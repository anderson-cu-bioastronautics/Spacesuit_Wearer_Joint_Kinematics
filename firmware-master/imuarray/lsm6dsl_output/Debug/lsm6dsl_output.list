
lsm6dsl_output.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00030ca4  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000658  08030e44  08030e44  00040e44  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0803149c  0803149c  00050634  2**0
                  CONTENTS
  4 .ARM          00000008  0803149c  0803149c  0004149c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080314a4  080314a4  00050634  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080314a4  080314a4  000414a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080314a8  080314a8  000414a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000634  20000000  080314ac  00050000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000041ec  20000634  08031ae0  00050634  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20004820  08031ae0  00054820  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00050634  2**0
                  CONTENTS, READONLY
 12 .debug_info   0008604e  00000000  00000000  00050664  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00015a01  00000000  00000000  000d66b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001e80  00000000  00000000  000ec0b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000072e8  00000000  00000000  000edf38  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00019cca  00000000  00000000  000f5220  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00046ca7  00000000  00000000  0010eeea  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    000957eb  00000000  00000000  00155b91  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      000000c7  00000000  00000000  001eb37c  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000afbc  00000000  00000000  001eb444  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    00059844  00000000  00000000  001f6400  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000634 	.word	0x20000634
 80001bc:	00000000 	.word	0x00000000
 80001c0:	08030e2c 	.word	0x08030e2c

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000638 	.word	0x20000638
 80001dc:	08030e2c 	.word	0x08030e2c

080001e0 <gsl_blas_sdsdot>:
#define INT(X) ((int)(X))

int
gsl_blas_sdsdot (float alpha, const gsl_vector_float * X,
                 const gsl_vector_float * Y, float *result)
{
 80001e0:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 80001e2:	680b      	ldr	r3, [r1, #0]
{
 80001e4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80001e6:	6800      	ldr	r0, [r0, #0]
 80001e8:	4298      	cmp	r0, r3
{
 80001ea:	b083      	sub	sp, #12
  if (X->size == Y->size)
 80001ec:	d008      	beq.n	8000200 <gsl_blas_sdsdot+0x20>
                      INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80001ee:	490b      	ldr	r1, [pc, #44]	; (800021c <gsl_blas_sdsdot+0x3c>)
 80001f0:	480b      	ldr	r0, [pc, #44]	; (8000220 <gsl_blas_sdsdot+0x40>)
 80001f2:	2313      	movs	r3, #19
 80001f4:	2239      	movs	r2, #57	; 0x39
 80001f6:	f002 fb33 	bl	8002860 <gsl_error>
 80001fa:	2013      	movs	r0, #19
    }
}
 80001fc:	b003      	add	sp, #12
 80001fe:	bd30      	pop	{r4, r5, pc}
        cblas_sdsdot (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
 8000200:	684b      	ldr	r3, [r1, #4]
 8000202:	9300      	str	r3, [sp, #0]
 8000204:	688b      	ldr	r3, [r1, #8]
 8000206:	4615      	mov	r5, r2
 8000208:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800020c:	f008 f80a 	bl	8008224 <cblas_sdsdot>
      return GSL_SUCCESS;
 8000210:	2000      	movs	r0, #0
      *result =
 8000212:	ed85 0a00 	vstr	s0, [r5]
}
 8000216:	b003      	add	sp, #12
 8000218:	bd30      	pop	{r4, r5, pc}
 800021a:	bf00      	nop
 800021c:	08030efc 	.word	0x08030efc
 8000220:	08030f04 	.word	0x08030f04

08000224 <gsl_blas_dsdot>:

int
gsl_blas_dsdot (const gsl_vector_float * X, const gsl_vector_float * Y,
                double *result)
{
 8000224:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 8000226:	680b      	ldr	r3, [r1, #0]
{
 8000228:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800022a:	6800      	ldr	r0, [r0, #0]
 800022c:	4298      	cmp	r0, r3
{
 800022e:	b083      	sub	sp, #12
  if (X->size == Y->size)
 8000230:	d008      	beq.n	8000244 <gsl_blas_dsdot+0x20>
                     INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000232:	490b      	ldr	r1, [pc, #44]	; (8000260 <gsl_blas_dsdot+0x3c>)
 8000234:	480b      	ldr	r0, [pc, #44]	; (8000264 <gsl_blas_dsdot+0x40>)
 8000236:	2313      	movs	r3, #19
 8000238:	224a      	movs	r2, #74	; 0x4a
 800023a:	f002 fb11 	bl	8002860 <gsl_error>
 800023e:	2013      	movs	r0, #19
    }
}
 8000240:	b003      	add	sp, #12
 8000242:	bd30      	pop	{r4, r5, pc}
        cblas_dsdot (INT (X->size), X->data, INT (X->stride), Y->data,
 8000244:	684b      	ldr	r3, [r1, #4]
 8000246:	9300      	str	r3, [sp, #0]
 8000248:	688b      	ldr	r3, [r1, #8]
 800024a:	4615      	mov	r5, r2
 800024c:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 8000250:	f00d fe4c 	bl	800deec <cblas_dsdot>
      return GSL_SUCCESS;
 8000254:	2000      	movs	r0, #0
      *result =
 8000256:	ed85 0b00 	vstr	d0, [r5]
}
 800025a:	b003      	add	sp, #12
 800025c:	bd30      	pop	{r4, r5, pc}
 800025e:	bf00      	nop
 8000260:	08030efc 	.word	0x08030efc
 8000264:	08030f04 	.word	0x08030f04

08000268 <gsl_blas_sdot>:

int
gsl_blas_sdot (const gsl_vector_float * X, const gsl_vector_float * Y,
               float *result)
{
 8000268:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 800026a:	680b      	ldr	r3, [r1, #0]
{
 800026c:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800026e:	6800      	ldr	r0, [r0, #0]
 8000270:	4298      	cmp	r0, r3
{
 8000272:	b083      	sub	sp, #12
  if (X->size == Y->size)
 8000274:	d008      	beq.n	8000288 <gsl_blas_sdot+0x20>
                    INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000276:	490b      	ldr	r1, [pc, #44]	; (80002a4 <gsl_blas_sdot+0x3c>)
 8000278:	480b      	ldr	r0, [pc, #44]	; (80002a8 <gsl_blas_sdot+0x40>)
 800027a:	2313      	movs	r3, #19
 800027c:	225b      	movs	r2, #91	; 0x5b
 800027e:	f002 faef 	bl	8002860 <gsl_error>
 8000282:	2013      	movs	r0, #19
    }
}
 8000284:	b003      	add	sp, #12
 8000286:	bd30      	pop	{r4, r5, pc}
        cblas_sdot (INT (X->size), X->data, INT (X->stride), Y->data,
 8000288:	684b      	ldr	r3, [r1, #4]
 800028a:	9300      	str	r3, [sp, #0]
 800028c:	688b      	ldr	r3, [r1, #8]
 800028e:	4615      	mov	r5, r2
 8000290:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 8000294:	f007 ff9e 	bl	80081d4 <cblas_sdot>
      return GSL_SUCCESS;
 8000298:	2000      	movs	r0, #0
      *result =
 800029a:	ed85 0a00 	vstr	s0, [r5]
}
 800029e:	b003      	add	sp, #12
 80002a0:	bd30      	pop	{r4, r5, pc}
 80002a2:	bf00      	nop
 80002a4:	08030efc 	.word	0x08030efc
 80002a8:	08030f04 	.word	0x08030f04

080002ac <gsl_blas_ddot>:

int
gsl_blas_ddot (const gsl_vector * X, const gsl_vector * Y, double *result)
{
 80002ac:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 80002ae:	680b      	ldr	r3, [r1, #0]
{
 80002b0:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80002b2:	6800      	ldr	r0, [r0, #0]
 80002b4:	4298      	cmp	r0, r3
{
 80002b6:	b083      	sub	sp, #12
  if (X->size == Y->size)
 80002b8:	d008      	beq.n	80002cc <gsl_blas_ddot+0x20>
                    INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80002ba:	490b      	ldr	r1, [pc, #44]	; (80002e8 <gsl_blas_ddot+0x3c>)
 80002bc:	480b      	ldr	r0, [pc, #44]	; (80002ec <gsl_blas_ddot+0x40>)
 80002be:	2313      	movs	r3, #19
 80002c0:	226b      	movs	r2, #107	; 0x6b
 80002c2:	f002 facd 	bl	8002860 <gsl_error>
 80002c6:	2013      	movs	r0, #19
    }
}
 80002c8:	b003      	add	sp, #12
 80002ca:	bd30      	pop	{r4, r5, pc}
        cblas_ddot (INT (X->size), X->data, INT (X->stride), Y->data,
 80002cc:	684b      	ldr	r3, [r1, #4]
 80002ce:	9300      	str	r3, [sp, #0]
 80002d0:	688b      	ldr	r3, [r1, #8]
 80002d2:	4615      	mov	r5, r2
 80002d4:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80002d8:	f00c f9d6 	bl	800c688 <cblas_ddot>
      return GSL_SUCCESS;
 80002dc:	2000      	movs	r0, #0
      *result =
 80002de:	ed85 0b00 	vstr	d0, [r5]
}
 80002e2:	b003      	add	sp, #12
 80002e4:	bd30      	pop	{r4, r5, pc}
 80002e6:	bf00      	nop
 80002e8:	08030efc 	.word	0x08030efc
 80002ec:	08030f04 	.word	0x08030f04

080002f0 <gsl_blas_cdotu>:


int
gsl_blas_cdotu (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotu)
{
 80002f0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80002f2:	680b      	ldr	r3, [r1, #0]
{
 80002f4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80002f6:	6800      	ldr	r0, [r0, #0]
 80002f8:	4298      	cmp	r0, r3
{
 80002fa:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80002fc:	d008      	beq.n	8000310 <gsl_blas_cdotu+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotu));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80002fe:	490a      	ldr	r1, [pc, #40]	; (8000328 <gsl_blas_cdotu+0x38>)
 8000300:	480a      	ldr	r0, [pc, #40]	; (800032c <gsl_blas_cdotu+0x3c>)
 8000302:	2313      	movs	r3, #19
 8000304:	227c      	movs	r2, #124	; 0x7c
 8000306:	f002 faab 	bl	8002860 <gsl_error>
 800030a:	2013      	movs	r0, #19
    }
}
 800030c:	b002      	add	sp, #8
 800030e:	bd10      	pop	{r4, pc}
      cblas_cdotu_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 8000310:	684b      	ldr	r3, [r1, #4]
 8000312:	e9cd 3200 	strd	r3, r2, [sp]
 8000316:	688b      	ldr	r3, [r1, #8]
 8000318:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800031c:	f012 fa58 	bl	80127d0 <cblas_cdotu_sub>
      return GSL_SUCCESS;
 8000320:	2000      	movs	r0, #0
}
 8000322:	b002      	add	sp, #8
 8000324:	bd10      	pop	{r4, pc}
 8000326:	bf00      	nop
 8000328:	08030efc 	.word	0x08030efc
 800032c:	08030f04 	.word	0x08030f04

08000330 <gsl_blas_cdotc>:


int
gsl_blas_cdotc (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotc)
{
 8000330:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000332:	680b      	ldr	r3, [r1, #0]
{
 8000334:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000336:	6800      	ldr	r0, [r0, #0]
 8000338:	4298      	cmp	r0, r3
{
 800033a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800033c:	d008      	beq.n	8000350 <gsl_blas_cdotc+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotc));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800033e:	490a      	ldr	r1, [pc, #40]	; (8000368 <gsl_blas_cdotc+0x38>)
 8000340:	480a      	ldr	r0, [pc, #40]	; (800036c <gsl_blas_cdotc+0x3c>)
 8000342:	2313      	movs	r3, #19
 8000344:	228d      	movs	r2, #141	; 0x8d
 8000346:	f002 fa8b 	bl	8002860 <gsl_error>
 800034a:	2013      	movs	r0, #19
    }
}
 800034c:	b002      	add	sp, #8
 800034e:	bd10      	pop	{r4, pc}
      cblas_cdotc_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 8000350:	684b      	ldr	r3, [r1, #4]
 8000352:	e9cd 3200 	strd	r3, r2, [sp]
 8000356:	688b      	ldr	r3, [r1, #8]
 8000358:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800035c:	f012 f9a4 	bl	80126a8 <cblas_cdotc_sub>
      return GSL_SUCCESS;
 8000360:	2000      	movs	r0, #0
}
 8000362:	b002      	add	sp, #8
 8000364:	bd10      	pop	{r4, pc}
 8000366:	bf00      	nop
 8000368:	08030efc 	.word	0x08030efc
 800036c:	08030f04 	.word	0x08030f04

08000370 <gsl_blas_zdotu>:


int
gsl_blas_zdotu (const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_complex * dotu)
{
 8000370:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000372:	680b      	ldr	r3, [r1, #0]
{
 8000374:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000376:	6800      	ldr	r0, [r0, #0]
 8000378:	4298      	cmp	r0, r3
{
 800037a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800037c:	d008      	beq.n	8000390 <gsl_blas_zdotu+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotu));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800037e:	490a      	ldr	r1, [pc, #40]	; (80003a8 <gsl_blas_zdotu+0x38>)
 8000380:	480a      	ldr	r0, [pc, #40]	; (80003ac <gsl_blas_zdotu+0x3c>)
 8000382:	2313      	movs	r3, #19
 8000384:	229e      	movs	r2, #158	; 0x9e
 8000386:	f002 fa6b 	bl	8002860 <gsl_error>
 800038a:	2013      	movs	r0, #19
    }
}
 800038c:	b002      	add	sp, #8
 800038e:	bd10      	pop	{r4, pc}
      cblas_zdotu_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 8000390:	684b      	ldr	r3, [r1, #4]
 8000392:	e9cd 3200 	strd	r3, r2, [sp]
 8000396:	688b      	ldr	r3, [r1, #8]
 8000398:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800039c:	f01a f82c 	bl	801a3f8 <cblas_zdotu_sub>
      return GSL_SUCCESS;
 80003a0:	2000      	movs	r0, #0
}
 80003a2:	b002      	add	sp, #8
 80003a4:	bd10      	pop	{r4, pc}
 80003a6:	bf00      	nop
 80003a8:	08030efc 	.word	0x08030efc
 80003ac:	08030f04 	.word	0x08030f04

080003b0 <gsl_blas_zdotc>:


int
gsl_blas_zdotc (const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_complex * dotc)
{
 80003b0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80003b2:	680b      	ldr	r3, [r1, #0]
{
 80003b4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80003b6:	6800      	ldr	r0, [r0, #0]
 80003b8:	4298      	cmp	r0, r3
{
 80003ba:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80003bc:	d008      	beq.n	80003d0 <gsl_blas_zdotc+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotc));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80003be:	490a      	ldr	r1, [pc, #40]	; (80003e8 <gsl_blas_zdotc+0x38>)
 80003c0:	480a      	ldr	r0, [pc, #40]	; (80003ec <gsl_blas_zdotc+0x3c>)
 80003c2:	2313      	movs	r3, #19
 80003c4:	22af      	movs	r2, #175	; 0xaf
 80003c6:	f002 fa4b 	bl	8002860 <gsl_error>
 80003ca:	2013      	movs	r0, #19
    }
}
 80003cc:	b002      	add	sp, #8
 80003ce:	bd10      	pop	{r4, pc}
      cblas_zdotc_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 80003d0:	684b      	ldr	r3, [r1, #4]
 80003d2:	e9cd 3200 	strd	r3, r2, [sp]
 80003d6:	688b      	ldr	r3, [r1, #8]
 80003d8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80003dc:	f019 ff7c 	bl	801a2d8 <cblas_zdotc_sub>
      return GSL_SUCCESS;
 80003e0:	2000      	movs	r0, #0
}
 80003e2:	b002      	add	sp, #8
 80003e4:	bd10      	pop	{r4, pc}
 80003e6:	bf00      	nop
 80003e8:	08030efc 	.word	0x08030efc
 80003ec:	08030f04 	.word	0x08030f04

080003f0 <gsl_blas_snrm2>:
/* Norms of vectors */

float
gsl_blas_snrm2 (const gsl_vector_float * X)
{
  return cblas_snrm2 (INT (X->size), X->data, INT (X->stride));
 80003f0:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 80003f4:	6800      	ldr	r0, [r0, #0]
 80003f6:	f008 bc8d 	b.w	8008d14 <cblas_snrm2>
 80003fa:	bf00      	nop

080003fc <gsl_blas_dnrm2>:
}

double
gsl_blas_dnrm2 (const gsl_vector * X)
{
  return cblas_dnrm2 (INT (X->size), X->data, INT (X->stride));
 80003fc:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000400:	6800      	ldr	r0, [r0, #0]
 8000402:	f00c bff9 	b.w	800d3f8 <cblas_dnrm2>
 8000406:	bf00      	nop

08000408 <gsl_blas_scnrm2>:
}

float
gsl_blas_scnrm2 (const gsl_vector_complex_float * X)
{
  return cblas_scnrm2 (INT (X->size), X->data, INT (X->stride));
 8000408:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 800040c:	6800      	ldr	r0, [r0, #0]
 800040e:	f007 be3f 	b.w	8008090 <cblas_scnrm2>
 8000412:	bf00      	nop

08000414 <gsl_blas_dznrm2>:
}

double
gsl_blas_dznrm2 (const gsl_vector_complex * X)
{
  return cblas_dznrm2 (INT (X->size), X->data, INT (X->stride));
 8000414:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000418:	6800      	ldr	r0, [r0, #0]
 800041a:	f012 b80d 	b.w	8012438 <cblas_dznrm2>
 800041e:	bf00      	nop

08000420 <gsl_blas_sasum>:
/* Absolute sums of vectors */

float
gsl_blas_sasum (const gsl_vector_float * X)
{
  return cblas_sasum (INT (X->size), X->data, INT (X->stride));
 8000420:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000424:	6800      	ldr	r0, [r0, #0]
 8000426:	f007 bd5b 	b.w	8007ee0 <cblas_sasum>
 800042a:	bf00      	nop

0800042c <gsl_blas_dasum>:
}

double
gsl_blas_dasum (const gsl_vector * X)
{
  return cblas_dasum (INT (X->size), X->data, INT (X->stride));
 800042c:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000430:	6800      	ldr	r0, [r0, #0]
 8000432:	f00c b823 	b.w	800c47c <cblas_dasum>
 8000436:	bf00      	nop

08000438 <gsl_blas_scasum>:
}

float
gsl_blas_scasum (const gsl_vector_complex_float * X)
{
  return cblas_scasum (INT (X->size), X->data, INT (X->stride));
 8000438:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 800043c:	6800      	ldr	r0, [r0, #0]
 800043e:	f007 bde5 	b.w	800800c <cblas_scasum>
 8000442:	bf00      	nop

08000444 <gsl_blas_dzasum>:
}

double
gsl_blas_dzasum (const gsl_vector_complex * X)
{
  return cblas_dzasum (INT (X->size), X->data, INT (X->stride));
 8000444:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000448:	6800      	ldr	r0, [r0, #0]
 800044a:	f011 bfb9 	b.w	80123c0 <cblas_dzasum>
 800044e:	bf00      	nop

08000450 <gsl_blas_isamax>:
/* Maximum elements of vectors */

CBLAS_INDEX_t
gsl_blas_isamax (const gsl_vector_float * X)
{
  return cblas_isamax (INT (X->size), X->data, INT (X->stride));
 8000450:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000454:	6800      	ldr	r0, [r0, #0]
 8000456:	f028 b8eb 	b.w	8028630 <cblas_isamax>
 800045a:	bf00      	nop

0800045c <gsl_blas_idamax>:
}

CBLAS_INDEX_t
gsl_blas_idamax (const gsl_vector * X)
{
  return cblas_idamax (INT (X->size), X->data, INT (X->stride));
 800045c:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000460:	6800      	ldr	r0, [r0, #0]
 8000462:	f028 b8b7 	b.w	80285d4 <cblas_idamax>
 8000466:	bf00      	nop

08000468 <gsl_blas_icamax>:
}

CBLAS_INDEX_t
gsl_blas_icamax (const gsl_vector_complex_float * X)
{
  return cblas_icamax (INT (X->size), X->data, INT (X->stride));
 8000468:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 800046c:	6800      	ldr	r0, [r0, #0]
 800046e:	f028 b887 	b.w	8028580 <cblas_icamax>
 8000472:	bf00      	nop

08000474 <gsl_blas_izamax>:
}

CBLAS_INDEX_t
gsl_blas_izamax (const gsl_vector_complex * X)
{
  return cblas_izamax (INT (X->size), X->data, INT (X->stride));
 8000474:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000478:	6800      	ldr	r0, [r0, #0]
 800047a:	f028 b8fd 	b.w	8028678 <cblas_izamax>
 800047e:	bf00      	nop

08000480 <gsl_blas_sswap>:

/* Swap vectors */

int
gsl_blas_sswap (gsl_vector_float * X, gsl_vector_float * Y)
{
 8000480:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000482:	680b      	ldr	r3, [r1, #0]
{
 8000484:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000486:	6800      	ldr	r0, [r0, #0]
 8000488:	4298      	cmp	r0, r3
{
 800048a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800048c:	d009      	beq.n	80004a2 <gsl_blas_sswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800048e:	490a      	ldr	r1, [pc, #40]	; (80004b8 <gsl_blas_sswap+0x38>)
 8000490:	480a      	ldr	r0, [pc, #40]	; (80004bc <gsl_blas_sswap+0x3c>)
 8000492:	2313      	movs	r3, #19
 8000494:	f240 120f 	movw	r2, #271	; 0x10f
 8000498:	f002 f9e2 	bl	8002860 <gsl_error>
 800049c:	2013      	movs	r0, #19
    }
}
 800049e:	b002      	add	sp, #8
 80004a0:	bd10      	pop	{r4, pc}
      cblas_sswap (INT (X->size), X->data, INT (X->stride), Y->data,
 80004a2:	684b      	ldr	r3, [r1, #4]
 80004a4:	9300      	str	r3, [sp, #0]
 80004a6:	688b      	ldr	r3, [r1, #8]
 80004a8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80004ac:	f008 fed8 	bl	8009260 <cblas_sswap>
      return GSL_SUCCESS;
 80004b0:	2000      	movs	r0, #0
}
 80004b2:	b002      	add	sp, #8
 80004b4:	bd10      	pop	{r4, pc}
 80004b6:	bf00      	nop
 80004b8:	08030efc 	.word	0x08030efc
 80004bc:	08030f04 	.word	0x08030f04

080004c0 <gsl_blas_dswap>:

int
gsl_blas_dswap (gsl_vector * X, gsl_vector * Y)
{
 80004c0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80004c2:	680b      	ldr	r3, [r1, #0]
{
 80004c4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80004c6:	6800      	ldr	r0, [r0, #0]
 80004c8:	4298      	cmp	r0, r3
{
 80004ca:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80004cc:	d009      	beq.n	80004e2 <gsl_blas_dswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80004ce:	490a      	ldr	r1, [pc, #40]	; (80004f8 <gsl_blas_dswap+0x38>)
 80004d0:	480a      	ldr	r0, [pc, #40]	; (80004fc <gsl_blas_dswap+0x3c>)
 80004d2:	2313      	movs	r3, #19
 80004d4:	f44f 728f 	mov.w	r2, #286	; 0x11e
 80004d8:	f002 f9c2 	bl	8002860 <gsl_error>
 80004dc:	2013      	movs	r0, #19
    };
}
 80004de:	b002      	add	sp, #8
 80004e0:	bd10      	pop	{r4, pc}
      cblas_dswap (INT (X->size), X->data, INT (X->stride), Y->data,
 80004e2:	684b      	ldr	r3, [r1, #4]
 80004e4:	9300      	str	r3, [sp, #0]
 80004e6:	688b      	ldr	r3, [r1, #8]
 80004e8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80004ec:	f00d fd3c 	bl	800df68 <cblas_dswap>
      return GSL_SUCCESS;
 80004f0:	2000      	movs	r0, #0
}
 80004f2:	b002      	add	sp, #8
 80004f4:	bd10      	pop	{r4, pc}
 80004f6:	bf00      	nop
 80004f8:	08030efc 	.word	0x08030efc
 80004fc:	08030f04 	.word	0x08030f04

08000500 <gsl_blas_cswap>:

int
gsl_blas_cswap (gsl_vector_complex_float * X, gsl_vector_complex_float * Y)
{
 8000500:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000502:	680b      	ldr	r3, [r1, #0]
{
 8000504:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000506:	6800      	ldr	r0, [r0, #0]
 8000508:	4298      	cmp	r0, r3
{
 800050a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800050c:	d009      	beq.n	8000522 <gsl_blas_cswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800050e:	490a      	ldr	r1, [pc, #40]	; (8000538 <gsl_blas_cswap+0x38>)
 8000510:	480a      	ldr	r0, [pc, #40]	; (800053c <gsl_blas_cswap+0x3c>)
 8000512:	2313      	movs	r3, #19
 8000514:	f240 122d 	movw	r2, #301	; 0x12d
 8000518:	f002 f9a2 	bl	8002860 <gsl_error>
 800051c:	2013      	movs	r0, #19
    }
}
 800051e:	b002      	add	sp, #8
 8000520:	bd10      	pop	{r4, pc}
      cblas_cswap (INT (X->size), X->data, INT (X->stride), Y->data,
 8000522:	684b      	ldr	r3, [r1, #4]
 8000524:	9300      	str	r3, [sp, #0]
 8000526:	688b      	ldr	r3, [r1, #8]
 8000528:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800052c:	f015 fdca 	bl	80160c4 <cblas_cswap>
      return GSL_SUCCESS;
 8000530:	2000      	movs	r0, #0
}
 8000532:	b002      	add	sp, #8
 8000534:	bd10      	pop	{r4, pc}
 8000536:	bf00      	nop
 8000538:	08030efc 	.word	0x08030efc
 800053c:	08030f04 	.word	0x08030f04

08000540 <gsl_blas_zswap>:

int
gsl_blas_zswap (gsl_vector_complex * X, gsl_vector_complex * Y)
{
 8000540:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000542:	680b      	ldr	r3, [r1, #0]
{
 8000544:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000546:	6800      	ldr	r0, [r0, #0]
 8000548:	4298      	cmp	r0, r3
{
 800054a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800054c:	d009      	beq.n	8000562 <gsl_blas_zswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800054e:	490a      	ldr	r1, [pc, #40]	; (8000578 <gsl_blas_zswap+0x38>)
 8000550:	480a      	ldr	r0, [pc, #40]	; (800057c <gsl_blas_zswap+0x3c>)
 8000552:	2313      	movs	r3, #19
 8000554:	f44f 729e 	mov.w	r2, #316	; 0x13c
 8000558:	f002 f982 	bl	8002860 <gsl_error>
 800055c:	2013      	movs	r0, #19
    }
}
 800055e:	b002      	add	sp, #8
 8000560:	bd10      	pop	{r4, pc}
      cblas_zswap (INT (X->size), X->data, INT (X->stride), Y->data,
 8000562:	684b      	ldr	r3, [r1, #4]
 8000564:	9300      	str	r3, [sp, #0]
 8000566:	688b      	ldr	r3, [r1, #8]
 8000568:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800056c:	f020 fb26 	bl	8020bbc <cblas_zswap>
      return GSL_SUCCESS;
 8000570:	2000      	movs	r0, #0
}
 8000572:	b002      	add	sp, #8
 8000574:	bd10      	pop	{r4, pc}
 8000576:	bf00      	nop
 8000578:	08030efc 	.word	0x08030efc
 800057c:	08030f04 	.word	0x08030f04

08000580 <gsl_blas_scopy>:

/* Copy vectors */

int
gsl_blas_scopy (const gsl_vector_float * X, gsl_vector_float * Y)
{
 8000580:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000582:	680b      	ldr	r3, [r1, #0]
{
 8000584:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000586:	6800      	ldr	r0, [r0, #0]
 8000588:	4298      	cmp	r0, r3
{
 800058a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800058c:	d009      	beq.n	80005a2 <gsl_blas_scopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800058e:	490a      	ldr	r1, [pc, #40]	; (80005b8 <gsl_blas_scopy+0x38>)
 8000590:	480a      	ldr	r0, [pc, #40]	; (80005bc <gsl_blas_scopy+0x3c>)
 8000592:	2313      	movs	r3, #19
 8000594:	f44f 72a7 	mov.w	r2, #334	; 0x14e
 8000598:	f002 f962 	bl	8002860 <gsl_error>
 800059c:	2013      	movs	r0, #19
    }
}
 800059e:	b002      	add	sp, #8
 80005a0:	bd10      	pop	{r4, pc}
      cblas_scopy (INT (X->size), X->data, INT (X->stride), Y->data,
 80005a2:	684b      	ldr	r3, [r1, #4]
 80005a4:	9300      	str	r3, [sp, #0]
 80005a6:	688b      	ldr	r3, [r1, #8]
 80005a8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80005ac:	f007 fdf2 	bl	8008194 <cblas_scopy>
      return GSL_SUCCESS;
 80005b0:	2000      	movs	r0, #0
}
 80005b2:	b002      	add	sp, #8
 80005b4:	bd10      	pop	{r4, pc}
 80005b6:	bf00      	nop
 80005b8:	08030efc 	.word	0x08030efc
 80005bc:	08030f04 	.word	0x08030f04

080005c0 <gsl_blas_dcopy>:

int
gsl_blas_dcopy (const gsl_vector * X, gsl_vector * Y)
{
 80005c0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80005c2:	680b      	ldr	r3, [r1, #0]
{
 80005c4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80005c6:	6800      	ldr	r0, [r0, #0]
 80005c8:	4298      	cmp	r0, r3
{
 80005ca:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80005cc:	d009      	beq.n	80005e2 <gsl_blas_dcopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80005ce:	490a      	ldr	r1, [pc, #40]	; (80005f8 <gsl_blas_dcopy+0x38>)
 80005d0:	480a      	ldr	r0, [pc, #40]	; (80005fc <gsl_blas_dcopy+0x3c>)
 80005d2:	2313      	movs	r3, #19
 80005d4:	f240 125d 	movw	r2, #349	; 0x15d
 80005d8:	f002 f942 	bl	8002860 <gsl_error>
 80005dc:	2013      	movs	r0, #19
    }
}
 80005de:	b002      	add	sp, #8
 80005e0:	bd10      	pop	{r4, pc}
      cblas_dcopy (INT (X->size), X->data, INT (X->stride), Y->data,
 80005e2:	684b      	ldr	r3, [r1, #4]
 80005e4:	9300      	str	r3, [sp, #0]
 80005e6:	688b      	ldr	r3, [r1, #8]
 80005e8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80005ec:	f00c f82a 	bl	800c644 <cblas_dcopy>
      return GSL_SUCCESS;
 80005f0:	2000      	movs	r0, #0
}
 80005f2:	b002      	add	sp, #8
 80005f4:	bd10      	pop	{r4, pc}
 80005f6:	bf00      	nop
 80005f8:	08030efc 	.word	0x08030efc
 80005fc:	08030f04 	.word	0x08030f04

08000600 <gsl_blas_ccopy>:

int
gsl_blas_ccopy (const gsl_vector_complex_float * X,
                gsl_vector_complex_float * Y)
{
 8000600:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000602:	680b      	ldr	r3, [r1, #0]
{
 8000604:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000606:	6800      	ldr	r0, [r0, #0]
 8000608:	4298      	cmp	r0, r3
{
 800060a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800060c:	d009      	beq.n	8000622 <gsl_blas_ccopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800060e:	490a      	ldr	r1, [pc, #40]	; (8000638 <gsl_blas_ccopy+0x38>)
 8000610:	480a      	ldr	r0, [pc, #40]	; (800063c <gsl_blas_ccopy+0x3c>)
 8000612:	2313      	movs	r3, #19
 8000614:	f240 126d 	movw	r2, #365	; 0x16d
 8000618:	f002 f922 	bl	8002860 <gsl_error>
 800061c:	2013      	movs	r0, #19
    }
}
 800061e:	b002      	add	sp, #8
 8000620:	bd10      	pop	{r4, pc}
      cblas_ccopy (INT (X->size), X->data, INT (X->stride), Y->data,
 8000622:	684b      	ldr	r3, [r1, #4]
 8000624:	9300      	str	r3, [sp, #0]
 8000626:	688b      	ldr	r3, [r1, #8]
 8000628:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800062c:	f012 f81a 	bl	8012664 <cblas_ccopy>
      return GSL_SUCCESS;
 8000630:	2000      	movs	r0, #0
}
 8000632:	b002      	add	sp, #8
 8000634:	bd10      	pop	{r4, pc}
 8000636:	bf00      	nop
 8000638:	08030efc 	.word	0x08030efc
 800063c:	08030f04 	.word	0x08030f04

08000640 <gsl_blas_zcopy>:

int
gsl_blas_zcopy (const gsl_vector_complex * X, gsl_vector_complex * Y)
{
 8000640:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000642:	680b      	ldr	r3, [r1, #0]
{
 8000644:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000646:	6800      	ldr	r0, [r0, #0]
 8000648:	4298      	cmp	r0, r3
{
 800064a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800064c:	d009      	beq.n	8000662 <gsl_blas_zcopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800064e:	490a      	ldr	r1, [pc, #40]	; (8000678 <gsl_blas_zcopy+0x38>)
 8000650:	480a      	ldr	r0, [pc, #40]	; (800067c <gsl_blas_zcopy+0x3c>)
 8000652:	2313      	movs	r3, #19
 8000654:	f44f 72be 	mov.w	r2, #380	; 0x17c
 8000658:	f002 f902 	bl	8002860 <gsl_error>
 800065c:	2013      	movs	r0, #19
    }
}
 800065e:	b002      	add	sp, #8
 8000660:	bd10      	pop	{r4, pc}
      cblas_zcopy (INT (X->size), X->data, INT (X->stride), Y->data,
 8000662:	684b      	ldr	r3, [r1, #4]
 8000664:	9300      	str	r3, [sp, #0]
 8000666:	688b      	ldr	r3, [r1, #8]
 8000668:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800066c:	f019 fe0e 	bl	801a28c <cblas_zcopy>
      return GSL_SUCCESS;
 8000670:	2000      	movs	r0, #0
}
 8000672:	b002      	add	sp, #8
 8000674:	bd10      	pop	{r4, pc}
 8000676:	bf00      	nop
 8000678:	08030efc 	.word	0x08030efc
 800067c:	08030f04 	.word	0x08030f04

08000680 <gsl_blas_saxpy>:

/* Compute Y = alpha X + Y */

int
gsl_blas_saxpy (float alpha, const gsl_vector_float * X, gsl_vector_float * Y)
{
 8000680:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000682:	680b      	ldr	r3, [r1, #0]
{
 8000684:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000686:	6800      	ldr	r0, [r0, #0]
 8000688:	4298      	cmp	r0, r3
{
 800068a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800068c:	d009      	beq.n	80006a2 <gsl_blas_saxpy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800068e:	490a      	ldr	r1, [pc, #40]	; (80006b8 <gsl_blas_saxpy+0x38>)
 8000690:	480a      	ldr	r0, [pc, #40]	; (80006bc <gsl_blas_saxpy+0x3c>)
 8000692:	2313      	movs	r3, #19
 8000694:	f44f 72c7 	mov.w	r2, #398	; 0x18e
 8000698:	f002 f8e2 	bl	8002860 <gsl_error>
 800069c:	2013      	movs	r0, #19
    }
}
 800069e:	b002      	add	sp, #8
 80006a0:	bd10      	pop	{r4, pc}
      cblas_saxpy (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
 80006a2:	684b      	ldr	r3, [r1, #4]
 80006a4:	9300      	str	r3, [sp, #0]
 80006a6:	688b      	ldr	r3, [r1, #8]
 80006a8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80006ac:	f007 fc30 	bl	8007f10 <cblas_saxpy>
      return GSL_SUCCESS;
 80006b0:	2000      	movs	r0, #0
}
 80006b2:	b002      	add	sp, #8
 80006b4:	bd10      	pop	{r4, pc}
 80006b6:	bf00      	nop
 80006b8:	08030efc 	.word	0x08030efc
 80006bc:	08030f04 	.word	0x08030f04

080006c0 <gsl_blas_daxpy>:

int
gsl_blas_daxpy (double alpha, const gsl_vector * X, gsl_vector * Y)
{
 80006c0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80006c2:	680b      	ldr	r3, [r1, #0]
{
 80006c4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80006c6:	6800      	ldr	r0, [r0, #0]
 80006c8:	4298      	cmp	r0, r3
{
 80006ca:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80006cc:	d009      	beq.n	80006e2 <gsl_blas_daxpy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80006ce:	490a      	ldr	r1, [pc, #40]	; (80006f8 <gsl_blas_daxpy+0x38>)
 80006d0:	480a      	ldr	r0, [pc, #40]	; (80006fc <gsl_blas_daxpy+0x3c>)
 80006d2:	2313      	movs	r3, #19
 80006d4:	f240 129d 	movw	r2, #413	; 0x19d
 80006d8:	f002 f8c2 	bl	8002860 <gsl_error>
 80006dc:	2013      	movs	r0, #19
    }
}
 80006de:	b002      	add	sp, #8
 80006e0:	bd10      	pop	{r4, pc}
      cblas_daxpy (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
 80006e2:	684b      	ldr	r3, [r1, #4]
 80006e4:	9300      	str	r3, [sp, #0]
 80006e6:	688b      	ldr	r3, [r1, #8]
 80006e8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80006ec:	f00b feec 	bl	800c4c8 <cblas_daxpy>
      return GSL_SUCCESS;
 80006f0:	2000      	movs	r0, #0
}
 80006f2:	b002      	add	sp, #8
 80006f4:	bd10      	pop	{r4, pc}
 80006f6:	bf00      	nop
 80006f8:	08030efc 	.word	0x08030efc
 80006fc:	08030f04 	.word	0x08030f04

08000700 <gsl_blas_caxpy>:

int
gsl_blas_caxpy (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                gsl_vector_complex_float * Y)
{
 8000700:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000702:	680b      	ldr	r3, [r1, #0]
{
 8000704:	4602      	mov	r2, r0
  if (X->size == Y->size)
 8000706:	6800      	ldr	r0, [r0, #0]
{
 8000708:	b084      	sub	sp, #16
  if (X->size == Y->size)
 800070a:	4298      	cmp	r0, r3
{
 800070c:	ed8d 0a02 	vstr	s0, [sp, #8]
 8000710:	edcd 0a03 	vstr	s1, [sp, #12]
  if (X->size == Y->size)
 8000714:	d009      	beq.n	800072a <gsl_blas_caxpy+0x2a>
                   INT (X->stride), Y->data, INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000716:	490b      	ldr	r1, [pc, #44]	; (8000744 <gsl_blas_caxpy+0x44>)
 8000718:	480b      	ldr	r0, [pc, #44]	; (8000748 <gsl_blas_caxpy+0x48>)
 800071a:	2313      	movs	r3, #19
 800071c:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 8000720:	f002 f89e 	bl	8002860 <gsl_error>
 8000724:	2013      	movs	r0, #19
    }
}
 8000726:	b004      	add	sp, #16
 8000728:	bd10      	pop	{r4, pc}
      cblas_caxpy (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 800072a:	e9d1 4301 	ldrd	r4, r3, [r1, #4]
 800072e:	e9cd 3400 	strd	r3, r4, [sp]
 8000732:	a902      	add	r1, sp, #8
 8000734:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
 8000738:	f011 ff44 	bl	80125c4 <cblas_caxpy>
      return GSL_SUCCESS;
 800073c:	2000      	movs	r0, #0
}
 800073e:	b004      	add	sp, #16
 8000740:	bd10      	pop	{r4, pc}
 8000742:	bf00      	nop
 8000744:	08030efc 	.word	0x08030efc
 8000748:	08030f04 	.word	0x08030f04

0800074c <gsl_blas_zaxpy>:

int
gsl_blas_zaxpy (const gsl_complex alpha, const gsl_vector_complex * X,
                gsl_vector_complex * Y)
{
 800074c:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 800074e:	680b      	ldr	r3, [r1, #0]
{
 8000750:	4602      	mov	r2, r0
  if (X->size == Y->size)
 8000752:	6800      	ldr	r0, [r0, #0]
{
 8000754:	b086      	sub	sp, #24
  if (X->size == Y->size)
 8000756:	4298      	cmp	r0, r3
{
 8000758:	ed8d 0b02 	vstr	d0, [sp, #8]
 800075c:	ed8d 1b04 	vstr	d1, [sp, #16]
  if (X->size == Y->size)
 8000760:	d009      	beq.n	8000776 <gsl_blas_zaxpy+0x2a>
                   INT (X->stride), Y->data, INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000762:	490b      	ldr	r1, [pc, #44]	; (8000790 <gsl_blas_zaxpy+0x44>)
 8000764:	480b      	ldr	r0, [pc, #44]	; (8000794 <gsl_blas_zaxpy+0x48>)
 8000766:	2313      	movs	r3, #19
 8000768:	f44f 72df 	mov.w	r2, #446	; 0x1be
 800076c:	f002 f878 	bl	8002860 <gsl_error>
 8000770:	2013      	movs	r0, #19
    }
}
 8000772:	b006      	add	sp, #24
 8000774:	bd10      	pop	{r4, pc}
      cblas_zaxpy (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 8000776:	e9d1 4301 	ldrd	r4, r3, [r1, #4]
 800077a:	e9cd 3400 	strd	r3, r4, [sp]
 800077e:	a902      	add	r1, sp, #8
 8000780:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
 8000784:	f019 fcee 	bl	801a164 <cblas_zaxpy>
      return GSL_SUCCESS;
 8000788:	2000      	movs	r0, #0
}
 800078a:	b006      	add	sp, #24
 800078c:	bd10      	pop	{r4, pc}
 800078e:	bf00      	nop
 8000790:	08030efc 	.word	0x08030efc
 8000794:	08030f04 	.word	0x08030f04

08000798 <gsl_blas_srotg>:

/* Generate rotation */

int
gsl_blas_srotg (float a[], float b[], float c[], float s[])
{
 8000798:	b508      	push	{r3, lr}
  cblas_srotg (a, b, c, s);
 800079a:	f008 fb47 	bl	8008e2c <cblas_srotg>
  return GSL_SUCCESS;
}
 800079e:	2000      	movs	r0, #0
 80007a0:	bd08      	pop	{r3, pc}
 80007a2:	bf00      	nop

080007a4 <gsl_blas_drotg>:

int
gsl_blas_drotg (double a[], double b[], double c[], double s[])
{
 80007a4:	b508      	push	{r3, lr}
  cblas_drotg (a, b, c, s);
 80007a6:	f00c ff23 	bl	800d5f0 <cblas_drotg>
  return GSL_SUCCESS;
}
 80007aa:	2000      	movs	r0, #0
 80007ac:	bd08      	pop	{r3, pc}
 80007ae:	bf00      	nop

080007b0 <gsl_blas_srot>:

/* Apply rotation to vectors */

int
gsl_blas_srot (gsl_vector_float * X, gsl_vector_float * Y, float c, float s)
{
 80007b0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80007b2:	680b      	ldr	r3, [r1, #0]
{
 80007b4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80007b6:	6800      	ldr	r0, [r0, #0]
 80007b8:	4298      	cmp	r0, r3
{
 80007ba:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80007bc:	d009      	beq.n	80007d2 <gsl_blas_srot+0x22>
                  INT (Y->stride), c, s);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80007be:	490a      	ldr	r1, [pc, #40]	; (80007e8 <gsl_blas_srot+0x38>)
 80007c0:	480a      	ldr	r0, [pc, #40]	; (80007ec <gsl_blas_srot+0x3c>)
 80007c2:	2313      	movs	r3, #19
 80007c4:	f240 12df 	movw	r2, #479	; 0x1df
 80007c8:	f002 f84a 	bl	8002860 <gsl_error>
 80007cc:	2013      	movs	r0, #19
    }
}
 80007ce:	b002      	add	sp, #8
 80007d0:	bd10      	pop	{r4, pc}
      cblas_srot (INT (X->size), X->data, INT (X->stride), Y->data,
 80007d2:	684b      	ldr	r3, [r1, #4]
 80007d4:	9300      	str	r3, [sp, #0]
 80007d6:	688b      	ldr	r3, [r1, #8]
 80007d8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80007dc:	f008 faf6 	bl	8008dcc <cblas_srot>
      return GSL_SUCCESS;
 80007e0:	2000      	movs	r0, #0
}
 80007e2:	b002      	add	sp, #8
 80007e4:	bd10      	pop	{r4, pc}
 80007e6:	bf00      	nop
 80007e8:	08030efc 	.word	0x08030efc
 80007ec:	08030f04 	.word	0x08030f04

080007f0 <gsl_blas_drot>:

int
gsl_blas_drot (gsl_vector * X, gsl_vector * Y, const double c, const double s)
{
 80007f0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80007f2:	680b      	ldr	r3, [r1, #0]
{
 80007f4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80007f6:	6800      	ldr	r0, [r0, #0]
 80007f8:	4298      	cmp	r0, r3
{
 80007fa:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80007fc:	d009      	beq.n	8000812 <gsl_blas_drot+0x22>
                  INT (Y->stride), c, s);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80007fe:	490a      	ldr	r1, [pc, #40]	; (8000828 <gsl_blas_drot+0x38>)
 8000800:	480a      	ldr	r0, [pc, #40]	; (800082c <gsl_blas_drot+0x3c>)
 8000802:	2313      	movs	r3, #19
 8000804:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
 8000808:	f002 f82a 	bl	8002860 <gsl_error>
 800080c:	2013      	movs	r0, #19
    }
}
 800080e:	b002      	add	sp, #8
 8000810:	bd10      	pop	{r4, pc}
      cblas_drot (INT (X->size), X->data, INT (X->stride), Y->data,
 8000812:	684b      	ldr	r3, [r1, #4]
 8000814:	9300      	str	r3, [sp, #0]
 8000816:	688b      	ldr	r3, [r1, #8]
 8000818:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800081c:	f00c fe76 	bl	800d50c <cblas_drot>
      return GSL_SUCCESS;
 8000820:	2000      	movs	r0, #0
}
 8000822:	b002      	add	sp, #8
 8000824:	bd10      	pop	{r4, pc}
 8000826:	bf00      	nop
 8000828:	08030efc 	.word	0x08030efc
 800082c:	08030f04 	.word	0x08030f04

08000830 <gsl_blas_srotmg>:

/* Generate modified rotation */

int
gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[])
{
 8000830:	b508      	push	{r3, lr}
  cblas_srotmg (d1, d2, b1, b2, P);
 8000832:	f008 fbeb 	bl	800900c <cblas_srotmg>
  return GSL_SUCCESS;
}
 8000836:	2000      	movs	r0, #0
 8000838:	bd08      	pop	{r3, pc}
 800083a:	bf00      	nop

0800083c <gsl_blas_drotmg>:

int
gsl_blas_drotmg (double d1[], double d2[], double b1[], double b2, double P[])
{
 800083c:	b508      	push	{r3, lr}
  cblas_drotmg (d1, d2, b1, b2, P);
 800083e:	f00d f89b 	bl	800d978 <cblas_drotmg>
  return GSL_SUCCESS;
}
 8000842:	2000      	movs	r0, #0
 8000844:	bd08      	pop	{r3, pc}
 8000846:	bf00      	nop

08000848 <gsl_blas_srotm>:

/* Apply modified rotation */

int
gsl_blas_srotm (gsl_vector_float * X, gsl_vector_float * Y, const float P[])
{
 8000848:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 800084a:	680b      	ldr	r3, [r1, #0]
{
 800084c:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800084e:	6800      	ldr	r0, [r0, #0]
 8000850:	4298      	cmp	r0, r3
{
 8000852:	b082      	sub	sp, #8
  if (X->size == Y->size)
 8000854:	d009      	beq.n	800086a <gsl_blas_srotm+0x22>
                   INT (Y->stride), P);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000856:	490a      	ldr	r1, [pc, #40]	; (8000880 <gsl_blas_srotm+0x38>)
 8000858:	480a      	ldr	r0, [pc, #40]	; (8000884 <gsl_blas_srotm+0x3c>)
 800085a:	2313      	movs	r3, #19
 800085c:	f240 2211 	movw	r2, #529	; 0x211
 8000860:	f001 fffe 	bl	8002860 <gsl_error>
 8000864:	2013      	movs	r0, #19
    }
}
 8000866:	b002      	add	sp, #8
 8000868:	bd10      	pop	{r4, pc}
      cblas_srotm (INT (X->size), X->data, INT (X->stride), Y->data,
 800086a:	684b      	ldr	r3, [r1, #4]
 800086c:	e9cd 3200 	strd	r3, r2, [sp]
 8000870:	688b      	ldr	r3, [r1, #8]
 8000872:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 8000876:	f008 fb5b 	bl	8008f30 <cblas_srotm>
      return GSL_SUCCESS;
 800087a:	2000      	movs	r0, #0
}
 800087c:	b002      	add	sp, #8
 800087e:	bd10      	pop	{r4, pc}
 8000880:	08030efc 	.word	0x08030efc
 8000884:	08030f04 	.word	0x08030f04

08000888 <gsl_blas_drotm>:

int
gsl_blas_drotm (gsl_vector * X, gsl_vector * Y, const double P[])
{
 8000888:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 800088a:	680b      	ldr	r3, [r1, #0]
{
 800088c:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800088e:	6800      	ldr	r0, [r0, #0]
 8000890:	4298      	cmp	r0, r3
{
 8000892:	b082      	sub	sp, #8
  if (X->size == Y->size)
 8000894:	d009      	beq.n	80008aa <gsl_blas_drotm+0x22>
                   INT (Y->stride), P);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000896:	490a      	ldr	r1, [pc, #40]	; (80008c0 <gsl_blas_drotm+0x38>)
 8000898:	480a      	ldr	r0, [pc, #40]	; (80008c4 <gsl_blas_drotm+0x3c>)
 800089a:	2313      	movs	r3, #19
 800089c:	f44f 7208 	mov.w	r2, #544	; 0x220
 80008a0:	f001 ffde 	bl	8002860 <gsl_error>
 80008a4:	2013      	movs	r0, #19
    }
}
 80008a6:	b002      	add	sp, #8
 80008a8:	bd10      	pop	{r4, pc}
      cblas_drotm (INT (X->size), X->data, INT (X->stride), Y->data,
 80008aa:	684b      	ldr	r3, [r1, #4]
 80008ac:	e9cd 3200 	strd	r3, r2, [sp]
 80008b0:	688b      	ldr	r3, [r1, #8]
 80008b2:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80008b6:	f00c ff77 	bl	800d7a8 <cblas_drotm>
      return GSL_SUCCESS;
 80008ba:	2000      	movs	r0, #0
}
 80008bc:	b002      	add	sp, #8
 80008be:	bd10      	pop	{r4, pc}
 80008c0:	08030efc 	.word	0x08030efc
 80008c4:	08030f04 	.word	0x08030f04

080008c8 <gsl_blas_sscal>:
/* Scale vector */

void
gsl_blas_sscal (float alpha, gsl_vector_float * X)
{
  cblas_sscal (INT (X->size), alpha, X->data, INT (X->stride));
 80008c8:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 80008cc:	6800      	ldr	r0, [r0, #0]
 80008ce:	f008 bcb5 	b.w	800923c <cblas_sscal>
 80008d2:	bf00      	nop

080008d4 <gsl_blas_dscal>:
}

void
gsl_blas_dscal (double alpha, gsl_vector * X)
{
  cblas_dscal (INT (X->size), alpha, X->data, INT (X->stride));
 80008d4:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 80008d8:	6800      	ldr	r0, [r0, #0]
 80008da:	f00d baeb 	b.w	800deb4 <cblas_dscal>
 80008de:	bf00      	nop

080008e0 <gsl_blas_cscal>:
}

void
gsl_blas_cscal (const gsl_complex_float alpha, gsl_vector_complex_float * X)
{
 80008e0:	b500      	push	{lr}
 80008e2:	b083      	sub	sp, #12
  cblas_cscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 80008e4:	e9d0 3201 	ldrd	r3, r2, [r0, #4]
 80008e8:	4669      	mov	r1, sp
 80008ea:	6800      	ldr	r0, [r0, #0]
{
 80008ec:	ed8d 0a00 	vstr	s0, [sp]
 80008f0:	edcd 0a01 	vstr	s1, [sp, #4]
  cblas_cscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 80008f4:	f015 fba2 	bl	801603c <cblas_cscal>
               INT (X->stride));
}
 80008f8:	b003      	add	sp, #12
 80008fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80008fe:	bf00      	nop

08000900 <gsl_blas_zscal>:

void
gsl_blas_zscal (const gsl_complex alpha, gsl_vector_complex * X)
{
 8000900:	b500      	push	{lr}
 8000902:	b085      	sub	sp, #20
  cblas_zscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 8000904:	e9d0 3201 	ldrd	r3, r2, [r0, #4]
 8000908:	4669      	mov	r1, sp
 800090a:	6800      	ldr	r0, [r0, #0]
{
 800090c:	ed8d 0b00 	vstr	d0, [sp]
 8000910:	ed8d 1b02 	vstr	d1, [sp, #8]
  cblas_zscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 8000914:	f020 f8fc 	bl	8020b10 <cblas_zscal>
               INT (X->stride));
}
 8000918:	b005      	add	sp, #20
 800091a:	f85d fb04 	ldr.w	pc, [sp], #4
 800091e:	bf00      	nop

08000920 <gsl_blas_csscal>:

void
gsl_blas_csscal (float alpha, gsl_vector_complex_float * X)
{
  cblas_csscal (INT (X->size), alpha, X->data, INT (X->stride));
 8000920:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000924:	6800      	ldr	r0, [r0, #0]
 8000926:	f015 bbaf 	b.w	8016088 <cblas_csscal>
 800092a:	bf00      	nop

0800092c <gsl_blas_zdscal>:
}

void
gsl_blas_zdscal (double alpha, gsl_vector_complex * X)
{
  cblas_zdscal (INT (X->size), alpha, X->data, INT (X->stride));
 800092c:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000930:	6800      	ldr	r0, [r0, #0]
 8000932:	f019 bded 	b.w	801a510 <cblas_zdscal>
 8000936:	bf00      	nop

08000938 <gsl_blas_sgemv>:

int
gsl_blas_sgemv (CBLAS_TRANSPOSE_t TransA, float alpha,
                const gsl_matrix_float * A, const gsl_vector_float * X,
                float beta, gsl_vector_float * Y)
{
 8000938:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 800093a:	286f      	cmp	r0, #111	; 0x6f
  const size_t N = A->size2;
 800093c:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 8000940:	b087      	sub	sp, #28
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000942:	d011      	beq.n	8000968 <gsl_blas_sgemv+0x30>
      || (TransA == CblasTrans && M == X->size && N == Y->size))
 8000944:	2870      	cmp	r0, #112	; 0x70
 8000946:	d105      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
 8000948:	6816      	ldr	r6, [r2, #0]
 800094a:	42a6      	cmp	r6, r4
 800094c:	d102      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
 800094e:	681e      	ldr	r6, [r3, #0]
 8000950:	42ae      	cmp	r6, r5
 8000952:	d00f      	beq.n	8000974 <gsl_blas_sgemv+0x3c>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000954:	4912      	ldr	r1, [pc, #72]	; (80009a0 <gsl_blas_sgemv+0x68>)
 8000956:	4813      	ldr	r0, [pc, #76]	; (80009a4 <gsl_blas_sgemv+0x6c>)
 8000958:	2313      	movs	r3, #19
 800095a:	f240 2266 	movw	r2, #614	; 0x266
 800095e:	f001 ff7f 	bl	8002860 <gsl_error>
 8000962:	2013      	movs	r0, #19
    }
}
 8000964:	b007      	add	sp, #28
 8000966:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000968:	6816      	ldr	r6, [r2, #0]
 800096a:	42ae      	cmp	r6, r5
 800096c:	d1f2      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
 800096e:	681e      	ldr	r6, [r3, #0]
 8000970:	42a6      	cmp	r6, r4
 8000972:	d1ef      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
      cblas_sgemv (CblasRowMajor, TransA, INT (M), INT (N), alpha, A->data,
 8000974:	e9d3 6301 	ldrd	r6, r3, [r3, #4]
 8000978:	e9d2 ec01 	ldrd	lr, ip, [r2, #4]
 800097c:	9605      	str	r6, [sp, #20]
 800097e:	e9d1 7602 	ldrd	r7, r6, [r1, #8]
 8000982:	4622      	mov	r2, r4
 8000984:	9304      	str	r3, [sp, #16]
 8000986:	4601      	mov	r1, r0
 8000988:	e9cd ce02 	strd	ip, lr, [sp, #8]
 800098c:	e9cd 6700 	strd	r6, r7, [sp]
 8000990:	462b      	mov	r3, r5
 8000992:	2065      	movs	r0, #101	; 0x65
 8000994:	f007 ff32 	bl	80087fc <cblas_sgemv>
      return GSL_SUCCESS;
 8000998:	2000      	movs	r0, #0
}
 800099a:	b007      	add	sp, #28
 800099c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800099e:	bf00      	nop
 80009a0:	08030efc 	.word	0x08030efc
 80009a4:	08030f04 	.word	0x08030f04

080009a8 <gsl_blas_dgemv>:


int
gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransA, double alpha, const gsl_matrix * A,
                const gsl_vector * X, double beta, gsl_vector * Y)
{
 80009a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 80009aa:	286f      	cmp	r0, #111	; 0x6f
  const size_t N = A->size2;
 80009ac:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 80009b0:	b087      	sub	sp, #28
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 80009b2:	d011      	beq.n	80009d8 <gsl_blas_dgemv+0x30>
      || (TransA == CblasTrans && M == X->size && N == Y->size))
 80009b4:	2870      	cmp	r0, #112	; 0x70
 80009b6:	d105      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
 80009b8:	6816      	ldr	r6, [r2, #0]
 80009ba:	42a6      	cmp	r6, r4
 80009bc:	d102      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
 80009be:	681e      	ldr	r6, [r3, #0]
 80009c0:	42ae      	cmp	r6, r5
 80009c2:	d00f      	beq.n	80009e4 <gsl_blas_dgemv+0x3c>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80009c4:	4912      	ldr	r1, [pc, #72]	; (8000a10 <gsl_blas_dgemv+0x68>)
 80009c6:	4813      	ldr	r0, [pc, #76]	; (8000a14 <gsl_blas_dgemv+0x6c>)
 80009c8:	2313      	movs	r3, #19
 80009ca:	f44f 721f 	mov.w	r2, #636	; 0x27c
 80009ce:	f001 ff47 	bl	8002860 <gsl_error>
 80009d2:	2013      	movs	r0, #19
    }
}
 80009d4:	b007      	add	sp, #28
 80009d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 80009d8:	6816      	ldr	r6, [r2, #0]
 80009da:	42ae      	cmp	r6, r5
 80009dc:	d1f2      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
 80009de:	681e      	ldr	r6, [r3, #0]
 80009e0:	42a6      	cmp	r6, r4
 80009e2:	d1ef      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
      cblas_dgemv (CblasRowMajor, TransA, INT (M), INT (N), alpha, A->data,
 80009e4:	e9d3 6301 	ldrd	r6, r3, [r3, #4]
 80009e8:	e9d2 ec01 	ldrd	lr, ip, [r2, #4]
 80009ec:	9605      	str	r6, [sp, #20]
 80009ee:	e9d1 7602 	ldrd	r7, r6, [r1, #8]
 80009f2:	4622      	mov	r2, r4
 80009f4:	9304      	str	r3, [sp, #16]
 80009f6:	4601      	mov	r1, r0
 80009f8:	e9cd ce02 	strd	ip, lr, [sp, #8]
 80009fc:	e9cd 6700 	strd	r6, r7, [sp]
 8000a00:	462b      	mov	r3, r5
 8000a02:	2065      	movs	r0, #101	; 0x65
 8000a04:	f00c f9c8 	bl	800cd98 <cblas_dgemv>
      return GSL_SUCCESS;
 8000a08:	2000      	movs	r0, #0
}
 8000a0a:	b007      	add	sp, #28
 8000a0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a0e:	bf00      	nop
 8000a10:	08030efc 	.word	0x08030efc
 8000a14:	08030f04 	.word	0x08030f04

08000a18 <gsl_blas_cgemv>:
int
gsl_blas_cgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_vector_complex_float * X,
                const gsl_complex_float beta, gsl_vector_complex_float * Y)
{
 8000a18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000a1c:	286f      	cmp	r0, #111	; 0x6f
{
 8000a1e:	b08c      	sub	sp, #48	; 0x30
  const size_t N = A->size2;
 8000a20:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 8000a24:	460e      	mov	r6, r1
 8000a26:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
 8000a2a:	edcd 0a0b 	vstr	s1, [sp, #44]	; 0x2c
 8000a2e:	ed8d 1a08 	vstr	s2, [sp, #32]
 8000a32:	edcd 1a09 	vstr	s3, [sp, #36]	; 0x24
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000a36:	d015      	beq.n	8000a64 <gsl_blas_cgemv+0x4c>
      || (TransA == CblasTrans && M == X->size && N == Y->size)
 8000a38:	2870      	cmp	r0, #112	; 0x70
 8000a3a:	d110      	bne.n	8000a5e <gsl_blas_cgemv+0x46>
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000a3c:	6811      	ldr	r1, [r2, #0]
 8000a3e:	42a1      	cmp	r1, r4
 8000a40:	d102      	bne.n	8000a48 <gsl_blas_cgemv+0x30>
 8000a42:	6819      	ldr	r1, [r3, #0]
 8000a44:	42a9      	cmp	r1, r5
 8000a46:	d013      	beq.n	8000a70 <gsl_blas_cgemv+0x58>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000a48:	4918      	ldr	r1, [pc, #96]	; (8000aac <gsl_blas_cgemv+0x94>)
 8000a4a:	4819      	ldr	r0, [pc, #100]	; (8000ab0 <gsl_blas_cgemv+0x98>)
 8000a4c:	2313      	movs	r3, #19
 8000a4e:	f240 2296 	movw	r2, #662	; 0x296
 8000a52:	f001 ff05 	bl	8002860 <gsl_error>
 8000a56:	2013      	movs	r0, #19
    }
}
 8000a58:	b00c      	add	sp, #48	; 0x30
 8000a5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000a5e:	2871      	cmp	r0, #113	; 0x71
 8000a60:	d0ec      	beq.n	8000a3c <gsl_blas_cgemv+0x24>
 8000a62:	e7f1      	b.n	8000a48 <gsl_blas_cgemv+0x30>
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000a64:	6811      	ldr	r1, [r2, #0]
 8000a66:	42a9      	cmp	r1, r5
 8000a68:	d1ee      	bne.n	8000a48 <gsl_blas_cgemv+0x30>
 8000a6a:	6819      	ldr	r1, [r3, #0]
 8000a6c:	42a1      	cmp	r1, r4
 8000a6e:	d1eb      	bne.n	8000a48 <gsl_blas_cgemv+0x30>
      cblas_cgemv (CblasRowMajor, TransA, INT (M), INT (N),
 8000a70:	e9d3 1801 	ldrd	r1, r8, [r3, #4]
 8000a74:	e9d2 c701 	ldrd	ip, r7, [r2, #4]
 8000a78:	9107      	str	r1, [sp, #28]
 8000a7a:	f8cd 8018 	str.w	r8, [sp, #24]
 8000a7e:	462b      	mov	r3, r5
 8000a80:	4622      	mov	r2, r4
 8000a82:	e9d6 5402 	ldrd	r5, r4, [r6, #8]
 8000a86:	f10d 0e20 	add.w	lr, sp, #32
 8000a8a:	4601      	mov	r1, r0
 8000a8c:	a80a      	add	r0, sp, #40	; 0x28
 8000a8e:	9000      	str	r0, [sp, #0]
 8000a90:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 8000a94:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8000a98:	f8cd e014 	str.w	lr, [sp, #20]
 8000a9c:	2065      	movs	r0, #101	; 0x65
 8000a9e:	f012 faf5 	bl	801308c <cblas_cgemv>
      return GSL_SUCCESS;
 8000aa2:	2000      	movs	r0, #0
}
 8000aa4:	b00c      	add	sp, #48	; 0x30
 8000aa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000aaa:	bf00      	nop
 8000aac:	08030efc 	.word	0x08030efc
 8000ab0:	08030f04 	.word	0x08030f04

08000ab4 <gsl_blas_zgemv>:

int
gsl_blas_zgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex alpha,
                const gsl_matrix_complex * A, const gsl_vector_complex * X,
                const gsl_complex beta, gsl_vector_complex * Y)
{
 8000ab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000ab8:	286f      	cmp	r0, #111	; 0x6f
{
 8000aba:	b090      	sub	sp, #64	; 0x40
  const size_t N = A->size2;
 8000abc:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 8000ac0:	ed8d 0b0c 	vstr	d0, [sp, #48]	; 0x30
 8000ac4:	ed8d 1b0e 	vstr	d1, [sp, #56]	; 0x38
 8000ac8:	ed8d 2b08 	vstr	d2, [sp, #32]
 8000acc:	ed8d 3b0a 	vstr	d3, [sp, #40]	; 0x28
 8000ad0:	460e      	mov	r6, r1
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000ad2:	d015      	beq.n	8000b00 <gsl_blas_zgemv+0x4c>
      || (TransA == CblasTrans && M == X->size && N == Y->size)
 8000ad4:	2870      	cmp	r0, #112	; 0x70
 8000ad6:	d110      	bne.n	8000afa <gsl_blas_zgemv+0x46>
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000ad8:	6811      	ldr	r1, [r2, #0]
 8000ada:	42a1      	cmp	r1, r4
 8000adc:	d102      	bne.n	8000ae4 <gsl_blas_zgemv+0x30>
 8000ade:	6819      	ldr	r1, [r3, #0]
 8000ae0:	42a9      	cmp	r1, r5
 8000ae2:	d013      	beq.n	8000b0c <gsl_blas_zgemv+0x58>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000ae4:	4918      	ldr	r1, [pc, #96]	; (8000b48 <gsl_blas_zgemv+0x94>)
 8000ae6:	4819      	ldr	r0, [pc, #100]	; (8000b4c <gsl_blas_zgemv+0x98>)
 8000ae8:	2313      	movs	r3, #19
 8000aea:	f240 22af 	movw	r2, #687	; 0x2af
 8000aee:	f001 feb7 	bl	8002860 <gsl_error>
 8000af2:	2013      	movs	r0, #19
    }
}
 8000af4:	b010      	add	sp, #64	; 0x40
 8000af6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000afa:	2871      	cmp	r0, #113	; 0x71
 8000afc:	d0ec      	beq.n	8000ad8 <gsl_blas_zgemv+0x24>
 8000afe:	e7f1      	b.n	8000ae4 <gsl_blas_zgemv+0x30>
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000b00:	6811      	ldr	r1, [r2, #0]
 8000b02:	42a9      	cmp	r1, r5
 8000b04:	d1ee      	bne.n	8000ae4 <gsl_blas_zgemv+0x30>
 8000b06:	6819      	ldr	r1, [r3, #0]
 8000b08:	42a1      	cmp	r1, r4
 8000b0a:	d1eb      	bne.n	8000ae4 <gsl_blas_zgemv+0x30>
      cblas_zgemv (CblasRowMajor, TransA, INT (M), INT (N),
 8000b0c:	e9d3 1801 	ldrd	r1, r8, [r3, #4]
 8000b10:	e9d2 c701 	ldrd	ip, r7, [r2, #4]
 8000b14:	9107      	str	r1, [sp, #28]
 8000b16:	f8cd 8018 	str.w	r8, [sp, #24]
 8000b1a:	462b      	mov	r3, r5
 8000b1c:	4622      	mov	r2, r4
 8000b1e:	e9d6 5402 	ldrd	r5, r4, [r6, #8]
 8000b22:	f10d 0e20 	add.w	lr, sp, #32
 8000b26:	4601      	mov	r1, r0
 8000b28:	a80c      	add	r0, sp, #48	; 0x30
 8000b2a:	9000      	str	r0, [sp, #0]
 8000b2c:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 8000b30:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8000b34:	f8cd e014 	str.w	lr, [sp, #20]
 8000b38:	2065      	movs	r0, #101	; 0x65
 8000b3a:	f01a fb75 	bl	801b228 <cblas_zgemv>
      return GSL_SUCCESS;
 8000b3e:	2000      	movs	r0, #0
}
 8000b40:	b010      	add	sp, #64	; 0x40
 8000b42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000b46:	bf00      	nop
 8000b48:	08030efc 	.word	0x08030efc
 8000b4c:	08030f04 	.word	0x08030f04

08000b50 <gsl_blas_chemv>:
int
gsl_blas_chemv (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_vector_complex_float * X,
                const gsl_complex_float beta, gsl_vector_complex_float * Y)
{
 8000b50:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000b52:	e9d1 6500 	ldrd	r6, r5, [r1]
{
 8000b56:	b08d      	sub	sp, #52	; 0x34
  if (M != N)
 8000b58:	42ae      	cmp	r6, r5
{
 8000b5a:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
 8000b5e:	edcd 0a0b 	vstr	s1, [sp, #44]	; 0x2c
 8000b62:	ed8d 1a08 	vstr	s2, [sp, #32]
 8000b66:	edcd 1a09 	vstr	s3, [sp, #36]	; 0x24
  if (M != N)
 8000b6a:	d127      	bne.n	8000bbc <gsl_blas_chemv+0x6c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000b6c:	6815      	ldr	r5, [r2, #0]
 8000b6e:	42b5      	cmp	r5, r6
 8000b70:	d103      	bne.n	8000b7a <gsl_blas_chemv+0x2a>
 8000b72:	460c      	mov	r4, r1
 8000b74:	6819      	ldr	r1, [r3, #0]
 8000b76:	42a9      	cmp	r1, r5
 8000b78:	d009      	beq.n	8000b8e <gsl_blas_chemv+0x3e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000b7a:	4915      	ldr	r1, [pc, #84]	; (8000bd0 <gsl_blas_chemv+0x80>)
 8000b7c:	4815      	ldr	r0, [pc, #84]	; (8000bd4 <gsl_blas_chemv+0x84>)
 8000b7e:	2313      	movs	r3, #19
 8000b80:	f240 22c6 	movw	r2, #710	; 0x2c6
 8000b84:	f001 fe6c 	bl	8002860 <gsl_error>
 8000b88:	2013      	movs	r0, #19

  cblas_chemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
               INT (A->tda), X->data, INT (X->stride), GSL_COMPLEX_P (&beta),
               Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000b8a:	b00d      	add	sp, #52	; 0x34
 8000b8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_chemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
 8000b8e:	e9d3 7301 	ldrd	r7, r3, [r3, #4]
 8000b92:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000b96:	9706      	str	r7, [sp, #24]
 8000b98:	9305      	str	r3, [sp, #20]
 8000b9a:	460a      	mov	r2, r1
 8000b9c:	4601      	mov	r1, r0
 8000b9e:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 8000ba2:	af08      	add	r7, sp, #32
 8000ba4:	e9cd 0501 	strd	r0, r5, [sp, #4]
 8000ba8:	9300      	str	r3, [sp, #0]
 8000baa:	e9cd 6703 	strd	r6, r7, [sp, #12]
 8000bae:	ab0a      	add	r3, sp, #40	; 0x28
 8000bb0:	2065      	movs	r0, #101	; 0x65
 8000bb2:	f013 fc3f 	bl	8014434 <cblas_chemv>
  return GSL_SUCCESS;
 8000bb6:	2000      	movs	r0, #0
}
 8000bb8:	b00d      	add	sp, #52	; 0x34
 8000bba:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000bbc:	4904      	ldr	r1, [pc, #16]	; (8000bd0 <gsl_blas_chemv+0x80>)
 8000bbe:	4806      	ldr	r0, [pc, #24]	; (8000bd8 <gsl_blas_chemv+0x88>)
 8000bc0:	2314      	movs	r3, #20
 8000bc2:	f240 22c2 	movw	r2, #706	; 0x2c2
 8000bc6:	f001 fe4b 	bl	8002860 <gsl_error>
 8000bca:	2014      	movs	r0, #20
}
 8000bcc:	b00d      	add	sp, #52	; 0x34
 8000bce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000bd0:	08030efc 	.word	0x08030efc
 8000bd4:	08030f04 	.word	0x08030f04
 8000bd8:	08030f14 	.word	0x08030f14

08000bdc <gsl_blas_zhemv>:

int
gsl_blas_zhemv (CBLAS_UPLO_t Uplo, const gsl_complex alpha,
                const gsl_matrix_complex * A, const gsl_vector_complex * X,
                const gsl_complex beta, gsl_vector_complex * Y)
{
 8000bdc:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000bde:	e9d1 6500 	ldrd	r6, r5, [r1]
{
 8000be2:	b091      	sub	sp, #68	; 0x44
  if (M != N)
 8000be4:	42ae      	cmp	r6, r5
{
 8000be6:	ed8d 0b0c 	vstr	d0, [sp, #48]	; 0x30
 8000bea:	ed8d 1b0e 	vstr	d1, [sp, #56]	; 0x38
 8000bee:	ed8d 2b08 	vstr	d2, [sp, #32]
 8000bf2:	ed8d 3b0a 	vstr	d3, [sp, #40]	; 0x28
  if (M != N)
 8000bf6:	d127      	bne.n	8000c48 <gsl_blas_zhemv+0x6c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000bf8:	6815      	ldr	r5, [r2, #0]
 8000bfa:	42b5      	cmp	r5, r6
 8000bfc:	d103      	bne.n	8000c06 <gsl_blas_zhemv+0x2a>
 8000bfe:	460c      	mov	r4, r1
 8000c00:	6819      	ldr	r1, [r3, #0]
 8000c02:	42a9      	cmp	r1, r5
 8000c04:	d009      	beq.n	8000c1a <gsl_blas_zhemv+0x3e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000c06:	4915      	ldr	r1, [pc, #84]	; (8000c5c <gsl_blas_zhemv+0x80>)
 8000c08:	4815      	ldr	r0, [pc, #84]	; (8000c60 <gsl_blas_zhemv+0x84>)
 8000c0a:	2313      	movs	r3, #19
 8000c0c:	f240 22dd 	movw	r2, #733	; 0x2dd
 8000c10:	f001 fe26 	bl	8002860 <gsl_error>
 8000c14:	2013      	movs	r0, #19

  cblas_zhemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
               INT (A->tda), X->data, INT (X->stride), GSL_COMPLEX_P (&beta),
               Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000c16:	b011      	add	sp, #68	; 0x44
 8000c18:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_zhemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
 8000c1a:	e9d3 7301 	ldrd	r7, r3, [r3, #4]
 8000c1e:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000c22:	9706      	str	r7, [sp, #24]
 8000c24:	9305      	str	r3, [sp, #20]
 8000c26:	460a      	mov	r2, r1
 8000c28:	4601      	mov	r1, r0
 8000c2a:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 8000c2e:	af08      	add	r7, sp, #32
 8000c30:	e9cd 0501 	strd	r0, r5, [sp, #4]
 8000c34:	9300      	str	r3, [sp, #0]
 8000c36:	e9cd 6703 	strd	r6, r7, [sp, #12]
 8000c3a:	ab0c      	add	r3, sp, #48	; 0x30
 8000c3c:	2065      	movs	r0, #101	; 0x65
 8000c3e:	f01c fd33 	bl	801d6a8 <cblas_zhemv>
  return GSL_SUCCESS;
 8000c42:	2000      	movs	r0, #0
}
 8000c44:	b011      	add	sp, #68	; 0x44
 8000c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000c48:	4904      	ldr	r1, [pc, #16]	; (8000c5c <gsl_blas_zhemv+0x80>)
 8000c4a:	4806      	ldr	r0, [pc, #24]	; (8000c64 <gsl_blas_zhemv+0x88>)
 8000c4c:	2314      	movs	r3, #20
 8000c4e:	f240 22d9 	movw	r2, #729	; 0x2d9
 8000c52:	f001 fe05 	bl	8002860 <gsl_error>
 8000c56:	2014      	movs	r0, #20
}
 8000c58:	b011      	add	sp, #68	; 0x44
 8000c5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c5c:	08030efc 	.word	0x08030efc
 8000c60:	08030f04 	.word	0x08030f04
 8000c64:	08030f14 	.word	0x08030f14

08000c68 <gsl_blas_ssymv>:
/* SYMV */

int
gsl_blas_ssymv (CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A,
                const gsl_vector_float * X, float beta, gsl_vector_float * Y)
{
 8000c68:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000c6a:	e9d1 6500 	ldrd	r6, r5, [r1]
 8000c6e:	42ae      	cmp	r6, r5
{
 8000c70:	b087      	sub	sp, #28
  if (M != N)
 8000c72:	d124      	bne.n	8000cbe <gsl_blas_ssymv+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000c74:	6815      	ldr	r5, [r2, #0]
 8000c76:	42b5      	cmp	r5, r6
 8000c78:	d103      	bne.n	8000c82 <gsl_blas_ssymv+0x1a>
 8000c7a:	460c      	mov	r4, r1
 8000c7c:	6819      	ldr	r1, [r3, #0]
 8000c7e:	42a9      	cmp	r1, r5
 8000c80:	d009      	beq.n	8000c96 <gsl_blas_ssymv+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000c82:	4914      	ldr	r1, [pc, #80]	; (8000cd4 <gsl_blas_ssymv+0x6c>)
 8000c84:	4814      	ldr	r0, [pc, #80]	; (8000cd8 <gsl_blas_ssymv+0x70>)
 8000c86:	2313      	movs	r3, #19
 8000c88:	f240 22f6 	movw	r2, #758	; 0x2f6
 8000c8c:	f001 fde8 	bl	8002860 <gsl_error>
 8000c90:	2013      	movs	r0, #19
    }

  cblas_ssymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
               X->data, INT (X->stride), beta, Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000c92:	b007      	add	sp, #28
 8000c94:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_ssymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
 8000c96:	e9d3 c701 	ldrd	ip, r7, [r3, #4]
 8000c9a:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000c9e:	f8cd c010 	str.w	ip, [sp, #16]
 8000ca2:	68a3      	ldr	r3, [r4, #8]
 8000ca4:	9300      	str	r3, [sp, #0]
 8000ca6:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8000caa:	9703      	str	r7, [sp, #12]
 8000cac:	460a      	mov	r2, r1
 8000cae:	68e3      	ldr	r3, [r4, #12]
 8000cb0:	4601      	mov	r1, r0
 8000cb2:	2065      	movs	r0, #101	; 0x65
 8000cb4:	f008 fe0e 	bl	80098d4 <cblas_ssymv>
  return GSL_SUCCESS;
 8000cb8:	2000      	movs	r0, #0
}
 8000cba:	b007      	add	sp, #28
 8000cbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000cbe:	4905      	ldr	r1, [pc, #20]	; (8000cd4 <gsl_blas_ssymv+0x6c>)
 8000cc0:	4806      	ldr	r0, [pc, #24]	; (8000cdc <gsl_blas_ssymv+0x74>)
 8000cc2:	2314      	movs	r3, #20
 8000cc4:	f240 22f2 	movw	r2, #754	; 0x2f2
 8000cc8:	f001 fdca 	bl	8002860 <gsl_error>
 8000ccc:	2014      	movs	r0, #20
}
 8000cce:	b007      	add	sp, #28
 8000cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cd2:	bf00      	nop
 8000cd4:	08030efc 	.word	0x08030efc
 8000cd8:	08030f04 	.word	0x08030f04
 8000cdc:	08030f14 	.word	0x08030f14

08000ce0 <gsl_blas_dsymv>:

int
gsl_blas_dsymv (CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A,
                const gsl_vector * X, double beta, gsl_vector * Y)
{
 8000ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000ce2:	e9d1 6500 	ldrd	r6, r5, [r1]
 8000ce6:	42ae      	cmp	r6, r5
{
 8000ce8:	b087      	sub	sp, #28
  if (M != N)
 8000cea:	d124      	bne.n	8000d36 <gsl_blas_dsymv+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000cec:	6815      	ldr	r5, [r2, #0]
 8000cee:	42b5      	cmp	r5, r6
 8000cf0:	d103      	bne.n	8000cfa <gsl_blas_dsymv+0x1a>
 8000cf2:	460c      	mov	r4, r1
 8000cf4:	6819      	ldr	r1, [r3, #0]
 8000cf6:	42a9      	cmp	r1, r5
 8000cf8:	d009      	beq.n	8000d0e <gsl_blas_dsymv+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000cfa:	4914      	ldr	r1, [pc, #80]	; (8000d4c <gsl_blas_dsymv+0x6c>)
 8000cfc:	4814      	ldr	r0, [pc, #80]	; (8000d50 <gsl_blas_dsymv+0x70>)
 8000cfe:	2313      	movs	r3, #19
 8000d00:	f240 320b 	movw	r2, #779	; 0x30b
 8000d04:	f001 fdac 	bl	8002860 <gsl_error>
 8000d08:	2013      	movs	r0, #19
    }

  cblas_dsymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
               X->data, INT (X->stride), beta, Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000d0a:	b007      	add	sp, #28
 8000d0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_dsymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
 8000d0e:	e9d3 c701 	ldrd	ip, r7, [r3, #4]
 8000d12:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000d16:	f8cd c010 	str.w	ip, [sp, #16]
 8000d1a:	68a3      	ldr	r3, [r4, #8]
 8000d1c:	9300      	str	r3, [sp, #0]
 8000d1e:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8000d22:	9703      	str	r7, [sp, #12]
 8000d24:	460a      	mov	r2, r1
 8000d26:	68e3      	ldr	r3, [r4, #12]
 8000d28:	4601      	mov	r1, r0
 8000d2a:	2065      	movs	r0, #101	; 0x65
 8000d2c:	f00d fdaa 	bl	800e884 <cblas_dsymv>
  return GSL_SUCCESS;
 8000d30:	2000      	movs	r0, #0
}
 8000d32:	b007      	add	sp, #28
 8000d34:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000d36:	4905      	ldr	r1, [pc, #20]	; (8000d4c <gsl_blas_dsymv+0x6c>)
 8000d38:	4806      	ldr	r0, [pc, #24]	; (8000d54 <gsl_blas_dsymv+0x74>)
 8000d3a:	2314      	movs	r3, #20
 8000d3c:	f240 3207 	movw	r2, #775	; 0x307
 8000d40:	f001 fd8e 	bl	8002860 <gsl_error>
 8000d44:	2014      	movs	r0, #20
}
 8000d46:	b007      	add	sp, #28
 8000d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d4a:	bf00      	nop
 8000d4c:	08030efc 	.word	0x08030efc
 8000d50:	08030f04 	.word	0x08030f04
 8000d54:	08030f14 	.word	0x08030f14

08000d58 <gsl_blas_strmv>:

int
gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
                gsl_vector_float * X)
{
 8000d58:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000d5a:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000d5e:	b087      	sub	sp, #28
  if (M != N)
 8000d60:	42a6      	cmp	r6, r4
{
 8000d62:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000d64:	d11e      	bne.n	8000da4 <gsl_blas_strmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000d66:	682c      	ldr	r4, [r5, #0]
 8000d68:	42b4      	cmp	r4, r6
 8000d6a:	d111      	bne.n	8000d90 <gsl_blas_strmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_strmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000d6c:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000d70:	9400      	str	r4, [sp, #0]
 8000d72:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000d76:	4613      	mov	r3, r2
 8000d78:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000d7c:	460a      	mov	r2, r1
 8000d7e:	9704      	str	r7, [sp, #16]
 8000d80:	4601      	mov	r1, r0
 8000d82:	9401      	str	r4, [sp, #4]
 8000d84:	2065      	movs	r0, #101	; 0x65
 8000d86:	f00a fae3 	bl	800b350 <cblas_strmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000d8a:	2000      	movs	r0, #0
}
 8000d8c:	b007      	add	sp, #28
 8000d8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000d90:	4909      	ldr	r1, [pc, #36]	; (8000db8 <gsl_blas_strmv+0x60>)
 8000d92:	480a      	ldr	r0, [pc, #40]	; (8000dbc <gsl_blas_strmv+0x64>)
 8000d94:	2313      	movs	r3, #19
 8000d96:	f44f 7249 	mov.w	r2, #804	; 0x324
 8000d9a:	f001 fd61 	bl	8002860 <gsl_error>
 8000d9e:	2013      	movs	r0, #19
}
 8000da0:	b007      	add	sp, #28
 8000da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000da4:	4904      	ldr	r1, [pc, #16]	; (8000db8 <gsl_blas_strmv+0x60>)
 8000da6:	4806      	ldr	r0, [pc, #24]	; (8000dc0 <gsl_blas_strmv+0x68>)
 8000da8:	2314      	movs	r3, #20
 8000daa:	f44f 7248 	mov.w	r2, #800	; 0x320
 8000dae:	f001 fd57 	bl	8002860 <gsl_error>
 8000db2:	2014      	movs	r0, #20
}
 8000db4:	b007      	add	sp, #28
 8000db6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000db8:	08030efc 	.word	0x08030efc
 8000dbc:	08030f04 	.word	0x08030f04
 8000dc0:	08030f14 	.word	0x08030f14

08000dc4 <gsl_blas_dtrmv>:


int
gsl_blas_dtrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
{
 8000dc4:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000dc6:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000dca:	b087      	sub	sp, #28
  if (M != N)
 8000dcc:	42a6      	cmp	r6, r4
{
 8000dce:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000dd0:	d11e      	bne.n	8000e10 <gsl_blas_dtrmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000dd2:	682c      	ldr	r4, [r5, #0]
 8000dd4:	42b4      	cmp	r4, r6
 8000dd6:	d111      	bne.n	8000dfc <gsl_blas_dtrmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dtrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000dd8:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000ddc:	9400      	str	r4, [sp, #0]
 8000dde:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000de2:	4613      	mov	r3, r2
 8000de4:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000de8:	460a      	mov	r2, r1
 8000dea:	9704      	str	r7, [sp, #16]
 8000dec:	4601      	mov	r1, r0
 8000dee:	9401      	str	r4, [sp, #4]
 8000df0:	2065      	movs	r0, #101	; 0x65
 8000df2:	f00f ff7b 	bl	8010cec <cblas_dtrmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000df6:	2000      	movs	r0, #0
}
 8000df8:	b007      	add	sp, #28
 8000dfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000dfc:	4909      	ldr	r1, [pc, #36]	; (8000e24 <gsl_blas_dtrmv+0x60>)
 8000dfe:	480a      	ldr	r0, [pc, #40]	; (8000e28 <gsl_blas_dtrmv+0x64>)
 8000e00:	2313      	movs	r3, #19
 8000e02:	f240 323a 	movw	r2, #826	; 0x33a
 8000e06:	f001 fd2b 	bl	8002860 <gsl_error>
 8000e0a:	2013      	movs	r0, #19
}
 8000e0c:	b007      	add	sp, #28
 8000e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000e10:	4904      	ldr	r1, [pc, #16]	; (8000e24 <gsl_blas_dtrmv+0x60>)
 8000e12:	4806      	ldr	r0, [pc, #24]	; (8000e2c <gsl_blas_dtrmv+0x68>)
 8000e14:	2314      	movs	r3, #20
 8000e16:	f240 3236 	movw	r2, #822	; 0x336
 8000e1a:	f001 fd21 	bl	8002860 <gsl_error>
 8000e1e:	2014      	movs	r0, #20
}
 8000e20:	b007      	add	sp, #28
 8000e22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e24:	08030efc 	.word	0x08030efc
 8000e28:	08030f04 	.word	0x08030f04
 8000e2c:	08030f14 	.word	0x08030f14

08000e30 <gsl_blas_ctrmv>:

int
gsl_blas_ctrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A,
                gsl_vector_complex_float * X)
{
 8000e30:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000e32:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000e36:	b087      	sub	sp, #28
  if (M != N)
 8000e38:	42a6      	cmp	r6, r4
{
 8000e3a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000e3c:	d11e      	bne.n	8000e7c <gsl_blas_ctrmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000e3e:	682c      	ldr	r4, [r5, #0]
 8000e40:	42b4      	cmp	r4, r6
 8000e42:	d111      	bne.n	8000e68 <gsl_blas_ctrmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ctrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000e44:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000e48:	9400      	str	r4, [sp, #0]
 8000e4a:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000e4e:	4613      	mov	r3, r2
 8000e50:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000e54:	460a      	mov	r2, r1
 8000e56:	9704      	str	r7, [sp, #16]
 8000e58:	4601      	mov	r1, r0
 8000e5a:	9401      	str	r4, [sp, #4]
 8000e5c:	2065      	movs	r0, #101	; 0x65
 8000e5e:	f017 fa01 	bl	8018264 <cblas_ctrmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000e62:	2000      	movs	r0, #0
}
 8000e64:	b007      	add	sp, #28
 8000e66:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000e68:	4909      	ldr	r1, [pc, #36]	; (8000e90 <gsl_blas_ctrmv+0x60>)
 8000e6a:	480a      	ldr	r0, [pc, #40]	; (8000e94 <gsl_blas_ctrmv+0x64>)
 8000e6c:	2313      	movs	r3, #19
 8000e6e:	f240 3251 	movw	r2, #849	; 0x351
 8000e72:	f001 fcf5 	bl	8002860 <gsl_error>
 8000e76:	2013      	movs	r0, #19
}
 8000e78:	b007      	add	sp, #28
 8000e7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000e7c:	4904      	ldr	r1, [pc, #16]	; (8000e90 <gsl_blas_ctrmv+0x60>)
 8000e7e:	4806      	ldr	r0, [pc, #24]	; (8000e98 <gsl_blas_ctrmv+0x68>)
 8000e80:	2314      	movs	r3, #20
 8000e82:	f240 324d 	movw	r2, #845	; 0x34d
 8000e86:	f001 fceb 	bl	8002860 <gsl_error>
 8000e8a:	2014      	movs	r0, #20
}
 8000e8c:	b007      	add	sp, #28
 8000e8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e90:	08030efc 	.word	0x08030efc
 8000e94:	08030f04 	.word	0x08030f04
 8000e98:	08030f14 	.word	0x08030f14

08000e9c <gsl_blas_ztrmv>:

int
gsl_blas_ztrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex * A,
                gsl_vector_complex * X)
{
 8000e9c:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000e9e:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000ea2:	b087      	sub	sp, #28
  if (M != N)
 8000ea4:	42a6      	cmp	r6, r4
{
 8000ea6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000ea8:	d11e      	bne.n	8000ee8 <gsl_blas_ztrmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000eaa:	682c      	ldr	r4, [r5, #0]
 8000eac:	42b4      	cmp	r4, r6
 8000eae:	d111      	bne.n	8000ed4 <gsl_blas_ztrmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ztrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000eb0:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000eb4:	9400      	str	r4, [sp, #0]
 8000eb6:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000eba:	4613      	mov	r3, r2
 8000ebc:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000ec0:	460a      	mov	r2, r1
 8000ec2:	9704      	str	r7, [sp, #16]
 8000ec4:	4601      	mov	r1, r0
 8000ec6:	9401      	str	r4, [sp, #4]
 8000ec8:	2065      	movs	r0, #101	; 0x65
 8000eca:	f024 f8b5 	bl	8025038 <cblas_ztrmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000ece:	2000      	movs	r0, #0
}
 8000ed0:	b007      	add	sp, #28
 8000ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000ed4:	4909      	ldr	r1, [pc, #36]	; (8000efc <gsl_blas_ztrmv+0x60>)
 8000ed6:	480a      	ldr	r0, [pc, #40]	; (8000f00 <gsl_blas_ztrmv+0x64>)
 8000ed8:	2313      	movs	r3, #19
 8000eda:	f44f 725a 	mov.w	r2, #872	; 0x368
 8000ede:	f001 fcbf 	bl	8002860 <gsl_error>
 8000ee2:	2013      	movs	r0, #19
}
 8000ee4:	b007      	add	sp, #28
 8000ee6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000ee8:	4904      	ldr	r1, [pc, #16]	; (8000efc <gsl_blas_ztrmv+0x60>)
 8000eea:	4806      	ldr	r0, [pc, #24]	; (8000f04 <gsl_blas_ztrmv+0x68>)
 8000eec:	2314      	movs	r3, #20
 8000eee:	f44f 7259 	mov.w	r2, #868	; 0x364
 8000ef2:	f001 fcb5 	bl	8002860 <gsl_error>
 8000ef6:	2014      	movs	r0, #20
}
 8000ef8:	b007      	add	sp, #28
 8000efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000efc:	08030efc 	.word	0x08030efc
 8000f00:	08030f04 	.word	0x08030f04
 8000f04:	08030f14 	.word	0x08030f14

08000f08 <gsl_blas_strsv>:

int
gsl_blas_strsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
                gsl_vector_float * X)
{
 8000f08:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000f0a:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000f0e:	b087      	sub	sp, #28
  if (M != N)
 8000f10:	42a6      	cmp	r6, r4
{
 8000f12:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000f14:	d11e      	bne.n	8000f54 <gsl_blas_strsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000f16:	682c      	ldr	r4, [r5, #0]
 8000f18:	42b4      	cmp	r4, r6
 8000f1a:	d111      	bne.n	8000f40 <gsl_blas_strsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_strsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000f1c:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000f20:	9400      	str	r4, [sp, #0]
 8000f22:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000f26:	4613      	mov	r3, r2
 8000f28:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000f2c:	460a      	mov	r2, r1
 8000f2e:	9704      	str	r7, [sp, #16]
 8000f30:	4601      	mov	r1, r0
 8000f32:	9401      	str	r4, [sp, #4]
 8000f34:	2065      	movs	r0, #101	; 0x65
 8000f36:	f00b f8a7 	bl	800c088 <cblas_strsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000f3a:	2000      	movs	r0, #0
}
 8000f3c:	b007      	add	sp, #28
 8000f3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000f40:	4909      	ldr	r1, [pc, #36]	; (8000f68 <gsl_blas_strsv+0x60>)
 8000f42:	480a      	ldr	r0, [pc, #40]	; (8000f6c <gsl_blas_strsv+0x64>)
 8000f44:	2313      	movs	r3, #19
 8000f46:	f240 3281 	movw	r2, #897	; 0x381
 8000f4a:	f001 fc89 	bl	8002860 <gsl_error>
 8000f4e:	2013      	movs	r0, #19
}
 8000f50:	b007      	add	sp, #28
 8000f52:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000f54:	4904      	ldr	r1, [pc, #16]	; (8000f68 <gsl_blas_strsv+0x60>)
 8000f56:	4806      	ldr	r0, [pc, #24]	; (8000f70 <gsl_blas_strsv+0x68>)
 8000f58:	2314      	movs	r3, #20
 8000f5a:	f240 327d 	movw	r2, #893	; 0x37d
 8000f5e:	f001 fc7f 	bl	8002860 <gsl_error>
 8000f62:	2014      	movs	r0, #20
}
 8000f64:	b007      	add	sp, #28
 8000f66:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000f68:	08030efc 	.word	0x08030efc
 8000f6c:	08030f04 	.word	0x08030f04
 8000f70:	08030f14 	.word	0x08030f14

08000f74 <gsl_blas_dtrsv>:


int
gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
{
 8000f74:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000f76:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000f7a:	b087      	sub	sp, #28
  if (M != N)
 8000f7c:	42a6      	cmp	r6, r4
{
 8000f7e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000f80:	d11e      	bne.n	8000fc0 <gsl_blas_dtrsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000f82:	682c      	ldr	r4, [r5, #0]
 8000f84:	42b4      	cmp	r4, r6
 8000f86:	d111      	bne.n	8000fac <gsl_blas_dtrsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dtrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000f88:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000f8c:	9400      	str	r4, [sp, #0]
 8000f8e:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000f92:	4613      	mov	r3, r2
 8000f94:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000f98:	460a      	mov	r2, r1
 8000f9a:	9704      	str	r7, [sp, #16]
 8000f9c:	4601      	mov	r1, r0
 8000f9e:	9401      	str	r4, [sp, #4]
 8000fa0:	2065      	movs	r0, #101	; 0x65
 8000fa2:	f010 ff77 	bl	8011e94 <cblas_dtrsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000fa6:	2000      	movs	r0, #0
}
 8000fa8:	b007      	add	sp, #28
 8000faa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000fac:	4909      	ldr	r1, [pc, #36]	; (8000fd4 <gsl_blas_dtrsv+0x60>)
 8000fae:	480a      	ldr	r0, [pc, #40]	; (8000fd8 <gsl_blas_dtrsv+0x64>)
 8000fb0:	2313      	movs	r3, #19
 8000fb2:	f240 3297 	movw	r2, #919	; 0x397
 8000fb6:	f001 fc53 	bl	8002860 <gsl_error>
 8000fba:	2013      	movs	r0, #19
}
 8000fbc:	b007      	add	sp, #28
 8000fbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000fc0:	4904      	ldr	r1, [pc, #16]	; (8000fd4 <gsl_blas_dtrsv+0x60>)
 8000fc2:	4806      	ldr	r0, [pc, #24]	; (8000fdc <gsl_blas_dtrsv+0x68>)
 8000fc4:	2314      	movs	r3, #20
 8000fc6:	f240 3293 	movw	r2, #915	; 0x393
 8000fca:	f001 fc49 	bl	8002860 <gsl_error>
 8000fce:	2014      	movs	r0, #20
}
 8000fd0:	b007      	add	sp, #28
 8000fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000fd4:	08030efc 	.word	0x08030efc
 8000fd8:	08030f04 	.word	0x08030f04
 8000fdc:	08030f14 	.word	0x08030f14

08000fe0 <gsl_blas_ctrsv>:

int
gsl_blas_ctrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A,
                gsl_vector_complex_float * X)
{
 8000fe0:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000fe2:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000fe6:	b087      	sub	sp, #28
  if (M != N)
 8000fe8:	42a6      	cmp	r6, r4
{
 8000fea:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000fec:	d11e      	bne.n	800102c <gsl_blas_ctrsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000fee:	682c      	ldr	r4, [r5, #0]
 8000ff0:	42b4      	cmp	r4, r6
 8000ff2:	d111      	bne.n	8001018 <gsl_blas_ctrsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ctrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000ff4:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000ff8:	9400      	str	r4, [sp, #0]
 8000ffa:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000ffe:	4613      	mov	r3, r2
 8001000:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8001004:	460a      	mov	r2, r1
 8001006:	9704      	str	r7, [sp, #16]
 8001008:	4601      	mov	r1, r0
 800100a:	9401      	str	r4, [sp, #4]
 800100c:	2065      	movs	r0, #101	; 0x65
 800100e:	f018 fc8d 	bl	801992c <cblas_ctrsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8001012:	2000      	movs	r0, #0
}
 8001014:	b007      	add	sp, #28
 8001016:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001018:	4909      	ldr	r1, [pc, #36]	; (8001040 <gsl_blas_ctrsv+0x60>)
 800101a:	480a      	ldr	r0, [pc, #40]	; (8001044 <gsl_blas_ctrsv+0x64>)
 800101c:	2313      	movs	r3, #19
 800101e:	f240 32ae 	movw	r2, #942	; 0x3ae
 8001022:	f001 fc1d 	bl	8002860 <gsl_error>
 8001026:	2013      	movs	r0, #19
}
 8001028:	b007      	add	sp, #28
 800102a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 800102c:	4904      	ldr	r1, [pc, #16]	; (8001040 <gsl_blas_ctrsv+0x60>)
 800102e:	4806      	ldr	r0, [pc, #24]	; (8001048 <gsl_blas_ctrsv+0x68>)
 8001030:	2314      	movs	r3, #20
 8001032:	f240 32aa 	movw	r2, #938	; 0x3aa
 8001036:	f001 fc13 	bl	8002860 <gsl_error>
 800103a:	2014      	movs	r0, #20
}
 800103c:	b007      	add	sp, #28
 800103e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001040:	08030efc 	.word	0x08030efc
 8001044:	08030f04 	.word	0x08030f04
 8001048:	08030f14 	.word	0x08030f14

0800104c <gsl_blas_ztrsv>:

int
gsl_blas_ztrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex * A,
                gsl_vector_complex * X)
{
 800104c:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 800104e:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8001052:	b087      	sub	sp, #28
  if (M != N)
 8001054:	42a6      	cmp	r6, r4
{
 8001056:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8001058:	d11e      	bne.n	8001098 <gsl_blas_ztrsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 800105a:	682c      	ldr	r4, [r5, #0]
 800105c:	42b4      	cmp	r4, r6
 800105e:	d111      	bne.n	8001084 <gsl_blas_ztrsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ztrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8001060:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8001064:	9400      	str	r4, [sp, #0]
 8001066:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 800106a:	4613      	mov	r3, r2
 800106c:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8001070:	460a      	mov	r2, r1
 8001072:	9704      	str	r7, [sp, #16]
 8001074:	4601      	mov	r1, r0
 8001076:	9401      	str	r4, [sp, #4]
 8001078:	2065      	movs	r0, #101	; 0x65
 800107a:	f026 fb6b 	bl	8027754 <cblas_ztrsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 800107e:	2000      	movs	r0, #0
}
 8001080:	b007      	add	sp, #28
 8001082:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001084:	4909      	ldr	r1, [pc, #36]	; (80010ac <gsl_blas_ztrsv+0x60>)
 8001086:	480a      	ldr	r0, [pc, #40]	; (80010b0 <gsl_blas_ztrsv+0x64>)
 8001088:	2313      	movs	r3, #19
 800108a:	f240 32c5 	movw	r2, #965	; 0x3c5
 800108e:	f001 fbe7 	bl	8002860 <gsl_error>
 8001092:	2013      	movs	r0, #19
}
 8001094:	b007      	add	sp, #28
 8001096:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001098:	4904      	ldr	r1, [pc, #16]	; (80010ac <gsl_blas_ztrsv+0x60>)
 800109a:	4806      	ldr	r0, [pc, #24]	; (80010b4 <gsl_blas_ztrsv+0x68>)
 800109c:	2314      	movs	r3, #20
 800109e:	f240 32c1 	movw	r2, #961	; 0x3c1
 80010a2:	f001 fbdd 	bl	8002860 <gsl_error>
 80010a6:	2014      	movs	r0, #20
}
 80010a8:	b007      	add	sp, #28
 80010aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80010ac:	08030efc 	.word	0x08030efc
 80010b0:	08030f04 	.word	0x08030f04
 80010b4:	08030f14 	.word	0x08030f14

080010b8 <gsl_blas_sger>:
/* GER */

int
gsl_blas_sger (float alpha, const gsl_vector_float * X,
               const gsl_vector_float * Y, gsl_matrix_float * A)
{
 80010b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 80010ba:	6803      	ldr	r3, [r0, #0]
  const size_t M = A->size1;
 80010bc:	6814      	ldr	r4, [r2, #0]
  if (X->size == M && Y->size == N)
 80010be:	42a3      	cmp	r3, r4
{
 80010c0:	b087      	sub	sp, #28
  if (X->size == M && Y->size == N)
 80010c2:	d103      	bne.n	80010cc <gsl_blas_sger+0x14>
  const size_t N = A->size2;
 80010c4:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 80010c6:	680c      	ldr	r4, [r1, #0]
 80010c8:	42ac      	cmp	r4, r5
 80010ca:	d009      	beq.n	80010e0 <gsl_blas_sger+0x28>
                  INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80010cc:	490e      	ldr	r1, [pc, #56]	; (8001108 <gsl_blas_sger+0x50>)
 80010ce:	480f      	ldr	r0, [pc, #60]	; (800110c <gsl_blas_sger+0x54>)
 80010d0:	2313      	movs	r3, #19
 80010d2:	f44f 7278 	mov.w	r2, #992	; 0x3e0
 80010d6:	f001 fbc3 	bl	8002860 <gsl_error>
 80010da:	2013      	movs	r0, #19
    }
}
 80010dc:	b007      	add	sp, #28
 80010de:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_sger (CblasRowMajor, INT (M), INT (N), alpha, X->data,
 80010e0:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 80010e4:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 80010e8:	9504      	str	r5, [sp, #16]
 80010ea:	6845      	ldr	r5, [r0, #4]
 80010ec:	9500      	str	r5, [sp, #0]
 80010ee:	e9cd 6701 	strd	r6, r7, [sp, #4]
 80010f2:	9203      	str	r2, [sp, #12]
 80010f4:	4619      	mov	r1, r3
 80010f6:	4622      	mov	r2, r4
 80010f8:	6883      	ldr	r3, [r0, #8]
 80010fa:	2065      	movs	r0, #101	; 0x65
 80010fc:	f007 fcf6 	bl	8008aec <cblas_sger>
      return GSL_SUCCESS;
 8001100:	2000      	movs	r0, #0
}
 8001102:	b007      	add	sp, #28
 8001104:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001106:	bf00      	nop
 8001108:	08030efc 	.word	0x08030efc
 800110c:	08030f04 	.word	0x08030f04

08001110 <gsl_blas_dger>:


int
gsl_blas_dger (double alpha, const gsl_vector * X, const gsl_vector * Y,
               gsl_matrix * A)
{
 8001110:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 8001112:	6803      	ldr	r3, [r0, #0]
  const size_t M = A->size1;
 8001114:	6814      	ldr	r4, [r2, #0]
  if (X->size == M && Y->size == N)
 8001116:	42a3      	cmp	r3, r4
{
 8001118:	b087      	sub	sp, #28
  if (X->size == M && Y->size == N)
 800111a:	d103      	bne.n	8001124 <gsl_blas_dger+0x14>
  const size_t N = A->size2;
 800111c:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 800111e:	680c      	ldr	r4, [r1, #0]
 8001120:	42ac      	cmp	r4, r5
 8001122:	d009      	beq.n	8001138 <gsl_blas_dger+0x28>
                  INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001124:	490e      	ldr	r1, [pc, #56]	; (8001160 <gsl_blas_dger+0x50>)
 8001126:	480f      	ldr	r0, [pc, #60]	; (8001164 <gsl_blas_dger+0x54>)
 8001128:	2313      	movs	r3, #19
 800112a:	f240 32f5 	movw	r2, #1013	; 0x3f5
 800112e:	f001 fb97 	bl	8002860 <gsl_error>
 8001132:	2013      	movs	r0, #19
    }
}
 8001134:	b007      	add	sp, #28
 8001136:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_dger (CblasRowMajor, INT (M), INT (N), alpha, X->data,
 8001138:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 800113c:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 8001140:	9504      	str	r5, [sp, #16]
 8001142:	6845      	ldr	r5, [r0, #4]
 8001144:	9500      	str	r5, [sp, #0]
 8001146:	e9cd 6701 	strd	r6, r7, [sp, #4]
 800114a:	9203      	str	r2, [sp, #12]
 800114c:	4619      	mov	r1, r3
 800114e:	4622      	mov	r2, r4
 8001150:	6883      	ldr	r3, [r0, #8]
 8001152:	2065      	movs	r0, #101	; 0x65
 8001154:	f00b fff0 	bl	800d138 <cblas_dger>
      return GSL_SUCCESS;
 8001158:	2000      	movs	r0, #0
}
 800115a:	b007      	add	sp, #28
 800115c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800115e:	bf00      	nop
 8001160:	08030efc 	.word	0x08030efc
 8001164:	08030f04 	.word	0x08030f04

08001168 <gsl_blas_cgeru>:
int
gsl_blas_cgeru (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
 8001168:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 800116a:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 800116c:	6804      	ldr	r4, [r0, #0]
{
 800116e:	b089      	sub	sp, #36	; 0x24
  if (X->size == M && Y->size == N)
 8001170:	429c      	cmp	r4, r3
{
 8001172:	ed8d 0a06 	vstr	s0, [sp, #24]
 8001176:	edcd 0a07 	vstr	s1, [sp, #28]
  if (X->size == M && Y->size == N)
 800117a:	d103      	bne.n	8001184 <gsl_blas_cgeru+0x1c>
  const size_t N = A->size2;
 800117c:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 800117e:	680b      	ldr	r3, [r1, #0]
 8001180:	42ab      	cmp	r3, r5
 8001182:	d009      	beq.n	8001198 <gsl_blas_cgeru+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001184:	490f      	ldr	r1, [pc, #60]	; (80011c4 <gsl_blas_cgeru+0x5c>)
 8001186:	4810      	ldr	r0, [pc, #64]	; (80011c8 <gsl_blas_cgeru+0x60>)
 8001188:	2313      	movs	r3, #19
 800118a:	f240 420e 	movw	r2, #1038	; 0x40e
 800118e:	f001 fb67 	bl	8002860 <gsl_error>
 8001192:	2013      	movs	r0, #19
    }
}
 8001194:	b009      	add	sp, #36	; 0x24
 8001196:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_cgeru (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 8001198:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 800119c:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 80011a0:	9505      	str	r5, [sp, #20]
 80011a2:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 80011a6:	4621      	mov	r1, r4
 80011a8:	e9cd 0500 	strd	r0, r5, [sp]
 80011ac:	9204      	str	r2, [sp, #16]
 80011ae:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80011b2:	461a      	mov	r2, r3
 80011b4:	2065      	movs	r0, #101	; 0x65
 80011b6:	ab06      	add	r3, sp, #24
 80011b8:	f012 fb74 	bl	80138a4 <cblas_cgeru>
      return GSL_SUCCESS;
 80011bc:	2000      	movs	r0, #0
}
 80011be:	b009      	add	sp, #36	; 0x24
 80011c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80011c2:	bf00      	nop
 80011c4:	08030efc 	.word	0x08030efc
 80011c8:	08030f04 	.word	0x08030f04

080011cc <gsl_blas_zgeru>:

int
gsl_blas_zgeru (const gsl_complex alpha, const gsl_vector_complex * X,
                const gsl_vector_complex * Y, gsl_matrix_complex * A)
{
 80011cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 80011ce:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 80011d0:	6804      	ldr	r4, [r0, #0]
{
 80011d2:	b08b      	sub	sp, #44	; 0x2c
  if (X->size == M && Y->size == N)
 80011d4:	429c      	cmp	r4, r3
{
 80011d6:	ed8d 0b06 	vstr	d0, [sp, #24]
 80011da:	ed8d 1b08 	vstr	d1, [sp, #32]
  if (X->size == M && Y->size == N)
 80011de:	d103      	bne.n	80011e8 <gsl_blas_zgeru+0x1c>
  const size_t N = A->size2;
 80011e0:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 80011e2:	680b      	ldr	r3, [r1, #0]
 80011e4:	42ab      	cmp	r3, r5
 80011e6:	d009      	beq.n	80011fc <gsl_blas_zgeru+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80011e8:	490f      	ldr	r1, [pc, #60]	; (8001228 <gsl_blas_zgeru+0x5c>)
 80011ea:	4810      	ldr	r0, [pc, #64]	; (800122c <gsl_blas_zgeru+0x60>)
 80011ec:	2313      	movs	r3, #19
 80011ee:	f240 4222 	movw	r2, #1058	; 0x422
 80011f2:	f001 fb35 	bl	8002860 <gsl_error>
 80011f6:	2013      	movs	r0, #19
    }
}
 80011f8:	b00b      	add	sp, #44	; 0x2c
 80011fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_zgeru (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 80011fc:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 8001200:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 8001204:	9505      	str	r5, [sp, #20]
 8001206:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 800120a:	4621      	mov	r1, r4
 800120c:	e9cd 0500 	strd	r0, r5, [sp]
 8001210:	9204      	str	r2, [sp, #16]
 8001212:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001216:	461a      	mov	r2, r3
 8001218:	2065      	movs	r0, #101	; 0x65
 800121a:	ab06      	add	r3, sp, #24
 800121c:	f01a ff58 	bl	801c0d0 <cblas_zgeru>
      return GSL_SUCCESS;
 8001220:	2000      	movs	r0, #0
}
 8001222:	b00b      	add	sp, #44	; 0x2c
 8001224:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001226:	bf00      	nop
 8001228:	08030efc 	.word	0x08030efc
 800122c:	08030f04 	.word	0x08030f04

08001230 <gsl_blas_cgerc>:
int
gsl_blas_cgerc (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
 8001230:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 8001232:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 8001234:	6804      	ldr	r4, [r0, #0]
{
 8001236:	b089      	sub	sp, #36	; 0x24
  if (X->size == M && Y->size == N)
 8001238:	429c      	cmp	r4, r3
{
 800123a:	ed8d 0a06 	vstr	s0, [sp, #24]
 800123e:	edcd 0a07 	vstr	s1, [sp, #28]
  if (X->size == M && Y->size == N)
 8001242:	d103      	bne.n	800124c <gsl_blas_cgerc+0x1c>
  const size_t N = A->size2;
 8001244:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 8001246:	680b      	ldr	r3, [r1, #0]
 8001248:	42ab      	cmp	r3, r5
 800124a:	d009      	beq.n	8001260 <gsl_blas_cgerc+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800124c:	490f      	ldr	r1, [pc, #60]	; (800128c <gsl_blas_cgerc+0x5c>)
 800124e:	4810      	ldr	r0, [pc, #64]	; (8001290 <gsl_blas_cgerc+0x60>)
 8001250:	2313      	movs	r3, #19
 8001252:	f240 423b 	movw	r2, #1083	; 0x43b
 8001256:	f001 fb03 	bl	8002860 <gsl_error>
 800125a:	2013      	movs	r0, #19
    }
}
 800125c:	b009      	add	sp, #36	; 0x24
 800125e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_cgerc (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 8001260:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 8001264:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 8001268:	9505      	str	r5, [sp, #20]
 800126a:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 800126e:	4621      	mov	r1, r4
 8001270:	e9cd 0500 	strd	r0, r5, [sp]
 8001274:	9204      	str	r2, [sp, #16]
 8001276:	e9cd 6702 	strd	r6, r7, [sp, #8]
 800127a:	461a      	mov	r2, r3
 800127c:	2065      	movs	r0, #101	; 0x65
 800127e:	ab06      	add	r3, sp, #24
 8001280:	f012 f99c 	bl	80135bc <cblas_cgerc>
      return GSL_SUCCESS;
 8001284:	2000      	movs	r0, #0
}
 8001286:	b009      	add	sp, #36	; 0x24
 8001288:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800128a:	bf00      	nop
 800128c:	08030efc 	.word	0x08030efc
 8001290:	08030f04 	.word	0x08030f04

08001294 <gsl_blas_zgerc>:


int
gsl_blas_zgerc (const gsl_complex alpha, const gsl_vector_complex * X,
                const gsl_vector_complex * Y, gsl_matrix_complex * A)
{
 8001294:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 8001296:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 8001298:	6804      	ldr	r4, [r0, #0]
{
 800129a:	b08b      	sub	sp, #44	; 0x2c
  if (X->size == M && Y->size == N)
 800129c:	429c      	cmp	r4, r3
{
 800129e:	ed8d 0b06 	vstr	d0, [sp, #24]
 80012a2:	ed8d 1b08 	vstr	d1, [sp, #32]
  if (X->size == M && Y->size == N)
 80012a6:	d103      	bne.n	80012b0 <gsl_blas_zgerc+0x1c>
  const size_t N = A->size2;
 80012a8:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 80012aa:	680b      	ldr	r3, [r1, #0]
 80012ac:	42ab      	cmp	r3, r5
 80012ae:	d009      	beq.n	80012c4 <gsl_blas_zgerc+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80012b0:	490f      	ldr	r1, [pc, #60]	; (80012f0 <gsl_blas_zgerc+0x5c>)
 80012b2:	4810      	ldr	r0, [pc, #64]	; (80012f4 <gsl_blas_zgerc+0x60>)
 80012b4:	2313      	movs	r3, #19
 80012b6:	f44f 628a 	mov.w	r2, #1104	; 0x450
 80012ba:	f001 fad1 	bl	8002860 <gsl_error>
 80012be:	2013      	movs	r0, #19
    }
}
 80012c0:	b00b      	add	sp, #44	; 0x2c
 80012c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_zgerc (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 80012c4:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 80012c8:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 80012cc:	9505      	str	r5, [sp, #20]
 80012ce:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 80012d2:	4621      	mov	r1, r4
 80012d4:	e9cd 0500 	strd	r0, r5, [sp]
 80012d8:	9204      	str	r2, [sp, #16]
 80012da:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80012de:	461a      	mov	r2, r3
 80012e0:	2065      	movs	r0, #101	; 0x65
 80012e2:	ab06      	add	r3, sp, #24
 80012e4:	f01a fc9c 	bl	801bc20 <cblas_zgerc>
      return GSL_SUCCESS;
 80012e8:	2000      	movs	r0, #0
}
 80012ea:	b00b      	add	sp, #44	; 0x2c
 80012ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80012ee:	bf00      	nop
 80012f0:	08030efc 	.word	0x08030efc
 80012f4:	08030f04 	.word	0x08030f04

080012f8 <gsl_blas_cher>:

int
gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha,
               const gsl_vector_complex_float * X,
               gsl_matrix_complex_float * A)
{
 80012f8:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;
 80012fa:	e9d2 4500 	ldrd	r4, r5, [r2]

  if (M != N)
 80012fe:	42ac      	cmp	r4, r5
{
 8001300:	b084      	sub	sp, #16
  if (M != N)
 8001302:	d11c      	bne.n	800133e <gsl_blas_cher+0x46>
 8001304:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 8001306:	6809      	ldr	r1, [r1, #0]
 8001308:	42a1      	cmp	r1, r4
 800130a:	d10e      	bne.n	800132a <gsl_blas_cher+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_cher (CblasRowMajor, Uplo, INT (M), alpha, X->data, INT (X->stride),
 800130c:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 8001310:	685c      	ldr	r4, [r3, #4]
 8001312:	9602      	str	r6, [sp, #8]
 8001314:	e9cd 4500 	strd	r4, r5, [sp]
 8001318:	460a      	mov	r2, r1
 800131a:	689b      	ldr	r3, [r3, #8]
 800131c:	4601      	mov	r1, r0
 800131e:	2065      	movs	r0, #101	; 0x65
 8001320:	f013 fb4c 	bl	80149bc <cblas_cher>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 8001324:	2000      	movs	r0, #0
}
 8001326:	b004      	add	sp, #16
 8001328:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800132a:	490a      	ldr	r1, [pc, #40]	; (8001354 <gsl_blas_cher+0x5c>)
 800132c:	480a      	ldr	r0, [pc, #40]	; (8001358 <gsl_blas_cher+0x60>)
 800132e:	2313      	movs	r3, #19
 8001330:	f240 4264 	movw	r2, #1124	; 0x464
 8001334:	f001 fa94 	bl	8002860 <gsl_error>
 8001338:	2013      	movs	r0, #19
}
 800133a:	b004      	add	sp, #16
 800133c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 800133e:	4905      	ldr	r1, [pc, #20]	; (8001354 <gsl_blas_cher+0x5c>)
 8001340:	4806      	ldr	r0, [pc, #24]	; (800135c <gsl_blas_cher+0x64>)
 8001342:	2314      	movs	r3, #20
 8001344:	f44f 628c 	mov.w	r2, #1120	; 0x460
 8001348:	f001 fa8a 	bl	8002860 <gsl_error>
 800134c:	2014      	movs	r0, #20
}
 800134e:	b004      	add	sp, #16
 8001350:	bd70      	pop	{r4, r5, r6, pc}
 8001352:	bf00      	nop
 8001354:	08030efc 	.word	0x08030efc
 8001358:	08030f04 	.word	0x08030f04
 800135c:	08030f14 	.word	0x08030f14

08001360 <gsl_blas_zher>:


int
gsl_blas_zher (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector_complex * X,
               gsl_matrix_complex * A)
{
 8001360:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8001362:	e9d2 4500 	ldrd	r4, r5, [r2]
 8001366:	42ac      	cmp	r4, r5
{
 8001368:	b084      	sub	sp, #16
  if (M != N)
 800136a:	d11c      	bne.n	80013a6 <gsl_blas_zher+0x46>
 800136c:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 800136e:	6809      	ldr	r1, [r1, #0]
 8001370:	42a1      	cmp	r1, r4
 8001372:	d10e      	bne.n	8001392 <gsl_blas_zher+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_zher (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 8001374:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 8001378:	685c      	ldr	r4, [r3, #4]
 800137a:	9602      	str	r6, [sp, #8]
 800137c:	e9cd 4500 	strd	r4, r5, [sp]
 8001380:	460a      	mov	r2, r1
 8001382:	689b      	ldr	r3, [r3, #8]
 8001384:	4601      	mov	r1, r0
 8001386:	2065      	movs	r0, #101	; 0x65
 8001388:	f01c fec6 	bl	801e118 <cblas_zher>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 800138c:	2000      	movs	r0, #0
}
 800138e:	b004      	add	sp, #16
 8001390:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001392:	490a      	ldr	r1, [pc, #40]	; (80013bc <gsl_blas_zher+0x5c>)
 8001394:	480a      	ldr	r0, [pc, #40]	; (80013c0 <gsl_blas_zher+0x60>)
 8001396:	2313      	movs	r3, #19
 8001398:	f240 427a 	movw	r2, #1146	; 0x47a
 800139c:	f001 fa60 	bl	8002860 <gsl_error>
 80013a0:	2013      	movs	r0, #19
}
 80013a2:	b004      	add	sp, #16
 80013a4:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 80013a6:	4905      	ldr	r1, [pc, #20]	; (80013bc <gsl_blas_zher+0x5c>)
 80013a8:	4806      	ldr	r0, [pc, #24]	; (80013c4 <gsl_blas_zher+0x64>)
 80013aa:	2314      	movs	r3, #20
 80013ac:	f240 4276 	movw	r2, #1142	; 0x476
 80013b0:	f001 fa56 	bl	8002860 <gsl_error>
 80013b4:	2014      	movs	r0, #20
}
 80013b6:	b004      	add	sp, #16
 80013b8:	bd70      	pop	{r4, r5, r6, pc}
 80013ba:	bf00      	nop
 80013bc:	08030efc 	.word	0x08030efc
 80013c0:	08030f04 	.word	0x08030f04
 80013c4:	08030f14 	.word	0x08030f14

080013c8 <gsl_blas_cher2>:
int
gsl_blas_cher2 (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
 80013c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 80013ca:	e9d3 5400 	ldrd	r5, r4, [r3]
{
 80013ce:	b089      	sub	sp, #36	; 0x24
  if (M != N)
 80013d0:	42a5      	cmp	r5, r4
{
 80013d2:	ed8d 0a06 	vstr	s0, [sp, #24]
 80013d6:	edcd 0a07 	vstr	s1, [sp, #28]
  if (M != N)
 80013da:	d124      	bne.n	8001426 <gsl_blas_cher2+0x5e>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 80013dc:	680c      	ldr	r4, [r1, #0]
 80013de:	42ac      	cmp	r4, r5
 80013e0:	d102      	bne.n	80013e8 <gsl_blas_cher2+0x20>
 80013e2:	6815      	ldr	r5, [r2, #0]
 80013e4:	42a5      	cmp	r5, r4
 80013e6:	d009      	beq.n	80013fc <gsl_blas_cher2+0x34>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80013e8:	4914      	ldr	r1, [pc, #80]	; (800143c <gsl_blas_cher2+0x74>)
 80013ea:	4815      	ldr	r0, [pc, #84]	; (8001440 <gsl_blas_cher2+0x78>)
 80013ec:	2313      	movs	r3, #19
 80013ee:	f240 4294 	movw	r2, #1172	; 0x494
 80013f2:	f001 fa35 	bl	8002860 <gsl_error>
 80013f6:	2013      	movs	r0, #19

  cblas_cher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
               INT (X->stride), Y->data, INT (Y->stride), A->data,
               INT (A->tda));
  return GSL_SUCCESS;
}
 80013f8:	b009      	add	sp, #36	; 0x24
 80013fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_cher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
 80013fc:	e9d3 4302 	ldrd	r4, r3, [r3, #8]
 8001400:	e9d2 7601 	ldrd	r7, r6, [r2, #4]
 8001404:	9405      	str	r4, [sp, #20]
 8001406:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 800140a:	9304      	str	r3, [sp, #16]
 800140c:	9200      	str	r2, [sp, #0]
 800140e:	4601      	mov	r1, r0
 8001410:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001414:	462a      	mov	r2, r5
 8001416:	9401      	str	r4, [sp, #4]
 8001418:	ab06      	add	r3, sp, #24
 800141a:	2065      	movs	r0, #101	; 0x65
 800141c:	f013 fc3e 	bl	8014c9c <cblas_cher2>
  return GSL_SUCCESS;
 8001420:	2000      	movs	r0, #0
}
 8001422:	b009      	add	sp, #36	; 0x24
 8001424:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001426:	4905      	ldr	r1, [pc, #20]	; (800143c <gsl_blas_cher2+0x74>)
 8001428:	4806      	ldr	r0, [pc, #24]	; (8001444 <gsl_blas_cher2+0x7c>)
 800142a:	2314      	movs	r3, #20
 800142c:	f44f 6292 	mov.w	r2, #1168	; 0x490
 8001430:	f001 fa16 	bl	8002860 <gsl_error>
 8001434:	2014      	movs	r0, #20
}
 8001436:	b009      	add	sp, #36	; 0x24
 8001438:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800143a:	bf00      	nop
 800143c:	08030efc 	.word	0x08030efc
 8001440:	08030f04 	.word	0x08030f04
 8001444:	08030f14 	.word	0x08030f14

08001448 <gsl_blas_zher2>:

int
gsl_blas_zher2 (CBLAS_UPLO_t Uplo, const gsl_complex alpha,
                const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_matrix_complex * A)
{
 8001448:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 800144a:	e9d3 5400 	ldrd	r5, r4, [r3]
{
 800144e:	b08b      	sub	sp, #44	; 0x2c
  if (M != N)
 8001450:	42a5      	cmp	r5, r4
{
 8001452:	ed8d 0b06 	vstr	d0, [sp, #24]
 8001456:	ed8d 1b08 	vstr	d1, [sp, #32]
  if (M != N)
 800145a:	d124      	bne.n	80014a6 <gsl_blas_zher2+0x5e>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 800145c:	680c      	ldr	r4, [r1, #0]
 800145e:	42ac      	cmp	r4, r5
 8001460:	d102      	bne.n	8001468 <gsl_blas_zher2+0x20>
 8001462:	6815      	ldr	r5, [r2, #0]
 8001464:	42a5      	cmp	r5, r4
 8001466:	d009      	beq.n	800147c <gsl_blas_zher2+0x34>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001468:	4914      	ldr	r1, [pc, #80]	; (80014bc <gsl_blas_zher2+0x74>)
 800146a:	4815      	ldr	r0, [pc, #84]	; (80014c0 <gsl_blas_zher2+0x78>)
 800146c:	2313      	movs	r3, #19
 800146e:	f240 42ac 	movw	r2, #1196	; 0x4ac
 8001472:	f001 f9f5 	bl	8002860 <gsl_error>
 8001476:	2013      	movs	r0, #19

  cblas_zher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
               INT (X->stride), Y->data, INT (Y->stride), A->data,
               INT (A->tda));
  return GSL_SUCCESS;
}
 8001478:	b00b      	add	sp, #44	; 0x2c
 800147a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_zher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
 800147c:	e9d3 4302 	ldrd	r4, r3, [r3, #8]
 8001480:	e9d2 7601 	ldrd	r7, r6, [r2, #4]
 8001484:	9405      	str	r4, [sp, #20]
 8001486:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 800148a:	9304      	str	r3, [sp, #16]
 800148c:	9200      	str	r2, [sp, #0]
 800148e:	4601      	mov	r1, r0
 8001490:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001494:	462a      	mov	r2, r5
 8001496:	9401      	str	r4, [sp, #4]
 8001498:	ab06      	add	r3, sp, #24
 800149a:	2065      	movs	r0, #101	; 0x65
 800149c:	f01d f8a8 	bl	801e5f0 <cblas_zher2>
  return GSL_SUCCESS;
 80014a0:	2000      	movs	r0, #0
}
 80014a2:	b00b      	add	sp, #44	; 0x2c
 80014a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 80014a6:	4905      	ldr	r1, [pc, #20]	; (80014bc <gsl_blas_zher2+0x74>)
 80014a8:	4806      	ldr	r0, [pc, #24]	; (80014c4 <gsl_blas_zher2+0x7c>)
 80014aa:	2314      	movs	r3, #20
 80014ac:	f44f 6295 	mov.w	r2, #1192	; 0x4a8
 80014b0:	f001 f9d6 	bl	8002860 <gsl_error>
 80014b4:	2014      	movs	r0, #20
}
 80014b6:	b00b      	add	sp, #44	; 0x2c
 80014b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80014ba:	bf00      	nop
 80014bc:	08030efc 	.word	0x08030efc
 80014c0:	08030f04 	.word	0x08030f04
 80014c4:	08030f14 	.word	0x08030f14

080014c8 <gsl_blas_ssyr>:
/* SYR */

int
gsl_blas_ssyr (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
               gsl_matrix_float * A)
{
 80014c8:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 80014ca:	e9d2 4500 	ldrd	r4, r5, [r2]
 80014ce:	42ac      	cmp	r4, r5
{
 80014d0:	b084      	sub	sp, #16
  if (M != N)
 80014d2:	d11c      	bne.n	800150e <gsl_blas_ssyr+0x46>
 80014d4:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 80014d6:	6809      	ldr	r1, [r1, #0]
 80014d8:	42a1      	cmp	r1, r4
 80014da:	d10e      	bne.n	80014fa <gsl_blas_ssyr+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ssyr (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 80014dc:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 80014e0:	685c      	ldr	r4, [r3, #4]
 80014e2:	9602      	str	r6, [sp, #8]
 80014e4:	e9cd 4500 	strd	r4, r5, [sp]
 80014e8:	460a      	mov	r2, r1
 80014ea:	689b      	ldr	r3, [r3, #8]
 80014ec:	4601      	mov	r1, r0
 80014ee:	2065      	movs	r0, #101	; 0x65
 80014f0:	f008 fbc0 	bl	8009c74 <cblas_ssyr>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 80014f4:	2000      	movs	r0, #0
}
 80014f6:	b004      	add	sp, #16
 80014f8:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80014fa:	490a      	ldr	r1, [pc, #40]	; (8001524 <gsl_blas_ssyr+0x5c>)
 80014fc:	480a      	ldr	r0, [pc, #40]	; (8001528 <gsl_blas_ssyr+0x60>)
 80014fe:	2313      	movs	r3, #19
 8001500:	f240 42c5 	movw	r2, #1221	; 0x4c5
 8001504:	f001 f9ac 	bl	8002860 <gsl_error>
 8001508:	2013      	movs	r0, #19
}
 800150a:	b004      	add	sp, #16
 800150c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 800150e:	4905      	ldr	r1, [pc, #20]	; (8001524 <gsl_blas_ssyr+0x5c>)
 8001510:	4806      	ldr	r0, [pc, #24]	; (800152c <gsl_blas_ssyr+0x64>)
 8001512:	2314      	movs	r3, #20
 8001514:	f240 42c1 	movw	r2, #1217	; 0x4c1
 8001518:	f001 f9a2 	bl	8002860 <gsl_error>
 800151c:	2014      	movs	r0, #20
}
 800151e:	b004      	add	sp, #16
 8001520:	bd70      	pop	{r4, r5, r6, pc}
 8001522:	bf00      	nop
 8001524:	08030efc 	.word	0x08030efc
 8001528:	08030f04 	.word	0x08030f04
 800152c:	08030f14 	.word	0x08030f14

08001530 <gsl_blas_dsyr>:


int
gsl_blas_dsyr (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * X,
               gsl_matrix * A)
{
 8001530:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8001532:	e9d2 4500 	ldrd	r4, r5, [r2]
 8001536:	42ac      	cmp	r4, r5
{
 8001538:	b084      	sub	sp, #16
  if (M != N)
 800153a:	d11c      	bne.n	8001576 <gsl_blas_dsyr+0x46>
 800153c:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 800153e:	6809      	ldr	r1, [r1, #0]
 8001540:	42a1      	cmp	r1, r4
 8001542:	d10e      	bne.n	8001562 <gsl_blas_dsyr+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dsyr (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 8001544:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 8001548:	685c      	ldr	r4, [r3, #4]
 800154a:	9602      	str	r6, [sp, #8]
 800154c:	e9cd 4500 	strd	r4, r5, [sp]
 8001550:	460a      	mov	r2, r1
 8001552:	689b      	ldr	r3, [r3, #8]
 8001554:	4601      	mov	r1, r0
 8001556:	2065      	movs	r0, #101	; 0x65
 8001558:	f00d fc0e 	bl	800ed78 <cblas_dsyr>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 800155c:	2000      	movs	r0, #0
}
 800155e:	b004      	add	sp, #16
 8001560:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001562:	490a      	ldr	r1, [pc, #40]	; (800158c <gsl_blas_dsyr+0x5c>)
 8001564:	480a      	ldr	r0, [pc, #40]	; (8001590 <gsl_blas_dsyr+0x60>)
 8001566:	2313      	movs	r3, #19
 8001568:	f240 42db 	movw	r2, #1243	; 0x4db
 800156c:	f001 f978 	bl	8002860 <gsl_error>
 8001570:	2013      	movs	r0, #19
}
 8001572:	b004      	add	sp, #16
 8001574:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001576:	4905      	ldr	r1, [pc, #20]	; (800158c <gsl_blas_dsyr+0x5c>)
 8001578:	4806      	ldr	r0, [pc, #24]	; (8001594 <gsl_blas_dsyr+0x64>)
 800157a:	2314      	movs	r3, #20
 800157c:	f240 42d7 	movw	r2, #1239	; 0x4d7
 8001580:	f001 f96e 	bl	8002860 <gsl_error>
 8001584:	2014      	movs	r0, #20
}
 8001586:	b004      	add	sp, #16
 8001588:	bd70      	pop	{r4, r5, r6, pc}
 800158a:	bf00      	nop
 800158c:	08030efc 	.word	0x08030efc
 8001590:	08030f04 	.word	0x08030f04
 8001594:	08030f14 	.word	0x08030f14

08001598 <gsl_blas_ssyr2>:
/* SYR2 */

int
gsl_blas_ssyr2 (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
                const gsl_vector_float * Y, gsl_matrix_float * A)
{
 8001598:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 800159a:	e9d3 4500 	ldrd	r4, r5, [r3]
 800159e:	42ac      	cmp	r4, r5
{
 80015a0:	b087      	sub	sp, #28
  if (M != N)
 80015a2:	d124      	bne.n	80015ee <gsl_blas_ssyr2+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 80015a4:	680d      	ldr	r5, [r1, #0]
 80015a6:	42a5      	cmp	r5, r4
 80015a8:	460e      	mov	r6, r1
 80015aa:	d102      	bne.n	80015b2 <gsl_blas_ssyr2+0x1a>
 80015ac:	6811      	ldr	r1, [r2, #0]
 80015ae:	42a9      	cmp	r1, r5
 80015b0:	d009      	beq.n	80015c6 <gsl_blas_ssyr2+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80015b2:	4914      	ldr	r1, [pc, #80]	; (8001604 <gsl_blas_ssyr2+0x6c>)
 80015b4:	4814      	ldr	r0, [pc, #80]	; (8001608 <gsl_blas_ssyr2+0x70>)
 80015b6:	2313      	movs	r3, #19
 80015b8:	f240 42f3 	movw	r2, #1267	; 0x4f3
 80015bc:	f001 f950 	bl	8002860 <gsl_error>
 80015c0:	2013      	movs	r0, #19
    }

  cblas_ssyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
               Y->data, INT (Y->stride), A->data, INT (A->tda));
  return GSL_SUCCESS;
}
 80015c2:	b007      	add	sp, #28
 80015c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_ssyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 80015c6:	e9d3 c702 	ldrd	ip, r7, [r3, #8]
 80015ca:	e9d2 5401 	ldrd	r5, r4, [r2, #4]
 80015ce:	f8cd c010 	str.w	ip, [sp, #16]
 80015d2:	6873      	ldr	r3, [r6, #4]
 80015d4:	9300      	str	r3, [sp, #0]
 80015d6:	e9cd 4501 	strd	r4, r5, [sp, #4]
 80015da:	9703      	str	r7, [sp, #12]
 80015dc:	460a      	mov	r2, r1
 80015de:	68b3      	ldr	r3, [r6, #8]
 80015e0:	4601      	mov	r1, r0
 80015e2:	2065      	movs	r0, #101	; 0x65
 80015e4:	f008 fc22 	bl	8009e2c <cblas_ssyr2>
  return GSL_SUCCESS;
 80015e8:	2000      	movs	r0, #0
}
 80015ea:	b007      	add	sp, #28
 80015ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 80015ee:	4905      	ldr	r1, [pc, #20]	; (8001604 <gsl_blas_ssyr2+0x6c>)
 80015f0:	4806      	ldr	r0, [pc, #24]	; (800160c <gsl_blas_ssyr2+0x74>)
 80015f2:	2314      	movs	r3, #20
 80015f4:	f240 42ef 	movw	r2, #1263	; 0x4ef
 80015f8:	f001 f932 	bl	8002860 <gsl_error>
 80015fc:	2014      	movs	r0, #20
}
 80015fe:	b007      	add	sp, #28
 8001600:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001602:	bf00      	nop
 8001604:	08030efc 	.word	0x08030efc
 8001608:	08030f04 	.word	0x08030f04
 800160c:	08030f14 	.word	0x08030f14

08001610 <gsl_blas_dsyr2>:


int
gsl_blas_dsyr2 (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * X,
                const gsl_vector * Y, gsl_matrix * A)
{
 8001610:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8001612:	e9d3 4500 	ldrd	r4, r5, [r3]
 8001616:	42ac      	cmp	r4, r5
{
 8001618:	b087      	sub	sp, #28
  if (M != N)
 800161a:	d124      	bne.n	8001666 <gsl_blas_dsyr2+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 800161c:	680d      	ldr	r5, [r1, #0]
 800161e:	42a5      	cmp	r5, r4
 8001620:	460e      	mov	r6, r1
 8001622:	d102      	bne.n	800162a <gsl_blas_dsyr2+0x1a>
 8001624:	6811      	ldr	r1, [r2, #0]
 8001626:	42a9      	cmp	r1, r5
 8001628:	d009      	beq.n	800163e <gsl_blas_dsyr2+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800162a:	4914      	ldr	r1, [pc, #80]	; (800167c <gsl_blas_dsyr2+0x6c>)
 800162c:	4814      	ldr	r0, [pc, #80]	; (8001680 <gsl_blas_dsyr2+0x70>)
 800162e:	2313      	movs	r3, #19
 8001630:	f240 5209 	movw	r2, #1289	; 0x509
 8001634:	f001 f914 	bl	8002860 <gsl_error>
 8001638:	2013      	movs	r0, #19
    }

  cblas_dsyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
               Y->data, INT (Y->stride), A->data, INT (A->tda));
  return GSL_SUCCESS;
}
 800163a:	b007      	add	sp, #28
 800163c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_dsyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 800163e:	e9d3 c702 	ldrd	ip, r7, [r3, #8]
 8001642:	e9d2 5401 	ldrd	r5, r4, [r2, #4]
 8001646:	f8cd c010 	str.w	ip, [sp, #16]
 800164a:	6873      	ldr	r3, [r6, #4]
 800164c:	9300      	str	r3, [sp, #0]
 800164e:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8001652:	9703      	str	r7, [sp, #12]
 8001654:	460a      	mov	r2, r1
 8001656:	68b3      	ldr	r3, [r6, #8]
 8001658:	4601      	mov	r1, r0
 800165a:	2065      	movs	r0, #101	; 0x65
 800165c:	f00d fcb6 	bl	800efcc <cblas_dsyr2>
  return GSL_SUCCESS;
 8001660:	2000      	movs	r0, #0
}
 8001662:	b007      	add	sp, #28
 8001664:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001666:	4905      	ldr	r1, [pc, #20]	; (800167c <gsl_blas_dsyr2+0x6c>)
 8001668:	4806      	ldr	r0, [pc, #24]	; (8001684 <gsl_blas_dsyr2+0x74>)
 800166a:	2314      	movs	r3, #20
 800166c:	f240 5205 	movw	r2, #1285	; 0x505
 8001670:	f001 f8f6 	bl	8002860 <gsl_error>
 8001674:	2014      	movs	r0, #20
}
 8001676:	b007      	add	sp, #28
 8001678:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800167a:	bf00      	nop
 800167c:	08030efc 	.word	0x08030efc
 8001680:	08030f04 	.word	0x08030f04
 8001684:	08030f14 	.word	0x08030f14

08001688 <gsl_blas_sgemm>:

int
gsl_blas_sgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                float alpha, const gsl_matrix_float * A,
                const gsl_matrix_float * B, float beta, gsl_matrix_float * C)
{
 8001688:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800168c:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800168e:	286f      	cmp	r0, #111	; 0x6f
{
 8001690:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 8001694:	e9d2 e700 	ldrd	lr, r7, [r2]
  const size_t M = C->size1;
 8001698:	f8dc 6000 	ldr.w	r6, [ip]
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800169c:	d102      	bne.n	80016a4 <gsl_blas_sgemm+0x1c>
 800169e:	4674      	mov	r4, lr
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 80016a0:	46be      	mov	lr, r7
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80016a2:	4627      	mov	r7, r4
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80016a4:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80016a6:	e9d3 4500 	ldrd	r4, r5, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80016aa:	d102      	bne.n	80016b2 <gsl_blas_sgemm+0x2a>
 80016ac:	46a0      	mov	r8, r4
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80016ae:	462c      	mov	r4, r5
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80016b0:	4645      	mov	r5, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80016b2:	42be      	cmp	r6, r7
 80016b4:	d105      	bne.n	80016c2 <gsl_blas_sgemm+0x3a>
  const size_t N = C->size2;
 80016b6:	f8dc 7004 	ldr.w	r7, [ip, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80016ba:	42bc      	cmp	r4, r7
 80016bc:	d101      	bne.n	80016c2 <gsl_blas_sgemm+0x3a>
 80016be:	45ae      	cmp	lr, r5
 80016c0:	d00a      	beq.n	80016d8 <gsl_blas_sgemm+0x50>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80016c2:	4912      	ldr	r1, [pc, #72]	; (800170c <gsl_blas_sgemm+0x84>)
 80016c4:	4812      	ldr	r0, [pc, #72]	; (8001710 <gsl_blas_sgemm+0x88>)
 80016c6:	2313      	movs	r3, #19
 80016c8:	f44f 62a6 	mov.w	r2, #1328	; 0x530
 80016cc:	f001 f8c8 	bl	8002860 <gsl_error>
 80016d0:	2013      	movs	r0, #19
    }
}
 80016d2:	b008      	add	sp, #32
 80016d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      cblas_sgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 80016d8:	e9dc 8c02 	ldrd	r8, ip, [ip, #8]
 80016dc:	f8cd e004 	str.w	lr, [sp, #4]
 80016e0:	e9d3 e702 	ldrd	lr, r7, [r3, #8]
 80016e4:	9400      	str	r4, [sp, #0]
 80016e6:	e9d2 5402 	ldrd	r5, r4, [r2, #8]
 80016ea:	4633      	mov	r3, r6
 80016ec:	460a      	mov	r2, r1
 80016ee:	e9cd ec05 	strd	lr, ip, [sp, #20]
 80016f2:	4601      	mov	r1, r0
 80016f4:	e9cd 5703 	strd	r5, r7, [sp, #12]
 80016f8:	f8cd 801c 	str.w	r8, [sp, #28]
 80016fc:	9402      	str	r4, [sp, #8]
 80016fe:	2065      	movs	r0, #101	; 0x65
 8001700:	f006 fddc 	bl	80082bc <cblas_sgemm>
      return GSL_SUCCESS;
 8001704:	2000      	movs	r0, #0
}
 8001706:	b008      	add	sp, #32
 8001708:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800170c:	08030efc 	.word	0x08030efc
 8001710:	08030f04 	.word	0x08030f04

08001714 <gsl_blas_dgemm>:

int
gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                double alpha, const gsl_matrix * A, const gsl_matrix * B,
                double beta, gsl_matrix * C)
{
 8001714:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001718:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800171a:	286f      	cmp	r0, #111	; 0x6f
{
 800171c:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 8001720:	e9d2 e700 	ldrd	lr, r7, [r2]
  const size_t M = C->size1;
 8001724:	f8dc 6000 	ldr.w	r6, [ip]
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 8001728:	d102      	bne.n	8001730 <gsl_blas_dgemm+0x1c>
 800172a:	4674      	mov	r4, lr
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 800172c:	46be      	mov	lr, r7
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800172e:	4627      	mov	r7, r4
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001730:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 8001732:	e9d3 4500 	ldrd	r4, r5, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001736:	d102      	bne.n	800173e <gsl_blas_dgemm+0x2a>
 8001738:	46a0      	mov	r8, r4
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 800173a:	462c      	mov	r4, r5
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 800173c:	4645      	mov	r5, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 800173e:	42be      	cmp	r6, r7
 8001740:	d105      	bne.n	800174e <gsl_blas_dgemm+0x3a>
  const size_t N = C->size2;
 8001742:	f8dc 7004 	ldr.w	r7, [ip, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 8001746:	42bc      	cmp	r4, r7
 8001748:	d101      	bne.n	800174e <gsl_blas_dgemm+0x3a>
 800174a:	45ae      	cmp	lr, r5
 800174c:	d00a      	beq.n	8001764 <gsl_blas_dgemm+0x50>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800174e:	4912      	ldr	r1, [pc, #72]	; (8001798 <gsl_blas_dgemm+0x84>)
 8001750:	4812      	ldr	r0, [pc, #72]	; (800179c <gsl_blas_dgemm+0x88>)
 8001752:	2313      	movs	r3, #19
 8001754:	f240 524a 	movw	r2, #1354	; 0x54a
 8001758:	f001 f882 	bl	8002860 <gsl_error>
 800175c:	2013      	movs	r0, #19
    }
}
 800175e:	b008      	add	sp, #32
 8001760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      cblas_dgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 8001764:	e9dc 8c02 	ldrd	r8, ip, [ip, #8]
 8001768:	f8cd e004 	str.w	lr, [sp, #4]
 800176c:	e9d3 e702 	ldrd	lr, r7, [r3, #8]
 8001770:	9400      	str	r4, [sp, #0]
 8001772:	e9d2 5402 	ldrd	r5, r4, [r2, #8]
 8001776:	4633      	mov	r3, r6
 8001778:	460a      	mov	r2, r1
 800177a:	e9cd ec05 	strd	lr, ip, [sp, #20]
 800177e:	4601      	mov	r1, r0
 8001780:	e9cd 5703 	strd	r5, r7, [sp, #12]
 8001784:	f8cd 801c 	str.w	r8, [sp, #28]
 8001788:	9402      	str	r4, [sp, #8]
 800178a:	2065      	movs	r0, #101	; 0x65
 800178c:	f00a ffb6 	bl	800c6fc <cblas_dgemm>
      return GSL_SUCCESS;
 8001790:	2000      	movs	r0, #0
}
 8001792:	b008      	add	sp, #32
 8001794:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001798:	08030efc 	.word	0x08030efc
 800179c:	08030f04 	.word	0x08030f04

080017a0 <gsl_blas_cgemm>:
gsl_blas_cgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_matrix_complex_float * B,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 80017a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80017a4:	b08e      	sub	sp, #56	; 0x38
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80017a6:	286f      	cmp	r0, #111	; 0x6f
{
 80017a8:	9c14      	ldr	r4, [sp, #80]	; 0x50
 80017aa:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 80017ae:	e9d2 7500 	ldrd	r7, r5, [r2]
  const size_t M = C->size1;
 80017b2:	f8d4 e000 	ldr.w	lr, [r4]
{
 80017b6:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 80017ba:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 80017be:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80017c2:	d102      	bne.n	80017ca <gsl_blas_cgemm+0x2a>
 80017c4:	463e      	mov	r6, r7
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 80017c6:	462f      	mov	r7, r5
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80017c8:	4635      	mov	r5, r6
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80017ca:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80017cc:	e9d3 6c00 	ldrd	r6, ip, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80017d0:	d102      	bne.n	80017d8 <gsl_blas_cgemm+0x38>
 80017d2:	46b0      	mov	r8, r6
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80017d4:	4666      	mov	r6, ip
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80017d6:	46c4      	mov	ip, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80017d8:	45ae      	cmp	lr, r5
 80017da:	d104      	bne.n	80017e6 <gsl_blas_cgemm+0x46>
  const size_t N = C->size2;
 80017dc:	6865      	ldr	r5, [r4, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80017de:	42ae      	cmp	r6, r5
 80017e0:	d101      	bne.n	80017e6 <gsl_blas_cgemm+0x46>
 80017e2:	4567      	cmp	r7, ip
 80017e4:	d00a      	beq.n	80017fc <gsl_blas_cgemm+0x5c>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80017e6:	4914      	ldr	r1, [pc, #80]	; (8001838 <gsl_blas_cgemm+0x98>)
 80017e8:	4814      	ldr	r0, [pc, #80]	; (800183c <gsl_blas_cgemm+0x9c>)
 80017ea:	2313      	movs	r3, #19
 80017ec:	f240 5267 	movw	r2, #1383	; 0x567
 80017f0:	f001 f836 	bl	8002860 <gsl_error>
 80017f4:	2013      	movs	r0, #19
    }
}
 80017f6:	b00e      	add	sp, #56	; 0x38
 80017f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      cblas_cgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 80017fc:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001800:	9701      	str	r7, [sp, #4]
 8001802:	9600      	str	r6, [sp, #0]
 8001804:	e9d3 8702 	ldrd	r8, r7, [r3, #8]
 8001808:	9509      	str	r5, [sp, #36]	; 0x24
 800180a:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 800180e:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001812:	9408      	str	r4, [sp, #32]
 8001814:	ac0c      	add	r4, sp, #48	; 0x30
 8001816:	460a      	mov	r2, r1
 8001818:	e9cd 8c06 	strd	r8, ip, [sp, #24]
 800181c:	4601      	mov	r1, r0
 800181e:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001822:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001826:	4673      	mov	r3, lr
 8001828:	2065      	movs	r0, #101	; 0x65
 800182a:	f011 f85f 	bl	80128ec <cblas_cgemm>
      return GSL_SUCCESS;
 800182e:	2000      	movs	r0, #0
}
 8001830:	b00e      	add	sp, #56	; 0x38
 8001832:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001836:	bf00      	nop
 8001838:	08030efc 	.word	0x08030efc
 800183c:	08030f04 	.word	0x08030f04

08001840 <gsl_blas_zgemm>:
int
gsl_blas_zgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_matrix_complex * B, const gsl_complex beta,
                gsl_matrix_complex * C)
{
 8001840:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001844:	b093      	sub	sp, #76	; 0x4c
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 8001846:	286f      	cmp	r0, #111	; 0x6f
{
 8001848:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 800184c:	e9d2 e700 	ldrd	lr, r7, [r2]
{
 8001850:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 8001854:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8001858:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 800185c:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
  const size_t M = C->size1;
 8001860:	f8dc 6000 	ldr.w	r6, [ip]
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 8001864:	d102      	bne.n	800186c <gsl_blas_zgemm+0x2c>
 8001866:	4674      	mov	r4, lr
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 8001868:	46be      	mov	lr, r7
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800186a:	4627      	mov	r7, r4
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 800186c:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 800186e:	e9d3 4500 	ldrd	r4, r5, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001872:	d102      	bne.n	800187a <gsl_blas_zgemm+0x3a>
 8001874:	46a0      	mov	r8, r4
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 8001876:	462c      	mov	r4, r5
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001878:	4645      	mov	r5, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 800187a:	42be      	cmp	r6, r7
 800187c:	d105      	bne.n	800188a <gsl_blas_zgemm+0x4a>
  const size_t N = C->size2;
 800187e:	f8dc 7004 	ldr.w	r7, [ip, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 8001882:	42bc      	cmp	r4, r7
 8001884:	d101      	bne.n	800188a <gsl_blas_zgemm+0x4a>
 8001886:	45ae      	cmp	lr, r5
 8001888:	d00a      	beq.n	80018a0 <gsl_blas_zgemm+0x60>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800188a:	4915      	ldr	r1, [pc, #84]	; (80018e0 <gsl_blas_zgemm+0xa0>)
 800188c:	4815      	ldr	r0, [pc, #84]	; (80018e4 <gsl_blas_zgemm+0xa4>)
 800188e:	2313      	movs	r3, #19
 8001890:	f240 5283 	movw	r2, #1411	; 0x583
 8001894:	f000 ffe4 	bl	8002860 <gsl_error>
 8001898:	2013      	movs	r0, #19
    }
}
 800189a:	b013      	add	sp, #76	; 0x4c
 800189c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      cblas_zgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 80018a0:	e9dc 5902 	ldrd	r5, r9, [ip, #8]
 80018a4:	f8cd e004 	str.w	lr, [sp, #4]
 80018a8:	9400      	str	r4, [sp, #0]
 80018aa:	e9d3 8c02 	ldrd	r8, ip, [r3, #8]
 80018ae:	9509      	str	r5, [sp, #36]	; 0x24
 80018b0:	e9d2 7502 	ldrd	r7, r5, [r2, #8]
 80018b4:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 80018b8:	ac0e      	add	r4, sp, #56	; 0x38
 80018ba:	460a      	mov	r2, r1
 80018bc:	e9cd 8e06 	strd	r8, lr, [sp, #24]
 80018c0:	4601      	mov	r1, r0
 80018c2:	e9cd 7c04 	strd	r7, ip, [sp, #16]
 80018c6:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80018ca:	f8cd 9020 	str.w	r9, [sp, #32]
 80018ce:	4633      	mov	r3, r6
 80018d0:	2065      	movs	r0, #101	; 0x65
 80018d2:	f018 fe45 	bl	801a560 <cblas_zgemm>
      return GSL_SUCCESS;
 80018d6:	2000      	movs	r0, #0
}
 80018d8:	b013      	add	sp, #76	; 0x4c
 80018da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80018de:	bf00      	nop
 80018e0:	08030efc 	.word	0x08030efc
 80018e4:	08030f04 	.word	0x08030f04

080018e8 <gsl_blas_ssymm>:

int
gsl_blas_ssymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, float alpha,
                const gsl_matrix_float * A, const gsl_matrix_float * B,
                float beta, gsl_matrix_float * C)
{
 80018e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 80018ea:	e9d2 6400 	ldrd	r6, r4, [r2]
{
 80018ee:	b089      	sub	sp, #36	; 0x24
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 80018f0:	42a6      	cmp	r6, r4
{
 80018f2:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (MA != NA)
 80018f4:	d134      	bne.n	8001960 <gsl_blas_ssymm+0x78>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 80018f6:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 80018f8:	e9d5 4700 	ldrd	r4, r7, [r5]
  const size_t NB = B->size2;
 80018fc:	e9d3 ce00 	ldrd	ip, lr, [r3]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001900:	d011      	beq.n	8001926 <gsl_blas_ssymm+0x3e>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001902:	288e      	cmp	r0, #142	; 0x8e
 8001904:	d105      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 8001906:	4564      	cmp	r4, ip
 8001908:	d103      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800190a:	42b7      	cmp	r7, r6
 800190c:	d101      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800190e:	4577      	cmp	r7, lr
 8001910:	d00f      	beq.n	8001932 <gsl_blas_ssymm+0x4a>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001912:	4918      	ldr	r1, [pc, #96]	; (8001974 <gsl_blas_ssymm+0x8c>)
 8001914:	4818      	ldr	r0, [pc, #96]	; (8001978 <gsl_blas_ssymm+0x90>)
 8001916:	2313      	movs	r3, #19
 8001918:	f240 52a5 	movw	r2, #1445	; 0x5a5
 800191c:	f000 ffa0 	bl	8002860 <gsl_error>
 8001920:	2013      	movs	r0, #19
    }

}
 8001922:	b009      	add	sp, #36	; 0x24
 8001924:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001926:	42b4      	cmp	r4, r6
 8001928:	d1f3      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800192a:	4577      	cmp	r7, lr
 800192c:	d1f1      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800192e:	4564      	cmp	r4, ip
 8001930:	d1ef      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
      cblas_ssymm (CblasRowMajor, Side, Uplo, INT (M), INT (N), alpha,
 8001932:	e9d5 6e02 	ldrd	r6, lr, [r5, #8]
 8001936:	9700      	str	r7, [sp, #0]
 8001938:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 800193c:	9606      	str	r6, [sp, #24]
 800193e:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001942:	460a      	mov	r2, r1
 8001944:	9301      	str	r3, [sp, #4]
 8001946:	4601      	mov	r1, r0
 8001948:	e9cd 7503 	strd	r7, r5, [sp, #12]
 800194c:	f8cd e014 	str.w	lr, [sp, #20]
 8001950:	4623      	mov	r3, r4
 8001952:	9602      	str	r6, [sp, #8]
 8001954:	2065      	movs	r0, #101	; 0x65
 8001956:	f007 fca5 	bl	80092a4 <cblas_ssymm>
      return GSL_SUCCESS;
 800195a:	2000      	movs	r0, #0
}
 800195c:	b009      	add	sp, #36	; 0x24
 800195e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001960:	4904      	ldr	r1, [pc, #16]	; (8001974 <gsl_blas_ssymm+0x8c>)
 8001962:	4806      	ldr	r0, [pc, #24]	; (800197c <gsl_blas_ssymm+0x94>)
 8001964:	2314      	movs	r3, #20
 8001966:	f44f 62b3 	mov.w	r2, #1432	; 0x598
 800196a:	f000 ff79 	bl	8002860 <gsl_error>
 800196e:	2014      	movs	r0, #20
}
 8001970:	b009      	add	sp, #36	; 0x24
 8001972:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001974:	08030efc 	.word	0x08030efc
 8001978:	08030f04 	.word	0x08030f04
 800197c:	08030f2c 	.word	0x08030f2c

08001980 <gsl_blas_dsymm>:

int
gsl_blas_dsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, double alpha,
                const gsl_matrix * A, const gsl_matrix * B, double beta,
                gsl_matrix * C)
{
 8001980:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 8001982:	e9d2 6400 	ldrd	r6, r4, [r2]
{
 8001986:	b089      	sub	sp, #36	; 0x24
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001988:	42a6      	cmp	r6, r4
{
 800198a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (MA != NA)
 800198c:	d134      	bne.n	80019f8 <gsl_blas_dsymm+0x78>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 800198e:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001990:	e9d5 4700 	ldrd	r4, r7, [r5]
  const size_t NB = B->size2;
 8001994:	e9d3 ce00 	ldrd	ip, lr, [r3]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001998:	d011      	beq.n	80019be <gsl_blas_dsymm+0x3e>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 800199a:	288e      	cmp	r0, #142	; 0x8e
 800199c:	d105      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 800199e:	4564      	cmp	r4, ip
 80019a0:	d103      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019a2:	42b7      	cmp	r7, r6
 80019a4:	d101      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019a6:	4577      	cmp	r7, lr
 80019a8:	d00f      	beq.n	80019ca <gsl_blas_dsymm+0x4a>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80019aa:	4918      	ldr	r1, [pc, #96]	; (8001a0c <gsl_blas_dsymm+0x8c>)
 80019ac:	4818      	ldr	r0, [pc, #96]	; (8001a10 <gsl_blas_dsymm+0x90>)
 80019ae:	2313      	movs	r3, #19
 80019b0:	f240 52c6 	movw	r2, #1478	; 0x5c6
 80019b4:	f000 ff54 	bl	8002860 <gsl_error>
 80019b8:	2013      	movs	r0, #19
    }
}
 80019ba:	b009      	add	sp, #36	; 0x24
 80019bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 80019be:	42b4      	cmp	r4, r6
 80019c0:	d1f3      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019c2:	4577      	cmp	r7, lr
 80019c4:	d1f1      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019c6:	4564      	cmp	r4, ip
 80019c8:	d1ef      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
      cblas_dsymm (CblasRowMajor, Side, Uplo, INT (M), INT (N), alpha,
 80019ca:	e9d5 6e02 	ldrd	r6, lr, [r5, #8]
 80019ce:	9700      	str	r7, [sp, #0]
 80019d0:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 80019d4:	9606      	str	r6, [sp, #24]
 80019d6:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 80019da:	460a      	mov	r2, r1
 80019dc:	9301      	str	r3, [sp, #4]
 80019de:	4601      	mov	r1, r0
 80019e0:	e9cd 7503 	strd	r7, r5, [sp, #12]
 80019e4:	f8cd e014 	str.w	lr, [sp, #20]
 80019e8:	4623      	mov	r3, r4
 80019ea:	9602      	str	r6, [sp, #8]
 80019ec:	2065      	movs	r0, #101	; 0x65
 80019ee:	f00c fae3 	bl	800dfb8 <cblas_dsymm>
      return GSL_SUCCESS;
 80019f2:	2000      	movs	r0, #0
}
 80019f4:	b009      	add	sp, #36	; 0x24
 80019f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 80019f8:	4904      	ldr	r1, [pc, #16]	; (8001a0c <gsl_blas_dsymm+0x8c>)
 80019fa:	4806      	ldr	r0, [pc, #24]	; (8001a14 <gsl_blas_dsymm+0x94>)
 80019fc:	2314      	movs	r3, #20
 80019fe:	f240 52b9 	movw	r2, #1465	; 0x5b9
 8001a02:	f000 ff2d 	bl	8002860 <gsl_error>
 8001a06:	2014      	movs	r0, #20
}
 8001a08:	b009      	add	sp, #36	; 0x24
 8001a0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a0c:	08030efc 	.word	0x08030efc
 8001a10:	08030f04 	.word	0x08030f04
 8001a14:	08030f2c 	.word	0x08030f2c

08001a18 <gsl_blas_csymm>:
gsl_blas_csymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_matrix_complex_float * B,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8001a18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001a1c:	4614      	mov	r4, r2
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
 8001a1e:	6812      	ldr	r2, [r2, #0]
  const size_t NA = A->size2;
 8001a20:	6867      	ldr	r7, [r4, #4]
{
 8001a22:	b08e      	sub	sp, #56	; 0x38
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001a24:	42ba      	cmp	r2, r7
{
 8001a26:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8001a28:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
 8001a2c:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 8001a30:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 8001a34:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  if (MA != NA)
 8001a38:	d13d      	bne.n	8001ab6 <gsl_blas_csymm+0x9e>
 8001a3a:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001a3c:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001a3e:	e9d6 3700 	ldrd	r3, r7, [r6]
  const size_t NB = B->size2;
 8001a42:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001a46:	d012      	beq.n	8001a6e <gsl_blas_csymm+0x56>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001a48:	288e      	cmp	r0, #142	; 0x8e
 8001a4a:	d105      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a4c:	4563      	cmp	r3, ip
 8001a4e:	d103      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a50:	4297      	cmp	r7, r2
 8001a52:	d101      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a54:	4577      	cmp	r7, lr
 8001a56:	d010      	beq.n	8001a7a <gsl_blas_csymm+0x62>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001a58:	491c      	ldr	r1, [pc, #112]	; (8001acc <gsl_blas_csymm+0xb4>)
 8001a5a:	481d      	ldr	r0, [pc, #116]	; (8001ad0 <gsl_blas_csymm+0xb8>)
 8001a5c:	2313      	movs	r3, #19
 8001a5e:	f240 52e9 	movw	r2, #1513	; 0x5e9
 8001a62:	f000 fefd 	bl	8002860 <gsl_error>
 8001a66:	2013      	movs	r0, #19
    }
}
 8001a68:	b00e      	add	sp, #56	; 0x38
 8001a6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001a6e:	4293      	cmp	r3, r2
 8001a70:	d1f2      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a72:	4577      	cmp	r7, lr
 8001a74:	d1f0      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a76:	4563      	cmp	r3, ip
 8001a78:	d1ee      	bne.n	8001a58 <gsl_blas_csymm+0x40>
      cblas_csymm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001a7a:	e9d6 8e02 	ldrd	r8, lr, [r6, #8]
 8001a7e:	9700      	str	r7, [sp, #0]
 8001a80:	f8cd 8020 	str.w	r8, [sp, #32]
 8001a84:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001a88:	f8cd e01c 	str.w	lr, [sp, #28]
 8001a8c:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001a90:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001a94:	460a      	mov	r2, r1
 8001a96:	4601      	mov	r1, r0
 8001a98:	a80c      	add	r0, sp, #48	; 0x30
 8001a9a:	9001      	str	r0, [sp, #4]
 8001a9c:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001aa0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001aa4:	f8cd c018 	str.w	ip, [sp, #24]
 8001aa8:	2065      	movs	r0, #101	; 0x65
 8001aaa:	f014 fb45 	bl	8016138 <cblas_csymm>
      return GSL_SUCCESS;
 8001aae:	2000      	movs	r0, #0
}
 8001ab0:	b00e      	add	sp, #56	; 0x38
 8001ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001ab6:	4905      	ldr	r1, [pc, #20]	; (8001acc <gsl_blas_csymm+0xb4>)
 8001ab8:	4806      	ldr	r0, [pc, #24]	; (8001ad4 <gsl_blas_csymm+0xbc>)
 8001aba:	2314      	movs	r3, #20
 8001abc:	f240 52db 	movw	r2, #1499	; 0x5db
 8001ac0:	f000 fece 	bl	8002860 <gsl_error>
 8001ac4:	2014      	movs	r0, #20
}
 8001ac6:	b00e      	add	sp, #56	; 0x38
 8001ac8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001acc:	08030efc 	.word	0x08030efc
 8001ad0:	08030f04 	.word	0x08030f04
 8001ad4:	08030f2c 	.word	0x08030f2c

08001ad8 <gsl_blas_zsymm>:
int
gsl_blas_zsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_matrix_complex * B, const gsl_complex beta,
                gsl_matrix_complex * C)
{
 8001ad8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 8001ada:	e9d2 7600 	ldrd	r7, r6, [r2]
{
 8001ade:	b093      	sub	sp, #76	; 0x4c
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001ae0:	42b7      	cmp	r7, r6
{
 8001ae2:	4614      	mov	r4, r2
 8001ae4:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 8001ae8:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8001aec:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 8001af0:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
 8001af4:	9a18      	ldr	r2, [sp, #96]	; 0x60
  if (MA != NA)
 8001af6:	d13a      	bne.n	8001b6e <gsl_blas_zsymm+0x96>
 8001af8:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001afa:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001afc:	e9d2 3600 	ldrd	r3, r6, [r2]
  const size_t NB = B->size2;
 8001b00:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001b04:	d011      	beq.n	8001b2a <gsl_blas_zsymm+0x52>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001b06:	288e      	cmp	r0, #142	; 0x8e
 8001b08:	d105      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b0a:	4563      	cmp	r3, ip
 8001b0c:	d103      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b0e:	42be      	cmp	r6, r7
 8001b10:	d101      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b12:	4576      	cmp	r6, lr
 8001b14:	d00f      	beq.n	8001b36 <gsl_blas_zsymm+0x5e>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001b16:	491b      	ldr	r1, [pc, #108]	; (8001b84 <gsl_blas_zsymm+0xac>)
 8001b18:	481b      	ldr	r0, [pc, #108]	; (8001b88 <gsl_blas_zsymm+0xb0>)
 8001b1a:	2313      	movs	r3, #19
 8001b1c:	f240 620a 	movw	r2, #1546	; 0x60a
 8001b20:	f000 fe9e 	bl	8002860 <gsl_error>
 8001b24:	2013      	movs	r0, #19
    }
}
 8001b26:	b013      	add	sp, #76	; 0x4c
 8001b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001b2a:	42bb      	cmp	r3, r7
 8001b2c:	d1f3      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b2e:	4576      	cmp	r6, lr
 8001b30:	d1f1      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b32:	4563      	cmp	r3, ip
 8001b34:	d1ef      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
      cblas_zsymm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001b36:	e9d2 7e02 	ldrd	r7, lr, [r2, #8]
 8001b3a:	9600      	str	r6, [sp, #0]
 8001b3c:	9708      	str	r7, [sp, #32]
 8001b3e:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001b42:	f8cd e01c 	str.w	lr, [sp, #28]
 8001b46:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001b4a:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001b4e:	460a      	mov	r2, r1
 8001b50:	4601      	mov	r1, r0
 8001b52:	a80e      	add	r0, sp, #56	; 0x38
 8001b54:	9001      	str	r0, [sp, #4]
 8001b56:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001b5a:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001b5e:	f8cd c018 	str.w	ip, [sp, #24]
 8001b62:	2065      	movs	r0, #101	; 0x65
 8001b64:	f01f f864 	bl	8020c30 <cblas_zsymm>
      return GSL_SUCCESS;
 8001b68:	2000      	movs	r0, #0
}
 8001b6a:	b013      	add	sp, #76	; 0x4c
 8001b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001b6e:	4905      	ldr	r1, [pc, #20]	; (8001b84 <gsl_blas_zsymm+0xac>)
 8001b70:	4806      	ldr	r0, [pc, #24]	; (8001b8c <gsl_blas_zsymm+0xb4>)
 8001b72:	2314      	movs	r3, #20
 8001b74:	f240 52fc 	movw	r2, #1532	; 0x5fc
 8001b78:	f000 fe72 	bl	8002860 <gsl_error>
 8001b7c:	2014      	movs	r0, #20
}
 8001b7e:	b013      	add	sp, #76	; 0x4c
 8001b80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001b82:	bf00      	nop
 8001b84:	08030efc 	.word	0x08030efc
 8001b88:	08030f04 	.word	0x08030f04
 8001b8c:	08030f2c 	.word	0x08030f2c

08001b90 <gsl_blas_chemm>:
gsl_blas_chemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_matrix_complex_float * B,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8001b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b94:	4614      	mov	r4, r2
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
 8001b96:	6812      	ldr	r2, [r2, #0]
  const size_t NA = A->size2;
 8001b98:	6867      	ldr	r7, [r4, #4]
{
 8001b9a:	b08e      	sub	sp, #56	; 0x38
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001b9c:	42ba      	cmp	r2, r7
{
 8001b9e:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8001ba0:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
 8001ba4:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 8001ba8:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 8001bac:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  if (MA != NA)
 8001bb0:	d13d      	bne.n	8001c2e <gsl_blas_chemm+0x9e>
 8001bb2:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001bb4:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001bb6:	e9d6 3700 	ldrd	r3, r7, [r6]
  const size_t NB = B->size2;
 8001bba:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001bbe:	d012      	beq.n	8001be6 <gsl_blas_chemm+0x56>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001bc0:	288e      	cmp	r0, #142	; 0x8e
 8001bc2:	d105      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bc4:	4563      	cmp	r3, ip
 8001bc6:	d103      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bc8:	4297      	cmp	r7, r2
 8001bca:	d101      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bcc:	4577      	cmp	r7, lr
 8001bce:	d010      	beq.n	8001bf2 <gsl_blas_chemm+0x62>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001bd0:	491c      	ldr	r1, [pc, #112]	; (8001c44 <gsl_blas_chemm+0xb4>)
 8001bd2:	481d      	ldr	r0, [pc, #116]	; (8001c48 <gsl_blas_chemm+0xb8>)
 8001bd4:	2313      	movs	r3, #19
 8001bd6:	f240 622f 	movw	r2, #1583	; 0x62f
 8001bda:	f000 fe41 	bl	8002860 <gsl_error>
 8001bde:	2013      	movs	r0, #19
    }

}
 8001be0:	b00e      	add	sp, #56	; 0x38
 8001be2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d1f2      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bea:	4577      	cmp	r7, lr
 8001bec:	d1f0      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bee:	4563      	cmp	r3, ip
 8001bf0:	d1ee      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
      cblas_chemm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001bf2:	e9d6 8e02 	ldrd	r8, lr, [r6, #8]
 8001bf6:	9700      	str	r7, [sp, #0]
 8001bf8:	f8cd 8020 	str.w	r8, [sp, #32]
 8001bfc:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001c00:	f8cd e01c 	str.w	lr, [sp, #28]
 8001c04:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001c08:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001c0c:	460a      	mov	r2, r1
 8001c0e:	4601      	mov	r1, r0
 8001c10:	a80c      	add	r0, sp, #48	; 0x30
 8001c12:	9001      	str	r0, [sp, #4]
 8001c14:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001c18:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001c1c:	f8cd c018 	str.w	ip, [sp, #24]
 8001c20:	2065      	movs	r0, #101	; 0x65
 8001c22:	f011 ffb3 	bl	8013b8c <cblas_chemm>
      return GSL_SUCCESS;
 8001c26:	2000      	movs	r0, #0
}
 8001c28:	b00e      	add	sp, #56	; 0x38
 8001c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001c2e:	4905      	ldr	r1, [pc, #20]	; (8001c44 <gsl_blas_chemm+0xb4>)
 8001c30:	4806      	ldr	r0, [pc, #24]	; (8001c4c <gsl_blas_chemm+0xbc>)
 8001c32:	2314      	movs	r3, #20
 8001c34:	f240 6221 	movw	r2, #1569	; 0x621
 8001c38:	f000 fe12 	bl	8002860 <gsl_error>
 8001c3c:	2014      	movs	r0, #20
}
 8001c3e:	b00e      	add	sp, #56	; 0x38
 8001c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001c44:	08030efc 	.word	0x08030efc
 8001c48:	08030f04 	.word	0x08030f04
 8001c4c:	08030f2c 	.word	0x08030f2c

08001c50 <gsl_blas_zhemm>:
int
gsl_blas_zhemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_matrix_complex * B, const gsl_complex beta,
                gsl_matrix_complex * C)
{
 8001c50:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 8001c52:	e9d2 7600 	ldrd	r7, r6, [r2]
{
 8001c56:	b093      	sub	sp, #76	; 0x4c
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001c58:	42b7      	cmp	r7, r6
{
 8001c5a:	4614      	mov	r4, r2
 8001c5c:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 8001c60:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8001c64:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 8001c68:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
 8001c6c:	9a18      	ldr	r2, [sp, #96]	; 0x60
  if (MA != NA)
 8001c6e:	d13a      	bne.n	8001ce6 <gsl_blas_zhemm+0x96>
 8001c70:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001c72:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001c74:	e9d2 3600 	ldrd	r3, r6, [r2]
  const size_t NB = B->size2;
 8001c78:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001c7c:	d011      	beq.n	8001ca2 <gsl_blas_zhemm+0x52>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001c7e:	288e      	cmp	r0, #142	; 0x8e
 8001c80:	d105      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001c82:	4563      	cmp	r3, ip
 8001c84:	d103      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001c86:	42be      	cmp	r6, r7
 8001c88:	d101      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001c8a:	4576      	cmp	r6, lr
 8001c8c:	d00f      	beq.n	8001cae <gsl_blas_zhemm+0x5e>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001c8e:	491b      	ldr	r1, [pc, #108]	; (8001cfc <gsl_blas_zhemm+0xac>)
 8001c90:	481b      	ldr	r0, [pc, #108]	; (8001d00 <gsl_blas_zhemm+0xb0>)
 8001c92:	2313      	movs	r3, #19
 8001c94:	f240 6252 	movw	r2, #1618	; 0x652
 8001c98:	f000 fde2 	bl	8002860 <gsl_error>
 8001c9c:	2013      	movs	r0, #19
    }
}
 8001c9e:	b013      	add	sp, #76	; 0x4c
 8001ca0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001ca2:	42bb      	cmp	r3, r7
 8001ca4:	d1f3      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001ca6:	4576      	cmp	r6, lr
 8001ca8:	d1f1      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001caa:	4563      	cmp	r3, ip
 8001cac:	d1ef      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
      cblas_zhemm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001cae:	e9d2 7e02 	ldrd	r7, lr, [r2, #8]
 8001cb2:	9600      	str	r6, [sp, #0]
 8001cb4:	9708      	str	r7, [sp, #32]
 8001cb6:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001cba:	f8cd e01c 	str.w	lr, [sp, #28]
 8001cbe:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001cc2:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001cc6:	460a      	mov	r2, r1
 8001cc8:	4601      	mov	r1, r0
 8001cca:	a80e      	add	r0, sp, #56	; 0x38
 8001ccc:	9001      	str	r0, [sp, #4]
 8001cce:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001cd2:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001cd6:	f8cd c018 	str.w	ip, [sp, #24]
 8001cda:	2065      	movs	r0, #101	; 0x65
 8001cdc:	f01a fc50 	bl	801c580 <cblas_zhemm>
      return GSL_SUCCESS;
 8001ce0:	2000      	movs	r0, #0
}
 8001ce2:	b013      	add	sp, #76	; 0x4c
 8001ce4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001ce6:	4905      	ldr	r1, [pc, #20]	; (8001cfc <gsl_blas_zhemm+0xac>)
 8001ce8:	4806      	ldr	r0, [pc, #24]	; (8001d04 <gsl_blas_zhemm+0xb4>)
 8001cea:	2314      	movs	r3, #20
 8001cec:	f240 6244 	movw	r2, #1604	; 0x644
 8001cf0:	f000 fdb6 	bl	8002860 <gsl_error>
 8001cf4:	2014      	movs	r0, #20
}
 8001cf6:	b013      	add	sp, #76	; 0x4c
 8001cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001cfa:	bf00      	nop
 8001cfc:	08030efc 	.word	0x08030efc
 8001d00:	08030f04 	.word	0x08030f04
 8001d04:	08030f2c 	.word	0x08030f2c

08001d08 <gsl_blas_ssyrk>:
/* SYRK */

int
gsl_blas_ssyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
                const gsl_matrix_float * A, float beta, gsl_matrix_float * C)
{
 8001d08:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d0a:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001d0c:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d10:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001d14:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d16:	d102      	bne.n	8001d1e <gsl_blas_ssyrk+0x16>
 8001d18:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d1a:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d1c:	4665      	mov	r5, ip

  if (M != N)
 8001d1e:	42bc      	cmp	r4, r7
 8001d20:	d11d      	bne.n	8001d5e <gsl_blas_ssyrk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001d22:	42ac      	cmp	r4, r5
 8001d24:	d111      	bne.n	8001d4a <gsl_blas_ssyrk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ssyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001d26:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001d2a:	9600      	str	r6, [sp, #0]
 8001d2c:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001d30:	460a      	mov	r2, r1
 8001d32:	9301      	str	r3, [sp, #4]
 8001d34:	4601      	mov	r1, r0
 8001d36:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001d3a:	9504      	str	r5, [sp, #16]
 8001d3c:	4623      	mov	r3, r4
 8001d3e:	2065      	movs	r0, #101	; 0x65
 8001d40:	f008 fcba 	bl	800a6b8 <cblas_ssyrk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001d44:	2000      	movs	r0, #0
}
 8001d46:	b007      	add	sp, #28
 8001d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001d4a:	490a      	ldr	r1, [pc, #40]	; (8001d74 <gsl_blas_ssyrk+0x6c>)
 8001d4c:	480a      	ldr	r0, [pc, #40]	; (8001d78 <gsl_blas_ssyrk+0x70>)
 8001d4e:	2313      	movs	r3, #19
 8001d50:	f240 6267 	movw	r2, #1639	; 0x667
 8001d54:	f000 fd84 	bl	8002860 <gsl_error>
 8001d58:	2013      	movs	r0, #19
}
 8001d5a:	b007      	add	sp, #28
 8001d5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001d5e:	4905      	ldr	r1, [pc, #20]	; (8001d74 <gsl_blas_ssyrk+0x6c>)
 8001d60:	4806      	ldr	r0, [pc, #24]	; (8001d7c <gsl_blas_ssyrk+0x74>)
 8001d62:	2314      	movs	r3, #20
 8001d64:	f240 6263 	movw	r2, #1635	; 0x663
 8001d68:	f000 fd7a 	bl	8002860 <gsl_error>
 8001d6c:	2014      	movs	r0, #20
}
 8001d6e:	b007      	add	sp, #28
 8001d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d72:	bf00      	nop
 8001d74:	08030efc 	.word	0x08030efc
 8001d78:	08030f04 	.word	0x08030f04
 8001d7c:	08030f44 	.word	0x08030f44

08001d80 <gsl_blas_dsyrk>:


int
gsl_blas_dsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
                const gsl_matrix * A, double beta, gsl_matrix * C)
{
 8001d80:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d82:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001d84:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d88:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001d8c:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d8e:	d102      	bne.n	8001d96 <gsl_blas_dsyrk+0x16>
 8001d90:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d92:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d94:	4665      	mov	r5, ip

  if (M != N)
 8001d96:	42bc      	cmp	r4, r7
 8001d98:	d11d      	bne.n	8001dd6 <gsl_blas_dsyrk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001d9a:	42ac      	cmp	r4, r5
 8001d9c:	d111      	bne.n	8001dc2 <gsl_blas_dsyrk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dsyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001d9e:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001da2:	9600      	str	r6, [sp, #0]
 8001da4:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001da8:	460a      	mov	r2, r1
 8001daa:	9301      	str	r3, [sp, #4]
 8001dac:	4601      	mov	r1, r0
 8001dae:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001db2:	9504      	str	r5, [sp, #16]
 8001db4:	4623      	mov	r3, r4
 8001db6:	2065      	movs	r0, #101	; 0x65
 8001db8:	f00d ff16 	bl	800fbe8 <cblas_dsyrk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001dbc:	2000      	movs	r0, #0

}
 8001dbe:	b007      	add	sp, #28
 8001dc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001dc2:	490a      	ldr	r1, [pc, #40]	; (8001dec <gsl_blas_dsyrk+0x6c>)
 8001dc4:	480a      	ldr	r0, [pc, #40]	; (8001df0 <gsl_blas_dsyrk+0x70>)
 8001dc6:	2313      	movs	r3, #19
 8001dc8:	f240 627f 	movw	r2, #1663	; 0x67f
 8001dcc:	f000 fd48 	bl	8002860 <gsl_error>
 8001dd0:	2013      	movs	r0, #19
}
 8001dd2:	b007      	add	sp, #28
 8001dd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001dd6:	4905      	ldr	r1, [pc, #20]	; (8001dec <gsl_blas_dsyrk+0x6c>)
 8001dd8:	4806      	ldr	r0, [pc, #24]	; (8001df4 <gsl_blas_dsyrk+0x74>)
 8001dda:	2314      	movs	r3, #20
 8001ddc:	f240 627b 	movw	r2, #1659	; 0x67b
 8001de0:	f000 fd3e 	bl	8002860 <gsl_error>
 8001de4:	2014      	movs	r0, #20
}
 8001de6:	b007      	add	sp, #28
 8001de8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001dea:	bf00      	nop
 8001dec:	08030efc 	.word	0x08030efc
 8001df0:	08030f04 	.word	0x08030f04
 8001df4:	08030f44 	.word	0x08030f44

08001df8 <gsl_blas_csyrk>:
int
gsl_blas_csyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8001df8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001dfa:	4614      	mov	r4, r2
 8001dfc:	460a      	mov	r2, r1
 8001dfe:	b08d      	sub	sp, #52	; 0x34
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e00:	2a6f      	cmp	r2, #111	; 0x6f
{
 8001e02:	4601      	mov	r1, r0
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001e04:	e9d4 6500 	ldrd	r6, r5, [r4]
  const size_t N = C->size2;
 8001e08:	e9d3 0700 	ldrd	r0, r7, [r3]
{
 8001e0c:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
 8001e10:	edcd 0a0b 	vstr	s1, [sp, #44]	; 0x2c
 8001e14:	ed8d 1a08 	vstr	s2, [sp, #32]
 8001e18:	edcd 1a09 	vstr	s3, [sp, #36]	; 0x24
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e1c:	d102      	bne.n	8001e24 <gsl_blas_csyrk+0x2c>
 8001e1e:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001e20:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e22:	4665      	mov	r5, ip

  if (M != N)
 8001e24:	42b8      	cmp	r0, r7
 8001e26:	d11f      	bne.n	8001e68 <gsl_blas_csyrk+0x70>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001e28:	42a8      	cmp	r0, r5
 8001e2a:	d113      	bne.n	8001e54 <gsl_blas_csyrk+0x5c>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_csyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K),
 8001e2c:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001e30:	9600      	str	r6, [sp, #0]
 8001e32:	9506      	str	r5, [sp, #24]
 8001e34:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001e38:	4603      	mov	r3, r0
 8001e3a:	ae08      	add	r6, sp, #32
 8001e3c:	a80a      	add	r0, sp, #40	; 0x28
 8001e3e:	e9cd 0401 	strd	r0, r4, [sp, #4]
 8001e42:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8001e46:	9705      	str	r7, [sp, #20]
 8001e48:	2065      	movs	r0, #101	; 0x65
 8001e4a:	f015 f99b 	bl	8017184 <cblas_csyrk>
               GSL_COMPLEX_P (&alpha), A->data, INT (A->tda),
               GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001e4e:	2000      	movs	r0, #0
}
 8001e50:	b00d      	add	sp, #52	; 0x34
 8001e52:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001e54:	4909      	ldr	r1, [pc, #36]	; (8001e7c <gsl_blas_csyrk+0x84>)
 8001e56:	480a      	ldr	r0, [pc, #40]	; (8001e80 <gsl_blas_csyrk+0x88>)
 8001e58:	2313      	movs	r3, #19
 8001e5a:	f240 629a 	movw	r2, #1690	; 0x69a
 8001e5e:	f000 fcff 	bl	8002860 <gsl_error>
 8001e62:	2013      	movs	r0, #19
}
 8001e64:	b00d      	add	sp, #52	; 0x34
 8001e66:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001e68:	4904      	ldr	r1, [pc, #16]	; (8001e7c <gsl_blas_csyrk+0x84>)
 8001e6a:	4806      	ldr	r0, [pc, #24]	; (8001e84 <gsl_blas_csyrk+0x8c>)
 8001e6c:	2314      	movs	r3, #20
 8001e6e:	f240 6296 	movw	r2, #1686	; 0x696
 8001e72:	f000 fcf5 	bl	8002860 <gsl_error>
 8001e76:	2014      	movs	r0, #20
}
 8001e78:	b00d      	add	sp, #52	; 0x34
 8001e7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001e7c:	08030efc 	.word	0x08030efc
 8001e80:	08030f04 	.word	0x08030f04
 8001e84:	08030f44 	.word	0x08030f44

08001e88 <gsl_blas_zsyrk>:

int
gsl_blas_zsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_complex beta, gsl_matrix_complex * C)
{
 8001e88:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e8a:	4614      	mov	r4, r2
 8001e8c:	460a      	mov	r2, r1
 8001e8e:	b091      	sub	sp, #68	; 0x44
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e90:	2a6f      	cmp	r2, #111	; 0x6f
{
 8001e92:	4601      	mov	r1, r0
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001e94:	e9d4 6500 	ldrd	r6, r5, [r4]
  const size_t N = C->size2;
 8001e98:	e9d3 0700 	ldrd	r0, r7, [r3]
{
 8001e9c:	ed8d 0b0c 	vstr	d0, [sp, #48]	; 0x30
 8001ea0:	ed8d 1b0e 	vstr	d1, [sp, #56]	; 0x38
 8001ea4:	ed8d 2b08 	vstr	d2, [sp, #32]
 8001ea8:	ed8d 3b0a 	vstr	d3, [sp, #40]	; 0x28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001eac:	d102      	bne.n	8001eb4 <gsl_blas_zsyrk+0x2c>
 8001eae:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001eb0:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001eb2:	4665      	mov	r5, ip

  if (M != N)
 8001eb4:	42b8      	cmp	r0, r7
 8001eb6:	d11f      	bne.n	8001ef8 <gsl_blas_zsyrk+0x70>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001eb8:	42a8      	cmp	r0, r5
 8001eba:	d113      	bne.n	8001ee4 <gsl_blas_zsyrk+0x5c>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_zsyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K),
 8001ebc:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001ec0:	9600      	str	r6, [sp, #0]
 8001ec2:	9506      	str	r5, [sp, #24]
 8001ec4:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001ec8:	4603      	mov	r3, r0
 8001eca:	ae08      	add	r6, sp, #32
 8001ecc:	a80c      	add	r0, sp, #48	; 0x30
 8001ece:	e9cd 0401 	strd	r0, r4, [sp, #4]
 8001ed2:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8001ed6:	9705      	str	r7, [sp, #20]
 8001ed8:	2065      	movs	r0, #101	; 0x65
 8001eda:	f020 fef9 	bl	8022cd0 <cblas_zsyrk>
               GSL_COMPLEX_P (&alpha), A->data, INT (A->tda),
               GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001ede:	2000      	movs	r0, #0
}
 8001ee0:	b011      	add	sp, #68	; 0x44
 8001ee2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001ee4:	4909      	ldr	r1, [pc, #36]	; (8001f0c <gsl_blas_zsyrk+0x84>)
 8001ee6:	480a      	ldr	r0, [pc, #40]	; (8001f10 <gsl_blas_zsyrk+0x88>)
 8001ee8:	2313      	movs	r3, #19
 8001eea:	f240 62b4 	movw	r2, #1716	; 0x6b4
 8001eee:	f000 fcb7 	bl	8002860 <gsl_error>
 8001ef2:	2013      	movs	r0, #19
}
 8001ef4:	b011      	add	sp, #68	; 0x44
 8001ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001ef8:	4904      	ldr	r1, [pc, #16]	; (8001f0c <gsl_blas_zsyrk+0x84>)
 8001efa:	4806      	ldr	r0, [pc, #24]	; (8001f14 <gsl_blas_zsyrk+0x8c>)
 8001efc:	2314      	movs	r3, #20
 8001efe:	f44f 62d6 	mov.w	r2, #1712	; 0x6b0
 8001f02:	f000 fcad 	bl	8002860 <gsl_error>
 8001f06:	2014      	movs	r0, #20
}
 8001f08:	b011      	add	sp, #68	; 0x44
 8001f0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f0c:	08030efc 	.word	0x08030efc
 8001f10:	08030f04 	.word	0x08030f04
 8001f14:	08030f44 	.word	0x08030f44

08001f18 <gsl_blas_cherk>:

int
gsl_blas_cherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
                const gsl_matrix_complex_float * A, float beta,
                gsl_matrix_complex_float * C)
{
 8001f18:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f1a:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001f1c:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001f20:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001f24:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f26:	d102      	bne.n	8001f2e <gsl_blas_cherk+0x16>
 8001f28:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001f2a:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f2c:	4665      	mov	r5, ip

  if (M != N)
 8001f2e:	42bc      	cmp	r4, r7
 8001f30:	d11d      	bne.n	8001f6e <gsl_blas_cherk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001f32:	42ac      	cmp	r4, r5
 8001f34:	d111      	bne.n	8001f5a <gsl_blas_cherk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_cherk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001f36:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001f3a:	9600      	str	r6, [sp, #0]
 8001f3c:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001f40:	460a      	mov	r2, r1
 8001f42:	9301      	str	r3, [sp, #4]
 8001f44:	4601      	mov	r1, r0
 8001f46:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001f4a:	9504      	str	r5, [sp, #16]
 8001f4c:	4623      	mov	r3, r4
 8001f4e:	2065      	movs	r0, #101	; 0x65
 8001f50:	f013 fd06 	bl	8015960 <cblas_cherk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001f54:	2000      	movs	r0, #0
}
 8001f56:	b007      	add	sp, #28
 8001f58:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001f5a:	490a      	ldr	r1, [pc, #40]	; (8001f84 <gsl_blas_cherk+0x6c>)
 8001f5c:	480a      	ldr	r0, [pc, #40]	; (8001f88 <gsl_blas_cherk+0x70>)
 8001f5e:	2313      	movs	r3, #19
 8001f60:	f240 62cf 	movw	r2, #1743	; 0x6cf
 8001f64:	f000 fc7c 	bl	8002860 <gsl_error>
 8001f68:	2013      	movs	r0, #19
}
 8001f6a:	b007      	add	sp, #28
 8001f6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001f6e:	4905      	ldr	r1, [pc, #20]	; (8001f84 <gsl_blas_cherk+0x6c>)
 8001f70:	4806      	ldr	r0, [pc, #24]	; (8001f8c <gsl_blas_cherk+0x74>)
 8001f72:	2314      	movs	r3, #20
 8001f74:	f240 62cb 	movw	r2, #1739	; 0x6cb
 8001f78:	f000 fc72 	bl	8002860 <gsl_error>
 8001f7c:	2014      	movs	r0, #20
}
 8001f7e:	b007      	add	sp, #28
 8001f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f82:	bf00      	nop
 8001f84:	08030efc 	.word	0x08030efc
 8001f88:	08030f04 	.word	0x08030f04
 8001f8c:	08030f44 	.word	0x08030f44

08001f90 <gsl_blas_zherk>:

int
gsl_blas_zherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
                const gsl_matrix_complex * A, double beta,
                gsl_matrix_complex * C)
{
 8001f90:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f92:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001f94:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001f98:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001f9c:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f9e:	d102      	bne.n	8001fa6 <gsl_blas_zherk+0x16>
 8001fa0:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001fa2:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001fa4:	4665      	mov	r5, ip

  if (M != N)
 8001fa6:	42bc      	cmp	r4, r7
 8001fa8:	d11d      	bne.n	8001fe6 <gsl_blas_zherk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001faa:	42ac      	cmp	r4, r5
 8001fac:	d111      	bne.n	8001fd2 <gsl_blas_zherk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_zherk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001fae:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001fb2:	9600      	str	r6, [sp, #0]
 8001fb4:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001fb8:	460a      	mov	r2, r1
 8001fba:	9301      	str	r3, [sp, #4]
 8001fbc:	4601      	mov	r1, r0
 8001fbe:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001fc2:	9504      	str	r5, [sp, #16]
 8001fc4:	4623      	mov	r3, r4
 8001fc6:	2065      	movs	r0, #101	; 0x65
 8001fc8:	f01d fffa 	bl	801ffc0 <cblas_zherk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001fcc:	2000      	movs	r0, #0
}
 8001fce:	b007      	add	sp, #28
 8001fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001fd2:	490a      	ldr	r1, [pc, #40]	; (8001ffc <gsl_blas_zherk+0x6c>)
 8001fd4:	480a      	ldr	r0, [pc, #40]	; (8002000 <gsl_blas_zherk+0x70>)
 8001fd6:	2313      	movs	r3, #19
 8001fd8:	f44f 62dd 	mov.w	r2, #1768	; 0x6e8
 8001fdc:	f000 fc40 	bl	8002860 <gsl_error>
 8001fe0:	2013      	movs	r0, #19
}
 8001fe2:	b007      	add	sp, #28
 8001fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001fe6:	4905      	ldr	r1, [pc, #20]	; (8001ffc <gsl_blas_zherk+0x6c>)
 8001fe8:	4806      	ldr	r0, [pc, #24]	; (8002004 <gsl_blas_zherk+0x74>)
 8001fea:	2314      	movs	r3, #20
 8001fec:	f240 62e4 	movw	r2, #1764	; 0x6e4
 8001ff0:	f000 fc36 	bl	8002860 <gsl_error>
 8001ff4:	2014      	movs	r0, #20
}
 8001ff6:	b007      	add	sp, #28
 8001ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001ffa:	bf00      	nop
 8001ffc:	08030efc 	.word	0x08030efc
 8002000:	08030f04 	.word	0x08030f04
 8002004:	08030f44 	.word	0x08030f44

08002008 <gsl_blas_ssyr2k>:

int
gsl_blas_ssyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
                 const gsl_matrix_float * A, const gsl_matrix_float * B,
                 float beta, gsl_matrix_float * C)
{
 8002008:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800200c:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800200e:	296f      	cmp	r1, #111	; 0x6f
{
 8002010:	9e10      	ldr	r6, [sp, #64]	; 0x40
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002012:	e9d3 ec00 	ldrd	lr, ip, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002016:	e9d2 8700 	ldrd	r8, r7, [r2]
  const size_t N = C->size2;
 800201a:	e9d6 5400 	ldrd	r5, r4, [r6]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800201e:	d105      	bne.n	800202c <gsl_blas_ssyr2k+0x24>
 8002020:	46ba      	mov	sl, r7
 8002022:	46f1      	mov	r9, lr
 8002024:	4647      	mov	r7, r8
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002026:	46e6      	mov	lr, ip
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8002028:	46d0      	mov	r8, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 800202a:	46cc      	mov	ip, r9

  if (M != N)
 800202c:	42a5      	cmp	r5, r4
 800202e:	d110      	bne.n	8002052 <gsl_blas_ssyr2k+0x4a>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 8002030:	42bd      	cmp	r5, r7
 8002032:	d103      	bne.n	800203c <gsl_blas_ssyr2k+0x34>
 8002034:	4565      	cmp	r5, ip
 8002036:	d101      	bne.n	800203c <gsl_blas_ssyr2k+0x34>
 8002038:	45c6      	cmp	lr, r8
 800203a:	d015      	beq.n	8002068 <gsl_blas_ssyr2k+0x60>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800203c:	4917      	ldr	r1, [pc, #92]	; (800209c <gsl_blas_ssyr2k+0x94>)
 800203e:	4818      	ldr	r0, [pc, #96]	; (80020a0 <gsl_blas_ssyr2k+0x98>)
 8002040:	2313      	movs	r3, #19
 8002042:	f240 7204 	movw	r2, #1796	; 0x704
 8002046:	f000 fc0b 	bl	8002860 <gsl_error>
 800204a:	2013      	movs	r0, #19

  cblas_ssyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
                INT (A->tda), B->data, INT (B->tda), beta, C->data,
                INT (C->tda));
  return GSL_SUCCESS;
}
 800204c:	b008      	add	sp, #32
 800204e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8002052:	4912      	ldr	r1, [pc, #72]	; (800209c <gsl_blas_ssyr2k+0x94>)
 8002054:	4813      	ldr	r0, [pc, #76]	; (80020a4 <gsl_blas_ssyr2k+0x9c>)
 8002056:	2314      	movs	r3, #20
 8002058:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800205c:	f000 fc00 	bl	8002860 <gsl_error>
 8002060:	2014      	movs	r0, #20
}
 8002062:	b008      	add	sp, #32
 8002064:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_ssyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
 8002068:	e9d6 4802 	ldrd	r4, r8, [r6, #8]
 800206c:	f8cd e000 	str.w	lr, [sp]
 8002070:	e9d3 c702 	ldrd	ip, r7, [r3, #8]
 8002074:	9406      	str	r4, [sp, #24]
 8002076:	e9d2 6402 	ldrd	r6, r4, [r2, #8]
 800207a:	462b      	mov	r3, r5
 800207c:	460a      	mov	r2, r1
 800207e:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 8002082:	4601      	mov	r1, r0
 8002084:	e9cd 4601 	strd	r4, r6, [sp, #4]
 8002088:	f8cd 8014 	str.w	r8, [sp, #20]
 800208c:	2065      	movs	r0, #101	; 0x65
 800208e:	f008 f807 	bl	800a0a0 <cblas_ssyr2k>
  return GSL_SUCCESS;
 8002092:	2000      	movs	r0, #0
}
 8002094:	b008      	add	sp, #32
 8002096:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800209a:	bf00      	nop
 800209c:	08030efc 	.word	0x08030efc
 80020a0:	08030f04 	.word	0x08030f04
 80020a4:	08030f44 	.word	0x08030f44

080020a8 <gsl_blas_dsyr2k>:

int
gsl_blas_dsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
                 const gsl_matrix * A, const gsl_matrix * B, double beta,
                 gsl_matrix * C)
{
 80020a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80020ac:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80020ae:	296f      	cmp	r1, #111	; 0x6f
{
 80020b0:	9d10      	ldr	r5, [sp, #64]	; 0x40
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80020b2:	e9d3 c700 	ldrd	ip, r7, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80020b6:	e9d2 e600 	ldrd	lr, r6, [r2]
  const size_t N = C->size2;
 80020ba:	e9d5 4800 	ldrd	r4, r8, [r5]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80020be:	d105      	bne.n	80020cc <gsl_blas_dsyr2k+0x24>
 80020c0:	46b2      	mov	sl, r6
 80020c2:	46e1      	mov	r9, ip
 80020c4:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80020c6:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 80020c8:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 80020ca:	464f      	mov	r7, r9

  if (M != N)
 80020cc:	4544      	cmp	r4, r8
 80020ce:	d110      	bne.n	80020f2 <gsl_blas_dsyr2k+0x4a>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 80020d0:	42b4      	cmp	r4, r6
 80020d2:	d103      	bne.n	80020dc <gsl_blas_dsyr2k+0x34>
 80020d4:	42bc      	cmp	r4, r7
 80020d6:	d101      	bne.n	80020dc <gsl_blas_dsyr2k+0x34>
 80020d8:	45f4      	cmp	ip, lr
 80020da:	d015      	beq.n	8002108 <gsl_blas_dsyr2k+0x60>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80020dc:	4917      	ldr	r1, [pc, #92]	; (800213c <gsl_blas_dsyr2k+0x94>)
 80020de:	4818      	ldr	r0, [pc, #96]	; (8002140 <gsl_blas_dsyr2k+0x98>)
 80020e0:	2313      	movs	r3, #19
 80020e2:	f44f 62e4 	mov.w	r2, #1824	; 0x720
 80020e6:	f000 fbbb 	bl	8002860 <gsl_error>
 80020ea:	2013      	movs	r0, #19

  cblas_dsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
                INT (A->tda), B->data, INT (B->tda), beta, C->data,
                INT (C->tda));
  return GSL_SUCCESS;
}
 80020ec:	b008      	add	sp, #32
 80020ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 80020f2:	4912      	ldr	r1, [pc, #72]	; (800213c <gsl_blas_dsyr2k+0x94>)
 80020f4:	4813      	ldr	r0, [pc, #76]	; (8002144 <gsl_blas_dsyr2k+0x9c>)
 80020f6:	2314      	movs	r3, #20
 80020f8:	f240 721c 	movw	r2, #1820	; 0x71c
 80020fc:	f000 fbb0 	bl	8002860 <gsl_error>
 8002100:	2014      	movs	r0, #20
}
 8002102:	b008      	add	sp, #32
 8002104:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_dsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
 8002108:	e9d5 6e02 	ldrd	r6, lr, [r5, #8]
 800210c:	f8cd c000 	str.w	ip, [sp]
 8002110:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8002114:	9606      	str	r6, [sp, #24]
 8002116:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 800211a:	460a      	mov	r2, r1
 800211c:	9301      	str	r3, [sp, #4]
 800211e:	4601      	mov	r1, r0
 8002120:	e9cd 7503 	strd	r7, r5, [sp, #12]
 8002124:	f8cd e014 	str.w	lr, [sp, #20]
 8002128:	4623      	mov	r3, r4
 800212a:	9602      	str	r6, [sp, #8]
 800212c:	2065      	movs	r0, #101	; 0x65
 800212e:	f00d f907 	bl	800f340 <cblas_dsyr2k>
  return GSL_SUCCESS;
 8002132:	2000      	movs	r0, #0
}
 8002134:	b008      	add	sp, #32
 8002136:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800213a:	bf00      	nop
 800213c:	08030efc 	.word	0x08030efc
 8002140:	08030f04 	.word	0x08030f04
 8002144:	08030f44 	.word	0x08030f44

08002148 <gsl_blas_csyr2k>:
gsl_blas_csyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex_float alpha,
                 const gsl_matrix_complex_float * A,
                 const gsl_matrix_complex_float * B,
                 const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8002148:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800214c:	b08e      	sub	sp, #56	; 0x38
 800214e:	4614      	mov	r4, r2
 8002150:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8002152:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002156:	296f      	cmp	r1, #111	; 0x6f
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002158:	e9d3 c700 	ldrd	ip, r7, [r3]
{
 800215c:	461d      	mov	r5, r3
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800215e:	e9d4 e600 	ldrd	lr, r6, [r4]
  const size_t N = C->size2;
 8002162:	e9d2 3800 	ldrd	r3, r8, [r2]
{
 8002166:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 800216a:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 800216e:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002172:	d105      	bne.n	8002180 <gsl_blas_csyr2k+0x38>
 8002174:	46b2      	mov	sl, r6
 8002176:	46e1      	mov	r9, ip
 8002178:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 800217a:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 800217c:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 800217e:	464f      	mov	r7, r9

  if (M != N)
 8002180:	4543      	cmp	r3, r8
 8002182:	d110      	bne.n	80021a6 <gsl_blas_csyr2k+0x5e>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 8002184:	42b3      	cmp	r3, r6
 8002186:	d103      	bne.n	8002190 <gsl_blas_csyr2k+0x48>
 8002188:	42bb      	cmp	r3, r7
 800218a:	d101      	bne.n	8002190 <gsl_blas_csyr2k+0x48>
 800218c:	45f4      	cmp	ip, lr
 800218e:	d015      	beq.n	80021bc <gsl_blas_csyr2k+0x74>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8002190:	4919      	ldr	r1, [pc, #100]	; (80021f8 <gsl_blas_csyr2k+0xb0>)
 8002192:	481a      	ldr	r0, [pc, #104]	; (80021fc <gsl_blas_csyr2k+0xb4>)
 8002194:	2313      	movs	r3, #19
 8002196:	f240 723e 	movw	r2, #1854	; 0x73e
 800219a:	f000 fb61 	bl	8002860 <gsl_error>
 800219e:	2013      	movs	r0, #19

  cblas_csyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
}
 80021a0:	b00e      	add	sp, #56	; 0x38
 80021a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 80021a6:	4914      	ldr	r1, [pc, #80]	; (80021f8 <gsl_blas_csyr2k+0xb0>)
 80021a8:	4815      	ldr	r0, [pc, #84]	; (8002200 <gsl_blas_csyr2k+0xb8>)
 80021aa:	2314      	movs	r3, #20
 80021ac:	f240 723a 	movw	r2, #1850	; 0x73a
 80021b0:	f000 fb56 	bl	8002860 <gsl_error>
 80021b4:	2014      	movs	r0, #20
}
 80021b6:	b00e      	add	sp, #56	; 0x38
 80021b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_csyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 80021bc:	e9d2 6e02 	ldrd	r6, lr, [r2, #8]
 80021c0:	f8cd c000 	str.w	ip, [sp]
 80021c4:	9608      	str	r6, [sp, #32]
 80021c6:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 80021ca:	f8cd e01c 	str.w	lr, [sp, #28]
 80021ce:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 80021d2:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 80021d6:	460a      	mov	r2, r1
 80021d8:	4601      	mov	r1, r0
 80021da:	a80c      	add	r0, sp, #48	; 0x30
 80021dc:	9001      	str	r0, [sp, #4]
 80021de:	e9cd 6704 	strd	r6, r7, [sp, #16]
 80021e2:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80021e6:	f8cd c018 	str.w	ip, [sp, #24]
 80021ea:	2065      	movs	r0, #101	; 0x65
 80021ec:	f014 fc32 	bl	8016a54 <cblas_csyr2k>
  return GSL_SUCCESS;
 80021f0:	2000      	movs	r0, #0
}
 80021f2:	b00e      	add	sp, #56	; 0x38
 80021f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80021f8:	08030efc 	.word	0x08030efc
 80021fc:	08030f04 	.word	0x08030f04
 8002200:	08030f44 	.word	0x08030f44

08002204 <gsl_blas_zsyr2k>:
int
gsl_blas_zsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex alpha, const gsl_matrix_complex * A,
                 const gsl_matrix_complex * B, const gsl_complex beta,
                 gsl_matrix_complex * C)
{
 8002204:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002208:	b092      	sub	sp, #72	; 0x48
 800220a:	4614      	mov	r4, r2
 800220c:	9a1a      	ldr	r2, [sp, #104]	; 0x68
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800220e:	296f      	cmp	r1, #111	; 0x6f
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002210:	e9d3 c700 	ldrd	ip, r7, [r3]
{
 8002214:	461d      	mov	r5, r3
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002216:	e9d4 e600 	ldrd	lr, r6, [r4]
{
 800221a:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 800221e:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8002222:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 8002226:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
  const size_t N = C->size2;
 800222a:	e9d2 3800 	ldrd	r3, r8, [r2]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800222e:	d105      	bne.n	800223c <gsl_blas_zsyr2k+0x38>
 8002230:	46b2      	mov	sl, r6
 8002232:	46e1      	mov	r9, ip
 8002234:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002236:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8002238:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 800223a:	464f      	mov	r7, r9

  if (M != N)
 800223c:	4543      	cmp	r3, r8
 800223e:	d110      	bne.n	8002262 <gsl_blas_zsyr2k+0x5e>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 8002240:	42b3      	cmp	r3, r6
 8002242:	d103      	bne.n	800224c <gsl_blas_zsyr2k+0x48>
 8002244:	42bb      	cmp	r3, r7
 8002246:	d101      	bne.n	800224c <gsl_blas_zsyr2k+0x48>
 8002248:	45f4      	cmp	ip, lr
 800224a:	d015      	beq.n	8002278 <gsl_blas_zsyr2k+0x74>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800224c:	4919      	ldr	r1, [pc, #100]	; (80022b4 <gsl_blas_zsyr2k+0xb0>)
 800224e:	481a      	ldr	r0, [pc, #104]	; (80022b8 <gsl_blas_zsyr2k+0xb4>)
 8002250:	2313      	movs	r3, #19
 8002252:	f240 725c 	movw	r2, #1884	; 0x75c
 8002256:	f000 fb03 	bl	8002860 <gsl_error>
 800225a:	2013      	movs	r0, #19

  cblas_zsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
}
 800225c:	b012      	add	sp, #72	; 0x48
 800225e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8002262:	4914      	ldr	r1, [pc, #80]	; (80022b4 <gsl_blas_zsyr2k+0xb0>)
 8002264:	4815      	ldr	r0, [pc, #84]	; (80022bc <gsl_blas_zsyr2k+0xb8>)
 8002266:	2314      	movs	r3, #20
 8002268:	f44f 62eb 	mov.w	r2, #1880	; 0x758
 800226c:	f000 faf8 	bl	8002860 <gsl_error>
 8002270:	2014      	movs	r0, #20
}
 8002272:	b012      	add	sp, #72	; 0x48
 8002274:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_zsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 8002278:	e9d2 6e02 	ldrd	r6, lr, [r2, #8]
 800227c:	f8cd c000 	str.w	ip, [sp]
 8002280:	9608      	str	r6, [sp, #32]
 8002282:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8002286:	f8cd e01c 	str.w	lr, [sp, #28]
 800228a:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 800228e:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8002292:	460a      	mov	r2, r1
 8002294:	4601      	mov	r1, r0
 8002296:	a80e      	add	r0, sp, #56	; 0x38
 8002298:	9001      	str	r0, [sp, #4]
 800229a:	e9cd 6704 	strd	r6, r7, [sp, #16]
 800229e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80022a2:	f8cd c018 	str.w	ip, [sp, #24]
 80022a6:	2065      	movs	r0, #101	; 0x65
 80022a8:	f01f fdce 	bl	8021e48 <cblas_zsyr2k>
  return GSL_SUCCESS;
 80022ac:	2000      	movs	r0, #0
}
 80022ae:	b012      	add	sp, #72	; 0x48
 80022b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80022b4:	08030efc 	.word	0x08030efc
 80022b8:	08030f04 	.word	0x08030f04
 80022bc:	08030f44 	.word	0x08030f44

080022c0 <gsl_blas_cher2k>:
gsl_blas_cher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex_float alpha,
                 const gsl_matrix_complex_float * A,
                 const gsl_matrix_complex_float * B, float beta,
                 gsl_matrix_complex_float * C)
{
 80022c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80022c4:	b08a      	sub	sp, #40	; 0x28
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80022c6:	296f      	cmp	r1, #111	; 0x6f
{
 80022c8:	9e12      	ldr	r6, [sp, #72]	; 0x48
 80022ca:	ed8d 0a08 	vstr	s0, [sp, #32]
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80022ce:	e9d3 ec00 	ldrd	lr, ip, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80022d2:	e9d2 8700 	ldrd	r8, r7, [r2]
  const size_t N = C->size2;
 80022d6:	e9d6 4500 	ldrd	r4, r5, [r6]
{
 80022da:	edcd 0a09 	vstr	s1, [sp, #36]	; 0x24
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80022de:	d105      	bne.n	80022ec <gsl_blas_cher2k+0x2c>
 80022e0:	46ba      	mov	sl, r7
 80022e2:	46f1      	mov	r9, lr
 80022e4:	4647      	mov	r7, r8
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80022e6:	46e6      	mov	lr, ip
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 80022e8:	46d0      	mov	r8, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 80022ea:	46cc      	mov	ip, r9

  if (M != N)
 80022ec:	42ac      	cmp	r4, r5
 80022ee:	d110      	bne.n	8002312 <gsl_blas_cher2k+0x52>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 80022f0:	42bc      	cmp	r4, r7
 80022f2:	d103      	bne.n	80022fc <gsl_blas_cher2k+0x3c>
 80022f4:	4564      	cmp	r4, ip
 80022f6:	d101      	bne.n	80022fc <gsl_blas_cher2k+0x3c>
 80022f8:	45c6      	cmp	lr, r8
 80022fa:	d015      	beq.n	8002328 <gsl_blas_cher2k+0x68>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80022fc:	4918      	ldr	r1, [pc, #96]	; (8002360 <gsl_blas_cher2k+0xa0>)
 80022fe:	4819      	ldr	r0, [pc, #100]	; (8002364 <gsl_blas_cher2k+0xa4>)
 8002300:	2313      	movs	r3, #19
 8002302:	f240 727b 	movw	r2, #1915	; 0x77b
 8002306:	f000 faab 	bl	8002860 <gsl_error>
 800230a:	2013      	movs	r0, #19
  cblas_cher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;

}
 800230c:	b00a      	add	sp, #40	; 0x28
 800230e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8002312:	4913      	ldr	r1, [pc, #76]	; (8002360 <gsl_blas_cher2k+0xa0>)
 8002314:	4814      	ldr	r0, [pc, #80]	; (8002368 <gsl_blas_cher2k+0xa8>)
 8002316:	2314      	movs	r3, #20
 8002318:	f240 7277 	movw	r2, #1911	; 0x777
 800231c:	f000 faa0 	bl	8002860 <gsl_error>
 8002320:	2014      	movs	r0, #20
}
 8002322:	b00a      	add	sp, #40	; 0x28
 8002324:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_cher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 8002328:	e9d6 7502 	ldrd	r7, r5, [r6, #8]
 800232c:	f8cd e000 	str.w	lr, [sp]
 8002330:	e9d3 e602 	ldrd	lr, r6, [r3, #8]
 8002334:	9707      	str	r7, [sp, #28]
 8002336:	e9d2 7302 	ldrd	r7, r3, [r2, #8]
 800233a:	9506      	str	r5, [sp, #24]
 800233c:	ad08      	add	r5, sp, #32
 800233e:	9302      	str	r3, [sp, #8]
 8002340:	460a      	mov	r2, r1
 8002342:	e9cd 6e04 	strd	r6, lr, [sp, #16]
 8002346:	4601      	mov	r1, r0
 8002348:	eeb0 0a41 	vmov.f32	s0, s2
 800234c:	4623      	mov	r3, r4
 800234e:	9703      	str	r7, [sp, #12]
 8002350:	9501      	str	r5, [sp, #4]
 8002352:	2065      	movs	r0, #101	; 0x65
 8002354:	f012 fe74 	bl	8015040 <cblas_cher2k>
  return GSL_SUCCESS;
 8002358:	2000      	movs	r0, #0
}
 800235a:	b00a      	add	sp, #40	; 0x28
 800235c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002360:	08030efc 	.word	0x08030efc
 8002364:	08030f04 	.word	0x08030f04
 8002368:	08030f44 	.word	0x08030f44

0800236c <gsl_blas_zher2k>:
int
gsl_blas_zher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex alpha, const gsl_matrix_complex * A,
                 const gsl_matrix_complex * B, double beta,
                 gsl_matrix_complex * C)
{
 800236c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002370:	b08c      	sub	sp, #48	; 0x30
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002372:	296f      	cmp	r1, #111	; 0x6f
{
 8002374:	9d14      	ldr	r5, [sp, #80]	; 0x50
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002376:	e9d3 c700 	ldrd	ip, r7, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800237a:	e9d2 e600 	ldrd	lr, r6, [r2]
{
 800237e:	ed8d 0b08 	vstr	d0, [sp, #32]
 8002382:	ed8d 1b0a 	vstr	d1, [sp, #40]	; 0x28
  const size_t N = C->size2;
 8002386:	e9d5 4800 	ldrd	r4, r8, [r5]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800238a:	d105      	bne.n	8002398 <gsl_blas_zher2k+0x2c>
 800238c:	46b2      	mov	sl, r6
 800238e:	46e1      	mov	r9, ip
 8002390:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002392:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8002394:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 8002396:	464f      	mov	r7, r9

  if (M != N)
 8002398:	4544      	cmp	r4, r8
 800239a:	d110      	bne.n	80023be <gsl_blas_zher2k+0x52>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 800239c:	42b4      	cmp	r4, r6
 800239e:	d103      	bne.n	80023a8 <gsl_blas_zher2k+0x3c>
 80023a0:	42bc      	cmp	r4, r7
 80023a2:	d101      	bne.n	80023a8 <gsl_blas_zher2k+0x3c>
 80023a4:	45f4      	cmp	ip, lr
 80023a6:	d015      	beq.n	80023d4 <gsl_blas_zher2k+0x68>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80023a8:	4919      	ldr	r1, [pc, #100]	; (8002410 <gsl_blas_zher2k+0xa4>)
 80023aa:	481a      	ldr	r0, [pc, #104]	; (8002414 <gsl_blas_zher2k+0xa8>)
 80023ac:	2313      	movs	r3, #19
 80023ae:	f240 7299 	movw	r2, #1945	; 0x799
 80023b2:	f000 fa55 	bl	8002860 <gsl_error>
 80023b6:	2013      	movs	r0, #19
  cblas_zher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;

}
 80023b8:	b00c      	add	sp, #48	; 0x30
 80023ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 80023be:	4914      	ldr	r1, [pc, #80]	; (8002410 <gsl_blas_zher2k+0xa4>)
 80023c0:	4815      	ldr	r0, [pc, #84]	; (8002418 <gsl_blas_zher2k+0xac>)
 80023c2:	2314      	movs	r3, #20
 80023c4:	f240 7295 	movw	r2, #1941	; 0x795
 80023c8:	f000 fa4a 	bl	8002860 <gsl_error>
 80023cc:	2014      	movs	r0, #20
}
 80023ce:	b00c      	add	sp, #48	; 0x30
 80023d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_zher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 80023d4:	e9d5 6502 	ldrd	r6, r5, [r5, #8]
 80023d8:	eeb0 0a42 	vmov.f32	s0, s4
 80023dc:	eef0 0a62 	vmov.f32	s1, s5
 80023e0:	f8cd c000 	str.w	ip, [sp]
 80023e4:	e9d3 ec02 	ldrd	lr, ip, [r3, #8]
 80023e8:	9607      	str	r6, [sp, #28]
 80023ea:	e9d2 7602 	ldrd	r7, r6, [r2, #8]
 80023ee:	9506      	str	r5, [sp, #24]
 80023f0:	ad08      	add	r5, sp, #32
 80023f2:	460a      	mov	r2, r1
 80023f4:	e9cd ce04 	strd	ip, lr, [sp, #16]
 80023f8:	4601      	mov	r1, r0
 80023fa:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80023fe:	4623      	mov	r3, r4
 8002400:	9501      	str	r5, [sp, #4]
 8002402:	2065      	movs	r0, #101	; 0x65
 8002404:	f01c fcc4 	bl	801ed90 <cblas_zher2k>
  return GSL_SUCCESS;
 8002408:	2000      	movs	r0, #0
}
 800240a:	b00c      	add	sp, #48	; 0x30
 800240c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002410:	08030efc 	.word	0x08030efc
 8002414:	08030f04 	.word	0x08030f04
 8002418:	08030f44 	.word	0x08030f44

0800241c <gsl_blas_strmm>:

int
gsl_blas_strmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha,
                const gsl_matrix_float * A, gsl_matrix_float * B)
{
 800241c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800241e:	b089      	sub	sp, #36	; 0x24
 8002420:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002424:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002428:	42af      	cmp	r7, r5
 800242a:	d127      	bne.n	800247c <gsl_blas_strmm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800242c:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 800242e:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002432:	d00d      	beq.n	8002450 <gsl_blas_strmm+0x34>
 8002434:	288e      	cmp	r0, #142	; 0x8e
 8002436:	d101      	bne.n	800243c <gsl_blas_strmm+0x20>
 8002438:	42bd      	cmp	r5, r7
 800243a:	d00b      	beq.n	8002454 <gsl_blas_strmm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800243c:	4914      	ldr	r1, [pc, #80]	; (8002490 <gsl_blas_strmm+0x74>)
 800243e:	4815      	ldr	r0, [pc, #84]	; (8002494 <gsl_blas_strmm+0x78>)
 8002440:	2313      	movs	r3, #19
 8002442:	f240 72bc 	movw	r2, #1980	; 0x7bc
 8002446:	f000 fa0b 	bl	8002860 <gsl_error>
 800244a:	2013      	movs	r0, #19
    }
}
 800244c:	b009      	add	sp, #36	; 0x24
 800244e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002450:	45bc      	cmp	ip, r7
 8002452:	d1f3      	bne.n	800243c <gsl_blas_strmm+0x20>
      cblas_strmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 8002454:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002458:	9502      	str	r5, [sp, #8]
 800245a:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 800245e:	e9cd 3c00 	strd	r3, ip, [sp]
 8002462:	e9cd 6705 	strd	r6, r7, [sp, #20]
 8002466:	4613      	mov	r3, r2
 8002468:	e9cd 4503 	strd	r4, r5, [sp, #12]
 800246c:	460a      	mov	r2, r1
 800246e:	4601      	mov	r1, r0
 8002470:	2065      	movs	r0, #101	; 0x65
 8002472:	f008 fba7 	bl	800abc4 <cblas_strmm>
      return GSL_SUCCESS;
 8002476:	2000      	movs	r0, #0
}
 8002478:	b009      	add	sp, #36	; 0x24
 800247a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800247c:	4904      	ldr	r1, [pc, #16]	; (8002490 <gsl_blas_strmm+0x74>)
 800247e:	4806      	ldr	r0, [pc, #24]	; (8002498 <gsl_blas_strmm+0x7c>)
 8002480:	2314      	movs	r3, #20
 8002482:	f240 72b1 	movw	r2, #1969	; 0x7b1
 8002486:	f000 f9eb 	bl	8002860 <gsl_error>
 800248a:	2014      	movs	r0, #20
}
 800248c:	b009      	add	sp, #36	; 0x24
 800248e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002490:	08030efc 	.word	0x08030efc
 8002494:	08030f04 	.word	0x08030f04
 8002498:	08030f2c 	.word	0x08030f2c

0800249c <gsl_blas_dtrmm>:

int
gsl_blas_dtrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha,
                const gsl_matrix * A, gsl_matrix * B)
{
 800249c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800249e:	b089      	sub	sp, #36	; 0x24
 80024a0:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80024a4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80024a8:	42af      	cmp	r7, r5
 80024aa:	d127      	bne.n	80024fc <gsl_blas_dtrmm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80024ac:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80024ae:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80024b2:	d00d      	beq.n	80024d0 <gsl_blas_dtrmm+0x34>
 80024b4:	288e      	cmp	r0, #142	; 0x8e
 80024b6:	d101      	bne.n	80024bc <gsl_blas_dtrmm+0x20>
 80024b8:	42bd      	cmp	r5, r7
 80024ba:	d00b      	beq.n	80024d4 <gsl_blas_dtrmm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80024bc:	4914      	ldr	r1, [pc, #80]	; (8002510 <gsl_blas_dtrmm+0x74>)
 80024be:	4815      	ldr	r0, [pc, #84]	; (8002514 <gsl_blas_dtrmm+0x78>)
 80024c0:	2313      	movs	r3, #19
 80024c2:	f44f 62fb 	mov.w	r2, #2008	; 0x7d8
 80024c6:	f000 f9cb 	bl	8002860 <gsl_error>
 80024ca:	2013      	movs	r0, #19
    }
}
 80024cc:	b009      	add	sp, #36	; 0x24
 80024ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80024d0:	45bc      	cmp	ip, r7
 80024d2:	d1f3      	bne.n	80024bc <gsl_blas_dtrmm+0x20>
      cblas_dtrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 80024d4:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 80024d8:	9502      	str	r5, [sp, #8]
 80024da:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 80024de:	e9cd 3c00 	strd	r3, ip, [sp]
 80024e2:	e9cd 6705 	strd	r6, r7, [sp, #20]
 80024e6:	4613      	mov	r3, r2
 80024e8:	e9cd 4503 	strd	r4, r5, [sp, #12]
 80024ec:	460a      	mov	r2, r1
 80024ee:	4601      	mov	r1, r0
 80024f0:	2065      	movs	r0, #101	; 0x65
 80024f2:	f00d ff05 	bl	8010300 <cblas_dtrmm>
      return GSL_SUCCESS;
 80024f6:	2000      	movs	r0, #0
}
 80024f8:	b009      	add	sp, #36	; 0x24
 80024fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 80024fc:	4904      	ldr	r1, [pc, #16]	; (8002510 <gsl_blas_dtrmm+0x74>)
 80024fe:	4806      	ldr	r0, [pc, #24]	; (8002518 <gsl_blas_dtrmm+0x7c>)
 8002500:	2314      	movs	r3, #20
 8002502:	f240 72cd 	movw	r2, #1997	; 0x7cd
 8002506:	f000 f9ab 	bl	8002860 <gsl_error>
 800250a:	2014      	movs	r0, #20
}
 800250c:	b009      	add	sp, #36	; 0x24
 800250e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002510:	08030efc 	.word	0x08030efc
 8002514:	08030f04 	.word	0x08030f04
 8002518:	08030f2c 	.word	0x08030f2c

0800251c <gsl_blas_ctrmm>:
gsl_blas_ctrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                gsl_matrix_complex_float * B)
{
 800251c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800251e:	b08b      	sub	sp, #44	; 0x2c
 8002520:	e9dd 4610 	ldrd	r4, r6, [sp, #64]	; 0x40
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002524:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002528:	42af      	cmp	r7, r5
{
 800252a:	ed8d 0a08 	vstr	s0, [sp, #32]
 800252e:	edcd 0a09 	vstr	s1, [sp, #36]	; 0x24
  if (MA != NA)
 8002532:	d12a      	bne.n	800258a <gsl_blas_ctrmm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002534:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 8002536:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800253a:	d00d      	beq.n	8002558 <gsl_blas_ctrmm+0x3c>
 800253c:	288e      	cmp	r0, #142	; 0x8e
 800253e:	d101      	bne.n	8002544 <gsl_blas_ctrmm+0x28>
 8002540:	42bd      	cmp	r5, r7
 8002542:	d00b      	beq.n	800255c <gsl_blas_ctrmm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8002544:	4916      	ldr	r1, [pc, #88]	; (80025a0 <gsl_blas_ctrmm+0x84>)
 8002546:	4817      	ldr	r0, [pc, #92]	; (80025a4 <gsl_blas_ctrmm+0x88>)
 8002548:	2313      	movs	r3, #19
 800254a:	f240 72f7 	movw	r2, #2039	; 0x7f7
 800254e:	f000 f987 	bl	8002860 <gsl_error>
 8002552:	2013      	movs	r0, #19
    }
}
 8002554:	b00b      	add	sp, #44	; 0x2c
 8002556:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002558:	45bc      	cmp	ip, r7
 800255a:	d1f3      	bne.n	8002544 <gsl_blas_ctrmm+0x28>
      cblas_ctrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 800255c:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002560:	9502      	str	r5, [sp, #8]
 8002562:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 8002566:	ad08      	add	r5, sp, #32
 8002568:	9300      	str	r3, [sp, #0]
 800256a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800256e:	4613      	mov	r3, r2
 8002570:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002574:	460a      	mov	r2, r1
 8002576:	f8cd c004 	str.w	ip, [sp, #4]
 800257a:	4601      	mov	r1, r0
 800257c:	9503      	str	r5, [sp, #12]
 800257e:	2065      	movs	r0, #101	; 0x65
 8002580:	f015 f8fa 	bl	8017778 <cblas_ctrmm>
      return GSL_SUCCESS;
 8002584:	2000      	movs	r0, #0
}
 8002586:	b00b      	add	sp, #44	; 0x2c
 8002588:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800258a:	4905      	ldr	r1, [pc, #20]	; (80025a0 <gsl_blas_ctrmm+0x84>)
 800258c:	4806      	ldr	r0, [pc, #24]	; (80025a8 <gsl_blas_ctrmm+0x8c>)
 800258e:	2314      	movs	r3, #20
 8002590:	f240 72eb 	movw	r2, #2027	; 0x7eb
 8002594:	f000 f964 	bl	8002860 <gsl_error>
 8002598:	2014      	movs	r0, #20
}
 800259a:	b00b      	add	sp, #44	; 0x2c
 800259c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800259e:	bf00      	nop
 80025a0:	08030efc 	.word	0x08030efc
 80025a4:	08030f04 	.word	0x08030f04
 80025a8:	08030f2c 	.word	0x08030f2c

080025ac <gsl_blas_ztrmm>:
int
gsl_blas_ztrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                gsl_matrix_complex * B)
{
 80025ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025ae:	b08d      	sub	sp, #52	; 0x34
 80025b0:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80025b4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80025b8:	42af      	cmp	r7, r5
{
 80025ba:	ed8d 0b08 	vstr	d0, [sp, #32]
 80025be:	ed8d 1b0a 	vstr	d1, [sp, #40]	; 0x28
  if (MA != NA)
 80025c2:	d12a      	bne.n	800261a <gsl_blas_ztrmm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80025c4:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80025c6:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80025ca:	d00d      	beq.n	80025e8 <gsl_blas_ztrmm+0x3c>
 80025cc:	288e      	cmp	r0, #142	; 0x8e
 80025ce:	d101      	bne.n	80025d4 <gsl_blas_ztrmm+0x28>
 80025d0:	42bd      	cmp	r5, r7
 80025d2:	d00b      	beq.n	80025ec <gsl_blas_ztrmm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80025d4:	4916      	ldr	r1, [pc, #88]	; (8002630 <gsl_blas_ztrmm+0x84>)
 80025d6:	4817      	ldr	r0, [pc, #92]	; (8002634 <gsl_blas_ztrmm+0x88>)
 80025d8:	2313      	movs	r3, #19
 80025da:	f640 0215 	movw	r2, #2069	; 0x815
 80025de:	f000 f93f 	bl	8002860 <gsl_error>
 80025e2:	2013      	movs	r0, #19
    }
}
 80025e4:	b00d      	add	sp, #52	; 0x34
 80025e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80025e8:	45bc      	cmp	ip, r7
 80025ea:	d1f3      	bne.n	80025d4 <gsl_blas_ztrmm+0x28>
      cblas_ztrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 80025ec:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 80025f0:	9502      	str	r5, [sp, #8]
 80025f2:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 80025f6:	ad08      	add	r5, sp, #32
 80025f8:	9300      	str	r3, [sp, #0]
 80025fa:	e9cd 6706 	strd	r6, r7, [sp, #24]
 80025fe:	4613      	mov	r3, r2
 8002600:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002604:	460a      	mov	r2, r1
 8002606:	f8cd c004 	str.w	ip, [sp, #4]
 800260a:	4601      	mov	r1, r0
 800260c:	9503      	str	r5, [sp, #12]
 800260e:	2065      	movs	r0, #101	; 0x65
 8002610:	f021 f912 	bl	8023838 <cblas_ztrmm>
      return GSL_SUCCESS;
 8002614:	2000      	movs	r0, #0
}
 8002616:	b00d      	add	sp, #52	; 0x34
 8002618:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800261a:	4905      	ldr	r1, [pc, #20]	; (8002630 <gsl_blas_ztrmm+0x84>)
 800261c:	4806      	ldr	r0, [pc, #24]	; (8002638 <gsl_blas_ztrmm+0x8c>)
 800261e:	2314      	movs	r3, #20
 8002620:	f640 0209 	movw	r2, #2057	; 0x809
 8002624:	f000 f91c 	bl	8002860 <gsl_error>
 8002628:	2014      	movs	r0, #20
}
 800262a:	b00d      	add	sp, #52	; 0x34
 800262c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800262e:	bf00      	nop
 8002630:	08030efc 	.word	0x08030efc
 8002634:	08030f04 	.word	0x08030f04
 8002638:	08030f2c 	.word	0x08030f2c

0800263c <gsl_blas_strsm>:

int
gsl_blas_strsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha,
                const gsl_matrix_float * A, gsl_matrix_float * B)
{
 800263c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800263e:	b089      	sub	sp, #36	; 0x24
 8002640:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002644:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002648:	42af      	cmp	r7, r5
 800264a:	d127      	bne.n	800269c <gsl_blas_strsm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800264c:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 800264e:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002652:	d00d      	beq.n	8002670 <gsl_blas_strsm+0x34>
 8002654:	288e      	cmp	r0, #142	; 0x8e
 8002656:	d101      	bne.n	800265c <gsl_blas_strsm+0x20>
 8002658:	42bd      	cmp	r5, r7
 800265a:	d00b      	beq.n	8002674 <gsl_blas_strsm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800265c:	4914      	ldr	r1, [pc, #80]	; (80026b0 <gsl_blas_strsm+0x74>)
 800265e:	4815      	ldr	r0, [pc, #84]	; (80026b4 <gsl_blas_strsm+0x78>)
 8002660:	2313      	movs	r3, #19
 8002662:	f640 0233 	movw	r2, #2099	; 0x833
 8002666:	f000 f8fb 	bl	8002860 <gsl_error>
 800266a:	2013      	movs	r0, #19
    }
}
 800266c:	b009      	add	sp, #36	; 0x24
 800266e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002670:	45bc      	cmp	ip, r7
 8002672:	d1f3      	bne.n	800265c <gsl_blas_strsm+0x20>
      cblas_strsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 8002674:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002678:	9502      	str	r5, [sp, #8]
 800267a:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 800267e:	e9cd 3c00 	strd	r3, ip, [sp]
 8002682:	e9cd 6705 	strd	r6, r7, [sp, #20]
 8002686:	4613      	mov	r3, r2
 8002688:	e9cd 4503 	strd	r4, r5, [sp, #12]
 800268c:	460a      	mov	r2, r1
 800268e:	4601      	mov	r1, r0
 8002690:	2065      	movs	r0, #101	; 0x65
 8002692:	f009 f831 	bl	800b6f8 <cblas_strsm>
      return GSL_SUCCESS;
 8002696:	2000      	movs	r0, #0
}
 8002698:	b009      	add	sp, #36	; 0x24
 800269a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800269c:	4904      	ldr	r1, [pc, #16]	; (80026b0 <gsl_blas_strsm+0x74>)
 800269e:	4806      	ldr	r0, [pc, #24]	; (80026b8 <gsl_blas_strsm+0x7c>)
 80026a0:	2314      	movs	r3, #20
 80026a2:	f640 0228 	movw	r2, #2088	; 0x828
 80026a6:	f000 f8db 	bl	8002860 <gsl_error>
 80026aa:	2014      	movs	r0, #20
}
 80026ac:	b009      	add	sp, #36	; 0x24
 80026ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80026b0:	08030efc 	.word	0x08030efc
 80026b4:	08030f04 	.word	0x08030f04
 80026b8:	08030f2c 	.word	0x08030f2c

080026bc <gsl_blas_dtrsm>:

int
gsl_blas_dtrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha,
                const gsl_matrix * A, gsl_matrix * B)
{
 80026bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80026be:	b089      	sub	sp, #36	; 0x24
 80026c0:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80026c4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80026c8:	42af      	cmp	r7, r5
 80026ca:	d127      	bne.n	800271c <gsl_blas_dtrsm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80026cc:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80026ce:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80026d2:	d00d      	beq.n	80026f0 <gsl_blas_dtrsm+0x34>
 80026d4:	288e      	cmp	r0, #142	; 0x8e
 80026d6:	d101      	bne.n	80026dc <gsl_blas_dtrsm+0x20>
 80026d8:	42bd      	cmp	r5, r7
 80026da:	d00b      	beq.n	80026f4 <gsl_blas_dtrsm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80026dc:	4914      	ldr	r1, [pc, #80]	; (8002730 <gsl_blas_dtrsm+0x74>)
 80026de:	4815      	ldr	r0, [pc, #84]	; (8002734 <gsl_blas_dtrsm+0x78>)
 80026e0:	2313      	movs	r3, #19
 80026e2:	f640 024f 	movw	r2, #2127	; 0x84f
 80026e6:	f000 f8bb 	bl	8002860 <gsl_error>
 80026ea:	2013      	movs	r0, #19
    }
}
 80026ec:	b009      	add	sp, #36	; 0x24
 80026ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80026f0:	45bc      	cmp	ip, r7
 80026f2:	d1f3      	bne.n	80026dc <gsl_blas_dtrsm+0x20>
      cblas_dtrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 80026f4:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 80026f8:	9502      	str	r5, [sp, #8]
 80026fa:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 80026fe:	e9cd 3c00 	strd	r3, ip, [sp]
 8002702:	e9cd 6705 	strd	r6, r7, [sp, #20]
 8002706:	4613      	mov	r3, r2
 8002708:	e9cd 4503 	strd	r4, r5, [sp, #12]
 800270c:	460a      	mov	r2, r1
 800270e:	4601      	mov	r1, r0
 8002710:	2065      	movs	r0, #101	; 0x65
 8002712:	f00e fd59 	bl	80111c8 <cblas_dtrsm>
      return GSL_SUCCESS;
 8002716:	2000      	movs	r0, #0
}
 8002718:	b009      	add	sp, #36	; 0x24
 800271a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800271c:	4904      	ldr	r1, [pc, #16]	; (8002730 <gsl_blas_dtrsm+0x74>)
 800271e:	4806      	ldr	r0, [pc, #24]	; (8002738 <gsl_blas_dtrsm+0x7c>)
 8002720:	2314      	movs	r3, #20
 8002722:	f640 0244 	movw	r2, #2116	; 0x844
 8002726:	f000 f89b 	bl	8002860 <gsl_error>
 800272a:	2014      	movs	r0, #20
}
 800272c:	b009      	add	sp, #36	; 0x24
 800272e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002730:	08030efc 	.word	0x08030efc
 8002734:	08030f04 	.word	0x08030f04
 8002738:	08030f2c 	.word	0x08030f2c

0800273c <gsl_blas_ctrsm>:
gsl_blas_ctrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                gsl_matrix_complex_float * B)
{
 800273c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800273e:	b08b      	sub	sp, #44	; 0x2c
 8002740:	e9dd 4610 	ldrd	r4, r6, [sp, #64]	; 0x40
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002744:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002748:	42af      	cmp	r7, r5
{
 800274a:	ed8d 0a08 	vstr	s0, [sp, #32]
 800274e:	edcd 0a09 	vstr	s1, [sp, #36]	; 0x24
  if (MA != NA)
 8002752:	d12a      	bne.n	80027aa <gsl_blas_ctrsm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002754:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 8002756:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800275a:	d00d      	beq.n	8002778 <gsl_blas_ctrsm+0x3c>
 800275c:	288e      	cmp	r0, #142	; 0x8e
 800275e:	d101      	bne.n	8002764 <gsl_blas_ctrsm+0x28>
 8002760:	42bd      	cmp	r5, r7
 8002762:	d00b      	beq.n	800277c <gsl_blas_ctrsm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8002764:	4916      	ldr	r1, [pc, #88]	; (80027c0 <gsl_blas_ctrsm+0x84>)
 8002766:	4817      	ldr	r0, [pc, #92]	; (80027c4 <gsl_blas_ctrsm+0x88>)
 8002768:	2313      	movs	r3, #19
 800276a:	f640 026e 	movw	r2, #2158	; 0x86e
 800276e:	f000 f877 	bl	8002860 <gsl_error>
 8002772:	2013      	movs	r0, #19
    }
}
 8002774:	b00b      	add	sp, #44	; 0x2c
 8002776:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002778:	45bc      	cmp	ip, r7
 800277a:	d1f3      	bne.n	8002764 <gsl_blas_ctrsm+0x28>
      cblas_ctrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 800277c:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002780:	9502      	str	r5, [sp, #8]
 8002782:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 8002786:	ad08      	add	r5, sp, #32
 8002788:	9300      	str	r3, [sp, #0]
 800278a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800278e:	4613      	mov	r3, r2
 8002790:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002794:	460a      	mov	r2, r1
 8002796:	f8cd c004 	str.w	ip, [sp, #4]
 800279a:	4601      	mov	r1, r0
 800279c:	9503      	str	r5, [sp, #12]
 800279e:	2065      	movs	r0, #101	; 0x65
 80027a0:	f016 f852 	bl	8018848 <cblas_ctrsm>
      return GSL_SUCCESS;
 80027a4:	2000      	movs	r0, #0
}
 80027a6:	b00b      	add	sp, #44	; 0x2c
 80027a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 80027aa:	4905      	ldr	r1, [pc, #20]	; (80027c0 <gsl_blas_ctrsm+0x84>)
 80027ac:	4806      	ldr	r0, [pc, #24]	; (80027c8 <gsl_blas_ctrsm+0x8c>)
 80027ae:	2314      	movs	r3, #20
 80027b0:	f640 0262 	movw	r2, #2146	; 0x862
 80027b4:	f000 f854 	bl	8002860 <gsl_error>
 80027b8:	2014      	movs	r0, #20
}
 80027ba:	b00b      	add	sp, #44	; 0x2c
 80027bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80027be:	bf00      	nop
 80027c0:	08030efc 	.word	0x08030efc
 80027c4:	08030f04 	.word	0x08030f04
 80027c8:	08030f2c 	.word	0x08030f2c

080027cc <gsl_blas_ztrsm>:
int
gsl_blas_ztrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                gsl_matrix_complex * B)
{
 80027cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80027ce:	b08d      	sub	sp, #52	; 0x34
 80027d0:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80027d4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80027d8:	42af      	cmp	r7, r5
{
 80027da:	ed8d 0b08 	vstr	d0, [sp, #32]
 80027de:	ed8d 1b0a 	vstr	d1, [sp, #40]	; 0x28
  if (MA != NA)
 80027e2:	d12a      	bne.n	800283a <gsl_blas_ztrsm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80027e4:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80027e6:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80027ea:	d00d      	beq.n	8002808 <gsl_blas_ztrsm+0x3c>
 80027ec:	288e      	cmp	r0, #142	; 0x8e
 80027ee:	d101      	bne.n	80027f4 <gsl_blas_ztrsm+0x28>
 80027f0:	42bd      	cmp	r5, r7
 80027f2:	d00b      	beq.n	800280c <gsl_blas_ztrsm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80027f4:	4916      	ldr	r1, [pc, #88]	; (8002850 <gsl_blas_ztrsm+0x84>)
 80027f6:	4817      	ldr	r0, [pc, #92]	; (8002854 <gsl_blas_ztrsm+0x88>)
 80027f8:	2313      	movs	r3, #19
 80027fa:	f640 028c 	movw	r2, #2188	; 0x88c
 80027fe:	f000 f82f 	bl	8002860 <gsl_error>
 8002802:	2013      	movs	r0, #19
    }
}
 8002804:	b00d      	add	sp, #52	; 0x34
 8002806:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002808:	45bc      	cmp	ip, r7
 800280a:	d1f3      	bne.n	80027f4 <gsl_blas_ztrsm+0x28>
      cblas_ztrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 800280c:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002810:	9502      	str	r5, [sp, #8]
 8002812:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 8002816:	ad08      	add	r5, sp, #32
 8002818:	9300      	str	r3, [sp, #0]
 800281a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800281e:	4613      	mov	r3, r2
 8002820:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002824:	460a      	mov	r2, r1
 8002826:	f8cd c004 	str.w	ip, [sp, #4]
 800282a:	4601      	mov	r1, r0
 800282c:	9503      	str	r5, [sp, #12]
 800282e:	2065      	movs	r0, #101	; 0x65
 8002830:	f023 f966 	bl	8025b00 <cblas_ztrsm>
      return GSL_SUCCESS;
 8002834:	2000      	movs	r0, #0
}
 8002836:	b00d      	add	sp, #52	; 0x34
 8002838:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800283a:	4905      	ldr	r1, [pc, #20]	; (8002850 <gsl_blas_ztrsm+0x84>)
 800283c:	4806      	ldr	r0, [pc, #24]	; (8002858 <gsl_blas_ztrsm+0x8c>)
 800283e:	2314      	movs	r3, #20
 8002840:	f44f 6208 	mov.w	r2, #2176	; 0x880
 8002844:	f000 f80c 	bl	8002860 <gsl_error>
 8002848:	2014      	movs	r0, #20
}
 800284a:	b00d      	add	sp, #52	; 0x34
 800284c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800284e:	bf00      	nop
 8002850:	08030efc 	.word	0x08030efc
 8002854:	08030f04 	.word	0x08030f04
 8002858:	08030f2c 	.word	0x08030f2c

0800285c <no_error_handler>:
  reason = 0;
  file = 0;
  line = 0;
  gsl_errno = 0;
  return;
}
 800285c:	4770      	bx	lr
 800285e:	bf00      	nop

08002860 <gsl_error>:
{
 8002860:	b570      	push	{r4, r5, r6, lr}
  if (gsl_error_handler) 
 8002862:	4c0f      	ldr	r4, [pc, #60]	; (80028a0 <gsl_error+0x40>)
 8002864:	6825      	ldr	r5, [r4, #0]
 8002866:	b11d      	cbz	r5, 8002870 <gsl_error+0x10>
      (*gsl_error_handler) (reason, file, line, gsl_errno);
 8002868:	46ac      	mov	ip, r5
}
 800286a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      (*gsl_error_handler) (reason, file, line, gsl_errno);
 800286e:	4760      	bx	ip
  fflush (stdout);
 8002870:	4d0c      	ldr	r5, [pc, #48]	; (80028a4 <gsl_error+0x44>)
 8002872:	4604      	mov	r4, r0
  gsl_stream_printf ("ERROR", file, line, reason);
 8002874:	4623      	mov	r3, r4
 8002876:	480c      	ldr	r0, [pc, #48]	; (80028a8 <gsl_error+0x48>)
 8002878:	f000 f82c 	bl	80028d4 <gsl_stream_printf>
  fflush (stdout);
 800287c:	682b      	ldr	r3, [r5, #0]
 800287e:	6898      	ldr	r0, [r3, #8]
 8002880:	f02d faa2 	bl	802fdc8 <fflush>
  fprintf (stderr, "Default GSL error handler invoked.\n");
 8002884:	682b      	ldr	r3, [r5, #0]
 8002886:	4809      	ldr	r0, [pc, #36]	; (80028ac <gsl_error+0x4c>)
 8002888:	68db      	ldr	r3, [r3, #12]
 800288a:	2223      	movs	r2, #35	; 0x23
 800288c:	2101      	movs	r1, #1
 800288e:	f02d fbd7 	bl	8030040 <fwrite>
  fflush (stderr);
 8002892:	682b      	ldr	r3, [r5, #0]
 8002894:	68d8      	ldr	r0, [r3, #12]
 8002896:	f02d fa97 	bl	802fdc8 <fflush>
  abort ();
 800289a:	f02d f9d7 	bl	802fc4c <abort>
 800289e:	bf00      	nop
 80028a0:	20000650 	.word	0x20000650
 80028a4:	200005cc 	.word	0x200005cc
 80028a8:	08030f5c 	.word	0x08030f5c
 80028ac:	08030f64 	.word	0x08030f64

080028b0 <gsl_set_error_handler>:
  gsl_error_handler_t * previous_handler = gsl_error_handler;
 80028b0:	4b02      	ldr	r3, [pc, #8]	; (80028bc <gsl_set_error_handler+0xc>)
 80028b2:	681a      	ldr	r2, [r3, #0]
  gsl_error_handler = new_handler;
 80028b4:	6018      	str	r0, [r3, #0]
}
 80028b6:	4610      	mov	r0, r2
 80028b8:	4770      	bx	lr
 80028ba:	bf00      	nop
 80028bc:	20000650 	.word	0x20000650

080028c0 <gsl_set_error_handler_off>:
  gsl_error_handler_t * previous_handler = gsl_error_handler;
 80028c0:	4b02      	ldr	r3, [pc, #8]	; (80028cc <gsl_set_error_handler_off+0xc>)
  gsl_error_handler = no_error_handler;
 80028c2:	4a03      	ldr	r2, [pc, #12]	; (80028d0 <gsl_set_error_handler_off+0x10>)
  gsl_error_handler_t * previous_handler = gsl_error_handler;
 80028c4:	6818      	ldr	r0, [r3, #0]
  gsl_error_handler = no_error_handler;
 80028c6:	601a      	str	r2, [r3, #0]
}
 80028c8:	4770      	bx	lr
 80028ca:	bf00      	nop
 80028cc:	20000650 	.word	0x20000650
 80028d0:	0800285d 	.word	0x0800285d

080028d4 <gsl_stream_printf>:
gsl_stream_handler_t * gsl_stream_handler = NULL;

void
gsl_stream_printf (const char *label, const char *file, int line, 
                   const char *reason)
{
 80028d4:	b530      	push	{r4, r5, lr}
  if (gsl_stream == NULL)
 80028d6:	4d0e      	ldr	r5, [pc, #56]	; (8002910 <gsl_stream_printf+0x3c>)
 80028d8:	682c      	ldr	r4, [r5, #0]
{
 80028da:	b083      	sub	sp, #12
  if (gsl_stream == NULL)
 80028dc:	b134      	cbz	r4, 80028ec <gsl_stream_printf+0x18>
    {
      gsl_stream = stderr;
    }
  if (gsl_stream_handler)
 80028de:	686c      	ldr	r4, [r5, #4]
 80028e0:	b15c      	cbz	r4, 80028fa <gsl_stream_printf+0x26>
    {
      (*gsl_stream_handler) (label, file, line, reason);
 80028e2:	46a4      	mov	ip, r4
      return;
    }
  fprintf (gsl_stream, "gsl: %s:%d: %s: %s\n", file, line, label, reason);

}
 80028e4:	b003      	add	sp, #12
 80028e6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      (*gsl_stream_handler) (label, file, line, reason);
 80028ea:	4760      	bx	ip
      gsl_stream = stderr;
 80028ec:	4c09      	ldr	r4, [pc, #36]	; (8002914 <gsl_stream_printf+0x40>)
 80028ee:	6824      	ldr	r4, [r4, #0]
 80028f0:	68e4      	ldr	r4, [r4, #12]
 80028f2:	602c      	str	r4, [r5, #0]
  if (gsl_stream_handler)
 80028f4:	686c      	ldr	r4, [r5, #4]
 80028f6:	2c00      	cmp	r4, #0
 80028f8:	d1f3      	bne.n	80028e2 <gsl_stream_printf+0xe>
  fprintf (gsl_stream, "gsl: %s:%d: %s: %s\n", file, line, label, reason);
 80028fa:	e9cd 0300 	strd	r0, r3, [sp]
 80028fe:	4613      	mov	r3, r2
 8002900:	6828      	ldr	r0, [r5, #0]
 8002902:	460a      	mov	r2, r1
 8002904:	4904      	ldr	r1, [pc, #16]	; (8002918 <gsl_stream_printf+0x44>)
 8002906:	f02d fb1d 	bl	802ff44 <fiprintf>
}
 800290a:	b003      	add	sp, #12
 800290c:	bd30      	pop	{r4, r5, pc}
 800290e:	bf00      	nop
 8002910:	20000654 	.word	0x20000654
 8002914:	200005cc 	.word	0x200005cc
 8002918:	08030f88 	.word	0x08030f88

0800291c <gsl_set_stream_handler>:

gsl_stream_handler_t *
gsl_set_stream_handler (gsl_stream_handler_t * new_handler)
{
  gsl_stream_handler_t * previous_handler = gsl_stream_handler;
 800291c:	4b02      	ldr	r3, [pc, #8]	; (8002928 <gsl_set_stream_handler+0xc>)
 800291e:	685a      	ldr	r2, [r3, #4]
  gsl_stream_handler = new_handler;
 8002920:	6058      	str	r0, [r3, #4]
  return previous_handler;
}
 8002922:	4610      	mov	r0, r2
 8002924:	4770      	bx	lr
 8002926:	bf00      	nop
 8002928:	20000654 	.word	0x20000654

0800292c <gsl_set_stream>:

FILE *
gsl_set_stream (FILE * new_stream)
{
  FILE * previous_stream;
  if (gsl_stream == NULL) {
 800292c:	4a05      	ldr	r2, [pc, #20]	; (8002944 <gsl_set_stream+0x18>)
 800292e:	6813      	ldr	r3, [r2, #0]
 8002930:	b113      	cbz	r3, 8002938 <gsl_set_stream+0xc>
    gsl_stream = stderr;
  }
  previous_stream = gsl_stream;
  gsl_stream = new_stream;
 8002932:	6010      	str	r0, [r2, #0]
  return previous_stream;
}
 8002934:	4618      	mov	r0, r3
 8002936:	4770      	bx	lr
    gsl_stream = stderr;
 8002938:	4b03      	ldr	r3, [pc, #12]	; (8002948 <gsl_set_stream+0x1c>)
  gsl_stream = new_stream;
 800293a:	6010      	str	r0, [r2, #0]
    gsl_stream = stderr;
 800293c:	681b      	ldr	r3, [r3, #0]
 800293e:	68db      	ldr	r3, [r3, #12]
}
 8002940:	4618      	mov	r0, r3
 8002942:	4770      	bx	lr
 8002944:	20000654 	.word	0x20000654
 8002948:	200005cc 	.word	0x200005cc

0800294c <gsl_matrix_complex_long_double_alloc>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

TYPE (gsl_matrix) *
FUNCTION (gsl_matrix, alloc) (const size_t n1, const size_t n2)
{
 800294c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800294e:	4607      	mov	r7, r0
  TYPE (gsl_block) * block;
  TYPE (gsl_matrix) * m;

  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002950:	2018      	movs	r0, #24
{
 8002952:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002954:	f02d fba6 	bl	80300a4 <malloc>

  if (m == 0)
 8002958:	4604      	mov	r4, r0
 800295a:	b1b8      	cbz	r0, 800298c <gsl_matrix_complex_long_double_alloc+0x40>
                        GSL_ENOMEM, 0);
    }

  /* FIXME: n1*n2 could overflow for large dimensions */

  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800295c:	fb06 f007 	mul.w	r0, r6, r7
 8002960:	f004 fe80 	bl	8007664 <gsl_block_complex_long_double_alloc>

  if (block == 0)
 8002964:	4605      	mov	r5, r0
 8002966:	b148      	cbz	r0, 800297c <gsl_matrix_complex_long_double_alloc+0x30>
    {
      GSL_ERROR_VAL ("failed to allocate space for block",
                        GSL_ENOMEM, 0);
    }

  m->data = block->data;
 8002968:	6843      	ldr	r3, [r0, #4]
 800296a:	60e3      	str	r3, [r4, #12]
  m->size1 = n1;
  m->size2 = n2;
  m->tda = n2; 
  m->block = block;
  m->owner = 1;
 800296c:	2301      	movs	r3, #1
  m->size2 = n2;
 800296e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8002972:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8002976:	60a6      	str	r6, [r4, #8]

  return m;
}
 8002978:	4620      	mov	r0, r4
 800297a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 800297c:	4907      	ldr	r1, [pc, #28]	; (800299c <gsl_matrix_complex_long_double_alloc+0x50>)
 800297e:	4808      	ldr	r0, [pc, #32]	; (80029a0 <gsl_matrix_complex_long_double_alloc+0x54>)
 8002980:	2308      	movs	r3, #8
 8002982:	2228      	movs	r2, #40	; 0x28
 8002984:	462c      	mov	r4, r5
 8002986:	f7ff ff6b 	bl	8002860 <gsl_error>
 800298a:	e7f5      	b.n	8002978 <gsl_matrix_complex_long_double_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800298c:	4903      	ldr	r1, [pc, #12]	; (800299c <gsl_matrix_complex_long_double_alloc+0x50>)
 800298e:	4805      	ldr	r0, [pc, #20]	; (80029a4 <gsl_matrix_complex_long_double_alloc+0x58>)
 8002990:	2308      	movs	r3, #8
 8002992:	221e      	movs	r2, #30
 8002994:	f7ff ff64 	bl	8002860 <gsl_error>
 8002998:	e7ee      	b.n	8002978 <gsl_matrix_complex_long_double_alloc+0x2c>
 800299a:	bf00      	nop
 800299c:	08030f9c 	.word	0x08030f9c
 80029a0:	08030fd8 	.word	0x08030fd8
 80029a4:	08030fac 	.word	0x08030fac

080029a8 <gsl_matrix_complex_long_double_calloc>:

TYPE (gsl_matrix) *
FUNCTION (gsl_matrix, calloc) (const size_t n1, const size_t n2)
{
 80029a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80029aa:	4604      	mov	r4, r0
 80029ac:	460e      	mov	r6, r1
  size_t i;

  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80029ae:	f7ff ffcd 	bl	800294c <gsl_matrix_complex_long_double_alloc>

  if (m == 0)
 80029b2:	4605      	mov	r5, r0
 80029b4:	b188      	cbz	r0, 80029da <gsl_matrix_complex_long_double_calloc+0x32>
    return 0;

  /* initialize matrix to zero */
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80029b6:	fb06 f604 	mul.w	r6, r6, r4
 80029ba:	0134      	lsls	r4, r6, #4
 80029bc:	68c0      	ldr	r0, [r0, #12]
 80029be:	4622      	mov	r2, r4
 80029c0:	2100      	movs	r1, #0
 80029c2:	f02d fb7f 	bl	80300c4 <memset>

  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80029c6:	0073      	lsls	r3, r6, #1
 80029c8:	d007      	beq.n	80029da <gsl_matrix_complex_long_double_calloc+0x32>
 80029ca:	68eb      	ldr	r3, [r5, #12]
    {
      m->data[i] = 0;
 80029cc:	2600      	movs	r6, #0
 80029ce:	2700      	movs	r7, #0
 80029d0:	18e2      	adds	r2, r4, r3
 80029d2:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80029d6:	4293      	cmp	r3, r2
 80029d8:	d1fb      	bne.n	80029d2 <gsl_matrix_complex_long_double_calloc+0x2a>
    }

  return m;
}
 80029da:	4628      	mov	r0, r5
 80029dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80029de:	bf00      	nop

080029e0 <gsl_matrix_complex_long_double_alloc_from_block>:
FUNCTION (gsl_matrix, alloc_from_block) (TYPE(gsl_block) * block, 
                                         const size_t offset,
                                         const size_t n1, 
                                         const size_t n2,
                                         const size_t d2)
{
 80029e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80029e4:	f8dd 9020 	ldr.w	r9, [sp, #32]
  TYPE (gsl_matrix) * m;

  if (d2 < n2)
 80029e8:	4599      	cmp	r9, r3
 80029ea:	d325      	bcc.n	8002a38 <gsl_matrix_complex_long_double_alloc_from_block+0x58>
    {
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
                        GSL_EINVAL, 0);
    }
  else if (block->size < offset + n1 * d2)
 80029ec:	4690      	mov	r8, r2
 80029ee:	6802      	ldr	r2, [r0, #0]
 80029f0:	461e      	mov	r6, r3
 80029f2:	fb08 1309 	mla	r3, r8, r9, r1
 80029f6:	429a      	cmp	r2, r3
 80029f8:	4605      	mov	r5, r0
 80029fa:	460f      	mov	r7, r1
 80029fc:	d312      	bcc.n	8002a24 <gsl_matrix_complex_long_double_alloc_from_block+0x44>
    {
      GSL_ERROR_VAL ("matrix size exceeds available block size",
                        GSL_EINVAL, 0);
    }

  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80029fe:	2018      	movs	r0, #24
 8002a00:	f02d fb50 	bl	80300a4 <malloc>

  if (m == 0)
 8002a04:	4604      	mov	r4, r0
 8002a06:	b1f8      	cbz	r0, 8002a48 <gsl_matrix_complex_long_double_alloc_from_block+0x68>
    {
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
                        GSL_ENOMEM, 0);
    }

  m->data = block->data + MULTIPLICITY * offset;
 8002a08:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8002a0a:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8002a0e:	eb01 1107 	add.w	r1, r1, r7, lsl #4
  m->size2 = n2;
  m->tda = d2;
 8002a12:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8002a16:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->block = block;
  m->owner = 0;
 8002a1a:	2300      	movs	r3, #0
 8002a1c:	6143      	str	r3, [r0, #20]

  return m;
}
 8002a1e:	4620      	mov	r0, r4
 8002a20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8002a24:	490c      	ldr	r1, [pc, #48]	; (8002a58 <gsl_matrix_complex_long_double_alloc_from_block+0x78>)
 8002a26:	480d      	ldr	r0, [pc, #52]	; (8002a5c <gsl_matrix_complex_long_double_alloc_from_block+0x7c>)
 8002a28:	2304      	movs	r3, #4
 8002a2a:	225b      	movs	r2, #91	; 0x5b
 8002a2c:	2400      	movs	r4, #0
 8002a2e:	f7ff ff17 	bl	8002860 <gsl_error>
}
 8002a32:	4620      	mov	r0, r4
 8002a34:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8002a38:	4907      	ldr	r1, [pc, #28]	; (8002a58 <gsl_matrix_complex_long_double_alloc_from_block+0x78>)
 8002a3a:	4809      	ldr	r0, [pc, #36]	; (8002a60 <gsl_matrix_complex_long_double_alloc_from_block+0x80>)
 8002a3c:	2304      	movs	r3, #4
 8002a3e:	2256      	movs	r2, #86	; 0x56
 8002a40:	f7ff ff0e 	bl	8002860 <gsl_error>
 8002a44:	2400      	movs	r4, #0
 8002a46:	e7ea      	b.n	8002a1e <gsl_matrix_complex_long_double_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002a48:	4903      	ldr	r1, [pc, #12]	; (8002a58 <gsl_matrix_complex_long_double_alloc_from_block+0x78>)
 8002a4a:	4806      	ldr	r0, [pc, #24]	; (8002a64 <gsl_matrix_complex_long_double_alloc_from_block+0x84>)
 8002a4c:	2308      	movs	r3, #8
 8002a4e:	2263      	movs	r2, #99	; 0x63
 8002a50:	f7ff ff06 	bl	8002860 <gsl_error>
 8002a54:	e7e3      	b.n	8002a1e <gsl_matrix_complex_long_double_alloc_from_block+0x3e>
 8002a56:	bf00      	nop
 8002a58:	08030f9c 	.word	0x08030f9c
 8002a5c:	08031028 	.word	0x08031028
 8002a60:	08030ffc 	.word	0x08030ffc
 8002a64:	08030fac 	.word	0x08030fac

08002a68 <gsl_matrix_complex_long_double_alloc_from_matrix>:
FUNCTION (gsl_matrix, alloc_from_matrix) (TYPE(gsl_matrix) * mm, 
                                          const size_t k1,
                                          const size_t k2,
                                          const size_t n1, 
                                          const size_t n2)
{
 8002a68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002a6c:	461f      	mov	r7, r3
  TYPE (gsl_matrix) * m;

  if (k1 + n1 > mm->size1)
 8002a6e:	6803      	ldr	r3, [r0, #0]
{
 8002a70:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8002a74:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8002a76:	19c8      	adds	r0, r1, r7
 8002a78:	4298      	cmp	r0, r3
 8002a7a:	d826      	bhi.n	8002aca <gsl_matrix_complex_long_double_alloc_from_matrix+0x62>
    {
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
                        GSL_EINVAL, 0);
    }
  else if (k2 + n2 > mm->size2)
 8002a7c:	686b      	ldr	r3, [r5, #4]
 8002a7e:	4690      	mov	r8, r2
 8002a80:	444a      	add	r2, r9
 8002a82:	429a      	cmp	r2, r3
 8002a84:	d817      	bhi.n	8002ab6 <gsl_matrix_complex_long_double_alloc_from_matrix+0x4e>
    {
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
                        GSL_EINVAL, 0);
    }

  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002a86:	2018      	movs	r0, #24
 8002a88:	460e      	mov	r6, r1
 8002a8a:	f02d fb0b 	bl	80300a4 <malloc>

  if (m == 0)
 8002a8e:	4604      	mov	r4, r0
 8002a90:	b318      	cbz	r0, 8002ada <gsl_matrix_complex_long_double_alloc_from_matrix+0x72>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
                        GSL_ENOMEM, 0);
    }

  m->data = mm->data + k1 * mm->tda + k2 ;
  m->size1 = n1;
 8002a92:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002a94:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8002a96:	f8c4 9004 	str.w	r9, [r4, #4]
  m->tda = mm->tda;
  m->block = mm->block;
 8002a9a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002a9e:	fb06 8603 	mla	r6, r6, r3, r8
 8002aa2:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 8002aa6:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002aa8:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8002aac:	e9c4 0204 	strd	r0, r2, [r4, #16]

  return m;
}
 8002ab0:	4620      	mov	r0, r4
 8002ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8002ab6:	490c      	ldr	r1, [pc, #48]	; (8002ae8 <gsl_matrix_complex_long_double_alloc_from_matrix+0x80>)
 8002ab8:	480c      	ldr	r0, [pc, #48]	; (8002aec <gsl_matrix_complex_long_double_alloc_from_matrix+0x84>)
 8002aba:	2304      	movs	r3, #4
 8002abc:	2282      	movs	r2, #130	; 0x82
 8002abe:	2400      	movs	r4, #0
 8002ac0:	f7ff fece 	bl	8002860 <gsl_error>
}
 8002ac4:	4620      	mov	r0, r4
 8002ac6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8002aca:	4907      	ldr	r1, [pc, #28]	; (8002ae8 <gsl_matrix_complex_long_double_alloc_from_matrix+0x80>)
 8002acc:	4808      	ldr	r0, [pc, #32]	; (8002af0 <gsl_matrix_complex_long_double_alloc_from_matrix+0x88>)
 8002ace:	2304      	movs	r3, #4
 8002ad0:	227d      	movs	r2, #125	; 0x7d
 8002ad2:	f7ff fec5 	bl	8002860 <gsl_error>
 8002ad6:	2400      	movs	r4, #0
 8002ad8:	e7ea      	b.n	8002ab0 <gsl_matrix_complex_long_double_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002ada:	4903      	ldr	r1, [pc, #12]	; (8002ae8 <gsl_matrix_complex_long_double_alloc_from_matrix+0x80>)
 8002adc:	4805      	ldr	r0, [pc, #20]	; (8002af4 <gsl_matrix_complex_long_double_alloc_from_matrix+0x8c>)
 8002ade:	2308      	movs	r3, #8
 8002ae0:	228a      	movs	r2, #138	; 0x8a
 8002ae2:	f7ff febd 	bl	8002860 <gsl_error>
 8002ae6:	e7e3      	b.n	8002ab0 <gsl_matrix_complex_long_double_alloc_from_matrix+0x48>
 8002ae8:	08030f9c 	.word	0x08030f9c
 8002aec:	08031084 	.word	0x08031084
 8002af0:	08031054 	.word	0x08031054
 8002af4:	08030fac 	.word	0x08030fac

08002af8 <gsl_matrix_complex_long_double_free>:

void
FUNCTION (gsl_matrix, free) (TYPE (gsl_matrix) * m)
{
  RETURN_IF_NULL (m);
 8002af8:	b180      	cbz	r0, 8002b1c <gsl_matrix_complex_long_double_free+0x24>

  if (m->owner)
 8002afa:	6943      	ldr	r3, [r0, #20]
{
 8002afc:	b510      	push	{r4, lr}
 8002afe:	4604      	mov	r4, r0
  if (m->owner)
 8002b00:	b923      	cbnz	r3, 8002b0c <gsl_matrix_complex_long_double_free+0x14>
    {
      FUNCTION(gsl_block, free) (m->block);
    }

  free (m);
 8002b02:	4620      	mov	r0, r4
}
 8002b04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002b08:	f02d bad4 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8002b0c:	6900      	ldr	r0, [r0, #16]
 8002b0e:	f004 fdeb 	bl	80076e8 <gsl_block_complex_long_double_free>
  free (m);
 8002b12:	4620      	mov	r0, r4
}
 8002b14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002b18:	f02d bacc 	b.w	80300b4 <free>
 8002b1c:	4770      	bx	lr
 8002b1e:	bf00      	nop

08002b20 <gsl_matrix_complex_long_double_set_identity>:
void
FUNCTION (gsl_matrix, set_identity) (TYPE (gsl_matrix) * m)
{
 8002b20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  size_t i, j;
  ATOMIC * const data = m->data;
  const size_t p = m->size1 ;
 8002b24:	6807      	ldr	r7, [r0, #0]
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
 8002b26:	1d05      	adds	r5, r0, #4
 8002b28:	e895 5020 	ldmia.w	r5, {r5, ip, lr}

  const BASE zero = ZERO;
  const BASE one = ONE;

  for (i = 0; i < p; i++)
 8002b2c:	b327      	cbz	r7, 8002b78 <gsl_matrix_complex_long_double_set_identity+0x58>
 8002b2e:	2600      	movs	r6, #0
    {
      for (j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b30:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8002b7c <gsl_matrix_complex_long_double_set_identity+0x5c>
 8002b34:	2000      	movs	r0, #0
 8002b36:	2100      	movs	r1, #0
 8002b38:	f04f 0800 	mov.w	r8, #0
  for (i = 0; i < p; i++)
 8002b3c:	4634      	mov	r4, r6
      for (j = 0; j < q; j++)
 8002b3e:	b1bd      	cbz	r5, 8002b70 <gsl_matrix_complex_long_double_set_identity+0x50>
 8002b40:	eb0e 1206 	add.w	r2, lr, r6, lsl #4
 8002b44:	2300      	movs	r3, #0
 8002b46:	e008      	b.n	8002b5a <gsl_matrix_complex_long_double_set_identity+0x3a>
 8002b48:	3301      	adds	r3, #1
 8002b4a:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b4c:	e9c2 0100 	strd	r0, r1, [r2]
 8002b50:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002b54:	f102 0210 	add.w	r2, r2, #16
 8002b58:	d00a      	beq.n	8002b70 <gsl_matrix_complex_long_double_set_identity+0x50>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b5a:	42a3      	cmp	r3, r4
 8002b5c:	d1f4      	bne.n	8002b48 <gsl_matrix_complex_long_double_set_identity+0x28>
      for (j = 0; j < q; j++)
 8002b5e:	3301      	adds	r3, #1
 8002b60:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b62:	e9c2 8900 	strd	r8, r9, [r2]
 8002b66:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002b6a:	f102 0210 	add.w	r2, r2, #16
 8002b6e:	d1f4      	bne.n	8002b5a <gsl_matrix_complex_long_double_set_identity+0x3a>
  for (i = 0; i < p; i++)
 8002b70:	3401      	adds	r4, #1
 8002b72:	42a7      	cmp	r7, r4
 8002b74:	4466      	add	r6, ip
 8002b76:	d1e2      	bne.n	8002b3e <gsl_matrix_complex_long_double_set_identity+0x1e>
        }
    }
}
 8002b78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002b7c:	3ff00000 	.word	0x3ff00000

08002b80 <gsl_matrix_complex_long_double_set_zero>:
void
FUNCTION (gsl_matrix, set_zero) (TYPE (gsl_matrix) * m)
{
  size_t i, j;
  ATOMIC * const data = m->data;
  const size_t p = m->size1 ;
 8002b80:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 8002b84:	68c2      	ldr	r2, [r0, #12]
{
 8002b86:	b4f0      	push	{r4, r5, r6, r7}
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
 8002b88:	e9d0 5701 	ldrd	r5, r7, [r0, #4]

  const BASE zero = ZERO;

  for (i = 0; i < p; i++)
 8002b8c:	f1bc 0f00 	cmp.w	ip, #0
 8002b90:	d015      	beq.n	8002bbe <gsl_matrix_complex_long_double_set_zero+0x3e>
 8002b92:	ebc5 7605 	rsb	r6, r5, r5, lsl #28
 8002b96:	013f      	lsls	r7, r7, #4
 8002b98:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 8002b9c:	0136      	lsls	r6, r6, #4
 8002b9e:	2400      	movs	r4, #0
    {
      for (j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002ba0:	2000      	movs	r0, #0
 8002ba2:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8002ba4:	1993      	adds	r3, r2, r6
 8002ba6:	b135      	cbz	r5, 8002bb6 <gsl_matrix_complex_long_double_set_zero+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002ba8:	e9c3 0100 	strd	r0, r1, [r3]
 8002bac:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (j = 0; j < q; j++)
 8002bb0:	3310      	adds	r3, #16
 8002bb2:	4293      	cmp	r3, r2
 8002bb4:	d1f8      	bne.n	8002ba8 <gsl_matrix_complex_long_double_set_zero+0x28>
  for (i = 0; i < p; i++)
 8002bb6:	3401      	adds	r4, #1
 8002bb8:	45a4      	cmp	ip, r4
 8002bba:	443a      	add	r2, r7
 8002bbc:	d1f2      	bne.n	8002ba4 <gsl_matrix_complex_long_double_set_zero+0x24>
        }
    }
}
 8002bbe:	bcf0      	pop	{r4, r5, r6, r7}
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop

08002bc4 <gsl_matrix_complex_long_double_set_all>:

void
FUNCTION (gsl_matrix, set_all) (TYPE (gsl_matrix) * m, BASE x)
{
 8002bc4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  size_t i, j;
  ATOMIC * const data = m->data;
  const size_t p = m->size1 ;
 8002bc8:	f8d0 9000 	ldr.w	r9, [r0]
  ATOMIC * const data = m->data;
 8002bcc:	68c6      	ldr	r6, [r0, #12]
{
 8002bce:	b085      	sub	sp, #20
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
 8002bd0:	e9d0 c301 	ldrd	ip, r3, [r0, #4]
{
 8002bd4:	ed8d 0b00 	vstr	d0, [sp]
 8002bd8:	ed8d 1b02 	vstr	d1, [sp, #8]

  for (i = 0; i < p; i++)
 8002bdc:	f1b9 0f00 	cmp.w	r9, #0
 8002be0:	d019      	beq.n	8002c16 <gsl_matrix_complex_long_double_set_all+0x52>
 8002be2:	ebcc 7e0c 	rsb	lr, ip, ip, lsl #28
 8002be6:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8002bea:	eb06 160c 	add.w	r6, r6, ip, lsl #4
 8002bee:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
 8002bf2:	2700      	movs	r7, #0
 8002bf4:	466d      	mov	r5, sp
    {
      for (j = 0; j < q; j++)
 8002bf6:	eb06 040e 	add.w	r4, r6, lr
 8002bfa:	f1bc 0f00 	cmp.w	ip, #0
 8002bfe:	d006      	beq.n	8002c0e <gsl_matrix_complex_long_double_set_all+0x4a>
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8002c00:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002c04:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
      for (j = 0; j < q; j++)
 8002c08:	3410      	adds	r4, #16
 8002c0a:	42b4      	cmp	r4, r6
 8002c0c:	d1f8      	bne.n	8002c00 <gsl_matrix_complex_long_double_set_all+0x3c>
  for (i = 0; i < p; i++)
 8002c0e:	3701      	adds	r7, #1
 8002c10:	45b9      	cmp	r9, r7
 8002c12:	4446      	add	r6, r8
 8002c14:	d1ef      	bne.n	8002bf6 <gsl_matrix_complex_long_double_set_all+0x32>
        }
    }
}
 8002c16:	b005      	add	sp, #20
 8002c18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002c1c <gsl_matrix_complex_alloc>:
{
 8002c1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c1e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002c20:	2018      	movs	r0, #24
{
 8002c22:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002c24:	f02d fa3e 	bl	80300a4 <malloc>
  if (m == 0)
 8002c28:	4604      	mov	r4, r0
 8002c2a:	b1b8      	cbz	r0, 8002c5c <gsl_matrix_complex_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8002c2c:	fb06 f007 	mul.w	r0, r6, r7
 8002c30:	f004 fd66 	bl	8007700 <gsl_block_complex_alloc>
  if (block == 0)
 8002c34:	4605      	mov	r5, r0
 8002c36:	b148      	cbz	r0, 8002c4c <gsl_matrix_complex_alloc+0x30>
  m->data = block->data;
 8002c38:	6843      	ldr	r3, [r0, #4]
 8002c3a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8002c3c:	2301      	movs	r3, #1
  m->size2 = n2;
 8002c3e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8002c42:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8002c46:	60a6      	str	r6, [r4, #8]
}
 8002c48:	4620      	mov	r0, r4
 8002c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8002c4c:	4907      	ldr	r1, [pc, #28]	; (8002c6c <gsl_matrix_complex_alloc+0x50>)
 8002c4e:	4808      	ldr	r0, [pc, #32]	; (8002c70 <gsl_matrix_complex_alloc+0x54>)
 8002c50:	2308      	movs	r3, #8
 8002c52:	2228      	movs	r2, #40	; 0x28
 8002c54:	462c      	mov	r4, r5
 8002c56:	f7ff fe03 	bl	8002860 <gsl_error>
 8002c5a:	e7f5      	b.n	8002c48 <gsl_matrix_complex_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002c5c:	4903      	ldr	r1, [pc, #12]	; (8002c6c <gsl_matrix_complex_alloc+0x50>)
 8002c5e:	4805      	ldr	r0, [pc, #20]	; (8002c74 <gsl_matrix_complex_alloc+0x58>)
 8002c60:	2308      	movs	r3, #8
 8002c62:	221e      	movs	r2, #30
 8002c64:	f7ff fdfc 	bl	8002860 <gsl_error>
 8002c68:	e7ee      	b.n	8002c48 <gsl_matrix_complex_alloc+0x2c>
 8002c6a:	bf00      	nop
 8002c6c:	08030f9c 	.word	0x08030f9c
 8002c70:	08030fd8 	.word	0x08030fd8
 8002c74:	08030fac 	.word	0x08030fac

08002c78 <gsl_matrix_complex_calloc>:
{
 8002c78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c7a:	4604      	mov	r4, r0
 8002c7c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8002c7e:	f7ff ffcd 	bl	8002c1c <gsl_matrix_complex_alloc>
  if (m == 0)
 8002c82:	4605      	mov	r5, r0
 8002c84:	b188      	cbz	r0, 8002caa <gsl_matrix_complex_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8002c86:	fb06 f604 	mul.w	r6, r6, r4
 8002c8a:	0134      	lsls	r4, r6, #4
 8002c8c:	68c0      	ldr	r0, [r0, #12]
 8002c8e:	4622      	mov	r2, r4
 8002c90:	2100      	movs	r1, #0
 8002c92:	f02d fa17 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002c96:	0073      	lsls	r3, r6, #1
 8002c98:	d007      	beq.n	8002caa <gsl_matrix_complex_calloc+0x32>
 8002c9a:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 8002c9c:	2600      	movs	r6, #0
 8002c9e:	2700      	movs	r7, #0
 8002ca0:	18e2      	adds	r2, r4, r3
 8002ca2:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002ca6:	4293      	cmp	r3, r2
 8002ca8:	d1fb      	bne.n	8002ca2 <gsl_matrix_complex_calloc+0x2a>
}
 8002caa:	4628      	mov	r0, r5
 8002cac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002cae:	bf00      	nop

08002cb0 <gsl_matrix_complex_alloc_from_block>:
{
 8002cb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002cb4:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8002cb8:	4599      	cmp	r9, r3
 8002cba:	d325      	bcc.n	8002d08 <gsl_matrix_complex_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8002cbc:	4690      	mov	r8, r2
 8002cbe:	6802      	ldr	r2, [r0, #0]
 8002cc0:	461e      	mov	r6, r3
 8002cc2:	fb08 1309 	mla	r3, r8, r9, r1
 8002cc6:	429a      	cmp	r2, r3
 8002cc8:	4605      	mov	r5, r0
 8002cca:	460f      	mov	r7, r1
 8002ccc:	d312      	bcc.n	8002cf4 <gsl_matrix_complex_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002cce:	2018      	movs	r0, #24
 8002cd0:	f02d f9e8 	bl	80300a4 <malloc>
  if (m == 0)
 8002cd4:	4604      	mov	r4, r0
 8002cd6:	b1f8      	cbz	r0, 8002d18 <gsl_matrix_complex_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8002cd8:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8002cda:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8002cde:	eb01 1107 	add.w	r1, r1, r7, lsl #4
  m->tda = d2;
 8002ce2:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8002ce6:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8002cea:	2300      	movs	r3, #0
 8002cec:	6143      	str	r3, [r0, #20]
}
 8002cee:	4620      	mov	r0, r4
 8002cf0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8002cf4:	490c      	ldr	r1, [pc, #48]	; (8002d28 <gsl_matrix_complex_alloc_from_block+0x78>)
 8002cf6:	480d      	ldr	r0, [pc, #52]	; (8002d2c <gsl_matrix_complex_alloc_from_block+0x7c>)
 8002cf8:	2304      	movs	r3, #4
 8002cfa:	225b      	movs	r2, #91	; 0x5b
 8002cfc:	2400      	movs	r4, #0
 8002cfe:	f7ff fdaf 	bl	8002860 <gsl_error>
}
 8002d02:	4620      	mov	r0, r4
 8002d04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8002d08:	4907      	ldr	r1, [pc, #28]	; (8002d28 <gsl_matrix_complex_alloc_from_block+0x78>)
 8002d0a:	4809      	ldr	r0, [pc, #36]	; (8002d30 <gsl_matrix_complex_alloc_from_block+0x80>)
 8002d0c:	2304      	movs	r3, #4
 8002d0e:	2256      	movs	r2, #86	; 0x56
 8002d10:	f7ff fda6 	bl	8002860 <gsl_error>
 8002d14:	2400      	movs	r4, #0
 8002d16:	e7ea      	b.n	8002cee <gsl_matrix_complex_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002d18:	4903      	ldr	r1, [pc, #12]	; (8002d28 <gsl_matrix_complex_alloc_from_block+0x78>)
 8002d1a:	4806      	ldr	r0, [pc, #24]	; (8002d34 <gsl_matrix_complex_alloc_from_block+0x84>)
 8002d1c:	2308      	movs	r3, #8
 8002d1e:	2263      	movs	r2, #99	; 0x63
 8002d20:	f7ff fd9e 	bl	8002860 <gsl_error>
 8002d24:	e7e3      	b.n	8002cee <gsl_matrix_complex_alloc_from_block+0x3e>
 8002d26:	bf00      	nop
 8002d28:	08030f9c 	.word	0x08030f9c
 8002d2c:	08031028 	.word	0x08031028
 8002d30:	08030ffc 	.word	0x08030ffc
 8002d34:	08030fac 	.word	0x08030fac

08002d38 <gsl_matrix_complex_alloc_from_matrix>:
{
 8002d38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002d3c:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8002d3e:	6803      	ldr	r3, [r0, #0]
{
 8002d40:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8002d44:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8002d46:	19c8      	adds	r0, r1, r7
 8002d48:	4298      	cmp	r0, r3
 8002d4a:	d826      	bhi.n	8002d9a <gsl_matrix_complex_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8002d4c:	686b      	ldr	r3, [r5, #4]
 8002d4e:	4690      	mov	r8, r2
 8002d50:	444a      	add	r2, r9
 8002d52:	429a      	cmp	r2, r3
 8002d54:	d817      	bhi.n	8002d86 <gsl_matrix_complex_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002d56:	2018      	movs	r0, #24
 8002d58:	460e      	mov	r6, r1
 8002d5a:	f02d f9a3 	bl	80300a4 <malloc>
  if (m == 0)
 8002d5e:	4604      	mov	r4, r0
 8002d60:	b318      	cbz	r0, 8002daa <gsl_matrix_complex_alloc_from_matrix+0x72>
  m->size1 = n1;
 8002d62:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002d64:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8002d66:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8002d6a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002d6e:	fb06 8603 	mla	r6, r6, r3, r8
 8002d72:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 8002d76:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002d78:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8002d7c:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8002d80:	4620      	mov	r0, r4
 8002d82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8002d86:	490c      	ldr	r1, [pc, #48]	; (8002db8 <gsl_matrix_complex_alloc_from_matrix+0x80>)
 8002d88:	480c      	ldr	r0, [pc, #48]	; (8002dbc <gsl_matrix_complex_alloc_from_matrix+0x84>)
 8002d8a:	2304      	movs	r3, #4
 8002d8c:	2282      	movs	r2, #130	; 0x82
 8002d8e:	2400      	movs	r4, #0
 8002d90:	f7ff fd66 	bl	8002860 <gsl_error>
}
 8002d94:	4620      	mov	r0, r4
 8002d96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8002d9a:	4907      	ldr	r1, [pc, #28]	; (8002db8 <gsl_matrix_complex_alloc_from_matrix+0x80>)
 8002d9c:	4808      	ldr	r0, [pc, #32]	; (8002dc0 <gsl_matrix_complex_alloc_from_matrix+0x88>)
 8002d9e:	2304      	movs	r3, #4
 8002da0:	227d      	movs	r2, #125	; 0x7d
 8002da2:	f7ff fd5d 	bl	8002860 <gsl_error>
 8002da6:	2400      	movs	r4, #0
 8002da8:	e7ea      	b.n	8002d80 <gsl_matrix_complex_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002daa:	4903      	ldr	r1, [pc, #12]	; (8002db8 <gsl_matrix_complex_alloc_from_matrix+0x80>)
 8002dac:	4805      	ldr	r0, [pc, #20]	; (8002dc4 <gsl_matrix_complex_alloc_from_matrix+0x8c>)
 8002dae:	2308      	movs	r3, #8
 8002db0:	228a      	movs	r2, #138	; 0x8a
 8002db2:	f7ff fd55 	bl	8002860 <gsl_error>
 8002db6:	e7e3      	b.n	8002d80 <gsl_matrix_complex_alloc_from_matrix+0x48>
 8002db8:	08030f9c 	.word	0x08030f9c
 8002dbc:	08031084 	.word	0x08031084
 8002dc0:	08031054 	.word	0x08031054
 8002dc4:	08030fac 	.word	0x08030fac

08002dc8 <gsl_matrix_complex_free>:
  RETURN_IF_NULL (m);
 8002dc8:	b180      	cbz	r0, 8002dec <gsl_matrix_complex_free+0x24>
  if (m->owner)
 8002dca:	6943      	ldr	r3, [r0, #20]
{
 8002dcc:	b510      	push	{r4, lr}
 8002dce:	4604      	mov	r4, r0
  if (m->owner)
 8002dd0:	b923      	cbnz	r3, 8002ddc <gsl_matrix_complex_free+0x14>
  free (m);
 8002dd2:	4620      	mov	r0, r4
}
 8002dd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002dd8:	f02d b96c 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8002ddc:	6900      	ldr	r0, [r0, #16]
 8002dde:	f004 fcd1 	bl	8007784 <gsl_block_complex_free>
  free (m);
 8002de2:	4620      	mov	r0, r4
}
 8002de4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002de8:	f02d b964 	b.w	80300b4 <free>
 8002dec:	4770      	bx	lr
 8002dee:	bf00      	nop

08002df0 <gsl_matrix_complex_set_identity>:
{
 8002df0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  const size_t p = m->size1 ;
 8002df4:	6807      	ldr	r7, [r0, #0]
  const size_t tda = m->tda ;
 8002df6:	1d05      	adds	r5, r0, #4
 8002df8:	e895 5020 	ldmia.w	r5, {r5, ip, lr}
  for (i = 0; i < p; i++)
 8002dfc:	b327      	cbz	r7, 8002e48 <gsl_matrix_complex_set_identity+0x58>
 8002dfe:	2600      	movs	r6, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e00:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8002e4c <gsl_matrix_complex_set_identity+0x5c>
 8002e04:	2000      	movs	r0, #0
 8002e06:	2100      	movs	r1, #0
 8002e08:	f04f 0800 	mov.w	r8, #0
  for (i = 0; i < p; i++)
 8002e0c:	4634      	mov	r4, r6
      for (j = 0; j < q; j++)
 8002e0e:	b1bd      	cbz	r5, 8002e40 <gsl_matrix_complex_set_identity+0x50>
 8002e10:	eb0e 1206 	add.w	r2, lr, r6, lsl #4
 8002e14:	2300      	movs	r3, #0
 8002e16:	e008      	b.n	8002e2a <gsl_matrix_complex_set_identity+0x3a>
 8002e18:	3301      	adds	r3, #1
 8002e1a:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e1c:	e9c2 0100 	strd	r0, r1, [r2]
 8002e20:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002e24:	f102 0210 	add.w	r2, r2, #16
 8002e28:	d00a      	beq.n	8002e40 <gsl_matrix_complex_set_identity+0x50>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e2a:	42a3      	cmp	r3, r4
 8002e2c:	d1f4      	bne.n	8002e18 <gsl_matrix_complex_set_identity+0x28>
      for (j = 0; j < q; j++)
 8002e2e:	3301      	adds	r3, #1
 8002e30:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e32:	e9c2 8900 	strd	r8, r9, [r2]
 8002e36:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002e3a:	f102 0210 	add.w	r2, r2, #16
 8002e3e:	d1f4      	bne.n	8002e2a <gsl_matrix_complex_set_identity+0x3a>
  for (i = 0; i < p; i++)
 8002e40:	3401      	adds	r4, #1
 8002e42:	42a7      	cmp	r7, r4
 8002e44:	4466      	add	r6, ip
 8002e46:	d1e2      	bne.n	8002e0e <gsl_matrix_complex_set_identity+0x1e>
}
 8002e48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002e4c:	3ff00000 	.word	0x3ff00000

08002e50 <gsl_matrix_complex_set_zero>:
  const size_t p = m->size1 ;
 8002e50:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 8002e54:	68c2      	ldr	r2, [r0, #12]
{
 8002e56:	b4f0      	push	{r4, r5, r6, r7}
  const size_t tda = m->tda ;
 8002e58:	e9d0 5701 	ldrd	r5, r7, [r0, #4]
  for (i = 0; i < p; i++)
 8002e5c:	f1bc 0f00 	cmp.w	ip, #0
 8002e60:	d015      	beq.n	8002e8e <gsl_matrix_complex_set_zero+0x3e>
 8002e62:	ebc5 7605 	rsb	r6, r5, r5, lsl #28
 8002e66:	013f      	lsls	r7, r7, #4
 8002e68:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 8002e6c:	0136      	lsls	r6, r6, #4
 8002e6e:	2400      	movs	r4, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002e70:	2000      	movs	r0, #0
 8002e72:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8002e74:	1993      	adds	r3, r2, r6
 8002e76:	b135      	cbz	r5, 8002e86 <gsl_matrix_complex_set_zero+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002e78:	e9c3 0100 	strd	r0, r1, [r3]
 8002e7c:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (j = 0; j < q; j++)
 8002e80:	3310      	adds	r3, #16
 8002e82:	4293      	cmp	r3, r2
 8002e84:	d1f8      	bne.n	8002e78 <gsl_matrix_complex_set_zero+0x28>
  for (i = 0; i < p; i++)
 8002e86:	3401      	adds	r4, #1
 8002e88:	45a4      	cmp	ip, r4
 8002e8a:	443a      	add	r2, r7
 8002e8c:	d1f2      	bne.n	8002e74 <gsl_matrix_complex_set_zero+0x24>
}
 8002e8e:	bcf0      	pop	{r4, r5, r6, r7}
 8002e90:	4770      	bx	lr
 8002e92:	bf00      	nop

08002e94 <gsl_matrix_complex_set_all>:
{
 8002e94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  const size_t p = m->size1 ;
 8002e98:	f8d0 9000 	ldr.w	r9, [r0]
  ATOMIC * const data = m->data;
 8002e9c:	68c6      	ldr	r6, [r0, #12]
{
 8002e9e:	b085      	sub	sp, #20
  const size_t tda = m->tda ;
 8002ea0:	e9d0 c301 	ldrd	ip, r3, [r0, #4]
{
 8002ea4:	ed8d 0b00 	vstr	d0, [sp]
 8002ea8:	ed8d 1b02 	vstr	d1, [sp, #8]
  for (i = 0; i < p; i++)
 8002eac:	f1b9 0f00 	cmp.w	r9, #0
 8002eb0:	d019      	beq.n	8002ee6 <gsl_matrix_complex_set_all+0x52>
 8002eb2:	ebcc 7e0c 	rsb	lr, ip, ip, lsl #28
 8002eb6:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8002eba:	eb06 160c 	add.w	r6, r6, ip, lsl #4
 8002ebe:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
 8002ec2:	2700      	movs	r7, #0
 8002ec4:	466d      	mov	r5, sp
      for (j = 0; j < q; j++)
 8002ec6:	eb06 040e 	add.w	r4, r6, lr
 8002eca:	f1bc 0f00 	cmp.w	ip, #0
 8002ece:	d006      	beq.n	8002ede <gsl_matrix_complex_set_all+0x4a>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8002ed0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002ed4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
      for (j = 0; j < q; j++)
 8002ed8:	3410      	adds	r4, #16
 8002eda:	42b4      	cmp	r4, r6
 8002edc:	d1f8      	bne.n	8002ed0 <gsl_matrix_complex_set_all+0x3c>
  for (i = 0; i < p; i++)
 8002ede:	3701      	adds	r7, #1
 8002ee0:	45b9      	cmp	r9, r7
 8002ee2:	4446      	add	r6, r8
 8002ee4:	d1ef      	bne.n	8002ec6 <gsl_matrix_complex_set_all+0x32>
}
 8002ee6:	b005      	add	sp, #20
 8002ee8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002eec <gsl_matrix_complex_float_alloc>:
{
 8002eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002eee:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002ef0:	2018      	movs	r0, #24
{
 8002ef2:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002ef4:	f02d f8d6 	bl	80300a4 <malloc>
  if (m == 0)
 8002ef8:	4604      	mov	r4, r0
 8002efa:	b1b8      	cbz	r0, 8002f2c <gsl_matrix_complex_float_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8002efc:	fb06 f007 	mul.w	r0, r6, r7
 8002f00:	f004 fc4c 	bl	800779c <gsl_block_complex_float_alloc>
  if (block == 0)
 8002f04:	4605      	mov	r5, r0
 8002f06:	b148      	cbz	r0, 8002f1c <gsl_matrix_complex_float_alloc+0x30>
  m->data = block->data;
 8002f08:	6843      	ldr	r3, [r0, #4]
 8002f0a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8002f0c:	2301      	movs	r3, #1
  m->size2 = n2;
 8002f0e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8002f12:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8002f16:	60a6      	str	r6, [r4, #8]
}
 8002f18:	4620      	mov	r0, r4
 8002f1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8002f1c:	4907      	ldr	r1, [pc, #28]	; (8002f3c <gsl_matrix_complex_float_alloc+0x50>)
 8002f1e:	4808      	ldr	r0, [pc, #32]	; (8002f40 <gsl_matrix_complex_float_alloc+0x54>)
 8002f20:	2308      	movs	r3, #8
 8002f22:	2228      	movs	r2, #40	; 0x28
 8002f24:	462c      	mov	r4, r5
 8002f26:	f7ff fc9b 	bl	8002860 <gsl_error>
 8002f2a:	e7f5      	b.n	8002f18 <gsl_matrix_complex_float_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002f2c:	4903      	ldr	r1, [pc, #12]	; (8002f3c <gsl_matrix_complex_float_alloc+0x50>)
 8002f2e:	4805      	ldr	r0, [pc, #20]	; (8002f44 <gsl_matrix_complex_float_alloc+0x58>)
 8002f30:	2308      	movs	r3, #8
 8002f32:	221e      	movs	r2, #30
 8002f34:	f7ff fc94 	bl	8002860 <gsl_error>
 8002f38:	e7ee      	b.n	8002f18 <gsl_matrix_complex_float_alloc+0x2c>
 8002f3a:	bf00      	nop
 8002f3c:	08030f9c 	.word	0x08030f9c
 8002f40:	08030fd8 	.word	0x08030fd8
 8002f44:	08030fac 	.word	0x08030fac

08002f48 <gsl_matrix_complex_float_calloc>:
{
 8002f48:	b570      	push	{r4, r5, r6, lr}
 8002f4a:	4604      	mov	r4, r0
 8002f4c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8002f4e:	f7ff ffcd 	bl	8002eec <gsl_matrix_complex_float_alloc>
  if (m == 0)
 8002f52:	4605      	mov	r5, r0
 8002f54:	b180      	cbz	r0, 8002f78 <gsl_matrix_complex_float_calloc+0x30>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8002f56:	fb06 f604 	mul.w	r6, r6, r4
 8002f5a:	00f4      	lsls	r4, r6, #3
 8002f5c:	68c0      	ldr	r0, [r0, #12]
 8002f5e:	4622      	mov	r2, r4
 8002f60:	2100      	movs	r1, #0
 8002f62:	f02d f8af 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002f66:	0073      	lsls	r3, r6, #1
 8002f68:	d006      	beq.n	8002f78 <gsl_matrix_complex_float_calloc+0x30>
 8002f6a:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 8002f6c:	2100      	movs	r1, #0
 8002f6e:	18e2      	adds	r2, r4, r3
 8002f70:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002f74:	4293      	cmp	r3, r2
 8002f76:	d1fb      	bne.n	8002f70 <gsl_matrix_complex_float_calloc+0x28>
}
 8002f78:	4628      	mov	r0, r5
 8002f7a:	bd70      	pop	{r4, r5, r6, pc}

08002f7c <gsl_matrix_complex_float_alloc_from_block>:
{
 8002f7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002f80:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8002f84:	4599      	cmp	r9, r3
 8002f86:	d325      	bcc.n	8002fd4 <gsl_matrix_complex_float_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8002f88:	4690      	mov	r8, r2
 8002f8a:	6802      	ldr	r2, [r0, #0]
 8002f8c:	461e      	mov	r6, r3
 8002f8e:	fb08 1309 	mla	r3, r8, r9, r1
 8002f92:	429a      	cmp	r2, r3
 8002f94:	4605      	mov	r5, r0
 8002f96:	460f      	mov	r7, r1
 8002f98:	d312      	bcc.n	8002fc0 <gsl_matrix_complex_float_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002f9a:	2018      	movs	r0, #24
 8002f9c:	f02d f882 	bl	80300a4 <malloc>
  if (m == 0)
 8002fa0:	4604      	mov	r4, r0
 8002fa2:	b1f8      	cbz	r0, 8002fe4 <gsl_matrix_complex_float_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8002fa4:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8002fa6:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8002faa:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
  m->tda = d2;
 8002fae:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8002fb2:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8002fb6:	2300      	movs	r3, #0
 8002fb8:	6143      	str	r3, [r0, #20]
}
 8002fba:	4620      	mov	r0, r4
 8002fbc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8002fc0:	490c      	ldr	r1, [pc, #48]	; (8002ff4 <gsl_matrix_complex_float_alloc_from_block+0x78>)
 8002fc2:	480d      	ldr	r0, [pc, #52]	; (8002ff8 <gsl_matrix_complex_float_alloc_from_block+0x7c>)
 8002fc4:	2304      	movs	r3, #4
 8002fc6:	225b      	movs	r2, #91	; 0x5b
 8002fc8:	2400      	movs	r4, #0
 8002fca:	f7ff fc49 	bl	8002860 <gsl_error>
}
 8002fce:	4620      	mov	r0, r4
 8002fd0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8002fd4:	4907      	ldr	r1, [pc, #28]	; (8002ff4 <gsl_matrix_complex_float_alloc_from_block+0x78>)
 8002fd6:	4809      	ldr	r0, [pc, #36]	; (8002ffc <gsl_matrix_complex_float_alloc_from_block+0x80>)
 8002fd8:	2304      	movs	r3, #4
 8002fda:	2256      	movs	r2, #86	; 0x56
 8002fdc:	f7ff fc40 	bl	8002860 <gsl_error>
 8002fe0:	2400      	movs	r4, #0
 8002fe2:	e7ea      	b.n	8002fba <gsl_matrix_complex_float_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002fe4:	4903      	ldr	r1, [pc, #12]	; (8002ff4 <gsl_matrix_complex_float_alloc_from_block+0x78>)
 8002fe6:	4806      	ldr	r0, [pc, #24]	; (8003000 <gsl_matrix_complex_float_alloc_from_block+0x84>)
 8002fe8:	2308      	movs	r3, #8
 8002fea:	2263      	movs	r2, #99	; 0x63
 8002fec:	f7ff fc38 	bl	8002860 <gsl_error>
 8002ff0:	e7e3      	b.n	8002fba <gsl_matrix_complex_float_alloc_from_block+0x3e>
 8002ff2:	bf00      	nop
 8002ff4:	08030f9c 	.word	0x08030f9c
 8002ff8:	08031028 	.word	0x08031028
 8002ffc:	08030ffc 	.word	0x08030ffc
 8003000:	08030fac 	.word	0x08030fac

08003004 <gsl_matrix_complex_float_alloc_from_matrix>:
{
 8003004:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003008:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 800300a:	6803      	ldr	r3, [r0, #0]
{
 800300c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003010:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003012:	19c8      	adds	r0, r1, r7
 8003014:	4298      	cmp	r0, r3
 8003016:	d826      	bhi.n	8003066 <gsl_matrix_complex_float_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003018:	686b      	ldr	r3, [r5, #4]
 800301a:	4690      	mov	r8, r2
 800301c:	444a      	add	r2, r9
 800301e:	429a      	cmp	r2, r3
 8003020:	d817      	bhi.n	8003052 <gsl_matrix_complex_float_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003022:	2018      	movs	r0, #24
 8003024:	460e      	mov	r6, r1
 8003026:	f02d f83d 	bl	80300a4 <malloc>
  if (m == 0)
 800302a:	4604      	mov	r4, r0
 800302c:	b318      	cbz	r0, 8003076 <gsl_matrix_complex_float_alloc_from_matrix+0x72>
  m->size1 = n1;
 800302e:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003030:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003032:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003036:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 800303a:	fb06 8603 	mla	r6, r6, r3, r8
 800303e:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003042:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003044:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003048:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 800304c:	4620      	mov	r0, r4
 800304e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003052:	490c      	ldr	r1, [pc, #48]	; (8003084 <gsl_matrix_complex_float_alloc_from_matrix+0x80>)
 8003054:	480c      	ldr	r0, [pc, #48]	; (8003088 <gsl_matrix_complex_float_alloc_from_matrix+0x84>)
 8003056:	2304      	movs	r3, #4
 8003058:	2282      	movs	r2, #130	; 0x82
 800305a:	2400      	movs	r4, #0
 800305c:	f7ff fc00 	bl	8002860 <gsl_error>
}
 8003060:	4620      	mov	r0, r4
 8003062:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003066:	4907      	ldr	r1, [pc, #28]	; (8003084 <gsl_matrix_complex_float_alloc_from_matrix+0x80>)
 8003068:	4808      	ldr	r0, [pc, #32]	; (800308c <gsl_matrix_complex_float_alloc_from_matrix+0x88>)
 800306a:	2304      	movs	r3, #4
 800306c:	227d      	movs	r2, #125	; 0x7d
 800306e:	f7ff fbf7 	bl	8002860 <gsl_error>
 8003072:	2400      	movs	r4, #0
 8003074:	e7ea      	b.n	800304c <gsl_matrix_complex_float_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003076:	4903      	ldr	r1, [pc, #12]	; (8003084 <gsl_matrix_complex_float_alloc_from_matrix+0x80>)
 8003078:	4805      	ldr	r0, [pc, #20]	; (8003090 <gsl_matrix_complex_float_alloc_from_matrix+0x8c>)
 800307a:	2308      	movs	r3, #8
 800307c:	228a      	movs	r2, #138	; 0x8a
 800307e:	f7ff fbef 	bl	8002860 <gsl_error>
 8003082:	e7e3      	b.n	800304c <gsl_matrix_complex_float_alloc_from_matrix+0x48>
 8003084:	08030f9c 	.word	0x08030f9c
 8003088:	08031084 	.word	0x08031084
 800308c:	08031054 	.word	0x08031054
 8003090:	08030fac 	.word	0x08030fac

08003094 <gsl_matrix_complex_float_free>:
  RETURN_IF_NULL (m);
 8003094:	b180      	cbz	r0, 80030b8 <gsl_matrix_complex_float_free+0x24>
  if (m->owner)
 8003096:	6943      	ldr	r3, [r0, #20]
{
 8003098:	b510      	push	{r4, lr}
 800309a:	4604      	mov	r4, r0
  if (m->owner)
 800309c:	b923      	cbnz	r3, 80030a8 <gsl_matrix_complex_float_free+0x14>
  free (m);
 800309e:	4620      	mov	r0, r4
}
 80030a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80030a4:	f02d b806 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 80030a8:	6900      	ldr	r0, [r0, #16]
 80030aa:	f004 fbb9 	bl	8007820 <gsl_block_complex_float_free>
  free (m);
 80030ae:	4620      	mov	r0, r4
}
 80030b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80030b4:	f02c bffe 	b.w	80300b4 <free>
 80030b8:	4770      	bx	lr
 80030ba:	bf00      	nop

080030bc <gsl_matrix_complex_float_set_identity>:
{
 80030bc:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 80030be:	6807      	ldr	r7, [r0, #0]
  const size_t tda = m->tda ;
 80030c0:	1d04      	adds	r4, r0, #4
 80030c2:	e894 5010 	ldmia.w	r4, {r4, ip, lr}
  for (i = 0; i < p; i++)
 80030c6:	b1bf      	cbz	r7, 80030f8 <gsl_matrix_complex_float_set_identity+0x3c>
 80030c8:	2500      	movs	r5, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030ca:	2100      	movs	r1, #0
  for (i = 0; i < p; i++)
 80030cc:	4628      	mov	r0, r5
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030ce:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
      for (j = 0; j < q; j++)
 80030d2:	b16c      	cbz	r4, 80030f0 <gsl_matrix_complex_float_set_identity+0x34>
 80030d4:	eb0e 02c5 	add.w	r2, lr, r5, lsl #3
 80030d8:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030da:	4283      	cmp	r3, r0
      for (j = 0; j < q; j++)
 80030dc:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030e0:	bf0c      	ite	eq
 80030e2:	6016      	streq	r6, [r2, #0]
 80030e4:	6011      	strne	r1, [r2, #0]
      for (j = 0; j < q; j++)
 80030e6:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030e8:	6051      	str	r1, [r2, #4]
      for (j = 0; j < q; j++)
 80030ea:	f102 0208 	add.w	r2, r2, #8
 80030ee:	d1f4      	bne.n	80030da <gsl_matrix_complex_float_set_identity+0x1e>
  for (i = 0; i < p; i++)
 80030f0:	3001      	adds	r0, #1
 80030f2:	4287      	cmp	r7, r0
 80030f4:	4465      	add	r5, ip
 80030f6:	d1ec      	bne.n	80030d2 <gsl_matrix_complex_float_set_identity+0x16>
}
 80030f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80030fa:	bf00      	nop

080030fc <gsl_matrix_complex_float_set_zero>:
{
 80030fc:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80030fe:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003100:	68c1      	ldr	r1, [r0, #12]
  const size_t tda = m->tda ;
 8003102:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003106:	b197      	cbz	r7, 800312e <gsl_matrix_complex_float_set_zero+0x32>
 8003108:	ebc4 7544 	rsb	r5, r4, r4, lsl #29
 800310c:	00f6      	lsls	r6, r6, #3
 800310e:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 8003112:	00ed      	lsls	r5, r5, #3
 8003114:	2000      	movs	r0, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003116:	2200      	movs	r2, #0
      for (j = 0; j < q; j++)
 8003118:	194b      	adds	r3, r1, r5
 800311a:	b124      	cbz	r4, 8003126 <gsl_matrix_complex_float_set_zero+0x2a>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800311c:	601a      	str	r2, [r3, #0]
 800311e:	605a      	str	r2, [r3, #4]
      for (j = 0; j < q; j++)
 8003120:	3308      	adds	r3, #8
 8003122:	428b      	cmp	r3, r1
 8003124:	d1fa      	bne.n	800311c <gsl_matrix_complex_float_set_zero+0x20>
  for (i = 0; i < p; i++)
 8003126:	3001      	adds	r0, #1
 8003128:	4287      	cmp	r7, r0
 800312a:	4431      	add	r1, r6
 800312c:	d1f4      	bne.n	8003118 <gsl_matrix_complex_float_set_zero+0x1c>
}
 800312e:	bcf0      	pop	{r4, r5, r6, r7}
 8003130:	4770      	bx	lr
 8003132:	bf00      	nop

08003134 <gsl_matrix_complex_float_set_all>:
{
 8003134:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 8003136:	f8d0 e000 	ldr.w	lr, [r0]
  ATOMIC * const data = m->data;
 800313a:	68c5      	ldr	r5, [r0, #12]
{
 800313c:	b083      	sub	sp, #12
  const size_t tda = m->tda ;
 800313e:	e9d0 6301 	ldrd	r6, r3, [r0, #4]
{
 8003142:	ed8d 0a00 	vstr	s0, [sp]
 8003146:	edcd 0a01 	vstr	s1, [sp, #4]
  for (i = 0; i < p; i++)
 800314a:	f1be 0f00 	cmp.w	lr, #0
 800314e:	d012      	beq.n	8003176 <gsl_matrix_complex_float_set_all+0x42>
 8003150:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 8003154:	2700      	movs	r7, #0
 8003156:	466c      	mov	r4, sp
      for (j = 0; j < q; j++)
 8003158:	2300      	movs	r3, #0
 800315a:	b146      	cbz	r6, 800316e <gsl_matrix_complex_float_set_all+0x3a>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 800315c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8003160:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
      for (j = 0; j < q; j++)
 8003164:	3301      	adds	r3, #1
 8003166:	429e      	cmp	r6, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003168:	e882 0003 	stmia.w	r2, {r0, r1}
      for (j = 0; j < q; j++)
 800316c:	d1f6      	bne.n	800315c <gsl_matrix_complex_float_set_all+0x28>
  for (i = 0; i < p; i++)
 800316e:	3701      	adds	r7, #1
 8003170:	45be      	cmp	lr, r7
 8003172:	4465      	add	r5, ip
 8003174:	d1f0      	bne.n	8003158 <gsl_matrix_complex_float_set_all+0x24>
}
 8003176:	b003      	add	sp, #12
 8003178:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800317a:	bf00      	nop

0800317c <gsl_matrix_long_double_alloc>:
{
 800317c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800317e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003180:	2018      	movs	r0, #24
{
 8003182:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003184:	f02c ff8e 	bl	80300a4 <malloc>
  if (m == 0)
 8003188:	4604      	mov	r4, r0
 800318a:	b1b8      	cbz	r0, 80031bc <gsl_matrix_long_double_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800318c:	fb06 f007 	mul.w	r0, r6, r7
 8003190:	f004 fb52 	bl	8007838 <gsl_block_long_double_alloc>
  if (block == 0)
 8003194:	4605      	mov	r5, r0
 8003196:	b148      	cbz	r0, 80031ac <gsl_matrix_long_double_alloc+0x30>
  m->data = block->data;
 8003198:	6843      	ldr	r3, [r0, #4]
 800319a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 800319c:	2301      	movs	r3, #1
  m->size2 = n2;
 800319e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 80031a2:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 80031a6:	60a6      	str	r6, [r4, #8]
}
 80031a8:	4620      	mov	r0, r4
 80031aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80031ac:	4907      	ldr	r1, [pc, #28]	; (80031cc <gsl_matrix_long_double_alloc+0x50>)
 80031ae:	4808      	ldr	r0, [pc, #32]	; (80031d0 <gsl_matrix_long_double_alloc+0x54>)
 80031b0:	2308      	movs	r3, #8
 80031b2:	2228      	movs	r2, #40	; 0x28
 80031b4:	462c      	mov	r4, r5
 80031b6:	f7ff fb53 	bl	8002860 <gsl_error>
 80031ba:	e7f5      	b.n	80031a8 <gsl_matrix_long_double_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80031bc:	4903      	ldr	r1, [pc, #12]	; (80031cc <gsl_matrix_long_double_alloc+0x50>)
 80031be:	4805      	ldr	r0, [pc, #20]	; (80031d4 <gsl_matrix_long_double_alloc+0x58>)
 80031c0:	2308      	movs	r3, #8
 80031c2:	221e      	movs	r2, #30
 80031c4:	f7ff fb4c 	bl	8002860 <gsl_error>
 80031c8:	e7ee      	b.n	80031a8 <gsl_matrix_long_double_alloc+0x2c>
 80031ca:	bf00      	nop
 80031cc:	08030f9c 	.word	0x08030f9c
 80031d0:	08030fd8 	.word	0x08030fd8
 80031d4:	08030fac 	.word	0x08030fac

080031d8 <gsl_matrix_long_double_calloc>:
{
 80031d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80031da:	4604      	mov	r4, r0
 80031dc:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80031de:	f7ff ffcd 	bl	800317c <gsl_matrix_long_double_alloc>
  if (m == 0)
 80031e2:	4605      	mov	r5, r0
 80031e4:	b180      	cbz	r0, 8003208 <gsl_matrix_long_double_calloc+0x30>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80031e6:	fb06 f604 	mul.w	r6, r6, r4
 80031ea:	00f4      	lsls	r4, r6, #3
 80031ec:	68c0      	ldr	r0, [r0, #12]
 80031ee:	4622      	mov	r2, r4
 80031f0:	2100      	movs	r1, #0
 80031f2:	f02c ff67 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80031f6:	b13e      	cbz	r6, 8003208 <gsl_matrix_long_double_calloc+0x30>
 80031f8:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 80031fa:	2600      	movs	r6, #0
 80031fc:	2700      	movs	r7, #0
 80031fe:	18e2      	adds	r2, r4, r3
 8003200:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003204:	4293      	cmp	r3, r2
 8003206:	d1fb      	bne.n	8003200 <gsl_matrix_long_double_calloc+0x28>
}
 8003208:	4628      	mov	r0, r5
 800320a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800320c <gsl_matrix_long_double_alloc_from_block>:
{
 800320c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003210:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003214:	4599      	cmp	r9, r3
 8003216:	d325      	bcc.n	8003264 <gsl_matrix_long_double_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003218:	4690      	mov	r8, r2
 800321a:	6802      	ldr	r2, [r0, #0]
 800321c:	461e      	mov	r6, r3
 800321e:	fb08 1309 	mla	r3, r8, r9, r1
 8003222:	429a      	cmp	r2, r3
 8003224:	4605      	mov	r5, r0
 8003226:	460f      	mov	r7, r1
 8003228:	d312      	bcc.n	8003250 <gsl_matrix_long_double_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800322a:	2018      	movs	r0, #24
 800322c:	f02c ff3a 	bl	80300a4 <malloc>
  if (m == 0)
 8003230:	4604      	mov	r4, r0
 8003232:	b1f8      	cbz	r0, 8003274 <gsl_matrix_long_double_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003234:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003236:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800323a:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
  m->tda = d2;
 800323e:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003242:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003246:	2300      	movs	r3, #0
 8003248:	6143      	str	r3, [r0, #20]
}
 800324a:	4620      	mov	r0, r4
 800324c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003250:	490c      	ldr	r1, [pc, #48]	; (8003284 <gsl_matrix_long_double_alloc_from_block+0x78>)
 8003252:	480d      	ldr	r0, [pc, #52]	; (8003288 <gsl_matrix_long_double_alloc_from_block+0x7c>)
 8003254:	2304      	movs	r3, #4
 8003256:	225b      	movs	r2, #91	; 0x5b
 8003258:	2400      	movs	r4, #0
 800325a:	f7ff fb01 	bl	8002860 <gsl_error>
}
 800325e:	4620      	mov	r0, r4
 8003260:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003264:	4907      	ldr	r1, [pc, #28]	; (8003284 <gsl_matrix_long_double_alloc_from_block+0x78>)
 8003266:	4809      	ldr	r0, [pc, #36]	; (800328c <gsl_matrix_long_double_alloc_from_block+0x80>)
 8003268:	2304      	movs	r3, #4
 800326a:	2256      	movs	r2, #86	; 0x56
 800326c:	f7ff faf8 	bl	8002860 <gsl_error>
 8003270:	2400      	movs	r4, #0
 8003272:	e7ea      	b.n	800324a <gsl_matrix_long_double_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003274:	4903      	ldr	r1, [pc, #12]	; (8003284 <gsl_matrix_long_double_alloc_from_block+0x78>)
 8003276:	4806      	ldr	r0, [pc, #24]	; (8003290 <gsl_matrix_long_double_alloc_from_block+0x84>)
 8003278:	2308      	movs	r3, #8
 800327a:	2263      	movs	r2, #99	; 0x63
 800327c:	f7ff faf0 	bl	8002860 <gsl_error>
 8003280:	e7e3      	b.n	800324a <gsl_matrix_long_double_alloc_from_block+0x3e>
 8003282:	bf00      	nop
 8003284:	08030f9c 	.word	0x08030f9c
 8003288:	08031028 	.word	0x08031028
 800328c:	08030ffc 	.word	0x08030ffc
 8003290:	08030fac 	.word	0x08030fac

08003294 <gsl_matrix_long_double_alloc_from_matrix>:
{
 8003294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003298:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 800329a:	6803      	ldr	r3, [r0, #0]
{
 800329c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80032a0:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 80032a2:	19c8      	adds	r0, r1, r7
 80032a4:	4298      	cmp	r0, r3
 80032a6:	d826      	bhi.n	80032f6 <gsl_matrix_long_double_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80032a8:	686b      	ldr	r3, [r5, #4]
 80032aa:	4690      	mov	r8, r2
 80032ac:	444a      	add	r2, r9
 80032ae:	429a      	cmp	r2, r3
 80032b0:	d817      	bhi.n	80032e2 <gsl_matrix_long_double_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80032b2:	2018      	movs	r0, #24
 80032b4:	460e      	mov	r6, r1
 80032b6:	f02c fef5 	bl	80300a4 <malloc>
  if (m == 0)
 80032ba:	4604      	mov	r4, r0
 80032bc:	b318      	cbz	r0, 8003306 <gsl_matrix_long_double_alloc_from_matrix+0x72>
  m->size1 = n1;
 80032be:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80032c0:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80032c2:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80032c6:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80032ca:	fb06 8603 	mla	r6, r6, r3, r8
 80032ce:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 80032d2:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 80032d4:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 80032d8:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 80032dc:	4620      	mov	r0, r4
 80032de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 80032e2:	490c      	ldr	r1, [pc, #48]	; (8003314 <gsl_matrix_long_double_alloc_from_matrix+0x80>)
 80032e4:	480c      	ldr	r0, [pc, #48]	; (8003318 <gsl_matrix_long_double_alloc_from_matrix+0x84>)
 80032e6:	2304      	movs	r3, #4
 80032e8:	2282      	movs	r2, #130	; 0x82
 80032ea:	2400      	movs	r4, #0
 80032ec:	f7ff fab8 	bl	8002860 <gsl_error>
}
 80032f0:	4620      	mov	r0, r4
 80032f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 80032f6:	4907      	ldr	r1, [pc, #28]	; (8003314 <gsl_matrix_long_double_alloc_from_matrix+0x80>)
 80032f8:	4808      	ldr	r0, [pc, #32]	; (800331c <gsl_matrix_long_double_alloc_from_matrix+0x88>)
 80032fa:	2304      	movs	r3, #4
 80032fc:	227d      	movs	r2, #125	; 0x7d
 80032fe:	f7ff faaf 	bl	8002860 <gsl_error>
 8003302:	2400      	movs	r4, #0
 8003304:	e7ea      	b.n	80032dc <gsl_matrix_long_double_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003306:	4903      	ldr	r1, [pc, #12]	; (8003314 <gsl_matrix_long_double_alloc_from_matrix+0x80>)
 8003308:	4805      	ldr	r0, [pc, #20]	; (8003320 <gsl_matrix_long_double_alloc_from_matrix+0x8c>)
 800330a:	2308      	movs	r3, #8
 800330c:	228a      	movs	r2, #138	; 0x8a
 800330e:	f7ff faa7 	bl	8002860 <gsl_error>
 8003312:	e7e3      	b.n	80032dc <gsl_matrix_long_double_alloc_from_matrix+0x48>
 8003314:	08030f9c 	.word	0x08030f9c
 8003318:	08031084 	.word	0x08031084
 800331c:	08031054 	.word	0x08031054
 8003320:	08030fac 	.word	0x08030fac

08003324 <gsl_matrix_long_double_free>:
  RETURN_IF_NULL (m);
 8003324:	b180      	cbz	r0, 8003348 <gsl_matrix_long_double_free+0x24>
  if (m->owner)
 8003326:	6943      	ldr	r3, [r0, #20]
{
 8003328:	b510      	push	{r4, lr}
 800332a:	4604      	mov	r4, r0
  if (m->owner)
 800332c:	b923      	cbnz	r3, 8003338 <gsl_matrix_long_double_free+0x14>
  free (m);
 800332e:	4620      	mov	r0, r4
}
 8003330:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003334:	f02c bebe 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003338:	6900      	ldr	r0, [r0, #16]
 800333a:	f004 fabf 	bl	80078bc <gsl_block_long_double_free>
  free (m);
 800333e:	4620      	mov	r0, r4
}
 8003340:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003344:	f02c beb6 	b.w	80300b4 <free>
 8003348:	4770      	bx	lr
 800334a:	bf00      	nop

0800334c <gsl_matrix_long_double_set_identity>:
{
 800334c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const size_t p = m->size1 ;
 8003350:	f8d0 e000 	ldr.w	lr, [r0]
  const size_t tda = m->tda ;
 8003354:	1d05      	adds	r5, r0, #4
 8003356:	e895 0c20 	ldmia.w	r5, {r5, sl, fp}
  for (i = 0; i < p; i++)
 800335a:	f1be 0f00 	cmp.w	lr, #0
 800335e:	d01c      	beq.n	800339a <gsl_matrix_long_double_set_identity+0x4e>
 8003360:	f04f 0c00 	mov.w	ip, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003364:	f8df 9038 	ldr.w	r9, [pc, #56]	; 80033a0 <gsl_matrix_long_double_set_identity+0x54>
 8003368:	f04f 0800 	mov.w	r8, #0
 800336c:	2600      	movs	r6, #0
 800336e:	2700      	movs	r7, #0
  for (i = 0; i < p; i++)
 8003370:	4664      	mov	r4, ip
      for (j = 0; j < q; j++)
 8003372:	b175      	cbz	r5, 8003392 <gsl_matrix_long_double_set_identity+0x46>
 8003374:	eb0b 02cc 	add.w	r2, fp, ip, lsl #3
 8003378:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800337a:	429c      	cmp	r4, r3
      for (j = 0; j < q; j++)
 800337c:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003380:	bf19      	ittee	ne
 8003382:	4630      	movne	r0, r6
 8003384:	4639      	movne	r1, r7
 8003386:	4640      	moveq	r0, r8
 8003388:	4649      	moveq	r1, r9
      for (j = 0; j < q; j++)
 800338a:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800338c:	e8e2 0102 	strd	r0, r1, [r2], #8
      for (j = 0; j < q; j++)
 8003390:	d1f3      	bne.n	800337a <gsl_matrix_long_double_set_identity+0x2e>
  for (i = 0; i < p; i++)
 8003392:	3401      	adds	r4, #1
 8003394:	45a6      	cmp	lr, r4
 8003396:	44d4      	add	ip, sl
 8003398:	d1eb      	bne.n	8003372 <gsl_matrix_long_double_set_identity+0x26>
}
 800339a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800339e:	bf00      	nop
 80033a0:	3ff00000 	.word	0x3ff00000

080033a4 <gsl_matrix_long_double_set_zero>:
  const size_t p = m->size1 ;
 80033a4:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 80033a8:	68c2      	ldr	r2, [r0, #12]
{
 80033aa:	b4f0      	push	{r4, r5, r6, r7}
  const size_t tda = m->tda ;
 80033ac:	e9d0 5701 	ldrd	r5, r7, [r0, #4]
  for (i = 0; i < p; i++)
 80033b0:	f1bc 0f00 	cmp.w	ip, #0
 80033b4:	d012      	beq.n	80033dc <gsl_matrix_long_double_set_zero+0x38>
 80033b6:	ebc5 7645 	rsb	r6, r5, r5, lsl #29
 80033ba:	00ff      	lsls	r7, r7, #3
 80033bc:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 80033c0:	00f6      	lsls	r6, r6, #3
 80033c2:	2400      	movs	r4, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80033c4:	2000      	movs	r0, #0
 80033c6:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 80033c8:	1993      	adds	r3, r2, r6
 80033ca:	b11d      	cbz	r5, 80033d4 <gsl_matrix_long_double_set_zero+0x30>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80033cc:	e8e3 0102 	strd	r0, r1, [r3], #8
      for (j = 0; j < q; j++)
 80033d0:	4293      	cmp	r3, r2
 80033d2:	d1fb      	bne.n	80033cc <gsl_matrix_long_double_set_zero+0x28>
  for (i = 0; i < p; i++)
 80033d4:	3401      	adds	r4, #1
 80033d6:	45a4      	cmp	ip, r4
 80033d8:	443a      	add	r2, r7
 80033da:	d1f5      	bne.n	80033c8 <gsl_matrix_long_double_set_zero+0x24>
}
 80033dc:	bcf0      	pop	{r4, r5, r6, r7}
 80033de:	4770      	bx	lr

080033e0 <gsl_matrix_long_double_set_all>:
{
 80033e0:	b470      	push	{r4, r5, r6}
  const size_t p = m->size1 ;
 80033e2:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80033e4:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80033e6:	e9d0 4501 	ldrd	r4, r5, [r0, #4]
  for (i = 0; i < p; i++)
 80033ea:	b186      	cbz	r6, 800340e <gsl_matrix_long_double_set_all+0x2e>
 80033ec:	ebc4 7044 	rsb	r0, r4, r4, lsl #29
 80033f0:	00ed      	lsls	r5, r5, #3
 80033f2:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80033f6:	00c0      	lsls	r0, r0, #3
 80033f8:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 80033fa:	1813      	adds	r3, r2, r0
 80033fc:	b11c      	cbz	r4, 8003406 <gsl_matrix_long_double_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 80033fe:	eca3 0b02 	vstmia	r3!, {d0}
      for (j = 0; j < q; j++)
 8003402:	4293      	cmp	r3, r2
 8003404:	d1fb      	bne.n	80033fe <gsl_matrix_long_double_set_all+0x1e>
  for (i = 0; i < p; i++)
 8003406:	3101      	adds	r1, #1
 8003408:	428e      	cmp	r6, r1
 800340a:	442a      	add	r2, r5
 800340c:	d1f5      	bne.n	80033fa <gsl_matrix_long_double_set_all+0x1a>
}
 800340e:	bc70      	pop	{r4, r5, r6}
 8003410:	4770      	bx	lr
 8003412:	bf00      	nop

08003414 <gsl_matrix_alloc>:
{
 8003414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003416:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003418:	2018      	movs	r0, #24
{
 800341a:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800341c:	f02c fe42 	bl	80300a4 <malloc>
  if (m == 0)
 8003420:	4604      	mov	r4, r0
 8003422:	b1b8      	cbz	r0, 8003454 <gsl_matrix_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8003424:	fb06 f007 	mul.w	r0, r6, r7
 8003428:	f004 fa54 	bl	80078d4 <gsl_block_alloc>
  if (block == 0)
 800342c:	4605      	mov	r5, r0
 800342e:	b148      	cbz	r0, 8003444 <gsl_matrix_alloc+0x30>
  m->data = block->data;
 8003430:	6843      	ldr	r3, [r0, #4]
 8003432:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8003434:	2301      	movs	r3, #1
  m->size2 = n2;
 8003436:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 800343a:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 800343e:	60a6      	str	r6, [r4, #8]
}
 8003440:	4620      	mov	r0, r4
 8003442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8003444:	4907      	ldr	r1, [pc, #28]	; (8003464 <gsl_matrix_alloc+0x50>)
 8003446:	4808      	ldr	r0, [pc, #32]	; (8003468 <gsl_matrix_alloc+0x54>)
 8003448:	2308      	movs	r3, #8
 800344a:	2228      	movs	r2, #40	; 0x28
 800344c:	462c      	mov	r4, r5
 800344e:	f7ff fa07 	bl	8002860 <gsl_error>
 8003452:	e7f5      	b.n	8003440 <gsl_matrix_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003454:	4903      	ldr	r1, [pc, #12]	; (8003464 <gsl_matrix_alloc+0x50>)
 8003456:	4805      	ldr	r0, [pc, #20]	; (800346c <gsl_matrix_alloc+0x58>)
 8003458:	2308      	movs	r3, #8
 800345a:	221e      	movs	r2, #30
 800345c:	f7ff fa00 	bl	8002860 <gsl_error>
 8003460:	e7ee      	b.n	8003440 <gsl_matrix_alloc+0x2c>
 8003462:	bf00      	nop
 8003464:	08030f9c 	.word	0x08030f9c
 8003468:	08030fd8 	.word	0x08030fd8
 800346c:	08030fac 	.word	0x08030fac

08003470 <gsl_matrix_calloc>:
{
 8003470:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003472:	4604      	mov	r4, r0
 8003474:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8003476:	f7ff ffcd 	bl	8003414 <gsl_matrix_alloc>
  if (m == 0)
 800347a:	4605      	mov	r5, r0
 800347c:	b180      	cbz	r0, 80034a0 <gsl_matrix_calloc+0x30>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 800347e:	fb06 f604 	mul.w	r6, r6, r4
 8003482:	00f4      	lsls	r4, r6, #3
 8003484:	68c0      	ldr	r0, [r0, #12]
 8003486:	4622      	mov	r2, r4
 8003488:	2100      	movs	r1, #0
 800348a:	f02c fe1b 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 800348e:	b13e      	cbz	r6, 80034a0 <gsl_matrix_calloc+0x30>
 8003490:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 8003492:	2600      	movs	r6, #0
 8003494:	2700      	movs	r7, #0
 8003496:	18e2      	adds	r2, r4, r3
 8003498:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 800349c:	4293      	cmp	r3, r2
 800349e:	d1fb      	bne.n	8003498 <gsl_matrix_calloc+0x28>
}
 80034a0:	4628      	mov	r0, r5
 80034a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080034a4 <gsl_matrix_alloc_from_block>:
{
 80034a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80034a8:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 80034ac:	4599      	cmp	r9, r3
 80034ae:	d325      	bcc.n	80034fc <gsl_matrix_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 80034b0:	4690      	mov	r8, r2
 80034b2:	6802      	ldr	r2, [r0, #0]
 80034b4:	461e      	mov	r6, r3
 80034b6:	fb08 1309 	mla	r3, r8, r9, r1
 80034ba:	429a      	cmp	r2, r3
 80034bc:	4605      	mov	r5, r0
 80034be:	460f      	mov	r7, r1
 80034c0:	d312      	bcc.n	80034e8 <gsl_matrix_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80034c2:	2018      	movs	r0, #24
 80034c4:	f02c fdee 	bl	80300a4 <malloc>
  if (m == 0)
 80034c8:	4604      	mov	r4, r0
 80034ca:	b1f8      	cbz	r0, 800350c <gsl_matrix_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 80034cc:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 80034ce:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 80034d2:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
  m->tda = d2;
 80034d6:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80034da:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80034de:	2300      	movs	r3, #0
 80034e0:	6143      	str	r3, [r0, #20]
}
 80034e2:	4620      	mov	r0, r4
 80034e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 80034e8:	490c      	ldr	r1, [pc, #48]	; (800351c <gsl_matrix_alloc_from_block+0x78>)
 80034ea:	480d      	ldr	r0, [pc, #52]	; (8003520 <gsl_matrix_alloc_from_block+0x7c>)
 80034ec:	2304      	movs	r3, #4
 80034ee:	225b      	movs	r2, #91	; 0x5b
 80034f0:	2400      	movs	r4, #0
 80034f2:	f7ff f9b5 	bl	8002860 <gsl_error>
}
 80034f6:	4620      	mov	r0, r4
 80034f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 80034fc:	4907      	ldr	r1, [pc, #28]	; (800351c <gsl_matrix_alloc_from_block+0x78>)
 80034fe:	4809      	ldr	r0, [pc, #36]	; (8003524 <gsl_matrix_alloc_from_block+0x80>)
 8003500:	2304      	movs	r3, #4
 8003502:	2256      	movs	r2, #86	; 0x56
 8003504:	f7ff f9ac 	bl	8002860 <gsl_error>
 8003508:	2400      	movs	r4, #0
 800350a:	e7ea      	b.n	80034e2 <gsl_matrix_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800350c:	4903      	ldr	r1, [pc, #12]	; (800351c <gsl_matrix_alloc_from_block+0x78>)
 800350e:	4806      	ldr	r0, [pc, #24]	; (8003528 <gsl_matrix_alloc_from_block+0x84>)
 8003510:	2308      	movs	r3, #8
 8003512:	2263      	movs	r2, #99	; 0x63
 8003514:	f7ff f9a4 	bl	8002860 <gsl_error>
 8003518:	e7e3      	b.n	80034e2 <gsl_matrix_alloc_from_block+0x3e>
 800351a:	bf00      	nop
 800351c:	08030f9c 	.word	0x08030f9c
 8003520:	08031028 	.word	0x08031028
 8003524:	08030ffc 	.word	0x08030ffc
 8003528:	08030fac 	.word	0x08030fac

0800352c <gsl_matrix_alloc_from_matrix>:
{
 800352c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003530:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003532:	6803      	ldr	r3, [r0, #0]
{
 8003534:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003538:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 800353a:	19c8      	adds	r0, r1, r7
 800353c:	4298      	cmp	r0, r3
 800353e:	d826      	bhi.n	800358e <gsl_matrix_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003540:	686b      	ldr	r3, [r5, #4]
 8003542:	4690      	mov	r8, r2
 8003544:	444a      	add	r2, r9
 8003546:	429a      	cmp	r2, r3
 8003548:	d817      	bhi.n	800357a <gsl_matrix_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800354a:	2018      	movs	r0, #24
 800354c:	460e      	mov	r6, r1
 800354e:	f02c fda9 	bl	80300a4 <malloc>
  if (m == 0)
 8003552:	4604      	mov	r4, r0
 8003554:	b318      	cbz	r0, 800359e <gsl_matrix_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003556:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003558:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 800355a:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 800355e:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003562:	fb06 8603 	mla	r6, r6, r3, r8
 8003566:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 800356a:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 800356c:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003570:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003574:	4620      	mov	r0, r4
 8003576:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 800357a:	490c      	ldr	r1, [pc, #48]	; (80035ac <gsl_matrix_alloc_from_matrix+0x80>)
 800357c:	480c      	ldr	r0, [pc, #48]	; (80035b0 <gsl_matrix_alloc_from_matrix+0x84>)
 800357e:	2304      	movs	r3, #4
 8003580:	2282      	movs	r2, #130	; 0x82
 8003582:	2400      	movs	r4, #0
 8003584:	f7ff f96c 	bl	8002860 <gsl_error>
}
 8003588:	4620      	mov	r0, r4
 800358a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 800358e:	4907      	ldr	r1, [pc, #28]	; (80035ac <gsl_matrix_alloc_from_matrix+0x80>)
 8003590:	4808      	ldr	r0, [pc, #32]	; (80035b4 <gsl_matrix_alloc_from_matrix+0x88>)
 8003592:	2304      	movs	r3, #4
 8003594:	227d      	movs	r2, #125	; 0x7d
 8003596:	f7ff f963 	bl	8002860 <gsl_error>
 800359a:	2400      	movs	r4, #0
 800359c:	e7ea      	b.n	8003574 <gsl_matrix_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800359e:	4903      	ldr	r1, [pc, #12]	; (80035ac <gsl_matrix_alloc_from_matrix+0x80>)
 80035a0:	4805      	ldr	r0, [pc, #20]	; (80035b8 <gsl_matrix_alloc_from_matrix+0x8c>)
 80035a2:	2308      	movs	r3, #8
 80035a4:	228a      	movs	r2, #138	; 0x8a
 80035a6:	f7ff f95b 	bl	8002860 <gsl_error>
 80035aa:	e7e3      	b.n	8003574 <gsl_matrix_alloc_from_matrix+0x48>
 80035ac:	08030f9c 	.word	0x08030f9c
 80035b0:	08031084 	.word	0x08031084
 80035b4:	08031054 	.word	0x08031054
 80035b8:	08030fac 	.word	0x08030fac

080035bc <gsl_matrix_free>:
  RETURN_IF_NULL (m);
 80035bc:	b180      	cbz	r0, 80035e0 <gsl_matrix_free+0x24>
  if (m->owner)
 80035be:	6943      	ldr	r3, [r0, #20]
{
 80035c0:	b510      	push	{r4, lr}
 80035c2:	4604      	mov	r4, r0
  if (m->owner)
 80035c4:	b923      	cbnz	r3, 80035d0 <gsl_matrix_free+0x14>
  free (m);
 80035c6:	4620      	mov	r0, r4
}
 80035c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80035cc:	f02c bd72 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 80035d0:	6900      	ldr	r0, [r0, #16]
 80035d2:	f004 f9c1 	bl	8007958 <gsl_block_free>
  free (m);
 80035d6:	4620      	mov	r0, r4
}
 80035d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80035dc:	f02c bd6a 	b.w	80300b4 <free>
 80035e0:	4770      	bx	lr
 80035e2:	bf00      	nop

080035e4 <gsl_matrix_set_identity>:
{
 80035e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const size_t p = m->size1 ;
 80035e8:	f8d0 e000 	ldr.w	lr, [r0]
  const size_t tda = m->tda ;
 80035ec:	1d05      	adds	r5, r0, #4
 80035ee:	e895 0c20 	ldmia.w	r5, {r5, sl, fp}
  for (i = 0; i < p; i++)
 80035f2:	f1be 0f00 	cmp.w	lr, #0
 80035f6:	d01c      	beq.n	8003632 <gsl_matrix_set_identity+0x4e>
 80035f8:	f04f 0c00 	mov.w	ip, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80035fc:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8003638 <gsl_matrix_set_identity+0x54>
 8003600:	f04f 0800 	mov.w	r8, #0
 8003604:	2600      	movs	r6, #0
 8003606:	2700      	movs	r7, #0
  for (i = 0; i < p; i++)
 8003608:	4664      	mov	r4, ip
      for (j = 0; j < q; j++)
 800360a:	b175      	cbz	r5, 800362a <gsl_matrix_set_identity+0x46>
 800360c:	eb0b 02cc 	add.w	r2, fp, ip, lsl #3
 8003610:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003612:	429c      	cmp	r4, r3
      for (j = 0; j < q; j++)
 8003614:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003618:	bf19      	ittee	ne
 800361a:	4630      	movne	r0, r6
 800361c:	4639      	movne	r1, r7
 800361e:	4640      	moveq	r0, r8
 8003620:	4649      	moveq	r1, r9
      for (j = 0; j < q; j++)
 8003622:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003624:	e8e2 0102 	strd	r0, r1, [r2], #8
      for (j = 0; j < q; j++)
 8003628:	d1f3      	bne.n	8003612 <gsl_matrix_set_identity+0x2e>
  for (i = 0; i < p; i++)
 800362a:	3401      	adds	r4, #1
 800362c:	45a6      	cmp	lr, r4
 800362e:	44d4      	add	ip, sl
 8003630:	d1eb      	bne.n	800360a <gsl_matrix_set_identity+0x26>
}
 8003632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003636:	bf00      	nop
 8003638:	3ff00000 	.word	0x3ff00000

0800363c <gsl_matrix_set_zero>:
  const size_t p = m->size1 ;
 800363c:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 8003640:	68c2      	ldr	r2, [r0, #12]
{
 8003642:	b4f0      	push	{r4, r5, r6, r7}
  const size_t tda = m->tda ;
 8003644:	e9d0 5701 	ldrd	r5, r7, [r0, #4]
  for (i = 0; i < p; i++)
 8003648:	f1bc 0f00 	cmp.w	ip, #0
 800364c:	d012      	beq.n	8003674 <gsl_matrix_set_zero+0x38>
 800364e:	ebc5 7645 	rsb	r6, r5, r5, lsl #29
 8003652:	00ff      	lsls	r7, r7, #3
 8003654:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 8003658:	00f6      	lsls	r6, r6, #3
 800365a:	2400      	movs	r4, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800365c:	2000      	movs	r0, #0
 800365e:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8003660:	1993      	adds	r3, r2, r6
 8003662:	b11d      	cbz	r5, 800366c <gsl_matrix_set_zero+0x30>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003664:	e8e3 0102 	strd	r0, r1, [r3], #8
      for (j = 0; j < q; j++)
 8003668:	4293      	cmp	r3, r2
 800366a:	d1fb      	bne.n	8003664 <gsl_matrix_set_zero+0x28>
  for (i = 0; i < p; i++)
 800366c:	3401      	adds	r4, #1
 800366e:	45a4      	cmp	ip, r4
 8003670:	443a      	add	r2, r7
 8003672:	d1f5      	bne.n	8003660 <gsl_matrix_set_zero+0x24>
}
 8003674:	bcf0      	pop	{r4, r5, r6, r7}
 8003676:	4770      	bx	lr

08003678 <gsl_matrix_set_all>:
{
 8003678:	b470      	push	{r4, r5, r6}
  const size_t p = m->size1 ;
 800367a:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 800367c:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800367e:	e9d0 4501 	ldrd	r4, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8003682:	b186      	cbz	r6, 80036a6 <gsl_matrix_set_all+0x2e>
 8003684:	ebc4 7044 	rsb	r0, r4, r4, lsl #29
 8003688:	00ed      	lsls	r5, r5, #3
 800368a:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 800368e:	00c0      	lsls	r0, r0, #3
 8003690:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8003692:	1813      	adds	r3, r2, r0
 8003694:	b11c      	cbz	r4, 800369e <gsl_matrix_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003696:	eca3 0b02 	vstmia	r3!, {d0}
      for (j = 0; j < q; j++)
 800369a:	4293      	cmp	r3, r2
 800369c:	d1fb      	bne.n	8003696 <gsl_matrix_set_all+0x1e>
  for (i = 0; i < p; i++)
 800369e:	3101      	adds	r1, #1
 80036a0:	428e      	cmp	r6, r1
 80036a2:	442a      	add	r2, r5
 80036a4:	d1f5      	bne.n	8003692 <gsl_matrix_set_all+0x1a>
}
 80036a6:	bc70      	pop	{r4, r5, r6}
 80036a8:	4770      	bx	lr
 80036aa:	bf00      	nop

080036ac <gsl_matrix_float_alloc>:
{
 80036ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036ae:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80036b0:	2018      	movs	r0, #24
{
 80036b2:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80036b4:	f02c fcf6 	bl	80300a4 <malloc>
  if (m == 0)
 80036b8:	4604      	mov	r4, r0
 80036ba:	b1b8      	cbz	r0, 80036ec <gsl_matrix_float_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 80036bc:	fb06 f007 	mul.w	r0, r6, r7
 80036c0:	f004 f956 	bl	8007970 <gsl_block_float_alloc>
  if (block == 0)
 80036c4:	4605      	mov	r5, r0
 80036c6:	b148      	cbz	r0, 80036dc <gsl_matrix_float_alloc+0x30>
  m->data = block->data;
 80036c8:	6843      	ldr	r3, [r0, #4]
 80036ca:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 80036cc:	2301      	movs	r3, #1
  m->size2 = n2;
 80036ce:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 80036d2:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 80036d6:	60a6      	str	r6, [r4, #8]
}
 80036d8:	4620      	mov	r0, r4
 80036da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80036dc:	4907      	ldr	r1, [pc, #28]	; (80036fc <gsl_matrix_float_alloc+0x50>)
 80036de:	4808      	ldr	r0, [pc, #32]	; (8003700 <gsl_matrix_float_alloc+0x54>)
 80036e0:	2308      	movs	r3, #8
 80036e2:	2228      	movs	r2, #40	; 0x28
 80036e4:	462c      	mov	r4, r5
 80036e6:	f7ff f8bb 	bl	8002860 <gsl_error>
 80036ea:	e7f5      	b.n	80036d8 <gsl_matrix_float_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80036ec:	4903      	ldr	r1, [pc, #12]	; (80036fc <gsl_matrix_float_alloc+0x50>)
 80036ee:	4805      	ldr	r0, [pc, #20]	; (8003704 <gsl_matrix_float_alloc+0x58>)
 80036f0:	2308      	movs	r3, #8
 80036f2:	221e      	movs	r2, #30
 80036f4:	f7ff f8b4 	bl	8002860 <gsl_error>
 80036f8:	e7ee      	b.n	80036d8 <gsl_matrix_float_alloc+0x2c>
 80036fa:	bf00      	nop
 80036fc:	08030f9c 	.word	0x08030f9c
 8003700:	08030fd8 	.word	0x08030fd8
 8003704:	08030fac 	.word	0x08030fac

08003708 <gsl_matrix_float_calloc>:
{
 8003708:	b570      	push	{r4, r5, r6, lr}
 800370a:	4604      	mov	r4, r0
 800370c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 800370e:	f7ff ffcd 	bl	80036ac <gsl_matrix_float_alloc>
  if (m == 0)
 8003712:	4605      	mov	r5, r0
 8003714:	b178      	cbz	r0, 8003736 <gsl_matrix_float_calloc+0x2e>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003716:	fb06 f604 	mul.w	r6, r6, r4
 800371a:	00b4      	lsls	r4, r6, #2
 800371c:	68c0      	ldr	r0, [r0, #12]
 800371e:	4622      	mov	r2, r4
 8003720:	2100      	movs	r1, #0
 8003722:	f02c fccf 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003726:	b136      	cbz	r6, 8003736 <gsl_matrix_float_calloc+0x2e>
 8003728:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 800372a:	2100      	movs	r1, #0
 800372c:	18e2      	adds	r2, r4, r3
 800372e:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003732:	4293      	cmp	r3, r2
 8003734:	d1fb      	bne.n	800372e <gsl_matrix_float_calloc+0x26>
}
 8003736:	4628      	mov	r0, r5
 8003738:	bd70      	pop	{r4, r5, r6, pc}
 800373a:	bf00      	nop

0800373c <gsl_matrix_float_alloc_from_block>:
{
 800373c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003740:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003744:	4599      	cmp	r9, r3
 8003746:	d325      	bcc.n	8003794 <gsl_matrix_float_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003748:	4690      	mov	r8, r2
 800374a:	6802      	ldr	r2, [r0, #0]
 800374c:	461e      	mov	r6, r3
 800374e:	fb08 1309 	mla	r3, r8, r9, r1
 8003752:	429a      	cmp	r2, r3
 8003754:	4605      	mov	r5, r0
 8003756:	460f      	mov	r7, r1
 8003758:	d312      	bcc.n	8003780 <gsl_matrix_float_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800375a:	2018      	movs	r0, #24
 800375c:	f02c fca2 	bl	80300a4 <malloc>
  if (m == 0)
 8003760:	4604      	mov	r4, r0
 8003762:	b1f8      	cbz	r0, 80037a4 <gsl_matrix_float_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003764:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003766:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800376a:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 800376e:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003772:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003776:	2300      	movs	r3, #0
 8003778:	6143      	str	r3, [r0, #20]
}
 800377a:	4620      	mov	r0, r4
 800377c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003780:	490c      	ldr	r1, [pc, #48]	; (80037b4 <gsl_matrix_float_alloc_from_block+0x78>)
 8003782:	480d      	ldr	r0, [pc, #52]	; (80037b8 <gsl_matrix_float_alloc_from_block+0x7c>)
 8003784:	2304      	movs	r3, #4
 8003786:	225b      	movs	r2, #91	; 0x5b
 8003788:	2400      	movs	r4, #0
 800378a:	f7ff f869 	bl	8002860 <gsl_error>
}
 800378e:	4620      	mov	r0, r4
 8003790:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003794:	4907      	ldr	r1, [pc, #28]	; (80037b4 <gsl_matrix_float_alloc_from_block+0x78>)
 8003796:	4809      	ldr	r0, [pc, #36]	; (80037bc <gsl_matrix_float_alloc_from_block+0x80>)
 8003798:	2304      	movs	r3, #4
 800379a:	2256      	movs	r2, #86	; 0x56
 800379c:	f7ff f860 	bl	8002860 <gsl_error>
 80037a0:	2400      	movs	r4, #0
 80037a2:	e7ea      	b.n	800377a <gsl_matrix_float_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80037a4:	4903      	ldr	r1, [pc, #12]	; (80037b4 <gsl_matrix_float_alloc_from_block+0x78>)
 80037a6:	4806      	ldr	r0, [pc, #24]	; (80037c0 <gsl_matrix_float_alloc_from_block+0x84>)
 80037a8:	2308      	movs	r3, #8
 80037aa:	2263      	movs	r2, #99	; 0x63
 80037ac:	f7ff f858 	bl	8002860 <gsl_error>
 80037b0:	e7e3      	b.n	800377a <gsl_matrix_float_alloc_from_block+0x3e>
 80037b2:	bf00      	nop
 80037b4:	08030f9c 	.word	0x08030f9c
 80037b8:	08031028 	.word	0x08031028
 80037bc:	08030ffc 	.word	0x08030ffc
 80037c0:	08030fac 	.word	0x08030fac

080037c4 <gsl_matrix_float_alloc_from_matrix>:
{
 80037c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80037c8:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 80037ca:	6803      	ldr	r3, [r0, #0]
{
 80037cc:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80037d0:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 80037d2:	19c8      	adds	r0, r1, r7
 80037d4:	4298      	cmp	r0, r3
 80037d6:	d826      	bhi.n	8003826 <gsl_matrix_float_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80037d8:	686b      	ldr	r3, [r5, #4]
 80037da:	4690      	mov	r8, r2
 80037dc:	444a      	add	r2, r9
 80037de:	429a      	cmp	r2, r3
 80037e0:	d817      	bhi.n	8003812 <gsl_matrix_float_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80037e2:	2018      	movs	r0, #24
 80037e4:	460e      	mov	r6, r1
 80037e6:	f02c fc5d 	bl	80300a4 <malloc>
  if (m == 0)
 80037ea:	4604      	mov	r4, r0
 80037ec:	b318      	cbz	r0, 8003836 <gsl_matrix_float_alloc_from_matrix+0x72>
  m->size1 = n1;
 80037ee:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80037f0:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80037f2:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80037f6:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80037fa:	fb06 8603 	mla	r6, r6, r3, r8
 80037fe:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003802:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003804:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003808:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 800380c:	4620      	mov	r0, r4
 800380e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003812:	490c      	ldr	r1, [pc, #48]	; (8003844 <gsl_matrix_float_alloc_from_matrix+0x80>)
 8003814:	480c      	ldr	r0, [pc, #48]	; (8003848 <gsl_matrix_float_alloc_from_matrix+0x84>)
 8003816:	2304      	movs	r3, #4
 8003818:	2282      	movs	r2, #130	; 0x82
 800381a:	2400      	movs	r4, #0
 800381c:	f7ff f820 	bl	8002860 <gsl_error>
}
 8003820:	4620      	mov	r0, r4
 8003822:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003826:	4907      	ldr	r1, [pc, #28]	; (8003844 <gsl_matrix_float_alloc_from_matrix+0x80>)
 8003828:	4808      	ldr	r0, [pc, #32]	; (800384c <gsl_matrix_float_alloc_from_matrix+0x88>)
 800382a:	2304      	movs	r3, #4
 800382c:	227d      	movs	r2, #125	; 0x7d
 800382e:	f7ff f817 	bl	8002860 <gsl_error>
 8003832:	2400      	movs	r4, #0
 8003834:	e7ea      	b.n	800380c <gsl_matrix_float_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003836:	4903      	ldr	r1, [pc, #12]	; (8003844 <gsl_matrix_float_alloc_from_matrix+0x80>)
 8003838:	4805      	ldr	r0, [pc, #20]	; (8003850 <gsl_matrix_float_alloc_from_matrix+0x8c>)
 800383a:	2308      	movs	r3, #8
 800383c:	228a      	movs	r2, #138	; 0x8a
 800383e:	f7ff f80f 	bl	8002860 <gsl_error>
 8003842:	e7e3      	b.n	800380c <gsl_matrix_float_alloc_from_matrix+0x48>
 8003844:	08030f9c 	.word	0x08030f9c
 8003848:	08031084 	.word	0x08031084
 800384c:	08031054 	.word	0x08031054
 8003850:	08030fac 	.word	0x08030fac

08003854 <gsl_matrix_float_free>:
  RETURN_IF_NULL (m);
 8003854:	b180      	cbz	r0, 8003878 <gsl_matrix_float_free+0x24>
  if (m->owner)
 8003856:	6943      	ldr	r3, [r0, #20]
{
 8003858:	b510      	push	{r4, lr}
 800385a:	4604      	mov	r4, r0
  if (m->owner)
 800385c:	b923      	cbnz	r3, 8003868 <gsl_matrix_float_free+0x14>
  free (m);
 800385e:	4620      	mov	r0, r4
}
 8003860:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003864:	f02c bc26 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003868:	6900      	ldr	r0, [r0, #16]
 800386a:	f004 f8c1 	bl	80079f0 <gsl_block_float_free>
  free (m);
 800386e:	4620      	mov	r0, r4
}
 8003870:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003874:	f02c bc1e 	b.w	80300b4 <free>
 8003878:	4770      	bx	lr
 800387a:	bf00      	nop

0800387c <gsl_matrix_float_set_identity>:
{
 800387c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800387e:	6805      	ldr	r5, [r0, #0]
  const size_t tda = m->tda ;
 8003880:	1d04      	adds	r4, r0, #4
 8003882:	ccd0      	ldmia	r4, {r4, r6, r7}
  for (i = 0; i < p; i++)
 8003884:	b1cd      	cbz	r5, 80038ba <gsl_matrix_float_set_identity+0x3e>
 8003886:	2000      	movs	r0, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003888:	eddf 6a0d 	vldr	s13, [pc, #52]	; 80038c0 <gsl_matrix_float_set_identity+0x44>
  for (i = 0; i < p; i++)
 800388c:	4601      	mov	r1, r0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800388e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
      for (j = 0; j < q; j++)
 8003892:	b174      	cbz	r4, 80038b2 <gsl_matrix_float_set_identity+0x36>
 8003894:	eb07 0280 	add.w	r2, r7, r0, lsl #2
 8003898:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800389a:	4299      	cmp	r1, r3
      for (j = 0; j < q; j++)
 800389c:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80038a0:	bf14      	ite	ne
 80038a2:	eef0 7a66 	vmovne.f32	s15, s13
 80038a6:	eef0 7a47 	vmoveq.f32	s15, s14
      for (j = 0; j < q; j++)
 80038aa:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80038ac:	ece2 7a01 	vstmia	r2!, {s15}
      for (j = 0; j < q; j++)
 80038b0:	d1f3      	bne.n	800389a <gsl_matrix_float_set_identity+0x1e>
  for (i = 0; i < p; i++)
 80038b2:	3101      	adds	r1, #1
 80038b4:	428d      	cmp	r5, r1
 80038b6:	4430      	add	r0, r6
 80038b8:	d1eb      	bne.n	8003892 <gsl_matrix_float_set_identity+0x16>
}
 80038ba:	bcf0      	pop	{r4, r5, r6, r7}
 80038bc:	4770      	bx	lr
 80038be:	bf00      	nop
 80038c0:	00000000 	.word	0x00000000

080038c4 <gsl_matrix_float_set_zero>:
{
 80038c4:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80038c6:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80038c8:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80038ca:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 80038ce:	b18f      	cbz	r7, 80038f4 <gsl_matrix_float_set_zero+0x30>
 80038d0:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 80038d4:	00b6      	lsls	r6, r6, #2
 80038d6:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80038da:	00ad      	lsls	r5, r5, #2
 80038dc:	2000      	movs	r0, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80038de:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 80038e0:	1953      	adds	r3, r2, r5
 80038e2:	b11c      	cbz	r4, 80038ec <gsl_matrix_float_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80038e4:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 80038e8:	4293      	cmp	r3, r2
 80038ea:	d1fb      	bne.n	80038e4 <gsl_matrix_float_set_zero+0x20>
  for (i = 0; i < p; i++)
 80038ec:	3001      	adds	r0, #1
 80038ee:	4287      	cmp	r7, r0
 80038f0:	4432      	add	r2, r6
 80038f2:	d1f5      	bne.n	80038e0 <gsl_matrix_float_set_zero+0x1c>
}
 80038f4:	bcf0      	pop	{r4, r5, r6, r7}
 80038f6:	4770      	bx	lr

080038f8 <gsl_matrix_float_set_all>:
{
 80038f8:	b470      	push	{r4, r5, r6}
  const size_t p = m->size1 ;
 80038fa:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80038fc:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80038fe:	e9d0 4501 	ldrd	r4, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8003902:	b186      	cbz	r6, 8003926 <gsl_matrix_float_set_all+0x2e>
 8003904:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 8003908:	00ad      	lsls	r5, r5, #2
 800390a:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 800390e:	0080      	lsls	r0, r0, #2
 8003910:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8003912:	1813      	adds	r3, r2, r0
 8003914:	b11c      	cbz	r4, 800391e <gsl_matrix_float_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003916:	eca3 0a01 	vstmia	r3!, {s0}
      for (j = 0; j < q; j++)
 800391a:	4293      	cmp	r3, r2
 800391c:	d1fb      	bne.n	8003916 <gsl_matrix_float_set_all+0x1e>
  for (i = 0; i < p; i++)
 800391e:	3101      	adds	r1, #1
 8003920:	428e      	cmp	r6, r1
 8003922:	442a      	add	r2, r5
 8003924:	d1f5      	bne.n	8003912 <gsl_matrix_float_set_all+0x1a>
}
 8003926:	bc70      	pop	{r4, r5, r6}
 8003928:	4770      	bx	lr
 800392a:	bf00      	nop

0800392c <gsl_matrix_ulong_alloc>:
{
 800392c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800392e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003930:	2018      	movs	r0, #24
{
 8003932:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003934:	f02c fbb6 	bl	80300a4 <malloc>
  if (m == 0)
 8003938:	4604      	mov	r4, r0
 800393a:	b1b8      	cbz	r0, 800396c <gsl_matrix_ulong_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800393c:	fb06 f007 	mul.w	r0, r6, r7
 8003940:	f004 f862 	bl	8007a08 <gsl_block_ulong_alloc>
  if (block == 0)
 8003944:	4605      	mov	r5, r0
 8003946:	b148      	cbz	r0, 800395c <gsl_matrix_ulong_alloc+0x30>
  m->data = block->data;
 8003948:	6843      	ldr	r3, [r0, #4]
 800394a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 800394c:	2301      	movs	r3, #1
  m->size2 = n2;
 800394e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8003952:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8003956:	60a6      	str	r6, [r4, #8]
}
 8003958:	4620      	mov	r0, r4
 800395a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 800395c:	4907      	ldr	r1, [pc, #28]	; (800397c <gsl_matrix_ulong_alloc+0x50>)
 800395e:	4808      	ldr	r0, [pc, #32]	; (8003980 <gsl_matrix_ulong_alloc+0x54>)
 8003960:	2308      	movs	r3, #8
 8003962:	2228      	movs	r2, #40	; 0x28
 8003964:	462c      	mov	r4, r5
 8003966:	f7fe ff7b 	bl	8002860 <gsl_error>
 800396a:	e7f5      	b.n	8003958 <gsl_matrix_ulong_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800396c:	4903      	ldr	r1, [pc, #12]	; (800397c <gsl_matrix_ulong_alloc+0x50>)
 800396e:	4805      	ldr	r0, [pc, #20]	; (8003984 <gsl_matrix_ulong_alloc+0x58>)
 8003970:	2308      	movs	r3, #8
 8003972:	221e      	movs	r2, #30
 8003974:	f7fe ff74 	bl	8002860 <gsl_error>
 8003978:	e7ee      	b.n	8003958 <gsl_matrix_ulong_alloc+0x2c>
 800397a:	bf00      	nop
 800397c:	08030f9c 	.word	0x08030f9c
 8003980:	08030fd8 	.word	0x08030fd8
 8003984:	08030fac 	.word	0x08030fac

08003988 <gsl_matrix_ulong_calloc>:
{
 8003988:	b570      	push	{r4, r5, r6, lr}
 800398a:	4604      	mov	r4, r0
 800398c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 800398e:	f7ff ffcd 	bl	800392c <gsl_matrix_ulong_alloc>
  if (m == 0)
 8003992:	4605      	mov	r5, r0
 8003994:	b188      	cbz	r0, 80039ba <gsl_matrix_ulong_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003996:	fb06 f604 	mul.w	r6, r6, r4
 800399a:	00b4      	lsls	r4, r6, #2
 800399c:	68c0      	ldr	r0, [r0, #12]
 800399e:	4622      	mov	r2, r4
 80039a0:	2100      	movs	r1, #0
 80039a2:	f02c fb8f 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80039a6:	b146      	cbz	r6, 80039ba <gsl_matrix_ulong_calloc+0x32>
      m->data[i] = 0;
 80039a8:	68eb      	ldr	r3, [r5, #12]
 80039aa:	1f22      	subs	r2, r4, #4
 80039ac:	441a      	add	r2, r3
 80039ae:	2100      	movs	r1, #0
 80039b0:	3b04      	subs	r3, #4
 80039b2:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80039b6:	4293      	cmp	r3, r2
 80039b8:	d1fb      	bne.n	80039b2 <gsl_matrix_ulong_calloc+0x2a>
}
 80039ba:	4628      	mov	r0, r5
 80039bc:	bd70      	pop	{r4, r5, r6, pc}
 80039be:	bf00      	nop

080039c0 <gsl_matrix_ulong_alloc_from_block>:
{
 80039c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80039c4:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 80039c8:	4599      	cmp	r9, r3
 80039ca:	d325      	bcc.n	8003a18 <gsl_matrix_ulong_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 80039cc:	4690      	mov	r8, r2
 80039ce:	6802      	ldr	r2, [r0, #0]
 80039d0:	461e      	mov	r6, r3
 80039d2:	fb08 1309 	mla	r3, r8, r9, r1
 80039d6:	429a      	cmp	r2, r3
 80039d8:	4605      	mov	r5, r0
 80039da:	460f      	mov	r7, r1
 80039dc:	d312      	bcc.n	8003a04 <gsl_matrix_ulong_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80039de:	2018      	movs	r0, #24
 80039e0:	f02c fb60 	bl	80300a4 <malloc>
  if (m == 0)
 80039e4:	4604      	mov	r4, r0
 80039e6:	b1f8      	cbz	r0, 8003a28 <gsl_matrix_ulong_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 80039e8:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 80039ea:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 80039ee:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 80039f2:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80039f6:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80039fa:	2300      	movs	r3, #0
 80039fc:	6143      	str	r3, [r0, #20]
}
 80039fe:	4620      	mov	r0, r4
 8003a00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003a04:	490c      	ldr	r1, [pc, #48]	; (8003a38 <gsl_matrix_ulong_alloc_from_block+0x78>)
 8003a06:	480d      	ldr	r0, [pc, #52]	; (8003a3c <gsl_matrix_ulong_alloc_from_block+0x7c>)
 8003a08:	2304      	movs	r3, #4
 8003a0a:	225b      	movs	r2, #91	; 0x5b
 8003a0c:	2400      	movs	r4, #0
 8003a0e:	f7fe ff27 	bl	8002860 <gsl_error>
}
 8003a12:	4620      	mov	r0, r4
 8003a14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003a18:	4907      	ldr	r1, [pc, #28]	; (8003a38 <gsl_matrix_ulong_alloc_from_block+0x78>)
 8003a1a:	4809      	ldr	r0, [pc, #36]	; (8003a40 <gsl_matrix_ulong_alloc_from_block+0x80>)
 8003a1c:	2304      	movs	r3, #4
 8003a1e:	2256      	movs	r2, #86	; 0x56
 8003a20:	f7fe ff1e 	bl	8002860 <gsl_error>
 8003a24:	2400      	movs	r4, #0
 8003a26:	e7ea      	b.n	80039fe <gsl_matrix_ulong_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003a28:	4903      	ldr	r1, [pc, #12]	; (8003a38 <gsl_matrix_ulong_alloc_from_block+0x78>)
 8003a2a:	4806      	ldr	r0, [pc, #24]	; (8003a44 <gsl_matrix_ulong_alloc_from_block+0x84>)
 8003a2c:	2308      	movs	r3, #8
 8003a2e:	2263      	movs	r2, #99	; 0x63
 8003a30:	f7fe ff16 	bl	8002860 <gsl_error>
 8003a34:	e7e3      	b.n	80039fe <gsl_matrix_ulong_alloc_from_block+0x3e>
 8003a36:	bf00      	nop
 8003a38:	08030f9c 	.word	0x08030f9c
 8003a3c:	08031028 	.word	0x08031028
 8003a40:	08030ffc 	.word	0x08030ffc
 8003a44:	08030fac 	.word	0x08030fac

08003a48 <gsl_matrix_ulong_alloc_from_matrix>:
{
 8003a48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003a4c:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003a4e:	6803      	ldr	r3, [r0, #0]
{
 8003a50:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003a54:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003a56:	19c8      	adds	r0, r1, r7
 8003a58:	4298      	cmp	r0, r3
 8003a5a:	d826      	bhi.n	8003aaa <gsl_matrix_ulong_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003a5c:	686b      	ldr	r3, [r5, #4]
 8003a5e:	4690      	mov	r8, r2
 8003a60:	444a      	add	r2, r9
 8003a62:	429a      	cmp	r2, r3
 8003a64:	d817      	bhi.n	8003a96 <gsl_matrix_ulong_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003a66:	2018      	movs	r0, #24
 8003a68:	460e      	mov	r6, r1
 8003a6a:	f02c fb1b 	bl	80300a4 <malloc>
  if (m == 0)
 8003a6e:	4604      	mov	r4, r0
 8003a70:	b318      	cbz	r0, 8003aba <gsl_matrix_ulong_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003a72:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003a74:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003a76:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003a7a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003a7e:	fb06 8603 	mla	r6, r6, r3, r8
 8003a82:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003a86:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003a88:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003a8c:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003a90:	4620      	mov	r0, r4
 8003a92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003a96:	490c      	ldr	r1, [pc, #48]	; (8003ac8 <gsl_matrix_ulong_alloc_from_matrix+0x80>)
 8003a98:	480c      	ldr	r0, [pc, #48]	; (8003acc <gsl_matrix_ulong_alloc_from_matrix+0x84>)
 8003a9a:	2304      	movs	r3, #4
 8003a9c:	2282      	movs	r2, #130	; 0x82
 8003a9e:	2400      	movs	r4, #0
 8003aa0:	f7fe fede 	bl	8002860 <gsl_error>
}
 8003aa4:	4620      	mov	r0, r4
 8003aa6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003aaa:	4907      	ldr	r1, [pc, #28]	; (8003ac8 <gsl_matrix_ulong_alloc_from_matrix+0x80>)
 8003aac:	4808      	ldr	r0, [pc, #32]	; (8003ad0 <gsl_matrix_ulong_alloc_from_matrix+0x88>)
 8003aae:	2304      	movs	r3, #4
 8003ab0:	227d      	movs	r2, #125	; 0x7d
 8003ab2:	f7fe fed5 	bl	8002860 <gsl_error>
 8003ab6:	2400      	movs	r4, #0
 8003ab8:	e7ea      	b.n	8003a90 <gsl_matrix_ulong_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003aba:	4903      	ldr	r1, [pc, #12]	; (8003ac8 <gsl_matrix_ulong_alloc_from_matrix+0x80>)
 8003abc:	4805      	ldr	r0, [pc, #20]	; (8003ad4 <gsl_matrix_ulong_alloc_from_matrix+0x8c>)
 8003abe:	2308      	movs	r3, #8
 8003ac0:	228a      	movs	r2, #138	; 0x8a
 8003ac2:	f7fe fecd 	bl	8002860 <gsl_error>
 8003ac6:	e7e3      	b.n	8003a90 <gsl_matrix_ulong_alloc_from_matrix+0x48>
 8003ac8:	08030f9c 	.word	0x08030f9c
 8003acc:	08031084 	.word	0x08031084
 8003ad0:	08031054 	.word	0x08031054
 8003ad4:	08030fac 	.word	0x08030fac

08003ad8 <gsl_matrix_ulong_free>:
  RETURN_IF_NULL (m);
 8003ad8:	b180      	cbz	r0, 8003afc <gsl_matrix_ulong_free+0x24>
  if (m->owner)
 8003ada:	6943      	ldr	r3, [r0, #20]
{
 8003adc:	b510      	push	{r4, lr}
 8003ade:	4604      	mov	r4, r0
  if (m->owner)
 8003ae0:	b923      	cbnz	r3, 8003aec <gsl_matrix_ulong_free+0x14>
  free (m);
 8003ae2:	4620      	mov	r0, r4
}
 8003ae4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003ae8:	f02c bae4 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003aec:	6900      	ldr	r0, [r0, #16]
 8003aee:	f003 ffcd 	bl	8007a8c <gsl_block_ulong_free>
  free (m);
 8003af2:	4620      	mov	r0, r4
}
 8003af4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003af8:	f02c badc 	b.w	80300b4 <free>
 8003afc:	4770      	bx	lr
 8003afe:	bf00      	nop

08003b00 <gsl_matrix_ulong_set_identity>:
{
 8003b00:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003b02:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8003b04:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8003b06:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8003b0a:	b19e      	cbz	r6, 8003b34 <gsl_matrix_ulong_set_identity+0x34>
 8003b0c:	2500      	movs	r5, #0
 8003b0e:	3f04      	subs	r7, #4
 8003b10:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8003b12:	b15c      	cbz	r4, 8003b2c <gsl_matrix_ulong_set_identity+0x2c>
 8003b14:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8003b18:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003b1a:	1ac1      	subs	r1, r0, r3
 8003b1c:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8003b20:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003b22:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8003b24:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003b26:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8003b2a:	d1f6      	bne.n	8003b1a <gsl_matrix_ulong_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8003b2c:	3001      	adds	r0, #1
 8003b2e:	4286      	cmp	r6, r0
 8003b30:	4465      	add	r5, ip
 8003b32:	d1ee      	bne.n	8003b12 <gsl_matrix_ulong_set_identity+0x12>
}
 8003b34:	bcf0      	pop	{r4, r5, r6, r7}
 8003b36:	4770      	bx	lr

08003b38 <gsl_matrix_ulong_set_zero>:
{
 8003b38:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003b3a:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003b3c:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003b3e:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003b42:	b18f      	cbz	r7, 8003b68 <gsl_matrix_ulong_set_zero+0x30>
 8003b44:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003b48:	2000      	movs	r0, #0
 8003b4a:	00b6      	lsls	r6, r6, #2
 8003b4c:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003b50:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003b52:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8003b54:	1953      	adds	r3, r2, r5
 8003b56:	b11c      	cbz	r4, 8003b60 <gsl_matrix_ulong_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003b58:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003b5c:	4293      	cmp	r3, r2
 8003b5e:	d1fb      	bne.n	8003b58 <gsl_matrix_ulong_set_zero+0x20>
  for (i = 0; i < p; i++)
 8003b60:	3001      	adds	r0, #1
 8003b62:	4287      	cmp	r7, r0
 8003b64:	4432      	add	r2, r6
 8003b66:	d1f5      	bne.n	8003b54 <gsl_matrix_ulong_set_zero+0x1c>
}
 8003b68:	bcf0      	pop	{r4, r5, r6, r7}
 8003b6a:	4770      	bx	lr

08003b6c <gsl_matrix_ulong_set_all>:
{
 8003b6c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003b6e:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003b70:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003b72:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003b76:	b187      	cbz	r7, 8003b9a <gsl_matrix_ulong_set_all+0x2e>
 8003b78:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003b7c:	00b6      	lsls	r6, r6, #2
 8003b7e:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003b82:	00ad      	lsls	r5, r5, #2
 8003b84:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 8003b86:	1953      	adds	r3, r2, r5
 8003b88:	b11c      	cbz	r4, 8003b92 <gsl_matrix_ulong_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003b8a:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003b8e:	4293      	cmp	r3, r2
 8003b90:	d1fb      	bne.n	8003b8a <gsl_matrix_ulong_set_all+0x1e>
  for (i = 0; i < p; i++)
 8003b92:	3001      	adds	r0, #1
 8003b94:	4287      	cmp	r7, r0
 8003b96:	4432      	add	r2, r6
 8003b98:	d1f5      	bne.n	8003b86 <gsl_matrix_ulong_set_all+0x1a>
}
 8003b9a:	bcf0      	pop	{r4, r5, r6, r7}
 8003b9c:	4770      	bx	lr
 8003b9e:	bf00      	nop

08003ba0 <gsl_matrix_long_alloc>:
{
 8003ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ba2:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003ba4:	2018      	movs	r0, #24
{
 8003ba6:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003ba8:	f02c fa7c 	bl	80300a4 <malloc>
  if (m == 0)
 8003bac:	4604      	mov	r4, r0
 8003bae:	b1b8      	cbz	r0, 8003be0 <gsl_matrix_long_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8003bb0:	fb06 f007 	mul.w	r0, r6, r7
 8003bb4:	f003 ff76 	bl	8007aa4 <gsl_block_long_alloc>
  if (block == 0)
 8003bb8:	4605      	mov	r5, r0
 8003bba:	b148      	cbz	r0, 8003bd0 <gsl_matrix_long_alloc+0x30>
  m->data = block->data;
 8003bbc:	6843      	ldr	r3, [r0, #4]
 8003bbe:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8003bc0:	2301      	movs	r3, #1
  m->size2 = n2;
 8003bc2:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8003bc6:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8003bca:	60a6      	str	r6, [r4, #8]
}
 8003bcc:	4620      	mov	r0, r4
 8003bce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8003bd0:	4907      	ldr	r1, [pc, #28]	; (8003bf0 <gsl_matrix_long_alloc+0x50>)
 8003bd2:	4808      	ldr	r0, [pc, #32]	; (8003bf4 <gsl_matrix_long_alloc+0x54>)
 8003bd4:	2308      	movs	r3, #8
 8003bd6:	2228      	movs	r2, #40	; 0x28
 8003bd8:	462c      	mov	r4, r5
 8003bda:	f7fe fe41 	bl	8002860 <gsl_error>
 8003bde:	e7f5      	b.n	8003bcc <gsl_matrix_long_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003be0:	4903      	ldr	r1, [pc, #12]	; (8003bf0 <gsl_matrix_long_alloc+0x50>)
 8003be2:	4805      	ldr	r0, [pc, #20]	; (8003bf8 <gsl_matrix_long_alloc+0x58>)
 8003be4:	2308      	movs	r3, #8
 8003be6:	221e      	movs	r2, #30
 8003be8:	f7fe fe3a 	bl	8002860 <gsl_error>
 8003bec:	e7ee      	b.n	8003bcc <gsl_matrix_long_alloc+0x2c>
 8003bee:	bf00      	nop
 8003bf0:	08030f9c 	.word	0x08030f9c
 8003bf4:	08030fd8 	.word	0x08030fd8
 8003bf8:	08030fac 	.word	0x08030fac

08003bfc <gsl_matrix_long_calloc>:
{
 8003bfc:	b570      	push	{r4, r5, r6, lr}
 8003bfe:	4604      	mov	r4, r0
 8003c00:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8003c02:	f7ff ffcd 	bl	8003ba0 <gsl_matrix_long_alloc>
  if (m == 0)
 8003c06:	4605      	mov	r5, r0
 8003c08:	b188      	cbz	r0, 8003c2e <gsl_matrix_long_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003c0a:	fb06 f604 	mul.w	r6, r6, r4
 8003c0e:	00b4      	lsls	r4, r6, #2
 8003c10:	68c0      	ldr	r0, [r0, #12]
 8003c12:	4622      	mov	r2, r4
 8003c14:	2100      	movs	r1, #0
 8003c16:	f02c fa55 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003c1a:	b146      	cbz	r6, 8003c2e <gsl_matrix_long_calloc+0x32>
      m->data[i] = 0;
 8003c1c:	68eb      	ldr	r3, [r5, #12]
 8003c1e:	1f22      	subs	r2, r4, #4
 8003c20:	441a      	add	r2, r3
 8003c22:	2100      	movs	r1, #0
 8003c24:	3b04      	subs	r3, #4
 8003c26:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003c2a:	4293      	cmp	r3, r2
 8003c2c:	d1fb      	bne.n	8003c26 <gsl_matrix_long_calloc+0x2a>
}
 8003c2e:	4628      	mov	r0, r5
 8003c30:	bd70      	pop	{r4, r5, r6, pc}
 8003c32:	bf00      	nop

08003c34 <gsl_matrix_long_alloc_from_block>:
{
 8003c34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003c38:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003c3c:	4599      	cmp	r9, r3
 8003c3e:	d325      	bcc.n	8003c8c <gsl_matrix_long_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003c40:	4690      	mov	r8, r2
 8003c42:	6802      	ldr	r2, [r0, #0]
 8003c44:	461e      	mov	r6, r3
 8003c46:	fb08 1309 	mla	r3, r8, r9, r1
 8003c4a:	429a      	cmp	r2, r3
 8003c4c:	4605      	mov	r5, r0
 8003c4e:	460f      	mov	r7, r1
 8003c50:	d312      	bcc.n	8003c78 <gsl_matrix_long_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003c52:	2018      	movs	r0, #24
 8003c54:	f02c fa26 	bl	80300a4 <malloc>
  if (m == 0)
 8003c58:	4604      	mov	r4, r0
 8003c5a:	b1f8      	cbz	r0, 8003c9c <gsl_matrix_long_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003c5c:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003c5e:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8003c62:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 8003c66:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003c6a:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003c6e:	2300      	movs	r3, #0
 8003c70:	6143      	str	r3, [r0, #20]
}
 8003c72:	4620      	mov	r0, r4
 8003c74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003c78:	490c      	ldr	r1, [pc, #48]	; (8003cac <gsl_matrix_long_alloc_from_block+0x78>)
 8003c7a:	480d      	ldr	r0, [pc, #52]	; (8003cb0 <gsl_matrix_long_alloc_from_block+0x7c>)
 8003c7c:	2304      	movs	r3, #4
 8003c7e:	225b      	movs	r2, #91	; 0x5b
 8003c80:	2400      	movs	r4, #0
 8003c82:	f7fe fded 	bl	8002860 <gsl_error>
}
 8003c86:	4620      	mov	r0, r4
 8003c88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003c8c:	4907      	ldr	r1, [pc, #28]	; (8003cac <gsl_matrix_long_alloc_from_block+0x78>)
 8003c8e:	4809      	ldr	r0, [pc, #36]	; (8003cb4 <gsl_matrix_long_alloc_from_block+0x80>)
 8003c90:	2304      	movs	r3, #4
 8003c92:	2256      	movs	r2, #86	; 0x56
 8003c94:	f7fe fde4 	bl	8002860 <gsl_error>
 8003c98:	2400      	movs	r4, #0
 8003c9a:	e7ea      	b.n	8003c72 <gsl_matrix_long_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003c9c:	4903      	ldr	r1, [pc, #12]	; (8003cac <gsl_matrix_long_alloc_from_block+0x78>)
 8003c9e:	4806      	ldr	r0, [pc, #24]	; (8003cb8 <gsl_matrix_long_alloc_from_block+0x84>)
 8003ca0:	2308      	movs	r3, #8
 8003ca2:	2263      	movs	r2, #99	; 0x63
 8003ca4:	f7fe fddc 	bl	8002860 <gsl_error>
 8003ca8:	e7e3      	b.n	8003c72 <gsl_matrix_long_alloc_from_block+0x3e>
 8003caa:	bf00      	nop
 8003cac:	08030f9c 	.word	0x08030f9c
 8003cb0:	08031028 	.word	0x08031028
 8003cb4:	08030ffc 	.word	0x08030ffc
 8003cb8:	08030fac 	.word	0x08030fac

08003cbc <gsl_matrix_long_alloc_from_matrix>:
{
 8003cbc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003cc0:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003cc2:	6803      	ldr	r3, [r0, #0]
{
 8003cc4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003cc8:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003cca:	19c8      	adds	r0, r1, r7
 8003ccc:	4298      	cmp	r0, r3
 8003cce:	d826      	bhi.n	8003d1e <gsl_matrix_long_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003cd0:	686b      	ldr	r3, [r5, #4]
 8003cd2:	4690      	mov	r8, r2
 8003cd4:	444a      	add	r2, r9
 8003cd6:	429a      	cmp	r2, r3
 8003cd8:	d817      	bhi.n	8003d0a <gsl_matrix_long_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003cda:	2018      	movs	r0, #24
 8003cdc:	460e      	mov	r6, r1
 8003cde:	f02c f9e1 	bl	80300a4 <malloc>
  if (m == 0)
 8003ce2:	4604      	mov	r4, r0
 8003ce4:	b318      	cbz	r0, 8003d2e <gsl_matrix_long_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003ce6:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003ce8:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003cea:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003cee:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003cf2:	fb06 8603 	mla	r6, r6, r3, r8
 8003cf6:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003cfa:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003cfc:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003d00:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003d04:	4620      	mov	r0, r4
 8003d06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003d0a:	490c      	ldr	r1, [pc, #48]	; (8003d3c <gsl_matrix_long_alloc_from_matrix+0x80>)
 8003d0c:	480c      	ldr	r0, [pc, #48]	; (8003d40 <gsl_matrix_long_alloc_from_matrix+0x84>)
 8003d0e:	2304      	movs	r3, #4
 8003d10:	2282      	movs	r2, #130	; 0x82
 8003d12:	2400      	movs	r4, #0
 8003d14:	f7fe fda4 	bl	8002860 <gsl_error>
}
 8003d18:	4620      	mov	r0, r4
 8003d1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003d1e:	4907      	ldr	r1, [pc, #28]	; (8003d3c <gsl_matrix_long_alloc_from_matrix+0x80>)
 8003d20:	4808      	ldr	r0, [pc, #32]	; (8003d44 <gsl_matrix_long_alloc_from_matrix+0x88>)
 8003d22:	2304      	movs	r3, #4
 8003d24:	227d      	movs	r2, #125	; 0x7d
 8003d26:	f7fe fd9b 	bl	8002860 <gsl_error>
 8003d2a:	2400      	movs	r4, #0
 8003d2c:	e7ea      	b.n	8003d04 <gsl_matrix_long_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003d2e:	4903      	ldr	r1, [pc, #12]	; (8003d3c <gsl_matrix_long_alloc_from_matrix+0x80>)
 8003d30:	4805      	ldr	r0, [pc, #20]	; (8003d48 <gsl_matrix_long_alloc_from_matrix+0x8c>)
 8003d32:	2308      	movs	r3, #8
 8003d34:	228a      	movs	r2, #138	; 0x8a
 8003d36:	f7fe fd93 	bl	8002860 <gsl_error>
 8003d3a:	e7e3      	b.n	8003d04 <gsl_matrix_long_alloc_from_matrix+0x48>
 8003d3c:	08030f9c 	.word	0x08030f9c
 8003d40:	08031084 	.word	0x08031084
 8003d44:	08031054 	.word	0x08031054
 8003d48:	08030fac 	.word	0x08030fac

08003d4c <gsl_matrix_long_free>:
  RETURN_IF_NULL (m);
 8003d4c:	b180      	cbz	r0, 8003d70 <gsl_matrix_long_free+0x24>
  if (m->owner)
 8003d4e:	6943      	ldr	r3, [r0, #20]
{
 8003d50:	b510      	push	{r4, lr}
 8003d52:	4604      	mov	r4, r0
  if (m->owner)
 8003d54:	b923      	cbnz	r3, 8003d60 <gsl_matrix_long_free+0x14>
  free (m);
 8003d56:	4620      	mov	r0, r4
}
 8003d58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003d5c:	f02c b9aa 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003d60:	6900      	ldr	r0, [r0, #16]
 8003d62:	f003 fee1 	bl	8007b28 <gsl_block_long_free>
  free (m);
 8003d66:	4620      	mov	r0, r4
}
 8003d68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003d6c:	f02c b9a2 	b.w	80300b4 <free>
 8003d70:	4770      	bx	lr
 8003d72:	bf00      	nop

08003d74 <gsl_matrix_long_set_identity>:
{
 8003d74:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003d76:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8003d78:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8003d7a:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8003d7e:	b19e      	cbz	r6, 8003da8 <gsl_matrix_long_set_identity+0x34>
 8003d80:	2500      	movs	r5, #0
 8003d82:	3f04      	subs	r7, #4
 8003d84:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8003d86:	b15c      	cbz	r4, 8003da0 <gsl_matrix_long_set_identity+0x2c>
 8003d88:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8003d8c:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003d8e:	1ac1      	subs	r1, r0, r3
 8003d90:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8003d94:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003d96:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8003d98:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003d9a:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8003d9e:	d1f6      	bne.n	8003d8e <gsl_matrix_long_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8003da0:	3001      	adds	r0, #1
 8003da2:	4286      	cmp	r6, r0
 8003da4:	4465      	add	r5, ip
 8003da6:	d1ee      	bne.n	8003d86 <gsl_matrix_long_set_identity+0x12>
}
 8003da8:	bcf0      	pop	{r4, r5, r6, r7}
 8003daa:	4770      	bx	lr

08003dac <gsl_matrix_long_set_zero>:
{
 8003dac:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003dae:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003db0:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003db2:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003db6:	b18f      	cbz	r7, 8003ddc <gsl_matrix_long_set_zero+0x30>
 8003db8:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003dbc:	2000      	movs	r0, #0
 8003dbe:	00b6      	lsls	r6, r6, #2
 8003dc0:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003dc4:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003dc6:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8003dc8:	1953      	adds	r3, r2, r5
 8003dca:	b11c      	cbz	r4, 8003dd4 <gsl_matrix_long_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003dcc:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003dd0:	4293      	cmp	r3, r2
 8003dd2:	d1fb      	bne.n	8003dcc <gsl_matrix_long_set_zero+0x20>
  for (i = 0; i < p; i++)
 8003dd4:	3001      	adds	r0, #1
 8003dd6:	4287      	cmp	r7, r0
 8003dd8:	4432      	add	r2, r6
 8003dda:	d1f5      	bne.n	8003dc8 <gsl_matrix_long_set_zero+0x1c>
}
 8003ddc:	bcf0      	pop	{r4, r5, r6, r7}
 8003dde:	4770      	bx	lr

08003de0 <gsl_matrix_long_set_all>:
{
 8003de0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003de2:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003de4:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003de6:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003dea:	b187      	cbz	r7, 8003e0e <gsl_matrix_long_set_all+0x2e>
 8003dec:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003df0:	00b6      	lsls	r6, r6, #2
 8003df2:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003df6:	00ad      	lsls	r5, r5, #2
 8003df8:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 8003dfa:	1953      	adds	r3, r2, r5
 8003dfc:	b11c      	cbz	r4, 8003e06 <gsl_matrix_long_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003dfe:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003e02:	4293      	cmp	r3, r2
 8003e04:	d1fb      	bne.n	8003dfe <gsl_matrix_long_set_all+0x1e>
  for (i = 0; i < p; i++)
 8003e06:	3001      	adds	r0, #1
 8003e08:	4287      	cmp	r7, r0
 8003e0a:	4432      	add	r2, r6
 8003e0c:	d1f5      	bne.n	8003dfa <gsl_matrix_long_set_all+0x1a>
}
 8003e0e:	bcf0      	pop	{r4, r5, r6, r7}
 8003e10:	4770      	bx	lr
 8003e12:	bf00      	nop

08003e14 <gsl_matrix_uint_alloc>:
{
 8003e14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e16:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003e18:	2018      	movs	r0, #24
{
 8003e1a:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003e1c:	f02c f942 	bl	80300a4 <malloc>
  if (m == 0)
 8003e20:	4604      	mov	r4, r0
 8003e22:	b1b8      	cbz	r0, 8003e54 <gsl_matrix_uint_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8003e24:	fb06 f007 	mul.w	r0, r6, r7
 8003e28:	f003 fe8a 	bl	8007b40 <gsl_block_uint_alloc>
  if (block == 0)
 8003e2c:	4605      	mov	r5, r0
 8003e2e:	b148      	cbz	r0, 8003e44 <gsl_matrix_uint_alloc+0x30>
  m->data = block->data;
 8003e30:	6843      	ldr	r3, [r0, #4]
 8003e32:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8003e34:	2301      	movs	r3, #1
  m->size2 = n2;
 8003e36:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8003e3a:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8003e3e:	60a6      	str	r6, [r4, #8]
}
 8003e40:	4620      	mov	r0, r4
 8003e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8003e44:	4907      	ldr	r1, [pc, #28]	; (8003e64 <gsl_matrix_uint_alloc+0x50>)
 8003e46:	4808      	ldr	r0, [pc, #32]	; (8003e68 <gsl_matrix_uint_alloc+0x54>)
 8003e48:	2308      	movs	r3, #8
 8003e4a:	2228      	movs	r2, #40	; 0x28
 8003e4c:	462c      	mov	r4, r5
 8003e4e:	f7fe fd07 	bl	8002860 <gsl_error>
 8003e52:	e7f5      	b.n	8003e40 <gsl_matrix_uint_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003e54:	4903      	ldr	r1, [pc, #12]	; (8003e64 <gsl_matrix_uint_alloc+0x50>)
 8003e56:	4805      	ldr	r0, [pc, #20]	; (8003e6c <gsl_matrix_uint_alloc+0x58>)
 8003e58:	2308      	movs	r3, #8
 8003e5a:	221e      	movs	r2, #30
 8003e5c:	f7fe fd00 	bl	8002860 <gsl_error>
 8003e60:	e7ee      	b.n	8003e40 <gsl_matrix_uint_alloc+0x2c>
 8003e62:	bf00      	nop
 8003e64:	08030f9c 	.word	0x08030f9c
 8003e68:	08030fd8 	.word	0x08030fd8
 8003e6c:	08030fac 	.word	0x08030fac

08003e70 <gsl_matrix_uint_calloc>:
{
 8003e70:	b570      	push	{r4, r5, r6, lr}
 8003e72:	4604      	mov	r4, r0
 8003e74:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8003e76:	f7ff ffcd 	bl	8003e14 <gsl_matrix_uint_alloc>
  if (m == 0)
 8003e7a:	4605      	mov	r5, r0
 8003e7c:	b188      	cbz	r0, 8003ea2 <gsl_matrix_uint_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003e7e:	fb06 f604 	mul.w	r6, r6, r4
 8003e82:	00b4      	lsls	r4, r6, #2
 8003e84:	68c0      	ldr	r0, [r0, #12]
 8003e86:	4622      	mov	r2, r4
 8003e88:	2100      	movs	r1, #0
 8003e8a:	f02c f91b 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003e8e:	b146      	cbz	r6, 8003ea2 <gsl_matrix_uint_calloc+0x32>
      m->data[i] = 0;
 8003e90:	68eb      	ldr	r3, [r5, #12]
 8003e92:	1f22      	subs	r2, r4, #4
 8003e94:	441a      	add	r2, r3
 8003e96:	2100      	movs	r1, #0
 8003e98:	3b04      	subs	r3, #4
 8003e9a:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003e9e:	4293      	cmp	r3, r2
 8003ea0:	d1fb      	bne.n	8003e9a <gsl_matrix_uint_calloc+0x2a>
}
 8003ea2:	4628      	mov	r0, r5
 8003ea4:	bd70      	pop	{r4, r5, r6, pc}
 8003ea6:	bf00      	nop

08003ea8 <gsl_matrix_uint_alloc_from_block>:
{
 8003ea8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003eac:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003eb0:	4599      	cmp	r9, r3
 8003eb2:	d325      	bcc.n	8003f00 <gsl_matrix_uint_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003eb4:	4690      	mov	r8, r2
 8003eb6:	6802      	ldr	r2, [r0, #0]
 8003eb8:	461e      	mov	r6, r3
 8003eba:	fb08 1309 	mla	r3, r8, r9, r1
 8003ebe:	429a      	cmp	r2, r3
 8003ec0:	4605      	mov	r5, r0
 8003ec2:	460f      	mov	r7, r1
 8003ec4:	d312      	bcc.n	8003eec <gsl_matrix_uint_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003ec6:	2018      	movs	r0, #24
 8003ec8:	f02c f8ec 	bl	80300a4 <malloc>
  if (m == 0)
 8003ecc:	4604      	mov	r4, r0
 8003ece:	b1f8      	cbz	r0, 8003f10 <gsl_matrix_uint_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003ed0:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003ed2:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8003ed6:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 8003eda:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003ede:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003ee2:	2300      	movs	r3, #0
 8003ee4:	6143      	str	r3, [r0, #20]
}
 8003ee6:	4620      	mov	r0, r4
 8003ee8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003eec:	490c      	ldr	r1, [pc, #48]	; (8003f20 <gsl_matrix_uint_alloc_from_block+0x78>)
 8003eee:	480d      	ldr	r0, [pc, #52]	; (8003f24 <gsl_matrix_uint_alloc_from_block+0x7c>)
 8003ef0:	2304      	movs	r3, #4
 8003ef2:	225b      	movs	r2, #91	; 0x5b
 8003ef4:	2400      	movs	r4, #0
 8003ef6:	f7fe fcb3 	bl	8002860 <gsl_error>
}
 8003efa:	4620      	mov	r0, r4
 8003efc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003f00:	4907      	ldr	r1, [pc, #28]	; (8003f20 <gsl_matrix_uint_alloc_from_block+0x78>)
 8003f02:	4809      	ldr	r0, [pc, #36]	; (8003f28 <gsl_matrix_uint_alloc_from_block+0x80>)
 8003f04:	2304      	movs	r3, #4
 8003f06:	2256      	movs	r2, #86	; 0x56
 8003f08:	f7fe fcaa 	bl	8002860 <gsl_error>
 8003f0c:	2400      	movs	r4, #0
 8003f0e:	e7ea      	b.n	8003ee6 <gsl_matrix_uint_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003f10:	4903      	ldr	r1, [pc, #12]	; (8003f20 <gsl_matrix_uint_alloc_from_block+0x78>)
 8003f12:	4806      	ldr	r0, [pc, #24]	; (8003f2c <gsl_matrix_uint_alloc_from_block+0x84>)
 8003f14:	2308      	movs	r3, #8
 8003f16:	2263      	movs	r2, #99	; 0x63
 8003f18:	f7fe fca2 	bl	8002860 <gsl_error>
 8003f1c:	e7e3      	b.n	8003ee6 <gsl_matrix_uint_alloc_from_block+0x3e>
 8003f1e:	bf00      	nop
 8003f20:	08030f9c 	.word	0x08030f9c
 8003f24:	08031028 	.word	0x08031028
 8003f28:	08030ffc 	.word	0x08030ffc
 8003f2c:	08030fac 	.word	0x08030fac

08003f30 <gsl_matrix_uint_alloc_from_matrix>:
{
 8003f30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003f34:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003f36:	6803      	ldr	r3, [r0, #0]
{
 8003f38:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003f3c:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003f3e:	19c8      	adds	r0, r1, r7
 8003f40:	4298      	cmp	r0, r3
 8003f42:	d826      	bhi.n	8003f92 <gsl_matrix_uint_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003f44:	686b      	ldr	r3, [r5, #4]
 8003f46:	4690      	mov	r8, r2
 8003f48:	444a      	add	r2, r9
 8003f4a:	429a      	cmp	r2, r3
 8003f4c:	d817      	bhi.n	8003f7e <gsl_matrix_uint_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003f4e:	2018      	movs	r0, #24
 8003f50:	460e      	mov	r6, r1
 8003f52:	f02c f8a7 	bl	80300a4 <malloc>
  if (m == 0)
 8003f56:	4604      	mov	r4, r0
 8003f58:	b318      	cbz	r0, 8003fa2 <gsl_matrix_uint_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003f5a:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003f5c:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003f5e:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003f62:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003f66:	fb06 8603 	mla	r6, r6, r3, r8
 8003f6a:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003f6e:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003f70:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003f74:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003f78:	4620      	mov	r0, r4
 8003f7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003f7e:	490c      	ldr	r1, [pc, #48]	; (8003fb0 <gsl_matrix_uint_alloc_from_matrix+0x80>)
 8003f80:	480c      	ldr	r0, [pc, #48]	; (8003fb4 <gsl_matrix_uint_alloc_from_matrix+0x84>)
 8003f82:	2304      	movs	r3, #4
 8003f84:	2282      	movs	r2, #130	; 0x82
 8003f86:	2400      	movs	r4, #0
 8003f88:	f7fe fc6a 	bl	8002860 <gsl_error>
}
 8003f8c:	4620      	mov	r0, r4
 8003f8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003f92:	4907      	ldr	r1, [pc, #28]	; (8003fb0 <gsl_matrix_uint_alloc_from_matrix+0x80>)
 8003f94:	4808      	ldr	r0, [pc, #32]	; (8003fb8 <gsl_matrix_uint_alloc_from_matrix+0x88>)
 8003f96:	2304      	movs	r3, #4
 8003f98:	227d      	movs	r2, #125	; 0x7d
 8003f9a:	f7fe fc61 	bl	8002860 <gsl_error>
 8003f9e:	2400      	movs	r4, #0
 8003fa0:	e7ea      	b.n	8003f78 <gsl_matrix_uint_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003fa2:	4903      	ldr	r1, [pc, #12]	; (8003fb0 <gsl_matrix_uint_alloc_from_matrix+0x80>)
 8003fa4:	4805      	ldr	r0, [pc, #20]	; (8003fbc <gsl_matrix_uint_alloc_from_matrix+0x8c>)
 8003fa6:	2308      	movs	r3, #8
 8003fa8:	228a      	movs	r2, #138	; 0x8a
 8003faa:	f7fe fc59 	bl	8002860 <gsl_error>
 8003fae:	e7e3      	b.n	8003f78 <gsl_matrix_uint_alloc_from_matrix+0x48>
 8003fb0:	08030f9c 	.word	0x08030f9c
 8003fb4:	08031084 	.word	0x08031084
 8003fb8:	08031054 	.word	0x08031054
 8003fbc:	08030fac 	.word	0x08030fac

08003fc0 <gsl_matrix_uint_free>:
  RETURN_IF_NULL (m);
 8003fc0:	b180      	cbz	r0, 8003fe4 <gsl_matrix_uint_free+0x24>
  if (m->owner)
 8003fc2:	6943      	ldr	r3, [r0, #20]
{
 8003fc4:	b510      	push	{r4, lr}
 8003fc6:	4604      	mov	r4, r0
  if (m->owner)
 8003fc8:	b923      	cbnz	r3, 8003fd4 <gsl_matrix_uint_free+0x14>
  free (m);
 8003fca:	4620      	mov	r0, r4
}
 8003fcc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003fd0:	f02c b870 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003fd4:	6900      	ldr	r0, [r0, #16]
 8003fd6:	f003 fdf5 	bl	8007bc4 <gsl_block_uint_free>
  free (m);
 8003fda:	4620      	mov	r0, r4
}
 8003fdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003fe0:	f02c b868 	b.w	80300b4 <free>
 8003fe4:	4770      	bx	lr
 8003fe6:	bf00      	nop

08003fe8 <gsl_matrix_uint_set_identity>:
{
 8003fe8:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003fea:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8003fec:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8003fee:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8003ff2:	b19e      	cbz	r6, 800401c <gsl_matrix_uint_set_identity+0x34>
 8003ff4:	2500      	movs	r5, #0
 8003ff6:	3f04      	subs	r7, #4
 8003ff8:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8003ffa:	b15c      	cbz	r4, 8004014 <gsl_matrix_uint_set_identity+0x2c>
 8003ffc:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8004000:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004002:	1ac1      	subs	r1, r0, r3
 8004004:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8004008:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800400a:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 800400c:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800400e:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8004012:	d1f6      	bne.n	8004002 <gsl_matrix_uint_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8004014:	3001      	adds	r0, #1
 8004016:	4286      	cmp	r6, r0
 8004018:	4465      	add	r5, ip
 800401a:	d1ee      	bne.n	8003ffa <gsl_matrix_uint_set_identity+0x12>
}
 800401c:	bcf0      	pop	{r4, r5, r6, r7}
 800401e:	4770      	bx	lr

08004020 <gsl_matrix_uint_set_zero>:
{
 8004020:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004022:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004024:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8004026:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 800402a:	b18f      	cbz	r7, 8004050 <gsl_matrix_uint_set_zero+0x30>
 800402c:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8004030:	2000      	movs	r0, #0
 8004032:	00b6      	lsls	r6, r6, #2
 8004034:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8004038:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800403a:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 800403c:	1953      	adds	r3, r2, r5
 800403e:	b11c      	cbz	r4, 8004048 <gsl_matrix_uint_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004040:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8004044:	4293      	cmp	r3, r2
 8004046:	d1fb      	bne.n	8004040 <gsl_matrix_uint_set_zero+0x20>
  for (i = 0; i < p; i++)
 8004048:	3001      	adds	r0, #1
 800404a:	4287      	cmp	r7, r0
 800404c:	4432      	add	r2, r6
 800404e:	d1f5      	bne.n	800403c <gsl_matrix_uint_set_zero+0x1c>
}
 8004050:	bcf0      	pop	{r4, r5, r6, r7}
 8004052:	4770      	bx	lr

08004054 <gsl_matrix_uint_set_all>:
{
 8004054:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004056:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004058:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800405a:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 800405e:	b187      	cbz	r7, 8004082 <gsl_matrix_uint_set_all+0x2e>
 8004060:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8004064:	00b6      	lsls	r6, r6, #2
 8004066:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 800406a:	00ad      	lsls	r5, r5, #2
 800406c:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 800406e:	1953      	adds	r3, r2, r5
 8004070:	b11c      	cbz	r4, 800407a <gsl_matrix_uint_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8004072:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8004076:	4293      	cmp	r3, r2
 8004078:	d1fb      	bne.n	8004072 <gsl_matrix_uint_set_all+0x1e>
  for (i = 0; i < p; i++)
 800407a:	3001      	adds	r0, #1
 800407c:	4287      	cmp	r7, r0
 800407e:	4432      	add	r2, r6
 8004080:	d1f5      	bne.n	800406e <gsl_matrix_uint_set_all+0x1a>
}
 8004082:	bcf0      	pop	{r4, r5, r6, r7}
 8004084:	4770      	bx	lr
 8004086:	bf00      	nop

08004088 <gsl_matrix_int_alloc>:
{
 8004088:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800408a:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800408c:	2018      	movs	r0, #24
{
 800408e:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004090:	f02c f808 	bl	80300a4 <malloc>
  if (m == 0)
 8004094:	4604      	mov	r4, r0
 8004096:	b1b8      	cbz	r0, 80040c8 <gsl_matrix_int_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8004098:	fb06 f007 	mul.w	r0, r6, r7
 800409c:	f003 fd9e 	bl	8007bdc <gsl_block_int_alloc>
  if (block == 0)
 80040a0:	4605      	mov	r5, r0
 80040a2:	b148      	cbz	r0, 80040b8 <gsl_matrix_int_alloc+0x30>
  m->data = block->data;
 80040a4:	6843      	ldr	r3, [r0, #4]
 80040a6:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 80040a8:	2301      	movs	r3, #1
  m->size2 = n2;
 80040aa:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 80040ae:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 80040b2:	60a6      	str	r6, [r4, #8]
}
 80040b4:	4620      	mov	r0, r4
 80040b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80040b8:	4907      	ldr	r1, [pc, #28]	; (80040d8 <gsl_matrix_int_alloc+0x50>)
 80040ba:	4808      	ldr	r0, [pc, #32]	; (80040dc <gsl_matrix_int_alloc+0x54>)
 80040bc:	2308      	movs	r3, #8
 80040be:	2228      	movs	r2, #40	; 0x28
 80040c0:	462c      	mov	r4, r5
 80040c2:	f7fe fbcd 	bl	8002860 <gsl_error>
 80040c6:	e7f5      	b.n	80040b4 <gsl_matrix_int_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80040c8:	4903      	ldr	r1, [pc, #12]	; (80040d8 <gsl_matrix_int_alloc+0x50>)
 80040ca:	4805      	ldr	r0, [pc, #20]	; (80040e0 <gsl_matrix_int_alloc+0x58>)
 80040cc:	2308      	movs	r3, #8
 80040ce:	221e      	movs	r2, #30
 80040d0:	f7fe fbc6 	bl	8002860 <gsl_error>
 80040d4:	e7ee      	b.n	80040b4 <gsl_matrix_int_alloc+0x2c>
 80040d6:	bf00      	nop
 80040d8:	08030f9c 	.word	0x08030f9c
 80040dc:	08030fd8 	.word	0x08030fd8
 80040e0:	08030fac 	.word	0x08030fac

080040e4 <gsl_matrix_int_calloc>:
{
 80040e4:	b570      	push	{r4, r5, r6, lr}
 80040e6:	4604      	mov	r4, r0
 80040e8:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80040ea:	f7ff ffcd 	bl	8004088 <gsl_matrix_int_alloc>
  if (m == 0)
 80040ee:	4605      	mov	r5, r0
 80040f0:	b188      	cbz	r0, 8004116 <gsl_matrix_int_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80040f2:	fb06 f604 	mul.w	r6, r6, r4
 80040f6:	00b4      	lsls	r4, r6, #2
 80040f8:	68c0      	ldr	r0, [r0, #12]
 80040fa:	4622      	mov	r2, r4
 80040fc:	2100      	movs	r1, #0
 80040fe:	f02b ffe1 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004102:	b146      	cbz	r6, 8004116 <gsl_matrix_int_calloc+0x32>
      m->data[i] = 0;
 8004104:	68eb      	ldr	r3, [r5, #12]
 8004106:	1f22      	subs	r2, r4, #4
 8004108:	441a      	add	r2, r3
 800410a:	2100      	movs	r1, #0
 800410c:	3b04      	subs	r3, #4
 800410e:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004112:	4293      	cmp	r3, r2
 8004114:	d1fb      	bne.n	800410e <gsl_matrix_int_calloc+0x2a>
}
 8004116:	4628      	mov	r0, r5
 8004118:	bd70      	pop	{r4, r5, r6, pc}
 800411a:	bf00      	nop

0800411c <gsl_matrix_int_alloc_from_block>:
{
 800411c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004120:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004124:	4599      	cmp	r9, r3
 8004126:	d325      	bcc.n	8004174 <gsl_matrix_int_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8004128:	4690      	mov	r8, r2
 800412a:	6802      	ldr	r2, [r0, #0]
 800412c:	461e      	mov	r6, r3
 800412e:	fb08 1309 	mla	r3, r8, r9, r1
 8004132:	429a      	cmp	r2, r3
 8004134:	4605      	mov	r5, r0
 8004136:	460f      	mov	r7, r1
 8004138:	d312      	bcc.n	8004160 <gsl_matrix_int_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800413a:	2018      	movs	r0, #24
 800413c:	f02b ffb2 	bl	80300a4 <malloc>
  if (m == 0)
 8004140:	4604      	mov	r4, r0
 8004142:	b1f8      	cbz	r0, 8004184 <gsl_matrix_int_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8004144:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8004146:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800414a:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 800414e:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8004152:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8004156:	2300      	movs	r3, #0
 8004158:	6143      	str	r3, [r0, #20]
}
 800415a:	4620      	mov	r0, r4
 800415c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8004160:	490c      	ldr	r1, [pc, #48]	; (8004194 <gsl_matrix_int_alloc_from_block+0x78>)
 8004162:	480d      	ldr	r0, [pc, #52]	; (8004198 <gsl_matrix_int_alloc_from_block+0x7c>)
 8004164:	2304      	movs	r3, #4
 8004166:	225b      	movs	r2, #91	; 0x5b
 8004168:	2400      	movs	r4, #0
 800416a:	f7fe fb79 	bl	8002860 <gsl_error>
}
 800416e:	4620      	mov	r0, r4
 8004170:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8004174:	4907      	ldr	r1, [pc, #28]	; (8004194 <gsl_matrix_int_alloc_from_block+0x78>)
 8004176:	4809      	ldr	r0, [pc, #36]	; (800419c <gsl_matrix_int_alloc_from_block+0x80>)
 8004178:	2304      	movs	r3, #4
 800417a:	2256      	movs	r2, #86	; 0x56
 800417c:	f7fe fb70 	bl	8002860 <gsl_error>
 8004180:	2400      	movs	r4, #0
 8004182:	e7ea      	b.n	800415a <gsl_matrix_int_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004184:	4903      	ldr	r1, [pc, #12]	; (8004194 <gsl_matrix_int_alloc_from_block+0x78>)
 8004186:	4806      	ldr	r0, [pc, #24]	; (80041a0 <gsl_matrix_int_alloc_from_block+0x84>)
 8004188:	2308      	movs	r3, #8
 800418a:	2263      	movs	r2, #99	; 0x63
 800418c:	f7fe fb68 	bl	8002860 <gsl_error>
 8004190:	e7e3      	b.n	800415a <gsl_matrix_int_alloc_from_block+0x3e>
 8004192:	bf00      	nop
 8004194:	08030f9c 	.word	0x08030f9c
 8004198:	08031028 	.word	0x08031028
 800419c:	08030ffc 	.word	0x08030ffc
 80041a0:	08030fac 	.word	0x08030fac

080041a4 <gsl_matrix_int_alloc_from_matrix>:
{
 80041a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80041a8:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 80041aa:	6803      	ldr	r3, [r0, #0]
{
 80041ac:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80041b0:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 80041b2:	19c8      	adds	r0, r1, r7
 80041b4:	4298      	cmp	r0, r3
 80041b6:	d826      	bhi.n	8004206 <gsl_matrix_int_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80041b8:	686b      	ldr	r3, [r5, #4]
 80041ba:	4690      	mov	r8, r2
 80041bc:	444a      	add	r2, r9
 80041be:	429a      	cmp	r2, r3
 80041c0:	d817      	bhi.n	80041f2 <gsl_matrix_int_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80041c2:	2018      	movs	r0, #24
 80041c4:	460e      	mov	r6, r1
 80041c6:	f02b ff6d 	bl	80300a4 <malloc>
  if (m == 0)
 80041ca:	4604      	mov	r4, r0
 80041cc:	b318      	cbz	r0, 8004216 <gsl_matrix_int_alloc_from_matrix+0x72>
  m->size1 = n1;
 80041ce:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80041d0:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80041d2:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80041d6:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80041da:	fb06 8603 	mla	r6, r6, r3, r8
 80041de:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 80041e2:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 80041e4:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 80041e8:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 80041ec:	4620      	mov	r0, r4
 80041ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 80041f2:	490c      	ldr	r1, [pc, #48]	; (8004224 <gsl_matrix_int_alloc_from_matrix+0x80>)
 80041f4:	480c      	ldr	r0, [pc, #48]	; (8004228 <gsl_matrix_int_alloc_from_matrix+0x84>)
 80041f6:	2304      	movs	r3, #4
 80041f8:	2282      	movs	r2, #130	; 0x82
 80041fa:	2400      	movs	r4, #0
 80041fc:	f7fe fb30 	bl	8002860 <gsl_error>
}
 8004200:	4620      	mov	r0, r4
 8004202:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8004206:	4907      	ldr	r1, [pc, #28]	; (8004224 <gsl_matrix_int_alloc_from_matrix+0x80>)
 8004208:	4808      	ldr	r0, [pc, #32]	; (800422c <gsl_matrix_int_alloc_from_matrix+0x88>)
 800420a:	2304      	movs	r3, #4
 800420c:	227d      	movs	r2, #125	; 0x7d
 800420e:	f7fe fb27 	bl	8002860 <gsl_error>
 8004212:	2400      	movs	r4, #0
 8004214:	e7ea      	b.n	80041ec <gsl_matrix_int_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004216:	4903      	ldr	r1, [pc, #12]	; (8004224 <gsl_matrix_int_alloc_from_matrix+0x80>)
 8004218:	4805      	ldr	r0, [pc, #20]	; (8004230 <gsl_matrix_int_alloc_from_matrix+0x8c>)
 800421a:	2308      	movs	r3, #8
 800421c:	228a      	movs	r2, #138	; 0x8a
 800421e:	f7fe fb1f 	bl	8002860 <gsl_error>
 8004222:	e7e3      	b.n	80041ec <gsl_matrix_int_alloc_from_matrix+0x48>
 8004224:	08030f9c 	.word	0x08030f9c
 8004228:	08031084 	.word	0x08031084
 800422c:	08031054 	.word	0x08031054
 8004230:	08030fac 	.word	0x08030fac

08004234 <gsl_matrix_int_free>:
  RETURN_IF_NULL (m);
 8004234:	b180      	cbz	r0, 8004258 <gsl_matrix_int_free+0x24>
  if (m->owner)
 8004236:	6943      	ldr	r3, [r0, #20]
{
 8004238:	b510      	push	{r4, lr}
 800423a:	4604      	mov	r4, r0
  if (m->owner)
 800423c:	b923      	cbnz	r3, 8004248 <gsl_matrix_int_free+0x14>
  free (m);
 800423e:	4620      	mov	r0, r4
}
 8004240:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004244:	f02b bf36 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004248:	6900      	ldr	r0, [r0, #16]
 800424a:	f003 fd09 	bl	8007c60 <gsl_block_int_free>
  free (m);
 800424e:	4620      	mov	r0, r4
}
 8004250:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004254:	f02b bf2e 	b.w	80300b4 <free>
 8004258:	4770      	bx	lr
 800425a:	bf00      	nop

0800425c <gsl_matrix_int_set_identity>:
{
 800425c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800425e:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004260:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8004262:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8004266:	b19e      	cbz	r6, 8004290 <gsl_matrix_int_set_identity+0x34>
 8004268:	2500      	movs	r5, #0
 800426a:	3f04      	subs	r7, #4
 800426c:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 800426e:	b15c      	cbz	r4, 8004288 <gsl_matrix_int_set_identity+0x2c>
 8004270:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8004274:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004276:	1ac1      	subs	r1, r0, r3
 8004278:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 800427c:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800427e:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8004280:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004282:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8004286:	d1f6      	bne.n	8004276 <gsl_matrix_int_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8004288:	3001      	adds	r0, #1
 800428a:	4286      	cmp	r6, r0
 800428c:	4465      	add	r5, ip
 800428e:	d1ee      	bne.n	800426e <gsl_matrix_int_set_identity+0x12>
}
 8004290:	bcf0      	pop	{r4, r5, r6, r7}
 8004292:	4770      	bx	lr

08004294 <gsl_matrix_int_set_zero>:
{
 8004294:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004296:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004298:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800429a:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 800429e:	b18f      	cbz	r7, 80042c4 <gsl_matrix_int_set_zero+0x30>
 80042a0:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 80042a4:	2000      	movs	r0, #0
 80042a6:	00b6      	lsls	r6, r6, #2
 80042a8:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80042ac:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80042ae:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 80042b0:	1953      	adds	r3, r2, r5
 80042b2:	b11c      	cbz	r4, 80042bc <gsl_matrix_int_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80042b4:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 80042b8:	4293      	cmp	r3, r2
 80042ba:	d1fb      	bne.n	80042b4 <gsl_matrix_int_set_zero+0x20>
  for (i = 0; i < p; i++)
 80042bc:	3001      	adds	r0, #1
 80042be:	4287      	cmp	r7, r0
 80042c0:	4432      	add	r2, r6
 80042c2:	d1f5      	bne.n	80042b0 <gsl_matrix_int_set_zero+0x1c>
}
 80042c4:	bcf0      	pop	{r4, r5, r6, r7}
 80042c6:	4770      	bx	lr

080042c8 <gsl_matrix_int_set_all>:
{
 80042c8:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80042ca:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80042cc:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80042ce:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 80042d2:	b187      	cbz	r7, 80042f6 <gsl_matrix_int_set_all+0x2e>
 80042d4:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 80042d8:	00b6      	lsls	r6, r6, #2
 80042da:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80042de:	00ad      	lsls	r5, r5, #2
 80042e0:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 80042e2:	1953      	adds	r3, r2, r5
 80042e4:	b11c      	cbz	r4, 80042ee <gsl_matrix_int_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 80042e6:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 80042ea:	4293      	cmp	r3, r2
 80042ec:	d1fb      	bne.n	80042e6 <gsl_matrix_int_set_all+0x1e>
  for (i = 0; i < p; i++)
 80042ee:	3001      	adds	r0, #1
 80042f0:	4287      	cmp	r7, r0
 80042f2:	4432      	add	r2, r6
 80042f4:	d1f5      	bne.n	80042e2 <gsl_matrix_int_set_all+0x1a>
}
 80042f6:	bcf0      	pop	{r4, r5, r6, r7}
 80042f8:	4770      	bx	lr
 80042fa:	bf00      	nop

080042fc <gsl_matrix_ushort_alloc>:
{
 80042fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80042fe:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004300:	2018      	movs	r0, #24
{
 8004302:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004304:	f02b fece 	bl	80300a4 <malloc>
  if (m == 0)
 8004308:	4604      	mov	r4, r0
 800430a:	b1b8      	cbz	r0, 800433c <gsl_matrix_ushort_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800430c:	fb06 f007 	mul.w	r0, r6, r7
 8004310:	f003 fcb2 	bl	8007c78 <gsl_block_ushort_alloc>
  if (block == 0)
 8004314:	4605      	mov	r5, r0
 8004316:	b148      	cbz	r0, 800432c <gsl_matrix_ushort_alloc+0x30>
  m->data = block->data;
 8004318:	6843      	ldr	r3, [r0, #4]
 800431a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 800431c:	2301      	movs	r3, #1
  m->size2 = n2;
 800431e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8004322:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8004326:	60a6      	str	r6, [r4, #8]
}
 8004328:	4620      	mov	r0, r4
 800432a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 800432c:	4907      	ldr	r1, [pc, #28]	; (800434c <gsl_matrix_ushort_alloc+0x50>)
 800432e:	4808      	ldr	r0, [pc, #32]	; (8004350 <gsl_matrix_ushort_alloc+0x54>)
 8004330:	2308      	movs	r3, #8
 8004332:	2228      	movs	r2, #40	; 0x28
 8004334:	462c      	mov	r4, r5
 8004336:	f7fe fa93 	bl	8002860 <gsl_error>
 800433a:	e7f5      	b.n	8004328 <gsl_matrix_ushort_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800433c:	4903      	ldr	r1, [pc, #12]	; (800434c <gsl_matrix_ushort_alloc+0x50>)
 800433e:	4805      	ldr	r0, [pc, #20]	; (8004354 <gsl_matrix_ushort_alloc+0x58>)
 8004340:	2308      	movs	r3, #8
 8004342:	221e      	movs	r2, #30
 8004344:	f7fe fa8c 	bl	8002860 <gsl_error>
 8004348:	e7ee      	b.n	8004328 <gsl_matrix_ushort_alloc+0x2c>
 800434a:	bf00      	nop
 800434c:	08030f9c 	.word	0x08030f9c
 8004350:	08030fd8 	.word	0x08030fd8
 8004354:	08030fac 	.word	0x08030fac

08004358 <gsl_matrix_ushort_calloc>:
{
 8004358:	b570      	push	{r4, r5, r6, lr}
 800435a:	4604      	mov	r4, r0
 800435c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 800435e:	f7ff ffcd 	bl	80042fc <gsl_matrix_ushort_alloc>
  if (m == 0)
 8004362:	4605      	mov	r5, r0
 8004364:	b188      	cbz	r0, 800438a <gsl_matrix_ushort_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8004366:	fb06 f604 	mul.w	r6, r6, r4
 800436a:	0074      	lsls	r4, r6, #1
 800436c:	68c0      	ldr	r0, [r0, #12]
 800436e:	4622      	mov	r2, r4
 8004370:	2100      	movs	r1, #0
 8004372:	f02b fea7 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004376:	b146      	cbz	r6, 800438a <gsl_matrix_ushort_calloc+0x32>
      m->data[i] = 0;
 8004378:	68eb      	ldr	r3, [r5, #12]
 800437a:	1ea2      	subs	r2, r4, #2
 800437c:	441a      	add	r2, r3
 800437e:	2100      	movs	r1, #0
 8004380:	3b02      	subs	r3, #2
 8004382:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004386:	4293      	cmp	r3, r2
 8004388:	d1fb      	bne.n	8004382 <gsl_matrix_ushort_calloc+0x2a>
}
 800438a:	4628      	mov	r0, r5
 800438c:	bd70      	pop	{r4, r5, r6, pc}
 800438e:	bf00      	nop

08004390 <gsl_matrix_ushort_alloc_from_block>:
{
 8004390:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004394:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004398:	4599      	cmp	r9, r3
 800439a:	d325      	bcc.n	80043e8 <gsl_matrix_ushort_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 800439c:	4690      	mov	r8, r2
 800439e:	6802      	ldr	r2, [r0, #0]
 80043a0:	461e      	mov	r6, r3
 80043a2:	fb08 1309 	mla	r3, r8, r9, r1
 80043a6:	429a      	cmp	r2, r3
 80043a8:	4605      	mov	r5, r0
 80043aa:	460f      	mov	r7, r1
 80043ac:	d312      	bcc.n	80043d4 <gsl_matrix_ushort_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80043ae:	2018      	movs	r0, #24
 80043b0:	f02b fe78 	bl	80300a4 <malloc>
  if (m == 0)
 80043b4:	4604      	mov	r4, r0
 80043b6:	b1f8      	cbz	r0, 80043f8 <gsl_matrix_ushort_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 80043b8:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 80043ba:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 80043be:	eb01 0147 	add.w	r1, r1, r7, lsl #1
  m->tda = d2;
 80043c2:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80043c6:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80043ca:	2300      	movs	r3, #0
 80043cc:	6143      	str	r3, [r0, #20]
}
 80043ce:	4620      	mov	r0, r4
 80043d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 80043d4:	490c      	ldr	r1, [pc, #48]	; (8004408 <gsl_matrix_ushort_alloc_from_block+0x78>)
 80043d6:	480d      	ldr	r0, [pc, #52]	; (800440c <gsl_matrix_ushort_alloc_from_block+0x7c>)
 80043d8:	2304      	movs	r3, #4
 80043da:	225b      	movs	r2, #91	; 0x5b
 80043dc:	2400      	movs	r4, #0
 80043de:	f7fe fa3f 	bl	8002860 <gsl_error>
}
 80043e2:	4620      	mov	r0, r4
 80043e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 80043e8:	4907      	ldr	r1, [pc, #28]	; (8004408 <gsl_matrix_ushort_alloc_from_block+0x78>)
 80043ea:	4809      	ldr	r0, [pc, #36]	; (8004410 <gsl_matrix_ushort_alloc_from_block+0x80>)
 80043ec:	2304      	movs	r3, #4
 80043ee:	2256      	movs	r2, #86	; 0x56
 80043f0:	f7fe fa36 	bl	8002860 <gsl_error>
 80043f4:	2400      	movs	r4, #0
 80043f6:	e7ea      	b.n	80043ce <gsl_matrix_ushort_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80043f8:	4903      	ldr	r1, [pc, #12]	; (8004408 <gsl_matrix_ushort_alloc_from_block+0x78>)
 80043fa:	4806      	ldr	r0, [pc, #24]	; (8004414 <gsl_matrix_ushort_alloc_from_block+0x84>)
 80043fc:	2308      	movs	r3, #8
 80043fe:	2263      	movs	r2, #99	; 0x63
 8004400:	f7fe fa2e 	bl	8002860 <gsl_error>
 8004404:	e7e3      	b.n	80043ce <gsl_matrix_ushort_alloc_from_block+0x3e>
 8004406:	bf00      	nop
 8004408:	08030f9c 	.word	0x08030f9c
 800440c:	08031028 	.word	0x08031028
 8004410:	08030ffc 	.word	0x08030ffc
 8004414:	08030fac 	.word	0x08030fac

08004418 <gsl_matrix_ushort_alloc_from_matrix>:
{
 8004418:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800441c:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 800441e:	6803      	ldr	r3, [r0, #0]
{
 8004420:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004424:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8004426:	19c8      	adds	r0, r1, r7
 8004428:	4298      	cmp	r0, r3
 800442a:	d826      	bhi.n	800447a <gsl_matrix_ushort_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 800442c:	686b      	ldr	r3, [r5, #4]
 800442e:	4690      	mov	r8, r2
 8004430:	444a      	add	r2, r9
 8004432:	429a      	cmp	r2, r3
 8004434:	d817      	bhi.n	8004466 <gsl_matrix_ushort_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004436:	2018      	movs	r0, #24
 8004438:	460e      	mov	r6, r1
 800443a:	f02b fe33 	bl	80300a4 <malloc>
  if (m == 0)
 800443e:	4604      	mov	r4, r0
 8004440:	b318      	cbz	r0, 800448a <gsl_matrix_ushort_alloc_from_matrix+0x72>
  m->size1 = n1;
 8004442:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004444:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8004446:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 800444a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 800444e:	fb06 8603 	mla	r6, r6, r3, r8
 8004452:	eb01 0646 	add.w	r6, r1, r6, lsl #1
  m->owner = 0;
 8004456:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004458:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 800445c:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8004460:	4620      	mov	r0, r4
 8004462:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8004466:	490c      	ldr	r1, [pc, #48]	; (8004498 <gsl_matrix_ushort_alloc_from_matrix+0x80>)
 8004468:	480c      	ldr	r0, [pc, #48]	; (800449c <gsl_matrix_ushort_alloc_from_matrix+0x84>)
 800446a:	2304      	movs	r3, #4
 800446c:	2282      	movs	r2, #130	; 0x82
 800446e:	2400      	movs	r4, #0
 8004470:	f7fe f9f6 	bl	8002860 <gsl_error>
}
 8004474:	4620      	mov	r0, r4
 8004476:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 800447a:	4907      	ldr	r1, [pc, #28]	; (8004498 <gsl_matrix_ushort_alloc_from_matrix+0x80>)
 800447c:	4808      	ldr	r0, [pc, #32]	; (80044a0 <gsl_matrix_ushort_alloc_from_matrix+0x88>)
 800447e:	2304      	movs	r3, #4
 8004480:	227d      	movs	r2, #125	; 0x7d
 8004482:	f7fe f9ed 	bl	8002860 <gsl_error>
 8004486:	2400      	movs	r4, #0
 8004488:	e7ea      	b.n	8004460 <gsl_matrix_ushort_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800448a:	4903      	ldr	r1, [pc, #12]	; (8004498 <gsl_matrix_ushort_alloc_from_matrix+0x80>)
 800448c:	4805      	ldr	r0, [pc, #20]	; (80044a4 <gsl_matrix_ushort_alloc_from_matrix+0x8c>)
 800448e:	2308      	movs	r3, #8
 8004490:	228a      	movs	r2, #138	; 0x8a
 8004492:	f7fe f9e5 	bl	8002860 <gsl_error>
 8004496:	e7e3      	b.n	8004460 <gsl_matrix_ushort_alloc_from_matrix+0x48>
 8004498:	08030f9c 	.word	0x08030f9c
 800449c:	08031084 	.word	0x08031084
 80044a0:	08031054 	.word	0x08031054
 80044a4:	08030fac 	.word	0x08030fac

080044a8 <gsl_matrix_ushort_free>:
  RETURN_IF_NULL (m);
 80044a8:	b180      	cbz	r0, 80044cc <gsl_matrix_ushort_free+0x24>
  if (m->owner)
 80044aa:	6943      	ldr	r3, [r0, #20]
{
 80044ac:	b510      	push	{r4, lr}
 80044ae:	4604      	mov	r4, r0
  if (m->owner)
 80044b0:	b923      	cbnz	r3, 80044bc <gsl_matrix_ushort_free+0x14>
  free (m);
 80044b2:	4620      	mov	r0, r4
}
 80044b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80044b8:	f02b bdfc 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 80044bc:	6900      	ldr	r0, [r0, #16]
 80044be:	f003 fc1d 	bl	8007cfc <gsl_block_ushort_free>
  free (m);
 80044c2:	4620      	mov	r0, r4
}
 80044c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80044c8:	f02b bdf4 	b.w	80300b4 <free>
 80044cc:	4770      	bx	lr
 80044ce:	bf00      	nop

080044d0 <gsl_matrix_ushort_set_identity>:
{
 80044d0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80044d2:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80044d4:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 80044d6:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 80044da:	b19e      	cbz	r6, 8004504 <gsl_matrix_ushort_set_identity+0x34>
 80044dc:	2500      	movs	r5, #0
 80044de:	3f02      	subs	r7, #2
 80044e0:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 80044e2:	b15c      	cbz	r4, 80044fc <gsl_matrix_ushort_set_identity+0x2c>
 80044e4:	eb07 0245 	add.w	r2, r7, r5, lsl #1
 80044e8:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80044ea:	1ac1      	subs	r1, r0, r3
 80044ec:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 80044f0:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80044f2:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 80044f4:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80044f6:	f822 1f02 	strh.w	r1, [r2, #2]!
      for (j = 0; j < q; j++)
 80044fa:	d1f6      	bne.n	80044ea <gsl_matrix_ushort_set_identity+0x1a>
  for (i = 0; i < p; i++)
 80044fc:	3001      	adds	r0, #1
 80044fe:	4286      	cmp	r6, r0
 8004500:	4465      	add	r5, ip
 8004502:	d1ee      	bne.n	80044e2 <gsl_matrix_ushort_set_identity+0x12>
}
 8004504:	bcf0      	pop	{r4, r5, r6, r7}
 8004506:	4770      	bx	lr

08004508 <gsl_matrix_ushort_set_zero>:
{
 8004508:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800450a:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 800450c:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800450e:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8004512:	b18f      	cbz	r7, 8004538 <gsl_matrix_ushort_set_zero+0x30>
 8004514:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 8004518:	2000      	movs	r0, #0
 800451a:	0076      	lsls	r6, r6, #1
 800451c:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 8004520:	006d      	lsls	r5, r5, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004522:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8004524:	1953      	adds	r3, r2, r5
 8004526:	b11c      	cbz	r4, 8004530 <gsl_matrix_ushort_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004528:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 800452c:	4293      	cmp	r3, r2
 800452e:	d1fb      	bne.n	8004528 <gsl_matrix_ushort_set_zero+0x20>
  for (i = 0; i < p; i++)
 8004530:	3001      	adds	r0, #1
 8004532:	4287      	cmp	r7, r0
 8004534:	4432      	add	r2, r6
 8004536:	d1f5      	bne.n	8004524 <gsl_matrix_ushort_set_zero+0x1c>
}
 8004538:	bcf0      	pop	{r4, r5, r6, r7}
 800453a:	4770      	bx	lr

0800453c <gsl_matrix_ushort_set_all>:
{
 800453c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800453e:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004540:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8004542:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8004546:	b187      	cbz	r7, 800456a <gsl_matrix_ushort_set_all+0x2e>
 8004548:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 800454c:	0076      	lsls	r6, r6, #1
 800454e:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 8004552:	006d      	lsls	r5, r5, #1
 8004554:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 8004556:	1953      	adds	r3, r2, r5
 8004558:	b11c      	cbz	r4, 8004562 <gsl_matrix_ushort_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 800455a:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 800455e:	4293      	cmp	r3, r2
 8004560:	d1fb      	bne.n	800455a <gsl_matrix_ushort_set_all+0x1e>
  for (i = 0; i < p; i++)
 8004562:	3001      	adds	r0, #1
 8004564:	4287      	cmp	r7, r0
 8004566:	4432      	add	r2, r6
 8004568:	d1f5      	bne.n	8004556 <gsl_matrix_ushort_set_all+0x1a>
}
 800456a:	bcf0      	pop	{r4, r5, r6, r7}
 800456c:	4770      	bx	lr
 800456e:	bf00      	nop

08004570 <gsl_matrix_short_alloc>:
{
 8004570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004572:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004574:	2018      	movs	r0, #24
{
 8004576:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004578:	f02b fd94 	bl	80300a4 <malloc>
  if (m == 0)
 800457c:	4604      	mov	r4, r0
 800457e:	b1b8      	cbz	r0, 80045b0 <gsl_matrix_short_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8004580:	fb06 f007 	mul.w	r0, r6, r7
 8004584:	f003 fbc6 	bl	8007d14 <gsl_block_short_alloc>
  if (block == 0)
 8004588:	4605      	mov	r5, r0
 800458a:	b148      	cbz	r0, 80045a0 <gsl_matrix_short_alloc+0x30>
  m->data = block->data;
 800458c:	6843      	ldr	r3, [r0, #4]
 800458e:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8004590:	2301      	movs	r3, #1
  m->size2 = n2;
 8004592:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8004596:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 800459a:	60a6      	str	r6, [r4, #8]
}
 800459c:	4620      	mov	r0, r4
 800459e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80045a0:	4907      	ldr	r1, [pc, #28]	; (80045c0 <gsl_matrix_short_alloc+0x50>)
 80045a2:	4808      	ldr	r0, [pc, #32]	; (80045c4 <gsl_matrix_short_alloc+0x54>)
 80045a4:	2308      	movs	r3, #8
 80045a6:	2228      	movs	r2, #40	; 0x28
 80045a8:	462c      	mov	r4, r5
 80045aa:	f7fe f959 	bl	8002860 <gsl_error>
 80045ae:	e7f5      	b.n	800459c <gsl_matrix_short_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80045b0:	4903      	ldr	r1, [pc, #12]	; (80045c0 <gsl_matrix_short_alloc+0x50>)
 80045b2:	4805      	ldr	r0, [pc, #20]	; (80045c8 <gsl_matrix_short_alloc+0x58>)
 80045b4:	2308      	movs	r3, #8
 80045b6:	221e      	movs	r2, #30
 80045b8:	f7fe f952 	bl	8002860 <gsl_error>
 80045bc:	e7ee      	b.n	800459c <gsl_matrix_short_alloc+0x2c>
 80045be:	bf00      	nop
 80045c0:	08030f9c 	.word	0x08030f9c
 80045c4:	08030fd8 	.word	0x08030fd8
 80045c8:	08030fac 	.word	0x08030fac

080045cc <gsl_matrix_short_calloc>:
{
 80045cc:	b570      	push	{r4, r5, r6, lr}
 80045ce:	4604      	mov	r4, r0
 80045d0:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80045d2:	f7ff ffcd 	bl	8004570 <gsl_matrix_short_alloc>
  if (m == 0)
 80045d6:	4605      	mov	r5, r0
 80045d8:	b188      	cbz	r0, 80045fe <gsl_matrix_short_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80045da:	fb06 f604 	mul.w	r6, r6, r4
 80045de:	0074      	lsls	r4, r6, #1
 80045e0:	68c0      	ldr	r0, [r0, #12]
 80045e2:	4622      	mov	r2, r4
 80045e4:	2100      	movs	r1, #0
 80045e6:	f02b fd6d 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80045ea:	b146      	cbz	r6, 80045fe <gsl_matrix_short_calloc+0x32>
      m->data[i] = 0;
 80045ec:	68eb      	ldr	r3, [r5, #12]
 80045ee:	1ea2      	subs	r2, r4, #2
 80045f0:	441a      	add	r2, r3
 80045f2:	2100      	movs	r1, #0
 80045f4:	3b02      	subs	r3, #2
 80045f6:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80045fa:	4293      	cmp	r3, r2
 80045fc:	d1fb      	bne.n	80045f6 <gsl_matrix_short_calloc+0x2a>
}
 80045fe:	4628      	mov	r0, r5
 8004600:	bd70      	pop	{r4, r5, r6, pc}
 8004602:	bf00      	nop

08004604 <gsl_matrix_short_alloc_from_block>:
{
 8004604:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004608:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 800460c:	4599      	cmp	r9, r3
 800460e:	d325      	bcc.n	800465c <gsl_matrix_short_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8004610:	4690      	mov	r8, r2
 8004612:	6802      	ldr	r2, [r0, #0]
 8004614:	461e      	mov	r6, r3
 8004616:	fb08 1309 	mla	r3, r8, r9, r1
 800461a:	429a      	cmp	r2, r3
 800461c:	4605      	mov	r5, r0
 800461e:	460f      	mov	r7, r1
 8004620:	d312      	bcc.n	8004648 <gsl_matrix_short_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004622:	2018      	movs	r0, #24
 8004624:	f02b fd3e 	bl	80300a4 <malloc>
  if (m == 0)
 8004628:	4604      	mov	r4, r0
 800462a:	b1f8      	cbz	r0, 800466c <gsl_matrix_short_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 800462c:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 800462e:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8004632:	eb01 0147 	add.w	r1, r1, r7, lsl #1
  m->tda = d2;
 8004636:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 800463a:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 800463e:	2300      	movs	r3, #0
 8004640:	6143      	str	r3, [r0, #20]
}
 8004642:	4620      	mov	r0, r4
 8004644:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8004648:	490c      	ldr	r1, [pc, #48]	; (800467c <gsl_matrix_short_alloc_from_block+0x78>)
 800464a:	480d      	ldr	r0, [pc, #52]	; (8004680 <gsl_matrix_short_alloc_from_block+0x7c>)
 800464c:	2304      	movs	r3, #4
 800464e:	225b      	movs	r2, #91	; 0x5b
 8004650:	2400      	movs	r4, #0
 8004652:	f7fe f905 	bl	8002860 <gsl_error>
}
 8004656:	4620      	mov	r0, r4
 8004658:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 800465c:	4907      	ldr	r1, [pc, #28]	; (800467c <gsl_matrix_short_alloc_from_block+0x78>)
 800465e:	4809      	ldr	r0, [pc, #36]	; (8004684 <gsl_matrix_short_alloc_from_block+0x80>)
 8004660:	2304      	movs	r3, #4
 8004662:	2256      	movs	r2, #86	; 0x56
 8004664:	f7fe f8fc 	bl	8002860 <gsl_error>
 8004668:	2400      	movs	r4, #0
 800466a:	e7ea      	b.n	8004642 <gsl_matrix_short_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800466c:	4903      	ldr	r1, [pc, #12]	; (800467c <gsl_matrix_short_alloc_from_block+0x78>)
 800466e:	4806      	ldr	r0, [pc, #24]	; (8004688 <gsl_matrix_short_alloc_from_block+0x84>)
 8004670:	2308      	movs	r3, #8
 8004672:	2263      	movs	r2, #99	; 0x63
 8004674:	f7fe f8f4 	bl	8002860 <gsl_error>
 8004678:	e7e3      	b.n	8004642 <gsl_matrix_short_alloc_from_block+0x3e>
 800467a:	bf00      	nop
 800467c:	08030f9c 	.word	0x08030f9c
 8004680:	08031028 	.word	0x08031028
 8004684:	08030ffc 	.word	0x08030ffc
 8004688:	08030fac 	.word	0x08030fac

0800468c <gsl_matrix_short_alloc_from_matrix>:
{
 800468c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004690:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8004692:	6803      	ldr	r3, [r0, #0]
{
 8004694:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004698:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 800469a:	19c8      	adds	r0, r1, r7
 800469c:	4298      	cmp	r0, r3
 800469e:	d826      	bhi.n	80046ee <gsl_matrix_short_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80046a0:	686b      	ldr	r3, [r5, #4]
 80046a2:	4690      	mov	r8, r2
 80046a4:	444a      	add	r2, r9
 80046a6:	429a      	cmp	r2, r3
 80046a8:	d817      	bhi.n	80046da <gsl_matrix_short_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80046aa:	2018      	movs	r0, #24
 80046ac:	460e      	mov	r6, r1
 80046ae:	f02b fcf9 	bl	80300a4 <malloc>
  if (m == 0)
 80046b2:	4604      	mov	r4, r0
 80046b4:	b318      	cbz	r0, 80046fe <gsl_matrix_short_alloc_from_matrix+0x72>
  m->size1 = n1;
 80046b6:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80046b8:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80046ba:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80046be:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80046c2:	fb06 8603 	mla	r6, r6, r3, r8
 80046c6:	eb01 0646 	add.w	r6, r1, r6, lsl #1
  m->owner = 0;
 80046ca:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 80046cc:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 80046d0:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 80046d4:	4620      	mov	r0, r4
 80046d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 80046da:	490c      	ldr	r1, [pc, #48]	; (800470c <gsl_matrix_short_alloc_from_matrix+0x80>)
 80046dc:	480c      	ldr	r0, [pc, #48]	; (8004710 <gsl_matrix_short_alloc_from_matrix+0x84>)
 80046de:	2304      	movs	r3, #4
 80046e0:	2282      	movs	r2, #130	; 0x82
 80046e2:	2400      	movs	r4, #0
 80046e4:	f7fe f8bc 	bl	8002860 <gsl_error>
}
 80046e8:	4620      	mov	r0, r4
 80046ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 80046ee:	4907      	ldr	r1, [pc, #28]	; (800470c <gsl_matrix_short_alloc_from_matrix+0x80>)
 80046f0:	4808      	ldr	r0, [pc, #32]	; (8004714 <gsl_matrix_short_alloc_from_matrix+0x88>)
 80046f2:	2304      	movs	r3, #4
 80046f4:	227d      	movs	r2, #125	; 0x7d
 80046f6:	f7fe f8b3 	bl	8002860 <gsl_error>
 80046fa:	2400      	movs	r4, #0
 80046fc:	e7ea      	b.n	80046d4 <gsl_matrix_short_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80046fe:	4903      	ldr	r1, [pc, #12]	; (800470c <gsl_matrix_short_alloc_from_matrix+0x80>)
 8004700:	4805      	ldr	r0, [pc, #20]	; (8004718 <gsl_matrix_short_alloc_from_matrix+0x8c>)
 8004702:	2308      	movs	r3, #8
 8004704:	228a      	movs	r2, #138	; 0x8a
 8004706:	f7fe f8ab 	bl	8002860 <gsl_error>
 800470a:	e7e3      	b.n	80046d4 <gsl_matrix_short_alloc_from_matrix+0x48>
 800470c:	08030f9c 	.word	0x08030f9c
 8004710:	08031084 	.word	0x08031084
 8004714:	08031054 	.word	0x08031054
 8004718:	08030fac 	.word	0x08030fac

0800471c <gsl_matrix_short_free>:
  RETURN_IF_NULL (m);
 800471c:	b180      	cbz	r0, 8004740 <gsl_matrix_short_free+0x24>
  if (m->owner)
 800471e:	6943      	ldr	r3, [r0, #20]
{
 8004720:	b510      	push	{r4, lr}
 8004722:	4604      	mov	r4, r0
  if (m->owner)
 8004724:	b923      	cbnz	r3, 8004730 <gsl_matrix_short_free+0x14>
  free (m);
 8004726:	4620      	mov	r0, r4
}
 8004728:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 800472c:	f02b bcc2 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004730:	6900      	ldr	r0, [r0, #16]
 8004732:	f003 fb31 	bl	8007d98 <gsl_block_short_free>
  free (m);
 8004736:	4620      	mov	r0, r4
}
 8004738:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 800473c:	f02b bcba 	b.w	80300b4 <free>
 8004740:	4770      	bx	lr
 8004742:	bf00      	nop

08004744 <gsl_matrix_short_set_identity>:
{
 8004744:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004746:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004748:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 800474a:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 800474e:	b19e      	cbz	r6, 8004778 <gsl_matrix_short_set_identity+0x34>
 8004750:	2500      	movs	r5, #0
 8004752:	3f02      	subs	r7, #2
 8004754:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8004756:	b15c      	cbz	r4, 8004770 <gsl_matrix_short_set_identity+0x2c>
 8004758:	eb07 0245 	add.w	r2, r7, r5, lsl #1
 800475c:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800475e:	1ac1      	subs	r1, r0, r3
 8004760:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8004764:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004766:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8004768:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800476a:	f822 1f02 	strh.w	r1, [r2, #2]!
      for (j = 0; j < q; j++)
 800476e:	d1f6      	bne.n	800475e <gsl_matrix_short_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8004770:	3001      	adds	r0, #1
 8004772:	4286      	cmp	r6, r0
 8004774:	4465      	add	r5, ip
 8004776:	d1ee      	bne.n	8004756 <gsl_matrix_short_set_identity+0x12>
}
 8004778:	bcf0      	pop	{r4, r5, r6, r7}
 800477a:	4770      	bx	lr

0800477c <gsl_matrix_short_set_zero>:
{
 800477c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800477e:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004780:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8004782:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8004786:	b18f      	cbz	r7, 80047ac <gsl_matrix_short_set_zero+0x30>
 8004788:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 800478c:	2000      	movs	r0, #0
 800478e:	0076      	lsls	r6, r6, #1
 8004790:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 8004794:	006d      	lsls	r5, r5, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004796:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8004798:	1953      	adds	r3, r2, r5
 800479a:	b11c      	cbz	r4, 80047a4 <gsl_matrix_short_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800479c:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 80047a0:	4293      	cmp	r3, r2
 80047a2:	d1fb      	bne.n	800479c <gsl_matrix_short_set_zero+0x20>
  for (i = 0; i < p; i++)
 80047a4:	3001      	adds	r0, #1
 80047a6:	4287      	cmp	r7, r0
 80047a8:	4432      	add	r2, r6
 80047aa:	d1f5      	bne.n	8004798 <gsl_matrix_short_set_zero+0x1c>
}
 80047ac:	bcf0      	pop	{r4, r5, r6, r7}
 80047ae:	4770      	bx	lr

080047b0 <gsl_matrix_short_set_all>:
{
 80047b0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80047b2:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80047b4:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80047b6:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 80047ba:	b187      	cbz	r7, 80047de <gsl_matrix_short_set_all+0x2e>
 80047bc:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 80047c0:	0076      	lsls	r6, r6, #1
 80047c2:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 80047c6:	006d      	lsls	r5, r5, #1
 80047c8:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 80047ca:	1953      	adds	r3, r2, r5
 80047cc:	b11c      	cbz	r4, 80047d6 <gsl_matrix_short_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 80047ce:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 80047d2:	4293      	cmp	r3, r2
 80047d4:	d1fb      	bne.n	80047ce <gsl_matrix_short_set_all+0x1e>
  for (i = 0; i < p; i++)
 80047d6:	3001      	adds	r0, #1
 80047d8:	4287      	cmp	r7, r0
 80047da:	4432      	add	r2, r6
 80047dc:	d1f5      	bne.n	80047ca <gsl_matrix_short_set_all+0x1a>
}
 80047de:	bcf0      	pop	{r4, r5, r6, r7}
 80047e0:	4770      	bx	lr
 80047e2:	bf00      	nop

080047e4 <gsl_matrix_uchar_alloc>:
{
 80047e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80047e6:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80047e8:	2018      	movs	r0, #24
{
 80047ea:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80047ec:	f02b fc5a 	bl	80300a4 <malloc>
  if (m == 0)
 80047f0:	4604      	mov	r4, r0
 80047f2:	b1b8      	cbz	r0, 8004824 <gsl_matrix_uchar_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 80047f4:	fb06 f007 	mul.w	r0, r6, r7
 80047f8:	f003 fada 	bl	8007db0 <gsl_block_uchar_alloc>
  if (block == 0)
 80047fc:	4605      	mov	r5, r0
 80047fe:	b148      	cbz	r0, 8004814 <gsl_matrix_uchar_alloc+0x30>
  m->data = block->data;
 8004800:	6843      	ldr	r3, [r0, #4]
 8004802:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8004804:	2301      	movs	r3, #1
  m->size2 = n2;
 8004806:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 800480a:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 800480e:	60a6      	str	r6, [r4, #8]
}
 8004810:	4620      	mov	r0, r4
 8004812:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8004814:	4907      	ldr	r1, [pc, #28]	; (8004834 <gsl_matrix_uchar_alloc+0x50>)
 8004816:	4808      	ldr	r0, [pc, #32]	; (8004838 <gsl_matrix_uchar_alloc+0x54>)
 8004818:	2308      	movs	r3, #8
 800481a:	2228      	movs	r2, #40	; 0x28
 800481c:	462c      	mov	r4, r5
 800481e:	f7fe f81f 	bl	8002860 <gsl_error>
 8004822:	e7f5      	b.n	8004810 <gsl_matrix_uchar_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004824:	4903      	ldr	r1, [pc, #12]	; (8004834 <gsl_matrix_uchar_alloc+0x50>)
 8004826:	4805      	ldr	r0, [pc, #20]	; (800483c <gsl_matrix_uchar_alloc+0x58>)
 8004828:	2308      	movs	r3, #8
 800482a:	221e      	movs	r2, #30
 800482c:	f7fe f818 	bl	8002860 <gsl_error>
 8004830:	e7ee      	b.n	8004810 <gsl_matrix_uchar_alloc+0x2c>
 8004832:	bf00      	nop
 8004834:	08030f9c 	.word	0x08030f9c
 8004838:	08030fd8 	.word	0x08030fd8
 800483c:	08030fac 	.word	0x08030fac

08004840 <gsl_matrix_uchar_calloc>:
{
 8004840:	b570      	push	{r4, r5, r6, lr}
 8004842:	4606      	mov	r6, r0
 8004844:	460c      	mov	r4, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8004846:	f7ff ffcd 	bl	80047e4 <gsl_matrix_uchar_alloc>
  if (m == 0)
 800484a:	4605      	mov	r5, r0
 800484c:	b170      	cbz	r0, 800486c <gsl_matrix_uchar_calloc+0x2c>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 800484e:	fb04 f406 	mul.w	r4, r4, r6
 8004852:	68c0      	ldr	r0, [r0, #12]
 8004854:	4622      	mov	r2, r4
 8004856:	2100      	movs	r1, #0
 8004858:	f02b fc34 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 800485c:	b134      	cbz	r4, 800486c <gsl_matrix_uchar_calloc+0x2c>
 800485e:	2300      	movs	r3, #0
      m->data[i] = 0;
 8004860:	461a      	mov	r2, r3
 8004862:	68e9      	ldr	r1, [r5, #12]
 8004864:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004866:	3301      	adds	r3, #1
 8004868:	429c      	cmp	r4, r3
 800486a:	d1fa      	bne.n	8004862 <gsl_matrix_uchar_calloc+0x22>
}
 800486c:	4628      	mov	r0, r5
 800486e:	bd70      	pop	{r4, r5, r6, pc}

08004870 <gsl_matrix_uchar_alloc_from_block>:
{
 8004870:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004874:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004878:	4599      	cmp	r9, r3
 800487a:	d324      	bcc.n	80048c6 <gsl_matrix_uchar_alloc_from_block+0x56>
  else if (block->size < offset + n1 * d2)
 800487c:	4690      	mov	r8, r2
 800487e:	6802      	ldr	r2, [r0, #0]
 8004880:	461e      	mov	r6, r3
 8004882:	fb08 1309 	mla	r3, r8, r9, r1
 8004886:	429a      	cmp	r2, r3
 8004888:	4605      	mov	r5, r0
 800488a:	460f      	mov	r7, r1
 800488c:	d311      	bcc.n	80048b2 <gsl_matrix_uchar_alloc_from_block+0x42>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800488e:	2018      	movs	r0, #24
 8004890:	f02b fc08 	bl	80300a4 <malloc>
  if (m == 0)
 8004894:	4604      	mov	r4, r0
 8004896:	b1f0      	cbz	r0, 80048d6 <gsl_matrix_uchar_alloc_from_block+0x66>
  m->data = block->data + MULTIPLICITY * offset;
 8004898:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 800489a:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800489e:	4439      	add	r1, r7
  m->tda = d2;
 80048a0:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80048a4:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80048a8:	2300      	movs	r3, #0
 80048aa:	6143      	str	r3, [r0, #20]
}
 80048ac:	4620      	mov	r0, r4
 80048ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 80048b2:	490c      	ldr	r1, [pc, #48]	; (80048e4 <gsl_matrix_uchar_alloc_from_block+0x74>)
 80048b4:	480c      	ldr	r0, [pc, #48]	; (80048e8 <gsl_matrix_uchar_alloc_from_block+0x78>)
 80048b6:	2304      	movs	r3, #4
 80048b8:	225b      	movs	r2, #91	; 0x5b
 80048ba:	2400      	movs	r4, #0
 80048bc:	f7fd ffd0 	bl	8002860 <gsl_error>
}
 80048c0:	4620      	mov	r0, r4
 80048c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 80048c6:	4907      	ldr	r1, [pc, #28]	; (80048e4 <gsl_matrix_uchar_alloc_from_block+0x74>)
 80048c8:	4808      	ldr	r0, [pc, #32]	; (80048ec <gsl_matrix_uchar_alloc_from_block+0x7c>)
 80048ca:	2304      	movs	r3, #4
 80048cc:	2256      	movs	r2, #86	; 0x56
 80048ce:	f7fd ffc7 	bl	8002860 <gsl_error>
 80048d2:	2400      	movs	r4, #0
 80048d4:	e7ea      	b.n	80048ac <gsl_matrix_uchar_alloc_from_block+0x3c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80048d6:	4903      	ldr	r1, [pc, #12]	; (80048e4 <gsl_matrix_uchar_alloc_from_block+0x74>)
 80048d8:	4805      	ldr	r0, [pc, #20]	; (80048f0 <gsl_matrix_uchar_alloc_from_block+0x80>)
 80048da:	2308      	movs	r3, #8
 80048dc:	2263      	movs	r2, #99	; 0x63
 80048de:	f7fd ffbf 	bl	8002860 <gsl_error>
 80048e2:	e7e3      	b.n	80048ac <gsl_matrix_uchar_alloc_from_block+0x3c>
 80048e4:	08030f9c 	.word	0x08030f9c
 80048e8:	08031028 	.word	0x08031028
 80048ec:	08030ffc 	.word	0x08030ffc
 80048f0:	08030fac 	.word	0x08030fac

080048f4 <gsl_matrix_uchar_alloc_from_matrix>:
{
 80048f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80048f8:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 80048fa:	6803      	ldr	r3, [r0, #0]
{
 80048fc:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004900:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8004902:	19c8      	adds	r0, r1, r7
 8004904:	4298      	cmp	r0, r3
 8004906:	d825      	bhi.n	8004954 <gsl_matrix_uchar_alloc_from_matrix+0x60>
  else if (k2 + n2 > mm->size2)
 8004908:	686b      	ldr	r3, [r5, #4]
 800490a:	4690      	mov	r8, r2
 800490c:	444a      	add	r2, r9
 800490e:	429a      	cmp	r2, r3
 8004910:	d816      	bhi.n	8004940 <gsl_matrix_uchar_alloc_from_matrix+0x4c>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004912:	2018      	movs	r0, #24
 8004914:	460e      	mov	r6, r1
 8004916:	f02b fbc5 	bl	80300a4 <malloc>
  if (m == 0)
 800491a:	4604      	mov	r4, r0
 800491c:	b310      	cbz	r0, 8004964 <gsl_matrix_uchar_alloc_from_matrix+0x70>
  m->size1 = n1;
 800491e:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004920:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8004922:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8004926:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 800492a:	fb06 8603 	mla	r6, r6, r3, r8
 800492e:	440e      	add	r6, r1
  m->owner = 0;
 8004930:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004932:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8004936:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 800493a:	4620      	mov	r0, r4
 800493c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8004940:	490c      	ldr	r1, [pc, #48]	; (8004974 <gsl_matrix_uchar_alloc_from_matrix+0x80>)
 8004942:	480d      	ldr	r0, [pc, #52]	; (8004978 <gsl_matrix_uchar_alloc_from_matrix+0x84>)
 8004944:	2304      	movs	r3, #4
 8004946:	2282      	movs	r2, #130	; 0x82
 8004948:	2400      	movs	r4, #0
 800494a:	f7fd ff89 	bl	8002860 <gsl_error>
}
 800494e:	4620      	mov	r0, r4
 8004950:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8004954:	4907      	ldr	r1, [pc, #28]	; (8004974 <gsl_matrix_uchar_alloc_from_matrix+0x80>)
 8004956:	4809      	ldr	r0, [pc, #36]	; (800497c <gsl_matrix_uchar_alloc_from_matrix+0x88>)
 8004958:	2304      	movs	r3, #4
 800495a:	227d      	movs	r2, #125	; 0x7d
 800495c:	f7fd ff80 	bl	8002860 <gsl_error>
 8004960:	2400      	movs	r4, #0
 8004962:	e7ea      	b.n	800493a <gsl_matrix_uchar_alloc_from_matrix+0x46>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004964:	4903      	ldr	r1, [pc, #12]	; (8004974 <gsl_matrix_uchar_alloc_from_matrix+0x80>)
 8004966:	4806      	ldr	r0, [pc, #24]	; (8004980 <gsl_matrix_uchar_alloc_from_matrix+0x8c>)
 8004968:	2308      	movs	r3, #8
 800496a:	228a      	movs	r2, #138	; 0x8a
 800496c:	f7fd ff78 	bl	8002860 <gsl_error>
 8004970:	e7e3      	b.n	800493a <gsl_matrix_uchar_alloc_from_matrix+0x46>
 8004972:	bf00      	nop
 8004974:	08030f9c 	.word	0x08030f9c
 8004978:	08031084 	.word	0x08031084
 800497c:	08031054 	.word	0x08031054
 8004980:	08030fac 	.word	0x08030fac

08004984 <gsl_matrix_uchar_free>:
  RETURN_IF_NULL (m);
 8004984:	b180      	cbz	r0, 80049a8 <gsl_matrix_uchar_free+0x24>
  if (m->owner)
 8004986:	6943      	ldr	r3, [r0, #20]
{
 8004988:	b510      	push	{r4, lr}
 800498a:	4604      	mov	r4, r0
  if (m->owner)
 800498c:	b923      	cbnz	r3, 8004998 <gsl_matrix_uchar_free+0x14>
  free (m);
 800498e:	4620      	mov	r0, r4
}
 8004990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004994:	f02b bb8e 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004998:	6900      	ldr	r0, [r0, #16]
 800499a:	f003 fa49 	bl	8007e30 <gsl_block_uchar_free>
  free (m);
 800499e:	4620      	mov	r0, r4
}
 80049a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80049a4:	f02b bb86 	b.w	80300b4 <free>
 80049a8:	4770      	bx	lr
 80049aa:	bf00      	nop

080049ac <gsl_matrix_uchar_set_identity>:
{
 80049ac:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 80049ae:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80049b0:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  const size_t tda = m->tda ;
 80049b4:	e9d0 c501 	ldrd	ip, r5, [r0, #4]
  for (i = 0; i < p; i++)
 80049b8:	b1d7      	cbz	r7, 80049f0 <gsl_matrix_uchar_set_identity+0x44>
 80049ba:	2600      	movs	r6, #0
 80049bc:	4631      	mov	r1, r6
 80049be:	f1ce 0400 	rsb	r4, lr, #0
 80049c2:	eb0e 000c 	add.w	r0, lr, ip
      for (j = 0; j < q; j++)
 80049c6:	eb0e 0306 	add.w	r3, lr, r6
 80049ca:	f1bc 0f00 	cmp.w	ip, #0
 80049ce:	d008      	beq.n	80049e2 <gsl_matrix_uchar_set_identity+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80049d0:	191a      	adds	r2, r3, r4
 80049d2:	1a52      	subs	r2, r2, r1
 80049d4:	fab2 f282 	clz	r2, r2
 80049d8:	0952      	lsrs	r2, r2, #5
 80049da:	f803 2b01 	strb.w	r2, [r3], #1
      for (j = 0; j < q; j++)
 80049de:	4283      	cmp	r3, r0
 80049e0:	d1f6      	bne.n	80049d0 <gsl_matrix_uchar_set_identity+0x24>
  for (i = 0; i < p; i++)
 80049e2:	3101      	adds	r1, #1
 80049e4:	428f      	cmp	r7, r1
 80049e6:	eba4 0405 	sub.w	r4, r4, r5
 80049ea:	442e      	add	r6, r5
 80049ec:	4428      	add	r0, r5
 80049ee:	d1ea      	bne.n	80049c6 <gsl_matrix_uchar_set_identity+0x1a>
}
 80049f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80049f2:	bf00      	nop

080049f4 <gsl_matrix_uchar_set_zero>:
{
 80049f4:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80049f6:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80049f8:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 80049fc:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004a00:	b186      	cbz	r6, 8004a24 <gsl_matrix_uchar_set_zero+0x30>
 8004a02:	2000      	movs	r0, #0
 8004a04:	4604      	mov	r4, r0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004a06:	4601      	mov	r1, r0
 8004a08:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004a0c:	eb0c 0300 	add.w	r3, ip, r0
 8004a10:	b11f      	cbz	r7, 8004a1a <gsl_matrix_uchar_set_zero+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004a12:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004a16:	4293      	cmp	r3, r2
 8004a18:	d1fb      	bne.n	8004a12 <gsl_matrix_uchar_set_zero+0x1e>
  for (i = 0; i < p; i++)
 8004a1a:	3401      	adds	r4, #1
 8004a1c:	42a6      	cmp	r6, r4
 8004a1e:	4428      	add	r0, r5
 8004a20:	442a      	add	r2, r5
 8004a22:	d1f3      	bne.n	8004a0c <gsl_matrix_uchar_set_zero+0x18>
}
 8004a24:	bcf0      	pop	{r4, r5, r6, r7}
 8004a26:	4770      	bx	lr

08004a28 <gsl_matrix_uchar_set_all>:
{
 8004a28:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004a2a:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004a2c:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 8004a30:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004a34:	b17e      	cbz	r6, 8004a56 <gsl_matrix_uchar_set_all+0x2e>
 8004a36:	2400      	movs	r4, #0
 8004a38:	4620      	mov	r0, r4
 8004a3a:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004a3e:	eb0c 0304 	add.w	r3, ip, r4
 8004a42:	b11f      	cbz	r7, 8004a4c <gsl_matrix_uchar_set_all+0x24>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8004a44:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004a48:	4293      	cmp	r3, r2
 8004a4a:	d1fb      	bne.n	8004a44 <gsl_matrix_uchar_set_all+0x1c>
  for (i = 0; i < p; i++)
 8004a4c:	3001      	adds	r0, #1
 8004a4e:	4286      	cmp	r6, r0
 8004a50:	442c      	add	r4, r5
 8004a52:	442a      	add	r2, r5
 8004a54:	d1f3      	bne.n	8004a3e <gsl_matrix_uchar_set_all+0x16>
}
 8004a56:	bcf0      	pop	{r4, r5, r6, r7}
 8004a58:	4770      	bx	lr
 8004a5a:	bf00      	nop

08004a5c <gsl_matrix_char_alloc>:
{
 8004a5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a5e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004a60:	2018      	movs	r0, #24
{
 8004a62:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004a64:	f02b fb1e 	bl	80300a4 <malloc>
  if (m == 0)
 8004a68:	4604      	mov	r4, r0
 8004a6a:	b1b8      	cbz	r0, 8004a9c <gsl_matrix_char_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8004a6c:	fb06 f007 	mul.w	r0, r6, r7
 8004a70:	f003 f9ea 	bl	8007e48 <gsl_block_char_alloc>
  if (block == 0)
 8004a74:	4605      	mov	r5, r0
 8004a76:	b148      	cbz	r0, 8004a8c <gsl_matrix_char_alloc+0x30>
  m->data = block->data;
 8004a78:	6843      	ldr	r3, [r0, #4]
 8004a7a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8004a7c:	2301      	movs	r3, #1
  m->size2 = n2;
 8004a7e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8004a82:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8004a86:	60a6      	str	r6, [r4, #8]
}
 8004a88:	4620      	mov	r0, r4
 8004a8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8004a8c:	4907      	ldr	r1, [pc, #28]	; (8004aac <gsl_matrix_char_alloc+0x50>)
 8004a8e:	4808      	ldr	r0, [pc, #32]	; (8004ab0 <gsl_matrix_char_alloc+0x54>)
 8004a90:	2308      	movs	r3, #8
 8004a92:	2228      	movs	r2, #40	; 0x28
 8004a94:	462c      	mov	r4, r5
 8004a96:	f7fd fee3 	bl	8002860 <gsl_error>
 8004a9a:	e7f5      	b.n	8004a88 <gsl_matrix_char_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004a9c:	4903      	ldr	r1, [pc, #12]	; (8004aac <gsl_matrix_char_alloc+0x50>)
 8004a9e:	4805      	ldr	r0, [pc, #20]	; (8004ab4 <gsl_matrix_char_alloc+0x58>)
 8004aa0:	2308      	movs	r3, #8
 8004aa2:	221e      	movs	r2, #30
 8004aa4:	f7fd fedc 	bl	8002860 <gsl_error>
 8004aa8:	e7ee      	b.n	8004a88 <gsl_matrix_char_alloc+0x2c>
 8004aaa:	bf00      	nop
 8004aac:	08030f9c 	.word	0x08030f9c
 8004ab0:	08030fd8 	.word	0x08030fd8
 8004ab4:	08030fac 	.word	0x08030fac

08004ab8 <gsl_matrix_char_calloc>:
{
 8004ab8:	b570      	push	{r4, r5, r6, lr}
 8004aba:	4606      	mov	r6, r0
 8004abc:	460c      	mov	r4, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8004abe:	f7ff ffcd 	bl	8004a5c <gsl_matrix_char_alloc>
  if (m == 0)
 8004ac2:	4605      	mov	r5, r0
 8004ac4:	b170      	cbz	r0, 8004ae4 <gsl_matrix_char_calloc+0x2c>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8004ac6:	fb04 f406 	mul.w	r4, r4, r6
 8004aca:	68c0      	ldr	r0, [r0, #12]
 8004acc:	4622      	mov	r2, r4
 8004ace:	2100      	movs	r1, #0
 8004ad0:	f02b faf8 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004ad4:	b134      	cbz	r4, 8004ae4 <gsl_matrix_char_calloc+0x2c>
 8004ad6:	2300      	movs	r3, #0
      m->data[i] = 0;
 8004ad8:	461a      	mov	r2, r3
 8004ada:	68e9      	ldr	r1, [r5, #12]
 8004adc:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004ade:	3301      	adds	r3, #1
 8004ae0:	429c      	cmp	r4, r3
 8004ae2:	d1fa      	bne.n	8004ada <gsl_matrix_char_calloc+0x22>
}
 8004ae4:	4628      	mov	r0, r5
 8004ae6:	bd70      	pop	{r4, r5, r6, pc}

08004ae8 <gsl_matrix_char_alloc_from_block>:
{
 8004ae8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004aec:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004af0:	4599      	cmp	r9, r3
 8004af2:	d324      	bcc.n	8004b3e <gsl_matrix_char_alloc_from_block+0x56>
  else if (block->size < offset + n1 * d2)
 8004af4:	4690      	mov	r8, r2
 8004af6:	6802      	ldr	r2, [r0, #0]
 8004af8:	461e      	mov	r6, r3
 8004afa:	fb08 1309 	mla	r3, r8, r9, r1
 8004afe:	429a      	cmp	r2, r3
 8004b00:	4605      	mov	r5, r0
 8004b02:	460f      	mov	r7, r1
 8004b04:	d311      	bcc.n	8004b2a <gsl_matrix_char_alloc_from_block+0x42>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004b06:	2018      	movs	r0, #24
 8004b08:	f02b facc 	bl	80300a4 <malloc>
  if (m == 0)
 8004b0c:	4604      	mov	r4, r0
 8004b0e:	b1f0      	cbz	r0, 8004b4e <gsl_matrix_char_alloc_from_block+0x66>
  m->data = block->data + MULTIPLICITY * offset;
 8004b10:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8004b12:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8004b16:	4439      	add	r1, r7
  m->tda = d2;
 8004b18:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8004b1c:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8004b20:	2300      	movs	r3, #0
 8004b22:	6143      	str	r3, [r0, #20]
}
 8004b24:	4620      	mov	r0, r4
 8004b26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8004b2a:	490c      	ldr	r1, [pc, #48]	; (8004b5c <gsl_matrix_char_alloc_from_block+0x74>)
 8004b2c:	480c      	ldr	r0, [pc, #48]	; (8004b60 <gsl_matrix_char_alloc_from_block+0x78>)
 8004b2e:	2304      	movs	r3, #4
 8004b30:	225b      	movs	r2, #91	; 0x5b
 8004b32:	2400      	movs	r4, #0
 8004b34:	f7fd fe94 	bl	8002860 <gsl_error>
}
 8004b38:	4620      	mov	r0, r4
 8004b3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8004b3e:	4907      	ldr	r1, [pc, #28]	; (8004b5c <gsl_matrix_char_alloc_from_block+0x74>)
 8004b40:	4808      	ldr	r0, [pc, #32]	; (8004b64 <gsl_matrix_char_alloc_from_block+0x7c>)
 8004b42:	2304      	movs	r3, #4
 8004b44:	2256      	movs	r2, #86	; 0x56
 8004b46:	f7fd fe8b 	bl	8002860 <gsl_error>
 8004b4a:	2400      	movs	r4, #0
 8004b4c:	e7ea      	b.n	8004b24 <gsl_matrix_char_alloc_from_block+0x3c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004b4e:	4903      	ldr	r1, [pc, #12]	; (8004b5c <gsl_matrix_char_alloc_from_block+0x74>)
 8004b50:	4805      	ldr	r0, [pc, #20]	; (8004b68 <gsl_matrix_char_alloc_from_block+0x80>)
 8004b52:	2308      	movs	r3, #8
 8004b54:	2263      	movs	r2, #99	; 0x63
 8004b56:	f7fd fe83 	bl	8002860 <gsl_error>
 8004b5a:	e7e3      	b.n	8004b24 <gsl_matrix_char_alloc_from_block+0x3c>
 8004b5c:	08030f9c 	.word	0x08030f9c
 8004b60:	08031028 	.word	0x08031028
 8004b64:	08030ffc 	.word	0x08030ffc
 8004b68:	08030fac 	.word	0x08030fac

08004b6c <gsl_matrix_char_alloc_from_matrix>:
{
 8004b6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004b70:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8004b72:	6803      	ldr	r3, [r0, #0]
{
 8004b74:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004b78:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8004b7a:	19c8      	adds	r0, r1, r7
 8004b7c:	4298      	cmp	r0, r3
 8004b7e:	d825      	bhi.n	8004bcc <gsl_matrix_char_alloc_from_matrix+0x60>
  else if (k2 + n2 > mm->size2)
 8004b80:	686b      	ldr	r3, [r5, #4]
 8004b82:	4690      	mov	r8, r2
 8004b84:	444a      	add	r2, r9
 8004b86:	429a      	cmp	r2, r3
 8004b88:	d816      	bhi.n	8004bb8 <gsl_matrix_char_alloc_from_matrix+0x4c>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004b8a:	2018      	movs	r0, #24
 8004b8c:	460e      	mov	r6, r1
 8004b8e:	f02b fa89 	bl	80300a4 <malloc>
  if (m == 0)
 8004b92:	4604      	mov	r4, r0
 8004b94:	b310      	cbz	r0, 8004bdc <gsl_matrix_char_alloc_from_matrix+0x70>
  m->size1 = n1;
 8004b96:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004b98:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8004b9a:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8004b9e:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004ba2:	fb06 8603 	mla	r6, r6, r3, r8
 8004ba6:	440e      	add	r6, r1
  m->owner = 0;
 8004ba8:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004baa:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8004bae:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8004bb2:	4620      	mov	r0, r4
 8004bb4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8004bb8:	490c      	ldr	r1, [pc, #48]	; (8004bec <gsl_matrix_char_alloc_from_matrix+0x80>)
 8004bba:	480d      	ldr	r0, [pc, #52]	; (8004bf0 <gsl_matrix_char_alloc_from_matrix+0x84>)
 8004bbc:	2304      	movs	r3, #4
 8004bbe:	2282      	movs	r2, #130	; 0x82
 8004bc0:	2400      	movs	r4, #0
 8004bc2:	f7fd fe4d 	bl	8002860 <gsl_error>
}
 8004bc6:	4620      	mov	r0, r4
 8004bc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8004bcc:	4907      	ldr	r1, [pc, #28]	; (8004bec <gsl_matrix_char_alloc_from_matrix+0x80>)
 8004bce:	4809      	ldr	r0, [pc, #36]	; (8004bf4 <gsl_matrix_char_alloc_from_matrix+0x88>)
 8004bd0:	2304      	movs	r3, #4
 8004bd2:	227d      	movs	r2, #125	; 0x7d
 8004bd4:	f7fd fe44 	bl	8002860 <gsl_error>
 8004bd8:	2400      	movs	r4, #0
 8004bda:	e7ea      	b.n	8004bb2 <gsl_matrix_char_alloc_from_matrix+0x46>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004bdc:	4903      	ldr	r1, [pc, #12]	; (8004bec <gsl_matrix_char_alloc_from_matrix+0x80>)
 8004bde:	4806      	ldr	r0, [pc, #24]	; (8004bf8 <gsl_matrix_char_alloc_from_matrix+0x8c>)
 8004be0:	2308      	movs	r3, #8
 8004be2:	228a      	movs	r2, #138	; 0x8a
 8004be4:	f7fd fe3c 	bl	8002860 <gsl_error>
 8004be8:	e7e3      	b.n	8004bb2 <gsl_matrix_char_alloc_from_matrix+0x46>
 8004bea:	bf00      	nop
 8004bec:	08030f9c 	.word	0x08030f9c
 8004bf0:	08031084 	.word	0x08031084
 8004bf4:	08031054 	.word	0x08031054
 8004bf8:	08030fac 	.word	0x08030fac

08004bfc <gsl_matrix_char_free>:
  RETURN_IF_NULL (m);
 8004bfc:	b180      	cbz	r0, 8004c20 <gsl_matrix_char_free+0x24>
  if (m->owner)
 8004bfe:	6943      	ldr	r3, [r0, #20]
{
 8004c00:	b510      	push	{r4, lr}
 8004c02:	4604      	mov	r4, r0
  if (m->owner)
 8004c04:	b923      	cbnz	r3, 8004c10 <gsl_matrix_char_free+0x14>
  free (m);
 8004c06:	4620      	mov	r0, r4
}
 8004c08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004c0c:	f02b ba52 	b.w	80300b4 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004c10:	6900      	ldr	r0, [r0, #16]
 8004c12:	f003 f959 	bl	8007ec8 <gsl_block_char_free>
  free (m);
 8004c16:	4620      	mov	r0, r4
}
 8004c18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004c1c:	f02b ba4a 	b.w	80300b4 <free>
 8004c20:	4770      	bx	lr
 8004c22:	bf00      	nop

08004c24 <gsl_matrix_char_set_identity>:
{
 8004c24:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 8004c26:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004c28:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  const size_t tda = m->tda ;
 8004c2c:	e9d0 c501 	ldrd	ip, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004c30:	b1d7      	cbz	r7, 8004c68 <gsl_matrix_char_set_identity+0x44>
 8004c32:	2600      	movs	r6, #0
 8004c34:	4631      	mov	r1, r6
 8004c36:	f1ce 0400 	rsb	r4, lr, #0
 8004c3a:	eb0e 000c 	add.w	r0, lr, ip
      for (j = 0; j < q; j++)
 8004c3e:	eb0e 0306 	add.w	r3, lr, r6
 8004c42:	f1bc 0f00 	cmp.w	ip, #0
 8004c46:	d008      	beq.n	8004c5a <gsl_matrix_char_set_identity+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004c48:	191a      	adds	r2, r3, r4
 8004c4a:	1a52      	subs	r2, r2, r1
 8004c4c:	fab2 f282 	clz	r2, r2
 8004c50:	0952      	lsrs	r2, r2, #5
 8004c52:	f803 2b01 	strb.w	r2, [r3], #1
      for (j = 0; j < q; j++)
 8004c56:	4283      	cmp	r3, r0
 8004c58:	d1f6      	bne.n	8004c48 <gsl_matrix_char_set_identity+0x24>
  for (i = 0; i < p; i++)
 8004c5a:	3101      	adds	r1, #1
 8004c5c:	428f      	cmp	r7, r1
 8004c5e:	eba4 0405 	sub.w	r4, r4, r5
 8004c62:	442e      	add	r6, r5
 8004c64:	4428      	add	r0, r5
 8004c66:	d1ea      	bne.n	8004c3e <gsl_matrix_char_set_identity+0x1a>
}
 8004c68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004c6a:	bf00      	nop

08004c6c <gsl_matrix_char_set_zero>:
{
 8004c6c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004c6e:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004c70:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 8004c74:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004c78:	b186      	cbz	r6, 8004c9c <gsl_matrix_char_set_zero+0x30>
 8004c7a:	2000      	movs	r0, #0
 8004c7c:	4604      	mov	r4, r0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004c7e:	4601      	mov	r1, r0
 8004c80:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004c84:	eb0c 0300 	add.w	r3, ip, r0
 8004c88:	b11f      	cbz	r7, 8004c92 <gsl_matrix_char_set_zero+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004c8a:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004c8e:	4293      	cmp	r3, r2
 8004c90:	d1fb      	bne.n	8004c8a <gsl_matrix_char_set_zero+0x1e>
  for (i = 0; i < p; i++)
 8004c92:	3401      	adds	r4, #1
 8004c94:	42a6      	cmp	r6, r4
 8004c96:	4428      	add	r0, r5
 8004c98:	442a      	add	r2, r5
 8004c9a:	d1f3      	bne.n	8004c84 <gsl_matrix_char_set_zero+0x18>
}
 8004c9c:	bcf0      	pop	{r4, r5, r6, r7}
 8004c9e:	4770      	bx	lr

08004ca0 <gsl_matrix_char_set_all>:
{
 8004ca0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004ca2:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004ca4:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 8004ca8:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004cac:	b17e      	cbz	r6, 8004cce <gsl_matrix_char_set_all+0x2e>
 8004cae:	2400      	movs	r4, #0
 8004cb0:	4620      	mov	r0, r4
 8004cb2:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004cb6:	eb0c 0304 	add.w	r3, ip, r4
 8004cba:	b11f      	cbz	r7, 8004cc4 <gsl_matrix_char_set_all+0x24>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8004cbc:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004cc0:	4293      	cmp	r3, r2
 8004cc2:	d1fb      	bne.n	8004cbc <gsl_matrix_char_set_all+0x1c>
  for (i = 0; i < p; i++)
 8004cc4:	3001      	adds	r0, #1
 8004cc6:	4286      	cmp	r6, r0
 8004cc8:	442c      	add	r4, r5
 8004cca:	442a      	add	r2, r5
 8004ccc:	d1f3      	bne.n	8004cb6 <gsl_matrix_char_set_all+0x16>
}
 8004cce:	bcf0      	pop	{r4, r5, r6, r7}
 8004cd0:	4770      	bx	lr
 8004cd2:	bf00      	nop

08004cd4 <gsl_matrix_complex_long_double_view_array>:
 */

QUALIFIED_VIEW (_gsl_matrix,view)
FUNCTION (gsl_matrix, view_array) (QUALIFIER ATOMIC * array, 
                                   const size_t n1, const size_t n2)
{
 8004cd4:	b430      	push	{r4, r5}
    m.tda = n2; 
    m.block = 0;
    m.owner = 0;

    view.matrix = m;    
    return view;
 8004cd6:	2500      	movs	r5, #0
 8004cd8:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8004cdc:	e9c0 2300 	strd	r2, r3, [r0]
  }
}
 8004ce0:	bc30      	pop	{r4, r5}
    return view;
 8004ce2:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8004ce6:	4770      	bx	lr

08004ce8 <gsl_matrix_complex_long_double_view_array_with_tda>:
QUALIFIED_VIEW (_gsl_matrix,view)
FUNCTION(gsl_matrix, view_array_with_tda) (QUALIFIER ATOMIC * base,
                                           const size_t n1, 
                                           const size_t n2,
                                           const size_t tda)
{
 8004ce8:	b538      	push	{r3, r4, r5, lr}
 8004cea:	9d04      	ldr	r5, [sp, #16]
  QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;

  if (n2 > tda)
 8004cec:	42ab      	cmp	r3, r5
{
 8004cee:	4604      	mov	r4, r0
  if (n2 > tda)
 8004cf0:	d808      	bhi.n	8004d04 <gsl_matrix_complex_long_double_view_array_with_tda+0x1c>
    m.tda = tda;
    m.block = 0;
    m.owner = 0;

    view.matrix = m;    
    return view;
 8004cf2:	2000      	movs	r0, #0
 8004cf4:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8004cf8:	e9c4 2300 	strd	r2, r3, [r4]
 8004cfc:	e9c4 5102 	strd	r5, r1, [r4, #8]
  }
}
 8004d00:	4620      	mov	r0, r4
 8004d02:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8004d04:	4907      	ldr	r1, [pc, #28]	; (8004d24 <gsl_matrix_complex_long_double_view_array_with_tda+0x3c>)
 8004d06:	4808      	ldr	r0, [pc, #32]	; (8004d28 <gsl_matrix_complex_long_double_view_array_with_tda+0x40>)
 8004d08:	2304      	movs	r3, #4
 8004d0a:	2233      	movs	r2, #51	; 0x33
 8004d0c:	f7fd fda8 	bl	8002860 <gsl_error>
 8004d10:	2300      	movs	r3, #0
 8004d12:	e9c4 3300 	strd	r3, r3, [r4]
 8004d16:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004d1a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004d1e:	4620      	mov	r0, r4
 8004d20:	bd38      	pop	{r3, r4, r5, pc}
 8004d22:	bf00      	nop
 8004d24:	080310b4 	.word	0x080310b4
 8004d28:	080310c4 	.word	0x080310c4

08004d2c <gsl_matrix_complex_long_double_view_vector>:

QUALIFIED_VIEW (_gsl_matrix,view)
FUNCTION(gsl_matrix, view_vector) (QUALIFIED_TYPE(gsl_vector) * v,
                                   const size_t n1, 
                                   const size_t n2)
{
 8004d2c:	b538      	push	{r3, r4, r5, lr}
  QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;

  if (v->stride != 1)
 8004d2e:	684d      	ldr	r5, [r1, #4]
 8004d30:	2d01      	cmp	r5, #1
{
 8004d32:	4604      	mov	r4, r0
  if (v->stride != 1)
 8004d34:	d10f      	bne.n	8004d56 <gsl_matrix_complex_long_double_view_vector+0x2a>
    {
      GSL_ERROR_VAL ("vector must have unit stride",
                     GSL_EINVAL, view);
    }
  else if (n1 * n2 > v->size)
 8004d36:	6808      	ldr	r0, [r1, #0]
 8004d38:	fb03 f502 	mul.w	r5, r3, r2
 8004d3c:	4285      	cmp	r5, r0
 8004d3e:	d819      	bhi.n	8004d74 <gsl_matrix_complex_long_double_view_vector+0x48>

    m.data = v->data;
    m.size1 = n1;
    m.size2 = n2;
    m.tda = n2;
    m.block = v->block;
 8004d40:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    m.owner = 0;

    view.matrix = m;    
    return view;
 8004d44:	6022      	str	r2, [r4, #0]
 8004d46:	2200      	movs	r2, #0
 8004d48:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8004d4c:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8004d50:	6162      	str	r2, [r4, #20]
  }
}
 8004d52:	4620      	mov	r0, r4
 8004d54:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8004d56:	490a      	ldr	r1, [pc, #40]	; (8004d80 <gsl_matrix_complex_long_double_view_vector+0x54>)
 8004d58:	480a      	ldr	r0, [pc, #40]	; (8004d84 <gsl_matrix_complex_long_double_view_vector+0x58>)
 8004d5a:	2304      	movs	r3, #4
 8004d5c:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004d5e:	f7fd fd7f 	bl	8002860 <gsl_error>
 8004d62:	2300      	movs	r3, #0
 8004d64:	e9c4 3300 	strd	r3, r3, [r4]
 8004d68:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004d6c:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004d70:	4620      	mov	r0, r4
 8004d72:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004d74:	4902      	ldr	r1, [pc, #8]	; (8004d80 <gsl_matrix_complex_long_double_view_vector+0x54>)
 8004d76:	4804      	ldr	r0, [pc, #16]	; (8004d88 <gsl_matrix_complex_long_double_view_vector+0x5c>)
 8004d78:	2304      	movs	r3, #4
 8004d7a:	2254      	movs	r2, #84	; 0x54
 8004d7c:	e7ef      	b.n	8004d5e <gsl_matrix_complex_long_double_view_vector+0x32>
 8004d7e:	bf00      	nop
 8004d80:	080310b4 	.word	0x080310b4
 8004d84:	080310ec 	.word	0x080310ec
 8004d88:	0803110c 	.word	0x0803110c

08004d8c <gsl_matrix_complex_long_double_view_vector_with_tda>:
QUALIFIED_VIEW (_gsl_matrix,view)
FUNCTION(gsl_matrix, view_vector_with_tda) (QUALIFIED_TYPE(gsl_vector) * v,
                                            const size_t n1, 
                                            const size_t n2,
                                            const size_t tda)
{
 8004d8c:	b570      	push	{r4, r5, r6, lr}
  QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;

  if (v->stride != 1)
 8004d8e:	684d      	ldr	r5, [r1, #4]
{
 8004d90:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8004d92:	2d01      	cmp	r5, #1
{
 8004d94:	4604      	mov	r4, r0
  if (v->stride != 1)
 8004d96:	d111      	bne.n	8004dbc <gsl_matrix_complex_long_double_view_vector_with_tda+0x30>
    {
      GSL_ERROR_VAL ("vector must have unit stride",
                     GSL_EINVAL, view);
    }
  else if (n2 > tda)
 8004d98:	42b3      	cmp	r3, r6
 8004d9a:	d823      	bhi.n	8004de4 <gsl_matrix_complex_long_double_view_vector_with_tda+0x58>
    {
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
                     GSL_EINVAL, view);
    }
  else if (n1 * tda > v->size)
 8004d9c:	6808      	ldr	r0, [r1, #0]
 8004d9e:	fb02 f506 	mul.w	r5, r2, r6
 8004da2:	4285      	cmp	r5, r0
 8004da4:	d819      	bhi.n	8004dda <gsl_matrix_complex_long_double_view_vector_with_tda+0x4e>

    m.data = v->data;
    m.size1 = n1;
    m.size2 = n2;
    m.tda = tda;
    m.block = v->block;
 8004da6:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    m.owner = 0;

    view.matrix = m;    
    return view;
 8004daa:	6022      	str	r2, [r4, #0]
 8004dac:	2200      	movs	r2, #0
 8004dae:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8004db2:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8004db6:	6162      	str	r2, [r4, #20]
  }
}
 8004db8:	4620      	mov	r0, r4
 8004dba:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8004dbc:	490c      	ldr	r1, [pc, #48]	; (8004df0 <gsl_matrix_complex_long_double_view_vector_with_tda+0x64>)
 8004dbe:	480d      	ldr	r0, [pc, #52]	; (8004df4 <gsl_matrix_complex_long_double_view_vector_with_tda+0x68>)
 8004dc0:	2304      	movs	r3, #4
 8004dc2:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004dc4:	f7fd fd4c 	bl	8002860 <gsl_error>
 8004dc8:	2300      	movs	r3, #0
 8004dca:	e9c4 3300 	strd	r3, r3, [r4]
 8004dce:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004dd2:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004dd6:	4620      	mov	r0, r4
 8004dd8:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004dda:	4905      	ldr	r1, [pc, #20]	; (8004df0 <gsl_matrix_complex_long_double_view_vector_with_tda+0x64>)
 8004ddc:	4806      	ldr	r0, [pc, #24]	; (8004df8 <gsl_matrix_complex_long_double_view_vector_with_tda+0x6c>)
 8004dde:	2304      	movs	r3, #4
 8004de0:	227c      	movs	r2, #124	; 0x7c
 8004de2:	e7ef      	b.n	8004dc4 <gsl_matrix_complex_long_double_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8004de4:	4902      	ldr	r1, [pc, #8]	; (8004df0 <gsl_matrix_complex_long_double_view_vector_with_tda+0x64>)
 8004de6:	4805      	ldr	r0, [pc, #20]	; (8004dfc <gsl_matrix_complex_long_double_view_vector_with_tda+0x70>)
 8004de8:	2304      	movs	r3, #4
 8004dea:	2277      	movs	r2, #119	; 0x77
 8004dec:	e7ea      	b.n	8004dc4 <gsl_matrix_complex_long_double_view_vector_with_tda+0x38>
 8004dee:	bf00      	nop
 8004df0:	080310b4 	.word	0x080310b4
 8004df4:	080310ec 	.word	0x080310ec
 8004df8:	0803110c 	.word	0x0803110c
 8004dfc:	080310c4 	.word	0x080310c4

08004e00 <gsl_matrix_complex_view_array>:
{
 8004e00:	b430      	push	{r4, r5}
    return view;
 8004e02:	2500      	movs	r5, #0
 8004e04:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8004e08:	e9c0 2300 	strd	r2, r3, [r0]
}
 8004e0c:	bc30      	pop	{r4, r5}
    return view;
 8004e0e:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8004e12:	4770      	bx	lr

08004e14 <gsl_matrix_complex_view_array_with_tda>:
{
 8004e14:	b538      	push	{r3, r4, r5, lr}
 8004e16:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8004e18:	42ab      	cmp	r3, r5
{
 8004e1a:	4604      	mov	r4, r0
  if (n2 > tda)
 8004e1c:	d808      	bhi.n	8004e30 <gsl_matrix_complex_view_array_with_tda+0x1c>
    return view;
 8004e1e:	2000      	movs	r0, #0
 8004e20:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8004e24:	e9c4 2300 	strd	r2, r3, [r4]
 8004e28:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8004e2c:	4620      	mov	r0, r4
 8004e2e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8004e30:	4907      	ldr	r1, [pc, #28]	; (8004e50 <gsl_matrix_complex_view_array_with_tda+0x3c>)
 8004e32:	4808      	ldr	r0, [pc, #32]	; (8004e54 <gsl_matrix_complex_view_array_with_tda+0x40>)
 8004e34:	2304      	movs	r3, #4
 8004e36:	2233      	movs	r2, #51	; 0x33
 8004e38:	f7fd fd12 	bl	8002860 <gsl_error>
 8004e3c:	2300      	movs	r3, #0
 8004e3e:	e9c4 3300 	strd	r3, r3, [r4]
 8004e42:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004e46:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004e4a:	4620      	mov	r0, r4
 8004e4c:	bd38      	pop	{r3, r4, r5, pc}
 8004e4e:	bf00      	nop
 8004e50:	080310b4 	.word	0x080310b4
 8004e54:	080310c4 	.word	0x080310c4

08004e58 <gsl_matrix_complex_view_vector>:
{
 8004e58:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8004e5a:	684d      	ldr	r5, [r1, #4]
 8004e5c:	2d01      	cmp	r5, #1
{
 8004e5e:	4604      	mov	r4, r0
  if (v->stride != 1)
 8004e60:	d10f      	bne.n	8004e82 <gsl_matrix_complex_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8004e62:	6808      	ldr	r0, [r1, #0]
 8004e64:	fb03 f502 	mul.w	r5, r3, r2
 8004e68:	4285      	cmp	r5, r0
 8004e6a:	d819      	bhi.n	8004ea0 <gsl_matrix_complex_view_vector+0x48>
    m.block = v->block;
 8004e6c:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8004e70:	6022      	str	r2, [r4, #0]
 8004e72:	2200      	movs	r2, #0
 8004e74:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8004e78:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8004e7c:	6162      	str	r2, [r4, #20]
}
 8004e7e:	4620      	mov	r0, r4
 8004e80:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8004e82:	490a      	ldr	r1, [pc, #40]	; (8004eac <gsl_matrix_complex_view_vector+0x54>)
 8004e84:	480a      	ldr	r0, [pc, #40]	; (8004eb0 <gsl_matrix_complex_view_vector+0x58>)
 8004e86:	2304      	movs	r3, #4
 8004e88:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004e8a:	f7fd fce9 	bl	8002860 <gsl_error>
 8004e8e:	2300      	movs	r3, #0
 8004e90:	e9c4 3300 	strd	r3, r3, [r4]
 8004e94:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004e98:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004e9c:	4620      	mov	r0, r4
 8004e9e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004ea0:	4902      	ldr	r1, [pc, #8]	; (8004eac <gsl_matrix_complex_view_vector+0x54>)
 8004ea2:	4804      	ldr	r0, [pc, #16]	; (8004eb4 <gsl_matrix_complex_view_vector+0x5c>)
 8004ea4:	2304      	movs	r3, #4
 8004ea6:	2254      	movs	r2, #84	; 0x54
 8004ea8:	e7ef      	b.n	8004e8a <gsl_matrix_complex_view_vector+0x32>
 8004eaa:	bf00      	nop
 8004eac:	080310b4 	.word	0x080310b4
 8004eb0:	080310ec 	.word	0x080310ec
 8004eb4:	0803110c 	.word	0x0803110c

08004eb8 <gsl_matrix_complex_view_vector_with_tda>:
{
 8004eb8:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8004eba:	684d      	ldr	r5, [r1, #4]
{
 8004ebc:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8004ebe:	2d01      	cmp	r5, #1
{
 8004ec0:	4604      	mov	r4, r0
  if (v->stride != 1)
 8004ec2:	d111      	bne.n	8004ee8 <gsl_matrix_complex_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8004ec4:	42b3      	cmp	r3, r6
 8004ec6:	d823      	bhi.n	8004f10 <gsl_matrix_complex_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8004ec8:	6808      	ldr	r0, [r1, #0]
 8004eca:	fb02 f506 	mul.w	r5, r2, r6
 8004ece:	4285      	cmp	r5, r0
 8004ed0:	d819      	bhi.n	8004f06 <gsl_matrix_complex_view_vector_with_tda+0x4e>
    m.block = v->block;
 8004ed2:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8004ed6:	6022      	str	r2, [r4, #0]
 8004ed8:	2200      	movs	r2, #0
 8004eda:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8004ede:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8004ee2:	6162      	str	r2, [r4, #20]
}
 8004ee4:	4620      	mov	r0, r4
 8004ee6:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8004ee8:	490c      	ldr	r1, [pc, #48]	; (8004f1c <gsl_matrix_complex_view_vector_with_tda+0x64>)
 8004eea:	480d      	ldr	r0, [pc, #52]	; (8004f20 <gsl_matrix_complex_view_vector_with_tda+0x68>)
 8004eec:	2304      	movs	r3, #4
 8004eee:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004ef0:	f7fd fcb6 	bl	8002860 <gsl_error>
 8004ef4:	2300      	movs	r3, #0
 8004ef6:	e9c4 3300 	strd	r3, r3, [r4]
 8004efa:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004efe:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004f02:	4620      	mov	r0, r4
 8004f04:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004f06:	4905      	ldr	r1, [pc, #20]	; (8004f1c <gsl_matrix_complex_view_vector_with_tda+0x64>)
 8004f08:	4806      	ldr	r0, [pc, #24]	; (8004f24 <gsl_matrix_complex_view_vector_with_tda+0x6c>)
 8004f0a:	2304      	movs	r3, #4
 8004f0c:	227c      	movs	r2, #124	; 0x7c
 8004f0e:	e7ef      	b.n	8004ef0 <gsl_matrix_complex_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8004f10:	4902      	ldr	r1, [pc, #8]	; (8004f1c <gsl_matrix_complex_view_vector_with_tda+0x64>)
 8004f12:	4805      	ldr	r0, [pc, #20]	; (8004f28 <gsl_matrix_complex_view_vector_with_tda+0x70>)
 8004f14:	2304      	movs	r3, #4
 8004f16:	2277      	movs	r2, #119	; 0x77
 8004f18:	e7ea      	b.n	8004ef0 <gsl_matrix_complex_view_vector_with_tda+0x38>
 8004f1a:	bf00      	nop
 8004f1c:	080310b4 	.word	0x080310b4
 8004f20:	080310ec 	.word	0x080310ec
 8004f24:	0803110c 	.word	0x0803110c
 8004f28:	080310c4 	.word	0x080310c4

08004f2c <gsl_matrix_complex_float_view_array>:
{
 8004f2c:	b430      	push	{r4, r5}
    return view;
 8004f2e:	2500      	movs	r5, #0
 8004f30:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8004f34:	e9c0 2300 	strd	r2, r3, [r0]
}
 8004f38:	bc30      	pop	{r4, r5}
    return view;
 8004f3a:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8004f3e:	4770      	bx	lr

08004f40 <gsl_matrix_complex_float_view_array_with_tda>:
{
 8004f40:	b538      	push	{r3, r4, r5, lr}
 8004f42:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8004f44:	42ab      	cmp	r3, r5
{
 8004f46:	4604      	mov	r4, r0
  if (n2 > tda)
 8004f48:	d808      	bhi.n	8004f5c <gsl_matrix_complex_float_view_array_with_tda+0x1c>
    return view;
 8004f4a:	2000      	movs	r0, #0
 8004f4c:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8004f50:	e9c4 2300 	strd	r2, r3, [r4]
 8004f54:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8004f58:	4620      	mov	r0, r4
 8004f5a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8004f5c:	4907      	ldr	r1, [pc, #28]	; (8004f7c <gsl_matrix_complex_float_view_array_with_tda+0x3c>)
 8004f5e:	4808      	ldr	r0, [pc, #32]	; (8004f80 <gsl_matrix_complex_float_view_array_with_tda+0x40>)
 8004f60:	2304      	movs	r3, #4
 8004f62:	2233      	movs	r2, #51	; 0x33
 8004f64:	f7fd fc7c 	bl	8002860 <gsl_error>
 8004f68:	2300      	movs	r3, #0
 8004f6a:	e9c4 3300 	strd	r3, r3, [r4]
 8004f6e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004f72:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004f76:	4620      	mov	r0, r4
 8004f78:	bd38      	pop	{r3, r4, r5, pc}
 8004f7a:	bf00      	nop
 8004f7c:	080310b4 	.word	0x080310b4
 8004f80:	080310c4 	.word	0x080310c4

08004f84 <gsl_matrix_complex_float_view_vector>:
{
 8004f84:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8004f86:	684d      	ldr	r5, [r1, #4]
 8004f88:	2d01      	cmp	r5, #1
{
 8004f8a:	4604      	mov	r4, r0
  if (v->stride != 1)
 8004f8c:	d10f      	bne.n	8004fae <gsl_matrix_complex_float_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8004f8e:	6808      	ldr	r0, [r1, #0]
 8004f90:	fb03 f502 	mul.w	r5, r3, r2
 8004f94:	4285      	cmp	r5, r0
 8004f96:	d819      	bhi.n	8004fcc <gsl_matrix_complex_float_view_vector+0x48>
    m.block = v->block;
 8004f98:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8004f9c:	6022      	str	r2, [r4, #0]
 8004f9e:	2200      	movs	r2, #0
 8004fa0:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8004fa4:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8004fa8:	6162      	str	r2, [r4, #20]
}
 8004faa:	4620      	mov	r0, r4
 8004fac:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8004fae:	490a      	ldr	r1, [pc, #40]	; (8004fd8 <gsl_matrix_complex_float_view_vector+0x54>)
 8004fb0:	480a      	ldr	r0, [pc, #40]	; (8004fdc <gsl_matrix_complex_float_view_vector+0x58>)
 8004fb2:	2304      	movs	r3, #4
 8004fb4:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004fb6:	f7fd fc53 	bl	8002860 <gsl_error>
 8004fba:	2300      	movs	r3, #0
 8004fbc:	e9c4 3300 	strd	r3, r3, [r4]
 8004fc0:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8004fc4:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8004fc8:	4620      	mov	r0, r4
 8004fca:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8004fcc:	4902      	ldr	r1, [pc, #8]	; (8004fd8 <gsl_matrix_complex_float_view_vector+0x54>)
 8004fce:	4804      	ldr	r0, [pc, #16]	; (8004fe0 <gsl_matrix_complex_float_view_vector+0x5c>)
 8004fd0:	2304      	movs	r3, #4
 8004fd2:	2254      	movs	r2, #84	; 0x54
 8004fd4:	e7ef      	b.n	8004fb6 <gsl_matrix_complex_float_view_vector+0x32>
 8004fd6:	bf00      	nop
 8004fd8:	080310b4 	.word	0x080310b4
 8004fdc:	080310ec 	.word	0x080310ec
 8004fe0:	0803110c 	.word	0x0803110c

08004fe4 <gsl_matrix_complex_float_view_vector_with_tda>:
{
 8004fe4:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8004fe6:	684d      	ldr	r5, [r1, #4]
{
 8004fe8:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8004fea:	2d01      	cmp	r5, #1
{
 8004fec:	4604      	mov	r4, r0
  if (v->stride != 1)
 8004fee:	d111      	bne.n	8005014 <gsl_matrix_complex_float_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8004ff0:	42b3      	cmp	r3, r6
 8004ff2:	d823      	bhi.n	800503c <gsl_matrix_complex_float_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8004ff4:	6808      	ldr	r0, [r1, #0]
 8004ff6:	fb02 f506 	mul.w	r5, r2, r6
 8004ffa:	4285      	cmp	r5, r0
 8004ffc:	d819      	bhi.n	8005032 <gsl_matrix_complex_float_view_vector_with_tda+0x4e>
    m.block = v->block;
 8004ffe:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005002:	6022      	str	r2, [r4, #0]
 8005004:	2200      	movs	r2, #0
 8005006:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800500a:	e9c4 3601 	strd	r3, r6, [r4, #4]
 800500e:	6162      	str	r2, [r4, #20]
}
 8005010:	4620      	mov	r0, r4
 8005012:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005014:	490c      	ldr	r1, [pc, #48]	; (8005048 <gsl_matrix_complex_float_view_vector_with_tda+0x64>)
 8005016:	480d      	ldr	r0, [pc, #52]	; (800504c <gsl_matrix_complex_float_view_vector_with_tda+0x68>)
 8005018:	2304      	movs	r3, #4
 800501a:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800501c:	f7fd fc20 	bl	8002860 <gsl_error>
 8005020:	2300      	movs	r3, #0
 8005022:	e9c4 3300 	strd	r3, r3, [r4]
 8005026:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800502a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800502e:	4620      	mov	r0, r4
 8005030:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005032:	4905      	ldr	r1, [pc, #20]	; (8005048 <gsl_matrix_complex_float_view_vector_with_tda+0x64>)
 8005034:	4806      	ldr	r0, [pc, #24]	; (8005050 <gsl_matrix_complex_float_view_vector_with_tda+0x6c>)
 8005036:	2304      	movs	r3, #4
 8005038:	227c      	movs	r2, #124	; 0x7c
 800503a:	e7ef      	b.n	800501c <gsl_matrix_complex_float_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 800503c:	4902      	ldr	r1, [pc, #8]	; (8005048 <gsl_matrix_complex_float_view_vector_with_tda+0x64>)
 800503e:	4805      	ldr	r0, [pc, #20]	; (8005054 <gsl_matrix_complex_float_view_vector_with_tda+0x70>)
 8005040:	2304      	movs	r3, #4
 8005042:	2277      	movs	r2, #119	; 0x77
 8005044:	e7ea      	b.n	800501c <gsl_matrix_complex_float_view_vector_with_tda+0x38>
 8005046:	bf00      	nop
 8005048:	080310b4 	.word	0x080310b4
 800504c:	080310ec 	.word	0x080310ec
 8005050:	0803110c 	.word	0x0803110c
 8005054:	080310c4 	.word	0x080310c4

08005058 <gsl_matrix_long_double_view_array>:
{
 8005058:	b430      	push	{r4, r5}
    return view;
 800505a:	2500      	movs	r5, #0
 800505c:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005060:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005064:	bc30      	pop	{r4, r5}
    return view;
 8005066:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 800506a:	4770      	bx	lr

0800506c <gsl_matrix_long_double_view_array_with_tda>:
{
 800506c:	b538      	push	{r3, r4, r5, lr}
 800506e:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005070:	42ab      	cmp	r3, r5
{
 8005072:	4604      	mov	r4, r0
  if (n2 > tda)
 8005074:	d808      	bhi.n	8005088 <gsl_matrix_long_double_view_array_with_tda+0x1c>
    return view;
 8005076:	2000      	movs	r0, #0
 8005078:	e9c4 0004 	strd	r0, r0, [r4, #16]
 800507c:	e9c4 2300 	strd	r2, r3, [r4]
 8005080:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005084:	4620      	mov	r0, r4
 8005086:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005088:	4907      	ldr	r1, [pc, #28]	; (80050a8 <gsl_matrix_long_double_view_array_with_tda+0x3c>)
 800508a:	4808      	ldr	r0, [pc, #32]	; (80050ac <gsl_matrix_long_double_view_array_with_tda+0x40>)
 800508c:	2304      	movs	r3, #4
 800508e:	2233      	movs	r2, #51	; 0x33
 8005090:	f7fd fbe6 	bl	8002860 <gsl_error>
 8005094:	2300      	movs	r3, #0
 8005096:	e9c4 3300 	strd	r3, r3, [r4]
 800509a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800509e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80050a2:	4620      	mov	r0, r4
 80050a4:	bd38      	pop	{r3, r4, r5, pc}
 80050a6:	bf00      	nop
 80050a8:	080310b4 	.word	0x080310b4
 80050ac:	080310c4 	.word	0x080310c4

080050b0 <gsl_matrix_long_double_view_vector>:
{
 80050b0:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 80050b2:	684d      	ldr	r5, [r1, #4]
 80050b4:	2d01      	cmp	r5, #1
{
 80050b6:	4604      	mov	r4, r0
  if (v->stride != 1)
 80050b8:	d10f      	bne.n	80050da <gsl_matrix_long_double_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80050ba:	6808      	ldr	r0, [r1, #0]
 80050bc:	fb03 f502 	mul.w	r5, r3, r2
 80050c0:	4285      	cmp	r5, r0
 80050c2:	d819      	bhi.n	80050f8 <gsl_matrix_long_double_view_vector+0x48>
    m.block = v->block;
 80050c4:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80050c8:	6022      	str	r2, [r4, #0]
 80050ca:	2200      	movs	r2, #0
 80050cc:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80050d0:	e9c4 3301 	strd	r3, r3, [r4, #4]
 80050d4:	6162      	str	r2, [r4, #20]
}
 80050d6:	4620      	mov	r0, r4
 80050d8:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80050da:	490a      	ldr	r1, [pc, #40]	; (8005104 <gsl_matrix_long_double_view_vector+0x54>)
 80050dc:	480a      	ldr	r0, [pc, #40]	; (8005108 <gsl_matrix_long_double_view_vector+0x58>)
 80050de:	2304      	movs	r3, #4
 80050e0:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80050e2:	f7fd fbbd 	bl	8002860 <gsl_error>
 80050e6:	2300      	movs	r3, #0
 80050e8:	e9c4 3300 	strd	r3, r3, [r4]
 80050ec:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80050f0:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80050f4:	4620      	mov	r0, r4
 80050f6:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80050f8:	4902      	ldr	r1, [pc, #8]	; (8005104 <gsl_matrix_long_double_view_vector+0x54>)
 80050fa:	4804      	ldr	r0, [pc, #16]	; (800510c <gsl_matrix_long_double_view_vector+0x5c>)
 80050fc:	2304      	movs	r3, #4
 80050fe:	2254      	movs	r2, #84	; 0x54
 8005100:	e7ef      	b.n	80050e2 <gsl_matrix_long_double_view_vector+0x32>
 8005102:	bf00      	nop
 8005104:	080310b4 	.word	0x080310b4
 8005108:	080310ec 	.word	0x080310ec
 800510c:	0803110c 	.word	0x0803110c

08005110 <gsl_matrix_long_double_view_vector_with_tda>:
{
 8005110:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005112:	684d      	ldr	r5, [r1, #4]
{
 8005114:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005116:	2d01      	cmp	r5, #1
{
 8005118:	4604      	mov	r4, r0
  if (v->stride != 1)
 800511a:	d111      	bne.n	8005140 <gsl_matrix_long_double_view_vector_with_tda+0x30>
  else if (n2 > tda)
 800511c:	42b3      	cmp	r3, r6
 800511e:	d823      	bhi.n	8005168 <gsl_matrix_long_double_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005120:	6808      	ldr	r0, [r1, #0]
 8005122:	fb02 f506 	mul.w	r5, r2, r6
 8005126:	4285      	cmp	r5, r0
 8005128:	d819      	bhi.n	800515e <gsl_matrix_long_double_view_vector_with_tda+0x4e>
    m.block = v->block;
 800512a:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800512e:	6022      	str	r2, [r4, #0]
 8005130:	2200      	movs	r2, #0
 8005132:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005136:	e9c4 3601 	strd	r3, r6, [r4, #4]
 800513a:	6162      	str	r2, [r4, #20]
}
 800513c:	4620      	mov	r0, r4
 800513e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005140:	490c      	ldr	r1, [pc, #48]	; (8005174 <gsl_matrix_long_double_view_vector_with_tda+0x64>)
 8005142:	480d      	ldr	r0, [pc, #52]	; (8005178 <gsl_matrix_long_double_view_vector_with_tda+0x68>)
 8005144:	2304      	movs	r3, #4
 8005146:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005148:	f7fd fb8a 	bl	8002860 <gsl_error>
 800514c:	2300      	movs	r3, #0
 800514e:	e9c4 3300 	strd	r3, r3, [r4]
 8005152:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005156:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800515a:	4620      	mov	r0, r4
 800515c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800515e:	4905      	ldr	r1, [pc, #20]	; (8005174 <gsl_matrix_long_double_view_vector_with_tda+0x64>)
 8005160:	4806      	ldr	r0, [pc, #24]	; (800517c <gsl_matrix_long_double_view_vector_with_tda+0x6c>)
 8005162:	2304      	movs	r3, #4
 8005164:	227c      	movs	r2, #124	; 0x7c
 8005166:	e7ef      	b.n	8005148 <gsl_matrix_long_double_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005168:	4902      	ldr	r1, [pc, #8]	; (8005174 <gsl_matrix_long_double_view_vector_with_tda+0x64>)
 800516a:	4805      	ldr	r0, [pc, #20]	; (8005180 <gsl_matrix_long_double_view_vector_with_tda+0x70>)
 800516c:	2304      	movs	r3, #4
 800516e:	2277      	movs	r2, #119	; 0x77
 8005170:	e7ea      	b.n	8005148 <gsl_matrix_long_double_view_vector_with_tda+0x38>
 8005172:	bf00      	nop
 8005174:	080310b4 	.word	0x080310b4
 8005178:	080310ec 	.word	0x080310ec
 800517c:	0803110c 	.word	0x0803110c
 8005180:	080310c4 	.word	0x080310c4

08005184 <gsl_matrix_view_array>:
{
 8005184:	b430      	push	{r4, r5}
    return view;
 8005186:	2500      	movs	r5, #0
 8005188:	e9c0 5504 	strd	r5, r5, [r0, #16]
 800518c:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005190:	bc30      	pop	{r4, r5}
    return view;
 8005192:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005196:	4770      	bx	lr

08005198 <gsl_matrix_view_array_with_tda>:
{
 8005198:	b538      	push	{r3, r4, r5, lr}
 800519a:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 800519c:	42ab      	cmp	r3, r5
{
 800519e:	4604      	mov	r4, r0
  if (n2 > tda)
 80051a0:	d808      	bhi.n	80051b4 <gsl_matrix_view_array_with_tda+0x1c>
    return view;
 80051a2:	2000      	movs	r0, #0
 80051a4:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80051a8:	e9c4 2300 	strd	r2, r3, [r4]
 80051ac:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80051b0:	4620      	mov	r0, r4
 80051b2:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80051b4:	4907      	ldr	r1, [pc, #28]	; (80051d4 <gsl_matrix_view_array_with_tda+0x3c>)
 80051b6:	4808      	ldr	r0, [pc, #32]	; (80051d8 <gsl_matrix_view_array_with_tda+0x40>)
 80051b8:	2304      	movs	r3, #4
 80051ba:	2233      	movs	r2, #51	; 0x33
 80051bc:	f7fd fb50 	bl	8002860 <gsl_error>
 80051c0:	2300      	movs	r3, #0
 80051c2:	e9c4 3300 	strd	r3, r3, [r4]
 80051c6:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80051ca:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80051ce:	4620      	mov	r0, r4
 80051d0:	bd38      	pop	{r3, r4, r5, pc}
 80051d2:	bf00      	nop
 80051d4:	080310b4 	.word	0x080310b4
 80051d8:	080310c4 	.word	0x080310c4

080051dc <gsl_matrix_view_vector>:
{
 80051dc:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 80051de:	684d      	ldr	r5, [r1, #4]
 80051e0:	2d01      	cmp	r5, #1
{
 80051e2:	4604      	mov	r4, r0
  if (v->stride != 1)
 80051e4:	d10f      	bne.n	8005206 <gsl_matrix_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80051e6:	6808      	ldr	r0, [r1, #0]
 80051e8:	fb03 f502 	mul.w	r5, r3, r2
 80051ec:	4285      	cmp	r5, r0
 80051ee:	d819      	bhi.n	8005224 <gsl_matrix_view_vector+0x48>
    m.block = v->block;
 80051f0:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80051f4:	6022      	str	r2, [r4, #0]
 80051f6:	2200      	movs	r2, #0
 80051f8:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80051fc:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005200:	6162      	str	r2, [r4, #20]
}
 8005202:	4620      	mov	r0, r4
 8005204:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005206:	490a      	ldr	r1, [pc, #40]	; (8005230 <gsl_matrix_view_vector+0x54>)
 8005208:	480a      	ldr	r0, [pc, #40]	; (8005234 <gsl_matrix_view_vector+0x58>)
 800520a:	2304      	movs	r3, #4
 800520c:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800520e:	f7fd fb27 	bl	8002860 <gsl_error>
 8005212:	2300      	movs	r3, #0
 8005214:	e9c4 3300 	strd	r3, r3, [r4]
 8005218:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800521c:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005220:	4620      	mov	r0, r4
 8005222:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005224:	4902      	ldr	r1, [pc, #8]	; (8005230 <gsl_matrix_view_vector+0x54>)
 8005226:	4804      	ldr	r0, [pc, #16]	; (8005238 <gsl_matrix_view_vector+0x5c>)
 8005228:	2304      	movs	r3, #4
 800522a:	2254      	movs	r2, #84	; 0x54
 800522c:	e7ef      	b.n	800520e <gsl_matrix_view_vector+0x32>
 800522e:	bf00      	nop
 8005230:	080310b4 	.word	0x080310b4
 8005234:	080310ec 	.word	0x080310ec
 8005238:	0803110c 	.word	0x0803110c

0800523c <gsl_matrix_view_vector_with_tda>:
{
 800523c:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 800523e:	684d      	ldr	r5, [r1, #4]
{
 8005240:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005242:	2d01      	cmp	r5, #1
{
 8005244:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005246:	d111      	bne.n	800526c <gsl_matrix_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005248:	42b3      	cmp	r3, r6
 800524a:	d823      	bhi.n	8005294 <gsl_matrix_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 800524c:	6808      	ldr	r0, [r1, #0]
 800524e:	fb02 f506 	mul.w	r5, r2, r6
 8005252:	4285      	cmp	r5, r0
 8005254:	d819      	bhi.n	800528a <gsl_matrix_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005256:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800525a:	6022      	str	r2, [r4, #0]
 800525c:	2200      	movs	r2, #0
 800525e:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005262:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005266:	6162      	str	r2, [r4, #20]
}
 8005268:	4620      	mov	r0, r4
 800526a:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800526c:	490c      	ldr	r1, [pc, #48]	; (80052a0 <gsl_matrix_view_vector_with_tda+0x64>)
 800526e:	480d      	ldr	r0, [pc, #52]	; (80052a4 <gsl_matrix_view_vector_with_tda+0x68>)
 8005270:	2304      	movs	r3, #4
 8005272:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005274:	f7fd faf4 	bl	8002860 <gsl_error>
 8005278:	2300      	movs	r3, #0
 800527a:	e9c4 3300 	strd	r3, r3, [r4]
 800527e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005282:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005286:	4620      	mov	r0, r4
 8005288:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800528a:	4905      	ldr	r1, [pc, #20]	; (80052a0 <gsl_matrix_view_vector_with_tda+0x64>)
 800528c:	4806      	ldr	r0, [pc, #24]	; (80052a8 <gsl_matrix_view_vector_with_tda+0x6c>)
 800528e:	2304      	movs	r3, #4
 8005290:	227c      	movs	r2, #124	; 0x7c
 8005292:	e7ef      	b.n	8005274 <gsl_matrix_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005294:	4902      	ldr	r1, [pc, #8]	; (80052a0 <gsl_matrix_view_vector_with_tda+0x64>)
 8005296:	4805      	ldr	r0, [pc, #20]	; (80052ac <gsl_matrix_view_vector_with_tda+0x70>)
 8005298:	2304      	movs	r3, #4
 800529a:	2277      	movs	r2, #119	; 0x77
 800529c:	e7ea      	b.n	8005274 <gsl_matrix_view_vector_with_tda+0x38>
 800529e:	bf00      	nop
 80052a0:	080310b4 	.word	0x080310b4
 80052a4:	080310ec 	.word	0x080310ec
 80052a8:	0803110c 	.word	0x0803110c
 80052ac:	080310c4 	.word	0x080310c4

080052b0 <gsl_matrix_float_view_array>:
{
 80052b0:	b430      	push	{r4, r5}
    return view;
 80052b2:	2500      	movs	r5, #0
 80052b4:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80052b8:	e9c0 2300 	strd	r2, r3, [r0]
}
 80052bc:	bc30      	pop	{r4, r5}
    return view;
 80052be:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80052c2:	4770      	bx	lr

080052c4 <gsl_matrix_float_view_array_with_tda>:
{
 80052c4:	b538      	push	{r3, r4, r5, lr}
 80052c6:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80052c8:	42ab      	cmp	r3, r5
{
 80052ca:	4604      	mov	r4, r0
  if (n2 > tda)
 80052cc:	d808      	bhi.n	80052e0 <gsl_matrix_float_view_array_with_tda+0x1c>
    return view;
 80052ce:	2000      	movs	r0, #0
 80052d0:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80052d4:	e9c4 2300 	strd	r2, r3, [r4]
 80052d8:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80052dc:	4620      	mov	r0, r4
 80052de:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80052e0:	4907      	ldr	r1, [pc, #28]	; (8005300 <gsl_matrix_float_view_array_with_tda+0x3c>)
 80052e2:	4808      	ldr	r0, [pc, #32]	; (8005304 <gsl_matrix_float_view_array_with_tda+0x40>)
 80052e4:	2304      	movs	r3, #4
 80052e6:	2233      	movs	r2, #51	; 0x33
 80052e8:	f7fd faba 	bl	8002860 <gsl_error>
 80052ec:	2300      	movs	r3, #0
 80052ee:	e9c4 3300 	strd	r3, r3, [r4]
 80052f2:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80052f6:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80052fa:	4620      	mov	r0, r4
 80052fc:	bd38      	pop	{r3, r4, r5, pc}
 80052fe:	bf00      	nop
 8005300:	080310b4 	.word	0x080310b4
 8005304:	080310c4 	.word	0x080310c4

08005308 <gsl_matrix_float_view_vector>:
{
 8005308:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 800530a:	684d      	ldr	r5, [r1, #4]
 800530c:	2d01      	cmp	r5, #1
{
 800530e:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005310:	d10f      	bne.n	8005332 <gsl_matrix_float_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005312:	6808      	ldr	r0, [r1, #0]
 8005314:	fb03 f502 	mul.w	r5, r3, r2
 8005318:	4285      	cmp	r5, r0
 800531a:	d819      	bhi.n	8005350 <gsl_matrix_float_view_vector+0x48>
    m.block = v->block;
 800531c:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005320:	6022      	str	r2, [r4, #0]
 8005322:	2200      	movs	r2, #0
 8005324:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005328:	e9c4 3301 	strd	r3, r3, [r4, #4]
 800532c:	6162      	str	r2, [r4, #20]
}
 800532e:	4620      	mov	r0, r4
 8005330:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005332:	490a      	ldr	r1, [pc, #40]	; (800535c <gsl_matrix_float_view_vector+0x54>)
 8005334:	480a      	ldr	r0, [pc, #40]	; (8005360 <gsl_matrix_float_view_vector+0x58>)
 8005336:	2304      	movs	r3, #4
 8005338:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800533a:	f7fd fa91 	bl	8002860 <gsl_error>
 800533e:	2300      	movs	r3, #0
 8005340:	e9c4 3300 	strd	r3, r3, [r4]
 8005344:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005348:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800534c:	4620      	mov	r0, r4
 800534e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005350:	4902      	ldr	r1, [pc, #8]	; (800535c <gsl_matrix_float_view_vector+0x54>)
 8005352:	4804      	ldr	r0, [pc, #16]	; (8005364 <gsl_matrix_float_view_vector+0x5c>)
 8005354:	2304      	movs	r3, #4
 8005356:	2254      	movs	r2, #84	; 0x54
 8005358:	e7ef      	b.n	800533a <gsl_matrix_float_view_vector+0x32>
 800535a:	bf00      	nop
 800535c:	080310b4 	.word	0x080310b4
 8005360:	080310ec 	.word	0x080310ec
 8005364:	0803110c 	.word	0x0803110c

08005368 <gsl_matrix_float_view_vector_with_tda>:
{
 8005368:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 800536a:	684d      	ldr	r5, [r1, #4]
{
 800536c:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800536e:	2d01      	cmp	r5, #1
{
 8005370:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005372:	d111      	bne.n	8005398 <gsl_matrix_float_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005374:	42b3      	cmp	r3, r6
 8005376:	d823      	bhi.n	80053c0 <gsl_matrix_float_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005378:	6808      	ldr	r0, [r1, #0]
 800537a:	fb02 f506 	mul.w	r5, r2, r6
 800537e:	4285      	cmp	r5, r0
 8005380:	d819      	bhi.n	80053b6 <gsl_matrix_float_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005382:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005386:	6022      	str	r2, [r4, #0]
 8005388:	2200      	movs	r2, #0
 800538a:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800538e:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005392:	6162      	str	r2, [r4, #20]
}
 8005394:	4620      	mov	r0, r4
 8005396:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005398:	490c      	ldr	r1, [pc, #48]	; (80053cc <gsl_matrix_float_view_vector_with_tda+0x64>)
 800539a:	480d      	ldr	r0, [pc, #52]	; (80053d0 <gsl_matrix_float_view_vector_with_tda+0x68>)
 800539c:	2304      	movs	r3, #4
 800539e:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80053a0:	f7fd fa5e 	bl	8002860 <gsl_error>
 80053a4:	2300      	movs	r3, #0
 80053a6:	e9c4 3300 	strd	r3, r3, [r4]
 80053aa:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80053ae:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80053b2:	4620      	mov	r0, r4
 80053b4:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80053b6:	4905      	ldr	r1, [pc, #20]	; (80053cc <gsl_matrix_float_view_vector_with_tda+0x64>)
 80053b8:	4806      	ldr	r0, [pc, #24]	; (80053d4 <gsl_matrix_float_view_vector_with_tda+0x6c>)
 80053ba:	2304      	movs	r3, #4
 80053bc:	227c      	movs	r2, #124	; 0x7c
 80053be:	e7ef      	b.n	80053a0 <gsl_matrix_float_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80053c0:	4902      	ldr	r1, [pc, #8]	; (80053cc <gsl_matrix_float_view_vector_with_tda+0x64>)
 80053c2:	4805      	ldr	r0, [pc, #20]	; (80053d8 <gsl_matrix_float_view_vector_with_tda+0x70>)
 80053c4:	2304      	movs	r3, #4
 80053c6:	2277      	movs	r2, #119	; 0x77
 80053c8:	e7ea      	b.n	80053a0 <gsl_matrix_float_view_vector_with_tda+0x38>
 80053ca:	bf00      	nop
 80053cc:	080310b4 	.word	0x080310b4
 80053d0:	080310ec 	.word	0x080310ec
 80053d4:	0803110c 	.word	0x0803110c
 80053d8:	080310c4 	.word	0x080310c4

080053dc <gsl_matrix_ulong_view_array>:
{
 80053dc:	b430      	push	{r4, r5}
    return view;
 80053de:	2500      	movs	r5, #0
 80053e0:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80053e4:	e9c0 2300 	strd	r2, r3, [r0]
}
 80053e8:	bc30      	pop	{r4, r5}
    return view;
 80053ea:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80053ee:	4770      	bx	lr

080053f0 <gsl_matrix_ulong_view_array_with_tda>:
{
 80053f0:	b538      	push	{r3, r4, r5, lr}
 80053f2:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80053f4:	42ab      	cmp	r3, r5
{
 80053f6:	4604      	mov	r4, r0
  if (n2 > tda)
 80053f8:	d808      	bhi.n	800540c <gsl_matrix_ulong_view_array_with_tda+0x1c>
    return view;
 80053fa:	2000      	movs	r0, #0
 80053fc:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005400:	e9c4 2300 	strd	r2, r3, [r4]
 8005404:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005408:	4620      	mov	r0, r4
 800540a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 800540c:	4907      	ldr	r1, [pc, #28]	; (800542c <gsl_matrix_ulong_view_array_with_tda+0x3c>)
 800540e:	4808      	ldr	r0, [pc, #32]	; (8005430 <gsl_matrix_ulong_view_array_with_tda+0x40>)
 8005410:	2304      	movs	r3, #4
 8005412:	2233      	movs	r2, #51	; 0x33
 8005414:	f7fd fa24 	bl	8002860 <gsl_error>
 8005418:	2300      	movs	r3, #0
 800541a:	e9c4 3300 	strd	r3, r3, [r4]
 800541e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005422:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005426:	4620      	mov	r0, r4
 8005428:	bd38      	pop	{r3, r4, r5, pc}
 800542a:	bf00      	nop
 800542c:	080310b4 	.word	0x080310b4
 8005430:	080310c4 	.word	0x080310c4

08005434 <gsl_matrix_ulong_view_vector>:
{
 8005434:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005436:	684d      	ldr	r5, [r1, #4]
 8005438:	2d01      	cmp	r5, #1
{
 800543a:	4604      	mov	r4, r0
  if (v->stride != 1)
 800543c:	d10f      	bne.n	800545e <gsl_matrix_ulong_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 800543e:	6808      	ldr	r0, [r1, #0]
 8005440:	fb03 f502 	mul.w	r5, r3, r2
 8005444:	4285      	cmp	r5, r0
 8005446:	d819      	bhi.n	800547c <gsl_matrix_ulong_view_vector+0x48>
    m.block = v->block;
 8005448:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800544c:	6022      	str	r2, [r4, #0]
 800544e:	2200      	movs	r2, #0
 8005450:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005454:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005458:	6162      	str	r2, [r4, #20]
}
 800545a:	4620      	mov	r0, r4
 800545c:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800545e:	490a      	ldr	r1, [pc, #40]	; (8005488 <gsl_matrix_ulong_view_vector+0x54>)
 8005460:	480a      	ldr	r0, [pc, #40]	; (800548c <gsl_matrix_ulong_view_vector+0x58>)
 8005462:	2304      	movs	r3, #4
 8005464:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005466:	f7fd f9fb 	bl	8002860 <gsl_error>
 800546a:	2300      	movs	r3, #0
 800546c:	e9c4 3300 	strd	r3, r3, [r4]
 8005470:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005474:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005478:	4620      	mov	r0, r4
 800547a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800547c:	4902      	ldr	r1, [pc, #8]	; (8005488 <gsl_matrix_ulong_view_vector+0x54>)
 800547e:	4804      	ldr	r0, [pc, #16]	; (8005490 <gsl_matrix_ulong_view_vector+0x5c>)
 8005480:	2304      	movs	r3, #4
 8005482:	2254      	movs	r2, #84	; 0x54
 8005484:	e7ef      	b.n	8005466 <gsl_matrix_ulong_view_vector+0x32>
 8005486:	bf00      	nop
 8005488:	080310b4 	.word	0x080310b4
 800548c:	080310ec 	.word	0x080310ec
 8005490:	0803110c 	.word	0x0803110c

08005494 <gsl_matrix_ulong_view_vector_with_tda>:
{
 8005494:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005496:	684d      	ldr	r5, [r1, #4]
{
 8005498:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800549a:	2d01      	cmp	r5, #1
{
 800549c:	4604      	mov	r4, r0
  if (v->stride != 1)
 800549e:	d111      	bne.n	80054c4 <gsl_matrix_ulong_view_vector_with_tda+0x30>
  else if (n2 > tda)
 80054a0:	42b3      	cmp	r3, r6
 80054a2:	d823      	bhi.n	80054ec <gsl_matrix_ulong_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 80054a4:	6808      	ldr	r0, [r1, #0]
 80054a6:	fb02 f506 	mul.w	r5, r2, r6
 80054aa:	4285      	cmp	r5, r0
 80054ac:	d819      	bhi.n	80054e2 <gsl_matrix_ulong_view_vector_with_tda+0x4e>
    m.block = v->block;
 80054ae:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80054b2:	6022      	str	r2, [r4, #0]
 80054b4:	2200      	movs	r2, #0
 80054b6:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80054ba:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80054be:	6162      	str	r2, [r4, #20]
}
 80054c0:	4620      	mov	r0, r4
 80054c2:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80054c4:	490c      	ldr	r1, [pc, #48]	; (80054f8 <gsl_matrix_ulong_view_vector_with_tda+0x64>)
 80054c6:	480d      	ldr	r0, [pc, #52]	; (80054fc <gsl_matrix_ulong_view_vector_with_tda+0x68>)
 80054c8:	2304      	movs	r3, #4
 80054ca:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80054cc:	f7fd f9c8 	bl	8002860 <gsl_error>
 80054d0:	2300      	movs	r3, #0
 80054d2:	e9c4 3300 	strd	r3, r3, [r4]
 80054d6:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80054da:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80054de:	4620      	mov	r0, r4
 80054e0:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80054e2:	4905      	ldr	r1, [pc, #20]	; (80054f8 <gsl_matrix_ulong_view_vector_with_tda+0x64>)
 80054e4:	4806      	ldr	r0, [pc, #24]	; (8005500 <gsl_matrix_ulong_view_vector_with_tda+0x6c>)
 80054e6:	2304      	movs	r3, #4
 80054e8:	227c      	movs	r2, #124	; 0x7c
 80054ea:	e7ef      	b.n	80054cc <gsl_matrix_ulong_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80054ec:	4902      	ldr	r1, [pc, #8]	; (80054f8 <gsl_matrix_ulong_view_vector_with_tda+0x64>)
 80054ee:	4805      	ldr	r0, [pc, #20]	; (8005504 <gsl_matrix_ulong_view_vector_with_tda+0x70>)
 80054f0:	2304      	movs	r3, #4
 80054f2:	2277      	movs	r2, #119	; 0x77
 80054f4:	e7ea      	b.n	80054cc <gsl_matrix_ulong_view_vector_with_tda+0x38>
 80054f6:	bf00      	nop
 80054f8:	080310b4 	.word	0x080310b4
 80054fc:	080310ec 	.word	0x080310ec
 8005500:	0803110c 	.word	0x0803110c
 8005504:	080310c4 	.word	0x080310c4

08005508 <gsl_matrix_long_view_array>:
{
 8005508:	b430      	push	{r4, r5}
    return view;
 800550a:	2500      	movs	r5, #0
 800550c:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005510:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005514:	bc30      	pop	{r4, r5}
    return view;
 8005516:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 800551a:	4770      	bx	lr

0800551c <gsl_matrix_long_view_array_with_tda>:
{
 800551c:	b538      	push	{r3, r4, r5, lr}
 800551e:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005520:	42ab      	cmp	r3, r5
{
 8005522:	4604      	mov	r4, r0
  if (n2 > tda)
 8005524:	d808      	bhi.n	8005538 <gsl_matrix_long_view_array_with_tda+0x1c>
    return view;
 8005526:	2000      	movs	r0, #0
 8005528:	e9c4 0004 	strd	r0, r0, [r4, #16]
 800552c:	e9c4 2300 	strd	r2, r3, [r4]
 8005530:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005534:	4620      	mov	r0, r4
 8005536:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005538:	4907      	ldr	r1, [pc, #28]	; (8005558 <gsl_matrix_long_view_array_with_tda+0x3c>)
 800553a:	4808      	ldr	r0, [pc, #32]	; (800555c <gsl_matrix_long_view_array_with_tda+0x40>)
 800553c:	2304      	movs	r3, #4
 800553e:	2233      	movs	r2, #51	; 0x33
 8005540:	f7fd f98e 	bl	8002860 <gsl_error>
 8005544:	2300      	movs	r3, #0
 8005546:	e9c4 3300 	strd	r3, r3, [r4]
 800554a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800554e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005552:	4620      	mov	r0, r4
 8005554:	bd38      	pop	{r3, r4, r5, pc}
 8005556:	bf00      	nop
 8005558:	080310b4 	.word	0x080310b4
 800555c:	080310c4 	.word	0x080310c4

08005560 <gsl_matrix_long_view_vector>:
{
 8005560:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005562:	684d      	ldr	r5, [r1, #4]
 8005564:	2d01      	cmp	r5, #1
{
 8005566:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005568:	d10f      	bne.n	800558a <gsl_matrix_long_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 800556a:	6808      	ldr	r0, [r1, #0]
 800556c:	fb03 f502 	mul.w	r5, r3, r2
 8005570:	4285      	cmp	r5, r0
 8005572:	d819      	bhi.n	80055a8 <gsl_matrix_long_view_vector+0x48>
    m.block = v->block;
 8005574:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005578:	6022      	str	r2, [r4, #0]
 800557a:	2200      	movs	r2, #0
 800557c:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005580:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005584:	6162      	str	r2, [r4, #20]
}
 8005586:	4620      	mov	r0, r4
 8005588:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800558a:	490a      	ldr	r1, [pc, #40]	; (80055b4 <gsl_matrix_long_view_vector+0x54>)
 800558c:	480a      	ldr	r0, [pc, #40]	; (80055b8 <gsl_matrix_long_view_vector+0x58>)
 800558e:	2304      	movs	r3, #4
 8005590:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005592:	f7fd f965 	bl	8002860 <gsl_error>
 8005596:	2300      	movs	r3, #0
 8005598:	e9c4 3300 	strd	r3, r3, [r4]
 800559c:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80055a0:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80055a4:	4620      	mov	r0, r4
 80055a6:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80055a8:	4902      	ldr	r1, [pc, #8]	; (80055b4 <gsl_matrix_long_view_vector+0x54>)
 80055aa:	4804      	ldr	r0, [pc, #16]	; (80055bc <gsl_matrix_long_view_vector+0x5c>)
 80055ac:	2304      	movs	r3, #4
 80055ae:	2254      	movs	r2, #84	; 0x54
 80055b0:	e7ef      	b.n	8005592 <gsl_matrix_long_view_vector+0x32>
 80055b2:	bf00      	nop
 80055b4:	080310b4 	.word	0x080310b4
 80055b8:	080310ec 	.word	0x080310ec
 80055bc:	0803110c 	.word	0x0803110c

080055c0 <gsl_matrix_long_view_vector_with_tda>:
{
 80055c0:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 80055c2:	684d      	ldr	r5, [r1, #4]
{
 80055c4:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 80055c6:	2d01      	cmp	r5, #1
{
 80055c8:	4604      	mov	r4, r0
  if (v->stride != 1)
 80055ca:	d111      	bne.n	80055f0 <gsl_matrix_long_view_vector_with_tda+0x30>
  else if (n2 > tda)
 80055cc:	42b3      	cmp	r3, r6
 80055ce:	d823      	bhi.n	8005618 <gsl_matrix_long_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 80055d0:	6808      	ldr	r0, [r1, #0]
 80055d2:	fb02 f506 	mul.w	r5, r2, r6
 80055d6:	4285      	cmp	r5, r0
 80055d8:	d819      	bhi.n	800560e <gsl_matrix_long_view_vector_with_tda+0x4e>
    m.block = v->block;
 80055da:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80055de:	6022      	str	r2, [r4, #0]
 80055e0:	2200      	movs	r2, #0
 80055e2:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80055e6:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80055ea:	6162      	str	r2, [r4, #20]
}
 80055ec:	4620      	mov	r0, r4
 80055ee:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80055f0:	490c      	ldr	r1, [pc, #48]	; (8005624 <gsl_matrix_long_view_vector_with_tda+0x64>)
 80055f2:	480d      	ldr	r0, [pc, #52]	; (8005628 <gsl_matrix_long_view_vector_with_tda+0x68>)
 80055f4:	2304      	movs	r3, #4
 80055f6:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80055f8:	f7fd f932 	bl	8002860 <gsl_error>
 80055fc:	2300      	movs	r3, #0
 80055fe:	e9c4 3300 	strd	r3, r3, [r4]
 8005602:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005606:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800560a:	4620      	mov	r0, r4
 800560c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800560e:	4905      	ldr	r1, [pc, #20]	; (8005624 <gsl_matrix_long_view_vector_with_tda+0x64>)
 8005610:	4806      	ldr	r0, [pc, #24]	; (800562c <gsl_matrix_long_view_vector_with_tda+0x6c>)
 8005612:	2304      	movs	r3, #4
 8005614:	227c      	movs	r2, #124	; 0x7c
 8005616:	e7ef      	b.n	80055f8 <gsl_matrix_long_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005618:	4902      	ldr	r1, [pc, #8]	; (8005624 <gsl_matrix_long_view_vector_with_tda+0x64>)
 800561a:	4805      	ldr	r0, [pc, #20]	; (8005630 <gsl_matrix_long_view_vector_with_tda+0x70>)
 800561c:	2304      	movs	r3, #4
 800561e:	2277      	movs	r2, #119	; 0x77
 8005620:	e7ea      	b.n	80055f8 <gsl_matrix_long_view_vector_with_tda+0x38>
 8005622:	bf00      	nop
 8005624:	080310b4 	.word	0x080310b4
 8005628:	080310ec 	.word	0x080310ec
 800562c:	0803110c 	.word	0x0803110c
 8005630:	080310c4 	.word	0x080310c4

08005634 <gsl_matrix_uint_view_array>:
{
 8005634:	b430      	push	{r4, r5}
    return view;
 8005636:	2500      	movs	r5, #0
 8005638:	e9c0 5504 	strd	r5, r5, [r0, #16]
 800563c:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005640:	bc30      	pop	{r4, r5}
    return view;
 8005642:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005646:	4770      	bx	lr

08005648 <gsl_matrix_uint_view_array_with_tda>:
{
 8005648:	b538      	push	{r3, r4, r5, lr}
 800564a:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 800564c:	42ab      	cmp	r3, r5
{
 800564e:	4604      	mov	r4, r0
  if (n2 > tda)
 8005650:	d808      	bhi.n	8005664 <gsl_matrix_uint_view_array_with_tda+0x1c>
    return view;
 8005652:	2000      	movs	r0, #0
 8005654:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005658:	e9c4 2300 	strd	r2, r3, [r4]
 800565c:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005660:	4620      	mov	r0, r4
 8005662:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005664:	4907      	ldr	r1, [pc, #28]	; (8005684 <gsl_matrix_uint_view_array_with_tda+0x3c>)
 8005666:	4808      	ldr	r0, [pc, #32]	; (8005688 <gsl_matrix_uint_view_array_with_tda+0x40>)
 8005668:	2304      	movs	r3, #4
 800566a:	2233      	movs	r2, #51	; 0x33
 800566c:	f7fd f8f8 	bl	8002860 <gsl_error>
 8005670:	2300      	movs	r3, #0
 8005672:	e9c4 3300 	strd	r3, r3, [r4]
 8005676:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800567a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800567e:	4620      	mov	r0, r4
 8005680:	bd38      	pop	{r3, r4, r5, pc}
 8005682:	bf00      	nop
 8005684:	080310b4 	.word	0x080310b4
 8005688:	080310c4 	.word	0x080310c4

0800568c <gsl_matrix_uint_view_vector>:
{
 800568c:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 800568e:	684d      	ldr	r5, [r1, #4]
 8005690:	2d01      	cmp	r5, #1
{
 8005692:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005694:	d10f      	bne.n	80056b6 <gsl_matrix_uint_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005696:	6808      	ldr	r0, [r1, #0]
 8005698:	fb03 f502 	mul.w	r5, r3, r2
 800569c:	4285      	cmp	r5, r0
 800569e:	d819      	bhi.n	80056d4 <gsl_matrix_uint_view_vector+0x48>
    m.block = v->block;
 80056a0:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80056a4:	6022      	str	r2, [r4, #0]
 80056a6:	2200      	movs	r2, #0
 80056a8:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80056ac:	e9c4 3301 	strd	r3, r3, [r4, #4]
 80056b0:	6162      	str	r2, [r4, #20]
}
 80056b2:	4620      	mov	r0, r4
 80056b4:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80056b6:	490a      	ldr	r1, [pc, #40]	; (80056e0 <gsl_matrix_uint_view_vector+0x54>)
 80056b8:	480a      	ldr	r0, [pc, #40]	; (80056e4 <gsl_matrix_uint_view_vector+0x58>)
 80056ba:	2304      	movs	r3, #4
 80056bc:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80056be:	f7fd f8cf 	bl	8002860 <gsl_error>
 80056c2:	2300      	movs	r3, #0
 80056c4:	e9c4 3300 	strd	r3, r3, [r4]
 80056c8:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80056cc:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80056d0:	4620      	mov	r0, r4
 80056d2:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80056d4:	4902      	ldr	r1, [pc, #8]	; (80056e0 <gsl_matrix_uint_view_vector+0x54>)
 80056d6:	4804      	ldr	r0, [pc, #16]	; (80056e8 <gsl_matrix_uint_view_vector+0x5c>)
 80056d8:	2304      	movs	r3, #4
 80056da:	2254      	movs	r2, #84	; 0x54
 80056dc:	e7ef      	b.n	80056be <gsl_matrix_uint_view_vector+0x32>
 80056de:	bf00      	nop
 80056e0:	080310b4 	.word	0x080310b4
 80056e4:	080310ec 	.word	0x080310ec
 80056e8:	0803110c 	.word	0x0803110c

080056ec <gsl_matrix_uint_view_vector_with_tda>:
{
 80056ec:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 80056ee:	684d      	ldr	r5, [r1, #4]
{
 80056f0:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 80056f2:	2d01      	cmp	r5, #1
{
 80056f4:	4604      	mov	r4, r0
  if (v->stride != 1)
 80056f6:	d111      	bne.n	800571c <gsl_matrix_uint_view_vector_with_tda+0x30>
  else if (n2 > tda)
 80056f8:	42b3      	cmp	r3, r6
 80056fa:	d823      	bhi.n	8005744 <gsl_matrix_uint_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 80056fc:	6808      	ldr	r0, [r1, #0]
 80056fe:	fb02 f506 	mul.w	r5, r2, r6
 8005702:	4285      	cmp	r5, r0
 8005704:	d819      	bhi.n	800573a <gsl_matrix_uint_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005706:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800570a:	6022      	str	r2, [r4, #0]
 800570c:	2200      	movs	r2, #0
 800570e:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005712:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005716:	6162      	str	r2, [r4, #20]
}
 8005718:	4620      	mov	r0, r4
 800571a:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800571c:	490c      	ldr	r1, [pc, #48]	; (8005750 <gsl_matrix_uint_view_vector_with_tda+0x64>)
 800571e:	480d      	ldr	r0, [pc, #52]	; (8005754 <gsl_matrix_uint_view_vector_with_tda+0x68>)
 8005720:	2304      	movs	r3, #4
 8005722:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005724:	f7fd f89c 	bl	8002860 <gsl_error>
 8005728:	2300      	movs	r3, #0
 800572a:	e9c4 3300 	strd	r3, r3, [r4]
 800572e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005732:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005736:	4620      	mov	r0, r4
 8005738:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800573a:	4905      	ldr	r1, [pc, #20]	; (8005750 <gsl_matrix_uint_view_vector_with_tda+0x64>)
 800573c:	4806      	ldr	r0, [pc, #24]	; (8005758 <gsl_matrix_uint_view_vector_with_tda+0x6c>)
 800573e:	2304      	movs	r3, #4
 8005740:	227c      	movs	r2, #124	; 0x7c
 8005742:	e7ef      	b.n	8005724 <gsl_matrix_uint_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005744:	4902      	ldr	r1, [pc, #8]	; (8005750 <gsl_matrix_uint_view_vector_with_tda+0x64>)
 8005746:	4805      	ldr	r0, [pc, #20]	; (800575c <gsl_matrix_uint_view_vector_with_tda+0x70>)
 8005748:	2304      	movs	r3, #4
 800574a:	2277      	movs	r2, #119	; 0x77
 800574c:	e7ea      	b.n	8005724 <gsl_matrix_uint_view_vector_with_tda+0x38>
 800574e:	bf00      	nop
 8005750:	080310b4 	.word	0x080310b4
 8005754:	080310ec 	.word	0x080310ec
 8005758:	0803110c 	.word	0x0803110c
 800575c:	080310c4 	.word	0x080310c4

08005760 <gsl_matrix_int_view_array>:
{
 8005760:	b430      	push	{r4, r5}
    return view;
 8005762:	2500      	movs	r5, #0
 8005764:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005768:	e9c0 2300 	strd	r2, r3, [r0]
}
 800576c:	bc30      	pop	{r4, r5}
    return view;
 800576e:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005772:	4770      	bx	lr

08005774 <gsl_matrix_int_view_array_with_tda>:
{
 8005774:	b538      	push	{r3, r4, r5, lr}
 8005776:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005778:	42ab      	cmp	r3, r5
{
 800577a:	4604      	mov	r4, r0
  if (n2 > tda)
 800577c:	d808      	bhi.n	8005790 <gsl_matrix_int_view_array_with_tda+0x1c>
    return view;
 800577e:	2000      	movs	r0, #0
 8005780:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005784:	e9c4 2300 	strd	r2, r3, [r4]
 8005788:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 800578c:	4620      	mov	r0, r4
 800578e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005790:	4907      	ldr	r1, [pc, #28]	; (80057b0 <gsl_matrix_int_view_array_with_tda+0x3c>)
 8005792:	4808      	ldr	r0, [pc, #32]	; (80057b4 <gsl_matrix_int_view_array_with_tda+0x40>)
 8005794:	2304      	movs	r3, #4
 8005796:	2233      	movs	r2, #51	; 0x33
 8005798:	f7fd f862 	bl	8002860 <gsl_error>
 800579c:	2300      	movs	r3, #0
 800579e:	e9c4 3300 	strd	r3, r3, [r4]
 80057a2:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80057a6:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80057aa:	4620      	mov	r0, r4
 80057ac:	bd38      	pop	{r3, r4, r5, pc}
 80057ae:	bf00      	nop
 80057b0:	080310b4 	.word	0x080310b4
 80057b4:	080310c4 	.word	0x080310c4

080057b8 <gsl_matrix_int_view_vector>:
{
 80057b8:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 80057ba:	684d      	ldr	r5, [r1, #4]
 80057bc:	2d01      	cmp	r5, #1
{
 80057be:	4604      	mov	r4, r0
  if (v->stride != 1)
 80057c0:	d10f      	bne.n	80057e2 <gsl_matrix_int_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80057c2:	6808      	ldr	r0, [r1, #0]
 80057c4:	fb03 f502 	mul.w	r5, r3, r2
 80057c8:	4285      	cmp	r5, r0
 80057ca:	d819      	bhi.n	8005800 <gsl_matrix_int_view_vector+0x48>
    m.block = v->block;
 80057cc:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80057d0:	6022      	str	r2, [r4, #0]
 80057d2:	2200      	movs	r2, #0
 80057d4:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80057d8:	e9c4 3301 	strd	r3, r3, [r4, #4]
 80057dc:	6162      	str	r2, [r4, #20]
}
 80057de:	4620      	mov	r0, r4
 80057e0:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80057e2:	490a      	ldr	r1, [pc, #40]	; (800580c <gsl_matrix_int_view_vector+0x54>)
 80057e4:	480a      	ldr	r0, [pc, #40]	; (8005810 <gsl_matrix_int_view_vector+0x58>)
 80057e6:	2304      	movs	r3, #4
 80057e8:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80057ea:	f7fd f839 	bl	8002860 <gsl_error>
 80057ee:	2300      	movs	r3, #0
 80057f0:	e9c4 3300 	strd	r3, r3, [r4]
 80057f4:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80057f8:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80057fc:	4620      	mov	r0, r4
 80057fe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005800:	4902      	ldr	r1, [pc, #8]	; (800580c <gsl_matrix_int_view_vector+0x54>)
 8005802:	4804      	ldr	r0, [pc, #16]	; (8005814 <gsl_matrix_int_view_vector+0x5c>)
 8005804:	2304      	movs	r3, #4
 8005806:	2254      	movs	r2, #84	; 0x54
 8005808:	e7ef      	b.n	80057ea <gsl_matrix_int_view_vector+0x32>
 800580a:	bf00      	nop
 800580c:	080310b4 	.word	0x080310b4
 8005810:	080310ec 	.word	0x080310ec
 8005814:	0803110c 	.word	0x0803110c

08005818 <gsl_matrix_int_view_vector_with_tda>:
{
 8005818:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 800581a:	684d      	ldr	r5, [r1, #4]
{
 800581c:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800581e:	2d01      	cmp	r5, #1
{
 8005820:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005822:	d111      	bne.n	8005848 <gsl_matrix_int_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005824:	42b3      	cmp	r3, r6
 8005826:	d823      	bhi.n	8005870 <gsl_matrix_int_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005828:	6808      	ldr	r0, [r1, #0]
 800582a:	fb02 f506 	mul.w	r5, r2, r6
 800582e:	4285      	cmp	r5, r0
 8005830:	d819      	bhi.n	8005866 <gsl_matrix_int_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005832:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005836:	6022      	str	r2, [r4, #0]
 8005838:	2200      	movs	r2, #0
 800583a:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800583e:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005842:	6162      	str	r2, [r4, #20]
}
 8005844:	4620      	mov	r0, r4
 8005846:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005848:	490c      	ldr	r1, [pc, #48]	; (800587c <gsl_matrix_int_view_vector_with_tda+0x64>)
 800584a:	480d      	ldr	r0, [pc, #52]	; (8005880 <gsl_matrix_int_view_vector_with_tda+0x68>)
 800584c:	2304      	movs	r3, #4
 800584e:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005850:	f7fd f806 	bl	8002860 <gsl_error>
 8005854:	2300      	movs	r3, #0
 8005856:	e9c4 3300 	strd	r3, r3, [r4]
 800585a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800585e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005862:	4620      	mov	r0, r4
 8005864:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005866:	4905      	ldr	r1, [pc, #20]	; (800587c <gsl_matrix_int_view_vector_with_tda+0x64>)
 8005868:	4806      	ldr	r0, [pc, #24]	; (8005884 <gsl_matrix_int_view_vector_with_tda+0x6c>)
 800586a:	2304      	movs	r3, #4
 800586c:	227c      	movs	r2, #124	; 0x7c
 800586e:	e7ef      	b.n	8005850 <gsl_matrix_int_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005870:	4902      	ldr	r1, [pc, #8]	; (800587c <gsl_matrix_int_view_vector_with_tda+0x64>)
 8005872:	4805      	ldr	r0, [pc, #20]	; (8005888 <gsl_matrix_int_view_vector_with_tda+0x70>)
 8005874:	2304      	movs	r3, #4
 8005876:	2277      	movs	r2, #119	; 0x77
 8005878:	e7ea      	b.n	8005850 <gsl_matrix_int_view_vector_with_tda+0x38>
 800587a:	bf00      	nop
 800587c:	080310b4 	.word	0x080310b4
 8005880:	080310ec 	.word	0x080310ec
 8005884:	0803110c 	.word	0x0803110c
 8005888:	080310c4 	.word	0x080310c4

0800588c <gsl_matrix_ushort_view_array>:
{
 800588c:	b430      	push	{r4, r5}
    return view;
 800588e:	2500      	movs	r5, #0
 8005890:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005894:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005898:	bc30      	pop	{r4, r5}
    return view;
 800589a:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 800589e:	4770      	bx	lr

080058a0 <gsl_matrix_ushort_view_array_with_tda>:
{
 80058a0:	b538      	push	{r3, r4, r5, lr}
 80058a2:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80058a4:	42ab      	cmp	r3, r5
{
 80058a6:	4604      	mov	r4, r0
  if (n2 > tda)
 80058a8:	d808      	bhi.n	80058bc <gsl_matrix_ushort_view_array_with_tda+0x1c>
    return view;
 80058aa:	2000      	movs	r0, #0
 80058ac:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80058b0:	e9c4 2300 	strd	r2, r3, [r4]
 80058b4:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80058b8:	4620      	mov	r0, r4
 80058ba:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80058bc:	4907      	ldr	r1, [pc, #28]	; (80058dc <gsl_matrix_ushort_view_array_with_tda+0x3c>)
 80058be:	4808      	ldr	r0, [pc, #32]	; (80058e0 <gsl_matrix_ushort_view_array_with_tda+0x40>)
 80058c0:	2304      	movs	r3, #4
 80058c2:	2233      	movs	r2, #51	; 0x33
 80058c4:	f7fc ffcc 	bl	8002860 <gsl_error>
 80058c8:	2300      	movs	r3, #0
 80058ca:	e9c4 3300 	strd	r3, r3, [r4]
 80058ce:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80058d2:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80058d6:	4620      	mov	r0, r4
 80058d8:	bd38      	pop	{r3, r4, r5, pc}
 80058da:	bf00      	nop
 80058dc:	080310b4 	.word	0x080310b4
 80058e0:	080310c4 	.word	0x080310c4

080058e4 <gsl_matrix_ushort_view_vector>:
{
 80058e4:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 80058e6:	684d      	ldr	r5, [r1, #4]
 80058e8:	2d01      	cmp	r5, #1
{
 80058ea:	4604      	mov	r4, r0
  if (v->stride != 1)
 80058ec:	d10f      	bne.n	800590e <gsl_matrix_ushort_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80058ee:	6808      	ldr	r0, [r1, #0]
 80058f0:	fb03 f502 	mul.w	r5, r3, r2
 80058f4:	4285      	cmp	r5, r0
 80058f6:	d819      	bhi.n	800592c <gsl_matrix_ushort_view_vector+0x48>
    m.block = v->block;
 80058f8:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80058fc:	6022      	str	r2, [r4, #0]
 80058fe:	2200      	movs	r2, #0
 8005900:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005904:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005908:	6162      	str	r2, [r4, #20]
}
 800590a:	4620      	mov	r0, r4
 800590c:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800590e:	490a      	ldr	r1, [pc, #40]	; (8005938 <gsl_matrix_ushort_view_vector+0x54>)
 8005910:	480a      	ldr	r0, [pc, #40]	; (800593c <gsl_matrix_ushort_view_vector+0x58>)
 8005912:	2304      	movs	r3, #4
 8005914:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005916:	f7fc ffa3 	bl	8002860 <gsl_error>
 800591a:	2300      	movs	r3, #0
 800591c:	e9c4 3300 	strd	r3, r3, [r4]
 8005920:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005924:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005928:	4620      	mov	r0, r4
 800592a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800592c:	4902      	ldr	r1, [pc, #8]	; (8005938 <gsl_matrix_ushort_view_vector+0x54>)
 800592e:	4804      	ldr	r0, [pc, #16]	; (8005940 <gsl_matrix_ushort_view_vector+0x5c>)
 8005930:	2304      	movs	r3, #4
 8005932:	2254      	movs	r2, #84	; 0x54
 8005934:	e7ef      	b.n	8005916 <gsl_matrix_ushort_view_vector+0x32>
 8005936:	bf00      	nop
 8005938:	080310b4 	.word	0x080310b4
 800593c:	080310ec 	.word	0x080310ec
 8005940:	0803110c 	.word	0x0803110c

08005944 <gsl_matrix_ushort_view_vector_with_tda>:
{
 8005944:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005946:	684d      	ldr	r5, [r1, #4]
{
 8005948:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800594a:	2d01      	cmp	r5, #1
{
 800594c:	4604      	mov	r4, r0
  if (v->stride != 1)
 800594e:	d111      	bne.n	8005974 <gsl_matrix_ushort_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005950:	42b3      	cmp	r3, r6
 8005952:	d823      	bhi.n	800599c <gsl_matrix_ushort_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005954:	6808      	ldr	r0, [r1, #0]
 8005956:	fb02 f506 	mul.w	r5, r2, r6
 800595a:	4285      	cmp	r5, r0
 800595c:	d819      	bhi.n	8005992 <gsl_matrix_ushort_view_vector_with_tda+0x4e>
    m.block = v->block;
 800595e:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005962:	6022      	str	r2, [r4, #0]
 8005964:	2200      	movs	r2, #0
 8005966:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800596a:	e9c4 3601 	strd	r3, r6, [r4, #4]
 800596e:	6162      	str	r2, [r4, #20]
}
 8005970:	4620      	mov	r0, r4
 8005972:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005974:	490c      	ldr	r1, [pc, #48]	; (80059a8 <gsl_matrix_ushort_view_vector_with_tda+0x64>)
 8005976:	480d      	ldr	r0, [pc, #52]	; (80059ac <gsl_matrix_ushort_view_vector_with_tda+0x68>)
 8005978:	2304      	movs	r3, #4
 800597a:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800597c:	f7fc ff70 	bl	8002860 <gsl_error>
 8005980:	2300      	movs	r3, #0
 8005982:	e9c4 3300 	strd	r3, r3, [r4]
 8005986:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800598a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800598e:	4620      	mov	r0, r4
 8005990:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005992:	4905      	ldr	r1, [pc, #20]	; (80059a8 <gsl_matrix_ushort_view_vector_with_tda+0x64>)
 8005994:	4806      	ldr	r0, [pc, #24]	; (80059b0 <gsl_matrix_ushort_view_vector_with_tda+0x6c>)
 8005996:	2304      	movs	r3, #4
 8005998:	227c      	movs	r2, #124	; 0x7c
 800599a:	e7ef      	b.n	800597c <gsl_matrix_ushort_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 800599c:	4902      	ldr	r1, [pc, #8]	; (80059a8 <gsl_matrix_ushort_view_vector_with_tda+0x64>)
 800599e:	4805      	ldr	r0, [pc, #20]	; (80059b4 <gsl_matrix_ushort_view_vector_with_tda+0x70>)
 80059a0:	2304      	movs	r3, #4
 80059a2:	2277      	movs	r2, #119	; 0x77
 80059a4:	e7ea      	b.n	800597c <gsl_matrix_ushort_view_vector_with_tda+0x38>
 80059a6:	bf00      	nop
 80059a8:	080310b4 	.word	0x080310b4
 80059ac:	080310ec 	.word	0x080310ec
 80059b0:	0803110c 	.word	0x0803110c
 80059b4:	080310c4 	.word	0x080310c4

080059b8 <gsl_matrix_short_view_array>:
{
 80059b8:	b430      	push	{r4, r5}
    return view;
 80059ba:	2500      	movs	r5, #0
 80059bc:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80059c0:	e9c0 2300 	strd	r2, r3, [r0]
}
 80059c4:	bc30      	pop	{r4, r5}
    return view;
 80059c6:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80059ca:	4770      	bx	lr

080059cc <gsl_matrix_short_view_array_with_tda>:
{
 80059cc:	b538      	push	{r3, r4, r5, lr}
 80059ce:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80059d0:	42ab      	cmp	r3, r5
{
 80059d2:	4604      	mov	r4, r0
  if (n2 > tda)
 80059d4:	d808      	bhi.n	80059e8 <gsl_matrix_short_view_array_with_tda+0x1c>
    return view;
 80059d6:	2000      	movs	r0, #0
 80059d8:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80059dc:	e9c4 2300 	strd	r2, r3, [r4]
 80059e0:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80059e4:	4620      	mov	r0, r4
 80059e6:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80059e8:	4907      	ldr	r1, [pc, #28]	; (8005a08 <gsl_matrix_short_view_array_with_tda+0x3c>)
 80059ea:	4808      	ldr	r0, [pc, #32]	; (8005a0c <gsl_matrix_short_view_array_with_tda+0x40>)
 80059ec:	2304      	movs	r3, #4
 80059ee:	2233      	movs	r2, #51	; 0x33
 80059f0:	f7fc ff36 	bl	8002860 <gsl_error>
 80059f4:	2300      	movs	r3, #0
 80059f6:	e9c4 3300 	strd	r3, r3, [r4]
 80059fa:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80059fe:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005a02:	4620      	mov	r0, r4
 8005a04:	bd38      	pop	{r3, r4, r5, pc}
 8005a06:	bf00      	nop
 8005a08:	080310b4 	.word	0x080310b4
 8005a0c:	080310c4 	.word	0x080310c4

08005a10 <gsl_matrix_short_view_vector>:
{
 8005a10:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005a12:	684d      	ldr	r5, [r1, #4]
 8005a14:	2d01      	cmp	r5, #1
{
 8005a16:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005a18:	d10f      	bne.n	8005a3a <gsl_matrix_short_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005a1a:	6808      	ldr	r0, [r1, #0]
 8005a1c:	fb03 f502 	mul.w	r5, r3, r2
 8005a20:	4285      	cmp	r5, r0
 8005a22:	d819      	bhi.n	8005a58 <gsl_matrix_short_view_vector+0x48>
    m.block = v->block;
 8005a24:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005a28:	6022      	str	r2, [r4, #0]
 8005a2a:	2200      	movs	r2, #0
 8005a2c:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005a30:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005a34:	6162      	str	r2, [r4, #20]
}
 8005a36:	4620      	mov	r0, r4
 8005a38:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005a3a:	490a      	ldr	r1, [pc, #40]	; (8005a64 <gsl_matrix_short_view_vector+0x54>)
 8005a3c:	480a      	ldr	r0, [pc, #40]	; (8005a68 <gsl_matrix_short_view_vector+0x58>)
 8005a3e:	2304      	movs	r3, #4
 8005a40:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005a42:	f7fc ff0d 	bl	8002860 <gsl_error>
 8005a46:	2300      	movs	r3, #0
 8005a48:	e9c4 3300 	strd	r3, r3, [r4]
 8005a4c:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005a50:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005a54:	4620      	mov	r0, r4
 8005a56:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005a58:	4902      	ldr	r1, [pc, #8]	; (8005a64 <gsl_matrix_short_view_vector+0x54>)
 8005a5a:	4804      	ldr	r0, [pc, #16]	; (8005a6c <gsl_matrix_short_view_vector+0x5c>)
 8005a5c:	2304      	movs	r3, #4
 8005a5e:	2254      	movs	r2, #84	; 0x54
 8005a60:	e7ef      	b.n	8005a42 <gsl_matrix_short_view_vector+0x32>
 8005a62:	bf00      	nop
 8005a64:	080310b4 	.word	0x080310b4
 8005a68:	080310ec 	.word	0x080310ec
 8005a6c:	0803110c 	.word	0x0803110c

08005a70 <gsl_matrix_short_view_vector_with_tda>:
{
 8005a70:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005a72:	684d      	ldr	r5, [r1, #4]
{
 8005a74:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005a76:	2d01      	cmp	r5, #1
{
 8005a78:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005a7a:	d111      	bne.n	8005aa0 <gsl_matrix_short_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005a7c:	42b3      	cmp	r3, r6
 8005a7e:	d823      	bhi.n	8005ac8 <gsl_matrix_short_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005a80:	6808      	ldr	r0, [r1, #0]
 8005a82:	fb02 f506 	mul.w	r5, r2, r6
 8005a86:	4285      	cmp	r5, r0
 8005a88:	d819      	bhi.n	8005abe <gsl_matrix_short_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005a8a:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005a8e:	6022      	str	r2, [r4, #0]
 8005a90:	2200      	movs	r2, #0
 8005a92:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005a96:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005a9a:	6162      	str	r2, [r4, #20]
}
 8005a9c:	4620      	mov	r0, r4
 8005a9e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005aa0:	490c      	ldr	r1, [pc, #48]	; (8005ad4 <gsl_matrix_short_view_vector_with_tda+0x64>)
 8005aa2:	480d      	ldr	r0, [pc, #52]	; (8005ad8 <gsl_matrix_short_view_vector_with_tda+0x68>)
 8005aa4:	2304      	movs	r3, #4
 8005aa6:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005aa8:	f7fc feda 	bl	8002860 <gsl_error>
 8005aac:	2300      	movs	r3, #0
 8005aae:	e9c4 3300 	strd	r3, r3, [r4]
 8005ab2:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005ab6:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005aba:	4620      	mov	r0, r4
 8005abc:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005abe:	4905      	ldr	r1, [pc, #20]	; (8005ad4 <gsl_matrix_short_view_vector_with_tda+0x64>)
 8005ac0:	4806      	ldr	r0, [pc, #24]	; (8005adc <gsl_matrix_short_view_vector_with_tda+0x6c>)
 8005ac2:	2304      	movs	r3, #4
 8005ac4:	227c      	movs	r2, #124	; 0x7c
 8005ac6:	e7ef      	b.n	8005aa8 <gsl_matrix_short_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005ac8:	4902      	ldr	r1, [pc, #8]	; (8005ad4 <gsl_matrix_short_view_vector_with_tda+0x64>)
 8005aca:	4805      	ldr	r0, [pc, #20]	; (8005ae0 <gsl_matrix_short_view_vector_with_tda+0x70>)
 8005acc:	2304      	movs	r3, #4
 8005ace:	2277      	movs	r2, #119	; 0x77
 8005ad0:	e7ea      	b.n	8005aa8 <gsl_matrix_short_view_vector_with_tda+0x38>
 8005ad2:	bf00      	nop
 8005ad4:	080310b4 	.word	0x080310b4
 8005ad8:	080310ec 	.word	0x080310ec
 8005adc:	0803110c 	.word	0x0803110c
 8005ae0:	080310c4 	.word	0x080310c4

08005ae4 <gsl_matrix_uchar_view_array>:
{
 8005ae4:	b430      	push	{r4, r5}
    return view;
 8005ae6:	2500      	movs	r5, #0
 8005ae8:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005aec:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005af0:	bc30      	pop	{r4, r5}
    return view;
 8005af2:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005af6:	4770      	bx	lr

08005af8 <gsl_matrix_uchar_view_array_with_tda>:
{
 8005af8:	b538      	push	{r3, r4, r5, lr}
 8005afa:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005afc:	42ab      	cmp	r3, r5
{
 8005afe:	4604      	mov	r4, r0
  if (n2 > tda)
 8005b00:	d808      	bhi.n	8005b14 <gsl_matrix_uchar_view_array_with_tda+0x1c>
    return view;
 8005b02:	2000      	movs	r0, #0
 8005b04:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005b08:	e9c4 2300 	strd	r2, r3, [r4]
 8005b0c:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005b10:	4620      	mov	r0, r4
 8005b12:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005b14:	4907      	ldr	r1, [pc, #28]	; (8005b34 <gsl_matrix_uchar_view_array_with_tda+0x3c>)
 8005b16:	4808      	ldr	r0, [pc, #32]	; (8005b38 <gsl_matrix_uchar_view_array_with_tda+0x40>)
 8005b18:	2304      	movs	r3, #4
 8005b1a:	2233      	movs	r2, #51	; 0x33
 8005b1c:	f7fc fea0 	bl	8002860 <gsl_error>
 8005b20:	2300      	movs	r3, #0
 8005b22:	e9c4 3300 	strd	r3, r3, [r4]
 8005b26:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005b2a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005b2e:	4620      	mov	r0, r4
 8005b30:	bd38      	pop	{r3, r4, r5, pc}
 8005b32:	bf00      	nop
 8005b34:	080310b4 	.word	0x080310b4
 8005b38:	080310c4 	.word	0x080310c4

08005b3c <gsl_matrix_uchar_view_vector>:
{
 8005b3c:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005b3e:	684d      	ldr	r5, [r1, #4]
 8005b40:	2d01      	cmp	r5, #1
{
 8005b42:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005b44:	d10f      	bne.n	8005b66 <gsl_matrix_uchar_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005b46:	6808      	ldr	r0, [r1, #0]
 8005b48:	fb03 f502 	mul.w	r5, r3, r2
 8005b4c:	4285      	cmp	r5, r0
 8005b4e:	d819      	bhi.n	8005b84 <gsl_matrix_uchar_view_vector+0x48>
    m.block = v->block;
 8005b50:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005b54:	6022      	str	r2, [r4, #0]
 8005b56:	2200      	movs	r2, #0
 8005b58:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005b5c:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005b60:	6162      	str	r2, [r4, #20]
}
 8005b62:	4620      	mov	r0, r4
 8005b64:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005b66:	490a      	ldr	r1, [pc, #40]	; (8005b90 <gsl_matrix_uchar_view_vector+0x54>)
 8005b68:	480a      	ldr	r0, [pc, #40]	; (8005b94 <gsl_matrix_uchar_view_vector+0x58>)
 8005b6a:	2304      	movs	r3, #4
 8005b6c:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005b6e:	f7fc fe77 	bl	8002860 <gsl_error>
 8005b72:	2300      	movs	r3, #0
 8005b74:	e9c4 3300 	strd	r3, r3, [r4]
 8005b78:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005b7c:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005b80:	4620      	mov	r0, r4
 8005b82:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005b84:	4902      	ldr	r1, [pc, #8]	; (8005b90 <gsl_matrix_uchar_view_vector+0x54>)
 8005b86:	4804      	ldr	r0, [pc, #16]	; (8005b98 <gsl_matrix_uchar_view_vector+0x5c>)
 8005b88:	2304      	movs	r3, #4
 8005b8a:	2254      	movs	r2, #84	; 0x54
 8005b8c:	e7ef      	b.n	8005b6e <gsl_matrix_uchar_view_vector+0x32>
 8005b8e:	bf00      	nop
 8005b90:	080310b4 	.word	0x080310b4
 8005b94:	080310ec 	.word	0x080310ec
 8005b98:	0803110c 	.word	0x0803110c

08005b9c <gsl_matrix_uchar_view_vector_with_tda>:
{
 8005b9c:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005b9e:	684d      	ldr	r5, [r1, #4]
{
 8005ba0:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005ba2:	2d01      	cmp	r5, #1
{
 8005ba4:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005ba6:	d111      	bne.n	8005bcc <gsl_matrix_uchar_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005ba8:	42b3      	cmp	r3, r6
 8005baa:	d823      	bhi.n	8005bf4 <gsl_matrix_uchar_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005bac:	6808      	ldr	r0, [r1, #0]
 8005bae:	fb02 f506 	mul.w	r5, r2, r6
 8005bb2:	4285      	cmp	r5, r0
 8005bb4:	d819      	bhi.n	8005bea <gsl_matrix_uchar_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005bb6:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005bba:	6022      	str	r2, [r4, #0]
 8005bbc:	2200      	movs	r2, #0
 8005bbe:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005bc2:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005bc6:	6162      	str	r2, [r4, #20]
}
 8005bc8:	4620      	mov	r0, r4
 8005bca:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005bcc:	490c      	ldr	r1, [pc, #48]	; (8005c00 <gsl_matrix_uchar_view_vector_with_tda+0x64>)
 8005bce:	480d      	ldr	r0, [pc, #52]	; (8005c04 <gsl_matrix_uchar_view_vector_with_tda+0x68>)
 8005bd0:	2304      	movs	r3, #4
 8005bd2:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005bd4:	f7fc fe44 	bl	8002860 <gsl_error>
 8005bd8:	2300      	movs	r3, #0
 8005bda:	e9c4 3300 	strd	r3, r3, [r4]
 8005bde:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005be2:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005be6:	4620      	mov	r0, r4
 8005be8:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005bea:	4905      	ldr	r1, [pc, #20]	; (8005c00 <gsl_matrix_uchar_view_vector_with_tda+0x64>)
 8005bec:	4806      	ldr	r0, [pc, #24]	; (8005c08 <gsl_matrix_uchar_view_vector_with_tda+0x6c>)
 8005bee:	2304      	movs	r3, #4
 8005bf0:	227c      	movs	r2, #124	; 0x7c
 8005bf2:	e7ef      	b.n	8005bd4 <gsl_matrix_uchar_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005bf4:	4902      	ldr	r1, [pc, #8]	; (8005c00 <gsl_matrix_uchar_view_vector_with_tda+0x64>)
 8005bf6:	4805      	ldr	r0, [pc, #20]	; (8005c0c <gsl_matrix_uchar_view_vector_with_tda+0x70>)
 8005bf8:	2304      	movs	r3, #4
 8005bfa:	2277      	movs	r2, #119	; 0x77
 8005bfc:	e7ea      	b.n	8005bd4 <gsl_matrix_uchar_view_vector_with_tda+0x38>
 8005bfe:	bf00      	nop
 8005c00:	080310b4 	.word	0x080310b4
 8005c04:	080310ec 	.word	0x080310ec
 8005c08:	0803110c 	.word	0x0803110c
 8005c0c:	080310c4 	.word	0x080310c4

08005c10 <gsl_matrix_char_view_array>:
{
 8005c10:	b430      	push	{r4, r5}
    return view;
 8005c12:	2500      	movs	r5, #0
 8005c14:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005c18:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005c1c:	bc30      	pop	{r4, r5}
    return view;
 8005c1e:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005c22:	4770      	bx	lr

08005c24 <gsl_matrix_char_view_array_with_tda>:
{
 8005c24:	b538      	push	{r3, r4, r5, lr}
 8005c26:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005c28:	42ab      	cmp	r3, r5
{
 8005c2a:	4604      	mov	r4, r0
  if (n2 > tda)
 8005c2c:	d808      	bhi.n	8005c40 <gsl_matrix_char_view_array_with_tda+0x1c>
    return view;
 8005c2e:	2000      	movs	r0, #0
 8005c30:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005c34:	e9c4 2300 	strd	r2, r3, [r4]
 8005c38:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005c3c:	4620      	mov	r0, r4
 8005c3e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005c40:	4907      	ldr	r1, [pc, #28]	; (8005c60 <gsl_matrix_char_view_array_with_tda+0x3c>)
 8005c42:	4808      	ldr	r0, [pc, #32]	; (8005c64 <gsl_matrix_char_view_array_with_tda+0x40>)
 8005c44:	2304      	movs	r3, #4
 8005c46:	2233      	movs	r2, #51	; 0x33
 8005c48:	f7fc fe0a 	bl	8002860 <gsl_error>
 8005c4c:	2300      	movs	r3, #0
 8005c4e:	e9c4 3300 	strd	r3, r3, [r4]
 8005c52:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005c56:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005c5a:	4620      	mov	r0, r4
 8005c5c:	bd38      	pop	{r3, r4, r5, pc}
 8005c5e:	bf00      	nop
 8005c60:	080310b4 	.word	0x080310b4
 8005c64:	080310c4 	.word	0x080310c4

08005c68 <gsl_matrix_char_view_vector>:
{
 8005c68:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005c6a:	684d      	ldr	r5, [r1, #4]
 8005c6c:	2d01      	cmp	r5, #1
{
 8005c6e:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005c70:	d10f      	bne.n	8005c92 <gsl_matrix_char_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005c72:	6808      	ldr	r0, [r1, #0]
 8005c74:	fb03 f502 	mul.w	r5, r3, r2
 8005c78:	4285      	cmp	r5, r0
 8005c7a:	d819      	bhi.n	8005cb0 <gsl_matrix_char_view_vector+0x48>
    m.block = v->block;
 8005c7c:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005c80:	6022      	str	r2, [r4, #0]
 8005c82:	2200      	movs	r2, #0
 8005c84:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005c88:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005c8c:	6162      	str	r2, [r4, #20]
}
 8005c8e:	4620      	mov	r0, r4
 8005c90:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005c92:	490a      	ldr	r1, [pc, #40]	; (8005cbc <gsl_matrix_char_view_vector+0x54>)
 8005c94:	480a      	ldr	r0, [pc, #40]	; (8005cc0 <gsl_matrix_char_view_vector+0x58>)
 8005c96:	2304      	movs	r3, #4
 8005c98:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005c9a:	f7fc fde1 	bl	8002860 <gsl_error>
 8005c9e:	2300      	movs	r3, #0
 8005ca0:	e9c4 3300 	strd	r3, r3, [r4]
 8005ca4:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005ca8:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005cac:	4620      	mov	r0, r4
 8005cae:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005cb0:	4902      	ldr	r1, [pc, #8]	; (8005cbc <gsl_matrix_char_view_vector+0x54>)
 8005cb2:	4804      	ldr	r0, [pc, #16]	; (8005cc4 <gsl_matrix_char_view_vector+0x5c>)
 8005cb4:	2304      	movs	r3, #4
 8005cb6:	2254      	movs	r2, #84	; 0x54
 8005cb8:	e7ef      	b.n	8005c9a <gsl_matrix_char_view_vector+0x32>
 8005cba:	bf00      	nop
 8005cbc:	080310b4 	.word	0x080310b4
 8005cc0:	080310ec 	.word	0x080310ec
 8005cc4:	0803110c 	.word	0x0803110c

08005cc8 <gsl_matrix_char_view_vector_with_tda>:
{
 8005cc8:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005cca:	684d      	ldr	r5, [r1, #4]
{
 8005ccc:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005cce:	2d01      	cmp	r5, #1
{
 8005cd0:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005cd2:	d111      	bne.n	8005cf8 <gsl_matrix_char_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005cd4:	42b3      	cmp	r3, r6
 8005cd6:	d823      	bhi.n	8005d20 <gsl_matrix_char_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005cd8:	6808      	ldr	r0, [r1, #0]
 8005cda:	fb02 f506 	mul.w	r5, r2, r6
 8005cde:	4285      	cmp	r5, r0
 8005ce0:	d819      	bhi.n	8005d16 <gsl_matrix_char_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005ce2:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005ce6:	6022      	str	r2, [r4, #0]
 8005ce8:	2200      	movs	r2, #0
 8005cea:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005cee:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005cf2:	6162      	str	r2, [r4, #20]
}
 8005cf4:	4620      	mov	r0, r4
 8005cf6:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005cf8:	490c      	ldr	r1, [pc, #48]	; (8005d2c <gsl_matrix_char_view_vector_with_tda+0x64>)
 8005cfa:	480d      	ldr	r0, [pc, #52]	; (8005d30 <gsl_matrix_char_view_vector_with_tda+0x68>)
 8005cfc:	2304      	movs	r3, #4
 8005cfe:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005d00:	f7fc fdae 	bl	8002860 <gsl_error>
 8005d04:	2300      	movs	r3, #0
 8005d06:	e9c4 3300 	strd	r3, r3, [r4]
 8005d0a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005d0e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005d12:	4620      	mov	r0, r4
 8005d14:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005d16:	4905      	ldr	r1, [pc, #20]	; (8005d2c <gsl_matrix_char_view_vector_with_tda+0x64>)
 8005d18:	4806      	ldr	r0, [pc, #24]	; (8005d34 <gsl_matrix_char_view_vector_with_tda+0x6c>)
 8005d1a:	2304      	movs	r3, #4
 8005d1c:	227c      	movs	r2, #124	; 0x7c
 8005d1e:	e7ef      	b.n	8005d00 <gsl_matrix_char_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005d20:	4902      	ldr	r1, [pc, #8]	; (8005d2c <gsl_matrix_char_view_vector_with_tda+0x64>)
 8005d22:	4805      	ldr	r0, [pc, #20]	; (8005d38 <gsl_matrix_char_view_vector_with_tda+0x70>)
 8005d24:	2304      	movs	r3, #4
 8005d26:	2277      	movs	r2, #119	; 0x77
 8005d28:	e7ea      	b.n	8005d00 <gsl_matrix_char_view_vector_with_tda+0x38>
 8005d2a:	bf00      	nop
 8005d2c:	080310b4 	.word	0x080310b4
 8005d30:	080310ec 	.word	0x080310ec
 8005d34:	0803110c 	.word	0x0803110c
 8005d38:	080310c4 	.word	0x080310c4

08005d3c <gsl_matrix_complex_long_double_const_view_array>:
{
 8005d3c:	b430      	push	{r4, r5}
    return view;
 8005d3e:	2500      	movs	r5, #0
 8005d40:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005d44:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005d48:	bc30      	pop	{r4, r5}
    return view;
 8005d4a:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005d4e:	4770      	bx	lr

08005d50 <gsl_matrix_complex_long_double_const_view_array_with_tda>:
{
 8005d50:	b538      	push	{r3, r4, r5, lr}
 8005d52:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005d54:	42ab      	cmp	r3, r5
{
 8005d56:	4604      	mov	r4, r0
  if (n2 > tda)
 8005d58:	d808      	bhi.n	8005d6c <gsl_matrix_complex_long_double_const_view_array_with_tda+0x1c>
    return view;
 8005d5a:	2000      	movs	r0, #0
 8005d5c:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005d60:	e9c4 2300 	strd	r2, r3, [r4]
 8005d64:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005d68:	4620      	mov	r0, r4
 8005d6a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005d6c:	4907      	ldr	r1, [pc, #28]	; (8005d8c <gsl_matrix_complex_long_double_const_view_array_with_tda+0x3c>)
 8005d6e:	4808      	ldr	r0, [pc, #32]	; (8005d90 <gsl_matrix_complex_long_double_const_view_array_with_tda+0x40>)
 8005d70:	2304      	movs	r3, #4
 8005d72:	2233      	movs	r2, #51	; 0x33
 8005d74:	f7fc fd74 	bl	8002860 <gsl_error>
 8005d78:	2300      	movs	r3, #0
 8005d7a:	e9c4 3300 	strd	r3, r3, [r4]
 8005d7e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005d82:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005d86:	4620      	mov	r0, r4
 8005d88:	bd38      	pop	{r3, r4, r5, pc}
 8005d8a:	bf00      	nop
 8005d8c:	080310b4 	.word	0x080310b4
 8005d90:	080310c4 	.word	0x080310c4

08005d94 <gsl_matrix_complex_long_double_const_view_vector>:
{
 8005d94:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005d96:	684d      	ldr	r5, [r1, #4]
 8005d98:	2d01      	cmp	r5, #1
{
 8005d9a:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005d9c:	d10f      	bne.n	8005dbe <gsl_matrix_complex_long_double_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005d9e:	6808      	ldr	r0, [r1, #0]
 8005da0:	fb03 f502 	mul.w	r5, r3, r2
 8005da4:	4285      	cmp	r5, r0
 8005da6:	d819      	bhi.n	8005ddc <gsl_matrix_complex_long_double_const_view_vector+0x48>
    m.block = v->block;
 8005da8:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005dac:	6022      	str	r2, [r4, #0]
 8005dae:	2200      	movs	r2, #0
 8005db0:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005db4:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005db8:	6162      	str	r2, [r4, #20]
}
 8005dba:	4620      	mov	r0, r4
 8005dbc:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005dbe:	490a      	ldr	r1, [pc, #40]	; (8005de8 <gsl_matrix_complex_long_double_const_view_vector+0x54>)
 8005dc0:	480a      	ldr	r0, [pc, #40]	; (8005dec <gsl_matrix_complex_long_double_const_view_vector+0x58>)
 8005dc2:	2304      	movs	r3, #4
 8005dc4:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005dc6:	f7fc fd4b 	bl	8002860 <gsl_error>
 8005dca:	2300      	movs	r3, #0
 8005dcc:	e9c4 3300 	strd	r3, r3, [r4]
 8005dd0:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005dd4:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005dd8:	4620      	mov	r0, r4
 8005dda:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005ddc:	4902      	ldr	r1, [pc, #8]	; (8005de8 <gsl_matrix_complex_long_double_const_view_vector+0x54>)
 8005dde:	4804      	ldr	r0, [pc, #16]	; (8005df0 <gsl_matrix_complex_long_double_const_view_vector+0x5c>)
 8005de0:	2304      	movs	r3, #4
 8005de2:	2254      	movs	r2, #84	; 0x54
 8005de4:	e7ef      	b.n	8005dc6 <gsl_matrix_complex_long_double_const_view_vector+0x32>
 8005de6:	bf00      	nop
 8005de8:	080310b4 	.word	0x080310b4
 8005dec:	080310ec 	.word	0x080310ec
 8005df0:	0803110c 	.word	0x0803110c

08005df4 <gsl_matrix_complex_long_double_const_view_vector_with_tda>:
{
 8005df4:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005df6:	684d      	ldr	r5, [r1, #4]
{
 8005df8:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005dfa:	2d01      	cmp	r5, #1
{
 8005dfc:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005dfe:	d111      	bne.n	8005e24 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005e00:	42b3      	cmp	r3, r6
 8005e02:	d823      	bhi.n	8005e4c <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005e04:	6808      	ldr	r0, [r1, #0]
 8005e06:	fb02 f506 	mul.w	r5, r2, r6
 8005e0a:	4285      	cmp	r5, r0
 8005e0c:	d819      	bhi.n	8005e42 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005e0e:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005e12:	6022      	str	r2, [r4, #0]
 8005e14:	2200      	movs	r2, #0
 8005e16:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005e1a:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005e1e:	6162      	str	r2, [r4, #20]
}
 8005e20:	4620      	mov	r0, r4
 8005e22:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005e24:	490c      	ldr	r1, [pc, #48]	; (8005e58 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x64>)
 8005e26:	480d      	ldr	r0, [pc, #52]	; (8005e5c <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x68>)
 8005e28:	2304      	movs	r3, #4
 8005e2a:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005e2c:	f7fc fd18 	bl	8002860 <gsl_error>
 8005e30:	2300      	movs	r3, #0
 8005e32:	e9c4 3300 	strd	r3, r3, [r4]
 8005e36:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005e3a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005e3e:	4620      	mov	r0, r4
 8005e40:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005e42:	4905      	ldr	r1, [pc, #20]	; (8005e58 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x64>)
 8005e44:	4806      	ldr	r0, [pc, #24]	; (8005e60 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x6c>)
 8005e46:	2304      	movs	r3, #4
 8005e48:	227c      	movs	r2, #124	; 0x7c
 8005e4a:	e7ef      	b.n	8005e2c <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005e4c:	4902      	ldr	r1, [pc, #8]	; (8005e58 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x64>)
 8005e4e:	4805      	ldr	r0, [pc, #20]	; (8005e64 <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x70>)
 8005e50:	2304      	movs	r3, #4
 8005e52:	2277      	movs	r2, #119	; 0x77
 8005e54:	e7ea      	b.n	8005e2c <gsl_matrix_complex_long_double_const_view_vector_with_tda+0x38>
 8005e56:	bf00      	nop
 8005e58:	080310b4 	.word	0x080310b4
 8005e5c:	080310ec 	.word	0x080310ec
 8005e60:	0803110c 	.word	0x0803110c
 8005e64:	080310c4 	.word	0x080310c4

08005e68 <gsl_matrix_complex_const_view_array>:
{
 8005e68:	b430      	push	{r4, r5}
    return view;
 8005e6a:	2500      	movs	r5, #0
 8005e6c:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005e70:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005e74:	bc30      	pop	{r4, r5}
    return view;
 8005e76:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005e7a:	4770      	bx	lr

08005e7c <gsl_matrix_complex_const_view_array_with_tda>:
{
 8005e7c:	b538      	push	{r3, r4, r5, lr}
 8005e7e:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005e80:	42ab      	cmp	r3, r5
{
 8005e82:	4604      	mov	r4, r0
  if (n2 > tda)
 8005e84:	d808      	bhi.n	8005e98 <gsl_matrix_complex_const_view_array_with_tda+0x1c>
    return view;
 8005e86:	2000      	movs	r0, #0
 8005e88:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005e8c:	e9c4 2300 	strd	r2, r3, [r4]
 8005e90:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005e94:	4620      	mov	r0, r4
 8005e96:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005e98:	4907      	ldr	r1, [pc, #28]	; (8005eb8 <gsl_matrix_complex_const_view_array_with_tda+0x3c>)
 8005e9a:	4808      	ldr	r0, [pc, #32]	; (8005ebc <gsl_matrix_complex_const_view_array_with_tda+0x40>)
 8005e9c:	2304      	movs	r3, #4
 8005e9e:	2233      	movs	r2, #51	; 0x33
 8005ea0:	f7fc fcde 	bl	8002860 <gsl_error>
 8005ea4:	2300      	movs	r3, #0
 8005ea6:	e9c4 3300 	strd	r3, r3, [r4]
 8005eaa:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005eae:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005eb2:	4620      	mov	r0, r4
 8005eb4:	bd38      	pop	{r3, r4, r5, pc}
 8005eb6:	bf00      	nop
 8005eb8:	080310b4 	.word	0x080310b4
 8005ebc:	080310c4 	.word	0x080310c4

08005ec0 <gsl_matrix_complex_const_view_vector>:
{
 8005ec0:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005ec2:	684d      	ldr	r5, [r1, #4]
 8005ec4:	2d01      	cmp	r5, #1
{
 8005ec6:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005ec8:	d10f      	bne.n	8005eea <gsl_matrix_complex_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005eca:	6808      	ldr	r0, [r1, #0]
 8005ecc:	fb03 f502 	mul.w	r5, r3, r2
 8005ed0:	4285      	cmp	r5, r0
 8005ed2:	d819      	bhi.n	8005f08 <gsl_matrix_complex_const_view_vector+0x48>
    m.block = v->block;
 8005ed4:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005ed8:	6022      	str	r2, [r4, #0]
 8005eda:	2200      	movs	r2, #0
 8005edc:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005ee0:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8005ee4:	6162      	str	r2, [r4, #20]
}
 8005ee6:	4620      	mov	r0, r4
 8005ee8:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005eea:	490a      	ldr	r1, [pc, #40]	; (8005f14 <gsl_matrix_complex_const_view_vector+0x54>)
 8005eec:	480a      	ldr	r0, [pc, #40]	; (8005f18 <gsl_matrix_complex_const_view_vector+0x58>)
 8005eee:	2304      	movs	r3, #4
 8005ef0:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005ef2:	f7fc fcb5 	bl	8002860 <gsl_error>
 8005ef6:	2300      	movs	r3, #0
 8005ef8:	e9c4 3300 	strd	r3, r3, [r4]
 8005efc:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005f00:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005f04:	4620      	mov	r0, r4
 8005f06:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005f08:	4902      	ldr	r1, [pc, #8]	; (8005f14 <gsl_matrix_complex_const_view_vector+0x54>)
 8005f0a:	4804      	ldr	r0, [pc, #16]	; (8005f1c <gsl_matrix_complex_const_view_vector+0x5c>)
 8005f0c:	2304      	movs	r3, #4
 8005f0e:	2254      	movs	r2, #84	; 0x54
 8005f10:	e7ef      	b.n	8005ef2 <gsl_matrix_complex_const_view_vector+0x32>
 8005f12:	bf00      	nop
 8005f14:	080310b4 	.word	0x080310b4
 8005f18:	080310ec 	.word	0x080310ec
 8005f1c:	0803110c 	.word	0x0803110c

08005f20 <gsl_matrix_complex_const_view_vector_with_tda>:
{
 8005f20:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8005f22:	684d      	ldr	r5, [r1, #4]
{
 8005f24:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8005f26:	2d01      	cmp	r5, #1
{
 8005f28:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005f2a:	d111      	bne.n	8005f50 <gsl_matrix_complex_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8005f2c:	42b3      	cmp	r3, r6
 8005f2e:	d823      	bhi.n	8005f78 <gsl_matrix_complex_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8005f30:	6808      	ldr	r0, [r1, #0]
 8005f32:	fb02 f506 	mul.w	r5, r2, r6
 8005f36:	4285      	cmp	r5, r0
 8005f38:	d819      	bhi.n	8005f6e <gsl_matrix_complex_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8005f3a:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8005f3e:	6022      	str	r2, [r4, #0]
 8005f40:	2200      	movs	r2, #0
 8005f42:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8005f46:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8005f4a:	6162      	str	r2, [r4, #20]
}
 8005f4c:	4620      	mov	r0, r4
 8005f4e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8005f50:	490c      	ldr	r1, [pc, #48]	; (8005f84 <gsl_matrix_complex_const_view_vector_with_tda+0x64>)
 8005f52:	480d      	ldr	r0, [pc, #52]	; (8005f88 <gsl_matrix_complex_const_view_vector_with_tda+0x68>)
 8005f54:	2304      	movs	r3, #4
 8005f56:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005f58:	f7fc fc82 	bl	8002860 <gsl_error>
 8005f5c:	2300      	movs	r3, #0
 8005f5e:	e9c4 3300 	strd	r3, r3, [r4]
 8005f62:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005f66:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005f6a:	4620      	mov	r0, r4
 8005f6c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8005f6e:	4905      	ldr	r1, [pc, #20]	; (8005f84 <gsl_matrix_complex_const_view_vector_with_tda+0x64>)
 8005f70:	4806      	ldr	r0, [pc, #24]	; (8005f8c <gsl_matrix_complex_const_view_vector_with_tda+0x6c>)
 8005f72:	2304      	movs	r3, #4
 8005f74:	227c      	movs	r2, #124	; 0x7c
 8005f76:	e7ef      	b.n	8005f58 <gsl_matrix_complex_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005f78:	4902      	ldr	r1, [pc, #8]	; (8005f84 <gsl_matrix_complex_const_view_vector_with_tda+0x64>)
 8005f7a:	4805      	ldr	r0, [pc, #20]	; (8005f90 <gsl_matrix_complex_const_view_vector_with_tda+0x70>)
 8005f7c:	2304      	movs	r3, #4
 8005f7e:	2277      	movs	r2, #119	; 0x77
 8005f80:	e7ea      	b.n	8005f58 <gsl_matrix_complex_const_view_vector_with_tda+0x38>
 8005f82:	bf00      	nop
 8005f84:	080310b4 	.word	0x080310b4
 8005f88:	080310ec 	.word	0x080310ec
 8005f8c:	0803110c 	.word	0x0803110c
 8005f90:	080310c4 	.word	0x080310c4

08005f94 <gsl_matrix_complex_float_const_view_array>:
{
 8005f94:	b430      	push	{r4, r5}
    return view;
 8005f96:	2500      	movs	r5, #0
 8005f98:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8005f9c:	e9c0 2300 	strd	r2, r3, [r0]
}
 8005fa0:	bc30      	pop	{r4, r5}
    return view;
 8005fa2:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8005fa6:	4770      	bx	lr

08005fa8 <gsl_matrix_complex_float_const_view_array_with_tda>:
{
 8005fa8:	b538      	push	{r3, r4, r5, lr}
 8005faa:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8005fac:	42ab      	cmp	r3, r5
{
 8005fae:	4604      	mov	r4, r0
  if (n2 > tda)
 8005fb0:	d808      	bhi.n	8005fc4 <gsl_matrix_complex_float_const_view_array_with_tda+0x1c>
    return view;
 8005fb2:	2000      	movs	r0, #0
 8005fb4:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8005fb8:	e9c4 2300 	strd	r2, r3, [r4]
 8005fbc:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8005fc0:	4620      	mov	r0, r4
 8005fc2:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8005fc4:	4907      	ldr	r1, [pc, #28]	; (8005fe4 <gsl_matrix_complex_float_const_view_array_with_tda+0x3c>)
 8005fc6:	4808      	ldr	r0, [pc, #32]	; (8005fe8 <gsl_matrix_complex_float_const_view_array_with_tda+0x40>)
 8005fc8:	2304      	movs	r3, #4
 8005fca:	2233      	movs	r2, #51	; 0x33
 8005fcc:	f7fc fc48 	bl	8002860 <gsl_error>
 8005fd0:	2300      	movs	r3, #0
 8005fd2:	e9c4 3300 	strd	r3, r3, [r4]
 8005fd6:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8005fda:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8005fde:	4620      	mov	r0, r4
 8005fe0:	bd38      	pop	{r3, r4, r5, pc}
 8005fe2:	bf00      	nop
 8005fe4:	080310b4 	.word	0x080310b4
 8005fe8:	080310c4 	.word	0x080310c4

08005fec <gsl_matrix_complex_float_const_view_vector>:
{
 8005fec:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8005fee:	684d      	ldr	r5, [r1, #4]
 8005ff0:	2d01      	cmp	r5, #1
{
 8005ff2:	4604      	mov	r4, r0
  if (v->stride != 1)
 8005ff4:	d10f      	bne.n	8006016 <gsl_matrix_complex_float_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8005ff6:	6808      	ldr	r0, [r1, #0]
 8005ff8:	fb03 f502 	mul.w	r5, r3, r2
 8005ffc:	4285      	cmp	r5, r0
 8005ffe:	d819      	bhi.n	8006034 <gsl_matrix_complex_float_const_view_vector+0x48>
    m.block = v->block;
 8006000:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006004:	6022      	str	r2, [r4, #0]
 8006006:	2200      	movs	r2, #0
 8006008:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800600c:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006010:	6162      	str	r2, [r4, #20]
}
 8006012:	4620      	mov	r0, r4
 8006014:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006016:	490a      	ldr	r1, [pc, #40]	; (8006040 <gsl_matrix_complex_float_const_view_vector+0x54>)
 8006018:	480a      	ldr	r0, [pc, #40]	; (8006044 <gsl_matrix_complex_float_const_view_vector+0x58>)
 800601a:	2304      	movs	r3, #4
 800601c:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800601e:	f7fc fc1f 	bl	8002860 <gsl_error>
 8006022:	2300      	movs	r3, #0
 8006024:	e9c4 3300 	strd	r3, r3, [r4]
 8006028:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800602c:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006030:	4620      	mov	r0, r4
 8006032:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006034:	4902      	ldr	r1, [pc, #8]	; (8006040 <gsl_matrix_complex_float_const_view_vector+0x54>)
 8006036:	4804      	ldr	r0, [pc, #16]	; (8006048 <gsl_matrix_complex_float_const_view_vector+0x5c>)
 8006038:	2304      	movs	r3, #4
 800603a:	2254      	movs	r2, #84	; 0x54
 800603c:	e7ef      	b.n	800601e <gsl_matrix_complex_float_const_view_vector+0x32>
 800603e:	bf00      	nop
 8006040:	080310b4 	.word	0x080310b4
 8006044:	080310ec 	.word	0x080310ec
 8006048:	0803110c 	.word	0x0803110c

0800604c <gsl_matrix_complex_float_const_view_vector_with_tda>:
{
 800604c:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 800604e:	684d      	ldr	r5, [r1, #4]
{
 8006050:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8006052:	2d01      	cmp	r5, #1
{
 8006054:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006056:	d111      	bne.n	800607c <gsl_matrix_complex_float_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006058:	42b3      	cmp	r3, r6
 800605a:	d823      	bhi.n	80060a4 <gsl_matrix_complex_float_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 800605c:	6808      	ldr	r0, [r1, #0]
 800605e:	fb02 f506 	mul.w	r5, r2, r6
 8006062:	4285      	cmp	r5, r0
 8006064:	d819      	bhi.n	800609a <gsl_matrix_complex_float_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006066:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800606a:	6022      	str	r2, [r4, #0]
 800606c:	2200      	movs	r2, #0
 800606e:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006072:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8006076:	6162      	str	r2, [r4, #20]
}
 8006078:	4620      	mov	r0, r4
 800607a:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800607c:	490c      	ldr	r1, [pc, #48]	; (80060b0 <gsl_matrix_complex_float_const_view_vector_with_tda+0x64>)
 800607e:	480d      	ldr	r0, [pc, #52]	; (80060b4 <gsl_matrix_complex_float_const_view_vector_with_tda+0x68>)
 8006080:	2304      	movs	r3, #4
 8006082:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006084:	f7fc fbec 	bl	8002860 <gsl_error>
 8006088:	2300      	movs	r3, #0
 800608a:	e9c4 3300 	strd	r3, r3, [r4]
 800608e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006092:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006096:	4620      	mov	r0, r4
 8006098:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800609a:	4905      	ldr	r1, [pc, #20]	; (80060b0 <gsl_matrix_complex_float_const_view_vector_with_tda+0x64>)
 800609c:	4806      	ldr	r0, [pc, #24]	; (80060b8 <gsl_matrix_complex_float_const_view_vector_with_tda+0x6c>)
 800609e:	2304      	movs	r3, #4
 80060a0:	227c      	movs	r2, #124	; 0x7c
 80060a2:	e7ef      	b.n	8006084 <gsl_matrix_complex_float_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80060a4:	4902      	ldr	r1, [pc, #8]	; (80060b0 <gsl_matrix_complex_float_const_view_vector_with_tda+0x64>)
 80060a6:	4805      	ldr	r0, [pc, #20]	; (80060bc <gsl_matrix_complex_float_const_view_vector_with_tda+0x70>)
 80060a8:	2304      	movs	r3, #4
 80060aa:	2277      	movs	r2, #119	; 0x77
 80060ac:	e7ea      	b.n	8006084 <gsl_matrix_complex_float_const_view_vector_with_tda+0x38>
 80060ae:	bf00      	nop
 80060b0:	080310b4 	.word	0x080310b4
 80060b4:	080310ec 	.word	0x080310ec
 80060b8:	0803110c 	.word	0x0803110c
 80060bc:	080310c4 	.word	0x080310c4

080060c0 <gsl_matrix_long_double_const_view_array>:
{
 80060c0:	b430      	push	{r4, r5}
    return view;
 80060c2:	2500      	movs	r5, #0
 80060c4:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80060c8:	e9c0 2300 	strd	r2, r3, [r0]
}
 80060cc:	bc30      	pop	{r4, r5}
    return view;
 80060ce:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80060d2:	4770      	bx	lr

080060d4 <gsl_matrix_long_double_const_view_array_with_tda>:
{
 80060d4:	b538      	push	{r3, r4, r5, lr}
 80060d6:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80060d8:	42ab      	cmp	r3, r5
{
 80060da:	4604      	mov	r4, r0
  if (n2 > tda)
 80060dc:	d808      	bhi.n	80060f0 <gsl_matrix_long_double_const_view_array_with_tda+0x1c>
    return view;
 80060de:	2000      	movs	r0, #0
 80060e0:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80060e4:	e9c4 2300 	strd	r2, r3, [r4]
 80060e8:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80060ec:	4620      	mov	r0, r4
 80060ee:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80060f0:	4907      	ldr	r1, [pc, #28]	; (8006110 <gsl_matrix_long_double_const_view_array_with_tda+0x3c>)
 80060f2:	4808      	ldr	r0, [pc, #32]	; (8006114 <gsl_matrix_long_double_const_view_array_with_tda+0x40>)
 80060f4:	2304      	movs	r3, #4
 80060f6:	2233      	movs	r2, #51	; 0x33
 80060f8:	f7fc fbb2 	bl	8002860 <gsl_error>
 80060fc:	2300      	movs	r3, #0
 80060fe:	e9c4 3300 	strd	r3, r3, [r4]
 8006102:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006106:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800610a:	4620      	mov	r0, r4
 800610c:	bd38      	pop	{r3, r4, r5, pc}
 800610e:	bf00      	nop
 8006110:	080310b4 	.word	0x080310b4
 8006114:	080310c4 	.word	0x080310c4

08006118 <gsl_matrix_long_double_const_view_vector>:
{
 8006118:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 800611a:	684d      	ldr	r5, [r1, #4]
 800611c:	2d01      	cmp	r5, #1
{
 800611e:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006120:	d10f      	bne.n	8006142 <gsl_matrix_long_double_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8006122:	6808      	ldr	r0, [r1, #0]
 8006124:	fb03 f502 	mul.w	r5, r3, r2
 8006128:	4285      	cmp	r5, r0
 800612a:	d819      	bhi.n	8006160 <gsl_matrix_long_double_const_view_vector+0x48>
    m.block = v->block;
 800612c:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006130:	6022      	str	r2, [r4, #0]
 8006132:	2200      	movs	r2, #0
 8006134:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006138:	e9c4 3301 	strd	r3, r3, [r4, #4]
 800613c:	6162      	str	r2, [r4, #20]
}
 800613e:	4620      	mov	r0, r4
 8006140:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006142:	490a      	ldr	r1, [pc, #40]	; (800616c <gsl_matrix_long_double_const_view_vector+0x54>)
 8006144:	480a      	ldr	r0, [pc, #40]	; (8006170 <gsl_matrix_long_double_const_view_vector+0x58>)
 8006146:	2304      	movs	r3, #4
 8006148:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800614a:	f7fc fb89 	bl	8002860 <gsl_error>
 800614e:	2300      	movs	r3, #0
 8006150:	e9c4 3300 	strd	r3, r3, [r4]
 8006154:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006158:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800615c:	4620      	mov	r0, r4
 800615e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006160:	4902      	ldr	r1, [pc, #8]	; (800616c <gsl_matrix_long_double_const_view_vector+0x54>)
 8006162:	4804      	ldr	r0, [pc, #16]	; (8006174 <gsl_matrix_long_double_const_view_vector+0x5c>)
 8006164:	2304      	movs	r3, #4
 8006166:	2254      	movs	r2, #84	; 0x54
 8006168:	e7ef      	b.n	800614a <gsl_matrix_long_double_const_view_vector+0x32>
 800616a:	bf00      	nop
 800616c:	080310b4 	.word	0x080310b4
 8006170:	080310ec 	.word	0x080310ec
 8006174:	0803110c 	.word	0x0803110c

08006178 <gsl_matrix_long_double_const_view_vector_with_tda>:
{
 8006178:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 800617a:	684d      	ldr	r5, [r1, #4]
{
 800617c:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800617e:	2d01      	cmp	r5, #1
{
 8006180:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006182:	d111      	bne.n	80061a8 <gsl_matrix_long_double_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006184:	42b3      	cmp	r3, r6
 8006186:	d823      	bhi.n	80061d0 <gsl_matrix_long_double_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006188:	6808      	ldr	r0, [r1, #0]
 800618a:	fb02 f506 	mul.w	r5, r2, r6
 800618e:	4285      	cmp	r5, r0
 8006190:	d819      	bhi.n	80061c6 <gsl_matrix_long_double_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006192:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006196:	6022      	str	r2, [r4, #0]
 8006198:	2200      	movs	r2, #0
 800619a:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800619e:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80061a2:	6162      	str	r2, [r4, #20]
}
 80061a4:	4620      	mov	r0, r4
 80061a6:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80061a8:	490c      	ldr	r1, [pc, #48]	; (80061dc <gsl_matrix_long_double_const_view_vector_with_tda+0x64>)
 80061aa:	480d      	ldr	r0, [pc, #52]	; (80061e0 <gsl_matrix_long_double_const_view_vector_with_tda+0x68>)
 80061ac:	2304      	movs	r3, #4
 80061ae:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80061b0:	f7fc fb56 	bl	8002860 <gsl_error>
 80061b4:	2300      	movs	r3, #0
 80061b6:	e9c4 3300 	strd	r3, r3, [r4]
 80061ba:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80061be:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80061c2:	4620      	mov	r0, r4
 80061c4:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80061c6:	4905      	ldr	r1, [pc, #20]	; (80061dc <gsl_matrix_long_double_const_view_vector_with_tda+0x64>)
 80061c8:	4806      	ldr	r0, [pc, #24]	; (80061e4 <gsl_matrix_long_double_const_view_vector_with_tda+0x6c>)
 80061ca:	2304      	movs	r3, #4
 80061cc:	227c      	movs	r2, #124	; 0x7c
 80061ce:	e7ef      	b.n	80061b0 <gsl_matrix_long_double_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80061d0:	4902      	ldr	r1, [pc, #8]	; (80061dc <gsl_matrix_long_double_const_view_vector_with_tda+0x64>)
 80061d2:	4805      	ldr	r0, [pc, #20]	; (80061e8 <gsl_matrix_long_double_const_view_vector_with_tda+0x70>)
 80061d4:	2304      	movs	r3, #4
 80061d6:	2277      	movs	r2, #119	; 0x77
 80061d8:	e7ea      	b.n	80061b0 <gsl_matrix_long_double_const_view_vector_with_tda+0x38>
 80061da:	bf00      	nop
 80061dc:	080310b4 	.word	0x080310b4
 80061e0:	080310ec 	.word	0x080310ec
 80061e4:	0803110c 	.word	0x0803110c
 80061e8:	080310c4 	.word	0x080310c4

080061ec <gsl_matrix_const_view_array>:
{
 80061ec:	b430      	push	{r4, r5}
    return view;
 80061ee:	2500      	movs	r5, #0
 80061f0:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80061f4:	e9c0 2300 	strd	r2, r3, [r0]
}
 80061f8:	bc30      	pop	{r4, r5}
    return view;
 80061fa:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80061fe:	4770      	bx	lr

08006200 <gsl_matrix_const_view_array_with_tda>:
{
 8006200:	b538      	push	{r3, r4, r5, lr}
 8006202:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8006204:	42ab      	cmp	r3, r5
{
 8006206:	4604      	mov	r4, r0
  if (n2 > tda)
 8006208:	d808      	bhi.n	800621c <gsl_matrix_const_view_array_with_tda+0x1c>
    return view;
 800620a:	2000      	movs	r0, #0
 800620c:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006210:	e9c4 2300 	strd	r2, r3, [r4]
 8006214:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006218:	4620      	mov	r0, r4
 800621a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 800621c:	4907      	ldr	r1, [pc, #28]	; (800623c <gsl_matrix_const_view_array_with_tda+0x3c>)
 800621e:	4808      	ldr	r0, [pc, #32]	; (8006240 <gsl_matrix_const_view_array_with_tda+0x40>)
 8006220:	2304      	movs	r3, #4
 8006222:	2233      	movs	r2, #51	; 0x33
 8006224:	f7fc fb1c 	bl	8002860 <gsl_error>
 8006228:	2300      	movs	r3, #0
 800622a:	e9c4 3300 	strd	r3, r3, [r4]
 800622e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006232:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006236:	4620      	mov	r0, r4
 8006238:	bd38      	pop	{r3, r4, r5, pc}
 800623a:	bf00      	nop
 800623c:	080310b4 	.word	0x080310b4
 8006240:	080310c4 	.word	0x080310c4

08006244 <gsl_matrix_const_view_vector>:
{
 8006244:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8006246:	684d      	ldr	r5, [r1, #4]
 8006248:	2d01      	cmp	r5, #1
{
 800624a:	4604      	mov	r4, r0
  if (v->stride != 1)
 800624c:	d10f      	bne.n	800626e <gsl_matrix_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 800624e:	6808      	ldr	r0, [r1, #0]
 8006250:	fb03 f502 	mul.w	r5, r3, r2
 8006254:	4285      	cmp	r5, r0
 8006256:	d819      	bhi.n	800628c <gsl_matrix_const_view_vector+0x48>
    m.block = v->block;
 8006258:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800625c:	6022      	str	r2, [r4, #0]
 800625e:	2200      	movs	r2, #0
 8006260:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006264:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006268:	6162      	str	r2, [r4, #20]
}
 800626a:	4620      	mov	r0, r4
 800626c:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800626e:	490a      	ldr	r1, [pc, #40]	; (8006298 <gsl_matrix_const_view_vector+0x54>)
 8006270:	480a      	ldr	r0, [pc, #40]	; (800629c <gsl_matrix_const_view_vector+0x58>)
 8006272:	2304      	movs	r3, #4
 8006274:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006276:	f7fc faf3 	bl	8002860 <gsl_error>
 800627a:	2300      	movs	r3, #0
 800627c:	e9c4 3300 	strd	r3, r3, [r4]
 8006280:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006284:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006288:	4620      	mov	r0, r4
 800628a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800628c:	4902      	ldr	r1, [pc, #8]	; (8006298 <gsl_matrix_const_view_vector+0x54>)
 800628e:	4804      	ldr	r0, [pc, #16]	; (80062a0 <gsl_matrix_const_view_vector+0x5c>)
 8006290:	2304      	movs	r3, #4
 8006292:	2254      	movs	r2, #84	; 0x54
 8006294:	e7ef      	b.n	8006276 <gsl_matrix_const_view_vector+0x32>
 8006296:	bf00      	nop
 8006298:	080310b4 	.word	0x080310b4
 800629c:	080310ec 	.word	0x080310ec
 80062a0:	0803110c 	.word	0x0803110c

080062a4 <gsl_matrix_const_view_vector_with_tda>:
{
 80062a4:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 80062a6:	684d      	ldr	r5, [r1, #4]
{
 80062a8:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 80062aa:	2d01      	cmp	r5, #1
{
 80062ac:	4604      	mov	r4, r0
  if (v->stride != 1)
 80062ae:	d111      	bne.n	80062d4 <gsl_matrix_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 80062b0:	42b3      	cmp	r3, r6
 80062b2:	d823      	bhi.n	80062fc <gsl_matrix_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 80062b4:	6808      	ldr	r0, [r1, #0]
 80062b6:	fb02 f506 	mul.w	r5, r2, r6
 80062ba:	4285      	cmp	r5, r0
 80062bc:	d819      	bhi.n	80062f2 <gsl_matrix_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 80062be:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80062c2:	6022      	str	r2, [r4, #0]
 80062c4:	2200      	movs	r2, #0
 80062c6:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80062ca:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80062ce:	6162      	str	r2, [r4, #20]
}
 80062d0:	4620      	mov	r0, r4
 80062d2:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80062d4:	490c      	ldr	r1, [pc, #48]	; (8006308 <gsl_matrix_const_view_vector_with_tda+0x64>)
 80062d6:	480d      	ldr	r0, [pc, #52]	; (800630c <gsl_matrix_const_view_vector_with_tda+0x68>)
 80062d8:	2304      	movs	r3, #4
 80062da:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80062dc:	f7fc fac0 	bl	8002860 <gsl_error>
 80062e0:	2300      	movs	r3, #0
 80062e2:	e9c4 3300 	strd	r3, r3, [r4]
 80062e6:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80062ea:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80062ee:	4620      	mov	r0, r4
 80062f0:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80062f2:	4905      	ldr	r1, [pc, #20]	; (8006308 <gsl_matrix_const_view_vector_with_tda+0x64>)
 80062f4:	4806      	ldr	r0, [pc, #24]	; (8006310 <gsl_matrix_const_view_vector_with_tda+0x6c>)
 80062f6:	2304      	movs	r3, #4
 80062f8:	227c      	movs	r2, #124	; 0x7c
 80062fa:	e7ef      	b.n	80062dc <gsl_matrix_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80062fc:	4902      	ldr	r1, [pc, #8]	; (8006308 <gsl_matrix_const_view_vector_with_tda+0x64>)
 80062fe:	4805      	ldr	r0, [pc, #20]	; (8006314 <gsl_matrix_const_view_vector_with_tda+0x70>)
 8006300:	2304      	movs	r3, #4
 8006302:	2277      	movs	r2, #119	; 0x77
 8006304:	e7ea      	b.n	80062dc <gsl_matrix_const_view_vector_with_tda+0x38>
 8006306:	bf00      	nop
 8006308:	080310b4 	.word	0x080310b4
 800630c:	080310ec 	.word	0x080310ec
 8006310:	0803110c 	.word	0x0803110c
 8006314:	080310c4 	.word	0x080310c4

08006318 <gsl_matrix_float_const_view_array>:
{
 8006318:	b430      	push	{r4, r5}
    return view;
 800631a:	2500      	movs	r5, #0
 800631c:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8006320:	e9c0 2300 	strd	r2, r3, [r0]
}
 8006324:	bc30      	pop	{r4, r5}
    return view;
 8006326:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 800632a:	4770      	bx	lr

0800632c <gsl_matrix_float_const_view_array_with_tda>:
{
 800632c:	b538      	push	{r3, r4, r5, lr}
 800632e:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8006330:	42ab      	cmp	r3, r5
{
 8006332:	4604      	mov	r4, r0
  if (n2 > tda)
 8006334:	d808      	bhi.n	8006348 <gsl_matrix_float_const_view_array_with_tda+0x1c>
    return view;
 8006336:	2000      	movs	r0, #0
 8006338:	e9c4 0004 	strd	r0, r0, [r4, #16]
 800633c:	e9c4 2300 	strd	r2, r3, [r4]
 8006340:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006344:	4620      	mov	r0, r4
 8006346:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006348:	4907      	ldr	r1, [pc, #28]	; (8006368 <gsl_matrix_float_const_view_array_with_tda+0x3c>)
 800634a:	4808      	ldr	r0, [pc, #32]	; (800636c <gsl_matrix_float_const_view_array_with_tda+0x40>)
 800634c:	2304      	movs	r3, #4
 800634e:	2233      	movs	r2, #51	; 0x33
 8006350:	f7fc fa86 	bl	8002860 <gsl_error>
 8006354:	2300      	movs	r3, #0
 8006356:	e9c4 3300 	strd	r3, r3, [r4]
 800635a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800635e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006362:	4620      	mov	r0, r4
 8006364:	bd38      	pop	{r3, r4, r5, pc}
 8006366:	bf00      	nop
 8006368:	080310b4 	.word	0x080310b4
 800636c:	080310c4 	.word	0x080310c4

08006370 <gsl_matrix_float_const_view_vector>:
{
 8006370:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8006372:	684d      	ldr	r5, [r1, #4]
 8006374:	2d01      	cmp	r5, #1
{
 8006376:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006378:	d10f      	bne.n	800639a <gsl_matrix_float_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 800637a:	6808      	ldr	r0, [r1, #0]
 800637c:	fb03 f502 	mul.w	r5, r3, r2
 8006380:	4285      	cmp	r5, r0
 8006382:	d819      	bhi.n	80063b8 <gsl_matrix_float_const_view_vector+0x48>
    m.block = v->block;
 8006384:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006388:	6022      	str	r2, [r4, #0]
 800638a:	2200      	movs	r2, #0
 800638c:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006390:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006394:	6162      	str	r2, [r4, #20]
}
 8006396:	4620      	mov	r0, r4
 8006398:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800639a:	490a      	ldr	r1, [pc, #40]	; (80063c4 <gsl_matrix_float_const_view_vector+0x54>)
 800639c:	480a      	ldr	r0, [pc, #40]	; (80063c8 <gsl_matrix_float_const_view_vector+0x58>)
 800639e:	2304      	movs	r3, #4
 80063a0:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80063a2:	f7fc fa5d 	bl	8002860 <gsl_error>
 80063a6:	2300      	movs	r3, #0
 80063a8:	e9c4 3300 	strd	r3, r3, [r4]
 80063ac:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80063b0:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80063b4:	4620      	mov	r0, r4
 80063b6:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80063b8:	4902      	ldr	r1, [pc, #8]	; (80063c4 <gsl_matrix_float_const_view_vector+0x54>)
 80063ba:	4804      	ldr	r0, [pc, #16]	; (80063cc <gsl_matrix_float_const_view_vector+0x5c>)
 80063bc:	2304      	movs	r3, #4
 80063be:	2254      	movs	r2, #84	; 0x54
 80063c0:	e7ef      	b.n	80063a2 <gsl_matrix_float_const_view_vector+0x32>
 80063c2:	bf00      	nop
 80063c4:	080310b4 	.word	0x080310b4
 80063c8:	080310ec 	.word	0x080310ec
 80063cc:	0803110c 	.word	0x0803110c

080063d0 <gsl_matrix_float_const_view_vector_with_tda>:
{
 80063d0:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 80063d2:	684d      	ldr	r5, [r1, #4]
{
 80063d4:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 80063d6:	2d01      	cmp	r5, #1
{
 80063d8:	4604      	mov	r4, r0
  if (v->stride != 1)
 80063da:	d111      	bne.n	8006400 <gsl_matrix_float_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 80063dc:	42b3      	cmp	r3, r6
 80063de:	d823      	bhi.n	8006428 <gsl_matrix_float_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 80063e0:	6808      	ldr	r0, [r1, #0]
 80063e2:	fb02 f506 	mul.w	r5, r2, r6
 80063e6:	4285      	cmp	r5, r0
 80063e8:	d819      	bhi.n	800641e <gsl_matrix_float_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 80063ea:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80063ee:	6022      	str	r2, [r4, #0]
 80063f0:	2200      	movs	r2, #0
 80063f2:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80063f6:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80063fa:	6162      	str	r2, [r4, #20]
}
 80063fc:	4620      	mov	r0, r4
 80063fe:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006400:	490c      	ldr	r1, [pc, #48]	; (8006434 <gsl_matrix_float_const_view_vector_with_tda+0x64>)
 8006402:	480d      	ldr	r0, [pc, #52]	; (8006438 <gsl_matrix_float_const_view_vector_with_tda+0x68>)
 8006404:	2304      	movs	r3, #4
 8006406:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006408:	f7fc fa2a 	bl	8002860 <gsl_error>
 800640c:	2300      	movs	r3, #0
 800640e:	e9c4 3300 	strd	r3, r3, [r4]
 8006412:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006416:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800641a:	4620      	mov	r0, r4
 800641c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800641e:	4905      	ldr	r1, [pc, #20]	; (8006434 <gsl_matrix_float_const_view_vector_with_tda+0x64>)
 8006420:	4806      	ldr	r0, [pc, #24]	; (800643c <gsl_matrix_float_const_view_vector_with_tda+0x6c>)
 8006422:	2304      	movs	r3, #4
 8006424:	227c      	movs	r2, #124	; 0x7c
 8006426:	e7ef      	b.n	8006408 <gsl_matrix_float_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006428:	4902      	ldr	r1, [pc, #8]	; (8006434 <gsl_matrix_float_const_view_vector_with_tda+0x64>)
 800642a:	4805      	ldr	r0, [pc, #20]	; (8006440 <gsl_matrix_float_const_view_vector_with_tda+0x70>)
 800642c:	2304      	movs	r3, #4
 800642e:	2277      	movs	r2, #119	; 0x77
 8006430:	e7ea      	b.n	8006408 <gsl_matrix_float_const_view_vector_with_tda+0x38>
 8006432:	bf00      	nop
 8006434:	080310b4 	.word	0x080310b4
 8006438:	080310ec 	.word	0x080310ec
 800643c:	0803110c 	.word	0x0803110c
 8006440:	080310c4 	.word	0x080310c4

08006444 <gsl_matrix_ulong_const_view_array>:
{
 8006444:	b430      	push	{r4, r5}
    return view;
 8006446:	2500      	movs	r5, #0
 8006448:	e9c0 5504 	strd	r5, r5, [r0, #16]
 800644c:	e9c0 2300 	strd	r2, r3, [r0]
}
 8006450:	bc30      	pop	{r4, r5}
    return view;
 8006452:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8006456:	4770      	bx	lr

08006458 <gsl_matrix_ulong_const_view_array_with_tda>:
{
 8006458:	b538      	push	{r3, r4, r5, lr}
 800645a:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 800645c:	42ab      	cmp	r3, r5
{
 800645e:	4604      	mov	r4, r0
  if (n2 > tda)
 8006460:	d808      	bhi.n	8006474 <gsl_matrix_ulong_const_view_array_with_tda+0x1c>
    return view;
 8006462:	2000      	movs	r0, #0
 8006464:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006468:	e9c4 2300 	strd	r2, r3, [r4]
 800646c:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006470:	4620      	mov	r0, r4
 8006472:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006474:	4907      	ldr	r1, [pc, #28]	; (8006494 <gsl_matrix_ulong_const_view_array_with_tda+0x3c>)
 8006476:	4808      	ldr	r0, [pc, #32]	; (8006498 <gsl_matrix_ulong_const_view_array_with_tda+0x40>)
 8006478:	2304      	movs	r3, #4
 800647a:	2233      	movs	r2, #51	; 0x33
 800647c:	f7fc f9f0 	bl	8002860 <gsl_error>
 8006480:	2300      	movs	r3, #0
 8006482:	e9c4 3300 	strd	r3, r3, [r4]
 8006486:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800648a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800648e:	4620      	mov	r0, r4
 8006490:	bd38      	pop	{r3, r4, r5, pc}
 8006492:	bf00      	nop
 8006494:	080310b4 	.word	0x080310b4
 8006498:	080310c4 	.word	0x080310c4

0800649c <gsl_matrix_ulong_const_view_vector>:
{
 800649c:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 800649e:	684d      	ldr	r5, [r1, #4]
 80064a0:	2d01      	cmp	r5, #1
{
 80064a2:	4604      	mov	r4, r0
  if (v->stride != 1)
 80064a4:	d10f      	bne.n	80064c6 <gsl_matrix_ulong_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80064a6:	6808      	ldr	r0, [r1, #0]
 80064a8:	fb03 f502 	mul.w	r5, r3, r2
 80064ac:	4285      	cmp	r5, r0
 80064ae:	d819      	bhi.n	80064e4 <gsl_matrix_ulong_const_view_vector+0x48>
    m.block = v->block;
 80064b0:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80064b4:	6022      	str	r2, [r4, #0]
 80064b6:	2200      	movs	r2, #0
 80064b8:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80064bc:	e9c4 3301 	strd	r3, r3, [r4, #4]
 80064c0:	6162      	str	r2, [r4, #20]
}
 80064c2:	4620      	mov	r0, r4
 80064c4:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80064c6:	490a      	ldr	r1, [pc, #40]	; (80064f0 <gsl_matrix_ulong_const_view_vector+0x54>)
 80064c8:	480a      	ldr	r0, [pc, #40]	; (80064f4 <gsl_matrix_ulong_const_view_vector+0x58>)
 80064ca:	2304      	movs	r3, #4
 80064cc:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80064ce:	f7fc f9c7 	bl	8002860 <gsl_error>
 80064d2:	2300      	movs	r3, #0
 80064d4:	e9c4 3300 	strd	r3, r3, [r4]
 80064d8:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80064dc:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80064e0:	4620      	mov	r0, r4
 80064e2:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80064e4:	4902      	ldr	r1, [pc, #8]	; (80064f0 <gsl_matrix_ulong_const_view_vector+0x54>)
 80064e6:	4804      	ldr	r0, [pc, #16]	; (80064f8 <gsl_matrix_ulong_const_view_vector+0x5c>)
 80064e8:	2304      	movs	r3, #4
 80064ea:	2254      	movs	r2, #84	; 0x54
 80064ec:	e7ef      	b.n	80064ce <gsl_matrix_ulong_const_view_vector+0x32>
 80064ee:	bf00      	nop
 80064f0:	080310b4 	.word	0x080310b4
 80064f4:	080310ec 	.word	0x080310ec
 80064f8:	0803110c 	.word	0x0803110c

080064fc <gsl_matrix_ulong_const_view_vector_with_tda>:
{
 80064fc:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 80064fe:	684d      	ldr	r5, [r1, #4]
{
 8006500:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8006502:	2d01      	cmp	r5, #1
{
 8006504:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006506:	d111      	bne.n	800652c <gsl_matrix_ulong_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006508:	42b3      	cmp	r3, r6
 800650a:	d823      	bhi.n	8006554 <gsl_matrix_ulong_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 800650c:	6808      	ldr	r0, [r1, #0]
 800650e:	fb02 f506 	mul.w	r5, r2, r6
 8006512:	4285      	cmp	r5, r0
 8006514:	d819      	bhi.n	800654a <gsl_matrix_ulong_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006516:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800651a:	6022      	str	r2, [r4, #0]
 800651c:	2200      	movs	r2, #0
 800651e:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006522:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8006526:	6162      	str	r2, [r4, #20]
}
 8006528:	4620      	mov	r0, r4
 800652a:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800652c:	490c      	ldr	r1, [pc, #48]	; (8006560 <gsl_matrix_ulong_const_view_vector_with_tda+0x64>)
 800652e:	480d      	ldr	r0, [pc, #52]	; (8006564 <gsl_matrix_ulong_const_view_vector_with_tda+0x68>)
 8006530:	2304      	movs	r3, #4
 8006532:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006534:	f7fc f994 	bl	8002860 <gsl_error>
 8006538:	2300      	movs	r3, #0
 800653a:	e9c4 3300 	strd	r3, r3, [r4]
 800653e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006542:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006546:	4620      	mov	r0, r4
 8006548:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800654a:	4905      	ldr	r1, [pc, #20]	; (8006560 <gsl_matrix_ulong_const_view_vector_with_tda+0x64>)
 800654c:	4806      	ldr	r0, [pc, #24]	; (8006568 <gsl_matrix_ulong_const_view_vector_with_tda+0x6c>)
 800654e:	2304      	movs	r3, #4
 8006550:	227c      	movs	r2, #124	; 0x7c
 8006552:	e7ef      	b.n	8006534 <gsl_matrix_ulong_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006554:	4902      	ldr	r1, [pc, #8]	; (8006560 <gsl_matrix_ulong_const_view_vector_with_tda+0x64>)
 8006556:	4805      	ldr	r0, [pc, #20]	; (800656c <gsl_matrix_ulong_const_view_vector_with_tda+0x70>)
 8006558:	2304      	movs	r3, #4
 800655a:	2277      	movs	r2, #119	; 0x77
 800655c:	e7ea      	b.n	8006534 <gsl_matrix_ulong_const_view_vector_with_tda+0x38>
 800655e:	bf00      	nop
 8006560:	080310b4 	.word	0x080310b4
 8006564:	080310ec 	.word	0x080310ec
 8006568:	0803110c 	.word	0x0803110c
 800656c:	080310c4 	.word	0x080310c4

08006570 <gsl_matrix_long_const_view_array>:
{
 8006570:	b430      	push	{r4, r5}
    return view;
 8006572:	2500      	movs	r5, #0
 8006574:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8006578:	e9c0 2300 	strd	r2, r3, [r0]
}
 800657c:	bc30      	pop	{r4, r5}
    return view;
 800657e:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8006582:	4770      	bx	lr

08006584 <gsl_matrix_long_const_view_array_with_tda>:
{
 8006584:	b538      	push	{r3, r4, r5, lr}
 8006586:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8006588:	42ab      	cmp	r3, r5
{
 800658a:	4604      	mov	r4, r0
  if (n2 > tda)
 800658c:	d808      	bhi.n	80065a0 <gsl_matrix_long_const_view_array_with_tda+0x1c>
    return view;
 800658e:	2000      	movs	r0, #0
 8006590:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006594:	e9c4 2300 	strd	r2, r3, [r4]
 8006598:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 800659c:	4620      	mov	r0, r4
 800659e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80065a0:	4907      	ldr	r1, [pc, #28]	; (80065c0 <gsl_matrix_long_const_view_array_with_tda+0x3c>)
 80065a2:	4808      	ldr	r0, [pc, #32]	; (80065c4 <gsl_matrix_long_const_view_array_with_tda+0x40>)
 80065a4:	2304      	movs	r3, #4
 80065a6:	2233      	movs	r2, #51	; 0x33
 80065a8:	f7fc f95a 	bl	8002860 <gsl_error>
 80065ac:	2300      	movs	r3, #0
 80065ae:	e9c4 3300 	strd	r3, r3, [r4]
 80065b2:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80065b6:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80065ba:	4620      	mov	r0, r4
 80065bc:	bd38      	pop	{r3, r4, r5, pc}
 80065be:	bf00      	nop
 80065c0:	080310b4 	.word	0x080310b4
 80065c4:	080310c4 	.word	0x080310c4

080065c8 <gsl_matrix_long_const_view_vector>:
{
 80065c8:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 80065ca:	684d      	ldr	r5, [r1, #4]
 80065cc:	2d01      	cmp	r5, #1
{
 80065ce:	4604      	mov	r4, r0
  if (v->stride != 1)
 80065d0:	d10f      	bne.n	80065f2 <gsl_matrix_long_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80065d2:	6808      	ldr	r0, [r1, #0]
 80065d4:	fb03 f502 	mul.w	r5, r3, r2
 80065d8:	4285      	cmp	r5, r0
 80065da:	d819      	bhi.n	8006610 <gsl_matrix_long_const_view_vector+0x48>
    m.block = v->block;
 80065dc:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80065e0:	6022      	str	r2, [r4, #0]
 80065e2:	2200      	movs	r2, #0
 80065e4:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80065e8:	e9c4 3301 	strd	r3, r3, [r4, #4]
 80065ec:	6162      	str	r2, [r4, #20]
}
 80065ee:	4620      	mov	r0, r4
 80065f0:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80065f2:	490a      	ldr	r1, [pc, #40]	; (800661c <gsl_matrix_long_const_view_vector+0x54>)
 80065f4:	480a      	ldr	r0, [pc, #40]	; (8006620 <gsl_matrix_long_const_view_vector+0x58>)
 80065f6:	2304      	movs	r3, #4
 80065f8:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80065fa:	f7fc f931 	bl	8002860 <gsl_error>
 80065fe:	2300      	movs	r3, #0
 8006600:	e9c4 3300 	strd	r3, r3, [r4]
 8006604:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006608:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800660c:	4620      	mov	r0, r4
 800660e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006610:	4902      	ldr	r1, [pc, #8]	; (800661c <gsl_matrix_long_const_view_vector+0x54>)
 8006612:	4804      	ldr	r0, [pc, #16]	; (8006624 <gsl_matrix_long_const_view_vector+0x5c>)
 8006614:	2304      	movs	r3, #4
 8006616:	2254      	movs	r2, #84	; 0x54
 8006618:	e7ef      	b.n	80065fa <gsl_matrix_long_const_view_vector+0x32>
 800661a:	bf00      	nop
 800661c:	080310b4 	.word	0x080310b4
 8006620:	080310ec 	.word	0x080310ec
 8006624:	0803110c 	.word	0x0803110c

08006628 <gsl_matrix_long_const_view_vector_with_tda>:
{
 8006628:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 800662a:	684d      	ldr	r5, [r1, #4]
{
 800662c:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800662e:	2d01      	cmp	r5, #1
{
 8006630:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006632:	d111      	bne.n	8006658 <gsl_matrix_long_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006634:	42b3      	cmp	r3, r6
 8006636:	d823      	bhi.n	8006680 <gsl_matrix_long_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006638:	6808      	ldr	r0, [r1, #0]
 800663a:	fb02 f506 	mul.w	r5, r2, r6
 800663e:	4285      	cmp	r5, r0
 8006640:	d819      	bhi.n	8006676 <gsl_matrix_long_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006642:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006646:	6022      	str	r2, [r4, #0]
 8006648:	2200      	movs	r2, #0
 800664a:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800664e:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8006652:	6162      	str	r2, [r4, #20]
}
 8006654:	4620      	mov	r0, r4
 8006656:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006658:	490c      	ldr	r1, [pc, #48]	; (800668c <gsl_matrix_long_const_view_vector_with_tda+0x64>)
 800665a:	480d      	ldr	r0, [pc, #52]	; (8006690 <gsl_matrix_long_const_view_vector_with_tda+0x68>)
 800665c:	2304      	movs	r3, #4
 800665e:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006660:	f7fc f8fe 	bl	8002860 <gsl_error>
 8006664:	2300      	movs	r3, #0
 8006666:	e9c4 3300 	strd	r3, r3, [r4]
 800666a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800666e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006672:	4620      	mov	r0, r4
 8006674:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006676:	4905      	ldr	r1, [pc, #20]	; (800668c <gsl_matrix_long_const_view_vector_with_tda+0x64>)
 8006678:	4806      	ldr	r0, [pc, #24]	; (8006694 <gsl_matrix_long_const_view_vector_with_tda+0x6c>)
 800667a:	2304      	movs	r3, #4
 800667c:	227c      	movs	r2, #124	; 0x7c
 800667e:	e7ef      	b.n	8006660 <gsl_matrix_long_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006680:	4902      	ldr	r1, [pc, #8]	; (800668c <gsl_matrix_long_const_view_vector_with_tda+0x64>)
 8006682:	4805      	ldr	r0, [pc, #20]	; (8006698 <gsl_matrix_long_const_view_vector_with_tda+0x70>)
 8006684:	2304      	movs	r3, #4
 8006686:	2277      	movs	r2, #119	; 0x77
 8006688:	e7ea      	b.n	8006660 <gsl_matrix_long_const_view_vector_with_tda+0x38>
 800668a:	bf00      	nop
 800668c:	080310b4 	.word	0x080310b4
 8006690:	080310ec 	.word	0x080310ec
 8006694:	0803110c 	.word	0x0803110c
 8006698:	080310c4 	.word	0x080310c4

0800669c <gsl_matrix_uint_const_view_array>:
{
 800669c:	b430      	push	{r4, r5}
    return view;
 800669e:	2500      	movs	r5, #0
 80066a0:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80066a4:	e9c0 2300 	strd	r2, r3, [r0]
}
 80066a8:	bc30      	pop	{r4, r5}
    return view;
 80066aa:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80066ae:	4770      	bx	lr

080066b0 <gsl_matrix_uint_const_view_array_with_tda>:
{
 80066b0:	b538      	push	{r3, r4, r5, lr}
 80066b2:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80066b4:	42ab      	cmp	r3, r5
{
 80066b6:	4604      	mov	r4, r0
  if (n2 > tda)
 80066b8:	d808      	bhi.n	80066cc <gsl_matrix_uint_const_view_array_with_tda+0x1c>
    return view;
 80066ba:	2000      	movs	r0, #0
 80066bc:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80066c0:	e9c4 2300 	strd	r2, r3, [r4]
 80066c4:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80066c8:	4620      	mov	r0, r4
 80066ca:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80066cc:	4907      	ldr	r1, [pc, #28]	; (80066ec <gsl_matrix_uint_const_view_array_with_tda+0x3c>)
 80066ce:	4808      	ldr	r0, [pc, #32]	; (80066f0 <gsl_matrix_uint_const_view_array_with_tda+0x40>)
 80066d0:	2304      	movs	r3, #4
 80066d2:	2233      	movs	r2, #51	; 0x33
 80066d4:	f7fc f8c4 	bl	8002860 <gsl_error>
 80066d8:	2300      	movs	r3, #0
 80066da:	e9c4 3300 	strd	r3, r3, [r4]
 80066de:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80066e2:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80066e6:	4620      	mov	r0, r4
 80066e8:	bd38      	pop	{r3, r4, r5, pc}
 80066ea:	bf00      	nop
 80066ec:	080310b4 	.word	0x080310b4
 80066f0:	080310c4 	.word	0x080310c4

080066f4 <gsl_matrix_uint_const_view_vector>:
{
 80066f4:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 80066f6:	684d      	ldr	r5, [r1, #4]
 80066f8:	2d01      	cmp	r5, #1
{
 80066fa:	4604      	mov	r4, r0
  if (v->stride != 1)
 80066fc:	d10f      	bne.n	800671e <gsl_matrix_uint_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 80066fe:	6808      	ldr	r0, [r1, #0]
 8006700:	fb03 f502 	mul.w	r5, r3, r2
 8006704:	4285      	cmp	r5, r0
 8006706:	d819      	bhi.n	800673c <gsl_matrix_uint_const_view_vector+0x48>
    m.block = v->block;
 8006708:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800670c:	6022      	str	r2, [r4, #0]
 800670e:	2200      	movs	r2, #0
 8006710:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006714:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006718:	6162      	str	r2, [r4, #20]
}
 800671a:	4620      	mov	r0, r4
 800671c:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800671e:	490a      	ldr	r1, [pc, #40]	; (8006748 <gsl_matrix_uint_const_view_vector+0x54>)
 8006720:	480a      	ldr	r0, [pc, #40]	; (800674c <gsl_matrix_uint_const_view_vector+0x58>)
 8006722:	2304      	movs	r3, #4
 8006724:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006726:	f7fc f89b 	bl	8002860 <gsl_error>
 800672a:	2300      	movs	r3, #0
 800672c:	e9c4 3300 	strd	r3, r3, [r4]
 8006730:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006734:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006738:	4620      	mov	r0, r4
 800673a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800673c:	4902      	ldr	r1, [pc, #8]	; (8006748 <gsl_matrix_uint_const_view_vector+0x54>)
 800673e:	4804      	ldr	r0, [pc, #16]	; (8006750 <gsl_matrix_uint_const_view_vector+0x5c>)
 8006740:	2304      	movs	r3, #4
 8006742:	2254      	movs	r2, #84	; 0x54
 8006744:	e7ef      	b.n	8006726 <gsl_matrix_uint_const_view_vector+0x32>
 8006746:	bf00      	nop
 8006748:	080310b4 	.word	0x080310b4
 800674c:	080310ec 	.word	0x080310ec
 8006750:	0803110c 	.word	0x0803110c

08006754 <gsl_matrix_uint_const_view_vector_with_tda>:
{
 8006754:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8006756:	684d      	ldr	r5, [r1, #4]
{
 8006758:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 800675a:	2d01      	cmp	r5, #1
{
 800675c:	4604      	mov	r4, r0
  if (v->stride != 1)
 800675e:	d111      	bne.n	8006784 <gsl_matrix_uint_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006760:	42b3      	cmp	r3, r6
 8006762:	d823      	bhi.n	80067ac <gsl_matrix_uint_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006764:	6808      	ldr	r0, [r1, #0]
 8006766:	fb02 f506 	mul.w	r5, r2, r6
 800676a:	4285      	cmp	r5, r0
 800676c:	d819      	bhi.n	80067a2 <gsl_matrix_uint_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 800676e:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006772:	6022      	str	r2, [r4, #0]
 8006774:	2200      	movs	r2, #0
 8006776:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800677a:	e9c4 3601 	strd	r3, r6, [r4, #4]
 800677e:	6162      	str	r2, [r4, #20]
}
 8006780:	4620      	mov	r0, r4
 8006782:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006784:	490c      	ldr	r1, [pc, #48]	; (80067b8 <gsl_matrix_uint_const_view_vector_with_tda+0x64>)
 8006786:	480d      	ldr	r0, [pc, #52]	; (80067bc <gsl_matrix_uint_const_view_vector_with_tda+0x68>)
 8006788:	2304      	movs	r3, #4
 800678a:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800678c:	f7fc f868 	bl	8002860 <gsl_error>
 8006790:	2300      	movs	r3, #0
 8006792:	e9c4 3300 	strd	r3, r3, [r4]
 8006796:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800679a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800679e:	4620      	mov	r0, r4
 80067a0:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80067a2:	4905      	ldr	r1, [pc, #20]	; (80067b8 <gsl_matrix_uint_const_view_vector_with_tda+0x64>)
 80067a4:	4806      	ldr	r0, [pc, #24]	; (80067c0 <gsl_matrix_uint_const_view_vector_with_tda+0x6c>)
 80067a6:	2304      	movs	r3, #4
 80067a8:	227c      	movs	r2, #124	; 0x7c
 80067aa:	e7ef      	b.n	800678c <gsl_matrix_uint_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80067ac:	4902      	ldr	r1, [pc, #8]	; (80067b8 <gsl_matrix_uint_const_view_vector_with_tda+0x64>)
 80067ae:	4805      	ldr	r0, [pc, #20]	; (80067c4 <gsl_matrix_uint_const_view_vector_with_tda+0x70>)
 80067b0:	2304      	movs	r3, #4
 80067b2:	2277      	movs	r2, #119	; 0x77
 80067b4:	e7ea      	b.n	800678c <gsl_matrix_uint_const_view_vector_with_tda+0x38>
 80067b6:	bf00      	nop
 80067b8:	080310b4 	.word	0x080310b4
 80067bc:	080310ec 	.word	0x080310ec
 80067c0:	0803110c 	.word	0x0803110c
 80067c4:	080310c4 	.word	0x080310c4

080067c8 <gsl_matrix_int_const_view_array>:
{
 80067c8:	b430      	push	{r4, r5}
    return view;
 80067ca:	2500      	movs	r5, #0
 80067cc:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80067d0:	e9c0 2300 	strd	r2, r3, [r0]
}
 80067d4:	bc30      	pop	{r4, r5}
    return view;
 80067d6:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 80067da:	4770      	bx	lr

080067dc <gsl_matrix_int_const_view_array_with_tda>:
{
 80067dc:	b538      	push	{r3, r4, r5, lr}
 80067de:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 80067e0:	42ab      	cmp	r3, r5
{
 80067e2:	4604      	mov	r4, r0
  if (n2 > tda)
 80067e4:	d808      	bhi.n	80067f8 <gsl_matrix_int_const_view_array_with_tda+0x1c>
    return view;
 80067e6:	2000      	movs	r0, #0
 80067e8:	e9c4 0004 	strd	r0, r0, [r4, #16]
 80067ec:	e9c4 2300 	strd	r2, r3, [r4]
 80067f0:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 80067f4:	4620      	mov	r0, r4
 80067f6:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80067f8:	4907      	ldr	r1, [pc, #28]	; (8006818 <gsl_matrix_int_const_view_array_with_tda+0x3c>)
 80067fa:	4808      	ldr	r0, [pc, #32]	; (800681c <gsl_matrix_int_const_view_array_with_tda+0x40>)
 80067fc:	2304      	movs	r3, #4
 80067fe:	2233      	movs	r2, #51	; 0x33
 8006800:	f7fc f82e 	bl	8002860 <gsl_error>
 8006804:	2300      	movs	r3, #0
 8006806:	e9c4 3300 	strd	r3, r3, [r4]
 800680a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800680e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006812:	4620      	mov	r0, r4
 8006814:	bd38      	pop	{r3, r4, r5, pc}
 8006816:	bf00      	nop
 8006818:	080310b4 	.word	0x080310b4
 800681c:	080310c4 	.word	0x080310c4

08006820 <gsl_matrix_int_const_view_vector>:
{
 8006820:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8006822:	684d      	ldr	r5, [r1, #4]
 8006824:	2d01      	cmp	r5, #1
{
 8006826:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006828:	d10f      	bne.n	800684a <gsl_matrix_int_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 800682a:	6808      	ldr	r0, [r1, #0]
 800682c:	fb03 f502 	mul.w	r5, r3, r2
 8006830:	4285      	cmp	r5, r0
 8006832:	d819      	bhi.n	8006868 <gsl_matrix_int_const_view_vector+0x48>
    m.block = v->block;
 8006834:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006838:	6022      	str	r2, [r4, #0]
 800683a:	2200      	movs	r2, #0
 800683c:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006840:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006844:	6162      	str	r2, [r4, #20]
}
 8006846:	4620      	mov	r0, r4
 8006848:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 800684a:	490a      	ldr	r1, [pc, #40]	; (8006874 <gsl_matrix_int_const_view_vector+0x54>)
 800684c:	480a      	ldr	r0, [pc, #40]	; (8006878 <gsl_matrix_int_const_view_vector+0x58>)
 800684e:	2304      	movs	r3, #4
 8006850:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006852:	f7fc f805 	bl	8002860 <gsl_error>
 8006856:	2300      	movs	r3, #0
 8006858:	e9c4 3300 	strd	r3, r3, [r4]
 800685c:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006860:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006864:	4620      	mov	r0, r4
 8006866:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006868:	4902      	ldr	r1, [pc, #8]	; (8006874 <gsl_matrix_int_const_view_vector+0x54>)
 800686a:	4804      	ldr	r0, [pc, #16]	; (800687c <gsl_matrix_int_const_view_vector+0x5c>)
 800686c:	2304      	movs	r3, #4
 800686e:	2254      	movs	r2, #84	; 0x54
 8006870:	e7ef      	b.n	8006852 <gsl_matrix_int_const_view_vector+0x32>
 8006872:	bf00      	nop
 8006874:	080310b4 	.word	0x080310b4
 8006878:	080310ec 	.word	0x080310ec
 800687c:	0803110c 	.word	0x0803110c

08006880 <gsl_matrix_int_const_view_vector_with_tda>:
{
 8006880:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8006882:	684d      	ldr	r5, [r1, #4]
{
 8006884:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8006886:	2d01      	cmp	r5, #1
{
 8006888:	4604      	mov	r4, r0
  if (v->stride != 1)
 800688a:	d111      	bne.n	80068b0 <gsl_matrix_int_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 800688c:	42b3      	cmp	r3, r6
 800688e:	d823      	bhi.n	80068d8 <gsl_matrix_int_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006890:	6808      	ldr	r0, [r1, #0]
 8006892:	fb02 f506 	mul.w	r5, r2, r6
 8006896:	4285      	cmp	r5, r0
 8006898:	d819      	bhi.n	80068ce <gsl_matrix_int_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 800689a:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 800689e:	6022      	str	r2, [r4, #0]
 80068a0:	2200      	movs	r2, #0
 80068a2:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80068a6:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80068aa:	6162      	str	r2, [r4, #20]
}
 80068ac:	4620      	mov	r0, r4
 80068ae:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80068b0:	490c      	ldr	r1, [pc, #48]	; (80068e4 <gsl_matrix_int_const_view_vector_with_tda+0x64>)
 80068b2:	480d      	ldr	r0, [pc, #52]	; (80068e8 <gsl_matrix_int_const_view_vector_with_tda+0x68>)
 80068b4:	2304      	movs	r3, #4
 80068b6:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80068b8:	f7fb ffd2 	bl	8002860 <gsl_error>
 80068bc:	2300      	movs	r3, #0
 80068be:	e9c4 3300 	strd	r3, r3, [r4]
 80068c2:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80068c6:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80068ca:	4620      	mov	r0, r4
 80068cc:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80068ce:	4905      	ldr	r1, [pc, #20]	; (80068e4 <gsl_matrix_int_const_view_vector_with_tda+0x64>)
 80068d0:	4806      	ldr	r0, [pc, #24]	; (80068ec <gsl_matrix_int_const_view_vector_with_tda+0x6c>)
 80068d2:	2304      	movs	r3, #4
 80068d4:	227c      	movs	r2, #124	; 0x7c
 80068d6:	e7ef      	b.n	80068b8 <gsl_matrix_int_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 80068d8:	4902      	ldr	r1, [pc, #8]	; (80068e4 <gsl_matrix_int_const_view_vector_with_tda+0x64>)
 80068da:	4805      	ldr	r0, [pc, #20]	; (80068f0 <gsl_matrix_int_const_view_vector_with_tda+0x70>)
 80068dc:	2304      	movs	r3, #4
 80068de:	2277      	movs	r2, #119	; 0x77
 80068e0:	e7ea      	b.n	80068b8 <gsl_matrix_int_const_view_vector_with_tda+0x38>
 80068e2:	bf00      	nop
 80068e4:	080310b4 	.word	0x080310b4
 80068e8:	080310ec 	.word	0x080310ec
 80068ec:	0803110c 	.word	0x0803110c
 80068f0:	080310c4 	.word	0x080310c4

080068f4 <gsl_matrix_ushort_const_view_array>:
{
 80068f4:	b430      	push	{r4, r5}
    return view;
 80068f6:	2500      	movs	r5, #0
 80068f8:	e9c0 5504 	strd	r5, r5, [r0, #16]
 80068fc:	e9c0 2300 	strd	r2, r3, [r0]
}
 8006900:	bc30      	pop	{r4, r5}
    return view;
 8006902:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8006906:	4770      	bx	lr

08006908 <gsl_matrix_ushort_const_view_array_with_tda>:
{
 8006908:	b538      	push	{r3, r4, r5, lr}
 800690a:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 800690c:	42ab      	cmp	r3, r5
{
 800690e:	4604      	mov	r4, r0
  if (n2 > tda)
 8006910:	d808      	bhi.n	8006924 <gsl_matrix_ushort_const_view_array_with_tda+0x1c>
    return view;
 8006912:	2000      	movs	r0, #0
 8006914:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006918:	e9c4 2300 	strd	r2, r3, [r4]
 800691c:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006920:	4620      	mov	r0, r4
 8006922:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006924:	4907      	ldr	r1, [pc, #28]	; (8006944 <gsl_matrix_ushort_const_view_array_with_tda+0x3c>)
 8006926:	4808      	ldr	r0, [pc, #32]	; (8006948 <gsl_matrix_ushort_const_view_array_with_tda+0x40>)
 8006928:	2304      	movs	r3, #4
 800692a:	2233      	movs	r2, #51	; 0x33
 800692c:	f7fb ff98 	bl	8002860 <gsl_error>
 8006930:	2300      	movs	r3, #0
 8006932:	e9c4 3300 	strd	r3, r3, [r4]
 8006936:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800693a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 800693e:	4620      	mov	r0, r4
 8006940:	bd38      	pop	{r3, r4, r5, pc}
 8006942:	bf00      	nop
 8006944:	080310b4 	.word	0x080310b4
 8006948:	080310c4 	.word	0x080310c4

0800694c <gsl_matrix_ushort_const_view_vector>:
{
 800694c:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 800694e:	684d      	ldr	r5, [r1, #4]
 8006950:	2d01      	cmp	r5, #1
{
 8006952:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006954:	d10f      	bne.n	8006976 <gsl_matrix_ushort_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8006956:	6808      	ldr	r0, [r1, #0]
 8006958:	fb03 f502 	mul.w	r5, r3, r2
 800695c:	4285      	cmp	r5, r0
 800695e:	d819      	bhi.n	8006994 <gsl_matrix_ushort_const_view_vector+0x48>
    m.block = v->block;
 8006960:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006964:	6022      	str	r2, [r4, #0]
 8006966:	2200      	movs	r2, #0
 8006968:	e9c4 0103 	strd	r0, r1, [r4, #12]
 800696c:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006970:	6162      	str	r2, [r4, #20]
}
 8006972:	4620      	mov	r0, r4
 8006974:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006976:	490a      	ldr	r1, [pc, #40]	; (80069a0 <gsl_matrix_ushort_const_view_vector+0x54>)
 8006978:	480a      	ldr	r0, [pc, #40]	; (80069a4 <gsl_matrix_ushort_const_view_vector+0x58>)
 800697a:	2304      	movs	r3, #4
 800697c:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 800697e:	f7fb ff6f 	bl	8002860 <gsl_error>
 8006982:	2300      	movs	r3, #0
 8006984:	e9c4 3300 	strd	r3, r3, [r4]
 8006988:	e9c4 3302 	strd	r3, r3, [r4, #8]
 800698c:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006990:	4620      	mov	r0, r4
 8006992:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006994:	4902      	ldr	r1, [pc, #8]	; (80069a0 <gsl_matrix_ushort_const_view_vector+0x54>)
 8006996:	4804      	ldr	r0, [pc, #16]	; (80069a8 <gsl_matrix_ushort_const_view_vector+0x5c>)
 8006998:	2304      	movs	r3, #4
 800699a:	2254      	movs	r2, #84	; 0x54
 800699c:	e7ef      	b.n	800697e <gsl_matrix_ushort_const_view_vector+0x32>
 800699e:	bf00      	nop
 80069a0:	080310b4 	.word	0x080310b4
 80069a4:	080310ec 	.word	0x080310ec
 80069a8:	0803110c 	.word	0x0803110c

080069ac <gsl_matrix_ushort_const_view_vector_with_tda>:
{
 80069ac:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 80069ae:	684d      	ldr	r5, [r1, #4]
{
 80069b0:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 80069b2:	2d01      	cmp	r5, #1
{
 80069b4:	4604      	mov	r4, r0
  if (v->stride != 1)
 80069b6:	d111      	bne.n	80069dc <gsl_matrix_ushort_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 80069b8:	42b3      	cmp	r3, r6
 80069ba:	d823      	bhi.n	8006a04 <gsl_matrix_ushort_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 80069bc:	6808      	ldr	r0, [r1, #0]
 80069be:	fb02 f506 	mul.w	r5, r2, r6
 80069c2:	4285      	cmp	r5, r0
 80069c4:	d819      	bhi.n	80069fa <gsl_matrix_ushort_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 80069c6:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 80069ca:	6022      	str	r2, [r4, #0]
 80069cc:	2200      	movs	r2, #0
 80069ce:	e9c4 0103 	strd	r0, r1, [r4, #12]
 80069d2:	e9c4 3601 	strd	r3, r6, [r4, #4]
 80069d6:	6162      	str	r2, [r4, #20]
}
 80069d8:	4620      	mov	r0, r4
 80069da:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 80069dc:	490c      	ldr	r1, [pc, #48]	; (8006a10 <gsl_matrix_ushort_const_view_vector_with_tda+0x64>)
 80069de:	480d      	ldr	r0, [pc, #52]	; (8006a14 <gsl_matrix_ushort_const_view_vector_with_tda+0x68>)
 80069e0:	2304      	movs	r3, #4
 80069e2:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80069e4:	f7fb ff3c 	bl	8002860 <gsl_error>
 80069e8:	2300      	movs	r3, #0
 80069ea:	e9c4 3300 	strd	r3, r3, [r4]
 80069ee:	e9c4 3302 	strd	r3, r3, [r4, #8]
 80069f2:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 80069f6:	4620      	mov	r0, r4
 80069f8:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 80069fa:	4905      	ldr	r1, [pc, #20]	; (8006a10 <gsl_matrix_ushort_const_view_vector_with_tda+0x64>)
 80069fc:	4806      	ldr	r0, [pc, #24]	; (8006a18 <gsl_matrix_ushort_const_view_vector_with_tda+0x6c>)
 80069fe:	2304      	movs	r3, #4
 8006a00:	227c      	movs	r2, #124	; 0x7c
 8006a02:	e7ef      	b.n	80069e4 <gsl_matrix_ushort_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006a04:	4902      	ldr	r1, [pc, #8]	; (8006a10 <gsl_matrix_ushort_const_view_vector_with_tda+0x64>)
 8006a06:	4805      	ldr	r0, [pc, #20]	; (8006a1c <gsl_matrix_ushort_const_view_vector_with_tda+0x70>)
 8006a08:	2304      	movs	r3, #4
 8006a0a:	2277      	movs	r2, #119	; 0x77
 8006a0c:	e7ea      	b.n	80069e4 <gsl_matrix_ushort_const_view_vector_with_tda+0x38>
 8006a0e:	bf00      	nop
 8006a10:	080310b4 	.word	0x080310b4
 8006a14:	080310ec 	.word	0x080310ec
 8006a18:	0803110c 	.word	0x0803110c
 8006a1c:	080310c4 	.word	0x080310c4

08006a20 <gsl_matrix_short_const_view_array>:
{
 8006a20:	b430      	push	{r4, r5}
    return view;
 8006a22:	2500      	movs	r5, #0
 8006a24:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8006a28:	e9c0 2300 	strd	r2, r3, [r0]
}
 8006a2c:	bc30      	pop	{r4, r5}
    return view;
 8006a2e:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8006a32:	4770      	bx	lr

08006a34 <gsl_matrix_short_const_view_array_with_tda>:
{
 8006a34:	b538      	push	{r3, r4, r5, lr}
 8006a36:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8006a38:	42ab      	cmp	r3, r5
{
 8006a3a:	4604      	mov	r4, r0
  if (n2 > tda)
 8006a3c:	d808      	bhi.n	8006a50 <gsl_matrix_short_const_view_array_with_tda+0x1c>
    return view;
 8006a3e:	2000      	movs	r0, #0
 8006a40:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006a44:	e9c4 2300 	strd	r2, r3, [r4]
 8006a48:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006a4c:	4620      	mov	r0, r4
 8006a4e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006a50:	4907      	ldr	r1, [pc, #28]	; (8006a70 <gsl_matrix_short_const_view_array_with_tda+0x3c>)
 8006a52:	4808      	ldr	r0, [pc, #32]	; (8006a74 <gsl_matrix_short_const_view_array_with_tda+0x40>)
 8006a54:	2304      	movs	r3, #4
 8006a56:	2233      	movs	r2, #51	; 0x33
 8006a58:	f7fb ff02 	bl	8002860 <gsl_error>
 8006a5c:	2300      	movs	r3, #0
 8006a5e:	e9c4 3300 	strd	r3, r3, [r4]
 8006a62:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006a66:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006a6a:	4620      	mov	r0, r4
 8006a6c:	bd38      	pop	{r3, r4, r5, pc}
 8006a6e:	bf00      	nop
 8006a70:	080310b4 	.word	0x080310b4
 8006a74:	080310c4 	.word	0x080310c4

08006a78 <gsl_matrix_short_const_view_vector>:
{
 8006a78:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8006a7a:	684d      	ldr	r5, [r1, #4]
 8006a7c:	2d01      	cmp	r5, #1
{
 8006a7e:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006a80:	d10f      	bne.n	8006aa2 <gsl_matrix_short_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8006a82:	6808      	ldr	r0, [r1, #0]
 8006a84:	fb03 f502 	mul.w	r5, r3, r2
 8006a88:	4285      	cmp	r5, r0
 8006a8a:	d819      	bhi.n	8006ac0 <gsl_matrix_short_const_view_vector+0x48>
    m.block = v->block;
 8006a8c:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006a90:	6022      	str	r2, [r4, #0]
 8006a92:	2200      	movs	r2, #0
 8006a94:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006a98:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006a9c:	6162      	str	r2, [r4, #20]
}
 8006a9e:	4620      	mov	r0, r4
 8006aa0:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006aa2:	490a      	ldr	r1, [pc, #40]	; (8006acc <gsl_matrix_short_const_view_vector+0x54>)
 8006aa4:	480a      	ldr	r0, [pc, #40]	; (8006ad0 <gsl_matrix_short_const_view_vector+0x58>)
 8006aa6:	2304      	movs	r3, #4
 8006aa8:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006aaa:	f7fb fed9 	bl	8002860 <gsl_error>
 8006aae:	2300      	movs	r3, #0
 8006ab0:	e9c4 3300 	strd	r3, r3, [r4]
 8006ab4:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006ab8:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006abc:	4620      	mov	r0, r4
 8006abe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006ac0:	4902      	ldr	r1, [pc, #8]	; (8006acc <gsl_matrix_short_const_view_vector+0x54>)
 8006ac2:	4804      	ldr	r0, [pc, #16]	; (8006ad4 <gsl_matrix_short_const_view_vector+0x5c>)
 8006ac4:	2304      	movs	r3, #4
 8006ac6:	2254      	movs	r2, #84	; 0x54
 8006ac8:	e7ef      	b.n	8006aaa <gsl_matrix_short_const_view_vector+0x32>
 8006aca:	bf00      	nop
 8006acc:	080310b4 	.word	0x080310b4
 8006ad0:	080310ec 	.word	0x080310ec
 8006ad4:	0803110c 	.word	0x0803110c

08006ad8 <gsl_matrix_short_const_view_vector_with_tda>:
{
 8006ad8:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8006ada:	684d      	ldr	r5, [r1, #4]
{
 8006adc:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8006ade:	2d01      	cmp	r5, #1
{
 8006ae0:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006ae2:	d111      	bne.n	8006b08 <gsl_matrix_short_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006ae4:	42b3      	cmp	r3, r6
 8006ae6:	d823      	bhi.n	8006b30 <gsl_matrix_short_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006ae8:	6808      	ldr	r0, [r1, #0]
 8006aea:	fb02 f506 	mul.w	r5, r2, r6
 8006aee:	4285      	cmp	r5, r0
 8006af0:	d819      	bhi.n	8006b26 <gsl_matrix_short_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006af2:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006af6:	6022      	str	r2, [r4, #0]
 8006af8:	2200      	movs	r2, #0
 8006afa:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006afe:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8006b02:	6162      	str	r2, [r4, #20]
}
 8006b04:	4620      	mov	r0, r4
 8006b06:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006b08:	490c      	ldr	r1, [pc, #48]	; (8006b3c <gsl_matrix_short_const_view_vector_with_tda+0x64>)
 8006b0a:	480d      	ldr	r0, [pc, #52]	; (8006b40 <gsl_matrix_short_const_view_vector_with_tda+0x68>)
 8006b0c:	2304      	movs	r3, #4
 8006b0e:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006b10:	f7fb fea6 	bl	8002860 <gsl_error>
 8006b14:	2300      	movs	r3, #0
 8006b16:	e9c4 3300 	strd	r3, r3, [r4]
 8006b1a:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006b1e:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006b22:	4620      	mov	r0, r4
 8006b24:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006b26:	4905      	ldr	r1, [pc, #20]	; (8006b3c <gsl_matrix_short_const_view_vector_with_tda+0x64>)
 8006b28:	4806      	ldr	r0, [pc, #24]	; (8006b44 <gsl_matrix_short_const_view_vector_with_tda+0x6c>)
 8006b2a:	2304      	movs	r3, #4
 8006b2c:	227c      	movs	r2, #124	; 0x7c
 8006b2e:	e7ef      	b.n	8006b10 <gsl_matrix_short_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006b30:	4902      	ldr	r1, [pc, #8]	; (8006b3c <gsl_matrix_short_const_view_vector_with_tda+0x64>)
 8006b32:	4805      	ldr	r0, [pc, #20]	; (8006b48 <gsl_matrix_short_const_view_vector_with_tda+0x70>)
 8006b34:	2304      	movs	r3, #4
 8006b36:	2277      	movs	r2, #119	; 0x77
 8006b38:	e7ea      	b.n	8006b10 <gsl_matrix_short_const_view_vector_with_tda+0x38>
 8006b3a:	bf00      	nop
 8006b3c:	080310b4 	.word	0x080310b4
 8006b40:	080310ec 	.word	0x080310ec
 8006b44:	0803110c 	.word	0x0803110c
 8006b48:	080310c4 	.word	0x080310c4

08006b4c <gsl_matrix_uchar_const_view_array>:
{
 8006b4c:	b430      	push	{r4, r5}
    return view;
 8006b4e:	2500      	movs	r5, #0
 8006b50:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8006b54:	e9c0 2300 	strd	r2, r3, [r0]
}
 8006b58:	bc30      	pop	{r4, r5}
    return view;
 8006b5a:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8006b5e:	4770      	bx	lr

08006b60 <gsl_matrix_uchar_const_view_array_with_tda>:
{
 8006b60:	b538      	push	{r3, r4, r5, lr}
 8006b62:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8006b64:	42ab      	cmp	r3, r5
{
 8006b66:	4604      	mov	r4, r0
  if (n2 > tda)
 8006b68:	d808      	bhi.n	8006b7c <gsl_matrix_uchar_const_view_array_with_tda+0x1c>
    return view;
 8006b6a:	2000      	movs	r0, #0
 8006b6c:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006b70:	e9c4 2300 	strd	r2, r3, [r4]
 8006b74:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006b78:	4620      	mov	r0, r4
 8006b7a:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006b7c:	4907      	ldr	r1, [pc, #28]	; (8006b9c <gsl_matrix_uchar_const_view_array_with_tda+0x3c>)
 8006b7e:	4808      	ldr	r0, [pc, #32]	; (8006ba0 <gsl_matrix_uchar_const_view_array_with_tda+0x40>)
 8006b80:	2304      	movs	r3, #4
 8006b82:	2233      	movs	r2, #51	; 0x33
 8006b84:	f7fb fe6c 	bl	8002860 <gsl_error>
 8006b88:	2300      	movs	r3, #0
 8006b8a:	e9c4 3300 	strd	r3, r3, [r4]
 8006b8e:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006b92:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006b96:	4620      	mov	r0, r4
 8006b98:	bd38      	pop	{r3, r4, r5, pc}
 8006b9a:	bf00      	nop
 8006b9c:	080310b4 	.word	0x080310b4
 8006ba0:	080310c4 	.word	0x080310c4

08006ba4 <gsl_matrix_uchar_const_view_vector>:
{
 8006ba4:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8006ba6:	684d      	ldr	r5, [r1, #4]
 8006ba8:	2d01      	cmp	r5, #1
{
 8006baa:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006bac:	d10f      	bne.n	8006bce <gsl_matrix_uchar_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8006bae:	6808      	ldr	r0, [r1, #0]
 8006bb0:	fb03 f502 	mul.w	r5, r3, r2
 8006bb4:	4285      	cmp	r5, r0
 8006bb6:	d819      	bhi.n	8006bec <gsl_matrix_uchar_const_view_vector+0x48>
    m.block = v->block;
 8006bb8:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006bbc:	6022      	str	r2, [r4, #0]
 8006bbe:	2200      	movs	r2, #0
 8006bc0:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006bc4:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006bc8:	6162      	str	r2, [r4, #20]
}
 8006bca:	4620      	mov	r0, r4
 8006bcc:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006bce:	490a      	ldr	r1, [pc, #40]	; (8006bf8 <gsl_matrix_uchar_const_view_vector+0x54>)
 8006bd0:	480a      	ldr	r0, [pc, #40]	; (8006bfc <gsl_matrix_uchar_const_view_vector+0x58>)
 8006bd2:	2304      	movs	r3, #4
 8006bd4:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006bd6:	f7fb fe43 	bl	8002860 <gsl_error>
 8006bda:	2300      	movs	r3, #0
 8006bdc:	e9c4 3300 	strd	r3, r3, [r4]
 8006be0:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006be4:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006be8:	4620      	mov	r0, r4
 8006bea:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006bec:	4902      	ldr	r1, [pc, #8]	; (8006bf8 <gsl_matrix_uchar_const_view_vector+0x54>)
 8006bee:	4804      	ldr	r0, [pc, #16]	; (8006c00 <gsl_matrix_uchar_const_view_vector+0x5c>)
 8006bf0:	2304      	movs	r3, #4
 8006bf2:	2254      	movs	r2, #84	; 0x54
 8006bf4:	e7ef      	b.n	8006bd6 <gsl_matrix_uchar_const_view_vector+0x32>
 8006bf6:	bf00      	nop
 8006bf8:	080310b4 	.word	0x080310b4
 8006bfc:	080310ec 	.word	0x080310ec
 8006c00:	0803110c 	.word	0x0803110c

08006c04 <gsl_matrix_uchar_const_view_vector_with_tda>:
{
 8006c04:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8006c06:	684d      	ldr	r5, [r1, #4]
{
 8006c08:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8006c0a:	2d01      	cmp	r5, #1
{
 8006c0c:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006c0e:	d111      	bne.n	8006c34 <gsl_matrix_uchar_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006c10:	42b3      	cmp	r3, r6
 8006c12:	d823      	bhi.n	8006c5c <gsl_matrix_uchar_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006c14:	6808      	ldr	r0, [r1, #0]
 8006c16:	fb02 f506 	mul.w	r5, r2, r6
 8006c1a:	4285      	cmp	r5, r0
 8006c1c:	d819      	bhi.n	8006c52 <gsl_matrix_uchar_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006c1e:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006c22:	6022      	str	r2, [r4, #0]
 8006c24:	2200      	movs	r2, #0
 8006c26:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006c2a:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8006c2e:	6162      	str	r2, [r4, #20]
}
 8006c30:	4620      	mov	r0, r4
 8006c32:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006c34:	490c      	ldr	r1, [pc, #48]	; (8006c68 <gsl_matrix_uchar_const_view_vector_with_tda+0x64>)
 8006c36:	480d      	ldr	r0, [pc, #52]	; (8006c6c <gsl_matrix_uchar_const_view_vector_with_tda+0x68>)
 8006c38:	2304      	movs	r3, #4
 8006c3a:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006c3c:	f7fb fe10 	bl	8002860 <gsl_error>
 8006c40:	2300      	movs	r3, #0
 8006c42:	e9c4 3300 	strd	r3, r3, [r4]
 8006c46:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006c4a:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006c4e:	4620      	mov	r0, r4
 8006c50:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006c52:	4905      	ldr	r1, [pc, #20]	; (8006c68 <gsl_matrix_uchar_const_view_vector_with_tda+0x64>)
 8006c54:	4806      	ldr	r0, [pc, #24]	; (8006c70 <gsl_matrix_uchar_const_view_vector_with_tda+0x6c>)
 8006c56:	2304      	movs	r3, #4
 8006c58:	227c      	movs	r2, #124	; 0x7c
 8006c5a:	e7ef      	b.n	8006c3c <gsl_matrix_uchar_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006c5c:	4902      	ldr	r1, [pc, #8]	; (8006c68 <gsl_matrix_uchar_const_view_vector_with_tda+0x64>)
 8006c5e:	4805      	ldr	r0, [pc, #20]	; (8006c74 <gsl_matrix_uchar_const_view_vector_with_tda+0x70>)
 8006c60:	2304      	movs	r3, #4
 8006c62:	2277      	movs	r2, #119	; 0x77
 8006c64:	e7ea      	b.n	8006c3c <gsl_matrix_uchar_const_view_vector_with_tda+0x38>
 8006c66:	bf00      	nop
 8006c68:	080310b4 	.word	0x080310b4
 8006c6c:	080310ec 	.word	0x080310ec
 8006c70:	0803110c 	.word	0x0803110c
 8006c74:	080310c4 	.word	0x080310c4

08006c78 <gsl_matrix_char_const_view_array>:
{
 8006c78:	b430      	push	{r4, r5}
    return view;
 8006c7a:	2500      	movs	r5, #0
 8006c7c:	e9c0 5504 	strd	r5, r5, [r0, #16]
 8006c80:	e9c0 2300 	strd	r2, r3, [r0]
}
 8006c84:	bc30      	pop	{r4, r5}
    return view;
 8006c86:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 8006c8a:	4770      	bx	lr

08006c8c <gsl_matrix_char_const_view_array_with_tda>:
{
 8006c8c:	b538      	push	{r3, r4, r5, lr}
 8006c8e:	9d04      	ldr	r5, [sp, #16]
  if (n2 > tda)
 8006c90:	42ab      	cmp	r3, r5
{
 8006c92:	4604      	mov	r4, r0
  if (n2 > tda)
 8006c94:	d808      	bhi.n	8006ca8 <gsl_matrix_char_const_view_array_with_tda+0x1c>
    return view;
 8006c96:	2000      	movs	r0, #0
 8006c98:	e9c4 0004 	strd	r0, r0, [r4, #16]
 8006c9c:	e9c4 2300 	strd	r2, r3, [r4]
 8006ca0:	e9c4 5102 	strd	r5, r1, [r4, #8]
}
 8006ca4:	4620      	mov	r0, r4
 8006ca6:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006ca8:	4907      	ldr	r1, [pc, #28]	; (8006cc8 <gsl_matrix_char_const_view_array_with_tda+0x3c>)
 8006caa:	4808      	ldr	r0, [pc, #32]	; (8006ccc <gsl_matrix_char_const_view_array_with_tda+0x40>)
 8006cac:	2304      	movs	r3, #4
 8006cae:	2233      	movs	r2, #51	; 0x33
 8006cb0:	f7fb fdd6 	bl	8002860 <gsl_error>
 8006cb4:	2300      	movs	r3, #0
 8006cb6:	e9c4 3300 	strd	r3, r3, [r4]
 8006cba:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006cbe:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006cc2:	4620      	mov	r0, r4
 8006cc4:	bd38      	pop	{r3, r4, r5, pc}
 8006cc6:	bf00      	nop
 8006cc8:	080310b4 	.word	0x080310b4
 8006ccc:	080310c4 	.word	0x080310c4

08006cd0 <gsl_matrix_char_const_view_vector>:
{
 8006cd0:	b538      	push	{r3, r4, r5, lr}
  if (v->stride != 1)
 8006cd2:	684d      	ldr	r5, [r1, #4]
 8006cd4:	2d01      	cmp	r5, #1
{
 8006cd6:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006cd8:	d10f      	bne.n	8006cfa <gsl_matrix_char_const_view_vector+0x2a>
  else if (n1 * n2 > v->size)
 8006cda:	6808      	ldr	r0, [r1, #0]
 8006cdc:	fb03 f502 	mul.w	r5, r3, r2
 8006ce0:	4285      	cmp	r5, r0
 8006ce2:	d819      	bhi.n	8006d18 <gsl_matrix_char_const_view_vector+0x48>
    m.block = v->block;
 8006ce4:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006ce8:	6022      	str	r2, [r4, #0]
 8006cea:	2200      	movs	r2, #0
 8006cec:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006cf0:	e9c4 3301 	strd	r3, r3, [r4, #4]
 8006cf4:	6162      	str	r2, [r4, #20]
}
 8006cf6:	4620      	mov	r0, r4
 8006cf8:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006cfa:	490a      	ldr	r1, [pc, #40]	; (8006d24 <gsl_matrix_char_const_view_vector+0x54>)
 8006cfc:	480a      	ldr	r0, [pc, #40]	; (8006d28 <gsl_matrix_char_const_view_vector+0x58>)
 8006cfe:	2304      	movs	r3, #4
 8006d00:	224f      	movs	r2, #79	; 0x4f
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006d02:	f7fb fdad 	bl	8002860 <gsl_error>
 8006d06:	2300      	movs	r3, #0
 8006d08:	e9c4 3300 	strd	r3, r3, [r4]
 8006d0c:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006d10:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006d14:	4620      	mov	r0, r4
 8006d16:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006d18:	4902      	ldr	r1, [pc, #8]	; (8006d24 <gsl_matrix_char_const_view_vector+0x54>)
 8006d1a:	4804      	ldr	r0, [pc, #16]	; (8006d2c <gsl_matrix_char_const_view_vector+0x5c>)
 8006d1c:	2304      	movs	r3, #4
 8006d1e:	2254      	movs	r2, #84	; 0x54
 8006d20:	e7ef      	b.n	8006d02 <gsl_matrix_char_const_view_vector+0x32>
 8006d22:	bf00      	nop
 8006d24:	080310b4 	.word	0x080310b4
 8006d28:	080310ec 	.word	0x080310ec
 8006d2c:	0803110c 	.word	0x0803110c

08006d30 <gsl_matrix_char_const_view_vector_with_tda>:
{
 8006d30:	b570      	push	{r4, r5, r6, lr}
  if (v->stride != 1)
 8006d32:	684d      	ldr	r5, [r1, #4]
{
 8006d34:	9e04      	ldr	r6, [sp, #16]
  if (v->stride != 1)
 8006d36:	2d01      	cmp	r5, #1
{
 8006d38:	4604      	mov	r4, r0
  if (v->stride != 1)
 8006d3a:	d111      	bne.n	8006d60 <gsl_matrix_char_const_view_vector_with_tda+0x30>
  else if (n2 > tda)
 8006d3c:	42b3      	cmp	r3, r6
 8006d3e:	d823      	bhi.n	8006d88 <gsl_matrix_char_const_view_vector_with_tda+0x58>
  else if (n1 * tda > v->size)
 8006d40:	6808      	ldr	r0, [r1, #0]
 8006d42:	fb02 f506 	mul.w	r5, r2, r6
 8006d46:	4285      	cmp	r5, r0
 8006d48:	d819      	bhi.n	8006d7e <gsl_matrix_char_const_view_vector_with_tda+0x4e>
    m.block = v->block;
 8006d4a:	e9d1 0102 	ldrd	r0, r1, [r1, #8]
    return view;
 8006d4e:	6022      	str	r2, [r4, #0]
 8006d50:	2200      	movs	r2, #0
 8006d52:	e9c4 0103 	strd	r0, r1, [r4, #12]
 8006d56:	e9c4 3601 	strd	r3, r6, [r4, #4]
 8006d5a:	6162      	str	r2, [r4, #20]
}
 8006d5c:	4620      	mov	r0, r4
 8006d5e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("vector must have unit stride",
 8006d60:	490c      	ldr	r1, [pc, #48]	; (8006d94 <gsl_matrix_char_const_view_vector_with_tda+0x64>)
 8006d62:	480d      	ldr	r0, [pc, #52]	; (8006d98 <gsl_matrix_char_const_view_vector_with_tda+0x68>)
 8006d64:	2304      	movs	r3, #4
 8006d66:	2272      	movs	r2, #114	; 0x72
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006d68:	f7fb fd7a 	bl	8002860 <gsl_error>
 8006d6c:	2300      	movs	r3, #0
 8006d6e:	e9c4 3300 	strd	r3, r3, [r4]
 8006d72:	e9c4 3302 	strd	r3, r3, [r4, #8]
 8006d76:	e9c4 3304 	strd	r3, r3, [r4, #16]
}
 8006d7a:	4620      	mov	r0, r4
 8006d7c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("matrix size exceeds size of original", 
 8006d7e:	4905      	ldr	r1, [pc, #20]	; (8006d94 <gsl_matrix_char_const_view_vector_with_tda+0x64>)
 8006d80:	4806      	ldr	r0, [pc, #24]	; (8006d9c <gsl_matrix_char_const_view_vector_with_tda+0x6c>)
 8006d82:	2304      	movs	r3, #4
 8006d84:	227c      	movs	r2, #124	; 0x7c
 8006d86:	e7ef      	b.n	8006d68 <gsl_matrix_char_const_view_vector_with_tda+0x38>
      GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
 8006d88:	4902      	ldr	r1, [pc, #8]	; (8006d94 <gsl_matrix_char_const_view_vector_with_tda+0x64>)
 8006d8a:	4805      	ldr	r0, [pc, #20]	; (8006da0 <gsl_matrix_char_const_view_vector_with_tda+0x70>)
 8006d8c:	2304      	movs	r3, #4
 8006d8e:	2277      	movs	r2, #119	; 0x77
 8006d90:	e7ea      	b.n	8006d68 <gsl_matrix_char_const_view_vector_with_tda+0x38>
 8006d92:	bf00      	nop
 8006d94:	080310b4 	.word	0x080310b4
 8006d98:	080310ec 	.word	0x080310ec
 8006d9c:	0803110c 	.word	0x0803110c
 8006da0:	080310c4 	.word	0x080310c4

08006da4 <gsl_vector_complex_long_double_view_array>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

QUALIFIED_VIEW(_gsl_vector,view)
FUNCTION(gsl_vector, view_array) (QUALIFIER ATOMIC * base, size_t n)
{
 8006da4:	b430      	push	{r4, r5}
    v.stride = 1;
    v.block = 0;
    v.owner = 0;

    view.vector = v;
    return view;
 8006da6:	2501      	movs	r5, #1
 8006da8:	2400      	movs	r4, #0
 8006daa:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006dae:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006db2:	6002      	str	r2, [r0, #0]
  }
}
 8006db4:	bc30      	pop	{r4, r5}
 8006db6:	4770      	bx	lr

08006db8 <gsl_vector_complex_long_double_view_array_with_stride>:

QUALIFIED_VIEW(_gsl_vector,view)
FUNCTION(gsl_vector, view_array_with_stride) (QUALIFIER ATOMIC * base, 
                                              size_t stride,
                                              size_t n)
{
 8006db8:	b538      	push	{r3, r4, r5, lr}
 8006dba:	4604      	mov	r4, r0
  QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;

  if (stride == 0)
 8006dbc:	4615      	mov	r5, r2
 8006dbe:	b13a      	cbz	r2, 8006dd0 <gsl_vector_complex_long_double_view_array_with_stride+0x18>
    v.stride = stride;
    v.block = 0;
    v.owner = 0;

    view.vector = v;
    return view;
 8006dc0:	2200      	movs	r2, #0
 8006dc2:	e9c0 3500 	strd	r3, r5, [r0]
 8006dc6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006dca:	6102      	str	r2, [r0, #16]
  }
}
 8006dcc:	4620      	mov	r0, r4
 8006dce:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006dd0:	4906      	ldr	r1, [pc, #24]	; (8006dec <gsl_vector_complex_long_double_view_array_with_stride+0x34>)
 8006dd2:	4807      	ldr	r0, [pc, #28]	; (8006df0 <gsl_vector_complex_long_double_view_array_with_stride+0x38>)
 8006dd4:	2304      	movs	r3, #4
 8006dd6:	2230      	movs	r2, #48	; 0x30
 8006dd8:	f7fb fd42 	bl	8002860 <gsl_error>
 8006ddc:	e9c4 5500 	strd	r5, r5, [r4]
 8006de0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006de4:	6125      	str	r5, [r4, #16]
}
 8006de6:	4620      	mov	r0, r4
 8006de8:	bd38      	pop	{r3, r4, r5, pc}
 8006dea:	bf00      	nop
 8006dec:	080310b4 	.word	0x080310b4
 8006df0:	08031134 	.word	0x08031134

08006df4 <gsl_vector_complex_view_array>:
{
 8006df4:	b430      	push	{r4, r5}
    return view;
 8006df6:	2501      	movs	r5, #1
 8006df8:	2400      	movs	r4, #0
 8006dfa:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006dfe:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006e02:	6002      	str	r2, [r0, #0]
}
 8006e04:	bc30      	pop	{r4, r5}
 8006e06:	4770      	bx	lr

08006e08 <gsl_vector_complex_view_array_with_stride>:
{
 8006e08:	b538      	push	{r3, r4, r5, lr}
 8006e0a:	4604      	mov	r4, r0
  if (stride == 0)
 8006e0c:	4615      	mov	r5, r2
 8006e0e:	b13a      	cbz	r2, 8006e20 <gsl_vector_complex_view_array_with_stride+0x18>
    return view;
 8006e10:	2200      	movs	r2, #0
 8006e12:	e9c0 3500 	strd	r3, r5, [r0]
 8006e16:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006e1a:	6102      	str	r2, [r0, #16]
}
 8006e1c:	4620      	mov	r0, r4
 8006e1e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006e20:	4906      	ldr	r1, [pc, #24]	; (8006e3c <gsl_vector_complex_view_array_with_stride+0x34>)
 8006e22:	4807      	ldr	r0, [pc, #28]	; (8006e40 <gsl_vector_complex_view_array_with_stride+0x38>)
 8006e24:	2304      	movs	r3, #4
 8006e26:	2230      	movs	r2, #48	; 0x30
 8006e28:	f7fb fd1a 	bl	8002860 <gsl_error>
 8006e2c:	e9c4 5500 	strd	r5, r5, [r4]
 8006e30:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006e34:	6125      	str	r5, [r4, #16]
}
 8006e36:	4620      	mov	r0, r4
 8006e38:	bd38      	pop	{r3, r4, r5, pc}
 8006e3a:	bf00      	nop
 8006e3c:	080310b4 	.word	0x080310b4
 8006e40:	08031134 	.word	0x08031134

08006e44 <gsl_vector_complex_float_view_array>:
{
 8006e44:	b430      	push	{r4, r5}
    return view;
 8006e46:	2501      	movs	r5, #1
 8006e48:	2400      	movs	r4, #0
 8006e4a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006e4e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006e52:	6002      	str	r2, [r0, #0]
}
 8006e54:	bc30      	pop	{r4, r5}
 8006e56:	4770      	bx	lr

08006e58 <gsl_vector_complex_float_view_array_with_stride>:
{
 8006e58:	b538      	push	{r3, r4, r5, lr}
 8006e5a:	4604      	mov	r4, r0
  if (stride == 0)
 8006e5c:	4615      	mov	r5, r2
 8006e5e:	b13a      	cbz	r2, 8006e70 <gsl_vector_complex_float_view_array_with_stride+0x18>
    return view;
 8006e60:	2200      	movs	r2, #0
 8006e62:	e9c0 3500 	strd	r3, r5, [r0]
 8006e66:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006e6a:	6102      	str	r2, [r0, #16]
}
 8006e6c:	4620      	mov	r0, r4
 8006e6e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006e70:	4906      	ldr	r1, [pc, #24]	; (8006e8c <gsl_vector_complex_float_view_array_with_stride+0x34>)
 8006e72:	4807      	ldr	r0, [pc, #28]	; (8006e90 <gsl_vector_complex_float_view_array_with_stride+0x38>)
 8006e74:	2304      	movs	r3, #4
 8006e76:	2230      	movs	r2, #48	; 0x30
 8006e78:	f7fb fcf2 	bl	8002860 <gsl_error>
 8006e7c:	e9c4 5500 	strd	r5, r5, [r4]
 8006e80:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006e84:	6125      	str	r5, [r4, #16]
}
 8006e86:	4620      	mov	r0, r4
 8006e88:	bd38      	pop	{r3, r4, r5, pc}
 8006e8a:	bf00      	nop
 8006e8c:	080310b4 	.word	0x080310b4
 8006e90:	08031134 	.word	0x08031134

08006e94 <gsl_vector_long_double_view_array>:
{
 8006e94:	b430      	push	{r4, r5}
    return view;
 8006e96:	2501      	movs	r5, #1
 8006e98:	2400      	movs	r4, #0
 8006e9a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006e9e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006ea2:	6002      	str	r2, [r0, #0]
}
 8006ea4:	bc30      	pop	{r4, r5}
 8006ea6:	4770      	bx	lr

08006ea8 <gsl_vector_long_double_view_array_with_stride>:
{
 8006ea8:	b538      	push	{r3, r4, r5, lr}
 8006eaa:	4604      	mov	r4, r0
  if (stride == 0)
 8006eac:	4615      	mov	r5, r2
 8006eae:	b13a      	cbz	r2, 8006ec0 <gsl_vector_long_double_view_array_with_stride+0x18>
    return view;
 8006eb0:	2200      	movs	r2, #0
 8006eb2:	e9c0 3500 	strd	r3, r5, [r0]
 8006eb6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006eba:	6102      	str	r2, [r0, #16]
}
 8006ebc:	4620      	mov	r0, r4
 8006ebe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006ec0:	4906      	ldr	r1, [pc, #24]	; (8006edc <gsl_vector_long_double_view_array_with_stride+0x34>)
 8006ec2:	4807      	ldr	r0, [pc, #28]	; (8006ee0 <gsl_vector_long_double_view_array_with_stride+0x38>)
 8006ec4:	2304      	movs	r3, #4
 8006ec6:	2230      	movs	r2, #48	; 0x30
 8006ec8:	f7fb fcca 	bl	8002860 <gsl_error>
 8006ecc:	e9c4 5500 	strd	r5, r5, [r4]
 8006ed0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006ed4:	6125      	str	r5, [r4, #16]
}
 8006ed6:	4620      	mov	r0, r4
 8006ed8:	bd38      	pop	{r3, r4, r5, pc}
 8006eda:	bf00      	nop
 8006edc:	080310b4 	.word	0x080310b4
 8006ee0:	08031134 	.word	0x08031134

08006ee4 <gsl_vector_view_array>:
{
 8006ee4:	b430      	push	{r4, r5}
    return view;
 8006ee6:	2501      	movs	r5, #1
 8006ee8:	2400      	movs	r4, #0
 8006eea:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006eee:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006ef2:	6002      	str	r2, [r0, #0]
}
 8006ef4:	bc30      	pop	{r4, r5}
 8006ef6:	4770      	bx	lr

08006ef8 <gsl_vector_view_array_with_stride>:
{
 8006ef8:	b538      	push	{r3, r4, r5, lr}
 8006efa:	4604      	mov	r4, r0
  if (stride == 0)
 8006efc:	4615      	mov	r5, r2
 8006efe:	b13a      	cbz	r2, 8006f10 <gsl_vector_view_array_with_stride+0x18>
    return view;
 8006f00:	2200      	movs	r2, #0
 8006f02:	e9c0 3500 	strd	r3, r5, [r0]
 8006f06:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006f0a:	6102      	str	r2, [r0, #16]
}
 8006f0c:	4620      	mov	r0, r4
 8006f0e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006f10:	4906      	ldr	r1, [pc, #24]	; (8006f2c <gsl_vector_view_array_with_stride+0x34>)
 8006f12:	4807      	ldr	r0, [pc, #28]	; (8006f30 <gsl_vector_view_array_with_stride+0x38>)
 8006f14:	2304      	movs	r3, #4
 8006f16:	2230      	movs	r2, #48	; 0x30
 8006f18:	f7fb fca2 	bl	8002860 <gsl_error>
 8006f1c:	e9c4 5500 	strd	r5, r5, [r4]
 8006f20:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006f24:	6125      	str	r5, [r4, #16]
}
 8006f26:	4620      	mov	r0, r4
 8006f28:	bd38      	pop	{r3, r4, r5, pc}
 8006f2a:	bf00      	nop
 8006f2c:	080310b4 	.word	0x080310b4
 8006f30:	08031134 	.word	0x08031134

08006f34 <gsl_vector_float_view_array>:
{
 8006f34:	b430      	push	{r4, r5}
    return view;
 8006f36:	2501      	movs	r5, #1
 8006f38:	2400      	movs	r4, #0
 8006f3a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006f3e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006f42:	6002      	str	r2, [r0, #0]
}
 8006f44:	bc30      	pop	{r4, r5}
 8006f46:	4770      	bx	lr

08006f48 <gsl_vector_float_view_array_with_stride>:
{
 8006f48:	b538      	push	{r3, r4, r5, lr}
 8006f4a:	4604      	mov	r4, r0
  if (stride == 0)
 8006f4c:	4615      	mov	r5, r2
 8006f4e:	b13a      	cbz	r2, 8006f60 <gsl_vector_float_view_array_with_stride+0x18>
    return view;
 8006f50:	2200      	movs	r2, #0
 8006f52:	e9c0 3500 	strd	r3, r5, [r0]
 8006f56:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006f5a:	6102      	str	r2, [r0, #16]
}
 8006f5c:	4620      	mov	r0, r4
 8006f5e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006f60:	4906      	ldr	r1, [pc, #24]	; (8006f7c <gsl_vector_float_view_array_with_stride+0x34>)
 8006f62:	4807      	ldr	r0, [pc, #28]	; (8006f80 <gsl_vector_float_view_array_with_stride+0x38>)
 8006f64:	2304      	movs	r3, #4
 8006f66:	2230      	movs	r2, #48	; 0x30
 8006f68:	f7fb fc7a 	bl	8002860 <gsl_error>
 8006f6c:	e9c4 5500 	strd	r5, r5, [r4]
 8006f70:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006f74:	6125      	str	r5, [r4, #16]
}
 8006f76:	4620      	mov	r0, r4
 8006f78:	bd38      	pop	{r3, r4, r5, pc}
 8006f7a:	bf00      	nop
 8006f7c:	080310b4 	.word	0x080310b4
 8006f80:	08031134 	.word	0x08031134

08006f84 <gsl_vector_ulong_view_array>:
{
 8006f84:	b430      	push	{r4, r5}
    return view;
 8006f86:	2501      	movs	r5, #1
 8006f88:	2400      	movs	r4, #0
 8006f8a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006f8e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006f92:	6002      	str	r2, [r0, #0]
}
 8006f94:	bc30      	pop	{r4, r5}
 8006f96:	4770      	bx	lr

08006f98 <gsl_vector_ulong_view_array_with_stride>:
{
 8006f98:	b538      	push	{r3, r4, r5, lr}
 8006f9a:	4604      	mov	r4, r0
  if (stride == 0)
 8006f9c:	4615      	mov	r5, r2
 8006f9e:	b13a      	cbz	r2, 8006fb0 <gsl_vector_ulong_view_array_with_stride+0x18>
    return view;
 8006fa0:	2200      	movs	r2, #0
 8006fa2:	e9c0 3500 	strd	r3, r5, [r0]
 8006fa6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006faa:	6102      	str	r2, [r0, #16]
}
 8006fac:	4620      	mov	r0, r4
 8006fae:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006fb0:	4906      	ldr	r1, [pc, #24]	; (8006fcc <gsl_vector_ulong_view_array_with_stride+0x34>)
 8006fb2:	4807      	ldr	r0, [pc, #28]	; (8006fd0 <gsl_vector_ulong_view_array_with_stride+0x38>)
 8006fb4:	2304      	movs	r3, #4
 8006fb6:	2230      	movs	r2, #48	; 0x30
 8006fb8:	f7fb fc52 	bl	8002860 <gsl_error>
 8006fbc:	e9c4 5500 	strd	r5, r5, [r4]
 8006fc0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006fc4:	6125      	str	r5, [r4, #16]
}
 8006fc6:	4620      	mov	r0, r4
 8006fc8:	bd38      	pop	{r3, r4, r5, pc}
 8006fca:	bf00      	nop
 8006fcc:	080310b4 	.word	0x080310b4
 8006fd0:	08031134 	.word	0x08031134

08006fd4 <gsl_vector_long_view_array>:
{
 8006fd4:	b430      	push	{r4, r5}
    return view;
 8006fd6:	2501      	movs	r5, #1
 8006fd8:	2400      	movs	r4, #0
 8006fda:	e9c0 5101 	strd	r5, r1, [r0, #4]
 8006fde:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006fe2:	6002      	str	r2, [r0, #0]
}
 8006fe4:	bc30      	pop	{r4, r5}
 8006fe6:	4770      	bx	lr

08006fe8 <gsl_vector_long_view_array_with_stride>:
{
 8006fe8:	b538      	push	{r3, r4, r5, lr}
 8006fea:	4604      	mov	r4, r0
  if (stride == 0)
 8006fec:	4615      	mov	r5, r2
 8006fee:	b13a      	cbz	r2, 8007000 <gsl_vector_long_view_array_with_stride+0x18>
    return view;
 8006ff0:	2200      	movs	r2, #0
 8006ff2:	e9c0 3500 	strd	r3, r5, [r0]
 8006ff6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8006ffa:	6102      	str	r2, [r0, #16]
}
 8006ffc:	4620      	mov	r0, r4
 8006ffe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007000:	4906      	ldr	r1, [pc, #24]	; (800701c <gsl_vector_long_view_array_with_stride+0x34>)
 8007002:	4807      	ldr	r0, [pc, #28]	; (8007020 <gsl_vector_long_view_array_with_stride+0x38>)
 8007004:	2304      	movs	r3, #4
 8007006:	2230      	movs	r2, #48	; 0x30
 8007008:	f7fb fc2a 	bl	8002860 <gsl_error>
 800700c:	e9c4 5500 	strd	r5, r5, [r4]
 8007010:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007014:	6125      	str	r5, [r4, #16]
}
 8007016:	4620      	mov	r0, r4
 8007018:	bd38      	pop	{r3, r4, r5, pc}
 800701a:	bf00      	nop
 800701c:	080310b4 	.word	0x080310b4
 8007020:	08031134 	.word	0x08031134

08007024 <gsl_vector_uint_view_array>:
{
 8007024:	b430      	push	{r4, r5}
    return view;
 8007026:	2501      	movs	r5, #1
 8007028:	2400      	movs	r4, #0
 800702a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800702e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007032:	6002      	str	r2, [r0, #0]
}
 8007034:	bc30      	pop	{r4, r5}
 8007036:	4770      	bx	lr

08007038 <gsl_vector_uint_view_array_with_stride>:
{
 8007038:	b538      	push	{r3, r4, r5, lr}
 800703a:	4604      	mov	r4, r0
  if (stride == 0)
 800703c:	4615      	mov	r5, r2
 800703e:	b13a      	cbz	r2, 8007050 <gsl_vector_uint_view_array_with_stride+0x18>
    return view;
 8007040:	2200      	movs	r2, #0
 8007042:	e9c0 3500 	strd	r3, r5, [r0]
 8007046:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800704a:	6102      	str	r2, [r0, #16]
}
 800704c:	4620      	mov	r0, r4
 800704e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007050:	4906      	ldr	r1, [pc, #24]	; (800706c <gsl_vector_uint_view_array_with_stride+0x34>)
 8007052:	4807      	ldr	r0, [pc, #28]	; (8007070 <gsl_vector_uint_view_array_with_stride+0x38>)
 8007054:	2304      	movs	r3, #4
 8007056:	2230      	movs	r2, #48	; 0x30
 8007058:	f7fb fc02 	bl	8002860 <gsl_error>
 800705c:	e9c4 5500 	strd	r5, r5, [r4]
 8007060:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007064:	6125      	str	r5, [r4, #16]
}
 8007066:	4620      	mov	r0, r4
 8007068:	bd38      	pop	{r3, r4, r5, pc}
 800706a:	bf00      	nop
 800706c:	080310b4 	.word	0x080310b4
 8007070:	08031134 	.word	0x08031134

08007074 <gsl_vector_int_view_array>:
{
 8007074:	b430      	push	{r4, r5}
    return view;
 8007076:	2501      	movs	r5, #1
 8007078:	2400      	movs	r4, #0
 800707a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800707e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007082:	6002      	str	r2, [r0, #0]
}
 8007084:	bc30      	pop	{r4, r5}
 8007086:	4770      	bx	lr

08007088 <gsl_vector_int_view_array_with_stride>:
{
 8007088:	b538      	push	{r3, r4, r5, lr}
 800708a:	4604      	mov	r4, r0
  if (stride == 0)
 800708c:	4615      	mov	r5, r2
 800708e:	b13a      	cbz	r2, 80070a0 <gsl_vector_int_view_array_with_stride+0x18>
    return view;
 8007090:	2200      	movs	r2, #0
 8007092:	e9c0 3500 	strd	r3, r5, [r0]
 8007096:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800709a:	6102      	str	r2, [r0, #16]
}
 800709c:	4620      	mov	r0, r4
 800709e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80070a0:	4906      	ldr	r1, [pc, #24]	; (80070bc <gsl_vector_int_view_array_with_stride+0x34>)
 80070a2:	4807      	ldr	r0, [pc, #28]	; (80070c0 <gsl_vector_int_view_array_with_stride+0x38>)
 80070a4:	2304      	movs	r3, #4
 80070a6:	2230      	movs	r2, #48	; 0x30
 80070a8:	f7fb fbda 	bl	8002860 <gsl_error>
 80070ac:	e9c4 5500 	strd	r5, r5, [r4]
 80070b0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80070b4:	6125      	str	r5, [r4, #16]
}
 80070b6:	4620      	mov	r0, r4
 80070b8:	bd38      	pop	{r3, r4, r5, pc}
 80070ba:	bf00      	nop
 80070bc:	080310b4 	.word	0x080310b4
 80070c0:	08031134 	.word	0x08031134

080070c4 <gsl_vector_ushort_view_array>:
{
 80070c4:	b430      	push	{r4, r5}
    return view;
 80070c6:	2501      	movs	r5, #1
 80070c8:	2400      	movs	r4, #0
 80070ca:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80070ce:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80070d2:	6002      	str	r2, [r0, #0]
}
 80070d4:	bc30      	pop	{r4, r5}
 80070d6:	4770      	bx	lr

080070d8 <gsl_vector_ushort_view_array_with_stride>:
{
 80070d8:	b538      	push	{r3, r4, r5, lr}
 80070da:	4604      	mov	r4, r0
  if (stride == 0)
 80070dc:	4615      	mov	r5, r2
 80070de:	b13a      	cbz	r2, 80070f0 <gsl_vector_ushort_view_array_with_stride+0x18>
    return view;
 80070e0:	2200      	movs	r2, #0
 80070e2:	e9c0 3500 	strd	r3, r5, [r0]
 80070e6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80070ea:	6102      	str	r2, [r0, #16]
}
 80070ec:	4620      	mov	r0, r4
 80070ee:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80070f0:	4906      	ldr	r1, [pc, #24]	; (800710c <gsl_vector_ushort_view_array_with_stride+0x34>)
 80070f2:	4807      	ldr	r0, [pc, #28]	; (8007110 <gsl_vector_ushort_view_array_with_stride+0x38>)
 80070f4:	2304      	movs	r3, #4
 80070f6:	2230      	movs	r2, #48	; 0x30
 80070f8:	f7fb fbb2 	bl	8002860 <gsl_error>
 80070fc:	e9c4 5500 	strd	r5, r5, [r4]
 8007100:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007104:	6125      	str	r5, [r4, #16]
}
 8007106:	4620      	mov	r0, r4
 8007108:	bd38      	pop	{r3, r4, r5, pc}
 800710a:	bf00      	nop
 800710c:	080310b4 	.word	0x080310b4
 8007110:	08031134 	.word	0x08031134

08007114 <gsl_vector_short_view_array>:
{
 8007114:	b430      	push	{r4, r5}
    return view;
 8007116:	2501      	movs	r5, #1
 8007118:	2400      	movs	r4, #0
 800711a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800711e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007122:	6002      	str	r2, [r0, #0]
}
 8007124:	bc30      	pop	{r4, r5}
 8007126:	4770      	bx	lr

08007128 <gsl_vector_short_view_array_with_stride>:
{
 8007128:	b538      	push	{r3, r4, r5, lr}
 800712a:	4604      	mov	r4, r0
  if (stride == 0)
 800712c:	4615      	mov	r5, r2
 800712e:	b13a      	cbz	r2, 8007140 <gsl_vector_short_view_array_with_stride+0x18>
    return view;
 8007130:	2200      	movs	r2, #0
 8007132:	e9c0 3500 	strd	r3, r5, [r0]
 8007136:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800713a:	6102      	str	r2, [r0, #16]
}
 800713c:	4620      	mov	r0, r4
 800713e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007140:	4906      	ldr	r1, [pc, #24]	; (800715c <gsl_vector_short_view_array_with_stride+0x34>)
 8007142:	4807      	ldr	r0, [pc, #28]	; (8007160 <gsl_vector_short_view_array_with_stride+0x38>)
 8007144:	2304      	movs	r3, #4
 8007146:	2230      	movs	r2, #48	; 0x30
 8007148:	f7fb fb8a 	bl	8002860 <gsl_error>
 800714c:	e9c4 5500 	strd	r5, r5, [r4]
 8007150:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007154:	6125      	str	r5, [r4, #16]
}
 8007156:	4620      	mov	r0, r4
 8007158:	bd38      	pop	{r3, r4, r5, pc}
 800715a:	bf00      	nop
 800715c:	080310b4 	.word	0x080310b4
 8007160:	08031134 	.word	0x08031134

08007164 <gsl_vector_uchar_view_array>:
{
 8007164:	b430      	push	{r4, r5}
    return view;
 8007166:	2501      	movs	r5, #1
 8007168:	2400      	movs	r4, #0
 800716a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800716e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007172:	6002      	str	r2, [r0, #0]
}
 8007174:	bc30      	pop	{r4, r5}
 8007176:	4770      	bx	lr

08007178 <gsl_vector_uchar_view_array_with_stride>:
{
 8007178:	b538      	push	{r3, r4, r5, lr}
 800717a:	4604      	mov	r4, r0
  if (stride == 0)
 800717c:	4615      	mov	r5, r2
 800717e:	b13a      	cbz	r2, 8007190 <gsl_vector_uchar_view_array_with_stride+0x18>
    return view;
 8007180:	2200      	movs	r2, #0
 8007182:	e9c0 3500 	strd	r3, r5, [r0]
 8007186:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800718a:	6102      	str	r2, [r0, #16]
}
 800718c:	4620      	mov	r0, r4
 800718e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007190:	4906      	ldr	r1, [pc, #24]	; (80071ac <gsl_vector_uchar_view_array_with_stride+0x34>)
 8007192:	4807      	ldr	r0, [pc, #28]	; (80071b0 <gsl_vector_uchar_view_array_with_stride+0x38>)
 8007194:	2304      	movs	r3, #4
 8007196:	2230      	movs	r2, #48	; 0x30
 8007198:	f7fb fb62 	bl	8002860 <gsl_error>
 800719c:	e9c4 5500 	strd	r5, r5, [r4]
 80071a0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80071a4:	6125      	str	r5, [r4, #16]
}
 80071a6:	4620      	mov	r0, r4
 80071a8:	bd38      	pop	{r3, r4, r5, pc}
 80071aa:	bf00      	nop
 80071ac:	080310b4 	.word	0x080310b4
 80071b0:	08031134 	.word	0x08031134

080071b4 <gsl_vector_char_view_array>:
{
 80071b4:	b430      	push	{r4, r5}
    return view;
 80071b6:	2501      	movs	r5, #1
 80071b8:	2400      	movs	r4, #0
 80071ba:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80071be:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80071c2:	6002      	str	r2, [r0, #0]
}
 80071c4:	bc30      	pop	{r4, r5}
 80071c6:	4770      	bx	lr

080071c8 <gsl_vector_char_view_array_with_stride>:
{
 80071c8:	b538      	push	{r3, r4, r5, lr}
 80071ca:	4604      	mov	r4, r0
  if (stride == 0)
 80071cc:	4615      	mov	r5, r2
 80071ce:	b13a      	cbz	r2, 80071e0 <gsl_vector_char_view_array_with_stride+0x18>
    return view;
 80071d0:	2200      	movs	r2, #0
 80071d2:	e9c0 3500 	strd	r3, r5, [r0]
 80071d6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80071da:	6102      	str	r2, [r0, #16]
}
 80071dc:	4620      	mov	r0, r4
 80071de:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80071e0:	4906      	ldr	r1, [pc, #24]	; (80071fc <gsl_vector_char_view_array_with_stride+0x34>)
 80071e2:	4807      	ldr	r0, [pc, #28]	; (8007200 <gsl_vector_char_view_array_with_stride+0x38>)
 80071e4:	2304      	movs	r3, #4
 80071e6:	2230      	movs	r2, #48	; 0x30
 80071e8:	f7fb fb3a 	bl	8002860 <gsl_error>
 80071ec:	e9c4 5500 	strd	r5, r5, [r4]
 80071f0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80071f4:	6125      	str	r5, [r4, #16]
}
 80071f6:	4620      	mov	r0, r4
 80071f8:	bd38      	pop	{r3, r4, r5, pc}
 80071fa:	bf00      	nop
 80071fc:	080310b4 	.word	0x080310b4
 8007200:	08031134 	.word	0x08031134

08007204 <gsl_vector_complex_long_double_const_view_array>:
{
 8007204:	b430      	push	{r4, r5}
    return view;
 8007206:	2501      	movs	r5, #1
 8007208:	2400      	movs	r4, #0
 800720a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800720e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007212:	6002      	str	r2, [r0, #0]
}
 8007214:	bc30      	pop	{r4, r5}
 8007216:	4770      	bx	lr

08007218 <gsl_vector_complex_long_double_const_view_array_with_stride>:
{
 8007218:	b538      	push	{r3, r4, r5, lr}
 800721a:	4604      	mov	r4, r0
  if (stride == 0)
 800721c:	4615      	mov	r5, r2
 800721e:	b13a      	cbz	r2, 8007230 <gsl_vector_complex_long_double_const_view_array_with_stride+0x18>
    return view;
 8007220:	2200      	movs	r2, #0
 8007222:	e9c0 3500 	strd	r3, r5, [r0]
 8007226:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800722a:	6102      	str	r2, [r0, #16]
}
 800722c:	4620      	mov	r0, r4
 800722e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007230:	4906      	ldr	r1, [pc, #24]	; (800724c <gsl_vector_complex_long_double_const_view_array_with_stride+0x34>)
 8007232:	4807      	ldr	r0, [pc, #28]	; (8007250 <gsl_vector_complex_long_double_const_view_array_with_stride+0x38>)
 8007234:	2304      	movs	r3, #4
 8007236:	2230      	movs	r2, #48	; 0x30
 8007238:	f7fb fb12 	bl	8002860 <gsl_error>
 800723c:	e9c4 5500 	strd	r5, r5, [r4]
 8007240:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007244:	6125      	str	r5, [r4, #16]
}
 8007246:	4620      	mov	r0, r4
 8007248:	bd38      	pop	{r3, r4, r5, pc}
 800724a:	bf00      	nop
 800724c:	080310b4 	.word	0x080310b4
 8007250:	08031134 	.word	0x08031134

08007254 <gsl_vector_complex_const_view_array>:
{
 8007254:	b430      	push	{r4, r5}
    return view;
 8007256:	2501      	movs	r5, #1
 8007258:	2400      	movs	r4, #0
 800725a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800725e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007262:	6002      	str	r2, [r0, #0]
}
 8007264:	bc30      	pop	{r4, r5}
 8007266:	4770      	bx	lr

08007268 <gsl_vector_complex_const_view_array_with_stride>:
{
 8007268:	b538      	push	{r3, r4, r5, lr}
 800726a:	4604      	mov	r4, r0
  if (stride == 0)
 800726c:	4615      	mov	r5, r2
 800726e:	b13a      	cbz	r2, 8007280 <gsl_vector_complex_const_view_array_with_stride+0x18>
    return view;
 8007270:	2200      	movs	r2, #0
 8007272:	e9c0 3500 	strd	r3, r5, [r0]
 8007276:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800727a:	6102      	str	r2, [r0, #16]
}
 800727c:	4620      	mov	r0, r4
 800727e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007280:	4906      	ldr	r1, [pc, #24]	; (800729c <gsl_vector_complex_const_view_array_with_stride+0x34>)
 8007282:	4807      	ldr	r0, [pc, #28]	; (80072a0 <gsl_vector_complex_const_view_array_with_stride+0x38>)
 8007284:	2304      	movs	r3, #4
 8007286:	2230      	movs	r2, #48	; 0x30
 8007288:	f7fb faea 	bl	8002860 <gsl_error>
 800728c:	e9c4 5500 	strd	r5, r5, [r4]
 8007290:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007294:	6125      	str	r5, [r4, #16]
}
 8007296:	4620      	mov	r0, r4
 8007298:	bd38      	pop	{r3, r4, r5, pc}
 800729a:	bf00      	nop
 800729c:	080310b4 	.word	0x080310b4
 80072a0:	08031134 	.word	0x08031134

080072a4 <gsl_vector_complex_float_const_view_array>:
{
 80072a4:	b430      	push	{r4, r5}
    return view;
 80072a6:	2501      	movs	r5, #1
 80072a8:	2400      	movs	r4, #0
 80072aa:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80072ae:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80072b2:	6002      	str	r2, [r0, #0]
}
 80072b4:	bc30      	pop	{r4, r5}
 80072b6:	4770      	bx	lr

080072b8 <gsl_vector_complex_float_const_view_array_with_stride>:
{
 80072b8:	b538      	push	{r3, r4, r5, lr}
 80072ba:	4604      	mov	r4, r0
  if (stride == 0)
 80072bc:	4615      	mov	r5, r2
 80072be:	b13a      	cbz	r2, 80072d0 <gsl_vector_complex_float_const_view_array_with_stride+0x18>
    return view;
 80072c0:	2200      	movs	r2, #0
 80072c2:	e9c0 3500 	strd	r3, r5, [r0]
 80072c6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80072ca:	6102      	str	r2, [r0, #16]
}
 80072cc:	4620      	mov	r0, r4
 80072ce:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80072d0:	4906      	ldr	r1, [pc, #24]	; (80072ec <gsl_vector_complex_float_const_view_array_with_stride+0x34>)
 80072d2:	4807      	ldr	r0, [pc, #28]	; (80072f0 <gsl_vector_complex_float_const_view_array_with_stride+0x38>)
 80072d4:	2304      	movs	r3, #4
 80072d6:	2230      	movs	r2, #48	; 0x30
 80072d8:	f7fb fac2 	bl	8002860 <gsl_error>
 80072dc:	e9c4 5500 	strd	r5, r5, [r4]
 80072e0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80072e4:	6125      	str	r5, [r4, #16]
}
 80072e6:	4620      	mov	r0, r4
 80072e8:	bd38      	pop	{r3, r4, r5, pc}
 80072ea:	bf00      	nop
 80072ec:	080310b4 	.word	0x080310b4
 80072f0:	08031134 	.word	0x08031134

080072f4 <gsl_vector_long_double_const_view_array>:
{
 80072f4:	b430      	push	{r4, r5}
    return view;
 80072f6:	2501      	movs	r5, #1
 80072f8:	2400      	movs	r4, #0
 80072fa:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80072fe:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007302:	6002      	str	r2, [r0, #0]
}
 8007304:	bc30      	pop	{r4, r5}
 8007306:	4770      	bx	lr

08007308 <gsl_vector_long_double_const_view_array_with_stride>:
{
 8007308:	b538      	push	{r3, r4, r5, lr}
 800730a:	4604      	mov	r4, r0
  if (stride == 0)
 800730c:	4615      	mov	r5, r2
 800730e:	b13a      	cbz	r2, 8007320 <gsl_vector_long_double_const_view_array_with_stride+0x18>
    return view;
 8007310:	2200      	movs	r2, #0
 8007312:	e9c0 3500 	strd	r3, r5, [r0]
 8007316:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800731a:	6102      	str	r2, [r0, #16]
}
 800731c:	4620      	mov	r0, r4
 800731e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007320:	4906      	ldr	r1, [pc, #24]	; (800733c <gsl_vector_long_double_const_view_array_with_stride+0x34>)
 8007322:	4807      	ldr	r0, [pc, #28]	; (8007340 <gsl_vector_long_double_const_view_array_with_stride+0x38>)
 8007324:	2304      	movs	r3, #4
 8007326:	2230      	movs	r2, #48	; 0x30
 8007328:	f7fb fa9a 	bl	8002860 <gsl_error>
 800732c:	e9c4 5500 	strd	r5, r5, [r4]
 8007330:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007334:	6125      	str	r5, [r4, #16]
}
 8007336:	4620      	mov	r0, r4
 8007338:	bd38      	pop	{r3, r4, r5, pc}
 800733a:	bf00      	nop
 800733c:	080310b4 	.word	0x080310b4
 8007340:	08031134 	.word	0x08031134

08007344 <gsl_vector_const_view_array>:
{
 8007344:	b430      	push	{r4, r5}
    return view;
 8007346:	2501      	movs	r5, #1
 8007348:	2400      	movs	r4, #0
 800734a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800734e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007352:	6002      	str	r2, [r0, #0]
}
 8007354:	bc30      	pop	{r4, r5}
 8007356:	4770      	bx	lr

08007358 <gsl_vector_const_view_array_with_stride>:
{
 8007358:	b538      	push	{r3, r4, r5, lr}
 800735a:	4604      	mov	r4, r0
  if (stride == 0)
 800735c:	4615      	mov	r5, r2
 800735e:	b13a      	cbz	r2, 8007370 <gsl_vector_const_view_array_with_stride+0x18>
    return view;
 8007360:	2200      	movs	r2, #0
 8007362:	e9c0 3500 	strd	r3, r5, [r0]
 8007366:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800736a:	6102      	str	r2, [r0, #16]
}
 800736c:	4620      	mov	r0, r4
 800736e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007370:	4906      	ldr	r1, [pc, #24]	; (800738c <gsl_vector_const_view_array_with_stride+0x34>)
 8007372:	4807      	ldr	r0, [pc, #28]	; (8007390 <gsl_vector_const_view_array_with_stride+0x38>)
 8007374:	2304      	movs	r3, #4
 8007376:	2230      	movs	r2, #48	; 0x30
 8007378:	f7fb fa72 	bl	8002860 <gsl_error>
 800737c:	e9c4 5500 	strd	r5, r5, [r4]
 8007380:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007384:	6125      	str	r5, [r4, #16]
}
 8007386:	4620      	mov	r0, r4
 8007388:	bd38      	pop	{r3, r4, r5, pc}
 800738a:	bf00      	nop
 800738c:	080310b4 	.word	0x080310b4
 8007390:	08031134 	.word	0x08031134

08007394 <gsl_vector_float_const_view_array>:
{
 8007394:	b430      	push	{r4, r5}
    return view;
 8007396:	2501      	movs	r5, #1
 8007398:	2400      	movs	r4, #0
 800739a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800739e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80073a2:	6002      	str	r2, [r0, #0]
}
 80073a4:	bc30      	pop	{r4, r5}
 80073a6:	4770      	bx	lr

080073a8 <gsl_vector_float_const_view_array_with_stride>:
{
 80073a8:	b538      	push	{r3, r4, r5, lr}
 80073aa:	4604      	mov	r4, r0
  if (stride == 0)
 80073ac:	4615      	mov	r5, r2
 80073ae:	b13a      	cbz	r2, 80073c0 <gsl_vector_float_const_view_array_with_stride+0x18>
    return view;
 80073b0:	2200      	movs	r2, #0
 80073b2:	e9c0 3500 	strd	r3, r5, [r0]
 80073b6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80073ba:	6102      	str	r2, [r0, #16]
}
 80073bc:	4620      	mov	r0, r4
 80073be:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80073c0:	4906      	ldr	r1, [pc, #24]	; (80073dc <gsl_vector_float_const_view_array_with_stride+0x34>)
 80073c2:	4807      	ldr	r0, [pc, #28]	; (80073e0 <gsl_vector_float_const_view_array_with_stride+0x38>)
 80073c4:	2304      	movs	r3, #4
 80073c6:	2230      	movs	r2, #48	; 0x30
 80073c8:	f7fb fa4a 	bl	8002860 <gsl_error>
 80073cc:	e9c4 5500 	strd	r5, r5, [r4]
 80073d0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80073d4:	6125      	str	r5, [r4, #16]
}
 80073d6:	4620      	mov	r0, r4
 80073d8:	bd38      	pop	{r3, r4, r5, pc}
 80073da:	bf00      	nop
 80073dc:	080310b4 	.word	0x080310b4
 80073e0:	08031134 	.word	0x08031134

080073e4 <gsl_vector_ulong_const_view_array>:
{
 80073e4:	b430      	push	{r4, r5}
    return view;
 80073e6:	2501      	movs	r5, #1
 80073e8:	2400      	movs	r4, #0
 80073ea:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80073ee:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80073f2:	6002      	str	r2, [r0, #0]
}
 80073f4:	bc30      	pop	{r4, r5}
 80073f6:	4770      	bx	lr

080073f8 <gsl_vector_ulong_const_view_array_with_stride>:
{
 80073f8:	b538      	push	{r3, r4, r5, lr}
 80073fa:	4604      	mov	r4, r0
  if (stride == 0)
 80073fc:	4615      	mov	r5, r2
 80073fe:	b13a      	cbz	r2, 8007410 <gsl_vector_ulong_const_view_array_with_stride+0x18>
    return view;
 8007400:	2200      	movs	r2, #0
 8007402:	e9c0 3500 	strd	r3, r5, [r0]
 8007406:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800740a:	6102      	str	r2, [r0, #16]
}
 800740c:	4620      	mov	r0, r4
 800740e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007410:	4906      	ldr	r1, [pc, #24]	; (800742c <gsl_vector_ulong_const_view_array_with_stride+0x34>)
 8007412:	4807      	ldr	r0, [pc, #28]	; (8007430 <gsl_vector_ulong_const_view_array_with_stride+0x38>)
 8007414:	2304      	movs	r3, #4
 8007416:	2230      	movs	r2, #48	; 0x30
 8007418:	f7fb fa22 	bl	8002860 <gsl_error>
 800741c:	e9c4 5500 	strd	r5, r5, [r4]
 8007420:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007424:	6125      	str	r5, [r4, #16]
}
 8007426:	4620      	mov	r0, r4
 8007428:	bd38      	pop	{r3, r4, r5, pc}
 800742a:	bf00      	nop
 800742c:	080310b4 	.word	0x080310b4
 8007430:	08031134 	.word	0x08031134

08007434 <gsl_vector_long_const_view_array>:
{
 8007434:	b430      	push	{r4, r5}
    return view;
 8007436:	2501      	movs	r5, #1
 8007438:	2400      	movs	r4, #0
 800743a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800743e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007442:	6002      	str	r2, [r0, #0]
}
 8007444:	bc30      	pop	{r4, r5}
 8007446:	4770      	bx	lr

08007448 <gsl_vector_long_const_view_array_with_stride>:
{
 8007448:	b538      	push	{r3, r4, r5, lr}
 800744a:	4604      	mov	r4, r0
  if (stride == 0)
 800744c:	4615      	mov	r5, r2
 800744e:	b13a      	cbz	r2, 8007460 <gsl_vector_long_const_view_array_with_stride+0x18>
    return view;
 8007450:	2200      	movs	r2, #0
 8007452:	e9c0 3500 	strd	r3, r5, [r0]
 8007456:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800745a:	6102      	str	r2, [r0, #16]
}
 800745c:	4620      	mov	r0, r4
 800745e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007460:	4906      	ldr	r1, [pc, #24]	; (800747c <gsl_vector_long_const_view_array_with_stride+0x34>)
 8007462:	4807      	ldr	r0, [pc, #28]	; (8007480 <gsl_vector_long_const_view_array_with_stride+0x38>)
 8007464:	2304      	movs	r3, #4
 8007466:	2230      	movs	r2, #48	; 0x30
 8007468:	f7fb f9fa 	bl	8002860 <gsl_error>
 800746c:	e9c4 5500 	strd	r5, r5, [r4]
 8007470:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007474:	6125      	str	r5, [r4, #16]
}
 8007476:	4620      	mov	r0, r4
 8007478:	bd38      	pop	{r3, r4, r5, pc}
 800747a:	bf00      	nop
 800747c:	080310b4 	.word	0x080310b4
 8007480:	08031134 	.word	0x08031134

08007484 <gsl_vector_uint_const_view_array>:
{
 8007484:	b430      	push	{r4, r5}
    return view;
 8007486:	2501      	movs	r5, #1
 8007488:	2400      	movs	r4, #0
 800748a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800748e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007492:	6002      	str	r2, [r0, #0]
}
 8007494:	bc30      	pop	{r4, r5}
 8007496:	4770      	bx	lr

08007498 <gsl_vector_uint_const_view_array_with_stride>:
{
 8007498:	b538      	push	{r3, r4, r5, lr}
 800749a:	4604      	mov	r4, r0
  if (stride == 0)
 800749c:	4615      	mov	r5, r2
 800749e:	b13a      	cbz	r2, 80074b0 <gsl_vector_uint_const_view_array_with_stride+0x18>
    return view;
 80074a0:	2200      	movs	r2, #0
 80074a2:	e9c0 3500 	strd	r3, r5, [r0]
 80074a6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80074aa:	6102      	str	r2, [r0, #16]
}
 80074ac:	4620      	mov	r0, r4
 80074ae:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80074b0:	4906      	ldr	r1, [pc, #24]	; (80074cc <gsl_vector_uint_const_view_array_with_stride+0x34>)
 80074b2:	4807      	ldr	r0, [pc, #28]	; (80074d0 <gsl_vector_uint_const_view_array_with_stride+0x38>)
 80074b4:	2304      	movs	r3, #4
 80074b6:	2230      	movs	r2, #48	; 0x30
 80074b8:	f7fb f9d2 	bl	8002860 <gsl_error>
 80074bc:	e9c4 5500 	strd	r5, r5, [r4]
 80074c0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80074c4:	6125      	str	r5, [r4, #16]
}
 80074c6:	4620      	mov	r0, r4
 80074c8:	bd38      	pop	{r3, r4, r5, pc}
 80074ca:	bf00      	nop
 80074cc:	080310b4 	.word	0x080310b4
 80074d0:	08031134 	.word	0x08031134

080074d4 <gsl_vector_int_const_view_array>:
{
 80074d4:	b430      	push	{r4, r5}
    return view;
 80074d6:	2501      	movs	r5, #1
 80074d8:	2400      	movs	r4, #0
 80074da:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80074de:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80074e2:	6002      	str	r2, [r0, #0]
}
 80074e4:	bc30      	pop	{r4, r5}
 80074e6:	4770      	bx	lr

080074e8 <gsl_vector_int_const_view_array_with_stride>:
{
 80074e8:	b538      	push	{r3, r4, r5, lr}
 80074ea:	4604      	mov	r4, r0
  if (stride == 0)
 80074ec:	4615      	mov	r5, r2
 80074ee:	b13a      	cbz	r2, 8007500 <gsl_vector_int_const_view_array_with_stride+0x18>
    return view;
 80074f0:	2200      	movs	r2, #0
 80074f2:	e9c0 3500 	strd	r3, r5, [r0]
 80074f6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80074fa:	6102      	str	r2, [r0, #16]
}
 80074fc:	4620      	mov	r0, r4
 80074fe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007500:	4906      	ldr	r1, [pc, #24]	; (800751c <gsl_vector_int_const_view_array_with_stride+0x34>)
 8007502:	4807      	ldr	r0, [pc, #28]	; (8007520 <gsl_vector_int_const_view_array_with_stride+0x38>)
 8007504:	2304      	movs	r3, #4
 8007506:	2230      	movs	r2, #48	; 0x30
 8007508:	f7fb f9aa 	bl	8002860 <gsl_error>
 800750c:	e9c4 5500 	strd	r5, r5, [r4]
 8007510:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007514:	6125      	str	r5, [r4, #16]
}
 8007516:	4620      	mov	r0, r4
 8007518:	bd38      	pop	{r3, r4, r5, pc}
 800751a:	bf00      	nop
 800751c:	080310b4 	.word	0x080310b4
 8007520:	08031134 	.word	0x08031134

08007524 <gsl_vector_ushort_const_view_array>:
{
 8007524:	b430      	push	{r4, r5}
    return view;
 8007526:	2501      	movs	r5, #1
 8007528:	2400      	movs	r4, #0
 800752a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800752e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007532:	6002      	str	r2, [r0, #0]
}
 8007534:	bc30      	pop	{r4, r5}
 8007536:	4770      	bx	lr

08007538 <gsl_vector_ushort_const_view_array_with_stride>:
{
 8007538:	b538      	push	{r3, r4, r5, lr}
 800753a:	4604      	mov	r4, r0
  if (stride == 0)
 800753c:	4615      	mov	r5, r2
 800753e:	b13a      	cbz	r2, 8007550 <gsl_vector_ushort_const_view_array_with_stride+0x18>
    return view;
 8007540:	2200      	movs	r2, #0
 8007542:	e9c0 3500 	strd	r3, r5, [r0]
 8007546:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800754a:	6102      	str	r2, [r0, #16]
}
 800754c:	4620      	mov	r0, r4
 800754e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007550:	4906      	ldr	r1, [pc, #24]	; (800756c <gsl_vector_ushort_const_view_array_with_stride+0x34>)
 8007552:	4807      	ldr	r0, [pc, #28]	; (8007570 <gsl_vector_ushort_const_view_array_with_stride+0x38>)
 8007554:	2304      	movs	r3, #4
 8007556:	2230      	movs	r2, #48	; 0x30
 8007558:	f7fb f982 	bl	8002860 <gsl_error>
 800755c:	e9c4 5500 	strd	r5, r5, [r4]
 8007560:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007564:	6125      	str	r5, [r4, #16]
}
 8007566:	4620      	mov	r0, r4
 8007568:	bd38      	pop	{r3, r4, r5, pc}
 800756a:	bf00      	nop
 800756c:	080310b4 	.word	0x080310b4
 8007570:	08031134 	.word	0x08031134

08007574 <gsl_vector_short_const_view_array>:
{
 8007574:	b430      	push	{r4, r5}
    return view;
 8007576:	2501      	movs	r5, #1
 8007578:	2400      	movs	r4, #0
 800757a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800757e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007582:	6002      	str	r2, [r0, #0]
}
 8007584:	bc30      	pop	{r4, r5}
 8007586:	4770      	bx	lr

08007588 <gsl_vector_short_const_view_array_with_stride>:
{
 8007588:	b538      	push	{r3, r4, r5, lr}
 800758a:	4604      	mov	r4, r0
  if (stride == 0)
 800758c:	4615      	mov	r5, r2
 800758e:	b13a      	cbz	r2, 80075a0 <gsl_vector_short_const_view_array_with_stride+0x18>
    return view;
 8007590:	2200      	movs	r2, #0
 8007592:	e9c0 3500 	strd	r3, r5, [r0]
 8007596:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800759a:	6102      	str	r2, [r0, #16]
}
 800759c:	4620      	mov	r0, r4
 800759e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80075a0:	4906      	ldr	r1, [pc, #24]	; (80075bc <gsl_vector_short_const_view_array_with_stride+0x34>)
 80075a2:	4807      	ldr	r0, [pc, #28]	; (80075c0 <gsl_vector_short_const_view_array_with_stride+0x38>)
 80075a4:	2304      	movs	r3, #4
 80075a6:	2230      	movs	r2, #48	; 0x30
 80075a8:	f7fb f95a 	bl	8002860 <gsl_error>
 80075ac:	e9c4 5500 	strd	r5, r5, [r4]
 80075b0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80075b4:	6125      	str	r5, [r4, #16]
}
 80075b6:	4620      	mov	r0, r4
 80075b8:	bd38      	pop	{r3, r4, r5, pc}
 80075ba:	bf00      	nop
 80075bc:	080310b4 	.word	0x080310b4
 80075c0:	08031134 	.word	0x08031134

080075c4 <gsl_vector_uchar_const_view_array>:
{
 80075c4:	b430      	push	{r4, r5}
    return view;
 80075c6:	2501      	movs	r5, #1
 80075c8:	2400      	movs	r4, #0
 80075ca:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80075ce:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80075d2:	6002      	str	r2, [r0, #0]
}
 80075d4:	bc30      	pop	{r4, r5}
 80075d6:	4770      	bx	lr

080075d8 <gsl_vector_uchar_const_view_array_with_stride>:
{
 80075d8:	b538      	push	{r3, r4, r5, lr}
 80075da:	4604      	mov	r4, r0
  if (stride == 0)
 80075dc:	4615      	mov	r5, r2
 80075de:	b13a      	cbz	r2, 80075f0 <gsl_vector_uchar_const_view_array_with_stride+0x18>
    return view;
 80075e0:	2200      	movs	r2, #0
 80075e2:	e9c0 3500 	strd	r3, r5, [r0]
 80075e6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80075ea:	6102      	str	r2, [r0, #16]
}
 80075ec:	4620      	mov	r0, r4
 80075ee:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80075f0:	4906      	ldr	r1, [pc, #24]	; (800760c <gsl_vector_uchar_const_view_array_with_stride+0x34>)
 80075f2:	4807      	ldr	r0, [pc, #28]	; (8007610 <gsl_vector_uchar_const_view_array_with_stride+0x38>)
 80075f4:	2304      	movs	r3, #4
 80075f6:	2230      	movs	r2, #48	; 0x30
 80075f8:	f7fb f932 	bl	8002860 <gsl_error>
 80075fc:	e9c4 5500 	strd	r5, r5, [r4]
 8007600:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007604:	6125      	str	r5, [r4, #16]
}
 8007606:	4620      	mov	r0, r4
 8007608:	bd38      	pop	{r3, r4, r5, pc}
 800760a:	bf00      	nop
 800760c:	080310b4 	.word	0x080310b4
 8007610:	08031134 	.word	0x08031134

08007614 <gsl_vector_char_const_view_array>:
{
 8007614:	b430      	push	{r4, r5}
    return view;
 8007616:	2501      	movs	r5, #1
 8007618:	2400      	movs	r4, #0
 800761a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800761e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8007622:	6002      	str	r2, [r0, #0]
}
 8007624:	bc30      	pop	{r4, r5}
 8007626:	4770      	bx	lr

08007628 <gsl_vector_char_const_view_array_with_stride>:
{
 8007628:	b538      	push	{r3, r4, r5, lr}
 800762a:	4604      	mov	r4, r0
  if (stride == 0)
 800762c:	4615      	mov	r5, r2
 800762e:	b13a      	cbz	r2, 8007640 <gsl_vector_char_const_view_array_with_stride+0x18>
    return view;
 8007630:	2200      	movs	r2, #0
 8007632:	e9c0 3500 	strd	r3, r5, [r0]
 8007636:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800763a:	6102      	str	r2, [r0, #16]
}
 800763c:	4620      	mov	r0, r4
 800763e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8007640:	4906      	ldr	r1, [pc, #24]	; (800765c <gsl_vector_char_const_view_array_with_stride+0x34>)
 8007642:	4807      	ldr	r0, [pc, #28]	; (8007660 <gsl_vector_char_const_view_array_with_stride+0x38>)
 8007644:	2304      	movs	r3, #4
 8007646:	2230      	movs	r2, #48	; 0x30
 8007648:	f7fb f90a 	bl	8002860 <gsl_error>
 800764c:	e9c4 5500 	strd	r5, r5, [r4]
 8007650:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8007654:	6125      	str	r5, [r4, #16]
}
 8007656:	4620      	mov	r0, r4
 8007658:	bd38      	pop	{r3, r4, r5, pc}
 800765a:	bf00      	nop
 800765c:	080310b4 	.word	0x080310b4
 8007660:	08031134 	.word	0x08031134

08007664 <gsl_block_complex_long_double_alloc>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

TYPE (gsl_block) *
FUNCTION (gsl_block, alloc) (const size_t n)
{
 8007664:	b570      	push	{r4, r5, r6, lr}
 8007666:	4605      	mov	r5, r0
  TYPE (gsl_block) * b;

  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007668:	2008      	movs	r0, #8
 800766a:	f028 fd1b 	bl	80300a4 <malloc>

  if (b == 0)
 800766e:	4604      	mov	r4, r0
 8007670:	b140      	cbz	r0, 8007684 <gsl_block_complex_long_double_alloc+0x20>
    {
      GSL_ERROR_VAL ("failed to allocate space for block struct",
                        GSL_ENOMEM, 0);
    }

  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007672:	0128      	lsls	r0, r5, #4
 8007674:	f028 fd16 	bl	80300a4 <malloc>
 8007678:	4606      	mov	r6, r0
 800767a:	6060      	str	r0, [r4, #4]

  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 800767c:	b148      	cbz	r0, 8007692 <gsl_block_complex_long_double_alloc+0x2e>

      GSL_ERROR_VAL ("failed to allocate space for block data",
                        GSL_ENOMEM, 0);
    }

  b->size = n;
 800767e:	6025      	str	r5, [r4, #0]

  return b;
}
 8007680:	4620      	mov	r0, r4
 8007682:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007684:	4909      	ldr	r1, [pc, #36]	; (80076ac <gsl_block_complex_long_double_alloc+0x48>)
 8007686:	480a      	ldr	r0, [pc, #40]	; (80076b0 <gsl_block_complex_long_double_alloc+0x4c>)
 8007688:	2308      	movs	r3, #8
 800768a:	221d      	movs	r2, #29
 800768c:	f7fb f8e8 	bl	8002860 <gsl_error>
 8007690:	e7f6      	b.n	8007680 <gsl_block_complex_long_double_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007692:	2d00      	cmp	r5, #0
 8007694:	d0f3      	beq.n	800767e <gsl_block_complex_long_double_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007696:	4620      	mov	r0, r4
 8007698:	f028 fd0c 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 800769c:	4903      	ldr	r1, [pc, #12]	; (80076ac <gsl_block_complex_long_double_alloc+0x48>)
 800769e:	4805      	ldr	r0, [pc, #20]	; (80076b4 <gsl_block_complex_long_double_alloc+0x50>)
 80076a0:	2308      	movs	r3, #8
 80076a2:	2227      	movs	r2, #39	; 0x27
 80076a4:	4634      	mov	r4, r6
 80076a6:	f7fb f8db 	bl	8002860 <gsl_error>
 80076aa:	e7e9      	b.n	8007680 <gsl_block_complex_long_double_alloc+0x1c>
 80076ac:	08030f9c 	.word	0x08030f9c
 80076b0:	08031154 	.word	0x08031154
 80076b4:	08031180 	.word	0x08031180

080076b8 <gsl_block_complex_long_double_calloc>:

TYPE (gsl_block) *
FUNCTION (gsl_block, calloc) (const size_t n)
{
 80076b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80076ba:	4606      	mov	r6, r0
  size_t i;

  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 80076bc:	f7ff ffd2 	bl	8007664 <gsl_block_complex_long_double_alloc>

  if (b == 0)
 80076c0:	4605      	mov	r5, r0
 80076c2:	b178      	cbz	r0, 80076e4 <gsl_block_complex_long_double_calloc+0x2c>
    return 0;

  /* initialize block to zero; the memset call takes care of padding bytes */
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 80076c4:	0134      	lsls	r4, r6, #4
 80076c6:	6840      	ldr	r0, [r0, #4]
 80076c8:	4622      	mov	r2, r4
 80076ca:	2100      	movs	r1, #0
 80076cc:	f028 fcfa 	bl	80300c4 <memset>

  for (i = 0; i < MULTIPLICITY * n; i++)
 80076d0:	0073      	lsls	r3, r6, #1
 80076d2:	d007      	beq.n	80076e4 <gsl_block_complex_long_double_calloc+0x2c>
 80076d4:	686b      	ldr	r3, [r5, #4]
    {
      b->data[i] = 0;
 80076d6:	2600      	movs	r6, #0
 80076d8:	2700      	movs	r7, #0
 80076da:	18e2      	adds	r2, r4, r3
 80076dc:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 80076e0:	4293      	cmp	r3, r2
 80076e2:	d1fb      	bne.n	80076dc <gsl_block_complex_long_double_calloc+0x24>
    }

  return b;
}
 80076e4:	4628      	mov	r0, r5
 80076e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080076e8 <gsl_block_complex_long_double_free>:

void
FUNCTION (gsl_block, free) (TYPE (gsl_block) * b)
{
  RETURN_IF_NULL (b);
 80076e8:	b148      	cbz	r0, 80076fe <gsl_block_complex_long_double_free+0x16>
{
 80076ea:	b510      	push	{r4, lr}
 80076ec:	4604      	mov	r4, r0
  free (b->data);
 80076ee:	6840      	ldr	r0, [r0, #4]
 80076f0:	f028 fce0 	bl	80300b4 <free>
  free (b);
 80076f4:	4620      	mov	r0, r4
}
 80076f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 80076fa:	f028 bcdb 	b.w	80300b4 <free>
 80076fe:	4770      	bx	lr

08007700 <gsl_block_complex_alloc>:
{
 8007700:	b570      	push	{r4, r5, r6, lr}
 8007702:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007704:	2008      	movs	r0, #8
 8007706:	f028 fccd 	bl	80300a4 <malloc>
  if (b == 0)
 800770a:	4604      	mov	r4, r0
 800770c:	b140      	cbz	r0, 8007720 <gsl_block_complex_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 800770e:	0128      	lsls	r0, r5, #4
 8007710:	f028 fcc8 	bl	80300a4 <malloc>
 8007714:	4606      	mov	r6, r0
 8007716:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007718:	b148      	cbz	r0, 800772e <gsl_block_complex_alloc+0x2e>
  b->size = n;
 800771a:	6025      	str	r5, [r4, #0]
}
 800771c:	4620      	mov	r0, r4
 800771e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007720:	4909      	ldr	r1, [pc, #36]	; (8007748 <gsl_block_complex_alloc+0x48>)
 8007722:	480a      	ldr	r0, [pc, #40]	; (800774c <gsl_block_complex_alloc+0x4c>)
 8007724:	2308      	movs	r3, #8
 8007726:	221d      	movs	r2, #29
 8007728:	f7fb f89a 	bl	8002860 <gsl_error>
 800772c:	e7f6      	b.n	800771c <gsl_block_complex_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 800772e:	2d00      	cmp	r5, #0
 8007730:	d0f3      	beq.n	800771a <gsl_block_complex_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007732:	4620      	mov	r0, r4
 8007734:	f028 fcbe 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007738:	4903      	ldr	r1, [pc, #12]	; (8007748 <gsl_block_complex_alloc+0x48>)
 800773a:	4805      	ldr	r0, [pc, #20]	; (8007750 <gsl_block_complex_alloc+0x50>)
 800773c:	2308      	movs	r3, #8
 800773e:	2227      	movs	r2, #39	; 0x27
 8007740:	4634      	mov	r4, r6
 8007742:	f7fb f88d 	bl	8002860 <gsl_error>
 8007746:	e7e9      	b.n	800771c <gsl_block_complex_alloc+0x1c>
 8007748:	08030f9c 	.word	0x08030f9c
 800774c:	08031154 	.word	0x08031154
 8007750:	08031180 	.word	0x08031180

08007754 <gsl_block_complex_calloc>:
{
 8007754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007756:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007758:	f7ff ffd2 	bl	8007700 <gsl_block_complex_alloc>
  if (b == 0)
 800775c:	4605      	mov	r5, r0
 800775e:	b178      	cbz	r0, 8007780 <gsl_block_complex_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007760:	0134      	lsls	r4, r6, #4
 8007762:	6840      	ldr	r0, [r0, #4]
 8007764:	4622      	mov	r2, r4
 8007766:	2100      	movs	r1, #0
 8007768:	f028 fcac 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 800776c:	0073      	lsls	r3, r6, #1
 800776e:	d007      	beq.n	8007780 <gsl_block_complex_calloc+0x2c>
 8007770:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8007772:	2600      	movs	r6, #0
 8007774:	2700      	movs	r7, #0
 8007776:	18e2      	adds	r2, r4, r3
 8007778:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 800777c:	4293      	cmp	r3, r2
 800777e:	d1fb      	bne.n	8007778 <gsl_block_complex_calloc+0x24>
}
 8007780:	4628      	mov	r0, r5
 8007782:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08007784 <gsl_block_complex_free>:
  RETURN_IF_NULL (b);
 8007784:	b148      	cbz	r0, 800779a <gsl_block_complex_free+0x16>
{
 8007786:	b510      	push	{r4, lr}
 8007788:	4604      	mov	r4, r0
  free (b->data);
 800778a:	6840      	ldr	r0, [r0, #4]
 800778c:	f028 fc92 	bl	80300b4 <free>
  free (b);
 8007790:	4620      	mov	r0, r4
}
 8007792:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007796:	f028 bc8d 	b.w	80300b4 <free>
 800779a:	4770      	bx	lr

0800779c <gsl_block_complex_float_alloc>:
{
 800779c:	b570      	push	{r4, r5, r6, lr}
 800779e:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 80077a0:	2008      	movs	r0, #8
 80077a2:	f028 fc7f 	bl	80300a4 <malloc>
  if (b == 0)
 80077a6:	4604      	mov	r4, r0
 80077a8:	b140      	cbz	r0, 80077bc <gsl_block_complex_float_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 80077aa:	00e8      	lsls	r0, r5, #3
 80077ac:	f028 fc7a 	bl	80300a4 <malloc>
 80077b0:	4606      	mov	r6, r0
 80077b2:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80077b4:	b148      	cbz	r0, 80077ca <gsl_block_complex_float_alloc+0x2e>
  b->size = n;
 80077b6:	6025      	str	r5, [r4, #0]
}
 80077b8:	4620      	mov	r0, r4
 80077ba:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 80077bc:	4909      	ldr	r1, [pc, #36]	; (80077e4 <gsl_block_complex_float_alloc+0x48>)
 80077be:	480a      	ldr	r0, [pc, #40]	; (80077e8 <gsl_block_complex_float_alloc+0x4c>)
 80077c0:	2308      	movs	r3, #8
 80077c2:	221d      	movs	r2, #29
 80077c4:	f7fb f84c 	bl	8002860 <gsl_error>
 80077c8:	e7f6      	b.n	80077b8 <gsl_block_complex_float_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80077ca:	2d00      	cmp	r5, #0
 80077cc:	d0f3      	beq.n	80077b6 <gsl_block_complex_float_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 80077ce:	4620      	mov	r0, r4
 80077d0:	f028 fc70 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 80077d4:	4903      	ldr	r1, [pc, #12]	; (80077e4 <gsl_block_complex_float_alloc+0x48>)
 80077d6:	4805      	ldr	r0, [pc, #20]	; (80077ec <gsl_block_complex_float_alloc+0x50>)
 80077d8:	2308      	movs	r3, #8
 80077da:	2227      	movs	r2, #39	; 0x27
 80077dc:	4634      	mov	r4, r6
 80077de:	f7fb f83f 	bl	8002860 <gsl_error>
 80077e2:	e7e9      	b.n	80077b8 <gsl_block_complex_float_alloc+0x1c>
 80077e4:	08030f9c 	.word	0x08030f9c
 80077e8:	08031154 	.word	0x08031154
 80077ec:	08031180 	.word	0x08031180

080077f0 <gsl_block_complex_float_calloc>:
{
 80077f0:	b570      	push	{r4, r5, r6, lr}
 80077f2:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 80077f4:	f7ff ffd2 	bl	800779c <gsl_block_complex_float_alloc>
  if (b == 0)
 80077f8:	4605      	mov	r5, r0
 80077fa:	b170      	cbz	r0, 800781a <gsl_block_complex_float_calloc+0x2a>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 80077fc:	00f4      	lsls	r4, r6, #3
 80077fe:	6840      	ldr	r0, [r0, #4]
 8007800:	4622      	mov	r2, r4
 8007802:	2100      	movs	r1, #0
 8007804:	f028 fc5e 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007808:	0073      	lsls	r3, r6, #1
 800780a:	d006      	beq.n	800781a <gsl_block_complex_float_calloc+0x2a>
 800780c:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 800780e:	2100      	movs	r1, #0
 8007810:	18e2      	adds	r2, r4, r3
 8007812:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007816:	4293      	cmp	r3, r2
 8007818:	d1fb      	bne.n	8007812 <gsl_block_complex_float_calloc+0x22>
}
 800781a:	4628      	mov	r0, r5
 800781c:	bd70      	pop	{r4, r5, r6, pc}
 800781e:	bf00      	nop

08007820 <gsl_block_complex_float_free>:
  RETURN_IF_NULL (b);
 8007820:	b148      	cbz	r0, 8007836 <gsl_block_complex_float_free+0x16>
{
 8007822:	b510      	push	{r4, lr}
 8007824:	4604      	mov	r4, r0
  free (b->data);
 8007826:	6840      	ldr	r0, [r0, #4]
 8007828:	f028 fc44 	bl	80300b4 <free>
  free (b);
 800782c:	4620      	mov	r0, r4
}
 800782e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007832:	f028 bc3f 	b.w	80300b4 <free>
 8007836:	4770      	bx	lr

08007838 <gsl_block_long_double_alloc>:
{
 8007838:	b570      	push	{r4, r5, r6, lr}
 800783a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 800783c:	2008      	movs	r0, #8
 800783e:	f028 fc31 	bl	80300a4 <malloc>
  if (b == 0)
 8007842:	4604      	mov	r4, r0
 8007844:	b140      	cbz	r0, 8007858 <gsl_block_long_double_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007846:	00e8      	lsls	r0, r5, #3
 8007848:	f028 fc2c 	bl	80300a4 <malloc>
 800784c:	4606      	mov	r6, r0
 800784e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007850:	b148      	cbz	r0, 8007866 <gsl_block_long_double_alloc+0x2e>
  b->size = n;
 8007852:	6025      	str	r5, [r4, #0]
}
 8007854:	4620      	mov	r0, r4
 8007856:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007858:	4909      	ldr	r1, [pc, #36]	; (8007880 <gsl_block_long_double_alloc+0x48>)
 800785a:	480a      	ldr	r0, [pc, #40]	; (8007884 <gsl_block_long_double_alloc+0x4c>)
 800785c:	2308      	movs	r3, #8
 800785e:	221d      	movs	r2, #29
 8007860:	f7fa fffe 	bl	8002860 <gsl_error>
 8007864:	e7f6      	b.n	8007854 <gsl_block_long_double_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007866:	2d00      	cmp	r5, #0
 8007868:	d0f3      	beq.n	8007852 <gsl_block_long_double_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 800786a:	4620      	mov	r0, r4
 800786c:	f028 fc22 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007870:	4903      	ldr	r1, [pc, #12]	; (8007880 <gsl_block_long_double_alloc+0x48>)
 8007872:	4805      	ldr	r0, [pc, #20]	; (8007888 <gsl_block_long_double_alloc+0x50>)
 8007874:	2308      	movs	r3, #8
 8007876:	2227      	movs	r2, #39	; 0x27
 8007878:	4634      	mov	r4, r6
 800787a:	f7fa fff1 	bl	8002860 <gsl_error>
 800787e:	e7e9      	b.n	8007854 <gsl_block_long_double_alloc+0x1c>
 8007880:	08030f9c 	.word	0x08030f9c
 8007884:	08031154 	.word	0x08031154
 8007888:	08031180 	.word	0x08031180

0800788c <gsl_block_long_double_calloc>:
{
 800788c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800788e:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007890:	f7ff ffd2 	bl	8007838 <gsl_block_long_double_alloc>
  if (b == 0)
 8007894:	4605      	mov	r5, r0
 8007896:	b170      	cbz	r0, 80078b6 <gsl_block_long_double_calloc+0x2a>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007898:	00f4      	lsls	r4, r6, #3
 800789a:	6840      	ldr	r0, [r0, #4]
 800789c:	4622      	mov	r2, r4
 800789e:	2100      	movs	r1, #0
 80078a0:	f028 fc10 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 80078a4:	b13e      	cbz	r6, 80078b6 <gsl_block_long_double_calloc+0x2a>
 80078a6:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 80078a8:	2600      	movs	r6, #0
 80078aa:	2700      	movs	r7, #0
 80078ac:	18e2      	adds	r2, r4, r3
 80078ae:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 80078b2:	4293      	cmp	r3, r2
 80078b4:	d1fb      	bne.n	80078ae <gsl_block_long_double_calloc+0x22>
}
 80078b6:	4628      	mov	r0, r5
 80078b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80078ba:	bf00      	nop

080078bc <gsl_block_long_double_free>:
  RETURN_IF_NULL (b);
 80078bc:	b148      	cbz	r0, 80078d2 <gsl_block_long_double_free+0x16>
{
 80078be:	b510      	push	{r4, lr}
 80078c0:	4604      	mov	r4, r0
  free (b->data);
 80078c2:	6840      	ldr	r0, [r0, #4]
 80078c4:	f028 fbf6 	bl	80300b4 <free>
  free (b);
 80078c8:	4620      	mov	r0, r4
}
 80078ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 80078ce:	f028 bbf1 	b.w	80300b4 <free>
 80078d2:	4770      	bx	lr

080078d4 <gsl_block_alloc>:
{
 80078d4:	b570      	push	{r4, r5, r6, lr}
 80078d6:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 80078d8:	2008      	movs	r0, #8
 80078da:	f028 fbe3 	bl	80300a4 <malloc>
  if (b == 0)
 80078de:	4604      	mov	r4, r0
 80078e0:	b140      	cbz	r0, 80078f4 <gsl_block_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 80078e2:	00e8      	lsls	r0, r5, #3
 80078e4:	f028 fbde 	bl	80300a4 <malloc>
 80078e8:	4606      	mov	r6, r0
 80078ea:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80078ec:	b148      	cbz	r0, 8007902 <gsl_block_alloc+0x2e>
  b->size = n;
 80078ee:	6025      	str	r5, [r4, #0]
}
 80078f0:	4620      	mov	r0, r4
 80078f2:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 80078f4:	4909      	ldr	r1, [pc, #36]	; (800791c <gsl_block_alloc+0x48>)
 80078f6:	480a      	ldr	r0, [pc, #40]	; (8007920 <gsl_block_alloc+0x4c>)
 80078f8:	2308      	movs	r3, #8
 80078fa:	221d      	movs	r2, #29
 80078fc:	f7fa ffb0 	bl	8002860 <gsl_error>
 8007900:	e7f6      	b.n	80078f0 <gsl_block_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007902:	2d00      	cmp	r5, #0
 8007904:	d0f3      	beq.n	80078ee <gsl_block_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007906:	4620      	mov	r0, r4
 8007908:	f028 fbd4 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 800790c:	4903      	ldr	r1, [pc, #12]	; (800791c <gsl_block_alloc+0x48>)
 800790e:	4805      	ldr	r0, [pc, #20]	; (8007924 <gsl_block_alloc+0x50>)
 8007910:	2308      	movs	r3, #8
 8007912:	2227      	movs	r2, #39	; 0x27
 8007914:	4634      	mov	r4, r6
 8007916:	f7fa ffa3 	bl	8002860 <gsl_error>
 800791a:	e7e9      	b.n	80078f0 <gsl_block_alloc+0x1c>
 800791c:	08030f9c 	.word	0x08030f9c
 8007920:	08031154 	.word	0x08031154
 8007924:	08031180 	.word	0x08031180

08007928 <gsl_block_calloc>:
{
 8007928:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800792a:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 800792c:	f7ff ffd2 	bl	80078d4 <gsl_block_alloc>
  if (b == 0)
 8007930:	4605      	mov	r5, r0
 8007932:	b170      	cbz	r0, 8007952 <gsl_block_calloc+0x2a>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007934:	00f4      	lsls	r4, r6, #3
 8007936:	6840      	ldr	r0, [r0, #4]
 8007938:	4622      	mov	r2, r4
 800793a:	2100      	movs	r1, #0
 800793c:	f028 fbc2 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007940:	b13e      	cbz	r6, 8007952 <gsl_block_calloc+0x2a>
 8007942:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8007944:	2600      	movs	r6, #0
 8007946:	2700      	movs	r7, #0
 8007948:	18e2      	adds	r2, r4, r3
 800794a:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 800794e:	4293      	cmp	r3, r2
 8007950:	d1fb      	bne.n	800794a <gsl_block_calloc+0x22>
}
 8007952:	4628      	mov	r0, r5
 8007954:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007956:	bf00      	nop

08007958 <gsl_block_free>:
  RETURN_IF_NULL (b);
 8007958:	b148      	cbz	r0, 800796e <gsl_block_free+0x16>
{
 800795a:	b510      	push	{r4, lr}
 800795c:	4604      	mov	r4, r0
  free (b->data);
 800795e:	6840      	ldr	r0, [r0, #4]
 8007960:	f028 fba8 	bl	80300b4 <free>
  free (b);
 8007964:	4620      	mov	r0, r4
}
 8007966:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 800796a:	f028 bba3 	b.w	80300b4 <free>
 800796e:	4770      	bx	lr

08007970 <gsl_block_float_alloc>:
{
 8007970:	b570      	push	{r4, r5, r6, lr}
 8007972:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007974:	2008      	movs	r0, #8
 8007976:	f028 fb95 	bl	80300a4 <malloc>
  if (b == 0)
 800797a:	4604      	mov	r4, r0
 800797c:	b140      	cbz	r0, 8007990 <gsl_block_float_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 800797e:	00a8      	lsls	r0, r5, #2
 8007980:	f028 fb90 	bl	80300a4 <malloc>
 8007984:	4606      	mov	r6, r0
 8007986:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007988:	b148      	cbz	r0, 800799e <gsl_block_float_alloc+0x2e>
  b->size = n;
 800798a:	6025      	str	r5, [r4, #0]
}
 800798c:	4620      	mov	r0, r4
 800798e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007990:	4909      	ldr	r1, [pc, #36]	; (80079b8 <gsl_block_float_alloc+0x48>)
 8007992:	480a      	ldr	r0, [pc, #40]	; (80079bc <gsl_block_float_alloc+0x4c>)
 8007994:	2308      	movs	r3, #8
 8007996:	221d      	movs	r2, #29
 8007998:	f7fa ff62 	bl	8002860 <gsl_error>
 800799c:	e7f6      	b.n	800798c <gsl_block_float_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 800799e:	2d00      	cmp	r5, #0
 80079a0:	d0f3      	beq.n	800798a <gsl_block_float_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 80079a2:	4620      	mov	r0, r4
 80079a4:	f028 fb86 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 80079a8:	4903      	ldr	r1, [pc, #12]	; (80079b8 <gsl_block_float_alloc+0x48>)
 80079aa:	4805      	ldr	r0, [pc, #20]	; (80079c0 <gsl_block_float_alloc+0x50>)
 80079ac:	2308      	movs	r3, #8
 80079ae:	2227      	movs	r2, #39	; 0x27
 80079b0:	4634      	mov	r4, r6
 80079b2:	f7fa ff55 	bl	8002860 <gsl_error>
 80079b6:	e7e9      	b.n	800798c <gsl_block_float_alloc+0x1c>
 80079b8:	08030f9c 	.word	0x08030f9c
 80079bc:	08031154 	.word	0x08031154
 80079c0:	08031180 	.word	0x08031180

080079c4 <gsl_block_float_calloc>:
{
 80079c4:	b570      	push	{r4, r5, r6, lr}
 80079c6:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 80079c8:	f7ff ffd2 	bl	8007970 <gsl_block_float_alloc>
  if (b == 0)
 80079cc:	4605      	mov	r5, r0
 80079ce:	b168      	cbz	r0, 80079ec <gsl_block_float_calloc+0x28>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 80079d0:	00b4      	lsls	r4, r6, #2
 80079d2:	6840      	ldr	r0, [r0, #4]
 80079d4:	4622      	mov	r2, r4
 80079d6:	2100      	movs	r1, #0
 80079d8:	f028 fb74 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 80079dc:	b136      	cbz	r6, 80079ec <gsl_block_float_calloc+0x28>
 80079de:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 80079e0:	2100      	movs	r1, #0
 80079e2:	18e2      	adds	r2, r4, r3
 80079e4:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n; i++)
 80079e8:	4293      	cmp	r3, r2
 80079ea:	d1fb      	bne.n	80079e4 <gsl_block_float_calloc+0x20>
}
 80079ec:	4628      	mov	r0, r5
 80079ee:	bd70      	pop	{r4, r5, r6, pc}

080079f0 <gsl_block_float_free>:
  RETURN_IF_NULL (b);
 80079f0:	b148      	cbz	r0, 8007a06 <gsl_block_float_free+0x16>
{
 80079f2:	b510      	push	{r4, lr}
 80079f4:	4604      	mov	r4, r0
  free (b->data);
 80079f6:	6840      	ldr	r0, [r0, #4]
 80079f8:	f028 fb5c 	bl	80300b4 <free>
  free (b);
 80079fc:	4620      	mov	r0, r4
}
 80079fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007a02:	f028 bb57 	b.w	80300b4 <free>
 8007a06:	4770      	bx	lr

08007a08 <gsl_block_ulong_alloc>:
{
 8007a08:	b570      	push	{r4, r5, r6, lr}
 8007a0a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007a0c:	2008      	movs	r0, #8
 8007a0e:	f028 fb49 	bl	80300a4 <malloc>
  if (b == 0)
 8007a12:	4604      	mov	r4, r0
 8007a14:	b140      	cbz	r0, 8007a28 <gsl_block_ulong_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007a16:	00a8      	lsls	r0, r5, #2
 8007a18:	f028 fb44 	bl	80300a4 <malloc>
 8007a1c:	4606      	mov	r6, r0
 8007a1e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007a20:	b148      	cbz	r0, 8007a36 <gsl_block_ulong_alloc+0x2e>
  b->size = n;
 8007a22:	6025      	str	r5, [r4, #0]
}
 8007a24:	4620      	mov	r0, r4
 8007a26:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007a28:	4909      	ldr	r1, [pc, #36]	; (8007a50 <gsl_block_ulong_alloc+0x48>)
 8007a2a:	480a      	ldr	r0, [pc, #40]	; (8007a54 <gsl_block_ulong_alloc+0x4c>)
 8007a2c:	2308      	movs	r3, #8
 8007a2e:	221d      	movs	r2, #29
 8007a30:	f7fa ff16 	bl	8002860 <gsl_error>
 8007a34:	e7f6      	b.n	8007a24 <gsl_block_ulong_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007a36:	2d00      	cmp	r5, #0
 8007a38:	d0f3      	beq.n	8007a22 <gsl_block_ulong_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007a3a:	4620      	mov	r0, r4
 8007a3c:	f028 fb3a 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007a40:	4903      	ldr	r1, [pc, #12]	; (8007a50 <gsl_block_ulong_alloc+0x48>)
 8007a42:	4805      	ldr	r0, [pc, #20]	; (8007a58 <gsl_block_ulong_alloc+0x50>)
 8007a44:	2308      	movs	r3, #8
 8007a46:	2227      	movs	r2, #39	; 0x27
 8007a48:	4634      	mov	r4, r6
 8007a4a:	f7fa ff09 	bl	8002860 <gsl_error>
 8007a4e:	e7e9      	b.n	8007a24 <gsl_block_ulong_alloc+0x1c>
 8007a50:	08030f9c 	.word	0x08030f9c
 8007a54:	08031154 	.word	0x08031154
 8007a58:	08031180 	.word	0x08031180

08007a5c <gsl_block_ulong_calloc>:
{
 8007a5c:	b570      	push	{r4, r5, r6, lr}
 8007a5e:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007a60:	f7ff ffd2 	bl	8007a08 <gsl_block_ulong_alloc>
  if (b == 0)
 8007a64:	4605      	mov	r5, r0
 8007a66:	b178      	cbz	r0, 8007a88 <gsl_block_ulong_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007a68:	00b4      	lsls	r4, r6, #2
 8007a6a:	6840      	ldr	r0, [r0, #4]
 8007a6c:	4622      	mov	r2, r4
 8007a6e:	2100      	movs	r1, #0
 8007a70:	f028 fb28 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007a74:	b146      	cbz	r6, 8007a88 <gsl_block_ulong_calloc+0x2c>
      b->data[i] = 0;
 8007a76:	686b      	ldr	r3, [r5, #4]
 8007a78:	1f22      	subs	r2, r4, #4
 8007a7a:	441a      	add	r2, r3
 8007a7c:	2100      	movs	r1, #0
 8007a7e:	3b04      	subs	r3, #4
 8007a80:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007a84:	4293      	cmp	r3, r2
 8007a86:	d1fb      	bne.n	8007a80 <gsl_block_ulong_calloc+0x24>
}
 8007a88:	4628      	mov	r0, r5
 8007a8a:	bd70      	pop	{r4, r5, r6, pc}

08007a8c <gsl_block_ulong_free>:
  RETURN_IF_NULL (b);
 8007a8c:	b148      	cbz	r0, 8007aa2 <gsl_block_ulong_free+0x16>
{
 8007a8e:	b510      	push	{r4, lr}
 8007a90:	4604      	mov	r4, r0
  free (b->data);
 8007a92:	6840      	ldr	r0, [r0, #4]
 8007a94:	f028 fb0e 	bl	80300b4 <free>
  free (b);
 8007a98:	4620      	mov	r0, r4
}
 8007a9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007a9e:	f028 bb09 	b.w	80300b4 <free>
 8007aa2:	4770      	bx	lr

08007aa4 <gsl_block_long_alloc>:
{
 8007aa4:	b570      	push	{r4, r5, r6, lr}
 8007aa6:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007aa8:	2008      	movs	r0, #8
 8007aaa:	f028 fafb 	bl	80300a4 <malloc>
  if (b == 0)
 8007aae:	4604      	mov	r4, r0
 8007ab0:	b140      	cbz	r0, 8007ac4 <gsl_block_long_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007ab2:	00a8      	lsls	r0, r5, #2
 8007ab4:	f028 faf6 	bl	80300a4 <malloc>
 8007ab8:	4606      	mov	r6, r0
 8007aba:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007abc:	b148      	cbz	r0, 8007ad2 <gsl_block_long_alloc+0x2e>
  b->size = n;
 8007abe:	6025      	str	r5, [r4, #0]
}
 8007ac0:	4620      	mov	r0, r4
 8007ac2:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007ac4:	4909      	ldr	r1, [pc, #36]	; (8007aec <gsl_block_long_alloc+0x48>)
 8007ac6:	480a      	ldr	r0, [pc, #40]	; (8007af0 <gsl_block_long_alloc+0x4c>)
 8007ac8:	2308      	movs	r3, #8
 8007aca:	221d      	movs	r2, #29
 8007acc:	f7fa fec8 	bl	8002860 <gsl_error>
 8007ad0:	e7f6      	b.n	8007ac0 <gsl_block_long_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007ad2:	2d00      	cmp	r5, #0
 8007ad4:	d0f3      	beq.n	8007abe <gsl_block_long_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007ad6:	4620      	mov	r0, r4
 8007ad8:	f028 faec 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007adc:	4903      	ldr	r1, [pc, #12]	; (8007aec <gsl_block_long_alloc+0x48>)
 8007ade:	4805      	ldr	r0, [pc, #20]	; (8007af4 <gsl_block_long_alloc+0x50>)
 8007ae0:	2308      	movs	r3, #8
 8007ae2:	2227      	movs	r2, #39	; 0x27
 8007ae4:	4634      	mov	r4, r6
 8007ae6:	f7fa febb 	bl	8002860 <gsl_error>
 8007aea:	e7e9      	b.n	8007ac0 <gsl_block_long_alloc+0x1c>
 8007aec:	08030f9c 	.word	0x08030f9c
 8007af0:	08031154 	.word	0x08031154
 8007af4:	08031180 	.word	0x08031180

08007af8 <gsl_block_long_calloc>:
{
 8007af8:	b570      	push	{r4, r5, r6, lr}
 8007afa:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007afc:	f7ff ffd2 	bl	8007aa4 <gsl_block_long_alloc>
  if (b == 0)
 8007b00:	4605      	mov	r5, r0
 8007b02:	b178      	cbz	r0, 8007b24 <gsl_block_long_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007b04:	00b4      	lsls	r4, r6, #2
 8007b06:	6840      	ldr	r0, [r0, #4]
 8007b08:	4622      	mov	r2, r4
 8007b0a:	2100      	movs	r1, #0
 8007b0c:	f028 fada 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007b10:	b146      	cbz	r6, 8007b24 <gsl_block_long_calloc+0x2c>
      b->data[i] = 0;
 8007b12:	686b      	ldr	r3, [r5, #4]
 8007b14:	1f22      	subs	r2, r4, #4
 8007b16:	441a      	add	r2, r3
 8007b18:	2100      	movs	r1, #0
 8007b1a:	3b04      	subs	r3, #4
 8007b1c:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007b20:	4293      	cmp	r3, r2
 8007b22:	d1fb      	bne.n	8007b1c <gsl_block_long_calloc+0x24>
}
 8007b24:	4628      	mov	r0, r5
 8007b26:	bd70      	pop	{r4, r5, r6, pc}

08007b28 <gsl_block_long_free>:
  RETURN_IF_NULL (b);
 8007b28:	b148      	cbz	r0, 8007b3e <gsl_block_long_free+0x16>
{
 8007b2a:	b510      	push	{r4, lr}
 8007b2c:	4604      	mov	r4, r0
  free (b->data);
 8007b2e:	6840      	ldr	r0, [r0, #4]
 8007b30:	f028 fac0 	bl	80300b4 <free>
  free (b);
 8007b34:	4620      	mov	r0, r4
}
 8007b36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007b3a:	f028 babb 	b.w	80300b4 <free>
 8007b3e:	4770      	bx	lr

08007b40 <gsl_block_uint_alloc>:
{
 8007b40:	b570      	push	{r4, r5, r6, lr}
 8007b42:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007b44:	2008      	movs	r0, #8
 8007b46:	f028 faad 	bl	80300a4 <malloc>
  if (b == 0)
 8007b4a:	4604      	mov	r4, r0
 8007b4c:	b140      	cbz	r0, 8007b60 <gsl_block_uint_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007b4e:	00a8      	lsls	r0, r5, #2
 8007b50:	f028 faa8 	bl	80300a4 <malloc>
 8007b54:	4606      	mov	r6, r0
 8007b56:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007b58:	b148      	cbz	r0, 8007b6e <gsl_block_uint_alloc+0x2e>
  b->size = n;
 8007b5a:	6025      	str	r5, [r4, #0]
}
 8007b5c:	4620      	mov	r0, r4
 8007b5e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007b60:	4909      	ldr	r1, [pc, #36]	; (8007b88 <gsl_block_uint_alloc+0x48>)
 8007b62:	480a      	ldr	r0, [pc, #40]	; (8007b8c <gsl_block_uint_alloc+0x4c>)
 8007b64:	2308      	movs	r3, #8
 8007b66:	221d      	movs	r2, #29
 8007b68:	f7fa fe7a 	bl	8002860 <gsl_error>
 8007b6c:	e7f6      	b.n	8007b5c <gsl_block_uint_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007b6e:	2d00      	cmp	r5, #0
 8007b70:	d0f3      	beq.n	8007b5a <gsl_block_uint_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007b72:	4620      	mov	r0, r4
 8007b74:	f028 fa9e 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007b78:	4903      	ldr	r1, [pc, #12]	; (8007b88 <gsl_block_uint_alloc+0x48>)
 8007b7a:	4805      	ldr	r0, [pc, #20]	; (8007b90 <gsl_block_uint_alloc+0x50>)
 8007b7c:	2308      	movs	r3, #8
 8007b7e:	2227      	movs	r2, #39	; 0x27
 8007b80:	4634      	mov	r4, r6
 8007b82:	f7fa fe6d 	bl	8002860 <gsl_error>
 8007b86:	e7e9      	b.n	8007b5c <gsl_block_uint_alloc+0x1c>
 8007b88:	08030f9c 	.word	0x08030f9c
 8007b8c:	08031154 	.word	0x08031154
 8007b90:	08031180 	.word	0x08031180

08007b94 <gsl_block_uint_calloc>:
{
 8007b94:	b570      	push	{r4, r5, r6, lr}
 8007b96:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007b98:	f7ff ffd2 	bl	8007b40 <gsl_block_uint_alloc>
  if (b == 0)
 8007b9c:	4605      	mov	r5, r0
 8007b9e:	b178      	cbz	r0, 8007bc0 <gsl_block_uint_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007ba0:	00b4      	lsls	r4, r6, #2
 8007ba2:	6840      	ldr	r0, [r0, #4]
 8007ba4:	4622      	mov	r2, r4
 8007ba6:	2100      	movs	r1, #0
 8007ba8:	f028 fa8c 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007bac:	b146      	cbz	r6, 8007bc0 <gsl_block_uint_calloc+0x2c>
      b->data[i] = 0;
 8007bae:	686b      	ldr	r3, [r5, #4]
 8007bb0:	1f22      	subs	r2, r4, #4
 8007bb2:	441a      	add	r2, r3
 8007bb4:	2100      	movs	r1, #0
 8007bb6:	3b04      	subs	r3, #4
 8007bb8:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007bbc:	4293      	cmp	r3, r2
 8007bbe:	d1fb      	bne.n	8007bb8 <gsl_block_uint_calloc+0x24>
}
 8007bc0:	4628      	mov	r0, r5
 8007bc2:	bd70      	pop	{r4, r5, r6, pc}

08007bc4 <gsl_block_uint_free>:
  RETURN_IF_NULL (b);
 8007bc4:	b148      	cbz	r0, 8007bda <gsl_block_uint_free+0x16>
{
 8007bc6:	b510      	push	{r4, lr}
 8007bc8:	4604      	mov	r4, r0
  free (b->data);
 8007bca:	6840      	ldr	r0, [r0, #4]
 8007bcc:	f028 fa72 	bl	80300b4 <free>
  free (b);
 8007bd0:	4620      	mov	r0, r4
}
 8007bd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007bd6:	f028 ba6d 	b.w	80300b4 <free>
 8007bda:	4770      	bx	lr

08007bdc <gsl_block_int_alloc>:
{
 8007bdc:	b570      	push	{r4, r5, r6, lr}
 8007bde:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007be0:	2008      	movs	r0, #8
 8007be2:	f028 fa5f 	bl	80300a4 <malloc>
  if (b == 0)
 8007be6:	4604      	mov	r4, r0
 8007be8:	b140      	cbz	r0, 8007bfc <gsl_block_int_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007bea:	00a8      	lsls	r0, r5, #2
 8007bec:	f028 fa5a 	bl	80300a4 <malloc>
 8007bf0:	4606      	mov	r6, r0
 8007bf2:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007bf4:	b148      	cbz	r0, 8007c0a <gsl_block_int_alloc+0x2e>
  b->size = n;
 8007bf6:	6025      	str	r5, [r4, #0]
}
 8007bf8:	4620      	mov	r0, r4
 8007bfa:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007bfc:	4909      	ldr	r1, [pc, #36]	; (8007c24 <gsl_block_int_alloc+0x48>)
 8007bfe:	480a      	ldr	r0, [pc, #40]	; (8007c28 <gsl_block_int_alloc+0x4c>)
 8007c00:	2308      	movs	r3, #8
 8007c02:	221d      	movs	r2, #29
 8007c04:	f7fa fe2c 	bl	8002860 <gsl_error>
 8007c08:	e7f6      	b.n	8007bf8 <gsl_block_int_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007c0a:	2d00      	cmp	r5, #0
 8007c0c:	d0f3      	beq.n	8007bf6 <gsl_block_int_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007c0e:	4620      	mov	r0, r4
 8007c10:	f028 fa50 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007c14:	4903      	ldr	r1, [pc, #12]	; (8007c24 <gsl_block_int_alloc+0x48>)
 8007c16:	4805      	ldr	r0, [pc, #20]	; (8007c2c <gsl_block_int_alloc+0x50>)
 8007c18:	2308      	movs	r3, #8
 8007c1a:	2227      	movs	r2, #39	; 0x27
 8007c1c:	4634      	mov	r4, r6
 8007c1e:	f7fa fe1f 	bl	8002860 <gsl_error>
 8007c22:	e7e9      	b.n	8007bf8 <gsl_block_int_alloc+0x1c>
 8007c24:	08030f9c 	.word	0x08030f9c
 8007c28:	08031154 	.word	0x08031154
 8007c2c:	08031180 	.word	0x08031180

08007c30 <gsl_block_int_calloc>:
{
 8007c30:	b570      	push	{r4, r5, r6, lr}
 8007c32:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007c34:	f7ff ffd2 	bl	8007bdc <gsl_block_int_alloc>
  if (b == 0)
 8007c38:	4605      	mov	r5, r0
 8007c3a:	b178      	cbz	r0, 8007c5c <gsl_block_int_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007c3c:	00b4      	lsls	r4, r6, #2
 8007c3e:	6840      	ldr	r0, [r0, #4]
 8007c40:	4622      	mov	r2, r4
 8007c42:	2100      	movs	r1, #0
 8007c44:	f028 fa3e 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007c48:	b146      	cbz	r6, 8007c5c <gsl_block_int_calloc+0x2c>
      b->data[i] = 0;
 8007c4a:	686b      	ldr	r3, [r5, #4]
 8007c4c:	1f22      	subs	r2, r4, #4
 8007c4e:	441a      	add	r2, r3
 8007c50:	2100      	movs	r1, #0
 8007c52:	3b04      	subs	r3, #4
 8007c54:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007c58:	4293      	cmp	r3, r2
 8007c5a:	d1fb      	bne.n	8007c54 <gsl_block_int_calloc+0x24>
}
 8007c5c:	4628      	mov	r0, r5
 8007c5e:	bd70      	pop	{r4, r5, r6, pc}

08007c60 <gsl_block_int_free>:
  RETURN_IF_NULL (b);
 8007c60:	b148      	cbz	r0, 8007c76 <gsl_block_int_free+0x16>
{
 8007c62:	b510      	push	{r4, lr}
 8007c64:	4604      	mov	r4, r0
  free (b->data);
 8007c66:	6840      	ldr	r0, [r0, #4]
 8007c68:	f028 fa24 	bl	80300b4 <free>
  free (b);
 8007c6c:	4620      	mov	r0, r4
}
 8007c6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007c72:	f028 ba1f 	b.w	80300b4 <free>
 8007c76:	4770      	bx	lr

08007c78 <gsl_block_ushort_alloc>:
{
 8007c78:	b570      	push	{r4, r5, r6, lr}
 8007c7a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007c7c:	2008      	movs	r0, #8
 8007c7e:	f028 fa11 	bl	80300a4 <malloc>
  if (b == 0)
 8007c82:	4604      	mov	r4, r0
 8007c84:	b140      	cbz	r0, 8007c98 <gsl_block_ushort_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007c86:	0068      	lsls	r0, r5, #1
 8007c88:	f028 fa0c 	bl	80300a4 <malloc>
 8007c8c:	4606      	mov	r6, r0
 8007c8e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007c90:	b148      	cbz	r0, 8007ca6 <gsl_block_ushort_alloc+0x2e>
  b->size = n;
 8007c92:	6025      	str	r5, [r4, #0]
}
 8007c94:	4620      	mov	r0, r4
 8007c96:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007c98:	4909      	ldr	r1, [pc, #36]	; (8007cc0 <gsl_block_ushort_alloc+0x48>)
 8007c9a:	480a      	ldr	r0, [pc, #40]	; (8007cc4 <gsl_block_ushort_alloc+0x4c>)
 8007c9c:	2308      	movs	r3, #8
 8007c9e:	221d      	movs	r2, #29
 8007ca0:	f7fa fdde 	bl	8002860 <gsl_error>
 8007ca4:	e7f6      	b.n	8007c94 <gsl_block_ushort_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007ca6:	2d00      	cmp	r5, #0
 8007ca8:	d0f3      	beq.n	8007c92 <gsl_block_ushort_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007caa:	4620      	mov	r0, r4
 8007cac:	f028 fa02 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007cb0:	4903      	ldr	r1, [pc, #12]	; (8007cc0 <gsl_block_ushort_alloc+0x48>)
 8007cb2:	4805      	ldr	r0, [pc, #20]	; (8007cc8 <gsl_block_ushort_alloc+0x50>)
 8007cb4:	2308      	movs	r3, #8
 8007cb6:	2227      	movs	r2, #39	; 0x27
 8007cb8:	4634      	mov	r4, r6
 8007cba:	f7fa fdd1 	bl	8002860 <gsl_error>
 8007cbe:	e7e9      	b.n	8007c94 <gsl_block_ushort_alloc+0x1c>
 8007cc0:	08030f9c 	.word	0x08030f9c
 8007cc4:	08031154 	.word	0x08031154
 8007cc8:	08031180 	.word	0x08031180

08007ccc <gsl_block_ushort_calloc>:
{
 8007ccc:	b570      	push	{r4, r5, r6, lr}
 8007cce:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007cd0:	f7ff ffd2 	bl	8007c78 <gsl_block_ushort_alloc>
  if (b == 0)
 8007cd4:	4605      	mov	r5, r0
 8007cd6:	b178      	cbz	r0, 8007cf8 <gsl_block_ushort_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007cd8:	0074      	lsls	r4, r6, #1
 8007cda:	6840      	ldr	r0, [r0, #4]
 8007cdc:	4622      	mov	r2, r4
 8007cde:	2100      	movs	r1, #0
 8007ce0:	f028 f9f0 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007ce4:	b146      	cbz	r6, 8007cf8 <gsl_block_ushort_calloc+0x2c>
      b->data[i] = 0;
 8007ce6:	686b      	ldr	r3, [r5, #4]
 8007ce8:	1ea2      	subs	r2, r4, #2
 8007cea:	441a      	add	r2, r3
 8007cec:	2100      	movs	r1, #0
 8007cee:	3b02      	subs	r3, #2
 8007cf0:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007cf4:	4293      	cmp	r3, r2
 8007cf6:	d1fb      	bne.n	8007cf0 <gsl_block_ushort_calloc+0x24>
}
 8007cf8:	4628      	mov	r0, r5
 8007cfa:	bd70      	pop	{r4, r5, r6, pc}

08007cfc <gsl_block_ushort_free>:
  RETURN_IF_NULL (b);
 8007cfc:	b148      	cbz	r0, 8007d12 <gsl_block_ushort_free+0x16>
{
 8007cfe:	b510      	push	{r4, lr}
 8007d00:	4604      	mov	r4, r0
  free (b->data);
 8007d02:	6840      	ldr	r0, [r0, #4]
 8007d04:	f028 f9d6 	bl	80300b4 <free>
  free (b);
 8007d08:	4620      	mov	r0, r4
}
 8007d0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007d0e:	f028 b9d1 	b.w	80300b4 <free>
 8007d12:	4770      	bx	lr

08007d14 <gsl_block_short_alloc>:
{
 8007d14:	b570      	push	{r4, r5, r6, lr}
 8007d16:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007d18:	2008      	movs	r0, #8
 8007d1a:	f028 f9c3 	bl	80300a4 <malloc>
  if (b == 0)
 8007d1e:	4604      	mov	r4, r0
 8007d20:	b140      	cbz	r0, 8007d34 <gsl_block_short_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007d22:	0068      	lsls	r0, r5, #1
 8007d24:	f028 f9be 	bl	80300a4 <malloc>
 8007d28:	4606      	mov	r6, r0
 8007d2a:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007d2c:	b148      	cbz	r0, 8007d42 <gsl_block_short_alloc+0x2e>
  b->size = n;
 8007d2e:	6025      	str	r5, [r4, #0]
}
 8007d30:	4620      	mov	r0, r4
 8007d32:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007d34:	4909      	ldr	r1, [pc, #36]	; (8007d5c <gsl_block_short_alloc+0x48>)
 8007d36:	480a      	ldr	r0, [pc, #40]	; (8007d60 <gsl_block_short_alloc+0x4c>)
 8007d38:	2308      	movs	r3, #8
 8007d3a:	221d      	movs	r2, #29
 8007d3c:	f7fa fd90 	bl	8002860 <gsl_error>
 8007d40:	e7f6      	b.n	8007d30 <gsl_block_short_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007d42:	2d00      	cmp	r5, #0
 8007d44:	d0f3      	beq.n	8007d2e <gsl_block_short_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007d46:	4620      	mov	r0, r4
 8007d48:	f028 f9b4 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007d4c:	4903      	ldr	r1, [pc, #12]	; (8007d5c <gsl_block_short_alloc+0x48>)
 8007d4e:	4805      	ldr	r0, [pc, #20]	; (8007d64 <gsl_block_short_alloc+0x50>)
 8007d50:	2308      	movs	r3, #8
 8007d52:	2227      	movs	r2, #39	; 0x27
 8007d54:	4634      	mov	r4, r6
 8007d56:	f7fa fd83 	bl	8002860 <gsl_error>
 8007d5a:	e7e9      	b.n	8007d30 <gsl_block_short_alloc+0x1c>
 8007d5c:	08030f9c 	.word	0x08030f9c
 8007d60:	08031154 	.word	0x08031154
 8007d64:	08031180 	.word	0x08031180

08007d68 <gsl_block_short_calloc>:
{
 8007d68:	b570      	push	{r4, r5, r6, lr}
 8007d6a:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007d6c:	f7ff ffd2 	bl	8007d14 <gsl_block_short_alloc>
  if (b == 0)
 8007d70:	4605      	mov	r5, r0
 8007d72:	b178      	cbz	r0, 8007d94 <gsl_block_short_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007d74:	0074      	lsls	r4, r6, #1
 8007d76:	6840      	ldr	r0, [r0, #4]
 8007d78:	4622      	mov	r2, r4
 8007d7a:	2100      	movs	r1, #0
 8007d7c:	f028 f9a2 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007d80:	b146      	cbz	r6, 8007d94 <gsl_block_short_calloc+0x2c>
      b->data[i] = 0;
 8007d82:	686b      	ldr	r3, [r5, #4]
 8007d84:	1ea2      	subs	r2, r4, #2
 8007d86:	441a      	add	r2, r3
 8007d88:	2100      	movs	r1, #0
 8007d8a:	3b02      	subs	r3, #2
 8007d8c:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007d90:	4293      	cmp	r3, r2
 8007d92:	d1fb      	bne.n	8007d8c <gsl_block_short_calloc+0x24>
}
 8007d94:	4628      	mov	r0, r5
 8007d96:	bd70      	pop	{r4, r5, r6, pc}

08007d98 <gsl_block_short_free>:
  RETURN_IF_NULL (b);
 8007d98:	b148      	cbz	r0, 8007dae <gsl_block_short_free+0x16>
{
 8007d9a:	b510      	push	{r4, lr}
 8007d9c:	4604      	mov	r4, r0
  free (b->data);
 8007d9e:	6840      	ldr	r0, [r0, #4]
 8007da0:	f028 f988 	bl	80300b4 <free>
  free (b);
 8007da4:	4620      	mov	r0, r4
}
 8007da6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007daa:	f028 b983 	b.w	80300b4 <free>
 8007dae:	4770      	bx	lr

08007db0 <gsl_block_uchar_alloc>:
{
 8007db0:	b570      	push	{r4, r5, r6, lr}
 8007db2:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007db4:	2008      	movs	r0, #8
 8007db6:	f028 f975 	bl	80300a4 <malloc>
  if (b == 0)
 8007dba:	4604      	mov	r4, r0
 8007dbc:	b140      	cbz	r0, 8007dd0 <gsl_block_uchar_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007dbe:	4628      	mov	r0, r5
 8007dc0:	f028 f970 	bl	80300a4 <malloc>
 8007dc4:	4606      	mov	r6, r0
 8007dc6:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007dc8:	b148      	cbz	r0, 8007dde <gsl_block_uchar_alloc+0x2e>
  b->size = n;
 8007dca:	6025      	str	r5, [r4, #0]
}
 8007dcc:	4620      	mov	r0, r4
 8007dce:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007dd0:	4909      	ldr	r1, [pc, #36]	; (8007df8 <gsl_block_uchar_alloc+0x48>)
 8007dd2:	480a      	ldr	r0, [pc, #40]	; (8007dfc <gsl_block_uchar_alloc+0x4c>)
 8007dd4:	2308      	movs	r3, #8
 8007dd6:	221d      	movs	r2, #29
 8007dd8:	f7fa fd42 	bl	8002860 <gsl_error>
 8007ddc:	e7f6      	b.n	8007dcc <gsl_block_uchar_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007dde:	2d00      	cmp	r5, #0
 8007de0:	d0f3      	beq.n	8007dca <gsl_block_uchar_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007de2:	4620      	mov	r0, r4
 8007de4:	f028 f966 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007de8:	4903      	ldr	r1, [pc, #12]	; (8007df8 <gsl_block_uchar_alloc+0x48>)
 8007dea:	4805      	ldr	r0, [pc, #20]	; (8007e00 <gsl_block_uchar_alloc+0x50>)
 8007dec:	2308      	movs	r3, #8
 8007dee:	2227      	movs	r2, #39	; 0x27
 8007df0:	4634      	mov	r4, r6
 8007df2:	f7fa fd35 	bl	8002860 <gsl_error>
 8007df6:	e7e9      	b.n	8007dcc <gsl_block_uchar_alloc+0x1c>
 8007df8:	08030f9c 	.word	0x08030f9c
 8007dfc:	08031154 	.word	0x08031154
 8007e00:	08031180 	.word	0x08031180

08007e04 <gsl_block_uchar_calloc>:
{
 8007e04:	b538      	push	{r3, r4, r5, lr}
 8007e06:	4605      	mov	r5, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007e08:	f7ff ffd2 	bl	8007db0 <gsl_block_uchar_alloc>
  if (b == 0)
 8007e0c:	4604      	mov	r4, r0
 8007e0e:	b160      	cbz	r0, 8007e2a <gsl_block_uchar_calloc+0x26>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007e10:	6840      	ldr	r0, [r0, #4]
 8007e12:	462a      	mov	r2, r5
 8007e14:	2100      	movs	r1, #0
 8007e16:	f028 f955 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007e1a:	b135      	cbz	r5, 8007e2a <gsl_block_uchar_calloc+0x26>
 8007e1c:	2300      	movs	r3, #0
      b->data[i] = 0;
 8007e1e:	461a      	mov	r2, r3
 8007e20:	6861      	ldr	r1, [r4, #4]
 8007e22:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007e24:	3301      	adds	r3, #1
 8007e26:	429d      	cmp	r5, r3
 8007e28:	d1fa      	bne.n	8007e20 <gsl_block_uchar_calloc+0x1c>
}
 8007e2a:	4620      	mov	r0, r4
 8007e2c:	bd38      	pop	{r3, r4, r5, pc}
 8007e2e:	bf00      	nop

08007e30 <gsl_block_uchar_free>:
  RETURN_IF_NULL (b);
 8007e30:	b148      	cbz	r0, 8007e46 <gsl_block_uchar_free+0x16>
{
 8007e32:	b510      	push	{r4, lr}
 8007e34:	4604      	mov	r4, r0
  free (b->data);
 8007e36:	6840      	ldr	r0, [r0, #4]
 8007e38:	f028 f93c 	bl	80300b4 <free>
  free (b);
 8007e3c:	4620      	mov	r0, r4
}
 8007e3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007e42:	f028 b937 	b.w	80300b4 <free>
 8007e46:	4770      	bx	lr

08007e48 <gsl_block_char_alloc>:
{
 8007e48:	b570      	push	{r4, r5, r6, lr}
 8007e4a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007e4c:	2008      	movs	r0, #8
 8007e4e:	f028 f929 	bl	80300a4 <malloc>
  if (b == 0)
 8007e52:	4604      	mov	r4, r0
 8007e54:	b140      	cbz	r0, 8007e68 <gsl_block_char_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007e56:	4628      	mov	r0, r5
 8007e58:	f028 f924 	bl	80300a4 <malloc>
 8007e5c:	4606      	mov	r6, r0
 8007e5e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007e60:	b148      	cbz	r0, 8007e76 <gsl_block_char_alloc+0x2e>
  b->size = n;
 8007e62:	6025      	str	r5, [r4, #0]
}
 8007e64:	4620      	mov	r0, r4
 8007e66:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007e68:	4909      	ldr	r1, [pc, #36]	; (8007e90 <gsl_block_char_alloc+0x48>)
 8007e6a:	480a      	ldr	r0, [pc, #40]	; (8007e94 <gsl_block_char_alloc+0x4c>)
 8007e6c:	2308      	movs	r3, #8
 8007e6e:	221d      	movs	r2, #29
 8007e70:	f7fa fcf6 	bl	8002860 <gsl_error>
 8007e74:	e7f6      	b.n	8007e64 <gsl_block_char_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007e76:	2d00      	cmp	r5, #0
 8007e78:	d0f3      	beq.n	8007e62 <gsl_block_char_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007e7a:	4620      	mov	r0, r4
 8007e7c:	f028 f91a 	bl	80300b4 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007e80:	4903      	ldr	r1, [pc, #12]	; (8007e90 <gsl_block_char_alloc+0x48>)
 8007e82:	4805      	ldr	r0, [pc, #20]	; (8007e98 <gsl_block_char_alloc+0x50>)
 8007e84:	2308      	movs	r3, #8
 8007e86:	2227      	movs	r2, #39	; 0x27
 8007e88:	4634      	mov	r4, r6
 8007e8a:	f7fa fce9 	bl	8002860 <gsl_error>
 8007e8e:	e7e9      	b.n	8007e64 <gsl_block_char_alloc+0x1c>
 8007e90:	08030f9c 	.word	0x08030f9c
 8007e94:	08031154 	.word	0x08031154
 8007e98:	08031180 	.word	0x08031180

08007e9c <gsl_block_char_calloc>:
{
 8007e9c:	b538      	push	{r3, r4, r5, lr}
 8007e9e:	4605      	mov	r5, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007ea0:	f7ff ffd2 	bl	8007e48 <gsl_block_char_alloc>
  if (b == 0)
 8007ea4:	4604      	mov	r4, r0
 8007ea6:	b160      	cbz	r0, 8007ec2 <gsl_block_char_calloc+0x26>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007ea8:	6840      	ldr	r0, [r0, #4]
 8007eaa:	462a      	mov	r2, r5
 8007eac:	2100      	movs	r1, #0
 8007eae:	f028 f909 	bl	80300c4 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007eb2:	b135      	cbz	r5, 8007ec2 <gsl_block_char_calloc+0x26>
 8007eb4:	2300      	movs	r3, #0
      b->data[i] = 0;
 8007eb6:	461a      	mov	r2, r3
 8007eb8:	6861      	ldr	r1, [r4, #4]
 8007eba:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007ebc:	3301      	adds	r3, #1
 8007ebe:	429d      	cmp	r5, r3
 8007ec0:	d1fa      	bne.n	8007eb8 <gsl_block_char_calloc+0x1c>
}
 8007ec2:	4620      	mov	r0, r4
 8007ec4:	bd38      	pop	{r3, r4, r5, pc}
 8007ec6:	bf00      	nop

08007ec8 <gsl_block_char_free>:
  RETURN_IF_NULL (b);
 8007ec8:	b148      	cbz	r0, 8007ede <gsl_block_char_free+0x16>
{
 8007eca:	b510      	push	{r4, lr}
 8007ecc:	4604      	mov	r4, r0
  free (b->data);
 8007ece:	6840      	ldr	r0, [r0, #4]
 8007ed0:	f028 f8f0 	bl	80300b4 <free>
  free (b);
 8007ed4:	4620      	mov	r0, r4
}
 8007ed6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007eda:	f028 b8eb 	b.w	80300b4 <free>
 8007ede:	4770      	bx	lr

08007ee0 <cblas_sasum>:
{
  BASE r = 0.0;
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 8007ee0:	2a00      	cmp	r2, #0
    return 0;
 8007ee2:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8007f0c <cblas_sasum+0x2c>
  if (incX <= 0) {
 8007ee6:	dd0e      	ble.n	8007f06 <cblas_sasum+0x26>
  }

  for (i = 0; i < N; i++) {
 8007ee8:	2800      	cmp	r0, #0
 8007eea:	dd0d      	ble.n	8007f08 <cblas_sasum+0x28>
 8007eec:	0092      	lsls	r2, r2, #2
 8007eee:	2300      	movs	r3, #0
    r += fabs(X[ix]);
 8007ef0:	edd1 7a00 	vldr	s15, [r1]
  for (i = 0; i < N; i++) {
 8007ef4:	3301      	adds	r3, #1
    r += fabs(X[ix]);
 8007ef6:	eef0 7ae7 	vabs.f32	s15, s15
  for (i = 0; i < N; i++) {
 8007efa:	4298      	cmp	r0, r3
    r += fabs(X[ix]);
 8007efc:	ee30 0a27 	vadd.f32	s0, s0, s15
  for (i = 0; i < N; i++) {
 8007f00:	4411      	add	r1, r2
 8007f02:	d1f5      	bne.n	8007ef0 <cblas_sasum+0x10>
 8007f04:	4770      	bx	lr
 8007f06:	4770      	bx	lr
cblas_sasum (const int N, const float *X, const int incX)
{
#define BASE float
#include "source_asum_r.h"
#undef BASE
}
 8007f08:	4770      	bx	lr
 8007f0a:	bf00      	nop
 8007f0c:	00000000 	.word	0x00000000

08007f10 <cblas_saxpy>:
 */

{
  INDEX i;

  if (alpha == 0.0) {
 8007f10:	eeb5 0a40 	vcmp.f32	s0, #0.0
#include "cblas.h"

void
cblas_saxpy (const int N, const float alpha, const float *X, const int incX,
             float *Y, const int incY)
{
 8007f14:	b470      	push	{r4, r5, r6}
 8007f16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007f1a:	9d03      	ldr	r5, [sp, #12]
 8007f1c:	d023      	beq.n	8007f66 <cblas_saxpy+0x56>
    return;
  }

  if (incX == 1 && incY == 1) {
 8007f1e:	2a01      	cmp	r2, #1
 8007f20:	d023      	beq.n	8007f6a <cblas_saxpy+0x5a>
      Y[i + 1] += alpha * X[i + 1];
      Y[i + 2] += alpha * X[i + 2];
      Y[i + 3] += alpha * X[i + 3];
    }
  } else {
    INDEX ix = OFFSET(N, incX);
 8007f22:	2a00      	cmp	r2, #0
 8007f24:	dc23      	bgt.n	8007f6e <cblas_saxpy+0x5e>
 8007f26:	f1c0 0601 	rsb	r6, r0, #1
 8007f2a:	fb06 f602 	mul.w	r6, r6, r2
    INDEX iy = OFFSET(N, incY);
 8007f2e:	2d00      	cmp	r5, #0
 8007f30:	bfda      	itte	le
 8007f32:	f1c0 0401 	rsble	r4, r0, #1
 8007f36:	436c      	mulle	r4, r5
 8007f38:	2400      	movgt	r4, #0

    for (i = 0; i < N; i++) {
 8007f3a:	2800      	cmp	r0, #0
 8007f3c:	dd13      	ble.n	8007f66 <cblas_saxpy+0x56>
 8007f3e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8007f42:	00ad      	lsls	r5, r5, #2
 8007f44:	0094      	lsls	r4, r2, #2
 8007f46:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 8007f4a:	2200      	movs	r2, #0
      Y[iy] += alpha * X[ix];
 8007f4c:	ed91 7a00 	vldr	s14, [r1]
 8007f50:	edd3 7a00 	vldr	s15, [r3]
 8007f54:	eee7 7a00 	vfma.f32	s15, s14, s0
    for (i = 0; i < N; i++) {
 8007f58:	3201      	adds	r2, #1
 8007f5a:	4290      	cmp	r0, r2
 8007f5c:	4421      	add	r1, r4
      Y[iy] += alpha * X[ix];
 8007f5e:	edc3 7a00 	vstr	s15, [r3]
    for (i = 0; i < N; i++) {
 8007f62:	442b      	add	r3, r5
 8007f64:	d1f2      	bne.n	8007f4c <cblas_saxpy+0x3c>
#define BASE float
#include "source_axpy_r.h"
#undef BASE
}
 8007f66:	bc70      	pop	{r4, r5, r6}
 8007f68:	4770      	bx	lr
  if (incX == 1 && incY == 1) {
 8007f6a:	2d01      	cmp	r5, #1
 8007f6c:	d001      	beq.n	8007f72 <cblas_saxpy+0x62>
    INDEX ix = OFFSET(N, incX);
 8007f6e:	2600      	movs	r6, #0
 8007f70:	e7dd      	b.n	8007f2e <cblas_saxpy+0x1e>
    const INDEX m = N % 4;
 8007f72:	4244      	negs	r4, r0
 8007f74:	f004 0403 	and.w	r4, r4, #3
 8007f78:	f000 0203 	and.w	r2, r0, #3
 8007f7c:	bf58      	it	pl
 8007f7e:	4262      	negpl	r2, r4
    for (i = 0; i < m; i++) {
 8007f80:	2a00      	cmp	r2, #0
 8007f82:	dd0d      	ble.n	8007fa0 <cblas_saxpy+0x90>
 8007f84:	461c      	mov	r4, r3
 8007f86:	460d      	mov	r5, r1
 8007f88:	eb03 0682 	add.w	r6, r3, r2, lsl #2
      Y[i] += alpha * X[i];
 8007f8c:	edd4 7a00 	vldr	s15, [r4]
 8007f90:	ecb5 7a01 	vldmia	r5!, {s14}
 8007f94:	eee7 7a00 	vfma.f32	s15, s14, s0
 8007f98:	ece4 7a01 	vstmia	r4!, {s15}
    for (i = 0; i < m; i++) {
 8007f9c:	42a6      	cmp	r6, r4
 8007f9e:	d1f5      	bne.n	8007f8c <cblas_saxpy+0x7c>
    for (i = m; i + 3 < N; i += 4) {
 8007fa0:	1cd4      	adds	r4, r2, #3
 8007fa2:	42a0      	cmp	r0, r4
 8007fa4:	dddf      	ble.n	8007f66 <cblas_saxpy+0x56>
 8007fa6:	1f04      	subs	r4, r0, #4
 8007fa8:	1aa4      	subs	r4, r4, r2
 8007faa:	f024 0403 	bic.w	r4, r4, #3
 8007fae:	f103 0010 	add.w	r0, r3, #16
 8007fb2:	4414      	add	r4, r2
 8007fb4:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8007fb8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8007fbc:	eb00 0284 	add.w	r2, r0, r4, lsl #2
      Y[i] += alpha * X[i];
 8007fc0:	edd1 5a00 	vldr	s11, [r1]
 8007fc4:	ed93 6a00 	vldr	s12, [r3]
      Y[i + 1] += alpha * X[i + 1];
 8007fc8:	edd3 6a01 	vldr	s13, [r3, #4]
      Y[i + 2] += alpha * X[i + 2];
 8007fcc:	ed93 7a02 	vldr	s14, [r3, #8]
      Y[i + 3] += alpha * X[i + 3];
 8007fd0:	edd3 7a03 	vldr	s15, [r3, #12]
      Y[i] += alpha * X[i];
 8007fd4:	eea5 6a80 	vfma.f32	s12, s11, s0
 8007fd8:	3310      	adds	r3, #16
 8007fda:	3110      	adds	r1, #16
 8007fdc:	ed03 6a04 	vstr	s12, [r3, #-16]
      Y[i + 1] += alpha * X[i + 1];
 8007fe0:	ed11 6a03 	vldr	s12, [r1, #-12]
 8007fe4:	eee6 6a00 	vfma.f32	s13, s12, s0
 8007fe8:	ed43 6a03 	vstr	s13, [r3, #-12]
      Y[i + 2] += alpha * X[i + 2];
 8007fec:	ed51 6a02 	vldr	s13, [r1, #-8]
 8007ff0:	eea6 7a80 	vfma.f32	s14, s13, s0
 8007ff4:	ed03 7a02 	vstr	s14, [r3, #-8]
      Y[i + 3] += alpha * X[i + 3];
 8007ff8:	ed11 7a01 	vldr	s14, [r1, #-4]
 8007ffc:	eee7 7a00 	vfma.f32	s15, s14, s0
 8008000:	ed43 7a01 	vstr	s15, [r3, #-4]
    for (i = m; i + 3 < N; i += 4) {
 8008004:	4293      	cmp	r3, r2
 8008006:	d1db      	bne.n	8007fc0 <cblas_saxpy+0xb0>
 8008008:	e7ad      	b.n	8007f66 <cblas_saxpy+0x56>
 800800a:	bf00      	nop

0800800c <cblas_scasum>:
{
  BASE r = 0.0;
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 800800c:	2a00      	cmp	r2, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

float
cblas_scasum (const int N, const void *X, const int incX)
{
 800800e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008012:	dd36      	ble.n	8008082 <cblas_scasum+0x76>
    return 0;
  }

  for (i = 0; i < N; i++) {
 8008014:	2800      	cmp	r0, #0
 8008016:	4681      	mov	r9, r0
  BASE r = 0.0;
 8008018:	f04f 0a00 	mov.w	sl, #0
  for (i = 0; i < N; i++) {
 800801c:	dd2d      	ble.n	800807a <cblas_scasum+0x6e>
 800801e:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 8008022:	460c      	mov	r4, r1
 8008024:	2500      	movs	r5, #0
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 8008026:	edd4 7a00 	vldr	s15, [r4]
 800802a:	eef0 7ae7 	vabs.f32	s15, s15
 800802e:	ee17 0a90 	vmov	r0, s15
 8008032:	f020 fd41 	bl	8028ab8 <__aeabi_f2d>
 8008036:	edd4 7a01 	vldr	s15, [r4, #4]
 800803a:	eef0 7ae7 	vabs.f32	s15, s15
 800803e:	4606      	mov	r6, r0
 8008040:	ee17 0a90 	vmov	r0, s15
 8008044:	460f      	mov	r7, r1
 8008046:	f020 fd37 	bl	8028ab8 <__aeabi_f2d>
 800804a:	4602      	mov	r2, r0
 800804c:	460b      	mov	r3, r1
 800804e:	4630      	mov	r0, r6
 8008050:	4639      	mov	r1, r7
 8008052:	f020 fbd3 	bl	80287fc <__adddf3>
 8008056:	4606      	mov	r6, r0
 8008058:	4650      	mov	r0, sl
 800805a:	460f      	mov	r7, r1
 800805c:	f020 fd2c 	bl	8028ab8 <__aeabi_f2d>
 8008060:	4602      	mov	r2, r0
 8008062:	460b      	mov	r3, r1
 8008064:	4630      	mov	r0, r6
 8008066:	4639      	mov	r1, r7
 8008068:	f020 fbc8 	bl	80287fc <__adddf3>
 800806c:	f021 f82c 	bl	80290c8 <__aeabi_d2f>
  for (i = 0; i < N; i++) {
 8008070:	3501      	adds	r5, #1
 8008072:	45a9      	cmp	r9, r5
 8008074:	4444      	add	r4, r8
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 8008076:	4682      	mov	sl, r0
  for (i = 0; i < N; i++) {
 8008078:	d1d5      	bne.n	8008026 <cblas_scasum+0x1a>
#define BASE float
#include "source_asum_c.h"
#undef BASE
}
 800807a:	ee00 aa10 	vmov	s0, sl
 800807e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return 0;
 8008082:	f04f 0a00 	mov.w	sl, #0
 8008086:	ee00 aa10 	vmov	s0, sl
 800808a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800808e:	bf00      	nop

08008090 <cblas_scnrm2>:
  BASE scale = 0.0;
  BASE ssq = 1.0;
  INDEX i;
  INDEX ix = 0;

  if (N == 0 || incX < 1) {
 8008090:	2800      	cmp	r0, #0
 8008092:	d06a      	beq.n	800816a <cblas_scnrm2+0xda>
 8008094:	2a00      	cmp	r2, #0
 8008096:	dd68      	ble.n	800816a <cblas_scnrm2+0xda>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

float
cblas_scnrm2 (const int N, const void *X, const int incX)
{
 8008098:	b538      	push	{r3, r4, r5, lr}
    return 0;
  }

  for (i = 0; i < N; i++) {
 800809a:	2800      	cmp	r0, #0
 800809c:	ed2d 8b02 	vpush	{d8}
 80080a0:	dd6b      	ble.n	800817a <cblas_scnrm2+0xea>
  BASE ssq = 1.0;
 80080a2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
  BASE scale = 0.0;
 80080a6:	eddf 6a3a 	vldr	s13, [pc, #232]	; 8008190 <cblas_scnrm2+0x100>

    if (x != 0.0) {
      const BASE ax = fabs(x);

      if (scale < ax) {
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80080aa:	eef0 5a48 	vmov.f32	s11, s16
 80080ae:	00d2      	lsls	r2, r2, #3
  for (i = 0; i < N; i++) {
 80080b0:	2300      	movs	r3, #0
 80080b2:	e00f      	b.n	80080d4 <cblas_scnrm2+0x44>

    if (y != 0.0) {
      const BASE ay = fabs(y);

      if (scale < ay) {
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 80080b4:	eec6 7a87 	vdiv.f32	s15, s13, s14
        scale = ay;
 80080b8:	eef0 6a47 	vmov.f32	s13, s14
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 80080bc:	ee27 8a88 	vmul.f32	s16, s15, s16
 80080c0:	eeb0 7a65 	vmov.f32	s14, s11
 80080c4:	eea7 7a88 	vfma.f32	s14, s15, s16
 80080c8:	eeb0 8a47 	vmov.f32	s16, s14
  for (i = 0; i < N; i++) {
 80080cc:	3301      	adds	r3, #1
 80080ce:	4298      	cmp	r0, r3
 80080d0:	4411      	add	r1, r2
 80080d2:	d02f      	beq.n	8008134 <cblas_scnrm2+0xa4>
    const BASE x = CONST_REAL(X, ix);
 80080d4:	ed91 7a00 	vldr	s14, [r1]
    const BASE y = CONST_IMAG(X, ix);
 80080d8:	edd1 7a01 	vldr	s15, [r1, #4]
    if (x != 0.0) {
 80080dc:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80080e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      const BASE ax = fabs(x);
 80080e4:	eeb0 6ac7 	vabs.f32	s12, s14
    if (x != 0.0) {
 80080e8:	d010      	beq.n	800810c <cblas_scnrm2+0x7c>
      if (scale < ax) {
 80080ea:	eeb4 6ae6 	vcmpe.f32	s12, s13
 80080ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80080f2:	dd3d      	ble.n	8008170 <cblas_scnrm2+0xe0>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80080f4:	ee86 7a86 	vdiv.f32	s14, s13, s12
        scale = ax;
 80080f8:	eef0 6a46 	vmov.f32	s13, s12
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80080fc:	ee27 8a08 	vmul.f32	s16, s14, s16
 8008100:	eeb0 6a65 	vmov.f32	s12, s11
 8008104:	eea7 6a08 	vfma.f32	s12, s14, s16
 8008108:	eeb0 8a46 	vmov.f32	s16, s12
    if (y != 0.0) {
 800810c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008110:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      const BASE ay = fabs(y);
 8008114:	eeb0 7ae7 	vabs.f32	s14, s15
    if (y != 0.0) {
 8008118:	d0d8      	beq.n	80080cc <cblas_scnrm2+0x3c>
      if (scale < ay) {
 800811a:	eef4 6ac7 	vcmpe.f32	s13, s14
 800811e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008122:	d4c7      	bmi.n	80080b4 <cblas_scnrm2+0x24>
      } else {
        ssq += (ay / scale) * (ay / scale);
 8008124:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  for (i = 0; i < N; i++) {
 8008128:	3301      	adds	r3, #1
 800812a:	4298      	cmp	r0, r3
 800812c:	4411      	add	r1, r2
        ssq += (ay / scale) * (ay / scale);
 800812e:	eea7 8a07 	vfma.f32	s16, s14, s14
  for (i = 0; i < N; i++) {
 8008132:	d1cf      	bne.n	80080d4 <cblas_scnrm2+0x44>
 8008134:	ee16 0a90 	vmov	r0, s13
 8008138:	f020 fcbe 	bl	8028ab8 <__aeabi_f2d>
 800813c:	4604      	mov	r4, r0
 800813e:	ee18 0a10 	vmov	r0, s16
 8008142:	460d      	mov	r5, r1
 8008144:	f020 fcb8 	bl	8028ab8 <__aeabi_f2d>
 8008148:	ec41 0b10 	vmov	d0, r0, r1
    }

    ix += incX;
  }

  return scale * sqrt(ssq);
 800814c:	f028 fd62 	bl	8030c14 <sqrt>
 8008150:	4622      	mov	r2, r4
 8008152:	ec51 0b10 	vmov	r0, r1, d0
 8008156:	462b      	mov	r3, r5
 8008158:	f020 fd06 	bl	8028b68 <__aeabi_dmul>
 800815c:	f020 ffb4 	bl	80290c8 <__aeabi_d2f>
#define BASE float
#include "source_nrm2_c.h"
#undef BASE
}
 8008160:	ecbd 8b02 	vpop	{d8}
 8008164:	ee00 0a10 	vmov	s0, r0
 8008168:	bd38      	pop	{r3, r4, r5, pc}
    return 0;
 800816a:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8008190 <cblas_scnrm2+0x100>
 800816e:	4770      	bx	lr
        ssq += (ax / scale) * (ax / scale);
 8008170:	ee87 6a26 	vdiv.f32	s12, s14, s13
 8008174:	eea6 8a06 	vfma.f32	s16, s12, s12
 8008178:	e7c8      	b.n	800810c <cblas_scnrm2+0x7c>
  for (i = 0; i < N; i++) {
 800817a:	ed9f 0b03 	vldr	d0, [pc, #12]	; 8008188 <cblas_scnrm2+0xf8>
 800817e:	2400      	movs	r4, #0
 8008180:	2500      	movs	r5, #0
 8008182:	e7e3      	b.n	800814c <cblas_scnrm2+0xbc>
 8008184:	f3af 8000 	nop.w
 8008188:	00000000 	.word	0x00000000
 800818c:	3ff00000 	.word	0x3ff00000
 8008190:	00000000 	.word	0x00000000

08008194 <cblas_scopy>:
#include "cblas.h"

void
cblas_scopy (const int N, const float *X, const int incX, float *Y,
             const int incY)
{
 8008194:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 8008196:	2a00      	cmp	r2, #0
 8008198:	9e04      	ldr	r6, [sp, #16]
 800819a:	bfda      	itte	le
 800819c:	f1c0 0701 	rsble	r7, r0, #1
 80081a0:	4357      	mulle	r7, r2
 80081a2:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 80081a4:	2e00      	cmp	r6, #0
 80081a6:	bfda      	itte	le
 80081a8:	f1c0 0401 	rsble	r4, r0, #1
 80081ac:	4374      	mulle	r4, r6
 80081ae:	2400      	movgt	r4, #0

  for (i = 0; i < N; i++) {
 80081b0:	2800      	cmp	r0, #0
 80081b2:	dd0d      	ble.n	80081d0 <cblas_scopy+0x3c>
 80081b4:	0095      	lsls	r5, r2, #2
 80081b6:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 80081ba:	00b6      	lsls	r6, r6, #2
 80081bc:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80081c0:	2200      	movs	r2, #0
 80081c2:	3201      	adds	r2, #1
    Y[iy] = X[ix];
 80081c4:	680c      	ldr	r4, [r1, #0]
 80081c6:	601c      	str	r4, [r3, #0]
  for (i = 0; i < N; i++) {
 80081c8:	4290      	cmp	r0, r2
 80081ca:	4429      	add	r1, r5
 80081cc:	4433      	add	r3, r6
 80081ce:	d1f8      	bne.n	80081c2 <cblas_scopy+0x2e>
#define BASE float
#include "source_copy_r.h"
#undef BASE
}
 80081d0:	bcf0      	pop	{r4, r5, r6, r7}
 80081d2:	4770      	bx	lr

080081d4 <cblas_sdot>:
#include "cblas.h"

float
cblas_sdot (const int N, const float *X, const int incX, const float *Y,
            const int incY)
{
 80081d4:	b4f0      	push	{r4, r5, r6, r7}
 */

{
  ACC_TYPE r = INIT_VAL;
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80081d6:	2a00      	cmp	r2, #0
 80081d8:	9d04      	ldr	r5, [sp, #16]
  INDEX iy = OFFSET(N, incY);

  for (i = 0; i < N; i++) {
 80081da:	ed9f 0a11 	vldr	s0, [pc, #68]	; 8008220 <cblas_sdot+0x4c>
  INDEX ix = OFFSET(N, incX);
 80081de:	bfda      	itte	le
 80081e0:	f1c0 0701 	rsble	r7, r0, #1
 80081e4:	4357      	mulle	r7, r2
 80081e6:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 80081e8:	2d00      	cmp	r5, #0
 80081ea:	bfda      	itte	le
 80081ec:	f1c0 0601 	rsble	r6, r0, #1
 80081f0:	436e      	mulle	r6, r5
 80081f2:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 80081f4:	2800      	cmp	r0, #0
 80081f6:	dd11      	ble.n	800821c <cblas_sdot+0x48>
 80081f8:	0094      	lsls	r4, r2, #2
 80081fa:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 80081fe:	00ad      	lsls	r5, r5, #2
 8008200:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8008204:	2200      	movs	r2, #0
    r += X[ix] * Y[iy];
 8008206:	ed91 7a00 	vldr	s14, [r1]
 800820a:	edd3 7a00 	vldr	s15, [r3]
  for (i = 0; i < N; i++) {
 800820e:	3201      	adds	r2, #1
 8008210:	4290      	cmp	r0, r2
    r += X[ix] * Y[iy];
 8008212:	eea7 0a27 	vfma.f32	s0, s14, s15
  for (i = 0; i < N; i++) {
 8008216:	4421      	add	r1, r4
 8008218:	442b      	add	r3, r5
 800821a:	d1f4      	bne.n	8008206 <cblas_sdot+0x32>
#define BASE float
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 800821c:	bcf0      	pop	{r4, r5, r6, r7}
 800821e:	4770      	bx	lr
 8008220:	00000000 	.word	0x00000000

08008224 <cblas_sdsdot>:
#include "cblas.h"

float
cblas_sdsdot (const int N, const float alpha, const float *X, const int incX,
              const float *Y, const int incY)
{
 8008224:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008228:	4682      	mov	sl, r0
  ACC_TYPE r = INIT_VAL;
 800822a:	ee10 0a10 	vmov	r0, s0
 800822e:	4691      	mov	r9, r2
 8008230:	461e      	mov	r6, r3
 8008232:	ee10 8a10 	vmov	r8, s0
 8008236:	460f      	mov	r7, r1
 8008238:	f020 fc3e 	bl	8028ab8 <__aeabi_f2d>
  INDEX ix = OFFSET(N, incX);
 800823c:	f1b9 0f00 	cmp.w	r9, #0
 8008240:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  ACC_TYPE r = INIT_VAL;
 8008242:	460d      	mov	r5, r1
  INDEX ix = OFFSET(N, incX);
 8008244:	bfda      	itte	le
 8008246:	f1ca 0101 	rsble	r1, sl, #1
 800824a:	fb01 f109 	mulle.w	r1, r1, r9
 800824e:	2100      	movgt	r1, #0
  INDEX iy = OFFSET(N, incY);
 8008250:	2b00      	cmp	r3, #0
 8008252:	bfda      	itte	le
 8008254:	f1ca 0201 	rsble	r2, sl, #1
 8008258:	435a      	mulle	r2, r3
 800825a:	2200      	movgt	r2, #0
  for (i = 0; i < N; i++) {
 800825c:	f1ba 0f00 	cmp.w	sl, #0
  ACC_TYPE r = INIT_VAL;
 8008260:	4604      	mov	r4, r0
  for (i = 0; i < N; i++) {
 8008262:	dd27      	ble.n	80082b4 <cblas_sdsdot+0x90>
 8008264:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8008268:	eb07 0781 	add.w	r7, r7, r1, lsl #2
 800826c:	ea4f 0b83 	mov.w	fp, r3, lsl #2
 8008270:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 8008274:	f04f 0800 	mov.w	r8, #0
    r += X[ix] * Y[iy];
 8008278:	ed97 7a00 	vldr	s14, [r7]
 800827c:	edd6 7a00 	vldr	s15, [r6]
 8008280:	ee67 7a27 	vmul.f32	s15, s14, s15
  for (i = 0; i < N; i++) {
 8008284:	f108 0801 	add.w	r8, r8, #1
    r += X[ix] * Y[iy];
 8008288:	ee17 0a90 	vmov	r0, s15
 800828c:	f020 fc14 	bl	8028ab8 <__aeabi_f2d>
 8008290:	4602      	mov	r2, r0
 8008292:	460b      	mov	r3, r1
 8008294:	4620      	mov	r0, r4
 8008296:	4629      	mov	r1, r5
 8008298:	f020 fab0 	bl	80287fc <__adddf3>
  for (i = 0; i < N; i++) {
 800829c:	45c2      	cmp	sl, r8
    r += X[ix] * Y[iy];
 800829e:	4604      	mov	r4, r0
 80082a0:	460d      	mov	r5, r1
 80082a2:	444f      	add	r7, r9
 80082a4:	445e      	add	r6, fp
  for (i = 0; i < N; i++) {
 80082a6:	d1e7      	bne.n	8008278 <cblas_sdsdot+0x54>
 80082a8:	f020 ff0e 	bl	80290c8 <__aeabi_d2f>
 80082ac:	ee00 0a10 	vmov	s0, r0
#define BASE float
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 80082b0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80082b4:	ee00 8a10 	vmov	s0, r8
 80082b8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080082bc <cblas_sgemm>:
cblas_sgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const float alpha, const float *A, const int lda,
             const float *B, const int ldb, const float beta, float *C,
             const int ldc)
{
 80082bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80082c0:	ed2d 8b02 	vpush	{d8}
 80082c4:	b089      	sub	sp, #36	; 0x24
 80082c6:	461d      	mov	r5, r3
 80082c8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80082ca:	9304      	str	r3, [sp, #16]
 80082cc:	e9dd 8317 	ldrd	r8, r3, [sp, #92]	; 0x5c
 80082d0:	9303      	str	r3, [sp, #12]
 80082d2:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80082d4:	9302      	str	r3, [sp, #8]
  INDEX n1, n2;
  INDEX ldf, ldg;
  int TransF, TransG;
  const BASE *F, *G;

  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80082d6:	2865      	cmp	r0, #101	; 0x65
 80082d8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80082da:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 80082de:	9301      	str	r3, [sp, #4]
 80082e0:	e9dd 6714 	ldrd	r6, r7, [sp, #80]	; 0x50
 80082e4:	4682      	mov	sl, r0
 80082e6:	460c      	mov	r4, r1
 80082e8:	4693      	mov	fp, r2
 80082ea:	eeb0 8a40 	vmov.f32	s16, s0
 80082ee:	eef0 8a60 	vmov.f32	s17, s1
 80082f2:	f000 8106 	beq.w	8008502 <cblas_sgemm+0x246>
 80082f6:	2a71      	cmp	r2, #113	; 0x71
 80082f8:	bf08      	it	eq
 80082fa:	2270      	moveq	r2, #112	; 0x70
 80082fc:	2971      	cmp	r1, #113	; 0x71
 80082fe:	d069      	beq.n	80083d4 <cblas_sgemm+0x118>
 8008300:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8008304:	b2db      	uxtb	r3, r3
 8008306:	2b02      	cmp	r3, #2
 8008308:	d970      	bls.n	80083ec <cblas_sgemm+0x130>
 800830a:	2002      	movs	r0, #2
 800830c:	f1ab 036f 	sub.w	r3, fp, #111	; 0x6f
 8008310:	2b02      	cmp	r3, #2
 8008312:	bf88      	it	hi
 8008314:	2003      	movhi	r0, #3
 8008316:	2d00      	cmp	r5, #0
 8008318:	bfb8      	it	lt
 800831a:	2004      	movlt	r0, #4
 800831c:	2e00      	cmp	r6, #0
 800831e:	f2c0 80c8 	blt.w	80084b2 <cblas_sgemm+0x1f6>
 8008322:	2f00      	cmp	r7, #0
 8008324:	db69      	blt.n	80083fa <cblas_sgemm+0x13e>
 8008326:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 800832a:	f000 80c9 	beq.w	80084c0 <cblas_sgemm+0x204>
 800832e:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8008332:	d06a      	beq.n	800840a <cblas_sgemm+0x14e>
 8008334:	2800      	cmp	r0, #0
 8008336:	f040 8085 	bne.w	8008444 <cblas_sgemm+0x188>

  if (alpha == 0.0 && beta == 1.0)
 800833a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800833e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008342:	d107      	bne.n	8008354 <cblas_sgemm+0x98>
 8008344:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008348:	eef4 8a67 	vcmp.f32	s17, s15
 800834c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008350:	f000 8087 	beq.w	8008462 <cblas_sgemm+0x1a6>
    return;

  if (Order == CblasRowMajor) {
 8008354:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8008358:	f000 80e1 	beq.w	800851e <cblas_sgemm+0x262>
  } else {
    n1 = N;
    n2 = M;
    F = B;
    ldf = ldb;
    TransF = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800835c:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8008360:	bf14      	ite	ne
 8008362:	4659      	movne	r1, fp
 8008364:	2170      	moveq	r1, #112	; 0x70
    G = A;
    ldg = lda;
    TransG = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 8008366:	2c71      	cmp	r4, #113	; 0x71
 8008368:	bf14      	ite	ne
 800836a:	46a3      	movne	fp, r4
 800836c:	f04f 0b70 	moveq.w	fp, #112	; 0x70
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 8008370:	eef5 8a40 	vcmp.f32	s17, #0.0
 8008374:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008378:	d178      	bne.n	800846c <cblas_sgemm+0x1b0>
    for (i = 0; i < n1; i++) {
 800837a:	2e00      	cmp	r6, #0
 800837c:	dd16      	ble.n	80083ac <cblas_sgemm+0xf0>
 800837e:	9b01      	ldr	r3, [sp, #4]
 8008380:	ebc5 7485 	rsb	r4, r5, r5, lsl #30
 8008384:	00a4      	lsls	r4, r4, #2
 8008386:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 800838a:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 800838e:	2000      	movs	r0, #0
      for (j = 0; j < n2; j++) {
        C[ldc * i + j] = 0.0;
 8008390:	f04f 0e00 	mov.w	lr, #0
      for (j = 0; j < n2; j++) {
 8008394:	2d00      	cmp	r5, #0
 8008396:	bfc8      	it	gt
 8008398:	1913      	addgt	r3, r2, r4
 800839a:	dd03      	ble.n	80083a4 <cblas_sgemm+0xe8>
        C[ldc * i + j] = 0.0;
 800839c:	f843 eb04 	str.w	lr, [r3], #4
      for (j = 0; j < n2; j++) {
 80083a0:	4293      	cmp	r3, r2
 80083a2:	d1fb      	bne.n	800839c <cblas_sgemm+0xe0>
    for (i = 0; i < n1; i++) {
 80083a4:	3001      	adds	r0, #1
 80083a6:	4286      	cmp	r6, r0
 80083a8:	4462      	add	r2, ip
 80083aa:	d1f3      	bne.n	8008394 <cblas_sgemm+0xd8>
        C[ldc * i + j] *= beta;
      }
    }
  }

  if (alpha == 0.0)
 80083ac:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80083b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80083b4:	d055      	beq.n	8008462 <cblas_sgemm+0x1a6>
    return;

  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 80083b6:	296f      	cmp	r1, #111	; 0x6f
 80083b8:	d049      	beq.n	800844e <cblas_sgemm+0x192>
        }
        C[ldc * i + j] += alpha * temp;
      }
    }

  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 80083ba:	2970      	cmp	r1, #112	; 0x70
 80083bc:	f000 80c2 	beq.w	8008544 <cblas_sgemm+0x288>
        C[ldc * i + j] += alpha * temp;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 80083c0:	4ab1      	ldr	r2, [pc, #708]	; (8008688 <cblas_sgemm+0x3cc>)
 80083c2:	49b2      	ldr	r1, [pc, #712]	; (800868c <cblas_sgemm+0x3d0>)
 80083c4:	2000      	movs	r0, #0
#define BASE float
#include "source_gemm_r.h"
#undef BASE
}
 80083c6:	b009      	add	sp, #36	; 0x24
 80083c8:	ecbd 8b02 	vpop	{d8}
 80083cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80083d0:	f020 b99a 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80083d4:	3865      	subs	r0, #101	; 0x65
 80083d6:	2801      	cmp	r0, #1
 80083d8:	bf94      	ite	ls
 80083da:	2000      	movls	r0, #0
 80083dc:	2001      	movhi	r0, #1
 80083de:	2170      	movs	r1, #112	; 0x70
 80083e0:	e794      	b.n	800830c <cblas_sgemm+0x50>
 80083e2:	2a71      	cmp	r2, #113	; 0x71
 80083e4:	f000 8208 	beq.w	80087f8 <cblas_sgemm+0x53c>
 80083e8:	4659      	mov	r1, fp
 80083ea:	2270      	movs	r2, #112	; 0x70
 80083ec:	f1aa 0065 	sub.w	r0, sl, #101	; 0x65
 80083f0:	2801      	cmp	r0, #1
 80083f2:	bf94      	ite	ls
 80083f4:	2000      	movls	r0, #0
 80083f6:	2001      	movhi	r0, #1
 80083f8:	e788      	b.n	800830c <cblas_sgemm+0x50>
 80083fa:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80083fe:	f04f 0006 	mov.w	r0, #6
 8008402:	d05d      	beq.n	80084c0 <cblas_sgemm+0x204>
 8008404:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8008408:	d11c      	bne.n	8008444 <cblas_sgemm+0x188>
 800840a:	2a6f      	cmp	r2, #111	; 0x6f
 800840c:	bf0c      	ite	eq
 800840e:	463b      	moveq	r3, r7
 8008410:	4633      	movne	r3, r6
 8008412:	2b01      	cmp	r3, #1
 8008414:	9a02      	ldr	r2, [sp, #8]
 8008416:	bfb8      	it	lt
 8008418:	2301      	movlt	r3, #1
 800841a:	4293      	cmp	r3, r2
 800841c:	bfc8      	it	gt
 800841e:	200b      	movgt	r0, #11
 8008420:	296f      	cmp	r1, #111	; 0x6f
 8008422:	f000 80e7 	beq.w	80085f4 <cblas_sgemm+0x338>
 8008426:	2f01      	cmp	r7, #1
 8008428:	463b      	mov	r3, r7
 800842a:	bfb8      	it	lt
 800842c:	2301      	movlt	r3, #1
 800842e:	4543      	cmp	r3, r8
 8008430:	f300 8103 	bgt.w	800863a <cblas_sgemm+0x37e>
 8008434:	2d01      	cmp	r5, #1
 8008436:	462b      	mov	r3, r5
 8008438:	bfb8      	it	lt
 800843a:	2301      	movlt	r3, #1
 800843c:	4599      	cmp	r9, r3
 800843e:	f6bf af79 	bge.w	8008334 <cblas_sgemm+0x78>
 8008442:	200e      	movs	r0, #14
 8008444:	4a92      	ldr	r2, [pc, #584]	; (8008690 <cblas_sgemm+0x3d4>)
 8008446:	4991      	ldr	r1, [pc, #580]	; (800868c <cblas_sgemm+0x3d0>)
 8008448:	f020 f95e 	bl	8028708 <cblas_xerbla>
 800844c:	e775      	b.n	800833a <cblas_sgemm+0x7e>
  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 800844e:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8008452:	f000 80fb 	beq.w	800864c <cblas_sgemm+0x390>
  } else if (TransF == CblasNoTrans && TransG == CblasTrans) {
 8008456:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800845a:	d1b1      	bne.n	80083c0 <cblas_sgemm+0x104>
    for (i = 0; i < n1; i++) {
 800845c:	2e00      	cmp	r6, #0
 800845e:	f300 8147 	bgt.w	80086f0 <cblas_sgemm+0x434>
 8008462:	b009      	add	sp, #36	; 0x24
 8008464:	ecbd 8b02 	vpop	{d8}
 8008468:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 800846c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008470:	eef4 8a67 	vcmp.f32	s17, s15
 8008474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008478:	d098      	beq.n	80083ac <cblas_sgemm+0xf0>
    for (i = 0; i < n1; i++) {
 800847a:	2e00      	cmp	r6, #0
 800847c:	dd96      	ble.n	80083ac <cblas_sgemm+0xf0>
 800847e:	9b01      	ldr	r3, [sp, #4]
 8008480:	ebc5 7485 	rsb	r4, r5, r5, lsl #30
 8008484:	00a4      	lsls	r4, r4, #2
 8008486:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 800848a:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 800848e:	2000      	movs	r0, #0
      for (j = 0; j < n2; j++) {
 8008490:	2d00      	cmp	r5, #0
 8008492:	bfc8      	it	gt
 8008494:	1913      	addgt	r3, r2, r4
 8008496:	dd07      	ble.n	80084a8 <cblas_sgemm+0x1ec>
        C[ldc * i + j] *= beta;
 8008498:	edd3 7a00 	vldr	s15, [r3]
 800849c:	ee67 7aa8 	vmul.f32	s15, s15, s17
 80084a0:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j < n2; j++) {
 80084a4:	4293      	cmp	r3, r2
 80084a6:	d1f7      	bne.n	8008498 <cblas_sgemm+0x1dc>
    for (i = 0; i < n1; i++) {
 80084a8:	3001      	adds	r0, #1
 80084aa:	4286      	cmp	r6, r0
 80084ac:	4462      	add	r2, ip
 80084ae:	d1ef      	bne.n	8008490 <cblas_sgemm+0x1d4>
 80084b0:	e77c      	b.n	80083ac <cblas_sgemm+0xf0>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80084b2:	2f00      	cmp	r7, #0
 80084b4:	dba1      	blt.n	80083fa <cblas_sgemm+0x13e>
 80084b6:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80084ba:	f04f 0005 	mov.w	r0, #5
 80084be:	d1a1      	bne.n	8008404 <cblas_sgemm+0x148>
 80084c0:	2a6f      	cmp	r2, #111	; 0x6f
 80084c2:	bf0c      	ite	eq
 80084c4:	463b      	moveq	r3, r7
 80084c6:	462b      	movne	r3, r5
 80084c8:	2b01      	cmp	r3, #1
 80084ca:	bfb8      	it	lt
 80084cc:	2301      	movlt	r3, #1
 80084ce:	4543      	cmp	r3, r8
 80084d0:	bfc8      	it	gt
 80084d2:	2009      	movgt	r0, #9
 80084d4:	296f      	cmp	r1, #111	; 0x6f
 80084d6:	f000 80a3 	beq.w	8008620 <cblas_sgemm+0x364>
 80084da:	2f01      	cmp	r7, #1
 80084dc:	9a02      	ldr	r2, [sp, #8]
 80084de:	463b      	mov	r3, r7
 80084e0:	bfb8      	it	lt
 80084e2:	2301      	movlt	r3, #1
 80084e4:	4293      	cmp	r3, r2
 80084e6:	dd7c      	ble.n	80085e2 <cblas_sgemm+0x326>
 80084e8:	2e01      	cmp	r6, #1
 80084ea:	4630      	mov	r0, r6
 80084ec:	bfb8      	it	lt
 80084ee:	2001      	movlt	r0, #1
 80084f0:	4a67      	ldr	r2, [pc, #412]	; (8008690 <cblas_sgemm+0x3d4>)
 80084f2:	4966      	ldr	r1, [pc, #408]	; (800868c <cblas_sgemm+0x3d0>)
 80084f4:	4581      	cmp	r9, r0
 80084f6:	bfb4      	ite	lt
 80084f8:	200e      	movlt	r0, #14
 80084fa:	200b      	movge	r0, #11
 80084fc:	f020 f904 	bl	8028708 <cblas_xerbla>
 8008500:	e71b      	b.n	800833a <cblas_sgemm+0x7e>
 8008502:	2971      	cmp	r1, #113	; 0x71
 8008504:	f43f af6d 	beq.w	80083e2 <cblas_sgemm+0x126>
 8008508:	2a71      	cmp	r2, #113	; 0x71
 800850a:	d07f      	beq.n	800860c <cblas_sgemm+0x350>
 800850c:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8008510:	b2db      	uxtb	r3, r3
 8008512:	2b02      	cmp	r3, #2
 8008514:	4611      	mov	r1, r2
 8008516:	4622      	mov	r2, r4
 8008518:	f63f aef7 	bhi.w	800830a <cblas_sgemm+0x4e>
 800851c:	e766      	b.n	80083ec <cblas_sgemm+0x130>
    TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800851e:	2c71      	cmp	r4, #113	; 0x71
 8008520:	e9dd 2002 	ldrd	r2, r0, [sp, #8]
 8008524:	bf18      	it	ne
 8008526:	4621      	movne	r1, r4
    F = A;
 8008528:	9c04      	ldr	r4, [sp, #16]
    G = B;
 800852a:	9004      	str	r0, [sp, #16]
 800852c:	bf08      	it	eq
 800852e:	2170      	moveq	r1, #112	; 0x70
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 8008530:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8008534:	e9cd 8402 	strd	r8, r4, [sp, #8]
 8008538:	4633      	mov	r3, r6
 800853a:	4690      	mov	r8, r2
 800853c:	462e      	mov	r6, r5
 800853e:	d055      	beq.n	80085ec <cblas_sgemm+0x330>
 8008540:	461d      	mov	r5, r3
 8008542:	e715      	b.n	8008370 <cblas_sgemm+0xb4>
  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 8008544:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8008548:	f000 810f 	beq.w	800876a <cblas_sgemm+0x4ae>
  } else if (TransF == CblasTrans && TransG == CblasTrans) {
 800854c:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 8008550:	f47f af36 	bne.w	80083c0 <cblas_sgemm+0x104>
    for (i = 0; i < n1; i++) {
 8008554:	2e00      	cmp	r6, #0
 8008556:	dd84      	ble.n	8008462 <cblas_sgemm+0x1a6>
 8008558:	ea4f 0189 	mov.w	r1, r9, lsl #2
 800855c:	e9dd 2a02 	ldrd	r2, sl, [sp, #8]
 8008560:	9102      	str	r1, [sp, #8]
 8008562:	9901      	ldr	r1, [sp, #4]
 8008564:	f8cd 9014 	str.w	r9, [sp, #20]
 8008568:	eb01 0e85 	add.w	lr, r1, r5, lsl #2
 800856c:	9904      	ldr	r1, [sp, #16]
 800856e:	2300      	movs	r3, #0
 8008570:	eb01 0087 	add.w	r0, r1, r7, lsl #2
 8008574:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8008578:	0094      	lsls	r4, r2, #2
 800857a:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 800857e:	9006      	str	r0, [sp, #24]
 8008580:	469c      	mov	ip, r3
 8008582:	460e      	mov	r6, r1
 8008584:	4699      	mov	r9, r3
      for (j = 0; j < n2; j++) {
 8008586:	9b03      	ldr	r3, [sp, #12]
 8008588:	2b00      	cmp	r3, #0
 800858a:	dd1e      	ble.n	80085ca <cblas_sgemm+0x30e>
 800858c:	9b01      	ldr	r3, [sp, #4]
 800858e:	9906      	ldr	r1, [sp, #24]
 8008590:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 8008594:	2500      	movs	r5, #0
        for (k = 0; k < K; k++) {
 8008596:	2f00      	cmp	r7, #0
        BASE temp = 0.0;
 8008598:	eddf 7a3e 	vldr	s15, [pc, #248]	; 8008694 <cblas_sgemm+0x3d8>
        for (k = 0; k < K; k++) {
 800859c:	dd0b      	ble.n	80085b6 <cblas_sgemm+0x2fa>
 800859e:	eb06 0285 	add.w	r2, r6, r5, lsl #2
 80085a2:	4653      	mov	r3, sl
          temp += F[ldf * k + i] * G[ldg * j + k];
 80085a4:	ecb2 7a01 	vldmia	r2!, {s14}
 80085a8:	edd3 6a00 	vldr	s13, [r3]
        for (k = 0; k < K; k++) {
 80085ac:	428a      	cmp	r2, r1
          temp += F[ldf * k + i] * G[ldg * j + k];
 80085ae:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 80085b2:	4423      	add	r3, r4
 80085b4:	d1f6      	bne.n	80085a4 <cblas_sgemm+0x2e8>
        C[ldc * i + j] += alpha * temp;
 80085b6:	ed90 7a00 	vldr	s14, [r0]
 80085ba:	eea8 7a27 	vfma.f32	s14, s16, s15
 80085be:	4445      	add	r5, r8
 80085c0:	4459      	add	r1, fp
 80085c2:	eca0 7a01 	vstmia	r0!, {s14}
      for (j = 0; j < n2; j++) {
 80085c6:	4570      	cmp	r0, lr
 80085c8:	d1e5      	bne.n	8008596 <cblas_sgemm+0x2da>
    for (i = 0; i < n1; i++) {
 80085ca:	9b05      	ldr	r3, [sp, #20]
 80085cc:	4499      	add	r9, r3
 80085ce:	9b02      	ldr	r3, [sp, #8]
 80085d0:	449e      	add	lr, r3
 80085d2:	9b04      	ldr	r3, [sp, #16]
 80085d4:	f10c 0c01 	add.w	ip, ip, #1
 80085d8:	4563      	cmp	r3, ip
 80085da:	f10a 0a04 	add.w	sl, sl, #4
 80085de:	d1d2      	bne.n	8008586 <cblas_sgemm+0x2ca>
 80085e0:	e73f      	b.n	8008462 <cblas_sgemm+0x1a6>
 80085e2:	2e01      	cmp	r6, #1
 80085e4:	4633      	mov	r3, r6
 80085e6:	bfb8      	it	lt
 80085e8:	2301      	movlt	r3, #1
 80085ea:	e727      	b.n	800843c <cblas_sgemm+0x180>
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 80085ec:	f04f 0b70 	mov.w	fp, #112	; 0x70
 80085f0:	461d      	mov	r5, r3
 80085f2:	e6bd      	b.n	8008370 <cblas_sgemm+0xb4>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80085f4:	2d01      	cmp	r5, #1
 80085f6:	462b      	mov	r3, r5
 80085f8:	bfb8      	it	lt
 80085fa:	2301      	movlt	r3, #1
 80085fc:	4543      	cmp	r3, r8
 80085fe:	f77f af1d 	ble.w	800843c <cblas_sgemm+0x180>
 8008602:	454b      	cmp	r3, r9
 8008604:	bfcc      	ite	gt
 8008606:	200e      	movgt	r0, #14
 8008608:	2009      	movle	r0, #9
 800860a:	e71b      	b.n	8008444 <cblas_sgemm+0x188>
 800860c:	460a      	mov	r2, r1
 800860e:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8008612:	b2db      	uxtb	r3, r3
 8008614:	2b02      	cmp	r3, #2
 8008616:	bf8c      	ite	hi
 8008618:	2002      	movhi	r0, #2
 800861a:	2000      	movls	r0, #0
 800861c:	2170      	movs	r1, #112	; 0x70
 800861e:	e67a      	b.n	8008316 <cblas_sgemm+0x5a>
 8008620:	2e01      	cmp	r6, #1
 8008622:	9a02      	ldr	r2, [sp, #8]
 8008624:	4633      	mov	r3, r6
 8008626:	bfb8      	it	lt
 8008628:	2301      	movlt	r3, #1
 800862a:	4293      	cmp	r3, r2
 800862c:	f77f af06 	ble.w	800843c <cblas_sgemm+0x180>
 8008630:	454b      	cmp	r3, r9
 8008632:	bfcc      	ite	gt
 8008634:	200e      	movgt	r0, #14
 8008636:	200b      	movle	r0, #11
 8008638:	e704      	b.n	8008444 <cblas_sgemm+0x188>
 800863a:	2d01      	cmp	r5, #1
 800863c:	4628      	mov	r0, r5
 800863e:	bfb8      	it	lt
 8008640:	2001      	movlt	r0, #1
 8008642:	4581      	cmp	r9, r0
 8008644:	bfb4      	ite	lt
 8008646:	200e      	movlt	r0, #14
 8008648:	2009      	movge	r0, #9
 800864a:	e6fb      	b.n	8008444 <cblas_sgemm+0x188>
    for (k = 0; k < K; k++) {
 800864c:	2f00      	cmp	r7, #0
 800864e:	f77f af08 	ble.w	8008462 <cblas_sgemm+0x1a6>
 8008652:	ea4f 0388 	mov.w	r3, r8, lsl #2
 8008656:	9305      	str	r3, [sp, #20]
 8008658:	9b02      	ldr	r3, [sp, #8]
 800865a:	f8dd a010 	ldr.w	sl, [sp, #16]
 800865e:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8008662:	9b01      	ldr	r3, [sp, #4]
 8008664:	9701      	str	r7, [sp, #4]
 8008666:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 800866a:	ea4f 0e89 	mov.w	lr, r9, lsl #2
 800866e:	9202      	str	r2, [sp, #8]
 8008670:	f04f 0b00 	mov.w	fp, #0
 8008674:	469c      	mov	ip, r3
      for (i = 0; i < n1; i++) {
 8008676:	2e00      	cmp	r6, #0
 8008678:	dd32      	ble.n	80086e0 <cblas_sgemm+0x424>
 800867a:	9b03      	ldr	r3, [sp, #12]
 800867c:	9902      	ldr	r1, [sp, #8]
 800867e:	2700      	movs	r7, #0
 8008680:	463c      	mov	r4, r7
 8008682:	eb03 008b 	add.w	r0, r3, fp, lsl #2
 8008686:	e00d      	b.n	80086a4 <cblas_sgemm+0x3e8>
 8008688:	080311b8 	.word	0x080311b8
 800868c:	080311a8 	.word	0x080311a8
 8008690:	08031108 	.word	0x08031108
 8008694:	00000000 	.word	0x00000000
 8008698:	3401      	adds	r4, #1
 800869a:	42a6      	cmp	r6, r4
 800869c:	4440      	add	r0, r8
 800869e:	444f      	add	r7, r9
 80086a0:	4471      	add	r1, lr
 80086a2:	d01d      	beq.n	80086e0 <cblas_sgemm+0x424>
        const BASE temp = alpha * F[ldf * i + k];
 80086a4:	ed90 7a00 	vldr	s14, [r0]
 80086a8:	ee28 7a07 	vmul.f32	s14, s16, s14
        if (temp != 0.0) {
 80086ac:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80086b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086b4:	d0f0      	beq.n	8008698 <cblas_sgemm+0x3dc>
          for (j = 0; j < n2; j++) {
 80086b6:	2d00      	cmp	r5, #0
 80086b8:	ddee      	ble.n	8008698 <cblas_sgemm+0x3dc>
 80086ba:	eb0c 0387 	add.w	r3, ip, r7, lsl #2
 80086be:	4652      	mov	r2, sl
            C[ldc * i + j] += temp * G[ldg * k + j];
 80086c0:	edd3 7a00 	vldr	s15, [r3]
 80086c4:	ecf2 6a01 	vldmia	r2!, {s13}
 80086c8:	eee6 7a87 	vfma.f32	s15, s13, s14
 80086cc:	ece3 7a01 	vstmia	r3!, {s15}
          for (j = 0; j < n2; j++) {
 80086d0:	4299      	cmp	r1, r3
 80086d2:	d1f5      	bne.n	80086c0 <cblas_sgemm+0x404>
      for (i = 0; i < n1; i++) {
 80086d4:	3401      	adds	r4, #1
 80086d6:	42a6      	cmp	r6, r4
 80086d8:	4440      	add	r0, r8
 80086da:	444f      	add	r7, r9
 80086dc:	4471      	add	r1, lr
 80086de:	d1e1      	bne.n	80086a4 <cblas_sgemm+0x3e8>
    for (k = 0; k < K; k++) {
 80086e0:	9b05      	ldr	r3, [sp, #20]
 80086e2:	449a      	add	sl, r3
 80086e4:	9b01      	ldr	r3, [sp, #4]
 80086e6:	f10b 0b01 	add.w	fp, fp, #1
 80086ea:	455b      	cmp	r3, fp
 80086ec:	d1c3      	bne.n	8008676 <cblas_sgemm+0x3ba>
 80086ee:	e6b8      	b.n	8008462 <cblas_sgemm+0x1a6>
 80086f0:	ea4f 0289 	mov.w	r2, r9, lsl #2
 80086f4:	9b02      	ldr	r3, [sp, #8]
 80086f6:	9202      	str	r2, [sp, #8]
 80086f8:	9a01      	ldr	r2, [sp, #4]
 80086fa:	f8dd e00c 	ldr.w	lr, [sp, #12]
 80086fe:	9503      	str	r5, [sp, #12]
    for (i = 0; i < n1; i++) {
 8008700:	f04f 0a00 	mov.w	sl, #0
 8008704:	009b      	lsls	r3, r3, #2
 8008706:	eb02 0c85 	add.w	ip, r2, r5, lsl #2
 800870a:	9d04      	ldr	r5, [sp, #16]
 800870c:	9605      	str	r6, [sp, #20]
 800870e:	eb0e 0187 	add.w	r1, lr, r7, lsl #2
 8008712:	46d3      	mov	fp, sl
 8008714:	461e      	mov	r6, r3
      for (j = 0; j < n2; j++) {
 8008716:	9b03      	ldr	r3, [sp, #12]
 8008718:	2b00      	cmp	r3, #0
 800871a:	dd1b      	ble.n	8008754 <cblas_sgemm+0x498>
 800871c:	9b01      	ldr	r3, [sp, #4]
 800871e:	2400      	movs	r4, #0
 8008720:	eb03 008a 	add.w	r0, r3, sl, lsl #2
        for (k = 0; k < K; k++) {
 8008724:	2f00      	cmp	r7, #0
        BASE temp = 0.0;
 8008726:	ed5f 7a25 	vldr	s15, [pc, #-148]	; 8008694 <cblas_sgemm+0x3d8>
        for (k = 0; k < K; k++) {
 800872a:	dd0a      	ble.n	8008742 <cblas_sgemm+0x486>
 800872c:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8008730:	4673      	mov	r3, lr
          temp += F[ldf * i + k] * G[ldg * j + k];
 8008732:	ecf3 6a01 	vldmia	r3!, {s13}
 8008736:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < K; k++) {
 800873a:	4299      	cmp	r1, r3
          temp += F[ldf * i + k] * G[ldg * j + k];
 800873c:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 8008740:	d1f7      	bne.n	8008732 <cblas_sgemm+0x476>
        C[ldc * i + j] += alpha * temp;
 8008742:	ed90 7a00 	vldr	s14, [r0]
 8008746:	eea8 7a27 	vfma.f32	s14, s16, s15
 800874a:	4444      	add	r4, r8
 800874c:	eca0 7a01 	vstmia	r0!, {s14}
      for (j = 0; j < n2; j++) {
 8008750:	4584      	cmp	ip, r0
 8008752:	d1e7      	bne.n	8008724 <cblas_sgemm+0x468>
    for (i = 0; i < n1; i++) {
 8008754:	9b02      	ldr	r3, [sp, #8]
 8008756:	449c      	add	ip, r3
 8008758:	9b05      	ldr	r3, [sp, #20]
 800875a:	f10b 0b01 	add.w	fp, fp, #1
 800875e:	455b      	cmp	r3, fp
 8008760:	44ca      	add	sl, r9
 8008762:	44b6      	add	lr, r6
 8008764:	4431      	add	r1, r6
 8008766:	d1d6      	bne.n	8008716 <cblas_sgemm+0x45a>
 8008768:	e67b      	b.n	8008462 <cblas_sgemm+0x1a6>
    for (k = 0; k < K; k++) {
 800876a:	2f00      	cmp	r7, #0
 800876c:	f77f ae79 	ble.w	8008462 <cblas_sgemm+0x1a6>
 8008770:	9b02      	ldr	r3, [sp, #8]
 8008772:	009b      	lsls	r3, r3, #2
 8008774:	9305      	str	r3, [sp, #20]
 8008776:	9b03      	ldr	r3, [sp, #12]
 8008778:	f04f 0e00 	mov.w	lr, #0
 800877c:	e9cd 6706 	strd	r6, r7, [sp, #24]
 8008780:	eb03 0c86 	add.w	ip, r3, r6, lsl #2
 8008784:	9e01      	ldr	r6, [sp, #4]
 8008786:	46f2      	mov	sl, lr
 8008788:	46f3      	mov	fp, lr
      for (i = 0; i < n1; i++) {
 800878a:	9b06      	ldr	r3, [sp, #24]
 800878c:	2b00      	cmp	r3, #0
 800878e:	dd28      	ble.n	80087e2 <cblas_sgemm+0x526>
 8008790:	9b03      	ldr	r3, [sp, #12]
 8008792:	eb03 018a 	add.w	r1, r3, sl, lsl #2
 8008796:	9b04      	ldr	r3, [sp, #16]
 8008798:	2400      	movs	r4, #0
 800879a:	eb03 078e 	add.w	r7, r3, lr, lsl #2
 800879e:	e002      	b.n	80087a6 <cblas_sgemm+0x4ea>
 80087a0:	458c      	cmp	ip, r1
 80087a2:	444c      	add	r4, r9
 80087a4:	d01d      	beq.n	80087e2 <cblas_sgemm+0x526>
        const BASE temp = alpha * F[ldf * k + i];
 80087a6:	ecb1 7a01 	vldmia	r1!, {s14}
 80087aa:	ee27 7a08 	vmul.f32	s14, s14, s16
        if (temp != 0.0) {
 80087ae:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80087b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80087b6:	d0f3      	beq.n	80087a0 <cblas_sgemm+0x4e4>
          for (j = 0; j < n2; j++) {
 80087b8:	2d00      	cmp	r5, #0
 80087ba:	ddf1      	ble.n	80087a0 <cblas_sgemm+0x4e4>
 80087bc:	1928      	adds	r0, r5, r4
 80087be:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 80087c2:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 80087c6:	463a      	mov	r2, r7
            C[ldc * i + j] += temp * G[ldg * k + j];
 80087c8:	edd3 7a00 	vldr	s15, [r3]
 80087cc:	ecf2 6a01 	vldmia	r2!, {s13}
 80087d0:	eee6 7a87 	vfma.f32	s15, s13, s14
 80087d4:	ece3 7a01 	vstmia	r3!, {s15}
          for (j = 0; j < n2; j++) {
 80087d8:	4283      	cmp	r3, r0
 80087da:	d1f5      	bne.n	80087c8 <cblas_sgemm+0x50c>
      for (i = 0; i < n1; i++) {
 80087dc:	458c      	cmp	ip, r1
 80087de:	444c      	add	r4, r9
 80087e0:	d1e1      	bne.n	80087a6 <cblas_sgemm+0x4ea>
    for (k = 0; k < K; k++) {
 80087e2:	9b05      	ldr	r3, [sp, #20]
 80087e4:	449c      	add	ip, r3
 80087e6:	9b02      	ldr	r3, [sp, #8]
 80087e8:	449a      	add	sl, r3
 80087ea:	9b07      	ldr	r3, [sp, #28]
 80087ec:	f10b 0b01 	add.w	fp, fp, #1
 80087f0:	455b      	cmp	r3, fp
 80087f2:	44c6      	add	lr, r8
 80087f4:	d1c9      	bne.n	800878a <cblas_sgemm+0x4ce>
 80087f6:	e634      	b.n	8008462 <cblas_sgemm+0x1a6>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80087f8:	2270      	movs	r2, #112	; 0x70
 80087fa:	e708      	b.n	800860e <cblas_sgemm+0x352>

080087fc <cblas_sgemv>:
void
cblas_sgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const float alpha, const float *A,
             const int lda, const float *X, const int incX, const float beta,
             float *Y, const int incY)
{
 80087fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008800:	ed2d 8b02 	vpush	{d8}
 8008804:	b083      	sub	sp, #12
 8008806:	461e      	mov	r6, r3

{
  INDEX i, j;
  INDEX lenX, lenY;

  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8008808:	2971      	cmp	r1, #113	; 0x71
 800880a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800880c:	9301      	str	r3, [sp, #4]
 800880e:	e9dd ba0e 	ldrd	fp, sl, [sp, #56]	; 0x38
 8008812:	e9dd 7311 	ldrd	r7, r3, [sp, #68]	; 0x44
 8008816:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
 800881a:	4680      	mov	r8, r0
 800881c:	4614      	mov	r4, r2
 800881e:	eeb0 8a40 	vmov.f32	s16, s0
 8008822:	eef0 8a60 	vmov.f32	s17, s1
 8008826:	f000 80d8 	beq.w	80089da <cblas_sgemv+0x1de>

  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800882a:	f1a1 026f 	sub.w	r2, r1, #111	; 0x6f
 800882e:	2a02      	cmp	r2, #2
 8008830:	460d      	mov	r5, r1
 8008832:	f240 80ee 	bls.w	8008a12 <cblas_sgemv+0x216>
 8008836:	2002      	movs	r0, #2
 8008838:	2c00      	cmp	r4, #0
 800883a:	bfb8      	it	lt
 800883c:	2003      	movlt	r0, #3
 800883e:	2e00      	cmp	r6, #0
 8008840:	bfb8      	it	lt
 8008842:	2004      	movlt	r0, #4
 8008844:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 8008848:	f000 80bc 	beq.w	80089c4 <cblas_sgemv+0x1c8>
 800884c:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 8008850:	f000 80a8 	beq.w	80089a4 <cblas_sgemv+0x1a8>
 8008854:	2f00      	cmp	r7, #0
 8008856:	f040 809e 	bne.w	8008996 <cblas_sgemv+0x19a>
 800885a:	f1b9 0f00 	cmp.w	r9, #0
 800885e:	bf14      	ite	ne
 8008860:	2009      	movne	r0, #9
 8008862:	200c      	moveq	r0, #12
 8008864:	4a9d      	ldr	r2, [pc, #628]	; (8008adc <cblas_sgemv+0x2e0>)
 8008866:	499e      	ldr	r1, [pc, #632]	; (8008ae0 <cblas_sgemv+0x2e4>)
 8008868:	9300      	str	r3, [sp, #0]
 800886a:	f01f ff4d 	bl	8028708 <cblas_xerbla>
 800886e:	9b00      	ldr	r3, [sp, #0]

  if (M == 0 || N == 0)
 8008870:	2c00      	cmp	r4, #0
 8008872:	f000 808b 	beq.w	800898c <cblas_sgemv+0x190>
 8008876:	2e00      	cmp	r6, #0
 8008878:	f000 8088 	beq.w	800898c <cblas_sgemv+0x190>
    return;

  if (alpha == 0.0 && beta == 1.0)
 800887c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8008880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008884:	d106      	bne.n	8008894 <cblas_sgemv+0x98>
 8008886:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800888a:	eef4 8a67 	vcmp.f32	s17, s15
 800888e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008892:	d07b      	beq.n	800898c <cblas_sgemv+0x190>
    return;

  if (Trans == CblasNoTrans) {
 8008894:	2d6f      	cmp	r5, #111	; 0x6f
 8008896:	d002      	beq.n	800889e <cblas_sgemv+0xa2>
 8008898:	4632      	mov	r2, r6
 800889a:	4626      	mov	r6, r4
 800889c:	4614      	mov	r4, r2
    lenX = M;
    lenY = N;
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 800889e:	eef5 8a40 	vcmp.f32	s17, #0.0
 80088a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80088a6:	f000 809f 	beq.w	80089e8 <cblas_sgemv+0x1ec>
    INDEX iy = OFFSET(lenY, incY);
    for (i = 0; i < lenY; i++) {
      Y[iy] = 0.0;
      iy += incY;
    }
  } else if (beta != 1.0) {
 80088aa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80088ae:	eef4 8a67 	vcmp.f32	s17, s15
 80088b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80088b6:	d015      	beq.n	80088e4 <cblas_sgemv+0xe8>
    INDEX iy = OFFSET(lenY, incY);
 80088b8:	f1b9 0f00 	cmp.w	r9, #0
 80088bc:	f340 8109 	ble.w	8008ad2 <cblas_sgemv+0x2d6>
 80088c0:	2200      	movs	r2, #0
    for (i = 0; i < lenY; i++) {
 80088c2:	2c00      	cmp	r4, #0
 80088c4:	dd0e      	ble.n	80088e4 <cblas_sgemv+0xe8>
 80088c6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80088ca:	ea4f 0089 	mov.w	r0, r9, lsl #2
 80088ce:	2100      	movs	r1, #0
      Y[iy] *= beta;
 80088d0:	edd2 7a00 	vldr	s15, [r2]
    for (i = 0; i < lenY; i++) {
 80088d4:	3101      	adds	r1, #1
      Y[iy] *= beta;
 80088d6:	ee67 7aa8 	vmul.f32	s15, s15, s17
    for (i = 0; i < lenY; i++) {
 80088da:	428c      	cmp	r4, r1
      Y[iy] *= beta;
 80088dc:	edc2 7a00 	vstr	s15, [r2]
    for (i = 0; i < lenY; i++) {
 80088e0:	4402      	add	r2, r0
 80088e2:	d1f5      	bne.n	80088d0 <cblas_sgemv+0xd4>
      iy += incY;
    }
  }

  if (alpha == 0.0)
 80088e4:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80088e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80088ec:	d04e      	beq.n	800898c <cblas_sgemv+0x190>
    return;

  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 80088ee:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 80088f2:	f000 8096 	beq.w	8008a22 <cblas_sgemv+0x226>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 80088f6:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 80088fa:	d009      	beq.n	8008910 <cblas_sgemv+0x114>
        }
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 80088fc:	4a79      	ldr	r2, [pc, #484]	; (8008ae4 <cblas_sgemv+0x2e8>)
 80088fe:	4978      	ldr	r1, [pc, #480]	; (8008ae0 <cblas_sgemv+0x2e4>)
 8008900:	2000      	movs	r0, #0
#define BASE float
#include "source_gemv_r.h"
#undef BASE
}
 8008902:	b003      	add	sp, #12
 8008904:	ecbd 8b02 	vpop	{d8}
 8008908:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800890c:	f01f befc 	b.w	8028708 <cblas_xerbla>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 8008910:	2d70      	cmp	r5, #112	; 0x70
 8008912:	f040 80d0 	bne.w	8008ab6 <cblas_sgemv+0x2ba>
    INDEX iy = OFFSET(lenY, incY);
 8008916:	f1b9 0f00 	cmp.w	r9, #0
 800891a:	f340 80d0 	ble.w	8008abe <cblas_sgemv+0x2c2>
 800891e:	2000      	movs	r0, #0
    for (i = 0; i < lenY; i++) {
 8008920:	2c00      	cmp	r4, #0
 8008922:	dd33      	ble.n	800898c <cblas_sgemv+0x190>
 8008924:	2f00      	cmp	r7, #0
 8008926:	f1c6 0e01 	rsb	lr, r6, #1
 800892a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 800892e:	9b01      	ldr	r3, [sp, #4]
 8008930:	fb0e fe07 	mul.w	lr, lr, r7
      INDEX ix = OFFSET(lenX, incX);
 8008934:	f04f 0500 	mov.w	r5, #0
 8008938:	bfc8      	it	gt
 800893a:	f04f 0e00 	movgt.w	lr, #0
 800893e:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8008942:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 8008946:	00bf      	lsls	r7, r7, #2
 8008948:	46ac      	mov	ip, r5
 800894a:	ea4f 088a 	mov.w	r8, sl, lsl #2
 800894e:	eb0b 0186 	add.w	r1, fp, r6, lsl #2
      for (j = 0; j < lenX; j++) {
 8008952:	2e00      	cmp	r6, #0
 8008954:	eddf 7a64 	vldr	s15, [pc, #400]	; 8008ae8 <cblas_sgemv+0x2ec>
 8008958:	dd0b      	ble.n	8008972 <cblas_sgemv+0x176>
 800895a:	eb0b 0285 	add.w	r2, fp, r5, lsl #2
 800895e:	4673      	mov	r3, lr
        temp += X[ix] * A[lda * i + j];
 8008960:	ecb2 7a01 	vldmia	r2!, {s14}
 8008964:	edd3 6a00 	vldr	s13, [r3]
      for (j = 0; j < lenX; j++) {
 8008968:	4291      	cmp	r1, r2
        temp += X[ix] * A[lda * i + j];
 800896a:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = 0; j < lenX; j++) {
 800896e:	443b      	add	r3, r7
 8008970:	d1f6      	bne.n	8008960 <cblas_sgemv+0x164>
      Y[iy] += alpha * temp;
 8008972:	ed90 7a00 	vldr	s14, [r0]
 8008976:	eea8 7a27 	vfma.f32	s14, s16, s15
    for (i = 0; i < lenY; i++) {
 800897a:	f10c 0c01 	add.w	ip, ip, #1
 800897e:	4564      	cmp	r4, ip
 8008980:	4455      	add	r5, sl
      Y[iy] += alpha * temp;
 8008982:	ed80 7a00 	vstr	s14, [r0]
    for (i = 0; i < lenY; i++) {
 8008986:	4441      	add	r1, r8
 8008988:	4448      	add	r0, r9
 800898a:	d1e2      	bne.n	8008952 <cblas_sgemv+0x156>
 800898c:	b003      	add	sp, #12
 800898e:	ecbd 8b02 	vpop	{d8}
 8008992:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8008996:	f1b9 0f00 	cmp.w	r9, #0
 800899a:	d040      	beq.n	8008a1e <cblas_sgemv+0x222>
 800899c:	2800      	cmp	r0, #0
 800899e:	f43f af67 	beq.w	8008870 <cblas_sgemv+0x74>
 80089a2:	e75f      	b.n	8008864 <cblas_sgemv+0x68>
 80089a4:	2c01      	cmp	r4, #1
 80089a6:	4622      	mov	r2, r4
 80089a8:	bfb8      	it	lt
 80089aa:	2201      	movlt	r2, #1
 80089ac:	4552      	cmp	r2, sl
 80089ae:	f77f af51 	ble.w	8008854 <cblas_sgemv+0x58>
 80089b2:	2f00      	cmp	r7, #0
 80089b4:	f43f af51 	beq.w	800885a <cblas_sgemv+0x5e>
 80089b8:	f1b9 0f00 	cmp.w	r9, #0
 80089bc:	bf14      	ite	ne
 80089be:	2007      	movne	r0, #7
 80089c0:	200c      	moveq	r0, #12
 80089c2:	e74f      	b.n	8008864 <cblas_sgemv+0x68>
 80089c4:	2e01      	cmp	r6, #1
 80089c6:	4632      	mov	r2, r6
 80089c8:	bfb8      	it	lt
 80089ca:	2201      	movlt	r2, #1
 80089cc:	4552      	cmp	r2, sl
 80089ce:	f77f af41 	ble.w	8008854 <cblas_sgemv+0x58>
 80089d2:	2f00      	cmp	r7, #0
 80089d4:	f43f af41 	beq.w	800885a <cblas_sgemv+0x5e>
 80089d8:	e7ee      	b.n	80089b8 <cblas_sgemv+0x1bc>
 80089da:	3865      	subs	r0, #101	; 0x65
 80089dc:	2801      	cmp	r0, #1
 80089de:	bf94      	ite	ls
 80089e0:	2000      	movls	r0, #0
 80089e2:	2001      	movhi	r0, #1
 80089e4:	2570      	movs	r5, #112	; 0x70
 80089e6:	e727      	b.n	8008838 <cblas_sgemv+0x3c>
    INDEX iy = OFFSET(lenY, incY);
 80089e8:	f1b9 0f00 	cmp.w	r9, #0
 80089ec:	dd5e      	ble.n	8008aac <cblas_sgemv+0x2b0>
 80089ee:	2200      	movs	r2, #0
    for (i = 0; i < lenY; i++) {
 80089f0:	2c00      	cmp	r4, #0
 80089f2:	f77f af77 	ble.w	80088e4 <cblas_sgemv+0xe8>
      Y[iy] = 0.0;
 80089f6:	f04f 0c00 	mov.w	ip, #0
 80089fa:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80089fe:	ea4f 0089 	mov.w	r0, r9, lsl #2
    for (i = 0; i < lenY; i++) {
 8008a02:	2100      	movs	r1, #0
 8008a04:	3101      	adds	r1, #1
 8008a06:	428c      	cmp	r4, r1
      Y[iy] = 0.0;
 8008a08:	f8c2 c000 	str.w	ip, [r2]
    for (i = 0; i < lenY; i++) {
 8008a0c:	4402      	add	r2, r0
 8008a0e:	d1f9      	bne.n	8008a04 <cblas_sgemv+0x208>
 8008a10:	e768      	b.n	80088e4 <cblas_sgemv+0xe8>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8008a12:	3865      	subs	r0, #101	; 0x65
 8008a14:	2801      	cmp	r0, #1
 8008a16:	bf94      	ite	ls
 8008a18:	2000      	movls	r0, #0
 8008a1a:	2001      	movhi	r0, #1
 8008a1c:	e70c      	b.n	8008838 <cblas_sgemv+0x3c>
 8008a1e:	200c      	movs	r0, #12
 8008a20:	e720      	b.n	8008864 <cblas_sgemv+0x68>
  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 8008a22:	2d6f      	cmp	r5, #111	; 0x6f
 8008a24:	f43f af77 	beq.w	8008916 <cblas_sgemv+0x11a>
  } else if ((order == CblasRowMajor && Trans == CblasTrans)
 8008a28:	2d70      	cmp	r5, #112	; 0x70
 8008a2a:	f47f af67 	bne.w	80088fc <cblas_sgemv+0x100>
    INDEX ix = OFFSET(lenX, incX);
 8008a2e:	2f00      	cmp	r7, #0
 8008a30:	dd4a      	ble.n	8008ac8 <cblas_sgemv+0x2cc>
 8008a32:	2000      	movs	r0, #0
    for (j = 0; j < lenX; j++) {
 8008a34:	2e00      	cmp	r6, #0
 8008a36:	dda9      	ble.n	800898c <cblas_sgemv+0x190>
 8008a38:	f1b9 0f00 	cmp.w	r9, #0
 8008a3c:	9a01      	ldr	r2, [sp, #4]
 8008a3e:	f1c4 0e01 	rsb	lr, r4, #1
 8008a42:	fb0e fe09 	mul.w	lr, lr, r9
        INDEX iy = OFFSET(lenY, incY);
 8008a46:	f04f 0500 	mov.w	r5, #0
 8008a4a:	bfc8      	it	gt
 8008a4c:	f04f 0e00 	movgt.w	lr, #0
 8008a50:	00bf      	lsls	r7, r7, #2
 8008a52:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8008a56:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 8008a5a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8008a5e:	46ac      	mov	ip, r5
 8008a60:	ea4f 088a 	mov.w	r8, sl, lsl #2
 8008a64:	eb0b 0184 	add.w	r1, fp, r4, lsl #2
 8008a68:	e006      	b.n	8008a78 <cblas_sgemv+0x27c>
    for (j = 0; j < lenX; j++) {
 8008a6a:	f10c 0c01 	add.w	ip, ip, #1
 8008a6e:	4566      	cmp	r6, ip
 8008a70:	4438      	add	r0, r7
 8008a72:	4455      	add	r5, sl
 8008a74:	4441      	add	r1, r8
 8008a76:	d089      	beq.n	800898c <cblas_sgemv+0x190>
      const BASE temp = alpha * X[ix];
 8008a78:	ed90 7a00 	vldr	s14, [r0]
 8008a7c:	ee28 7a07 	vmul.f32	s14, s16, s14
      if (temp != 0.0) {
 8008a80:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8008a84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008a88:	d0ef      	beq.n	8008a6a <cblas_sgemv+0x26e>
        for (i = 0; i < lenY; i++) {
 8008a8a:	2c00      	cmp	r4, #0
 8008a8c:	dded      	ble.n	8008a6a <cblas_sgemv+0x26e>
 8008a8e:	eb0b 0285 	add.w	r2, fp, r5, lsl #2
 8008a92:	4673      	mov	r3, lr
          Y[iy] += temp * A[lda * j + i];
 8008a94:	ecf2 6a01 	vldmia	r2!, {s13}
 8008a98:	edd3 7a00 	vldr	s15, [r3]
 8008a9c:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (i = 0; i < lenY; i++) {
 8008aa0:	428a      	cmp	r2, r1
          Y[iy] += temp * A[lda * j + i];
 8008aa2:	edc3 7a00 	vstr	s15, [r3]
        for (i = 0; i < lenY; i++) {
 8008aa6:	444b      	add	r3, r9
 8008aa8:	d1f4      	bne.n	8008a94 <cblas_sgemv+0x298>
 8008aaa:	e7de      	b.n	8008a6a <cblas_sgemv+0x26e>
    INDEX iy = OFFSET(lenY, incY);
 8008aac:	f1c4 0201 	rsb	r2, r4, #1
 8008ab0:	fb02 f209 	mul.w	r2, r2, r9
 8008ab4:	e79c      	b.n	80089f0 <cblas_sgemv+0x1f4>
             || (order == CblasColMajor && Trans == CblasNoTrans)) {
 8008ab6:	2d6f      	cmp	r5, #111	; 0x6f
 8008ab8:	f47f af20 	bne.w	80088fc <cblas_sgemv+0x100>
 8008abc:	e7b7      	b.n	8008a2e <cblas_sgemv+0x232>
    INDEX iy = OFFSET(lenY, incY);
 8008abe:	f1c4 0001 	rsb	r0, r4, #1
 8008ac2:	fb00 f009 	mul.w	r0, r0, r9
 8008ac6:	e72b      	b.n	8008920 <cblas_sgemv+0x124>
    INDEX ix = OFFSET(lenX, incX);
 8008ac8:	f1c6 0001 	rsb	r0, r6, #1
 8008acc:	fb00 f007 	mul.w	r0, r0, r7
 8008ad0:	e7b0      	b.n	8008a34 <cblas_sgemv+0x238>
    INDEX iy = OFFSET(lenY, incY);
 8008ad2:	f1c4 0201 	rsb	r2, r4, #1
 8008ad6:	fb02 f209 	mul.w	r2, r2, r9
 8008ada:	e6f2      	b.n	80088c2 <cblas_sgemv+0xc6>
 8008adc:	08031108 	.word	0x08031108
 8008ae0:	080311d0 	.word	0x080311d0
 8008ae4:	080311b8 	.word	0x080311b8
 8008ae8:	00000000 	.word	0x00000000

08008aec <cblas_sger>:

void
cblas_sger (const enum CBLAS_ORDER order, const int M, const int N,
            const float alpha, const float *X, const int incX, const float *Y,
            const int incY, float *A, const int lda)
{
 8008aec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008af0:	ed2d 8b02 	vpush	{d8}
 8008af4:	b083      	sub	sp, #12
 8008af6:	469a      	mov	sl, r3
 8008af8:	e9dd 930e 	ldrd	r9, r3, [sp, #56]	; 0x38
 */

{
  INDEX i, j;

  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008afc:	1e0e      	subs	r6, r1, #0
 8008afe:	e9dd 4810 	ldrd	r4, r8, [sp, #64]	; 0x40
 8008b02:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8008b04:	9301      	str	r3, [sp, #4]
 8008b06:	4683      	mov	fp, r0
 8008b08:	4615      	mov	r5, r2
 8008b0a:	eeb0 8a40 	vmov.f32	s16, s0
 8008b0e:	db75      	blt.n	8008bfc <cblas_sger+0x110>
 8008b10:	3865      	subs	r0, #101	; 0x65
 8008b12:	2801      	cmp	r0, #1
 8008b14:	bf94      	ite	ls
 8008b16:	2000      	movls	r0, #0
 8008b18:	2001      	movhi	r0, #1
 8008b1a:	2d00      	cmp	r5, #0
 8008b1c:	bfb8      	it	lt
 8008b1e:	2003      	movlt	r0, #3
 8008b20:	f1b9 0f00 	cmp.w	r9, #0
 8008b24:	d156      	bne.n	8008bd4 <cblas_sger+0xe8>
 8008b26:	2c00      	cmp	r4, #0
 8008b28:	d14b      	bne.n	8008bc2 <cblas_sger+0xd6>
 8008b2a:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8008b2e:	d067      	beq.n	8008c00 <cblas_sger+0x114>
 8008b30:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8008b34:	f000 80c7 	beq.w	8008cc6 <cblas_sger+0x1da>
 8008b38:	2008      	movs	r0, #8
 8008b3a:	4a73      	ldr	r2, [pc, #460]	; (8008d08 <cblas_sger+0x21c>)
 8008b3c:	4973      	ldr	r1, [pc, #460]	; (8008d0c <cblas_sger+0x220>)
 8008b3e:	f01f fde3 	bl	8028708 <cblas_xerbla>
        A[lda * i + j] += Y[jy] * tmp;
        jy += incY;
      }
      ix += incX;
    }
  } else if (order == CblasColMajor) {
 8008b42:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8008b46:	d14f      	bne.n	8008be8 <cblas_sger+0xfc>
    INDEX jy = OFFSET(N, incY);
 8008b48:	2c00      	cmp	r4, #0
 8008b4a:	f340 80a1 	ble.w	8008c90 <cblas_sger+0x1a4>
 8008b4e:	2300      	movs	r3, #0
    for (j = 0; j < N; j++) {
 8008b50:	2d00      	cmp	r5, #0
 8008b52:	dd31      	ble.n	8008bb8 <cblas_sger+0xcc>
 8008b54:	9901      	ldr	r1, [sp, #4]
 8008b56:	f1b9 0f00 	cmp.w	r9, #0
 8008b5a:	f1c6 0201 	rsb	r2, r6, #1
 8008b5e:	fb02 f209 	mul.w	r2, r2, r9
      const BASE tmp = alpha * Y[jy];
      INDEX ix = OFFSET(M, incX);
 8008b62:	f04f 0c00 	mov.w	ip, #0
 8008b66:	bfc8      	it	gt
 8008b68:	2200      	movgt	r2, #0
 8008b6a:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
 8008b6e:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
 8008b72:	ea4f 0189 	mov.w	r1, r9, lsl #2
 8008b76:	00a4      	lsls	r4, r4, #2
 8008b78:	46e6      	mov	lr, ip
 8008b7a:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8008b7e:	eb08 0286 	add.w	r2, r8, r6, lsl #2
      const BASE tmp = alpha * Y[jy];
 8008b82:	eddb 6a00 	vldr	s13, [fp]
      for (i = 0; i < M; i++) {
 8008b86:	2e00      	cmp	r6, #0
      const BASE tmp = alpha * Y[jy];
 8008b88:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (i = 0; i < M; i++) {
 8008b8c:	dd0d      	ble.n	8008baa <cblas_sger+0xbe>
 8008b8e:	eb08 038c 	add.w	r3, r8, ip, lsl #2
 8008b92:	4650      	mov	r0, sl
        A[i + lda * j] += X[ix] * tmp;
 8008b94:	ed90 7a00 	vldr	s14, [r0]
 8008b98:	edd3 7a00 	vldr	s15, [r3]
 8008b9c:	eee7 7a26 	vfma.f32	s15, s14, s13
 8008ba0:	4408      	add	r0, r1
 8008ba2:	ece3 7a01 	vstmia	r3!, {s15}
      for (i = 0; i < M; i++) {
 8008ba6:	4293      	cmp	r3, r2
 8008ba8:	d1f4      	bne.n	8008b94 <cblas_sger+0xa8>
    for (j = 0; j < N; j++) {
 8008baa:	f10e 0e01 	add.w	lr, lr, #1
 8008bae:	4575      	cmp	r5, lr
 8008bb0:	44a3      	add	fp, r4
 8008bb2:	44bc      	add	ip, r7
 8008bb4:	444a      	add	r2, r9
 8008bb6:	d1e4      	bne.n	8008b82 <cblas_sger+0x96>
#define BASE float
#include "source_ger.h"
#undef BASE
}
 8008bb8:	b003      	add	sp, #12
 8008bba:	ecbd 8b02 	vpop	{d8}
 8008bbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008bc2:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8008bc6:	d070      	beq.n	8008caa <cblas_sger+0x1be>
 8008bc8:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8008bcc:	f000 8092 	beq.w	8008cf4 <cblas_sger+0x208>
 8008bd0:	2006      	movs	r0, #6
 8008bd2:	e7b2      	b.n	8008b3a <cblas_sger+0x4e>
 8008bd4:	2c00      	cmp	r4, #0
 8008bd6:	d0a8      	beq.n	8008b2a <cblas_sger+0x3e>
 8008bd8:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8008bdc:	d05d      	beq.n	8008c9a <cblas_sger+0x1ae>
 8008bde:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8008be2:	d07d      	beq.n	8008ce0 <cblas_sger+0x1f4>
 8008be4:	2800      	cmp	r0, #0
 8008be6:	d1a8      	bne.n	8008b3a <cblas_sger+0x4e>
        ix += incX;
      }
      jy += incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8008be8:	4a49      	ldr	r2, [pc, #292]	; (8008d10 <cblas_sger+0x224>)
 8008bea:	4948      	ldr	r1, [pc, #288]	; (8008d0c <cblas_sger+0x220>)
 8008bec:	2000      	movs	r0, #0
 8008bee:	b003      	add	sp, #12
 8008bf0:	ecbd 8b02 	vpop	{d8}
 8008bf4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008bf8:	f01f bd86 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008bfc:	2002      	movs	r0, #2
 8008bfe:	e78c      	b.n	8008b1a <cblas_sger+0x2e>
 8008c00:	2d01      	cmp	r5, #1
 8008c02:	4628      	mov	r0, r5
 8008c04:	bfb8      	it	lt
 8008c06:	2001      	movlt	r0, #1
 8008c08:	4287      	cmp	r7, r0
 8008c0a:	bfac      	ite	ge
 8008c0c:	2008      	movge	r0, #8
 8008c0e:	200a      	movlt	r0, #10
 8008c10:	4a3d      	ldr	r2, [pc, #244]	; (8008d08 <cblas_sger+0x21c>)
 8008c12:	493e      	ldr	r1, [pc, #248]	; (8008d0c <cblas_sger+0x220>)
 8008c14:	f01f fd78 	bl	8028708 <cblas_xerbla>
    INDEX ix = OFFSET(M, incX);
 8008c18:	f1b9 0f00 	cmp.w	r9, #0
 8008c1c:	dd4e      	ble.n	8008cbc <cblas_sger+0x1d0>
 8008c1e:	2300      	movs	r3, #0
    for (i = 0; i < M; i++) {
 8008c20:	2e00      	cmp	r6, #0
 8008c22:	ddc9      	ble.n	8008bb8 <cblas_sger+0xcc>
 8008c24:	2c00      	cmp	r4, #0
 8008c26:	f1c5 0201 	rsb	r2, r5, #1
 8008c2a:	eb0a 0a83 	add.w	sl, sl, r3, lsl #2
 8008c2e:	9b01      	ldr	r3, [sp, #4]
 8008c30:	fb02 f204 	mul.w	r2, r2, r4
      INDEX jy = OFFSET(N, incY);
 8008c34:	f04f 0c00 	mov.w	ip, #0
 8008c38:	bfc8      	it	gt
 8008c3a:	2200      	movgt	r2, #0
 8008c3c:	ea4f 0189 	mov.w	r1, r9, lsl #2
 8008c40:	eb03 0b82 	add.w	fp, r3, r2, lsl #2
 8008c44:	46e6      	mov	lr, ip
 8008c46:	00a2      	lsls	r2, r4, #2
 8008c48:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8008c4c:	eb08 0485 	add.w	r4, r8, r5, lsl #2
      const BASE tmp = alpha * X[ix];
 8008c50:	edda 6a00 	vldr	s13, [sl]
      for (j = 0; j < N; j++) {
 8008c54:	2d00      	cmp	r5, #0
      const BASE tmp = alpha * X[ix];
 8008c56:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (j = 0; j < N; j++) {
 8008c5a:	dd0d      	ble.n	8008c78 <cblas_sger+0x18c>
 8008c5c:	eb08 038c 	add.w	r3, r8, ip, lsl #2
 8008c60:	4658      	mov	r0, fp
        A[lda * i + j] += Y[jy] * tmp;
 8008c62:	ed90 7a00 	vldr	s14, [r0]
 8008c66:	edd3 7a00 	vldr	s15, [r3]
 8008c6a:	eee7 7a26 	vfma.f32	s15, s14, s13
 8008c6e:	4410      	add	r0, r2
 8008c70:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j < N; j++) {
 8008c74:	42a3      	cmp	r3, r4
 8008c76:	d1f4      	bne.n	8008c62 <cblas_sger+0x176>
    for (i = 0; i < M; i++) {
 8008c78:	f10e 0e01 	add.w	lr, lr, #1
 8008c7c:	4576      	cmp	r6, lr
 8008c7e:	448a      	add	sl, r1
 8008c80:	44bc      	add	ip, r7
 8008c82:	444c      	add	r4, r9
 8008c84:	d1e4      	bne.n	8008c50 <cblas_sger+0x164>
 8008c86:	b003      	add	sp, #12
 8008c88:	ecbd 8b02 	vpop	{d8}
 8008c8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    INDEX jy = OFFSET(N, incY);
 8008c90:	f1c5 0301 	rsb	r3, r5, #1
 8008c94:	fb03 f304 	mul.w	r3, r3, r4
 8008c98:	e75a      	b.n	8008b50 <cblas_sger+0x64>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008c9a:	2d01      	cmp	r5, #1
 8008c9c:	462b      	mov	r3, r5
 8008c9e:	bfb8      	it	lt
 8008ca0:	2301      	movlt	r3, #1
 8008ca2:	42bb      	cmp	r3, r7
 8008ca4:	dd2d      	ble.n	8008d02 <cblas_sger+0x216>
 8008ca6:	200a      	movs	r0, #10
 8008ca8:	e7b2      	b.n	8008c10 <cblas_sger+0x124>
 8008caa:	2d01      	cmp	r5, #1
 8008cac:	4628      	mov	r0, r5
 8008cae:	bfb8      	it	lt
 8008cb0:	2001      	movlt	r0, #1
 8008cb2:	42b8      	cmp	r0, r7
 8008cb4:	bfcc      	ite	gt
 8008cb6:	200a      	movgt	r0, #10
 8008cb8:	2006      	movle	r0, #6
 8008cba:	e7a9      	b.n	8008c10 <cblas_sger+0x124>
    INDEX ix = OFFSET(M, incX);
 8008cbc:	f1c6 0301 	rsb	r3, r6, #1
 8008cc0:	fb03 f309 	mul.w	r3, r3, r9
 8008cc4:	e7ac      	b.n	8008c20 <cblas_sger+0x134>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008cc6:	2e01      	cmp	r6, #1
 8008cc8:	4633      	mov	r3, r6
 8008cca:	bfb8      	it	lt
 8008ccc:	2301      	movlt	r3, #1
 8008cce:	42bb      	cmp	r3, r7
 8008cd0:	f77f af32 	ble.w	8008b38 <cblas_sger+0x4c>
 8008cd4:	4a0c      	ldr	r2, [pc, #48]	; (8008d08 <cblas_sger+0x21c>)
 8008cd6:	490d      	ldr	r1, [pc, #52]	; (8008d0c <cblas_sger+0x220>)
 8008cd8:	200a      	movs	r0, #10
 8008cda:	f01f fd15 	bl	8028708 <cblas_xerbla>
  if (order == CblasRowMajor) {
 8008cde:	e733      	b.n	8008b48 <cblas_sger+0x5c>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008ce0:	2e01      	cmp	r6, #1
 8008ce2:	4633      	mov	r3, r6
 8008ce4:	bfb8      	it	lt
 8008ce6:	2301      	movlt	r3, #1
 8008ce8:	42bb      	cmp	r3, r7
 8008cea:	dcf3      	bgt.n	8008cd4 <cblas_sger+0x1e8>
 8008cec:	2800      	cmp	r0, #0
 8008cee:	f43f af2b 	beq.w	8008b48 <cblas_sger+0x5c>
 8008cf2:	e722      	b.n	8008b3a <cblas_sger+0x4e>
 8008cf4:	2e01      	cmp	r6, #1
 8008cf6:	4633      	mov	r3, r6
 8008cf8:	bfb8      	it	lt
 8008cfa:	2301      	movlt	r3, #1
 8008cfc:	429f      	cmp	r7, r3
 8008cfe:	dbe9      	blt.n	8008cd4 <cblas_sger+0x1e8>
 8008d00:	e766      	b.n	8008bd0 <cblas_sger+0xe4>
 8008d02:	2800      	cmp	r0, #0
 8008d04:	d088      	beq.n	8008c18 <cblas_sger+0x12c>
 8008d06:	e783      	b.n	8008c10 <cblas_sger+0x124>
 8008d08:	08031108 	.word	0x08031108
 8008d0c:	080311e0 	.word	0x080311e0
 8008d10:	080311b8 	.word	0x080311b8

08008d14 <cblas_snrm2>:
  BASE scale = 0.0;
  BASE ssq = 1.0;
  INDEX i;
  INDEX ix = 0;

  if (N <= 0 || incX <= 0) {
 8008d14:	2800      	cmp	r0, #0
 8008d16:	dd4e      	ble.n	8008db6 <cblas_snrm2+0xa2>
 8008d18:	2a00      	cmp	r2, #0
 8008d1a:	dd4c      	ble.n	8008db6 <cblas_snrm2+0xa2>
    return 0;
  } else if (N == 1) {
 8008d1c:	2801      	cmp	r0, #1
 8008d1e:	d04d      	beq.n	8008dbc <cblas_snrm2+0xa8>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

float
cblas_snrm2 (const int N, const float *X, const int incX)
{
 8008d20:	b538      	push	{r3, r4, r5, lr}
  BASE ssq = 1.0;
 8008d22:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8008d26:	ed2d 8b02 	vpush	{d8}

    if (x != 0.0) {
      const BASE ax = fabs(x);

      if (scale < ax) {
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 8008d2a:	eeb0 6a66 	vmov.f32	s12, s13
  BASE scale = 0.0;
 8008d2e:	ed9f 8a26 	vldr	s16, [pc, #152]	; 8008dc8 <cblas_snrm2+0xb4>
 8008d32:	0092      	lsls	r2, r2, #2
  for (i = 0; i < N; i++) {
 8008d34:	2300      	movs	r3, #0
 8008d36:	e00f      	b.n	8008d58 <cblas_snrm2+0x44>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 8008d38:	eec8 7a07 	vdiv.f32	s15, s16, s14
        scale = ax;
 8008d3c:	eeb0 8a47 	vmov.f32	s16, s14
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 8008d40:	ee67 6aa6 	vmul.f32	s13, s15, s13
 8008d44:	eeb0 7a46 	vmov.f32	s14, s12
 8008d48:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8008d4c:	eef0 6a47 	vmov.f32	s13, s14
  for (i = 0; i < N; i++) {
 8008d50:	3301      	adds	r3, #1
 8008d52:	4298      	cmp	r0, r3
 8008d54:	4411      	add	r1, r2
 8008d56:	d015      	beq.n	8008d84 <cblas_snrm2+0x70>
    const BASE x = X[ix];
 8008d58:	edd1 7a00 	vldr	s15, [r1]
    if (x != 0.0) {
 8008d5c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008d60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      const BASE ax = fabs(x);
 8008d64:	eeb0 7ae7 	vabs.f32	s14, s15
    if (x != 0.0) {
 8008d68:	d0f2      	beq.n	8008d50 <cblas_snrm2+0x3c>
      if (scale < ax) {
 8008d6a:	eeb4 7ac8 	vcmpe.f32	s14, s16
 8008d6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008d72:	dce1      	bgt.n	8008d38 <cblas_snrm2+0x24>
      } else {
        ssq += (ax / scale) * (ax / scale);
 8008d74:	ee87 7a88 	vdiv.f32	s14, s15, s16
  for (i = 0; i < N; i++) {
 8008d78:	3301      	adds	r3, #1
 8008d7a:	4298      	cmp	r0, r3
 8008d7c:	4411      	add	r1, r2
        ssq += (ax / scale) * (ax / scale);
 8008d7e:	eee7 6a07 	vfma.f32	s13, s14, s14
  for (i = 0; i < N; i++) {
 8008d82:	d1e9      	bne.n	8008d58 <cblas_snrm2+0x44>
    }

    ix += incX;
  }

  return scale * sqrt(ssq);
 8008d84:	ee16 0a90 	vmov	r0, s13
 8008d88:	f01f fe96 	bl	8028ab8 <__aeabi_f2d>
 8008d8c:	ec41 0b10 	vmov	d0, r0, r1
 8008d90:	f027 ff40 	bl	8030c14 <sqrt>
 8008d94:	ec55 4b10 	vmov	r4, r5, d0
 8008d98:	ee18 0a10 	vmov	r0, s16
 8008d9c:	f01f fe8c 	bl	8028ab8 <__aeabi_f2d>
 8008da0:	4622      	mov	r2, r4
 8008da2:	462b      	mov	r3, r5
 8008da4:	f01f fee0 	bl	8028b68 <__aeabi_dmul>
 8008da8:	f020 f98e 	bl	80290c8 <__aeabi_d2f>
#define BASE float
#include "source_nrm2_r.h"
#undef BASE
}
 8008dac:	ecbd 8b02 	vpop	{d8}
 8008db0:	ee00 0a10 	vmov	s0, r0
 8008db4:	bd38      	pop	{r3, r4, r5, pc}
    return 0;
 8008db6:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8008dc8 <cblas_snrm2+0xb4>
 8008dba:	4770      	bx	lr
    return fabs(X[0]);
 8008dbc:	ed91 0a00 	vldr	s0, [r1]
 8008dc0:	eeb0 0ac0 	vabs.f32	s0, s0
 8008dc4:	4770      	bx	lr
 8008dc6:	bf00      	nop
 8008dc8:	00000000 	.word	0x00000000

08008dcc <cblas_srot>:
#include "cblas.h"

void
cblas_srot (const int N, float *X, const int incX, float *Y, const int incY,
            const float c, const float s)
{
 8008dcc:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 8008dce:	2a00      	cmp	r2, #0
 8008dd0:	9d04      	ldr	r5, [sp, #16]
 8008dd2:	bfda      	itte	le
 8008dd4:	f1c0 0701 	rsble	r7, r0, #1
 8008dd8:	4357      	mulle	r7, r2
 8008dda:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 8008ddc:	2d00      	cmp	r5, #0
 8008dde:	bfda      	itte	le
 8008de0:	f1c0 0601 	rsble	r6, r0, #1
 8008de4:	436e      	mulle	r6, r5
 8008de6:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 8008de8:	2800      	cmp	r0, #0
 8008dea:	dd1d      	ble.n	8008e28 <cblas_srot+0x5c>
 8008dec:	0094      	lsls	r4, r2, #2
 8008dee:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 8008df2:	00ad      	lsls	r5, r5, #2
 8008df4:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8008df8:	eeb1 6a60 	vneg.f32	s12, s1
 8008dfc:	2200      	movs	r2, #0
    const BASE x = X[ix];
    const BASE y = Y[iy];
 8008dfe:	edd3 7a00 	vldr	s15, [r3]
    const BASE x = X[ix];
 8008e02:	edd1 6a00 	vldr	s13, [r1]
    X[ix] = c * x + s * y;
 8008e06:	ee27 7aa0 	vmul.f32	s14, s15, s1
    Y[iy] = -s * x + c * y;
 8008e0a:	ee67 7a80 	vmul.f32	s15, s15, s0
    X[ix] = c * x + s * y;
 8008e0e:	eea6 7a80 	vfma.f32	s14, s13, s0
  for (i = 0; i < N; i++) {
 8008e12:	3201      	adds	r2, #1
 8008e14:	4290      	cmp	r0, r2
    Y[iy] = -s * x + c * y;
 8008e16:	eee6 7a86 	vfma.f32	s15, s13, s12
    X[ix] = c * x + s * y;
 8008e1a:	ed81 7a00 	vstr	s14, [r1]
    Y[iy] = -s * x + c * y;
 8008e1e:	edc3 7a00 	vstr	s15, [r3]
  for (i = 0; i < N; i++) {
 8008e22:	4421      	add	r1, r4
 8008e24:	442b      	add	r3, r5
 8008e26:	d1ea      	bne.n	8008dfe <cblas_srot+0x32>
#define BASE float
#include "source_rot.h"
#undef BASE
}
 8008e28:	bcf0      	pop	{r4, r5, r6, r7}
 8008e2a:	4770      	bx	lr

08008e2c <cblas_srotg>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_srotg (float *a, float *b, float *c, float *s)
{
 8008e2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008e30:	ed90 7a00 	vldr	s14, [r0]
 8008e34:	edd1 6a00 	vldr	s13, [r1]
  const BASE scale = fabs(*a) + fabs(*b);
  BASE r, z;

  if (scale != 0.0) {
 8008e38:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 8008f2c <cblas_srotg+0x100>
 8008e3c:	ed2d 8b02 	vpush	{d8}
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008e40:	eef0 7ac7 	vabs.f32	s15, s14
 8008e44:	eeb0 8ae6 	vabs.f32	s16, s13
 8008e48:	eef4 7ac8 	vcmpe.f32	s15, s16
  const BASE scale = fabs(*a) + fabs(*b);
 8008e4c:	ee37 8a88 	vadd.f32	s16, s15, s16
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008e50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (scale != 0.0) {
 8008e54:	eeb4 8a46 	vcmp.f32	s16, s12
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008e58:	bfd4      	ite	le
 8008e5a:	eef0 8a66 	vmovle.f32	s17, s13
 8008e5e:	eef0 8a47 	vmovgt.f32	s17, s14
  if (scale != 0.0) {
 8008e62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008e66:	4607      	mov	r7, r0
 8008e68:	460c      	mov	r4, r1
 8008e6a:	4615      	mov	r5, r2
 8008e6c:	461e      	mov	r6, r3
 8008e6e:	d110      	bne.n	8008e92 <cblas_srotg+0x66>
    if (fabs(*a) > fabs(*b))
      z = *s;
    if (fabs(*b) >= fabs(*a) && *c != 0.0)
      z = 1.0 / (*c);
  } else {
    *c = 1.0;
 8008e70:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8008e74:	6013      	str	r3, [r2, #0]
    *s = 0.0;
    r = 0.0;
    z = 0.0;
 8008e76:	eef0 7a46 	vmov.f32	s15, s12
    r = 0.0;
 8008e7a:	eeb0 7a46 	vmov.f32	s14, s12
    *s = 0.0;
 8008e7e:	ed86 6a00 	vstr	s12, [r6]
#define BASE float
#include "source_rotg.h"
#undef BASE
}
 8008e82:	ecbd 8b02 	vpop	{d8}
  }

  *a = r;
 8008e86:	ed87 7a00 	vstr	s14, [r7]
  *b = z;
 8008e8a:	edc4 7a00 	vstr	s15, [r4]
 8008e8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    const BASE bos = *b / scale;
 8008e92:	eec6 7a88 	vdiv.f32	s15, s13, s16
    const BASE aos = *a / scale;
 8008e96:	eec7 6a08 	vdiv.f32	s13, s14, s16
    r = scale * sqrt(aos * aos + bos * bos);
 8008e9a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8008e9e:	eee6 7aa6 	vfma.f32	s15, s13, s13
 8008ea2:	ee17 0a90 	vmov	r0, s15
 8008ea6:	f01f fe07 	bl	8028ab8 <__aeabi_f2d>
 8008eaa:	ec41 0b10 	vmov	d0, r0, r1
 8008eae:	f027 feb1 	bl	8030c14 <sqrt>
 8008eb2:	ec59 8b10 	vmov	r8, r9, d0
 8008eb6:	ee18 0a10 	vmov	r0, s16
 8008eba:	f01f fdfd 	bl	8028ab8 <__aeabi_f2d>
 8008ebe:	4642      	mov	r2, r8
 8008ec0:	464b      	mov	r3, r9
 8008ec2:	f01f fe51 	bl	8028b68 <__aeabi_dmul>
 8008ec6:	f020 f8ff 	bl	80290c8 <__aeabi_d2f>
    r = GSL_SIGN(roe) * r;
 8008eca:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    r = scale * sqrt(aos * aos + bos * bos);
 8008ece:	ee07 0a10 	vmov	s14, r0
    *c = *a / r;
 8008ed2:	edd7 6a00 	vldr	s13, [r7]
    r = GSL_SIGN(roe) * r;
 8008ed6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008eda:	bfb8      	it	lt
 8008edc:	eeb1 7a47 	vneglt.f32	s14, s14
    *c = *a / r;
 8008ee0:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z = 1.0;
 8008ee4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    *c = *a / r;
 8008ee8:	edc5 7a00 	vstr	s15, [r5]
    *s = *b / r;
 8008eec:	edd4 6a00 	vldr	s13, [r4]
 8008ef0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8008ef4:	edc6 7a00 	vstr	s15, [r6]
    if (fabs(*a) > fabs(*b))
 8008ef8:	ed97 6a00 	vldr	s12, [r7]
 8008efc:	edd4 6a00 	vldr	s13, [r4]
 8008f00:	eeb0 6ac6 	vabs.f32	s12, s12
 8008f04:	eef0 6ae6 	vabs.f32	s13, s13
    z = 1.0;
 8008f08:	eeb4 6ae6 	vcmpe.f32	s12, s13
 8008f0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f10:	bfd8      	it	le
 8008f12:	eef0 7a65 	vmovle.f32	s15, s11
    if (fabs(*b) >= fabs(*a) && *c != 0.0)
 8008f16:	d8b4      	bhi.n	8008e82 <cblas_srotg+0x56>
 8008f18:	edd5 6a00 	vldr	s13, [r5]
 8008f1c:	eef5 6a40 	vcmp.f32	s13, #0.0
 8008f20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f24:	d0ad      	beq.n	8008e82 <cblas_srotg+0x56>
      z = 1.0 / (*c);
 8008f26:	eec5 7aa6 	vdiv.f32	s15, s11, s13
 8008f2a:	e7aa      	b.n	8008e82 <cblas_srotg+0x56>
 8008f2c:	00000000 	.word	0x00000000

08008f30 <cblas_srotm>:
#include "cblas.h"

void
cblas_srotm (const int N, float *X, const int incX, float *Y, const int incY,
             const float *P)
{
 8008f30:	b4f0      	push	{r4, r5, r6, r7}
 8008f32:	e9dd 5404 	ldrd	r5, r4, [sp, #16]
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX n;
  INDEX i = OFFSET(N, incX);
 8008f36:	2a00      	cmp	r2, #0
 8008f38:	bfd8      	it	le
 8008f3a:	f1c0 0701 	rsble	r7, r0, #1
  INDEX j = OFFSET(N, incY);

  BASE h11, h21, h12, h22;

  if (P[0] == -1.0) {
 8008f3e:	ed94 6a00 	vldr	s12, [r4]
  INDEX i = OFFSET(N, incX);
 8008f42:	bfd4      	ite	le
 8008f44:	4357      	mulle	r7, r2
 8008f46:	2700      	movgt	r7, #0
  if (P[0] == -1.0) {
 8008f48:	eeff 5a00 	vmov.f32	s11, #240	; 0xbf800000 -1.0
  INDEX j = OFFSET(N, incY);
 8008f4c:	2d00      	cmp	r5, #0
 8008f4e:	bfd8      	it	le
 8008f50:	f1c0 0601 	rsble	r6, r0, #1
  if (P[0] == -1.0) {
 8008f54:	eeb4 6a65 	vcmp.f32	s12, s11
  INDEX j = OFFSET(N, incY);
 8008f58:	bfd4      	ite	le
 8008f5a:	436e      	mulle	r6, r5
 8008f5c:	2600      	movgt	r6, #0
  if (P[0] == -1.0) {
 8008f5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008f62:	d127      	bne.n	8008fb4 <cblas_srotm+0x84>
    h11 = P[1];
 8008f64:	edd4 4a01 	vldr	s9, [r4, #4]
    h21 = P[2];
 8008f68:	edd4 5a02 	vldr	s11, [r4, #8]
    h12 = P[3];
 8008f6c:	ed94 6a03 	vldr	s12, [r4, #12]
    h22 = P[4];
 8008f70:	ed94 5a04 	vldr	s10, [r4, #16]
  } else {
    BLAS_ERROR("unrecognized value of P[0]");
    return;
  }

  for (n = 0; n < N; n++) {
 8008f74:	2800      	cmp	r0, #0
 8008f76:	dd1b      	ble.n	8008fb0 <cblas_srotm+0x80>
 8008f78:	0094      	lsls	r4, r2, #2
 8008f7a:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 8008f7e:	00ad      	lsls	r5, r5, #2
 8008f80:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8008f84:	2200      	movs	r2, #0
    const BASE w = X[i];
    const BASE z = Y[j];
 8008f86:	edd3 7a00 	vldr	s15, [r3]
    const BASE w = X[i];
 8008f8a:	edd1 6a00 	vldr	s13, [r1]
    X[i] = h11 * w + h12 * z;
 8008f8e:	ee26 7a27 	vmul.f32	s14, s12, s15
    Y[j] = h21 * w + h22 * z;
 8008f92:	ee65 7a27 	vmul.f32	s15, s10, s15
    X[i] = h11 * w + h12 * z;
 8008f96:	eea4 7aa6 	vfma.f32	s14, s9, s13
  for (n = 0; n < N; n++) {
 8008f9a:	3201      	adds	r2, #1
 8008f9c:	4290      	cmp	r0, r2
    Y[j] = h21 * w + h22 * z;
 8008f9e:	eee5 7aa6 	vfma.f32	s15, s11, s13
    X[i] = h11 * w + h12 * z;
 8008fa2:	ed81 7a00 	vstr	s14, [r1]
    Y[j] = h21 * w + h22 * z;
 8008fa6:	edc3 7a00 	vstr	s15, [r3]
  for (n = 0; n < N; n++) {
 8008faa:	4421      	add	r1, r4
 8008fac:	442b      	add	r3, r5
 8008fae:	d1ea      	bne.n	8008f86 <cblas_srotm+0x56>
#define BASE float
#include "source_rotm.h"
#undef BASE
}
 8008fb0:	bcf0      	pop	{r4, r5, r6, r7}
 8008fb2:	4770      	bx	lr
  } else if (P[0] == 0.0) {
 8008fb4:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8008fb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fbc:	d108      	bne.n	8008fd0 <cblas_srotm+0xa0>
    h22 = 1.0;
 8008fbe:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    h21 = P[2];
 8008fc2:	edd4 5a02 	vldr	s11, [r4, #8]
    h12 = P[3];
 8008fc6:	ed94 6a03 	vldr	s12, [r4, #12]
    h11 = 1.0;
 8008fca:	eef0 4a45 	vmov.f32	s9, s10
 8008fce:	e7d1      	b.n	8008f74 <cblas_srotm+0x44>
  } else if (P[0] == 1.0) {
 8008fd0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008fd4:	eeb4 6a67 	vcmp.f32	s12, s15
 8008fd8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008fdc:	d104      	bne.n	8008fe8 <cblas_srotm+0xb8>
    h11 = P[1];
 8008fde:	edd4 4a01 	vldr	s9, [r4, #4]
    h22 = P[4];
 8008fe2:	ed94 5a04 	vldr	s10, [r4, #16]
 8008fe6:	e7c5      	b.n	8008f74 <cblas_srotm+0x44>
  } else if (P[0] == -2.0) {
 8008fe8:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 8008fec:	eeb4 6a67 	vcmp.f32	s12, s15
 8008ff0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008ff4:	d0dc      	beq.n	8008fb0 <cblas_srotm+0x80>
 8008ff6:	bcf0      	pop	{r4, r5, r6, r7}
    BLAS_ERROR("unrecognized value of P[0]");
 8008ff8:	4a02      	ldr	r2, [pc, #8]	; (8009004 <cblas_srotm+0xd4>)
 8008ffa:	4903      	ldr	r1, [pc, #12]	; (8009008 <cblas_srotm+0xd8>)
 8008ffc:	2000      	movs	r0, #0
 8008ffe:	f01f bb83 	b.w	8028708 <cblas_xerbla>
 8009002:	bf00      	nop
 8009004:	080311f0 	.word	0x080311f0
 8009008:	0803120c 	.word	0x0803120c

0800900c <cblas_srotmg>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const BASE G = 4096.0, G2 = G * G;
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800900c:	ed90 4a00 	vldr	s8, [r0]

  BASE c, s;

  /* case of d1 < 0, appendix A, second to last paragraph */

  if (D1 < 0.0) {
 8009010:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
 8009014:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_srotmg (float *d1, float *d2, float *b1, const float b2, float *P)
{
 8009018:	b430      	push	{r4, r5}
 800901a:	d43f      	bmi.n	800909c <cblas_srotmg+0x90>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800901c:	ed91 3a00 	vldr	s6, [r1]
    *d2 = 0;
    *b1 = 0;
    return;
  }

  if (D2 * y == 0.0) {
 8009020:	ee63 7a00 	vmul.f32	s15, s6, s0
 8009024:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009028:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800902c:	d02c      	beq.n	8009088 <cblas_srotmg+0x7c>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800902e:	edd2 3a00 	vldr	s7, [r2]
    P[0] = -2;                  /* case of H = I, page 315 */
    return;
  }

  c = fabs(D1 * x * x);
 8009032:	ee64 6a23 	vmul.f32	s13, s8, s7
  s = fabs(D2 * y * y);
 8009036:	ee27 6a80 	vmul.f32	s12, s15, s0
  c = fabs(D1 * x * x);
 800903a:	ee26 7aa3 	vmul.f32	s14, s13, s7
  s = fabs(D2 * y * y);
 800903e:	eef0 5ac6 	vabs.f32	s11, s12
  c = fabs(D1 * x * x);
 8009042:	eeb0 7ac7 	vabs.f32	s14, s14

  if (c > s) {
 8009046:	eeb4 7ae5 	vcmpe.f32	s14, s11
 800904a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800904e:	dd20      	ble.n	8009092 <cblas_srotmg+0x86>

    P[0] = 0.0;

    h11 = 1;
    h12 = (D2 * y) / (D1 * x);
    h21 = -y / x;
 8009050:	eeb1 0a40 	vneg.f32	s0, s0
    h12 = (D2 * y) / (D1 * x);
 8009054:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8009058:	2400      	movs	r4, #0
    P[0] = 0.0;
 800905a:	601c      	str	r4, [r3, #0]
    h21 = -y / x;
 800905c:	ee80 5a23 	vdiv.f32	s10, s0, s7
    h22 = 1;

    u = 1 - h21 * h12;
 8009060:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 8009064:	eef0 6a65 	vmov.f32	s13, s11
 8009068:	eee6 6a45 	vfms.f32	s13, s12, s10

    if (u <= 0.0) {             /* the case u <= 0 is rejected */
 800906c:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 8009070:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009074:	d912      	bls.n	800909c <cblas_srotmg+0x90>
      *d2 = 0;
      *b1 = 0;
      return;
    }

    D1 /= u;
 8009076:	eec4 7a26 	vdiv.f32	s15, s8, s13
    D2 /= u;
 800907a:	ee83 7a26 	vdiv.f32	s14, s6, s13
    h11 = 1;
 800907e:	eef0 4a65 	vmov.f32	s9, s11
    x *= u;
 8009082:	ee63 6aa6 	vmul.f32	s13, s7, s13
 8009086:	e029      	b.n	80090dc <cblas_srotmg+0xd0>
    P[0] = -2;                  /* case of H = I, page 315 */
 8009088:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
 800908c:	601a      	str	r2, [r3, #0]
#define BASE float
#include "source_rotmg.h"
#undef BASE
}
 800908e:	bc30      	pop	{r4, r5}
 8009090:	4770      	bx	lr
  } else {
    /* case of equation A7 */

    if (D2 * y * y < 0.0) {
 8009092:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
 8009096:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800909a:	d50b      	bpl.n	80090b4 <cblas_srotmg+0xa8>
    P[1] = 0;
 800909c:	2400      	movs	r4, #0
    P[0] = -1;
 800909e:	4d62      	ldr	r5, [pc, #392]	; (8009228 <cblas_srotmg+0x21c>)
    P[1] = 0;
 80090a0:	605c      	str	r4, [r3, #4]
    P[2] = 0;
 80090a2:	609c      	str	r4, [r3, #8]
    P[3] = 0;
 80090a4:	60dc      	str	r4, [r3, #12]
    P[4] = 0;
 80090a6:	611c      	str	r4, [r3, #16]
    P[0] = -1;
 80090a8:	601d      	str	r5, [r3, #0]
    *d1 = 0;
 80090aa:	6004      	str	r4, [r0, #0]
    *d2 = 0;
 80090ac:	600c      	str	r4, [r1, #0]
    *b1 = 0;
 80090ae:	6014      	str	r4, [r2, #0]
 80090b0:	bc30      	pop	{r4, r5}
 80090b2:	4770      	bx	lr
      return;
    }

    P[0] = 1;

    h11 = (D1 * x) / (D2 * y);
 80090b4:	eec6 4aa7 	vdiv.f32	s9, s13, s15
    h12 = 1;
    h21 = -1;
    h22 = x / y;
 80090b8:	eec3 5a80 	vdiv.f32	s11, s7, s0
    P[0] = 1;
 80090bc:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0

    u = 1 + h11 * h22;
 80090c0:	eef0 6a46 	vmov.f32	s13, s12
 80090c4:	eee4 6aa5 	vfma.f32	s13, s9, s11
    P[0] = 1;
 80090c8:	ed83 6a00 	vstr	s12, [r3]

    D1 /= u;
 80090cc:	ee84 7a26 	vdiv.f32	s14, s8, s13
    D2 /= u;
 80090d0:	eec3 7a26 	vdiv.f32	s15, s6, s13
      BASE tmp = D2;
      D2 = D1;
      D1 = tmp;
    }

    x = y * u;
 80090d4:	ee60 6a26 	vmul.f32	s13, s0, s13
    h21 = -1;
 80090d8:	eebf 5a00 	vmov.f32	s10, #240	; 0xbf800000 -1.0
  }

  /* rescale D1 to range [1/G2,G2] */

  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 80090dc:	eddf 3a53 	vldr	s7, [pc, #332]	; 800922c <cblas_srotmg+0x220>
 80090e0:	eef4 7ae3 	vcmpe.f32	s15, s7
 80090e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090e8:	d818      	bhi.n	800911c <cblas_srotmg+0x110>
    P[0] = -1;
 80090ea:	4c4f      	ldr	r4, [pc, #316]	; (8009228 <cblas_srotmg+0x21c>)
    D1 *= G2;
 80090ec:	ed9f 3a50 	vldr	s6, [pc, #320]	; 8009230 <cblas_srotmg+0x224>
    x /= G;
 80090f0:	ed9f 4a50 	vldr	s8, [pc, #320]	; 8009234 <cblas_srotmg+0x228>
 80090f4:	e00d      	b.n	8009112 <cblas_srotmg+0x106>
    D1 *= G2;
 80090f6:	ee67 7a83 	vmul.f32	s15, s15, s6
    x /= G;
 80090fa:	ee66 6a84 	vmul.f32	s13, s13, s8
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 80090fe:	eef4 7ae3 	vcmpe.f32	s15, s7
 8009102:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h11 /= G;
 8009106:	ee64 4a84 	vmul.f32	s9, s9, s8
    h12 /= G;
 800910a:	ee26 6a04 	vmul.f32	s12, s12, s8
    P[0] = -1;
 800910e:	601c      	str	r4, [r3, #0]
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 8009110:	d804      	bhi.n	800911c <cblas_srotmg+0x110>
 8009112:	eef5 7a40 	vcmp.f32	s15, #0.0
 8009116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800911a:	d1ec      	bne.n	80090f6 <cblas_srotmg+0xea>
  }

  while (D1 >= G2) {
 800911c:	eddf 3a44 	vldr	s7, [pc, #272]	; 8009230 <cblas_srotmg+0x224>
 8009120:	eef4 7ae3 	vcmpe.f32	s15, s7
 8009124:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009128:	db12      	blt.n	8009150 <cblas_srotmg+0x144>
    P[0] = -1;
    D1 /= G2;
 800912a:	ed9f 3a40 	vldr	s6, [pc, #256]	; 800922c <cblas_srotmg+0x220>
    x *= G;
 800912e:	ed9f 4a42 	vldr	s8, [pc, #264]	; 8009238 <cblas_srotmg+0x22c>
    D1 /= G2;
 8009132:	ee67 7a83 	vmul.f32	s15, s15, s6
    x *= G;
 8009136:	ee66 6a84 	vmul.f32	s13, s13, s8
  while (D1 >= G2) {
 800913a:	eef4 7ae3 	vcmpe.f32	s15, s7
 800913e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h11 *= G;
 8009142:	ee64 4a84 	vmul.f32	s9, s9, s8
    h12 *= G;
 8009146:	ee26 6a04 	vmul.f32	s12, s12, s8
  while (D1 >= G2) {
 800914a:	daf2      	bge.n	8009132 <cblas_srotmg+0x126>
 800914c:	4c36      	ldr	r4, [pc, #216]	; (8009228 <cblas_srotmg+0x21c>)
 800914e:	601c      	str	r4, [r3, #0]
  }

  /* rescale D2 to range [1/G2,G2] */

  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 8009150:	ed9f 3a36 	vldr	s6, [pc, #216]	; 800922c <cblas_srotmg+0x220>
 8009154:	eeb0 4ac7 	vabs.f32	s8, s14
 8009158:	eeb4 4ac3 	vcmpe.f32	s8, s6
 800915c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009160:	d818      	bhi.n	8009194 <cblas_srotmg+0x188>
    P[0] = -1;
 8009162:	4c31      	ldr	r4, [pc, #196]	; (8009228 <cblas_srotmg+0x21c>)
    D2 *= G2;
 8009164:	eddf 2a32 	vldr	s5, [pc, #200]	; 8009230 <cblas_srotmg+0x224>
    h21 /= G;
 8009168:	eddf 3a32 	vldr	s7, [pc, #200]	; 8009234 <cblas_srotmg+0x228>
 800916c:	e00d      	b.n	800918a <cblas_srotmg+0x17e>
    D2 *= G2;
 800916e:	ee27 7a22 	vmul.f32	s14, s14, s5
    h21 /= G;
 8009172:	ee25 5a23 	vmul.f32	s10, s10, s7
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 8009176:	eeb0 4ac7 	vabs.f32	s8, s14
 800917a:	eeb4 4ac3 	vcmpe.f32	s8, s6
 800917e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h22 /= G;
 8009182:	ee65 5aa3 	vmul.f32	s11, s11, s7
    P[0] = -1;
 8009186:	601c      	str	r4, [r3, #0]
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 8009188:	d804      	bhi.n	8009194 <cblas_srotmg+0x188>
 800918a:	eeb5 7a40 	vcmp.f32	s14, #0.0
 800918e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009192:	d1ec      	bne.n	800916e <cblas_srotmg+0x162>
  }

  while (fabs(D2) >= G2) {
 8009194:	ed9f 3a26 	vldr	s6, [pc, #152]	; 8009230 <cblas_srotmg+0x224>
 8009198:	eeb4 4ac3 	vcmpe.f32	s8, s6
 800919c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80091a0:	db12      	blt.n	80091c8 <cblas_srotmg+0x1bc>
    P[0] = -1;
    D2 /= G2;
 80091a2:	eddf 2a22 	vldr	s5, [pc, #136]	; 800922c <cblas_srotmg+0x220>
    h21 *= G;
 80091a6:	ed9f 4a24 	vldr	s8, [pc, #144]	; 8009238 <cblas_srotmg+0x22c>
    D2 /= G2;
 80091aa:	ee27 7a22 	vmul.f32	s14, s14, s5
    h21 *= G;
 80091ae:	ee25 5a04 	vmul.f32	s10, s10, s8
  while (fabs(D2) >= G2) {
 80091b2:	eef0 3ac7 	vabs.f32	s7, s14
 80091b6:	eef4 3ac3 	vcmpe.f32	s7, s6
 80091ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h22 *= G;
 80091be:	ee65 5a84 	vmul.f32	s11, s11, s8
  while (fabs(D2) >= G2) {
 80091c2:	daf2      	bge.n	80091aa <cblas_srotmg+0x19e>
 80091c4:	4c18      	ldr	r4, [pc, #96]	; (8009228 <cblas_srotmg+0x21c>)
 80091c6:	601c      	str	r4, [r3, #0]
  }

  *d1 = D1;
 80091c8:	edc0 7a00 	vstr	s15, [r0]
  *d2 = D2;
 80091cc:	ed81 7a00 	vstr	s14, [r1]
  *b1 = x;
 80091d0:	edc2 6a00 	vstr	s13, [r2]

  if (P[0] == -1.0) {
 80091d4:	edd3 7a00 	vldr	s15, [r3]
 80091d8:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 80091dc:	eef4 7a47 	vcmp.f32	s15, s14
 80091e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80091e4:	d109      	bne.n	80091fa <cblas_srotmg+0x1ee>
 80091e6:	bc30      	pop	{r4, r5}
    P[1] = h11;
 80091e8:	edc3 4a01 	vstr	s9, [r3, #4]
    P[2] = h21;
 80091ec:	ed83 5a02 	vstr	s10, [r3, #8]
    P[3] = h12;
 80091f0:	ed83 6a03 	vstr	s12, [r3, #12]
    P[4] = h22;
 80091f4:	edc3 5a04 	vstr	s11, [r3, #16]
 80091f8:	4770      	bx	lr
  } else if (P[0] == 0.0) {
 80091fa:	eef5 7a40 	vcmp.f32	s15, #0.0
 80091fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009202:	d104      	bne.n	800920e <cblas_srotmg+0x202>
    P[2] = h21;
 8009204:	ed83 5a02 	vstr	s10, [r3, #8]
    P[3] = h12;
 8009208:	ed83 6a03 	vstr	s12, [r3, #12]
 800920c:	e73f      	b.n	800908e <cblas_srotmg+0x82>
  } else if (P[0] == 1.0) {
 800920e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8009212:	eef4 7a47 	vcmp.f32	s15, s14
 8009216:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    P[1] = h11;
 800921a:	bf04      	itt	eq
 800921c:	edc3 4a01 	vstreq	s9, [r3, #4]
    P[4] = h22;
 8009220:	edc3 5a04 	vstreq	s11, [r3, #16]
 8009224:	e733      	b.n	800908e <cblas_srotmg+0x82>
 8009226:	bf00      	nop
 8009228:	bf800000 	.word	0xbf800000
 800922c:	33800000 	.word	0x33800000
 8009230:	4b800000 	.word	0x4b800000
 8009234:	39800000 	.word	0x39800000
 8009238:	45800000 	.word	0x45800000

0800923c <cblas_sscal>:

{
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 800923c:	2a00      	cmp	r2, #0
 800923e:	dd0d      	ble.n	800925c <cblas_sscal+0x20>
    return;
  }

  for (i = 0; i < N; i++) {
 8009240:	2800      	cmp	r0, #0
 8009242:	dd0b      	ble.n	800925c <cblas_sscal+0x20>
 8009244:	0092      	lsls	r2, r2, #2
 8009246:	2300      	movs	r3, #0
    X[ix] *= alpha;
 8009248:	edd1 7a00 	vldr	s15, [r1]
  for (i = 0; i < N; i++) {
 800924c:	3301      	adds	r3, #1
    X[ix] *= alpha;
 800924e:	ee67 7a80 	vmul.f32	s15, s15, s0
  for (i = 0; i < N; i++) {
 8009252:	4298      	cmp	r0, r3
    X[ix] *= alpha;
 8009254:	edc1 7a00 	vstr	s15, [r1]
  for (i = 0; i < N; i++) {
 8009258:	4411      	add	r1, r2
 800925a:	d1f5      	bne.n	8009248 <cblas_sscal+0xc>
cblas_sscal (const int N, const float alpha, float *X, const int incX)
{
#define BASE float
#include "source_scal_r.h"
#undef BASE
}
 800925c:	4770      	bx	lr
 800925e:	bf00      	nop

08009260 <cblas_sswap>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_sswap (const int N, float *X, const int incX, float *Y, const int incY)
{
 8009260:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 8009262:	2a00      	cmp	r2, #0
 8009264:	9f04      	ldr	r7, [sp, #16]
 8009266:	bfda      	itte	le
 8009268:	f1c0 0501 	rsble	r5, r0, #1
 800926c:	4355      	mulle	r5, r2
 800926e:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 8009270:	2f00      	cmp	r7, #0
 8009272:	bfda      	itte	le
 8009274:	f1c0 0401 	rsble	r4, r0, #1
 8009278:	437c      	mulle	r4, r7
 800927a:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 800927c:	2800      	cmp	r0, #0
 800927e:	dd0f      	ble.n	80092a0 <cblas_sswap+0x40>
 8009280:	0096      	lsls	r6, r2, #2
 8009282:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 8009286:	00bf      	lsls	r7, r7, #2
 8009288:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800928c:	2200      	movs	r2, #0
 800928e:	3201      	adds	r2, #1
    const BASE tmp = X[ix];
 8009290:	680c      	ldr	r4, [r1, #0]
    X[ix] = Y[iy];
 8009292:	681d      	ldr	r5, [r3, #0]
 8009294:	600d      	str	r5, [r1, #0]
  for (i = 0; i < N; i++) {
 8009296:	4290      	cmp	r0, r2
    Y[iy] = tmp;
 8009298:	601c      	str	r4, [r3, #0]
  for (i = 0; i < N; i++) {
 800929a:	4431      	add	r1, r6
 800929c:	443b      	add	r3, r7
 800929e:	d1f6      	bne.n	800928e <cblas_sswap+0x2e>
#define BASE float
#include "source_swap_r.h"
#undef BASE
}
 80092a0:	bcf0      	pop	{r4, r5, r6, r7}
 80092a2:	4770      	bx	lr

080092a4 <cblas_ssymm>:
void
cblas_ssymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const float alpha, const float *A, const int lda, const float *B,
             const int ldb, const float beta, float *C, const int ldc)
{
 80092a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80092a8:	ed2d 8b02 	vpush	{d8}
 80092ac:	b08d      	sub	sp, #52	; 0x34
 80092ae:	461e      	mov	r6, r3
 80092b0:	e9dd b318 	ldrd	fp, r3, [sp, #96]	; 0x60
 80092b4:	9301      	str	r3, [sp, #4]
 80092b6:	e9dd 831a 	ldrd	r8, r3, [sp, #104]	; 0x68
 80092ba:	9305      	str	r3, [sp, #20]
 80092bc:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80092be:	9303      	str	r3, [sp, #12]
 80092c0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80092c2:	9304      	str	r3, [sp, #16]
{
  INDEX i, j, k;
  INDEX n1, n2;
  int uplo, side;

  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80092c4:	298d      	cmp	r1, #141	; 0x8d
 80092c6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80092c8:	9302      	str	r3, [sp, #8]
 80092ca:	460c      	mov	r4, r1
 80092cc:	4607      	mov	r7, r0
 80092ce:	4615      	mov	r5, r2
 80092d0:	eeb0 8a40 	vmov.f32	s16, s0
 80092d4:	eef0 8a60 	vmov.f32	s17, s1
 80092d8:	f000 80ae 	beq.w	8009438 <cblas_ssymm+0x194>
 80092dc:	298e      	cmp	r1, #142	; 0x8e
 80092de:	f000 81d4 	beq.w	800968a <cblas_ssymm+0x3e6>
 80092e2:	465b      	mov	r3, fp
 80092e4:	2002      	movs	r0, #2
 80092e6:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 80092ea:	2a01      	cmp	r2, #1
 80092ec:	bf88      	it	hi
 80092ee:	2003      	movhi	r0, #3
 80092f0:	2e00      	cmp	r6, #0
 80092f2:	bfb8      	it	lt
 80092f4:	2004      	movlt	r0, #4
 80092f6:	2b01      	cmp	r3, #1
 80092f8:	bfb8      	it	lt
 80092fa:	2301      	movlt	r3, #1
 80092fc:	f1bb 0f00 	cmp.w	fp, #0
 8009300:	f2c0 8090 	blt.w	8009424 <cblas_ssymm+0x180>
 8009304:	4543      	cmp	r3, r8
 8009306:	dd54      	ble.n	80093b2 <cblas_ssymm+0x10e>
 8009308:	2f65      	cmp	r7, #101	; 0x65
 800930a:	f000 81a2 	beq.w	8009652 <cblas_ssymm+0x3ae>
 800930e:	2f66      	cmp	r7, #102	; 0x66
 8009310:	f000 81ad 	beq.w	800966e <cblas_ssymm+0x3ca>
 8009314:	2008      	movs	r0, #8
 8009316:	4a93      	ldr	r2, [pc, #588]	; (8009564 <cblas_ssymm+0x2c0>)
 8009318:	4993      	ldr	r1, [pc, #588]	; (8009568 <cblas_ssymm+0x2c4>)
 800931a:	f01f f9f5 	bl	8028708 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 800931e:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009322:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009326:	d106      	bne.n	8009336 <cblas_ssymm+0x92>
 8009328:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800932c:	eef4 8a67 	vcmp.f32	s17, s15
 8009330:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009334:	d04d      	beq.n	80093d2 <cblas_ssymm+0x12e>
    return;

  if (Order == CblasRowMajor) {
 8009336:	2f65      	cmp	r7, #101	; 0x65
 8009338:	f000 8085 	beq.w	8009446 <cblas_ssymm+0x1a2>
    uplo = Uplo;
    side = Side;
  } else {
    n1 = N;
    n2 = M;
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800933c:	2d79      	cmp	r5, #121	; 0x79
 800933e:	bf0c      	ite	eq
 8009340:	257a      	moveq	r5, #122	; 0x7a
 8009342:	2579      	movne	r5, #121	; 0x79
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8009344:	2c8d      	cmp	r4, #141	; 0x8d
 8009346:	bf0c      	ite	eq
 8009348:	248e      	moveq	r4, #142	; 0x8e
 800934a:	248d      	movne	r4, #141	; 0x8d
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 800934c:	eef5 8a40 	vcmp.f32	s17, #0.0
 8009350:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009354:	d142      	bne.n	80093dc <cblas_ssymm+0x138>
    for (i = 0; i < n1; i++) {
 8009356:	f1bb 0f00 	cmp.w	fp, #0
 800935a:	dd16      	ble.n	800938a <cblas_ssymm+0xe6>
 800935c:	9b02      	ldr	r3, [sp, #8]
 800935e:	0099      	lsls	r1, r3, #2
 8009360:	9b04      	ldr	r3, [sp, #16]
 8009362:	ebc6 7286 	rsb	r2, r6, r6, lsl #30
 8009366:	0092      	lsls	r2, r2, #2
 8009368:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 800936c:	2700      	movs	r7, #0
      for (j = 0; j < n2; j++) {
        C[ldc * i + j] = 0.0;
 800936e:	f04f 0c00 	mov.w	ip, #0
      for (j = 0; j < n2; j++) {
 8009372:	2e00      	cmp	r6, #0
 8009374:	bfc8      	it	gt
 8009376:	1883      	addgt	r3, r0, r2
 8009378:	dd03      	ble.n	8009382 <cblas_ssymm+0xde>
        C[ldc * i + j] = 0.0;
 800937a:	f843 cb04 	str.w	ip, [r3], #4
      for (j = 0; j < n2; j++) {
 800937e:	4283      	cmp	r3, r0
 8009380:	d1fb      	bne.n	800937a <cblas_ssymm+0xd6>
    for (i = 0; i < n1; i++) {
 8009382:	3701      	adds	r7, #1
 8009384:	45bb      	cmp	fp, r7
 8009386:	4408      	add	r0, r1
 8009388:	d1f3      	bne.n	8009372 <cblas_ssymm+0xce>
        C[ldc * i + j] *= beta;
      }
    }
  }

  if (alpha == 0.0)
 800938a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800938e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009392:	d01e      	beq.n	80093d2 <cblas_ssymm+0x12e>
    return;

  if (side == CblasLeft && uplo == CblasUpper) {
 8009394:	2c8d      	cmp	r4, #141	; 0x8d
 8009396:	f000 80ed 	beq.w	8009574 <cblas_ssymm+0x2d0>
        }
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
      }
    }

  } else if (side == CblasRight && uplo == CblasUpper) {
 800939a:	2c8e      	cmp	r4, #142	; 0x8e
 800939c:	d057      	beq.n	800944e <cblas_ssymm+0x1aa>
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 800939e:	4a73      	ldr	r2, [pc, #460]	; (800956c <cblas_ssymm+0x2c8>)
 80093a0:	4971      	ldr	r1, [pc, #452]	; (8009568 <cblas_ssymm+0x2c4>)
 80093a2:	2000      	movs	r0, #0
#define BASE float
#include "source_symm_r.h"
#undef BASE
}
 80093a4:	b00d      	add	sp, #52	; 0x34
 80093a6:	ecbd 8b02 	vpop	{d8}
 80093aa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80093ae:	f01f b9ab 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80093b2:	2f65      	cmp	r7, #101	; 0x65
 80093b4:	f000 80a4 	beq.w	8009500 <cblas_ssymm+0x25c>
 80093b8:	2f66      	cmp	r7, #102	; 0x66
 80093ba:	f000 80b9 	beq.w	8009530 <cblas_ssymm+0x28c>
 80093be:	2800      	cmp	r0, #0
 80093c0:	d0ad      	beq.n	800931e <cblas_ssymm+0x7a>
 80093c2:	e7a8      	b.n	8009316 <cblas_ssymm+0x72>
        C[i * ldc + j] += alpha * temp2;
 80093c4:	eee8 7a25 	vfma.f32	s15, s16, s11
      for (j = 0; j < n2; j++) {
 80093c8:	4576      	cmp	r6, lr
        C[i * ldc + j] += alpha * temp2;
 80093ca:	ed47 7a01 	vstr	s15, [r7, #-4]
      for (j = 0; j < n2; j++) {
 80093ce:	f300 81cb 	bgt.w	8009768 <cblas_ssymm+0x4c4>
 80093d2:	b00d      	add	sp, #52	; 0x34
 80093d4:	ecbd 8b02 	vpop	{d8}
 80093d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 80093dc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80093e0:	eef4 8a67 	vcmp.f32	s17, s15
 80093e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80093e8:	d0cf      	beq.n	800938a <cblas_ssymm+0xe6>
    for (i = 0; i < n1; i++) {
 80093ea:	f1bb 0f00 	cmp.w	fp, #0
 80093ee:	ddcc      	ble.n	800938a <cblas_ssymm+0xe6>
 80093f0:	9b02      	ldr	r3, [sp, #8]
 80093f2:	009f      	lsls	r7, r3, #2
 80093f4:	9b04      	ldr	r3, [sp, #16]
 80093f6:	ebc6 7186 	rsb	r1, r6, r6, lsl #30
 80093fa:	0089      	lsls	r1, r1, #2
 80093fc:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 8009400:	2200      	movs	r2, #0
      for (j = 0; j < n2; j++) {
 8009402:	2e00      	cmp	r6, #0
 8009404:	bfc8      	it	gt
 8009406:	1843      	addgt	r3, r0, r1
 8009408:	dd07      	ble.n	800941a <cblas_ssymm+0x176>
        C[ldc * i + j] *= beta;
 800940a:	edd3 7a00 	vldr	s15, [r3]
 800940e:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8009412:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j < n2; j++) {
 8009416:	4283      	cmp	r3, r0
 8009418:	d1f7      	bne.n	800940a <cblas_ssymm+0x166>
    for (i = 0; i < n1; i++) {
 800941a:	3201      	adds	r2, #1
 800941c:	4593      	cmp	fp, r2
 800941e:	4438      	add	r0, r7
 8009420:	d1ef      	bne.n	8009402 <cblas_ssymm+0x15e>
 8009422:	e7b2      	b.n	800938a <cblas_ssymm+0xe6>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8009424:	4598      	cmp	r8, r3
 8009426:	f6ff af6f 	blt.w	8009308 <cblas_ssymm+0x64>
 800942a:	2f65      	cmp	r7, #101	; 0x65
 800942c:	d075      	beq.n	800951a <cblas_ssymm+0x276>
 800942e:	2f66      	cmp	r7, #102	; 0x66
 8009430:	f000 8242 	beq.w	80098b8 <cblas_ssymm+0x614>
 8009434:	2005      	movs	r0, #5
 8009436:	e76e      	b.n	8009316 <cblas_ssymm+0x72>
 8009438:	3865      	subs	r0, #101	; 0x65
 800943a:	2801      	cmp	r0, #1
 800943c:	bf94      	ite	ls
 800943e:	2000      	movls	r0, #0
 8009440:	2001      	movhi	r0, #1
 8009442:	4633      	mov	r3, r6
 8009444:	e74f      	b.n	80092e6 <cblas_ssymm+0x42>
    uplo = Uplo;
 8009446:	465b      	mov	r3, fp
    side = Side;
 8009448:	46b3      	mov	fp, r6
 800944a:	461e      	mov	r6, r3
 800944c:	e77e      	b.n	800934c <cblas_ssymm+0xa8>
  } else if (side == CblasRight && uplo == CblasUpper) {
 800944e:	2d79      	cmp	r5, #121	; 0x79
 8009450:	f000 81c8 	beq.w	80097e4 <cblas_ssymm+0x540>
  } else if (side == CblasRight && uplo == CblasLower) {
 8009454:	2d7a      	cmp	r5, #122	; 0x7a
 8009456:	d1a2      	bne.n	800939e <cblas_ssymm+0xfa>
    for (i = 0; i < n1; i++) {
 8009458:	f1bb 0f00 	cmp.w	fp, #0
 800945c:	ddb9      	ble.n	80093d2 <cblas_ssymm+0x12e>
 800945e:	9a02      	ldr	r2, [sp, #8]
 8009460:	f8dd a010 	ldr.w	sl, [sp, #16]
 8009464:	9805      	ldr	r0, [sp, #20]
 8009466:	0092      	lsls	r2, r2, #2
 8009468:	9202      	str	r2, [sp, #8]
 800946a:	9a03      	ldr	r2, [sp, #12]
 800946c:	0092      	lsls	r2, r2, #2
 800946e:	9203      	str	r2, [sp, #12]
 8009470:	9a01      	ldr	r2, [sp, #4]
 8009472:	f108 0301 	add.w	r3, r8, #1
 8009476:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 800947a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800947e:	9306      	str	r3, [sp, #24]
 8009480:	2300      	movs	r3, #0
 8009482:	e9cd 6b04 	strd	r6, fp, [sp, #16]
 8009486:	eb0a 0986 	add.w	r9, sl, r6, lsl #2
 800948a:	9301      	str	r3, [sp, #4]
 800948c:	4684      	mov	ip, r0
 800948e:	4693      	mov	fp, r2
      for (j = 0; j < n2; j++) {
 8009490:	9b04      	ldr	r3, [sp, #16]
 8009492:	2b00      	cmp	r3, #0
 8009494:	dd59      	ble.n	800954a <cblas_ssymm+0x2a6>
        const BASE temp1 = alpha * B[ldb * i + j];
 8009496:	4667      	mov	r7, ip
 8009498:	ecb7 6a01 	vldmia	r7!, {s12}
        BASE temp2 = 0.0;
 800949c:	eddf 6a34 	vldr	s13, [pc, #208]	; 8009570 <cblas_ssymm+0x2cc>
        const BASE temp1 = alpha * B[ldb * i + j];
 80094a0:	9806      	ldr	r0, [sp, #24]
 80094a2:	ee28 6a06 	vmul.f32	s12, s16, s12
 80094a6:	4646      	mov	r6, r8
 80094a8:	465d      	mov	r5, fp
 80094aa:	4654      	mov	r4, sl
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
 80094ac:	ed95 7a00 	vldr	s14, [r5]
 80094b0:	edd4 7a00 	vldr	s15, [r4]
 80094b4:	ee68 6a26 	vmul.f32	s13, s16, s13
 80094b8:	eee7 6a06 	vfma.f32	s13, s14, s12
 80094bc:	ee77 6aa6 	vadd.f32	s13, s15, s13
 80094c0:	ece4 6a01 	vstmia	r4!, {s13}
      for (j = 0; j < n2; j++) {
 80094c4:	454c      	cmp	r4, r9
 80094c6:	d040      	beq.n	800954a <cblas_ssymm+0x2a6>
        const BASE temp1 = alpha * B[ldb * i + j];
 80094c8:	ecb7 6a01 	vldmia	r7!, {s12}
        BASE temp2 = 0.0;
 80094cc:	eddf 6a28 	vldr	s13, [pc, #160]	; 8009570 <cblas_ssymm+0x2cc>
        const BASE temp1 = alpha * B[ldb * i + j];
 80094d0:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = 0; k < j; k++) {
 80094d4:	eb0b 0286 	add.w	r2, fp, r6, lsl #2
        const BASE temp1 = alpha * B[ldb * i + j];
 80094d8:	4661      	mov	r1, ip
 80094da:	4653      	mov	r3, sl
          const BASE Ajk = A[j * lda + k];
 80094dc:	ecb2 7a01 	vldmia	r2!, {s14}
          C[i * ldc + k] += temp1 * Ajk;
 80094e0:	edd3 7a00 	vldr	s15, [r3]
 80094e4:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = 0; k < j; k++) {
 80094e8:	4282      	cmp	r2, r0
          C[i * ldc + k] += temp1 * Ajk;
 80094ea:	ece3 7a01 	vstmia	r3!, {s15}
          temp2 += B[ldb * i + k] * Ajk;
 80094ee:	ecf1 7a01 	vldmia	r1!, {s15}
 80094f2:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = 0; k < j; k++) {
 80094f6:	d1f1      	bne.n	80094dc <cblas_ssymm+0x238>
 80094f8:	4475      	add	r5, lr
 80094fa:	4446      	add	r6, r8
 80094fc:	4470      	add	r0, lr
 80094fe:	e7d5      	b.n	80094ac <cblas_ssymm+0x208>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8009500:	465b      	mov	r3, fp
 8009502:	2b01      	cmp	r3, #1
 8009504:	9a03      	ldr	r2, [sp, #12]
 8009506:	bfb8      	it	lt
 8009508:	2301      	movlt	r3, #1
 800950a:	4293      	cmp	r3, r2
 800950c:	dc0a      	bgt.n	8009524 <cblas_ssymm+0x280>
 800950e:	9a02      	ldr	r2, [sp, #8]
 8009510:	4293      	cmp	r3, r2
 8009512:	f77f af54 	ble.w	80093be <cblas_ssymm+0x11a>
 8009516:	200d      	movs	r0, #13
 8009518:	e6fd      	b.n	8009316 <cblas_ssymm+0x72>
 800951a:	9b03      	ldr	r3, [sp, #12]
 800951c:	2b00      	cmp	r3, #0
 800951e:	f300 815b 	bgt.w	80097d8 <cblas_ssymm+0x534>
 8009522:	2301      	movs	r3, #1
 8009524:	9a02      	ldr	r2, [sp, #8]
 8009526:	429a      	cmp	r2, r3
 8009528:	bfb4      	ite	lt
 800952a:	200d      	movlt	r0, #13
 800952c:	200a      	movge	r0, #10
 800952e:	e6f2      	b.n	8009316 <cblas_ssymm+0x72>
 8009530:	2e01      	cmp	r6, #1
 8009532:	9a03      	ldr	r2, [sp, #12]
 8009534:	4633      	mov	r3, r6
 8009536:	bfb8      	it	lt
 8009538:	2301      	movlt	r3, #1
 800953a:	4293      	cmp	r3, r2
 800953c:	dde7      	ble.n	800950e <cblas_ssymm+0x26a>
 800953e:	9a02      	ldr	r2, [sp, #8]
 8009540:	4293      	cmp	r3, r2
 8009542:	bfcc      	ite	gt
 8009544:	200d      	movgt	r0, #13
 8009546:	200a      	movle	r0, #10
 8009548:	e6e5      	b.n	8009316 <cblas_ssymm+0x72>
    for (i = 0; i < n1; i++) {
 800954a:	9a02      	ldr	r2, [sp, #8]
 800954c:	9b01      	ldr	r3, [sp, #4]
 800954e:	9903      	ldr	r1, [sp, #12]
 8009550:	4492      	add	sl, r2
 8009552:	4491      	add	r9, r2
 8009554:	9a05      	ldr	r2, [sp, #20]
 8009556:	3301      	adds	r3, #1
 8009558:	429a      	cmp	r2, r3
 800955a:	9301      	str	r3, [sp, #4]
 800955c:	448c      	add	ip, r1
 800955e:	d197      	bne.n	8009490 <cblas_ssymm+0x1ec>
 8009560:	e737      	b.n	80093d2 <cblas_ssymm+0x12e>
 8009562:	bf00      	nop
 8009564:	08031108 	.word	0x08031108
 8009568:	0803121c 	.word	0x0803121c
 800956c:	080311b8 	.word	0x080311b8
 8009570:	00000000 	.word	0x00000000
  if (side == CblasLeft && uplo == CblasUpper) {
 8009574:	2d79      	cmp	r5, #121	; 0x79
 8009576:	f000 808f 	beq.w	8009698 <cblas_ssymm+0x3f4>
  } else if (side == CblasLeft && uplo == CblasLower) {
 800957a:	2d7a      	cmp	r5, #122	; 0x7a
 800957c:	f47f af0f 	bne.w	800939e <cblas_ssymm+0xfa>
    for (i = 0; i < n1; i++) {
 8009580:	f1bb 0f00 	cmp.w	fp, #0
 8009584:	f77f af25 	ble.w	80093d2 <cblas_ssymm+0x12e>
 8009588:	2300      	movs	r3, #0
 800958a:	f108 0801 	add.w	r8, r8, #1
 800958e:	ea4f 0288 	mov.w	r2, r8, lsl #2
 8009592:	9801      	ldr	r0, [sp, #4]
 8009594:	9306      	str	r3, [sp, #24]
 8009596:	9301      	str	r3, [sp, #4]
 8009598:	4698      	mov	r8, r3
 800959a:	9b03      	ldr	r3, [sp, #12]
 800959c:	9208      	str	r2, [sp, #32]
 800959e:	3a04      	subs	r2, #4
 80095a0:	9207      	str	r2, [sp, #28]
 80095a2:	009c      	lsls	r4, r3, #2
 80095a4:	9a02      	ldr	r2, [sp, #8]
 80095a6:	9b05      	ldr	r3, [sp, #20]
 80095a8:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 80095ac:	f8dd b010 	ldr.w	fp, [sp, #16]
 80095b0:	9605      	str	r6, [sp, #20]
 80095b2:	4682      	mov	sl, r0
 80095b4:	eb03 0986 	add.w	r9, r3, r6, lsl #2
 80095b8:	0095      	lsls	r5, r2, #2
 80095ba:	469e      	mov	lr, r3
      for (j = 0; j < n2; j++) {
 80095bc:	9b05      	ldr	r3, [sp, #20]
 80095be:	2b00      	cmp	r3, #0
 80095c0:	dd34      	ble.n	800962c <cblas_ssymm+0x388>
 80095c2:	9b01      	ldr	r3, [sp, #4]
 80095c4:	eb0e 0c83 	add.w	ip, lr, r3, lsl #2
 80095c8:	9b06      	ldr	r3, [sp, #24]
 80095ca:	2600      	movs	r6, #0
 80095cc:	eb0b 0783 	add.w	r7, fp, r3, lsl #2
        const BASE temp1 = alpha * B[ldb * i + j];
 80095d0:	ecbc 6a01 	vldmia	ip!, {s12}
        BASE temp2 = 0.0;
 80095d4:	ed5f 6a1a 	vldr	s13, [pc, #-104]	; 8009570 <cblas_ssymm+0x2cc>
        const BASE temp1 = alpha * B[ldb * i + j];
 80095d8:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = 0; k < i; k++) {
 80095dc:	f1b8 0f00 	cmp.w	r8, #0
 80095e0:	d014      	beq.n	800960c <cblas_ssymm+0x368>
 80095e2:	eb0b 0386 	add.w	r3, fp, r6, lsl #2
 80095e6:	eb0e 0186 	add.w	r1, lr, r6, lsl #2
 80095ea:	4652      	mov	r2, sl
          const BASE Aik = A[i * lda + k];
 80095ec:	ecb2 7a01 	vldmia	r2!, {s14}
          C[k * ldc + j] += Aik * temp1;
 80095f0:	edd3 7a00 	vldr	s15, [r3]
 80095f4:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = 0; k < i; k++) {
 80095f8:	4290      	cmp	r0, r2
          C[k * ldc + j] += Aik * temp1;
 80095fa:	edc3 7a00 	vstr	s15, [r3]
          temp2 += Aik * B[ldb * k + j];
 80095fe:	edd1 7a00 	vldr	s15, [r1]
 8009602:	442b      	add	r3, r5
 8009604:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = 0; k < i; k++) {
 8009608:	4421      	add	r1, r4
 800960a:	d1ef      	bne.n	80095ec <cblas_ssymm+0x348>
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800960c:	ed90 7a00 	vldr	s14, [r0]
 8009610:	edd7 7a00 	vldr	s15, [r7]
 8009614:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (j = 0; j < n2; j++) {
 8009618:	45e1      	cmp	r9, ip
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800961a:	eee7 6a06 	vfma.f32	s13, s14, s12
      for (j = 0; j < n2; j++) {
 800961e:	f106 0601 	add.w	r6, r6, #1
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 8009622:	ee77 6aa6 	vadd.f32	s13, s15, s13
 8009626:	ece7 6a01 	vstmia	r7!, {s13}
      for (j = 0; j < n2; j++) {
 800962a:	d1d1      	bne.n	80095d0 <cblas_ssymm+0x32c>
    for (i = 0; i < n1; i++) {
 800962c:	9b06      	ldr	r3, [sp, #24]
 800962e:	9a02      	ldr	r2, [sp, #8]
 8009630:	4413      	add	r3, r2
 8009632:	9306      	str	r3, [sp, #24]
 8009634:	9b08      	ldr	r3, [sp, #32]
 8009636:	9a03      	ldr	r2, [sp, #12]
 8009638:	4418      	add	r0, r3
 800963a:	9b01      	ldr	r3, [sp, #4]
 800963c:	4413      	add	r3, r2
 800963e:	9301      	str	r3, [sp, #4]
 8009640:	9b07      	ldr	r3, [sp, #28]
 8009642:	449a      	add	sl, r3
 8009644:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009646:	f108 0801 	add.w	r8, r8, #1
 800964a:	4543      	cmp	r3, r8
 800964c:	44a1      	add	r9, r4
 800964e:	d1b5      	bne.n	80095bc <cblas_ssymm+0x318>
 8009650:	e6bf      	b.n	80093d2 <cblas_ssymm+0x12e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8009652:	465b      	mov	r3, fp
 8009654:	2b01      	cmp	r3, #1
 8009656:	9a03      	ldr	r2, [sp, #12]
 8009658:	bfb8      	it	lt
 800965a:	2301      	movlt	r3, #1
 800965c:	4293      	cmp	r3, r2
 800965e:	f73f af61 	bgt.w	8009524 <cblas_ssymm+0x280>
 8009662:	9a02      	ldr	r2, [sp, #8]
 8009664:	4293      	cmp	r3, r2
 8009666:	bfcc      	ite	gt
 8009668:	200d      	movgt	r0, #13
 800966a:	2008      	movle	r0, #8
 800966c:	e653      	b.n	8009316 <cblas_ssymm+0x72>
 800966e:	2e01      	cmp	r6, #1
 8009670:	9a03      	ldr	r2, [sp, #12]
 8009672:	4633      	mov	r3, r6
 8009674:	bfb8      	it	lt
 8009676:	2301      	movlt	r3, #1
 8009678:	429a      	cmp	r2, r3
 800967a:	f6ff af60 	blt.w	800953e <cblas_ssymm+0x29a>
 800967e:	9a02      	ldr	r2, [sp, #8]
 8009680:	429a      	cmp	r2, r3
 8009682:	bfac      	ite	ge
 8009684:	2008      	movge	r0, #8
 8009686:	200d      	movlt	r0, #13
 8009688:	e645      	b.n	8009316 <cblas_ssymm+0x72>
 800968a:	3865      	subs	r0, #101	; 0x65
 800968c:	2801      	cmp	r0, #1
 800968e:	bf94      	ite	ls
 8009690:	2000      	movls	r0, #0
 8009692:	2001      	movhi	r0, #1
 8009694:	465b      	mov	r3, fp
 8009696:	e626      	b.n	80092e6 <cblas_ssymm+0x42>
    for (i = 0; i < n1; i++) {
 8009698:	f1bb 0f00 	cmp.w	fp, #0
 800969c:	f77f ae99 	ble.w	80093d2 <cblas_ssymm+0x12e>
 80096a0:	f108 0801 	add.w	r8, r8, #1
 80096a4:	ea4f 0388 	mov.w	r3, r8, lsl #2
 80096a8:	930b      	str	r3, [sp, #44]	; 0x2c
 80096aa:	3b04      	subs	r3, #4
 80096ac:	930a      	str	r3, [sp, #40]	; 0x28
 80096ae:	9b01      	ldr	r3, [sp, #4]
        C[i * ldc + j] += alpha * temp2;
 80096b0:	ed5f 5a51 	vldr	s11, [pc, #-324]	; 8009570 <cblas_ssymm+0x2cc>
    for (i = 0; i < n1; i++) {
 80096b4:	2200      	movs	r2, #0
 80096b6:	f103 0804 	add.w	r8, r3, #4
 80096ba:	eb03 008b 	add.w	r0, r3, fp, lsl #2
 80096be:	9b02      	ldr	r3, [sp, #8]
 80096c0:	9206      	str	r2, [sp, #24]
 80096c2:	9208      	str	r2, [sp, #32]
 80096c4:	9a03      	ldr	r2, [sp, #12]
 80096c6:	9309      	str	r3, [sp, #36]	; 0x24
 80096c8:	009d      	lsls	r5, r3, #2
 80096ca:	2301      	movs	r3, #1
 80096cc:	0094      	lsls	r4, r2, #2
 80096ce:	9207      	str	r2, [sp, #28]
 80096d0:	9301      	str	r3, [sp, #4]
      for (j = 0; j < n2; j++) {
 80096d2:	2e00      	cmp	r6, #0
 80096d4:	dd63      	ble.n	800979e <cblas_ssymm+0x4fa>
 80096d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80096d8:	9a07      	ldr	r2, [sp, #28]
 80096da:	4619      	mov	r1, r3
 80096dc:	9b08      	ldr	r3, [sp, #32]
 80096de:	4617      	mov	r7, r2
 80096e0:	eba1 0a03 	sub.w	sl, r1, r3
 80096e4:	9a06      	ldr	r2, [sp, #24]
 80096e6:	9905      	ldr	r1, [sp, #20]
 80096e8:	eba7 0902 	sub.w	r9, r7, r2
 80096ec:	eb01 0c82 	add.w	ip, r1, r2, lsl #2
 80096f0:	9a04      	ldr	r2, [sp, #16]
 80096f2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 80096f6:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80096fa:	f1aa 0a04 	sub.w	sl, sl, #4
 80096fe:	f1a9 0904 	sub.w	r9, r9, #4
 8009702:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 8009706:	f04f 0e01 	mov.w	lr, #1
        const BASE temp1 = alpha * B[ldb * i + j];
 800970a:	ecbc 6a01 	vldmia	ip!, {s12}
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800970e:	edd7 7a00 	vldr	s15, [r7]
 8009712:	ed18 7a01 	vldr	s14, [r8, #-4]
        for (k = i + 1; k < n1; k++) {
 8009716:	9b01      	ldr	r3, [sp, #4]
        const BASE temp1 = alpha * B[ldb * i + j];
 8009718:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = i + 1; k < n1; k++) {
 800971c:	459b      	cmp	fp, r3
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800971e:	eee7 7a06 	vfma.f32	s15, s14, s12
 8009722:	ece7 7a01 	vstmia	r7!, {s15}
        for (k = i + 1; k < n1; k++) {
 8009726:	f77f ae4d 	ble.w	80093c4 <cblas_ssymm+0x120>
        BASE temp2 = 0.0;
 800972a:	ed5f 6a6f 	vldr	s13, [pc, #-444]	; 8009570 <cblas_ssymm+0x2cc>
 800972e:	eb0a 0307 	add.w	r3, sl, r7
 8009732:	eb09 010c 	add.w	r1, r9, ip
        for (k = i + 1; k < n1; k++) {
 8009736:	4642      	mov	r2, r8
          const BASE Aik = A[i * lda + k];
 8009738:	ecb2 7a01 	vldmia	r2!, {s14}
          C[k * ldc + j] += Aik * temp1;
 800973c:	edd3 7a00 	vldr	s15, [r3]
 8009740:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = i + 1; k < n1; k++) {
 8009744:	4290      	cmp	r0, r2
          C[k * ldc + j] += Aik * temp1;
 8009746:	edc3 7a00 	vstr	s15, [r3]
          temp2 += Aik * B[ldb * k + j];
 800974a:	edd1 7a00 	vldr	s15, [r1]
 800974e:	442b      	add	r3, r5
 8009750:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = i + 1; k < n1; k++) {
 8009754:	4421      	add	r1, r4
 8009756:	d1ef      	bne.n	8009738 <cblas_ssymm+0x494>
        C[i * ldc + j] += alpha * temp2;
 8009758:	ed57 7a01 	vldr	s15, [r7, #-4]
 800975c:	eee8 7a26 	vfma.f32	s15, s16, s13
      for (j = 0; j < n2; j++) {
 8009760:	4576      	cmp	r6, lr
        C[i * ldc + j] += alpha * temp2;
 8009762:	ed47 7a01 	vstr	s15, [r7, #-4]
      for (j = 0; j < n2; j++) {
 8009766:	dd02      	ble.n	800976e <cblas_ssymm+0x4ca>
 8009768:	f10e 0e01 	add.w	lr, lr, #1
 800976c:	e7cd      	b.n	800970a <cblas_ssymm+0x466>
    for (i = 0; i < n1; i++) {
 800976e:	9b01      	ldr	r3, [sp, #4]
 8009770:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009772:	3301      	adds	r3, #1
 8009774:	9301      	str	r3, [sp, #4]
 8009776:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8009778:	4498      	add	r8, r3
 800977a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800977c:	4611      	mov	r1, r2
 800977e:	4418      	add	r0, r3
 8009780:	9a08      	ldr	r2, [sp, #32]
 8009782:	9b02      	ldr	r3, [sp, #8]
 8009784:	441a      	add	r2, r3
 8009786:	9208      	str	r2, [sp, #32]
 8009788:	9a07      	ldr	r2, [sp, #28]
 800978a:	4419      	add	r1, r3
 800978c:	9109      	str	r1, [sp, #36]	; 0x24
 800978e:	9b03      	ldr	r3, [sp, #12]
 8009790:	4611      	mov	r1, r2
 8009792:	9a06      	ldr	r2, [sp, #24]
 8009794:	4419      	add	r1, r3
 8009796:	441a      	add	r2, r3
 8009798:	9107      	str	r1, [sp, #28]
 800979a:	9206      	str	r2, [sp, #24]
 800979c:	e799      	b.n	80096d2 <cblas_ssymm+0x42e>
 800979e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80097a0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80097a2:	f8dd c004 	ldr.w	ip, [sp, #4]
 80097a6:	4490      	add	r8, r2
 80097a8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80097aa:	460f      	mov	r7, r1
 80097ac:	4410      	add	r0, r2
 80097ae:	9908      	ldr	r1, [sp, #32]
 80097b0:	9a02      	ldr	r2, [sp, #8]
 80097b2:	4411      	add	r1, r2
 80097b4:	9108      	str	r1, [sp, #32]
 80097b6:	9907      	ldr	r1, [sp, #28]
 80097b8:	4417      	add	r7, r2
 80097ba:	9709      	str	r7, [sp, #36]	; 0x24
 80097bc:	9a03      	ldr	r2, [sp, #12]
 80097be:	460f      	mov	r7, r1
 80097c0:	9906      	ldr	r1, [sp, #24]
 80097c2:	4663      	mov	r3, ip
 80097c4:	4417      	add	r7, r2
 80097c6:	4411      	add	r1, r2
 80097c8:	3301      	adds	r3, #1
 80097ca:	45e3      	cmp	fp, ip
 80097cc:	9707      	str	r7, [sp, #28]
 80097ce:	9106      	str	r1, [sp, #24]
 80097d0:	9301      	str	r3, [sp, #4]
 80097d2:	f73f af7e 	bgt.w	80096d2 <cblas_ssymm+0x42e>
 80097d6:	e5fc      	b.n	80093d2 <cblas_ssymm+0x12e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80097d8:	9b02      	ldr	r3, [sp, #8]
 80097da:	2b00      	cmp	r3, #0
 80097dc:	bfcc      	ite	gt
 80097de:	2005      	movgt	r0, #5
 80097e0:	200d      	movle	r0, #13
 80097e2:	e598      	b.n	8009316 <cblas_ssymm+0x72>
    for (i = 0; i < n1; i++) {
 80097e4:	f1bb 0f00 	cmp.w	fp, #0
 80097e8:	f77f adf3 	ble.w	80093d2 <cblas_ssymm+0x12e>
 80097ec:	9b03      	ldr	r3, [sp, #12]
        C[i * ldc + j] += alpha * temp2;
 80097ee:	ed5f 5aa0 	vldr	s11, [pc, #-640]	; 8009570 <cblas_ssymm+0x2cc>
 80097f2:	009b      	lsls	r3, r3, #2
 80097f4:	9306      	str	r3, [sp, #24]
 80097f6:	00b3      	lsls	r3, r6, #2
 80097f8:	930a      	str	r3, [sp, #40]	; 0x28
 80097fa:	9b05      	ldr	r3, [sp, #20]
 80097fc:	eb03 0c86 	add.w	ip, r3, r6, lsl #2
 8009800:	9b01      	ldr	r3, [sp, #4]
 8009802:	f108 0e01 	add.w	lr, r8, #1
    for (i = 0; i < n1; i++) {
 8009806:	f04f 0a00 	mov.w	sl, #0
 800980a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 800980e:	e9cd 6b07 	strd	r6, fp, [sp, #28]
 8009812:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8009816:	ea4f 0888 	mov.w	r8, r8, lsl #2
 800981a:	46d1      	mov	r9, sl
 800981c:	9309      	str	r3, [sp, #36]	; 0x24
 800981e:	46d3      	mov	fp, sl
      for (j = 0; j < n2; j++) {
 8009820:	9b07      	ldr	r3, [sp, #28]
 8009822:	2b00      	cmp	r3, #0
 8009824:	dd3c      	ble.n	80098a0 <cblas_ssymm+0x5fc>
 8009826:	9b05      	ldr	r3, [sp, #20]
 8009828:	9809      	ldr	r0, [sp, #36]	; 0x24
 800982a:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 800982e:	9b04      	ldr	r3, [sp, #16]
 8009830:	eb03 048a 	add.w	r4, r3, sl, lsl #2
 8009834:	9b01      	ldr	r3, [sp, #4]
 8009836:	ea4f 078a 	mov.w	r7, sl, lsl #2
 800983a:	1d1e      	adds	r6, r3, #4
        const BASE temp1 = alpha * B[ldb * i + j];
 800983c:	ecb5 6a01 	vldmia	r5!, {s12}
        C[i * ldc + j] += temp1 * A[j * lda + j];
 8009840:	edd4 7a00 	vldr	s15, [r4]
 8009844:	ed16 7a01 	vldr	s14, [r6, #-4]
        const BASE temp1 = alpha * B[ldb * i + j];
 8009848:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = j + 1; k < n2; k++) {
 800984c:	45ac      	cmp	ip, r5
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800984e:	eee7 7a06 	vfma.f32	s15, s14, s12
 8009852:	ece4 7a01 	vstmia	r4!, {s15}
        for (k = j + 1; k < n2; k++) {
 8009856:	d01b      	beq.n	8009890 <cblas_ssymm+0x5ec>
        BASE temp2 = 0.0;
 8009858:	ed5f 6abb 	vldr	s13, [pc, #-748]	; 8009570 <cblas_ssymm+0x2cc>
        for (k = j + 1; k < n2; k++) {
 800985c:	4629      	mov	r1, r5
 800985e:	4622      	mov	r2, r4
 8009860:	4633      	mov	r3, r6
          const BASE Ajk = A[j * lda + k];
 8009862:	ecb3 7a01 	vldmia	r3!, {s14}
          C[i * ldc + k] += temp1 * Ajk;
 8009866:	edd2 7a00 	vldr	s15, [r2]
 800986a:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = j + 1; k < n2; k++) {
 800986e:	4283      	cmp	r3, r0
          C[i * ldc + k] += temp1 * Ajk;
 8009870:	ece2 7a01 	vstmia	r2!, {s15}
          temp2 += B[ldb * i + k] * Ajk;
 8009874:	ecf1 7a01 	vldmia	r1!, {s15}
 8009878:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = j + 1; k < n2; k++) {
 800987c:	d1f1      	bne.n	8009862 <cblas_ssymm+0x5be>
        C[i * ldc + j] += alpha * temp2;
 800987e:	ed54 7a01 	vldr	s15, [r4, #-4]
 8009882:	eee8 7a26 	vfma.f32	s15, s16, s13
 8009886:	4476      	add	r6, lr
 8009888:	4440      	add	r0, r8
 800988a:	ed44 7a01 	vstr	s15, [r4, #-4]
      for (j = 0; j < n2; j++) {
 800988e:	e7d5      	b.n	800983c <cblas_ssymm+0x598>
        C[i * ldc + j] += alpha * temp2;
 8009890:	eee8 7a25 	vfma.f32	s15, s16, s11
 8009894:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8009896:	9a04      	ldr	r2, [sp, #16]
 8009898:	443b      	add	r3, r7
 800989a:	4413      	add	r3, r2
 800989c:	ed43 7a01 	vstr	s15, [r3, #-4]
    for (i = 0; i < n1; i++) {
 80098a0:	9b03      	ldr	r3, [sp, #12]
 80098a2:	449b      	add	fp, r3
 80098a4:	9b02      	ldr	r3, [sp, #8]
 80098a6:	449a      	add	sl, r3
 80098a8:	9b06      	ldr	r3, [sp, #24]
 80098aa:	449c      	add	ip, r3
 80098ac:	9b08      	ldr	r3, [sp, #32]
 80098ae:	f109 0901 	add.w	r9, r9, #1
 80098b2:	454b      	cmp	r3, r9
 80098b4:	d1b4      	bne.n	8009820 <cblas_ssymm+0x57c>
 80098b6:	e58c      	b.n	80093d2 <cblas_ssymm+0x12e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80098b8:	2e01      	cmp	r6, #1
 80098ba:	9a03      	ldr	r2, [sp, #12]
 80098bc:	4633      	mov	r3, r6
 80098be:	bfb8      	it	lt
 80098c0:	2301      	movlt	r3, #1
 80098c2:	429a      	cmp	r2, r3
 80098c4:	f6ff ae3b 	blt.w	800953e <cblas_ssymm+0x29a>
 80098c8:	9a02      	ldr	r2, [sp, #8]
 80098ca:	429a      	cmp	r2, r3
 80098cc:	bfac      	ite	ge
 80098ce:	2005      	movge	r0, #5
 80098d0:	200d      	movlt	r0, #13
 80098d2:	e520      	b.n	8009316 <cblas_ssymm+0x72>

080098d4 <cblas_ssymv>:
void
cblas_ssymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const float alpha, const float *A, const int lda,
             const float *X, const int incX, const float beta, float *Y,
             const int incY)
{
 80098d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80098d8:	ed2d 8b02 	vpush	{d8}
 80098dc:	b089      	sub	sp, #36	; 0x24
 80098de:	461c      	mov	r4, r3
 80098e0:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
 80098e4:	4689      	mov	r9, r1
 */

{
  INDEX i, j;

  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 80098e6:	3979      	subs	r1, #121	; 0x79
 80098e8:	2901      	cmp	r1, #1
 80098ea:	e9dd a814 	ldrd	sl, r8, [sp, #80]	; 0x50
 80098ee:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80098f0:	9301      	str	r3, [sp, #4]
 80098f2:	4683      	mov	fp, r0
 80098f4:	4615      	mov	r5, r2
 80098f6:	eeb0 8a40 	vmov.f32	s16, s0
 80098fa:	eef0 8a60 	vmov.f32	s17, s1
 80098fe:	f240 8096 	bls.w	8009a2e <cblas_ssymv+0x15a>
 8009902:	2002      	movs	r0, #2
 8009904:	2d00      	cmp	r5, #0
 8009906:	f2c0 8086 	blt.w	8009a16 <cblas_ssymv+0x142>
 800990a:	2d01      	cmp	r5, #1
 800990c:	462b      	mov	r3, r5
 800990e:	bfb8      	it	lt
 8009910:	2301      	movlt	r3, #1
 8009912:	4553      	cmp	r3, sl
 8009914:	dd72      	ble.n	80099fc <cblas_ssymv+0x128>
 8009916:	2e00      	cmp	r6, #0
 8009918:	d178      	bne.n	8009a0c <cblas_ssymv+0x138>
 800991a:	2f00      	cmp	r7, #0
 800991c:	bf0c      	ite	eq
 800991e:	200b      	moveq	r0, #11
 8009920:	2008      	movne	r0, #8
 8009922:	4acf      	ldr	r2, [pc, #828]	; (8009c60 <cblas_ssymv+0x38c>)
 8009924:	49cf      	ldr	r1, [pc, #828]	; (8009c64 <cblas_ssymv+0x390>)
 8009926:	f01e feef 	bl	8028708 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 800992a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800992e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009932:	d141      	bne.n	80099b8 <cblas_ssymv+0xe4>
 8009934:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009938:	eef4 8a67 	vcmp.f32	s17, s15
 800993c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009940:	d035      	beq.n	80099ae <cblas_ssymv+0xda>
    return;

  /* form  y := beta*y */
  if (beta == 0.0) {
 8009942:	eef5 8a40 	vcmp.f32	s17, #0.0
 8009946:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800994a:	d141      	bne.n	80099d0 <cblas_ssymv+0xfc>
    INDEX iy = OFFSET(N, incY);
 800994c:	2f00      	cmp	r7, #0
 800994e:	f340 8102 	ble.w	8009b56 <cblas_ssymv+0x282>
 8009952:	2300      	movs	r3, #0
    for (i = 0; i < N; i++) {
 8009954:	2d00      	cmp	r5, #0
 8009956:	dd0a      	ble.n	800996e <cblas_ssymv+0x9a>
 8009958:	9a01      	ldr	r2, [sp, #4]
      Y[iy] = 0.0;
 800995a:	2000      	movs	r0, #0
 800995c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8009960:	00b9      	lsls	r1, r7, #2
    for (i = 0; i < N; i++) {
 8009962:	2200      	movs	r2, #0
 8009964:	3201      	adds	r2, #1
 8009966:	4295      	cmp	r5, r2
      Y[iy] = 0.0;
 8009968:	6018      	str	r0, [r3, #0]
    for (i = 0; i < N; i++) {
 800996a:	440b      	add	r3, r1
 800996c:	d1fa      	bne.n	8009964 <cblas_ssymv+0x90>
      Y[iy] *= beta;
      iy += incY;
    }
  }

  if (alpha == 0.0)
 800996e:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009976:	d01a      	beq.n	80099ae <cblas_ssymv+0xda>
    return;

  /* form  y := alpha*A*x + y */

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8009978:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 800997c:	f000 80e3 	beq.w	8009b46 <cblas_ssymv+0x272>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009980:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8009984:	d059      	beq.n	8009a3a <cblas_ssymv+0x166>
      Y[iy] += alpha * temp2;
      ix -= incX;
      iy -= incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8009986:	4ab8      	ldr	r2, [pc, #736]	; (8009c68 <cblas_ssymv+0x394>)
 8009988:	49b6      	ldr	r1, [pc, #728]	; (8009c64 <cblas_ssymv+0x390>)
 800998a:	2000      	movs	r0, #0
#define BASE float
#include "source_symv.h"
#undef BASE
}
 800998c:	b009      	add	sp, #36	; 0x24
 800998e:	ecbd 8b02 	vpop	{d8}
 8009992:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009996:	f01e beb7 	b.w	8028708 <cblas_xerbla>
 800999a:	9a06      	ldr	r2, [sp, #24]
      Y[iy] += alpha * temp2;
 800999c:	eee8 7a07 	vfma.f32	s15, s16, s14
 80099a0:	fb07 2303 	mla	r3, r7, r3, r2
 80099a4:	9a01      	ldr	r2, [sp, #4]
 80099a6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80099aa:	edc3 7a00 	vstr	s15, [r3]
 80099ae:	b009      	add	sp, #36	; 0x24
 80099b0:	ecbd 8b02 	vpop	{d8}
 80099b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (beta == 0.0) {
 80099b8:	eef5 8a40 	vcmp.f32	s17, #0.0
 80099bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80099c0:	d0c4      	beq.n	800994c <cblas_ssymv+0x78>
  } else if (beta != 1.0) {
 80099c2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80099c6:	eef4 8a67 	vcmp.f32	s17, s15
 80099ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80099ce:	d0d3      	beq.n	8009978 <cblas_ssymv+0xa4>
    INDEX iy = OFFSET(N, incY);
 80099d0:	2f00      	cmp	r7, #0
 80099d2:	f340 80b3 	ble.w	8009b3c <cblas_ssymv+0x268>
 80099d6:	2300      	movs	r3, #0
    for (i = 0; i < N; i++) {
 80099d8:	2d00      	cmp	r5, #0
 80099da:	ddc8      	ble.n	800996e <cblas_ssymv+0x9a>
 80099dc:	9a01      	ldr	r2, [sp, #4]
 80099de:	00b9      	lsls	r1, r7, #2
 80099e0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80099e4:	2200      	movs	r2, #0
      Y[iy] *= beta;
 80099e6:	edd3 7a00 	vldr	s15, [r3]
    for (i = 0; i < N; i++) {
 80099ea:	3201      	adds	r2, #1
      Y[iy] *= beta;
 80099ec:	ee67 7aa8 	vmul.f32	s15, s15, s17
    for (i = 0; i < N; i++) {
 80099f0:	4295      	cmp	r5, r2
      Y[iy] *= beta;
 80099f2:	edc3 7a00 	vstr	s15, [r3]
    for (i = 0; i < N; i++) {
 80099f6:	440b      	add	r3, r1
 80099f8:	d1f5      	bne.n	80099e6 <cblas_ssymv+0x112>
 80099fa:	e7b8      	b.n	800996e <cblas_ssymv+0x9a>
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 80099fc:	2e00      	cmp	r6, #0
 80099fe:	d08c      	beq.n	800991a <cblas_ssymv+0x46>
 8009a00:	2f00      	cmp	r7, #0
 8009a02:	f000 8135 	beq.w	8009c70 <cblas_ssymv+0x39c>
 8009a06:	2800      	cmp	r0, #0
 8009a08:	d08f      	beq.n	800992a <cblas_ssymv+0x56>
 8009a0a:	e78a      	b.n	8009922 <cblas_ssymv+0x4e>
 8009a0c:	2f00      	cmp	r7, #0
 8009a0e:	bf0c      	ite	eq
 8009a10:	200b      	moveq	r0, #11
 8009a12:	2006      	movne	r0, #6
 8009a14:	e785      	b.n	8009922 <cblas_ssymv+0x4e>
 8009a16:	f1ba 0f00 	cmp.w	sl, #0
 8009a1a:	f77f af7c 	ble.w	8009916 <cblas_ssymv+0x42>
 8009a1e:	2e00      	cmp	r6, #0
 8009a20:	f43f af7b 	beq.w	800991a <cblas_ssymv+0x46>
 8009a24:	2f00      	cmp	r7, #0
 8009a26:	bf0c      	ite	eq
 8009a28:	200b      	moveq	r0, #11
 8009a2a:	2003      	movne	r0, #3
 8009a2c:	e779      	b.n	8009922 <cblas_ssymv+0x4e>
 8009a2e:	3865      	subs	r0, #101	; 0x65
 8009a30:	2801      	cmp	r0, #1
 8009a32:	bf94      	ite	ls
 8009a34:	2000      	movls	r0, #0
 8009a36:	2001      	movhi	r0, #1
 8009a38:	e764      	b.n	8009904 <cblas_ssymv+0x30>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009a3a:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8009a3e:	f000 808f 	beq.w	8009b60 <cblas_ssymv+0x28c>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 8009a42:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8009a46:	d19e      	bne.n	8009986 <cblas_ssymv+0xb2>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8009a48:	2e00      	cmp	r6, #0
 8009a4a:	f105 32ff 	add.w	r2, r5, #4294967295
 8009a4e:	bfd6      	itet	le
 8009a50:	f1c6 0c00 	rsble	ip, r6, #0
 8009a54:	f04f 0c00 	movgt.w	ip, #0
 8009a58:	fb02 fc0c 	mulle.w	ip, r2, ip
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8009a5c:	2f00      	cmp	r7, #0
 8009a5e:	bfda      	itte	le
 8009a60:	f1c7 0e00 	rsble	lr, r7, #0
 8009a64:	fb02 fe0e 	mulle.w	lr, r2, lr
 8009a68:	f04f 0e00 	movgt.w	lr, #0
 8009a6c:	fb02 e307 	mla	r3, r2, r7, lr
    for (i = N; i > 0 && i--;) {
 8009a70:	2d00      	cmp	r5, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8009a72:	fb02 c106 	mla	r1, r2, r6, ip
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8009a76:	9304      	str	r3, [sp, #16]
    for (i = N; i > 0 && i--;) {
 8009a78:	dd99      	ble.n	80099ae <cblas_ssymv+0xda>
 8009a7a:	fb02 f00a 	mul.w	r0, r2, sl
 8009a7e:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 8009a82:	1813      	adds	r3, r2, r0
 8009a84:	ebc7 7b87 	rsb	fp, r7, r7, lsl #30
 8009a88:	ea6f 090a 	mvn.w	r9, sl
 8009a8c:	9105      	str	r1, [sp, #20]
 8009a8e:	ebca 7a8a 	rsb	sl, sl, sl, lsl #30
 8009a92:	9901      	ldr	r1, [sp, #4]
 8009a94:	9206      	str	r2, [sp, #24]
 8009a96:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8009a9a:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8009a9e:	ea4f 048b 	mov.w	r4, fp, lsl #2
 8009aa2:	9403      	str	r4, [sp, #12]
 8009aa4:	ea4f 048a 	mov.w	r4, sl, lsl #2
 8009aa8:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
 8009aac:	9407      	str	r4, [sp, #28]
 8009aae:	9901      	ldr	r1, [sp, #4]
 8009ab0:	9c04      	ldr	r4, [sp, #16]
 8009ab2:	f8cd e008 	str.w	lr, [sp, #8]
 8009ab6:	ebc6 7586 	rsb	r5, r6, r6, lsl #30
 8009aba:	f8dd e01c 	ldr.w	lr, [sp, #28]
 8009abe:	ea4f 0b89 	mov.w	fp, r9, lsl #2
 8009ac2:	eb01 0a84 	add.w	sl, r1, r4, lsl #2
 8009ac6:	eb08 088c 	add.w	r8, r8, ip, lsl #2
 8009aca:	9905      	ldr	r1, [sp, #20]
 8009acc:	9705      	str	r7, [sp, #20]
 8009ace:	00ad      	lsls	r5, r5, #2
 8009ad0:	00b6      	lsls	r6, r6, #2
 8009ad2:	ea4f 0987 	mov.w	r9, r7, lsl #2
      BASE temp1 = alpha * X[ix];
 8009ad6:	ed91 6a00 	vldr	s12, [r1]
      Y[iy] += temp1 * A[lda * i + i];
 8009ada:	ed93 7a00 	vldr	s14, [r3]
 8009ade:	edda 7a00 	vldr	s15, [sl]
      BASE temp1 = alpha * X[ix];
 8009ae2:	ee28 6a06 	vmul.f32	s12, s16, s12
      Y[iy] += temp1 * A[lda * i + i];
 8009ae6:	eee7 7a06 	vfma.f32	s15, s14, s12
 8009aea:	edca 7a00 	vstr	s15, [sl]
      for (j = j_min; j < j_max; j++) {
 8009aee:	2a00      	cmp	r2, #0
 8009af0:	f000 80a2 	beq.w	8009c38 <cblas_ssymv+0x364>
      BASE temp2 = 0.0;
 8009af4:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 8009c6c <cblas_ssymv+0x398>
      for (j = j_min; j < j_max; j++) {
 8009af8:	9c02      	ldr	r4, [sp, #8]
 8009afa:	46c4      	mov	ip, r8
 8009afc:	4607      	mov	r7, r0
        Y[jy] += temp1 * A[lda * i + j];
 8009afe:	edd7 6a00 	vldr	s13, [r7]
 8009b02:	edd4 7a00 	vldr	s15, [r4]
 8009b06:	eee6 7a86 	vfma.f32	s15, s13, s12
 8009b0a:	edc4 7a00 	vstr	s15, [r4]
        temp2 += X[jx] * A[lda * i + j];
 8009b0e:	ecf7 7a01 	vldmia	r7!, {s15}
 8009b12:	eddc 6a00 	vldr	s13, [ip]
      for (j = j_min; j < j_max; j++) {
 8009b16:	429f      	cmp	r7, r3
        temp2 += X[jx] * A[lda * i + j];
 8009b18:	eea6 7aa7 	vfma.f32	s14, s13, s15
      for (j = j_min; j < j_max; j++) {
 8009b1c:	444c      	add	r4, r9
 8009b1e:	44b4      	add	ip, r6
 8009b20:	d1ed      	bne.n	8009afe <cblas_ssymv+0x22a>
      Y[iy] += alpha * temp2;
 8009b22:	edda 7a00 	vldr	s15, [sl]
 8009b26:	9c03      	ldr	r4, [sp, #12]
 8009b28:	eee8 7a07 	vfma.f32	s15, s16, s14
 8009b2c:	4429      	add	r1, r5
 8009b2e:	445b      	add	r3, fp
 8009b30:	4470      	add	r0, lr
 8009b32:	edca 7a00 	vstr	s15, [sl]
    for (i = N; i > 0 && i--;) {
 8009b36:	3a01      	subs	r2, #1
 8009b38:	44a2      	add	sl, r4
 8009b3a:	e7cc      	b.n	8009ad6 <cblas_ssymv+0x202>
    INDEX iy = OFFSET(N, incY);
 8009b3c:	f1c5 0301 	rsb	r3, r5, #1
 8009b40:	fb03 f307 	mul.w	r3, r3, r7
 8009b44:	e748      	b.n	80099d8 <cblas_ssymv+0x104>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8009b46:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8009b4a:	d009      	beq.n	8009b60 <cblas_ssymv+0x28c>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8009b4c:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8009b50:	f47f af19 	bne.w	8009986 <cblas_ssymv+0xb2>
 8009b54:	e778      	b.n	8009a48 <cblas_ssymv+0x174>
    INDEX iy = OFFSET(N, incY);
 8009b56:	f1c5 0301 	rsb	r3, r5, #1
 8009b5a:	fb03 f307 	mul.w	r3, r3, r7
 8009b5e:	e6f9      	b.n	8009954 <cblas_ssymv+0x80>
    INDEX ix = OFFSET(N, incX);
 8009b60:	2e00      	cmp	r6, #0
 8009b62:	bfda      	itte	le
 8009b64:	f1c5 0901 	rsble	r9, r5, #1
 8009b68:	fb09 f906 	mulle.w	r9, r9, r6
 8009b6c:	f04f 0900 	movgt.w	r9, #0
    INDEX iy = OFFSET(N, incY);
 8009b70:	2f00      	cmp	r7, #0
 8009b72:	bfda      	itte	le
 8009b74:	f1c5 0301 	rsble	r3, r5, #1
 8009b78:	437b      	mulle	r3, r7
 8009b7a:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8009b7c:	2d00      	cmp	r5, #0
    INDEX iy = OFFSET(N, incY);
 8009b7e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 8009b80:	f77f af15 	ble.w	80099ae <cblas_ssymv+0xda>
 8009b84:	ebc6 7386 	rsb	r3, r6, r6, lsl #30
 8009b88:	009b      	lsls	r3, r3, #2
 8009b8a:	f10a 0a01 	add.w	sl, sl, #1
 8009b8e:	9302      	str	r3, [sp, #8]
 8009b90:	9b06      	ldr	r3, [sp, #24]
 8009b92:	9801      	ldr	r0, [sp, #4]
 8009b94:	9605      	str	r6, [sp, #20]
 8009b96:	ea4f 028a 	mov.w	r2, sl, lsl #2
 8009b9a:	19d9      	adds	r1, r3, r7
 8009b9c:	9204      	str	r2, [sp, #16]
 8009b9e:	3a04      	subs	r2, #4
 8009ba0:	9203      	str	r2, [sp, #12]
 8009ba2:	eb00 0e83 	add.w	lr, r0, r3, lsl #2
 8009ba6:	f104 0a04 	add.w	sl, r4, #4
 8009baa:	44b1      	add	r9, r6
 8009bac:	00ba      	lsls	r2, r7, #2
 8009bae:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 8009bb2:	ea4f 0c86 	mov.w	ip, r6, lsl #2
 8009bb6:	2300      	movs	r3, #0
 8009bb8:	468b      	mov	fp, r1
      BASE temp1 = alpha * X[ix];
 8009bba:	9902      	ldr	r1, [sp, #8]
      Y[iy] += temp1 * A[lda * i + i];
 8009bbc:	ed1a 7a01 	vldr	s14, [sl, #-4]
 8009bc0:	edde 7a00 	vldr	s15, [lr]
      BASE temp1 = alpha * X[ix];
 8009bc4:	eb01 0189 	add.w	r1, r1, r9, lsl #2
 8009bc8:	4441      	add	r1, r8
 8009bca:	ed91 6a00 	vldr	s12, [r1]
 8009bce:	ee28 6a06 	vmul.f32	s12, s16, s12
      const INDEX j_min = i + 1;
 8009bd2:	1c5e      	adds	r6, r3, #1
      Y[iy] += temp1 * A[lda * i + i];
 8009bd4:	eee7 7a06 	vfma.f32	s15, s14, s12
      for (j = j_min; j < j_max; j++) {
 8009bd8:	42b5      	cmp	r5, r6
 8009bda:	ea4f 0089 	mov.w	r0, r9, lsl #2
      BASE temp2 = 0.0;
 8009bde:	ed9f 7a23 	vldr	s14, [pc, #140]	; 8009c6c <cblas_ssymv+0x398>
      Y[iy] += temp1 * A[lda * i + i];
 8009be2:	edce 7a00 	vstr	s15, [lr]
      for (j = j_min; j < j_max; j++) {
 8009be6:	f43f aed8 	beq.w	800999a <cblas_ssymv+0xc6>
 8009bea:	9b01      	ldr	r3, [sp, #4]
 8009bec:	4440      	add	r0, r8
 8009bee:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 8009bf2:	4653      	mov	r3, sl
        Y[jy] += temp1 * A[lda * i + j];
 8009bf4:	edd3 6a00 	vldr	s13, [r3]
 8009bf8:	edd1 7a00 	vldr	s15, [r1]
 8009bfc:	eee6 7a86 	vfma.f32	s15, s13, s12
 8009c00:	edc1 7a00 	vstr	s15, [r1]
        temp2 += X[jx] * A[lda * i + j];
 8009c04:	ecf3 7a01 	vldmia	r3!, {s15}
 8009c08:	edd0 6a00 	vldr	s13, [r0]
      for (j = j_min; j < j_max; j++) {
 8009c0c:	429c      	cmp	r4, r3
        temp2 += X[jx] * A[lda * i + j];
 8009c0e:	eea6 7aa7 	vfma.f32	s14, s13, s15
      for (j = j_min; j < j_max; j++) {
 8009c12:	4411      	add	r1, r2
 8009c14:	4460      	add	r0, ip
 8009c16:	d1ed      	bne.n	8009bf4 <cblas_ssymv+0x320>
      Y[iy] += alpha * temp2;
 8009c18:	edde 7a00 	vldr	s15, [lr]
 8009c1c:	9b05      	ldr	r3, [sp, #20]
 8009c1e:	eee8 7a07 	vfma.f32	s15, s16, s14
 8009c22:	4499      	add	r9, r3
 8009c24:	9b04      	ldr	r3, [sp, #16]
 8009c26:	449a      	add	sl, r3
 8009c28:	9b03      	ldr	r3, [sp, #12]
 8009c2a:	edce 7a00 	vstr	s15, [lr]
    for (i = 0; i < N; i++) {
 8009c2e:	441c      	add	r4, r3
 8009c30:	44bb      	add	fp, r7
      Y[iy] += alpha * temp2;
 8009c32:	4633      	mov	r3, r6
 8009c34:	4496      	add	lr, r2
 8009c36:	e7c0      	b.n	8009bba <cblas_ssymv+0x2e6>
      Y[iy] += alpha * temp2;
 8009c38:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 8009c6c <cblas_ssymv+0x398>
 8009c3c:	9a04      	ldr	r2, [sp, #16]
 8009c3e:	9f05      	ldr	r7, [sp, #20]
 8009c40:	9b06      	ldr	r3, [sp, #24]
 8009c42:	eee8 7a07 	vfma.f32	s15, s16, s14
 8009c46:	fb07 2313 	mls	r3, r7, r3, r2
 8009c4a:	9a01      	ldr	r2, [sp, #4]
 8009c4c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8009c50:	edc3 7a00 	vstr	s15, [r3]
 8009c54:	b009      	add	sp, #36	; 0x24
 8009c56:	ecbd 8b02 	vpop	{d8}
 8009c5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009c5e:	bf00      	nop
 8009c60:	08031108 	.word	0x08031108
 8009c64:	0803122c 	.word	0x0803122c
 8009c68:	080311b8 	.word	0x080311b8
 8009c6c:	00000000 	.word	0x00000000
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8009c70:	200b      	movs	r0, #11
 8009c72:	e656      	b.n	8009922 <cblas_ssymv+0x4e>

08009c74 <cblas_ssyr>:

void
cblas_ssyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const float alpha, const float *X, const int incX,
            float *A, const int lda)
{
 8009c74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009c78:	ed2d 8b02 	vpush	{d8}
 8009c7c:	4689      	mov	r9, r1
 */

{
  INDEX i, j;

  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009c7e:	3979      	subs	r1, #121	; 0x79
 8009c80:	2901      	cmp	r1, #1
 8009c82:	e9dd 740c 	ldrd	r7, r4, [sp, #48]	; 0x30
 8009c86:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8009c8a:	4682      	mov	sl, r0
 8009c8c:	4615      	mov	r5, r2
 8009c8e:	461e      	mov	r6, r3
 8009c90:	eeb0 8a40 	vmov.f32	s16, s0
 8009c94:	d935      	bls.n	8009d02 <cblas_ssyr+0x8e>
 8009c96:	2a00      	cmp	r2, #0
 8009c98:	db22      	blt.n	8009ce0 <cblas_ssyr+0x6c>
 8009c9a:	2f00      	cmp	r7, #0
 8009c9c:	d142      	bne.n	8009d24 <cblas_ssyr+0xb0>
 8009c9e:	2d01      	cmp	r5, #1
 8009ca0:	4628      	mov	r0, r5
 8009ca2:	bfb8      	it	lt
 8009ca4:	2001      	movlt	r0, #1
 8009ca6:	4a5e      	ldr	r2, [pc, #376]	; (8009e20 <cblas_ssyr+0x1ac>)
 8009ca8:	495e      	ldr	r1, [pc, #376]	; (8009e24 <cblas_ssyr+0x1b0>)
 8009caa:	4580      	cmp	r8, r0
 8009cac:	bfb4      	ite	lt
 8009cae:	2008      	movlt	r0, #8
 8009cb0:	2006      	movge	r0, #6
 8009cb2:	f01e fd29 	bl	8028708 <cblas_xerbla>

  if (N == 0)
 8009cb6:	b305      	cbz	r5, 8009cfa <cblas_ssyr+0x86>
    return;

  if (alpha == 0.0)
 8009cb8:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009cbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009cc0:	d01b      	beq.n	8009cfa <cblas_ssyr+0x86>
    return;

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8009cc2:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8009cc6:	d070      	beq.n	8009daa <cblas_ssyr+0x136>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009cc8:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8009ccc:	d033      	beq.n	8009d36 <cblas_ssyr+0xc2>
#define BASE float
#include "source_syr.h"
#undef BASE
}
 8009cce:	ecbd 8b02 	vpop	{d8}
        jx += incX;
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8009cd2:	4a55      	ldr	r2, [pc, #340]	; (8009e28 <cblas_ssyr+0x1b4>)
 8009cd4:	4953      	ldr	r1, [pc, #332]	; (8009e24 <cblas_ssyr+0x1b0>)
 8009cd6:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009cda:	2000      	movs	r0, #0
 8009cdc:	f01e bd14 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009ce0:	2f00      	cmp	r7, #0
 8009ce2:	d0dc      	beq.n	8009c9e <cblas_ssyr+0x2a>
 8009ce4:	f1b8 0f00 	cmp.w	r8, #0
 8009ce8:	bfd4      	ite	le
 8009cea:	2008      	movle	r0, #8
 8009cec:	2003      	movgt	r0, #3
 8009cee:	4a4c      	ldr	r2, [pc, #304]	; (8009e20 <cblas_ssyr+0x1ac>)
 8009cf0:	494c      	ldr	r1, [pc, #304]	; (8009e24 <cblas_ssyr+0x1b0>)
 8009cf2:	f01e fd09 	bl	8028708 <cblas_xerbla>
  if (N == 0)
 8009cf6:	2d00      	cmp	r5, #0
 8009cf8:	d1de      	bne.n	8009cb8 <cblas_ssyr+0x44>
 8009cfa:	ecbd 8b02 	vpop	{d8}
 8009cfe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009d02:	2a00      	cmp	r2, #0
 8009d04:	dbec      	blt.n	8009ce0 <cblas_ssyr+0x6c>
 8009d06:	2f00      	cmp	r7, #0
 8009d08:	d0c9      	beq.n	8009c9e <cblas_ssyr+0x2a>
 8009d0a:	2a01      	cmp	r2, #1
 8009d0c:	4613      	mov	r3, r2
 8009d0e:	bfb8      	it	lt
 8009d10:	2301      	movlt	r3, #1
 8009d12:	4543      	cmp	r3, r8
 8009d14:	dc7d      	bgt.n	8009e12 <cblas_ssyr+0x19e>
 8009d16:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8009d1a:	2b01      	cmp	r3, #1
 8009d1c:	bf88      	it	hi
 8009d1e:	2001      	movhi	r0, #1
 8009d20:	d9c9      	bls.n	8009cb6 <cblas_ssyr+0x42>
 8009d22:	e7e4      	b.n	8009cee <cblas_ssyr+0x7a>
 8009d24:	2a01      	cmp	r2, #1
 8009d26:	4610      	mov	r0, r2
 8009d28:	bfb8      	it	lt
 8009d2a:	2001      	movlt	r0, #1
 8009d2c:	4580      	cmp	r8, r0
 8009d2e:	bfb4      	ite	lt
 8009d30:	2008      	movlt	r0, #8
 8009d32:	2002      	movge	r0, #2
 8009d34:	e7db      	b.n	8009cee <cblas_ssyr+0x7a>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009d36:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8009d3a:	d03d      	beq.n	8009db8 <cblas_ssyr+0x144>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 8009d3c:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8009d40:	d1c5      	bne.n	8009cce <cblas_ssyr+0x5a>
    INDEX ix = OFFSET(N, incX);
 8009d42:	2f00      	cmp	r7, #0
 8009d44:	bfda      	itte	le
 8009d46:	f1c5 0c01 	rsble	ip, r5, #1
 8009d4a:	fb0c fc07 	mulle.w	ip, ip, r7
 8009d4e:	f04f 0c00 	movgt.w	ip, #0
    for (i = 0; i < N; i++) {
 8009d52:	2d00      	cmp	r5, #0
 8009d54:	ddd1      	ble.n	8009cfa <cblas_ssyr+0x86>
 8009d56:	f108 0a01 	add.w	sl, r8, #1
 8009d5a:	f04f 0e00 	mov.w	lr, #0
 8009d5e:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8009d62:	46f1      	mov	r9, lr
 8009d64:	1d22      	adds	r2, r4, #4
 8009d66:	00bb      	lsls	r3, r7, #2
 8009d68:	ea4f 018c 	mov.w	r1, ip, lsl #2
 8009d6c:	eb06 0b8c 	add.w	fp, r6, ip, lsl #2
      const BASE tmp = alpha * X[ix];
 8009d70:	4431      	add	r1, r6
 8009d72:	edd1 6a00 	vldr	s13, [r1]
 8009d76:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (j = 0; j <= i; j++) {
 8009d7a:	eb04 018e 	add.w	r1, r4, lr, lsl #2
      const BASE tmp = alpha * X[ix];
 8009d7e:	4658      	mov	r0, fp
        A[lda * i + j] += X[jx] * tmp;
 8009d80:	ed90 7a00 	vldr	s14, [r0]
 8009d84:	edd1 7a00 	vldr	s15, [r1]
 8009d88:	eee7 7a26 	vfma.f32	s15, s14, s13
 8009d8c:	4418      	add	r0, r3
 8009d8e:	ece1 7a01 	vstmia	r1!, {s15}
      for (j = 0; j <= i; j++) {
 8009d92:	428a      	cmp	r2, r1
 8009d94:	d1f4      	bne.n	8009d80 <cblas_ssyr+0x10c>
    for (i = 0; i < N; i++) {
 8009d96:	f109 0901 	add.w	r9, r9, #1
 8009d9a:	454d      	cmp	r5, r9
      ix += incX;
 8009d9c:	44bc      	add	ip, r7
    for (i = 0; i < N; i++) {
 8009d9e:	44c6      	add	lr, r8
 8009da0:	4452      	add	r2, sl
 8009da2:	d0aa      	beq.n	8009cfa <cblas_ssyr+0x86>
 8009da4:	ea4f 018c 	mov.w	r1, ip, lsl #2
 8009da8:	e7e2      	b.n	8009d70 <cblas_ssyr+0xfc>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8009daa:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8009dae:	d003      	beq.n	8009db8 <cblas_ssyr+0x144>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8009db0:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8009db4:	d18b      	bne.n	8009cce <cblas_ssyr+0x5a>
 8009db6:	e7c4      	b.n	8009d42 <cblas_ssyr+0xce>
    INDEX ix = OFFSET(N, incX);
 8009db8:	2f00      	cmp	r7, #0
 8009dba:	dd2c      	ble.n	8009e16 <cblas_ssyr+0x1a2>
 8009dbc:	2200      	movs	r2, #0
    for (i = 0; i < N; i++) {
 8009dbe:	2d00      	cmp	r5, #0
 8009dc0:	dd9b      	ble.n	8009cfa <cblas_ssyr+0x86>
 8009dc2:	f108 0801 	add.w	r8, r8, #1
 8009dc6:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8009dca:	46a6      	mov	lr, r4
 8009dcc:	00bb      	lsls	r3, r7, #2
 8009dce:	eb06 0987 	add.w	r9, r6, r7, lsl #2
 8009dd2:	f04f 0c00 	mov.w	ip, #0
      const BASE tmp = alpha * X[ix];
 8009dd6:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 8009dda:	ed91 7a00 	vldr	s14, [r1]
 8009dde:	eb09 0482 	add.w	r4, r9, r2, lsl #2
 8009de2:	ee67 6a08 	vmul.f32	s13, s14, s16
 8009de6:	4670      	mov	r0, lr
 8009de8:	4661      	mov	r1, ip
 8009dea:	e002      	b.n	8009df2 <cblas_ssyr+0x17e>
 8009dec:	ed94 7a00 	vldr	s14, [r4]
 8009df0:	441c      	add	r4, r3
        A[lda * i + j] += X[jx] * tmp;
 8009df2:	edd0 7a00 	vldr	s15, [r0]
 8009df6:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = i; j < N; j++) {
 8009dfa:	3101      	adds	r1, #1
 8009dfc:	428d      	cmp	r5, r1
        A[lda * i + j] += X[jx] * tmp;
 8009dfe:	ece0 7a01 	vstmia	r0!, {s15}
      for (j = i; j < N; j++) {
 8009e02:	dcf3      	bgt.n	8009dec <cblas_ssyr+0x178>
    for (i = 0; i < N; i++) {
 8009e04:	f10c 0c01 	add.w	ip, ip, #1
 8009e08:	4565      	cmp	r5, ip
      ix += incX;
 8009e0a:	443a      	add	r2, r7
    for (i = 0; i < N; i++) {
 8009e0c:	44c6      	add	lr, r8
 8009e0e:	d1e2      	bne.n	8009dd6 <cblas_ssyr+0x162>
 8009e10:	e773      	b.n	8009cfa <cblas_ssyr+0x86>
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009e12:	2008      	movs	r0, #8
 8009e14:	e76b      	b.n	8009cee <cblas_ssyr+0x7a>
    INDEX ix = OFFSET(N, incX);
 8009e16:	f1c5 0201 	rsb	r2, r5, #1
 8009e1a:	fb02 f207 	mul.w	r2, r2, r7
 8009e1e:	e7ce      	b.n	8009dbe <cblas_ssyr+0x14a>
 8009e20:	08031108 	.word	0x08031108
 8009e24:	0803123c 	.word	0x0803123c
 8009e28:	080311b8 	.word	0x080311b8

08009e2c <cblas_ssyr2>:

void
cblas_ssyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const float alpha, const float *X, const int incX,
             const float *Y, const int incY, float *A, const int lda)
{
 8009e2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009e30:	ed2d 8b02 	vpush	{d8}
 8009e34:	b087      	sub	sp, #28
 8009e36:	460d      	mov	r5, r1
 8009e38:	9300      	str	r3, [sp, #0]
 8009e3a:	e9dd 6312 	ldrd	r6, r3, [sp, #72]	; 0x48
 8009e3e:	9301      	str	r3, [sp, #4]
 8009e40:	e9dd 7314 	ldrd	r7, r3, [sp, #80]	; 0x50
 */

{
  INDEX i, j;

  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 8009e44:	3979      	subs	r1, #121	; 0x79
 8009e46:	2901      	cmp	r1, #1
 8009e48:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 8009e4c:	9302      	str	r3, [sp, #8]
 8009e4e:	4681      	mov	r9, r0
 8009e50:	4614      	mov	r4, r2
 8009e52:	eeb0 8a40 	vmov.f32	s16, s0
 8009e56:	f240 80a7 	bls.w	8009fa8 <cblas_ssyr2+0x17c>
 8009e5a:	2002      	movs	r0, #2
 8009e5c:	2c00      	cmp	r4, #0
 8009e5e:	f2c0 8097 	blt.w	8009f90 <cblas_ssyr2+0x164>
 8009e62:	2e00      	cmp	r6, #0
 8009e64:	d17f      	bne.n	8009f66 <cblas_ssyr2+0x13a>
 8009e66:	2f00      	cmp	r7, #0
 8009e68:	f040 8089 	bne.w	8009f7e <cblas_ssyr2+0x152>
 8009e6c:	2c01      	cmp	r4, #1
 8009e6e:	4620      	mov	r0, r4
 8009e70:	bfb8      	it	lt
 8009e72:	2001      	movlt	r0, #1
 8009e74:	4580      	cmp	r8, r0
 8009e76:	bfb4      	ite	lt
 8009e78:	200a      	movlt	r0, #10
 8009e7a:	2008      	movge	r0, #8
 8009e7c:	4a85      	ldr	r2, [pc, #532]	; (800a094 <cblas_ssyr2+0x268>)
 8009e7e:	4986      	ldr	r1, [pc, #536]	; (800a098 <cblas_ssyr2+0x26c>)
 8009e80:	f01e fc42 	bl	8028708 <cblas_xerbla>

  if (N == 0)
 8009e84:	2c00      	cmp	r4, #0
 8009e86:	d069      	beq.n	8009f5c <cblas_ssyr2+0x130>
    return;

  if (alpha == 0.0)
 8009e88:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009e8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e90:	d064      	beq.n	8009f5c <cblas_ssyr2+0x130>
    return;

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8009e92:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8009e96:	f000 80ef 	beq.w	800a078 <cblas_ssyr2+0x24c>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009e9a:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 8009e9e:	f000 8089 	beq.w	8009fb4 <cblas_ssyr2+0x188>
      }
      ix += incX;
      iy += incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8009ea2:	4a7e      	ldr	r2, [pc, #504]	; (800a09c <cblas_ssyr2+0x270>)
 8009ea4:	497c      	ldr	r1, [pc, #496]	; (800a098 <cblas_ssyr2+0x26c>)
 8009ea6:	2000      	movs	r0, #0
#define BASE float
#include "source_syr2.h"
#undef BASE
}
 8009ea8:	b007      	add	sp, #28
 8009eaa:	ecbd 8b02 	vpop	{d8}
 8009eae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009eb2:	f01e bc29 	b.w	8028708 <cblas_xerbla>
    INDEX ix = OFFSET(N, incX);
 8009eb6:	2e00      	cmp	r6, #0
 8009eb8:	bfda      	itte	le
 8009eba:	f1c4 0e01 	rsble	lr, r4, #1
 8009ebe:	fb0e fe06 	mulle.w	lr, lr, r6
 8009ec2:	f04f 0e00 	movgt.w	lr, #0
    INDEX iy = OFFSET(N, incY);
 8009ec6:	2f00      	cmp	r7, #0
 8009ec8:	f340 80df 	ble.w	800a08a <cblas_ssyr2+0x25e>
 8009ecc:	f04f 0900 	mov.w	r9, #0
    for (i = 0; i < N; i++) {
 8009ed0:	2c00      	cmp	r4, #0
 8009ed2:	dd43      	ble.n	8009f5c <cblas_ssyr2+0x130>
 8009ed4:	9b01      	ldr	r3, [sp, #4]
 8009ed6:	f8dd a008 	ldr.w	sl, [sp, #8]
 8009eda:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 8009ede:	9303      	str	r3, [sp, #12]
 8009ee0:	9b00      	ldr	r3, [sp, #0]
 8009ee2:	f108 0801 	add.w	r8, r8, #1
 8009ee6:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8009eea:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 8009eee:	ea4f 0c87 	mov.w	ip, r7, lsl #2
 8009ef2:	00b5      	lsls	r5, r6, #2
 8009ef4:	9302      	str	r3, [sp, #8]
 8009ef6:	f04f 0800 	mov.w	r8, #0
      const BASE tmp1 = alpha * X[ix];
 8009efa:	9b00      	ldr	r3, [sp, #0]
 8009efc:	eb03 028e 	add.w	r2, r3, lr, lsl #2
      const BASE tmp2 = alpha * Y[iy];
 8009f00:	9b01      	ldr	r3, [sp, #4]
      const BASE tmp1 = alpha * X[ix];
 8009f02:	edd2 7a00 	vldr	s15, [r2]
      const BASE tmp2 = alpha * Y[iy];
 8009f06:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 8009f0a:	edd3 6a00 	vldr	s13, [r3]
 8009f0e:	9b03      	ldr	r3, [sp, #12]
 8009f10:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 8009f14:	9b02      	ldr	r3, [sp, #8]
      const BASE tmp1 = alpha * X[ix];
 8009f16:	ee67 5a88 	vmul.f32	s11, s15, s16
      const BASE tmp2 = alpha * Y[iy];
 8009f1a:	eb03 018e 	add.w	r1, r3, lr, lsl #2
 8009f1e:	ee26 6a88 	vmul.f32	s12, s13, s16
 8009f22:	4652      	mov	r2, sl
 8009f24:	4643      	mov	r3, r8
 8009f26:	e005      	b.n	8009f34 <cblas_ssyr2+0x108>
 8009f28:	edd0 6a00 	vldr	s13, [r0]
 8009f2c:	edd1 7a00 	vldr	s15, [r1]
 8009f30:	4460      	add	r0, ip
 8009f32:	4429      	add	r1, r5
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 8009f34:	ee66 7a27 	vmul.f32	s15, s12, s15
 8009f38:	ed92 7a00 	vldr	s14, [r2]
 8009f3c:	eee5 7aa6 	vfma.f32	s15, s11, s13
      for (j = i; j < N; j++) {
 8009f40:	3301      	adds	r3, #1
 8009f42:	429c      	cmp	r4, r3
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 8009f44:	ee77 7a27 	vadd.f32	s15, s14, s15
 8009f48:	ece2 7a01 	vstmia	r2!, {s15}
      for (j = i; j < N; j++) {
 8009f4c:	dcec      	bgt.n	8009f28 <cblas_ssyr2+0xfc>
    for (i = 0; i < N; i++) {
 8009f4e:	f108 0801 	add.w	r8, r8, #1
 8009f52:	4544      	cmp	r4, r8
      ix += incX;
 8009f54:	44b6      	add	lr, r6
      iy += incY;
 8009f56:	44b9      	add	r9, r7
    for (i = 0; i < N; i++) {
 8009f58:	44da      	add	sl, fp
 8009f5a:	d1ce      	bne.n	8009efa <cblas_ssyr2+0xce>
 8009f5c:	b007      	add	sp, #28
 8009f5e:	ecbd 8b02 	vpop	{d8}
 8009f62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 8009f66:	2f00      	cmp	r7, #0
 8009f68:	d080      	beq.n	8009e6c <cblas_ssyr2+0x40>
 8009f6a:	2c01      	cmp	r4, #1
 8009f6c:	4623      	mov	r3, r4
 8009f6e:	bfb8      	it	lt
 8009f70:	2301      	movlt	r3, #1
 8009f72:	4543      	cmp	r3, r8
 8009f74:	f300 8087 	bgt.w	800a086 <cblas_ssyr2+0x25a>
 8009f78:	2800      	cmp	r0, #0
 8009f7a:	d083      	beq.n	8009e84 <cblas_ssyr2+0x58>
 8009f7c:	e77e      	b.n	8009e7c <cblas_ssyr2+0x50>
 8009f7e:	2c01      	cmp	r4, #1
 8009f80:	4620      	mov	r0, r4
 8009f82:	bfb8      	it	lt
 8009f84:	2001      	movlt	r0, #1
 8009f86:	4580      	cmp	r8, r0
 8009f88:	bfb4      	ite	lt
 8009f8a:	200a      	movlt	r0, #10
 8009f8c:	2006      	movge	r0, #6
 8009f8e:	e775      	b.n	8009e7c <cblas_ssyr2+0x50>
 8009f90:	2e00      	cmp	r6, #0
 8009f92:	f43f af68 	beq.w	8009e66 <cblas_ssyr2+0x3a>
 8009f96:	2f00      	cmp	r7, #0
 8009f98:	f43f af68 	beq.w	8009e6c <cblas_ssyr2+0x40>
 8009f9c:	f1b8 0f00 	cmp.w	r8, #0
 8009fa0:	bfd4      	ite	le
 8009fa2:	200a      	movle	r0, #10
 8009fa4:	2003      	movgt	r0, #3
 8009fa6:	e769      	b.n	8009e7c <cblas_ssyr2+0x50>
 8009fa8:	3865      	subs	r0, #101	; 0x65
 8009faa:	2801      	cmp	r0, #1
 8009fac:	bf94      	ite	ls
 8009fae:	2000      	movls	r0, #0
 8009fb0:	2001      	movhi	r0, #1
 8009fb2:	e753      	b.n	8009e5c <cblas_ssyr2+0x30>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009fb4:	2d7a      	cmp	r5, #122	; 0x7a
 8009fb6:	f43f af7e 	beq.w	8009eb6 <cblas_ssyr2+0x8a>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 8009fba:	2d79      	cmp	r5, #121	; 0x79
 8009fbc:	f47f af71 	bne.w	8009ea2 <cblas_ssyr2+0x76>
    INDEX ix = OFFSET(N, incX);
 8009fc0:	2e00      	cmp	r6, #0
 8009fc2:	bfda      	itte	le
 8009fc4:	f1c4 0e01 	rsble	lr, r4, #1
 8009fc8:	fb0e fe06 	mulle.w	lr, lr, r6
 8009fcc:	f04f 0e00 	movgt.w	lr, #0
    INDEX iy = OFFSET(N, incY);
 8009fd0:	2f00      	cmp	r7, #0
 8009fd2:	bfda      	itte	le
 8009fd4:	f1c4 0901 	rsble	r9, r4, #1
 8009fd8:	fb09 f907 	mulle.w	r9, r9, r7
 8009fdc:	f04f 0900 	movgt.w	r9, #0
    for (i = 0; i < N; i++) {
 8009fe0:	2c00      	cmp	r4, #0
 8009fe2:	ddbb      	ble.n	8009f5c <cblas_ssyr2+0x130>
 8009fe4:	f108 0301 	add.w	r3, r8, #1
 8009fe8:	009b      	lsls	r3, r3, #2
 8009fea:	9303      	str	r3, [sp, #12]
 8009fec:	9b02      	ldr	r3, [sp, #8]
 8009fee:	9800      	ldr	r0, [sp, #0]
 8009ff0:	1d1a      	adds	r2, r3, #4
 8009ff2:	9b01      	ldr	r3, [sp, #4]
 8009ff4:	f04f 0a00 	mov.w	sl, #0
 8009ff8:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 8009ffc:	eb00 008e 	add.w	r0, r0, lr, lsl #2
 800a000:	9305      	str	r3, [sp, #20]
 800a002:	46d3      	mov	fp, sl
 800a004:	ea4f 0c87 	mov.w	ip, r7, lsl #2
 800a008:	ea4f 0189 	mov.w	r1, r9, lsl #2
 800a00c:	00b5      	lsls	r5, r6, #2
 800a00e:	ea4f 038e 	mov.w	r3, lr, lsl #2
 800a012:	9004      	str	r0, [sp, #16]
      const BASE tmp1 = alpha * X[ix];
 800a014:	9800      	ldr	r0, [sp, #0]
 800a016:	4403      	add	r3, r0
      const BASE tmp2 = alpha * Y[iy];
 800a018:	9801      	ldr	r0, [sp, #4]
      const BASE tmp1 = alpha * X[ix];
 800a01a:	edd3 5a00 	vldr	s11, [r3]
 800a01e:	9b02      	ldr	r3, [sp, #8]
      const BASE tmp2 = alpha * Y[iy];
 800a020:	4401      	add	r1, r0
 800a022:	ed91 6a00 	vldr	s12, [r1]
 800a026:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
      const BASE tmp1 = alpha * X[ix];
 800a02a:	ee68 5a25 	vmul.f32	s11, s16, s11
      const BASE tmp2 = alpha * Y[iy];
 800a02e:	ee28 6a06 	vmul.f32	s12, s16, s12
      for (j = 0; j <= i; j++) {
 800a032:	eb03 038a 	add.w	r3, r3, sl, lsl #2
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800a036:	edd0 7a00 	vldr	s15, [r0]
 800a03a:	edd1 6a00 	vldr	s13, [r1]
 800a03e:	ed93 7a00 	vldr	s14, [r3]
 800a042:	ee66 7a27 	vmul.f32	s15, s12, s15
 800a046:	4428      	add	r0, r5
 800a048:	eee6 7aa5 	vfma.f32	s15, s13, s11
 800a04c:	4461      	add	r1, ip
 800a04e:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a052:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j <= i; j++) {
 800a056:	429a      	cmp	r2, r3
 800a058:	d1ed      	bne.n	800a036 <cblas_ssyr2+0x20a>
      ix += incX;
 800a05a:	9b03      	ldr	r3, [sp, #12]
    for (i = 0; i < N; i++) {
 800a05c:	f10b 0b01 	add.w	fp, fp, #1
 800a060:	455c      	cmp	r4, fp
      ix += incX;
 800a062:	44b6      	add	lr, r6
      iy += incY;
 800a064:	44b9      	add	r9, r7
    for (i = 0; i < N; i++) {
 800a066:	44c2      	add	sl, r8
 800a068:	441a      	add	r2, r3
 800a06a:	f43f af77 	beq.w	8009f5c <cblas_ssyr2+0x130>
 800a06e:	ea4f 0189 	mov.w	r1, r9, lsl #2
 800a072:	ea4f 038e 	mov.w	r3, lr, lsl #2
 800a076:	e7cd      	b.n	800a014 <cblas_ssyr2+0x1e8>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800a078:	2d79      	cmp	r5, #121	; 0x79
 800a07a:	f43f af1c 	beq.w	8009eb6 <cblas_ssyr2+0x8a>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800a07e:	2d7a      	cmp	r5, #122	; 0x7a
 800a080:	f47f af0f 	bne.w	8009ea2 <cblas_ssyr2+0x76>
 800a084:	e79c      	b.n	8009fc0 <cblas_ssyr2+0x194>
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800a086:	200a      	movs	r0, #10
 800a088:	e6f8      	b.n	8009e7c <cblas_ssyr2+0x50>
    INDEX iy = OFFSET(N, incY);
 800a08a:	f1c4 0901 	rsb	r9, r4, #1
 800a08e:	fb09 f907 	mul.w	r9, r9, r7
 800a092:	e71d      	b.n	8009ed0 <cblas_ssyr2+0xa4>
 800a094:	08031108 	.word	0x08031108
 800a098:	0803124c 	.word	0x0803124c
 800a09c:	080311b8 	.word	0x080311b8

0800a0a0 <cblas_ssyr2k>:
cblas_ssyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const float alpha, const float *A, const int lda,
              const float *B, const int ldb, const float beta, float *C,
              const int ldc)
{
 800a0a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a0a4:	ed2d 8b02 	vpush	{d8}
 800a0a8:	b08b      	sub	sp, #44	; 0x2c
 800a0aa:	461c      	mov	r4, r3
 800a0ac:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800a0ae:	9302      	str	r3, [sp, #8]
 800a0b0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800a0b2:	9300      	str	r3, [sp, #0]
 800a0b4:	e9dd 6318 	ldrd	r6, r3, [sp, #96]	; 0x60

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800a0b8:	2865      	cmp	r0, #101	; 0x65
 800a0ba:	e9dd b71a 	ldrd	fp, r7, [sp, #104]	; 0x68
 800a0be:	f8dd 8070 	ldr.w	r8, [sp, #112]	; 0x70
 800a0c2:	9301      	str	r3, [sp, #4]
 800a0c4:	4681      	mov	r9, r0
 800a0c6:	468a      	mov	sl, r1
 800a0c8:	4615      	mov	r5, r2
 800a0ca:	eeb0 8a40 	vmov.f32	s16, s0
 800a0ce:	eef0 8a60 	vmov.f32	s17, s1
 800a0d2:	f000 80e7 	beq.w	800a2a4 <cblas_ssyr2k+0x204>
 800a0d6:	2a6f      	cmp	r2, #111	; 0x6f
 800a0d8:	f000 80c0 	beq.w	800a25c <cblas_ssyr2k+0x1bc>
 800a0dc:	9902      	ldr	r1, [sp, #8]
 800a0de:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 800a0e2:	2a01      	cmp	r2, #1
 800a0e4:	f240 80d7 	bls.w	800a296 <cblas_ssyr2k+0x1f6>
 800a0e8:	2002      	movs	r0, #2
 800a0ea:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800a0ee:	b2db      	uxtb	r3, r3
 800a0f0:	2b03      	cmp	r3, #3
 800a0f2:	bf28      	it	cs
 800a0f4:	2003      	movcs	r0, #3
 800a0f6:	9b02      	ldr	r3, [sp, #8]
 800a0f8:	2c00      	cmp	r4, #0
 800a0fa:	bfb8      	it	lt
 800a0fc:	2004      	movlt	r0, #4
 800a0fe:	2b00      	cmp	r3, #0
 800a100:	bfb8      	it	lt
 800a102:	2005      	movlt	r0, #5
 800a104:	2901      	cmp	r1, #1
 800a106:	460b      	mov	r3, r1
 800a108:	bfb8      	it	lt
 800a10a:	2301      	movlt	r3, #1
 800a10c:	42b3      	cmp	r3, r6
 800a10e:	f340 80b5 	ble.w	800a27c <cblas_ssyr2k+0x1dc>
 800a112:	455b      	cmp	r3, fp
 800a114:	f300 80a9 	bgt.w	800a26a <cblas_ssyr2k+0x1ca>
 800a118:	2c01      	cmp	r4, #1
 800a11a:	4620      	mov	r0, r4
 800a11c:	bfb8      	it	lt
 800a11e:	2001      	movlt	r0, #1
 800a120:	4580      	cmp	r8, r0
 800a122:	bfb4      	ite	lt
 800a124:	200e      	movlt	r0, #14
 800a126:	2008      	movge	r0, #8
 800a128:	4ad6      	ldr	r2, [pc, #856]	; (800a484 <cblas_ssyr2k+0x3e4>)
 800a12a:	49d7      	ldr	r1, [pc, #860]	; (800a488 <cblas_ssyr2k+0x3e8>)
 800a12c:	f01e faec 	bl	8028708 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 800a130:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a134:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a138:	d107      	bne.n	800a14a <cblas_ssyr2k+0xaa>
 800a13a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a13e:	eef4 8a67 	vcmp.f32	s17, s15
 800a142:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a146:	f000 8084 	beq.w	800a252 <cblas_ssyr2k+0x1b2>
    return;

  if (Order == CblasRowMajor) {
 800a14a:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 800a14e:	f000 80ae 	beq.w	800a2ae <cblas_ssyr2k+0x20e>
    uplo = Uplo;
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
  } else {
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;

    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a152:	f1a5 0370 	sub.w	r3, r5, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a156:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a15a:	b2db      	uxtb	r3, r3
      trans = CblasTrans;
    }
  }

  /* form  C := beta*C */
  if (beta == 0.0) {
 800a15c:	eef5 8a40 	vcmp.f32	s17, #0.0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a160:	f000 8180 	beq.w	800a464 <cblas_ssyr2k+0x3c4>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a164:	2b01      	cmp	r3, #1
 800a166:	f240 8195 	bls.w	800a494 <cblas_ssyr2k+0x3f4>
  if (beta == 0.0) {
 800a16a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a16e:	f040 814f 	bne.w	800a410 <cblas_ssyr2k+0x370>
    if (uplo == CblasUpper) {
      for (i = 0; i < N; i++) {
 800a172:	2c00      	cmp	r4, #0
      trans = CblasTrans;
 800a174:	bfc8      	it	gt
 800a176:	f04f 0c70 	movgt.w	ip, #112	; 0x70
      for (i = 0; i < N; i++) {
 800a17a:	f340 816c 	ble.w	800a456 <cblas_ssyr2k+0x3b6>
 800a17e:	f108 0501 	add.w	r5, r8, #1
        for (j = i; j < N; j++) {
          C[ldc * i + j] = 0.0;
 800a182:	f04f 0e00 	mov.w	lr, #0
 800a186:	00ad      	lsls	r5, r5, #2
 800a188:	4638      	mov	r0, r7
      for (i = 0; i < N; i++) {
 800a18a:	2100      	movs	r1, #0
 800a18c:	4602      	mov	r2, r0
 800a18e:	460b      	mov	r3, r1
        for (j = i; j < N; j++) {
 800a190:	3301      	adds	r3, #1
 800a192:	429c      	cmp	r4, r3
          C[ldc * i + j] = 0.0;
 800a194:	f842 eb04 	str.w	lr, [r2], #4
        for (j = i; j < N; j++) {
 800a198:	dcfa      	bgt.n	800a190 <cblas_ssyr2k+0xf0>
      for (i = 0; i < N; i++) {
 800a19a:	3101      	adds	r1, #1
 800a19c:	428c      	cmp	r4, r1
 800a19e:	4428      	add	r0, r5
 800a1a0:	dcf4      	bgt.n	800a18c <cblas_ssyr2k+0xec>
        }
      }
    }
  }

  if (alpha == 0.0)
 800a1a2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a1a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a1aa:	d052      	beq.n	800a252 <cblas_ssyr2k+0x1b2>
    return;

  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800a1ac:	f1bc 0f6f 	cmp.w	ip, #111	; 0x6f
 800a1b0:	f000 817f 	beq.w	800a4b2 <cblas_ssyr2k+0x412>
        }
        C[i * ldc + j] += alpha * temp;
      }
    }

  } else if (uplo == CblasUpper && trans == CblasTrans) {
 800a1b4:	f1bc 0f70 	cmp.w	ip, #112	; 0x70
 800a1b8:	f040 80ad 	bne.w	800a316 <cblas_ssyr2k+0x276>

    for (k = 0; k < K; k++) {
 800a1bc:	9b02      	ldr	r3, [sp, #8]
 800a1be:	2b00      	cmp	r3, #0
 800a1c0:	dd47      	ble.n	800a252 <cblas_ssyr2k+0x1b2>
 800a1c2:	00b0      	lsls	r0, r6, #2
 800a1c4:	9003      	str	r0, [sp, #12]
 800a1c6:	9800      	ldr	r0, [sp, #0]
 800a1c8:	9706      	str	r7, [sp, #24]
 800a1ca:	2300      	movs	r3, #0
 800a1cc:	f106 0a01 	add.w	sl, r6, #1
 800a1d0:	e9cd 6b04 	strd	r6, fp, [sp, #16]
 800a1d4:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800a1d8:	eb00 0984 	add.w	r9, r0, r4, lsl #2
 800a1dc:	469e      	mov	lr, r3
 800a1de:	4698      	mov	r8, r3
 800a1e0:	469b      	mov	fp, r3
      for (i = 0; i < N; i++) {
 800a1e2:	2c00      	cmp	r4, #0
 800a1e4:	dd2a      	ble.n	800a23c <cblas_ssyr2k+0x19c>
 800a1e6:	9b00      	ldr	r3, [sp, #0]
 800a1e8:	9f06      	ldr	r7, [sp, #24]
 800a1ea:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 800a1ee:	9b01      	ldr	r3, [sp, #4]
 800a1f0:	2600      	movs	r6, #0
 800a1f2:	eb03 0c88 	add.w	ip, r3, r8, lsl #2
        BASE temp1 = alpha * A[k * lda + i];
 800a1f6:	ecf5 7a01 	vldmia	r5!, {s15}
        BASE temp2 = alpha * B[k * ldb + i];
 800a1fa:	ecfc 6a01 	vldmia	ip!, {s13}
        BASE temp1 = alpha * A[k * lda + i];
 800a1fe:	ee67 5a88 	vmul.f32	s11, s15, s16
        BASE temp2 = alpha * B[k * ldb + i];
 800a202:	ee26 6a88 	vmul.f32	s12, s13, s16
 800a206:	4628      	mov	r0, r5
 800a208:	4661      	mov	r1, ip
 800a20a:	463a      	mov	r2, r7
 800a20c:	4633      	mov	r3, r6
 800a20e:	e003      	b.n	800a218 <cblas_ssyr2k+0x178>
 800a210:	ecf1 6a01 	vldmia	r1!, {s13}
 800a214:	ecf0 7a01 	vldmia	r0!, {s15}
        for (j = i; j < N; j++) {
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800a218:	ed92 7a00 	vldr	s14, [r2]
 800a21c:	ee66 7a27 	vmul.f32	s15, s12, s15
        for (j = i; j < N; j++) {
 800a220:	3301      	adds	r3, #1
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800a222:	eee5 7aa6 	vfma.f32	s15, s11, s13
        for (j = i; j < N; j++) {
 800a226:	429c      	cmp	r4, r3
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800a228:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a22c:	ece2 7a01 	vstmia	r2!, {s15}
        for (j = i; j < N; j++) {
 800a230:	dcee      	bgt.n	800a210 <cblas_ssyr2k+0x170>
      for (i = 0; i < N; i++) {
 800a232:	45a9      	cmp	r9, r5
 800a234:	f106 0601 	add.w	r6, r6, #1
 800a238:	4457      	add	r7, sl
 800a23a:	d1dc      	bne.n	800a1f6 <cblas_ssyr2k+0x156>
    for (k = 0; k < K; k++) {
 800a23c:	9b03      	ldr	r3, [sp, #12]
 800a23e:	4499      	add	r9, r3
 800a240:	9b04      	ldr	r3, [sp, #16]
 800a242:	449b      	add	fp, r3
 800a244:	9b05      	ldr	r3, [sp, #20]
 800a246:	4498      	add	r8, r3
 800a248:	9b02      	ldr	r3, [sp, #8]
 800a24a:	f10e 0e01 	add.w	lr, lr, #1
 800a24e:	4573      	cmp	r3, lr
 800a250:	d1c7      	bne.n	800a1e2 <cblas_ssyr2k+0x142>
#define BASE float
#include "source_syr2k_r.h"
#undef BASE
}
 800a252:	b00b      	add	sp, #44	; 0x2c
 800a254:	ecbd 8b02 	vpop	{d8}
 800a258:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800a25c:	4621      	mov	r1, r4
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800a25e:	f1aa 0379 	sub.w	r3, sl, #121	; 0x79
 800a262:	2b01      	cmp	r3, #1
 800a264:	d917      	bls.n	800a296 <cblas_ssyr2k+0x1f6>
 800a266:	2002      	movs	r0, #2
 800a268:	e745      	b.n	800a0f6 <cblas_ssyr2k+0x56>
 800a26a:	2c01      	cmp	r4, #1
 800a26c:	4620      	mov	r0, r4
 800a26e:	bfb8      	it	lt
 800a270:	2001      	movlt	r0, #1
 800a272:	4580      	cmp	r8, r0
 800a274:	bfb4      	ite	lt
 800a276:	200e      	movlt	r0, #14
 800a278:	200b      	movge	r0, #11
 800a27a:	e755      	b.n	800a128 <cblas_ssyr2k+0x88>
 800a27c:	455b      	cmp	r3, fp
 800a27e:	dcf4      	bgt.n	800a26a <cblas_ssyr2k+0x1ca>
 800a280:	2c01      	cmp	r4, #1
 800a282:	4623      	mov	r3, r4
 800a284:	bfb8      	it	lt
 800a286:	2301      	movlt	r3, #1
 800a288:	4543      	cmp	r3, r8
 800a28a:	f300 80e2 	bgt.w	800a452 <cblas_ssyr2k+0x3b2>
 800a28e:	2800      	cmp	r0, #0
 800a290:	f43f af4e 	beq.w	800a130 <cblas_ssyr2k+0x90>
 800a294:	e748      	b.n	800a128 <cblas_ssyr2k+0x88>
 800a296:	f1a9 0065 	sub.w	r0, r9, #101	; 0x65
 800a29a:	2801      	cmp	r0, #1
 800a29c:	bf94      	ite	ls
 800a29e:	2000      	movls	r0, #0
 800a2a0:	2001      	movhi	r0, #1
 800a2a2:	e722      	b.n	800a0ea <cblas_ssyr2k+0x4a>
 800a2a4:	2a6f      	cmp	r2, #111	; 0x6f
 800a2a6:	f000 815f 	beq.w	800a568 <cblas_ssyr2k+0x4c8>
 800a2aa:	4621      	mov	r1, r4
 800a2ac:	e717      	b.n	800a0de <cblas_ssyr2k+0x3e>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 800a2ae:	2d71      	cmp	r5, #113	; 0x71
  if (beta == 0.0) {
 800a2b0:	eef5 8a40 	vcmp.f32	s17, #0.0
 800a2b4:	bf14      	ite	ne
 800a2b6:	46ac      	movne	ip, r5
 800a2b8:	f04f 0c70 	moveq.w	ip, #112	; 0x70
 800a2bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a2c0:	d033      	beq.n	800a32a <cblas_ssyr2k+0x28a>
  } else if (beta != 1.0) {
 800a2c2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a2c6:	eef4 8a67 	vcmp.f32	s17, s15
 800a2ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a2ce:	d045      	beq.n	800a35c <cblas_ssyr2k+0x2bc>
    if (uplo == CblasUpper) {
 800a2d0:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a2d4:	f000 81eb 	beq.w	800a6ae <cblas_ssyr2k+0x60e>
      for (i = 0; i < N; i++) {
 800a2d8:	2c00      	cmp	r4, #0
 800a2da:	dd14      	ble.n	800a306 <cblas_ssyr2k+0x266>
 800a2dc:	f108 0501 	add.w	r5, r8, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a2e0:	2100      	movs	r1, #0
 800a2e2:	00ad      	lsls	r5, r5, #2
      for (i = 0; i < N; i++) {
 800a2e4:	4608      	mov	r0, r1
 800a2e6:	1d3a      	adds	r2, r7, #4
 800a2e8:	eb07 0381 	add.w	r3, r7, r1, lsl #2
          C[ldc * i + j] *= beta;
 800a2ec:	edd3 7a00 	vldr	s15, [r3]
 800a2f0:	ee67 7aa8 	vmul.f32	s15, s15, s17
 800a2f4:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j <= i; j++) {
 800a2f8:	4293      	cmp	r3, r2
 800a2fa:	d1f7      	bne.n	800a2ec <cblas_ssyr2k+0x24c>
      for (i = 0; i < N; i++) {
 800a2fc:	3001      	adds	r0, #1
 800a2fe:	4284      	cmp	r4, r0
 800a300:	4441      	add	r1, r8
 800a302:	442a      	add	r2, r5
 800a304:	dcf0      	bgt.n	800a2e8 <cblas_ssyr2k+0x248>
  if (alpha == 0.0)
 800a306:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a30a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a30e:	d0a0      	beq.n	800a252 <cblas_ssyr2k+0x1b2>
        }
      }
    }

  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800a310:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a314:	d02f      	beq.n	800a376 <cblas_ssyr2k+0x2d6>
      }
    }


  } else {
    BLAS_ERROR("unrecognized operation");
 800a316:	4a5d      	ldr	r2, [pc, #372]	; (800a48c <cblas_ssyr2k+0x3ec>)
 800a318:	495b      	ldr	r1, [pc, #364]	; (800a488 <cblas_ssyr2k+0x3e8>)
 800a31a:	2000      	movs	r0, #0
 800a31c:	b00b      	add	sp, #44	; 0x2c
 800a31e:	ecbd 8b02 	vpop	{d8}
 800a322:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a326:	f01e b9ef 	b.w	8028708 <cblas_xerbla>
    if (uplo == CblasUpper) {
 800a32a:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a32e:	f000 81ba 	beq.w	800a6a6 <cblas_ssyr2k+0x606>
      for (i = 0; i < N; i++) {
 800a332:	2c00      	cmp	r4, #0
 800a334:	dde7      	ble.n	800a306 <cblas_ssyr2k+0x266>
 800a336:	f108 0501 	add.w	r5, r8, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a33a:	2000      	movs	r0, #0
          C[ldc * i + j] = 0.0;
 800a33c:	f04f 0e00 	mov.w	lr, #0
 800a340:	00ad      	lsls	r5, r5, #2
      for (i = 0; i < N; i++) {
 800a342:	4601      	mov	r1, r0
 800a344:	1d3a      	adds	r2, r7, #4
 800a346:	eb07 0380 	add.w	r3, r7, r0, lsl #2
          C[ldc * i + j] = 0.0;
 800a34a:	f843 eb04 	str.w	lr, [r3], #4
        for (j = 0; j <= i; j++) {
 800a34e:	429a      	cmp	r2, r3
 800a350:	d1fb      	bne.n	800a34a <cblas_ssyr2k+0x2aa>
      for (i = 0; i < N; i++) {
 800a352:	3101      	adds	r1, #1
 800a354:	428c      	cmp	r4, r1
 800a356:	4440      	add	r0, r8
 800a358:	442a      	add	r2, r5
 800a35a:	dcf4      	bgt.n	800a346 <cblas_ssyr2k+0x2a6>
  if (alpha == 0.0)
 800a35c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a360:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a364:	f43f af75 	beq.w	800a252 <cblas_ssyr2k+0x1b2>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800a368:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a36c:	f43f af1e 	beq.w	800a1ac <cblas_ssyr2k+0x10c>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800a370:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a374:	d1cf      	bne.n	800a316 <cblas_ssyr2k+0x276>
 800a376:	f1bc 0f6f 	cmp.w	ip, #111	; 0x6f
 800a37a:	f000 8139 	beq.w	800a5f0 <cblas_ssyr2k+0x550>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 800a37e:	f1bc 0f70 	cmp.w	ip, #112	; 0x70
 800a382:	d1c8      	bne.n	800a316 <cblas_ssyr2k+0x276>
    for (k = 0; k < K; k++) {
 800a384:	9b02      	ldr	r3, [sp, #8]
 800a386:	2b00      	cmp	r3, #0
 800a388:	f77f af63 	ble.w	800a252 <cblas_ssyr2k+0x1b2>
 800a38c:	00b3      	lsls	r3, r6, #2
 800a38e:	f8dd 8000 	ldr.w	r8, [sp]
 800a392:	9303      	str	r3, [sp, #12]
 800a394:	ea4f 028b 	mov.w	r2, fp, lsl #2
 800a398:	f103 0b04 	add.w	fp, r3, #4
 800a39c:	2300      	movs	r3, #0
 800a39e:	f8dd 9004 	ldr.w	r9, [sp, #4]
 800a3a2:	9200      	str	r2, [sp, #0]
 800a3a4:	eb08 0a84 	add.w	sl, r8, r4, lsl #2
 800a3a8:	469e      	mov	lr, r3
 800a3aa:	9401      	str	r4, [sp, #4]
      for (i = 0; i < N; i++) {
 800a3ac:	9b01      	ldr	r3, [sp, #4]
 800a3ae:	2b00      	cmp	r3, #0
 800a3b0:	dd23      	ble.n	800a3fa <cblas_ssyr2k+0x35a>
 800a3b2:	1d38      	adds	r0, r7, #4
 800a3b4:	46cc      	mov	ip, r9
 800a3b6:	4645      	mov	r5, r8
 800a3b8:	2400      	movs	r4, #0
        BASE temp1 = alpha * A[k * lda + i];
 800a3ba:	ecf5 5a01 	vldmia	r5!, {s11}
        BASE temp2 = alpha * B[k * ldb + i];
 800a3be:	ecbc 6a01 	vldmia	ip!, {s12}
        BASE temp1 = alpha * A[k * lda + i];
 800a3c2:	ee65 5a88 	vmul.f32	s11, s11, s16
        BASE temp2 = alpha * B[k * ldb + i];
 800a3c6:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (j = 0; j <= i; j++) {
 800a3ca:	eb07 0384 	add.w	r3, r7, r4, lsl #2
        BASE temp2 = alpha * B[k * ldb + i];
 800a3ce:	4641      	mov	r1, r8
 800a3d0:	464a      	mov	r2, r9
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800a3d2:	ecf1 7a01 	vldmia	r1!, {s15}
 800a3d6:	ecf2 6a01 	vldmia	r2!, {s13}
 800a3da:	ed93 7a00 	vldr	s14, [r3]
 800a3de:	ee67 7a86 	vmul.f32	s15, s15, s12
 800a3e2:	eee6 7aa5 	vfma.f32	s15, s13, s11
 800a3e6:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a3ea:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j <= i; j++) {
 800a3ee:	4283      	cmp	r3, r0
 800a3f0:	d1ef      	bne.n	800a3d2 <cblas_ssyr2k+0x332>
      for (i = 0; i < N; i++) {
 800a3f2:	4555      	cmp	r5, sl
 800a3f4:	4434      	add	r4, r6
 800a3f6:	4458      	add	r0, fp
 800a3f8:	d1df      	bne.n	800a3ba <cblas_ssyr2k+0x31a>
    for (k = 0; k < K; k++) {
 800a3fa:	9b03      	ldr	r3, [sp, #12]
 800a3fc:	9a00      	ldr	r2, [sp, #0]
 800a3fe:	449a      	add	sl, r3
 800a400:	4498      	add	r8, r3
 800a402:	9b02      	ldr	r3, [sp, #8]
 800a404:	f10e 0e01 	add.w	lr, lr, #1
 800a408:	4573      	cmp	r3, lr
 800a40a:	4491      	add	r9, r2
 800a40c:	d1ce      	bne.n	800a3ac <cblas_ssyr2k+0x30c>
 800a40e:	e720      	b.n	800a252 <cblas_ssyr2k+0x1b2>
  } else if (beta != 1.0) {
 800a410:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a414:	eef4 8a67 	vcmp.f32	s17, s15
 800a418:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a41c:	d01b      	beq.n	800a456 <cblas_ssyr2k+0x3b6>
      for (i = 0; i < N; i++) {
 800a41e:	2c00      	cmp	r4, #0
      trans = CblasTrans;
 800a420:	bfc8      	it	gt
 800a422:	f04f 0c70 	movgt.w	ip, #112	; 0x70
      for (i = 0; i < N; i++) {
 800a426:	dd16      	ble.n	800a456 <cblas_ssyr2k+0x3b6>
 800a428:	f108 0501 	add.w	r5, r8, #1
 800a42c:	00ad      	lsls	r5, r5, #2
 800a42e:	4638      	mov	r0, r7
 800a430:	2100      	movs	r1, #0
 800a432:	4602      	mov	r2, r0
 800a434:	460b      	mov	r3, r1
          C[ldc * i + j] *= beta;
 800a436:	edd2 7a00 	vldr	s15, [r2]
        for (j = i; j < N; j++) {
 800a43a:	3301      	adds	r3, #1
          C[ldc * i + j] *= beta;
 800a43c:	ee67 7aa8 	vmul.f32	s15, s15, s17
        for (j = i; j < N; j++) {
 800a440:	429c      	cmp	r4, r3
          C[ldc * i + j] *= beta;
 800a442:	ece2 7a01 	vstmia	r2!, {s15}
        for (j = i; j < N; j++) {
 800a446:	dcf6      	bgt.n	800a436 <cblas_ssyr2k+0x396>
      for (i = 0; i < N; i++) {
 800a448:	3101      	adds	r1, #1
 800a44a:	428c      	cmp	r4, r1
 800a44c:	4428      	add	r0, r5
 800a44e:	dcf0      	bgt.n	800a432 <cblas_ssyr2k+0x392>
 800a450:	e6a7      	b.n	800a1a2 <cblas_ssyr2k+0x102>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800a452:	200e      	movs	r0, #14
 800a454:	e668      	b.n	800a128 <cblas_ssyr2k+0x88>
  if (alpha == 0.0)
 800a456:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a45a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a45e:	f47f aead 	bne.w	800a1bc <cblas_ssyr2k+0x11c>
 800a462:	e6f6      	b.n	800a252 <cblas_ssyr2k+0x1b2>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a464:	2b01      	cmp	r3, #1
 800a466:	f240 808f 	bls.w	800a588 <cblas_ssyr2k+0x4e8>
  if (beta == 0.0) {
 800a46a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a46e:	f040 809c 	bne.w	800a5aa <cblas_ssyr2k+0x50a>
      for (i = 0; i < N; i++) {
 800a472:	2c00      	cmp	r4, #0
 800a474:	f340 80af 	ble.w	800a5d6 <cblas_ssyr2k+0x536>
      trans = CblasTrans;
 800a478:	f04f 0c70 	mov.w	ip, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a47c:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 800a480:	e759      	b.n	800a336 <cblas_ssyr2k+0x296>
 800a482:	bf00      	nop
 800a484:	08031108 	.word	0x08031108
 800a488:	0803125c 	.word	0x0803125c
 800a48c:	080311b8 	.word	0x080311b8
 800a490:	00000000 	.word	0x00000000
  if (beta == 0.0) {
 800a494:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a498:	d168      	bne.n	800a56c <cblas_ssyr2k+0x4cc>
      for (i = 0; i < N; i++) {
 800a49a:	2c00      	cmp	r4, #0
      trans = CblasNoTrans;
 800a49c:	bfc8      	it	gt
 800a49e:	f04f 0c6f 	movgt.w	ip, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800a4a2:	f73f ae6c 	bgt.w	800a17e <cblas_ssyr2k+0xde>
  if (alpha == 0.0)
 800a4a6:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a4aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a4ae:	f43f aed0 	beq.w	800a252 <cblas_ssyr2k+0x1b2>
    for (i = 0; i < N; i++) {
 800a4b2:	2c00      	cmp	r4, #0
 800a4b4:	f77f aecd 	ble.w	800a252 <cblas_ssyr2k+0x1b2>
 800a4b8:	2300      	movs	r3, #0
 800a4ba:	e9cd 3705 	strd	r3, r7, [sp, #20]
 800a4be:	9304      	str	r3, [sp, #16]
 800a4c0:	9303      	str	r3, [sp, #12]
 800a4c2:	00b3      	lsls	r3, r6, #2
 800a4c4:	9308      	str	r3, [sp, #32]
 800a4c6:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800a4ca:	9902      	ldr	r1, [sp, #8]
 800a4cc:	9307      	str	r3, [sp, #28]
 800a4ce:	f108 0801 	add.w	r8, r8, #1
 800a4d2:	9b00      	ldr	r3, [sp, #0]
 800a4d4:	f8dd a004 	ldr.w	sl, [sp, #4]
 800a4d8:	ea4f 0288 	mov.w	r2, r8, lsl #2
 800a4dc:	9209      	str	r2, [sp, #36]	; 0x24
 800a4de:	eb03 0581 	add.w	r5, r3, r1, lsl #2
 800a4e2:	4699      	mov	r9, r3
        BASE temp = 0.0;
 800a4e4:	e9dd 8e04 	ldrd	r8, lr, [sp, #16]
 800a4e8:	f8dd c018 	ldr.w	ip, [sp, #24]
 800a4ec:	9f03      	ldr	r7, [sp, #12]
        for (k = 0; k < K; k++) {
 800a4ee:	9b02      	ldr	r3, [sp, #8]
        BASE temp = 0.0;
 800a4f0:	ed1f 7a19 	vldr	s14, [pc, #-100]	; 800a490 <cblas_ssyr2k+0x3f0>
        for (k = 0; k < K; k++) {
 800a4f4:	2b00      	cmp	r3, #0
 800a4f6:	dd17      	ble.n	800a528 <cblas_ssyr2k+0x488>
 800a4f8:	9b01      	ldr	r3, [sp, #4]
 800a4fa:	eb03 008e 	add.w	r0, r3, lr, lsl #2
 800a4fe:	9b00      	ldr	r3, [sp, #0]
 800a500:	4652      	mov	r2, sl
 800a502:	eb03 0188 	add.w	r1, r3, r8, lsl #2
 800a506:	464b      	mov	r3, r9
                   + B[i * ldb + k] * A[j * lda + k]);
 800a508:	ecf2 7a01 	vldmia	r2!, {s15}
 800a50c:	ecf1 5a01 	vldmia	r1!, {s11}
          temp += (A[i * lda + k] * B[j * ldb + k]
 800a510:	ecb3 6a01 	vldmia	r3!, {s12}
 800a514:	ecf0 6a01 	vldmia	r0!, {s13}
                   + B[i * ldb + k] * A[j * lda + k]);
 800a518:	ee67 7aa5 	vmul.f32	s15, s15, s11
        for (k = 0; k < K; k++) {
 800a51c:	429d      	cmp	r5, r3
                   + B[i * ldb + k] * A[j * lda + k]);
 800a51e:	eee6 7a26 	vfma.f32	s15, s12, s13
          temp += (A[i * lda + k] * B[j * ldb + k]
 800a522:	ee37 7a27 	vadd.f32	s14, s14, s15
        for (k = 0; k < K; k++) {
 800a526:	d1ef      	bne.n	800a508 <cblas_ssyr2k+0x468>
        C[i * ldc + j] += alpha * temp;
 800a528:	eddc 7a00 	vldr	s15, [ip]
 800a52c:	eee7 7a08 	vfma.f32	s15, s14, s16
      for (j = i; j < N; j++) {
 800a530:	3701      	adds	r7, #1
 800a532:	42bc      	cmp	r4, r7
 800a534:	44de      	add	lr, fp
 800a536:	44b0      	add	r8, r6
        C[i * ldc + j] += alpha * temp;
 800a538:	ecec 7a01 	vstmia	ip!, {s15}
      for (j = i; j < N; j++) {
 800a53c:	dcd7      	bgt.n	800a4ee <cblas_ssyr2k+0x44e>
    for (i = 0; i < N; i++) {
 800a53e:	9a06      	ldr	r2, [sp, #24]
 800a540:	9909      	ldr	r1, [sp, #36]	; 0x24
 800a542:	9b03      	ldr	r3, [sp, #12]
 800a544:	440a      	add	r2, r1
 800a546:	9206      	str	r2, [sp, #24]
 800a548:	9a05      	ldr	r2, [sp, #20]
 800a54a:	9907      	ldr	r1, [sp, #28]
 800a54c:	445a      	add	r2, fp
 800a54e:	9205      	str	r2, [sp, #20]
 800a550:	9a04      	ldr	r2, [sp, #16]
 800a552:	4432      	add	r2, r6
 800a554:	3301      	adds	r3, #1
 800a556:	9204      	str	r2, [sp, #16]
 800a558:	9a08      	ldr	r2, [sp, #32]
 800a55a:	9303      	str	r3, [sp, #12]
 800a55c:	429c      	cmp	r4, r3
 800a55e:	4491      	add	r9, r2
 800a560:	448a      	add	sl, r1
 800a562:	4415      	add	r5, r2
 800a564:	d1be      	bne.n	800a4e4 <cblas_ssyr2k+0x444>
 800a566:	e674      	b.n	800a252 <cblas_ssyr2k+0x1b2>
 800a568:	9902      	ldr	r1, [sp, #8]
 800a56a:	e678      	b.n	800a25e <cblas_ssyr2k+0x1be>
  } else if (beta != 1.0) {
 800a56c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a570:	eef4 8a67 	vcmp.f32	s17, s15
 800a574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a578:	d095      	beq.n	800a4a6 <cblas_ssyr2k+0x406>
      for (i = 0; i < N; i++) {
 800a57a:	2c00      	cmp	r4, #0
      trans = CblasNoTrans;
 800a57c:	bfc8      	it	gt
 800a57e:	f04f 0c6f 	movgt.w	ip, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800a582:	f73f af51 	bgt.w	800a428 <cblas_ssyr2k+0x388>
 800a586:	e78e      	b.n	800a4a6 <cblas_ssyr2k+0x406>
  if (beta == 0.0) {
 800a588:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a58c:	d01b      	beq.n	800a5c6 <cblas_ssyr2k+0x526>
  } else if (beta != 1.0) {
 800a58e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a592:	eef4 8a67 	vcmp.f32	s17, s15
 800a596:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a59a:	d023      	beq.n	800a5e4 <cblas_ssyr2k+0x544>
      for (i = 0; i < N; i++) {
 800a59c:	2c00      	cmp	r4, #0
 800a59e:	dd21      	ble.n	800a5e4 <cblas_ssyr2k+0x544>
      trans = CblasNoTrans;
 800a5a0:	f04f 0c6f 	mov.w	ip, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a5a4:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 800a5a8:	e698      	b.n	800a2dc <cblas_ssyr2k+0x23c>
  } else if (beta != 1.0) {
 800a5aa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a5ae:	eef4 8a67 	vcmp.f32	s17, s15
 800a5b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5b6:	d00e      	beq.n	800a5d6 <cblas_ssyr2k+0x536>
      for (i = 0; i < N; i++) {
 800a5b8:	2c00      	cmp	r4, #0
 800a5ba:	dd0c      	ble.n	800a5d6 <cblas_ssyr2k+0x536>
      trans = CblasTrans;
 800a5bc:	f04f 0c70 	mov.w	ip, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a5c0:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 800a5c4:	e68a      	b.n	800a2dc <cblas_ssyr2k+0x23c>
      for (i = 0; i < N; i++) {
 800a5c6:	2c00      	cmp	r4, #0
 800a5c8:	f77f ae43 	ble.w	800a252 <cblas_ssyr2k+0x1b2>
      trans = CblasNoTrans;
 800a5cc:	f04f 0c6f 	mov.w	ip, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a5d0:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 800a5d4:	e6af      	b.n	800a336 <cblas_ssyr2k+0x296>
  if (alpha == 0.0)
 800a5d6:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a5da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5de:	f47f aed1 	bne.w	800a384 <cblas_ssyr2k+0x2e4>
 800a5e2:	e636      	b.n	800a252 <cblas_ssyr2k+0x1b2>
 800a5e4:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a5e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a5ec:	f43f ae31 	beq.w	800a252 <cblas_ssyr2k+0x1b2>
    for (i = 0; i < N; i++) {
 800a5f0:	2c00      	cmp	r4, #0
 800a5f2:	f77f ae2e 	ble.w	800a252 <cblas_ssyr2k+0x1b2>
 800a5f6:	f108 0301 	add.w	r3, r8, #1
 800a5fa:	009b      	lsls	r3, r3, #2
 800a5fc:	9307      	str	r3, [sp, #28]
 800a5fe:	00b3      	lsls	r3, r6, #2
 800a600:	2200      	movs	r2, #0
 800a602:	9306      	str	r3, [sp, #24]
 800a604:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800a608:	9902      	ldr	r1, [sp, #8]
 800a60a:	9203      	str	r2, [sp, #12]
 800a60c:	9204      	str	r2, [sp, #16]
 800a60e:	9305      	str	r3, [sp, #20]
 800a610:	9a01      	ldr	r2, [sp, #4]
 800a612:	9b00      	ldr	r3, [sp, #0]
 800a614:	9402      	str	r4, [sp, #8]
 800a616:	e9cd 7808 	strd	r7, r8, [sp, #32]
 800a61a:	f107 0a04 	add.w	sl, r7, #4
 800a61e:	eb03 0581 	add.w	r5, r3, r1, lsl #2
 800a622:	4696      	mov	lr, r2
 800a624:	4689      	mov	r9, r1
 800a626:	4698      	mov	r8, r3
 800a628:	9b08      	ldr	r3, [sp, #32]
 800a62a:	9a03      	ldr	r2, [sp, #12]
        BASE temp = 0.0;
 800a62c:	2700      	movs	r7, #0
 800a62e:	46bc      	mov	ip, r7
 800a630:	eb03 0482 	add.w	r4, r3, r2, lsl #2
        for (k = 0; k < K; k++) {
 800a634:	f1b9 0f00 	cmp.w	r9, #0
        BASE temp = 0.0;
 800a638:	ed1f 7a6b 	vldr	s14, [pc, #-428]	; 800a490 <cblas_ssyr2k+0x3f0>
        for (k = 0; k < K; k++) {
 800a63c:	dd17      	ble.n	800a66e <cblas_ssyr2k+0x5ce>
 800a63e:	9b01      	ldr	r3, [sp, #4]
 800a640:	eb03 008c 	add.w	r0, r3, ip, lsl #2
 800a644:	9b00      	ldr	r3, [sp, #0]
 800a646:	4672      	mov	r2, lr
 800a648:	eb03 0187 	add.w	r1, r3, r7, lsl #2
 800a64c:	4643      	mov	r3, r8
                   + B[i * ldb + k] * A[j * lda + k]);
 800a64e:	ecf2 7a01 	vldmia	r2!, {s15}
 800a652:	ecf1 5a01 	vldmia	r1!, {s11}
          temp += (A[i * lda + k] * B[j * ldb + k]
 800a656:	ecb3 6a01 	vldmia	r3!, {s12}
 800a65a:	ecf0 6a01 	vldmia	r0!, {s13}
                   + B[i * ldb + k] * A[j * lda + k]);
 800a65e:	ee67 7aa5 	vmul.f32	s15, s15, s11
        for (k = 0; k < K; k++) {
 800a662:	429d      	cmp	r5, r3
                   + B[i * ldb + k] * A[j * lda + k]);
 800a664:	eee6 7a26 	vfma.f32	s15, s12, s13
          temp += (A[i * lda + k] * B[j * ldb + k]
 800a668:	ee37 7a27 	vadd.f32	s14, s14, s15
        for (k = 0; k < K; k++) {
 800a66c:	d1ef      	bne.n	800a64e <cblas_ssyr2k+0x5ae>
        C[i * ldc + j] += alpha * temp;
 800a66e:	edd4 7a00 	vldr	s15, [r4]
 800a672:	eee8 7a07 	vfma.f32	s15, s16, s14
 800a676:	44dc      	add	ip, fp
 800a678:	4437      	add	r7, r6
 800a67a:	ece4 7a01 	vstmia	r4!, {s15}
      for (j = 0; j <= i; j++) {
 800a67e:	45a2      	cmp	sl, r4
 800a680:	d1d8      	bne.n	800a634 <cblas_ssyr2k+0x594>
    for (i = 0; i < N; i++) {
 800a682:	9a03      	ldr	r2, [sp, #12]
 800a684:	9909      	ldr	r1, [sp, #36]	; 0x24
 800a686:	9b04      	ldr	r3, [sp, #16]
 800a688:	440a      	add	r2, r1
 800a68a:	9203      	str	r2, [sp, #12]
 800a68c:	9a07      	ldr	r2, [sp, #28]
 800a68e:	9905      	ldr	r1, [sp, #20]
 800a690:	4492      	add	sl, r2
 800a692:	9a06      	ldr	r2, [sp, #24]
 800a694:	4490      	add	r8, r2
 800a696:	4415      	add	r5, r2
 800a698:	9a02      	ldr	r2, [sp, #8]
 800a69a:	3301      	adds	r3, #1
 800a69c:	429a      	cmp	r2, r3
 800a69e:	9304      	str	r3, [sp, #16]
 800a6a0:	448e      	add	lr, r1
 800a6a2:	d1c1      	bne.n	800a628 <cblas_ssyr2k+0x588>
 800a6a4:	e5d5      	b.n	800a252 <cblas_ssyr2k+0x1b2>
      for (i = 0; i < N; i++) {
 800a6a6:	2c00      	cmp	r4, #0
 800a6a8:	f73f ad69 	bgt.w	800a17e <cblas_ssyr2k+0xde>
 800a6ac:	e579      	b.n	800a1a2 <cblas_ssyr2k+0x102>
      for (i = 0; i < N; i++) {
 800a6ae:	2c00      	cmp	r4, #0
 800a6b0:	f73f aeba 	bgt.w	800a428 <cblas_ssyr2k+0x388>
 800a6b4:	e575      	b.n	800a1a2 <cblas_ssyr2k+0x102>
 800a6b6:	bf00      	nop

0800a6b8 <cblas_ssyrk>:
void
cblas_ssyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const float alpha, const float *A, const int lda,
             const float beta, float *C, const int ldc)
{
 800a6b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a6bc:	ed2d 8b02 	vpush	{d8}
 800a6c0:	b085      	sub	sp, #20
 800a6c2:	461f      	mov	r7, r3
 800a6c4:	e9dd 5312 	ldrd	r5, r3, [sp, #72]	; 0x48

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800a6c8:	2865      	cmp	r0, #101	; 0x65
 800a6ca:	e9dd 4810 	ldrd	r4, r8, [sp, #64]	; 0x40
 800a6ce:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 800a6d2:	9301      	str	r3, [sp, #4]
 800a6d4:	4682      	mov	sl, r0
 800a6d6:	460e      	mov	r6, r1
 800a6d8:	4693      	mov	fp, r2
 800a6da:	eeb0 8a40 	vmov.f32	s16, s0
 800a6de:	eef0 8a60 	vmov.f32	s17, s1
 800a6e2:	f000 80c7 	beq.w	800a874 <cblas_ssyrk+0x1bc>
 800a6e6:	2a6f      	cmp	r2, #111	; 0x6f
 800a6e8:	d021      	beq.n	800a72e <cblas_ssyrk+0x76>
 800a6ea:	4622      	mov	r2, r4
 800a6ec:	f1a6 0379 	sub.w	r3, r6, #121	; 0x79
 800a6f0:	2b01      	cmp	r3, #1
 800a6f2:	f240 80b8 	bls.w	800a866 <cblas_ssyrk+0x1ae>
 800a6f6:	2002      	movs	r0, #2
 800a6f8:	f1ab 036f 	sub.w	r3, fp, #111	; 0x6f
 800a6fc:	b2db      	uxtb	r3, r3
 800a6fe:	2b03      	cmp	r3, #3
 800a700:	bf28      	it	cs
 800a702:	2003      	movcs	r0, #3
 800a704:	2f00      	cmp	r7, #0
 800a706:	bfb8      	it	lt
 800a708:	2004      	movlt	r0, #4
 800a70a:	2a01      	cmp	r2, #1
 800a70c:	4613      	mov	r3, r2
 800a70e:	bfb8      	it	lt
 800a710:	2301      	movlt	r3, #1
 800a712:	2c00      	cmp	r4, #0
 800a714:	f2c0 809b 	blt.w	800a84e <cblas_ssyrk+0x196>
 800a718:	42ab      	cmp	r3, r5
 800a71a:	dc10      	bgt.n	800a73e <cblas_ssyrk+0x86>
 800a71c:	2f01      	cmp	r7, #1
 800a71e:	463b      	mov	r3, r7
 800a720:	bfb8      	it	lt
 800a722:	2301      	movlt	r3, #1
 800a724:	454b      	cmp	r3, r9
 800a726:	f300 816b 	bgt.w	800aa00 <cblas_ssyrk+0x348>
 800a72a:	b1a0      	cbz	r0, 800a756 <cblas_ssyrk+0x9e>
 800a72c:	e00f      	b.n	800a74e <cblas_ssyrk+0x96>
 800a72e:	463a      	mov	r2, r7
 800a730:	f1a6 0379 	sub.w	r3, r6, #121	; 0x79
 800a734:	2b01      	cmp	r3, #1
 800a736:	f240 8096 	bls.w	800a866 <cblas_ssyrk+0x1ae>
 800a73a:	2002      	movs	r0, #2
 800a73c:	e7e2      	b.n	800a704 <cblas_ssyrk+0x4c>
 800a73e:	2f01      	cmp	r7, #1
 800a740:	4638      	mov	r0, r7
 800a742:	bfb8      	it	lt
 800a744:	2001      	movlt	r0, #1
 800a746:	4581      	cmp	r9, r0
 800a748:	bfb4      	ite	lt
 800a74a:	200b      	movlt	r0, #11
 800a74c:	2008      	movge	r0, #8
 800a74e:	4ad7      	ldr	r2, [pc, #860]	; (800aaac <cblas_ssyrk+0x3f4>)
 800a750:	49d7      	ldr	r1, [pc, #860]	; (800aab0 <cblas_ssyrk+0x3f8>)
 800a752:	f01d ffd9 	bl	8028708 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 800a756:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a75a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a75e:	d106      	bne.n	800a76e <cblas_ssyrk+0xb6>
 800a760:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a764:	eef4 8a67 	vcmp.f32	s17, s15
 800a768:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a76c:	d06a      	beq.n	800a844 <cblas_ssyrk+0x18c>
    return;

  if (Order == CblasRowMajor) {
 800a76e:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 800a772:	f000 8084 	beq.w	800a87e <cblas_ssyrk+0x1c6>
    uplo = Uplo;
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
  } else {
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;

    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a776:	f1ab 0370 	sub.w	r3, fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a77a:	2e79      	cmp	r6, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a77c:	b2db      	uxtb	r3, r3
      trans = CblasTrans;
    }
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 800a77e:	eef5 8a40 	vcmp.f32	s17, #0.0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a782:	f000 813f 	beq.w	800aa04 <cblas_ssyrk+0x34c>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800a786:	2b01      	cmp	r3, #1
 800a788:	f240 8147 	bls.w	800aa1a <cblas_ssyrk+0x362>
  if (beta == 0.0) {
 800a78c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a790:	f040 8113 	bne.w	800a9ba <cblas_ssyrk+0x302>
    if (uplo == CblasUpper) {
      for (i = 0; i < N; i++) {
 800a794:	2f00      	cmp	r7, #0
      trans = CblasTrans;
 800a796:	bfc8      	it	gt
 800a798:	2070      	movgt	r0, #112	; 0x70
      for (i = 0; i < N; i++) {
 800a79a:	dd53      	ble.n	800a844 <cblas_ssyrk+0x18c>
 800a79c:	f109 0e01 	add.w	lr, r9, #1
 800a7a0:	f8dd c004 	ldr.w	ip, [sp, #4]
        for (j = i; j < N; j++) {
          C[ldc * i + j] = 0.0;
 800a7a4:	2100      	movs	r1, #0
 800a7a6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
      for (i = 0; i < N; i++) {
 800a7aa:	2600      	movs	r6, #0
 800a7ac:	4662      	mov	r2, ip
 800a7ae:	4633      	mov	r3, r6
        for (j = i; j < N; j++) {
 800a7b0:	3301      	adds	r3, #1
 800a7b2:	429f      	cmp	r7, r3
          C[ldc * i + j] = 0.0;
 800a7b4:	f842 1b04 	str.w	r1, [r2], #4
        for (j = i; j < N; j++) {
 800a7b8:	dcfa      	bgt.n	800a7b0 <cblas_ssyrk+0xf8>
      for (i = 0; i < N; i++) {
 800a7ba:	3601      	adds	r6, #1
 800a7bc:	42b7      	cmp	r7, r6
 800a7be:	44f4      	add	ip, lr
 800a7c0:	dcf4      	bgt.n	800a7ac <cblas_ssyrk+0xf4>
        }
      }
    }
  }

  if (alpha == 0.0)
 800a7c2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a7c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a7ca:	d03b      	beq.n	800a844 <cblas_ssyrk+0x18c>
    return;

  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800a7cc:	286f      	cmp	r0, #111	; 0x6f
 800a7ce:	f000 8132 	beq.w	800aa36 <cblas_ssyrk+0x37e>
        }
        C[i * ldc + j] += alpha * temp;
      }
    }

  } else if (uplo == CblasUpper && trans == CblasTrans) {
 800a7d2:	2870      	cmp	r0, #112	; 0x70
 800a7d4:	f040 8089 	bne.w	800a8ea <cblas_ssyrk+0x232>

    for (i = 0; i < N; i++) {
 800a7d8:	2f00      	cmp	r7, #0
 800a7da:	dd33      	ble.n	800a844 <cblas_ssyrk+0x18c>
 800a7dc:	f109 0901 	add.w	r9, r9, #1
 800a7e0:	2600      	movs	r6, #0
 800a7e2:	f8dd a004 	ldr.w	sl, [sp, #4]
 800a7e6:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800a7ea:	00ad      	lsls	r5, r5, #2
 800a7ec:	46b3      	mov	fp, r6
 800a7ee:	ea4f 008b 	mov.w	r0, fp, lsl #2
      for (j = i; j < N; j++) {
        BASE temp = 0.0;
 800a7f2:	46d6      	mov	lr, sl
 800a7f4:	46dc      	mov	ip, fp
        for (k = 0; k < K; k++) {
 800a7f6:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 800a7f8:	eddf 7aaf 	vldr	s15, [pc, #700]	; 800aab8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 800a7fc:	dd0d      	ble.n	800a81a <cblas_ssyrk+0x162>
 800a7fe:	4643      	mov	r3, r8
 800a800:	2100      	movs	r1, #0
          temp += A[k * lda + i] * A[k * lda + j];
 800a802:	18f2      	adds	r2, r6, r3
 800a804:	4402      	add	r2, r0
 800a806:	edd3 6a00 	vldr	s13, [r3]
 800a80a:	ed92 7a00 	vldr	s14, [r2]
        for (k = 0; k < K; k++) {
 800a80e:	3101      	adds	r1, #1
 800a810:	428c      	cmp	r4, r1
          temp += A[k * lda + i] * A[k * lda + j];
 800a812:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 800a816:	442b      	add	r3, r5
 800a818:	d1f3      	bne.n	800a802 <cblas_ssyrk+0x14a>
        }
        C[i * ldc + j] += alpha * temp;
 800a81a:	ed9e 7a00 	vldr	s14, [lr]
 800a81e:	eea7 7a88 	vfma.f32	s14, s15, s16
      for (j = i; j < N; j++) {
 800a822:	f10c 0c01 	add.w	ip, ip, #1
 800a826:	4567      	cmp	r7, ip
 800a828:	f100 0004 	add.w	r0, r0, #4
        C[i * ldc + j] += alpha * temp;
 800a82c:	ecae 7a01 	vstmia	lr!, {s14}
      for (j = i; j < N; j++) {
 800a830:	dce1      	bgt.n	800a7f6 <cblas_ssyrk+0x13e>
    for (i = 0; i < N; i++) {
 800a832:	f10b 0b01 	add.w	fp, fp, #1
 800a836:	455f      	cmp	r7, fp
 800a838:	44ca      	add	sl, r9
 800a83a:	f108 0804 	add.w	r8, r8, #4
 800a83e:	f1a6 0604 	sub.w	r6, r6, #4
 800a842:	d1d4      	bne.n	800a7ee <cblas_ssyrk+0x136>
#define BASE float
#include "source_syrk_r.h"
#undef BASE
}
 800a844:	b005      	add	sp, #20
 800a846:	ecbd 8b02 	vpop	{d8}
 800a84a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800a84e:	42ab      	cmp	r3, r5
 800a850:	f73f af75 	bgt.w	800a73e <cblas_ssyrk+0x86>
 800a854:	2f01      	cmp	r7, #1
 800a856:	4638      	mov	r0, r7
 800a858:	bfb8      	it	lt
 800a85a:	2001      	movlt	r0, #1
 800a85c:	4581      	cmp	r9, r0
 800a85e:	bfb4      	ite	lt
 800a860:	200b      	movlt	r0, #11
 800a862:	2005      	movge	r0, #5
 800a864:	e773      	b.n	800a74e <cblas_ssyrk+0x96>
 800a866:	f1aa 0065 	sub.w	r0, sl, #101	; 0x65
 800a86a:	2801      	cmp	r0, #1
 800a86c:	bf94      	ite	ls
 800a86e:	2000      	movls	r0, #0
 800a870:	2001      	movhi	r0, #1
 800a872:	e741      	b.n	800a6f8 <cblas_ssyrk+0x40>
 800a874:	2a6f      	cmp	r2, #111	; 0x6f
 800a876:	f000 8117 	beq.w	800aaa8 <cblas_ssyrk+0x3f0>
 800a87a:	463a      	mov	r2, r7
 800a87c:	e736      	b.n	800a6ec <cblas_ssyrk+0x34>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 800a87e:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
  if (beta == 0.0) {
 800a882:	eef5 8a40 	vcmp.f32	s17, #0.0
 800a886:	bf14      	ite	ne
 800a888:	4658      	movne	r0, fp
 800a88a:	2070      	moveq	r0, #112	; 0x70
 800a88c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a890:	d035      	beq.n	800a8fe <cblas_ssyrk+0x246>
  } else if (beta != 1.0) {
 800a892:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a896:	eef4 8a67 	vcmp.f32	s17, s15
 800a89a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a89e:	d04a      	beq.n	800a936 <cblas_ssyrk+0x27e>
    if (uplo == CblasUpper) {
 800a8a0:	2e79      	cmp	r6, #121	; 0x79
 800a8a2:	f000 8187 	beq.w	800abb4 <cblas_ssyrk+0x4fc>
      for (i = 0; i < N; i++) {
 800a8a6:	2f00      	cmp	r7, #0
 800a8a8:	dd18      	ble.n	800a8dc <cblas_ssyrk+0x224>
 800a8aa:	9b01      	ldr	r3, [sp, #4]
 800a8ac:	f109 0e01 	add.w	lr, r9, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a8b0:	f04f 0c00 	mov.w	ip, #0
 800a8b4:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
      for (i = 0; i < N; i++) {
 800a8b8:	4661      	mov	r1, ip
 800a8ba:	1d1a      	adds	r2, r3, #4
 800a8bc:	469a      	mov	sl, r3
 800a8be:	eb0a 038c 	add.w	r3, sl, ip, lsl #2
          C[ldc * i + j] *= beta;
 800a8c2:	edd3 7a00 	vldr	s15, [r3]
 800a8c6:	ee67 7aa8 	vmul.f32	s15, s15, s17
 800a8ca:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j <= i; j++) {
 800a8ce:	429a      	cmp	r2, r3
 800a8d0:	d1f7      	bne.n	800a8c2 <cblas_ssyrk+0x20a>
      for (i = 0; i < N; i++) {
 800a8d2:	3101      	adds	r1, #1
 800a8d4:	428f      	cmp	r7, r1
 800a8d6:	44cc      	add	ip, r9
 800a8d8:	4472      	add	r2, lr
 800a8da:	dcf0      	bgt.n	800a8be <cblas_ssyrk+0x206>
  if (alpha == 0.0)
 800a8dc:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a8e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a8e4:	d0ae      	beq.n	800a844 <cblas_ssyrk+0x18c>
      }
    }

  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800a8e6:	2e7a      	cmp	r6, #122	; 0x7a
 800a8e8:	d02f      	beq.n	800a94a <cblas_ssyrk+0x292>
        C[i * ldc + j] += alpha * temp;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 800a8ea:	4a72      	ldr	r2, [pc, #456]	; (800aab4 <cblas_ssyrk+0x3fc>)
 800a8ec:	4970      	ldr	r1, [pc, #448]	; (800aab0 <cblas_ssyrk+0x3f8>)
 800a8ee:	2000      	movs	r0, #0
 800a8f0:	b005      	add	sp, #20
 800a8f2:	ecbd 8b02 	vpop	{d8}
 800a8f6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a8fa:	f01d bf05 	b.w	8028708 <cblas_xerbla>
    if (uplo == CblasUpper) {
 800a8fe:	2e79      	cmp	r6, #121	; 0x79
 800a900:	f000 815c 	beq.w	800abbc <cblas_ssyrk+0x504>
      for (i = 0; i < N; i++) {
 800a904:	2f00      	cmp	r7, #0
 800a906:	dde9      	ble.n	800a8dc <cblas_ssyrk+0x224>
 800a908:	9b01      	ldr	r3, [sp, #4]
 800a90a:	f109 0a01 	add.w	sl, r9, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800a90e:	f04f 0c00 	mov.w	ip, #0
          C[ldc * i + j] = 0.0;
 800a912:	2100      	movs	r1, #0
 800a914:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
      for (i = 0; i < N; i++) {
 800a918:	46e6      	mov	lr, ip
 800a91a:	1d1a      	adds	r2, r3, #4
 800a91c:	469b      	mov	fp, r3
 800a91e:	eb0b 038c 	add.w	r3, fp, ip, lsl #2
          C[ldc * i + j] = 0.0;
 800a922:	f843 1b04 	str.w	r1, [r3], #4
        for (j = 0; j <= i; j++) {
 800a926:	429a      	cmp	r2, r3
 800a928:	d1fb      	bne.n	800a922 <cblas_ssyrk+0x26a>
      for (i = 0; i < N; i++) {
 800a92a:	f10e 0e01 	add.w	lr, lr, #1
 800a92e:	4577      	cmp	r7, lr
 800a930:	44cc      	add	ip, r9
 800a932:	4452      	add	r2, sl
 800a934:	dcf3      	bgt.n	800a91e <cblas_ssyrk+0x266>
  if (alpha == 0.0)
 800a936:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800a93a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a93e:	d081      	beq.n	800a844 <cblas_ssyrk+0x18c>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800a940:	2e79      	cmp	r6, #121	; 0x79
 800a942:	f43f af43 	beq.w	800a7cc <cblas_ssyrk+0x114>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800a946:	2e7a      	cmp	r6, #122	; 0x7a
 800a948:	d1cf      	bne.n	800a8ea <cblas_ssyrk+0x232>
 800a94a:	286f      	cmp	r0, #111	; 0x6f
 800a94c:	f000 80f8 	beq.w	800ab40 <cblas_ssyrk+0x488>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 800a950:	2870      	cmp	r0, #112	; 0x70
 800a952:	d1ca      	bne.n	800a8ea <cblas_ssyrk+0x232>
    for (i = 0; i < N; i++) {
 800a954:	2f00      	cmp	r7, #0
 800a956:	f77f af75 	ble.w	800a844 <cblas_ssyrk+0x18c>
 800a95a:	2300      	movs	r3, #0
 800a95c:	00ad      	lsls	r5, r5, #2
 800a95e:	469b      	mov	fp, r3
 800a960:	469a      	mov	sl, r3
 800a962:	f04f 0e04 	mov.w	lr, #4
 800a966:	9a01      	ldr	r2, [sp, #4]
        BASE temp = 0.0;
 800a968:	2600      	movs	r6, #0
 800a96a:	eb02 0c8b 	add.w	ip, r2, fp, lsl #2
        for (k = 0; k < K; k++) {
 800a96e:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 800a970:	eddf 7a51 	vldr	s15, [pc, #324]	; 800aab8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 800a974:	dd0e      	ble.n	800a994 <cblas_ssyrk+0x2dc>
 800a976:	eba8 0203 	sub.w	r2, r8, r3
 800a97a:	2000      	movs	r0, #0
          temp += A[k * lda + i] * A[k * lda + j];
 800a97c:	18d1      	adds	r1, r2, r3
 800a97e:	4431      	add	r1, r6
 800a980:	edd2 6a00 	vldr	s13, [r2]
 800a984:	ed91 7a00 	vldr	s14, [r1]
        for (k = 0; k < K; k++) {
 800a988:	3001      	adds	r0, #1
 800a98a:	4284      	cmp	r4, r0
          temp += A[k * lda + i] * A[k * lda + j];
 800a98c:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 800a990:	442a      	add	r2, r5
 800a992:	d1f3      	bne.n	800a97c <cblas_ssyrk+0x2c4>
        C[i * ldc + j] += alpha * temp;
 800a994:	ed9c 7a00 	vldr	s14, [ip]
 800a998:	eea7 7a88 	vfma.f32	s14, s15, s16
 800a99c:	3604      	adds	r6, #4
      for (j = 0; j <= i; j++) {
 800a99e:	45b6      	cmp	lr, r6
        C[i * ldc + j] += alpha * temp;
 800a9a0:	ecac 7a01 	vstmia	ip!, {s14}
      for (j = 0; j <= i; j++) {
 800a9a4:	d1e3      	bne.n	800a96e <cblas_ssyrk+0x2b6>
    for (i = 0; i < N; i++) {
 800a9a6:	f10a 0a01 	add.w	sl, sl, #1
 800a9aa:	4557      	cmp	r7, sl
 800a9ac:	44cb      	add	fp, r9
 800a9ae:	f10e 0e04 	add.w	lr, lr, #4
 800a9b2:	f1a3 0304 	sub.w	r3, r3, #4
 800a9b6:	d1d6      	bne.n	800a966 <cblas_ssyrk+0x2ae>
 800a9b8:	e744      	b.n	800a844 <cblas_ssyrk+0x18c>
  } else if (beta != 1.0) {
 800a9ba:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800a9be:	eef4 8a67 	vcmp.f32	s17, s15
 800a9c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800a9c6:	f000 8094 	beq.w	800aaf2 <cblas_ssyrk+0x43a>
      for (i = 0; i < N; i++) {
 800a9ca:	2f00      	cmp	r7, #0
      trans = CblasTrans;
 800a9cc:	bfc8      	it	gt
 800a9ce:	2070      	movgt	r0, #112	; 0x70
      for (i = 0; i < N; i++) {
 800a9d0:	f77f af38 	ble.w	800a844 <cblas_ssyrk+0x18c>
 800a9d4:	f109 0c01 	add.w	ip, r9, #1
 800a9d8:	9e01      	ldr	r6, [sp, #4]
 800a9da:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800a9de:	2100      	movs	r1, #0
 800a9e0:	4632      	mov	r2, r6
 800a9e2:	460b      	mov	r3, r1
          C[ldc * i + j] *= beta;
 800a9e4:	edd2 7a00 	vldr	s15, [r2]
        for (j = i; j < N; j++) {
 800a9e8:	3301      	adds	r3, #1
          C[ldc * i + j] *= beta;
 800a9ea:	ee67 7aa8 	vmul.f32	s15, s15, s17
        for (j = i; j < N; j++) {
 800a9ee:	429f      	cmp	r7, r3
          C[ldc * i + j] *= beta;
 800a9f0:	ece2 7a01 	vstmia	r2!, {s15}
        for (j = i; j < N; j++) {
 800a9f4:	dcf6      	bgt.n	800a9e4 <cblas_ssyrk+0x32c>
      for (i = 0; i < N; i++) {
 800a9f6:	3101      	adds	r1, #1
 800a9f8:	428f      	cmp	r7, r1
 800a9fa:	4466      	add	r6, ip
 800a9fc:	dcf0      	bgt.n	800a9e0 <cblas_ssyrk+0x328>
 800a9fe:	e6e0      	b.n	800a7c2 <cblas_ssyrk+0x10a>
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800aa00:	200b      	movs	r0, #11
 800aa02:	e6a4      	b.n	800a74e <cblas_ssyrk+0x96>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800aa04:	2b01      	cmp	r3, #1
 800aa06:	d965      	bls.n	800aad4 <cblas_ssyrk+0x41c>
  if (beta == 0.0) {
 800aa08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aa0c:	d178      	bne.n	800ab00 <cblas_ssyrk+0x448>
      for (i = 0; i < N; i++) {
 800aa0e:	2f00      	cmp	r7, #0
 800aa10:	f340 8089 	ble.w	800ab26 <cblas_ssyrk+0x46e>
      trans = CblasTrans;
 800aa14:	2070      	movs	r0, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800aa16:	267a      	movs	r6, #122	; 0x7a
 800aa18:	e776      	b.n	800a908 <cblas_ssyrk+0x250>
  if (beta == 0.0) {
 800aa1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aa1e:	d14d      	bne.n	800aabc <cblas_ssyrk+0x404>
      for (i = 0; i < N; i++) {
 800aa20:	2f00      	cmp	r7, #0
      trans = CblasNoTrans;
 800aa22:	bfc8      	it	gt
 800aa24:	206f      	movgt	r0, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800aa26:	f73f aeb9 	bgt.w	800a79c <cblas_ssyrk+0xe4>
  if (alpha == 0.0)
 800aa2a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800aa2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aa32:	f43f af07 	beq.w	800a844 <cblas_ssyrk+0x18c>
    for (i = 0; i < N; i++) {
 800aa36:	2f00      	cmp	r7, #0
 800aa38:	f77f af04 	ble.w	800a844 <cblas_ssyrk+0x18c>
 800aa3c:	f109 0901 	add.w	r9, r9, #1
 800aa40:	ea4f 0389 	mov.w	r3, r9, lsl #2
 800aa44:	f04f 0a00 	mov.w	sl, #0
 800aa48:	9302      	str	r3, [sp, #8]
 800aa4a:	00ab      	lsls	r3, r5, #2
 800aa4c:	f8dd b004 	ldr.w	fp, [sp, #4]
 800aa50:	9301      	str	r3, [sp, #4]
 800aa52:	46d1      	mov	r9, sl
 800aa54:	eb08 0184 	add.w	r1, r8, r4, lsl #2
 800aa58:	46c6      	mov	lr, r8
        BASE temp = 0.0;
 800aa5a:	46d4      	mov	ip, sl
 800aa5c:	465e      	mov	r6, fp
 800aa5e:	4648      	mov	r0, r9
        for (k = 0; k < K; k++) {
 800aa60:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 800aa62:	eddf 7a15 	vldr	s15, [pc, #84]	; 800aab8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 800aa66:	dd0a      	ble.n	800aa7e <cblas_ssyrk+0x3c6>
 800aa68:	eb08 028c 	add.w	r2, r8, ip, lsl #2
 800aa6c:	4673      	mov	r3, lr
          temp += A[i * lda + k] * A[j * lda + k];
 800aa6e:	ecf3 6a01 	vldmia	r3!, {s13}
 800aa72:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < K; k++) {
 800aa76:	4299      	cmp	r1, r3
          temp += A[i * lda + k] * A[j * lda + k];
 800aa78:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 800aa7c:	d1f7      	bne.n	800aa6e <cblas_ssyrk+0x3b6>
        C[i * ldc + j] += alpha * temp;
 800aa7e:	ed96 7a00 	vldr	s14, [r6]
 800aa82:	eea7 7a88 	vfma.f32	s14, s15, s16
      for (j = i; j < N; j++) {
 800aa86:	3001      	adds	r0, #1
 800aa88:	4287      	cmp	r7, r0
 800aa8a:	44ac      	add	ip, r5
        C[i * ldc + j] += alpha * temp;
 800aa8c:	eca6 7a01 	vstmia	r6!, {s14}
      for (j = i; j < N; j++) {
 800aa90:	dce6      	bgt.n	800aa60 <cblas_ssyrk+0x3a8>
    for (i = 0; i < N; i++) {
 800aa92:	9b02      	ldr	r3, [sp, #8]
 800aa94:	f109 0901 	add.w	r9, r9, #1
 800aa98:	449b      	add	fp, r3
 800aa9a:	9b01      	ldr	r3, [sp, #4]
 800aa9c:	454f      	cmp	r7, r9
 800aa9e:	44aa      	add	sl, r5
 800aaa0:	449e      	add	lr, r3
 800aaa2:	4419      	add	r1, r3
 800aaa4:	d1d9      	bne.n	800aa5a <cblas_ssyrk+0x3a2>
 800aaa6:	e6cd      	b.n	800a844 <cblas_ssyrk+0x18c>
 800aaa8:	4622      	mov	r2, r4
 800aaaa:	e641      	b.n	800a730 <cblas_ssyrk+0x78>
 800aaac:	08031108 	.word	0x08031108
 800aab0:	08031270 	.word	0x08031270
 800aab4:	080311b8 	.word	0x080311b8
 800aab8:	00000000 	.word	0x00000000
  } else if (beta != 1.0) {
 800aabc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800aac0:	eef4 8a67 	vcmp.f32	s17, s15
 800aac4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aac8:	d0af      	beq.n	800aa2a <cblas_ssyrk+0x372>
      for (i = 0; i < N; i++) {
 800aaca:	2f00      	cmp	r7, #0
      trans = CblasNoTrans;
 800aacc:	bfc8      	it	gt
 800aace:	206f      	movgt	r0, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800aad0:	dc80      	bgt.n	800a9d4 <cblas_ssyrk+0x31c>
 800aad2:	e7aa      	b.n	800aa2a <cblas_ssyrk+0x372>
  if (beta == 0.0) {
 800aad4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aad8:	d01f      	beq.n	800ab1a <cblas_ssyrk+0x462>
  } else if (beta != 1.0) {
 800aada:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800aade:	eef4 8a67 	vcmp.f32	s17, s15
 800aae2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aae6:	d025      	beq.n	800ab34 <cblas_ssyrk+0x47c>
      for (i = 0; i < N; i++) {
 800aae8:	2f00      	cmp	r7, #0
 800aaea:	dd23      	ble.n	800ab34 <cblas_ssyrk+0x47c>
      trans = CblasNoTrans;
 800aaec:	206f      	movs	r0, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800aaee:	267a      	movs	r6, #122	; 0x7a
 800aaf0:	e6db      	b.n	800a8aa <cblas_ssyrk+0x1f2>
  if (alpha == 0.0)
 800aaf2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800aaf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800aafa:	f47f ae6d 	bne.w	800a7d8 <cblas_ssyrk+0x120>
 800aafe:	e6a1      	b.n	800a844 <cblas_ssyrk+0x18c>
  } else if (beta != 1.0) {
 800ab00:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800ab04:	eef4 8a67 	vcmp.f32	s17, s15
 800ab08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ab0c:	d00b      	beq.n	800ab26 <cblas_ssyrk+0x46e>
      for (i = 0; i < N; i++) {
 800ab0e:	2f00      	cmp	r7, #0
 800ab10:	f77f ae98 	ble.w	800a844 <cblas_ssyrk+0x18c>
      trans = CblasTrans;
 800ab14:	2070      	movs	r0, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ab16:	267a      	movs	r6, #122	; 0x7a
 800ab18:	e6c7      	b.n	800a8aa <cblas_ssyrk+0x1f2>
      for (i = 0; i < N; i++) {
 800ab1a:	2f00      	cmp	r7, #0
 800ab1c:	f77f ae92 	ble.w	800a844 <cblas_ssyrk+0x18c>
      trans = CblasNoTrans;
 800ab20:	206f      	movs	r0, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ab22:	267a      	movs	r6, #122	; 0x7a
 800ab24:	e6f0      	b.n	800a908 <cblas_ssyrk+0x250>
  if (alpha == 0.0)
 800ab26:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800ab2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ab2e:	f47f af11 	bne.w	800a954 <cblas_ssyrk+0x29c>
 800ab32:	e687      	b.n	800a844 <cblas_ssyrk+0x18c>
 800ab34:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800ab38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ab3c:	f43f ae82 	beq.w	800a844 <cblas_ssyrk+0x18c>
    for (i = 0; i < N; i++) {
 800ab40:	2f00      	cmp	r7, #0
 800ab42:	f77f ae7f 	ble.w	800a844 <cblas_ssyrk+0x18c>
 800ab46:	f109 0301 	add.w	r3, r9, #1
 800ab4a:	009b      	lsls	r3, r3, #2
 800ab4c:	9302      	str	r3, [sp, #8]
 800ab4e:	9b01      	ldr	r3, [sp, #4]
 800ab50:	9703      	str	r7, [sp, #12]
 800ab52:	f04f 0a00 	mov.w	sl, #0
 800ab56:	f103 0c04 	add.w	ip, r3, #4
 800ab5a:	00ab      	lsls	r3, r5, #2
 800ab5c:	46d3      	mov	fp, sl
 800ab5e:	eb08 0184 	add.w	r1, r8, r4, lsl #2
 800ab62:	46c6      	mov	lr, r8
 800ab64:	461f      	mov	r7, r3
 800ab66:	9b01      	ldr	r3, [sp, #4]
        BASE temp = 0.0;
 800ab68:	2600      	movs	r6, #0
 800ab6a:	eb03 008a 	add.w	r0, r3, sl, lsl #2
        for (k = 0; k < K; k++) {
 800ab6e:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 800ab70:	ed5f 7a2f 	vldr	s15, [pc, #-188]	; 800aab8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 800ab74:	dd0a      	ble.n	800ab8c <cblas_ssyrk+0x4d4>
 800ab76:	eb08 0286 	add.w	r2, r8, r6, lsl #2
 800ab7a:	4673      	mov	r3, lr
          temp += A[i * lda + k] * A[j * lda + k];
 800ab7c:	ecf3 6a01 	vldmia	r3!, {s13}
 800ab80:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < K; k++) {
 800ab84:	4299      	cmp	r1, r3
          temp += A[i * lda + k] * A[j * lda + k];
 800ab86:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 800ab8a:	d1f7      	bne.n	800ab7c <cblas_ssyrk+0x4c4>
        C[i * ldc + j] += alpha * temp;
 800ab8c:	ed90 7a00 	vldr	s14, [r0]
 800ab90:	eea7 7a88 	vfma.f32	s14, s15, s16
 800ab94:	442e      	add	r6, r5
 800ab96:	eca0 7a01 	vstmia	r0!, {s14}
      for (j = 0; j <= i; j++) {
 800ab9a:	4584      	cmp	ip, r0
 800ab9c:	d1e7      	bne.n	800ab6e <cblas_ssyrk+0x4b6>
    for (i = 0; i < N; i++) {
 800ab9e:	9b02      	ldr	r3, [sp, #8]
 800aba0:	449c      	add	ip, r3
 800aba2:	9b03      	ldr	r3, [sp, #12]
 800aba4:	f10b 0b01 	add.w	fp, fp, #1
 800aba8:	455b      	cmp	r3, fp
 800abaa:	44ca      	add	sl, r9
 800abac:	44be      	add	lr, r7
 800abae:	4439      	add	r1, r7
 800abb0:	d1d9      	bne.n	800ab66 <cblas_ssyrk+0x4ae>
 800abb2:	e647      	b.n	800a844 <cblas_ssyrk+0x18c>
      for (i = 0; i < N; i++) {
 800abb4:	2f00      	cmp	r7, #0
 800abb6:	f73f af0d 	bgt.w	800a9d4 <cblas_ssyrk+0x31c>
 800abba:	e602      	b.n	800a7c2 <cblas_ssyrk+0x10a>
      for (i = 0; i < N; i++) {
 800abbc:	2f00      	cmp	r7, #0
 800abbe:	f73f aded 	bgt.w	800a79c <cblas_ssyrk+0xe4>
 800abc2:	e5fe      	b.n	800a7c2 <cblas_ssyrk+0x10a>

0800abc4 <cblas_strmm>:
cblas_strmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const float alpha, const float *A, const int lda, float *B,
             const int ldb)
{
 800abc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800abc8:	ed2d 8b02 	vpush	{d8}
 800abcc:	b089      	sub	sp, #36	; 0x24
 800abce:	4699      	mov	r9, r3
 800abd0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800abd2:	9301      	str	r3, [sp, #4]
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  int side, uplo, trans;

  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800abd4:	298d      	cmp	r1, #141	; 0x8d
 800abd6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800abd8:	f89d 5050 	ldrb.w	r5, [sp, #80]	; 0x50
 800abdc:	9300      	str	r3, [sp, #0]
 800abde:	e9dd 6415 	ldrd	r6, r4, [sp, #84]	; 0x54
 800abe2:	e9dd 7b18 	ldrd	r7, fp, [sp, #96]	; 0x60
 800abe6:	4688      	mov	r8, r1
 800abe8:	4692      	mov	sl, r2
 800abea:	eeb0 8a40 	vmov.f32	s16, s0
 800abee:	d069      	beq.n	800acc4 <cblas_strmm+0x100>
 800abf0:	298e      	cmp	r1, #142	; 0x8e
 800abf2:	f000 81fe 	beq.w	800aff2 <cblas_strmm+0x42e>
 800abf6:	46a4      	mov	ip, r4
 800abf8:	2302      	movs	r3, #2
 800abfa:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 800abfe:	2a01      	cmp	r2, #1
 800ac00:	f1a9 016f 	sub.w	r1, r9, #111	; 0x6f
 800ac04:	f105 027d 	add.w	r2, r5, #125	; 0x7d
 800ac08:	bf88      	it	hi
 800ac0a:	2303      	movhi	r3, #3
 800ac0c:	b2d2      	uxtb	r2, r2
 800ac0e:	2902      	cmp	r1, #2
 800ac10:	bf88      	it	hi
 800ac12:	2304      	movhi	r3, #4
 800ac14:	2a02      	cmp	r2, #2
 800ac16:	bf28      	it	cs
 800ac18:	2305      	movcs	r3, #5
 800ac1a:	2e00      	cmp	r6, #0
 800ac1c:	bfb8      	it	lt
 800ac1e:	2306      	movlt	r3, #6
 800ac20:	2c00      	cmp	r4, #0
 800ac22:	bfb8      	it	lt
 800ac24:	2307      	movlt	r3, #7
 800ac26:	f1bc 0f01 	cmp.w	ip, #1
 800ac2a:	bfb8      	it	lt
 800ac2c:	f04f 0c01 	movlt.w	ip, #1
 800ac30:	45bc      	cmp	ip, r7
 800ac32:	dd3b      	ble.n	800acac <cblas_strmm+0xe8>
 800ac34:	2865      	cmp	r0, #101	; 0x65
 800ac36:	f000 80ab 	beq.w	800ad90 <cblas_strmm+0x1cc>
 800ac3a:	2e01      	cmp	r6, #1
 800ac3c:	9a00      	ldr	r2, [sp, #0]
 800ac3e:	4633      	mov	r3, r6
 800ac40:	bfb8      	it	lt
 800ac42:	2301      	movlt	r3, #1
 800ac44:	4293      	cmp	r3, r2
 800ac46:	bfcc      	ite	gt
 800ac48:	230c      	movgt	r3, #12
 800ac4a:	230a      	movle	r3, #10
 800ac4c:	4abc      	ldr	r2, [pc, #752]	; (800af40 <cblas_strmm+0x37c>)
 800ac4e:	49bd      	ldr	r1, [pc, #756]	; (800af44 <cblas_strmm+0x380>)
 800ac50:	4618      	mov	r0, r3
 800ac52:	f01d fd59 	bl	8028708 <cblas_xerbla>
    uplo = Uplo;
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
  } else {
    n1 = N;
    n2 = M;
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800ac56:	f1b8 0f8d 	cmp.w	r8, #141	; 0x8d
 800ac5a:	bf0c      	ite	eq
 800ac5c:	f04f 088e 	moveq.w	r8, #142	; 0x8e
 800ac60:	f04f 088d 	movne.w	r8, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ac64:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800ac68:	bf0c      	ite	eq
 800ac6a:	f04f 0a7a 	moveq.w	sl, #122	; 0x7a
 800ac6e:	f04f 0a79 	movne.w	sl, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800ac72:	f1b9 0f71 	cmp.w	r9, #113	; 0x71
 800ac76:	bf08      	it	eq
 800ac78:	f04f 0970 	moveq.w	r9, #112	; 0x70
  }

  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800ac7c:	f1b8 0f8d 	cmp.w	r8, #141	; 0x8d
 800ac80:	d028      	beq.n	800acd4 <cblas_strmm+0x110>

        B[ldb * i + j] = alpha * temp;
      }
    }

  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800ac82:	f1b8 0f8e 	cmp.w	r8, #142	; 0x8e
 800ac86:	d107      	bne.n	800ac98 <cblas_strmm+0xd4>
 800ac88:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800ac8c:	f000 809b 	beq.w	800adc6 <cblas_strmm+0x202>

        B[ldb * i + j] = alpha * temp;
      }
    }

  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800ac90:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800ac94:	f000 80e9 	beq.w	800ae6a <cblas_strmm+0x2a6>
        B[ldb * i + j] = alpha * temp;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 800ac98:	4aab      	ldr	r2, [pc, #684]	; (800af48 <cblas_strmm+0x384>)
 800ac9a:	49aa      	ldr	r1, [pc, #680]	; (800af44 <cblas_strmm+0x380>)
 800ac9c:	2000      	movs	r0, #0
#define BASE float
#include "source_trmm_r.h"
#undef BASE
}
 800ac9e:	b009      	add	sp, #36	; 0x24
 800aca0:	ecbd 8b02 	vpop	{d8}
 800aca4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800aca8:	f01d bd2e 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800acac:	2865      	cmp	r0, #101	; 0x65
 800acae:	f000 813d 	beq.w	800af2c <cblas_strmm+0x368>
 800acb2:	2e01      	cmp	r6, #1
 800acb4:	9900      	ldr	r1, [sp, #0]
 800acb6:	4632      	mov	r2, r6
 800acb8:	bfb8      	it	lt
 800acba:	2201      	movlt	r2, #1
 800acbc:	428a      	cmp	r2, r1
 800acbe:	dd7e      	ble.n	800adbe <cblas_strmm+0x1fa>
 800acc0:	230c      	movs	r3, #12
 800acc2:	e7c3      	b.n	800ac4c <cblas_strmm+0x88>
 800acc4:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800acc8:	2b01      	cmp	r3, #1
 800acca:	bf94      	ite	ls
 800accc:	2300      	movls	r3, #0
 800acce:	2301      	movhi	r3, #1
 800acd0:	46b4      	mov	ip, r6
 800acd2:	e792      	b.n	800abfa <cblas_strmm+0x36>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800acd4:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800acd8:	f000 813a 	beq.w	800af50 <cblas_strmm+0x38c>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 800acdc:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800ace0:	d1da      	bne.n	800ac98 <cblas_strmm+0xd4>
 800ace2:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800ace6:	f000 821f 	beq.w	800b128 <cblas_strmm+0x564>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 800acea:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800acee:	d1d3      	bne.n	800ac98 <cblas_strmm+0xd4>
    for (i = 0; i < n1; i++) {
 800acf0:	2c00      	cmp	r4, #0
 800acf2:	f340 8116 	ble.w	800af22 <cblas_strmm+0x35e>
 800acf6:	1c78      	adds	r0, r7, #1
 800acf8:	9a00      	ldr	r2, [sp, #0]
 800acfa:	9202      	str	r2, [sp, #8]
 800acfc:	0083      	lsls	r3, r0, #2
 800acfe:	1f18      	subs	r0, r3, #4
 800ad00:	9304      	str	r3, [sp, #16]
 800ad02:	9b01      	ldr	r3, [sp, #4]
 800ad04:	f8cd b014 	str.w	fp, [sp, #20]
 800ad08:	0097      	lsls	r7, r2, #2
 800ad0a:	2200      	movs	r2, #0
 800ad0c:	eb03 0a00 	add.w	sl, r3, r0
 800ad10:	9201      	str	r2, [sp, #4]
 800ad12:	f04f 0801 	mov.w	r8, #1
 800ad16:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800ad18:	2e00      	cmp	r6, #0
 800ad1a:	bfd8      	it	le
 800ad1c:	f8cd 800c 	strle.w	r8, [sp, #12]
 800ad20:	f340 8191 	ble.w	800b046 <cblas_strmm+0x482>
 800ad24:	9b02      	ldr	r3, [sp, #8]
 800ad26:	9a05      	ldr	r2, [sp, #20]
 800ad28:	f8cd 800c 	str.w	r8, [sp, #12]
 800ad2c:	4619      	mov	r1, r3
 800ad2e:	9b01      	ldr	r3, [sp, #4]
 800ad30:	eba1 0903 	sub.w	r9, r1, r3
 800ad34:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800ad38:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 800ad3c:	f04f 0e01 	mov.w	lr, #1
        if (nonunit) {
 800ad40:	2d83      	cmp	r5, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 800ad42:	bf05      	ittet	eq
 800ad44:	eddb 7a00 	vldreq	s15, [fp]
 800ad48:	ed9c 7a00 	vldreq	s14, [ip]
          temp = B[i * ldb + j];
 800ad4c:	eddc 7a00 	vldrne	s15, [ip]
          temp = A[i * lda + i] * B[i * ldb + j];
 800ad50:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = i + 1; k < n1; k++) {
 800ad54:	4544      	cmp	r4, r8
 800ad56:	f340 8189 	ble.w	800b06c <cblas_strmm+0x4a8>
 800ad5a:	eb09 010c 	add.w	r1, r9, ip
 800ad5e:	4652      	mov	r2, sl
 800ad60:	4643      	mov	r3, r8
          temp += A[lda * k + i] * B[k * ldb + j];
 800ad62:	edd2 6a00 	vldr	s13, [r2]
 800ad66:	ed91 7a00 	vldr	s14, [r1]
        for (k = i + 1; k < n1; k++) {
 800ad6a:	3301      	adds	r3, #1
 800ad6c:	429c      	cmp	r4, r3
          temp += A[lda * k + i] * B[k * ldb + j];
 800ad6e:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = i + 1; k < n1; k++) {
 800ad72:	4402      	add	r2, r0
 800ad74:	4439      	add	r1, r7
 800ad76:	d1f4      	bne.n	800ad62 <cblas_strmm+0x19e>
        B[ldb * i + j] = alpha * temp;
 800ad78:	ee68 7a27 	vmul.f32	s15, s16, s15
      for (j = 0; j < n2; j++) {
 800ad7c:	4576      	cmp	r6, lr
        B[ldb * i + j] = alpha * temp;
 800ad7e:	edcc 7a00 	vstr	s15, [ip]
      for (j = 0; j < n2; j++) {
 800ad82:	f340 8160 	ble.w	800b046 <cblas_strmm+0x482>
 800ad86:	f10e 0e01 	add.w	lr, lr, #1
 800ad8a:	f10c 0c04 	add.w	ip, ip, #4
 800ad8e:	e7d7      	b.n	800ad40 <cblas_strmm+0x17c>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800ad90:	2c01      	cmp	r4, #1
 800ad92:	9a00      	ldr	r2, [sp, #0]
 800ad94:	4623      	mov	r3, r4
 800ad96:	bfb8      	it	lt
 800ad98:	2301      	movlt	r3, #1
 800ad9a:	4293      	cmp	r3, r2
 800ad9c:	bfcc      	ite	gt
 800ad9e:	230c      	movgt	r3, #12
 800ada0:	230a      	movle	r3, #10
 800ada2:	4a67      	ldr	r2, [pc, #412]	; (800af40 <cblas_strmm+0x37c>)
 800ada4:	4967      	ldr	r1, [pc, #412]	; (800af44 <cblas_strmm+0x380>)
 800ada6:	4618      	mov	r0, r3
 800ada8:	f01d fcae 	bl	8028708 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800adac:	f1b9 0f71 	cmp.w	r9, #113	; 0x71
 800adb0:	4623      	mov	r3, r4
 800adb2:	d101      	bne.n	800adb8 <cblas_strmm+0x1f4>
 800adb4:	f04f 0970 	mov.w	r9, #112	; 0x70
 800adb8:	4634      	mov	r4, r6
 800adba:	461e      	mov	r6, r3
 800adbc:	e75e      	b.n	800ac7c <cblas_strmm+0xb8>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800adbe:	2b00      	cmp	r3, #0
 800adc0:	f43f af49 	beq.w	800ac56 <cblas_strmm+0x92>
 800adc4:	e742      	b.n	800ac4c <cblas_strmm+0x88>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800adc6:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800adca:	f000 8207 	beq.w	800b1dc <cblas_strmm+0x618>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 800adce:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800add2:	f47f af61 	bne.w	800ac98 <cblas_strmm+0xd4>
    for (i = 0; i < n1; i++) {
 800add6:	2c00      	cmp	r4, #0
 800add8:	f340 80a3 	ble.w	800af22 <cblas_strmm+0x35e>
 800addc:	00b1      	lsls	r1, r6, #2
 800adde:	9107      	str	r1, [sp, #28]
 800ade0:	9901      	ldr	r1, [sp, #4]
 800ade2:	f8cd b00c 	str.w	fp, [sp, #12]
 800ade6:	00b8      	lsls	r0, r7, #2
 800ade8:	2300      	movs	r3, #0
 800adea:	f107 0a01 	add.w	sl, r7, #1
 800adee:	1d02      	adds	r2, r0, #4
 800adf0:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 800adf4:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800adf8:	9302      	str	r3, [sp, #8]
 800adfa:	9106      	str	r1, [sp, #24]
 800adfc:	4691      	mov	r9, r2
 800adfe:	9405      	str	r4, [sp, #20]
 800ae00:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800ae02:	2e00      	cmp	r6, #0
 800ae04:	f340 8115 	ble.w	800b032 <cblas_strmm+0x46e>
 800ae08:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800ae0c:	9304      	str	r3, [sp, #16]
 800ae0e:	9b03      	ldr	r3, [sp, #12]
 800ae10:	9906      	ldr	r1, [sp, #24]
 800ae12:	eb03 048b 	add.w	r4, r3, fp, lsl #2
 800ae16:	9b01      	ldr	r3, [sp, #4]
 800ae18:	2700      	movs	r7, #0
 800ae1a:	f103 0c04 	add.w	ip, r3, #4
 800ae1e:	4698      	mov	r8, r3
        if (nonunit) {
 800ae20:	2d83      	cmp	r5, #131	; 0x83
          temp = A[j * lda + j] * B[i * ldb + j];
 800ae22:	bf06      	itte	eq
 800ae24:	edd8 7a00 	vldreq	s15, [r8]
 800ae28:	ed94 7a00 	vldreq	s14, [r4]
          temp = B[i * ldb + j];
 800ae2c:	edd4 7a00 	vldrne	s15, [r4]
        for (k = j + 1; k < n2; k++) {
 800ae30:	f107 0701 	add.w	r7, r7, #1
          temp = A[j * lda + j] * B[i * ldb + j];
 800ae34:	bf08      	it	eq
 800ae36:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = j + 1; k < n2; k++) {
 800ae3a:	42be      	cmp	r6, r7
 800ae3c:	f000 80f0 	beq.w	800b020 <cblas_strmm+0x45c>
 800ae40:	f104 0e04 	add.w	lr, r4, #4
 800ae44:	4672      	mov	r2, lr
 800ae46:	4663      	mov	r3, ip
          temp += A[lda * j + k] * B[i * ldb + k];
 800ae48:	ecf3 6a01 	vldmia	r3!, {s13}
 800ae4c:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = j + 1; k < n2; k++) {
 800ae50:	4299      	cmp	r1, r3
          temp += A[lda * j + k] * B[i * ldb + k];
 800ae52:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = j + 1; k < n2; k++) {
 800ae56:	d1f7      	bne.n	800ae48 <cblas_strmm+0x284>
        B[ldb * i + j] = alpha * temp;
 800ae58:	ee68 7a27 	vmul.f32	s15, s16, s15
 800ae5c:	44d4      	add	ip, sl
 800ae5e:	edc4 7a00 	vstr	s15, [r4]
      for (j = 0; j < n2; j++) {
 800ae62:	4401      	add	r1, r0
 800ae64:	44c8      	add	r8, r9
        B[ldb * i + j] = alpha * temp;
 800ae66:	4674      	mov	r4, lr
 800ae68:	e7da      	b.n	800ae20 <cblas_strmm+0x25c>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800ae6a:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800ae6e:	f000 8216 	beq.w	800b29e <cblas_strmm+0x6da>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 800ae72:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800ae76:	f47f af0f 	bne.w	800ac98 <cblas_strmm+0xd4>
    for (i = 0; i < n1; i++) {
 800ae7a:	2c00      	cmp	r4, #0
 800ae7c:	dd51      	ble.n	800af22 <cblas_strmm+0x35e>
 800ae7e:	9b01      	ldr	r3, [sp, #4]
 800ae80:	9800      	ldr	r0, [sp, #0]
 800ae82:	1e72      	subs	r2, r6, #1
 800ae84:	1c79      	adds	r1, r7, #1
 800ae86:	fb07 6e02 	mla	lr, r7, r2, r6
 800ae8a:	0089      	lsls	r1, r1, #2
 800ae8c:	f1a3 0c04 	sub.w	ip, r3, #4
 800ae90:	ebc7 7a87 	rsb	sl, r7, r7, lsl #30
 800ae94:	43fb      	mvns	r3, r7
 800ae96:	9f01      	ldr	r7, [sp, #4]
 800ae98:	f1a1 0904 	sub.w	r9, r1, #4
 800ae9c:	0080      	lsls	r0, r0, #2
 800ae9e:	9000      	str	r0, [sp, #0]
 800aea0:	fb02 7009 	mla	r0, r2, r9, r7
 800aea4:	fb02 7201 	mla	r2, r2, r1, r7
 800aea8:	9201      	str	r2, [sp, #4]
 800aeaa:	ea4f 0983 	mov.w	r9, r3, lsl #2
 800aeae:	eb0c 028e 	add.w	r2, ip, lr, lsl #2
 800aeb2:	00b3      	lsls	r3, r6, #2
 800aeb4:	46d8      	mov	r8, fp
 800aeb6:	9002      	str	r0, [sp, #8]
 800aeb8:	9203      	str	r2, [sp, #12]
 800aeba:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800aebe:	9304      	str	r3, [sp, #16]
 800aec0:	f04f 0b00 	mov.w	fp, #0
      for (j = n2; j > 0 && j--;) {
 800aec4:	2e00      	cmp	r6, #0
 800aec6:	dd26      	ble.n	800af16 <cblas_strmm+0x352>
 800aec8:	9b04      	ldr	r3, [sp, #16]
 800aeca:	f8dd e004 	ldr.w	lr, [sp, #4]
 800aece:	e9dd c102 	ldrd	ip, r1, [sp, #8]
 800aed2:	eb08 0003 	add.w	r0, r8, r3
 800aed6:	4637      	mov	r7, r6
        for (k = 0; k < j; k++) {
 800aed8:	3f01      	subs	r7, #1
        BASE temp = 0.0;
 800aeda:	eddf 7a1c 	vldr	s15, [pc, #112]	; 800af4c <cblas_strmm+0x388>
        for (k = 0; k < j; k++) {
 800aede:	d009      	beq.n	800aef4 <cblas_strmm+0x330>
 800aee0:	4642      	mov	r2, r8
 800aee2:	4663      	mov	r3, ip
          temp += A[lda * j + k] * B[i * ldb + k];
 800aee4:	ecf3 6a01 	vldmia	r3!, {s13}
 800aee8:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < j; k++) {
 800aeec:	428b      	cmp	r3, r1
          temp += A[lda * j + k] * B[i * ldb + k];
 800aeee:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < j; k++) {
 800aef2:	d1f7      	bne.n	800aee4 <cblas_strmm+0x320>
        if (nonunit) {
 800aef4:	2d83      	cmp	r5, #131	; 0x83
 800aef6:	f000 8084 	beq.w	800b002 <cblas_strmm+0x43e>
          temp += B[i * ldb + j];
 800aefa:	ed10 7a01 	vldr	s14, [r0, #-4]
 800aefe:	ee77 7a87 	vadd.f32	s15, s15, s14
 800af02:	3804      	subs	r0, #4
        B[ldb * i + j] = alpha * temp;
 800af04:	ee67 7a88 	vmul.f32	s15, s15, s16
 800af08:	44ce      	add	lr, r9
 800af0a:	edc0 7a00 	vstr	s15, [r0]
      for (j = n2; j > 0 && j--;) {
 800af0e:	44d4      	add	ip, sl
 800af10:	4449      	add	r1, r9
 800af12:	2f00      	cmp	r7, #0
 800af14:	d1e0      	bne.n	800aed8 <cblas_strmm+0x314>
    for (i = 0; i < n1; i++) {
 800af16:	9b00      	ldr	r3, [sp, #0]
 800af18:	f10b 0b01 	add.w	fp, fp, #1
 800af1c:	455c      	cmp	r4, fp
 800af1e:	4498      	add	r8, r3
 800af20:	d1d0      	bne.n	800aec4 <cblas_strmm+0x300>
 800af22:	b009      	add	sp, #36	; 0x24
 800af24:	ecbd 8b02 	vpop	{d8}
 800af28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800af2c:	2c01      	cmp	r4, #1
 800af2e:	9900      	ldr	r1, [sp, #0]
 800af30:	4622      	mov	r2, r4
 800af32:	bfb8      	it	lt
 800af34:	2201      	movlt	r2, #1
 800af36:	428a      	cmp	r2, r1
 800af38:	dd57      	ble.n	800afea <cblas_strmm+0x426>
 800af3a:	230c      	movs	r3, #12
 800af3c:	e731      	b.n	800ada2 <cblas_strmm+0x1de>
 800af3e:	bf00      	nop
 800af40:	08031108 	.word	0x08031108
 800af44:	08031280 	.word	0x08031280
 800af48:	080311b8 	.word	0x080311b8
 800af4c:	00000000 	.word	0x00000000
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800af50:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800af54:	f000 8092 	beq.w	800b07c <cblas_strmm+0x4b8>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 800af58:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800af5c:	f47f ae9c 	bne.w	800ac98 <cblas_strmm+0xd4>
    for (i = n1; i > 0 && i--;) {
 800af60:	2c00      	cmp	r4, #0
 800af62:	ddde      	ble.n	800af22 <cblas_strmm+0x35e>
 800af64:	43f8      	mvns	r0, r7
 800af66:	9a00      	ldr	r2, [sp, #0]
 800af68:	0080      	lsls	r0, r0, #2
 800af6a:	1c7b      	adds	r3, r7, #1
 800af6c:	9000      	str	r0, [sp, #0]
 800af6e:	9801      	ldr	r0, [sp, #4]
 800af70:	009b      	lsls	r3, r3, #2
 800af72:	1e61      	subs	r1, r4, #1
 800af74:	ea4f 0c82 	mov.w	ip, r2, lsl #2
 800af78:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 800af7c:	fb01 0903 	mla	r9, r1, r3, r0
 800af80:	1f1f      	subs	r7, r3, #4
 800af82:	0093      	lsls	r3, r2, #2
 800af84:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800af88:	9301      	str	r3, [sp, #4]
 800af8a:	fb01 ba0c 	mla	sl, r1, ip, fp
      for (j = 0; j < n2; j++) {
 800af8e:	2e00      	cmp	r6, #0
 800af90:	dd22      	ble.n	800afd8 <cblas_strmm+0x414>
 800af92:	46d0      	mov	r8, sl
 800af94:	f04f 0e00 	mov.w	lr, #0
        BASE temp = 0.0;
 800af98:	ed5f 7a14 	vldr	s15, [pc, #-80]	; 800af4c <cblas_strmm+0x388>
        for (k = 0; k < i; k++) {
 800af9c:	b171      	cbz	r1, 800afbc <cblas_strmm+0x3f8>
 800af9e:	eb0b 008e 	add.w	r0, fp, lr, lsl #2
 800afa2:	4622      	mov	r2, r4
 800afa4:	2300      	movs	r3, #0
          temp += A[lda * k + i] * B[k * ldb + j];
 800afa6:	ed52 6a01 	vldr	s13, [r2, #-4]
 800afaa:	ed90 7a00 	vldr	s14, [r0]
        for (k = 0; k < i; k++) {
 800afae:	3301      	adds	r3, #1
 800afb0:	4299      	cmp	r1, r3
          temp += A[lda * k + i] * B[k * ldb + j];
 800afb2:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < i; k++) {
 800afb6:	443a      	add	r2, r7
 800afb8:	4460      	add	r0, ip
 800afba:	d1f4      	bne.n	800afa6 <cblas_strmm+0x3e2>
        if (nonunit) {
 800afbc:	2d83      	cmp	r5, #131	; 0x83
 800afbe:	d028      	beq.n	800b012 <cblas_strmm+0x44e>
          temp += B[i * ldb + j];
 800afc0:	ed98 7a00 	vldr	s14, [r8]
 800afc4:	ee77 7a87 	vadd.f32	s15, s15, s14
        B[ldb * i + j] = alpha * temp;
 800afc8:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800afcc:	f10e 0e01 	add.w	lr, lr, #1
 800afd0:	4576      	cmp	r6, lr
        B[ldb * i + j] = alpha * temp;
 800afd2:	ece8 7a01 	vstmia	r8!, {s15}
      for (j = 0; j < n2; j++) {
 800afd6:	d1df      	bne.n	800af98 <cblas_strmm+0x3d4>
    for (i = n1; i > 0 && i--;) {
 800afd8:	9b00      	ldr	r3, [sp, #0]
 800afda:	4499      	add	r9, r3
 800afdc:	9b01      	ldr	r3, [sp, #4]
 800afde:	3c04      	subs	r4, #4
 800afe0:	449a      	add	sl, r3
 800afe2:	2900      	cmp	r1, #0
 800afe4:	d09d      	beq.n	800af22 <cblas_strmm+0x35e>
 800afe6:	3901      	subs	r1, #1
 800afe8:	e7d1      	b.n	800af8e <cblas_strmm+0x3ca>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800afea:	2b00      	cmp	r3, #0
 800afec:	f43f aede 	beq.w	800adac <cblas_strmm+0x1e8>
 800aff0:	e6d7      	b.n	800ada2 <cblas_strmm+0x1de>
 800aff2:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800aff6:	2b01      	cmp	r3, #1
 800aff8:	bf94      	ite	ls
 800affa:	2300      	movls	r3, #0
 800affc:	2301      	movhi	r3, #1
 800affe:	46a4      	mov	ip, r4
 800b000:	e5fb      	b.n	800abfa <cblas_strmm+0x36>
          temp += A[j * lda + j] * B[i * ldb + j];
 800b002:	ed10 7a01 	vldr	s14, [r0, #-4]
 800b006:	edde 6a00 	vldr	s13, [lr]
 800b00a:	3804      	subs	r0, #4
 800b00c:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b010:	e778      	b.n	800af04 <cblas_strmm+0x340>
          temp += A[i * lda + i] * B[i * ldb + j];
 800b012:	edd9 6a00 	vldr	s13, [r9]
 800b016:	ed98 7a00 	vldr	s14, [r8]
 800b01a:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b01e:	e7d3      	b.n	800afc8 <cblas_strmm+0x404>
        B[ldb * i + j] = alpha * temp;
 800b020:	9a07      	ldr	r2, [sp, #28]
 800b022:	9b04      	ldr	r3, [sp, #16]
 800b024:	4413      	add	r3, r2
 800b026:	9a03      	ldr	r2, [sp, #12]
 800b028:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b02c:	4413      	add	r3, r2
 800b02e:	ed43 7a01 	vstr	s15, [r3, #-4]
    for (i = 0; i < n1; i++) {
 800b032:	9a00      	ldr	r2, [sp, #0]
 800b034:	9b02      	ldr	r3, [sp, #8]
 800b036:	4493      	add	fp, r2
 800b038:	9a05      	ldr	r2, [sp, #20]
 800b03a:	3301      	adds	r3, #1
 800b03c:	429a      	cmp	r2, r3
 800b03e:	9302      	str	r3, [sp, #8]
 800b040:	f47f aedf 	bne.w	800ae02 <cblas_strmm+0x23e>
 800b044:	e76d      	b.n	800af22 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800b046:	9b04      	ldr	r3, [sp, #16]
 800b048:	9902      	ldr	r1, [sp, #8]
 800b04a:	9a00      	ldr	r2, [sp, #0]
 800b04c:	468c      	mov	ip, r1
 800b04e:	449a      	add	sl, r3
 800b050:	9901      	ldr	r1, [sp, #4]
 800b052:	449b      	add	fp, r3
 800b054:	9b03      	ldr	r3, [sp, #12]
 800b056:	4494      	add	ip, r2
 800b058:	4411      	add	r1, r2
 800b05a:	429c      	cmp	r4, r3
 800b05c:	f108 0801 	add.w	r8, r8, #1
 800b060:	f8cd c008 	str.w	ip, [sp, #8]
 800b064:	9101      	str	r1, [sp, #4]
 800b066:	f73f ae57 	bgt.w	800ad18 <cblas_strmm+0x154>
 800b06a:	e75a      	b.n	800af22 <cblas_strmm+0x35e>
        B[ldb * i + j] = alpha * temp;
 800b06c:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800b070:	4576      	cmp	r6, lr
        B[ldb * i + j] = alpha * temp;
 800b072:	edcc 7a00 	vstr	s15, [ip]
      for (j = 0; j < n2; j++) {
 800b076:	f73f ae86 	bgt.w	800ad86 <cblas_strmm+0x1c2>
 800b07a:	e752      	b.n	800af22 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800b07c:	2c00      	cmp	r4, #0
 800b07e:	f77f af50 	ble.w	800af22 <cblas_strmm+0x35e>
 800b082:	1c78      	adds	r0, r7, #1
 800b084:	0083      	lsls	r3, r0, #2
 800b086:	9303      	str	r3, [sp, #12]
 800b088:	3b04      	subs	r3, #4
 800b08a:	9302      	str	r3, [sp, #8]
 800b08c:	9b01      	ldr	r3, [sp, #4]
 800b08e:	f103 0e04 	add.w	lr, r3, #4
 800b092:	eb03 0184 	add.w	r1, r3, r4, lsl #2
 800b096:	9b00      	ldr	r3, [sp, #0]
 800b098:	9301      	str	r3, [sp, #4]
 800b09a:	0098      	lsls	r0, r3, #2
 800b09c:	f04f 0a00 	mov.w	sl, #0
 800b0a0:	f04f 0801 	mov.w	r8, #1
      for (j = 0; j < n2; j++) {
 800b0a4:	2e00      	cmp	r6, #0
 800b0a6:	f340 80e9 	ble.w	800b27c <cblas_strmm+0x6b8>
 800b0aa:	9b01      	ldr	r3, [sp, #4]
 800b0ac:	eba3 090a 	sub.w	r9, r3, sl
 800b0b0:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800b0b4:	eb0b 078a 	add.w	r7, fp, sl, lsl #2
 800b0b8:	f04f 0c01 	mov.w	ip, #1
        if (nonunit) {
 800b0bc:	2d83      	cmp	r5, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 800b0be:	bf05      	ittet	eq
 800b0c0:	ed5e 7a01 	vldreq	s15, [lr, #-4]
 800b0c4:	ed97 7a00 	vldreq	s14, [r7]
          temp = B[i * ldb + j];
 800b0c8:	edd7 7a00 	vldrne	s15, [r7]
          temp = A[i * lda + i] * B[i * ldb + j];
 800b0cc:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = i + 1; k < n1; k++) {
 800b0d0:	4544      	cmp	r4, r8
 800b0d2:	dd15      	ble.n	800b100 <cblas_strmm+0x53c>
 800b0d4:	eb09 0207 	add.w	r2, r9, r7
 800b0d8:	4673      	mov	r3, lr
          temp += A[lda * i + k] * B[k * ldb + j];
 800b0da:	ecf3 6a01 	vldmia	r3!, {s13}
 800b0de:	ed92 7a00 	vldr	s14, [r2]
        for (k = i + 1; k < n1; k++) {
 800b0e2:	4299      	cmp	r1, r3
          temp += A[lda * i + k] * B[k * ldb + j];
 800b0e4:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = i + 1; k < n1; k++) {
 800b0e8:	4402      	add	r2, r0
 800b0ea:	d1f6      	bne.n	800b0da <cblas_strmm+0x516>
        B[ldb * i + j] = alpha * temp;
 800b0ec:	ee68 7a27 	vmul.f32	s15, s16, s15
      for (j = 0; j < n2; j++) {
 800b0f0:	4566      	cmp	r6, ip
        B[ldb * i + j] = alpha * temp;
 800b0f2:	edc7 7a00 	vstr	s15, [r7]
      for (j = 0; j < n2; j++) {
 800b0f6:	dd0a      	ble.n	800b10e <cblas_strmm+0x54a>
 800b0f8:	f10c 0c01 	add.w	ip, ip, #1
 800b0fc:	3704      	adds	r7, #4
 800b0fe:	e7dd      	b.n	800b0bc <cblas_strmm+0x4f8>
        B[ldb * i + j] = alpha * temp;
 800b100:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800b104:	45b4      	cmp	ip, r6
        B[ldb * i + j] = alpha * temp;
 800b106:	edc7 7a00 	vstr	s15, [r7]
      for (j = 0; j < n2; j++) {
 800b10a:	dbf5      	blt.n	800b0f8 <cblas_strmm+0x534>
 800b10c:	e709      	b.n	800af22 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800b10e:	9b03      	ldr	r3, [sp, #12]
 800b110:	9a01      	ldr	r2, [sp, #4]
 800b112:	449e      	add	lr, r3
 800b114:	9b02      	ldr	r3, [sp, #8]
 800b116:	4419      	add	r1, r3
 800b118:	9b00      	ldr	r3, [sp, #0]
 800b11a:	4617      	mov	r7, r2
 800b11c:	441f      	add	r7, r3
 800b11e:	f108 0801 	add.w	r8, r8, #1
 800b122:	9701      	str	r7, [sp, #4]
 800b124:	449a      	add	sl, r3
 800b126:	e7bd      	b.n	800b0a4 <cblas_strmm+0x4e0>
    for (i = n1; i > 0 && i--;) {
 800b128:	2c00      	cmp	r4, #0
 800b12a:	f77f aefa 	ble.w	800af22 <cblas_strmm+0x35e>
 800b12e:	1e61      	subs	r1, r4, #1
 800b130:	1c7a      	adds	r2, r7, #1
 800b132:	fb07 4301 	mla	r3, r7, r1, r4
 800b136:	0092      	lsls	r2, r2, #2
 800b138:	ea6f 0807 	mvn.w	r8, r7
 800b13c:	ebc7 7a87 	rsb	sl, r7, r7, lsl #30
 800b140:	9f01      	ldr	r7, [sp, #4]
 800b142:	9800      	ldr	r0, [sp, #0]
 800b144:	9302      	str	r3, [sp, #8]
 800b146:	f1a2 0e04 	sub.w	lr, r2, #4
 800b14a:	9b01      	ldr	r3, [sp, #4]
 800b14c:	fb01 7e0e 	mla	lr, r1, lr, r7
 800b150:	fb01 7702 	mla	r7, r1, r2, r7
 800b154:	9a02      	ldr	r2, [sp, #8]
 800b156:	3b04      	subs	r3, #4
 800b158:	ebc0 7980 	rsb	r9, r0, r0, lsl #30
 800b15c:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 800b160:	ea4f 0389 	mov.w	r3, r9, lsl #2
 800b164:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800b168:	9300      	str	r3, [sp, #0]
 800b16a:	ea4f 038a 	mov.w	r3, sl, lsl #2
 800b16e:	fb01 b90c 	mla	r9, r1, ip, fp
 800b172:	ea4f 0888 	mov.w	r8, r8, lsl #2
 800b176:	9301      	str	r3, [sp, #4]
      for (j = 0; j < n2; j++) {
 800b178:	2e00      	cmp	r6, #0
 800b17a:	dd1d      	ble.n	800b1b8 <cblas_strmm+0x5f4>
 800b17c:	46ca      	mov	sl, r9
 800b17e:	2000      	movs	r0, #0
        BASE temp = 0.0;
 800b180:	ed5f 7a8e 	vldr	s15, [pc, #-568]	; 800af4c <cblas_strmm+0x388>
        for (k = 0; k < i; k++) {
 800b184:	b159      	cbz	r1, 800b19e <cblas_strmm+0x5da>
 800b186:	eb0b 0280 	add.w	r2, fp, r0, lsl #2
 800b18a:	4673      	mov	r3, lr
          temp += A[lda * i + k] * B[k * ldb + j];
 800b18c:	ecf3 6a01 	vldmia	r3!, {s13}
 800b190:	ed92 7a00 	vldr	s14, [r2]
        for (k = 0; k < i; k++) {
 800b194:	429c      	cmp	r4, r3
          temp += A[lda * i + k] * B[k * ldb + j];
 800b196:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < i; k++) {
 800b19a:	4462      	add	r2, ip
 800b19c:	d1f6      	bne.n	800b18c <cblas_strmm+0x5c8>
        if (nonunit) {
 800b19e:	2d83      	cmp	r5, #131	; 0x83
 800b1a0:	d015      	beq.n	800b1ce <cblas_strmm+0x60a>
          temp += B[i * ldb + j];
 800b1a2:	ed9a 7a00 	vldr	s14, [sl]
 800b1a6:	ee77 7a87 	vadd.f32	s15, s15, s14
        B[ldb * i + j] = alpha * temp;
 800b1aa:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800b1ae:	3001      	adds	r0, #1
 800b1b0:	4286      	cmp	r6, r0
        B[ldb * i + j] = alpha * temp;
 800b1b2:	ecea 7a01 	vstmia	sl!, {s15}
      for (j = 0; j < n2; j++) {
 800b1b6:	d1e3      	bne.n	800b180 <cblas_strmm+0x5bc>
    for (i = n1; i > 0 && i--;) {
 800b1b8:	9b00      	ldr	r3, [sp, #0]
 800b1ba:	4499      	add	r9, r3
 800b1bc:	9b01      	ldr	r3, [sp, #4]
 800b1be:	4447      	add	r7, r8
 800b1c0:	449e      	add	lr, r3
 800b1c2:	4444      	add	r4, r8
 800b1c4:	2900      	cmp	r1, #0
 800b1c6:	f43f aeac 	beq.w	800af22 <cblas_strmm+0x35e>
 800b1ca:	3901      	subs	r1, #1
 800b1cc:	e7d4      	b.n	800b178 <cblas_strmm+0x5b4>
          temp += A[i * lda + i] * B[i * ldb + j];
 800b1ce:	edd7 6a00 	vldr	s13, [r7]
 800b1d2:	ed9a 7a00 	vldr	s14, [sl]
 800b1d6:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b1da:	e7e6      	b.n	800b1aa <cblas_strmm+0x5e6>
    for (i = 0; i < n1; i++) {
 800b1dc:	2c00      	cmp	r4, #0
 800b1de:	f77f aea0 	ble.w	800af22 <cblas_strmm+0x35e>
 800b1e2:	43f8      	mvns	r0, r7
 800b1e4:	1c7b      	adds	r3, r7, #1
 800b1e6:	9f00      	ldr	r7, [sp, #0]
 800b1e8:	ea4f 0987 	mov.w	r9, r7, lsl #2
 800b1ec:	9f01      	ldr	r7, [sp, #4]
 800b1ee:	009b      	lsls	r3, r3, #2
 800b1f0:	1e71      	subs	r1, r6, #1
 800b1f2:	00b2      	lsls	r2, r6, #2
 800b1f4:	46de      	mov	lr, fp
 800b1f6:	fb03 7101 	mla	r1, r3, r1, r7
 800b1fa:	f1a2 0b04 	sub.w	fp, r2, #4
 800b1fe:	ea4f 0880 	mov.w	r8, r0, lsl #2
 800b202:	f8cd b004 	str.w	fp, [sp, #4]
 800b206:	9100      	str	r1, [sp, #0]
 800b208:	1f18      	subs	r0, r3, #4
 800b20a:	f04f 0a00 	mov.w	sl, #0
 800b20e:	46bb      	mov	fp, r7
      for (j = n2; j > 0 && j--;) {
 800b210:	2e00      	cmp	r6, #0
 800b212:	dd26      	ble.n	800b262 <cblas_strmm+0x69e>
 800b214:	9b01      	ldr	r3, [sp, #4]
 800b216:	f8dd c000 	ldr.w	ip, [sp]
 800b21a:	eb03 010e 	add.w	r1, r3, lr
 800b21e:	4633      	mov	r3, r6
        for (k = 0; k < j; k++) {
 800b220:	1e5a      	subs	r2, r3, #1
 800b222:	2a00      	cmp	r2, #0
        BASE temp = 0.0;
 800b224:	ed5f 7ab7 	vldr	s15, [pc, #-732]	; 800af4c <cblas_strmm+0x388>
        for (k = 0; k < j; k++) {
 800b228:	dd0b      	ble.n	800b242 <cblas_strmm+0x67e>
 800b22a:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 800b22e:	4677      	mov	r7, lr
          temp += A[lda * k + j] * B[i * ldb + k];
 800b230:	ecb7 7a01 	vldmia	r7!, {s14}
 800b234:	ed53 6a01 	vldr	s13, [r3, #-4]
        for (k = 0; k < j; k++) {
 800b238:	428f      	cmp	r7, r1
          temp += A[lda * k + j] * B[i * ldb + k];
 800b23a:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < j; k++) {
 800b23e:	4403      	add	r3, r0
 800b240:	d1f6      	bne.n	800b230 <cblas_strmm+0x66c>
        if (nonunit) {
 800b242:	2d83      	cmp	r5, #131	; 0x83
 800b244:	d013      	beq.n	800b26e <cblas_strmm+0x6aa>
          temp += B[i * ldb + j];
 800b246:	ed91 7a00 	vldr	s14, [r1]
 800b24a:	ee77 7a87 	vadd.f32	s15, s15, s14
        B[ldb * i + j] = alpha * temp;
 800b24e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b252:	460b      	mov	r3, r1
 800b254:	edc3 7a00 	vstr	s15, [r3]
      for (j = n2; j > 0 && j--;) {
 800b258:	44c4      	add	ip, r8
        B[ldb * i + j] = alpha * temp;
 800b25a:	3904      	subs	r1, #4
      for (j = n2; j > 0 && j--;) {
 800b25c:	4613      	mov	r3, r2
 800b25e:	2a00      	cmp	r2, #0
 800b260:	d1de      	bne.n	800b220 <cblas_strmm+0x65c>
    for (i = 0; i < n1; i++) {
 800b262:	f10a 0a01 	add.w	sl, sl, #1
 800b266:	4554      	cmp	r4, sl
 800b268:	44ce      	add	lr, r9
 800b26a:	d1d1      	bne.n	800b210 <cblas_strmm+0x64c>
 800b26c:	e659      	b.n	800af22 <cblas_strmm+0x35e>
          temp += A[j * lda + j] * B[i * ldb + j];
 800b26e:	eddc 6a00 	vldr	s13, [ip]
 800b272:	ed91 7a00 	vldr	s14, [r1]
 800b276:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b27a:	e7e8      	b.n	800b24e <cblas_strmm+0x68a>
    for (i = 0; i < n1; i++) {
 800b27c:	9a03      	ldr	r2, [sp, #12]
 800b27e:	9f01      	ldr	r7, [sp, #4]
 800b280:	4496      	add	lr, r2
 800b282:	9a02      	ldr	r2, [sp, #8]
 800b284:	4411      	add	r1, r2
 800b286:	9a00      	ldr	r2, [sp, #0]
 800b288:	46bc      	mov	ip, r7
 800b28a:	4494      	add	ip, r2
 800b28c:	4544      	cmp	r4, r8
 800b28e:	f8cd c004 	str.w	ip, [sp, #4]
 800b292:	4492      	add	sl, r2
 800b294:	f108 0801 	add.w	r8, r8, #1
 800b298:	f73f af04 	bgt.w	800b0a4 <cblas_strmm+0x4e0>
 800b29c:	e641      	b.n	800af22 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800b29e:	2c00      	cmp	r4, #0
 800b2a0:	f77f ae3f 	ble.w	800af22 <cblas_strmm+0x35e>
 800b2a4:	9a01      	ldr	r2, [sp, #4]
 800b2a6:	9900      	ldr	r1, [sp, #0]
 800b2a8:	f8cd b018 	str.w	fp, [sp, #24]
 800b2ac:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 800b2b0:	00b8      	lsls	r0, r7, #2
 800b2b2:	2300      	movs	r3, #0
 800b2b4:	0089      	lsls	r1, r1, #2
 800b2b6:	f107 0a01 	add.w	sl, r7, #1
 800b2ba:	9205      	str	r2, [sp, #20]
 800b2bc:	1d02      	adds	r2, r0, #4
 800b2be:	9103      	str	r1, [sp, #12]
 800b2c0:	9302      	str	r3, [sp, #8]
 800b2c2:	eb0b 0186 	add.w	r1, fp, r6, lsl #2
 800b2c6:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800b2ca:	4691      	mov	r9, r2
 800b2cc:	9404      	str	r4, [sp, #16]
 800b2ce:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800b2d0:	2e00      	cmp	r6, #0
 800b2d2:	dd30      	ble.n	800b336 <cblas_strmm+0x772>
 800b2d4:	9b06      	ldr	r3, [sp, #24]
 800b2d6:	9a02      	ldr	r2, [sp, #8]
 800b2d8:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800b2dc:	f8dd c014 	ldr.w	ip, [sp, #20]
 800b2e0:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 800b2e4:	2700      	movs	r7, #0
        if (nonunit) {
 800b2e6:	2d83      	cmp	r5, #131	; 0x83
          temp = A[j * lda + j] * B[i * ldb + j];
 800b2e8:	bf06      	itte	eq
 800b2ea:	edd8 7a00 	vldreq	s15, [r8]
 800b2ee:	ed94 7a00 	vldreq	s14, [r4]
          temp = B[i * ldb + j];
 800b2f2:	edd4 7a00 	vldrne	s15, [r4]
        for (k = j + 1; k < n2; k++) {
 800b2f6:	f107 0701 	add.w	r7, r7, #1
          temp = A[j * lda + j] * B[i * ldb + j];
 800b2fa:	bf08      	it	eq
 800b2fc:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = j + 1; k < n2; k++) {
 800b300:	42be      	cmp	r6, r7
 800b302:	d014      	beq.n	800b32e <cblas_strmm+0x76a>
 800b304:	f104 0e04 	add.w	lr, r4, #4
 800b308:	4672      	mov	r2, lr
 800b30a:	4663      	mov	r3, ip
          temp += A[lda * k + j] * B[i * ldb + k];
 800b30c:	ecb2 7a01 	vldmia	r2!, {s14}
 800b310:	edd3 6a00 	vldr	s13, [r3]
        for (k = j + 1; k < n2; k++) {
 800b314:	428a      	cmp	r2, r1
          temp += A[lda * k + j] * B[i * ldb + k];
 800b316:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = j + 1; k < n2; k++) {
 800b31a:	4403      	add	r3, r0
 800b31c:	d1f6      	bne.n	800b30c <cblas_strmm+0x748>
        B[ldb * i + j] = alpha * temp;
 800b31e:	ee68 7a27 	vmul.f32	s15, s16, s15
 800b322:	44d4      	add	ip, sl
 800b324:	edc4 7a00 	vstr	s15, [r4]
      for (j = 0; j < n2; j++) {
 800b328:	44c8      	add	r8, r9
        B[ldb * i + j] = alpha * temp;
 800b32a:	4674      	mov	r4, lr
 800b32c:	e7db      	b.n	800b2e6 <cblas_strmm+0x722>
 800b32e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b332:	ed41 7a01 	vstr	s15, [r1, #-4]
    for (i = 0; i < n1; i++) {
 800b336:	9b03      	ldr	r3, [sp, #12]
 800b338:	9a00      	ldr	r2, [sp, #0]
 800b33a:	4419      	add	r1, r3
 800b33c:	9b02      	ldr	r3, [sp, #8]
 800b33e:	4413      	add	r3, r2
 800b340:	9302      	str	r3, [sp, #8]
 800b342:	9b04      	ldr	r3, [sp, #16]
 800b344:	f10b 0b01 	add.w	fp, fp, #1
 800b348:	455b      	cmp	r3, fp
 800b34a:	d1c1      	bne.n	800b2d0 <cblas_strmm+0x70c>
 800b34c:	e5e9      	b.n	800af22 <cblas_strmm+0x35e>
 800b34e:	bf00      	nop

0800b350 <cblas_strmv>:
void
cblas_strmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const float *A, const int lda, float *X,
             const int incX)
{
 800b350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b354:	b083      	sub	sp, #12

{
  INDEX i, j;

  const int nonunit = (Diag == CblasNonUnit);
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 800b356:	2a71      	cmp	r2, #113	; 0x71
 800b358:	e9dd 570c 	ldrd	r5, r7, [sp, #48]	; 0x30
 800b35c:	e9dd b80e 	ldrd	fp, r8, [sp, #56]	; 0x38
 800b360:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800b362:	4681      	mov	r9, r0
 800b364:	468a      	mov	sl, r1
 800b366:	461e      	mov	r6, r3
 800b368:	f000 809d 	beq.w	800b4a6 <cblas_strmv+0x156>

  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b36c:	3979      	subs	r1, #121	; 0x79
 800b36e:	2901      	cmp	r1, #1
 800b370:	4613      	mov	r3, r2
 800b372:	d92f      	bls.n	800b3d4 <cblas_strmv+0x84>
 800b374:	2002      	movs	r0, #2
 800b376:	3a6f      	subs	r2, #111	; 0x6f
 800b378:	2a02      	cmp	r2, #2
 800b37a:	bf88      	it	hi
 800b37c:	2003      	movhi	r0, #3
 800b37e:	f106 027d 	add.w	r2, r6, #125	; 0x7d
 800b382:	b2d2      	uxtb	r2, r2
 800b384:	2a01      	cmp	r2, #1
 800b386:	d933      	bls.n	800b3f0 <cblas_strmv+0xa0>
 800b388:	2d00      	cmp	r5, #0
 800b38a:	db29      	blt.n	800b3e0 <cblas_strmv+0x90>
 800b38c:	2d01      	cmp	r5, #1
 800b38e:	462a      	mov	r2, r5
 800b390:	bfb8      	it	lt
 800b392:	2201      	movlt	r2, #1
 800b394:	455a      	cmp	r2, fp
 800b396:	f340 808d 	ble.w	800b4b4 <cblas_strmv+0x164>
 800b39a:	2c00      	cmp	r4, #0
 800b39c:	bf0c      	ite	eq
 800b39e:	2009      	moveq	r0, #9
 800b3a0:	2007      	movne	r0, #7
 800b3a2:	4ad1      	ldr	r2, [pc, #836]	; (800b6e8 <cblas_strmv+0x398>)
 800b3a4:	49d1      	ldr	r1, [pc, #836]	; (800b6ec <cblas_strmv+0x39c>)
 800b3a6:	9301      	str	r3, [sp, #4]
 800b3a8:	f01d f9ae 	bl	8028708 <cblas_xerbla>
 800b3ac:	9b01      	ldr	r3, [sp, #4]

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800b3ae:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 800b3b2:	d02b      	beq.n	800b40c <cblas_strmv+0xbc>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800b3b4:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 800b3b8:	d104      	bne.n	800b3c4 <cblas_strmv+0x74>
 800b3ba:	2b70      	cmp	r3, #112	; 0x70
 800b3bc:	f000 80f5 	beq.w	800b5aa <cblas_strmv+0x25a>
        X[ix] += temp;
      }
      ix -= incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 800b3c0:	2b6f      	cmp	r3, #111	; 0x6f
 800b3c2:	d07c      	beq.n	800b4be <cblas_strmv+0x16e>
        X[ix] += temp;
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 800b3c4:	4aca      	ldr	r2, [pc, #808]	; (800b6f0 <cblas_strmv+0x3a0>)
 800b3c6:	49c9      	ldr	r1, [pc, #804]	; (800b6ec <cblas_strmv+0x39c>)
 800b3c8:	2000      	movs	r0, #0
#define BASE float
#include "source_trmv_r.h"
#undef BASE
}
 800b3ca:	b003      	add	sp, #12
 800b3cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b3d0:	f01d b99a 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b3d4:	3865      	subs	r0, #101	; 0x65
 800b3d6:	2801      	cmp	r0, #1
 800b3d8:	bf94      	ite	ls
 800b3da:	2000      	movls	r0, #0
 800b3dc:	2001      	movhi	r0, #1
 800b3de:	e7ca      	b.n	800b376 <cblas_strmv+0x26>
 800b3e0:	f1bb 0f00 	cmp.w	fp, #0
 800b3e4:	ddd9      	ble.n	800b39a <cblas_strmv+0x4a>
 800b3e6:	2c00      	cmp	r4, #0
 800b3e8:	bf0c      	ite	eq
 800b3ea:	2009      	moveq	r0, #9
 800b3ec:	2005      	movne	r0, #5
 800b3ee:	e7d8      	b.n	800b3a2 <cblas_strmv+0x52>
 800b3f0:	2d00      	cmp	r5, #0
 800b3f2:	dbf5      	blt.n	800b3e0 <cblas_strmv+0x90>
 800b3f4:	2d01      	cmp	r5, #1
 800b3f6:	462a      	mov	r2, r5
 800b3f8:	bfb8      	it	lt
 800b3fa:	2201      	movlt	r2, #1
 800b3fc:	455a      	cmp	r2, fp
 800b3fe:	dccc      	bgt.n	800b39a <cblas_strmv+0x4a>
 800b400:	2c00      	cmp	r4, #0
 800b402:	f000 816f 	beq.w	800b6e4 <cblas_strmv+0x394>
 800b406:	2800      	cmp	r0, #0
 800b408:	d0d1      	beq.n	800b3ae <cblas_strmv+0x5e>
 800b40a:	e7ca      	b.n	800b3a2 <cblas_strmv+0x52>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800b40c:	2b6f      	cmp	r3, #111	; 0x6f
 800b40e:	d071      	beq.n	800b4f4 <cblas_strmv+0x1a4>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 800b410:	2b70      	cmp	r3, #112	; 0x70
 800b412:	d1d7      	bne.n	800b3c4 <cblas_strmv+0x74>
 800b414:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b418:	f000 8116 	beq.w	800b648 <cblas_strmv+0x2f8>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 800b41c:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b420:	d1d0      	bne.n	800b3c4 <cblas_strmv+0x74>
    INDEX ix = OFFSET(N, incX);
 800b422:	2c00      	cmp	r4, #0
 800b424:	bfda      	itte	le
 800b426:	f1c5 0901 	rsble	r9, r5, #1
 800b42a:	fb09 f904 	mulle.w	r9, r9, r4
 800b42e:	f04f 0900 	movgt.w	r9, #0
    for (i = 0; i < N; i++) {
 800b432:	2d00      	cmp	r5, #0
 800b434:	dd34      	ble.n	800b4a0 <cblas_strmv+0x150>
 800b436:	f10b 0a01 	add.w	sl, fp, #1
 800b43a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800b43e:	ebcb 7b8b 	rsb	fp, fp, fp, lsl #30
 800b442:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800b446:	f1aa 0c04 	sub.w	ip, sl, #4
 800b44a:	eb09 0b04 	add.w	fp, r9, r4
 800b44e:	9301      	str	r3, [sp, #4]
 800b450:	4467      	add	r7, ip
 800b452:	eb08 0989 	add.w	r9, r8, r9, lsl #2
 800b456:	00a0      	lsls	r0, r4, #2
 800b458:	f04f 0e00 	mov.w	lr, #0
      const INDEX j_min = i + 1;
 800b45c:	f10e 0e01 	add.w	lr, lr, #1
      for (j = j_min; j < j_max; j++) {
 800b460:	4575      	cmp	r5, lr
      BASE temp = 0.0;
 800b462:	eddf 7aa4 	vldr	s15, [pc, #656]	; 800b6f4 <cblas_strmv+0x3a4>
      for (j = j_min; j < j_max; j++) {
 800b466:	dd0e      	ble.n	800b486 <cblas_strmv+0x136>
 800b468:	eb08 018b 	add.w	r1, r8, fp, lsl #2
 800b46c:	463a      	mov	r2, r7
 800b46e:	4673      	mov	r3, lr
        temp += X[jx] * A[lda * j + i];
 800b470:	edd1 6a00 	vldr	s13, [r1]
 800b474:	ed92 7a00 	vldr	s14, [r2]
      for (j = j_min; j < j_max; j++) {
 800b478:	3301      	adds	r3, #1
 800b47a:	429d      	cmp	r5, r3
        temp += X[jx] * A[lda * j + i];
 800b47c:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800b480:	4401      	add	r1, r0
 800b482:	4462      	add	r2, ip
 800b484:	d1f4      	bne.n	800b470 <cblas_strmv+0x120>
      if (nonunit) {
 800b486:	2e83      	cmp	r6, #131	; 0x83
 800b488:	d022      	beq.n	800b4d0 <cblas_strmv+0x180>
        X[ix] += temp;
 800b48a:	ed99 7a00 	vldr	s14, [r9]
 800b48e:	ee77 7a27 	vadd.f32	s15, s14, s15
 800b492:	edc9 7a00 	vstr	s15, [r9]
    for (i = 0; i < N; i++) {
 800b496:	4575      	cmp	r5, lr
 800b498:	44a3      	add	fp, r4
 800b49a:	4481      	add	r9, r0
 800b49c:	4457      	add	r7, sl
 800b49e:	d1dd      	bne.n	800b45c <cblas_strmv+0x10c>
 800b4a0:	b003      	add	sp, #12
 800b4a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b4a6:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
 800b4aa:	2b01      	cmp	r3, #1
 800b4ac:	d91b      	bls.n	800b4e6 <cblas_strmv+0x196>
 800b4ae:	2370      	movs	r3, #112	; 0x70
 800b4b0:	2002      	movs	r0, #2
 800b4b2:	e764      	b.n	800b37e <cblas_strmv+0x2e>
 800b4b4:	2c00      	cmp	r4, #0
 800b4b6:	bf0c      	ite	eq
 800b4b8:	2009      	moveq	r0, #9
 800b4ba:	2004      	movne	r0, #4
 800b4bc:	e771      	b.n	800b3a2 <cblas_strmv+0x52>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 800b4be:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b4c2:	f000 80c1 	beq.w	800b648 <cblas_strmv+0x2f8>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 800b4c6:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b4ca:	f47f af7b 	bne.w	800b3c4 <cblas_strmv+0x74>
 800b4ce:	e7a8      	b.n	800b422 <cblas_strmv+0xd2>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800b4d0:	9b01      	ldr	r3, [sp, #4]
 800b4d2:	edd9 6a00 	vldr	s13, [r9]
 800b4d6:	18fb      	adds	r3, r7, r3
 800b4d8:	ed93 7a00 	vldr	s14, [r3]
 800b4dc:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b4e0:	edc9 7a00 	vstr	s15, [r9]
 800b4e4:	e7d7      	b.n	800b496 <cblas_strmv+0x146>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b4e6:	3865      	subs	r0, #101	; 0x65
 800b4e8:	2801      	cmp	r0, #1
 800b4ea:	bf94      	ite	ls
 800b4ec:	2000      	movls	r0, #0
 800b4ee:	2001      	movhi	r0, #1
 800b4f0:	2370      	movs	r3, #112	; 0x70
 800b4f2:	e744      	b.n	800b37e <cblas_strmv+0x2e>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800b4f4:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b4f8:	d05f      	beq.n	800b5ba <cblas_strmv+0x26a>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 800b4fa:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b4fe:	f47f af61 	bne.w	800b3c4 <cblas_strmv+0x74>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800b502:	2c00      	cmp	r4, #0
 800b504:	bfd8      	it	le
 800b506:	f1c4 0e00 	rsble	lr, r4, #0
 800b50a:	f105 30ff 	add.w	r0, r5, #4294967295
 800b50e:	bfcc      	ite	gt
 800b510:	f04f 0e00 	movgt.w	lr, #0
 800b514:	fb00 fe0e 	mulle.w	lr, r0, lr
    for (i = N; i > 0 && i--;) {
 800b518:	2d00      	cmp	r5, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800b51a:	fb00 ec04 	mla	ip, r0, r4, lr
    for (i = N; i > 0 && i--;) {
 800b51e:	ddbf      	ble.n	800b4a0 <cblas_strmv+0x150>
 800b520:	f10b 0301 	add.w	r3, fp, #1
 800b524:	009b      	lsls	r3, r3, #2
 800b526:	fb00 550b 	mla	r5, r0, fp, r5
 800b52a:	1f39      	subs	r1, r7, #4
 800b52c:	ebc4 7984 	rsb	r9, r4, r4, lsl #30
 800b530:	1f1a      	subs	r2, r3, #4
 800b532:	eb08 0c8c 	add.w	ip, r8, ip, lsl #2
 800b536:	eb08 088e 	add.w	r8, r8, lr, lsl #2
 800b53a:	ea6f 0e0b 	mvn.w	lr, fp
 800b53e:	ebcb 7b8b 	rsb	fp, fp, fp, lsl #30
 800b542:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 800b546:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800b54a:	fb00 7502 	mla	r5, r0, r2, r7
 800b54e:	00a4      	lsls	r4, r4, #2
 800b550:	fb00 7703 	mla	r7, r0, r3, r7
 800b554:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800b558:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
      for (j = j_min; j < j_max; j++) {
 800b55c:	eddf 7a65 	vldr	s15, [pc, #404]	; 800b6f4 <cblas_strmv+0x3a4>
 800b560:	b150      	cbz	r0, 800b578 <cblas_strmv+0x228>
 800b562:	462a      	mov	r2, r5
 800b564:	4643      	mov	r3, r8
        temp += X[jx] * A[lda * i + j];
 800b566:	ecb2 7a01 	vldmia	r2!, {s14}
 800b56a:	edd3 6a00 	vldr	s13, [r3]
      for (j = j_min; j < j_max; j++) {
 800b56e:	428a      	cmp	r2, r1
        temp += X[jx] * A[lda * i + j];
 800b570:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800b574:	4423      	add	r3, r4
 800b576:	d1f6      	bne.n	800b566 <cblas_strmv+0x216>
      if (nonunit) {
 800b578:	2e83      	cmp	r6, #131	; 0x83
 800b57a:	d00d      	beq.n	800b598 <cblas_strmv+0x248>
        X[ix] += temp;
 800b57c:	ed9c 7a00 	vldr	s14, [ip]
 800b580:	ee77 7a27 	vadd.f32	s15, s14, s15
 800b584:	edcc 7a00 	vstr	s15, [ip]
    for (i = N; i > 0 && i--;) {
 800b588:	44cc      	add	ip, r9
 800b58a:	4477      	add	r7, lr
 800b58c:	4455      	add	r5, sl
 800b58e:	4471      	add	r1, lr
 800b590:	2800      	cmp	r0, #0
 800b592:	d085      	beq.n	800b4a0 <cblas_strmv+0x150>
 800b594:	3801      	subs	r0, #1
 800b596:	e7e1      	b.n	800b55c <cblas_strmv+0x20c>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800b598:	eddc 6a00 	vldr	s13, [ip]
 800b59c:	ed97 7a00 	vldr	s14, [r7]
 800b5a0:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b5a4:	edcc 7a00 	vstr	s15, [ip]
 800b5a8:	e7ee      	b.n	800b588 <cblas_strmv+0x238>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800b5aa:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b5ae:	d004      	beq.n	800b5ba <cblas_strmv+0x26a>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 800b5b0:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b5b4:	f47f af06 	bne.w	800b3c4 <cblas_strmv+0x74>
 800b5b8:	e7a3      	b.n	800b502 <cblas_strmv+0x1b2>
    INDEX ix = OFFSET(N, incX);
 800b5ba:	2c00      	cmp	r4, #0
 800b5bc:	bfda      	itte	le
 800b5be:	f1c5 0901 	rsble	r9, r5, #1
 800b5c2:	fb09 f904 	mulle.w	r9, r9, r4
 800b5c6:	f04f 0900 	movgt.w	r9, #0
    for (i = 0; i < N; i++) {
 800b5ca:	2d00      	cmp	r5, #0
 800b5cc:	f77f af68 	ble.w	800b4a0 <cblas_strmv+0x150>
 800b5d0:	f10b 0301 	add.w	r3, fp, #1
 800b5d4:	009b      	lsls	r3, r3, #2
 800b5d6:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800b5da:	f107 0a04 	add.w	sl, r7, #4
 800b5de:	eb07 0085 	add.w	r0, r7, r5, lsl #2
 800b5e2:	f1a3 0b04 	sub.w	fp, r3, #4
 800b5e6:	00a7      	lsls	r7, r4, #2
 800b5e8:	9201      	str	r2, [sp, #4]
 800b5ea:	f04f 0e00 	mov.w	lr, #0
      const INDEX j_min = i + 1;
 800b5ee:	f10e 0e01 	add.w	lr, lr, #1
      for (j = j_min; j < j_max; j++) {
 800b5f2:	4575      	cmp	r5, lr
      BASE temp = 0.0;
 800b5f4:	eddf 7a3f 	vldr	s15, [pc, #252]	; 800b6f4 <cblas_strmv+0x3a4>
 800b5f8:	ea4f 0c89 	mov.w	ip, r9, lsl #2
      for (j = j_min; j < j_max; j++) {
 800b5fc:	dd0c      	ble.n	800b618 <cblas_strmv+0x2c8>
 800b5fe:	9a01      	ldr	r2, [sp, #4]
 800b600:	eb02 0189 	add.w	r1, r2, r9, lsl #2
 800b604:	4652      	mov	r2, sl
        temp += X[jx] * A[lda * i + j];
 800b606:	ecb2 7a01 	vldmia	r2!, {s14}
 800b60a:	edd1 6a00 	vldr	s13, [r1]
      for (j = j_min; j < j_max; j++) {
 800b60e:	4290      	cmp	r0, r2
        temp += X[jx] * A[lda * i + j];
 800b610:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800b614:	4439      	add	r1, r7
 800b616:	d1f6      	bne.n	800b606 <cblas_strmv+0x2b6>
      if (nonunit) {
 800b618:	2e83      	cmp	r6, #131	; 0x83
 800b61a:	44c4      	add	ip, r8
 800b61c:	d00b      	beq.n	800b636 <cblas_strmv+0x2e6>
        X[ix] += temp;
 800b61e:	ed9c 7a00 	vldr	s14, [ip]
 800b622:	ee77 7a27 	vadd.f32	s15, s14, s15
 800b626:	edcc 7a00 	vstr	s15, [ip]
    for (i = 0; i < N; i++) {
 800b62a:	4575      	cmp	r5, lr
      ix += incX;
 800b62c:	44a1      	add	r9, r4
    for (i = 0; i < N; i++) {
 800b62e:	449a      	add	sl, r3
 800b630:	4458      	add	r0, fp
 800b632:	d1dc      	bne.n	800b5ee <cblas_strmv+0x29e>
 800b634:	e734      	b.n	800b4a0 <cblas_strmv+0x150>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800b636:	eddc 6a00 	vldr	s13, [ip]
 800b63a:	ed1a 7a01 	vldr	s14, [sl, #-4]
 800b63e:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b642:	edcc 7a00 	vstr	s15, [ip]
 800b646:	e7f0      	b.n	800b62a <cblas_strmv+0x2da>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800b648:	2c00      	cmp	r4, #0
 800b64a:	bfd8      	it	le
 800b64c:	4263      	negle	r3, r4
 800b64e:	f105 30ff 	add.w	r0, r5, #4294967295
 800b652:	bfcc      	ite	gt
 800b654:	2300      	movgt	r3, #0
 800b656:	4343      	mulle	r3, r0
    for (i = N; i > 0 && i--;) {
 800b658:	2d00      	cmp	r5, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800b65a:	fb00 3e04 	mla	lr, r0, r4, r3
    for (i = N; i > 0 && i--;) {
 800b65e:	f77f af1f 	ble.w	800b4a0 <cblas_strmv+0x150>
 800b662:	f10b 0c01 	add.w	ip, fp, #1
 800b666:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800b66a:	ebc4 7984 	rsb	r9, r4, r4, lsl #30
 800b66e:	ea6f 0a0b 	mvn.w	sl, fp
 800b672:	eb08 0e8e 	add.w	lr, r8, lr, lsl #2
 800b676:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 800b67a:	eb08 0883 	add.w	r8, r8, r3, lsl #2
 800b67e:	fb0c 7700 	mla	r7, ip, r0, r7
 800b682:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800b686:	f1ac 0c04 	sub.w	ip, ip, #4
 800b68a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800b68e:	00a4      	lsls	r4, r4, #2
      for (j = j_min; j < j_max; j++) {
 800b690:	eddf 7a18 	vldr	s15, [pc, #96]	; 800b6f4 <cblas_strmv+0x3a4>
 800b694:	b168      	cbz	r0, 800b6b2 <cblas_strmv+0x362>
 800b696:	4629      	mov	r1, r5
 800b698:	4642      	mov	r2, r8
 800b69a:	2300      	movs	r3, #0
        temp += X[jx] * A[lda * j + i];
 800b69c:	edd2 6a00 	vldr	s13, [r2]
 800b6a0:	ed11 7a01 	vldr	s14, [r1, #-4]
      for (j = j_min; j < j_max; j++) {
 800b6a4:	3301      	adds	r3, #1
 800b6a6:	4298      	cmp	r0, r3
        temp += X[jx] * A[lda * j + i];
 800b6a8:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800b6ac:	4422      	add	r2, r4
 800b6ae:	4461      	add	r1, ip
 800b6b0:	d1f4      	bne.n	800b69c <cblas_strmv+0x34c>
      if (nonunit) {
 800b6b2:	2e83      	cmp	r6, #131	; 0x83
 800b6b4:	d00d      	beq.n	800b6d2 <cblas_strmv+0x382>
        X[ix] += temp;
 800b6b6:	ed9e 7a00 	vldr	s14, [lr]
 800b6ba:	ee77 7a27 	vadd.f32	s15, s14, s15
 800b6be:	edce 7a00 	vstr	s15, [lr]
    for (i = N; i > 0 && i--;) {
 800b6c2:	44ce      	add	lr, r9
 800b6c4:	4457      	add	r7, sl
 800b6c6:	3d04      	subs	r5, #4
 800b6c8:	2800      	cmp	r0, #0
 800b6ca:	f43f aee9 	beq.w	800b4a0 <cblas_strmv+0x150>
 800b6ce:	3801      	subs	r0, #1
 800b6d0:	e7de      	b.n	800b690 <cblas_strmv+0x340>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800b6d2:	edde 6a00 	vldr	s13, [lr]
 800b6d6:	ed97 7a00 	vldr	s14, [r7]
 800b6da:	eee6 7a87 	vfma.f32	s15, s13, s14
 800b6de:	edce 7a00 	vstr	s15, [lr]
 800b6e2:	e7ee      	b.n	800b6c2 <cblas_strmv+0x372>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b6e4:	2009      	movs	r0, #9
 800b6e6:	e65c      	b.n	800b3a2 <cblas_strmv+0x52>
 800b6e8:	08031108 	.word	0x08031108
 800b6ec:	08031290 	.word	0x08031290
 800b6f0:	080311b8 	.word	0x080311b8
 800b6f4:	00000000 	.word	0x00000000

0800b6f8 <cblas_strsm>:
cblas_strsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const float alpha, const float *A, const int lda, float *B,
             const int ldb)
{
 800b6f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b6fc:	ed2d 8b02 	vpush	{d8}
 800b700:	b089      	sub	sp, #36	; 0x24
 800b702:	469a      	mov	sl, r3
 800b704:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 800b708:	9301      	str	r3, [sp, #4]
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  int side, uplo, trans;

  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800b70a:	298d      	cmp	r1, #141	; 0x8d
 800b70c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800b70e:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
 800b712:	9302      	str	r3, [sp, #8]
 800b714:	e9dd 4515 	ldrd	r4, r5, [sp, #84]	; 0x54
 800b718:	e9dd 7818 	ldrd	r7, r8, [sp, #96]	; 0x60
 800b71c:	460e      	mov	r6, r1
 800b71e:	4693      	mov	fp, r2
 800b720:	eeb0 8a40 	vmov.f32	s16, s0
 800b724:	d064      	beq.n	800b7f0 <cblas_strsm+0xf8>
 800b726:	298e      	cmp	r1, #142	; 0x8e
 800b728:	f000 825e 	beq.w	800bbe8 <cblas_strsm+0x4f0>
 800b72c:	46ac      	mov	ip, r5
 800b72e:	2302      	movs	r3, #2
 800b730:	f1ab 0279 	sub.w	r2, fp, #121	; 0x79
 800b734:	2a01      	cmp	r2, #1
 800b736:	9a01      	ldr	r2, [sp, #4]
 800b738:	f1aa 016f 	sub.w	r1, sl, #111	; 0x6f
 800b73c:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 800b740:	bf88      	it	hi
 800b742:	2303      	movhi	r3, #3
 800b744:	b2d2      	uxtb	r2, r2
 800b746:	2902      	cmp	r1, #2
 800b748:	bf88      	it	hi
 800b74a:	2304      	movhi	r3, #4
 800b74c:	2a02      	cmp	r2, #2
 800b74e:	bf28      	it	cs
 800b750:	2305      	movcs	r3, #5
 800b752:	2c00      	cmp	r4, #0
 800b754:	bfb8      	it	lt
 800b756:	2306      	movlt	r3, #6
 800b758:	2d00      	cmp	r5, #0
 800b75a:	bfb8      	it	lt
 800b75c:	2307      	movlt	r3, #7
 800b75e:	f1bc 0f01 	cmp.w	ip, #1
 800b762:	bfb8      	it	lt
 800b764:	f04f 0c01 	movlt.w	ip, #1
 800b768:	45bc      	cmp	ip, r7
 800b76a:	dd35      	ble.n	800b7d8 <cblas_strsm+0xe0>
 800b76c:	2865      	cmp	r0, #101	; 0x65
 800b76e:	f000 80c9 	beq.w	800b904 <cblas_strsm+0x20c>
 800b772:	2c01      	cmp	r4, #1
 800b774:	4623      	mov	r3, r4
 800b776:	bfb8      	it	lt
 800b778:	2301      	movlt	r3, #1
 800b77a:	454b      	cmp	r3, r9
 800b77c:	bfcc      	ite	gt
 800b77e:	230c      	movgt	r3, #12
 800b780:	230a      	movle	r3, #10
 800b782:	4aa4      	ldr	r2, [pc, #656]	; (800ba14 <cblas_strsm+0x31c>)
 800b784:	49a4      	ldr	r1, [pc, #656]	; (800ba18 <cblas_strsm+0x320>)
 800b786:	4618      	mov	r0, r3
 800b788:	f01c ffbe 	bl	8028708 <cblas_xerbla>
    uplo = Uplo;
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
  } else {
    n1 = N;
    n2 = M;
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800b78c:	2e8d      	cmp	r6, #141	; 0x8d
 800b78e:	bf0c      	ite	eq
 800b790:	268e      	moveq	r6, #142	; 0x8e
 800b792:	268d      	movne	r6, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800b794:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 800b798:	bf0c      	ite	eq
 800b79a:	f04f 0b7a 	moveq.w	fp, #122	; 0x7a
 800b79e:	f04f 0b79 	movne.w	fp, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800b7a2:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
 800b7a6:	bf08      	it	eq
 800b7a8:	f04f 0a70 	moveq.w	sl, #112	; 0x70
  }

  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800b7ac:	2e8d      	cmp	r6, #141	; 0x8d
 800b7ae:	d027      	beq.n	800b800 <cblas_strsm+0x108>
          B[ldb * k + j] -= Aik * B[ldb * i + j];
        }
      }
    }

  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800b7b0:	2e8e      	cmp	r6, #142	; 0x8e
 800b7b2:	d107      	bne.n	800b7c4 <cblas_strsm+0xcc>
 800b7b4:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 800b7b8:	f000 80be 	beq.w	800b938 <cblas_strsm+0x240>
        }
      }
    }


  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800b7bc:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 800b7c0:	f000 812e 	beq.w	800ba20 <cblas_strsm+0x328>
    }



  } else {
    BLAS_ERROR("unrecognized operation");
 800b7c4:	4a95      	ldr	r2, [pc, #596]	; (800ba1c <cblas_strsm+0x324>)
 800b7c6:	4994      	ldr	r1, [pc, #592]	; (800ba18 <cblas_strsm+0x320>)
 800b7c8:	2000      	movs	r0, #0
#define BASE float
#include "source_trsm_r.h"
#undef BASE
}
 800b7ca:	b009      	add	sp, #36	; 0x24
 800b7cc:	ecbd 8b02 	vpop	{d8}
 800b7d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b7d4:	f01c bf98 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800b7d8:	2865      	cmp	r0, #101	; 0x65
 800b7da:	f000 818f 	beq.w	800bafc <cblas_strsm+0x404>
 800b7de:	2c01      	cmp	r4, #1
 800b7e0:	4622      	mov	r2, r4
 800b7e2:	bfb8      	it	lt
 800b7e4:	2201      	movlt	r2, #1
 800b7e6:	454a      	cmp	r2, r9
 800b7e8:	f340 80a2 	ble.w	800b930 <cblas_strsm+0x238>
 800b7ec:	230c      	movs	r3, #12
 800b7ee:	e7c8      	b.n	800b782 <cblas_strsm+0x8a>
 800b7f0:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800b7f4:	2b01      	cmp	r3, #1
 800b7f6:	bf94      	ite	ls
 800b7f8:	2300      	movls	r3, #0
 800b7fa:	2301      	movhi	r3, #1
 800b7fc:	46a4      	mov	ip, r4
 800b7fe:	e797      	b.n	800b730 <cblas_strsm+0x38>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800b800:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 800b804:	f000 8182 	beq.w	800bb0c <cblas_strsm+0x414>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 800b808:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 800b80c:	d1da      	bne.n	800b7c4 <cblas_strsm+0xcc>
 800b80e:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800b812:	f000 82ac 	beq.w	800bd6e <cblas_strsm+0x676>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 800b816:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800b81a:	d1d3      	bne.n	800b7c4 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800b81c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800b820:	eeb4 8a67 	vcmp.f32	s16, s15
 800b824:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b828:	f000 83f5 	beq.w	800c016 <cblas_strsm+0x91e>
      for (i = 0; i < n1; i++) {
 800b82c:	2d00      	cmp	r5, #0
 800b82e:	f340 8203 	ble.w	800bc38 <cblas_strsm+0x540>
 800b832:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800b836:	00a3      	lsls	r3, r4, #2
 800b838:	0080      	lsls	r0, r0, #2
 800b83a:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b83e:	9303      	str	r3, [sp, #12]
 800b840:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800b844:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800b846:	2c00      	cmp	r4, #0
 800b848:	bfc8      	it	gt
 800b84a:	1813      	addgt	r3, r2, r0
 800b84c:	dd07      	ble.n	800b85e <cblas_strsm+0x166>
          B[ldb * i + j] *= alpha;
 800b84e:	edd3 7a00 	vldr	s15, [r3]
 800b852:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b856:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b85a:	4293      	cmp	r3, r2
 800b85c:	d1f7      	bne.n	800b84e <cblas_strsm+0x156>
      for (i = 0; i < n1; i++) {
 800b85e:	3101      	adds	r1, #1
 800b860:	428d      	cmp	r5, r1
 800b862:	4432      	add	r2, r6
 800b864:	d1ef      	bne.n	800b846 <cblas_strsm+0x14e>
 800b866:	f105 3cff 	add.w	ip, r5, #4294967295
 800b86a:	fb0c fa07 	mul.w	sl, ip, r7
 800b86e:	9a02      	ldr	r2, [sp, #8]
 800b870:	fb07 c30c 	mla	r3, r7, ip, ip
 800b874:	eba3 030a 	sub.w	r3, r3, sl
 800b878:	1f11      	subs	r1, r2, #4
 800b87a:	009b      	lsls	r3, r3, #2
 800b87c:	43fa      	mvns	r2, r7
 800b87e:	9306      	str	r3, [sp, #24]
 800b880:	0093      	lsls	r3, r2, #2
 800b882:	9304      	str	r3, [sp, #16]
 800b884:	ebc9 7389 	rsb	r3, r9, r9, lsl #30
 800b888:	009b      	lsls	r3, r3, #2
 800b88a:	eb0a 0005 	add.w	r0, sl, r5
 800b88e:	9305      	str	r3, [sp, #20]
 800b890:	9b03      	ldr	r3, [sp, #12]
 800b892:	ebc7 7b87 	rsb	fp, r7, r7, lsl #30
 800b896:	ebc5 7585 	rsb	r5, r5, r5, lsl #30
 800b89a:	eb01 0780 	add.w	r7, r1, r0, lsl #2
 800b89e:	9902      	ldr	r1, [sp, #8]
 800b8a0:	00ad      	lsls	r5, r5, #2
 800b8a2:	4443      	add	r3, r8
 800b8a4:	9507      	str	r5, [sp, #28]
 800b8a6:	eb01 0a8a 	add.w	sl, r1, sl, lsl #2
 800b8aa:	fb06 8e0c 	mla	lr, r6, ip, r8
 800b8ae:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800b8b2:	9302      	str	r3, [sp, #8]
      if (nonunit) {
 800b8b4:	9b01      	ldr	r3, [sp, #4]
 800b8b6:	2b83      	cmp	r3, #131	; 0x83
 800b8b8:	f000 819e 	beq.w	800bbf8 <cblas_strsm+0x500>
      for (k = 0; k < i; k++) {
 800b8bc:	f1bc 0f00 	cmp.w	ip, #0
 800b8c0:	f000 81ba 	beq.w	800bc38 <cblas_strsm+0x540>
 800b8c4:	9902      	ldr	r1, [sp, #8]
 800b8c6:	4650      	mov	r0, sl
 800b8c8:	2500      	movs	r5, #0
        for (j = 0; j < n2; j++) {
 800b8ca:	2c00      	cmp	r4, #0
        const BASE Aik = A[i * lda + k];
 800b8cc:	ecf0 6a01 	vldmia	r0!, {s13}
        for (j = 0; j < n2; j++) {
 800b8d0:	dd0c      	ble.n	800b8ec <cblas_strsm+0x1f4>
 800b8d2:	eb08 0385 	add.w	r3, r8, r5, lsl #2
 800b8d6:	4672      	mov	r2, lr
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 800b8d8:	edd3 7a00 	vldr	s15, [r3]
 800b8dc:	ecb2 7a01 	vldmia	r2!, {s14}
 800b8e0:	eee7 7a66 	vfms.f32	s15, s14, s13
 800b8e4:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b8e8:	428b      	cmp	r3, r1
 800b8ea:	d1f5      	bne.n	800b8d8 <cblas_strsm+0x1e0>
      for (k = 0; k < i; k++) {
 800b8ec:	42b8      	cmp	r0, r7
 800b8ee:	444d      	add	r5, r9
 800b8f0:	4431      	add	r1, r6
 800b8f2:	d1ea      	bne.n	800b8ca <cblas_strsm+0x1d2>
 800b8f4:	9b04      	ldr	r3, [sp, #16]
 800b8f6:	441f      	add	r7, r3
 800b8f8:	9b05      	ldr	r3, [sp, #20]
 800b8fa:	44da      	add	sl, fp
 800b8fc:	449e      	add	lr, r3
 800b8fe:	f10c 3cff 	add.w	ip, ip, #4294967295
 800b902:	e7d7      	b.n	800b8b4 <cblas_strsm+0x1bc>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800b904:	2d01      	cmp	r5, #1
 800b906:	462b      	mov	r3, r5
 800b908:	bfb8      	it	lt
 800b90a:	2301      	movlt	r3, #1
 800b90c:	454b      	cmp	r3, r9
 800b90e:	bfcc      	ite	gt
 800b910:	230c      	movgt	r3, #12
 800b912:	230a      	movle	r3, #10
 800b914:	4a3f      	ldr	r2, [pc, #252]	; (800ba14 <cblas_strsm+0x31c>)
 800b916:	4940      	ldr	r1, [pc, #256]	; (800ba18 <cblas_strsm+0x320>)
 800b918:	4618      	mov	r0, r3
 800b91a:	f01c fef5 	bl	8028708 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800b91e:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
 800b922:	462b      	mov	r3, r5
 800b924:	d101      	bne.n	800b92a <cblas_strsm+0x232>
 800b926:	f04f 0a70 	mov.w	sl, #112	; 0x70
 800b92a:	4625      	mov	r5, r4
 800b92c:	461c      	mov	r4, r3
 800b92e:	e73d      	b.n	800b7ac <cblas_strsm+0xb4>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800b930:	2b00      	cmp	r3, #0
 800b932:	f43f af2b 	beq.w	800b78c <cblas_strsm+0x94>
 800b936:	e724      	b.n	800b782 <cblas_strsm+0x8a>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800b938:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800b93c:	f000 8292 	beq.w	800be64 <cblas_strsm+0x76c>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 800b940:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800b944:	f47f af3e 	bne.w	800b7c4 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800b948:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800b94c:	eeb4 8a67 	vcmp.f32	s16, s15
 800b950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b954:	f000 837f 	beq.w	800c056 <cblas_strsm+0x95e>
      for (i = 0; i < n1; i++) {
 800b958:	2d00      	cmp	r5, #0
 800b95a:	f340 816d 	ble.w	800bc38 <cblas_strsm+0x540>
 800b95e:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800b962:	00a3      	lsls	r3, r4, #2
 800b964:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b968:	0080      	lsls	r0, r0, #2
 800b96a:	9303      	str	r3, [sp, #12]
 800b96c:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800b970:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800b972:	2c00      	cmp	r4, #0
 800b974:	bfc8      	it	gt
 800b976:	1813      	addgt	r3, r2, r0
 800b978:	dd07      	ble.n	800b98a <cblas_strsm+0x292>
          B[ldb * i + j] *= alpha;
 800b97a:	edd3 7a00 	vldr	s15, [r3]
 800b97e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b982:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b986:	4293      	cmp	r3, r2
 800b988:	d1f7      	bne.n	800b97a <cblas_strsm+0x282>
      for (i = 0; i < n1; i++) {
 800b98a:	3101      	adds	r1, #1
 800b98c:	428d      	cmp	r5, r1
 800b98e:	4432      	add	r2, r6
 800b990:	d1ef      	bne.n	800b972 <cblas_strsm+0x27a>
 800b992:	9903      	ldr	r1, [sp, #12]
 800b994:	f8dd c004 	ldr.w	ip, [sp, #4]
 800b998:	4441      	add	r1, r8
 800b99a:	1c7b      	adds	r3, r7, #1
 800b99c:	468b      	mov	fp, r1
 800b99e:	9902      	ldr	r1, [sp, #8]
 800b9a0:	009b      	lsls	r3, r3, #2
 800b9a2:	43ff      	mvns	r7, r7
 800b9a4:	1e62      	subs	r2, r4, #1
 800b9a6:	e9cd 4501 	strd	r4, r5, [sp, #4]
 800b9aa:	fb03 1202 	mla	r2, r3, r2, r1
 800b9ae:	ea4f 0987 	mov.w	r9, r7, lsl #2
 800b9b2:	1f1f      	subs	r7, r3, #4
      for (j = n2; j > 0 && j--;) {
 800b9b4:	2300      	movs	r3, #0
 800b9b6:	9203      	str	r2, [sp, #12]
 800b9b8:	f101 0a04 	add.w	sl, r1, #4
 800b9bc:	469e      	mov	lr, r3
 800b9be:	9b01      	ldr	r3, [sp, #4]
 800b9c0:	2b00      	cmp	r3, #0
 800b9c2:	f340 813e 	ble.w	800bc42 <cblas_strsm+0x54a>
 800b9c6:	9d03      	ldr	r5, [sp, #12]
 800b9c8:	9801      	ldr	r0, [sp, #4]
 800b9ca:	465c      	mov	r4, fp
 800b9cc:	4659      	mov	r1, fp
        if (nonunit) {
 800b9ce:	f1bc 0f83 	cmp.w	ip, #131	; 0x83
      for (j = n2; j > 0 && j--;) {
 800b9d2:	f100 30ff 	add.w	r0, r0, #4294967295
        if (nonunit) {
 800b9d6:	d107      	bne.n	800b9e8 <cblas_strsm+0x2f0>
          B[ldb * i + j] /= Ajj;
 800b9d8:	ed54 6a01 	vldr	s13, [r4, #-4]
 800b9dc:	ed95 7a00 	vldr	s14, [r5]
 800b9e0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b9e4:	ed44 7a01 	vstr	s15, [r4, #-4]
          BASE Bij = B[ldb * i + j];
 800b9e8:	ed71 6a01 	vldmdb	r1!, {s13}
          for (k = 0; k < j; k++) {
 800b9ec:	2800      	cmp	r0, #0
 800b9ee:	f000 8128 	beq.w	800bc42 <cblas_strsm+0x54a>
 800b9f2:	eb0a 0280 	add.w	r2, sl, r0, lsl #2
 800b9f6:	4643      	mov	r3, r8
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 800b9f8:	ed12 7a01 	vldr	s14, [r2, #-4]
 800b9fc:	edd3 7a00 	vldr	s15, [r3]
 800ba00:	eee7 7a66 	vfms.f32	s15, s14, s13
 800ba04:	443a      	add	r2, r7
 800ba06:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = 0; k < j; k++) {
 800ba0a:	428b      	cmp	r3, r1
 800ba0c:	d1f4      	bne.n	800b9f8 <cblas_strsm+0x300>
 800ba0e:	444d      	add	r5, r9
 800ba10:	3c04      	subs	r4, #4
 800ba12:	e7dc      	b.n	800b9ce <cblas_strsm+0x2d6>
 800ba14:	08031108 	.word	0x08031108
 800ba18:	080312a0 	.word	0x080312a0
 800ba1c:	080311b8 	.word	0x080311b8
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800ba20:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800ba24:	f000 8280 	beq.w	800bf28 <cblas_strsm+0x830>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 800ba28:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800ba2c:	f47f aeca 	bne.w	800b7c4 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800ba30:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800ba34:	eeb4 8a67 	vcmp.f32	s16, s15
 800ba38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ba3c:	f000 82e3 	beq.w	800c006 <cblas_strsm+0x90e>
      for (i = 0; i < n1; i++) {
 800ba40:	2d00      	cmp	r5, #0
 800ba42:	f340 80f9 	ble.w	800bc38 <cblas_strsm+0x540>
 800ba46:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800ba4a:	00a3      	lsls	r3, r4, #2
 800ba4c:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800ba50:	0080      	lsls	r0, r0, #2
 800ba52:	9303      	str	r3, [sp, #12]
 800ba54:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800ba58:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800ba5a:	2c00      	cmp	r4, #0
 800ba5c:	bfc8      	it	gt
 800ba5e:	1813      	addgt	r3, r2, r0
 800ba60:	dd07      	ble.n	800ba72 <cblas_strsm+0x37a>
          B[ldb * i + j] *= alpha;
 800ba62:	edd3 7a00 	vldr	s15, [r3]
 800ba66:	ee67 7a88 	vmul.f32	s15, s15, s16
 800ba6a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800ba6e:	4293      	cmp	r3, r2
 800ba70:	d1f7      	bne.n	800ba62 <cblas_strsm+0x36a>
      for (i = 0; i < n1; i++) {
 800ba72:	3101      	adds	r1, #1
 800ba74:	428d      	cmp	r5, r1
 800ba76:	4432      	add	r2, r6
 800ba78:	d1ef      	bne.n	800ba5a <cblas_strsm+0x362>
 800ba7a:	9a03      	ldr	r2, [sp, #12]
 800ba7c:	9604      	str	r6, [sp, #16]
 800ba7e:	4611      	mov	r1, r2
 800ba80:	9a02      	ldr	r2, [sp, #8]
 800ba82:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 800ba86:	f107 0a01 	add.w	sl, r7, #1
 800ba8a:	00b8      	lsls	r0, r7, #2
 800ba8c:	9205      	str	r2, [sp, #20]
          for (k = j + 1; k < n2; k++) {
 800ba8e:	2200      	movs	r2, #0
 800ba90:	4441      	add	r1, r8
 800ba92:	46c1      	mov	r9, r8
 800ba94:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800ba98:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800ba9c:	9203      	str	r2, [sp, #12]
 800ba9e:	f100 0b04 	add.w	fp, r0, #4
 800baa2:	9501      	str	r5, [sp, #4]
      for (j = 0; j < n2; j++) {
 800baa4:	2c00      	cmp	r4, #0
 800baa6:	f340 80bd 	ble.w	800bc24 <cblas_strsm+0x52c>
 800baaa:	f8dd e008 	ldr.w	lr, [sp, #8]
 800baae:	9f05      	ldr	r7, [sp, #20]
 800bab0:	46cc      	mov	ip, r9
 800bab2:	464e      	mov	r6, r9
 800bab4:	2500      	movs	r5, #0
        if (nonunit) {
 800bab6:	f1b8 0f83 	cmp.w	r8, #131	; 0x83
 800baba:	d107      	bne.n	800bacc <cblas_strsm+0x3d4>
          B[ldb * i + j] /= Ajj;
 800babc:	eddc 6a00 	vldr	s13, [ip]
 800bac0:	ed9e 7a00 	vldr	s14, [lr]
 800bac4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800bac8:	edcc 7a00 	vstr	s15, [ip]
          for (k = j + 1; k < n2; k++) {
 800bacc:	3501      	adds	r5, #1
 800bace:	42ac      	cmp	r4, r5
          BASE Bij = B[ldb * i + j];
 800bad0:	ecf6 6a01 	vldmia	r6!, {s13}
          for (k = j + 1; k < n2; k++) {
 800bad4:	f000 80a6 	beq.w	800bc24 <cblas_strsm+0x52c>
 800bad8:	463a      	mov	r2, r7
 800bada:	4633      	mov	r3, r6
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 800badc:	ed92 7a00 	vldr	s14, [r2]
 800bae0:	edd3 7a00 	vldr	s15, [r3]
 800bae4:	eee7 7a66 	vfms.f32	s15, s14, s13
 800bae8:	4402      	add	r2, r0
 800baea:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = j + 1; k < n2; k++) {
 800baee:	428b      	cmp	r3, r1
 800baf0:	d1f4      	bne.n	800badc <cblas_strsm+0x3e4>
 800baf2:	4457      	add	r7, sl
 800baf4:	44de      	add	lr, fp
 800baf6:	f10c 0c04 	add.w	ip, ip, #4
 800bafa:	e7dc      	b.n	800bab6 <cblas_strsm+0x3be>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800bafc:	2d01      	cmp	r5, #1
 800bafe:	462a      	mov	r2, r5
 800bb00:	bfb8      	it	lt
 800bb02:	2201      	movlt	r2, #1
 800bb04:	454a      	cmp	r2, r9
 800bb06:	dd6b      	ble.n	800bbe0 <cblas_strsm+0x4e8>
 800bb08:	230c      	movs	r3, #12
 800bb0a:	e703      	b.n	800b914 <cblas_strsm+0x21c>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800bb0c:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800bb10:	f000 80b2 	beq.w	800bc78 <cblas_strsm+0x580>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 800bb14:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800bb18:	f47f ae54 	bne.w	800b7c4 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800bb1c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800bb20:	eeb4 8a67 	vcmp.f32	s16, s15
 800bb24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bb28:	f000 828d 	beq.w	800c046 <cblas_strsm+0x94e>
      for (i = 0; i < n1; i++) {
 800bb2c:	2d00      	cmp	r5, #0
 800bb2e:	f340 8083 	ble.w	800bc38 <cblas_strsm+0x540>
 800bb32:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800bb36:	00a3      	lsls	r3, r4, #2
 800bb38:	0080      	lsls	r0, r0, #2
 800bb3a:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800bb3e:	9303      	str	r3, [sp, #12]
 800bb40:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800bb44:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800bb46:	2c00      	cmp	r4, #0
 800bb48:	bfc8      	it	gt
 800bb4a:	1883      	addgt	r3, r0, r2
 800bb4c:	dd07      	ble.n	800bb5e <cblas_strsm+0x466>
          B[ldb * i + j] *= alpha;
 800bb4e:	edd3 7a00 	vldr	s15, [r3]
 800bb52:	ee67 7a88 	vmul.f32	s15, s15, s16
 800bb56:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bb5a:	429a      	cmp	r2, r3
 800bb5c:	d1f7      	bne.n	800bb4e <cblas_strsm+0x456>
      for (i = 0; i < n1; i++) {
 800bb5e:	3101      	adds	r1, #1
 800bb60:	428d      	cmp	r5, r1
 800bb62:	4432      	add	r2, r6
 800bb64:	d1ef      	bne.n	800bb46 <cblas_strsm+0x44e>
 800bb66:	00b8      	lsls	r0, r7, #2
 800bb68:	9a02      	ldr	r2, [sp, #8]
 800bb6a:	9007      	str	r0, [sp, #28]
 800bb6c:	eb04 0309 	add.w	r3, r4, r9
 800bb70:	f04f 0b00 	mov.w	fp, #0
 800bb74:	1d01      	adds	r1, r0, #4
 800bb76:	009b      	lsls	r3, r3, #2
 800bb78:	eb02 0e85 	add.w	lr, r2, r5, lsl #2
 800bb7c:	9106      	str	r1, [sp, #24]
 800bb7e:	1d17      	adds	r7, r2, #4
 800bb80:	9305      	str	r3, [sp, #20]
 800bb82:	46da      	mov	sl, fp
 800bb84:	46c4      	mov	ip, r8
 800bb86:	9504      	str	r5, [sp, #16]
      if (nonunit) {
 800bb88:	9b01      	ldr	r3, [sp, #4]
 800bb8a:	2b83      	cmp	r3, #131	; 0x83
 800bb8c:	d062      	beq.n	800bc54 <cblas_strsm+0x55c>
      for (k = i + 1; k < n1; k++) {
 800bb8e:	9b04      	ldr	r3, [sp, #16]
 800bb90:	f10a 0a01 	add.w	sl, sl, #1
 800bb94:	4553      	cmp	r3, sl
 800bb96:	dd4f      	ble.n	800bc38 <cblas_strsm+0x540>
 800bb98:	9b05      	ldr	r3, [sp, #20]
 800bb9a:	44cb      	add	fp, r9
 800bb9c:	465d      	mov	r5, fp
 800bb9e:	eb03 010c 	add.w	r1, r3, ip
 800bba2:	4638      	mov	r0, r7
        for (j = 0; j < n2; j++) {
 800bba4:	2c00      	cmp	r4, #0
        const BASE Aik = A[i * lda + k];
 800bba6:	ecf0 6a01 	vldmia	r0!, {s13}
        for (j = 0; j < n2; j++) {
 800bbaa:	dd0c      	ble.n	800bbc6 <cblas_strsm+0x4ce>
 800bbac:	eb08 0385 	add.w	r3, r8, r5, lsl #2
 800bbb0:	4662      	mov	r2, ip
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 800bbb2:	edd3 7a00 	vldr	s15, [r3]
 800bbb6:	ecb2 7a01 	vldmia	r2!, {s14}
 800bbba:	eee7 7a66 	vfms.f32	s15, s14, s13
 800bbbe:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bbc2:	4299      	cmp	r1, r3
 800bbc4:	d1f5      	bne.n	800bbb2 <cblas_strsm+0x4ba>
      for (k = i + 1; k < n1; k++) {
 800bbc6:	4586      	cmp	lr, r0
 800bbc8:	444d      	add	r5, r9
 800bbca:	4431      	add	r1, r6
 800bbcc:	d1ea      	bne.n	800bba4 <cblas_strsm+0x4ac>
 800bbce:	9b07      	ldr	r3, [sp, #28]
 800bbd0:	9a02      	ldr	r2, [sp, #8]
 800bbd2:	449e      	add	lr, r3
 800bbd4:	9b06      	ldr	r3, [sp, #24]
 800bbd6:	441a      	add	r2, r3
 800bbd8:	441f      	add	r7, r3
 800bbda:	44b4      	add	ip, r6
 800bbdc:	9202      	str	r2, [sp, #8]
 800bbde:	e7d3      	b.n	800bb88 <cblas_strsm+0x490>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800bbe0:	2b00      	cmp	r3, #0
 800bbe2:	f43f ae9c 	beq.w	800b91e <cblas_strsm+0x226>
 800bbe6:	e695      	b.n	800b914 <cblas_strsm+0x21c>
 800bbe8:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800bbec:	2b01      	cmp	r3, #1
 800bbee:	bf94      	ite	ls
 800bbf0:	2300      	movls	r3, #0
 800bbf2:	2301      	movhi	r3, #1
 800bbf4:	46ac      	mov	ip, r5
 800bbf6:	e59b      	b.n	800b730 <cblas_strsm+0x38>
        BASE Aii = A[lda * i + i];
 800bbf8:	9b06      	ldr	r3, [sp, #24]
 800bbfa:	9a07      	ldr	r2, [sp, #28]
 800bbfc:	18fb      	adds	r3, r7, r3
 800bbfe:	4413      	add	r3, r2
        for (j = 0; j < n2; j++) {
 800bc00:	2c00      	cmp	r4, #0
        BASE Aii = A[lda * i + i];
 800bc02:	edd3 6a01 	vldr	s13, [r3, #4]
        for (j = 0; j < n2; j++) {
 800bc06:	f77f ae59 	ble.w	800b8bc <cblas_strsm+0x1c4>
 800bc0a:	9b03      	ldr	r3, [sp, #12]
 800bc0c:	eb0e 0203 	add.w	r2, lr, r3
 800bc10:	4673      	mov	r3, lr
          B[ldb * i + j] /= Aii;
 800bc12:	ed93 7a00 	vldr	s14, [r3]
 800bc16:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800bc1a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bc1e:	4293      	cmp	r3, r2
 800bc20:	d1f7      	bne.n	800bc12 <cblas_strsm+0x51a>
 800bc22:	e64b      	b.n	800b8bc <cblas_strsm+0x1c4>
    for (i = 0; i < n1; i++) {
 800bc24:	9a04      	ldr	r2, [sp, #16]
 800bc26:	9b03      	ldr	r3, [sp, #12]
 800bc28:	4491      	add	r9, r2
 800bc2a:	4411      	add	r1, r2
 800bc2c:	9a01      	ldr	r2, [sp, #4]
 800bc2e:	3301      	adds	r3, #1
 800bc30:	429a      	cmp	r2, r3
 800bc32:	9303      	str	r3, [sp, #12]
 800bc34:	f73f af36 	bgt.w	800baa4 <cblas_strsm+0x3ac>
 800bc38:	b009      	add	sp, #36	; 0x24
 800bc3a:	ecbd 8b02 	vpop	{d8}
 800bc3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < n1; i++) {
 800bc42:	9b02      	ldr	r3, [sp, #8]
 800bc44:	f10e 0e01 	add.w	lr, lr, #1
 800bc48:	4573      	cmp	r3, lr
 800bc4a:	44b3      	add	fp, r6
 800bc4c:	44b0      	add	r8, r6
 800bc4e:	f73f aeb6 	bgt.w	800b9be <cblas_strsm+0x2c6>
 800bc52:	e7f1      	b.n	800bc38 <cblas_strsm+0x540>
        BASE Aii = A[lda * i + i];
 800bc54:	9b02      	ldr	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 800bc56:	2c00      	cmp	r4, #0
        BASE Aii = A[lda * i + i];
 800bc58:	edd3 6a00 	vldr	s13, [r3]
        for (j = 0; j < n2; j++) {
 800bc5c:	dd97      	ble.n	800bb8e <cblas_strsm+0x496>
 800bc5e:	9b03      	ldr	r3, [sp, #12]
 800bc60:	eb03 020c 	add.w	r2, r3, ip
 800bc64:	4663      	mov	r3, ip
          B[ldb * i + j] /= Aii;
 800bc66:	ed93 7a00 	vldr	s14, [r3]
 800bc6a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800bc6e:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bc72:	429a      	cmp	r2, r3
 800bc74:	d1f7      	bne.n	800bc66 <cblas_strsm+0x56e>
 800bc76:	e78a      	b.n	800bb8e <cblas_strsm+0x496>
    if (alpha != 1.0) {
 800bc78:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800bc7c:	eeb4 8a67 	vcmp.f32	s16, s15
 800bc80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bc84:	f000 81d7 	beq.w	800c036 <cblas_strsm+0x93e>
      for (i = 0; i < n1; i++) {
 800bc88:	2d00      	cmp	r5, #0
 800bc8a:	ddd5      	ble.n	800bc38 <cblas_strsm+0x540>
 800bc8c:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800bc90:	00a3      	lsls	r3, r4, #2
 800bc92:	0080      	lsls	r0, r0, #2
 800bc94:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800bc98:	9303      	str	r3, [sp, #12]
 800bc9a:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800bc9e:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800bca0:	2c00      	cmp	r4, #0
 800bca2:	bfc8      	it	gt
 800bca4:	1883      	addgt	r3, r0, r2
 800bca6:	dd07      	ble.n	800bcb8 <cblas_strsm+0x5c0>
          B[ldb * i + j] *= alpha;
 800bca8:	edd3 7a00 	vldr	s15, [r3]
 800bcac:	ee67 7a88 	vmul.f32	s15, s15, s16
 800bcb0:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bcb4:	429a      	cmp	r2, r3
 800bcb6:	d1f7      	bne.n	800bca8 <cblas_strsm+0x5b0>
      for (i = 0; i < n1; i++) {
 800bcb8:	3101      	adds	r1, #1
 800bcba:	428d      	cmp	r5, r1
 800bcbc:	4432      	add	r2, r6
 800bcbe:	d1ef      	bne.n	800bca0 <cblas_strsm+0x5a8>
 800bcc0:	ebc9 7389 	rsb	r3, r9, r9, lsl #30
 800bcc4:	f107 0e01 	add.w	lr, r7, #1
 800bcc8:	009b      	lsls	r3, r3, #2
 800bcca:	43ff      	mvns	r7, r7
 800bccc:	00ba      	lsls	r2, r7, #2
 800bcce:	9305      	str	r3, [sp, #20]
 800bcd0:	9b03      	ldr	r3, [sp, #12]
 800bcd2:	9204      	str	r2, [sp, #16]
 800bcd4:	9a02      	ldr	r2, [sp, #8]
 800bcd6:	f105 3cff 	add.w	ip, r5, #4294967295
 800bcda:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800bcde:	4443      	add	r3, r8
 800bce0:	fb0c 2b0e 	mla	fp, ip, lr, r2
 800bce4:	9302      	str	r3, [sp, #8]
 800bce6:	3204      	adds	r2, #4
 800bce8:	4663      	mov	r3, ip
 800bcea:	fb0c 8a06 	mla	sl, ip, r6, r8
 800bcee:	f1ae 0e04 	sub.w	lr, lr, #4
 800bcf2:	46a4      	mov	ip, r4
 800bcf4:	9206      	str	r2, [sp, #24]
 800bcf6:	461c      	mov	r4, r3
      if (nonunit) {
 800bcf8:	9b01      	ldr	r3, [sp, #4]
 800bcfa:	2b83      	cmp	r3, #131	; 0x83
 800bcfc:	d025      	beq.n	800bd4a <cblas_strsm+0x652>
      for (k = 0; k < i; k++) {
 800bcfe:	2c00      	cmp	r4, #0
 800bd00:	d09a      	beq.n	800bc38 <cblas_strsm+0x540>
 800bd02:	9b06      	ldr	r3, [sp, #24]
 800bd04:	9902      	ldr	r1, [sp, #8]
 800bd06:	2700      	movs	r7, #0
 800bd08:	463d      	mov	r5, r7
 800bd0a:	eb03 0084 	add.w	r0, r3, r4, lsl #2
        for (j = 0; j < n2; j++) {
 800bd0e:	f1bc 0f00 	cmp.w	ip, #0
        const BASE Aki = A[k * lda + i];
 800bd12:	ed50 6a01 	vldr	s13, [r0, #-4]
        for (j = 0; j < n2; j++) {
 800bd16:	dd0c      	ble.n	800bd32 <cblas_strsm+0x63a>
 800bd18:	eb08 0387 	add.w	r3, r8, r7, lsl #2
 800bd1c:	4652      	mov	r2, sl
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 800bd1e:	edd3 7a00 	vldr	s15, [r3]
 800bd22:	ecb2 7a01 	vldmia	r2!, {s14}
 800bd26:	eee7 7a66 	vfms.f32	s15, s14, s13
 800bd2a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bd2e:	428b      	cmp	r3, r1
 800bd30:	d1f5      	bne.n	800bd1e <cblas_strsm+0x626>
      for (k = 0; k < i; k++) {
 800bd32:	3501      	adds	r5, #1
 800bd34:	42ac      	cmp	r4, r5
 800bd36:	4470      	add	r0, lr
 800bd38:	444f      	add	r7, r9
 800bd3a:	4431      	add	r1, r6
 800bd3c:	d1e7      	bne.n	800bd0e <cblas_strsm+0x616>
 800bd3e:	9b05      	ldr	r3, [sp, #20]
 800bd40:	449a      	add	sl, r3
 800bd42:	9b04      	ldr	r3, [sp, #16]
 800bd44:	3c01      	subs	r4, #1
 800bd46:	449b      	add	fp, r3
 800bd48:	e7d6      	b.n	800bcf8 <cblas_strsm+0x600>
        for (j = 0; j < n2; j++) {
 800bd4a:	f1bc 0f00 	cmp.w	ip, #0
        BASE Aii = A[lda * i + i];
 800bd4e:	eddb 6a00 	vldr	s13, [fp]
        for (j = 0; j < n2; j++) {
 800bd52:	ddd4      	ble.n	800bcfe <cblas_strsm+0x606>
 800bd54:	9b03      	ldr	r3, [sp, #12]
 800bd56:	eb03 020a 	add.w	r2, r3, sl
 800bd5a:	4653      	mov	r3, sl
          B[ldb * i + j] /= Aii;
 800bd5c:	ed93 7a00 	vldr	s14, [r3]
 800bd60:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800bd64:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bd68:	429a      	cmp	r2, r3
 800bd6a:	d1f7      	bne.n	800bd5c <cblas_strsm+0x664>
 800bd6c:	e7c7      	b.n	800bcfe <cblas_strsm+0x606>
    if (alpha != 1.0) {
 800bd6e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800bd72:	eeb4 8a67 	vcmp.f32	s16, s15
 800bd76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bd7a:	f000 8154 	beq.w	800c026 <cblas_strsm+0x92e>
      for (i = 0; i < n1; i++) {
 800bd7e:	2d00      	cmp	r5, #0
 800bd80:	f77f af5a 	ble.w	800bc38 <cblas_strsm+0x540>
 800bd84:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800bd88:	00a3      	lsls	r3, r4, #2
 800bd8a:	0080      	lsls	r0, r0, #2
 800bd8c:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800bd90:	9303      	str	r3, [sp, #12]
 800bd92:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800bd96:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800bd98:	2c00      	cmp	r4, #0
 800bd9a:	bfc8      	it	gt
 800bd9c:	1883      	addgt	r3, r0, r2
 800bd9e:	dd07      	ble.n	800bdb0 <cblas_strsm+0x6b8>
          B[ldb * i + j] *= alpha;
 800bda0:	edd3 7a00 	vldr	s15, [r3]
 800bda4:	ee67 7a88 	vmul.f32	s15, s15, s16
 800bda8:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bdac:	429a      	cmp	r2, r3
 800bdae:	d1f7      	bne.n	800bda0 <cblas_strsm+0x6a8>
      for (i = 0; i < n1; i++) {
 800bdb0:	3101      	adds	r1, #1
 800bdb2:	428d      	cmp	r5, r1
 800bdb4:	4432      	add	r2, r6
 800bdb6:	d1ef      	bne.n	800bd98 <cblas_strsm+0x6a0>
 800bdb8:	3701      	adds	r7, #1
 800bdba:	9902      	ldr	r1, [sp, #8]
 800bdbc:	9104      	str	r1, [sp, #16]
 800bdbe:	00bb      	lsls	r3, r7, #2
 800bdc0:	f1a3 0e04 	sub.w	lr, r3, #4
 800bdc4:	9306      	str	r3, [sp, #24]
 800bdc6:	eb04 0309 	add.w	r3, r4, r9
 800bdca:	2200      	movs	r2, #0
 800bdcc:	eb01 000e 	add.w	r0, r1, lr
 800bdd0:	009b      	lsls	r3, r3, #2
 800bdd2:	9205      	str	r2, [sp, #20]
 800bdd4:	9002      	str	r0, [sp, #8]
 800bdd6:	9307      	str	r3, [sp, #28]
 800bdd8:	4693      	mov	fp, r2
 800bdda:	46c2      	mov	sl, r8
      if (nonunit) {
 800bddc:	9b01      	ldr	r3, [sp, #4]
 800bdde:	2b83      	cmp	r3, #131	; 0x83
 800bde0:	d02e      	beq.n	800be40 <cblas_strsm+0x748>
      for (k = i + 1; k < n1; k++) {
 800bde2:	f10b 0b01 	add.w	fp, fp, #1
 800bde6:	455d      	cmp	r5, fp
 800bde8:	f77f af26 	ble.w	800bc38 <cblas_strsm+0x540>
 800bdec:	9b05      	ldr	r3, [sp, #20]
 800bdee:	9f02      	ldr	r7, [sp, #8]
 800bdf0:	444b      	add	r3, r9
 800bdf2:	9305      	str	r3, [sp, #20]
 800bdf4:	469c      	mov	ip, r3
 800bdf6:	9b07      	ldr	r3, [sp, #28]
 800bdf8:	4658      	mov	r0, fp
 800bdfa:	eb0a 0103 	add.w	r1, sl, r3
        for (j = 0; j < n2; j++) {
 800bdfe:	2c00      	cmp	r4, #0
        const BASE Aki = A[k * lda + i];
 800be00:	edd7 6a00 	vldr	s13, [r7]
        for (j = 0; j < n2; j++) {
 800be04:	dd0c      	ble.n	800be20 <cblas_strsm+0x728>
 800be06:	eb08 038c 	add.w	r3, r8, ip, lsl #2
 800be0a:	4652      	mov	r2, sl
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 800be0c:	edd3 7a00 	vldr	s15, [r3]
 800be10:	ecb2 7a01 	vldmia	r2!, {s14}
 800be14:	eee7 7a66 	vfms.f32	s15, s14, s13
 800be18:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800be1c:	4299      	cmp	r1, r3
 800be1e:	d1f5      	bne.n	800be0c <cblas_strsm+0x714>
      for (k = i + 1; k < n1; k++) {
 800be20:	3001      	adds	r0, #1
 800be22:	4285      	cmp	r5, r0
 800be24:	4477      	add	r7, lr
 800be26:	44cc      	add	ip, r9
 800be28:	4431      	add	r1, r6
 800be2a:	d1e8      	bne.n	800bdfe <cblas_strsm+0x706>
 800be2c:	9a02      	ldr	r2, [sp, #8]
 800be2e:	9b06      	ldr	r3, [sp, #24]
 800be30:	4611      	mov	r1, r2
 800be32:	9a04      	ldr	r2, [sp, #16]
 800be34:	4419      	add	r1, r3
 800be36:	441a      	add	r2, r3
 800be38:	9102      	str	r1, [sp, #8]
 800be3a:	44b2      	add	sl, r6
 800be3c:	9204      	str	r2, [sp, #16]
 800be3e:	e7cd      	b.n	800bddc <cblas_strsm+0x6e4>
        BASE Aii = A[lda * i + i];
 800be40:	9b04      	ldr	r3, [sp, #16]
        for (j = 0; j < n2; j++) {
 800be42:	2c00      	cmp	r4, #0
        BASE Aii = A[lda * i + i];
 800be44:	edd3 6a00 	vldr	s13, [r3]
        for (j = 0; j < n2; j++) {
 800be48:	ddcb      	ble.n	800bde2 <cblas_strsm+0x6ea>
 800be4a:	9b03      	ldr	r3, [sp, #12]
 800be4c:	eb0a 0203 	add.w	r2, sl, r3
 800be50:	4653      	mov	r3, sl
          B[ldb * i + j] /= Aii;
 800be52:	ed93 7a00 	vldr	s14, [r3]
 800be56:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800be5a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800be5e:	4293      	cmp	r3, r2
 800be60:	d1f7      	bne.n	800be52 <cblas_strsm+0x75a>
 800be62:	e7be      	b.n	800bde2 <cblas_strsm+0x6ea>
    if (alpha != 1.0) {
 800be64:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800be68:	eeb4 8a67 	vcmp.f32	s16, s15
 800be6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800be70:	f000 8101 	beq.w	800c076 <cblas_strsm+0x97e>
      for (i = 0; i < n1; i++) {
 800be74:	2d00      	cmp	r5, #0
 800be76:	f77f aedf 	ble.w	800bc38 <cblas_strsm+0x540>
 800be7a:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800be7e:	00a3      	lsls	r3, r4, #2
 800be80:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800be84:	0080      	lsls	r0, r0, #2
 800be86:	9303      	str	r3, [sp, #12]
 800be88:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800be8c:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800be8e:	2c00      	cmp	r4, #0
 800be90:	bfc8      	it	gt
 800be92:	1813      	addgt	r3, r2, r0
 800be94:	dd07      	ble.n	800bea6 <cblas_strsm+0x7ae>
          B[ldb * i + j] *= alpha;
 800be96:	edd3 7a00 	vldr	s15, [r3]
 800be9a:	ee67 7a88 	vmul.f32	s15, s15, s16
 800be9e:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bea2:	4293      	cmp	r3, r2
 800bea4:	d1f7      	bne.n	800be96 <cblas_strsm+0x79e>
      for (i = 0; i < n1; i++) {
 800bea6:	3101      	adds	r1, #1
 800bea8:	428d      	cmp	r5, r1
 800beaa:	4432      	add	r2, r6
 800beac:	d1ef      	bne.n	800be8e <cblas_strsm+0x796>
 800beae:	9b03      	ldr	r3, [sp, #12]
 800beb0:	f8dd a004 	ldr.w	sl, [sp, #4]
 800beb4:	9501      	str	r5, [sp, #4]
 800beb6:	3701      	adds	r7, #1
 800beb8:	4443      	add	r3, r8
 800beba:	4640      	mov	r0, r8
 800bebc:	4619      	mov	r1, r3
 800bebe:	00bf      	lsls	r7, r7, #2
          for (k = j + 1; k < n2; k++) {
 800bec0:	f04f 0b00 	mov.w	fp, #0
      for (j = 0; j < n2; j++) {
 800bec4:	2c00      	cmp	r4, #0
 800bec6:	dd27      	ble.n	800bf18 <cblas_strsm+0x820>
 800bec8:	9b02      	ldr	r3, [sp, #8]
 800beca:	4680      	mov	r8, r0
 800becc:	f103 0e04 	add.w	lr, r3, #4
 800bed0:	4699      	mov	r9, r3
 800bed2:	4684      	mov	ip, r0
 800bed4:	2500      	movs	r5, #0
        if (nonunit) {
 800bed6:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 800beda:	d107      	bne.n	800beec <cblas_strsm+0x7f4>
          B[ldb * i + j] /= Ajj;
 800bedc:	edd8 6a00 	vldr	s13, [r8]
 800bee0:	ed99 7a00 	vldr	s14, [r9]
 800bee4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800bee8:	edc8 7a00 	vstr	s15, [r8]
          for (k = j + 1; k < n2; k++) {
 800beec:	3501      	adds	r5, #1
 800beee:	42ac      	cmp	r4, r5
          BASE Bij = B[ldb * i + j];
 800bef0:	ecfc 6a01 	vldmia	ip!, {s13}
          for (k = j + 1; k < n2; k++) {
 800bef4:	d010      	beq.n	800bf18 <cblas_strsm+0x820>
 800bef6:	4672      	mov	r2, lr
 800bef8:	4663      	mov	r3, ip
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 800befa:	edd3 7a00 	vldr	s15, [r3]
 800befe:	ecb2 7a01 	vldmia	r2!, {s14}
 800bf02:	eee7 7a66 	vfms.f32	s15, s14, s13
 800bf06:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = j + 1; k < n2; k++) {
 800bf0a:	428b      	cmp	r3, r1
 800bf0c:	d1f5      	bne.n	800befa <cblas_strsm+0x802>
 800bf0e:	44be      	add	lr, r7
 800bf10:	44b9      	add	r9, r7
 800bf12:	f108 0804 	add.w	r8, r8, #4
 800bf16:	e7de      	b.n	800bed6 <cblas_strsm+0x7de>
    for (i = 0; i < n1; i++) {
 800bf18:	9b01      	ldr	r3, [sp, #4]
 800bf1a:	f10b 0b01 	add.w	fp, fp, #1
 800bf1e:	455b      	cmp	r3, fp
 800bf20:	4430      	add	r0, r6
 800bf22:	4431      	add	r1, r6
 800bf24:	dcce      	bgt.n	800bec4 <cblas_strsm+0x7cc>
 800bf26:	e687      	b.n	800bc38 <cblas_strsm+0x540>
    if (alpha != 1.0) {
 800bf28:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800bf2c:	eeb4 8a67 	vcmp.f32	s16, s15
 800bf30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800bf34:	f000 8097 	beq.w	800c066 <cblas_strsm+0x96e>
      for (i = 0; i < n1; i++) {
 800bf38:	2d00      	cmp	r5, #0
 800bf3a:	f77f ae7d 	ble.w	800bc38 <cblas_strsm+0x540>
 800bf3e:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800bf42:	00a3      	lsls	r3, r4, #2
 800bf44:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800bf48:	0080      	lsls	r0, r0, #2
 800bf4a:	9303      	str	r3, [sp, #12]
 800bf4c:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800bf50:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800bf52:	2c00      	cmp	r4, #0
 800bf54:	bfc8      	it	gt
 800bf56:	1813      	addgt	r3, r2, r0
 800bf58:	dd07      	ble.n	800bf6a <cblas_strsm+0x872>
          B[ldb * i + j] *= alpha;
 800bf5a:	edd3 7a00 	vldr	s15, [r3]
 800bf5e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800bf62:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800bf66:	4293      	cmp	r3, r2
 800bf68:	d1f7      	bne.n	800bf5a <cblas_strsm+0x862>
      for (i = 0; i < n1; i++) {
 800bf6a:	3101      	adds	r1, #1
 800bf6c:	428d      	cmp	r5, r1
 800bf6e:	4432      	add	r2, r6
 800bf70:	d1ef      	bne.n	800bf52 <cblas_strsm+0x85a>
 800bf72:	1e63      	subs	r3, r4, #1
 800bf74:	fb07 f203 	mul.w	r2, r7, r3
 800bf78:	fb07 3c03 	mla	ip, r7, r3, r3
 800bf7c:	9b03      	ldr	r3, [sp, #12]
 800bf7e:	9902      	ldr	r1, [sp, #8]
 800bf80:	f8dd e004 	ldr.w	lr, [sp, #4]
 800bf84:	9401      	str	r4, [sp, #4]
 800bf86:	4443      	add	r3, r8
 800bf88:	4699      	mov	r9, r3
 800bf8a:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 800bf8e:	ebc7 7a87 	rsb	sl, r7, r7, lsl #30
 800bf92:	9302      	str	r3, [sp, #8]
 800bf94:	43ff      	mvns	r7, r7
 800bf96:	eb01 038c 	add.w	r3, r1, ip, lsl #2
 800bf9a:	4640      	mov	r0, r8
 800bf9c:	9303      	str	r3, [sp, #12]
 800bf9e:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800bfa2:	ea4f 0887 	mov.w	r8, r7, lsl #2
      for (j = n2; j > 0 && j--;) {
 800bfa6:	f04f 0b00 	mov.w	fp, #0
 800bfaa:	9b01      	ldr	r3, [sp, #4]
 800bfac:	2b00      	cmp	r3, #0
 800bfae:	dd23      	ble.n	800bff8 <cblas_strsm+0x900>
 800bfb0:	f8dd c00c 	ldr.w	ip, [sp, #12]
 800bfb4:	9c02      	ldr	r4, [sp, #8]
 800bfb6:	464f      	mov	r7, r9
 800bfb8:	4649      	mov	r1, r9
        if (nonunit) {
 800bfba:	f1be 0f83 	cmp.w	lr, #131	; 0x83
 800bfbe:	d107      	bne.n	800bfd0 <cblas_strsm+0x8d8>
          B[ldb * i + j] /= Ajj;
 800bfc0:	ed57 6a01 	vldr	s13, [r7, #-4]
 800bfc4:	ed9c 7a00 	vldr	s14, [ip]
 800bfc8:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800bfcc:	ed47 7a01 	vstr	s15, [r7, #-4]
          BASE Bij = B[ldb * i + j];
 800bfd0:	ed71 6a01 	vldmdb	r1!, {s13}
          for (k = 0; k < j; k++) {
 800bfd4:	4281      	cmp	r1, r0
 800bfd6:	d00f      	beq.n	800bff8 <cblas_strsm+0x900>
 800bfd8:	4622      	mov	r2, r4
 800bfda:	4603      	mov	r3, r0
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 800bfdc:	edd3 7a00 	vldr	s15, [r3]
 800bfe0:	ecb2 7a01 	vldmia	r2!, {s14}
 800bfe4:	eee7 7a66 	vfms.f32	s15, s14, s13
 800bfe8:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = 0; k < j; k++) {
 800bfec:	428b      	cmp	r3, r1
 800bfee:	d1f5      	bne.n	800bfdc <cblas_strsm+0x8e4>
 800bff0:	4454      	add	r4, sl
 800bff2:	44c4      	add	ip, r8
 800bff4:	3f04      	subs	r7, #4
 800bff6:	e7e0      	b.n	800bfba <cblas_strsm+0x8c2>
    for (i = 0; i < n1; i++) {
 800bff8:	f10b 0b01 	add.w	fp, fp, #1
 800bffc:	455d      	cmp	r5, fp
 800bffe:	4430      	add	r0, r6
 800c000:	44b1      	add	r9, r6
 800c002:	dcd2      	bgt.n	800bfaa <cblas_strsm+0x8b2>
 800c004:	e618      	b.n	800bc38 <cblas_strsm+0x540>
    for (i = 0; i < n1; i++) {
 800c006:	2d00      	cmp	r5, #0
 800c008:	f77f ae16 	ble.w	800bc38 <cblas_strsm+0x540>
 800c00c:	00a3      	lsls	r3, r4, #2
 800c00e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c012:	9303      	str	r3, [sp, #12]
 800c014:	e531      	b.n	800ba7a <cblas_strsm+0x382>
    for (i = n1; i > 0 && i--;) {
 800c016:	2d00      	cmp	r5, #0
 800c018:	f77f ae0e 	ble.w	800bc38 <cblas_strsm+0x540>
 800c01c:	00a3      	lsls	r3, r4, #2
 800c01e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c022:	9303      	str	r3, [sp, #12]
 800c024:	e41f      	b.n	800b866 <cblas_strsm+0x16e>
    for (i = 0; i < n1; i++) {
 800c026:	2d00      	cmp	r5, #0
 800c028:	f77f ae06 	ble.w	800bc38 <cblas_strsm+0x540>
 800c02c:	00a3      	lsls	r3, r4, #2
 800c02e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c032:	9303      	str	r3, [sp, #12]
 800c034:	e6c0      	b.n	800bdb8 <cblas_strsm+0x6c0>
    for (i = n1; i > 0 && i--;) {
 800c036:	2d00      	cmp	r5, #0
 800c038:	f77f adfe 	ble.w	800bc38 <cblas_strsm+0x540>
 800c03c:	00a3      	lsls	r3, r4, #2
 800c03e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c042:	9303      	str	r3, [sp, #12]
 800c044:	e63c      	b.n	800bcc0 <cblas_strsm+0x5c8>
    for (i = 0; i < n1; i++) {
 800c046:	2d00      	cmp	r5, #0
 800c048:	f77f adf6 	ble.w	800bc38 <cblas_strsm+0x540>
 800c04c:	00a3      	lsls	r3, r4, #2
 800c04e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c052:	9303      	str	r3, [sp, #12]
 800c054:	e587      	b.n	800bb66 <cblas_strsm+0x46e>
    for (i = 0; i < n1; i++) {
 800c056:	2d00      	cmp	r5, #0
 800c058:	f77f adee 	ble.w	800bc38 <cblas_strsm+0x540>
 800c05c:	00a3      	lsls	r3, r4, #2
 800c05e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c062:	9303      	str	r3, [sp, #12]
 800c064:	e495      	b.n	800b992 <cblas_strsm+0x29a>
    for (i = 0; i < n1; i++) {
 800c066:	2d00      	cmp	r5, #0
 800c068:	f77f ade6 	ble.w	800bc38 <cblas_strsm+0x540>
 800c06c:	00a3      	lsls	r3, r4, #2
 800c06e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c072:	9303      	str	r3, [sp, #12]
 800c074:	e77d      	b.n	800bf72 <cblas_strsm+0x87a>
    for (i = 0; i < n1; i++) {
 800c076:	2d00      	cmp	r5, #0
 800c078:	f77f adde 	ble.w	800bc38 <cblas_strsm+0x540>
 800c07c:	00a3      	lsls	r3, r4, #2
 800c07e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800c082:	9303      	str	r3, [sp, #12]
 800c084:	e713      	b.n	800beae <cblas_strsm+0x7b6>
 800c086:	bf00      	nop

0800c088 <cblas_strsv>:
void
cblas_strsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const float *A, const int lda, float *X,
             const int incX)
{
 800c088:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c08c:	b083      	sub	sp, #12

{
  const int nonunit = (Diag == CblasNonUnit);
  INDEX ix, jx;
  INDEX i, j;
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 800c08e:	2a71      	cmp	r2, #113	; 0x71
 800c090:	e9dd 580c 	ldrd	r5, r8, [sp, #48]	; 0x30
 800c094:	e9dd 790e 	ldrd	r7, r9, [sp, #56]	; 0x38
 800c098:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800c09a:	4683      	mov	fp, r0
 800c09c:	468a      	mov	sl, r1
 800c09e:	461e      	mov	r6, r3
 800c0a0:	f000 80c2 	beq.w	800c228 <cblas_strsv+0x1a0>

  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800c0a4:	3979      	subs	r1, #121	; 0x79
 800c0a6:	2901      	cmp	r1, #1
 800c0a8:	4613      	mov	r3, r2
 800c0aa:	d93c      	bls.n	800c126 <cblas_strsv+0x9e>
 800c0ac:	2002      	movs	r0, #2
 800c0ae:	3a6f      	subs	r2, #111	; 0x6f
 800c0b0:	2a02      	cmp	r2, #2
 800c0b2:	bf88      	it	hi
 800c0b4:	2003      	movhi	r0, #3
 800c0b6:	f106 027d 	add.w	r2, r6, #125	; 0x7d
 800c0ba:	b2d2      	uxtb	r2, r2
 800c0bc:	2a01      	cmp	r2, #1
 800c0be:	f240 80a3 	bls.w	800c208 <cblas_strsv+0x180>
 800c0c2:	2d00      	cmp	r5, #0
 800c0c4:	f2c0 8098 	blt.w	800c1f8 <cblas_strsv+0x170>
 800c0c8:	2d01      	cmp	r5, #1
 800c0ca:	462a      	mov	r2, r5
 800c0cc:	bfb8      	it	lt
 800c0ce:	2201      	movlt	r2, #1
 800c0d0:	4297      	cmp	r7, r2
 800c0d2:	f280 8120 	bge.w	800c316 <cblas_strsv+0x28e>
 800c0d6:	2c00      	cmp	r4, #0
 800c0d8:	bf0c      	ite	eq
 800c0da:	2009      	moveq	r0, #9
 800c0dc:	2007      	movne	r0, #7
 800c0de:	4abb      	ldr	r2, [pc, #748]	; (800c3cc <cblas_strsv+0x344>)
 800c0e0:	49bb      	ldr	r1, [pc, #748]	; (800c3d0 <cblas_strsv+0x348>)
 800c0e2:	9300      	str	r3, [sp, #0]
 800c0e4:	f01c fb10 	bl	8028708 <cblas_xerbla>
 800c0e8:	9b00      	ldr	r3, [sp, #0]

  if (N == 0)
 800c0ea:	2d00      	cmp	r5, #0
 800c0ec:	f000 8081 	beq.w	800c1f2 <cblas_strsv+0x16a>
    return;

  /* form  x := inv( A )*x */

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800c0f0:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 800c0f4:	f000 80a0 	beq.w	800c238 <cblas_strsv+0x1b0>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800c0f8:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 800c0fc:	d10b      	bne.n	800c116 <cblas_strsv+0x8e>
 800c0fe:	2b70      	cmp	r3, #112	; 0x70
 800c100:	d017      	beq.n	800c132 <cblas_strsv+0xaa>
        X[ix] = tmp;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 800c102:	2b6f      	cmp	r3, #111	; 0x6f
 800c104:	d107      	bne.n	800c116 <cblas_strsv+0x8e>
 800c106:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800c10a:	f000 8165 	beq.w	800c3d8 <cblas_strsv+0x350>
        X[ix] = tmp;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 800c10e:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800c112:	f000 809e 	beq.w	800c252 <cblas_strsv+0x1ca>
        X[ix] = tmp;
      }
      ix -= incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 800c116:	4aaf      	ldr	r2, [pc, #700]	; (800c3d4 <cblas_strsv+0x34c>)
 800c118:	49ad      	ldr	r1, [pc, #692]	; (800c3d0 <cblas_strsv+0x348>)
 800c11a:	2000      	movs	r0, #0
#define BASE float
#include "source_trsv_r.h"
#undef BASE
}
 800c11c:	b003      	add	sp, #12
 800c11e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c122:	f01c baf1 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800c126:	3865      	subs	r0, #101	; 0x65
 800c128:	2801      	cmp	r0, #1
 800c12a:	bf94      	ite	ls
 800c12c:	2000      	movls	r0, #0
 800c12e:	2001      	movhi	r0, #1
 800c130:	e7bd      	b.n	800c0ae <cblas_strsv+0x26>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800c132:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800c136:	f040 813d 	bne.w	800c3b4 <cblas_strsv+0x32c>
    ix = OFFSET(N, incX) + incX * (N - 1);
 800c13a:	2c00      	cmp	r4, #0
 800c13c:	bfd8      	it	le
 800c13e:	4260      	negle	r0, r4
 800c140:	f105 32ff 	add.w	r2, r5, #4294967295
 800c144:	bfcc      	ite	gt
 800c146:	2000      	movgt	r0, #0
 800c148:	4350      	mulle	r0, r2
    if (nonunit) {
 800c14a:	2e83      	cmp	r6, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 800c14c:	fb02 0004 	mla	r0, r2, r4, r0
    if (nonunit) {
 800c150:	d10d      	bne.n	800c16e <cblas_strsv+0xe6>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 800c152:	fb02 2307 	mla	r3, r2, r7, r2
 800c156:	eb09 0180 	add.w	r1, r9, r0, lsl #2
 800c15a:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800c15e:	ed93 7a00 	vldr	s14, [r3]
 800c162:	edd1 6a00 	vldr	s13, [r1]
 800c166:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c16a:	edc1 7a00 	vstr	s15, [r1]
    for (i = N - 1; i > 0 && i--;) {
 800c16e:	2a00      	cmp	r2, #0
 800c170:	dd3f      	ble.n	800c1f2 <cblas_strsv+0x16a>
 800c172:	f102 3eff 	add.w	lr, r2, #4294967295
 800c176:	fb07 f30e 	mul.w	r3, r7, lr
 800c17a:	1899      	adds	r1, r3, r2
 800c17c:	fb07 ee0e 	mla	lr, r7, lr, lr
 800c180:	ebc1 7a81 	rsb	sl, r1, r1, lsl #30
 800c184:	ea6f 0c07 	mvn.w	ip, r7
 800c188:	442b      	add	r3, r5
 800c18a:	ebc7 7787 	rsb	r7, r7, r7, lsl #30
 800c18e:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 800c192:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800c196:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800c19a:	eb08 0b83 	add.w	fp, r8, r3, lsl #2
 800c19e:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 800c1a2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800c1a6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800c1aa:	00bf      	lsls	r7, r7, #2
 800c1ac:	0080      	lsls	r0, r0, #2
 800c1ae:	00a4      	lsls	r4, r4, #2
      BASE tmp = X[ix];
 800c1b0:	eb09 0300 	add.w	r3, r9, r0
      for (j = i + 1; j < N; j++) {
 800c1b4:	4295      	cmp	r5, r2
      BASE tmp = X[ix];
 800c1b6:	edd3 7a00 	vldr	s15, [r3]
      for (j = i + 1; j < N; j++) {
 800c1ba:	bfc8      	it	gt
 800c1bc:	4688      	movgt	r8, r1
 800c1be:	dd08      	ble.n	800c1d2 <cblas_strsv+0x14a>
        const BASE Aij = A[lda * i + j];
 800c1c0:	ecb8 7a01 	vldmia	r8!, {s14}
        tmp -= Aij * X[jx];
 800c1c4:	edd9 6a00 	vldr	s13, [r9]
      for (j = i + 1; j < N; j++) {
 800c1c8:	45c3      	cmp	fp, r8
        tmp -= Aij * X[jx];
 800c1ca:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = i + 1; j < N; j++) {
 800c1ce:	44a1      	add	r9, r4
 800c1d0:	d1f6      	bne.n	800c1c0 <cblas_strsv+0x138>
      if (nonunit) {
 800c1d2:	2e83      	cmp	r6, #131	; 0x83
 800c1d4:	d106      	bne.n	800c1e4 <cblas_strsv+0x15c>
        X[ix] = tmp / A[lda * i + i];
 800c1d6:	eb0a 0801 	add.w	r8, sl, r1
 800c1da:	44f0      	add	r8, lr
 800c1dc:	ed98 7a00 	vldr	s14, [r8]
 800c1e0:	eec7 7a87 	vdiv.f32	s15, s15, s14
    for (i = N - 1; i > 0 && i--;) {
 800c1e4:	3a01      	subs	r2, #1
 800c1e6:	4461      	add	r1, ip
 800c1e8:	44bb      	add	fp, r7
 800c1ea:	4699      	mov	r9, r3
 800c1ec:	edc3 7a00 	vstr	s15, [r3]
 800c1f0:	d1de      	bne.n	800c1b0 <cblas_strsv+0x128>
 800c1f2:	b003      	add	sp, #12
 800c1f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800c1f8:	2f00      	cmp	r7, #0
 800c1fa:	f77f af6c 	ble.w	800c0d6 <cblas_strsv+0x4e>
 800c1fe:	2c00      	cmp	r4, #0
 800c200:	bf0c      	ite	eq
 800c202:	2009      	moveq	r0, #9
 800c204:	2005      	movne	r0, #5
 800c206:	e76a      	b.n	800c0de <cblas_strsv+0x56>
 800c208:	2d00      	cmp	r5, #0
 800c20a:	dbf5      	blt.n	800c1f8 <cblas_strsv+0x170>
 800c20c:	2d01      	cmp	r5, #1
 800c20e:	462a      	mov	r2, r5
 800c210:	bfb8      	it	lt
 800c212:	2201      	movlt	r2, #1
 800c214:	42ba      	cmp	r2, r7
 800c216:	f73f af5e 	bgt.w	800c0d6 <cblas_strsv+0x4e>
 800c21a:	2c00      	cmp	r4, #0
 800c21c:	f000 811e 	beq.w	800c45c <cblas_strsv+0x3d4>
 800c220:	2800      	cmp	r0, #0
 800c222:	f43f af62 	beq.w	800c0ea <cblas_strsv+0x62>
 800c226:	e75a      	b.n	800c0de <cblas_strsv+0x56>
 800c228:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
 800c22c:	2b01      	cmp	r3, #1
 800c22e:	f240 80c6 	bls.w	800c3be <cblas_strsv+0x336>
 800c232:	2370      	movs	r3, #112	; 0x70
 800c234:	2002      	movs	r0, #2
 800c236:	e73e      	b.n	800c0b6 <cblas_strsv+0x2e>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800c238:	2b6f      	cmp	r3, #111	; 0x6f
 800c23a:	d071      	beq.n	800c320 <cblas_strsv+0x298>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 800c23c:	2b70      	cmp	r3, #112	; 0x70
 800c23e:	f47f af6a 	bne.w	800c116 <cblas_strsv+0x8e>
 800c242:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800c246:	f000 80c7 	beq.w	800c3d8 <cblas_strsv+0x350>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 800c24a:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800c24e:	f47f af62 	bne.w	800c116 <cblas_strsv+0x8e>
    ix = OFFSET(N, incX) + (N - 1) * incX;
 800c252:	2c00      	cmp	r4, #0
 800c254:	bfd8      	it	le
 800c256:	4263      	negle	r3, r4
 800c258:	f105 3cff 	add.w	ip, r5, #4294967295
 800c25c:	bfcc      	ite	gt
 800c25e:	2300      	movgt	r3, #0
 800c260:	fb0c f303 	mulle.w	r3, ip, r3
    if (nonunit) {
 800c264:	2e83      	cmp	r6, #131	; 0x83
    ix = OFFSET(N, incX) + (N - 1) * incX;
 800c266:	fb0c 3304 	mla	r3, ip, r4, r3
    if (nonunit) {
 800c26a:	d10d      	bne.n	800c288 <cblas_strsv+0x200>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 800c26c:	fb0c c207 	mla	r2, ip, r7, ip
 800c270:	eb09 0183 	add.w	r1, r9, r3, lsl #2
 800c274:	eb08 0282 	add.w	r2, r8, r2, lsl #2
 800c278:	ed92 7a00 	vldr	s14, [r2]
 800c27c:	edd1 6a00 	vldr	s13, [r1]
 800c280:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c284:	edc1 7a00 	vstr	s15, [r1]
    for (i = N - 1; i > 0 && i--;) {
 800c288:	f1bc 0f00 	cmp.w	ip, #0
    ix -= incX;
 800c28c:	eba3 0304 	sub.w	r3, r3, r4
    for (i = N - 1; i > 0 && i--;) {
 800c290:	ddaf      	ble.n	800c1f2 <cblas_strsv+0x16a>
 800c292:	1c7a      	adds	r2, r7, #1
 800c294:	fb0c fa02 	mul.w	sl, ip, r2
 800c298:	ea6f 0e07 	mvn.w	lr, r7
 800c29c:	0092      	lsls	r2, r2, #2
 800c29e:	f10c 37ff 	add.w	r7, ip, #4294967295
 800c2a2:	ebc4 7b84 	rsb	fp, r4, r4, lsl #30
 800c2a6:	ebca 7a8a 	rsb	sl, sl, sl, lsl #30
 800c2aa:	eb09 0983 	add.w	r9, r9, r3, lsl #2
 800c2ae:	fb02 f307 	mul.w	r3, r2, r7
 800c2b2:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800c2b6:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800c2ba:	fb0c 8802 	mla	r8, ip, r2, r8
 800c2be:	1f10      	subs	r0, r2, #4
 800c2c0:	9300      	str	r3, [sp, #0]
 800c2c2:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800c2c6:	00a4      	lsls	r4, r4, #2
 800c2c8:	4663      	mov	r3, ip
      for (j = i + 1; j < N; j++) {
 800c2ca:	429d      	cmp	r5, r3
      BASE tmp = X[ix];
 800c2cc:	edd9 7a00 	vldr	s15, [r9]
    for (i = N - 1; i > 0 && i--;) {
 800c2d0:	46bc      	mov	ip, r7
      for (j = i + 1; j < N; j++) {
 800c2d2:	dd0d      	ble.n	800c2f0 <cblas_strsv+0x268>
 800c2d4:	eb04 0109 	add.w	r1, r4, r9
 800c2d8:	4642      	mov	r2, r8
        tmp -= Aji * X[jx];
 800c2da:	edd1 6a00 	vldr	s13, [r1]
 800c2de:	ed12 7a01 	vldr	s14, [r2, #-4]
      for (j = i + 1; j < N; j++) {
 800c2e2:	3301      	adds	r3, #1
 800c2e4:	429d      	cmp	r5, r3
        tmp -= Aji * X[jx];
 800c2e6:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = i + 1; j < N; j++) {
 800c2ea:	4421      	add	r1, r4
 800c2ec:	4402      	add	r2, r0
 800c2ee:	d1f4      	bne.n	800c2da <cblas_strsv+0x252>
      if (nonunit) {
 800c2f0:	2e83      	cmp	r6, #131	; 0x83
 800c2f2:	d107      	bne.n	800c304 <cblas_strsv+0x27c>
        X[ix] = tmp / A[lda * i + i];
 800c2f4:	9a00      	ldr	r2, [sp, #0]
 800c2f6:	eb08 030a 	add.w	r3, r8, sl
 800c2fa:	4413      	add	r3, r2
 800c2fc:	ed93 7a00 	vldr	s14, [r3]
 800c300:	eec7 7a87 	vdiv.f32	s15, s15, s14
 800c304:	44f0      	add	r8, lr
 800c306:	edc9 7a00 	vstr	s15, [r9]
    for (i = N - 1; i > 0 && i--;) {
 800c30a:	44d9      	add	r9, fp
 800c30c:	2f00      	cmp	r7, #0
 800c30e:	f43f af70 	beq.w	800c1f2 <cblas_strsv+0x16a>
 800c312:	3f01      	subs	r7, #1
 800c314:	e7d8      	b.n	800c2c8 <cblas_strsv+0x240>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800c316:	2c00      	cmp	r4, #0
 800c318:	bf0c      	ite	eq
 800c31a:	2009      	moveq	r0, #9
 800c31c:	2004      	movne	r0, #4
 800c31e:	e6de      	b.n	800c0de <cblas_strsv+0x56>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800c320:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800c324:	f43f af09 	beq.w	800c13a <cblas_strsv+0xb2>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 800c328:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800c32c:	f47f aef3 	bne.w	800c116 <cblas_strsv+0x8e>
    ix = OFFSET(N, incX);
 800c330:	2c00      	cmp	r4, #0
 800c332:	f340 8095 	ble.w	800c460 <cblas_strsv+0x3d8>
 800c336:	46a4      	mov	ip, r4
 800c338:	2200      	movs	r2, #0
    if (nonunit) {
 800c33a:	2e83      	cmp	r6, #131	; 0x83
 800c33c:	d109      	bne.n	800c352 <cblas_strsv+0x2ca>
      X[ix] = X[ix] / A[lda * 0 + 0];
 800c33e:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 800c342:	edd3 6a00 	vldr	s13, [r3]
 800c346:	ed98 7a00 	vldr	s14, [r8]
 800c34a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c34e:	edc3 7a00 	vstr	s15, [r3]
    for (i = 1; i < N; i++) {
 800c352:	2d01      	cmp	r5, #1
 800c354:	f77f af4d 	ble.w	800c1f2 <cblas_strsv+0x16a>
 800c358:	1c7b      	adds	r3, r7, #1
 800c35a:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800c35e:	9200      	str	r2, [sp, #0]
 800c360:	009a      	lsls	r2, r3, #2
 800c362:	9201      	str	r2, [sp, #4]
 800c364:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800c368:	00a0      	lsls	r0, r4, #2
 800c36a:	46ba      	mov	sl, r7
 800c36c:	f04f 0e01 	mov.w	lr, #1
      BASE tmp = X[ix];
 800c370:	eb09 0b8c 	add.w	fp, r9, ip, lsl #2
 800c374:	eddb 7a00 	vldr	s15, [fp]
 800c378:	9a00      	ldr	r2, [sp, #0]
 800c37a:	eb08 018a 	add.w	r1, r8, sl, lsl #2
        const BASE Aij = A[lda * i + j];
 800c37e:	ecb1 7a01 	vldmia	r1!, {s14}
        tmp -= Aij * X[jx];
 800c382:	edd2 6a00 	vldr	s13, [r2]
      for (j = 0; j < i; j++) {
 800c386:	4299      	cmp	r1, r3
        tmp -= Aij * X[jx];
 800c388:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = 0; j < i; j++) {
 800c38c:	4402      	add	r2, r0
 800c38e:	d1f6      	bne.n	800c37e <cblas_strsv+0x2f6>
      if (nonunit) {
 800c390:	2e83      	cmp	r6, #131	; 0x83
        X[ix] = tmp / A[lda * i + i];
 800c392:	bf08      	it	eq
 800c394:	ed93 7a00 	vldreq	s14, [r3]
 800c398:	9a01      	ldr	r2, [sp, #4]
 800c39a:	bf08      	it	eq
 800c39c:	eec7 7a87 	vdiveq.f32	s15, s15, s14
    for (i = 1; i < N; i++) {
 800c3a0:	f10e 0e01 	add.w	lr, lr, #1
 800c3a4:	4575      	cmp	r5, lr
      ix += incX;
 800c3a6:	44a4      	add	ip, r4
 800c3a8:	4413      	add	r3, r2
 800c3aa:	44ba      	add	sl, r7
 800c3ac:	edcb 7a00 	vstr	s15, [fp]
    for (i = 1; i < N; i++) {
 800c3b0:	d1de      	bne.n	800c370 <cblas_strsv+0x2e8>
 800c3b2:	e71e      	b.n	800c1f2 <cblas_strsv+0x16a>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 800c3b4:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800c3b8:	f47f aead 	bne.w	800c116 <cblas_strsv+0x8e>
 800c3bc:	e7b8      	b.n	800c330 <cblas_strsv+0x2a8>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800c3be:	3865      	subs	r0, #101	; 0x65
 800c3c0:	2801      	cmp	r0, #1
 800c3c2:	bf94      	ite	ls
 800c3c4:	2000      	movls	r0, #0
 800c3c6:	2001      	movhi	r0, #1
 800c3c8:	2370      	movs	r3, #112	; 0x70
 800c3ca:	e674      	b.n	800c0b6 <cblas_strsv+0x2e>
 800c3cc:	08031108 	.word	0x08031108
 800c3d0:	080312b0 	.word	0x080312b0
 800c3d4:	080311b8 	.word	0x080311b8
    ix = OFFSET(N, incX);
 800c3d8:	2c00      	cmp	r4, #0
 800c3da:	dd48      	ble.n	800c46e <cblas_strsv+0x3e6>
 800c3dc:	46a6      	mov	lr, r4
 800c3de:	2300      	movs	r3, #0
    if (nonunit) {
 800c3e0:	2e83      	cmp	r6, #131	; 0x83
 800c3e2:	d109      	bne.n	800c3f8 <cblas_strsv+0x370>
      X[ix] = X[ix] / A[lda * 0 + 0];
 800c3e4:	eb09 0283 	add.w	r2, r9, r3, lsl #2
 800c3e8:	edd2 6a00 	vldr	s13, [r2]
 800c3ec:	ed98 7a00 	vldr	s14, [r8]
 800c3f0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800c3f4:	edc2 7a00 	vstr	s15, [r2]
    for (i = 1; i < N; i++) {
 800c3f8:	2d01      	cmp	r5, #1
 800c3fa:	f77f aefa 	ble.w	800c1f2 <cblas_strsv+0x16a>
 800c3fe:	3701      	adds	r7, #1
 800c400:	00ba      	lsls	r2, r7, #2
 800c402:	1f17      	subs	r7, r2, #4
 800c404:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 800c408:	9201      	str	r2, [sp, #4]
 800c40a:	9300      	str	r3, [sp, #0]
 800c40c:	eb08 0b07 	add.w	fp, r8, r7
 800c410:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 800c414:	2001      	movs	r0, #1
      BASE tmp = X[ix];
 800c416:	eb09 0a8e 	add.w	sl, r9, lr, lsl #2
 800c41a:	edda 7a00 	vldr	s15, [sl]
 800c41e:	9a00      	ldr	r2, [sp, #0]
 800c420:	eb08 0180 	add.w	r1, r8, r0, lsl #2
 800c424:	2300      	movs	r3, #0
        tmp -= Aji * X[jx];
 800c426:	edd2 6a00 	vldr	s13, [r2]
 800c42a:	ed91 7a00 	vldr	s14, [r1]
      for (j = 0; j < i; j++) {
 800c42e:	3301      	adds	r3, #1
 800c430:	4283      	cmp	r3, r0
        tmp -= Aji * X[jx];
 800c432:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = 0; j < i; j++) {
 800c436:	4462      	add	r2, ip
 800c438:	4439      	add	r1, r7
 800c43a:	d1f4      	bne.n	800c426 <cblas_strsv+0x39e>
      if (nonunit) {
 800c43c:	2e83      	cmp	r6, #131	; 0x83
        X[ix] = tmp / A[lda * i + i];
 800c43e:	bf08      	it	eq
 800c440:	ed9b 7a01 	vldreq	s14, [fp, #4]
 800c444:	9b01      	ldr	r3, [sp, #4]
 800c446:	bf08      	it	eq
 800c448:	eec7 7a87 	vdiveq.f32	s15, s15, s14
    for (i = 1; i < N; i++) {
 800c44c:	3001      	adds	r0, #1
 800c44e:	4285      	cmp	r5, r0
      ix += incX;
 800c450:	44a6      	add	lr, r4
 800c452:	449b      	add	fp, r3
 800c454:	edca 7a00 	vstr	s15, [sl]
    for (i = 1; i < N; i++) {
 800c458:	d1dd      	bne.n	800c416 <cblas_strsv+0x38e>
 800c45a:	e6ca      	b.n	800c1f2 <cblas_strsv+0x16a>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800c45c:	2009      	movs	r0, #9
 800c45e:	e63e      	b.n	800c0de <cblas_strsv+0x56>
    ix = OFFSET(N, incX);
 800c460:	f1c5 0201 	rsb	r2, r5, #1
 800c464:	fb02 f204 	mul.w	r2, r2, r4
 800c468:	eb04 0c02 	add.w	ip, r4, r2
 800c46c:	e765      	b.n	800c33a <cblas_strsv+0x2b2>
    ix = OFFSET(N, incX);
 800c46e:	f1c5 0301 	rsb	r3, r5, #1
 800c472:	fb03 f304 	mul.w	r3, r3, r4
 800c476:	eb04 0e03 	add.w	lr, r4, r3
 800c47a:	e7b1      	b.n	800c3e0 <cblas_strsv+0x358>

0800c47c <cblas_dasum>:
  if (incX <= 0) {
 800c47c:	2a00      	cmp	r2, #0
 800c47e:	dd1a      	ble.n	800c4b6 <cblas_dasum+0x3a>
  for (i = 0; i < N; i++) {
 800c480:	2800      	cmp	r0, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dasum (const int N, const double *X, const int incX)
{
 800c482:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c486:	4681      	mov	r9, r0
 800c488:	dd1a      	ble.n	800c4c0 <cblas_dasum+0x44>
 800c48a:	460c      	mov	r4, r1
  BASE r = 0.0;
 800c48c:	2000      	movs	r0, #0
 800c48e:	2100      	movs	r1, #0
 800c490:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  for (i = 0; i < N; i++) {
 800c494:	2500      	movs	r5, #0
    r += fabs(X[ix]);
 800c496:	e9d4 6300 	ldrd	r6, r3, [r4]
 800c49a:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 800c49e:	4632      	mov	r2, r6
 800c4a0:	463b      	mov	r3, r7
  for (i = 0; i < N; i++) {
 800c4a2:	3501      	adds	r5, #1
    r += fabs(X[ix]);
 800c4a4:	f01c f9aa 	bl	80287fc <__adddf3>
  for (i = 0; i < N; i++) {
 800c4a8:	45a9      	cmp	r9, r5
 800c4aa:	4444      	add	r4, r8
 800c4ac:	d1f3      	bne.n	800c496 <cblas_dasum+0x1a>
#define BASE double
#include "source_asum_r.h"
#undef BASE
}
 800c4ae:	ec41 0b10 	vmov	d0, r0, r1
 800c4b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;
 800c4b6:	2000      	movs	r0, #0
 800c4b8:	2100      	movs	r1, #0
 800c4ba:	ec41 0b10 	vmov	d0, r0, r1
 800c4be:	4770      	bx	lr
 800c4c0:	2000      	movs	r0, #0
 800c4c2:	2100      	movs	r1, #0
 800c4c4:	e7f3      	b.n	800c4ae <cblas_dasum+0x32>
 800c4c6:	bf00      	nop

0800c4c8 <cblas_daxpy>:
#include "cblas.h"

void
cblas_daxpy (const int N, const double alpha, const double *X, const int incX,
             double *Y, const int incY)
{
 800c4c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c4cc:	ec55 4b10 	vmov	r4, r5, d0
 800c4d0:	b085      	sub	sp, #20
 800c4d2:	4607      	mov	r7, r0
 800c4d4:	468a      	mov	sl, r1
  if (alpha == 0.0) {
 800c4d6:	ee10 0a10 	vmov	r0, s0
 800c4da:	4691      	mov	r9, r2
 800c4dc:	461e      	mov	r6, r3
 800c4de:	4629      	mov	r1, r5
 800c4e0:	2300      	movs	r3, #0
 800c4e2:	2200      	movs	r2, #0
 800c4e4:	f01c fda8 	bl	8029038 <__aeabi_dcmpeq>
 800c4e8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c4ea:	bb78      	cbnz	r0, 800c54c <cblas_daxpy+0x84>
  if (incX == 1 && incY == 1) {
 800c4ec:	f1b9 0f01 	cmp.w	r9, #1
 800c4f0:	d02f      	beq.n	800c552 <cblas_daxpy+0x8a>
    INDEX ix = OFFSET(N, incX);
 800c4f2:	f1b9 0f00 	cmp.w	r9, #0
 800c4f6:	bfdc      	itt	le
 800c4f8:	f1c7 0001 	rsble	r0, r7, #1
 800c4fc:	fb00 f009 	mulle.w	r0, r0, r9
    INDEX iy = OFFSET(N, incY);
 800c500:	2b00      	cmp	r3, #0
 800c502:	bfda      	itte	le
 800c504:	f1c7 0201 	rsble	r2, r7, #1
 800c508:	435a      	mulle	r2, r3
 800c50a:	2200      	movgt	r2, #0
    for (i = 0; i < N; i++) {
 800c50c:	2f00      	cmp	r7, #0
 800c50e:	dd1d      	ble.n	800c54c <cblas_daxpy+0x84>
 800c510:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 800c514:	eb06 06c2 	add.w	r6, r6, r2, lsl #3
 800c518:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800c51c:	eb0a 0ac0 	add.w	sl, sl, r0, lsl #3
 800c520:	f04f 0b00 	mov.w	fp, #0
      Y[iy] += alpha * X[ix];
 800c524:	e9da 2300 	ldrd	r2, r3, [sl]
 800c528:	4620      	mov	r0, r4
 800c52a:	4629      	mov	r1, r5
 800c52c:	f01c fb1c 	bl	8028b68 <__aeabi_dmul>
 800c530:	4602      	mov	r2, r0
 800c532:	460b      	mov	r3, r1
 800c534:	e9d6 0100 	ldrd	r0, r1, [r6]
 800c538:	f01c f960 	bl	80287fc <__adddf3>
    for (i = 0; i < N; i++) {
 800c53c:	f10b 0b01 	add.w	fp, fp, #1
 800c540:	455f      	cmp	r7, fp
      Y[iy] += alpha * X[ix];
 800c542:	e9c6 0100 	strd	r0, r1, [r6]
    for (i = 0; i < N; i++) {
 800c546:	44ca      	add	sl, r9
 800c548:	4446      	add	r6, r8
 800c54a:	d1eb      	bne.n	800c524 <cblas_daxpy+0x5c>
#define BASE double
#include "source_axpy_r.h"
#undef BASE
}
 800c54c:	b005      	add	sp, #20
 800c54e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (incX == 1 && incY == 1) {
 800c552:	2b01      	cmp	r3, #1
 800c554:	d1d4      	bne.n	800c500 <cblas_daxpy+0x38>
    const INDEX m = N % 4;
 800c556:	427b      	negs	r3, r7
 800c558:	f003 0303 	and.w	r3, r3, #3
 800c55c:	f007 0b03 	and.w	fp, r7, #3
 800c560:	bf58      	it	pl
 800c562:	f1c3 0b00 	rsbpl	fp, r3, #0
    for (i = 0; i < m; i++) {
 800c566:	f1bb 0f00 	cmp.w	fp, #0
 800c56a:	dd1b      	ble.n	800c5a4 <cblas_daxpy+0xdc>
 800c56c:	e9cd b701 	strd	fp, r7, [sp, #4]
 800c570:	46b0      	mov	r8, r6
 800c572:	eb06 09cb 	add.w	r9, r6, fp, lsl #3
 800c576:	9603      	str	r6, [sp, #12]
 800c578:	4657      	mov	r7, sl
 800c57a:	4656      	mov	r6, sl
      Y[i] += alpha * X[i];
 800c57c:	e9d8 ab00 	ldrd	sl, fp, [r8]
 800c580:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 800c584:	4622      	mov	r2, r4
 800c586:	462b      	mov	r3, r5
 800c588:	f01c faee 	bl	8028b68 <__aeabi_dmul>
 800c58c:	4652      	mov	r2, sl
 800c58e:	465b      	mov	r3, fp
 800c590:	f01c f934 	bl	80287fc <__adddf3>
 800c594:	e8e8 0102 	strd	r0, r1, [r8], #8
    for (i = 0; i < m; i++) {
 800c598:	45c1      	cmp	r9, r8
 800c59a:	d1ef      	bne.n	800c57c <cblas_daxpy+0xb4>
 800c59c:	e9dd b701 	ldrd	fp, r7, [sp, #4]
 800c5a0:	46b2      	mov	sl, r6
 800c5a2:	9e03      	ldr	r6, [sp, #12]
    for (i = m; i + 3 < N; i += 4) {
 800c5a4:	f10b 0303 	add.w	r3, fp, #3
 800c5a8:	429f      	cmp	r7, r3
 800c5aa:	ddcf      	ble.n	800c54c <cblas_daxpy+0x84>
 800c5ac:	1f3b      	subs	r3, r7, #4
 800c5ae:	eba3 030b 	sub.w	r3, r3, fp
 800c5b2:	f023 0303 	bic.w	r3, r3, #3
 800c5b6:	f106 0720 	add.w	r7, r6, #32
 800c5ba:	445b      	add	r3, fp
 800c5bc:	eb0a 0acb 	add.w	sl, sl, fp, lsl #3
 800c5c0:	eb06 06cb 	add.w	r6, r6, fp, lsl #3
 800c5c4:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
      Y[i] += alpha * X[i];
 800c5c8:	e9da 2300 	ldrd	r2, r3, [sl]
 800c5cc:	4620      	mov	r0, r4
 800c5ce:	4629      	mov	r1, r5
 800c5d0:	f01c faca 	bl	8028b68 <__aeabi_dmul>
 800c5d4:	4602      	mov	r2, r0
 800c5d6:	460b      	mov	r3, r1
 800c5d8:	e9d6 0100 	ldrd	r0, r1, [r6]
 800c5dc:	f01c f90e 	bl	80287fc <__adddf3>
 800c5e0:	e9c6 0100 	strd	r0, r1, [r6]
      Y[i + 1] += alpha * X[i + 1];
 800c5e4:	4620      	mov	r0, r4
 800c5e6:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 800c5ea:	4629      	mov	r1, r5
 800c5ec:	f01c fabc 	bl	8028b68 <__aeabi_dmul>
 800c5f0:	4602      	mov	r2, r0
 800c5f2:	460b      	mov	r3, r1
 800c5f4:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 800c5f8:	f01c f900 	bl	80287fc <__adddf3>
 800c5fc:	e9c6 0102 	strd	r0, r1, [r6, #8]
      Y[i + 2] += alpha * X[i + 2];
 800c600:	4620      	mov	r0, r4
 800c602:	e9da 2304 	ldrd	r2, r3, [sl, #16]
 800c606:	4629      	mov	r1, r5
 800c608:	f01c faae 	bl	8028b68 <__aeabi_dmul>
 800c60c:	4602      	mov	r2, r0
 800c60e:	460b      	mov	r3, r1
 800c610:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
 800c614:	f01c f8f2 	bl	80287fc <__adddf3>
 800c618:	e9c6 0104 	strd	r0, r1, [r6, #16]
      Y[i + 3] += alpha * X[i + 3];
 800c61c:	4620      	mov	r0, r4
 800c61e:	e9da 2306 	ldrd	r2, r3, [sl, #24]
 800c622:	4629      	mov	r1, r5
 800c624:	f01c faa0 	bl	8028b68 <__aeabi_dmul>
 800c628:	4602      	mov	r2, r0
 800c62a:	460b      	mov	r3, r1
 800c62c:	e9d6 0106 	ldrd	r0, r1, [r6, #24]
 800c630:	f01c f8e4 	bl	80287fc <__adddf3>
 800c634:	3620      	adds	r6, #32
 800c636:	e946 0102 	strd	r0, r1, [r6, #-8]
    for (i = m; i + 3 < N; i += 4) {
 800c63a:	42be      	cmp	r6, r7
 800c63c:	f10a 0a20 	add.w	sl, sl, #32
 800c640:	d1c2      	bne.n	800c5c8 <cblas_daxpy+0x100>
 800c642:	e783      	b.n	800c54c <cblas_daxpy+0x84>

0800c644 <cblas_dcopy>:
#include "cblas.h"

void
cblas_dcopy (const int N, const double *X, const int incX, double *Y,
             const int incY)
{
 800c644:	b4f0      	push	{r4, r5, r6, r7}
  INDEX ix = OFFSET(N, incX);
 800c646:	2a00      	cmp	r2, #0
 800c648:	9f04      	ldr	r7, [sp, #16]
 800c64a:	bfda      	itte	le
 800c64c:	f1c0 0501 	rsble	r5, r0, #1
 800c650:	4355      	mulle	r5, r2
 800c652:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 800c654:	2f00      	cmp	r7, #0
 800c656:	bfda      	itte	le
 800c658:	f1c0 0401 	rsble	r4, r0, #1
 800c65c:	437c      	mulle	r4, r7
 800c65e:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 800c660:	2800      	cmp	r0, #0
 800c662:	dd0f      	ble.n	800c684 <cblas_dcopy+0x40>
 800c664:	00d6      	lsls	r6, r2, #3
 800c666:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 800c66a:	00ff      	lsls	r7, r7, #3
 800c66c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800c670:	2200      	movs	r2, #0
    Y[iy] = X[ix];
 800c672:	e9d1 4500 	ldrd	r4, r5, [r1]
  for (i = 0; i < N; i++) {
 800c676:	3201      	adds	r2, #1
 800c678:	4290      	cmp	r0, r2
    Y[iy] = X[ix];
 800c67a:	e9c3 4500 	strd	r4, r5, [r3]
  for (i = 0; i < N; i++) {
 800c67e:	4431      	add	r1, r6
 800c680:	443b      	add	r3, r7
 800c682:	d1f6      	bne.n	800c672 <cblas_dcopy+0x2e>
#define BASE double
#include "source_copy_r.h"
#undef BASE
}
 800c684:	bcf0      	pop	{r4, r5, r6, r7}
 800c686:	4770      	bx	lr

0800c688 <cblas_ddot>:
#include "cblas.h"

double
cblas_ddot (const int N, const double *X, const int incX, const double *Y,
            const int incY)
{
 800c688:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  INDEX ix = OFFSET(N, incX);
 800c68c:	2a00      	cmp	r2, #0
 800c68e:	4682      	mov	sl, r0
 800c690:	980a      	ldr	r0, [sp, #40]	; 0x28
 800c692:	bfda      	itte	le
 800c694:	f1ca 0701 	rsble	r7, sl, #1
 800c698:	4357      	mulle	r7, r2
 800c69a:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 800c69c:	2800      	cmp	r0, #0
 800c69e:	bfda      	itte	le
 800c6a0:	f1ca 0601 	rsble	r6, sl, #1
 800c6a4:	4346      	mulle	r6, r0
 800c6a6:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 800c6a8:	f1ba 0f00 	cmp.w	sl, #0
 800c6ac:	f04f 0400 	mov.w	r4, #0
 800c6b0:	f04f 0500 	mov.w	r5, #0
 800c6b4:	dd1d      	ble.n	800c6f2 <cblas_ddot+0x6a>
 800c6b6:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 800c6ba:	eb01 07c7 	add.w	r7, r1, r7, lsl #3
 800c6be:	ea4f 0bc0 	mov.w	fp, r0, lsl #3
 800c6c2:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 800c6c6:	f04f 0800 	mov.w	r8, #0
    r += X[ix] * Y[iy];
 800c6ca:	e9d6 2300 	ldrd	r2, r3, [r6]
 800c6ce:	e9d7 0100 	ldrd	r0, r1, [r7]
 800c6d2:	f01c fa49 	bl	8028b68 <__aeabi_dmul>
 800c6d6:	4602      	mov	r2, r0
 800c6d8:	460b      	mov	r3, r1
 800c6da:	4620      	mov	r0, r4
 800c6dc:	4629      	mov	r1, r5
 800c6de:	f01c f88d 	bl	80287fc <__adddf3>
  for (i = 0; i < N; i++) {
 800c6e2:	f108 0801 	add.w	r8, r8, #1
 800c6e6:	45c2      	cmp	sl, r8
 800c6e8:	445e      	add	r6, fp
    r += X[ix] * Y[iy];
 800c6ea:	4604      	mov	r4, r0
 800c6ec:	460d      	mov	r5, r1
  for (i = 0; i < N; i++) {
 800c6ee:	444f      	add	r7, r9
 800c6f0:	d1eb      	bne.n	800c6ca <cblas_ddot+0x42>
#define BASE double
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 800c6f2:	ec45 4b10 	vmov	d0, r4, r5
 800c6f6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c6fa:	bf00      	nop

0800c6fc <cblas_dgemm>:
cblas_dgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const double alpha, const double *A, const int lda,
             const double *B, const int ldb, const double beta, double *C,
             const int ldc)
{
 800c6fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c700:	ed2d 8b02 	vpush	{d8}
 800c704:	eeb0 8a40 	vmov.f32	s16, s0
 800c708:	eef0 8a60 	vmov.f32	s17, s1
 800c70c:	b091      	sub	sp, #68	; 0x44
 800c70e:	2865      	cmp	r0, #101	; 0x65
 800c710:	9306      	str	r3, [sp, #24]
 800c712:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800c714:	9300      	str	r3, [sp, #0]
 800c716:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800c718:	9301      	str	r3, [sp, #4]
 800c71a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800c71c:	9305      	str	r3, [sp, #20]
 800c71e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800c720:	9302      	str	r3, [sp, #8]
 800c722:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800c724:	930a      	str	r3, [sp, #40]	; 0x28
 800c726:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800c728:	9308      	str	r3, [sp, #32]
 800c72a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800c72c:	9309      	str	r3, [sp, #36]	; 0x24
 800c72e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800c730:	9303      	str	r3, [sp, #12]
 800c732:	ec57 6b11 	vmov	r6, r7, d1
 800c736:	4680      	mov	r8, r0
 800c738:	460d      	mov	r5, r1
 800c73a:	4614      	mov	r4, r2
 800c73c:	f000 8130 	beq.w	800c9a0 <cblas_dgemm+0x2a4>
 800c740:	2a71      	cmp	r2, #113	; 0x71
 800c742:	bf08      	it	eq
 800c744:	2270      	moveq	r2, #112	; 0x70
 800c746:	2971      	cmp	r1, #113	; 0x71
 800c748:	d07d      	beq.n	800c846 <cblas_dgemm+0x14a>
 800c74a:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800c74e:	b2db      	uxtb	r3, r3
 800c750:	2b02      	cmp	r3, #2
 800c752:	f240 8084 	bls.w	800c85e <cblas_dgemm+0x162>
 800c756:	2002      	movs	r0, #2
 800c758:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 800c75c:	2b02      	cmp	r3, #2
 800c75e:	bf88      	it	hi
 800c760:	2003      	movhi	r0, #3
 800c762:	9b06      	ldr	r3, [sp, #24]
 800c764:	2b00      	cmp	r3, #0
 800c766:	9b00      	ldr	r3, [sp, #0]
 800c768:	bfb8      	it	lt
 800c76a:	2004      	movlt	r0, #4
 800c76c:	2b00      	cmp	r3, #0
 800c76e:	9b01      	ldr	r3, [sp, #4]
 800c770:	f2c0 80eb 	blt.w	800c94a <cblas_dgemm+0x24e>
 800c774:	2b00      	cmp	r3, #0
 800c776:	db79      	blt.n	800c86c <cblas_dgemm+0x170>
 800c778:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c77c:	f000 80ec 	beq.w	800c958 <cblas_dgemm+0x25c>
 800c780:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800c784:	d07a      	beq.n	800c87c <cblas_dgemm+0x180>
 800c786:	2800      	cmp	r0, #0
 800c788:	f040 8097 	bne.w	800c8ba <cblas_dgemm+0x1be>
  if (alpha == 0.0 && beta == 1.0)
 800c78c:	ec51 0b18 	vmov	r0, r1, d8
 800c790:	2200      	movs	r2, #0
 800c792:	2300      	movs	r3, #0
 800c794:	f01c fc50 	bl	8029038 <__aeabi_dcmpeq>
 800c798:	b140      	cbz	r0, 800c7ac <cblas_dgemm+0xb0>
 800c79a:	4b94      	ldr	r3, [pc, #592]	; (800c9ec <cblas_dgemm+0x2f0>)
 800c79c:	2200      	movs	r2, #0
 800c79e:	4630      	mov	r0, r6
 800c7a0:	4639      	mov	r1, r7
 800c7a2:	f01c fc49 	bl	8029038 <__aeabi_dcmpeq>
 800c7a6:	2800      	cmp	r0, #0
 800c7a8:	f040 8097 	bne.w	800c8da <cblas_dgemm+0x1de>
  if (Order == CblasRowMajor) {
 800c7ac:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c7b0:	f000 8105 	beq.w	800c9be <cblas_dgemm+0x2c2>
    TransF = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800c7b4:	2c71      	cmp	r4, #113	; 0x71
 800c7b6:	bf14      	ite	ne
 800c7b8:	46a3      	movne	fp, r4
 800c7ba:	f04f 0b70 	moveq.w	fp, #112	; 0x70
    TransG = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800c7be:	2d71      	cmp	r5, #113	; 0x71
 800c7c0:	bf14      	ite	ne
 800c7c2:	462b      	movne	r3, r5
 800c7c4:	2370      	moveq	r3, #112	; 0x70
 800c7c6:	9304      	str	r3, [sp, #16]
  if (beta == 0.0) {
 800c7c8:	2200      	movs	r2, #0
 800c7ca:	2300      	movs	r3, #0
 800c7cc:	4630      	mov	r0, r6
 800c7ce:	4639      	mov	r1, r7
 800c7d0:	f01c fc32 	bl	8029038 <__aeabi_dcmpeq>
 800c7d4:	2800      	cmp	r0, #0
 800c7d6:	f000 8085 	beq.w	800c8e4 <cblas_dgemm+0x1e8>
    for (i = 0; i < n1; i++) {
 800c7da:	9b00      	ldr	r3, [sp, #0]
 800c7dc:	2b00      	cmp	r3, #0
 800c7de:	dd19      	ble.n	800c814 <cblas_dgemm+0x118>
 800c7e0:	9a03      	ldr	r2, [sp, #12]
 800c7e2:	9d06      	ldr	r5, [sp, #24]
 800c7e4:	f8dd c000 	ldr.w	ip, [sp]
 800c7e8:	00d4      	lsls	r4, r2, #3
 800c7ea:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c7ec:	ebc5 7045 	rsb	r0, r5, r5, lsl #29
 800c7f0:	00c0      	lsls	r0, r0, #3
 800c7f2:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800c7f6:	2100      	movs	r1, #0
        C[ldc * i + j] = 0.0;
 800c7f8:	2600      	movs	r6, #0
 800c7fa:	2700      	movs	r7, #0
      for (j = 0; j < n2; j++) {
 800c7fc:	2d00      	cmp	r5, #0
 800c7fe:	bfc8      	it	gt
 800c800:	1813      	addgt	r3, r2, r0
 800c802:	dd03      	ble.n	800c80c <cblas_dgemm+0x110>
        C[ldc * i + j] = 0.0;
 800c804:	e8e3 6702 	strd	r6, r7, [r3], #8
      for (j = 0; j < n2; j++) {
 800c808:	4293      	cmp	r3, r2
 800c80a:	d1fb      	bne.n	800c804 <cblas_dgemm+0x108>
    for (i = 0; i < n1; i++) {
 800c80c:	3101      	adds	r1, #1
 800c80e:	458c      	cmp	ip, r1
 800c810:	4422      	add	r2, r4
 800c812:	d1f3      	bne.n	800c7fc <cblas_dgemm+0x100>
  if (alpha == 0.0)
 800c814:	ec51 0b18 	vmov	r0, r1, d8
 800c818:	2200      	movs	r2, #0
 800c81a:	2300      	movs	r3, #0
 800c81c:	f01c fc0c 	bl	8029038 <__aeabi_dcmpeq>
 800c820:	2800      	cmp	r0, #0
 800c822:	d15a      	bne.n	800c8da <cblas_dgemm+0x1de>
  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 800c824:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 800c828:	d04c      	beq.n	800c8c4 <cblas_dgemm+0x1c8>
  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 800c82a:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800c82e:	f000 80e5 	beq.w	800c9fc <cblas_dgemm+0x300>
    BLAS_ERROR("unrecognized operation");
 800c832:	4a6f      	ldr	r2, [pc, #444]	; (800c9f0 <cblas_dgemm+0x2f4>)
 800c834:	496f      	ldr	r1, [pc, #444]	; (800c9f4 <cblas_dgemm+0x2f8>)
 800c836:	2000      	movs	r0, #0
#define BASE double
#include "source_gemm_r.h"
#undef BASE
}
 800c838:	b011      	add	sp, #68	; 0x44
 800c83a:	ecbd 8b02 	vpop	{d8}
 800c83e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c842:	f01b bf61 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800c846:	3865      	subs	r0, #101	; 0x65
 800c848:	2801      	cmp	r0, #1
 800c84a:	bf94      	ite	ls
 800c84c:	2000      	movls	r0, #0
 800c84e:	2001      	movhi	r0, #1
 800c850:	2170      	movs	r1, #112	; 0x70
 800c852:	e781      	b.n	800c758 <cblas_dgemm+0x5c>
 800c854:	2a71      	cmp	r2, #113	; 0x71
 800c856:	f000 829c 	beq.w	800cd92 <cblas_dgemm+0x696>
 800c85a:	4621      	mov	r1, r4
 800c85c:	2270      	movs	r2, #112	; 0x70
 800c85e:	f1a8 0065 	sub.w	r0, r8, #101	; 0x65
 800c862:	2801      	cmp	r0, #1
 800c864:	bf94      	ite	ls
 800c866:	2000      	movls	r0, #0
 800c868:	2001      	movhi	r0, #1
 800c86a:	e775      	b.n	800c758 <cblas_dgemm+0x5c>
 800c86c:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c870:	f04f 0006 	mov.w	r0, #6
 800c874:	d070      	beq.n	800c958 <cblas_dgemm+0x25c>
 800c876:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800c87a:	d11e      	bne.n	800c8ba <cblas_dgemm+0x1be>
 800c87c:	2a6f      	cmp	r2, #111	; 0x6f
 800c87e:	bf0c      	ite	eq
 800c880:	9b01      	ldreq	r3, [sp, #4]
 800c882:	9b00      	ldrne	r3, [sp, #0]
 800c884:	9a08      	ldr	r2, [sp, #32]
 800c886:	2b01      	cmp	r3, #1
 800c888:	bfb8      	it	lt
 800c88a:	2301      	movlt	r3, #1
 800c88c:	4293      	cmp	r3, r2
 800c88e:	bfc8      	it	gt
 800c890:	200b      	movgt	r0, #11
 800c892:	296f      	cmp	r1, #111	; 0x6f
 800c894:	f000 8135 	beq.w	800cb02 <cblas_dgemm+0x406>
 800c898:	9b01      	ldr	r3, [sp, #4]
 800c89a:	9a02      	ldr	r2, [sp, #8]
 800c89c:	2b01      	cmp	r3, #1
 800c89e:	bfb8      	it	lt
 800c8a0:	2301      	movlt	r3, #1
 800c8a2:	4293      	cmp	r3, r2
 800c8a4:	f300 8149 	bgt.w	800cb3a <cblas_dgemm+0x43e>
 800c8a8:	9b06      	ldr	r3, [sp, #24]
 800c8aa:	2b01      	cmp	r3, #1
 800c8ac:	bfb8      	it	lt
 800c8ae:	2301      	movlt	r3, #1
 800c8b0:	9a03      	ldr	r2, [sp, #12]
 800c8b2:	429a      	cmp	r2, r3
 800c8b4:	f6bf af67 	bge.w	800c786 <cblas_dgemm+0x8a>
 800c8b8:	200e      	movs	r0, #14
 800c8ba:	4a4f      	ldr	r2, [pc, #316]	; (800c9f8 <cblas_dgemm+0x2fc>)
 800c8bc:	494d      	ldr	r1, [pc, #308]	; (800c9f4 <cblas_dgemm+0x2f8>)
 800c8be:	f01b ff23 	bl	8028708 <cblas_xerbla>
 800c8c2:	e763      	b.n	800c78c <cblas_dgemm+0x90>
  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 800c8c4:	9b04      	ldr	r3, [sp, #16]
 800c8c6:	2b6f      	cmp	r3, #111	; 0x6f
 800c8c8:	f000 8141 	beq.w	800cb4e <cblas_dgemm+0x452>
  } else if (TransF == CblasNoTrans && TransG == CblasTrans) {
 800c8cc:	9b04      	ldr	r3, [sp, #16]
 800c8ce:	2b70      	cmp	r3, #112	; 0x70
 800c8d0:	d1af      	bne.n	800c832 <cblas_dgemm+0x136>
    for (i = 0; i < n1; i++) {
 800c8d2:	9b00      	ldr	r3, [sp, #0]
 800c8d4:	2b00      	cmp	r3, #0
 800c8d6:	f300 819c 	bgt.w	800cc12 <cblas_dgemm+0x516>
 800c8da:	b011      	add	sp, #68	; 0x44
 800c8dc:	ecbd 8b02 	vpop	{d8}
 800c8e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 800c8e4:	4b41      	ldr	r3, [pc, #260]	; (800c9ec <cblas_dgemm+0x2f0>)
 800c8e6:	2200      	movs	r2, #0
 800c8e8:	4630      	mov	r0, r6
 800c8ea:	4639      	mov	r1, r7
 800c8ec:	f01c fba4 	bl	8029038 <__aeabi_dcmpeq>
 800c8f0:	2800      	cmp	r0, #0
 800c8f2:	d18f      	bne.n	800c814 <cblas_dgemm+0x118>
    for (i = 0; i < n1; i++) {
 800c8f4:	9b00      	ldr	r3, [sp, #0]
 800c8f6:	2b00      	cmp	r3, #0
 800c8f8:	dd8c      	ble.n	800c814 <cblas_dgemm+0x118>
 800c8fa:	9a03      	ldr	r2, [sp, #12]
 800c8fc:	9b06      	ldr	r3, [sp, #24]
 800c8fe:	f8cd b01c 	str.w	fp, [sp, #28]
 800c902:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 800c906:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800c908:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 800c90c:	4680      	mov	r8, r0
 800c90e:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800c912:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 800c916:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800c918:	f1bb 0f00 	cmp.w	fp, #0
 800c91c:	bfc8      	it	gt
 800c91e:	eb05 0409 	addgt.w	r4, r5, r9
 800c922:	dd09      	ble.n	800c938 <cblas_dgemm+0x23c>
        C[ldc * i + j] *= beta;
 800c924:	e9d4 0100 	ldrd	r0, r1, [r4]
 800c928:	4632      	mov	r2, r6
 800c92a:	463b      	mov	r3, r7
 800c92c:	f01c f91c 	bl	8028b68 <__aeabi_dmul>
 800c930:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j < n2; j++) {
 800c934:	42ac      	cmp	r4, r5
 800c936:	d1f5      	bne.n	800c924 <cblas_dgemm+0x228>
    for (i = 0; i < n1; i++) {
 800c938:	9b00      	ldr	r3, [sp, #0]
 800c93a:	f108 0801 	add.w	r8, r8, #1
 800c93e:	4543      	cmp	r3, r8
 800c940:	4455      	add	r5, sl
 800c942:	d1e9      	bne.n	800c918 <cblas_dgemm+0x21c>
 800c944:	f8dd b01c 	ldr.w	fp, [sp, #28]
 800c948:	e764      	b.n	800c814 <cblas_dgemm+0x118>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800c94a:	2b00      	cmp	r3, #0
 800c94c:	db8e      	blt.n	800c86c <cblas_dgemm+0x170>
 800c94e:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c952:	f04f 0005 	mov.w	r0, #5
 800c956:	d18e      	bne.n	800c876 <cblas_dgemm+0x17a>
 800c958:	2a6f      	cmp	r2, #111	; 0x6f
 800c95a:	bf0c      	ite	eq
 800c95c:	9b01      	ldreq	r3, [sp, #4]
 800c95e:	9b06      	ldrne	r3, [sp, #24]
 800c960:	9a02      	ldr	r2, [sp, #8]
 800c962:	2b01      	cmp	r3, #1
 800c964:	bfb8      	it	lt
 800c966:	2301      	movlt	r3, #1
 800c968:	4293      	cmp	r3, r2
 800c96a:	bfc8      	it	gt
 800c96c:	2009      	movgt	r0, #9
 800c96e:	296f      	cmp	r1, #111	; 0x6f
 800c970:	f000 80d5 	beq.w	800cb1e <cblas_dgemm+0x422>
 800c974:	9b01      	ldr	r3, [sp, #4]
 800c976:	9a08      	ldr	r2, [sp, #32]
 800c978:	2b01      	cmp	r3, #1
 800c97a:	bfb8      	it	lt
 800c97c:	2301      	movlt	r3, #1
 800c97e:	4293      	cmp	r3, r2
 800c980:	f340 80ac 	ble.w	800cadc <cblas_dgemm+0x3e0>
 800c984:	9800      	ldr	r0, [sp, #0]
 800c986:	9b03      	ldr	r3, [sp, #12]
 800c988:	4a1b      	ldr	r2, [pc, #108]	; (800c9f8 <cblas_dgemm+0x2fc>)
 800c98a:	491a      	ldr	r1, [pc, #104]	; (800c9f4 <cblas_dgemm+0x2f8>)
 800c98c:	2801      	cmp	r0, #1
 800c98e:	bfb8      	it	lt
 800c990:	2001      	movlt	r0, #1
 800c992:	4283      	cmp	r3, r0
 800c994:	bfb4      	ite	lt
 800c996:	200e      	movlt	r0, #14
 800c998:	200b      	movge	r0, #11
 800c99a:	f01b feb5 	bl	8028708 <cblas_xerbla>
 800c99e:	e6f5      	b.n	800c78c <cblas_dgemm+0x90>
 800c9a0:	2971      	cmp	r1, #113	; 0x71
 800c9a2:	f43f af57 	beq.w	800c854 <cblas_dgemm+0x158>
 800c9a6:	2a71      	cmp	r2, #113	; 0x71
 800c9a8:	f000 80a1 	beq.w	800caee <cblas_dgemm+0x3f2>
 800c9ac:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800c9b0:	b2db      	uxtb	r3, r3
 800c9b2:	2b02      	cmp	r3, #2
 800c9b4:	4611      	mov	r1, r2
 800c9b6:	462a      	mov	r2, r5
 800c9b8:	f63f aecd 	bhi.w	800c756 <cblas_dgemm+0x5a>
 800c9bc:	e74f      	b.n	800c85e <cblas_dgemm+0x162>
    TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800c9be:	9a08      	ldr	r2, [sp, #32]
    F = A;
 800c9c0:	9805      	ldr	r0, [sp, #20]
 800c9c2:	990a      	ldr	r1, [sp, #40]	; 0x28
 800c9c4:	900a      	str	r0, [sp, #40]	; 0x28
    TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800c9c6:	2d71      	cmp	r5, #113	; 0x71
 800c9c8:	9802      	ldr	r0, [sp, #8]
 800c9ca:	9202      	str	r2, [sp, #8]
 800c9cc:	bf18      	it	ne
 800c9ce:	46ab      	movne	fp, r5
 800c9d0:	9a06      	ldr	r2, [sp, #24]
 800c9d2:	9b00      	ldr	r3, [sp, #0]
 800c9d4:	9008      	str	r0, [sp, #32]
 800c9d6:	bf08      	it	eq
 800c9d8:	f04f 0b70 	moveq.w	fp, #112	; 0x70
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800c9dc:	2c71      	cmp	r4, #113	; 0x71
    G = B;
 800c9de:	9105      	str	r1, [sp, #20]
 800c9e0:	9200      	str	r2, [sp, #0]
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800c9e2:	f000 8080 	beq.w	800cae6 <cblas_dgemm+0x3ea>
 800c9e6:	9404      	str	r4, [sp, #16]
 800c9e8:	9306      	str	r3, [sp, #24]
 800c9ea:	e6ed      	b.n	800c7c8 <cblas_dgemm+0xcc>
 800c9ec:	3ff00000 	.word	0x3ff00000
 800c9f0:	080311b8 	.word	0x080311b8
 800c9f4:	080311a8 	.word	0x080311a8
 800c9f8:	08031108 	.word	0x08031108
  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 800c9fc:	9b04      	ldr	r3, [sp, #16]
 800c9fe:	2b6f      	cmp	r3, #111	; 0x6f
 800ca00:	f000 8162 	beq.w	800ccc8 <cblas_dgemm+0x5cc>
  } else if (TransF == CblasTrans && TransG == CblasTrans) {
 800ca04:	9b04      	ldr	r3, [sp, #16]
 800ca06:	2b70      	cmp	r3, #112	; 0x70
 800ca08:	f47f af13 	bne.w	800c832 <cblas_dgemm+0x136>
    for (i = 0; i < n1; i++) {
 800ca0c:	9b00      	ldr	r3, [sp, #0]
 800ca0e:	2b00      	cmp	r3, #0
 800ca10:	f77f af63 	ble.w	800c8da <cblas_dgemm+0x1de>
 800ca14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ca16:	9307      	str	r3, [sp, #28]
 800ca18:	9b08      	ldr	r3, [sp, #32]
 800ca1a:	9a06      	ldr	r2, [sp, #24]
 800ca1c:	900b      	str	r0, [sp, #44]	; 0x2c
 800ca1e:	00df      	lsls	r7, r3, #3
 800ca20:	9b03      	ldr	r3, [sp, #12]
 800ca22:	900a      	str	r0, [sp, #40]	; 0x28
 800ca24:	00db      	lsls	r3, r3, #3
 800ca26:	930c      	str	r3, [sp, #48]	; 0x30
 800ca28:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ca2a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800ca2e:	9304      	str	r3, [sp, #16]
 800ca30:	9b02      	ldr	r3, [sp, #8]
 800ca32:	9a01      	ldr	r2, [sp, #4]
 800ca34:	00db      	lsls	r3, r3, #3
 800ca36:	9308      	str	r3, [sp, #32]
 800ca38:	9b05      	ldr	r3, [sp, #20]
 800ca3a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800ca3e:	930d      	str	r3, [sp, #52]	; 0x34
      for (j = 0; j < n2; j++) {
 800ca40:	9b06      	ldr	r3, [sp, #24]
 800ca42:	2b00      	cmp	r3, #0
 800ca44:	dd38      	ble.n	800cab8 <cblas_dgemm+0x3bc>
 800ca46:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ca48:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ca4a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800ca4c:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 800ca50:	f04f 0900 	mov.w	r9, #0
        for (k = 0; k < K; k++) {
 800ca54:	9b01      	ldr	r3, [sp, #4]
 800ca56:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800ca58:	f04f 0400 	mov.w	r4, #0
 800ca5c:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800ca60:	dd15      	ble.n	800ca8e <cblas_dgemm+0x392>
 800ca62:	9b05      	ldr	r3, [sp, #20]
 800ca64:	f8dd a01c 	ldr.w	sl, [sp, #28]
 800ca68:	eb03 0bc9 	add.w	fp, r3, r9, lsl #3
          temp += F[ldf * k + i] * G[ldg * j + k];
 800ca6c:	e9da 2300 	ldrd	r2, r3, [sl]
 800ca70:	e8fb 0102 	ldrd	r0, r1, [fp], #8
 800ca74:	f01c f878 	bl	8028b68 <__aeabi_dmul>
 800ca78:	4602      	mov	r2, r0
 800ca7a:	460b      	mov	r3, r1
 800ca7c:	4620      	mov	r0, r4
 800ca7e:	4629      	mov	r1, r5
 800ca80:	f01b febc 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 800ca84:	45b3      	cmp	fp, r6
 800ca86:	44ba      	add	sl, r7
          temp += F[ldf * k + i] * G[ldg * j + k];
 800ca88:	4604      	mov	r4, r0
 800ca8a:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800ca8c:	d1ee      	bne.n	800ca6c <cblas_dgemm+0x370>
        C[ldc * i + j] += alpha * temp;
 800ca8e:	4622      	mov	r2, r4
 800ca90:	462b      	mov	r3, r5
 800ca92:	e9d8 4500 	ldrd	r4, r5, [r8]
 800ca96:	ec51 0b18 	vmov	r0, r1, d8
 800ca9a:	f01c f865 	bl	8028b68 <__aeabi_dmul>
 800ca9e:	462b      	mov	r3, r5
 800caa0:	4622      	mov	r2, r4
 800caa2:	f01b feab 	bl	80287fc <__adddf3>
 800caa6:	9b02      	ldr	r3, [sp, #8]
 800caa8:	4499      	add	r9, r3
 800caaa:	9b08      	ldr	r3, [sp, #32]
 800caac:	e8e8 0102 	strd	r0, r1, [r8], #8
      for (j = 0; j < n2; j++) {
 800cab0:	441e      	add	r6, r3
 800cab2:	9b04      	ldr	r3, [sp, #16]
 800cab4:	4598      	cmp	r8, r3
 800cab6:	d1cd      	bne.n	800ca54 <cblas_dgemm+0x358>
    for (i = 0; i < n1; i++) {
 800cab8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800caba:	9903      	ldr	r1, [sp, #12]
 800cabc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800cabe:	440a      	add	r2, r1
 800cac0:	920b      	str	r2, [sp, #44]	; 0x2c
 800cac2:	990c      	ldr	r1, [sp, #48]	; 0x30
 800cac4:	9a04      	ldr	r2, [sp, #16]
 800cac6:	440a      	add	r2, r1
 800cac8:	9204      	str	r2, [sp, #16]
 800caca:	9a07      	ldr	r2, [sp, #28]
 800cacc:	3208      	adds	r2, #8
 800cace:	9207      	str	r2, [sp, #28]
 800cad0:	9a00      	ldr	r2, [sp, #0]
 800cad2:	3301      	adds	r3, #1
 800cad4:	429a      	cmp	r2, r3
 800cad6:	930a      	str	r3, [sp, #40]	; 0x28
 800cad8:	d1b2      	bne.n	800ca40 <cblas_dgemm+0x344>
 800cada:	e6fe      	b.n	800c8da <cblas_dgemm+0x1de>
 800cadc:	9b00      	ldr	r3, [sp, #0]
 800cade:	2b01      	cmp	r3, #1
 800cae0:	bfb8      	it	lt
 800cae2:	2301      	movlt	r3, #1
 800cae4:	e6e4      	b.n	800c8b0 <cblas_dgemm+0x1b4>
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800cae6:	2270      	movs	r2, #112	; 0x70
 800cae8:	9204      	str	r2, [sp, #16]
 800caea:	9306      	str	r3, [sp, #24]
 800caec:	e66c      	b.n	800c7c8 <cblas_dgemm+0xcc>
 800caee:	460a      	mov	r2, r1
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800caf0:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800caf4:	b2db      	uxtb	r3, r3
 800caf6:	2b02      	cmp	r3, #2
 800caf8:	bf8c      	ite	hi
 800cafa:	2002      	movhi	r0, #2
 800cafc:	2000      	movls	r0, #0
 800cafe:	2170      	movs	r1, #112	; 0x70
 800cb00:	e62f      	b.n	800c762 <cblas_dgemm+0x66>
 800cb02:	9b06      	ldr	r3, [sp, #24]
 800cb04:	9a02      	ldr	r2, [sp, #8]
 800cb06:	2b01      	cmp	r3, #1
 800cb08:	bfb8      	it	lt
 800cb0a:	2301      	movlt	r3, #1
 800cb0c:	4293      	cmp	r3, r2
 800cb0e:	f77f aecf 	ble.w	800c8b0 <cblas_dgemm+0x1b4>
 800cb12:	9a03      	ldr	r2, [sp, #12]
 800cb14:	4293      	cmp	r3, r2
 800cb16:	bfcc      	ite	gt
 800cb18:	200e      	movgt	r0, #14
 800cb1a:	2009      	movle	r0, #9
 800cb1c:	e6cd      	b.n	800c8ba <cblas_dgemm+0x1be>
 800cb1e:	9b00      	ldr	r3, [sp, #0]
 800cb20:	9a08      	ldr	r2, [sp, #32]
 800cb22:	2b01      	cmp	r3, #1
 800cb24:	bfb8      	it	lt
 800cb26:	2301      	movlt	r3, #1
 800cb28:	4293      	cmp	r3, r2
 800cb2a:	f77f aec1 	ble.w	800c8b0 <cblas_dgemm+0x1b4>
 800cb2e:	9a03      	ldr	r2, [sp, #12]
 800cb30:	4293      	cmp	r3, r2
 800cb32:	bfcc      	ite	gt
 800cb34:	200e      	movgt	r0, #14
 800cb36:	200b      	movle	r0, #11
 800cb38:	e6bf      	b.n	800c8ba <cblas_dgemm+0x1be>
 800cb3a:	9806      	ldr	r0, [sp, #24]
 800cb3c:	9b03      	ldr	r3, [sp, #12]
 800cb3e:	2801      	cmp	r0, #1
 800cb40:	bfb8      	it	lt
 800cb42:	2001      	movlt	r0, #1
 800cb44:	4283      	cmp	r3, r0
 800cb46:	bfb4      	ite	lt
 800cb48:	200e      	movlt	r0, #14
 800cb4a:	2009      	movge	r0, #9
 800cb4c:	e6b5      	b.n	800c8ba <cblas_dgemm+0x1be>
    for (k = 0; k < K; k++) {
 800cb4e:	9b01      	ldr	r3, [sp, #4]
 800cb50:	2b00      	cmp	r3, #0
 800cb52:	f77f aec2 	ble.w	800c8da <cblas_dgemm+0x1de>
 800cb56:	9b02      	ldr	r3, [sp, #8]
 800cb58:	9a06      	ldr	r2, [sp, #24]
 800cb5a:	900b      	str	r0, [sp, #44]	; 0x2c
 800cb5c:	00db      	lsls	r3, r3, #3
 800cb5e:	930c      	str	r3, [sp, #48]	; 0x30
 800cb60:	9b08      	ldr	r3, [sp, #32]
 800cb62:	00db      	lsls	r3, r3, #3
 800cb64:	9304      	str	r3, [sp, #16]
 800cb66:	9b03      	ldr	r3, [sp, #12]
 800cb68:	00db      	lsls	r3, r3, #3
 800cb6a:	9302      	str	r3, [sp, #8]
 800cb6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cb6e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cb72:	930d      	str	r3, [sp, #52]	; 0x34
      for (i = 0; i < n1; i++) {
 800cb74:	9b00      	ldr	r3, [sp, #0]
 800cb76:	2b00      	cmp	r3, #0
 800cb78:	dd40      	ble.n	800cbfc <cblas_dgemm+0x500>
 800cb7a:	e9dd 100a 	ldrd	r1, r0, [sp, #40]	; 0x28
 800cb7e:	2300      	movs	r3, #0
 800cb80:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 800cb84:	eb01 0bc0 	add.w	fp, r1, r0, lsl #3
 800cb88:	4698      	mov	r8, r3
 800cb8a:	4699      	mov	r9, r3
 800cb8c:	e00a      	b.n	800cba4 <cblas_dgemm+0x4a8>
 800cb8e:	9b04      	ldr	r3, [sp, #16]
 800cb90:	449b      	add	fp, r3
 800cb92:	9b03      	ldr	r3, [sp, #12]
 800cb94:	4499      	add	r9, r3
 800cb96:	9b02      	ldr	r3, [sp, #8]
 800cb98:	449a      	add	sl, r3
 800cb9a:	9b00      	ldr	r3, [sp, #0]
 800cb9c:	f108 0801 	add.w	r8, r8, #1
 800cba0:	4543      	cmp	r3, r8
 800cba2:	d02b      	beq.n	800cbfc <cblas_dgemm+0x500>
        const BASE temp = alpha * F[ldf * i + k];
 800cba4:	e9db 2300 	ldrd	r2, r3, [fp]
 800cba8:	ec51 0b18 	vmov	r0, r1, d8
 800cbac:	f01b ffdc 	bl	8028b68 <__aeabi_dmul>
        if (temp != 0.0) {
 800cbb0:	2200      	movs	r2, #0
 800cbb2:	2300      	movs	r3, #0
        const BASE temp = alpha * F[ldf * i + k];
 800cbb4:	4606      	mov	r6, r0
 800cbb6:	460f      	mov	r7, r1
        if (temp != 0.0) {
 800cbb8:	f01c fa3e 	bl	8029038 <__aeabi_dcmpeq>
 800cbbc:	2800      	cmp	r0, #0
 800cbbe:	d1e6      	bne.n	800cb8e <cblas_dgemm+0x492>
          for (j = 0; j < n2; j++) {
 800cbc0:	9b06      	ldr	r3, [sp, #24]
 800cbc2:	2b00      	cmp	r3, #0
 800cbc4:	dde3      	ble.n	800cb8e <cblas_dgemm+0x492>
 800cbc6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cbc8:	9d05      	ldr	r5, [sp, #20]
 800cbca:	e9cd 8907 	strd	r8, r9, [sp, #28]
 800cbce:	eb03 04c9 	add.w	r4, r3, r9, lsl #3
 800cbd2:	46b0      	mov	r8, r6
 800cbd4:	46b9      	mov	r9, r7
            C[ldc * i + j] += temp * G[ldg * k + j];
 800cbd6:	e9d4 6700 	ldrd	r6, r7, [r4]
 800cbda:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800cbde:	4642      	mov	r2, r8
 800cbe0:	464b      	mov	r3, r9
 800cbe2:	f01b ffc1 	bl	8028b68 <__aeabi_dmul>
 800cbe6:	4632      	mov	r2, r6
 800cbe8:	463b      	mov	r3, r7
 800cbea:	f01b fe07 	bl	80287fc <__adddf3>
 800cbee:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (j = 0; j < n2; j++) {
 800cbf2:	45a2      	cmp	sl, r4
 800cbf4:	d1ef      	bne.n	800cbd6 <cblas_dgemm+0x4da>
 800cbf6:	e9dd 8907 	ldrd	r8, r9, [sp, #28]
 800cbfa:	e7c8      	b.n	800cb8e <cblas_dgemm+0x492>
    for (k = 0; k < K; k++) {
 800cbfc:	9a05      	ldr	r2, [sp, #20]
 800cbfe:	990c      	ldr	r1, [sp, #48]	; 0x30
 800cc00:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800cc02:	440a      	add	r2, r1
 800cc04:	9205      	str	r2, [sp, #20]
 800cc06:	9a01      	ldr	r2, [sp, #4]
 800cc08:	3301      	adds	r3, #1
 800cc0a:	429a      	cmp	r2, r3
 800cc0c:	930b      	str	r3, [sp, #44]	; 0x2c
 800cc0e:	d1b1      	bne.n	800cb74 <cblas_dgemm+0x478>
 800cc10:	e663      	b.n	800c8da <cblas_dgemm+0x1de>
 800cc12:	9a08      	ldr	r2, [sp, #32]
 800cc14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800cc16:	9304      	str	r3, [sp, #16]
 800cc18:	00d2      	lsls	r2, r2, #3
 800cc1a:	920a      	str	r2, [sp, #40]	; 0x28
 800cc1c:	9a01      	ldr	r2, [sp, #4]
    for (i = 0; i < n1; i++) {
 800cc1e:	9007      	str	r0, [sp, #28]
 800cc20:	eb03 06c2 	add.w	r6, r3, r2, lsl #3
 800cc24:	9b03      	ldr	r3, [sp, #12]
 800cc26:	9a06      	ldr	r2, [sp, #24]
 800cc28:	9008      	str	r0, [sp, #32]
 800cc2a:	00db      	lsls	r3, r3, #3
 800cc2c:	930b      	str	r3, [sp, #44]	; 0x2c
 800cc2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cc30:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
      for (j = 0; j < n2; j++) {
 800cc34:	9b06      	ldr	r3, [sp, #24]
 800cc36:	2b00      	cmp	r3, #0
 800cc38:	dd33      	ble.n	800cca2 <cblas_dgemm+0x5a6>
 800cc3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cc3c:	9a07      	ldr	r2, [sp, #28]
 800cc3e:	f04f 0800 	mov.w	r8, #0
 800cc42:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        for (k = 0; k < K; k++) {
 800cc46:	9b01      	ldr	r3, [sp, #4]
 800cc48:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800cc4a:	f04f 0400 	mov.w	r4, #0
 800cc4e:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800cc52:	dd14      	ble.n	800cc7e <cblas_dgemm+0x582>
 800cc54:	9b05      	ldr	r3, [sp, #20]
 800cc56:	f8dd a010 	ldr.w	sl, [sp, #16]
 800cc5a:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
          temp += F[ldf * i + k] * G[ldg * j + k];
 800cc5e:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800cc62:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 800cc66:	f01b ff7f 	bl	8028b68 <__aeabi_dmul>
 800cc6a:	4602      	mov	r2, r0
 800cc6c:	460b      	mov	r3, r1
 800cc6e:	4620      	mov	r0, r4
 800cc70:	4629      	mov	r1, r5
 800cc72:	f01b fdc3 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 800cc76:	4556      	cmp	r6, sl
          temp += F[ldf * i + k] * G[ldg * j + k];
 800cc78:	4604      	mov	r4, r0
 800cc7a:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800cc7c:	d1ef      	bne.n	800cc5e <cblas_dgemm+0x562>
        C[ldc * i + j] += alpha * temp;
 800cc7e:	4622      	mov	r2, r4
 800cc80:	462b      	mov	r3, r5
 800cc82:	e9d7 4500 	ldrd	r4, r5, [r7]
 800cc86:	ec51 0b18 	vmov	r0, r1, d8
 800cc8a:	f01b ff6d 	bl	8028b68 <__aeabi_dmul>
 800cc8e:	462b      	mov	r3, r5
 800cc90:	4622      	mov	r2, r4
 800cc92:	f01b fdb3 	bl	80287fc <__adddf3>
 800cc96:	e8e7 0102 	strd	r0, r1, [r7], #8
      for (j = 0; j < n2; j++) {
 800cc9a:	9b02      	ldr	r3, [sp, #8]
 800cc9c:	45b9      	cmp	r9, r7
 800cc9e:	4498      	add	r8, r3
 800cca0:	d1d1      	bne.n	800cc46 <cblas_dgemm+0x54a>
    for (i = 0; i < n1; i++) {
 800cca2:	9a07      	ldr	r2, [sp, #28]
 800cca4:	9903      	ldr	r1, [sp, #12]
 800cca6:	9b08      	ldr	r3, [sp, #32]
 800cca8:	440a      	add	r2, r1
 800ccaa:	9207      	str	r2, [sp, #28]
 800ccac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ccae:	9904      	ldr	r1, [sp, #16]
 800ccb0:	4491      	add	r9, r2
 800ccb2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ccb4:	4608      	mov	r0, r1
 800ccb6:	4410      	add	r0, r2
 800ccb8:	4416      	add	r6, r2
 800ccba:	9a00      	ldr	r2, [sp, #0]
 800ccbc:	9004      	str	r0, [sp, #16]
 800ccbe:	3301      	adds	r3, #1
 800ccc0:	429a      	cmp	r2, r3
 800ccc2:	9308      	str	r3, [sp, #32]
 800ccc4:	d1b6      	bne.n	800cc34 <cblas_dgemm+0x538>
 800ccc6:	e608      	b.n	800c8da <cblas_dgemm+0x1de>
    for (k = 0; k < K; k++) {
 800ccc8:	9b01      	ldr	r3, [sp, #4]
 800ccca:	2b00      	cmp	r3, #0
 800cccc:	f77f ae05 	ble.w	800c8da <cblas_dgemm+0x1de>
 800ccd0:	9b08      	ldr	r3, [sp, #32]
 800ccd2:	9a00      	ldr	r2, [sp, #0]
 800ccd4:	900e      	str	r0, [sp, #56]	; 0x38
 800ccd6:	00db      	lsls	r3, r3, #3
 800ccd8:	930f      	str	r3, [sp, #60]	; 0x3c
 800ccda:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ccdc:	e9cd 000b 	strd	r0, r0, [sp, #44]	; 0x2c
 800cce0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cce4:	9307      	str	r3, [sp, #28]
      for (i = 0; i < n1; i++) {
 800cce6:	9b00      	ldr	r3, [sp, #0]
 800cce8:	2b00      	cmp	r3, #0
 800ccea:	dd3f      	ble.n	800cd6c <cblas_dgemm+0x670>
 800ccec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ccee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800ccf0:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
 800ccf4:	9b05      	ldr	r3, [sp, #20]
 800ccf6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ccf8:	f8cd a010 	str.w	sl, [sp, #16]
 800ccfc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cd00:	930d      	str	r3, [sp, #52]	; 0x34
 800cd02:	2300      	movs	r3, #0
 800cd04:	4699      	mov	r9, r3
 800cd06:	e005      	b.n	800cd14 <cblas_dgemm+0x618>
 800cd08:	9b03      	ldr	r3, [sp, #12]
 800cd0a:	9a04      	ldr	r2, [sp, #16]
 800cd0c:	4499      	add	r9, r3
 800cd0e:	9b07      	ldr	r3, [sp, #28]
 800cd10:	4293      	cmp	r3, r2
 800cd12:	d02b      	beq.n	800cd6c <cblas_dgemm+0x670>
        const BASE temp = alpha * F[ldf * k + i];
 800cd14:	9c04      	ldr	r4, [sp, #16]
 800cd16:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800cd1a:	ec53 2b18 	vmov	r2, r3, d8
 800cd1e:	9404      	str	r4, [sp, #16]
 800cd20:	f01b ff22 	bl	8028b68 <__aeabi_dmul>
        if (temp != 0.0) {
 800cd24:	2200      	movs	r2, #0
 800cd26:	2300      	movs	r3, #0
        const BASE temp = alpha * F[ldf * k + i];
 800cd28:	4682      	mov	sl, r0
 800cd2a:	468b      	mov	fp, r1
        if (temp != 0.0) {
 800cd2c:	f01c f984 	bl	8029038 <__aeabi_dcmpeq>
 800cd30:	2800      	cmp	r0, #0
 800cd32:	d1e9      	bne.n	800cd08 <cblas_dgemm+0x60c>
          for (j = 0; j < n2; j++) {
 800cd34:	9b06      	ldr	r3, [sp, #24]
 800cd36:	2b00      	cmp	r3, #0
 800cd38:	dde6      	ble.n	800cd08 <cblas_dgemm+0x60c>
 800cd3a:	eb03 0809 	add.w	r8, r3, r9
 800cd3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800cd40:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800cd42:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 800cd46:	eb03 04c9 	add.w	r4, r3, r9, lsl #3
            C[ldc * i + j] += temp * G[ldg * k + j];
 800cd4a:	e9d4 6700 	ldrd	r6, r7, [r4]
 800cd4e:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800cd52:	4652      	mov	r2, sl
 800cd54:	465b      	mov	r3, fp
 800cd56:	f01b ff07 	bl	8028b68 <__aeabi_dmul>
 800cd5a:	4632      	mov	r2, r6
 800cd5c:	463b      	mov	r3, r7
 800cd5e:	f01b fd4d 	bl	80287fc <__adddf3>
 800cd62:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (j = 0; j < n2; j++) {
 800cd66:	4544      	cmp	r4, r8
 800cd68:	d1ef      	bne.n	800cd4a <cblas_dgemm+0x64e>
 800cd6a:	e7cd      	b.n	800cd08 <cblas_dgemm+0x60c>
    for (k = 0; k < K; k++) {
 800cd6c:	9a07      	ldr	r2, [sp, #28]
 800cd6e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800cd70:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cd72:	440a      	add	r2, r1
 800cd74:	9207      	str	r2, [sp, #28]
 800cd76:	9908      	ldr	r1, [sp, #32]
 800cd78:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800cd7a:	440a      	add	r2, r1
 800cd7c:	920c      	str	r2, [sp, #48]	; 0x30
 800cd7e:	9902      	ldr	r1, [sp, #8]
 800cd80:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800cd82:	440a      	add	r2, r1
 800cd84:	920b      	str	r2, [sp, #44]	; 0x2c
 800cd86:	9a01      	ldr	r2, [sp, #4]
 800cd88:	3301      	adds	r3, #1
 800cd8a:	429a      	cmp	r2, r3
 800cd8c:	930e      	str	r3, [sp, #56]	; 0x38
 800cd8e:	d1aa      	bne.n	800cce6 <cblas_dgemm+0x5ea>
 800cd90:	e5a3      	b.n	800c8da <cblas_dgemm+0x1de>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800cd92:	2270      	movs	r2, #112	; 0x70
 800cd94:	e6ac      	b.n	800caf0 <cblas_dgemm+0x3f4>
 800cd96:	bf00      	nop

0800cd98 <cblas_dgemv>:
void
cblas_dgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const double alpha, const double *A,
             const int lda, const double *X, const int incX,
             const double beta, double *Y, const int incY)
{
 800cd98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cd9c:	ed2d 8b02 	vpush	{d8}
 800cda0:	eeb0 8a40 	vmov.f32	s16, s0
 800cda4:	eef0 8a60 	vmov.f32	s17, s1
 800cda8:	b08b      	sub	sp, #44	; 0x2c
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 800cdaa:	2971      	cmp	r1, #113	; 0x71
 800cdac:	9301      	str	r3, [sp, #4]
 800cdae:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800cdb0:	9304      	str	r3, [sp, #16]
 800cdb2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800cdb4:	9302      	str	r3, [sp, #8]
 800cdb6:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800cdb8:	9306      	str	r3, [sp, #24]
 800cdba:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800cdbc:	9303      	str	r3, [sp, #12]
 800cdbe:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800cdc0:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 800cdc2:	9305      	str	r3, [sp, #20]
 800cdc4:	ec5b ab11 	vmov	sl, fp, d1
 800cdc8:	4605      	mov	r5, r0
 800cdca:	4690      	mov	r8, r2
 800cdcc:	f000 80f0 	beq.w	800cfb0 <cblas_dgemv+0x218>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800cdd0:	f1a1 036f 	sub.w	r3, r1, #111	; 0x6f
 800cdd4:	2b02      	cmp	r3, #2
 800cdd6:	460c      	mov	r4, r1
 800cdd8:	f240 811f 	bls.w	800d01a <cblas_dgemv+0x282>
 800cddc:	2002      	movs	r0, #2
 800cdde:	9b01      	ldr	r3, [sp, #4]
 800cde0:	f1b8 0f00 	cmp.w	r8, #0
 800cde4:	bfb8      	it	lt
 800cde6:	2003      	movlt	r0, #3
 800cde8:	2b00      	cmp	r3, #0
 800cdea:	bfb8      	it	lt
 800cdec:	2004      	movlt	r0, #4
 800cdee:	2d65      	cmp	r5, #101	; 0x65
 800cdf0:	f000 80c8 	beq.w	800cf84 <cblas_dgemv+0x1ec>
 800cdf4:	2d66      	cmp	r5, #102	; 0x66
 800cdf6:	f000 80c4 	beq.w	800cf82 <cblas_dgemv+0x1ea>
 800cdfa:	9b03      	ldr	r3, [sp, #12]
 800cdfc:	2b00      	cmp	r3, #0
 800cdfe:	f040 80d1 	bne.w	800cfa4 <cblas_dgemv+0x20c>
 800ce02:	2f00      	cmp	r7, #0
 800ce04:	bf14      	ite	ne
 800ce06:	2009      	movne	r0, #9
 800ce08:	200c      	moveq	r0, #12
 800ce0a:	4abf      	ldr	r2, [pc, #764]	; (800d108 <cblas_dgemv+0x370>)
 800ce0c:	49bf      	ldr	r1, [pc, #764]	; (800d10c <cblas_dgemv+0x374>)
 800ce0e:	f01b fc7b 	bl	8028708 <cblas_xerbla>
  if (M == 0 || N == 0)
 800ce12:	f1b8 0f00 	cmp.w	r8, #0
 800ce16:	f000 80af 	beq.w	800cf78 <cblas_dgemv+0x1e0>
 800ce1a:	9b01      	ldr	r3, [sp, #4]
 800ce1c:	2b00      	cmp	r3, #0
 800ce1e:	f000 80ab 	beq.w	800cf78 <cblas_dgemv+0x1e0>
  if (alpha == 0.0 && beta == 1.0)
 800ce22:	ec51 0b18 	vmov	r0, r1, d8
 800ce26:	2200      	movs	r2, #0
 800ce28:	2300      	movs	r3, #0
 800ce2a:	f01c f905 	bl	8029038 <__aeabi_dcmpeq>
 800ce2e:	b140      	cbz	r0, 800ce42 <cblas_dgemv+0xaa>
 800ce30:	4bb7      	ldr	r3, [pc, #732]	; (800d110 <cblas_dgemv+0x378>)
 800ce32:	2200      	movs	r2, #0
 800ce34:	4650      	mov	r0, sl
 800ce36:	4659      	mov	r1, fp
 800ce38:	f01c f8fe 	bl	8029038 <__aeabi_dcmpeq>
 800ce3c:	2800      	cmp	r0, #0
 800ce3e:	f040 809b 	bne.w	800cf78 <cblas_dgemv+0x1e0>
  if (Trans == CblasNoTrans) {
 800ce42:	2c6f      	cmp	r4, #111	; 0x6f
 800ce44:	d003      	beq.n	800ce4e <cblas_dgemv+0xb6>
 800ce46:	9b01      	ldr	r3, [sp, #4]
 800ce48:	f8cd 8004 	str.w	r8, [sp, #4]
 800ce4c:	4698      	mov	r8, r3
  if (beta == 0.0) {
 800ce4e:	2200      	movs	r2, #0
 800ce50:	2300      	movs	r3, #0
 800ce52:	4650      	mov	r0, sl
 800ce54:	4659      	mov	r1, fp
 800ce56:	f01c f8ef 	bl	8029038 <__aeabi_dcmpeq>
 800ce5a:	2800      	cmp	r0, #0
 800ce5c:	f000 80af 	beq.w	800cfbe <cblas_dgemv+0x226>
    INDEX iy = OFFSET(lenY, incY);
 800ce60:	2f00      	cmp	r7, #0
 800ce62:	f340 8145 	ble.w	800d0f0 <cblas_dgemv+0x358>
 800ce66:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 800ce68:	f1b8 0f00 	cmp.w	r8, #0
 800ce6c:	dd0c      	ble.n	800ce88 <cblas_dgemv+0xf0>
 800ce6e:	9a05      	ldr	r2, [sp, #20]
      Y[iy] = 0.0;
 800ce70:	ed9f 7ba3 	vldr	d7, [pc, #652]	; 800d100 <cblas_dgemv+0x368>
 800ce74:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800ce78:	00f9      	lsls	r1, r7, #3
    for (i = 0; i < lenY; i++) {
 800ce7a:	2200      	movs	r2, #0
 800ce7c:	3201      	adds	r2, #1
 800ce7e:	4590      	cmp	r8, r2
      Y[iy] = 0.0;
 800ce80:	ed83 7b00 	vstr	d7, [r3]
    for (i = 0; i < lenY; i++) {
 800ce84:	440b      	add	r3, r1
 800ce86:	d1f9      	bne.n	800ce7c <cblas_dgemv+0xe4>
  if (alpha == 0.0)
 800ce88:	ec51 0b18 	vmov	r0, r1, d8
 800ce8c:	2200      	movs	r2, #0
 800ce8e:	2300      	movs	r3, #0
 800ce90:	f01c f8d2 	bl	8029038 <__aeabi_dcmpeq>
 800ce94:	2800      	cmp	r0, #0
 800ce96:	d16f      	bne.n	800cf78 <cblas_dgemv+0x1e0>
  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 800ce98:	2d65      	cmp	r5, #101	; 0x65
 800ce9a:	f000 80c6 	beq.w	800d02a <cblas_dgemv+0x292>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 800ce9e:	2d66      	cmp	r5, #102	; 0x66
 800cea0:	d009      	beq.n	800ceb6 <cblas_dgemv+0x11e>
    BLAS_ERROR("unrecognized operation");
 800cea2:	4a9c      	ldr	r2, [pc, #624]	; (800d114 <cblas_dgemv+0x37c>)
 800cea4:	4999      	ldr	r1, [pc, #612]	; (800d10c <cblas_dgemv+0x374>)
 800cea6:	2000      	movs	r0, #0
#define BASE double
#include "source_gemv_r.h"
#undef BASE
}
 800cea8:	b00b      	add	sp, #44	; 0x2c
 800ceaa:	ecbd 8b02 	vpop	{d8}
 800ceae:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ceb2:	f01b bc29 	b.w	8028708 <cblas_xerbla>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 800ceb6:	2c70      	cmp	r4, #112	; 0x70
 800ceb8:	f040 812e 	bne.w	800d118 <cblas_dgemv+0x380>
    INDEX iy = OFFSET(lenY, incY);
 800cebc:	2f00      	cmp	r7, #0
 800cebe:	f340 812f 	ble.w	800d120 <cblas_dgemv+0x388>
 800cec2:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 800cec4:	f1b8 0f00 	cmp.w	r8, #0
 800cec8:	dd56      	ble.n	800cf78 <cblas_dgemv+0x1e0>
 800ceca:	00fd      	lsls	r5, r7, #3
 800cecc:	9903      	ldr	r1, [sp, #12]
 800cece:	9801      	ldr	r0, [sp, #4]
 800ced0:	9507      	str	r5, [sp, #28]
 800ced2:	9d05      	ldr	r5, [sp, #20]
 800ced4:	f1c0 0201 	rsb	r2, r0, #1
 800ced8:	2900      	cmp	r1, #0
 800ceda:	eb05 0bc3 	add.w	fp, r5, r3, lsl #3
 800cede:	9b06      	ldr	r3, [sp, #24]
 800cee0:	f8cd 8018 	str.w	r8, [sp, #24]
 800cee4:	fb02 f201 	mul.w	r2, r2, r1
 800cee8:	bfc8      	it	gt
 800ceea:	2200      	movgt	r2, #0
 800ceec:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800cef0:	9308      	str	r3, [sp, #32]
 800cef2:	9b02      	ldr	r3, [sp, #8]
 800cef4:	00db      	lsls	r3, r3, #3
 800cef6:	9305      	str	r3, [sp, #20]
 800cef8:	9b04      	ldr	r3, [sp, #16]
      INDEX ix = OFFSET(lenX, incX);
 800cefa:	2400      	movs	r4, #0
 800cefc:	9403      	str	r4, [sp, #12]
 800cefe:	ea4f 0ac1 	mov.w	sl, r1, lsl #3
 800cf02:	eb03 09c0 	add.w	r9, r3, r0, lsl #3
 800cf06:	46a0      	mov	r8, r4
      for (j = 0; j < lenX; j++) {
 800cf08:	9b01      	ldr	r3, [sp, #4]
 800cf0a:	2b00      	cmp	r3, #0
 800cf0c:	f04f 0400 	mov.w	r4, #0
 800cf10:	f04f 0500 	mov.w	r5, #0
 800cf14:	dd15      	ble.n	800cf42 <cblas_dgemv+0x1aa>
 800cf16:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 800cf1a:	9e08      	ldr	r6, [sp, #32]
 800cf1c:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        temp += X[ix] * A[lda * i + j];
 800cf20:	e9d6 2300 	ldrd	r2, r3, [r6]
 800cf24:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 800cf28:	f01b fe1e 	bl	8028b68 <__aeabi_dmul>
 800cf2c:	4602      	mov	r2, r0
 800cf2e:	460b      	mov	r3, r1
 800cf30:	4620      	mov	r0, r4
 800cf32:	4629      	mov	r1, r5
 800cf34:	f01b fc62 	bl	80287fc <__adddf3>
      for (j = 0; j < lenX; j++) {
 800cf38:	45b9      	cmp	r9, r7
 800cf3a:	4456      	add	r6, sl
        temp += X[ix] * A[lda * i + j];
 800cf3c:	4604      	mov	r4, r0
 800cf3e:	460d      	mov	r5, r1
      for (j = 0; j < lenX; j++) {
 800cf40:	d1ee      	bne.n	800cf20 <cblas_dgemv+0x188>
      Y[iy] += alpha * temp;
 800cf42:	4622      	mov	r2, r4
 800cf44:	462b      	mov	r3, r5
 800cf46:	ec51 0b18 	vmov	r0, r1, d8
 800cf4a:	f01b fe0d 	bl	8028b68 <__aeabi_dmul>
 800cf4e:	4602      	mov	r2, r0
 800cf50:	460b      	mov	r3, r1
 800cf52:	e9db 0100 	ldrd	r0, r1, [fp]
 800cf56:	f01b fc51 	bl	80287fc <__adddf3>
 800cf5a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800cf5e:	4413      	add	r3, r2
 800cf60:	9303      	str	r3, [sp, #12]
 800cf62:	9b05      	ldr	r3, [sp, #20]
 800cf64:	4499      	add	r9, r3
 800cf66:	9b07      	ldr	r3, [sp, #28]
 800cf68:	e9cb 0100 	strd	r0, r1, [fp]
    for (i = 0; i < lenY; i++) {
 800cf6c:	449b      	add	fp, r3
 800cf6e:	9b06      	ldr	r3, [sp, #24]
 800cf70:	f108 0801 	add.w	r8, r8, #1
 800cf74:	4543      	cmp	r3, r8
 800cf76:	d1c7      	bne.n	800cf08 <cblas_dgemv+0x170>
 800cf78:	b00b      	add	sp, #44	; 0x2c
 800cf7a:	ecbd 8b02 	vpop	{d8}
 800cf7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800cf82:	4643      	mov	r3, r8
 800cf84:	2b01      	cmp	r3, #1
 800cf86:	9a02      	ldr	r2, [sp, #8]
 800cf88:	bfb8      	it	lt
 800cf8a:	2301      	movlt	r3, #1
 800cf8c:	4293      	cmp	r3, r2
 800cf8e:	f77f af34 	ble.w	800cdfa <cblas_dgemv+0x62>
 800cf92:	9b03      	ldr	r3, [sp, #12]
 800cf94:	2b00      	cmp	r3, #0
 800cf96:	f43f af34 	beq.w	800ce02 <cblas_dgemv+0x6a>
 800cf9a:	2f00      	cmp	r7, #0
 800cf9c:	bf14      	ite	ne
 800cf9e:	2007      	movne	r0, #7
 800cfa0:	200c      	moveq	r0, #12
 800cfa2:	e732      	b.n	800ce0a <cblas_dgemv+0x72>
 800cfa4:	2f00      	cmp	r7, #0
 800cfa6:	d03e      	beq.n	800d026 <cblas_dgemv+0x28e>
 800cfa8:	2800      	cmp	r0, #0
 800cfaa:	f43f af32 	beq.w	800ce12 <cblas_dgemv+0x7a>
 800cfae:	e72c      	b.n	800ce0a <cblas_dgemv+0x72>
 800cfb0:	3865      	subs	r0, #101	; 0x65
 800cfb2:	2801      	cmp	r0, #1
 800cfb4:	bf94      	ite	ls
 800cfb6:	2000      	movls	r0, #0
 800cfb8:	2001      	movhi	r0, #1
 800cfba:	2470      	movs	r4, #112	; 0x70
 800cfbc:	e70f      	b.n	800cdde <cblas_dgemv+0x46>
  } else if (beta != 1.0) {
 800cfbe:	4b54      	ldr	r3, [pc, #336]	; (800d110 <cblas_dgemv+0x378>)
 800cfc0:	2200      	movs	r2, #0
 800cfc2:	4650      	mov	r0, sl
 800cfc4:	4659      	mov	r1, fp
 800cfc6:	f01c f837 	bl	8029038 <__aeabi_dcmpeq>
 800cfca:	2800      	cmp	r0, #0
 800cfcc:	f47f af5c 	bne.w	800ce88 <cblas_dgemv+0xf0>
    INDEX iy = OFFSET(lenY, incY);
 800cfd0:	2f00      	cmp	r7, #0
 800cfd2:	dc03      	bgt.n	800cfdc <cblas_dgemv+0x244>
 800cfd4:	f1c8 0001 	rsb	r0, r8, #1
 800cfd8:	fb00 f007 	mul.w	r0, r0, r7
    for (i = 0; i < lenY; i++) {
 800cfdc:	f1b8 0f00 	cmp.w	r8, #0
 800cfe0:	f77f af52 	ble.w	800ce88 <cblas_dgemv+0xf0>
 800cfe4:	9b05      	ldr	r3, [sp, #20]
 800cfe6:	9707      	str	r7, [sp, #28]
 800cfe8:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
 800cfec:	00fb      	lsls	r3, r7, #3
 800cfee:	f04f 0900 	mov.w	r9, #0
 800cff2:	462f      	mov	r7, r5
 800cff4:	4625      	mov	r5, r4
 800cff6:	461c      	mov	r4, r3
      Y[iy] *= beta;
 800cff8:	e9d6 0100 	ldrd	r0, r1, [r6]
 800cffc:	4652      	mov	r2, sl
 800cffe:	465b      	mov	r3, fp
 800d000:	f01b fdb2 	bl	8028b68 <__aeabi_dmul>
    for (i = 0; i < lenY; i++) {
 800d004:	f109 0901 	add.w	r9, r9, #1
 800d008:	45c8      	cmp	r8, r9
      Y[iy] *= beta;
 800d00a:	e9c6 0100 	strd	r0, r1, [r6]
    for (i = 0; i < lenY; i++) {
 800d00e:	4426      	add	r6, r4
 800d010:	d1f2      	bne.n	800cff8 <cblas_dgemv+0x260>
 800d012:	462c      	mov	r4, r5
 800d014:	463d      	mov	r5, r7
 800d016:	9f07      	ldr	r7, [sp, #28]
 800d018:	e736      	b.n	800ce88 <cblas_dgemv+0xf0>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800d01a:	3865      	subs	r0, #101	; 0x65
 800d01c:	2801      	cmp	r0, #1
 800d01e:	bf94      	ite	ls
 800d020:	2000      	movls	r0, #0
 800d022:	2001      	movhi	r0, #1
 800d024:	e6db      	b.n	800cdde <cblas_dgemv+0x46>
 800d026:	200c      	movs	r0, #12
 800d028:	e6ef      	b.n	800ce0a <cblas_dgemv+0x72>
  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 800d02a:	2c6f      	cmp	r4, #111	; 0x6f
 800d02c:	f43f af46 	beq.w	800cebc <cblas_dgemv+0x124>
  } else if ((order == CblasRowMajor && Trans == CblasTrans)
 800d030:	2c70      	cmp	r4, #112	; 0x70
 800d032:	f47f af36 	bne.w	800cea2 <cblas_dgemv+0x10a>
    INDEX ix = OFFSET(lenX, incX);
 800d036:	9b03      	ldr	r3, [sp, #12]
 800d038:	2b00      	cmp	r3, #0
 800d03a:	dd76      	ble.n	800d12a <cblas_dgemv+0x392>
 800d03c:	2500      	movs	r5, #0
    for (j = 0; j < lenX; j++) {
 800d03e:	9b01      	ldr	r3, [sp, #4]
 800d040:	2b00      	cmp	r3, #0
 800d042:	dd99      	ble.n	800cf78 <cblas_dgemv+0x1e0>
 800d044:	9903      	ldr	r1, [sp, #12]
 800d046:	f8cd 801c 	str.w	r8, [sp, #28]
 800d04a:	00c9      	lsls	r1, r1, #3
 800d04c:	9103      	str	r1, [sp, #12]
 800d04e:	9906      	ldr	r1, [sp, #24]
 800d050:	f1c8 0301 	rsb	r3, r8, #1
 800d054:	2f00      	cmp	r7, #0
 800d056:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
 800d05a:	9905      	ldr	r1, [sp, #20]
 800d05c:	fb03 f307 	mul.w	r3, r3, r7
 800d060:	bfc8      	it	gt
 800d062:	2300      	movgt	r3, #0
 800d064:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800d068:	9308      	str	r3, [sp, #32]
 800d06a:	00fb      	lsls	r3, r7, #3
 800d06c:	9309      	str	r3, [sp, #36]	; 0x24
 800d06e:	9b02      	ldr	r3, [sp, #8]
 800d070:	00db      	lsls	r3, r3, #3
 800d072:	9305      	str	r3, [sp, #20]
 800d074:	9b04      	ldr	r3, [sp, #16]
        INDEX iy = OFFSET(lenY, incY);
 800d076:	2200      	movs	r2, #0
 800d078:	eb03 04c8 	add.w	r4, r3, r8, lsl #3
 800d07c:	4691      	mov	r9, r2
 800d07e:	4690      	mov	r8, r2
 800d080:	e00b      	b.n	800d09a <cblas_dgemv+0x302>
    for (j = 0; j < lenX; j++) {
 800d082:	9b03      	ldr	r3, [sp, #12]
 800d084:	441d      	add	r5, r3
 800d086:	9b02      	ldr	r3, [sp, #8]
 800d088:	4498      	add	r8, r3
 800d08a:	9b05      	ldr	r3, [sp, #20]
 800d08c:	441c      	add	r4, r3
 800d08e:	9b01      	ldr	r3, [sp, #4]
 800d090:	f109 0901 	add.w	r9, r9, #1
 800d094:	454b      	cmp	r3, r9
 800d096:	f43f af6f 	beq.w	800cf78 <cblas_dgemv+0x1e0>
      const BASE temp = alpha * X[ix];
 800d09a:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d09e:	ec51 0b18 	vmov	r0, r1, d8
 800d0a2:	f01b fd61 	bl	8028b68 <__aeabi_dmul>
      if (temp != 0.0) {
 800d0a6:	2200      	movs	r2, #0
 800d0a8:	2300      	movs	r3, #0
      const BASE temp = alpha * X[ix];
 800d0aa:	4606      	mov	r6, r0
 800d0ac:	460f      	mov	r7, r1
      if (temp != 0.0) {
 800d0ae:	f01b ffc3 	bl	8029038 <__aeabi_dcmpeq>
 800d0b2:	2800      	cmp	r0, #0
 800d0b4:	d1e5      	bne.n	800d082 <cblas_dgemv+0x2ea>
        for (i = 0; i < lenY; i++) {
 800d0b6:	9b07      	ldr	r3, [sp, #28]
 800d0b8:	2b00      	cmp	r3, #0
 800d0ba:	dde2      	ble.n	800d082 <cblas_dgemv+0x2ea>
 800d0bc:	9b04      	ldr	r3, [sp, #16]
 800d0be:	9506      	str	r5, [sp, #24]
 800d0c0:	f8dd a020 	ldr.w	sl, [sp, #32]
 800d0c4:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800d0c6:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
          Y[iy] += temp * A[lda * j + i];
 800d0ca:	e8fb 0102 	ldrd	r0, r1, [fp], #8
 800d0ce:	4632      	mov	r2, r6
 800d0d0:	463b      	mov	r3, r7
 800d0d2:	f01b fd49 	bl	8028b68 <__aeabi_dmul>
 800d0d6:	4602      	mov	r2, r0
 800d0d8:	460b      	mov	r3, r1
 800d0da:	e9da 0100 	ldrd	r0, r1, [sl]
 800d0de:	f01b fb8d 	bl	80287fc <__adddf3>
        for (i = 0; i < lenY; i++) {
 800d0e2:	45a3      	cmp	fp, r4
          Y[iy] += temp * A[lda * j + i];
 800d0e4:	e9ca 0100 	strd	r0, r1, [sl]
        for (i = 0; i < lenY; i++) {
 800d0e8:	44aa      	add	sl, r5
 800d0ea:	d1ee      	bne.n	800d0ca <cblas_dgemv+0x332>
 800d0ec:	9d06      	ldr	r5, [sp, #24]
 800d0ee:	e7c8      	b.n	800d082 <cblas_dgemv+0x2ea>
    INDEX iy = OFFSET(lenY, incY);
 800d0f0:	f1c8 0301 	rsb	r3, r8, #1
 800d0f4:	fb03 f307 	mul.w	r3, r3, r7
 800d0f8:	e6b6      	b.n	800ce68 <cblas_dgemv+0xd0>
 800d0fa:	bf00      	nop
 800d0fc:	f3af 8000 	nop.w
	...
 800d108:	08031108 	.word	0x08031108
 800d10c:	080311d0 	.word	0x080311d0
 800d110:	3ff00000 	.word	0x3ff00000
 800d114:	080311b8 	.word	0x080311b8
             || (order == CblasColMajor && Trans == CblasNoTrans)) {
 800d118:	2c6f      	cmp	r4, #111	; 0x6f
 800d11a:	f47f aec2 	bne.w	800cea2 <cblas_dgemv+0x10a>
 800d11e:	e78a      	b.n	800d036 <cblas_dgemv+0x29e>
    INDEX iy = OFFSET(lenY, incY);
 800d120:	f1c8 0301 	rsb	r3, r8, #1
 800d124:	fb03 f307 	mul.w	r3, r3, r7
 800d128:	e6cc      	b.n	800cec4 <cblas_dgemv+0x12c>
    INDEX ix = OFFSET(lenX, incX);
 800d12a:	9a01      	ldr	r2, [sp, #4]
 800d12c:	f1c2 0501 	rsb	r5, r2, #1
 800d130:	fb05 f503 	mul.w	r5, r5, r3
 800d134:	e783      	b.n	800d03e <cblas_dgemv+0x2a6>
 800d136:	bf00      	nop

0800d138 <cblas_dger>:

void
cblas_dger (const enum CBLAS_ORDER order, const int M, const int N,
            const double alpha, const double *X, const int incX,
            const double *Y, const int incY, double *A, const int lda)
{
 800d138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d13c:	ed2d 8b02 	vpush	{d8}
 800d140:	eeb0 8a40 	vmov.f32	s16, s0
 800d144:	eef0 8a60 	vmov.f32	s17, s1
 800d148:	b08b      	sub	sp, #44	; 0x2c
 800d14a:	461e      	mov	r6, r3
 800d14c:	e9dd 4318 	ldrd	r4, r3, [sp, #96]	; 0x60
 800d150:	9305      	str	r3, [sp, #20]
 800d152:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800d154:	9303      	str	r3, [sp, #12]
 800d156:	1e0b      	subs	r3, r1, #0
 800d158:	e9dd 5716 	ldrd	r5, r7, [sp, #88]	; 0x58
 800d15c:	4680      	mov	r8, r0
 800d15e:	9201      	str	r2, [sp, #4]
 800d160:	9304      	str	r3, [sp, #16]
 800d162:	f2c0 8095 	blt.w	800d290 <cblas_dger+0x158>
 800d166:	3865      	subs	r0, #101	; 0x65
 800d168:	2801      	cmp	r0, #1
 800d16a:	bf94      	ite	ls
 800d16c:	2000      	movls	r0, #0
 800d16e:	2001      	movhi	r0, #1
 800d170:	9b01      	ldr	r3, [sp, #4]
 800d172:	2b00      	cmp	r3, #0
 800d174:	bfb8      	it	lt
 800d176:	2003      	movlt	r0, #3
 800d178:	2d00      	cmp	r5, #0
 800d17a:	d174      	bne.n	800d266 <cblas_dger+0x12e>
 800d17c:	2c00      	cmp	r4, #0
 800d17e:	d168      	bne.n	800d252 <cblas_dger+0x11a>
 800d180:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800d184:	f000 8086 	beq.w	800d294 <cblas_dger+0x15c>
 800d188:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800d18c:	f000 8106 	beq.w	800d39c <cblas_dger+0x264>
 800d190:	2008      	movs	r0, #8
 800d192:	4a95      	ldr	r2, [pc, #596]	; (800d3e8 <cblas_dger+0x2b0>)
 800d194:	4995      	ldr	r1, [pc, #596]	; (800d3ec <cblas_dger+0x2b4>)
 800d196:	f01b fab7 	bl	8028708 <cblas_xerbla>
  } else if (order == CblasColMajor) {
 800d19a:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800d19e:	d16d      	bne.n	800d27c <cblas_dger+0x144>
    INDEX jy = OFFSET(N, incY);
 800d1a0:	2c00      	cmp	r4, #0
 800d1a2:	f340 80dc 	ble.w	800d35e <cblas_dger+0x226>
 800d1a6:	2300      	movs	r3, #0
    for (j = 0; j < N; j++) {
 800d1a8:	9a01      	ldr	r2, [sp, #4]
 800d1aa:	2a00      	cmp	r2, #0
 800d1ac:	dd4c      	ble.n	800d248 <cblas_dger+0x110>
 800d1ae:	9904      	ldr	r1, [sp, #16]
 800d1b0:	2d00      	cmp	r5, #0
 800d1b2:	f1c1 0201 	rsb	r2, r1, #1
 800d1b6:	fb02 f205 	mul.w	r2, r2, r5
 800d1ba:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 800d1be:	bfc8      	it	gt
 800d1c0:	2200      	movgt	r2, #0
 800d1c2:	9300      	str	r3, [sp, #0]
 800d1c4:	eb06 03c2 	add.w	r3, r6, r2, lsl #3
 800d1c8:	9309      	str	r3, [sp, #36]	; 0x24
 800d1ca:	9b03      	ldr	r3, [sp, #12]
 800d1cc:	00db      	lsls	r3, r3, #3
 800d1ce:	9308      	str	r3, [sp, #32]
 800d1d0:	9b05      	ldr	r3, [sp, #20]
      INDEX ix = OFFSET(M, incX);
 800d1d2:	2000      	movs	r0, #0
 800d1d4:	00e4      	lsls	r4, r4, #3
 800d1d6:	9002      	str	r0, [sp, #8]
 800d1d8:	9407      	str	r4, [sp, #28]
 800d1da:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
 800d1de:	9006      	str	r0, [sp, #24]
 800d1e0:	eb03 0bc1 	add.w	fp, r3, r1, lsl #3
      const BASE tmp = alpha * Y[jy];
 800d1e4:	9b00      	ldr	r3, [sp, #0]
 800d1e6:	ec51 0b18 	vmov	r0, r1, d8
 800d1ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d1ee:	f01b fcbb 	bl	8028b68 <__aeabi_dmul>
      for (i = 0; i < M; i++) {
 800d1f2:	9b04      	ldr	r3, [sp, #16]
 800d1f4:	2b00      	cmp	r3, #0
      const BASE tmp = alpha * Y[jy];
 800d1f6:	4680      	mov	r8, r0
 800d1f8:	4689      	mov	r9, r1
      for (i = 0; i < M; i++) {
 800d1fa:	dd15      	ble.n	800d228 <cblas_dger+0xf0>
 800d1fc:	9b05      	ldr	r3, [sp, #20]
 800d1fe:	9a02      	ldr	r2, [sp, #8]
 800d200:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800d202:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[i + lda * j] += X[ix] * tmp;
 800d206:	e9d4 6700 	ldrd	r6, r7, [r4]
 800d20a:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d20e:	4640      	mov	r0, r8
 800d210:	4649      	mov	r1, r9
 800d212:	f01b fca9 	bl	8028b68 <__aeabi_dmul>
 800d216:	4632      	mov	r2, r6
 800d218:	463b      	mov	r3, r7
 800d21a:	f01b faef 	bl	80287fc <__adddf3>
 800d21e:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (i = 0; i < M; i++) {
 800d222:	455c      	cmp	r4, fp
 800d224:	4455      	add	r5, sl
 800d226:	d1ee      	bne.n	800d206 <cblas_dger+0xce>
    for (j = 0; j < N; j++) {
 800d228:	9a00      	ldr	r2, [sp, #0]
 800d22a:	9907      	ldr	r1, [sp, #28]
 800d22c:	9b06      	ldr	r3, [sp, #24]
 800d22e:	440a      	add	r2, r1
 800d230:	9200      	str	r2, [sp, #0]
 800d232:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 800d236:	440a      	add	r2, r1
 800d238:	9202      	str	r2, [sp, #8]
 800d23a:	9a08      	ldr	r2, [sp, #32]
 800d23c:	4493      	add	fp, r2
 800d23e:	9a01      	ldr	r2, [sp, #4]
 800d240:	3301      	adds	r3, #1
 800d242:	429a      	cmp	r2, r3
 800d244:	9306      	str	r3, [sp, #24]
 800d246:	d1cd      	bne.n	800d1e4 <cblas_dger+0xac>
#define BASE double
#include "source_ger.h"
#undef BASE
}
 800d248:	b00b      	add	sp, #44	; 0x2c
 800d24a:	ecbd 8b02 	vpop	{d8}
 800d24e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800d252:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800d256:	f000 8091 	beq.w	800d37c <cblas_dger+0x244>
 800d25a:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800d25e:	f000 80b6 	beq.w	800d3ce <cblas_dger+0x296>
 800d262:	2006      	movs	r0, #6
 800d264:	e795      	b.n	800d192 <cblas_dger+0x5a>
 800d266:	2c00      	cmp	r4, #0
 800d268:	d08a      	beq.n	800d180 <cblas_dger+0x48>
 800d26a:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800d26e:	d07c      	beq.n	800d36a <cblas_dger+0x232>
 800d270:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800d274:	f000 80a0 	beq.w	800d3b8 <cblas_dger+0x280>
 800d278:	2800      	cmp	r0, #0
 800d27a:	d18a      	bne.n	800d192 <cblas_dger+0x5a>
    BLAS_ERROR("unrecognized operation");
 800d27c:	4a5c      	ldr	r2, [pc, #368]	; (800d3f0 <cblas_dger+0x2b8>)
 800d27e:	495b      	ldr	r1, [pc, #364]	; (800d3ec <cblas_dger+0x2b4>)
 800d280:	2000      	movs	r0, #0
 800d282:	b00b      	add	sp, #44	; 0x2c
 800d284:	ecbd 8b02 	vpop	{d8}
 800d288:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d28c:	f01b ba3c 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800d290:	2002      	movs	r0, #2
 800d292:	e76d      	b.n	800d170 <cblas_dger+0x38>
 800d294:	9801      	ldr	r0, [sp, #4]
 800d296:	9b03      	ldr	r3, [sp, #12]
 800d298:	2801      	cmp	r0, #1
 800d29a:	bfb8      	it	lt
 800d29c:	2001      	movlt	r0, #1
 800d29e:	4283      	cmp	r3, r0
 800d2a0:	bfac      	ite	ge
 800d2a2:	2008      	movge	r0, #8
 800d2a4:	200a      	movlt	r0, #10
 800d2a6:	4a50      	ldr	r2, [pc, #320]	; (800d3e8 <cblas_dger+0x2b0>)
 800d2a8:	4950      	ldr	r1, [pc, #320]	; (800d3ec <cblas_dger+0x2b4>)
 800d2aa:	f01b fa2d 	bl	8028708 <cblas_xerbla>
    INDEX ix = OFFSET(M, incX);
 800d2ae:	2d00      	cmp	r5, #0
 800d2b0:	dd6e      	ble.n	800d390 <cblas_dger+0x258>
 800d2b2:	2300      	movs	r3, #0
    for (i = 0; i < M; i++) {
 800d2b4:	9a04      	ldr	r2, [sp, #16]
 800d2b6:	2a00      	cmp	r2, #0
 800d2b8:	ddc6      	ble.n	800d248 <cblas_dger+0x110>
 800d2ba:	9901      	ldr	r1, [sp, #4]
 800d2bc:	2c00      	cmp	r4, #0
 800d2be:	f1c1 0201 	rsb	r2, r1, #1
 800d2c2:	fb02 f204 	mul.w	r2, r2, r4
 800d2c6:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 800d2ca:	bfc8      	it	gt
 800d2cc:	2200      	movgt	r2, #0
 800d2ce:	9300      	str	r3, [sp, #0]
 800d2d0:	eb07 03c2 	add.w	r3, r7, r2, lsl #3
 800d2d4:	9309      	str	r3, [sp, #36]	; 0x24
 800d2d6:	9b03      	ldr	r3, [sp, #12]
 800d2d8:	00db      	lsls	r3, r3, #3
 800d2da:	9307      	str	r3, [sp, #28]
 800d2dc:	9b05      	ldr	r3, [sp, #20]
      INDEX jy = OFFSET(N, incY);
 800d2de:	2000      	movs	r0, #0
 800d2e0:	00ed      	lsls	r5, r5, #3
 800d2e2:	9002      	str	r0, [sp, #8]
 800d2e4:	9508      	str	r5, [sp, #32]
 800d2e6:	ea4f 0ac4 	mov.w	sl, r4, lsl #3
 800d2ea:	9006      	str	r0, [sp, #24]
 800d2ec:	eb03 0bc1 	add.w	fp, r3, r1, lsl #3
      const BASE tmp = alpha * X[ix];
 800d2f0:	9b00      	ldr	r3, [sp, #0]
 800d2f2:	ec51 0b18 	vmov	r0, r1, d8
 800d2f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d2fa:	f01b fc35 	bl	8028b68 <__aeabi_dmul>
      for (j = 0; j < N; j++) {
 800d2fe:	9b01      	ldr	r3, [sp, #4]
 800d300:	2b00      	cmp	r3, #0
      const BASE tmp = alpha * X[ix];
 800d302:	4680      	mov	r8, r0
 800d304:	4689      	mov	r9, r1
      for (j = 0; j < N; j++) {
 800d306:	dd15      	ble.n	800d334 <cblas_dger+0x1fc>
 800d308:	9b05      	ldr	r3, [sp, #20]
 800d30a:	9a02      	ldr	r2, [sp, #8]
 800d30c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800d30e:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[lda * i + j] += Y[jy] * tmp;
 800d312:	e9d4 6700 	ldrd	r6, r7, [r4]
 800d316:	e9d5 2300 	ldrd	r2, r3, [r5]
 800d31a:	4640      	mov	r0, r8
 800d31c:	4649      	mov	r1, r9
 800d31e:	f01b fc23 	bl	8028b68 <__aeabi_dmul>
 800d322:	4632      	mov	r2, r6
 800d324:	463b      	mov	r3, r7
 800d326:	f01b fa69 	bl	80287fc <__adddf3>
 800d32a:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j < N; j++) {
 800d32e:	455c      	cmp	r4, fp
 800d330:	4455      	add	r5, sl
 800d332:	d1ee      	bne.n	800d312 <cblas_dger+0x1da>
    for (i = 0; i < M; i++) {
 800d334:	9a00      	ldr	r2, [sp, #0]
 800d336:	9908      	ldr	r1, [sp, #32]
 800d338:	9b06      	ldr	r3, [sp, #24]
 800d33a:	440a      	add	r2, r1
 800d33c:	9200      	str	r2, [sp, #0]
 800d33e:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 800d342:	440a      	add	r2, r1
 800d344:	9202      	str	r2, [sp, #8]
 800d346:	9a07      	ldr	r2, [sp, #28]
 800d348:	4493      	add	fp, r2
 800d34a:	9a04      	ldr	r2, [sp, #16]
 800d34c:	3301      	adds	r3, #1
 800d34e:	429a      	cmp	r2, r3
 800d350:	9306      	str	r3, [sp, #24]
 800d352:	d1cd      	bne.n	800d2f0 <cblas_dger+0x1b8>
 800d354:	b00b      	add	sp, #44	; 0x2c
 800d356:	ecbd 8b02 	vpop	{d8}
 800d35a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    INDEX jy = OFFSET(N, incY);
 800d35e:	9b01      	ldr	r3, [sp, #4]
 800d360:	f1c3 0301 	rsb	r3, r3, #1
 800d364:	fb03 f304 	mul.w	r3, r3, r4
 800d368:	e71e      	b.n	800d1a8 <cblas_dger+0x70>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800d36a:	9b01      	ldr	r3, [sp, #4]
 800d36c:	9a03      	ldr	r2, [sp, #12]
 800d36e:	2b01      	cmp	r3, #1
 800d370:	bfb8      	it	lt
 800d372:	2301      	movlt	r3, #1
 800d374:	4293      	cmp	r3, r2
 800d376:	dd32      	ble.n	800d3de <cblas_dger+0x2a6>
 800d378:	200a      	movs	r0, #10
 800d37a:	e794      	b.n	800d2a6 <cblas_dger+0x16e>
 800d37c:	4618      	mov	r0, r3
 800d37e:	2b01      	cmp	r3, #1
 800d380:	9b03      	ldr	r3, [sp, #12]
 800d382:	bfb8      	it	lt
 800d384:	2001      	movlt	r0, #1
 800d386:	4298      	cmp	r0, r3
 800d388:	bfcc      	ite	gt
 800d38a:	200a      	movgt	r0, #10
 800d38c:	2006      	movle	r0, #6
 800d38e:	e78a      	b.n	800d2a6 <cblas_dger+0x16e>
    INDEX ix = OFFSET(M, incX);
 800d390:	9b04      	ldr	r3, [sp, #16]
 800d392:	f1c3 0301 	rsb	r3, r3, #1
 800d396:	fb03 f305 	mul.w	r3, r3, r5
 800d39a:	e78b      	b.n	800d2b4 <cblas_dger+0x17c>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800d39c:	9b04      	ldr	r3, [sp, #16]
 800d39e:	9a03      	ldr	r2, [sp, #12]
 800d3a0:	2b01      	cmp	r3, #1
 800d3a2:	bfb8      	it	lt
 800d3a4:	2301      	movlt	r3, #1
 800d3a6:	4293      	cmp	r3, r2
 800d3a8:	f77f aef2 	ble.w	800d190 <cblas_dger+0x58>
 800d3ac:	4a0e      	ldr	r2, [pc, #56]	; (800d3e8 <cblas_dger+0x2b0>)
 800d3ae:	490f      	ldr	r1, [pc, #60]	; (800d3ec <cblas_dger+0x2b4>)
 800d3b0:	200a      	movs	r0, #10
 800d3b2:	f01b f9a9 	bl	8028708 <cblas_xerbla>
  if (order == CblasRowMajor) {
 800d3b6:	e6f3      	b.n	800d1a0 <cblas_dger+0x68>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800d3b8:	9b04      	ldr	r3, [sp, #16]
 800d3ba:	9a03      	ldr	r2, [sp, #12]
 800d3bc:	2b01      	cmp	r3, #1
 800d3be:	bfb8      	it	lt
 800d3c0:	2301      	movlt	r3, #1
 800d3c2:	4293      	cmp	r3, r2
 800d3c4:	dcf2      	bgt.n	800d3ac <cblas_dger+0x274>
 800d3c6:	2800      	cmp	r0, #0
 800d3c8:	f43f aeea 	beq.w	800d1a0 <cblas_dger+0x68>
 800d3cc:	e6e1      	b.n	800d192 <cblas_dger+0x5a>
 800d3ce:	9b04      	ldr	r3, [sp, #16]
 800d3d0:	9a03      	ldr	r2, [sp, #12]
 800d3d2:	2b01      	cmp	r3, #1
 800d3d4:	bfb8      	it	lt
 800d3d6:	2301      	movlt	r3, #1
 800d3d8:	429a      	cmp	r2, r3
 800d3da:	dbe7      	blt.n	800d3ac <cblas_dger+0x274>
 800d3dc:	e741      	b.n	800d262 <cblas_dger+0x12a>
 800d3de:	2800      	cmp	r0, #0
 800d3e0:	f43f af65 	beq.w	800d2ae <cblas_dger+0x176>
 800d3e4:	e75f      	b.n	800d2a6 <cblas_dger+0x16e>
 800d3e6:	bf00      	nop
 800d3e8:	08031108 	.word	0x08031108
 800d3ec:	080311e0 	.word	0x080311e0
 800d3f0:	080311b8 	.word	0x080311b8
 800d3f4:	00000000 	.word	0x00000000

0800d3f8 <cblas_dnrm2>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dnrm2 (const int N, const double *X, const int incX)
{
 800d3f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d3fc:	b085      	sub	sp, #20
  if (N <= 0 || incX <= 0) {
 800d3fe:	1e03      	subs	r3, r0, #0
 800d400:	9302      	str	r3, [sp, #8]
 800d402:	dd58      	ble.n	800d4b6 <cblas_dnrm2+0xbe>
 800d404:	2a00      	cmp	r2, #0
 800d406:	dd56      	ble.n	800d4b6 <cblas_dnrm2+0xbe>
  } else if (N == 1) {
 800d408:	2b01      	cmp	r3, #1
 800d40a:	d068      	beq.n	800d4de <cblas_dnrm2+0xe6>
  BASE ssq = 1.0;
 800d40c:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 800d4f8 <cblas_dnrm2+0x100>
 800d410:	00d3      	lsls	r3, r2, #3
 800d412:	ed8d 7b00 	vstr	d7, [sp]
  BASE scale = 0.0;
 800d416:	f04f 0800 	mov.w	r8, #0
 800d41a:	f04f 0900 	mov.w	r9, #0
 800d41e:	9303      	str	r3, [sp, #12]
 800d420:	460c      	mov	r4, r1
  for (i = 0; i < N; i++) {
 800d422:	2500      	movs	r5, #0
 800d424:	e019      	b.n	800d45a <cblas_dnrm2+0x62>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 800d426:	f01b fcc9 	bl	8028dbc <__aeabi_ddiv>
 800d42a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800d42e:	4606      	mov	r6, r0
 800d430:	460f      	mov	r7, r1
 800d432:	f01b fb99 	bl	8028b68 <__aeabi_dmul>
 800d436:	4632      	mov	r2, r6
 800d438:	463b      	mov	r3, r7
 800d43a:	f01b fb95 	bl	8028b68 <__aeabi_dmul>
 800d43e:	4b32      	ldr	r3, [pc, #200]	; (800d508 <cblas_dnrm2+0x110>)
 800d440:	2200      	movs	r2, #0
 800d442:	f01b f9db 	bl	80287fc <__adddf3>
 800d446:	e9cd 0100 	strd	r0, r1, [sp]
        scale = ax;
 800d44a:	46d0      	mov	r8, sl
 800d44c:	46d9      	mov	r9, fp
  for (i = 0; i < N; i++) {
 800d44e:	9b03      	ldr	r3, [sp, #12]
 800d450:	441c      	add	r4, r3
 800d452:	9b02      	ldr	r3, [sp, #8]
 800d454:	3501      	adds	r5, #1
 800d456:	42ab      	cmp	r3, r5
 800d458:	d032      	beq.n	800d4c0 <cblas_dnrm2+0xc8>
    const BASE x = X[ix];
 800d45a:	e9d4 6700 	ldrd	r6, r7, [r4]
    if (x != 0.0) {
 800d45e:	2200      	movs	r2, #0
 800d460:	2300      	movs	r3, #0
 800d462:	4630      	mov	r0, r6
 800d464:	4639      	mov	r1, r7
 800d466:	f01b fde7 	bl	8029038 <__aeabi_dcmpeq>
      if (scale < ax) {
 800d46a:	4642      	mov	r2, r8
 800d46c:	464b      	mov	r3, r9
    if (x != 0.0) {
 800d46e:	2800      	cmp	r0, #0
 800d470:	d1ed      	bne.n	800d44e <cblas_dnrm2+0x56>
      const BASE ax = fabs(x);
 800d472:	f027 4b00 	bic.w	fp, r7, #2147483648	; 0x80000000
      if (scale < ax) {
 800d476:	4659      	mov	r1, fp
 800d478:	4630      	mov	r0, r6
 800d47a:	f01b fe05 	bl	8029088 <__aeabi_dcmpgt>
 800d47e:	4684      	mov	ip, r0
      const BASE ax = fabs(x);
 800d480:	46b2      	mov	sl, r6
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 800d482:	4632      	mov	r2, r6
 800d484:	465b      	mov	r3, fp
 800d486:	4640      	mov	r0, r8
 800d488:	4649      	mov	r1, r9
      if (scale < ax) {
 800d48a:	f1bc 0f00 	cmp.w	ip, #0
 800d48e:	d1ca      	bne.n	800d426 <cblas_dnrm2+0x2e>
        ssq += (ax / scale) * (ax / scale);
 800d490:	4642      	mov	r2, r8
 800d492:	464b      	mov	r3, r9
 800d494:	4630      	mov	r0, r6
 800d496:	4639      	mov	r1, r7
 800d498:	f01b fc90 	bl	8028dbc <__aeabi_ddiv>
 800d49c:	4602      	mov	r2, r0
 800d49e:	460b      	mov	r3, r1
 800d4a0:	f01b fb62 	bl	8028b68 <__aeabi_dmul>
 800d4a4:	4602      	mov	r2, r0
 800d4a6:	460b      	mov	r3, r1
 800d4a8:	e9dd 0100 	ldrd	r0, r1, [sp]
 800d4ac:	f01b f9a6 	bl	80287fc <__adddf3>
 800d4b0:	e9cd 0100 	strd	r0, r1, [sp]
 800d4b4:	e7cb      	b.n	800d44e <cblas_dnrm2+0x56>
    return 0;
 800d4b6:	ed9f 0b12 	vldr	d0, [pc, #72]	; 800d500 <cblas_dnrm2+0x108>
#define BASE double
#include "source_nrm2_r.h"
#undef BASE
}
 800d4ba:	b005      	add	sp, #20
 800d4bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return scale * sqrt(ssq);
 800d4c0:	ed9d 0b00 	vldr	d0, [sp]
 800d4c4:	f023 fba6 	bl	8030c14 <sqrt>
 800d4c8:	4642      	mov	r2, r8
 800d4ca:	ec51 0b10 	vmov	r0, r1, d0
 800d4ce:	464b      	mov	r3, r9
 800d4d0:	f01b fb4a 	bl	8028b68 <__aeabi_dmul>
 800d4d4:	ec41 0b10 	vmov	d0, r0, r1
 800d4d8:	b005      	add	sp, #20
 800d4da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return fabs(X[0]);
 800d4de:	684b      	ldr	r3, [r1, #4]
 800d4e0:	ed91 0a00 	vldr	s0, [r1]
 800d4e4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800d4e8:	ee00 3a90 	vmov	s1, r3
 800d4ec:	b005      	add	sp, #20
 800d4ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d4f2:	bf00      	nop
 800d4f4:	f3af 8000 	nop.w
 800d4f8:	00000000 	.word	0x00000000
 800d4fc:	3ff00000 	.word	0x3ff00000
	...
 800d508:	3ff00000 	.word	0x3ff00000

0800d50c <cblas_drot>:
#include "cblas.h"

void
cblas_drot (const int N, double *X, const int incX, double *Y, const int incY,
            const double c, const double s)
{
 800d50c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d510:	ed2d 8b08 	vpush	{d8-d11}
 800d514:	eeb0 8a40 	vmov.f32	s16, s0
 800d518:	eef0 8a60 	vmov.f32	s17, s1
 800d51c:	eeb0 ba41 	vmov.f32	s22, s2
 800d520:	eef0 ba61 	vmov.f32	s23, s3
 800d524:	b083      	sub	sp, #12
 800d526:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 800d528:	2a00      	cmp	r2, #0
 800d52a:	9000      	str	r0, [sp, #0]
 800d52c:	9814      	ldr	r0, [sp, #80]	; 0x50
 800d52e:	bfda      	itte	le
 800d530:	f1c4 0b01 	rsble	fp, r4, #1
 800d534:	fb0b fb02 	mulle.w	fp, fp, r2
 800d538:	f04f 0b00 	movgt.w	fp, #0
  INDEX iy = OFFSET(N, incY);
 800d53c:	2800      	cmp	r0, #0
 800d53e:	bfdc      	itt	le
 800d540:	9c00      	ldrle	r4, [sp, #0]
 800d542:	f1c4 0a01 	rsble	sl, r4, #1
  for (i = 0; i < N; i++) {
 800d546:	9c00      	ldr	r4, [sp, #0]
  INDEX iy = OFFSET(N, incY);
 800d548:	bfd4      	ite	le
 800d54a:	fb0a fa00 	mulle.w	sl, sl, r0
 800d54e:	f04f 0a00 	movgt.w	sl, #0
  for (i = 0; i < N; i++) {
 800d552:	2c00      	cmp	r4, #0
 800d554:	dd47      	ble.n	800d5e6 <cblas_drot+0xda>
 800d556:	ec56 5b11 	vmov	r5, r6, d1
 800d55a:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 800d55e:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 800d562:	ee0a 3a90 	vmov	s21, r3
 800d566:	00d2      	lsls	r2, r2, #3
 800d568:	2300      	movs	r3, #0
 800d56a:	eeb0 aa41 	vmov.f32	s20, s2
 800d56e:	9201      	str	r2, [sp, #4]
 800d570:	eb01 0bcb 	add.w	fp, r1, fp, lsl #3
 800d574:	00c7      	lsls	r7, r0, #3
 800d576:	461e      	mov	r6, r3
    const BASE x = X[ix];
 800d578:	e9db 4500 	ldrd	r4, r5, [fp]
    X[ix] = c * x + s * y;
 800d57c:	ec53 2b18 	vmov	r2, r3, d8
 800d580:	4620      	mov	r0, r4
 800d582:	4629      	mov	r1, r5
 800d584:	f01b faf0 	bl	8028b68 <__aeabi_dmul>
    const BASE y = Y[iy];
 800d588:	e9da 8900 	ldrd	r8, r9, [sl]
    X[ix] = c * x + s * y;
 800d58c:	ec53 2b1b 	vmov	r2, r3, d11
 800d590:	ec41 0b19 	vmov	d9, r0, r1
 800d594:	4640      	mov	r0, r8
 800d596:	4649      	mov	r1, r9
 800d598:	f01b fae6 	bl	8028b68 <__aeabi_dmul>
 800d59c:	4602      	mov	r2, r0
 800d59e:	460b      	mov	r3, r1
 800d5a0:	ec51 0b19 	vmov	r0, r1, d9
 800d5a4:	f01b f92a 	bl	80287fc <__adddf3>
    Y[iy] = -s * x + c * y;
 800d5a8:	ec53 2b1a 	vmov	r2, r3, d10
    X[ix] = c * x + s * y;
 800d5ac:	e9cb 0100 	strd	r0, r1, [fp]
    Y[iy] = -s * x + c * y;
 800d5b0:	4620      	mov	r0, r4
 800d5b2:	4629      	mov	r1, r5
 800d5b4:	f01b fad8 	bl	8028b68 <__aeabi_dmul>
 800d5b8:	ec53 2b18 	vmov	r2, r3, d8
 800d5bc:	4604      	mov	r4, r0
 800d5be:	460d      	mov	r5, r1
 800d5c0:	4640      	mov	r0, r8
 800d5c2:	4649      	mov	r1, r9
 800d5c4:	f01b fad0 	bl	8028b68 <__aeabi_dmul>
 800d5c8:	460b      	mov	r3, r1
 800d5ca:	4602      	mov	r2, r0
 800d5cc:	4629      	mov	r1, r5
 800d5ce:	4620      	mov	r0, r4
 800d5d0:	f01b f914 	bl	80287fc <__adddf3>
 800d5d4:	9b01      	ldr	r3, [sp, #4]
 800d5d6:	449b      	add	fp, r3
  for (i = 0; i < N; i++) {
 800d5d8:	9b00      	ldr	r3, [sp, #0]
 800d5da:	3601      	adds	r6, #1
 800d5dc:	42b3      	cmp	r3, r6
    Y[iy] = -s * x + c * y;
 800d5de:	e9ca 0100 	strd	r0, r1, [sl]
  for (i = 0; i < N; i++) {
 800d5e2:	44ba      	add	sl, r7
 800d5e4:	d1c8      	bne.n	800d578 <cblas_drot+0x6c>
#define BASE double
#include "source_rot.h"
#undef BASE
}
 800d5e6:	b003      	add	sp, #12
 800d5e8:	ecbd 8b08 	vpop	{d8-d11}
 800d5ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800d5f0 <cblas_drotg>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_drotg (double *a, double *b, double *c, double *s)
{
 800d5f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d5f4:	ed2d 8b02 	vpush	{d8}
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 800d5f8:	ed90 7b00 	vldr	d7, [r0]
 800d5fc:	b089      	sub	sp, #36	; 0x24
 800d5fe:	ed8d 7b00 	vstr	d7, [sp]
 800d602:	ed91 7b00 	vldr	d7, [r1]
 800d606:	9004      	str	r0, [sp, #16]
 800d608:	4689      	mov	r9, r1
 800d60a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800d60e:	ec5b ab17 	vmov	sl, fp, d7
 800d612:	f021 4500 	bic.w	r5, r1, #2147483648	; 0x80000000
 800d616:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
 800d61a:	4694      	mov	ip, r2
 800d61c:	4698      	mov	r8, r3
 800d61e:	ee17 2a10 	vmov	r2, s14
 800d622:	4629      	mov	r1, r5
 800d624:	463b      	mov	r3, r7
 800d626:	ed8d 7b02 	vstr	d7, [sp, #8]
 800d62a:	ee17 6a10 	vmov	r6, s14
 800d62e:	4604      	mov	r4, r0
 800d630:	f8cd c014 	str.w	ip, [sp, #20]
 800d634:	f01b fd28 	bl	8029088 <__aeabi_dcmpgt>
 800d638:	bb38      	cbnz	r0, 800d68a <cblas_drotg+0x9a>
 800d63a:	e9cd ab06 	strd	sl, fp, [sp, #24]
  const BASE scale = fabs(*a) + fabs(*b);
 800d63e:	4632      	mov	r2, r6
 800d640:	463b      	mov	r3, r7
 800d642:	4620      	mov	r0, r4
 800d644:	4629      	mov	r1, r5
 800d646:	f01b f8d9 	bl	80287fc <__adddf3>
  if (scale != 0.0) {
 800d64a:	f04f 0a00 	mov.w	sl, #0
 800d64e:	f04f 0b00 	mov.w	fp, #0
 800d652:	4652      	mov	r2, sl
 800d654:	465b      	mov	r3, fp
  const BASE scale = fabs(*a) + fabs(*b);
 800d656:	4604      	mov	r4, r0
 800d658:	460d      	mov	r5, r1
  if (scale != 0.0) {
 800d65a:	f01b fced 	bl	8029038 <__aeabi_dcmpeq>
 800d65e:	b1c8      	cbz	r0, 800d694 <cblas_drotg+0xa4>
    *c = 1.0;
 800d660:	4b4f      	ldr	r3, [pc, #316]	; (800d7a0 <cblas_drotg+0x1b0>)
 800d662:	9905      	ldr	r1, [sp, #20]
 800d664:	2200      	movs	r2, #0
 800d666:	e9c1 2300 	strd	r2, r3, [r1]
    *s = 0.0;
 800d66a:	e9c8 ab00 	strd	sl, fp, [r8]
    z = 0.0;
 800d66e:	4654      	mov	r4, sl
 800d670:	465d      	mov	r5, fp
    r = 0.0;
 800d672:	4656      	mov	r6, sl
 800d674:	465f      	mov	r7, fp
  *a = r;
 800d676:	9b04      	ldr	r3, [sp, #16]
 800d678:	e9c3 6700 	strd	r6, r7, [r3]
  *b = z;
 800d67c:	e9c9 4500 	strd	r4, r5, [r9]
#define BASE double
#include "source_rotg.h"
#undef BASE
}
 800d680:	b009      	add	sp, #36	; 0x24
 800d682:	ecbd 8b02 	vpop	{d8}
 800d686:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 800d68a:	ed9d 7b00 	vldr	d7, [sp]
 800d68e:	ed8d 7b06 	vstr	d7, [sp, #24]
 800d692:	e7d4      	b.n	800d63e <cblas_drotg+0x4e>
    const BASE aos = *a / scale;
 800d694:	e9dd 0100 	ldrd	r0, r1, [sp]
 800d698:	4622      	mov	r2, r4
 800d69a:	462b      	mov	r3, r5
 800d69c:	f01b fb8e 	bl	8028dbc <__aeabi_ddiv>
    const BASE bos = *b / scale;
 800d6a0:	4622      	mov	r2, r4
    const BASE aos = *a / scale;
 800d6a2:	ec41 0b18 	vmov	d8, r0, r1
    const BASE bos = *b / scale;
 800d6a6:	462b      	mov	r3, r5
 800d6a8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800d6ac:	f01b fb86 	bl	8028dbc <__aeabi_ddiv>
    r = scale * sqrt(aos * aos + bos * bos);
 800d6b0:	ec53 2b18 	vmov	r2, r3, d8
    const BASE bos = *b / scale;
 800d6b4:	4606      	mov	r6, r0
 800d6b6:	460f      	mov	r7, r1
    r = scale * sqrt(aos * aos + bos * bos);
 800d6b8:	ee18 0a10 	vmov	r0, s16
 800d6bc:	4619      	mov	r1, r3
 800d6be:	f01b fa53 	bl	8028b68 <__aeabi_dmul>
 800d6c2:	4632      	mov	r2, r6
 800d6c4:	463b      	mov	r3, r7
 800d6c6:	4606      	mov	r6, r0
 800d6c8:	460f      	mov	r7, r1
 800d6ca:	4610      	mov	r0, r2
 800d6cc:	4619      	mov	r1, r3
 800d6ce:	f01b fa4b 	bl	8028b68 <__aeabi_dmul>
 800d6d2:	4602      	mov	r2, r0
 800d6d4:	460b      	mov	r3, r1
 800d6d6:	4630      	mov	r0, r6
 800d6d8:	4639      	mov	r1, r7
 800d6da:	f01b f88f 	bl	80287fc <__adddf3>
 800d6de:	ec41 0b10 	vmov	d0, r0, r1
 800d6e2:	f023 fa97 	bl	8030c14 <sqrt>
 800d6e6:	4622      	mov	r2, r4
 800d6e8:	462b      	mov	r3, r5
 800d6ea:	ec51 0b10 	vmov	r0, r1, d0
 800d6ee:	f01b fa3b 	bl	8028b68 <__aeabi_dmul>
    r = GSL_SIGN(roe) * r;
 800d6f2:	4652      	mov	r2, sl
    r = scale * sqrt(aos * aos + bos * bos);
 800d6f4:	4606      	mov	r6, r0
 800d6f6:	460f      	mov	r7, r1
    r = GSL_SIGN(roe) * r;
 800d6f8:	465b      	mov	r3, fp
 800d6fa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800d6fe:	f01b fcb9 	bl	8029074 <__aeabi_dcmpge>
 800d702:	2800      	cmp	r0, #0
 800d704:	d048      	beq.n	800d798 <cblas_drotg+0x1a8>
    *c = *a / r;
 800d706:	9904      	ldr	r1, [sp, #16]
 800d708:	4632      	mov	r2, r6
 800d70a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800d70e:	463b      	mov	r3, r7
 800d710:	f01b fb54 	bl	8028dbc <__aeabi_ddiv>
 800d714:	9a05      	ldr	r2, [sp, #20]
 800d716:	e9c2 0100 	strd	r0, r1, [r2]
    *s = *b / r;
 800d71a:	463b      	mov	r3, r7
 800d71c:	e9d9 0100 	ldrd	r0, r1, [r9]
 800d720:	4632      	mov	r2, r6
 800d722:	f01b fb4b 	bl	8028dbc <__aeabi_ddiv>
 800d726:	4604      	mov	r4, r0
 800d728:	460d      	mov	r5, r1
 800d72a:	e9c8 4500 	strd	r4, r5, [r8]
    if (fabs(*a) > fabs(*b))
 800d72e:	9b04      	ldr	r3, [sp, #16]
 800d730:	685a      	ldr	r2, [r3, #4]
 800d732:	f8d3 a000 	ldr.w	sl, [r3]
 800d736:	f8d9 3000 	ldr.w	r3, [r9]
 800d73a:	9300      	str	r3, [sp, #0]
 800d73c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800d740:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800d744:	f022 4b00 	bic.w	fp, r2, #2147483648	; 0x80000000
 800d748:	9301      	str	r3, [sp, #4]
 800d74a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800d74e:	4650      	mov	r0, sl
 800d750:	4659      	mov	r1, fp
 800d752:	f01b fc99 	bl	8029088 <__aeabi_dcmpgt>
 800d756:	b1e0      	cbz	r0, 800d792 <cblas_drotg+0x1a2>
    if (fabs(*b) >= fabs(*a) && *c != 0.0)
 800d758:	e9dd 2300 	ldrd	r2, r3, [sp]
 800d75c:	4650      	mov	r0, sl
 800d75e:	4659      	mov	r1, fp
 800d760:	f01b fc7e 	bl	8029060 <__aeabi_dcmple>
 800d764:	2800      	cmp	r0, #0
 800d766:	d086      	beq.n	800d676 <cblas_drotg+0x86>
 800d768:	9b05      	ldr	r3, [sp, #20]
 800d76a:	e9d3 ab00 	ldrd	sl, fp, [r3]
 800d76e:	2200      	movs	r2, #0
 800d770:	2300      	movs	r3, #0
 800d772:	4650      	mov	r0, sl
 800d774:	4659      	mov	r1, fp
 800d776:	f01b fc5f 	bl	8029038 <__aeabi_dcmpeq>
 800d77a:	2800      	cmp	r0, #0
 800d77c:	f47f af7b 	bne.w	800d676 <cblas_drotg+0x86>
      z = 1.0 / (*c);
 800d780:	4907      	ldr	r1, [pc, #28]	; (800d7a0 <cblas_drotg+0x1b0>)
 800d782:	4652      	mov	r2, sl
 800d784:	465b      	mov	r3, fp
 800d786:	2000      	movs	r0, #0
 800d788:	f01b fb18 	bl	8028dbc <__aeabi_ddiv>
 800d78c:	4604      	mov	r4, r0
 800d78e:	460d      	mov	r5, r1
 800d790:	e771      	b.n	800d676 <cblas_drotg+0x86>
    z = 1.0;
 800d792:	4d03      	ldr	r5, [pc, #12]	; (800d7a0 <cblas_drotg+0x1b0>)
 800d794:	2400      	movs	r4, #0
 800d796:	e7df      	b.n	800d758 <cblas_drotg+0x168>
 800d798:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 800d79c:	461f      	mov	r7, r3
 800d79e:	e7b2      	b.n	800d706 <cblas_drotg+0x116>
 800d7a0:	3ff00000 	.word	0x3ff00000
 800d7a4:	00000000 	.word	0x00000000

0800d7a8 <cblas_drotm>:
#include "cblas.h"

void
cblas_drotm (const int N, double *X, const int incX, double *Y,
             const int incY, const double *P)
{
 800d7a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d7ac:	ed2d 8b0a 	vpush	{d8-d12}
 800d7b0:	b083      	sub	sp, #12
  INDEX i = OFFSET(N, incX);
 800d7b2:	1e14      	subs	r4, r2, #0
 800d7b4:	e9dd 5716 	ldrd	r5, r7, [sp, #88]	; 0x58
 800d7b8:	4698      	mov	r8, r3
 800d7ba:	bfdc      	itt	le
 800d7bc:	4603      	movle	r3, r0
 800d7be:	f1c3 0601 	rsble	r6, r3, #1
  if (P[0] == -1.0) {
 800d7c2:	ed97 7b00 	vldr	d7, [r7]
 800d7c6:	9000      	str	r0, [sp, #0]
  INDEX i = OFFSET(N, incX);
 800d7c8:	bfd4      	ite	le
 800d7ca:	4366      	mulle	r6, r4
 800d7cc:	2600      	movgt	r6, #0
  INDEX j = OFFSET(N, incY);
 800d7ce:	2d00      	cmp	r5, #0
 800d7d0:	bfd8      	it	le
 800d7d2:	9b00      	ldrle	r3, [sp, #0]
  if (P[0] == -1.0) {
 800d7d4:	eeb0 9a47 	vmov.f32	s18, s14
 800d7d8:	eef0 9a67 	vmov.f32	s19, s15
  INDEX j = OFFSET(N, incY);
 800d7dc:	bfd8      	it	le
 800d7de:	f1c3 0b01 	rsble	fp, r3, #1
 800d7e2:	468a      	mov	sl, r1
  if (P[0] == -1.0) {
 800d7e4:	4b60      	ldr	r3, [pc, #384]	; (800d968 <cblas_drotm+0x1c0>)
 800d7e6:	ec51 0b17 	vmov	r0, r1, d7
 800d7ea:	f04f 0200 	mov.w	r2, #0
  INDEX j = OFFSET(N, incY);
 800d7ee:	bfd4      	ite	le
 800d7f0:	fb0b fb05 	mulle.w	fp, fp, r5
 800d7f4:	f04f 0b00 	movgt.w	fp, #0
  if (P[0] == -1.0) {
 800d7f8:	f01b fc1e 	bl	8029038 <__aeabi_dcmpeq>
 800d7fc:	2800      	cmp	r0, #0
 800d7fe:	d05f      	beq.n	800d8c0 <cblas_drotm+0x118>
    h11 = P[1];
 800d800:	ed97 7b02 	vldr	d7, [r7, #8]
 800d804:	eeb0 aa47 	vmov.f32	s20, s14
 800d808:	eef0 aa67 	vmov.f32	s21, s15
    h21 = P[2];
 800d80c:	ed97 7b04 	vldr	d7, [r7, #16]
 800d810:	eeb0 ba47 	vmov.f32	s22, s14
 800d814:	eef0 ba67 	vmov.f32	s23, s15
    h12 = P[3];
 800d818:	ed97 7b06 	vldr	d7, [r7, #24]
 800d81c:	eeb0 9a47 	vmov.f32	s18, s14
 800d820:	eef0 9a67 	vmov.f32	s19, s15
    h22 = P[4];
 800d824:	ed97 7b08 	vldr	d7, [r7, #32]
 800d828:	eeb0 ca47 	vmov.f32	s24, s14
 800d82c:	eef0 ca67 	vmov.f32	s25, s15
  for (n = 0; n < N; n++) {
 800d830:	9b00      	ldr	r3, [sp, #0]
 800d832:	2b00      	cmp	r3, #0
 800d834:	dd3f      	ble.n	800d8b6 <cblas_drotm+0x10e>
 800d836:	00e3      	lsls	r3, r4, #3
 800d838:	9301      	str	r3, [sp, #4]
 800d83a:	2300      	movs	r3, #0
 800d83c:	eb0a 0ac6 	add.w	sl, sl, r6, lsl #3
 800d840:	00ef      	lsls	r7, r5, #3
 800d842:	eb08 0bcb 	add.w	fp, r8, fp, lsl #3
 800d846:	461e      	mov	r6, r3
    const BASE w = X[i];
 800d848:	e9da 4500 	ldrd	r4, r5, [sl]
    X[i] = h11 * w + h12 * z;
 800d84c:	ec51 0b1a 	vmov	r0, r1, d10
 800d850:	4622      	mov	r2, r4
 800d852:	462b      	mov	r3, r5
 800d854:	f01b f988 	bl	8028b68 <__aeabi_dmul>
    const BASE z = Y[j];
 800d858:	e9db 8900 	ldrd	r8, r9, [fp]
    X[i] = h11 * w + h12 * z;
 800d85c:	ec41 0b18 	vmov	d8, r0, r1
 800d860:	4642      	mov	r2, r8
 800d862:	464b      	mov	r3, r9
 800d864:	ec51 0b19 	vmov	r0, r1, d9
 800d868:	f01b f97e 	bl	8028b68 <__aeabi_dmul>
 800d86c:	4602      	mov	r2, r0
 800d86e:	460b      	mov	r3, r1
 800d870:	ec51 0b18 	vmov	r0, r1, d8
 800d874:	f01a ffc2 	bl	80287fc <__adddf3>
    Y[j] = h21 * w + h22 * z;
 800d878:	4622      	mov	r2, r4
    X[i] = h11 * w + h12 * z;
 800d87a:	e9ca 0100 	strd	r0, r1, [sl]
    Y[j] = h21 * w + h22 * z;
 800d87e:	462b      	mov	r3, r5
 800d880:	ec51 0b1b 	vmov	r0, r1, d11
 800d884:	f01b f970 	bl	8028b68 <__aeabi_dmul>
 800d888:	4642      	mov	r2, r8
 800d88a:	464b      	mov	r3, r9
 800d88c:	4604      	mov	r4, r0
 800d88e:	460d      	mov	r5, r1
 800d890:	ec51 0b1c 	vmov	r0, r1, d12
 800d894:	f01b f968 	bl	8028b68 <__aeabi_dmul>
 800d898:	460b      	mov	r3, r1
 800d89a:	4602      	mov	r2, r0
 800d89c:	4629      	mov	r1, r5
 800d89e:	4620      	mov	r0, r4
 800d8a0:	f01a ffac 	bl	80287fc <__adddf3>
 800d8a4:	9b01      	ldr	r3, [sp, #4]
 800d8a6:	449a      	add	sl, r3
  for (n = 0; n < N; n++) {
 800d8a8:	9b00      	ldr	r3, [sp, #0]
 800d8aa:	3601      	adds	r6, #1
 800d8ac:	42b3      	cmp	r3, r6
    Y[j] = h21 * w + h22 * z;
 800d8ae:	e9cb 0100 	strd	r0, r1, [fp]
  for (n = 0; n < N; n++) {
 800d8b2:	44bb      	add	fp, r7
 800d8b4:	d1c8      	bne.n	800d848 <cblas_drotm+0xa0>
#define BASE double
#include "source_rotm.h"
#undef BASE
}
 800d8b6:	b003      	add	sp, #12
 800d8b8:	ecbd 8b0a 	vpop	{d8-d12}
 800d8bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (P[0] == 0.0) {
 800d8c0:	ec51 0b19 	vmov	r0, r1, d9
 800d8c4:	2200      	movs	r2, #0
 800d8c6:	2300      	movs	r3, #0
 800d8c8:	f01b fbb6 	bl	8029038 <__aeabi_dcmpeq>
 800d8cc:	b1b0      	cbz	r0, 800d8fc <cblas_drotm+0x154>
    h22 = 1.0;
 800d8ce:	ed9f 7b22 	vldr	d7, [pc, #136]	; 800d958 <cblas_drotm+0x1b0>
    h21 = P[2];
 800d8d2:	ed97 6b04 	vldr	d6, [r7, #16]
    h22 = 1.0;
 800d8d6:	eeb0 ca47 	vmov.f32	s24, s14
 800d8da:	eef0 ca67 	vmov.f32	s25, s15
    h11 = 1.0;
 800d8de:	eeb0 aa47 	vmov.f32	s20, s14
 800d8e2:	eef0 aa67 	vmov.f32	s21, s15
    h12 = P[3];
 800d8e6:	ed97 7b06 	vldr	d7, [r7, #24]
    h21 = P[2];
 800d8ea:	eeb0 ba46 	vmov.f32	s22, s12
 800d8ee:	eef0 ba66 	vmov.f32	s23, s13
    h12 = P[3];
 800d8f2:	eeb0 9a47 	vmov.f32	s18, s14
 800d8f6:	eef0 9a67 	vmov.f32	s19, s15
    h22 = 1.0;
 800d8fa:	e799      	b.n	800d830 <cblas_drotm+0x88>
  } else if (P[0] == 1.0) {
 800d8fc:	4b1b      	ldr	r3, [pc, #108]	; (800d96c <cblas_drotm+0x1c4>)
 800d8fe:	ec51 0b19 	vmov	r0, r1, d9
 800d902:	2200      	movs	r2, #0
 800d904:	f01b fb98 	bl	8029038 <__aeabi_dcmpeq>
 800d908:	b190      	cbz	r0, 800d930 <cblas_drotm+0x188>
    h11 = P[1];
 800d90a:	ed97 7b02 	vldr	d7, [r7, #8]
 800d90e:	eeb0 aa47 	vmov.f32	s20, s14
 800d912:	eef0 aa67 	vmov.f32	s21, s15
    h22 = P[4];
 800d916:	ed97 7b08 	vldr	d7, [r7, #32]
 800d91a:	eeb0 ca47 	vmov.f32	s24, s14
 800d91e:	eef0 ca67 	vmov.f32	s25, s15
    h21 = -1.0;
 800d922:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 800d960 <cblas_drotm+0x1b8>
 800d926:	eeb0 ba47 	vmov.f32	s22, s14
 800d92a:	eef0 ba67 	vmov.f32	s23, s15
 800d92e:	e77f      	b.n	800d830 <cblas_drotm+0x88>
  } else if (P[0] == -2.0) {
 800d930:	ec51 0b19 	vmov	r0, r1, d9
 800d934:	2200      	movs	r2, #0
 800d936:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 800d93a:	f01b fb7d 	bl	8029038 <__aeabi_dcmpeq>
 800d93e:	2800      	cmp	r0, #0
 800d940:	d1b9      	bne.n	800d8b6 <cblas_drotm+0x10e>
    BLAS_ERROR("unrecognized value of P[0]");
 800d942:	4a0b      	ldr	r2, [pc, #44]	; (800d970 <cblas_drotm+0x1c8>)
 800d944:	490b      	ldr	r1, [pc, #44]	; (800d974 <cblas_drotm+0x1cc>)
 800d946:	b003      	add	sp, #12
 800d948:	ecbd 8b0a 	vpop	{d8-d12}
 800d94c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d950:	f01a beda 	b.w	8028708 <cblas_xerbla>
 800d954:	f3af 8000 	nop.w
 800d958:	00000000 	.word	0x00000000
 800d95c:	3ff00000 	.word	0x3ff00000
 800d960:	00000000 	.word	0x00000000
 800d964:	bff00000 	.word	0xbff00000
 800d968:	bff00000 	.word	0xbff00000
 800d96c:	3ff00000 	.word	0x3ff00000
 800d970:	080311f0 	.word	0x080311f0
 800d974:	0803120c 	.word	0x0803120c

0800d978 <cblas_drotmg>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_drotmg (double *d1, double *d2, double *b1, const double b2, double *P)
{
 800d978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d97c:	ed2d 8b06 	vpush	{d8-d10}
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800d980:	e9d0 ab00 	ldrd	sl, fp, [r0]
 800d984:	b093      	sub	sp, #76	; 0x4c
  if (D1 < 0.0) {
 800d986:	2400      	movs	r4, #0
 800d988:	2500      	movs	r5, #0
 800d98a:	468c      	mov	ip, r1
 800d98c:	4617      	mov	r7, r2
 800d98e:	461e      	mov	r6, r3
 800d990:	900f      	str	r0, [sp, #60]	; 0x3c
 800d992:	4659      	mov	r1, fp
 800d994:	4650      	mov	r0, sl
 800d996:	4622      	mov	r2, r4
 800d998:	462b      	mov	r3, r5
 800d99a:	e9cd c70d 	strd	ip, r7, [sp, #52]	; 0x34
 800d99e:	ed8d 0b00 	vstr	d0, [sp]
 800d9a2:	960c      	str	r6, [sp, #48]	; 0x30
 800d9a4:	f01b fb52 	bl	802904c <__aeabi_dcmplt>
 800d9a8:	2800      	cmp	r0, #0
 800d9aa:	f040 809f 	bne.w	800daec <cblas_drotmg+0x174>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800d9ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d9b0:	ed93 7b00 	vldr	d7, [r3]
  if (D2 * y == 0.0) {
 800d9b4:	e9dd 2300 	ldrd	r2, r3, [sp]
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800d9b8:	eeb0 aa47 	vmov.f32	s20, s14
 800d9bc:	eef0 aa67 	vmov.f32	s21, s15
  if (D2 * y == 0.0) {
 800d9c0:	ec51 0b17 	vmov	r0, r1, d7
 800d9c4:	f01b f8d0 	bl	8028b68 <__aeabi_dmul>
 800d9c8:	4622      	mov	r2, r4
 800d9ca:	462b      	mov	r3, r5
 800d9cc:	4606      	mov	r6, r0
 800d9ce:	460f      	mov	r7, r1
 800d9d0:	f01b fb32 	bl	8029038 <__aeabi_dcmpeq>
 800d9d4:	2800      	cmp	r0, #0
 800d9d6:	d177      	bne.n	800dac8 <cblas_drotmg+0x150>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800d9d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d9da:	ed93 7b00 	vldr	d7, [r3]
  c = fabs(D1 * x * x);
 800d9de:	4650      	mov	r0, sl
 800d9e0:	ec53 2b17 	vmov	r2, r3, d7
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800d9e4:	eeb0 8a47 	vmov.f32	s16, s14
 800d9e8:	eef0 8a67 	vmov.f32	s17, s15
  c = fabs(D1 * x * x);
 800d9ec:	4659      	mov	r1, fp
 800d9ee:	f01b f8bb 	bl	8028b68 <__aeabi_dmul>
  s = fabs(D2 * y * y);
 800d9f2:	e9dd 2300 	ldrd	r2, r3, [sp]
  c = fabs(D1 * x * x);
 800d9f6:	ec41 0b19 	vmov	d9, r0, r1
  s = fabs(D2 * y * y);
 800d9fa:	4630      	mov	r0, r6
 800d9fc:	4639      	mov	r1, r7
 800d9fe:	f01b f8b3 	bl	8028b68 <__aeabi_dmul>
  c = fabs(D1 * x * x);
 800da02:	ec53 2b18 	vmov	r2, r3, d8
  s = fabs(D2 * y * y);
 800da06:	4680      	mov	r8, r0
 800da08:	4689      	mov	r9, r1
  c = fabs(D1 * x * x);
 800da0a:	ec51 0b19 	vmov	r0, r1, d9
  s = fabs(D2 * y * y);
 800da0e:	e9cd 8902 	strd	r8, r9, [sp, #8]
  c = fabs(D1 * x * x);
 800da12:	f01b f8a9 	bl	8028b68 <__aeabi_dmul>
 800da16:	f021 4900 	bic.w	r9, r1, #2147483648	; 0x80000000
  s = fabs(D2 * y * y);
 800da1a:	9903      	ldr	r1, [sp, #12]
 800da1c:	9a02      	ldr	r2, [sp, #8]
  c = fabs(D1 * x * x);
 800da1e:	4680      	mov	r8, r0
  s = fabs(D2 * y * y);
 800da20:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
  if (c > s) {
 800da24:	4640      	mov	r0, r8
 800da26:	4649      	mov	r1, r9
 800da28:	f01b fb2e 	bl	8029088 <__aeabi_dcmpgt>
 800da2c:	2800      	cmp	r0, #0
 800da2e:	d056      	beq.n	800dade <cblas_drotmg+0x166>
    P[0] = 0.0;
 800da30:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    h12 = (D2 * y) / (D1 * x);
 800da32:	4630      	mov	r0, r6
    P[0] = 0.0;
 800da34:	e9c3 4500 	strd	r4, r5, [r3]
    h12 = (D2 * y) / (D1 * x);
 800da38:	4639      	mov	r1, r7
 800da3a:	ec53 2b19 	vmov	r2, r3, d9
 800da3e:	f01b f9bd 	bl	8028dbc <__aeabi_ddiv>
    h21 = -y / x;
 800da42:	e9dd 2300 	ldrd	r2, r3, [sp]
    h12 = (D2 * y) / (D1 * x);
 800da46:	4680      	mov	r8, r0
 800da48:	4689      	mov	r9, r1
    h21 = -y / x;
 800da4a:	4610      	mov	r0, r2
 800da4c:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 800da50:	ec53 2b18 	vmov	r2, r3, d8
    h12 = (D2 * y) / (D1 * x);
 800da54:	e9cd 8904 	strd	r8, r9, [sp, #16]
    h21 = -y / x;
 800da58:	f01b f9b0 	bl	8028dbc <__aeabi_ddiv>
 800da5c:	4602      	mov	r2, r0
 800da5e:	460b      	mov	r3, r1
    u = 1 - h21 * h12;
 800da60:	4640      	mov	r0, r8
 800da62:	4649      	mov	r1, r9
    h21 = -y / x;
 800da64:	e9cd 2302 	strd	r2, r3, [sp, #8]
    u = 1 - h21 * h12;
 800da68:	f01b f87e 	bl	8028b68 <__aeabi_dmul>
 800da6c:	4602      	mov	r2, r0
 800da6e:	460b      	mov	r3, r1
 800da70:	2000      	movs	r0, #0
 800da72:	49a1      	ldr	r1, [pc, #644]	; (800dcf8 <cblas_drotmg+0x380>)
 800da74:	f01a fec0 	bl	80287f8 <__aeabi_dsub>
    if (u <= 0.0) {             /* the case u <= 0 is rejected */
 800da78:	4622      	mov	r2, r4
 800da7a:	462b      	mov	r3, r5
    u = 1 - h21 * h12;
 800da7c:	4606      	mov	r6, r0
 800da7e:	460f      	mov	r7, r1
    if (u <= 0.0) {             /* the case u <= 0 is rejected */
 800da80:	f01b faee 	bl	8029060 <__aeabi_dcmple>
 800da84:	bb90      	cbnz	r0, 800daec <cblas_drotmg+0x174>
    D1 /= u;
 800da86:	4650      	mov	r0, sl
 800da88:	4659      	mov	r1, fp
 800da8a:	4632      	mov	r2, r6
 800da8c:	463b      	mov	r3, r7
 800da8e:	f01b f995 	bl	8028dbc <__aeabi_ddiv>
    D2 /= u;
 800da92:	4632      	mov	r2, r6
 800da94:	463b      	mov	r3, r7
    D1 /= u;
 800da96:	4604      	mov	r4, r0
 800da98:	460d      	mov	r5, r1
    D2 /= u;
 800da9a:	ec51 0b1a 	vmov	r0, r1, d10
 800da9e:	f01b f98d 	bl	8028dbc <__aeabi_ddiv>
    h22 = 1;
 800daa2:	ed9f 7b91 	vldr	d7, [pc, #580]	; 800dce8 <cblas_drotmg+0x370>
    D2 /= u;
 800daa6:	4682      	mov	sl, r0
 800daa8:	468b      	mov	fp, r1
    x *= u;
 800daaa:	4632      	mov	r2, r6
 800daac:	ec51 0b18 	vmov	r0, r1, d8
 800dab0:	463b      	mov	r3, r7
    h22 = 1;
 800dab2:	ed8d 7b06 	vstr	d7, [sp, #24]
    x *= u;
 800dab6:	f01b f857 	bl	8028b68 <__aeabi_dmul>
    h11 = 1;
 800daba:	ed9f 7b8b 	vldr	d7, [pc, #556]	; 800dce8 <cblas_drotmg+0x370>
    x *= u;
 800dabe:	e9cd 0100 	strd	r0, r1, [sp]
    h11 = 1;
 800dac2:	ed8d 7b08 	vstr	d7, [sp, #32]
 800dac6:	e073      	b.n	800dbb0 <cblas_drotmg+0x238>
    P[0] = -2;                  /* case of H = I, page 315 */
 800dac8:	990c      	ldr	r1, [sp, #48]	; 0x30
 800daca:	2200      	movs	r2, #0
 800dacc:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 800dad0:	e9c1 2300 	strd	r2, r3, [r1]
#define BASE double
#include "source_rotmg.h"
#undef BASE
}
 800dad4:	b013      	add	sp, #76	; 0x4c
 800dad6:	ecbd 8b06 	vpop	{d8-d10}
 800dada:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (D2 * y * y < 0.0) {
 800dade:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800dae2:	4622      	mov	r2, r4
 800dae4:	462b      	mov	r3, r5
 800dae6:	f01b fab1 	bl	802904c <__aeabi_dcmplt>
 800daea:	b1e0      	cbz	r0, 800db26 <cblas_drotmg+0x1ae>
    P[0] = -1;
 800daec:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800daee:	4983      	ldr	r1, [pc, #524]	; (800dcfc <cblas_drotmg+0x384>)
 800daf0:	2000      	movs	r0, #0
 800daf2:	e9c4 0100 	strd	r0, r1, [r4]
    *d1 = 0;
 800daf6:	990f      	ldr	r1, [sp, #60]	; 0x3c
    P[1] = 0;
 800daf8:	2200      	movs	r2, #0
 800dafa:	2300      	movs	r3, #0
 800dafc:	e9c4 2302 	strd	r2, r3, [r4, #8]
    P[2] = 0;
 800db00:	e9c4 2304 	strd	r2, r3, [r4, #16]
    P[3] = 0;
 800db04:	e9c4 2306 	strd	r2, r3, [r4, #24]
    P[4] = 0;
 800db08:	e9c4 2308 	strd	r2, r3, [r4, #32]
    *d1 = 0;
 800db0c:	e9c1 2300 	strd	r2, r3, [r1]
    *d2 = 0;
 800db10:	990d      	ldr	r1, [sp, #52]	; 0x34
 800db12:	e9c1 2300 	strd	r2, r3, [r1]
    *b1 = 0;
 800db16:	990e      	ldr	r1, [sp, #56]	; 0x38
 800db18:	e9c1 2300 	strd	r2, r3, [r1]
 800db1c:	b013      	add	sp, #76	; 0x4c
 800db1e:	ecbd 8b06 	vpop	{d8-d10}
 800db22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    P[0] = 1;
 800db26:	ed9f 7b70 	vldr	d7, [pc, #448]	; 800dce8 <cblas_drotmg+0x370>
 800db2a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    h11 = (D1 * x) / (D2 * y);
 800db2c:	4632      	mov	r2, r6
    P[0] = 1;
 800db2e:	ed84 7b00 	vstr	d7, [r4]
    h11 = (D1 * x) / (D2 * y);
 800db32:	463b      	mov	r3, r7
 800db34:	ec51 0b19 	vmov	r0, r1, d9
 800db38:	f01b f940 	bl	8028dbc <__aeabi_ddiv>
    h22 = x / y;
 800db3c:	e9dd 2300 	ldrd	r2, r3, [sp]
    h11 = (D1 * x) / (D2 * y);
 800db40:	4680      	mov	r8, r0
 800db42:	4689      	mov	r9, r1
    h22 = x / y;
 800db44:	ec51 0b18 	vmov	r0, r1, d8
    h11 = (D1 * x) / (D2 * y);
 800db48:	e9cd 8908 	strd	r8, r9, [sp, #32]
    h22 = x / y;
 800db4c:	f01b f936 	bl	8028dbc <__aeabi_ddiv>
 800db50:	4602      	mov	r2, r0
 800db52:	460b      	mov	r3, r1
    u = 1 + h11 * h22;
 800db54:	4640      	mov	r0, r8
 800db56:	4649      	mov	r1, r9
    h22 = x / y;
 800db58:	e9cd 2306 	strd	r2, r3, [sp, #24]
    u = 1 + h11 * h22;
 800db5c:	f01b f804 	bl	8028b68 <__aeabi_dmul>
 800db60:	4b65      	ldr	r3, [pc, #404]	; (800dcf8 <cblas_drotmg+0x380>)
 800db62:	2200      	movs	r2, #0
 800db64:	f01a fe4a 	bl	80287fc <__adddf3>
 800db68:	4606      	mov	r6, r0
 800db6a:	460f      	mov	r7, r1
    D1 /= u;
 800db6c:	4650      	mov	r0, sl
 800db6e:	4659      	mov	r1, fp
 800db70:	4632      	mov	r2, r6
 800db72:	463b      	mov	r3, r7
 800db74:	f01b f922 	bl	8028dbc <__aeabi_ddiv>
    D2 /= u;
 800db78:	4632      	mov	r2, r6
    D1 /= u;
 800db7a:	4604      	mov	r4, r0
 800db7c:	460d      	mov	r5, r1
    D2 /= u;
 800db7e:	463b      	mov	r3, r7
 800db80:	ec51 0b1a 	vmov	r0, r1, d10
 800db84:	f01b f91a 	bl	8028dbc <__aeabi_ddiv>
    D1 /= u;
 800db88:	46a2      	mov	sl, r4
 800db8a:	46ab      	mov	fp, r5
    D2 /= u;
 800db8c:	4604      	mov	r4, r0
 800db8e:	460d      	mov	r5, r1
    x = y * u;
 800db90:	4632      	mov	r2, r6
 800db92:	e9dd 0100 	ldrd	r0, r1, [sp]
 800db96:	463b      	mov	r3, r7
 800db98:	f01a ffe6 	bl	8028b68 <__aeabi_dmul>
    h12 = 1;
 800db9c:	ed9f 7b52 	vldr	d7, [pc, #328]	; 800dce8 <cblas_drotmg+0x370>
 800dba0:	ed8d 7b04 	vstr	d7, [sp, #16]
    h21 = -1;
 800dba4:	ed9f 7b52 	vldr	d7, [pc, #328]	; 800dcf0 <cblas_drotmg+0x378>
    x = y * u;
 800dba8:	e9cd 0100 	strd	r0, r1, [sp]
    h21 = -1;
 800dbac:	ed8d 7b02 	vstr	d7, [sp, #8]
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800dbb0:	4b53      	ldr	r3, [pc, #332]	; (800dd00 <cblas_drotmg+0x388>)
 800dbb2:	2200      	movs	r2, #0
 800dbb4:	4620      	mov	r0, r4
 800dbb6:	4629      	mov	r1, r5
 800dbb8:	f01b fa52 	bl	8029060 <__aeabi_dcmple>
 800dbbc:	2800      	cmp	r0, #0
 800dbbe:	d043      	beq.n	800dc48 <cblas_drotmg+0x2d0>
 800dbc0:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
    P[0] = -1;
 800dbc4:	ed9f 8b4a 	vldr	d8, [pc, #296]	; 800dcf0 <cblas_drotmg+0x378>
    x /= G;
 800dbc8:	4f4e      	ldr	r7, [pc, #312]	; (800dd04 <cblas_drotmg+0x38c>)
 800dbca:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 800dbce:	2600      	movs	r6, #0
 800dbd0:	e02a      	b.n	800dc28 <cblas_drotmg+0x2b0>
    P[0] = -1;
 800dbd2:	ed8b 8b00 	vstr	d8, [fp]
    D1 *= G2;
 800dbd6:	f01a ffc7 	bl	8028b68 <__aeabi_dmul>
    x /= G;
 800dbda:	4632      	mov	r2, r6
    D1 *= G2;
 800dbdc:	4604      	mov	r4, r0
 800dbde:	460d      	mov	r5, r1
    x /= G;
 800dbe0:	463b      	mov	r3, r7
 800dbe2:	e9dd 0100 	ldrd	r0, r1, [sp]
 800dbe6:	f01a ffbf 	bl	8028b68 <__aeabi_dmul>
    h11 /= G;
 800dbea:	4632      	mov	r2, r6
    x /= G;
 800dbec:	4680      	mov	r8, r0
 800dbee:	4689      	mov	r9, r1
    h11 /= G;
 800dbf0:	463b      	mov	r3, r7
 800dbf2:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    x /= G;
 800dbf6:	e9cd 8900 	strd	r8, r9, [sp]
    h11 /= G;
 800dbfa:	f01a ffb5 	bl	8028b68 <__aeabi_dmul>
    h12 /= G;
 800dbfe:	4632      	mov	r2, r6
    h11 /= G;
 800dc00:	4680      	mov	r8, r0
 800dc02:	4689      	mov	r9, r1
    h12 /= G;
 800dc04:	463b      	mov	r3, r7
 800dc06:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    h11 /= G;
 800dc0a:	e9cd 8908 	strd	r8, r9, [sp, #32]
    h12 /= G;
 800dc0e:	f01a ffab 	bl	8028b68 <__aeabi_dmul>
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800dc12:	4b3b      	ldr	r3, [pc, #236]	; (800dd00 <cblas_drotmg+0x388>)
    h12 /= G;
 800dc14:	4680      	mov	r8, r0
 800dc16:	4689      	mov	r9, r1
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800dc18:	2200      	movs	r2, #0
 800dc1a:	4620      	mov	r0, r4
 800dc1c:	4629      	mov	r1, r5
    h12 /= G;
 800dc1e:	e9cd 8904 	strd	r8, r9, [sp, #16]
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800dc22:	f01b fa1d 	bl	8029060 <__aeabi_dcmple>
 800dc26:	b168      	cbz	r0, 800dc44 <cblas_drotmg+0x2cc>
 800dc28:	2200      	movs	r2, #0
 800dc2a:	2300      	movs	r3, #0
 800dc2c:	4629      	mov	r1, r5
 800dc2e:	4620      	mov	r0, r4
 800dc30:	f01b fa02 	bl	8029038 <__aeabi_dcmpeq>
 800dc34:	4684      	mov	ip, r0
    D1 *= G2;
 800dc36:	4b34      	ldr	r3, [pc, #208]	; (800dd08 <cblas_drotmg+0x390>)
 800dc38:	2200      	movs	r2, #0
 800dc3a:	4620      	mov	r0, r4
 800dc3c:	4629      	mov	r1, r5
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800dc3e:	f1bc 0f00 	cmp.w	ip, #0
 800dc42:	d0c6      	beq.n	800dbd2 <cblas_drotmg+0x25a>
 800dc44:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
  while (D1 >= G2) {
 800dc48:	4b2f      	ldr	r3, [pc, #188]	; (800dd08 <cblas_drotmg+0x390>)
 800dc4a:	2200      	movs	r2, #0
 800dc4c:	4620      	mov	r0, r4
 800dc4e:	4629      	mov	r1, r5
 800dc50:	f01b fa10 	bl	8029074 <__aeabi_dcmpge>
 800dc54:	2800      	cmp	r0, #0
 800dc56:	d034      	beq.n	800dcc2 <cblas_drotmg+0x34a>
    x *= G;
 800dc58:	4f2c      	ldr	r7, [pc, #176]	; (800dd0c <cblas_drotmg+0x394>)
 800dc5a:	2600      	movs	r6, #0
    D1 /= G2;
 800dc5c:	4b28      	ldr	r3, [pc, #160]	; (800dd00 <cblas_drotmg+0x388>)
 800dc5e:	4620      	mov	r0, r4
 800dc60:	4629      	mov	r1, r5
 800dc62:	2200      	movs	r2, #0
 800dc64:	f01a ff80 	bl	8028b68 <__aeabi_dmul>
    x *= G;
 800dc68:	4632      	mov	r2, r6
    D1 /= G2;
 800dc6a:	4604      	mov	r4, r0
 800dc6c:	460d      	mov	r5, r1
    x *= G;
 800dc6e:	463b      	mov	r3, r7
 800dc70:	e9dd 0100 	ldrd	r0, r1, [sp]
 800dc74:	f01a ff78 	bl	8028b68 <__aeabi_dmul>
    h11 *= G;
 800dc78:	4632      	mov	r2, r6
    x *= G;
 800dc7a:	4680      	mov	r8, r0
 800dc7c:	4689      	mov	r9, r1
    h11 *= G;
 800dc7e:	463b      	mov	r3, r7
 800dc80:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    x *= G;
 800dc84:	e9cd 8900 	strd	r8, r9, [sp]
    h11 *= G;
 800dc88:	f01a ff6e 	bl	8028b68 <__aeabi_dmul>
    h12 *= G;
 800dc8c:	4632      	mov	r2, r6
    h11 *= G;
 800dc8e:	4680      	mov	r8, r0
 800dc90:	4689      	mov	r9, r1
    h12 *= G;
 800dc92:	463b      	mov	r3, r7
 800dc94:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    h11 *= G;
 800dc98:	e9cd 8908 	strd	r8, r9, [sp, #32]
    h12 *= G;
 800dc9c:	f01a ff64 	bl	8028b68 <__aeabi_dmul>
  while (D1 >= G2) {
 800dca0:	4b19      	ldr	r3, [pc, #100]	; (800dd08 <cblas_drotmg+0x390>)
    h12 *= G;
 800dca2:	4680      	mov	r8, r0
 800dca4:	4689      	mov	r9, r1
  while (D1 >= G2) {
 800dca6:	2200      	movs	r2, #0
 800dca8:	4620      	mov	r0, r4
 800dcaa:	4629      	mov	r1, r5
    h12 *= G;
 800dcac:	e9cd 8904 	strd	r8, r9, [sp, #16]
  while (D1 >= G2) {
 800dcb0:	f01b f9e0 	bl	8029074 <__aeabi_dcmpge>
 800dcb4:	2800      	cmp	r0, #0
 800dcb6:	d1d1      	bne.n	800dc5c <cblas_drotmg+0x2e4>
 800dcb8:	4b10      	ldr	r3, [pc, #64]	; (800dcfc <cblas_drotmg+0x384>)
 800dcba:	990c      	ldr	r1, [sp, #48]	; 0x30
 800dcbc:	2200      	movs	r2, #0
 800dcbe:	e9c1 2300 	strd	r2, r3, [r1]
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800dcc2:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
 800dcc6:	4b0e      	ldr	r3, [pc, #56]	; (800dd00 <cblas_drotmg+0x388>)
 800dcc8:	4650      	mov	r0, sl
 800dcca:	4639      	mov	r1, r7
 800dccc:	2200      	movs	r2, #0
 800dcce:	4656      	mov	r6, sl
 800dcd0:	f01b f9c6 	bl	8029060 <__aeabi_dcmple>
 800dcd4:	2800      	cmp	r0, #0
 800dcd6:	d054      	beq.n	800dd82 <cblas_drotmg+0x40a>
 800dcd8:	ec45 4b19 	vmov	d9, r4, r5
    P[0] = -1;
 800dcdc:	ed9f 8b04 	vldr	d8, [pc, #16]	; 800dcf0 <cblas_drotmg+0x378>
 800dce0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800dce2:	e03b      	b.n	800dd5c <cblas_drotmg+0x3e4>
 800dce4:	f3af 8000 	nop.w
 800dce8:	00000000 	.word	0x00000000
 800dcec:	3ff00000 	.word	0x3ff00000
 800dcf0:	00000000 	.word	0x00000000
 800dcf4:	bff00000 	.word	0xbff00000
 800dcf8:	3ff00000 	.word	0x3ff00000
 800dcfc:	bff00000 	.word	0xbff00000
 800dd00:	3e700000 	.word	0x3e700000
 800dd04:	3f300000 	.word	0x3f300000
 800dd08:	41700000 	.word	0x41700000
 800dd0c:	40b00000 	.word	0x40b00000
 800dd10:	ed85 8b00 	vstr	d8, [r5]
    D2 *= G2;
 800dd14:	f01a ff28 	bl	8028b68 <__aeabi_dmul>
    h21 /= G;
 800dd18:	4b60      	ldr	r3, [pc, #384]	; (800de9c <cblas_drotmg+0x524>)
    D2 *= G2;
 800dd1a:	4682      	mov	sl, r0
    h21 /= G;
 800dd1c:	2200      	movs	r2, #0
    D2 *= G2;
 800dd1e:	468b      	mov	fp, r1
    h21 /= G;
 800dd20:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800dd24:	f01a ff20 	bl	8028b68 <__aeabi_dmul>
    h22 /= G;
 800dd28:	4b5c      	ldr	r3, [pc, #368]	; (800de9c <cblas_drotmg+0x524>)
    h21 /= G;
 800dd2a:	4680      	mov	r8, r0
 800dd2c:	4689      	mov	r9, r1
    h22 /= G;
 800dd2e:	2200      	movs	r2, #0
 800dd30:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    h21 /= G;
 800dd34:	e9cd 8902 	strd	r8, r9, [sp, #8]
    h22 /= G;
 800dd38:	f01a ff16 	bl	8028b68 <__aeabi_dmul>
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800dd3c:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
    h22 /= G;
 800dd40:	4680      	mov	r8, r0
 800dd42:	4689      	mov	r9, r1
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800dd44:	4b56      	ldr	r3, [pc, #344]	; (800dea0 <cblas_drotmg+0x528>)
 800dd46:	2200      	movs	r2, #0
 800dd48:	4650      	mov	r0, sl
 800dd4a:	4639      	mov	r1, r7
    h22 /= G;
 800dd4c:	e9cd 8906 	strd	r8, r9, [sp, #24]
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800dd50:	4656      	mov	r6, sl
 800dd52:	f01b f985 	bl	8029060 <__aeabi_dcmple>
 800dd56:	2800      	cmp	r0, #0
 800dd58:	f000 808a 	beq.w	800de70 <cblas_drotmg+0x4f8>
 800dd5c:	2200      	movs	r2, #0
 800dd5e:	2300      	movs	r3, #0
 800dd60:	4659      	mov	r1, fp
 800dd62:	4650      	mov	r0, sl
 800dd64:	f01b f968 	bl	8029038 <__aeabi_dcmpeq>
 800dd68:	4684      	mov	ip, r0
    D2 *= G2;
 800dd6a:	4b4e      	ldr	r3, [pc, #312]	; (800dea4 <cblas_drotmg+0x52c>)
 800dd6c:	2200      	movs	r2, #0
 800dd6e:	4650      	mov	r0, sl
 800dd70:	4659      	mov	r1, fp
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800dd72:	f1bc 0f00 	cmp.w	ip, #0
 800dd76:	d0cb      	beq.n	800dd10 <cblas_drotmg+0x398>
 800dd78:	ec55 4b19 	vmov	r4, r5, d9
 800dd7c:	4656      	mov	r6, sl
 800dd7e:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
  while (fabs(D2) >= G2) {
 800dd82:	4b48      	ldr	r3, [pc, #288]	; (800dea4 <cblas_drotmg+0x52c>)
 800dd84:	4630      	mov	r0, r6
 800dd86:	4639      	mov	r1, r7
 800dd88:	2200      	movs	r2, #0
 800dd8a:	f01b f973 	bl	8029074 <__aeabi_dcmpge>
 800dd8e:	2800      	cmp	r0, #0
 800dd90:	d033      	beq.n	800ddfa <cblas_drotmg+0x482>
    h21 *= G;
 800dd92:	4f45      	ldr	r7, [pc, #276]	; (800dea8 <cblas_drotmg+0x530>)
 800dd94:	ec45 4b18 	vmov	d8, r4, r5
 800dd98:	2600      	movs	r6, #0
    D2 /= G2;
 800dd9a:	4b41      	ldr	r3, [pc, #260]	; (800dea0 <cblas_drotmg+0x528>)
 800dd9c:	4650      	mov	r0, sl
 800dd9e:	4659      	mov	r1, fp
 800dda0:	2200      	movs	r2, #0
 800dda2:	f01a fee1 	bl	8028b68 <__aeabi_dmul>
    h21 *= G;
 800dda6:	4632      	mov	r2, r6
 800dda8:	463b      	mov	r3, r7
    D2 /= G2;
 800ddaa:	4682      	mov	sl, r0
 800ddac:	468b      	mov	fp, r1
    h21 *= G;
 800ddae:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800ddb2:	f01a fed9 	bl	8028b68 <__aeabi_dmul>
  while (fabs(D2) >= G2) {
 800ddb6:	f02b 4400 	bic.w	r4, fp, #2147483648	; 0x80000000
    h21 *= G;
 800ddba:	4680      	mov	r8, r0
 800ddbc:	4689      	mov	r9, r1
    h22 *= G;
 800ddbe:	4632      	mov	r2, r6
 800ddc0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800ddc4:	463b      	mov	r3, r7
    h21 *= G;
 800ddc6:	e9cd 8902 	strd	r8, r9, [sp, #8]
  while (fabs(D2) >= G2) {
 800ddca:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 800ddce:	940b      	str	r4, [sp, #44]	; 0x2c
    h22 *= G;
 800ddd0:	f01a feca 	bl	8028b68 <__aeabi_dmul>
  while (fabs(D2) >= G2) {
 800ddd4:	4b33      	ldr	r3, [pc, #204]	; (800dea4 <cblas_drotmg+0x52c>)
    h22 *= G;
 800ddd6:	4680      	mov	r8, r0
 800ddd8:	4689      	mov	r9, r1
  while (fabs(D2) >= G2) {
 800ddda:	2200      	movs	r2, #0
 800dddc:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    h22 *= G;
 800dde0:	e9cd 8906 	strd	r8, r9, [sp, #24]
  while (fabs(D2) >= G2) {
 800dde4:	f01b f946 	bl	8029074 <__aeabi_dcmpge>
 800dde8:	2800      	cmp	r0, #0
 800ddea:	d1d6      	bne.n	800dd9a <cblas_drotmg+0x422>
 800ddec:	4b2f      	ldr	r3, [pc, #188]	; (800deac <cblas_drotmg+0x534>)
 800ddee:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ddf0:	2200      	movs	r2, #0
 800ddf2:	e9c1 2300 	strd	r2, r3, [r1]
 800ddf6:	ec55 4b18 	vmov	r4, r5, d8
  *d1 = D1;
 800ddfa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  if (P[0] == -1.0) {
 800ddfc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  *d1 = D1;
 800ddfe:	e9c3 4500 	strd	r4, r5, [r3]
  *d2 = D2;
 800de02:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  *b1 = x;
 800de04:	ed9d 7b00 	vldr	d7, [sp]
  *d2 = D2;
 800de08:	e9c3 ab00 	strd	sl, fp, [r3]
  *b1 = x;
 800de0c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800de0e:	ed83 7b00 	vstr	d7, [r3]
  if (P[0] == -1.0) {
 800de12:	e9d6 4500 	ldrd	r4, r5, [r6]
 800de16:	4b25      	ldr	r3, [pc, #148]	; (800deac <cblas_drotmg+0x534>)
 800de18:	2200      	movs	r2, #0
 800de1a:	4620      	mov	r0, r4
 800de1c:	4629      	mov	r1, r5
 800de1e:	f01b f90b 	bl	8029038 <__aeabi_dcmpeq>
 800de22:	b1a0      	cbz	r0, 800de4e <cblas_drotmg+0x4d6>
    P[1] = h11;
 800de24:	ed9d 7b08 	vldr	d7, [sp, #32]
 800de28:	ed86 7b02 	vstr	d7, [r6, #8]
    P[2] = h21;
 800de2c:	ed9d 7b02 	vldr	d7, [sp, #8]
 800de30:	ed86 7b04 	vstr	d7, [r6, #16]
    P[3] = h12;
 800de34:	ed9d 7b04 	vldr	d7, [sp, #16]
 800de38:	ed86 7b06 	vstr	d7, [r6, #24]
    P[4] = h22;
 800de3c:	ed9d 7b06 	vldr	d7, [sp, #24]
 800de40:	ed86 7b08 	vstr	d7, [r6, #32]
 800de44:	b013      	add	sp, #76	; 0x4c
 800de46:	ecbd 8b06 	vpop	{d8-d10}
 800de4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (P[0] == 0.0) {
 800de4e:	2200      	movs	r2, #0
 800de50:	2300      	movs	r3, #0
 800de52:	4620      	mov	r0, r4
 800de54:	4629      	mov	r1, r5
 800de56:	f01b f8ef 	bl	8029038 <__aeabi_dcmpeq>
 800de5a:	b160      	cbz	r0, 800de76 <cblas_drotmg+0x4fe>
    P[2] = h21;
 800de5c:	ed9d 7b02 	vldr	d7, [sp, #8]
 800de60:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800de62:	ed83 7b04 	vstr	d7, [r3, #16]
    P[3] = h12;
 800de66:	ed9d 7b04 	vldr	d7, [sp, #16]
 800de6a:	ed83 7b06 	vstr	d7, [r3, #24]
 800de6e:	e631      	b.n	800dad4 <cblas_drotmg+0x15c>
 800de70:	ec55 4b19 	vmov	r4, r5, d9
 800de74:	e785      	b.n	800dd82 <cblas_drotmg+0x40a>
  } else if (P[0] == 1.0) {
 800de76:	4b0e      	ldr	r3, [pc, #56]	; (800deb0 <cblas_drotmg+0x538>)
 800de78:	4620      	mov	r0, r4
 800de7a:	4629      	mov	r1, r5
 800de7c:	2200      	movs	r2, #0
 800de7e:	f01b f8db 	bl	8029038 <__aeabi_dcmpeq>
 800de82:	2800      	cmp	r0, #0
 800de84:	f43f ae26 	beq.w	800dad4 <cblas_drotmg+0x15c>
    P[1] = h11;
 800de88:	ed9d 7b08 	vldr	d7, [sp, #32]
 800de8c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800de8e:	ed83 7b02 	vstr	d7, [r3, #8]
    P[4] = h22;
 800de92:	ed9d 7b06 	vldr	d7, [sp, #24]
 800de96:	ed83 7b08 	vstr	d7, [r3, #32]
 800de9a:	e61b      	b.n	800dad4 <cblas_drotmg+0x15c>
 800de9c:	3f300000 	.word	0x3f300000
 800dea0:	3e700000 	.word	0x3e700000
 800dea4:	41700000 	.word	0x41700000
 800dea8:	40b00000 	.word	0x40b00000
 800deac:	bff00000 	.word	0xbff00000
 800deb0:	3ff00000 	.word	0x3ff00000

0800deb4 <cblas_dscal>:
  if (incX <= 0) {
 800deb4:	2a00      	cmp	r2, #0
 800deb6:	dd18      	ble.n	800deea <cblas_dscal+0x36>
  for (i = 0; i < N; i++) {
 800deb8:	2800      	cmp	r0, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_dscal (const int N, const double alpha, double *X, const int incX)
{
 800deba:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800debe:	4681      	mov	r9, r0
 800dec0:	dd11      	ble.n	800dee6 <cblas_dscal+0x32>
 800dec2:	ec57 6b10 	vmov	r6, r7, d0
 800dec6:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 800deca:	460c      	mov	r4, r1
 800decc:	2500      	movs	r5, #0
    X[ix] *= alpha;
 800dece:	e9d4 0100 	ldrd	r0, r1, [r4]
 800ded2:	4632      	mov	r2, r6
 800ded4:	463b      	mov	r3, r7
 800ded6:	f01a fe47 	bl	8028b68 <__aeabi_dmul>
  for (i = 0; i < N; i++) {
 800deda:	3501      	adds	r5, #1
 800dedc:	45a9      	cmp	r9, r5
    X[ix] *= alpha;
 800dede:	e9c4 0100 	strd	r0, r1, [r4]
  for (i = 0; i < N; i++) {
 800dee2:	4444      	add	r4, r8
 800dee4:	d1f3      	bne.n	800dece <cblas_dscal+0x1a>
#define BASE double
#include "source_scal_r.h"
#undef BASE
}
 800dee6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800deea:	4770      	bx	lr

0800deec <cblas_dsdot>:
#include "cblas.h"

double
cblas_dsdot (const int N, const float *X, const int incX, const float *Y,
             const int incY)
{
 800deec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  INDEX ix = OFFSET(N, incX);
 800def0:	2a00      	cmp	r2, #0
 800def2:	4682      	mov	sl, r0
 800def4:	980a      	ldr	r0, [sp, #40]	; 0x28
 800def6:	bfda      	itte	le
 800def8:	f1ca 0701 	rsble	r7, sl, #1
 800defc:	4357      	mulle	r7, r2
 800defe:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 800df00:	2800      	cmp	r0, #0
 800df02:	bfda      	itte	le
 800df04:	f1ca 0601 	rsble	r6, sl, #1
 800df08:	4346      	mulle	r6, r0
 800df0a:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 800df0c:	f1ba 0f00 	cmp.w	sl, #0
 800df10:	f04f 0400 	mov.w	r4, #0
 800df14:	f04f 0500 	mov.w	r5, #0
 800df18:	dd21      	ble.n	800df5e <cblas_dsdot+0x72>
 800df1a:	ea4f 0982 	mov.w	r9, r2, lsl #2
 800df1e:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 800df22:	ea4f 0b80 	mov.w	fp, r0, lsl #2
 800df26:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 800df2a:	f04f 0800 	mov.w	r8, #0
    r += X[ix] * Y[iy];
 800df2e:	ed97 7a00 	vldr	s14, [r7]
 800df32:	edd6 7a00 	vldr	s15, [r6]
 800df36:	ee67 7a27 	vmul.f32	s15, s14, s15
  for (i = 0; i < N; i++) {
 800df3a:	f108 0801 	add.w	r8, r8, #1
    r += X[ix] * Y[iy];
 800df3e:	ee17 0a90 	vmov	r0, s15
 800df42:	f01a fdb9 	bl	8028ab8 <__aeabi_f2d>
 800df46:	4602      	mov	r2, r0
 800df48:	460b      	mov	r3, r1
 800df4a:	4620      	mov	r0, r4
 800df4c:	4629      	mov	r1, r5
 800df4e:	f01a fc55 	bl	80287fc <__adddf3>
  for (i = 0; i < N; i++) {
 800df52:	45c2      	cmp	sl, r8
 800df54:	444f      	add	r7, r9
 800df56:	445e      	add	r6, fp
    r += X[ix] * Y[iy];
 800df58:	4604      	mov	r4, r0
 800df5a:	460d      	mov	r5, r1
  for (i = 0; i < N; i++) {
 800df5c:	d1e7      	bne.n	800df2e <cblas_dsdot+0x42>
#define BASE float
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 800df5e:	ec45 4b10 	vmov	d0, r4, r5
 800df62:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800df66:	bf00      	nop

0800df68 <cblas_dswap>:
#include "cblas.h"

void
cblas_dswap (const int N, double *X, const int incX, double *Y,
             const int incY)
{
 800df68:	b5f0      	push	{r4, r5, r6, r7, lr}
  INDEX ix = OFFSET(N, incX);
 800df6a:	2a00      	cmp	r2, #0
 800df6c:	9c05      	ldr	r4, [sp, #20]
 800df6e:	bfda      	itte	le
 800df70:	f1c0 0601 	rsble	r6, r0, #1
 800df74:	4356      	mulle	r6, r2
 800df76:	2600      	movgt	r6, #0
  INDEX iy = OFFSET(N, incY);
 800df78:	2c00      	cmp	r4, #0
 800df7a:	bfda      	itte	le
 800df7c:	f1c0 0501 	rsble	r5, r0, #1
 800df80:	4365      	mulle	r5, r4
 800df82:	2500      	movgt	r5, #0
  for (i = 0; i < N; i++) {
 800df84:	2800      	cmp	r0, #0
 800df86:	dd15      	ble.n	800dfb4 <cblas_dswap+0x4c>
 800df88:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 800df8c:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
 800df90:	ea4f 0ec4 	mov.w	lr, r4, lsl #3
 800df94:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 800df98:	2200      	movs	r2, #0
    const BASE tmp = X[ix];
 800df9a:	e9d1 4500 	ldrd	r4, r5, [r1]
    X[ix] = Y[iy];
 800df9e:	e9d3 6700 	ldrd	r6, r7, [r3]
  for (i = 0; i < N; i++) {
 800dfa2:	3201      	adds	r2, #1
 800dfa4:	4290      	cmp	r0, r2
    X[ix] = Y[iy];
 800dfa6:	e9c1 6700 	strd	r6, r7, [r1]
    Y[iy] = tmp;
 800dfaa:	e9c3 4500 	strd	r4, r5, [r3]
  for (i = 0; i < N; i++) {
 800dfae:	4461      	add	r1, ip
 800dfb0:	4473      	add	r3, lr
 800dfb2:	d1f2      	bne.n	800df9a <cblas_dswap+0x32>
#define BASE double
#include "source_swap_r.h"
#undef BASE
}
 800dfb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800dfb6:	bf00      	nop

0800dfb8 <cblas_dsymm>:
cblas_dsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const double alpha, const double *A, const int lda,
             const double *B, const int ldb, const double beta, double *C,
             const int ldc)
{
 800dfb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dfbc:	ed2d 8b06 	vpush	{d8-d10}
 800dfc0:	eeb0 9a40 	vmov.f32	s18, s0
 800dfc4:	eef0 9a60 	vmov.f32	s19, s1
 800dfc8:	b097      	sub	sp, #92	; 0x5c
 800dfca:	298d      	cmp	r1, #141	; 0x8d
 800dfcc:	9307      	str	r3, [sp, #28]
 800dfce:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800dfd0:	9306      	str	r3, [sp, #24]
 800dfd2:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800dfd4:	930b      	str	r3, [sp, #44]	; 0x2c
 800dfd6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800dfd8:	9309      	str	r3, [sp, #36]	; 0x24
 800dfda:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 800dfdc:	930c      	str	r3, [sp, #48]	; 0x30
 800dfde:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 800dfe0:	930f      	str	r3, [sp, #60]	; 0x3c
 800dfe2:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800dfe4:	930a      	str	r3, [sp, #40]	; 0x28
 800dfe6:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800dfe8:	930e      	str	r3, [sp, #56]	; 0x38
 800dfea:	ec57 6b11 	vmov	r6, r7, d1
 800dfee:	468b      	mov	fp, r1
 800dff0:	4604      	mov	r4, r0
 800dff2:	4690      	mov	r8, r2
 800dff4:	f000 80dd 	beq.w	800e1b2 <cblas_dsymm+0x1fa>
 800dff8:	298e      	cmp	r1, #142	; 0x8e
 800dffa:	f000 8296 	beq.w	800e52a <cblas_dsymm+0x572>
 800dffe:	9b06      	ldr	r3, [sp, #24]
 800e000:	2002      	movs	r0, #2
 800e002:	f1a8 0279 	sub.w	r2, r8, #121	; 0x79
 800e006:	2a01      	cmp	r2, #1
 800e008:	9a07      	ldr	r2, [sp, #28]
 800e00a:	bf88      	it	hi
 800e00c:	2003      	movhi	r0, #3
 800e00e:	2a00      	cmp	r2, #0
 800e010:	9a06      	ldr	r2, [sp, #24]
 800e012:	bfb8      	it	lt
 800e014:	2004      	movlt	r0, #4
 800e016:	2b01      	cmp	r3, #1
 800e018:	bfb8      	it	lt
 800e01a:	2301      	movlt	r3, #1
 800e01c:	2a00      	cmp	r2, #0
 800e01e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e020:	f2c0 80bc 	blt.w	800e19c <cblas_dsymm+0x1e4>
 800e024:	4293      	cmp	r3, r2
 800e026:	dd66      	ble.n	800e0f6 <cblas_dsymm+0x13e>
 800e028:	2c65      	cmp	r4, #101	; 0x65
 800e02a:	f000 8262 	beq.w	800e4f2 <cblas_dsymm+0x53a>
 800e02e:	2c66      	cmp	r4, #102	; 0x66
 800e030:	f000 826d 	beq.w	800e50e <cblas_dsymm+0x556>
 800e034:	2008      	movs	r0, #8
 800e036:	4ab8      	ldr	r2, [pc, #736]	; (800e318 <cblas_dsymm+0x360>)
 800e038:	49b8      	ldr	r1, [pc, #736]	; (800e31c <cblas_dsymm+0x364>)
 800e03a:	f01a fb65 	bl	8028708 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800e03e:	ec51 0b19 	vmov	r0, r1, d9
 800e042:	2200      	movs	r2, #0
 800e044:	2300      	movs	r3, #0
 800e046:	f01a fff7 	bl	8029038 <__aeabi_dcmpeq>
 800e04a:	b138      	cbz	r0, 800e05c <cblas_dsymm+0xa4>
 800e04c:	4bb4      	ldr	r3, [pc, #720]	; (800e320 <cblas_dsymm+0x368>)
 800e04e:	2200      	movs	r2, #0
 800e050:	4630      	mov	r0, r6
 800e052:	4639      	mov	r1, r7
 800e054:	f01a fff0 	bl	8029038 <__aeabi_dcmpeq>
 800e058:	2800      	cmp	r0, #0
 800e05a:	d167      	bne.n	800e12c <cblas_dsymm+0x174>
  if (Order == CblasRowMajor) {
 800e05c:	2c65      	cmp	r4, #101	; 0x65
 800e05e:	f000 80af 	beq.w	800e1c0 <cblas_dsymm+0x208>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800e062:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 800e066:	bf0c      	ite	eq
 800e068:	237a      	moveq	r3, #122	; 0x7a
 800e06a:	2379      	movne	r3, #121	; 0x79
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800e06c:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800e070:	9301      	str	r3, [sp, #4]
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800e072:	bf0c      	ite	eq
 800e074:	f04f 0b8e 	moveq.w	fp, #142	; 0x8e
 800e078:	f04f 0b8d 	movne.w	fp, #141	; 0x8d
  if (beta == 0.0) {
 800e07c:	2200      	movs	r2, #0
 800e07e:	2300      	movs	r3, #0
 800e080:	4630      	mov	r0, r6
 800e082:	4639      	mov	r1, r7
 800e084:	f01a ffd8 	bl	8029038 <__aeabi_dcmpeq>
 800e088:	2800      	cmp	r0, #0
 800e08a:	d054      	beq.n	800e136 <cblas_dsymm+0x17e>
    for (i = 0; i < n1; i++) {
 800e08c:	9b06      	ldr	r3, [sp, #24]
 800e08e:	2b00      	cmp	r3, #0
 800e090:	dd19      	ble.n	800e0c6 <cblas_dsymm+0x10e>
 800e092:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e094:	9d07      	ldr	r5, [sp, #28]
 800e096:	f8dd c018 	ldr.w	ip, [sp, #24]
 800e09a:	00d4      	lsls	r4, r2, #3
 800e09c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e09e:	ebc5 7045 	rsb	r0, r5, r5, lsl #29
 800e0a2:	00c0      	lsls	r0, r0, #3
 800e0a4:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800e0a8:	2100      	movs	r1, #0
        C[ldc * i + j] = 0.0;
 800e0aa:	2600      	movs	r6, #0
 800e0ac:	2700      	movs	r7, #0
      for (j = 0; j < n2; j++) {
 800e0ae:	2d00      	cmp	r5, #0
 800e0b0:	bfc8      	it	gt
 800e0b2:	1813      	addgt	r3, r2, r0
 800e0b4:	dd03      	ble.n	800e0be <cblas_dsymm+0x106>
        C[ldc * i + j] = 0.0;
 800e0b6:	e8e3 6702 	strd	r6, r7, [r3], #8
      for (j = 0; j < n2; j++) {
 800e0ba:	4293      	cmp	r3, r2
 800e0bc:	d1fb      	bne.n	800e0b6 <cblas_dsymm+0xfe>
    for (i = 0; i < n1; i++) {
 800e0be:	3101      	adds	r1, #1
 800e0c0:	458c      	cmp	ip, r1
 800e0c2:	4422      	add	r2, r4
 800e0c4:	d1f3      	bne.n	800e0ae <cblas_dsymm+0xf6>
  if (alpha == 0.0)
 800e0c6:	ec51 0b19 	vmov	r0, r1, d9
 800e0ca:	2200      	movs	r2, #0
 800e0cc:	2300      	movs	r3, #0
 800e0ce:	f01a ffb3 	bl	8029038 <__aeabi_dcmpeq>
 800e0d2:	bb58      	cbnz	r0, 800e12c <cblas_dsymm+0x174>
  if (side == CblasLeft && uplo == CblasUpper) {
 800e0d4:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
 800e0d8:	f000 815f 	beq.w	800e39a <cblas_dsymm+0x3e2>
  } else if (side == CblasRight && uplo == CblasUpper) {
 800e0dc:	f1bb 0f8e 	cmp.w	fp, #142	; 0x8e
 800e0e0:	d075      	beq.n	800e1ce <cblas_dsymm+0x216>
    BLAS_ERROR("unrecognized operation");
 800e0e2:	4a90      	ldr	r2, [pc, #576]	; (800e324 <cblas_dsymm+0x36c>)
 800e0e4:	498d      	ldr	r1, [pc, #564]	; (800e31c <cblas_dsymm+0x364>)
 800e0e6:	2000      	movs	r0, #0
#define BASE double
#include "source_symm_r.h"
#undef BASE
}
 800e0e8:	b017      	add	sp, #92	; 0x5c
 800e0ea:	ecbd 8b06 	vpop	{d8-d10}
 800e0ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e0f2:	f01a bb09 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800e0f6:	2c65      	cmp	r4, #101	; 0x65
 800e0f8:	f000 8116 	beq.w	800e328 <cblas_dsymm+0x370>
 800e0fc:	2c66      	cmp	r4, #102	; 0x66
 800e0fe:	f000 812b 	beq.w	800e358 <cblas_dsymm+0x3a0>
 800e102:	2800      	cmp	r0, #0
 800e104:	d09b      	beq.n	800e03e <cblas_dsymm+0x86>
 800e106:	e796      	b.n	800e036 <cblas_dsymm+0x7e>
        C[i * ldc + j] += alpha * temp2;
 800e108:	2200      	movs	r2, #0
 800e10a:	2300      	movs	r3, #0
 800e10c:	ec51 0b19 	vmov	r0, r1, d9
 800e110:	f01a fd2a 	bl	8028b68 <__aeabi_dmul>
 800e114:	4622      	mov	r2, r4
 800e116:	462b      	mov	r3, r5
 800e118:	f01a fb70 	bl	80287fc <__adddf3>
 800e11c:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < n2; j++) {
 800e11e:	9a05      	ldr	r2, [sp, #20]
        C[i * ldc + j] += alpha * temp2;
 800e120:	e943 0102 	strd	r0, r1, [r3, #-8]
      for (j = 0; j < n2; j++) {
 800e124:	9b07      	ldr	r3, [sp, #28]
 800e126:	4293      	cmp	r3, r2
 800e128:	f300 82a0 	bgt.w	800e66c <cblas_dsymm+0x6b4>
 800e12c:	b017      	add	sp, #92	; 0x5c
 800e12e:	ecbd 8b06 	vpop	{d8-d10}
 800e132:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 800e136:	4b7a      	ldr	r3, [pc, #488]	; (800e320 <cblas_dsymm+0x368>)
 800e138:	2200      	movs	r2, #0
 800e13a:	4630      	mov	r0, r6
 800e13c:	4639      	mov	r1, r7
 800e13e:	f01a ff7b 	bl	8029038 <__aeabi_dcmpeq>
 800e142:	2800      	cmp	r0, #0
 800e144:	d1bf      	bne.n	800e0c6 <cblas_dsymm+0x10e>
    for (i = 0; i < n1; i++) {
 800e146:	9b06      	ldr	r3, [sp, #24]
 800e148:	2b00      	cmp	r3, #0
 800e14a:	ddbc      	ble.n	800e0c6 <cblas_dsymm+0x10e>
 800e14c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e14e:	9b07      	ldr	r3, [sp, #28]
 800e150:	f8cd b008 	str.w	fp, [sp, #8]
 800e154:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 800e158:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e15a:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 800e15e:	4680      	mov	r8, r0
 800e160:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800e164:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 800e168:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800e16a:	f1bb 0f00 	cmp.w	fp, #0
 800e16e:	bfc8      	it	gt
 800e170:	eb05 0409 	addgt.w	r4, r5, r9
 800e174:	dd09      	ble.n	800e18a <cblas_dsymm+0x1d2>
        C[ldc * i + j] *= beta;
 800e176:	e9d4 0100 	ldrd	r0, r1, [r4]
 800e17a:	4632      	mov	r2, r6
 800e17c:	463b      	mov	r3, r7
 800e17e:	f01a fcf3 	bl	8028b68 <__aeabi_dmul>
 800e182:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j < n2; j++) {
 800e186:	42ac      	cmp	r4, r5
 800e188:	d1f5      	bne.n	800e176 <cblas_dsymm+0x1be>
    for (i = 0; i < n1; i++) {
 800e18a:	9b06      	ldr	r3, [sp, #24]
 800e18c:	f108 0801 	add.w	r8, r8, #1
 800e190:	4543      	cmp	r3, r8
 800e192:	4455      	add	r5, sl
 800e194:	d1e9      	bne.n	800e16a <cblas_dsymm+0x1b2>
 800e196:	f8dd b008 	ldr.w	fp, [sp, #8]
 800e19a:	e794      	b.n	800e0c6 <cblas_dsymm+0x10e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800e19c:	429a      	cmp	r2, r3
 800e19e:	f6ff af43 	blt.w	800e028 <cblas_dsymm+0x70>
 800e1a2:	2c65      	cmp	r4, #101	; 0x65
 800e1a4:	f000 80cd 	beq.w	800e342 <cblas_dsymm+0x38a>
 800e1a8:	2c66      	cmp	r4, #102	; 0x66
 800e1aa:	f000 835c 	beq.w	800e866 <cblas_dsymm+0x8ae>
 800e1ae:	2005      	movs	r0, #5
 800e1b0:	e741      	b.n	800e036 <cblas_dsymm+0x7e>
 800e1b2:	3865      	subs	r0, #101	; 0x65
 800e1b4:	2801      	cmp	r0, #1
 800e1b6:	9b07      	ldr	r3, [sp, #28]
 800e1b8:	bf94      	ite	ls
 800e1ba:	2000      	movls	r0, #0
 800e1bc:	2001      	movhi	r0, #1
 800e1be:	e720      	b.n	800e002 <cblas_dsymm+0x4a>
    uplo = Uplo;
 800e1c0:	9b06      	ldr	r3, [sp, #24]
 800e1c2:	9a07      	ldr	r2, [sp, #28]
 800e1c4:	f8cd 8004 	str.w	r8, [sp, #4]
    side = Side;
 800e1c8:	e9cd 2306 	strd	r2, r3, [sp, #24]
 800e1cc:	e756      	b.n	800e07c <cblas_dsymm+0xc4>
  } else if (side == CblasRight && uplo == CblasUpper) {
 800e1ce:	9b01      	ldr	r3, [sp, #4]
 800e1d0:	2b79      	cmp	r3, #121	; 0x79
 800e1d2:	f000 828e 	beq.w	800e6f2 <cblas_dsymm+0x73a>
  } else if (side == CblasRight && uplo == CblasLower) {
 800e1d6:	9b01      	ldr	r3, [sp, #4]
 800e1d8:	2b7a      	cmp	r3, #122	; 0x7a
 800e1da:	d182      	bne.n	800e0e2 <cblas_dsymm+0x12a>
    for (i = 0; i < n1; i++) {
 800e1dc:	9b06      	ldr	r3, [sp, #24]
 800e1de:	2b00      	cmp	r3, #0
 800e1e0:	dda4      	ble.n	800e12c <cblas_dsymm+0x174>
 800e1e2:	990e      	ldr	r1, [sp, #56]	; 0x38
 800e1e4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e1e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e1e8:	920d      	str	r2, [sp, #52]	; 0x34
 800e1ea:	00c9      	lsls	r1, r1, #3
 800e1ec:	9110      	str	r1, [sp, #64]	; 0x40
 800e1ee:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800e1f0:	900f      	str	r0, [sp, #60]	; 0x3c
 800e1f2:	00c9      	lsls	r1, r1, #3
 800e1f4:	9111      	str	r1, [sp, #68]	; 0x44
 800e1f6:	9907      	ldr	r1, [sp, #28]
 800e1f8:	3301      	adds	r3, #1
 800e1fa:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800e1fe:	920a      	str	r2, [sp, #40]	; 0x28
 800e200:	00da      	lsls	r2, r3, #3
 800e202:	920e      	str	r2, [sp, #56]	; 0x38
 800e204:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800e206:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e20a:	9312      	str	r3, [sp, #72]	; 0x48
      for (j = 0; j < n2; j++) {
 800e20c:	9b07      	ldr	r3, [sp, #28]
 800e20e:	2b00      	cmp	r3, #0
 800e210:	f340 80af 	ble.w	800e372 <cblas_dsymm+0x3ba>
        const BASE temp1 = alpha * B[ldb * i + j];
 800e214:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e216:	4619      	mov	r1, r3
 800e218:	e8f1 2302 	ldrd	r2, r3, [r1], #8
 800e21c:	9108      	str	r1, [sp, #32]
 800e21e:	ec51 0b19 	vmov	r0, r1, d9
 800e222:	f01a fca1 	bl	8028b68 <__aeabi_dmul>
 800e226:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e228:	9304      	str	r3, [sp, #16]
 800e22a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e22c:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
 800e230:	9303      	str	r3, [sp, #12]
 800e232:	ec41 0b18 	vmov	d8, r0, r1
 800e236:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e238:	9305      	str	r3, [sp, #20]
        BASE temp2 = 0.0;
 800e23a:	f04f 0800 	mov.w	r8, #0
 800e23e:	f04f 0900 	mov.w	r9, #0
 800e242:	f8cd b008 	str.w	fp, [sp, #8]
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
 800e246:	9b03      	ldr	r3, [sp, #12]
 800e248:	ec51 0b18 	vmov	r0, r1, d8
 800e24c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800e250:	f01a fc8a 	bl	8028b68 <__aeabi_dmul>
 800e254:	4642      	mov	r2, r8
 800e256:	4604      	mov	r4, r0
 800e258:	460d      	mov	r5, r1
 800e25a:	464b      	mov	r3, r9
 800e25c:	ec51 0b19 	vmov	r0, r1, d9
 800e260:	f01a fc82 	bl	8028b68 <__aeabi_dmul>
 800e264:	9e05      	ldr	r6, [sp, #20]
 800e266:	4602      	mov	r2, r0
 800e268:	460b      	mov	r3, r1
 800e26a:	4620      	mov	r0, r4
 800e26c:	4629      	mov	r1, r5
 800e26e:	e9d6 4500 	ldrd	r4, r5, [r6]
 800e272:	f01a fac3 	bl	80287fc <__adddf3>
 800e276:	462b      	mov	r3, r5
 800e278:	4622      	mov	r2, r4
 800e27a:	f01a fabf 	bl	80287fc <__adddf3>
 800e27e:	e8e6 0102 	strd	r0, r1, [r6], #8
      for (j = 0; j < n2; j++) {
 800e282:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
 800e284:	9605      	str	r6, [sp, #20]
      for (j = 0; j < n2; j++) {
 800e286:	429e      	cmp	r6, r3
 800e288:	d073      	beq.n	800e372 <cblas_dsymm+0x3ba>
        const BASE temp1 = alpha * B[ldb * i + j];
 800e28a:	9c08      	ldr	r4, [sp, #32]
 800e28c:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800e290:	ec53 2b19 	vmov	r2, r3, d9
 800e294:	9408      	str	r4, [sp, #32]
 800e296:	f01a fc67 	bl	8028b68 <__aeabi_dmul>
 800e29a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e29c:	9a04      	ldr	r2, [sp, #16]
 800e29e:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 800e2a2:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800e2a6:	ec41 0b18 	vmov	d8, r0, r1
 800e2aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e2ac:	9301      	str	r3, [sp, #4]
        BASE temp2 = 0.0;
 800e2ae:	f04f 0800 	mov.w	r8, #0
 800e2b2:	f04f 0900 	mov.w	r9, #0
          const BASE Ajk = A[j * lda + k];
 800e2b6:	e8fb 6702 	ldrd	r6, r7, [fp], #8
          C[i * ldc + k] += temp1 * Ajk;
 800e2ba:	e9da 4500 	ldrd	r4, r5, [sl]
 800e2be:	4632      	mov	r2, r6
 800e2c0:	463b      	mov	r3, r7
 800e2c2:	ec51 0b18 	vmov	r0, r1, d8
 800e2c6:	f01a fc4f 	bl	8028b68 <__aeabi_dmul>
 800e2ca:	4622      	mov	r2, r4
 800e2cc:	462b      	mov	r3, r5
 800e2ce:	f01a fa95 	bl	80287fc <__adddf3>
 800e2d2:	e8ea 0102 	strd	r0, r1, [sl], #8
          temp2 += B[ldb * i + k] * Ajk;
 800e2d6:	9c01      	ldr	r4, [sp, #4]
 800e2d8:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800e2dc:	4632      	mov	r2, r6
 800e2de:	463b      	mov	r3, r7
 800e2e0:	9401      	str	r4, [sp, #4]
 800e2e2:	f01a fc41 	bl	8028b68 <__aeabi_dmul>
 800e2e6:	460b      	mov	r3, r1
 800e2e8:	4602      	mov	r2, r0
 800e2ea:	4649      	mov	r1, r9
 800e2ec:	4640      	mov	r0, r8
 800e2ee:	f01a fa85 	bl	80287fc <__adddf3>
        for (k = 0; k < j; k++) {
 800e2f2:	9b02      	ldr	r3, [sp, #8]
 800e2f4:	459b      	cmp	fp, r3
          temp2 += B[ldb * i + k] * Ajk;
 800e2f6:	4680      	mov	r8, r0
 800e2f8:	4689      	mov	r9, r1
        for (k = 0; k < j; k++) {
 800e2fa:	d1dc      	bne.n	800e2b6 <cblas_dsymm+0x2fe>
 800e2fc:	9a03      	ldr	r2, [sp, #12]
 800e2fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e300:	4611      	mov	r1, r2
 800e302:	4419      	add	r1, r3
 800e304:	9a04      	ldr	r2, [sp, #16]
 800e306:	9103      	str	r1, [sp, #12]
 800e308:	9909      	ldr	r1, [sp, #36]	; 0x24
 800e30a:	440a      	add	r2, r1
 800e30c:	9204      	str	r2, [sp, #16]
 800e30e:	9a02      	ldr	r2, [sp, #8]
 800e310:	441a      	add	r2, r3
 800e312:	9202      	str	r2, [sp, #8]
 800e314:	e797      	b.n	800e246 <cblas_dsymm+0x28e>
 800e316:	bf00      	nop
 800e318:	08031108 	.word	0x08031108
 800e31c:	0803121c 	.word	0x0803121c
 800e320:	3ff00000 	.word	0x3ff00000
 800e324:	080311b8 	.word	0x080311b8
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800e328:	9b06      	ldr	r3, [sp, #24]
 800e32a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e32c:	2b01      	cmp	r3, #1
 800e32e:	bfb8      	it	lt
 800e330:	2301      	movlt	r3, #1
 800e332:	4293      	cmp	r3, r2
 800e334:	dc0a      	bgt.n	800e34c <cblas_dsymm+0x394>
 800e336:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e338:	4293      	cmp	r3, r2
 800e33a:	f77f aee2 	ble.w	800e102 <cblas_dsymm+0x14a>
 800e33e:	200d      	movs	r0, #13
 800e340:	e679      	b.n	800e036 <cblas_dsymm+0x7e>
 800e342:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800e344:	2b00      	cmp	r3, #0
 800e346:	f300 81ce 	bgt.w	800e6e6 <cblas_dsymm+0x72e>
 800e34a:	2301      	movs	r3, #1
 800e34c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e34e:	429a      	cmp	r2, r3
 800e350:	bfb4      	ite	lt
 800e352:	200d      	movlt	r0, #13
 800e354:	200a      	movge	r0, #10
 800e356:	e66e      	b.n	800e036 <cblas_dsymm+0x7e>
 800e358:	9b07      	ldr	r3, [sp, #28]
 800e35a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e35c:	2b01      	cmp	r3, #1
 800e35e:	bfb8      	it	lt
 800e360:	2301      	movlt	r3, #1
 800e362:	4293      	cmp	r3, r2
 800e364:	dde7      	ble.n	800e336 <cblas_dsymm+0x37e>
 800e366:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e368:	4293      	cmp	r3, r2
 800e36a:	bfcc      	ite	gt
 800e36c:	200d      	movgt	r0, #13
 800e36e:	200a      	movle	r0, #10
 800e370:	e661      	b.n	800e036 <cblas_dsymm+0x7e>
    for (i = 0; i < n1; i++) {
 800e372:	990d      	ldr	r1, [sp, #52]	; 0x34
 800e374:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800e376:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800e378:	4608      	mov	r0, r1
 800e37a:	4410      	add	r0, r2
 800e37c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e37e:	900d      	str	r0, [sp, #52]	; 0x34
 800e380:	9811      	ldr	r0, [sp, #68]	; 0x44
 800e382:	4401      	add	r1, r0
 800e384:	910c      	str	r1, [sp, #48]	; 0x30
 800e386:	990a      	ldr	r1, [sp, #40]	; 0x28
 800e388:	4411      	add	r1, r2
 800e38a:	9a06      	ldr	r2, [sp, #24]
 800e38c:	910a      	str	r1, [sp, #40]	; 0x28
 800e38e:	3301      	adds	r3, #1
 800e390:	429a      	cmp	r2, r3
 800e392:	930f      	str	r3, [sp, #60]	; 0x3c
 800e394:	f47f af3a 	bne.w	800e20c <cblas_dsymm+0x254>
 800e398:	e6c8      	b.n	800e12c <cblas_dsymm+0x174>
  if (side == CblasLeft && uplo == CblasUpper) {
 800e39a:	9b01      	ldr	r3, [sp, #4]
 800e39c:	2b79      	cmp	r3, #121	; 0x79
 800e39e:	f000 80cb 	beq.w	800e538 <cblas_dsymm+0x580>
  } else if (side == CblasLeft && uplo == CblasLower) {
 800e3a2:	9b01      	ldr	r3, [sp, #4]
 800e3a4:	2b7a      	cmp	r3, #122	; 0x7a
 800e3a6:	f47f ae9c 	bne.w	800e0e2 <cblas_dsymm+0x12a>
    for (i = 0; i < n1; i++) {
 800e3aa:	9b06      	ldr	r3, [sp, #24]
 800e3ac:	2b00      	cmp	r3, #0
 800e3ae:	f77f aebd 	ble.w	800e12c <cblas_dsymm+0x174>
 800e3b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e3b4:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800e3b8:	900d      	str	r0, [sp, #52]	; 0x34
 800e3ba:	3301      	adds	r3, #1
 800e3bc:	00db      	lsls	r3, r3, #3
 800e3be:	f1a3 0208 	sub.w	r2, r3, #8
 800e3c2:	9312      	str	r3, [sp, #72]	; 0x48
 800e3c4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800e3c6:	9211      	str	r2, [sp, #68]	; 0x44
 800e3c8:	00db      	lsls	r3, r3, #3
 800e3ca:	9a07      	ldr	r2, [sp, #28]
 800e3cc:	9301      	str	r3, [sp, #4]
 800e3ce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e3d0:	9010      	str	r0, [sp, #64]	; 0x40
 800e3d2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e3d6:	9309      	str	r3, [sp, #36]	; 0x24
 800e3d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e3da:	9008      	str	r0, [sp, #32]
 800e3dc:	00db      	lsls	r3, r3, #3
 800e3de:	9302      	str	r3, [sp, #8]
      for (j = 0; j < n2; j++) {
 800e3e0:	9b07      	ldr	r3, [sp, #28]
 800e3e2:	2b00      	cmp	r3, #0
 800e3e4:	dd6b      	ble.n	800e4be <cblas_dsymm+0x506>
 800e3e6:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
 800e3ea:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e3ee:	9303      	str	r3, [sp, #12]
 800e3f0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800e3f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e3f4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e3f8:	9305      	str	r3, [sp, #20]
 800e3fa:	2300      	movs	r3, #0
 800e3fc:	9304      	str	r3, [sp, #16]
        const BASE temp1 = alpha * B[ldb * i + j];
 800e3fe:	9c03      	ldr	r4, [sp, #12]
 800e400:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800e404:	ec53 2b19 	vmov	r2, r3, d9
 800e408:	9403      	str	r4, [sp, #12]
 800e40a:	f01a fbad 	bl	8028b68 <__aeabi_dmul>
        for (k = 0; k < i; k++) {
 800e40e:	9b08      	ldr	r3, [sp, #32]
        const BASE temp1 = alpha * B[ldb * i + j];
 800e410:	ec41 0b18 	vmov	d8, r0, r1
        BASE temp2 = 0.0;
 800e414:	2400      	movs	r4, #0
 800e416:	2500      	movs	r5, #0
        for (k = 0; k < i; k++) {
 800e418:	b363      	cbz	r3, 800e474 <cblas_dsymm+0x4bc>
 800e41a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e41c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e41e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800e420:	4619      	mov	r1, r3
 800e422:	9b04      	ldr	r3, [sp, #16]
 800e424:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
 800e428:	eb02 0ac3 	add.w	sl, r2, r3, lsl #3
          const BASE Aik = A[i * lda + k];
 800e42c:	e8f7 8902 	ldrd	r8, r9, [r7], #8
          C[k * ldc + j] += Aik * temp1;
 800e430:	ec51 0b18 	vmov	r0, r1, d8
 800e434:	4642      	mov	r2, r8
 800e436:	464b      	mov	r3, r9
 800e438:	f01a fb96 	bl	8028b68 <__aeabi_dmul>
 800e43c:	4602      	mov	r2, r0
 800e43e:	460b      	mov	r3, r1
 800e440:	e9d6 0100 	ldrd	r0, r1, [r6]
 800e444:	f01a f9da 	bl	80287fc <__adddf3>
 800e448:	e9c6 0100 	strd	r0, r1, [r6]
          temp2 += Aik * B[ldb * k + j];
 800e44c:	4640      	mov	r0, r8
 800e44e:	e9da 2300 	ldrd	r2, r3, [sl]
 800e452:	4649      	mov	r1, r9
 800e454:	f01a fb88 	bl	8028b68 <__aeabi_dmul>
 800e458:	460b      	mov	r3, r1
 800e45a:	4602      	mov	r2, r0
 800e45c:	4629      	mov	r1, r5
 800e45e:	4620      	mov	r0, r4
 800e460:	f01a f9cc 	bl	80287fc <__adddf3>
 800e464:	9b02      	ldr	r3, [sp, #8]
 800e466:	441e      	add	r6, r3
 800e468:	9b01      	ldr	r3, [sp, #4]
        for (k = 0; k < i; k++) {
 800e46a:	45bb      	cmp	fp, r7
          temp2 += Aik * B[ldb * k + j];
 800e46c:	4604      	mov	r4, r0
 800e46e:	460d      	mov	r5, r1
        for (k = 0; k < i; k++) {
 800e470:	449a      	add	sl, r3
 800e472:	d1db      	bne.n	800e42c <cblas_dsymm+0x474>
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800e474:	e9db 2300 	ldrd	r2, r3, [fp]
 800e478:	ec51 0b18 	vmov	r0, r1, d8
 800e47c:	f01a fb74 	bl	8028b68 <__aeabi_dmul>
 800e480:	4622      	mov	r2, r4
 800e482:	462b      	mov	r3, r5
 800e484:	4604      	mov	r4, r0
 800e486:	460d      	mov	r5, r1
 800e488:	ec51 0b19 	vmov	r0, r1, d9
 800e48c:	f01a fb6c 	bl	8028b68 <__aeabi_dmul>
 800e490:	9e05      	ldr	r6, [sp, #20]
 800e492:	4602      	mov	r2, r0
 800e494:	460b      	mov	r3, r1
 800e496:	4620      	mov	r0, r4
 800e498:	4629      	mov	r1, r5
 800e49a:	e9d6 4500 	ldrd	r4, r5, [r6]
 800e49e:	f01a f9ad 	bl	80287fc <__adddf3>
 800e4a2:	4622      	mov	r2, r4
 800e4a4:	462b      	mov	r3, r5
 800e4a6:	f01a f9a9 	bl	80287fc <__adddf3>
      for (j = 0; j < n2; j++) {
 800e4aa:	9b04      	ldr	r3, [sp, #16]
 800e4ac:	9a03      	ldr	r2, [sp, #12]
 800e4ae:	3301      	adds	r3, #1
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800e4b0:	e8e6 0102 	strd	r0, r1, [r6], #8
      for (j = 0; j < n2; j++) {
 800e4b4:	9304      	str	r3, [sp, #16]
 800e4b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800e4b8:	9605      	str	r6, [sp, #20]
      for (j = 0; j < n2; j++) {
 800e4ba:	4293      	cmp	r3, r2
 800e4bc:	d19f      	bne.n	800e3fe <cblas_dsymm+0x446>
    for (i = 0; i < n1; i++) {
 800e4be:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800e4c0:	990e      	ldr	r1, [sp, #56]	; 0x38
 800e4c2:	9b08      	ldr	r3, [sp, #32]
 800e4c4:	440a      	add	r2, r1
 800e4c6:	9210      	str	r2, [sp, #64]	; 0x40
 800e4c8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800e4ca:	9901      	ldr	r1, [sp, #4]
 800e4cc:	4493      	add	fp, r2
 800e4ce:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e4d0:	440a      	add	r2, r1
 800e4d2:	9209      	str	r2, [sp, #36]	; 0x24
 800e4d4:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800e4d6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800e4d8:	440a      	add	r2, r1
 800e4da:	920d      	str	r2, [sp, #52]	; 0x34
 800e4dc:	9911      	ldr	r1, [sp, #68]	; 0x44
 800e4de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800e4e0:	440a      	add	r2, r1
 800e4e2:	920b      	str	r2, [sp, #44]	; 0x2c
 800e4e4:	9a06      	ldr	r2, [sp, #24]
 800e4e6:	3301      	adds	r3, #1
 800e4e8:	429a      	cmp	r2, r3
 800e4ea:	9308      	str	r3, [sp, #32]
 800e4ec:	f47f af78 	bne.w	800e3e0 <cblas_dsymm+0x428>
 800e4f0:	e61c      	b.n	800e12c <cblas_dsymm+0x174>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800e4f2:	9b06      	ldr	r3, [sp, #24]
 800e4f4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e4f6:	2b01      	cmp	r3, #1
 800e4f8:	bfb8      	it	lt
 800e4fa:	2301      	movlt	r3, #1
 800e4fc:	4293      	cmp	r3, r2
 800e4fe:	f73f af25 	bgt.w	800e34c <cblas_dsymm+0x394>
 800e502:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e504:	4293      	cmp	r3, r2
 800e506:	bfcc      	ite	gt
 800e508:	200d      	movgt	r0, #13
 800e50a:	2008      	movle	r0, #8
 800e50c:	e593      	b.n	800e036 <cblas_dsymm+0x7e>
 800e50e:	9b07      	ldr	r3, [sp, #28]
 800e510:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e512:	2b01      	cmp	r3, #1
 800e514:	bfb8      	it	lt
 800e516:	2301      	movlt	r3, #1
 800e518:	429a      	cmp	r2, r3
 800e51a:	f6ff af24 	blt.w	800e366 <cblas_dsymm+0x3ae>
 800e51e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e520:	429a      	cmp	r2, r3
 800e522:	bfac      	ite	ge
 800e524:	2008      	movge	r0, #8
 800e526:	200d      	movlt	r0, #13
 800e528:	e585      	b.n	800e036 <cblas_dsymm+0x7e>
 800e52a:	3865      	subs	r0, #101	; 0x65
 800e52c:	2801      	cmp	r0, #1
 800e52e:	9b06      	ldr	r3, [sp, #24]
 800e530:	bf94      	ite	ls
 800e532:	2000      	movls	r0, #0
 800e534:	2001      	movhi	r0, #1
 800e536:	e564      	b.n	800e002 <cblas_dsymm+0x4a>
    for (i = 0; i < n1; i++) {
 800e538:	9a06      	ldr	r2, [sp, #24]
 800e53a:	2a00      	cmp	r2, #0
 800e53c:	f77f adf6 	ble.w	800e12c <cblas_dsymm+0x174>
 800e540:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e542:	9010      	str	r0, [sp, #64]	; 0x40
 800e544:	3301      	adds	r3, #1
 800e546:	00db      	lsls	r3, r3, #3
 800e548:	9315      	str	r3, [sp, #84]	; 0x54
 800e54a:	3b08      	subs	r3, #8
 800e54c:	9314      	str	r3, [sp, #80]	; 0x50
 800e54e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e550:	9012      	str	r0, [sp, #72]	; 0x48
 800e552:	f103 0108 	add.w	r1, r3, #8
 800e556:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800e55a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e55c:	9108      	str	r1, [sp, #32]
 800e55e:	00da      	lsls	r2, r3, #3
 800e560:	9202      	str	r2, [sp, #8]
 800e562:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e564:	9313      	str	r3, [sp, #76]	; 0x4c
 800e566:	00d1      	lsls	r1, r2, #3
 800e568:	2301      	movs	r3, #1
 800e56a:	9101      	str	r1, [sp, #4]
 800e56c:	9211      	str	r2, [sp, #68]	; 0x44
 800e56e:	9309      	str	r3, [sp, #36]	; 0x24
      for (j = 0; j < n2; j++) {
 800e570:	9b07      	ldr	r3, [sp, #28]
 800e572:	2b00      	cmp	r3, #0
 800e574:	f340 8098 	ble.w	800e6a8 <cblas_dsymm+0x6f0>
 800e578:	e9dd 1312 	ldrd	r1, r3, [sp, #72]	; 0x48
 800e57c:	1a5a      	subs	r2, r3, r1
 800e57e:	e9dd 0310 	ldrd	r0, r3, [sp, #64]	; 0x40
 800e582:	1a1b      	subs	r3, r3, r0
 800e584:	00db      	lsls	r3, r3, #3
 800e586:	3b08      	subs	r3, #8
 800e588:	930d      	str	r3, [sp, #52]	; 0x34
 800e58a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e58c:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800e590:	9304      	str	r3, [sp, #16]
 800e592:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e594:	00d2      	lsls	r2, r2, #3
 800e596:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800e59a:	3a08      	subs	r2, #8
 800e59c:	9303      	str	r3, [sp, #12]
 800e59e:	2301      	movs	r3, #1
 800e5a0:	920b      	str	r2, [sp, #44]	; 0x2c
 800e5a2:	9305      	str	r3, [sp, #20]
        const BASE temp1 = alpha * B[ldb * i + j];
 800e5a4:	9c04      	ldr	r4, [sp, #16]
 800e5a6:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800e5aa:	ec53 2b19 	vmov	r2, r3, d9
 800e5ae:	9404      	str	r4, [sp, #16]
 800e5b0:	f01a fada 	bl	8028b68 <__aeabi_dmul>
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800e5b4:	9b03      	ldr	r3, [sp, #12]
 800e5b6:	9a08      	ldr	r2, [sp, #32]
 800e5b8:	e9d3 4500 	ldrd	r4, r5, [r3]
 800e5bc:	e952 2302 	ldrd	r2, r3, [r2, #-8]
        const BASE temp1 = alpha * B[ldb * i + j];
 800e5c0:	4606      	mov	r6, r0
 800e5c2:	460f      	mov	r7, r1
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800e5c4:	f01a fad0 	bl	8028b68 <__aeabi_dmul>
 800e5c8:	462b      	mov	r3, r5
 800e5ca:	4622      	mov	r2, r4
 800e5cc:	f01a f916 	bl	80287fc <__adddf3>
 800e5d0:	9b03      	ldr	r3, [sp, #12]
 800e5d2:	4604      	mov	r4, r0
 800e5d4:	460d      	mov	r5, r1
 800e5d6:	4619      	mov	r1, r3
 800e5d8:	e8e1 4502 	strd	r4, r5, [r1], #8
        const BASE temp1 = alpha * B[ldb * i + j];
 800e5dc:	ec47 6b18 	vmov	d8, r6, r7
        for (k = i + 1; k < n1; k++) {
 800e5e0:	9806      	ldr	r0, [sp, #24]
 800e5e2:	9e09      	ldr	r6, [sp, #36]	; 0x24
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800e5e4:	9103      	str	r1, [sp, #12]
        for (k = i + 1; k < n1; k++) {
 800e5e6:	42b0      	cmp	r0, r6
 800e5e8:	f77f ad8e 	ble.w	800e108 <cblas_dsymm+0x150>
 800e5ec:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800e5ee:	9b04      	ldr	r3, [sp, #16]
 800e5f0:	9f08      	ldr	r7, [sp, #32]
 800e5f2:	1846      	adds	r6, r0, r1
 800e5f4:	990d      	ldr	r1, [sp, #52]	; 0x34
        BASE temp2 = 0.0;
 800e5f6:	2400      	movs	r4, #0
 800e5f8:	2500      	movs	r5, #0
 800e5fa:	eb01 0a03 	add.w	sl, r1, r3
          const BASE Aik = A[i * lda + k];
 800e5fe:	e8f7 8902 	ldrd	r8, r9, [r7], #8
          C[k * ldc + j] += Aik * temp1;
 800e602:	ec51 0b18 	vmov	r0, r1, d8
 800e606:	4642      	mov	r2, r8
 800e608:	464b      	mov	r3, r9
 800e60a:	f01a faad 	bl	8028b68 <__aeabi_dmul>
 800e60e:	4602      	mov	r2, r0
 800e610:	460b      	mov	r3, r1
 800e612:	e9d6 0100 	ldrd	r0, r1, [r6]
 800e616:	f01a f8f1 	bl	80287fc <__adddf3>
 800e61a:	e9c6 0100 	strd	r0, r1, [r6]
          temp2 += Aik * B[ldb * k + j];
 800e61e:	4640      	mov	r0, r8
 800e620:	e9da 2300 	ldrd	r2, r3, [sl]
 800e624:	4649      	mov	r1, r9
 800e626:	f01a fa9f 	bl	8028b68 <__aeabi_dmul>
 800e62a:	460b      	mov	r3, r1
 800e62c:	4602      	mov	r2, r0
 800e62e:	4629      	mov	r1, r5
 800e630:	4620      	mov	r0, r4
 800e632:	f01a f8e3 	bl	80287fc <__adddf3>
 800e636:	9b02      	ldr	r3, [sp, #8]
 800e638:	441e      	add	r6, r3
 800e63a:	9b01      	ldr	r3, [sp, #4]
        for (k = i + 1; k < n1; k++) {
 800e63c:	45bb      	cmp	fp, r7
          temp2 += Aik * B[ldb * k + j];
 800e63e:	4604      	mov	r4, r0
 800e640:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 800e642:	449a      	add	sl, r3
 800e644:	d1db      	bne.n	800e5fe <cblas_dsymm+0x646>
        C[i * ldc + j] += alpha * temp2;
 800e646:	4602      	mov	r2, r0
 800e648:	460b      	mov	r3, r1
 800e64a:	ec51 0b19 	vmov	r0, r1, d9
 800e64e:	f01a fa8b 	bl	8028b68 <__aeabi_dmul>
 800e652:	9c03      	ldr	r4, [sp, #12]
 800e654:	4602      	mov	r2, r0
 800e656:	460b      	mov	r3, r1
 800e658:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 800e65c:	f01a f8ce 	bl	80287fc <__adddf3>
      for (j = 0; j < n2; j++) {
 800e660:	9b07      	ldr	r3, [sp, #28]
 800e662:	9a05      	ldr	r2, [sp, #20]
 800e664:	4293      	cmp	r3, r2
        C[i * ldc + j] += alpha * temp2;
 800e666:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (j = 0; j < n2; j++) {
 800e66a:	dd03      	ble.n	800e674 <cblas_dsymm+0x6bc>
 800e66c:	9b05      	ldr	r3, [sp, #20]
 800e66e:	3301      	adds	r3, #1
 800e670:	9305      	str	r3, [sp, #20]
 800e672:	e797      	b.n	800e5a4 <cblas_dsymm+0x5ec>
    for (i = 0; i < n1; i++) {
 800e674:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e676:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800e678:	3301      	adds	r3, #1
 800e67a:	9309      	str	r3, [sp, #36]	; 0x24
 800e67c:	9b08      	ldr	r3, [sp, #32]
 800e67e:	4413      	add	r3, r2
 800e680:	9308      	str	r3, [sp, #32]
 800e682:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800e684:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800e686:	4611      	mov	r1, r2
 800e688:	449b      	add	fp, r3
 800e68a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800e68c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e68e:	441a      	add	r2, r3
 800e690:	9212      	str	r2, [sp, #72]	; 0x48
 800e692:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800e694:	4419      	add	r1, r3
 800e696:	9113      	str	r1, [sp, #76]	; 0x4c
 800e698:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800e69a:	4611      	mov	r1, r2
 800e69c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800e69e:	4419      	add	r1, r3
 800e6a0:	441a      	add	r2, r3
 800e6a2:	9111      	str	r1, [sp, #68]	; 0x44
 800e6a4:	9210      	str	r2, [sp, #64]	; 0x40
 800e6a6:	e763      	b.n	800e570 <cblas_dsymm+0x5b8>
 800e6a8:	9a08      	ldr	r2, [sp, #32]
 800e6aa:	9915      	ldr	r1, [sp, #84]	; 0x54
 800e6ac:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800e6ae:	440a      	add	r2, r1
 800e6b0:	9208      	str	r2, [sp, #32]
 800e6b2:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800e6b4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800e6b6:	4608      	mov	r0, r1
 800e6b8:	4493      	add	fp, r2
 800e6ba:	9912      	ldr	r1, [sp, #72]	; 0x48
 800e6bc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e6be:	4411      	add	r1, r2
 800e6c0:	9112      	str	r1, [sp, #72]	; 0x48
 800e6c2:	9911      	ldr	r1, [sp, #68]	; 0x44
 800e6c4:	4410      	add	r0, r2
 800e6c6:	9013      	str	r0, [sp, #76]	; 0x4c
 800e6c8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e6ca:	4608      	mov	r0, r1
 800e6cc:	9910      	ldr	r1, [sp, #64]	; 0x40
 800e6ce:	4410      	add	r0, r2
 800e6d0:	4411      	add	r1, r2
 800e6d2:	9a06      	ldr	r2, [sp, #24]
 800e6d4:	9011      	str	r0, [sp, #68]	; 0x44
 800e6d6:	4623      	mov	r3, r4
 800e6d8:	3301      	adds	r3, #1
 800e6da:	42a2      	cmp	r2, r4
 800e6dc:	9110      	str	r1, [sp, #64]	; 0x40
 800e6de:	9309      	str	r3, [sp, #36]	; 0x24
 800e6e0:	f73f af46 	bgt.w	800e570 <cblas_dsymm+0x5b8>
 800e6e4:	e522      	b.n	800e12c <cblas_dsymm+0x174>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800e6e6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800e6e8:	2b00      	cmp	r3, #0
 800e6ea:	bfcc      	ite	gt
 800e6ec:	2005      	movgt	r0, #5
 800e6ee:	200d      	movle	r0, #13
 800e6f0:	e4a1      	b.n	800e036 <cblas_dsymm+0x7e>
    for (i = 0; i < n1; i++) {
 800e6f2:	9b06      	ldr	r3, [sp, #24]
 800e6f4:	2b00      	cmp	r3, #0
 800e6f6:	f77f ad19 	ble.w	800e12c <cblas_dsymm+0x174>
 800e6fa:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e6fc:	900d      	str	r0, [sp, #52]	; 0x34
 800e6fe:	1c53      	adds	r3, r2, #1
 800e700:	00db      	lsls	r3, r3, #3
 800e702:	9308      	str	r3, [sp, #32]
 800e704:	00d3      	lsls	r3, r2, #3
 800e706:	9305      	str	r3, [sp, #20]
 800e708:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800e70a:	9009      	str	r0, [sp, #36]	; 0x24
 800e70c:	00db      	lsls	r3, r3, #3
 800e70e:	9312      	str	r3, [sp, #72]	; 0x48
 800e710:	9b07      	ldr	r3, [sp, #28]
 800e712:	9010      	str	r0, [sp, #64]	; 0x40
 800e714:	00da      	lsls	r2, r3, #3
 800e716:	9214      	str	r2, [sp, #80]	; 0x50
 800e718:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e71a:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800e71e:	9204      	str	r2, [sp, #16]
 800e720:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800e722:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e726:	9313      	str	r3, [sp, #76]	; 0x4c
      for (j = 0; j < n2; j++) {
 800e728:	9b07      	ldr	r3, [sp, #28]
 800e72a:	2b00      	cmp	r3, #0
 800e72c:	f340 8087 	ble.w	800e83e <cblas_dsymm+0x886>
 800e730:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e732:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e734:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e738:	9303      	str	r3, [sp, #12]
 800e73a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e73c:	00da      	lsls	r2, r3, #3
 800e73e:	9211      	str	r2, [sp, #68]	; 0x44
 800e740:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e742:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e746:	9301      	str	r3, [sp, #4]
 800e748:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e74a:	3308      	adds	r3, #8
 800e74c:	9302      	str	r3, [sp, #8]
 800e74e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800e750:	469b      	mov	fp, r3
        const BASE temp1 = alpha * B[ldb * i + j];
 800e752:	9c03      	ldr	r4, [sp, #12]
 800e754:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800e758:	ec53 2b19 	vmov	r2, r3, d9
 800e75c:	9403      	str	r4, [sp, #12]
 800e75e:	f01a fa03 	bl	8028b68 <__aeabi_dmul>
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800e762:	9a01      	ldr	r2, [sp, #4]
 800e764:	9b02      	ldr	r3, [sp, #8]
 800e766:	e9d2 4500 	ldrd	r4, r5, [r2]
 800e76a:	e953 2302 	ldrd	r2, r3, [r3, #-8]
        const BASE temp1 = alpha * B[ldb * i + j];
 800e76e:	4606      	mov	r6, r0
 800e770:	460f      	mov	r7, r1
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800e772:	f01a f9f9 	bl	8028b68 <__aeabi_dmul>
 800e776:	4622      	mov	r2, r4
 800e778:	462b      	mov	r3, r5
 800e77a:	f01a f83f 	bl	80287fc <__adddf3>
 800e77e:	9a01      	ldr	r2, [sp, #4]
        for (k = j + 1; k < n2; k++) {
 800e780:	9b03      	ldr	r3, [sp, #12]
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800e782:	460d      	mov	r5, r1
 800e784:	4604      	mov	r4, r0
 800e786:	4611      	mov	r1, r2
 800e788:	e8e1 4502 	strd	r4, r5, [r1], #8
        for (k = j + 1; k < n2; k++) {
 800e78c:	9a04      	ldr	r2, [sp, #16]
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800e78e:	9101      	str	r1, [sp, #4]
        for (k = j + 1; k < n2; k++) {
 800e790:	429a      	cmp	r2, r3
        const BASE temp1 = alpha * B[ldb * i + j];
 800e792:	ec47 6b1a 	vmov	d10, r6, r7
        for (k = j + 1; k < n2; k++) {
 800e796:	d040      	beq.n	800e81a <cblas_dsymm+0x862>
 800e798:	9c02      	ldr	r4, [sp, #8]
        BASE temp2 = 0.0;
 800e79a:	f04f 0800 	mov.w	r8, #0
 800e79e:	f04f 0900 	mov.w	r9, #0
        for (k = j + 1; k < n2; k++) {
 800e7a2:	469a      	mov	sl, r3
 800e7a4:	460d      	mov	r5, r1
          const BASE Ajk = A[j * lda + k];
 800e7a6:	e8f4 6702 	ldrd	r6, r7, [r4], #8
          C[i * ldc + k] += temp1 * Ajk;
 800e7aa:	ed95 7b00 	vldr	d7, [r5]
 800e7ae:	4632      	mov	r2, r6
 800e7b0:	463b      	mov	r3, r7
 800e7b2:	ec51 0b1a 	vmov	r0, r1, d10
 800e7b6:	eeb0 8a47 	vmov.f32	s16, s14
 800e7ba:	eef0 8a67 	vmov.f32	s17, s15
 800e7be:	f01a f9d3 	bl	8028b68 <__aeabi_dmul>
 800e7c2:	ec53 2b18 	vmov	r2, r3, d8
 800e7c6:	f01a f819 	bl	80287fc <__adddf3>
 800e7ca:	e8e5 0102 	strd	r0, r1, [r5], #8
          temp2 += B[ldb * i + k] * Ajk;
 800e7ce:	4632      	mov	r2, r6
 800e7d0:	463b      	mov	r3, r7
 800e7d2:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 800e7d6:	f01a f9c7 	bl	8028b68 <__aeabi_dmul>
 800e7da:	4602      	mov	r2, r0
 800e7dc:	460b      	mov	r3, r1
 800e7de:	4640      	mov	r0, r8
 800e7e0:	4649      	mov	r1, r9
 800e7e2:	f01a f80b 	bl	80287fc <__adddf3>
        for (k = j + 1; k < n2; k++) {
 800e7e6:	455c      	cmp	r4, fp
          temp2 += B[ldb * i + k] * Ajk;
 800e7e8:	4680      	mov	r8, r0
 800e7ea:	4689      	mov	r9, r1
        for (k = j + 1; k < n2; k++) {
 800e7ec:	d1db      	bne.n	800e7a6 <cblas_dsymm+0x7ee>
        C[i * ldc + j] += alpha * temp2;
 800e7ee:	4602      	mov	r2, r0
 800e7f0:	460b      	mov	r3, r1
 800e7f2:	ec51 0b19 	vmov	r0, r1, d9
 800e7f6:	f01a f9b7 	bl	8028b68 <__aeabi_dmul>
 800e7fa:	9c01      	ldr	r4, [sp, #4]
 800e7fc:	4602      	mov	r2, r0
 800e7fe:	460b      	mov	r3, r1
 800e800:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 800e804:	f019 fffa 	bl	80287fc <__adddf3>
 800e808:	9b02      	ldr	r3, [sp, #8]
 800e80a:	9a08      	ldr	r2, [sp, #32]
 800e80c:	4413      	add	r3, r2
 800e80e:	9302      	str	r3, [sp, #8]
 800e810:	9b05      	ldr	r3, [sp, #20]
 800e812:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (j = 0; j < n2; j++) {
 800e816:	449b      	add	fp, r3
 800e818:	e79b      	b.n	800e752 <cblas_dsymm+0x79a>
        C[i * ldc + j] += alpha * temp2;
 800e81a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800e81c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800e81e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800e820:	4413      	add	r3, r2
 800e822:	461e      	mov	r6, r3
 800e824:	2200      	movs	r2, #0
 800e826:	2300      	movs	r3, #0
 800e828:	ec51 0b19 	vmov	r0, r1, d9
 800e82c:	f01a f99c 	bl	8028b68 <__aeabi_dmul>
 800e830:	4622      	mov	r2, r4
 800e832:	462b      	mov	r3, r5
 800e834:	f019 ffe2 	bl	80287fc <__adddf3>
 800e838:	443e      	add	r6, r7
 800e83a:	e946 0102 	strd	r0, r1, [r6, #-8]
    for (i = 0; i < n1; i++) {
 800e83e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800e840:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800e842:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800e844:	440a      	add	r2, r1
 800e846:	9209      	str	r2, [sp, #36]	; 0x24
 800e848:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
 800e84c:	440a      	add	r2, r1
 800e84e:	920d      	str	r2, [sp, #52]	; 0x34
 800e850:	9912      	ldr	r1, [sp, #72]	; 0x48
 800e852:	9a04      	ldr	r2, [sp, #16]
 800e854:	440a      	add	r2, r1
 800e856:	9204      	str	r2, [sp, #16]
 800e858:	9a06      	ldr	r2, [sp, #24]
 800e85a:	3301      	adds	r3, #1
 800e85c:	429a      	cmp	r2, r3
 800e85e:	9310      	str	r3, [sp, #64]	; 0x40
 800e860:	f47f af62 	bne.w	800e728 <cblas_dsymm+0x770>
 800e864:	e462      	b.n	800e12c <cblas_dsymm+0x174>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800e866:	9b07      	ldr	r3, [sp, #28]
 800e868:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800e86a:	2b01      	cmp	r3, #1
 800e86c:	bfb8      	it	lt
 800e86e:	2301      	movlt	r3, #1
 800e870:	429a      	cmp	r2, r3
 800e872:	f6ff ad78 	blt.w	800e366 <cblas_dsymm+0x3ae>
 800e876:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e878:	429a      	cmp	r2, r3
 800e87a:	bfac      	ite	ge
 800e87c:	2005      	movge	r0, #5
 800e87e:	200d      	movlt	r0, #13
 800e880:	f7ff bbd9 	b.w	800e036 <cblas_dsymm+0x7e>

0800e884 <cblas_dsymv>:
void
cblas_dsymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const double alpha, const double *A, const int lda,
             const double *X, const int incX, const double beta, double *Y,
             const int incY)
{
 800e884:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e888:	ed2d 8b04 	vpush	{d8-d9}
 800e88c:	eeb0 9a40 	vmov.f32	s18, s0
 800e890:	eef0 9a60 	vmov.f32	s19, s1
 800e894:	b08f      	sub	sp, #60	; 0x3c
 800e896:	4688      	mov	r8, r1
 800e898:	9308      	str	r3, [sp, #32]
 800e89a:	e9dd a31c 	ldrd	sl, r3, [sp, #112]	; 0x70
 800e89e:	9304      	str	r3, [sp, #16]
 800e8a0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800e8a2:	9303      	str	r3, [sp, #12]
 800e8a4:	3979      	subs	r1, #121	; 0x79
 800e8a6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800e8a8:	9305      	str	r3, [sp, #20]
 800e8aa:	2901      	cmp	r1, #1
 800e8ac:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e8ae:	9300      	str	r3, [sp, #0]
 800e8b0:	ec57 6b11 	vmov	r6, r7, d1
 800e8b4:	4681      	mov	r9, r0
 800e8b6:	4693      	mov	fp, r2
 800e8b8:	f240 80c9 	bls.w	800ea4e <cblas_dsymv+0x1ca>
 800e8bc:	2002      	movs	r0, #2
 800e8be:	f1bb 0f00 	cmp.w	fp, #0
 800e8c2:	f2c0 80b6 	blt.w	800ea32 <cblas_dsymv+0x1ae>
 800e8c6:	465b      	mov	r3, fp
 800e8c8:	2b01      	cmp	r3, #1
 800e8ca:	bfb8      	it	lt
 800e8cc:	2301      	movlt	r3, #1
 800e8ce:	4553      	cmp	r3, sl
 800e8d0:	f340 809d 	ble.w	800ea0e <cblas_dsymv+0x18a>
 800e8d4:	9b03      	ldr	r3, [sp, #12]
 800e8d6:	2b00      	cmp	r3, #0
 800e8d8:	f040 80a5 	bne.w	800ea26 <cblas_dsymv+0x1a2>
 800e8dc:	9b00      	ldr	r3, [sp, #0]
 800e8de:	2b00      	cmp	r3, #0
 800e8e0:	bf0c      	ite	eq
 800e8e2:	200b      	moveq	r0, #11
 800e8e4:	2008      	movne	r0, #8
 800e8e6:	4a5d      	ldr	r2, [pc, #372]	; (800ea5c <cblas_dsymv+0x1d8>)
 800e8e8:	495d      	ldr	r1, [pc, #372]	; (800ea60 <cblas_dsymv+0x1dc>)
 800e8ea:	f019 ff0d 	bl	8028708 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800e8ee:	2200      	movs	r2, #0
 800e8f0:	ec51 0b19 	vmov	r0, r1, d9
 800e8f4:	2300      	movs	r3, #0
 800e8f6:	f01a fb9f 	bl	8029038 <__aeabi_dcmpeq>
 800e8fa:	2200      	movs	r2, #0
 800e8fc:	2800      	cmp	r0, #0
 800e8fe:	d055      	beq.n	800e9ac <cblas_dsymv+0x128>
 800e900:	4b58      	ldr	r3, [pc, #352]	; (800ea64 <cblas_dsymv+0x1e0>)
 800e902:	4630      	mov	r0, r6
 800e904:	4639      	mov	r1, r7
 800e906:	f01a fb97 	bl	8029038 <__aeabi_dcmpeq>
 800e90a:	2800      	cmp	r0, #0
 800e90c:	d149      	bne.n	800e9a2 <cblas_dsymv+0x11e>
  if (beta == 0.0) {
 800e90e:	2200      	movs	r2, #0
 800e910:	2300      	movs	r3, #0
 800e912:	4630      	mov	r0, r6
 800e914:	4639      	mov	r1, r7
 800e916:	f01a fb8f 	bl	8029038 <__aeabi_dcmpeq>
 800e91a:	2800      	cmp	r0, #0
 800e91c:	d055      	beq.n	800e9ca <cblas_dsymv+0x146>
    INDEX iy = OFFSET(N, incY);
 800e91e:	9a00      	ldr	r2, [sp, #0]
 800e920:	2a00      	cmp	r2, #0
 800e922:	f340 816b 	ble.w	800ebfc <cblas_dsymv+0x378>
 800e926:	2300      	movs	r3, #0
    for (i = 0; i < N; i++) {
 800e928:	f1bb 0f00 	cmp.w	fp, #0
 800e92c:	dd0d      	ble.n	800e94a <cblas_dsymv+0xc6>
 800e92e:	9a05      	ldr	r2, [sp, #20]
 800e930:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e934:	9a00      	ldr	r2, [sp, #0]
      Y[iy] = 0.0;
 800e936:	2400      	movs	r4, #0
 800e938:	00d1      	lsls	r1, r2, #3
 800e93a:	2500      	movs	r5, #0
    for (i = 0; i < N; i++) {
 800e93c:	2200      	movs	r2, #0
 800e93e:	3201      	adds	r2, #1
 800e940:	4593      	cmp	fp, r2
      Y[iy] = 0.0;
 800e942:	e9c3 4500 	strd	r4, r5, [r3]
    for (i = 0; i < N; i++) {
 800e946:	440b      	add	r3, r1
 800e948:	d1f9      	bne.n	800e93e <cblas_dsymv+0xba>
  if (alpha == 0.0)
 800e94a:	ec51 0b19 	vmov	r0, r1, d9
 800e94e:	2200      	movs	r2, #0
 800e950:	2300      	movs	r3, #0
 800e952:	f01a fb71 	bl	8029038 <__aeabi_dcmpeq>
 800e956:	bb20      	cbnz	r0, 800e9a2 <cblas_dsymv+0x11e>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800e958:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 800e95c:	f000 8146 	beq.w	800ebec <cblas_dsymv+0x368>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800e960:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 800e964:	f000 8082 	beq.w	800ea6c <cblas_dsymv+0x1e8>
    BLAS_ERROR("unrecognized operation");
 800e968:	4a3f      	ldr	r2, [pc, #252]	; (800ea68 <cblas_dsymv+0x1e4>)
 800e96a:	493d      	ldr	r1, [pc, #244]	; (800ea60 <cblas_dsymv+0x1dc>)
 800e96c:	2000      	movs	r0, #0
#define BASE double
#include "source_symv.h"
#undef BASE
}
 800e96e:	b00f      	add	sp, #60	; 0x3c
 800e970:	ecbd 8b04 	vpop	{d8-d9}
 800e974:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e978:	f019 bec6 	b.w	8028708 <cblas_xerbla>
      Y[iy] += alpha * temp2;
 800e97c:	9b00      	ldr	r3, [sp, #0]
 800e97e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800e980:	fb03 2606 	mla	r6, r3, r6, r2
      Y[iy] += alpha * temp2;
 800e984:	2200      	movs	r2, #0
 800e986:	2300      	movs	r3, #0
 800e988:	ec51 0b19 	vmov	r0, r1, d9
 800e98c:	f01a f8ec 	bl	8028b68 <__aeabi_dmul>
 800e990:	4622      	mov	r2, r4
 800e992:	462b      	mov	r3, r5
 800e994:	9f05      	ldr	r7, [sp, #20]
 800e996:	f019 ff31 	bl	80287fc <__adddf3>
 800e99a:	eb07 06c6 	add.w	r6, r7, r6, lsl #3
 800e99e:	e9c6 0100 	strd	r0, r1, [r6]
 800e9a2:	b00f      	add	sp, #60	; 0x3c
 800e9a4:	ecbd 8b04 	vpop	{d8-d9}
 800e9a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (beta == 0.0) {
 800e9ac:	2300      	movs	r3, #0
 800e9ae:	4630      	mov	r0, r6
 800e9b0:	4639      	mov	r1, r7
 800e9b2:	f01a fb41 	bl	8029038 <__aeabi_dcmpeq>
 800e9b6:	2800      	cmp	r0, #0
 800e9b8:	d1b1      	bne.n	800e91e <cblas_dsymv+0x9a>
  } else if (beta != 1.0) {
 800e9ba:	4b2a      	ldr	r3, [pc, #168]	; (800ea64 <cblas_dsymv+0x1e0>)
 800e9bc:	2200      	movs	r2, #0
 800e9be:	4630      	mov	r0, r6
 800e9c0:	4639      	mov	r1, r7
 800e9c2:	f01a fb39 	bl	8029038 <__aeabi_dcmpeq>
 800e9c6:	2800      	cmp	r0, #0
 800e9c8:	d1c6      	bne.n	800e958 <cblas_dsymv+0xd4>
    INDEX iy = OFFSET(N, incY);
 800e9ca:	9b00      	ldr	r3, [sp, #0]
 800e9cc:	2b00      	cmp	r3, #0
 800e9ce:	f340 8108 	ble.w	800ebe2 <cblas_dsymv+0x35e>
 800e9d2:	2400      	movs	r4, #0
    for (i = 0; i < N; i++) {
 800e9d4:	f1bb 0f00 	cmp.w	fp, #0
 800e9d8:	ddb7      	ble.n	800e94a <cblas_dsymv+0xc6>
 800e9da:	9b05      	ldr	r3, [sp, #20]
 800e9dc:	f8cd a004 	str.w	sl, [sp, #4]
 800e9e0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 800e9e4:	9b00      	ldr	r3, [sp, #0]
 800e9e6:	00db      	lsls	r3, r3, #3
 800e9e8:	46c2      	mov	sl, r8
 800e9ea:	2500      	movs	r5, #0
 800e9ec:	4698      	mov	r8, r3
      Y[iy] *= beta;
 800e9ee:	e9d4 0100 	ldrd	r0, r1, [r4]
 800e9f2:	4632      	mov	r2, r6
 800e9f4:	463b      	mov	r3, r7
 800e9f6:	f01a f8b7 	bl	8028b68 <__aeabi_dmul>
    for (i = 0; i < N; i++) {
 800e9fa:	3501      	adds	r5, #1
 800e9fc:	45ab      	cmp	fp, r5
      Y[iy] *= beta;
 800e9fe:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 800ea02:	4444      	add	r4, r8
 800ea04:	d1f3      	bne.n	800e9ee <cblas_dsymv+0x16a>
 800ea06:	46d0      	mov	r8, sl
 800ea08:	f8dd a004 	ldr.w	sl, [sp, #4]
 800ea0c:	e79d      	b.n	800e94a <cblas_dsymv+0xc6>
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 800ea0e:	9b03      	ldr	r3, [sp, #12]
 800ea10:	2b00      	cmp	r3, #0
 800ea12:	f43f af63 	beq.w	800e8dc <cblas_dsymv+0x58>
 800ea16:	9b00      	ldr	r3, [sp, #0]
 800ea18:	2b00      	cmp	r3, #0
 800ea1a:	f000 81a3 	beq.w	800ed64 <cblas_dsymv+0x4e0>
 800ea1e:	2800      	cmp	r0, #0
 800ea20:	f43f af65 	beq.w	800e8ee <cblas_dsymv+0x6a>
 800ea24:	e75f      	b.n	800e8e6 <cblas_dsymv+0x62>
 800ea26:	9b00      	ldr	r3, [sp, #0]
 800ea28:	2b00      	cmp	r3, #0
 800ea2a:	bf0c      	ite	eq
 800ea2c:	200b      	moveq	r0, #11
 800ea2e:	2006      	movne	r0, #6
 800ea30:	e759      	b.n	800e8e6 <cblas_dsymv+0x62>
 800ea32:	f1ba 0f00 	cmp.w	sl, #0
 800ea36:	f77f af4d 	ble.w	800e8d4 <cblas_dsymv+0x50>
 800ea3a:	9b03      	ldr	r3, [sp, #12]
 800ea3c:	2b00      	cmp	r3, #0
 800ea3e:	f43f af4d 	beq.w	800e8dc <cblas_dsymv+0x58>
 800ea42:	9b00      	ldr	r3, [sp, #0]
 800ea44:	2b00      	cmp	r3, #0
 800ea46:	bf0c      	ite	eq
 800ea48:	200b      	moveq	r0, #11
 800ea4a:	2003      	movne	r0, #3
 800ea4c:	e74b      	b.n	800e8e6 <cblas_dsymv+0x62>
 800ea4e:	3865      	subs	r0, #101	; 0x65
 800ea50:	2801      	cmp	r0, #1
 800ea52:	bf94      	ite	ls
 800ea54:	2000      	movls	r0, #0
 800ea56:	2001      	movhi	r0, #1
 800ea58:	e731      	b.n	800e8be <cblas_dsymv+0x3a>
 800ea5a:	bf00      	nop
 800ea5c:	08031108 	.word	0x08031108
 800ea60:	0803122c 	.word	0x0803122c
 800ea64:	3ff00000 	.word	0x3ff00000
 800ea68:	080311b8 	.word	0x080311b8
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800ea6c:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 800ea70:	f000 80c9 	beq.w	800ec06 <cblas_dsymv+0x382>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800ea74:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 800ea78:	f47f af76 	bne.w	800e968 <cblas_dsymv+0xe4>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800ea7c:	9b03      	ldr	r3, [sp, #12]
 800ea7e:	2b00      	cmp	r3, #0
 800ea80:	f340 8172 	ble.w	800ed68 <cblas_dsymv+0x4e4>
 800ea84:	f10b 33ff 	add.w	r3, fp, #4294967295
 800ea88:	9301      	str	r3, [sp, #4]
 800ea8a:	2300      	movs	r3, #0
 800ea8c:	9901      	ldr	r1, [sp, #4]
 800ea8e:	9a03      	ldr	r2, [sp, #12]
 800ea90:	fb01 3002 	mla	r0, r1, r2, r3
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 800ea94:	9a00      	ldr	r2, [sp, #0]
 800ea96:	2a00      	cmp	r2, #0
 800ea98:	bfdc      	itt	le
 800ea9a:	4252      	negle	r2, r2
 800ea9c:	434a      	mulle	r2, r1
 800ea9e:	e9dd 6100 	ldrd	r6, r1, [sp]
 800eaa2:	bfc8      	it	gt
 800eaa4:	2200      	movgt	r2, #0
 800eaa6:	fb01 2406 	mla	r4, r1, r6, r2
    for (i = N; i > 0 && i--;) {
 800eaaa:	f1bb 0f00 	cmp.w	fp, #0
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 800eaae:	940c      	str	r4, [sp, #48]	; 0x30
    for (i = N; i > 0 && i--;) {
 800eab0:	f77f af77 	ble.w	800e9a2 <cblas_dsymv+0x11e>
 800eab4:	9d04      	ldr	r5, [sp, #16]
 800eab6:	9f03      	ldr	r7, [sp, #12]
 800eab8:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 800eabc:	9d04      	ldr	r5, [sp, #16]
 800eabe:	9002      	str	r0, [sp, #8]
 800eac0:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 800eac4:	460c      	mov	r4, r1
 800eac6:	9507      	str	r5, [sp, #28]
 800eac8:	fb01 f10a 	mul.w	r1, r1, sl
 800eacc:	9d08      	ldr	r5, [sp, #32]
 800eace:	9805      	ldr	r0, [sp, #20]
 800ead0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ead2:	eb04 0e01 	add.w	lr, r4, r1
 800ead6:	eb05 0bce 	add.w	fp, r5, lr, lsl #3
 800eada:	ebc7 7447 	rsb	r4, r7, r7, lsl #29
 800eade:	eb05 05c1 	add.w	r5, r5, r1, lsl #3
 800eae2:	ebc6 7646 	rsb	r6, r6, r6, lsl #29
 800eae6:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 800eaea:	9504      	str	r5, [sp, #16]
 800eaec:	00e5      	lsls	r5, r4, #3
 800eaee:	ea6f 070a 	mvn.w	r7, sl
 800eaf2:	9206      	str	r2, [sp, #24]
 800eaf4:	9509      	str	r5, [sp, #36]	; 0x24
 800eaf6:	9a03      	ldr	r2, [sp, #12]
 800eaf8:	9c01      	ldr	r4, [sp, #4]
 800eafa:	940d      	str	r4, [sp, #52]	; 0x34
 800eafc:	00f5      	lsls	r5, r6, #3
 800eafe:	9e00      	ldr	r6, [sp, #0]
 800eb00:	950a      	str	r5, [sp, #40]	; 0x28
 800eb02:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 800eb06:	00fd      	lsls	r5, r7, #3
 800eb08:	ebca 7c4a 	rsb	ip, sl, sl, lsl #29
 800eb0c:	00d2      	lsls	r2, r2, #3
 800eb0e:	9508      	str	r5, [sp, #32]
 800eb10:	9303      	str	r3, [sp, #12]
 800eb12:	ea4f 05cc 	mov.w	r5, ip, lsl #3
 800eb16:	00f3      	lsls	r3, r6, #3
 800eb18:	950b      	str	r5, [sp, #44]	; 0x2c
 800eb1a:	4698      	mov	r8, r3
 800eb1c:	4691      	mov	r9, r2
      BASE temp1 = alpha * X[ix];
 800eb1e:	9b02      	ldr	r3, [sp, #8]
 800eb20:	ec51 0b19 	vmov	r0, r1, d9
 800eb24:	e9d3 2300 	ldrd	r2, r3, [r3]
 800eb28:	f01a f81e 	bl	8028b68 <__aeabi_dmul>
      Y[iy] += temp1 * A[lda * i + i];
 800eb2c:	e9db 2300 	ldrd	r2, r3, [fp]
      BASE temp1 = alpha * X[ix];
 800eb30:	4604      	mov	r4, r0
 800eb32:	460d      	mov	r5, r1
      Y[iy] += temp1 * A[lda * i + i];
 800eb34:	f01a f818 	bl	8028b68 <__aeabi_dmul>
 800eb38:	9e03      	ldr	r6, [sp, #12]
 800eb3a:	e9d6 2300 	ldrd	r2, r3, [r6]
 800eb3e:	f019 fe5d 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 800eb42:	9b01      	ldr	r3, [sp, #4]
      BASE temp1 = alpha * X[ix];
 800eb44:	ec45 4b18 	vmov	d8, r4, r5
      Y[iy] += temp1 * A[lda * i + i];
 800eb48:	4604      	mov	r4, r0
 800eb4a:	460d      	mov	r5, r1
 800eb4c:	e9c6 4500 	strd	r4, r5, [r6]
      for (j = j_min; j < j_max; j++) {
 800eb50:	2b00      	cmp	r3, #0
 800eb52:	f000 8101 	beq.w	800ed58 <cblas_dsymv+0x4d4>
 800eb56:	f8dd a01c 	ldr.w	sl, [sp, #28]
 800eb5a:	9f04      	ldr	r7, [sp, #16]
 800eb5c:	9e06      	ldr	r6, [sp, #24]
      BASE temp2 = 0.0;
 800eb5e:	2400      	movs	r4, #0
 800eb60:	2500      	movs	r5, #0
        Y[jy] += temp1 * A[lda * i + j];
 800eb62:	e9d7 0100 	ldrd	r0, r1, [r7]
 800eb66:	ec53 2b18 	vmov	r2, r3, d8
 800eb6a:	f019 fffd 	bl	8028b68 <__aeabi_dmul>
 800eb6e:	4602      	mov	r2, r0
 800eb70:	460b      	mov	r3, r1
 800eb72:	e9d6 0100 	ldrd	r0, r1, [r6]
 800eb76:	f019 fe41 	bl	80287fc <__adddf3>
 800eb7a:	e9c6 0100 	strd	r0, r1, [r6]
        temp2 += X[jx] * A[lda * i + j];
 800eb7e:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 800eb82:	e9da 0100 	ldrd	r0, r1, [sl]
 800eb86:	f019 ffef 	bl	8028b68 <__aeabi_dmul>
 800eb8a:	4602      	mov	r2, r0
 800eb8c:	460b      	mov	r3, r1
 800eb8e:	4620      	mov	r0, r4
 800eb90:	4629      	mov	r1, r5
 800eb92:	f019 fe33 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 800eb96:	455f      	cmp	r7, fp
 800eb98:	4446      	add	r6, r8
        temp2 += X[jx] * A[lda * i + j];
 800eb9a:	4604      	mov	r4, r0
 800eb9c:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 800eb9e:	44ca      	add	sl, r9
 800eba0:	d1df      	bne.n	800eb62 <cblas_dsymv+0x2de>
      Y[iy] += alpha * temp2;
 800eba2:	4602      	mov	r2, r0
 800eba4:	460b      	mov	r3, r1
 800eba6:	ec51 0b19 	vmov	r0, r1, d9
 800ebaa:	f019 ffdd 	bl	8028b68 <__aeabi_dmul>
 800ebae:	9c03      	ldr	r4, [sp, #12]
 800ebb0:	4602      	mov	r2, r0
 800ebb2:	460b      	mov	r3, r1
 800ebb4:	e9d4 0100 	ldrd	r0, r1, [r4]
 800ebb8:	f019 fe20 	bl	80287fc <__adddf3>
 800ebbc:	9b02      	ldr	r3, [sp, #8]
 800ebbe:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ebc0:	4413      	add	r3, r2
 800ebc2:	9302      	str	r3, [sp, #8]
 800ebc4:	9b08      	ldr	r3, [sp, #32]
 800ebc6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ebc8:	449b      	add	fp, r3
 800ebca:	9b04      	ldr	r3, [sp, #16]
 800ebcc:	4413      	add	r3, r2
 800ebce:	9304      	str	r3, [sp, #16]
 800ebd0:	9b01      	ldr	r3, [sp, #4]
 800ebd2:	3b01      	subs	r3, #1
 800ebd4:	9301      	str	r3, [sp, #4]
 800ebd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ebd8:	18e3      	adds	r3, r4, r3
 800ebda:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 800ebde:	9303      	str	r3, [sp, #12]
 800ebe0:	e79d      	b.n	800eb1e <cblas_dsymv+0x29a>
    INDEX iy = OFFSET(N, incY);
 800ebe2:	f1cb 0401 	rsb	r4, fp, #1
 800ebe6:	fb04 f403 	mul.w	r4, r4, r3
 800ebea:	e6f3      	b.n	800e9d4 <cblas_dsymv+0x150>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800ebec:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 800ebf0:	d009      	beq.n	800ec06 <cblas_dsymv+0x382>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800ebf2:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 800ebf6:	f47f aeb7 	bne.w	800e968 <cblas_dsymv+0xe4>
 800ebfa:	e73f      	b.n	800ea7c <cblas_dsymv+0x1f8>
    INDEX iy = OFFSET(N, incY);
 800ebfc:	f1cb 0301 	rsb	r3, fp, #1
 800ec00:	fb03 f302 	mul.w	r3, r3, r2
 800ec04:	e690      	b.n	800e928 <cblas_dsymv+0xa4>
    INDEX ix = OFFSET(N, incX);
 800ec06:	9b03      	ldr	r3, [sp, #12]
    INDEX iy = OFFSET(N, incY);
 800ec08:	9900      	ldr	r1, [sp, #0]
    INDEX ix = OFFSET(N, incX);
 800ec0a:	2b00      	cmp	r3, #0
 800ec0c:	bfda      	itte	le
 800ec0e:	f1cb 0201 	rsble	r2, fp, #1
 800ec12:	435a      	mulle	r2, r3
 800ec14:	2200      	movgt	r2, #0
    INDEX iy = OFFSET(N, incY);
 800ec16:	2900      	cmp	r1, #0
 800ec18:	bfda      	itte	le
 800ec1a:	f1cb 0301 	rsble	r3, fp, #1
 800ec1e:	434b      	mulle	r3, r1
 800ec20:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 800ec22:	f1bb 0f00 	cmp.w	fp, #0
    INDEX iy = OFFSET(N, incY);
 800ec26:	930d      	str	r3, [sp, #52]	; 0x34
    for (i = 0; i < N; i++) {
 800ec28:	f77f aebb 	ble.w	800e9a2 <cblas_dsymv+0x11e>
 800ec2c:	9903      	ldr	r1, [sp, #12]
 800ec2e:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 800ec32:	f10a 0301 	add.w	r3, sl, #1
 800ec36:	00d8      	lsls	r0, r3, #3
 800ec38:	440a      	add	r2, r1
 800ec3a:	ebc1 7341 	rsb	r3, r1, r1, lsl #29
 800ec3e:	00db      	lsls	r3, r3, #3
 800ec40:	9206      	str	r2, [sp, #24]
 800ec42:	f1a0 0208 	sub.w	r2, r0, #8
 800ec46:	920b      	str	r2, [sp, #44]	; 0x2c
 800ec48:	9309      	str	r3, [sp, #36]	; 0x24
 800ec4a:	9a00      	ldr	r2, [sp, #0]
 800ec4c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ec4e:	900c      	str	r0, [sp, #48]	; 0x30
 800ec50:	1898      	adds	r0, r3, r2
 800ec52:	9007      	str	r0, [sp, #28]
 800ec54:	00d0      	lsls	r0, r2, #3
 800ec56:	9a05      	ldr	r2, [sp, #20]
 800ec58:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800ec5c:	9301      	str	r3, [sp, #4]
 800ec5e:	9b08      	ldr	r3, [sp, #32]
 800ec60:	461a      	mov	r2, r3
 800ec62:	3208      	adds	r2, #8
 800ec64:	9202      	str	r2, [sp, #8]
 800ec66:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 800ec6a:	00ca      	lsls	r2, r1, #3
 800ec6c:	2600      	movs	r6, #0
 800ec6e:	4698      	mov	r8, r3
 800ec70:	4681      	mov	r9, r0
 800ec72:	4692      	mov	sl, r2
      BASE temp1 = alpha * X[ix];
 800ec74:	9f06      	ldr	r7, [sp, #24]
 800ec76:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ec78:	9a04      	ldr	r2, [sp, #16]
 800ec7a:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 800ec7e:	4413      	add	r3, r2
 800ec80:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ec84:	ec51 0b19 	vmov	r0, r1, d9
 800ec88:	f019 ff6e 	bl	8028b68 <__aeabi_dmul>
      Y[iy] += temp1 * A[lda * i + i];
 800ec8c:	9b02      	ldr	r3, [sp, #8]
 800ec8e:	e953 2302 	ldrd	r2, r3, [r3, #-8]
      BASE temp1 = alpha * X[ix];
 800ec92:	4604      	mov	r4, r0
 800ec94:	460d      	mov	r5, r1
      Y[iy] += temp1 * A[lda * i + i];
 800ec96:	f019 ff67 	bl	8028b68 <__aeabi_dmul>
 800ec9a:	9b01      	ldr	r3, [sp, #4]
 800ec9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800eca0:	f019 fdac 	bl	80287fc <__adddf3>
      BASE temp1 = alpha * X[ix];
 800eca4:	ec45 4b18 	vmov	d8, r4, r5
      Y[iy] += temp1 * A[lda * i + i];
 800eca8:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 800ecaa:	990a      	ldr	r1, [sp, #40]	; 0x28
      Y[iy] += temp1 * A[lda * i + i];
 800ecac:	9b01      	ldr	r3, [sp, #4]
      const INDEX j_min = i + 1;
 800ecae:	1c72      	adds	r2, r6, #1
      Y[iy] += temp1 * A[lda * i + i];
 800ecb0:	4604      	mov	r4, r0
      for (j = j_min; j < j_max; j++) {
 800ecb2:	4291      	cmp	r1, r2
      Y[iy] += temp1 * A[lda * i + i];
 800ecb4:	e9c3 4500 	strd	r4, r5, [r3]
      const INDEX j_min = i + 1;
 800ecb8:	9208      	str	r2, [sp, #32]
      for (j = j_min; j < j_max; j++) {
 800ecba:	ea4f 0bc7 	mov.w	fp, r7, lsl #3
 800ecbe:	f43f ae5d 	beq.w	800e97c <cblas_dsymv+0xf8>
 800ecc2:	9a04      	ldr	r2, [sp, #16]
 800ecc4:	9907      	ldr	r1, [sp, #28]
 800ecc6:	9e02      	ldr	r6, [sp, #8]
 800ecc8:	4493      	add	fp, r2
 800ecca:	9a05      	ldr	r2, [sp, #20]
      BASE temp2 = 0.0;
 800eccc:	2400      	movs	r4, #0
 800ecce:	2500      	movs	r5, #0
 800ecd0:	eb02 07c1 	add.w	r7, r2, r1, lsl #3
        Y[jy] += temp1 * A[lda * i + j];
 800ecd4:	e9d6 0100 	ldrd	r0, r1, [r6]
 800ecd8:	ec53 2b18 	vmov	r2, r3, d8
 800ecdc:	f019 ff44 	bl	8028b68 <__aeabi_dmul>
 800ece0:	4602      	mov	r2, r0
 800ece2:	460b      	mov	r3, r1
 800ece4:	e9d7 0100 	ldrd	r0, r1, [r7]
 800ece8:	f019 fd88 	bl	80287fc <__adddf3>
 800ecec:	e9c7 0100 	strd	r0, r1, [r7]
        temp2 += X[jx] * A[lda * i + j];
 800ecf0:	e8f6 2302 	ldrd	r2, r3, [r6], #8
 800ecf4:	e9db 0100 	ldrd	r0, r1, [fp]
 800ecf8:	f019 ff36 	bl	8028b68 <__aeabi_dmul>
 800ecfc:	4602      	mov	r2, r0
 800ecfe:	460b      	mov	r3, r1
 800ed00:	4620      	mov	r0, r4
 800ed02:	4629      	mov	r1, r5
 800ed04:	f019 fd7a 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 800ed08:	45b0      	cmp	r8, r6
 800ed0a:	444f      	add	r7, r9
        temp2 += X[jx] * A[lda * i + j];
 800ed0c:	4604      	mov	r4, r0
 800ed0e:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 800ed10:	44d3      	add	fp, sl
 800ed12:	d1df      	bne.n	800ecd4 <cblas_dsymv+0x450>
      Y[iy] += alpha * temp2;
 800ed14:	4602      	mov	r2, r0
 800ed16:	460b      	mov	r3, r1
 800ed18:	ec51 0b19 	vmov	r0, r1, d9
 800ed1c:	f019 ff24 	bl	8028b68 <__aeabi_dmul>
 800ed20:	9c01      	ldr	r4, [sp, #4]
 800ed22:	4602      	mov	r2, r0
 800ed24:	460b      	mov	r3, r1
 800ed26:	e9d4 0100 	ldrd	r0, r1, [r4]
 800ed2a:	f019 fd67 	bl	80287fc <__adddf3>
 800ed2e:	9b06      	ldr	r3, [sp, #24]
 800ed30:	9a03      	ldr	r2, [sp, #12]
 800ed32:	9e08      	ldr	r6, [sp, #32]
 800ed34:	4413      	add	r3, r2
 800ed36:	9306      	str	r3, [sp, #24]
 800ed38:	9a00      	ldr	r2, [sp, #0]
 800ed3a:	9b07      	ldr	r3, [sp, #28]
 800ed3c:	4413      	add	r3, r2
 800ed3e:	9307      	str	r3, [sp, #28]
 800ed40:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800ed42:	9b02      	ldr	r3, [sp, #8]
 800ed44:	4413      	add	r3, r2
 800ed46:	9302      	str	r3, [sp, #8]
 800ed48:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800ed4a:	4498      	add	r8, r3
 800ed4c:	eb04 0309 	add.w	r3, r4, r9
 800ed50:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 800ed54:	9301      	str	r3, [sp, #4]
 800ed56:	e78d      	b.n	800ec74 <cblas_dsymv+0x3f0>
      Y[iy] += alpha * temp2;
 800ed58:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ed5a:	9a00      	ldr	r2, [sp, #0]
 800ed5c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ed5e:	fb02 1613 	mls	r6, r2, r3, r1
 800ed62:	e60f      	b.n	800e984 <cblas_dsymv+0x100>
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 800ed64:	200b      	movs	r0, #11
 800ed66:	e5be      	b.n	800e8e6 <cblas_dsymv+0x62>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800ed68:	9b03      	ldr	r3, [sp, #12]
 800ed6a:	f10b 32ff 	add.w	r2, fp, #4294967295
 800ed6e:	425b      	negs	r3, r3
 800ed70:	9201      	str	r2, [sp, #4]
 800ed72:	fb02 f303 	mul.w	r3, r2, r3
 800ed76:	e689      	b.n	800ea8c <cblas_dsymv+0x208>

0800ed78 <cblas_dsyr>:

void
cblas_dsyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const double alpha, const double *X, const int incX,
            double *A, const int lda)
{
 800ed78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ed7c:	ed2d 8b02 	vpush	{d8}
 800ed80:	eeb0 8a40 	vmov.f32	s16, s0
 800ed84:	eef0 8a60 	vmov.f32	s17, s1
 800ed88:	b08b      	sub	sp, #44	; 0x2c
 800ed8a:	460c      	mov	r4, r1
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 800ed8c:	3979      	subs	r1, #121	; 0x79
 800ed8e:	9e18      	ldr	r6, [sp, #96]	; 0x60
 800ed90:	9303      	str	r3, [sp, #12]
 800ed92:	4605      	mov	r5, r0
 800ed94:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800ed96:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800ed98:	9201      	str	r2, [sp, #4]
 800ed9a:	2901      	cmp	r1, #1
 800ed9c:	9302      	str	r3, [sp, #8]
 800ed9e:	9005      	str	r0, [sp, #20]
 800eda0:	9600      	str	r6, [sp, #0]
 800eda2:	f240 8089 	bls.w	800eeb8 <cblas_dsyr+0x140>
 800eda6:	2a00      	cmp	r2, #0
 800eda8:	db0c      	blt.n	800edc4 <cblas_dsyr+0x4c>
 800edaa:	2b00      	cmp	r3, #0
 800edac:	f040 809a 	bne.w	800eee4 <cblas_dsyr+0x16c>
 800edb0:	9801      	ldr	r0, [sp, #4]
 800edb2:	9b00      	ldr	r3, [sp, #0]
 800edb4:	2801      	cmp	r0, #1
 800edb6:	bfb8      	it	lt
 800edb8:	2001      	movlt	r0, #1
 800edba:	4283      	cmp	r3, r0
 800edbc:	bfb4      	ite	lt
 800edbe:	2008      	movlt	r0, #8
 800edc0:	2006      	movge	r0, #6
 800edc2:	e007      	b.n	800edd4 <cblas_dsyr+0x5c>
 800edc4:	9b02      	ldr	r3, [sp, #8]
 800edc6:	2b00      	cmp	r3, #0
 800edc8:	d0f2      	beq.n	800edb0 <cblas_dsyr+0x38>
 800edca:	9b00      	ldr	r3, [sp, #0]
 800edcc:	2b00      	cmp	r3, #0
 800edce:	bfd4      	ite	le
 800edd0:	2008      	movle	r0, #8
 800edd2:	2003      	movgt	r0, #3
 800edd4:	4a7a      	ldr	r2, [pc, #488]	; (800efc0 <cblas_dsyr+0x248>)
 800edd6:	497b      	ldr	r1, [pc, #492]	; (800efc4 <cblas_dsyr+0x24c>)
 800edd8:	f019 fc96 	bl	8028708 <cblas_xerbla>
  if (N == 0)
 800eddc:	9b01      	ldr	r3, [sp, #4]
 800edde:	2b00      	cmp	r3, #0
 800ede0:	d065      	beq.n	800eeae <cblas_dsyr+0x136>
  if (alpha == 0.0)
 800ede2:	ec51 0b18 	vmov	r0, r1, d8
 800ede6:	2200      	movs	r2, #0
 800ede8:	2300      	movs	r3, #0
 800edea:	f01a f925 	bl	8029038 <__aeabi_dcmpeq>
 800edee:	2800      	cmp	r0, #0
 800edf0:	d15d      	bne.n	800eeae <cblas_dsyr+0x136>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800edf2:	2d65      	cmp	r5, #101	; 0x65
 800edf4:	f000 80d4 	beq.w	800efa0 <cblas_dsyr+0x228>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800edf8:	2d66      	cmp	r5, #102	; 0x66
 800edfa:	d07b      	beq.n	800eef4 <cblas_dsyr+0x17c>
    BLAS_ERROR("unrecognized operation");
 800edfc:	4a72      	ldr	r2, [pc, #456]	; (800efc8 <cblas_dsyr+0x250>)
 800edfe:	4971      	ldr	r1, [pc, #452]	; (800efc4 <cblas_dsyr+0x24c>)
 800ee00:	2000      	movs	r0, #0
#define BASE double
#include "source_syr.h"
#undef BASE
}
 800ee02:	b00b      	add	sp, #44	; 0x2c
 800ee04:	ecbd 8b02 	vpop	{d8}
 800ee08:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ee0c:	f019 bc7c 	b.w	8028708 <cblas_xerbla>
    INDEX ix = OFFSET(N, incX);
 800ee10:	9a02      	ldr	r2, [sp, #8]
 800ee12:	2a00      	cmp	r2, #0
 800ee14:	f340 80cd 	ble.w	800efb2 <cblas_dsyr+0x23a>
 800ee18:	2300      	movs	r3, #0
 800ee1a:	9304      	str	r3, [sp, #16]
    for (i = 0; i < N; i++) {
 800ee1c:	9b01      	ldr	r3, [sp, #4]
 800ee1e:	2b00      	cmp	r3, #0
 800ee20:	dd45      	ble.n	800eeae <cblas_dsyr+0x136>
 800ee22:	9b00      	ldr	r3, [sp, #0]
 800ee24:	9a03      	ldr	r2, [sp, #12]
 800ee26:	3301      	adds	r3, #1
 800ee28:	00db      	lsls	r3, r3, #3
 800ee2a:	9308      	str	r3, [sp, #32]
 800ee2c:	9b05      	ldr	r3, [sp, #20]
 800ee2e:	9306      	str	r3, [sp, #24]
 800ee30:	9b02      	ldr	r3, [sp, #8]
 800ee32:	00df      	lsls	r7, r3, #3
 800ee34:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800ee38:	9307      	str	r3, [sp, #28]
 800ee3a:	9700      	str	r7, [sp, #0]
 800ee3c:	2300      	movs	r3, #0
 800ee3e:	9f01      	ldr	r7, [sp, #4]
 800ee40:	9305      	str	r3, [sp, #20]
      const BASE tmp = alpha * X[ix];
 800ee42:	9c04      	ldr	r4, [sp, #16]
 800ee44:	9b03      	ldr	r3, [sp, #12]
 800ee46:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800ee4a:	e9d3 8900 	ldrd	r8, r9, [r3]
 800ee4e:	ec53 2b18 	vmov	r2, r3, d8
 800ee52:	4640      	mov	r0, r8
 800ee54:	4649      	mov	r1, r9
 800ee56:	f019 fe87 	bl	8028b68 <__aeabi_dmul>
 800ee5a:	9b07      	ldr	r3, [sp, #28]
 800ee5c:	00e4      	lsls	r4, r4, #3
 800ee5e:	e9dd 5605 	ldrd	r5, r6, [sp, #20]
 800ee62:	4682      	mov	sl, r0
 800ee64:	468b      	mov	fp, r1
      for (j = i; j < N; j++) {
 800ee66:	441c      	add	r4, r3
 800ee68:	e003      	b.n	800ee72 <cblas_dsyr+0xfa>
 800ee6a:	9b00      	ldr	r3, [sp, #0]
 800ee6c:	e9d4 8900 	ldrd	r8, r9, [r4]
 800ee70:	441c      	add	r4, r3
        A[lda * i + j] += X[jx] * tmp;
 800ee72:	4642      	mov	r2, r8
 800ee74:	464b      	mov	r3, r9
 800ee76:	e9d6 8900 	ldrd	r8, r9, [r6]
 800ee7a:	4650      	mov	r0, sl
 800ee7c:	4659      	mov	r1, fp
 800ee7e:	f019 fe73 	bl	8028b68 <__aeabi_dmul>
 800ee82:	4642      	mov	r2, r8
 800ee84:	464b      	mov	r3, r9
 800ee86:	f019 fcb9 	bl	80287fc <__adddf3>
      for (j = i; j < N; j++) {
 800ee8a:	3501      	adds	r5, #1
 800ee8c:	42af      	cmp	r7, r5
        A[lda * i + j] += X[jx] * tmp;
 800ee8e:	e8e6 0102 	strd	r0, r1, [r6], #8
      for (j = i; j < N; j++) {
 800ee92:	dcea      	bgt.n	800ee6a <cblas_dsyr+0xf2>
      ix += incX;
 800ee94:	9a04      	ldr	r2, [sp, #16]
 800ee96:	9902      	ldr	r1, [sp, #8]
    for (i = 0; i < N; i++) {
 800ee98:	9b05      	ldr	r3, [sp, #20]
      ix += incX;
 800ee9a:	440a      	add	r2, r1
 800ee9c:	9204      	str	r2, [sp, #16]
    for (i = 0; i < N; i++) {
 800ee9e:	9908      	ldr	r1, [sp, #32]
 800eea0:	9a06      	ldr	r2, [sp, #24]
 800eea2:	3301      	adds	r3, #1
 800eea4:	440a      	add	r2, r1
 800eea6:	429f      	cmp	r7, r3
 800eea8:	9305      	str	r3, [sp, #20]
 800eeaa:	9206      	str	r2, [sp, #24]
 800eeac:	d1c9      	bne.n	800ee42 <cblas_dsyr+0xca>
 800eeae:	b00b      	add	sp, #44	; 0x2c
 800eeb0:	ecbd 8b02 	vpop	{d8}
 800eeb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 800eeb8:	9b01      	ldr	r3, [sp, #4]
 800eeba:	2b00      	cmp	r3, #0
 800eebc:	db82      	blt.n	800edc4 <cblas_dsyr+0x4c>
 800eebe:	9b02      	ldr	r3, [sp, #8]
 800eec0:	2b00      	cmp	r3, #0
 800eec2:	f43f af75 	beq.w	800edb0 <cblas_dsyr+0x38>
 800eec6:	9b01      	ldr	r3, [sp, #4]
 800eec8:	9a00      	ldr	r2, [sp, #0]
 800eeca:	2b01      	cmp	r3, #1
 800eecc:	bfb8      	it	lt
 800eece:	2301      	movlt	r3, #1
 800eed0:	4293      	cmp	r3, r2
 800eed2:	dc6c      	bgt.n	800efae <cblas_dsyr+0x236>
 800eed4:	f1a5 0365 	sub.w	r3, r5, #101	; 0x65
 800eed8:	2b01      	cmp	r3, #1
 800eeda:	bf88      	it	hi
 800eedc:	2001      	movhi	r0, #1
 800eede:	f67f af7d 	bls.w	800eddc <cblas_dsyr+0x64>
 800eee2:	e777      	b.n	800edd4 <cblas_dsyr+0x5c>
 800eee4:	2a01      	cmp	r2, #1
 800eee6:	bfb8      	it	lt
 800eee8:	2201      	movlt	r2, #1
 800eeea:	4296      	cmp	r6, r2
 800eeec:	bfb4      	ite	lt
 800eeee:	2008      	movlt	r0, #8
 800eef0:	2002      	movge	r0, #2
 800eef2:	e76f      	b.n	800edd4 <cblas_dsyr+0x5c>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800eef4:	2c7a      	cmp	r4, #122	; 0x7a
 800eef6:	d08b      	beq.n	800ee10 <cblas_dsyr+0x98>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800eef8:	2c79      	cmp	r4, #121	; 0x79
 800eefa:	f47f af7f 	bne.w	800edfc <cblas_dsyr+0x84>
    INDEX ix = OFFSET(N, incX);
 800eefe:	9a02      	ldr	r2, [sp, #8]
 800ef00:	2a00      	cmp	r2, #0
 800ef02:	bfdd      	ittte	le
 800ef04:	9b01      	ldrle	r3, [sp, #4]
 800ef06:	f1c3 0301 	rsble	r3, r3, #1
 800ef0a:	4353      	mulle	r3, r2
 800ef0c:	2300      	movgt	r3, #0
 800ef0e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 800ef10:	9b01      	ldr	r3, [sp, #4]
 800ef12:	2b00      	cmp	r3, #0
 800ef14:	ddcb      	ble.n	800eeae <cblas_dsyr+0x136>
 800ef16:	9b00      	ldr	r3, [sp, #0]
 800ef18:	9903      	ldr	r1, [sp, #12]
 800ef1a:	3301      	adds	r3, #1
 800ef1c:	00db      	lsls	r3, r3, #3
 800ef1e:	9309      	str	r3, [sp, #36]	; 0x24
 800ef20:	9b05      	ldr	r3, [sp, #20]
 800ef22:	2200      	movs	r2, #0
 800ef24:	9204      	str	r2, [sp, #16]
 800ef26:	9207      	str	r2, [sp, #28]
 800ef28:	f103 0a08 	add.w	sl, r3, #8
 800ef2c:	9a06      	ldr	r2, [sp, #24]
 800ef2e:	9b02      	ldr	r3, [sp, #8]
 800ef30:	ea4f 0bc3 	mov.w	fp, r3, lsl #3
 800ef34:	00d3      	lsls	r3, r2, #3
 800ef36:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 800ef3a:	9208      	str	r2, [sp, #32]
      const BASE tmp = alpha * X[ix];
 800ef3c:	9a03      	ldr	r2, [sp, #12]
 800ef3e:	4413      	add	r3, r2
 800ef40:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ef44:	ec51 0b18 	vmov	r0, r1, d8
 800ef48:	f019 fe0e 	bl	8028b68 <__aeabi_dmul>
 800ef4c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800ef50:	9d08      	ldr	r5, [sp, #32]
 800ef52:	4680      	mov	r8, r0
 800ef54:	4689      	mov	r9, r1
      for (j = 0; j <= i; j++) {
 800ef56:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[lda * i + j] += X[jx] * tmp;
 800ef5a:	e9d4 6700 	ldrd	r6, r7, [r4]
 800ef5e:	e9d5 2300 	ldrd	r2, r3, [r5]
 800ef62:	4640      	mov	r0, r8
 800ef64:	4649      	mov	r1, r9
 800ef66:	f019 fdff 	bl	8028b68 <__aeabi_dmul>
 800ef6a:	4632      	mov	r2, r6
 800ef6c:	463b      	mov	r3, r7
 800ef6e:	f019 fc45 	bl	80287fc <__adddf3>
 800ef72:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j <= i; j++) {
 800ef76:	45a2      	cmp	sl, r4
 800ef78:	445d      	add	r5, fp
 800ef7a:	d1ee      	bne.n	800ef5a <cblas_dsyr+0x1e2>
      ix += incX;
 800ef7c:	9a06      	ldr	r2, [sp, #24]
 800ef7e:	9902      	ldr	r1, [sp, #8]
 800ef80:	9800      	ldr	r0, [sp, #0]
    for (i = 0; i < N; i++) {
 800ef82:	9b07      	ldr	r3, [sp, #28]
      ix += incX;
 800ef84:	440a      	add	r2, r1
 800ef86:	9904      	ldr	r1, [sp, #16]
 800ef88:	9206      	str	r2, [sp, #24]
    for (i = 0; i < N; i++) {
 800ef8a:	4401      	add	r1, r0
 800ef8c:	9104      	str	r1, [sp, #16]
 800ef8e:	9909      	ldr	r1, [sp, #36]	; 0x24
 800ef90:	448a      	add	sl, r1
 800ef92:	9901      	ldr	r1, [sp, #4]
 800ef94:	3301      	adds	r3, #1
 800ef96:	4299      	cmp	r1, r3
 800ef98:	9307      	str	r3, [sp, #28]
 800ef9a:	d088      	beq.n	800eeae <cblas_dsyr+0x136>
 800ef9c:	00d3      	lsls	r3, r2, #3
 800ef9e:	e7cd      	b.n	800ef3c <cblas_dsyr+0x1c4>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800efa0:	2c79      	cmp	r4, #121	; 0x79
 800efa2:	f43f af35 	beq.w	800ee10 <cblas_dsyr+0x98>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800efa6:	2c7a      	cmp	r4, #122	; 0x7a
 800efa8:	f47f af28 	bne.w	800edfc <cblas_dsyr+0x84>
 800efac:	e7a7      	b.n	800eefe <cblas_dsyr+0x186>
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 800efae:	2008      	movs	r0, #8
 800efb0:	e710      	b.n	800edd4 <cblas_dsyr+0x5c>
    INDEX ix = OFFSET(N, incX);
 800efb2:	9b01      	ldr	r3, [sp, #4]
 800efb4:	f1c3 0301 	rsb	r3, r3, #1
 800efb8:	fb03 f302 	mul.w	r3, r3, r2
 800efbc:	9304      	str	r3, [sp, #16]
 800efbe:	e72d      	b.n	800ee1c <cblas_dsyr+0xa4>
 800efc0:	08031108 	.word	0x08031108
 800efc4:	0803123c 	.word	0x0803123c
 800efc8:	080311b8 	.word	0x080311b8

0800efcc <cblas_dsyr2>:

void
cblas_dsyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const double alpha, const double *X, const int incX,
             const double *Y, const int incY, double *A, const int lda)
{
 800efcc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800efd0:	ed2d 8b06 	vpush	{d8-d10}
 800efd4:	eeb0 aa40 	vmov.f32	s20, s0
 800efd8:	eef0 aa60 	vmov.f32	s21, s1
 800efdc:	b08f      	sub	sp, #60	; 0x3c
 800efde:	460c      	mov	r4, r1
 800efe0:	9307      	str	r3, [sp, #28]
 800efe2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800efe4:	9303      	str	r3, [sp, #12]
 800efe6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800efe8:	9308      	str	r3, [sp, #32]
 800efea:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800efec:	9304      	str	r3, [sp, #16]
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800efee:	3979      	subs	r1, #121	; 0x79
 800eff0:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800eff2:	9309      	str	r3, [sp, #36]	; 0x24
 800eff4:	2901      	cmp	r1, #1
 800eff6:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800eff8:	9200      	str	r2, [sp, #0]
 800effa:	4605      	mov	r5, r0
 800effc:	9301      	str	r3, [sp, #4]
 800effe:	f240 80f6 	bls.w	800f1ee <cblas_dsyr2+0x222>
 800f002:	2002      	movs	r0, #2
 800f004:	9b00      	ldr	r3, [sp, #0]
 800f006:	2b00      	cmp	r3, #0
 800f008:	9b03      	ldr	r3, [sp, #12]
 800f00a:	f2c0 80e3 	blt.w	800f1d4 <cblas_dsyr2+0x208>
 800f00e:	2b00      	cmp	r3, #0
 800f010:	f040 80c6 	bne.w	800f1a0 <cblas_dsyr2+0x1d4>
 800f014:	9b04      	ldr	r3, [sp, #16]
 800f016:	2b00      	cmp	r3, #0
 800f018:	f040 80d2 	bne.w	800f1c0 <cblas_dsyr2+0x1f4>
 800f01c:	9800      	ldr	r0, [sp, #0]
 800f01e:	9b01      	ldr	r3, [sp, #4]
 800f020:	2801      	cmp	r0, #1
 800f022:	bfb8      	it	lt
 800f024:	2001      	movlt	r0, #1
 800f026:	4283      	cmp	r3, r0
 800f028:	bfb4      	ite	lt
 800f02a:	200a      	movlt	r0, #10
 800f02c:	2008      	movge	r0, #8
 800f02e:	4a73      	ldr	r2, [pc, #460]	; (800f1fc <cblas_dsyr2+0x230>)
 800f030:	4973      	ldr	r1, [pc, #460]	; (800f200 <cblas_dsyr2+0x234>)
 800f032:	f019 fb69 	bl	8028708 <cblas_xerbla>
  if (N == 0)
 800f036:	9b00      	ldr	r3, [sp, #0]
 800f038:	2b00      	cmp	r3, #0
 800f03a:	f000 80ac 	beq.w	800f196 <cblas_dsyr2+0x1ca>
  if (alpha == 0.0)
 800f03e:	ec51 0b1a 	vmov	r0, r1, d10
 800f042:	2200      	movs	r2, #0
 800f044:	2300      	movs	r3, #0
 800f046:	f019 fff7 	bl	8029038 <__aeabi_dcmpeq>
 800f04a:	2800      	cmp	r0, #0
 800f04c:	f040 80a3 	bne.w	800f196 <cblas_dsyr2+0x1ca>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800f050:	2d65      	cmp	r5, #101	; 0x65
 800f052:	f000 8165 	beq.w	800f320 <cblas_dsyr2+0x354>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800f056:	2d66      	cmp	r5, #102	; 0x66
 800f058:	f000 80d6 	beq.w	800f208 <cblas_dsyr2+0x23c>
    BLAS_ERROR("unrecognized operation");
 800f05c:	4a69      	ldr	r2, [pc, #420]	; (800f204 <cblas_dsyr2+0x238>)
 800f05e:	4968      	ldr	r1, [pc, #416]	; (800f200 <cblas_dsyr2+0x234>)
 800f060:	2000      	movs	r0, #0
#define BASE double
#include "source_syr2.h"
#undef BASE
}
 800f062:	b00f      	add	sp, #60	; 0x3c
 800f064:	ecbd 8b06 	vpop	{d8-d10}
 800f068:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f06c:	f019 bb4c 	b.w	8028708 <cblas_xerbla>
    INDEX ix = OFFSET(N, incX);
 800f070:	9a03      	ldr	r2, [sp, #12]
 800f072:	2a00      	cmp	r2, #0
 800f074:	bfde      	ittt	le
 800f076:	9b00      	ldrle	r3, [sp, #0]
 800f078:	f1c3 0301 	rsble	r3, r3, #1
 800f07c:	4353      	mulle	r3, r2
    INDEX iy = OFFSET(N, incY);
 800f07e:	9a04      	ldr	r2, [sp, #16]
    INDEX ix = OFFSET(N, incX);
 800f080:	bfc8      	it	gt
 800f082:	2300      	movgt	r3, #0
    INDEX iy = OFFSET(N, incY);
 800f084:	2a00      	cmp	r2, #0
    INDEX ix = OFFSET(N, incX);
 800f086:	9305      	str	r3, [sp, #20]
    INDEX iy = OFFSET(N, incY);
 800f088:	f340 8153 	ble.w	800f332 <cblas_dsyr2+0x366>
 800f08c:	2300      	movs	r3, #0
 800f08e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 800f090:	9b00      	ldr	r3, [sp, #0]
 800f092:	2b00      	cmp	r3, #0
 800f094:	dd7f      	ble.n	800f196 <cblas_dsyr2+0x1ca>
 800f096:	9b01      	ldr	r3, [sp, #4]
 800f098:	3301      	adds	r3, #1
 800f09a:	00db      	lsls	r3, r3, #3
 800f09c:	930d      	str	r3, [sp, #52]	; 0x34
 800f09e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f0a0:	930a      	str	r3, [sp, #40]	; 0x28
 800f0a2:	9b04      	ldr	r3, [sp, #16]
 800f0a4:	00da      	lsls	r2, r3, #3
 800f0a6:	9202      	str	r2, [sp, #8]
 800f0a8:	9a08      	ldr	r2, [sp, #32]
 800f0aa:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800f0ae:	930c      	str	r3, [sp, #48]	; 0x30
 800f0b0:	9b03      	ldr	r3, [sp, #12]
 800f0b2:	00da      	lsls	r2, r3, #3
 800f0b4:	9201      	str	r2, [sp, #4]
 800f0b6:	9a07      	ldr	r2, [sp, #28]
 800f0b8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800f0bc:	930b      	str	r3, [sp, #44]	; 0x2c
 800f0be:	2300      	movs	r3, #0
 800f0c0:	9309      	str	r3, [sp, #36]	; 0x24
      const BASE tmp1 = alpha * X[ix];
 800f0c2:	9b07      	ldr	r3, [sp, #28]
 800f0c4:	461a      	mov	r2, r3
 800f0c6:	9b05      	ldr	r3, [sp, #20]
 800f0c8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800f0cc:	e9d3 ab00 	ldrd	sl, fp, [r3]
 800f0d0:	ec59 8b1a 	vmov	r8, r9, d10
 800f0d4:	ee1a 2a10 	vmov	r2, s20
 800f0d8:	464b      	mov	r3, r9
 800f0da:	4650      	mov	r0, sl
 800f0dc:	4659      	mov	r1, fp
 800f0de:	f019 fd43 	bl	8028b68 <__aeabi_dmul>
 800f0e2:	460f      	mov	r7, r1
      const BASE tmp2 = alpha * Y[iy];
 800f0e4:	9908      	ldr	r1, [sp, #32]
      const BASE tmp1 = alpha * X[ix];
 800f0e6:	4606      	mov	r6, r0
      const BASE tmp2 = alpha * Y[iy];
 800f0e8:	4608      	mov	r0, r1
 800f0ea:	9906      	ldr	r1, [sp, #24]
 800f0ec:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
 800f0f0:	e9d3 4500 	ldrd	r4, r5, [r3]
 800f0f4:	ee1a 2a10 	vmov	r2, s20
 800f0f8:	464b      	mov	r3, r9
 800f0fa:	4620      	mov	r0, r4
 800f0fc:	4629      	mov	r1, r5
 800f0fe:	f019 fd33 	bl	8028b68 <__aeabi_dmul>
 800f102:	9b05      	ldr	r3, [sp, #20]
      const BASE tmp1 = alpha * X[ix];
 800f104:	ec47 6b18 	vmov	d8, r6, r7
      const BASE tmp2 = alpha * Y[iy];
 800f108:	00df      	lsls	r7, r3, #3
 800f10a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f10c:	ec41 0b19 	vmov	d9, r0, r1
      for (j = i; j < N; j++) {
 800f110:	9906      	ldr	r1, [sp, #24]
 800f112:	441f      	add	r7, r3
 800f114:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f116:	00ce      	lsls	r6, r1, #3
      const BASE tmp2 = alpha * Y[iy];
 800f118:	e9dd 8909 	ldrd	r8, r9, [sp, #36]	; 0x24
 800f11c:	441e      	add	r6, r3
 800f11e:	e007      	b.n	800f130 <cblas_dsyr2+0x164>
 800f120:	9b02      	ldr	r3, [sp, #8]
 800f122:	e9d6 4500 	ldrd	r4, r5, [r6]
 800f126:	441e      	add	r6, r3
 800f128:	9b01      	ldr	r3, [sp, #4]
 800f12a:	e9d7 ab00 	ldrd	sl, fp, [r7]
 800f12e:	441f      	add	r7, r3
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800f130:	4622      	mov	r2, r4
 800f132:	462b      	mov	r3, r5
 800f134:	ec51 0b18 	vmov	r0, r1, d8
 800f138:	f019 fd16 	bl	8028b68 <__aeabi_dmul>
 800f13c:	4652      	mov	r2, sl
 800f13e:	4604      	mov	r4, r0
 800f140:	460d      	mov	r5, r1
 800f142:	465b      	mov	r3, fp
 800f144:	ec51 0b19 	vmov	r0, r1, d9
 800f148:	f019 fd0e 	bl	8028b68 <__aeabi_dmul>
 800f14c:	4602      	mov	r2, r0
 800f14e:	460b      	mov	r3, r1
 800f150:	4620      	mov	r0, r4
 800f152:	4629      	mov	r1, r5
 800f154:	e9d9 4500 	ldrd	r4, r5, [r9]
 800f158:	f019 fb50 	bl	80287fc <__adddf3>
 800f15c:	462b      	mov	r3, r5
 800f15e:	4622      	mov	r2, r4
 800f160:	f019 fb4c 	bl	80287fc <__adddf3>
      for (j = i; j < N; j++) {
 800f164:	9b00      	ldr	r3, [sp, #0]
 800f166:	f108 0801 	add.w	r8, r8, #1
 800f16a:	4543      	cmp	r3, r8
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800f16c:	e8e9 0102 	strd	r0, r1, [r9], #8
      for (j = i; j < N; j++) {
 800f170:	dcd6      	bgt.n	800f120 <cblas_dsyr2+0x154>
      ix += incX;
 800f172:	9a05      	ldr	r2, [sp, #20]
 800f174:	9903      	ldr	r1, [sp, #12]
    for (i = 0; i < N; i++) {
 800f176:	9b09      	ldr	r3, [sp, #36]	; 0x24
      ix += incX;
 800f178:	440a      	add	r2, r1
 800f17a:	9205      	str	r2, [sp, #20]
      iy += incY;
 800f17c:	9904      	ldr	r1, [sp, #16]
 800f17e:	9a06      	ldr	r2, [sp, #24]
 800f180:	440a      	add	r2, r1
 800f182:	9206      	str	r2, [sp, #24]
    for (i = 0; i < N; i++) {
 800f184:	990d      	ldr	r1, [sp, #52]	; 0x34
 800f186:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800f188:	440a      	add	r2, r1
 800f18a:	920a      	str	r2, [sp, #40]	; 0x28
 800f18c:	9a00      	ldr	r2, [sp, #0]
 800f18e:	3301      	adds	r3, #1
 800f190:	429a      	cmp	r2, r3
 800f192:	9309      	str	r3, [sp, #36]	; 0x24
 800f194:	d195      	bne.n	800f0c2 <cblas_dsyr2+0xf6>
 800f196:	b00f      	add	sp, #60	; 0x3c
 800f198:	ecbd 8b06 	vpop	{d8-d10}
 800f19c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800f1a0:	9b04      	ldr	r3, [sp, #16]
 800f1a2:	2b00      	cmp	r3, #0
 800f1a4:	f43f af3a 	beq.w	800f01c <cblas_dsyr2+0x50>
 800f1a8:	9b00      	ldr	r3, [sp, #0]
 800f1aa:	9a01      	ldr	r2, [sp, #4]
 800f1ac:	2b01      	cmp	r3, #1
 800f1ae:	bfb8      	it	lt
 800f1b0:	2301      	movlt	r3, #1
 800f1b2:	4293      	cmp	r3, r2
 800f1b4:	f300 80bb 	bgt.w	800f32e <cblas_dsyr2+0x362>
 800f1b8:	2800      	cmp	r0, #0
 800f1ba:	f43f af3c 	beq.w	800f036 <cblas_dsyr2+0x6a>
 800f1be:	e736      	b.n	800f02e <cblas_dsyr2+0x62>
 800f1c0:	9800      	ldr	r0, [sp, #0]
 800f1c2:	9b01      	ldr	r3, [sp, #4]
 800f1c4:	2801      	cmp	r0, #1
 800f1c6:	bfb8      	it	lt
 800f1c8:	2001      	movlt	r0, #1
 800f1ca:	4283      	cmp	r3, r0
 800f1cc:	bfb4      	ite	lt
 800f1ce:	200a      	movlt	r0, #10
 800f1d0:	2006      	movge	r0, #6
 800f1d2:	e72c      	b.n	800f02e <cblas_dsyr2+0x62>
 800f1d4:	2b00      	cmp	r3, #0
 800f1d6:	f43f af1d 	beq.w	800f014 <cblas_dsyr2+0x48>
 800f1da:	9b04      	ldr	r3, [sp, #16]
 800f1dc:	2b00      	cmp	r3, #0
 800f1de:	f43f af1d 	beq.w	800f01c <cblas_dsyr2+0x50>
 800f1e2:	9b01      	ldr	r3, [sp, #4]
 800f1e4:	2b00      	cmp	r3, #0
 800f1e6:	bfd4      	ite	le
 800f1e8:	200a      	movle	r0, #10
 800f1ea:	2003      	movgt	r0, #3
 800f1ec:	e71f      	b.n	800f02e <cblas_dsyr2+0x62>
 800f1ee:	3865      	subs	r0, #101	; 0x65
 800f1f0:	2801      	cmp	r0, #1
 800f1f2:	bf94      	ite	ls
 800f1f4:	2000      	movls	r0, #0
 800f1f6:	2001      	movhi	r0, #1
 800f1f8:	e704      	b.n	800f004 <cblas_dsyr2+0x38>
 800f1fa:	bf00      	nop
 800f1fc:	08031108 	.word	0x08031108
 800f200:	0803124c 	.word	0x0803124c
 800f204:	080311b8 	.word	0x080311b8
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800f208:	2c7a      	cmp	r4, #122	; 0x7a
 800f20a:	f43f af31 	beq.w	800f070 <cblas_dsyr2+0xa4>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800f20e:	2c79      	cmp	r4, #121	; 0x79
 800f210:	f47f af24 	bne.w	800f05c <cblas_dsyr2+0x90>
    INDEX ix = OFFSET(N, incX);
 800f214:	9a03      	ldr	r2, [sp, #12]
 800f216:	2a00      	cmp	r2, #0
 800f218:	bfde      	ittt	le
 800f21a:	9b00      	ldrle	r3, [sp, #0]
 800f21c:	f1c3 0301 	rsble	r3, r3, #1
 800f220:	4353      	mulle	r3, r2
    INDEX iy = OFFSET(N, incY);
 800f222:	9a04      	ldr	r2, [sp, #16]
    INDEX ix = OFFSET(N, incX);
 800f224:	bfc8      	it	gt
 800f226:	2300      	movgt	r3, #0
    INDEX iy = OFFSET(N, incY);
 800f228:	2a00      	cmp	r2, #0
    INDEX ix = OFFSET(N, incX);
 800f22a:	9305      	str	r3, [sp, #20]
    INDEX iy = OFFSET(N, incY);
 800f22c:	bfdd      	ittte	le
 800f22e:	9b00      	ldrle	r3, [sp, #0]
 800f230:	f1c3 0301 	rsble	r3, r3, #1
 800f234:	4353      	mulle	r3, r2
 800f236:	2300      	movgt	r3, #0
 800f238:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 800f23a:	9b00      	ldr	r3, [sp, #0]
 800f23c:	2b00      	cmp	r3, #0
 800f23e:	ddaa      	ble.n	800f196 <cblas_dsyr2+0x1ca>
 800f240:	9b01      	ldr	r3, [sp, #4]
 800f242:	9d07      	ldr	r5, [sp, #28]
 800f244:	3301      	adds	r3, #1
 800f246:	2200      	movs	r2, #0
 800f248:	00db      	lsls	r3, r3, #3
 800f24a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 800f24e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f250:	9202      	str	r2, [sp, #8]
 800f252:	f103 0908 	add.w	r9, r3, #8
 800f256:	9b04      	ldr	r3, [sp, #16]
 800f258:	9a08      	ldr	r2, [sp, #32]
 800f25a:	00d9      	lsls	r1, r3, #3
 800f25c:	9b06      	ldr	r3, [sp, #24]
 800f25e:	00dc      	lsls	r4, r3, #3
 800f260:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800f264:	930d      	str	r3, [sp, #52]	; 0x34
 800f266:	9a05      	ldr	r2, [sp, #20]
 800f268:	9b03      	ldr	r3, [sp, #12]
 800f26a:	00d8      	lsls	r0, r3, #3
 800f26c:	00d3      	lsls	r3, r2, #3
 800f26e:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 800f272:	920c      	str	r2, [sp, #48]	; 0x30
 800f274:	4683      	mov	fp, r0
 800f276:	468a      	mov	sl, r1
      const BASE tmp1 = alpha * X[ix];
 800f278:	9a07      	ldr	r2, [sp, #28]
 800f27a:	4413      	add	r3, r2
 800f27c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f280:	ec51 0b1a 	vmov	r0, r1, d10
 800f284:	f019 fc70 	bl	8028b68 <__aeabi_dmul>
      const BASE tmp2 = alpha * Y[iy];
 800f288:	9b08      	ldr	r3, [sp, #32]
 800f28a:	441c      	add	r4, r3
 800f28c:	e9d4 2300 	ldrd	r2, r3, [r4]
      const BASE tmp1 = alpha * X[ix];
 800f290:	4606      	mov	r6, r0
 800f292:	460f      	mov	r7, r1
      const BASE tmp2 = alpha * Y[iy];
 800f294:	ec51 0b1a 	vmov	r0, r1, d10
 800f298:	f019 fc66 	bl	8028b68 <__aeabi_dmul>
 800f29c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f29e:	9a02      	ldr	r2, [sp, #8]
 800f2a0:	e9dd 850c 	ldrd	r8, r5, [sp, #48]	; 0x30
      const BASE tmp1 = alpha * X[ix];
 800f2a4:	ec47 6b18 	vmov	d8, r6, r7
      const BASE tmp2 = alpha * Y[iy];
 800f2a8:	ec41 0b19 	vmov	d9, r0, r1
      for (j = 0; j <= i; j++) {
 800f2ac:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800f2b0:	e9d5 2300 	ldrd	r2, r3, [r5]
 800f2b4:	ec51 0b18 	vmov	r0, r1, d8
 800f2b8:	f019 fc56 	bl	8028b68 <__aeabi_dmul>
 800f2bc:	e9d8 2300 	ldrd	r2, r3, [r8]
 800f2c0:	4606      	mov	r6, r0
 800f2c2:	460f      	mov	r7, r1
 800f2c4:	ec51 0b19 	vmov	r0, r1, d9
 800f2c8:	f019 fc4e 	bl	8028b68 <__aeabi_dmul>
 800f2cc:	4602      	mov	r2, r0
 800f2ce:	460b      	mov	r3, r1
 800f2d0:	4630      	mov	r0, r6
 800f2d2:	4639      	mov	r1, r7
 800f2d4:	e9d4 6700 	ldrd	r6, r7, [r4]
 800f2d8:	f019 fa90 	bl	80287fc <__adddf3>
 800f2dc:	4632      	mov	r2, r6
 800f2de:	463b      	mov	r3, r7
 800f2e0:	f019 fa8c 	bl	80287fc <__adddf3>
 800f2e4:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j <= i; j++) {
 800f2e8:	45a1      	cmp	r9, r4
 800f2ea:	4455      	add	r5, sl
 800f2ec:	44d8      	add	r8, fp
 800f2ee:	d1df      	bne.n	800f2b0 <cblas_dsyr2+0x2e4>
      ix += incX;
 800f2f0:	9905      	ldr	r1, [sp, #20]
 800f2f2:	9a03      	ldr	r2, [sp, #12]
      iy += incY;
 800f2f4:	9804      	ldr	r0, [sp, #16]
    for (i = 0; i < N; i++) {
 800f2f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      ix += incX;
 800f2f8:	4411      	add	r1, r2
      iy += incY;
 800f2fa:	9a06      	ldr	r2, [sp, #24]
      ix += incX;
 800f2fc:	9105      	str	r1, [sp, #20]
      iy += incY;
 800f2fe:	4402      	add	r2, r0
 800f300:	e9dd 4001 	ldrd	r4, r0, [sp, #4]
 800f304:	4420      	add	r0, r4
 800f306:	9002      	str	r0, [sp, #8]
 800f308:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800f30a:	9206      	str	r2, [sp, #24]
    for (i = 0; i < N; i++) {
 800f30c:	4481      	add	r9, r0
 800f30e:	9800      	ldr	r0, [sp, #0]
 800f310:	3301      	adds	r3, #1
 800f312:	4298      	cmp	r0, r3
 800f314:	930a      	str	r3, [sp, #40]	; 0x28
 800f316:	f43f af3e 	beq.w	800f196 <cblas_dsyr2+0x1ca>
 800f31a:	00d4      	lsls	r4, r2, #3
 800f31c:	00cb      	lsls	r3, r1, #3
 800f31e:	e7ab      	b.n	800f278 <cblas_dsyr2+0x2ac>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800f320:	2c79      	cmp	r4, #121	; 0x79
 800f322:	f43f aea5 	beq.w	800f070 <cblas_dsyr2+0xa4>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800f326:	2c7a      	cmp	r4, #122	; 0x7a
 800f328:	f47f ae98 	bne.w	800f05c <cblas_dsyr2+0x90>
 800f32c:	e772      	b.n	800f214 <cblas_dsyr2+0x248>
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800f32e:	200a      	movs	r0, #10
 800f330:	e67d      	b.n	800f02e <cblas_dsyr2+0x62>
    INDEX iy = OFFSET(N, incY);
 800f332:	9b00      	ldr	r3, [sp, #0]
 800f334:	f1c3 0301 	rsb	r3, r3, #1
 800f338:	fb03 f302 	mul.w	r3, r3, r2
 800f33c:	9306      	str	r3, [sp, #24]
 800f33e:	e6a7      	b.n	800f090 <cblas_dsyr2+0xc4>

0800f340 <cblas_dsyr2k>:
cblas_dsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const double alpha, const double *A, const int lda,
              const double *B, const int ldb, const double beta, double *C,
              const int ldc)
{
 800f340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f344:	ed2d 8b06 	vpush	{d8-d10}
 800f348:	eeb0 aa40 	vmov.f32	s20, s0
 800f34c:	eef0 aa60 	vmov.f32	s21, s1
 800f350:	b095      	sub	sp, #84	; 0x54
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800f352:	2865      	cmp	r0, #101	; 0x65
 800f354:	9300      	str	r3, [sp, #0]
 800f356:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800f358:	9306      	str	r3, [sp, #24]
 800f35a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800f35c:	9309      	str	r3, [sp, #36]	; 0x24
 800f35e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800f360:	9302      	str	r3, [sp, #8]
 800f362:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800f364:	930a      	str	r3, [sp, #40]	; 0x28
 800f366:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800f368:	9307      	str	r3, [sp, #28]
 800f36a:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 800f36c:	9308      	str	r3, [sp, #32]
 800f36e:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 800f370:	930c      	str	r3, [sp, #48]	; 0x30
 800f372:	ec57 6b11 	vmov	r6, r7, d1
 800f376:	4605      	mov	r5, r0
 800f378:	4688      	mov	r8, r1
 800f37a:	4693      	mov	fp, r2
 800f37c:	f000 8133 	beq.w	800f5e6 <cblas_dsyr2k+0x2a6>
 800f380:	2a6f      	cmp	r2, #111	; 0x6f
 800f382:	f000 810a 	beq.w	800f59a <cblas_dsyr2k+0x25a>
 800f386:	9a06      	ldr	r2, [sp, #24]
 800f388:	f1a8 0379 	sub.w	r3, r8, #121	; 0x79
 800f38c:	2b01      	cmp	r3, #1
 800f38e:	f240 8123 	bls.w	800f5d8 <cblas_dsyr2k+0x298>
 800f392:	2002      	movs	r0, #2
 800f394:	f1ab 036f 	sub.w	r3, fp, #111	; 0x6f
 800f398:	b2db      	uxtb	r3, r3
 800f39a:	2b03      	cmp	r3, #3
 800f39c:	bf28      	it	cs
 800f39e:	2003      	movcs	r0, #3
 800f3a0:	9900      	ldr	r1, [sp, #0]
 800f3a2:	9b06      	ldr	r3, [sp, #24]
 800f3a4:	2900      	cmp	r1, #0
 800f3a6:	bfb8      	it	lt
 800f3a8:	2004      	movlt	r0, #4
 800f3aa:	2b00      	cmp	r3, #0
 800f3ac:	bfb8      	it	lt
 800f3ae:	2005      	movlt	r0, #5
 800f3b0:	4613      	mov	r3, r2
 800f3b2:	2a01      	cmp	r2, #1
 800f3b4:	9a02      	ldr	r2, [sp, #8]
 800f3b6:	bfb8      	it	lt
 800f3b8:	2301      	movlt	r3, #1
 800f3ba:	4293      	cmp	r3, r2
 800f3bc:	9a07      	ldr	r2, [sp, #28]
 800f3be:	f340 80fd 	ble.w	800f5bc <cblas_dsyr2k+0x27c>
 800f3c2:	4293      	cmp	r3, r2
 800f3c4:	f300 80f0 	bgt.w	800f5a8 <cblas_dsyr2k+0x268>
 800f3c8:	2901      	cmp	r1, #1
 800f3ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f3cc:	bfb8      	it	lt
 800f3ce:	2101      	movlt	r1, #1
 800f3d0:	428b      	cmp	r3, r1
 800f3d2:	bfb4      	ite	lt
 800f3d4:	200e      	movlt	r0, #14
 800f3d6:	2008      	movge	r0, #8
 800f3d8:	4ab2      	ldr	r2, [pc, #712]	; (800f6a4 <cblas_dsyr2k+0x364>)
 800f3da:	49b3      	ldr	r1, [pc, #716]	; (800f6a8 <cblas_dsyr2k+0x368>)
 800f3dc:	f019 f994 	bl	8028708 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800f3e0:	ec51 0b1a 	vmov	r0, r1, d10
 800f3e4:	2200      	movs	r2, #0
 800f3e6:	2300      	movs	r3, #0
 800f3e8:	f019 fe26 	bl	8029038 <__aeabi_dcmpeq>
 800f3ec:	b140      	cbz	r0, 800f400 <cblas_dsyr2k+0xc0>
 800f3ee:	4baf      	ldr	r3, [pc, #700]	; (800f6ac <cblas_dsyr2k+0x36c>)
 800f3f0:	2200      	movs	r2, #0
 800f3f2:	4630      	mov	r0, r6
 800f3f4:	4639      	mov	r1, r7
 800f3f6:	f019 fe1f 	bl	8029038 <__aeabi_dcmpeq>
 800f3fa:	2800      	cmp	r0, #0
 800f3fc:	f040 80c8 	bne.w	800f590 <cblas_dsyr2k+0x250>
  if (Order == CblasRowMajor) {
 800f400:	2d65      	cmp	r5, #101	; 0x65
 800f402:	f000 80f5 	beq.w	800f5f0 <cblas_dsyr2k+0x2b0>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f406:	f1ab 0370 	sub.w	r3, fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f40a:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f40e:	b2db      	uxtb	r3, r3
  if (beta == 0.0) {
 800f410:	f04f 0200 	mov.w	r2, #0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f414:	f000 8243 	beq.w	800f89e <cblas_dsyr2k+0x55e>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f418:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800f41a:	4630      	mov	r0, r6
 800f41c:	f04f 0300 	mov.w	r3, #0
 800f420:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f422:	f240 8251 	bls.w	800f8c8 <cblas_dsyr2k+0x588>
  if (beta == 0.0) {
 800f426:	f019 fe07 	bl	8029038 <__aeabi_dcmpeq>
 800f42a:	2800      	cmp	r0, #0
 800f42c:	f000 81f9 	beq.w	800f822 <cblas_dsyr2k+0x4e2>
      for (i = 0; i < N; i++) {
 800f430:	9b00      	ldr	r3, [sp, #0]
 800f432:	2b00      	cmp	r3, #0
      trans = CblasTrans;
 800f434:	bfc8      	it	gt
 800f436:	f04f 0b70 	movgt.w	fp, #112	; 0x70
      for (i = 0; i < N; i++) {
 800f43a:	f340 8226 	ble.w	800f88a <cblas_dsyr2k+0x54a>
 800f43e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f440:	9808      	ldr	r0, [sp, #32]
 800f442:	9d00      	ldr	r5, [sp, #0]
 800f444:	1c5c      	adds	r4, r3, #1
          C[ldc * i + j] = 0.0;
 800f446:	2600      	movs	r6, #0
 800f448:	2700      	movs	r7, #0
 800f44a:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800f44c:	2100      	movs	r1, #0
 800f44e:	4602      	mov	r2, r0
 800f450:	460b      	mov	r3, r1
        for (j = i; j < N; j++) {
 800f452:	3301      	adds	r3, #1
 800f454:	429d      	cmp	r5, r3
          C[ldc * i + j] = 0.0;
 800f456:	e8e2 6702 	strd	r6, r7, [r2], #8
        for (j = i; j < N; j++) {
 800f45a:	dcfa      	bgt.n	800f452 <cblas_dsyr2k+0x112>
      for (i = 0; i < N; i++) {
 800f45c:	3101      	adds	r1, #1
 800f45e:	428d      	cmp	r5, r1
 800f460:	4420      	add	r0, r4
 800f462:	dcf4      	bgt.n	800f44e <cblas_dsyr2k+0x10e>
  if (alpha == 0.0)
 800f464:	ec51 0b1a 	vmov	r0, r1, d10
 800f468:	2200      	movs	r2, #0
 800f46a:	2300      	movs	r3, #0
 800f46c:	f019 fde4 	bl	8029038 <__aeabi_dcmpeq>
 800f470:	2800      	cmp	r0, #0
 800f472:	f040 808d 	bne.w	800f590 <cblas_dsyr2k+0x250>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800f476:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 800f47a:	f000 823a 	beq.w	800f8f2 <cblas_dsyr2k+0x5b2>
  } else if (uplo == CblasUpper && trans == CblasTrans) {
 800f47e:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800f482:	f040 8104 	bne.w	800f68e <cblas_dsyr2k+0x34e>
    for (k = 0; k < K; k++) {
 800f486:	9b06      	ldr	r3, [sp, #24]
 800f488:	2b00      	cmp	r3, #0
 800f48a:	f340 8081 	ble.w	800f590 <cblas_dsyr2k+0x250>
 800f48e:	9902      	ldr	r1, [sp, #8]
 800f490:	1c4b      	adds	r3, r1, #1
 800f492:	00db      	lsls	r3, r3, #3
 800f494:	2200      	movs	r2, #0
 800f496:	930c      	str	r3, [sp, #48]	; 0x30
 800f498:	00cb      	lsls	r3, r1, #3
 800f49a:	e9cd 220e 	strd	r2, r2, [sp, #56]	; 0x38
 800f49e:	920d      	str	r2, [sp, #52]	; 0x34
 800f4a0:	9310      	str	r3, [sp, #64]	; 0x40
 800f4a2:	9a00      	ldr	r2, [sp, #0]
 800f4a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f4a6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f4aa:	930b      	str	r3, [sp, #44]	; 0x2c
      for (i = 0; i < N; i++) {
 800f4ac:	9b00      	ldr	r3, [sp, #0]
 800f4ae:	2b00      	cmp	r3, #0
 800f4b0:	dd5c      	ble.n	800f56c <cblas_dsyr2k+0x22c>
 800f4b2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800f4b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f4b6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f4ba:	9301      	str	r3, [sp, #4]
 800f4bc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f4be:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f4c0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f4c4:	9305      	str	r3, [sp, #20]
 800f4c6:	9b08      	ldr	r3, [sp, #32]
 800f4c8:	9304      	str	r3, [sp, #16]
 800f4ca:	2300      	movs	r3, #0
 800f4cc:	9303      	str	r3, [sp, #12]
        BASE temp1 = alpha * A[k * lda + i];
 800f4ce:	9b01      	ldr	r3, [sp, #4]
 800f4d0:	e8f3 8902 	ldrd	r8, r9, [r3], #8
 800f4d4:	9301      	str	r3, [sp, #4]
 800f4d6:	4640      	mov	r0, r8
 800f4d8:	ec53 2b1a 	vmov	r2, r3, d10
 800f4dc:	4649      	mov	r1, r9
 800f4de:	f019 fb43 	bl	8028b68 <__aeabi_dmul>
 800f4e2:	460d      	mov	r5, r1
        BASE temp2 = alpha * B[k * ldb + i];
 800f4e4:	9905      	ldr	r1, [sp, #20]
 800f4e6:	e8f1 6702 	ldrd	r6, r7, [r1], #8
        BASE temp1 = alpha * A[k * lda + i];
 800f4ea:	4604      	mov	r4, r0
        BASE temp2 = alpha * B[k * ldb + i];
 800f4ec:	9105      	str	r1, [sp, #20]
 800f4ee:	ec53 2b1a 	vmov	r2, r3, d10
 800f4f2:	4630      	mov	r0, r6
 800f4f4:	4639      	mov	r1, r7
 800f4f6:	f019 fb37 	bl	8028b68 <__aeabi_dmul>
        BASE temp1 = alpha * A[k * lda + i];
 800f4fa:	ec45 4b18 	vmov	d8, r4, r5
        BASE temp2 = alpha * B[k * ldb + i];
 800f4fe:	ec41 0b19 	vmov	d9, r0, r1
 800f502:	e9dd 5b04 	ldrd	r5, fp, [sp, #16]
 800f506:	f8dd a004 	ldr.w	sl, [sp, #4]
 800f50a:	9c03      	ldr	r4, [sp, #12]
 800f50c:	e003      	b.n	800f516 <cblas_dsyr2k+0x1d6>
 800f50e:	e8fb 6702 	ldrd	r6, r7, [fp], #8
 800f512:	e8fa 8902 	ldrd	r8, r9, [sl], #8
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800f516:	4632      	mov	r2, r6
 800f518:	463b      	mov	r3, r7
 800f51a:	ec51 0b18 	vmov	r0, r1, d8
 800f51e:	f019 fb23 	bl	8028b68 <__aeabi_dmul>
 800f522:	4642      	mov	r2, r8
 800f524:	4606      	mov	r6, r0
 800f526:	460f      	mov	r7, r1
 800f528:	464b      	mov	r3, r9
 800f52a:	ec51 0b19 	vmov	r0, r1, d9
 800f52e:	f019 fb1b 	bl	8028b68 <__aeabi_dmul>
 800f532:	4602      	mov	r2, r0
 800f534:	460b      	mov	r3, r1
 800f536:	4630      	mov	r0, r6
 800f538:	4639      	mov	r1, r7
 800f53a:	e9d5 6700 	ldrd	r6, r7, [r5]
 800f53e:	f019 f95d 	bl	80287fc <__adddf3>
 800f542:	463b      	mov	r3, r7
 800f544:	4632      	mov	r2, r6
 800f546:	f019 f959 	bl	80287fc <__adddf3>
        for (j = i; j < N; j++) {
 800f54a:	9b00      	ldr	r3, [sp, #0]
 800f54c:	3401      	adds	r4, #1
 800f54e:	42a3      	cmp	r3, r4
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800f550:	e8e5 0102 	strd	r0, r1, [r5], #8
        for (j = i; j < N; j++) {
 800f554:	dcdb      	bgt.n	800f50e <cblas_dsyr2k+0x1ce>
      for (i = 0; i < N; i++) {
 800f556:	9b03      	ldr	r3, [sp, #12]
 800f558:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800f55a:	3301      	adds	r3, #1
 800f55c:	9303      	str	r3, [sp, #12]
 800f55e:	9b04      	ldr	r3, [sp, #16]
 800f560:	4413      	add	r3, r2
 800f562:	9304      	str	r3, [sp, #16]
 800f564:	9a01      	ldr	r2, [sp, #4]
 800f566:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f568:	4293      	cmp	r3, r2
 800f56a:	d1b0      	bne.n	800f4ce <cblas_dsyr2k+0x18e>
    for (k = 0; k < K; k++) {
 800f56c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800f56e:	9910      	ldr	r1, [sp, #64]	; 0x40
 800f570:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800f572:	440a      	add	r2, r1
 800f574:	920b      	str	r2, [sp, #44]	; 0x2c
 800f576:	9902      	ldr	r1, [sp, #8]
 800f578:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800f57a:	440a      	add	r2, r1
 800f57c:	920e      	str	r2, [sp, #56]	; 0x38
 800f57e:	9907      	ldr	r1, [sp, #28]
 800f580:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f582:	440a      	add	r2, r1
 800f584:	920d      	str	r2, [sp, #52]	; 0x34
 800f586:	9a06      	ldr	r2, [sp, #24]
 800f588:	3301      	adds	r3, #1
 800f58a:	429a      	cmp	r2, r3
 800f58c:	930f      	str	r3, [sp, #60]	; 0x3c
 800f58e:	d18d      	bne.n	800f4ac <cblas_dsyr2k+0x16c>
#define BASE double
#include "source_syr2k_r.h"
#undef BASE
}
 800f590:	b015      	add	sp, #84	; 0x54
 800f592:	ecbd 8b06 	vpop	{d8-d10}
 800f596:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f59a:	9a00      	ldr	r2, [sp, #0]
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800f59c:	f1a8 0379 	sub.w	r3, r8, #121	; 0x79
 800f5a0:	2b01      	cmp	r3, #1
 800f5a2:	d919      	bls.n	800f5d8 <cblas_dsyr2k+0x298>
 800f5a4:	2002      	movs	r0, #2
 800f5a6:	e6fb      	b.n	800f3a0 <cblas_dsyr2k+0x60>
 800f5a8:	9800      	ldr	r0, [sp, #0]
 800f5aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f5ac:	2801      	cmp	r0, #1
 800f5ae:	bfb8      	it	lt
 800f5b0:	2001      	movlt	r0, #1
 800f5b2:	4283      	cmp	r3, r0
 800f5b4:	bfb4      	ite	lt
 800f5b6:	200e      	movlt	r0, #14
 800f5b8:	200b      	movge	r0, #11
 800f5ba:	e70d      	b.n	800f3d8 <cblas_dsyr2k+0x98>
 800f5bc:	4293      	cmp	r3, r2
 800f5be:	dcf3      	bgt.n	800f5a8 <cblas_dsyr2k+0x268>
 800f5c0:	9b00      	ldr	r3, [sp, #0]
 800f5c2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800f5c4:	2b01      	cmp	r3, #1
 800f5c6:	bfb8      	it	lt
 800f5c8:	2301      	movlt	r3, #1
 800f5ca:	4293      	cmp	r3, r2
 800f5cc:	f300 815b 	bgt.w	800f886 <cblas_dsyr2k+0x546>
 800f5d0:	2800      	cmp	r0, #0
 800f5d2:	f43f af05 	beq.w	800f3e0 <cblas_dsyr2k+0xa0>
 800f5d6:	e6ff      	b.n	800f3d8 <cblas_dsyr2k+0x98>
 800f5d8:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 800f5dc:	2801      	cmp	r0, #1
 800f5de:	bf94      	ite	ls
 800f5e0:	2000      	movls	r0, #0
 800f5e2:	2001      	movhi	r0, #1
 800f5e4:	e6d6      	b.n	800f394 <cblas_dsyr2k+0x54>
 800f5e6:	2a6f      	cmp	r2, #111	; 0x6f
 800f5e8:	f000 8216 	beq.w	800fa18 <cblas_dsyr2k+0x6d8>
 800f5ec:	9a00      	ldr	r2, [sp, #0]
 800f5ee:	e6cb      	b.n	800f388 <cblas_dsyr2k+0x48>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 800f5f0:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
  if (beta == 0.0) {
 800f5f4:	f04f 0200 	mov.w	r2, #0
 800f5f8:	f04f 0300 	mov.w	r3, #0
 800f5fc:	4630      	mov	r0, r6
 800f5fe:	4639      	mov	r1, r7
 800f600:	bf08      	it	eq
 800f602:	f04f 0b70 	moveq.w	fp, #112	; 0x70
 800f606:	f019 fd17 	bl	8029038 <__aeabi_dcmpeq>
    uplo = Uplo;
 800f60a:	f8cd 8004 	str.w	r8, [sp, #4]
  if (beta == 0.0) {
 800f60e:	2800      	cmp	r0, #0
 800f610:	d150      	bne.n	800f6b4 <cblas_dsyr2k+0x374>
  } else if (beta != 1.0) {
 800f612:	4b26      	ldr	r3, [pc, #152]	; (800f6ac <cblas_dsyr2k+0x36c>)
 800f614:	2200      	movs	r2, #0
 800f616:	4630      	mov	r0, r6
 800f618:	4639      	mov	r1, r7
 800f61a:	f019 fd0d 	bl	8029038 <__aeabi_dcmpeq>
 800f61e:	2800      	cmp	r0, #0
 800f620:	d167      	bne.n	800f6f2 <cblas_dsyr2k+0x3b2>
    if (uplo == CblasUpper) {
 800f622:	9b01      	ldr	r3, [sp, #4]
 800f624:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800f626:	9b00      	ldr	r3, [sp, #0]
    if (uplo == CblasUpper) {
 800f628:	f000 82d9 	beq.w	800fbde <cblas_dsyr2k+0x89e>
      for (i = 0; i < N; i++) {
 800f62c:	2b00      	cmp	r3, #0
 800f62e:	dd23      	ble.n	800f678 <cblas_dsyr2k+0x338>
 800f630:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f632:	f8cd b00c 	str.w	fp, [sp, #12]
 800f636:	f103 0a01 	add.w	sl, r3, #1
 800f63a:	9b08      	ldr	r3, [sp, #32]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f63c:	f04f 0800 	mov.w	r8, #0
 800f640:	ea4f 0aca 	mov.w	sl, sl, lsl #3
      for (i = 0; i < N; i++) {
 800f644:	46c1      	mov	r9, r8
 800f646:	f103 0508 	add.w	r5, r3, #8
 800f64a:	469b      	mov	fp, r3
 800f64c:	eb0b 04c8 	add.w	r4, fp, r8, lsl #3
          C[ldc * i + j] *= beta;
 800f650:	e9d4 0100 	ldrd	r0, r1, [r4]
 800f654:	4632      	mov	r2, r6
 800f656:	463b      	mov	r3, r7
 800f658:	f019 fa86 	bl	8028b68 <__aeabi_dmul>
 800f65c:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j <= i; j++) {
 800f660:	42ac      	cmp	r4, r5
 800f662:	d1f5      	bne.n	800f650 <cblas_dsyr2k+0x310>
      for (i = 0; i < N; i++) {
 800f664:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f666:	4498      	add	r8, r3
 800f668:	9b00      	ldr	r3, [sp, #0]
 800f66a:	f109 0901 	add.w	r9, r9, #1
 800f66e:	454b      	cmp	r3, r9
 800f670:	4455      	add	r5, sl
 800f672:	dceb      	bgt.n	800f64c <cblas_dsyr2k+0x30c>
 800f674:	f8dd b00c 	ldr.w	fp, [sp, #12]
  if (alpha == 0.0)
 800f678:	ec51 0b1a 	vmov	r0, r1, d10
 800f67c:	2200      	movs	r2, #0
 800f67e:	2300      	movs	r3, #0
 800f680:	f019 fcda 	bl	8029038 <__aeabi_dcmpeq>
 800f684:	2800      	cmp	r0, #0
 800f686:	d183      	bne.n	800f590 <cblas_dsyr2k+0x250>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800f688:	9b01      	ldr	r3, [sp, #4]
 800f68a:	2b7a      	cmp	r3, #122	; 0x7a
 800f68c:	d041      	beq.n	800f712 <cblas_dsyr2k+0x3d2>
    BLAS_ERROR("unrecognized operation");
 800f68e:	4a08      	ldr	r2, [pc, #32]	; (800f6b0 <cblas_dsyr2k+0x370>)
 800f690:	4905      	ldr	r1, [pc, #20]	; (800f6a8 <cblas_dsyr2k+0x368>)
 800f692:	2000      	movs	r0, #0
 800f694:	b015      	add	sp, #84	; 0x54
 800f696:	ecbd 8b06 	vpop	{d8-d10}
 800f69a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f69e:	f019 b833 	b.w	8028708 <cblas_xerbla>
 800f6a2:	bf00      	nop
 800f6a4:	08031108 	.word	0x08031108
 800f6a8:	0803125c 	.word	0x0803125c
 800f6ac:	3ff00000 	.word	0x3ff00000
 800f6b0:	080311b8 	.word	0x080311b8
    if (uplo == CblasUpper) {
 800f6b4:	9b01      	ldr	r3, [sp, #4]
 800f6b6:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800f6b8:	9b00      	ldr	r3, [sp, #0]
    if (uplo == CblasUpper) {
 800f6ba:	f000 828c 	beq.w	800fbd6 <cblas_dsyr2k+0x896>
      for (i = 0; i < N; i++) {
 800f6be:	2b00      	cmp	r3, #0
 800f6c0:	ddda      	ble.n	800f678 <cblas_dsyr2k+0x338>
 800f6c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f6c4:	9a08      	ldr	r2, [sp, #32]
 800f6c6:	9d00      	ldr	r5, [sp, #0]
 800f6c8:	f8dd c020 	ldr.w	ip, [sp, #32]
 800f6cc:	1c5c      	adds	r4, r3, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f6ce:	2100      	movs	r1, #0
          C[ldc * i + j] = 0.0;
 800f6d0:	2600      	movs	r6, #0
 800f6d2:	2700      	movs	r7, #0
 800f6d4:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800f6d6:	4608      	mov	r0, r1
 800f6d8:	3208      	adds	r2, #8
 800f6da:	469e      	mov	lr, r3
 800f6dc:	eb0c 03c1 	add.w	r3, ip, r1, lsl #3
          C[ldc * i + j] = 0.0;
 800f6e0:	e8e3 6702 	strd	r6, r7, [r3], #8
        for (j = 0; j <= i; j++) {
 800f6e4:	429a      	cmp	r2, r3
 800f6e6:	d1fb      	bne.n	800f6e0 <cblas_dsyr2k+0x3a0>
      for (i = 0; i < N; i++) {
 800f6e8:	3001      	adds	r0, #1
 800f6ea:	4285      	cmp	r5, r0
 800f6ec:	4471      	add	r1, lr
 800f6ee:	4422      	add	r2, r4
 800f6f0:	dcf4      	bgt.n	800f6dc <cblas_dsyr2k+0x39c>
  if (alpha == 0.0)
 800f6f2:	ec51 0b1a 	vmov	r0, r1, d10
 800f6f6:	2200      	movs	r2, #0
 800f6f8:	2300      	movs	r3, #0
 800f6fa:	f019 fc9d 	bl	8029038 <__aeabi_dcmpeq>
 800f6fe:	2800      	cmp	r0, #0
 800f700:	f47f af46 	bne.w	800f590 <cblas_dsyr2k+0x250>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800f704:	9b01      	ldr	r3, [sp, #4]
 800f706:	2b79      	cmp	r3, #121	; 0x79
 800f708:	f43f aeb5 	beq.w	800f476 <cblas_dsyr2k+0x136>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800f70c:	9b01      	ldr	r3, [sp, #4]
 800f70e:	2b7a      	cmp	r3, #122	; 0x7a
 800f710:	d1bd      	bne.n	800f68e <cblas_dsyr2k+0x34e>
 800f712:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 800f716:	f000 81d2 	beq.w	800fabe <cblas_dsyr2k+0x77e>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 800f71a:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800f71e:	d1b6      	bne.n	800f68e <cblas_dsyr2k+0x34e>
    for (k = 0; k < K; k++) {
 800f720:	9b06      	ldr	r3, [sp, #24]
 800f722:	2b00      	cmp	r3, #0
 800f724:	f77f af34 	ble.w	800f590 <cblas_dsyr2k+0x250>
 800f728:	9907      	ldr	r1, [sp, #28]
 800f72a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f72c:	9a02      	ldr	r2, [sp, #8]
 800f72e:	9305      	str	r3, [sp, #20]
 800f730:	00c9      	lsls	r1, r1, #3
 800f732:	910c      	str	r1, [sp, #48]	; 0x30
 800f734:	990a      	ldr	r1, [sp, #40]	; 0x28
 800f736:	9107      	str	r1, [sp, #28]
 800f738:	9900      	ldr	r1, [sp, #0]
 800f73a:	00d2      	lsls	r2, r2, #3
 800f73c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800f740:	9309      	str	r3, [sp, #36]	; 0x24
 800f742:	f102 0308 	add.w	r3, r2, #8
 800f746:	930a      	str	r3, [sp, #40]	; 0x28
 800f748:	2300      	movs	r3, #0
 800f74a:	920d      	str	r2, [sp, #52]	; 0x34
 800f74c:	930b      	str	r3, [sp, #44]	; 0x2c
      for (i = 0; i < N; i++) {
 800f74e:	9b00      	ldr	r3, [sp, #0]
 800f750:	2b00      	cmp	r3, #0
 800f752:	dd53      	ble.n	800f7fc <cblas_dsyr2k+0x4bc>
 800f754:	9b08      	ldr	r3, [sp, #32]
 800f756:	f103 0b08 	add.w	fp, r3, #8
 800f75a:	9b07      	ldr	r3, [sp, #28]
 800f75c:	9304      	str	r3, [sp, #16]
 800f75e:	9b05      	ldr	r3, [sp, #20]
 800f760:	9301      	str	r3, [sp, #4]
 800f762:	2300      	movs	r3, #0
 800f764:	9303      	str	r3, [sp, #12]
        BASE temp1 = alpha * A[k * lda + i];
 800f766:	9c01      	ldr	r4, [sp, #4]
 800f768:	ec57 6b1a 	vmov	r6, r7, d10
 800f76c:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800f770:	ee1a 2a10 	vmov	r2, s20
 800f774:	463b      	mov	r3, r7
 800f776:	9401      	str	r4, [sp, #4]
 800f778:	f019 f9f6 	bl	8028b68 <__aeabi_dmul>
        BASE temp2 = alpha * B[k * ldb + i];
 800f77c:	9e04      	ldr	r6, [sp, #16]
        BASE temp1 = alpha * A[k * lda + i];
 800f77e:	4604      	mov	r4, r0
 800f780:	460d      	mov	r5, r1
        BASE temp2 = alpha * B[k * ldb + i];
 800f782:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800f786:	ee1a 2a10 	vmov	r2, s20
 800f78a:	463b      	mov	r3, r7
 800f78c:	9604      	str	r6, [sp, #16]
 800f78e:	f019 f9eb 	bl	8028b68 <__aeabi_dmul>
 800f792:	9b08      	ldr	r3, [sp, #32]
 800f794:	9a03      	ldr	r2, [sp, #12]
 800f796:	f8dd a014 	ldr.w	sl, [sp, #20]
        BASE temp1 = alpha * A[k * lda + i];
 800f79a:	ec45 4b18 	vmov	d8, r4, r5
        BASE temp2 = alpha * B[k * ldb + i];
 800f79e:	ec41 0b19 	vmov	d9, r0, r1
 800f7a2:	9d07      	ldr	r5, [sp, #28]
 800f7a4:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800f7a8:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800f7ac:	ec53 2b18 	vmov	r2, r3, d8
 800f7b0:	f019 f9da 	bl	8028b68 <__aeabi_dmul>
 800f7b4:	e8fa 6702 	ldrd	r6, r7, [sl], #8
 800f7b8:	ec53 2b19 	vmov	r2, r3, d9
 800f7bc:	4680      	mov	r8, r0
 800f7be:	4689      	mov	r9, r1
 800f7c0:	4630      	mov	r0, r6
 800f7c2:	4639      	mov	r1, r7
 800f7c4:	f019 f9d0 	bl	8028b68 <__aeabi_dmul>
 800f7c8:	e9d4 6700 	ldrd	r6, r7, [r4]
 800f7cc:	4602      	mov	r2, r0
 800f7ce:	460b      	mov	r3, r1
 800f7d0:	4640      	mov	r0, r8
 800f7d2:	4649      	mov	r1, r9
 800f7d4:	f019 f812 	bl	80287fc <__adddf3>
 800f7d8:	4632      	mov	r2, r6
 800f7da:	463b      	mov	r3, r7
 800f7dc:	f019 f80e 	bl	80287fc <__adddf3>
 800f7e0:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j <= i; j++) {
 800f7e4:	455c      	cmp	r4, fp
 800f7e6:	d1df      	bne.n	800f7a8 <cblas_dsyr2k+0x468>
      for (i = 0; i < N; i++) {
 800f7e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800f7ec:	4413      	add	r3, r2
 800f7ee:	9303      	str	r3, [sp, #12]
 800f7f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f7f2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800f7f4:	449b      	add	fp, r3
 800f7f6:	9b01      	ldr	r3, [sp, #4]
 800f7f8:	4293      	cmp	r3, r2
 800f7fa:	d1b4      	bne.n	800f766 <cblas_dsyr2k+0x426>
    for (k = 0; k < K; k++) {
 800f7fc:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f7fe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800f800:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f802:	4608      	mov	r0, r1
 800f804:	4410      	add	r0, r2
 800f806:	9907      	ldr	r1, [sp, #28]
 800f808:	9009      	str	r0, [sp, #36]	; 0x24
 800f80a:	980c      	ldr	r0, [sp, #48]	; 0x30
 800f80c:	4401      	add	r1, r0
 800f80e:	9107      	str	r1, [sp, #28]
 800f810:	9905      	ldr	r1, [sp, #20]
 800f812:	4411      	add	r1, r2
 800f814:	9a06      	ldr	r2, [sp, #24]
 800f816:	9105      	str	r1, [sp, #20]
 800f818:	3301      	adds	r3, #1
 800f81a:	429a      	cmp	r2, r3
 800f81c:	930b      	str	r3, [sp, #44]	; 0x2c
 800f81e:	d196      	bne.n	800f74e <cblas_dsyr2k+0x40e>
 800f820:	e6b6      	b.n	800f590 <cblas_dsyr2k+0x250>
  } else if (beta != 1.0) {
 800f822:	4ba1      	ldr	r3, [pc, #644]	; (800faa8 <cblas_dsyr2k+0x768>)
 800f824:	2200      	movs	r2, #0
 800f826:	4630      	mov	r0, r6
 800f828:	4639      	mov	r1, r7
 800f82a:	f019 fc05 	bl	8029038 <__aeabi_dcmpeq>
 800f82e:	bb60      	cbnz	r0, 800f88a <cblas_dsyr2k+0x54a>
      for (i = 0; i < N; i++) {
 800f830:	9b00      	ldr	r3, [sp, #0]
 800f832:	2b00      	cmp	r3, #0
      trans = CblasTrans;
 800f834:	bfc8      	it	gt
 800f836:	f04f 0b70 	movgt.w	fp, #112	; 0x70
      for (i = 0; i < N; i++) {
 800f83a:	dd26      	ble.n	800f88a <cblas_dsyr2k+0x54a>
 800f83c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f83e:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800f842:	f8cd b004 	str.w	fp, [sp, #4]
 800f846:	f103 0a01 	add.w	sl, r3, #1
 800f84a:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 800f84e:	f04f 0800 	mov.w	r8, #0
 800f852:	46d3      	mov	fp, sl
 800f854:	46ca      	mov	sl, r9
 800f856:	46c1      	mov	r9, r8
 800f858:	f8dd 8000 	ldr.w	r8, [sp]
 800f85c:	4655      	mov	r5, sl
 800f85e:	464c      	mov	r4, r9
          C[ldc * i + j] *= beta;
 800f860:	e9d5 0100 	ldrd	r0, r1, [r5]
 800f864:	4632      	mov	r2, r6
 800f866:	463b      	mov	r3, r7
 800f868:	f019 f97e 	bl	8028b68 <__aeabi_dmul>
        for (j = i; j < N; j++) {
 800f86c:	3401      	adds	r4, #1
 800f86e:	45a0      	cmp	r8, r4
          C[ldc * i + j] *= beta;
 800f870:	e8e5 0102 	strd	r0, r1, [r5], #8
        for (j = i; j < N; j++) {
 800f874:	dcf4      	bgt.n	800f860 <cblas_dsyr2k+0x520>
      for (i = 0; i < N; i++) {
 800f876:	f109 0901 	add.w	r9, r9, #1
 800f87a:	45c8      	cmp	r8, r9
 800f87c:	44da      	add	sl, fp
 800f87e:	dced      	bgt.n	800f85c <cblas_dsyr2k+0x51c>
 800f880:	f8dd b004 	ldr.w	fp, [sp, #4]
 800f884:	e5ee      	b.n	800f464 <cblas_dsyr2k+0x124>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800f886:	200e      	movs	r0, #14
 800f888:	e5a6      	b.n	800f3d8 <cblas_dsyr2k+0x98>
  if (alpha == 0.0)
 800f88a:	ec51 0b1a 	vmov	r0, r1, d10
 800f88e:	2200      	movs	r2, #0
 800f890:	2300      	movs	r3, #0
 800f892:	f019 fbd1 	bl	8029038 <__aeabi_dcmpeq>
 800f896:	2800      	cmp	r0, #0
 800f898:	f43f adf5 	beq.w	800f486 <cblas_dsyr2k+0x146>
 800f89c:	e678      	b.n	800f590 <cblas_dsyr2k+0x250>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f89e:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800f8a0:	4630      	mov	r0, r6
 800f8a2:	f04f 0300 	mov.w	r3, #0
 800f8a6:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f8a8:	f240 80c9 	bls.w	800fa3e <cblas_dsyr2k+0x6fe>
  if (beta == 0.0) {
 800f8ac:	f019 fbc4 	bl	8029038 <__aeabi_dcmpeq>
 800f8b0:	2800      	cmp	r0, #0
 800f8b2:	f000 80d6 	beq.w	800fa62 <cblas_dsyr2k+0x722>
      for (i = 0; i < N; i++) {
 800f8b6:	9b00      	ldr	r3, [sp, #0]
 800f8b8:	2b00      	cmp	r3, #0
 800f8ba:	f340 80ea 	ble.w	800fa92 <cblas_dsyr2k+0x752>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f8be:	237a      	movs	r3, #122	; 0x7a
      trans = CblasTrans;
 800f8c0:	f04f 0b70 	mov.w	fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f8c4:	9301      	str	r3, [sp, #4]
 800f8c6:	e6fc      	b.n	800f6c2 <cblas_dsyr2k+0x382>
  if (beta == 0.0) {
 800f8c8:	f019 fbb6 	bl	8029038 <__aeabi_dcmpeq>
 800f8cc:	2800      	cmp	r0, #0
 800f8ce:	f000 80a5 	beq.w	800fa1c <cblas_dsyr2k+0x6dc>
      for (i = 0; i < N; i++) {
 800f8d2:	9b00      	ldr	r3, [sp, #0]
 800f8d4:	2b00      	cmp	r3, #0
      trans = CblasNoTrans;
 800f8d6:	bfc8      	it	gt
 800f8d8:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800f8dc:	f73f adaf 	bgt.w	800f43e <cblas_dsyr2k+0xfe>
  if (alpha == 0.0)
 800f8e0:	ec51 0b1a 	vmov	r0, r1, d10
 800f8e4:	2200      	movs	r2, #0
 800f8e6:	2300      	movs	r3, #0
 800f8e8:	f019 fba6 	bl	8029038 <__aeabi_dcmpeq>
 800f8ec:	2800      	cmp	r0, #0
 800f8ee:	f47f ae4f 	bne.w	800f590 <cblas_dsyr2k+0x250>
    for (i = 0; i < N; i++) {
 800f8f2:	9b00      	ldr	r3, [sp, #0]
 800f8f4:	2b00      	cmp	r3, #0
 800f8f6:	f77f ae4b 	ble.w	800f590 <cblas_dsyr2k+0x250>
 800f8fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f8fc:	9906      	ldr	r1, [sp, #24]
 800f8fe:	3301      	adds	r3, #1
 800f900:	00db      	lsls	r3, r3, #3
 800f902:	9313      	str	r3, [sp, #76]	; 0x4c
 800f904:	9b08      	ldr	r3, [sp, #32]
 800f906:	2200      	movs	r2, #0
 800f908:	e9cd 230f 	strd	r2, r3, [sp, #60]	; 0x3c
 800f90c:	9b02      	ldr	r3, [sp, #8]
 800f90e:	920e      	str	r2, [sp, #56]	; 0x38
 800f910:	00db      	lsls	r3, r3, #3
 800f912:	9312      	str	r3, [sp, #72]	; 0x48
 800f914:	9b07      	ldr	r3, [sp, #28]
 800f916:	920d      	str	r2, [sp, #52]	; 0x34
 800f918:	00db      	lsls	r3, r3, #3
 800f91a:	9311      	str	r3, [sp, #68]	; 0x44
 800f91c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f91e:	eb03 02c1 	add.w	r2, r3, r1, lsl #3
 800f922:	9201      	str	r2, [sp, #4]
 800f924:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800f926:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
        BASE temp = 0.0;
 800f92a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800f92c:	9303      	str	r3, [sp, #12]
 800f92e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800f930:	9304      	str	r3, [sp, #16]
 800f932:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800f934:	9308      	str	r3, [sp, #32]
 800f936:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800f938:	9305      	str	r3, [sp, #20]
        for (k = 0; k < K; k++) {
 800f93a:	9b06      	ldr	r3, [sp, #24]
 800f93c:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800f93e:	f04f 0400 	mov.w	r4, #0
 800f942:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800f946:	dd2a      	ble.n	800f99e <cblas_dsyr2k+0x65e>
 800f948:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800f94a:	9a04      	ldr	r2, [sp, #16]
 800f94c:	e9dd 760b 	ldrd	r7, r6, [sp, #44]	; 0x2c
 800f950:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800f954:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f956:	9a03      	ldr	r2, [sp, #12]
 800f958:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
          temp += (A[i * lda + k] * B[j * ldb + k]
 800f95c:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800f960:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800f964:	f019 f900 	bl	8028b68 <__aeabi_dmul>
                   + B[i * ldb + k] * A[j * lda + k]);
 800f968:	ecb7 8b02 	vldmia	r7!, {d8}
 800f96c:	e8fa 2302 	ldrd	r2, r3, [sl], #8
          temp += (A[i * lda + k] * B[j * ldb + k]
 800f970:	4680      	mov	r8, r0
 800f972:	4689      	mov	r9, r1
                   + B[i * ldb + k] * A[j * lda + k]);
 800f974:	ec51 0b18 	vmov	r0, r1, d8
 800f978:	f019 f8f6 	bl	8028b68 <__aeabi_dmul>
 800f97c:	4602      	mov	r2, r0
 800f97e:	460b      	mov	r3, r1
 800f980:	4640      	mov	r0, r8
 800f982:	4649      	mov	r1, r9
 800f984:	f018 ff3a 	bl	80287fc <__adddf3>
 800f988:	460b      	mov	r3, r1
 800f98a:	4602      	mov	r2, r0
          temp += (A[i * lda + k] * B[j * ldb + k]
 800f98c:	4629      	mov	r1, r5
 800f98e:	4620      	mov	r0, r4
 800f990:	f018 ff34 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 800f994:	9b01      	ldr	r3, [sp, #4]
 800f996:	42b3      	cmp	r3, r6
          temp += (A[i * lda + k] * B[j * ldb + k]
 800f998:	4604      	mov	r4, r0
 800f99a:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800f99c:	d1de      	bne.n	800f95c <cblas_dsyr2k+0x61c>
        C[i * ldc + j] += alpha * temp;
 800f99e:	9e08      	ldr	r6, [sp, #32]
 800f9a0:	4620      	mov	r0, r4
 800f9a2:	4629      	mov	r1, r5
 800f9a4:	e9d6 4500 	ldrd	r4, r5, [r6]
 800f9a8:	ec53 2b1a 	vmov	r2, r3, d10
 800f9ac:	f019 f8dc 	bl	8028b68 <__aeabi_dmul>
 800f9b0:	4622      	mov	r2, r4
 800f9b2:	462b      	mov	r3, r5
 800f9b4:	f018 ff22 	bl	80287fc <__adddf3>
 800f9b8:	9a04      	ldr	r2, [sp, #16]
 800f9ba:	9c07      	ldr	r4, [sp, #28]
      for (j = i; j < N; j++) {
 800f9bc:	9b05      	ldr	r3, [sp, #20]
 800f9be:	4422      	add	r2, r4
 800f9c0:	9204      	str	r2, [sp, #16]
 800f9c2:	e9dd 4202 	ldrd	r4, r2, [sp, #8]
 800f9c6:	4422      	add	r2, r4
        C[i * ldc + j] += alpha * temp;
 800f9c8:	e8e6 0102 	strd	r0, r1, [r6], #8
 800f9cc:	9203      	str	r2, [sp, #12]
      for (j = i; j < N; j++) {
 800f9ce:	9a00      	ldr	r2, [sp, #0]
        C[i * ldc + j] += alpha * temp;
 800f9d0:	9608      	str	r6, [sp, #32]
      for (j = i; j < N; j++) {
 800f9d2:	3301      	adds	r3, #1
 800f9d4:	429a      	cmp	r2, r3
 800f9d6:	9305      	str	r3, [sp, #20]
 800f9d8:	dcaf      	bgt.n	800f93a <cblas_dsyr2k+0x5fa>
    for (i = 0; i < N; i++) {
 800f9da:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800f9dc:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800f9de:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800f9e0:	440a      	add	r2, r1
 800f9e2:	9210      	str	r2, [sp, #64]	; 0x40
 800f9e4:	9907      	ldr	r1, [sp, #28]
 800f9e6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800f9e8:	440a      	add	r2, r1
 800f9ea:	920f      	str	r2, [sp, #60]	; 0x3c
 800f9ec:	9902      	ldr	r1, [sp, #8]
 800f9ee:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800f9f0:	440a      	add	r2, r1
 800f9f2:	990c      	ldr	r1, [sp, #48]	; 0x30
 800f9f4:	920e      	str	r2, [sp, #56]	; 0x38
 800f9f6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800f9f8:	4608      	mov	r0, r1
 800f9fa:	4410      	add	r0, r2
 800f9fc:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800f9fe:	900c      	str	r0, [sp, #48]	; 0x30
 800fa00:	9811      	ldr	r0, [sp, #68]	; 0x44
 800fa02:	4401      	add	r1, r0
 800fa04:	910b      	str	r1, [sp, #44]	; 0x2c
 800fa06:	9901      	ldr	r1, [sp, #4]
 800fa08:	4411      	add	r1, r2
 800fa0a:	9a00      	ldr	r2, [sp, #0]
 800fa0c:	9101      	str	r1, [sp, #4]
 800fa0e:	3301      	adds	r3, #1
 800fa10:	429a      	cmp	r2, r3
 800fa12:	930d      	str	r3, [sp, #52]	; 0x34
 800fa14:	d189      	bne.n	800f92a <cblas_dsyr2k+0x5ea>
 800fa16:	e5bb      	b.n	800f590 <cblas_dsyr2k+0x250>
 800fa18:	9a06      	ldr	r2, [sp, #24]
 800fa1a:	e5bf      	b.n	800f59c <cblas_dsyr2k+0x25c>
  } else if (beta != 1.0) {
 800fa1c:	4b22      	ldr	r3, [pc, #136]	; (800faa8 <cblas_dsyr2k+0x768>)
 800fa1e:	2200      	movs	r2, #0
 800fa20:	4630      	mov	r0, r6
 800fa22:	4639      	mov	r1, r7
 800fa24:	f019 fb08 	bl	8029038 <__aeabi_dcmpeq>
 800fa28:	2800      	cmp	r0, #0
 800fa2a:	f47f af59 	bne.w	800f8e0 <cblas_dsyr2k+0x5a0>
      for (i = 0; i < N; i++) {
 800fa2e:	9b00      	ldr	r3, [sp, #0]
 800fa30:	2b00      	cmp	r3, #0
      trans = CblasNoTrans;
 800fa32:	bfc8      	it	gt
 800fa34:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800fa38:	f73f af00 	bgt.w	800f83c <cblas_dsyr2k+0x4fc>
 800fa3c:	e750      	b.n	800f8e0 <cblas_dsyr2k+0x5a0>
  if (beta == 0.0) {
 800fa3e:	f019 fafb 	bl	8029038 <__aeabi_dcmpeq>
 800fa42:	b9e8      	cbnz	r0, 800fa80 <cblas_dsyr2k+0x740>
  } else if (beta != 1.0) {
 800fa44:	4b18      	ldr	r3, [pc, #96]	; (800faa8 <cblas_dsyr2k+0x768>)
 800fa46:	2200      	movs	r2, #0
 800fa48:	4630      	mov	r0, r6
 800fa4a:	4639      	mov	r1, r7
 800fa4c:	f019 faf4 	bl	8029038 <__aeabi_dcmpeq>
 800fa50:	bb60      	cbnz	r0, 800faac <cblas_dsyr2k+0x76c>
      for (i = 0; i < N; i++) {
 800fa52:	9b00      	ldr	r3, [sp, #0]
 800fa54:	2b00      	cmp	r3, #0
 800fa56:	dd29      	ble.n	800faac <cblas_dsyr2k+0x76c>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fa58:	237a      	movs	r3, #122	; 0x7a
      trans = CblasNoTrans;
 800fa5a:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fa5e:	9301      	str	r3, [sp, #4]
 800fa60:	e5e6      	b.n	800f630 <cblas_dsyr2k+0x2f0>
  } else if (beta != 1.0) {
 800fa62:	4b11      	ldr	r3, [pc, #68]	; (800faa8 <cblas_dsyr2k+0x768>)
 800fa64:	2200      	movs	r2, #0
 800fa66:	4630      	mov	r0, r6
 800fa68:	4639      	mov	r1, r7
 800fa6a:	f019 fae5 	bl	8029038 <__aeabi_dcmpeq>
 800fa6e:	b980      	cbnz	r0, 800fa92 <cblas_dsyr2k+0x752>
      for (i = 0; i < N; i++) {
 800fa70:	9b00      	ldr	r3, [sp, #0]
 800fa72:	2b00      	cmp	r3, #0
 800fa74:	dd0d      	ble.n	800fa92 <cblas_dsyr2k+0x752>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fa76:	237a      	movs	r3, #122	; 0x7a
      trans = CblasTrans;
 800fa78:	f04f 0b70 	mov.w	fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fa7c:	9301      	str	r3, [sp, #4]
 800fa7e:	e5d7      	b.n	800f630 <cblas_dsyr2k+0x2f0>
      for (i = 0; i < N; i++) {
 800fa80:	9b00      	ldr	r3, [sp, #0]
 800fa82:	2b00      	cmp	r3, #0
 800fa84:	f77f ad84 	ble.w	800f590 <cblas_dsyr2k+0x250>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fa88:	237a      	movs	r3, #122	; 0x7a
      trans = CblasNoTrans;
 800fa8a:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fa8e:	9301      	str	r3, [sp, #4]
 800fa90:	e617      	b.n	800f6c2 <cblas_dsyr2k+0x382>
  if (alpha == 0.0)
 800fa92:	ec51 0b1a 	vmov	r0, r1, d10
 800fa96:	2200      	movs	r2, #0
 800fa98:	2300      	movs	r3, #0
 800fa9a:	f019 facd 	bl	8029038 <__aeabi_dcmpeq>
 800fa9e:	2800      	cmp	r0, #0
 800faa0:	f43f ae3e 	beq.w	800f720 <cblas_dsyr2k+0x3e0>
 800faa4:	e574      	b.n	800f590 <cblas_dsyr2k+0x250>
 800faa6:	bf00      	nop
 800faa8:	3ff00000 	.word	0x3ff00000
 800faac:	ec51 0b1a 	vmov	r0, r1, d10
 800fab0:	2200      	movs	r2, #0
 800fab2:	2300      	movs	r3, #0
 800fab4:	f019 fac0 	bl	8029038 <__aeabi_dcmpeq>
 800fab8:	2800      	cmp	r0, #0
 800faba:	f47f ad69 	bne.w	800f590 <cblas_dsyr2k+0x250>
    for (i = 0; i < N; i++) {
 800fabe:	9b00      	ldr	r3, [sp, #0]
 800fac0:	2b00      	cmp	r3, #0
 800fac2:	f77f ad65 	ble.w	800f590 <cblas_dsyr2k+0x250>
 800fac6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800fac8:	9906      	ldr	r1, [sp, #24]
 800faca:	3301      	adds	r3, #1
 800facc:	00db      	lsls	r3, r3, #3
 800face:	9313      	str	r3, [sp, #76]	; 0x4c
 800fad0:	9b08      	ldr	r3, [sp, #32]
 800fad2:	3308      	adds	r3, #8
 800fad4:	930b      	str	r3, [sp, #44]	; 0x2c
 800fad6:	9b02      	ldr	r3, [sp, #8]
 800fad8:	00db      	lsls	r3, r3, #3
 800fada:	9312      	str	r3, [sp, #72]	; 0x48
 800fadc:	9b07      	ldr	r3, [sp, #28]
 800fade:	00db      	lsls	r3, r3, #3
 800fae0:	9311      	str	r3, [sp, #68]	; 0x44
 800fae2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fae4:	2200      	movs	r2, #0
 800fae6:	920f      	str	r2, [sp, #60]	; 0x3c
 800fae8:	9210      	str	r2, [sp, #64]	; 0x40
 800faea:	eb03 02c1 	add.w	r2, r3, r1, lsl #3
 800faee:	9201      	str	r2, [sp, #4]
 800faf0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800faf2:	e9cd 230d 	strd	r2, r3, [sp, #52]	; 0x34
        BASE temp = 0.0;
 800faf6:	2300      	movs	r3, #0
 800faf8:	e9cd 3303 	strd	r3, r3, [sp, #12]
 800fafc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800fafe:	9b08      	ldr	r3, [sp, #32]
 800fb00:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800fb04:	9305      	str	r3, [sp, #20]
        for (k = 0; k < K; k++) {
 800fb06:	9b06      	ldr	r3, [sp, #24]
 800fb08:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800fb0a:	f04f 0400 	mov.w	r4, #0
 800fb0e:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800fb12:	dd2a      	ble.n	800fb6a <cblas_dsyr2k+0x82a>
 800fb14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800fb16:	9a04      	ldr	r2, [sp, #16]
 800fb18:	e9dd 760d 	ldrd	r7, r6, [sp, #52]	; 0x34
 800fb1c:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800fb20:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fb22:	9a03      	ldr	r2, [sp, #12]
 800fb24:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
          temp += (A[i * lda + k] * B[j * ldb + k]
 800fb28:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800fb2c:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800fb30:	f019 f81a 	bl	8028b68 <__aeabi_dmul>
                   + B[i * ldb + k] * A[j * lda + k]);
 800fb34:	ecb7 8b02 	vldmia	r7!, {d8}
 800fb38:	e8fa 2302 	ldrd	r2, r3, [sl], #8
          temp += (A[i * lda + k] * B[j * ldb + k]
 800fb3c:	4680      	mov	r8, r0
 800fb3e:	4689      	mov	r9, r1
                   + B[i * ldb + k] * A[j * lda + k]);
 800fb40:	ec51 0b18 	vmov	r0, r1, d8
 800fb44:	f019 f810 	bl	8028b68 <__aeabi_dmul>
 800fb48:	4602      	mov	r2, r0
 800fb4a:	460b      	mov	r3, r1
 800fb4c:	4640      	mov	r0, r8
 800fb4e:	4649      	mov	r1, r9
 800fb50:	f018 fe54 	bl	80287fc <__adddf3>
 800fb54:	460b      	mov	r3, r1
 800fb56:	4602      	mov	r2, r0
          temp += (A[i * lda + k] * B[j * ldb + k]
 800fb58:	4629      	mov	r1, r5
 800fb5a:	4620      	mov	r0, r4
 800fb5c:	f018 fe4e 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 800fb60:	9b01      	ldr	r3, [sp, #4]
 800fb62:	42b3      	cmp	r3, r6
          temp += (A[i * lda + k] * B[j * ldb + k]
 800fb64:	4604      	mov	r4, r0
 800fb66:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800fb68:	d1de      	bne.n	800fb28 <cblas_dsyr2k+0x7e8>
        C[i * ldc + j] += alpha * temp;
 800fb6a:	9e05      	ldr	r6, [sp, #20]
 800fb6c:	4622      	mov	r2, r4
 800fb6e:	462b      	mov	r3, r5
 800fb70:	e9d6 4500 	ldrd	r4, r5, [r6]
 800fb74:	ec51 0b1a 	vmov	r0, r1, d10
 800fb78:	f018 fff6 	bl	8028b68 <__aeabi_dmul>
 800fb7c:	4622      	mov	r2, r4
 800fb7e:	462b      	mov	r3, r5
 800fb80:	f018 fe3c 	bl	80287fc <__adddf3>
 800fb84:	9b04      	ldr	r3, [sp, #16]
 800fb86:	9a07      	ldr	r2, [sp, #28]
 800fb88:	4413      	add	r3, r2
 800fb8a:	9304      	str	r3, [sp, #16]
 800fb8c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800fb90:	e8e6 0102 	strd	r0, r1, [r6], #8
 800fb94:	4413      	add	r3, r2
 800fb96:	9303      	str	r3, [sp, #12]
      for (j = 0; j <= i; j++) {
 800fb98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        C[i * ldc + j] += alpha * temp;
 800fb9a:	9605      	str	r6, [sp, #20]
      for (j = 0; j <= i; j++) {
 800fb9c:	42b3      	cmp	r3, r6
 800fb9e:	d1b2      	bne.n	800fb06 <cblas_dsyr2k+0x7c6>
    for (i = 0; i < N; i++) {
 800fba0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800fba2:	990c      	ldr	r1, [sp, #48]	; 0x30
 800fba4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800fba6:	440a      	add	r2, r1
 800fba8:	920f      	str	r2, [sp, #60]	; 0x3c
 800fbaa:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800fbac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800fbae:	440a      	add	r2, r1
 800fbb0:	990e      	ldr	r1, [sp, #56]	; 0x38
 800fbb2:	920b      	str	r2, [sp, #44]	; 0x2c
 800fbb4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800fbb6:	4608      	mov	r0, r1
 800fbb8:	4410      	add	r0, r2
 800fbba:	990d      	ldr	r1, [sp, #52]	; 0x34
 800fbbc:	900e      	str	r0, [sp, #56]	; 0x38
 800fbbe:	9811      	ldr	r0, [sp, #68]	; 0x44
 800fbc0:	4401      	add	r1, r0
 800fbc2:	910d      	str	r1, [sp, #52]	; 0x34
 800fbc4:	9901      	ldr	r1, [sp, #4]
 800fbc6:	4411      	add	r1, r2
 800fbc8:	9a00      	ldr	r2, [sp, #0]
 800fbca:	9101      	str	r1, [sp, #4]
 800fbcc:	3301      	adds	r3, #1
 800fbce:	429a      	cmp	r2, r3
 800fbd0:	9310      	str	r3, [sp, #64]	; 0x40
 800fbd2:	d190      	bne.n	800faf6 <cblas_dsyr2k+0x7b6>
 800fbd4:	e4dc      	b.n	800f590 <cblas_dsyr2k+0x250>
      for (i = 0; i < N; i++) {
 800fbd6:	2b00      	cmp	r3, #0
 800fbd8:	f73f ac31 	bgt.w	800f43e <cblas_dsyr2k+0xfe>
 800fbdc:	e442      	b.n	800f464 <cblas_dsyr2k+0x124>
      for (i = 0; i < N; i++) {
 800fbde:	2b00      	cmp	r3, #0
 800fbe0:	f73f ae2c 	bgt.w	800f83c <cblas_dsyr2k+0x4fc>
 800fbe4:	e43e      	b.n	800f464 <cblas_dsyr2k+0x124>
 800fbe6:	bf00      	nop

0800fbe8 <cblas_dsyrk>:
void
cblas_dsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const double alpha, const double *A, const int lda,
             const double beta, double *C, const int ldc)
{
 800fbe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fbec:	ed2d 8b02 	vpush	{d8}
 800fbf0:	eeb0 8a40 	vmov.f32	s16, s0
 800fbf4:	eef0 8a60 	vmov.f32	s17, s1
 800fbf8:	b08d      	sub	sp, #52	; 0x34
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800fbfa:	2865      	cmp	r0, #101	; 0x65
 800fbfc:	9301      	str	r3, [sp, #4]
 800fbfe:	e9dd 8318 	ldrd	r8, r3, [sp, #96]	; 0x60
 800fc02:	9303      	str	r3, [sp, #12]
 800fc04:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800fc06:	9302      	str	r3, [sp, #8]
 800fc08:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800fc0a:	9307      	str	r3, [sp, #28]
 800fc0c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800fc0e:	9305      	str	r3, [sp, #20]
 800fc10:	ec57 6b11 	vmov	r6, r7, d1
 800fc14:	4605      	mov	r5, r0
 800fc16:	460c      	mov	r4, r1
 800fc18:	4693      	mov	fp, r2
 800fc1a:	f000 8103 	beq.w	800fe24 <cblas_dsyrk+0x23c>
 800fc1e:	2a6f      	cmp	r2, #111	; 0x6f
 800fc20:	d024      	beq.n	800fc6c <cblas_dsyrk+0x84>
 800fc22:	4643      	mov	r3, r8
 800fc24:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 800fc28:	2a01      	cmp	r2, #1
 800fc2a:	f240 80f4 	bls.w	800fe16 <cblas_dsyrk+0x22e>
 800fc2e:	2002      	movs	r0, #2
 800fc30:	f1ab 026f 	sub.w	r2, fp, #111	; 0x6f
 800fc34:	b2d2      	uxtb	r2, r2
 800fc36:	2a03      	cmp	r2, #3
 800fc38:	bf28      	it	cs
 800fc3a:	2003      	movcs	r0, #3
 800fc3c:	9a01      	ldr	r2, [sp, #4]
 800fc3e:	2a00      	cmp	r2, #0
 800fc40:	bfb8      	it	lt
 800fc42:	2004      	movlt	r0, #4
 800fc44:	2b01      	cmp	r3, #1
 800fc46:	bfb8      	it	lt
 800fc48:	2301      	movlt	r3, #1
 800fc4a:	f1b8 0f00 	cmp.w	r8, #0
 800fc4e:	f2c0 80d5 	blt.w	800fdfc <cblas_dsyrk+0x214>
 800fc52:	9a02      	ldr	r2, [sp, #8]
 800fc54:	4293      	cmp	r3, r2
 800fc56:	dc11      	bgt.n	800fc7c <cblas_dsyrk+0x94>
 800fc58:	9b01      	ldr	r3, [sp, #4]
 800fc5a:	9a05      	ldr	r2, [sp, #20]
 800fc5c:	2b01      	cmp	r3, #1
 800fc5e:	bfb8      	it	lt
 800fc60:	2301      	movlt	r3, #1
 800fc62:	4293      	cmp	r3, r2
 800fc64:	f300 81e1 	bgt.w	801002a <cblas_dsyrk+0x442>
 800fc68:	b1a8      	cbz	r0, 800fc96 <cblas_dsyrk+0xae>
 800fc6a:	e010      	b.n	800fc8e <cblas_dsyrk+0xa6>
 800fc6c:	9b01      	ldr	r3, [sp, #4]
 800fc6e:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 800fc72:	2a01      	cmp	r2, #1
 800fc74:	f240 80cf 	bls.w	800fe16 <cblas_dsyrk+0x22e>
 800fc78:	2002      	movs	r0, #2
 800fc7a:	e7df      	b.n	800fc3c <cblas_dsyrk+0x54>
 800fc7c:	9801      	ldr	r0, [sp, #4]
 800fc7e:	9b05      	ldr	r3, [sp, #20]
 800fc80:	2801      	cmp	r0, #1
 800fc82:	bfb8      	it	lt
 800fc84:	2001      	movlt	r0, #1
 800fc86:	4283      	cmp	r3, r0
 800fc88:	bfb4      	ite	lt
 800fc8a:	200b      	movlt	r0, #11
 800fc8c:	2008      	movge	r0, #8
 800fc8e:	4a93      	ldr	r2, [pc, #588]	; (800fedc <cblas_dsyrk+0x2f4>)
 800fc90:	4993      	ldr	r1, [pc, #588]	; (800fee0 <cblas_dsyrk+0x2f8>)
 800fc92:	f018 fd39 	bl	8028708 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800fc96:	ec51 0b18 	vmov	r0, r1, d8
 800fc9a:	2200      	movs	r2, #0
 800fc9c:	2300      	movs	r3, #0
 800fc9e:	f019 f9cb 	bl	8029038 <__aeabi_dcmpeq>
 800fca2:	b140      	cbz	r0, 800fcb6 <cblas_dsyrk+0xce>
 800fca4:	4b8f      	ldr	r3, [pc, #572]	; (800fee4 <cblas_dsyrk+0x2fc>)
 800fca6:	2200      	movs	r2, #0
 800fca8:	4630      	mov	r0, r6
 800fcaa:	4639      	mov	r1, r7
 800fcac:	f019 f9c4 	bl	8029038 <__aeabi_dcmpeq>
 800fcb0:	2800      	cmp	r0, #0
 800fcb2:	f040 809e 	bne.w	800fdf2 <cblas_dsyrk+0x20a>
  if (Order == CblasRowMajor) {
 800fcb6:	2d65      	cmp	r5, #101	; 0x65
 800fcb8:	f000 80b9 	beq.w	800fe2e <cblas_dsyrk+0x246>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800fcbc:	f1ab 0370 	sub.w	r3, fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fcc0:	2c79      	cmp	r4, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800fcc2:	b2db      	uxtb	r3, r3
  if (beta == 0.0) {
 800fcc4:	f04f 0200 	mov.w	r2, #0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fcc8:	f000 81b1 	beq.w	801002e <cblas_dsyrk+0x446>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800fccc:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800fcce:	4630      	mov	r0, r6
 800fcd0:	f04f 0300 	mov.w	r3, #0
 800fcd4:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800fcd6:	f240 81bf 	bls.w	8010058 <cblas_dsyrk+0x470>
  if (beta == 0.0) {
 800fcda:	f019 f9ad 	bl	8029038 <__aeabi_dcmpeq>
 800fcde:	2800      	cmp	r0, #0
 800fce0:	f000 8193 	beq.w	801000a <cblas_dsyrk+0x422>
      for (i = 0; i < N; i++) {
 800fce4:	9b01      	ldr	r3, [sp, #4]
 800fce6:	2b00      	cmp	r3, #0
 800fce8:	f340 8083 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
      trans = CblasTrans;
 800fcec:	2370      	movs	r3, #112	; 0x70
 800fcee:	9304      	str	r3, [sp, #16]
 800fcf0:	9b05      	ldr	r3, [sp, #20]
 800fcf2:	9807      	ldr	r0, [sp, #28]
      for (i = 0; i < N; i++) {
 800fcf4:	9d01      	ldr	r5, [sp, #4]
 800fcf6:	1c5c      	adds	r4, r3, #1
          C[ldc * i + j] = 0.0;
 800fcf8:	2600      	movs	r6, #0
 800fcfa:	2700      	movs	r7, #0
 800fcfc:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800fcfe:	2100      	movs	r1, #0
 800fd00:	4602      	mov	r2, r0
 800fd02:	460b      	mov	r3, r1
        for (j = i; j < N; j++) {
 800fd04:	3301      	adds	r3, #1
 800fd06:	429d      	cmp	r5, r3
          C[ldc * i + j] = 0.0;
 800fd08:	e8e2 6702 	strd	r6, r7, [r2], #8
        for (j = i; j < N; j++) {
 800fd0c:	dcfa      	bgt.n	800fd04 <cblas_dsyrk+0x11c>
      for (i = 0; i < N; i++) {
 800fd0e:	3101      	adds	r1, #1
 800fd10:	428d      	cmp	r5, r1
 800fd12:	4420      	add	r0, r4
 800fd14:	dcf4      	bgt.n	800fd00 <cblas_dsyrk+0x118>
  if (alpha == 0.0)
 800fd16:	ec51 0b18 	vmov	r0, r1, d8
 800fd1a:	2200      	movs	r2, #0
 800fd1c:	2300      	movs	r3, #0
 800fd1e:	f019 f98b 	bl	8029038 <__aeabi_dcmpeq>
 800fd22:	2800      	cmp	r0, #0
 800fd24:	d165      	bne.n	800fdf2 <cblas_dsyrk+0x20a>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800fd26:	9b04      	ldr	r3, [sp, #16]
 800fd28:	2b6f      	cmp	r3, #111	; 0x6f
 800fd2a:	f000 81b2 	beq.w	8010092 <cblas_dsyrk+0x4aa>
  } else if (uplo == CblasUpper && trans == CblasTrans) {
 800fd2e:	9b04      	ldr	r3, [sp, #16]
 800fd30:	2b70      	cmp	r3, #112	; 0x70
 800fd32:	f040 80c9 	bne.w	800fec8 <cblas_dsyrk+0x2e0>
    for (i = 0; i < N; i++) {
 800fd36:	9b01      	ldr	r3, [sp, #4]
 800fd38:	2b00      	cmp	r3, #0
 800fd3a:	dd5a      	ble.n	800fdf2 <cblas_dsyrk+0x20a>
 800fd3c:	9b05      	ldr	r3, [sp, #20]
 800fd3e:	3301      	adds	r3, #1
 800fd40:	00db      	lsls	r3, r3, #3
 800fd42:	9308      	str	r3, [sp, #32]
 800fd44:	9b07      	ldr	r3, [sp, #28]
 800fd46:	9306      	str	r3, [sp, #24]
 800fd48:	9b03      	ldr	r3, [sp, #12]
 800fd4a:	9304      	str	r3, [sp, #16]
 800fd4c:	9b02      	ldr	r3, [sp, #8]
 800fd4e:	2700      	movs	r7, #0
 800fd50:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 800fd54:	9705      	str	r7, [sp, #20]
 800fd56:	9b05      	ldr	r3, [sp, #20]
        BASE temp = 0.0;
 800fd58:	9a06      	ldr	r2, [sp, #24]
 800fd5a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800fd5e:	00de      	lsls	r6, r3, #3
        for (k = 0; k < K; k++) {
 800fd60:	f1b8 0f00 	cmp.w	r8, #0
        BASE temp = 0.0;
 800fd64:	f04f 0400 	mov.w	r4, #0
 800fd68:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800fd6c:	dd19      	ble.n	800fda2 <cblas_dsyrk+0x1ba>
 800fd6e:	f8dd a010 	ldr.w	sl, [sp, #16]
 800fd72:	f04f 0b00 	mov.w	fp, #0
          temp += A[k * lda + i] * A[k * lda + j];
 800fd76:	eb07 030a 	add.w	r3, r7, sl
 800fd7a:	4433      	add	r3, r6
 800fd7c:	e9d3 0100 	ldrd	r0, r1, [r3]
 800fd80:	e9da 2300 	ldrd	r2, r3, [sl]
 800fd84:	f018 fef0 	bl	8028b68 <__aeabi_dmul>
 800fd88:	4602      	mov	r2, r0
 800fd8a:	460b      	mov	r3, r1
 800fd8c:	4620      	mov	r0, r4
 800fd8e:	4629      	mov	r1, r5
 800fd90:	f018 fd34 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 800fd94:	f10b 0b01 	add.w	fp, fp, #1
 800fd98:	45d8      	cmp	r8, fp
          temp += A[k * lda + i] * A[k * lda + j];
 800fd9a:	4604      	mov	r4, r0
 800fd9c:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800fd9e:	44ca      	add	sl, r9
 800fda0:	d1e9      	bne.n	800fd76 <cblas_dsyrk+0x18e>
        C[i * ldc + j] += alpha * temp;
 800fda2:	9b02      	ldr	r3, [sp, #8]
 800fda4:	4620      	mov	r0, r4
 800fda6:	4629      	mov	r1, r5
 800fda8:	e9d3 4500 	ldrd	r4, r5, [r3]
 800fdac:	ec53 2b18 	vmov	r2, r3, d8
 800fdb0:	f018 feda 	bl	8028b68 <__aeabi_dmul>
 800fdb4:	4622      	mov	r2, r4
 800fdb6:	462b      	mov	r3, r5
 800fdb8:	f018 fd20 	bl	80287fc <__adddf3>
 800fdbc:	9a02      	ldr	r2, [sp, #8]
      for (j = i; j < N; j++) {
 800fdbe:	9b03      	ldr	r3, [sp, #12]
        C[i * ldc + j] += alpha * temp;
 800fdc0:	e8e2 0102 	strd	r0, r1, [r2], #8
 800fdc4:	9202      	str	r2, [sp, #8]
      for (j = i; j < N; j++) {
 800fdc6:	9a01      	ldr	r2, [sp, #4]
 800fdc8:	3301      	adds	r3, #1
 800fdca:	429a      	cmp	r2, r3
 800fdcc:	9303      	str	r3, [sp, #12]
 800fdce:	f106 0608 	add.w	r6, r6, #8
 800fdd2:	dcc5      	bgt.n	800fd60 <cblas_dsyrk+0x178>
    for (i = 0; i < N; i++) {
 800fdd4:	9a06      	ldr	r2, [sp, #24]
 800fdd6:	9908      	ldr	r1, [sp, #32]
 800fdd8:	9b05      	ldr	r3, [sp, #20]
 800fdda:	440a      	add	r2, r1
 800fddc:	9206      	str	r2, [sp, #24]
 800fdde:	9a04      	ldr	r2, [sp, #16]
 800fde0:	3208      	adds	r2, #8
 800fde2:	9204      	str	r2, [sp, #16]
 800fde4:	9a01      	ldr	r2, [sp, #4]
 800fde6:	3301      	adds	r3, #1
 800fde8:	429a      	cmp	r2, r3
 800fdea:	9305      	str	r3, [sp, #20]
 800fdec:	f1a7 0708 	sub.w	r7, r7, #8
 800fdf0:	d1b1      	bne.n	800fd56 <cblas_dsyrk+0x16e>
#define BASE double
#include "source_syrk_r.h"
#undef BASE
}
 800fdf2:	b00d      	add	sp, #52	; 0x34
 800fdf4:	ecbd 8b02 	vpop	{d8}
 800fdf8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800fdfc:	9902      	ldr	r1, [sp, #8]
 800fdfe:	428b      	cmp	r3, r1
 800fe00:	f73f af3c 	bgt.w	800fc7c <cblas_dsyrk+0x94>
 800fe04:	2a01      	cmp	r2, #1
 800fe06:	9b05      	ldr	r3, [sp, #20]
 800fe08:	bfb8      	it	lt
 800fe0a:	2201      	movlt	r2, #1
 800fe0c:	4293      	cmp	r3, r2
 800fe0e:	bfb4      	ite	lt
 800fe10:	200b      	movlt	r0, #11
 800fe12:	2005      	movge	r0, #5
 800fe14:	e73b      	b.n	800fc8e <cblas_dsyrk+0xa6>
 800fe16:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 800fe1a:	2801      	cmp	r0, #1
 800fe1c:	bf94      	ite	ls
 800fe1e:	2000      	movls	r0, #0
 800fe20:	2001      	movhi	r0, #1
 800fe22:	e705      	b.n	800fc30 <cblas_dsyrk+0x48>
 800fe24:	2a6f      	cmp	r2, #111	; 0x6f
 800fe26:	f000 8120 	beq.w	801006a <cblas_dsyrk+0x482>
 800fe2a:	9b01      	ldr	r3, [sp, #4]
 800fe2c:	e6fa      	b.n	800fc24 <cblas_dsyrk+0x3c>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 800fe2e:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 800fe32:	bf14      	ite	ne
 800fe34:	465d      	movne	r5, fp
 800fe36:	2570      	moveq	r5, #112	; 0x70
  if (beta == 0.0) {
 800fe38:	2200      	movs	r2, #0
 800fe3a:	2300      	movs	r3, #0
 800fe3c:	4630      	mov	r0, r6
 800fe3e:	4639      	mov	r1, r7
 800fe40:	9504      	str	r5, [sp, #16]
 800fe42:	f019 f8f9 	bl	8029038 <__aeabi_dcmpeq>
    uplo = Uplo;
 800fe46:	9406      	str	r4, [sp, #24]
  if (beta == 0.0) {
 800fe48:	2800      	cmp	r0, #0
 800fe4a:	d14f      	bne.n	800feec <cblas_dsyrk+0x304>
  } else if (beta != 1.0) {
 800fe4c:	4b25      	ldr	r3, [pc, #148]	; (800fee4 <cblas_dsyrk+0x2fc>)
 800fe4e:	2200      	movs	r2, #0
 800fe50:	4630      	mov	r0, r6
 800fe52:	4639      	mov	r1, r7
 800fe54:	f019 f8f0 	bl	8029038 <__aeabi_dcmpeq>
 800fe58:	2800      	cmp	r0, #0
 800fe5a:	d166      	bne.n	800ff2a <cblas_dsyrk+0x342>
    if (uplo == CblasUpper) {
 800fe5c:	9b06      	ldr	r3, [sp, #24]
 800fe5e:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800fe60:	9b01      	ldr	r3, [sp, #4]
    if (uplo == CblasUpper) {
 800fe62:	f000 8249 	beq.w	80102f8 <cblas_dsyrk+0x710>
      for (i = 0; i < N; i++) {
 800fe66:	2b00      	cmp	r3, #0
 800fe68:	dd23      	ble.n	800feb2 <cblas_dsyrk+0x2ca>
 800fe6a:	9b05      	ldr	r3, [sp, #20]
 800fe6c:	f8cd 8020 	str.w	r8, [sp, #32]
 800fe70:	f103 0a01 	add.w	sl, r3, #1
 800fe74:	9b07      	ldr	r3, [sp, #28]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800fe76:	f04f 0b00 	mov.w	fp, #0
 800fe7a:	ea4f 0aca 	mov.w	sl, sl, lsl #3
      for (i = 0; i < N; i++) {
 800fe7e:	46d9      	mov	r9, fp
 800fe80:	f103 0508 	add.w	r5, r3, #8
 800fe84:	4698      	mov	r8, r3
 800fe86:	eb08 04cb 	add.w	r4, r8, fp, lsl #3
          C[ldc * i + j] *= beta;
 800fe8a:	e9d4 0100 	ldrd	r0, r1, [r4]
 800fe8e:	4632      	mov	r2, r6
 800fe90:	463b      	mov	r3, r7
 800fe92:	f018 fe69 	bl	8028b68 <__aeabi_dmul>
 800fe96:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j <= i; j++) {
 800fe9a:	42a5      	cmp	r5, r4
 800fe9c:	d1f5      	bne.n	800fe8a <cblas_dsyrk+0x2a2>
      for (i = 0; i < N; i++) {
 800fe9e:	9b05      	ldr	r3, [sp, #20]
 800fea0:	449b      	add	fp, r3
 800fea2:	9b01      	ldr	r3, [sp, #4]
 800fea4:	f109 0901 	add.w	r9, r9, #1
 800fea8:	454b      	cmp	r3, r9
 800feaa:	4455      	add	r5, sl
 800feac:	dceb      	bgt.n	800fe86 <cblas_dsyrk+0x29e>
 800feae:	f8dd 8020 	ldr.w	r8, [sp, #32]
  if (alpha == 0.0)
 800feb2:	ec51 0b18 	vmov	r0, r1, d8
 800feb6:	2200      	movs	r2, #0
 800feb8:	2300      	movs	r3, #0
 800feba:	f019 f8bd 	bl	8029038 <__aeabi_dcmpeq>
 800febe:	2800      	cmp	r0, #0
 800fec0:	d197      	bne.n	800fdf2 <cblas_dsyrk+0x20a>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800fec2:	9b06      	ldr	r3, [sp, #24]
 800fec4:	2b7a      	cmp	r3, #122	; 0x7a
 800fec6:	d040      	beq.n	800ff4a <cblas_dsyrk+0x362>
    BLAS_ERROR("unrecognized operation");
 800fec8:	4a07      	ldr	r2, [pc, #28]	; (800fee8 <cblas_dsyrk+0x300>)
 800feca:	4905      	ldr	r1, [pc, #20]	; (800fee0 <cblas_dsyrk+0x2f8>)
 800fecc:	2000      	movs	r0, #0
 800fece:	b00d      	add	sp, #52	; 0x34
 800fed0:	ecbd 8b02 	vpop	{d8}
 800fed4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800fed8:	f018 bc16 	b.w	8028708 <cblas_xerbla>
 800fedc:	08031108 	.word	0x08031108
 800fee0:	08031270 	.word	0x08031270
 800fee4:	3ff00000 	.word	0x3ff00000
 800fee8:	080311b8 	.word	0x080311b8
    if (uplo == CblasUpper) {
 800feec:	9b06      	ldr	r3, [sp, #24]
 800feee:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800fef0:	9b01      	ldr	r3, [sp, #4]
    if (uplo == CblasUpper) {
 800fef2:	f000 81fa 	beq.w	80102ea <cblas_dsyrk+0x702>
      for (i = 0; i < N; i++) {
 800fef6:	2b00      	cmp	r3, #0
 800fef8:	dddb      	ble.n	800feb2 <cblas_dsyrk+0x2ca>
 800fefa:	9b05      	ldr	r3, [sp, #20]
 800fefc:	9a07      	ldr	r2, [sp, #28]
 800fefe:	9d01      	ldr	r5, [sp, #4]
 800ff00:	f8dd c01c 	ldr.w	ip, [sp, #28]
 800ff04:	1c5c      	adds	r4, r3, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ff06:	2100      	movs	r1, #0
          C[ldc * i + j] = 0.0;
 800ff08:	2600      	movs	r6, #0
 800ff0a:	2700      	movs	r7, #0
 800ff0c:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800ff0e:	4608      	mov	r0, r1
 800ff10:	3208      	adds	r2, #8
 800ff12:	469e      	mov	lr, r3
 800ff14:	eb0c 03c1 	add.w	r3, ip, r1, lsl #3
          C[ldc * i + j] = 0.0;
 800ff18:	e8e3 6702 	strd	r6, r7, [r3], #8
        for (j = 0; j <= i; j++) {
 800ff1c:	429a      	cmp	r2, r3
 800ff1e:	d1fb      	bne.n	800ff18 <cblas_dsyrk+0x330>
      for (i = 0; i < N; i++) {
 800ff20:	3001      	adds	r0, #1
 800ff22:	4285      	cmp	r5, r0
 800ff24:	4471      	add	r1, lr
 800ff26:	4422      	add	r2, r4
 800ff28:	dcf4      	bgt.n	800ff14 <cblas_dsyrk+0x32c>
  if (alpha == 0.0)
 800ff2a:	ec51 0b18 	vmov	r0, r1, d8
 800ff2e:	2200      	movs	r2, #0
 800ff30:	2300      	movs	r3, #0
 800ff32:	f019 f881 	bl	8029038 <__aeabi_dcmpeq>
 800ff36:	2800      	cmp	r0, #0
 800ff38:	f47f af5b 	bne.w	800fdf2 <cblas_dsyrk+0x20a>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800ff3c:	9b06      	ldr	r3, [sp, #24]
 800ff3e:	2b79      	cmp	r3, #121	; 0x79
 800ff40:	f43f aef1 	beq.w	800fd26 <cblas_dsyrk+0x13e>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800ff44:	9b06      	ldr	r3, [sp, #24]
 800ff46:	2b7a      	cmp	r3, #122	; 0x7a
 800ff48:	d1be      	bne.n	800fec8 <cblas_dsyrk+0x2e0>
 800ff4a:	9b04      	ldr	r3, [sp, #16]
 800ff4c:	2b6f      	cmp	r3, #111	; 0x6f
 800ff4e:	f000 816d 	beq.w	801022c <cblas_dsyrk+0x644>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 800ff52:	9b04      	ldr	r3, [sp, #16]
 800ff54:	2b70      	cmp	r3, #112	; 0x70
 800ff56:	d1b7      	bne.n	800fec8 <cblas_dsyrk+0x2e0>
    for (i = 0; i < N; i++) {
 800ff58:	9b01      	ldr	r3, [sp, #4]
 800ff5a:	2b00      	cmp	r3, #0
 800ff5c:	f77f af49 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
 800ff60:	9b02      	ldr	r3, [sp, #8]
 800ff62:	2700      	movs	r7, #0
 800ff64:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 800ff68:	2308      	movs	r3, #8
 800ff6a:	9706      	str	r7, [sp, #24]
 800ff6c:	9708      	str	r7, [sp, #32]
 800ff6e:	9304      	str	r3, [sp, #16]
 800ff70:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 800ff74:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800ff78:	9302      	str	r3, [sp, #8]
        BASE temp = 0.0;
 800ff7a:	2600      	movs	r6, #0
        for (k = 0; k < K; k++) {
 800ff7c:	f1b8 0f00 	cmp.w	r8, #0
        BASE temp = 0.0;
 800ff80:	f04f 0400 	mov.w	r4, #0
 800ff84:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800ff88:	dd1a      	ble.n	800ffc0 <cblas_dsyrk+0x3d8>
 800ff8a:	9b03      	ldr	r3, [sp, #12]
 800ff8c:	f04f 0b00 	mov.w	fp, #0
 800ff90:	eba3 0a07 	sub.w	sl, r3, r7
          temp += A[k * lda + i] * A[k * lda + j];
 800ff94:	eb0a 0307 	add.w	r3, sl, r7
 800ff98:	4433      	add	r3, r6
 800ff9a:	e9d3 0100 	ldrd	r0, r1, [r3]
 800ff9e:	e9da 2300 	ldrd	r2, r3, [sl]
 800ffa2:	f018 fde1 	bl	8028b68 <__aeabi_dmul>
 800ffa6:	4602      	mov	r2, r0
 800ffa8:	460b      	mov	r3, r1
 800ffaa:	4620      	mov	r0, r4
 800ffac:	4629      	mov	r1, r5
 800ffae:	f018 fc25 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 800ffb2:	f10b 0b01 	add.w	fp, fp, #1
 800ffb6:	45d8      	cmp	r8, fp
          temp += A[k * lda + i] * A[k * lda + j];
 800ffb8:	4604      	mov	r4, r0
 800ffba:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800ffbc:	44ca      	add	sl, r9
 800ffbe:	d1e9      	bne.n	800ff94 <cblas_dsyrk+0x3ac>
        C[i * ldc + j] += alpha * temp;
 800ffc0:	9b02      	ldr	r3, [sp, #8]
 800ffc2:	4620      	mov	r0, r4
 800ffc4:	4629      	mov	r1, r5
 800ffc6:	e9d3 4500 	ldrd	r4, r5, [r3]
 800ffca:	ec53 2b18 	vmov	r2, r3, d8
 800ffce:	f018 fdcb 	bl	8028b68 <__aeabi_dmul>
 800ffd2:	462b      	mov	r3, r5
 800ffd4:	4622      	mov	r2, r4
 800ffd6:	f018 fc11 	bl	80287fc <__adddf3>
 800ffda:	9b02      	ldr	r3, [sp, #8]
 800ffdc:	e8e3 0102 	strd	r0, r1, [r3], #8
 800ffe0:	9302      	str	r3, [sp, #8]
      for (j = 0; j <= i; j++) {
 800ffe2:	9b04      	ldr	r3, [sp, #16]
 800ffe4:	3608      	adds	r6, #8
 800ffe6:	42b3      	cmp	r3, r6
 800ffe8:	d1c8      	bne.n	800ff7c <cblas_dsyrk+0x394>
    for (i = 0; i < N; i++) {
 800ffea:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 800ffee:	440a      	add	r2, r1
 800fff0:	9206      	str	r2, [sp, #24]
 800fff2:	9a04      	ldr	r2, [sp, #16]
 800fff4:	9b08      	ldr	r3, [sp, #32]
 800fff6:	3208      	adds	r2, #8
 800fff8:	9204      	str	r2, [sp, #16]
 800fffa:	9a01      	ldr	r2, [sp, #4]
 800fffc:	3301      	adds	r3, #1
 800fffe:	429a      	cmp	r2, r3
 8010000:	9308      	str	r3, [sp, #32]
 8010002:	f1a7 0708 	sub.w	r7, r7, #8
 8010006:	d1b3      	bne.n	800ff70 <cblas_dsyrk+0x388>
 8010008:	e6f3      	b.n	800fdf2 <cblas_dsyrk+0x20a>
  } else if (beta != 1.0) {
 801000a:	4bba      	ldr	r3, [pc, #744]	; (80102f4 <cblas_dsyrk+0x70c>)
 801000c:	2200      	movs	r2, #0
 801000e:	4630      	mov	r0, r6
 8010010:	4639      	mov	r1, r7
 8010012:	f019 f811 	bl	8029038 <__aeabi_dcmpeq>
 8010016:	2800      	cmp	r0, #0
 8010018:	f040 80a9 	bne.w	801016e <cblas_dsyrk+0x586>
      for (i = 0; i < N; i++) {
 801001c:	9b01      	ldr	r3, [sp, #4]
 801001e:	2b00      	cmp	r3, #0
 8010020:	f77f aee7 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
      trans = CblasTrans;
 8010024:	2370      	movs	r3, #112	; 0x70
 8010026:	9304      	str	r3, [sp, #16]
 8010028:	e0cb      	b.n	80101c2 <cblas_dsyrk+0x5da>
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 801002a:	200b      	movs	r0, #11
 801002c:	e62f      	b.n	800fc8e <cblas_dsyrk+0xa6>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 801002e:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 8010030:	4630      	mov	r0, r6
 8010032:	f04f 0300 	mov.w	r3, #0
 8010036:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 8010038:	f240 8086 	bls.w	8010148 <cblas_dsyrk+0x560>
  if (beta == 0.0) {
 801003c:	f018 fffc 	bl	8029038 <__aeabi_dcmpeq>
 8010040:	2800      	cmp	r0, #0
 8010042:	f000 809e 	beq.w	8010182 <cblas_dsyrk+0x59a>
      for (i = 0; i < N; i++) {
 8010046:	9b01      	ldr	r3, [sp, #4]
 8010048:	2b00      	cmp	r3, #0
 801004a:	f340 80dc 	ble.w	8010206 <cblas_dsyrk+0x61e>
      trans = CblasTrans;
 801004e:	2370      	movs	r3, #112	; 0x70
 8010050:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8010052:	237a      	movs	r3, #122	; 0x7a
 8010054:	9306      	str	r3, [sp, #24]
 8010056:	e750      	b.n	800fefa <cblas_dsyrk+0x312>
  if (beta == 0.0) {
 8010058:	f018 ffee 	bl	8029038 <__aeabi_dcmpeq>
 801005c:	b138      	cbz	r0, 801006e <cblas_dsyrk+0x486>
      for (i = 0; i < N; i++) {
 801005e:	9b01      	ldr	r3, [sp, #4]
 8010060:	2b00      	cmp	r3, #0
 8010062:	dd0d      	ble.n	8010080 <cblas_dsyrk+0x498>
      trans = CblasNoTrans;
 8010064:	236f      	movs	r3, #111	; 0x6f
 8010066:	9304      	str	r3, [sp, #16]
 8010068:	e642      	b.n	800fcf0 <cblas_dsyrk+0x108>
 801006a:	4643      	mov	r3, r8
 801006c:	e5ff      	b.n	800fc6e <cblas_dsyrk+0x86>
  } else if (beta != 1.0) {
 801006e:	4ba1      	ldr	r3, [pc, #644]	; (80102f4 <cblas_dsyrk+0x70c>)
 8010070:	2200      	movs	r2, #0
 8010072:	4630      	mov	r0, r6
 8010074:	4639      	mov	r1, r7
 8010076:	f018 ffdf 	bl	8029038 <__aeabi_dcmpeq>
 801007a:	2800      	cmp	r0, #0
 801007c:	f000 809b 	beq.w	80101b6 <cblas_dsyrk+0x5ce>
  if (alpha == 0.0)
 8010080:	ec51 0b18 	vmov	r0, r1, d8
 8010084:	2200      	movs	r2, #0
 8010086:	2300      	movs	r3, #0
 8010088:	f018 ffd6 	bl	8029038 <__aeabi_dcmpeq>
 801008c:	2800      	cmp	r0, #0
 801008e:	f47f aeb0 	bne.w	800fdf2 <cblas_dsyrk+0x20a>
    for (i = 0; i < N; i++) {
 8010092:	9b01      	ldr	r3, [sp, #4]
 8010094:	2b00      	cmp	r3, #0
 8010096:	f77f aeac 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
 801009a:	9b05      	ldr	r3, [sp, #20]
 801009c:	3301      	adds	r3, #1
 801009e:	00db      	lsls	r3, r3, #3
 80100a0:	930a      	str	r3, [sp, #40]	; 0x28
 80100a2:	9b02      	ldr	r3, [sp, #8]
 80100a4:	00db      	lsls	r3, r3, #3
 80100a6:	9309      	str	r3, [sp, #36]	; 0x24
 80100a8:	9b03      	ldr	r3, [sp, #12]
 80100aa:	e9cd 3804 	strd	r3, r8, [sp, #16]
 80100ae:	2200      	movs	r2, #0
 80100b0:	9208      	str	r2, [sp, #32]
 80100b2:	9206      	str	r2, [sp, #24]
 80100b4:	eb03 06c8 	add.w	r6, r3, r8, lsl #3
        BASE temp = 0.0;
 80100b8:	e9dd 8907 	ldrd	r8, r9, [sp, #28]
 80100bc:	9f06      	ldr	r7, [sp, #24]
        for (k = 0; k < K; k++) {
 80100be:	9b05      	ldr	r3, [sp, #20]
 80100c0:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 80100c2:	f04f 0400 	mov.w	r4, #0
 80100c6:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 80100ca:	dd14      	ble.n	80100f6 <cblas_dsyrk+0x50e>
 80100cc:	9b03      	ldr	r3, [sp, #12]
 80100ce:	f8dd a010 	ldr.w	sl, [sp, #16]
 80100d2:	eb03 0bc9 	add.w	fp, r3, r9, lsl #3
          temp += A[i * lda + k] * A[j * lda + k];
 80100d6:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 80100da:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 80100de:	f018 fd43 	bl	8028b68 <__aeabi_dmul>
 80100e2:	4602      	mov	r2, r0
 80100e4:	460b      	mov	r3, r1
 80100e6:	4620      	mov	r0, r4
 80100e8:	4629      	mov	r1, r5
 80100ea:	f018 fb87 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 80100ee:	4556      	cmp	r6, sl
          temp += A[i * lda + k] * A[j * lda + k];
 80100f0:	4604      	mov	r4, r0
 80100f2:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 80100f4:	d1ef      	bne.n	80100d6 <cblas_dsyrk+0x4ee>
        C[i * ldc + j] += alpha * temp;
 80100f6:	4620      	mov	r0, r4
 80100f8:	4629      	mov	r1, r5
 80100fa:	e9d8 4500 	ldrd	r4, r5, [r8]
 80100fe:	ec53 2b18 	vmov	r2, r3, d8
 8010102:	f018 fd31 	bl	8028b68 <__aeabi_dmul>
 8010106:	462b      	mov	r3, r5
 8010108:	4622      	mov	r2, r4
 801010a:	f018 fb77 	bl	80287fc <__adddf3>
 801010e:	9b02      	ldr	r3, [sp, #8]
 8010110:	4499      	add	r9, r3
      for (j = i; j < N; j++) {
 8010112:	9b01      	ldr	r3, [sp, #4]
 8010114:	3701      	adds	r7, #1
 8010116:	42bb      	cmp	r3, r7
        C[i * ldc + j] += alpha * temp;
 8010118:	e8e8 0102 	strd	r0, r1, [r8], #8
      for (j = i; j < N; j++) {
 801011c:	dccf      	bgt.n	80100be <cblas_dsyrk+0x4d6>
    for (i = 0; i < N; i++) {
 801011e:	9a07      	ldr	r2, [sp, #28]
 8010120:	990a      	ldr	r1, [sp, #40]	; 0x28
 8010122:	9b06      	ldr	r3, [sp, #24]
 8010124:	440a      	add	r2, r1
 8010126:	9207      	str	r2, [sp, #28]
 8010128:	9902      	ldr	r1, [sp, #8]
 801012a:	9a08      	ldr	r2, [sp, #32]
 801012c:	440a      	add	r2, r1
 801012e:	9904      	ldr	r1, [sp, #16]
 8010130:	9208      	str	r2, [sp, #32]
 8010132:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010134:	4608      	mov	r0, r1
 8010136:	4410      	add	r0, r2
 8010138:	4416      	add	r6, r2
 801013a:	9a01      	ldr	r2, [sp, #4]
 801013c:	9004      	str	r0, [sp, #16]
 801013e:	3301      	adds	r3, #1
 8010140:	429a      	cmp	r2, r3
 8010142:	9306      	str	r3, [sp, #24]
 8010144:	d1b8      	bne.n	80100b8 <cblas_dsyrk+0x4d0>
 8010146:	e654      	b.n	800fdf2 <cblas_dsyrk+0x20a>
  if (beta == 0.0) {
 8010148:	f018 ff76 	bl	8029038 <__aeabi_dcmpeq>
 801014c:	bb50      	cbnz	r0, 80101a4 <cblas_dsyrk+0x5bc>
  } else if (beta != 1.0) {
 801014e:	4b69      	ldr	r3, [pc, #420]	; (80102f4 <cblas_dsyrk+0x70c>)
 8010150:	2200      	movs	r2, #0
 8010152:	4630      	mov	r0, r6
 8010154:	4639      	mov	r1, r7
 8010156:	f018 ff6f 	bl	8029038 <__aeabi_dcmpeq>
 801015a:	2800      	cmp	r0, #0
 801015c:	d15d      	bne.n	801021a <cblas_dsyrk+0x632>
      for (i = 0; i < N; i++) {
 801015e:	9b01      	ldr	r3, [sp, #4]
 8010160:	2b00      	cmp	r3, #0
 8010162:	dd5a      	ble.n	801021a <cblas_dsyrk+0x632>
      trans = CblasNoTrans;
 8010164:	236f      	movs	r3, #111	; 0x6f
 8010166:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8010168:	237a      	movs	r3, #122	; 0x7a
 801016a:	9306      	str	r3, [sp, #24]
 801016c:	e67d      	b.n	800fe6a <cblas_dsyrk+0x282>
  if (alpha == 0.0)
 801016e:	ec51 0b18 	vmov	r0, r1, d8
 8010172:	2200      	movs	r2, #0
 8010174:	2300      	movs	r3, #0
 8010176:	f018 ff5f 	bl	8029038 <__aeabi_dcmpeq>
 801017a:	2800      	cmp	r0, #0
 801017c:	f43f addb 	beq.w	800fd36 <cblas_dsyrk+0x14e>
 8010180:	e637      	b.n	800fdf2 <cblas_dsyrk+0x20a>
  } else if (beta != 1.0) {
 8010182:	4b5c      	ldr	r3, [pc, #368]	; (80102f4 <cblas_dsyrk+0x70c>)
 8010184:	2200      	movs	r2, #0
 8010186:	4630      	mov	r0, r6
 8010188:	4639      	mov	r1, r7
 801018a:	f018 ff55 	bl	8029038 <__aeabi_dcmpeq>
 801018e:	2800      	cmp	r0, #0
 8010190:	d139      	bne.n	8010206 <cblas_dsyrk+0x61e>
      for (i = 0; i < N; i++) {
 8010192:	9b01      	ldr	r3, [sp, #4]
 8010194:	2b00      	cmp	r3, #0
 8010196:	f77f ae2c 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
      trans = CblasTrans;
 801019a:	2370      	movs	r3, #112	; 0x70
 801019c:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801019e:	237a      	movs	r3, #122	; 0x7a
 80101a0:	9306      	str	r3, [sp, #24]
 80101a2:	e662      	b.n	800fe6a <cblas_dsyrk+0x282>
      for (i = 0; i < N; i++) {
 80101a4:	9b01      	ldr	r3, [sp, #4]
 80101a6:	2b00      	cmp	r3, #0
 80101a8:	f77f ae23 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
      trans = CblasNoTrans;
 80101ac:	236f      	movs	r3, #111	; 0x6f
 80101ae:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80101b0:	237a      	movs	r3, #122	; 0x7a
 80101b2:	9306      	str	r3, [sp, #24]
 80101b4:	e6a1      	b.n	800fefa <cblas_dsyrk+0x312>
      for (i = 0; i < N; i++) {
 80101b6:	9b01      	ldr	r3, [sp, #4]
 80101b8:	2b00      	cmp	r3, #0
 80101ba:	f77f af61 	ble.w	8010080 <cblas_dsyrk+0x498>
      trans = CblasNoTrans;
 80101be:	236f      	movs	r3, #111	; 0x6f
 80101c0:	9304      	str	r3, [sp, #16]
 80101c2:	9b05      	ldr	r3, [sp, #20]
      for (i = 0; i < N; i++) {
 80101c4:	f8cd 8018 	str.w	r8, [sp, #24]
 80101c8:	f103 0a01 	add.w	sl, r3, #1
 80101cc:	f8dd 901c 	ldr.w	r9, [sp, #28]
 80101d0:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80101d4:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 80101d8:	f04f 0b00 	mov.w	fp, #0
 80101dc:	464d      	mov	r5, r9
 80101de:	465c      	mov	r4, fp
          C[ldc * i + j] *= beta;
 80101e0:	e9d5 0100 	ldrd	r0, r1, [r5]
 80101e4:	4632      	mov	r2, r6
 80101e6:	463b      	mov	r3, r7
 80101e8:	f018 fcbe 	bl	8028b68 <__aeabi_dmul>
        for (j = i; j < N; j++) {
 80101ec:	3401      	adds	r4, #1
 80101ee:	45a0      	cmp	r8, r4
          C[ldc * i + j] *= beta;
 80101f0:	e8e5 0102 	strd	r0, r1, [r5], #8
        for (j = i; j < N; j++) {
 80101f4:	dcf4      	bgt.n	80101e0 <cblas_dsyrk+0x5f8>
      for (i = 0; i < N; i++) {
 80101f6:	f10b 0b01 	add.w	fp, fp, #1
 80101fa:	45d8      	cmp	r8, fp
 80101fc:	44d1      	add	r9, sl
 80101fe:	dced      	bgt.n	80101dc <cblas_dsyrk+0x5f4>
 8010200:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8010204:	e587      	b.n	800fd16 <cblas_dsyrk+0x12e>
  if (alpha == 0.0)
 8010206:	ec51 0b18 	vmov	r0, r1, d8
 801020a:	2200      	movs	r2, #0
 801020c:	2300      	movs	r3, #0
 801020e:	f018 ff13 	bl	8029038 <__aeabi_dcmpeq>
 8010212:	2800      	cmp	r0, #0
 8010214:	f43f aea0 	beq.w	800ff58 <cblas_dsyrk+0x370>
 8010218:	e5eb      	b.n	800fdf2 <cblas_dsyrk+0x20a>
 801021a:	ec51 0b18 	vmov	r0, r1, d8
 801021e:	2200      	movs	r2, #0
 8010220:	2300      	movs	r3, #0
 8010222:	f018 ff09 	bl	8029038 <__aeabi_dcmpeq>
 8010226:	2800      	cmp	r0, #0
 8010228:	f47f ade3 	bne.w	800fdf2 <cblas_dsyrk+0x20a>
    for (i = 0; i < N; i++) {
 801022c:	9b01      	ldr	r3, [sp, #4]
 801022e:	2b00      	cmp	r3, #0
 8010230:	f77f addf 	ble.w	800fdf2 <cblas_dsyrk+0x20a>
 8010234:	9b05      	ldr	r3, [sp, #20]
 8010236:	f8cd 8018 	str.w	r8, [sp, #24]
 801023a:	3301      	adds	r3, #1
 801023c:	00db      	lsls	r3, r3, #3
 801023e:	930b      	str	r3, [sp, #44]	; 0x2c
 8010240:	9b07      	ldr	r3, [sp, #28]
 8010242:	f103 0108 	add.w	r1, r3, #8
 8010246:	9b02      	ldr	r3, [sp, #8]
 8010248:	00db      	lsls	r3, r3, #3
 801024a:	930a      	str	r3, [sp, #40]	; 0x28
 801024c:	9b03      	ldr	r3, [sp, #12]
 801024e:	9304      	str	r3, [sp, #16]
 8010250:	2200      	movs	r2, #0
 8010252:	9208      	str	r2, [sp, #32]
 8010254:	9209      	str	r2, [sp, #36]	; 0x24
 8010256:	eb03 06c8 	add.w	r6, r3, r8, lsl #3
 801025a:	4689      	mov	r9, r1
 801025c:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
        BASE temp = 0.0;
 8010260:	f04f 0800 	mov.w	r8, #0
 8010264:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        for (k = 0; k < K; k++) {
 8010268:	9b06      	ldr	r3, [sp, #24]
 801026a:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 801026c:	f04f 0400 	mov.w	r4, #0
 8010270:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 8010274:	dd14      	ble.n	80102a0 <cblas_dsyrk+0x6b8>
 8010276:	9b03      	ldr	r3, [sp, #12]
 8010278:	f8dd a010 	ldr.w	sl, [sp, #16]
 801027c:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
          temp += A[i * lda + k] * A[j * lda + k];
 8010280:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 8010284:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 8010288:	f018 fc6e 	bl	8028b68 <__aeabi_dmul>
 801028c:	4602      	mov	r2, r0
 801028e:	460b      	mov	r3, r1
 8010290:	4620      	mov	r0, r4
 8010292:	4629      	mov	r1, r5
 8010294:	f018 fab2 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 8010298:	4556      	cmp	r6, sl
          temp += A[i * lda + k] * A[j * lda + k];
 801029a:	4604      	mov	r4, r0
 801029c:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 801029e:	d1ef      	bne.n	8010280 <cblas_dsyrk+0x698>
        C[i * ldc + j] += alpha * temp;
 80102a0:	4620      	mov	r0, r4
 80102a2:	4629      	mov	r1, r5
 80102a4:	e9d7 4500 	ldrd	r4, r5, [r7]
 80102a8:	ec53 2b18 	vmov	r2, r3, d8
 80102ac:	f018 fc5c 	bl	8028b68 <__aeabi_dmul>
 80102b0:	462b      	mov	r3, r5
 80102b2:	4622      	mov	r2, r4
 80102b4:	f018 faa2 	bl	80287fc <__adddf3>
 80102b8:	e8e7 0102 	strd	r0, r1, [r7], #8
      for (j = 0; j <= i; j++) {
 80102bc:	9b02      	ldr	r3, [sp, #8]
 80102be:	45b9      	cmp	r9, r7
 80102c0:	4498      	add	r8, r3
 80102c2:	d1d1      	bne.n	8010268 <cblas_dsyrk+0x680>
    for (i = 0; i < N; i++) {
 80102c4:	9a08      	ldr	r2, [sp, #32]
 80102c6:	9905      	ldr	r1, [sp, #20]
 80102c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80102ca:	440a      	add	r2, r1
 80102cc:	9208      	str	r2, [sp, #32]
 80102ce:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80102d0:	9904      	ldr	r1, [sp, #16]
 80102d2:	4491      	add	r9, r2
 80102d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80102d6:	4608      	mov	r0, r1
 80102d8:	4410      	add	r0, r2
 80102da:	4416      	add	r6, r2
 80102dc:	9a01      	ldr	r2, [sp, #4]
 80102de:	9004      	str	r0, [sp, #16]
 80102e0:	3301      	adds	r3, #1
 80102e2:	429a      	cmp	r2, r3
 80102e4:	9309      	str	r3, [sp, #36]	; 0x24
 80102e6:	d1b9      	bne.n	801025c <cblas_dsyrk+0x674>
 80102e8:	e583      	b.n	800fdf2 <cblas_dsyrk+0x20a>
      for (i = 0; i < N; i++) {
 80102ea:	2b00      	cmp	r3, #0
 80102ec:	f73f ad00 	bgt.w	800fcf0 <cblas_dsyrk+0x108>
 80102f0:	e511      	b.n	800fd16 <cblas_dsyrk+0x12e>
 80102f2:	bf00      	nop
 80102f4:	3ff00000 	.word	0x3ff00000
      for (i = 0; i < N; i++) {
 80102f8:	2b00      	cmp	r3, #0
 80102fa:	f73f af62 	bgt.w	80101c2 <cblas_dsyrk+0x5da>
 80102fe:	e50a      	b.n	800fd16 <cblas_dsyrk+0x12e>

08010300 <cblas_dtrmm>:
cblas_dtrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const double alpha, const double *A, const int lda, double *B,
             const int ldb)
{
 8010300:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010304:	ed2d 8b02 	vpush	{d8}
 8010308:	eeb0 8a40 	vmov.f32	s16, s0
 801030c:	eef0 8a60 	vmov.f32	s17, s1
 8010310:	b091      	sub	sp, #68	; 0x44
 8010312:	461e      	mov	r6, r3
 8010314:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 8010318:	9300      	str	r3, [sp, #0]
 801031a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801031c:	9301      	str	r3, [sp, #4]
 801031e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8010320:	9302      	str	r3, [sp, #8]
 8010322:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010324:	9306      	str	r3, [sp, #24]
 8010326:	e9dd 5320 	ldrd	r5, r3, [sp, #128]	; 0x80
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801032a:	298d      	cmp	r1, #141	; 0x8d
 801032c:	9304      	str	r3, [sp, #16]
 801032e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8010330:	9308      	str	r3, [sp, #32]
 8010332:	460c      	mov	r4, r1
 8010334:	4617      	mov	r7, r2
 8010336:	d062      	beq.n	80103fe <cblas_dtrmm+0xfe>
 8010338:	298e      	cmp	r1, #142	; 0x8e
 801033a:	f000 8294 	beq.w	8010866 <cblas_dtrmm+0x566>
 801033e:	f8dd c008 	ldr.w	ip, [sp, #8]
 8010342:	2302      	movs	r3, #2
 8010344:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 8010348:	2a01      	cmp	r2, #1
 801034a:	9a00      	ldr	r2, [sp, #0]
 801034c:	f1a6 016f 	sub.w	r1, r6, #111	; 0x6f
 8010350:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8010354:	bf88      	it	hi
 8010356:	2303      	movhi	r3, #3
 8010358:	b2d2      	uxtb	r2, r2
 801035a:	2902      	cmp	r1, #2
 801035c:	bf88      	it	hi
 801035e:	2304      	movhi	r3, #4
 8010360:	2a02      	cmp	r2, #2
 8010362:	9a01      	ldr	r2, [sp, #4]
 8010364:	bf28      	it	cs
 8010366:	2305      	movcs	r3, #5
 8010368:	2a00      	cmp	r2, #0
 801036a:	9a02      	ldr	r2, [sp, #8]
 801036c:	bfb8      	it	lt
 801036e:	2306      	movlt	r3, #6
 8010370:	2a00      	cmp	r2, #0
 8010372:	bfb8      	it	lt
 8010374:	2307      	movlt	r3, #7
 8010376:	f1bc 0f01 	cmp.w	ip, #1
 801037a:	bfb8      	it	lt
 801037c:	f04f 0c01 	movlt.w	ip, #1
 8010380:	45ac      	cmp	ip, r5
 8010382:	dd2f      	ble.n	80103e4 <cblas_dtrmm+0xe4>
 8010384:	2865      	cmp	r0, #101	; 0x65
 8010386:	f000 80c8 	beq.w	801051a <cblas_dtrmm+0x21a>
 801038a:	9b01      	ldr	r3, [sp, #4]
 801038c:	9a08      	ldr	r2, [sp, #32]
 801038e:	2b01      	cmp	r3, #1
 8010390:	bfb8      	it	lt
 8010392:	2301      	movlt	r3, #1
 8010394:	4293      	cmp	r3, r2
 8010396:	bfcc      	ite	gt
 8010398:	230c      	movgt	r3, #12
 801039a:	230a      	movle	r3, #10
 801039c:	4ab0      	ldr	r2, [pc, #704]	; (8010660 <cblas_dtrmm+0x360>)
 801039e:	49b1      	ldr	r1, [pc, #708]	; (8010664 <cblas_dtrmm+0x364>)
 80103a0:	4618      	mov	r0, r3
 80103a2:	f018 f9b1 	bl	8028708 <cblas_xerbla>
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 80103a6:	2c8d      	cmp	r4, #141	; 0x8d
 80103a8:	bf0c      	ite	eq
 80103aa:	248e      	moveq	r4, #142	; 0x8e
 80103ac:	248d      	movne	r4, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80103ae:	2f79      	cmp	r7, #121	; 0x79
 80103b0:	bf0c      	ite	eq
 80103b2:	277a      	moveq	r7, #122	; 0x7a
 80103b4:	2779      	movne	r7, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 80103b6:	2e71      	cmp	r6, #113	; 0x71
 80103b8:	bf08      	it	eq
 80103ba:	2670      	moveq	r6, #112	; 0x70
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80103bc:	2c8d      	cmp	r4, #141	; 0x8d
 80103be:	d027      	beq.n	8010410 <cblas_dtrmm+0x110>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 80103c0:	2c8e      	cmp	r4, #142	; 0x8e
 80103c2:	d105      	bne.n	80103d0 <cblas_dtrmm+0xd0>
 80103c4:	2f79      	cmp	r7, #121	; 0x79
 80103c6:	f000 80c2 	beq.w	801054e <cblas_dtrmm+0x24e>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 80103ca:	2f7a      	cmp	r7, #122	; 0x7a
 80103cc:	f000 814e 	beq.w	801066c <cblas_dtrmm+0x36c>
    BLAS_ERROR("unrecognized operation");
 80103d0:	4aa5      	ldr	r2, [pc, #660]	; (8010668 <cblas_dtrmm+0x368>)
 80103d2:	49a4      	ldr	r1, [pc, #656]	; (8010664 <cblas_dtrmm+0x364>)
 80103d4:	2000      	movs	r0, #0
#define BASE double
#include "source_trmm_r.h"
#undef BASE
}
 80103d6:	b011      	add	sp, #68	; 0x44
 80103d8:	ecbd 8b02 	vpop	{d8}
 80103dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80103e0:	f018 b992 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80103e4:	2865      	cmp	r0, #101	; 0x65
 80103e6:	f000 81bf 	beq.w	8010768 <cblas_dtrmm+0x468>
 80103ea:	9a01      	ldr	r2, [sp, #4]
 80103ec:	9908      	ldr	r1, [sp, #32]
 80103ee:	2a01      	cmp	r2, #1
 80103f0:	bfb8      	it	lt
 80103f2:	2201      	movlt	r2, #1
 80103f4:	428a      	cmp	r2, r1
 80103f6:	f340 80a6 	ble.w	8010546 <cblas_dtrmm+0x246>
 80103fa:	230c      	movs	r3, #12
 80103fc:	e7ce      	b.n	801039c <cblas_dtrmm+0x9c>
 80103fe:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8010402:	2b01      	cmp	r3, #1
 8010404:	f8dd c004 	ldr.w	ip, [sp, #4]
 8010408:	bf94      	ite	ls
 801040a:	2300      	movls	r3, #0
 801040c:	2301      	movhi	r3, #1
 801040e:	e799      	b.n	8010344 <cblas_dtrmm+0x44>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8010410:	2f79      	cmp	r7, #121	; 0x79
 8010412:	f000 81b2 	beq.w	801077a <cblas_dtrmm+0x47a>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8010416:	2f7a      	cmp	r7, #122	; 0x7a
 8010418:	d1da      	bne.n	80103d0 <cblas_dtrmm+0xd0>
 801041a:	2e6f      	cmp	r6, #111	; 0x6f
 801041c:	f000 82e1 	beq.w	80109e2 <cblas_dtrmm+0x6e2>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 8010420:	2e70      	cmp	r6, #112	; 0x70
 8010422:	d1d5      	bne.n	80103d0 <cblas_dtrmm+0xd0>
    for (i = 0; i < n1; i++) {
 8010424:	9b02      	ldr	r3, [sp, #8]
 8010426:	2b00      	cmp	r3, #0
 8010428:	f340 8199 	ble.w	801075e <cblas_dtrmm+0x45e>
 801042c:	3501      	adds	r5, #1
 801042e:	00ea      	lsls	r2, r5, #3
 8010430:	f1a2 0a08 	sub.w	sl, r2, #8
 8010434:	920d      	str	r2, [sp, #52]	; 0x34
 8010436:	9a06      	ldr	r2, [sp, #24]
 8010438:	9209      	str	r2, [sp, #36]	; 0x24
 801043a:	eb02 010a 	add.w	r1, r2, sl
 801043e:	9a08      	ldr	r2, [sp, #32]
 8010440:	920b      	str	r2, [sp, #44]	; 0x2c
 8010442:	ea4f 0bc2 	mov.w	fp, r2, lsl #3
 8010446:	2200      	movs	r2, #0
 8010448:	920a      	str	r2, [sp, #40]	; 0x28
 801044a:	2201      	movs	r2, #1
 801044c:	9106      	str	r1, [sp, #24]
 801044e:	9205      	str	r2, [sp, #20]
 8010450:	4699      	mov	r9, r3
      for (j = 0; j < n2; j++) {
 8010452:	9b01      	ldr	r3, [sp, #4]
 8010454:	2b00      	cmp	r3, #0
 8010456:	f340 822a 	ble.w	80108ae <cblas_dtrmm+0x5ae>
 801045a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 801045e:	1a9b      	subs	r3, r3, r2
 8010460:	00db      	lsls	r3, r3, #3
 8010462:	9307      	str	r3, [sp, #28]
 8010464:	9b05      	ldr	r3, [sp, #20]
 8010466:	930c      	str	r3, [sp, #48]	; 0x30
 8010468:	9b04      	ldr	r3, [sp, #16]
 801046a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801046e:	9302      	str	r3, [sp, #8]
 8010470:	2301      	movs	r3, #1
 8010472:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 8010474:	9b00      	ldr	r3, [sp, #0]
 8010476:	2b83      	cmp	r3, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 8010478:	9b02      	ldr	r3, [sp, #8]
        if (nonunit) {
 801047a:	d034      	beq.n	80104e6 <cblas_dtrmm+0x1e6>
        for (k = i + 1; k < n1; k++) {
 801047c:	9e05      	ldr	r6, [sp, #20]
 801047e:	45b1      	cmp	r9, r6
          temp = B[i * ldb + j];
 8010480:	e9d3 4500 	ldrd	r4, r5, [r3]
        for (k = i + 1; k < n1; k++) {
 8010484:	dd3b      	ble.n	80104fe <cblas_dtrmm+0x1fe>
 8010486:	9b07      	ldr	r3, [sp, #28]
 8010488:	9a02      	ldr	r2, [sp, #8]
 801048a:	9f06      	ldr	r7, [sp, #24]
 801048c:	eb03 0802 	add.w	r8, r3, r2
          temp += A[lda * k + i] * B[k * ldb + j];
 8010490:	e9d8 2300 	ldrd	r2, r3, [r8]
 8010494:	e9d7 0100 	ldrd	r0, r1, [r7]
 8010498:	f018 fb66 	bl	8028b68 <__aeabi_dmul>
 801049c:	4602      	mov	r2, r0
 801049e:	460b      	mov	r3, r1
 80104a0:	4620      	mov	r0, r4
 80104a2:	4629      	mov	r1, r5
 80104a4:	f018 f9aa 	bl	80287fc <__adddf3>
        for (k = i + 1; k < n1; k++) {
 80104a8:	3601      	adds	r6, #1
 80104aa:	45b1      	cmp	r9, r6
 80104ac:	44d8      	add	r8, fp
          temp += A[lda * k + i] * B[k * ldb + j];
 80104ae:	4604      	mov	r4, r0
 80104b0:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 80104b2:	4457      	add	r7, sl
 80104b4:	d1ec      	bne.n	8010490 <cblas_dtrmm+0x190>
        B[ldb * i + j] = alpha * temp;
 80104b6:	4602      	mov	r2, r0
 80104b8:	460b      	mov	r3, r1
 80104ba:	ec51 0b18 	vmov	r0, r1, d8
 80104be:	f018 fb53 	bl	8028b68 <__aeabi_dmul>
 80104c2:	9b02      	ldr	r3, [sp, #8]
      for (j = 0; j < n2; j++) {
 80104c4:	9a03      	ldr	r2, [sp, #12]
        B[ldb * i + j] = alpha * temp;
 80104c6:	e9c3 0100 	strd	r0, r1, [r3]
      for (j = 0; j < n2; j++) {
 80104ca:	9b01      	ldr	r3, [sp, #4]
 80104cc:	4293      	cmp	r3, r2
 80104ce:	f340 81f0 	ble.w	80108b2 <cblas_dtrmm+0x5b2>
 80104d2:	9b03      	ldr	r3, [sp, #12]
 80104d4:	3301      	adds	r3, #1
 80104d6:	9303      	str	r3, [sp, #12]
 80104d8:	9b02      	ldr	r3, [sp, #8]
 80104da:	3308      	adds	r3, #8
 80104dc:	9302      	str	r3, [sp, #8]
        if (nonunit) {
 80104de:	9b00      	ldr	r3, [sp, #0]
 80104e0:	2b83      	cmp	r3, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 80104e2:	9b02      	ldr	r3, [sp, #8]
        if (nonunit) {
 80104e4:	d1ca      	bne.n	801047c <cblas_dtrmm+0x17c>
          temp = A[i * lda + i] * B[i * ldb + j];
 80104e6:	9909      	ldr	r1, [sp, #36]	; 0x24
 80104e8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80104ec:	e9d1 0100 	ldrd	r0, r1, [r1]
 80104f0:	f018 fb3a 	bl	8028b68 <__aeabi_dmul>
        for (k = i + 1; k < n1; k++) {
 80104f4:	9e05      	ldr	r6, [sp, #20]
 80104f6:	45b1      	cmp	r9, r6
          temp = A[i * lda + i] * B[i * ldb + j];
 80104f8:	4604      	mov	r4, r0
 80104fa:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 80104fc:	dcc3      	bgt.n	8010486 <cblas_dtrmm+0x186>
        B[ldb * i + j] = alpha * temp;
 80104fe:	ec53 2b18 	vmov	r2, r3, d8
 8010502:	4620      	mov	r0, r4
 8010504:	4629      	mov	r1, r5
 8010506:	f018 fb2f 	bl	8028b68 <__aeabi_dmul>
 801050a:	9b02      	ldr	r3, [sp, #8]
      for (j = 0; j < n2; j++) {
 801050c:	9a03      	ldr	r2, [sp, #12]
        B[ldb * i + j] = alpha * temp;
 801050e:	e9c3 0100 	strd	r0, r1, [r3]
      for (j = 0; j < n2; j++) {
 8010512:	9b01      	ldr	r3, [sp, #4]
 8010514:	4293      	cmp	r3, r2
 8010516:	dcdc      	bgt.n	80104d2 <cblas_dtrmm+0x1d2>
 8010518:	e121      	b.n	801075e <cblas_dtrmm+0x45e>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801051a:	4613      	mov	r3, r2
 801051c:	2a01      	cmp	r2, #1
 801051e:	9a08      	ldr	r2, [sp, #32]
 8010520:	bfb8      	it	lt
 8010522:	2301      	movlt	r3, #1
 8010524:	4293      	cmp	r3, r2
 8010526:	bfcc      	ite	gt
 8010528:	230c      	movgt	r3, #12
 801052a:	230a      	movle	r3, #10
 801052c:	4a4c      	ldr	r2, [pc, #304]	; (8010660 <cblas_dtrmm+0x360>)
 801052e:	494d      	ldr	r1, [pc, #308]	; (8010664 <cblas_dtrmm+0x364>)
 8010530:	4618      	mov	r0, r3
 8010532:	f018 f8e9 	bl	8028708 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 8010536:	2e71      	cmp	r6, #113	; 0x71
 8010538:	9b02      	ldr	r3, [sp, #8]
 801053a:	d100      	bne.n	801053e <cblas_dtrmm+0x23e>
 801053c:	2670      	movs	r6, #112	; 0x70
 801053e:	9a01      	ldr	r2, [sp, #4]
 8010540:	e9cd 3201 	strd	r3, r2, [sp, #4]
 8010544:	e73a      	b.n	80103bc <cblas_dtrmm+0xbc>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8010546:	2b00      	cmp	r3, #0
 8010548:	f43f af2d 	beq.w	80103a6 <cblas_dtrmm+0xa6>
 801054c:	e726      	b.n	801039c <cblas_dtrmm+0x9c>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 801054e:	2e6f      	cmp	r6, #111	; 0x6f
 8010550:	f000 82de 	beq.w	8010b10 <cblas_dtrmm+0x810>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 8010554:	2e70      	cmp	r6, #112	; 0x70
 8010556:	f47f af3b 	bne.w	80103d0 <cblas_dtrmm+0xd0>
    for (i = 0; i < n1; i++) {
 801055a:	9b02      	ldr	r3, [sp, #8]
 801055c:	2b00      	cmp	r3, #0
 801055e:	f340 80fe 	ble.w	801075e <cblas_dtrmm+0x45e>
 8010562:	1c6b      	adds	r3, r5, #1
 8010564:	00ea      	lsls	r2, r5, #3
 8010566:	00db      	lsls	r3, r3, #3
 8010568:	9307      	str	r3, [sp, #28]
 801056a:	f102 0308 	add.w	r3, r2, #8
 801056e:	930a      	str	r3, [sp, #40]	; 0x28
 8010570:	9b01      	ldr	r3, [sp, #4]
 8010572:	9209      	str	r2, [sp, #36]	; 0x24
 8010574:	00da      	lsls	r2, r3, #3
 8010576:	920f      	str	r2, [sp, #60]	; 0x3c
 8010578:	9a06      	ldr	r2, [sp, #24]
 801057a:	2100      	movs	r1, #0
 801057c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8010580:	910b      	str	r1, [sp, #44]	; 0x2c
 8010582:	910c      	str	r1, [sp, #48]	; 0x30
 8010584:	930e      	str	r3, [sp, #56]	; 0x38
      for (j = 0; j < n2; j++) {
 8010586:	9b01      	ldr	r3, [sp, #4]
 8010588:	2b00      	cmp	r3, #0
 801058a:	dd5d      	ble.n	8010648 <cblas_dtrmm+0x348>
 801058c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801058e:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8010592:	00da      	lsls	r2, r3, #3
 8010594:	920d      	str	r2, [sp, #52]	; 0x34
 8010596:	9a04      	ldr	r2, [sp, #16]
 8010598:	eb02 09c3 	add.w	r9, r2, r3, lsl #3
 801059c:	9b06      	ldr	r3, [sp, #24]
 801059e:	9303      	str	r3, [sp, #12]
 80105a0:	f103 0b08 	add.w	fp, r3, #8
        if (nonunit) {
 80105a4:	9b00      	ldr	r3, [sp, #0]
 80105a6:	2b83      	cmp	r3, #131	; 0x83
      for (j = 0; j < n2; j++) {
 80105a8:	f04f 0a00 	mov.w	sl, #0
        if (nonunit) {
 80105ac:	d030      	beq.n	8010610 <cblas_dtrmm+0x310>
        for (k = j + 1; k < n2; k++) {
 80105ae:	9b01      	ldr	r3, [sp, #4]
 80105b0:	f10a 0a01 	add.w	sl, sl, #1
 80105b4:	4553      	cmp	r3, sl
          temp = B[i * ldb + j];
 80105b6:	e9d9 4500 	ldrd	r4, r5, [r9]
        for (k = j + 1; k < n2; k++) {
 80105ba:	d037      	beq.n	801062c <cblas_dtrmm+0x32c>
 80105bc:	f109 0308 	add.w	r3, r9, #8
 80105c0:	9305      	str	r3, [sp, #20]
 80105c2:	461f      	mov	r7, r3
 80105c4:	465e      	mov	r6, fp
          temp += A[lda * j + k] * B[i * ldb + k];
 80105c6:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 80105ca:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 80105ce:	f018 facb 	bl	8028b68 <__aeabi_dmul>
 80105d2:	4602      	mov	r2, r0
 80105d4:	460b      	mov	r3, r1
 80105d6:	4620      	mov	r0, r4
 80105d8:	4629      	mov	r1, r5
 80105da:	f018 f90f 	bl	80287fc <__adddf3>
        for (k = j + 1; k < n2; k++) {
 80105de:	45b0      	cmp	r8, r6
          temp += A[lda * j + k] * B[i * ldb + k];
 80105e0:	4604      	mov	r4, r0
 80105e2:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 80105e4:	d1ef      	bne.n	80105c6 <cblas_dtrmm+0x2c6>
        B[ldb * i + j] = alpha * temp;
 80105e6:	4602      	mov	r2, r0
 80105e8:	460b      	mov	r3, r1
 80105ea:	ec51 0b18 	vmov	r0, r1, d8
 80105ee:	f018 fabb 	bl	8028b68 <__aeabi_dmul>
 80105f2:	9b07      	ldr	r3, [sp, #28]
 80105f4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80105f6:	449b      	add	fp, r3
 80105f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80105fa:	4498      	add	r8, r3
 80105fc:	9b03      	ldr	r3, [sp, #12]
 80105fe:	4413      	add	r3, r2
 8010600:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 8010602:	9b00      	ldr	r3, [sp, #0]
 8010604:	2b83      	cmp	r3, #131	; 0x83
        B[ldb * i + j] = alpha * temp;
 8010606:	e9c9 0100 	strd	r0, r1, [r9]
 801060a:	f8dd 9014 	ldr.w	r9, [sp, #20]
        if (nonunit) {
 801060e:	d1ce      	bne.n	80105ae <cblas_dtrmm+0x2ae>
          temp = A[j * lda + j] * B[i * ldb + j];
 8010610:	9903      	ldr	r1, [sp, #12]
 8010612:	e9d9 2300 	ldrd	r2, r3, [r9]
 8010616:	e9d1 0100 	ldrd	r0, r1, [r1]
 801061a:	f018 faa5 	bl	8028b68 <__aeabi_dmul>
        for (k = j + 1; k < n2; k++) {
 801061e:	9b01      	ldr	r3, [sp, #4]
 8010620:	f10a 0a01 	add.w	sl, sl, #1
 8010624:	4553      	cmp	r3, sl
          temp = A[j * lda + j] * B[i * ldb + j];
 8010626:	4604      	mov	r4, r0
 8010628:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 801062a:	d1c7      	bne.n	80105bc <cblas_dtrmm+0x2bc>
        B[ldb * i + j] = alpha * temp;
 801062c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801062e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010630:	4413      	add	r3, r2
 8010632:	461e      	mov	r6, r3
 8010634:	4620      	mov	r0, r4
 8010636:	ec53 2b18 	vmov	r2, r3, d8
 801063a:	4629      	mov	r1, r5
 801063c:	f018 fa94 	bl	8028b68 <__aeabi_dmul>
 8010640:	9c04      	ldr	r4, [sp, #16]
 8010642:	4426      	add	r6, r4
 8010644:	e946 0102 	strd	r0, r1, [r6, #-8]
    for (i = 0; i < n1; i++) {
 8010648:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801064a:	9908      	ldr	r1, [sp, #32]
 801064c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801064e:	440a      	add	r2, r1
 8010650:	920b      	str	r2, [sp, #44]	; 0x2c
 8010652:	9a02      	ldr	r2, [sp, #8]
 8010654:	3301      	adds	r3, #1
 8010656:	429a      	cmp	r2, r3
 8010658:	930c      	str	r3, [sp, #48]	; 0x30
 801065a:	d194      	bne.n	8010586 <cblas_dtrmm+0x286>
 801065c:	e07f      	b.n	801075e <cblas_dtrmm+0x45e>
 801065e:	bf00      	nop
 8010660:	08031108 	.word	0x08031108
 8010664:	08031280 	.word	0x08031280
 8010668:	080311b8 	.word	0x080311b8
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 801066c:	2e6f      	cmp	r6, #111	; 0x6f
 801066e:	f000 82bd 	beq.w	8010bec <cblas_dtrmm+0x8ec>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 8010672:	2e70      	cmp	r6, #112	; 0x70
 8010674:	f47f aeac 	bne.w	80103d0 <cblas_dtrmm+0xd0>
    for (i = 0; i < n1; i++) {
 8010678:	9b02      	ldr	r3, [sp, #8]
 801067a:	2b00      	cmp	r3, #0
 801067c:	dd6f      	ble.n	801075e <cblas_dtrmm+0x45e>
 801067e:	9901      	ldr	r1, [sp, #4]
 8010680:	1e4b      	subs	r3, r1, #1
 8010682:	fb05 1003 	mla	r0, r5, r3, r1
 8010686:	1c6a      	adds	r2, r5, #1
 8010688:	43ee      	mvns	r6, r5
 801068a:	ebc5 7c45 	rsb	ip, r5, r5, lsl #29
 801068e:	9d08      	ldr	r5, [sp, #32]
 8010690:	00ed      	lsls	r5, r5, #3
 8010692:	00d2      	lsls	r2, r2, #3
 8010694:	460f      	mov	r7, r1
 8010696:	9508      	str	r5, [sp, #32]
 8010698:	9906      	ldr	r1, [sp, #24]
 801069a:	9d06      	ldr	r5, [sp, #24]
 801069c:	f1a2 0408 	sub.w	r4, r2, #8
 80106a0:	fb03 5404 	mla	r4, r3, r4, r5
 80106a4:	3908      	subs	r1, #8
 80106a6:	fb03 5302 	mla	r3, r3, r2, r5
 80106aa:	9309      	str	r3, [sp, #36]	; 0x24
 80106ac:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
 80106b0:	930b      	str	r3, [sp, #44]	; 0x2c
 80106b2:	00f3      	lsls	r3, r6, #3
 80106b4:	9305      	str	r3, [sp, #20]
 80106b6:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 80106ba:	9306      	str	r3, [sp, #24]
 80106bc:	00fb      	lsls	r3, r7, #3
 80106be:	930c      	str	r3, [sp, #48]	; 0x30
 80106c0:	2300      	movs	r3, #0
 80106c2:	940a      	str	r4, [sp, #40]	; 0x28
 80106c4:	9307      	str	r3, [sp, #28]
      for (j = n2; j > 0 && j--;) {
 80106c6:	9b01      	ldr	r3, [sp, #4]
 80106c8:	2b00      	cmp	r3, #0
 80106ca:	dd3e      	ble.n	801074a <cblas_dtrmm+0x44a>
 80106cc:	9a04      	ldr	r2, [sp, #16]
 80106ce:	990c      	ldr	r1, [sp, #48]	; 0x30
 80106d0:	e9dd b80a 	ldrd	fp, r8, [sp, #40]	; 0x28
 80106d4:	eb02 0901 	add.w	r9, r2, r1
 80106d8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80106da:	9203      	str	r2, [sp, #12]
 80106dc:	469a      	mov	sl, r3
        for (k = 0; k < j; k++) {
 80106de:	f1ba 0a01 	subs.w	sl, sl, #1
        BASE temp = 0.0;
 80106e2:	f04f 0400 	mov.w	r4, #0
 80106e6:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < j; k++) {
 80106ea:	d011      	beq.n	8010710 <cblas_dtrmm+0x410>
 80106ec:	9f04      	ldr	r7, [sp, #16]
 80106ee:	465e      	mov	r6, fp
          temp += A[lda * j + k] * B[i * ldb + k];
 80106f0:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 80106f4:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 80106f8:	f018 fa36 	bl	8028b68 <__aeabi_dmul>
 80106fc:	4602      	mov	r2, r0
 80106fe:	460b      	mov	r3, r1
 8010700:	4620      	mov	r0, r4
 8010702:	4629      	mov	r1, r5
 8010704:	f018 f87a 	bl	80287fc <__adddf3>
        for (k = 0; k < j; k++) {
 8010708:	4546      	cmp	r6, r8
          temp += A[lda * j + k] * B[i * ldb + k];
 801070a:	4604      	mov	r4, r0
 801070c:	460d      	mov	r5, r1
        for (k = 0; k < j; k++) {
 801070e:	d1ef      	bne.n	80106f0 <cblas_dtrmm+0x3f0>
        if (nonunit) {
 8010710:	9b00      	ldr	r3, [sp, #0]
 8010712:	2b83      	cmp	r3, #131	; 0x83
 8010714:	f000 80b0 	beq.w	8010878 <cblas_dtrmm+0x578>
          temp += B[i * ldb + j];
 8010718:	e959 2302 	ldrd	r2, r3, [r9, #-8]
 801071c:	4620      	mov	r0, r4
 801071e:	4629      	mov	r1, r5
 8010720:	f018 f86c 	bl	80287fc <__adddf3>
 8010724:	f1a9 0908 	sub.w	r9, r9, #8
        B[ldb * i + j] = alpha * temp;
 8010728:	ec53 2b18 	vmov	r2, r3, d8
 801072c:	f018 fa1c 	bl	8028b68 <__aeabi_dmul>
 8010730:	9a03      	ldr	r2, [sp, #12]
 8010732:	9b05      	ldr	r3, [sp, #20]
 8010734:	4614      	mov	r4, r2
 8010736:	9a06      	ldr	r2, [sp, #24]
 8010738:	441c      	add	r4, r3
 801073a:	e9c9 0100 	strd	r0, r1, [r9]
      for (j = n2; j > 0 && j--;) {
 801073e:	9403      	str	r4, [sp, #12]
 8010740:	4493      	add	fp, r2
 8010742:	4498      	add	r8, r3
 8010744:	f1ba 0f00 	cmp.w	sl, #0
 8010748:	d1c9      	bne.n	80106de <cblas_dtrmm+0x3de>
    for (i = 0; i < n1; i++) {
 801074a:	9a04      	ldr	r2, [sp, #16]
 801074c:	9908      	ldr	r1, [sp, #32]
 801074e:	9b07      	ldr	r3, [sp, #28]
 8010750:	440a      	add	r2, r1
 8010752:	9204      	str	r2, [sp, #16]
 8010754:	9a02      	ldr	r2, [sp, #8]
 8010756:	3301      	adds	r3, #1
 8010758:	429a      	cmp	r2, r3
 801075a:	9307      	str	r3, [sp, #28]
 801075c:	d1b3      	bne.n	80106c6 <cblas_dtrmm+0x3c6>
 801075e:	b011      	add	sp, #68	; 0x44
 8010760:	ecbd 8b02 	vpop	{d8}
 8010764:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8010768:	9a02      	ldr	r2, [sp, #8]
 801076a:	9908      	ldr	r1, [sp, #32]
 801076c:	2a01      	cmp	r2, #1
 801076e:	bfb8      	it	lt
 8010770:	2201      	movlt	r2, #1
 8010772:	428a      	cmp	r2, r1
 8010774:	dd73      	ble.n	801085e <cblas_dtrmm+0x55e>
 8010776:	230c      	movs	r3, #12
 8010778:	e6d8      	b.n	801052c <cblas_dtrmm+0x22c>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 801077a:	2e6f      	cmp	r6, #111	; 0x6f
 801077c:	f000 80b1 	beq.w	80108e2 <cblas_dtrmm+0x5e2>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 8010780:	2e70      	cmp	r6, #112	; 0x70
 8010782:	f47f ae25 	bne.w	80103d0 <cblas_dtrmm+0xd0>
    for (i = n1; i > 0 && i--;) {
 8010786:	9902      	ldr	r1, [sp, #8]
 8010788:	2900      	cmp	r1, #0
 801078a:	dde8      	ble.n	801075e <cblas_dtrmm+0x45e>
 801078c:	1c6b      	adds	r3, r5, #1
 801078e:	43ed      	mvns	r5, r5
 8010790:	00e8      	lsls	r0, r5, #3
 8010792:	9a08      	ldr	r2, [sp, #32]
 8010794:	9008      	str	r0, [sp, #32]
 8010796:	9806      	ldr	r0, [sp, #24]
 8010798:	00db      	lsls	r3, r3, #3
 801079a:	f101 3bff 	add.w	fp, r1, #4294967295
 801079e:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 80107a2:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 80107a6:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 80107aa:	9105      	str	r1, [sp, #20]
 80107ac:	f1a3 0a08 	sub.w	sl, r3, #8
 80107b0:	fb0b 0103 	mla	r1, fp, r3, r0
 80107b4:	00d3      	lsls	r3, r2, #3
 80107b6:	9309      	str	r3, [sp, #36]	; 0x24
 80107b8:	9b04      	ldr	r3, [sp, #16]
 80107ba:	9106      	str	r1, [sp, #24]
 80107bc:	fb0b 3309 	mla	r3, fp, r9, r3
 80107c0:	9307      	str	r3, [sp, #28]
      for (j = 0; j < n2; j++) {
 80107c2:	9b01      	ldr	r3, [sp, #4]
 80107c4:	2b00      	cmp	r3, #0
 80107c6:	dd39      	ble.n	801083c <cblas_dtrmm+0x53c>
 80107c8:	9b07      	ldr	r3, [sp, #28]
 80107ca:	9302      	str	r3, [sp, #8]
 80107cc:	2300      	movs	r3, #0
 80107ce:	9303      	str	r3, [sp, #12]
        BASE temp = 0.0;
 80107d0:	2400      	movs	r4, #0
 80107d2:	2500      	movs	r5, #0
        for (k = 0; k < i; k++) {
 80107d4:	f1bb 0f00 	cmp.w	fp, #0
 80107d8:	d018      	beq.n	801080c <cblas_dtrmm+0x50c>
 80107da:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 80107de:	9f05      	ldr	r7, [sp, #20]
 80107e0:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 80107e4:	2600      	movs	r6, #0
          temp += A[lda * k + i] * B[k * ldb + j];
 80107e6:	e9d8 2300 	ldrd	r2, r3, [r8]
 80107ea:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 80107ee:	f018 f9bb 	bl	8028b68 <__aeabi_dmul>
 80107f2:	4602      	mov	r2, r0
 80107f4:	460b      	mov	r3, r1
 80107f6:	4620      	mov	r0, r4
 80107f8:	4629      	mov	r1, r5
 80107fa:	f017 ffff 	bl	80287fc <__adddf3>
        for (k = 0; k < i; k++) {
 80107fe:	3601      	adds	r6, #1
 8010800:	45b3      	cmp	fp, r6
 8010802:	44c8      	add	r8, r9
          temp += A[lda * k + i] * B[k * ldb + j];
 8010804:	4604      	mov	r4, r0
 8010806:	460d      	mov	r5, r1
        for (k = 0; k < i; k++) {
 8010808:	4457      	add	r7, sl
 801080a:	d1ec      	bne.n	80107e6 <cblas_dtrmm+0x4e6>
        if (nonunit) {
 801080c:	9b00      	ldr	r3, [sp, #0]
 801080e:	2b83      	cmp	r3, #131	; 0x83
 8010810:	d040      	beq.n	8010894 <cblas_dtrmm+0x594>
          temp += B[i * ldb + j];
 8010812:	9b02      	ldr	r3, [sp, #8]
 8010814:	4620      	mov	r0, r4
 8010816:	e9d3 2300 	ldrd	r2, r3, [r3]
 801081a:	4629      	mov	r1, r5
 801081c:	f017 ffee 	bl	80287fc <__adddf3>
        B[ldb * i + j] = alpha * temp;
 8010820:	ec53 2b18 	vmov	r2, r3, d8
 8010824:	f018 f9a0 	bl	8028b68 <__aeabi_dmul>
 8010828:	9a02      	ldr	r2, [sp, #8]
      for (j = 0; j < n2; j++) {
 801082a:	9b03      	ldr	r3, [sp, #12]
        B[ldb * i + j] = alpha * temp;
 801082c:	e8e2 0102 	strd	r0, r1, [r2], #8
 8010830:	9202      	str	r2, [sp, #8]
      for (j = 0; j < n2; j++) {
 8010832:	9a01      	ldr	r2, [sp, #4]
 8010834:	3301      	adds	r3, #1
 8010836:	429a      	cmp	r2, r3
 8010838:	9303      	str	r3, [sp, #12]
 801083a:	d1c9      	bne.n	80107d0 <cblas_dtrmm+0x4d0>
    for (i = n1; i > 0 && i--;) {
 801083c:	9b06      	ldr	r3, [sp, #24]
 801083e:	9a08      	ldr	r2, [sp, #32]
 8010840:	4413      	add	r3, r2
 8010842:	9306      	str	r3, [sp, #24]
 8010844:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010846:	9b07      	ldr	r3, [sp, #28]
 8010848:	4413      	add	r3, r2
 801084a:	9307      	str	r3, [sp, #28]
 801084c:	9b05      	ldr	r3, [sp, #20]
 801084e:	3b08      	subs	r3, #8
 8010850:	9305      	str	r3, [sp, #20]
 8010852:	f1bb 0f00 	cmp.w	fp, #0
 8010856:	d082      	beq.n	801075e <cblas_dtrmm+0x45e>
 8010858:	f10b 3bff 	add.w	fp, fp, #4294967295
 801085c:	e7b1      	b.n	80107c2 <cblas_dtrmm+0x4c2>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801085e:	2b00      	cmp	r3, #0
 8010860:	f43f ae69 	beq.w	8010536 <cblas_dtrmm+0x236>
 8010864:	e662      	b.n	801052c <cblas_dtrmm+0x22c>
 8010866:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 801086a:	2b01      	cmp	r3, #1
 801086c:	f8dd c008 	ldr.w	ip, [sp, #8]
 8010870:	bf94      	ite	ls
 8010872:	2300      	movls	r3, #0
 8010874:	2301      	movhi	r3, #1
 8010876:	e565      	b.n	8010344 <cblas_dtrmm+0x44>
          temp += A[j * lda + j] * B[i * ldb + j];
 8010878:	9903      	ldr	r1, [sp, #12]
 801087a:	e959 2302 	ldrd	r2, r3, [r9, #-8]
 801087e:	e9d1 0100 	ldrd	r0, r1, [r1]
 8010882:	f018 f971 	bl	8028b68 <__aeabi_dmul>
 8010886:	4622      	mov	r2, r4
 8010888:	462b      	mov	r3, r5
 801088a:	f017 ffb7 	bl	80287fc <__adddf3>
 801088e:	f1a9 0908 	sub.w	r9, r9, #8
 8010892:	e749      	b.n	8010728 <cblas_dtrmm+0x428>
          temp += A[i * lda + i] * B[i * ldb + j];
 8010894:	9b02      	ldr	r3, [sp, #8]
 8010896:	9906      	ldr	r1, [sp, #24]
 8010898:	e9d3 2300 	ldrd	r2, r3, [r3]
 801089c:	e9d1 0100 	ldrd	r0, r1, [r1]
 80108a0:	f018 f962 	bl	8028b68 <__aeabi_dmul>
 80108a4:	4622      	mov	r2, r4
 80108a6:	462b      	mov	r3, r5
 80108a8:	f017 ffa8 	bl	80287fc <__adddf3>
 80108ac:	e7b8      	b.n	8010820 <cblas_dtrmm+0x520>
 80108ae:	9b05      	ldr	r3, [sp, #20]
 80108b0:	930c      	str	r3, [sp, #48]	; 0x30
    for (i = 0; i < n1; i++) {
 80108b2:	9b05      	ldr	r3, [sp, #20]
 80108b4:	9a06      	ldr	r2, [sp, #24]
 80108b6:	3301      	adds	r3, #1
 80108b8:	9305      	str	r3, [sp, #20]
 80108ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80108bc:	4611      	mov	r1, r2
 80108be:	4419      	add	r1, r3
 80108c0:	9106      	str	r1, [sp, #24]
 80108c2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80108c4:	9a08      	ldr	r2, [sp, #32]
 80108c6:	4608      	mov	r0, r1
 80108c8:	990a      	ldr	r1, [sp, #40]	; 0x28
 80108ca:	4410      	add	r0, r2
 80108cc:	4411      	add	r1, r2
 80108ce:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80108d0:	900b      	str	r0, [sp, #44]	; 0x2c
 80108d2:	441a      	add	r2, r3
 80108d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80108d6:	910a      	str	r1, [sp, #40]	; 0x28
 80108d8:	4599      	cmp	r9, r3
 80108da:	9209      	str	r2, [sp, #36]	; 0x24
 80108dc:	f73f adb9 	bgt.w	8010452 <cblas_dtrmm+0x152>
 80108e0:	e73d      	b.n	801075e <cblas_dtrmm+0x45e>
    for (i = 0; i < n1; i++) {
 80108e2:	9b02      	ldr	r3, [sp, #8]
 80108e4:	2b00      	cmp	r3, #0
 80108e6:	f77f af3a 	ble.w	801075e <cblas_dtrmm+0x45e>
 80108ea:	3501      	adds	r5, #1
 80108ec:	00ea      	lsls	r2, r5, #3
 80108ee:	920b      	str	r2, [sp, #44]	; 0x2c
 80108f0:	3a08      	subs	r2, #8
 80108f2:	920a      	str	r2, [sp, #40]	; 0x28
 80108f4:	9a06      	ldr	r2, [sp, #24]
 80108f6:	eb02 0bc3 	add.w	fp, r2, r3, lsl #3
 80108fa:	9b08      	ldr	r3, [sp, #32]
 80108fc:	9309      	str	r3, [sp, #36]	; 0x24
 80108fe:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 8010902:	2300      	movs	r3, #0
 8010904:	f102 0108 	add.w	r1, r2, #8
 8010908:	9307      	str	r3, [sp, #28]
 801090a:	2301      	movs	r3, #1
 801090c:	9103      	str	r1, [sp, #12]
 801090e:	9305      	str	r3, [sp, #20]
      for (j = 0; j < n2; j++) {
 8010910:	9b01      	ldr	r3, [sp, #4]
 8010912:	2b00      	cmp	r3, #0
 8010914:	f340 80e5 	ble.w	8010ae2 <cblas_dtrmm+0x7e2>
 8010918:	9a07      	ldr	r2, [sp, #28]
 801091a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801091c:	1a9b      	subs	r3, r3, r2
 801091e:	00db      	lsls	r3, r3, #3
 8010920:	9306      	str	r3, [sp, #24]
 8010922:	9b04      	ldr	r3, [sp, #16]
 8010924:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
        if (nonunit) {
 8010928:	9b00      	ldr	r3, [sp, #0]
 801092a:	2b83      	cmp	r3, #131	; 0x83
      for (j = 0; j < n2; j++) {
 801092c:	f04f 0a01 	mov.w	sl, #1
        if (nonunit) {
 8010930:	d02c      	beq.n	801098c <cblas_dtrmm+0x68c>
        for (k = i + 1; k < n1; k++) {
 8010932:	9b02      	ldr	r3, [sp, #8]
 8010934:	9a05      	ldr	r2, [sp, #20]
 8010936:	4293      	cmp	r3, r2
          temp = B[i * ldb + j];
 8010938:	e9d9 4500 	ldrd	r4, r5, [r9]
        for (k = i + 1; k < n1; k++) {
 801093c:	dd33      	ble.n	80109a6 <cblas_dtrmm+0x6a6>
 801093e:	9b06      	ldr	r3, [sp, #24]
 8010940:	9e03      	ldr	r6, [sp, #12]
 8010942:	eb03 0709 	add.w	r7, r3, r9
          temp += A[lda * i + k] * B[k * ldb + j];
 8010946:	e9d7 2300 	ldrd	r2, r3, [r7]
 801094a:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 801094e:	f018 f90b 	bl	8028b68 <__aeabi_dmul>
 8010952:	4602      	mov	r2, r0
 8010954:	460b      	mov	r3, r1
 8010956:	4620      	mov	r0, r4
 8010958:	4629      	mov	r1, r5
 801095a:	f017 ff4f 	bl	80287fc <__adddf3>
        for (k = i + 1; k < n1; k++) {
 801095e:	45b3      	cmp	fp, r6
 8010960:	4447      	add	r7, r8
          temp += A[lda * i + k] * B[k * ldb + j];
 8010962:	4604      	mov	r4, r0
 8010964:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 8010966:	d1ee      	bne.n	8010946 <cblas_dtrmm+0x646>
        B[ldb * i + j] = alpha * temp;
 8010968:	460b      	mov	r3, r1
 801096a:	4602      	mov	r2, r0
 801096c:	ec51 0b18 	vmov	r0, r1, d8
 8010970:	f018 f8fa 	bl	8028b68 <__aeabi_dmul>
      for (j = 0; j < n2; j++) {
 8010974:	9b01      	ldr	r3, [sp, #4]
 8010976:	4553      	cmp	r3, sl
        B[ldb * i + j] = alpha * temp;
 8010978:	e9c9 0100 	strd	r0, r1, [r9]
      for (j = 0; j < n2; j++) {
 801097c:	dd1f      	ble.n	80109be <cblas_dtrmm+0x6be>
        if (nonunit) {
 801097e:	9b00      	ldr	r3, [sp, #0]
 8010980:	2b83      	cmp	r3, #131	; 0x83
 8010982:	f10a 0a01 	add.w	sl, sl, #1
 8010986:	f109 0908 	add.w	r9, r9, #8
 801098a:	d1d2      	bne.n	8010932 <cblas_dtrmm+0x632>
          temp = A[i * lda + i] * B[i * ldb + j];
 801098c:	9903      	ldr	r1, [sp, #12]
 801098e:	e9d9 2300 	ldrd	r2, r3, [r9]
 8010992:	e951 0102 	ldrd	r0, r1, [r1, #-8]
 8010996:	f018 f8e7 	bl	8028b68 <__aeabi_dmul>
        for (k = i + 1; k < n1; k++) {
 801099a:	9b02      	ldr	r3, [sp, #8]
 801099c:	9a05      	ldr	r2, [sp, #20]
 801099e:	4293      	cmp	r3, r2
          temp = A[i * lda + i] * B[i * ldb + j];
 80109a0:	4604      	mov	r4, r0
 80109a2:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 80109a4:	dccb      	bgt.n	801093e <cblas_dtrmm+0x63e>
        B[ldb * i + j] = alpha * temp;
 80109a6:	ec53 2b18 	vmov	r2, r3, d8
 80109aa:	4620      	mov	r0, r4
 80109ac:	4629      	mov	r1, r5
 80109ae:	f018 f8db 	bl	8028b68 <__aeabi_dmul>
      for (j = 0; j < n2; j++) {
 80109b2:	9b01      	ldr	r3, [sp, #4]
 80109b4:	459a      	cmp	sl, r3
        B[ldb * i + j] = alpha * temp;
 80109b6:	e9c9 0100 	strd	r0, r1, [r9]
      for (j = 0; j < n2; j++) {
 80109ba:	dbe0      	blt.n	801097e <cblas_dtrmm+0x67e>
 80109bc:	e6cf      	b.n	801075e <cblas_dtrmm+0x45e>
    for (i = 0; i < n1; i++) {
 80109be:	9b05      	ldr	r3, [sp, #20]
 80109c0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80109c2:	3301      	adds	r3, #1
 80109c4:	9305      	str	r3, [sp, #20]
 80109c6:	9b03      	ldr	r3, [sp, #12]
 80109c8:	4413      	add	r3, r2
 80109ca:	9303      	str	r3, [sp, #12]
 80109cc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80109ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80109d0:	4611      	mov	r1, r2
 80109d2:	449b      	add	fp, r3
 80109d4:	9a07      	ldr	r2, [sp, #28]
 80109d6:	9b08      	ldr	r3, [sp, #32]
 80109d8:	4419      	add	r1, r3
 80109da:	441a      	add	r2, r3
 80109dc:	9109      	str	r1, [sp, #36]	; 0x24
 80109de:	9207      	str	r2, [sp, #28]
 80109e0:	e796      	b.n	8010910 <cblas_dtrmm+0x610>
    for (i = n1; i > 0 && i--;) {
 80109e2:	9a02      	ldr	r2, [sp, #8]
 80109e4:	2a00      	cmp	r2, #0
 80109e6:	f77f aeba 	ble.w	801075e <cblas_dtrmm+0x45e>
 80109ea:	f102 3bff 	add.w	fp, r2, #4294967295
 80109ee:	9e06      	ldr	r6, [sp, #24]
 80109f0:	f8cd b008 	str.w	fp, [sp, #8]
 80109f4:	fb05 210b 	mla	r1, r5, fp, r2
 80109f8:	1c6b      	adds	r3, r5, #1
 80109fa:	9a08      	ldr	r2, [sp, #32]
 80109fc:	00db      	lsls	r3, r3, #3
 80109fe:	f1a3 0008 	sub.w	r0, r3, #8
 8010a02:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 8010a06:	fb0b 6303 	mla	r3, fp, r3, r6
 8010a0a:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8010a0e:	9305      	str	r3, [sp, #20]
 8010a10:	00d3      	lsls	r3, r2, #3
 8010a12:	9308      	str	r3, [sp, #32]
 8010a14:	9b04      	ldr	r3, [sp, #16]
 8010a16:	43ec      	mvns	r4, r5
 8010a18:	fb0b 3309 	mla	r3, fp, r9, r3
 8010a1c:	ebc5 7545 	rsb	r5, r5, r5, lsl #29
 8010a20:	9306      	str	r3, [sp, #24]
 8010a22:	00e3      	lsls	r3, r4, #3
 8010a24:	f1a6 0808 	sub.w	r8, r6, #8
 8010a28:	fb0b 6000 	mla	r0, fp, r0, r6
 8010a2c:	9307      	str	r3, [sp, #28]
 8010a2e:	00eb      	lsls	r3, r5, #3
 8010a30:	9003      	str	r0, [sp, #12]
 8010a32:	eb08 08c1 	add.w	r8, r8, r1, lsl #3
 8010a36:	9309      	str	r3, [sp, #36]	; 0x24
      for (j = 0; j < n2; j++) {
 8010a38:	9b01      	ldr	r3, [sp, #4]
 8010a3a:	2b00      	cmp	r3, #0
 8010a3c:	dd30      	ble.n	8010aa0 <cblas_dtrmm+0x7a0>
 8010a3e:	f8dd b018 	ldr.w	fp, [sp, #24]
 8010a42:	f04f 0a00 	mov.w	sl, #0
        for (k = 0; k < i; k++) {
 8010a46:	9b02      	ldr	r3, [sp, #8]
        BASE temp = 0.0;
 8010a48:	2400      	movs	r4, #0
 8010a4a:	2500      	movs	r5, #0
        for (k = 0; k < i; k++) {
 8010a4c:	b1a3      	cbz	r3, 8010a78 <cblas_dtrmm+0x778>
 8010a4e:	9b04      	ldr	r3, [sp, #16]
 8010a50:	9e03      	ldr	r6, [sp, #12]
 8010a52:	eb03 07ca 	add.w	r7, r3, sl, lsl #3
          temp += A[lda * i + k] * B[k * ldb + j];
 8010a56:	e9d7 2300 	ldrd	r2, r3, [r7]
 8010a5a:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 8010a5e:	f018 f883 	bl	8028b68 <__aeabi_dmul>
 8010a62:	4602      	mov	r2, r0
 8010a64:	460b      	mov	r3, r1
 8010a66:	4620      	mov	r0, r4
 8010a68:	4629      	mov	r1, r5
 8010a6a:	f017 fec7 	bl	80287fc <__adddf3>
        for (k = 0; k < i; k++) {
 8010a6e:	45b0      	cmp	r8, r6
 8010a70:	444f      	add	r7, r9
          temp += A[lda * i + k] * B[k * ldb + j];
 8010a72:	4604      	mov	r4, r0
 8010a74:	460d      	mov	r5, r1
        for (k = 0; k < i; k++) {
 8010a76:	d1ee      	bne.n	8010a56 <cblas_dtrmm+0x756>
        if (nonunit) {
 8010a78:	9b00      	ldr	r3, [sp, #0]
 8010a7a:	2b83      	cmp	r3, #131	; 0x83
 8010a7c:	d025      	beq.n	8010aca <cblas_dtrmm+0x7ca>
          temp += B[i * ldb + j];
 8010a7e:	e9db 2300 	ldrd	r2, r3, [fp]
 8010a82:	4620      	mov	r0, r4
 8010a84:	4629      	mov	r1, r5
 8010a86:	f017 feb9 	bl	80287fc <__adddf3>
        B[ldb * i + j] = alpha * temp;
 8010a8a:	ec53 2b18 	vmov	r2, r3, d8
 8010a8e:	f018 f86b 	bl	8028b68 <__aeabi_dmul>
      for (j = 0; j < n2; j++) {
 8010a92:	9b01      	ldr	r3, [sp, #4]
 8010a94:	f10a 0a01 	add.w	sl, sl, #1
 8010a98:	4553      	cmp	r3, sl
        B[ldb * i + j] = alpha * temp;
 8010a9a:	e8eb 0102 	strd	r0, r1, [fp], #8
      for (j = 0; j < n2; j++) {
 8010a9e:	d1d2      	bne.n	8010a46 <cblas_dtrmm+0x746>
    for (i = n1; i > 0 && i--;) {
 8010aa0:	9a05      	ldr	r2, [sp, #20]
 8010aa2:	9b07      	ldr	r3, [sp, #28]
 8010aa4:	4611      	mov	r1, r2
 8010aa6:	4419      	add	r1, r3
 8010aa8:	9a06      	ldr	r2, [sp, #24]
 8010aaa:	9105      	str	r1, [sp, #20]
 8010aac:	9908      	ldr	r1, [sp, #32]
 8010aae:	440a      	add	r2, r1
 8010ab0:	9206      	str	r2, [sp, #24]
 8010ab2:	9909      	ldr	r1, [sp, #36]	; 0x24
 8010ab4:	9a03      	ldr	r2, [sp, #12]
 8010ab6:	4498      	add	r8, r3
 8010ab8:	9b02      	ldr	r3, [sp, #8]
 8010aba:	440a      	add	r2, r1
 8010abc:	9203      	str	r2, [sp, #12]
 8010abe:	2b00      	cmp	r3, #0
 8010ac0:	f43f ae4d 	beq.w	801075e <cblas_dtrmm+0x45e>
 8010ac4:	3b01      	subs	r3, #1
 8010ac6:	9302      	str	r3, [sp, #8]
 8010ac8:	e7b6      	b.n	8010a38 <cblas_dtrmm+0x738>
          temp += A[i * lda + i] * B[i * ldb + j];
 8010aca:	9905      	ldr	r1, [sp, #20]
 8010acc:	e9db 2300 	ldrd	r2, r3, [fp]
 8010ad0:	e9d1 0100 	ldrd	r0, r1, [r1]
 8010ad4:	f018 f848 	bl	8028b68 <__aeabi_dmul>
 8010ad8:	4622      	mov	r2, r4
 8010ada:	462b      	mov	r3, r5
 8010adc:	f017 fe8e 	bl	80287fc <__adddf3>
 8010ae0:	e7d3      	b.n	8010a8a <cblas_dtrmm+0x78a>
 8010ae2:	9a03      	ldr	r2, [sp, #12]
 8010ae4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8010ae6:	9c05      	ldr	r4, [sp, #20]
 8010ae8:	440a      	add	r2, r1
 8010aea:	9203      	str	r2, [sp, #12]
 8010aec:	9909      	ldr	r1, [sp, #36]	; 0x24
 8010aee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010af0:	4608      	mov	r0, r1
 8010af2:	4493      	add	fp, r2
 8010af4:	9907      	ldr	r1, [sp, #28]
 8010af6:	9a08      	ldr	r2, [sp, #32]
 8010af8:	4410      	add	r0, r2
 8010afa:	4411      	add	r1, r2
    for (i = 0; i < n1; i++) {
 8010afc:	9a02      	ldr	r2, [sp, #8]
 8010afe:	9009      	str	r0, [sp, #36]	; 0x24
 8010b00:	4623      	mov	r3, r4
 8010b02:	3301      	adds	r3, #1
 8010b04:	42a2      	cmp	r2, r4
 8010b06:	9107      	str	r1, [sp, #28]
 8010b08:	9305      	str	r3, [sp, #20]
 8010b0a:	f73f af01 	bgt.w	8010910 <cblas_dtrmm+0x610>
 8010b0e:	e626      	b.n	801075e <cblas_dtrmm+0x45e>
    for (i = 0; i < n1; i++) {
 8010b10:	9b02      	ldr	r3, [sp, #8]
 8010b12:	2b00      	cmp	r3, #0
 8010b14:	f77f ae23 	ble.w	801075e <cblas_dtrmm+0x45e>
 8010b18:	9908      	ldr	r1, [sp, #32]
 8010b1a:	9b01      	ldr	r3, [sp, #4]
 8010b1c:	00c9      	lsls	r1, r1, #3
 8010b1e:	f105 0901 	add.w	r9, r5, #1
 8010b22:	9107      	str	r1, [sp, #28]
 8010b24:	43ed      	mvns	r5, r5
 8010b26:	9904      	ldr	r1, [sp, #16]
 8010b28:	9103      	str	r1, [sp, #12]
 8010b2a:	00e9      	lsls	r1, r5, #3
 8010b2c:	1e5a      	subs	r2, r3, #1
 8010b2e:	9104      	str	r1, [sp, #16]
 8010b30:	00db      	lsls	r3, r3, #3
 8010b32:	9906      	ldr	r1, [sp, #24]
 8010b34:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010b38:	3b08      	subs	r3, #8
 8010b3a:	fb09 1202 	mla	r2, r9, r2, r1
 8010b3e:	9309      	str	r3, [sp, #36]	; 0x24
 8010b40:	2300      	movs	r3, #0
 8010b42:	9208      	str	r2, [sp, #32]
 8010b44:	f1a9 0908 	sub.w	r9, r9, #8
 8010b48:	9305      	str	r3, [sp, #20]
      for (j = n2; j > 0 && j--;) {
 8010b4a:	9e01      	ldr	r6, [sp, #4]
 8010b4c:	2e00      	cmp	r6, #0
 8010b4e:	dd37      	ble.n	8010bc0 <cblas_dtrmm+0x8c0>
 8010b50:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010b52:	9a03      	ldr	r2, [sp, #12]
 8010b54:	f8dd b020 	ldr.w	fp, [sp, #32]
 8010b58:	eb03 0802 	add.w	r8, r3, r2
        for (k = 0; k < j; k++) {
 8010b5c:	f106 3aff 	add.w	sl, r6, #4294967295
 8010b60:	f1ba 0f00 	cmp.w	sl, #0
        BASE temp = 0.0;
 8010b64:	f04f 0400 	mov.w	r4, #0
 8010b68:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < j; k++) {
 8010b6c:	dd14      	ble.n	8010b98 <cblas_dtrmm+0x898>
 8010b6e:	9b06      	ldr	r3, [sp, #24]
 8010b70:	9f03      	ldr	r7, [sp, #12]
 8010b72:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
          temp += A[lda * k + j] * B[i * ldb + k];
 8010b76:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 8010b7a:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 8010b7e:	f017 fff3 	bl	8028b68 <__aeabi_dmul>
 8010b82:	4602      	mov	r2, r0
 8010b84:	460b      	mov	r3, r1
 8010b86:	4620      	mov	r0, r4
 8010b88:	4629      	mov	r1, r5
 8010b8a:	f017 fe37 	bl	80287fc <__adddf3>
        for (k = 0; k < j; k++) {
 8010b8e:	4547      	cmp	r7, r8
 8010b90:	444e      	add	r6, r9
          temp += A[lda * k + j] * B[i * ldb + k];
 8010b92:	4604      	mov	r4, r0
 8010b94:	460d      	mov	r5, r1
        for (k = 0; k < j; k++) {
 8010b96:	d1ee      	bne.n	8010b76 <cblas_dtrmm+0x876>
        if (nonunit) {
 8010b98:	9b00      	ldr	r3, [sp, #0]
 8010b9a:	2b83      	cmp	r3, #131	; 0x83
 8010b9c:	d01b      	beq.n	8010bd6 <cblas_dtrmm+0x8d6>
          temp += B[i * ldb + j];
 8010b9e:	e9d8 2300 	ldrd	r2, r3, [r8]
 8010ba2:	4620      	mov	r0, r4
 8010ba4:	4629      	mov	r1, r5
 8010ba6:	f017 fe29 	bl	80287fc <__adddf3>
        B[ldb * i + j] = alpha * temp;
 8010baa:	ec53 2b18 	vmov	r2, r3, d8
 8010bae:	f017 ffdb 	bl	8028b68 <__aeabi_dmul>
 8010bb2:	9b04      	ldr	r3, [sp, #16]
      for (j = n2; j > 0 && j--;) {
 8010bb4:	4656      	mov	r6, sl
        B[ldb * i + j] = alpha * temp;
 8010bb6:	e868 0102 	strd	r0, r1, [r8], #-8
      for (j = n2; j > 0 && j--;) {
 8010bba:	449b      	add	fp, r3
 8010bbc:	2e00      	cmp	r6, #0
 8010bbe:	d1cd      	bne.n	8010b5c <cblas_dtrmm+0x85c>
    for (i = 0; i < n1; i++) {
 8010bc0:	9a03      	ldr	r2, [sp, #12]
 8010bc2:	9907      	ldr	r1, [sp, #28]
 8010bc4:	9b05      	ldr	r3, [sp, #20]
 8010bc6:	440a      	add	r2, r1
 8010bc8:	9203      	str	r2, [sp, #12]
 8010bca:	9a02      	ldr	r2, [sp, #8]
 8010bcc:	3301      	adds	r3, #1
 8010bce:	429a      	cmp	r2, r3
 8010bd0:	9305      	str	r3, [sp, #20]
 8010bd2:	d1ba      	bne.n	8010b4a <cblas_dtrmm+0x84a>
 8010bd4:	e5c3      	b.n	801075e <cblas_dtrmm+0x45e>
          temp += A[j * lda + j] * B[i * ldb + j];
 8010bd6:	e9d8 2300 	ldrd	r2, r3, [r8]
 8010bda:	e9db 0100 	ldrd	r0, r1, [fp]
 8010bde:	f017 ffc3 	bl	8028b68 <__aeabi_dmul>
 8010be2:	4622      	mov	r2, r4
 8010be4:	462b      	mov	r3, r5
 8010be6:	f017 fe09 	bl	80287fc <__adddf3>
 8010bea:	e7de      	b.n	8010baa <cblas_dtrmm+0x8aa>
    for (i = 0; i < n1; i++) {
 8010bec:	9b02      	ldr	r3, [sp, #8]
 8010bee:	2b00      	cmp	r3, #0
 8010bf0:	f77f adb5 	ble.w	801075e <cblas_dtrmm+0x45e>
 8010bf4:	1c6b      	adds	r3, r5, #1
 8010bf6:	00db      	lsls	r3, r3, #3
 8010bf8:	9309      	str	r3, [sp, #36]	; 0x24
 8010bfa:	9b06      	ldr	r3, [sp, #24]
 8010bfc:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
 8010c00:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 8010c04:	930e      	str	r3, [sp, #56]	; 0x38
 8010c06:	f10a 0308 	add.w	r3, sl, #8
 8010c0a:	930a      	str	r3, [sp, #40]	; 0x28
 8010c0c:	9b08      	ldr	r3, [sp, #32]
 8010c0e:	2200      	movs	r2, #0
 8010c10:	00db      	lsls	r3, r3, #3
 8010c12:	920b      	str	r2, [sp, #44]	; 0x2c
 8010c14:	920c      	str	r2, [sp, #48]	; 0x30
 8010c16:	930d      	str	r3, [sp, #52]	; 0x34
 8010c18:	9a01      	ldr	r2, [sp, #4]
 8010c1a:	9b04      	ldr	r3, [sp, #16]
 8010c1c:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
      for (j = 0; j < n2; j++) {
 8010c20:	9b01      	ldr	r3, [sp, #4]
 8010c22:	2b00      	cmp	r3, #0
 8010c24:	dd54      	ble.n	8010cd0 <cblas_dtrmm+0x9d0>
 8010c26:	9b04      	ldr	r3, [sp, #16]
 8010c28:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8010c2a:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 8010c2e:	9b06      	ldr	r3, [sp, #24]
 8010c30:	9305      	str	r3, [sp, #20]
 8010c32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010c34:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 8010c36:	9b00      	ldr	r3, [sp, #0]
 8010c38:	2b83      	cmp	r3, #131	; 0x83
      for (j = 0; j < n2; j++) {
 8010c3a:	f04f 0900 	mov.w	r9, #0
        if (nonunit) {
 8010c3e:	d031      	beq.n	8010ca4 <cblas_dtrmm+0x9a4>
        for (k = j + 1; k < n2; k++) {
 8010c40:	9b01      	ldr	r3, [sp, #4]
 8010c42:	f109 0901 	add.w	r9, r9, #1
 8010c46:	454b      	cmp	r3, r9
          temp = B[i * ldb + j];
 8010c48:	e9d8 4500 	ldrd	r4, r5, [r8]
        for (k = j + 1; k < n2; k++) {
 8010c4c:	d038      	beq.n	8010cc0 <cblas_dtrmm+0x9c0>
 8010c4e:	f108 0308 	add.w	r3, r8, #8
 8010c52:	9e03      	ldr	r6, [sp, #12]
 8010c54:	9307      	str	r3, [sp, #28]
 8010c56:	461f      	mov	r7, r3
          temp += A[lda * k + j] * B[i * ldb + k];
 8010c58:	e9d6 2300 	ldrd	r2, r3, [r6]
 8010c5c:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 8010c60:	f017 ff82 	bl	8028b68 <__aeabi_dmul>
 8010c64:	4602      	mov	r2, r0
 8010c66:	460b      	mov	r3, r1
 8010c68:	4620      	mov	r0, r4
 8010c6a:	4629      	mov	r1, r5
 8010c6c:	f017 fdc6 	bl	80287fc <__adddf3>
        for (k = j + 1; k < n2; k++) {
 8010c70:	455f      	cmp	r7, fp
 8010c72:	4456      	add	r6, sl
          temp += A[lda * k + j] * B[i * ldb + k];
 8010c74:	4604      	mov	r4, r0
 8010c76:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 8010c78:	d1ee      	bne.n	8010c58 <cblas_dtrmm+0x958>
        B[ldb * i + j] = alpha * temp;
 8010c7a:	4602      	mov	r2, r0
 8010c7c:	460b      	mov	r3, r1
 8010c7e:	ec51 0b18 	vmov	r0, r1, d8
 8010c82:	f017 ff71 	bl	8028b68 <__aeabi_dmul>
 8010c86:	9b03      	ldr	r3, [sp, #12]
 8010c88:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010c8a:	4413      	add	r3, r2
 8010c8c:	9303      	str	r3, [sp, #12]
 8010c8e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010c90:	9b05      	ldr	r3, [sp, #20]
 8010c92:	4413      	add	r3, r2
 8010c94:	9305      	str	r3, [sp, #20]
        if (nonunit) {
 8010c96:	9b00      	ldr	r3, [sp, #0]
 8010c98:	2b83      	cmp	r3, #131	; 0x83
        B[ldb * i + j] = alpha * temp;
 8010c9a:	e9c8 0100 	strd	r0, r1, [r8]
 8010c9e:	f8dd 801c 	ldr.w	r8, [sp, #28]
        if (nonunit) {
 8010ca2:	d1cd      	bne.n	8010c40 <cblas_dtrmm+0x940>
          temp = A[j * lda + j] * B[i * ldb + j];
 8010ca4:	9905      	ldr	r1, [sp, #20]
 8010ca6:	e9d8 2300 	ldrd	r2, r3, [r8]
 8010caa:	e9d1 0100 	ldrd	r0, r1, [r1]
 8010cae:	f017 ff5b 	bl	8028b68 <__aeabi_dmul>
        for (k = j + 1; k < n2; k++) {
 8010cb2:	9b01      	ldr	r3, [sp, #4]
 8010cb4:	f109 0901 	add.w	r9, r9, #1
 8010cb8:	454b      	cmp	r3, r9
          temp = A[j * lda + j] * B[i * ldb + j];
 8010cba:	4604      	mov	r4, r0
 8010cbc:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 8010cbe:	d1c6      	bne.n	8010c4e <cblas_dtrmm+0x94e>
        B[ldb * i + j] = alpha * temp;
 8010cc0:	ec53 2b18 	vmov	r2, r3, d8
 8010cc4:	4620      	mov	r0, r4
 8010cc6:	4629      	mov	r1, r5
 8010cc8:	f017 ff4e 	bl	8028b68 <__aeabi_dmul>
 8010ccc:	e94b 0102 	strd	r0, r1, [fp, #-8]
    for (i = 0; i < n1; i++) {
 8010cd0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010cd2:	9908      	ldr	r1, [sp, #32]
 8010cd4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010cd6:	4493      	add	fp, r2
 8010cd8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8010cda:	440a      	add	r2, r1
 8010cdc:	920b      	str	r2, [sp, #44]	; 0x2c
 8010cde:	9a02      	ldr	r2, [sp, #8]
 8010ce0:	3301      	adds	r3, #1
 8010ce2:	429a      	cmp	r2, r3
 8010ce4:	930c      	str	r3, [sp, #48]	; 0x30
 8010ce6:	d19b      	bne.n	8010c20 <cblas_dtrmm+0x920>
 8010ce8:	e539      	b.n	801075e <cblas_dtrmm+0x45e>
 8010cea:	bf00      	nop

08010cec <cblas_dtrmv>:
void
cblas_dtrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const double *A, const int lda, double *X,
             const int incX)
{
 8010cec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010cf0:	b08b      	sub	sp, #44	; 0x2c
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8010cf2:	2a71      	cmp	r2, #113	; 0x71
 8010cf4:	9301      	str	r3, [sp, #4]
 8010cf6:	e9dd 5316 	ldrd	r5, r3, [sp, #88]	; 0x58
 8010cfa:	9303      	str	r3, [sp, #12]
 8010cfc:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8010cfe:	9302      	str	r3, [sp, #8]
 8010d00:	e9dd b414 	ldrd	fp, r4, [sp, #80]	; 0x50
 8010d04:	4606      	mov	r6, r0
 8010d06:	460f      	mov	r7, r1
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010d08:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8010d0c:	f000 80bd 	beq.w	8010e8a <cblas_dtrmv+0x19e>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010d10:	2b01      	cmp	r3, #1
 8010d12:	4690      	mov	r8, r2
 8010d14:	d930      	bls.n	8010d78 <cblas_dtrmv+0x8c>
 8010d16:	2002      	movs	r0, #2
 8010d18:	3a6f      	subs	r2, #111	; 0x6f
 8010d1a:	2a02      	cmp	r2, #2
 8010d1c:	bf88      	it	hi
 8010d1e:	2003      	movhi	r0, #3
 8010d20:	9b01      	ldr	r3, [sp, #4]
 8010d22:	337d      	adds	r3, #125	; 0x7d
 8010d24:	b2db      	uxtb	r3, r3
 8010d26:	2b01      	cmp	r3, #1
 8010d28:	d934      	bls.n	8010d94 <cblas_dtrmv+0xa8>
 8010d2a:	f1bb 0f00 	cmp.w	fp, #0
 8010d2e:	db29      	blt.n	8010d84 <cblas_dtrmv+0x98>
 8010d30:	465b      	mov	r3, fp
 8010d32:	2b01      	cmp	r3, #1
 8010d34:	bfb8      	it	lt
 8010d36:	2301      	movlt	r3, #1
 8010d38:	42ab      	cmp	r3, r5
 8010d3a:	f340 80ac 	ble.w	8010e96 <cblas_dtrmv+0x1aa>
 8010d3e:	9b02      	ldr	r3, [sp, #8]
 8010d40:	2b00      	cmp	r3, #0
 8010d42:	bf0c      	ite	eq
 8010d44:	2009      	moveq	r0, #9
 8010d46:	2007      	movne	r0, #7
 8010d48:	4aa9      	ldr	r2, [pc, #676]	; (8010ff0 <cblas_dtrmv+0x304>)
 8010d4a:	49aa      	ldr	r1, [pc, #680]	; (8010ff4 <cblas_dtrmv+0x308>)
 8010d4c:	f017 fcdc 	bl	8028708 <cblas_xerbla>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8010d50:	2e65      	cmp	r6, #101	; 0x65
 8010d52:	d02f      	beq.n	8010db4 <cblas_dtrmv+0xc8>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8010d54:	2e66      	cmp	r6, #102	; 0x66
 8010d56:	d107      	bne.n	8010d68 <cblas_dtrmv+0x7c>
 8010d58:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8010d5c:	f000 8141 	beq.w	8010fe2 <cblas_dtrmv+0x2f6>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8010d60:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8010d64:	f000 809d 	beq.w	8010ea2 <cblas_dtrmv+0x1b6>
    BLAS_ERROR("unrecognized operation");
 8010d68:	4aa3      	ldr	r2, [pc, #652]	; (8010ff8 <cblas_dtrmv+0x30c>)
 8010d6a:	49a2      	ldr	r1, [pc, #648]	; (8010ff4 <cblas_dtrmv+0x308>)
 8010d6c:	2000      	movs	r0, #0
#define BASE double
#include "source_trmv_r.h"
#undef BASE
}
 8010d6e:	b00b      	add	sp, #44	; 0x2c
 8010d70:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010d74:	f017 bcc8 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010d78:	3865      	subs	r0, #101	; 0x65
 8010d7a:	2801      	cmp	r0, #1
 8010d7c:	bf94      	ite	ls
 8010d7e:	2000      	movls	r0, #0
 8010d80:	2001      	movhi	r0, #1
 8010d82:	e7c9      	b.n	8010d18 <cblas_dtrmv+0x2c>
 8010d84:	2d00      	cmp	r5, #0
 8010d86:	ddda      	ble.n	8010d3e <cblas_dtrmv+0x52>
 8010d88:	9b02      	ldr	r3, [sp, #8]
 8010d8a:	2b00      	cmp	r3, #0
 8010d8c:	bf0c      	ite	eq
 8010d8e:	2009      	moveq	r0, #9
 8010d90:	2005      	movne	r0, #5
 8010d92:	e7d9      	b.n	8010d48 <cblas_dtrmv+0x5c>
 8010d94:	f1bb 0f00 	cmp.w	fp, #0
 8010d98:	dbf4      	blt.n	8010d84 <cblas_dtrmv+0x98>
 8010d9a:	465b      	mov	r3, fp
 8010d9c:	2b01      	cmp	r3, #1
 8010d9e:	bfb8      	it	lt
 8010da0:	2301      	movlt	r3, #1
 8010da2:	42ab      	cmp	r3, r5
 8010da4:	dccb      	bgt.n	8010d3e <cblas_dtrmv+0x52>
 8010da6:	9b02      	ldr	r3, [sp, #8]
 8010da8:	2b00      	cmp	r3, #0
 8010daa:	f000 820a 	beq.w	80111c2 <cblas_dtrmv+0x4d6>
 8010dae:	2800      	cmp	r0, #0
 8010db0:	d0ce      	beq.n	8010d50 <cblas_dtrmv+0x64>
 8010db2:	e7c9      	b.n	8010d48 <cblas_dtrmv+0x5c>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8010db4:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8010db8:	f000 8093 	beq.w	8010ee2 <cblas_dtrmv+0x1f6>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8010dbc:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8010dc0:	d1d2      	bne.n	8010d68 <cblas_dtrmv+0x7c>
 8010dc2:	2f79      	cmp	r7, #121	; 0x79
 8010dc4:	f000 8186 	beq.w	80110d4 <cblas_dtrmv+0x3e8>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8010dc8:	2f7a      	cmp	r7, #122	; 0x7a
 8010dca:	d1cd      	bne.n	8010d68 <cblas_dtrmv+0x7c>
    INDEX ix = OFFSET(N, incX);
 8010dcc:	9a02      	ldr	r2, [sp, #8]
 8010dce:	2a00      	cmp	r2, #0
 8010dd0:	bfda      	itte	le
 8010dd2:	f1cb 0301 	rsble	r3, fp, #1
 8010dd6:	4353      	mulle	r3, r2
 8010dd8:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8010dda:	f1bb 0f00 	cmp.w	fp, #0
 8010dde:	dd51      	ble.n	8010e84 <cblas_dtrmv+0x198>
 8010de0:	1c6a      	adds	r2, r5, #1
 8010de2:	00d2      	lsls	r2, r2, #3
 8010de4:	ebc5 7545 	rsb	r5, r5, r5, lsl #29
 8010de8:	f1a2 0a08 	sub.w	sl, r2, #8
 8010dec:	9208      	str	r2, [sp, #32]
 8010dee:	00ea      	lsls	r2, r5, #3
 8010df0:	9209      	str	r2, [sp, #36]	; 0x24
 8010df2:	eb04 020a 	add.w	r2, r4, sl
 8010df6:	9204      	str	r2, [sp, #16]
 8010df8:	9a02      	ldr	r2, [sp, #8]
 8010dfa:	1899      	adds	r1, r3, r2
 8010dfc:	9107      	str	r1, [sp, #28]
 8010dfe:	9903      	ldr	r1, [sp, #12]
 8010e00:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8010e04:	9306      	str	r3, [sp, #24]
 8010e06:	2300      	movs	r3, #0
 8010e08:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 8010e0c:	9305      	str	r3, [sp, #20]
      const INDEX j_min = i + 1;
 8010e0e:	9e05      	ldr	r6, [sp, #20]
 8010e10:	3601      	adds	r6, #1
      for (j = j_min; j < j_max; j++) {
 8010e12:	45b3      	cmp	fp, r6
      const INDEX j_min = i + 1;
 8010e14:	9605      	str	r6, [sp, #20]
      BASE temp = 0.0;
 8010e16:	f04f 0400 	mov.w	r4, #0
 8010e1a:	f04f 0500 	mov.w	r5, #0
      for (j = j_min; j < j_max; j++) {
 8010e1e:	dd17      	ble.n	8010e50 <cblas_dtrmv+0x164>
 8010e20:	9b03      	ldr	r3, [sp, #12]
 8010e22:	9a07      	ldr	r2, [sp, #28]
 8010e24:	9f04      	ldr	r7, [sp, #16]
 8010e26:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
        temp += X[jx] * A[lda * j + i];
 8010e2a:	e9d7 2300 	ldrd	r2, r3, [r7]
 8010e2e:	e9d8 0100 	ldrd	r0, r1, [r8]
 8010e32:	f017 fe99 	bl	8028b68 <__aeabi_dmul>
 8010e36:	4602      	mov	r2, r0
 8010e38:	460b      	mov	r3, r1
 8010e3a:	4620      	mov	r0, r4
 8010e3c:	4629      	mov	r1, r5
 8010e3e:	f017 fcdd 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 8010e42:	3601      	adds	r6, #1
 8010e44:	45b3      	cmp	fp, r6
 8010e46:	4457      	add	r7, sl
        temp += X[jx] * A[lda * j + i];
 8010e48:	4604      	mov	r4, r0
 8010e4a:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 8010e4c:	44c8      	add	r8, r9
 8010e4e:	d1ec      	bne.n	8010e2a <cblas_dtrmv+0x13e>
      if (nonunit) {
 8010e50:	9b01      	ldr	r3, [sp, #4]
 8010e52:	2b83      	cmp	r3, #131	; 0x83
 8010e54:	d02c      	beq.n	8010eb0 <cblas_dtrmv+0x1c4>
        X[ix] += temp;
 8010e56:	4622      	mov	r2, r4
 8010e58:	9c06      	ldr	r4, [sp, #24]
 8010e5a:	462b      	mov	r3, r5
 8010e5c:	e9d4 0100 	ldrd	r0, r1, [r4]
 8010e60:	f017 fccc 	bl	80287fc <__adddf3>
 8010e64:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 8010e68:	9b07      	ldr	r3, [sp, #28]
 8010e6a:	9a02      	ldr	r2, [sp, #8]
 8010e6c:	4413      	add	r3, r2
 8010e6e:	9307      	str	r3, [sp, #28]
 8010e70:	9b06      	ldr	r3, [sp, #24]
 8010e72:	9a08      	ldr	r2, [sp, #32]
 8010e74:	444b      	add	r3, r9
 8010e76:	9306      	str	r3, [sp, #24]
 8010e78:	9b04      	ldr	r3, [sp, #16]
 8010e7a:	4413      	add	r3, r2
 8010e7c:	9304      	str	r3, [sp, #16]
 8010e7e:	9b05      	ldr	r3, [sp, #20]
 8010e80:	459b      	cmp	fp, r3
 8010e82:	d1c4      	bne.n	8010e0e <cblas_dtrmv+0x122>
 8010e84:	b00b      	add	sp, #44	; 0x2c
 8010e86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010e8a:	2b01      	cmp	r3, #1
 8010e8c:	d921      	bls.n	8010ed2 <cblas_dtrmv+0x1e6>
 8010e8e:	f04f 0870 	mov.w	r8, #112	; 0x70
 8010e92:	2002      	movs	r0, #2
 8010e94:	e744      	b.n	8010d20 <cblas_dtrmv+0x34>
 8010e96:	9b02      	ldr	r3, [sp, #8]
 8010e98:	2b00      	cmp	r3, #0
 8010e9a:	bf0c      	ite	eq
 8010e9c:	2009      	moveq	r0, #9
 8010e9e:	2004      	movne	r0, #4
 8010ea0:	e752      	b.n	8010d48 <cblas_dtrmv+0x5c>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8010ea2:	2f7a      	cmp	r7, #122	; 0x7a
 8010ea4:	f000 8116 	beq.w	80110d4 <cblas_dtrmv+0x3e8>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 8010ea8:	2f79      	cmp	r7, #121	; 0x79
 8010eaa:	f47f af5d 	bne.w	8010d68 <cblas_dtrmv+0x7c>
 8010eae:	e78d      	b.n	8010dcc <cblas_dtrmv+0xe0>
        X[ix] = temp + X[ix] * A[lda * i + i];
 8010eb0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010eb2:	9b04      	ldr	r3, [sp, #16]
 8010eb4:	9e06      	ldr	r6, [sp, #24]
 8010eb6:	4413      	add	r3, r2
 8010eb8:	e9d3 0100 	ldrd	r0, r1, [r3]
 8010ebc:	e9d6 2300 	ldrd	r2, r3, [r6]
 8010ec0:	f017 fe52 	bl	8028b68 <__aeabi_dmul>
 8010ec4:	4622      	mov	r2, r4
 8010ec6:	462b      	mov	r3, r5
 8010ec8:	f017 fc98 	bl	80287fc <__adddf3>
 8010ecc:	e9c6 0100 	strd	r0, r1, [r6]
 8010ed0:	e7ca      	b.n	8010e68 <cblas_dtrmv+0x17c>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010ed2:	3865      	subs	r0, #101	; 0x65
 8010ed4:	2801      	cmp	r0, #1
 8010ed6:	bf94      	ite	ls
 8010ed8:	2000      	movls	r0, #0
 8010eda:	2001      	movhi	r0, #1
 8010edc:	f04f 0870 	mov.w	r8, #112	; 0x70
 8010ee0:	e71e      	b.n	8010d20 <cblas_dtrmv+0x34>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8010ee2:	2f79      	cmp	r7, #121	; 0x79
 8010ee4:	f000 808a 	beq.w	8010ffc <cblas_dtrmv+0x310>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 8010ee8:	2f7a      	cmp	r7, #122	; 0x7a
 8010eea:	f47f af3d 	bne.w	8010d68 <cblas_dtrmv+0x7c>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8010eee:	9b02      	ldr	r3, [sp, #8]
 8010ef0:	9f02      	ldr	r7, [sp, #8]
 8010ef2:	2b00      	cmp	r3, #0
 8010ef4:	bfd8      	it	le
 8010ef6:	9b02      	ldrle	r3, [sp, #8]
 8010ef8:	f10b 39ff 	add.w	r9, fp, #4294967295
 8010efc:	bfd6      	itet	le
 8010efe:	425a      	negle	r2, r3
 8010f00:	2200      	movgt	r2, #0
 8010f02:	fb09 f202 	mulle.w	r2, r9, r2
    for (i = N; i > 0 && i--;) {
 8010f06:	f1bb 0f00 	cmp.w	fp, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8010f0a:	fb09 2807 	mla	r8, r9, r7, r2
    for (i = N; i > 0 && i--;) {
 8010f0e:	ddb9      	ble.n	8010e84 <cblas_dtrmv+0x198>
 8010f10:	1c6b      	adds	r3, r5, #1
 8010f12:	00db      	lsls	r3, r3, #3
 8010f14:	9903      	ldr	r1, [sp, #12]
 8010f16:	f1a3 0608 	sub.w	r6, r3, #8
 8010f1a:	ebc7 7047 	rsb	r0, r7, r7, lsl #29
 8010f1e:	fb09 4303 	mla	r3, r9, r3, r4
 8010f22:	ea6f 0c05 	mvn.w	ip, r5
 8010f26:	9303      	str	r3, [sp, #12]
 8010f28:	00c3      	lsls	r3, r0, #3
 8010f2a:	fb09 bb05 	mla	fp, r9, r5, fp
 8010f2e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8010f32:	ebc5 7545 	rsb	r5, r5, r5, lsl #29
 8010f36:	9305      	str	r3, [sp, #20]
 8010f38:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8010f3c:	f1a4 0a08 	sub.w	sl, r4, #8
 8010f40:	9207      	str	r2, [sp, #28]
 8010f42:	9304      	str	r3, [sp, #16]
 8010f44:	fb09 4206 	mla	r2, r9, r6, r4
 8010f48:	00eb      	lsls	r3, r5, #3
 8010f4a:	eb0a 0acb 	add.w	sl, sl, fp, lsl #3
 8010f4e:	eb01 08c8 	add.w	r8, r1, r8, lsl #3
 8010f52:	9202      	str	r2, [sp, #8]
 8010f54:	ea4f 0bc7 	mov.w	fp, r7, lsl #3
 8010f58:	9306      	str	r3, [sp, #24]
      for (j = j_min; j < j_max; j++) {
 8010f5a:	2400      	movs	r4, #0
 8010f5c:	2500      	movs	r5, #0
 8010f5e:	f1b9 0f00 	cmp.w	r9, #0
 8010f62:	d012      	beq.n	8010f8a <cblas_dtrmv+0x29e>
 8010f64:	9f02      	ldr	r7, [sp, #8]
 8010f66:	9e07      	ldr	r6, [sp, #28]
        temp += X[jx] * A[lda * i + j];
 8010f68:	e9d6 2300 	ldrd	r2, r3, [r6]
 8010f6c:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 8010f70:	f017 fdfa 	bl	8028b68 <__aeabi_dmul>
 8010f74:	4602      	mov	r2, r0
 8010f76:	460b      	mov	r3, r1
 8010f78:	4620      	mov	r0, r4
 8010f7a:	4629      	mov	r1, r5
 8010f7c:	f017 fc3e 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 8010f80:	4557      	cmp	r7, sl
 8010f82:	445e      	add	r6, fp
        temp += X[jx] * A[lda * i + j];
 8010f84:	4604      	mov	r4, r0
 8010f86:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 8010f88:	d1ee      	bne.n	8010f68 <cblas_dtrmv+0x27c>
      if (nonunit) {
 8010f8a:	9b01      	ldr	r3, [sp, #4]
 8010f8c:	2b83      	cmp	r3, #131	; 0x83
 8010f8e:	d01a      	beq.n	8010fc6 <cblas_dtrmv+0x2da>
        X[ix] += temp;
 8010f90:	e9d8 0100 	ldrd	r0, r1, [r8]
 8010f94:	4622      	mov	r2, r4
 8010f96:	462b      	mov	r3, r5
 8010f98:	f017 fc30 	bl	80287fc <__adddf3>
 8010f9c:	e9c8 0100 	strd	r0, r1, [r8]
    for (i = N; i > 0 && i--;) {
 8010fa0:	9b05      	ldr	r3, [sp, #20]
 8010fa2:	9a03      	ldr	r2, [sp, #12]
 8010fa4:	4498      	add	r8, r3
 8010fa6:	9b04      	ldr	r3, [sp, #16]
 8010fa8:	4611      	mov	r1, r2
 8010faa:	4419      	add	r1, r3
 8010fac:	9a02      	ldr	r2, [sp, #8]
 8010fae:	9103      	str	r1, [sp, #12]
 8010fb0:	9906      	ldr	r1, [sp, #24]
 8010fb2:	440a      	add	r2, r1
 8010fb4:	9202      	str	r2, [sp, #8]
 8010fb6:	449a      	add	sl, r3
 8010fb8:	f1b9 0f00 	cmp.w	r9, #0
 8010fbc:	f43f af62 	beq.w	8010e84 <cblas_dtrmv+0x198>
 8010fc0:	f109 39ff 	add.w	r9, r9, #4294967295
 8010fc4:	e7c9      	b.n	8010f5a <cblas_dtrmv+0x26e>
        X[ix] = temp + X[ix] * A[lda * i + i];
 8010fc6:	9b03      	ldr	r3, [sp, #12]
 8010fc8:	e9d8 0100 	ldrd	r0, r1, [r8]
 8010fcc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010fd0:	f017 fdca 	bl	8028b68 <__aeabi_dmul>
 8010fd4:	4622      	mov	r2, r4
 8010fd6:	462b      	mov	r3, r5
 8010fd8:	f017 fc10 	bl	80287fc <__adddf3>
 8010fdc:	e9c8 0100 	strd	r0, r1, [r8]
 8010fe0:	e7de      	b.n	8010fa0 <cblas_dtrmv+0x2b4>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8010fe2:	2f7a      	cmp	r7, #122	; 0x7a
 8010fe4:	d00a      	beq.n	8010ffc <cblas_dtrmv+0x310>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 8010fe6:	2f79      	cmp	r7, #121	; 0x79
 8010fe8:	f47f aebe 	bne.w	8010d68 <cblas_dtrmv+0x7c>
 8010fec:	e77f      	b.n	8010eee <cblas_dtrmv+0x202>
 8010fee:	bf00      	nop
 8010ff0:	08031108 	.word	0x08031108
 8010ff4:	08031290 	.word	0x08031290
 8010ff8:	080311b8 	.word	0x080311b8
    INDEX ix = OFFSET(N, incX);
 8010ffc:	9a02      	ldr	r2, [sp, #8]
 8010ffe:	2a00      	cmp	r2, #0
 8011000:	bfda      	itte	le
 8011002:	f1cb 0301 	rsble	r3, fp, #1
 8011006:	4353      	mulle	r3, r2
 8011008:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 801100a:	f1bb 0f00 	cmp.w	fp, #0
    INDEX ix = OFFSET(N, incX);
 801100e:	4619      	mov	r1, r3
    for (i = 0; i < N; i++) {
 8011010:	f77f af38 	ble.w	8010e84 <cblas_dtrmv+0x198>
 8011014:	3501      	adds	r5, #1
 8011016:	00eb      	lsls	r3, r5, #3
 8011018:	9308      	str	r3, [sp, #32]
 801101a:	3b08      	subs	r3, #8
 801101c:	9307      	str	r3, [sp, #28]
 801101e:	f104 0308 	add.w	r3, r4, #8
 8011022:	9a03      	ldr	r2, [sp, #12]
 8011024:	9304      	str	r3, [sp, #16]
 8011026:	9b02      	ldr	r3, [sp, #8]
 8011028:	f8cd b014 	str.w	fp, [sp, #20]
 801102c:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8011030:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8011034:	9309      	str	r3, [sp, #36]	; 0x24
 8011036:	2300      	movs	r3, #0
 8011038:	eb04 08cb 	add.w	r8, r4, fp, lsl #3
 801103c:	469a      	mov	sl, r3
 801103e:	468b      	mov	fp, r1
      for (j = j_min; j < j_max; j++) {
 8011040:	9b05      	ldr	r3, [sp, #20]
      const INDEX j_min = i + 1;
 8011042:	f10a 0a01 	add.w	sl, sl, #1
      for (j = j_min; j < j_max; j++) {
 8011046:	4553      	cmp	r3, sl
 8011048:	ea4f 03cb 	mov.w	r3, fp, lsl #3
      BASE temp = 0.0;
 801104c:	f04f 0400 	mov.w	r4, #0
 8011050:	f04f 0500 	mov.w	r5, #0
 8011054:	9306      	str	r3, [sp, #24]
      for (j = j_min; j < j_max; j++) {
 8011056:	dd14      	ble.n	8011082 <cblas_dtrmv+0x396>
 8011058:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801105a:	9e04      	ldr	r6, [sp, #16]
 801105c:	eb03 07cb 	add.w	r7, r3, fp, lsl #3
        temp += X[jx] * A[lda * i + j];
 8011060:	e9d7 2300 	ldrd	r2, r3, [r7]
 8011064:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 8011068:	f017 fd7e 	bl	8028b68 <__aeabi_dmul>
 801106c:	4602      	mov	r2, r0
 801106e:	460b      	mov	r3, r1
 8011070:	4620      	mov	r0, r4
 8011072:	4629      	mov	r1, r5
 8011074:	f017 fbc2 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 8011078:	45b0      	cmp	r8, r6
 801107a:	444f      	add	r7, r9
        temp += X[jx] * A[lda * i + j];
 801107c:	4604      	mov	r4, r0
 801107e:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 8011080:	d1ee      	bne.n	8011060 <cblas_dtrmv+0x374>
      if (nonunit) {
 8011082:	9b01      	ldr	r3, [sp, #4]
 8011084:	9a03      	ldr	r2, [sp, #12]
 8011086:	2b83      	cmp	r3, #131	; 0x83
 8011088:	9b06      	ldr	r3, [sp, #24]
 801108a:	4413      	add	r3, r2
 801108c:	461e      	mov	r6, r3
 801108e:	d013      	beq.n	80110b8 <cblas_dtrmv+0x3cc>
        X[ix] += temp;
 8011090:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011094:	4622      	mov	r2, r4
 8011096:	462b      	mov	r3, r5
 8011098:	f017 fbb0 	bl	80287fc <__adddf3>
 801109c:	e9c6 0100 	strd	r0, r1, [r6]
      ix += incX;
 80110a0:	9b02      	ldr	r3, [sp, #8]
 80110a2:	9a08      	ldr	r2, [sp, #32]
 80110a4:	449b      	add	fp, r3
    for (i = 0; i < N; i++) {
 80110a6:	9b04      	ldr	r3, [sp, #16]
 80110a8:	4413      	add	r3, r2
 80110aa:	9304      	str	r3, [sp, #16]
 80110ac:	9b07      	ldr	r3, [sp, #28]
 80110ae:	4498      	add	r8, r3
 80110b0:	9b05      	ldr	r3, [sp, #20]
 80110b2:	4553      	cmp	r3, sl
 80110b4:	d1c4      	bne.n	8011040 <cblas_dtrmv+0x354>
 80110b6:	e6e5      	b.n	8010e84 <cblas_dtrmv+0x198>
        X[ix] = temp + X[ix] * A[lda * i + i];
 80110b8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80110bc:	9b04      	ldr	r3, [sp, #16]
 80110be:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 80110c2:	f017 fd51 	bl	8028b68 <__aeabi_dmul>
 80110c6:	4622      	mov	r2, r4
 80110c8:	462b      	mov	r3, r5
 80110ca:	f017 fb97 	bl	80287fc <__adddf3>
 80110ce:	e9c6 0100 	strd	r0, r1, [r6]
 80110d2:	e7e5      	b.n	80110a0 <cblas_dtrmv+0x3b4>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80110d4:	9b02      	ldr	r3, [sp, #8]
 80110d6:	9802      	ldr	r0, [sp, #8]
 80110d8:	2b00      	cmp	r3, #0
 80110da:	bfd8      	it	le
 80110dc:	9b02      	ldrle	r3, [sp, #8]
 80110de:	f10b 39ff 	add.w	r9, fp, #4294967295
 80110e2:	bfd6      	itet	le
 80110e4:	425b      	negle	r3, r3
 80110e6:	2300      	movgt	r3, #0
 80110e8:	fb09 f303 	mulle.w	r3, r9, r3
    for (i = N; i > 0 && i--;) {
 80110ec:	f1bb 0f00 	cmp.w	fp, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80110f0:	fb09 3200 	mla	r2, r9, r0, r3
    for (i = N; i > 0 && i--;) {
 80110f4:	f77f aec6 	ble.w	8010e84 <cblas_dtrmv+0x198>
 80110f8:	9e03      	ldr	r6, [sp, #12]
 80110fa:	f105 0a01 	add.w	sl, r5, #1
 80110fe:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8011102:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8011106:	43ed      	mvns	r5, r5
 8011108:	9307      	str	r3, [sp, #28]
 801110a:	fb0a 4309 	mla	r3, sl, r9, r4
 801110e:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8011112:	ebc0 7140 	rsb	r1, r0, r0, lsl #29
 8011116:	9304      	str	r3, [sp, #16]
 8011118:	00eb      	lsls	r3, r5, #3
 801111a:	9202      	str	r2, [sp, #8]
 801111c:	9305      	str	r3, [sp, #20]
 801111e:	eb04 02cb 	add.w	r2, r4, fp, lsl #3
 8011122:	00cb      	lsls	r3, r1, #3
 8011124:	9203      	str	r2, [sp, #12]
 8011126:	f1aa 0a08 	sub.w	sl, sl, #8
 801112a:	9306      	str	r3, [sp, #24]
 801112c:	ea4f 0bc0 	mov.w	fp, r0, lsl #3
      for (j = j_min; j < j_max; j++) {
 8011130:	2400      	movs	r4, #0
 8011132:	2500      	movs	r5, #0
 8011134:	f1b9 0f00 	cmp.w	r9, #0
 8011138:	d016      	beq.n	8011168 <cblas_dtrmv+0x47c>
 801113a:	f8dd 800c 	ldr.w	r8, [sp, #12]
 801113e:	9f07      	ldr	r7, [sp, #28]
 8011140:	2600      	movs	r6, #0
        temp += X[jx] * A[lda * j + i];
 8011142:	e958 2302 	ldrd	r2, r3, [r8, #-8]
 8011146:	e9d7 0100 	ldrd	r0, r1, [r7]
 801114a:	f017 fd0d 	bl	8028b68 <__aeabi_dmul>
 801114e:	4602      	mov	r2, r0
 8011150:	460b      	mov	r3, r1
 8011152:	4620      	mov	r0, r4
 8011154:	4629      	mov	r1, r5
 8011156:	f017 fb51 	bl	80287fc <__adddf3>
      for (j = j_min; j < j_max; j++) {
 801115a:	3601      	adds	r6, #1
 801115c:	45b1      	cmp	r9, r6
 801115e:	44d0      	add	r8, sl
        temp += X[jx] * A[lda * j + i];
 8011160:	4604      	mov	r4, r0
 8011162:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 8011164:	445f      	add	r7, fp
 8011166:	d1ec      	bne.n	8011142 <cblas_dtrmv+0x456>
      if (nonunit) {
 8011168:	9b01      	ldr	r3, [sp, #4]
 801116a:	2b83      	cmp	r3, #131	; 0x83
 801116c:	d01a      	beq.n	80111a4 <cblas_dtrmv+0x4b8>
        X[ix] += temp;
 801116e:	4622      	mov	r2, r4
 8011170:	9c02      	ldr	r4, [sp, #8]
 8011172:	462b      	mov	r3, r5
 8011174:	e9d4 0100 	ldrd	r0, r1, [r4]
 8011178:	f017 fb40 	bl	80287fc <__adddf3>
 801117c:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 8011180:	9b02      	ldr	r3, [sp, #8]
 8011182:	9a06      	ldr	r2, [sp, #24]
 8011184:	4413      	add	r3, r2
 8011186:	9302      	str	r3, [sp, #8]
 8011188:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 801118c:	4413      	add	r3, r2
 801118e:	9304      	str	r3, [sp, #16]
 8011190:	9b03      	ldr	r3, [sp, #12]
 8011192:	3b08      	subs	r3, #8
 8011194:	9303      	str	r3, [sp, #12]
 8011196:	f1b9 0f00 	cmp.w	r9, #0
 801119a:	f43f ae73 	beq.w	8010e84 <cblas_dtrmv+0x198>
 801119e:	f109 39ff 	add.w	r9, r9, #4294967295
 80111a2:	e7c5      	b.n	8011130 <cblas_dtrmv+0x444>
        X[ix] = temp + X[ix] * A[lda * i + i];
 80111a4:	9e02      	ldr	r6, [sp, #8]
 80111a6:	9b04      	ldr	r3, [sp, #16]
 80111a8:	e9d6 0100 	ldrd	r0, r1, [r6]
 80111ac:	e9d3 2300 	ldrd	r2, r3, [r3]
 80111b0:	f017 fcda 	bl	8028b68 <__aeabi_dmul>
 80111b4:	4622      	mov	r2, r4
 80111b6:	462b      	mov	r3, r5
 80111b8:	f017 fb20 	bl	80287fc <__adddf3>
 80111bc:	e9c6 0100 	strd	r0, r1, [r6]
 80111c0:	e7de      	b.n	8011180 <cblas_dtrmv+0x494>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80111c2:	2009      	movs	r0, #9
 80111c4:	e5c0      	b.n	8010d48 <cblas_dtrmv+0x5c>
 80111c6:	bf00      	nop

080111c8 <cblas_dtrsm>:
cblas_dtrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const double alpha, const double *A, const int lda, double *B,
             const int ldb)
{
 80111c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80111cc:	b093      	sub	sp, #76	; 0x4c
 80111ce:	461f      	mov	r7, r3
 80111d0:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 80111d4:	9304      	str	r3, [sp, #16]
 80111d6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 80111d8:	9301      	str	r3, [sp, #4]
 80111da:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80111dc:	9306      	str	r3, [sp, #24]
 80111de:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80111e0:	930c      	str	r3, [sp, #48]	; 0x30
 80111e2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80111e4:	9309      	str	r3, [sp, #36]	; 0x24
 80111e6:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80111e8:	9305      	str	r3, [sp, #20]
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80111ea:	298d      	cmp	r1, #141	; 0x8d
 80111ec:	9b22      	ldr	r3, [sp, #136]	; 0x88
 80111ee:	9303      	str	r3, [sp, #12]
 80111f0:	ec55 4b10 	vmov	r4, r5, d0
 80111f4:	460e      	mov	r6, r1
 80111f6:	4690      	mov	r8, r2
 80111f8:	d066      	beq.n	80112c8 <cblas_dtrsm+0x100>
 80111fa:	298e      	cmp	r1, #142	; 0x8e
 80111fc:	f000 8313 	beq.w	8011826 <cblas_dtrsm+0x65e>
 8011200:	f8dd c018 	ldr.w	ip, [sp, #24]
 8011204:	2302      	movs	r3, #2
 8011206:	f1a8 0279 	sub.w	r2, r8, #121	; 0x79
 801120a:	2a01      	cmp	r2, #1
 801120c:	9a04      	ldr	r2, [sp, #16]
 801120e:	f1a7 016f 	sub.w	r1, r7, #111	; 0x6f
 8011212:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8011216:	bf88      	it	hi
 8011218:	2303      	movhi	r3, #3
 801121a:	b2d2      	uxtb	r2, r2
 801121c:	2902      	cmp	r1, #2
 801121e:	bf88      	it	hi
 8011220:	2304      	movhi	r3, #4
 8011222:	2a02      	cmp	r2, #2
 8011224:	9a01      	ldr	r2, [sp, #4]
 8011226:	bf28      	it	cs
 8011228:	2305      	movcs	r3, #5
 801122a:	2a00      	cmp	r2, #0
 801122c:	9a06      	ldr	r2, [sp, #24]
 801122e:	bfb8      	it	lt
 8011230:	2306      	movlt	r3, #6
 8011232:	2a00      	cmp	r2, #0
 8011234:	bfb8      	it	lt
 8011236:	2307      	movlt	r3, #7
 8011238:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801123a:	f1bc 0f01 	cmp.w	ip, #1
 801123e:	bfb8      	it	lt
 8011240:	f04f 0c01 	movlt.w	ip, #1
 8011244:	4594      	cmp	ip, r2
 8011246:	dd32      	ble.n	80112ae <cblas_dtrsm+0xe6>
 8011248:	2865      	cmp	r0, #101	; 0x65
 801124a:	f000 80f8 	beq.w	801143e <cblas_dtrsm+0x276>
 801124e:	9b01      	ldr	r3, [sp, #4]
 8011250:	9a03      	ldr	r2, [sp, #12]
 8011252:	2b01      	cmp	r3, #1
 8011254:	bfb8      	it	lt
 8011256:	2301      	movlt	r3, #1
 8011258:	4293      	cmp	r3, r2
 801125a:	bfcc      	ite	gt
 801125c:	230c      	movgt	r3, #12
 801125e:	230a      	movle	r3, #10
 8011260:	4a84      	ldr	r2, [pc, #528]	; (8011474 <cblas_dtrsm+0x2ac>)
 8011262:	4985      	ldr	r1, [pc, #532]	; (8011478 <cblas_dtrsm+0x2b0>)
 8011264:	4618      	mov	r0, r3
 8011266:	f017 fa4f 	bl	8028708 <cblas_xerbla>
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 801126a:	2e8d      	cmp	r6, #141	; 0x8d
 801126c:	bf0c      	ite	eq
 801126e:	268e      	moveq	r6, #142	; 0x8e
 8011270:	268d      	movne	r6, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8011272:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8011276:	bf0c      	ite	eq
 8011278:	f04f 087a 	moveq.w	r8, #122	; 0x7a
 801127c:	f04f 0879 	movne.w	r8, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 8011280:	2f71      	cmp	r7, #113	; 0x71
 8011282:	bf08      	it	eq
 8011284:	2770      	moveq	r7, #112	; 0x70
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8011286:	2e8d      	cmp	r6, #141	; 0x8d
 8011288:	d027      	beq.n	80112da <cblas_dtrsm+0x112>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 801128a:	2e8e      	cmp	r6, #142	; 0x8e
 801128c:	d107      	bne.n	801129e <cblas_dtrsm+0xd6>
 801128e:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8011292:	f000 80f7 	beq.w	8011484 <cblas_dtrsm+0x2bc>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8011296:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 801129a:	f000 8188 	beq.w	80115ae <cblas_dtrsm+0x3e6>
    BLAS_ERROR("unrecognized operation");
 801129e:	4a77      	ldr	r2, [pc, #476]	; (801147c <cblas_dtrsm+0x2b4>)
 80112a0:	4975      	ldr	r1, [pc, #468]	; (8011478 <cblas_dtrsm+0x2b0>)
 80112a2:	2000      	movs	r0, #0
#define BASE double
#include "source_trsm_r.h"
#undef BASE
}
 80112a4:	b013      	add	sp, #76	; 0x4c
 80112a6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80112aa:	f017 ba2d 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80112ae:	2865      	cmp	r0, #101	; 0x65
 80112b0:	f000 8210 	beq.w	80116d4 <cblas_dtrsm+0x50c>
 80112b4:	9a01      	ldr	r2, [sp, #4]
 80112b6:	9903      	ldr	r1, [sp, #12]
 80112b8:	2a01      	cmp	r2, #1
 80112ba:	bfb8      	it	lt
 80112bc:	2201      	movlt	r2, #1
 80112be:	428a      	cmp	r2, r1
 80112c0:	f340 80d3 	ble.w	801146a <cblas_dtrsm+0x2a2>
 80112c4:	230c      	movs	r3, #12
 80112c6:	e7cb      	b.n	8011260 <cblas_dtrsm+0x98>
 80112c8:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 80112cc:	2b01      	cmp	r3, #1
 80112ce:	f8dd c004 	ldr.w	ip, [sp, #4]
 80112d2:	bf94      	ite	ls
 80112d4:	2300      	movls	r3, #0
 80112d6:	2301      	movhi	r3, #1
 80112d8:	e795      	b.n	8011206 <cblas_dtrsm+0x3e>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80112da:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80112de:	f000 8205 	beq.w	80116ec <cblas_dtrsm+0x524>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 80112e2:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 80112e6:	d1da      	bne.n	801129e <cblas_dtrsm+0xd6>
 80112e8:	2f6f      	cmp	r7, #111	; 0x6f
 80112ea:	f000 83a3 	beq.w	8011a34 <cblas_dtrsm+0x86c>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 80112ee:	2f70      	cmp	r7, #112	; 0x70
 80112f0:	d1d5      	bne.n	801129e <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 80112f2:	4b63      	ldr	r3, [pc, #396]	; (8011480 <cblas_dtrsm+0x2b8>)
 80112f4:	2200      	movs	r2, #0
 80112f6:	4620      	mov	r0, r4
 80112f8:	4629      	mov	r1, r5
 80112fa:	f017 fe9d 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 80112fe:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8011300:	2800      	cmp	r0, #0
 8011302:	f040 8585 	bne.w	8011e10 <cblas_dtrsm+0xc48>
      for (i = 0; i < n1; i++) {
 8011306:	2b00      	cmp	r3, #0
 8011308:	f340 82a3 	ble.w	8011852 <cblas_dtrsm+0x68a>
 801130c:	9a03      	ldr	r2, [sp, #12]
 801130e:	9b01      	ldr	r3, [sp, #4]
 8011310:	f8dd b018 	ldr.w	fp, [sp, #24]
 8011314:	00d2      	lsls	r2, r2, #3
 8011316:	9202      	str	r2, [sp, #8]
 8011318:	00da      	lsls	r2, r3, #3
 801131a:	920e      	str	r2, [sp, #56]	; 0x38
 801131c:	9a05      	ldr	r2, [sp, #20]
 801131e:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011322:	4680      	mov	r8, r0
 8011324:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8011328:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 801132c:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 801132e:	f1ba 0f00 	cmp.w	sl, #0
 8011332:	bfc8      	it	gt
 8011334:	eb07 0609 	addgt.w	r6, r7, r9
 8011338:	dd09      	ble.n	801134e <cblas_dtrsm+0x186>
          B[ldb * i + j] *= alpha;
 801133a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801133e:	4622      	mov	r2, r4
 8011340:	462b      	mov	r3, r5
 8011342:	f017 fc11 	bl	8028b68 <__aeabi_dmul>
 8011346:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 801134a:	42be      	cmp	r6, r7
 801134c:	d1f5      	bne.n	801133a <cblas_dtrsm+0x172>
      for (i = 0; i < n1; i++) {
 801134e:	9b02      	ldr	r3, [sp, #8]
 8011350:	f108 0801 	add.w	r8, r8, #1
 8011354:	45c3      	cmp	fp, r8
 8011356:	441f      	add	r7, r3
 8011358:	d1e9      	bne.n	801132e <cblas_dtrsm+0x166>
 801135a:	9c06      	ldr	r4, [sp, #24]
 801135c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 801135e:	1e63      	subs	r3, r4, #1
 8011360:	4620      	mov	r0, r4
 8011362:	fb03 f206 	mul.w	r2, r3, r6
 8011366:	461f      	mov	r7, r3
 8011368:	ebc0 7540 	rsb	r5, r0, r0, lsl #29
 801136c:	9308      	str	r3, [sp, #32]
 801136e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8011370:	fb06 3303 	mla	r3, r6, r3, r3
 8011374:	1a9b      	subs	r3, r3, r2
 8011376:	1914      	adds	r4, r2, r4
 8011378:	3808      	subs	r0, #8
 801137a:	00db      	lsls	r3, r3, #3
 801137c:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
 8011380:	9310      	str	r3, [sp, #64]	; 0x40
 8011382:	980c      	ldr	r0, [sp, #48]	; 0x30
 8011384:	9b02      	ldr	r3, [sp, #8]
 8011386:	9407      	str	r4, [sp, #28]
 8011388:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 801138c:	4618      	mov	r0, r3
 801138e:	9b05      	ldr	r3, [sp, #20]
 8011390:	920a      	str	r2, [sp, #40]	; 0x28
 8011392:	43f1      	mvns	r1, r6
 8011394:	fb00 3207 	mla	r2, r0, r7, r3
 8011398:	ebc6 7a46 	rsb	sl, r6, r6, lsl #29
 801139c:	9e03      	ldr	r6, [sp, #12]
 801139e:	9209      	str	r2, [sp, #36]	; 0x24
 80113a0:	00ca      	lsls	r2, r1, #3
 80113a2:	ebc6 7646 	rsb	r6, r6, r6, lsl #29
 80113a6:	920c      	str	r2, [sp, #48]	; 0x30
 80113a8:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80113ac:	920d      	str	r2, [sp, #52]	; 0x34
 80113ae:	00f2      	lsls	r2, r6, #3
 80113b0:	920f      	str	r2, [sp, #60]	; 0x3c
 80113b2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80113b4:	00ed      	lsls	r5, r5, #3
 80113b6:	4413      	add	r3, r2
 80113b8:	9511      	str	r5, [sp, #68]	; 0x44
 80113ba:	930b      	str	r3, [sp, #44]	; 0x2c
      if (nonunit) {
 80113bc:	9b04      	ldr	r3, [sp, #16]
 80113be:	2b83      	cmp	r3, #131	; 0x83
 80113c0:	f000 826e 	beq.w	80118a0 <cblas_dtrsm+0x6d8>
      for (k = 0; k < i; k++) {
 80113c4:	9b08      	ldr	r3, [sp, #32]
 80113c6:	2b00      	cmp	r3, #0
 80113c8:	f000 8243 	beq.w	8011852 <cblas_dtrsm+0x68a>
 80113cc:	e9dd ba0a 	ldrd	fp, sl, [sp, #40]	; 0x28
 80113d0:	2300      	movs	r3, #0
 80113d2:	9306      	str	r3, [sp, #24]
        for (j = 0; j < n2; j++) {
 80113d4:	9b01      	ldr	r3, [sp, #4]
 80113d6:	2b00      	cmp	r3, #0
        const BASE Aik = A[i * lda + k];
 80113d8:	e8fb 8902 	ldrd	r8, r9, [fp], #8
        for (j = 0; j < n2; j++) {
 80113dc:	dd16      	ble.n	801140c <cblas_dtrsm+0x244>
 80113de:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
 80113e2:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80113e4:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 80113e8:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 80113ec:	4642      	mov	r2, r8
 80113ee:	464b      	mov	r3, r9
 80113f0:	f017 fbba 	bl	8028b68 <__aeabi_dmul>
 80113f4:	e9d4 6700 	ldrd	r6, r7, [r4]
 80113f8:	4602      	mov	r2, r0
 80113fa:	460b      	mov	r3, r1
 80113fc:	4630      	mov	r0, r6
 80113fe:	4639      	mov	r1, r7
 8011400:	f017 f9fa 	bl	80287f8 <__aeabi_dsub>
 8011404:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8011408:	4554      	cmp	r4, sl
 801140a:	d1ed      	bne.n	80113e8 <cblas_dtrsm+0x220>
      for (k = 0; k < i; k++) {
 801140c:	9b06      	ldr	r3, [sp, #24]
 801140e:	9a03      	ldr	r2, [sp, #12]
 8011410:	4413      	add	r3, r2
 8011412:	9306      	str	r3, [sp, #24]
 8011414:	9b02      	ldr	r3, [sp, #8]
 8011416:	449a      	add	sl, r3
 8011418:	9b07      	ldr	r3, [sp, #28]
 801141a:	459b      	cmp	fp, r3
 801141c:	d1da      	bne.n	80113d4 <cblas_dtrsm+0x20c>
 801141e:	9b07      	ldr	r3, [sp, #28]
 8011420:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8011422:	4413      	add	r3, r2
 8011424:	9307      	str	r3, [sp, #28]
 8011426:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8011428:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801142a:	4413      	add	r3, r2
 801142c:	930a      	str	r3, [sp, #40]	; 0x28
 801142e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8011430:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011432:	4413      	add	r3, r2
 8011434:	9309      	str	r3, [sp, #36]	; 0x24
 8011436:	9b08      	ldr	r3, [sp, #32]
 8011438:	3b01      	subs	r3, #1
 801143a:	9308      	str	r3, [sp, #32]
 801143c:	e7be      	b.n	80113bc <cblas_dtrsm+0x1f4>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801143e:	9b06      	ldr	r3, [sp, #24]
 8011440:	9a03      	ldr	r2, [sp, #12]
 8011442:	2b01      	cmp	r3, #1
 8011444:	bfb8      	it	lt
 8011446:	2301      	movlt	r3, #1
 8011448:	4293      	cmp	r3, r2
 801144a:	bfcc      	ite	gt
 801144c:	230c      	movgt	r3, #12
 801144e:	230a      	movle	r3, #10
 8011450:	4a08      	ldr	r2, [pc, #32]	; (8011474 <cblas_dtrsm+0x2ac>)
 8011452:	4909      	ldr	r1, [pc, #36]	; (8011478 <cblas_dtrsm+0x2b0>)
 8011454:	4618      	mov	r0, r3
 8011456:	f017 f957 	bl	8028708 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 801145a:	2f71      	cmp	r7, #113	; 0x71
 801145c:	9b06      	ldr	r3, [sp, #24]
 801145e:	d100      	bne.n	8011462 <cblas_dtrsm+0x29a>
 8011460:	2770      	movs	r7, #112	; 0x70
 8011462:	9a01      	ldr	r2, [sp, #4]
 8011464:	9206      	str	r2, [sp, #24]
 8011466:	9301      	str	r3, [sp, #4]
 8011468:	e70d      	b.n	8011286 <cblas_dtrsm+0xbe>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801146a:	2b00      	cmp	r3, #0
 801146c:	f43f aefd 	beq.w	801126a <cblas_dtrsm+0xa2>
 8011470:	e6f6      	b.n	8011260 <cblas_dtrsm+0x98>
 8011472:	bf00      	nop
 8011474:	08031108 	.word	0x08031108
 8011478:	080312a0 	.word	0x080312a0
 801147c:	080311b8 	.word	0x080311b8
 8011480:	3ff00000 	.word	0x3ff00000
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8011484:	2f6f      	cmp	r7, #111	; 0x6f
 8011486:	f000 8383 	beq.w	8011b90 <cblas_dtrsm+0x9c8>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 801148a:	2f70      	cmp	r7, #112	; 0x70
 801148c:	f47f af07 	bne.w	801129e <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 8011490:	4b95      	ldr	r3, [pc, #596]	; (80116e8 <cblas_dtrsm+0x520>)
 8011492:	2200      	movs	r2, #0
 8011494:	4620      	mov	r0, r4
 8011496:	4629      	mov	r1, r5
 8011498:	f017 fdce 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 801149c:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 801149e:	2800      	cmp	r0, #0
 80114a0:	f040 84ed 	bne.w	8011e7e <cblas_dtrsm+0xcb6>
      for (i = 0; i < n1; i++) {
 80114a4:	2b00      	cmp	r3, #0
 80114a6:	f340 81d4 	ble.w	8011852 <cblas_dtrsm+0x68a>
 80114aa:	9a03      	ldr	r2, [sp, #12]
 80114ac:	9b01      	ldr	r3, [sp, #4]
 80114ae:	f8dd b018 	ldr.w	fp, [sp, #24]
 80114b2:	00d2      	lsls	r2, r2, #3
 80114b4:	9202      	str	r2, [sp, #8]
 80114b6:	00da      	lsls	r2, r3, #3
 80114b8:	920e      	str	r2, [sp, #56]	; 0x38
 80114ba:	9a05      	ldr	r2, [sp, #20]
 80114bc:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 80114c0:	4680      	mov	r8, r0
 80114c2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 80114c6:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 80114ca:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 80114cc:	f1ba 0f00 	cmp.w	sl, #0
 80114d0:	bfc8      	it	gt
 80114d2:	eb07 0609 	addgt.w	r6, r7, r9
 80114d6:	dd09      	ble.n	80114ec <cblas_dtrsm+0x324>
          B[ldb * i + j] *= alpha;
 80114d8:	e9d6 0100 	ldrd	r0, r1, [r6]
 80114dc:	4622      	mov	r2, r4
 80114de:	462b      	mov	r3, r5
 80114e0:	f017 fb42 	bl	8028b68 <__aeabi_dmul>
 80114e4:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 80114e8:	42be      	cmp	r6, r7
 80114ea:	d1f5      	bne.n	80114d8 <cblas_dtrsm+0x310>
      for (i = 0; i < n1; i++) {
 80114ec:	9b02      	ldr	r3, [sp, #8]
 80114ee:	f108 0801 	add.w	r8, r8, #1
 80114f2:	45c3      	cmp	fp, r8
 80114f4:	441f      	add	r7, r3
 80114f6:	d1e9      	bne.n	80114cc <cblas_dtrsm+0x304>
 80114f8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80114fa:	980e      	ldr	r0, [sp, #56]	; 0x38
 80114fc:	9905      	ldr	r1, [sp, #20]
 80114fe:	9108      	str	r1, [sp, #32]
 8011500:	ea6f 0a02 	mvn.w	sl, r2
 8011504:	4604      	mov	r4, r0
 8011506:	1c53      	adds	r3, r2, #1
 8011508:	440c      	add	r4, r1
 801150a:	9a01      	ldr	r2, [sp, #4]
 801150c:	940b      	str	r4, [sp, #44]	; 0x2c
 801150e:	ea4f 01ca 	mov.w	r1, sl, lsl #3
 8011512:	9109      	str	r1, [sp, #36]	; 0x24
 8011514:	990c      	ldr	r1, [sp, #48]	; 0x30
 8011516:	00db      	lsls	r3, r3, #3
 8011518:	3a01      	subs	r2, #1
 801151a:	fb03 1202 	mla	r2, r3, r2, r1
 801151e:	f1a3 0b08 	sub.w	fp, r3, #8
 8011522:	f101 0308 	add.w	r3, r1, #8
 8011526:	930a      	str	r3, [sp, #40]	; 0x28
      for (j = n2; j > 0 && j--;) {
 8011528:	2300      	movs	r3, #0
 801152a:	920d      	str	r2, [sp, #52]	; 0x34
 801152c:	930c      	str	r3, [sp, #48]	; 0x30
 801152e:	9b01      	ldr	r3, [sp, #4]
 8011530:	2b00      	cmp	r3, #0
 8011532:	f340 8191 	ble.w	8011858 <cblas_dtrsm+0x690>
 8011536:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011538:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801153a:	9307      	str	r3, [sp, #28]
 801153c:	469a      	mov	sl, r3
 801153e:	9b01      	ldr	r3, [sp, #4]
 8011540:	9205      	str	r2, [sp, #20]
 8011542:	9303      	str	r3, [sp, #12]
 8011544:	9b03      	ldr	r3, [sp, #12]
 8011546:	3b01      	subs	r3, #1
 8011548:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 801154a:	9b04      	ldr	r3, [sp, #16]
 801154c:	2b83      	cmp	r3, #131	; 0x83
 801154e:	d109      	bne.n	8011564 <cblas_dtrsm+0x39c>
          B[ldb * i + j] /= Ajj;
 8011550:	9c07      	ldr	r4, [sp, #28]
 8011552:	9b05      	ldr	r3, [sp, #20]
 8011554:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8011558:	e9d3 2300 	ldrd	r2, r3, [r3]
 801155c:	f017 fc2e 	bl	8028dbc <__aeabi_ddiv>
 8011560:	e944 0102 	strd	r0, r1, [r4, #-8]
          for (k = 0; k < j; k++) {
 8011564:	9b03      	ldr	r3, [sp, #12]
          BASE Bij = B[ldb * i + j];
 8011566:	e97a 8902 	ldrd	r8, r9, [sl, #-8]!
          for (k = 0; k < j; k++) {
 801156a:	2b00      	cmp	r3, #0
 801156c:	f000 8174 	beq.w	8011858 <cblas_dtrsm+0x690>
 8011570:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8011572:	9c08      	ldr	r4, [sp, #32]
 8011574:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 8011578:	e955 2302 	ldrd	r2, r3, [r5, #-8]
 801157c:	4640      	mov	r0, r8
 801157e:	4649      	mov	r1, r9
 8011580:	f017 faf2 	bl	8028b68 <__aeabi_dmul>
 8011584:	e9d4 6700 	ldrd	r6, r7, [r4]
 8011588:	4602      	mov	r2, r0
 801158a:	460b      	mov	r3, r1
 801158c:	4630      	mov	r0, r6
 801158e:	4639      	mov	r1, r7
 8011590:	f017 f932 	bl	80287f8 <__aeabi_dsub>
 8011594:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = 0; k < j; k++) {
 8011598:	4554      	cmp	r4, sl
 801159a:	445d      	add	r5, fp
 801159c:	d1ec      	bne.n	8011578 <cblas_dtrsm+0x3b0>
 801159e:	9b05      	ldr	r3, [sp, #20]
 80115a0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80115a2:	4413      	add	r3, r2
 80115a4:	9305      	str	r3, [sp, #20]
 80115a6:	9b07      	ldr	r3, [sp, #28]
 80115a8:	3b08      	subs	r3, #8
 80115aa:	9307      	str	r3, [sp, #28]
 80115ac:	e7ca      	b.n	8011544 <cblas_dtrsm+0x37c>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 80115ae:	2f6f      	cmp	r7, #111	; 0x6f
 80115b0:	f000 837e 	beq.w	8011cb0 <cblas_dtrsm+0xae8>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 80115b4:	2f70      	cmp	r7, #112	; 0x70
 80115b6:	f47f ae72 	bne.w	801129e <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 80115ba:	4b4b      	ldr	r3, [pc, #300]	; (80116e8 <cblas_dtrsm+0x520>)
 80115bc:	2200      	movs	r2, #0
 80115be:	4620      	mov	r0, r4
 80115c0:	4629      	mov	r1, r5
 80115c2:	f017 fd39 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 80115c6:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 80115c8:	2800      	cmp	r0, #0
 80115ca:	f040 840c 	bne.w	8011de6 <cblas_dtrsm+0xc1e>
      for (i = 0; i < n1; i++) {
 80115ce:	2b00      	cmp	r3, #0
 80115d0:	f340 813f 	ble.w	8011852 <cblas_dtrsm+0x68a>
 80115d4:	9a03      	ldr	r2, [sp, #12]
 80115d6:	9b01      	ldr	r3, [sp, #4]
 80115d8:	f8dd b018 	ldr.w	fp, [sp, #24]
 80115dc:	00d2      	lsls	r2, r2, #3
 80115de:	9202      	str	r2, [sp, #8]
 80115e0:	00da      	lsls	r2, r3, #3
 80115e2:	920e      	str	r2, [sp, #56]	; 0x38
 80115e4:	9a05      	ldr	r2, [sp, #20]
 80115e6:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 80115ea:	4680      	mov	r8, r0
 80115ec:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 80115f0:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 80115f4:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 80115f6:	f1ba 0f00 	cmp.w	sl, #0
 80115fa:	bfc8      	it	gt
 80115fc:	eb07 0609 	addgt.w	r6, r7, r9
 8011600:	dd09      	ble.n	8011616 <cblas_dtrsm+0x44e>
          B[ldb * i + j] *= alpha;
 8011602:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011606:	4622      	mov	r2, r4
 8011608:	462b      	mov	r3, r5
 801160a:	f017 faad 	bl	8028b68 <__aeabi_dmul>
 801160e:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8011612:	42be      	cmp	r6, r7
 8011614:	d1f5      	bne.n	8011602 <cblas_dtrsm+0x43a>
      for (i = 0; i < n1; i++) {
 8011616:	9b02      	ldr	r3, [sp, #8]
 8011618:	f108 0801 	add.w	r8, r8, #1
 801161c:	45c3      	cmp	fp, r8
 801161e:	441f      	add	r7, r3
 8011620:	d1e9      	bne.n	80115f6 <cblas_dtrsm+0x42e>
 8011622:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011624:	9805      	ldr	r0, [sp, #20]
 8011626:	990e      	ldr	r1, [sp, #56]	; 0x38
 8011628:	900d      	str	r0, [sp, #52]	; 0x34
 801162a:	1c53      	adds	r3, r2, #1
 801162c:	00db      	lsls	r3, r3, #3
 801162e:	930a      	str	r3, [sp, #40]	; 0x28
 8011630:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011632:	ea4f 0bc2 	mov.w	fp, r2, lsl #3
 8011636:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801163a:	930f      	str	r3, [sp, #60]	; 0x3c
 801163c:	f10b 0308 	add.w	r3, fp, #8
 8011640:	4401      	add	r1, r0
 8011642:	930b      	str	r3, [sp, #44]	; 0x2c
          for (k = j + 1; k < n2; k++) {
 8011644:	2300      	movs	r3, #0
 8011646:	468a      	mov	sl, r1
 8011648:	930e      	str	r3, [sp, #56]	; 0x38
      for (j = 0; j < n2; j++) {
 801164a:	9b01      	ldr	r3, [sp, #4]
 801164c:	2b00      	cmp	r3, #0
 801164e:	f340 80f3 	ble.w	8011838 <cblas_dtrsm+0x670>
 8011652:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011654:	9305      	str	r3, [sp, #20]
 8011656:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011658:	9307      	str	r3, [sp, #28]
 801165a:	9309      	str	r3, [sp, #36]	; 0x24
 801165c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801165e:	9303      	str	r3, [sp, #12]
 8011660:	2300      	movs	r3, #0
 8011662:	9308      	str	r3, [sp, #32]
        if (nonunit) {
 8011664:	9b04      	ldr	r3, [sp, #16]
 8011666:	2b83      	cmp	r3, #131	; 0x83
 8011668:	d109      	bne.n	801167e <cblas_dtrsm+0x4b6>
          B[ldb * i + j] /= Ajj;
 801166a:	9c07      	ldr	r4, [sp, #28]
 801166c:	9b05      	ldr	r3, [sp, #20]
 801166e:	e9d4 0100 	ldrd	r0, r1, [r4]
 8011672:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011676:	f017 fba1 	bl	8028dbc <__aeabi_ddiv>
 801167a:	e9c4 0100 	strd	r0, r1, [r4]
          BASE Bij = B[ldb * i + j];
 801167e:	9c09      	ldr	r4, [sp, #36]	; 0x24
          for (k = j + 1; k < n2; k++) {
 8011680:	9b08      	ldr	r3, [sp, #32]
 8011682:	9a01      	ldr	r2, [sp, #4]
          BASE Bij = B[ldb * i + j];
 8011684:	e8f4 8902 	ldrd	r8, r9, [r4], #8
          for (k = j + 1; k < n2; k++) {
 8011688:	3301      	adds	r3, #1
 801168a:	429a      	cmp	r2, r3
 801168c:	9308      	str	r3, [sp, #32]
          BASE Bij = B[ldb * i + j];
 801168e:	9409      	str	r4, [sp, #36]	; 0x24
          for (k = j + 1; k < n2; k++) {
 8011690:	f000 80d2 	beq.w	8011838 <cblas_dtrsm+0x670>
 8011694:	9d03      	ldr	r5, [sp, #12]
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 8011696:	e9d5 2300 	ldrd	r2, r3, [r5]
 801169a:	4640      	mov	r0, r8
 801169c:	4649      	mov	r1, r9
 801169e:	f017 fa63 	bl	8028b68 <__aeabi_dmul>
 80116a2:	e9d4 6700 	ldrd	r6, r7, [r4]
 80116a6:	4602      	mov	r2, r0
 80116a8:	460b      	mov	r3, r1
 80116aa:	4630      	mov	r0, r6
 80116ac:	4639      	mov	r1, r7
 80116ae:	f017 f8a3 	bl	80287f8 <__aeabi_dsub>
 80116b2:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = j + 1; k < n2; k++) {
 80116b6:	4554      	cmp	r4, sl
 80116b8:	445d      	add	r5, fp
 80116ba:	d1ec      	bne.n	8011696 <cblas_dtrsm+0x4ce>
 80116bc:	9b03      	ldr	r3, [sp, #12]
 80116be:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80116c0:	4413      	add	r3, r2
 80116c2:	9303      	str	r3, [sp, #12]
 80116c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80116c6:	9b05      	ldr	r3, [sp, #20]
 80116c8:	4413      	add	r3, r2
 80116ca:	9305      	str	r3, [sp, #20]
 80116cc:	9b07      	ldr	r3, [sp, #28]
 80116ce:	3308      	adds	r3, #8
 80116d0:	9307      	str	r3, [sp, #28]
 80116d2:	e7c7      	b.n	8011664 <cblas_dtrsm+0x49c>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80116d4:	9a06      	ldr	r2, [sp, #24]
 80116d6:	9903      	ldr	r1, [sp, #12]
 80116d8:	2a01      	cmp	r2, #1
 80116da:	bfb8      	it	lt
 80116dc:	2201      	movlt	r2, #1
 80116de:	428a      	cmp	r2, r1
 80116e0:	f340 809d 	ble.w	801181e <cblas_dtrsm+0x656>
 80116e4:	230c      	movs	r3, #12
 80116e6:	e6b3      	b.n	8011450 <cblas_dtrsm+0x288>
 80116e8:	3ff00000 	.word	0x3ff00000
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80116ec:	2f6f      	cmp	r7, #111	; 0x6f
 80116ee:	f000 80f3 	beq.w	80118d8 <cblas_dtrsm+0x710>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 80116f2:	2f70      	cmp	r7, #112	; 0x70
 80116f4:	f47f add3 	bne.w	801129e <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 80116f8:	4b76      	ldr	r3, [pc, #472]	; (80118d4 <cblas_dtrsm+0x70c>)
 80116fa:	2200      	movs	r2, #0
 80116fc:	4620      	mov	r0, r4
 80116fe:	4629      	mov	r1, r5
 8011700:	f017 fc9a 	bl	8029038 <__aeabi_dcmpeq>
 8011704:	2800      	cmp	r0, #0
 8011706:	f040 839b 	bne.w	8011e40 <cblas_dtrsm+0xc78>
      for (i = 0; i < n1; i++) {
 801170a:	9906      	ldr	r1, [sp, #24]
 801170c:	2900      	cmp	r1, #0
 801170e:	f340 80a0 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011712:	9a03      	ldr	r2, [sp, #12]
 8011714:	9b01      	ldr	r3, [sp, #4]
 8011716:	00d2      	lsls	r2, r2, #3
 8011718:	9202      	str	r2, [sp, #8]
 801171a:	00da      	lsls	r2, r3, #3
 801171c:	920e      	str	r2, [sp, #56]	; 0x38
 801171e:	9a05      	ldr	r2, [sp, #20]
 8011720:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011724:	4680      	mov	r8, r0
 8011726:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 801172a:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 801172e:	469a      	mov	sl, r3
 8011730:	468b      	mov	fp, r1
        for (j = 0; j < n2; j++) {
 8011732:	f1ba 0f00 	cmp.w	sl, #0
 8011736:	bfc8      	it	gt
 8011738:	eb09 0607 	addgt.w	r6, r9, r7
 801173c:	dd09      	ble.n	8011752 <cblas_dtrsm+0x58a>
          B[ldb * i + j] *= alpha;
 801173e:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011742:	4622      	mov	r2, r4
 8011744:	462b      	mov	r3, r5
 8011746:	f017 fa0f 	bl	8028b68 <__aeabi_dmul>
 801174a:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 801174e:	42b7      	cmp	r7, r6
 8011750:	d1f5      	bne.n	801173e <cblas_dtrsm+0x576>
      for (i = 0; i < n1; i++) {
 8011752:	9b02      	ldr	r3, [sp, #8]
 8011754:	f108 0801 	add.w	r8, r8, #1
 8011758:	45c3      	cmp	fp, r8
 801175a:	441f      	add	r7, r3
 801175c:	d1e9      	bne.n	8011732 <cblas_dtrsm+0x56a>
 801175e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011760:	9903      	ldr	r1, [sp, #12]
 8011762:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8011764:	9d06      	ldr	r5, [sp, #24]
 8011766:	00d8      	lsls	r0, r3, #3
 8011768:	9b01      	ldr	r3, [sp, #4]
 801176a:	9011      	str	r0, [sp, #68]	; 0x44
 801176c:	440b      	add	r3, r1
 801176e:	00db      	lsls	r3, r3, #3
 8011770:	eb02 01c5 	add.w	r1, r2, r5, lsl #3
 8011774:	2400      	movs	r4, #0
 8011776:	9109      	str	r1, [sp, #36]	; 0x24
 8011778:	3208      	adds	r2, #8
 801177a:	f100 0108 	add.w	r1, r0, #8
 801177e:	930f      	str	r3, [sp, #60]	; 0x3c
 8011780:	9b05      	ldr	r3, [sp, #20]
 8011782:	940d      	str	r4, [sp, #52]	; 0x34
 8011784:	9110      	str	r1, [sp, #64]	; 0x40
 8011786:	920a      	str	r2, [sp, #40]	; 0x28
 8011788:	940b      	str	r4, [sp, #44]	; 0x2c
 801178a:	9308      	str	r3, [sp, #32]
      if (nonunit) {
 801178c:	9b04      	ldr	r3, [sp, #16]
 801178e:	2b83      	cmp	r3, #131	; 0x83
 8011790:	d072      	beq.n	8011878 <cblas_dtrsm+0x6b0>
      for (k = i + 1; k < n1; k++) {
 8011792:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011794:	9a06      	ldr	r2, [sp, #24]
 8011796:	3301      	adds	r3, #1
 8011798:	429a      	cmp	r2, r3
 801179a:	930b      	str	r3, [sp, #44]	; 0x2c
 801179c:	dd59      	ble.n	8011852 <cblas_dtrsm+0x68a>
 801179e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80117a0:	9a03      	ldr	r2, [sp, #12]
 80117a2:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 80117a6:	4413      	add	r3, r2
 80117a8:	930d      	str	r3, [sp, #52]	; 0x34
 80117aa:	9a08      	ldr	r2, [sp, #32]
 80117ac:	9307      	str	r3, [sp, #28]
 80117ae:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80117b0:	eb03 0a02 	add.w	sl, r3, r2
        for (j = 0; j < n2; j++) {
 80117b4:	9b01      	ldr	r3, [sp, #4]
 80117b6:	2b00      	cmp	r3, #0
        const BASE Aik = A[i * lda + k];
 80117b8:	e8fb 8902 	ldrd	r8, r9, [fp], #8
        for (j = 0; j < n2; j++) {
 80117bc:	dd16      	ble.n	80117ec <cblas_dtrsm+0x624>
 80117be:	9b05      	ldr	r3, [sp, #20]
 80117c0:	9a07      	ldr	r2, [sp, #28]
 80117c2:	9d08      	ldr	r5, [sp, #32]
 80117c4:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 80117c8:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 80117cc:	4642      	mov	r2, r8
 80117ce:	464b      	mov	r3, r9
 80117d0:	f017 f9ca 	bl	8028b68 <__aeabi_dmul>
 80117d4:	e9d4 6700 	ldrd	r6, r7, [r4]
 80117d8:	4602      	mov	r2, r0
 80117da:	460b      	mov	r3, r1
 80117dc:	4630      	mov	r0, r6
 80117de:	4639      	mov	r1, r7
 80117e0:	f017 f80a 	bl	80287f8 <__aeabi_dsub>
 80117e4:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 80117e8:	45a2      	cmp	sl, r4
 80117ea:	d1ed      	bne.n	80117c8 <cblas_dtrsm+0x600>
      for (k = i + 1; k < n1; k++) {
 80117ec:	9b07      	ldr	r3, [sp, #28]
 80117ee:	9a03      	ldr	r2, [sp, #12]
 80117f0:	4413      	add	r3, r2
 80117f2:	9307      	str	r3, [sp, #28]
 80117f4:	9b02      	ldr	r3, [sp, #8]
 80117f6:	449a      	add	sl, r3
 80117f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80117fa:	455b      	cmp	r3, fp
 80117fc:	d1da      	bne.n	80117b4 <cblas_dtrsm+0x5ec>
 80117fe:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8011800:	4413      	add	r3, r2
 8011802:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8011804:	9309      	str	r3, [sp, #36]	; 0x24
 8011806:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011808:	4611      	mov	r1, r2
 801180a:	4419      	add	r1, r3
 801180c:	9a08      	ldr	r2, [sp, #32]
 801180e:	910a      	str	r1, [sp, #40]	; 0x28
 8011810:	9902      	ldr	r1, [sp, #8]
 8011812:	440a      	add	r2, r1
 8011814:	9208      	str	r2, [sp, #32]
 8011816:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8011818:	441a      	add	r2, r3
 801181a:	920c      	str	r2, [sp, #48]	; 0x30
 801181c:	e7b6      	b.n	801178c <cblas_dtrsm+0x5c4>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801181e:	2b00      	cmp	r3, #0
 8011820:	f43f ae1b 	beq.w	801145a <cblas_dtrsm+0x292>
 8011824:	e614      	b.n	8011450 <cblas_dtrsm+0x288>
 8011826:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 801182a:	2b01      	cmp	r3, #1
 801182c:	f8dd c018 	ldr.w	ip, [sp, #24]
 8011830:	bf94      	ite	ls
 8011832:	2300      	movls	r3, #0
 8011834:	2301      	movhi	r3, #1
 8011836:	e4e6      	b.n	8011206 <cblas_dtrsm+0x3e>
    for (i = 0; i < n1; i++) {
 8011838:	990d      	ldr	r1, [sp, #52]	; 0x34
 801183a:	9a02      	ldr	r2, [sp, #8]
 801183c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801183e:	4608      	mov	r0, r1
 8011840:	4410      	add	r0, r2
 8011842:	4492      	add	sl, r2
 8011844:	9a06      	ldr	r2, [sp, #24]
 8011846:	900d      	str	r0, [sp, #52]	; 0x34
 8011848:	3301      	adds	r3, #1
 801184a:	429a      	cmp	r2, r3
 801184c:	930e      	str	r3, [sp, #56]	; 0x38
 801184e:	f73f aefc 	bgt.w	801164a <cblas_dtrsm+0x482>
 8011852:	b013      	add	sp, #76	; 0x4c
 8011854:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < n1; i++) {
 8011858:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801185a:	9a02      	ldr	r2, [sp, #8]
 801185c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801185e:	4608      	mov	r0, r1
 8011860:	9908      	ldr	r1, [sp, #32]
 8011862:	4410      	add	r0, r2
 8011864:	4411      	add	r1, r2
 8011866:	9a06      	ldr	r2, [sp, #24]
 8011868:	900b      	str	r0, [sp, #44]	; 0x2c
 801186a:	3301      	adds	r3, #1
 801186c:	429a      	cmp	r2, r3
 801186e:	930c      	str	r3, [sp, #48]	; 0x30
 8011870:	9108      	str	r1, [sp, #32]
 8011872:	f73f ae5c 	bgt.w	801152e <cblas_dtrsm+0x366>
 8011876:	e7ec      	b.n	8011852 <cblas_dtrsm+0x68a>
        BASE Aii = A[lda * i + i];
 8011878:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801187a:	e9d3 6700 	ldrd	r6, r7, [r3]
        for (j = 0; j < n2; j++) {
 801187e:	9b01      	ldr	r3, [sp, #4]
 8011880:	2b00      	cmp	r3, #0
 8011882:	dd86      	ble.n	8011792 <cblas_dtrsm+0x5ca>
 8011884:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011886:	9c08      	ldr	r4, [sp, #32]
 8011888:	191d      	adds	r5, r3, r4
          B[ldb * i + j] /= Aii;
 801188a:	e9d4 0100 	ldrd	r0, r1, [r4]
 801188e:	4632      	mov	r2, r6
 8011890:	463b      	mov	r3, r7
 8011892:	f017 fa93 	bl	8028dbc <__aeabi_ddiv>
 8011896:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 801189a:	42a5      	cmp	r5, r4
 801189c:	d1f5      	bne.n	801188a <cblas_dtrsm+0x6c2>
 801189e:	e778      	b.n	8011792 <cblas_dtrsm+0x5ca>
        BASE Aii = A[lda * i + i];
 80118a0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80118a2:	9b07      	ldr	r3, [sp, #28]
 80118a4:	4413      	add	r3, r2
 80118a6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80118a8:	4413      	add	r3, r2
 80118aa:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 80118ae:	9b01      	ldr	r3, [sp, #4]
 80118b0:	2b00      	cmp	r3, #0
 80118b2:	f77f ad87 	ble.w	80113c4 <cblas_dtrsm+0x1fc>
 80118b6:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80118b8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80118ba:	18e5      	adds	r5, r4, r3
          B[ldb * i + j] /= Aii;
 80118bc:	e9d4 0100 	ldrd	r0, r1, [r4]
 80118c0:	4632      	mov	r2, r6
 80118c2:	463b      	mov	r3, r7
 80118c4:	f017 fa7a 	bl	8028dbc <__aeabi_ddiv>
 80118c8:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 80118cc:	42ac      	cmp	r4, r5
 80118ce:	d1f5      	bne.n	80118bc <cblas_dtrsm+0x6f4>
 80118d0:	e578      	b.n	80113c4 <cblas_dtrsm+0x1fc>
 80118d2:	bf00      	nop
 80118d4:	3ff00000 	.word	0x3ff00000
    if (alpha != 1.0) {
 80118d8:	4ba2      	ldr	r3, [pc, #648]	; (8011b64 <cblas_dtrsm+0x99c>)
 80118da:	2200      	movs	r2, #0
 80118dc:	4620      	mov	r0, r4
 80118de:	4629      	mov	r1, r5
 80118e0:	f017 fbaa 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 80118e4:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 80118e6:	2800      	cmp	r0, #0
 80118e8:	f040 829d 	bne.w	8011e26 <cblas_dtrsm+0xc5e>
      for (i = 0; i < n1; i++) {
 80118ec:	2b00      	cmp	r3, #0
 80118ee:	ddb0      	ble.n	8011852 <cblas_dtrsm+0x68a>
 80118f0:	9a03      	ldr	r2, [sp, #12]
 80118f2:	9b01      	ldr	r3, [sp, #4]
 80118f4:	f8dd b018 	ldr.w	fp, [sp, #24]
 80118f8:	00d2      	lsls	r2, r2, #3
 80118fa:	9202      	str	r2, [sp, #8]
 80118fc:	00da      	lsls	r2, r3, #3
 80118fe:	920e      	str	r2, [sp, #56]	; 0x38
 8011900:	9a05      	ldr	r2, [sp, #20]
 8011902:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011906:	4680      	mov	r8, r0
 8011908:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 801190c:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8011910:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 8011912:	f1ba 0f00 	cmp.w	sl, #0
 8011916:	bfc8      	it	gt
 8011918:	eb09 0607 	addgt.w	r6, r9, r7
 801191c:	dd09      	ble.n	8011932 <cblas_dtrsm+0x76a>
          B[ldb * i + j] *= alpha;
 801191e:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011922:	4622      	mov	r2, r4
 8011924:	462b      	mov	r3, r5
 8011926:	f017 f91f 	bl	8028b68 <__aeabi_dmul>
 801192a:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 801192e:	42b7      	cmp	r7, r6
 8011930:	d1f5      	bne.n	801191e <cblas_dtrsm+0x756>
      for (i = 0; i < n1; i++) {
 8011932:	9b02      	ldr	r3, [sp, #8]
 8011934:	f108 0801 	add.w	r8, r8, #1
 8011938:	45c3      	cmp	fp, r8
 801193a:	441f      	add	r7, r3
 801193c:	d1e9      	bne.n	8011912 <cblas_dtrsm+0x74a>
 801193e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011940:	9906      	ldr	r1, [sp, #24]
 8011942:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8011944:	1c53      	adds	r3, r2, #1
 8011946:	ea6f 0a02 	mvn.w	sl, r2
 801194a:	3901      	subs	r1, #1
 801194c:	00db      	lsls	r3, r3, #3
 801194e:	ea4f 00ca 	mov.w	r0, sl, lsl #3
 8011952:	900d      	str	r0, [sp, #52]	; 0x34
 8011954:	fb01 4003 	mla	r0, r1, r3, r4
 8011958:	3b08      	subs	r3, #8
 801195a:	930a      	str	r3, [sp, #40]	; 0x28
 801195c:	f104 0308 	add.w	r3, r4, #8
 8011960:	9a03      	ldr	r2, [sp, #12]
 8011962:	900b      	str	r0, [sp, #44]	; 0x2c
 8011964:	9310      	str	r3, [sp, #64]	; 0x40
 8011966:	9805      	ldr	r0, [sp, #20]
 8011968:	9b02      	ldr	r3, [sp, #8]
 801196a:	9108      	str	r1, [sp, #32]
 801196c:	fb01 0303 	mla	r3, r1, r3, r0
 8011970:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8011974:	9309      	str	r3, [sp, #36]	; 0x24
 8011976:	00d3      	lsls	r3, r2, #3
 8011978:	930f      	str	r3, [sp, #60]	; 0x3c
 801197a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801197c:	18c3      	adds	r3, r0, r3
 801197e:	930c      	str	r3, [sp, #48]	; 0x30
      if (nonunit) {
 8011980:	9b04      	ldr	r3, [sp, #16]
 8011982:	2b83      	cmp	r3, #131	; 0x83
 8011984:	d042      	beq.n	8011a0c <cblas_dtrsm+0x844>
      for (k = 0; k < i; k++) {
 8011986:	9b08      	ldr	r3, [sp, #32]
 8011988:	2b00      	cmp	r3, #0
 801198a:	f43f af62 	beq.w	8011852 <cblas_dtrsm+0x68a>
 801198e:	2300      	movs	r3, #0
 8011990:	e9cd 3306 	strd	r3, r3, [sp, #24]
 8011994:	9a08      	ldr	r2, [sp, #32]
 8011996:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011998:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 801199c:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
        for (j = 0; j < n2; j++) {
 80119a0:	9b01      	ldr	r3, [sp, #4]
 80119a2:	2b00      	cmp	r3, #0
        const BASE Aki = A[k * lda + i];
 80119a4:	e95b 8902 	ldrd	r8, r9, [fp, #-8]
        for (j = 0; j < n2; j++) {
 80119a8:	dd16      	ble.n	80119d8 <cblas_dtrsm+0x810>
 80119aa:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
 80119ae:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80119b0:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 80119b4:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 80119b8:	4642      	mov	r2, r8
 80119ba:	464b      	mov	r3, r9
 80119bc:	f017 f8d4 	bl	8028b68 <__aeabi_dmul>
 80119c0:	e9d4 6700 	ldrd	r6, r7, [r4]
 80119c4:	4602      	mov	r2, r0
 80119c6:	460b      	mov	r3, r1
 80119c8:	4630      	mov	r0, r6
 80119ca:	4639      	mov	r1, r7
 80119cc:	f016 ff14 	bl	80287f8 <__aeabi_dsub>
 80119d0:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 80119d4:	4554      	cmp	r4, sl
 80119d6:	d1ed      	bne.n	80119b4 <cblas_dtrsm+0x7ec>
      for (k = 0; k < i; k++) {
 80119d8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80119da:	9903      	ldr	r1, [sp, #12]
 80119dc:	9b07      	ldr	r3, [sp, #28]
 80119de:	4493      	add	fp, r2
 80119e0:	9a06      	ldr	r2, [sp, #24]
 80119e2:	440a      	add	r2, r1
 80119e4:	9206      	str	r2, [sp, #24]
 80119e6:	9a02      	ldr	r2, [sp, #8]
 80119e8:	4492      	add	sl, r2
 80119ea:	9a08      	ldr	r2, [sp, #32]
 80119ec:	3301      	adds	r3, #1
 80119ee:	429a      	cmp	r2, r3
 80119f0:	9307      	str	r3, [sp, #28]
 80119f2:	d1d5      	bne.n	80119a0 <cblas_dtrsm+0x7d8>
 80119f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80119f6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80119f8:	4413      	add	r3, r2
 80119fa:	9309      	str	r3, [sp, #36]	; 0x24
 80119fc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80119fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011a00:	4413      	add	r3, r2
 8011a02:	930b      	str	r3, [sp, #44]	; 0x2c
 8011a04:	9b08      	ldr	r3, [sp, #32]
 8011a06:	3b01      	subs	r3, #1
 8011a08:	9308      	str	r3, [sp, #32]
 8011a0a:	e7b9      	b.n	8011980 <cblas_dtrsm+0x7b8>
        BASE Aii = A[lda * i + i];
 8011a0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011a0e:	e9d3 6700 	ldrd	r6, r7, [r3]
        for (j = 0; j < n2; j++) {
 8011a12:	9b01      	ldr	r3, [sp, #4]
 8011a14:	2b00      	cmp	r3, #0
 8011a16:	ddb6      	ble.n	8011986 <cblas_dtrsm+0x7be>
 8011a18:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011a1a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8011a1c:	191d      	adds	r5, r3, r4
          B[ldb * i + j] /= Aii;
 8011a1e:	e9d4 0100 	ldrd	r0, r1, [r4]
 8011a22:	4632      	mov	r2, r6
 8011a24:	463b      	mov	r3, r7
 8011a26:	f017 f9c9 	bl	8028dbc <__aeabi_ddiv>
 8011a2a:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8011a2e:	42a5      	cmp	r5, r4
 8011a30:	d1f5      	bne.n	8011a1e <cblas_dtrsm+0x856>
 8011a32:	e7a8      	b.n	8011986 <cblas_dtrsm+0x7be>
    if (alpha != 1.0) {
 8011a34:	4b4b      	ldr	r3, [pc, #300]	; (8011b64 <cblas_dtrsm+0x99c>)
 8011a36:	2200      	movs	r2, #0
 8011a38:	4620      	mov	r0, r4
 8011a3a:	4629      	mov	r1, r5
 8011a3c:	f017 fafc 	bl	8029038 <__aeabi_dcmpeq>
 8011a40:	2800      	cmp	r0, #0
 8011a42:	f040 81da 	bne.w	8011dfa <cblas_dtrsm+0xc32>
      for (i = 0; i < n1; i++) {
 8011a46:	9906      	ldr	r1, [sp, #24]
 8011a48:	2900      	cmp	r1, #0
 8011a4a:	f77f af02 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011a4e:	9a03      	ldr	r2, [sp, #12]
 8011a50:	9b01      	ldr	r3, [sp, #4]
 8011a52:	00d2      	lsls	r2, r2, #3
 8011a54:	9202      	str	r2, [sp, #8]
 8011a56:	00da      	lsls	r2, r3, #3
 8011a58:	920e      	str	r2, [sp, #56]	; 0x38
 8011a5a:	9a05      	ldr	r2, [sp, #20]
 8011a5c:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011a60:	4680      	mov	r8, r0
 8011a62:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8011a66:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8011a6a:	469a      	mov	sl, r3
 8011a6c:	468b      	mov	fp, r1
        for (j = 0; j < n2; j++) {
 8011a6e:	f1ba 0f00 	cmp.w	sl, #0
 8011a72:	bfc8      	it	gt
 8011a74:	eb09 0607 	addgt.w	r6, r9, r7
 8011a78:	dd09      	ble.n	8011a8e <cblas_dtrsm+0x8c6>
          B[ldb * i + j] *= alpha;
 8011a7a:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011a7e:	4622      	mov	r2, r4
 8011a80:	462b      	mov	r3, r5
 8011a82:	f017 f871 	bl	8028b68 <__aeabi_dmul>
 8011a86:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8011a8a:	42b7      	cmp	r7, r6
 8011a8c:	d1f5      	bne.n	8011a7a <cblas_dtrsm+0x8b2>
      for (i = 0; i < n1; i++) {
 8011a8e:	9b02      	ldr	r3, [sp, #8]
 8011a90:	f108 0801 	add.w	r8, r8, #1
 8011a94:	45c3      	cmp	fp, r8
 8011a96:	441f      	add	r7, r3
 8011a98:	d1e9      	bne.n	8011a6e <cblas_dtrsm+0x8a6>
 8011a9a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011a9c:	9903      	ldr	r1, [sp, #12]
 8011a9e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8011aa0:	900d      	str	r0, [sp, #52]	; 0x34
 8011aa2:	f103 0a01 	add.w	sl, r3, #1
 8011aa6:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8011aaa:	f1a3 0208 	sub.w	r2, r3, #8
 8011aae:	9310      	str	r3, [sp, #64]	; 0x40
 8011ab0:	9b01      	ldr	r3, [sp, #4]
 8011ab2:	920a      	str	r2, [sp, #40]	; 0x28
 8011ab4:	440b      	add	r3, r1
 8011ab6:	00db      	lsls	r3, r3, #3
 8011ab8:	2100      	movs	r1, #0
 8011aba:	1882      	adds	r2, r0, r2
 8011abc:	9311      	str	r3, [sp, #68]	; 0x44
 8011abe:	9b05      	ldr	r3, [sp, #20]
 8011ac0:	910f      	str	r1, [sp, #60]	; 0x3c
 8011ac2:	920b      	str	r2, [sp, #44]	; 0x2c
 8011ac4:	910c      	str	r1, [sp, #48]	; 0x30
 8011ac6:	9309      	str	r3, [sp, #36]	; 0x24
      if (nonunit) {
 8011ac8:	9b04      	ldr	r3, [sp, #16]
 8011aca:	2b83      	cmp	r3, #131	; 0x83
 8011acc:	d04c      	beq.n	8011b68 <cblas_dtrsm+0x9a0>
      for (k = i + 1; k < n1; k++) {
 8011ace:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011ad0:	9a06      	ldr	r2, [sp, #24]
 8011ad2:	3301      	adds	r3, #1
 8011ad4:	429a      	cmp	r2, r3
 8011ad6:	930c      	str	r3, [sp, #48]	; 0x30
 8011ad8:	f77f aebb 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011adc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8011ade:	9903      	ldr	r1, [sp, #12]
 8011ae0:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 8011ae4:	9308      	str	r3, [sp, #32]
 8011ae6:	440a      	add	r2, r1
 8011ae8:	920f      	str	r2, [sp, #60]	; 0x3c
 8011aea:	9911      	ldr	r1, [sp, #68]	; 0x44
 8011aec:	9207      	str	r2, [sp, #28]
 8011aee:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011af0:	eb02 0a01 	add.w	sl, r2, r1
        for (j = 0; j < n2; j++) {
 8011af4:	9b01      	ldr	r3, [sp, #4]
 8011af6:	2b00      	cmp	r3, #0
        const BASE Aki = A[k * lda + i];
 8011af8:	e9db 8900 	ldrd	r8, r9, [fp]
        for (j = 0; j < n2; j++) {
 8011afc:	dd16      	ble.n	8011b2c <cblas_dtrsm+0x964>
 8011afe:	9b05      	ldr	r3, [sp, #20]
 8011b00:	9a07      	ldr	r2, [sp, #28]
 8011b02:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8011b04:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 8011b08:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8011b0c:	4642      	mov	r2, r8
 8011b0e:	464b      	mov	r3, r9
 8011b10:	f017 f82a 	bl	8028b68 <__aeabi_dmul>
 8011b14:	e9d4 6700 	ldrd	r6, r7, [r4]
 8011b18:	4602      	mov	r2, r0
 8011b1a:	460b      	mov	r3, r1
 8011b1c:	4630      	mov	r0, r6
 8011b1e:	4639      	mov	r1, r7
 8011b20:	f016 fe6a 	bl	80287f8 <__aeabi_dsub>
 8011b24:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8011b28:	45a2      	cmp	sl, r4
 8011b2a:	d1ed      	bne.n	8011b08 <cblas_dtrsm+0x940>
      for (k = i + 1; k < n1; k++) {
 8011b2c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8011b2e:	9903      	ldr	r1, [sp, #12]
 8011b30:	9b08      	ldr	r3, [sp, #32]
 8011b32:	4493      	add	fp, r2
 8011b34:	9a07      	ldr	r2, [sp, #28]
 8011b36:	440a      	add	r2, r1
 8011b38:	9207      	str	r2, [sp, #28]
 8011b3a:	9a02      	ldr	r2, [sp, #8]
 8011b3c:	4492      	add	sl, r2
 8011b3e:	9a06      	ldr	r2, [sp, #24]
 8011b40:	3301      	adds	r3, #1
 8011b42:	429a      	cmp	r2, r3
 8011b44:	9308      	str	r3, [sp, #32]
 8011b46:	d1d5      	bne.n	8011af4 <cblas_dtrsm+0x92c>
 8011b48:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8011b4a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011b4c:	4611      	mov	r1, r2
 8011b4e:	4419      	add	r1, r3
 8011b50:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011b52:	910b      	str	r1, [sp, #44]	; 0x2c
 8011b54:	9902      	ldr	r1, [sp, #8]
 8011b56:	440a      	add	r2, r1
 8011b58:	9209      	str	r2, [sp, #36]	; 0x24
 8011b5a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8011b5c:	441a      	add	r2, r3
 8011b5e:	920d      	str	r2, [sp, #52]	; 0x34
 8011b60:	e7b2      	b.n	8011ac8 <cblas_dtrsm+0x900>
 8011b62:	bf00      	nop
 8011b64:	3ff00000 	.word	0x3ff00000
        BASE Aii = A[lda * i + i];
 8011b68:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8011b6a:	e9d3 6700 	ldrd	r6, r7, [r3]
        for (j = 0; j < n2; j++) {
 8011b6e:	9b01      	ldr	r3, [sp, #4]
 8011b70:	2b00      	cmp	r3, #0
 8011b72:	ddac      	ble.n	8011ace <cblas_dtrsm+0x906>
 8011b74:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8011b76:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011b78:	18e5      	adds	r5, r4, r3
          B[ldb * i + j] /= Aii;
 8011b7a:	e9d4 0100 	ldrd	r0, r1, [r4]
 8011b7e:	4632      	mov	r2, r6
 8011b80:	463b      	mov	r3, r7
 8011b82:	f017 f91b 	bl	8028dbc <__aeabi_ddiv>
 8011b86:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8011b8a:	42ac      	cmp	r4, r5
 8011b8c:	d1f5      	bne.n	8011b7a <cblas_dtrsm+0x9b2>
 8011b8e:	e79e      	b.n	8011ace <cblas_dtrsm+0x906>
    if (alpha != 1.0) {
 8011b90:	4baa      	ldr	r3, [pc, #680]	; (8011e3c <cblas_dtrsm+0xc74>)
 8011b92:	2200      	movs	r2, #0
 8011b94:	4620      	mov	r0, r4
 8011b96:	4629      	mov	r1, r5
 8011b98:	f017 fa4e 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 8011b9c:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8011b9e:	2800      	cmp	r0, #0
 8011ba0:	f040 8163 	bne.w	8011e6a <cblas_dtrsm+0xca2>
      for (i = 0; i < n1; i++) {
 8011ba4:	2b00      	cmp	r3, #0
 8011ba6:	f77f ae54 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011baa:	9a03      	ldr	r2, [sp, #12]
 8011bac:	9b01      	ldr	r3, [sp, #4]
 8011bae:	f8dd b018 	ldr.w	fp, [sp, #24]
 8011bb2:	00d2      	lsls	r2, r2, #3
 8011bb4:	9202      	str	r2, [sp, #8]
 8011bb6:	00da      	lsls	r2, r3, #3
 8011bb8:	920e      	str	r2, [sp, #56]	; 0x38
 8011bba:	9a05      	ldr	r2, [sp, #20]
 8011bbc:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011bc0:	4680      	mov	r8, r0
 8011bc2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8011bc6:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8011bca:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 8011bcc:	f1ba 0f00 	cmp.w	sl, #0
 8011bd0:	bfc8      	it	gt
 8011bd2:	eb07 0609 	addgt.w	r6, r7, r9
 8011bd6:	dd09      	ble.n	8011bec <cblas_dtrsm+0xa24>
          B[ldb * i + j] *= alpha;
 8011bd8:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011bdc:	4622      	mov	r2, r4
 8011bde:	462b      	mov	r3, r5
 8011be0:	f016 ffc2 	bl	8028b68 <__aeabi_dmul>
 8011be4:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8011be8:	42be      	cmp	r6, r7
 8011bea:	d1f5      	bne.n	8011bd8 <cblas_dtrsm+0xa10>
      for (i = 0; i < n1; i++) {
 8011bec:	9b02      	ldr	r3, [sp, #8]
 8011bee:	f108 0801 	add.w	r8, r8, #1
 8011bf2:	45c3      	cmp	fp, r8
 8011bf4:	441f      	add	r7, r3
 8011bf6:	d1e9      	bne.n	8011bcc <cblas_dtrsm+0xa04>
 8011bf8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011bfa:	9b05      	ldr	r3, [sp, #20]
 8011bfc:	930a      	str	r3, [sp, #40]	; 0x28
 8011bfe:	f102 0a01 	add.w	sl, r2, #1
 8011c02:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8011c04:	441a      	add	r2, r3
 8011c06:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8011c0a:	9309      	str	r3, [sp, #36]	; 0x24
          for (k = j + 1; k < n2; k++) {
 8011c0c:	2300      	movs	r3, #0
 8011c0e:	4693      	mov	fp, r2
 8011c10:	930b      	str	r3, [sp, #44]	; 0x2c
      for (j = 0; j < n2; j++) {
 8011c12:	9b01      	ldr	r3, [sp, #4]
 8011c14:	2b00      	cmp	r3, #0
 8011c16:	dd3e      	ble.n	8011c96 <cblas_dtrsm+0xace>
 8011c18:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011c1a:	9305      	str	r3, [sp, #20]
 8011c1c:	461a      	mov	r2, r3
 8011c1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011c20:	e9cd 3307 	strd	r3, r3, [sp, #28]
 8011c24:	3208      	adds	r2, #8
 8011c26:	9203      	str	r2, [sp, #12]
 8011c28:	f04f 0a00 	mov.w	sl, #0
        if (nonunit) {
 8011c2c:	9b04      	ldr	r3, [sp, #16]
 8011c2e:	2b83      	cmp	r3, #131	; 0x83
 8011c30:	d109      	bne.n	8011c46 <cblas_dtrsm+0xa7e>
          B[ldb * i + j] /= Ajj;
 8011c32:	9c07      	ldr	r4, [sp, #28]
 8011c34:	9b05      	ldr	r3, [sp, #20]
 8011c36:	e9d4 0100 	ldrd	r0, r1, [r4]
 8011c3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011c3e:	f017 f8bd 	bl	8028dbc <__aeabi_ddiv>
 8011c42:	e9c4 0100 	strd	r0, r1, [r4]
          BASE Bij = B[ldb * i + j];
 8011c46:	9c08      	ldr	r4, [sp, #32]
          for (k = j + 1; k < n2; k++) {
 8011c48:	9b01      	ldr	r3, [sp, #4]
          BASE Bij = B[ldb * i + j];
 8011c4a:	e8f4 8902 	ldrd	r8, r9, [r4], #8
          for (k = j + 1; k < n2; k++) {
 8011c4e:	f10a 0a01 	add.w	sl, sl, #1
 8011c52:	4553      	cmp	r3, sl
          BASE Bij = B[ldb * i + j];
 8011c54:	9408      	str	r4, [sp, #32]
          for (k = j + 1; k < n2; k++) {
 8011c56:	d01e      	beq.n	8011c96 <cblas_dtrsm+0xace>
 8011c58:	9d03      	ldr	r5, [sp, #12]
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 8011c5a:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8011c5e:	4642      	mov	r2, r8
 8011c60:	464b      	mov	r3, r9
 8011c62:	f016 ff81 	bl	8028b68 <__aeabi_dmul>
 8011c66:	e9d4 6700 	ldrd	r6, r7, [r4]
 8011c6a:	4602      	mov	r2, r0
 8011c6c:	460b      	mov	r3, r1
 8011c6e:	4630      	mov	r0, r6
 8011c70:	4639      	mov	r1, r7
 8011c72:	f016 fdc1 	bl	80287f8 <__aeabi_dsub>
 8011c76:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = j + 1; k < n2; k++) {
 8011c7a:	455c      	cmp	r4, fp
 8011c7c:	d1ed      	bne.n	8011c5a <cblas_dtrsm+0xa92>
 8011c7e:	9a03      	ldr	r2, [sp, #12]
 8011c80:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011c82:	4611      	mov	r1, r2
 8011c84:	9a05      	ldr	r2, [sp, #20]
 8011c86:	4419      	add	r1, r3
 8011c88:	441a      	add	r2, r3
 8011c8a:	9b07      	ldr	r3, [sp, #28]
 8011c8c:	9103      	str	r1, [sp, #12]
 8011c8e:	3308      	adds	r3, #8
 8011c90:	9205      	str	r2, [sp, #20]
 8011c92:	9307      	str	r3, [sp, #28]
 8011c94:	e7ca      	b.n	8011c2c <cblas_dtrsm+0xa64>
    for (i = 0; i < n1; i++) {
 8011c96:	990a      	ldr	r1, [sp, #40]	; 0x28
 8011c98:	9a02      	ldr	r2, [sp, #8]
 8011c9a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011c9c:	4608      	mov	r0, r1
 8011c9e:	4410      	add	r0, r2
 8011ca0:	4493      	add	fp, r2
 8011ca2:	9a06      	ldr	r2, [sp, #24]
 8011ca4:	900a      	str	r0, [sp, #40]	; 0x28
 8011ca6:	3301      	adds	r3, #1
 8011ca8:	429a      	cmp	r2, r3
 8011caa:	930b      	str	r3, [sp, #44]	; 0x2c
 8011cac:	dcb1      	bgt.n	8011c12 <cblas_dtrsm+0xa4a>
 8011cae:	e5d0      	b.n	8011852 <cblas_dtrsm+0x68a>
    if (alpha != 1.0) {
 8011cb0:	4b62      	ldr	r3, [pc, #392]	; (8011e3c <cblas_dtrsm+0xc74>)
 8011cb2:	2200      	movs	r2, #0
 8011cb4:	4620      	mov	r0, r4
 8011cb6:	4629      	mov	r1, r5
 8011cb8:	f017 f9be 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 8011cbc:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8011cbe:	2800      	cmp	r0, #0
 8011cc0:	f040 80c9 	bne.w	8011e56 <cblas_dtrsm+0xc8e>
      for (i = 0; i < n1; i++) {
 8011cc4:	2b00      	cmp	r3, #0
 8011cc6:	f77f adc4 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011cca:	9a03      	ldr	r2, [sp, #12]
 8011ccc:	9b01      	ldr	r3, [sp, #4]
 8011cce:	f8dd b018 	ldr.w	fp, [sp, #24]
 8011cd2:	00d2      	lsls	r2, r2, #3
 8011cd4:	9202      	str	r2, [sp, #8]
 8011cd6:	00da      	lsls	r2, r3, #3
 8011cd8:	920e      	str	r2, [sp, #56]	; 0x38
 8011cda:	9a05      	ldr	r2, [sp, #20]
 8011cdc:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011ce0:	4680      	mov	r8, r0
 8011ce2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8011ce6:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8011cea:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 8011cec:	f1ba 0f00 	cmp.w	sl, #0
 8011cf0:	bfc8      	it	gt
 8011cf2:	eb07 0609 	addgt.w	r6, r7, r9
 8011cf6:	dd09      	ble.n	8011d0c <cblas_dtrsm+0xb44>
          B[ldb * i + j] *= alpha;
 8011cf8:	e9d6 0100 	ldrd	r0, r1, [r6]
 8011cfc:	4622      	mov	r2, r4
 8011cfe:	462b      	mov	r3, r5
 8011d00:	f016 ff32 	bl	8028b68 <__aeabi_dmul>
 8011d04:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8011d08:	42be      	cmp	r6, r7
 8011d0a:	d1f5      	bne.n	8011cf8 <cblas_dtrsm+0xb30>
      for (i = 0; i < n1; i++) {
 8011d0c:	9b02      	ldr	r3, [sp, #8]
 8011d0e:	f108 0801 	add.w	r8, r8, #1
 8011d12:	45c3      	cmp	fp, r8
 8011d14:	441f      	add	r7, r3
 8011d16:	d1e9      	bne.n	8011cec <cblas_dtrsm+0xb24>
 8011d18:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8011d1a:	9c05      	ldr	r4, [sp, #20]
 8011d1c:	9b01      	ldr	r3, [sp, #4]
 8011d1e:	9407      	str	r4, [sp, #28]
 8011d20:	4610      	mov	r0, r2
 8011d22:	ea6f 0a00 	mvn.w	sl, r0
 8011d26:	980e      	ldr	r0, [sp, #56]	; 0x38
 8011d28:	4420      	add	r0, r4
 8011d2a:	3b01      	subs	r3, #1
 8011d2c:	900a      	str	r0, [sp, #40]	; 0x28
 8011d2e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8011d30:	fb02 f103 	mul.w	r1, r2, r3
 8011d34:	fb02 3303 	mla	r3, r2, r3, r3
 8011d38:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8011d3c:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8011d40:	930d      	str	r3, [sp, #52]	; 0x34
 8011d42:	00d3      	lsls	r3, r2, #3
 8011d44:	9309      	str	r3, [sp, #36]	; 0x24
 8011d46:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8011d4a:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 8011d4e:	9308      	str	r3, [sp, #32]
      for (j = n2; j > 0 && j--;) {
 8011d50:	2300      	movs	r3, #0
 8011d52:	910c      	str	r1, [sp, #48]	; 0x30
 8011d54:	930b      	str	r3, [sp, #44]	; 0x2c
 8011d56:	9b01      	ldr	r3, [sp, #4]
 8011d58:	2b00      	cmp	r3, #0
 8011d5a:	dd35      	ble.n	8011dc8 <cblas_dtrsm+0xc00>
 8011d5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011d5e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8011d60:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 8011d64:	9305      	str	r3, [sp, #20]
 8011d66:	9203      	str	r2, [sp, #12]
 8011d68:	469a      	mov	sl, r3
        if (nonunit) {
 8011d6a:	9b04      	ldr	r3, [sp, #16]
 8011d6c:	2b83      	cmp	r3, #131	; 0x83
 8011d6e:	d109      	bne.n	8011d84 <cblas_dtrsm+0xbbc>
          B[ldb * i + j] /= Ajj;
 8011d70:	9c05      	ldr	r4, [sp, #20]
 8011d72:	9b03      	ldr	r3, [sp, #12]
 8011d74:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8011d78:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011d7c:	f017 f81e 	bl	8028dbc <__aeabi_ddiv>
 8011d80:	e944 0102 	strd	r0, r1, [r4, #-8]
          BASE Bij = B[ldb * i + j];
 8011d84:	e97a 8902 	ldrd	r8, r9, [sl, #-8]!
          for (k = 0; k < j; k++) {
 8011d88:	9c07      	ldr	r4, [sp, #28]
 8011d8a:	45a2      	cmp	sl, r4
 8011d8c:	d01c      	beq.n	8011dc8 <cblas_dtrsm+0xc00>
 8011d8e:	465d      	mov	r5, fp
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 8011d90:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8011d94:	4642      	mov	r2, r8
 8011d96:	464b      	mov	r3, r9
 8011d98:	f016 fee6 	bl	8028b68 <__aeabi_dmul>
 8011d9c:	e9d4 6700 	ldrd	r6, r7, [r4]
 8011da0:	4602      	mov	r2, r0
 8011da2:	460b      	mov	r3, r1
 8011da4:	4630      	mov	r0, r6
 8011da6:	4639      	mov	r1, r7
 8011da8:	f016 fd26 	bl	80287f8 <__aeabi_dsub>
 8011dac:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = 0; k < j; k++) {
 8011db0:	4554      	cmp	r4, sl
 8011db2:	d1ed      	bne.n	8011d90 <cblas_dtrsm+0xbc8>
 8011db4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8011db6:	9a08      	ldr	r2, [sp, #32]
 8011db8:	449b      	add	fp, r3
 8011dba:	9b03      	ldr	r3, [sp, #12]
 8011dbc:	4413      	add	r3, r2
 8011dbe:	9303      	str	r3, [sp, #12]
 8011dc0:	9b05      	ldr	r3, [sp, #20]
 8011dc2:	3b08      	subs	r3, #8
 8011dc4:	9305      	str	r3, [sp, #20]
 8011dc6:	e7d0      	b.n	8011d6a <cblas_dtrsm+0xba2>
    for (i = 0; i < n1; i++) {
 8011dc8:	9907      	ldr	r1, [sp, #28]
 8011dca:	9a02      	ldr	r2, [sp, #8]
 8011dcc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011dce:	4608      	mov	r0, r1
 8011dd0:	990a      	ldr	r1, [sp, #40]	; 0x28
 8011dd2:	4410      	add	r0, r2
 8011dd4:	4411      	add	r1, r2
 8011dd6:	9a06      	ldr	r2, [sp, #24]
 8011dd8:	9007      	str	r0, [sp, #28]
 8011dda:	3301      	adds	r3, #1
 8011ddc:	429a      	cmp	r2, r3
 8011dde:	930b      	str	r3, [sp, #44]	; 0x2c
 8011de0:	910a      	str	r1, [sp, #40]	; 0x28
 8011de2:	dcb8      	bgt.n	8011d56 <cblas_dtrsm+0xb8e>
 8011de4:	e535      	b.n	8011852 <cblas_dtrsm+0x68a>
    for (i = 0; i < n1; i++) {
 8011de6:	2b00      	cmp	r3, #0
 8011de8:	f77f ad33 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011dec:	9b03      	ldr	r3, [sp, #12]
 8011dee:	00db      	lsls	r3, r3, #3
 8011df0:	9302      	str	r3, [sp, #8]
 8011df2:	9b01      	ldr	r3, [sp, #4]
 8011df4:	00db      	lsls	r3, r3, #3
 8011df6:	930e      	str	r3, [sp, #56]	; 0x38
 8011df8:	e413      	b.n	8011622 <cblas_dtrsm+0x45a>
    for (i = 0; i < n1; i++) {
 8011dfa:	9b06      	ldr	r3, [sp, #24]
 8011dfc:	2b00      	cmp	r3, #0
 8011dfe:	f77f ad28 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e02:	9b03      	ldr	r3, [sp, #12]
 8011e04:	00db      	lsls	r3, r3, #3
 8011e06:	9302      	str	r3, [sp, #8]
 8011e08:	9b01      	ldr	r3, [sp, #4]
 8011e0a:	00db      	lsls	r3, r3, #3
 8011e0c:	930e      	str	r3, [sp, #56]	; 0x38
 8011e0e:	e644      	b.n	8011a9a <cblas_dtrsm+0x8d2>
    for (i = n1; i > 0 && i--;) {
 8011e10:	2b00      	cmp	r3, #0
 8011e12:	f77f ad1e 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e16:	9b03      	ldr	r3, [sp, #12]
 8011e18:	00db      	lsls	r3, r3, #3
 8011e1a:	9302      	str	r3, [sp, #8]
 8011e1c:	9b01      	ldr	r3, [sp, #4]
 8011e1e:	00db      	lsls	r3, r3, #3
 8011e20:	930e      	str	r3, [sp, #56]	; 0x38
 8011e22:	f7ff ba9a 	b.w	801135a <cblas_dtrsm+0x192>
    for (i = n1; i > 0 && i--;) {
 8011e26:	2b00      	cmp	r3, #0
 8011e28:	f77f ad13 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e2c:	9b03      	ldr	r3, [sp, #12]
 8011e2e:	00db      	lsls	r3, r3, #3
 8011e30:	9302      	str	r3, [sp, #8]
 8011e32:	9b01      	ldr	r3, [sp, #4]
 8011e34:	00db      	lsls	r3, r3, #3
 8011e36:	930e      	str	r3, [sp, #56]	; 0x38
 8011e38:	e581      	b.n	801193e <cblas_dtrsm+0x776>
 8011e3a:	bf00      	nop
 8011e3c:	3ff00000 	.word	0x3ff00000
    for (i = 0; i < n1; i++) {
 8011e40:	9b06      	ldr	r3, [sp, #24]
 8011e42:	2b00      	cmp	r3, #0
 8011e44:	f77f ad05 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e48:	9b03      	ldr	r3, [sp, #12]
 8011e4a:	00db      	lsls	r3, r3, #3
 8011e4c:	9302      	str	r3, [sp, #8]
 8011e4e:	9b01      	ldr	r3, [sp, #4]
 8011e50:	00db      	lsls	r3, r3, #3
 8011e52:	930e      	str	r3, [sp, #56]	; 0x38
 8011e54:	e483      	b.n	801175e <cblas_dtrsm+0x596>
    for (i = 0; i < n1; i++) {
 8011e56:	2b00      	cmp	r3, #0
 8011e58:	f77f acfb 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e5c:	9b03      	ldr	r3, [sp, #12]
 8011e5e:	00db      	lsls	r3, r3, #3
 8011e60:	9302      	str	r3, [sp, #8]
 8011e62:	9b01      	ldr	r3, [sp, #4]
 8011e64:	00db      	lsls	r3, r3, #3
 8011e66:	930e      	str	r3, [sp, #56]	; 0x38
 8011e68:	e756      	b.n	8011d18 <cblas_dtrsm+0xb50>
    for (i = 0; i < n1; i++) {
 8011e6a:	2b00      	cmp	r3, #0
 8011e6c:	f77f acf1 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e70:	9b03      	ldr	r3, [sp, #12]
 8011e72:	00db      	lsls	r3, r3, #3
 8011e74:	9302      	str	r3, [sp, #8]
 8011e76:	9b01      	ldr	r3, [sp, #4]
 8011e78:	00db      	lsls	r3, r3, #3
 8011e7a:	930e      	str	r3, [sp, #56]	; 0x38
 8011e7c:	e6bc      	b.n	8011bf8 <cblas_dtrsm+0xa30>
    for (i = 0; i < n1; i++) {
 8011e7e:	2b00      	cmp	r3, #0
 8011e80:	f77f ace7 	ble.w	8011852 <cblas_dtrsm+0x68a>
 8011e84:	9b03      	ldr	r3, [sp, #12]
 8011e86:	00db      	lsls	r3, r3, #3
 8011e88:	9302      	str	r3, [sp, #8]
 8011e8a:	9b01      	ldr	r3, [sp, #4]
 8011e8c:	00db      	lsls	r3, r3, #3
 8011e8e:	930e      	str	r3, [sp, #56]	; 0x38
 8011e90:	f7ff bb32 	b.w	80114f8 <cblas_dtrsm+0x330>

08011e94 <cblas_dtrsv>:
void
cblas_dtrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const double *A, const int lda, double *X,
             const int incX)
{
 8011e94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011e98:	b08b      	sub	sp, #44	; 0x2c
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8011e9a:	2a71      	cmp	r2, #113	; 0x71
 8011e9c:	9300      	str	r3, [sp, #0]
 8011e9e:	e9dd b314 	ldrd	fp, r3, [sp, #80]	; 0x50
 8011ea2:	9302      	str	r3, [sp, #8]
 8011ea4:	e9dd a316 	ldrd	sl, r3, [sp, #88]	; 0x58
 8011ea8:	9303      	str	r3, [sp, #12]
 8011eaa:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8011eac:	9301      	str	r3, [sp, #4]
 8011eae:	4605      	mov	r5, r0
 8011eb0:	460c      	mov	r4, r1
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011eb2:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8011eb6:	f000 80e9 	beq.w	801208c <cblas_dtrsv+0x1f8>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011eba:	2b01      	cmp	r3, #1
 8011ebc:	4616      	mov	r6, r2
 8011ebe:	d939      	bls.n	8011f34 <cblas_dtrsv+0xa0>
 8011ec0:	2002      	movs	r0, #2
 8011ec2:	3a6f      	subs	r2, #111	; 0x6f
 8011ec4:	2a02      	cmp	r2, #2
 8011ec6:	bf88      	it	hi
 8011ec8:	2003      	movhi	r0, #3
 8011eca:	9b00      	ldr	r3, [sp, #0]
 8011ecc:	337d      	adds	r3, #125	; 0x7d
 8011ece:	b2db      	uxtb	r3, r3
 8011ed0:	2b01      	cmp	r3, #1
 8011ed2:	f240 80c9 	bls.w	8012068 <cblas_dtrsv+0x1d4>
 8011ed6:	f1bb 0f00 	cmp.w	fp, #0
 8011eda:	f2c0 80bb 	blt.w	8012054 <cblas_dtrsv+0x1c0>
 8011ede:	465b      	mov	r3, fp
 8011ee0:	2b01      	cmp	r3, #1
 8011ee2:	bfb8      	it	lt
 8011ee4:	2301      	movlt	r3, #1
 8011ee6:	459a      	cmp	sl, r3
 8011ee8:	f280 8176 	bge.w	80121d8 <cblas_dtrsv+0x344>
 8011eec:	9b01      	ldr	r3, [sp, #4]
 8011eee:	2b00      	cmp	r3, #0
 8011ef0:	bf0c      	ite	eq
 8011ef2:	2009      	moveq	r0, #9
 8011ef4:	2007      	movne	r0, #7
 8011ef6:	4ab5      	ldr	r2, [pc, #724]	; (80121cc <cblas_dtrsv+0x338>)
 8011ef8:	49b5      	ldr	r1, [pc, #724]	; (80121d0 <cblas_dtrsv+0x33c>)
 8011efa:	f016 fc05 	bl	8028708 <cblas_xerbla>
  if (N == 0)
 8011efe:	f1bb 0f00 	cmp.w	fp, #0
 8011f02:	f000 80a4 	beq.w	801204e <cblas_dtrsv+0x1ba>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8011f06:	2d65      	cmp	r5, #101	; 0x65
 8011f08:	f000 80c6 	beq.w	8012098 <cblas_dtrsv+0x204>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8011f0c:	2d66      	cmp	r5, #102	; 0x66
 8011f0e:	d109      	bne.n	8011f24 <cblas_dtrsv+0x90>
 8011f10:	2e70      	cmp	r6, #112	; 0x70
 8011f12:	d015      	beq.n	8011f40 <cblas_dtrsv+0xac>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8011f14:	2e6f      	cmp	r6, #111	; 0x6f
 8011f16:	d105      	bne.n	8011f24 <cblas_dtrsv+0x90>
 8011f18:	2c7a      	cmp	r4, #122	; 0x7a
 8011f1a:	f000 81d9 	beq.w	80122d0 <cblas_dtrsv+0x43c>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 8011f1e:	2c79      	cmp	r4, #121	; 0x79
 8011f20:	f000 80c6 	beq.w	80120b0 <cblas_dtrsv+0x21c>
    BLAS_ERROR("unrecognized operation");
 8011f24:	4aab      	ldr	r2, [pc, #684]	; (80121d4 <cblas_dtrsv+0x340>)
 8011f26:	49aa      	ldr	r1, [pc, #680]	; (80121d0 <cblas_dtrsv+0x33c>)
 8011f28:	2000      	movs	r0, #0
#define BASE double
#include "source_trsv_r.h"
#undef BASE
}
 8011f2a:	b00b      	add	sp, #44	; 0x2c
 8011f2c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011f30:	f016 bbea 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011f34:	3865      	subs	r0, #101	; 0x65
 8011f36:	2801      	cmp	r0, #1
 8011f38:	bf94      	ite	ls
 8011f3a:	2000      	movls	r0, #0
 8011f3c:	2001      	movhi	r0, #1
 8011f3e:	e7c0      	b.n	8011ec2 <cblas_dtrsv+0x2e>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8011f40:	2c7a      	cmp	r4, #122	; 0x7a
 8011f42:	f040 81ba 	bne.w	80122ba <cblas_dtrsv+0x426>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8011f46:	9b01      	ldr	r3, [sp, #4]
 8011f48:	2b00      	cmp	r3, #0
 8011f4a:	bfd8      	it	le
 8011f4c:	9b01      	ldrle	r3, [sp, #4]
 8011f4e:	f10b 35ff 	add.w	r5, fp, #4294967295
 8011f52:	bfd8      	it	le
 8011f54:	425e      	negle	r6, r3
 8011f56:	9b01      	ldr	r3, [sp, #4]
 8011f58:	bfcc      	ite	gt
 8011f5a:	2600      	movgt	r6, #0
 8011f5c:	436e      	mulle	r6, r5
 8011f5e:	fb05 6603 	mla	r6, r5, r3, r6
    if (nonunit) {
 8011f62:	9b00      	ldr	r3, [sp, #0]
 8011f64:	2b83      	cmp	r3, #131	; 0x83
 8011f66:	d10f      	bne.n	8011f88 <cblas_dtrsv+0xf4>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 8011f68:	9a02      	ldr	r2, [sp, #8]
 8011f6a:	fb05 530a 	mla	r3, r5, sl, r5
 8011f6e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8011f72:	9a03      	ldr	r2, [sp, #12]
 8011f74:	eb02 04c6 	add.w	r4, r2, r6, lsl #3
 8011f78:	e9d4 0100 	ldrd	r0, r1, [r4]
 8011f7c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011f80:	f016 ff1c 	bl	8028dbc <__aeabi_ddiv>
 8011f84:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N - 1; i > 0 && i--;) {
 8011f88:	2d00      	cmp	r5, #0
 8011f8a:	dd60      	ble.n	801204e <cblas_dtrsv+0x1ba>
 8011f8c:	1e6b      	subs	r3, r5, #1
 8011f8e:	fb0a f803 	mul.w	r8, sl, r3
 8011f92:	fb0a 3303 	mla	r3, sl, r3, r3
 8011f96:	00db      	lsls	r3, r3, #3
 8011f98:	eb08 0205 	add.w	r2, r8, r5
 8011f9c:	9306      	str	r3, [sp, #24]
 8011f9e:	9b02      	ldr	r3, [sp, #8]
 8011fa0:	9c03      	ldr	r4, [sp, #12]
 8011fa2:	9504      	str	r5, [sp, #16]
 8011fa4:	44d8      	add	r8, fp
 8011fa6:	ebc2 7042 	rsb	r0, r2, r2, lsl #29
 8011faa:	9d01      	ldr	r5, [sp, #4]
 8011fac:	f8cd b014 	str.w	fp, [sp, #20]
 8011fb0:	ea6f 010a 	mvn.w	r1, sl
 8011fb4:	461f      	mov	r7, r3
 8011fb6:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 8011fba:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011fbe:	00c2      	lsls	r2, r0, #3
 8011fc0:	ebca 7a4a 	rsb	sl, sl, sl, lsl #29
 8011fc4:	9207      	str	r2, [sp, #28]
 8011fc6:	00ca      	lsls	r2, r1, #3
 8011fc8:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
 8011fcc:	9201      	str	r2, [sp, #4]
 8011fce:	ebc5 7445 	rsb	r4, r5, r5, lsl #29
 8011fd2:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 8011fd6:	9203      	str	r2, [sp, #12]
 8011fd8:	00e2      	lsls	r2, r4, #3
 8011fda:	9202      	str	r2, [sp, #8]
 8011fdc:	ea4f 09c5 	mov.w	r9, r5, lsl #3
 8011fe0:	469b      	mov	fp, r3
      BASE tmp = X[ix];
 8011fe2:	9b02      	ldr	r3, [sp, #8]
 8011fe4:	eb06 0a03 	add.w	sl, r6, r3
      for (j = i + 1; j < N; j++) {
 8011fe8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8011fec:	4293      	cmp	r3, r2
      BASE tmp = X[ix];
 8011fee:	e9da 4500 	ldrd	r4, r5, [sl]
      for (j = i + 1; j < N; j++) {
 8011ff2:	bfc8      	it	gt
 8011ff4:	465f      	movgt	r7, fp
 8011ff6:	dd10      	ble.n	801201a <cblas_dtrsv+0x186>
        tmp -= Aij * X[jx];
 8011ff8:	e9d6 2300 	ldrd	r2, r3, [r6]
 8011ffc:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 8012000:	f016 fdb2 	bl	8028b68 <__aeabi_dmul>
 8012004:	4602      	mov	r2, r0
 8012006:	460b      	mov	r3, r1
 8012008:	4620      	mov	r0, r4
 801200a:	4629      	mov	r1, r5
 801200c:	f016 fbf4 	bl	80287f8 <__aeabi_dsub>
      for (j = i + 1; j < N; j++) {
 8012010:	45b8      	cmp	r8, r7
 8012012:	444e      	add	r6, r9
        tmp -= Aij * X[jx];
 8012014:	4604      	mov	r4, r0
 8012016:	460d      	mov	r5, r1
      for (j = i + 1; j < N; j++) {
 8012018:	d1ee      	bne.n	8011ff8 <cblas_dtrsv+0x164>
      if (nonunit) {
 801201a:	9b00      	ldr	r3, [sp, #0]
 801201c:	2b83      	cmp	r3, #131	; 0x83
 801201e:	d10b      	bne.n	8012038 <cblas_dtrsv+0x1a4>
        X[ix] = tmp / A[lda * i + i];
 8012020:	9b07      	ldr	r3, [sp, #28]
 8012022:	9a06      	ldr	r2, [sp, #24]
 8012024:	445b      	add	r3, fp
 8012026:	4413      	add	r3, r2
 8012028:	4620      	mov	r0, r4
 801202a:	4629      	mov	r1, r5
 801202c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012030:	f016 fec4 	bl	8028dbc <__aeabi_ddiv>
 8012034:	4604      	mov	r4, r0
 8012036:	460d      	mov	r5, r1
 8012038:	9b01      	ldr	r3, [sp, #4]
 801203a:	449b      	add	fp, r3
 801203c:	9b03      	ldr	r3, [sp, #12]
 801203e:	4498      	add	r8, r3
    for (i = N - 1; i > 0 && i--;) {
 8012040:	9b04      	ldr	r3, [sp, #16]
 8012042:	3b01      	subs	r3, #1
 8012044:	e9ca 4500 	strd	r4, r5, [sl]
 8012048:	4656      	mov	r6, sl
 801204a:	9304      	str	r3, [sp, #16]
 801204c:	d1c9      	bne.n	8011fe2 <cblas_dtrsv+0x14e>
 801204e:	b00b      	add	sp, #44	; 0x2c
 8012050:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8012054:	f1ba 0f00 	cmp.w	sl, #0
 8012058:	f77f af48 	ble.w	8011eec <cblas_dtrsv+0x58>
 801205c:	9b01      	ldr	r3, [sp, #4]
 801205e:	2b00      	cmp	r3, #0
 8012060:	bf0c      	ite	eq
 8012062:	2009      	moveq	r0, #9
 8012064:	2005      	movne	r0, #5
 8012066:	e746      	b.n	8011ef6 <cblas_dtrsv+0x62>
 8012068:	f1bb 0f00 	cmp.w	fp, #0
 801206c:	dbf2      	blt.n	8012054 <cblas_dtrsv+0x1c0>
 801206e:	465b      	mov	r3, fp
 8012070:	2b01      	cmp	r3, #1
 8012072:	bfb8      	it	lt
 8012074:	2301      	movlt	r3, #1
 8012076:	4553      	cmp	r3, sl
 8012078:	f73f af38 	bgt.w	8011eec <cblas_dtrsv+0x58>
 801207c:	9b01      	ldr	r3, [sp, #4]
 801207e:	2b00      	cmp	r3, #0
 8012080:	f000 818e 	beq.w	80123a0 <cblas_dtrsv+0x50c>
 8012084:	2800      	cmp	r0, #0
 8012086:	f43f af3a 	beq.w	8011efe <cblas_dtrsv+0x6a>
 801208a:	e734      	b.n	8011ef6 <cblas_dtrsv+0x62>
 801208c:	2b01      	cmp	r3, #1
 801208e:	f240 8118 	bls.w	80122c2 <cblas_dtrsv+0x42e>
 8012092:	2670      	movs	r6, #112	; 0x70
 8012094:	2002      	movs	r0, #2
 8012096:	e718      	b.n	8011eca <cblas_dtrsv+0x36>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8012098:	2e6f      	cmp	r6, #111	; 0x6f
 801209a:	f000 80a3 	beq.w	80121e4 <cblas_dtrsv+0x350>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 801209e:	2e70      	cmp	r6, #112	; 0x70
 80120a0:	f47f af40 	bne.w	8011f24 <cblas_dtrsv+0x90>
 80120a4:	2c79      	cmp	r4, #121	; 0x79
 80120a6:	f000 8113 	beq.w	80122d0 <cblas_dtrsv+0x43c>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 80120aa:	2c7a      	cmp	r4, #122	; 0x7a
 80120ac:	f47f af3a 	bne.w	8011f24 <cblas_dtrsv+0x90>
    ix = OFFSET(N, incX) + (N - 1) * incX;
 80120b0:	9b01      	ldr	r3, [sp, #4]
 80120b2:	2b00      	cmp	r3, #0
 80120b4:	bfd8      	it	le
 80120b6:	9a01      	ldrle	r2, [sp, #4]
 80120b8:	f10b 33ff 	add.w	r3, fp, #4294967295
 80120bc:	bfd8      	it	le
 80120be:	4254      	negle	r4, r2
 80120c0:	9305      	str	r3, [sp, #20]
 80120c2:	bfd8      	it	le
 80120c4:	435c      	mulle	r4, r3
 80120c6:	9a05      	ldr	r2, [sp, #20]
 80120c8:	9b01      	ldr	r3, [sp, #4]
 80120ca:	bfc8      	it	gt
 80120cc:	2400      	movgt	r4, #0
 80120ce:	fb02 4403 	mla	r4, r2, r3, r4
    if (nonunit) {
 80120d2:	9b00      	ldr	r3, [sp, #0]
 80120d4:	2b83      	cmp	r3, #131	; 0x83
 80120d6:	d10f      	bne.n	80120f8 <cblas_dtrsv+0x264>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 80120d8:	fb02 230a 	mla	r3, r2, sl, r2
 80120dc:	9a02      	ldr	r2, [sp, #8]
 80120de:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80120e2:	9a03      	ldr	r2, [sp, #12]
 80120e4:	eb02 05c4 	add.w	r5, r2, r4, lsl #3
 80120e8:	e9d5 0100 	ldrd	r0, r1, [r5]
 80120ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80120f0:	f016 fe64 	bl	8028dbc <__aeabi_ddiv>
 80120f4:	e9c5 0100 	strd	r0, r1, [r5]
    for (i = N - 1; i > 0 && i--;) {
 80120f8:	9805      	ldr	r0, [sp, #20]
    ix -= incX;
 80120fa:	9d01      	ldr	r5, [sp, #4]
    for (i = N - 1; i > 0 && i--;) {
 80120fc:	2800      	cmp	r0, #0
    ix -= incX;
 80120fe:	eba4 0405 	sub.w	r4, r4, r5
    for (i = N - 1; i > 0 && i--;) {
 8012102:	dda4      	ble.n	801204e <cblas_dtrsv+0x1ba>
 8012104:	f10a 0301 	add.w	r3, sl, #1
 8012108:	4602      	mov	r2, r0
 801210a:	fb02 f203 	mul.w	r2, r2, r3
 801210e:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8012112:	9f03      	ldr	r7, [sp, #12]
 8012114:	00d2      	lsls	r2, r2, #3
 8012116:	9208      	str	r2, [sp, #32]
 8012118:	9a02      	ldr	r2, [sp, #8]
 801211a:	00db      	lsls	r3, r3, #3
 801211c:	ea6f 0a0a 	mvn.w	sl, sl
 8012120:	1e46      	subs	r6, r0, #1
 8012122:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 8012126:	fb00 2203 	mla	r2, r0, r3, r2
 801212a:	ebc5 7145 	rsb	r1, r5, r5, lsl #29
 801212e:	9401      	str	r4, [sp, #4]
 8012130:	ea4f 04ca 	mov.w	r4, sl, lsl #3
 8012134:	f1a3 0a08 	sub.w	sl, r3, #8
 8012138:	fb03 f306 	mul.w	r3, r3, r6
 801213c:	9307      	str	r3, [sp, #28]
 801213e:	00cb      	lsls	r3, r1, #3
 8012140:	9604      	str	r6, [sp, #16]
 8012142:	9403      	str	r4, [sp, #12]
 8012144:	9202      	str	r2, [sp, #8]
 8012146:	9306      	str	r3, [sp, #24]
 8012148:	ea4f 09c5 	mov.w	r9, r5, lsl #3
 801214c:	9e05      	ldr	r6, [sp, #20]
      BASE tmp = X[ix];
 801214e:	9b01      	ldr	r3, [sp, #4]
      for (j = i + 1; j < N; j++) {
 8012150:	45b3      	cmp	fp, r6
      BASE tmp = X[ix];
 8012152:	e9d3 4500 	ldrd	r4, r5, [r3]
    for (i = N - 1; i > 0 && i--;) {
 8012156:	9b04      	ldr	r3, [sp, #16]
 8012158:	9305      	str	r3, [sp, #20]
      for (j = i + 1; j < N; j++) {
 801215a:	dd16      	ble.n	801218a <cblas_dtrsv+0x2f6>
 801215c:	9b01      	ldr	r3, [sp, #4]
 801215e:	9f02      	ldr	r7, [sp, #8]
 8012160:	eb09 0803 	add.w	r8, r9, r3
        tmp -= Aji * X[jx];
 8012164:	e957 2302 	ldrd	r2, r3, [r7, #-8]
 8012168:	e9d8 0100 	ldrd	r0, r1, [r8]
 801216c:	f016 fcfc 	bl	8028b68 <__aeabi_dmul>
 8012170:	4602      	mov	r2, r0
 8012172:	460b      	mov	r3, r1
 8012174:	4620      	mov	r0, r4
 8012176:	4629      	mov	r1, r5
 8012178:	f016 fb3e 	bl	80287f8 <__aeabi_dsub>
      for (j = i + 1; j < N; j++) {
 801217c:	3601      	adds	r6, #1
 801217e:	45b3      	cmp	fp, r6
 8012180:	4457      	add	r7, sl
        tmp -= Aji * X[jx];
 8012182:	4604      	mov	r4, r0
 8012184:	460d      	mov	r5, r1
      for (j = i + 1; j < N; j++) {
 8012186:	44c8      	add	r8, r9
 8012188:	d1ec      	bne.n	8012164 <cblas_dtrsv+0x2d0>
      if (nonunit) {
 801218a:	9b00      	ldr	r3, [sp, #0]
 801218c:	2b83      	cmp	r3, #131	; 0x83
 801218e:	d10c      	bne.n	80121aa <cblas_dtrsv+0x316>
        X[ix] = tmp / A[lda * i + i];
 8012190:	9a08      	ldr	r2, [sp, #32]
 8012192:	9b02      	ldr	r3, [sp, #8]
 8012194:	4413      	add	r3, r2
 8012196:	9a07      	ldr	r2, [sp, #28]
 8012198:	4413      	add	r3, r2
 801219a:	4620      	mov	r0, r4
 801219c:	4629      	mov	r1, r5
 801219e:	e9d3 2300 	ldrd	r2, r3, [r3]
 80121a2:	f016 fe0b 	bl	8028dbc <__aeabi_ddiv>
 80121a6:	4604      	mov	r4, r0
 80121a8:	460d      	mov	r5, r1
 80121aa:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 80121ae:	440a      	add	r2, r1
 80121b0:	9b01      	ldr	r3, [sp, #4]
 80121b2:	9202      	str	r2, [sp, #8]
 80121b4:	9a06      	ldr	r2, [sp, #24]
 80121b6:	e9c3 4500 	strd	r4, r5, [r3]
    for (i = N - 1; i > 0 && i--;) {
 80121ba:	4413      	add	r3, r2
 80121bc:	9301      	str	r3, [sp, #4]
 80121be:	9b04      	ldr	r3, [sp, #16]
 80121c0:	2b00      	cmp	r3, #0
 80121c2:	f43f af44 	beq.w	801204e <cblas_dtrsv+0x1ba>
 80121c6:	3b01      	subs	r3, #1
 80121c8:	9304      	str	r3, [sp, #16]
 80121ca:	e7bf      	b.n	801214c <cblas_dtrsv+0x2b8>
 80121cc:	08031108 	.word	0x08031108
 80121d0:	080312b0 	.word	0x080312b0
 80121d4:	080311b8 	.word	0x080311b8
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80121d8:	9b01      	ldr	r3, [sp, #4]
 80121da:	2b00      	cmp	r3, #0
 80121dc:	bf0c      	ite	eq
 80121de:	2009      	moveq	r0, #9
 80121e0:	2004      	movne	r0, #4
 80121e2:	e688      	b.n	8011ef6 <cblas_dtrsv+0x62>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80121e4:	2c79      	cmp	r4, #121	; 0x79
 80121e6:	f43f aeae 	beq.w	8011f46 <cblas_dtrsv+0xb2>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 80121ea:	2c7a      	cmp	r4, #122	; 0x7a
 80121ec:	f47f ae9a 	bne.w	8011f24 <cblas_dtrsv+0x90>
    ix = OFFSET(N, incX);
 80121f0:	9b01      	ldr	r3, [sp, #4]
 80121f2:	2b00      	cmp	r3, #0
 80121f4:	f340 80d6 	ble.w	80123a4 <cblas_dtrsv+0x510>
 80121f8:	9b01      	ldr	r3, [sp, #4]
 80121fa:	2400      	movs	r4, #0
 80121fc:	461e      	mov	r6, r3
    if (nonunit) {
 80121fe:	9b00      	ldr	r3, [sp, #0]
 8012200:	2b83      	cmp	r3, #131	; 0x83
 8012202:	d10b      	bne.n	801221c <cblas_dtrsv+0x388>
      X[ix] = X[ix] / A[lda * 0 + 0];
 8012204:	9b03      	ldr	r3, [sp, #12]
 8012206:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
 801220a:	9b02      	ldr	r3, [sp, #8]
 801220c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012210:	e9d3 2300 	ldrd	r2, r3, [r3]
 8012214:	f016 fdd2 	bl	8028dbc <__aeabi_ddiv>
 8012218:	e9c5 0100 	strd	r0, r1, [r5]
    for (i = 1; i < N; i++) {
 801221c:	f1bb 0f01 	cmp.w	fp, #1
 8012220:	f77f af15 	ble.w	801204e <cblas_dtrsv+0x1ba>
 8012224:	9b03      	ldr	r3, [sp, #12]
 8012226:	f8cd a010 	str.w	sl, [sp, #16]
 801222a:	f10a 0801 	add.w	r8, sl, #1
 801222e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8012232:	9306      	str	r3, [sp, #24]
 8012234:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 8012238:	9307      	str	r3, [sp, #28]
 801223a:	9b02      	ldr	r3, [sp, #8]
 801223c:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 8012240:	9b01      	ldr	r3, [sp, #4]
 8012242:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8012246:	2301      	movs	r3, #1
 8012248:	e9cd ba08 	strd	fp, sl, [sp, #32]
 801224c:	9305      	str	r3, [sp, #20]
 801224e:	46b2      	mov	sl, r6
      BASE tmp = X[ix];
 8012250:	9b03      	ldr	r3, [sp, #12]
 8012252:	9a04      	ldr	r2, [sp, #16]
 8012254:	9e06      	ldr	r6, [sp, #24]
 8012256:	eb03 0bca 	add.w	fp, r3, sl, lsl #3
 801225a:	e9db 4500 	ldrd	r4, r5, [fp]
      for (j = 0; j < i; j++) {
 801225e:	9b02      	ldr	r3, [sp, #8]
 8012260:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        tmp -= Aij * X[jx];
 8012264:	e9d6 2300 	ldrd	r2, r3, [r6]
 8012268:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 801226c:	f016 fc7c 	bl	8028b68 <__aeabi_dmul>
 8012270:	4602      	mov	r2, r0
 8012272:	460b      	mov	r3, r1
 8012274:	4620      	mov	r0, r4
 8012276:	4629      	mov	r1, r5
 8012278:	f016 fabe 	bl	80287f8 <__aeabi_dsub>
      for (j = 0; j < i; j++) {
 801227c:	4547      	cmp	r7, r8
        tmp -= Aij * X[jx];
 801227e:	4604      	mov	r4, r0
 8012280:	460d      	mov	r5, r1
 8012282:	444e      	add	r6, r9
      for (j = 0; j < i; j++) {
 8012284:	d1ee      	bne.n	8012264 <cblas_dtrsv+0x3d0>
      if (nonunit) {
 8012286:	9b00      	ldr	r3, [sp, #0]
 8012288:	2b83      	cmp	r3, #131	; 0x83
 801228a:	d105      	bne.n	8012298 <cblas_dtrsv+0x404>
        X[ix] = tmp / A[lda * i + i];
 801228c:	e9d8 2300 	ldrd	r2, r3, [r8]
 8012290:	f016 fd94 	bl	8028dbc <__aeabi_ddiv>
 8012294:	4604      	mov	r4, r0
 8012296:	460d      	mov	r5, r1
      ix += incX;
 8012298:	9a01      	ldr	r2, [sp, #4]
 801229a:	9909      	ldr	r1, [sp, #36]	; 0x24
    for (i = 1; i < N; i++) {
 801229c:	9b05      	ldr	r3, [sp, #20]
      ix += incX;
 801229e:	4492      	add	sl, r2
 80122a0:	9a07      	ldr	r2, [sp, #28]
 80122a2:	4490      	add	r8, r2
 80122a4:	9a04      	ldr	r2, [sp, #16]
 80122a6:	440a      	add	r2, r1
 80122a8:	9204      	str	r2, [sp, #16]
    for (i = 1; i < N; i++) {
 80122aa:	9a08      	ldr	r2, [sp, #32]
 80122ac:	3301      	adds	r3, #1
 80122ae:	429a      	cmp	r2, r3
 80122b0:	e9cb 4500 	strd	r4, r5, [fp]
 80122b4:	9305      	str	r3, [sp, #20]
 80122b6:	d1cb      	bne.n	8012250 <cblas_dtrsv+0x3bc>
 80122b8:	e6c9      	b.n	801204e <cblas_dtrsv+0x1ba>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 80122ba:	2c79      	cmp	r4, #121	; 0x79
 80122bc:	f47f ae32 	bne.w	8011f24 <cblas_dtrsv+0x90>
 80122c0:	e796      	b.n	80121f0 <cblas_dtrsv+0x35c>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80122c2:	3865      	subs	r0, #101	; 0x65
 80122c4:	2801      	cmp	r0, #1
 80122c6:	bf94      	ite	ls
 80122c8:	2000      	movls	r0, #0
 80122ca:	2001      	movhi	r0, #1
 80122cc:	2670      	movs	r6, #112	; 0x70
 80122ce:	e5fc      	b.n	8011eca <cblas_dtrsv+0x36>
    ix = OFFSET(N, incX);
 80122d0:	9b01      	ldr	r3, [sp, #4]
 80122d2:	2b00      	cmp	r3, #0
 80122d4:	dd6d      	ble.n	80123b2 <cblas_dtrsv+0x51e>
 80122d6:	9b01      	ldr	r3, [sp, #4]
 80122d8:	9304      	str	r3, [sp, #16]
 80122da:	2400      	movs	r4, #0
    if (nonunit) {
 80122dc:	9b00      	ldr	r3, [sp, #0]
 80122de:	2b83      	cmp	r3, #131	; 0x83
 80122e0:	d10b      	bne.n	80122fa <cblas_dtrsv+0x466>
      X[ix] = X[ix] / A[lda * 0 + 0];
 80122e2:	9b03      	ldr	r3, [sp, #12]
 80122e4:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
 80122e8:	9b02      	ldr	r3, [sp, #8]
 80122ea:	e9d5 0100 	ldrd	r0, r1, [r5]
 80122ee:	e9d3 2300 	ldrd	r2, r3, [r3]
 80122f2:	f016 fd63 	bl	8028dbc <__aeabi_ddiv>
 80122f6:	e9c5 0100 	strd	r0, r1, [r5]
    for (i = 1; i < N; i++) {
 80122fa:	f1bb 0f01 	cmp.w	fp, #1
 80122fe:	f77f aea6 	ble.w	801204e <cblas_dtrsv+0x1ba>
 8012302:	f10a 0a01 	add.w	sl, sl, #1
 8012306:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 801230a:	f1a3 0a08 	sub.w	sl, r3, #8
 801230e:	9308      	str	r3, [sp, #32]
 8012310:	9b03      	ldr	r3, [sp, #12]
 8012312:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 8012316:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 801231a:	9307      	str	r3, [sp, #28]
 801231c:	9b02      	ldr	r3, [sp, #8]
 801231e:	4453      	add	r3, sl
 8012320:	9305      	str	r3, [sp, #20]
 8012322:	9b01      	ldr	r3, [sp, #4]
 8012324:	00db      	lsls	r3, r3, #3
 8012326:	f04f 0901 	mov.w	r9, #1
 801232a:	469b      	mov	fp, r3
      BASE tmp = X[ix];
 801232c:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8012330:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8012334:	e9d3 4500 	ldrd	r4, r5, [r3]
      for (j = 0; j < i; j++) {
 8012338:	9306      	str	r3, [sp, #24]
 801233a:	9b02      	ldr	r3, [sp, #8]
      BASE tmp = X[ix];
 801233c:	9f07      	ldr	r7, [sp, #28]
 801233e:	eb03 08c9 	add.w	r8, r3, r9, lsl #3
 8012342:	2600      	movs	r6, #0
        tmp -= Aji * X[jx];
 8012344:	e9d8 2300 	ldrd	r2, r3, [r8]
 8012348:	e9d7 0100 	ldrd	r0, r1, [r7]
 801234c:	f016 fc0c 	bl	8028b68 <__aeabi_dmul>
 8012350:	4602      	mov	r2, r0
 8012352:	460b      	mov	r3, r1
 8012354:	4620      	mov	r0, r4
 8012356:	4629      	mov	r1, r5
 8012358:	f016 fa4e 	bl	80287f8 <__aeabi_dsub>
      for (j = 0; j < i; j++) {
 801235c:	3601      	adds	r6, #1
 801235e:	454e      	cmp	r6, r9
        tmp -= Aji * X[jx];
 8012360:	4604      	mov	r4, r0
 8012362:	460d      	mov	r5, r1
 8012364:	44d0      	add	r8, sl
 8012366:	445f      	add	r7, fp
      for (j = 0; j < i; j++) {
 8012368:	d1ec      	bne.n	8012344 <cblas_dtrsv+0x4b0>
      if (nonunit) {
 801236a:	9b00      	ldr	r3, [sp, #0]
 801236c:	2b83      	cmp	r3, #131	; 0x83
 801236e:	d106      	bne.n	801237e <cblas_dtrsv+0x4ea>
        X[ix] = tmp / A[lda * i + i];
 8012370:	9b05      	ldr	r3, [sp, #20]
 8012372:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8012376:	f016 fd21 	bl	8028dbc <__aeabi_ddiv>
 801237a:	4604      	mov	r4, r0
 801237c:	460d      	mov	r5, r1
 801237e:	9b06      	ldr	r3, [sp, #24]
      ix += incX;
 8012380:	9a01      	ldr	r2, [sp, #4]
 8012382:	e9c3 4500 	strd	r4, r5, [r3]
 8012386:	9b04      	ldr	r3, [sp, #16]
 8012388:	4413      	add	r3, r2
 801238a:	9304      	str	r3, [sp, #16]
    for (i = 1; i < N; i++) {
 801238c:	9a08      	ldr	r2, [sp, #32]
 801238e:	9b05      	ldr	r3, [sp, #20]
 8012390:	4413      	add	r3, r2
 8012392:	9305      	str	r3, [sp, #20]
 8012394:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8012396:	f109 0901 	add.w	r9, r9, #1
 801239a:	454b      	cmp	r3, r9
 801239c:	d1c6      	bne.n	801232c <cblas_dtrsv+0x498>
 801239e:	e656      	b.n	801204e <cblas_dtrsv+0x1ba>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80123a0:	2009      	movs	r0, #9
 80123a2:	e5a8      	b.n	8011ef6 <cblas_dtrsv+0x62>
    ix = OFFSET(N, incX);
 80123a4:	f1cb 0401 	rsb	r4, fp, #1
 80123a8:	fb04 f403 	mul.w	r4, r4, r3
 80123ac:	4423      	add	r3, r4
 80123ae:	461e      	mov	r6, r3
 80123b0:	e725      	b.n	80121fe <cblas_dtrsv+0x36a>
    ix = OFFSET(N, incX);
 80123b2:	f1cb 0401 	rsb	r4, fp, #1
 80123b6:	fb04 f403 	mul.w	r4, r4, r3
 80123ba:	4423      	add	r3, r4
 80123bc:	9304      	str	r3, [sp, #16]
 80123be:	e78d      	b.n	80122dc <cblas_dtrsv+0x448>

080123c0 <cblas_dzasum>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dzasum (const int N, const void *X, const int incX)
{
 80123c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80123c4:	b083      	sub	sp, #12
  if (incX <= 0) {
 80123c6:	2a00      	cmp	r2, #0
 80123c8:	9000      	str	r0, [sp, #0]
 80123ca:	dd2e      	ble.n	801242a <cblas_dzasum+0x6a>
  for (i = 0; i < N; i++) {
 80123cc:	2800      	cmp	r0, #0
  BASE r = 0.0;
 80123ce:	f04f 0400 	mov.w	r4, #0
 80123d2:	f04f 0500 	mov.w	r5, #0
  for (i = 0; i < N; i++) {
 80123d6:	dd23      	ble.n	8012420 <cblas_dzasum+0x60>
 80123d8:	0113      	lsls	r3, r2, #4
 80123da:	9301      	str	r3, [sp, #4]
 80123dc:	468a      	mov	sl, r1
 80123de:	f04f 0b00 	mov.w	fp, #0
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 80123e2:	e9da 2801 	ldrd	r2, r8, [sl, #4]
 80123e6:	f8da 300c 	ldr.w	r3, [sl, #12]
 80123ea:	f8da 6000 	ldr.w	r6, [sl]
 80123ee:	f022 4700 	bic.w	r7, r2, #2147483648	; 0x80000000
 80123f2:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
 80123f6:	4642      	mov	r2, r8
 80123f8:	464b      	mov	r3, r9
 80123fa:	4630      	mov	r0, r6
 80123fc:	4639      	mov	r1, r7
 80123fe:	f016 f9fd 	bl	80287fc <__adddf3>
 8012402:	460b      	mov	r3, r1
 8012404:	4602      	mov	r2, r0
 8012406:	4629      	mov	r1, r5
 8012408:	4620      	mov	r0, r4
 801240a:	f016 f9f7 	bl	80287fc <__adddf3>
 801240e:	9b01      	ldr	r3, [sp, #4]
 8012410:	449a      	add	sl, r3
  for (i = 0; i < N; i++) {
 8012412:	9b00      	ldr	r3, [sp, #0]
 8012414:	f10b 0b01 	add.w	fp, fp, #1
 8012418:	455b      	cmp	r3, fp
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 801241a:	4604      	mov	r4, r0
 801241c:	460d      	mov	r5, r1
  for (i = 0; i < N; i++) {
 801241e:	d1e0      	bne.n	80123e2 <cblas_dzasum+0x22>
#define BASE double
#include "source_asum_c.h"
#undef BASE
}
 8012420:	ec45 4b10 	vmov	d0, r4, r5
 8012424:	b003      	add	sp, #12
 8012426:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 801242a:	2400      	movs	r4, #0
 801242c:	2500      	movs	r5, #0
 801242e:	ec45 4b10 	vmov	d0, r4, r5
 8012432:	b003      	add	sp, #12
 8012434:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08012438 <cblas_dznrm2>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dznrm2 (const int N, const void *X, const int incX)
{
 8012438:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801243c:	b089      	sub	sp, #36	; 0x24
  if (N == 0 || incX < 1) {
 801243e:	9006      	str	r0, [sp, #24]
 8012440:	2800      	cmp	r0, #0
 8012442:	f000 808c 	beq.w	801255e <cblas_dznrm2+0x126>
 8012446:	2a00      	cmp	r2, #0
 8012448:	f340 8089 	ble.w	801255e <cblas_dznrm2+0x126>
  BASE ssq = 1.0;
 801244c:	ed9f 7b58 	vldr	d7, [pc, #352]	; 80125b0 <cblas_dznrm2+0x178>
  for (i = 0; i < N; i++) {
 8012450:	2800      	cmp	r0, #0
  BASE ssq = 1.0;
 8012452:	ed8d 7b04 	vstr	d7, [sp, #16]
  BASE scale = 0.0;
 8012456:	f04f 0a00 	mov.w	sl, #0
 801245a:	f04f 0b00 	mov.w	fp, #0
  for (i = 0; i < N; i++) {
 801245e:	f340 8096 	ble.w	801258e <cblas_dznrm2+0x156>
 8012462:	0113      	lsls	r3, r2, #4
 8012464:	9307      	str	r3, [sp, #28]
 8012466:	460c      	mov	r4, r1
 8012468:	2500      	movs	r5, #0
 801246a:	e019      	b.n	80124a0 <cblas_dznrm2+0x68>
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 801246c:	f016 fca6 	bl	8028dbc <__aeabi_ddiv>
 8012470:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8012474:	4606      	mov	r6, r0
 8012476:	460f      	mov	r7, r1
 8012478:	f016 fb76 	bl	8028b68 <__aeabi_dmul>
 801247c:	4632      	mov	r2, r6
 801247e:	463b      	mov	r3, r7
 8012480:	f016 fb72 	bl	8028b68 <__aeabi_dmul>
 8012484:	4b4e      	ldr	r3, [pc, #312]	; (80125c0 <cblas_dznrm2+0x188>)
 8012486:	2200      	movs	r2, #0
 8012488:	f016 f9b8 	bl	80287fc <__adddf3>
        scale = ay;
 801248c:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 8012490:	e9cd 0104 	strd	r0, r1, [sp, #16]
  for (i = 0; i < N; i++) {
 8012494:	9b07      	ldr	r3, [sp, #28]
 8012496:	441c      	add	r4, r3
 8012498:	9b06      	ldr	r3, [sp, #24]
 801249a:	3501      	adds	r5, #1
 801249c:	42ab      	cmp	r3, r5
 801249e:	d076      	beq.n	801258e <cblas_dznrm2+0x156>
    const BASE x = CONST_REAL(X, ix);
 80124a0:	e9d4 6700 	ldrd	r6, r7, [r4]
    if (x != 0.0) {
 80124a4:	2200      	movs	r2, #0
 80124a6:	2300      	movs	r3, #0
 80124a8:	4630      	mov	r0, r6
 80124aa:	4639      	mov	r1, r7
 80124ac:	f016 fdc4 	bl	8029038 <__aeabi_dcmpeq>
    const BASE y = CONST_IMAG(X, ix);
 80124b0:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
      if (scale < ax) {
 80124b4:	4652      	mov	r2, sl
 80124b6:	465b      	mov	r3, fp
    if (x != 0.0) {
 80124b8:	bb18      	cbnz	r0, 8012502 <cblas_dznrm2+0xca>
      const BASE ax = fabs(x);
 80124ba:	f027 4100 	bic.w	r1, r7, #2147483648	; 0x80000000
 80124be:	9600      	str	r6, [sp, #0]
 80124c0:	9101      	str	r1, [sp, #4]
      if (scale < ax) {
 80124c2:	e9dd 0100 	ldrd	r0, r1, [sp]
 80124c6:	f016 fddf 	bl	8029088 <__aeabi_dcmpgt>
 80124ca:	4684      	mov	ip, r0
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80124cc:	e9dd 2300 	ldrd	r2, r3, [sp]
 80124d0:	4650      	mov	r0, sl
 80124d2:	4659      	mov	r1, fp
      if (scale < ax) {
 80124d4:	f1bc 0f00 	cmp.w	ip, #0
 80124d8:	d046      	beq.n	8012568 <cblas_dznrm2+0x130>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80124da:	f016 fc6f 	bl	8028dbc <__aeabi_ddiv>
 80124de:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80124e2:	4606      	mov	r6, r0
 80124e4:	460f      	mov	r7, r1
 80124e6:	f016 fb3f 	bl	8028b68 <__aeabi_dmul>
 80124ea:	4632      	mov	r2, r6
 80124ec:	463b      	mov	r3, r7
 80124ee:	f016 fb3b 	bl	8028b68 <__aeabi_dmul>
 80124f2:	4b33      	ldr	r3, [pc, #204]	; (80125c0 <cblas_dznrm2+0x188>)
 80124f4:	2200      	movs	r2, #0
 80124f6:	f016 f981 	bl	80287fc <__adddf3>
        scale = ax;
 80124fa:	e9dd ab00 	ldrd	sl, fp, [sp]
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80124fe:	e9cd 0104 	strd	r0, r1, [sp, #16]
    if (y != 0.0) {
 8012502:	2300      	movs	r3, #0
 8012504:	4649      	mov	r1, r9
 8012506:	2200      	movs	r2, #0
 8012508:	4640      	mov	r0, r8
 801250a:	f016 fd95 	bl	8029038 <__aeabi_dcmpeq>
 801250e:	4603      	mov	r3, r0
      if (scale < ay) {
 8012510:	4659      	mov	r1, fp
 8012512:	4650      	mov	r0, sl
    if (y != 0.0) {
 8012514:	2b00      	cmp	r3, #0
 8012516:	d1bd      	bne.n	8012494 <cblas_dznrm2+0x5c>
      const BASE ay = fabs(y);
 8012518:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 801251c:	f8cd 8008 	str.w	r8, [sp, #8]
 8012520:	9303      	str	r3, [sp, #12]
      if (scale < ay) {
 8012522:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8012526:	f016 fd91 	bl	802904c <__aeabi_dcmplt>
 801252a:	4606      	mov	r6, r0
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 801252c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8012530:	4650      	mov	r0, sl
 8012532:	4659      	mov	r1, fp
      if (scale < ay) {
 8012534:	2e00      	cmp	r6, #0
 8012536:	d199      	bne.n	801246c <cblas_dznrm2+0x34>
        ssq += (ay / scale) * (ay / scale);
 8012538:	4652      	mov	r2, sl
 801253a:	465b      	mov	r3, fp
 801253c:	4640      	mov	r0, r8
 801253e:	4649      	mov	r1, r9
 8012540:	f016 fc3c 	bl	8028dbc <__aeabi_ddiv>
 8012544:	4602      	mov	r2, r0
 8012546:	460b      	mov	r3, r1
 8012548:	f016 fb0e 	bl	8028b68 <__aeabi_dmul>
 801254c:	4602      	mov	r2, r0
 801254e:	460b      	mov	r3, r1
 8012550:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8012554:	f016 f952 	bl	80287fc <__adddf3>
 8012558:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801255c:	e79a      	b.n	8012494 <cblas_dznrm2+0x5c>
    return 0;
 801255e:	ed9f 0b16 	vldr	d0, [pc, #88]	; 80125b8 <cblas_dznrm2+0x180>
#define BASE double
#include "source_nrm2_c.h"
#undef BASE
}
 8012562:	b009      	add	sp, #36	; 0x24
 8012564:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ssq += (ax / scale) * (ax / scale);
 8012568:	4652      	mov	r2, sl
 801256a:	465b      	mov	r3, fp
 801256c:	4630      	mov	r0, r6
 801256e:	4639      	mov	r1, r7
 8012570:	f016 fc24 	bl	8028dbc <__aeabi_ddiv>
 8012574:	4602      	mov	r2, r0
 8012576:	460b      	mov	r3, r1
 8012578:	f016 faf6 	bl	8028b68 <__aeabi_dmul>
 801257c:	4602      	mov	r2, r0
 801257e:	460b      	mov	r3, r1
 8012580:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8012584:	f016 f93a 	bl	80287fc <__adddf3>
 8012588:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801258c:	e7b9      	b.n	8012502 <cblas_dznrm2+0xca>
  return scale * sqrt(ssq);
 801258e:	ed9d 0b04 	vldr	d0, [sp, #16]
 8012592:	f01e fb3f 	bl	8030c14 <sqrt>
 8012596:	4652      	mov	r2, sl
 8012598:	ec51 0b10 	vmov	r0, r1, d0
 801259c:	465b      	mov	r3, fp
 801259e:	f016 fae3 	bl	8028b68 <__aeabi_dmul>
 80125a2:	ec41 0b10 	vmov	d0, r0, r1
 80125a6:	b009      	add	sp, #36	; 0x24
 80125a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80125ac:	f3af 8000 	nop.w
 80125b0:	00000000 	.word	0x00000000
 80125b4:	3ff00000 	.word	0x3ff00000
	...
 80125c0:	3ff00000 	.word	0x3ff00000

080125c4 <cblas_caxpy>:
#include "cblas.h"

void
cblas_caxpy (const int N, const void *alpha, const void *X, const int incX,
             void *Y, const int incY)
{
 80125c4:	b4f0      	push	{r4, r5, r6, r7}
 80125c6:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80125ca:	2b00      	cmp	r3, #0
 80125cc:	bfd8      	it	le
 80125ce:	f1c0 0c01 	rsble	ip, r0, #1
  INDEX iy = OFFSET(N, incY);

  const BASE alpha_real = CONST_REAL0(alpha);
 80125d2:	ed91 5a00 	vldr	s10, [r1]
  const BASE alpha_imag = CONST_IMAG0(alpha);
 80125d6:	edd1 4a01 	vldr	s9, [r1, #4]
  INDEX ix = OFFSET(N, incX);
 80125da:	bfd4      	ite	le
 80125dc:	fb0c fc03 	mulle.w	ip, ip, r3
 80125e0:	f04f 0c00 	movgt.w	ip, #0
  INDEX iy = OFFSET(N, incY);
 80125e4:	2d00      	cmp	r5, #0
 80125e6:	bfd8      	it	le
 80125e8:	f1c0 0701 	rsble	r7, r0, #1

  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 80125ec:	eeb5 5a40 	vcmp.f32	s10, #0.0
  INDEX iy = OFFSET(N, incY);
 80125f0:	bfd4      	ite	le
 80125f2:	436f      	mulle	r7, r5
 80125f4:	2700      	movgt	r7, #0
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 80125f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80125fa:	d104      	bne.n	8012606 <cblas_caxpy+0x42>
 80125fc:	eef5 4a40 	vcmp.f32	s9, #0.0
 8012600:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012604:	d02b      	beq.n	801265e <cblas_caxpy+0x9a>
    return;
  }

  for (i = 0; i < N; i++) {
 8012606:	2800      	cmp	r0, #0
 8012608:	dd29      	ble.n	801265e <cblas_caxpy+0x9a>
 801260a:	eb04 01c7 	add.w	r1, r4, r7, lsl #3
 801260e:	00de      	lsls	r6, r3, #3
 8012610:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
 8012614:	eb04 03c7 	add.w	r3, r4, r7, lsl #3
 8012618:	00ed      	lsls	r5, r5, #3
 801261a:	3104      	adds	r1, #4
 801261c:	2400      	movs	r4, #0
    const BASE x_real = CONST_REAL(X, ix);
    const BASE x_imag = CONST_IMAG(X, ix);
 801261e:	ed92 7a01 	vldr	s14, [r2, #4]
    const BASE x_real = CONST_REAL(X, ix);
 8012622:	edd2 5a00 	vldr	s11, [r2]
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8012626:	ed51 6a01 	vldr	s13, [r1, #-4]
 801262a:	ee27 6a64 	vnmul.f32	s12, s14, s9
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801262e:	ee64 7aa5 	vmul.f32	s15, s9, s11
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8012632:	eea5 6a25 	vfma.f32	s12, s10, s11
  for (i = 0; i < N; i++) {
 8012636:	3401      	adds	r4, #1
 8012638:	42a0      	cmp	r0, r4
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801263a:	eee5 7a07 	vfma.f32	s15, s10, s14
 801263e:	4432      	add	r2, r6
 8012640:	eeb0 7a67 	vmov.f32	s14, s15
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8012644:	ee76 7a86 	vadd.f32	s15, s13, s12
 8012648:	ed41 7a01 	vstr	s15, [r1, #-4]
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801264c:	edd3 7a01 	vldr	s15, [r3, #4]
 8012650:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012654:	4429      	add	r1, r5
 8012656:	edc3 7a01 	vstr	s15, [r3, #4]
  for (i = 0; i < N; i++) {
 801265a:	442b      	add	r3, r5
 801265c:	d1df      	bne.n	801261e <cblas_caxpy+0x5a>
#define BASE float
#include "source_axpy_c.h"
#undef BASE
}
 801265e:	bcf0      	pop	{r4, r5, r6, r7}
 8012660:	4770      	bx	lr
 8012662:	bf00      	nop

08012664 <cblas_ccopy>:
#include "cblas.h"

void
cblas_ccopy (const int N, const void *X, const int incX, void *Y,
             const int incY)
{
 8012664:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 8012666:	2a00      	cmp	r2, #0
 8012668:	9e04      	ldr	r6, [sp, #16]
 801266a:	bfda      	itte	le
 801266c:	f1c0 0701 	rsble	r7, r0, #1
 8012670:	4357      	mulle	r7, r2
 8012672:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 8012674:	2e00      	cmp	r6, #0
 8012676:	bfda      	itte	le
 8012678:	f1c0 0401 	rsble	r4, r0, #1
 801267c:	4374      	mulle	r4, r6
 801267e:	2400      	movgt	r4, #0

  for (i = 0; i < N; i++) {
 8012680:	2800      	cmp	r0, #0
 8012682:	dd0f      	ble.n	80126a4 <cblas_ccopy+0x40>
 8012684:	00d5      	lsls	r5, r2, #3
 8012686:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
 801268a:	00f6      	lsls	r6, r6, #3
 801268c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8012690:	2200      	movs	r2, #0
    REAL(Y, iy) = CONST_REAL(X, ix);
 8012692:	680c      	ldr	r4, [r1, #0]
 8012694:	601c      	str	r4, [r3, #0]
  for (i = 0; i < N; i++) {
 8012696:	3201      	adds	r2, #1
    IMAG(Y, iy) = CONST_IMAG(X, ix);
 8012698:	684c      	ldr	r4, [r1, #4]
 801269a:	605c      	str	r4, [r3, #4]
  for (i = 0; i < N; i++) {
 801269c:	4290      	cmp	r0, r2
 801269e:	4429      	add	r1, r5
 80126a0:	4433      	add	r3, r6
 80126a2:	d1f6      	bne.n	8012692 <cblas_ccopy+0x2e>
#define BASE float
#include "source_copy_c.h"
#undef BASE
}
 80126a4:	bcf0      	pop	{r4, r5, r6, r7}
 80126a6:	4770      	bx	lr

080126a8 <cblas_cdotc_sub>:
#include "cblas.h"

void
cblas_cdotc_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 80126a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80126ac:	ed2d 8b04 	vpush	{d8-d9}
 80126b0:	b087      	sub	sp, #28
 80126b2:	4604      	mov	r4, r0

{
  BASE r_real = 0.0;
  BASE r_imag = 0.0;
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80126b4:	2a00      	cmp	r2, #0
 80126b6:	9003      	str	r0, [sp, #12]
 80126b8:	9814      	ldr	r0, [sp, #80]	; 0x50
 80126ba:	bfda      	itte	le
 80126bc:	f1c4 0701 	rsble	r7, r4, #1
 80126c0:	4357      	mulle	r7, r2
 80126c2:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 80126c4:	2800      	cmp	r0, #0
 80126c6:	bfdc      	itt	le
 80126c8:	9c03      	ldrle	r4, [sp, #12]
 80126ca:	f1c4 0601 	rsble	r6, r4, #1
  for (i = 0; i < N; i++) {
 80126ce:	9c03      	ldr	r4, [sp, #12]
  INDEX iy = OFFSET(N, incY);
 80126d0:	bfd4      	ite	le
 80126d2:	4346      	mulle	r6, r0
 80126d4:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 80126d6:	f04f 0b00 	mov.w	fp, #0
 80126da:	2c00      	cmp	r4, #0
 80126dc:	46da      	mov	sl, fp
 80126de:	dd6c      	ble.n	80127ba <cblas_cdotc_sub+0x112>
 80126e0:	00d2      	lsls	r2, r2, #3
 80126e2:	9205      	str	r2, [sp, #20]
 80126e4:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 80126e8:	00c2      	lsls	r2, r0, #3
 80126ea:	2300      	movs	r3, #0
 80126ec:	eb01 07c7 	add.w	r7, r1, r7, lsl #3
 80126f0:	9204      	str	r2, [sp, #16]
 80126f2:	9302      	str	r3, [sp, #8]
    const BASE x_real = CONST_REAL(X, ix);
 80126f4:	edd7 8a00 	vldr	s17, [r7]
    const BASE x_imag = CONST_IMAG(X, ix);
    const BASE y_real = CONST_REAL(Y, iy);
 80126f8:	ed96 9a00 	vldr	s18, [r6]
    const BASE y_imag = CONST_IMAG(Y, iy);
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80126fc:	6878      	ldr	r0, [r7, #4]
    const BASE y_imag = CONST_IMAG(Y, iy);
 80126fe:	ed96 8a01 	vldr	s16, [r6, #4]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8012702:	f016 f9d9 	bl	8028ab8 <__aeabi_f2d>
 8012706:	ee68 7a89 	vmul.f32	s15, s17, s18
 801270a:	4604      	mov	r4, r0
 801270c:	ee17 0a90 	vmov	r0, s15
 8012710:	460d      	mov	r5, r1
 8012712:	f016 f9d1 	bl	8028ab8 <__aeabi_f2d>
 8012716:	4680      	mov	r8, r0
 8012718:	ee18 0a10 	vmov	r0, s16
 801271c:	4689      	mov	r9, r1
 801271e:	f016 f9cb 	bl	8028ab8 <__aeabi_f2d>
 8012722:	4622      	mov	r2, r4
 8012724:	462b      	mov	r3, r5
 8012726:	f016 fa1f 	bl	8028b68 <__aeabi_dmul>
 801272a:	4602      	mov	r2, r0
 801272c:	460b      	mov	r3, r1
 801272e:	4640      	mov	r0, r8
 8012730:	4649      	mov	r1, r9
 8012732:	f016 f863 	bl	80287fc <__adddf3>
 8012736:	4680      	mov	r8, r0
 8012738:	4650      	mov	r0, sl
 801273a:	4689      	mov	r9, r1
 801273c:	f016 f9bc 	bl	8028ab8 <__aeabi_f2d>
 8012740:	4602      	mov	r2, r0
 8012742:	460b      	mov	r3, r1
 8012744:	4640      	mov	r0, r8
 8012746:	4649      	mov	r1, r9
 8012748:	f016 f858 	bl	80287fc <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801274c:	9400      	str	r4, [sp, #0]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801274e:	f016 fcbb 	bl	80290c8 <__aeabi_d2f>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8012752:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8012756:	4682      	mov	sl, r0
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8012758:	ee19 0a10 	vmov	r0, s18
 801275c:	9301      	str	r3, [sp, #4]
 801275e:	f016 f9ab 	bl	8028ab8 <__aeabi_f2d>
 8012762:	4602      	mov	r2, r0
 8012764:	460b      	mov	r3, r1
 8012766:	e9dd 0100 	ldrd	r0, r1, [sp]
 801276a:	f016 f9fd 	bl	8028b68 <__aeabi_dmul>
 801276e:	ee68 7a88 	vmul.f32	s15, s17, s16
 8012772:	4604      	mov	r4, r0
 8012774:	ee17 0a90 	vmov	r0, s15
 8012778:	460d      	mov	r5, r1
 801277a:	f016 f99d 	bl	8028ab8 <__aeabi_f2d>
 801277e:	4602      	mov	r2, r0
 8012780:	460b      	mov	r3, r1
 8012782:	4620      	mov	r0, r4
 8012784:	4629      	mov	r1, r5
 8012786:	f016 f839 	bl	80287fc <__adddf3>
 801278a:	4604      	mov	r4, r0
 801278c:	4658      	mov	r0, fp
 801278e:	460d      	mov	r5, r1
 8012790:	f016 f992 	bl	8028ab8 <__aeabi_f2d>
 8012794:	4602      	mov	r2, r0
 8012796:	460b      	mov	r3, r1
 8012798:	4620      	mov	r0, r4
 801279a:	4629      	mov	r1, r5
 801279c:	f016 f82e 	bl	80287fc <__adddf3>
 80127a0:	f016 fc92 	bl	80290c8 <__aeabi_d2f>
 80127a4:	9a05      	ldr	r2, [sp, #20]
  for (i = 0; i < N; i++) {
 80127a6:	9b02      	ldr	r3, [sp, #8]
 80127a8:	4417      	add	r7, r2
 80127aa:	9a04      	ldr	r2, [sp, #16]
 80127ac:	4416      	add	r6, r2
 80127ae:	9a03      	ldr	r2, [sp, #12]
 80127b0:	3301      	adds	r3, #1
 80127b2:	429a      	cmp	r2, r3
 80127b4:	9302      	str	r3, [sp, #8]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80127b6:	4683      	mov	fp, r0
  for (i = 0; i < N; i++) {
 80127b8:	d19c      	bne.n	80126f4 <cblas_cdotc_sub+0x4c>
    ix += incX;
    iy += incY;
  }
  REAL0(result) = r_real;
 80127ba:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80127bc:	f8c3 a000 	str.w	sl, [r3]
  IMAG0(result) = r_imag;
 80127c0:	f8c3 b004 	str.w	fp, [r3, #4]
#define BASE float
#define CONJ_SIGN (-1.0)
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 80127c4:	b007      	add	sp, #28
 80127c6:	ecbd 8b04 	vpop	{d8-d9}
 80127ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80127ce:	bf00      	nop

080127d0 <cblas_cdotu_sub>:
#include "cblas.h"

void
cblas_cdotu_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 80127d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80127d4:	ed2d 8b04 	vpush	{d8-d9}
 80127d8:	b085      	sub	sp, #20
 80127da:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 80127dc:	2a00      	cmp	r2, #0
 80127de:	9001      	str	r0, [sp, #4]
 80127e0:	9812      	ldr	r0, [sp, #72]	; 0x48
 80127e2:	bfda      	itte	le
 80127e4:	f1c4 0601 	rsble	r6, r4, #1
 80127e8:	4356      	mulle	r6, r2
 80127ea:	2600      	movgt	r6, #0
  INDEX iy = OFFSET(N, incY);
 80127ec:	2800      	cmp	r0, #0
 80127ee:	bfdc      	itt	le
 80127f0:	9c01      	ldrle	r4, [sp, #4]
 80127f2:	f1c4 0701 	rsble	r7, r4, #1
  for (i = 0; i < N; i++) {
 80127f6:	9c01      	ldr	r4, [sp, #4]
  INDEX iy = OFFSET(N, incY);
 80127f8:	bfd4      	ite	le
 80127fa:	4347      	mulle	r7, r0
 80127fc:	2700      	movgt	r7, #0
  for (i = 0; i < N; i++) {
 80127fe:	f04f 0b00 	mov.w	fp, #0
 8012802:	2c00      	cmp	r4, #0
 8012804:	46da      	mov	sl, fp
 8012806:	dd66      	ble.n	80128d6 <cblas_cdotu_sub+0x106>
 8012808:	00d2      	lsls	r2, r2, #3
 801280a:	9203      	str	r2, [sp, #12]
 801280c:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
 8012810:	00c2      	lsls	r2, r0, #3
 8012812:	2300      	movs	r3, #0
 8012814:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 8012818:	9202      	str	r2, [sp, #8]
 801281a:	9300      	str	r3, [sp, #0]
    const BASE x_real = CONST_REAL(X, ix);
 801281c:	ed96 9a00 	vldr	s18, [r6]
    const BASE y_real = CONST_REAL(Y, iy);
 8012820:	ed97 8a00 	vldr	s16, [r7]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8012824:	6870      	ldr	r0, [r6, #4]
    const BASE y_imag = CONST_IMAG(Y, iy);
 8012826:	edd7 8a01 	vldr	s17, [r7, #4]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801282a:	f016 f945 	bl	8028ab8 <__aeabi_f2d>
 801282e:	ee69 7a08 	vmul.f32	s15, s18, s16
 8012832:	4680      	mov	r8, r0
 8012834:	ee17 0a90 	vmov	r0, s15
 8012838:	4689      	mov	r9, r1
 801283a:	f016 f93d 	bl	8028ab8 <__aeabi_f2d>
 801283e:	4604      	mov	r4, r0
 8012840:	ee18 0a90 	vmov	r0, s17
 8012844:	460d      	mov	r5, r1
 8012846:	f016 f937 	bl	8028ab8 <__aeabi_f2d>
 801284a:	4642      	mov	r2, r8
 801284c:	464b      	mov	r3, r9
 801284e:	f016 f98b 	bl	8028b68 <__aeabi_dmul>
 8012852:	4602      	mov	r2, r0
 8012854:	460b      	mov	r3, r1
 8012856:	4620      	mov	r0, r4
 8012858:	4629      	mov	r1, r5
 801285a:	f015 ffcd 	bl	80287f8 <__aeabi_dsub>
 801285e:	4604      	mov	r4, r0
 8012860:	4650      	mov	r0, sl
 8012862:	460d      	mov	r5, r1
 8012864:	f016 f928 	bl	8028ab8 <__aeabi_f2d>
 8012868:	4602      	mov	r2, r0
 801286a:	460b      	mov	r3, r1
 801286c:	4620      	mov	r0, r4
 801286e:	4629      	mov	r1, r5
 8012870:	f015 ffc4 	bl	80287fc <__adddf3>
 8012874:	f016 fc28 	bl	80290c8 <__aeabi_d2f>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8012878:	ee69 7a28 	vmul.f32	s15, s18, s17
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801287c:	4682      	mov	sl, r0
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801287e:	ee17 0a90 	vmov	r0, s15
 8012882:	f016 f919 	bl	8028ab8 <__aeabi_f2d>
 8012886:	4604      	mov	r4, r0
 8012888:	ee18 0a10 	vmov	r0, s16
 801288c:	460d      	mov	r5, r1
 801288e:	f016 f913 	bl	8028ab8 <__aeabi_f2d>
 8012892:	4642      	mov	r2, r8
 8012894:	464b      	mov	r3, r9
 8012896:	f016 f967 	bl	8028b68 <__aeabi_dmul>
 801289a:	4602      	mov	r2, r0
 801289c:	460b      	mov	r3, r1
 801289e:	4620      	mov	r0, r4
 80128a0:	4629      	mov	r1, r5
 80128a2:	f015 ffab 	bl	80287fc <__adddf3>
 80128a6:	4604      	mov	r4, r0
 80128a8:	4658      	mov	r0, fp
 80128aa:	460d      	mov	r5, r1
 80128ac:	f016 f904 	bl	8028ab8 <__aeabi_f2d>
 80128b0:	4602      	mov	r2, r0
 80128b2:	460b      	mov	r3, r1
 80128b4:	4620      	mov	r0, r4
 80128b6:	4629      	mov	r1, r5
 80128b8:	f015 ffa0 	bl	80287fc <__adddf3>
 80128bc:	f016 fc04 	bl	80290c8 <__aeabi_d2f>
 80128c0:	9a03      	ldr	r2, [sp, #12]
  for (i = 0; i < N; i++) {
 80128c2:	9b00      	ldr	r3, [sp, #0]
 80128c4:	4416      	add	r6, r2
 80128c6:	9a02      	ldr	r2, [sp, #8]
 80128c8:	4417      	add	r7, r2
 80128ca:	9a01      	ldr	r2, [sp, #4]
 80128cc:	3301      	adds	r3, #1
 80128ce:	429a      	cmp	r2, r3
 80128d0:	9300      	str	r3, [sp, #0]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80128d2:	4683      	mov	fp, r0
  for (i = 0; i < N; i++) {
 80128d4:	d1a2      	bne.n	801281c <cblas_cdotu_sub+0x4c>
  REAL0(result) = r_real;
 80128d6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80128d8:	f8c3 a000 	str.w	sl, [r3]
  IMAG0(result) = r_imag;
 80128dc:	f8c3 b004 	str.w	fp, [r3, #4]
#define BASE float
#define CONJ_SIGN 1.0
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 80128e0:	b005      	add	sp, #20
 80128e2:	ecbd 8b04 	vpop	{d8-d9}
 80128e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80128ea:	bf00      	nop

080128ec <cblas_cgemm>:
cblas_cgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const void *alpha, const void *A, const int lda,
             const void *B, const int ldb, const void *beta, void *C,
             const int ldc)
{
 80128ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80128f0:	b085      	sub	sp, #20
  INDEX n1, n2;
  INDEX ldf, ldg;
  int conjF, conjG, TransF, TransG;
  const BASE *F, *G;

  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80128f2:	2865      	cmp	r0, #101	; 0x65
 80128f4:	e9dd 780e 	ldrd	r7, r8, [sp, #56]	; 0x38
 80128f8:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 80128fc:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
 8012900:	4605      	mov	r5, r0
 8012902:	468a      	mov	sl, r1
 8012904:	4614      	mov	r4, r2
 8012906:	461e      	mov	r6, r3
 8012908:	f000 819d 	beq.w	8012c46 <cblas_cgemm+0x35a>
 801290c:	2a71      	cmp	r2, #113	; 0x71
 801290e:	bf08      	it	eq
 8012910:	2270      	moveq	r2, #112	; 0x70
 8012912:	2971      	cmp	r1, #113	; 0x71
 8012914:	f000 8106 	beq.w	8012b24 <cblas_cgemm+0x238>
 8012918:	f1aa 036f 	sub.w	r3, sl, #111	; 0x6f
 801291c:	2b02      	cmp	r3, #2
 801291e:	f240 824d 	bls.w	8012dbc <cblas_cgemm+0x4d0>
 8012922:	2002      	movs	r0, #2
 8012924:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8012928:	2b02      	cmp	r3, #2
 801292a:	bf88      	it	hi
 801292c:	2003      	movhi	r0, #3
 801292e:	2e00      	cmp	r6, #0
 8012930:	bfb8      	it	lt
 8012932:	2004      	movlt	r0, #4
 8012934:	2f00      	cmp	r7, #0
 8012936:	f2c0 815d 	blt.w	8012bf4 <cblas_cgemm+0x308>
 801293a:	f1b8 0f00 	cmp.w	r8, #0
 801293e:	f2c0 80f8 	blt.w	8012b32 <cblas_cgemm+0x246>
 8012942:	2d65      	cmp	r5, #101	; 0x65
 8012944:	f000 815d 	beq.w	8012c02 <cblas_cgemm+0x316>
 8012948:	2d66      	cmp	r5, #102	; 0x66
 801294a:	f000 80f8 	beq.w	8012b3e <cblas_cgemm+0x252>
 801294e:	2800      	cmp	r0, #0
 8012950:	f040 8112 	bne.w	8012b78 <cblas_cgemm+0x28c>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8012954:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8012956:	ed93 4a00 	vldr	s8, [r3]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801295a:	edd3 3a01 	vldr	s7, [r3, #4]

    const BASE beta_real = CONST_REAL0(beta);
 801295e:	9b15      	ldr	r3, [sp, #84]	; 0x54
    const BASE beta_imag = CONST_IMAG0(beta);

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8012960:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8012964:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    const BASE beta_real = CONST_REAL0(beta);
 8012968:	edd3 5a00 	vldr	s11, [r3]
    const BASE beta_imag = CONST_IMAG0(beta);
 801296c:	ed93 5a01 	vldr	s10, [r3, #4]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8012970:	d10c      	bne.n	801298c <cblas_cgemm+0xa0>
 8012972:	eef5 3a40 	vcmp.f32	s7, #0.0
 8012976:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801297a:	d107      	bne.n	801298c <cblas_cgemm+0xa0>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801297c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8012980:	eef4 5a67 	vcmp.f32	s11, s15
 8012984:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012988:	f000 821f 	beq.w	8012dca <cblas_cgemm+0x4de>
      return;

    if (Order == CblasRowMajor) {
 801298c:	2d65      	cmp	r5, #101	; 0x65
 801298e:	f000 8168 	beq.w	8012c62 <cblas_cgemm+0x376>
    } else {
      n1 = N;
      n2 = M;
      F = (const BASE *)B;
      ldf = ldb;
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 8012992:	2c71      	cmp	r4, #113	; 0x71
 8012994:	f000 8205 	beq.w	8012da2 <cblas_cgemm+0x4b6>
 8012998:	2c6f      	cmp	r4, #111	; 0x6f
 801299a:	bf0c      	ite	eq
 801299c:	256f      	moveq	r5, #111	; 0x6f
 801299e:	2570      	movne	r5, #112	; 0x70
      TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
      G = (const BASE *)A;
      ldg = lda;
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 80129a0:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 80129a4:	eddf 2ac3 	vldr	s5, [pc, #780]	; 8012cb4 <cblas_cgemm+0x3c8>
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 80129a8:	f000 8203 	beq.w	8012db2 <cblas_cgemm+0x4c6>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80129ac:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 80129b0:	ed9f 3ac0 	vldr	s6, [pc, #768]	; 8012cb4 <cblas_cgemm+0x3c8>
 80129b4:	bf0c      	ite	eq
 80129b6:	f04f 0a6f 	moveq.w	sl, #111	; 0x6f
 80129ba:	f04f 0a70 	movne.w	sl, #112	; 0x70
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 80129be:	eef5 5a40 	vcmp.f32	s11, #0.0
 80129c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80129c6:	f040 80dc 	bne.w	8012b82 <cblas_cgemm+0x296>
 80129ca:	eeb5 5a40 	vcmp.f32	s10, #0.0
 80129ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80129d2:	f040 80e3 	bne.w	8012b9c <cblas_cgemm+0x2b0>
      for (i = 0; i < n1; i++) {
 80129d6:	2f00      	cmp	r7, #0
 80129d8:	dd19      	ble.n	8012a0e <cblas_cgemm+0x122>
 80129da:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80129dc:	ebc6 7046 	rsb	r0, r6, r6, lsl #29
 80129e0:	00c0      	lsls	r0, r0, #3
 80129e2:	ea4f 04cb 	mov.w	r4, fp, lsl #3
 80129e6:	eb03 02c6 	add.w	r2, r3, r6, lsl #3
 80129ea:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
          REAL(C, ldc * i + j) = 0.0;
 80129ec:	f04f 0c00 	mov.w	ip, #0
        for (j = 0; j < n2; j++) {
 80129f0:	2e00      	cmp	r6, #0
 80129f2:	bfc8      	it	gt
 80129f4:	1813      	addgt	r3, r2, r0
 80129f6:	dd06      	ble.n	8012a06 <cblas_cgemm+0x11a>
          REAL(C, ldc * i + j) = 0.0;
 80129f8:	f8c3 c000 	str.w	ip, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 80129fc:	f8c3 c004 	str.w	ip, [r3, #4]
        for (j = 0; j < n2; j++) {
 8012a00:	3308      	adds	r3, #8
 8012a02:	429a      	cmp	r2, r3
 8012a04:	d1f8      	bne.n	80129f8 <cblas_cgemm+0x10c>
      for (i = 0; i < n1; i++) {
 8012a06:	3101      	adds	r1, #1
 8012a08:	428f      	cmp	r7, r1
 8012a0a:	4422      	add	r2, r4
 8012a0c:	d1f0      	bne.n	80129f0 <cblas_cgemm+0x104>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8012a0e:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8012a12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012a16:	d104      	bne.n	8012a22 <cblas_cgemm+0x136>
 8012a18:	eef5 3a40 	vcmp.f32	s7, #0.0
 8012a1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012a20:	d07d      	beq.n	8012b1e <cblas_cgemm+0x232>
      return;

    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 8012a22:	2d6f      	cmp	r5, #111	; 0x6f
 8012a24:	f000 8148 	beq.w	8012cb8 <cblas_cgemm+0x3cc>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 8012a28:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8012a2c:	f000 826e 	beq.w	8012f0c <cblas_cgemm+0x620>
        }
      }

    } else if (TransF == CblasTrans && TransG == CblasTrans) {

      for (i = 0; i < n1; i++) {
 8012a30:	2f00      	cmp	r7, #0
 8012a32:	dd74      	ble.n	8012b1e <cblas_cgemm+0x232>
 8012a34:	ea4f 01cb 	mov.w	r1, fp, lsl #3
 8012a38:	9100      	str	r1, [sp, #0]
 8012a3a:	9916      	ldr	r1, [sp, #88]	; 0x58
 8012a3c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012a3e:	970e      	str	r7, [sp, #56]	; 0x38
 8012a40:	eb01 0ec6 	add.w	lr, r1, r6, lsl #3
 8012a44:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8012a46:	f8cd b05c 	str.w	fp, [sp, #92]	; 0x5c
 8012a4a:	f101 0c04 	add.w	ip, r1, #4
 8012a4e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8012a50:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
 8012a54:	2300      	movs	r3, #0
 8012a56:	e9cd 6101 	strd	r6, r1, [sp, #4]
 8012a5a:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8012a5c:	00d0      	lsls	r0, r2, #3
 8012a5e:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 8012a62:	461f      	mov	r7, r3
 8012a64:	469b      	mov	fp, r3
        for (j = 0; j < n2; j++) {
 8012a66:	9b01      	ldr	r3, [sp, #4]
 8012a68:	2b00      	cmp	r3, #0
 8012a6a:	dd4e      	ble.n	8012b0a <cblas_cgemm+0x21e>
 8012a6c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012a6e:	9902      	ldr	r1, [sp, #8]
 8012a70:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
 8012a74:	2500      	movs	r5, #0
          BASE temp_real = 0.0;
          BASE temp_imag = 0.0;
 8012a76:	ed9f 5a8d 	vldr	s10, [pc, #564]	; 8012cac <cblas_cgemm+0x3c0>
          for (k = 0; k < K; k++) {
 8012a7a:	f1b8 0f00 	cmp.w	r8, #0
          BASE temp_real = 0.0;
 8012a7e:	bfd8      	it	le
 8012a80:	eef0 4a45 	vmovle.f32	s9, s10
          for (k = 0; k < K; k++) {
 8012a84:	dd24      	ble.n	8012ad0 <cblas_cgemm+0x1e4>
 8012a86:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 8012a8a:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
          BASE temp_real = 0.0;
 8012a8e:	eef0 4a45 	vmov.f32	s9, s10
 8012a92:	eb06 03c5 	add.w	r3, r6, r5, lsl #3
          for (k = 0; k < K; k++) {
 8012a96:	4662      	mov	r2, ip
            const BASE Fki_real = CONST_REAL(F, ldf * k + i);
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8012a98:	ed93 7a01 	vldr	s14, [r3, #4]
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8012a9c:	edd2 7a00 	vldr	s15, [r2]
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 8012aa0:	ed93 6a00 	vldr	s12, [r3]
            const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 8012aa4:	ed52 5a01 	vldr	s11, [r2, #-4]
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8012aa8:	ee61 7aa7 	vmul.f32	s15, s3, s15
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8012aac:	ee22 7a07 	vmul.f32	s14, s4, s14

            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8012ab0:	ee67 6a86 	vmul.f32	s13, s15, s12
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8012ab4:	ee67 7a67 	vnmul.f32	s15, s14, s15
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8012ab8:	eee5 6a87 	vfma.f32	s13, s11, s14
 8012abc:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8012abe:	4299      	cmp	r1, r3
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8012ac0:	eee5 7a86 	vfma.f32	s15, s11, s12
 8012ac4:	4402      	add	r2, r0
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8012ac6:	ee35 5a26 	vadd.f32	s10, s10, s13
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8012aca:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 8012ace:	d1e3      	bne.n	8012a98 <cblas_cgemm+0x1ac>
          }
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012ad0:	ee25 7a63 	vnmul.f32	s14, s10, s7
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012ad4:	ee63 7aa4 	vmul.f32	s15, s7, s9
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012ad8:	eea4 7a24 	vfma.f32	s14, s8, s9
 8012adc:	3408      	adds	r4, #8
 8012ade:	444d      	add	r5, r9
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012ae0:	eee4 7a05 	vfma.f32	s15, s8, s10
 8012ae4:	4451      	add	r1, sl
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012ae6:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012aea:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012aee:	ed14 7a02 	vldr	s14, [r4, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012af2:	ed54 7a01 	vldr	s15, [r4, #-4]
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012af6:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012afa:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012afe:	ed04 7a02 	vstr	s14, [r4, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012b02:	ed44 7a01 	vstr	s15, [r4, #-4]
        for (j = 0; j < n2; j++) {
 8012b06:	45a6      	cmp	lr, r4
 8012b08:	d1b5      	bne.n	8012a76 <cblas_cgemm+0x18a>
      for (i = 0; i < n1; i++) {
 8012b0a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8012b0c:	449b      	add	fp, r3
 8012b0e:	9b00      	ldr	r3, [sp, #0]
 8012b10:	449e      	add	lr, r3
 8012b12:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012b14:	3701      	adds	r7, #1
 8012b16:	42bb      	cmp	r3, r7
 8012b18:	f10c 0c08 	add.w	ip, ip, #8
 8012b1c:	d1a3      	bne.n	8012a66 <cblas_cgemm+0x17a>
#define BASE float
#include "source_gemm_c.h"
#undef BASE
}
 8012b1e:	b005      	add	sp, #20
 8012b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8012b24:	3865      	subs	r0, #101	; 0x65
 8012b26:	2801      	cmp	r0, #1
 8012b28:	bf94      	ite	ls
 8012b2a:	2000      	movls	r0, #0
 8012b2c:	2001      	movhi	r0, #1
 8012b2e:	2170      	movs	r1, #112	; 0x70
 8012b30:	e6f8      	b.n	8012924 <cblas_cgemm+0x38>
 8012b32:	2d65      	cmp	r5, #101	; 0x65
 8012b34:	f04f 0006 	mov.w	r0, #6
 8012b38:	d063      	beq.n	8012c02 <cblas_cgemm+0x316>
 8012b3a:	2d66      	cmp	r5, #102	; 0x66
 8012b3c:	d11c      	bne.n	8012b78 <cblas_cgemm+0x28c>
 8012b3e:	2a6f      	cmp	r2, #111	; 0x6f
 8012b40:	bf0c      	ite	eq
 8012b42:	4643      	moveq	r3, r8
 8012b44:	463b      	movne	r3, r7
 8012b46:	2b01      	cmp	r3, #1
 8012b48:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012b4a:	bfb8      	it	lt
 8012b4c:	2301      	movlt	r3, #1
 8012b4e:	4293      	cmp	r3, r2
 8012b50:	bfc8      	it	gt
 8012b52:	200b      	movgt	r0, #11
 8012b54:	296f      	cmp	r1, #111	; 0x6f
 8012b56:	f000 81cd 	beq.w	8012ef4 <cblas_cgemm+0x608>
 8012b5a:	4643      	mov	r3, r8
 8012b5c:	2b01      	cmp	r3, #1
 8012b5e:	bfb8      	it	lt
 8012b60:	2301      	movlt	r3, #1
 8012b62:	454b      	cmp	r3, r9
 8012b64:	f300 8282 	bgt.w	801306c <cblas_cgemm+0x780>
 8012b68:	2e01      	cmp	r6, #1
 8012b6a:	4633      	mov	r3, r6
 8012b6c:	bfb8      	it	lt
 8012b6e:	2301      	movlt	r3, #1
 8012b70:	459b      	cmp	fp, r3
 8012b72:	f6bf aeec 	bge.w	801294e <cblas_cgemm+0x62>
 8012b76:	200e      	movs	r0, #14
 8012b78:	4a4a      	ldr	r2, [pc, #296]	; (8012ca4 <cblas_cgemm+0x3b8>)
 8012b7a:	494b      	ldr	r1, [pc, #300]	; (8012ca8 <cblas_cgemm+0x3bc>)
 8012b7c:	f015 fdc4 	bl	8028708 <cblas_xerbla>
 8012b80:	e6e8      	b.n	8012954 <cblas_cgemm+0x68>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8012b82:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8012b86:	eef4 5a67 	vcmp.f32	s11, s15
 8012b8a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012b8e:	d105      	bne.n	8012b9c <cblas_cgemm+0x2b0>
 8012b90:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8012b94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012b98:	f43f af39 	beq.w	8012a0e <cblas_cgemm+0x122>
      for (i = 0; i < n1; i++) {
 8012b9c:	2f00      	cmp	r7, #0
 8012b9e:	f77f af36 	ble.w	8012a0e <cblas_cgemm+0x122>
 8012ba2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012ba4:	ebc6 7446 	rsb	r4, r6, r6, lsl #29
 8012ba8:	00e4      	lsls	r4, r4, #3
 8012baa:	f104 0e04 	add.w	lr, r4, #4
 8012bae:	ea4f 0ccb 	mov.w	ip, fp, lsl #3
 8012bb2:	eb03 01c6 	add.w	r1, r3, r6, lsl #3
 8012bb6:	2000      	movs	r0, #0
        for (j = 0; j < n2; j++) {
 8012bb8:	2e00      	cmp	r6, #0
 8012bba:	dd16      	ble.n	8012bea <cblas_cgemm+0x2fe>
 8012bbc:	1863      	adds	r3, r4, r1
 8012bbe:	eb0e 0201 	add.w	r2, lr, r1
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 8012bc2:	edd3 6a01 	vldr	s13, [r3, #4]
          const BASE Cij_real = REAL(C, ldc * i + j);
 8012bc6:	ed12 6a01 	vldr	s12, [r2, #-4]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8012bca:	ee26 7ac5 	vnmul.f32	s14, s13, s10
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8012bce:	ee65 7a06 	vmul.f32	s15, s10, s12
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8012bd2:	eea5 7a86 	vfma.f32	s14, s11, s12
 8012bd6:	3308      	adds	r3, #8
 8012bd8:	3208      	adds	r2, #8
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8012bda:	eee5 7aa6 	vfma.f32	s15, s11, s13
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8012bde:	ed02 7a03 	vstr	s14, [r2, #-12]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8012be2:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < n2; j++) {
 8012be6:	4299      	cmp	r1, r3
 8012be8:	d1eb      	bne.n	8012bc2 <cblas_cgemm+0x2d6>
      for (i = 0; i < n1; i++) {
 8012bea:	3001      	adds	r0, #1
 8012bec:	4287      	cmp	r7, r0
 8012bee:	4461      	add	r1, ip
 8012bf0:	d1e2      	bne.n	8012bb8 <cblas_cgemm+0x2cc>
 8012bf2:	e70c      	b.n	8012a0e <cblas_cgemm+0x122>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8012bf4:	f1b8 0f00 	cmp.w	r8, #0
 8012bf8:	db9b      	blt.n	8012b32 <cblas_cgemm+0x246>
 8012bfa:	2d65      	cmp	r5, #101	; 0x65
 8012bfc:	f04f 0005 	mov.w	r0, #5
 8012c00:	d19b      	bne.n	8012b3a <cblas_cgemm+0x24e>
 8012c02:	2a6f      	cmp	r2, #111	; 0x6f
 8012c04:	bf0c      	ite	eq
 8012c06:	4643      	moveq	r3, r8
 8012c08:	4633      	movne	r3, r6
 8012c0a:	2b01      	cmp	r3, #1
 8012c0c:	bfb8      	it	lt
 8012c0e:	2301      	movlt	r3, #1
 8012c10:	454b      	cmp	r3, r9
 8012c12:	bfc8      	it	gt
 8012c14:	2009      	movgt	r0, #9
 8012c16:	296f      	cmp	r1, #111	; 0x6f
 8012c18:	f000 820f 	beq.w	801303a <cblas_cgemm+0x74e>
 8012c1c:	4643      	mov	r3, r8
 8012c1e:	2b01      	cmp	r3, #1
 8012c20:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012c22:	bfb8      	it	lt
 8012c24:	2301      	movlt	r3, #1
 8012c26:	4293      	cmp	r3, r2
 8012c28:	f340 80d6 	ble.w	8012dd8 <cblas_cgemm+0x4ec>
 8012c2c:	2f01      	cmp	r7, #1
 8012c2e:	4638      	mov	r0, r7
 8012c30:	bfb8      	it	lt
 8012c32:	2001      	movlt	r0, #1
 8012c34:	4a1b      	ldr	r2, [pc, #108]	; (8012ca4 <cblas_cgemm+0x3b8>)
 8012c36:	491c      	ldr	r1, [pc, #112]	; (8012ca8 <cblas_cgemm+0x3bc>)
 8012c38:	4583      	cmp	fp, r0
 8012c3a:	bfb4      	ite	lt
 8012c3c:	200e      	movlt	r0, #14
 8012c3e:	200b      	movge	r0, #11
 8012c40:	f015 fd62 	bl	8028708 <cblas_xerbla>
 8012c44:	e686      	b.n	8012954 <cblas_cgemm+0x68>
 8012c46:	2971      	cmp	r1, #113	; 0x71
 8012c48:	f000 81f1 	beq.w	801302e <cblas_cgemm+0x742>
 8012c4c:	2a71      	cmp	r2, #113	; 0x71
 8012c4e:	f000 81e6 	beq.w	801301e <cblas_cgemm+0x732>
 8012c52:	f1aa 036f 	sub.w	r3, sl, #111	; 0x6f
 8012c56:	2b02      	cmp	r3, #2
 8012c58:	4611      	mov	r1, r2
 8012c5a:	4652      	mov	r2, sl
 8012c5c:	f63f ae61 	bhi.w	8012922 <cblas_cgemm+0x36>
 8012c60:	e0ac      	b.n	8012dbc <cblas_cgemm+0x4d0>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 8012c62:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
 8012c66:	f000 81fd 	beq.w	8013064 <cblas_cgemm+0x778>
 8012c6a:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8012c6e:	eddf 2a11 	vldr	s5, [pc, #68]	; 8012cb4 <cblas_cgemm+0x3c8>
 8012c72:	bf0c      	ite	eq
 8012c74:	256f      	moveq	r5, #111	; 0x6f
 8012c76:	2570      	movne	r5, #112	; 0x70
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8012c78:	9914      	ldr	r1, [sp, #80]	; 0x50
 8012c7a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012c7c:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
 8012c80:	463a      	mov	r2, r7
 8012c82:	2c71      	cmp	r4, #113	; 0x71
 8012c84:	4637      	mov	r7, r6
 8012c86:	4689      	mov	r9, r1
 8012c88:	4616      	mov	r6, r2
 8012c8a:	f000 81e3 	beq.w	8013054 <cblas_cgemm+0x768>
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8012c8e:	2c6f      	cmp	r4, #111	; 0x6f
 8012c90:	f040 80a7 	bne.w	8012de2 <cblas_cgemm+0x4f6>
      F = (const BASE *)A;
 8012c94:	9a11      	ldr	r2, [sp, #68]	; 0x44
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8012c96:	ed9f 3a07 	vldr	s6, [pc, #28]	; 8012cb4 <cblas_cgemm+0x3c8>
      F = (const BASE *)A;
 8012c9a:	9213      	str	r2, [sp, #76]	; 0x4c
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8012c9c:	46a2      	mov	sl, r4
      G = (const BASE *)B;
 8012c9e:	9311      	str	r3, [sp, #68]	; 0x44
 8012ca0:	e68d      	b.n	80129be <cblas_cgemm+0xd2>
 8012ca2:	bf00      	nop
 8012ca4:	08031108 	.word	0x08031108
 8012ca8:	080312c0 	.word	0x080312c0
 8012cac:	00000000 	.word	0x00000000
 8012cb0:	ffffffff 	.word	0xffffffff
 8012cb4:	00000001 	.word	0x00000001
    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 8012cb8:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8012cbc:	f000 8099 	beq.w	8012df2 <cblas_cgemm+0x506>
      for (i = 0; i < n1; i++) {
 8012cc0:	2f00      	cmp	r7, #0
 8012cc2:	f77f af2c 	ble.w	8012b1e <cblas_cgemm+0x232>
 8012cc6:	ea4f 02cb 	mov.w	r2, fp, lsl #3
 8012cca:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8012ccc:	9200      	str	r2, [sp, #0]
 8012cce:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012cd0:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 8012cd2:	9601      	str	r6, [sp, #4]
 8012cd4:	f04f 0a00 	mov.w	sl, #0
 8012cd8:	00db      	lsls	r3, r3, #3
 8012cda:	eb02 0cc6 	add.w	ip, r2, r6, lsl #3
 8012cde:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8012ce0:	970e      	str	r7, [sp, #56]	; 0x38
 8012ce2:	eb05 01c8 	add.w	r1, r5, r8, lsl #3
 8012ce6:	46d6      	mov	lr, sl
 8012ce8:	461f      	mov	r7, r3
        for (j = 0; j < n2; j++) {
 8012cea:	9b01      	ldr	r3, [sp, #4]
 8012cec:	2b00      	cmp	r3, #0
 8012cee:	dd4d      	ble.n	8012d8c <cblas_cgemm+0x4a0>
 8012cf0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012cf2:	2400      	movs	r4, #0
 8012cf4:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
          BASE temp_imag = 0.0;
 8012cf8:	ed1f 5a14 	vldr	s10, [pc, #-80]	; 8012cac <cblas_cgemm+0x3c0>
          for (k = 0; k < K; k++) {
 8012cfc:	f1b8 0f00 	cmp.w	r8, #0
          BASE temp_real = 0.0;
 8012d00:	bfd8      	it	le
 8012d02:	eef0 4a45 	vmovle.f32	s9, s10
          for (k = 0; k < K; k++) {
 8012d06:	dd25      	ble.n	8012d54 <cblas_cgemm+0x468>
 8012d08:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 8012d0c:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
          BASE temp_real = 0.0;
 8012d10:	eef0 4a45 	vmov.f32	s9, s10
 8012d14:	eb06 02c4 	add.w	r2, r6, r4, lsl #3
          for (k = 0; k < K; k++) {
 8012d18:	462b      	mov	r3, r5
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8012d1a:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8012d1e:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 8012d22:	ed92 6a00 	vldr	s12, [r2]
            const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 8012d26:	edd3 5a00 	vldr	s11, [r3]
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8012d2a:	ee61 7aa7 	vmul.f32	s15, s3, s15
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8012d2e:	ee22 7a07 	vmul.f32	s14, s4, s14
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8012d32:	ee67 6a86 	vmul.f32	s13, s15, s12
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8012d36:	ee67 7a67 	vnmul.f32	s15, s14, s15
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8012d3a:	eee5 6a87 	vfma.f32	s13, s11, s14
 8012d3e:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8012d40:	4299      	cmp	r1, r3
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8012d42:	eee5 7a86 	vfma.f32	s15, s11, s12
 8012d46:	f102 0208 	add.w	r2, r2, #8
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8012d4a:	ee35 5a26 	vadd.f32	s10, s10, s13
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8012d4e:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 8012d52:	d1e2      	bne.n	8012d1a <cblas_cgemm+0x42e>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012d54:	ee25 7a63 	vnmul.f32	s14, s10, s7
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012d58:	ee63 7aa4 	vmul.f32	s15, s7, s9
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012d5c:	eea4 7a24 	vfma.f32	s14, s8, s9
 8012d60:	3008      	adds	r0, #8
 8012d62:	444c      	add	r4, r9
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012d64:	eee4 7a05 	vfma.f32	s15, s8, s10
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012d68:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012d6c:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012d70:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012d74:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012d78:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012d7c:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012d80:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012d84:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 8012d88:	4584      	cmp	ip, r0
 8012d8a:	d1b5      	bne.n	8012cf8 <cblas_cgemm+0x40c>
      for (i = 0; i < n1; i++) {
 8012d8c:	9b00      	ldr	r3, [sp, #0]
 8012d8e:	449c      	add	ip, r3
 8012d90:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012d92:	f10e 0e01 	add.w	lr, lr, #1
 8012d96:	4573      	cmp	r3, lr
 8012d98:	44da      	add	sl, fp
 8012d9a:	443d      	add	r5, r7
 8012d9c:	4439      	add	r1, r7
 8012d9e:	d1a4      	bne.n	8012cea <cblas_cgemm+0x3fe>
 8012da0:	e6bd      	b.n	8012b1e <cblas_cgemm+0x232>
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 8012da2:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 8012da6:	ed5f 2a3e 	vldr	s5, [pc, #-248]	; 8012cb0 <cblas_cgemm+0x3c4>
      TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8012daa:	f04f 0570 	mov.w	r5, #112	; 0x70
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 8012dae:	f47f adfd 	bne.w	80129ac <cblas_cgemm+0xc0>
 8012db2:	ed1f 3a41 	vldr	s6, [pc, #-260]	; 8012cb0 <cblas_cgemm+0x3c4>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8012db6:	f04f 0a70 	mov.w	sl, #112	; 0x70
 8012dba:	e600      	b.n	80129be <cblas_cgemm+0xd2>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8012dbc:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 8012dc0:	2801      	cmp	r0, #1
 8012dc2:	bf94      	ite	ls
 8012dc4:	2000      	movls	r0, #0
 8012dc6:	2001      	movhi	r0, #1
 8012dc8:	e5ac      	b.n	8012924 <cblas_cgemm+0x38>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8012dca:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8012dce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012dd2:	f47f addb 	bne.w	801298c <cblas_cgemm+0xa0>
 8012dd6:	e6a2      	b.n	8012b1e <cblas_cgemm+0x232>
 8012dd8:	2f01      	cmp	r7, #1
 8012dda:	463b      	mov	r3, r7
 8012ddc:	bfb8      	it	lt
 8012dde:	2301      	movlt	r3, #1
 8012de0:	e6c6      	b.n	8012b70 <cblas_cgemm+0x284>
      F = (const BASE *)A;
 8012de2:	9a11      	ldr	r2, [sp, #68]	; 0x44
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8012de4:	ed1f 3a4d 	vldr	s6, [pc, #-308]	; 8012cb4 <cblas_cgemm+0x3c8>
      F = (const BASE *)A;
 8012de8:	9213      	str	r2, [sp, #76]	; 0x4c
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8012dea:	f04f 0a70 	mov.w	sl, #112	; 0x70
      G = (const BASE *)B;
 8012dee:	9311      	str	r3, [sp, #68]	; 0x44
 8012df0:	e5e5      	b.n	80129be <cblas_cgemm+0xd2>
      for (k = 0; k < K; k++) {
 8012df2:	f1b8 0f00 	cmp.w	r8, #0
 8012df6:	f77f ae92 	ble.w	8012b1e <cblas_cgemm+0x232>
 8012dfa:	2300      	movs	r3, #0
 8012dfc:	9300      	str	r3, [sp, #0]
 8012dfe:	9302      	str	r3, [sp, #8]
 8012e00:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012e02:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012e04:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8012e08:	3304      	adds	r3, #4
 8012e0a:	9301      	str	r3, [sp, #4]
 8012e0c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012e0e:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 8012e12:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 8012e16:	3304      	adds	r3, #4
 8012e18:	ea4f 0ec2 	mov.w	lr, r2, lsl #3
 8012e1c:	469a      	mov	sl, r3
        for (i = 0; i < n1; i++) {
 8012e1e:	2f00      	cmp	r7, #0
 8012e20:	dd5a      	ble.n	8012ed8 <cblas_cgemm+0x5ec>
 8012e22:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012e24:	9a00      	ldr	r2, [sp, #0]
 8012e26:	9c01      	ldr	r4, [sp, #4]
 8012e28:	2500      	movs	r5, #0
 8012e2a:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 8012e2e:	46ac      	mov	ip, r5
 8012e30:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
 8012e34:	e00a      	b.n	8012e4c <cblas_cgemm+0x560>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 8012e36:	eef5 4a40 	vcmp.f32	s9, #0.0
 8012e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012e3e:	d118      	bne.n	8012e72 <cblas_cgemm+0x586>
        for (i = 0; i < n1; i++) {
 8012e40:	f10c 0c01 	add.w	ip, ip, #1
 8012e44:	4567      	cmp	r7, ip
 8012e46:	445d      	add	r5, fp
 8012e48:	4474      	add	r4, lr
 8012e4a:	d045      	beq.n	8012ed8 <cblas_cgemm+0x5ec>
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8012e4c:	edd4 7a00 	vldr	s15, [r4]
          const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 8012e50:	ed14 7a01 	vldr	s14, [r4, #-4]
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8012e54:	ee61 7aa7 	vmul.f32	s15, s3, s15
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 8012e58:	ee63 4a87 	vmul.f32	s9, s7, s14
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 8012e5c:	ee67 5ae3 	vnmul.f32	s11, s15, s7
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 8012e60:	eee4 4a27 	vfma.f32	s9, s8, s15
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 8012e64:	eee4 5a07 	vfma.f32	s11, s8, s14
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 8012e68:	eef5 5a40 	vcmp.f32	s11, #0.0
 8012e6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012e70:	d0e1      	beq.n	8012e36 <cblas_cgemm+0x54a>
            for (j = 0; j < n2; j++) {
 8012e72:	2e00      	cmp	r6, #0
 8012e74:	dde4      	ble.n	8012e40 <cblas_cgemm+0x554>
 8012e76:	1970      	adds	r0, r6, r5
 8012e78:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
 8012e7c:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
 8012e80:	eb08 03c5 	add.w	r3, r8, r5, lsl #3
 8012e84:	eb0a 01c5 	add.w	r1, sl, r5, lsl #3
 8012e88:	464a      	mov	r2, r9
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 8012e8a:	edd2 7a01 	vldr	s15, [r2, #4]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 8012e8e:	ed92 5a00 	vldr	s10, [r2]
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012e92:	ed51 6a01 	vldr	s13, [r1, #-4]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 8012e96:	ee62 7a27 	vmul.f32	s15, s4, s15
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012e9a:	ee24 7a85 	vmul.f32	s14, s9, s10
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012e9e:	ee27 6ae4 	vnmul.f32	s12, s15, s9
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012ea2:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8012ea6:	3308      	adds	r3, #8
 8012ea8:	3208      	adds	r2, #8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012eaa:	eef0 7a46 	vmov.f32	s15, s12
 8012eae:	eee5 7a85 	vfma.f32	s15, s11, s10
 8012eb2:	3108      	adds	r1, #8
 8012eb4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8012eb8:	ed41 7a03 	vstr	s15, [r1, #-12]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012ebc:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012ec0:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012ec4:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (j = 0; j < n2; j++) {
 8012ec8:	4298      	cmp	r0, r3
 8012eca:	d1de      	bne.n	8012e8a <cblas_cgemm+0x59e>
        for (i = 0; i < n1; i++) {
 8012ecc:	f10c 0c01 	add.w	ip, ip, #1
 8012ed0:	4567      	cmp	r7, ip
 8012ed2:	445d      	add	r5, fp
 8012ed4:	4474      	add	r4, lr
 8012ed6:	d1b9      	bne.n	8012e4c <cblas_cgemm+0x560>
      for (k = 0; k < K; k++) {
 8012ed8:	9a01      	ldr	r2, [sp, #4]
 8012eda:	9912      	ldr	r1, [sp, #72]	; 0x48
 8012edc:	9b02      	ldr	r3, [sp, #8]
 8012ede:	3208      	adds	r2, #8
 8012ee0:	9201      	str	r2, [sp, #4]
 8012ee2:	9a00      	ldr	r2, [sp, #0]
 8012ee4:	440a      	add	r2, r1
 8012ee6:	9200      	str	r2, [sp, #0]
 8012ee8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8012eea:	3301      	adds	r3, #1
 8012eec:	429a      	cmp	r2, r3
 8012eee:	9302      	str	r3, [sp, #8]
 8012ef0:	d195      	bne.n	8012e1e <cblas_cgemm+0x532>
 8012ef2:	e614      	b.n	8012b1e <cblas_cgemm+0x232>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8012ef4:	2e01      	cmp	r6, #1
 8012ef6:	4633      	mov	r3, r6
 8012ef8:	bfb8      	it	lt
 8012efa:	2301      	movlt	r3, #1
 8012efc:	454b      	cmp	r3, r9
 8012efe:	f77f ae37 	ble.w	8012b70 <cblas_cgemm+0x284>
 8012f02:	455b      	cmp	r3, fp
 8012f04:	bfcc      	ite	gt
 8012f06:	200e      	movgt	r0, #14
 8012f08:	2009      	movle	r0, #9
 8012f0a:	e635      	b.n	8012b78 <cblas_cgemm+0x28c>
      for (k = 0; k < K; k++) {
 8012f0c:	f1b8 0f00 	cmp.w	r8, #0
 8012f10:	f77f ae05 	ble.w	8012b1e <cblas_cgemm+0x232>
 8012f14:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012f16:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 8012f1a:	00d2      	lsls	r2, r2, #3
 8012f1c:	9202      	str	r2, [sp, #8]
 8012f1e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012f20:	eb02 0cc7 	add.w	ip, r2, r7, lsl #3
 8012f24:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012f26:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8012f2a:	2300      	movs	r3, #0
 8012f2c:	9203      	str	r2, [sp, #12]
 8012f2e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012f30:	e9cd 3300 	strd	r3, r3, [sp]
 8012f34:	e9cd 780e 	strd	r7, r8, [sp, #56]	; 0x38
 8012f38:	3204      	adds	r2, #4
 8012f3a:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 8012f3e:	ea4f 0ecb 	mov.w	lr, fp, lsl #3
 8012f42:	469a      	mov	sl, r3
 8012f44:	4691      	mov	r9, r2
        for (i = 0; i < n1; i++) {
 8012f46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012f48:	2b00      	cmp	r3, #0
 8012f4a:	dd58      	ble.n	8012ffe <cblas_cgemm+0x712>
 8012f4c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012f4e:	9a01      	ldr	r2, [sp, #4]
 8012f50:	9803      	ldr	r0, [sp, #12]
 8012f52:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
 8012f56:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012f58:	9a00      	ldr	r2, [sp, #0]
 8012f5a:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 8012f5e:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 8012f62:	2500      	movs	r5, #0
 8012f64:	e009      	b.n	8012f7a <cblas_cgemm+0x68e>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 8012f66:	eef5 4a40 	vcmp.f32	s9, #0.0
 8012f6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f6e:	d117      	bne.n	8012fa0 <cblas_cgemm+0x6b4>
        for (i = 0; i < n1; i++) {
 8012f70:	3408      	adds	r4, #8
 8012f72:	45a4      	cmp	ip, r4
 8012f74:	445d      	add	r5, fp
 8012f76:	4470      	add	r0, lr
 8012f78:	d041      	beq.n	8012ffe <cblas_cgemm+0x712>
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8012f7a:	edd4 7a01 	vldr	s15, [r4, #4]
          const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 8012f7e:	ed94 7a00 	vldr	s14, [r4]
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8012f82:	ee61 7aa7 	vmul.f32	s15, s3, s15
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 8012f86:	ee63 4a87 	vmul.f32	s9, s7, s14
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 8012f8a:	ee67 5ae3 	vnmul.f32	s11, s15, s7
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 8012f8e:	eee4 4a27 	vfma.f32	s9, s8, s15
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 8012f92:	eee4 5a07 	vfma.f32	s11, s8, s14
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 8012f96:	eef5 5a40 	vcmp.f32	s11, #0.0
 8012f9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f9e:	d0e2      	beq.n	8012f66 <cblas_cgemm+0x67a>
            for (j = 0; j < n2; j++) {
 8012fa0:	2e00      	cmp	r6, #0
 8012fa2:	dde5      	ble.n	8012f70 <cblas_cgemm+0x684>
 8012fa4:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
 8012fa8:	eb08 03c5 	add.w	r3, r8, r5, lsl #3
 8012fac:	eb09 01c5 	add.w	r1, r9, r5, lsl #3
 8012fb0:	463a      	mov	r2, r7
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 8012fb2:	edd2 7a01 	vldr	s15, [r2, #4]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 8012fb6:	ed92 5a00 	vldr	s10, [r2]
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012fba:	ed51 6a01 	vldr	s13, [r1, #-4]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 8012fbe:	ee62 7a27 	vmul.f32	s15, s4, s15
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012fc2:	ee24 7a85 	vmul.f32	s14, s9, s10
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012fc6:	ee27 6ae4 	vnmul.f32	s12, s15, s9
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012fca:	eea5 7aa7 	vfma.f32	s14, s11, s15
 8012fce:	3308      	adds	r3, #8
 8012fd0:	3208      	adds	r2, #8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012fd2:	eef0 7a46 	vmov.f32	s15, s12
 8012fd6:	eee5 7a85 	vfma.f32	s15, s11, s10
 8012fda:	3108      	adds	r1, #8
 8012fdc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8012fe0:	ed41 7a03 	vstr	s15, [r1, #-12]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012fe4:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012fe8:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012fec:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (j = 0; j < n2; j++) {
 8012ff0:	4298      	cmp	r0, r3
 8012ff2:	d1de      	bne.n	8012fb2 <cblas_cgemm+0x6c6>
        for (i = 0; i < n1; i++) {
 8012ff4:	3408      	adds	r4, #8
 8012ff6:	45a4      	cmp	ip, r4
 8012ff8:	445d      	add	r5, fp
 8012ffa:	4470      	add	r0, lr
 8012ffc:	d1bd      	bne.n	8012f7a <cblas_cgemm+0x68e>
      for (k = 0; k < K; k++) {
 8012ffe:	9b02      	ldr	r3, [sp, #8]
 8013000:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8013002:	449c      	add	ip, r3
 8013004:	9b01      	ldr	r3, [sp, #4]
 8013006:	4413      	add	r3, r2
 8013008:	9301      	str	r3, [sp, #4]
 801300a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801300c:	9b00      	ldr	r3, [sp, #0]
 801300e:	4413      	add	r3, r2
 8013010:	9300      	str	r3, [sp, #0]
 8013012:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8013014:	f10a 0a01 	add.w	sl, sl, #1
 8013018:	4553      	cmp	r3, sl
 801301a:	d194      	bne.n	8012f46 <cblas_cgemm+0x65a>
 801301c:	e57f      	b.n	8012b1e <cblas_cgemm+0x232>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801301e:	f1a1 036f 	sub.w	r3, r1, #111	; 0x6f
 8013022:	2b02      	cmp	r3, #2
 8013024:	460a      	mov	r2, r1
 8013026:	d92b      	bls.n	8013080 <cblas_cgemm+0x794>
 8013028:	2170      	movs	r1, #112	; 0x70
 801302a:	2002      	movs	r0, #2
 801302c:	e47f      	b.n	801292e <cblas_cgemm+0x42>
 801302e:	2a71      	cmp	r2, #113	; 0x71
 8013030:	d025      	beq.n	801307e <cblas_cgemm+0x792>
 8013032:	4621      	mov	r1, r4
 8013034:	2270      	movs	r2, #112	; 0x70
 8013036:	2000      	movs	r0, #0
 8013038:	e474      	b.n	8012924 <cblas_cgemm+0x38>
 801303a:	2f01      	cmp	r7, #1
 801303c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801303e:	463b      	mov	r3, r7
 8013040:	bfb8      	it	lt
 8013042:	2301      	movlt	r3, #1
 8013044:	4293      	cmp	r3, r2
 8013046:	f77f ad93 	ble.w	8012b70 <cblas_cgemm+0x284>
 801304a:	455b      	cmp	r3, fp
 801304c:	bfcc      	ite	gt
 801304e:	200e      	movgt	r0, #14
 8013050:	200b      	movle	r0, #11
 8013052:	e591      	b.n	8012b78 <cblas_cgemm+0x28c>
      F = (const BASE *)A;
 8013054:	9a11      	ldr	r2, [sp, #68]	; 0x44
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8013056:	ed9f 3a0c 	vldr	s6, [pc, #48]	; 8013088 <cblas_cgemm+0x79c>
      F = (const BASE *)A;
 801305a:	9213      	str	r2, [sp, #76]	; 0x4c
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801305c:	f04f 0a70 	mov.w	sl, #112	; 0x70
      G = (const BASE *)B;
 8013060:	9311      	str	r3, [sp, #68]	; 0x44
 8013062:	e4ac      	b.n	80129be <cblas_cgemm+0xd2>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 8013064:	eddf 2a08 	vldr	s5, [pc, #32]	; 8013088 <cblas_cgemm+0x79c>
      TransF = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8013068:	2570      	movs	r5, #112	; 0x70
 801306a:	e605      	b.n	8012c78 <cblas_cgemm+0x38c>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801306c:	2e01      	cmp	r6, #1
 801306e:	4630      	mov	r0, r6
 8013070:	bfb8      	it	lt
 8013072:	2001      	movlt	r0, #1
 8013074:	4583      	cmp	fp, r0
 8013076:	bfb4      	ite	lt
 8013078:	200e      	movlt	r0, #14
 801307a:	2009      	movge	r0, #9
 801307c:	e57c      	b.n	8012b78 <cblas_cgemm+0x28c>
 801307e:	2270      	movs	r2, #112	; 0x70
 8013080:	2000      	movs	r0, #0
 8013082:	2170      	movs	r1, #112	; 0x70
 8013084:	e44e      	b.n	8012924 <cblas_cgemm+0x38>
 8013086:	bf00      	nop
 8013088:	ffffffff 	.word	0xffffffff

0801308c <cblas_cgemv>:
void
cblas_cgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const void *alpha, const void *A,
             const int lda, const void *X, const int incX, const void *beta,
             void *Y, const int incY)
{
 801308c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013090:	ed2d 8b04 	vpush	{d8-d9}
 8013094:	b083      	sub	sp, #12
 8013096:	4688      	mov	r8, r1
 8013098:	9915      	ldr	r1, [sp, #84]	; 0x54
 801309a:	9c10      	ldr	r4, [sp, #64]	; 0x40
  INDEX lenX, lenY;

  const BASE alpha_real = CONST_REAL0(alpha);
  const BASE alpha_imag = CONST_IMAG0(alpha);

  const BASE beta_real = CONST_REAL0(beta);
 801309c:	ed91 9a00 	vldr	s18, [r1]
  const BASE beta_imag = CONST_IMAG0(beta);
 80130a0:	edd1 9a01 	vldr	s19, [r1, #4]
 80130a4:	9911      	ldr	r1, [sp, #68]	; 0x44
 80130a6:	9100      	str	r1, [sp, #0]
 80130a8:	e9dd 9112 	ldrd	r9, r1, [sp, #72]	; 0x48
 80130ac:	9101      	str	r1, [sp, #4]

  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 80130ae:	f1a8 016f 	sub.w	r1, r8, #111	; 0x6f
 80130b2:	2902      	cmp	r1, #2
  const BASE alpha_real = CONST_REAL0(alpha);
 80130b4:	ed94 8a00 	vldr	s16, [r4]
  const BASE alpha_imag = CONST_IMAG0(alpha);
 80130b8:	edd4 8a01 	vldr	s17, [r4, #4]
 80130bc:	9e14      	ldr	r6, [sp, #80]	; 0x50
 80130be:	e9dd a416 	ldrd	sl, r4, [sp, #88]	; 0x58
 80130c2:	4683      	mov	fp, r0
 80130c4:	4615      	mov	r5, r2
 80130c6:	461f      	mov	r7, r3
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 80130c8:	d877      	bhi.n	80131ba <cblas_cgemv+0x12e>
 80130ca:	3865      	subs	r0, #101	; 0x65
 80130cc:	2801      	cmp	r0, #1
 80130ce:	bf94      	ite	ls
 80130d0:	2000      	movls	r0, #0
 80130d2:	2001      	movhi	r0, #1
 80130d4:	2d00      	cmp	r5, #0
 80130d6:	bfb8      	it	lt
 80130d8:	2003      	movlt	r0, #3
 80130da:	2f00      	cmp	r7, #0
 80130dc:	bfb8      	it	lt
 80130de:	2004      	movlt	r0, #4
 80130e0:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 80130e4:	f000 80a5 	beq.w	8013232 <cblas_cgemv+0x1a6>
 80130e8:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 80130ec:	d06c      	beq.n	80131c8 <cblas_cgemv+0x13c>
 80130ee:	2e00      	cmp	r6, #0
 80130f0:	d165      	bne.n	80131be <cblas_cgemv+0x132>
 80130f2:	2c00      	cmp	r4, #0
 80130f4:	bf14      	ite	ne
 80130f6:	2009      	movne	r0, #9
 80130f8:	200c      	moveq	r0, #12
 80130fa:	4ac4      	ldr	r2, [pc, #784]	; (801340c <cblas_cgemv+0x380>)
 80130fc:	49c4      	ldr	r1, [pc, #784]	; (8013410 <cblas_cgemv+0x384>)
 80130fe:	f015 fb03 	bl	8028708 <cblas_xerbla>

  if (M == 0 || N == 0)
 8013102:	2d00      	cmp	r5, #0
 8013104:	d054      	beq.n	80131b0 <cblas_cgemv+0x124>
 8013106:	2f00      	cmp	r7, #0
 8013108:	d052      	beq.n	80131b0 <cblas_cgemv+0x124>
    return;

  if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801310a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 801310e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013112:	d104      	bne.n	801311e <cblas_cgemv+0x92>
 8013114:	eef5 8a40 	vcmp.f32	s17, #0.0
 8013118:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801311c:	d03c      	beq.n	8013198 <cblas_cgemv+0x10c>
      && (beta_real == 1.0 && beta_imag == 0.0))
    return;

  if (TransA == CblasNoTrans) {
 801311e:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8013122:	d002      	beq.n	801312a <cblas_cgemv+0x9e>
 8013124:	463b      	mov	r3, r7
 8013126:	462f      	mov	r7, r5
 8013128:	461d      	mov	r5, r3
    lenY = N;
  }

  /* form  y := beta*y */

  if (beta_real == 0.0 && beta_imag == 0.0) {
 801312a:	eeb5 9a40 	vcmp.f32	s18, #0.0
 801312e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013132:	f040 808e 	bne.w	8013252 <cblas_cgemv+0x1c6>
 8013136:	eef5 9a40 	vcmp.f32	s19, #0.0
 801313a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801313e:	d156      	bne.n	80131ee <cblas_cgemv+0x162>
    INDEX iy = OFFSET(lenY, incY);
 8013140:	2c00      	cmp	r4, #0
 8013142:	f340 822b 	ble.w	801359c <cblas_cgemv+0x510>
 8013146:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8013148:	2d00      	cmp	r5, #0
 801314a:	dd0a      	ble.n	8013162 <cblas_cgemv+0xd6>
      REAL(Y, iy) = 0.0;
 801314c:	2100      	movs	r1, #0
 801314e:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
 8013152:	00e0      	lsls	r0, r4, #3
    for (i = 0; i < lenY; i++) {
 8013154:	2200      	movs	r2, #0
 8013156:	3201      	adds	r2, #1
 8013158:	4295      	cmp	r5, r2
      REAL(Y, iy) = 0.0;
 801315a:	6019      	str	r1, [r3, #0]
      IMAG(Y, iy) = 0.0;
 801315c:	6059      	str	r1, [r3, #4]
    for (i = 0; i < lenY; i++) {
 801315e:	4403      	add	r3, r0
 8013160:	d1f9      	bne.n	8013156 <cblas_cgemv+0xca>
      IMAG(Y, iy) = tmpI;
      iy += incY;
    }
  }

  if (alpha_real == 0.0 && alpha_imag == 0.0)
 8013162:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8013166:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801316a:	d104      	bne.n	8013176 <cblas_cgemv+0xea>
 801316c:	eef5 8a40 	vcmp.f32	s17, #0.0
 8013170:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013174:	d01c      	beq.n	80131b0 <cblas_cgemv+0x124>
    return;

  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 8013176:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 801317a:	d07a      	beq.n	8013272 <cblas_cgemv+0x1e6>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801317c:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8013180:	f000 80db 	beq.w	801333a <cblas_cgemv+0x2ae>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
      iy += incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8013184:	4aa3      	ldr	r2, [pc, #652]	; (8013414 <cblas_cgemv+0x388>)
 8013186:	49a2      	ldr	r1, [pc, #648]	; (8013410 <cblas_cgemv+0x384>)
 8013188:	2000      	movs	r0, #0
#define BASE float
#include "source_gemv_c.h"
#undef BASE
}
 801318a:	b003      	add	sp, #12
 801318c:	ecbd 8b04 	vpop	{d8-d9}
 8013190:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013194:	f015 bab8 	b.w	8028708 <cblas_xerbla>
      && (beta_real == 1.0 && beta_imag == 0.0))
 8013198:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801319c:	eeb4 9a67 	vcmp.f32	s18, s15
 80131a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80131a4:	d1bb      	bne.n	801311e <cblas_cgemv+0x92>
 80131a6:	eef5 9a40 	vcmp.f32	s19, #0.0
 80131aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80131ae:	d118      	bne.n	80131e2 <cblas_cgemv+0x156>
 80131b0:	b003      	add	sp, #12
 80131b2:	ecbd 8b04 	vpop	{d8-d9}
 80131b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 80131ba:	2002      	movs	r0, #2
 80131bc:	e78a      	b.n	80130d4 <cblas_cgemv+0x48>
 80131be:	2c00      	cmp	r4, #0
 80131c0:	d055      	beq.n	801326e <cblas_cgemv+0x1e2>
 80131c2:	2800      	cmp	r0, #0
 80131c4:	d09d      	beq.n	8013102 <cblas_cgemv+0x76>
 80131c6:	e798      	b.n	80130fa <cblas_cgemv+0x6e>
 80131c8:	2d01      	cmp	r5, #1
 80131ca:	462b      	mov	r3, r5
 80131cc:	bfb8      	it	lt
 80131ce:	2301      	movlt	r3, #1
 80131d0:	454b      	cmp	r3, r9
 80131d2:	dd8c      	ble.n	80130ee <cblas_cgemv+0x62>
 80131d4:	2e00      	cmp	r6, #0
 80131d6:	d08c      	beq.n	80130f2 <cblas_cgemv+0x66>
 80131d8:	2c00      	cmp	r4, #0
 80131da:	bf14      	ite	ne
 80131dc:	2007      	movne	r0, #7
 80131de:	200c      	moveq	r0, #12
 80131e0:	e78b      	b.n	80130fa <cblas_cgemv+0x6e>
  if (TransA == CblasNoTrans) {
 80131e2:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80131e6:	d002      	beq.n	80131ee <cblas_cgemv+0x162>
 80131e8:	463b      	mov	r3, r7
 80131ea:	462f      	mov	r7, r5
 80131ec:	461d      	mov	r5, r3
    INDEX iy = OFFSET(lenY, incY);
 80131ee:	2c00      	cmp	r4, #0
 80131f0:	dd2a      	ble.n	8013248 <cblas_cgemv+0x1bc>
 80131f2:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 80131f4:	2d00      	cmp	r5, #0
 80131f6:	ddb4      	ble.n	8013162 <cblas_cgemv+0xd6>
 80131f8:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
 80131fc:	3204      	adds	r2, #4
 80131fe:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
 8013202:	00e0      	lsls	r0, r4, #3
 8013204:	2100      	movs	r1, #0
      const BASE y_imag = IMAG(Y, iy);
 8013206:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE y_real = REAL(Y, iy);
 801320a:	ed52 6a01 	vldr	s13, [r2, #-4]
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801320e:	ee27 7ae9 	vnmul.f32	s14, s15, s19
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 8013212:	ee69 7a27 	vmul.f32	s15, s18, s15
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 8013216:	eea9 7a26 	vfma.f32	s14, s18, s13
    for (i = 0; i < lenY; i++) {
 801321a:	3101      	adds	r1, #1
 801321c:	428d      	cmp	r5, r1
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801321e:	eee9 7aa6 	vfma.f32	s15, s19, s13
      REAL(Y, iy) = tmpR;
 8013222:	ed02 7a01 	vstr	s14, [r2, #-4]
      IMAG(Y, iy) = tmpI;
 8013226:	edc3 7a01 	vstr	s15, [r3, #4]
    for (i = 0; i < lenY; i++) {
 801322a:	4402      	add	r2, r0
 801322c:	4403      	add	r3, r0
 801322e:	d1ea      	bne.n	8013206 <cblas_cgemv+0x17a>
 8013230:	e797      	b.n	8013162 <cblas_cgemv+0xd6>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8013232:	2f01      	cmp	r7, #1
 8013234:	463b      	mov	r3, r7
 8013236:	bfb8      	it	lt
 8013238:	2301      	movlt	r3, #1
 801323a:	454b      	cmp	r3, r9
 801323c:	f77f af57 	ble.w	80130ee <cblas_cgemv+0x62>
 8013240:	2e00      	cmp	r6, #0
 8013242:	f43f af56 	beq.w	80130f2 <cblas_cgemv+0x66>
 8013246:	e7c7      	b.n	80131d8 <cblas_cgemv+0x14c>
    INDEX iy = OFFSET(lenY, incY);
 8013248:	f1c5 0301 	rsb	r3, r5, #1
 801324c:	fb03 f304 	mul.w	r3, r3, r4
 8013250:	e7d0      	b.n	80131f4 <cblas_cgemv+0x168>
  } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8013252:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8013256:	eeb4 9a67 	vcmp.f32	s18, s15
 801325a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801325e:	d1c6      	bne.n	80131ee <cblas_cgemv+0x162>
 8013260:	eef5 9a40 	vcmp.f32	s19, #0.0
 8013264:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013268:	f43f af7b 	beq.w	8013162 <cblas_cgemv+0xd6>
 801326c:	e7bf      	b.n	80131ee <cblas_cgemv+0x162>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801326e:	200c      	movs	r0, #12
 8013270:	e743      	b.n	80130fa <cblas_cgemv+0x6e>
  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 8013272:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8013276:	f000 80d1 	beq.w	801341c <cblas_cgemv+0x390>
  } else if ((order == CblasRowMajor && TransA == CblasTrans)
 801327a:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 801327e:	f000 812b 	beq.w	80134d8 <cblas_cgemv+0x44c>
  } else if (order == CblasRowMajor && TransA == CblasConjTrans) {
 8013282:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 8013286:	f47f af7d 	bne.w	8013184 <cblas_cgemv+0xf8>
    INDEX ix = OFFSET(lenX, incX);
 801328a:	2e00      	cmp	r6, #0
 801328c:	f340 8190 	ble.w	80135b0 <cblas_cgemv+0x524>
 8013290:	2100      	movs	r1, #0
    for (j = 0; j < lenX; j++) {
 8013292:	2f00      	cmp	r7, #0
 8013294:	dd8c      	ble.n	80131b0 <cblas_cgemv+0x124>
 8013296:	2c00      	cmp	r4, #0
 8013298:	f1c5 0301 	rsb	r3, r5, #1
 801329c:	fb03 f304 	mul.w	r3, r3, r4
 80132a0:	bfc8      	it	gt
 80132a2:	2300      	movgt	r3, #0
 80132a4:	9801      	ldr	r0, [sp, #4]
 80132a6:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
 80132aa:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 80132ae:	9b00      	ldr	r3, [sp, #0]
      INDEX iy = OFFSET(lenY, incY);
 80132b0:	f04f 0c00 	mov.w	ip, #0
 80132b4:	3204      	adds	r2, #4
 80132b6:	eb00 0bc1 	add.w	fp, r0, r1, lsl #3
 80132ba:	00f6      	lsls	r6, r6, #3
 80132bc:	00e4      	lsls	r4, r4, #3
 80132be:	9201      	str	r2, [sp, #4]
 80132c0:	46e6      	mov	lr, ip
 80132c2:	ea4f 08c9 	mov.w	r8, r9, lsl #3
 80132c6:	eb03 00c5 	add.w	r0, r3, r5, lsl #3
      BASE x_real = CONST_REAL(X, ix);
 80132ca:	eddb 7a00 	vldr	s15, [fp]
      BASE x_imag = CONST_IMAG(X, ix);
 80132ce:	ed9b 7a01 	vldr	s14, [fp, #4]
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 80132d2:	ee28 5aa7 	vmul.f32	s10, s17, s15
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 80132d6:	ee67 5a68 	vnmul.f32	s11, s14, s17
      for (i = 0; i < lenY; i++) {
 80132da:	2d00      	cmp	r5, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 80132dc:	eea8 5a07 	vfma.f32	s10, s16, s14
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 80132e0:	eee8 5a27 	vfma.f32	s11, s16, s15
      for (i = 0; i < lenY; i++) {
 80132e4:	dd21      	ble.n	801332a <cblas_cgemv+0x29e>
 80132e6:	9b00      	ldr	r3, [sp, #0]
 80132e8:	9901      	ldr	r1, [sp, #4]
 80132ea:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 80132ee:	4652      	mov	r2, sl
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 80132f0:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80132f4:	ed93 6a00 	vldr	s12, [r3]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 80132f8:	ed51 6a01 	vldr	s13, [r1, #-4]
 80132fc:	ee25 7a27 	vmul.f32	s14, s10, s15
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 8013300:	ee67 7ae5 	vnmul.f32	s15, s15, s11
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 8013304:	eea5 7a86 	vfma.f32	s14, s11, s12
 8013308:	3308      	adds	r3, #8
      for (i = 0; i < lenY; i++) {
 801330a:	4298      	cmp	r0, r3
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801330c:	eee5 7a06 	vfma.f32	s15, s10, s12
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 8013310:	ee36 7a87 	vadd.f32	s14, s13, s14
 8013314:	ed01 7a01 	vstr	s14, [r1, #-4]
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 8013318:	ed92 7a01 	vldr	s14, [r2, #4]
 801331c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013320:	4421      	add	r1, r4
 8013322:	edc2 7a01 	vstr	s15, [r2, #4]
      for (i = 0; i < lenY; i++) {
 8013326:	4422      	add	r2, r4
 8013328:	d1e2      	bne.n	80132f0 <cblas_cgemv+0x264>
    for (j = 0; j < lenX; j++) {
 801332a:	f10e 0e01 	add.w	lr, lr, #1
 801332e:	4577      	cmp	r7, lr
 8013330:	44b3      	add	fp, r6
 8013332:	44cc      	add	ip, r9
 8013334:	4440      	add	r0, r8
 8013336:	d1c8      	bne.n	80132ca <cblas_cgemv+0x23e>
 8013338:	e73a      	b.n	80131b0 <cblas_cgemv+0x124>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801333a:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 801333e:	d06d      	beq.n	801341c <cblas_cgemv+0x390>
             || (order == CblasColMajor && TransA == CblasNoTrans)) {
 8013340:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8013344:	f000 80c8 	beq.w	80134d8 <cblas_cgemv+0x44c>
  } else if (order == CblasColMajor && TransA == CblasConjTrans) {
 8013348:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 801334c:	f47f af1a 	bne.w	8013184 <cblas_cgemv+0xf8>
    INDEX iy = OFFSET(lenY, incY);
 8013350:	2c00      	cmp	r4, #0
 8013352:	f340 8128 	ble.w	80135a6 <cblas_cgemv+0x51a>
 8013356:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8013358:	2d00      	cmp	r5, #0
 801335a:	f77f af29 	ble.w	80131b0 <cblas_cgemv+0x124>
 801335e:	2e00      	cmp	r6, #0
 8013360:	f1c7 0201 	rsb	r2, r7, #1
 8013364:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 8013368:	9b01      	ldr	r3, [sp, #4]
 801336a:	fb02 f206 	mul.w	r2, r2, r6
 801336e:	bfc8      	it	gt
 8013370:	2200      	movgt	r2, #0
 8013372:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 8013376:	9b00      	ldr	r3, [sp, #0]
      INDEX ix = OFFSET(lenX, incX);
 8013378:	2000      	movs	r0, #0
 801337a:	00e4      	lsls	r4, r4, #3
 801337c:	00f6      	lsls	r6, r6, #3
 801337e:	4684      	mov	ip, r0
 8013380:	ea4f 0ec9 	mov.w	lr, r9, lsl #3
 8013384:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 8013388:	4698      	mov	r8, r3
      for (j = 0; j < lenX; j++) {
 801338a:	ed9f 5a23 	vldr	s10, [pc, #140]	; 8013418 <cblas_cgemv+0x38c>
 801338e:	2f00      	cmp	r7, #0
 8013390:	eef0 4a45 	vmov.f32	s9, s10
 8013394:	dd1a      	ble.n	80133cc <cblas_cgemv+0x340>
 8013396:	eb08 03c0 	add.w	r3, r8, r0, lsl #3
 801339a:	465a      	mov	r2, fp
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801339c:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_real = CONST_REAL(X, ix);
 80133a0:	ed92 6a00 	vldr	s12, [r2]
        const BASE x_imag = CONST_IMAG(X, ix);
 80133a4:	edd2 5a01 	vldr	s11, [r2, #4]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 80133a8:	edd3 6a00 	vldr	s13, [r3]
        dotI += A_real * x_imag + (-A_imag) * x_real;
 80133ac:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        dotR += A_real * x_real - (-A_imag) * x_imag;
 80133b0:	ee65 7aa7 	vmul.f32	s15, s11, s15
        dotI += A_real * x_imag + (-A_imag) * x_real;
 80133b4:	eea5 7aa6 	vfma.f32	s14, s11, s13
 80133b8:	3308      	adds	r3, #8
      for (j = 0; j < lenX; j++) {
 80133ba:	4299      	cmp	r1, r3
        dotR += A_real * x_real - (-A_imag) * x_imag;
 80133bc:	eee6 7a26 	vfma.f32	s15, s12, s13
 80133c0:	4432      	add	r2, r6
        dotI += A_real * x_imag + (-A_imag) * x_real;
 80133c2:	ee35 5a07 	vadd.f32	s10, s10, s14
        dotR += A_real * x_real - (-A_imag) * x_imag;
 80133c6:	ee74 4aa7 	vadd.f32	s9, s9, s15
      for (j = 0; j < lenX; j++) {
 80133ca:	d1e7      	bne.n	801339c <cblas_cgemv+0x310>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80133cc:	ee25 7a68 	vnmul.f32	s14, s10, s17
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80133d0:	ee68 7aa4 	vmul.f32	s15, s17, s9
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80133d4:	eea8 7a24 	vfma.f32	s14, s16, s9
    for (i = 0; i < lenY; i++) {
 80133d8:	f10c 0c01 	add.w	ip, ip, #1
 80133dc:	4565      	cmp	r5, ip
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80133de:	eee8 7a05 	vfma.f32	s15, s16, s10
 80133e2:	4448      	add	r0, r9
 80133e4:	4471      	add	r1, lr
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80133e6:	eeb0 6a47 	vmov.f32	s12, s14
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80133ea:	eef0 6a67 	vmov.f32	s13, s15
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80133ee:	ed9a 7a00 	vldr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80133f2:	edda 7a01 	vldr	s15, [sl, #4]
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80133f6:	ee37 7a06 	vadd.f32	s14, s14, s12
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80133fa:	ee77 7aa6 	vadd.f32	s15, s15, s13
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80133fe:	ed8a 7a00 	vstr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 8013402:	edca 7a01 	vstr	s15, [sl, #4]
    for (i = 0; i < lenY; i++) {
 8013406:	44a2      	add	sl, r4
 8013408:	d1bf      	bne.n	801338a <cblas_cgemv+0x2fe>
 801340a:	e6d1      	b.n	80131b0 <cblas_cgemv+0x124>
 801340c:	08031108 	.word	0x08031108
 8013410:	080312d0 	.word	0x080312d0
 8013414:	080311b8 	.word	0x080311b8
 8013418:	00000000 	.word	0x00000000
    INDEX iy = OFFSET(lenY, incY);
 801341c:	2c00      	cmp	r4, #0
 801341e:	f340 80b3 	ble.w	8013588 <cblas_cgemv+0x4fc>
 8013422:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8013424:	2d00      	cmp	r5, #0
 8013426:	f77f aec3 	ble.w	80131b0 <cblas_cgemv+0x124>
 801342a:	2e00      	cmp	r6, #0
 801342c:	f1c7 0201 	rsb	r2, r7, #1
 8013430:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 8013434:	9b01      	ldr	r3, [sp, #4]
 8013436:	fb02 f206 	mul.w	r2, r2, r6
 801343a:	bfc8      	it	gt
 801343c:	2200      	movgt	r2, #0
 801343e:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 8013442:	9b00      	ldr	r3, [sp, #0]
      INDEX ix = OFFSET(lenX, incX);
 8013444:	2000      	movs	r0, #0
 8013446:	00e4      	lsls	r4, r4, #3
 8013448:	00f6      	lsls	r6, r6, #3
 801344a:	4684      	mov	ip, r0
 801344c:	ea4f 0ec9 	mov.w	lr, r9, lsl #3
 8013450:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 8013454:	4698      	mov	r8, r3
      for (j = 0; j < lenX; j++) {
 8013456:	ed1f 5a10 	vldr	s10, [pc, #-64]	; 8013418 <cblas_cgemv+0x38c>
 801345a:	2f00      	cmp	r7, #0
 801345c:	eef0 4a45 	vmov.f32	s9, s10
 8013460:	dd1a      	ble.n	8013498 <cblas_cgemv+0x40c>
 8013462:	eb08 03c0 	add.w	r3, r8, r0, lsl #3
 8013466:	465a      	mov	r2, fp
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 8013468:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_real = CONST_REAL(X, ix);
 801346c:	ed92 6a00 	vldr	s12, [r2]
        const BASE x_imag = CONST_IMAG(X, ix);
 8013470:	edd2 5a01 	vldr	s11, [r2, #4]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 8013474:	edd3 6a00 	vldr	s13, [r3]
        dotI += A_real * x_imag + A_imag * x_real;
 8013478:	ee26 7a27 	vmul.f32	s14, s12, s15
        dotR += A_real * x_real - A_imag * x_imag;
 801347c:	ee67 7ae5 	vnmul.f32	s15, s15, s11
        dotI += A_real * x_imag + A_imag * x_real;
 8013480:	eea5 7aa6 	vfma.f32	s14, s11, s13
 8013484:	3308      	adds	r3, #8
      for (j = 0; j < lenX; j++) {
 8013486:	428b      	cmp	r3, r1
        dotR += A_real * x_real - A_imag * x_imag;
 8013488:	eee6 7a26 	vfma.f32	s15, s12, s13
 801348c:	4432      	add	r2, r6
        dotI += A_real * x_imag + A_imag * x_real;
 801348e:	ee35 5a07 	vadd.f32	s10, s10, s14
        dotR += A_real * x_real - A_imag * x_imag;
 8013492:	ee74 4aa7 	vadd.f32	s9, s9, s15
      for (j = 0; j < lenX; j++) {
 8013496:	d1e7      	bne.n	8013468 <cblas_cgemv+0x3dc>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 8013498:	ee25 7a68 	vnmul.f32	s14, s10, s17
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801349c:	ee68 7aa4 	vmul.f32	s15, s17, s9
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80134a0:	eea8 7a24 	vfma.f32	s14, s16, s9
    for (i = 0; i < lenY; i++) {
 80134a4:	f10c 0c01 	add.w	ip, ip, #1
 80134a8:	4565      	cmp	r5, ip
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80134aa:	eee8 7a05 	vfma.f32	s15, s16, s10
 80134ae:	4448      	add	r0, r9
 80134b0:	4471      	add	r1, lr
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80134b2:	eeb0 6a47 	vmov.f32	s12, s14
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80134b6:	eef0 6a67 	vmov.f32	s13, s15
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80134ba:	ed9a 7a00 	vldr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80134be:	edda 7a01 	vldr	s15, [sl, #4]
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80134c2:	ee37 7a06 	vadd.f32	s14, s14, s12
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80134c6:	ee77 7aa6 	vadd.f32	s15, s15, s13
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80134ca:	ed8a 7a00 	vstr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80134ce:	edca 7a01 	vstr	s15, [sl, #4]
    for (i = 0; i < lenY; i++) {
 80134d2:	44a2      	add	sl, r4
 80134d4:	d1bf      	bne.n	8013456 <cblas_cgemv+0x3ca>
 80134d6:	e66b      	b.n	80131b0 <cblas_cgemv+0x124>
    INDEX ix = OFFSET(lenX, incX);
 80134d8:	2e00      	cmp	r6, #0
 80134da:	dd5a      	ble.n	8013592 <cblas_cgemv+0x506>
 80134dc:	2100      	movs	r1, #0
    for (j = 0; j < lenX; j++) {
 80134de:	2f00      	cmp	r7, #0
 80134e0:	f77f ae66 	ble.w	80131b0 <cblas_cgemv+0x124>
 80134e4:	2c00      	cmp	r4, #0
 80134e6:	f1c5 0301 	rsb	r3, r5, #1
 80134ea:	fb03 f304 	mul.w	r3, r3, r4
 80134ee:	bfc8      	it	gt
 80134f0:	2300      	movgt	r3, #0
 80134f2:	9801      	ldr	r0, [sp, #4]
 80134f4:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
 80134f8:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 80134fc:	9b00      	ldr	r3, [sp, #0]
      INDEX iy = OFFSET(lenY, incY);
 80134fe:	f04f 0c00 	mov.w	ip, #0
 8013502:	3204      	adds	r2, #4
 8013504:	eb00 0bc1 	add.w	fp, r0, r1, lsl #3
 8013508:	00f6      	lsls	r6, r6, #3
 801350a:	00e4      	lsls	r4, r4, #3
 801350c:	9201      	str	r2, [sp, #4]
 801350e:	46e6      	mov	lr, ip
 8013510:	ea4f 08c9 	mov.w	r8, r9, lsl #3
 8013514:	eb03 00c5 	add.w	r0, r3, r5, lsl #3
      BASE x_real = CONST_REAL(X, ix);
 8013518:	eddb 7a00 	vldr	s15, [fp]
      BASE x_imag = CONST_IMAG(X, ix);
 801351c:	ed9b 7a01 	vldr	s14, [fp, #4]
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 8013520:	ee28 5aa7 	vmul.f32	s10, s17, s15
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 8013524:	ee67 5a68 	vnmul.f32	s11, s14, s17
      for (i = 0; i < lenY; i++) {
 8013528:	2d00      	cmp	r5, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801352a:	eea8 5a07 	vfma.f32	s10, s16, s14
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801352e:	eee8 5a27 	vfma.f32	s11, s16, s15
      for (i = 0; i < lenY; i++) {
 8013532:	dd21      	ble.n	8013578 <cblas_cgemv+0x4ec>
 8013534:	9b00      	ldr	r3, [sp, #0]
 8013536:	9901      	ldr	r1, [sp, #4]
 8013538:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 801353c:	4652      	mov	r2, sl
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 801353e:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8013542:	ed93 6a00 	vldr	s12, [r3]
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 8013546:	ed51 6a01 	vldr	s13, [r1, #-4]
 801354a:	ee27 7ac5 	vnmul.f32	s14, s15, s10
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801354e:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 8013552:	eea5 7a86 	vfma.f32	s14, s11, s12
 8013556:	3308      	adds	r3, #8
      for (i = 0; i < lenY; i++) {
 8013558:	4298      	cmp	r0, r3
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801355a:	eee5 7a06 	vfma.f32	s15, s10, s12
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801355e:	ee36 7a87 	vadd.f32	s14, s13, s14
 8013562:	ed01 7a01 	vstr	s14, [r1, #-4]
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 8013566:	ed92 7a01 	vldr	s14, [r2, #4]
 801356a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801356e:	4421      	add	r1, r4
 8013570:	edc2 7a01 	vstr	s15, [r2, #4]
      for (i = 0; i < lenY; i++) {
 8013574:	4422      	add	r2, r4
 8013576:	d1e2      	bne.n	801353e <cblas_cgemv+0x4b2>
    for (j = 0; j < lenX; j++) {
 8013578:	f10e 0e01 	add.w	lr, lr, #1
 801357c:	4577      	cmp	r7, lr
 801357e:	44b3      	add	fp, r6
 8013580:	44cc      	add	ip, r9
 8013582:	4440      	add	r0, r8
 8013584:	d1c8      	bne.n	8013518 <cblas_cgemv+0x48c>
 8013586:	e613      	b.n	80131b0 <cblas_cgemv+0x124>
    INDEX iy = OFFSET(lenY, incY);
 8013588:	f1c5 0301 	rsb	r3, r5, #1
 801358c:	fb03 f304 	mul.w	r3, r3, r4
 8013590:	e748      	b.n	8013424 <cblas_cgemv+0x398>
    INDEX ix = OFFSET(lenX, incX);
 8013592:	f1c7 0101 	rsb	r1, r7, #1
 8013596:	fb01 f106 	mul.w	r1, r1, r6
 801359a:	e7a0      	b.n	80134de <cblas_cgemv+0x452>
    INDEX iy = OFFSET(lenY, incY);
 801359c:	f1c5 0301 	rsb	r3, r5, #1
 80135a0:	fb03 f304 	mul.w	r3, r3, r4
 80135a4:	e5d0      	b.n	8013148 <cblas_cgemv+0xbc>
    INDEX iy = OFFSET(lenY, incY);
 80135a6:	f1c5 0301 	rsb	r3, r5, #1
 80135aa:	fb03 f304 	mul.w	r3, r3, r4
 80135ae:	e6d3      	b.n	8013358 <cblas_cgemv+0x2cc>
    INDEX ix = OFFSET(lenX, incX);
 80135b0:	f1c7 0101 	rsb	r1, r7, #1
 80135b4:	fb01 f106 	mul.w	r1, r1, r6
 80135b8:	e66b      	b.n	8013292 <cblas_cgemv+0x206>
 80135ba:	bf00      	nop

080135bc <cblas_cgerc>:

void
cblas_cgerc (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 80135bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80135c0:	b083      	sub	sp, #12
 80135c2:	469b      	mov	fp, r3
 */

{
  INDEX i, j;

  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 80135c4:	f1b1 0900 	subs.w	r9, r1, #0
 80135c8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80135ca:	9300      	str	r3, [sp, #0]
 80135cc:	e9dd 460f 	ldrd	r4, r6, [sp, #60]	; 0x3c
 80135d0:	e9dd 530d 	ldrd	r5, r3, [sp, #52]	; 0x34
 80135d4:	9f11      	ldr	r7, [sp, #68]	; 0x44
 80135d6:	4682      	mov	sl, r0
 80135d8:	4690      	mov	r8, r2
 80135da:	f2c0 80bb 	blt.w	8013754 <cblas_cgerc+0x198>
 80135de:	3865      	subs	r0, #101	; 0x65
 80135e0:	2801      	cmp	r0, #1
 80135e2:	bf94      	ite	ls
 80135e4:	2000      	movls	r0, #0
 80135e6:	2001      	movhi	r0, #1
 80135e8:	f1b8 0f00 	cmp.w	r8, #0
 80135ec:	bfb8      	it	lt
 80135ee:	2003      	movlt	r0, #3
 80135f0:	2d00      	cmp	r5, #0
 80135f2:	f040 8092 	bne.w	801371a <cblas_cgerc+0x15e>
 80135f6:	2c00      	cmp	r4, #0
 80135f8:	d16e      	bne.n	80136d8 <cblas_cgerc+0x11c>
 80135fa:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80135fe:	f000 80ab 	beq.w	8013758 <cblas_cgerc+0x19c>
 8013602:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8013606:	f040 810f 	bne.w	8013828 <cblas_cgerc+0x26c>
 801360a:	464a      	mov	r2, r9
 801360c:	2a01      	cmp	r2, #1
 801360e:	bfb8      	it	lt
 8013610:	2201      	movlt	r2, #1
 8013612:	4297      	cmp	r7, r2
 8013614:	db6f      	blt.n	80136f6 <cblas_cgerc+0x13a>
 8013616:	2008      	movs	r0, #8
 8013618:	4a9f      	ldr	r2, [pc, #636]	; (8013898 <cblas_cgerc+0x2dc>)
 801361a:	49a0      	ldr	r1, [pc, #640]	; (801389c <cblas_cgerc+0x2e0>)
 801361c:	9301      	str	r3, [sp, #4]
 801361e:	f015 f873 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8013622:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013626:	ed9b 4a01 	vldr	s8, [fp, #4]

    if (order == CblasRowMajor) {
 801362a:	9b01      	ldr	r3, [sp, #4]
          jy += incY;
        }
        ix += incX;
      }
    } else if (order == CblasColMajor) {
      INDEX jy = OFFSET(N, incY);
 801362c:	2c00      	cmp	r4, #0
 801362e:	dd6f      	ble.n	8013710 <cblas_cgerc+0x154>
 8013630:	f04f 0c00 	mov.w	ip, #0
      for (j = 0; j < N; j++) {
 8013634:	f1b8 0f00 	cmp.w	r8, #0
 8013638:	dd4b      	ble.n	80136d2 <cblas_cgerc+0x116>
 801363a:	2d00      	cmp	r5, #0
 801363c:	f1c9 0a01 	rsb	sl, r9, #1
 8013640:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
 8013644:	9b00      	ldr	r3, [sp, #0]
 8013646:	fb0a fa05 	mul.w	sl, sl, r5
 801364a:	bfc8      	it	gt
 801364c:	f04f 0a00 	movgt.w	sl, #0
 8013650:	00e4      	lsls	r4, r4, #3
 8013652:	00ff      	lsls	r7, r7, #3
 8013654:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8013658:	00ed      	lsls	r5, r5, #3
 801365a:	eb06 00c9 	add.w	r0, r6, r9, lsl #3
        const BASE Y_real = CONST_REAL(Y, jy);
        const BASE Y_imag = -CONST_IMAG(Y, jy);
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
        INDEX ix = OFFSET(M, incX);
 801365e:	f04f 0e00 	mov.w	lr, #0
        const BASE Y_imag = -CONST_IMAG(Y, jy);
 8013662:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE Y_real = CONST_REAL(Y, jy);
 8013666:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801366a:	ee65 4a04 	vmul.f32	s9, s10, s8
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801366e:	ee25 5a63 	vnmul.f32	s10, s10, s7
        for (i = 0; i < M; i++) {
 8013672:	f1b9 0f00 	cmp.w	r9, #0
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 8013676:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801367a:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (i = 0; i < M; i++) {
 801367e:	dd21      	ble.n	80136c4 <cblas_cgerc+0x108>
 8013680:	1d31      	adds	r1, r6, #4
 8013682:	4633      	mov	r3, r6
 8013684:	4652      	mov	r2, sl
          const BASE X_real = CONST_REAL(X, ix);
          const BASE X_imag = CONST_IMAG(X, ix);
 8013686:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE X_real = CONST_REAL(X, ix);
 801368a:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801368e:	ed51 6a01 	vldr	s13, [r1, #-4]
 8013692:	ee27 6a45 	vnmul.f32	s12, s14, s10
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 8013696:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801369a:	eea4 6aa5 	vfma.f32	s12, s9, s11
 801369e:	3308      	adds	r3, #8
 80136a0:	442a      	add	r2, r5
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 80136a2:	eee4 7a87 	vfma.f32	s15, s9, s14
 80136a6:	3108      	adds	r1, #8
 80136a8:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 80136ac:	ee76 7a86 	vadd.f32	s15, s13, s12
 80136b0:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 80136b4:	ed53 7a01 	vldr	s15, [r3, #-4]
 80136b8:	ee77 7a87 	vadd.f32	s15, s15, s14
 80136bc:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (i = 0; i < M; i++) {
 80136c0:	4298      	cmp	r0, r3
 80136c2:	d1e0      	bne.n	8013686 <cblas_cgerc+0xca>
      for (j = 0; j < N; j++) {
 80136c4:	f10e 0e01 	add.w	lr, lr, #1
 80136c8:	45f0      	cmp	r8, lr
 80136ca:	44a4      	add	ip, r4
 80136cc:	443e      	add	r6, r7
 80136ce:	4438      	add	r0, r7
 80136d0:	d1c7      	bne.n	8013662 <cblas_cgerc+0xa6>
#define BASE float
#include "source_gerc.h"
#undef BASE
}
 80136d2:	b003      	add	sp, #12
 80136d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 80136d8:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80136dc:	f000 80b0 	beq.w	8013840 <cblas_cgerc+0x284>
 80136e0:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 80136e4:	f040 80c7 	bne.w	8013876 <cblas_cgerc+0x2ba>
 80136e8:	464a      	mov	r2, r9
 80136ea:	2a01      	cmp	r2, #1
 80136ec:	bfb8      	it	lt
 80136ee:	2201      	movlt	r2, #1
 80136f0:	4297      	cmp	r7, r2
 80136f2:	f280 80c2 	bge.w	801387a <cblas_cgerc+0x2be>
 80136f6:	4a68      	ldr	r2, [pc, #416]	; (8013898 <cblas_cgerc+0x2dc>)
 80136f8:	4968      	ldr	r1, [pc, #416]	; (801389c <cblas_cgerc+0x2e0>)
 80136fa:	9301      	str	r3, [sp, #4]
 80136fc:	200a      	movs	r0, #10
 80136fe:	f015 f803 	bl	8028708 <cblas_xerbla>
      INDEX jy = OFFSET(N, incY);
 8013702:	2c00      	cmp	r4, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 8013704:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013708:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 801370c:	9b01      	ldr	r3, [sp, #4]
      INDEX jy = OFFSET(N, incY);
 801370e:	dc8f      	bgt.n	8013630 <cblas_cgerc+0x74>
 8013710:	f1c8 0c01 	rsb	ip, r8, #1
 8013714:	fb0c fc04 	mul.w	ip, ip, r4
 8013718:	e78c      	b.n	8013634 <cblas_cgerc+0x78>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801371a:	2c00      	cmp	r4, #0
 801371c:	f43f af6d 	beq.w	80135fa <cblas_cgerc+0x3e>
 8013720:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8013724:	f000 8095 	beq.w	8013852 <cblas_cgerc+0x296>
 8013728:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801372c:	f000 80a9 	beq.w	8013882 <cblas_cgerc+0x2c6>
 8013730:	2800      	cmp	r0, #0
 8013732:	d17a      	bne.n	801382a <cblas_cgerc+0x26e>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013734:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013738:	ed9b 4a01 	vldr	s8, [fp, #4]
    } else if (order == CblasColMajor) {
 801373c:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8013740:	f43f af74 	beq.w	801362c <cblas_cgerc+0x70>
          ix += incX;
        }
        jy += incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 8013744:	4a56      	ldr	r2, [pc, #344]	; (80138a0 <cblas_cgerc+0x2e4>)
 8013746:	4955      	ldr	r1, [pc, #340]	; (801389c <cblas_cgerc+0x2e0>)
 8013748:	2000      	movs	r0, #0
 801374a:	b003      	add	sp, #12
 801374c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013750:	f014 bfda 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013754:	2002      	movs	r0, #2
 8013756:	e747      	b.n	80135e8 <cblas_cgerc+0x2c>
 8013758:	4640      	mov	r0, r8
 801375a:	2801      	cmp	r0, #1
 801375c:	bfb8      	it	lt
 801375e:	2001      	movlt	r0, #1
 8013760:	4287      	cmp	r7, r0
 8013762:	bfac      	ite	ge
 8013764:	2008      	movge	r0, #8
 8013766:	200a      	movlt	r0, #10
 8013768:	4a4b      	ldr	r2, [pc, #300]	; (8013898 <cblas_cgerc+0x2dc>)
 801376a:	494c      	ldr	r1, [pc, #304]	; (801389c <cblas_cgerc+0x2e0>)
 801376c:	9301      	str	r3, [sp, #4]
 801376e:	f014 ffcb 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013772:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013776:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 801377a:	9b01      	ldr	r3, [sp, #4]
      INDEX ix = OFFSET(M, incX);
 801377c:	2d00      	cmp	r5, #0
 801377e:	dd75      	ble.n	801386c <cblas_cgerc+0x2b0>
 8013780:	f04f 0c00 	mov.w	ip, #0
      for (i = 0; i < M; i++) {
 8013784:	f1b9 0f00 	cmp.w	r9, #0
 8013788:	dda3      	ble.n	80136d2 <cblas_cgerc+0x116>
 801378a:	2c00      	cmp	r4, #0
 801378c:	9a00      	ldr	r2, [sp, #0]
 801378e:	f1c8 0a01 	rsb	sl, r8, #1
 8013792:	fb0a fa04 	mul.w	sl, sl, r4
 8013796:	bfc8      	it	gt
 8013798:	f04f 0a00 	movgt.w	sl, #0
 801379c:	00ed      	lsls	r5, r5, #3
 801379e:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
 80137a2:	00ff      	lsls	r7, r7, #3
 80137a4:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 80137a8:	00e4      	lsls	r4, r4, #3
 80137aa:	eb06 00c8 	add.w	r0, r6, r8, lsl #3
        INDEX jy = OFFSET(N, incY);
 80137ae:	f04f 0e00 	mov.w	lr, #0
        const BASE X_imag = CONST_IMAG(X, ix);
 80137b2:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE X_real = CONST_REAL(X, ix);
 80137b6:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 80137ba:	ee64 4a45 	vnmul.f32	s9, s8, s10
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 80137be:	ee25 5a23 	vmul.f32	s10, s10, s7
        for (j = 0; j < N; j++) {
 80137c2:	f1b8 0f00 	cmp.w	r8, #0
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 80137c6:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 80137ca:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (j = 0; j < N; j++) {
 80137ce:	dd21      	ble.n	8013814 <cblas_cgerc+0x258>
 80137d0:	1d31      	adds	r1, r6, #4
 80137d2:	4633      	mov	r3, r6
 80137d4:	4652      	mov	r2, sl
          const BASE Y_imag = -CONST_IMAG(Y, jy);
 80137d6:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE Y_real = CONST_REAL(Y, jy);
 80137da:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 80137de:	ed51 6a01 	vldr	s13, [r1, #-4]
 80137e2:	ee27 6a05 	vmul.f32	s12, s14, s10
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 80137e6:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 80137ea:	eea4 6aa5 	vfma.f32	s12, s9, s11
 80137ee:	3308      	adds	r3, #8
 80137f0:	4422      	add	r2, r4
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 80137f2:	eee7 7a64 	vfms.f32	s15, s14, s9
 80137f6:	3108      	adds	r1, #8
 80137f8:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 80137fc:	ee76 7a86 	vadd.f32	s15, s13, s12
 8013800:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8013804:	ed53 7a01 	vldr	s15, [r3, #-4]
 8013808:	ee77 7a87 	vadd.f32	s15, s15, s14
 801380c:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < N; j++) {
 8013810:	4298      	cmp	r0, r3
 8013812:	d1e0      	bne.n	80137d6 <cblas_cgerc+0x21a>
      for (i = 0; i < M; i++) {
 8013814:	f10e 0e01 	add.w	lr, lr, #1
 8013818:	45f1      	cmp	r9, lr
 801381a:	44ac      	add	ip, r5
 801381c:	443e      	add	r6, r7
 801381e:	4438      	add	r0, r7
 8013820:	d1c7      	bne.n	80137b2 <cblas_cgerc+0x1f6>
 8013822:	b003      	add	sp, #12
 8013824:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013828:	2008      	movs	r0, #8
 801382a:	4a1b      	ldr	r2, [pc, #108]	; (8013898 <cblas_cgerc+0x2dc>)
 801382c:	491b      	ldr	r1, [pc, #108]	; (801389c <cblas_cgerc+0x2e0>)
 801382e:	9301      	str	r3, [sp, #4]
 8013830:	f014 ff6a 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013834:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013838:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 801383c:	9b01      	ldr	r3, [sp, #4]
 801383e:	e77d      	b.n	801373c <cblas_cgerc+0x180>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013840:	4640      	mov	r0, r8
 8013842:	2801      	cmp	r0, #1
 8013844:	bfb8      	it	lt
 8013846:	2001      	movlt	r0, #1
 8013848:	42b8      	cmp	r0, r7
 801384a:	bfcc      	ite	gt
 801384c:	200a      	movgt	r0, #10
 801384e:	2006      	movle	r0, #6
 8013850:	e78a      	b.n	8013768 <cblas_cgerc+0x1ac>
 8013852:	4642      	mov	r2, r8
 8013854:	2a01      	cmp	r2, #1
 8013856:	bfb8      	it	lt
 8013858:	2201      	movlt	r2, #1
 801385a:	42ba      	cmp	r2, r7
 801385c:	dc0f      	bgt.n	801387e <cblas_cgerc+0x2c2>
 801385e:	2800      	cmp	r0, #0
 8013860:	d182      	bne.n	8013768 <cblas_cgerc+0x1ac>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013862:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013866:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 801386a:	e787      	b.n	801377c <cblas_cgerc+0x1c0>
      INDEX ix = OFFSET(M, incX);
 801386c:	f1c9 0c01 	rsb	ip, r9, #1
 8013870:	fb0c fc05 	mul.w	ip, ip, r5
 8013874:	e786      	b.n	8013784 <cblas_cgerc+0x1c8>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013876:	2006      	movs	r0, #6
 8013878:	e7d7      	b.n	801382a <cblas_cgerc+0x26e>
 801387a:	2006      	movs	r0, #6
 801387c:	e6cc      	b.n	8013618 <cblas_cgerc+0x5c>
 801387e:	200a      	movs	r0, #10
 8013880:	e772      	b.n	8013768 <cblas_cgerc+0x1ac>
 8013882:	464a      	mov	r2, r9
 8013884:	2a01      	cmp	r2, #1
 8013886:	bfb8      	it	lt
 8013888:	2201      	movlt	r2, #1
 801388a:	42ba      	cmp	r2, r7
 801388c:	f73f af33 	bgt.w	80136f6 <cblas_cgerc+0x13a>
 8013890:	2800      	cmp	r0, #0
 8013892:	f43f af4f 	beq.w	8013734 <cblas_cgerc+0x178>
 8013896:	e6bf      	b.n	8013618 <cblas_cgerc+0x5c>
 8013898:	08031108 	.word	0x08031108
 801389c:	080312e0 	.word	0x080312e0
 80138a0:	080311b8 	.word	0x080311b8

080138a4 <cblas_cgeru>:

void
cblas_cgeru (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 80138a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80138a8:	b083      	sub	sp, #12
 80138aa:	469b      	mov	fp, r3
 */

{
  INDEX i, j;

  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 80138ac:	f1b1 0900 	subs.w	r9, r1, #0
 80138b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80138b2:	9300      	str	r3, [sp, #0]
 80138b4:	e9dd 460f 	ldrd	r4, r6, [sp, #60]	; 0x3c
 80138b8:	e9dd 530d 	ldrd	r5, r3, [sp, #52]	; 0x34
 80138bc:	9f11      	ldr	r7, [sp, #68]	; 0x44
 80138be:	4682      	mov	sl, r0
 80138c0:	4690      	mov	r8, r2
 80138c2:	f2c0 80bb 	blt.w	8013a3c <cblas_cgeru+0x198>
 80138c6:	3865      	subs	r0, #101	; 0x65
 80138c8:	2801      	cmp	r0, #1
 80138ca:	bf94      	ite	ls
 80138cc:	2000      	movls	r0, #0
 80138ce:	2001      	movhi	r0, #1
 80138d0:	f1b8 0f00 	cmp.w	r8, #0
 80138d4:	bfb8      	it	lt
 80138d6:	2003      	movlt	r0, #3
 80138d8:	2d00      	cmp	r5, #0
 80138da:	f040 8092 	bne.w	8013a02 <cblas_cgeru+0x15e>
 80138de:	2c00      	cmp	r4, #0
 80138e0:	d16e      	bne.n	80139c0 <cblas_cgeru+0x11c>
 80138e2:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80138e6:	f000 80ab 	beq.w	8013a40 <cblas_cgeru+0x19c>
 80138ea:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 80138ee:	f040 810f 	bne.w	8013b10 <cblas_cgeru+0x26c>
 80138f2:	464a      	mov	r2, r9
 80138f4:	2a01      	cmp	r2, #1
 80138f6:	bfb8      	it	lt
 80138f8:	2201      	movlt	r2, #1
 80138fa:	4297      	cmp	r7, r2
 80138fc:	db6f      	blt.n	80139de <cblas_cgeru+0x13a>
 80138fe:	2008      	movs	r0, #8
 8013900:	4a9f      	ldr	r2, [pc, #636]	; (8013b80 <cblas_cgeru+0x2dc>)
 8013902:	49a0      	ldr	r1, [pc, #640]	; (8013b84 <cblas_cgeru+0x2e0>)
 8013904:	9301      	str	r3, [sp, #4]
 8013906:	f014 feff 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 801390a:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801390e:	ed9b 4a01 	vldr	s8, [fp, #4]

    if (order == CblasRowMajor) {
 8013912:	9b01      	ldr	r3, [sp, #4]
          jy += incY;
        }
        ix += incX;
      }
    } else if (order == CblasColMajor) {
      INDEX jy = OFFSET(N, incY);
 8013914:	2c00      	cmp	r4, #0
 8013916:	dd6f      	ble.n	80139f8 <cblas_cgeru+0x154>
 8013918:	f04f 0c00 	mov.w	ip, #0
      for (j = 0; j < N; j++) {
 801391c:	f1b8 0f00 	cmp.w	r8, #0
 8013920:	dd4b      	ble.n	80139ba <cblas_cgeru+0x116>
 8013922:	2d00      	cmp	r5, #0
 8013924:	f1c9 0a01 	rsb	sl, r9, #1
 8013928:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
 801392c:	9b00      	ldr	r3, [sp, #0]
 801392e:	fb0a fa05 	mul.w	sl, sl, r5
 8013932:	bfc8      	it	gt
 8013934:	f04f 0a00 	movgt.w	sl, #0
 8013938:	00e4      	lsls	r4, r4, #3
 801393a:	00ff      	lsls	r7, r7, #3
 801393c:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8013940:	00ed      	lsls	r5, r5, #3
 8013942:	eb06 00c9 	add.w	r0, r6, r9, lsl #3
        const BASE Y_real = CONST_REAL(Y, jy);
        const BASE Y_imag = CONST_IMAG(Y, jy);
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
        INDEX ix = OFFSET(M, incX);
 8013946:	f04f 0e00 	mov.w	lr, #0
        const BASE Y_imag = CONST_IMAG(Y, jy);
 801394a:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE Y_real = CONST_REAL(Y, jy);
 801394e:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 8013952:	ee64 4a45 	vnmul.f32	s9, s8, s10
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 8013956:	ee25 5a23 	vmul.f32	s10, s10, s7
        for (i = 0; i < M; i++) {
 801395a:	f1b9 0f00 	cmp.w	r9, #0
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801395e:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 8013962:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (i = 0; i < M; i++) {
 8013966:	dd21      	ble.n	80139ac <cblas_cgeru+0x108>
 8013968:	1d31      	adds	r1, r6, #4
 801396a:	4633      	mov	r3, r6
 801396c:	4652      	mov	r2, sl
          const BASE X_real = CONST_REAL(X, ix);
          const BASE X_imag = CONST_IMAG(X, ix);
 801396e:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE X_real = CONST_REAL(X, ix);
 8013972:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 8013976:	ed51 6a01 	vldr	s13, [r1, #-4]
 801397a:	ee27 6a45 	vnmul.f32	s12, s14, s10
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801397e:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 8013982:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8013986:	3308      	adds	r3, #8
 8013988:	442a      	add	r2, r5
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801398a:	eee4 7a87 	vfma.f32	s15, s9, s14
 801398e:	3108      	adds	r1, #8
 8013990:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 8013994:	ee76 7a86 	vadd.f32	s15, s13, s12
 8013998:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801399c:	ed53 7a01 	vldr	s15, [r3, #-4]
 80139a0:	ee77 7a87 	vadd.f32	s15, s15, s14
 80139a4:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (i = 0; i < M; i++) {
 80139a8:	4298      	cmp	r0, r3
 80139aa:	d1e0      	bne.n	801396e <cblas_cgeru+0xca>
      for (j = 0; j < N; j++) {
 80139ac:	f10e 0e01 	add.w	lr, lr, #1
 80139b0:	45f0      	cmp	r8, lr
 80139b2:	44a4      	add	ip, r4
 80139b4:	443e      	add	r6, r7
 80139b6:	4438      	add	r0, r7
 80139b8:	d1c7      	bne.n	801394a <cblas_cgeru+0xa6>
#define BASE float
#include "source_geru.h"
#undef BASE
}
 80139ba:	b003      	add	sp, #12
 80139bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 80139c0:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80139c4:	f000 80b0 	beq.w	8013b28 <cblas_cgeru+0x284>
 80139c8:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 80139cc:	f040 80c7 	bne.w	8013b5e <cblas_cgeru+0x2ba>
 80139d0:	464a      	mov	r2, r9
 80139d2:	2a01      	cmp	r2, #1
 80139d4:	bfb8      	it	lt
 80139d6:	2201      	movlt	r2, #1
 80139d8:	4297      	cmp	r7, r2
 80139da:	f280 80c2 	bge.w	8013b62 <cblas_cgeru+0x2be>
 80139de:	4a68      	ldr	r2, [pc, #416]	; (8013b80 <cblas_cgeru+0x2dc>)
 80139e0:	4968      	ldr	r1, [pc, #416]	; (8013b84 <cblas_cgeru+0x2e0>)
 80139e2:	9301      	str	r3, [sp, #4]
 80139e4:	200a      	movs	r0, #10
 80139e6:	f014 fe8f 	bl	8028708 <cblas_xerbla>
      INDEX jy = OFFSET(N, incY);
 80139ea:	2c00      	cmp	r4, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 80139ec:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80139f0:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 80139f4:	9b01      	ldr	r3, [sp, #4]
      INDEX jy = OFFSET(N, incY);
 80139f6:	dc8f      	bgt.n	8013918 <cblas_cgeru+0x74>
 80139f8:	f1c8 0c01 	rsb	ip, r8, #1
 80139fc:	fb0c fc04 	mul.w	ip, ip, r4
 8013a00:	e78c      	b.n	801391c <cblas_cgeru+0x78>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013a02:	2c00      	cmp	r4, #0
 8013a04:	f43f af6d 	beq.w	80138e2 <cblas_cgeru+0x3e>
 8013a08:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8013a0c:	f000 8095 	beq.w	8013b3a <cblas_cgeru+0x296>
 8013a10:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8013a14:	f000 80a9 	beq.w	8013b6a <cblas_cgeru+0x2c6>
 8013a18:	2800      	cmp	r0, #0
 8013a1a:	d17a      	bne.n	8013b12 <cblas_cgeru+0x26e>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013a1c:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013a20:	ed9b 4a01 	vldr	s8, [fp, #4]
    } else if (order == CblasColMajor) {
 8013a24:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8013a28:	f43f af74 	beq.w	8013914 <cblas_cgeru+0x70>
          ix += incX;
        }
        jy += incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 8013a2c:	4a56      	ldr	r2, [pc, #344]	; (8013b88 <cblas_cgeru+0x2e4>)
 8013a2e:	4955      	ldr	r1, [pc, #340]	; (8013b84 <cblas_cgeru+0x2e0>)
 8013a30:	2000      	movs	r0, #0
 8013a32:	b003      	add	sp, #12
 8013a34:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013a38:	f014 be66 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013a3c:	2002      	movs	r0, #2
 8013a3e:	e747      	b.n	80138d0 <cblas_cgeru+0x2c>
 8013a40:	4640      	mov	r0, r8
 8013a42:	2801      	cmp	r0, #1
 8013a44:	bfb8      	it	lt
 8013a46:	2001      	movlt	r0, #1
 8013a48:	4287      	cmp	r7, r0
 8013a4a:	bfac      	ite	ge
 8013a4c:	2008      	movge	r0, #8
 8013a4e:	200a      	movlt	r0, #10
 8013a50:	4a4b      	ldr	r2, [pc, #300]	; (8013b80 <cblas_cgeru+0x2dc>)
 8013a52:	494c      	ldr	r1, [pc, #304]	; (8013b84 <cblas_cgeru+0x2e0>)
 8013a54:	9301      	str	r3, [sp, #4]
 8013a56:	f014 fe57 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013a5a:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013a5e:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8013a62:	9b01      	ldr	r3, [sp, #4]
      INDEX ix = OFFSET(M, incX);
 8013a64:	2d00      	cmp	r5, #0
 8013a66:	dd75      	ble.n	8013b54 <cblas_cgeru+0x2b0>
 8013a68:	f04f 0c00 	mov.w	ip, #0
      for (i = 0; i < M; i++) {
 8013a6c:	f1b9 0f00 	cmp.w	r9, #0
 8013a70:	dda3      	ble.n	80139ba <cblas_cgeru+0x116>
 8013a72:	2c00      	cmp	r4, #0
 8013a74:	9a00      	ldr	r2, [sp, #0]
 8013a76:	f1c8 0a01 	rsb	sl, r8, #1
 8013a7a:	fb0a fa04 	mul.w	sl, sl, r4
 8013a7e:	bfc8      	it	gt
 8013a80:	f04f 0a00 	movgt.w	sl, #0
 8013a84:	00ed      	lsls	r5, r5, #3
 8013a86:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
 8013a8a:	00ff      	lsls	r7, r7, #3
 8013a8c:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8013a90:	00e4      	lsls	r4, r4, #3
 8013a92:	eb06 00c8 	add.w	r0, r6, r8, lsl #3
        INDEX jy = OFFSET(N, incY);
 8013a96:	f04f 0e00 	mov.w	lr, #0
        const BASE X_imag = CONST_IMAG(X, ix);
 8013a9a:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE X_real = CONST_REAL(X, ix);
 8013a9e:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 8013aa2:	ee64 4a45 	vnmul.f32	s9, s8, s10
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 8013aa6:	ee25 5a23 	vmul.f32	s10, s10, s7
        for (j = 0; j < N; j++) {
 8013aaa:	f1b8 0f00 	cmp.w	r8, #0
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 8013aae:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 8013ab2:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (j = 0; j < N; j++) {
 8013ab6:	dd21      	ble.n	8013afc <cblas_cgeru+0x258>
 8013ab8:	1d31      	adds	r1, r6, #4
 8013aba:	4633      	mov	r3, r6
 8013abc:	4652      	mov	r2, sl
          const BASE Y_imag = CONST_IMAG(Y, jy);
 8013abe:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE Y_real = CONST_REAL(Y, jy);
 8013ac2:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8013ac6:	ed51 6a01 	vldr	s13, [r1, #-4]
 8013aca:	ee27 6a45 	vnmul.f32	s12, s14, s10
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8013ace:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8013ad2:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8013ad6:	3308      	adds	r3, #8
 8013ad8:	4422      	add	r2, r4
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8013ada:	eee4 7a87 	vfma.f32	s15, s9, s14
 8013ade:	3108      	adds	r1, #8
 8013ae0:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8013ae4:	ee76 7a86 	vadd.f32	s15, s13, s12
 8013ae8:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8013aec:	ed53 7a01 	vldr	s15, [r3, #-4]
 8013af0:	ee77 7a87 	vadd.f32	s15, s15, s14
 8013af4:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < N; j++) {
 8013af8:	4298      	cmp	r0, r3
 8013afa:	d1e0      	bne.n	8013abe <cblas_cgeru+0x21a>
      for (i = 0; i < M; i++) {
 8013afc:	f10e 0e01 	add.w	lr, lr, #1
 8013b00:	45f1      	cmp	r9, lr
 8013b02:	44ac      	add	ip, r5
 8013b04:	443e      	add	r6, r7
 8013b06:	4438      	add	r0, r7
 8013b08:	d1c7      	bne.n	8013a9a <cblas_cgeru+0x1f6>
 8013b0a:	b003      	add	sp, #12
 8013b0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013b10:	2008      	movs	r0, #8
 8013b12:	4a1b      	ldr	r2, [pc, #108]	; (8013b80 <cblas_cgeru+0x2dc>)
 8013b14:	491b      	ldr	r1, [pc, #108]	; (8013b84 <cblas_cgeru+0x2e0>)
 8013b16:	9301      	str	r3, [sp, #4]
 8013b18:	f014 fdf6 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013b1c:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013b20:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8013b24:	9b01      	ldr	r3, [sp, #4]
 8013b26:	e77d      	b.n	8013a24 <cblas_cgeru+0x180>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013b28:	4640      	mov	r0, r8
 8013b2a:	2801      	cmp	r0, #1
 8013b2c:	bfb8      	it	lt
 8013b2e:	2001      	movlt	r0, #1
 8013b30:	42b8      	cmp	r0, r7
 8013b32:	bfcc      	ite	gt
 8013b34:	200a      	movgt	r0, #10
 8013b36:	2006      	movle	r0, #6
 8013b38:	e78a      	b.n	8013a50 <cblas_cgeru+0x1ac>
 8013b3a:	4642      	mov	r2, r8
 8013b3c:	2a01      	cmp	r2, #1
 8013b3e:	bfb8      	it	lt
 8013b40:	2201      	movlt	r2, #1
 8013b42:	42ba      	cmp	r2, r7
 8013b44:	dc0f      	bgt.n	8013b66 <cblas_cgeru+0x2c2>
 8013b46:	2800      	cmp	r0, #0
 8013b48:	d182      	bne.n	8013a50 <cblas_cgeru+0x1ac>
    const BASE alpha_real = CONST_REAL0(alpha);
 8013b4a:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013b4e:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8013b52:	e787      	b.n	8013a64 <cblas_cgeru+0x1c0>
      INDEX ix = OFFSET(M, incX);
 8013b54:	f1c9 0c01 	rsb	ip, r9, #1
 8013b58:	fb0c fc05 	mul.w	ip, ip, r5
 8013b5c:	e786      	b.n	8013a6c <cblas_cgeru+0x1c8>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8013b5e:	2006      	movs	r0, #6
 8013b60:	e7d7      	b.n	8013b12 <cblas_cgeru+0x26e>
 8013b62:	2006      	movs	r0, #6
 8013b64:	e6cc      	b.n	8013900 <cblas_cgeru+0x5c>
 8013b66:	200a      	movs	r0, #10
 8013b68:	e772      	b.n	8013a50 <cblas_cgeru+0x1ac>
 8013b6a:	464a      	mov	r2, r9
 8013b6c:	2a01      	cmp	r2, #1
 8013b6e:	bfb8      	it	lt
 8013b70:	2201      	movlt	r2, #1
 8013b72:	42ba      	cmp	r2, r7
 8013b74:	f73f af33 	bgt.w	80139de <cblas_cgeru+0x13a>
 8013b78:	2800      	cmp	r0, #0
 8013b7a:	f43f af4f 	beq.w	8013a1c <cblas_cgeru+0x178>
 8013b7e:	e6bf      	b.n	8013900 <cblas_cgeru+0x5c>
 8013b80:	08031108 	.word	0x08031108
 8013b84:	080312f0 	.word	0x080312f0
 8013b88:	080311b8 	.word	0x080311b8

08013b8c <cblas_chemm>:
void
cblas_chemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 8013b8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013b90:	b08d      	sub	sp, #52	; 0x34
 8013b92:	4698      	mov	r8, r3
 8013b94:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8013b96:	9300      	str	r3, [sp, #0]
 8013b98:	e9dd 7317 	ldrd	r7, r3, [sp, #92]	; 0x5c
 8013b9c:	9302      	str	r3, [sp, #8]
 8013b9e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8013ba0:	9301      	str	r3, [sp, #4]
 8013ba2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8013ba4:	9303      	str	r3, [sp, #12]
 8013ba6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8013ba8:	9305      	str	r3, [sp, #20]
{
  INDEX i, j, k;
  INDEX n1, n2;
  int uplo, side;

  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8013baa:	298d      	cmp	r1, #141	; 0x8d
 8013bac:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8013bae:	9304      	str	r3, [sp, #16]
 8013bb0:	e9dd 9b1c 	ldrd	r9, fp, [sp, #112]	; 0x70
 8013bb4:	460c      	mov	r4, r1
 8013bb6:	4606      	mov	r6, r0
 8013bb8:	4615      	mov	r5, r2
 8013bba:	f000 80da 	beq.w	8013d72 <cblas_chemm+0x1e6>
 8013bbe:	298e      	cmp	r1, #142	; 0x8e
 8013bc0:	f000 8419 	beq.w	80143f6 <cblas_chemm+0x86a>
 8013bc4:	9b00      	ldr	r3, [sp, #0]
 8013bc6:	2002      	movs	r0, #2
 8013bc8:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 8013bcc:	2a01      	cmp	r2, #1
 8013bce:	bf88      	it	hi
 8013bd0:	2003      	movhi	r0, #3
 8013bd2:	9a00      	ldr	r2, [sp, #0]
 8013bd4:	f1b8 0f00 	cmp.w	r8, #0
 8013bd8:	bfb8      	it	lt
 8013bda:	2004      	movlt	r0, #4
 8013bdc:	2b01      	cmp	r3, #1
 8013bde:	bfb8      	it	lt
 8013be0:	2301      	movlt	r3, #1
 8013be2:	2a00      	cmp	r2, #0
 8013be4:	9a01      	ldr	r2, [sp, #4]
 8013be6:	f2c0 80b9 	blt.w	8013d5c <cblas_chemm+0x1d0>
 8013bea:	4293      	cmp	r3, r2
 8013bec:	dd6a      	ble.n	8013cc4 <cblas_chemm+0x138>
 8013bee:	2e65      	cmp	r6, #101	; 0x65
 8013bf0:	f000 8232 	beq.w	8014058 <cblas_chemm+0x4cc>
 8013bf4:	2e66      	cmp	r6, #102	; 0x66
 8013bf6:	f000 83f1 	beq.w	80143dc <cblas_chemm+0x850>
 8013bfa:	2008      	movs	r0, #8
 8013bfc:	4abd      	ldr	r2, [pc, #756]	; (8013ef4 <cblas_chemm+0x368>)
 8013bfe:	49be      	ldr	r1, [pc, #760]	; (8013ef8 <cblas_chemm+0x36c>)
 8013c00:	f014 fd82 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8013c04:	edd7 4a00 	vldr	s9, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8013c08:	ed97 4a01 	vldr	s8, [r7, #4]

    const BASE beta_real = CONST_REAL0(beta);
 8013c0c:	edd9 5a00 	vldr	s11, [r9]
    const BASE beta_imag = CONST_IMAG0(beta);
 8013c10:	ed99 5a01 	vldr	s10, [r9, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8013c14:	eef5 4a40 	vcmp.f32	s9, #0.0
 8013c18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013c1c:	d10b      	bne.n	8013c36 <cblas_chemm+0xaa>
 8013c1e:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8013c22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013c26:	d106      	bne.n	8013c36 <cblas_chemm+0xaa>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8013c28:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8013c2c:	eef4 5a67 	vcmp.f32	s11, s15
 8013c30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013c34:	d04f      	beq.n	8013cd6 <cblas_chemm+0x14a>
      return;

    if (Order == CblasRowMajor) {
 8013c36:	2e65      	cmp	r6, #101	; 0x65
 8013c38:	f000 80a2 	beq.w	8013d80 <cblas_chemm+0x1f4>
      uplo = Uplo;
      side = Side;
    } else {
      n1 = N;
      n2 = M;
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8013c3c:	2d79      	cmp	r5, #121	; 0x79
 8013c3e:	bf0c      	ite	eq
 8013c40:	257a      	moveq	r5, #122	; 0x7a
 8013c42:	2579      	movne	r5, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8013c44:	2c8d      	cmp	r4, #141	; 0x8d
 8013c46:	bf0c      	ite	eq
 8013c48:	248e      	moveq	r4, #142	; 0x8e
 8013c4a:	248d      	movne	r4, #141	; 0x8d
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8013c4c:	eef5 5a40 	vcmp.f32	s11, #0.0
 8013c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013c54:	d147      	bne.n	8013ce6 <cblas_chemm+0x15a>
 8013c56:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8013c5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013c5e:	d14e      	bne.n	8013cfe <cblas_chemm+0x172>
      for (i = 0; i < n1; i++) {
 8013c60:	9b00      	ldr	r3, [sp, #0]
 8013c62:	2b00      	cmp	r3, #0
 8013c64:	dd17      	ble.n	8013c96 <cblas_chemm+0x10a>
 8013c66:	9a04      	ldr	r2, [sp, #16]
 8013c68:	ebc8 7048 	rsb	r0, r8, r8, lsl #29
 8013c6c:	00d6      	lsls	r6, r2, #3
 8013c6e:	00c0      	lsls	r0, r0, #3
 8013c70:	eb0b 02c8 	add.w	r2, fp, r8, lsl #3
 8013c74:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8013c76:	2700      	movs	r7, #0
 8013c78:	469c      	mov	ip, r3
        for (j = 0; j < n2; j++) {
 8013c7a:	f1b8 0f00 	cmp.w	r8, #0
 8013c7e:	bfc8      	it	gt
 8013c80:	1883      	addgt	r3, r0, r2
 8013c82:	dd04      	ble.n	8013c8e <cblas_chemm+0x102>
          REAL(C, ldc * i + j) = 0.0;
 8013c84:	601f      	str	r7, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8013c86:	605f      	str	r7, [r3, #4]
        for (j = 0; j < n2; j++) {
 8013c88:	3308      	adds	r3, #8
 8013c8a:	429a      	cmp	r2, r3
 8013c8c:	d1fa      	bne.n	8013c84 <cblas_chemm+0xf8>
      for (i = 0; i < n1; i++) {
 8013c8e:	3101      	adds	r1, #1
 8013c90:	458c      	cmp	ip, r1
 8013c92:	4432      	add	r2, r6
 8013c94:	d1f1      	bne.n	8013c7a <cblas_chemm+0xee>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8013c96:	eef5 4a40 	vcmp.f32	s9, #0.0
 8013c9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013c9e:	d104      	bne.n	8013caa <cblas_chemm+0x11e>
 8013ca0:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8013ca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013ca8:	d01a      	beq.n	8013ce0 <cblas_chemm+0x154>
      return;

    if (side == CblasLeft && uplo == CblasUpper) {
 8013caa:	2c8d      	cmp	r4, #141	; 0x8d
 8013cac:	d06d      	beq.n	8013d8a <cblas_chemm+0x1fe>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper) {
 8013cae:	2c8e      	cmp	r4, #142	; 0x8e
 8013cb0:	f000 8128 	beq.w	8013f04 <cblas_chemm+0x378>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 8013cb4:	4a91      	ldr	r2, [pc, #580]	; (8013efc <cblas_chemm+0x370>)
 8013cb6:	4990      	ldr	r1, [pc, #576]	; (8013ef8 <cblas_chemm+0x36c>)
 8013cb8:	2000      	movs	r0, #0
#define BASE float
#include "source_hemm.h"
#undef BASE
}
 8013cba:	b00d      	add	sp, #52	; 0x34
 8013cbc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013cc0:	f014 bd22 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8013cc4:	2e65      	cmp	r6, #101	; 0x65
 8013cc6:	f000 81d5 	beq.w	8014074 <cblas_chemm+0x4e8>
 8013cca:	2e66      	cmp	r6, #102	; 0x66
 8013ccc:	f000 8355 	beq.w	801437a <cblas_chemm+0x7ee>
 8013cd0:	2800      	cmp	r0, #0
 8013cd2:	d097      	beq.n	8013c04 <cblas_chemm+0x78>
 8013cd4:	e792      	b.n	8013bfc <cblas_chemm+0x70>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8013cd6:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8013cda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013cde:	d1aa      	bne.n	8013c36 <cblas_chemm+0xaa>
 8013ce0:	b00d      	add	sp, #52	; 0x34
 8013ce2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8013ce6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8013cea:	eef4 5a67 	vcmp.f32	s11, s15
 8013cee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013cf2:	d104      	bne.n	8013cfe <cblas_chemm+0x172>
 8013cf4:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8013cf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013cfc:	d0cb      	beq.n	8013c96 <cblas_chemm+0x10a>
      for (i = 0; i < n1; i++) {
 8013cfe:	9900      	ldr	r1, [sp, #0]
 8013d00:	2900      	cmp	r1, #0
 8013d02:	ddc8      	ble.n	8013c96 <cblas_chemm+0x10a>
 8013d04:	9b04      	ldr	r3, [sp, #16]
 8013d06:	ebc8 7c48 	rsb	ip, r8, r8, lsl #29
 8013d0a:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8013d0e:	f10c 0904 	add.w	r9, ip, #4
 8013d12:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
 8013d16:	eb0b 06c8 	add.w	r6, fp, r8, lsl #3
 8013d1a:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 8013d1c:	f1b8 0f00 	cmp.w	r8, #0
 8013d20:	dd17      	ble.n	8013d52 <cblas_chemm+0x1c6>
 8013d22:	eb0c 0306 	add.w	r3, ip, r6
 8013d26:	eb09 0206 	add.w	r2, r9, r6
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 8013d2a:	edd3 6a01 	vldr	s13, [r3, #4]
          const BASE Cij_real = REAL(C, ldc * i + j);
 8013d2e:	ed12 6a01 	vldr	s12, [r2, #-4]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8013d32:	ee26 7ac5 	vnmul.f32	s14, s13, s10
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8013d36:	ee65 7a06 	vmul.f32	s15, s10, s12
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8013d3a:	eea5 7a86 	vfma.f32	s14, s11, s12
 8013d3e:	3308      	adds	r3, #8
 8013d40:	3208      	adds	r2, #8
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8013d42:	eee5 7aa6 	vfma.f32	s15, s11, s13
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8013d46:	ed02 7a03 	vstr	s14, [r2, #-12]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8013d4a:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < n2; j++) {
 8013d4e:	42b3      	cmp	r3, r6
 8013d50:	d1eb      	bne.n	8013d2a <cblas_chemm+0x19e>
      for (i = 0; i < n1; i++) {
 8013d52:	3701      	adds	r7, #1
 8013d54:	42b9      	cmp	r1, r7
 8013d56:	4476      	add	r6, lr
 8013d58:	d1e0      	bne.n	8013d1c <cblas_chemm+0x190>
 8013d5a:	e79c      	b.n	8013c96 <cblas_chemm+0x10a>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8013d5c:	429a      	cmp	r2, r3
 8013d5e:	f6ff af46 	blt.w	8013bee <cblas_chemm+0x62>
 8013d62:	2e65      	cmp	r6, #101	; 0x65
 8013d64:	f000 82ff 	beq.w	8014366 <cblas_chemm+0x7da>
 8013d68:	2e66      	cmp	r6, #102	; 0x66
 8013d6a:	f000 8353 	beq.w	8014414 <cblas_chemm+0x888>
 8013d6e:	2005      	movs	r0, #5
 8013d70:	e744      	b.n	8013bfc <cblas_chemm+0x70>
 8013d72:	3865      	subs	r0, #101	; 0x65
 8013d74:	2801      	cmp	r0, #1
 8013d76:	bf94      	ite	ls
 8013d78:	2000      	movls	r0, #0
 8013d7a:	2001      	movhi	r0, #1
 8013d7c:	4643      	mov	r3, r8
 8013d7e:	e723      	b.n	8013bc8 <cblas_chemm+0x3c>
      uplo = Uplo;
 8013d80:	9b00      	ldr	r3, [sp, #0]
      side = Side;
 8013d82:	f8cd 8000 	str.w	r8, [sp]
 8013d86:	4698      	mov	r8, r3
 8013d88:	e760      	b.n	8013c4c <cblas_chemm+0xc0>
    if (side == CblasLeft && uplo == CblasUpper) {
 8013d8a:	2d79      	cmp	r5, #121	; 0x79
 8013d8c:	f000 8180 	beq.w	8014090 <cblas_chemm+0x504>
    } else if (side == CblasLeft && uplo == CblasLower) {
 8013d90:	2d7a      	cmp	r5, #122	; 0x7a
 8013d92:	d18f      	bne.n	8013cb4 <cblas_chemm+0x128>
      for (i = 0; i < n1; i++) {
 8013d94:	9b00      	ldr	r3, [sp, #0]
 8013d96:	2b00      	cmp	r3, #0
 8013d98:	dda2      	ble.n	8013ce0 <cblas_chemm+0x154>
 8013d9a:	9b01      	ldr	r3, [sp, #4]
 8013d9c:	9d02      	ldr	r5, [sp, #8]
 8013d9e:	9501      	str	r5, [sp, #4]
 8013da0:	3301      	adds	r3, #1
 8013da2:	00da      	lsls	r2, r3, #3
 8013da4:	2300      	movs	r3, #0
 8013da6:	9302      	str	r3, [sp, #8]
 8013da8:	9306      	str	r3, [sp, #24]
 8013daa:	469a      	mov	sl, r3
 8013dac:	9b04      	ldr	r3, [sp, #16]
 8013dae:	9208      	str	r2, [sp, #32]
 8013db0:	00dc      	lsls	r4, r3, #3
 8013db2:	9b05      	ldr	r3, [sp, #20]
 8013db4:	00de      	lsls	r6, r3, #3
 8013db6:	9b03      	ldr	r3, [sp, #12]
 8013db8:	3304      	adds	r3, #4
 8013dba:	3a08      	subs	r2, #8
 8013dbc:	9309      	str	r3, [sp, #36]	; 0x24
 8013dbe:	f10b 0304 	add.w	r3, fp, #4
 8013dc2:	9207      	str	r2, [sp, #28]
 8013dc4:	930a      	str	r3, [sp, #40]	; 0x28
        for (j = 0; j < n2; j++) {
 8013dc6:	f1b8 0f00 	cmp.w	r8, #0
 8013dca:	dd7d      	ble.n	8013ec8 <cblas_chemm+0x33c>
 8013dcc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8013dce:	9a02      	ldr	r2, [sp, #8]
 8013dd0:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 8013dd4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013dd6:	9a06      	ldr	r2, [sp, #24]
 8013dd8:	f04f 0904 	mov.w	r9, #4
 8013ddc:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 8013de0:	f04f 0e00 	mov.w	lr, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8013de4:	ed5c 7a01 	vldr	s15, [ip, #-4]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8013de8:	ed9c 7a00 	vldr	s14, [ip]
          BASE temp2_imag = 0.0;
 8013dec:	eddf 2a44 	vldr	s5, [pc, #272]	; 8013f00 <cblas_chemm+0x374>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013df0:	ee24 3a27 	vmul.f32	s6, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013df4:	ee27 2a44 	vnmul.f32	s4, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013df8:	eea4 3a87 	vfma.f32	s6, s9, s14
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013dfc:	eea4 2aa7 	vfma.f32	s4, s9, s15
          BASE temp2_real = 0.0;
 8013e00:	eef0 1a62 	vmov.f32	s3, s5
          for (k = 0; k < i; k++) {
 8013e04:	f1ba 0f00 	cmp.w	sl, #0
 8013e08:	d035      	beq.n	8013e76 <cblas_chemm+0x2ea>
 8013e0a:	9b03      	ldr	r3, [sp, #12]
 8013e0c:	eb03 0109 	add.w	r1, r3, r9
 8013e10:	9b01      	ldr	r3, [sp, #4]
 8013e12:	eb0b 00ce 	add.w	r0, fp, lr, lsl #3
 8013e16:	eb0b 0209 	add.w	r2, fp, r9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8013e1a:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8013e1e:	ed93 7a00 	vldr	s14, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013e22:	ed12 6a01 	vldr	s12, [r2, #-4]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8013e26:	ed51 3a01 	vldr	s7, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8013e2a:	ed91 5a00 	vldr	s10, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013e2e:	ee63 6a27 	vmul.f32	s13, s6, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013e32:	ee67 5ac2 	vnmul.f32	s11, s15, s4
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013e36:	eee2 6a07 	vfma.f32	s13, s4, s14
 8013e3a:	3308      	adds	r3, #8
          for (k = 0; k < i; k++) {
 8013e3c:	429d      	cmp	r5, r3
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013e3e:	eee3 5a07 	vfma.f32	s11, s6, s14
 8013e42:	4431      	add	r1, r6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013e44:	ee76 6a26 	vadd.f32	s13, s12, s13
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8013e48:	ee25 6a67 	vnmul.f32	s12, s10, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8013e4c:	ee67 7aa3 	vmul.f32	s15, s15, s7
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013e50:	ed42 6a01 	vstr	s13, [r2, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013e54:	edd0 6a01 	vldr	s13, [r0, #4]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8013e58:	eea7 6a23 	vfma.f32	s12, s14, s7
 8013e5c:	4422      	add	r2, r4
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8013e5e:	eee7 7a05 	vfma.f32	s15, s14, s10
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013e62:	ee36 7aa5 	vadd.f32	s14, s13, s11
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8013e66:	ee71 1a86 	vadd.f32	s3, s3, s12
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013e6a:	ed80 7a01 	vstr	s14, [r0, #4]
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8013e6e:	ee72 2aa7 	vadd.f32	s5, s5, s15
          for (k = 0; k < i; k++) {
 8013e72:	4420      	add	r0, r4
 8013e74:	d1d1      	bne.n	8013e1a <cblas_chemm+0x28e>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8013e76:	ed95 5a00 	vldr	s10, [r5]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8013e7a:	ed17 7a01 	vldr	s14, [r7, #-4]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 8013e7e:	edd7 7a00 	vldr	s15, [r7]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8013e82:	eea2 7a05 	vfma.f32	s14, s4, s10
        for (j = 0; j < n2; j++) {
 8013e86:	f10e 0e01 	add.w	lr, lr, #1
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013e8a:	463b      	mov	r3, r7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013e8c:	ee62 5ac4 	vnmul.f32	s11, s5, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013e90:	ee24 6a21 	vmul.f32	s12, s8, s3
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8013e94:	eef0 6a47 	vmov.f32	s13, s14
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013e98:	eeb0 7a65 	vmov.f32	s14, s11
 8013e9c:	eea4 7aa1 	vfma.f32	s14, s9, s3
        for (j = 0; j < n2; j++) {
 8013ea0:	45f0      	cmp	r8, lr
 8013ea2:	f10c 0c08 	add.w	ip, ip, #8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013ea6:	eea4 6aa2 	vfma.f32	s12, s9, s5
 8013eaa:	f109 0908 	add.w	r9, r9, #8
 8013eae:	f107 0708 	add.w	r7, r7, #8
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 8013eb2:	eee3 7a05 	vfma.f32	s15, s6, s10
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013eb6:	ee36 7a87 	vadd.f32	s14, s13, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013eba:	ee77 7a86 	vadd.f32	s15, s15, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013ebe:	ed07 7a03 	vstr	s14, [r7, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013ec2:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < n2; j++) {
 8013ec6:	d18d      	bne.n	8013de4 <cblas_chemm+0x258>
      for (i = 0; i < n1; i++) {
 8013ec8:	9b08      	ldr	r3, [sp, #32]
 8013eca:	9a04      	ldr	r2, [sp, #16]
 8013ecc:	441d      	add	r5, r3
 8013ece:	9b06      	ldr	r3, [sp, #24]
 8013ed0:	4413      	add	r3, r2
 8013ed2:	9306      	str	r3, [sp, #24]
 8013ed4:	9a05      	ldr	r2, [sp, #20]
 8013ed6:	9b02      	ldr	r3, [sp, #8]
 8013ed8:	4413      	add	r3, r2
 8013eda:	9302      	str	r3, [sp, #8]
 8013edc:	9a07      	ldr	r2, [sp, #28]
 8013ede:	9b01      	ldr	r3, [sp, #4]
 8013ee0:	4413      	add	r3, r2
 8013ee2:	9301      	str	r3, [sp, #4]
 8013ee4:	9b00      	ldr	r3, [sp, #0]
 8013ee6:	f10a 0a01 	add.w	sl, sl, #1
 8013eea:	4553      	cmp	r3, sl
 8013eec:	f47f af6b 	bne.w	8013dc6 <cblas_chemm+0x23a>
 8013ef0:	e6f6      	b.n	8013ce0 <cblas_chemm+0x154>
 8013ef2:	bf00      	nop
 8013ef4:	08031108 	.word	0x08031108
 8013ef8:	08031300 	.word	0x08031300
 8013efc:	080311b8 	.word	0x080311b8
 8013f00:	00000000 	.word	0x00000000
    } else if (side == CblasRight && uplo == CblasUpper) {
 8013f04:	2d79      	cmp	r5, #121	; 0x79
 8013f06:	f000 818e 	beq.w	8014226 <cblas_chemm+0x69a>
    } else if (side == CblasRight && uplo == CblasLower) {
 8013f0a:	2d7a      	cmp	r5, #122	; 0x7a
 8013f0c:	f47f aed2 	bne.w	8013cb4 <cblas_chemm+0x128>
      for (i = 0; i < n1; i++) {
 8013f10:	9b00      	ldr	r3, [sp, #0]
 8013f12:	2b00      	cmp	r3, #0
 8013f14:	f77f aee4 	ble.w	8013ce0 <cblas_chemm+0x154>
 8013f18:	9a04      	ldr	r2, [sp, #16]
 8013f1a:	9b01      	ldr	r3, [sp, #4]
 8013f1c:	00d2      	lsls	r2, r2, #3
 8013f1e:	9206      	str	r2, [sp, #24]
 8013f20:	9a05      	ldr	r2, [sp, #20]
 8013f22:	00d2      	lsls	r2, r2, #3
 8013f24:	9204      	str	r2, [sp, #16]
 8013f26:	9a02      	ldr	r2, [sp, #8]
 8013f28:	3301      	adds	r3, #1
 8013f2a:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8013f2e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8013f32:	9305      	str	r3, [sp, #20]
 8013f34:	2300      	movs	r3, #0
 8013f36:	46d9      	mov	r9, fp
 8013f38:	f8dd b00c 	ldr.w	fp, [sp, #12]
 8013f3c:	9303      	str	r3, [sp, #12]
        for (j = 0; j < n2; j++) {
 8013f3e:	f1b8 0f00 	cmp.w	r8, #0
 8013f42:	f340 821c 	ble.w	801437e <cblas_chemm+0x7f2>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8013f46:	eddb 7a00 	vldr	s15, [fp]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8013f4a:	ed9b 7a01 	vldr	s14, [fp, #4]
          BASE temp2_imag = 0.0;
 8013f4e:	ed1f 3a14 	vldr	s6, [pc, #-80]	; 8013f00 <cblas_chemm+0x374>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013f52:	9c05      	ldr	r4, [sp, #20]
 8013f54:	f8dd e004 	ldr.w	lr, [sp, #4]
 8013f58:	f8dd c008 	ldr.w	ip, [sp, #8]
 8013f5c:	ee27 2a84 	vmul.f32	s4, s15, s8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013f60:	ee64 2a47 	vnmul.f32	s5, s8, s14
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013f64:	eea7 2a24 	vfma.f32	s4, s14, s9
 8013f68:	465e      	mov	r6, fp
 8013f6a:	464d      	mov	r5, r9
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013f6c:	eee7 2aa4 	vfma.f32	s5, s15, s9
        for (j = 0; j < n2; j++) {
 8013f70:	2700      	movs	r7, #0
          BASE temp2_real = 0.0;
 8013f72:	eef0 1a43 	vmov.f32	s3, s6
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8013f76:	ed9c 5a00 	vldr	s10, [ip]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 8013f7a:	ed95 7a00 	vldr	s14, [r5]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 8013f7e:	edd5 7a01 	vldr	s15, [r5, #4]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 8013f82:	eea5 7a22 	vfma.f32	s14, s10, s5
        for (j = 0; j < n2; j++) {
 8013f86:	3701      	adds	r7, #1
 8013f88:	45b8      	cmp	r8, r7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013f8a:	ee63 5a44 	vnmul.f32	s11, s6, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013f8e:	ee24 6a21 	vmul.f32	s12, s8, s3
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 8013f92:	eef0 6a47 	vmov.f32	s13, s14
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013f96:	eeb0 7a65 	vmov.f32	s14, s11
 8013f9a:	eea4 7aa1 	vfma.f32	s14, s9, s3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013f9e:	eea4 6a83 	vfma.f32	s12, s9, s6
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 8013fa2:	eee5 7a02 	vfma.f32	s15, s10, s4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013fa6:	ee36 7a87 	vadd.f32	s14, s13, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013faa:	ee77 7a86 	vadd.f32	s15, s15, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013fae:	ed85 7a00 	vstr	s14, [r5]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013fb2:	edc5 7a01 	vstr	s15, [r5, #4]
        for (j = 0; j < n2; j++) {
 8013fb6:	f000 81e2 	beq.w	801437e <cblas_chemm+0x7f2>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8013fba:	edd6 7a02 	vldr	s15, [r6, #8]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8013fbe:	ed96 7a03 	vldr	s14, [r6, #12]
          BASE temp2_imag = 0.0;
 8013fc2:	ed1f 3a31 	vldr	s6, [pc, #-196]	; 8013f00 <cblas_chemm+0x374>
 8013fc6:	9b02      	ldr	r3, [sp, #8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013fc8:	ee24 2a27 	vmul.f32	s4, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013fcc:	ee67 2a44 	vnmul.f32	s5, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013fd0:	eea4 2a87 	vfma.f32	s4, s9, s14
 8013fd4:	eb03 03ce 	add.w	r3, r3, lr, lsl #3
 8013fd8:	f109 0004 	add.w	r0, r9, #4
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013fdc:	eee4 2aa7 	vfma.f32	s5, s9, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013fe0:	4649      	mov	r1, r9
 8013fe2:	465a      	mov	r2, fp
          BASE temp2_real = 0.0;
 8013fe4:	eef0 1a43 	vmov.f32	s3, s6
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8013fe8:	ed93 7a01 	vldr	s14, [r3, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8013fec:	edd3 6a00 	vldr	s13, [r3]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013ff0:	ed50 5a01 	vldr	s11, [r0, #-4]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 8013ff4:	edd2 7a01 	vldr	s15, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8013ff8:	edd2 3a00 	vldr	s7, [r2]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013ffc:	ee27 6a42 	vnmul.f32	s12, s14, s4
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8014000:	ee22 5a26 	vmul.f32	s10, s4, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8014004:	eea2 6aa6 	vfma.f32	s12, s5, s13
 8014008:	3308      	adds	r3, #8
          for (k = 0; k < j; k++) {
 801400a:	429c      	cmp	r4, r3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801400c:	eea2 5a87 	vfma.f32	s10, s5, s14
 8014010:	f102 0208 	add.w	r2, r2, #8
 8014014:	f100 0008 	add.w	r0, r0, #8
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8014018:	ee35 6a86 	vadd.f32	s12, s11, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801401c:	ee67 5a27 	vmul.f32	s11, s14, s15
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8014020:	ee66 7aa7 	vmul.f32	s15, s13, s15
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8014024:	ed00 6a03 	vstr	s12, [r0, #-12]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8014028:	ed91 6a01 	vldr	s12, [r1, #4]
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801402c:	eee7 7a63 	vfms.f32	s15, s14, s7
 8014030:	f101 0108 	add.w	r1, r1, #8
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 8014034:	eee6 5aa3 	vfma.f32	s11, s13, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8014038:	ee36 7a05 	vadd.f32	s14, s12, s10
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801403c:	ee71 1aa5 	vadd.f32	s3, s3, s11
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8014040:	ed01 7a01 	vstr	s14, [r1, #-4]
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8014044:	ee33 3a27 	vadd.f32	s6, s6, s15
          for (k = 0; k < j; k++) {
 8014048:	d1ce      	bne.n	8013fe8 <cblas_chemm+0x45c>
 801404a:	9b01      	ldr	r3, [sp, #4]
 801404c:	44d4      	add	ip, sl
 801404e:	3508      	adds	r5, #8
 8014050:	3608      	adds	r6, #8
 8014052:	449e      	add	lr, r3
 8014054:	4454      	add	r4, sl
 8014056:	e78e      	b.n	8013f76 <cblas_chemm+0x3ea>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8014058:	9b00      	ldr	r3, [sp, #0]
 801405a:	9a05      	ldr	r2, [sp, #20]
 801405c:	2b01      	cmp	r3, #1
 801405e:	bfb8      	it	lt
 8014060:	2301      	movlt	r3, #1
 8014062:	4293      	cmp	r3, r2
 8014064:	f300 8183 	bgt.w	801436e <cblas_chemm+0x7e2>
 8014068:	9a04      	ldr	r2, [sp, #16]
 801406a:	4293      	cmp	r3, r2
 801406c:	bfcc      	ite	gt
 801406e:	200d      	movgt	r0, #13
 8014070:	2008      	movle	r0, #8
 8014072:	e5c3      	b.n	8013bfc <cblas_chemm+0x70>
 8014074:	9b00      	ldr	r3, [sp, #0]
 8014076:	9a05      	ldr	r2, [sp, #20]
 8014078:	2b01      	cmp	r3, #1
 801407a:	bfb8      	it	lt
 801407c:	2301      	movlt	r3, #1
 801407e:	4293      	cmp	r3, r2
 8014080:	f300 8175 	bgt.w	801436e <cblas_chemm+0x7e2>
 8014084:	9a04      	ldr	r2, [sp, #16]
 8014086:	4293      	cmp	r3, r2
 8014088:	f77f ae22 	ble.w	8013cd0 <cblas_chemm+0x144>
 801408c:	200d      	movs	r0, #13
 801408e:	e5b5      	b.n	8013bfc <cblas_chemm+0x70>
      for (i = 0; i < n1; i++) {
 8014090:	9a00      	ldr	r2, [sp, #0]
 8014092:	2a00      	cmp	r2, #0
 8014094:	f77f ae24 	ble.w	8013ce0 <cblas_chemm+0x154>
 8014098:	9b01      	ldr	r3, [sp, #4]
 801409a:	f8dd e008 	ldr.w	lr, [sp, #8]
 801409e:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 80140a2:	3301      	adds	r3, #1
 80140a4:	00db      	lsls	r3, r3, #3
 80140a6:	930a      	str	r3, [sp, #40]	; 0x28
 80140a8:	f1ae 0508 	sub.w	r5, lr, #8
 80140ac:	3b08      	subs	r3, #8
 80140ae:	9309      	str	r3, [sp, #36]	; 0x24
 80140b0:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
 80140b4:	9b05      	ldr	r3, [sp, #20]
 80140b6:	9a04      	ldr	r2, [sp, #16]
 80140b8:	2100      	movs	r1, #0
 80140ba:	e9cd 2301 	strd	r2, r3, [sp, #4]
 80140be:	00df      	lsls	r7, r3, #3
 80140c0:	2301      	movs	r3, #1
 80140c2:	9106      	str	r1, [sp, #24]
 80140c4:	9107      	str	r1, [sp, #28]
 80140c6:	00d6      	lsls	r6, r2, #3
 80140c8:	469b      	mov	fp, r3
        for (j = 0; j < n2; j++) {
 80140ca:	f1b8 0f00 	cmp.w	r8, #0
 80140ce:	bfd8      	it	le
 80140d0:	f8cd b020 	strle.w	fp, [sp, #32]
 80140d4:	f340 808b 	ble.w	80141ee <cblas_chemm+0x662>
 80140d8:	9b02      	ldr	r3, [sp, #8]
 80140da:	9a01      	ldr	r2, [sp, #4]
 80140dc:	f8cd b020 	str.w	fp, [sp, #32]
 80140e0:	4619      	mov	r1, r3
 80140e2:	9b07      	ldr	r3, [sp, #28]
 80140e4:	4610      	mov	r0, r2
 80140e6:	eba1 0a03 	sub.w	sl, r1, r3
 80140ea:	9a06      	ldr	r2, [sp, #24]
 80140ec:	9903      	ldr	r1, [sp, #12]
 80140ee:	eba0 0902 	sub.w	r9, r0, r2
 80140f2:	eb01 04c3 	add.w	r4, r1, r3, lsl #3
 80140f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80140f8:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 80140fc:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8014100:	f10a 0a04 	add.w	sl, sl, #4
 8014104:	f109 0904 	add.w	r9, r9, #4
 8014108:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 801410c:	f04f 0c00 	mov.w	ip, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8014110:	ed94 6a00 	vldr	s12, [r4]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8014114:	edd4 5a01 	vldr	s11, [r4, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8014118:	edde 6a00 	vldr	s13, [lr]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801411c:	ed90 7a00 	vldr	s14, [r0]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 8014120:	edd0 7a01 	vldr	s15, [r0, #4]
          for (k = i + 1; k < n1; k++) {
 8014124:	9b00      	ldr	r3, [sp, #0]
          BASE temp2_imag = 0.0;
 8014126:	ed1f 2a8a 	vldr	s4, [pc, #-552]	; 8013f00 <cblas_chemm+0x374>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801412a:	ee24 1a06 	vmul.f32	s2, s8, s12
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801412e:	ee65 1ac4 	vnmul.f32	s3, s11, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8014132:	eea4 1aa5 	vfma.f32	s2, s9, s11
          for (k = i + 1; k < n1; k++) {
 8014136:	455b      	cmp	r3, fp
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8014138:	eee4 1a86 	vfma.f32	s3, s9, s12
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801413c:	eee1 7a26 	vfma.f32	s15, s2, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8014140:	eea1 7aa6 	vfma.f32	s14, s3, s13
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 8014144:	edc0 7a01 	vstr	s15, [r0, #4]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8014148:	ed80 7a00 	vstr	s14, [r0]
          BASE temp2_real = 0.0;
 801414c:	eef0 0a42 	vmov.f32	s1, s4
          for (k = i + 1; k < n1; k++) {
 8014150:	dd35      	ble.n	80141be <cblas_chemm+0x632>
 8014152:	eb0a 0104 	add.w	r1, sl, r4
 8014156:	eb09 0300 	add.w	r3, r9, r0
 801415a:	4672      	mov	r2, lr
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801415c:	edd2 7a03 	vldr	s15, [r2, #12]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8014160:	ed92 7a02 	vldr	s14, [r2, #8]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8014164:	ed51 2a01 	vldr	s5, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8014168:	ed91 3a00 	vldr	s6, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801416c:	ed13 5a01 	vldr	s10, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8014170:	ed93 6a00 	vldr	s12, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8014174:	ee61 5a27 	vmul.f32	s11, s2, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8014178:	ee67 3ae1 	vnmul.f32	s7, s15, s3
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801417c:	eee1 5a87 	vfma.f32	s11, s3, s14
 8014180:	3208      	adds	r2, #8
          for (k = i + 1; k < n1; k++) {
 8014182:	4295      	cmp	r5, r2
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8014184:	ee63 6a67 	vnmul.f32	s13, s6, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8014188:	eee1 3a07 	vfma.f32	s7, s2, s14
 801418c:	4439      	add	r1, r7
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801418e:	ee67 7aa2 	vmul.f32	s15, s15, s5
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8014192:	eee7 6a22 	vfma.f32	s13, s14, s5
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8014196:	eee7 7a03 	vfma.f32	s15, s14, s6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801419a:	ee75 5a25 	vadd.f32	s11, s10, s11
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801419e:	ee36 7a23 	vadd.f32	s14, s12, s7
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 80141a2:	ed43 5a01 	vstr	s11, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80141a6:	ed83 7a00 	vstr	s14, [r3]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80141aa:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80141ae:	ee32 2a27 	vadd.f32	s4, s4, s15
          for (k = i + 1; k < n1; k++) {
 80141b2:	4433      	add	r3, r6
 80141b4:	d1d2      	bne.n	801415c <cblas_chemm+0x5d0>
 80141b6:	ed90 7a00 	vldr	s14, [r0]
 80141ba:	edd0 7a01 	vldr	s15, [r0, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80141be:	ee22 6a44 	vnmul.f32	s12, s4, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80141c2:	ee64 6a20 	vmul.f32	s13, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80141c6:	eea4 6aa0 	vfma.f32	s12, s9, s1
        for (j = 0; j < n2; j++) {
 80141ca:	f10c 0c01 	add.w	ip, ip, #1
 80141ce:	45e0      	cmp	r8, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80141d0:	eee4 6a82 	vfma.f32	s13, s9, s4
 80141d4:	f104 0408 	add.w	r4, r4, #8
 80141d8:	f100 0008 	add.w	r0, r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80141dc:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80141e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80141e4:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80141e8:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 80141ec:	d190      	bne.n	8014110 <cblas_chemm+0x584>
      for (i = 0; i < n1; i++) {
 80141ee:	9a07      	ldr	r2, [sp, #28]
 80141f0:	9b05      	ldr	r3, [sp, #20]
 80141f2:	4611      	mov	r1, r2
 80141f4:	4419      	add	r1, r3
 80141f6:	9107      	str	r1, [sp, #28]
 80141f8:	9906      	ldr	r1, [sp, #24]
 80141fa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80141fc:	4608      	mov	r0, r1
 80141fe:	9909      	ldr	r1, [sp, #36]	; 0x24
 8014200:	440d      	add	r5, r1
 8014202:	9902      	ldr	r1, [sp, #8]
 8014204:	4496      	add	lr, r2
 8014206:	4419      	add	r1, r3
 8014208:	9a04      	ldr	r2, [sp, #16]
 801420a:	9b01      	ldr	r3, [sp, #4]
 801420c:	9102      	str	r1, [sp, #8]
 801420e:	4413      	add	r3, r2
 8014210:	4410      	add	r0, r2
 8014212:	9301      	str	r3, [sp, #4]
 8014214:	9a08      	ldr	r2, [sp, #32]
 8014216:	9b00      	ldr	r3, [sp, #0]
 8014218:	9006      	str	r0, [sp, #24]
 801421a:	4293      	cmp	r3, r2
 801421c:	f10b 0b01 	add.w	fp, fp, #1
 8014220:	f73f af53 	bgt.w	80140ca <cblas_chemm+0x53e>
 8014224:	e55c      	b.n	8013ce0 <cblas_chemm+0x154>
      for (i = 0; i < n1; i++) {
 8014226:	9b00      	ldr	r3, [sp, #0]
 8014228:	2b00      	cmp	r3, #0
 801422a:	f77f ad59 	ble.w	8013ce0 <cblas_chemm+0x154>
 801422e:	9b02      	ldr	r3, [sp, #8]
 8014230:	9a01      	ldr	r2, [sp, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014232:	ed1f 0acd 	vldr	s0, [pc, #-820]	; 8013f00 <cblas_chemm+0x374>
 8014236:	f8cd b020 	str.w	fp, [sp, #32]
 801423a:	3b08      	subs	r3, #8
 801423c:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 8014240:	9307      	str	r3, [sp, #28]
 8014242:	9b04      	ldr	r3, [sp, #16]
      for (i = 0; i < n1; i++) {
 8014244:	f04f 0a00 	mov.w	sl, #0
 8014248:	f102 0c01 	add.w	ip, r2, #1
 801424c:	00db      	lsls	r3, r3, #3
 801424e:	eb0b 0ec8 	add.w	lr, fp, r8, lsl #3
 8014252:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8014256:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 801425a:	f8cd a004 	str.w	sl, [sp, #4]
 801425e:	9306      	str	r3, [sp, #24]
 8014260:	46d3      	mov	fp, sl
        for (j = 0; j < n2; j++) {
 8014262:	f1b8 0f00 	cmp.w	r8, #0
 8014266:	f340 80aa 	ble.w	80143be <cblas_chemm+0x832>
 801426a:	9b03      	ldr	r3, [sp, #12]
 801426c:	9a01      	ldr	r2, [sp, #4]
 801426e:	9c07      	ldr	r4, [sp, #28]
 8014270:	9e02      	ldr	r6, [sp, #8]
 8014272:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 8014276:	9b08      	ldr	r3, [sp, #32]
 8014278:	2700      	movs	r7, #0
 801427a:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801427e:	ed95 6a00 	vldr	s12, [r5]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8014282:	edd5 5a01 	vldr	s11, [r5, #4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8014286:	edd6 6a00 	vldr	s13, [r6]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801428a:	edd0 7a00 	vldr	s15, [r0]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801428e:	ed90 7a01 	vldr	s14, [r0, #4]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8014292:	ee64 1a06 	vmul.f32	s3, s8, s12
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8014296:	ee25 2ac4 	vnmul.f32	s4, s11, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801429a:	eee4 1aa5 	vfma.f32	s3, s9, s11
          for (k = j + 1; k < n2; k++) {
 801429e:	3701      	adds	r7, #1
 80142a0:	45b8      	cmp	r8, r7
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80142a2:	eea4 2a86 	vfma.f32	s4, s9, s12
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80142a6:	eea1 7aa6 	vfma.f32	s14, s3, s13
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80142aa:	eee2 7a26 	vfma.f32	s15, s4, s13
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80142ae:	ed80 7a01 	vstr	s14, [r0, #4]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80142b2:	edc0 7a00 	vstr	s15, [r0]
          for (k = j + 1; k < n2; k++) {
 80142b6:	d06e      	beq.n	8014396 <cblas_chemm+0x80a>
          BASE temp2_imag = 0.0;
 80142b8:	ed9f 1a5d 	vldr	s2, [pc, #372]	; 8014430 <cblas_chemm+0x8a4>
          for (k = j + 1; k < n2; k++) {
 80142bc:	4603      	mov	r3, r0
          BASE temp2_real = 0.0;
 80142be:	eef0 0a41 	vmov.f32	s1, s2
          for (k = j + 1; k < n2; k++) {
 80142c2:	4629      	mov	r1, r5
 80142c4:	4632      	mov	r2, r6
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80142c6:	edd2 6a02 	vldr	s13, [r2, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80142ca:	ed92 7a03 	vldr	s14, [r2, #12]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 80142ce:	edd1 7a03 	vldr	s15, [r1, #12]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 80142d2:	edd1 2a02 	vldr	s5, [r1, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80142d6:	ed93 5a03 	vldr	s10, [r3, #12]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80142da:	edd3 5a02 	vldr	s11, [r3, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80142de:	ee21 6aa6 	vmul.f32	s12, s3, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80142e2:	ee67 3a61 	vnmul.f32	s7, s14, s3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80142e6:	eea2 6a07 	vfma.f32	s12, s4, s14
 80142ea:	3208      	adds	r2, #8
          for (k = j + 1; k < n2; k++) {
 80142ec:	4294      	cmp	r4, r2
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80142ee:	eee2 3a26 	vfma.f32	s7, s4, s13
 80142f2:	f101 0108 	add.w	r1, r1, #8
 80142f6:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80142fa:	eeb0 3a46 	vmov.f32	s6, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 80142fe:	ee27 6a27 	vmul.f32	s12, s14, s15
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8014302:	ee66 7aa7 	vmul.f32	s15, s13, s15
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 8014306:	eea6 6aa2 	vfma.f32	s12, s13, s5
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801430a:	eee7 7a62 	vfms.f32	s15, s14, s5
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801430e:	eef0 6a46 	vmov.f32	s13, s12
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8014312:	ee35 7aa3 	vadd.f32	s14, s11, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8014316:	ee35 6a03 	vadd.f32	s12, s10, s6
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801431a:	ed83 7a00 	vstr	s14, [r3]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801431e:	ed83 6a01 	vstr	s12, [r3, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 8014322:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8014326:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = j + 1; k < n2; k++) {
 801432a:	d1cc      	bne.n	80142c6 <cblas_chemm+0x73a>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801432c:	ee21 7a44 	vnmul.f32	s14, s2, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014330:	ee64 7a20 	vmul.f32	s15, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014334:	eea4 7aa0 	vfma.f32	s14, s9, s1
 8014338:	3508      	adds	r5, #8
 801433a:	4466      	add	r6, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801433c:	eee4 7a81 	vfma.f32	s15, s9, s2
 8014340:	444c      	add	r4, r9
 8014342:	3008      	adds	r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014344:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014348:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801434c:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014350:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014354:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014358:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801435c:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014360:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 8014364:	e78b      	b.n	801427e <cblas_chemm+0x6f2>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8014366:	9b05      	ldr	r3, [sp, #20]
 8014368:	2b00      	cmp	r3, #0
 801436a:	dc4c      	bgt.n	8014406 <cblas_chemm+0x87a>
 801436c:	2301      	movs	r3, #1
 801436e:	9a04      	ldr	r2, [sp, #16]
 8014370:	429a      	cmp	r2, r3
 8014372:	bfb4      	ite	lt
 8014374:	200d      	movlt	r0, #13
 8014376:	200a      	movge	r0, #10
 8014378:	e440      	b.n	8013bfc <cblas_chemm+0x70>
 801437a:	4643      	mov	r3, r8
 801437c:	e67b      	b.n	8014076 <cblas_chemm+0x4ea>
      for (i = 0; i < n1; i++) {
 801437e:	9a06      	ldr	r2, [sp, #24]
 8014380:	9b03      	ldr	r3, [sp, #12]
 8014382:	4491      	add	r9, r2
 8014384:	9a04      	ldr	r2, [sp, #16]
 8014386:	4493      	add	fp, r2
 8014388:	9a00      	ldr	r2, [sp, #0]
 801438a:	3301      	adds	r3, #1
 801438c:	429a      	cmp	r2, r3
 801438e:	9303      	str	r3, [sp, #12]
 8014390:	f47f add5 	bne.w	8013f3e <cblas_chemm+0x3b2>
 8014394:	e4a4      	b.n	8013ce0 <cblas_chemm+0x154>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014396:	ee64 7a00 	vmul.f32	s15, s8, s0
 801439a:	ed5e 6a02 	vldr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801439e:	ed1e 7a01 	vldr	s14, [lr, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80143a2:	eeb0 6a67 	vmov.f32	s12, s15
 80143a6:	ee94 6a80 	vfnms.f32	s12, s9, s0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80143aa:	eee4 7a80 	vfma.f32	s15, s9, s0
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80143ae:	ee76 6a86 	vadd.f32	s13, s13, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80143b2:	ee77 7a27 	vadd.f32	s15, s14, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80143b6:	ed4e 6a02 	vstr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80143ba:	ed4e 7a01 	vstr	s15, [lr, #-4]
      for (i = 0; i < n1; i++) {
 80143be:	9b06      	ldr	r3, [sp, #24]
 80143c0:	9a05      	ldr	r2, [sp, #20]
 80143c2:	449e      	add	lr, r3
 80143c4:	9b01      	ldr	r3, [sp, #4]
 80143c6:	4413      	add	r3, r2
 80143c8:	9301      	str	r3, [sp, #4]
 80143ca:	9b04      	ldr	r3, [sp, #16]
 80143cc:	449a      	add	sl, r3
 80143ce:	9b00      	ldr	r3, [sp, #0]
 80143d0:	f10b 0b01 	add.w	fp, fp, #1
 80143d4:	455b      	cmp	r3, fp
 80143d6:	f47f af44 	bne.w	8014262 <cblas_chemm+0x6d6>
 80143da:	e481      	b.n	8013ce0 <cblas_chemm+0x154>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80143dc:	4643      	mov	r3, r8
 80143de:	2b01      	cmp	r3, #1
 80143e0:	9a05      	ldr	r2, [sp, #20]
 80143e2:	bfb8      	it	lt
 80143e4:	2301      	movlt	r3, #1
 80143e6:	429a      	cmp	r2, r3
 80143e8:	dbc1      	blt.n	801436e <cblas_chemm+0x7e2>
 80143ea:	9a04      	ldr	r2, [sp, #16]
 80143ec:	429a      	cmp	r2, r3
 80143ee:	bfac      	ite	ge
 80143f0:	2008      	movge	r0, #8
 80143f2:	200d      	movlt	r0, #13
 80143f4:	e402      	b.n	8013bfc <cblas_chemm+0x70>
 80143f6:	3865      	subs	r0, #101	; 0x65
 80143f8:	2801      	cmp	r0, #1
 80143fa:	9b00      	ldr	r3, [sp, #0]
 80143fc:	bf94      	ite	ls
 80143fe:	2000      	movls	r0, #0
 8014400:	2001      	movhi	r0, #1
 8014402:	f7ff bbe1 	b.w	8013bc8 <cblas_chemm+0x3c>
 8014406:	9b04      	ldr	r3, [sp, #16]
 8014408:	2b00      	cmp	r3, #0
 801440a:	bfcc      	ite	gt
 801440c:	2005      	movgt	r0, #5
 801440e:	200d      	movle	r0, #13
 8014410:	f7ff bbf4 	b.w	8013bfc <cblas_chemm+0x70>
 8014414:	4643      	mov	r3, r8
 8014416:	2b01      	cmp	r3, #1
 8014418:	9a05      	ldr	r2, [sp, #20]
 801441a:	bfb8      	it	lt
 801441c:	2301      	movlt	r3, #1
 801441e:	429a      	cmp	r2, r3
 8014420:	dba5      	blt.n	801436e <cblas_chemm+0x7e2>
 8014422:	9a04      	ldr	r2, [sp, #16]
 8014424:	429a      	cmp	r2, r3
 8014426:	bfac      	ite	ge
 8014428:	2005      	movge	r0, #5
 801442a:	200d      	movlt	r0, #13
 801442c:	f7ff bbe6 	b.w	8013bfc <cblas_chemm+0x70>
 8014430:	00000000 	.word	0x00000000

08014434 <cblas_chemv>:
void
cblas_chemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *A, const int lda,
             const void *X, const int incX, const void *beta, void *Y,
             const int incY)
{
 8014434:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014438:	ed2d 8b02 	vpush	{d8}
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801443c:	2866      	cmp	r0, #102	; 0x66
 801443e:	b089      	sub	sp, #36	; 0x24
 8014440:	461f      	mov	r7, r3
 8014442:	bf0c      	ite	eq
 8014444:	f04f 33ff 	moveq.w	r3, #4294967295
 8014448:	2301      	movne	r3, #1
 801444a:	ee08 3a10 	vmov	s16, r3
 801444e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8014450:	9301      	str	r3, [sp, #4]
 8014452:	4689      	mov	r9, r1
 8014454:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8014456:	9302      	str	r3, [sp, #8]
  INDEX i, j;

  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8014458:	3979      	subs	r1, #121	; 0x79
 801445a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801445c:	9300      	str	r3, [sp, #0]
 801445e:	2901      	cmp	r1, #1
 8014460:	e9dd 4a14 	ldrd	r4, sl, [sp, #80]	; 0x50
 8014464:	e9dd 6b17 	ldrd	r6, fp, [sp, #92]	; 0x5c
 8014468:	4605      	mov	r5, r0
 801446a:	4690      	mov	r8, r2
 801446c:	f240 80e5 	bls.w	801463a <cblas_chemv+0x206>
 8014470:	2002      	movs	r0, #2
 8014472:	f1b8 0f00 	cmp.w	r8, #0
 8014476:	f2c0 80d3 	blt.w	8014620 <cblas_chemv+0x1ec>
 801447a:	4643      	mov	r3, r8
 801447c:	2b01      	cmp	r3, #1
 801447e:	bfb8      	it	lt
 8014480:	2301      	movlt	r3, #1
 8014482:	4553      	cmp	r3, sl
 8014484:	f340 8099 	ble.w	80145ba <cblas_chemv+0x186>
 8014488:	2e00      	cmp	r6, #0
 801448a:	f040 80a1 	bne.w	80145d0 <cblas_chemv+0x19c>
 801448e:	9b00      	ldr	r3, [sp, #0]
 8014490:	2b00      	cmp	r3, #0
 8014492:	bf0c      	ite	eq
 8014494:	200b      	moveq	r0, #11
 8014496:	2008      	movne	r0, #8
 8014498:	4a6b      	ldr	r2, [pc, #428]	; (8014648 <cblas_chemv+0x214>)
 801449a:	496c      	ldr	r1, [pc, #432]	; (801464c <cblas_chemv+0x218>)
 801449c:	f014 f934 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 80144a0:	ed97 4a00 	vldr	s8, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80144a4:	edd7 4a01 	vldr	s9, [r7, #4]

    const BASE beta_real = CONST_REAL0(beta);
 80144a8:	ed9b 6a00 	vldr	s12, [fp]
    const BASE beta_imag = CONST_IMAG0(beta);
 80144ac:	eddb 5a01 	vldr	s11, [fp, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 80144b0:	eeb5 4a40 	vcmp.f32	s8, #0.0
 80144b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144b8:	d152      	bne.n	8014560 <cblas_chemv+0x12c>
 80144ba:	eef5 4a40 	vcmp.f32	s9, #0.0
 80144be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144c2:	d14d      	bne.n	8014560 <cblas_chemv+0x12c>
        && (beta_real == 1.0 && beta_imag == 0.0))
 80144c4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80144c8:	eeb4 6a67 	vcmp.f32	s12, s15
 80144cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144d0:	f040 81a6 	bne.w	8014820 <cblas_chemv+0x3ec>
 80144d4:	eef5 5a40 	vcmp.f32	s11, #0.0
 80144d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144dc:	f000 809b 	beq.w	8014616 <cblas_chemv+0x1e2>
        REAL(Y, iy) = 0.0;
        IMAG(Y, iy) = 0.0;
        iy += incY;
      }
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
      INDEX iy = OFFSET(N, incY);
 80144e0:	9a00      	ldr	r2, [sp, #0]
 80144e2:	2a00      	cmp	r2, #0
 80144e4:	f340 8197 	ble.w	8014816 <cblas_chemv+0x3e2>
 80144e8:	2300      	movs	r3, #0
      for (i = 0; i < N; i++) {
 80144ea:	f1b8 0f00 	cmp.w	r8, #0
 80144ee:	dd1d      	ble.n	801452c <cblas_chemv+0xf8>
 80144f0:	9902      	ldr	r1, [sp, #8]
 80144f2:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
 80144f6:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 80144fa:	9900      	ldr	r1, [sp, #0]
 80144fc:	3204      	adds	r2, #4
 80144fe:	00c8      	lsls	r0, r1, #3
 8014500:	2100      	movs	r1, #0
        const BASE y_real = REAL(Y, iy);
        const BASE y_imag = IMAG(Y, iy);
 8014502:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE y_real = REAL(Y, iy);
 8014506:	ed52 6a01 	vldr	s13, [r2, #-4]
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801450a:	ee27 7ae5 	vnmul.f32	s14, s15, s11
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801450e:	ee66 7a27 	vmul.f32	s15, s12, s15
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 8014512:	eea6 7a26 	vfma.f32	s14, s12, s13
      for (i = 0; i < N; i++) {
 8014516:	3101      	adds	r1, #1
 8014518:	4588      	cmp	r8, r1
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801451a:	eee5 7aa6 	vfma.f32	s15, s11, s13
        REAL(Y, iy) = tmpR;
 801451e:	ed02 7a01 	vstr	s14, [r2, #-4]
        IMAG(Y, iy) = tmpI;
 8014522:	edc3 7a01 	vstr	s15, [r3, #4]
      for (i = 0; i < N; i++) {
 8014526:	4402      	add	r2, r0
 8014528:	4403      	add	r3, r0
 801452a:	d1ea      	bne.n	8014502 <cblas_chemv+0xce>
        iy += incY;
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801452c:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8014530:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014534:	d104      	bne.n	8014540 <cblas_chemv+0x10c>
 8014536:	eef5 4a40 	vcmp.f32	s9, #0.0
 801453a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801453e:	d06a      	beq.n	8014616 <cblas_chemv+0x1e2>
      return;

    /* form  y := alpha*A*x + y */

    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014540:	2d65      	cmp	r5, #101	; 0x65
 8014542:	f000 8089 	beq.w	8014658 <cblas_chemv+0x224>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8014546:	2d66      	cmp	r5, #102	; 0x66
 8014548:	f000 815d 	beq.w	8014806 <cblas_chemv+0x3d2>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        ix -= incX;
        iy -= incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 801454c:	4a40      	ldr	r2, [pc, #256]	; (8014650 <cblas_chemv+0x21c>)
 801454e:	493f      	ldr	r1, [pc, #252]	; (801464c <cblas_chemv+0x218>)
 8014550:	2000      	movs	r0, #0
#define BASE float
#include "source_hemv.h"
#undef BASE
}
 8014552:	b009      	add	sp, #36	; 0x24
 8014554:	ecbd 8b02 	vpop	{d8}
 8014558:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801455c:	f014 b8d4 	b.w	8028708 <cblas_xerbla>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8014560:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8014564:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014568:	d11a      	bne.n	80145a0 <cblas_chemv+0x16c>
 801456a:	eef5 5a40 	vcmp.f32	s11, #0.0
 801456e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014572:	d1b5      	bne.n	80144e0 <cblas_chemv+0xac>
      INDEX iy = OFFSET(N, incY);
 8014574:	9a00      	ldr	r2, [sp, #0]
 8014576:	2a00      	cmp	r2, #0
 8014578:	f340 8159 	ble.w	801482e <cblas_chemv+0x3fa>
 801457c:	2300      	movs	r3, #0
      for (i = 0; i < N; i++) {
 801457e:	f1b8 0f00 	cmp.w	r8, #0
 8014582:	ddd3      	ble.n	801452c <cblas_chemv+0xf8>
 8014584:	9a02      	ldr	r2, [sp, #8]
 8014586:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801458a:	9a00      	ldr	r2, [sp, #0]
        REAL(Y, iy) = 0.0;
 801458c:	2100      	movs	r1, #0
 801458e:	00d0      	lsls	r0, r2, #3
      for (i = 0; i < N; i++) {
 8014590:	2200      	movs	r2, #0
 8014592:	3201      	adds	r2, #1
 8014594:	4590      	cmp	r8, r2
        REAL(Y, iy) = 0.0;
 8014596:	6019      	str	r1, [r3, #0]
        IMAG(Y, iy) = 0.0;
 8014598:	6059      	str	r1, [r3, #4]
      for (i = 0; i < N; i++) {
 801459a:	4403      	add	r3, r0
 801459c:	d1f9      	bne.n	8014592 <cblas_chemv+0x15e>
 801459e:	e7c5      	b.n	801452c <cblas_chemv+0xf8>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 80145a0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80145a4:	eeb4 6a67 	vcmp.f32	s12, s15
 80145a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80145ac:	d198      	bne.n	80144e0 <cblas_chemv+0xac>
 80145ae:	eef5 5a40 	vcmp.f32	s11, #0.0
 80145b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80145b6:	d0b9      	beq.n	801452c <cblas_chemv+0xf8>
 80145b8:	e792      	b.n	80144e0 <cblas_chemv+0xac>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 80145ba:	2e00      	cmp	r6, #0
 80145bc:	f43f af67 	beq.w	801448e <cblas_chemv+0x5a>
 80145c0:	9b00      	ldr	r3, [sp, #0]
 80145c2:	2b00      	cmp	r3, #0
 80145c4:	f000 81f8 	beq.w	80149b8 <cblas_chemv+0x584>
 80145c8:	2800      	cmp	r0, #0
 80145ca:	f43f af69 	beq.w	80144a0 <cblas_chemv+0x6c>
 80145ce:	e763      	b.n	8014498 <cblas_chemv+0x64>
 80145d0:	9b00      	ldr	r3, [sp, #0]
 80145d2:	2b00      	cmp	r3, #0
 80145d4:	bf0c      	ite	eq
 80145d6:	200b      	moveq	r0, #11
 80145d8:	2006      	movne	r0, #6
 80145da:	e75d      	b.n	8014498 <cblas_chemv+0x64>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80145dc:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8014654 <cblas_chemv+0x220>
 80145e0:	9a00      	ldr	r2, [sp, #0]
 80145e2:	9906      	ldr	r1, [sp, #24]
 80145e4:	ee64 4a87 	vmul.f32	s9, s9, s14
 80145e8:	fb02 1303 	mla	r3, r2, r3, r1
 80145ec:	9902      	ldr	r1, [sp, #8]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80145ee:	eef0 6a64 	vmov.f32	s13, s9
 80145f2:	eed4 6a07 	vfnms.f32	s13, s8, s14
 80145f6:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
 80145fa:	edd2 7a00 	vldr	s15, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80145fe:	eee4 4a07 	vfma.f32	s9, s8, s14
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014602:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8014606:	edc2 7a00 	vstr	s15, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801460a:	edd2 7a01 	vldr	s15, [r2, #4]
 801460e:	ee77 4aa4 	vadd.f32	s9, s15, s9
 8014612:	edc2 4a01 	vstr	s9, [r2, #4]
 8014616:	b009      	add	sp, #36	; 0x24
 8014618:	ecbd 8b02 	vpop	{d8}
 801461c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8014620:	f1ba 0f00 	cmp.w	sl, #0
 8014624:	f77f af30 	ble.w	8014488 <cblas_chemv+0x54>
 8014628:	2e00      	cmp	r6, #0
 801462a:	f43f af30 	beq.w	801448e <cblas_chemv+0x5a>
 801462e:	9b00      	ldr	r3, [sp, #0]
 8014630:	2b00      	cmp	r3, #0
 8014632:	bf0c      	ite	eq
 8014634:	200b      	moveq	r0, #11
 8014636:	2003      	movne	r0, #3
 8014638:	e72e      	b.n	8014498 <cblas_chemv+0x64>
 801463a:	3865      	subs	r0, #101	; 0x65
 801463c:	2801      	cmp	r0, #1
 801463e:	bf94      	ite	ls
 8014640:	2000      	movls	r0, #0
 8014642:	2001      	movhi	r0, #1
 8014644:	e715      	b.n	8014472 <cblas_chemv+0x3e>
 8014646:	bf00      	nop
 8014648:	08031108 	.word	0x08031108
 801464c:	08031310 	.word	0x08031310
 8014650:	080311b8 	.word	0x080311b8
 8014654:	00000000 	.word	0x00000000
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014658:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 801465c:	f000 80ec 	beq.w	8014838 <cblas_chemv+0x404>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8014660:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8014664:	f47f af72 	bne.w	801454c <cblas_chemv+0x118>
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8014668:	9b00      	ldr	r3, [sp, #0]
      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 801466a:	2e00      	cmp	r6, #0
 801466c:	f108 31ff 	add.w	r1, r8, #4294967295
 8014670:	bfd6      	itet	le
 8014672:	4277      	negle	r7, r6
 8014674:	2700      	movgt	r7, #0
 8014676:	434f      	mulle	r7, r1
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8014678:	2b00      	cmp	r3, #0
 801467a:	bfda      	itte	le
 801467c:	425d      	negle	r5, r3
 801467e:	fb01 f305 	mulle.w	r3, r1, r5
 8014682:	2300      	movgt	r3, #0
 8014684:	9306      	str	r3, [sp, #24]
 8014686:	9d06      	ldr	r5, [sp, #24]
 8014688:	9b00      	ldr	r3, [sp, #0]
      for (i = N; i > 0 && i--;) {
 801468a:	f1b8 0f00 	cmp.w	r8, #0
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801468e:	fb01 5503 	mla	r5, r1, r3, r5
      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8014692:	fb01 7206 	mla	r2, r1, r6, r7
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8014696:	9507      	str	r5, [sp, #28]
      for (i = N; i > 0 && i--;) {
 8014698:	ddbd      	ble.n	8014616 <cblas_chemv+0x1e2>
 801469a:	9801      	ldr	r0, [sp, #4]
 801469c:	9d07      	ldr	r5, [sp, #28]
 801469e:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 80146a2:	9800      	ldr	r0, [sp, #0]
 80146a4:	ebc0 7c40 	rsb	ip, r0, r0, lsl #29
 80146a8:	9802      	ldr	r0, [sp, #8]
 80146aa:	fb01 f30a 	mul.w	r3, r1, sl
 80146ae:	eb00 09c5 	add.w	r9, r0, r5, lsl #3
 80146b2:	4605      	mov	r5, r0
 80146b4:	9806      	ldr	r0, [sp, #24]
 80146b6:	9303      	str	r3, [sp, #12]
 80146b8:	eb05 0bc0 	add.w	fp, r5, r0, lsl #3
 80146bc:	9801      	ldr	r0, [sp, #4]
 80146be:	9d03      	ldr	r5, [sp, #12]
 80146c0:	18cb      	adds	r3, r1, r3
 80146c2:	ea6f 080a 	mvn.w	r8, sl
 80146c6:	eb00 07c7 	add.w	r7, r0, r7, lsl #3
 80146ca:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 80146ce:	eb04 00c5 	add.w	r0, r4, r5, lsl #3
 80146d2:	9c06      	ldr	r4, [sp, #24]
 80146d4:	9d02      	ldr	r5, [sp, #8]
 80146d6:	9701      	str	r7, [sp, #4]
 80146d8:	ebc6 7e46 	rsb	lr, r6, r6, lsl #29
 80146dc:	ea4f 07c8 	mov.w	r7, r8, lsl #3
 80146e0:	9703      	str	r7, [sp, #12]
 80146e2:	ea4f 07ce 	mov.w	r7, lr, lsl #3
 80146e6:	f109 0e04 	add.w	lr, r9, #4
 80146ea:	eb05 09c4 	add.w	r9, r5, r4, lsl #3
 80146ee:	9c00      	ldr	r4, [sp, #0]
 80146f0:	9704      	str	r7, [sp, #16]
 80146f2:	ebca 7a4a 	rsb	sl, sl, sl, lsl #29
 80146f6:	ea4f 07cc 	mov.w	r7, ip, lsl #3
 80146fa:	3204      	adds	r2, #4
 80146fc:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8014700:	00f6      	lsls	r6, r6, #3
 8014702:	9705      	str	r7, [sp, #20]
 8014704:	f10b 0b04 	add.w	fp, fp, #4
 8014708:	9106      	str	r1, [sp, #24]
 801470a:	ea4f 08c4 	mov.w	r8, r4, lsl #3
        BASE x_real = CONST_REAL(X, ix);
 801470e:	ed12 6a01 	vldr	s12, [r2, #-4]
        BASE x_imag = CONST_IMAG(X, ix);
 8014712:	edd2 5a00 	vldr	s11, [r2]
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 8014716:	edd3 6a00 	vldr	s13, [r3]
        REAL(Y, iy) += temp1_real * Aii_real;
 801471a:	ed5e 7a01 	vldr	s15, [lr, #-4]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801471e:	ed9e 7a00 	vldr	s14, [lr]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 8014722:	ee24 3a86 	vmul.f32	s6, s9, s12
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 8014726:	ee65 3ae4 	vnmul.f32	s7, s11, s9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801472a:	eea4 3a25 	vfma.f32	s6, s8, s11
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801472e:	eee4 3a06 	vfma.f32	s7, s8, s12
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8014732:	eea3 7a26 	vfma.f32	s14, s6, s13
        REAL(Y, iy) += temp1_real * Aii_real;
 8014736:	eee3 7aa6 	vfma.f32	s15, s7, s13
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801473a:	ed8e 7a00 	vstr	s14, [lr]
        REAL(Y, iy) += temp1_real * Aii_real;
 801473e:	ed4e 7a01 	vstr	s15, [lr, #-4]
        for (j = j_min; j < j_max; j++) {
 8014742:	2900      	cmp	r1, #0
 8014744:	f000 812e 	beq.w	80149a4 <cblas_chemv+0x570>
        BASE temp2_imag = 0.0;
 8014748:	ed5f 2a3e 	vldr	s5, [pc, #-248]	; 8014654 <cblas_chemv+0x220>
        for (j = j_min; j < j_max; j++) {
 801474c:	9f01      	ldr	r7, [sp, #4]
 801474e:	eef8 1ac8 	vcvt.f32.s32	s3, s16
        BASE temp2_real = 0.0;
 8014752:	eeb0 2a62 	vmov.f32	s4, s5
        for (j = j_min; j < j_max; j++) {
 8014756:	46dc      	mov	ip, fp
 8014758:	464d      	mov	r5, r9
 801475a:	4604      	mov	r4, r0
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 801475c:	edd4 6a00 	vldr	s13, [r4]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8014760:	ed94 7a01 	vldr	s14, [r4, #4]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8014764:	ed5c 5a01 	vldr	s11, [ip, #-4]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8014768:	ee21 7a87 	vmul.f32	s14, s3, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801476c:	ee63 7a26 	vmul.f32	s15, s6, s13
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8014770:	ee23 5a07 	vmul.f32	s10, s6, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8014774:	eee7 7a63 	vfms.f32	s15, s14, s7
 8014778:	3408      	adds	r4, #8
        for (j = j_min; j < j_max; j++) {
 801477a:	42a3      	cmp	r3, r4
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801477c:	eeb0 6a67 	vmov.f32	s12, s15
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8014780:	eef0 7a45 	vmov.f32	s15, s10
 8014784:	eee3 7aa6 	vfma.f32	s15, s7, s13
 8014788:	ee75 7aa7 	vadd.f32	s15, s11, s15
 801478c:	ed4c 7a01 	vstr	s15, [ip, #-4]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8014790:	edd5 7a01 	vldr	s15, [r5, #4]
 8014794:	ee77 7a86 	vadd.f32	s15, s15, s12
 8014798:	44c4      	add	ip, r8
 801479a:	edc5 7a01 	vstr	s15, [r5, #4]
          x_imag = CONST_IMAG(X, jx);
 801479e:	edd7 7a01 	vldr	s15, [r7, #4]
          x_real = CONST_REAL(X, jx);
 80147a2:	edd7 5a00 	vldr	s11, [r7]
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 80147a6:	ee27 6ac7 	vnmul.f32	s12, s15, s14
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 80147aa:	ee66 7aa7 	vmul.f32	s15, s13, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 80147ae:	eea6 6aa5 	vfma.f32	s12, s13, s11
 80147b2:	4445      	add	r5, r8
 80147b4:	4437      	add	r7, r6
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 80147b6:	eee7 7a25 	vfma.f32	s15, s14, s11
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 80147ba:	ee32 2a06 	vadd.f32	s4, s4, s12
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 80147be:	ee72 2aa7 	vadd.f32	s5, s5, s15
        for (j = j_min; j < j_max; j++) {
 80147c2:	d1cb      	bne.n	801475c <cblas_chemv+0x328>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80147c4:	ee22 7ae4 	vnmul.f32	s14, s5, s9
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80147c8:	ee64 7a82 	vmul.f32	s15, s9, s4
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80147cc:	eea4 7a02 	vfma.f32	s14, s8, s4
 80147d0:	9c03      	ldr	r4, [sp, #12]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80147d2:	eee4 7a22 	vfma.f32	s15, s8, s5
 80147d6:	4423      	add	r3, r4
 80147d8:	9c04      	ldr	r4, [sp, #16]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80147da:	eeb0 6a47 	vmov.f32	s12, s14
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80147de:	eef0 6a67 	vmov.f32	s13, s15
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80147e2:	ed1e 7a01 	vldr	s14, [lr, #-4]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80147e6:	edde 7a00 	vldr	s15, [lr]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80147ea:	ee37 7a06 	vadd.f32	s14, s14, s12
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80147ee:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80147f2:	4422      	add	r2, r4
 80147f4:	9c05      	ldr	r4, [sp, #20]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80147f6:	ed0e 7a01 	vstr	s14, [lr, #-4]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80147fa:	edce 7a00 	vstr	s15, [lr]
      for (i = N; i > 0 && i--;) {
 80147fe:	4450      	add	r0, sl
 8014800:	3901      	subs	r1, #1
 8014802:	44a6      	add	lr, r4
 8014804:	e783      	b.n	801470e <cblas_chemv+0x2da>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8014806:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 801480a:	d015      	beq.n	8014838 <cblas_chemv+0x404>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 801480c:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8014810:	f47f ae9c 	bne.w	801454c <cblas_chemv+0x118>
 8014814:	e728      	b.n	8014668 <cblas_chemv+0x234>
      INDEX iy = OFFSET(N, incY);
 8014816:	f1c8 0301 	rsb	r3, r8, #1
 801481a:	fb03 f302 	mul.w	r3, r3, r2
 801481e:	e664      	b.n	80144ea <cblas_chemv+0xb6>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8014820:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8014824:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014828:	f43f ae9f 	beq.w	801456a <cblas_chemv+0x136>
 801482c:	e658      	b.n	80144e0 <cblas_chemv+0xac>
      INDEX iy = OFFSET(N, incY);
 801482e:	f1c8 0301 	rsb	r3, r8, #1
 8014832:	fb03 f302 	mul.w	r3, r3, r2
 8014836:	e6a2      	b.n	801457e <cblas_chemv+0x14a>
      INDEX ix = OFFSET(N, incX);
 8014838:	2e00      	cmp	r6, #0
      INDEX iy = OFFSET(N, incY);
 801483a:	9a00      	ldr	r2, [sp, #0]
      INDEX ix = OFFSET(N, incX);
 801483c:	bfda      	itte	le
 801483e:	f1c8 0901 	rsble	r9, r8, #1
 8014842:	fb09 f906 	mulle.w	r9, r9, r6
 8014846:	f04f 0900 	movgt.w	r9, #0
      INDEX iy = OFFSET(N, incY);
 801484a:	2a00      	cmp	r2, #0
 801484c:	bfda      	itte	le
 801484e:	f1c8 0301 	rsble	r3, r8, #1
 8014852:	4353      	mulle	r3, r2
 8014854:	2300      	movgt	r3, #0
      for (i = 0; i < N; i++) {
 8014856:	f1b8 0f00 	cmp.w	r8, #0
      INDEX iy = OFFSET(N, incY);
 801485a:	9306      	str	r3, [sp, #24]
      for (i = 0; i < N; i++) {
 801485c:	f77f aedb 	ble.w	8014616 <cblas_chemv+0x1e2>
 8014860:	f10a 0a01 	add.w	sl, sl, #1
 8014864:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8014868:	9a06      	ldr	r2, [sp, #24]
 801486a:	9800      	ldr	r0, [sp, #0]
 801486c:	9304      	str	r3, [sp, #16]
 801486e:	3b08      	subs	r3, #8
 8014870:	f1a4 0708 	sub.w	r7, r4, #8
 8014874:	46a6      	mov	lr, r4
 8014876:	9303      	str	r3, [sp, #12]
 8014878:	9c01      	ldr	r4, [sp, #4]
 801487a:	9b02      	ldr	r3, [sp, #8]
 801487c:	9605      	str	r6, [sp, #20]
 801487e:	eb02 0a00 	add.w	sl, r2, r0
 8014882:	eb09 0106 	add.w	r1, r9, r6
 8014886:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 801488a:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 801488e:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
 8014892:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
 8014896:	ea4f 0cc6 	mov.w	ip, r6, lsl #3
 801489a:	00c5      	lsls	r5, r0, #3
 801489c:	2300      	movs	r3, #0
 801489e:	468b      	mov	fp, r1
        BASE x_real = CONST_REAL(X, ix);
 80148a0:	ed99 6a00 	vldr	s12, [r9]
        BASE x_imag = CONST_IMAG(X, ix);
 80148a4:	edd9 5a01 	vldr	s11, [r9, #4]
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 80148a8:	edde 6a00 	vldr	s13, [lr]
        REAL(Y, iy) += temp1_real * Aii_real;
 80148ac:	edd2 7a00 	vldr	s15, [r2]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 80148b0:	ed92 7a01 	vldr	s14, [r2, #4]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 80148b4:	ee24 3a86 	vmul.f32	s6, s9, s12
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 80148b8:	ee65 3ae4 	vnmul.f32	s7, s11, s9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 80148bc:	eea4 3a25 	vfma.f32	s6, s8, s11
        const INDEX j_min = i + 1;
 80148c0:	1c5e      	adds	r6, r3, #1
        for (j = j_min; j < j_max; j++) {
 80148c2:	45b0      	cmp	r8, r6
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 80148c4:	eee4 3a06 	vfma.f32	s7, s8, s12
        IMAG(Y, iy) += temp1_imag * Aii_real;
 80148c8:	eea3 7a26 	vfma.f32	s14, s6, s13
        REAL(Y, iy) += temp1_real * Aii_real;
 80148cc:	eee3 7aa6 	vfma.f32	s15, s7, s13
        IMAG(Y, iy) += temp1_imag * Aii_real;
 80148d0:	ed82 7a01 	vstr	s14, [r2, #4]
        REAL(Y, iy) += temp1_real * Aii_real;
 80148d4:	edc2 7a00 	vstr	s15, [r2]
        for (j = j_min; j < j_max; j++) {
 80148d8:	f43f ae80 	beq.w	80145dc <cblas_chemv+0x1a8>
 80148dc:	9b01      	ldr	r3, [sp, #4]
        BASE temp2_imag = 0.0;
 80148de:	ed5f 2aa3 	vldr	s5, [pc, #-652]	; 8014654 <cblas_chemv+0x220>
 80148e2:	eef8 1ac8 	vcvt.f32.s32	s3, s16
 80148e6:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
        BASE temp2_real = 0.0;
 80148ea:	eeb0 2a62 	vmov.f32	s4, s5
 80148ee:	f10a 0004 	add.w	r0, sl, #4
        for (j = j_min; j < j_max; j++) {
 80148f2:	4651      	mov	r1, sl
 80148f4:	4673      	mov	r3, lr
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 80148f6:	edd3 6a02 	vldr	s13, [r3, #8]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 80148fa:	ed93 7a03 	vldr	s14, [r3, #12]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 80148fe:	ed50 5a01 	vldr	s11, [r0, #-4]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8014902:	ee21 7a87 	vmul.f32	s14, s3, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8014906:	ee63 7a26 	vmul.f32	s15, s6, s13
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801490a:	ee23 5a07 	vmul.f32	s10, s6, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801490e:	eee7 7a63 	vfms.f32	s15, s14, s7
 8014912:	3308      	adds	r3, #8
        for (j = j_min; j < j_max; j++) {
 8014914:	429f      	cmp	r7, r3
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8014916:	eeb0 6a67 	vmov.f32	s12, s15
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801491a:	eef0 7a45 	vmov.f32	s15, s10
 801491e:	eee3 7aa6 	vfma.f32	s15, s7, s13
 8014922:	ee75 7aa7 	vadd.f32	s15, s11, s15
 8014926:	ed40 7a01 	vstr	s15, [r0, #-4]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801492a:	edd1 7a01 	vldr	s15, [r1, #4]
 801492e:	ee77 7a86 	vadd.f32	s15, s15, s12
 8014932:	4428      	add	r0, r5
 8014934:	edc1 7a01 	vstr	s15, [r1, #4]
          x_imag = CONST_IMAG(X, jx);
 8014938:	edd4 7a01 	vldr	s15, [r4, #4]
          x_real = CONST_REAL(X, jx);
 801493c:	edd4 5a00 	vldr	s11, [r4]
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8014940:	ee27 6ac7 	vnmul.f32	s12, s15, s14
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8014944:	ee66 7aa7 	vmul.f32	s15, s13, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8014948:	eea6 6aa5 	vfma.f32	s12, s13, s11
 801494c:	4429      	add	r1, r5
 801494e:	4464      	add	r4, ip
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8014950:	eee7 7a25 	vfma.f32	s15, s14, s11
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8014954:	ee32 2a06 	vadd.f32	s4, s4, s12
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8014958:	ee72 2aa7 	vadd.f32	s5, s5, s15
        for (j = j_min; j < j_max; j++) {
 801495c:	d1cb      	bne.n	80148f6 <cblas_chemv+0x4c2>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801495e:	ee22 7ae4 	vnmul.f32	s14, s5, s9
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014962:	ee64 7a82 	vmul.f32	s15, s9, s4
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014966:	eea4 7a02 	vfma.f32	s14, s8, s4
 801496a:	9b05      	ldr	r3, [sp, #20]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801496c:	eee4 7a22 	vfma.f32	s15, s8, s5
 8014970:	449b      	add	fp, r3
 8014972:	9b04      	ldr	r3, [sp, #16]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014974:	eeb0 6a47 	vmov.f32	s12, s14
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014978:	eef0 6a67 	vmov.f32	s13, s15
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801497c:	ed92 7a00 	vldr	s14, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014980:	edd2 7a01 	vldr	s15, [r2, #4]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014984:	ee37 7a06 	vadd.f32	s14, s14, s12
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014988:	ee77 7aa6 	vadd.f32	s15, s15, s13
 801498c:	449e      	add	lr, r3
 801498e:	9b03      	ldr	r3, [sp, #12]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8014990:	ed82 7a00 	vstr	s14, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8014994:	441f      	add	r7, r3
 8014996:	edc2 7a01 	vstr	s15, [r2, #4]
      for (i = 0; i < N; i++) {
 801499a:	44e1      	add	r9, ip
 801499c:	44aa      	add	sl, r5
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801499e:	4633      	mov	r3, r6
 80149a0:	442a      	add	r2, r5
 80149a2:	e77d      	b.n	80148a0 <cblas_chemv+0x46c>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80149a4:	ed1f 7ad5 	vldr	s14, [pc, #-852]	; 8014654 <cblas_chemv+0x220>
 80149a8:	9b06      	ldr	r3, [sp, #24]
 80149aa:	9a00      	ldr	r2, [sp, #0]
 80149ac:	9907      	ldr	r1, [sp, #28]
 80149ae:	ee64 4a87 	vmul.f32	s9, s9, s14
 80149b2:	fb02 1313 	mls	r3, r2, r3, r1
 80149b6:	e619      	b.n	80145ec <cblas_chemv+0x1b8>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 80149b8:	200b      	movs	r0, #11
 80149ba:	e56d      	b.n	8014498 <cblas_chemv+0x64>

080149bc <cblas_cher>:

void
cblas_cher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const float alpha, const void *X, const int incX,
            void *A, const int lda)
{
 80149bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80149c0:	ed2d 8b02 	vpush	{d8}
 80149c4:	b085      	sub	sp, #20
 80149c6:	4698      	mov	r8, r3
 80149c8:	e9dd 9310 	ldrd	r9, r3, [sp, #64]	; 0x40
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i, j;
  const int conj = (order == CblasColMajor) ? -1 : 1;
 80149cc:	2866      	cmp	r0, #102	; 0x66
 80149ce:	460e      	mov	r6, r1

  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 80149d0:	f1a1 0179 	sub.w	r1, r1, #121	; 0x79
  const int conj = (order == CblasColMajor) ? -1 : 1;
 80149d4:	bf0c      	ite	eq
 80149d6:	f04f 34ff 	moveq.w	r4, #4294967295
 80149da:	2401      	movne	r4, #1
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 80149dc:	2901      	cmp	r1, #1
 80149de:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 80149e2:	9300      	str	r3, [sp, #0]
 80149e4:	4605      	mov	r5, r0
 80149e6:	4617      	mov	r7, r2
 80149e8:	eeb0 8a40 	vmov.f32	s16, s0
 80149ec:	d933      	bls.n	8014a56 <cblas_cher+0x9a>
 80149ee:	2a00      	cmp	r2, #0
 80149f0:	db0c      	blt.n	8014a0c <cblas_cher+0x50>
 80149f2:	f1b9 0f00 	cmp.w	r9, #0
 80149f6:	f040 80ca 	bne.w	8014b8e <cblas_cher+0x1d2>
 80149fa:	2f01      	cmp	r7, #1
 80149fc:	4638      	mov	r0, r7
 80149fe:	bfb8      	it	lt
 8014a00:	2001      	movlt	r0, #1
 8014a02:	4582      	cmp	sl, r0
 8014a04:	bfb4      	ite	lt
 8014a06:	2008      	movlt	r0, #8
 8014a08:	2006      	movge	r0, #6
 8014a0a:	e007      	b.n	8014a1c <cblas_cher+0x60>
 8014a0c:	f1b9 0f00 	cmp.w	r9, #0
 8014a10:	d0f3      	beq.n	80149fa <cblas_cher+0x3e>
 8014a12:	f1ba 0f00 	cmp.w	sl, #0
 8014a16:	bfd4      	ite	le
 8014a18:	2008      	movle	r0, #8
 8014a1a:	2003      	movgt	r0, #3
 8014a1c:	4a9b      	ldr	r2, [pc, #620]	; (8014c8c <cblas_cher+0x2d0>)
 8014a1e:	499c      	ldr	r1, [pc, #624]	; (8014c90 <cblas_cher+0x2d4>)
 8014a20:	f013 fe72 	bl	8028708 <cblas_xerbla>

  if (alpha == 0.0)
 8014a24:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8014a28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014a2c:	d00e      	beq.n	8014a4c <cblas_cher+0x90>
    return;

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014a2e:	2d65      	cmp	r5, #101	; 0x65
 8014a30:	d024      	beq.n	8014a7c <cblas_cher+0xc0>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8014a32:	2d66      	cmp	r5, #102	; 0x66
 8014a34:	f000 811c 	beq.w	8014c70 <cblas_cher+0x2b4>
      }

      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8014a38:	4a96      	ldr	r2, [pc, #600]	; (8014c94 <cblas_cher+0x2d8>)
 8014a3a:	4995      	ldr	r1, [pc, #596]	; (8014c90 <cblas_cher+0x2d4>)
 8014a3c:	2000      	movs	r0, #0
#define BASE float
#include "source_her.h"
#undef BASE
}
 8014a3e:	b005      	add	sp, #20
 8014a40:	ecbd 8b02 	vpop	{d8}
 8014a44:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014a48:	f013 be5e 	b.w	8028708 <cblas_xerbla>
 8014a4c:	b005      	add	sp, #20
 8014a4e:	ecbd 8b02 	vpop	{d8}
 8014a52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8014a56:	2a00      	cmp	r2, #0
 8014a58:	dbd8      	blt.n	8014a0c <cblas_cher+0x50>
 8014a5a:	f1b9 0f00 	cmp.w	r9, #0
 8014a5e:	d0cc      	beq.n	80149fa <cblas_cher+0x3e>
 8014a60:	2a01      	cmp	r2, #1
 8014a62:	4613      	mov	r3, r2
 8014a64:	bfb8      	it	lt
 8014a66:	2301      	movlt	r3, #1
 8014a68:	4553      	cmp	r3, sl
 8014a6a:	f300 810c 	bgt.w	8014c86 <cblas_cher+0x2ca>
 8014a6e:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8014a72:	2b01      	cmp	r3, #1
 8014a74:	bf88      	it	hi
 8014a76:	2001      	movhi	r0, #1
 8014a78:	d9d4      	bls.n	8014a24 <cblas_cher+0x68>
 8014a7a:	e7cf      	b.n	8014a1c <cblas_cher+0x60>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014a7c:	2e79      	cmp	r6, #121	; 0x79
 8014a7e:	f000 808f 	beq.w	8014ba0 <cblas_cher+0x1e4>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8014a82:	2e7a      	cmp	r6, #122	; 0x7a
 8014a84:	d1d8      	bne.n	8014a38 <cblas_cher+0x7c>
    INDEX ix = OFFSET(N, incX);
 8014a86:	f1b9 0f00 	cmp.w	r9, #0
 8014a8a:	bfda      	itte	le
 8014a8c:	f1c7 0c01 	rsble	ip, r7, #1
 8014a90:	fb0c fc09 	mulle.w	ip, ip, r9
 8014a94:	f04f 0c00 	movgt.w	ip, #0
    for (i = 0; i < N; i++) {
 8014a98:	2f00      	cmp	r7, #0
 8014a9a:	ddd7      	ble.n	8014a4c <cblas_cher+0x90>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014a9c:	ee07 4a90 	vmov	s15, r4
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014aa0:	eb08 03cc 	add.w	r3, r8, ip, lsl #3
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014aa4:	eef8 3ae7 	vcvt.f32.s32	s7, s15
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014aa8:	edd3 6a00 	vldr	s13, [r3]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014aac:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014ab0:	9301      	str	r3, [sp, #4]
 8014ab2:	4263      	negs	r3, r4
 8014ab4:	ee04 3a10 	vmov	s8, r3
 8014ab8:	9a00      	ldr	r2, [sp, #0]
        IMAG(A, lda * i + i) = 0;
 8014aba:	ed9f 3a77 	vldr	s6, [pc, #476]	; 8014c98 <cblas_cher+0x2dc>
 8014abe:	f8cd a00c 	str.w	sl, [sp, #12]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014ac2:	ee63 3a88 	vmul.f32	s7, s7, s16
 8014ac6:	f10a 0501 	add.w	r5, sl, #1
 8014aca:	00e9      	lsls	r1, r5, #3
 8014acc:	1d13      	adds	r3, r2, #4
 8014ace:	ee27 5aa3 	vmul.f32	s10, s15, s7
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014ad2:	ee66 4a88 	vmul.f32	s9, s13, s16
      for (j = 0; j < i; j++) {
 8014ad6:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014ada:	46d6      	mov	lr, sl
 8014adc:	9302      	str	r3, [sp, #8]
 8014ade:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
 8014ae2:	ea4f 06c9 	mov.w	r6, r9, lsl #3
    for (i = 0; i < N; i++) {
 8014ae6:	f04f 0b00 	mov.w	fp, #0
 8014aea:	468a      	mov	sl, r1
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8014aec:	ee64 7a27 	vmul.f32	s15, s8, s15
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014af0:	ed13 7a01 	vldr	s14, [r3, #-4]
        IMAG(A, lda * i + i) = 0;
 8014af4:	ed83 3a00 	vstr	s6, [r3]
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014af8:	ee25 5a67 	vnmul.f32	s10, s10, s15
    for (i = 0; i < N; i++) {
 8014afc:	f10b 0b01 	add.w	fp, fp, #1
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014b00:	eea4 5aa6 	vfma.f32	s10, s9, s13
    for (i = 0; i < N; i++) {
 8014b04:	455f      	cmp	r7, fp
      ix += incX;
 8014b06:	44cc      	add	ip, r9
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014b08:	ee37 5a05 	vadd.f32	s10, s14, s10
 8014b0c:	ed03 5a01 	vstr	s10, [r3, #-4]
    for (i = 0; i < N; i++) {
 8014b10:	d09c      	beq.n	8014a4c <cblas_cher+0x90>
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014b12:	eb08 02cc 	add.w	r2, r8, ip, lsl #3
 8014b16:	edd2 4a00 	vldr	s9, [r2]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014b1a:	ed92 5a01 	vldr	s10, [r2, #4]
 8014b1e:	9902      	ldr	r1, [sp, #8]
 8014b20:	9a00      	ldr	r2, [sp, #0]
 8014b22:	eb01 00ce 	add.w	r0, r1, lr, lsl #3
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014b26:	ee68 4a24 	vmul.f32	s9, s16, s9
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014b2a:	ee23 5a85 	vmul.f32	s10, s7, s10
 8014b2e:	9901      	ldr	r1, [sp, #4]
 8014b30:	ea4f 04cc 	mov.w	r4, ip, lsl #3
 8014b34:	eb02 02ce 	add.w	r2, r2, lr, lsl #3
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8014b38:	edd1 7a01 	vldr	s15, [r1, #4]
        const BASE X_real = CONST_REAL(X, jx);
 8014b3c:	edd1 5a00 	vldr	s11, [r1]
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014b40:	ed50 6a01 	vldr	s13, [r0, #-4]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8014b44:	ee64 7a27 	vmul.f32	s15, s8, s15
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014b48:	ee25 7a25 	vmul.f32	s14, s10, s11
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014b4c:	ee27 6ac5 	vnmul.f32	s12, s15, s10
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014b50:	eea4 7aa7 	vfma.f32	s14, s9, s15
 8014b54:	3208      	adds	r2, #8
 8014b56:	4431      	add	r1, r6
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014b58:	eef0 7a46 	vmov.f32	s15, s12
 8014b5c:	eee4 7aa5 	vfma.f32	s15, s9, s11
 8014b60:	3008      	adds	r0, #8
 8014b62:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8014b66:	ed40 7a03 	vstr	s15, [r0, #-12]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014b6a:	ed52 7a01 	vldr	s15, [r2, #-4]
 8014b6e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8014b72:	ed42 7a01 	vstr	s15, [r2, #-4]
      for (j = 0; j < i; j++) {
 8014b76:	4295      	cmp	r5, r2
 8014b78:	d1de      	bne.n	8014b38 <cblas_cher+0x17c>
 8014b7a:	9a03      	ldr	r2, [sp, #12]
 8014b7c:	4444      	add	r4, r8
 8014b7e:	edd4 7a01 	vldr	s15, [r4, #4]
 8014b82:	edd4 6a00 	vldr	s13, [r4]
 8014b86:	4496      	add	lr, r2
 8014b88:	4455      	add	r5, sl
 8014b8a:	4453      	add	r3, sl
 8014b8c:	e7ae      	b.n	8014aec <cblas_cher+0x130>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8014b8e:	2a01      	cmp	r2, #1
 8014b90:	4610      	mov	r0, r2
 8014b92:	bfb8      	it	lt
 8014b94:	2001      	movlt	r0, #1
 8014b96:	4582      	cmp	sl, r0
 8014b98:	bfb4      	ite	lt
 8014b9a:	2008      	movlt	r0, #8
 8014b9c:	2002      	movge	r0, #2
 8014b9e:	e73d      	b.n	8014a1c <cblas_cher+0x60>
    INDEX ix = OFFSET(N, incX);
 8014ba0:	f1b9 0f00 	cmp.w	r9, #0
 8014ba4:	dd6a      	ble.n	8014c7c <cblas_cher+0x2c0>
 8014ba6:	2600      	movs	r6, #0
    for (i = 0; i < N; i++) {
 8014ba8:	2f00      	cmp	r7, #0
 8014baa:	f77f af4f 	ble.w	8014a4c <cblas_cher+0x90>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014bae:	ee07 4a90 	vmov	s15, r4
 8014bb2:	4264      	negs	r4, r4
 8014bb4:	eeb8 3ae7 	vcvt.f32.s32	s6, s15
 8014bb8:	9b00      	ldr	r3, [sp, #0]
 8014bba:	ee07 4a90 	vmov	s15, r4
 8014bbe:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8014bc2:	f1a3 0108 	sub.w	r1, r3, #8
 8014bc6:	eb08 05c6 	add.w	r5, r8, r6, lsl #3
 8014bca:	ee23 3a08 	vmul.f32	s6, s6, s16
 8014bce:	eef8 3ae7 	vcvt.f32.s32	s7, s15
        IMAG(A, lda * i + i) = 0;
 8014bd2:	f04f 0b00 	mov.w	fp, #0
 8014bd6:	f10a 0c08 	add.w	ip, sl, #8
 8014bda:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
 8014bde:	1d1c      	adds	r4, r3, #4
 8014be0:	3504      	adds	r5, #4
 8014be2:	ea4f 00c9 	mov.w	r0, r9, lsl #3
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014be6:	f04f 0e00 	mov.w	lr, #0
 8014bea:	edd5 7a00 	vldr	s15, [r5]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014bee:	ed55 6a01 	vldr	s13, [r5, #-4]
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014bf2:	ed14 7a01 	vldr	s14, [r4, #-4]
        IMAG(A, lda * i + i) = 0;
 8014bf6:	f8c4 b000 	str.w	fp, [r4]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8014bfa:	ee23 4a27 	vmul.f32	s8, s6, s15
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8014bfe:	ee67 7aa3 	vmul.f32	s15, s15, s7
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8014c02:	ee66 4a88 	vmul.f32	s9, s13, s16
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014c06:	ee64 7a67 	vnmul.f32	s15, s8, s15
      for (j = i + 1; j < N; j++) {
 8014c0a:	f10e 0e01 	add.w	lr, lr, #1
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014c0e:	eee6 7aa4 	vfma.f32	s15, s13, s9
      for (j = i + 1; j < N; j++) {
 8014c12:	4577      	cmp	r7, lr
        jx += incX;
 8014c14:	444e      	add	r6, r9
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8014c16:	ee77 7a27 	vadd.f32	s15, s14, s15
 8014c1a:	ed44 7a01 	vstr	s15, [r4, #-4]
      for (j = i + 1; j < N; j++) {
 8014c1e:	f43f af15 	beq.w	8014a4c <cblas_cher+0x90>
 8014c22:	eb08 02c6 	add.w	r2, r8, r6, lsl #3
 8014c26:	1f23      	subs	r3, r4, #4
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8014c28:	edd2 7a01 	vldr	s15, [r2, #4]
        const BASE X_real = CONST_REAL(X, jx);
 8014c2c:	ed92 5a00 	vldr	s10, [r2]
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014c30:	ed93 7a02 	vldr	s14, [r3, #8]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014c34:	ed93 6a03 	vldr	s12, [r3, #12]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8014c38:	ee63 7aa7 	vmul.f32	s15, s7, s15
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014c3c:	ee64 6a05 	vmul.f32	s13, s8, s10
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014c40:	ee67 5ac4 	vnmul.f32	s11, s15, s8
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014c44:	eee4 6aa7 	vfma.f32	s13, s9, s15
 8014c48:	3308      	adds	r3, #8
 8014c4a:	4402      	add	r2, r0
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014c4c:	eef0 7a65 	vmov.f32	s15, s11
 8014c50:	eee4 7a85 	vfma.f32	s15, s9, s10
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014c54:	ee76 6a26 	vadd.f32	s13, s12, s13
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014c58:	ee77 7a27 	vadd.f32	s15, s14, s15
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8014c5c:	edc3 6a01 	vstr	s13, [r3, #4]
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8014c60:	edc3 7a00 	vstr	s15, [r3]
      for (j = i + 1; j < N; j++) {
 8014c64:	4299      	cmp	r1, r3
 8014c66:	d1df      	bne.n	8014c28 <cblas_cher+0x26c>
 8014c68:	4451      	add	r1, sl
 8014c6a:	4405      	add	r5, r0
 8014c6c:	4464      	add	r4, ip
 8014c6e:	e7bc      	b.n	8014bea <cblas_cher+0x22e>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8014c70:	2e7a      	cmp	r6, #122	; 0x7a
 8014c72:	d095      	beq.n	8014ba0 <cblas_cher+0x1e4>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 8014c74:	2e79      	cmp	r6, #121	; 0x79
 8014c76:	f47f aedf 	bne.w	8014a38 <cblas_cher+0x7c>
 8014c7a:	e704      	b.n	8014a86 <cblas_cher+0xca>
    INDEX ix = OFFSET(N, incX);
 8014c7c:	f1c7 0601 	rsb	r6, r7, #1
 8014c80:	fb06 f609 	mul.w	r6, r6, r9
 8014c84:	e790      	b.n	8014ba8 <cblas_cher+0x1ec>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8014c86:	2008      	movs	r0, #8
 8014c88:	e6c8      	b.n	8014a1c <cblas_cher+0x60>
 8014c8a:	bf00      	nop
 8014c8c:	08031108 	.word	0x08031108
 8014c90:	08031320 	.word	0x08031320
 8014c94:	080311b8 	.word	0x080311b8
 8014c98:	00000000 	.word	0x00000000

08014c9c <cblas_cher2>:

void
cblas_cher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *X, const int incX,
             const void *Y, const int incY, void *A, const int lda)
{
 8014c9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014ca0:	ed2d 8b04 	vpush	{d8-d9}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i, j;
  const int conj = (order == CblasColMajor) ? -1 : 1;
 8014ca4:	2866      	cmp	r0, #102	; 0x66
 8014ca6:	b087      	sub	sp, #28
 8014ca8:	469a      	mov	sl, r3
 8014caa:	bf0c      	ite	eq
 8014cac:	f04f 33ff 	moveq.w	r3, #4294967295
 8014cb0:	2301      	movne	r3, #1
 8014cb2:	ee08 3a10 	vmov	s16, r3
 8014cb6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8014cb8:	9305      	str	r3, [sp, #20]
 8014cba:	e9dd 5315 	ldrd	r5, r3, [sp, #84]	; 0x54
 8014cbe:	9302      	str	r3, [sp, #8]
 8014cc0:	e9dd 4317 	ldrd	r4, r3, [sp, #92]	; 0x5c
 8014cc4:	4689      	mov	r9, r1

  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 8014cc6:	3979      	subs	r1, #121	; 0x79
 8014cc8:	2901      	cmp	r1, #1
 8014cca:	9f19      	ldr	r7, [sp, #100]	; 0x64
 8014ccc:	9200      	str	r2, [sp, #0]
 8014cce:	4606      	mov	r6, r0
 8014cd0:	9301      	str	r3, [sp, #4]
 8014cd2:	f240 80f8 	bls.w	8014ec6 <cblas_cher2+0x22a>
 8014cd6:	2002      	movs	r0, #2
 8014cd8:	9b00      	ldr	r3, [sp, #0]
 8014cda:	2b00      	cmp	r3, #0
 8014cdc:	f2c0 80e8 	blt.w	8014eb0 <cblas_cher2+0x214>
 8014ce0:	2d00      	cmp	r5, #0
 8014ce2:	f040 80ce 	bne.w	8014e82 <cblas_cher2+0x1e6>
 8014ce6:	2c00      	cmp	r4, #0
 8014ce8:	f040 80d9 	bne.w	8014e9e <cblas_cher2+0x202>
 8014cec:	9800      	ldr	r0, [sp, #0]
 8014cee:	2801      	cmp	r0, #1
 8014cf0:	bfb8      	it	lt
 8014cf2:	2001      	movlt	r0, #1
 8014cf4:	4287      	cmp	r7, r0
 8014cf6:	bfb4      	ite	lt
 8014cf8:	200a      	movlt	r0, #10
 8014cfa:	2008      	movge	r0, #8
 8014cfc:	4acc      	ldr	r2, [pc, #816]	; (8015030 <cblas_cher2+0x394>)
 8014cfe:	49cd      	ldr	r1, [pc, #820]	; (8015034 <cblas_cher2+0x398>)
 8014d00:	f013 fd02 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8014d04:	edda 4a00 	vldr	s9, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8014d08:	ed9a 4a01 	vldr	s8, [sl, #4]

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8014d0c:	eef5 4a40 	vcmp.f32	s9, #0.0
 8014d10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d14:	d105      	bne.n	8014d22 <cblas_cher2+0x86>
 8014d16:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8014d1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d1e:	f000 80ab 	beq.w	8014e78 <cblas_cher2+0x1dc>
      return;

    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014d22:	2e65      	cmp	r6, #101	; 0x65
 8014d24:	f000 80d5 	beq.w	8014ed2 <cblas_cher2+0x236>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8014d28:	2e66      	cmp	r6, #102	; 0x66
 8014d2a:	d009      	beq.n	8014d40 <cblas_cher2+0xa4>

        ix += incX;
        iy += incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 8014d2c:	4ac2      	ldr	r2, [pc, #776]	; (8015038 <cblas_cher2+0x39c>)
 8014d2e:	49c1      	ldr	r1, [pc, #772]	; (8015034 <cblas_cher2+0x398>)
 8014d30:	2000      	movs	r0, #0
#define BASE float
#include "source_her2.h"
#undef BASE
}
 8014d32:	b007      	add	sp, #28
 8014d34:	ecbd 8b04 	vpop	{d8-d9}
 8014d38:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014d3c:	f013 bce4 	b.w	8028708 <cblas_xerbla>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8014d40:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8014d44:	f000 80cd 	beq.w	8014ee2 <cblas_cher2+0x246>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 8014d48:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8014d4c:	d1ee      	bne.n	8014d2c <cblas_cher2+0x90>
      INDEX ix = OFFSET(N, incX);
 8014d4e:	2d00      	cmp	r5, #0
 8014d50:	bfdd      	ittte	le
 8014d52:	9b00      	ldrle	r3, [sp, #0]
 8014d54:	f1c3 0101 	rsble	r1, r3, #1
 8014d58:	4369      	mulle	r1, r5
 8014d5a:	2100      	movgt	r1, #0
      INDEX iy = OFFSET(N, incY);
 8014d5c:	2c00      	cmp	r4, #0
 8014d5e:	bfdc      	itt	le
 8014d60:	9b00      	ldrle	r3, [sp, #0]
 8014d62:	f1c3 0201 	rsble	r2, r3, #1
      for (i = 0; i < N; i++) {
 8014d66:	9b00      	ldr	r3, [sp, #0]
      INDEX iy = OFFSET(N, incY);
 8014d68:	bfd4      	ite	le
 8014d6a:	4362      	mulle	r2, r4
 8014d6c:	2200      	movgt	r2, #0
      for (i = 0; i < N; i++) {
 8014d6e:	2b00      	cmp	r3, #0
 8014d70:	f340 8082 	ble.w	8014e78 <cblas_cher2+0x1dc>
 8014d74:	9b05      	ldr	r3, [sp, #20]
        IMAG(A, lda * i + i) = 0;
 8014d76:	ed9f 0ab1 	vldr	s0, [pc, #708]	; 801503c <cblas_cher2+0x3a0>
 8014d7a:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8014d7e:	9902      	ldr	r1, [sp, #8]
 8014d80:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8014d84:	9202      	str	r2, [sp, #8]
      for (i = 0; i < N; i++) {
 8014d86:	4692      	mov	sl, r2
 8014d88:	9a01      	ldr	r2, [sp, #4]
 8014d8a:	4699      	mov	r9, r3
 8014d8c:	f107 0b01 	add.w	fp, r7, #1
 8014d90:	f04f 0800 	mov.w	r8, #0
 8014d94:	4694      	mov	ip, r2
 8014d96:	3204      	adds	r2, #4
 8014d98:	00ed      	lsls	r5, r5, #3
 8014d9a:	00e4      	lsls	r4, r4, #3
 8014d9c:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
 8014da0:	eef1 0a44 	vneg.f32	s1, s8
 8014da4:	9203      	str	r2, [sp, #12]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014da6:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
 8014daa:	4643      	mov	r3, r8
 8014dac:	46ce      	mov	lr, r9
        const BASE Xi_imag = CONST_IMAG(X, ix);
 8014dae:	ed99 5a01 	vldr	s10, [r9, #4]
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 8014db2:	ed9a 9a01 	vldr	s18, [sl, #4]
        const BASE Xi_real = CONST_REAL(X, ix);
 8014db6:	edd9 7a00 	vldr	s15, [r9]
        const BASE Yi_real = CONST_REAL(Y, iy);
 8014dba:	edda 8a00 	vldr	s17, [sl]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 8014dbe:	ee65 2a44 	vnmul.f32	s5, s10, s8
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 8014dc2:	ee24 2a09 	vmul.f32	s4, s8, s18
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014dc6:	ee24 5a85 	vmul.f32	s10, s9, s10
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 8014dca:	ee64 1a89 	vmul.f32	s3, s9, s18
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 8014dce:	eee4 2aa7 	vfma.f32	s5, s9, s15
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014dd2:	eea4 5a27 	vfma.f32	s10, s8, s15
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 8014dd6:	eea4 2aa8 	vfma.f32	s4, s9, s17
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 8014dda:	eee8 1aa0 	vfma.f32	s3, s17, s1
        for (j = 0; j < i; j++) {
 8014dde:	b3bb      	cbz	r3, 8014e50 <cblas_cher2+0x1b4>
 8014de0:	9903      	ldr	r1, [sp, #12]
 8014de2:	9a01      	ldr	r2, [sp, #4]
 8014de4:	9802      	ldr	r0, [sp, #8]
 8014de6:	eef8 9ac8 	vcvt.f32.s32	s19, s16
 8014dea:	eb01 06c8 	add.w	r6, r1, r8, lsl #3
 8014dee:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8014df2:	4671      	mov	r1, lr
          const BASE Xj_imag = CONST_IMAG(X, jx);
 8014df4:	ed91 7a01 	vldr	s14, [r1, #4]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 8014df8:	edd0 7a01 	vldr	s15, [r0, #4]
          const BASE Xj_real = CONST_REAL(X, jx);
 8014dfc:	ed91 3a00 	vldr	s6, [r1]
          const BASE Yj_real = CONST_REAL(Y, jy);
 8014e00:	edd0 3a00 	vldr	s7, [r0]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014e04:	ed16 6a01 	vldr	s12, [r6, #-4]
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014e08:	ee61 5a87 	vmul.f32	s11, s3, s14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014e0c:	ee65 6a27 	vmul.f32	s13, s10, s15
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014e10:	eee2 5a03 	vfma.f32	s11, s4, s6
 8014e14:	3208      	adds	r2, #8
 8014e16:	4429      	add	r1, r5
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014e18:	eee2 6aa3 	vfma.f32	s13, s5, s7
 8014e1c:	4420      	add	r0, r4
 8014e1e:	3608      	adds	r6, #8
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014e20:	ee27 7a42 	vnmul.f32	s14, s14, s4
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014e24:	ee67 7ae2 	vnmul.f32	s15, s15, s5
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014e28:	ee76 6aa5 	vadd.f32	s13, s13, s11
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014e2c:	eea1 7a83 	vfma.f32	s14, s3, s6
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014e30:	eee5 7a23 	vfma.f32	s15, s10, s7
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014e34:	ee76 6a26 	vadd.f32	s13, s12, s13
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014e38:	ee77 7a87 	vadd.f32	s15, s15, s14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014e3c:	ed46 6a03 	vstr	s13, [r6, #-12]
          IMAG(A, lda * i + j) +=
 8014e40:	ed12 7a01 	vldr	s14, [r2, #-4]
 8014e44:	eea7 7aa9 	vfma.f32	s14, s15, s19
 8014e48:	ed02 7a01 	vstr	s14, [r2, #-4]
        for (j = 0; j < i; j++) {
 8014e4c:	4594      	cmp	ip, r2
 8014e4e:	d1d1      	bne.n	8014df4 <cblas_cher2+0x158>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014e50:	ee25 5a09 	vmul.f32	s10, s10, s18
 8014e54:	eddc 7a00 	vldr	s15, [ip]
      for (i = 0; i < N; i++) {
 8014e58:	9a00      	ldr	r2, [sp, #0]
        IMAG(A, lda * i + i) = 0;
 8014e5a:	ed8c 0a01 	vstr	s0, [ip, #4]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014e5e:	eea2 5aa8 	vfma.f32	s10, s5, s17
      for (i = 0; i < N; i++) {
 8014e62:	3301      	adds	r3, #1
 8014e64:	429a      	cmp	r2, r3
 8014e66:	44a9      	add	r9, r5
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014e68:	eee5 7a01 	vfma.f32	s15, s10, s2
 8014e6c:	44a2      	add	sl, r4
 8014e6e:	44b8      	add	r8, r7
 8014e70:	edcc 7a00 	vstr	s15, [ip]
      for (i = 0; i < N; i++) {
 8014e74:	44dc      	add	ip, fp
 8014e76:	d19a      	bne.n	8014dae <cblas_cher2+0x112>
 8014e78:	b007      	add	sp, #28
 8014e7a:	ecbd 8b04 	vpop	{d8-d9}
 8014e7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 8014e82:	2c00      	cmp	r4, #0
 8014e84:	f43f af32 	beq.w	8014cec <cblas_cher2+0x50>
 8014e88:	9a00      	ldr	r2, [sp, #0]
 8014e8a:	2a01      	cmp	r2, #1
 8014e8c:	bfb8      	it	lt
 8014e8e:	2201      	movlt	r2, #1
 8014e90:	42ba      	cmp	r2, r7
 8014e92:	f300 80cb 	bgt.w	801502c <cblas_cher2+0x390>
 8014e96:	2800      	cmp	r0, #0
 8014e98:	f43f af34 	beq.w	8014d04 <cblas_cher2+0x68>
 8014e9c:	e72e      	b.n	8014cfc <cblas_cher2+0x60>
 8014e9e:	9800      	ldr	r0, [sp, #0]
 8014ea0:	2801      	cmp	r0, #1
 8014ea2:	bfb8      	it	lt
 8014ea4:	2001      	movlt	r0, #1
 8014ea6:	4287      	cmp	r7, r0
 8014ea8:	bfb4      	ite	lt
 8014eaa:	200a      	movlt	r0, #10
 8014eac:	2006      	movge	r0, #6
 8014eae:	e725      	b.n	8014cfc <cblas_cher2+0x60>
 8014eb0:	2d00      	cmp	r5, #0
 8014eb2:	f43f af18 	beq.w	8014ce6 <cblas_cher2+0x4a>
 8014eb6:	2c00      	cmp	r4, #0
 8014eb8:	f43f af18 	beq.w	8014cec <cblas_cher2+0x50>
 8014ebc:	2f00      	cmp	r7, #0
 8014ebe:	bfd4      	ite	le
 8014ec0:	200a      	movle	r0, #10
 8014ec2:	2003      	movgt	r0, #3
 8014ec4:	e71a      	b.n	8014cfc <cblas_cher2+0x60>
 8014ec6:	3865      	subs	r0, #101	; 0x65
 8014ec8:	2801      	cmp	r0, #1
 8014eca:	bf94      	ite	ls
 8014ecc:	2000      	movls	r0, #0
 8014ece:	2001      	movhi	r0, #1
 8014ed0:	e702      	b.n	8014cd8 <cblas_cher2+0x3c>
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014ed2:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8014ed6:	d004      	beq.n	8014ee2 <cblas_cher2+0x246>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8014ed8:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8014edc:	f47f af26 	bne.w	8014d2c <cblas_cher2+0x90>
 8014ee0:	e735      	b.n	8014d4e <cblas_cher2+0xb2>
      INDEX ix = OFFSET(N, incX);
 8014ee2:	2d00      	cmp	r5, #0
 8014ee4:	bfdd      	ittte	le
 8014ee6:	9b00      	ldrle	r3, [sp, #0]
 8014ee8:	f1c3 0a01 	rsble	sl, r3, #1
 8014eec:	fb0a fa05 	mulle.w	sl, sl, r5
 8014ef0:	f04f 0a00 	movgt.w	sl, #0
      INDEX iy = OFFSET(N, incY);
 8014ef4:	2c00      	cmp	r4, #0
 8014ef6:	f340 8093 	ble.w	8015020 <cblas_cher2+0x384>
 8014efa:	f04f 0b00 	mov.w	fp, #0
      for (i = 0; i < N; i++) {
 8014efe:	9b00      	ldr	r3, [sp, #0]
 8014f00:	2b00      	cmp	r3, #0
 8014f02:	ddb9      	ble.n	8014e78 <cblas_cher2+0x1dc>
 8014f04:	00fb      	lsls	r3, r7, #3
 8014f06:	9a01      	ldr	r2, [sp, #4]
 8014f08:	9304      	str	r3, [sp, #16]
 8014f0a:	3308      	adds	r3, #8
 8014f0c:	9303      	str	r3, [sp, #12]
 8014f0e:	9b00      	ldr	r3, [sp, #0]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f10:	9501      	str	r5, [sp, #4]
 8014f12:	f1a2 0008 	sub.w	r0, r2, #8
 8014f16:	00ef      	lsls	r7, r5, #3
 8014f18:	00e6      	lsls	r6, r4, #3
 8014f1a:	9d02      	ldr	r5, [sp, #8]
        IMAG(A, lda * i + i) = 0;
 8014f1c:	eddf 8a47 	vldr	s17, [pc, #284]	; 801503c <cblas_cher2+0x3a0>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f20:	9402      	str	r4, [sp, #8]
 8014f22:	9c05      	ldr	r4, [sp, #20]
 8014f24:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 8014f28:	f102 0c04 	add.w	ip, r2, #4
 8014f2c:	eeb1 0a44 	vneg.f32	s0, s8
      for (i = 0; i < N; i++) {
 8014f30:	f04f 0800 	mov.w	r8, #0
 8014f34:	ea4f 09ca 	mov.w	r9, sl, lsl #3
 8014f38:	ea4f 0ecb 	mov.w	lr, fp, lsl #3
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f3c:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
        const BASE Xi_real = CONST_REAL(X, ix);
 8014f40:	44a1      	add	r9, r4
        const BASE Xi_imag = CONST_IMAG(X, ix);
 8014f42:	edd9 2a01 	vldr	s5, [r9, #4]
        const BASE Xi_real = CONST_REAL(X, ix);
 8014f46:	edd9 7a00 	vldr	s15, [r9]
        INDEX jx = ix + incX;
 8014f4a:	9b01      	ldr	r3, [sp, #4]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f4c:	ed1c 7a01 	vldr	s14, [ip, #-4]
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014f50:	ee24 9aa2 	vmul.f32	s18, s9, s5
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 8014f54:	ee62 2ac4 	vnmul.f32	s5, s5, s8
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014f58:	eea4 9a27 	vfma.f32	s18, s8, s15
 8014f5c:	44ae      	add	lr, r5
        INDEX jx = ix + incX;
 8014f5e:	449a      	add	sl, r3
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 8014f60:	ed9e 2a01 	vldr	s4, [lr, #4]
        INDEX jy = iy + incY;
 8014f64:	9b02      	ldr	r3, [sp, #8]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 8014f66:	eee4 2aa7 	vfma.f32	s5, s9, s15
        INDEX jy = iy + incY;
 8014f6a:	449b      	add	fp, r3
        for (j = i + 1; j < N; j++) {
 8014f6c:	9b00      	ldr	r3, [sp, #0]
        const BASE Yi_real = CONST_REAL(Y, iy);
 8014f6e:	edde 7a00 	vldr	s15, [lr]
        IMAG(A, lda * i + i) = 0;
 8014f72:	edcc 8a00 	vstr	s17, [ip]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f76:	ee69 6a02 	vmul.f32	s13, s18, s4
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 8014f7a:	ee64 1a02 	vmul.f32	s3, s8, s4
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f7e:	eee2 6aa7 	vfma.f32	s13, s5, s15
        for (j = i + 1; j < N; j++) {
 8014f82:	f108 0801 	add.w	r8, r8, #1
 8014f86:	4543      	cmp	r3, r8
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 8014f88:	ee24 2a82 	vmul.f32	s4, s9, s4
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f8c:	eea6 7aa0 	vfma.f32	s14, s13, s1
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 8014f90:	eee4 1aa7 	vfma.f32	s3, s9, s15
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 8014f94:	eea7 2a80 	vfma.f32	s4, s15, s0
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014f98:	ed0c 7a01 	vstr	s14, [ip, #-4]
        for (j = i + 1; j < N; j++) {
 8014f9c:	f43f af6c 	beq.w	8014e78 <cblas_cher2+0x1dc>
 8014fa0:	eeb8 1ac8 	vcvt.f32.s32	s2, s16
 8014fa4:	ea4f 09ca 	mov.w	r9, sl, lsl #3
 8014fa8:	eb04 01ca 	add.w	r1, r4, sl, lsl #3
 8014fac:	ea4f 0ecb 	mov.w	lr, fp, lsl #3
 8014fb0:	eb05 02cb 	add.w	r2, r5, fp, lsl #3
 8014fb4:	f1ac 0304 	sub.w	r3, ip, #4
          const BASE Xj_imag = CONST_IMAG(X, jx);
 8014fb8:	ed91 7a01 	vldr	s14, [r1, #4]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 8014fbc:	edd2 7a01 	vldr	s15, [r2, #4]
          const BASE Xj_real = CONST_REAL(X, jx);
 8014fc0:	ed91 3a00 	vldr	s6, [r1]
          const BASE Yj_real = CONST_REAL(Y, jy);
 8014fc4:	edd2 3a00 	vldr	s7, [r2]
          IMAG(A, lda * i + j) +=
 8014fc8:	edd3 5a03 	vldr	s11, [r3, #12]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014fcc:	ed93 6a02 	vldr	s12, [r3, #8]
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014fd0:	ee27 5a61 	vnmul.f32	s10, s14, s3
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014fd4:	ee67 6ae2 	vnmul.f32	s13, s15, s5
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014fd8:	ee22 7a07 	vmul.f32	s14, s4, s14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014fdc:	ee69 7a27 	vmul.f32	s15, s18, s15
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014fe0:	eea2 5a03 	vfma.f32	s10, s4, s6
 8014fe4:	3308      	adds	r3, #8
 8014fe6:	4439      	add	r1, r7
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014fe8:	eee9 6a23 	vfma.f32	s13, s18, s7
 8014fec:	4432      	add	r2, r6
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014fee:	eea1 7a83 	vfma.f32	s14, s3, s6
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014ff2:	eee2 7aa3 	vfma.f32	s15, s5, s7
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014ff6:	ee76 6a85 	vadd.f32	s13, s13, s10
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014ffa:	ee77 7a87 	vadd.f32	s15, s15, s14
          IMAG(A, lda * i + j) +=
 8014ffe:	eeb0 7a65 	vmov.f32	s14, s11
 8015002:	eea6 7a81 	vfma.f32	s14, s13, s2
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8015006:	ee76 7a27 	vadd.f32	s15, s12, s15
          IMAG(A, lda * i + j) +=
 801500a:	ed83 7a01 	vstr	s14, [r3, #4]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801500e:	edc3 7a00 	vstr	s15, [r3]
        for (j = i + 1; j < N; j++) {
 8015012:	4298      	cmp	r0, r3
 8015014:	d1d0      	bne.n	8014fb8 <cblas_cher2+0x31c>
 8015016:	9b04      	ldr	r3, [sp, #16]
 8015018:	4418      	add	r0, r3
 801501a:	9b03      	ldr	r3, [sp, #12]
 801501c:	449c      	add	ip, r3
 801501e:	e78f      	b.n	8014f40 <cblas_cher2+0x2a4>
      INDEX iy = OFFSET(N, incY);
 8015020:	9b00      	ldr	r3, [sp, #0]
 8015022:	f1c3 0b01 	rsb	fp, r3, #1
 8015026:	fb0b fb04 	mul.w	fp, fp, r4
 801502a:	e768      	b.n	8014efe <cblas_cher2+0x262>
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801502c:	200a      	movs	r0, #10
 801502e:	e665      	b.n	8014cfc <cblas_cher2+0x60>
 8015030:	08031108 	.word	0x08031108
 8015034:	08031330 	.word	0x08031330
 8015038:	080311b8 	.word	0x080311b8
 801503c:	00000000 	.word	0x00000000

08015040 <cblas_cher2k>:
void
cblas_cher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const float beta, void *C, const int ldc)
{
 8015040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015044:	ed2d 8b02 	vpush	{d8}
 8015048:	b08f      	sub	sp, #60	; 0x3c
 801504a:	461e      	mov	r6, r3
 801504c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801504e:	9303      	str	r3, [sp, #12]
 8015050:	e9dd 831b 	ldrd	r8, r3, [sp, #108]	; 0x6c
 8015054:	9301      	str	r3, [sp, #4]
 8015056:	e9dd b31d 	ldrd	fp, r3, [sp, #116]	; 0x74
 801505a:	9300      	str	r3, [sp, #0]
 801505c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801505e:	9304      	str	r3, [sp, #16]

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015060:	2865      	cmp	r0, #101	; 0x65
 8015062:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8015064:	f8dd a084 	ldr.w	sl, [sp, #132]	; 0x84
 8015068:	9302      	str	r3, [sp, #8]
 801506a:	4607      	mov	r7, r0
 801506c:	460d      	mov	r5, r1
 801506e:	4614      	mov	r4, r2
 8015070:	eeb0 8a40 	vmov.f32	s16, s0
 8015074:	f000 824c 	beq.w	8015510 <cblas_cher2k+0x4d0>
 8015078:	2a6f      	cmp	r2, #111	; 0x6f
 801507a:	f000 8090 	beq.w	801519e <cblas_cher2k+0x15e>
 801507e:	9b03      	ldr	r3, [sp, #12]
 8015080:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 8015084:	2a01      	cmp	r2, #1
 8015086:	f240 81fa 	bls.w	801547e <cblas_cher2k+0x43e>
 801508a:	2002      	movs	r0, #2
 801508c:	f1a4 026f 	sub.w	r2, r4, #111	; 0x6f
 8015090:	2a02      	cmp	r2, #2
 8015092:	bf88      	it	hi
 8015094:	2003      	movhi	r0, #3
 8015096:	9a03      	ldr	r2, [sp, #12]
 8015098:	2e00      	cmp	r6, #0
 801509a:	bfb8      	it	lt
 801509c:	2004      	movlt	r0, #4
 801509e:	2a00      	cmp	r2, #0
 80150a0:	bfb8      	it	lt
 80150a2:	2005      	movlt	r0, #5
 80150a4:	2b01      	cmp	r3, #1
 80150a6:	bfb8      	it	lt
 80150a8:	2301      	movlt	r3, #1
 80150aa:	455b      	cmp	r3, fp
 80150ac:	9a04      	ldr	r2, [sp, #16]
 80150ae:	f340 81d1 	ble.w	8015454 <cblas_cher2k+0x414>
 80150b2:	4293      	cmp	r3, r2
 80150b4:	f300 81da 	bgt.w	801546c <cblas_cher2k+0x42c>
 80150b8:	2e01      	cmp	r6, #1
 80150ba:	4630      	mov	r0, r6
 80150bc:	bfb8      	it	lt
 80150be:	2001      	movlt	r0, #1
 80150c0:	4550      	cmp	r0, sl
 80150c2:	bfcc      	ite	gt
 80150c4:	200e      	movgt	r0, #14
 80150c6:	2008      	movle	r0, #8
 80150c8:	4ade      	ldr	r2, [pc, #888]	; (8015444 <cblas_cher2k+0x404>)
 80150ca:	49df      	ldr	r1, [pc, #892]	; (8015448 <cblas_cher2k+0x408>)
 80150cc:	f013 fb1c 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
    BASE alpha_imag = CONST_IMAG0(alpha);

    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 80150d0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80150d4:	eeb4 8a67 	vcmp.f32	s16, s15
 80150d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    const BASE alpha_real = CONST_REAL0(alpha);
 80150dc:	edd8 6a00 	vldr	s13, [r8]
    BASE alpha_imag = CONST_IMAG0(alpha);
 80150e0:	ed98 7a01 	vldr	s14, [r8, #4]
    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 80150e4:	d10e      	bne.n	8015104 <cblas_cher2k+0xc4>
 80150e6:	eef5 6a40 	vcmp.f32	s13, #0.0
 80150ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80150ee:	d105      	bne.n	80150fc <cblas_cher2k+0xbc>
 80150f0:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80150f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80150f8:	f000 819f 	beq.w	801543a <cblas_cher2k+0x3fa>
 80150fc:	9b03      	ldr	r3, [sp, #12]
 80150fe:	2b00      	cmp	r3, #0
 8015100:	f000 819b 	beq.w	801543a <cblas_cher2k+0x3fa>
      return;

    if (Order == CblasRowMajor) {
 8015104:	2f65      	cmp	r7, #101	; 0x65
 8015106:	f000 8208 	beq.w	801551a <cblas_cher2k+0x4da>
      uplo = Uplo;
      trans = Trans;
    } else {
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801510a:	2d79      	cmp	r5, #121	; 0x79
 801510c:	bf0c      	ite	eq
 801510e:	f04f 0e7a 	moveq.w	lr, #122	; 0x7a
 8015112:	f04f 0e79 	movne.w	lr, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015116:	2c6f      	cmp	r4, #111	; 0x6f
      alpha_imag *= -1;           /* conjugate alpha */
 8015118:	eeb1 7a47 	vneg.f32	s14, s14
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801511c:	bf0c      	ite	eq
 801511e:	f04f 0871 	moveq.w	r8, #113	; 0x71
 8015122:	f04f 086f 	movne.w	r8, #111	; 0x6f
    }

    /* form  C := beta*C */

    if (beta == 0.0) {
 8015126:	eeb5 8a40 	vcmp.f32	s16, #0.0
 801512a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801512e:	f040 81ad 	bne.w	801548c <cblas_cher2k+0x44c>
      if (uplo == CblasUpper) {
 8015132:	f1be 0f79 	cmp.w	lr, #121	; 0x79
 8015136:	d03a      	beq.n	80151ae <cblas_cher2k+0x16e>
            REAL(C, ldc * i + j) = 0.0;
            IMAG(C, ldc * i + j) = 0.0;
          }
        }
      } else {
        for (i = 0; i < N; i++) {
 8015138:	2e00      	cmp	r6, #0
 801513a:	dd14      	ble.n	8015166 <cblas_cher2k+0x126>
 801513c:	9f02      	ldr	r7, [sp, #8]
 801513e:	f10a 0401 	add.w	r4, sl, #1
 8015142:	2100      	movs	r1, #0
          for (j = 0; j <= i; j++) {
            REAL(C, ldc * i + j) = 0.0;
 8015144:	2500      	movs	r5, #0
 8015146:	00e4      	lsls	r4, r4, #3
        for (i = 0; i < N; i++) {
 8015148:	4608      	mov	r0, r1
 801514a:	f107 0208 	add.w	r2, r7, #8
 801514e:	eb07 03c1 	add.w	r3, r7, r1, lsl #3
            REAL(C, ldc * i + j) = 0.0;
 8015152:	601d      	str	r5, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 8015154:	605d      	str	r5, [r3, #4]
          for (j = 0; j <= i; j++) {
 8015156:	3308      	adds	r3, #8
 8015158:	429a      	cmp	r2, r3
 801515a:	d1fa      	bne.n	8015152 <cblas_cher2k+0x112>
        for (i = 0; i < N; i++) {
 801515c:	3001      	adds	r0, #1
 801515e:	4286      	cmp	r6, r0
 8015160:	4451      	add	r1, sl
 8015162:	4422      	add	r2, r4
 8015164:	d1f3      	bne.n	801514e <cblas_cher2k+0x10e>
      for (i = 0; i < N; i++) {
        IMAG(C, ldc * i + i) = 0.0;
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8015166:	eef5 6a40 	vcmp.f32	s13, #0.0
 801516a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801516e:	d108      	bne.n	8015182 <cblas_cher2k+0x142>
 8015170:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8015174:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015178:	f000 815f 	beq.w	801543a <cblas_cher2k+0x3fa>
      return;

    if (uplo == CblasUpper && trans == CblasNoTrans) {
 801517c:	f1be 0f79 	cmp.w	lr, #121	; 0x79
 8015180:	d02f      	beq.n	80151e2 <cblas_cher2k+0x1a2>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
          }
        }
      }

    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8015182:	f1be 0f7a 	cmp.w	lr, #122	; 0x7a
 8015186:	f000 80b9 	beq.w	80152fc <cblas_cher2k+0x2bc>
            IMAG(C, i * lda + i) = 0.0;
          }
        }
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 801518a:	4ab0      	ldr	r2, [pc, #704]	; (801544c <cblas_cher2k+0x40c>)
 801518c:	49ae      	ldr	r1, [pc, #696]	; (8015448 <cblas_cher2k+0x408>)
 801518e:	2000      	movs	r0, #0
#define BASE float
#include "source_her2k.h"
#undef BASE
}
 8015190:	b00f      	add	sp, #60	; 0x3c
 8015192:	ecbd 8b02 	vpop	{d8}
 8015196:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801519a:	f013 bab5 	b.w	8028708 <cblas_xerbla>
 801519e:	4633      	mov	r3, r6
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80151a0:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 80151a4:	2a01      	cmp	r2, #1
 80151a6:	f240 816a 	bls.w	801547e <cblas_cher2k+0x43e>
 80151aa:	2002      	movs	r0, #2
 80151ac:	e773      	b.n	8015096 <cblas_cher2k+0x56>
        for (i = 0; i < N; i++) {
 80151ae:	2e00      	cmp	r6, #0
 80151b0:	dd12      	ble.n	80151d8 <cblas_cher2k+0x198>
 80151b2:	f10a 0401 	add.w	r4, sl, #1
 80151b6:	9802      	ldr	r0, [sp, #8]
            REAL(C, ldc * i + j) = 0.0;
 80151b8:	2500      	movs	r5, #0
 80151ba:	00e4      	lsls	r4, r4, #3
        for (i = 0; i < N; i++) {
 80151bc:	2100      	movs	r1, #0
 80151be:	4603      	mov	r3, r0
 80151c0:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 80151c2:	3201      	adds	r2, #1
 80151c4:	4296      	cmp	r6, r2
            REAL(C, ldc * i + j) = 0.0;
 80151c6:	601d      	str	r5, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 80151c8:	605d      	str	r5, [r3, #4]
          for (j = i; j < N; j++) {
 80151ca:	f103 0308 	add.w	r3, r3, #8
 80151ce:	dcf8      	bgt.n	80151c2 <cblas_cher2k+0x182>
        for (i = 0; i < N; i++) {
 80151d0:	3101      	adds	r1, #1
 80151d2:	428e      	cmp	r6, r1
 80151d4:	4420      	add	r0, r4
 80151d6:	d1f2      	bne.n	80151be <cblas_cher2k+0x17e>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80151d8:	eef5 6a40 	vcmp.f32	s13, #0.0
 80151dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80151e0:	d0c6      	beq.n	8015170 <cblas_cher2k+0x130>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 80151e2:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80151e6:	f000 81b1 	beq.w	801554c <cblas_cher2k+0x50c>
    } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 80151ea:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 80151ee:	d1cc      	bne.n	801518a <cblas_cher2k+0x14a>
      for (k = 0; k < K; k++) {
 80151f0:	9b03      	ldr	r3, [sp, #12]
 80151f2:	2b00      	cmp	r3, #0
 80151f4:	f340 8121 	ble.w	801543a <cblas_cher2k+0x3fa>
 80151f8:	9b01      	ldr	r3, [sp, #4]
            IMAG(C, i * lda + i) = 0.0;
 80151fa:	ed9f 8a95 	vldr	s16, [pc, #596]	; 8015450 <cblas_cher2k+0x410>
 80151fe:	f1a3 0008 	sub.w	r0, r3, #8
      for (k = 0; k < K; k++) {
 8015202:	f04f 0800 	mov.w	r8, #0
 8015206:	f10b 0e01 	add.w	lr, fp, #1
 801520a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801520e:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
 8015212:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 8015216:	46c2      	mov	sl, r8
 8015218:	46c1      	mov	r9, r8
 801521a:	9305      	str	r3, [sp, #20]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801521c:	eef0 8a00 	vmov.f32	s17, #0	; 0x40000000  2.0
        for (i = 0; i < N; i++) {
 8015220:	2e00      	cmp	r6, #0
 8015222:	f340 8268 	ble.w	80156f6 <cblas_cher2k+0x6b6>
 8015226:	9b01      	ldr	r3, [sp, #4]
 8015228:	eb03 07ca 	add.w	r7, r3, sl, lsl #3
 801522c:	9b00      	ldr	r3, [sp, #0]
 801522e:	eb03 05c8 	add.w	r5, r3, r8, lsl #3
 8015232:	9b02      	ldr	r3, [sp, #8]
 8015234:	f04f 0c00 	mov.w	ip, #0
 8015238:	1d1c      	adds	r4, r3, #4
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801523a:	edd7 5a00 	vldr	s11, [r7]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801523e:	ed97 5a01 	vldr	s10, [r7, #4]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8015242:	edd5 1a01 	vldr	s3, [r5, #4]
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8015246:	edd5 7a00 	vldr	s15, [r5]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801524a:	ed14 6a01 	vldr	s12, [r4, #-4]
            IMAG(C, i * lda + i) = 0.0;
 801524e:	ed84 8a00 	vstr	s16, [r4]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 8015252:	ee27 0a25 	vmul.f32	s0, s14, s11
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 8015256:	ee67 0a05 	vmul.f32	s1, s14, s10
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801525a:	eea5 0a66 	vfms.f32	s0, s10, s13
          for (j = i + 1; j < N; j++) {
 801525e:	f10c 0c01 	add.w	ip, ip, #1
 8015262:	4566      	cmp	r6, ip
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 8015264:	eee6 0aa5 	vfma.f32	s1, s13, s11
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8015268:	ee60 5a61 	vnmul.f32	s11, s0, s3
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801526c:	ee27 1a27 	vmul.f32	s2, s14, s15
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8015270:	eee7 5aa0 	vfma.f32	s11, s15, s1
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 8015274:	eea6 1aa1 	vfma.f32	s2, s13, s3
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8015278:	eea5 6aa8 	vfma.f32	s12, s11, s17
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801527c:	ee61 1ac7 	vnmul.f32	s3, s3, s14
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8015280:	ed04 6a01 	vstr	s12, [r4, #-4]
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8015284:	eee6 1aa7 	vfma.f32	s3, s13, s15
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 8015288:	eeb1 1a41 	vneg.f32	s2, s2
          for (j = i + 1; j < N; j++) {
 801528c:	f000 8233 	beq.w	80156f6 <cblas_cher2k+0x6b6>
 8015290:	1f23      	subs	r3, r4, #4
 8015292:	4629      	mov	r1, r5
 8015294:	463a      	mov	r2, r7
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 8015296:	edd2 2a02 	vldr	s5, [r2, #8]
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801529a:	ed92 2a03 	vldr	s4, [r2, #12]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801529e:	ed91 3a02 	vldr	s6, [r1, #8]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80152a2:	edd1 3a03 	vldr	s7, [r1, #12]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80152a6:	ed93 5a02 	vldr	s10, [r3, #8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80152aa:	edd3 5a03 	vldr	s11, [r3, #12]
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80152ae:	ee61 4a22 	vmul.f32	s9, s2, s5
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80152b2:	ee22 4a41 	vnmul.f32	s8, s4, s2
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80152b6:	ee23 6ac0 	vnmul.f32	s12, s7, s0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80152ba:	ee60 7a03 	vmul.f32	s15, s0, s6
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80152be:	eee1 4a82 	vfma.f32	s9, s3, s4
 80152c2:	3208      	adds	r2, #8
          for (j = i + 1; j < N; j++) {
 80152c4:	4290      	cmp	r0, r2
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80152c6:	eea1 4aa2 	vfma.f32	s8, s3, s5
 80152ca:	f101 0108 	add.w	r1, r1, #8
 80152ce:	f103 0308 	add.w	r3, r3, #8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80152d2:	eea0 6a83 	vfma.f32	s12, s1, s6
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80152d6:	eee0 7aa3 	vfma.f32	s15, s1, s7
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80152da:	ee36 6a04 	vadd.f32	s12, s12, s8
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80152de:	ee77 7aa4 	vadd.f32	s15, s15, s9
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80152e2:	ee35 6a06 	vadd.f32	s12, s10, s12
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80152e6:	ee75 7aa7 	vadd.f32	s15, s11, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80152ea:	ed83 6a00 	vstr	s12, [r3]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80152ee:	edc3 7a01 	vstr	s15, [r3, #4]
          for (j = i + 1; j < N; j++) {
 80152f2:	d1d0      	bne.n	8015296 <cblas_cher2k+0x256>
 80152f4:	3708      	adds	r7, #8
 80152f6:	3508      	adds	r5, #8
 80152f8:	4474      	add	r4, lr
 80152fa:	e79e      	b.n	801523a <cblas_cher2k+0x1fa>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80152fc:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8015300:	f000 823d 	beq.w	801577e <cblas_cher2k+0x73e>
    } else if (uplo == CblasLower && trans == CblasConjTrans) {
 8015304:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 8015308:	f47f af3f 	bne.w	801518a <cblas_cher2k+0x14a>
      for (k = 0; k < K; k++) {
 801530c:	9b03      	ldr	r3, [sp, #12]
 801530e:	2b00      	cmp	r3, #0
 8015310:	f340 8093 	ble.w	801543a <cblas_cher2k+0x3fa>
 8015314:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8015318:	9307      	str	r3, [sp, #28]
 801531a:	f103 0a08 	add.w	sl, r3, #8
 801531e:	9b02      	ldr	r3, [sp, #8]
            IMAG(C, i * lda + i) = 0.0;
 8015320:	ed9f 1a4b 	vldr	s2, [pc, #300]	; 8015450 <cblas_cher2k+0x410>
 8015324:	f8dd 8004 	ldr.w	r8, [sp, #4]
      for (k = 0; k < K; k++) {
 8015328:	2200      	movs	r2, #0
 801532a:	3304      	adds	r3, #4
 801532c:	9205      	str	r2, [sp, #20]
 801532e:	9206      	str	r2, [sp, #24]
 8015330:	9301      	str	r3, [sp, #4]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8015332:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
        for (i = 0; i < N; i++) {
 8015336:	2e00      	cmp	r6, #0
 8015338:	dd72      	ble.n	8015420 <cblas_cher2k+0x3e0>
 801533a:	9b00      	ldr	r3, [sp, #0]
 801533c:	9a05      	ldr	r2, [sp, #20]
 801533e:	9d01      	ldr	r5, [sp, #4]
 8015340:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
 8015344:	f04f 0e00 	mov.w	lr, #0
 8015348:	46cc      	mov	ip, r9
 801534a:	4677      	mov	r7, lr
 801534c:	4644      	mov	r4, r8
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801534e:	ed9c 0a00 	vldr	s0, [ip]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8015352:	ed9c 8a01 	vldr	s16, [ip, #4]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8015356:	edd4 7a00 	vldr	s15, [r4]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801535a:	ed94 6a01 	vldr	s12, [r4, #4]
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801535e:	ee67 2a00 	vmul.f32	s5, s14, s0
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8015362:	ee68 1a47 	vnmul.f32	s3, s16, s14
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 8015366:	eee6 2a88 	vfma.f32	s5, s13, s16
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801536a:	ee27 3a27 	vmul.f32	s6, s14, s15
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801536e:	ee27 2a06 	vmul.f32	s4, s14, s12
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8015372:	eee6 1a80 	vfma.f32	s3, s13, s0
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 8015376:	eea6 3a66 	vfms.f32	s6, s12, s13
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801537a:	eea6 2aa7 	vfma.f32	s4, s13, s15
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801537e:	eef1 2a62 	vneg.f32	s5, s5
          for (j = 0; j < i; j++) {
 8015382:	b3c7      	cbz	r7, 80153f6 <cblas_cher2k+0x3b6>
 8015384:	9b02      	ldr	r3, [sp, #8]
 8015386:	eb03 00ce 	add.w	r0, r3, lr, lsl #3
 801538a:	9b01      	ldr	r3, [sp, #4]
 801538c:	464a      	mov	r2, r9
 801538e:	eb03 01ce 	add.w	r1, r3, lr, lsl #3
 8015392:	4643      	mov	r3, r8
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8015394:	edd3 3a01 	vldr	s7, [r3, #4]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 8015398:	ed92 4a01 	vldr	s8, [r2, #4]
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 801539c:	ed93 6a00 	vldr	s12, [r3]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 80153a0:	edd2 7a00 	vldr	s15, [r2]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80153a4:	ed11 5a01 	vldr	s10, [r1, #-4]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80153a8:	ee63 4ae2 	vnmul.f32	s9, s7, s5
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80153ac:	ee64 5a43 	vnmul.f32	s11, s8, s6
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80153b0:	eee1 4a86 	vfma.f32	s9, s3, s12
 80153b4:	3308      	adds	r3, #8
          for (j = 0; j < i; j++) {
 80153b6:	429c      	cmp	r4, r3
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80153b8:	eee2 5a27 	vfma.f32	s11, s4, s15
 80153bc:	f102 0208 	add.w	r2, r2, #8
 80153c0:	f101 0108 	add.w	r1, r1, #8
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80153c4:	ee22 6a86 	vmul.f32	s12, s5, s12
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80153c8:	ee63 7a27 	vmul.f32	s15, s6, s15
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80153cc:	ee75 5aa4 	vadd.f32	s11, s11, s9
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80153d0:	eea1 6aa3 	vfma.f32	s12, s3, s7
 80153d4:	f100 0008 	add.w	r0, r0, #8
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80153d8:	eee2 7a04 	vfma.f32	s15, s4, s8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80153dc:	ee75 5a25 	vadd.f32	s11, s10, s11
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80153e0:	ee77 7a86 	vadd.f32	s15, s15, s12
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80153e4:	ed41 5a03 	vstr	s11, [r1, #-12]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80153e8:	ed10 6a01 	vldr	s12, [r0, #-4]
 80153ec:	ee76 7a27 	vadd.f32	s15, s12, s15
 80153f0:	ed40 7a01 	vstr	s15, [r0, #-4]
          for (j = 0; j < i; j++) {
 80153f4:	d1ce      	bne.n	8015394 <cblas_cher2k+0x354>
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 80153f6:	ee23 3a48 	vnmul.f32	s6, s6, s16
 80153fa:	ed55 7a01 	vldr	s15, [r5, #-4]
            IMAG(C, i * lda + i) = 0.0;
 80153fe:	ed85 1a00 	vstr	s2, [r5]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8015402:	eea0 3a02 	vfma.f32	s6, s0, s4
        for (i = 0; i < N; i++) {
 8015406:	3701      	adds	r7, #1
 8015408:	42be      	cmp	r6, r7
 801540a:	f104 0408 	add.w	r4, r4, #8
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801540e:	eee3 7a20 	vfma.f32	s15, s6, s1
 8015412:	f10c 0c08 	add.w	ip, ip, #8
 8015416:	44de      	add	lr, fp
 8015418:	ed45 7a01 	vstr	s15, [r5, #-4]
        for (i = 0; i < N; i++) {
 801541c:	4455      	add	r5, sl
 801541e:	d196      	bne.n	801534e <cblas_cher2k+0x30e>
      for (k = 0; k < K; k++) {
 8015420:	9a07      	ldr	r2, [sp, #28]
 8015422:	9b06      	ldr	r3, [sp, #24]
 8015424:	4490      	add	r8, r2
 8015426:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 801542a:	440a      	add	r2, r1
 801542c:	9205      	str	r2, [sp, #20]
 801542e:	9a03      	ldr	r2, [sp, #12]
 8015430:	3301      	adds	r3, #1
 8015432:	429a      	cmp	r2, r3
 8015434:	9306      	str	r3, [sp, #24]
 8015436:	f47f af7e 	bne.w	8015336 <cblas_cher2k+0x2f6>
 801543a:	b00f      	add	sp, #60	; 0x3c
 801543c:	ecbd 8b02 	vpop	{d8}
 8015440:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015444:	08031108 	.word	0x08031108
 8015448:	08031340 	.word	0x08031340
 801544c:	080311b8 	.word	0x080311b8
 8015450:	00000000 	.word	0x00000000
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015454:	4293      	cmp	r3, r2
 8015456:	dc09      	bgt.n	801546c <cblas_cher2k+0x42c>
 8015458:	2e01      	cmp	r6, #1
 801545a:	4633      	mov	r3, r6
 801545c:	bfb8      	it	lt
 801545e:	2301      	movlt	r3, #1
 8015460:	4553      	cmp	r3, sl
 8015462:	dc71      	bgt.n	8015548 <cblas_cher2k+0x508>
 8015464:	2800      	cmp	r0, #0
 8015466:	f43f ae33 	beq.w	80150d0 <cblas_cher2k+0x90>
 801546a:	e62d      	b.n	80150c8 <cblas_cher2k+0x88>
 801546c:	2e01      	cmp	r6, #1
 801546e:	4630      	mov	r0, r6
 8015470:	bfb8      	it	lt
 8015472:	2001      	movlt	r0, #1
 8015474:	4582      	cmp	sl, r0
 8015476:	bfb4      	ite	lt
 8015478:	200e      	movlt	r0, #14
 801547a:	200b      	movge	r0, #11
 801547c:	e624      	b.n	80150c8 <cblas_cher2k+0x88>
 801547e:	f1a7 0065 	sub.w	r0, r7, #101	; 0x65
 8015482:	2801      	cmp	r0, #1
 8015484:	bf94      	ite	ls
 8015486:	2000      	movls	r0, #0
 8015488:	2001      	movhi	r0, #1
 801548a:	e5ff      	b.n	801508c <cblas_cher2k+0x4c>
    } else if (beta != 1.0) {
 801548c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015490:	eeb4 8a67 	vcmp.f32	s16, s15
 8015494:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015498:	d042      	beq.n	8015520 <cblas_cher2k+0x4e0>
      if (uplo == CblasUpper) {
 801549a:	f1be 0f79 	cmp.w	lr, #121	; 0x79
 801549e:	f000 8141 	beq.w	8015724 <cblas_cher2k+0x6e4>
        for (i = 0; i < N; i++) {
 80154a2:	2e00      	cmp	r6, #0
 80154a4:	f77f ae5f 	ble.w	8015166 <cblas_cher2k+0x126>
 80154a8:	9b02      	ldr	r3, [sp, #8]
 80154aa:	f8cd e014 	str.w	lr, [sp, #20]
 80154ae:	f10a 0101 	add.w	r1, sl, #1
 80154b2:	f103 0c04 	add.w	ip, r3, #4
 80154b6:	00cf      	lsls	r7, r1, #3
 80154b8:	4660      	mov	r0, ip
 80154ba:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80154be:	4654      	mov	r4, sl
 80154c0:	2500      	movs	r5, #0
          IMAG(C, ldc * i + i) = 0.0;
 80154c2:	f04f 0900 	mov.w	r9, #0
 80154c6:	469e      	mov	lr, r3
          REAL(C, ldc * i + i) *= beta;
 80154c8:	ed50 7a01 	vldr	s15, [r0, #-4]
          IMAG(C, ldc * i + i) = 0.0;
 80154cc:	f8c0 9000 	str.w	r9, [r0]
          REAL(C, ldc * i + i) *= beta;
 80154d0:	ee67 7a88 	vmul.f32	s15, s15, s16
        for (i = 0; i < N; i++) {
 80154d4:	3501      	adds	r5, #1
 80154d6:	42ae      	cmp	r6, r5
          REAL(C, ldc * i + i) *= beta;
 80154d8:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (i = 0; i < N; i++) {
 80154dc:	f000 8119 	beq.w	8015712 <cblas_cher2k+0x6d2>
          for (j = 0; j < i; j++) {
 80154e0:	eb0e 03c4 	add.w	r3, lr, r4, lsl #3
 80154e4:	eb0c 02c4 	add.w	r2, ip, r4, lsl #3
            REAL(C, ldc * i + j) *= beta;
 80154e8:	ed52 7a01 	vldr	s15, [r2, #-4]
 80154ec:	ee67 7a88 	vmul.f32	s15, s15, s16
 80154f0:	3308      	adds	r3, #8
 80154f2:	ed42 7a01 	vstr	s15, [r2, #-4]
            IMAG(C, ldc * i + j) *= beta;
 80154f6:	ed53 7a01 	vldr	s15, [r3, #-4]
 80154fa:	ee67 7a88 	vmul.f32	s15, s15, s16
 80154fe:	3208      	adds	r2, #8
 8015500:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < i; j++) {
 8015504:	4299      	cmp	r1, r3
 8015506:	d1ef      	bne.n	80154e8 <cblas_cher2k+0x4a8>
 8015508:	4454      	add	r4, sl
 801550a:	4439      	add	r1, r7
 801550c:	4438      	add	r0, r7
 801550e:	e7db      	b.n	80154c8 <cblas_cher2k+0x488>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015510:	2a6f      	cmp	r2, #111	; 0x6f
 8015512:	f000 80fc 	beq.w	801570e <cblas_cher2k+0x6ce>
 8015516:	4633      	mov	r3, r6
 8015518:	e5b2      	b.n	8015080 <cblas_cher2k+0x40>
      uplo = Uplo;
 801551a:	46ae      	mov	lr, r5
      trans = Trans;
 801551c:	46a0      	mov	r8, r4
 801551e:	e602      	b.n	8015126 <cblas_cher2k+0xe6>
      for (i = 0; i < N; i++) {
 8015520:	2e00      	cmp	r6, #0
 8015522:	dd0a      	ble.n	801553a <cblas_cher2k+0x4fa>
 8015524:	f10a 0101 	add.w	r1, sl, #1
 8015528:	9a02      	ldr	r2, [sp, #8]
        IMAG(C, ldc * i + i) = 0.0;
 801552a:	2000      	movs	r0, #0
 801552c:	00c9      	lsls	r1, r1, #3
      for (i = 0; i < N; i++) {
 801552e:	2300      	movs	r3, #0
 8015530:	3301      	adds	r3, #1
 8015532:	429e      	cmp	r6, r3
        IMAG(C, ldc * i + i) = 0.0;
 8015534:	6050      	str	r0, [r2, #4]
      for (i = 0; i < N; i++) {
 8015536:	440a      	add	r2, r1
 8015538:	d1fa      	bne.n	8015530 <cblas_cher2k+0x4f0>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801553a:	eef5 6a40 	vcmp.f32	s13, #0.0
 801553e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015542:	f47f ae1b 	bne.w	801517c <cblas_cher2k+0x13c>
 8015546:	e613      	b.n	8015170 <cblas_cher2k+0x130>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015548:	200e      	movs	r0, #14
 801554a:	e5bd      	b.n	80150c8 <cblas_cher2k+0x88>
      for (i = 0; i < N; i++) {
 801554c:	2e00      	cmp	r6, #0
 801554e:	f77f af74 	ble.w	801543a <cblas_cher2k+0x3fa>
 8015552:	2300      	movs	r3, #0
 8015554:	9306      	str	r3, [sp, #24]
 8015556:	9307      	str	r3, [sp, #28]
 8015558:	9305      	str	r3, [sp, #20]
 801555a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801555e:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 8015562:	9309      	str	r3, [sp, #36]	; 0x24
 8015564:	9b04      	ldr	r3, [sp, #16]
 8015566:	920a      	str	r2, [sp, #40]	; 0x28
 8015568:	3208      	adds	r2, #8
 801556a:	9902      	ldr	r1, [sp, #8]
 801556c:	9208      	str	r2, [sp, #32]
 801556e:	00da      	lsls	r2, r3, #3
 8015570:	9803      	ldr	r0, [sp, #12]
 8015572:	9204      	str	r2, [sp, #16]
 8015574:	9a01      	ldr	r2, [sp, #4]
          for (k = 0; k < K; k++) {
 8015576:	ed1f 1a4a 	vldr	s2, [pc, #-296]	; 8015450 <cblas_cher2k+0x410>
      for (i = 0; i < N; i++) {
 801557a:	f8dd 9000 	ldr.w	r9, [sp]
 801557e:	f101 0a04 	add.w	sl, r1, #4
 8015582:	f1a1 0e08 	sub.w	lr, r1, #8
 8015586:	e9cd a602 	strd	sl, r6, [sp, #8]
 801558a:	eb0e 0ec6 	add.w	lr, lr, r6, lsl #3
 801558e:	eb02 04c0 	add.w	r4, r2, r0, lsl #3
 8015592:	4690      	mov	r8, r2
 8015594:	4684      	mov	ip, r0
 8015596:	469a      	mov	sl, r3
          for (k = 0; k < K; k++) {
 8015598:	f1bc 0f00 	cmp.w	ip, #0
 801559c:	bfd8      	it	le
 801559e:	eef0 4a41 	vmovle.f32	s9, s2
 80155a2:	dd21      	ble.n	80155e8 <cblas_cher2k+0x5a8>
          BASE temp_real = 0.0;
 80155a4:	ed5f 4a56 	vldr	s9, [pc, #-344]	; 8015450 <cblas_cher2k+0x410>
          for (k = 0; k < K; k++) {
 80155a8:	464a      	mov	r2, r9
 80155aa:	4643      	mov	r3, r8
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80155ac:	edd3 5a00 	vldr	s11, [r3]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80155b0:	ed93 5a01 	vldr	s10, [r3, #4]
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 80155b4:	edd2 3a01 	vldr	s7, [r2, #4]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 80155b8:	ee67 7a25 	vmul.f32	s15, s14, s11
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80155bc:	ee25 6a47 	vnmul.f32	s12, s10, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 80155c0:	eee6 7a85 	vfma.f32	s15, s13, s10
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 80155c4:	4611      	mov	r1, r2
 80155c6:	3308      	adds	r3, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80155c8:	eea6 6aa5 	vfma.f32	s12, s13, s11
          for (k = 0; k < K; k++) {
 80155cc:	429c      	cmp	r4, r3
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 80155ce:	f102 0208 	add.w	r2, r2, #8
 80155d2:	ed91 4a00 	vldr	s8, [r1]
 80155d6:	ee67 7aa3 	vmul.f32	s15, s15, s7
 80155da:	eee6 7a04 	vfma.f32	s15, s12, s8
 80155de:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 80155e2:	d1e3      	bne.n	80155ac <cblas_cher2k+0x56c>
 80155e4:	ee74 4aa4 	vadd.f32	s9, s9, s9
          REAL(C, i * ldc + i) += 2 * temp_real;
 80155e8:	9b02      	ldr	r3, [sp, #8]
        for (j = i + 1; j < N; j++) {
 80155ea:	9905      	ldr	r1, [sp, #20]
          REAL(C, i * ldc + i) += 2 * temp_real;
 80155ec:	ed53 7a01 	vldr	s15, [r3, #-4]
        for (j = i + 1; j < N; j++) {
 80155f0:	9a03      	ldr	r2, [sp, #12]
          IMAG(C, i * ldc + i) = 0.0;
 80155f2:	ed83 1a00 	vstr	s2, [r3]
        for (j = i + 1; j < N; j++) {
 80155f6:	3101      	adds	r1, #1
          REAL(C, i * ldc + i) += 2 * temp_real;
 80155f8:	ee77 4aa4 	vadd.f32	s9, s15, s9
        for (j = i + 1; j < N; j++) {
 80155fc:	428a      	cmp	r2, r1
 80155fe:	9105      	str	r1, [sp, #20]
          REAL(C, i * ldc + i) += 2 * temp_real;
 8015600:	ed43 4a01 	vstr	s9, [r3, #-4]
        for (j = i + 1; j < N; j++) {
 8015604:	f43f af19 	beq.w	801543a <cblas_cher2k+0x3fa>
 8015608:	9e07      	ldr	r6, [sp, #28]
 801560a:	9a06      	ldr	r2, [sp, #24]
 801560c:	445e      	add	r6, fp
 801560e:	4452      	add	r2, sl
 8015610:	9607      	str	r6, [sp, #28]
 8015612:	9206      	str	r2, [sp, #24]
 8015614:	4617      	mov	r7, r2
 8015616:	1f1d      	subs	r5, r3, #4
          BASE temp_imag = 0.0;
 8015618:	ed5f 0a73 	vldr	s1, [pc, #-460]	; 8015450 <cblas_cher2k+0x410>
          for (k = 0; k < K; k++) {
 801561c:	f1bc 0f00 	cmp.w	ip, #0
          BASE temp_real = 0.0;
 8015620:	eeb0 0a60 	vmov.f32	s0, s1
          for (k = 0; k < K; k++) {
 8015624:	dd4a      	ble.n	80156bc <cblas_cher2k+0x67c>
 8015626:	9b01      	ldr	r3, [sp, #4]
 8015628:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 801562c:	9b00      	ldr	r3, [sp, #0]
 801562e:	464a      	mov	r2, r9
 8015630:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 8015634:	4643      	mov	r3, r8
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8015636:	ed93 5a00 	vldr	s10, [r3]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801563a:	edd0 3a00 	vldr	s7, [r0]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801563e:	edd0 1a01 	vldr	s3, [r0, #4]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8015642:	ed93 6a01 	vldr	s12, [r3, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8015646:	ed91 2a01 	vldr	s4, [r1, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801564a:	edd1 2a00 	vldr	s5, [r1]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801564e:	edd2 5a01 	vldr	s11, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8015652:	ed92 3a00 	vldr	s6, [r2]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8015656:	ee67 7a05 	vmul.f32	s15, s14, s10
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801565a:	ee67 4a23 	vmul.f32	s9, s14, s7
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801565e:	ee21 4ac7 	vnmul.f32	s8, s3, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8015662:	eee6 7a86 	vfma.f32	s15, s13, s12
 8015666:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8015668:	429c      	cmp	r4, r3
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801566a:	eee6 4aa1 	vfma.f32	s9, s13, s3
 801566e:	f101 0108 	add.w	r1, r1, #8
 8015672:	f100 0008 	add.w	r0, r0, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8015676:	ee26 6a47 	vnmul.f32	s12, s12, s14
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801567a:	eea6 4aa3 	vfma.f32	s8, s13, s7
 801567e:	f102 0208 	add.w	r2, r2, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8015682:	eea6 6a85 	vfma.f32	s12, s13, s10
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 8015686:	ee65 3aa4 	vmul.f32	s7, s11, s9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801568a:	ee27 5a82 	vmul.f32	s10, s15, s4
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801568e:	ee67 7aa2 	vmul.f32	s15, s15, s5
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 8015692:	ee65 5a84 	vmul.f32	s11, s11, s8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 8015696:	eee2 7a46 	vfms.f32	s15, s4, s12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801569a:	eea6 5a22 	vfma.f32	s10, s12, s5
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801569e:	eeb0 6a63 	vmov.f32	s12, s7
 80156a2:	eea3 6a04 	vfma.f32	s12, s6, s8
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80156a6:	eee4 5ac3 	vfms.f32	s11, s9, s6
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80156aa:	ee35 6a06 	vadd.f32	s12, s10, s12
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80156ae:	ee77 7aa5 	vadd.f32	s15, s15, s11
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 80156b2:	ee30 0a06 	vadd.f32	s0, s0, s12
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 80156b6:	ee70 0aa7 	vadd.f32	s1, s1, s15
          for (k = 0; k < K; k++) {
 80156ba:	d1bc      	bne.n	8015636 <cblas_cher2k+0x5f6>
          REAL(C, i * ldc + j) += temp_real;
 80156bc:	ed95 6a02 	vldr	s12, [r5, #8]
          IMAG(C, i * ldc + j) += temp_imag;
 80156c0:	edd5 7a03 	vldr	s15, [r5, #12]
          REAL(C, i * ldc + j) += temp_real;
 80156c4:	ee36 0a00 	vadd.f32	s0, s12, s0
          IMAG(C, i * ldc + j) += temp_imag;
 80156c8:	ee77 0aa0 	vadd.f32	s1, s15, s1
          REAL(C, i * ldc + j) += temp_real;
 80156cc:	ed85 0a02 	vstr	s0, [r5, #8]
          IMAG(C, i * ldc + j) += temp_imag;
 80156d0:	edc5 0a03 	vstr	s1, [r5, #12]
        for (j = i + 1; j < N; j++) {
 80156d4:	3508      	adds	r5, #8
 80156d6:	45ae      	cmp	lr, r5
 80156d8:	445e      	add	r6, fp
 80156da:	4457      	add	r7, sl
 80156dc:	d19c      	bne.n	8015618 <cblas_cher2k+0x5d8>
 80156de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80156e0:	9a04      	ldr	r2, [sp, #16]
 80156e2:	449e      	add	lr, r3
 80156e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80156e6:	4491      	add	r9, r2
 80156e8:	4498      	add	r8, r3
 80156ea:	9a08      	ldr	r2, [sp, #32]
 80156ec:	441c      	add	r4, r3
 80156ee:	9b02      	ldr	r3, [sp, #8]
 80156f0:	4413      	add	r3, r2
 80156f2:	9302      	str	r3, [sp, #8]
 80156f4:	e750      	b.n	8015598 <cblas_cher2k+0x558>
      for (k = 0; k < K; k++) {
 80156f6:	9b04      	ldr	r3, [sp, #16]
 80156f8:	4498      	add	r8, r3
 80156fa:	9b05      	ldr	r3, [sp, #20]
 80156fc:	4418      	add	r0, r3
 80156fe:	9b03      	ldr	r3, [sp, #12]
 8015700:	f109 0901 	add.w	r9, r9, #1
 8015704:	454b      	cmp	r3, r9
 8015706:	44da      	add	sl, fp
 8015708:	f47f ad8a 	bne.w	8015220 <cblas_cher2k+0x1e0>
 801570c:	e695      	b.n	801543a <cblas_cher2k+0x3fa>
 801570e:	9b03      	ldr	r3, [sp, #12]
 8015710:	e546      	b.n	80151a0 <cblas_cher2k+0x160>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8015712:	eef5 6a40 	vcmp.f32	s13, #0.0
 8015716:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801571a:	f8dd e014 	ldr.w	lr, [sp, #20]
 801571e:	f43f ad27 	beq.w	8015170 <cblas_cher2k+0x130>
 8015722:	e52e      	b.n	8015182 <cblas_cher2k+0x142>
        for (i = 0; i < N; i++) {
 8015724:	2e00      	cmp	r6, #0
 8015726:	f77f ad57 	ble.w	80151d8 <cblas_cher2k+0x198>
 801572a:	9b02      	ldr	r3, [sp, #8]
 801572c:	ea4f 04ca 	mov.w	r4, sl, lsl #3
 8015730:	f1a3 0208 	sub.w	r2, r3, #8
          IMAG(C, ldc * i + i) = 0.0;
 8015734:	2700      	movs	r7, #0
 8015736:	f104 0508 	add.w	r5, r4, #8
 801573a:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 801573e:	1d19      	adds	r1, r3, #4
        for (i = 0; i < N; i++) {
 8015740:	2000      	movs	r0, #0
          REAL(C, ldc * i + i) *= beta;
 8015742:	ed51 7a01 	vldr	s15, [r1, #-4]
          IMAG(C, ldc * i + i) = 0.0;
 8015746:	600f      	str	r7, [r1, #0]
          REAL(C, ldc * i + i) *= beta;
 8015748:	ee67 7a88 	vmul.f32	s15, s15, s16
          for (j = i + 1; j < N; j++) {
 801574c:	3001      	adds	r0, #1
 801574e:	4286      	cmp	r6, r0
          REAL(C, ldc * i + i) *= beta;
 8015750:	ed41 7a01 	vstr	s15, [r1, #-4]
          for (j = i + 1; j < N; j++) {
 8015754:	f43f ad40 	beq.w	80151d8 <cblas_cher2k+0x198>
 8015758:	1f0b      	subs	r3, r1, #4
            REAL(C, ldc * i + j) *= beta;
 801575a:	ed93 6a02 	vldr	s12, [r3, #8]
            IMAG(C, ldc * i + j) *= beta;
 801575e:	edd3 7a03 	vldr	s15, [r3, #12]
            REAL(C, ldc * i + j) *= beta;
 8015762:	ee26 6a08 	vmul.f32	s12, s12, s16
            IMAG(C, ldc * i + j) *= beta;
 8015766:	ee67 7a88 	vmul.f32	s15, s15, s16
            REAL(C, ldc * i + j) *= beta;
 801576a:	ed83 6a02 	vstr	s12, [r3, #8]
            IMAG(C, ldc * i + j) *= beta;
 801576e:	edc3 7a03 	vstr	s15, [r3, #12]
          for (j = i + 1; j < N; j++) {
 8015772:	3308      	adds	r3, #8
 8015774:	429a      	cmp	r2, r3
 8015776:	d1f0      	bne.n	801575a <cblas_cher2k+0x71a>
 8015778:	4422      	add	r2, r4
 801577a:	4429      	add	r1, r5
 801577c:	e7e1      	b.n	8015742 <cblas_cher2k+0x702>
      for (i = 0; i < N; i++) {
 801577e:	2e00      	cmp	r6, #0
 8015780:	f77f ae5b 	ble.w	801543a <cblas_cher2k+0x3fa>
 8015784:	9b03      	ldr	r3, [sp, #12]
 8015786:	9f01      	ldr	r7, [sp, #4]
 8015788:	9d02      	ldr	r5, [sp, #8]
          for (k = 0; k < K; k++) {
 801578a:	ed1f 0acf 	vldr	s0, [pc, #-828]	; 8015450 <cblas_cher2k+0x410>
 801578e:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8015792:	f10a 0801 	add.w	r8, sl, #1
 8015796:	eb03 020b 	add.w	r2, r3, fp
 801579a:	ea4f 04c8 	mov.w	r4, r8, lsl #3
 801579e:	4619      	mov	r1, r3
 80157a0:	940c      	str	r4, [sp, #48]	; 0x30
 80157a2:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
 80157a6:	eb07 04c2 	add.w	r4, r7, r2, lsl #3
 80157aa:	9a04      	ldr	r2, [sp, #16]
 80157ac:	9609      	str	r6, [sp, #36]	; 0x24
      for (i = 0; i < N; i++) {
 80157ae:	2000      	movs	r0, #0
 80157b0:	00db      	lsls	r3, r3, #3
 80157b2:	e9cd 0306 	strd	r0, r3, [sp, #24]
 80157b6:	00d3      	lsls	r3, r2, #3
 80157b8:	930b      	str	r3, [sp, #44]	; 0x2c
 80157ba:	9b00      	ldr	r3, [sp, #0]
 80157bc:	9005      	str	r0, [sp, #20]
 80157be:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
 80157c2:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80157c6:	930a      	str	r3, [sp, #40]	; 0x28
 80157c8:	eb07 0ec1 	add.w	lr, r7, r1, lsl #3
 80157cc:	460b      	mov	r3, r1
 80157ce:	1d29      	adds	r1, r5, #4
 80157d0:	e9cd 1a03 	strd	r1, sl, [sp, #12]
 80157d4:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
 80157d8:	469c      	mov	ip, r3
 80157da:	4692      	mov	sl, r2
          for (k = 0; k < K; k++) {
 80157dc:	f1bc 0f00 	cmp.w	ip, #0
 80157e0:	f340 80b8 	ble.w	8015954 <cblas_cher2k+0x914>
 80157e4:	9b07      	ldr	r3, [sp, #28]
 80157e6:	9a00      	ldr	r2, [sp, #0]
 80157e8:	9905      	ldr	r1, [sp, #20]
          BASE temp_real = 0.0;
 80157ea:	eddf 4a5c 	vldr	s9, [pc, #368]	; 801595c <cblas_cher2k+0x91c>
 80157ee:	4473      	add	r3, lr
 80157f0:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80157f4:	edd3 5a00 	vldr	s11, [r3]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80157f8:	ed93 5a01 	vldr	s10, [r3, #4]
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 80157fc:	edd2 3a01 	vldr	s7, [r2, #4]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8015800:	ee67 7a25 	vmul.f32	s15, s14, s11
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8015804:	ee25 6a47 	vnmul.f32	s12, s10, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8015808:	eee6 7a85 	vfma.f32	s15, s13, s10
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801580c:	4611      	mov	r1, r2
 801580e:	3308      	adds	r3, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8015810:	eea6 6aa5 	vfma.f32	s12, s13, s11
          for (k = 0; k < K; k++) {
 8015814:	459e      	cmp	lr, r3
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 8015816:	f102 0208 	add.w	r2, r2, #8
 801581a:	ed91 4a00 	vldr	s8, [r1]
 801581e:	ee67 7aa3 	vmul.f32	s15, s15, s7
 8015822:	eee6 7a04 	vfma.f32	s15, s12, s8
 8015826:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 801582a:	d1e3      	bne.n	80157f4 <cblas_cher2k+0x7b4>
 801582c:	ee74 4aa4 	vadd.f32	s9, s9, s9
          REAL(C, i * ldc + i) += 2 * temp_real;
 8015830:	9b03      	ldr	r3, [sp, #12]
      for (i = 0; i < N; i++) {
 8015832:	9a06      	ldr	r2, [sp, #24]
          REAL(C, i * ldc + i) += 2 * temp_real;
 8015834:	ed53 7a01 	vldr	s15, [r3, #-4]
          IMAG(C, i * ldc + i) = 0.0;
 8015838:	ed83 0a00 	vstr	s0, [r3]
          REAL(C, i * ldc + i) += 2 * temp_real;
 801583c:	ee77 4aa4 	vadd.f32	s9, s15, s9
      for (i = 0; i < N; i++) {
 8015840:	3201      	adds	r2, #1
          REAL(C, i * ldc + i) += 2 * temp_real;
 8015842:	ed43 4a01 	vstr	s9, [r3, #-4]
      for (i = 0; i < N; i++) {
 8015846:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8015848:	9206      	str	r2, [sp, #24]
 801584a:	4293      	cmp	r3, r2
 801584c:	f43f adf5 	beq.w	801543a <cblas_cher2k+0x3fa>
        for (j = 0; j < i; j++) {
 8015850:	9b02      	ldr	r3, [sp, #8]
 8015852:	9a04      	ldr	r2, [sp, #16]
 8015854:	f8cd e020 	str.w	lr, [sp, #32]
 8015858:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 801585c:	9b07      	ldr	r3, [sp, #28]
      for (i = 0; i < N; i++) {
 801585e:	2600      	movs	r6, #0
 8015860:	4423      	add	r3, r4
 8015862:	4637      	mov	r7, r6
 8015864:	469e      	mov	lr, r3
          BASE temp_imag = 0.0;
 8015866:	ed9f 1a3d 	vldr	s2, [pc, #244]	; 801595c <cblas_cher2k+0x91c>
          for (k = 0; k < K; k++) {
 801586a:	f1bc 0f00 	cmp.w	ip, #0
          BASE temp_real = 0.0;
 801586e:	eef0 0a41 	vmov.f32	s1, s2
          for (k = 0; k < K; k++) {
 8015872:	dd4a      	ble.n	801590a <cblas_cher2k+0x8ca>
 8015874:	9b01      	ldr	r3, [sp, #4]
 8015876:	eb03 00c7 	add.w	r0, r3, r7, lsl #3
 801587a:	9b00      	ldr	r3, [sp, #0]
 801587c:	464a      	mov	r2, r9
 801587e:	eb03 01c6 	add.w	r1, r3, r6, lsl #3
 8015882:	4673      	mov	r3, lr
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8015884:	ed93 5a00 	vldr	s10, [r3]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8015888:	edd0 3a00 	vldr	s7, [r0]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801588c:	edd0 1a01 	vldr	s3, [r0, #4]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8015890:	ed93 6a01 	vldr	s12, [r3, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8015894:	ed91 2a01 	vldr	s4, [r1, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8015898:	edd1 2a00 	vldr	s5, [r1]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801589c:	edd2 5a01 	vldr	s11, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 80158a0:	ed92 3a00 	vldr	s6, [r2]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 80158a4:	ee67 7a05 	vmul.f32	s15, s14, s10
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 80158a8:	ee67 4a23 	vmul.f32	s9, s14, s7
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 80158ac:	ee21 4ac7 	vnmul.f32	s8, s3, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 80158b0:	eee6 7a86 	vfma.f32	s15, s13, s12
 80158b4:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 80158b6:	429c      	cmp	r4, r3
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 80158b8:	eee6 4aa1 	vfma.f32	s9, s13, s3
 80158bc:	f101 0108 	add.w	r1, r1, #8
 80158c0:	f100 0008 	add.w	r0, r0, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80158c4:	ee26 6a47 	vnmul.f32	s12, s12, s14
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 80158c8:	eea6 4aa3 	vfma.f32	s8, s13, s7
 80158cc:	f102 0208 	add.w	r2, r2, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80158d0:	eea6 6a85 	vfma.f32	s12, s13, s10
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80158d4:	ee65 3aa4 	vmul.f32	s7, s11, s9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 80158d8:	ee27 5a82 	vmul.f32	s10, s15, s4
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 80158dc:	ee67 7aa2 	vmul.f32	s15, s15, s5
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80158e0:	ee65 5a84 	vmul.f32	s11, s11, s8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 80158e4:	eee2 7a46 	vfms.f32	s15, s4, s12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 80158e8:	eea6 5a22 	vfma.f32	s10, s12, s5
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80158ec:	eeb0 6a63 	vmov.f32	s12, s7
 80158f0:	eea3 6a04 	vfma.f32	s12, s6, s8
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80158f4:	eee4 5ac3 	vfms.f32	s11, s9, s6
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80158f8:	ee35 6a06 	vadd.f32	s12, s10, s12
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80158fc:	ee77 7aa5 	vadd.f32	s15, s15, s11
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 8015900:	ee70 0a86 	vadd.f32	s1, s1, s12
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 8015904:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = 0; k < K; k++) {
 8015908:	d1bc      	bne.n	8015884 <cblas_cher2k+0x844>
          REAL(C, i * ldc + j) += temp_real;
 801590a:	ed95 6a00 	vldr	s12, [r5]
          IMAG(C, i * ldc + j) += temp_imag;
 801590e:	edd5 7a01 	vldr	s15, [r5, #4]
          REAL(C, i * ldc + j) += temp_real;
 8015912:	ee76 0a20 	vadd.f32	s1, s12, s1
          IMAG(C, i * ldc + j) += temp_imag;
 8015916:	ee37 1a81 	vadd.f32	s2, s15, s2
          REAL(C, i * ldc + j) += temp_real;
 801591a:	edc5 0a00 	vstr	s1, [r5]
          IMAG(C, i * ldc + j) += temp_imag;
 801591e:	ed85 1a01 	vstr	s2, [r5, #4]
        for (j = 0; j < i; j++) {
 8015922:	3508      	adds	r5, #8
 8015924:	45a8      	cmp	r8, r5
 8015926:	445f      	add	r7, fp
 8015928:	4456      	add	r6, sl
 801592a:	d19c      	bne.n	8015866 <cblas_cher2k+0x826>
 801592c:	9b04      	ldr	r3, [sp, #16]
 801592e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8015930:	f8dd e020 	ldr.w	lr, [sp, #32]
 8015934:	9905      	ldr	r1, [sp, #20]
 8015936:	4413      	add	r3, r2
 8015938:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801593a:	9304      	str	r3, [sp, #16]
 801593c:	4491      	add	r9, r2
 801593e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8015940:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8015942:	4414      	add	r4, r2
 8015944:	4496      	add	lr, r2
 8015946:	9a03      	ldr	r2, [sp, #12]
 8015948:	4451      	add	r1, sl
 801594a:	441a      	add	r2, r3
 801594c:	4498      	add	r8, r3
 801594e:	9105      	str	r1, [sp, #20]
 8015950:	9203      	str	r2, [sp, #12]
 8015952:	e743      	b.n	80157dc <cblas_cher2k+0x79c>
          for (k = 0; k < K; k++) {
 8015954:	eef0 4a40 	vmov.f32	s9, s0
 8015958:	e76a      	b.n	8015830 <cblas_cher2k+0x7f0>
 801595a:	bf00      	nop
 801595c:	00000000 	.word	0x00000000

08015960 <cblas_cherk>:
void
cblas_cherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const float alpha, const void *A, const int lda,
             const float beta, void *C, const int ldc)
{
 8015960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015964:	ed2d 8b02 	vpush	{d8}
 8015968:	b087      	sub	sp, #28
 801596a:	461e      	mov	r6, r3
 801596c:	e9dd 4314 	ldrd	r4, r3, [sp, #80]	; 0x50

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8015970:	2865      	cmp	r0, #101	; 0x65
 8015972:	e9dd 5712 	ldrd	r5, r7, [sp, #72]	; 0x48
 8015976:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 801597a:	9301      	str	r3, [sp, #4]
 801597c:	4681      	mov	r9, r0
 801597e:	468a      	mov	sl, r1
 8015980:	4693      	mov	fp, r2
 8015982:	eeb0 8a40 	vmov.f32	s16, s0
 8015986:	eef0 8a60 	vmov.f32	s17, s1
 801598a:	f000 80ff 	beq.w	8015b8c <cblas_cherk+0x22c>
 801598e:	2a6f      	cmp	r2, #111	; 0x6f
 8015990:	f000 80b3 	beq.w	8015afa <cblas_cherk+0x19a>
 8015994:	462b      	mov	r3, r5
 8015996:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 801599a:	2a01      	cmp	r2, #1
 801599c:	f240 80ef 	bls.w	8015b7e <cblas_cherk+0x21e>
 80159a0:	2002      	movs	r0, #2
 80159a2:	f1ab 026f 	sub.w	r2, fp, #111	; 0x6f
 80159a6:	2a02      	cmp	r2, #2
 80159a8:	bf88      	it	hi
 80159aa:	2003      	movhi	r0, #3
 80159ac:	2e00      	cmp	r6, #0
 80159ae:	bfb8      	it	lt
 80159b0:	2004      	movlt	r0, #4
 80159b2:	2b01      	cmp	r3, #1
 80159b4:	bfb8      	it	lt
 80159b6:	2301      	movlt	r3, #1
 80159b8:	2d00      	cmp	r5, #0
 80159ba:	f2c0 80d5 	blt.w	8015b68 <cblas_cherk+0x208>
 80159be:	42a3      	cmp	r3, r4
 80159c0:	f300 80a2 	bgt.w	8015b08 <cblas_cherk+0x1a8>
 80159c4:	2e01      	cmp	r6, #1
 80159c6:	4633      	mov	r3, r6
 80159c8:	bfb8      	it	lt
 80159ca:	2301      	movlt	r3, #1
 80159cc:	4543      	cmp	r3, r8
 80159ce:	f300 812a 	bgt.w	8015c26 <cblas_cherk+0x2c6>
 80159d2:	2800      	cmp	r0, #0
 80159d4:	f040 80a0 	bne.w	8015b18 <cblas_cherk+0x1b8>

  if (beta == 1.0 && (alpha == 0.0 || K == 0))
 80159d8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80159dc:	eef4 8a67 	vcmp.f32	s17, s15
 80159e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80159e4:	f000 80a4 	beq.w	8015b30 <cblas_cherk+0x1d0>
    return;

  if (Order == CblasRowMajor) {
 80159e8:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 80159ec:	f000 80d3 	beq.w	8015b96 <cblas_cherk+0x236>
    uplo = Uplo;
    trans = Trans;
  } else {
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80159f0:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 80159f4:	eef5 8a40 	vcmp.f32	s17, #0.0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80159f8:	f000 8117 	beq.w	8015c2a <cblas_cherk+0x2ca>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80159fc:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8015a00:	f000 8189 	beq.w	8015d16 <cblas_cherk+0x3b6>
  if (beta == 0.0) {
 8015a04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a08:	f040 80fe 	bne.w	8015c08 <cblas_cherk+0x2a8>
    if (uplo == CblasUpper) {
      for (i = 0; i < N; i++) {
 8015a0c:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015a0e:	bfc8      	it	gt
 8015a10:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8015a14:	dd6c      	ble.n	8015af0 <cblas_cherk+0x190>
 8015a16:	f108 0e01 	add.w	lr, r8, #1
 8015a1a:	f8dd c004 	ldr.w	ip, [sp, #4]
        for (j = i; j < N; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8015a1e:	2100      	movs	r1, #0
 8015a20:	ea4f 0ece 	mov.w	lr, lr, lsl #3
      for (i = 0; i < N; i++) {
 8015a24:	2000      	movs	r0, #0
 8015a26:	4663      	mov	r3, ip
 8015a28:	4602      	mov	r2, r0
        for (j = i; j < N; j++) {
 8015a2a:	3201      	adds	r2, #1
 8015a2c:	4296      	cmp	r6, r2
          REAL(C, ldc * i + j) = 0.0;
 8015a2e:	6019      	str	r1, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8015a30:	6059      	str	r1, [r3, #4]
        for (j = i; j < N; j++) {
 8015a32:	f103 0308 	add.w	r3, r3, #8
 8015a36:	dcf8      	bgt.n	8015a2a <cblas_cherk+0xca>
      for (i = 0; i < N; i++) {
 8015a38:	3001      	adds	r0, #1
 8015a3a:	4286      	cmp	r6, r0
 8015a3c:	44f4      	add	ip, lr
 8015a3e:	dcf2      	bgt.n	8015a26 <cblas_cherk+0xc6>
    for (i = 0; i < N; i++) {
      IMAG(C, ldc * i + i) = 0.0;
    }
  }

  if (alpha == 0.0)
 8015a40:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8015a44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015a48:	d052      	beq.n	8015af0 <cblas_cherk+0x190>
    return;

  if (uplo == CblasUpper && trans == CblasNoTrans) {
 8015a4a:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8015a4e:	f000 8175 	beq.w	8015d3c <cblas_cherk+0x3dc>
        REAL(C, i * ldc + j) += alpha * temp_real;
        IMAG(C, i * ldc + j) += alpha * temp_imag;
      }
    }

  } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 8015a52:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8015a56:	f040 80cd 	bne.w	8015bf4 <cblas_cherk+0x294>

    for (i = 0; i < N; i++) {
 8015a5a:	2e00      	cmp	r6, #0
 8015a5c:	dd48      	ble.n	8015af0 <cblas_cherk+0x190>
 8015a5e:	f108 0801 	add.w	r8, r8, #1
 8015a62:	f8dd a004 	ldr.w	sl, [sp, #4]
 8015a66:	ea4f 09c8 	mov.w	r9, r8, lsl #3
 8015a6a:	00e0      	lsls	r0, r4, #3
 8015a6c:	f107 0e04 	add.w	lr, r7, #4
 8015a70:	f04f 0800 	mov.w	r8, #0
      for (j = i; j < N; j++) {
        BASE temp_real = 0.0;
 8015a74:	4654      	mov	r4, sl
 8015a76:	46c4      	mov	ip, r8
        BASE temp_imag = 0.0;
 8015a78:	ed9f 5adb 	vldr	s10, [pc, #876]	; 8015de8 <cblas_cherk+0x488>
        for (k = 0; k < K; k++) {
 8015a7c:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 8015a7e:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 8015a82:	dd1c      	ble.n	8015abe <cblas_cherk+0x15e>
 8015a84:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 8015a88:	4673      	mov	r3, lr
 8015a8a:	2100      	movs	r1, #0
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 8015a8c:	edd3 7a00 	vldr	s15, [r3]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8015a90:	edd2 6a01 	vldr	s13, [r2, #4]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8015a94:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8015a98:	ed13 6a01 	vldr	s12, [r3, #-4]
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8015a9c:	ee27 7aa6 	vmul.f32	s14, s15, s13
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015aa0:	ee67 7ae5 	vnmul.f32	s15, s15, s11
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8015aa4:	eea6 7a25 	vfma.f32	s14, s12, s11
        for (k = 0; k < K; k++) {
 8015aa8:	3101      	adds	r1, #1
 8015aaa:	428d      	cmp	r5, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015aac:	eee6 7a26 	vfma.f32	s15, s12, s13
 8015ab0:	4402      	add	r2, r0
 8015ab2:	4403      	add	r3, r0
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8015ab4:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015ab8:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 8015abc:	d1e6      	bne.n	8015a8c <cblas_cherk+0x12c>
        }
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015abe:	ed94 7a00 	vldr	s14, [r4]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015ac2:	edd4 7a01 	vldr	s15, [r4, #4]
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015ac6:	eea8 7a24 	vfma.f32	s14, s16, s9
      for (j = i; j < N; j++) {
 8015aca:	f10c 0c01 	add.w	ip, ip, #1
 8015ace:	4566      	cmp	r6, ip
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015ad0:	eee8 7a05 	vfma.f32	s15, s16, s10
 8015ad4:	f104 0408 	add.w	r4, r4, #8
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015ad8:	ed04 7a02 	vstr	s14, [r4, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015adc:	ed44 7a01 	vstr	s15, [r4, #-4]
      for (j = i; j < N; j++) {
 8015ae0:	dcca      	bgt.n	8015a78 <cblas_cherk+0x118>
    for (i = 0; i < N; i++) {
 8015ae2:	f108 0801 	add.w	r8, r8, #1
 8015ae6:	4546      	cmp	r6, r8
 8015ae8:	44ca      	add	sl, r9
 8015aea:	f10e 0e08 	add.w	lr, lr, #8
 8015aee:	d1c1      	bne.n	8015a74 <cblas_cherk+0x114>
#define BASE float
#include "source_herk.h"
#undef BASE
}
 8015af0:	b007      	add	sp, #28
 8015af2:	ecbd 8b02 	vpop	{d8}
 8015af6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015afa:	4633      	mov	r3, r6
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8015afc:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 8015b00:	2a01      	cmp	r2, #1
 8015b02:	d93c      	bls.n	8015b7e <cblas_cherk+0x21e>
 8015b04:	2002      	movs	r0, #2
 8015b06:	e751      	b.n	80159ac <cblas_cherk+0x4c>
 8015b08:	2e01      	cmp	r6, #1
 8015b0a:	4630      	mov	r0, r6
 8015b0c:	bfb8      	it	lt
 8015b0e:	2001      	movlt	r0, #1
 8015b10:	4580      	cmp	r8, r0
 8015b12:	bfb4      	ite	lt
 8015b14:	200b      	movlt	r0, #11
 8015b16:	2008      	movge	r0, #8
 8015b18:	4ab4      	ldr	r2, [pc, #720]	; (8015dec <cblas_cherk+0x48c>)
 8015b1a:	49b5      	ldr	r1, [pc, #724]	; (8015df0 <cblas_cherk+0x490>)
 8015b1c:	f012 fdf4 	bl	8028708 <cblas_xerbla>
  if (beta == 1.0 && (alpha == 0.0 || K == 0))
 8015b20:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015b24:	eef4 8a67 	vcmp.f32	s17, s15
 8015b28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b2c:	f47f af5c 	bne.w	80159e8 <cblas_cherk+0x88>
 8015b30:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8015b34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015b38:	d0da      	beq.n	8015af0 <cblas_cherk+0x190>
 8015b3a:	2d00      	cmp	r5, #0
 8015b3c:	d0d8      	beq.n	8015af0 <cblas_cherk+0x190>
  if (Order == CblasRowMajor) {
 8015b3e:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8015b42:	f47f af55 	bne.w	80159f0 <cblas_cherk+0x90>
    for (i = 0; i < N; i++) {
 8015b46:	2e00      	cmp	r6, #0
    uplo = Uplo;
 8015b48:	4650      	mov	r0, sl
    for (i = 0; i < N; i++) {
 8015b4a:	dd49      	ble.n	8015be0 <cblas_cherk+0x280>
 8015b4c:	f108 0101 	add.w	r1, r8, #1
 8015b50:	9a01      	ldr	r2, [sp, #4]
      IMAG(C, ldc * i + i) = 0.0;
 8015b52:	f04f 0c00 	mov.w	ip, #0
 8015b56:	00c9      	lsls	r1, r1, #3
    for (i = 0; i < N; i++) {
 8015b58:	2300      	movs	r3, #0
 8015b5a:	3301      	adds	r3, #1
 8015b5c:	429e      	cmp	r6, r3
      IMAG(C, ldc * i + i) = 0.0;
 8015b5e:	f8c2 c004 	str.w	ip, [r2, #4]
    for (i = 0; i < N; i++) {
 8015b62:	440a      	add	r2, r1
 8015b64:	dcf9      	bgt.n	8015b5a <cblas_cherk+0x1fa>
 8015b66:	e03b      	b.n	8015be0 <cblas_cherk+0x280>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8015b68:	42a3      	cmp	r3, r4
 8015b6a:	dccd      	bgt.n	8015b08 <cblas_cherk+0x1a8>
 8015b6c:	2e01      	cmp	r6, #1
 8015b6e:	4630      	mov	r0, r6
 8015b70:	bfb8      	it	lt
 8015b72:	2001      	movlt	r0, #1
 8015b74:	4580      	cmp	r8, r0
 8015b76:	bfb4      	ite	lt
 8015b78:	200b      	movlt	r0, #11
 8015b7a:	2005      	movge	r0, #5
 8015b7c:	e7cc      	b.n	8015b18 <cblas_cherk+0x1b8>
 8015b7e:	f1a9 0065 	sub.w	r0, r9, #101	; 0x65
 8015b82:	2801      	cmp	r0, #1
 8015b84:	bf94      	ite	ls
 8015b86:	2000      	movls	r0, #0
 8015b88:	2001      	movhi	r0, #1
 8015b8a:	e70a      	b.n	80159a2 <cblas_cherk+0x42>
 8015b8c:	2a6f      	cmp	r2, #111	; 0x6f
 8015b8e:	f000 80c0 	beq.w	8015d12 <cblas_cherk+0x3b2>
 8015b92:	4633      	mov	r3, r6
 8015b94:	e6ff      	b.n	8015996 <cblas_cherk+0x36>
  if (beta == 0.0) {
 8015b96:	eef5 8a40 	vcmp.f32	s17, #0.0
 8015b9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    uplo = Uplo;
 8015b9e:	4650      	mov	r0, sl
  if (beta == 0.0) {
 8015ba0:	f040 8179 	bne.w	8015e96 <cblas_cherk+0x536>
    if (uplo == CblasUpper) {
 8015ba4:	2879      	cmp	r0, #121	; 0x79
 8015ba6:	f000 823d 	beq.w	8016024 <cblas_cherk+0x6c4>
      for (i = 0; i < N; i++) {
 8015baa:	2e00      	cmp	r6, #0
 8015bac:	dd4e      	ble.n	8015c4c <cblas_cherk+0x2ec>
 8015bae:	9b01      	ldr	r3, [sp, #4]
 8015bb0:	f108 0901 	add.w	r9, r8, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015bb4:	f04f 0c00 	mov.w	ip, #0
 8015bb8:	4619      	mov	r1, r3
          REAL(C, ldc * i + j) = 0.0;
 8015bba:	2200      	movs	r2, #0
 8015bbc:	ea4f 09c9 	mov.w	r9, r9, lsl #3
      for (i = 0; i < N; i++) {
 8015bc0:	46e6      	mov	lr, ip
 8015bc2:	3108      	adds	r1, #8
 8015bc4:	469a      	mov	sl, r3
 8015bc6:	eb0a 03cc 	add.w	r3, sl, ip, lsl #3
          REAL(C, ldc * i + j) = 0.0;
 8015bca:	601a      	str	r2, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8015bcc:	605a      	str	r2, [r3, #4]
        for (j = 0; j <= i; j++) {
 8015bce:	3308      	adds	r3, #8
 8015bd0:	4299      	cmp	r1, r3
 8015bd2:	d1fa      	bne.n	8015bca <cblas_cherk+0x26a>
      for (i = 0; i < N; i++) {
 8015bd4:	f10e 0e01 	add.w	lr, lr, #1
 8015bd8:	4576      	cmp	r6, lr
 8015bda:	44c4      	add	ip, r8
 8015bdc:	4449      	add	r1, r9
 8015bde:	dcf2      	bgt.n	8015bc6 <cblas_cherk+0x266>
  if (alpha == 0.0)
 8015be0:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8015be4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015be8:	d082      	beq.n	8015af0 <cblas_cherk+0x190>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 8015bea:	2879      	cmp	r0, #121	; 0x79
 8015bec:	f43f af2d 	beq.w	8015a4a <cblas_cherk+0xea>
      }
    }

  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8015bf0:	287a      	cmp	r0, #122	; 0x7a
 8015bf2:	d031      	beq.n	8015c58 <cblas_cherk+0x2f8>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 8015bf4:	4a7f      	ldr	r2, [pc, #508]	; (8015df4 <cblas_cherk+0x494>)
 8015bf6:	497e      	ldr	r1, [pc, #504]	; (8015df0 <cblas_cherk+0x490>)
 8015bf8:	2000      	movs	r0, #0
 8015bfa:	b007      	add	sp, #28
 8015bfc:	ecbd 8b02 	vpop	{d8}
 8015c00:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015c04:	f012 bd80 	b.w	8028708 <cblas_xerbla>
  } else if (beta != 1.0) {
 8015c08:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015c0c:	eef4 8a67 	vcmp.f32	s17, s15
 8015c10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c14:	f040 810b 	bne.w	8015e2e <cblas_cherk+0x4ce>
    for (i = 0; i < N; i++) {
 8015c18:	2e00      	cmp	r6, #0
 8015c1a:	f77f af69 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015c1e:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015c22:	2079      	movs	r0, #121	; 0x79
 8015c24:	e792      	b.n	8015b4c <cblas_cherk+0x1ec>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8015c26:	200b      	movs	r0, #11
 8015c28:	e776      	b.n	8015b18 <cblas_cherk+0x1b8>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015c2a:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8015c2e:	f000 80f4 	beq.w	8015e1a <cblas_cherk+0x4ba>
  if (beta == 0.0) {
 8015c32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c36:	f040 80e1 	bne.w	8015dfc <cblas_cherk+0x49c>
      for (i = 0; i < N; i++) {
 8015c3a:	2e00      	cmp	r6, #0
 8015c3c:	f77f af58 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015c40:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015c44:	207a      	movs	r0, #122	; 0x7a
 8015c46:	e7b2      	b.n	8015bae <cblas_cherk+0x24e>
 8015c48:	e9dd 0b02 	ldrd	r0, fp, [sp, #8]
  if (alpha == 0.0)
 8015c4c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8015c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015c54:	d1cc      	bne.n	8015bf0 <cblas_cherk+0x290>
 8015c56:	e74b      	b.n	8015af0 <cblas_cherk+0x190>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8015c58:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8015c5c:	f000 8178 	beq.w	8015f50 <cblas_cherk+0x5f0>
  } else if (uplo == CblasLower && trans == CblasConjTrans) {
 8015c60:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8015c64:	d1c6      	bne.n	8015bf4 <cblas_cherk+0x294>
    for (i = 0; i < N; i++) {
 8015c66:	2e00      	cmp	r6, #0
 8015c68:	f77f af42 	ble.w	8015af0 <cblas_cherk+0x190>
 8015c6c:	9b01      	ldr	r3, [sp, #4]
 8015c6e:	3304      	adds	r3, #4
 8015c70:	00e0      	lsls	r0, r4, #3
 8015c72:	f107 0a04 	add.w	sl, r7, #4
 8015c76:	f04f 0b00 	mov.w	fp, #0
 8015c7a:	f04f 0901 	mov.w	r9, #1
 8015c7e:	9302      	str	r3, [sp, #8]
 8015c80:	9b01      	ldr	r3, [sp, #4]
 8015c82:	eb03 0ccb 	add.w	ip, r3, fp, lsl #3
 8015c86:	9b02      	ldr	r3, [sp, #8]
      for (j = 0; j <= i; j++) {
 8015c88:	f04f 0e00 	mov.w	lr, #0
 8015c8c:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
        BASE temp_imag = 0.0;
 8015c90:	ed9f 5a55 	vldr	s10, [pc, #340]	; 8015de8 <cblas_cherk+0x488>
        for (k = 0; k < K; k++) {
 8015c94:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 8015c96:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 8015c9a:	dd1c      	ble.n	8015cd6 <cblas_cherk+0x376>
 8015c9c:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 8015ca0:	4653      	mov	r3, sl
 8015ca2:	2100      	movs	r1, #0
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 8015ca4:	edd3 7a00 	vldr	s15, [r3]
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8015ca8:	edd2 6a01 	vldr	s13, [r2, #4]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8015cac:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8015cb0:	ed13 6a01 	vldr	s12, [r3, #-4]
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8015cb4:	ee27 7aa6 	vmul.f32	s14, s15, s13
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015cb8:	ee67 7ae5 	vnmul.f32	s15, s15, s11
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8015cbc:	eea6 7a25 	vfma.f32	s14, s12, s11
        for (k = 0; k < K; k++) {
 8015cc0:	3101      	adds	r1, #1
 8015cc2:	428d      	cmp	r5, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015cc4:	eee6 7a26 	vfma.f32	s15, s12, s13
 8015cc8:	4402      	add	r2, r0
 8015cca:	4403      	add	r3, r0
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8015ccc:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015cd0:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 8015cd4:	d1e6      	bne.n	8015ca4 <cblas_cherk+0x344>
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015cd6:	ed54 7a01 	vldr	s15, [r4, #-4]
 8015cda:	eee8 7a24 	vfma.f32	s15, s16, s9
      for (j = 0; j <= i; j++) {
 8015cde:	f10e 0e01 	add.w	lr, lr, #1
 8015ce2:	45ce      	cmp	lr, r9
 8015ce4:	f104 0408 	add.w	r4, r4, #8
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015ce8:	ed44 7a03 	vstr	s15, [r4, #-12]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015cec:	eddc 7a01 	vldr	s15, [ip, #4]
 8015cf0:	eee8 7a05 	vfma.f32	s15, s16, s10
 8015cf4:	f10c 0c08 	add.w	ip, ip, #8
 8015cf8:	ed4c 7a01 	vstr	s15, [ip, #-4]
      for (j = 0; j <= i; j++) {
 8015cfc:	d1c8      	bne.n	8015c90 <cblas_cherk+0x330>
    for (i = 0; i < N; i++) {
 8015cfe:	454e      	cmp	r6, r9
 8015d00:	44c3      	add	fp, r8
 8015d02:	f10a 0a08 	add.w	sl, sl, #8
 8015d06:	f109 0301 	add.w	r3, r9, #1
 8015d0a:	f43f aef1 	beq.w	8015af0 <cblas_cherk+0x190>
 8015d0e:	4699      	mov	r9, r3
 8015d10:	e7b6      	b.n	8015c80 <cblas_cherk+0x320>
 8015d12:	462b      	mov	r3, r5
 8015d14:	e6f2      	b.n	8015afc <cblas_cherk+0x19c>
  if (beta == 0.0) {
 8015d16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015d1a:	f000 8176 	beq.w	801600a <cblas_cherk+0x6aa>
  } else if (beta != 1.0) {
 8015d1e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015d22:	eef4 8a67 	vcmp.f32	s17, s15
 8015d26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015d2a:	f040 80f2 	bne.w	8015f12 <cblas_cherk+0x5b2>
    for (i = 0; i < N; i++) {
 8015d2e:	2e00      	cmp	r6, #0
 8015d30:	f77f aede 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015d34:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015d38:	2079      	movs	r0, #121	; 0x79
 8015d3a:	e707      	b.n	8015b4c <cblas_cherk+0x1ec>
    for (i = 0; i < N; i++) {
 8015d3c:	2e00      	cmp	r6, #0
 8015d3e:	f77f aed7 	ble.w	8015af0 <cblas_cherk+0x190>
 8015d42:	f108 0801 	add.w	r8, r8, #1
 8015d46:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 8015d4a:	f04f 0a00 	mov.w	sl, #0
 8015d4e:	9302      	str	r3, [sp, #8]
 8015d50:	00e3      	lsls	r3, r4, #3
 8015d52:	f8dd b004 	ldr.w	fp, [sp, #4]
 8015d56:	9301      	str	r3, [sp, #4]
 8015d58:	46d1      	mov	r9, sl
 8015d5a:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
 8015d5e:	46b8      	mov	r8, r7
        BASE temp_real = 0.0;
 8015d60:	46d6      	mov	lr, sl
 8015d62:	4658      	mov	r0, fp
 8015d64:	46cc      	mov	ip, r9
        BASE temp_imag = 0.0;
 8015d66:	ed9f 5a20 	vldr	s10, [pc, #128]	; 8015de8 <cblas_cherk+0x488>
        for (k = 0; k < K; k++) {
 8015d6a:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 8015d6c:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 8015d70:	dd1b      	ble.n	8015daa <cblas_cherk+0x44a>
 8015d72:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 8015d76:	4643      	mov	r3, r8
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8015d78:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 8015d7c:	ed92 6a01 	vldr	s12, [r2, #4]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8015d80:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8015d84:	edd3 6a00 	vldr	s13, [r3]
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015d88:	ee26 7a27 	vmul.f32	s14, s12, s15
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8015d8c:	ee67 7aa5 	vmul.f32	s15, s15, s11
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015d90:	eea6 7aa5 	vfma.f32	s14, s13, s11
 8015d94:	3308      	adds	r3, #8
        for (k = 0; k < K; k++) {
 8015d96:	4299      	cmp	r1, r3
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8015d98:	eee6 7a66 	vfms.f32	s15, s12, s13
 8015d9c:	f102 0208 	add.w	r2, r2, #8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015da0:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8015da4:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 8015da8:	d1e6      	bne.n	8015d78 <cblas_cherk+0x418>
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015daa:	ed90 7a00 	vldr	s14, [r0]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015dae:	edd0 7a01 	vldr	s15, [r0, #4]
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015db2:	eea4 7a88 	vfma.f32	s14, s9, s16
      for (j = i; j < N; j++) {
 8015db6:	f10c 0c01 	add.w	ip, ip, #1
 8015dba:	4566      	cmp	r6, ip
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015dbc:	eee8 7a05 	vfma.f32	s15, s16, s10
 8015dc0:	44a6      	add	lr, r4
 8015dc2:	f100 0008 	add.w	r0, r0, #8
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015dc6:	ed00 7a02 	vstr	s14, [r0, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015dca:	ed40 7a01 	vstr	s15, [r0, #-4]
      for (j = i; j < N; j++) {
 8015dce:	dcca      	bgt.n	8015d66 <cblas_cherk+0x406>
    for (i = 0; i < N; i++) {
 8015dd0:	9b02      	ldr	r3, [sp, #8]
 8015dd2:	f109 0901 	add.w	r9, r9, #1
 8015dd6:	449b      	add	fp, r3
 8015dd8:	9b01      	ldr	r3, [sp, #4]
 8015dda:	454e      	cmp	r6, r9
 8015ddc:	44a2      	add	sl, r4
 8015dde:	4498      	add	r8, r3
 8015de0:	4419      	add	r1, r3
 8015de2:	d1bd      	bne.n	8015d60 <cblas_cherk+0x400>
 8015de4:	e684      	b.n	8015af0 <cblas_cherk+0x190>
 8015de6:	bf00      	nop
 8015de8:	00000000 	.word	0x00000000
 8015dec:	08031108 	.word	0x08031108
 8015df0:	08031350 	.word	0x08031350
 8015df4:	080311b8 	.word	0x080311b8
 8015df8:	00000000 	.word	0x00000000
  } else if (beta != 1.0) {
 8015dfc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015e00:	eef4 8a67 	vcmp.f32	s17, s15
 8015e04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e08:	f000 8097 	beq.w	8015f3a <cblas_cherk+0x5da>
      for (i = 0; i < N; i++) {
 8015e0c:	2e00      	cmp	r6, #0
 8015e0e:	f77f ae6f 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015e12:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015e16:	207a      	movs	r0, #122	; 0x7a
 8015e18:	e042      	b.n	8015ea0 <cblas_cherk+0x540>
  if (beta == 0.0) {
 8015e1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e1e:	d17e      	bne.n	8015f1e <cblas_cherk+0x5be>
      for (i = 0; i < N; i++) {
 8015e20:	2e00      	cmp	r6, #0
 8015e22:	f77f ae65 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015e26:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015e2a:	207a      	movs	r0, #122	; 0x7a
 8015e2c:	e6bf      	b.n	8015bae <cblas_cherk+0x24e>
      for (i = 0; i < N; i++) {
 8015e2e:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015e30:	bfc8      	it	gt
 8015e32:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8015e36:	f77f ae5b 	ble.w	8015af0 <cblas_cherk+0x190>
 8015e3a:	9b01      	ldr	r3, [sp, #4]
 8015e3c:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8015e40:	f1a3 0208 	sub.w	r2, r3, #8
        IMAG(C, ldc * i + i) = 0;
 8015e44:	f04f 0900 	mov.w	r9, #0
 8015e48:	f100 0c08 	add.w	ip, r0, #8
 8015e4c:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8015e50:	1d19      	adds	r1, r3, #4
      for (i = 0; i < N; i++) {
 8015e52:	f04f 0e00 	mov.w	lr, #0
        REAL(C, ldc * i + i) *= beta;
 8015e56:	ed51 7a01 	vldr	s15, [r1, #-4]
        IMAG(C, ldc * i + i) = 0;
 8015e5a:	f8c1 9000 	str.w	r9, [r1]
        REAL(C, ldc * i + i) *= beta;
 8015e5e:	ee67 7aa8 	vmul.f32	s15, s15, s17
        for (j = i + 1; j < N; j++) {
 8015e62:	f10e 0e01 	add.w	lr, lr, #1
 8015e66:	4576      	cmp	r6, lr
        REAL(C, ldc * i + i) *= beta;
 8015e68:	ed41 7a01 	vstr	s15, [r1, #-4]
        for (j = i + 1; j < N; j++) {
 8015e6c:	f77f ade8 	ble.w	8015a40 <cblas_cherk+0xe0>
 8015e70:	1f0b      	subs	r3, r1, #4
          REAL(C, ldc * i + j) *= beta;
 8015e72:	ed93 7a02 	vldr	s14, [r3, #8]
          IMAG(C, ldc * i + j) *= beta;
 8015e76:	edd3 7a03 	vldr	s15, [r3, #12]
          REAL(C, ldc * i + j) *= beta;
 8015e7a:	ee27 7a28 	vmul.f32	s14, s14, s17
          IMAG(C, ldc * i + j) *= beta;
 8015e7e:	ee67 7aa8 	vmul.f32	s15, s15, s17
          REAL(C, ldc * i + j) *= beta;
 8015e82:	ed83 7a02 	vstr	s14, [r3, #8]
          IMAG(C, ldc * i + j) *= beta;
 8015e86:	edc3 7a03 	vstr	s15, [r3, #12]
        for (j = i + 1; j < N; j++) {
 8015e8a:	3308      	adds	r3, #8
 8015e8c:	429a      	cmp	r2, r3
 8015e8e:	d1f0      	bne.n	8015e72 <cblas_cherk+0x512>
 8015e90:	4402      	add	r2, r0
 8015e92:	4461      	add	r1, ip
 8015e94:	e7df      	b.n	8015e56 <cblas_cherk+0x4f6>
    if (uplo == CblasUpper) {
 8015e96:	2879      	cmp	r0, #121	; 0x79
 8015e98:	d056      	beq.n	8015f48 <cblas_cherk+0x5e8>
      for (i = 0; i < N; i++) {
 8015e9a:	2e00      	cmp	r6, #0
 8015e9c:	f77f aed6 	ble.w	8015c4c <cblas_cherk+0x2ec>
        for (j = 0; j < i; j++) {
 8015ea0:	9b01      	ldr	r3, [sp, #4]
        IMAG(C, ldc * i + i) = 0;
 8015ea2:	ed1f 7a2b 	vldr	s14, [pc, #-172]	; 8015df8 <cblas_cherk+0x498>
 8015ea6:	1d1a      	adds	r2, r3, #4
 8015ea8:	9202      	str	r2, [sp, #8]
 8015eaa:	9a02      	ldr	r2, [sp, #8]
 8015eac:	f108 0101 	add.w	r1, r8, #1
 8015eb0:	e9cd 0b02 	strd	r0, fp, [sp, #8]
 8015eb4:	ea4f 0ac1 	mov.w	sl, r1, lsl #3
 8015eb8:	4694      	mov	ip, r2
 8015eba:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
      for (i = 0; i < N; i++) {
 8015ebe:	46c6      	mov	lr, r8
      for (i = 0; i < N; i++) {
 8015ec0:	f04f 0900 	mov.w	r9, #0
 8015ec4:	4618      	mov	r0, r3
 8015ec6:	4693      	mov	fp, r2
        REAL(C, ldc * i + i) *= beta;
 8015ec8:	ed5c 7a01 	vldr	s15, [ip, #-4]
        IMAG(C, ldc * i + i) = 0;
 8015ecc:	ed8c 7a00 	vstr	s14, [ip]
        REAL(C, ldc * i + i) *= beta;
 8015ed0:	ee67 7aa8 	vmul.f32	s15, s15, s17
      for (i = 0; i < N; i++) {
 8015ed4:	f109 0901 	add.w	r9, r9, #1
 8015ed8:	454e      	cmp	r6, r9
        REAL(C, ldc * i + i) *= beta;
 8015eda:	ed4c 7a01 	vstr	s15, [ip, #-4]
      for (i = 0; i < N; i++) {
 8015ede:	f77f aeb3 	ble.w	8015c48 <cblas_cherk+0x2e8>
        for (j = 0; j < i; j++) {
 8015ee2:	eb00 03ce 	add.w	r3, r0, lr, lsl #3
 8015ee6:	eb0b 02ce 	add.w	r2, fp, lr, lsl #3
          REAL(C, ldc * i + j) *= beta;
 8015eea:	ed52 7a01 	vldr	s15, [r2, #-4]
 8015eee:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8015ef2:	3308      	adds	r3, #8
 8015ef4:	ed42 7a01 	vstr	s15, [r2, #-4]
          IMAG(C, ldc * i + j) *= beta;
 8015ef8:	ed53 7a01 	vldr	s15, [r3, #-4]
 8015efc:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8015f00:	3208      	adds	r2, #8
 8015f02:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < i; j++) {
 8015f06:	4299      	cmp	r1, r3
 8015f08:	d1ef      	bne.n	8015eea <cblas_cherk+0x58a>
 8015f0a:	44c6      	add	lr, r8
 8015f0c:	4451      	add	r1, sl
 8015f0e:	44d4      	add	ip, sl
 8015f10:	e7da      	b.n	8015ec8 <cblas_cherk+0x568>
      for (i = 0; i < N; i++) {
 8015f12:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015f14:	bfc8      	it	gt
 8015f16:	f04f 0b71 	movgt.w	fp, #113	; 0x71
      for (i = 0; i < N; i++) {
 8015f1a:	dc8e      	bgt.n	8015e3a <cblas_cherk+0x4da>
 8015f1c:	e5e8      	b.n	8015af0 <cblas_cherk+0x190>
  } else if (beta != 1.0) {
 8015f1e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015f22:	eef4 8a67 	vcmp.f32	s17, s15
 8015f26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f2a:	d075      	beq.n	8016018 <cblas_cherk+0x6b8>
      for (i = 0; i < N; i++) {
 8015f2c:	2e00      	cmp	r6, #0
 8015f2e:	f77f addf 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015f32:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015f36:	207a      	movs	r0, #122	; 0x7a
 8015f38:	e7b2      	b.n	8015ea0 <cblas_cherk+0x540>
    for (i = 0; i < N; i++) {
 8015f3a:	2e00      	cmp	r6, #0
 8015f3c:	f77f add8 	ble.w	8015af0 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015f40:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015f44:	207a      	movs	r0, #122	; 0x7a
 8015f46:	e601      	b.n	8015b4c <cblas_cherk+0x1ec>
      for (i = 0; i < N; i++) {
 8015f48:	2e00      	cmp	r6, #0
 8015f4a:	f73f af76 	bgt.w	8015e3a <cblas_cherk+0x4da>
 8015f4e:	e577      	b.n	8015a40 <cblas_cherk+0xe0>
    for (i = 0; i < N; i++) {
 8015f50:	2e00      	cmp	r6, #0
 8015f52:	f77f adcd 	ble.w	8015af0 <cblas_cherk+0x190>
 8015f56:	f108 0301 	add.w	r3, r8, #1
 8015f5a:	00db      	lsls	r3, r3, #3
 8015f5c:	9303      	str	r3, [sp, #12]
 8015f5e:	9b01      	ldr	r3, [sp, #4]
 8015f60:	f04f 0b00 	mov.w	fp, #0
 8015f64:	f103 0908 	add.w	r9, r3, #8
 8015f68:	00e2      	lsls	r2, r4, #3
 8015f6a:	3304      	adds	r3, #4
 8015f6c:	e9cd 6804 	strd	r6, r8, [sp, #16]
 8015f70:	46de      	mov	lr, fp
 8015f72:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
 8015f76:	46ba      	mov	sl, r7
 8015f78:	9302      	str	r3, [sp, #8]
 8015f7a:	4690      	mov	r8, r2
 8015f7c:	9b01      	ldr	r3, [sp, #4]
 8015f7e:	eb03 00cb 	add.w	r0, r3, fp, lsl #3
 8015f82:	9b02      	ldr	r3, [sp, #8]
        BASE temp_real = 0.0;
 8015f84:	f04f 0c00 	mov.w	ip, #0
 8015f88:	eb03 06cb 	add.w	r6, r3, fp, lsl #3
        BASE temp_imag = 0.0;
 8015f8c:	ed1f 5a66 	vldr	s10, [pc, #-408]	; 8015df8 <cblas_cherk+0x498>
        for (k = 0; k < K; k++) {
 8015f90:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 8015f92:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 8015f96:	dd1b      	ble.n	8015fd0 <cblas_cherk+0x670>
 8015f98:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 8015f9c:	4653      	mov	r3, sl
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8015f9e:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 8015fa2:	ed92 6a01 	vldr	s12, [r2, #4]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8015fa6:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8015faa:	edd3 6a00 	vldr	s13, [r3]
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015fae:	ee26 7a27 	vmul.f32	s14, s12, s15
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8015fb2:	ee67 7aa5 	vmul.f32	s15, s15, s11
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015fb6:	eea6 7aa5 	vfma.f32	s14, s13, s11
 8015fba:	3308      	adds	r3, #8
        for (k = 0; k < K; k++) {
 8015fbc:	4299      	cmp	r1, r3
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8015fbe:	eee6 7a66 	vfms.f32	s15, s12, s13
 8015fc2:	f102 0208 	add.w	r2, r2, #8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015fc6:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8015fca:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 8015fce:	d1e6      	bne.n	8015f9e <cblas_cherk+0x63e>
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015fd0:	ed56 7a01 	vldr	s15, [r6, #-4]
 8015fd4:	eee8 7a24 	vfma.f32	s15, s16, s9
 8015fd8:	3008      	adds	r0, #8
 8015fda:	44a4      	add	ip, r4
 8015fdc:	3608      	adds	r6, #8
 8015fde:	ed46 7a03 	vstr	s15, [r6, #-12]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015fe2:	ed50 7a01 	vldr	s15, [r0, #-4]
 8015fe6:	eee8 7a05 	vfma.f32	s15, s16, s10
 8015fea:	ed40 7a01 	vstr	s15, [r0, #-4]
      for (j = 0; j <= i; j++) {
 8015fee:	4581      	cmp	r9, r0
 8015ff0:	d1cc      	bne.n	8015f8c <cblas_cherk+0x62c>
    for (i = 0; i < N; i++) {
 8015ff2:	9b05      	ldr	r3, [sp, #20]
 8015ff4:	449b      	add	fp, r3
 8015ff6:	9b03      	ldr	r3, [sp, #12]
 8015ff8:	4499      	add	r9, r3
 8015ffa:	9b04      	ldr	r3, [sp, #16]
 8015ffc:	f10e 0e01 	add.w	lr, lr, #1
 8016000:	4573      	cmp	r3, lr
 8016002:	44c2      	add	sl, r8
 8016004:	4441      	add	r1, r8
 8016006:	d1b9      	bne.n	8015f7c <cblas_cherk+0x61c>
 8016008:	e572      	b.n	8015af0 <cblas_cherk+0x190>
      for (i = 0; i < N; i++) {
 801600a:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801600c:	bfc8      	it	gt
 801600e:	f04f 0b71 	movgt.w	fp, #113	; 0x71
      for (i = 0; i < N; i++) {
 8016012:	f73f ad00 	bgt.w	8015a16 <cblas_cherk+0xb6>
 8016016:	e56b      	b.n	8015af0 <cblas_cherk+0x190>
    for (i = 0; i < N; i++) {
 8016018:	2e00      	cmp	r6, #0
 801601a:	dd07      	ble.n	801602c <cblas_cherk+0x6cc>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801601c:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8016020:	207a      	movs	r0, #122	; 0x7a
 8016022:	e593      	b.n	8015b4c <cblas_cherk+0x1ec>
      for (i = 0; i < N; i++) {
 8016024:	2e00      	cmp	r6, #0
 8016026:	f73f acf6 	bgt.w	8015a16 <cblas_cherk+0xb6>
 801602a:	e509      	b.n	8015a40 <cblas_cherk+0xe0>
  if (alpha == 0.0)
 801602c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8016030:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016034:	f47f ae17 	bne.w	8015c66 <cblas_cherk+0x306>
 8016038:	e55a      	b.n	8015af0 <cblas_cherk+0x190>
 801603a:	bf00      	nop

0801603c <cblas_cscal>:
  INDEX i;
  INDEX ix = 0;
  const BASE alpha_real = CONST_REAL0(alpha);
  const BASE alpha_imag = CONST_IMAG0(alpha);

  if (incX <= 0) {
 801603c:	2b00      	cmp	r3, #0
 801603e:	dd21      	ble.n	8016084 <cblas_cscal+0x48>
    return;
  }

  for (i = 0; i < N; i++) {
 8016040:	2800      	cmp	r0, #0
 8016042:	dd1f      	ble.n	8016084 <cblas_cscal+0x48>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_cscal (const int N, const void *alpha, void *X, const int incX)
{
 8016044:	b410      	push	{r4}
  const BASE alpha_real = CONST_REAL0(alpha);
 8016046:	edd1 5a00 	vldr	s11, [r1]
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801604a:	ed91 6a01 	vldr	s12, [r1, #4]
 801604e:	00dc      	lsls	r4, r3, #3
  for (i = 0; i < N; i++) {
 8016050:	2100      	movs	r1, #0
 8016052:	1d13      	adds	r3, r2, #4
    const BASE x_real = REAL(X, ix);
    const BASE x_imag = IMAG(X, ix);
 8016054:	edd2 7a01 	vldr	s15, [r2, #4]
    const BASE x_real = REAL(X, ix);
 8016058:	ed53 6a01 	vldr	s13, [r3, #-4]
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 801605c:	ee27 7ac6 	vnmul.f32	s14, s15, s12
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 8016060:	ee65 7aa7 	vmul.f32	s15, s11, s15
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 8016064:	eea5 7aa6 	vfma.f32	s14, s11, s13
  for (i = 0; i < N; i++) {
 8016068:	3101      	adds	r1, #1
 801606a:	4288      	cmp	r0, r1
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 801606c:	eee6 7a26 	vfma.f32	s15, s12, s13
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 8016070:	ed03 7a01 	vstr	s14, [r3, #-4]
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 8016074:	edc2 7a01 	vstr	s15, [r2, #4]
  for (i = 0; i < N; i++) {
 8016078:	4423      	add	r3, r4
 801607a:	4422      	add	r2, r4
 801607c:	d1ea      	bne.n	8016054 <cblas_cscal+0x18>
#define BASE float
#include "source_scal_c.h"
#undef BASE
}
 801607e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016082:	4770      	bx	lr
 8016084:	4770      	bx	lr
 8016086:	bf00      	nop

08016088 <cblas_csscal>:

{
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 8016088:	2a00      	cmp	r2, #0
 801608a:	dd19      	ble.n	80160c0 <cblas_csscal+0x38>
    return;
  }

  for (i = 0; i < N; i++) {
 801608c:	2800      	cmp	r0, #0
 801608e:	dd17      	ble.n	80160c0 <cblas_csscal+0x38>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_csscal (const int N, const float alpha, void *X, const int incX)
{
 8016090:	b410      	push	{r4}
 8016092:	1d0b      	adds	r3, r1, #4
 8016094:	00d4      	lsls	r4, r2, #3
 8016096:	2200      	movs	r2, #0
    REAL(X, ix) *= alpha;
 8016098:	ed53 7a01 	vldr	s15, [r3, #-4]
 801609c:	ee67 7a80 	vmul.f32	s15, s15, s0
  for (i = 0; i < N; i++) {
 80160a0:	3201      	adds	r2, #1
    REAL(X, ix) *= alpha;
 80160a2:	ed43 7a01 	vstr	s15, [r3, #-4]
    IMAG(X, ix) *= alpha;
 80160a6:	edd1 7a01 	vldr	s15, [r1, #4]
 80160aa:	ee67 7a80 	vmul.f32	s15, s15, s0
  for (i = 0; i < N; i++) {
 80160ae:	4290      	cmp	r0, r2
    IMAG(X, ix) *= alpha;
 80160b0:	edc1 7a01 	vstr	s15, [r1, #4]
  for (i = 0; i < N; i++) {
 80160b4:	4423      	add	r3, r4
 80160b6:	4421      	add	r1, r4
 80160b8:	d1ee      	bne.n	8016098 <cblas_csscal+0x10>
#define BASE float
#include "source_scal_c_s.h"
#undef BASE
}
 80160ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 80160be:	4770      	bx	lr
 80160c0:	4770      	bx	lr
 80160c2:	bf00      	nop

080160c4 <cblas_cswap>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_cswap (const int N, void *X, const int incX, void *Y, const int incY)
{
 80160c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80160c8:	2a00      	cmp	r2, #0
 80160ca:	9f06      	ldr	r7, [sp, #24]
 80160cc:	bfda      	itte	le
 80160ce:	f1c0 0e01 	rsble	lr, r0, #1
 80160d2:	fb0e fe02 	mulle.w	lr, lr, r2
 80160d6:	f04f 0e00 	movgt.w	lr, #0
  INDEX iy = OFFSET(N, incY);
 80160da:	2f00      	cmp	r7, #0
 80160dc:	bfda      	itte	le
 80160de:	f1c0 0c01 	rsble	ip, r0, #1
 80160e2:	fb0c fc07 	mulle.w	ip, ip, r7
 80160e6:	f04f 0c00 	movgt.w	ip, #0

  for (i = 0; i < N; i++) {
 80160ea:	2800      	cmp	r0, #0
 80160ec:	dd22      	ble.n	8016134 <cblas_cswap+0x70>
 80160ee:	eb03 04cc 	add.w	r4, r3, ip, lsl #3
 80160f2:	eb01 05ce 	add.w	r5, r1, lr, lsl #3
 80160f6:	00d6      	lsls	r6, r2, #3
 80160f8:	4623      	mov	r3, r4
 80160fa:	1d22      	adds	r2, r4, #4
 80160fc:	00ff      	lsls	r7, r7, #3
 80160fe:	3504      	adds	r5, #4
 8016100:	eb01 01ce 	add.w	r1, r1, lr, lsl #3
 8016104:	2400      	movs	r4, #0
    const BASE tmp_real = REAL(X, ix);
    const BASE tmp_imag = IMAG(X, ix);
    REAL(X, ix) = REAL(Y, iy);
 8016106:	f852 8c04 	ldr.w	r8, [r2, #-4]
    const BASE tmp_real = REAL(X, ix);
 801610a:	f855 ec04 	ldr.w	lr, [r5, #-4]
    const BASE tmp_imag = IMAG(X, ix);
 801610e:	f8d1 c004 	ldr.w	ip, [r1, #4]
    REAL(X, ix) = REAL(Y, iy);
 8016112:	f845 8c04 	str.w	r8, [r5, #-4]
  for (i = 0; i < N; i++) {
 8016116:	3401      	adds	r4, #1
    IMAG(X, ix) = IMAG(Y, iy);
 8016118:	f8d3 8004 	ldr.w	r8, [r3, #4]
 801611c:	f8c1 8004 	str.w	r8, [r1, #4]
  for (i = 0; i < N; i++) {
 8016120:	42a0      	cmp	r0, r4
    REAL(Y, iy) = tmp_real;
 8016122:	f842 ec04 	str.w	lr, [r2, #-4]
    IMAG(Y, iy) = tmp_imag;
 8016126:	4435      	add	r5, r6
 8016128:	f8c3 c004 	str.w	ip, [r3, #4]
  for (i = 0; i < N; i++) {
 801612c:	4431      	add	r1, r6
 801612e:	443a      	add	r2, r7
 8016130:	443b      	add	r3, r7
 8016132:	d1e8      	bne.n	8016106 <cblas_cswap+0x42>
#define BASE float
#include "source_swap_c.h"
#undef BASE
}
 8016134:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08016138 <cblas_csymm>:
void
cblas_csymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 8016138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801613c:	b08f      	sub	sp, #60	; 0x3c
 801613e:	469b      	mov	fp, r3
 8016140:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8016142:	9301      	str	r3, [sp, #4]
 8016144:	e9dd 7319 	ldrd	r7, r3, [sp, #100]	; 0x64
 8016148:	9303      	str	r3, [sp, #12]
 801614a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801614c:	9302      	str	r3, [sp, #8]
 801614e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8016150:	9304      	str	r3, [sp, #16]
 8016152:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8016154:	9306      	str	r3, [sp, #24]
 8016156:	e9dd 831e 	ldrd	r8, r3, [sp, #120]	; 0x78
{
  INDEX i, j, k;
  INDEX n1, n2;
  int uplo, side;

  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801615a:	298d      	cmp	r1, #141	; 0x8d
 801615c:	9307      	str	r3, [sp, #28]
 801615e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8016160:	9305      	str	r3, [sp, #20]
 8016162:	460c      	mov	r4, r1
 8016164:	4606      	mov	r6, r0
 8016166:	4615      	mov	r5, r2
 8016168:	f000 80dc 	beq.w	8016324 <cblas_csymm+0x1ec>
 801616c:	298e      	cmp	r1, #142	; 0x8e
 801616e:	f000 8451 	beq.w	8016a14 <cblas_csymm+0x8dc>
 8016172:	9b01      	ldr	r3, [sp, #4]
 8016174:	2002      	movs	r0, #2
 8016176:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 801617a:	2a01      	cmp	r2, #1
 801617c:	bf88      	it	hi
 801617e:	2003      	movhi	r0, #3
 8016180:	9a01      	ldr	r2, [sp, #4]
 8016182:	f1bb 0f00 	cmp.w	fp, #0
 8016186:	bfb8      	it	lt
 8016188:	2004      	movlt	r0, #4
 801618a:	2b01      	cmp	r3, #1
 801618c:	bfb8      	it	lt
 801618e:	2301      	movlt	r3, #1
 8016190:	2a00      	cmp	r2, #0
 8016192:	9a02      	ldr	r2, [sp, #8]
 8016194:	f2c0 80bb 	blt.w	801630e <cblas_csymm+0x1d6>
 8016198:	4293      	cmp	r3, r2
 801619a:	dd6b      	ble.n	8016274 <cblas_csymm+0x13c>
 801619c:	2e65      	cmp	r6, #101	; 0x65
 801619e:	f000 8259 	beq.w	8016654 <cblas_csymm+0x51c>
 80161a2:	2e66      	cmp	r6, #102	; 0x66
 80161a4:	f000 8428 	beq.w	80169f8 <cblas_csymm+0x8c0>
 80161a8:	2008      	movs	r0, #8
 80161aa:	4ac9      	ldr	r2, [pc, #804]	; (80164d0 <cblas_csymm+0x398>)
 80161ac:	49c9      	ldr	r1, [pc, #804]	; (80164d4 <cblas_csymm+0x39c>)
 80161ae:	f012 faab 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 80161b2:	edd7 4a00 	vldr	s9, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80161b6:	ed97 4a01 	vldr	s8, [r7, #4]
    const BASE beta_real = CONST_REAL0(beta);
 80161ba:	edd8 5a00 	vldr	s11, [r8]
    const BASE beta_imag = CONST_IMAG0(beta);
 80161be:	ed98 5a01 	vldr	s10, [r8, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 80161c2:	eef5 4a40 	vcmp.f32	s9, #0.0
 80161c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161ca:	d10b      	bne.n	80161e4 <cblas_csymm+0xac>
 80161cc:	eeb5 4a40 	vcmp.f32	s8, #0.0
 80161d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161d4:	d106      	bne.n	80161e4 <cblas_csymm+0xac>
        && (beta_real == 1.0 && beta_imag == 0.0))
 80161d6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80161da:	eef4 5a67 	vcmp.f32	s11, s15
 80161de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161e2:	d050      	beq.n	8016286 <cblas_csymm+0x14e>
      return;

    if (Order == CblasRowMajor) {
 80161e4:	2e65      	cmp	r6, #101	; 0x65
 80161e6:	f000 80a4 	beq.w	8016332 <cblas_csymm+0x1fa>
      uplo = Uplo;
      side = Side;
    } else {
      n1 = N;
      n2 = M;
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80161ea:	2d79      	cmp	r5, #121	; 0x79
 80161ec:	bf0c      	ite	eq
 80161ee:	257a      	moveq	r5, #122	; 0x7a
 80161f0:	2579      	movne	r5, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 80161f2:	2c8d      	cmp	r4, #141	; 0x8d
 80161f4:	bf0c      	ite	eq
 80161f6:	248e      	moveq	r4, #142	; 0x8e
 80161f8:	248d      	movne	r4, #141	; 0x8d
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 80161fa:	eef5 5a40 	vcmp.f32	s11, #0.0
 80161fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016202:	d148      	bne.n	8016296 <cblas_csymm+0x15e>
 8016204:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016208:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801620c:	d14f      	bne.n	80162ae <cblas_csymm+0x176>
      for (i = 0; i < n1; i++) {
 801620e:	9b01      	ldr	r3, [sp, #4]
 8016210:	2b00      	cmp	r3, #0
 8016212:	dd18      	ble.n	8016246 <cblas_csymm+0x10e>
 8016214:	9a05      	ldr	r2, [sp, #20]
 8016216:	00d6      	lsls	r6, r2, #3
 8016218:	9a07      	ldr	r2, [sp, #28]
 801621a:	ebcb 704b 	rsb	r0, fp, fp, lsl #29
 801621e:	00c0      	lsls	r0, r0, #3
 8016220:	eb02 02cb 	add.w	r2, r2, fp, lsl #3
 8016224:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8016226:	2700      	movs	r7, #0
 8016228:	469c      	mov	ip, r3
        for (j = 0; j < n2; j++) {
 801622a:	f1bb 0f00 	cmp.w	fp, #0
 801622e:	bfc8      	it	gt
 8016230:	1883      	addgt	r3, r0, r2
 8016232:	dd04      	ble.n	801623e <cblas_csymm+0x106>
          REAL(C, ldc * i + j) = 0.0;
 8016234:	601f      	str	r7, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8016236:	605f      	str	r7, [r3, #4]
        for (j = 0; j < n2; j++) {
 8016238:	3308      	adds	r3, #8
 801623a:	429a      	cmp	r2, r3
 801623c:	d1fa      	bne.n	8016234 <cblas_csymm+0xfc>
      for (i = 0; i < n1; i++) {
 801623e:	3101      	adds	r1, #1
 8016240:	458c      	cmp	ip, r1
 8016242:	4432      	add	r2, r6
 8016244:	d1f1      	bne.n	801622a <cblas_csymm+0xf2>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8016246:	eef5 4a40 	vcmp.f32	s9, #0.0
 801624a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801624e:	d104      	bne.n	801625a <cblas_csymm+0x122>
 8016250:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8016254:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016258:	d01a      	beq.n	8016290 <cblas_csymm+0x158>
      return;

    if (side == CblasLeft && uplo == CblasUpper) {
 801625a:	2c8d      	cmp	r4, #141	; 0x8d
 801625c:	d06e      	beq.n	801633c <cblas_csymm+0x204>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper) {
 801625e:	2c8e      	cmp	r4, #142	; 0x8e
 8016260:	f000 813e 	beq.w	80164e0 <cblas_csymm+0x3a8>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 8016264:	4a9c      	ldr	r2, [pc, #624]	; (80164d8 <cblas_csymm+0x3a0>)
 8016266:	499b      	ldr	r1, [pc, #620]	; (80164d4 <cblas_csymm+0x39c>)
 8016268:	2000      	movs	r0, #0
#define BASE float
#include "source_symm_c.h"
#undef BASE
}
 801626a:	b00f      	add	sp, #60	; 0x3c
 801626c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016270:	f012 ba4a 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8016274:	2e65      	cmp	r6, #101	; 0x65
 8016276:	f000 81fb 	beq.w	8016670 <cblas_csymm+0x538>
 801627a:	2e66      	cmp	r6, #102	; 0x66
 801627c:	f000 838b 	beq.w	8016996 <cblas_csymm+0x85e>
 8016280:	2800      	cmp	r0, #0
 8016282:	d096      	beq.n	80161b2 <cblas_csymm+0x7a>
 8016284:	e791      	b.n	80161aa <cblas_csymm+0x72>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8016286:	eeb5 5a40 	vcmp.f32	s10, #0.0
 801628a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801628e:	d1a9      	bne.n	80161e4 <cblas_csymm+0xac>
 8016290:	b00f      	add	sp, #60	; 0x3c
 8016292:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8016296:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801629a:	eef4 5a67 	vcmp.f32	s11, s15
 801629e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80162a2:	d104      	bne.n	80162ae <cblas_csymm+0x176>
 80162a4:	eeb5 5a40 	vcmp.f32	s10, #0.0
 80162a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80162ac:	d0cb      	beq.n	8016246 <cblas_csymm+0x10e>
      for (i = 0; i < n1; i++) {
 80162ae:	9901      	ldr	r1, [sp, #4]
 80162b0:	2900      	cmp	r1, #0
 80162b2:	ddc8      	ble.n	8016246 <cblas_csymm+0x10e>
 80162b4:	9b05      	ldr	r3, [sp, #20]
 80162b6:	ebcb 7c4b 	rsb	ip, fp, fp, lsl #29
 80162ba:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
 80162be:	9b07      	ldr	r3, [sp, #28]
 80162c0:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 80162c4:	f10c 0804 	add.w	r8, ip, #4
 80162c8:	eb03 06cb 	add.w	r6, r3, fp, lsl #3
 80162cc:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 80162ce:	f1bb 0f00 	cmp.w	fp, #0
 80162d2:	dd17      	ble.n	8016304 <cblas_csymm+0x1cc>
 80162d4:	eb0c 0306 	add.w	r3, ip, r6
 80162d8:	eb08 0206 	add.w	r2, r8, r6
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 80162dc:	edd3 6a01 	vldr	s13, [r3, #4]
          const BASE Cij_real = REAL(C, ldc * i + j);
 80162e0:	ed12 6a01 	vldr	s12, [r2, #-4]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80162e4:	ee26 7ac5 	vnmul.f32	s14, s13, s10
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80162e8:	ee65 7a06 	vmul.f32	s15, s10, s12
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80162ec:	eea5 7a86 	vfma.f32	s14, s11, s12
 80162f0:	3308      	adds	r3, #8
 80162f2:	3208      	adds	r2, #8
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80162f4:	eee5 7aa6 	vfma.f32	s15, s11, s13
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80162f8:	ed02 7a03 	vstr	s14, [r2, #-12]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80162fc:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < n2; j++) {
 8016300:	429e      	cmp	r6, r3
 8016302:	d1eb      	bne.n	80162dc <cblas_csymm+0x1a4>
      for (i = 0; i < n1; i++) {
 8016304:	3701      	adds	r7, #1
 8016306:	42b9      	cmp	r1, r7
 8016308:	4476      	add	r6, lr
 801630a:	d1e0      	bne.n	80162ce <cblas_csymm+0x196>
 801630c:	e79b      	b.n	8016246 <cblas_csymm+0x10e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801630e:	429a      	cmp	r2, r3
 8016310:	f6ff af44 	blt.w	801619c <cblas_csymm+0x64>
 8016314:	2e65      	cmp	r6, #101	; 0x65
 8016316:	f000 8334 	beq.w	8016982 <cblas_csymm+0x84a>
 801631a:	2e66      	cmp	r6, #102	; 0x66
 801631c:	f000 8389 	beq.w	8016a32 <cblas_csymm+0x8fa>
 8016320:	2005      	movs	r0, #5
 8016322:	e742      	b.n	80161aa <cblas_csymm+0x72>
 8016324:	3865      	subs	r0, #101	; 0x65
 8016326:	2801      	cmp	r0, #1
 8016328:	bf94      	ite	ls
 801632a:	2000      	movls	r0, #0
 801632c:	2001      	movhi	r0, #1
 801632e:	465b      	mov	r3, fp
 8016330:	e721      	b.n	8016176 <cblas_csymm+0x3e>
      uplo = Uplo;
 8016332:	9b01      	ldr	r3, [sp, #4]
      side = Side;
 8016334:	f8cd b004 	str.w	fp, [sp, #4]
 8016338:	469b      	mov	fp, r3
 801633a:	e75e      	b.n	80161fa <cblas_csymm+0xc2>
    if (side == CblasLeft && uplo == CblasUpper) {
 801633c:	2d79      	cmp	r5, #121	; 0x79
 801633e:	f000 81a5 	beq.w	801668c <cblas_csymm+0x554>
    } else if (side == CblasLeft && uplo == CblasLower) {
 8016342:	2d7a      	cmp	r5, #122	; 0x7a
 8016344:	d18e      	bne.n	8016264 <cblas_csymm+0x12c>
      for (i = 0; i < n1; i++) {
 8016346:	9b01      	ldr	r3, [sp, #4]
 8016348:	2b00      	cmp	r3, #0
 801634a:	dda1      	ble.n	8016290 <cblas_csymm+0x158>
 801634c:	9b02      	ldr	r3, [sp, #8]
 801634e:	9d03      	ldr	r5, [sp, #12]
 8016350:	9502      	str	r5, [sp, #8]
 8016352:	3301      	adds	r3, #1
 8016354:	00da      	lsls	r2, r3, #3
 8016356:	2300      	movs	r3, #0
 8016358:	9308      	str	r3, [sp, #32]
 801635a:	9309      	str	r3, [sp, #36]	; 0x24
 801635c:	4699      	mov	r9, r3
 801635e:	9b05      	ldr	r3, [sp, #20]
 8016360:	920b      	str	r2, [sp, #44]	; 0x2c
 8016362:	00dc      	lsls	r4, r3, #3
 8016364:	9b06      	ldr	r3, [sp, #24]
 8016366:	f8cd b00c 	str.w	fp, [sp, #12]
 801636a:	00de      	lsls	r6, r3, #3
 801636c:	9b04      	ldr	r3, [sp, #16]
 801636e:	3304      	adds	r3, #4
 8016370:	930c      	str	r3, [sp, #48]	; 0x30
 8016372:	9b07      	ldr	r3, [sp, #28]
 8016374:	3a08      	subs	r2, #8
 8016376:	920a      	str	r2, [sp, #40]	; 0x28
 8016378:	1d1a      	adds	r2, r3, #4
 801637a:	f105 0a04 	add.w	sl, r5, #4
 801637e:	9207      	str	r2, [sp, #28]
 8016380:	469b      	mov	fp, r3
        for (j = 0; j < n2; j++) {
 8016382:	9b03      	ldr	r3, [sp, #12]
 8016384:	2b00      	cmp	r3, #0
 8016386:	f340 808d 	ble.w	80164a4 <cblas_csymm+0x36c>
 801638a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801638c:	9a08      	ldr	r2, [sp, #32]
 801638e:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 8016392:	9b07      	ldr	r3, [sp, #28]
 8016394:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016396:	f04f 0804 	mov.w	r8, #4
 801639a:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 801639e:	f04f 0e00 	mov.w	lr, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80163a2:	ed5c 7a01 	vldr	s15, [ip, #-4]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80163a6:	ed9c 7a00 	vldr	s14, [ip]
          BASE temp2_imag = 0.0;
 80163aa:	ed9f 2a4c 	vldr	s4, [pc, #304]	; 80164dc <cblas_csymm+0x3a4>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80163ae:	ee24 5a27 	vmul.f32	s10, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80163b2:	ee67 2a44 	vnmul.f32	s5, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80163b6:	eea4 5a87 	vfma.f32	s10, s9, s14
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80163ba:	eee4 2aa7 	vfma.f32	s5, s9, s15
          BASE temp2_real = 0.0;
 80163be:	eef0 1a42 	vmov.f32	s3, s4
          for (k = 0; k < i; k++) {
 80163c2:	f1b9 0f00 	cmp.w	r9, #0
 80163c6:	d035      	beq.n	8016434 <cblas_csymm+0x2fc>
 80163c8:	9b04      	ldr	r3, [sp, #16]
 80163ca:	eb03 0108 	add.w	r1, r3, r8
 80163ce:	9b02      	ldr	r3, [sp, #8]
 80163d0:	eb0b 00ce 	add.w	r0, fp, lr, lsl #3
 80163d4:	eb0b 0208 	add.w	r2, fp, r8
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80163d8:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80163dc:	ed93 7a00 	vldr	s14, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 80163e0:	ed12 6a01 	vldr	s12, [r2, #-4]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 80163e4:	ed11 3a01 	vldr	s6, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 80163e8:	edd1 3a00 	vldr	s7, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 80163ec:	ee67 6ac5 	vnmul.f32	s13, s15, s10
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 80163f0:	ee62 5aa7 	vmul.f32	s11, s5, s15
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 80163f4:	eee2 6a87 	vfma.f32	s13, s5, s14
 80163f8:	3308      	adds	r3, #8
          for (k = 0; k < i; k++) {
 80163fa:	429d      	cmp	r5, r3
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 80163fc:	eee5 5a07 	vfma.f32	s11, s10, s14
 8016400:	4431      	add	r1, r6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8016402:	ee76 6a26 	vadd.f32	s13, s12, s13
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8016406:	ee23 6ae7 	vnmul.f32	s12, s7, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801640a:	ee67 7a83 	vmul.f32	s15, s15, s6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 801640e:	ed42 6a01 	vstr	s13, [r2, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8016412:	edd0 6a01 	vldr	s13, [r0, #4]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8016416:	eea7 6a03 	vfma.f32	s12, s14, s6
 801641a:	4422      	add	r2, r4
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801641c:	eee7 7a23 	vfma.f32	s15, s14, s7
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8016420:	ee36 7aa5 	vadd.f32	s14, s13, s11
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8016424:	ee71 1a86 	vadd.f32	s3, s3, s12
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8016428:	ed80 7a01 	vstr	s14, [r0, #4]
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801642c:	ee32 2a27 	vadd.f32	s4, s4, s15
          for (k = 0; k < i; k++) {
 8016430:	4420      	add	r0, r4
 8016432:	d1d1      	bne.n	80163d8 <cblas_csymm+0x2a0>
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8016434:	ed95 6a01 	vldr	s12, [r5, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8016438:	ed5a 6a01 	vldr	s13, [sl, #-4]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 801643c:	ed17 3a01 	vldr	s6, [r7, #-4]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016440:	edd7 3a00 	vldr	s7, [r7]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8016444:	ee26 7a45 	vnmul.f32	s14, s12, s10
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016448:	ee65 7a26 	vmul.f32	s15, s10, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 801644c:	eea2 7aa6 	vfma.f32	s14, s5, s13
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016450:	463b      	mov	r3, r7
        for (j = 0; j < n2; j++) {
 8016452:	f10e 0e01 	add.w	lr, lr, #1
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016456:	eee2 7a86 	vfma.f32	s15, s5, s12
 801645a:	f10c 0c08 	add.w	ip, ip, #8
 801645e:	f108 0808 	add.w	r8, r8, #8
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8016462:	eef0 6a47 	vmov.f32	s13, s14
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016466:	eeb0 5a67 	vmov.f32	s10, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801646a:	ee22 7a44 	vnmul.f32	s14, s4, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801646e:	ee64 7a21 	vmul.f32	s15, s8, s3
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016472:	eea4 7aa1 	vfma.f32	s14, s9, s3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016476:	3708      	adds	r7, #8
 8016478:	eee4 7a82 	vfma.f32	s15, s9, s4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801647c:	eef0 5a47 	vmov.f32	s11, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016480:	eeb0 6a67 	vmov.f32	s12, s15
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8016484:	ee36 7a83 	vadd.f32	s14, s13, s6
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016488:	ee75 7a23 	vadd.f32	s15, s10, s7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801648c:	ee37 7a25 	vadd.f32	s14, s14, s11
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016490:	ee77 7a86 	vadd.f32	s15, s15, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016494:	ed07 7a03 	vstr	s14, [r7, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016498:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < n2; j++) {
 801649c:	9b03      	ldr	r3, [sp, #12]
 801649e:	4573      	cmp	r3, lr
 80164a0:	f47f af7f 	bne.w	80163a2 <cblas_csymm+0x26a>
      for (i = 0; i < n1; i++) {
 80164a4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80164a6:	9905      	ldr	r1, [sp, #20]
 80164a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80164aa:	440a      	add	r2, r1
 80164ac:	9209      	str	r2, [sp, #36]	; 0x24
 80164ae:	9906      	ldr	r1, [sp, #24]
 80164b0:	9a08      	ldr	r2, [sp, #32]
 80164b2:	440a      	add	r2, r1
 80164b4:	441d      	add	r5, r3
 80164b6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80164b8:	9208      	str	r2, [sp, #32]
 80164ba:	449a      	add	sl, r3
 80164bc:	9a02      	ldr	r2, [sp, #8]
 80164be:	9b01      	ldr	r3, [sp, #4]
 80164c0:	f109 0901 	add.w	r9, r9, #1
 80164c4:	440a      	add	r2, r1
 80164c6:	454b      	cmp	r3, r9
 80164c8:	9202      	str	r2, [sp, #8]
 80164ca:	f47f af5a 	bne.w	8016382 <cblas_csymm+0x24a>
 80164ce:	e6df      	b.n	8016290 <cblas_csymm+0x158>
 80164d0:	08031108 	.word	0x08031108
 80164d4:	08031360 	.word	0x08031360
 80164d8:	080311b8 	.word	0x080311b8
 80164dc:	00000000 	.word	0x00000000
    } else if (side == CblasRight && uplo == CblasUpper) {
 80164e0:	2d79      	cmp	r5, #121	; 0x79
 80164e2:	f000 81a5 	beq.w	8016830 <cblas_csymm+0x6f8>
    } else if (side == CblasRight && uplo == CblasLower) {
 80164e6:	2d7a      	cmp	r5, #122	; 0x7a
 80164e8:	f47f aebc 	bne.w	8016264 <cblas_csymm+0x12c>
      for (i = 0; i < n1; i++) {
 80164ec:	9b01      	ldr	r3, [sp, #4]
 80164ee:	2b00      	cmp	r3, #0
 80164f0:	f77f aece 	ble.w	8016290 <cblas_csymm+0x158>
 80164f4:	9a05      	ldr	r2, [sp, #20]
 80164f6:	9b02      	ldr	r3, [sp, #8]
 80164f8:	f8dd a010 	ldr.w	sl, [sp, #16]
 80164fc:	00d2      	lsls	r2, r2, #3
 80164fe:	9208      	str	r2, [sp, #32]
 8016500:	e9dd 2806 	ldrd	r2, r8, [sp, #24]
 8016504:	00d2      	lsls	r2, r2, #3
 8016506:	9205      	str	r2, [sp, #20]
 8016508:	9a03      	ldr	r2, [sp, #12]
 801650a:	3301      	adds	r3, #1
 801650c:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8016510:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8016514:	9306      	str	r3, [sp, #24]
 8016516:	2300      	movs	r3, #0
 8016518:	9304      	str	r3, [sp, #16]
        for (j = 0; j < n2; j++) {
 801651a:	f1bb 0f00 	cmp.w	fp, #0
 801651e:	f340 823c 	ble.w	801699a <cblas_csymm+0x862>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8016522:	edda 7a00 	vldr	s15, [sl]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8016526:	ed9a 7a01 	vldr	s14, [sl, #4]
          BASE temp2_imag = 0.0;
 801652a:	ed1f 2a14 	vldr	s4, [pc, #-80]	; 80164dc <cblas_csymm+0x3a4>
 801652e:	9b03      	ldr	r3, [sp, #12]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8016530:	9c06      	ldr	r4, [sp, #24]
 8016532:	f8dd e008 	ldr.w	lr, [sp, #8]
 8016536:	ee67 3a84 	vmul.f32	s7, s15, s8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801653a:	ee64 2a47 	vnmul.f32	s5, s8, s14
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801653e:	eee7 3a24 	vfma.f32	s7, s14, s9
 8016542:	1d1e      	adds	r6, r3, #4
 8016544:	4657      	mov	r7, sl
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8016546:	eee7 2aa4 	vfma.f32	s5, s15, s9
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801654a:	4645      	mov	r5, r8
        for (j = 0; j < n2; j++) {
 801654c:	f04f 0c00 	mov.w	ip, #0
          BASE temp2_real = 0.0;
 8016550:	eef0 1a42 	vmov.f32	s3, s4
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8016554:	ed16 6a01 	vldr	s12, [r6, #-4]
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8016558:	edd6 6a00 	vldr	s13, [r6]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 801655c:	ed95 3a00 	vldr	s6, [r5]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8016560:	ed95 5a01 	vldr	s10, [r5, #4]
 8016564:	ee26 7a23 	vmul.f32	s14, s12, s7
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8016568:	ee63 7ae6 	vnmul.f32	s15, s7, s13
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 801656c:	eea6 7aa2 	vfma.f32	s14, s13, s5
        for (j = 0; j < n2; j++) {
 8016570:	f10c 0c01 	add.w	ip, ip, #1
 8016574:	45e3      	cmp	fp, ip
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8016576:	eee6 7a22 	vfma.f32	s15, s12, s5
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 801657a:	eef0 6a47 	vmov.f32	s13, s14
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 801657e:	eef0 3a67 	vmov.f32	s7, s15
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016582:	ee24 7a21 	vmul.f32	s14, s8, s3
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016586:	ee62 7a44 	vnmul.f32	s15, s4, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801658a:	eea4 7a82 	vfma.f32	s14, s9, s4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801658e:	eee4 7aa1 	vfma.f32	s15, s9, s3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016592:	eeb0 6a47 	vmov.f32	s12, s14
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016596:	eef0 5a67 	vmov.f32	s11, s15
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 801659a:	ee36 7a85 	vadd.f32	s14, s13, s10
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 801659e:	ee73 7a83 	vadd.f32	s15, s7, s6
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80165a2:	ee37 7a06 	vadd.f32	s14, s14, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80165a6:	ee77 7aa5 	vadd.f32	s15, s15, s11
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80165aa:	ed85 7a01 	vstr	s14, [r5, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80165ae:	edc5 7a00 	vstr	s15, [r5]
        for (j = 0; j < n2; j++) {
 80165b2:	f000 81f2 	beq.w	801699a <cblas_csymm+0x862>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80165b6:	edd7 7a02 	vldr	s15, [r7, #8]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80165ba:	ed97 7a03 	vldr	s14, [r7, #12]
          BASE temp2_imag = 0.0;
 80165be:	ed1f 2a39 	vldr	s4, [pc, #-228]	; 80164dc <cblas_csymm+0x3a4>
 80165c2:	9b03      	ldr	r3, [sp, #12]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80165c4:	ee64 3a27 	vmul.f32	s7, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80165c8:	ee67 2a44 	vnmul.f32	s5, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80165cc:	eee4 3a87 	vfma.f32	s7, s9, s14
 80165d0:	eb03 03ce 	add.w	r3, r3, lr, lsl #3
 80165d4:	f108 0004 	add.w	r0, r8, #4
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80165d8:	eee4 2aa7 	vfma.f32	s5, s9, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80165dc:	4641      	mov	r1, r8
 80165de:	4652      	mov	r2, sl
          BASE temp2_real = 0.0;
 80165e0:	eef0 1a42 	vmov.f32	s3, s4
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80165e4:	ed93 7a01 	vldr	s14, [r3, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80165e8:	edd3 6a00 	vldr	s13, [r3]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80165ec:	ed50 5a01 	vldr	s11, [r0, #-4]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 80165f0:	edd2 7a01 	vldr	s15, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 80165f4:	ed92 3a00 	vldr	s6, [r2]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80165f8:	ee27 6a63 	vnmul.f32	s12, s14, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80165fc:	ee23 5aa6 	vmul.f32	s10, s7, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8016600:	eea2 6aa6 	vfma.f32	s12, s5, s13
 8016604:	3308      	adds	r3, #8
          for (k = 0; k < j; k++) {
 8016606:	429c      	cmp	r4, r3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8016608:	eea2 5a87 	vfma.f32	s10, s5, s14
 801660c:	f102 0208 	add.w	r2, r2, #8
 8016610:	f100 0008 	add.w	r0, r0, #8
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8016614:	ee35 6a86 	vadd.f32	s12, s11, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8016618:	ee67 5ac7 	vnmul.f32	s11, s15, s14
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 801661c:	ee66 7aa7 	vmul.f32	s15, s13, s15
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8016620:	ed00 6a03 	vstr	s12, [r0, #-12]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8016624:	ed91 6a01 	vldr	s12, [r1, #4]
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8016628:	eee7 7a03 	vfma.f32	s15, s14, s6
 801662c:	f101 0108 	add.w	r1, r1, #8
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8016630:	eee6 5a83 	vfma.f32	s11, s13, s6
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8016634:	ee36 7a05 	vadd.f32	s14, s12, s10
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8016638:	ee71 1aa5 	vadd.f32	s3, s3, s11
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801663c:	ed01 7a01 	vstr	s14, [r1, #-4]
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8016640:	ee32 2a27 	vadd.f32	s4, s4, s15
          for (k = 0; k < j; k++) {
 8016644:	d1ce      	bne.n	80165e4 <cblas_csymm+0x4ac>
 8016646:	9b02      	ldr	r3, [sp, #8]
 8016648:	3508      	adds	r5, #8
 801664a:	3708      	adds	r7, #8
 801664c:	449e      	add	lr, r3
 801664e:	444c      	add	r4, r9
 8016650:	444e      	add	r6, r9
 8016652:	e77f      	b.n	8016554 <cblas_csymm+0x41c>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8016654:	9b01      	ldr	r3, [sp, #4]
 8016656:	9a06      	ldr	r2, [sp, #24]
 8016658:	2b01      	cmp	r3, #1
 801665a:	bfb8      	it	lt
 801665c:	2301      	movlt	r3, #1
 801665e:	4293      	cmp	r3, r2
 8016660:	f300 8193 	bgt.w	801698a <cblas_csymm+0x852>
 8016664:	9a05      	ldr	r2, [sp, #20]
 8016666:	4293      	cmp	r3, r2
 8016668:	bfcc      	ite	gt
 801666a:	200d      	movgt	r0, #13
 801666c:	2008      	movle	r0, #8
 801666e:	e59c      	b.n	80161aa <cblas_csymm+0x72>
 8016670:	9b01      	ldr	r3, [sp, #4]
 8016672:	9a06      	ldr	r2, [sp, #24]
 8016674:	2b01      	cmp	r3, #1
 8016676:	bfb8      	it	lt
 8016678:	2301      	movlt	r3, #1
 801667a:	4293      	cmp	r3, r2
 801667c:	f300 8185 	bgt.w	801698a <cblas_csymm+0x852>
 8016680:	9a05      	ldr	r2, [sp, #20]
 8016682:	4293      	cmp	r3, r2
 8016684:	f77f adfc 	ble.w	8016280 <cblas_csymm+0x148>
 8016688:	200d      	movs	r0, #13
 801668a:	e58e      	b.n	80161aa <cblas_csymm+0x72>
      for (i = 0; i < n1; i++) {
 801668c:	9a01      	ldr	r2, [sp, #4]
 801668e:	2a00      	cmp	r2, #0
 8016690:	f77f adfe 	ble.w	8016290 <cblas_csymm+0x158>
 8016694:	9b02      	ldr	r3, [sp, #8]
 8016696:	f8dd e00c 	ldr.w	lr, [sp, #12]
 801669a:	3301      	adds	r3, #1
 801669c:	00db      	lsls	r3, r3, #3
 801669e:	930d      	str	r3, [sp, #52]	; 0x34
 80166a0:	3b08      	subs	r3, #8
 80166a2:	f1ae 0408 	sub.w	r4, lr, #8
 80166a6:	930c      	str	r3, [sp, #48]	; 0x30
 80166a8:	9b06      	ldr	r3, [sp, #24]
 80166aa:	9308      	str	r3, [sp, #32]
 80166ac:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 80166b0:	9a05      	ldr	r2, [sp, #20]
 80166b2:	9203      	str	r2, [sp, #12]
 80166b4:	2100      	movs	r1, #0
 80166b6:	00de      	lsls	r6, r3, #3
 80166b8:	2301      	movs	r3, #1
 80166ba:	9109      	str	r1, [sp, #36]	; 0x24
 80166bc:	f10e 0a04 	add.w	sl, lr, #4
 80166c0:	910a      	str	r1, [sp, #40]	; 0x28
 80166c2:	00d5      	lsls	r5, r2, #3
 80166c4:	4699      	mov	r9, r3
        for (j = 0; j < n2; j++) {
 80166c6:	f1bb 0f00 	cmp.w	fp, #0
 80166ca:	bfd8      	it	le
 80166cc:	f8cd 902c 	strle.w	r9, [sp, #44]	; 0x2c
 80166d0:	f340 8091 	ble.w	80167f6 <cblas_csymm+0x6be>
 80166d4:	9b08      	ldr	r3, [sp, #32]
 80166d6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80166d8:	9909      	ldr	r1, [sp, #36]	; 0x24
 80166da:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 80166de:	eba3 0802 	sub.w	r8, r3, r2
 80166e2:	9b03      	ldr	r3, [sp, #12]
 80166e4:	1a5b      	subs	r3, r3, r1
 80166e6:	00db      	lsls	r3, r3, #3
 80166e8:	3304      	adds	r3, #4
 80166ea:	9302      	str	r3, [sp, #8]
 80166ec:	9b04      	ldr	r3, [sp, #16]
 80166ee:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 80166f2:	9b07      	ldr	r3, [sp, #28]
 80166f4:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 80166f8:	f108 0804 	add.w	r8, r8, #4
 80166fc:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
 8016700:	f04f 0c00 	mov.w	ip, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8016704:	edd7 6a00 	vldr	s13, [r7]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8016708:	ed97 6a01 	vldr	s12, [r7, #4]
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 801670c:	edde 5a01 	vldr	s11, [lr, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8016710:	ed1a 5a01 	vldr	s10, [sl, #-4]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8016714:	ed90 7a00 	vldr	s14, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016718:	edd0 7a01 	vldr	s15, [r0, #4]
          for (k = i + 1; k < n1; k++) {
 801671c:	9b01      	ldr	r3, [sp, #4]
          BASE temp2_imag = 0.0;
 801671e:	ed1f 1a91 	vldr	s2, [pc, #-580]	; 80164dc <cblas_csymm+0x3a4>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8016722:	ee64 1a26 	vmul.f32	s3, s8, s13
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8016726:	ee26 2a44 	vnmul.f32	s4, s12, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801672a:	eee4 1a86 	vfma.f32	s3, s9, s12
          for (k = i + 1; k < n1; k++) {
 801672e:	454b      	cmp	r3, r9
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8016730:	eea4 2aa6 	vfma.f32	s4, s9, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8016734:	ee25 6ae1 	vnmul.f32	s12, s11, s3
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016738:	ee61 6a85 	vmul.f32	s13, s3, s10
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 801673c:	eea2 6a05 	vfma.f32	s12, s4, s10
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016740:	eee2 6a25 	vfma.f32	s13, s4, s11
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8016744:	ee37 7a06 	vadd.f32	s14, s14, s12
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016748:	ee77 7aa6 	vadd.f32	s15, s15, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 801674c:	ed80 7a00 	vstr	s14, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8016750:	edc0 7a01 	vstr	s15, [r0, #4]
          BASE temp2_real = 0.0;
 8016754:	eef0 0a41 	vmov.f32	s1, s2
          for (k = i + 1; k < n1; k++) {
 8016758:	dd35      	ble.n	80167c6 <cblas_csymm+0x68e>
 801675a:	9b02      	ldr	r3, [sp, #8]
 801675c:	eb08 0107 	add.w	r1, r8, r7
 8016760:	4403      	add	r3, r0
 8016762:	4672      	mov	r2, lr
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8016764:	edd2 7a03 	vldr	s15, [r2, #12]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8016768:	ed92 7a02 	vldr	s14, [r2, #8]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 801676c:	ed51 2a01 	vldr	s5, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8016770:	ed91 3a00 	vldr	s6, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8016774:	ed13 5a01 	vldr	s10, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8016778:	ed93 6a00 	vldr	s12, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 801677c:	ee67 5ae1 	vnmul.f32	s11, s15, s3
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8016780:	ee62 3a27 	vmul.f32	s7, s4, s15
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8016784:	eee2 5a07 	vfma.f32	s11, s4, s14
 8016788:	3208      	adds	r2, #8
          for (k = i + 1; k < n1; k++) {
 801678a:	4294      	cmp	r4, r2
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801678c:	ee63 6a67 	vnmul.f32	s13, s6, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8016790:	eee1 3a87 	vfma.f32	s7, s3, s14
 8016794:	4431      	add	r1, r6
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8016796:	ee67 7aa2 	vmul.f32	s15, s15, s5
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801679a:	eee7 6a22 	vfma.f32	s13, s14, s5
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801679e:	eee7 7a03 	vfma.f32	s15, s14, s6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 80167a2:	ee75 5a25 	vadd.f32	s11, s10, s11
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 80167a6:	ee36 7a23 	vadd.f32	s14, s12, s7
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 80167aa:	ed43 5a01 	vstr	s11, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 80167ae:	ed83 7a00 	vstr	s14, [r3]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80167b2:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80167b6:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = i + 1; k < n1; k++) {
 80167ba:	442b      	add	r3, r5
 80167bc:	d1d2      	bne.n	8016764 <cblas_csymm+0x62c>
 80167be:	ed90 7a00 	vldr	s14, [r0]
 80167c2:	edd0 7a01 	vldr	s15, [r0, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80167c6:	ee21 6a44 	vnmul.f32	s12, s2, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80167ca:	ee64 6a20 	vmul.f32	s13, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80167ce:	eea4 6aa0 	vfma.f32	s12, s9, s1
        for (j = 0; j < n2; j++) {
 80167d2:	f10c 0c01 	add.w	ip, ip, #1
 80167d6:	45e3      	cmp	fp, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80167d8:	eee4 6a81 	vfma.f32	s13, s9, s2
 80167dc:	f107 0708 	add.w	r7, r7, #8
 80167e0:	f100 0008 	add.w	r0, r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80167e4:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80167e8:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80167ec:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80167f0:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 80167f4:	d186      	bne.n	8016704 <cblas_csymm+0x5cc>
      for (i = 0; i < n1; i++) {
 80167f6:	9809      	ldr	r0, [sp, #36]	; 0x24
 80167f8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80167fa:	9b06      	ldr	r3, [sp, #24]
 80167fc:	4607      	mov	r7, r0
 80167fe:	980c      	ldr	r0, [sp, #48]	; 0x30
 8016800:	4611      	mov	r1, r2
 8016802:	4404      	add	r4, r0
 8016804:	9808      	ldr	r0, [sp, #32]
 8016806:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8016808:	4419      	add	r1, r3
 801680a:	4418      	add	r0, r3
 801680c:	910a      	str	r1, [sp, #40]	; 0x28
 801680e:	9b03      	ldr	r3, [sp, #12]
 8016810:	9905      	ldr	r1, [sp, #20]
 8016812:	9008      	str	r0, [sp, #32]
 8016814:	440b      	add	r3, r1
 8016816:	4496      	add	lr, r2
 8016818:	9303      	str	r3, [sp, #12]
 801681a:	4492      	add	sl, r2
 801681c:	9b01      	ldr	r3, [sp, #4]
 801681e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8016820:	440f      	add	r7, r1
 8016822:	4293      	cmp	r3, r2
 8016824:	f109 0901 	add.w	r9, r9, #1
 8016828:	9709      	str	r7, [sp, #36]	; 0x24
 801682a:	f73f af4c 	bgt.w	80166c6 <cblas_csymm+0x58e>
 801682e:	e52f      	b.n	8016290 <cblas_csymm+0x158>
      for (i = 0; i < n1; i++) {
 8016830:	9b01      	ldr	r3, [sp, #4]
 8016832:	2b00      	cmp	r3, #0
 8016834:	f77f ad2c 	ble.w	8016290 <cblas_csymm+0x158>
 8016838:	9b03      	ldr	r3, [sp, #12]
 801683a:	9a02      	ldr	r2, [sp, #8]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801683c:	ed1f 0ad9 	vldr	s0, [pc, #-868]	; 80164dc <cblas_csymm+0x3a4>
 8016840:	3b08      	subs	r3, #8
 8016842:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8016846:	9309      	str	r3, [sp, #36]	; 0x24
 8016848:	9b05      	ldr	r3, [sp, #20]
 801684a:	00db      	lsls	r3, r3, #3
 801684c:	9308      	str	r3, [sp, #32]
 801684e:	9b07      	ldr	r3, [sp, #28]
      for (i = 0; i < n1; i++) {
 8016850:	f04f 0800 	mov.w	r8, #0
 8016854:	f102 0c01 	add.w	ip, r2, #1
 8016858:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801685c:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 8016860:	f8cd 8008 	str.w	r8, [sp, #8]
 8016864:	46c1      	mov	r9, r8
 8016866:	eb03 0ecb 	add.w	lr, r3, fp, lsl #3
        for (j = 0; j < n2; j++) {
 801686a:	f1bb 0f00 	cmp.w	fp, #0
 801686e:	f340 80b4 	ble.w	80169da <cblas_csymm+0x8a2>
 8016872:	9b04      	ldr	r3, [sp, #16]
 8016874:	9a02      	ldr	r2, [sp, #8]
 8016876:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8016878:	9d03      	ldr	r5, [sp, #12]
 801687a:	eb03 06c2 	add.w	r6, r3, r2, lsl #3
 801687e:	9b07      	ldr	r3, [sp, #28]
 8016880:	2700      	movs	r7, #0
 8016882:	eb03 00c8 	add.w	r0, r3, r8, lsl #3
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8016886:	edd6 7a00 	vldr	s15, [r6]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801688a:	edd6 6a01 	vldr	s13, [r6, #4]
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 801688e:	edd5 5a01 	vldr	s11, [r5, #4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8016892:	ed95 5a00 	vldr	s10, [r5]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8016896:	ed90 6a00 	vldr	s12, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 801689a:	ed90 7a01 	vldr	s14, [r0, #4]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801689e:	ee64 1a27 	vmul.f32	s3, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80168a2:	ee26 2ac4 	vnmul.f32	s4, s13, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80168a6:	eee4 1aa6 	vfma.f32	s3, s9, s13
          for (k = j + 1; k < n2; k++) {
 80168aa:	3701      	adds	r7, #1
 80168ac:	45bb      	cmp	fp, r7
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80168ae:	eea4 2aa7 	vfma.f32	s4, s9, s15
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80168b2:	ee65 6ae1 	vnmul.f32	s13, s11, s3
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80168b6:	ee61 7a85 	vmul.f32	s15, s3, s10
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80168ba:	eee2 6a05 	vfma.f32	s13, s4, s10
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80168be:	eee2 7a25 	vfma.f32	s15, s4, s11
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80168c2:	ee76 6a26 	vadd.f32	s13, s12, s13
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80168c6:	ee77 7a27 	vadd.f32	s15, s14, s15
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80168ca:	edc0 6a00 	vstr	s13, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80168ce:	edc0 7a01 	vstr	s15, [r0, #4]
          for (k = j + 1; k < n2; k++) {
 80168d2:	d06e      	beq.n	80169b2 <cblas_csymm+0x87a>
          BASE temp2_imag = 0.0;
 80168d4:	ed9f 1a5e 	vldr	s2, [pc, #376]	; 8016a50 <cblas_csymm+0x918>
          for (k = j + 1; k < n2; k++) {
 80168d8:	4603      	mov	r3, r0
          BASE temp2_real = 0.0;
 80168da:	eef0 0a41 	vmov.f32	s1, s2
          for (k = j + 1; k < n2; k++) {
 80168de:	4631      	mov	r1, r6
 80168e0:	462a      	mov	r2, r5
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80168e2:	edd2 6a02 	vldr	s13, [r2, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80168e6:	ed92 7a03 	vldr	s14, [r2, #12]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 80168ea:	edd1 7a03 	vldr	s15, [r1, #12]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 80168ee:	edd1 2a02 	vldr	s5, [r1, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80168f2:	ed93 5a03 	vldr	s10, [r3, #12]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80168f6:	edd3 5a02 	vldr	s11, [r3, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80168fa:	ee21 6aa6 	vmul.f32	s12, s3, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80168fe:	ee67 3a61 	vnmul.f32	s7, s14, s3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8016902:	eea2 6a07 	vfma.f32	s12, s4, s14
 8016906:	3208      	adds	r2, #8
          for (k = j + 1; k < n2; k++) {
 8016908:	4294      	cmp	r4, r2
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801690a:	eee2 3a26 	vfma.f32	s7, s4, s13
 801690e:	f101 0108 	add.w	r1, r1, #8
 8016912:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8016916:	eeb0 3a46 	vmov.f32	s6, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 801691a:	ee27 6ac7 	vnmul.f32	s12, s15, s14
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 801691e:	ee66 7aa7 	vmul.f32	s15, s13, s15
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8016922:	eea6 6aa2 	vfma.f32	s12, s13, s5
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8016926:	eee7 7a22 	vfma.f32	s15, s14, s5
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 801692a:	eef0 6a46 	vmov.f32	s13, s12
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801692e:	ee35 7aa3 	vadd.f32	s14, s11, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8016932:	ee35 6a03 	vadd.f32	s12, s10, s6
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8016936:	ed83 7a00 	vstr	s14, [r3]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801693a:	ed83 6a01 	vstr	s12, [r3, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 801693e:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8016942:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = j + 1; k < n2; k++) {
 8016946:	d1cc      	bne.n	80168e2 <cblas_csymm+0x7aa>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016948:	ee21 7a44 	vnmul.f32	s14, s2, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801694c:	ee64 7a20 	vmul.f32	s15, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016950:	eea4 7aa0 	vfma.f32	s14, s9, s1
 8016954:	3608      	adds	r6, #8
 8016956:	4465      	add	r5, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016958:	eee4 7a81 	vfma.f32	s15, s9, s2
 801695c:	4454      	add	r4, sl
 801695e:	3008      	adds	r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016960:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016964:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016968:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801696c:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016970:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8016974:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8016978:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801697c:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 8016980:	e781      	b.n	8016886 <cblas_csymm+0x74e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8016982:	9b06      	ldr	r3, [sp, #24]
 8016984:	2b00      	cmp	r3, #0
 8016986:	dc4d      	bgt.n	8016a24 <cblas_csymm+0x8ec>
 8016988:	2301      	movs	r3, #1
 801698a:	9a05      	ldr	r2, [sp, #20]
 801698c:	429a      	cmp	r2, r3
 801698e:	bfb4      	ite	lt
 8016990:	200d      	movlt	r0, #13
 8016992:	200a      	movge	r0, #10
 8016994:	e409      	b.n	80161aa <cblas_csymm+0x72>
 8016996:	465b      	mov	r3, fp
 8016998:	e66b      	b.n	8016672 <cblas_csymm+0x53a>
      for (i = 0; i < n1; i++) {
 801699a:	9a08      	ldr	r2, [sp, #32]
 801699c:	9b04      	ldr	r3, [sp, #16]
 801699e:	4490      	add	r8, r2
 80169a0:	9a05      	ldr	r2, [sp, #20]
 80169a2:	4492      	add	sl, r2
 80169a4:	9a01      	ldr	r2, [sp, #4]
 80169a6:	3301      	adds	r3, #1
 80169a8:	429a      	cmp	r2, r3
 80169aa:	9304      	str	r3, [sp, #16]
 80169ac:	f47f adb5 	bne.w	801651a <cblas_csymm+0x3e2>
 80169b0:	e46e      	b.n	8016290 <cblas_csymm+0x158>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80169b2:	ee64 7a00 	vmul.f32	s15, s8, s0
 80169b6:	ed5e 6a02 	vldr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80169ba:	ed1e 7a01 	vldr	s14, [lr, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80169be:	eeb0 6a67 	vmov.f32	s12, s15
 80169c2:	ee94 6a80 	vfnms.f32	s12, s9, s0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80169c6:	eee4 7a80 	vfma.f32	s15, s9, s0
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80169ca:	ee76 6a86 	vadd.f32	s13, s13, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80169ce:	ee77 7a27 	vadd.f32	s15, s14, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80169d2:	ed4e 6a02 	vstr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80169d6:	ed4e 7a01 	vstr	s15, [lr, #-4]
      for (i = 0; i < n1; i++) {
 80169da:	9b08      	ldr	r3, [sp, #32]
 80169dc:	9a06      	ldr	r2, [sp, #24]
 80169de:	449e      	add	lr, r3
 80169e0:	9b02      	ldr	r3, [sp, #8]
 80169e2:	4413      	add	r3, r2
 80169e4:	9302      	str	r3, [sp, #8]
 80169e6:	9b05      	ldr	r3, [sp, #20]
 80169e8:	4498      	add	r8, r3
 80169ea:	9b01      	ldr	r3, [sp, #4]
 80169ec:	f109 0901 	add.w	r9, r9, #1
 80169f0:	454b      	cmp	r3, r9
 80169f2:	f47f af3a 	bne.w	801686a <cblas_csymm+0x732>
 80169f6:	e44b      	b.n	8016290 <cblas_csymm+0x158>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80169f8:	465b      	mov	r3, fp
 80169fa:	2b01      	cmp	r3, #1
 80169fc:	9a06      	ldr	r2, [sp, #24]
 80169fe:	bfb8      	it	lt
 8016a00:	2301      	movlt	r3, #1
 8016a02:	4293      	cmp	r3, r2
 8016a04:	dcc1      	bgt.n	801698a <cblas_csymm+0x852>
 8016a06:	9a05      	ldr	r2, [sp, #20]
 8016a08:	4293      	cmp	r3, r2
 8016a0a:	bfd4      	ite	le
 8016a0c:	2008      	movle	r0, #8
 8016a0e:	200d      	movgt	r0, #13
 8016a10:	f7ff bbcb 	b.w	80161aa <cblas_csymm+0x72>
 8016a14:	3865      	subs	r0, #101	; 0x65
 8016a16:	2801      	cmp	r0, #1
 8016a18:	9b01      	ldr	r3, [sp, #4]
 8016a1a:	bf94      	ite	ls
 8016a1c:	2000      	movls	r0, #0
 8016a1e:	2001      	movhi	r0, #1
 8016a20:	f7ff bba9 	b.w	8016176 <cblas_csymm+0x3e>
 8016a24:	9b05      	ldr	r3, [sp, #20]
 8016a26:	2b00      	cmp	r3, #0
 8016a28:	bfcc      	ite	gt
 8016a2a:	2005      	movgt	r0, #5
 8016a2c:	200d      	movle	r0, #13
 8016a2e:	f7ff bbbc 	b.w	80161aa <cblas_csymm+0x72>
 8016a32:	465b      	mov	r3, fp
 8016a34:	2b01      	cmp	r3, #1
 8016a36:	9a06      	ldr	r2, [sp, #24]
 8016a38:	bfb8      	it	lt
 8016a3a:	2301      	movlt	r3, #1
 8016a3c:	429a      	cmp	r2, r3
 8016a3e:	dba4      	blt.n	801698a <cblas_csymm+0x852>
 8016a40:	9a05      	ldr	r2, [sp, #20]
 8016a42:	429a      	cmp	r2, r3
 8016a44:	bfac      	ite	ge
 8016a46:	2005      	movge	r0, #5
 8016a48:	200d      	movlt	r0, #13
 8016a4a:	f7ff bbae 	b.w	80161aa <cblas_csymm+0x72>
 8016a4e:	bf00      	nop
 8016a50:	00000000 	.word	0x00000000

08016a54 <cblas_csyr2k>:
void
cblas_csyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const void *beta, void *C, const int ldc)
{
 8016a54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016a58:	b08b      	sub	sp, #44	; 0x2c
 8016a5a:	461d      	mov	r5, r3
 8016a5c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8016a5e:	9300      	str	r3, [sp, #0]
 8016a60:	e9dd 6317 	ldrd	r6, r3, [sp, #92]	; 0x5c
 8016a64:	9301      	str	r3, [sp, #4]
 8016a66:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8016a68:	9304      	str	r3, [sp, #16]
 8016a6a:	e9dd b31a 	ldrd	fp, r3, [sp, #104]	; 0x68

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8016a6e:	2865      	cmp	r0, #101	; 0x65
 8016a70:	9302      	str	r3, [sp, #8]
 8016a72:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8016a74:	9303      	str	r3, [sp, #12]
 8016a76:	e9dd 7a14 	ldrd	r7, sl, [sp, #80]	; 0x50
 8016a7a:	4681      	mov	r9, r0
 8016a7c:	460c      	mov	r4, r1
 8016a7e:	4690      	mov	r8, r2
 8016a80:	f000 8102 	beq.w	8016c88 <cblas_csyr2k+0x234>
 8016a84:	2a6f      	cmp	r2, #111	; 0x6f
 8016a86:	f000 8095 	beq.w	8016bb4 <cblas_csyr2k+0x160>
 8016a8a:	463b      	mov	r3, r7
 8016a8c:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8016a90:	2a01      	cmp	r2, #1
 8016a92:	f240 80e9 	bls.w	8016c68 <cblas_csyr2k+0x214>
 8016a96:	2002      	movs	r0, #2
 8016a98:	f1a8 026f 	sub.w	r2, r8, #111	; 0x6f
 8016a9c:	2a02      	cmp	r2, #2
 8016a9e:	bf88      	it	hi
 8016aa0:	2003      	movhi	r0, #3
 8016aa2:	2d00      	cmp	r5, #0
 8016aa4:	bfb8      	it	lt
 8016aa6:	2004      	movlt	r0, #4
 8016aa8:	2f00      	cmp	r7, #0
 8016aaa:	bfb8      	it	lt
 8016aac:	2005      	movlt	r0, #5
 8016aae:	2b01      	cmp	r3, #1
 8016ab0:	bfb8      	it	lt
 8016ab2:	2301      	movlt	r3, #1
 8016ab4:	42b3      	cmp	r3, r6
 8016ab6:	9a04      	ldr	r2, [sp, #16]
 8016ab8:	f340 80c8 	ble.w	8016c4c <cblas_csyr2k+0x1f8>
 8016abc:	4293      	cmp	r3, r2
 8016abe:	f300 80bb 	bgt.w	8016c38 <cblas_csyr2k+0x1e4>
 8016ac2:	2d01      	cmp	r5, #1
 8016ac4:	9b03      	ldr	r3, [sp, #12]
 8016ac6:	4628      	mov	r0, r5
 8016ac8:	bfb8      	it	lt
 8016aca:	2001      	movlt	r0, #1
 8016acc:	4298      	cmp	r0, r3
 8016ace:	bfcc      	ite	gt
 8016ad0:	200e      	movgt	r0, #14
 8016ad2:	2008      	movle	r0, #8
 8016ad4:	4abe      	ldr	r2, [pc, #760]	; (8016dd0 <cblas_csyr2k+0x37c>)
 8016ad6:	49bf      	ldr	r1, [pc, #764]	; (8016dd4 <cblas_csyr2k+0x380>)
 8016ad8:	f011 fe16 	bl	8028708 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8016adc:	edda 5a00 	vldr	s11, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8016ae0:	ed9a 5a01 	vldr	s10, [sl, #4]
    const BASE beta_real = CONST_REAL0(beta);
 8016ae4:	eddb 6a00 	vldr	s13, [fp]
    const BASE beta_imag = CONST_IMAG0(beta);
 8016ae8:	ed9b 6a01 	vldr	s12, [fp, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8016aec:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016af0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016af4:	d10c      	bne.n	8016b10 <cblas_csyr2k+0xbc>
 8016af6:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016afa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016afe:	d107      	bne.n	8016b10 <cblas_csyr2k+0xbc>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8016b00:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8016b04:	eef4 6a67 	vcmp.f32	s13, s15
 8016b08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b0c:	f000 80b3 	beq.w	8016c76 <cblas_csyr2k+0x222>
      return;

    if (Order == CblasRowMajor) {
 8016b10:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8016b14:	f000 80bd 	beq.w	8016c92 <cblas_csyr2k+0x23e>
      uplo = Uplo;
      trans = Trans;
    } else {
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8016b18:	2c79      	cmp	r4, #121	; 0x79
 8016b1a:	bf0c      	ite	eq
 8016b1c:	247a      	moveq	r4, #122	; 0x7a
 8016b1e:	2479      	movne	r4, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8016b20:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8016b24:	bf0c      	ite	eq
 8016b26:	f04f 0970 	moveq.w	r9, #112	; 0x70
 8016b2a:	f04f 096f 	movne.w	r9, #111	; 0x6f
    }

    /* form  C := beta*C */

    if (beta_real == 0.0 && beta_imag == 0.0) {
 8016b2e:	eef5 6a40 	vcmp.f32	s13, #0.0
 8016b32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b36:	d144      	bne.n	8016bc2 <cblas_csyr2k+0x16e>
 8016b38:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8016b3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b40:	d14c      	bne.n	8016bdc <cblas_csyr2k+0x188>
      if (uplo == CblasUpper) {
 8016b42:	2c79      	cmp	r4, #121	; 0x79
 8016b44:	f000 80a7 	beq.w	8016c96 <cblas_csyr2k+0x242>
            REAL(C, ldc * i + j) = 0.0;
            IMAG(C, ldc * i + j) = 0.0;
          }
        }
      } else {
        for (i = 0; i < N; i++) {
 8016b48:	2d00      	cmp	r5, #0
 8016b4a:	dd1b      	ble.n	8016b84 <cblas_csyr2k+0x130>
 8016b4c:	9b03      	ldr	r3, [sp, #12]
 8016b4e:	9a02      	ldr	r2, [sp, #8]
 8016b50:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8016b54:	f103 0c01 	add.w	ip, r3, #1
 8016b58:	2100      	movs	r1, #0
          for (j = 0; j <= i; j++) {
            REAL(C, ldc * i + j) = 0.0;
 8016b5a:	f04f 0e00 	mov.w	lr, #0
 8016b5e:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
        for (i = 0; i < N; i++) {
 8016b62:	4608      	mov	r0, r1
 8016b64:	3208      	adds	r2, #8
 8016b66:	469a      	mov	sl, r3
 8016b68:	eb08 03c1 	add.w	r3, r8, r1, lsl #3
            REAL(C, ldc * i + j) = 0.0;
 8016b6c:	f8c3 e000 	str.w	lr, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8016b70:	f8c3 e004 	str.w	lr, [r3, #4]
          for (j = 0; j <= i; j++) {
 8016b74:	3308      	adds	r3, #8
 8016b76:	429a      	cmp	r2, r3
 8016b78:	d1f8      	bne.n	8016b6c <cblas_csyr2k+0x118>
        for (i = 0; i < N; i++) {
 8016b7a:	3001      	adds	r0, #1
 8016b7c:	4285      	cmp	r5, r0
 8016b7e:	4451      	add	r1, sl
 8016b80:	4462      	add	r2, ip
 8016b82:	d1f1      	bne.n	8016b68 <cblas_csyr2k+0x114>
        }
      }
    }


    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8016b84:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016b88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b8c:	d107      	bne.n	8016b9e <cblas_csyr2k+0x14a>
 8016b8e:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8016b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016b96:	d074      	beq.n	8016c82 <cblas_csyr2k+0x22e>
      return;

    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8016b98:	2c79      	cmp	r4, #121	; 0x79
 8016b9a:	f000 809c 	beq.w	8016cd6 <cblas_csyr2k+0x282>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
          }
        }
      }

    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8016b9e:	2c7a      	cmp	r4, #122	; 0x7a
 8016ba0:	f000 811e 	beq.w	8016de0 <cblas_csyr2k+0x38c>
        }
      }


    } else {
      BLAS_ERROR("unrecognized operation");
 8016ba4:	4a8c      	ldr	r2, [pc, #560]	; (8016dd8 <cblas_csyr2k+0x384>)
 8016ba6:	498b      	ldr	r1, [pc, #556]	; (8016dd4 <cblas_csyr2k+0x380>)
 8016ba8:	2000      	movs	r0, #0
#define BASE float
#include "source_syr2k_c.h"
#undef BASE
}
 8016baa:	b00b      	add	sp, #44	; 0x2c
 8016bac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016bb0:	f011 bdaa 	b.w	8028708 <cblas_xerbla>
 8016bb4:	462b      	mov	r3, r5
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8016bb6:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8016bba:	2a01      	cmp	r2, #1
 8016bbc:	d954      	bls.n	8016c68 <cblas_csyr2k+0x214>
 8016bbe:	2002      	movs	r0, #2
 8016bc0:	e76f      	b.n	8016aa2 <cblas_csyr2k+0x4e>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8016bc2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8016bc6:	eef4 6a67 	vcmp.f32	s13, s15
 8016bca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bce:	d105      	bne.n	8016bdc <cblas_csyr2k+0x188>
 8016bd0:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8016bd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016bd8:	f000 817f 	beq.w	8016eda <cblas_csyr2k+0x486>
      if (uplo == CblasUpper) {
 8016bdc:	2c79      	cmp	r4, #121	; 0x79
 8016bde:	f000 82a8 	beq.w	8017132 <cblas_csyr2k+0x6de>
        for (i = 0; i < N; i++) {
 8016be2:	2d00      	cmp	r5, #0
 8016be4:	ddce      	ble.n	8016b84 <cblas_csyr2k+0x130>
 8016be6:	9b03      	ldr	r3, [sp, #12]
 8016be8:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 8016bec:	9b02      	ldr	r3, [sp, #8]
 8016bee:	f108 0108 	add.w	r1, r8, #8
 8016bf2:	469c      	mov	ip, r3
 8016bf4:	f103 0008 	add.w	r0, r3, #8
 8016bf8:	f04f 0e00 	mov.w	lr, #0
 8016bfc:	f10c 0204 	add.w	r2, ip, #4
 8016c00:	4663      	mov	r3, ip
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8016c02:	edd3 4a01 	vldr	s9, [r3, #4]
            const BASE Cij_real = REAL(C, ldc * i + j);
 8016c06:	ed12 4a01 	vldr	s8, [r2, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016c0a:	ee24 7ac6 	vnmul.f32	s14, s9, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016c0e:	ee66 7a04 	vmul.f32	s15, s12, s8
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016c12:	eea6 7a84 	vfma.f32	s14, s13, s8
 8016c16:	3308      	adds	r3, #8
 8016c18:	3208      	adds	r2, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016c1a:	eee6 7aa4 	vfma.f32	s15, s13, s9
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016c1e:	ed02 7a03 	vstr	s14, [r2, #-12]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016c22:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j <= i; j++) {
 8016c26:	4298      	cmp	r0, r3
 8016c28:	d1eb      	bne.n	8016c02 <cblas_csyr2k+0x1ae>
        for (i = 0; i < N; i++) {
 8016c2a:	f10e 0e01 	add.w	lr, lr, #1
 8016c2e:	4575      	cmp	r5, lr
 8016c30:	44c4      	add	ip, r8
 8016c32:	4408      	add	r0, r1
 8016c34:	d1e2      	bne.n	8016bfc <cblas_csyr2k+0x1a8>
 8016c36:	e7a5      	b.n	8016b84 <cblas_csyr2k+0x130>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8016c38:	2d01      	cmp	r5, #1
 8016c3a:	9b03      	ldr	r3, [sp, #12]
 8016c3c:	4628      	mov	r0, r5
 8016c3e:	bfb8      	it	lt
 8016c40:	2001      	movlt	r0, #1
 8016c42:	4283      	cmp	r3, r0
 8016c44:	bfb4      	ite	lt
 8016c46:	200e      	movlt	r0, #14
 8016c48:	200b      	movge	r0, #11
 8016c4a:	e743      	b.n	8016ad4 <cblas_csyr2k+0x80>
 8016c4c:	4293      	cmp	r3, r2
 8016c4e:	dcf3      	bgt.n	8016c38 <cblas_csyr2k+0x1e4>
 8016c50:	2d01      	cmp	r5, #1
 8016c52:	9a03      	ldr	r2, [sp, #12]
 8016c54:	462b      	mov	r3, r5
 8016c56:	bfb8      	it	lt
 8016c58:	2301      	movlt	r3, #1
 8016c5a:	4293      	cmp	r3, r2
 8016c5c:	f300 81d8 	bgt.w	8017010 <cblas_csyr2k+0x5bc>
 8016c60:	2800      	cmp	r0, #0
 8016c62:	f43f af3b 	beq.w	8016adc <cblas_csyr2k+0x88>
 8016c66:	e735      	b.n	8016ad4 <cblas_csyr2k+0x80>
 8016c68:	f1a9 0065 	sub.w	r0, r9, #101	; 0x65
 8016c6c:	2801      	cmp	r0, #1
 8016c6e:	bf94      	ite	ls
 8016c70:	2000      	movls	r0, #0
 8016c72:	2001      	movhi	r0, #1
 8016c74:	e710      	b.n	8016a98 <cblas_csyr2k+0x44>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8016c76:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8016c7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016c7e:	f47f af47 	bne.w	8016b10 <cblas_csyr2k+0xbc>
 8016c82:	b00b      	add	sp, #44	; 0x2c
 8016c84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8016c88:	2a6f      	cmp	r2, #111	; 0x6f
 8016c8a:	f000 8278 	beq.w	801717e <cblas_csyr2k+0x72a>
 8016c8e:	462b      	mov	r3, r5
 8016c90:	e6fc      	b.n	8016a8c <cblas_csyr2k+0x38>
      trans = Trans;
 8016c92:	46c1      	mov	r9, r8
 8016c94:	e74b      	b.n	8016b2e <cblas_csyr2k+0xda>
        for (i = 0; i < N; i++) {
 8016c96:	2d00      	cmp	r5, #0
 8016c98:	dd17      	ble.n	8016cca <cblas_csyr2k+0x276>
 8016c9a:	9b03      	ldr	r3, [sp, #12]
 8016c9c:	9802      	ldr	r0, [sp, #8]
 8016c9e:	f103 0c01 	add.w	ip, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 8016ca2:	f04f 0e00 	mov.w	lr, #0
 8016ca6:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
        for (i = 0; i < N; i++) {
 8016caa:	2100      	movs	r1, #0
 8016cac:	4603      	mov	r3, r0
 8016cae:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 8016cb0:	3201      	adds	r2, #1
 8016cb2:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 8016cb4:	f8c3 e000 	str.w	lr, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8016cb8:	f8c3 e004 	str.w	lr, [r3, #4]
          for (j = i; j < N; j++) {
 8016cbc:	f103 0308 	add.w	r3, r3, #8
 8016cc0:	dcf6      	bgt.n	8016cb0 <cblas_csyr2k+0x25c>
        for (i = 0; i < N; i++) {
 8016cc2:	3101      	adds	r1, #1
 8016cc4:	428d      	cmp	r5, r1
 8016cc6:	4460      	add	r0, ip
 8016cc8:	d1f0      	bne.n	8016cac <cblas_csyr2k+0x258>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8016cca:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016cce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016cd2:	f43f af5c 	beq.w	8016b8e <cblas_csyr2k+0x13a>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8016cd6:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 8016cda:	f000 8105 	beq.w	8016ee8 <cblas_csyr2k+0x494>
    } else if (uplo == CblasUpper && trans == CblasTrans) {
 8016cde:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 8016ce2:	f47f af5f 	bne.w	8016ba4 <cblas_csyr2k+0x150>
      for (k = 0; k < K; k++) {
 8016ce6:	2f00      	cmp	r7, #0
 8016ce8:	ddcb      	ble.n	8016c82 <cblas_csyr2k+0x22e>
 8016cea:	f04f 0a00 	mov.w	sl, #0
 8016cee:	f106 0901 	add.w	r9, r6, #1
 8016cf2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8016cf6:	46d0      	mov	r8, sl
 8016cf8:	46d3      	mov	fp, sl
 8016cfa:	9703      	str	r7, [sp, #12]
        for (i = 0; i < N; i++) {
 8016cfc:	2d00      	cmp	r5, #0
 8016cfe:	dd5e      	ble.n	8016dbe <cblas_csyr2k+0x36a>
 8016d00:	9b00      	ldr	r3, [sp, #0]
 8016d02:	f8dd e008 	ldr.w	lr, [sp, #8]
 8016d06:	eb03 07c8 	add.w	r7, r3, r8, lsl #3
 8016d0a:	9b01      	ldr	r3, [sp, #4]
 8016d0c:	f04f 0c00 	mov.w	ip, #0
 8016d10:	eb03 04ca 	add.w	r4, r3, sl, lsl #3
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016d14:	edd7 3a00 	vldr	s7, [r7]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8016d18:	ed97 3a01 	vldr	s6, [r7, #4]
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8016d1c:	edd4 4a00 	vldr	s9, [r4]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8016d20:	ed94 4a01 	vldr	s8, [r4, #4]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016d24:	ee25 1a23 	vmul.f32	s2, s10, s7
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8016d28:	ee63 1a45 	vnmul.f32	s3, s6, s10
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016d2c:	ee25 2a24 	vmul.f32	s4, s10, s9
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016d30:	ee64 2a45 	vnmul.f32	s5, s8, s10
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016d34:	eea5 1a83 	vfma.f32	s2, s11, s6
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016d38:	4621      	mov	r1, r4
 8016d3a:	463a      	mov	r2, r7
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8016d3c:	eee5 1aa3 	vfma.f32	s3, s11, s7
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016d40:	4673      	mov	r3, lr
 8016d42:	4660      	mov	r0, ip
 8016d44:	eea5 2a84 	vfma.f32	s4, s11, s8
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016d48:	eee5 2aa4 	vfma.f32	s5, s11, s9
          for (j = i; j < N; j++) {
 8016d4c:	e009      	b.n	8016d62 <cblas_csyr2k+0x30e>
 8016d4e:	edd2 3a02 	vldr	s7, [r2, #8]
 8016d52:	ed92 3a03 	vldr	s6, [r2, #12]
 8016d56:	edd1 4a02 	vldr	s9, [r1, #8]
 8016d5a:	ed91 4a03 	vldr	s8, [r1, #12]
 8016d5e:	3208      	adds	r2, #8
 8016d60:	3108      	adds	r1, #8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016d62:	ee24 6a41 	vnmul.f32	s12, s8, s2
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016d66:	ee21 7a24 	vmul.f32	s14, s2, s9
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8016d6a:	ee63 6a42 	vnmul.f32	s13, s6, s4
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8016d6e:	ee62 7a23 	vmul.f32	s15, s4, s7
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016d72:	eea1 6aa4 	vfma.f32	s12, s3, s9
          for (j = i; j < N; j++) {
 8016d76:	3001      	adds	r0, #1
 8016d78:	4285      	cmp	r5, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016d7a:	eea1 7a84 	vfma.f32	s14, s3, s8
 8016d7e:	f103 0308 	add.w	r3, r3, #8
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8016d82:	eee2 6aa3 	vfma.f32	s13, s5, s7
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8016d86:	eee2 7a83 	vfma.f32	s15, s5, s6
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8016d8a:	ee76 6a26 	vadd.f32	s13, s12, s13
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8016d8e:	ee77 7a27 	vadd.f32	s15, s14, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016d92:	ed13 6a02 	vldr	s12, [r3, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016d96:	ed13 7a01 	vldr	s14, [r3, #-4]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016d9a:	ee76 6a26 	vadd.f32	s13, s12, s13
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016d9e:	ee77 7a27 	vadd.f32	s15, s14, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016da2:	ed43 6a02 	vstr	s13, [r3, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016da6:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = i; j < N; j++) {
 8016daa:	dcd0      	bgt.n	8016d4e <cblas_csyr2k+0x2fa>
        for (i = 0; i < N; i++) {
 8016dac:	f10c 0c01 	add.w	ip, ip, #1
 8016db0:	4565      	cmp	r5, ip
 8016db2:	f107 0708 	add.w	r7, r7, #8
 8016db6:	f104 0408 	add.w	r4, r4, #8
 8016dba:	44ce      	add	lr, r9
 8016dbc:	d1aa      	bne.n	8016d14 <cblas_csyr2k+0x2c0>
      for (k = 0; k < K; k++) {
 8016dbe:	9b04      	ldr	r3, [sp, #16]
 8016dc0:	449a      	add	sl, r3
 8016dc2:	9b03      	ldr	r3, [sp, #12]
 8016dc4:	f10b 0b01 	add.w	fp, fp, #1
 8016dc8:	455b      	cmp	r3, fp
 8016dca:	44b0      	add	r8, r6
 8016dcc:	d196      	bne.n	8016cfc <cblas_csyr2k+0x2a8>
 8016dce:	e758      	b.n	8016c82 <cblas_csyr2k+0x22e>
 8016dd0:	08031108 	.word	0x08031108
 8016dd4:	08031370 	.word	0x08031370
 8016dd8:	080311b8 	.word	0x080311b8
 8016ddc:	00000000 	.word	0x00000000
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8016de0:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 8016de4:	f000 8116 	beq.w	8017014 <cblas_csyr2k+0x5c0>
    } else if (uplo == CblasLower && trans == CblasTrans) {
 8016de8:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 8016dec:	f47f aeda 	bne.w	8016ba4 <cblas_csyr2k+0x150>
      for (k = 0; k < K; k++) {
 8016df0:	2f00      	cmp	r7, #0
 8016df2:	f77f af46 	ble.w	8016c82 <cblas_csyr2k+0x22e>
 8016df6:	f8dd 8000 	ldr.w	r8, [sp]
 8016dfa:	9b04      	ldr	r3, [sp, #16]
 8016dfc:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8016e00:	f108 0a08 	add.w	sl, r8, #8
 8016e04:	00db      	lsls	r3, r3, #3
 8016e06:	00f6      	lsls	r6, r6, #3
 8016e08:	9300      	str	r3, [sp, #0]
 8016e0a:	eb0a 0ac5 	add.w	sl, sl, r5, lsl #3
 8016e0e:	f04f 0b00 	mov.w	fp, #0
        for (i = 0; i < N; i++) {
 8016e12:	2d00      	cmp	r5, #0
 8016e14:	dd58      	ble.n	8016ec8 <cblas_csyr2k+0x474>
 8016e16:	9b02      	ldr	r3, [sp, #8]
 8016e18:	f108 0408 	add.w	r4, r8, #8
 8016e1c:	f103 0e04 	add.w	lr, r3, #4
 8016e20:	46cc      	mov	ip, r9
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016e22:	ed54 6a02 	vldr	s13, [r4, #-8]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8016e26:	ed14 6a01 	vldr	s12, [r4, #-4]
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8016e2a:	eddc 7a00 	vldr	s15, [ip]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8016e2e:	ed9c 7a01 	vldr	s14, [ip, #4]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016e32:	ee65 1a26 	vmul.f32	s3, s10, s13
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8016e36:	ee26 2a45 	vnmul.f32	s4, s12, s10
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016e3a:	ee65 2a27 	vmul.f32	s5, s10, s15
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016e3e:	ee27 3a45 	vnmul.f32	s6, s14, s10
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016e42:	eee5 1a86 	vfma.f32	s3, s11, s12
 8016e46:	f1ae 0004 	sub.w	r0, lr, #4
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016e4a:	4671      	mov	r1, lr
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8016e4c:	eea5 2aa6 	vfma.f32	s4, s11, s13
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016e50:	464a      	mov	r2, r9
 8016e52:	4643      	mov	r3, r8
 8016e54:	eee5 2a87 	vfma.f32	s5, s11, s14
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016e58:	eea5 3aa7 	vfma.f32	s6, s11, s15
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 8016e5c:	3308      	adds	r3, #8
 8016e5e:	3208      	adds	r2, #8
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8016e60:	ed53 3a01 	vldr	s7, [r3, #-4]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 8016e64:	ed12 4a01 	vldr	s8, [r2, #-4]
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 8016e68:	ed13 7a02 	vldr	s14, [r3, #-8]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 8016e6c:	ed52 7a02 	vldr	s15, [r2, #-8]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016e70:	ed11 6a01 	vldr	s12, [r1, #-4]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8016e74:	ee63 4ae2 	vnmul.f32	s9, s7, s5
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016e78:	ee64 6a61 	vnmul.f32	s13, s8, s3
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8016e7c:	eee3 4a07 	vfma.f32	s9, s6, s14
          for (j = 0; j <= i; j++) {
 8016e80:	429c      	cmp	r4, r3
 8016e82:	f101 0108 	add.w	r1, r1, #8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016e86:	eee2 6a27 	vfma.f32	s13, s4, s15
 8016e8a:	f100 0008 	add.w	r0, r0, #8
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8016e8e:	ee22 7a87 	vmul.f32	s14, s5, s14
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016e92:	ee61 7aa7 	vmul.f32	s15, s3, s15
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8016e96:	ee76 6aa4 	vadd.f32	s13, s13, s9
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8016e9a:	eea3 7a23 	vfma.f32	s14, s6, s7
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016e9e:	eee2 7a04 	vfma.f32	s15, s4, s8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016ea2:	ee76 6a26 	vadd.f32	s13, s12, s13
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8016ea6:	ee77 7a87 	vadd.f32	s15, s15, s14
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8016eaa:	ed41 6a03 	vstr	s13, [r1, #-12]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8016eae:	ed10 7a01 	vldr	s14, [r0, #-4]
 8016eb2:	ee77 7a27 	vadd.f32	s15, s14, s15
 8016eb6:	ed40 7a01 	vstr	s15, [r0, #-4]
          for (j = 0; j <= i; j++) {
 8016eba:	d1cf      	bne.n	8016e5c <cblas_csyr2k+0x408>
        for (i = 0; i < N; i++) {
 8016ebc:	3408      	adds	r4, #8
 8016ebe:	45a2      	cmp	sl, r4
 8016ec0:	f10c 0c08 	add.w	ip, ip, #8
 8016ec4:	44b6      	add	lr, r6
 8016ec6:	d1ac      	bne.n	8016e22 <cblas_csyr2k+0x3ce>
      for (k = 0; k < K; k++) {
 8016ec8:	9b00      	ldr	r3, [sp, #0]
 8016eca:	f10b 0b01 	add.w	fp, fp, #1
 8016ece:	455f      	cmp	r7, fp
 8016ed0:	44b2      	add	sl, r6
 8016ed2:	44b0      	add	r8, r6
 8016ed4:	4499      	add	r9, r3
 8016ed6:	d19c      	bne.n	8016e12 <cblas_csyr2k+0x3be>
 8016ed8:	e6d3      	b.n	8016c82 <cblas_csyr2k+0x22e>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8016eda:	eef5 5a40 	vcmp.f32	s11, #0.0
 8016ede:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016ee2:	f47f ae59 	bne.w	8016b98 <cblas_csyr2k+0x144>
 8016ee6:	e652      	b.n	8016b8e <cblas_csyr2k+0x13a>
      for (i = 0; i < N; i++) {
 8016ee8:	2d00      	cmp	r5, #0
 8016eea:	f77f aeca 	ble.w	8016c82 <cblas_csyr2k+0x22e>
 8016eee:	9b03      	ldr	r3, [sp, #12]
 8016ef0:	9900      	ldr	r1, [sp, #0]
 8016ef2:	f8dd b004 	ldr.w	fp, [sp, #4]
 8016ef6:	3301      	adds	r3, #1
 8016ef8:	00db      	lsls	r3, r3, #3
 8016efa:	9309      	str	r3, [sp, #36]	; 0x24
 8016efc:	9b02      	ldr	r3, [sp, #8]
 8016efe:	9702      	str	r7, [sp, #8]
 8016f00:	2200      	movs	r2, #0
 8016f02:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8016f06:	9205      	str	r2, [sp, #20]
 8016f08:	9203      	str	r2, [sp, #12]
 8016f0a:	9a04      	ldr	r2, [sp, #16]
 8016f0c:	00f3      	lsls	r3, r6, #3
 8016f0e:	9308      	str	r3, [sp, #32]
 8016f10:	00d3      	lsls	r3, r2, #3
 8016f12:	9304      	str	r3, [sp, #16]
 8016f14:	468a      	mov	sl, r1
 8016f16:	eb01 03c7 	add.w	r3, r1, r7, lsl #3
 8016f1a:	4691      	mov	r9, r2
          BASE temp_real = 0.0;
 8016f1c:	e9dd 8e05 	ldrd	r8, lr, [sp, #20]
 8016f20:	9f07      	ldr	r7, [sp, #28]
 8016f22:	f8dd c00c 	ldr.w	ip, [sp, #12]
          for (k = 0; k < K; k++) {
 8016f26:	9a02      	ldr	r2, [sp, #8]
          BASE temp_imag = 0.0;
 8016f28:	ed5f 1a54 	vldr	s3, [pc, #-336]	; 8016ddc <cblas_csyr2k+0x388>
          for (k = 0; k < K; k++) {
 8016f2c:	2a00      	cmp	r2, #0
          BASE temp_real = 0.0;
 8016f2e:	eeb0 1a61 	vmov.f32	s2, s3
          for (k = 0; k < K; k++) {
 8016f32:	dd38      	ble.n	8016fa6 <cblas_csyr2k+0x552>
 8016f34:	9a00      	ldr	r2, [sp, #0]
 8016f36:	eb02 04ce 	add.w	r4, r2, lr, lsl #3
 8016f3a:	9a01      	ldr	r2, [sp, #4]
 8016f3c:	4659      	mov	r1, fp
 8016f3e:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
 8016f42:	4652      	mov	r2, sl
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8016f44:	edd2 7a01 	vldr	s15, [r2, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8016f48:	ed90 2a01 	vldr	s4, [r0, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8016f4c:	ed90 3a00 	vldr	s6, [r0]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 8016f50:	ed91 7a01 	vldr	s14, [r1, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8016f54:	edd4 4a01 	vldr	s9, [r4, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8016f58:	edd4 3a00 	vldr	s7, [r4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8016f5c:	edd2 2a00 	vldr	s5, [r2]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8016f60:	ed91 4a00 	vldr	s8, [r1]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8016f64:	ee22 6a67 	vnmul.f32	s12, s4, s15
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8016f68:	ee64 6ac7 	vnmul.f32	s13, s9, s14
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8016f6c:	ee67 7a83 	vmul.f32	s15, s15, s6
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8016f70:	ee27 7a23 	vmul.f32	s14, s14, s7
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8016f74:	eee2 7a82 	vfma.f32	s15, s5, s4
 8016f78:	3208      	adds	r2, #8
          for (k = 0; k < K; k++) {
 8016f7a:	429a      	cmp	r2, r3
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8016f7c:	eea2 6a83 	vfma.f32	s12, s5, s6
 8016f80:	f100 0008 	add.w	r0, r0, #8
 8016f84:	f104 0408 	add.w	r4, r4, #8
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8016f88:	eee4 6a23 	vfma.f32	s13, s8, s7
 8016f8c:	f101 0108 	add.w	r1, r1, #8
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8016f90:	eea4 7a24 	vfma.f32	s14, s8, s9
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8016f94:	ee76 6a26 	vadd.f32	s13, s12, s13
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8016f98:	ee77 7a87 	vadd.f32	s15, s15, s14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8016f9c:	ee31 1a26 	vadd.f32	s2, s2, s13
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8016fa0:	ee71 1aa7 	vadd.f32	s3, s3, s15
          for (k = 0; k < K; k++) {
 8016fa4:	d1ce      	bne.n	8016f44 <cblas_csyr2k+0x4f0>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016fa6:	ee21 7ac5 	vnmul.f32	s14, s3, s10
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016faa:	ee65 7a01 	vmul.f32	s15, s10, s2
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016fae:	eea5 7a81 	vfma.f32	s14, s11, s2
        for (j = i; j < N; j++) {
 8016fb2:	f10c 0c01 	add.w	ip, ip, #1
 8016fb6:	4565      	cmp	r5, ip
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016fb8:	eee5 7aa1 	vfma.f32	s15, s11, s3
 8016fbc:	44b6      	add	lr, r6
 8016fbe:	44c8      	add	r8, r9
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016fc0:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016fc4:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016fc8:	ed97 7a00 	vldr	s14, [r7]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016fcc:	edd7 7a01 	vldr	s15, [r7, #4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016fd0:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016fd4:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016fd8:	ed87 7a00 	vstr	s14, [r7]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016fdc:	edc7 7a01 	vstr	s15, [r7, #4]
        for (j = i; j < N; j++) {
 8016fe0:	f107 0708 	add.w	r7, r7, #8
 8016fe4:	dc9f      	bgt.n	8016f26 <cblas_csyr2k+0x4d2>
      for (i = 0; i < N; i++) {
 8016fe6:	9907      	ldr	r1, [sp, #28]
 8016fe8:	9809      	ldr	r0, [sp, #36]	; 0x24
 8016fea:	9a03      	ldr	r2, [sp, #12]
 8016fec:	4401      	add	r1, r0
 8016fee:	9107      	str	r1, [sp, #28]
 8016ff0:	9906      	ldr	r1, [sp, #24]
 8016ff2:	9804      	ldr	r0, [sp, #16]
 8016ff4:	4431      	add	r1, r6
 8016ff6:	9106      	str	r1, [sp, #24]
 8016ff8:	9905      	ldr	r1, [sp, #20]
 8016ffa:	4449      	add	r1, r9
 8016ffc:	3201      	adds	r2, #1
 8016ffe:	9105      	str	r1, [sp, #20]
 8017000:	9908      	ldr	r1, [sp, #32]
 8017002:	9203      	str	r2, [sp, #12]
 8017004:	4295      	cmp	r5, r2
 8017006:	448a      	add	sl, r1
 8017008:	4483      	add	fp, r0
 801700a:	440b      	add	r3, r1
 801700c:	d186      	bne.n	8016f1c <cblas_csyr2k+0x4c8>
 801700e:	e638      	b.n	8016c82 <cblas_csyr2k+0x22e>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8017010:	200e      	movs	r0, #14
 8017012:	e55f      	b.n	8016ad4 <cblas_csyr2k+0x80>
      for (i = 0; i < N; i++) {
 8017014:	2d00      	cmp	r5, #0
 8017016:	f77f ae34 	ble.w	8016c82 <cblas_csyr2k+0x22e>
 801701a:	9b03      	ldr	r3, [sp, #12]
 801701c:	f8dd b004 	ldr.w	fp, [sp, #4]
 8017020:	9509      	str	r5, [sp, #36]	; 0x24
 8017022:	3301      	adds	r3, #1
 8017024:	00db      	lsls	r3, r3, #3
 8017026:	9308      	str	r3, [sp, #32]
 8017028:	9b02      	ldr	r3, [sp, #8]
 801702a:	f103 0908 	add.w	r9, r3, #8
 801702e:	00f3      	lsls	r3, r6, #3
 8017030:	9307      	str	r3, [sp, #28]
 8017032:	9b04      	ldr	r3, [sp, #16]
 8017034:	2200      	movs	r2, #0
 8017036:	9205      	str	r2, [sp, #20]
 8017038:	9206      	str	r2, [sp, #24]
 801703a:	00da      	lsls	r2, r3, #3
 801703c:	9204      	str	r2, [sp, #16]
 801703e:	9a00      	ldr	r2, [sp, #0]
 8017040:	4698      	mov	r8, r3
 8017042:	eb02 04c7 	add.w	r4, r2, r7, lsl #3
 8017046:	4692      	mov	sl, r2
 8017048:	9b02      	ldr	r3, [sp, #8]
 801704a:	9a05      	ldr	r2, [sp, #20]
          BASE temp_real = 0.0;
 801704c:	f04f 0c00 	mov.w	ip, #0
 8017050:	46e6      	mov	lr, ip
 8017052:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
          BASE temp_imag = 0.0;
 8017056:	ed5f 1a9f 	vldr	s3, [pc, #-636]	; 8016ddc <cblas_csyr2k+0x388>
          for (k = 0; k < K; k++) {
 801705a:	2f00      	cmp	r7, #0
          BASE temp_real = 0.0;
 801705c:	eeb0 1a61 	vmov.f32	s2, s3
          for (k = 0; k < K; k++) {
 8017060:	dd38      	ble.n	80170d4 <cblas_csyr2k+0x680>
 8017062:	9b00      	ldr	r3, [sp, #0]
 8017064:	eb03 00ce 	add.w	r0, r3, lr, lsl #3
 8017068:	9b01      	ldr	r3, [sp, #4]
 801706a:	465a      	mov	r2, fp
 801706c:	eb03 01cc 	add.w	r1, r3, ip, lsl #3
 8017070:	4653      	mov	r3, sl
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8017072:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8017076:	ed91 2a01 	vldr	s4, [r1, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801707a:	ed91 3a00 	vldr	s6, [r1]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801707e:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8017082:	edd0 4a01 	vldr	s9, [r0, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8017086:	edd0 3a00 	vldr	s7, [r0]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801708a:	edd3 2a00 	vldr	s5, [r3]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801708e:	ed92 4a00 	vldr	s8, [r2]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8017092:	ee22 6a67 	vnmul.f32	s12, s4, s15
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8017096:	ee64 6ac7 	vnmul.f32	s13, s9, s14
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 801709a:	ee67 7a83 	vmul.f32	s15, s15, s6
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 801709e:	ee27 7a23 	vmul.f32	s14, s14, s7
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80170a2:	eee2 7a82 	vfma.f32	s15, s5, s4
 80170a6:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 80170a8:	429c      	cmp	r4, r3
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80170aa:	eea2 6a83 	vfma.f32	s12, s5, s6
 80170ae:	f101 0108 	add.w	r1, r1, #8
 80170b2:	f100 0008 	add.w	r0, r0, #8
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80170b6:	eee4 6a23 	vfma.f32	s13, s8, s7
 80170ba:	f102 0208 	add.w	r2, r2, #8
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80170be:	eea4 7a24 	vfma.f32	s14, s8, s9
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80170c2:	ee76 6a26 	vadd.f32	s13, s12, s13
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80170c6:	ee77 7a87 	vadd.f32	s15, s15, s14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80170ca:	ee31 1a26 	vadd.f32	s2, s2, s13
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80170ce:	ee71 1aa7 	vadd.f32	s3, s3, s15
          for (k = 0; k < K; k++) {
 80170d2:	d1ce      	bne.n	8017072 <cblas_csyr2k+0x61e>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80170d4:	ee21 7ac5 	vnmul.f32	s14, s3, s10
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80170d8:	ee65 7a01 	vmul.f32	s15, s10, s2
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80170dc:	eea5 7a81 	vfma.f32	s14, s11, s2
 80170e0:	3508      	adds	r5, #8
 80170e2:	44b6      	add	lr, r6
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80170e4:	eee5 7aa1 	vfma.f32	s15, s11, s3
 80170e8:	44c4      	add	ip, r8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80170ea:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80170ee:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80170f2:	ed15 7a02 	vldr	s14, [r5, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80170f6:	ed55 7a01 	vldr	s15, [r5, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80170fa:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80170fe:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017102:	ed05 7a02 	vstr	s14, [r5, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017106:	ed45 7a01 	vstr	s15, [r5, #-4]
        for (j = 0; j <= i; j++) {
 801710a:	45a9      	cmp	r9, r5
 801710c:	d1a3      	bne.n	8017056 <cblas_csyr2k+0x602>
      for (i = 0; i < N; i++) {
 801710e:	9a05      	ldr	r2, [sp, #20]
 8017110:	9903      	ldr	r1, [sp, #12]
 8017112:	9b06      	ldr	r3, [sp, #24]
 8017114:	440a      	add	r2, r1
 8017116:	9205      	str	r2, [sp, #20]
 8017118:	9a08      	ldr	r2, [sp, #32]
 801711a:	9904      	ldr	r1, [sp, #16]
 801711c:	4491      	add	r9, r2
 801711e:	9a07      	ldr	r2, [sp, #28]
 8017120:	4492      	add	sl, r2
 8017122:	4414      	add	r4, r2
 8017124:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8017126:	3301      	adds	r3, #1
 8017128:	429a      	cmp	r2, r3
 801712a:	9306      	str	r3, [sp, #24]
 801712c:	448b      	add	fp, r1
 801712e:	d18b      	bne.n	8017048 <cblas_csyr2k+0x5f4>
 8017130:	e5a7      	b.n	8016c82 <cblas_csyr2k+0x22e>
        for (i = 0; i < N; i++) {
 8017132:	2d00      	cmp	r5, #0
 8017134:	f77f adc9 	ble.w	8016cca <cblas_csyr2k+0x276>
 8017138:	9b03      	ldr	r3, [sp, #12]
 801713a:	9802      	ldr	r0, [sp, #8]
 801713c:	f103 0c01 	add.w	ip, r3, #1
 8017140:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8017144:	2100      	movs	r1, #0
 8017146:	4603      	mov	r3, r0
 8017148:	460a      	mov	r2, r1
            const BASE Cij_real = REAL(C, ldc * i + j);
 801714a:	edd3 4a00 	vldr	s9, [r3]
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 801714e:	ed93 4a01 	vldr	s8, [r3, #4]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8017152:	ee26 7a24 	vmul.f32	s14, s12, s9
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8017156:	ee64 7a46 	vnmul.f32	s15, s8, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801715a:	eea6 7a84 	vfma.f32	s14, s13, s8
          for (j = i; j < N; j++) {
 801715e:	3201      	adds	r2, #1
 8017160:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8017162:	eee6 7aa4 	vfma.f32	s15, s13, s9
 8017166:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801716a:	ed03 7a01 	vstr	s14, [r3, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801716e:	ed43 7a02 	vstr	s15, [r3, #-8]
          for (j = i; j < N; j++) {
 8017172:	dcea      	bgt.n	801714a <cblas_csyr2k+0x6f6>
        for (i = 0; i < N; i++) {
 8017174:	3101      	adds	r1, #1
 8017176:	428d      	cmp	r5, r1
 8017178:	4460      	add	r0, ip
 801717a:	d1e4      	bne.n	8017146 <cblas_csyr2k+0x6f2>
 801717c:	e5a5      	b.n	8016cca <cblas_csyr2k+0x276>
 801717e:	463b      	mov	r3, r7
 8017180:	e519      	b.n	8016bb6 <cblas_csyr2k+0x162>
 8017182:	bf00      	nop

08017184 <cblas_csyrk>:
void
cblas_csyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const void *alpha, const void *A, const int lda,
             const void *beta, void *C, const int ldc)
{
 8017184:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017188:	b087      	sub	sp, #28
 801718a:	461e      	mov	r6, r3
 801718c:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 8017190:	4691      	mov	r9, r2
 8017192:	9302      	str	r3, [sp, #8]
 8017194:	e9dd 3214 	ldrd	r3, r2, [sp, #80]	; 0x50

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8017198:	2865      	cmp	r0, #101	; 0x65
 801719a:	e9dd 7412 	ldrd	r7, r4, [sp, #72]	; 0x48
 801719e:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
 80171a2:	9201      	str	r2, [sp, #4]
 80171a4:	4682      	mov	sl, r0
 80171a6:	4688      	mov	r8, r1
 80171a8:	f000 80ff 	beq.w	80173aa <cblas_csyrk+0x226>
 80171ac:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80171b0:	d01f      	beq.n	80171f2 <cblas_csyrk+0x6e>
 80171b2:	462a      	mov	r2, r5
 80171b4:	f1a8 0179 	sub.w	r1, r8, #121	; 0x79
 80171b8:	2901      	cmp	r1, #1
 80171ba:	f240 80ef 	bls.w	801739c <cblas_csyrk+0x218>
 80171be:	2002      	movs	r0, #2
 80171c0:	f1a9 016f 	sub.w	r1, r9, #111	; 0x6f
 80171c4:	2902      	cmp	r1, #2
 80171c6:	bf88      	it	hi
 80171c8:	2003      	movhi	r0, #3
 80171ca:	2e00      	cmp	r6, #0
 80171cc:	bfb8      	it	lt
 80171ce:	2004      	movlt	r0, #4
 80171d0:	2a01      	cmp	r2, #1
 80171d2:	bfb8      	it	lt
 80171d4:	2201      	movlt	r2, #1
 80171d6:	2d00      	cmp	r5, #0
 80171d8:	f2c0 80d4 	blt.w	8017384 <cblas_csyrk+0x200>
 80171dc:	42a2      	cmp	r2, r4
 80171de:	dc10      	bgt.n	8017202 <cblas_csyrk+0x7e>
 80171e0:	2e01      	cmp	r6, #1
 80171e2:	4632      	mov	r2, r6
 80171e4:	bfb8      	it	lt
 80171e6:	2201      	movlt	r2, #1
 80171e8:	455a      	cmp	r2, fp
 80171ea:	f300 81d5 	bgt.w	8017598 <cblas_csyrk+0x414>
 80171ee:	b1b0      	cbz	r0, 801721e <cblas_csyrk+0x9a>
 80171f0:	e00f      	b.n	8017212 <cblas_csyrk+0x8e>
 80171f2:	4632      	mov	r2, r6
 80171f4:	f1a8 0179 	sub.w	r1, r8, #121	; 0x79
 80171f8:	2901      	cmp	r1, #1
 80171fa:	f240 80cf 	bls.w	801739c <cblas_csyrk+0x218>
 80171fe:	2002      	movs	r0, #2
 8017200:	e7e3      	b.n	80171ca <cblas_csyrk+0x46>
 8017202:	2e01      	cmp	r6, #1
 8017204:	4630      	mov	r0, r6
 8017206:	bfb8      	it	lt
 8017208:	2001      	movlt	r0, #1
 801720a:	4558      	cmp	r0, fp
 801720c:	bfcc      	ite	gt
 801720e:	200b      	movgt	r0, #11
 8017210:	2008      	movle	r0, #8
 8017212:	4add      	ldr	r2, [pc, #884]	; (8017588 <cblas_csyrk+0x404>)
 8017214:	49dd      	ldr	r1, [pc, #884]	; (801758c <cblas_csyrk+0x408>)
 8017216:	9303      	str	r3, [sp, #12]
 8017218:	f011 fa76 	bl	8028708 <cblas_xerbla>
 801721c:	9b03      	ldr	r3, [sp, #12]

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 801721e:	9a02      	ldr	r2, [sp, #8]
    const BASE alpha_imag = CONST_IMAG0(alpha);

    const BASE beta_real = CONST_REAL0(beta);
 8017220:	edd3 6a00 	vldr	s13, [r3]
    const BASE alpha_real = CONST_REAL0(alpha);
 8017224:	edd2 4a00 	vldr	s9, [r2]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8017228:	ed92 4a01 	vldr	s8, [r2, #4]
    const BASE beta_imag = CONST_IMAG0(beta);
 801722c:	ed93 6a01 	vldr	s12, [r3, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8017230:	eef5 4a40 	vcmp.f32	s9, #0.0
 8017234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    const BASE alpha_real = CONST_REAL0(alpha);
 8017238:	4611      	mov	r1, r2
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801723a:	d10c      	bne.n	8017256 <cblas_csyrk+0xd2>
 801723c:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8017240:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017244:	d107      	bne.n	8017256 <cblas_csyrk+0xd2>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8017246:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801724a:	eef4 6a67 	vcmp.f32	s13, s15
 801724e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017252:	f000 808e 	beq.w	8017372 <cblas_csyrk+0x1ee>
      return;

    if (Order == CblasRowMajor) {
 8017256:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801725a:	f000 80ac 	beq.w	80173b6 <cblas_csyrk+0x232>
      uplo = Uplo;
      /* FIXME: original blas does not make distinction between Trans and ConjTrans?? */
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
    } else {
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801725e:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8017262:	bf0c      	ite	eq
 8017264:	f04f 087a 	moveq.w	r8, #122	; 0x7a
 8017268:	f04f 0879 	movne.w	r8, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 801726c:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 8017270:	bf0c      	ite	eq
 8017272:	2170      	moveq	r1, #112	; 0x70
 8017274:	216f      	movne	r1, #111	; 0x6f
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8017276:	eef5 6a40 	vcmp.f32	s13, #0.0
 801727a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801727e:	d13d      	bne.n	80172fc <cblas_csyrk+0x178>
 8017280:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8017284:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017288:	d145      	bne.n	8017316 <cblas_csyrk+0x192>
      if (uplo == CblasUpper) {
 801728a:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801728e:	f000 8098 	beq.w	80173c2 <cblas_csyrk+0x23e>
            REAL(C, ldc * i + j) = 0.0;
            IMAG(C, ldc * i + j) = 0.0;
          }
        }
      } else {
        for (i = 0; i < N; i++) {
 8017292:	2e00      	cmp	r6, #0
 8017294:	dd18      	ble.n	80172c8 <cblas_csyrk+0x144>
 8017296:	9b01      	ldr	r3, [sp, #4]
 8017298:	f10b 0901 	add.w	r9, fp, #1
 801729c:	f04f 0c00 	mov.w	ip, #0
 80172a0:	4618      	mov	r0, r3
          for (j = 0; j <= i; j++) {
            REAL(C, ldc * i + j) = 0.0;
 80172a2:	2200      	movs	r2, #0
 80172a4:	ea4f 09c9 	mov.w	r9, r9, lsl #3
        for (i = 0; i < N; i++) {
 80172a8:	46e6      	mov	lr, ip
 80172aa:	3008      	adds	r0, #8
 80172ac:	469a      	mov	sl, r3
 80172ae:	eb0a 03cc 	add.w	r3, sl, ip, lsl #3
            REAL(C, ldc * i + j) = 0.0;
 80172b2:	601a      	str	r2, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 80172b4:	605a      	str	r2, [r3, #4]
          for (j = 0; j <= i; j++) {
 80172b6:	3308      	adds	r3, #8
 80172b8:	4298      	cmp	r0, r3
 80172ba:	d1fa      	bne.n	80172b2 <cblas_csyrk+0x12e>
        for (i = 0; i < N; i++) {
 80172bc:	f10e 0e01 	add.w	lr, lr, #1
 80172c0:	4576      	cmp	r6, lr
 80172c2:	44dc      	add	ip, fp
 80172c4:	4448      	add	r0, r9
 80172c6:	d1f2      	bne.n	80172ae <cblas_csyrk+0x12a>
          }
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80172c8:	eef5 4a40 	vcmp.f32	s9, #0.0
 80172cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80172d0:	d108      	bne.n	80172e4 <cblas_csyrk+0x160>
 80172d2:	eeb5 4a40 	vcmp.f32	s8, #0.0
 80172d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80172da:	d050      	beq.n	801737e <cblas_csyrk+0x1fa>
      return;

    if (uplo == CblasUpper && trans == CblasNoTrans) {
 80172dc:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80172e0:	f000 808e 	beq.w	8017400 <cblas_csyrk+0x27c>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80172e4:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 80172e8:	f000 80e5 	beq.w	80174b6 <cblas_csyrk+0x332>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 80172ec:	4aa8      	ldr	r2, [pc, #672]	; (8017590 <cblas_csyrk+0x40c>)
 80172ee:	49a7      	ldr	r1, [pc, #668]	; (801758c <cblas_csyrk+0x408>)
 80172f0:	2000      	movs	r0, #0
#define BASE float
#include "source_syrk_c.h"
#undef BASE
}
 80172f2:	b007      	add	sp, #28
 80172f4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80172f8:	f011 ba06 	b.w	8028708 <cblas_xerbla>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 80172fc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8017300:	eef4 6a67 	vcmp.f32	s13, s15
 8017304:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017308:	d105      	bne.n	8017316 <cblas_csyrk+0x192>
 801730a:	eeb5 6a40 	vcmp.f32	s12, #0.0
 801730e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017312:	f000 8131 	beq.w	8017578 <cblas_csyrk+0x3f4>
      if (uplo == CblasUpper) {
 8017316:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801731a:	f000 8204 	beq.w	8017726 <cblas_csyrk+0x5a2>
        for (i = 0; i < N; i++) {
 801731e:	2e00      	cmp	r6, #0
 8017320:	ddd2      	ble.n	80172c8 <cblas_csyrk+0x144>
 8017322:	9b01      	ldr	r3, [sp, #4]
 8017324:	ea4f 09cb 	mov.w	r9, fp, lsl #3
 8017328:	f109 0a08 	add.w	sl, r9, #8
 801732c:	469c      	mov	ip, r3
 801732e:	f103 0008 	add.w	r0, r3, #8
 8017332:	f04f 0e00 	mov.w	lr, #0
 8017336:	f10c 0204 	add.w	r2, ip, #4
 801733a:	4663      	mov	r3, ip
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 801733c:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Cij_real = REAL(C, ldc * i + j);
 8017340:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8017344:	ee25 7ac6 	vnmul.f32	s14, s11, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8017348:	ee66 7a05 	vmul.f32	s15, s12, s10
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801734c:	eea6 7a85 	vfma.f32	s14, s13, s10
 8017350:	3308      	adds	r3, #8
 8017352:	3208      	adds	r2, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8017354:	eee6 7aa5 	vfma.f32	s15, s13, s11
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8017358:	ed02 7a03 	vstr	s14, [r2, #-12]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801735c:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j <= i; j++) {
 8017360:	4298      	cmp	r0, r3
 8017362:	d1eb      	bne.n	801733c <cblas_csyrk+0x1b8>
        for (i = 0; i < N; i++) {
 8017364:	f10e 0e01 	add.w	lr, lr, #1
 8017368:	4576      	cmp	r6, lr
 801736a:	44cc      	add	ip, r9
 801736c:	4450      	add	r0, sl
 801736e:	d1e2      	bne.n	8017336 <cblas_csyrk+0x1b2>
 8017370:	e7aa      	b.n	80172c8 <cblas_csyrk+0x144>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8017372:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8017376:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801737a:	f47f af6c 	bne.w	8017256 <cblas_csyrk+0xd2>
 801737e:	b007      	add	sp, #28
 8017380:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8017384:	42a2      	cmp	r2, r4
 8017386:	f73f af3c 	bgt.w	8017202 <cblas_csyrk+0x7e>
 801738a:	2e01      	cmp	r6, #1
 801738c:	4630      	mov	r0, r6
 801738e:	bfb8      	it	lt
 8017390:	2001      	movlt	r0, #1
 8017392:	4583      	cmp	fp, r0
 8017394:	bfb4      	ite	lt
 8017396:	200b      	movlt	r0, #11
 8017398:	2005      	movge	r0, #5
 801739a:	e73a      	b.n	8017212 <cblas_csyrk+0x8e>
 801739c:	f1aa 0065 	sub.w	r0, sl, #101	; 0x65
 80173a0:	2801      	cmp	r0, #1
 80173a2:	bf94      	ite	ls
 80173a4:	2000      	movls	r0, #0
 80173a6:	2001      	movhi	r0, #1
 80173a8:	e70a      	b.n	80171c0 <cblas_csyrk+0x3c>
 80173aa:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80173ae:	f000 81e0 	beq.w	8017772 <cblas_csyrk+0x5ee>
 80173b2:	4632      	mov	r2, r6
 80173b4:	e6fe      	b.n	80171b4 <cblas_csyrk+0x30>
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80173b6:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80173ba:	bf0c      	ite	eq
 80173bc:	216f      	moveq	r1, #111	; 0x6f
 80173be:	2170      	movne	r1, #112	; 0x70
 80173c0:	e759      	b.n	8017276 <cblas_csyrk+0xf2>
        for (i = 0; i < N; i++) {
 80173c2:	2e00      	cmp	r6, #0
 80173c4:	dd16      	ble.n	80173f4 <cblas_csyrk+0x270>
 80173c6:	f10b 0901 	add.w	r9, fp, #1
 80173ca:	f8dd e004 	ldr.w	lr, [sp, #4]
            REAL(C, ldc * i + j) = 0.0;
 80173ce:	2000      	movs	r0, #0
 80173d0:	ea4f 09c9 	mov.w	r9, r9, lsl #3
        for (i = 0; i < N; i++) {
 80173d4:	f04f 0c00 	mov.w	ip, #0
 80173d8:	4673      	mov	r3, lr
 80173da:	4662      	mov	r2, ip
          for (j = i; j < N; j++) {
 80173dc:	3201      	adds	r2, #1
 80173de:	4296      	cmp	r6, r2
            REAL(C, ldc * i + j) = 0.0;
 80173e0:	6018      	str	r0, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 80173e2:	6058      	str	r0, [r3, #4]
          for (j = i; j < N; j++) {
 80173e4:	f103 0308 	add.w	r3, r3, #8
 80173e8:	dcf8      	bgt.n	80173dc <cblas_csyrk+0x258>
        for (i = 0; i < N; i++) {
 80173ea:	f10c 0c01 	add.w	ip, ip, #1
 80173ee:	4566      	cmp	r6, ip
 80173f0:	44ce      	add	lr, r9
 80173f2:	d1f1      	bne.n	80173d8 <cblas_csyrk+0x254>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80173f4:	eef5 4a40 	vcmp.f32	s9, #0.0
 80173f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80173fc:	f43f af69 	beq.w	80172d2 <cblas_csyrk+0x14e>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8017400:	296f      	cmp	r1, #111	; 0x6f
 8017402:	f000 80cb 	beq.w	801759c <cblas_csyrk+0x418>
      for (i = 0; i < N; i++) {
 8017406:	2e00      	cmp	r6, #0
 8017408:	ddb9      	ble.n	801737e <cblas_csyrk+0x1fa>
 801740a:	f10b 0901 	add.w	r9, fp, #1
 801740e:	f8dd b004 	ldr.w	fp, [sp, #4]
 8017412:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8017416:	00e4      	lsls	r4, r4, #3
 8017418:	f107 0e04 	add.w	lr, r7, #4
 801741c:	f04f 0800 	mov.w	r8, #0
          BASE temp_real = 0.0;
 8017420:	4658      	mov	r0, fp
 8017422:	46c4      	mov	ip, r8
          BASE temp_imag = 0.0;
 8017424:	ed9f 5a5b 	vldr	s10, [pc, #364]	; 8017594 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 8017428:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 801742a:	eef0 3a45 	vmov.f32	s7, s10
          for (k = 0; k < K; k++) {
 801742e:	dd1c      	ble.n	801746a <cblas_csyrk+0x2e6>
 8017430:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 8017434:	4673      	mov	r3, lr
 8017436:	2100      	movs	r1, #0
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8017438:	edd3 7a00 	vldr	s15, [r3]
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801743c:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8017440:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8017444:	ed13 6a01 	vldr	s12, [r3, #-4]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8017448:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801744c:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8017450:	eea6 7a25 	vfma.f32	s14, s12, s11
          for (k = 0; k < K; k++) {
 8017454:	3101      	adds	r1, #1
 8017456:	428d      	cmp	r5, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8017458:	eee6 7a26 	vfma.f32	s15, s12, s13
 801745c:	4422      	add	r2, r4
 801745e:	4423      	add	r3, r4
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8017460:	ee73 3a87 	vadd.f32	s7, s7, s14
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8017464:	ee35 5a27 	vadd.f32	s10, s10, s15
          for (k = 0; k < K; k++) {
 8017468:	d1e6      	bne.n	8017438 <cblas_csyrk+0x2b4>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801746a:	ee25 7a44 	vnmul.f32	s14, s10, s8
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801746e:	ee64 7a23 	vmul.f32	s15, s8, s7
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017472:	eea4 7aa3 	vfma.f32	s14, s9, s7
        for (j = i; j < N; j++) {
 8017476:	f10c 0c01 	add.w	ip, ip, #1
 801747a:	4566      	cmp	r6, ip
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801747c:	eee4 7a85 	vfma.f32	s15, s9, s10
 8017480:	f100 0008 	add.w	r0, r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017484:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017488:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801748c:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017490:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017494:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017498:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801749c:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80174a0:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = i; j < N; j++) {
 80174a4:	dcbe      	bgt.n	8017424 <cblas_csyrk+0x2a0>
      for (i = 0; i < N; i++) {
 80174a6:	f108 0801 	add.w	r8, r8, #1
 80174aa:	4546      	cmp	r6, r8
 80174ac:	44cb      	add	fp, r9
 80174ae:	f10e 0e08 	add.w	lr, lr, #8
 80174b2:	d1b5      	bne.n	8017420 <cblas_csyrk+0x29c>
 80174b4:	e763      	b.n	801737e <cblas_csyrk+0x1fa>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80174b6:	296f      	cmp	r1, #111	; 0x6f
 80174b8:	f000 80d0 	beq.w	801765c <cblas_csyrk+0x4d8>
      for (i = 0; i < N; i++) {
 80174bc:	2e00      	cmp	r6, #0
 80174be:	f77f af5e 	ble.w	801737e <cblas_csyrk+0x1fa>
 80174c2:	9b01      	ldr	r3, [sp, #4]
 80174c4:	3304      	adds	r3, #4
 80174c6:	00e4      	lsls	r4, r4, #3
 80174c8:	f107 0904 	add.w	r9, r7, #4
 80174cc:	f04f 0a00 	mov.w	sl, #0
 80174d0:	f04f 0801 	mov.w	r8, #1
 80174d4:	9302      	str	r3, [sp, #8]
 80174d6:	9b01      	ldr	r3, [sp, #4]
 80174d8:	eb03 0cca 	add.w	ip, r3, sl, lsl #3
 80174dc:	9b02      	ldr	r3, [sp, #8]
        for (j = 0; j <= i; j++) {
 80174de:	f04f 0e00 	mov.w	lr, #0
 80174e2:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
          BASE temp_imag = 0.0;
 80174e6:	eddf 3a2b 	vldr	s7, [pc, #172]	; 8017594 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 80174ea:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 80174ec:	eeb0 5a63 	vmov.f32	s10, s7
          for (k = 0; k < K; k++) {
 80174f0:	dd1c      	ble.n	801752c <cblas_csyrk+0x3a8>
 80174f2:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 80174f6:	464b      	mov	r3, r9
 80174f8:	2100      	movs	r1, #0
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 80174fa:	edd3 7a00 	vldr	s15, [r3]
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80174fe:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8017502:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8017506:	ed13 6a01 	vldr	s12, [r3, #-4]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801750a:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801750e:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8017512:	eea6 7a25 	vfma.f32	s14, s12, s11
          for (k = 0; k < K; k++) {
 8017516:	3101      	adds	r1, #1
 8017518:	428d      	cmp	r5, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801751a:	eee6 7a26 	vfma.f32	s15, s12, s13
 801751e:	4422      	add	r2, r4
 8017520:	4423      	add	r3, r4
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8017522:	ee35 5a07 	vadd.f32	s10, s10, s14
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8017526:	ee73 3aa7 	vadd.f32	s7, s7, s15
          for (k = 0; k < K; k++) {
 801752a:	d1e6      	bne.n	80174fa <cblas_csyrk+0x376>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801752c:	ee63 7ac4 	vnmul.f32	s15, s7, s8
 8017530:	ed10 7a01 	vldr	s14, [r0, #-4]
 8017534:	eee4 7a85 	vfma.f32	s15, s9, s10
        for (j = 0; j <= i; j++) {
 8017538:	f10e 0e01 	add.w	lr, lr, #1
 801753c:	45c6      	cmp	lr, r8
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801753e:	ee24 5a05 	vmul.f32	s10, s8, s10
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017542:	ee77 7a27 	vadd.f32	s15, s14, s15
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017546:	eea4 5aa3 	vfma.f32	s10, s9, s7
 801754a:	f100 0008 	add.w	r0, r0, #8
 801754e:	f10c 0c08 	add.w	ip, ip, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017552:	ed40 7a03 	vstr	s15, [r0, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017556:	ed5c 7a01 	vldr	s15, [ip, #-4]
 801755a:	ee37 5a85 	vadd.f32	s10, s15, s10
 801755e:	ed0c 5a01 	vstr	s10, [ip, #-4]
        for (j = 0; j <= i; j++) {
 8017562:	d1c0      	bne.n	80174e6 <cblas_csyrk+0x362>
      for (i = 0; i < N; i++) {
 8017564:	4546      	cmp	r6, r8
 8017566:	44da      	add	sl, fp
 8017568:	f109 0908 	add.w	r9, r9, #8
 801756c:	f108 0301 	add.w	r3, r8, #1
 8017570:	f43f af05 	beq.w	801737e <cblas_csyrk+0x1fa>
 8017574:	4698      	mov	r8, r3
 8017576:	e7ae      	b.n	80174d6 <cblas_csyrk+0x352>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8017578:	eef5 4a40 	vcmp.f32	s9, #0.0
 801757c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017580:	f47f aeac 	bne.w	80172dc <cblas_csyrk+0x158>
 8017584:	e6a5      	b.n	80172d2 <cblas_csyrk+0x14e>
 8017586:	bf00      	nop
 8017588:	08031108 	.word	0x08031108
 801758c:	08031384 	.word	0x08031384
 8017590:	080311b8 	.word	0x080311b8
 8017594:	00000000 	.word	0x00000000
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8017598:	200b      	movs	r0, #11
 801759a:	e63a      	b.n	8017212 <cblas_csyrk+0x8e>
      for (i = 0; i < N; i++) {
 801759c:	2e00      	cmp	r6, #0
 801759e:	f77f aeee 	ble.w	801737e <cblas_csyrk+0x1fa>
 80175a2:	f10b 0301 	add.w	r3, fp, #1
 80175a6:	00db      	lsls	r3, r3, #3
 80175a8:	f04f 0a00 	mov.w	sl, #0
 80175ac:	9302      	str	r3, [sp, #8]
 80175ae:	00e3      	lsls	r3, r4, #3
 80175b0:	f8dd b004 	ldr.w	fp, [sp, #4]
 80175b4:	9301      	str	r3, [sp, #4]
 80175b6:	46d1      	mov	r9, sl
 80175b8:	eb07 00c5 	add.w	r0, r7, r5, lsl #3
 80175bc:	46b8      	mov	r8, r7
          BASE temp_real = 0.0;
 80175be:	46d6      	mov	lr, sl
 80175c0:	4659      	mov	r1, fp
 80175c2:	46cc      	mov	ip, r9
          BASE temp_imag = 0.0;
 80175c4:	ed1f 5a0d 	vldr	s10, [pc, #-52]	; 8017594 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 80175c8:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 80175ca:	eef0 3a45 	vmov.f32	s7, s10
          for (k = 0; k < K; k++) {
 80175ce:	dd1b      	ble.n	8017608 <cblas_csyrk+0x484>
 80175d0:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 80175d4:	4643      	mov	r3, r8
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80175d6:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80175da:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80175de:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80175e2:	ed93 6a00 	vldr	s12, [r3]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80175e6:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80175ea:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80175ee:	eea6 7a25 	vfma.f32	s14, s12, s11
 80175f2:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 80175f4:	4298      	cmp	r0, r3
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80175f6:	eee6 7a26 	vfma.f32	s15, s12, s13
 80175fa:	f102 0208 	add.w	r2, r2, #8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80175fe:	ee73 3a87 	vadd.f32	s7, s7, s14
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8017602:	ee35 5a27 	vadd.f32	s10, s10, s15
          for (k = 0; k < K; k++) {
 8017606:	d1e6      	bne.n	80175d6 <cblas_csyrk+0x452>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017608:	ee25 7a44 	vnmul.f32	s14, s10, s8
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801760c:	ee63 7a84 	vmul.f32	s15, s7, s8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017610:	eea3 7aa4 	vfma.f32	s14, s7, s9
        for (j = i; j < N; j++) {
 8017614:	f10c 0c01 	add.w	ip, ip, #1
 8017618:	4566      	cmp	r6, ip
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801761a:	eee4 7a85 	vfma.f32	s15, s9, s10
 801761e:	44a6      	add	lr, r4
 8017620:	f101 0108 	add.w	r1, r1, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017624:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017628:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801762c:	ed11 7a02 	vldr	s14, [r1, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017630:	ed51 7a01 	vldr	s15, [r1, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8017634:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017638:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801763c:	ed01 7a02 	vstr	s14, [r1, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8017640:	ed41 7a01 	vstr	s15, [r1, #-4]
        for (j = i; j < N; j++) {
 8017644:	dcbe      	bgt.n	80175c4 <cblas_csyrk+0x440>
      for (i = 0; i < N; i++) {
 8017646:	9b02      	ldr	r3, [sp, #8]
 8017648:	f109 0901 	add.w	r9, r9, #1
 801764c:	449b      	add	fp, r3
 801764e:	9b01      	ldr	r3, [sp, #4]
 8017650:	454e      	cmp	r6, r9
 8017652:	44a2      	add	sl, r4
 8017654:	4498      	add	r8, r3
 8017656:	4418      	add	r0, r3
 8017658:	d1b1      	bne.n	80175be <cblas_csyrk+0x43a>
 801765a:	e690      	b.n	801737e <cblas_csyrk+0x1fa>
      for (i = 0; i < N; i++) {
 801765c:	2e00      	cmp	r6, #0
 801765e:	f77f ae8e 	ble.w	801737e <cblas_csyrk+0x1fa>
 8017662:	f10b 0301 	add.w	r3, fp, #1
 8017666:	00db      	lsls	r3, r3, #3
 8017668:	9303      	str	r3, [sp, #12]
 801766a:	9b01      	ldr	r3, [sp, #4]
 801766c:	f04f 0a00 	mov.w	sl, #0
 8017670:	f103 0808 	add.w	r8, r3, #8
 8017674:	00e2      	lsls	r2, r4, #3
 8017676:	3304      	adds	r3, #4
 8017678:	e9cd 6b04 	strd	r6, fp, [sp, #16]
 801767c:	46d6      	mov	lr, sl
 801767e:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
 8017682:	46b9      	mov	r9, r7
 8017684:	9302      	str	r3, [sp, #8]
 8017686:	4693      	mov	fp, r2
 8017688:	9b01      	ldr	r3, [sp, #4]
 801768a:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
 801768e:	9b02      	ldr	r3, [sp, #8]
          BASE temp_real = 0.0;
 8017690:	f04f 0c00 	mov.w	ip, #0
 8017694:	eb03 06ca 	add.w	r6, r3, sl, lsl #3
          BASE temp_imag = 0.0;
 8017698:	ed5f 3a42 	vldr	s7, [pc, #-264]	; 8017594 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 801769c:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 801769e:	eeb0 5a63 	vmov.f32	s10, s7
          for (k = 0; k < K; k++) {
 80176a2:	dd1b      	ble.n	80176dc <cblas_csyrk+0x558>
 80176a4:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 80176a8:	464b      	mov	r3, r9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80176aa:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80176ae:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80176b2:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80176b6:	ed93 6a00 	vldr	s12, [r3]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80176ba:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80176be:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80176c2:	eea6 7a25 	vfma.f32	s14, s12, s11
 80176c6:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 80176c8:	4299      	cmp	r1, r3
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80176ca:	eee6 7a26 	vfma.f32	s15, s12, s13
 80176ce:	f102 0208 	add.w	r2, r2, #8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80176d2:	ee35 5a07 	vadd.f32	s10, s10, s14
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80176d6:	ee73 3aa7 	vadd.f32	s7, s7, s15
          for (k = 0; k < K; k++) {
 80176da:	d1e6      	bne.n	80176aa <cblas_csyrk+0x526>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80176dc:	ee63 7ac4 	vnmul.f32	s15, s7, s8
 80176e0:	ed16 7a01 	vldr	s14, [r6, #-4]
 80176e4:	eee4 7a85 	vfma.f32	s15, s9, s10
 80176e8:	3008      	adds	r0, #8
 80176ea:	44a4      	add	ip, r4
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80176ec:	ee24 5a05 	vmul.f32	s10, s8, s10
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80176f0:	ee77 7a27 	vadd.f32	s15, s14, s15
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80176f4:	eea4 5aa3 	vfma.f32	s10, s9, s7
 80176f8:	3608      	adds	r6, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80176fa:	ed46 7a03 	vstr	s15, [r6, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80176fe:	ed50 7a01 	vldr	s15, [r0, #-4]
 8017702:	ee37 5a85 	vadd.f32	s10, s15, s10
 8017706:	ed00 5a01 	vstr	s10, [r0, #-4]
        for (j = 0; j <= i; j++) {
 801770a:	4580      	cmp	r8, r0
 801770c:	d1c4      	bne.n	8017698 <cblas_csyrk+0x514>
      for (i = 0; i < N; i++) {
 801770e:	9b05      	ldr	r3, [sp, #20]
 8017710:	449a      	add	sl, r3
 8017712:	9b03      	ldr	r3, [sp, #12]
 8017714:	4498      	add	r8, r3
 8017716:	9b04      	ldr	r3, [sp, #16]
 8017718:	f10e 0e01 	add.w	lr, lr, #1
 801771c:	4573      	cmp	r3, lr
 801771e:	44d9      	add	r9, fp
 8017720:	4459      	add	r1, fp
 8017722:	d1b1      	bne.n	8017688 <cblas_csyrk+0x504>
 8017724:	e62b      	b.n	801737e <cblas_csyrk+0x1fa>
        for (i = 0; i < N; i++) {
 8017726:	2e00      	cmp	r6, #0
 8017728:	f77f ae64 	ble.w	80173f4 <cblas_csyrk+0x270>
 801772c:	f10b 0e01 	add.w	lr, fp, #1
 8017730:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017734:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 8017738:	2000      	movs	r0, #0
 801773a:	4663      	mov	r3, ip
 801773c:	4602      	mov	r2, r0
            const BASE Cij_real = REAL(C, ldc * i + j);
 801773e:	edd3 5a00 	vldr	s11, [r3]
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8017742:	ed93 5a01 	vldr	s10, [r3, #4]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8017746:	ee26 7a25 	vmul.f32	s14, s12, s11
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801774a:	ee65 7a46 	vnmul.f32	s15, s10, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801774e:	eea6 7a85 	vfma.f32	s14, s13, s10
          for (j = i; j < N; j++) {
 8017752:	3201      	adds	r2, #1
 8017754:	4296      	cmp	r6, r2
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8017756:	eee6 7aa5 	vfma.f32	s15, s13, s11
 801775a:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801775e:	ed03 7a01 	vstr	s14, [r3, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8017762:	ed43 7a02 	vstr	s15, [r3, #-8]
          for (j = i; j < N; j++) {
 8017766:	dcea      	bgt.n	801773e <cblas_csyrk+0x5ba>
        for (i = 0; i < N; i++) {
 8017768:	3001      	adds	r0, #1
 801776a:	4286      	cmp	r6, r0
 801776c:	44f4      	add	ip, lr
 801776e:	d1e4      	bne.n	801773a <cblas_csyrk+0x5b6>
 8017770:	e640      	b.n	80173f4 <cblas_csyrk+0x270>
 8017772:	462a      	mov	r2, r5
 8017774:	e53e      	b.n	80171f4 <cblas_csyrk+0x70>
 8017776:	bf00      	nop

08017778 <cblas_ctrmm>:
cblas_ctrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8017778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801777c:	ed2d 8b02 	vpush	{d8}
{
  INDEX i, j, k;
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8017780:	2b71      	cmp	r3, #113	; 0x71
 8017782:	b089      	sub	sp, #36	; 0x24
 8017784:	4698      	mov	r8, r3
 8017786:	bf0c      	ite	eq
 8017788:	f04f 33ff 	moveq.w	r3, #4294967295
 801778c:	2301      	movne	r3, #1
 801778e:	ee08 3a10 	vmov	s16, r3
 8017792:	e9dd a317 	ldrd	sl, r3, [sp, #92]	; 0x5c
 8017796:	9302      	str	r3, [sp, #8]
 8017798:	e9dd 6319 	ldrd	r6, r3, [sp, #100]	; 0x64
  int side, uplo, trans;

  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801779c:	298d      	cmp	r1, #141	; 0x8d
 801779e:	9303      	str	r3, [sp, #12]
 80177a0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80177a2:	f89d 5050 	ldrb.w	r5, [sp, #80]	; 0x50
 80177a6:	9301      	str	r3, [sp, #4]
 80177a8:	e9dd b415 	ldrd	fp, r4, [sp, #84]	; 0x54
 80177ac:	460f      	mov	r7, r1
 80177ae:	4691      	mov	r9, r2
 80177b0:	d06c      	beq.n	801788c <cblas_ctrmm+0x114>
 80177b2:	298e      	cmp	r1, #142	; 0x8e
 80177b4:	f000 82c4 	beq.w	8017d40 <cblas_ctrmm+0x5c8>
 80177b8:	46a4      	mov	ip, r4
 80177ba:	2302      	movs	r3, #2
 80177bc:	f1a9 0279 	sub.w	r2, r9, #121	; 0x79
 80177c0:	2a01      	cmp	r2, #1
 80177c2:	f1a8 016f 	sub.w	r1, r8, #111	; 0x6f
 80177c6:	f105 027d 	add.w	r2, r5, #125	; 0x7d
 80177ca:	bf88      	it	hi
 80177cc:	2303      	movhi	r3, #3
 80177ce:	b2d2      	uxtb	r2, r2
 80177d0:	2902      	cmp	r1, #2
 80177d2:	bf88      	it	hi
 80177d4:	2304      	movhi	r3, #4
 80177d6:	2a02      	cmp	r2, #2
 80177d8:	bf28      	it	cs
 80177da:	2305      	movcs	r3, #5
 80177dc:	f1bb 0f00 	cmp.w	fp, #0
 80177e0:	bfb8      	it	lt
 80177e2:	2306      	movlt	r3, #6
 80177e4:	2c00      	cmp	r4, #0
 80177e6:	bfb8      	it	lt
 80177e8:	2307      	movlt	r3, #7
 80177ea:	f1bc 0f01 	cmp.w	ip, #1
 80177ee:	bfb8      	it	lt
 80177f0:	f04f 0c01 	movlt.w	ip, #1
 80177f4:	45b4      	cmp	ip, r6
 80177f6:	dd3c      	ble.n	8017872 <cblas_ctrmm+0xfa>
 80177f8:	2865      	cmp	r0, #101	; 0x65
 80177fa:	f000 80d3 	beq.w	80179a4 <cblas_ctrmm+0x22c>
 80177fe:	465b      	mov	r3, fp
 8017800:	2b01      	cmp	r3, #1
 8017802:	9a01      	ldr	r2, [sp, #4]
 8017804:	bfb8      	it	lt
 8017806:	2301      	movlt	r3, #1
 8017808:	4293      	cmp	r3, r2
 801780a:	bfcc      	ite	gt
 801780c:	230c      	movgt	r3, #12
 801780e:	230a      	movle	r3, #10
 8017810:	4abe      	ldr	r2, [pc, #760]	; (8017b0c <cblas_ctrmm+0x394>)
 8017812:	49bf      	ldr	r1, [pc, #764]	; (8017b10 <cblas_ctrmm+0x398>)
 8017814:	4618      	mov	r0, r3
 8017816:	f010 ff77 	bl	8028708 <cblas_xerbla>
      uplo = Uplo;
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
    } else {
      n1 = N;
      n2 = M;
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 801781a:	2f8d      	cmp	r7, #141	; 0x8d
 801781c:	bf0c      	ite	eq
 801781e:	278e      	moveq	r7, #142	; 0x8e
 8017820:	278d      	movne	r7, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8017822:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8017826:	bf0c      	ite	eq
 8017828:	f04f 097a 	moveq.w	r9, #122	; 0x7a
 801782c:	f04f 0979 	movne.w	r9, #121	; 0x79
    const BASE alpha_real = CONST_REAL0(alpha);
 8017830:	edda 6a00 	vldr	s13, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8017834:	ed9a 7a01 	vldr	s14, [sl, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 8017838:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 801783c:	bf0c      	ite	eq
 801783e:	f04f 086f 	moveq.w	r8, #111	; 0x6f
 8017842:	f04f 0870 	movne.w	r8, #112	; 0x70
    }

    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8017846:	2f8d      	cmp	r7, #141	; 0x8d
 8017848:	d028      	beq.n	801789c <cblas_ctrmm+0x124>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 801784a:	2f8e      	cmp	r7, #142	; 0x8e
 801784c:	d107      	bne.n	801785e <cblas_ctrmm+0xe6>
 801784e:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8017852:	f000 80c7 	beq.w	80179e4 <cblas_ctrmm+0x26c>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8017856:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 801785a:	f000 815f 	beq.w	8017b1c <cblas_ctrmm+0x3a4>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 801785e:	4aad      	ldr	r2, [pc, #692]	; (8017b14 <cblas_ctrmm+0x39c>)
 8017860:	49ab      	ldr	r1, [pc, #684]	; (8017b10 <cblas_ctrmm+0x398>)
 8017862:	2000      	movs	r0, #0
#define BASE float
#include "source_trmm_c.h"
#undef BASE
}
 8017864:	b009      	add	sp, #36	; 0x24
 8017866:	ecbd 8b02 	vpop	{d8}
 801786a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801786e:	f010 bf4b 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017872:	2865      	cmp	r0, #101	; 0x65
 8017874:	f000 81da 	beq.w	8017c2c <cblas_ctrmm+0x4b4>
 8017878:	465a      	mov	r2, fp
 801787a:	2a01      	cmp	r2, #1
 801787c:	9901      	ldr	r1, [sp, #4]
 801787e:	bfb8      	it	lt
 8017880:	2201      	movlt	r2, #1
 8017882:	428a      	cmp	r2, r1
 8017884:	f340 80aa 	ble.w	80179dc <cblas_ctrmm+0x264>
 8017888:	230c      	movs	r3, #12
 801788a:	e7c1      	b.n	8017810 <cblas_ctrmm+0x98>
 801788c:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8017890:	2b01      	cmp	r3, #1
 8017892:	bf94      	ite	ls
 8017894:	2300      	movls	r3, #0
 8017896:	2301      	movhi	r3, #1
 8017898:	46dc      	mov	ip, fp
 801789a:	e78f      	b.n	80177bc <cblas_ctrmm+0x44>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 801789c:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 80178a0:	f000 81cd 	beq.w	8017c3e <cblas_ctrmm+0x4c6>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 80178a4:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 80178a8:	d1d9      	bne.n	801785e <cblas_ctrmm+0xe6>
 80178aa:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80178ae:	f000 8325 	beq.w	8017efc <cblas_ctrmm+0x784>
      for (i = 0; i < n1; i++) {
 80178b2:	2c00      	cmp	r4, #0
 80178b4:	dd71      	ble.n	801799a <cblas_ctrmm+0x222>
 80178b6:	3601      	adds	r6, #1
 80178b8:	00f2      	lsls	r2, r6, #3
 80178ba:	9902      	ldr	r1, [sp, #8]
 80178bc:	9207      	str	r2, [sp, #28]
 80178be:	1f13      	subs	r3, r2, #4
 80178c0:	18cf      	adds	r7, r1, r3
 80178c2:	9b01      	ldr	r3, [sp, #4]
 80178c4:	9305      	str	r3, [sp, #20]
 80178c6:	00d8      	lsls	r0, r3, #3
 80178c8:	2300      	movs	r3, #0
 80178ca:	468a      	mov	sl, r1
 80178cc:	f1a2 0608 	sub.w	r6, r2, #8
 80178d0:	9304      	str	r3, [sp, #16]
 80178d2:	f04f 0801 	mov.w	r8, #1
 80178d6:	46b9      	mov	r9, r7
        for (j = 0; j < n2; j++) {
 80178d8:	f1bb 0f00 	cmp.w	fp, #0
 80178dc:	bfd8      	it	le
 80178de:	f8cd 8018 	strle.w	r8, [sp, #24]
 80178e2:	dd4a      	ble.n	801797a <cblas_ctrmm+0x202>
 80178e4:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80178e8:	1a9b      	subs	r3, r3, r2
 80178ea:	00db      	lsls	r3, r3, #3
 80178ec:	3304      	adds	r3, #4
 80178ee:	9302      	str	r3, [sp, #8]
 80178f0:	9b03      	ldr	r3, [sp, #12]
 80178f2:	f8cd 8018 	str.w	r8, [sp, #24]
 80178f6:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 80178fa:	f04f 0e00 	mov.w	lr, #0
          if (nonunit) {
 80178fe:	2d83      	cmp	r5, #131	; 0x83
 8017900:	f000 825c 	beq.w	8017dbc <cblas_ctrmm+0x644>
            temp_real = REAL(B, i * ldb + j);
 8017904:	46bc      	mov	ip, r7
 8017906:	ecfc 3a01 	vldmia	ip!, {s7}
            temp_imag = IMAG(B, i * ldb + j);
 801790a:	ed97 4a01 	vldr	s8, [r7, #4]
          for (k = i + 1; k < n1; k++) {
 801790e:	4544      	cmp	r4, r8
 8017910:	dd20      	ble.n	8017954 <cblas_ctrmm+0x1dc>
 8017912:	9b02      	ldr	r3, [sp, #8]
 8017914:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 8017918:	19da      	adds	r2, r3, r7
 801791a:	4641      	mov	r1, r8
 801791c:	464b      	mov	r3, r9
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 801791e:	edd3 7a00 	vldr	s15, [r3]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8017922:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8017926:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 801792a:	ed13 5a01 	vldr	s10, [r3, #-4]
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 801792e:	ee63 7a27 	vmul.f32	s15, s6, s15
          for (k = i + 1; k < n1; k++) {
 8017932:	3101      	adds	r1, #1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017934:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017938:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 801793c:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = i + 1; k < n1; k++) {
 8017940:	428c      	cmp	r4, r1
 8017942:	4402      	add	r2, r0
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017944:	eee5 7a25 	vfma.f32	s15, s10, s11
 8017948:	4433      	add	r3, r6
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 801794a:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 801794e:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = i + 1; k < n1; k++) {
 8017952:	d1e4      	bne.n	801791e <cblas_ctrmm+0x1a6>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017954:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017958:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801795c:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8017960:	f10e 0e01 	add.w	lr, lr, #1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017964:	463b      	mov	r3, r7
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017966:	eee4 7a26 	vfma.f32	s15, s8, s13
        for (j = 0; j < n2; j++) {
 801796a:	45f3      	cmp	fp, lr
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801796c:	f107 0708 	add.w	r7, r7, #8
 8017970:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017974:	edcc 7a00 	vstr	s15, [ip]
        for (j = 0; j < n2; j++) {
 8017978:	d1c1      	bne.n	80178fe <cblas_ctrmm+0x186>
      for (i = 0; i < n1; i++) {
 801797a:	9b07      	ldr	r3, [sp, #28]
 801797c:	9905      	ldr	r1, [sp, #20]
 801797e:	9a01      	ldr	r2, [sp, #4]
 8017980:	460f      	mov	r7, r1
 8017982:	4499      	add	r9, r3
 8017984:	9904      	ldr	r1, [sp, #16]
 8017986:	449a      	add	sl, r3
 8017988:	9b06      	ldr	r3, [sp, #24]
 801798a:	4417      	add	r7, r2
 801798c:	4411      	add	r1, r2
 801798e:	429c      	cmp	r4, r3
 8017990:	f108 0801 	add.w	r8, r8, #1
 8017994:	9705      	str	r7, [sp, #20]
 8017996:	9104      	str	r1, [sp, #16]
 8017998:	dc9e      	bgt.n	80178d8 <cblas_ctrmm+0x160>
 801799a:	b009      	add	sp, #36	; 0x24
 801799c:	ecbd 8b02 	vpop	{d8}
 80179a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80179a4:	2c01      	cmp	r4, #1
 80179a6:	9a01      	ldr	r2, [sp, #4]
 80179a8:	4623      	mov	r3, r4
 80179aa:	bfb8      	it	lt
 80179ac:	2301      	movlt	r3, #1
 80179ae:	4293      	cmp	r3, r2
 80179b0:	bfcc      	ite	gt
 80179b2:	230c      	movgt	r3, #12
 80179b4:	230a      	movle	r3, #10
 80179b6:	4a55      	ldr	r2, [pc, #340]	; (8017b0c <cblas_ctrmm+0x394>)
 80179b8:	4955      	ldr	r1, [pc, #340]	; (8017b10 <cblas_ctrmm+0x398>)
 80179ba:	4618      	mov	r0, r3
 80179bc:	f010 fea4 	bl	8028708 <cblas_xerbla>
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80179c0:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
    const BASE alpha_real = CONST_REAL0(alpha);
 80179c4:	edda 6a00 	vldr	s13, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80179c8:	ed9a 7a01 	vldr	s14, [sl, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80179cc:	4623      	mov	r3, r4
 80179ce:	f000 81b0 	beq.w	8017d32 <cblas_ctrmm+0x5ba>
 80179d2:	465c      	mov	r4, fp
 80179d4:	f04f 0870 	mov.w	r8, #112	; 0x70
 80179d8:	469b      	mov	fp, r3
 80179da:	e734      	b.n	8017846 <cblas_ctrmm+0xce>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80179dc:	2b00      	cmp	r3, #0
 80179de:	f43f af1c 	beq.w	801781a <cblas_ctrmm+0xa2>
 80179e2:	e715      	b.n	8017810 <cblas_ctrmm+0x98>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 80179e4:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80179e8:	f000 8324 	beq.w	8018034 <cblas_ctrmm+0x8bc>
      for (i = 0; i < n1; i++) {
 80179ec:	2c00      	cmp	r4, #0
 80179ee:	ddd4      	ble.n	801799a <cblas_ctrmm+0x222>
 80179f0:	9b02      	ldr	r3, [sp, #8]
 80179f2:	9406      	str	r4, [sp, #24]
 80179f4:	3b08      	subs	r3, #8
 80179f6:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 80179fa:	9307      	str	r3, [sp, #28]
 80179fc:	9b01      	ldr	r3, [sp, #4]
 80179fe:	00db      	lsls	r3, r3, #3
 8017a00:	9305      	str	r3, [sp, #20]
 8017a02:	9b03      	ldr	r3, [sp, #12]
 8017a04:	f106 0801 	add.w	r8, r6, #1
 8017a08:	2200      	movs	r2, #0
 8017a0a:	00f6      	lsls	r6, r6, #3
 8017a0c:	9204      	str	r2, [sp, #16]
 8017a0e:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8017a12:	f106 0908 	add.w	r9, r6, #8
 8017a16:	eb03 0acb 	add.w	sl, r3, fp, lsl #3
 8017a1a:	4696      	mov	lr, r2
        for (j = 0; j < n2; j++) {
 8017a1c:	f1bb 0f00 	cmp.w	fp, #0
 8017a20:	dd67      	ble.n	8017af2 <cblas_ctrmm+0x37a>
 8017a22:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8017a26:	9f02      	ldr	r7, [sp, #8]
 8017a28:	9907      	ldr	r1, [sp, #28]
          if (nonunit) {
 8017a2a:	2d83      	cmp	r5, #131	; 0x83
 8017a2c:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 8017a30:	f107 0c04 	add.w	ip, r7, #4
        for (j = 0; j < n2; j++) {
 8017a34:	f04f 0400 	mov.w	r4, #0
          if (nonunit) {
 8017a38:	d038      	beq.n	8017aac <cblas_ctrmm+0x334>
          for (k = j + 1; k < n2; k++) {
 8017a3a:	3401      	adds	r4, #1
 8017a3c:	45a3      	cmp	fp, r4
            temp_real = REAL(B, i * ldb + j);
 8017a3e:	edd0 3a00 	vldr	s7, [r0]
            temp_imag = IMAG(B, i * ldb + j);
 8017a42:	ed90 4a01 	vldr	s8, [r0, #4]
          for (k = j + 1; k < n2; k++) {
 8017a46:	d048      	beq.n	8017ada <cblas_ctrmm+0x362>
 8017a48:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 8017a4c:	4602      	mov	r2, r0
 8017a4e:	463b      	mov	r3, r7
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8017a50:	edd3 7a03 	vldr	s15, [r3, #12]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8017a54:	edd2 5a03 	vldr	s11, [r2, #12]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8017a58:	edd2 4a02 	vldr	s9, [r2, #8]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8017a5c:	ed93 5a02 	vldr	s10, [r3, #8]
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8017a60:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8017a64:	3308      	adds	r3, #8
 8017a66:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8017a6a:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8017a6e:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = j + 1; k < n2; k++) {
 8017a72:	4299      	cmp	r1, r3
 8017a74:	f102 0208 	add.w	r2, r2, #8
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8017a78:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8017a7c:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8017a80:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = j + 1; k < n2; k++) {
 8017a84:	d1e4      	bne.n	8017a50 <cblas_ctrmm+0x2d8>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017a86:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017a8a:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017a8e:	eea3 6aa6 	vfma.f32	s12, s7, s13
          if (nonunit) {
 8017a92:	2d83      	cmp	r5, #131	; 0x83
 8017a94:	4447      	add	r7, r8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017a96:	eee4 7a26 	vfma.f32	s15, s8, s13
 8017a9a:	4431      	add	r1, r6
 8017a9c:	44cc      	add	ip, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017a9e:	ed80 6a00 	vstr	s12, [r0]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017aa2:	edc0 7a01 	vstr	s15, [r0, #4]
        for (j = 0; j < n2; j++) {
 8017aa6:	f100 0008 	add.w	r0, r0, #8
          if (nonunit) {
 8017aaa:	d1c6      	bne.n	8017a3a <cblas_ctrmm+0x2c2>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017aac:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8017ab0:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017ab4:	edd0 7a01 	vldr	s15, [r0, #4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017ab8:	edd0 5a00 	vldr	s11, [r0]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8017abc:	ed1c 6a01 	vldr	s12, [ip, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017ac0:	ee24 4a05 	vmul.f32	s8, s8, s10
          for (k = j + 1; k < n2; k++) {
 8017ac4:	3401      	adds	r4, #1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017ac6:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017aca:	ee24 4a25 	vmul.f32	s8, s8, s11
          for (k = j + 1; k < n2; k++) {
 8017ace:	45a3      	cmp	fp, r4
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017ad0:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017ad4:	eea6 4a27 	vfma.f32	s8, s12, s15
          for (k = j + 1; k < n2; k++) {
 8017ad8:	d1b6      	bne.n	8017a48 <cblas_ctrmm+0x2d0>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017ada:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017ade:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017ae2:	eea3 6aa6 	vfma.f32	s12, s7, s13
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017ae6:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017aea:	ed0a 6a02 	vstr	s12, [sl, #-8]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017aee:	ed4a 7a01 	vstr	s15, [sl, #-4]
      for (i = 0; i < n1; i++) {
 8017af2:	9b05      	ldr	r3, [sp, #20]
 8017af4:	9a01      	ldr	r2, [sp, #4]
 8017af6:	449a      	add	sl, r3
 8017af8:	9b04      	ldr	r3, [sp, #16]
 8017afa:	4413      	add	r3, r2
 8017afc:	9304      	str	r3, [sp, #16]
 8017afe:	9b06      	ldr	r3, [sp, #24]
 8017b00:	f10e 0e01 	add.w	lr, lr, #1
 8017b04:	4573      	cmp	r3, lr
 8017b06:	d189      	bne.n	8017a1c <cblas_ctrmm+0x2a4>
 8017b08:	e747      	b.n	801799a <cblas_ctrmm+0x222>
 8017b0a:	bf00      	nop
 8017b0c:	08031108 	.word	0x08031108
 8017b10:	08031394 	.word	0x08031394
 8017b14:	080311b8 	.word	0x080311b8
 8017b18:	00000000 	.word	0x00000000
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8017b1c:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8017b20:	f000 8312 	beq.w	8018148 <cblas_ctrmm+0x9d0>
      for (i = 0; i < n1; i++) {
 8017b24:	2c00      	cmp	r4, #0
 8017b26:	f77f af38 	ble.w	801799a <cblas_ctrmm+0x222>
 8017b2a:	9b02      	ldr	r3, [sp, #8]
 8017b2c:	f10b 32ff 	add.w	r2, fp, #4294967295
 8017b30:	fb02 b706 	mla	r7, r2, r6, fp
 8017b34:	1c71      	adds	r1, r6, #1
 8017b36:	f1a3 0008 	sub.w	r0, r3, #8
 8017b3a:	ebc6 7946 	rsb	r9, r6, r6, lsl #29
 8017b3e:	43f3      	mvns	r3, r6
 8017b40:	9e01      	ldr	r6, [sp, #4]
 8017b42:	00f6      	lsls	r6, r6, #3
 8017b44:	9601      	str	r6, [sp, #4]
 8017b46:	e9dd 6802 	ldrd	r6, r8, [sp, #8]
 8017b4a:	00c9      	lsls	r1, r1, #3
 8017b4c:	f1a1 0c08 	sub.w	ip, r1, #8
 8017b50:	fb02 6c0c 	mla	ip, r2, ip, r6
 8017b54:	9e02      	ldr	r6, [sp, #8]
 8017b56:	f8cd c014 	str.w	ip, [sp, #20]
 8017b5a:	fb02 6201 	mla	r2, r2, r1, r6
 8017b5e:	9203      	str	r2, [sp, #12]
 8017b60:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
 8017b64:	eb00 02c7 	add.w	r2, r0, r7, lsl #3
 8017b68:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8017b6c:	9204      	str	r2, [sp, #16]
 8017b6e:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8017b72:	9302      	str	r3, [sp, #8]
 8017b74:	f04f 0a00 	mov.w	sl, #0
        for (j = n2; j > 0 && j--;) {
 8017b78:	f1bb 0f00 	cmp.w	fp, #0
 8017b7c:	dd4f      	ble.n	8017c1e <cblas_ctrmm+0x4a6>
 8017b7e:	9b02      	ldr	r3, [sp, #8]
 8017b80:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8017b84:	e9dd 1704 	ldrd	r1, r7, [sp, #16]
 8017b88:	eb08 0003 	add.w	r0, r8, r3
 8017b8c:	465e      	mov	r6, fp
          BASE temp_imag = 0.0;
 8017b8e:	ed1f 4a1e 	vldr	s8, [pc, #-120]	; 8017b18 <cblas_ctrmm+0x3a0>
          for (k = 0; k < j; k++) {
 8017b92:	3e01      	subs	r6, #1
          BASE temp_real = 0.0;
 8017b94:	bf08      	it	eq
 8017b96:	eef0 3a44 	vmoveq.f32	s7, s8
          for (k = 0; k < j; k++) {
 8017b9a:	d020      	beq.n	8017bde <cblas_ctrmm+0x466>
 8017b9c:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 8017ba0:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < j; k++) {
 8017ba4:	4642      	mov	r2, r8
 8017ba6:	463b      	mov	r3, r7
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8017ba8:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8017bac:	edd2 5a01 	vldr	s11, [r2, #4]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8017bb0:	edd2 4a00 	vldr	s9, [r2]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8017bb4:	ed93 5a00 	vldr	s10, [r3]
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8017bb8:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8017bbc:	3308      	adds	r3, #8
 8017bbe:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8017bc2:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8017bc6:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < j; k++) {
 8017bca:	4299      	cmp	r1, r3
 8017bcc:	f102 0208 	add.w	r2, r2, #8
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8017bd0:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8017bd4:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8017bd8:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < j; k++) {
 8017bdc:	d1e4      	bne.n	8017ba8 <cblas_ctrmm+0x430>
          if (nonunit) {
 8017bde:	2d83      	cmp	r5, #131	; 0x83
 8017be0:	f000 80b6 	beq.w	8017d50 <cblas_ctrmm+0x5d8>
            temp_real += REAL(B, i * ldb + j);
 8017be4:	ed10 6a02 	vldr	s12, [r0, #-8]
            temp_imag += IMAG(B, i * ldb + j);
 8017be8:	ed50 7a01 	vldr	s15, [r0, #-4]
            temp_real += REAL(B, i * ldb + j);
 8017bec:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 8017bf0:	ee34 4a27 	vadd.f32	s8, s8, s15
 8017bf4:	f1a0 0308 	sub.w	r3, r0, #8
 8017bf8:	1f02      	subs	r2, r0, #4
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017bfa:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017bfe:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017c02:	eea3 6aa6 	vfma.f32	s12, s7, s13
 8017c06:	44f4      	add	ip, lr
 8017c08:	444f      	add	r7, r9
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017c0a:	eee4 7a26 	vfma.f32	s15, s8, s13
 8017c0e:	4471      	add	r1, lr
 8017c10:	4618      	mov	r0, r3
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017c12:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017c16:	edc2 7a00 	vstr	s15, [r2]
        for (j = n2; j > 0 && j--;) {
 8017c1a:	2e00      	cmp	r6, #0
 8017c1c:	d1b7      	bne.n	8017b8e <cblas_ctrmm+0x416>
      for (i = 0; i < n1; i++) {
 8017c1e:	9b01      	ldr	r3, [sp, #4]
 8017c20:	f10a 0a01 	add.w	sl, sl, #1
 8017c24:	4554      	cmp	r4, sl
 8017c26:	4498      	add	r8, r3
 8017c28:	d1a6      	bne.n	8017b78 <cblas_ctrmm+0x400>
 8017c2a:	e6b6      	b.n	801799a <cblas_ctrmm+0x222>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017c2c:	2c01      	cmp	r4, #1
 8017c2e:	9901      	ldr	r1, [sp, #4]
 8017c30:	4622      	mov	r2, r4
 8017c32:	bfb8      	it	lt
 8017c34:	2201      	movlt	r2, #1
 8017c36:	428a      	cmp	r2, r1
 8017c38:	dd7e      	ble.n	8017d38 <cblas_ctrmm+0x5c0>
 8017c3a:	230c      	movs	r3, #12
 8017c3c:	e6bb      	b.n	80179b6 <cblas_ctrmm+0x23e>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8017c3e:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8017c42:	f000 80d1 	beq.w	8017de8 <cblas_ctrmm+0x670>
      for (i = n1; i > 0 && i--;) {
 8017c46:	2c00      	cmp	r4, #0
 8017c48:	f77f aea7 	ble.w	801799a <cblas_ctrmm+0x222>
 8017c4c:	9b01      	ldr	r3, [sp, #4]
 8017c4e:	9a03      	ldr	r2, [sp, #12]
 8017c50:	1e60      	subs	r0, r4, #1
 8017c52:	00df      	lsls	r7, r3, #3
 8017c54:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
 8017c58:	fb00 2807 	mla	r8, r0, r7, r2
 8017c5c:	00db      	lsls	r3, r3, #3
 8017c5e:	9a02      	ldr	r2, [sp, #8]
 8017c60:	9303      	str	r3, [sp, #12]
 8017c62:	f106 0c01 	add.w	ip, r6, #1
 8017c66:	43f6      	mvns	r6, r6
 8017c68:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8017c6c:	f108 0904 	add.w	r9, r8, #4
 8017c70:	fb00 f803 	mul.w	r8, r0, r3
 8017c74:	00f3      	lsls	r3, r6, #3
 8017c76:	fb00 2a0c 	mla	sl, r0, ip, r2
 8017c7a:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
 8017c7e:	f1ac 0c08 	sub.w	ip, ip, #8
 8017c82:	9301      	str	r3, [sp, #4]
        for (j = 0; j < n2; j++) {
 8017c84:	f1bb 0f00 	cmp.w	fp, #0
 8017c88:	dd48      	ble.n	8017d1c <cblas_ctrmm+0x5a4>
 8017c8a:	464e      	mov	r6, r9
 8017c8c:	f04f 0e00 	mov.w	lr, #0
          BASE temp_imag = 0.0;
 8017c90:	ed1f 4a5f 	vldr	s8, [pc, #-380]	; 8017b18 <cblas_ctrmm+0x3a0>
          BASE temp_real = 0.0;
 8017c94:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < i; k++) {
 8017c98:	b310      	cbz	r0, 8017ce0 <cblas_ctrmm+0x568>
 8017c9a:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 8017c9e:	eef0 3a44 	vmov.f32	s7, s8
 8017ca2:	eb08 0206 	add.w	r2, r8, r6
          for (k = 0; k < i; k++) {
 8017ca6:	4623      	mov	r3, r4
 8017ca8:	2100      	movs	r1, #0
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8017caa:	ed53 7a01 	vldr	s15, [r3, #-4]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8017cae:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8017cb2:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8017cb6:	ed13 5a02 	vldr	s10, [r3, #-8]
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8017cba:	ee63 7a27 	vmul.f32	s15, s6, s15
          for (k = 0; k < i; k++) {
 8017cbe:	3101      	adds	r1, #1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017cc0:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017cc4:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017cc8:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < i; k++) {
 8017ccc:	4288      	cmp	r0, r1
 8017cce:	443a      	add	r2, r7
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017cd0:	eee5 7a25 	vfma.f32	s15, s10, s11
 8017cd4:	4463      	add	r3, ip
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017cd6:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017cda:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < i; k++) {
 8017cde:	d1e4      	bne.n	8017caa <cblas_ctrmm+0x532>
          if (nonunit) {
 8017ce0:	2d83      	cmp	r5, #131	; 0x83
 8017ce2:	d051      	beq.n	8017d88 <cblas_ctrmm+0x610>
            temp_real += REAL(B, i * ldb + j);
 8017ce4:	ed16 6a01 	vldr	s12, [r6, #-4]
            temp_imag += IMAG(B, i * ldb + j);
 8017ce8:	edd6 7a00 	vldr	s15, [r6]
            temp_real += REAL(B, i * ldb + j);
 8017cec:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 8017cf0:	ee34 4a27 	vadd.f32	s8, s8, s15
 8017cf4:	1f33      	subs	r3, r6, #4
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017cf6:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017cfa:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017cfe:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8017d02:	f10e 0e01 	add.w	lr, lr, #1
 8017d06:	45f3      	cmp	fp, lr
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017d08:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017d0c:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017d10:	4633      	mov	r3, r6
 8017d12:	edc3 7a00 	vstr	s15, [r3]
 8017d16:	f106 0608 	add.w	r6, r6, #8
        for (j = 0; j < n2; j++) {
 8017d1a:	d1b9      	bne.n	8017c90 <cblas_ctrmm+0x518>
      for (i = n1; i > 0 && i--;) {
 8017d1c:	9b01      	ldr	r3, [sp, #4]
 8017d1e:	449a      	add	sl, r3
 8017d20:	9b03      	ldr	r3, [sp, #12]
 8017d22:	3c08      	subs	r4, #8
 8017d24:	4499      	add	r9, r3
 8017d26:	44b8      	add	r8, r7
 8017d28:	2800      	cmp	r0, #0
 8017d2a:	f43f ae36 	beq.w	801799a <cblas_ctrmm+0x222>
 8017d2e:	3801      	subs	r0, #1
 8017d30:	e7a8      	b.n	8017c84 <cblas_ctrmm+0x50c>
 8017d32:	465c      	mov	r4, fp
 8017d34:	469b      	mov	fp, r3
 8017d36:	e586      	b.n	8017846 <cblas_ctrmm+0xce>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017d38:	2b00      	cmp	r3, #0
 8017d3a:	f43f ae41 	beq.w	80179c0 <cblas_ctrmm+0x248>
 8017d3e:	e63a      	b.n	80179b6 <cblas_ctrmm+0x23e>
 8017d40:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8017d44:	2b01      	cmp	r3, #1
 8017d46:	bf94      	ite	ls
 8017d48:	2300      	movls	r3, #0
 8017d4a:	2301      	movhi	r3, #1
 8017d4c:	46a4      	mov	ip, r4
 8017d4e:	e535      	b.n	80177bc <cblas_ctrmm+0x44>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017d50:	ed9c 6a01 	vldr	s12, [ip, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017d54:	ed50 5a01 	vldr	s11, [r0, #-4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017d58:	ed50 4a02 	vldr	s9, [r0, #-8]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8017d5c:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017d60:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8017d64:	f1a0 0308 	sub.w	r3, r0, #8
 8017d68:	ee67 7a86 	vmul.f32	s15, s15, s12
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017d6c:	1f02      	subs	r2, r0, #4
 8017d6e:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017d72:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017d76:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017d7a:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017d7e:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017d82:	ee37 4a84 	vadd.f32	s8, s15, s8
 8017d86:	e738      	b.n	8017bfa <cblas_ctrmm+0x482>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017d88:	ed9a 6a01 	vldr	s12, [sl, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017d8c:	edd6 5a00 	vldr	s11, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017d90:	ed56 4a01 	vldr	s9, [r6, #-4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8017d94:	ed9a 5a00 	vldr	s10, [sl]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017d98:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8017d9c:	1f33      	subs	r3, r6, #4
 8017d9e:	ee67 7a86 	vmul.f32	s15, s15, s12
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017da2:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017da6:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017daa:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017dae:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017db2:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017db6:	ee37 4a84 	vadd.f32	s8, s15, s8
 8017dba:	e79c      	b.n	8017cf6 <cblas_ctrmm+0x57e>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017dbc:	edda 5a01 	vldr	s11, [sl, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017dc0:	edd7 7a01 	vldr	s15, [r7, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8017dc4:	ed9a 6a00 	vldr	s12, [sl]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017dc8:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017dcc:	46bc      	mov	ip, r7
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017dce:	ee24 4a25 	vmul.f32	s8, s8, s11
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017dd2:	ecfc 5a01 	vldmia	ip!, {s11}
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017dd6:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017dda:	ee24 4a25 	vmul.f32	s8, s8, s11
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017dde:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017de2:	eea6 4a27 	vfma.f32	s8, s12, s15
 8017de6:	e592      	b.n	801790e <cblas_ctrmm+0x196>
      for (i = 0; i < n1; i++) {
 8017de8:	2c00      	cmp	r4, #0
 8017dea:	f77f add6 	ble.w	801799a <cblas_ctrmm+0x222>
 8017dee:	3601      	adds	r6, #1
 8017df0:	00f3      	lsls	r3, r6, #3
 8017df2:	f8dd e008 	ldr.w	lr, [sp, #8]
 8017df6:	9306      	str	r3, [sp, #24]
 8017df8:	3b08      	subs	r3, #8
 8017dfa:	9305      	str	r3, [sp, #20]
 8017dfc:	9b01      	ldr	r3, [sp, #4]
 8017dfe:	9302      	str	r3, [sp, #8]
 8017e00:	f1ae 0108 	sub.w	r1, lr, #8
 8017e04:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 8017e08:	00d8      	lsls	r0, r3, #3
 8017e0a:	f04f 0a00 	mov.w	sl, #0
 8017e0e:	f04f 0901 	mov.w	r9, #1
        for (j = 0; j < n2; j++) {
 8017e12:	f1bb 0f00 	cmp.w	fp, #0
 8017e16:	bfd8      	it	le
 8017e18:	f8cd 9010 	strle.w	r9, [sp, #16]
 8017e1c:	dd48      	ble.n	8017eb0 <cblas_ctrmm+0x738>
 8017e1e:	9b02      	ldr	r3, [sp, #8]
 8017e20:	f8cd 9010 	str.w	r9, [sp, #16]
 8017e24:	eba3 080a 	sub.w	r8, r3, sl
 8017e28:	9b03      	ldr	r3, [sp, #12]
 8017e2a:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8017e2e:	f108 0804 	add.w	r8, r8, #4
 8017e32:	eb03 06ca 	add.w	r6, r3, sl, lsl #3
 8017e36:	f04f 0c00 	mov.w	ip, #0
          if (nonunit) {
 8017e3a:	2d83      	cmp	r5, #131	; 0x83
 8017e3c:	d048      	beq.n	8017ed0 <cblas_ctrmm+0x758>
            temp_real = REAL(B, i * ldb + j);
 8017e3e:	4637      	mov	r7, r6
 8017e40:	ecf7 3a01 	vldmia	r7!, {s7}
            temp_imag = IMAG(B, i * ldb + j);
 8017e44:	ed96 4a01 	vldr	s8, [r6, #4]
          for (k = i + 1; k < n1; k++) {
 8017e48:	454c      	cmp	r4, r9
 8017e4a:	dd1e      	ble.n	8017e8a <cblas_ctrmm+0x712>
 8017e4c:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 8017e50:	eb08 0206 	add.w	r2, r8, r6
 8017e54:	4673      	mov	r3, lr
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017e56:	edd3 7a03 	vldr	s15, [r3, #12]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8017e5a:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8017e5e:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8017e62:	ed93 5a02 	vldr	s10, [r3, #8]
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017e66:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8017e6a:	3308      	adds	r3, #8
 8017e6c:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8017e70:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8017e74:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = i + 1; k < n1; k++) {
 8017e78:	4299      	cmp	r1, r3
 8017e7a:	4402      	add	r2, r0
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8017e7c:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8017e80:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8017e84:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = i + 1; k < n1; k++) {
 8017e88:	d1e5      	bne.n	8017e56 <cblas_ctrmm+0x6de>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017e8a:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017e8e:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017e92:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8017e96:	f10c 0c01 	add.w	ip, ip, #1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017e9a:	4633      	mov	r3, r6
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017e9c:	eee4 7a26 	vfma.f32	s15, s8, s13
        for (j = 0; j < n2; j++) {
 8017ea0:	45e3      	cmp	fp, ip
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017ea2:	f106 0608 	add.w	r6, r6, #8
 8017ea6:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017eaa:	edc7 7a00 	vstr	s15, [r7]
        for (j = 0; j < n2; j++) {
 8017eae:	d1c4      	bne.n	8017e3a <cblas_ctrmm+0x6c2>
      for (i = 0; i < n1; i++) {
 8017eb0:	9b06      	ldr	r3, [sp, #24]
 8017eb2:	9a02      	ldr	r2, [sp, #8]
 8017eb4:	449e      	add	lr, r3
 8017eb6:	9b05      	ldr	r3, [sp, #20]
 8017eb8:	4419      	add	r1, r3
 8017eba:	9b01      	ldr	r3, [sp, #4]
 8017ebc:	4616      	mov	r6, r2
 8017ebe:	441e      	add	r6, r3
 8017ec0:	449a      	add	sl, r3
 8017ec2:	9b04      	ldr	r3, [sp, #16]
 8017ec4:	9602      	str	r6, [sp, #8]
 8017ec6:	429c      	cmp	r4, r3
 8017ec8:	f109 0901 	add.w	r9, r9, #1
 8017ecc:	dca1      	bgt.n	8017e12 <cblas_ctrmm+0x69a>
 8017ece:	e564      	b.n	801799a <cblas_ctrmm+0x222>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017ed0:	edde 5a01 	vldr	s11, [lr, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017ed4:	edd6 7a01 	vldr	s15, [r6, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8017ed8:	ed9e 6a00 	vldr	s12, [lr]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017edc:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017ee0:	4637      	mov	r7, r6
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017ee2:	ee24 4a25 	vmul.f32	s8, s8, s11
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017ee6:	ecf7 5a01 	vldmia	r7!, {s11}
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017eea:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017eee:	ee24 4a25 	vmul.f32	s8, s8, s11
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017ef2:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017ef6:	eea6 4a27 	vfma.f32	s8, s12, s15
 8017efa:	e7a5      	b.n	8017e48 <cblas_ctrmm+0x6d0>
      for (i = n1; i > 0 && i--;) {
 8017efc:	2c00      	cmp	r4, #0
 8017efe:	f77f ad4c 	ble.w	801799a <cblas_ctrmm+0x222>
 8017f02:	9b01      	ldr	r3, [sp, #4]
 8017f04:	00da      	lsls	r2, r3, #3
 8017f06:	9204      	str	r2, [sp, #16]
 8017f08:	ebc3 7e43 	rsb	lr, r3, r3, lsl #29
 8017f0c:	e9dd 7303 	ldrd	r7, r3, [sp, #12]
 8017f10:	1e60      	subs	r0, r4, #1
 8017f12:	9a02      	ldr	r2, [sp, #8]
 8017f14:	f106 0a01 	add.w	sl, r6, #1
 8017f18:	fb00 7803 	mla	r8, r0, r3, r7
 8017f1c:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8017f20:	ea4f 03ce 	mov.w	r3, lr, lsl #3
 8017f24:	fb06 4400 	mla	r4, r6, r0, r4
 8017f28:	ea6f 0906 	mvn.w	r9, r6
 8017f2c:	ebc6 7646 	rsb	r6, r6, r6, lsl #29
 8017f30:	f1aa 0c08 	sub.w	ip, sl, #8
 8017f34:	f1a2 0108 	sub.w	r1, r2, #8
 8017f38:	9301      	str	r3, [sp, #4]
 8017f3a:	fb00 fe03 	mul.w	lr, r0, r3
 8017f3e:	9f04      	ldr	r7, [sp, #16]
 8017f40:	00f3      	lsls	r3, r6, #3
 8017f42:	fb00 2c0c 	mla	ip, r0, ip, r2
 8017f46:	fb00 2a0a 	mla	sl, r0, sl, r2
 8017f4a:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 8017f4e:	f108 0804 	add.w	r8, r8, #4
 8017f52:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8017f56:	9302      	str	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 8017f58:	f1bb 0f00 	cmp.w	fp, #0
 8017f5c:	dd44      	ble.n	8017fe8 <cblas_ctrmm+0x870>
 8017f5e:	4644      	mov	r4, r8
 8017f60:	2600      	movs	r6, #0
          BASE temp_imag = 0.0;
 8017f62:	ed9f 4abf 	vldr	s8, [pc, #764]	; 8018260 <cblas_ctrmm+0xae8>
          BASE temp_real = 0.0;
 8017f66:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < i; k++) {
 8017f6a:	b300      	cbz	r0, 8017fae <cblas_ctrmm+0x836>
 8017f6c:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 8017f70:	eef0 3a44 	vmov.f32	s7, s8
 8017f74:	eb0e 0204 	add.w	r2, lr, r4
          for (k = 0; k < i; k++) {
 8017f78:	4663      	mov	r3, ip
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017f7a:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8017f7e:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8017f82:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8017f86:	ed93 5a00 	vldr	s10, [r3]
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017f8a:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8017f8e:	3308      	adds	r3, #8
 8017f90:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8017f94:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8017f98:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < i; k++) {
 8017f9c:	4299      	cmp	r1, r3
 8017f9e:	443a      	add	r2, r7
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8017fa0:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8017fa4:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8017fa8:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < i; k++) {
 8017fac:	d1e5      	bne.n	8017f7a <cblas_ctrmm+0x802>
          if (nonunit) {
 8017fae:	2d83      	cmp	r5, #131	; 0x83
 8017fb0:	d026      	beq.n	8018000 <cblas_ctrmm+0x888>
            temp_real += REAL(B, i * ldb + j);
 8017fb2:	ed14 6a01 	vldr	s12, [r4, #-4]
            temp_imag += IMAG(B, i * ldb + j);
 8017fb6:	edd4 7a00 	vldr	s15, [r4]
            temp_real += REAL(B, i * ldb + j);
 8017fba:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 8017fbe:	ee34 4a27 	vadd.f32	s8, s8, s15
 8017fc2:	1f23      	subs	r3, r4, #4
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017fc4:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017fc8:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017fcc:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8017fd0:	3601      	adds	r6, #1
 8017fd2:	45b3      	cmp	fp, r6
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017fd4:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017fd8:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017fdc:	4623      	mov	r3, r4
 8017fde:	edc3 7a00 	vstr	s15, [r3]
 8017fe2:	f104 0408 	add.w	r4, r4, #8
        for (j = 0; j < n2; j++) {
 8017fe6:	d1bc      	bne.n	8017f62 <cblas_ctrmm+0x7ea>
      for (i = n1; i > 0 && i--;) {
 8017fe8:	9b01      	ldr	r3, [sp, #4]
 8017fea:	4498      	add	r8, r3
 8017fec:	9b02      	ldr	r3, [sp, #8]
 8017fee:	44ca      	add	sl, r9
 8017ff0:	449c      	add	ip, r3
 8017ff2:	4449      	add	r1, r9
 8017ff4:	44be      	add	lr, r7
 8017ff6:	2800      	cmp	r0, #0
 8017ff8:	f43f accf 	beq.w	801799a <cblas_ctrmm+0x222>
 8017ffc:	3801      	subs	r0, #1
 8017ffe:	e7ab      	b.n	8017f58 <cblas_ctrmm+0x7e0>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8018000:	ed9a 6a01 	vldr	s12, [sl, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8018004:	edd4 5a00 	vldr	s11, [r4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8018008:	ed54 4a01 	vldr	s9, [r4, #-4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 801800c:	ed9a 5a00 	vldr	s10, [sl]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8018010:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8018014:	1f23      	subs	r3, r4, #4
 8018016:	ee67 7a86 	vmul.f32	s15, s15, s12
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 801801a:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 801801e:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8018022:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8018026:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 801802a:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 801802e:	ee37 4a84 	vadd.f32	s8, s15, s8
 8018032:	e7c7      	b.n	8017fc4 <cblas_ctrmm+0x84c>
      for (i = 0; i < n1; i++) {
 8018034:	2c00      	cmp	r4, #0
 8018036:	f77f acb0 	ble.w	801799a <cblas_ctrmm+0x222>
 801803a:	9901      	ldr	r1, [sp, #4]
 801803c:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8018040:	1c70      	adds	r0, r6, #1
 8018042:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 8018046:	9902      	ldr	r1, [sp, #8]
 8018048:	00c0      	lsls	r0, r0, #3
 801804a:	f10b 32ff 	add.w	r2, fp, #4294967295
 801804e:	fb00 1202 	mla	r2, r0, r2, r1
 8018052:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018056:	43f6      	mvns	r6, r6
 8018058:	9202      	str	r2, [sp, #8]
 801805a:	3b08      	subs	r3, #8
 801805c:	eb01 02cb 	add.w	r2, r1, fp, lsl #3
 8018060:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 8018064:	3808      	subs	r0, #8
 8018066:	9201      	str	r2, [sp, #4]
 8018068:	9303      	str	r3, [sp, #12]
 801806a:	f04f 0a00 	mov.w	sl, #0
        for (j = n2; j > 0 && j--;) {
 801806e:	f1bb 0f00 	cmp.w	fp, #0
 8018072:	dd49      	ble.n	8018108 <cblas_ctrmm+0x990>
 8018074:	9b03      	ldr	r3, [sp, #12]
 8018076:	e9dd 7c01 	ldrd	r7, ip, [sp, #4]
 801807a:	eb03 0108 	add.w	r1, r3, r8
 801807e:	465e      	mov	r6, fp
          BASE temp_imag = 0.0;
 8018080:	ed9f 4a77 	vldr	s8, [pc, #476]	; 8018260 <cblas_ctrmm+0xae8>
          for (k = 0; k < j; k++) {
 8018084:	3e01      	subs	r6, #1
          BASE temp_real = 0.0;
 8018086:	bf08      	it	eq
 8018088:	eef0 3a44 	vmoveq.f32	s7, s8
          for (k = 0; k < j; k++) {
 801808c:	d01f      	beq.n	80180ce <cblas_ctrmm+0x956>
 801808e:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 8018092:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < j; k++) {
 8018096:	4643      	mov	r3, r8
 8018098:	463a      	mov	r2, r7
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 801809a:	ed52 7a01 	vldr	s15, [r2, #-4]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 801809e:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bik_real = REAL(B, i * ldb + k);
 80180a2:	edd3 4a00 	vldr	s9, [r3]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80180a6:	ed12 5a02 	vldr	s10, [r2, #-8]
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80180aa:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80180ae:	3308      	adds	r3, #8
 80180b0:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80180b4:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80180b8:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < j; k++) {
 80180bc:	4299      	cmp	r1, r3
 80180be:	4402      	add	r2, r0
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80180c0:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80180c4:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80180c8:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < j; k++) {
 80180cc:	d1e5      	bne.n	801809a <cblas_ctrmm+0x922>
          if (nonunit) {
 80180ce:	2d83      	cmp	r5, #131	; 0x83
 80180d0:	d020      	beq.n	8018114 <cblas_ctrmm+0x99c>
            temp_real += REAL(B, i * ldb + j);
 80180d2:	460b      	mov	r3, r1
 80180d4:	ecb3 6a01 	vldmia	r3!, {s12}
            temp_imag += IMAG(B, i * ldb + j);
 80180d8:	edd1 7a01 	vldr	s15, [r1, #4]
            temp_real += REAL(B, i * ldb + j);
 80180dc:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 80180e0:	ee34 4a27 	vadd.f32	s8, s8, s15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80180e4:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80180e8:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80180ec:	eea3 6aa6 	vfma.f32	s12, s7, s13
 80180f0:	460a      	mov	r2, r1
 80180f2:	44cc      	add	ip, r9
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80180f4:	eee4 7a26 	vfma.f32	s15, s8, s13
 80180f8:	3f08      	subs	r7, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80180fa:	3908      	subs	r1, #8
 80180fc:	ed82 6a00 	vstr	s12, [r2]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8018100:	edc3 7a00 	vstr	s15, [r3]
        for (j = n2; j > 0 && j--;) {
 8018104:	2e00      	cmp	r6, #0
 8018106:	d1bb      	bne.n	8018080 <cblas_ctrmm+0x908>
      for (i = 0; i < n1; i++) {
 8018108:	f10a 0a01 	add.w	sl, sl, #1
 801810c:	4554      	cmp	r4, sl
 801810e:	44f0      	add	r8, lr
 8018110:	d1ad      	bne.n	801806e <cblas_ctrmm+0x8f6>
 8018112:	e442      	b.n	801799a <cblas_ctrmm+0x222>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8018114:	ed9c 6a01 	vldr	s12, [ip, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8018118:	edd1 5a01 	vldr	s11, [r1, #4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801811c:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8018120:	eef8 7ac8 	vcvt.f32.s32	s15, s16
            const BASE Bij_real = REAL(B, i * ldb + j);
 8018124:	460b      	mov	r3, r1
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8018126:	ee67 7a86 	vmul.f32	s15, s15, s12
            const BASE Bij_real = REAL(B, i * ldb + j);
 801812a:	ecf3 4a01 	vldmia	r3!, {s9}
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 801812e:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8018132:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8018136:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 801813a:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 801813e:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8018142:	ee37 4a84 	vadd.f32	s8, s15, s8
 8018146:	e7cd      	b.n	80180e4 <cblas_ctrmm+0x96c>
      for (i = 0; i < n1; i++) {
 8018148:	2c00      	cmp	r4, #0
 801814a:	f77f ac26 	ble.w	801799a <cblas_ctrmm+0x222>
 801814e:	00f0      	lsls	r0, r6, #3
 8018150:	9a02      	ldr	r2, [sp, #8]
 8018152:	1d03      	adds	r3, r0, #4
 8018154:	18d3      	adds	r3, r2, r3
 8018156:	9306      	str	r3, [sp, #24]
 8018158:	9b03      	ldr	r3, [sp, #12]
 801815a:	f10b 31ff 	add.w	r1, fp, #4294967295
 801815e:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8018162:	9b01      	ldr	r3, [sp, #4]
 8018164:	00db      	lsls	r3, r3, #3
 8018166:	e9cd 3404 	strd	r3, r4, [sp, #16]
 801816a:	3601      	adds	r6, #1
 801816c:	f04f 0a00 	mov.w	sl, #0
 8018170:	ea4f 08c6 	mov.w	r8, r6, lsl #3
 8018174:	f100 0908 	add.w	r9, r0, #8
 8018178:	46d6      	mov	lr, sl
        for (j = 0; j < n2; j++) {
 801817a:	f1bb 0f00 	cmp.w	fp, #0
 801817e:	dd64      	ble.n	801824a <cblas_ctrmm+0xad2>
 8018180:	9b03      	ldr	r3, [sp, #12]
 8018182:	9f06      	ldr	r7, [sp, #24]
 8018184:	eb03 04ca 	add.w	r4, r3, sl, lsl #3
 8018188:	9b02      	ldr	r3, [sp, #8]
          if (nonunit) {
 801818a:	2d83      	cmp	r5, #131	; 0x83
 801818c:	f103 0c04 	add.w	ip, r3, #4
        for (j = 0; j < n2; j++) {
 8018190:	f04f 0600 	mov.w	r6, #0
          if (nonunit) {
 8018194:	d036      	beq.n	8018204 <cblas_ctrmm+0xa8c>
          for (k = j + 1; k < n2; k++) {
 8018196:	3601      	adds	r6, #1
 8018198:	45b3      	cmp	fp, r6
            temp_real = REAL(B, i * ldb + j);
 801819a:	edd4 3a00 	vldr	s7, [r4]
            temp_imag = IMAG(B, i * ldb + j);
 801819e:	ed94 4a01 	vldr	s8, [r4, #4]
          for (k = j + 1; k < n2; k++) {
 80181a2:	d046      	beq.n	8018232 <cblas_ctrmm+0xaba>
 80181a4:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 80181a8:	463a      	mov	r2, r7
 80181aa:	4623      	mov	r3, r4
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80181ac:	edd2 7a00 	vldr	s15, [r2]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 80181b0:	edd3 5a03 	vldr	s11, [r3, #12]
            const BASE Bik_real = REAL(B, i * ldb + k);
 80181b4:	edd3 4a02 	vldr	s9, [r3, #8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80181b8:	ed12 5a01 	vldr	s10, [r2, #-4]
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80181bc:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80181c0:	3308      	adds	r3, #8
 80181c2:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80181c6:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80181ca:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = j + 1; k < n2; k++) {
 80181ce:	428b      	cmp	r3, r1
 80181d0:	4402      	add	r2, r0
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80181d2:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80181d6:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80181da:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = j + 1; k < n2; k++) {
 80181de:	d1e5      	bne.n	80181ac <cblas_ctrmm+0xa34>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80181e0:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80181e4:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80181e8:	eea3 6aa6 	vfma.f32	s12, s7, s13
          if (nonunit) {
 80181ec:	2d83      	cmp	r5, #131	; 0x83
 80181ee:	4447      	add	r7, r8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80181f0:	eee4 7a26 	vfma.f32	s15, s8, s13
 80181f4:	44cc      	add	ip, r9
 80181f6:	f104 0408 	add.w	r4, r4, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80181fa:	ed04 6a02 	vstr	s12, [r4, #-8]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80181fe:	ed44 7a01 	vstr	s15, [r4, #-4]
          if (nonunit) {
 8018202:	d1c8      	bne.n	8018196 <cblas_ctrmm+0xa1e>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8018204:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8018208:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 801820c:	edd4 7a01 	vldr	s15, [r4, #4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8018210:	edd4 5a00 	vldr	s11, [r4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8018214:	ed1c 6a01 	vldr	s12, [ip, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8018218:	ee24 4a05 	vmul.f32	s8, s8, s10
          for (k = j + 1; k < n2; k++) {
 801821c:	3601      	adds	r6, #1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 801821e:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8018222:	ee24 4a25 	vmul.f32	s8, s8, s11
          for (k = j + 1; k < n2; k++) {
 8018226:	45b3      	cmp	fp, r6
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8018228:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 801822c:	eea6 4a27 	vfma.f32	s8, s12, s15
          for (k = j + 1; k < n2; k++) {
 8018230:	d1b8      	bne.n	80181a4 <cblas_ctrmm+0xa2c>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8018232:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8018236:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801823a:	eea3 6aa6 	vfma.f32	s12, s7, s13
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 801823e:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8018242:	ed81 6a00 	vstr	s12, [r1]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8018246:	edc1 7a01 	vstr	s15, [r1, #4]
      for (i = 0; i < n1; i++) {
 801824a:	9b04      	ldr	r3, [sp, #16]
 801824c:	4419      	add	r1, r3
 801824e:	9b01      	ldr	r3, [sp, #4]
 8018250:	449a      	add	sl, r3
 8018252:	9b05      	ldr	r3, [sp, #20]
 8018254:	f10e 0e01 	add.w	lr, lr, #1
 8018258:	4573      	cmp	r3, lr
 801825a:	d18e      	bne.n	801817a <cblas_ctrmm+0xa02>
 801825c:	f7ff bb9d 	b.w	801799a <cblas_ctrmm+0x222>
 8018260:	00000000 	.word	0x00000000

08018264 <cblas_ctrmv>:
void
cblas_ctrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 8018264:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018268:	ed2d 8b02 	vpush	{d8}
 801826c:	b083      	sub	sp, #12
 801826e:	461c      	mov	r4, r3
 8018270:	e9dd 630e 	ldrd	r6, r3, [sp, #56]	; 0x38
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018274:	2a71      	cmp	r2, #113	; 0x71
 8018276:	e9dd 9710 	ldrd	r9, r7, [sp, #64]	; 0x40
 801827a:	9d12      	ldr	r5, [sp, #72]	; 0x48
 801827c:	9301      	str	r3, [sp, #4]
 801827e:	4682      	mov	sl, r0
 8018280:	468b      	mov	fp, r1
 8018282:	f000 80c1 	beq.w	8018408 <cblas_ctrmv+0x1a4>
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
  const int nonunit = (Diag == CblasNonUnit);

  INDEX i, j;

  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018286:	3979      	subs	r1, #121	; 0x79
 8018288:	2901      	cmp	r1, #1
 801828a:	4690      	mov	r8, r2
 801828c:	d934      	bls.n	80182f8 <cblas_ctrmv+0x94>
 801828e:	2002      	movs	r0, #2
 8018290:	3a6f      	subs	r2, #111	; 0x6f
 8018292:	2a02      	cmp	r2, #2
 8018294:	ed9f 8ac9 	vldr	s16, [pc, #804]	; 80185bc <cblas_ctrmv+0x358>
 8018298:	bf88      	it	hi
 801829a:	2003      	movhi	r0, #3
 801829c:	f104 027d 	add.w	r2, r4, #125	; 0x7d
 80182a0:	b2d2      	uxtb	r2, r2
 80182a2:	2a01      	cmp	r2, #1
 80182a4:	d936      	bls.n	8018314 <cblas_ctrmv+0xb0>
 80182a6:	2e00      	cmp	r6, #0
 80182a8:	db2c      	blt.n	8018304 <cblas_ctrmv+0xa0>
 80182aa:	2e01      	cmp	r6, #1
 80182ac:	4632      	mov	r2, r6
 80182ae:	bfb8      	it	lt
 80182b0:	2201      	movlt	r2, #1
 80182b2:	454a      	cmp	r2, r9
 80182b4:	f340 80b2 	ble.w	801841c <cblas_ctrmv+0x1b8>
 80182b8:	2d00      	cmp	r5, #0
 80182ba:	bf0c      	ite	eq
 80182bc:	2009      	moveq	r0, #9
 80182be:	2007      	movne	r0, #7
 80182c0:	4abf      	ldr	r2, [pc, #764]	; (80185c0 <cblas_ctrmv+0x35c>)
 80182c2:	49c0      	ldr	r1, [pc, #768]	; (80185c4 <cblas_ctrmv+0x360>)
 80182c4:	f010 fa20 	bl	8028708 <cblas_xerbla>

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80182c8:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80182cc:	d030      	beq.n	8018330 <cblas_ctrmv+0xcc>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80182ce:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 80182d2:	d107      	bne.n	80182e4 <cblas_ctrmv+0x80>
 80182d4:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 80182d8:	f000 8168 	beq.w	80185ac <cblas_ctrmv+0x348>
        IMAG(X, ix) += temp_i;
      }
      ix -= incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80182dc:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80182e0:	f000 80a1 	beq.w	8018426 <cblas_ctrmv+0x1c2>
        IMAG(X, ix) += temp_i;
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 80182e4:	4ab8      	ldr	r2, [pc, #736]	; (80185c8 <cblas_ctrmv+0x364>)
 80182e6:	49b7      	ldr	r1, [pc, #732]	; (80185c4 <cblas_ctrmv+0x360>)
 80182e8:	2000      	movs	r0, #0
#define BASE float
#include "source_trmv_c.h"
#undef BASE
}
 80182ea:	b003      	add	sp, #12
 80182ec:	ecbd 8b02 	vpop	{d8}
 80182f0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80182f4:	f010 ba08 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80182f8:	3865      	subs	r0, #101	; 0x65
 80182fa:	2801      	cmp	r0, #1
 80182fc:	bf94      	ite	ls
 80182fe:	2000      	movls	r0, #0
 8018300:	2001      	movhi	r0, #1
 8018302:	e7c5      	b.n	8018290 <cblas_ctrmv+0x2c>
 8018304:	f1b9 0f00 	cmp.w	r9, #0
 8018308:	ddd6      	ble.n	80182b8 <cblas_ctrmv+0x54>
 801830a:	2d00      	cmp	r5, #0
 801830c:	bf0c      	ite	eq
 801830e:	2009      	moveq	r0, #9
 8018310:	2005      	movne	r0, #5
 8018312:	e7d5      	b.n	80182c0 <cblas_ctrmv+0x5c>
 8018314:	2e00      	cmp	r6, #0
 8018316:	dbf5      	blt.n	8018304 <cblas_ctrmv+0xa0>
 8018318:	2e01      	cmp	r6, #1
 801831a:	4632      	mov	r2, r6
 801831c:	bfb8      	it	lt
 801831e:	2201      	movlt	r2, #1
 8018320:	454a      	cmp	r2, r9
 8018322:	dcc9      	bgt.n	80182b8 <cblas_ctrmv+0x54>
 8018324:	2d00      	cmp	r5, #0
 8018326:	f000 8255 	beq.w	80187d4 <cblas_ctrmv+0x570>
 801832a:	2800      	cmp	r0, #0
 801832c:	d0cc      	beq.n	80182c8 <cblas_ctrmv+0x64>
 801832e:	e7c7      	b.n	80182c0 <cblas_ctrmv+0x5c>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8018330:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8018334:	f000 80a7 	beq.w	8018486 <cblas_ctrmv+0x222>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8018338:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 801833c:	d1d2      	bne.n	80182e4 <cblas_ctrmv+0x80>
 801833e:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 8018342:	f000 81c4 	beq.w	80186ce <cblas_ctrmv+0x46a>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8018346:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 801834a:	d1cb      	bne.n	80182e4 <cblas_ctrmv+0x80>
    INDEX ix = OFFSET(N, incX);
 801834c:	2d00      	cmp	r5, #0
 801834e:	bfda      	itte	le
 8018350:	f1c6 0b01 	rsble	fp, r6, #1
 8018354:	fb0b fb05 	mulle.w	fp, fp, r5
 8018358:	f04f 0b00 	movgt.w	fp, #0
    for (i = 0; i < N; i++) {
 801835c:	2e00      	cmp	r6, #0
 801835e:	dd4e      	ble.n	80183fe <cblas_ctrmv+0x19a>
 8018360:	f109 0901 	add.w	r9, r9, #1
 8018364:	9b01      	ldr	r3, [sp, #4]
 8018366:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 801836a:	eb07 0ecb 	add.w	lr, r7, fp, lsl #3
 801836e:	f103 0804 	add.w	r8, r3, #4
 8018372:	f1aa 0c08 	sub.w	ip, sl, #8
 8018376:	f10e 0e04 	add.w	lr, lr, #4
 801837a:	44ab      	add	fp, r5
 801837c:	00e8      	lsls	r0, r5, #3
 801837e:	f04f 0900 	mov.w	r9, #0
      const INDEX j_min = i + 1;
 8018382:	f109 0901 	add.w	r9, r9, #1
      for (j = j_min; j < N; j++) {
 8018386:	454e      	cmp	r6, r9
      BASE temp_i = 0.0;
 8018388:	ed9f 5a91 	vldr	s10, [pc, #580]	; 80185d0 <cblas_ctrmv+0x36c>
      for (j = j_min; j < N; j++) {
 801838c:	f340 819c 	ble.w	80186c8 <cblas_ctrmv+0x464>
 8018390:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
      BASE temp_r = 0.0;
 8018394:	eef0 4a45 	vmov.f32	s9, s10
 8018398:	eb07 01cb 	add.w	r1, r7, fp, lsl #3
 801839c:	eb0c 0208 	add.w	r2, ip, r8
      for (j = j_min; j < N; j++) {
 80183a0:	464b      	mov	r3, r9
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80183a2:	edd2 7a00 	vldr	s15, [r2]
        const BASE x_imag = IMAG(X, jx);
 80183a6:	ed91 6a01 	vldr	s12, [r1, #4]
        const BASE x_real = REAL(X, jx);
 80183aa:	edd1 5a00 	vldr	s11, [r1]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80183ae:	ed52 6a01 	vldr	s13, [r2, #-4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80183b2:	ee64 7a27 	vmul.f32	s15, s8, s15
      for (j = j_min; j < N; j++) {
 80183b6:	3301      	adds	r3, #1
        temp_r += A_real * x_real - A_imag * x_imag;
 80183b8:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 80183bc:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 80183c0:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = j_min; j < N; j++) {
 80183c4:	429e      	cmp	r6, r3
 80183c6:	4401      	add	r1, r0
        temp_i += A_real * x_imag + A_imag * x_real;
 80183c8:	eee6 7a26 	vfma.f32	s15, s12, s13
 80183cc:	4462      	add	r2, ip
        temp_r += A_real * x_real - A_imag * x_imag;
 80183ce:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 80183d2:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = j_min; j < N; j++) {
 80183d6:	d1e4      	bne.n	80183a2 <cblas_ctrmv+0x13e>
      if (nonunit) {
 80183d8:	2c83      	cmp	r4, #131	; 0x83
 80183da:	d02d      	beq.n	8018438 <cblas_ctrmv+0x1d4>
        REAL(X, ix) += temp_r;
 80183dc:	ed1e 7a01 	vldr	s14, [lr, #-4]
        IMAG(X, ix) += temp_i;
 80183e0:	edde 7a00 	vldr	s15, [lr]
        REAL(X, ix) += temp_r;
 80183e4:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 80183e8:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 80183ec:	ed4e 4a01 	vstr	s9, [lr, #-4]
        IMAG(X, ix) += temp_i;
 80183f0:	ed8e 5a00 	vstr	s10, [lr]
    for (i = 0; i < N; i++) {
 80183f4:	454e      	cmp	r6, r9
 80183f6:	44ab      	add	fp, r5
 80183f8:	4486      	add	lr, r0
 80183fa:	44d0      	add	r8, sl
 80183fc:	d1c1      	bne.n	8018382 <cblas_ctrmv+0x11e>
 80183fe:	b003      	add	sp, #12
 8018400:	ecbd 8b02 	vpop	{d8}
 8018404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018408:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
 801840c:	2b01      	cmp	r3, #1
 801840e:	d930      	bls.n	8018472 <cblas_ctrmv+0x20e>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018410:	ed9f 8a6e 	vldr	s16, [pc, #440]	; 80185cc <cblas_ctrmv+0x368>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018414:	f04f 0870 	mov.w	r8, #112	; 0x70
 8018418:	2002      	movs	r0, #2
 801841a:	e73f      	b.n	801829c <cblas_ctrmv+0x38>
 801841c:	2d00      	cmp	r5, #0
 801841e:	bf0c      	ite	eq
 8018420:	2009      	moveq	r0, #9
 8018422:	2004      	movne	r0, #4
 8018424:	e74c      	b.n	80182c0 <cblas_ctrmv+0x5c>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8018426:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 801842a:	f000 8150 	beq.w	80186ce <cblas_ctrmv+0x46a>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 801842e:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 8018432:	f47f af57 	bne.w	80182e4 <cblas_ctrmv+0x80>
 8018436:	e789      	b.n	801834c <cblas_ctrmv+0xe8>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8018438:	ed98 7a00 	vldr	s14, [r8]
        const BASE x_imag = IMAG(X, ix);
 801843c:	ed9e 6a00 	vldr	s12, [lr]
        const BASE x_real = REAL(X, ix);
 8018440:	ed5e 5a01 	vldr	s11, [lr, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8018444:	ed58 6a01 	vldr	s13, [r8, #-4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8018448:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 801844c:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8018450:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8018454:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8018458:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 801845c:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8018460:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8018464:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8018468:	ed4e 4a01 	vstr	s9, [lr, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 801846c:	ed8e 5a00 	vstr	s10, [lr]
 8018470:	e7c0      	b.n	80183f4 <cblas_ctrmv+0x190>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018472:	3865      	subs	r0, #101	; 0x65
 8018474:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018476:	ed9f 8a55 	vldr	s16, [pc, #340]	; 80185cc <cblas_ctrmv+0x368>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 801847a:	bf94      	ite	ls
 801847c:	2000      	movls	r0, #0
 801847e:	2001      	movhi	r0, #1
 8018480:	f04f 0870 	mov.w	r8, #112	; 0x70
 8018484:	e70a      	b.n	801829c <cblas_ctrmv+0x38>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8018486:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 801848a:	f000 80a3 	beq.w	80185d4 <cblas_ctrmv+0x370>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 801848e:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 8018492:	f47f af27 	bne.w	80182e4 <cblas_ctrmv+0x80>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8018496:	2d00      	cmp	r5, #0
 8018498:	bfd8      	it	le
 801849a:	f1c5 0e00 	rsble	lr, r5, #0
 801849e:	f106 30ff 	add.w	r0, r6, #4294967295
 80184a2:	bfcc      	ite	gt
 80184a4:	f04f 0e00 	movgt.w	lr, #0
 80184a8:	fb00 fe0e 	mulle.w	lr, r0, lr
    for (i = N; i > 0 && i--;) {
 80184ac:	2e00      	cmp	r6, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80184ae:	fb00 e305 	mla	r3, r0, r5, lr
    for (i = N; i > 0 && i--;) {
 80184b2:	dda4      	ble.n	80183fe <cblas_ctrmv+0x19a>
 80184b4:	f109 0101 	add.w	r1, r9, #1
 80184b8:	ea4f 08c1 	mov.w	r8, r1, lsl #3
 80184bc:	9901      	ldr	r1, [sp, #4]
 80184be:	fb09 6200 	mla	r2, r9, r0, r6
 80184c2:	eb07 0cc3 	add.w	ip, r7, r3, lsl #3
 80184c6:	f1a1 0308 	sub.w	r3, r1, #8
 80184ca:	f1a8 0608 	sub.w	r6, r8, #8
 80184ce:	eb07 0ece 	add.w	lr, r7, lr, lsl #3
 80184d2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80184d6:	ea6f 0709 	mvn.w	r7, r9
 80184da:	ebc5 7245 	rsb	r2, r5, r5, lsl #29
 80184de:	ebc9 7949 	rsb	r9, r9, r9, lsl #29
 80184e2:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 80184e6:	f10c 0c04 	add.w	ip, ip, #4
 80184ea:	fb00 1606 	mla	r6, r0, r6, r1
 80184ee:	fb08 1800 	mla	r8, r8, r0, r1
 80184f2:	00ff      	lsls	r7, r7, #3
 80184f4:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 80184f8:	00ed      	lsls	r5, r5, #3
      for (j = 0; j < j_max; j++) {
 80184fa:	ed9f 5a35 	vldr	s10, [pc, #212]	; 80185d0 <cblas_ctrmv+0x36c>
 80184fe:	eef0 4a45 	vmov.f32	s9, s10
 8018502:	b1f8      	cbz	r0, 8018544 <cblas_ctrmv+0x2e0>
 8018504:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8018508:	eef0 4a45 	vmov.f32	s9, s10
 801850c:	4632      	mov	r2, r6
 801850e:	4671      	mov	r1, lr
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8018510:	edd2 7a01 	vldr	s15, [r2, #4]
        const BASE x_imag = IMAG(X, jx);
 8018514:	ed91 6a01 	vldr	s12, [r1, #4]
        const BASE x_real = REAL(X, jx);
 8018518:	edd1 5a00 	vldr	s11, [r1]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801851c:	edd2 6a00 	vldr	s13, [r2]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8018520:	ee64 7a27 	vmul.f32	s15, s8, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8018524:	3208      	adds	r2, #8
 8018526:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 801852a:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 801852e:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = 0; j < j_max; j++) {
 8018532:	4293      	cmp	r3, r2
 8018534:	4429      	add	r1, r5
        temp_i += A_real * x_imag + A_imag * x_real;
 8018536:	eee6 7a26 	vfma.f32	s15, s12, s13
        temp_r += A_real * x_real - A_imag * x_imag;
 801853a:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 801853e:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = 0; j < j_max; j++) {
 8018542:	d1e5      	bne.n	8018510 <cblas_ctrmv+0x2ac>
      if (nonunit) {
 8018544:	2c83      	cmp	r4, #131	; 0x83
 8018546:	d014      	beq.n	8018572 <cblas_ctrmv+0x30e>
        REAL(X, ix) += temp_r;
 8018548:	ed1c 7a01 	vldr	s14, [ip, #-4]
        IMAG(X, ix) += temp_i;
 801854c:	eddc 7a00 	vldr	s15, [ip]
        REAL(X, ix) += temp_r;
 8018550:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 8018554:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 8018558:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) += temp_i;
 801855c:	ed8c 5a00 	vstr	s10, [ip]
    for (i = N; i > 0 && i--;) {
 8018560:	44b8      	add	r8, r7
 8018562:	4456      	add	r6, sl
 8018564:	443b      	add	r3, r7
 8018566:	44cc      	add	ip, r9
 8018568:	2800      	cmp	r0, #0
 801856a:	f43f af48 	beq.w	80183fe <cblas_ctrmv+0x19a>
 801856e:	3801      	subs	r0, #1
 8018570:	e7c3      	b.n	80184fa <cblas_ctrmv+0x296>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8018572:	ed98 7a01 	vldr	s14, [r8, #4]
        const BASE x_imag = IMAG(X, ix);
 8018576:	ed9c 6a00 	vldr	s12, [ip]
        const BASE x_real = REAL(X, ix);
 801857a:	ed5c 5a01 	vldr	s11, [ip, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 801857e:	edd8 6a00 	vldr	s13, [r8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8018582:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8018586:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 801858a:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 801858e:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8018592:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8018596:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 801859a:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 801859e:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80185a2:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80185a6:	ed8c 5a00 	vstr	s10, [ip]
 80185aa:	e7d9      	b.n	8018560 <cblas_ctrmv+0x2fc>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80185ac:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 80185b0:	d010      	beq.n	80185d4 <cblas_ctrmv+0x370>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 80185b2:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 80185b6:	f47f ae95 	bne.w	80182e4 <cblas_ctrmv+0x80>
 80185ba:	e76c      	b.n	8018496 <cblas_ctrmv+0x232>
 80185bc:	00000001 	.word	0x00000001
 80185c0:	08031108 	.word	0x08031108
 80185c4:	080313a4 	.word	0x080313a4
 80185c8:	080311b8 	.word	0x080311b8
 80185cc:	ffffffff 	.word	0xffffffff
 80185d0:	00000000 	.word	0x00000000
    INDEX ix = OFFSET(N, incX);
 80185d4:	2d00      	cmp	r5, #0
 80185d6:	bfda      	itte	le
 80185d8:	f1c6 0201 	rsble	r2, r6, #1
 80185dc:	436a      	mulle	r2, r5
 80185de:	2200      	movgt	r2, #0
    for (i = 0; i < N; i++) {
 80185e0:	2e00      	cmp	r6, #0
 80185e2:	f77f af0c 	ble.w	80183fe <cblas_ctrmv+0x19a>
 80185e6:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80185ea:	f109 0901 	add.w	r9, r9, #1
 80185ee:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 80185f2:	f1a8 0308 	sub.w	r3, r8, #8
 80185f6:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
 80185fa:	f1aa 0b08 	sub.w	fp, sl, #8
 80185fe:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8018602:	f10c 0c04 	add.w	ip, ip, #4
 8018606:	eb02 0905 	add.w	r9, r2, r5
 801860a:	00e8      	lsls	r0, r5, #3
 801860c:	f04f 0e00 	mov.w	lr, #0
      const INDEX j_min = i + 1;
 8018610:	f10e 0e01 	add.w	lr, lr, #1
      for (j = j_min; j < N; j++) {
 8018614:	4576      	cmp	r6, lr
      BASE temp_i = 0.0;
 8018616:	ed1f 5a12 	vldr	s10, [pc, #-72]	; 80185d0 <cblas_ctrmv+0x36c>
      for (j = j_min; j < N; j++) {
 801861a:	dd52      	ble.n	80186c2 <cblas_ctrmv+0x45e>
 801861c:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
      BASE temp_r = 0.0;
 8018620:	eef0 4a45 	vmov.f32	s9, s10
 8018624:	eb07 01c9 	add.w	r1, r7, r9, lsl #3
      for (j = j_min; j < N; j++) {
 8018628:	4642      	mov	r2, r8
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 801862a:	edd2 7a03 	vldr	s15, [r2, #12]
        const BASE x_imag = IMAG(X, jx);
 801862e:	ed91 6a01 	vldr	s12, [r1, #4]
        const BASE x_real = REAL(X, jx);
 8018632:	edd1 5a00 	vldr	s11, [r1]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 8018636:	edd2 6a02 	vldr	s13, [r2, #8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 801863a:	ee64 7a27 	vmul.f32	s15, s8, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 801863e:	3208      	adds	r2, #8
 8018640:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 8018644:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8018648:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = j_min; j < N; j++) {
 801864c:	4293      	cmp	r3, r2
 801864e:	4401      	add	r1, r0
        temp_i += A_real * x_imag + A_imag * x_real;
 8018650:	eee6 7a26 	vfma.f32	s15, s12, s13
        temp_r += A_real * x_real - A_imag * x_imag;
 8018654:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 8018658:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = j_min; j < N; j++) {
 801865c:	d1e5      	bne.n	801862a <cblas_ctrmv+0x3c6>
      if (nonunit) {
 801865e:	2c83      	cmp	r4, #131	; 0x83
 8018660:	d012      	beq.n	8018688 <cblas_ctrmv+0x424>
        REAL(X, ix) += temp_r;
 8018662:	ed1c 7a01 	vldr	s14, [ip, #-4]
        IMAG(X, ix) += temp_i;
 8018666:	eddc 7a00 	vldr	s15, [ip]
        REAL(X, ix) += temp_r;
 801866a:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 801866e:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 8018672:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) += temp_i;
 8018676:	ed8c 5a00 	vstr	s10, [ip]
    for (i = 0; i < N; i++) {
 801867a:	4576      	cmp	r6, lr
 801867c:	44a9      	add	r9, r5
 801867e:	44d0      	add	r8, sl
 8018680:	445b      	add	r3, fp
 8018682:	4484      	add	ip, r0
 8018684:	d1c4      	bne.n	8018610 <cblas_ctrmv+0x3ac>
 8018686:	e6ba      	b.n	80183fe <cblas_ctrmv+0x19a>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8018688:	ed98 7a01 	vldr	s14, [r8, #4]
        const BASE x_imag = IMAG(X, ix);
 801868c:	ed9c 6a00 	vldr	s12, [ip]
        const BASE x_real = REAL(X, ix);
 8018690:	ed5c 5a01 	vldr	s11, [ip, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8018694:	edd8 6a00 	vldr	s13, [r8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8018698:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 801869c:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80186a0:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80186a4:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80186a8:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80186ac:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80186b0:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80186b4:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80186b8:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80186bc:	ed8c 5a00 	vstr	s10, [ip]
 80186c0:	e7db      	b.n	801867a <cblas_ctrmv+0x416>
      BASE temp_r = 0.0;
 80186c2:	eef0 4a45 	vmov.f32	s9, s10
 80186c6:	e7ca      	b.n	801865e <cblas_ctrmv+0x3fa>
      BASE temp_r = 0.0;
 80186c8:	eef0 4a45 	vmov.f32	s9, s10
 80186cc:	e684      	b.n	80183d8 <cblas_ctrmv+0x174>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80186ce:	2d00      	cmp	r5, #0
 80186d0:	bfd8      	it	le
 80186d2:	f1c5 0e00 	rsble	lr, r5, #0
 80186d6:	f106 30ff 	add.w	r0, r6, #4294967295
 80186da:	bfcc      	ite	gt
 80186dc:	f04f 0e00 	movgt.w	lr, #0
 80186e0:	fb00 fe0e 	mulle.w	lr, r0, lr
    for (i = N; i > 0 && i--;) {
 80186e4:	2e00      	cmp	r6, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80186e6:	fb00 e305 	mla	r3, r0, r5, lr
    for (i = N; i > 0 && i--;) {
 80186ea:	f77f ae88 	ble.w	80183fe <cblas_ctrmv+0x19a>
 80186ee:	9901      	ldr	r1, [sp, #4]
 80186f0:	f109 0201 	add.w	r2, r9, #1
 80186f4:	eb07 0cc3 	add.w	ip, r7, r3, lsl #3
 80186f8:	00d2      	lsls	r2, r2, #3
 80186fa:	ea6f 0909 	mvn.w	r9, r9
 80186fe:	ebc5 7b45 	rsb	fp, r5, r5, lsl #29
 8018702:	eb07 0ece 	add.w	lr, r7, lr, lsl #3
 8018706:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 801870a:	f10c 0c04 	add.w	ip, ip, #4
 801870e:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 8018712:	fb02 1800 	mla	r8, r2, r0, r1
 8018716:	f1a2 0708 	sub.w	r7, r2, #8
 801871a:	ea4f 09cb 	mov.w	r9, fp, lsl #3
 801871e:	00ed      	lsls	r5, r5, #3
      for (j = 0; j < j_max; j++) {
 8018720:	ed1f 5a55 	vldr	s10, [pc, #-340]	; 80185d0 <cblas_ctrmv+0x36c>
 8018724:	eef0 4a45 	vmov.f32	s9, s10
 8018728:	b308      	cbz	r0, 801876e <cblas_ctrmv+0x50a>
 801872a:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 801872e:	eef0 4a45 	vmov.f32	s9, s10
 8018732:	4631      	mov	r1, r6
 8018734:	4672      	mov	r2, lr
 8018736:	2300      	movs	r3, #0
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8018738:	ed51 7a01 	vldr	s15, [r1, #-4]
        const BASE x_imag = IMAG(X, jx);
 801873c:	ed92 6a01 	vldr	s12, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8018740:	edd2 5a00 	vldr	s11, [r2]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8018744:	ed51 6a02 	vldr	s13, [r1, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8018748:	ee64 7a27 	vmul.f32	s15, s8, s15
      for (j = 0; j < j_max; j++) {
 801874c:	3301      	adds	r3, #1
        temp_r += A_real * x_real - A_imag * x_imag;
 801874e:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 8018752:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8018756:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = 0; j < j_max; j++) {
 801875a:	4298      	cmp	r0, r3
 801875c:	442a      	add	r2, r5
        temp_i += A_real * x_imag + A_imag * x_real;
 801875e:	eee6 7a26 	vfma.f32	s15, s12, s13
 8018762:	4439      	add	r1, r7
        temp_r += A_real * x_real - A_imag * x_imag;
 8018764:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 8018768:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = 0; j < j_max; j++) {
 801876c:	d1e4      	bne.n	8018738 <cblas_ctrmv+0x4d4>
      if (nonunit) {
 801876e:	2c83      	cmp	r4, #131	; 0x83
 8018770:	d013      	beq.n	801879a <cblas_ctrmv+0x536>
        REAL(X, ix) += temp_r;
 8018772:	ed1c 7a01 	vldr	s14, [ip, #-4]
        IMAG(X, ix) += temp_i;
 8018776:	eddc 7a00 	vldr	s15, [ip]
        REAL(X, ix) += temp_r;
 801877a:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 801877e:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 8018782:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) += temp_i;
 8018786:	ed8c 5a00 	vstr	s10, [ip]
    for (i = N; i > 0 && i--;) {
 801878a:	44d0      	add	r8, sl
 801878c:	3e08      	subs	r6, #8
 801878e:	44cc      	add	ip, r9
 8018790:	2800      	cmp	r0, #0
 8018792:	f43f ae34 	beq.w	80183fe <cblas_ctrmv+0x19a>
 8018796:	3801      	subs	r0, #1
 8018798:	e7c2      	b.n	8018720 <cblas_ctrmv+0x4bc>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 801879a:	ed98 7a01 	vldr	s14, [r8, #4]
        const BASE x_imag = IMAG(X, ix);
 801879e:	ed9c 6a00 	vldr	s12, [ip]
        const BASE x_real = REAL(X, ix);
 80187a2:	ed5c 5a01 	vldr	s11, [ip, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80187a6:	edd8 6a00 	vldr	s13, [r8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80187aa:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 80187ae:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80187b2:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80187b6:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80187ba:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80187be:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80187c2:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80187c6:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80187ca:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80187ce:	ed8c 5a00 	vstr	s10, [ip]
 80187d2:	e7da      	b.n	801878a <cblas_ctrmv+0x526>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80187d4:	2009      	movs	r0, #9
 80187d6:	e573      	b.n	80182c0 <cblas_ctrmv+0x5c>

080187d8 <xhypot>:
#include <math.h>

static double xhypot (const double x, const double y);

static double xhypot (const double x, const double y)
{
 80187d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 80187da:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 80187de:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  double min, max;

  if (xabs < yabs) {
 80187e2:	4639      	mov	r1, r7
 80187e4:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 80187e6:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 80187e8:	4614      	mov	r4, r2
  if (xabs < yabs) {
 80187ea:	f010 fc2f 	bl	802904c <__aeabi_dcmplt>
 80187ee:	b928      	cbnz	r0, 80187fc <xhypot+0x24>
 80187f0:	4632      	mov	r2, r6
 80187f2:	463b      	mov	r3, r7
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
 80187f4:	4626      	mov	r6, r4
 80187f6:	462f      	mov	r7, r5
    max = xabs ;
 80187f8:	4614      	mov	r4, r2
 80187fa:	461d      	mov	r5, r3
  }

  if (min == 0) 
 80187fc:	2200      	movs	r2, #0
 80187fe:	2300      	movs	r3, #0
 8018800:	4630      	mov	r0, r6
 8018802:	4639      	mov	r1, r7
 8018804:	f010 fc18 	bl	8029038 <__aeabi_dcmpeq>
 8018808:	b9c8      	cbnz	r0, 801883e <xhypot+0x66>
    {
      return max ;
    }

  {
    double u = min / max ;
 801880a:	4622      	mov	r2, r4
 801880c:	462b      	mov	r3, r5
 801880e:	4630      	mov	r0, r6
 8018810:	4639      	mov	r1, r7
 8018812:	f010 fad3 	bl	8028dbc <__aeabi_ddiv>
 8018816:	4602      	mov	r2, r0
 8018818:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 801881a:	f010 f9a5 	bl	8028b68 <__aeabi_dmul>
 801881e:	4b09      	ldr	r3, [pc, #36]	; (8018844 <xhypot+0x6c>)
 8018820:	2200      	movs	r2, #0
 8018822:	f00f ffeb 	bl	80287fc <__adddf3>
 8018826:	ec41 0b10 	vmov	d0, r0, r1
 801882a:	f018 f9f3 	bl	8030c14 <sqrt>
 801882e:	4620      	mov	r0, r4
 8018830:	4629      	mov	r1, r5
 8018832:	ec53 2b10 	vmov	r2, r3, d0
 8018836:	f010 f997 	bl	8028b68 <__aeabi_dmul>
 801883a:	4604      	mov	r4, r0
 801883c:	460d      	mov	r5, r1
  }
}
 801883e:	4620      	mov	r0, r4
 8018840:	4629      	mov	r1, r5
 8018842:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8018844:	3ff00000 	.word	0x3ff00000

08018848 <cblas_ctrsm>:
cblas_ctrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8018848:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801884c:	ed2d 8b04 	vpush	{d8-d9}
{
  INDEX i, j, k;
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018850:	2b71      	cmp	r3, #113	; 0x71
 8018852:	b091      	sub	sp, #68	; 0x44
 8018854:	461d      	mov	r5, r3
 8018856:	bf0c      	ite	eq
 8018858:	f04f 33ff 	moveq.w	r3, #4294967295
 801885c:	2301      	movne	r3, #1
 801885e:	ee08 3a10 	vmov	s16, r3
 8018862:	f89d 3078 	ldrb.w	r3, [sp, #120]	; 0x78
 8018866:	9304      	str	r3, [sp, #16]
 8018868:	e9dd b31f 	ldrd	fp, r3, [sp, #124]	; 0x7c
 801886c:	9300      	str	r3, [sp, #0]
 801886e:	e9dd 8321 	ldrd	r8, r3, [sp, #132]	; 0x84
 8018872:	930a      	str	r3, [sp, #40]	; 0x28
 8018874:	e9dd 6323 	ldrd	r6, r3, [sp, #140]	; 0x8c
  int side, uplo, trans;

  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8018878:	298d      	cmp	r1, #141	; 0x8d
 801887a:	9306      	str	r3, [sp, #24]
 801887c:	9b25      	ldr	r3, [sp, #148]	; 0x94
 801887e:	9302      	str	r3, [sp, #8]
 8018880:	460c      	mov	r4, r1
 8018882:	4617      	mov	r7, r2
 8018884:	d067      	beq.n	8018956 <cblas_ctrsm+0x10e>
 8018886:	298e      	cmp	r1, #142	; 0x8e
 8018888:	f000 83a0 	beq.w	8018fcc <cblas_ctrsm+0x784>
 801888c:	f8dd c000 	ldr.w	ip, [sp]
 8018890:	2302      	movs	r3, #2
 8018892:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 8018896:	2a01      	cmp	r2, #1
 8018898:	9a04      	ldr	r2, [sp, #16]
 801889a:	f1a5 016f 	sub.w	r1, r5, #111	; 0x6f
 801889e:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 80188a2:	bf88      	it	hi
 80188a4:	2303      	movhi	r3, #3
 80188a6:	b2d2      	uxtb	r2, r2
 80188a8:	2902      	cmp	r1, #2
 80188aa:	bf88      	it	hi
 80188ac:	2304      	movhi	r3, #4
 80188ae:	2a02      	cmp	r2, #2
 80188b0:	9a00      	ldr	r2, [sp, #0]
 80188b2:	bf28      	it	cs
 80188b4:	2305      	movcs	r3, #5
 80188b6:	f1bb 0f00 	cmp.w	fp, #0
 80188ba:	bfb8      	it	lt
 80188bc:	2306      	movlt	r3, #6
 80188be:	2a00      	cmp	r2, #0
 80188c0:	bfb8      	it	lt
 80188c2:	2307      	movlt	r3, #7
 80188c4:	f1bc 0f01 	cmp.w	ip, #1
 80188c8:	bfb8      	it	lt
 80188ca:	f04f 0c01 	movlt.w	ip, #1
 80188ce:	45b4      	cmp	ip, r6
 80188d0:	dd34      	ble.n	801893c <cblas_ctrsm+0xf4>
 80188d2:	2865      	cmp	r0, #101	; 0x65
 80188d4:	f000 80f0 	beq.w	8018ab8 <cblas_ctrsm+0x270>
 80188d8:	465b      	mov	r3, fp
 80188da:	2b01      	cmp	r3, #1
 80188dc:	9a02      	ldr	r2, [sp, #8]
 80188de:	bfb8      	it	lt
 80188e0:	2301      	movlt	r3, #1
 80188e2:	4293      	cmp	r3, r2
 80188e4:	bfcc      	ite	gt
 80188e6:	230c      	movgt	r3, #12
 80188e8:	230a      	movle	r3, #10
 80188ea:	4a83      	ldr	r2, [pc, #524]	; (8018af8 <cblas_ctrsm+0x2b0>)
 80188ec:	4983      	ldr	r1, [pc, #524]	; (8018afc <cblas_ctrsm+0x2b4>)
 80188ee:	4618      	mov	r0, r3
 80188f0:	f00f ff0a 	bl	8028708 <cblas_xerbla>
      trans = TransA;
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
    } else {
      n1 = N;
      n2 = M;
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 80188f4:	2c8d      	cmp	r4, #141	; 0x8d
 80188f6:	bf0c      	ite	eq
 80188f8:	248e      	moveq	r4, #142	; 0x8e
 80188fa:	248d      	movne	r4, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 80188fc:	2f79      	cmp	r7, #121	; 0x79
 80188fe:	bf0c      	ite	eq
 8018900:	277a      	moveq	r7, #122	; 0x7a
 8018902:	2779      	movne	r7, #121	; 0x79
    const BASE alpha_real = CONST_REAL0(alpha);
 8018904:	ed98 7a00 	vldr	s14, [r8]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8018908:	edd8 7a01 	vldr	s15, [r8, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 801890c:	2d6f      	cmp	r5, #111	; 0x6f
 801890e:	bf0c      	ite	eq
 8018910:	256f      	moveq	r5, #111	; 0x6f
 8018912:	2570      	movne	r5, #112	; 0x70
    }

    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8018914:	2c8d      	cmp	r4, #141	; 0x8d
 8018916:	d026      	beq.n	8018966 <cblas_ctrsm+0x11e>
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
          }
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8018918:	2c8e      	cmp	r4, #142	; 0x8e
 801891a:	d105      	bne.n	8018928 <cblas_ctrsm+0xe0>
 801891c:	2f79      	cmp	r7, #121	; 0x79
 801891e:	f000 80f1 	beq.w	8018b04 <cblas_ctrsm+0x2bc>
          }
        }
      }


    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8018922:	2f7a      	cmp	r7, #122	; 0x7a
 8018924:	f000 81c0 	beq.w	8018ca8 <cblas_ctrsm+0x460>
        }
      }


    } else {
      BLAS_ERROR("unrecognized operation");
 8018928:	4a75      	ldr	r2, [pc, #468]	; (8018b00 <cblas_ctrsm+0x2b8>)
 801892a:	4974      	ldr	r1, [pc, #464]	; (8018afc <cblas_ctrsm+0x2b4>)
 801892c:	2000      	movs	r0, #0
#define BASE float
#include "source_trsm_c.h"
#undef BASE
}
 801892e:	b011      	add	sp, #68	; 0x44
 8018930:	ecbd 8b04 	vpop	{d8-d9}
 8018934:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018938:	f00f bee6 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801893c:	2865      	cmp	r0, #101	; 0x65
 801893e:	f000 8292 	beq.w	8018e66 <cblas_ctrsm+0x61e>
 8018942:	465a      	mov	r2, fp
 8018944:	2a01      	cmp	r2, #1
 8018946:	9902      	ldr	r1, [sp, #8]
 8018948:	bfb8      	it	lt
 801894a:	2201      	movlt	r2, #1
 801894c:	428a      	cmp	r2, r1
 801894e:	f340 80ce 	ble.w	8018aee <cblas_ctrsm+0x2a6>
 8018952:	230c      	movs	r3, #12
 8018954:	e7c9      	b.n	80188ea <cblas_ctrsm+0xa2>
 8018956:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 801895a:	2b01      	cmp	r3, #1
 801895c:	bf94      	ite	ls
 801895e:	2300      	movls	r3, #0
 8018960:	2301      	movhi	r3, #1
 8018962:	46dc      	mov	ip, fp
 8018964:	e795      	b.n	8018892 <cblas_ctrsm+0x4a>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8018966:	2f79      	cmp	r7, #121	; 0x79
 8018968:	f000 8287 	beq.w	8018e7a <cblas_ctrsm+0x632>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 801896c:	2f7a      	cmp	r7, #122	; 0x7a
 801896e:	d1db      	bne.n	8018928 <cblas_ctrsm+0xe0>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018970:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8018974:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018976:	eeb4 7a66 	vcmp.f32	s14, s13
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 801897a:	f000 8469 	beq.w	8019250 <cblas_ctrsm+0xa08>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 801897e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018982:	f000 837e 	beq.w	8019082 <cblas_ctrsm+0x83a>
        for (i = 0; i < n1; i++) {
 8018986:	9f00      	ldr	r7, [sp, #0]
 8018988:	2f00      	cmp	r7, #0
 801898a:	f340 8267 	ble.w	8018e5c <cblas_ctrsm+0x614>
 801898e:	9b02      	ldr	r3, [sp, #8]
 8018990:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018994:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018998:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 801899c:	930e      	str	r3, [sp, #56]	; 0x38
 801899e:	9b06      	ldr	r3, [sp, #24]
 80189a0:	00e4      	lsls	r4, r4, #3
 80189a2:	1d25      	adds	r5, r4, #4
 80189a4:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 80189a8:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 80189aa:	f1bb 0f00 	cmp.w	fp, #0
 80189ae:	dd15      	ble.n	80189dc <cblas_ctrsm+0x194>
 80189b0:	1863      	adds	r3, r4, r1
 80189b2:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80189b4:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80189b8:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80189bc:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80189c0:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80189c4:	eea5 6a07 	vfma.f32	s12, s10, s14
 80189c8:	3308      	adds	r3, #8
 80189ca:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80189cc:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80189d0:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80189d4:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80189d8:	4299      	cmp	r1, r3
 80189da:	d1eb      	bne.n	80189b4 <cblas_ctrsm+0x16c>
        for (i = 0; i < n1; i++) {
 80189dc:	3001      	adds	r0, #1
 80189de:	4287      	cmp	r7, r0
 80189e0:	4451      	add	r1, sl
 80189e2:	d1e2      	bne.n	80189aa <cblas_ctrsm+0x162>
 80189e4:	9b00      	ldr	r3, [sp, #0]
 80189e6:	9a02      	ldr	r2, [sp, #8]
 80189e8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80189ea:	1e5c      	subs	r4, r3, #1
 80189ec:	fb06 f804 	mul.w	r8, r6, r4
 80189f0:	eb03 0108 	add.w	r1, r3, r8
 80189f4:	ebc6 7c46 	rsb	ip, r6, r6, lsl #29
 80189f8:	43f3      	mvns	r3, r6
 80189fa:	ebc2 7042 	rsb	r0, r2, r2, lsl #29
 80189fe:	fb06 4204 	mla	r2, r6, r4, r4
 8018a02:	00de      	lsls	r6, r3, #3
 8018a04:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8018a08:	eb07 09c2 	add.w	r9, r7, r2, lsl #3
 8018a0c:	9307      	str	r3, [sp, #28]
 8018a0e:	9a06      	ldr	r2, [sp, #24]
 8018a10:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018a12:	f1a7 0508 	sub.w	r5, r7, #8
 8018a16:	00c0      	lsls	r0, r0, #3
 8018a18:	18d3      	adds	r3, r2, r3
 8018a1a:	eb07 08c8 	add.w	r8, r7, r8, lsl #3
 8018a1e:	9002      	str	r0, [sp, #8]
 8018a20:	eb05 05c1 	add.w	r5, r5, r1, lsl #3
 8018a24:	fb0a 2704 	mla	r7, sl, r4, r2
 8018a28:	9300      	str	r3, [sp, #0]
        if (nonunit) {
 8018a2a:	9b04      	ldr	r3, [sp, #16]
 8018a2c:	2b83      	cmp	r3, #131	; 0x83
 8018a2e:	f000 82e7 	beq.w	8019000 <cblas_ctrsm+0x7b8>
        for (k = 0; k < i; k++) {
 8018a32:	2c00      	cmp	r4, #0
 8018a34:	f000 8212 	beq.w	8018e5c <cblas_ctrsm+0x614>
 8018a38:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8018a3c:	9800      	ldr	r0, [sp, #0]
 8018a3e:	f8dd e018 	ldr.w	lr, [sp, #24]
 8018a42:	46c4      	mov	ip, r8
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8018a44:	ed9c 5a01 	vldr	s10, [ip, #4]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8018a48:	eddc 4a00 	vldr	s9, [ip]
          for (j = 0; j < n2; j++) {
 8018a4c:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8018a50:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 8018a54:	dd22      	ble.n	8018a9c <cblas_ctrsm+0x254>
 8018a56:	f10e 0104 	add.w	r1, lr, #4
 8018a5a:	4673      	mov	r3, lr
 8018a5c:	463a      	mov	r2, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018a5e:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018a62:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8018a66:	ed51 6a01 	vldr	s13, [r1, #-4]
 8018a6a:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8018a6e:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8018a72:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8018a76:	3308      	adds	r3, #8
 8018a78:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8018a7a:	eee4 7a87 	vfma.f32	s15, s9, s14
 8018a7e:	3108      	adds	r1, #8
 8018a80:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8018a84:	ee76 7ac6 	vsub.f32	s15, s13, s12
 8018a88:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8018a8c:	ed53 7a01 	vldr	s15, [r3, #-4]
 8018a90:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8018a94:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018a98:	4298      	cmp	r0, r3
 8018a9a:	d1e0      	bne.n	8018a5e <cblas_ctrsm+0x216>
        for (k = 0; k < i; k++) {
 8018a9c:	f10c 0c08 	add.w	ip, ip, #8
 8018aa0:	4565      	cmp	r5, ip
 8018aa2:	44d6      	add	lr, sl
 8018aa4:	4450      	add	r0, sl
 8018aa6:	d1cd      	bne.n	8018a44 <cblas_ctrsm+0x1fc>
 8018aa8:	9b02      	ldr	r3, [sp, #8]
 8018aaa:	441f      	add	r7, r3
 8018aac:	9b07      	ldr	r3, [sp, #28]
 8018aae:	4435      	add	r5, r6
 8018ab0:	4498      	add	r8, r3
 8018ab2:	44b1      	add	r9, r6
 8018ab4:	3c01      	subs	r4, #1
 8018ab6:	e7b8      	b.n	8018a2a <cblas_ctrsm+0x1e2>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8018ab8:	4613      	mov	r3, r2
 8018aba:	2a01      	cmp	r2, #1
 8018abc:	9a02      	ldr	r2, [sp, #8]
 8018abe:	bfb8      	it	lt
 8018ac0:	2301      	movlt	r3, #1
 8018ac2:	4293      	cmp	r3, r2
 8018ac4:	bfcc      	ite	gt
 8018ac6:	230c      	movgt	r3, #12
 8018ac8:	230a      	movle	r3, #10
 8018aca:	4a0b      	ldr	r2, [pc, #44]	; (8018af8 <cblas_ctrsm+0x2b0>)
 8018acc:	490b      	ldr	r1, [pc, #44]	; (8018afc <cblas_ctrsm+0x2b4>)
 8018ace:	4618      	mov	r0, r3
 8018ad0:	f00f fe1a 	bl	8028708 <cblas_xerbla>
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8018ad4:	2d6f      	cmp	r5, #111	; 0x6f
    const BASE alpha_real = CONST_REAL0(alpha);
 8018ad6:	ed98 7a00 	vldr	s14, [r8]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8018ada:	edd8 7a01 	vldr	s15, [r8, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8018ade:	9b00      	ldr	r3, [sp, #0]
 8018ae0:	f000 826c 	beq.w	8018fbc <cblas_ctrsm+0x774>
 8018ae4:	f8cd b000 	str.w	fp, [sp]
 8018ae8:	2570      	movs	r5, #112	; 0x70
 8018aea:	469b      	mov	fp, r3
 8018aec:	e712      	b.n	8018914 <cblas_ctrsm+0xcc>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8018aee:	2b00      	cmp	r3, #0
 8018af0:	f43f af00 	beq.w	80188f4 <cblas_ctrsm+0xac>
 8018af4:	e6f9      	b.n	80188ea <cblas_ctrsm+0xa2>
 8018af6:	bf00      	nop
 8018af8:	08031108 	.word	0x08031108
 8018afc:	080313b4 	.word	0x080313b4
 8018b00:	080311b8 	.word	0x080311b8
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018b04:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8018b08:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018b0a:	eeb4 7a66 	vcmp.f32	s14, s13
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8018b0e:	f000 8422 	beq.w	8019356 <cblas_ctrsm+0xb0e>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018b12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018b16:	f000 82d6 	beq.w	80190c6 <cblas_ctrsm+0x87e>
        for (i = 0; i < n1; i++) {
 8018b1a:	9f00      	ldr	r7, [sp, #0]
 8018b1c:	2f00      	cmp	r7, #0
 8018b1e:	f340 819d 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8018b22:	9b02      	ldr	r3, [sp, #8]
 8018b24:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018b28:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018b2c:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018b30:	930e      	str	r3, [sp, #56]	; 0x38
 8018b32:	9b06      	ldr	r3, [sp, #24]
 8018b34:	00e4      	lsls	r4, r4, #3
 8018b36:	1d25      	adds	r5, r4, #4
 8018b38:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018b3c:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018b3e:	f1bb 0f00 	cmp.w	fp, #0
 8018b42:	dd15      	ble.n	8018b70 <cblas_ctrsm+0x328>
 8018b44:	190b      	adds	r3, r1, r4
 8018b46:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018b48:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018b4c:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018b50:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018b54:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018b58:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018b5c:	3308      	adds	r3, #8
 8018b5e:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018b60:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018b64:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018b68:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018b6c:	428b      	cmp	r3, r1
 8018b6e:	d1eb      	bne.n	8018b48 <cblas_ctrsm+0x300>
        for (i = 0; i < n1; i++) {
 8018b70:	3001      	adds	r0, #1
 8018b72:	4287      	cmp	r7, r0
 8018b74:	4451      	add	r1, sl
 8018b76:	d1e2      	bne.n	8018b3e <cblas_ctrsm+0x2f6>
 8018b78:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8018b7a:	f8cd a020 	str.w	sl, [sp, #32]
 8018b7e:	3a08      	subs	r2, #8
 8018b80:	1c75      	adds	r5, r6, #1
 8018b82:	920b      	str	r2, [sp, #44]	; 0x2c
 8018b84:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8018b86:	f8dd a010 	ldr.w	sl, [sp, #16]
 8018b8a:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8018b8e:	00ed      	lsls	r5, r5, #3
 8018b90:	f10b 33ff 	add.w	r3, fp, #4294967295
 8018b94:	fb05 2303 	mla	r3, r5, r3, r2
 8018b98:	43f6      	mvns	r6, r6
 8018b9a:	930a      	str	r3, [sp, #40]	; 0x28
        for (j = n2; j > 0 && j--;) {
 8018b9c:	2300      	movs	r3, #0
 8018b9e:	e9cd 3b06 	strd	r3, fp, [sp, #24]
 8018ba2:	00f6      	lsls	r6, r6, #3
 8018ba4:	3d08      	subs	r5, #8
 8018ba6:	4693      	mov	fp, r2
 8018ba8:	9f07      	ldr	r7, [sp, #28]
 8018baa:	2f00      	cmp	r7, #0
 8018bac:	dd73      	ble.n	8018c96 <cblas_ctrsm+0x44e>
 8018bae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8018bb0:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
          if (nonunit) {
 8018bb4:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8018bb8:	eb03 0409 	add.w	r4, r3, r9
 8018bbc:	d033      	beq.n	8018c26 <cblas_ctrsm+0x3de>
            for (k = 0; k < j; k++) {
 8018bbe:	2f01      	cmp	r7, #1
 8018bc0:	edd4 5a01 	vldr	s11, [r4, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018bc4:	ed94 5a00 	vldr	s10, [r4]
            for (k = 0; k < j; k++) {
 8018bc8:	d065      	beq.n	8018c96 <cblas_ctrsm+0x44e>
 8018bca:	eef8 4ac8 	vcvt.f32.s32	s9, s16
 8018bce:	eb0b 01c7 	add.w	r1, fp, r7, lsl #3
 8018bd2:	f109 0204 	add.w	r2, r9, #4
 8018bd6:	464b      	mov	r3, r9
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8018bd8:	ed51 7a01 	vldr	s15, [r1, #-4]
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8018bdc:	ed11 6a02 	vldr	s12, [r1, #-8]
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018be0:	ed52 6a01 	vldr	s13, [r2, #-4]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8018be4:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018be8:	3308      	adds	r3, #8
 8018bea:	ee25 7ae7 	vnmul.f32	s14, s11, s15
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018bee:	ee65 7a27 	vmul.f32	s15, s10, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018bf2:	eea5 7a06 	vfma.f32	s14, s10, s12
 8018bf6:	4429      	add	r1, r5
 8018bf8:	3208      	adds	r2, #8
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018bfa:	eee6 7a25 	vfma.f32	s15, s12, s11
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018bfe:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8018c02:	ed02 7a03 	vstr	s14, [r2, #-12]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018c06:	ed13 7a01 	vldr	s14, [r3, #-4]
 8018c0a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8018c0e:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (k = 0; k < j; k++) {
 8018c12:	42a3      	cmp	r3, r4
 8018c14:	d1e0      	bne.n	8018bd8 <cblas_ctrsm+0x390>
          if (nonunit) {
 8018c16:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8018c1a:	f107 37ff 	add.w	r7, r7, #4294967295
 8018c1e:	f1a4 0408 	sub.w	r4, r4, #8
 8018c22:	44b0      	add	r8, r6
 8018c24:	d1cb      	bne.n	8018bbe <cblas_ctrsm+0x376>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018c26:	edd8 7a01 	vldr	s15, [r8, #4]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8018c2a:	ed98 9a00 	vldr	s18, [r8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018c2e:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 8018c32:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8018c36:	ee18 0a90 	vmov	r0, s17
 8018c3a:	f00f ff3d 	bl	8028ab8 <__aeabi_f2d>
 8018c3e:	4602      	mov	r2, r0
 8018c40:	460b      	mov	r3, r1
 8018c42:	ee19 0a10 	vmov	r0, s18
 8018c46:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8018c4a:	f00f ff35 	bl	8028ab8 <__aeabi_f2d>
 8018c4e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8018c52:	f7ff fdc1 	bl	80187d8 <xhypot>
 8018c56:	f010 fa37 	bl	80290c8 <__aeabi_d2f>
 8018c5a:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 8018c5e:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            for (k = 0; k < j; k++) {
 8018c62:	2f01      	cmp	r7, #1
            const BASE a_real = Ajj_real / s;
 8018c64:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018c68:	ed94 6a01 	vldr	s12, [r4, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018c6c:	ed94 5a00 	vldr	s10, [r4]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018c70:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018c74:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018c78:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018c7c:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018c80:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018c84:	eec7 5a27 	vdiv.f32	s11, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018c88:	ed84 6a00 	vstr	s12, [r4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018c8c:	ed94 5a00 	vldr	s10, [r4]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018c90:	edc4 5a01 	vstr	s11, [r4, #4]
            for (k = 0; k < j; k++) {
 8018c94:	d199      	bne.n	8018bca <cblas_ctrsm+0x382>
      for (i = 0; i < n1; i++) {
 8018c96:	9a08      	ldr	r2, [sp, #32]
 8018c98:	9b06      	ldr	r3, [sp, #24]
 8018c9a:	4491      	add	r9, r2
 8018c9c:	9a00      	ldr	r2, [sp, #0]
 8018c9e:	3301      	adds	r3, #1
 8018ca0:	429a      	cmp	r2, r3
 8018ca2:	9306      	str	r3, [sp, #24]
 8018ca4:	dc80      	bgt.n	8018ba8 <cblas_ctrsm+0x360>
 8018ca6:	e0d9      	b.n	8018e5c <cblas_ctrsm+0x614>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018ca8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8018cac:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018cae:	eeb4 7a66 	vcmp.f32	s14, s13
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8018cb2:	f000 83f9 	beq.w	80194a8 <cblas_ctrsm+0xc60>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018cb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018cba:	f000 8190 	beq.w	8018fde <cblas_ctrsm+0x796>
        for (i = 0; i < n1; i++) {
 8018cbe:	9f00      	ldr	r7, [sp, #0]
 8018cc0:	2f00      	cmp	r7, #0
 8018cc2:	f340 80cb 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8018cc6:	9b02      	ldr	r3, [sp, #8]
 8018cc8:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018ccc:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018cd0:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018cd4:	930e      	str	r3, [sp, #56]	; 0x38
 8018cd6:	9b06      	ldr	r3, [sp, #24]
 8018cd8:	00e4      	lsls	r4, r4, #3
 8018cda:	1d25      	adds	r5, r4, #4
 8018cdc:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018ce0:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018ce2:	f1bb 0f00 	cmp.w	fp, #0
 8018ce6:	dd15      	ble.n	8018d14 <cblas_ctrsm+0x4cc>
 8018ce8:	190b      	adds	r3, r1, r4
 8018cea:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018cec:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018cf0:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018cf4:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018cf8:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018cfc:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018d00:	3308      	adds	r3, #8
 8018d02:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018d04:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018d08:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018d0c:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018d10:	428b      	cmp	r3, r1
 8018d12:	d1eb      	bne.n	8018cec <cblas_ctrsm+0x4a4>
        for (i = 0; i < n1; i++) {
 8018d14:	3001      	adds	r0, #1
 8018d16:	4287      	cmp	r7, r0
 8018d18:	4451      	add	r1, sl
 8018d1a:	d1e2      	bne.n	8018ce2 <cblas_ctrsm+0x49a>
 8018d1c:	00f5      	lsls	r5, r6, #3
 8018d1e:	3601      	adds	r6, #1
 8018d20:	00f1      	lsls	r1, r6, #3
 8018d22:	9107      	str	r1, [sp, #28]
 8018d24:	990a      	ldr	r1, [sp, #40]	; 0x28
 8018d26:	9a06      	ldr	r2, [sp, #24]
 8018d28:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 8018d2c:	1d2b      	adds	r3, r5, #4
 8018d2e:	18cb      	adds	r3, r1, r3
 8018d30:	930f      	str	r3, [sp, #60]	; 0x3c
 8018d32:	f105 0308 	add.w	r3, r5, #8
 8018d36:	9308      	str	r3, [sp, #32]
 8018d38:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018d3a:	f8dd a010 	ldr.w	sl, [sp, #16]
 8018d3e:	f1a2 0408 	sub.w	r4, r2, #8
            for (k = j + 1; k < n2; k++) {
 8018d42:	2200      	movs	r2, #0
 8018d44:	920b      	str	r2, [sp, #44]	; 0x2c
 8018d46:	441c      	add	r4, r3
 8018d48:	920e      	str	r2, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 8018d4a:	f1bb 0f00 	cmp.w	fp, #0
 8018d4e:	dd78      	ble.n	8018e42 <cblas_ctrsm+0x5fa>
 8018d50:	9b06      	ldr	r3, [sp, #24]
 8018d52:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8018d54:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 8018d58:	eb03 06c2 	add.w	r6, r3, r2, lsl #3
 8018d5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
          if (nonunit) {
 8018d5e:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8018d62:	f103 0904 	add.w	r9, r3, #4
        for (j = 0; j < n2; j++) {
 8018d66:	f04f 0700 	mov.w	r7, #0
          if (nonunit) {
 8018d6a:	d031      	beq.n	8018dd0 <cblas_ctrsm+0x588>
            for (k = j + 1; k < n2; k++) {
 8018d6c:	3701      	adds	r7, #1
 8018d6e:	45bb      	cmp	fp, r7
 8018d70:	ed96 5a01 	vldr	s10, [r6, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018d74:	edd6 4a00 	vldr	s9, [r6]
            for (k = j + 1; k < n2; k++) {
 8018d78:	d063      	beq.n	8018e42 <cblas_ctrsm+0x5fa>
 8018d7a:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8018d7e:	4642      	mov	r2, r8
 8018d80:	4633      	mov	r3, r6
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8018d82:	edd2 7a00 	vldr	s15, [r2]
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8018d86:	ed52 5a01 	vldr	s11, [r2, #-4]
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018d8a:	ed93 6a02 	vldr	s12, [r3, #8]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018d8e:	ed93 7a03 	vldr	s14, [r3, #12]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8018d92:	ee64 7a27 	vmul.f32	s15, s8, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018d96:	3308      	adds	r3, #8
 8018d98:	ee65 6a67 	vnmul.f32	s13, s10, s15
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018d9c:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018da0:	eee4 6aa5 	vfma.f32	s13, s9, s11
 8018da4:	442a      	add	r2, r5
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018da6:	eee5 7a85 	vfma.f32	s15, s11, s10
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018daa:	ee76 6a66 	vsub.f32	s13, s12, s13
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018dae:	ee77 7a67 	vsub.f32	s15, s14, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8018db2:	edc3 6a00 	vstr	s13, [r3]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8018db6:	edc3 7a01 	vstr	s15, [r3, #4]
            for (k = j + 1; k < n2; k++) {
 8018dba:	42a3      	cmp	r3, r4
 8018dbc:	d1e1      	bne.n	8018d82 <cblas_ctrsm+0x53a>
 8018dbe:	9b07      	ldr	r3, [sp, #28]
 8018dc0:	4498      	add	r8, r3
 8018dc2:	9b08      	ldr	r3, [sp, #32]
          if (nonunit) {
 8018dc4:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8018dc8:	f106 0608 	add.w	r6, r6, #8
 8018dcc:	4499      	add	r9, r3
 8018dce:	d1cd      	bne.n	8018d6c <cblas_ctrsm+0x524>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018dd0:	edd9 7a00 	vldr	s15, [r9]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8018dd4:	ed19 9a01 	vldr	s18, [r9, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018dd8:	eef8 8ac8 	vcvt.f32.s32	s17, s16
            for (k = j + 1; k < n2; k++) {
 8018ddc:	3701      	adds	r7, #1
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018dde:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8018de2:	ee18 0a90 	vmov	r0, s17
 8018de6:	f00f fe67 	bl	8028ab8 <__aeabi_f2d>
 8018dea:	4602      	mov	r2, r0
 8018dec:	460b      	mov	r3, r1
 8018dee:	ee19 0a10 	vmov	r0, s18
 8018df2:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8018df6:	f00f fe5f 	bl	8028ab8 <__aeabi_f2d>
 8018dfa:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8018dfe:	f7ff fceb 	bl	80187d8 <xhypot>
 8018e02:	f010 f961 	bl	80290c8 <__aeabi_d2f>
 8018e06:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 8018e0a:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            for (k = j + 1; k < n2; k++) {
 8018e0e:	45bb      	cmp	fp, r7
            const BASE a_real = Ajj_real / s;
 8018e10:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018e14:	ed96 6a01 	vldr	s12, [r6, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018e18:	ed96 5a00 	vldr	s10, [r6]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018e1c:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018e20:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018e24:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018e28:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018e2c:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018e30:	ee87 5a27 	vdiv.f32	s10, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018e34:	ed86 6a00 	vstr	s12, [r6]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018e38:	edd6 4a00 	vldr	s9, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018e3c:	ed86 5a01 	vstr	s10, [r6, #4]
            for (k = j + 1; k < n2; k++) {
 8018e40:	d19b      	bne.n	8018d7a <cblas_ctrsm+0x532>
      for (i = 0; i < n1; i++) {
 8018e42:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8018e44:	9902      	ldr	r1, [sp, #8]
 8018e46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018e48:	440a      	add	r2, r1
 8018e4a:	920b      	str	r2, [sp, #44]	; 0x2c
 8018e4c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8018e4e:	4414      	add	r4, r2
 8018e50:	9a00      	ldr	r2, [sp, #0]
 8018e52:	3301      	adds	r3, #1
 8018e54:	429a      	cmp	r2, r3
 8018e56:	930e      	str	r3, [sp, #56]	; 0x38
 8018e58:	f73f af77 	bgt.w	8018d4a <cblas_ctrsm+0x502>
 8018e5c:	b011      	add	sp, #68	; 0x44
 8018e5e:	ecbd 8b04 	vpop	{d8-d9}
 8018e62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8018e66:	9a00      	ldr	r2, [sp, #0]
 8018e68:	9902      	ldr	r1, [sp, #8]
 8018e6a:	2a01      	cmp	r2, #1
 8018e6c:	bfb8      	it	lt
 8018e6e:	2201      	movlt	r2, #1
 8018e70:	428a      	cmp	r2, r1
 8018e72:	f340 80a7 	ble.w	8018fc4 <cblas_ctrsm+0x77c>
 8018e76:	230c      	movs	r3, #12
 8018e78:	e627      	b.n	8018aca <cblas_ctrsm+0x282>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018e7a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8018e7e:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018e80:	eeb4 7a66 	vcmp.f32	s14, s13
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8018e84:	f000 8130 	beq.w	80190e8 <cblas_ctrsm+0x8a0>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018e88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018e8c:	f000 810a 	beq.w	80190a4 <cblas_ctrsm+0x85c>
        for (i = 0; i < n1; i++) {
 8018e90:	9f00      	ldr	r7, [sp, #0]
 8018e92:	2f00      	cmp	r7, #0
 8018e94:	dde2      	ble.n	8018e5c <cblas_ctrsm+0x614>
 8018e96:	9b02      	ldr	r3, [sp, #8]
 8018e98:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018e9c:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018ea0:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018ea4:	930e      	str	r3, [sp, #56]	; 0x38
 8018ea6:	9b06      	ldr	r3, [sp, #24]
 8018ea8:	00e4      	lsls	r4, r4, #3
 8018eaa:	1d25      	adds	r5, r4, #4
 8018eac:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018eb0:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018eb2:	f1bb 0f00 	cmp.w	fp, #0
 8018eb6:	dd15      	ble.n	8018ee4 <cblas_ctrsm+0x69c>
 8018eb8:	1863      	adds	r3, r4, r1
 8018eba:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018ebc:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018ec0:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018ec4:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018ec8:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018ecc:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018ed0:	3308      	adds	r3, #8
 8018ed2:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018ed4:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018ed8:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018edc:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018ee0:	4299      	cmp	r1, r3
 8018ee2:	d1eb      	bne.n	8018ebc <cblas_ctrsm+0x674>
        for (i = 0; i < n1; i++) {
 8018ee4:	3001      	adds	r0, #1
 8018ee6:	4287      	cmp	r7, r0
 8018ee8:	4451      	add	r1, sl
 8018eea:	d1e2      	bne.n	8018eb2 <cblas_ctrsm+0x66a>
 8018eec:	990e      	ldr	r1, [sp, #56]	; 0x38
 8018eee:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 8018ef2:	9a06      	ldr	r2, [sp, #24]
 8018ef4:	f8cd 801c 	str.w	r8, [sp, #28]
 8018ef8:	00f3      	lsls	r3, r6, #3
 8018efa:	4608      	mov	r0, r1
 8018efc:	930b      	str	r3, [sp, #44]	; 0x2c
 8018efe:	9900      	ldr	r1, [sp, #0]
 8018f00:	9e02      	ldr	r6, [sp, #8]
 8018f02:	3308      	adds	r3, #8
 8018f04:	f1a8 0408 	sub.w	r4, r8, #8
 8018f08:	f04f 0900 	mov.w	r9, #0
 8018f0c:	4410      	add	r0, r2
 8018f0e:	930a      	str	r3, [sp, #40]	; 0x28
 8018f10:	1d13      	adds	r3, r2, #4
 8018f12:	9008      	str	r0, [sp, #32]
 8018f14:	eb04 04c1 	add.w	r4, r4, r1, lsl #3
 8018f18:	464f      	mov	r7, r9
 8018f1a:	4615      	mov	r5, r2
 8018f1c:	930e      	str	r3, [sp, #56]	; 0x38
        if (nonunit) {
 8018f1e:	9b04      	ldr	r3, [sp, #16]
 8018f20:	2b83      	cmp	r3, #131	; 0x83
 8018f22:	f000 83a8 	beq.w	8019676 <cblas_ctrsm+0xe2e>
        for (k = i + 1; k < n1; k++) {
 8018f26:	9b00      	ldr	r3, [sp, #0]
 8018f28:	3701      	adds	r7, #1
 8018f2a:	42bb      	cmp	r3, r7
 8018f2c:	dd96      	ble.n	8018e5c <cblas_ctrsm+0x614>
 8018f2e:	9b06      	ldr	r3, [sp, #24]
 8018f30:	eb03 0ec6 	add.w	lr, r3, r6, lsl #3
 8018f34:	9b08      	ldr	r3, [sp, #32]
 8018f36:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8018f3a:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 8018f3e:	46c4      	mov	ip, r8
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8018f40:	ed9c 5a03 	vldr	s10, [ip, #12]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8018f44:	eddc 4a02 	vldr	s9, [ip, #8]
          for (j = 0; j < n2; j++) {
 8018f48:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8018f4c:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 8018f50:	dd22      	ble.n	8018f98 <cblas_ctrsm+0x750>
 8018f52:	f10e 0104 	add.w	r1, lr, #4
 8018f56:	4673      	mov	r3, lr
 8018f58:	462a      	mov	r2, r5
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018f5a:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018f5e:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8018f62:	ed51 6a01 	vldr	s13, [r1, #-4]
 8018f66:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8018f6a:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8018f6e:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8018f72:	3308      	adds	r3, #8
 8018f74:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8018f76:	eee4 7a87 	vfma.f32	s15, s9, s14
 8018f7a:	3108      	adds	r1, #8
 8018f7c:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8018f80:	ee76 7ac6 	vsub.f32	s15, s13, s12
 8018f84:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8018f88:	ed53 7a01 	vldr	s15, [r3, #-4]
 8018f8c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8018f90:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018f94:	4298      	cmp	r0, r3
 8018f96:	d1e0      	bne.n	8018f5a <cblas_ctrsm+0x712>
        for (k = i + 1; k < n1; k++) {
 8018f98:	f10c 0c08 	add.w	ip, ip, #8
 8018f9c:	4564      	cmp	r4, ip
 8018f9e:	44d6      	add	lr, sl
 8018fa0:	4450      	add	r0, sl
 8018fa2:	d1cd      	bne.n	8018f40 <cblas_ctrsm+0x6f8>
 8018fa4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8018fa6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8018fa8:	441c      	add	r4, r3
 8018faa:	9b02      	ldr	r3, [sp, #8]
 8018fac:	4499      	add	r9, r3
 8018fae:	441e      	add	r6, r3
 8018fb0:	9b07      	ldr	r3, [sp, #28]
 8018fb2:	4413      	add	r3, r2
 8018fb4:	4455      	add	r5, sl
 8018fb6:	4490      	add	r8, r2
 8018fb8:	9307      	str	r3, [sp, #28]
 8018fba:	e7b0      	b.n	8018f1e <cblas_ctrsm+0x6d6>
 8018fbc:	f8cd b000 	str.w	fp, [sp]
 8018fc0:	469b      	mov	fp, r3
 8018fc2:	e4a7      	b.n	8018914 <cblas_ctrsm+0xcc>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8018fc4:	2b00      	cmp	r3, #0
 8018fc6:	f43f ad85 	beq.w	8018ad4 <cblas_ctrsm+0x28c>
 8018fca:	e57e      	b.n	8018aca <cblas_ctrsm+0x282>
 8018fcc:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8018fd0:	2b01      	cmp	r3, #1
 8018fd2:	f8dd c000 	ldr.w	ip, [sp]
 8018fd6:	bf94      	ite	ls
 8018fd8:	2300      	movls	r3, #0
 8018fda:	2301      	movhi	r3, #1
 8018fdc:	e459      	b.n	8018892 <cblas_ctrsm+0x4a>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018fde:	eef5 7a40 	vcmp.f32	s15, #0.0
 8018fe2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018fe6:	f47f ae6a 	bne.w	8018cbe <cblas_ctrsm+0x476>
      for (i = 0; i < n1; i++) {
 8018fea:	9b00      	ldr	r3, [sp, #0]
 8018fec:	2b00      	cmp	r3, #0
 8018fee:	f77f af35 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8018ff2:	9b02      	ldr	r3, [sp, #8]
 8018ff4:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018ff8:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018ffc:	930e      	str	r3, [sp, #56]	; 0x38
 8018ffe:	e68d      	b.n	8018d1c <cblas_ctrsm+0x4d4>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8019000:	edd9 7a01 	vldr	s15, [r9, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8019004:	ed99 9a00 	vldr	s18, [r9]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8019008:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 801900c:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 8019010:	ee18 0a90 	vmov	r0, s17
 8019014:	f00f fd50 	bl	8028ab8 <__aeabi_f2d>
 8019018:	4602      	mov	r2, r0
 801901a:	460b      	mov	r3, r1
 801901c:	ee19 0a10 	vmov	r0, s18
 8019020:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8019024:	f00f fd48 	bl	8028ab8 <__aeabi_f2d>
 8019028:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801902c:	f7ff fbd4 	bl	80187d8 <xhypot>
 8019030:	f010 f84a 	bl	80290c8 <__aeabi_d2f>
 8019034:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 8019038:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 801903c:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 8019040:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 8019044:	f77f acf5 	ble.w	8018a32 <cblas_ctrsm+0x1ea>
 8019048:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801904a:	1d3a      	adds	r2, r7, #4
 801904c:	18f9      	adds	r1, r7, r3
 801904e:	463b      	mov	r3, r7
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019050:	3308      	adds	r3, #8
 8019052:	3208      	adds	r2, #8
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8019054:	ed53 6a01 	vldr	s13, [r3, #-4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019058:	ed12 6a03 	vldr	s12, [r2, #-12]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801905c:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019060:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8019064:	eea5 7a06 	vfma.f32	s14, s10, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019068:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801906c:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019070:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8019074:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019078:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 801907c:	428b      	cmp	r3, r1
 801907e:	d1e7      	bne.n	8019050 <cblas_ctrsm+0x808>
 8019080:	e4d7      	b.n	8018a32 <cblas_ctrsm+0x1ea>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8019082:	eef5 7a40 	vcmp.f32	s15, #0.0
 8019086:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801908a:	f47f ac7c 	bne.w	8018986 <cblas_ctrsm+0x13e>
      for (i = n1; i > 0 && i--;) {
 801908e:	9b00      	ldr	r3, [sp, #0]
 8019090:	2b00      	cmp	r3, #0
 8019092:	f77f aee3 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8019096:	9b02      	ldr	r3, [sp, #8]
 8019098:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801909c:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80190a0:	930e      	str	r3, [sp, #56]	; 0x38
 80190a2:	e49f      	b.n	80189e4 <cblas_ctrsm+0x19c>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80190a4:	eef5 7a40 	vcmp.f32	s15, #0.0
 80190a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80190ac:	f47f aef0 	bne.w	8018e90 <cblas_ctrsm+0x648>
      for (i = 0; i < n1; i++) {
 80190b0:	9b00      	ldr	r3, [sp, #0]
 80190b2:	2b00      	cmp	r3, #0
 80190b4:	f77f aed2 	ble.w	8018e5c <cblas_ctrsm+0x614>
 80190b8:	9b02      	ldr	r3, [sp, #8]
 80190ba:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80190be:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80190c2:	930e      	str	r3, [sp, #56]	; 0x38
 80190c4:	e712      	b.n	8018eec <cblas_ctrsm+0x6a4>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80190c6:	eef5 7a40 	vcmp.f32	s15, #0.0
 80190ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80190ce:	f47f ad24 	bne.w	8018b1a <cblas_ctrsm+0x2d2>
      for (i = 0; i < n1; i++) {
 80190d2:	9b00      	ldr	r3, [sp, #0]
 80190d4:	2b00      	cmp	r3, #0
 80190d6:	f77f aec1 	ble.w	8018e5c <cblas_ctrsm+0x614>
 80190da:	9b02      	ldr	r3, [sp, #8]
 80190dc:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80190e0:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80190e4:	930e      	str	r3, [sp, #56]	; 0x38
 80190e6:	e547      	b.n	8018b78 <cblas_ctrsm+0x330>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80190e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80190ec:	f040 8293 	bne.w	8019616 <cblas_ctrsm+0xdce>
 80190f0:	eef5 7a40 	vcmp.f32	s15, #0.0
 80190f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80190f8:	f040 828d 	bne.w	8019616 <cblas_ctrsm+0xdce>
      for (i = n1; i > 0 && i--;) {
 80190fc:	9b00      	ldr	r3, [sp, #0]
 80190fe:	2b00      	cmp	r3, #0
 8019100:	f77f aeac 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8019104:	9b02      	ldr	r3, [sp, #8]
 8019106:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801910a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801910e:	930e      	str	r3, [sp, #56]	; 0x38
 8019110:	9b02      	ldr	r3, [sp, #8]
 8019112:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8019114:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8019118:	9b00      	ldr	r3, [sp, #0]
 801911a:	1c75      	adds	r5, r6, #1
 801911c:	43f6      	mvns	r6, r6
 801911e:	1e5c      	subs	r4, r3, #1
 8019120:	00f3      	lsls	r3, r6, #3
 8019122:	9300      	str	r3, [sp, #0]
 8019124:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8019126:	00ed      	lsls	r5, r5, #3
 8019128:	fb05 3804 	mla	r8, r5, r4, r3
 801912c:	3308      	adds	r3, #8
 801912e:	9307      	str	r3, [sp, #28]
 8019130:	9b06      	ldr	r3, [sp, #24]
 8019132:	fb0a 3604 	mla	r6, sl, r4, r3
 8019136:	4413      	add	r3, r2
 8019138:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 801913c:	3d08      	subs	r5, #8
 801913e:	9302      	str	r3, [sp, #8]
        if (nonunit) {
 8019140:	9b04      	ldr	r3, [sp, #16]
 8019142:	2b83      	cmp	r3, #131	; 0x83
 8019144:	d044      	beq.n	80191d0 <cblas_ctrsm+0x988>
        for (k = 0; k < i; k++) {
 8019146:	2c00      	cmp	r4, #0
 8019148:	f43f ae88 	beq.w	8018e5c <cblas_ctrsm+0x614>
 801914c:	9b07      	ldr	r3, [sp, #28]
 801914e:	9802      	ldr	r0, [sp, #8]
 8019150:	f8dd c018 	ldr.w	ip, [sp, #24]
 8019154:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8019158:	eb03 07c4 	add.w	r7, r3, r4, lsl #3
 801915c:	f04f 0e00 	mov.w	lr, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8019160:	ed17 5a01 	vldr	s10, [r7, #-4]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8019164:	ed57 4a02 	vldr	s9, [r7, #-8]
          for (j = 0; j < n2; j++) {
 8019168:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 801916c:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 8019170:	dd22      	ble.n	80191b8 <cblas_ctrsm+0x970>
 8019172:	f10c 0104 	add.w	r1, ip, #4
 8019176:	4663      	mov	r3, ip
 8019178:	4632      	mov	r2, r6
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801917a:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 801917e:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8019182:	ed51 6a01 	vldr	s13, [r1, #-4]
 8019186:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 801918a:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 801918e:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8019192:	3308      	adds	r3, #8
 8019194:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8019196:	eee4 7a87 	vfma.f32	s15, s9, s14
 801919a:	3108      	adds	r1, #8
 801919c:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 80191a0:	ee76 7ac6 	vsub.f32	s15, s13, s12
 80191a4:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 80191a8:	ed53 7a01 	vldr	s15, [r3, #-4]
 80191ac:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80191b0:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80191b4:	4283      	cmp	r3, r0
 80191b6:	d1e0      	bne.n	801917a <cblas_ctrsm+0x932>
        for (k = 0; k < i; k++) {
 80191b8:	f10e 0e01 	add.w	lr, lr, #1
 80191bc:	4574      	cmp	r4, lr
 80191be:	442f      	add	r7, r5
 80191c0:	44d4      	add	ip, sl
 80191c2:	4450      	add	r0, sl
 80191c4:	d1cc      	bne.n	8019160 <cblas_ctrsm+0x918>
 80191c6:	9b00      	ldr	r3, [sp, #0]
 80191c8:	444e      	add	r6, r9
 80191ca:	4498      	add	r8, r3
 80191cc:	3c01      	subs	r4, #1
 80191ce:	e7b7      	b.n	8019140 <cblas_ctrsm+0x8f8>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80191d0:	edd8 7a01 	vldr	s15, [r8, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 80191d4:	ed98 9a00 	vldr	s18, [r8]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80191d8:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 80191dc:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 80191e0:	ee18 0a90 	vmov	r0, s17
 80191e4:	f00f fc68 	bl	8028ab8 <__aeabi_f2d>
 80191e8:	4602      	mov	r2, r0
 80191ea:	460b      	mov	r3, r1
 80191ec:	ee19 0a10 	vmov	r0, s18
 80191f0:	e9cd 2308 	strd	r2, r3, [sp, #32]
 80191f4:	f00f fc60 	bl	8028ab8 <__aeabi_f2d>
 80191f8:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80191fc:	f7ff faec 	bl	80187d8 <xhypot>
 8019200:	f00f ff62 	bl	80290c8 <__aeabi_d2f>
 8019204:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 8019208:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 801920c:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 8019210:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 8019214:	dd97      	ble.n	8019146 <cblas_ctrsm+0x8fe>
 8019216:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8019218:	1d32      	adds	r2, r6, #4
 801921a:	1999      	adds	r1, r3, r6
 801921c:	4633      	mov	r3, r6
            const BASE Bij_real = REAL(B, ldb * i + j);
 801921e:	3308      	adds	r3, #8
 8019220:	3208      	adds	r2, #8
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8019222:	ed53 6a01 	vldr	s13, [r3, #-4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019226:	ed12 6a03 	vldr	s12, [r2, #-12]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801922a:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801922e:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8019232:	eea5 7a06 	vfma.f32	s14, s10, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019236:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801923a:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801923e:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8019242:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019246:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 801924a:	4299      	cmp	r1, r3
 801924c:	d1e7      	bne.n	801921e <cblas_ctrsm+0x9d6>
 801924e:	e77a      	b.n	8019146 <cblas_ctrsm+0x8fe>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8019250:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019254:	f040 8257 	bne.w	8019706 <cblas_ctrsm+0xebe>
 8019258:	eef5 7a40 	vcmp.f32	s15, #0.0
 801925c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019260:	f040 8251 	bne.w	8019706 <cblas_ctrsm+0xebe>
      for (i = 0; i < n1; i++) {
 8019264:	9b00      	ldr	r3, [sp, #0]
 8019266:	2b00      	cmp	r3, #0
 8019268:	f77f adf8 	ble.w	8018e5c <cblas_ctrsm+0x614>
 801926c:	9b02      	ldr	r3, [sp, #8]
 801926e:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8019272:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8019276:	930e      	str	r3, [sp, #56]	; 0x38
 8019278:	990e      	ldr	r1, [sp, #56]	; 0x38
 801927a:	9a06      	ldr	r2, [sp, #24]
        for (i = 0; i < n1; i++) {
 801927c:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8019280:	9f00      	ldr	r7, [sp, #0]
 8019282:	3601      	adds	r6, #1
 8019284:	00f3      	lsls	r3, r6, #3
 8019286:	4608      	mov	r0, r1
 8019288:	990a      	ldr	r1, [sp, #40]	; 0x28
 801928a:	930c      	str	r3, [sp, #48]	; 0x30
 801928c:	f1a3 0904 	sub.w	r9, r3, #4
 8019290:	2600      	movs	r6, #0
 8019292:	4410      	add	r0, r2
 8019294:	4489      	add	r9, r1
 8019296:	f1a3 0508 	sub.w	r5, r3, #8
 801929a:	1d13      	adds	r3, r2, #4
 801929c:	960b      	str	r6, [sp, #44]	; 0x2c
 801929e:	900e      	str	r0, [sp, #56]	; 0x38
 80192a0:	9108      	str	r1, [sp, #32]
 80192a2:	4614      	mov	r4, r2
 80192a4:	930a      	str	r3, [sp, #40]	; 0x28
 80192a6:	f8cd 901c 	str.w	r9, [sp, #28]
        if (nonunit) {
 80192aa:	9b04      	ldr	r3, [sp, #16]
 80192ac:	2b83      	cmp	r3, #131	; 0x83
 80192ae:	f000 825a 	beq.w	8019766 <cblas_ctrsm+0xf1e>
        for (k = i + 1; k < n1; k++) {
 80192b2:	3601      	adds	r6, #1
 80192b4:	42b7      	cmp	r7, r6
 80192b6:	f77f add1 	ble.w	8018e5c <cblas_ctrsm+0x614>
 80192ba:	9b06      	ldr	r3, [sp, #24]
 80192bc:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80192c0:	eb03 0ec8 	add.w	lr, r3, r8, lsl #3
 80192c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80192c6:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 80192ca:	eb03 00c8 	add.w	r0, r3, r8, lsl #3
 80192ce:	46b1      	mov	r9, r6
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 80192d0:	ed9c 5a00 	vldr	s10, [ip]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 80192d4:	ed5c 4a01 	vldr	s9, [ip, #-4]
          for (j = 0; j < n2; j++) {
 80192d8:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 80192dc:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 80192e0:	dd22      	ble.n	8019328 <cblas_ctrsm+0xae0>
 80192e2:	f10e 0104 	add.w	r1, lr, #4
 80192e6:	4673      	mov	r3, lr
 80192e8:	4622      	mov	r2, r4
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80192ea:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80192ee:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 80192f2:	ed51 6a01 	vldr	s13, [r1, #-4]
 80192f6:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 80192fa:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 80192fe:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8019302:	3308      	adds	r3, #8
 8019304:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8019306:	eee4 7a87 	vfma.f32	s15, s9, s14
 801930a:	3108      	adds	r1, #8
 801930c:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8019310:	ee76 7ac6 	vsub.f32	s15, s13, s12
 8019314:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8019318:	ed53 7a01 	vldr	s15, [r3, #-4]
 801931c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8019320:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8019324:	4298      	cmp	r0, r3
 8019326:	d1e0      	bne.n	80192ea <cblas_ctrsm+0xaa2>
        for (k = i + 1; k < n1; k++) {
 8019328:	f109 0901 	add.w	r9, r9, #1
 801932c:	454f      	cmp	r7, r9
 801932e:	44d6      	add	lr, sl
 8019330:	4450      	add	r0, sl
 8019332:	44ac      	add	ip, r5
 8019334:	d1cc      	bne.n	80192d0 <cblas_ctrsm+0xa88>
 8019336:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8019338:	9b02      	ldr	r3, [sp, #8]
 801933a:	4611      	mov	r1, r2
 801933c:	9a07      	ldr	r2, [sp, #28]
 801933e:	4419      	add	r1, r3
 8019340:	910b      	str	r1, [sp, #44]	; 0x2c
 8019342:	4498      	add	r8, r3
 8019344:	4611      	mov	r1, r2
 8019346:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8019348:	9a08      	ldr	r2, [sp, #32]
 801934a:	4419      	add	r1, r3
 801934c:	441a      	add	r2, r3
 801934e:	4454      	add	r4, sl
 8019350:	9107      	str	r1, [sp, #28]
 8019352:	9208      	str	r2, [sp, #32]
 8019354:	e7a9      	b.n	80192aa <cblas_ctrsm+0xa62>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8019356:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801935a:	f040 827f 	bne.w	801985c <cblas_ctrsm+0x1014>
 801935e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8019362:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019366:	f040 8279 	bne.w	801985c <cblas_ctrsm+0x1014>
      for (i = 0; i < n1; i++) {
 801936a:	9b00      	ldr	r3, [sp, #0]
 801936c:	2b00      	cmp	r3, #0
 801936e:	f77f ad75 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8019372:	9b02      	ldr	r3, [sp, #8]
 8019374:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8019378:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801937c:	930e      	str	r3, [sp, #56]	; 0x38
 801937e:	9b06      	ldr	r3, [sp, #24]
 8019380:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8019382:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 8019386:	f1a3 0408 	sub.w	r4, r3, #8
 801938a:	3601      	adds	r6, #1
            for (k = j + 1; k < n2; k++) {
 801938c:	2300      	movs	r3, #0
 801938e:	f8dd a010 	ldr.w	sl, [sp, #16]
 8019392:	9307      	str	r3, [sp, #28]
 8019394:	00f7      	lsls	r7, r6, #3
 8019396:	4414      	add	r4, r2
 8019398:	9308      	str	r3, [sp, #32]
        for (j = 0; j < n2; j++) {
 801939a:	f1bb 0f00 	cmp.w	fp, #0
 801939e:	dd75      	ble.n	801948c <cblas_ctrsm+0xc44>
 80193a0:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 80193a4:	990a      	ldr	r1, [sp, #40]	; 0x28
          if (nonunit) {
 80193a6:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 80193aa:	4688      	mov	r8, r1
 80193ac:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 80193b0:	f101 0904 	add.w	r9, r1, #4
        for (j = 0; j < n2; j++) {
 80193b4:	f04f 0600 	mov.w	r6, #0
          if (nonunit) {
 80193b8:	d02f      	beq.n	801941a <cblas_ctrsm+0xbd2>
            for (k = j + 1; k < n2; k++) {
 80193ba:	3601      	adds	r6, #1
 80193bc:	45b3      	cmp	fp, r6
 80193be:	ed95 5a01 	vldr	s10, [r5, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80193c2:	edd5 4a00 	vldr	s9, [r5]
            for (k = j + 1; k < n2; k++) {
 80193c6:	d061      	beq.n	801948c <cblas_ctrsm+0xc44>
 80193c8:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 80193cc:	462b      	mov	r3, r5
 80193ce:	4642      	mov	r2, r8
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 80193d0:	edd2 7a03 	vldr	s15, [r2, #12]
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80193d4:	edd2 5a02 	vldr	s11, [r2, #8]
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80193d8:	ed93 6a02 	vldr	s12, [r3, #8]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 80193dc:	ed93 7a03 	vldr	s14, [r3, #12]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 80193e0:	ee64 7a27 	vmul.f32	s15, s8, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80193e4:	3308      	adds	r3, #8
 80193e6:	ee65 6a67 	vnmul.f32	s13, s10, s15
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 80193ea:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80193ee:	eee4 6aa5 	vfma.f32	s13, s9, s11
 80193f2:	3208      	adds	r2, #8
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 80193f4:	eee5 7a85 	vfma.f32	s15, s11, s10
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80193f8:	ee76 6a66 	vsub.f32	s13, s12, s13
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 80193fc:	ee77 7a67 	vsub.f32	s15, s14, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8019400:	edc3 6a00 	vstr	s13, [r3]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8019404:	edc3 7a01 	vstr	s15, [r3, #4]
            for (k = j + 1; k < n2; k++) {
 8019408:	429c      	cmp	r4, r3
 801940a:	d1e1      	bne.n	80193d0 <cblas_ctrsm+0xb88>
          if (nonunit) {
 801940c:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8019410:	44b8      	add	r8, r7
 8019412:	f105 0508 	add.w	r5, r5, #8
 8019416:	44b9      	add	r9, r7
 8019418:	d1cf      	bne.n	80193ba <cblas_ctrsm+0xb72>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 801941a:	edd9 7a00 	vldr	s15, [r9]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 801941e:	ed19 9a01 	vldr	s18, [r9, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8019422:	eef8 8ac8 	vcvt.f32.s32	s17, s16
            for (k = j + 1; k < n2; k++) {
 8019426:	3601      	adds	r6, #1
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8019428:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 801942c:	ee18 0a90 	vmov	r0, s17
 8019430:	f00f fb42 	bl	8028ab8 <__aeabi_f2d>
 8019434:	4602      	mov	r2, r0
 8019436:	460b      	mov	r3, r1
 8019438:	ee19 0a10 	vmov	r0, s18
 801943c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8019440:	f00f fb3a 	bl	8028ab8 <__aeabi_f2d>
 8019444:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8019448:	f7ff f9c6 	bl	80187d8 <xhypot>
 801944c:	f00f fe3c 	bl	80290c8 <__aeabi_d2f>
 8019450:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 8019454:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            for (k = j + 1; k < n2; k++) {
 8019458:	45b3      	cmp	fp, r6
            const BASE a_real = Ajj_real / s;
 801945a:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801945e:	ed95 6a01 	vldr	s12, [r5, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019462:	ed95 5a00 	vldr	s10, [r5]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8019466:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801946a:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801946e:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019472:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8019476:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801947a:	ee87 5a27 	vdiv.f32	s10, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801947e:	ed85 6a00 	vstr	s12, [r5]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019482:	edd5 4a00 	vldr	s9, [r5]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8019486:	ed85 5a01 	vstr	s10, [r5, #4]
            for (k = j + 1; k < n2; k++) {
 801948a:	d19d      	bne.n	80193c8 <cblas_ctrsm+0xb80>
      for (i = 0; i < n1; i++) {
 801948c:	9a07      	ldr	r2, [sp, #28]
 801948e:	9902      	ldr	r1, [sp, #8]
 8019490:	9b08      	ldr	r3, [sp, #32]
 8019492:	440a      	add	r2, r1
 8019494:	9207      	str	r2, [sp, #28]
 8019496:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8019498:	4414      	add	r4, r2
 801949a:	9a00      	ldr	r2, [sp, #0]
 801949c:	3301      	adds	r3, #1
 801949e:	429a      	cmp	r2, r3
 80194a0:	9308      	str	r3, [sp, #32]
 80194a2:	f73f af7a 	bgt.w	801939a <cblas_ctrsm+0xb52>
 80194a6:	e4d9      	b.n	8018e5c <cblas_ctrsm+0x614>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80194a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80194ac:	f040 81a6 	bne.w	80197fc <cblas_ctrsm+0xfb4>
 80194b0:	eef5 7a40 	vcmp.f32	s15, #0.0
 80194b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80194b8:	f040 81a0 	bne.w	80197fc <cblas_ctrsm+0xfb4>
      for (i = 0; i < n1; i++) {
 80194bc:	9b00      	ldr	r3, [sp, #0]
 80194be:	2b00      	cmp	r3, #0
 80194c0:	f77f accc 	ble.w	8018e5c <cblas_ctrsm+0x614>
 80194c4:	9b02      	ldr	r3, [sp, #8]
 80194c6:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80194ca:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80194ce:	930e      	str	r3, [sp, #56]	; 0x38
 80194d0:	990e      	ldr	r1, [sp, #56]	; 0x38
 80194d2:	f8cd a020 	str.w	sl, [sp, #32]
 80194d6:	3908      	subs	r1, #8
 80194d8:	f10b 33ff 	add.w	r3, fp, #4294967295
 80194dc:	910e      	str	r1, [sp, #56]	; 0x38
 80194de:	990a      	ldr	r1, [sp, #40]	; 0x28
 80194e0:	f8dd a010 	ldr.w	sl, [sp, #16]
 80194e4:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80194e8:	fb06 f203 	mul.w	r2, r6, r3
 80194ec:	fb06 3303 	mla	r3, r6, r3, r3
 80194f0:	ebc6 7946 	rsb	r9, r6, r6, lsl #29
 80194f4:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 80194f8:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 80194fc:	43f6      	mvns	r6, r6
 80194fe:	920a      	str	r2, [sp, #40]	; 0x28
 8019500:	930b      	str	r3, [sp, #44]	; 0x2c
        for (j = n2; j > 0 && j--;) {
 8019502:	2200      	movs	r2, #0
 8019504:	00f3      	lsls	r3, r6, #3
 8019506:	e9cd 2b06 	strd	r2, fp, [sp, #24]
 801950a:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 801950e:	469b      	mov	fp, r3
 8019510:	9d07      	ldr	r5, [sp, #28]
 8019512:	2d00      	cmp	r5, #0
 8019514:	dd75      	ble.n	8019602 <cblas_ctrsm+0xdba>
 8019516:	9b0e      	ldr	r3, [sp, #56]	; 0x38
          if (nonunit) {
 8019518:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
        for (j = n2; j > 0 && j--;) {
 801951c:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8019520:	eb03 0408 	add.w	r4, r3, r8
 8019524:	f105 35ff 	add.w	r5, r5, #4294967295
          if (nonunit) {
 8019528:	d033      	beq.n	8019592 <cblas_ctrsm+0xd4a>
            const BASE Bij_real = REAL(B, ldb * i + j);
 801952a:	edd4 5a01 	vldr	s11, [r4, #4]
 801952e:	ed94 5a00 	vldr	s10, [r4]
            for (k = 0; k < j; k++) {
 8019532:	2d00      	cmp	r5, #0
 8019534:	d065      	beq.n	8019602 <cblas_ctrsm+0xdba>
 8019536:	eef8 4ac8 	vcvt.f32.s32	s9, s16
 801953a:	f108 0104 	add.w	r1, r8, #4
 801953e:	4643      	mov	r3, r8
 8019540:	4632      	mov	r2, r6
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8019542:	edd2 7a01 	vldr	s15, [r2, #4]
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8019546:	ed92 6a00 	vldr	s12, [r2]
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 801954a:	ed51 6a01 	vldr	s13, [r1, #-4]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 801954e:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8019552:	3308      	adds	r3, #8
 8019554:	ee25 7ae7 	vnmul.f32	s14, s11, s15
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8019558:	ee65 7a27 	vmul.f32	s15, s10, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 801955c:	eea5 7a06 	vfma.f32	s14, s10, s12
 8019560:	3208      	adds	r2, #8
 8019562:	3108      	adds	r1, #8
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8019564:	eee6 7a25 	vfma.f32	s15, s12, s11
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8019568:	ee36 7ac7 	vsub.f32	s14, s13, s14
 801956c:	ed01 7a03 	vstr	s14, [r1, #-12]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8019570:	ed13 7a01 	vldr	s14, [r3, #-4]
 8019574:	ee77 7a67 	vsub.f32	s15, s14, s15
 8019578:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (k = 0; k < j; k++) {
 801957c:	42a3      	cmp	r3, r4
 801957e:	d1e0      	bne.n	8019542 <cblas_ctrsm+0xcfa>
          if (nonunit) {
 8019580:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8019584:	444e      	add	r6, r9
 8019586:	f1a4 0408 	sub.w	r4, r4, #8
 801958a:	445f      	add	r7, fp
        for (j = n2; j > 0 && j--;) {
 801958c:	f105 35ff 	add.w	r5, r5, #4294967295
          if (nonunit) {
 8019590:	d1cb      	bne.n	801952a <cblas_ctrsm+0xce2>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8019592:	edd7 7a01 	vldr	s15, [r7, #4]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8019596:	ed97 9a00 	vldr	s18, [r7]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 801959a:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 801959e:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 80195a2:	ee18 0a90 	vmov	r0, s17
 80195a6:	f00f fa87 	bl	8028ab8 <__aeabi_f2d>
 80195aa:	4602      	mov	r2, r0
 80195ac:	460b      	mov	r3, r1
 80195ae:	ee19 0a10 	vmov	r0, s18
 80195b2:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80195b6:	f00f fa7f 	bl	8028ab8 <__aeabi_f2d>
 80195ba:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80195be:	f7ff f90b 	bl	80187d8 <xhypot>
 80195c2:	f00f fd81 	bl	80290c8 <__aeabi_d2f>
 80195c6:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 80195ca:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            const BASE a_real = Ajj_real / s;
 80195ce:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80195d2:	ed94 6a01 	vldr	s12, [r4, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80195d6:	ed94 5a00 	vldr	s10, [r4]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80195da:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80195de:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80195e2:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80195e6:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80195ea:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80195ee:	eec7 5a27 	vdiv.f32	s11, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80195f2:	ed84 6a00 	vstr	s12, [r4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80195f6:	ed94 5a00 	vldr	s10, [r4]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80195fa:	edc4 5a01 	vstr	s11, [r4, #4]
            for (k = 0; k < j; k++) {
 80195fe:	2d00      	cmp	r5, #0
 8019600:	d199      	bne.n	8019536 <cblas_ctrsm+0xcee>
      for (i = 0; i < n1; i++) {
 8019602:	9a08      	ldr	r2, [sp, #32]
 8019604:	9b06      	ldr	r3, [sp, #24]
 8019606:	4490      	add	r8, r2
 8019608:	9a00      	ldr	r2, [sp, #0]
 801960a:	3301      	adds	r3, #1
 801960c:	429a      	cmp	r2, r3
 801960e:	9306      	str	r3, [sp, #24]
 8019610:	f73f af7e 	bgt.w	8019510 <cblas_ctrsm+0xcc8>
 8019614:	e422      	b.n	8018e5c <cblas_ctrsm+0x614>
        for (i = 0; i < n1; i++) {
 8019616:	9f00      	ldr	r7, [sp, #0]
 8019618:	2f00      	cmp	r7, #0
 801961a:	f77f ac1f 	ble.w	8018e5c <cblas_ctrsm+0x614>
 801961e:	9b02      	ldr	r3, [sp, #8]
 8019620:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8019624:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8019628:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 801962c:	930e      	str	r3, [sp, #56]	; 0x38
 801962e:	9b06      	ldr	r3, [sp, #24]
 8019630:	00e4      	lsls	r4, r4, #3
 8019632:	1d25      	adds	r5, r4, #4
 8019634:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8019638:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 801963a:	f1bb 0f00 	cmp.w	fp, #0
 801963e:	dd15      	ble.n	801966c <cblas_ctrsm+0xe24>
 8019640:	1863      	adds	r3, r4, r1
 8019642:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8019644:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019648:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801964c:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019650:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019654:	eea5 6a07 	vfma.f32	s12, s10, s14
 8019658:	3308      	adds	r3, #8
 801965a:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801965c:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019660:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019664:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8019668:	4299      	cmp	r1, r3
 801966a:	d1eb      	bne.n	8019644 <cblas_ctrsm+0xdfc>
        for (i = 0; i < n1; i++) {
 801966c:	3001      	adds	r0, #1
 801966e:	4287      	cmp	r7, r0
 8019670:	4451      	add	r1, sl
 8019672:	d1e2      	bne.n	801963a <cblas_ctrsm+0xdf2>
 8019674:	e54c      	b.n	8019110 <cblas_ctrsm+0x8c8>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8019676:	9b07      	ldr	r3, [sp, #28]
 8019678:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 801967c:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8019680:	ed93 9a00 	vldr	s18, [r3]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8019684:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 8019688:	ee18 0a90 	vmov	r0, s17
 801968c:	f00f fa14 	bl	8028ab8 <__aeabi_f2d>
 8019690:	4602      	mov	r2, r0
 8019692:	460b      	mov	r3, r1
 8019694:	ee19 0a10 	vmov	r0, s18
 8019698:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 801969c:	f00f fa0c 	bl	8028ab8 <__aeabi_f2d>
 80196a0:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80196a4:	f7ff f898 	bl	80187d8 <xhypot>
 80196a8:	f00f fd0e 	bl	80290c8 <__aeabi_d2f>
 80196ac:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 80196b0:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 80196b4:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 80196b8:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 80196bc:	f77f ac33 	ble.w	8018f26 <cblas_ctrsm+0x6de>
 80196c0:	9b06      	ldr	r3, [sp, #24]
 80196c2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80196c4:	eb0b 0109 	add.w	r1, fp, r9
 80196c8:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80196cc:	eb02 02c9 	add.w	r2, r2, r9, lsl #3
 80196d0:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
            const BASE Bij_real = REAL(B, ldb * i + j);
 80196d4:	3308      	adds	r3, #8
 80196d6:	3208      	adds	r2, #8
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80196d8:	ed53 6a01 	vldr	s13, [r3, #-4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80196dc:	ed12 6a03 	vldr	s12, [r2, #-12]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80196e0:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80196e4:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80196e8:	eea5 7a06 	vfma.f32	s14, s10, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80196ec:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80196f0:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80196f4:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80196f8:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80196fc:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8019700:	4299      	cmp	r1, r3
 8019702:	d1e7      	bne.n	80196d4 <cblas_ctrsm+0xe8c>
 8019704:	e40f      	b.n	8018f26 <cblas_ctrsm+0x6de>
        for (i = 0; i < n1; i++) {
 8019706:	9f00      	ldr	r7, [sp, #0]
 8019708:	2f00      	cmp	r7, #0
 801970a:	f77f aba7 	ble.w	8018e5c <cblas_ctrsm+0x614>
 801970e:	9b02      	ldr	r3, [sp, #8]
 8019710:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8019714:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8019718:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 801971c:	930e      	str	r3, [sp, #56]	; 0x38
 801971e:	9b06      	ldr	r3, [sp, #24]
 8019720:	00e4      	lsls	r4, r4, #3
 8019722:	1d25      	adds	r5, r4, #4
 8019724:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8019728:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 801972a:	f1bb 0f00 	cmp.w	fp, #0
 801972e:	dd15      	ble.n	801975c <cblas_ctrsm+0xf14>
 8019730:	1863      	adds	r3, r4, r1
 8019732:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8019734:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8019738:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801973c:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019740:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019744:	eea5 6a07 	vfma.f32	s12, s10, s14
 8019748:	3308      	adds	r3, #8
 801974a:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801974c:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019750:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019754:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8019758:	4299      	cmp	r1, r3
 801975a:	d1eb      	bne.n	8019734 <cblas_ctrsm+0xeec>
        for (i = 0; i < n1; i++) {
 801975c:	3001      	adds	r0, #1
 801975e:	4287      	cmp	r7, r0
 8019760:	4451      	add	r1, sl
 8019762:	d1e2      	bne.n	801972a <cblas_ctrsm+0xee2>
 8019764:	e588      	b.n	8019278 <cblas_ctrsm+0xa30>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8019766:	9b08      	ldr	r3, [sp, #32]
 8019768:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 801976c:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8019770:	ed93 9a00 	vldr	s18, [r3]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8019774:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 8019778:	ee18 0a90 	vmov	r0, s17
 801977c:	f00f f99c 	bl	8028ab8 <__aeabi_f2d>
 8019780:	4602      	mov	r2, r0
 8019782:	460b      	mov	r3, r1
 8019784:	ee19 0a10 	vmov	r0, s18
 8019788:	e9cd 2300 	strd	r2, r3, [sp]
 801978c:	f00f f994 	bl	8028ab8 <__aeabi_f2d>
 8019790:	e9dd 2300 	ldrd	r2, r3, [sp]
 8019794:	f7ff f820 	bl	80187d8 <xhypot>
 8019798:	f00f fc96 	bl	80290c8 <__aeabi_d2f>
 801979c:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 80197a0:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 80197a4:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 80197a8:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 80197ac:	f77f ad81 	ble.w	80192b2 <cblas_ctrsm+0xa6a>
 80197b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80197b2:	9a06      	ldr	r2, [sp, #24]
 80197b4:	eb0b 0103 	add.w	r1, fp, r3
 80197b8:	4610      	mov	r0, r2
 80197ba:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
 80197be:	461a      	mov	r2, r3
 80197c0:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 80197c4:	980a      	ldr	r0, [sp, #40]	; 0x28
 80197c6:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80197ca:	edd3 6a01 	vldr	s13, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80197ce:	ed12 6a01 	vldr	s12, [r2, #-4]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80197d2:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80197d6:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80197da:	eea5 7a06 	vfma.f32	s14, s10, s12
 80197de:	3308      	adds	r3, #8
 80197e0:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80197e2:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80197e6:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80197ea:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80197ee:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80197f2:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80197f6:	4299      	cmp	r1, r3
 80197f8:	d1e7      	bne.n	80197ca <cblas_ctrsm+0xf82>
 80197fa:	e55a      	b.n	80192b2 <cblas_ctrsm+0xa6a>
        for (i = 0; i < n1; i++) {
 80197fc:	9f00      	ldr	r7, [sp, #0]
 80197fe:	2f00      	cmp	r7, #0
 8019800:	f77f ab2c 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8019804:	9b02      	ldr	r3, [sp, #8]
 8019806:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801980a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801980e:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8019812:	930e      	str	r3, [sp, #56]	; 0x38
 8019814:	9b06      	ldr	r3, [sp, #24]
 8019816:	00e4      	lsls	r4, r4, #3
 8019818:	1d25      	adds	r5, r4, #4
 801981a:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 801981e:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8019820:	f1bb 0f00 	cmp.w	fp, #0
 8019824:	dd15      	ble.n	8019852 <cblas_ctrsm+0x100a>
 8019826:	190b      	adds	r3, r1, r4
 8019828:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801982a:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 801982e:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019832:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019836:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801983a:	eea5 6a07 	vfma.f32	s12, s10, s14
 801983e:	3308      	adds	r3, #8
 8019840:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019842:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019846:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801984a:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 801984e:	428b      	cmp	r3, r1
 8019850:	d1eb      	bne.n	801982a <cblas_ctrsm+0xfe2>
        for (i = 0; i < n1; i++) {
 8019852:	3001      	adds	r0, #1
 8019854:	4287      	cmp	r7, r0
 8019856:	4451      	add	r1, sl
 8019858:	d1e2      	bne.n	8019820 <cblas_ctrsm+0xfd8>
 801985a:	e639      	b.n	80194d0 <cblas_ctrsm+0xc88>
        for (i = 0; i < n1; i++) {
 801985c:	9f00      	ldr	r7, [sp, #0]
 801985e:	2f00      	cmp	r7, #0
 8019860:	f77f aafc 	ble.w	8018e5c <cblas_ctrsm+0x614>
 8019864:	9b02      	ldr	r3, [sp, #8]
 8019866:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801986a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801986e:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8019872:	930e      	str	r3, [sp, #56]	; 0x38
 8019874:	9b06      	ldr	r3, [sp, #24]
 8019876:	00e4      	lsls	r4, r4, #3
 8019878:	1d25      	adds	r5, r4, #4
 801987a:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 801987e:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8019880:	f1bb 0f00 	cmp.w	fp, #0
 8019884:	dd15      	ble.n	80198b2 <cblas_ctrsm+0x106a>
 8019886:	190b      	adds	r3, r1, r4
 8019888:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801988a:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 801988e:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8019892:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8019896:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801989a:	eea5 6a07 	vfma.f32	s12, s10, s14
 801989e:	3308      	adds	r3, #8
 80198a0:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80198a2:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80198a6:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80198aa:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80198ae:	428b      	cmp	r3, r1
 80198b0:	d1eb      	bne.n	801988a <cblas_ctrsm+0x1042>
        for (i = 0; i < n1; i++) {
 80198b2:	3001      	adds	r0, #1
 80198b4:	4287      	cmp	r7, r0
 80198b6:	4451      	add	r1, sl
 80198b8:	d1e2      	bne.n	8019880 <cblas_ctrsm+0x1038>
 80198ba:	e560      	b.n	801937e <cblas_ctrsm+0xb36>

080198bc <xhypot>:
{
 80198bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 80198be:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 80198c2:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  if (xabs < yabs) {
 80198c6:	4639      	mov	r1, r7
 80198c8:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 80198ca:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 80198cc:	4614      	mov	r4, r2
  if (xabs < yabs) {
 80198ce:	f00f fbbd 	bl	802904c <__aeabi_dcmplt>
 80198d2:	b928      	cbnz	r0, 80198e0 <xhypot+0x24>
 80198d4:	4632      	mov	r2, r6
 80198d6:	463b      	mov	r3, r7
    min = yabs ;
 80198d8:	4626      	mov	r6, r4
 80198da:	462f      	mov	r7, r5
    max = xabs ;
 80198dc:	4614      	mov	r4, r2
 80198de:	461d      	mov	r5, r3
  if (min == 0) 
 80198e0:	2200      	movs	r2, #0
 80198e2:	2300      	movs	r3, #0
 80198e4:	4630      	mov	r0, r6
 80198e6:	4639      	mov	r1, r7
 80198e8:	f00f fba6 	bl	8029038 <__aeabi_dcmpeq>
 80198ec:	b9c8      	cbnz	r0, 8019922 <xhypot+0x66>
    double u = min / max ;
 80198ee:	4622      	mov	r2, r4
 80198f0:	462b      	mov	r3, r5
 80198f2:	4630      	mov	r0, r6
 80198f4:	4639      	mov	r1, r7
 80198f6:	f00f fa61 	bl	8028dbc <__aeabi_ddiv>
 80198fa:	4602      	mov	r2, r0
 80198fc:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 80198fe:	f00f f933 	bl	8028b68 <__aeabi_dmul>
 8019902:	4b09      	ldr	r3, [pc, #36]	; (8019928 <xhypot+0x6c>)
 8019904:	2200      	movs	r2, #0
 8019906:	f00e ff79 	bl	80287fc <__adddf3>
 801990a:	ec41 0b10 	vmov	d0, r0, r1
 801990e:	f017 f981 	bl	8030c14 <sqrt>
 8019912:	4620      	mov	r0, r4
 8019914:	4629      	mov	r1, r5
 8019916:	ec53 2b10 	vmov	r2, r3, d0
 801991a:	f00f f925 	bl	8028b68 <__aeabi_dmul>
 801991e:	4604      	mov	r4, r0
 8019920:	460d      	mov	r5, r1
}
 8019922:	4620      	mov	r0, r4
 8019924:	4629      	mov	r1, r5
 8019926:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8019928:	3ff00000 	.word	0x3ff00000

0801992c <cblas_ctrsv>:
void
cblas_ctrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 801992c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019930:	ed2d 8b06 	vpush	{d8-d10}
 8019934:	b089      	sub	sp, #36	; 0x24
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8019936:	2a71      	cmp	r2, #113	; 0x71
 8019938:	9302      	str	r3, [sp, #8]
 801993a:	e9dd b318 	ldrd	fp, r3, [sp, #96]	; 0x60
 801993e:	9300      	str	r3, [sp, #0]
 8019940:	e9dd 731a 	ldrd	r7, r3, [sp, #104]	; 0x68
 8019944:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 8019946:	9303      	str	r3, [sp, #12]
 8019948:	4681      	mov	r9, r0
 801994a:	4688      	mov	r8, r1
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
  const int nonunit = (Diag == CblasNonUnit);
  INDEX i, j;
  INDEX ix, jx;

  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 801994c:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8019950:	f000 8120 	beq.w	8019b94 <cblas_ctrsv+0x268>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019954:	2b01      	cmp	r3, #1
 8019956:	4692      	mov	sl, r2
 8019958:	d942      	bls.n	80199e0 <cblas_ctrsv+0xb4>
 801995a:	2002      	movs	r0, #2
 801995c:	3a6f      	subs	r2, #111	; 0x6f
 801995e:	2a02      	cmp	r2, #2
 8019960:	ed9f 8ad4 	vldr	s16, [pc, #848]	; 8019cb4 <cblas_ctrsv+0x388>
 8019964:	bf88      	it	hi
 8019966:	2003      	movhi	r0, #3
 8019968:	9b02      	ldr	r3, [sp, #8]
 801996a:	337d      	adds	r3, #125	; 0x7d
 801996c:	b2db      	uxtb	r3, r3
 801996e:	2b01      	cmp	r3, #1
 8019970:	f240 80ff 	bls.w	8019b72 <cblas_ctrsv+0x246>
 8019974:	f1bb 0f00 	cmp.w	fp, #0
 8019978:	f2c0 80f3 	blt.w	8019b62 <cblas_ctrsv+0x236>
 801997c:	465b      	mov	r3, fp
 801997e:	2b01      	cmp	r3, #1
 8019980:	bfb8      	it	lt
 8019982:	2301      	movlt	r3, #1
 8019984:	42bb      	cmp	r3, r7
 8019986:	f340 818f 	ble.w	8019ca8 <cblas_ctrsv+0x37c>
 801998a:	2c00      	cmp	r4, #0
 801998c:	bf0c      	ite	eq
 801998e:	2009      	moveq	r0, #9
 8019990:	2007      	movne	r0, #7
 8019992:	4ac9      	ldr	r2, [pc, #804]	; (8019cb8 <cblas_ctrsv+0x38c>)
 8019994:	49c9      	ldr	r1, [pc, #804]	; (8019cbc <cblas_ctrsv+0x390>)
 8019996:	f00e feb7 	bl	8028708 <cblas_xerbla>

  if (N == 0)
 801999a:	f1bb 0f00 	cmp.w	fp, #0
 801999e:	f000 80db 	beq.w	8019b58 <cblas_ctrsv+0x22c>
    return;

  /* form  x := inv( A )*x */

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80199a2:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 80199a6:	f000 80fe 	beq.w	8019ba6 <cblas_ctrsv+0x27a>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80199aa:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 80199ae:	d10d      	bne.n	80199cc <cblas_ctrsv+0xa0>
 80199b0:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 80199b4:	d01a      	beq.n	80199ec <cblas_ctrsv+0xc0>
        IMAG(X, ix) = tmp_imag;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80199b6:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 80199ba:	d107      	bne.n	80199cc <cblas_ctrsv+0xa0>
 80199bc:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 80199c0:	f000 81ec 	beq.w	8019d9c <cblas_ctrsv+0x470>
        IMAG(X, ix) = tmp_imag;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 80199c4:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80199c8:	f000 80fd 	beq.w	8019bc6 <cblas_ctrsv+0x29a>
        IMAG(X, ix) = tmp_imag;
      }
      ix -= incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 80199cc:	4abc      	ldr	r2, [pc, #752]	; (8019cc0 <cblas_ctrsv+0x394>)
 80199ce:	49bb      	ldr	r1, [pc, #748]	; (8019cbc <cblas_ctrsv+0x390>)
 80199d0:	2000      	movs	r0, #0
#define BASE float
#include "source_trsv_c.h"
#undef BASE
}
 80199d2:	b009      	add	sp, #36	; 0x24
 80199d4:	ecbd 8b06 	vpop	{d8-d10}
 80199d8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80199dc:	f00e be94 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80199e0:	3865      	subs	r0, #101	; 0x65
 80199e2:	2801      	cmp	r0, #1
 80199e4:	bf94      	ite	ls
 80199e6:	2000      	movls	r0, #0
 80199e8:	2001      	movhi	r0, #1
 80199ea:	e7b7      	b.n	801995c <cblas_ctrsv+0x30>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80199ec:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 80199f0:	f040 81c5 	bne.w	8019d7e <cblas_ctrsv+0x452>
    ix = OFFSET(N, incX) + incX * (N - 1);
 80199f4:	2c00      	cmp	r4, #0
    if (nonunit) {
 80199f6:	9b02      	ldr	r3, [sp, #8]
    ix = OFFSET(N, incX) + incX * (N - 1);
 80199f8:	bfd8      	it	le
 80199fa:	f1c4 0800 	rsble	r8, r4, #0
 80199fe:	f10b 39ff 	add.w	r9, fp, #4294967295
 8019a02:	bfcc      	ite	gt
 8019a04:	f04f 0800 	movgt.w	r8, #0
 8019a08:	fb09 f808 	mulle.w	r8, r9, r8
    if (nonunit) {
 8019a0c:	2b83      	cmp	r3, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 8019a0e:	fb09 8804 	mla	r8, r9, r4, r8
    if (nonunit) {
 8019a12:	d13f      	bne.n	8019a94 <cblas_ctrsv+0x168>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019a14:	9a00      	ldr	r2, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8019a16:	9e03      	ldr	r6, [sp, #12]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019a18:	fb09 9307 	mla	r3, r9, r7, r9
 8019a1c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8019a20:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019a24:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8019a28:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 8019a2c:	eb06 03c8 	add.w	r3, r6, r8, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8019a30:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 8019a34:	3304      	adds	r3, #4
      const BASE s = xhypot(a_real, a_imag);
 8019a36:	ee18 0a90 	vmov	r0, s17
      const BASE x_imag = IMAG(X, ix);
 8019a3a:	461d      	mov	r5, r3
      const BASE s = xhypot(a_real, a_imag);
 8019a3c:	f00f f83c 	bl	8028ab8 <__aeabi_f2d>
 8019a40:	4602      	mov	r2, r0
 8019a42:	460b      	mov	r3, r1
 8019a44:	ee1a 0a10 	vmov	r0, s20
 8019a48:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 8019a4c:	eb06 0ac8 	add.w	sl, r6, r8, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 8019a50:	f00f f832 	bl	8028ab8 <__aeabi_f2d>
 8019a54:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 8019a58:	ed95 9a00 	vldr	s18, [r5]
      const BASE x_real = REAL(X, ix);
 8019a5c:	edda 9a00 	vldr	s19, [sl]
      const BASE s = xhypot(a_real, a_imag);
 8019a60:	f7ff ff2c 	bl	80198bc <xhypot>
 8019a64:	f00f fb30 	bl	80290c8 <__aeabi_d2f>
 8019a68:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 8019a6c:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 8019a70:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019a74:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019a78:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019a7c:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019a80:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019a84:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019a88:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019a8c:	ed8a 6a00 	vstr	s12, [sl]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019a90:	edc5 6a00 	vstr	s13, [r5]
    for (i = N - 1; i > 0 && i--;) {
 8019a94:	f1b9 0f00 	cmp.w	r9, #0
    ix -= incX;
 8019a98:	eba8 0804 	sub.w	r8, r8, r4
    for (i = N - 1; i > 0 && i--;) {
 8019a9c:	dd5c      	ble.n	8019b58 <cblas_ctrsv+0x22c>
 8019a9e:	f109 33ff 	add.w	r3, r9, #4294967295
 8019aa2:	fb07 f103 	mul.w	r1, r7, r3
 8019aa6:	fb07 3303 	mla	r3, r7, r3, r3
 8019aaa:	00db      	lsls	r3, r3, #3
 8019aac:	eb01 0209 	add.w	r2, r1, r9
 8019ab0:	9306      	str	r3, [sp, #24]
 8019ab2:	9b00      	ldr	r3, [sp, #0]
 8019ab4:	9803      	ldr	r0, [sp, #12]
 8019ab6:	eb0b 0601 	add.w	r6, fp, r1
 8019aba:	ebc2 7c42 	rsb	ip, r2, r2, lsl #29
 8019abe:	ebc4 7144 	rsb	r1, r4, r4, lsl #29
 8019ac2:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 8019ac6:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 8019aca:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8019ace:	00e4      	lsls	r4, r4, #3
 8019ad0:	9307      	str	r3, [sp, #28]
 8019ad2:	00cb      	lsls	r3, r1, #3
 8019ad4:	eb00 08c8 	add.w	r8, r0, r8, lsl #3
 8019ad8:	9300      	str	r3, [sp, #0]
 8019ada:	43f8      	mvns	r0, r7
 8019adc:	1f23      	subs	r3, r4, #4
 8019ade:	ebc7 7747 	rsb	r7, r7, r7, lsl #29
 8019ae2:	f108 0804 	add.w	r8, r8, #4
 8019ae6:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
 8019aea:	00ff      	lsls	r7, r7, #3
 8019aec:	9303      	str	r3, [sp, #12]
      for (j = i + 1; j < N; j++) {
 8019aee:	45cb      	cmp	fp, r9
      BASE tmp_real = REAL(X, ix);
 8019af0:	ed58 8a01 	vldr	s17, [r8, #-4]
      BASE tmp_imag = IMAG(X, ix);
 8019af4:	ed98 9a00 	vldr	s18, [r8]
      for (j = i + 1; j < N; j++) {
 8019af8:	dd1f      	ble.n	8019b3a <cblas_ctrsv+0x20e>
 8019afa:	9b03      	ldr	r3, [sp, #12]
 8019afc:	eeb8 5ac8 	vcvt.f32.s32	s10, s16
 8019b00:	eb03 0208 	add.w	r2, r3, r8
 8019b04:	462b      	mov	r3, r5
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8019b06:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_imag = IMAG(X, jx);
 8019b0a:	edd2 6a01 	vldr	s13, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8019b0e:	edd2 5a00 	vldr	s11, [r2]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8019b12:	ed93 6a00 	vldr	s12, [r3]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8019b16:	ee65 7a27 	vmul.f32	s15, s10, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019b1a:	3308      	adds	r3, #8
 8019b1c:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019b20:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019b24:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = i + 1; j < N; j++) {
 8019b28:	429e      	cmp	r6, r3
 8019b2a:	4422      	add	r2, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019b2c:	eee6 7a26 	vfma.f32	s15, s12, s13
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019b30:	ee78 8ac7 	vsub.f32	s17, s17, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019b34:	ee39 9a67 	vsub.f32	s18, s18, s15
      for (j = i + 1; j < N; j++) {
 8019b38:	d1e5      	bne.n	8019b06 <cblas_ctrsv+0x1da>
      if (nonunit) {
 8019b3a:	9b02      	ldr	r3, [sp, #8]
 8019b3c:	2b83      	cmp	r3, #131	; 0x83
 8019b3e:	f000 8180 	beq.w	8019e42 <cblas_ctrsv+0x516>
        REAL(X, ix) = tmp_real;
 8019b42:	ed48 8a01 	vstr	s17, [r8, #-4]
        IMAG(X, ix) = tmp_imag;
 8019b46:	ed88 9a00 	vstr	s18, [r8]
    for (i = N - 1; i > 0 && i--;) {
 8019b4a:	9b00      	ldr	r3, [sp, #0]
 8019b4c:	f1b9 0901 	subs.w	r9, r9, #1
 8019b50:	4455      	add	r5, sl
 8019b52:	443e      	add	r6, r7
 8019b54:	4498      	add	r8, r3
 8019b56:	d1ca      	bne.n	8019aee <cblas_ctrsv+0x1c2>
 8019b58:	b009      	add	sp, #36	; 0x24
 8019b5a:	ecbd 8b06 	vpop	{d8-d10}
 8019b5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019b62:	2f00      	cmp	r7, #0
 8019b64:	f77f af11 	ble.w	801998a <cblas_ctrsv+0x5e>
 8019b68:	2c00      	cmp	r4, #0
 8019b6a:	bf0c      	ite	eq
 8019b6c:	2009      	moveq	r0, #9
 8019b6e:	2005      	movne	r0, #5
 8019b70:	e70f      	b.n	8019992 <cblas_ctrsv+0x66>
 8019b72:	f1bb 0f00 	cmp.w	fp, #0
 8019b76:	dbf4      	blt.n	8019b62 <cblas_ctrsv+0x236>
 8019b78:	465b      	mov	r3, fp
 8019b7a:	2b01      	cmp	r3, #1
 8019b7c:	bfb8      	it	lt
 8019b7e:	2301      	movlt	r3, #1
 8019b80:	42bb      	cmp	r3, r7
 8019b82:	f73f af02 	bgt.w	801998a <cblas_ctrsv+0x5e>
 8019b86:	2c00      	cmp	r4, #0
 8019b88:	f000 8223 	beq.w	8019fd2 <cblas_ctrsv+0x6a6>
 8019b8c:	2800      	cmp	r0, #0
 8019b8e:	f43f af04 	beq.w	801999a <cblas_ctrsv+0x6e>
 8019b92:	e6fe      	b.n	8019992 <cblas_ctrsv+0x66>
 8019b94:	2b01      	cmp	r3, #1
 8019b96:	f240 80f7 	bls.w	8019d88 <cblas_ctrsv+0x45c>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8019b9a:	ed9f 8a4a 	vldr	s16, [pc, #296]	; 8019cc4 <cblas_ctrsv+0x398>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019b9e:	f04f 0a70 	mov.w	sl, #112	; 0x70
 8019ba2:	2002      	movs	r0, #2
 8019ba4:	e6e0      	b.n	8019968 <cblas_ctrsv+0x3c>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8019ba6:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8019baa:	f000 808d 	beq.w	8019cc8 <cblas_ctrsv+0x39c>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8019bae:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 8019bb2:	f47f af0b 	bne.w	80199cc <cblas_ctrsv+0xa0>
 8019bb6:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8019bba:	f000 80ef 	beq.w	8019d9c <cblas_ctrsv+0x470>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8019bbe:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8019bc2:	f47f af03 	bne.w	80199cc <cblas_ctrsv+0xa0>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8019bc6:	2c00      	cmp	r4, #0
    if (nonunit) {
 8019bc8:	9b02      	ldr	r3, [sp, #8]
    ix = OFFSET(N, incX) + incX * (N - 1);
 8019bca:	bfd8      	it	le
 8019bcc:	f1c4 0800 	rsble	r8, r4, #0
 8019bd0:	f10b 3aff 	add.w	sl, fp, #4294967295
 8019bd4:	bfcc      	ite	gt
 8019bd6:	f04f 0800 	movgt.w	r8, #0
 8019bda:	fb0a f808 	mulle.w	r8, sl, r8
    if (nonunit) {
 8019bde:	2b83      	cmp	r3, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 8019be0:	fb0a 8804 	mla	r8, sl, r4, r8
    if (nonunit) {
 8019be4:	f000 8205 	beq.w	8019ff2 <cblas_ctrsv+0x6c6>
    for (i = N - 1; i > 0 && i--;) {
 8019be8:	f1ba 0f00 	cmp.w	sl, #0
    ix -= incX;
 8019bec:	eba8 0804 	sub.w	r8, r8, r4
    for (i = N - 1; i > 0 && i--;) {
 8019bf0:	ddb2      	ble.n	8019b58 <cblas_ctrsv+0x22c>
 8019bf2:	1c7b      	adds	r3, r7, #1
 8019bf4:	fb03 f20a 	mul.w	r2, r3, sl
 8019bf8:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8019bfc:	00d2      	lsls	r2, r2, #3
 8019bfe:	9903      	ldr	r1, [sp, #12]
 8019c00:	9207      	str	r2, [sp, #28]
 8019c02:	9a00      	ldr	r2, [sp, #0]
 8019c04:	00db      	lsls	r3, r3, #3
 8019c06:	ea6f 0907 	mvn.w	r9, r7
 8019c0a:	f10a 37ff 	add.w	r7, sl, #4294967295
 8019c0e:	eb01 08c8 	add.w	r8, r1, r8, lsl #3
 8019c12:	fb0a 2503 	mla	r5, sl, r3, r2
 8019c16:	ebc4 7144 	rsb	r1, r4, r4, lsl #29
 8019c1a:	f1a3 0608 	sub.w	r6, r3, #8
 8019c1e:	fb03 f307 	mul.w	r3, r3, r7
 8019c22:	00e4      	lsls	r4, r4, #3
 8019c24:	9306      	str	r3, [sp, #24]
 8019c26:	00cb      	lsls	r3, r1, #3
 8019c28:	9300      	str	r3, [sp, #0]
 8019c2a:	1f23      	subs	r3, r4, #4
 8019c2c:	f108 0804 	add.w	r8, r8, #4
 8019c30:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8019c34:	9303      	str	r3, [sp, #12]
 8019c36:	4651      	mov	r1, sl
      for (j = i + 1; j < N; j++) {
 8019c38:	458b      	cmp	fp, r1
      BASE tmp_real = REAL(X, ix);
 8019c3a:	ed58 8a01 	vldr	s17, [r8, #-4]
      BASE tmp_imag = IMAG(X, ix);
 8019c3e:	ed98 9a00 	vldr	s18, [r8]
    for (i = N - 1; i > 0 && i--;) {
 8019c42:	46ba      	mov	sl, r7
      for (j = i + 1; j < N; j++) {
 8019c44:	dd20      	ble.n	8019c88 <cblas_ctrsv+0x35c>
 8019c46:	9b03      	ldr	r3, [sp, #12]
 8019c48:	eeb8 5ac8 	vcvt.f32.s32	s10, s16
 8019c4c:	eb03 0208 	add.w	r2, r3, r8
 8019c50:	462b      	mov	r3, r5
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8019c52:	ed53 7a01 	vldr	s15, [r3, #-4]
        const BASE x_imag = IMAG(X, jx);
 8019c56:	edd2 6a01 	vldr	s13, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8019c5a:	edd2 5a00 	vldr	s11, [r2]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8019c5e:	ed13 6a02 	vldr	s12, [r3, #-8]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8019c62:	ee65 7a27 	vmul.f32	s15, s10, s15
      for (j = i + 1; j < N; j++) {
 8019c66:	3101      	adds	r1, #1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019c68:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019c6c:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019c70:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = i + 1; j < N; j++) {
 8019c74:	458b      	cmp	fp, r1
 8019c76:	4422      	add	r2, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019c78:	eee6 7a26 	vfma.f32	s15, s12, s13
 8019c7c:	4433      	add	r3, r6
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019c7e:	ee78 8ac7 	vsub.f32	s17, s17, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019c82:	ee39 9a67 	vsub.f32	s18, s18, s15
      for (j = i + 1; j < N; j++) {
 8019c86:	d1e4      	bne.n	8019c52 <cblas_ctrsv+0x326>
      if (nonunit) {
 8019c88:	9b02      	ldr	r3, [sp, #8]
 8019c8a:	2b83      	cmp	r3, #131	; 0x83
 8019c8c:	f000 810e 	beq.w	8019eac <cblas_ctrsv+0x580>
        REAL(X, ix) = tmp_real;
 8019c90:	ed48 8a01 	vstr	s17, [r8, #-4]
        IMAG(X, ix) = tmp_imag;
 8019c94:	ed88 9a00 	vstr	s18, [r8]
    for (i = N - 1; i > 0 && i--;) {
 8019c98:	9b00      	ldr	r3, [sp, #0]
 8019c9a:	444d      	add	r5, r9
 8019c9c:	4498      	add	r8, r3
 8019c9e:	2f00      	cmp	r7, #0
 8019ca0:	f43f af5a 	beq.w	8019b58 <cblas_ctrsv+0x22c>
 8019ca4:	3f01      	subs	r7, #1
 8019ca6:	e7c6      	b.n	8019c36 <cblas_ctrsv+0x30a>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019ca8:	2c00      	cmp	r4, #0
 8019caa:	bf0c      	ite	eq
 8019cac:	2009      	moveq	r0, #9
 8019cae:	2004      	movne	r0, #4
 8019cb0:	e66f      	b.n	8019992 <cblas_ctrsv+0x66>
 8019cb2:	bf00      	nop
 8019cb4:	00000001 	.word	0x00000001
 8019cb8:	08031108 	.word	0x08031108
 8019cbc:	080313c4 	.word	0x080313c4
 8019cc0:	080311b8 	.word	0x080311b8
 8019cc4:	ffffffff 	.word	0xffffffff
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8019cc8:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8019ccc:	f43f ae92 	beq.w	80199f4 <cblas_ctrsv+0xc8>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 8019cd0:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8019cd4:	f47f ae7a 	bne.w	80199cc <cblas_ctrsv+0xa0>
    ix = OFFSET(N, incX);
 8019cd8:	2c00      	cmp	r4, #0
 8019cda:	f340 817c 	ble.w	8019fd6 <cblas_ctrsv+0x6aa>
 8019cde:	46a1      	mov	r9, r4
 8019ce0:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 8019ce4:	9b02      	ldr	r3, [sp, #8]
 8019ce6:	2b83      	cmp	r3, #131	; 0x83
 8019ce8:	f000 81c3 	beq.w	801a072 <cblas_ctrsv+0x746>
    for (i = 1; i < N; i++) {
 8019cec:	f1bb 0f01 	cmp.w	fp, #1
 8019cf0:	f77f af32 	ble.w	8019b58 <cblas_ctrsv+0x22c>
 8019cf4:	9a03      	ldr	r2, [sp, #12]
 8019cf6:	9d00      	ldr	r5, [sp, #0]
 8019cf8:	1c7b      	adds	r3, r7, #1
 8019cfa:	eb02 08c9 	add.w	r8, r2, r9, lsl #3
 8019cfe:	461e      	mov	r6, r3
 8019d00:	eb02 02ca 	add.w	r2, r2, sl, lsl #3
 8019d04:	00db      	lsls	r3, r3, #3
 8019d06:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 8019d0a:	00e4      	lsls	r4, r4, #3
 8019d0c:	9204      	str	r2, [sp, #16]
 8019d0e:	9303      	str	r3, [sp, #12]
 8019d10:	eb05 06c6 	add.w	r6, r5, r6, lsl #3
 8019d14:	46ba      	mov	sl, r7
 8019d16:	f04f 0901 	mov.w	r9, #1
      BASE tmp_real = REAL(X, ix);
 8019d1a:	ed98 9a00 	vldr	s18, [r8]
      BASE tmp_imag = IMAG(X, ix);
 8019d1e:	edd8 8a01 	vldr	s17, [r8, #4]
 8019d22:	9a04      	ldr	r2, [sp, #16]
 8019d24:	eb05 03ca 	add.w	r3, r5, sl, lsl #3
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8019d28:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_imag = IMAG(X, jx);
 8019d2c:	edd2 6a01 	vldr	s13, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8019d30:	edd2 5a00 	vldr	s11, [r2]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8019d34:	ed93 6a00 	vldr	s12, [r3]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8019d38:	ee68 7a27 	vmul.f32	s15, s16, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019d3c:	3308      	adds	r3, #8
 8019d3e:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019d42:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019d46:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = 0; j < i; j++) {
 8019d4a:	429e      	cmp	r6, r3
 8019d4c:	4422      	add	r2, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019d4e:	eee6 7a26 	vfma.f32	s15, s12, s13
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019d52:	ee39 9a47 	vsub.f32	s18, s18, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019d56:	ee78 8ae7 	vsub.f32	s17, s17, s15
      for (j = 0; j < i; j++) {
 8019d5a:	d1e5      	bne.n	8019d28 <cblas_ctrsv+0x3fc>
      if (nonunit) {
 8019d5c:	9b02      	ldr	r3, [sp, #8]
 8019d5e:	2b83      	cmp	r3, #131	; 0x83
 8019d60:	f000 80d9 	beq.w	8019f16 <cblas_ctrsv+0x5ea>
        REAL(X, ix) = tmp_real;
 8019d64:	ed88 9a00 	vstr	s18, [r8]
        IMAG(X, ix) = tmp_imag;
 8019d68:	edc8 8a01 	vstr	s17, [r8, #4]
    for (i = 1; i < N; i++) {
 8019d6c:	9b03      	ldr	r3, [sp, #12]
 8019d6e:	f109 0901 	add.w	r9, r9, #1
 8019d72:	45cb      	cmp	fp, r9
 8019d74:	44a0      	add	r8, r4
 8019d76:	441e      	add	r6, r3
 8019d78:	44ba      	add	sl, r7
 8019d7a:	d1ce      	bne.n	8019d1a <cblas_ctrsv+0x3ee>
 8019d7c:	e6ec      	b.n	8019b58 <cblas_ctrsv+0x22c>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 8019d7e:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8019d82:	f47f ae23 	bne.w	80199cc <cblas_ctrsv+0xa0>
 8019d86:	e7a7      	b.n	8019cd8 <cblas_ctrsv+0x3ac>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019d88:	3865      	subs	r0, #101	; 0x65
 8019d8a:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8019d8c:	ed1f 8a33 	vldr	s16, [pc, #-204]	; 8019cc4 <cblas_ctrsv+0x398>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019d90:	bf94      	ite	ls
 8019d92:	2000      	movls	r0, #0
 8019d94:	2001      	movhi	r0, #1
 8019d96:	f04f 0a70 	mov.w	sl, #112	; 0x70
 8019d9a:	e5e5      	b.n	8019968 <cblas_ctrsv+0x3c>
    ix = OFFSET(N, incX);
 8019d9c:	2c00      	cmp	r4, #0
 8019d9e:	f340 8121 	ble.w	8019fe4 <cblas_ctrsv+0x6b8>
 8019da2:	46a1      	mov	r9, r4
 8019da4:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 8019da8:	9b02      	ldr	r3, [sp, #8]
 8019daa:	2b83      	cmp	r3, #131	; 0x83
 8019dac:	f000 819d 	beq.w	801a0ea <cblas_ctrsv+0x7be>
    for (i = 1; i < N; i++) {
 8019db0:	f1bb 0f01 	cmp.w	fp, #1
 8019db4:	f77f aed0 	ble.w	8019b58 <cblas_ctrsv+0x22c>
 8019db8:	9b03      	ldr	r3, [sp, #12]
 8019dba:	3701      	adds	r7, #1
 8019dbc:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
 8019dc0:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8019dc4:	00ff      	lsls	r7, r7, #3
 8019dc6:	9303      	str	r3, [sp, #12]
 8019dc8:	9b00      	ldr	r3, [sp, #0]
 8019dca:	f1a7 0808 	sub.w	r8, r7, #8
 8019dce:	eb03 0a08 	add.w	sl, r3, r8
 8019dd2:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 8019dd6:	330c      	adds	r3, #12
 8019dd8:	00e4      	lsls	r4, r4, #3
 8019dda:	461d      	mov	r5, r3
 8019ddc:	2601      	movs	r6, #1
      BASE tmp_real = REAL(X, ix);
 8019dde:	ed99 9a00 	vldr	s18, [r9]
      BASE tmp_imag = IMAG(X, ix);
 8019de2:	edd9 8a01 	vldr	s17, [r9, #4]
 8019de6:	9b03      	ldr	r3, [sp, #12]
 8019de8:	462a      	mov	r2, r5
 8019dea:	2100      	movs	r1, #0
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8019dec:	edd2 7a00 	vldr	s15, [r2]
        const BASE x_imag = IMAG(X, jx);
 8019df0:	edd3 6a01 	vldr	s13, [r3, #4]
        const BASE x_real = REAL(X, jx);
 8019df4:	edd3 5a00 	vldr	s11, [r3]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8019df8:	ed12 6a01 	vldr	s12, [r2, #-4]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8019dfc:	ee68 7a27 	vmul.f32	s15, s16, s15
      for (j = 0; j < i; j++) {
 8019e00:	3101      	adds	r1, #1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019e02:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019e06:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019e0a:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = 0; j < i; j++) {
 8019e0e:	42b1      	cmp	r1, r6
 8019e10:	4423      	add	r3, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019e12:	eee6 7a26 	vfma.f32	s15, s12, s13
 8019e16:	4442      	add	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019e18:	ee39 9a47 	vsub.f32	s18, s18, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019e1c:	ee78 8ae7 	vsub.f32	s17, s17, s15
      for (j = 0; j < i; j++) {
 8019e20:	d1e4      	bne.n	8019dec <cblas_ctrsv+0x4c0>
      if (nonunit) {
 8019e22:	9b02      	ldr	r3, [sp, #8]
 8019e24:	2b83      	cmp	r3, #131	; 0x83
 8019e26:	f000 80a5 	beq.w	8019f74 <cblas_ctrsv+0x648>
        REAL(X, ix) = tmp_real;
 8019e2a:	ed89 9a00 	vstr	s18, [r9]
        IMAG(X, ix) = tmp_imag;
 8019e2e:	edc9 8a01 	vstr	s17, [r9, #4]
    for (i = 1; i < N; i++) {
 8019e32:	3601      	adds	r6, #1
 8019e34:	45b3      	cmp	fp, r6
 8019e36:	44a1      	add	r9, r4
 8019e38:	44ba      	add	sl, r7
 8019e3a:	f105 0508 	add.w	r5, r5, #8
 8019e3e:	d1ce      	bne.n	8019dde <cblas_ctrsv+0x4b2>
 8019e40:	e68a      	b.n	8019b58 <cblas_ctrsv+0x22c>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019e42:	9b07      	ldr	r3, [sp, #28]
 8019e44:	9a06      	ldr	r2, [sp, #24]
 8019e46:	442b      	add	r3, r5
 8019e48:	4413      	add	r3, r2
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019e4a:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019e4e:	ed93 aa00 	vldr	s20, [r3]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019e52:	eef8 9ac8 	vcvt.f32.s32	s19, s16
 8019e56:	ee69 9aa7 	vmul.f32	s19, s19, s15
        const BASE s = xhypot(a_real, a_imag);
 8019e5a:	ee19 0a90 	vmov	r0, s19
 8019e5e:	f00e fe2b 	bl	8028ab8 <__aeabi_f2d>
 8019e62:	4602      	mov	r2, r0
 8019e64:	460b      	mov	r3, r1
 8019e66:	ee1a 0a10 	vmov	r0, s20
 8019e6a:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8019e6e:	f00e fe23 	bl	8028ab8 <__aeabi_f2d>
 8019e72:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8019e76:	f7ff fd21 	bl	80198bc <xhypot>
 8019e7a:	f00f f925 	bl	80290c8 <__aeabi_d2f>
 8019e7e:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 8019e82:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 8019e86:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019e8a:	ee67 6a09 	vmul.f32	s13, s14, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019e8e:	ee28 7ac7 	vnmul.f32	s14, s17, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019e92:	eee6 6a28 	vfma.f32	s13, s12, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019e96:	eea6 7a09 	vfma.f32	s14, s12, s18
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019e9a:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019e9e:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019ea2:	ed08 6a01 	vstr	s12, [r8, #-4]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019ea6:	edc8 6a00 	vstr	s13, [r8]
 8019eaa:	e64e      	b.n	8019b4a <cblas_ctrsv+0x21e>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019eac:	9b07      	ldr	r3, [sp, #28]
 8019eae:	9a06      	ldr	r2, [sp, #24]
 8019eb0:	18eb      	adds	r3, r5, r3
 8019eb2:	4413      	add	r3, r2
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019eb4:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019eb8:	ed93 aa00 	vldr	s20, [r3]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019ebc:	eef8 9ac8 	vcvt.f32.s32	s19, s16
 8019ec0:	ee69 9aa7 	vmul.f32	s19, s19, s15
        const BASE s = xhypot(a_real, a_imag);
 8019ec4:	ee19 0a90 	vmov	r0, s19
 8019ec8:	f00e fdf6 	bl	8028ab8 <__aeabi_f2d>
 8019ecc:	4602      	mov	r2, r0
 8019ece:	460b      	mov	r3, r1
 8019ed0:	ee1a 0a10 	vmov	r0, s20
 8019ed4:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8019ed8:	f00e fdee 	bl	8028ab8 <__aeabi_f2d>
 8019edc:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8019ee0:	f7ff fcec 	bl	80198bc <xhypot>
 8019ee4:	f00f f8f0 	bl	80290c8 <__aeabi_d2f>
 8019ee8:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 8019eec:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 8019ef0:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019ef4:	ee67 6a09 	vmul.f32	s13, s14, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019ef8:	ee28 7ac7 	vnmul.f32	s14, s17, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019efc:	eee6 6a28 	vfma.f32	s13, s12, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f00:	eea6 7a09 	vfma.f32	s14, s12, s18
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019f04:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f08:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019f0c:	ed08 6a01 	vstr	s12, [r8, #-4]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f10:	edc8 6a00 	vstr	s13, [r8]
 8019f14:	e6c0      	b.n	8019c98 <cblas_ctrsv+0x36c>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019f16:	edd6 9a01 	vldr	s19, [r6, #4]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019f1a:	ed96 aa00 	vldr	s20, [r6]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019f1e:	ee68 9a29 	vmul.f32	s19, s16, s19
        const BASE s = xhypot(a_real, a_imag);
 8019f22:	ee19 0a90 	vmov	r0, s19
 8019f26:	f00e fdc7 	bl	8028ab8 <__aeabi_f2d>
 8019f2a:	4602      	mov	r2, r0
 8019f2c:	460b      	mov	r3, r1
 8019f2e:	ee1a 0a10 	vmov	r0, s20
 8019f32:	e9cd 2300 	strd	r2, r3, [sp]
 8019f36:	f00e fdbf 	bl	8028ab8 <__aeabi_f2d>
 8019f3a:	e9dd 2300 	ldrd	r2, r3, [sp]
 8019f3e:	f7ff fcbd 	bl	80198bc <xhypot>
 8019f42:	f00f f8c1 	bl	80290c8 <__aeabi_d2f>
 8019f46:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 8019f4a:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 8019f4e:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019f52:	ee67 6a28 	vmul.f32	s13, s14, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f56:	ee29 7a47 	vnmul.f32	s14, s18, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019f5a:	eee6 6a09 	vfma.f32	s13, s12, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f5e:	eea6 7a28 	vfma.f32	s14, s12, s17
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019f62:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f66:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019f6a:	ed88 6a00 	vstr	s12, [r8]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019f6e:	edc8 6a01 	vstr	s13, [r8, #4]
 8019f72:	e6fb      	b.n	8019d6c <cblas_ctrsv+0x440>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019f74:	edda 9a03 	vldr	s19, [sl, #12]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019f78:	ed9a aa02 	vldr	s20, [sl, #8]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019f7c:	ee68 9a29 	vmul.f32	s19, s16, s19
        const BASE s = xhypot(a_real, a_imag);
 8019f80:	ee19 0a90 	vmov	r0, s19
 8019f84:	f00e fd98 	bl	8028ab8 <__aeabi_f2d>
 8019f88:	4602      	mov	r2, r0
 8019f8a:	460b      	mov	r3, r1
 8019f8c:	ee1a 0a10 	vmov	r0, s20
 8019f90:	e9cd 2300 	strd	r2, r3, [sp]
 8019f94:	f00e fd90 	bl	8028ab8 <__aeabi_f2d>
 8019f98:	e9dd 2300 	ldrd	r2, r3, [sp]
 8019f9c:	f7ff fc8e 	bl	80198bc <xhypot>
 8019fa0:	f00f f892 	bl	80290c8 <__aeabi_d2f>
 8019fa4:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 8019fa8:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 8019fac:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019fb0:	ee67 6a28 	vmul.f32	s13, s14, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019fb4:	ee29 7a47 	vnmul.f32	s14, s18, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019fb8:	eee6 6a09 	vfma.f32	s13, s12, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019fbc:	eea6 7a28 	vfma.f32	s14, s12, s17
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019fc0:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019fc4:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019fc8:	ed89 6a00 	vstr	s12, [r9]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019fcc:	edc9 6a01 	vstr	s13, [r9, #4]
 8019fd0:	e72f      	b.n	8019e32 <cblas_ctrsv+0x506>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019fd2:	2009      	movs	r0, #9
 8019fd4:	e4dd      	b.n	8019992 <cblas_ctrsv+0x66>
    ix = OFFSET(N, incX);
 8019fd6:	f1cb 0301 	rsb	r3, fp, #1
 8019fda:	fb03 fa04 	mul.w	sl, r3, r4
 8019fde:	eb04 090a 	add.w	r9, r4, sl
 8019fe2:	e67f      	b.n	8019ce4 <cblas_ctrsv+0x3b8>
    ix = OFFSET(N, incX);
 8019fe4:	f1cb 0a01 	rsb	sl, fp, #1
 8019fe8:	fb0a fa04 	mul.w	sl, sl, r4
 8019fec:	eb04 090a 	add.w	r9, r4, sl
 8019ff0:	e6da      	b.n	8019da8 <cblas_ctrsv+0x47c>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019ff2:	9a00      	ldr	r2, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8019ff4:	9e03      	ldr	r6, [sp, #12]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019ff6:	fb0a a307 	mla	r3, sl, r7, sl
 8019ffa:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8019ffe:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 801a002:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 801a006:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 801a00a:	eb06 03c8 	add.w	r3, r6, r8, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 801a00e:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 801a012:	1d1d      	adds	r5, r3, #4
      const BASE s = xhypot(a_real, a_imag);
 801a014:	ee18 0a90 	vmov	r0, s17
 801a018:	f00e fd4e 	bl	8028ab8 <__aeabi_f2d>
 801a01c:	4602      	mov	r2, r0
 801a01e:	460b      	mov	r3, r1
 801a020:	ee1a 0a10 	vmov	r0, s20
 801a024:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 801a028:	eb06 09c8 	add.w	r9, r6, r8, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 801a02c:	f00e fd44 	bl	8028ab8 <__aeabi_f2d>
 801a030:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 801a034:	ed95 9a00 	vldr	s18, [r5]
      const BASE x_real = REAL(X, ix);
 801a038:	edd9 9a00 	vldr	s19, [r9]
      const BASE s = xhypot(a_real, a_imag);
 801a03c:	f7ff fc3e 	bl	80198bc <xhypot>
 801a040:	f00f f842 	bl	80290c8 <__aeabi_d2f>
 801a044:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 801a048:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 801a04c:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a050:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a054:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a058:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a05c:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a060:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a064:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a068:	ed89 6a00 	vstr	s12, [r9]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a06c:	edc5 6a00 	vstr	s13, [r5]
 801a070:	e5ba      	b.n	8019be8 <cblas_ctrsv+0x2bc>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a072:	9b00      	ldr	r3, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 801a074:	9d03      	ldr	r5, [sp, #12]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a076:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 801a07a:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a07e:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 801a082:	eb05 03ca 	add.w	r3, r5, sl, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a086:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 801a08a:	1d1e      	adds	r6, r3, #4
      const BASE s = xhypot(a_real, a_imag);
 801a08c:	ee18 0a90 	vmov	r0, s17
 801a090:	f00e fd12 	bl	8028ab8 <__aeabi_f2d>
 801a094:	4602      	mov	r2, r0
 801a096:	460b      	mov	r3, r1
 801a098:	ee1a 0a10 	vmov	r0, s20
 801a09c:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 801a0a0:	eb05 08ca 	add.w	r8, r5, sl, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 801a0a4:	f00e fd08 	bl	8028ab8 <__aeabi_f2d>
 801a0a8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 801a0ac:	ed96 9a00 	vldr	s18, [r6]
      const BASE x_real = REAL(X, ix);
 801a0b0:	edd8 9a00 	vldr	s19, [r8]
      const BASE s = xhypot(a_real, a_imag);
 801a0b4:	f7ff fc02 	bl	80198bc <xhypot>
 801a0b8:	f00f f806 	bl	80290c8 <__aeabi_d2f>
 801a0bc:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 801a0c0:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 801a0c4:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a0c8:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a0cc:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a0d0:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a0d4:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a0d8:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a0dc:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a0e0:	ed88 6a00 	vstr	s12, [r8]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a0e4:	edc6 6a00 	vstr	s13, [r6]
 801a0e8:	e600      	b.n	8019cec <cblas_ctrsv+0x3c0>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a0ea:	9b00      	ldr	r3, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 801a0ec:	9e03      	ldr	r6, [sp, #12]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a0ee:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 801a0f2:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a0f6:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 801a0fa:	eb06 03ca 	add.w	r3, r6, sl, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801a0fe:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 801a102:	1d1d      	adds	r5, r3, #4
      const BASE s = xhypot(a_real, a_imag);
 801a104:	ee18 0a90 	vmov	r0, s17
 801a108:	f00e fcd6 	bl	8028ab8 <__aeabi_f2d>
 801a10c:	4602      	mov	r2, r0
 801a10e:	460b      	mov	r3, r1
 801a110:	ee1a 0a10 	vmov	r0, s20
 801a114:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 801a118:	eb06 08ca 	add.w	r8, r6, sl, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 801a11c:	f00e fccc 	bl	8028ab8 <__aeabi_f2d>
 801a120:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 801a124:	ed95 9a00 	vldr	s18, [r5]
      const BASE x_real = REAL(X, ix);
 801a128:	edd8 9a00 	vldr	s19, [r8]
      const BASE s = xhypot(a_real, a_imag);
 801a12c:	f7ff fbc6 	bl	80198bc <xhypot>
 801a130:	f00e ffca 	bl	80290c8 <__aeabi_d2f>
 801a134:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 801a138:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 801a13c:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a140:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a144:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a148:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a14c:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a150:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a154:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 801a158:	ed88 6a00 	vstr	s12, [r8]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801a15c:	edc5 6a00 	vstr	s13, [r5]
 801a160:	e626      	b.n	8019db0 <cblas_ctrsv+0x484>
 801a162:	bf00      	nop

0801a164 <cblas_zaxpy>:
#include "cblas.h"

void
cblas_zaxpy (const int N, const void *alpha, const void *X, const int incX,
             void *Y, const int incY)
{
 801a164:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a168:	ed2d 8b06 	vpush	{d8-d10}
 801a16c:	b085      	sub	sp, #20
  INDEX ix = OFFSET(N, incX);
 801a16e:	1e1e      	subs	r6, r3, #0
 801a170:	e9dd 7414 	ldrd	r7, r4, [sp, #80]	; 0x50
 801a174:	bfd8      	it	le
 801a176:	4603      	movle	r3, r0
  const BASE alpha_real = CONST_REAL0(alpha);
 801a178:	ed91 7b00 	vldr	d7, [r1]
  INDEX ix = OFFSET(N, incX);
 801a17c:	bfd8      	it	le
 801a17e:	f1c3 0501 	rsble	r5, r3, #1
 801a182:	9001      	str	r0, [sp, #4]
 801a184:	468c      	mov	ip, r1
 801a186:	bfd4      	ite	le
 801a188:	4375      	mulle	r5, r6
 801a18a:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 801a18c:	2c00      	cmp	r4, #0
 801a18e:	bfd8      	it	le
 801a190:	9b01      	ldrle	r3, [sp, #4]
  const BASE alpha_real = CONST_REAL0(alpha);
 801a192:	eeb0 9a47 	vmov.f32	s18, s14
 801a196:	eef0 9a67 	vmov.f32	s19, s15
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 801a19a:	ec51 0b17 	vmov	r0, r1, d7
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801a19e:	ed9c 7b02 	vldr	d7, [ip, #8]
  INDEX iy = OFFSET(N, incY);
 801a1a2:	bfd8      	it	le
 801a1a4:	f1c3 0b01 	rsble	fp, r3, #1
 801a1a8:	4692      	mov	sl, r2
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 801a1aa:	f04f 0300 	mov.w	r3, #0
 801a1ae:	f04f 0200 	mov.w	r2, #0
  INDEX iy = OFFSET(N, incY);
 801a1b2:	bfd4      	ite	le
 801a1b4:	fb0b fb04 	mulle.w	fp, fp, r4
 801a1b8:	f04f 0b00 	movgt.w	fp, #0
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801a1bc:	eeb0 8a47 	vmov.f32	s16, s14
 801a1c0:	eef0 8a67 	vmov.f32	s17, s15
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 801a1c4:	f00e ff38 	bl	8029038 <__aeabi_dcmpeq>
 801a1c8:	b138      	cbz	r0, 801a1da <cblas_zaxpy+0x76>
 801a1ca:	ec51 0b18 	vmov	r0, r1, d8
 801a1ce:	2200      	movs	r2, #0
 801a1d0:	2300      	movs	r3, #0
 801a1d2:	f00e ff31 	bl	8029038 <__aeabi_dcmpeq>
 801a1d6:	2800      	cmp	r0, #0
 801a1d8:	d153      	bne.n	801a282 <cblas_zaxpy+0x11e>
  for (i = 0; i < N; i++) {
 801a1da:	9b01      	ldr	r3, [sp, #4]
 801a1dc:	2b00      	cmp	r3, #0
 801a1de:	dd50      	ble.n	801a282 <cblas_zaxpy+0x11e>
 801a1e0:	0132      	lsls	r2, r6, #4
 801a1e2:	eb07 130b 	add.w	r3, r7, fp, lsl #4
 801a1e6:	9203      	str	r2, [sp, #12]
 801a1e8:	0122      	lsls	r2, r4, #4
 801a1ea:	eb0a 1a05 	add.w	sl, sl, r5, lsl #4
 801a1ee:	9202      	str	r2, [sp, #8]
 801a1f0:	f103 0408 	add.w	r4, r3, #8
 801a1f4:	469b      	mov	fp, r3
 801a1f6:	2500      	movs	r5, #0
    const BASE x_real = CONST_REAL(X, ix);
 801a1f8:	e9da 6700 	ldrd	r6, r7, [sl]
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 801a1fc:	ec51 0b19 	vmov	r0, r1, d9
 801a200:	4632      	mov	r2, r6
 801a202:	463b      	mov	r3, r7
 801a204:	f00e fcb0 	bl	8028b68 <__aeabi_dmul>
    const BASE x_imag = CONST_IMAG(X, ix);
 801a208:	e9da 8902 	ldrd	r8, r9, [sl, #8]
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 801a20c:	ec41 0b1a 	vmov	d10, r0, r1
 801a210:	4642      	mov	r2, r8
 801a212:	464b      	mov	r3, r9
 801a214:	ec51 0b18 	vmov	r0, r1, d8
 801a218:	f00e fca6 	bl	8028b68 <__aeabi_dmul>
 801a21c:	4602      	mov	r2, r0
 801a21e:	460b      	mov	r3, r1
 801a220:	ec51 0b1a 	vmov	r0, r1, d10
 801a224:	f00e fae8 	bl	80287f8 <__aeabi_dsub>
 801a228:	4602      	mov	r2, r0
 801a22a:	460b      	mov	r3, r1
 801a22c:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801a230:	f00e fae4 	bl	80287fc <__adddf3>
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801a234:	4642      	mov	r2, r8
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 801a236:	e944 0102 	strd	r0, r1, [r4, #-8]
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801a23a:	464b      	mov	r3, r9
 801a23c:	ec51 0b19 	vmov	r0, r1, d9
 801a240:	f00e fc92 	bl	8028b68 <__aeabi_dmul>
 801a244:	4632      	mov	r2, r6
 801a246:	463b      	mov	r3, r7
 801a248:	4606      	mov	r6, r0
 801a24a:	460f      	mov	r7, r1
 801a24c:	ec51 0b18 	vmov	r0, r1, d8
 801a250:	f00e fc8a 	bl	8028b68 <__aeabi_dmul>
 801a254:	4602      	mov	r2, r0
 801a256:	460b      	mov	r3, r1
 801a258:	4630      	mov	r0, r6
 801a25a:	4639      	mov	r1, r7
 801a25c:	f00e face 	bl	80287fc <__adddf3>
 801a260:	460b      	mov	r3, r1
 801a262:	4602      	mov	r2, r0
 801a264:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801a268:	f00e fac8 	bl	80287fc <__adddf3>
 801a26c:	9b03      	ldr	r3, [sp, #12]
 801a26e:	449a      	add	sl, r3
 801a270:	9b02      	ldr	r3, [sp, #8]
 801a272:	e9cb 0102 	strd	r0, r1, [fp, #8]
  for (i = 0; i < N; i++) {
 801a276:	441c      	add	r4, r3
 801a278:	449b      	add	fp, r3
 801a27a:	9b01      	ldr	r3, [sp, #4]
 801a27c:	3501      	adds	r5, #1
 801a27e:	42ab      	cmp	r3, r5
 801a280:	d1ba      	bne.n	801a1f8 <cblas_zaxpy+0x94>
#define BASE double
#include "source_axpy_c.h"
#undef BASE
}
 801a282:	b005      	add	sp, #20
 801a284:	ecbd 8b06 	vpop	{d8-d10}
 801a288:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801a28c <cblas_zcopy>:
#include "cblas.h"

void
cblas_zcopy (const int N, const void *X, const int incX, void *Y,
             const int incY)
{
 801a28c:	b4f0      	push	{r4, r5, r6, r7}
  INDEX ix = OFFSET(N, incX);
 801a28e:	2a00      	cmp	r2, #0
 801a290:	9f04      	ldr	r7, [sp, #16]
 801a292:	bfda      	itte	le
 801a294:	f1c0 0501 	rsble	r5, r0, #1
 801a298:	4355      	mulle	r5, r2
 801a29a:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 801a29c:	2f00      	cmp	r7, #0
 801a29e:	bfda      	itte	le
 801a2a0:	f1c0 0401 	rsble	r4, r0, #1
 801a2a4:	437c      	mulle	r4, r7
 801a2a6:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 801a2a8:	2800      	cmp	r0, #0
 801a2aa:	dd13      	ble.n	801a2d4 <cblas_zcopy+0x48>
 801a2ac:	0116      	lsls	r6, r2, #4
 801a2ae:	eb01 1105 	add.w	r1, r1, r5, lsl #4
 801a2b2:	013f      	lsls	r7, r7, #4
 801a2b4:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801a2b8:	2200      	movs	r2, #0
    REAL(Y, iy) = CONST_REAL(X, ix);
 801a2ba:	e9d1 4500 	ldrd	r4, r5, [r1]
 801a2be:	e9c3 4500 	strd	r4, r5, [r3]
    IMAG(Y, iy) = CONST_IMAG(X, ix);
 801a2c2:	e9d1 4502 	ldrd	r4, r5, [r1, #8]
  for (i = 0; i < N; i++) {
 801a2c6:	3201      	adds	r2, #1
 801a2c8:	4290      	cmp	r0, r2
    IMAG(Y, iy) = CONST_IMAG(X, ix);
 801a2ca:	e9c3 4502 	strd	r4, r5, [r3, #8]
  for (i = 0; i < N; i++) {
 801a2ce:	4431      	add	r1, r6
 801a2d0:	443b      	add	r3, r7
 801a2d2:	d1f2      	bne.n	801a2ba <cblas_zcopy+0x2e>
#define BASE double
#include "source_copy_c.h"
#undef BASE
}
 801a2d4:	bcf0      	pop	{r4, r5, r6, r7}
 801a2d6:	4770      	bx	lr

0801a2d8 <cblas_zdotc_sub>:
#include "cblas.h"

void
cblas_zdotc_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 801a2d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a2dc:	ed2d 8b04 	vpush	{d8-d9}
 801a2e0:	b08b      	sub	sp, #44	; 0x2c
 801a2e2:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 801a2e4:	2a00      	cmp	r2, #0
 801a2e6:	9007      	str	r0, [sp, #28]
 801a2e8:	9818      	ldr	r0, [sp, #96]	; 0x60
  for (i = 0; i < N; i++) {
 801a2ea:	9e07      	ldr	r6, [sp, #28]
  INDEX ix = OFFSET(N, incX);
 801a2ec:	bfda      	itte	le
 801a2ee:	f1c4 0501 	rsble	r5, r4, #1
 801a2f2:	4355      	mulle	r5, r2
 801a2f4:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 801a2f6:	2800      	cmp	r0, #0
 801a2f8:	bfd8      	it	le
 801a2fa:	9c07      	ldrle	r4, [sp, #28]
  for (i = 0; i < N; i++) {
 801a2fc:	ed9f 7b3c 	vldr	d7, [pc, #240]	; 801a3f0 <cblas_zdotc_sub+0x118>
  INDEX iy = OFFSET(N, incY);
 801a300:	bfda      	itte	le
 801a302:	f1c4 0401 	rsble	r4, r4, #1
 801a306:	4344      	mulle	r4, r0
 801a308:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 801a30a:	2e00      	cmp	r6, #0
 801a30c:	ed8d 7b02 	vstr	d7, [sp, #8]
 801a310:	ed8d 7b04 	vstr	d7, [sp, #16]
 801a314:	dd5d      	ble.n	801a3d2 <cblas_zdotc_sub+0xfa>
 801a316:	0112      	lsls	r2, r2, #4
 801a318:	9209      	str	r2, [sp, #36]	; 0x24
 801a31a:	eb03 1704 	add.w	r7, r3, r4, lsl #4
 801a31e:	0102      	lsls	r2, r0, #4
 801a320:	2300      	movs	r3, #0
 801a322:	eb01 1605 	add.w	r6, r1, r5, lsl #4
 801a326:	9208      	str	r2, [sp, #32]
 801a328:	9306      	str	r3, [sp, #24]
    const BASE x_real = CONST_REAL(X, ix);
 801a32a:	ed96 7b00 	vldr	d7, [r6]
    const BASE y_real = CONST_REAL(Y, iy);
 801a32e:	e9d7 8900 	ldrd	r8, r9, [r7]
    const BASE x_real = CONST_REAL(X, ix);
 801a332:	eeb0 8a47 	vmov.f32	s16, s14
 801a336:	eef0 8a67 	vmov.f32	s17, s15
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a33a:	ec51 0b17 	vmov	r0, r1, d7
 801a33e:	4642      	mov	r2, r8
 801a340:	464b      	mov	r3, r9
 801a342:	f00e fc11 	bl	8028b68 <__aeabi_dmul>
    const BASE x_imag = CONST_IMAG(X, ix);
 801a346:	e9d6 4502 	ldrd	r4, r5, [r6, #8]
    const BASE y_imag = CONST_IMAG(Y, iy);
 801a34a:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a34e:	ec41 0b19 	vmov	d9, r0, r1
 801a352:	4652      	mov	r2, sl
 801a354:	465b      	mov	r3, fp
 801a356:	4620      	mov	r0, r4
 801a358:	4629      	mov	r1, r5
 801a35a:	f00e fc05 	bl	8028b68 <__aeabi_dmul>
 801a35e:	4602      	mov	r2, r0
 801a360:	460b      	mov	r3, r1
 801a362:	ec51 0b19 	vmov	r0, r1, d9
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a366:	9400      	str	r4, [sp, #0]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a368:	f00e fa48 	bl	80287fc <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a36c:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a370:	4602      	mov	r2, r0
 801a372:	460b      	mov	r3, r1
 801a374:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a378:	9401      	str	r4, [sp, #4]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a37a:	f00e fa3f 	bl	80287fc <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a37e:	4642      	mov	r2, r8
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a380:	4604      	mov	r4, r0
 801a382:	460d      	mov	r5, r1
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a384:	464b      	mov	r3, r9
 801a386:	e9dd 0100 	ldrd	r0, r1, [sp]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a38a:	e9cd 4504 	strd	r4, r5, [sp, #16]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a38e:	f00e fbeb 	bl	8028b68 <__aeabi_dmul>
 801a392:	4652      	mov	r2, sl
 801a394:	465b      	mov	r3, fp
 801a396:	4604      	mov	r4, r0
 801a398:	460d      	mov	r5, r1
 801a39a:	ec51 0b18 	vmov	r0, r1, d8
 801a39e:	f00e fbe3 	bl	8028b68 <__aeabi_dmul>
 801a3a2:	4602      	mov	r2, r0
 801a3a4:	460b      	mov	r3, r1
 801a3a6:	4620      	mov	r0, r4
 801a3a8:	4629      	mov	r1, r5
 801a3aa:	f00e fa27 	bl	80287fc <__adddf3>
 801a3ae:	4602      	mov	r2, r0
 801a3b0:	460b      	mov	r3, r1
 801a3b2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801a3b6:	f00e fa21 	bl	80287fc <__adddf3>
 801a3ba:	9a09      	ldr	r2, [sp, #36]	; 0x24
  for (i = 0; i < N; i++) {
 801a3bc:	9b06      	ldr	r3, [sp, #24]
 801a3be:	4416      	add	r6, r2
 801a3c0:	9a08      	ldr	r2, [sp, #32]
 801a3c2:	4417      	add	r7, r2
 801a3c4:	9a07      	ldr	r2, [sp, #28]
 801a3c6:	3301      	adds	r3, #1
 801a3c8:	429a      	cmp	r2, r3
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a3ca:	e9cd 0102 	strd	r0, r1, [sp, #8]
  for (i = 0; i < N; i++) {
 801a3ce:	9306      	str	r3, [sp, #24]
 801a3d0:	d1ab      	bne.n	801a32a <cblas_zdotc_sub+0x52>
  REAL0(result) = r_real;
 801a3d2:	ed9d 7b04 	vldr	d7, [sp, #16]
 801a3d6:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801a3d8:	ed83 7b00 	vstr	d7, [r3]
  IMAG0(result) = r_imag;
 801a3dc:	ed9d 7b02 	vldr	d7, [sp, #8]
 801a3e0:	ed83 7b02 	vstr	d7, [r3, #8]
#define BASE double
#define CONJ_SIGN (-1.0)
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 801a3e4:	b00b      	add	sp, #44	; 0x2c
 801a3e6:	ecbd 8b04 	vpop	{d8-d9}
 801a3ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801a3ee:	bf00      	nop
	...

0801a3f8 <cblas_zdotu_sub>:
#include "cblas.h"

void
cblas_zdotu_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 801a3f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a3fc:	ed2d 8b04 	vpush	{d8-d9}
 801a400:	b089      	sub	sp, #36	; 0x24
 801a402:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 801a404:	2a00      	cmp	r2, #0
 801a406:	9005      	str	r0, [sp, #20]
 801a408:	9816      	ldr	r0, [sp, #88]	; 0x58
  for (i = 0; i < N; i++) {
 801a40a:	9e05      	ldr	r6, [sp, #20]
  INDEX ix = OFFSET(N, incX);
 801a40c:	bfda      	itte	le
 801a40e:	f1c4 0501 	rsble	r5, r4, #1
 801a412:	4355      	mulle	r5, r2
 801a414:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 801a416:	2800      	cmp	r0, #0
 801a418:	bfd8      	it	le
 801a41a:	9c05      	ldrle	r4, [sp, #20]
  for (i = 0; i < N; i++) {
 801a41c:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 801a508 <cblas_zdotu_sub+0x110>
  INDEX iy = OFFSET(N, incY);
 801a420:	bfda      	itte	le
 801a422:	f1c4 0401 	rsble	r4, r4, #1
 801a426:	4344      	mulle	r4, r0
 801a428:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 801a42a:	2e00      	cmp	r6, #0
 801a42c:	ed8d 7b00 	vstr	d7, [sp]
 801a430:	ed8d 7b02 	vstr	d7, [sp, #8]
 801a434:	dd59      	ble.n	801a4ea <cblas_zdotu_sub+0xf2>
 801a436:	0112      	lsls	r2, r2, #4
 801a438:	9207      	str	r2, [sp, #28]
 801a43a:	eb03 1404 	add.w	r4, r3, r4, lsl #4
 801a43e:	0102      	lsls	r2, r0, #4
 801a440:	2300      	movs	r3, #0
 801a442:	eb01 1505 	add.w	r5, r1, r5, lsl #4
 801a446:	9206      	str	r2, [sp, #24]
 801a448:	9304      	str	r3, [sp, #16]
    const BASE y_real = CONST_REAL(Y, iy);
 801a44a:	ed94 7b00 	vldr	d7, [r4]
    const BASE x_real = CONST_REAL(X, ix);
 801a44e:	e9d5 ab00 	ldrd	sl, fp, [r5]
    const BASE y_real = CONST_REAL(Y, iy);
 801a452:	eeb0 9a47 	vmov.f32	s18, s14
 801a456:	eef0 9a67 	vmov.f32	s19, s15
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a45a:	ec53 2b17 	vmov	r2, r3, d7
 801a45e:	4650      	mov	r0, sl
 801a460:	4659      	mov	r1, fp
 801a462:	f00e fb81 	bl	8028b68 <__aeabi_dmul>
    const BASE y_imag = CONST_IMAG(Y, iy);
 801a466:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
    const BASE x_imag = CONST_IMAG(X, ix);
 801a46a:	ed95 8b02 	vldr	d8, [r5, #8]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a46e:	4606      	mov	r6, r0
 801a470:	460f      	mov	r7, r1
 801a472:	4642      	mov	r2, r8
 801a474:	464b      	mov	r3, r9
 801a476:	ec51 0b18 	vmov	r0, r1, d8
 801a47a:	f00e fb75 	bl	8028b68 <__aeabi_dmul>
 801a47e:	4602      	mov	r2, r0
 801a480:	460b      	mov	r3, r1
 801a482:	4630      	mov	r0, r6
 801a484:	4639      	mov	r1, r7
 801a486:	f00e f9b7 	bl	80287f8 <__aeabi_dsub>
 801a48a:	4602      	mov	r2, r0
 801a48c:	460b      	mov	r3, r1
 801a48e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801a492:	f00e f9b3 	bl	80287fc <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a496:	4642      	mov	r2, r8
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a498:	4606      	mov	r6, r0
 801a49a:	460f      	mov	r7, r1
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a49c:	464b      	mov	r3, r9
 801a49e:	4650      	mov	r0, sl
 801a4a0:	4659      	mov	r1, fp
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801a4a2:	e9cd 6702 	strd	r6, r7, [sp, #8]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a4a6:	f00e fb5f 	bl	8028b68 <__aeabi_dmul>
 801a4aa:	ec53 2b19 	vmov	r2, r3, d9
 801a4ae:	4606      	mov	r6, r0
 801a4b0:	460f      	mov	r7, r1
 801a4b2:	ec51 0b18 	vmov	r0, r1, d8
 801a4b6:	f00e fb57 	bl	8028b68 <__aeabi_dmul>
 801a4ba:	4602      	mov	r2, r0
 801a4bc:	460b      	mov	r3, r1
 801a4be:	4630      	mov	r0, r6
 801a4c0:	4639      	mov	r1, r7
 801a4c2:	f00e f99b 	bl	80287fc <__adddf3>
 801a4c6:	4602      	mov	r2, r0
 801a4c8:	460b      	mov	r3, r1
 801a4ca:	e9dd 0100 	ldrd	r0, r1, [sp]
 801a4ce:	f00e f995 	bl	80287fc <__adddf3>
 801a4d2:	9a07      	ldr	r2, [sp, #28]
  for (i = 0; i < N; i++) {
 801a4d4:	9b04      	ldr	r3, [sp, #16]
 801a4d6:	4415      	add	r5, r2
 801a4d8:	9a06      	ldr	r2, [sp, #24]
 801a4da:	4414      	add	r4, r2
 801a4dc:	9a05      	ldr	r2, [sp, #20]
 801a4de:	3301      	adds	r3, #1
 801a4e0:	429a      	cmp	r2, r3
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801a4e2:	e9cd 0100 	strd	r0, r1, [sp]
  for (i = 0; i < N; i++) {
 801a4e6:	9304      	str	r3, [sp, #16]
 801a4e8:	d1af      	bne.n	801a44a <cblas_zdotu_sub+0x52>
  REAL0(result) = r_real;
 801a4ea:	ed9d 7b02 	vldr	d7, [sp, #8]
 801a4ee:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801a4f0:	ed83 7b00 	vstr	d7, [r3]
  IMAG0(result) = r_imag;
 801a4f4:	ed9d 7b00 	vldr	d7, [sp]
 801a4f8:	ed83 7b02 	vstr	d7, [r3, #8]
#define BASE double
#define CONJ_SIGN 1.0
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 801a4fc:	b009      	add	sp, #36	; 0x24
 801a4fe:	ecbd 8b04 	vpop	{d8-d9}
 801a502:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801a506:	bf00      	nop
	...

0801a510 <cblas_zdscal>:
  if (incX <= 0) {
 801a510:	2a00      	cmp	r2, #0
 801a512:	dd22      	ble.n	801a55a <cblas_zdscal+0x4a>
  for (i = 0; i < N; i++) {
 801a514:	2800      	cmp	r0, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_zdscal (const int N, const double alpha, void *X, const int incX)
{
 801a516:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801a51a:	4682      	mov	sl, r0
 801a51c:	dd1b      	ble.n	801a556 <cblas_zdscal+0x46>
 801a51e:	ec59 8b10 	vmov	r8, r9, d0
 801a522:	460c      	mov	r4, r1
 801a524:	0117      	lsls	r7, r2, #4
 801a526:	f101 0508 	add.w	r5, r1, #8
 801a52a:	2600      	movs	r6, #0
    REAL(X, ix) *= alpha;
 801a52c:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 801a530:	4642      	mov	r2, r8
 801a532:	464b      	mov	r3, r9
 801a534:	f00e fb18 	bl	8028b68 <__aeabi_dmul>
 801a538:	e945 0102 	strd	r0, r1, [r5, #-8]
    IMAG(X, ix) *= alpha;
 801a53c:	4642      	mov	r2, r8
 801a53e:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801a542:	464b      	mov	r3, r9
 801a544:	f00e fb10 	bl	8028b68 <__aeabi_dmul>
  for (i = 0; i < N; i++) {
 801a548:	3601      	adds	r6, #1
 801a54a:	45b2      	cmp	sl, r6
    IMAG(X, ix) *= alpha;
 801a54c:	e9c4 0102 	strd	r0, r1, [r4, #8]
  for (i = 0; i < N; i++) {
 801a550:	443d      	add	r5, r7
 801a552:	443c      	add	r4, r7
 801a554:	d1ea      	bne.n	801a52c <cblas_zdscal+0x1c>
#define BASE double
#include "source_scal_c_s.h"
#undef BASE
}
 801a556:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801a55a:	4770      	bx	lr
 801a55c:	0000      	movs	r0, r0
	...

0801a560 <cblas_zgemm>:
cblas_zgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const void *alpha, const void *A, const int lda,
             const void *B, const int ldb, const void *beta, void *C,
             const int ldc)
{
 801a560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a564:	ed2d 8b10 	vpush	{d8-d15}
 801a568:	b091      	sub	sp, #68	; 0x44
 801a56a:	2865      	cmp	r0, #101	; 0x65
 801a56c:	f8dd 80b0 	ldr.w	r8, [sp, #176]	; 0xb0
 801a570:	9f31      	ldr	r7, [sp, #196]	; 0xc4
 801a572:	9304      	str	r3, [sp, #16]
 801a574:	4605      	mov	r5, r0
 801a576:	460e      	mov	r6, r1
 801a578:	4614      	mov	r4, r2
 801a57a:	f000 828e 	beq.w	801aa9a <cblas_zgemm+0x53a>
 801a57e:	2a71      	cmp	r2, #113	; 0x71
 801a580:	bf08      	it	eq
 801a582:	2270      	moveq	r2, #112	; 0x70
 801a584:	2971      	cmp	r1, #113	; 0x71
 801a586:	f000 81b1 	beq.w	801a8ec <cblas_zgemm+0x38c>
 801a58a:	f1a6 036f 	sub.w	r3, r6, #111	; 0x6f
 801a58e:	2b02      	cmp	r3, #2
 801a590:	f240 83c6 	bls.w	801ad20 <cblas_zgemm+0x7c0>
 801a594:	2002      	movs	r0, #2
 801a596:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 801a59a:	2b02      	cmp	r3, #2
 801a59c:	bf88      	it	hi
 801a59e:	2003      	movhi	r0, #3
 801a5a0:	9b04      	ldr	r3, [sp, #16]
 801a5a2:	2b00      	cmp	r3, #0
 801a5a4:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a5a6:	bfb8      	it	lt
 801a5a8:	2004      	movlt	r0, #4
 801a5aa:	2b00      	cmp	r3, #0
 801a5ac:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801a5ae:	f2c0 8248 	blt.w	801aa42 <cblas_zgemm+0x4e2>
 801a5b2:	2b00      	cmp	r3, #0
 801a5b4:	f2c0 81aa 	blt.w	801a90c <cblas_zgemm+0x3ac>
 801a5b8:	2d65      	cmp	r5, #101	; 0x65
 801a5ba:	f000 824a 	beq.w	801aa52 <cblas_zgemm+0x4f2>
 801a5be:	2d66      	cmp	r5, #102	; 0x66
 801a5c0:	f000 81ab 	beq.w	801a91a <cblas_zgemm+0x3ba>
 801a5c4:	2800      	cmp	r0, #0
 801a5c6:	f040 81c7 	bne.w	801a958 <cblas_zgemm+0x3f8>
    const BASE alpha_real = CONST_REAL0(alpha);
 801a5ca:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801a5ce:	2200      	movs	r2, #0
 801a5d0:	ec51 0b17 	vmov	r0, r1, d7
    const BASE alpha_real = CONST_REAL0(alpha);
 801a5d4:	eeb0 ea47 	vmov.f32	s28, s14
 801a5d8:	eef0 ea67 	vmov.f32	s29, s15
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801a5dc:	2300      	movs	r3, #0
 801a5de:	f00e fd2b 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801a5e2:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801a5e6:	e9d7 ab00 	ldrd	sl, fp, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801a5ea:	eeb0 fa47 	vmov.f32	s30, s14
 801a5ee:	eef0 fa67 	vmov.f32	s31, s15
    const BASE beta_imag = CONST_IMAG0(beta);
 801a5f2:	ed97 8b02 	vldr	d8, [r7, #8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801a5f6:	b178      	cbz	r0, 801a618 <cblas_zgemm+0xb8>
 801a5f8:	ec51 0b17 	vmov	r0, r1, d7
 801a5fc:	2200      	movs	r2, #0
 801a5fe:	2300      	movs	r3, #0
 801a600:	f00e fd1a 	bl	8029038 <__aeabi_dcmpeq>
 801a604:	b140      	cbz	r0, 801a618 <cblas_zgemm+0xb8>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801a606:	4bc0      	ldr	r3, [pc, #768]	; (801a908 <cblas_zgemm+0x3a8>)
 801a608:	2200      	movs	r2, #0
 801a60a:	4650      	mov	r0, sl
 801a60c:	4659      	mov	r1, fp
 801a60e:	f00e fd13 	bl	8029038 <__aeabi_dcmpeq>
 801a612:	2800      	cmp	r0, #0
 801a614:	f040 838b 	bne.w	801ad2e <cblas_zgemm+0x7ce>
    if (Order == CblasRowMajor) {
 801a618:	2d65      	cmp	r5, #101	; 0x65
 801a61a:	f000 824c 	beq.w	801aab6 <cblas_zgemm+0x556>
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 801a61e:	2c71      	cmp	r4, #113	; 0x71
 801a620:	f000 836f 	beq.w	801ad02 <cblas_zgemm+0x7a2>
 801a624:	2c6f      	cmp	r4, #111	; 0x6f
 801a626:	bf0c      	ite	eq
 801a628:	236f      	moveq	r3, #111	; 0x6f
 801a62a:	2370      	movne	r3, #112	; 0x70
 801a62c:	9309      	str	r3, [sp, #36]	; 0x24
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801a62e:	2e71      	cmp	r6, #113	; 0x71
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 801a630:	f04f 0301 	mov.w	r3, #1
 801a634:	9307      	str	r3, [sp, #28]
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801a636:	f000 836d 	beq.w	801ad14 <cblas_zgemm+0x7b4>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a63a:	2e6f      	cmp	r6, #111	; 0x6f
 801a63c:	bf0c      	ite	eq
 801a63e:	236f      	moveq	r3, #111	; 0x6f
 801a640:	2370      	movne	r3, #112	; 0x70
 801a642:	930a      	str	r3, [sp, #40]	; 0x28
 801a644:	2301      	movs	r3, #1
 801a646:	9305      	str	r3, [sp, #20]
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801a648:	2200      	movs	r2, #0
 801a64a:	2300      	movs	r3, #0
 801a64c:	4650      	mov	r0, sl
 801a64e:	4659      	mov	r1, fp
 801a650:	f00e fcf2 	bl	8029038 <__aeabi_dcmpeq>
 801a654:	2200      	movs	r2, #0
 801a656:	2800      	cmp	r0, #0
 801a658:	f000 8183 	beq.w	801a962 <cblas_zgemm+0x402>
 801a65c:	ec51 0b18 	vmov	r0, r1, d8
 801a660:	2300      	movs	r3, #0
 801a662:	f00e fce9 	bl	8029038 <__aeabi_dcmpeq>
 801a666:	2800      	cmp	r0, #0
 801a668:	f000 818a 	beq.w	801a980 <cblas_zgemm+0x420>
      for (i = 0; i < n1; i++) {
 801a66c:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a66e:	2b00      	cmp	r3, #0
 801a670:	dd1e      	ble.n	801a6b0 <cblas_zgemm+0x150>
 801a672:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801a674:	9d04      	ldr	r5, [sp, #16]
 801a676:	f8dd c0a8 	ldr.w	ip, [sp, #168]	; 0xa8
 801a67a:	011c      	lsls	r4, r3, #4
 801a67c:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a67e:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 801a682:	461a      	mov	r2, r3
 801a684:	0100      	lsls	r0, r0, #4
 801a686:	462b      	mov	r3, r5
 801a688:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 801a68c:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 801a68e:	2600      	movs	r6, #0
 801a690:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 801a692:	2d00      	cmp	r5, #0
 801a694:	bfc8      	it	gt
 801a696:	1813      	addgt	r3, r2, r0
 801a698:	dd06      	ble.n	801a6a8 <cblas_zgemm+0x148>
          REAL(C, ldc * i + j) = 0.0;
 801a69a:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 801a69e:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 801a6a2:	3310      	adds	r3, #16
 801a6a4:	429a      	cmp	r2, r3
 801a6a6:	d1f8      	bne.n	801a69a <cblas_zgemm+0x13a>
      for (i = 0; i < n1; i++) {
 801a6a8:	3101      	adds	r1, #1
 801a6aa:	458c      	cmp	ip, r1
 801a6ac:	4422      	add	r2, r4
 801a6ae:	d1f0      	bne.n	801a692 <cblas_zgemm+0x132>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801a6b0:	ec51 0b1e 	vmov	r0, r1, d14
 801a6b4:	2200      	movs	r2, #0
 801a6b6:	2300      	movs	r3, #0
 801a6b8:	f00e fcbe 	bl	8029038 <__aeabi_dcmpeq>
 801a6bc:	b140      	cbz	r0, 801a6d0 <cblas_zgemm+0x170>
 801a6be:	ec51 0b1f 	vmov	r0, r1, d15
 801a6c2:	2200      	movs	r2, #0
 801a6c4:	2300      	movs	r3, #0
 801a6c6:	f00e fcb7 	bl	8029038 <__aeabi_dcmpeq>
 801a6ca:	2800      	cmp	r0, #0
 801a6cc:	f040 8109 	bne.w	801a8e2 <cblas_zgemm+0x382>
    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 801a6d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801a6d2:	2b6f      	cmp	r3, #111	; 0x6f
 801a6d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801a6d6:	f000 8215 	beq.w	801ab04 <cblas_zgemm+0x5a4>
    } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 801a6da:	2b6f      	cmp	r3, #111	; 0x6f
 801a6dc:	f000 842b 	beq.w	801af36 <cblas_zgemm+0x9d6>
      for (i = 0; i < n1; i++) {
 801a6e0:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a6e2:	2b00      	cmp	r3, #0
 801a6e4:	f340 80fd 	ble.w	801a8e2 <cblas_zgemm+0x382>
 801a6e8:	2300      	movs	r3, #0
 801a6ea:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801a6ec:	930b      	str	r3, [sp, #44]	; 0x2c
 801a6ee:	930c      	str	r3, [sp, #48]	; 0x30
 801a6f0:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801a6f2:	0112      	lsls	r2, r2, #4
 801a6f4:	011b      	lsls	r3, r3, #4
 801a6f6:	9202      	str	r2, [sp, #8]
 801a6f8:	930d      	str	r3, [sp, #52]	; 0x34
 801a6fa:	9a04      	ldr	r2, [sp, #16]
 801a6fc:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a6fe:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a702:	9308      	str	r3, [sp, #32]
 801a704:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801a706:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 801a708:	3308      	adds	r3, #8
 801a70a:	9309      	str	r3, [sp, #36]	; 0x24
 801a70c:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 801a70e:	011b      	lsls	r3, r3, #4
 801a710:	930a      	str	r3, [sp, #40]	; 0x28
 801a712:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801a714:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a718:	930e      	str	r3, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 801a71a:	9b04      	ldr	r3, [sp, #16]
 801a71c:	2b00      	cmp	r3, #0
 801a71e:	f340 80ce 	ble.w	801a8be <cblas_zgemm+0x35e>
 801a722:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a724:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801a726:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a72a:	9306      	str	r3, [sp, #24]
 801a72c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801a72e:	9301      	str	r3, [sp, #4]
 801a730:	2300      	movs	r3, #0
 801a732:	9303      	str	r3, [sp, #12]
          for (k = 0; k < K; k++) {
 801a734:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801a736:	2b00      	cmp	r3, #0
 801a738:	f340 8510 	ble.w	801b15c <cblas_zgemm+0xbfc>
 801a73c:	9807      	ldr	r0, [sp, #28]
 801a73e:	f00e f9a9 	bl	8028a94 <__aeabi_i2d>
 801a742:	4602      	mov	r2, r0
 801a744:	460b      	mov	r3, r1
 801a746:	9805      	ldr	r0, [sp, #20]
 801a748:	ec43 2b1c 	vmov	d12, r2, r3
 801a74c:	f00e f9a2 	bl	8028a94 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 801a750:	ed9f 7b6b 	vldr	d7, [pc, #428]	; 801a900 <cblas_zgemm+0x3a0>
 801a754:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801a756:	9a03      	ldr	r2, [sp, #12]
          for (k = 0; k < K; k++) {
 801a758:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
          BASE temp_imag = 0.0;
 801a75c:	eeb0 ba47 	vmov.f32	s22, s14
 801a760:	eef0 ba67 	vmov.f32	s23, s15
 801a764:	ec41 0b1d 	vmov	d13, r0, r1
          BASE temp_real = 0.0;
 801a768:	eeb0 aa47 	vmov.f32	s20, s14
 801a76c:	eef0 aa67 	vmov.f32	s21, s15
 801a770:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801a774:	e9db 2300 	ldrd	r2, r3, [fp]
 801a778:	ec51 0b1c 	vmov	r0, r1, d12
 801a77c:	f00e f9f4 	bl	8028b68 <__aeabi_dmul>
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801a780:	e9da 2302 	ldrd	r2, r3, [sl, #8]
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801a784:	4606      	mov	r6, r0
 801a786:	460f      	mov	r7, r1
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801a788:	ec51 0b1d 	vmov	r0, r1, d13
 801a78c:	f00e f9ec 	bl	8028b68 <__aeabi_dmul>
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 801a790:	ed9a 9b00 	vldr	d9, [sl]
            const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 801a794:	ed1b 8b02 	vldr	d8, [fp, #-8]
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 801a798:	ec53 2b19 	vmov	r2, r3, d9
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801a79c:	4680      	mov	r8, r0
 801a79e:	4689      	mov	r9, r1
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 801a7a0:	ec51 0b18 	vmov	r0, r1, d8
 801a7a4:	f00e f9e0 	bl	8028b68 <__aeabi_dmul>
 801a7a8:	4642      	mov	r2, r8
 801a7aa:	4604      	mov	r4, r0
 801a7ac:	460d      	mov	r5, r1
 801a7ae:	464b      	mov	r3, r9
 801a7b0:	4630      	mov	r0, r6
 801a7b2:	4639      	mov	r1, r7
 801a7b4:	f00e f9d8 	bl	8028b68 <__aeabi_dmul>
 801a7b8:	4602      	mov	r2, r0
 801a7ba:	460b      	mov	r3, r1
 801a7bc:	4620      	mov	r0, r4
 801a7be:	4629      	mov	r1, r5
 801a7c0:	f00e f81a 	bl	80287f8 <__aeabi_dsub>
 801a7c4:	4602      	mov	r2, r0
 801a7c6:	460b      	mov	r3, r1
 801a7c8:	ec51 0b1a 	vmov	r0, r1, d10
 801a7cc:	f00e f816 	bl	80287fc <__adddf3>
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 801a7d0:	4642      	mov	r2, r8
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 801a7d2:	4604      	mov	r4, r0
 801a7d4:	460d      	mov	r5, r1
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 801a7d6:	464b      	mov	r3, r9
 801a7d8:	ec51 0b18 	vmov	r0, r1, d8
 801a7dc:	f00e f9c4 	bl	8028b68 <__aeabi_dmul>
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 801a7e0:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 801a7e4:	ec53 2b19 	vmov	r2, r3, d9
 801a7e8:	4604      	mov	r4, r0
 801a7ea:	460d      	mov	r5, r1
 801a7ec:	4630      	mov	r0, r6
 801a7ee:	4639      	mov	r1, r7
 801a7f0:	f00e f9ba 	bl	8028b68 <__aeabi_dmul>
 801a7f4:	4602      	mov	r2, r0
 801a7f6:	460b      	mov	r3, r1
 801a7f8:	4620      	mov	r0, r4
 801a7fa:	4629      	mov	r1, r5
 801a7fc:	f00d fffe 	bl	80287fc <__adddf3>
 801a800:	460b      	mov	r3, r1
 801a802:	4602      	mov	r2, r0
 801a804:	ec51 0b1b 	vmov	r0, r1, d11
 801a808:	f00d fff8 	bl	80287fc <__adddf3>
 801a80c:	9b02      	ldr	r3, [sp, #8]
 801a80e:	449b      	add	fp, r3
          for (k = 0; k < K; k++) {
 801a810:	9b01      	ldr	r3, [sp, #4]
 801a812:	f10a 0a10 	add.w	sl, sl, #16
 801a816:	4553      	cmp	r3, sl
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 801a818:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < K; k++) {
 801a81c:	d1aa      	bne.n	801a774 <cblas_zgemm+0x214>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801a81e:	ec53 2b1a 	vmov	r2, r3, d10
 801a822:	ec51 0b1e 	vmov	r0, r1, d14
 801a826:	f00e f99f 	bl	8028b68 <__aeabi_dmul>
 801a82a:	ec5a 9b1b 	vmov	r9, sl, d11
 801a82e:	ec58 7b1f 	vmov	r7, r8, d15
 801a832:	4604      	mov	r4, r0
 801a834:	460d      	mov	r5, r1
 801a836:	ee1b 2a10 	vmov	r2, s22
 801a83a:	4653      	mov	r3, sl
 801a83c:	ee1f 0a10 	vmov	r0, s30
 801a840:	4641      	mov	r1, r8
 801a842:	f00e f991 	bl	8028b68 <__aeabi_dmul>
 801a846:	4602      	mov	r2, r0
 801a848:	460b      	mov	r3, r1
 801a84a:	4620      	mov	r0, r4
 801a84c:	4629      	mov	r1, r5
 801a84e:	f00d ffd3 	bl	80287f8 <__aeabi_dsub>
 801a852:	9e06      	ldr	r6, [sp, #24]
 801a854:	4602      	mov	r2, r0
 801a856:	460b      	mov	r3, r1
 801a858:	e9d6 0100 	ldrd	r0, r1, [r6]
 801a85c:	f00d ffce 	bl	80287fc <__adddf3>
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801a860:	ee1b 2a10 	vmov	r2, s22
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801a864:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801a868:	4653      	mov	r3, sl
 801a86a:	ec51 0b1e 	vmov	r0, r1, d14
 801a86e:	f00e f97b 	bl	8028b68 <__aeabi_dmul>
 801a872:	ec53 2b1a 	vmov	r2, r3, d10
 801a876:	4604      	mov	r4, r0
 801a878:	460d      	mov	r5, r1
 801a87a:	ee1f 0a10 	vmov	r0, s30
 801a87e:	4641      	mov	r1, r8
 801a880:	f00e f972 	bl	8028b68 <__aeabi_dmul>
 801a884:	4602      	mov	r2, r0
 801a886:	460b      	mov	r3, r1
 801a888:	4620      	mov	r0, r4
 801a88a:	4629      	mov	r1, r5
 801a88c:	f00d ffb6 	bl	80287fc <__adddf3>
 801a890:	4602      	mov	r2, r0
 801a892:	460b      	mov	r3, r1
 801a894:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801a898:	f00d ffb0 	bl	80287fc <__adddf3>
 801a89c:	9a03      	ldr	r2, [sp, #12]
 801a89e:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801a8a2:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801a8a4:	440a      	add	r2, r1
 801a8a6:	9203      	str	r2, [sp, #12]
 801a8a8:	990a      	ldr	r1, [sp, #40]	; 0x28
 801a8aa:	9a01      	ldr	r2, [sp, #4]
 801a8ac:	440a      	add	r2, r1
 801a8ae:	9201      	str	r2, [sp, #4]
 801a8b0:	9a08      	ldr	r2, [sp, #32]
 801a8b2:	f106 0310 	add.w	r3, r6, #16
 801a8b6:	429a      	cmp	r2, r3
 801a8b8:	9306      	str	r3, [sp, #24]
 801a8ba:	f47f af3b 	bne.w	801a734 <cblas_zgemm+0x1d4>
      for (i = 0; i < n1; i++) {
 801a8be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801a8c0:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801a8c2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801a8c4:	440a      	add	r2, r1
 801a8c6:	920b      	str	r2, [sp, #44]	; 0x2c
 801a8c8:	990d      	ldr	r1, [sp, #52]	; 0x34
 801a8ca:	9a08      	ldr	r2, [sp, #32]
 801a8cc:	440a      	add	r2, r1
 801a8ce:	9208      	str	r2, [sp, #32]
 801a8d0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801a8d2:	3210      	adds	r2, #16
 801a8d4:	9209      	str	r2, [sp, #36]	; 0x24
 801a8d6:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801a8d8:	3301      	adds	r3, #1
 801a8da:	429a      	cmp	r2, r3
 801a8dc:	930c      	str	r3, [sp, #48]	; 0x30
 801a8de:	f47f af1c 	bne.w	801a71a <cblas_zgemm+0x1ba>
#define BASE double
#include "source_gemm_c.h"
#undef BASE
}
 801a8e2:	b011      	add	sp, #68	; 0x44
 801a8e4:	ecbd 8b10 	vpop	{d8-d15}
 801a8e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801a8ec:	3865      	subs	r0, #101	; 0x65
 801a8ee:	2801      	cmp	r0, #1
 801a8f0:	bf94      	ite	ls
 801a8f2:	2000      	movls	r0, #0
 801a8f4:	2001      	movhi	r0, #1
 801a8f6:	2170      	movs	r1, #112	; 0x70
 801a8f8:	e64d      	b.n	801a596 <cblas_zgemm+0x36>
 801a8fa:	bf00      	nop
 801a8fc:	f3af 8000 	nop.w
	...
 801a908:	3ff00000 	.word	0x3ff00000
 801a90c:	2d65      	cmp	r5, #101	; 0x65
 801a90e:	f04f 0006 	mov.w	r0, #6
 801a912:	f000 809e 	beq.w	801aa52 <cblas_zgemm+0x4f2>
 801a916:	2d66      	cmp	r5, #102	; 0x66
 801a918:	d11e      	bne.n	801a958 <cblas_zgemm+0x3f8>
 801a91a:	2a6f      	cmp	r2, #111	; 0x6f
 801a91c:	bf0c      	ite	eq
 801a91e:	9b2b      	ldreq	r3, [sp, #172]	; 0xac
 801a920:	9b2a      	ldrne	r3, [sp, #168]	; 0xa8
 801a922:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801a924:	2b01      	cmp	r3, #1
 801a926:	bfb8      	it	lt
 801a928:	2301      	movlt	r3, #1
 801a92a:	4293      	cmp	r3, r2
 801a92c:	bfc8      	it	gt
 801a92e:	200b      	movgt	r0, #11
 801a930:	296f      	cmp	r1, #111	; 0x6f
 801a932:	f000 83ec 	beq.w	801b10e <cblas_zgemm+0xbae>
 801a936:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801a938:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 801a93a:	2b01      	cmp	r3, #1
 801a93c:	bfb8      	it	lt
 801a93e:	2301      	movlt	r3, #1
 801a940:	4293      	cmp	r3, r2
 801a942:	f300 845d 	bgt.w	801b200 <cblas_zgemm+0xca0>
 801a946:	9b04      	ldr	r3, [sp, #16]
 801a948:	2b01      	cmp	r3, #1
 801a94a:	bfb8      	it	lt
 801a94c:	2301      	movlt	r3, #1
 801a94e:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 801a950:	429a      	cmp	r2, r3
 801a952:	f6bf ae37 	bge.w	801a5c4 <cblas_zgemm+0x64>
 801a956:	200e      	movs	r0, #14
 801a958:	4a67      	ldr	r2, [pc, #412]	; (801aaf8 <cblas_zgemm+0x598>)
 801a95a:	4968      	ldr	r1, [pc, #416]	; (801aafc <cblas_zgemm+0x59c>)
 801a95c:	f00d fed4 	bl	8028708 <cblas_xerbla>
 801a960:	e633      	b.n	801a5ca <cblas_zgemm+0x6a>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801a962:	4b67      	ldr	r3, [pc, #412]	; (801ab00 <cblas_zgemm+0x5a0>)
 801a964:	4650      	mov	r0, sl
 801a966:	4659      	mov	r1, fp
 801a968:	f00e fb66 	bl	8029038 <__aeabi_dcmpeq>
 801a96c:	b140      	cbz	r0, 801a980 <cblas_zgemm+0x420>
 801a96e:	ec51 0b18 	vmov	r0, r1, d8
 801a972:	2200      	movs	r2, #0
 801a974:	2300      	movs	r3, #0
 801a976:	f00e fb5f 	bl	8029038 <__aeabi_dcmpeq>
 801a97a:	2800      	cmp	r0, #0
 801a97c:	f47f ae98 	bne.w	801a6b0 <cblas_zgemm+0x150>
      for (i = 0; i < n1; i++) {
 801a980:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a982:	2b00      	cmp	r3, #0
 801a984:	f77f ae94 	ble.w	801a6b0 <cblas_zgemm+0x150>
 801a988:	9a04      	ldr	r2, [sp, #16]
 801a98a:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 801a98e:	011b      	lsls	r3, r3, #4
 801a990:	9306      	str	r3, [sp, #24]
 801a992:	3308      	adds	r3, #8
 801a994:	9308      	str	r3, [sp, #32]
 801a996:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801a998:	011b      	lsls	r3, r3, #4
 801a99a:	9303      	str	r3, [sp, #12]
 801a99c:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a99e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a9a2:	9301      	str	r3, [sp, #4]
 801a9a4:	2300      	movs	r3, #0
 801a9a6:	9302      	str	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 801a9a8:	9b04      	ldr	r3, [sp, #16]
 801a9aa:	2b00      	cmp	r3, #0
 801a9ac:	dd3e      	ble.n	801aa2c <cblas_zgemm+0x4cc>
 801a9ae:	9b06      	ldr	r3, [sp, #24]
 801a9b0:	9a08      	ldr	r2, [sp, #32]
 801a9b2:	4619      	mov	r1, r3
 801a9b4:	9b01      	ldr	r3, [sp, #4]
 801a9b6:	eb01 0803 	add.w	r8, r1, r3
 801a9ba:	eb02 0903 	add.w	r9, r2, r3
          const BASE Cij_real = REAL(C, ldc * i + j);
 801a9be:	e959 4502 	ldrd	r4, r5, [r9, #-8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801a9c2:	4650      	mov	r0, sl
 801a9c4:	4622      	mov	r2, r4
 801a9c6:	462b      	mov	r3, r5
 801a9c8:	4659      	mov	r1, fp
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 801a9ca:	e9d8 6702 	ldrd	r6, r7, [r8, #8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801a9ce:	f00e f8cb 	bl	8028b68 <__aeabi_dmul>
 801a9d2:	4632      	mov	r2, r6
 801a9d4:	ec41 0b19 	vmov	d9, r0, r1
 801a9d8:	463b      	mov	r3, r7
 801a9da:	ec51 0b18 	vmov	r0, r1, d8
 801a9de:	f00e f8c3 	bl	8028b68 <__aeabi_dmul>
 801a9e2:	4602      	mov	r2, r0
 801a9e4:	460b      	mov	r3, r1
 801a9e6:	ec51 0b19 	vmov	r0, r1, d9
 801a9ea:	f00d ff05 	bl	80287f8 <__aeabi_dsub>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801a9ee:	4632      	mov	r2, r6
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801a9f0:	e949 0102 	strd	r0, r1, [r9, #-8]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801a9f4:	463b      	mov	r3, r7
 801a9f6:	4650      	mov	r0, sl
 801a9f8:	4659      	mov	r1, fp
 801a9fa:	f00e f8b5 	bl	8028b68 <__aeabi_dmul>
 801a9fe:	4622      	mov	r2, r4
 801aa00:	462b      	mov	r3, r5
 801aa02:	4604      	mov	r4, r0
 801aa04:	460d      	mov	r5, r1
 801aa06:	ec51 0b18 	vmov	r0, r1, d8
 801aa0a:	f00e f8ad 	bl	8028b68 <__aeabi_dmul>
 801aa0e:	460b      	mov	r3, r1
 801aa10:	4602      	mov	r2, r0
 801aa12:	4629      	mov	r1, r5
 801aa14:	4620      	mov	r0, r4
 801aa16:	f00d fef1 	bl	80287fc <__adddf3>
        for (j = 0; j < n2; j++) {
 801aa1a:	9b01      	ldr	r3, [sp, #4]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801aa1c:	e9c8 0102 	strd	r0, r1, [r8, #8]
        for (j = 0; j < n2; j++) {
 801aa20:	f108 0810 	add.w	r8, r8, #16
 801aa24:	4543      	cmp	r3, r8
 801aa26:	f109 0910 	add.w	r9, r9, #16
 801aa2a:	d1c8      	bne.n	801a9be <cblas_zgemm+0x45e>
      for (i = 0; i < n1; i++) {
 801aa2c:	9a01      	ldr	r2, [sp, #4]
 801aa2e:	9903      	ldr	r1, [sp, #12]
 801aa30:	9b02      	ldr	r3, [sp, #8]
 801aa32:	440a      	add	r2, r1
 801aa34:	9201      	str	r2, [sp, #4]
 801aa36:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801aa38:	3301      	adds	r3, #1
 801aa3a:	429a      	cmp	r2, r3
 801aa3c:	9302      	str	r3, [sp, #8]
 801aa3e:	d1b3      	bne.n	801a9a8 <cblas_zgemm+0x448>
 801aa40:	e636      	b.n	801a6b0 <cblas_zgemm+0x150>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801aa42:	2b00      	cmp	r3, #0
 801aa44:	f6ff af62 	blt.w	801a90c <cblas_zgemm+0x3ac>
 801aa48:	2d65      	cmp	r5, #101	; 0x65
 801aa4a:	f04f 0005 	mov.w	r0, #5
 801aa4e:	f47f af62 	bne.w	801a916 <cblas_zgemm+0x3b6>
 801aa52:	2a6f      	cmp	r2, #111	; 0x6f
 801aa54:	bf0c      	ite	eq
 801aa56:	9b2b      	ldreq	r3, [sp, #172]	; 0xac
 801aa58:	9b04      	ldrne	r3, [sp, #16]
 801aa5a:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 801aa5c:	2b01      	cmp	r3, #1
 801aa5e:	bfb8      	it	lt
 801aa60:	2301      	movlt	r3, #1
 801aa62:	4293      	cmp	r3, r2
 801aa64:	bfc8      	it	gt
 801aa66:	2009      	movgt	r0, #9
 801aa68:	296f      	cmp	r1, #111	; 0x6f
 801aa6a:	f000 83a3 	beq.w	801b1b4 <cblas_zgemm+0xc54>
 801aa6e:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801aa70:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801aa72:	2b01      	cmp	r3, #1
 801aa74:	bfb8      	it	lt
 801aa76:	2301      	movlt	r3, #1
 801aa78:	4293      	cmp	r3, r2
 801aa7a:	f340 8162 	ble.w	801ad42 <cblas_zgemm+0x7e2>
 801aa7e:	982a      	ldr	r0, [sp, #168]	; 0xa8
 801aa80:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801aa82:	4a1d      	ldr	r2, [pc, #116]	; (801aaf8 <cblas_zgemm+0x598>)
 801aa84:	491d      	ldr	r1, [pc, #116]	; (801aafc <cblas_zgemm+0x59c>)
 801aa86:	2801      	cmp	r0, #1
 801aa88:	bfb8      	it	lt
 801aa8a:	2001      	movlt	r0, #1
 801aa8c:	4283      	cmp	r3, r0
 801aa8e:	bfb4      	ite	lt
 801aa90:	200e      	movlt	r0, #14
 801aa92:	200b      	movge	r0, #11
 801aa94:	f00d fe38 	bl	8028708 <cblas_xerbla>
 801aa98:	e597      	b.n	801a5ca <cblas_zgemm+0x6a>
 801aa9a:	2971      	cmp	r1, #113	; 0x71
 801aa9c:	f000 8399 	beq.w	801b1d2 <cblas_zgemm+0xc72>
 801aaa0:	2a71      	cmp	r2, #113	; 0x71
 801aaa2:	f000 8342 	beq.w	801b12a <cblas_zgemm+0xbca>
 801aaa6:	f1a6 036f 	sub.w	r3, r6, #111	; 0x6f
 801aaaa:	2b02      	cmp	r3, #2
 801aaac:	4611      	mov	r1, r2
 801aaae:	4632      	mov	r2, r6
 801aab0:	f63f ad70 	bhi.w	801a594 <cblas_zgemm+0x34>
 801aab4:	e134      	b.n	801ad20 <cblas_zgemm+0x7c0>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 801aab6:	2e71      	cmp	r6, #113	; 0x71
 801aab8:	f000 839c 	beq.w	801b1f4 <cblas_zgemm+0xc94>
 801aabc:	2e6f      	cmp	r6, #111	; 0x6f
 801aabe:	bf0c      	ite	eq
 801aac0:	236f      	moveq	r3, #111	; 0x6f
 801aac2:	2370      	movne	r3, #112	; 0x70
 801aac4:	9309      	str	r3, [sp, #36]	; 0x24
 801aac6:	2301      	movs	r3, #1
 801aac8:	9307      	str	r3, [sp, #28]
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801aaca:	e9dd 032e 	ldrd	r0, r3, [sp, #184]	; 0xb8
 801aace:	9930      	ldr	r1, [sp, #192]	; 0xc0
 801aad0:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801aad2:	9030      	str	r0, [sp, #192]	; 0xc0
 801aad4:	2c71      	cmp	r4, #113	; 0x71
 801aad6:	9804      	ldr	r0, [sp, #16]
 801aad8:	902a      	str	r0, [sp, #168]	; 0xa8
 801aada:	912e      	str	r1, [sp, #184]	; 0xb8
 801aadc:	9204      	str	r2, [sp, #16]
 801aade:	f000 837f 	beq.w	801b1e0 <cblas_zgemm+0xc80>
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801aae2:	2c6f      	cmp	r4, #111	; 0x6f
 801aae4:	f040 8132 	bne.w	801ad4c <cblas_zgemm+0x7ec>
      F = (const BASE *)A;
 801aae8:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 801aaea:	922f      	str	r2, [sp, #188]	; 0xbc
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801aaec:	2201      	movs	r2, #1
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801aaee:	940a      	str	r4, [sp, #40]	; 0x28
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801aaf0:	9205      	str	r2, [sp, #20]
      G = (const BASE *)B;
 801aaf2:	932d      	str	r3, [sp, #180]	; 0xb4
 801aaf4:	e5a8      	b.n	801a648 <cblas_zgemm+0xe8>
 801aaf6:	bf00      	nop
 801aaf8:	08031108 	.word	0x08031108
 801aafc:	080312c0 	.word	0x080312c0
 801ab00:	3ff00000 	.word	0x3ff00000
    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 801ab04:	2b6f      	cmp	r3, #111	; 0x6f
 801ab06:	f000 8129 	beq.w	801ad5c <cblas_zgemm+0x7fc>
      for (i = 0; i < n1; i++) {
 801ab0a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801ab0c:	2b00      	cmp	r3, #0
 801ab0e:	f77f aee8 	ble.w	801a8e2 <cblas_zgemm+0x382>
 801ab12:	9930      	ldr	r1, [sp, #192]	; 0xc0
 801ab14:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801ab16:	9308      	str	r3, [sp, #32]
 801ab18:	0109      	lsls	r1, r1, #4
 801ab1a:	910b      	str	r1, [sp, #44]	; 0x2c
 801ab1c:	992b      	ldr	r1, [sp, #172]	; 0xac
 801ab1e:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 801ab22:	9301      	str	r3, [sp, #4]
 801ab24:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801ab26:	2200      	movs	r2, #0
 801ab28:	011b      	lsls	r3, r3, #4
 801ab2a:	9209      	str	r2, [sp, #36]	; 0x24
 801ab2c:	920a      	str	r2, [sp, #40]	; 0x28
 801ab2e:	930c      	str	r3, [sp, #48]	; 0x30
 801ab30:	9a04      	ldr	r2, [sp, #16]
 801ab32:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801ab34:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ab38:	9306      	str	r3, [sp, #24]
        for (j = 0; j < n2; j++) {
 801ab3a:	9b04      	ldr	r3, [sp, #16]
 801ab3c:	2b00      	cmp	r3, #0
 801ab3e:	f340 80c8 	ble.w	801acd2 <cblas_zgemm+0x772>
 801ab42:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801ab44:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801ab46:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ab4a:	9303      	str	r3, [sp, #12]
 801ab4c:	2300      	movs	r3, #0
 801ab4e:	9302      	str	r3, [sp, #8]
          for (k = 0; k < K; k++) {
 801ab50:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801ab52:	2b00      	cmp	r3, #0
 801ab54:	f340 830e 	ble.w	801b174 <cblas_zgemm+0xc14>
 801ab58:	9807      	ldr	r0, [sp, #28]
 801ab5a:	f00d ff9b 	bl	8028a94 <__aeabi_i2d>
 801ab5e:	4602      	mov	r2, r0
 801ab60:	460b      	mov	r3, r1
 801ab62:	9805      	ldr	r0, [sp, #20]
 801ab64:	ec43 2b1c 	vmov	d12, r2, r3
 801ab68:	f00d ff94 	bl	8028a94 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 801ab6c:	ed9f 7b8e 	vldr	d7, [pc, #568]	; 801ada8 <cblas_zgemm+0x848>
 801ab70:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801ab72:	9a02      	ldr	r2, [sp, #8]
          for (k = 0; k < K; k++) {
 801ab74:	f8dd b020 	ldr.w	fp, [sp, #32]
          BASE temp_imag = 0.0;
 801ab78:	eeb0 ba47 	vmov.f32	s22, s14
 801ab7c:	eef0 ba67 	vmov.f32	s23, s15
 801ab80:	ec41 0b1d 	vmov	d13, r0, r1
          BASE temp_real = 0.0;
 801ab84:	eeb0 aa47 	vmov.f32	s20, s14
 801ab88:	eef0 aa67 	vmov.f32	s21, s15
 801ab8c:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801ab90:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801ab94:	ec51 0b1c 	vmov	r0, r1, d12
 801ab98:	f00d ffe6 	bl	8028b68 <__aeabi_dmul>
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801ab9c:	e9da 2302 	ldrd	r2, r3, [sl, #8]
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801aba0:	4606      	mov	r6, r0
 801aba2:	460f      	mov	r7, r1
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801aba4:	ec51 0b1d 	vmov	r0, r1, d13
 801aba8:	f00d ffde 	bl	8028b68 <__aeabi_dmul>
            const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 801abac:	ed9b 8b00 	vldr	d8, [fp]
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 801abb0:	ed9a 9b00 	vldr	d9, [sl]
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801abb4:	4680      	mov	r8, r0
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 801abb6:	ec53 2b19 	vmov	r2, r3, d9
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801abba:	4689      	mov	r9, r1
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 801abbc:	ec51 0b18 	vmov	r0, r1, d8
 801abc0:	f00d ffd2 	bl	8028b68 <__aeabi_dmul>
 801abc4:	4642      	mov	r2, r8
 801abc6:	4604      	mov	r4, r0
 801abc8:	460d      	mov	r5, r1
 801abca:	464b      	mov	r3, r9
 801abcc:	4630      	mov	r0, r6
 801abce:	4639      	mov	r1, r7
 801abd0:	f00d ffca 	bl	8028b68 <__aeabi_dmul>
 801abd4:	4602      	mov	r2, r0
 801abd6:	460b      	mov	r3, r1
 801abd8:	4620      	mov	r0, r4
 801abda:	4629      	mov	r1, r5
 801abdc:	f00d fe0c 	bl	80287f8 <__aeabi_dsub>
 801abe0:	4602      	mov	r2, r0
 801abe2:	460b      	mov	r3, r1
 801abe4:	ec51 0b1a 	vmov	r0, r1, d10
 801abe8:	f00d fe08 	bl	80287fc <__adddf3>
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 801abec:	4642      	mov	r2, r8
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 801abee:	4604      	mov	r4, r0
 801abf0:	460d      	mov	r5, r1
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 801abf2:	464b      	mov	r3, r9
 801abf4:	ec51 0b18 	vmov	r0, r1, d8
 801abf8:	f00d ffb6 	bl	8028b68 <__aeabi_dmul>
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 801abfc:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 801ac00:	ec53 2b19 	vmov	r2, r3, d9
 801ac04:	4604      	mov	r4, r0
 801ac06:	460d      	mov	r5, r1
 801ac08:	4630      	mov	r0, r6
 801ac0a:	4639      	mov	r1, r7
 801ac0c:	f00d ffac 	bl	8028b68 <__aeabi_dmul>
 801ac10:	4602      	mov	r2, r0
 801ac12:	460b      	mov	r3, r1
 801ac14:	4620      	mov	r0, r4
 801ac16:	4629      	mov	r1, r5
 801ac18:	f00d fdf0 	bl	80287fc <__adddf3>
 801ac1c:	460b      	mov	r3, r1
 801ac1e:	4602      	mov	r2, r0
 801ac20:	ec51 0b1b 	vmov	r0, r1, d11
 801ac24:	f00d fdea 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 801ac28:	9b01      	ldr	r3, [sp, #4]
 801ac2a:	f10b 0b10 	add.w	fp, fp, #16
 801ac2e:	455b      	cmp	r3, fp
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 801ac30:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < K; k++) {
 801ac34:	f10a 0a10 	add.w	sl, sl, #16
 801ac38:	d1aa      	bne.n	801ab90 <cblas_zgemm+0x630>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801ac3a:	ec53 2b1a 	vmov	r2, r3, d10
 801ac3e:	ec51 0b1e 	vmov	r0, r1, d14
 801ac42:	f00d ff91 	bl	8028b68 <__aeabi_dmul>
 801ac46:	ec5a 9b1b 	vmov	r9, sl, d11
 801ac4a:	ec58 7b1f 	vmov	r7, r8, d15
 801ac4e:	4604      	mov	r4, r0
 801ac50:	460d      	mov	r5, r1
 801ac52:	ee1b 2a10 	vmov	r2, s22
 801ac56:	4653      	mov	r3, sl
 801ac58:	ee1f 0a10 	vmov	r0, s30
 801ac5c:	4641      	mov	r1, r8
 801ac5e:	f00d ff83 	bl	8028b68 <__aeabi_dmul>
 801ac62:	4602      	mov	r2, r0
 801ac64:	460b      	mov	r3, r1
 801ac66:	4620      	mov	r0, r4
 801ac68:	4629      	mov	r1, r5
 801ac6a:	f00d fdc5 	bl	80287f8 <__aeabi_dsub>
 801ac6e:	9e03      	ldr	r6, [sp, #12]
 801ac70:	4602      	mov	r2, r0
 801ac72:	460b      	mov	r3, r1
 801ac74:	e9d6 0100 	ldrd	r0, r1, [r6]
 801ac78:	f00d fdc0 	bl	80287fc <__adddf3>
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801ac7c:	ee1b 2a10 	vmov	r2, s22
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801ac80:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801ac84:	4653      	mov	r3, sl
 801ac86:	ec51 0b1e 	vmov	r0, r1, d14
 801ac8a:	f00d ff6d 	bl	8028b68 <__aeabi_dmul>
 801ac8e:	ec53 2b1a 	vmov	r2, r3, d10
 801ac92:	4604      	mov	r4, r0
 801ac94:	460d      	mov	r5, r1
 801ac96:	ee1f 0a10 	vmov	r0, s30
 801ac9a:	4641      	mov	r1, r8
 801ac9c:	f00d ff64 	bl	8028b68 <__aeabi_dmul>
 801aca0:	4602      	mov	r2, r0
 801aca2:	460b      	mov	r3, r1
 801aca4:	4620      	mov	r0, r4
 801aca6:	4629      	mov	r1, r5
 801aca8:	f00d fda8 	bl	80287fc <__adddf3>
 801acac:	4602      	mov	r2, r0
 801acae:	460b      	mov	r3, r1
 801acb0:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801acb4:	f00d fda2 	bl	80287fc <__adddf3>
 801acb8:	9a02      	ldr	r2, [sp, #8]
 801acba:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801acbe:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801acc0:	440a      	add	r2, r1
 801acc2:	9202      	str	r2, [sp, #8]
 801acc4:	9a06      	ldr	r2, [sp, #24]
 801acc6:	f106 0310 	add.w	r3, r6, #16
 801acca:	429a      	cmp	r2, r3
 801accc:	9303      	str	r3, [sp, #12]
 801acce:	f47f af3f 	bne.w	801ab50 <cblas_zgemm+0x5f0>
      for (i = 0; i < n1; i++) {
 801acd2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801acd4:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801acd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801acd8:	440a      	add	r2, r1
 801acda:	9209      	str	r2, [sp, #36]	; 0x24
 801acdc:	990c      	ldr	r1, [sp, #48]	; 0x30
 801acde:	9a06      	ldr	r2, [sp, #24]
 801ace0:	440a      	add	r2, r1
 801ace2:	9908      	ldr	r1, [sp, #32]
 801ace4:	9206      	str	r2, [sp, #24]
 801ace6:	4608      	mov	r0, r1
 801ace8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801acea:	9901      	ldr	r1, [sp, #4]
 801acec:	4410      	add	r0, r2
 801acee:	4411      	add	r1, r2
 801acf0:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801acf2:	9008      	str	r0, [sp, #32]
 801acf4:	3301      	adds	r3, #1
 801acf6:	429a      	cmp	r2, r3
 801acf8:	930a      	str	r3, [sp, #40]	; 0x28
 801acfa:	9101      	str	r1, [sp, #4]
 801acfc:	f47f af1d 	bne.w	801ab3a <cblas_zgemm+0x5da>
 801ad00:	e5ef      	b.n	801a8e2 <cblas_zgemm+0x382>
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 801ad02:	f04f 33ff 	mov.w	r3, #4294967295
 801ad06:	9307      	str	r3, [sp, #28]
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801ad08:	2e71      	cmp	r6, #113	; 0x71
      TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801ad0a:	f04f 0370 	mov.w	r3, #112	; 0x70
 801ad0e:	9309      	str	r3, [sp, #36]	; 0x24
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801ad10:	f47f ac93 	bne.w	801a63a <cblas_zgemm+0xda>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801ad14:	2370      	movs	r3, #112	; 0x70
 801ad16:	930a      	str	r3, [sp, #40]	; 0x28
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801ad18:	f04f 33ff 	mov.w	r3, #4294967295
 801ad1c:	9305      	str	r3, [sp, #20]
 801ad1e:	e493      	b.n	801a648 <cblas_zgemm+0xe8>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801ad20:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 801ad24:	2801      	cmp	r0, #1
 801ad26:	bf94      	ite	ls
 801ad28:	2000      	movls	r0, #0
 801ad2a:	2001      	movhi	r0, #1
 801ad2c:	e433      	b.n	801a596 <cblas_zgemm+0x36>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801ad2e:	ec51 0b18 	vmov	r0, r1, d8
 801ad32:	2200      	movs	r2, #0
 801ad34:	2300      	movs	r3, #0
 801ad36:	f00e f97f 	bl	8029038 <__aeabi_dcmpeq>
 801ad3a:	2800      	cmp	r0, #0
 801ad3c:	f43f ac6c 	beq.w	801a618 <cblas_zgemm+0xb8>
 801ad40:	e5cf      	b.n	801a8e2 <cblas_zgemm+0x382>
 801ad42:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801ad44:	2b01      	cmp	r3, #1
 801ad46:	bfb8      	it	lt
 801ad48:	2301      	movlt	r3, #1
 801ad4a:	e600      	b.n	801a94e <cblas_zgemm+0x3ee>
      F = (const BASE *)A;
 801ad4c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 801ad4e:	922f      	str	r2, [sp, #188]	; 0xbc
      G = (const BASE *)B;
 801ad50:	932d      	str	r3, [sp, #180]	; 0xb4
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801ad52:	2270      	movs	r2, #112	; 0x70
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801ad54:	2301      	movs	r3, #1
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801ad56:	920a      	str	r2, [sp, #40]	; 0x28
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801ad58:	9305      	str	r3, [sp, #20]
 801ad5a:	e475      	b.n	801a648 <cblas_zgemm+0xe8>
      for (k = 0; k < K; k++) {
 801ad5c:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801ad5e:	2b00      	cmp	r3, #0
 801ad60:	f77f adbf 	ble.w	801a8e2 <cblas_zgemm+0x382>
 801ad64:	2300      	movs	r3, #0
 801ad66:	930a      	str	r3, [sp, #40]	; 0x28
 801ad68:	930c      	str	r3, [sp, #48]	; 0x30
 801ad6a:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801ad6c:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801ad6e:	3308      	adds	r3, #8
 801ad70:	930b      	str	r3, [sp, #44]	; 0x2c
 801ad72:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801ad74:	0112      	lsls	r2, r2, #4
 801ad76:	3308      	adds	r3, #8
 801ad78:	9206      	str	r2, [sp, #24]
 801ad7a:	9309      	str	r3, [sp, #36]	; 0x24
        for (i = 0; i < n1; i++) {
 801ad7c:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801ad7e:	2b00      	cmp	r3, #0
 801ad80:	f340 81dc 	ble.w	801b13c <cblas_zgemm+0xbdc>
 801ad84:	9807      	ldr	r0, [sp, #28]
 801ad86:	f00d fe85 	bl	8028a94 <__aeabi_i2d>
 801ad8a:	2300      	movs	r3, #0
 801ad8c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ad8e:	9302      	str	r3, [sp, #8]
 801ad90:	9303      	str	r3, [sp, #12]
 801ad92:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801ad94:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ad98:	9308      	str	r3, [sp, #32]
 801ad9a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ad9c:	9301      	str	r3, [sp, #4]
 801ad9e:	ec41 0b1c 	vmov	d12, r0, r1
 801ada2:	e01c      	b.n	801adde <cblas_zgemm+0x87e>
 801ada4:	f3af 8000 	nop.w
	...
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801adb0:	2200      	movs	r2, #0
 801adb2:	2300      	movs	r3, #0
 801adb4:	4620      	mov	r0, r4
 801adb6:	4629      	mov	r1, r5
 801adb8:	f00e f93e 	bl	8029038 <__aeabi_dcmpeq>
 801adbc:	2800      	cmp	r0, #0
 801adbe:	d055      	beq.n	801ae6c <cblas_zgemm+0x90c>
        for (i = 0; i < n1; i++) {
 801adc0:	9a02      	ldr	r2, [sp, #8]
 801adc2:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801adc4:	9b03      	ldr	r3, [sp, #12]
 801adc6:	440a      	add	r2, r1
 801adc8:	9202      	str	r2, [sp, #8]
 801adca:	9906      	ldr	r1, [sp, #24]
 801adcc:	9a01      	ldr	r2, [sp, #4]
 801adce:	440a      	add	r2, r1
 801add0:	9201      	str	r2, [sp, #4]
 801add2:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801add4:	3301      	adds	r3, #1
 801add6:	429a      	cmp	r2, r3
 801add8:	9303      	str	r3, [sp, #12]
 801adda:	f000 81af 	beq.w	801b13c <cblas_zgemm+0xbdc>
          const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 801adde:	9b01      	ldr	r3, [sp, #4]
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801ade0:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 801ade4:	e953 6702 	ldrd	r6, r7, [r3, #-8]
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801ade8:	e9d3 2300 	ldrd	r2, r3, [r3]
 801adec:	f00d febc 	bl	8028b68 <__aeabi_dmul>
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801adf0:	4632      	mov	r2, r6
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801adf2:	4604      	mov	r4, r0
 801adf4:	460d      	mov	r5, r1
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801adf6:	463b      	mov	r3, r7
 801adf8:	ec51 0b1e 	vmov	r0, r1, d14
 801adfc:	f00d feb4 	bl	8028b68 <__aeabi_dmul>
 801ae00:	ec5b ab1f 	vmov	sl, fp, d15
 801ae04:	4622      	mov	r2, r4
 801ae06:	462b      	mov	r3, r5
 801ae08:	4680      	mov	r8, r0
 801ae0a:	4689      	mov	r9, r1
 801ae0c:	ee1f 0a10 	vmov	r0, s30
 801ae10:	4659      	mov	r1, fp
 801ae12:	f00d fea9 	bl	8028b68 <__aeabi_dmul>
 801ae16:	4602      	mov	r2, r0
 801ae18:	460b      	mov	r3, r1
 801ae1a:	4640      	mov	r0, r8
 801ae1c:	4649      	mov	r1, r9
 801ae1e:	f00d fceb 	bl	80287f8 <__aeabi_dsub>
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801ae22:	4622      	mov	r2, r4
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801ae24:	4680      	mov	r8, r0
 801ae26:	4689      	mov	r9, r1
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801ae28:	462b      	mov	r3, r5
 801ae2a:	ec51 0b1e 	vmov	r0, r1, d14
 801ae2e:	f00d fe9b 	bl	8028b68 <__aeabi_dmul>
 801ae32:	4632      	mov	r2, r6
 801ae34:	4604      	mov	r4, r0
 801ae36:	460d      	mov	r5, r1
 801ae38:	463b      	mov	r3, r7
 801ae3a:	ee1f 0a10 	vmov	r0, s30
 801ae3e:	4659      	mov	r1, fp
 801ae40:	f00d fe92 	bl	8028b68 <__aeabi_dmul>
 801ae44:	4602      	mov	r2, r0
 801ae46:	460b      	mov	r3, r1
 801ae48:	4620      	mov	r0, r4
 801ae4a:	4629      	mov	r1, r5
 801ae4c:	f00d fcd6 	bl	80287fc <__adddf3>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801ae50:	2200      	movs	r2, #0
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801ae52:	4604      	mov	r4, r0
 801ae54:	460d      	mov	r5, r1
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801ae56:	2300      	movs	r3, #0
 801ae58:	4640      	mov	r0, r8
 801ae5a:	4649      	mov	r1, r9
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801ae5c:	ec49 8b1a 	vmov	d10, r8, r9
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801ae60:	ec45 4b19 	vmov	d9, r4, r5
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801ae64:	f00e f8e8 	bl	8029038 <__aeabi_dcmpeq>
 801ae68:	2800      	cmp	r0, #0
 801ae6a:	d1a1      	bne.n	801adb0 <cblas_zgemm+0x850>
            for (j = 0; j < n2; j++) {
 801ae6c:	9b04      	ldr	r3, [sp, #16]
 801ae6e:	2b00      	cmp	r3, #0
 801ae70:	dda6      	ble.n	801adc0 <cblas_zgemm+0x860>
 801ae72:	9805      	ldr	r0, [sp, #20]
 801ae74:	f00d fe0e 	bl	8028a94 <__aeabi_i2d>
 801ae78:	9b04      	ldr	r3, [sp, #16]
 801ae7a:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 801ae7c:	f8dd b020 	ldr.w	fp, [sp, #32]
 801ae80:	461c      	mov	r4, r3
 801ae82:	9b02      	ldr	r3, [sp, #8]
 801ae84:	eb04 0a03 	add.w	sl, r4, r3
 801ae88:	eb02 1a0a 	add.w	sl, r2, sl, lsl #4
 801ae8c:	eb02 1403 	add.w	r4, r2, r3, lsl #4
 801ae90:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801ae92:	ec41 0b1b 	vmov	d11, r0, r1
 801ae96:	eb02 1503 	add.w	r5, r2, r3, lsl #4
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801ae9a:	ed9b 7b00 	vldr	d7, [fp]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801ae9e:	e9db 2302 	ldrd	r2, r3, [fp, #8]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801aea2:	eeb0 8a47 	vmov.f32	s16, s14
 801aea6:	eef0 8a67 	vmov.f32	s17, s15
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801aeaa:	ec51 0b1b 	vmov	r0, r1, d11
 801aeae:	f00d fe5b 	bl	8028b68 <__aeabi_dmul>
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801aeb2:	ec53 2b18 	vmov	r2, r3, d8
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801aeb6:	4680      	mov	r8, r0
 801aeb8:	4689      	mov	r9, r1
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801aeba:	ec51 0b1a 	vmov	r0, r1, d10
 801aebe:	f00d fe53 	bl	8028b68 <__aeabi_dmul>
 801aec2:	4642      	mov	r2, r8
 801aec4:	4606      	mov	r6, r0
 801aec6:	460f      	mov	r7, r1
 801aec8:	464b      	mov	r3, r9
 801aeca:	ec51 0b19 	vmov	r0, r1, d9
 801aece:	f00d fe4b 	bl	8028b68 <__aeabi_dmul>
 801aed2:	4602      	mov	r2, r0
 801aed4:	460b      	mov	r3, r1
 801aed6:	4630      	mov	r0, r6
 801aed8:	4639      	mov	r1, r7
 801aeda:	f00d fc8d 	bl	80287f8 <__aeabi_dsub>
 801aede:	4602      	mov	r2, r0
 801aee0:	460b      	mov	r3, r1
 801aee2:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 801aee6:	f00d fc89 	bl	80287fc <__adddf3>
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801aeea:	4642      	mov	r2, r8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801aeec:	e945 0102 	strd	r0, r1, [r5, #-8]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801aef0:	464b      	mov	r3, r9
 801aef2:	ec51 0b1a 	vmov	r0, r1, d10
 801aef6:	f00d fe37 	bl	8028b68 <__aeabi_dmul>
 801aefa:	ec53 2b18 	vmov	r2, r3, d8
 801aefe:	4606      	mov	r6, r0
 801af00:	460f      	mov	r7, r1
 801af02:	ec51 0b19 	vmov	r0, r1, d9
 801af06:	f00d fe2f 	bl	8028b68 <__aeabi_dmul>
 801af0a:	4602      	mov	r2, r0
 801af0c:	460b      	mov	r3, r1
 801af0e:	4630      	mov	r0, r6
 801af10:	4639      	mov	r1, r7
 801af12:	f00d fc73 	bl	80287fc <__adddf3>
 801af16:	4602      	mov	r2, r0
 801af18:	460b      	mov	r3, r1
 801af1a:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801af1e:	f00d fc6d 	bl	80287fc <__adddf3>
 801af22:	3410      	adds	r4, #16
 801af24:	e944 0102 	strd	r0, r1, [r4, #-8]
            for (j = 0; j < n2; j++) {
 801af28:	45a2      	cmp	sl, r4
 801af2a:	f10b 0b10 	add.w	fp, fp, #16
 801af2e:	f105 0510 	add.w	r5, r5, #16
 801af32:	d1b2      	bne.n	801ae9a <cblas_zgemm+0x93a>
 801af34:	e744      	b.n	801adc0 <cblas_zgemm+0x860>
      for (k = 0; k < K; k++) {
 801af36:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801af38:	2b00      	cmp	r3, #0
 801af3a:	f77f acd2 	ble.w	801a8e2 <cblas_zgemm+0x382>
 801af3e:	2300      	movs	r3, #0
 801af40:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 801af44:	930d      	str	r3, [sp, #52]	; 0x34
 801af46:	9b30      	ldr	r3, [sp, #192]	; 0xc0
 801af48:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801af4a:	011b      	lsls	r3, r3, #4
 801af4c:	930e      	str	r3, [sp, #56]	; 0x38
 801af4e:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801af50:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801af54:	9306      	str	r3, [sp, #24]
 801af56:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801af58:	9a04      	ldr	r2, [sp, #16]
 801af5a:	011b      	lsls	r3, r3, #4
 801af5c:	9308      	str	r3, [sp, #32]
 801af5e:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801af60:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801af64:	930f      	str	r3, [sp, #60]	; 0x3c
 801af66:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801af68:	3308      	adds	r3, #8
 801af6a:	930a      	str	r3, [sp, #40]	; 0x28
        for (i = 0; i < n1; i++) {
 801af6c:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801af6e:	2b00      	cmp	r3, #0
 801af70:	f340 810b 	ble.w	801b18a <cblas_zgemm+0xc2a>
 801af74:	9807      	ldr	r0, [sp, #28]
 801af76:	f00d fd8d 	bl	8028a94 <__aeabi_i2d>
 801af7a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801af7c:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801af7e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801af82:	9301      	str	r3, [sp, #4]
 801af84:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801af86:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801af88:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801af8c:	9309      	str	r3, [sp, #36]	; 0x24
 801af8e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801af90:	9302      	str	r3, [sp, #8]
 801af92:	2300      	movs	r3, #0
 801af94:	ec41 0b1c 	vmov	d12, r0, r1
 801af98:	9303      	str	r3, [sp, #12]
 801af9a:	e016      	b.n	801afca <cblas_zgemm+0xa6a>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801af9c:	2200      	movs	r2, #0
 801af9e:	2300      	movs	r3, #0
 801afa0:	4620      	mov	r0, r4
 801afa2:	4629      	mov	r1, r5
 801afa4:	f00e f848 	bl	8029038 <__aeabi_dcmpeq>
 801afa8:	2800      	cmp	r0, #0
 801afaa:	d04f      	beq.n	801b04c <cblas_zgemm+0xaec>
        for (i = 0; i < n1; i++) {
 801afac:	9a03      	ldr	r2, [sp, #12]
 801afae:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801afb0:	9b01      	ldr	r3, [sp, #4]
 801afb2:	440a      	add	r2, r1
 801afb4:	9203      	str	r2, [sp, #12]
 801afb6:	9908      	ldr	r1, [sp, #32]
 801afb8:	9a02      	ldr	r2, [sp, #8]
 801afba:	440a      	add	r2, r1
 801afbc:	9202      	str	r2, [sp, #8]
 801afbe:	9a06      	ldr	r2, [sp, #24]
 801afc0:	3310      	adds	r3, #16
 801afc2:	429a      	cmp	r2, r3
 801afc4:	9301      	str	r3, [sp, #4]
 801afc6:	f000 80e0 	beq.w	801b18a <cblas_zgemm+0xc2a>
          const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 801afca:	9b01      	ldr	r3, [sp, #4]
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801afcc:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 801afd0:	e9d3 ab00 	ldrd	sl, fp, [r3]
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801afd4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 801afd8:	f00d fdc6 	bl	8028b68 <__aeabi_dmul>
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 801afdc:	4652      	mov	r2, sl
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801afde:	4604      	mov	r4, r0
 801afe0:	460d      	mov	r5, r1
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 801afe2:	465b      	mov	r3, fp
 801afe4:	ec51 0b1e 	vmov	r0, r1, d14
 801afe8:	f00d fdbe 	bl	8028b68 <__aeabi_dmul>
 801afec:	4622      	mov	r2, r4
 801afee:	462b      	mov	r3, r5
 801aff0:	4680      	mov	r8, r0
 801aff2:	4689      	mov	r9, r1
 801aff4:	ec51 0b1f 	vmov	r0, r1, d15
 801aff8:	f00d fdb6 	bl	8028b68 <__aeabi_dmul>
 801affc:	4602      	mov	r2, r0
 801affe:	460b      	mov	r3, r1
 801b000:	4640      	mov	r0, r8
 801b002:	4649      	mov	r1, r9
 801b004:	f00d fbf8 	bl	80287f8 <__aeabi_dsub>
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801b008:	4622      	mov	r2, r4
 801b00a:	462b      	mov	r3, r5
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 801b00c:	4606      	mov	r6, r0
 801b00e:	460f      	mov	r7, r1
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801b010:	ec51 0b1e 	vmov	r0, r1, d14
 801b014:	f00d fda8 	bl	8028b68 <__aeabi_dmul>
 801b018:	4652      	mov	r2, sl
 801b01a:	4604      	mov	r4, r0
 801b01c:	460d      	mov	r5, r1
 801b01e:	465b      	mov	r3, fp
 801b020:	ec51 0b1f 	vmov	r0, r1, d15
 801b024:	f00d fda0 	bl	8028b68 <__aeabi_dmul>
 801b028:	4602      	mov	r2, r0
 801b02a:	460b      	mov	r3, r1
 801b02c:	4620      	mov	r0, r4
 801b02e:	4629      	mov	r1, r5
 801b030:	f00d fbe4 	bl	80287fc <__adddf3>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801b034:	2200      	movs	r2, #0
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801b036:	4604      	mov	r4, r0
 801b038:	460d      	mov	r5, r1
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801b03a:	2300      	movs	r3, #0
 801b03c:	4630      	mov	r0, r6
 801b03e:	4639      	mov	r1, r7
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801b040:	ec45 4b19 	vmov	d9, r4, r5
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801b044:	f00d fff8 	bl	8029038 <__aeabi_dcmpeq>
 801b048:	2800      	cmp	r0, #0
 801b04a:	d1a7      	bne.n	801af9c <cblas_zgemm+0xa3c>
            for (j = 0; j < n2; j++) {
 801b04c:	9b04      	ldr	r3, [sp, #16]
 801b04e:	2b00      	cmp	r3, #0
 801b050:	ddac      	ble.n	801afac <cblas_zgemm+0xa4c>
 801b052:	9805      	ldr	r0, [sp, #20]
 801b054:	f00d fd1e 	bl	8028a94 <__aeabi_i2d>
 801b058:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801b05a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801b05c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801b05e:	9d02      	ldr	r5, [sp, #8]
 801b060:	ec41 0b1b 	vmov	d11, r0, r1
 801b064:	4619      	mov	r1, r3
 801b066:	9b03      	ldr	r3, [sp, #12]
 801b068:	eb01 1a03 	add.w	sl, r1, r3, lsl #4
 801b06c:	eb02 1b03 	add.w	fp, r2, r3, lsl #4
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801b070:	ed94 7b00 	vldr	d7, [r4]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801b074:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801b078:	eeb0 8a47 	vmov.f32	s16, s14
 801b07c:	eef0 8a67 	vmov.f32	s17, s15
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801b080:	ec51 0b1b 	vmov	r0, r1, d11
 801b084:	f00d fd70 	bl	8028b68 <__aeabi_dmul>
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801b088:	ec53 2b18 	vmov	r2, r3, d8
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801b08c:	4680      	mov	r8, r0
 801b08e:	4689      	mov	r9, r1
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801b090:	4630      	mov	r0, r6
 801b092:	4639      	mov	r1, r7
 801b094:	f00d fd68 	bl	8028b68 <__aeabi_dmul>
 801b098:	4642      	mov	r2, r8
 801b09a:	464b      	mov	r3, r9
 801b09c:	ec41 0b1a 	vmov	d10, r0, r1
 801b0a0:	ec51 0b19 	vmov	r0, r1, d9
 801b0a4:	f00d fd60 	bl	8028b68 <__aeabi_dmul>
 801b0a8:	4602      	mov	r2, r0
 801b0aa:	460b      	mov	r3, r1
 801b0ac:	ec51 0b1a 	vmov	r0, r1, d10
 801b0b0:	f00d fba2 	bl	80287f8 <__aeabi_dsub>
 801b0b4:	4602      	mov	r2, r0
 801b0b6:	460b      	mov	r3, r1
 801b0b8:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801b0bc:	f00d fb9e 	bl	80287fc <__adddf3>
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801b0c0:	4642      	mov	r2, r8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801b0c2:	e94b 0102 	strd	r0, r1, [fp, #-8]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801b0c6:	464b      	mov	r3, r9
 801b0c8:	4630      	mov	r0, r6
 801b0ca:	4639      	mov	r1, r7
 801b0cc:	f00d fd4c 	bl	8028b68 <__aeabi_dmul>
 801b0d0:	ec53 2b18 	vmov	r2, r3, d8
 801b0d4:	4680      	mov	r8, r0
 801b0d6:	4689      	mov	r9, r1
 801b0d8:	ec51 0b19 	vmov	r0, r1, d9
 801b0dc:	f00d fd44 	bl	8028b68 <__aeabi_dmul>
 801b0e0:	4602      	mov	r2, r0
 801b0e2:	460b      	mov	r3, r1
 801b0e4:	4640      	mov	r0, r8
 801b0e6:	4649      	mov	r1, r9
 801b0e8:	f00d fb88 	bl	80287fc <__adddf3>
 801b0ec:	4602      	mov	r2, r0
 801b0ee:	460b      	mov	r3, r1
 801b0f0:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801b0f4:	f00d fb82 	bl	80287fc <__adddf3>
 801b0f8:	f10a 0a10 	add.w	sl, sl, #16
 801b0fc:	e94a 0102 	strd	r0, r1, [sl, #-8]
            for (j = 0; j < n2; j++) {
 801b100:	4555      	cmp	r5, sl
 801b102:	f104 0410 	add.w	r4, r4, #16
 801b106:	f10b 0b10 	add.w	fp, fp, #16
 801b10a:	d1b1      	bne.n	801b070 <cblas_zgemm+0xb10>
 801b10c:	e74e      	b.n	801afac <cblas_zgemm+0xa4c>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801b10e:	9b04      	ldr	r3, [sp, #16]
 801b110:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 801b112:	2b01      	cmp	r3, #1
 801b114:	bfb8      	it	lt
 801b116:	2301      	movlt	r3, #1
 801b118:	4293      	cmp	r3, r2
 801b11a:	f77f ac18 	ble.w	801a94e <cblas_zgemm+0x3ee>
 801b11e:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 801b120:	4293      	cmp	r3, r2
 801b122:	bfcc      	ite	gt
 801b124:	200e      	movgt	r0, #14
 801b126:	2009      	movle	r0, #9
 801b128:	e416      	b.n	801a958 <cblas_zgemm+0x3f8>
 801b12a:	f1a1 036f 	sub.w	r3, r1, #111	; 0x6f
 801b12e:	2b02      	cmp	r3, #2
 801b130:	460a      	mov	r2, r1
 801b132:	d971      	bls.n	801b218 <cblas_zgemm+0xcb8>
 801b134:	2170      	movs	r1, #112	; 0x70
 801b136:	2002      	movs	r0, #2
 801b138:	f7ff ba32 	b.w	801a5a0 <cblas_zgemm+0x40>
      for (k = 0; k < K; k++) {
 801b13c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801b13e:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801b140:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801b142:	3210      	adds	r2, #16
 801b144:	920b      	str	r2, [sp, #44]	; 0x2c
 801b146:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801b148:	440a      	add	r2, r1
 801b14a:	920a      	str	r2, [sp, #40]	; 0x28
 801b14c:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 801b14e:	3301      	adds	r3, #1
 801b150:	429a      	cmp	r2, r3
 801b152:	930c      	str	r3, [sp, #48]	; 0x30
 801b154:	f47f ae12 	bne.w	801ad7c <cblas_zgemm+0x81c>
 801b158:	f7ff bbc3 	b.w	801a8e2 <cblas_zgemm+0x382>
          BASE temp_imag = 0.0;
 801b15c:	ed9f 7b30 	vldr	d7, [pc, #192]	; 801b220 <cblas_zgemm+0xcc0>
 801b160:	eeb0 ba47 	vmov.f32	s22, s14
 801b164:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 801b168:	eeb0 aa47 	vmov.f32	s20, s14
 801b16c:	eef0 aa67 	vmov.f32	s21, s15
 801b170:	f7ff bb55 	b.w	801a81e <cblas_zgemm+0x2be>
          BASE temp_imag = 0.0;
 801b174:	ed9f 7b2a 	vldr	d7, [pc, #168]	; 801b220 <cblas_zgemm+0xcc0>
 801b178:	eeb0 ba47 	vmov.f32	s22, s14
 801b17c:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 801b180:	eeb0 aa47 	vmov.f32	s20, s14
 801b184:	eef0 aa67 	vmov.f32	s21, s15
 801b188:	e557      	b.n	801ac3a <cblas_zgemm+0x6da>
      for (k = 0; k < K; k++) {
 801b18a:	9a06      	ldr	r2, [sp, #24]
 801b18c:	990e      	ldr	r1, [sp, #56]	; 0x38
 801b18e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801b190:	440a      	add	r2, r1
 801b192:	9206      	str	r2, [sp, #24]
 801b194:	9930      	ldr	r1, [sp, #192]	; 0xc0
 801b196:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801b198:	440a      	add	r2, r1
 801b19a:	920c      	str	r2, [sp, #48]	; 0x30
 801b19c:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801b19e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801b1a0:	440a      	add	r2, r1
 801b1a2:	920b      	str	r2, [sp, #44]	; 0x2c
 801b1a4:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 801b1a6:	3301      	adds	r3, #1
 801b1a8:	429a      	cmp	r2, r3
 801b1aa:	930d      	str	r3, [sp, #52]	; 0x34
 801b1ac:	f47f aede 	bne.w	801af6c <cblas_zgemm+0xa0c>
 801b1b0:	f7ff bb97 	b.w	801a8e2 <cblas_zgemm+0x382>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801b1b4:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801b1b6:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801b1b8:	2b01      	cmp	r3, #1
 801b1ba:	bfb8      	it	lt
 801b1bc:	2301      	movlt	r3, #1
 801b1be:	4293      	cmp	r3, r2
 801b1c0:	f77f abc5 	ble.w	801a94e <cblas_zgemm+0x3ee>
 801b1c4:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 801b1c6:	4293      	cmp	r3, r2
 801b1c8:	bfcc      	ite	gt
 801b1ca:	200e      	movgt	r0, #14
 801b1cc:	200b      	movle	r0, #11
 801b1ce:	f7ff bbc3 	b.w	801a958 <cblas_zgemm+0x3f8>
 801b1d2:	2a71      	cmp	r2, #113	; 0x71
 801b1d4:	d01f      	beq.n	801b216 <cblas_zgemm+0xcb6>
 801b1d6:	4621      	mov	r1, r4
 801b1d8:	2270      	movs	r2, #112	; 0x70
 801b1da:	2000      	movs	r0, #0
 801b1dc:	f7ff b9db 	b.w	801a596 <cblas_zgemm+0x36>
      F = (const BASE *)A;
 801b1e0:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 801b1e2:	922f      	str	r2, [sp, #188]	; 0xbc
      G = (const BASE *)B;
 801b1e4:	932d      	str	r3, [sp, #180]	; 0xb4
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801b1e6:	2270      	movs	r2, #112	; 0x70
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801b1e8:	f04f 33ff 	mov.w	r3, #4294967295
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801b1ec:	920a      	str	r2, [sp, #40]	; 0x28
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801b1ee:	9305      	str	r3, [sp, #20]
 801b1f0:	f7ff ba2a 	b.w	801a648 <cblas_zgemm+0xe8>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 801b1f4:	f04f 33ff 	mov.w	r3, #4294967295
 801b1f8:	9307      	str	r3, [sp, #28]
      TransF = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801b1fa:	2370      	movs	r3, #112	; 0x70
 801b1fc:	9309      	str	r3, [sp, #36]	; 0x24
 801b1fe:	e464      	b.n	801aaca <cblas_zgemm+0x56a>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801b200:	9804      	ldr	r0, [sp, #16]
 801b202:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801b204:	2801      	cmp	r0, #1
 801b206:	bfb8      	it	lt
 801b208:	2001      	movlt	r0, #1
 801b20a:	4283      	cmp	r3, r0
 801b20c:	bfb4      	ite	lt
 801b20e:	200e      	movlt	r0, #14
 801b210:	2009      	movge	r0, #9
 801b212:	f7ff bba1 	b.w	801a958 <cblas_zgemm+0x3f8>
 801b216:	2270      	movs	r2, #112	; 0x70
 801b218:	2000      	movs	r0, #0
 801b21a:	2170      	movs	r1, #112	; 0x70
 801b21c:	f7ff b9bb 	b.w	801a596 <cblas_zgemm+0x36>
	...

0801b228 <cblas_zgemv>:
void
cblas_zgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const void *alpha, const void *A,
             const int lda, const void *X, const int incX, const void *beta,
             void *Y, const int incY)
{
 801b228:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b22c:	ed2d 8b0c 	vpush	{d8-d13}
 801b230:	b091      	sub	sp, #68	; 0x44
 801b232:	460e      	mov	r6, r1
 801b234:	9c26      	ldr	r4, [sp, #152]	; 0x98
 801b236:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 801b238:	9509      	str	r5, [sp, #36]	; 0x24
  const BASE alpha_real = CONST_REAL0(alpha);
 801b23a:	ed94 7b00 	vldr	d7, [r4]
 801b23e:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 801b240:	9506      	str	r5, [sp, #24]
 801b242:	eeb0 ca47 	vmov.f32	s24, s14
 801b246:	eef0 ca67 	vmov.f32	s25, s15
 801b24a:	9d29      	ldr	r5, [sp, #164]	; 0xa4
 801b24c:	910b      	str	r1, [sp, #44]	; 0x2c
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801b24e:	ed94 7b02 	vldr	d7, [r4, #8]
 801b252:	992b      	ldr	r1, [sp, #172]	; 0xac
 801b254:	950d      	str	r5, [sp, #52]	; 0x34
 801b256:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 801b258:	950a      	str	r5, [sp, #40]	; 0x28
 801b25a:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 801b25c:	950c      	str	r5, [sp, #48]	; 0x30
 801b25e:	eeb0 da47 	vmov.f32	s26, s14
 801b262:	eef0 da67 	vmov.f32	s27, s15
 801b266:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 801b268:	9508      	str	r5, [sp, #32]
  const BASE beta_imag = CONST_IMAG0(beta);
 801b26a:	ed91 7b02 	vldr	d7, [r1, #8]
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801b26e:	f1a6 056f 	sub.w	r5, r6, #111	; 0x6f
 801b272:	2d02      	cmp	r5, #2
 801b274:	e9cd 2302 	strd	r2, r3, [sp, #8]
  const BASE beta_imag = CONST_IMAG0(beta);
 801b278:	eeb0 8a47 	vmov.f32	s16, s14
 801b27c:	eef0 8a67 	vmov.f32	s17, s15
  const BASE beta_real = CONST_REAL0(beta);
 801b280:	e9d1 6700 	ldrd	r6, r7, [r1]
 801b284:	9007      	str	r0, [sp, #28]
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801b286:	f200 81b4 	bhi.w	801b5f2 <cblas_zgemv+0x3ca>
 801b28a:	3865      	subs	r0, #101	; 0x65
 801b28c:	2801      	cmp	r0, #1
 801b28e:	bf94      	ite	ls
 801b290:	2000      	movls	r0, #0
 801b292:	2001      	movhi	r0, #1
 801b294:	9b02      	ldr	r3, [sp, #8]
 801b296:	2b00      	cmp	r3, #0
 801b298:	9b03      	ldr	r3, [sp, #12]
 801b29a:	bfb8      	it	lt
 801b29c:	2003      	movlt	r0, #3
 801b29e:	2b00      	cmp	r3, #0
 801b2a0:	9b07      	ldr	r3, [sp, #28]
 801b2a2:	bfb8      	it	lt
 801b2a4:	2004      	movlt	r0, #4
 801b2a6:	2b65      	cmp	r3, #101	; 0x65
 801b2a8:	f000 81fe 	beq.w	801b6a8 <cblas_zgemv+0x480>
 801b2ac:	9b07      	ldr	r3, [sp, #28]
 801b2ae:	2b66      	cmp	r3, #102	; 0x66
 801b2b0:	f000 81b5 	beq.w	801b61e <cblas_zgemv+0x3f6>
 801b2b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b2b6:	2b00      	cmp	r3, #0
 801b2b8:	f040 81aa 	bne.w	801b610 <cblas_zgemv+0x3e8>
 801b2bc:	9b08      	ldr	r3, [sp, #32]
 801b2be:	2b00      	cmp	r3, #0
 801b2c0:	bf14      	ite	ne
 801b2c2:	2009      	movne	r0, #9
 801b2c4:	200c      	moveq	r0, #12
 801b2c6:	4ace      	ldr	r2, [pc, #824]	; (801b600 <cblas_zgemv+0x3d8>)
 801b2c8:	49ce      	ldr	r1, [pc, #824]	; (801b604 <cblas_zgemv+0x3dc>)
 801b2ca:	f00d fa1d 	bl	8028708 <cblas_xerbla>
  if (M == 0 || N == 0)
 801b2ce:	9b02      	ldr	r3, [sp, #8]
 801b2d0:	2b00      	cmp	r3, #0
 801b2d2:	f000 8189 	beq.w	801b5e8 <cblas_zgemv+0x3c0>
 801b2d6:	9b03      	ldr	r3, [sp, #12]
 801b2d8:	2b00      	cmp	r3, #0
 801b2da:	f000 8185 	beq.w	801b5e8 <cblas_zgemv+0x3c0>
  if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801b2de:	ec51 0b1c 	vmov	r0, r1, d12
 801b2e2:	2200      	movs	r2, #0
 801b2e4:	2300      	movs	r3, #0
 801b2e6:	f00d fea7 	bl	8029038 <__aeabi_dcmpeq>
 801b2ea:	2800      	cmp	r0, #0
 801b2ec:	f000 81a9 	beq.w	801b642 <cblas_zgemv+0x41a>
 801b2f0:	ec51 0b1d 	vmov	r0, r1, d13
 801b2f4:	2200      	movs	r2, #0
 801b2f6:	2300      	movs	r3, #0
 801b2f8:	f00d fe9e 	bl	8029038 <__aeabi_dcmpeq>
 801b2fc:	2800      	cmp	r0, #0
 801b2fe:	f000 81a0 	beq.w	801b642 <cblas_zgemv+0x41a>
      && (beta_real == 1.0 && beta_imag == 0.0))
 801b302:	4bc1      	ldr	r3, [pc, #772]	; (801b608 <cblas_zgemv+0x3e0>)
 801b304:	2200      	movs	r2, #0
 801b306:	4630      	mov	r0, r6
 801b308:	4639      	mov	r1, r7
 801b30a:	f00d fe95 	bl	8029038 <__aeabi_dcmpeq>
 801b30e:	2800      	cmp	r0, #0
 801b310:	f000 8197 	beq.w	801b642 <cblas_zgemv+0x41a>
 801b314:	ec51 0b18 	vmov	r0, r1, d8
 801b318:	2200      	movs	r2, #0
 801b31a:	2300      	movs	r3, #0
 801b31c:	f00d fe8c 	bl	8029038 <__aeabi_dcmpeq>
 801b320:	2800      	cmp	r0, #0
 801b322:	f040 8161 	bne.w	801b5e8 <cblas_zgemv+0x3c0>
  if (TransA == CblasNoTrans) {
 801b326:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b328:	2b6f      	cmp	r3, #111	; 0x6f
 801b32a:	d003      	beq.n	801b334 <cblas_zgemv+0x10c>
 801b32c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801b330:	e9cd 3202 	strd	r3, r2, [sp, #8]
    INDEX iy = OFFSET(lenY, incY);
 801b334:	9b08      	ldr	r3, [sp, #32]
 801b336:	2b00      	cmp	r3, #0
 801b338:	f340 81b8 	ble.w	801b6ac <cblas_zgemv+0x484>
 801b33c:	f04f 0a00 	mov.w	sl, #0
    for (i = 0; i < lenY; i++) {
 801b340:	9b02      	ldr	r3, [sp, #8]
 801b342:	2b00      	cmp	r3, #0
 801b344:	dd42      	ble.n	801b3cc <cblas_zgemv+0x1a4>
 801b346:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801b348:	eb02 130a 	add.w	r3, r2, sl, lsl #4
 801b34c:	f103 0b08 	add.w	fp, r3, #8
 801b350:	469a      	mov	sl, r3
 801b352:	9b08      	ldr	r3, [sp, #32]
 801b354:	2400      	movs	r4, #0
 801b356:	011d      	lsls	r5, r3, #4
      const BASE y_real = REAL(Y, iy);
 801b358:	ed1b 7b02 	vldr	d7, [fp, #-8]
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801b35c:	4630      	mov	r0, r6
 801b35e:	ec53 2b17 	vmov	r2, r3, d7
      const BASE y_real = REAL(Y, iy);
 801b362:	eeb0 9a47 	vmov.f32	s18, s14
 801b366:	eef0 9a67 	vmov.f32	s19, s15
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801b36a:	4639      	mov	r1, r7
      const BASE y_imag = IMAG(Y, iy);
 801b36c:	e9da 8902 	ldrd	r8, r9, [sl, #8]
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801b370:	f00d fbfa 	bl	8028b68 <__aeabi_dmul>
 801b374:	4642      	mov	r2, r8
 801b376:	464b      	mov	r3, r9
 801b378:	ec41 0b1a 	vmov	d10, r0, r1
 801b37c:	ec51 0b18 	vmov	r0, r1, d8
 801b380:	f00d fbf2 	bl	8028b68 <__aeabi_dmul>
 801b384:	4602      	mov	r2, r0
 801b386:	460b      	mov	r3, r1
 801b388:	ec51 0b1a 	vmov	r0, r1, d10
 801b38c:	f00d fa34 	bl	80287f8 <__aeabi_dsub>
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801b390:	ec53 2b19 	vmov	r2, r3, d9
      REAL(Y, iy) = tmpR;
 801b394:	e94b 0102 	strd	r0, r1, [fp, #-8]
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801b398:	ec51 0b18 	vmov	r0, r1, d8
 801b39c:	f00d fbe4 	bl	8028b68 <__aeabi_dmul>
 801b3a0:	4642      	mov	r2, r8
 801b3a2:	464b      	mov	r3, r9
 801b3a4:	4680      	mov	r8, r0
 801b3a6:	4689      	mov	r9, r1
 801b3a8:	4630      	mov	r0, r6
 801b3aa:	4639      	mov	r1, r7
 801b3ac:	f00d fbdc 	bl	8028b68 <__aeabi_dmul>
 801b3b0:	460b      	mov	r3, r1
 801b3b2:	4602      	mov	r2, r0
 801b3b4:	4649      	mov	r1, r9
 801b3b6:	4640      	mov	r0, r8
 801b3b8:	f00d fa20 	bl	80287fc <__adddf3>
    for (i = 0; i < lenY; i++) {
 801b3bc:	9b02      	ldr	r3, [sp, #8]
 801b3be:	3401      	adds	r4, #1
 801b3c0:	42a3      	cmp	r3, r4
      IMAG(Y, iy) = tmpI;
 801b3c2:	e9ca 0102 	strd	r0, r1, [sl, #8]
    for (i = 0; i < lenY; i++) {
 801b3c6:	44ab      	add	fp, r5
 801b3c8:	44aa      	add	sl, r5
 801b3ca:	d1c5      	bne.n	801b358 <cblas_zgemv+0x130>
  if (alpha_real == 0.0 && alpha_imag == 0.0)
 801b3cc:	ec51 0b1c 	vmov	r0, r1, d12
 801b3d0:	2200      	movs	r2, #0
 801b3d2:	2300      	movs	r3, #0
 801b3d4:	f00d fe30 	bl	8029038 <__aeabi_dcmpeq>
 801b3d8:	b140      	cbz	r0, 801b3ec <cblas_zgemv+0x1c4>
 801b3da:	ec51 0b1d 	vmov	r0, r1, d13
 801b3de:	2200      	movs	r2, #0
 801b3e0:	2300      	movs	r3, #0
 801b3e2:	f00d fe29 	bl	8029038 <__aeabi_dcmpeq>
 801b3e6:	2800      	cmp	r0, #0
 801b3e8:	f040 80fe 	bne.w	801b5e8 <cblas_zgemv+0x3c0>
  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 801b3ec:	9b07      	ldr	r3, [sp, #28]
 801b3ee:	2b65      	cmp	r3, #101	; 0x65
 801b3f0:	f000 8176 	beq.w	801b6e0 <cblas_zgemv+0x4b8>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801b3f4:	9b07      	ldr	r3, [sp, #28]
 801b3f6:	2b66      	cmp	r3, #102	; 0x66
 801b3f8:	d009      	beq.n	801b40e <cblas_zgemv+0x1e6>
    BLAS_ERROR("unrecognized operation");
 801b3fa:	4a84      	ldr	r2, [pc, #528]	; (801b60c <cblas_zgemv+0x3e4>)
 801b3fc:	4981      	ldr	r1, [pc, #516]	; (801b604 <cblas_zgemv+0x3dc>)
 801b3fe:	2000      	movs	r0, #0
#define BASE double
#include "source_gemv_c.h"
#undef BASE
}
 801b400:	b011      	add	sp, #68	; 0x44
 801b402:	ecbd 8b0c 	vpop	{d8-d13}
 801b406:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b40a:	f00d b97d 	b.w	8028708 <cblas_xerbla>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801b40e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b410:	2b70      	cmp	r3, #112	; 0x70
 801b412:	f000 823b 	beq.w	801b88c <cblas_zgemv+0x664>
             || (order == CblasColMajor && TransA == CblasNoTrans)) {
 801b416:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b418:	2b6f      	cmp	r3, #111	; 0x6f
 801b41a:	f000 8318 	beq.w	801ba4e <cblas_zgemv+0x826>
  } else if (order == CblasColMajor && TransA == CblasConjTrans) {
 801b41e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b420:	2b71      	cmp	r3, #113	; 0x71
 801b422:	d1ea      	bne.n	801b3fa <cblas_zgemv+0x1d2>
    INDEX iy = OFFSET(lenY, incY);
 801b424:	9a08      	ldr	r2, [sp, #32]
 801b426:	2a00      	cmp	r2, #0
 801b428:	f340 83e8 	ble.w	801bbfc <cblas_zgemv+0x9d4>
 801b42c:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 801b42e:	9a02      	ldr	r2, [sp, #8]
 801b430:	2a00      	cmp	r2, #0
 801b432:	f340 80d9 	ble.w	801b5e8 <cblas_zgemv+0x3c0>
 801b436:	9d08      	ldr	r5, [sp, #32]
 801b438:	990a      	ldr	r1, [sp, #40]	; 0x28
 801b43a:	9803      	ldr	r0, [sp, #12]
 801b43c:	012d      	lsls	r5, r5, #4
 801b43e:	950e      	str	r5, [sp, #56]	; 0x38
 801b440:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801b442:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 801b446:	f1c0 0201 	rsb	r2, r0, #1
 801b44a:	2900      	cmp	r1, #0
 801b44c:	930b      	str	r3, [sp, #44]	; 0x2c
 801b44e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801b450:	fb02 f201 	mul.w	r2, r2, r1
 801b454:	bfc8      	it	gt
 801b456:	2200      	movgt	r2, #0
 801b458:	eb03 1302 	add.w	r3, r3, r2, lsl #4
      INDEX ix = OFFSET(lenX, incX);
 801b45c:	2400      	movs	r4, #0
 801b45e:	930d      	str	r3, [sp, #52]	; 0x34
 801b460:	010b      	lsls	r3, r1, #4
 801b462:	e9cd 3407 	strd	r3, r4, [sp, #28]
 801b466:	9b06      	ldr	r3, [sp, #24]
 801b468:	940a      	str	r4, [sp, #40]	; 0x28
 801b46a:	011b      	lsls	r3, r3, #4
 801b46c:	930c      	str	r3, [sp, #48]	; 0x30
 801b46e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b470:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801b474:	9304      	str	r3, [sp, #16]
      for (j = 0; j < lenX; j++) {
 801b476:	ed9f 7b60 	vldr	d7, [pc, #384]	; 801b5f8 <cblas_zgemv+0x3d0>
 801b47a:	9b03      	ldr	r3, [sp, #12]
 801b47c:	eeb0 ba47 	vmov.f32	s22, s14
 801b480:	eef0 ba67 	vmov.f32	s23, s15
 801b484:	2b00      	cmp	r3, #0
 801b486:	eeb0 aa47 	vmov.f32	s20, s14
 801b48a:	eef0 aa67 	vmov.f32	s21, s15
 801b48e:	dd58      	ble.n	801b542 <cblas_zgemv+0x31a>
 801b490:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 801b494:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
 801b498:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE x_real = CONST_REAL(X, ix);
 801b49c:	ed9b 7b00 	vldr	d7, [fp]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801b4a0:	e9da 6700 	ldrd	r6, r7, [sl]
        const BASE x_real = CONST_REAL(X, ix);
 801b4a4:	eeb0 8a47 	vmov.f32	s16, s14
 801b4a8:	eef0 8a67 	vmov.f32	s17, s15
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b4ac:	ec51 0b17 	vmov	r0, r1, d7
 801b4b0:	4632      	mov	r2, r6
 801b4b2:	463b      	mov	r3, r7
 801b4b4:	f00d fb58 	bl	8028b68 <__aeabi_dmul>
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801b4b8:	e9da 4502 	ldrd	r4, r5, [sl, #8]
        const BASE x_imag = CONST_IMAG(X, ix);
 801b4bc:	e9db 8902 	ldrd	r8, r9, [fp, #8]
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b4c0:	4602      	mov	r2, r0
 801b4c2:	460b      	mov	r3, r1
 801b4c4:	ec43 2b19 	vmov	d9, r2, r3
 801b4c8:	4640      	mov	r0, r8
 801b4ca:	4622      	mov	r2, r4
 801b4cc:	462b      	mov	r3, r5
 801b4ce:	4649      	mov	r1, r9
 801b4d0:	f00d fb4a 	bl	8028b68 <__aeabi_dmul>
 801b4d4:	4602      	mov	r2, r0
 801b4d6:	460b      	mov	r3, r1
 801b4d8:	ec51 0b19 	vmov	r0, r1, d9
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b4dc:	9400      	str	r4, [sp, #0]
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b4de:	f00d f98d 	bl	80287fc <__adddf3>
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b4e2:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b4e6:	4602      	mov	r2, r0
 801b4e8:	460b      	mov	r3, r1
 801b4ea:	ec51 0b1a 	vmov	r0, r1, d10
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b4ee:	9401      	str	r4, [sp, #4]
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b4f0:	f00d f984 	bl	80287fc <__adddf3>
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b4f4:	ec53 2b18 	vmov	r2, r3, d8
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b4f8:	4604      	mov	r4, r0
 801b4fa:	460d      	mov	r5, r1
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b4fc:	e9dd 0100 	ldrd	r0, r1, [sp]
 801b500:	f00d fb32 	bl	8028b68 <__aeabi_dmul>
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801b504:	ec45 4b1a 	vmov	d10, r4, r5
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b508:	4632      	mov	r2, r6
 801b50a:	463b      	mov	r3, r7
 801b50c:	4604      	mov	r4, r0
 801b50e:	460d      	mov	r5, r1
 801b510:	4640      	mov	r0, r8
 801b512:	4649      	mov	r1, r9
 801b514:	f00d fb28 	bl	8028b68 <__aeabi_dmul>
 801b518:	4602      	mov	r2, r0
 801b51a:	460b      	mov	r3, r1
 801b51c:	4620      	mov	r0, r4
 801b51e:	4629      	mov	r1, r5
 801b520:	f00d f96c 	bl	80287fc <__adddf3>
 801b524:	460b      	mov	r3, r1
 801b526:	4602      	mov	r2, r0
 801b528:	ec51 0b1b 	vmov	r0, r1, d11
 801b52c:	f00d f966 	bl	80287fc <__adddf3>
 801b530:	9b07      	ldr	r3, [sp, #28]
 801b532:	449b      	add	fp, r3
      for (j = 0; j < lenX; j++) {
 801b534:	9b04      	ldr	r3, [sp, #16]
 801b536:	f10a 0a10 	add.w	sl, sl, #16
 801b53a:	4553      	cmp	r3, sl
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801b53c:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = 0; j < lenX; j++) {
 801b540:	d1ac      	bne.n	801b49c <cblas_zgemv+0x274>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801b542:	ec53 2b1a 	vmov	r2, r3, d10
 801b546:	ec51 0b1c 	vmov	r0, r1, d12
 801b54a:	f00d fb0d 	bl	8028b68 <__aeabi_dmul>
 801b54e:	ec5a 9b1b 	vmov	r9, sl, d11
 801b552:	ec58 7b1d 	vmov	r7, r8, d13
 801b556:	4604      	mov	r4, r0
 801b558:	460d      	mov	r5, r1
 801b55a:	ee1b 2a10 	vmov	r2, s22
 801b55e:	4653      	mov	r3, sl
 801b560:	ee1d 0a10 	vmov	r0, s26
 801b564:	4641      	mov	r1, r8
 801b566:	f00d faff 	bl	8028b68 <__aeabi_dmul>
 801b56a:	4602      	mov	r2, r0
 801b56c:	460b      	mov	r3, r1
 801b56e:	4620      	mov	r0, r4
 801b570:	4629      	mov	r1, r5
 801b572:	f00d f941 	bl	80287f8 <__aeabi_dsub>
 801b576:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801b578:	4602      	mov	r2, r0
 801b57a:	460b      	mov	r3, r1
 801b57c:	e9d6 0100 	ldrd	r0, r1, [r6]
 801b580:	f00d f93c 	bl	80287fc <__adddf3>
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801b584:	ee1b 2a10 	vmov	r2, s22
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801b588:	e9c6 0100 	strd	r0, r1, [r6]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801b58c:	4653      	mov	r3, sl
 801b58e:	ec51 0b1c 	vmov	r0, r1, d12
 801b592:	f00d fae9 	bl	8028b68 <__aeabi_dmul>
 801b596:	ec53 2b1a 	vmov	r2, r3, d10
 801b59a:	460d      	mov	r5, r1
 801b59c:	4604      	mov	r4, r0
 801b59e:	4641      	mov	r1, r8
 801b5a0:	ee1d 0a10 	vmov	r0, s26
 801b5a4:	f00d fae0 	bl	8028b68 <__aeabi_dmul>
 801b5a8:	4602      	mov	r2, r0
 801b5aa:	460b      	mov	r3, r1
 801b5ac:	4620      	mov	r0, r4
 801b5ae:	4629      	mov	r1, r5
 801b5b0:	f00d f924 	bl	80287fc <__adddf3>
 801b5b4:	4602      	mov	r2, r0
 801b5b6:	460b      	mov	r3, r1
 801b5b8:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801b5bc:	f00d f91e 	bl	80287fc <__adddf3>
 801b5c0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b5c2:	9d06      	ldr	r5, [sp, #24]
    for (i = 0; i < lenY; i++) {
 801b5c4:	9a08      	ldr	r2, [sp, #32]
 801b5c6:	442b      	add	r3, r5
 801b5c8:	930a      	str	r3, [sp, #40]	; 0x28
 801b5ca:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801b5cc:	9b04      	ldr	r3, [sp, #16]
 801b5ce:	442b      	add	r3, r5
 801b5d0:	9304      	str	r3, [sp, #16]
 801b5d2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801b5d4:	18f3      	adds	r3, r6, r3
 801b5d6:	930b      	str	r3, [sp, #44]	; 0x2c
 801b5d8:	9b02      	ldr	r3, [sp, #8]
 801b5da:	3201      	adds	r2, #1
 801b5dc:	4293      	cmp	r3, r2
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801b5de:	e9c6 0102 	strd	r0, r1, [r6, #8]
    for (i = 0; i < lenY; i++) {
 801b5e2:	9208      	str	r2, [sp, #32]
 801b5e4:	f47f af47 	bne.w	801b476 <cblas_zgemv+0x24e>
 801b5e8:	b011      	add	sp, #68	; 0x44
 801b5ea:	ecbd 8b0c 	vpop	{d8-d13}
 801b5ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801b5f2:	2002      	movs	r0, #2
 801b5f4:	e64e      	b.n	801b294 <cblas_zgemv+0x6c>
 801b5f6:	bf00      	nop
	...
 801b600:	08031108 	.word	0x08031108
 801b604:	080312d0 	.word	0x080312d0
 801b608:	3ff00000 	.word	0x3ff00000
 801b60c:	080311b8 	.word	0x080311b8
 801b610:	9b08      	ldr	r3, [sp, #32]
 801b612:	2b00      	cmp	r3, #0
 801b614:	d062      	beq.n	801b6dc <cblas_zgemv+0x4b4>
 801b616:	2800      	cmp	r0, #0
 801b618:	f43f ae59 	beq.w	801b2ce <cblas_zgemv+0xa6>
 801b61c:	e653      	b.n	801b2c6 <cblas_zgemv+0x9e>
 801b61e:	9b02      	ldr	r3, [sp, #8]
 801b620:	9a06      	ldr	r2, [sp, #24]
 801b622:	2b01      	cmp	r3, #1
 801b624:	bfb8      	it	lt
 801b626:	2301      	movlt	r3, #1
 801b628:	4293      	cmp	r3, r2
 801b62a:	f77f ae43 	ble.w	801b2b4 <cblas_zgemv+0x8c>
 801b62e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b630:	2b00      	cmp	r3, #0
 801b632:	f43f ae43 	beq.w	801b2bc <cblas_zgemv+0x94>
 801b636:	9b08      	ldr	r3, [sp, #32]
 801b638:	2b00      	cmp	r3, #0
 801b63a:	bf14      	ite	ne
 801b63c:	2007      	movne	r0, #7
 801b63e:	200c      	moveq	r0, #12
 801b640:	e641      	b.n	801b2c6 <cblas_zgemv+0x9e>
  if (TransA == CblasNoTrans) {
 801b642:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b644:	2b6f      	cmp	r3, #111	; 0x6f
 801b646:	bf18      	it	ne
 801b648:	e9dd 2302 	ldrdne	r2, r3, [sp, #8]
  if (beta_real == 0.0 && beta_imag == 0.0) {
 801b64c:	4630      	mov	r0, r6
  if (TransA == CblasNoTrans) {
 801b64e:	bf18      	it	ne
 801b650:	e9cd 3202 	strdne	r3, r2, [sp, #8]
  if (beta_real == 0.0 && beta_imag == 0.0) {
 801b654:	4639      	mov	r1, r7
 801b656:	2200      	movs	r2, #0
 801b658:	2300      	movs	r3, #0
 801b65a:	f00d fced 	bl	8029038 <__aeabi_dcmpeq>
 801b65e:	2200      	movs	r2, #0
 801b660:	b350      	cbz	r0, 801b6b8 <cblas_zgemv+0x490>
 801b662:	ec51 0b18 	vmov	r0, r1, d8
 801b666:	2300      	movs	r3, #0
 801b668:	f00d fce6 	bl	8029038 <__aeabi_dcmpeq>
 801b66c:	2800      	cmp	r0, #0
 801b66e:	f43f ae61 	beq.w	801b334 <cblas_zgemv+0x10c>
    INDEX iy = OFFSET(lenY, incY);
 801b672:	9a08      	ldr	r2, [sp, #32]
 801b674:	2a00      	cmp	r2, #0
 801b676:	f340 82bb 	ble.w	801bbf0 <cblas_zgemv+0x9c8>
 801b67a:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 801b67c:	9a02      	ldr	r2, [sp, #8]
 801b67e:	2a00      	cmp	r2, #0
 801b680:	f77f aea4 	ble.w	801b3cc <cblas_zgemv+0x1a4>
 801b684:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801b686:	9d02      	ldr	r5, [sp, #8]
 801b688:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801b68c:	9a08      	ldr	r2, [sp, #32]
      REAL(Y, iy) = 0.0;
 801b68e:	2000      	movs	r0, #0
 801b690:	0114      	lsls	r4, r2, #4
 801b692:	2100      	movs	r1, #0
    for (i = 0; i < lenY; i++) {
 801b694:	2200      	movs	r2, #0
 801b696:	3201      	adds	r2, #1
 801b698:	4295      	cmp	r5, r2
      REAL(Y, iy) = 0.0;
 801b69a:	e9c3 0100 	strd	r0, r1, [r3]
      IMAG(Y, iy) = 0.0;
 801b69e:	e9c3 0102 	strd	r0, r1, [r3, #8]
    for (i = 0; i < lenY; i++) {
 801b6a2:	4423      	add	r3, r4
 801b6a4:	d1f7      	bne.n	801b696 <cblas_zgemv+0x46e>
 801b6a6:	e691      	b.n	801b3cc <cblas_zgemv+0x1a4>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801b6a8:	9b03      	ldr	r3, [sp, #12]
 801b6aa:	e7b9      	b.n	801b620 <cblas_zgemv+0x3f8>
    INDEX iy = OFFSET(lenY, incY);
 801b6ac:	9a02      	ldr	r2, [sp, #8]
 801b6ae:	f1c2 0a01 	rsb	sl, r2, #1
 801b6b2:	fb0a fa03 	mul.w	sl, sl, r3
 801b6b6:	e643      	b.n	801b340 <cblas_zgemv+0x118>
  } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801b6b8:	4b73      	ldr	r3, [pc, #460]	; (801b888 <cblas_zgemv+0x660>)
 801b6ba:	4630      	mov	r0, r6
 801b6bc:	4639      	mov	r1, r7
 801b6be:	f00d fcbb 	bl	8029038 <__aeabi_dcmpeq>
 801b6c2:	2800      	cmp	r0, #0
 801b6c4:	f43f ae36 	beq.w	801b334 <cblas_zgemv+0x10c>
 801b6c8:	ec51 0b18 	vmov	r0, r1, d8
 801b6cc:	2200      	movs	r2, #0
 801b6ce:	2300      	movs	r3, #0
 801b6d0:	f00d fcb2 	bl	8029038 <__aeabi_dcmpeq>
 801b6d4:	2800      	cmp	r0, #0
 801b6d6:	f47f ae79 	bne.w	801b3cc <cblas_zgemv+0x1a4>
 801b6da:	e62b      	b.n	801b334 <cblas_zgemv+0x10c>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801b6dc:	200c      	movs	r0, #12
 801b6de:	e5f2      	b.n	801b2c6 <cblas_zgemv+0x9e>
  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 801b6e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b6e2:	2b6f      	cmp	r3, #111	; 0x6f
 801b6e4:	f000 80d2 	beq.w	801b88c <cblas_zgemv+0x664>
  } else if ((order == CblasRowMajor && TransA == CblasTrans)
 801b6e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b6ea:	2b70      	cmp	r3, #112	; 0x70
 801b6ec:	f000 81af 	beq.w	801ba4e <cblas_zgemv+0x826>
  } else if (order == CblasRowMajor && TransA == CblasConjTrans) {
 801b6f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801b6f2:	2b71      	cmp	r3, #113	; 0x71
 801b6f4:	f47f ae81 	bne.w	801b3fa <cblas_zgemv+0x1d2>
    INDEX ix = OFFSET(lenX, incX);
 801b6f8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801b6fa:	2a00      	cmp	r2, #0
 801b6fc:	f340 8284 	ble.w	801bc08 <cblas_zgemv+0x9e0>
 801b700:	2300      	movs	r3, #0
    for (j = 0; j < lenX; j++) {
 801b702:	9a03      	ldr	r2, [sp, #12]
 801b704:	2a00      	cmp	r2, #0
 801b706:	f77f af6f 	ble.w	801b5e8 <cblas_zgemv+0x3c0>
 801b70a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 801b70c:	9808      	ldr	r0, [sp, #32]
 801b70e:	9c02      	ldr	r4, [sp, #8]
 801b710:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801b712:	013f      	lsls	r7, r7, #4
 801b714:	970c      	str	r7, [sp, #48]	; 0x30
 801b716:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801b718:	f1c4 0201 	rsb	r2, r4, #1
 801b71c:	2800      	cmp	r0, #0
 801b71e:	fb02 f200 	mul.w	r2, r2, r0
 801b722:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801b726:	bfc8      	it	gt
 801b728:	2200      	movgt	r2, #0
 801b72a:	eb05 1102 	add.w	r1, r5, r2, lsl #4
 801b72e:	9307      	str	r3, [sp, #28]
 801b730:	0103      	lsls	r3, r0, #4
 801b732:	930f      	str	r3, [sp, #60]	; 0x3c
 801b734:	f101 0308 	add.w	r3, r1, #8
 801b738:	930d      	str	r3, [sp, #52]	; 0x34
 801b73a:	9b06      	ldr	r3, [sp, #24]
 801b73c:	910e      	str	r1, [sp, #56]	; 0x38
 801b73e:	011b      	lsls	r3, r3, #4
 801b740:	930b      	str	r3, [sp, #44]	; 0x2c
 801b742:	9b09      	ldr	r3, [sp, #36]	; 0x24
      INDEX iy = OFFSET(lenY, incY);
 801b744:	2600      	movs	r6, #0
 801b746:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801b74a:	9608      	str	r6, [sp, #32]
 801b74c:	960a      	str	r6, [sp, #40]	; 0x28
 801b74e:	9300      	str	r3, [sp, #0]
      BASE x_real = CONST_REAL(X, ix);
 801b750:	9c07      	ldr	r4, [sp, #28]
 801b752:	e9d4 8900 	ldrd	r8, r9, [r4]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801b756:	ec51 0b1c 	vmov	r0, r1, d12
 801b75a:	4642      	mov	r2, r8
 801b75c:	464b      	mov	r3, r9
 801b75e:	f00d fa03 	bl	8028b68 <__aeabi_dmul>
      BASE x_imag = CONST_IMAG(X, ix);
 801b762:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801b766:	ec5b ab1d 	vmov	sl, fp, d13
 801b76a:	4604      	mov	r4, r0
 801b76c:	460d      	mov	r5, r1
 801b76e:	4632      	mov	r2, r6
 801b770:	463b      	mov	r3, r7
 801b772:	ee1d 0a10 	vmov	r0, s26
 801b776:	4659      	mov	r1, fp
 801b778:	f00d f9f6 	bl	8028b68 <__aeabi_dmul>
 801b77c:	4602      	mov	r2, r0
 801b77e:	460b      	mov	r3, r1
 801b780:	4620      	mov	r0, r4
 801b782:	4629      	mov	r1, r5
 801b784:	f00d f838 	bl	80287f8 <__aeabi_dsub>
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801b788:	4632      	mov	r2, r6
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801b78a:	4604      	mov	r4, r0
 801b78c:	460d      	mov	r5, r1
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801b78e:	463b      	mov	r3, r7
 801b790:	ec51 0b1c 	vmov	r0, r1, d12
 801b794:	f00d f9e8 	bl	8028b68 <__aeabi_dmul>
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801b798:	ec45 4b19 	vmov	d9, r4, r5
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801b79c:	4642      	mov	r2, r8
 801b79e:	464b      	mov	r3, r9
 801b7a0:	4604      	mov	r4, r0
 801b7a2:	460d      	mov	r5, r1
 801b7a4:	ee1d 0a10 	vmov	r0, s26
 801b7a8:	4659      	mov	r1, fp
 801b7aa:	f00d f9dd 	bl	8028b68 <__aeabi_dmul>
 801b7ae:	460b      	mov	r3, r1
 801b7b0:	4602      	mov	r2, r0
 801b7b2:	4629      	mov	r1, r5
 801b7b4:	4620      	mov	r0, r4
 801b7b6:	f00d f821 	bl	80287fc <__adddf3>
      for (i = 0; i < lenY; i++) {
 801b7ba:	9b02      	ldr	r3, [sp, #8]
 801b7bc:	2b00      	cmp	r3, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801b7be:	ec41 0b18 	vmov	d8, r0, r1
      for (i = 0; i < lenY; i++) {
 801b7c2:	dd4d      	ble.n	801b860 <cblas_zgemv+0x638>
 801b7c4:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801b7c8:	e9dd 6b0d 	ldrd	r6, fp, [sp, #52]	; 0x34
 801b7cc:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 801b7ce:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE A_real = CONST_REAL(A, lda * j + i);
 801b7d2:	e9da 8900 	ldrd	r8, r9, [sl]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801b7d6:	ec51 0b19 	vmov	r0, r1, d9
 801b7da:	4642      	mov	r2, r8
 801b7dc:	464b      	mov	r3, r9
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 801b7de:	e9da 4502 	ldrd	r4, r5, [sl, #8]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801b7e2:	f00d f9c1 	bl	8028b68 <__aeabi_dmul>
 801b7e6:	4622      	mov	r2, r4
 801b7e8:	462b      	mov	r3, r5
 801b7ea:	ec41 0b1a 	vmov	d10, r0, r1
 801b7ee:	ec51 0b18 	vmov	r0, r1, d8
 801b7f2:	f00d f9b9 	bl	8028b68 <__aeabi_dmul>
 801b7f6:	4602      	mov	r2, r0
 801b7f8:	460b      	mov	r3, r1
 801b7fa:	ec51 0b1a 	vmov	r0, r1, d10
 801b7fe:	f00c fffd 	bl	80287fc <__adddf3>
 801b802:	4602      	mov	r2, r0
 801b804:	460b      	mov	r3, r1
 801b806:	e956 0102 	ldrd	r0, r1, [r6, #-8]
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801b80a:	9404      	str	r4, [sp, #16]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801b80c:	f00c fff6 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801b810:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 801b814:	9305      	str	r3, [sp, #20]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801b816:	e946 0102 	strd	r0, r1, [r6, #-8]
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801b81a:	ec53 2b19 	vmov	r2, r3, d9
 801b81e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 801b822:	f00d f9a1 	bl	8028b68 <__aeabi_dmul>
 801b826:	4642      	mov	r2, r8
 801b828:	464b      	mov	r3, r9
 801b82a:	4604      	mov	r4, r0
 801b82c:	460d      	mov	r5, r1
 801b82e:	ec51 0b18 	vmov	r0, r1, d8
 801b832:	f00d f999 	bl	8028b68 <__aeabi_dmul>
 801b836:	4602      	mov	r2, r0
 801b838:	460b      	mov	r3, r1
 801b83a:	4620      	mov	r0, r4
 801b83c:	4629      	mov	r1, r5
 801b83e:	f00c ffdd 	bl	80287fc <__adddf3>
 801b842:	460b      	mov	r3, r1
 801b844:	4602      	mov	r2, r0
 801b846:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801b84a:	f00c ffd7 	bl	80287fc <__adddf3>
      for (i = 0; i < lenY; i++) {
 801b84e:	9b00      	ldr	r3, [sp, #0]
 801b850:	f10a 0a10 	add.w	sl, sl, #16
 801b854:	4553      	cmp	r3, sl
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801b856:	e9cb 0102 	strd	r0, r1, [fp, #8]
      for (i = 0; i < lenY; i++) {
 801b85a:	443e      	add	r6, r7
 801b85c:	44bb      	add	fp, r7
 801b85e:	d1b8      	bne.n	801b7d2 <cblas_zgemv+0x5aa>
    for (j = 0; j < lenX; j++) {
 801b860:	9a07      	ldr	r2, [sp, #28]
 801b862:	990c      	ldr	r1, [sp, #48]	; 0x30
 801b864:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801b866:	440a      	add	r2, r1
 801b868:	9207      	str	r2, [sp, #28]
 801b86a:	9906      	ldr	r1, [sp, #24]
 801b86c:	9a08      	ldr	r2, [sp, #32]
 801b86e:	440a      	add	r2, r1
 801b870:	9208      	str	r2, [sp, #32]
 801b872:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801b874:	9a00      	ldr	r2, [sp, #0]
 801b876:	440a      	add	r2, r1
 801b878:	9200      	str	r2, [sp, #0]
 801b87a:	9a03      	ldr	r2, [sp, #12]
 801b87c:	3301      	adds	r3, #1
 801b87e:	429a      	cmp	r2, r3
 801b880:	930a      	str	r3, [sp, #40]	; 0x28
 801b882:	f47f af65 	bne.w	801b750 <cblas_zgemv+0x528>
 801b886:	e6af      	b.n	801b5e8 <cblas_zgemv+0x3c0>
 801b888:	3ff00000 	.word	0x3ff00000
    INDEX iy = OFFSET(lenY, incY);
 801b88c:	9a08      	ldr	r2, [sp, #32]
 801b88e:	2a00      	cmp	r2, #0
 801b890:	f340 81a2 	ble.w	801bbd8 <cblas_zgemv+0x9b0>
 801b894:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 801b896:	9a02      	ldr	r2, [sp, #8]
 801b898:	2a00      	cmp	r2, #0
 801b89a:	f77f aea5 	ble.w	801b5e8 <cblas_zgemv+0x3c0>
 801b89e:	9d08      	ldr	r5, [sp, #32]
 801b8a0:	990a      	ldr	r1, [sp, #40]	; 0x28
 801b8a2:	9803      	ldr	r0, [sp, #12]
 801b8a4:	012d      	lsls	r5, r5, #4
 801b8a6:	950e      	str	r5, [sp, #56]	; 0x38
 801b8a8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801b8aa:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 801b8ae:	f1c0 0201 	rsb	r2, r0, #1
 801b8b2:	2900      	cmp	r1, #0
 801b8b4:	930a      	str	r3, [sp, #40]	; 0x28
 801b8b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801b8b8:	fb02 f201 	mul.w	r2, r2, r1
 801b8bc:	bfc8      	it	gt
 801b8be:	2200      	movgt	r2, #0
 801b8c0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801b8c4:	930c      	str	r3, [sp, #48]	; 0x30
 801b8c6:	010b      	lsls	r3, r1, #4
 801b8c8:	9304      	str	r3, [sp, #16]
 801b8ca:	9b06      	ldr	r3, [sp, #24]
 801b8cc:	011b      	lsls	r3, r3, #4
 801b8ce:	930b      	str	r3, [sp, #44]	; 0x2c
 801b8d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
      INDEX ix = OFFSET(lenX, incX);
 801b8d2:	2400      	movs	r4, #0
 801b8d4:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801b8d8:	9407      	str	r4, [sp, #28]
 801b8da:	9408      	str	r4, [sp, #32]
 801b8dc:	9300      	str	r3, [sp, #0]
      for (j = 0; j < lenX; j++) {
 801b8de:	ed9f 7bce 	vldr	d7, [pc, #824]	; 801bc18 <cblas_zgemv+0x9f0>
 801b8e2:	9b03      	ldr	r3, [sp, #12]
 801b8e4:	eeb0 ba47 	vmov.f32	s22, s14
 801b8e8:	eef0 ba67 	vmov.f32	s23, s15
 801b8ec:	2b00      	cmp	r3, #0
 801b8ee:	eeb0 aa47 	vmov.f32	s20, s14
 801b8f2:	eef0 aa67 	vmov.f32	s21, s15
 801b8f6:	dd56      	ble.n	801b9a6 <cblas_zgemv+0x77e>
 801b8f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801b8fa:	9a07      	ldr	r2, [sp, #28]
 801b8fc:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 801b900:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801b904:	ed9a 7b00 	vldr	d7, [sl]
        const BASE x_real = CONST_REAL(X, ix);
 801b908:	e9db 6700 	ldrd	r6, r7, [fp]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801b90c:	eeb0 9a47 	vmov.f32	s18, s14
 801b910:	eef0 9a67 	vmov.f32	s19, s15
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801b914:	ed9a 6b02 	vldr	d6, [sl, #8]
        dotR += A_real * x_real - A_imag * x_imag;
 801b918:	ec53 2b17 	vmov	r2, r3, d7
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801b91c:	eeb0 8a46 	vmov.f32	s16, s12
 801b920:	eef0 8a66 	vmov.f32	s17, s13
        dotR += A_real * x_real - A_imag * x_imag;
 801b924:	4630      	mov	r0, r6
 801b926:	4639      	mov	r1, r7
 801b928:	f00d f91e 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = CONST_IMAG(X, ix);
 801b92c:	e9db 8902 	ldrd	r8, r9, [fp, #8]
        dotR += A_real * x_real - A_imag * x_imag;
 801b930:	ec53 2b18 	vmov	r2, r3, d8
 801b934:	4604      	mov	r4, r0
 801b936:	460d      	mov	r5, r1
 801b938:	4640      	mov	r0, r8
 801b93a:	4649      	mov	r1, r9
 801b93c:	f00d f914 	bl	8028b68 <__aeabi_dmul>
 801b940:	4602      	mov	r2, r0
 801b942:	460b      	mov	r3, r1
 801b944:	4620      	mov	r0, r4
 801b946:	4629      	mov	r1, r5
 801b948:	f00c ff56 	bl	80287f8 <__aeabi_dsub>
 801b94c:	4602      	mov	r2, r0
 801b94e:	460b      	mov	r3, r1
 801b950:	ec51 0b1a 	vmov	r0, r1, d10
 801b954:	f00c ff52 	bl	80287fc <__adddf3>
        dotI += A_real * x_imag + A_imag * x_real;
 801b958:	ec53 2b19 	vmov	r2, r3, d9
        dotR += A_real * x_real - A_imag * x_imag;
 801b95c:	4604      	mov	r4, r0
 801b95e:	460d      	mov	r5, r1
        dotI += A_real * x_imag + A_imag * x_real;
 801b960:	4640      	mov	r0, r8
 801b962:	4649      	mov	r1, r9
 801b964:	f00d f900 	bl	8028b68 <__aeabi_dmul>
        dotR += A_real * x_real - A_imag * x_imag;
 801b968:	ec45 4b1a 	vmov	d10, r4, r5
        dotI += A_real * x_imag + A_imag * x_real;
 801b96c:	ec53 2b18 	vmov	r2, r3, d8
 801b970:	4604      	mov	r4, r0
 801b972:	460d      	mov	r5, r1
 801b974:	4630      	mov	r0, r6
 801b976:	4639      	mov	r1, r7
 801b978:	f00d f8f6 	bl	8028b68 <__aeabi_dmul>
 801b97c:	4602      	mov	r2, r0
 801b97e:	460b      	mov	r3, r1
 801b980:	4620      	mov	r0, r4
 801b982:	4629      	mov	r1, r5
 801b984:	f00c ff3a 	bl	80287fc <__adddf3>
 801b988:	460b      	mov	r3, r1
 801b98a:	4602      	mov	r2, r0
 801b98c:	ec51 0b1b 	vmov	r0, r1, d11
 801b990:	f00c ff34 	bl	80287fc <__adddf3>
 801b994:	9b04      	ldr	r3, [sp, #16]
 801b996:	449b      	add	fp, r3
      for (j = 0; j < lenX; j++) {
 801b998:	9b00      	ldr	r3, [sp, #0]
 801b99a:	f10a 0a10 	add.w	sl, sl, #16
 801b99e:	459a      	cmp	sl, r3
        dotI += A_real * x_imag + A_imag * x_real;
 801b9a0:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = 0; j < lenX; j++) {
 801b9a4:	d1ae      	bne.n	801b904 <cblas_zgemv+0x6dc>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801b9a6:	ec53 2b1a 	vmov	r2, r3, d10
 801b9aa:	ec51 0b1c 	vmov	r0, r1, d12
 801b9ae:	f00d f8db 	bl	8028b68 <__aeabi_dmul>
 801b9b2:	ec5a 9b1b 	vmov	r9, sl, d11
 801b9b6:	ec58 7b1d 	vmov	r7, r8, d13
 801b9ba:	4604      	mov	r4, r0
 801b9bc:	460d      	mov	r5, r1
 801b9be:	ee1b 2a10 	vmov	r2, s22
 801b9c2:	4653      	mov	r3, sl
 801b9c4:	ee1d 0a10 	vmov	r0, s26
 801b9c8:	4641      	mov	r1, r8
 801b9ca:	f00d f8cd 	bl	8028b68 <__aeabi_dmul>
 801b9ce:	4602      	mov	r2, r0
 801b9d0:	460b      	mov	r3, r1
 801b9d2:	4620      	mov	r0, r4
 801b9d4:	4629      	mov	r1, r5
 801b9d6:	f00c ff0f 	bl	80287f8 <__aeabi_dsub>
 801b9da:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 801b9dc:	4602      	mov	r2, r0
 801b9de:	460b      	mov	r3, r1
 801b9e0:	e9d6 0100 	ldrd	r0, r1, [r6]
 801b9e4:	f00c ff0a 	bl	80287fc <__adddf3>
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801b9e8:	ee1b 2a10 	vmov	r2, s22
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801b9ec:	e9c6 0100 	strd	r0, r1, [r6]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801b9f0:	4653      	mov	r3, sl
 801b9f2:	ec51 0b1c 	vmov	r0, r1, d12
 801b9f6:	f00d f8b7 	bl	8028b68 <__aeabi_dmul>
 801b9fa:	ec53 2b1a 	vmov	r2, r3, d10
 801b9fe:	460d      	mov	r5, r1
 801ba00:	4604      	mov	r4, r0
 801ba02:	4641      	mov	r1, r8
 801ba04:	ee1d 0a10 	vmov	r0, s26
 801ba08:	f00d f8ae 	bl	8028b68 <__aeabi_dmul>
 801ba0c:	4602      	mov	r2, r0
 801ba0e:	460b      	mov	r3, r1
 801ba10:	4620      	mov	r0, r4
 801ba12:	4629      	mov	r1, r5
 801ba14:	f00c fef2 	bl	80287fc <__adddf3>
 801ba18:	4602      	mov	r2, r0
 801ba1a:	460b      	mov	r3, r1
 801ba1c:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801ba20:	f00c feec 	bl	80287fc <__adddf3>
 801ba24:	e9dd 5306 	ldrd	r5, r3, [sp, #24]
 801ba28:	442b      	add	r3, r5
 801ba2a:	9307      	str	r3, [sp, #28]
 801ba2c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801ba2e:	9b00      	ldr	r3, [sp, #0]
    for (i = 0; i < lenY; i++) {
 801ba30:	9a08      	ldr	r2, [sp, #32]
 801ba32:	442b      	add	r3, r5
 801ba34:	9300      	str	r3, [sp, #0]
 801ba36:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801ba38:	18f3      	adds	r3, r6, r3
 801ba3a:	930a      	str	r3, [sp, #40]	; 0x28
 801ba3c:	9b02      	ldr	r3, [sp, #8]
 801ba3e:	3201      	adds	r2, #1
 801ba40:	4293      	cmp	r3, r2
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801ba42:	e9c6 0102 	strd	r0, r1, [r6, #8]
    for (i = 0; i < lenY; i++) {
 801ba46:	9208      	str	r2, [sp, #32]
 801ba48:	f47f af49 	bne.w	801b8de <cblas_zgemv+0x6b6>
 801ba4c:	e5cc      	b.n	801b5e8 <cblas_zgemv+0x3c0>
    INDEX ix = OFFSET(lenX, incX);
 801ba4e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ba50:	2a00      	cmp	r2, #0
 801ba52:	f340 80c7 	ble.w	801bbe4 <cblas_zgemv+0x9bc>
 801ba56:	2300      	movs	r3, #0
    for (j = 0; j < lenX; j++) {
 801ba58:	9a03      	ldr	r2, [sp, #12]
 801ba5a:	2a00      	cmp	r2, #0
 801ba5c:	f77f adc4 	ble.w	801b5e8 <cblas_zgemv+0x3c0>
 801ba60:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 801ba62:	9808      	ldr	r0, [sp, #32]
 801ba64:	9c02      	ldr	r4, [sp, #8]
 801ba66:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801ba68:	013f      	lsls	r7, r7, #4
 801ba6a:	970b      	str	r7, [sp, #44]	; 0x2c
 801ba6c:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801ba6e:	f1c4 0201 	rsb	r2, r4, #1
 801ba72:	2800      	cmp	r0, #0
 801ba74:	fb02 f200 	mul.w	r2, r2, r0
 801ba78:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801ba7c:	bfc8      	it	gt
 801ba7e:	2200      	movgt	r2, #0
 801ba80:	eb05 1102 	add.w	r1, r5, r2, lsl #4
 801ba84:	9304      	str	r3, [sp, #16]
 801ba86:	0103      	lsls	r3, r0, #4
 801ba88:	930e      	str	r3, [sp, #56]	; 0x38
 801ba8a:	f101 0308 	add.w	r3, r1, #8
 801ba8e:	930c      	str	r3, [sp, #48]	; 0x30
 801ba90:	9b06      	ldr	r3, [sp, #24]
 801ba92:	910d      	str	r1, [sp, #52]	; 0x34
 801ba94:	011b      	lsls	r3, r3, #4
 801ba96:	930a      	str	r3, [sp, #40]	; 0x28
 801ba98:	9b09      	ldr	r3, [sp, #36]	; 0x24
      INDEX iy = OFFSET(lenY, incY);
 801ba9a:	2600      	movs	r6, #0
 801ba9c:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801baa0:	9607      	str	r6, [sp, #28]
 801baa2:	9608      	str	r6, [sp, #32]
 801baa4:	9300      	str	r3, [sp, #0]
      BASE x_real = CONST_REAL(X, ix);
 801baa6:	9c04      	ldr	r4, [sp, #16]
 801baa8:	e9d4 8900 	ldrd	r8, r9, [r4]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801baac:	ec51 0b1c 	vmov	r0, r1, d12
 801bab0:	4642      	mov	r2, r8
 801bab2:	464b      	mov	r3, r9
 801bab4:	f00d f858 	bl	8028b68 <__aeabi_dmul>
      BASE x_imag = CONST_IMAG(X, ix);
 801bab8:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801babc:	ec5b ab1d 	vmov	sl, fp, d13
 801bac0:	4604      	mov	r4, r0
 801bac2:	460d      	mov	r5, r1
 801bac4:	4632      	mov	r2, r6
 801bac6:	463b      	mov	r3, r7
 801bac8:	ee1d 0a10 	vmov	r0, s26
 801bacc:	4659      	mov	r1, fp
 801bace:	f00d f84b 	bl	8028b68 <__aeabi_dmul>
 801bad2:	4602      	mov	r2, r0
 801bad4:	460b      	mov	r3, r1
 801bad6:	4620      	mov	r0, r4
 801bad8:	4629      	mov	r1, r5
 801bada:	f00c fe8d 	bl	80287f8 <__aeabi_dsub>
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801bade:	4632      	mov	r2, r6
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801bae0:	4604      	mov	r4, r0
 801bae2:	460d      	mov	r5, r1
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801bae4:	463b      	mov	r3, r7
 801bae6:	ec51 0b1c 	vmov	r0, r1, d12
 801baea:	f00d f83d 	bl	8028b68 <__aeabi_dmul>
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801baee:	ec45 4b19 	vmov	d9, r4, r5
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801baf2:	4642      	mov	r2, r8
 801baf4:	464b      	mov	r3, r9
 801baf6:	4604      	mov	r4, r0
 801baf8:	460d      	mov	r5, r1
 801bafa:	ee1d 0a10 	vmov	r0, s26
 801bafe:	4659      	mov	r1, fp
 801bb00:	f00d f832 	bl	8028b68 <__aeabi_dmul>
 801bb04:	460b      	mov	r3, r1
 801bb06:	4602      	mov	r2, r0
 801bb08:	4629      	mov	r1, r5
 801bb0a:	4620      	mov	r0, r4
 801bb0c:	f00c fe76 	bl	80287fc <__adddf3>
      for (i = 0; i < lenY; i++) {
 801bb10:	9b02      	ldr	r3, [sp, #8]
 801bb12:	2b00      	cmp	r3, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801bb14:	ec41 0b18 	vmov	d8, r0, r1
      for (i = 0; i < lenY; i++) {
 801bb18:	dd4a      	ble.n	801bbb0 <cblas_zgemv+0x988>
 801bb1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801bb1c:	9a07      	ldr	r2, [sp, #28]
 801bb1e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801bb20:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 801bb24:	e9dd 3b0c 	ldrd	r3, fp, [sp, #48]	; 0x30
 801bb28:	461c      	mov	r4, r3
        const BASE A_real = CONST_REAL(A, lda * j + i);
 801bb2a:	e9da 8900 	ldrd	r8, r9, [sl]
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801bb2e:	ec51 0b19 	vmov	r0, r1, d9
 801bb32:	4642      	mov	r2, r8
 801bb34:	464b      	mov	r3, r9
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 801bb36:	e9da 6702 	ldrd	r6, r7, [sl, #8]
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801bb3a:	f00d f815 	bl	8028b68 <__aeabi_dmul>
 801bb3e:	4632      	mov	r2, r6
 801bb40:	463b      	mov	r3, r7
 801bb42:	ec41 0b1a 	vmov	d10, r0, r1
 801bb46:	ec51 0b18 	vmov	r0, r1, d8
 801bb4a:	f00d f80d 	bl	8028b68 <__aeabi_dmul>
 801bb4e:	4602      	mov	r2, r0
 801bb50:	460b      	mov	r3, r1
 801bb52:	ec51 0b1a 	vmov	r0, r1, d10
 801bb56:	f00c fe4f 	bl	80287f8 <__aeabi_dsub>
 801bb5a:	4602      	mov	r2, r0
 801bb5c:	460b      	mov	r3, r1
 801bb5e:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801bb62:	f00c fe4b 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801bb66:	4642      	mov	r2, r8
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801bb68:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801bb6c:	464b      	mov	r3, r9
 801bb6e:	ec51 0b18 	vmov	r0, r1, d8
 801bb72:	f00c fff9 	bl	8028b68 <__aeabi_dmul>
 801bb76:	4632      	mov	r2, r6
 801bb78:	463b      	mov	r3, r7
 801bb7a:	4606      	mov	r6, r0
 801bb7c:	460f      	mov	r7, r1
 801bb7e:	ec51 0b19 	vmov	r0, r1, d9
 801bb82:	f00c fff1 	bl	8028b68 <__aeabi_dmul>
 801bb86:	4602      	mov	r2, r0
 801bb88:	460b      	mov	r3, r1
 801bb8a:	4630      	mov	r0, r6
 801bb8c:	4639      	mov	r1, r7
 801bb8e:	f00c fe35 	bl	80287fc <__adddf3>
 801bb92:	460b      	mov	r3, r1
 801bb94:	4602      	mov	r2, r0
 801bb96:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801bb9a:	f00c fe2f 	bl	80287fc <__adddf3>
      for (i = 0; i < lenY; i++) {
 801bb9e:	9b00      	ldr	r3, [sp, #0]
 801bba0:	f10a 0a10 	add.w	sl, sl, #16
 801bba4:	4553      	cmp	r3, sl
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801bba6:	e9cb 0102 	strd	r0, r1, [fp, #8]
      for (i = 0; i < lenY; i++) {
 801bbaa:	442c      	add	r4, r5
 801bbac:	44ab      	add	fp, r5
 801bbae:	d1bc      	bne.n	801bb2a <cblas_zgemv+0x902>
    for (j = 0; j < lenX; j++) {
 801bbb0:	9a04      	ldr	r2, [sp, #16]
 801bbb2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801bbb4:	9b08      	ldr	r3, [sp, #32]
 801bbb6:	440a      	add	r2, r1
 801bbb8:	9204      	str	r2, [sp, #16]
 801bbba:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
 801bbbe:	440a      	add	r2, r1
 801bbc0:	9207      	str	r2, [sp, #28]
 801bbc2:	990a      	ldr	r1, [sp, #40]	; 0x28
 801bbc4:	9a00      	ldr	r2, [sp, #0]
 801bbc6:	440a      	add	r2, r1
 801bbc8:	9200      	str	r2, [sp, #0]
 801bbca:	9a03      	ldr	r2, [sp, #12]
 801bbcc:	3301      	adds	r3, #1
 801bbce:	429a      	cmp	r2, r3
 801bbd0:	9308      	str	r3, [sp, #32]
 801bbd2:	f47f af68 	bne.w	801baa6 <cblas_zgemv+0x87e>
 801bbd6:	e507      	b.n	801b5e8 <cblas_zgemv+0x3c0>
    INDEX iy = OFFSET(lenY, incY);
 801bbd8:	9b02      	ldr	r3, [sp, #8]
 801bbda:	f1c3 0301 	rsb	r3, r3, #1
 801bbde:	fb03 f302 	mul.w	r3, r3, r2
 801bbe2:	e658      	b.n	801b896 <cblas_zgemv+0x66e>
    INDEX ix = OFFSET(lenX, incX);
 801bbe4:	9b03      	ldr	r3, [sp, #12]
 801bbe6:	f1c3 0301 	rsb	r3, r3, #1
 801bbea:	fb03 f302 	mul.w	r3, r3, r2
 801bbee:	e733      	b.n	801ba58 <cblas_zgemv+0x830>
    INDEX iy = OFFSET(lenY, incY);
 801bbf0:	9b02      	ldr	r3, [sp, #8]
 801bbf2:	f1c3 0301 	rsb	r3, r3, #1
 801bbf6:	fb03 f302 	mul.w	r3, r3, r2
 801bbfa:	e53f      	b.n	801b67c <cblas_zgemv+0x454>
    INDEX iy = OFFSET(lenY, incY);
 801bbfc:	9b02      	ldr	r3, [sp, #8]
 801bbfe:	f1c3 0301 	rsb	r3, r3, #1
 801bc02:	fb03 f302 	mul.w	r3, r3, r2
 801bc06:	e412      	b.n	801b42e <cblas_zgemv+0x206>
    INDEX ix = OFFSET(lenX, incX);
 801bc08:	9b03      	ldr	r3, [sp, #12]
 801bc0a:	f1c3 0301 	rsb	r3, r3, #1
 801bc0e:	fb03 f302 	mul.w	r3, r3, r2
 801bc12:	e576      	b.n	801b702 <cblas_zgemv+0x4da>
 801bc14:	f3af 8000 	nop.w
	...

0801bc20 <cblas_zgerc>:

void
cblas_zgerc (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 801bc20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801bc24:	ed2d 8b0c 	vpush	{d8-d13}
 801bc28:	b08b      	sub	sp, #44	; 0x2c
 801bc2a:	4699      	mov	r9, r3
 801bc2c:	1e0b      	subs	r3, r1, #0
 801bc2e:	e9dd b520 	ldrd	fp, r5, [sp, #128]	; 0x80
 801bc32:	e9dd a422 	ldrd	sl, r4, [sp, #136]	; 0x88
 801bc36:	e9dd 7624 	ldrd	r7, r6, [sp, #144]	; 0x90
 801bc3a:	4680      	mov	r8, r0
 801bc3c:	9203      	str	r2, [sp, #12]
 801bc3e:	9305      	str	r3, [sp, #20]
 801bc40:	f2c0 8130 	blt.w	801bea4 <cblas_zgerc+0x284>
 801bc44:	3865      	subs	r0, #101	; 0x65
 801bc46:	2801      	cmp	r0, #1
 801bc48:	bf94      	ite	ls
 801bc4a:	2000      	movls	r0, #0
 801bc4c:	2001      	movhi	r0, #1
 801bc4e:	9b03      	ldr	r3, [sp, #12]
 801bc50:	2b00      	cmp	r3, #0
 801bc52:	bfb8      	it	lt
 801bc54:	2003      	movlt	r0, #3
 801bc56:	2d00      	cmp	r5, #0
 801bc58:	f040 80fc 	bne.w	801be54 <cblas_zgerc+0x234>
 801bc5c:	2c00      	cmp	r4, #0
 801bc5e:	f040 80e6 	bne.w	801be2e <cblas_zgerc+0x20e>
 801bc62:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 801bc66:	f000 8125 	beq.w	801beb4 <cblas_zgerc+0x294>
 801bc6a:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 801bc6e:	f040 81f4 	bne.w	801c05a <cblas_zgerc+0x43a>
 801bc72:	9b05      	ldr	r3, [sp, #20]
 801bc74:	2b01      	cmp	r3, #1
 801bc76:	bfb8      	it	lt
 801bc78:	2301      	movlt	r3, #1
 801bc7a:	429e      	cmp	r6, r3
 801bc7c:	f2c0 80e6 	blt.w	801be4c <cblas_zgerc+0x22c>
 801bc80:	2008      	movs	r0, #8
 801bc82:	4a89      	ldr	r2, [pc, #548]	; (801bea8 <cblas_zgerc+0x288>)
 801bc84:	4989      	ldr	r1, [pc, #548]	; (801beac <cblas_zgerc+0x28c>)
 801bc86:	f00c fd3f 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801bc8a:	ed99 7b00 	vldr	d7, [r9]
 801bc8e:	eeb0 ca47 	vmov.f32	s24, s14
 801bc92:	eef0 ca67 	vmov.f32	s25, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801bc96:	ed99 7b02 	vldr	d7, [r9, #8]
 801bc9a:	eeb0 da47 	vmov.f32	s26, s14
 801bc9e:	eef0 da67 	vmov.f32	s27, s15
      INDEX jy = OFFSET(N, incY);
 801bca2:	2c00      	cmp	r4, #0
 801bca4:	f340 81f6 	ble.w	801c094 <cblas_zgerc+0x474>
 801bca8:	2200      	movs	r2, #0
      for (j = 0; j < N; j++) {
 801bcaa:	9b03      	ldr	r3, [sp, #12]
 801bcac:	2b00      	cmp	r3, #0
 801bcae:	f340 80b9 	ble.w	801be24 <cblas_zgerc+0x204>
 801bcb2:	9905      	ldr	r1, [sp, #20]
 801bcb4:	9704      	str	r7, [sp, #16]
 801bcb6:	f1c1 0301 	rsb	r3, r1, #1
 801bcba:	2d00      	cmp	r5, #0
 801bcbc:	fb03 f305 	mul.w	r3, r3, r5
 801bcc0:	bfc8      	it	gt
 801bcc2:	2300      	movgt	r3, #0
 801bcc4:	eb0b 1303 	add.w	r3, fp, r3, lsl #4
 801bcc8:	9309      	str	r3, [sp, #36]	; 0x24
 801bcca:	012b      	lsls	r3, r5, #4
 801bccc:	eb0a 1202 	add.w	r2, sl, r2, lsl #4
 801bcd0:	9300      	str	r3, [sp, #0]
 801bcd2:	eb07 1301 	add.w	r3, r7, r1, lsl #4
 801bcd6:	0120      	lsls	r0, r4, #4
 801bcd8:	9201      	str	r2, [sp, #4]
 801bcda:	9302      	str	r3, [sp, #8]
 801bcdc:	0132      	lsls	r2, r6, #4
        INDEX ix = OFFSET(M, incX);
 801bcde:	2300      	movs	r3, #0
 801bce0:	9008      	str	r0, [sp, #32]
 801bce2:	9207      	str	r2, [sp, #28]
 801bce4:	9306      	str	r3, [sp, #24]
        const BASE Y_real = CONST_REAL(Y, jy);
 801bce6:	9b01      	ldr	r3, [sp, #4]
 801bce8:	e9d3 6700 	ldrd	r6, r7, [r3]
        const BASE Y_imag = -CONST_IMAG(Y, jy);
 801bcec:	68dc      	ldr	r4, [r3, #12]
 801bcee:	689a      	ldr	r2, [r3, #8]
 801bcf0:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
 801bcf4:	ee0b 2a10 	vmov	s22, r2
 801bcf8:	ee0b 4a90 	vmov	s23, r4
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801bcfc:	ec53 2b1c 	vmov	r2, r3, d12
 801bd00:	4630      	mov	r0, r6
 801bd02:	4639      	mov	r1, r7
 801bd04:	f00c ff30 	bl	8028b68 <__aeabi_dmul>
 801bd08:	ec59 8b1b 	vmov	r8, r9, d11
 801bd0c:	ec5b ab1d 	vmov	sl, fp, d13
 801bd10:	4604      	mov	r4, r0
 801bd12:	460d      	mov	r5, r1
 801bd14:	ee1d 2a10 	vmov	r2, s26
 801bd18:	465b      	mov	r3, fp
 801bd1a:	4640      	mov	r0, r8
 801bd1c:	4649      	mov	r1, r9
 801bd1e:	f00c ff23 	bl	8028b68 <__aeabi_dmul>
 801bd22:	4602      	mov	r2, r0
 801bd24:	460b      	mov	r3, r1
 801bd26:	4620      	mov	r0, r4
 801bd28:	4629      	mov	r1, r5
 801bd2a:	f00c fd65 	bl	80287f8 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801bd2e:	ee1d 2a10 	vmov	r2, s26
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801bd32:	4604      	mov	r4, r0
 801bd34:	460d      	mov	r5, r1
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801bd36:	465b      	mov	r3, fp
 801bd38:	4630      	mov	r0, r6
 801bd3a:	4639      	mov	r1, r7
 801bd3c:	f00c ff14 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801bd40:	ec45 4b19 	vmov	d9, r4, r5
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801bd44:	ec53 2b1c 	vmov	r2, r3, d12
 801bd48:	4604      	mov	r4, r0
 801bd4a:	460d      	mov	r5, r1
 801bd4c:	4640      	mov	r0, r8
 801bd4e:	4649      	mov	r1, r9
 801bd50:	f00c ff0a 	bl	8028b68 <__aeabi_dmul>
 801bd54:	460b      	mov	r3, r1
 801bd56:	4602      	mov	r2, r0
 801bd58:	4629      	mov	r1, r5
 801bd5a:	4620      	mov	r0, r4
 801bd5c:	f00c fd4e 	bl	80287fc <__adddf3>
        for (i = 0; i < M; i++) {
 801bd60:	9b05      	ldr	r3, [sp, #20]
 801bd62:	2b00      	cmp	r3, #0
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801bd64:	ec41 0b18 	vmov	d8, r0, r1
        for (i = 0; i < M; i++) {
 801bd68:	dd49      	ble.n	801bdfe <cblas_zgerc+0x1de>
 801bd6a:	9b04      	ldr	r3, [sp, #16]
 801bd6c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801bd6e:	9d02      	ldr	r5, [sp, #8]
 801bd70:	f103 0b08 	add.w	fp, r3, #8
 801bd74:	469a      	mov	sl, r3
          const BASE X_real = CONST_REAL(X, ix);
 801bd76:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801bd7a:	ec51 0b19 	vmov	r0, r1, d9
 801bd7e:	4632      	mov	r2, r6
 801bd80:	463b      	mov	r3, r7
 801bd82:	f00c fef1 	bl	8028b68 <__aeabi_dmul>
          const BASE X_imag = CONST_IMAG(X, ix);
 801bd86:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801bd8a:	ec41 0b1a 	vmov	d10, r0, r1
 801bd8e:	4642      	mov	r2, r8
 801bd90:	464b      	mov	r3, r9
 801bd92:	ec51 0b18 	vmov	r0, r1, d8
 801bd96:	f00c fee7 	bl	8028b68 <__aeabi_dmul>
 801bd9a:	4602      	mov	r2, r0
 801bd9c:	460b      	mov	r3, r1
 801bd9e:	ec51 0b1a 	vmov	r0, r1, d10
 801bda2:	f00c fd29 	bl	80287f8 <__aeabi_dsub>
 801bda6:	4602      	mov	r2, r0
 801bda8:	460b      	mov	r3, r1
 801bdaa:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801bdae:	f00c fd25 	bl	80287fc <__adddf3>
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801bdb2:	4642      	mov	r2, r8
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801bdb4:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801bdb8:	464b      	mov	r3, r9
 801bdba:	ec51 0b19 	vmov	r0, r1, d9
 801bdbe:	f00c fed3 	bl	8028b68 <__aeabi_dmul>
 801bdc2:	4632      	mov	r2, r6
 801bdc4:	463b      	mov	r3, r7
 801bdc6:	4606      	mov	r6, r0
 801bdc8:	460f      	mov	r7, r1
 801bdca:	ec51 0b18 	vmov	r0, r1, d8
 801bdce:	f00c fecb 	bl	8028b68 <__aeabi_dmul>
 801bdd2:	4602      	mov	r2, r0
 801bdd4:	460b      	mov	r3, r1
 801bdd6:	4630      	mov	r0, r6
 801bdd8:	4639      	mov	r1, r7
 801bdda:	f00c fd0f 	bl	80287fc <__adddf3>
 801bdde:	460b      	mov	r3, r1
 801bde0:	4602      	mov	r2, r0
 801bde2:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801bde6:	f00c fd09 	bl	80287fc <__adddf3>
 801bdea:	f10a 0a10 	add.w	sl, sl, #16
 801bdee:	9b00      	ldr	r3, [sp, #0]
 801bdf0:	e94a 0102 	strd	r0, r1, [sl, #-8]
        for (i = 0; i < M; i++) {
 801bdf4:	4555      	cmp	r5, sl
 801bdf6:	441c      	add	r4, r3
 801bdf8:	f10b 0b10 	add.w	fp, fp, #16
 801bdfc:	d1bb      	bne.n	801bd76 <cblas_zgerc+0x156>
      for (j = 0; j < N; j++) {
 801bdfe:	9a01      	ldr	r2, [sp, #4]
 801be00:	9908      	ldr	r1, [sp, #32]
 801be02:	9b06      	ldr	r3, [sp, #24]
 801be04:	440a      	add	r2, r1
 801be06:	9904      	ldr	r1, [sp, #16]
 801be08:	9201      	str	r2, [sp, #4]
 801be0a:	4608      	mov	r0, r1
 801be0c:	9a07      	ldr	r2, [sp, #28]
 801be0e:	9902      	ldr	r1, [sp, #8]
 801be10:	4410      	add	r0, r2
 801be12:	4411      	add	r1, r2
 801be14:	9a03      	ldr	r2, [sp, #12]
 801be16:	9004      	str	r0, [sp, #16]
 801be18:	3301      	adds	r3, #1
 801be1a:	429a      	cmp	r2, r3
 801be1c:	9306      	str	r3, [sp, #24]
 801be1e:	9102      	str	r1, [sp, #8]
 801be20:	f47f af61 	bne.w	801bce6 <cblas_zgerc+0xc6>
#define BASE double
#include "source_gerc.h"
#undef BASE
}
 801be24:	b00b      	add	sp, #44	; 0x2c
 801be26:	ecbd 8b0c 	vpop	{d8-d13}
 801be2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801be2e:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 801be32:	f000 8118 	beq.w	801c066 <cblas_zgerc+0x446>
 801be36:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 801be3a:	f040 8131 	bne.w	801c0a0 <cblas_zgerc+0x480>
 801be3e:	9b05      	ldr	r3, [sp, #20]
 801be40:	2b01      	cmp	r3, #1
 801be42:	bfb8      	it	lt
 801be44:	2301      	movlt	r3, #1
 801be46:	429e      	cmp	r6, r3
 801be48:	f280 812c 	bge.w	801c0a4 <cblas_zgerc+0x484>
 801be4c:	4a16      	ldr	r2, [pc, #88]	; (801bea8 <cblas_zgerc+0x288>)
 801be4e:	4917      	ldr	r1, [pc, #92]	; (801beac <cblas_zgerc+0x28c>)
 801be50:	200a      	movs	r0, #10
 801be52:	e718      	b.n	801bc86 <cblas_zgerc+0x66>
 801be54:	2c00      	cmp	r4, #0
 801be56:	f43f af04 	beq.w	801bc62 <cblas_zgerc+0x42>
 801be5a:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 801be5e:	f000 810b 	beq.w	801c078 <cblas_zgerc+0x458>
 801be62:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 801be66:	f000 8123 	beq.w	801c0b0 <cblas_zgerc+0x490>
 801be6a:	2800      	cmp	r0, #0
 801be6c:	f040 80f6 	bne.w	801c05c <cblas_zgerc+0x43c>
    const BASE alpha_real = CONST_REAL0(alpha);
 801be70:	ed99 7b00 	vldr	d7, [r9]
 801be74:	eeb0 ca47 	vmov.f32	s24, s14
 801be78:	eef0 ca67 	vmov.f32	s25, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801be7c:	ed99 7b02 	vldr	d7, [r9, #8]
    } else if (order == CblasColMajor) {
 801be80:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801be84:	eeb0 da47 	vmov.f32	s26, s14
 801be88:	eef0 da67 	vmov.f32	s27, s15
    } else if (order == CblasColMajor) {
 801be8c:	f43f af09 	beq.w	801bca2 <cblas_zgerc+0x82>
      BLAS_ERROR("unrecognized operation");
 801be90:	4a07      	ldr	r2, [pc, #28]	; (801beb0 <cblas_zgerc+0x290>)
 801be92:	4906      	ldr	r1, [pc, #24]	; (801beac <cblas_zgerc+0x28c>)
 801be94:	2000      	movs	r0, #0
 801be96:	b00b      	add	sp, #44	; 0x2c
 801be98:	ecbd 8b0c 	vpop	{d8-d13}
 801be9c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801bea0:	f00c bc32 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801bea4:	2002      	movs	r0, #2
 801bea6:	e6d2      	b.n	801bc4e <cblas_zgerc+0x2e>
 801bea8:	08031108 	.word	0x08031108
 801beac:	080312e0 	.word	0x080312e0
 801beb0:	080311b8 	.word	0x080311b8
 801beb4:	9803      	ldr	r0, [sp, #12]
 801beb6:	2801      	cmp	r0, #1
 801beb8:	bfb8      	it	lt
 801beba:	2001      	movlt	r0, #1
 801bebc:	4286      	cmp	r6, r0
 801bebe:	bfac      	ite	ge
 801bec0:	2008      	movge	r0, #8
 801bec2:	200a      	movlt	r0, #10
 801bec4:	4a80      	ldr	r2, [pc, #512]	; (801c0c8 <cblas_zgerc+0x4a8>)
 801bec6:	4981      	ldr	r1, [pc, #516]	; (801c0cc <cblas_zgerc+0x4ac>)
 801bec8:	f00c fc1e 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801becc:	ed99 7b00 	vldr	d7, [r9]
 801bed0:	eeb0 da47 	vmov.f32	s26, s14
 801bed4:	eef0 da67 	vmov.f32	s27, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801bed8:	ed99 7b02 	vldr	d7, [r9, #8]
      INDEX ix = OFFSET(M, incX);
 801bedc:	2d00      	cmp	r5, #0
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801bede:	eeb0 ca47 	vmov.f32	s24, s14
 801bee2:	eef0 ca67 	vmov.f32	s25, s15
      INDEX ix = OFFSET(M, incX);
 801bee6:	f340 80cf 	ble.w	801c088 <cblas_zgerc+0x468>
 801beea:	2200      	movs	r2, #0
      for (i = 0; i < M; i++) {
 801beec:	9b05      	ldr	r3, [sp, #20]
 801beee:	2b00      	cmp	r3, #0
 801bef0:	dd98      	ble.n	801be24 <cblas_zgerc+0x204>
 801bef2:	9903      	ldr	r1, [sp, #12]
 801bef4:	9704      	str	r7, [sp, #16]
 801bef6:	f1c1 0301 	rsb	r3, r1, #1
 801befa:	2c00      	cmp	r4, #0
 801befc:	fb03 f304 	mul.w	r3, r3, r4
 801bf00:	bfc8      	it	gt
 801bf02:	2300      	movgt	r3, #0
 801bf04:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
 801bf08:	eb0b 1202 	add.w	r2, fp, r2, lsl #4
 801bf0c:	9309      	str	r3, [sp, #36]	; 0x24
 801bf0e:	0123      	lsls	r3, r4, #4
 801bf10:	0128      	lsls	r0, r5, #4
 801bf12:	9202      	str	r2, [sp, #8]
 801bf14:	9301      	str	r3, [sp, #4]
 801bf16:	0132      	lsls	r2, r6, #4
        INDEX jy = OFFSET(N, incY);
 801bf18:	2300      	movs	r3, #0
 801bf1a:	9008      	str	r0, [sp, #32]
 801bf1c:	9207      	str	r2, [sp, #28]
 801bf1e:	eb07 1501 	add.w	r5, r7, r1, lsl #4
 801bf22:	9306      	str	r3, [sp, #24]
        const BASE X_real = CONST_REAL(X, ix);
 801bf24:	9c02      	ldr	r4, [sp, #8]
 801bf26:	e9d4 8900 	ldrd	r8, r9, [r4]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801bf2a:	ec53 2b1d 	vmov	r2, r3, d13
 801bf2e:	4640      	mov	r0, r8
 801bf30:	4649      	mov	r1, r9
 801bf32:	f00c fe19 	bl	8028b68 <__aeabi_dmul>
        const BASE X_imag = CONST_IMAG(X, ix);
 801bf36:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801bf3a:	ec53 2b1c 	vmov	r2, r3, d12
 801bf3e:	4682      	mov	sl, r0
 801bf40:	468b      	mov	fp, r1
 801bf42:	4630      	mov	r0, r6
 801bf44:	4639      	mov	r1, r7
 801bf46:	f00c fe0f 	bl	8028b68 <__aeabi_dmul>
 801bf4a:	4602      	mov	r2, r0
 801bf4c:	460b      	mov	r3, r1
 801bf4e:	4650      	mov	r0, sl
 801bf50:	4659      	mov	r1, fp
 801bf52:	f00c fc51 	bl	80287f8 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801bf56:	ec53 2b1c 	vmov	r2, r3, d12
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801bf5a:	4682      	mov	sl, r0
 801bf5c:	468b      	mov	fp, r1
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801bf5e:	4640      	mov	r0, r8
 801bf60:	4649      	mov	r1, r9
 801bf62:	f00c fe01 	bl	8028b68 <__aeabi_dmul>
 801bf66:	ec53 2b1d 	vmov	r2, r3, d13
 801bf6a:	4680      	mov	r8, r0
 801bf6c:	4689      	mov	r9, r1
 801bf6e:	4630      	mov	r0, r6
 801bf70:	4639      	mov	r1, r7
 801bf72:	f00c fdf9 	bl	8028b68 <__aeabi_dmul>
 801bf76:	460b      	mov	r3, r1
 801bf78:	4602      	mov	r2, r0
 801bf7a:	4649      	mov	r1, r9
 801bf7c:	4640      	mov	r0, r8
 801bf7e:	f00c fc3d 	bl	80287fc <__adddf3>
        for (j = 0; j < N; j++) {
 801bf82:	9b03      	ldr	r3, [sp, #12]
 801bf84:	2b00      	cmp	r3, #0
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801bf86:	ec4b ab1b 	vmov	d11, sl, fp
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801bf8a:	ec41 0b18 	vmov	d8, r0, r1
        for (j = 0; j < N; j++) {
 801bf8e:	dd4e      	ble.n	801c02e <cblas_zgerc+0x40e>
 801bf90:	9b04      	ldr	r3, [sp, #16]
 801bf92:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801bf94:	9500      	str	r5, [sp, #0]
 801bf96:	f103 0b08 	add.w	fp, r3, #8
 801bf9a:	469a      	mov	sl, r3
          const BASE Y_real = CONST_REAL(Y, jy);
 801bf9c:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801bfa0:	ec51 0b1b 	vmov	r0, r1, d11
 801bfa4:	4632      	mov	r2, r6
 801bfa6:	463b      	mov	r3, r7
 801bfa8:	f00c fdde 	bl	8028b68 <__aeabi_dmul>
          const BASE Y_imag = -CONST_IMAG(Y, jy);
 801bfac:	68e5      	ldr	r5, [r4, #12]
 801bfae:	f8d4 8008 	ldr.w	r8, [r4, #8]
 801bfb2:	f105 4900 	add.w	r9, r5, #2147483648	; 0x80000000
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801bfb6:	ec41 0b1a 	vmov	d10, r0, r1
 801bfba:	4642      	mov	r2, r8
 801bfbc:	464b      	mov	r3, r9
 801bfbe:	ec51 0b18 	vmov	r0, r1, d8
 801bfc2:	f00c fdd1 	bl	8028b68 <__aeabi_dmul>
 801bfc6:	4602      	mov	r2, r0
 801bfc8:	460b      	mov	r3, r1
 801bfca:	ec51 0b1a 	vmov	r0, r1, d10
 801bfce:	f00c fc13 	bl	80287f8 <__aeabi_dsub>
 801bfd2:	4602      	mov	r2, r0
 801bfd4:	460b      	mov	r3, r1
 801bfd6:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801bfda:	f00c fc0f 	bl	80287fc <__adddf3>
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801bfde:	4642      	mov	r2, r8
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801bfe0:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801bfe4:	464b      	mov	r3, r9
 801bfe6:	ec51 0b1b 	vmov	r0, r1, d11
 801bfea:	f00c fdbd 	bl	8028b68 <__aeabi_dmul>
 801bfee:	4632      	mov	r2, r6
 801bff0:	463b      	mov	r3, r7
 801bff2:	4606      	mov	r6, r0
 801bff4:	460f      	mov	r7, r1
 801bff6:	ec51 0b18 	vmov	r0, r1, d8
 801bffa:	f00c fdb5 	bl	8028b68 <__aeabi_dmul>
 801bffe:	4602      	mov	r2, r0
 801c000:	460b      	mov	r3, r1
 801c002:	4630      	mov	r0, r6
 801c004:	4639      	mov	r1, r7
 801c006:	f00c fbf9 	bl	80287fc <__adddf3>
 801c00a:	460b      	mov	r3, r1
 801c00c:	4602      	mov	r2, r0
 801c00e:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801c012:	f00c fbf3 	bl	80287fc <__adddf3>
 801c016:	9b01      	ldr	r3, [sp, #4]
 801c018:	441c      	add	r4, r3
        for (j = 0; j < N; j++) {
 801c01a:	9b00      	ldr	r3, [sp, #0]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801c01c:	e9ca 0102 	strd	r0, r1, [sl, #8]
        for (j = 0; j < N; j++) {
 801c020:	f10a 0a10 	add.w	sl, sl, #16
 801c024:	4553      	cmp	r3, sl
 801c026:	f10b 0b10 	add.w	fp, fp, #16
 801c02a:	d1b7      	bne.n	801bf9c <cblas_zgerc+0x37c>
 801c02c:	461d      	mov	r5, r3
      for (i = 0; i < M; i++) {
 801c02e:	9a02      	ldr	r2, [sp, #8]
 801c030:	9908      	ldr	r1, [sp, #32]
 801c032:	9b06      	ldr	r3, [sp, #24]
 801c034:	440a      	add	r2, r1
 801c036:	9904      	ldr	r1, [sp, #16]
 801c038:	9202      	str	r2, [sp, #8]
 801c03a:	9a07      	ldr	r2, [sp, #28]
 801c03c:	4608      	mov	r0, r1
 801c03e:	4410      	add	r0, r2
 801c040:	4415      	add	r5, r2
 801c042:	9a05      	ldr	r2, [sp, #20]
 801c044:	9004      	str	r0, [sp, #16]
 801c046:	3301      	adds	r3, #1
 801c048:	429a      	cmp	r2, r3
 801c04a:	9306      	str	r3, [sp, #24]
 801c04c:	f47f af6a 	bne.w	801bf24 <cblas_zgerc+0x304>
 801c050:	b00b      	add	sp, #44	; 0x2c
 801c052:	ecbd 8b0c 	vpop	{d8-d13}
 801c056:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801c05a:	2008      	movs	r0, #8
 801c05c:	4a1a      	ldr	r2, [pc, #104]	; (801c0c8 <cblas_zgerc+0x4a8>)
 801c05e:	491b      	ldr	r1, [pc, #108]	; (801c0cc <cblas_zgerc+0x4ac>)
 801c060:	f00c fb52 	bl	8028708 <cblas_xerbla>
 801c064:	e704      	b.n	801be70 <cblas_zgerc+0x250>
 801c066:	2b01      	cmp	r3, #1
 801c068:	4618      	mov	r0, r3
 801c06a:	bfb8      	it	lt
 801c06c:	2001      	movlt	r0, #1
 801c06e:	42b0      	cmp	r0, r6
 801c070:	bfcc      	ite	gt
 801c072:	200a      	movgt	r0, #10
 801c074:	2006      	movle	r0, #6
 801c076:	e725      	b.n	801bec4 <cblas_zgerc+0x2a4>
 801c078:	9b03      	ldr	r3, [sp, #12]
 801c07a:	2b01      	cmp	r3, #1
 801c07c:	bfb8      	it	lt
 801c07e:	2301      	movlt	r3, #1
 801c080:	42b3      	cmp	r3, r6
 801c082:	dd11      	ble.n	801c0a8 <cblas_zgerc+0x488>
 801c084:	200a      	movs	r0, #10
 801c086:	e71d      	b.n	801bec4 <cblas_zgerc+0x2a4>
      INDEX ix = OFFSET(M, incX);
 801c088:	9b05      	ldr	r3, [sp, #20]
 801c08a:	f1c3 0201 	rsb	r2, r3, #1
 801c08e:	fb02 f205 	mul.w	r2, r2, r5
 801c092:	e72b      	b.n	801beec <cblas_zgerc+0x2cc>
      INDEX jy = OFFSET(N, incY);
 801c094:	9b03      	ldr	r3, [sp, #12]
 801c096:	f1c3 0201 	rsb	r2, r3, #1
 801c09a:	fb02 f204 	mul.w	r2, r2, r4
 801c09e:	e604      	b.n	801bcaa <cblas_zgerc+0x8a>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801c0a0:	2006      	movs	r0, #6
 801c0a2:	e7db      	b.n	801c05c <cblas_zgerc+0x43c>
 801c0a4:	2006      	movs	r0, #6
 801c0a6:	e5ec      	b.n	801bc82 <cblas_zgerc+0x62>
 801c0a8:	2800      	cmp	r0, #0
 801c0aa:	f43f af0f 	beq.w	801becc <cblas_zgerc+0x2ac>
 801c0ae:	e709      	b.n	801bec4 <cblas_zgerc+0x2a4>
 801c0b0:	9b05      	ldr	r3, [sp, #20]
 801c0b2:	2b01      	cmp	r3, #1
 801c0b4:	bfb8      	it	lt
 801c0b6:	2301      	movlt	r3, #1
 801c0b8:	42b3      	cmp	r3, r6
 801c0ba:	f73f aec7 	bgt.w	801be4c <cblas_zgerc+0x22c>
 801c0be:	2800      	cmp	r0, #0
 801c0c0:	f43f aed6 	beq.w	801be70 <cblas_zgerc+0x250>
 801c0c4:	e5dd      	b.n	801bc82 <cblas_zgerc+0x62>
 801c0c6:	bf00      	nop
 801c0c8:	08031108 	.word	0x08031108
 801c0cc:	080312e0 	.word	0x080312e0

0801c0d0 <cblas_zgeru>:

void
cblas_zgeru (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 801c0d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c0d4:	ed2d 8b0a 	vpush	{d8-d12}
 801c0d8:	b08b      	sub	sp, #44	; 0x2c
 801c0da:	469b      	mov	fp, r3
 801c0dc:	1e0b      	subs	r3, r1, #0
 801c0de:	e9dd 751e 	ldrd	r7, r5, [sp, #120]	; 0x78
 801c0e2:	e9dd 8420 	ldrd	r8, r4, [sp, #128]	; 0x80
 801c0e6:	e9dd 9622 	ldrd	r9, r6, [sp, #136]	; 0x88
 801c0ea:	4682      	mov	sl, r0
 801c0ec:	9202      	str	r2, [sp, #8]
 801c0ee:	9305      	str	r3, [sp, #20]
 801c0f0:	f2c0 8129 	blt.w	801c346 <cblas_zgeru+0x276>
 801c0f4:	3865      	subs	r0, #101	; 0x65
 801c0f6:	2801      	cmp	r0, #1
 801c0f8:	bf94      	ite	ls
 801c0fa:	2000      	movls	r0, #0
 801c0fc:	2001      	movhi	r0, #1
 801c0fe:	9b02      	ldr	r3, [sp, #8]
 801c100:	2b00      	cmp	r3, #0
 801c102:	bfb8      	it	lt
 801c104:	2003      	movlt	r0, #3
 801c106:	2d00      	cmp	r5, #0
 801c108:	f040 80f5 	bne.w	801c2f6 <cblas_zgeru+0x226>
 801c10c:	2c00      	cmp	r4, #0
 801c10e:	f040 80df 	bne.w	801c2d0 <cblas_zgeru+0x200>
 801c112:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801c116:	f000 811f 	beq.w	801c358 <cblas_zgeru+0x288>
 801c11a:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801c11e:	f040 81f2 	bne.w	801c506 <cblas_zgeru+0x436>
 801c122:	9b05      	ldr	r3, [sp, #20]
 801c124:	2b01      	cmp	r3, #1
 801c126:	bfb8      	it	lt
 801c128:	2301      	movlt	r3, #1
 801c12a:	429e      	cmp	r6, r3
 801c12c:	f2c0 80df 	blt.w	801c2ee <cblas_zgeru+0x21e>
 801c130:	2008      	movs	r0, #8
 801c132:	4a86      	ldr	r2, [pc, #536]	; (801c34c <cblas_zgeru+0x27c>)
 801c134:	4986      	ldr	r1, [pc, #536]	; (801c350 <cblas_zgeru+0x280>)
 801c136:	f00c fae7 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801c13a:	ed9b 7b00 	vldr	d7, [fp]
 801c13e:	eeb0 ba47 	vmov.f32	s22, s14
 801c142:	eef0 ba67 	vmov.f32	s23, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c146:	ed9b 7b02 	vldr	d7, [fp, #8]
 801c14a:	eeb0 ca47 	vmov.f32	s24, s14
 801c14e:	eef0 ca67 	vmov.f32	s25, s15
      INDEX jy = OFFSET(N, incY);
 801c152:	2c00      	cmp	r4, #0
 801c154:	f340 81f4 	ble.w	801c540 <cblas_zgeru+0x470>
 801c158:	2200      	movs	r2, #0
      for (j = 0; j < N; j++) {
 801c15a:	9b02      	ldr	r3, [sp, #8]
 801c15c:	2b00      	cmp	r3, #0
 801c15e:	f340 80b2 	ble.w	801c2c6 <cblas_zgeru+0x1f6>
 801c162:	9905      	ldr	r1, [sp, #20]
 801c164:	f8cd 9010 	str.w	r9, [sp, #16]
 801c168:	f1c1 0301 	rsb	r3, r1, #1
 801c16c:	2d00      	cmp	r5, #0
 801c16e:	fb03 f305 	mul.w	r3, r3, r5
 801c172:	bfc8      	it	gt
 801c174:	2300      	movgt	r3, #0
 801c176:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801c17a:	9309      	str	r3, [sp, #36]	; 0x24
 801c17c:	012b      	lsls	r3, r5, #4
 801c17e:	eb08 1202 	add.w	r2, r8, r2, lsl #4
 801c182:	9300      	str	r3, [sp, #0]
 801c184:	eb09 1301 	add.w	r3, r9, r1, lsl #4
 801c188:	0120      	lsls	r0, r4, #4
 801c18a:	9201      	str	r2, [sp, #4]
 801c18c:	9303      	str	r3, [sp, #12]
 801c18e:	0132      	lsls	r2, r6, #4
        INDEX ix = OFFSET(M, incX);
 801c190:	2300      	movs	r3, #0
 801c192:	9008      	str	r0, [sp, #32]
 801c194:	9207      	str	r2, [sp, #28]
 801c196:	9306      	str	r3, [sp, #24]
        const BASE Y_real = CONST_REAL(Y, jy);
 801c198:	9c01      	ldr	r4, [sp, #4]
 801c19a:	e9d4 6700 	ldrd	r6, r7, [r4]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801c19e:	ec53 2b1b 	vmov	r2, r3, d11
 801c1a2:	4630      	mov	r0, r6
 801c1a4:	4639      	mov	r1, r7
 801c1a6:	f00c fcdf 	bl	8028b68 <__aeabi_dmul>
        const BASE Y_imag = CONST_IMAG(Y, jy);
 801c1aa:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801c1ae:	ec5b ab1c 	vmov	sl, fp, d12
 801c1b2:	4604      	mov	r4, r0
 801c1b4:	460d      	mov	r5, r1
 801c1b6:	ee1c 2a10 	vmov	r2, s24
 801c1ba:	465b      	mov	r3, fp
 801c1bc:	4640      	mov	r0, r8
 801c1be:	4649      	mov	r1, r9
 801c1c0:	f00c fcd2 	bl	8028b68 <__aeabi_dmul>
 801c1c4:	4602      	mov	r2, r0
 801c1c6:	460b      	mov	r3, r1
 801c1c8:	4620      	mov	r0, r4
 801c1ca:	4629      	mov	r1, r5
 801c1cc:	f00c fb14 	bl	80287f8 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801c1d0:	ee1c 2a10 	vmov	r2, s24
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801c1d4:	4604      	mov	r4, r0
 801c1d6:	460d      	mov	r5, r1
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801c1d8:	465b      	mov	r3, fp
 801c1da:	4630      	mov	r0, r6
 801c1dc:	4639      	mov	r1, r7
 801c1de:	f00c fcc3 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801c1e2:	ec45 4b19 	vmov	d9, r4, r5
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801c1e6:	ec53 2b1b 	vmov	r2, r3, d11
 801c1ea:	4604      	mov	r4, r0
 801c1ec:	460d      	mov	r5, r1
 801c1ee:	4640      	mov	r0, r8
 801c1f0:	4649      	mov	r1, r9
 801c1f2:	f00c fcb9 	bl	8028b68 <__aeabi_dmul>
 801c1f6:	460b      	mov	r3, r1
 801c1f8:	4602      	mov	r2, r0
 801c1fa:	4629      	mov	r1, r5
 801c1fc:	4620      	mov	r0, r4
 801c1fe:	f00c fafd 	bl	80287fc <__adddf3>
        for (i = 0; i < M; i++) {
 801c202:	9b05      	ldr	r3, [sp, #20]
 801c204:	2b00      	cmp	r3, #0
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801c206:	ec41 0b18 	vmov	d8, r0, r1
        for (i = 0; i < M; i++) {
 801c20a:	dd49      	ble.n	801c2a0 <cblas_zgeru+0x1d0>
 801c20c:	9b04      	ldr	r3, [sp, #16]
 801c20e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801c210:	9d03      	ldr	r5, [sp, #12]
 801c212:	f103 0b08 	add.w	fp, r3, #8
 801c216:	469a      	mov	sl, r3
          const BASE X_real = CONST_REAL(X, ix);
 801c218:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801c21c:	ec51 0b19 	vmov	r0, r1, d9
 801c220:	4632      	mov	r2, r6
 801c222:	463b      	mov	r3, r7
 801c224:	f00c fca0 	bl	8028b68 <__aeabi_dmul>
          const BASE X_imag = CONST_IMAG(X, ix);
 801c228:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801c22c:	ec41 0b1a 	vmov	d10, r0, r1
 801c230:	4642      	mov	r2, r8
 801c232:	464b      	mov	r3, r9
 801c234:	ec51 0b18 	vmov	r0, r1, d8
 801c238:	f00c fc96 	bl	8028b68 <__aeabi_dmul>
 801c23c:	4602      	mov	r2, r0
 801c23e:	460b      	mov	r3, r1
 801c240:	ec51 0b1a 	vmov	r0, r1, d10
 801c244:	f00c fad8 	bl	80287f8 <__aeabi_dsub>
 801c248:	4602      	mov	r2, r0
 801c24a:	460b      	mov	r3, r1
 801c24c:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801c250:	f00c fad4 	bl	80287fc <__adddf3>
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801c254:	4642      	mov	r2, r8
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801c256:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801c25a:	464b      	mov	r3, r9
 801c25c:	ec51 0b19 	vmov	r0, r1, d9
 801c260:	f00c fc82 	bl	8028b68 <__aeabi_dmul>
 801c264:	4632      	mov	r2, r6
 801c266:	463b      	mov	r3, r7
 801c268:	4606      	mov	r6, r0
 801c26a:	460f      	mov	r7, r1
 801c26c:	ec51 0b18 	vmov	r0, r1, d8
 801c270:	f00c fc7a 	bl	8028b68 <__aeabi_dmul>
 801c274:	4602      	mov	r2, r0
 801c276:	460b      	mov	r3, r1
 801c278:	4630      	mov	r0, r6
 801c27a:	4639      	mov	r1, r7
 801c27c:	f00c fabe 	bl	80287fc <__adddf3>
 801c280:	460b      	mov	r3, r1
 801c282:	4602      	mov	r2, r0
 801c284:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801c288:	f00c fab8 	bl	80287fc <__adddf3>
 801c28c:	f10a 0a10 	add.w	sl, sl, #16
 801c290:	9b00      	ldr	r3, [sp, #0]
 801c292:	e94a 0102 	strd	r0, r1, [sl, #-8]
        for (i = 0; i < M; i++) {
 801c296:	4555      	cmp	r5, sl
 801c298:	441c      	add	r4, r3
 801c29a:	f10b 0b10 	add.w	fp, fp, #16
 801c29e:	d1bb      	bne.n	801c218 <cblas_zgeru+0x148>
      for (j = 0; j < N; j++) {
 801c2a0:	9a01      	ldr	r2, [sp, #4]
 801c2a2:	9908      	ldr	r1, [sp, #32]
 801c2a4:	9b06      	ldr	r3, [sp, #24]
 801c2a6:	440a      	add	r2, r1
 801c2a8:	9904      	ldr	r1, [sp, #16]
 801c2aa:	9201      	str	r2, [sp, #4]
 801c2ac:	4608      	mov	r0, r1
 801c2ae:	9a07      	ldr	r2, [sp, #28]
 801c2b0:	9903      	ldr	r1, [sp, #12]
 801c2b2:	4410      	add	r0, r2
 801c2b4:	4411      	add	r1, r2
 801c2b6:	9a02      	ldr	r2, [sp, #8]
 801c2b8:	9004      	str	r0, [sp, #16]
 801c2ba:	3301      	adds	r3, #1
 801c2bc:	429a      	cmp	r2, r3
 801c2be:	9306      	str	r3, [sp, #24]
 801c2c0:	9103      	str	r1, [sp, #12]
 801c2c2:	f47f af69 	bne.w	801c198 <cblas_zgeru+0xc8>
#define BASE double
#include "source_geru.h"
#undef BASE
}
 801c2c6:	b00b      	add	sp, #44	; 0x2c
 801c2c8:	ecbd 8b0a 	vpop	{d8-d12}
 801c2cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801c2d0:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801c2d4:	f000 811d 	beq.w	801c512 <cblas_zgeru+0x442>
 801c2d8:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801c2dc:	f040 8136 	bne.w	801c54c <cblas_zgeru+0x47c>
 801c2e0:	9b05      	ldr	r3, [sp, #20]
 801c2e2:	2b01      	cmp	r3, #1
 801c2e4:	bfb8      	it	lt
 801c2e6:	2301      	movlt	r3, #1
 801c2e8:	429e      	cmp	r6, r3
 801c2ea:	f280 8131 	bge.w	801c550 <cblas_zgeru+0x480>
 801c2ee:	4a17      	ldr	r2, [pc, #92]	; (801c34c <cblas_zgeru+0x27c>)
 801c2f0:	4917      	ldr	r1, [pc, #92]	; (801c350 <cblas_zgeru+0x280>)
 801c2f2:	200a      	movs	r0, #10
 801c2f4:	e71f      	b.n	801c136 <cblas_zgeru+0x66>
 801c2f6:	2c00      	cmp	r4, #0
 801c2f8:	f43f af0b 	beq.w	801c112 <cblas_zgeru+0x42>
 801c2fc:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801c300:	f000 8110 	beq.w	801c524 <cblas_zgeru+0x454>
 801c304:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801c308:	f000 8128 	beq.w	801c55c <cblas_zgeru+0x48c>
 801c30c:	2800      	cmp	r0, #0
 801c30e:	f040 80fb 	bne.w	801c508 <cblas_zgeru+0x438>
    const BASE alpha_real = CONST_REAL0(alpha);
 801c312:	ed9b 7b00 	vldr	d7, [fp]
 801c316:	eeb0 ba47 	vmov.f32	s22, s14
 801c31a:	eef0 ba67 	vmov.f32	s23, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c31e:	ed9b 7b02 	vldr	d7, [fp, #8]
    } else if (order == CblasColMajor) {
 801c322:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c326:	eeb0 ca47 	vmov.f32	s24, s14
 801c32a:	eef0 ca67 	vmov.f32	s25, s15
    } else if (order == CblasColMajor) {
 801c32e:	f43f af10 	beq.w	801c152 <cblas_zgeru+0x82>
      BLAS_ERROR("unrecognized operation");
 801c332:	4a08      	ldr	r2, [pc, #32]	; (801c354 <cblas_zgeru+0x284>)
 801c334:	4906      	ldr	r1, [pc, #24]	; (801c350 <cblas_zgeru+0x280>)
 801c336:	2000      	movs	r0, #0
 801c338:	b00b      	add	sp, #44	; 0x2c
 801c33a:	ecbd 8b0a 	vpop	{d8-d12}
 801c33e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c342:	f00c b9e1 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801c346:	2002      	movs	r0, #2
 801c348:	e6d9      	b.n	801c0fe <cblas_zgeru+0x2e>
 801c34a:	bf00      	nop
 801c34c:	08031108 	.word	0x08031108
 801c350:	080312f0 	.word	0x080312f0
 801c354:	080311b8 	.word	0x080311b8
 801c358:	9802      	ldr	r0, [sp, #8]
 801c35a:	2801      	cmp	r0, #1
 801c35c:	bfb8      	it	lt
 801c35e:	2001      	movlt	r0, #1
 801c360:	4286      	cmp	r6, r0
 801c362:	bfac      	ite	ge
 801c364:	2008      	movge	r0, #8
 801c366:	200a      	movlt	r0, #10
 801c368:	4a82      	ldr	r2, [pc, #520]	; (801c574 <cblas_zgeru+0x4a4>)
 801c36a:	4983      	ldr	r1, [pc, #524]	; (801c578 <cblas_zgeru+0x4a8>)
 801c36c:	f00c f9cc 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801c370:	ed9b 7b00 	vldr	d7, [fp]
 801c374:	eeb0 ca47 	vmov.f32	s24, s14
 801c378:	eef0 ca67 	vmov.f32	s25, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c37c:	ed9b 7b02 	vldr	d7, [fp, #8]
      INDEX ix = OFFSET(M, incX);
 801c380:	2d00      	cmp	r5, #0
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c382:	eeb0 ba47 	vmov.f32	s22, s14
 801c386:	eef0 ba67 	vmov.f32	s23, s15
      INDEX ix = OFFSET(M, incX);
 801c38a:	f340 80d3 	ble.w	801c534 <cblas_zgeru+0x464>
 801c38e:	2200      	movs	r2, #0
      for (i = 0; i < M; i++) {
 801c390:	9b05      	ldr	r3, [sp, #20]
 801c392:	2b00      	cmp	r3, #0
 801c394:	dd97      	ble.n	801c2c6 <cblas_zgeru+0x1f6>
 801c396:	9902      	ldr	r1, [sp, #8]
 801c398:	f8cd 900c 	str.w	r9, [sp, #12]
 801c39c:	f1c1 0301 	rsb	r3, r1, #1
 801c3a0:	2c00      	cmp	r4, #0
 801c3a2:	fb03 f304 	mul.w	r3, r3, r4
 801c3a6:	bfc8      	it	gt
 801c3a8:	2300      	movgt	r3, #0
 801c3aa:	eb08 1303 	add.w	r3, r8, r3, lsl #4
 801c3ae:	9309      	str	r3, [sp, #36]	; 0x24
 801c3b0:	0123      	lsls	r3, r4, #4
 801c3b2:	eb07 1202 	add.w	r2, r7, r2, lsl #4
 801c3b6:	9308      	str	r3, [sp, #32]
 801c3b8:	eb09 1301 	add.w	r3, r9, r1, lsl #4
 801c3bc:	0128      	lsls	r0, r5, #4
 801c3be:	9201      	str	r2, [sp, #4]
 801c3c0:	9300      	str	r3, [sp, #0]
 801c3c2:	0132      	lsls	r2, r6, #4
        INDEX jy = OFFSET(N, incY);
 801c3c4:	2300      	movs	r3, #0
 801c3c6:	9007      	str	r0, [sp, #28]
 801c3c8:	9206      	str	r2, [sp, #24]
 801c3ca:	9304      	str	r3, [sp, #16]
        const BASE X_real = CONST_REAL(X, ix);
 801c3cc:	9c01      	ldr	r4, [sp, #4]
 801c3ce:	e9d4 6700 	ldrd	r6, r7, [r4]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801c3d2:	ec53 2b1c 	vmov	r2, r3, d12
 801c3d6:	4630      	mov	r0, r6
 801c3d8:	4639      	mov	r1, r7
 801c3da:	f00c fbc5 	bl	8028b68 <__aeabi_dmul>
        const BASE X_imag = CONST_IMAG(X, ix);
 801c3de:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801c3e2:	ec5b ab1b 	vmov	sl, fp, d11
 801c3e6:	4604      	mov	r4, r0
 801c3e8:	460d      	mov	r5, r1
 801c3ea:	ee1b 2a10 	vmov	r2, s22
 801c3ee:	465b      	mov	r3, fp
 801c3f0:	4640      	mov	r0, r8
 801c3f2:	4649      	mov	r1, r9
 801c3f4:	f00c fbb8 	bl	8028b68 <__aeabi_dmul>
 801c3f8:	4602      	mov	r2, r0
 801c3fa:	460b      	mov	r3, r1
 801c3fc:	4620      	mov	r0, r4
 801c3fe:	4629      	mov	r1, r5
 801c400:	f00c f9fa 	bl	80287f8 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801c404:	ee1b 2a10 	vmov	r2, s22
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801c408:	4604      	mov	r4, r0
 801c40a:	460d      	mov	r5, r1
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801c40c:	465b      	mov	r3, fp
 801c40e:	4630      	mov	r0, r6
 801c410:	4639      	mov	r1, r7
 801c412:	f00c fba9 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801c416:	ec45 4b19 	vmov	d9, r4, r5
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801c41a:	ec53 2b1c 	vmov	r2, r3, d12
 801c41e:	4604      	mov	r4, r0
 801c420:	460d      	mov	r5, r1
 801c422:	4640      	mov	r0, r8
 801c424:	4649      	mov	r1, r9
 801c426:	f00c fb9f 	bl	8028b68 <__aeabi_dmul>
 801c42a:	460b      	mov	r3, r1
 801c42c:	4602      	mov	r2, r0
 801c42e:	4629      	mov	r1, r5
 801c430:	4620      	mov	r0, r4
 801c432:	f00c f9e3 	bl	80287fc <__adddf3>
        for (j = 0; j < N; j++) {
 801c436:	9b02      	ldr	r3, [sp, #8]
 801c438:	2b00      	cmp	r3, #0
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801c43a:	ec41 0b18 	vmov	d8, r0, r1
        for (j = 0; j < N; j++) {
 801c43e:	dd4a      	ble.n	801c4d6 <cblas_zgeru+0x406>
 801c440:	9b03      	ldr	r3, [sp, #12]
 801c442:	f103 0b08 	add.w	fp, r3, #8
 801c446:	469a      	mov	sl, r3
 801c448:	e9dd 5308 	ldrd	r5, r3, [sp, #32]
 801c44c:	461c      	mov	r4, r3
          const BASE Y_real = CONST_REAL(Y, jy);
 801c44e:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801c452:	ec51 0b19 	vmov	r0, r1, d9
 801c456:	4632      	mov	r2, r6
 801c458:	463b      	mov	r3, r7
 801c45a:	f00c fb85 	bl	8028b68 <__aeabi_dmul>
          const BASE Y_imag = CONST_IMAG(Y, jy);
 801c45e:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801c462:	ec41 0b1a 	vmov	d10, r0, r1
 801c466:	4642      	mov	r2, r8
 801c468:	464b      	mov	r3, r9
 801c46a:	ec51 0b18 	vmov	r0, r1, d8
 801c46e:	f00c fb7b 	bl	8028b68 <__aeabi_dmul>
 801c472:	4602      	mov	r2, r0
 801c474:	460b      	mov	r3, r1
 801c476:	ec51 0b1a 	vmov	r0, r1, d10
 801c47a:	f00c f9bd 	bl	80287f8 <__aeabi_dsub>
 801c47e:	4602      	mov	r2, r0
 801c480:	460b      	mov	r3, r1
 801c482:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801c486:	f00c f9b9 	bl	80287fc <__adddf3>
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801c48a:	4642      	mov	r2, r8
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801c48c:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801c490:	464b      	mov	r3, r9
 801c492:	ec51 0b19 	vmov	r0, r1, d9
 801c496:	f00c fb67 	bl	8028b68 <__aeabi_dmul>
 801c49a:	4632      	mov	r2, r6
 801c49c:	463b      	mov	r3, r7
 801c49e:	4606      	mov	r6, r0
 801c4a0:	460f      	mov	r7, r1
 801c4a2:	ec51 0b18 	vmov	r0, r1, d8
 801c4a6:	f00c fb5f 	bl	8028b68 <__aeabi_dmul>
 801c4aa:	4602      	mov	r2, r0
 801c4ac:	460b      	mov	r3, r1
 801c4ae:	4630      	mov	r0, r6
 801c4b0:	4639      	mov	r1, r7
 801c4b2:	f00c f9a3 	bl	80287fc <__adddf3>
 801c4b6:	460b      	mov	r3, r1
 801c4b8:	4602      	mov	r2, r0
 801c4ba:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801c4be:	f00c f99d 	bl	80287fc <__adddf3>
        for (j = 0; j < N; j++) {
 801c4c2:	9b00      	ldr	r3, [sp, #0]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801c4c4:	e9ca 0102 	strd	r0, r1, [sl, #8]
        for (j = 0; j < N; j++) {
 801c4c8:	f10a 0a10 	add.w	sl, sl, #16
 801c4cc:	4553      	cmp	r3, sl
 801c4ce:	442c      	add	r4, r5
 801c4d0:	f10b 0b10 	add.w	fp, fp, #16
 801c4d4:	d1bb      	bne.n	801c44e <cblas_zgeru+0x37e>
      for (i = 0; i < M; i++) {
 801c4d6:	9a01      	ldr	r2, [sp, #4]
 801c4d8:	9907      	ldr	r1, [sp, #28]
 801c4da:	9b04      	ldr	r3, [sp, #16]
 801c4dc:	440a      	add	r2, r1
 801c4de:	9903      	ldr	r1, [sp, #12]
 801c4e0:	9201      	str	r2, [sp, #4]
 801c4e2:	4608      	mov	r0, r1
 801c4e4:	9a06      	ldr	r2, [sp, #24]
 801c4e6:	9900      	ldr	r1, [sp, #0]
 801c4e8:	4410      	add	r0, r2
 801c4ea:	4411      	add	r1, r2
 801c4ec:	9a05      	ldr	r2, [sp, #20]
 801c4ee:	9003      	str	r0, [sp, #12]
 801c4f0:	3301      	adds	r3, #1
 801c4f2:	429a      	cmp	r2, r3
 801c4f4:	9304      	str	r3, [sp, #16]
 801c4f6:	9100      	str	r1, [sp, #0]
 801c4f8:	f47f af68 	bne.w	801c3cc <cblas_zgeru+0x2fc>
 801c4fc:	b00b      	add	sp, #44	; 0x2c
 801c4fe:	ecbd 8b0a 	vpop	{d8-d12}
 801c502:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801c506:	2008      	movs	r0, #8
 801c508:	4a1a      	ldr	r2, [pc, #104]	; (801c574 <cblas_zgeru+0x4a4>)
 801c50a:	491b      	ldr	r1, [pc, #108]	; (801c578 <cblas_zgeru+0x4a8>)
 801c50c:	f00c f8fc 	bl	8028708 <cblas_xerbla>
 801c510:	e6ff      	b.n	801c312 <cblas_zgeru+0x242>
 801c512:	2b01      	cmp	r3, #1
 801c514:	4618      	mov	r0, r3
 801c516:	bfb8      	it	lt
 801c518:	2001      	movlt	r0, #1
 801c51a:	42b0      	cmp	r0, r6
 801c51c:	bfcc      	ite	gt
 801c51e:	200a      	movgt	r0, #10
 801c520:	2006      	movle	r0, #6
 801c522:	e721      	b.n	801c368 <cblas_zgeru+0x298>
 801c524:	9b02      	ldr	r3, [sp, #8]
 801c526:	2b01      	cmp	r3, #1
 801c528:	bfb8      	it	lt
 801c52a:	2301      	movlt	r3, #1
 801c52c:	42b3      	cmp	r3, r6
 801c52e:	dd11      	ble.n	801c554 <cblas_zgeru+0x484>
 801c530:	200a      	movs	r0, #10
 801c532:	e719      	b.n	801c368 <cblas_zgeru+0x298>
      INDEX ix = OFFSET(M, incX);
 801c534:	9b05      	ldr	r3, [sp, #20]
 801c536:	f1c3 0201 	rsb	r2, r3, #1
 801c53a:	fb02 f205 	mul.w	r2, r2, r5
 801c53e:	e727      	b.n	801c390 <cblas_zgeru+0x2c0>
      INDEX jy = OFFSET(N, incY);
 801c540:	9b02      	ldr	r3, [sp, #8]
 801c542:	f1c3 0201 	rsb	r2, r3, #1
 801c546:	fb02 f204 	mul.w	r2, r2, r4
 801c54a:	e606      	b.n	801c15a <cblas_zgeru+0x8a>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801c54c:	2006      	movs	r0, #6
 801c54e:	e7db      	b.n	801c508 <cblas_zgeru+0x438>
 801c550:	2006      	movs	r0, #6
 801c552:	e5ee      	b.n	801c132 <cblas_zgeru+0x62>
 801c554:	2800      	cmp	r0, #0
 801c556:	f43f af0b 	beq.w	801c370 <cblas_zgeru+0x2a0>
 801c55a:	e705      	b.n	801c368 <cblas_zgeru+0x298>
 801c55c:	9b05      	ldr	r3, [sp, #20]
 801c55e:	2b01      	cmp	r3, #1
 801c560:	bfb8      	it	lt
 801c562:	2301      	movlt	r3, #1
 801c564:	42b3      	cmp	r3, r6
 801c566:	f73f aec2 	bgt.w	801c2ee <cblas_zgeru+0x21e>
 801c56a:	2800      	cmp	r0, #0
 801c56c:	f43f aed1 	beq.w	801c312 <cblas_zgeru+0x242>
 801c570:	e5df      	b.n	801c132 <cblas_zgeru+0x62>
 801c572:	bf00      	nop
 801c574:	08031108 	.word	0x08031108
 801c578:	080312f0 	.word	0x080312f0
 801c57c:	00000000 	.word	0x00000000

0801c580 <cblas_zhemm>:
void
cblas_zhemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 801c580:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c584:	ed2d 8b10 	vpush	{d8-d15}
 801c588:	b0a1      	sub	sp, #132	; 0x84
 801c58a:	298d      	cmp	r1, #141	; 0x8d
 801c58c:	930d      	str	r3, [sp, #52]	; 0x34
 801c58e:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801c590:	930e      	str	r3, [sp, #56]	; 0x38
 801c592:	e9dd 733b 	ldrd	r7, r3, [sp, #236]	; 0xec
 801c596:	9313      	str	r3, [sp, #76]	; 0x4c
 801c598:	9b3d      	ldr	r3, [sp, #244]	; 0xf4
 801c59a:	9312      	str	r3, [sp, #72]	; 0x48
 801c59c:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 801c59e:	9315      	str	r3, [sp, #84]	; 0x54
 801c5a0:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
 801c5a2:	9318      	str	r3, [sp, #96]	; 0x60
 801c5a4:	e9dd 6340 	ldrd	r6, r3, [sp, #256]	; 0x100
 801c5a8:	9314      	str	r3, [sp, #80]	; 0x50
 801c5aa:	9b42      	ldr	r3, [sp, #264]	; 0x108
 801c5ac:	9317      	str	r3, [sp, #92]	; 0x5c
 801c5ae:	460d      	mov	r5, r1
 801c5b0:	4604      	mov	r4, r0
 801c5b2:	4690      	mov	r8, r2
 801c5b4:	f000 8134 	beq.w	801c820 <cblas_zhemm+0x2a0>
 801c5b8:	298e      	cmp	r1, #142	; 0x8e
 801c5ba:	f001 8056 	beq.w	801d66a <cblas_zhemm+0x10ea>
 801c5be:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c5c0:	2002      	movs	r0, #2
 801c5c2:	f1a8 0279 	sub.w	r2, r8, #121	; 0x79
 801c5c6:	2a01      	cmp	r2, #1
 801c5c8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801c5ca:	bf88      	it	hi
 801c5cc:	2003      	movhi	r0, #3
 801c5ce:	2a00      	cmp	r2, #0
 801c5d0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801c5d2:	bfb8      	it	lt
 801c5d4:	2004      	movlt	r0, #4
 801c5d6:	2b01      	cmp	r3, #1
 801c5d8:	bfb8      	it	lt
 801c5da:	2301      	movlt	r3, #1
 801c5dc:	2a00      	cmp	r2, #0
 801c5de:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801c5e0:	f2c0 8113 	blt.w	801c80a <cblas_zhemm+0x28a>
 801c5e4:	4293      	cmp	r3, r2
 801c5e6:	f340 808b 	ble.w	801c700 <cblas_zhemm+0x180>
 801c5ea:	2c65      	cmp	r4, #101	; 0x65
 801c5ec:	f000 847e 	beq.w	801ceec <cblas_zhemm+0x96c>
 801c5f0:	2c66      	cmp	r4, #102	; 0x66
 801c5f2:	f001 8029 	beq.w	801d648 <cblas_zhemm+0x10c8>
 801c5f6:	2008      	movs	r0, #8
 801c5f8:	4a91      	ldr	r2, [pc, #580]	; (801c840 <cblas_zhemm+0x2c0>)
 801c5fa:	4992      	ldr	r1, [pc, #584]	; (801c844 <cblas_zhemm+0x2c4>)
 801c5fc:	f00c f884 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801c600:	ed97 7b00 	vldr	d7, [r7]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801c604:	2200      	movs	r2, #0
 801c606:	ec51 0b17 	vmov	r0, r1, d7
 801c60a:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 801c60c:	ed8d 7b08 	vstr	d7, [sp, #32]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801c610:	f00c fd12 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c614:	ed97 7b02 	vldr	d7, [r7, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801c618:	e9d6 ab00 	ldrd	sl, fp, [r6]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801c61c:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    const BASE beta_imag = CONST_IMAG0(beta);
 801c620:	ed96 8b02 	vldr	d8, [r6, #8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801c624:	b170      	cbz	r0, 801c644 <cblas_zhemm+0xc4>
 801c626:	ec51 0b17 	vmov	r0, r1, d7
 801c62a:	2200      	movs	r2, #0
 801c62c:	2300      	movs	r3, #0
 801c62e:	f00c fd03 	bl	8029038 <__aeabi_dcmpeq>
 801c632:	b138      	cbz	r0, 801c644 <cblas_zhemm+0xc4>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801c634:	4b84      	ldr	r3, [pc, #528]	; (801c848 <cblas_zhemm+0x2c8>)
 801c636:	2200      	movs	r2, #0
 801c638:	4650      	mov	r0, sl
 801c63a:	4659      	mov	r1, fp
 801c63c:	f00c fcfc 	bl	8029038 <__aeabi_dcmpeq>
 801c640:	2800      	cmp	r0, #0
 801c642:	d167      	bne.n	801c714 <cblas_zhemm+0x194>
    if (Order == CblasRowMajor) {
 801c644:	2c65      	cmp	r4, #101	; 0x65
 801c646:	f000 80f2 	beq.w	801c82e <cblas_zhemm+0x2ae>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801c64a:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801c64e:	bf0c      	ite	eq
 801c650:	237a      	moveq	r3, #122	; 0x7a
 801c652:	2379      	movne	r3, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 801c654:	2d8d      	cmp	r5, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801c656:	931a      	str	r3, [sp, #104]	; 0x68
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 801c658:	bf0c      	ite	eq
 801c65a:	238e      	moveq	r3, #142	; 0x8e
 801c65c:	238d      	movne	r3, #141	; 0x8d
 801c65e:	9319      	str	r3, [sp, #100]	; 0x64
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801c660:	2200      	movs	r2, #0
 801c662:	2300      	movs	r3, #0
 801c664:	4650      	mov	r0, sl
 801c666:	4659      	mov	r1, fp
 801c668:	f00c fce6 	bl	8029038 <__aeabi_dcmpeq>
 801c66c:	2200      	movs	r2, #0
 801c66e:	2800      	cmp	r0, #0
 801c670:	d05d      	beq.n	801c72e <cblas_zhemm+0x1ae>
 801c672:	ec51 0b18 	vmov	r0, r1, d8
 801c676:	2300      	movs	r3, #0
 801c678:	f00c fcde 	bl	8029038 <__aeabi_dcmpeq>
 801c67c:	2800      	cmp	r0, #0
 801c67e:	d064      	beq.n	801c74a <cblas_zhemm+0x1ca>
      for (i = 0; i < n1; i++) {
 801c680:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c682:	2b00      	cmp	r3, #0
 801c684:	dd1c      	ble.n	801c6c0 <cblas_zhemm+0x140>
 801c686:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c688:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801c68a:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
 801c68e:	0114      	lsls	r4, r2, #4
 801c690:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801c692:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 801c696:	0100      	lsls	r0, r0, #4
 801c698:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 801c69c:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 801c69e:	2600      	movs	r6, #0
 801c6a0:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 801c6a2:	2d00      	cmp	r5, #0
 801c6a4:	bfc8      	it	gt
 801c6a6:	1883      	addgt	r3, r0, r2
 801c6a8:	dd06      	ble.n	801c6b8 <cblas_zhemm+0x138>
          REAL(C, ldc * i + j) = 0.0;
 801c6aa:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 801c6ae:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 801c6b2:	3310      	adds	r3, #16
 801c6b4:	429a      	cmp	r2, r3
 801c6b6:	d1f8      	bne.n	801c6aa <cblas_zhemm+0x12a>
      for (i = 0; i < n1; i++) {
 801c6b8:	3101      	adds	r1, #1
 801c6ba:	458c      	cmp	ip, r1
 801c6bc:	4422      	add	r2, r4
 801c6be:	d1f0      	bne.n	801c6a2 <cblas_zhemm+0x122>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801c6c0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801c6c4:	2200      	movs	r2, #0
 801c6c6:	2300      	movs	r3, #0
 801c6c8:	f00c fcb6 	bl	8029038 <__aeabi_dcmpeq>
 801c6cc:	b130      	cbz	r0, 801c6dc <cblas_zhemm+0x15c>
 801c6ce:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801c6d2:	2200      	movs	r2, #0
 801c6d4:	2300      	movs	r3, #0
 801c6d6:	f00c fcaf 	bl	8029038 <__aeabi_dcmpeq>
 801c6da:	bb18      	cbnz	r0, 801c724 <cblas_zhemm+0x1a4>
    if (side == CblasLeft && uplo == CblasUpper) {
 801c6dc:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801c6de:	2b8d      	cmp	r3, #141	; 0x8d
 801c6e0:	f000 80b6 	beq.w	801c850 <cblas_zhemm+0x2d0>
    } else if (side == CblasRight && uplo == CblasUpper) {
 801c6e4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801c6e6:	2b8e      	cmp	r3, #142	; 0x8e
 801c6e8:	f000 824a 	beq.w	801cb80 <cblas_zhemm+0x600>
      BLAS_ERROR("unrecognized operation");
 801c6ec:	4a57      	ldr	r2, [pc, #348]	; (801c84c <cblas_zhemm+0x2cc>)
 801c6ee:	4955      	ldr	r1, [pc, #340]	; (801c844 <cblas_zhemm+0x2c4>)
 801c6f0:	2000      	movs	r0, #0
#define BASE double
#include "source_hemm.h"
#undef BASE
}
 801c6f2:	b021      	add	sp, #132	; 0x84
 801c6f4:	ecbd 8b10 	vpop	{d8-d15}
 801c6f8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c6fc:	f00c b804 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801c700:	2c65      	cmp	r4, #101	; 0x65
 801c702:	f000 8402 	beq.w	801cf0a <cblas_zhemm+0x98a>
 801c706:	2c66      	cmp	r4, #102	; 0x66
 801c708:	f000 8746 	beq.w	801d598 <cblas_zhemm+0x1018>
 801c70c:	2800      	cmp	r0, #0
 801c70e:	f43f af77 	beq.w	801c600 <cblas_zhemm+0x80>
 801c712:	e771      	b.n	801c5f8 <cblas_zhemm+0x78>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801c714:	ec51 0b18 	vmov	r0, r1, d8
 801c718:	2200      	movs	r2, #0
 801c71a:	2300      	movs	r3, #0
 801c71c:	f00c fc8c 	bl	8029038 <__aeabi_dcmpeq>
 801c720:	2800      	cmp	r0, #0
 801c722:	d08f      	beq.n	801c644 <cblas_zhemm+0xc4>
 801c724:	b021      	add	sp, #132	; 0x84
 801c726:	ecbd 8b10 	vpop	{d8-d15}
 801c72a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801c72e:	4b46      	ldr	r3, [pc, #280]	; (801c848 <cblas_zhemm+0x2c8>)
 801c730:	4650      	mov	r0, sl
 801c732:	4659      	mov	r1, fp
 801c734:	f00c fc80 	bl	8029038 <__aeabi_dcmpeq>
 801c738:	b138      	cbz	r0, 801c74a <cblas_zhemm+0x1ca>
 801c73a:	ec51 0b18 	vmov	r0, r1, d8
 801c73e:	2200      	movs	r2, #0
 801c740:	2300      	movs	r3, #0
 801c742:	f00c fc79 	bl	8029038 <__aeabi_dcmpeq>
 801c746:	2800      	cmp	r0, #0
 801c748:	d1ba      	bne.n	801c6c0 <cblas_zhemm+0x140>
      for (i = 0; i < n1; i++) {
 801c74a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c74c:	2b00      	cmp	r3, #0
 801c74e:	ddb7      	ble.n	801c6c0 <cblas_zhemm+0x140>
 801c750:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801c752:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 801c756:	011b      	lsls	r3, r3, #4
 801c758:	9311      	str	r3, [sp, #68]	; 0x44
 801c75a:	3308      	adds	r3, #8
 801c75c:	9316      	str	r3, [sp, #88]	; 0x58
 801c75e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801c760:	011b      	lsls	r3, r3, #4
 801c762:	9310      	str	r3, [sp, #64]	; 0x40
 801c764:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801c766:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c76a:	930c      	str	r3, [sp, #48]	; 0x30
 801c76c:	2300      	movs	r3, #0
 801c76e:	930f      	str	r3, [sp, #60]	; 0x3c
        for (j = 0; j < n2; j++) {
 801c770:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c772:	2b00      	cmp	r3, #0
 801c774:	dd3e      	ble.n	801c7f4 <cblas_zhemm+0x274>
 801c776:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801c778:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801c77a:	4619      	mov	r1, r3
 801c77c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801c77e:	eb01 0803 	add.w	r8, r1, r3
 801c782:	eb02 0903 	add.w	r9, r2, r3
          const BASE Cij_real = REAL(C, ldc * i + j);
 801c786:	e959 4502 	ldrd	r4, r5, [r9, #-8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801c78a:	4650      	mov	r0, sl
 801c78c:	4622      	mov	r2, r4
 801c78e:	462b      	mov	r3, r5
 801c790:	4659      	mov	r1, fp
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 801c792:	e9d8 6702 	ldrd	r6, r7, [r8, #8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801c796:	f00c f9e7 	bl	8028b68 <__aeabi_dmul>
 801c79a:	4632      	mov	r2, r6
 801c79c:	ec41 0b19 	vmov	d9, r0, r1
 801c7a0:	463b      	mov	r3, r7
 801c7a2:	ec51 0b18 	vmov	r0, r1, d8
 801c7a6:	f00c f9df 	bl	8028b68 <__aeabi_dmul>
 801c7aa:	4602      	mov	r2, r0
 801c7ac:	460b      	mov	r3, r1
 801c7ae:	ec51 0b19 	vmov	r0, r1, d9
 801c7b2:	f00c f821 	bl	80287f8 <__aeabi_dsub>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801c7b6:	4632      	mov	r2, r6
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801c7b8:	e949 0102 	strd	r0, r1, [r9, #-8]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801c7bc:	463b      	mov	r3, r7
 801c7be:	4650      	mov	r0, sl
 801c7c0:	4659      	mov	r1, fp
 801c7c2:	f00c f9d1 	bl	8028b68 <__aeabi_dmul>
 801c7c6:	4622      	mov	r2, r4
 801c7c8:	462b      	mov	r3, r5
 801c7ca:	4604      	mov	r4, r0
 801c7cc:	460d      	mov	r5, r1
 801c7ce:	ec51 0b18 	vmov	r0, r1, d8
 801c7d2:	f00c f9c9 	bl	8028b68 <__aeabi_dmul>
 801c7d6:	460b      	mov	r3, r1
 801c7d8:	4602      	mov	r2, r0
 801c7da:	4629      	mov	r1, r5
 801c7dc:	4620      	mov	r0, r4
 801c7de:	f00c f80d 	bl	80287fc <__adddf3>
        for (j = 0; j < n2; j++) {
 801c7e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801c7e4:	e9c8 0102 	strd	r0, r1, [r8, #8]
        for (j = 0; j < n2; j++) {
 801c7e8:	f108 0810 	add.w	r8, r8, #16
 801c7ec:	4598      	cmp	r8, r3
 801c7ee:	f109 0910 	add.w	r9, r9, #16
 801c7f2:	d1c8      	bne.n	801c786 <cblas_zhemm+0x206>
      for (i = 0; i < n1; i++) {
 801c7f4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801c7f6:	9910      	ldr	r1, [sp, #64]	; 0x40
 801c7f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801c7fa:	440a      	add	r2, r1
 801c7fc:	920c      	str	r2, [sp, #48]	; 0x30
 801c7fe:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801c800:	3301      	adds	r3, #1
 801c802:	429a      	cmp	r2, r3
 801c804:	930f      	str	r3, [sp, #60]	; 0x3c
 801c806:	d1b3      	bne.n	801c770 <cblas_zhemm+0x1f0>
 801c808:	e75a      	b.n	801c6c0 <cblas_zhemm+0x140>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801c80a:	429a      	cmp	r2, r3
 801c80c:	f6ff aeed 	blt.w	801c5ea <cblas_zhemm+0x6a>
 801c810:	2c65      	cmp	r4, #101	; 0x65
 801c812:	f000 86b6 	beq.w	801d582 <cblas_zhemm+0x1002>
 801c816:	2c66      	cmp	r4, #102	; 0x66
 801c818:	f000 8736 	beq.w	801d688 <cblas_zhemm+0x1108>
 801c81c:	2005      	movs	r0, #5
 801c81e:	e6eb      	b.n	801c5f8 <cblas_zhemm+0x78>
 801c820:	3865      	subs	r0, #101	; 0x65
 801c822:	2801      	cmp	r0, #1
 801c824:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c826:	bf94      	ite	ls
 801c828:	2000      	movls	r0, #0
 801c82a:	2001      	movhi	r0, #1
 801c82c:	e6c9      	b.n	801c5c2 <cblas_zhemm+0x42>
      uplo = Uplo;
 801c82e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c830:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801c832:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
      side = Side;
 801c836:	920e      	str	r2, [sp, #56]	; 0x38
 801c838:	9519      	str	r5, [sp, #100]	; 0x64
 801c83a:	930d      	str	r3, [sp, #52]	; 0x34
 801c83c:	e710      	b.n	801c660 <cblas_zhemm+0xe0>
 801c83e:	bf00      	nop
 801c840:	08031108 	.word	0x08031108
 801c844:	08031300 	.word	0x08031300
 801c848:	3ff00000 	.word	0x3ff00000
 801c84c:	080311b8 	.word	0x080311b8
    if (side == CblasLeft && uplo == CblasUpper) {
 801c850:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801c852:	2b79      	cmp	r3, #121	; 0x79
 801c854:	f000 8368 	beq.w	801cf28 <cblas_zhemm+0x9a8>
    } else if (side == CblasLeft && uplo == CblasLower) {
 801c858:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801c85a:	2b7a      	cmp	r3, #122	; 0x7a
 801c85c:	f47f af46 	bne.w	801c6ec <cblas_zhemm+0x16c>
      for (i = 0; i < n1; i++) {
 801c860:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c862:	2b00      	cmp	r3, #0
 801c864:	f77f af5e 	ble.w	801c724 <cblas_zhemm+0x1a4>
 801c868:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801c86a:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801c86c:	9100      	str	r1, [sp, #0]
 801c86e:	3301      	adds	r3, #1
 801c870:	011a      	lsls	r2, r3, #4
 801c872:	921b      	str	r2, [sp, #108]	; 0x6c
 801c874:	2300      	movs	r3, #0
 801c876:	3a10      	subs	r2, #16
 801c878:	e9cd 3219 	strd	r3, r2, [sp, #100]	; 0x64
 801c87c:	9316      	str	r3, [sp, #88]	; 0x58
 801c87e:	9312      	str	r3, [sp, #72]	; 0x48
 801c880:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801c882:	011b      	lsls	r3, r3, #4
 801c884:	9306      	str	r3, [sp, #24]
 801c886:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801c888:	011b      	lsls	r3, r3, #4
 801c88a:	9302      	str	r3, [sp, #8]
 801c88c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801c88e:	3308      	adds	r3, #8
 801c890:	931c      	str	r3, [sp, #112]	; 0x70
 801c892:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801c894:	3308      	adds	r3, #8
 801c896:	931d      	str	r3, [sp, #116]	; 0x74
        for (j = 0; j < n2; j++) {
 801c898:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c89a:	2b00      	cmp	r3, #0
 801c89c:	f340 8153 	ble.w	801cb46 <cblas_zhemm+0x5c6>
 801c8a0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801c8a2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801c8a4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c8a8:	930f      	str	r3, [sp, #60]	; 0x3c
 801c8aa:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801c8ac:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801c8ae:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c8b2:	930c      	str	r3, [sp, #48]	; 0x30
 801c8b4:	2208      	movs	r2, #8
 801c8b6:	2300      	movs	r3, #0
 801c8b8:	e9cd 3210 	strd	r3, r2, [sp, #64]	; 0x40
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c8bc:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c8be:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c8c2:	e954 6702 	ldrd	r6, r7, [r4, #-8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c8c6:	ec51 0b18 	vmov	r0, r1, d8
 801c8ca:	4632      	mov	r2, r6
 801c8cc:	463b      	mov	r3, r7
 801c8ce:	f00c f94b 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801c8d2:	e9d4 8900 	ldrd	r8, r9, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c8d6:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801c8da:	4604      	mov	r4, r0
 801c8dc:	460d      	mov	r5, r1
 801c8de:	4642      	mov	r2, r8
 801c8e0:	464b      	mov	r3, r9
 801c8e2:	4650      	mov	r0, sl
 801c8e4:	4659      	mov	r1, fp
 801c8e6:	f00c f93f 	bl	8028b68 <__aeabi_dmul>
 801c8ea:	4602      	mov	r2, r0
 801c8ec:	460b      	mov	r3, r1
 801c8ee:	4620      	mov	r0, r4
 801c8f0:	4629      	mov	r1, r5
 801c8f2:	f00b ff81 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c8f6:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c8f8:	4604      	mov	r4, r0
 801c8fa:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c8fc:	464b      	mov	r3, r9
 801c8fe:	ec51 0b18 	vmov	r0, r1, d8
 801c902:	f00c f931 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c906:	ec45 4b1e 	vmov	d14, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c90a:	4632      	mov	r2, r6
 801c90c:	463b      	mov	r3, r7
 801c90e:	4604      	mov	r4, r0
 801c910:	460d      	mov	r5, r1
 801c912:	4650      	mov	r0, sl
 801c914:	4659      	mov	r1, fp
 801c916:	f00c f927 	bl	8028b68 <__aeabi_dmul>
 801c91a:	460b      	mov	r3, r1
 801c91c:	4602      	mov	r2, r0
 801c91e:	4629      	mov	r1, r5
 801c920:	4620      	mov	r0, r4
 801c922:	f00b ff6b 	bl	80287fc <__adddf3>
          BASE temp2_imag = 0.0;
 801c926:	ed9f 7b94 	vldr	d7, [pc, #592]	; 801cb78 <cblas_zhemm+0x5f8>
          for (k = 0; k < i; k++) {
 801c92a:	9b12      	ldr	r3, [sp, #72]	; 0x48
          BASE temp2_imag = 0.0;
 801c92c:	eeb0 da47 	vmov.f32	s26, s14
 801c930:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c934:	ec41 0b1f 	vmov	d15, r0, r1
          BASE temp2_real = 0.0;
 801c938:	eeb0 ca47 	vmov.f32	s24, s14
 801c93c:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < i; k++) {
 801c940:	2b00      	cmp	r3, #0
 801c942:	f000 809a 	beq.w	801ca7a <cblas_zhemm+0x4fa>
 801c946:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801c948:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801c94a:	9910      	ldr	r1, [sp, #64]	; 0x40
 801c94c:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
 801c950:	4610      	mov	r0, r2
 801c952:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801c954:	eb03 1a01 	add.w	sl, r3, r1, lsl #4
 801c958:	eb00 0902 	add.w	r9, r0, r2
 801c95c:	eb03 0802 	add.w	r8, r3, r2
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801c960:	e9db 4500 	ldrd	r4, r5, [fp]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c964:	ec51 0b1e 	vmov	r0, r1, d14
 801c968:	4622      	mov	r2, r4
 801c96a:	462b      	mov	r3, r5
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801c96c:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c970:	f00c f8fa 	bl	8028b68 <__aeabi_dmul>
 801c974:	4632      	mov	r2, r6
 801c976:	ec41 0b18 	vmov	d8, r0, r1
 801c97a:	463b      	mov	r3, r7
 801c97c:	ec51 0b1f 	vmov	r0, r1, d15
 801c980:	f00c f8f2 	bl	8028b68 <__aeabi_dmul>
 801c984:	4602      	mov	r2, r0
 801c986:	460b      	mov	r3, r1
 801c988:	ec51 0b18 	vmov	r0, r1, d8
 801c98c:	f00b ff36 	bl	80287fc <__adddf3>
 801c990:	4602      	mov	r2, r0
 801c992:	460b      	mov	r3, r1
 801c994:	e958 0102 	ldrd	r0, r1, [r8, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c998:	9604      	str	r6, [sp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c99a:	f00b ff2f 	bl	80287fc <__adddf3>
 801c99e:	460b      	mov	r3, r1
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c9a0:	f107 4100 	add.w	r1, r7, #2147483648	; 0x80000000
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c9a4:	4602      	mov	r2, r0
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c9a6:	9105      	str	r1, [sp, #20]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 801c9a8:	ed19 8b02 	vldr	d8, [r9, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 801c9ac:	ed99 9b00 	vldr	d9, [r9]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c9b0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c9b4:	e948 2302 	strd	r2, r3, [r8, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c9b8:	ec53 2b1e 	vmov	r2, r3, d14
 801c9bc:	f00c f8d4 	bl	8028b68 <__aeabi_dmul>
 801c9c0:	4622      	mov	r2, r4
 801c9c2:	462b      	mov	r3, r5
 801c9c4:	ec41 0b1b 	vmov	d11, r0, r1
 801c9c8:	ec51 0b1f 	vmov	r0, r1, d15
 801c9cc:	f00c f8cc 	bl	8028b68 <__aeabi_dmul>
 801c9d0:	4602      	mov	r2, r0
 801c9d2:	460b      	mov	r3, r1
 801c9d4:	ec51 0b1b 	vmov	r0, r1, d11
 801c9d8:	f00b ff10 	bl	80287fc <__adddf3>
 801c9dc:	4602      	mov	r2, r0
 801c9de:	460b      	mov	r3, r1
 801c9e0:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801c9e4:	f00b ff0a 	bl	80287fc <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801c9e8:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c9ec:	e9ca 0102 	strd	r0, r1, [sl, #8]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801c9f0:	4620      	mov	r0, r4
 801c9f2:	4629      	mov	r1, r5
 801c9f4:	f00c f8b8 	bl	8028b68 <__aeabi_dmul>
 801c9f8:	ec53 2b19 	vmov	r2, r3, d9
 801c9fc:	ec41 0b1a 	vmov	d10, r0, r1
 801ca00:	4630      	mov	r0, r6
 801ca02:	4639      	mov	r1, r7
 801ca04:	f00c f8b0 	bl	8028b68 <__aeabi_dmul>
 801ca08:	4602      	mov	r2, r0
 801ca0a:	460b      	mov	r3, r1
 801ca0c:	ec51 0b1a 	vmov	r0, r1, d10
 801ca10:	f00b fef2 	bl	80287f8 <__aeabi_dsub>
 801ca14:	4602      	mov	r2, r0
 801ca16:	460b      	mov	r3, r1
 801ca18:	ec51 0b1c 	vmov	r0, r1, d12
 801ca1c:	f00b feee 	bl	80287fc <__adddf3>
 801ca20:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801ca24:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801ca28:	eeb0 ca47 	vmov.f32	s24, s14
 801ca2c:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801ca30:	4620      	mov	r0, r4
 801ca32:	4629      	mov	r1, r5
 801ca34:	f00c f898 	bl	8028b68 <__aeabi_dmul>
 801ca38:	ec53 2b18 	vmov	r2, r3, d8
 801ca3c:	4604      	mov	r4, r0
 801ca3e:	460d      	mov	r5, r1
 801ca40:	4630      	mov	r0, r6
 801ca42:	4639      	mov	r1, r7
 801ca44:	f00c f890 	bl	8028b68 <__aeabi_dmul>
 801ca48:	4602      	mov	r2, r0
 801ca4a:	460b      	mov	r3, r1
 801ca4c:	4620      	mov	r0, r4
 801ca4e:	4629      	mov	r1, r5
 801ca50:	f00b fed4 	bl	80287fc <__adddf3>
 801ca54:	460b      	mov	r3, r1
 801ca56:	4602      	mov	r2, r0
 801ca58:	ec51 0b1d 	vmov	r0, r1, d13
 801ca5c:	f00b fece 	bl	80287fc <__adddf3>
 801ca60:	9b02      	ldr	r3, [sp, #8]
 801ca62:	4499      	add	r9, r3
 801ca64:	9b06      	ldr	r3, [sp, #24]
 801ca66:	4498      	add	r8, r3
 801ca68:	449a      	add	sl, r3
          for (k = 0; k < i; k++) {
 801ca6a:	9b00      	ldr	r3, [sp, #0]
 801ca6c:	f10b 0b10 	add.w	fp, fp, #16
 801ca70:	455b      	cmp	r3, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801ca72:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < i; k++) {
 801ca76:	f47f af73 	bne.w	801c960 <cblas_zhemm+0x3e0>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 801ca7a:	9b00      	ldr	r3, [sp, #0]
 801ca7c:	e9d3 4500 	ldrd	r4, r5, [r3]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801ca80:	ec51 0b1f 	vmov	r0, r1, d15
 801ca84:	4622      	mov	r2, r4
 801ca86:	462b      	mov	r3, r5
 801ca88:	f00c f86e 	bl	8028b68 <__aeabi_dmul>
 801ca8c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801ca8e:	e9d6 2300 	ldrd	r2, r3, [r6]
 801ca92:	f00b feb3 	bl	80287fc <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801ca96:	4622      	mov	r2, r4
 801ca98:	462b      	mov	r3, r5
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801ca9a:	4680      	mov	r8, r0
 801ca9c:	4689      	mov	r9, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801ca9e:	ec51 0b1e 	vmov	r0, r1, d14
 801caa2:	f00c f861 	bl	8028b68 <__aeabi_dmul>
 801caa6:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 801caaa:	960c      	str	r6, [sp, #48]	; 0x30
 801caac:	f00b fea6 	bl	80287fc <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cab0:	ed9d 9b08 	vldr	d9, [sp, #32]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801cab4:	4604      	mov	r4, r0
 801cab6:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cab8:	ec53 2b1c 	vmov	r2, r3, d12
 801cabc:	ec51 0b19 	vmov	r0, r1, d9
 801cac0:	f00c f852 	bl	8028b68 <__aeabi_dmul>
 801cac4:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801cac8:	ec53 2b1d 	vmov	r2, r3, d13
 801cacc:	4606      	mov	r6, r0
 801cace:	460f      	mov	r7, r1
 801cad0:	4650      	mov	r0, sl
 801cad2:	4659      	mov	r1, fp
 801cad4:	f00c f848 	bl	8028b68 <__aeabi_dmul>
 801cad8:	4602      	mov	r2, r0
 801cada:	460b      	mov	r3, r1
 801cadc:	4630      	mov	r0, r6
 801cade:	4639      	mov	r1, r7
 801cae0:	f00b fe8a 	bl	80287f8 <__aeabi_dsub>
 801cae4:	4602      	mov	r2, r0
 801cae6:	460b      	mov	r3, r1
 801cae8:	4620      	mov	r0, r4
 801caea:	4629      	mov	r1, r5
 801caec:	f00b fe86 	bl	80287fc <__adddf3>
 801caf0:	9e0c      	ldr	r6, [sp, #48]	; 0x30
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801caf2:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801caf6:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801cafa:	ec51 0b19 	vmov	r0, r1, d9
 801cafe:	f00c f833 	bl	8028b68 <__aeabi_dmul>
 801cb02:	ec53 2b1c 	vmov	r2, r3, d12
 801cb06:	4604      	mov	r4, r0
 801cb08:	460d      	mov	r5, r1
 801cb0a:	4650      	mov	r0, sl
 801cb0c:	4659      	mov	r1, fp
 801cb0e:	f00c f82b 	bl	8028b68 <__aeabi_dmul>
 801cb12:	4602      	mov	r2, r0
 801cb14:	460b      	mov	r3, r1
 801cb16:	4620      	mov	r0, r4
 801cb18:	4629      	mov	r1, r5
 801cb1a:	f00b fe6f 	bl	80287fc <__adddf3>
 801cb1e:	4642      	mov	r2, r8
 801cb20:	464b      	mov	r3, r9
 801cb22:	f00b fe6b 	bl	80287fc <__adddf3>
 801cb26:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
        for (j = 0; j < n2; j++) {
 801cb28:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801cb2a:	3210      	adds	r2, #16
 801cb2c:	920f      	str	r2, [sp, #60]	; 0x3c
 801cb2e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801cb30:	3210      	adds	r2, #16
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801cb32:	e8e6 0104 	strd	r0, r1, [r6], #16
 801cb36:	9211      	str	r2, [sp, #68]	; 0x44
        for (j = 0; j < n2; j++) {
 801cb38:	9a0d      	ldr	r2, [sp, #52]	; 0x34
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801cb3a:	960c      	str	r6, [sp, #48]	; 0x30
        for (j = 0; j < n2; j++) {
 801cb3c:	3301      	adds	r3, #1
 801cb3e:	429a      	cmp	r2, r3
 801cb40:	9310      	str	r3, [sp, #64]	; 0x40
 801cb42:	f47f aebb 	bne.w	801c8bc <cblas_zhemm+0x33c>
      for (i = 0; i < n1; i++) {
 801cb46:	9a00      	ldr	r2, [sp, #0]
 801cb48:	991b      	ldr	r1, [sp, #108]	; 0x6c
 801cb4a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801cb4c:	440a      	add	r2, r1
 801cb4e:	9200      	str	r2, [sp, #0]
 801cb50:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801cb52:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801cb54:	440a      	add	r2, r1
 801cb56:	9219      	str	r2, [sp, #100]	; 0x64
 801cb58:	9918      	ldr	r1, [sp, #96]	; 0x60
 801cb5a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801cb5c:	440a      	add	r2, r1
 801cb5e:	9216      	str	r2, [sp, #88]	; 0x58
 801cb60:	991a      	ldr	r1, [sp, #104]	; 0x68
 801cb62:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801cb64:	440a      	add	r2, r1
 801cb66:	9213      	str	r2, [sp, #76]	; 0x4c
 801cb68:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801cb6a:	3301      	adds	r3, #1
 801cb6c:	429a      	cmp	r2, r3
 801cb6e:	9312      	str	r3, [sp, #72]	; 0x48
 801cb70:	f47f ae92 	bne.w	801c898 <cblas_zhemm+0x318>
 801cb74:	e5d6      	b.n	801c724 <cblas_zhemm+0x1a4>
 801cb76:	bf00      	nop
	...
    } else if (side == CblasRight && uplo == CblasUpper) {
 801cb80:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801cb82:	2b79      	cmp	r3, #121	; 0x79
 801cb84:	f000 8380 	beq.w	801d288 <cblas_zhemm+0xd08>
    } else if (side == CblasRight && uplo == CblasLower) {
 801cb88:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801cb8a:	2b7a      	cmp	r3, #122	; 0x7a
 801cb8c:	f47f adae 	bne.w	801c6ec <cblas_zhemm+0x16c>
      for (i = 0; i < n1; i++) {
 801cb90:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801cb92:	2b00      	cmp	r3, #0
 801cb94:	f77f adc6 	ble.w	801c724 <cblas_zhemm+0x1a4>
 801cb98:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801cb9a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801cb9c:	0112      	lsls	r2, r2, #4
 801cb9e:	9219      	str	r2, [sp, #100]	; 0x64
 801cba0:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801cba2:	0112      	lsls	r2, r2, #4
 801cba4:	3301      	adds	r3, #1
 801cba6:	9217      	str	r2, [sp, #92]	; 0x5c
 801cba8:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801cbaa:	9211      	str	r2, [sp, #68]	; 0x44
 801cbac:	011a      	lsls	r2, r3, #4
 801cbae:	9215      	str	r2, [sp, #84]	; 0x54
 801cbb0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801cbb2:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801cbb6:	9318      	str	r3, [sp, #96]	; 0x60
 801cbb8:	2300      	movs	r3, #0
 801cbba:	9316      	str	r3, [sp, #88]	; 0x58
        for (j = 0; j < n2; j++) {
 801cbbc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801cbbe:	2b00      	cmp	r3, #0
 801cbc0:	f340 84ec 	ble.w	801d59c <cblas_zhemm+0x101c>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801cbc4:	9c11      	ldr	r4, [sp, #68]	; 0x44
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cbc6:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801cbca:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cbce:	ec53 2b18 	vmov	r2, r3, d8
 801cbd2:	4630      	mov	r0, r6
 801cbd4:	4639      	mov	r1, r7
 801cbd6:	f00b ffc7 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801cbda:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cbde:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801cbe2:	4604      	mov	r4, r0
 801cbe4:	460d      	mov	r5, r1
 801cbe6:	4652      	mov	r2, sl
 801cbe8:	465b      	mov	r3, fp
 801cbea:	4640      	mov	r0, r8
 801cbec:	4649      	mov	r1, r9
 801cbee:	f00b ffbb 	bl	8028b68 <__aeabi_dmul>
 801cbf2:	4602      	mov	r2, r0
 801cbf4:	460b      	mov	r3, r1
 801cbf6:	4620      	mov	r0, r4
 801cbf8:	4629      	mov	r1, r5
 801cbfa:	f00b fdfd 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cbfe:	4652      	mov	r2, sl
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cc00:	4604      	mov	r4, r0
 801cc02:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cc04:	465b      	mov	r3, fp
 801cc06:	4630      	mov	r0, r6
 801cc08:	4639      	mov	r1, r7
 801cc0a:	f00b ffad 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cc0e:	ec45 4b1e 	vmov	d14, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cc12:	ec53 2b18 	vmov	r2, r3, d8
 801cc16:	4604      	mov	r4, r0
 801cc18:	460d      	mov	r5, r1
 801cc1a:	4640      	mov	r0, r8
 801cc1c:	4649      	mov	r1, r9
 801cc1e:	f00b ffa3 	bl	8028b68 <__aeabi_dmul>
 801cc22:	460b      	mov	r3, r1
 801cc24:	4602      	mov	r2, r0
 801cc26:	4629      	mov	r1, r5
 801cc28:	4620      	mov	r0, r4
 801cc2a:	f00b fde7 	bl	80287fc <__adddf3>
 801cc2e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801cc30:	9302      	str	r3, [sp, #8]
 801cc32:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801cc34:	930c      	str	r3, [sp, #48]	; 0x30
 801cc36:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801cc38:	9304      	str	r3, [sp, #16]
          BASE temp2_imag = 0.0;
 801cc3a:	ed1f 7b31 	vldr	d7, [pc, #-196]	; 801cb78 <cblas_zhemm+0x5f8>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cc3e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801cc40:	9c11      	ldr	r4, [sp, #68]	; 0x44
 801cc42:	9306      	str	r3, [sp, #24]
 801cc44:	ec41 0b1f 	vmov	d15, r0, r1
          BASE temp2_imag = 0.0;
 801cc48:	eeb0 da47 	vmov.f32	s26, s14
 801cc4c:	eef0 da67 	vmov.f32	s27, s15
        for (j = 0; j < n2; j++) {
 801cc50:	2300      	movs	r3, #0
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cc52:	940f      	str	r4, [sp, #60]	; 0x3c
        for (j = 0; j < n2; j++) {
 801cc54:	9310      	str	r3, [sp, #64]	; 0x40
          BASE temp2_real = 0.0;
 801cc56:	eeb0 ca47 	vmov.f32	s24, s14
 801cc5a:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801cc5e:	9b06      	ldr	r3, [sp, #24]
 801cc60:	e9d3 4500 	ldrd	r4, r5, [r3]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801cc64:	ec53 2b1f 	vmov	r2, r3, d15
 801cc68:	4620      	mov	r0, r4
 801cc6a:	4629      	mov	r1, r5
 801cc6c:	f00b ff7c 	bl	8028b68 <__aeabi_dmul>
 801cc70:	9e04      	ldr	r6, [sp, #16]
 801cc72:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 801cc76:	f00b fdc1 	bl	80287fc <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801cc7a:	ec53 2b1e 	vmov	r2, r3, d14
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801cc7e:	4680      	mov	r8, r0
 801cc80:	4689      	mov	r9, r1
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801cc82:	4620      	mov	r0, r4
 801cc84:	4629      	mov	r1, r5
 801cc86:	f00b ff6f 	bl	8028b68 <__aeabi_dmul>
 801cc8a:	e9d6 2300 	ldrd	r2, r3, [r6]
 801cc8e:	9604      	str	r6, [sp, #16]
 801cc90:	f00b fdb4 	bl	80287fc <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cc94:	ed9d 9b08 	vldr	d9, [sp, #32]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801cc98:	4604      	mov	r4, r0
 801cc9a:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cc9c:	ec53 2b1c 	vmov	r2, r3, d12
 801cca0:	ec51 0b19 	vmov	r0, r1, d9
 801cca4:	f00b ff60 	bl	8028b68 <__aeabi_dmul>
 801cca8:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801ccac:	ec53 2b1d 	vmov	r2, r3, d13
 801ccb0:	4606      	mov	r6, r0
 801ccb2:	460f      	mov	r7, r1
 801ccb4:	4650      	mov	r0, sl
 801ccb6:	4659      	mov	r1, fp
 801ccb8:	f00b ff56 	bl	8028b68 <__aeabi_dmul>
 801ccbc:	4602      	mov	r2, r0
 801ccbe:	460b      	mov	r3, r1
 801ccc0:	4630      	mov	r0, r6
 801ccc2:	4639      	mov	r1, r7
 801ccc4:	f00b fd98 	bl	80287f8 <__aeabi_dsub>
 801ccc8:	4602      	mov	r2, r0
 801ccca:	460b      	mov	r3, r1
 801cccc:	4620      	mov	r0, r4
 801ccce:	4629      	mov	r1, r5
 801ccd0:	f00b fd94 	bl	80287fc <__adddf3>
 801ccd4:	9e04      	ldr	r6, [sp, #16]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801ccd6:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801ccda:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801ccde:	ec51 0b19 	vmov	r0, r1, d9
 801cce2:	f00b ff41 	bl	8028b68 <__aeabi_dmul>
 801cce6:	ec53 2b1c 	vmov	r2, r3, d12
 801ccea:	4604      	mov	r4, r0
 801ccec:	460d      	mov	r5, r1
 801ccee:	4650      	mov	r0, sl
 801ccf0:	4659      	mov	r1, fp
 801ccf2:	f00b ff39 	bl	8028b68 <__aeabi_dmul>
 801ccf6:	4602      	mov	r2, r0
 801ccf8:	460b      	mov	r3, r1
 801ccfa:	4620      	mov	r0, r4
 801ccfc:	4629      	mov	r1, r5
 801ccfe:	f00b fd7d 	bl	80287fc <__adddf3>
 801cd02:	4642      	mov	r2, r8
 801cd04:	464b      	mov	r3, r9
 801cd06:	f00b fd79 	bl	80287fc <__adddf3>
        for (j = 0; j < n2; j++) {
 801cd0a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801cd0c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801cd0e:	3301      	adds	r3, #1
 801cd10:	429a      	cmp	r2, r3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801cd12:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801cd16:	9310      	str	r3, [sp, #64]	; 0x40
 801cd18:	f000 8440 	beq.w	801d59c <cblas_zhemm+0x101c>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801cd1c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cd1e:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801cd22:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cd26:	ec51 0b18 	vmov	r0, r1, d8
 801cd2a:	4632      	mov	r2, r6
 801cd2c:	463b      	mov	r3, r7
 801cd2e:	f00b ff1b 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801cd32:	e9d4 8906 	ldrd	r8, r9, [r4, #24]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cd36:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801cd3a:	4604      	mov	r4, r0
 801cd3c:	460d      	mov	r5, r1
 801cd3e:	4642      	mov	r2, r8
 801cd40:	464b      	mov	r3, r9
 801cd42:	4650      	mov	r0, sl
 801cd44:	4659      	mov	r1, fp
 801cd46:	f00b ff0f 	bl	8028b68 <__aeabi_dmul>
 801cd4a:	4602      	mov	r2, r0
 801cd4c:	460b      	mov	r3, r1
 801cd4e:	4620      	mov	r0, r4
 801cd50:	4629      	mov	r1, r5
 801cd52:	f00b fd51 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cd56:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cd58:	4604      	mov	r4, r0
 801cd5a:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cd5c:	464b      	mov	r3, r9
 801cd5e:	ec51 0b18 	vmov	r0, r1, d8
 801cd62:	f00b ff01 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cd66:	ec45 4b1e 	vmov	d14, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cd6a:	4632      	mov	r2, r6
 801cd6c:	4604      	mov	r4, r0
 801cd6e:	460d      	mov	r5, r1
 801cd70:	463b      	mov	r3, r7
 801cd72:	4650      	mov	r0, sl
 801cd74:	4659      	mov	r1, fp
 801cd76:	f00b fef7 	bl	8028b68 <__aeabi_dmul>
 801cd7a:	4602      	mov	r2, r0
 801cd7c:	460b      	mov	r3, r1
 801cd7e:	4620      	mov	r0, r4
 801cd80:	4629      	mov	r1, r5
 801cd82:	f00b fd3b 	bl	80287fc <__adddf3>
          BASE temp2_imag = 0.0;
 801cd86:	ed1f 7b84 	vldr	d7, [pc, #-528]	; 801cb78 <cblas_zhemm+0x5f8>
 801cd8a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801cd8c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801cd8e:	9c14      	ldr	r4, [sp, #80]	; 0x50
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cd90:	9d11      	ldr	r5, [sp, #68]	; 0x44
          BASE temp2_imag = 0.0;
 801cd92:	eeb0 da47 	vmov.f32	s26, s14
 801cd96:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cd9a:	ec41 0b1f 	vmov	d15, r0, r1
          BASE temp2_real = 0.0;
 801cd9e:	eeb0 ca47 	vmov.f32	s24, s14
 801cda2:	eef0 ca67 	vmov.f32	s25, s15
 801cda6:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 801cdaa:	f104 0b08 	add.w	fp, r4, #8
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801cdae:	e9da 8900 	ldrd	r8, r9, [sl]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801cdb2:	ec51 0b1e 	vmov	r0, r1, d14
 801cdb6:	4642      	mov	r2, r8
 801cdb8:	464b      	mov	r3, r9
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801cdba:	e9da 6702 	ldrd	r6, r7, [sl, #8]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801cdbe:	f00b fed3 	bl	8028b68 <__aeabi_dmul>
 801cdc2:	4632      	mov	r2, r6
 801cdc4:	ec41 0b18 	vmov	d8, r0, r1
 801cdc8:	463b      	mov	r3, r7
 801cdca:	ec51 0b1f 	vmov	r0, r1, d15
 801cdce:	f00b fecb 	bl	8028b68 <__aeabi_dmul>
 801cdd2:	4602      	mov	r2, r0
 801cdd4:	460b      	mov	r3, r1
 801cdd6:	ec51 0b18 	vmov	r0, r1, d8
 801cdda:	f00b fd0d 	bl	80287f8 <__aeabi_dsub>
 801cdde:	4602      	mov	r2, r0
 801cde0:	460b      	mov	r3, r1
 801cde2:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801cde6:	f00b fd09 	bl	80287fc <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 801cdea:	ed95 8b00 	vldr	d8, [r5]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 801cdee:	ed95 9b02 	vldr	d9, [r5, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801cdf2:	4632      	mov	r2, r6
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801cdf4:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801cdf8:	463b      	mov	r3, r7
 801cdfa:	ec51 0b1e 	vmov	r0, r1, d14
 801cdfe:	f00b feb3 	bl	8028b68 <__aeabi_dmul>
 801ce02:	4642      	mov	r2, r8
 801ce04:	ec41 0b1b 	vmov	d11, r0, r1
 801ce08:	464b      	mov	r3, r9
 801ce0a:	ec51 0b1f 	vmov	r0, r1, d15
 801ce0e:	f00b feab 	bl	8028b68 <__aeabi_dmul>
 801ce12:	4602      	mov	r2, r0
 801ce14:	460b      	mov	r3, r1
 801ce16:	ec51 0b1b 	vmov	r0, r1, d11
 801ce1a:	f00b fcef 	bl	80287fc <__adddf3>
 801ce1e:	4602      	mov	r2, r0
 801ce20:	460b      	mov	r3, r1
 801ce22:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801ce26:	f00b fce9 	bl	80287fc <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801ce2a:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801ce2e:	e9c4 0102 	strd	r0, r1, [r4, #8]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801ce32:	4640      	mov	r0, r8
 801ce34:	4649      	mov	r1, r9
 801ce36:	f00b fe97 	bl	8028b68 <__aeabi_dmul>
 801ce3a:	ec53 2b19 	vmov	r2, r3, d9
 801ce3e:	ec41 0b1a 	vmov	d10, r0, r1
 801ce42:	4630      	mov	r0, r6
 801ce44:	4639      	mov	r1, r7
 801ce46:	f00b fe8f 	bl	8028b68 <__aeabi_dmul>
 801ce4a:	4602      	mov	r2, r0
 801ce4c:	460b      	mov	r3, r1
 801ce4e:	ec51 0b1a 	vmov	r0, r1, d10
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801ce52:	9600      	str	r6, [sp, #0]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801ce54:	f00b fcd2 	bl	80287fc <__adddf3>
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801ce58:	f107 4600 	add.w	r6, r7, #2147483648	; 0x80000000
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801ce5c:	4602      	mov	r2, r0
 801ce5e:	460b      	mov	r3, r1
 801ce60:	ec51 0b1c 	vmov	r0, r1, d12
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801ce64:	9601      	str	r6, [sp, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801ce66:	f00b fcc9 	bl	80287fc <__adddf3>
 801ce6a:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801ce6e:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801ce72:	eeb0 ca47 	vmov.f32	s24, s14
 801ce76:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801ce7a:	e9dd 0100 	ldrd	r0, r1, [sp]
 801ce7e:	f00b fe73 	bl	8028b68 <__aeabi_dmul>
 801ce82:	ec53 2b19 	vmov	r2, r3, d9
 801ce86:	4606      	mov	r6, r0
 801ce88:	460f      	mov	r7, r1
 801ce8a:	4640      	mov	r0, r8
 801ce8c:	4649      	mov	r1, r9
 801ce8e:	f00b fe6b 	bl	8028b68 <__aeabi_dmul>
 801ce92:	4602      	mov	r2, r0
 801ce94:	460b      	mov	r3, r1
 801ce96:	4630      	mov	r0, r6
 801ce98:	4639      	mov	r1, r7
 801ce9a:	f00b fcaf 	bl	80287fc <__adddf3>
 801ce9e:	460b      	mov	r3, r1
 801cea0:	4602      	mov	r2, r0
 801cea2:	ec51 0b1d 	vmov	r0, r1, d13
 801cea6:	f00b fca9 	bl	80287fc <__adddf3>
          for (k = 0; k < j; k++) {
 801ceaa:	9b02      	ldr	r3, [sp, #8]
 801ceac:	f10a 0a10 	add.w	sl, sl, #16
 801ceb0:	4553      	cmp	r3, sl
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801ceb2:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < j; k++) {
 801ceb6:	f105 0510 	add.w	r5, r5, #16
 801ceba:	f10b 0b10 	add.w	fp, fp, #16
 801cebe:	f104 0410 	add.w	r4, r4, #16
 801cec2:	f47f af74 	bne.w	801cdae <cblas_zhemm+0x82e>
 801cec6:	9a06      	ldr	r2, [sp, #24]
 801cec8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801ceca:	4611      	mov	r1, r2
 801cecc:	9a04      	ldr	r2, [sp, #16]
 801cece:	3210      	adds	r2, #16
 801ced0:	9204      	str	r2, [sp, #16]
 801ced2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801ced4:	4419      	add	r1, r3
 801ced6:	3210      	adds	r2, #16
 801ced8:	9106      	str	r1, [sp, #24]
 801ceda:	920f      	str	r2, [sp, #60]	; 0x3c
 801cedc:	9912      	ldr	r1, [sp, #72]	; 0x48
 801cede:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801cee0:	440a      	add	r2, r1
 801cee2:	920c      	str	r2, [sp, #48]	; 0x30
 801cee4:	9a02      	ldr	r2, [sp, #8]
 801cee6:	441a      	add	r2, r3
 801cee8:	9202      	str	r2, [sp, #8]
 801ceea:	e6b8      	b.n	801cc5e <cblas_zhemm+0x6de>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801ceec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801ceee:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801cef0:	2b01      	cmp	r3, #1
 801cef2:	bfb8      	it	lt
 801cef4:	2301      	movlt	r3, #1
 801cef6:	4293      	cmp	r3, r2
 801cef8:	f300 8347 	bgt.w	801d58a <cblas_zhemm+0x100a>
 801cefc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801cefe:	4293      	cmp	r3, r2
 801cf00:	bfcc      	ite	gt
 801cf02:	200d      	movgt	r0, #13
 801cf04:	2008      	movle	r0, #8
 801cf06:	f7ff bb77 	b.w	801c5f8 <cblas_zhemm+0x78>
 801cf0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801cf0c:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801cf0e:	2b01      	cmp	r3, #1
 801cf10:	bfb8      	it	lt
 801cf12:	2301      	movlt	r3, #1
 801cf14:	4293      	cmp	r3, r2
 801cf16:	f300 8338 	bgt.w	801d58a <cblas_zhemm+0x100a>
 801cf1a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801cf1c:	4293      	cmp	r3, r2
 801cf1e:	f77f abf5 	ble.w	801c70c <cblas_zhemm+0x18c>
 801cf22:	200d      	movs	r0, #13
 801cf24:	f7ff bb68 	b.w	801c5f8 <cblas_zhemm+0x78>
      for (i = 0; i < n1; i++) {
 801cf28:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801cf2a:	2a00      	cmp	r2, #0
 801cf2c:	f77f abfa 	ble.w	801c724 <cblas_zhemm+0x1a4>
 801cf30:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801cf32:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801cf34:	910f      	str	r1, [sp, #60]	; 0x3c
 801cf36:	3301      	adds	r3, #1
 801cf38:	0118      	lsls	r0, r3, #4
 801cf3a:	f1a1 0310 	sub.w	r3, r1, #16
 801cf3e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801cf42:	9312      	str	r3, [sp, #72]	; 0x48
 801cf44:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801cf46:	901f      	str	r0, [sp, #124]	; 0x7c
 801cf48:	011a      	lsls	r2, r3, #4
 801cf4a:	9204      	str	r2, [sp, #16]
 801cf4c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801cf4e:	2100      	movs	r1, #0
 801cf50:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
 801cf54:	911b      	str	r1, [sp, #108]	; 0x6c
 801cf56:	3810      	subs	r0, #16
 801cf58:	911c      	str	r1, [sp, #112]	; 0x70
 801cf5a:	2301      	movs	r3, #1
 801cf5c:	0111      	lsls	r1, r2, #4
 801cf5e:	901e      	str	r0, [sp, #120]	; 0x78
 801cf60:	9100      	str	r1, [sp, #0]
 801cf62:	9311      	str	r3, [sp, #68]	; 0x44
        for (j = 0; j < n2; j++) {
 801cf64:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801cf66:	2b00      	cmp	r3, #0
 801cf68:	f340 837c 	ble.w	801d664 <cblas_zhemm+0x10e4>
 801cf6c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801cf6e:	991c      	ldr	r1, [sp, #112]	; 0x70
 801cf70:	981b      	ldr	r0, [sp, #108]	; 0x6c
 801cf72:	1a5a      	subs	r2, r3, r1
 801cf74:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801cf76:	1a1b      	subs	r3, r3, r0
 801cf78:	011b      	lsls	r3, r3, #4
 801cf7a:	3308      	adds	r3, #8
 801cf7c:	9316      	str	r3, [sp, #88]	; 0x58
 801cf7e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801cf80:	931d      	str	r3, [sp, #116]	; 0x74
 801cf82:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801cf84:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 801cf88:	9306      	str	r3, [sp, #24]
 801cf8a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801cf8c:	0112      	lsls	r2, r2, #4
 801cf8e:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801cf92:	3208      	adds	r2, #8
 801cf94:	930c      	str	r3, [sp, #48]	; 0x30
 801cf96:	2300      	movs	r3, #0
 801cf98:	9213      	str	r2, [sp, #76]	; 0x4c
 801cf9a:	9310      	str	r3, [sp, #64]	; 0x40
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801cf9c:	9c06      	ldr	r4, [sp, #24]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cf9e:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801cfa2:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cfa6:	ec51 0b18 	vmov	r0, r1, d8
 801cfaa:	4632      	mov	r2, r6
 801cfac:	463b      	mov	r3, r7
 801cfae:	f00b fddb 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801cfb2:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cfb6:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801cfba:	4642      	mov	r2, r8
 801cfbc:	464b      	mov	r3, r9
 801cfbe:	4604      	mov	r4, r0
 801cfc0:	460d      	mov	r5, r1
 801cfc2:	4650      	mov	r0, sl
 801cfc4:	4659      	mov	r1, fp
 801cfc6:	f00b fdcf 	bl	8028b68 <__aeabi_dmul>
 801cfca:	4602      	mov	r2, r0
 801cfcc:	460b      	mov	r3, r1
 801cfce:	4620      	mov	r0, r4
 801cfd0:	4629      	mov	r1, r5
 801cfd2:	f00b fc11 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cfd6:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cfd8:	4604      	mov	r4, r0
 801cfda:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cfdc:	464b      	mov	r3, r9
 801cfde:	ec51 0b18 	vmov	r0, r1, d8
 801cfe2:	f00b fdc1 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801cfe6:	46a0      	mov	r8, r4
 801cfe8:	46a9      	mov	r9, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801cfea:	4632      	mov	r2, r6
 801cfec:	463b      	mov	r3, r7
 801cfee:	4604      	mov	r4, r0
 801cff0:	460d      	mov	r5, r1
 801cff2:	4650      	mov	r0, sl
 801cff4:	4659      	mov	r1, fp
 801cff6:	f00b fdb7 	bl	8028b68 <__aeabi_dmul>
 801cffa:	4602      	mov	r2, r0
 801cffc:	460b      	mov	r3, r1
 801cffe:	4620      	mov	r0, r4
 801d000:	4629      	mov	r1, r5
 801d002:	f00b fbfb 	bl	80287fc <__adddf3>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 801d006:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801d008:	e9d3 4500 	ldrd	r4, r5, [r3]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d00c:	4606      	mov	r6, r0
 801d00e:	460f      	mov	r7, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801d010:	4640      	mov	r0, r8
 801d012:	4649      	mov	r1, r9
 801d014:	4622      	mov	r2, r4
 801d016:	462b      	mov	r3, r5
 801d018:	f00b fda6 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d01c:	ec49 8b1e 	vmov	d14, r8, r9
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d020:	46b9      	mov	r9, r7
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801d022:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 801d024:	4602      	mov	r2, r0
 801d026:	460b      	mov	r3, r1
 801d028:	e9d7 0100 	ldrd	r0, r1, [r7]
 801d02c:	f00b fbe6 	bl	80287fc <__adddf3>
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801d030:	4622      	mov	r2, r4
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801d032:	e9c7 0100 	strd	r0, r1, [r7]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801d036:	462b      	mov	r3, r5
 801d038:	4630      	mov	r0, r6
 801d03a:	4649      	mov	r1, r9
 801d03c:	f00b fd94 	bl	8028b68 <__aeabi_dmul>
 801d040:	4602      	mov	r2, r0
 801d042:	460b      	mov	r3, r1
 801d044:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801d048:	f00b fbd8 	bl	80287fc <__adddf3>
          BASE temp2_imag = 0.0;
 801d04c:	ed9f 7b8c 	vldr	d7, [pc, #560]	; 801d280 <cblas_zhemm+0xd00>
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801d050:	e9c7 0102 	strd	r0, r1, [r7, #8]
          BASE temp2_imag = 0.0;
 801d054:	eeb0 da47 	vmov.f32	s26, s14
 801d058:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 801d05c:	eeb0 ca47 	vmov.f32	s24, s14
 801d060:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 801d064:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801d066:	9911      	ldr	r1, [sp, #68]	; 0x44
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d068:	46b0      	mov	r8, r6
          for (k = i + 1; k < n1; k++) {
 801d06a:	428a      	cmp	r2, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d06c:	ec49 8b1f 	vmov	d15, r8, r9
          for (k = i + 1; k < n1; k++) {
 801d070:	f340 8095 	ble.w	801d19e <cblas_zhemm+0xc1e>
 801d074:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801d076:	9c06      	ldr	r4, [sp, #24]
 801d078:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
 801d07c:	9d12      	ldr	r5, [sp, #72]	; 0x48
 801d07e:	1914      	adds	r4, r2, r4
 801d080:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801d082:	eb02 0a07 	add.w	sl, r2, r7
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801d086:	e9db 6704 	ldrd	r6, r7, [fp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801d08a:	ec51 0b1e 	vmov	r0, r1, d14
 801d08e:	4632      	mov	r2, r6
 801d090:	463b      	mov	r3, r7
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801d092:	e9db 8906 	ldrd	r8, r9, [fp, #24]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801d096:	f00b fd67 	bl	8028b68 <__aeabi_dmul>
 801d09a:	4642      	mov	r2, r8
 801d09c:	ec41 0b18 	vmov	d8, r0, r1
 801d0a0:	464b      	mov	r3, r9
 801d0a2:	ec51 0b1f 	vmov	r0, r1, d15
 801d0a6:	f00b fd5f 	bl	8028b68 <__aeabi_dmul>
 801d0aa:	4602      	mov	r2, r0
 801d0ac:	460b      	mov	r3, r1
 801d0ae:	ec51 0b18 	vmov	r0, r1, d8
 801d0b2:	f00b fba3 	bl	80287fc <__adddf3>
 801d0b6:	4602      	mov	r2, r0
 801d0b8:	460b      	mov	r3, r1
 801d0ba:	e95a 0102 	ldrd	r0, r1, [sl, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801d0be:	f8cd 8008 	str.w	r8, [sp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801d0c2:	f00b fb9b 	bl	80287fc <__adddf3>
 801d0c6:	460b      	mov	r3, r1
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801d0c8:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801d0cc:	4602      	mov	r2, r0
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801d0ce:	9103      	str	r1, [sp, #12]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 801d0d0:	ed14 8b02 	vldr	d8, [r4, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 801d0d4:	ed94 9b00 	vldr	d9, [r4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801d0d8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801d0dc:	e94a 2302 	strd	r2, r3, [sl, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801d0e0:	ec53 2b1e 	vmov	r2, r3, d14
 801d0e4:	f00b fd40 	bl	8028b68 <__aeabi_dmul>
 801d0e8:	4632      	mov	r2, r6
 801d0ea:	463b      	mov	r3, r7
 801d0ec:	ec41 0b1b 	vmov	d11, r0, r1
 801d0f0:	ec51 0b1f 	vmov	r0, r1, d15
 801d0f4:	f00b fd38 	bl	8028b68 <__aeabi_dmul>
 801d0f8:	4602      	mov	r2, r0
 801d0fa:	460b      	mov	r3, r1
 801d0fc:	ec51 0b1b 	vmov	r0, r1, d11
 801d100:	f00b fb7c 	bl	80287fc <__adddf3>
 801d104:	4602      	mov	r2, r0
 801d106:	460b      	mov	r3, r1
 801d108:	e9da 0100 	ldrd	r0, r1, [sl]
 801d10c:	f00b fb76 	bl	80287fc <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801d110:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801d114:	e9ca 0100 	strd	r0, r1, [sl]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801d118:	4630      	mov	r0, r6
 801d11a:	4639      	mov	r1, r7
 801d11c:	f00b fd24 	bl	8028b68 <__aeabi_dmul>
 801d120:	ec53 2b19 	vmov	r2, r3, d9
 801d124:	ec41 0b1a 	vmov	d10, r0, r1
 801d128:	4640      	mov	r0, r8
 801d12a:	4649      	mov	r1, r9
 801d12c:	f00b fd1c 	bl	8028b68 <__aeabi_dmul>
 801d130:	4602      	mov	r2, r0
 801d132:	460b      	mov	r3, r1
 801d134:	ec51 0b1a 	vmov	r0, r1, d10
 801d138:	f00b fb5e 	bl	80287f8 <__aeabi_dsub>
 801d13c:	4602      	mov	r2, r0
 801d13e:	460b      	mov	r3, r1
 801d140:	ec51 0b1c 	vmov	r0, r1, d12
 801d144:	f00b fb5a 	bl	80287fc <__adddf3>
 801d148:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801d14c:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801d150:	eeb0 ca47 	vmov.f32	s24, s14
 801d154:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801d158:	4630      	mov	r0, r6
 801d15a:	4639      	mov	r1, r7
 801d15c:	f00b fd04 	bl	8028b68 <__aeabi_dmul>
 801d160:	ec53 2b18 	vmov	r2, r3, d8
 801d164:	4606      	mov	r6, r0
 801d166:	460f      	mov	r7, r1
 801d168:	4640      	mov	r0, r8
 801d16a:	4649      	mov	r1, r9
 801d16c:	f00b fcfc 	bl	8028b68 <__aeabi_dmul>
 801d170:	4602      	mov	r2, r0
 801d172:	460b      	mov	r3, r1
 801d174:	4630      	mov	r0, r6
 801d176:	4639      	mov	r1, r7
 801d178:	f00b fb40 	bl	80287fc <__adddf3>
 801d17c:	460b      	mov	r3, r1
 801d17e:	4602      	mov	r2, r0
 801d180:	ec51 0b1d 	vmov	r0, r1, d13
 801d184:	f00b fb3a 	bl	80287fc <__adddf3>
 801d188:	9b04      	ldr	r3, [sp, #16]
 801d18a:	f10b 0b10 	add.w	fp, fp, #16
 801d18e:	441c      	add	r4, r3
 801d190:	9b00      	ldr	r3, [sp, #0]
          for (k = i + 1; k < n1; k++) {
 801d192:	455d      	cmp	r5, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801d194:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = i + 1; k < n1; k++) {
 801d198:	449a      	add	sl, r3
 801d19a:	f47f af74 	bne.w	801d086 <cblas_zhemm+0xb06>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d19e:	ed9d 8b08 	vldr	d8, [sp, #32]
 801d1a2:	ec53 2b1c 	vmov	r2, r3, d12
 801d1a6:	ec51 0b18 	vmov	r0, r1, d8
 801d1aa:	f00b fcdd 	bl	8028b68 <__aeabi_dmul>
 801d1ae:	e9dd 780a 	ldrd	r7, r8, [sp, #40]	; 0x28
 801d1b2:	ec5a 9b1d 	vmov	r9, sl, d13
 801d1b6:	4604      	mov	r4, r0
 801d1b8:	460d      	mov	r5, r1
 801d1ba:	ee1d 2a10 	vmov	r2, s26
 801d1be:	4653      	mov	r3, sl
 801d1c0:	4638      	mov	r0, r7
 801d1c2:	4641      	mov	r1, r8
 801d1c4:	f00b fcd0 	bl	8028b68 <__aeabi_dmul>
 801d1c8:	4602      	mov	r2, r0
 801d1ca:	460b      	mov	r3, r1
 801d1cc:	4620      	mov	r0, r4
 801d1ce:	4629      	mov	r1, r5
 801d1d0:	f00b fb12 	bl	80287f8 <__aeabi_dsub>
 801d1d4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801d1d6:	4602      	mov	r2, r0
 801d1d8:	460b      	mov	r3, r1
 801d1da:	e9d6 0100 	ldrd	r0, r1, [r6]
 801d1de:	f00b fb0d 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d1e2:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d1e6:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d1ea:	4653      	mov	r3, sl
 801d1ec:	ec51 0b18 	vmov	r0, r1, d8
 801d1f0:	f00b fcba 	bl	8028b68 <__aeabi_dmul>
 801d1f4:	ec53 2b1c 	vmov	r2, r3, d12
 801d1f8:	4604      	mov	r4, r0
 801d1fa:	460d      	mov	r5, r1
 801d1fc:	4638      	mov	r0, r7
 801d1fe:	4641      	mov	r1, r8
 801d200:	f00b fcb2 	bl	8028b68 <__aeabi_dmul>
 801d204:	4602      	mov	r2, r0
 801d206:	460b      	mov	r3, r1
 801d208:	4620      	mov	r0, r4
 801d20a:	4629      	mov	r1, r5
 801d20c:	f00b faf6 	bl	80287fc <__adddf3>
 801d210:	4602      	mov	r2, r0
 801d212:	460b      	mov	r3, r1
 801d214:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801d218:	f00b faf0 	bl	80287fc <__adddf3>
 801d21c:	9b06      	ldr	r3, [sp, #24]
        for (j = 0; j < n2; j++) {
 801d21e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801d220:	3310      	adds	r3, #16
 801d222:	9306      	str	r3, [sp, #24]
 801d224:	f106 0310 	add.w	r3, r6, #16
 801d228:	930c      	str	r3, [sp, #48]	; 0x30
 801d22a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d22c:	3201      	adds	r2, #1
 801d22e:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d230:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801d234:	9210      	str	r2, [sp, #64]	; 0x40
 801d236:	f47f aeb1 	bne.w	801cf9c <cblas_zhemm+0xa1c>
      for (i = 0; i < n1; i++) {
 801d23a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801d23c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801d23e:	3301      	adds	r3, #1
 801d240:	9311      	str	r3, [sp, #68]	; 0x44
 801d242:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801d244:	4611      	mov	r1, r2
 801d246:	4419      	add	r1, r3
 801d248:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801d24a:	911c      	str	r1, [sp, #112]	; 0x70
 801d24c:	991f      	ldr	r1, [sp, #124]	; 0x7c
 801d24e:	440a      	add	r2, r1
 801d250:	991b      	ldr	r1, [sp, #108]	; 0x6c
 801d252:	920f      	str	r2, [sp, #60]	; 0x3c
 801d254:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801d256:	4608      	mov	r0, r1
 801d258:	4410      	add	r0, r2
 801d25a:	9912      	ldr	r1, [sp, #72]	; 0x48
 801d25c:	901b      	str	r0, [sp, #108]	; 0x6c
 801d25e:	981e      	ldr	r0, [sp, #120]	; 0x78
 801d260:	4401      	add	r1, r0
 801d262:	9112      	str	r1, [sp, #72]	; 0x48
 801d264:	991a      	ldr	r1, [sp, #104]	; 0x68
 801d266:	4419      	add	r1, r3
 801d268:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801d26a:	911a      	str	r1, [sp, #104]	; 0x68
 801d26c:	4413      	add	r3, r2
 801d26e:	9319      	str	r3, [sp, #100]	; 0x64
 801d270:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801d272:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801d274:	4293      	cmp	r3, r2
 801d276:	f73f ae75 	bgt.w	801cf64 <cblas_zhemm+0x9e4>
 801d27a:	f7ff ba53 	b.w	801c724 <cblas_zhemm+0x1a4>
 801d27e:	bf00      	nop
	...
      for (i = 0; i < n1; i++) {
 801d288:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801d28a:	2b00      	cmp	r3, #0
 801d28c:	f77f aa4a 	ble.w	801c724 <cblas_zhemm+0x1a4>
 801d290:	9812      	ldr	r0, [sp, #72]	; 0x48
 801d292:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801d294:	1c42      	adds	r2, r0, #1
 801d296:	0112      	lsls	r2, r2, #4
 801d298:	9212      	str	r2, [sp, #72]	; 0x48
 801d29a:	0102      	lsls	r2, r0, #4
 801d29c:	9211      	str	r2, [sp, #68]	; 0x44
 801d29e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801d2a0:	3b10      	subs	r3, #16
 801d2a2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801d2a6:	931d      	str	r3, [sp, #116]	; 0x74
 801d2a8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801d2aa:	011b      	lsls	r3, r3, #4
 801d2ac:	2100      	movs	r1, #0
 801d2ae:	931c      	str	r3, [sp, #112]	; 0x70
 801d2b0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801d2b2:	9119      	str	r1, [sp, #100]	; 0x64
 801d2b4:	e9cd 111a 	strd	r1, r1, [sp, #104]	; 0x68
 801d2b8:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801d2bc:	9316      	str	r3, [sp, #88]	; 0x58
        for (j = 0; j < n2; j++) {
 801d2be:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d2c0:	2b00      	cmp	r3, #0
 801d2c2:	f340 81ac 	ble.w	801d61e <cblas_zhemm+0x109e>
 801d2c6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801d2c8:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801d2ca:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801d2ce:	9304      	str	r3, [sp, #16]
 801d2d0:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801d2d2:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801d2d4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801d2d8:	930f      	str	r3, [sp, #60]	; 0x3c
 801d2da:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801d2dc:	9302      	str	r3, [sp, #8]
 801d2de:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801d2e0:	930c      	str	r3, [sp, #48]	; 0x30
 801d2e2:	2300      	movs	r3, #0
 801d2e4:	9310      	str	r3, [sp, #64]	; 0x40
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801d2e6:	9c04      	ldr	r4, [sp, #16]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d2e8:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801d2ec:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d2f0:	4650      	mov	r0, sl
 801d2f2:	4632      	mov	r2, r6
 801d2f4:	463b      	mov	r3, r7
 801d2f6:	4659      	mov	r1, fp
 801d2f8:	f00b fc36 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801d2fc:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d300:	ed9d 8b0a 	vldr	d8, [sp, #40]	; 0x28
 801d304:	464b      	mov	r3, r9
 801d306:	4604      	mov	r4, r0
 801d308:	460d      	mov	r5, r1
 801d30a:	4642      	mov	r2, r8
 801d30c:	ec51 0b18 	vmov	r0, r1, d8
 801d310:	f00b fc2a 	bl	8028b68 <__aeabi_dmul>
 801d314:	4602      	mov	r2, r0
 801d316:	460b      	mov	r3, r1
 801d318:	4620      	mov	r0, r4
 801d31a:	4629      	mov	r1, r5
 801d31c:	f00b fa6c 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d320:	464b      	mov	r3, r9
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d322:	4604      	mov	r4, r0
 801d324:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d326:	4642      	mov	r2, r8
 801d328:	4650      	mov	r0, sl
 801d32a:	4659      	mov	r1, fp
 801d32c:	f00b fc1c 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d330:	46a1      	mov	r9, r4
 801d332:	46aa      	mov	sl, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d334:	4632      	mov	r2, r6
 801d336:	463b      	mov	r3, r7
 801d338:	4604      	mov	r4, r0
 801d33a:	460d      	mov	r5, r1
 801d33c:	ec51 0b18 	vmov	r0, r1, d8
 801d340:	f00b fc12 	bl	8028b68 <__aeabi_dmul>
 801d344:	4602      	mov	r2, r0
 801d346:	460b      	mov	r3, r1
 801d348:	4620      	mov	r0, r4
 801d34a:	4629      	mov	r1, r5
 801d34c:	f00b fa56 	bl	80287fc <__adddf3>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801d350:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d352:	e9d3 4500 	ldrd	r4, r5, [r3]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d356:	4606      	mov	r6, r0
 801d358:	460f      	mov	r7, r1
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801d35a:	462b      	mov	r3, r5
 801d35c:	4648      	mov	r0, r9
 801d35e:	4651      	mov	r1, sl
 801d360:	4622      	mov	r2, r4
 801d362:	f00b fc01 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801d366:	ec4a 9b1b 	vmov	d11, r9, sl
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d36a:	46ba      	mov	sl, r7
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801d36c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 801d36e:	4602      	mov	r2, r0
 801d370:	460b      	mov	r3, r1
 801d372:	e9d7 0100 	ldrd	r0, r1, [r7]
 801d376:	f00b fa41 	bl	80287fc <__adddf3>
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801d37a:	462b      	mov	r3, r5
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801d37c:	e9c7 0100 	strd	r0, r1, [r7]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801d380:	4622      	mov	r2, r4
 801d382:	4630      	mov	r0, r6
 801d384:	4651      	mov	r1, sl
 801d386:	f00b fbef 	bl	8028b68 <__aeabi_dmul>
 801d38a:	4602      	mov	r2, r0
 801d38c:	460b      	mov	r3, r1
 801d38e:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801d392:	f00b fa33 	bl	80287fc <__adddf3>
          for (k = j + 1; k < n2; k++) {
 801d396:	9d10      	ldr	r5, [sp, #64]	; 0x40
 801d398:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801d39a:	3501      	adds	r5, #1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d39c:	46b1      	mov	r9, r6
          for (k = j + 1; k < n2; k++) {
 801d39e:	42aa      	cmp	r2, r5
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801d3a0:	e9c7 0102 	strd	r0, r1, [r7, #8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801d3a4:	ec4a 9b1a 	vmov	d10, r9, sl
          for (k = j + 1; k < n2; k++) {
 801d3a8:	9510      	str	r5, [sp, #64]	; 0x40
 801d3aa:	f000 8108 	beq.w	801d5be <cblas_zhemm+0x103e>
          BASE temp2_imag = 0.0;
 801d3ae:	ed1f 7b4c 	vldr	d7, [pc, #-304]	; 801d280 <cblas_zhemm+0xd00>
          for (k = j + 1; k < n2; k++) {
 801d3b2:	9c04      	ldr	r4, [sp, #16]
 801d3b4:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 801d3b8:	9400      	str	r4, [sp, #0]
 801d3ba:	46b9      	mov	r9, r7
          BASE temp2_imag = 0.0;
 801d3bc:	eeb0 da47 	vmov.f32	s26, s14
 801d3c0:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 801d3c4:	eeb0 ca47 	vmov.f32	s24, s14
 801d3c8:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801d3cc:	e9d8 4504 	ldrd	r4, r5, [r8, #16]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801d3d0:	ec51 0b1b 	vmov	r0, r1, d11
 801d3d4:	4622      	mov	r2, r4
 801d3d6:	462b      	mov	r3, r5
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801d3d8:	e9d8 ab06 	ldrd	sl, fp, [r8, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801d3dc:	f00b fbc4 	bl	8028b68 <__aeabi_dmul>
 801d3e0:	4652      	mov	r2, sl
 801d3e2:	4606      	mov	r6, r0
 801d3e4:	460f      	mov	r7, r1
 801d3e6:	465b      	mov	r3, fp
 801d3e8:	ec51 0b1a 	vmov	r0, r1, d10
 801d3ec:	f00b fbbc 	bl	8028b68 <__aeabi_dmul>
 801d3f0:	4602      	mov	r2, r0
 801d3f2:	460b      	mov	r3, r1
 801d3f4:	4630      	mov	r0, r6
 801d3f6:	4639      	mov	r1, r7
 801d3f8:	f00b f9fe 	bl	80287f8 <__aeabi_dsub>
 801d3fc:	4602      	mov	r2, r0
 801d3fe:	460b      	mov	r3, r1
 801d400:	e9d9 0104 	ldrd	r0, r1, [r9, #16]
 801d404:	f00b f9fa 	bl	80287fc <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 801d408:	9b00      	ldr	r3, [sp, #0]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801d40a:	4652      	mov	r2, sl
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 801d40c:	ed93 8b04 	vldr	d8, [r3, #16]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 801d410:	ed93 9b06 	vldr	d9, [r3, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801d414:	e9c9 0104 	strd	r0, r1, [r9, #16]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801d418:	465b      	mov	r3, fp
 801d41a:	ec51 0b1b 	vmov	r0, r1, d11
 801d41e:	f00b fba3 	bl	8028b68 <__aeabi_dmul>
 801d422:	4622      	mov	r2, r4
 801d424:	4606      	mov	r6, r0
 801d426:	460f      	mov	r7, r1
 801d428:	462b      	mov	r3, r5
 801d42a:	ec51 0b1a 	vmov	r0, r1, d10
 801d42e:	f00b fb9b 	bl	8028b68 <__aeabi_dmul>
 801d432:	4602      	mov	r2, r0
 801d434:	460b      	mov	r3, r1
 801d436:	4630      	mov	r0, r6
 801d438:	4639      	mov	r1, r7
 801d43a:	f00b f9df 	bl	80287fc <__adddf3>
 801d43e:	4602      	mov	r2, r0
 801d440:	460b      	mov	r3, r1
 801d442:	e9d9 0106 	ldrd	r0, r1, [r9, #24]
 801d446:	f00b f9d9 	bl	80287fc <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d44a:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801d44e:	e9c9 0106 	strd	r0, r1, [r9, #24]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d452:	4620      	mov	r0, r4
 801d454:	4629      	mov	r1, r5
 801d456:	f00b fb87 	bl	8028b68 <__aeabi_dmul>
 801d45a:	ec53 2b19 	vmov	r2, r3, d9
 801d45e:	4606      	mov	r6, r0
 801d460:	460f      	mov	r7, r1
 801d462:	4650      	mov	r0, sl
 801d464:	4659      	mov	r1, fp
 801d466:	f00b fb7f 	bl	8028b68 <__aeabi_dmul>
 801d46a:	4602      	mov	r2, r0
 801d46c:	460b      	mov	r3, r1
 801d46e:	4630      	mov	r0, r6
 801d470:	4639      	mov	r1, r7
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d472:	f8cd a018 	str.w	sl, [sp, #24]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d476:	f00b f9c1 	bl	80287fc <__adddf3>
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d47a:	f10b 4600 	add.w	r6, fp, #2147483648	; 0x80000000
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d47e:	4602      	mov	r2, r0
 801d480:	460b      	mov	r3, r1
 801d482:	ec51 0b1c 	vmov	r0, r1, d12
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d486:	9607      	str	r6, [sp, #28]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d488:	f00b f9b8 	bl	80287fc <__adddf3>
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d48c:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d490:	4606      	mov	r6, r0
 801d492:	460f      	mov	r7, r1
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d494:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801d498:	f00b fb66 	bl	8028b68 <__aeabi_dmul>
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801d49c:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d4a0:	ec53 2b19 	vmov	r2, r3, d9
 801d4a4:	4606      	mov	r6, r0
 801d4a6:	460f      	mov	r7, r1
 801d4a8:	4620      	mov	r0, r4
 801d4aa:	4629      	mov	r1, r5
 801d4ac:	f00b fb5c 	bl	8028b68 <__aeabi_dmul>
 801d4b0:	4602      	mov	r2, r0
 801d4b2:	460b      	mov	r3, r1
 801d4b4:	4630      	mov	r0, r6
 801d4b6:	4639      	mov	r1, r7
 801d4b8:	f00b f9a0 	bl	80287fc <__adddf3>
 801d4bc:	460b      	mov	r3, r1
 801d4be:	4602      	mov	r2, r0
 801d4c0:	ec51 0b1d 	vmov	r0, r1, d13
 801d4c4:	f00b f99a 	bl	80287fc <__adddf3>
 801d4c8:	9b00      	ldr	r3, [sp, #0]
 801d4ca:	3310      	adds	r3, #16
 801d4cc:	9300      	str	r3, [sp, #0]
          for (k = j + 1; k < n2; k++) {
 801d4ce:	9b02      	ldr	r3, [sp, #8]
 801d4d0:	f108 0810 	add.w	r8, r8, #16
 801d4d4:	4543      	cmp	r3, r8
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801d4d6:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = j + 1; k < n2; k++) {
 801d4da:	f109 0910 	add.w	r9, r9, #16
 801d4de:	f47f af75 	bne.w	801d3cc <cblas_zhemm+0xe4c>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d4e2:	ed9d 8b08 	vldr	d8, [sp, #32]
 801d4e6:	ec53 2b1c 	vmov	r2, r3, d12
 801d4ea:	ec51 0b18 	vmov	r0, r1, d8
 801d4ee:	f00b fb3b 	bl	8028b68 <__aeabi_dmul>
 801d4f2:	e9dd 780a 	ldrd	r7, r8, [sp, #40]	; 0x28
 801d4f6:	ec5a 9b1d 	vmov	r9, sl, d13
 801d4fa:	4604      	mov	r4, r0
 801d4fc:	460d      	mov	r5, r1
 801d4fe:	ee1d 2a10 	vmov	r2, s26
 801d502:	4653      	mov	r3, sl
 801d504:	4638      	mov	r0, r7
 801d506:	4641      	mov	r1, r8
 801d508:	f00b fb2e 	bl	8028b68 <__aeabi_dmul>
 801d50c:	4602      	mov	r2, r0
 801d50e:	460b      	mov	r3, r1
 801d510:	4620      	mov	r0, r4
 801d512:	4629      	mov	r1, r5
 801d514:	f00b f970 	bl	80287f8 <__aeabi_dsub>
 801d518:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 801d51a:	4602      	mov	r2, r0
 801d51c:	460b      	mov	r3, r1
 801d51e:	e9d6 0100 	ldrd	r0, r1, [r6]
 801d522:	f00b f96b 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d526:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d52a:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d52e:	4653      	mov	r3, sl
 801d530:	ec51 0b18 	vmov	r0, r1, d8
 801d534:	f00b fb18 	bl	8028b68 <__aeabi_dmul>
 801d538:	ec53 2b1c 	vmov	r2, r3, d12
 801d53c:	4604      	mov	r4, r0
 801d53e:	460d      	mov	r5, r1
 801d540:	4638      	mov	r0, r7
 801d542:	4641      	mov	r1, r8
 801d544:	f00b fb10 	bl	8028b68 <__aeabi_dmul>
 801d548:	4602      	mov	r2, r0
 801d54a:	460b      	mov	r3, r1
 801d54c:	4620      	mov	r0, r4
 801d54e:	4629      	mov	r1, r5
 801d550:	f00b f954 	bl	80287fc <__adddf3>
 801d554:	4602      	mov	r2, r0
 801d556:	460b      	mov	r3, r1
 801d558:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801d55c:	f00b f94e 	bl	80287fc <__adddf3>
 801d560:	9b04      	ldr	r3, [sp, #16]
 801d562:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801d564:	3310      	adds	r3, #16
 801d566:	9304      	str	r3, [sp, #16]
 801d568:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d56a:	4413      	add	r3, r2
 801d56c:	930c      	str	r3, [sp, #48]	; 0x30
 801d56e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801d570:	9b02      	ldr	r3, [sp, #8]
 801d572:	4413      	add	r3, r2
 801d574:	9302      	str	r3, [sp, #8]
 801d576:	f106 0310 	add.w	r3, r6, #16
 801d57a:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801d57e:	930f      	str	r3, [sp, #60]	; 0x3c
 801d580:	e6b1      	b.n	801d2e6 <cblas_zhemm+0xd66>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801d582:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801d584:	2b00      	cmp	r3, #0
 801d586:	dc78      	bgt.n	801d67a <cblas_zhemm+0x10fa>
 801d588:	2301      	movs	r3, #1
 801d58a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801d58c:	429a      	cmp	r2, r3
 801d58e:	bfb4      	ite	lt
 801d590:	200d      	movlt	r0, #13
 801d592:	200a      	movge	r0, #10
 801d594:	f7ff b830 	b.w	801c5f8 <cblas_zhemm+0x78>
 801d598:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d59a:	e4b7      	b.n	801cf0c <cblas_zhemm+0x98c>
      for (i = 0; i < n1; i++) {
 801d59c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801d59e:	9919      	ldr	r1, [sp, #100]	; 0x64
 801d5a0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801d5a2:	440a      	add	r2, r1
 801d5a4:	9214      	str	r2, [sp, #80]	; 0x50
 801d5a6:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801d5a8:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801d5aa:	440a      	add	r2, r1
 801d5ac:	9211      	str	r2, [sp, #68]	; 0x44
 801d5ae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801d5b0:	3301      	adds	r3, #1
 801d5b2:	429a      	cmp	r2, r3
 801d5b4:	9316      	str	r3, [sp, #88]	; 0x58
 801d5b6:	f47f ab01 	bne.w	801cbbc <cblas_zhemm+0x63c>
 801d5ba:	f7ff b8b3 	b.w	801c724 <cblas_zhemm+0x1a4>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d5be:	2200      	movs	r2, #0
 801d5c0:	2300      	movs	r3, #0
 801d5c2:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801d5c6:	f00b facf 	bl	8028b68 <__aeabi_dmul>
 801d5ca:	2200      	movs	r2, #0
 801d5cc:	4680      	mov	r8, r0
 801d5ce:	4689      	mov	r9, r1
 801d5d0:	2300      	movs	r3, #0
 801d5d2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801d5d6:	f00b fac7 	bl	8028b68 <__aeabi_dmul>
 801d5da:	4604      	mov	r4, r0
 801d5dc:	460d      	mov	r5, r1
 801d5de:	4622      	mov	r2, r4
 801d5e0:	462b      	mov	r3, r5
 801d5e2:	4640      	mov	r0, r8
 801d5e4:	4649      	mov	r1, r9
 801d5e6:	f00b f907 	bl	80287f8 <__aeabi_dsub>
 801d5ea:	460b      	mov	r3, r1
 801d5ec:	9916      	ldr	r1, [sp, #88]	; 0x58
 801d5ee:	4602      	mov	r2, r0
 801d5f0:	e951 0104 	ldrd	r0, r1, [r1, #-16]
 801d5f4:	f00b f902 	bl	80287fc <__adddf3>
 801d5f8:	4606      	mov	r6, r0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d5fa:	4620      	mov	r0, r4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d5fc:	9c16      	ldr	r4, [sp, #88]	; 0x58
 801d5fe:	460f      	mov	r7, r1
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d600:	4642      	mov	r2, r8
 801d602:	464b      	mov	r3, r9
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d604:	e944 6704 	strd	r6, r7, [r4, #-16]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d608:	4629      	mov	r1, r5
 801d60a:	f00b f8f7 	bl	80287fc <__adddf3>
 801d60e:	4602      	mov	r2, r0
 801d610:	460b      	mov	r3, r1
 801d612:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801d616:	f00b f8f1 	bl	80287fc <__adddf3>
 801d61a:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (i = 0; i < n1; i++) {
 801d61e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801d620:	991c      	ldr	r1, [sp, #112]	; 0x70
 801d622:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801d624:	440a      	add	r2, r1
 801d626:	9216      	str	r2, [sp, #88]	; 0x58
 801d628:	9918      	ldr	r1, [sp, #96]	; 0x60
 801d62a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801d62c:	440a      	add	r2, r1
 801d62e:	921a      	str	r2, [sp, #104]	; 0x68
 801d630:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801d632:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801d634:	440a      	add	r2, r1
 801d636:	9219      	str	r2, [sp, #100]	; 0x64
 801d638:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801d63a:	3301      	adds	r3, #1
 801d63c:	429a      	cmp	r2, r3
 801d63e:	931b      	str	r3, [sp, #108]	; 0x6c
 801d640:	f47f ae3d 	bne.w	801d2be <cblas_zhemm+0xd3e>
 801d644:	f7ff b86e 	b.w	801c724 <cblas_zhemm+0x1a4>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801d648:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d64a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801d64c:	2b01      	cmp	r3, #1
 801d64e:	bfb8      	it	lt
 801d650:	2301      	movlt	r3, #1
 801d652:	429a      	cmp	r2, r3
 801d654:	db99      	blt.n	801d58a <cblas_zhemm+0x100a>
 801d656:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801d658:	429a      	cmp	r2, r3
 801d65a:	bfac      	ite	ge
 801d65c:	2008      	movge	r0, #8
 801d65e:	200d      	movlt	r0, #13
 801d660:	f7fe bfca 	b.w	801c5f8 <cblas_zhemm+0x78>
 801d664:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801d666:	931d      	str	r3, [sp, #116]	; 0x74
 801d668:	e5e7      	b.n	801d23a <cblas_zhemm+0xcba>
 801d66a:	3865      	subs	r0, #101	; 0x65
 801d66c:	2801      	cmp	r0, #1
 801d66e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801d670:	bf94      	ite	ls
 801d672:	2000      	movls	r0, #0
 801d674:	2001      	movhi	r0, #1
 801d676:	f7fe bfa4 	b.w	801c5c2 <cblas_zhemm+0x42>
 801d67a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801d67c:	2b00      	cmp	r3, #0
 801d67e:	bfcc      	ite	gt
 801d680:	2005      	movgt	r0, #5
 801d682:	200d      	movle	r0, #13
 801d684:	f7fe bfb8 	b.w	801c5f8 <cblas_zhemm+0x78>
 801d688:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d68a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801d68c:	2b01      	cmp	r3, #1
 801d68e:	bfb8      	it	lt
 801d690:	2301      	movlt	r3, #1
 801d692:	429a      	cmp	r2, r3
 801d694:	f6ff af79 	blt.w	801d58a <cblas_zhemm+0x100a>
 801d698:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801d69a:	429a      	cmp	r2, r3
 801d69c:	bfac      	ite	ge
 801d69e:	2005      	movge	r0, #5
 801d6a0:	200d      	movlt	r0, #13
 801d6a2:	f7fe bfa9 	b.w	801c5f8 <cblas_zhemm+0x78>
 801d6a6:	bf00      	nop

0801d6a8 <cblas_zhemv>:
void
cblas_zhemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *A, const int lda,
             const void *X, const int incX, const void *beta, void *Y,
             const int incY)
{
 801d6a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d6ac:	ed2d 8b10 	vpush	{d8-d15}
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801d6b0:	2866      	cmp	r0, #102	; 0x66
 801d6b2:	b09b      	sub	sp, #108	; 0x6c
 801d6b4:	461d      	mov	r5, r3
 801d6b6:	bf0c      	ite	eq
 801d6b8:	f04f 33ff 	moveq.w	r3, #4294967295
 801d6bc:	2301      	movne	r3, #1
 801d6be:	9312      	str	r3, [sp, #72]	; 0x48
 801d6c0:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 801d6c2:	930e      	str	r3, [sp, #56]	; 0x38
 801d6c4:	9b35      	ldr	r3, [sp, #212]	; 0xd4
 801d6c6:	9305      	str	r3, [sp, #20]
 801d6c8:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 801d6ca:	9313      	str	r3, [sp, #76]	; 0x4c
 801d6cc:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 801d6ce:	930d      	str	r3, [sp, #52]	; 0x34
 801d6d0:	e9dd 4338 	ldrd	r4, r3, [sp, #224]	; 0xe0
 801d6d4:	910b      	str	r1, [sp, #44]	; 0x2c
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801d6d6:	3979      	subs	r1, #121	; 0x79
 801d6d8:	9315      	str	r3, [sp, #84]	; 0x54
 801d6da:	2901      	cmp	r1, #1
 801d6dc:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801d6de:	9004      	str	r0, [sp, #16]
 801d6e0:	920a      	str	r2, [sp, #40]	; 0x28
 801d6e2:	930c      	str	r3, [sp, #48]	; 0x30
 801d6e4:	f240 8150 	bls.w	801d988 <cblas_zhemv+0x2e0>
 801d6e8:	2002      	movs	r0, #2
 801d6ea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d6ec:	2b00      	cmp	r3, #0
 801d6ee:	f2c0 813d 	blt.w	801d96c <cblas_zhemv+0x2c4>
 801d6f2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d6f4:	9a05      	ldr	r2, [sp, #20]
 801d6f6:	2b01      	cmp	r3, #1
 801d6f8:	bfb8      	it	lt
 801d6fa:	2301      	movlt	r3, #1
 801d6fc:	4293      	cmp	r3, r2
 801d6fe:	f340 80ea 	ble.w	801d8d6 <cblas_zhemv+0x22e>
 801d702:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d704:	2b00      	cmp	r3, #0
 801d706:	f040 80f2 	bne.w	801d8ee <cblas_zhemv+0x246>
 801d70a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d70c:	2b00      	cmp	r3, #0
 801d70e:	bf0c      	ite	eq
 801d710:	200b      	moveq	r0, #11
 801d712:	2008      	movne	r0, #8
 801d714:	4a9f      	ldr	r2, [pc, #636]	; (801d994 <cblas_zhemv+0x2ec>)
 801d716:	49a0      	ldr	r1, [pc, #640]	; (801d998 <cblas_zhemv+0x2f0>)
 801d718:	f00a fff6 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801d71c:	ed95 7b00 	vldr	d7, [r5]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801d720:	2200      	movs	r2, #0
 801d722:	ec51 0b17 	vmov	r0, r1, d7
 801d726:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 801d728:	ed8d 7b06 	vstr	d7, [sp, #24]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801d72c:	f00b fc84 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801d730:	ed95 7b02 	vldr	d7, [r5, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801d734:	ed94 8b00 	vldr	d8, [r4]
    const BASE beta_imag = CONST_IMAG0(beta);
 801d738:	ed94 9b02 	vldr	d9, [r4, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801d73c:	eeb0 ba48 	vmov.f32	s22, s16
 801d740:	eef0 ba68 	vmov.f32	s23, s17
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801d744:	ed8d 7b08 	vstr	d7, [sp, #32]
    const BASE beta_imag = CONST_IMAG0(beta);
 801d748:	eeb0 ca49 	vmov.f32	s24, s18
 801d74c:	eef0 ca69 	vmov.f32	s25, s19
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801d750:	2800      	cmp	r0, #0
 801d752:	f000 8085 	beq.w	801d860 <cblas_zhemv+0x1b8>
 801d756:	ec51 0b17 	vmov	r0, r1, d7
 801d75a:	2200      	movs	r2, #0
 801d75c:	2300      	movs	r3, #0
 801d75e:	f00b fc6b 	bl	8029038 <__aeabi_dcmpeq>
 801d762:	2800      	cmp	r0, #0
 801d764:	d07c      	beq.n	801d860 <cblas_zhemv+0x1b8>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801d766:	4b8d      	ldr	r3, [pc, #564]	; (801d99c <cblas_zhemv+0x2f4>)
 801d768:	2200      	movs	r2, #0
 801d76a:	ec51 0b18 	vmov	r0, r1, d8
 801d76e:	f00b fc63 	bl	8029038 <__aeabi_dcmpeq>
 801d772:	2200      	movs	r2, #0
 801d774:	2300      	movs	r3, #0
 801d776:	2800      	cmp	r0, #0
 801d778:	f000 82ee 	beq.w	801dd58 <cblas_zhemv+0x6b0>
 801d77c:	ec51 0b19 	vmov	r0, r1, d9
 801d780:	f00b fc5a 	bl	8029038 <__aeabi_dcmpeq>
 801d784:	2800      	cmp	r0, #0
 801d786:	f040 80ec 	bne.w	801d962 <cblas_zhemv+0x2ba>
      INDEX iy = OFFSET(N, incY);
 801d78a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d78c:	2b00      	cmp	r3, #0
 801d78e:	f340 82dd 	ble.w	801dd4c <cblas_zhemv+0x6a4>
 801d792:	f04f 0a00 	mov.w	sl, #0
      for (i = 0; i < N; i++) {
 801d796:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d798:	2b00      	cmp	r3, #0
 801d79a:	dd3f      	ble.n	801d81c <cblas_zhemv+0x174>
 801d79c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801d79e:	eb02 130a 	add.w	r3, r2, sl, lsl #4
 801d7a2:	f103 0b08 	add.w	fp, r3, #8
 801d7a6:	469a      	mov	sl, r3
 801d7a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d7aa:	011f      	lsls	r7, r3, #4
 801d7ac:	2300      	movs	r3, #0
 801d7ae:	461e      	mov	r6, r3
        const BASE y_real = REAL(Y, iy);
 801d7b0:	e95b 8902 	ldrd	r8, r9, [fp, #-8]
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801d7b4:	ec51 0b1b 	vmov	r0, r1, d11
 801d7b8:	4642      	mov	r2, r8
 801d7ba:	464b      	mov	r3, r9
        const BASE y_imag = IMAG(Y, iy);
 801d7bc:	e9da 4502 	ldrd	r4, r5, [sl, #8]
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801d7c0:	f00b f9d2 	bl	8028b68 <__aeabi_dmul>
 801d7c4:	4622      	mov	r2, r4
 801d7c6:	462b      	mov	r3, r5
 801d7c8:	ec41 0b1a 	vmov	d10, r0, r1
 801d7cc:	ec51 0b1c 	vmov	r0, r1, d12
 801d7d0:	f00b f9ca 	bl	8028b68 <__aeabi_dmul>
 801d7d4:	4602      	mov	r2, r0
 801d7d6:	460b      	mov	r3, r1
 801d7d8:	ec51 0b1a 	vmov	r0, r1, d10
 801d7dc:	f00b f80c 	bl	80287f8 <__aeabi_dsub>
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801d7e0:	4642      	mov	r2, r8
        REAL(Y, iy) = tmpR;
 801d7e2:	e94b 0102 	strd	r0, r1, [fp, #-8]
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801d7e6:	464b      	mov	r3, r9
 801d7e8:	ec51 0b1c 	vmov	r0, r1, d12
 801d7ec:	f00b f9bc 	bl	8028b68 <__aeabi_dmul>
 801d7f0:	4622      	mov	r2, r4
 801d7f2:	462b      	mov	r3, r5
 801d7f4:	4604      	mov	r4, r0
 801d7f6:	460d      	mov	r5, r1
 801d7f8:	ec51 0b1b 	vmov	r0, r1, d11
 801d7fc:	f00b f9b4 	bl	8028b68 <__aeabi_dmul>
 801d800:	460b      	mov	r3, r1
 801d802:	4602      	mov	r2, r0
 801d804:	4629      	mov	r1, r5
 801d806:	4620      	mov	r0, r4
 801d808:	f00a fff8 	bl	80287fc <__adddf3>
      for (i = 0; i < N; i++) {
 801d80c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d80e:	3601      	adds	r6, #1
 801d810:	42b3      	cmp	r3, r6
        IMAG(Y, iy) = tmpI;
 801d812:	e9ca 0102 	strd	r0, r1, [sl, #8]
      for (i = 0; i < N; i++) {
 801d816:	44bb      	add	fp, r7
 801d818:	44ba      	add	sl, r7
 801d81a:	d1c9      	bne.n	801d7b0 <cblas_zhemv+0x108>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801d81c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801d820:	2200      	movs	r2, #0
 801d822:	2300      	movs	r3, #0
 801d824:	f00b fc08 	bl	8029038 <__aeabi_dcmpeq>
 801d828:	b140      	cbz	r0, 801d83c <cblas_zhemv+0x194>
 801d82a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801d82e:	2200      	movs	r2, #0
 801d830:	2300      	movs	r3, #0
 801d832:	f00b fc01 	bl	8029038 <__aeabi_dcmpeq>
 801d836:	2800      	cmp	r0, #0
 801d838:	f040 8093 	bne.w	801d962 <cblas_zhemv+0x2ba>
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801d83c:	9b04      	ldr	r3, [sp, #16]
 801d83e:	2b65      	cmp	r3, #101	; 0x65
 801d840:	f000 80b0 	beq.w	801d9a4 <cblas_zhemv+0x2fc>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801d844:	9b04      	ldr	r3, [sp, #16]
 801d846:	2b66      	cmp	r3, #102	; 0x66
 801d848:	f000 8278 	beq.w	801dd3c <cblas_zhemv+0x694>
      BLAS_ERROR("unrecognized operation");
 801d84c:	4a54      	ldr	r2, [pc, #336]	; (801d9a0 <cblas_zhemv+0x2f8>)
 801d84e:	4952      	ldr	r1, [pc, #328]	; (801d998 <cblas_zhemv+0x2f0>)
 801d850:	2000      	movs	r0, #0
#define BASE double
#include "source_hemv.h"
#undef BASE
}
 801d852:	b01b      	add	sp, #108	; 0x6c
 801d854:	ecbd 8b10 	vpop	{d8-d15}
 801d858:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d85c:	f00a bf54 	b.w	8028708 <cblas_xerbla>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801d860:	ec51 0b1b 	vmov	r0, r1, d11
 801d864:	2200      	movs	r2, #0
 801d866:	2300      	movs	r3, #0
 801d868:	f00b fbe6 	bl	8029038 <__aeabi_dcmpeq>
 801d86c:	b308      	cbz	r0, 801d8b2 <cblas_zhemv+0x20a>
 801d86e:	ec51 0b1c 	vmov	r0, r1, d12
 801d872:	2200      	movs	r2, #0
 801d874:	2300      	movs	r3, #0
 801d876:	f00b fbdf 	bl	8029038 <__aeabi_dcmpeq>
 801d87a:	2800      	cmp	r0, #0
 801d87c:	d085      	beq.n	801d78a <cblas_zhemv+0xe2>
      INDEX iy = OFFSET(N, incY);
 801d87e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801d880:	2a00      	cmp	r2, #0
 801d882:	f340 8271 	ble.w	801dd68 <cblas_zhemv+0x6c0>
 801d886:	2300      	movs	r3, #0
      for (i = 0; i < N; i++) {
 801d888:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801d88a:	2a00      	cmp	r2, #0
 801d88c:	ddc6      	ble.n	801d81c <cblas_zhemv+0x174>
 801d88e:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801d890:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801d892:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801d896:	9a0c      	ldr	r2, [sp, #48]	; 0x30
        REAL(Y, iy) = 0.0;
 801d898:	2000      	movs	r0, #0
 801d89a:	0114      	lsls	r4, r2, #4
 801d89c:	2100      	movs	r1, #0
      for (i = 0; i < N; i++) {
 801d89e:	2200      	movs	r2, #0
 801d8a0:	3201      	adds	r2, #1
 801d8a2:	4295      	cmp	r5, r2
        REAL(Y, iy) = 0.0;
 801d8a4:	e9c3 0100 	strd	r0, r1, [r3]
        IMAG(Y, iy) = 0.0;
 801d8a8:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (i = 0; i < N; i++) {
 801d8ac:	4423      	add	r3, r4
 801d8ae:	d1f7      	bne.n	801d8a0 <cblas_zhemv+0x1f8>
 801d8b0:	e7b4      	b.n	801d81c <cblas_zhemv+0x174>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801d8b2:	4b3a      	ldr	r3, [pc, #232]	; (801d99c <cblas_zhemv+0x2f4>)
 801d8b4:	ec51 0b1b 	vmov	r0, r1, d11
 801d8b8:	2200      	movs	r2, #0
 801d8ba:	f00b fbbd 	bl	8029038 <__aeabi_dcmpeq>
 801d8be:	2800      	cmp	r0, #0
 801d8c0:	f43f af63 	beq.w	801d78a <cblas_zhemv+0xe2>
 801d8c4:	ec51 0b1c 	vmov	r0, r1, d12
 801d8c8:	2200      	movs	r2, #0
 801d8ca:	2300      	movs	r3, #0
 801d8cc:	f00b fbb4 	bl	8029038 <__aeabi_dcmpeq>
 801d8d0:	2800      	cmp	r0, #0
 801d8d2:	d1a3      	bne.n	801d81c <cblas_zhemv+0x174>
 801d8d4:	e759      	b.n	801d78a <cblas_zhemv+0xe2>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801d8d6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d8d8:	2b00      	cmp	r3, #0
 801d8da:	f43f af16 	beq.w	801d70a <cblas_zhemv+0x62>
 801d8de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d8e0:	2b00      	cmp	r3, #0
 801d8e2:	f000 8415 	beq.w	801e110 <cblas_zhemv+0xa68>
 801d8e6:	2800      	cmp	r0, #0
 801d8e8:	f43f af18 	beq.w	801d71c <cblas_zhemv+0x74>
 801d8ec:	e712      	b.n	801d714 <cblas_zhemv+0x6c>
 801d8ee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d8f0:	2b00      	cmp	r3, #0
 801d8f2:	bf0c      	ite	eq
 801d8f4:	200b      	moveq	r0, #11
 801d8f6:	2006      	movne	r0, #6
 801d8f8:	e70c      	b.n	801d714 <cblas_zhemv+0x6c>
 801d8fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d8fc:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801d8fe:	9e15      	ldr	r6, [sp, #84]	; 0x54
 801d900:	fb03 250a 	mla	r5, r3, sl, r2
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d904:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801d908:	2200      	movs	r2, #0
 801d90a:	2300      	movs	r3, #0
 801d90c:	f00b f92c 	bl	8028b68 <__aeabi_dmul>
 801d910:	2200      	movs	r2, #0
 801d912:	4680      	mov	r8, r0
 801d914:	4689      	mov	r9, r1
 801d916:	2300      	movs	r3, #0
 801d918:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801d91c:	f00b f924 	bl	8028b68 <__aeabi_dmul>
 801d920:	eb06 1405 	add.w	r4, r6, r5, lsl #4
 801d924:	460f      	mov	r7, r1
 801d926:	4606      	mov	r6, r0
 801d928:	4625      	mov	r5, r4
 801d92a:	4640      	mov	r0, r8
 801d92c:	4649      	mov	r1, r9
 801d92e:	4632      	mov	r2, r6
 801d930:	463b      	mov	r3, r7
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d932:	f00a ff61 	bl	80287f8 <__aeabi_dsub>
 801d936:	4602      	mov	r2, r0
 801d938:	460b      	mov	r3, r1
 801d93a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801d93e:	f00a ff5d 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d942:	4642      	mov	r2, r8
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d944:	e9c5 0100 	strd	r0, r1, [r5]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d948:	464b      	mov	r3, r9
 801d94a:	4630      	mov	r0, r6
 801d94c:	4639      	mov	r1, r7
 801d94e:	f00a ff55 	bl	80287fc <__adddf3>
 801d952:	4602      	mov	r2, r0
 801d954:	460b      	mov	r3, r1
 801d956:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801d95a:	f00a ff4f 	bl	80287fc <__adddf3>
 801d95e:	e9c4 0102 	strd	r0, r1, [r4, #8]
 801d962:	b01b      	add	sp, #108	; 0x6c
 801d964:	ecbd 8b10 	vpop	{d8-d15}
 801d968:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801d96c:	9b05      	ldr	r3, [sp, #20]
 801d96e:	2b00      	cmp	r3, #0
 801d970:	f77f aec7 	ble.w	801d702 <cblas_zhemv+0x5a>
 801d974:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d976:	2b00      	cmp	r3, #0
 801d978:	f43f aec7 	beq.w	801d70a <cblas_zhemv+0x62>
 801d97c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d97e:	2b00      	cmp	r3, #0
 801d980:	bf0c      	ite	eq
 801d982:	200b      	moveq	r0, #11
 801d984:	2003      	movne	r0, #3
 801d986:	e6c5      	b.n	801d714 <cblas_zhemv+0x6c>
 801d988:	3865      	subs	r0, #101	; 0x65
 801d98a:	2801      	cmp	r0, #1
 801d98c:	bf94      	ite	ls
 801d98e:	2000      	movls	r0, #0
 801d990:	2001      	movhi	r0, #1
 801d992:	e6aa      	b.n	801d6ea <cblas_zhemv+0x42>
 801d994:	08031108 	.word	0x08031108
 801d998:	08031310 	.word	0x08031310
 801d99c:	3ff00000 	.word	0x3ff00000
 801d9a0:	080311b8 	.word	0x080311b8
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801d9a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d9a6:	2b79      	cmp	r3, #121	; 0x79
 801d9a8:	f000 81ea 	beq.w	801dd80 <cblas_zhemv+0x6d8>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 801d9ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d9ae:	2b7a      	cmp	r3, #122	; 0x7a
 801d9b0:	f47f af4c 	bne.w	801d84c <cblas_zhemv+0x1a4>
      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 801d9b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d9b6:	2b00      	cmp	r3, #0
 801d9b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d9ba:	bfd8      	it	le
 801d9bc:	9a0d      	ldrle	r2, [sp, #52]	; 0x34
 801d9be:	f103 33ff 	add.w	r3, r3, #4294967295
 801d9c2:	930b      	str	r3, [sp, #44]	; 0x2c
 801d9c4:	bfd8      	it	le
 801d9c6:	4252      	negle	r2, r2
 801d9c8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801d9ca:	bfd8      	it	le
 801d9cc:	435a      	mulle	r2, r3
 801d9ce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d9d0:	bfc8      	it	gt
 801d9d2:	2200      	movgt	r2, #0
 801d9d4:	fb01 2803 	mla	r8, r1, r3, r2
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801d9d8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d9da:	2b00      	cmp	r3, #0
 801d9dc:	bfdc      	itt	le
 801d9de:	425b      	negle	r3, r3
 801d9e0:	fb01 fb03 	mulle.w	fp, r1, r3
 801d9e4:	e9dd 150b 	ldrd	r1, r5, [sp, #44]	; 0x2c
      for (i = N; i > 0 && i--;) {
 801d9e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801d9ea:	bfc8      	it	gt
 801d9ec:	f04f 0b00 	movgt.w	fp, #0
 801d9f0:	fb01 b005 	mla	r0, r1, r5, fp
      for (i = N; i > 0 && i--;) {
 801d9f4:	2b00      	cmp	r3, #0
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801d9f6:	9018      	str	r0, [sp, #96]	; 0x60
      for (i = N; i > 0 && i--;) {
 801d9f8:	ddb3      	ble.n	801d962 <cblas_zhemv+0x2ba>
 801d9fa:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 801d9fc:	9e05      	ldr	r6, [sp, #20]
 801d9fe:	eb07 1808 	add.w	r8, r7, r8, lsl #4
 801da02:	f108 0308 	add.w	r3, r8, #8
 801da06:	930a      	str	r3, [sp, #40]	; 0x28
 801da08:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801da0a:	4634      	mov	r4, r6
 801da0c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801da10:	fb01 f404 	mul.w	r4, r1, r4
 801da14:	9310      	str	r3, [sp, #64]	; 0x40
 801da16:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801da18:	eb01 0e04 	add.w	lr, r1, r4
 801da1c:	ea6f 0c06 	mvn.w	ip, r6
 801da20:	ebc6 7706 	rsb	r7, r6, r6, lsl #28
 801da24:	eb03 120e 	add.w	r2, r3, lr, lsl #4
 801da28:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801da2a:	9918      	ldr	r1, [sp, #96]	; 0x60
 801da2c:	9200      	str	r2, [sp, #0]
 801da2e:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801da32:	930e      	str	r3, [sp, #56]	; 0x38
 801da34:	ea4f 130c 	mov.w	r3, ip, lsl #4
 801da38:	ebc6 7606 	rsb	r6, r6, r6, lsl #28
 801da3c:	9313      	str	r3, [sp, #76]	; 0x4c
 801da3e:	013b      	lsls	r3, r7, #4
 801da40:	9314      	str	r3, [sp, #80]	; 0x50
 801da42:	0133      	lsls	r3, r6, #4
 801da44:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801da46:	9316      	str	r3, [sp, #88]	; 0x58
 801da48:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 801da4c:	9d15      	ldr	r5, [sp, #84]	; 0x54
 801da4e:	0133      	lsls	r3, r6, #4
 801da50:	eb05 1101 	add.w	r1, r5, r1, lsl #4
 801da54:	9304      	str	r3, [sp, #16]
 801da56:	0103      	lsls	r3, r0, #4
 801da58:	eb05 150b 	add.w	r5, r5, fp, lsl #4
 801da5c:	9317      	str	r3, [sp, #92]	; 0x5c
 801da5e:	f101 0308 	add.w	r3, r1, #8
 801da62:	930d      	str	r3, [sp, #52]	; 0x34
 801da64:	9511      	str	r5, [sp, #68]	; 0x44
 801da66:	f105 0308 	add.w	r3, r5, #8
 801da6a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801da6c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801da6e:	930f      	str	r3, [sp, #60]	; 0x3c
 801da70:	012b      	lsls	r3, r5, #4
 801da72:	9119      	str	r1, [sp, #100]	; 0x64
 801da74:	9305      	str	r3, [sp, #20]
        BASE x_real = CONST_REAL(X, ix);
 801da76:	9c0a      	ldr	r4, [sp, #40]	; 0x28
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801da78:	ed9d 8b06 	vldr	d8, [sp, #24]
        BASE x_real = CONST_REAL(X, ix);
 801da7c:	e954 6702 	ldrd	r6, r7, [r4, #-8]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801da80:	ec51 0b18 	vmov	r0, r1, d8
 801da84:	4632      	mov	r2, r6
 801da86:	463b      	mov	r3, r7
 801da88:	f00b f86e 	bl	8028b68 <__aeabi_dmul>
        BASE x_imag = CONST_IMAG(X, ix);
 801da8c:	e9d4 8900 	ldrd	r8, r9, [r4]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801da90:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 801da94:	4642      	mov	r2, r8
 801da96:	464b      	mov	r3, r9
 801da98:	4604      	mov	r4, r0
 801da9a:	460d      	mov	r5, r1
 801da9c:	4650      	mov	r0, sl
 801da9e:	4659      	mov	r1, fp
 801daa0:	f00b f862 	bl	8028b68 <__aeabi_dmul>
 801daa4:	4602      	mov	r2, r0
 801daa6:	460b      	mov	r3, r1
 801daa8:	4620      	mov	r0, r4
 801daaa:	4629      	mov	r1, r5
 801daac:	f00a fea4 	bl	80287f8 <__aeabi_dsub>
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801dab0:	4642      	mov	r2, r8
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801dab2:	4604      	mov	r4, r0
 801dab4:	460d      	mov	r5, r1
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801dab6:	464b      	mov	r3, r9
 801dab8:	ec51 0b18 	vmov	r0, r1, d8
 801dabc:	f00b f854 	bl	8028b68 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801dac0:	46a0      	mov	r8, r4
 801dac2:	46a9      	mov	r9, r5
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801dac4:	4632      	mov	r2, r6
 801dac6:	463b      	mov	r3, r7
 801dac8:	4604      	mov	r4, r0
 801daca:	460d      	mov	r5, r1
 801dacc:	4650      	mov	r0, sl
 801dace:	4659      	mov	r1, fp
 801dad0:	f00b f84a 	bl	8028b68 <__aeabi_dmul>
 801dad4:	4602      	mov	r2, r0
 801dad6:	460b      	mov	r3, r1
 801dad8:	4620      	mov	r0, r4
 801dada:	4629      	mov	r1, r5
 801dadc:	f00a fe8e 	bl	80287fc <__adddf3>
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 801dae0:	9b00      	ldr	r3, [sp, #0]
 801dae2:	e9d3 4500 	ldrd	r4, r5, [r3]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801dae6:	4606      	mov	r6, r0
 801dae8:	460f      	mov	r7, r1
        REAL(Y, iy) += temp1_real * Aii_real;
 801daea:	4640      	mov	r0, r8
 801daec:	4649      	mov	r1, r9
 801daee:	4622      	mov	r2, r4
 801daf0:	462b      	mov	r3, r5
 801daf2:	f00b f839 	bl	8028b68 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801daf6:	ec49 8b1d 	vmov	d13, r8, r9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801dafa:	46b9      	mov	r9, r7
        REAL(Y, iy) += temp1_real * Aii_real;
 801dafc:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801dafe:	4602      	mov	r2, r0
 801db00:	460b      	mov	r3, r1
 801db02:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 801db06:	f00a fe79 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801db0a:	4622      	mov	r2, r4
        REAL(Y, iy) += temp1_real * Aii_real;
 801db0c:	e947 0102 	strd	r0, r1, [r7, #-8]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801db10:	462b      	mov	r3, r5
 801db12:	4630      	mov	r0, r6
 801db14:	4649      	mov	r1, r9
 801db16:	f00b f827 	bl	8028b68 <__aeabi_dmul>
 801db1a:	460b      	mov	r3, r1
 801db1c:	4602      	mov	r2, r0
 801db1e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801db22:	f00a fe6b 	bl	80287fc <__adddf3>
        for (j = j_min; j < j_max; j++) {
 801db26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801db28:	46b0      	mov	r8, r6
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801db2a:	e9c7 0100 	strd	r0, r1, [r7]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801db2e:	ec49 8b1e 	vmov	d14, r8, r9
        for (j = j_min; j < j_max; j++) {
 801db32:	2b00      	cmp	r3, #0
 801db34:	f000 82ce 	beq.w	801e0d4 <cblas_zhemv+0xa2c>
 801db38:	9812      	ldr	r0, [sp, #72]	; 0x48
 801db3a:	f00a ffab 	bl	8028a94 <__aeabi_i2d>
        BASE temp2_imag = 0.0;
 801db3e:	ed9f 7b8e 	vldr	d7, [pc, #568]	; 801dd78 <cblas_zhemv+0x6d0>
        for (j = j_min; j < j_max; j++) {
 801db42:	e9dd 450f 	ldrd	r4, r5, [sp, #60]	; 0x3c
        BASE temp2_imag = 0.0;
 801db46:	eeb0 ca47 	vmov.f32	s24, s14
 801db4a:	eef0 ca67 	vmov.f32	s25, s15
        BASE temp2_real = 0.0;
 801db4e:	eeb0 ba47 	vmov.f32	s22, s14
 801db52:	eef0 ba67 	vmov.f32	s23, s15
 801db56:	ec41 0b1f 	vmov	d15, r0, r1
        for (j = j_min; j < j_max; j++) {
 801db5a:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
 801db5e:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801db62:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 801db66:	ec51 0b1f 	vmov	r0, r1, d15
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 801db6a:	e9da 8900 	ldrd	r8, r9, [sl]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801db6e:	f00a fffb 	bl	8028b68 <__aeabi_dmul>
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801db72:	4642      	mov	r2, r8
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801db74:	4606      	mov	r6, r0
 801db76:	460f      	mov	r7, r1
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801db78:	464b      	mov	r3, r9
 801db7a:	ec51 0b1d 	vmov	r0, r1, d13
 801db7e:	f00a fff3 	bl	8028b68 <__aeabi_dmul>
 801db82:	4632      	mov	r2, r6
 801db84:	ec41 0b1a 	vmov	d10, r0, r1
 801db88:	463b      	mov	r3, r7
 801db8a:	ec51 0b1e 	vmov	r0, r1, d14
 801db8e:	f00a ffeb 	bl	8028b68 <__aeabi_dmul>
 801db92:	4602      	mov	r2, r0
 801db94:	460b      	mov	r3, r1
 801db96:	ec51 0b1a 	vmov	r0, r1, d10
 801db9a:	f00a fe2f 	bl	80287fc <__adddf3>
 801db9e:	4602      	mov	r2, r0
 801dba0:	460b      	mov	r3, r1
 801dba2:	e954 0102 	ldrd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801dba6:	9602      	str	r6, [sp, #8]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801dba8:	f00a fe28 	bl	80287fc <__adddf3>
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801dbac:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 801dbb0:	9303      	str	r3, [sp, #12]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801dbb2:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801dbb6:	ec53 2b1d 	vmov	r2, r3, d13
 801dbba:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801dbbe:	f00a ffd3 	bl	8028b68 <__aeabi_dmul>
 801dbc2:	4642      	mov	r2, r8
 801dbc4:	ec41 0b19 	vmov	d9, r0, r1
 801dbc8:	464b      	mov	r3, r9
 801dbca:	ec51 0b1e 	vmov	r0, r1, d14
 801dbce:	f00a ffcb 	bl	8028b68 <__aeabi_dmul>
 801dbd2:	4602      	mov	r2, r0
 801dbd4:	460b      	mov	r3, r1
 801dbd6:	ec51 0b19 	vmov	r0, r1, d9
 801dbda:	f00a fe0f 	bl	80287fc <__adddf3>
 801dbde:	4602      	mov	r2, r0
 801dbe0:	460b      	mov	r3, r1
 801dbe2:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801dbe6:	f00a fe09 	bl	80287fc <__adddf3>
 801dbea:	e9cb 0102 	strd	r0, r1, [fp, #8]
          x_real = CONST_REAL(X, jx);
 801dbee:	ed95 7b00 	vldr	d7, [r5]
          x_imag = CONST_IMAG(X, jx);
 801dbf2:	ed95 6b02 	vldr	d6, [r5, #8]
          x_real = CONST_REAL(X, jx);
 801dbf6:	eeb0 9a47 	vmov.f32	s18, s14
 801dbfa:	eef0 9a67 	vmov.f32	s19, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801dbfe:	ec53 2b17 	vmov	r2, r3, d7
          x_imag = CONST_IMAG(X, jx);
 801dc02:	eeb0 8a46 	vmov.f32	s16, s12
 801dc06:	eef0 8a66 	vmov.f32	s17, s13
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801dc0a:	4640      	mov	r0, r8
 801dc0c:	4649      	mov	r1, r9
 801dc0e:	f00a ffab 	bl	8028b68 <__aeabi_dmul>
 801dc12:	ec53 2b18 	vmov	r2, r3, d8
 801dc16:	ec41 0b1a 	vmov	d10, r0, r1
 801dc1a:	4630      	mov	r0, r6
 801dc1c:	4639      	mov	r1, r7
 801dc1e:	f00a ffa3 	bl	8028b68 <__aeabi_dmul>
 801dc22:	4602      	mov	r2, r0
 801dc24:	460b      	mov	r3, r1
 801dc26:	ec51 0b1a 	vmov	r0, r1, d10
 801dc2a:	f00a fde5 	bl	80287f8 <__aeabi_dsub>
 801dc2e:	4602      	mov	r2, r0
 801dc30:	460b      	mov	r3, r1
 801dc32:	ec51 0b1b 	vmov	r0, r1, d11
 801dc36:	f00a fde1 	bl	80287fc <__adddf3>
 801dc3a:	ec41 0b17 	vmov	d7, r0, r1
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801dc3e:	ec53 2b19 	vmov	r2, r3, d9
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801dc42:	eeb0 ba47 	vmov.f32	s22, s14
 801dc46:	eef0 ba67 	vmov.f32	s23, s15
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801dc4a:	4630      	mov	r0, r6
 801dc4c:	4639      	mov	r1, r7
 801dc4e:	f00a ff8b 	bl	8028b68 <__aeabi_dmul>
 801dc52:	ec53 2b18 	vmov	r2, r3, d8
 801dc56:	4606      	mov	r6, r0
 801dc58:	460f      	mov	r7, r1
 801dc5a:	4640      	mov	r0, r8
 801dc5c:	4649      	mov	r1, r9
 801dc5e:	f00a ff83 	bl	8028b68 <__aeabi_dmul>
 801dc62:	4602      	mov	r2, r0
 801dc64:	460b      	mov	r3, r1
 801dc66:	4630      	mov	r0, r6
 801dc68:	4639      	mov	r1, r7
 801dc6a:	f00a fdc7 	bl	80287fc <__adddf3>
 801dc6e:	460b      	mov	r3, r1
 801dc70:	4602      	mov	r2, r0
 801dc72:	ec51 0b1c 	vmov	r0, r1, d12
 801dc76:	f00a fdc1 	bl	80287fc <__adddf3>
 801dc7a:	9b05      	ldr	r3, [sp, #20]
 801dc7c:	441c      	add	r4, r3
 801dc7e:	449b      	add	fp, r3
 801dc80:	9b04      	ldr	r3, [sp, #16]
 801dc82:	441d      	add	r5, r3
        for (j = j_min; j < j_max; j++) {
 801dc84:	9b00      	ldr	r3, [sp, #0]
 801dc86:	f10a 0a10 	add.w	sl, sl, #16
 801dc8a:	4553      	cmp	r3, sl
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801dc8c:	ec41 0b1c 	vmov	d12, r0, r1
        for (j = j_min; j < j_max; j++) {
 801dc90:	f47f af67 	bne.w	801db62 <cblas_zhemv+0x4ba>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801dc94:	ed9d 8b06 	vldr	d8, [sp, #24]
 801dc98:	ec53 2b1b 	vmov	r2, r3, d11
 801dc9c:	ec51 0b18 	vmov	r0, r1, d8
 801dca0:	f00a ff62 	bl	8028b68 <__aeabi_dmul>
 801dca4:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 801dca8:	ec5a 9b1c 	vmov	r9, sl, d12
 801dcac:	4604      	mov	r4, r0
 801dcae:	460d      	mov	r5, r1
 801dcb0:	ee1c 2a10 	vmov	r2, s24
 801dcb4:	4653      	mov	r3, sl
 801dcb6:	4638      	mov	r0, r7
 801dcb8:	4641      	mov	r1, r8
 801dcba:	f00a ff55 	bl	8028b68 <__aeabi_dmul>
 801dcbe:	4602      	mov	r2, r0
 801dcc0:	460b      	mov	r3, r1
 801dcc2:	4620      	mov	r0, r4
 801dcc4:	4629      	mov	r1, r5
 801dcc6:	f00a fd97 	bl	80287f8 <__aeabi_dsub>
 801dcca:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801dccc:	4602      	mov	r2, r0
 801dcce:	460b      	mov	r3, r1
 801dcd0:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 801dcd4:	f00a fd92 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801dcd8:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801dcdc:	e946 0102 	strd	r0, r1, [r6, #-8]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801dce0:	4638      	mov	r0, r7
 801dce2:	4641      	mov	r1, r8
 801dce4:	f00a ff40 	bl	8028b68 <__aeabi_dmul>
 801dce8:	ee1c 2a10 	vmov	r2, s24
 801dcec:	4653      	mov	r3, sl
 801dcee:	4604      	mov	r4, r0
 801dcf0:	460d      	mov	r5, r1
 801dcf2:	ec51 0b18 	vmov	r0, r1, d8
 801dcf6:	f00a ff37 	bl	8028b68 <__aeabi_dmul>
 801dcfa:	4602      	mov	r2, r0
 801dcfc:	460b      	mov	r3, r1
 801dcfe:	4620      	mov	r0, r4
 801dd00:	4629      	mov	r1, r5
 801dd02:	f00a fd7b 	bl	80287fc <__adddf3>
 801dd06:	4602      	mov	r2, r0
 801dd08:	460b      	mov	r3, r1
 801dd0a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801dd0e:	f00a fd75 	bl	80287fc <__adddf3>
 801dd12:	9b00      	ldr	r3, [sp, #0]
 801dd14:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801dd16:	4413      	add	r3, r2
 801dd18:	9300      	str	r3, [sp, #0]
 801dd1a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801dd1c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801dd1e:	4413      	add	r3, r2
 801dd20:	930e      	str	r3, [sp, #56]	; 0x38
 801dd22:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801dd24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801dd26:	4413      	add	r3, r2
 801dd28:	930a      	str	r3, [sp, #40]	; 0x28
 801dd2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dd2c:	3b01      	subs	r3, #1
 801dd2e:	930b      	str	r3, [sp, #44]	; 0x2c
 801dd30:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801dd32:	18f3      	adds	r3, r6, r3
 801dd34:	e9c6 0100 	strd	r0, r1, [r6]
      for (i = N; i > 0 && i--;) {
 801dd38:	930d      	str	r3, [sp, #52]	; 0x34
 801dd3a:	e69c      	b.n	801da76 <cblas_zhemv+0x3ce>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801dd3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dd3e:	2b7a      	cmp	r3, #122	; 0x7a
 801dd40:	d01e      	beq.n	801dd80 <cblas_zhemv+0x6d8>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 801dd42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dd44:	2b79      	cmp	r3, #121	; 0x79
 801dd46:	f47f ad81 	bne.w	801d84c <cblas_zhemv+0x1a4>
 801dd4a:	e633      	b.n	801d9b4 <cblas_zhemv+0x30c>
      INDEX iy = OFFSET(N, incY);
 801dd4c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801dd4e:	f1c2 0a01 	rsb	sl, r2, #1
 801dd52:	fb0a fa03 	mul.w	sl, sl, r3
 801dd56:	e51e      	b.n	801d796 <cblas_zhemv+0xee>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801dd58:	ec51 0b18 	vmov	r0, r1, d8
 801dd5c:	f00b f96c 	bl	8029038 <__aeabi_dcmpeq>
 801dd60:	2800      	cmp	r0, #0
 801dd62:	f47f ad84 	bne.w	801d86e <cblas_zhemv+0x1c6>
 801dd66:	e510      	b.n	801d78a <cblas_zhemv+0xe2>
      INDEX iy = OFFSET(N, incY);
 801dd68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801dd6a:	f1c3 0301 	rsb	r3, r3, #1
 801dd6e:	fb03 f302 	mul.w	r3, r3, r2
 801dd72:	e589      	b.n	801d888 <cblas_zhemv+0x1e0>
 801dd74:	f3af 8000 	nop.w
	...
      INDEX ix = OFFSET(N, incX);
 801dd80:	9b0d      	ldr	r3, [sp, #52]	; 0x34
      INDEX iy = OFFSET(N, incY);
 801dd82:	990c      	ldr	r1, [sp, #48]	; 0x30
      for (i = 0; i < N; i++) {
 801dd84:	980a      	ldr	r0, [sp, #40]	; 0x28
      INDEX ix = OFFSET(N, incX);
 801dd86:	2b00      	cmp	r3, #0
 801dd88:	bfdd      	ittte	le
 801dd8a:	9a0a      	ldrle	r2, [sp, #40]	; 0x28
 801dd8c:	f1c2 0201 	rsble	r2, r2, #1
 801dd90:	435a      	mulle	r2, r3
 801dd92:	2200      	movgt	r2, #0
      INDEX iy = OFFSET(N, incY);
 801dd94:	2900      	cmp	r1, #0
 801dd96:	bfdd      	ittte	le
 801dd98:	9b0a      	ldrle	r3, [sp, #40]	; 0x28
 801dd9a:	f1c3 0301 	rsble	r3, r3, #1
 801dd9e:	434b      	mulle	r3, r1
 801dda0:	2300      	movgt	r3, #0
      for (i = 0; i < N; i++) {
 801dda2:	2800      	cmp	r0, #0
      INDEX iy = OFFSET(N, incY);
 801dda4:	9318      	str	r3, [sp, #96]	; 0x60
      for (i = 0; i < N; i++) {
 801dda6:	f77f addc 	ble.w	801d962 <cblas_zhemv+0x2ba>
 801ddaa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801ddac:	9d18      	ldr	r5, [sp, #96]	; 0x60
 801ddae:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801ddb0:	930b      	str	r3, [sp, #44]	; 0x2c
 801ddb2:	f1a3 0110 	sub.w	r1, r3, #16
 801ddb6:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 801ddba:	9102      	str	r1, [sp, #8]
 801ddbc:	9915      	ldr	r1, [sp, #84]	; 0x54
 801ddbe:	9f05      	ldr	r7, [sp, #20]
 801ddc0:	19ab      	adds	r3, r5, r6
 801ddc2:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 801ddc6:	9310      	str	r3, [sp, #64]	; 0x40
 801ddc8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801ddca:	18d0      	adds	r0, r2, r3
 801ddcc:	3701      	adds	r7, #1
 801ddce:	011b      	lsls	r3, r3, #4
 801ddd0:	9011      	str	r0, [sp, #68]	; 0x44
 801ddd2:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801ddd4:	9305      	str	r3, [sp, #20]
 801ddd6:	013c      	lsls	r4, r7, #4
 801ddd8:	0133      	lsls	r3, r6, #4
 801ddda:	9417      	str	r4, [sp, #92]	; 0x5c
 801dddc:	eb00 1202 	add.w	r2, r0, r2, lsl #4
 801dde0:	3c10      	subs	r4, #16
 801dde2:	9304      	str	r3, [sp, #16]
 801dde4:	eb01 1305 	add.w	r3, r1, r5, lsl #4
 801dde8:	9416      	str	r4, [sp, #88]	; 0x58
 801ddea:	920f      	str	r2, [sp, #60]	; 0x3c
 801ddec:	930e      	str	r3, [sp, #56]	; 0x38
 801ddee:	f04f 0a00 	mov.w	sl, #0
        BASE x_real = CONST_REAL(X, ix);
 801ddf2:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801ddf4:	ed9d 9b06 	vldr	d9, [sp, #24]
        BASE x_real = CONST_REAL(X, ix);
 801ddf8:	e9d4 6700 	ldrd	r6, r7, [r4]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801ddfc:	ec51 0b19 	vmov	r0, r1, d9
 801de00:	4632      	mov	r2, r6
 801de02:	463b      	mov	r3, r7
 801de04:	f00a feb0 	bl	8028b68 <__aeabi_dmul>
        BASE x_imag = CONST_IMAG(X, ix);
 801de08:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801de0c:	ed9d 8b08 	vldr	d8, [sp, #32]
 801de10:	4642      	mov	r2, r8
 801de12:	464b      	mov	r3, r9
 801de14:	4604      	mov	r4, r0
 801de16:	460d      	mov	r5, r1
 801de18:	ec51 0b18 	vmov	r0, r1, d8
 801de1c:	f00a fea4 	bl	8028b68 <__aeabi_dmul>
 801de20:	4602      	mov	r2, r0
 801de22:	460b      	mov	r3, r1
 801de24:	4620      	mov	r0, r4
 801de26:	4629      	mov	r1, r5
 801de28:	f00a fce6 	bl	80287f8 <__aeabi_dsub>
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801de2c:	4642      	mov	r2, r8
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801de2e:	4604      	mov	r4, r0
 801de30:	460d      	mov	r5, r1
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801de32:	464b      	mov	r3, r9
 801de34:	ec51 0b19 	vmov	r0, r1, d9
 801de38:	f00a fe96 	bl	8028b68 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801de3c:	46a0      	mov	r8, r4
 801de3e:	46a9      	mov	r9, r5
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801de40:	4632      	mov	r2, r6
 801de42:	463b      	mov	r3, r7
 801de44:	4604      	mov	r4, r0
 801de46:	460d      	mov	r5, r1
 801de48:	ec51 0b18 	vmov	r0, r1, d8
 801de4c:	f00a fe8c 	bl	8028b68 <__aeabi_dmul>
 801de50:	4602      	mov	r2, r0
 801de52:	460b      	mov	r3, r1
 801de54:	4620      	mov	r0, r4
 801de56:	4629      	mov	r1, r5
 801de58:	f00a fcd0 	bl	80287fc <__adddf3>
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 801de5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801de5e:	e9d3 4500 	ldrd	r4, r5, [r3]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801de62:	4606      	mov	r6, r0
 801de64:	460f      	mov	r7, r1
        REAL(Y, iy) += temp1_real * Aii_real;
 801de66:	4640      	mov	r0, r8
 801de68:	4649      	mov	r1, r9
 801de6a:	4622      	mov	r2, r4
 801de6c:	462b      	mov	r3, r5
 801de6e:	f00a fe7b 	bl	8028b68 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801de72:	ec49 8b1d 	vmov	d13, r8, r9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801de76:	46b9      	mov	r9, r7
        REAL(Y, iy) += temp1_real * Aii_real;
 801de78:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 801de7a:	4602      	mov	r2, r0
 801de7c:	460b      	mov	r3, r1
 801de7e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801de82:	f00a fcbb 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801de86:	4622      	mov	r2, r4
        REAL(Y, iy) += temp1_real * Aii_real;
 801de88:	e9c7 0100 	strd	r0, r1, [r7]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801de8c:	462b      	mov	r3, r5
 801de8e:	4630      	mov	r0, r6
 801de90:	4649      	mov	r1, r9
 801de92:	f00a fe69 	bl	8028b68 <__aeabi_dmul>
 801de96:	4602      	mov	r2, r0
 801de98:	460b      	mov	r3, r1
 801de9a:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801de9e:	f00a fcad 	bl	80287fc <__adddf3>
        for (j = j_min; j < j_max; j++) {
 801dea2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        const INDEX j_min = i + 1;
 801dea4:	f10a 0301 	add.w	r3, sl, #1
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801dea8:	46b0      	mov	r8, r6
        for (j = j_min; j < j_max; j++) {
 801deaa:	429a      	cmp	r2, r3
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801deac:	e9c7 0102 	strd	r0, r1, [r7, #8]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801deb0:	ec49 8b1e 	vmov	d14, r8, r9
        const INDEX j_min = i + 1;
 801deb4:	9314      	str	r3, [sp, #80]	; 0x50
        for (j = j_min; j < j_max; j++) {
 801deb6:	f43f ad20 	beq.w	801d8fa <cblas_zhemv+0x252>
 801deba:	9812      	ldr	r0, [sp, #72]	; 0x48
 801debc:	f00a fdea 	bl	8028a94 <__aeabi_i2d>
 801dec0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801dec2:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 801dec6:	ec41 0b1f 	vmov	d15, r0, r1
 801deca:	9911      	ldr	r1, [sp, #68]	; 0x44
        BASE temp2_imag = 0.0;
 801decc:	ed1f 7b56 	vldr	d7, [pc, #-344]	; 801dd78 <cblas_zhemv+0x6d0>
 801ded0:	eb02 1b01 	add.w	fp, r2, r1, lsl #4
 801ded4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801ded6:	eeb0 ca47 	vmov.f32	s24, s14
 801deda:	eef0 ca67 	vmov.f32	s25, s15
 801dede:	f102 0408 	add.w	r4, r2, #8
        for (j = j_min; j < j_max; j++) {
 801dee2:	4615      	mov	r5, r2
        BASE temp2_real = 0.0;
 801dee4:	eeb0 ba47 	vmov.f32	s22, s14
 801dee8:	eef0 ba67 	vmov.f32	s23, s15
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801deec:	e9da 2306 	ldrd	r2, r3, [sl, #24]
 801def0:	ec51 0b1f 	vmov	r0, r1, d15
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 801def4:	e9da 8904 	ldrd	r8, r9, [sl, #16]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801def8:	f00a fe36 	bl	8028b68 <__aeabi_dmul>
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801defc:	4642      	mov	r2, r8
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801defe:	4606      	mov	r6, r0
 801df00:	460f      	mov	r7, r1
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801df02:	464b      	mov	r3, r9
 801df04:	ec51 0b1d 	vmov	r0, r1, d13
 801df08:	f00a fe2e 	bl	8028b68 <__aeabi_dmul>
 801df0c:	4632      	mov	r2, r6
 801df0e:	ec41 0b1a 	vmov	d10, r0, r1
 801df12:	463b      	mov	r3, r7
 801df14:	ec51 0b1e 	vmov	r0, r1, d14
 801df18:	f00a fe26 	bl	8028b68 <__aeabi_dmul>
 801df1c:	4602      	mov	r2, r0
 801df1e:	460b      	mov	r3, r1
 801df20:	ec51 0b1a 	vmov	r0, r1, d10
 801df24:	f00a fc6a 	bl	80287fc <__adddf3>
 801df28:	4602      	mov	r2, r0
 801df2a:	460b      	mov	r3, r1
 801df2c:	e954 0102 	ldrd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801df30:	9600      	str	r6, [sp, #0]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801df32:	f00a fc63 	bl	80287fc <__adddf3>
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801df36:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 801df3a:	9301      	str	r3, [sp, #4]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801df3c:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801df40:	ec53 2b1d 	vmov	r2, r3, d13
 801df44:	e9dd 0100 	ldrd	r0, r1, [sp]
 801df48:	f00a fe0e 	bl	8028b68 <__aeabi_dmul>
 801df4c:	4642      	mov	r2, r8
 801df4e:	ec41 0b19 	vmov	d9, r0, r1
 801df52:	464b      	mov	r3, r9
 801df54:	ec51 0b1e 	vmov	r0, r1, d14
 801df58:	f00a fe06 	bl	8028b68 <__aeabi_dmul>
 801df5c:	4602      	mov	r2, r0
 801df5e:	460b      	mov	r3, r1
 801df60:	ec51 0b19 	vmov	r0, r1, d9
 801df64:	f00a fc4a 	bl	80287fc <__adddf3>
 801df68:	4602      	mov	r2, r0
 801df6a:	460b      	mov	r3, r1
 801df6c:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 801df70:	f00a fc44 	bl	80287fc <__adddf3>
 801df74:	e9c5 0102 	strd	r0, r1, [r5, #8]
          x_real = CONST_REAL(X, jx);
 801df78:	ed9b 7b00 	vldr	d7, [fp]
          x_imag = CONST_IMAG(X, jx);
 801df7c:	ed9b 6b02 	vldr	d6, [fp, #8]
          x_real = CONST_REAL(X, jx);
 801df80:	eeb0 9a47 	vmov.f32	s18, s14
 801df84:	eef0 9a67 	vmov.f32	s19, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801df88:	ec53 2b17 	vmov	r2, r3, d7
          x_imag = CONST_IMAG(X, jx);
 801df8c:	eeb0 8a46 	vmov.f32	s16, s12
 801df90:	eef0 8a66 	vmov.f32	s17, s13
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801df94:	4640      	mov	r0, r8
 801df96:	4649      	mov	r1, r9
 801df98:	f00a fde6 	bl	8028b68 <__aeabi_dmul>
 801df9c:	ec53 2b18 	vmov	r2, r3, d8
 801dfa0:	ec41 0b1a 	vmov	d10, r0, r1
 801dfa4:	4630      	mov	r0, r6
 801dfa6:	4639      	mov	r1, r7
 801dfa8:	f00a fdde 	bl	8028b68 <__aeabi_dmul>
 801dfac:	4602      	mov	r2, r0
 801dfae:	460b      	mov	r3, r1
 801dfb0:	ec51 0b1a 	vmov	r0, r1, d10
 801dfb4:	f00a fc20 	bl	80287f8 <__aeabi_dsub>
 801dfb8:	4602      	mov	r2, r0
 801dfba:	460b      	mov	r3, r1
 801dfbc:	ec51 0b1b 	vmov	r0, r1, d11
 801dfc0:	f00a fc1c 	bl	80287fc <__adddf3>
 801dfc4:	ec41 0b17 	vmov	d7, r0, r1
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801dfc8:	ec53 2b19 	vmov	r2, r3, d9
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801dfcc:	eeb0 ba47 	vmov.f32	s22, s14
 801dfd0:	eef0 ba67 	vmov.f32	s23, s15
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801dfd4:	4630      	mov	r0, r6
 801dfd6:	4639      	mov	r1, r7
 801dfd8:	f00a fdc6 	bl	8028b68 <__aeabi_dmul>
 801dfdc:	ec53 2b18 	vmov	r2, r3, d8
 801dfe0:	4606      	mov	r6, r0
 801dfe2:	460f      	mov	r7, r1
 801dfe4:	4640      	mov	r0, r8
 801dfe6:	4649      	mov	r1, r9
 801dfe8:	f00a fdbe 	bl	8028b68 <__aeabi_dmul>
 801dfec:	4602      	mov	r2, r0
 801dfee:	460b      	mov	r3, r1
 801dff0:	4630      	mov	r0, r6
 801dff2:	4639      	mov	r1, r7
 801dff4:	f00a fc02 	bl	80287fc <__adddf3>
 801dff8:	460b      	mov	r3, r1
 801dffa:	4602      	mov	r2, r0
 801dffc:	ec51 0b1c 	vmov	r0, r1, d12
 801e000:	f00a fbfc 	bl	80287fc <__adddf3>
 801e004:	9b04      	ldr	r3, [sp, #16]
 801e006:	441c      	add	r4, r3
 801e008:	441d      	add	r5, r3
 801e00a:	9b05      	ldr	r3, [sp, #20]
 801e00c:	449b      	add	fp, r3
        for (j = j_min; j < j_max; j++) {
 801e00e:	9b02      	ldr	r3, [sp, #8]
 801e010:	f10a 0a10 	add.w	sl, sl, #16
 801e014:	4553      	cmp	r3, sl
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801e016:	ec41 0b1c 	vmov	d12, r0, r1
        for (j = j_min; j < j_max; j++) {
 801e01a:	f47f af67 	bne.w	801deec <cblas_zhemv+0x844>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801e01e:	ed9d 8b06 	vldr	d8, [sp, #24]
 801e022:	ec53 2b1b 	vmov	r2, r3, d11
 801e026:	ec51 0b18 	vmov	r0, r1, d8
 801e02a:	f00a fd9d 	bl	8028b68 <__aeabi_dmul>
 801e02e:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 801e032:	ec5a 9b1c 	vmov	r9, sl, d12
 801e036:	4604      	mov	r4, r0
 801e038:	4653      	mov	r3, sl
 801e03a:	460d      	mov	r5, r1
 801e03c:	ee1c 2a10 	vmov	r2, s24
 801e040:	4638      	mov	r0, r7
 801e042:	4641      	mov	r1, r8
 801e044:	f00a fd90 	bl	8028b68 <__aeabi_dmul>
 801e048:	4602      	mov	r2, r0
 801e04a:	460b      	mov	r3, r1
 801e04c:	4620      	mov	r0, r4
 801e04e:	4629      	mov	r1, r5
 801e050:	f00a fbd2 	bl	80287f8 <__aeabi_dsub>
 801e054:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 801e056:	4602      	mov	r2, r0
 801e058:	460b      	mov	r3, r1
 801e05a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801e05e:	f00a fbcd 	bl	80287fc <__adddf3>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801e062:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801e066:	e9c6 0100 	strd	r0, r1, [r6]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801e06a:	4638      	mov	r0, r7
 801e06c:	4641      	mov	r1, r8
 801e06e:	f00a fd7b 	bl	8028b68 <__aeabi_dmul>
 801e072:	4653      	mov	r3, sl
 801e074:	460d      	mov	r5, r1
 801e076:	ee1c 2a10 	vmov	r2, s24
 801e07a:	4604      	mov	r4, r0
 801e07c:	ec51 0b18 	vmov	r0, r1, d8
 801e080:	f00a fd72 	bl	8028b68 <__aeabi_dmul>
 801e084:	4602      	mov	r2, r0
 801e086:	460b      	mov	r3, r1
 801e088:	4620      	mov	r0, r4
 801e08a:	4629      	mov	r1, r5
 801e08c:	f00a fbb6 	bl	80287fc <__adddf3>
 801e090:	4602      	mov	r2, r0
 801e092:	460b      	mov	r3, r1
 801e094:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801e098:	f00a fbb0 	bl	80287fc <__adddf3>
 801e09c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801e09e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801e0a0:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
 801e0a4:	4413      	add	r3, r2
 801e0a6:	9311      	str	r3, [sp, #68]	; 0x44
 801e0a8:	9a05      	ldr	r2, [sp, #20]
 801e0aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801e0ac:	4413      	add	r3, r2
 801e0ae:	930f      	str	r3, [sp, #60]	; 0x3c
 801e0b0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801e0b2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e0b4:	4413      	add	r3, r2
 801e0b6:	930b      	str	r3, [sp, #44]	; 0x2c
 801e0b8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801e0ba:	9a04      	ldr	r2, [sp, #16]
 801e0bc:	461d      	mov	r5, r3
 801e0be:	4415      	add	r5, r2
 801e0c0:	9b02      	ldr	r3, [sp, #8]
 801e0c2:	9510      	str	r5, [sp, #64]	; 0x40
 801e0c4:	9d16      	ldr	r5, [sp, #88]	; 0x58
 801e0c6:	442b      	add	r3, r5
 801e0c8:	9302      	str	r3, [sp, #8]
 801e0ca:	18b3      	adds	r3, r6, r2
 801e0cc:	e9c6 0102 	strd	r0, r1, [r6, #8]
      for (i = 0; i < N; i++) {
 801e0d0:	930e      	str	r3, [sp, #56]	; 0x38
 801e0d2:	e68e      	b.n	801ddf2 <cblas_zhemv+0x74a>
 801e0d4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801e0d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801e0d8:	9918      	ldr	r1, [sp, #96]	; 0x60
 801e0da:	9e15      	ldr	r6, [sp, #84]	; 0x54
 801e0dc:	fb02 1513 	mls	r5, r2, r3, r1
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801e0e0:	2200      	movs	r2, #0
 801e0e2:	2300      	movs	r3, #0
 801e0e4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801e0e8:	f00a fd3e 	bl	8028b68 <__aeabi_dmul>
 801e0ec:	eb06 1405 	add.w	r4, r6, r5, lsl #4
 801e0f0:	460f      	mov	r7, r1
 801e0f2:	4606      	mov	r6, r0
 801e0f4:	2200      	movs	r2, #0
 801e0f6:	2300      	movs	r3, #0
 801e0f8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801e0fc:	f00a fd34 	bl	8028b68 <__aeabi_dmul>
 801e100:	4680      	mov	r8, r0
 801e102:	4689      	mov	r9, r1
 801e104:	4625      	mov	r5, r4
 801e106:	4630      	mov	r0, r6
 801e108:	4639      	mov	r1, r7
 801e10a:	4642      	mov	r2, r8
 801e10c:	464b      	mov	r3, r9
 801e10e:	e410      	b.n	801d932 <cblas_zhemv+0x28a>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801e110:	200b      	movs	r0, #11
 801e112:	f7ff baff 	b.w	801d714 <cblas_zhemv+0x6c>
 801e116:	bf00      	nop

0801e118 <cblas_zher>:

void
cblas_zher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const double alpha, const void *X, const int incX,
            void *A, const int lda)
{
 801e118:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e11c:	ed2d 8b0e 	vpush	{d8-d14}
 801e120:	eeb0 da40 	vmov.f32	s26, s0
 801e124:	eef0 da60 	vmov.f32	s27, s1
 801e128:	b091      	sub	sp, #68	; 0x44
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801e12a:	2866      	cmp	r0, #102	; 0x66
 801e12c:	460d      	mov	r5, r1
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801e12e:	f1a1 0179 	sub.w	r1, r1, #121	; 0x79
 801e132:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 801e134:	9305      	str	r3, [sp, #20]
 801e136:	4604      	mov	r4, r0
 801e138:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 801e13a:	9829      	ldr	r0, [sp, #164]	; 0xa4
 801e13c:	9203      	str	r2, [sp, #12]
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801e13e:	bf0c      	ite	eq
 801e140:	f04f 38ff 	moveq.w	r8, #4294967295
 801e144:	f04f 0801 	movne.w	r8, #1
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801e148:	2901      	cmp	r1, #1
 801e14a:	9304      	str	r3, [sp, #16]
 801e14c:	900b      	str	r0, [sp, #44]	; 0x2c
 801e14e:	9609      	str	r6, [sp, #36]	; 0x24
 801e150:	d935      	bls.n	801e1be <cblas_zher+0xa6>
 801e152:	2a00      	cmp	r2, #0
 801e154:	db0c      	blt.n	801e170 <cblas_zher+0x58>
 801e156:	2b00      	cmp	r3, #0
 801e158:	f040 8149 	bne.w	801e3ee <cblas_zher+0x2d6>
 801e15c:	9803      	ldr	r0, [sp, #12]
 801e15e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e160:	2801      	cmp	r0, #1
 801e162:	bfb8      	it	lt
 801e164:	2001      	movlt	r0, #1
 801e166:	4283      	cmp	r3, r0
 801e168:	bfb4      	ite	lt
 801e16a:	2008      	movlt	r0, #8
 801e16c:	2006      	movge	r0, #6
 801e16e:	e007      	b.n	801e180 <cblas_zher+0x68>
 801e170:	9b04      	ldr	r3, [sp, #16]
 801e172:	2b00      	cmp	r3, #0
 801e174:	d0f2      	beq.n	801e15c <cblas_zher+0x44>
 801e176:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e178:	2b00      	cmp	r3, #0
 801e17a:	bfd4      	ite	le
 801e17c:	2008      	movle	r0, #8
 801e17e:	2003      	movgt	r0, #3
 801e180:	4aa1      	ldr	r2, [pc, #644]	; (801e408 <cblas_zher+0x2f0>)
 801e182:	49a2      	ldr	r1, [pc, #648]	; (801e40c <cblas_zher+0x2f4>)
 801e184:	f00a fac0 	bl	8028708 <cblas_xerbla>
  if (alpha == 0.0)
 801e188:	ec51 0b1d 	vmov	r0, r1, d13
 801e18c:	2200      	movs	r2, #0
 801e18e:	2300      	movs	r3, #0
 801e190:	f00a ff52 	bl	8029038 <__aeabi_dcmpeq>
 801e194:	b970      	cbnz	r0, 801e1b4 <cblas_zher+0x9c>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 801e196:	2c65      	cmp	r4, #101	; 0x65
 801e198:	d026      	beq.n	801e1e8 <cblas_zher+0xd0>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 801e19a:	2c66      	cmp	r4, #102	; 0x66
 801e19c:	f000 8212 	beq.w	801e5c4 <cblas_zher+0x4ac>
    BLAS_ERROR("unrecognized operation");
 801e1a0:	4a9b      	ldr	r2, [pc, #620]	; (801e410 <cblas_zher+0x2f8>)
 801e1a2:	499a      	ldr	r1, [pc, #616]	; (801e40c <cblas_zher+0x2f4>)
 801e1a4:	2000      	movs	r0, #0
#define BASE double
#include "source_her.h"
#undef BASE
}
 801e1a6:	b011      	add	sp, #68	; 0x44
 801e1a8:	ecbd 8b0e 	vpop	{d8-d14}
 801e1ac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e1b0:	f00a baaa 	b.w	8028708 <cblas_xerbla>
 801e1b4:	b011      	add	sp, #68	; 0x44
 801e1b6:	ecbd 8b0e 	vpop	{d8-d14}
 801e1ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801e1be:	9b03      	ldr	r3, [sp, #12]
 801e1c0:	2b00      	cmp	r3, #0
 801e1c2:	dbd5      	blt.n	801e170 <cblas_zher+0x58>
 801e1c4:	9b04      	ldr	r3, [sp, #16]
 801e1c6:	2b00      	cmp	r3, #0
 801e1c8:	d0c8      	beq.n	801e15c <cblas_zher+0x44>
 801e1ca:	9b03      	ldr	r3, [sp, #12]
 801e1cc:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801e1ce:	2b01      	cmp	r3, #1
 801e1d0:	bfb8      	it	lt
 801e1d2:	2301      	movlt	r3, #1
 801e1d4:	4293      	cmp	r3, r2
 801e1d6:	f300 8203 	bgt.w	801e5e0 <cblas_zher+0x4c8>
 801e1da:	f1a4 0365 	sub.w	r3, r4, #101	; 0x65
 801e1de:	2b01      	cmp	r3, #1
 801e1e0:	bf88      	it	hi
 801e1e2:	2001      	movhi	r0, #1
 801e1e4:	d9d0      	bls.n	801e188 <cblas_zher+0x70>
 801e1e6:	e7cb      	b.n	801e180 <cblas_zher+0x68>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 801e1e8:	2d79      	cmp	r5, #121	; 0x79
 801e1ea:	f000 8113 	beq.w	801e414 <cblas_zher+0x2fc>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 801e1ee:	2d7a      	cmp	r5, #122	; 0x7a
 801e1f0:	d1d6      	bne.n	801e1a0 <cblas_zher+0x88>
    INDEX ix = OFFSET(N, incX);
 801e1f2:	9a04      	ldr	r2, [sp, #16]
 801e1f4:	2a00      	cmp	r2, #0
 801e1f6:	bfdd      	ittte	le
 801e1f8:	9b03      	ldrle	r3, [sp, #12]
 801e1fa:	f1c3 0301 	rsble	r3, r3, #1
 801e1fe:	4353      	mulle	r3, r2
 801e200:	2300      	movgt	r3, #0
 801e202:	9302      	str	r3, [sp, #8]
    for (i = 0; i < N; i++) {
 801e204:	9b03      	ldr	r3, [sp, #12]
 801e206:	2b00      	cmp	r3, #0
 801e208:	ddd4      	ble.n	801e1b4 <cblas_zher+0x9c>
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e20a:	9b05      	ldr	r3, [sp, #20]
 801e20c:	9a02      	ldr	r2, [sp, #8]
 801e20e:	eb03 1602 	add.w	r6, r3, r2, lsl #4
 801e212:	e9d6 4500 	ldrd	r4, r5, [r6]
 801e216:	ec5a 9b1d 	vmov	r9, sl, d13
 801e21a:	ee1d 2a10 	vmov	r2, s26
 801e21e:	4653      	mov	r3, sl
 801e220:	4620      	mov	r0, r4
 801e222:	4629      	mov	r1, r5
 801e224:	960d      	str	r6, [sp, #52]	; 0x34
 801e226:	f00a fc9f 	bl	8028b68 <__aeabi_dmul>
 801e22a:	4602      	mov	r2, r0
 801e22c:	460b      	mov	r3, r1
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e22e:	4640      	mov	r0, r8
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e230:	ec43 2b1a 	vmov	d10, r2, r3
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e234:	f00a fc2e 	bl	8028a94 <__aeabi_i2d>
 801e238:	4653      	mov	r3, sl
 801e23a:	ee1d 2a10 	vmov	r2, s26
 801e23e:	f00a fc93 	bl	8028b68 <__aeabi_dmul>
 801e242:	e9d6 ab02 	ldrd	sl, fp, [r6, #8]
 801e246:	4602      	mov	r2, r0
 801e248:	460b      	mov	r3, r1
 801e24a:	4650      	mov	r0, sl
 801e24c:	4659      	mov	r1, fp
 801e24e:	ec43 2b1e 	vmov	d14, r2, r3
 801e252:	f00a fc89 	bl	8028b68 <__aeabi_dmul>
 801e256:	4606      	mov	r6, r0
 801e258:	460f      	mov	r7, r1
 801e25a:	f1c8 0000 	rsb	r0, r8, #0
 801e25e:	f00a fc19 	bl	8028a94 <__aeabi_i2d>
 801e262:	ec47 6b19 	vmov	d9, r6, r7
      for (j = 0; j < i; j++) {
 801e266:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801e268:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e26a:	9208      	str	r2, [sp, #32]
 801e26c:	1c53      	adds	r3, r2, #1
 801e26e:	463e      	mov	r6, r7
 801e270:	3608      	adds	r6, #8
 801e272:	ec41 0b1c 	vmov	d12, r0, r1
 801e276:	0119      	lsls	r1, r3, #4
 801e278:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801e27c:	e9cd 6306 	strd	r6, r3, [sp, #24]
 801e280:	9b04      	ldr	r3, [sp, #16]
 801e282:	960f      	str	r6, [sp, #60]	; 0x3c
 801e284:	011b      	lsls	r3, r3, #4
        IMAG(A, lda * i + i) = 0;
 801e286:	ed9f 8b5e 	vldr	d8, [pc, #376]	; 801e400 <cblas_zher+0x2e8>
 801e28a:	9301      	str	r3, [sp, #4]
    for (i = 0; i < N; i++) {
 801e28c:	2300      	movs	r3, #0
 801e28e:	910e      	str	r1, [sp, #56]	; 0x38
 801e290:	930a      	str	r3, [sp, #40]	; 0x28
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e292:	4622      	mov	r2, r4
 801e294:	462b      	mov	r3, r5
 801e296:	ec51 0b1a 	vmov	r0, r1, d10
 801e29a:	f00a fc65 	bl	8028b68 <__aeabi_dmul>
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e29e:	4652      	mov	r2, sl
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e2a0:	4604      	mov	r4, r0
 801e2a2:	460d      	mov	r5, r1
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e2a4:	465b      	mov	r3, fp
 801e2a6:	ec51 0b1c 	vmov	r0, r1, d12
 801e2aa:	f00a fc5d 	bl	8028b68 <__aeabi_dmul>
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e2ae:	ec53 2b19 	vmov	r2, r3, d9
 801e2b2:	f00a fc59 	bl	8028b68 <__aeabi_dmul>
 801e2b6:	4602      	mov	r2, r0
 801e2b8:	460b      	mov	r3, r1
 801e2ba:	4620      	mov	r0, r4
 801e2bc:	4629      	mov	r1, r5
 801e2be:	f00a fa9b 	bl	80287f8 <__aeabi_dsub>
 801e2c2:	9c06      	ldr	r4, [sp, #24]
 801e2c4:	4602      	mov	r2, r0
 801e2c6:	460b      	mov	r3, r1
 801e2c8:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801e2cc:	f00a fa96 	bl	80287fc <__adddf3>
      ix += incX;
 801e2d0:	9b02      	ldr	r3, [sp, #8]
 801e2d2:	9d04      	ldr	r5, [sp, #16]
    for (i = 0; i < N; i++) {
 801e2d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
      ix += incX;
 801e2d6:	442b      	add	r3, r5
 801e2d8:	9302      	str	r3, [sp, #8]
    for (i = 0; i < N; i++) {
 801e2da:	9b03      	ldr	r3, [sp, #12]
 801e2dc:	3201      	adds	r2, #1
 801e2de:	4293      	cmp	r3, r2
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e2e0:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(A, lda * i + i) = 0;
 801e2e4:	ed84 8b00 	vstr	d8, [r4]
    for (i = 0; i < N; i++) {
 801e2e8:	920a      	str	r2, [sp, #40]	; 0x28
 801e2ea:	f43f af63 	beq.w	801e1b4 <cblas_zher+0x9c>
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e2ee:	9f02      	ldr	r7, [sp, #8]
 801e2f0:	9b05      	ldr	r3, [sp, #20]
 801e2f2:	eb03 1607 	add.w	r6, r3, r7, lsl #4
 801e2f6:	e9d6 2300 	ldrd	r2, r3, [r6]
 801e2fa:	ec51 0b1d 	vmov	r0, r1, d13
 801e2fe:	f00a fc33 	bl	8028b68 <__aeabi_dmul>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e302:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e306:	4604      	mov	r4, r0
 801e308:	460d      	mov	r5, r1
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e30a:	ec51 0b1e 	vmov	r0, r1, d14
 801e30e:	f00a fc2b 	bl	8028b68 <__aeabi_dmul>
 801e312:	013b      	lsls	r3, r7, #4
 801e314:	930c      	str	r3, [sp, #48]	; 0x30
 801e316:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e318:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801e31a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801e31c:	9f07      	ldr	r7, [sp, #28]
 801e31e:	ec41 0b19 	vmov	d9, r0, r1
 801e322:	4619      	mov	r1, r3
 801e324:	9b08      	ldr	r3, [sp, #32]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e326:	ec45 4b1a 	vmov	d10, r4, r5
      for (j = 0; j < i; j++) {
 801e32a:	eb01 1a03 	add.w	sl, r1, r3, lsl #4
 801e32e:	eb02 1b03 	add.w	fp, r2, r3, lsl #4
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e332:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 801e336:	ec51 0b1c 	vmov	r0, r1, d12
 801e33a:	f00a fc15 	bl	8028b68 <__aeabi_dmul>
        const BASE X_real = CONST_REAL(X, jx);
 801e33e:	e9d6 8900 	ldrd	r8, r9, [r6]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e342:	4604      	mov	r4, r0
 801e344:	460d      	mov	r5, r1
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801e346:	4642      	mov	r2, r8
 801e348:	464b      	mov	r3, r9
 801e34a:	ec51 0b1a 	vmov	r0, r1, d10
 801e34e:	f00a fc0b 	bl	8028b68 <__aeabi_dmul>
 801e352:	4622      	mov	r2, r4
 801e354:	462b      	mov	r3, r5
 801e356:	ec41 0b1b 	vmov	d11, r0, r1
 801e35a:	ec51 0b19 	vmov	r0, r1, d9
 801e35e:	f00a fc03 	bl	8028b68 <__aeabi_dmul>
 801e362:	4602      	mov	r2, r0
 801e364:	460b      	mov	r3, r1
 801e366:	ec51 0b1b 	vmov	r0, r1, d11
 801e36a:	f00a fa45 	bl	80287f8 <__aeabi_dsub>
 801e36e:	4602      	mov	r2, r0
 801e370:	460b      	mov	r3, r1
 801e372:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801e376:	f00a fa41 	bl	80287fc <__adddf3>
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801e37a:	4622      	mov	r2, r4
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801e37c:	e94b 0102 	strd	r0, r1, [fp, #-8]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801e380:	462b      	mov	r3, r5
 801e382:	ec51 0b1a 	vmov	r0, r1, d10
 801e386:	f00a fbef 	bl	8028b68 <__aeabi_dmul>
 801e38a:	4642      	mov	r2, r8
 801e38c:	464b      	mov	r3, r9
 801e38e:	4604      	mov	r4, r0
 801e390:	460d      	mov	r5, r1
 801e392:	ec51 0b19 	vmov	r0, r1, d9
 801e396:	f00a fbe7 	bl	8028b68 <__aeabi_dmul>
 801e39a:	4602      	mov	r2, r0
 801e39c:	460b      	mov	r3, r1
 801e39e:	4620      	mov	r0, r4
 801e3a0:	4629      	mov	r1, r5
 801e3a2:	f00a fa2b 	bl	80287fc <__adddf3>
 801e3a6:	460b      	mov	r3, r1
 801e3a8:	4602      	mov	r2, r0
 801e3aa:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801e3ae:	f00a fa25 	bl	80287fc <__adddf3>
 801e3b2:	f10a 0a10 	add.w	sl, sl, #16
 801e3b6:	9b01      	ldr	r3, [sp, #4]
 801e3b8:	e94a 0102 	strd	r0, r1, [sl, #-8]
      for (j = 0; j < i; j++) {
 801e3bc:	4557      	cmp	r7, sl
 801e3be:	441e      	add	r6, r3
 801e3c0:	f10b 0b10 	add.w	fp, fp, #16
 801e3c4:	d1b5      	bne.n	801e332 <cblas_zher+0x21a>
 801e3c6:	9a05      	ldr	r2, [sp, #20]
 801e3c8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801e3ca:	4413      	add	r3, r2
 801e3cc:	e9d3 ab02 	ldrd	sl, fp, [r3, #8]
 801e3d0:	e9d3 4500 	ldrd	r4, r5, [r3]
 801e3d4:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 801e3d8:	4413      	add	r3, r2
 801e3da:	9a07      	ldr	r2, [sp, #28]
 801e3dc:	9308      	str	r3, [sp, #32]
 801e3de:	4611      	mov	r1, r2
 801e3e0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801e3e2:	9a06      	ldr	r2, [sp, #24]
 801e3e4:	4419      	add	r1, r3
 801e3e6:	441a      	add	r2, r3
 801e3e8:	9107      	str	r1, [sp, #28]
 801e3ea:	9206      	str	r2, [sp, #24]
 801e3ec:	e751      	b.n	801e292 <cblas_zher+0x17a>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801e3ee:	2a01      	cmp	r2, #1
 801e3f0:	bfb8      	it	lt
 801e3f2:	2201      	movlt	r2, #1
 801e3f4:	4296      	cmp	r6, r2
 801e3f6:	bfb4      	ite	lt
 801e3f8:	2008      	movlt	r0, #8
 801e3fa:	2002      	movge	r0, #2
 801e3fc:	e6c0      	b.n	801e180 <cblas_zher+0x68>
 801e3fe:	bf00      	nop
	...
 801e408:	08031108 	.word	0x08031108
 801e40c:	08031320 	.word	0x08031320
 801e410:	080311b8 	.word	0x080311b8
    INDEX ix = OFFSET(N, incX);
 801e414:	9a04      	ldr	r2, [sp, #16]
 801e416:	2a00      	cmp	r2, #0
 801e418:	f340 80db 	ble.w	801e5d2 <cblas_zher+0x4ba>
 801e41c:	2300      	movs	r3, #0
 801e41e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 801e420:	9b03      	ldr	r3, [sp, #12]
 801e422:	2b00      	cmp	r3, #0
 801e424:	f77f aec6 	ble.w	801e1b4 <cblas_zher+0x9c>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e428:	4640      	mov	r0, r8
 801e42a:	f00a fb33 	bl	8028a94 <__aeabi_i2d>
 801e42e:	ec53 2b1d 	vmov	r2, r3, d13
 801e432:	f00a fb99 	bl	8028b68 <__aeabi_dmul>
 801e436:	4602      	mov	r2, r0
 801e438:	460b      	mov	r3, r1
 801e43a:	f1c8 0000 	rsb	r0, r8, #0
 801e43e:	ec43 2b1c 	vmov	d12, r2, r3
 801e442:	f00a fb27 	bl	8028a94 <__aeabi_i2d>
 801e446:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e448:	ec41 0b1b 	vmov	d11, r0, r1
 801e44c:	011c      	lsls	r4, r3, #4
 801e44e:	e9dd 3005 	ldrd	r3, r0, [sp, #20]
 801e452:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801e456:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801e458:	940c      	str	r4, [sp, #48]	; 0x30
 801e45a:	f104 0010 	add.w	r0, r4, #16
 801e45e:	3308      	adds	r3, #8
 801e460:	900a      	str	r0, [sp, #40]	; 0x28
 801e462:	9308      	str	r3, [sp, #32]
 801e464:	9803      	ldr	r0, [sp, #12]
 801e466:	9b04      	ldr	r3, [sp, #16]
 801e468:	f1a1 0210 	sub.w	r2, r1, #16
 801e46c:	eb02 1200 	add.w	r2, r2, r0, lsl #4
 801e470:	011b      	lsls	r3, r3, #4
        IMAG(A, lda * i + i) = 0;
 801e472:	ed9f 8b5d 	vldr	d8, [pc, #372]	; 801e5e8 <cblas_zher+0x4d0>
 801e476:	9201      	str	r2, [sp, #4]
 801e478:	9302      	str	r3, [sp, #8]
 801e47a:	f101 0208 	add.w	r2, r1, #8
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e47e:	2300      	movs	r3, #0
 801e480:	9207      	str	r2, [sp, #28]
 801e482:	9309      	str	r3, [sp, #36]	; 0x24
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e484:	9e08      	ldr	r6, [sp, #32]
 801e486:	e956 4502 	ldrd	r4, r5, [r6, #-8]
 801e48a:	ec53 2b1d 	vmov	r2, r3, d13
 801e48e:	4620      	mov	r0, r4
 801e490:	4629      	mov	r1, r5
 801e492:	f00a fb69 	bl	8028b68 <__aeabi_dmul>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e496:	e9d6 ab00 	ldrd	sl, fp, [r6]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801e49a:	460f      	mov	r7, r1
 801e49c:	4606      	mov	r6, r0
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e49e:	4652      	mov	r2, sl
 801e4a0:	465b      	mov	r3, fp
 801e4a2:	ec51 0b1c 	vmov	r0, r1, d12
 801e4a6:	f00a fb5f 	bl	8028b68 <__aeabi_dmul>
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e4aa:	4632      	mov	r2, r6
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e4ac:	4680      	mov	r8, r0
 801e4ae:	4689      	mov	r9, r1
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e4b0:	463b      	mov	r3, r7
 801e4b2:	4620      	mov	r0, r4
 801e4b4:	4629      	mov	r1, r5
 801e4b6:	f00a fb57 	bl	8028b68 <__aeabi_dmul>
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e4ba:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e4be:	4604      	mov	r4, r0
 801e4c0:	460d      	mov	r5, r1
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e4c2:	4650      	mov	r0, sl
 801e4c4:	4659      	mov	r1, fp
 801e4c6:	f00a fb4f 	bl	8028b68 <__aeabi_dmul>
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e4ca:	4642      	mov	r2, r8
 801e4cc:	464b      	mov	r3, r9
 801e4ce:	f00a fb4b 	bl	8028b68 <__aeabi_dmul>
 801e4d2:	4602      	mov	r2, r0
 801e4d4:	460b      	mov	r3, r1
 801e4d6:	4620      	mov	r0, r4
 801e4d8:	4629      	mov	r1, r5
 801e4da:	f00a f98d 	bl	80287f8 <__aeabi_dsub>
 801e4de:	9c07      	ldr	r4, [sp, #28]
 801e4e0:	4602      	mov	r2, r0
 801e4e2:	460b      	mov	r3, r1
 801e4e4:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801e4e8:	f00a f988 	bl	80287fc <__adddf3>
      for (j = i + 1; j < N; j++) {
 801e4ec:	9d09      	ldr	r5, [sp, #36]	; 0x24
        jx += incX;
 801e4ee:	9b06      	ldr	r3, [sp, #24]
 801e4f0:	9a04      	ldr	r2, [sp, #16]
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801e4f2:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (j = i + 1; j < N; j++) {
 801e4f6:	9903      	ldr	r1, [sp, #12]
 801e4f8:	3501      	adds	r5, #1
        jx += incX;
 801e4fa:	4413      	add	r3, r2
      for (j = i + 1; j < N; j++) {
 801e4fc:	42a9      	cmp	r1, r5
        IMAG(A, lda * i + i) = 0;
 801e4fe:	ed84 8b00 	vstr	d8, [r4]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801e502:	ec49 8b19 	vmov	d9, r8, r9
      for (j = i + 1; j < N; j++) {
 801e506:	9509      	str	r5, [sp, #36]	; 0x24
        jx += incX;
 801e508:	9306      	str	r3, [sp, #24]
      for (j = i + 1; j < N; j++) {
 801e50a:	f43f ae53 	beq.w	801e1b4 <cblas_zher+0x9c>
 801e50e:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 801e512:	f1a4 0a08 	sub.w	sl, r4, #8
 801e516:	eb01 1b02 	add.w	fp, r1, r2, lsl #4
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e51a:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801e51e:	ec51 0b1b 	vmov	r0, r1, d11
 801e522:	f00a fb21 	bl	8028b68 <__aeabi_dmul>
        const BASE X_real = CONST_REAL(X, jx);
 801e526:	e9db 4500 	ldrd	r4, r5, [fp]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801e52a:	4680      	mov	r8, r0
 801e52c:	4689      	mov	r9, r1
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801e52e:	4622      	mov	r2, r4
 801e530:	462b      	mov	r3, r5
 801e532:	4630      	mov	r0, r6
 801e534:	4639      	mov	r1, r7
 801e536:	f00a fb17 	bl	8028b68 <__aeabi_dmul>
 801e53a:	4642      	mov	r2, r8
 801e53c:	464b      	mov	r3, r9
 801e53e:	ec41 0b1a 	vmov	d10, r0, r1
 801e542:	ec51 0b19 	vmov	r0, r1, d9
 801e546:	f00a fb0f 	bl	8028b68 <__aeabi_dmul>
 801e54a:	4602      	mov	r2, r0
 801e54c:	460b      	mov	r3, r1
 801e54e:	ec51 0b1a 	vmov	r0, r1, d10
 801e552:	f00a f951 	bl	80287f8 <__aeabi_dsub>
 801e556:	4602      	mov	r2, r0
 801e558:	460b      	mov	r3, r1
 801e55a:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 801e55e:	f00a f94d 	bl	80287fc <__adddf3>
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801e562:	4642      	mov	r2, r8
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801e564:	e9ca 0104 	strd	r0, r1, [sl, #16]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801e568:	464b      	mov	r3, r9
 801e56a:	4630      	mov	r0, r6
 801e56c:	4639      	mov	r1, r7
 801e56e:	f00a fafb 	bl	8028b68 <__aeabi_dmul>
 801e572:	4622      	mov	r2, r4
 801e574:	462b      	mov	r3, r5
 801e576:	4680      	mov	r8, r0
 801e578:	4689      	mov	r9, r1
 801e57a:	ec51 0b19 	vmov	r0, r1, d9
 801e57e:	f00a faf3 	bl	8028b68 <__aeabi_dmul>
 801e582:	4602      	mov	r2, r0
 801e584:	460b      	mov	r3, r1
 801e586:	4640      	mov	r0, r8
 801e588:	4649      	mov	r1, r9
 801e58a:	f00a f937 	bl	80287fc <__adddf3>
 801e58e:	460b      	mov	r3, r1
 801e590:	4602      	mov	r2, r0
 801e592:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 801e596:	f00a f931 	bl	80287fc <__adddf3>
 801e59a:	9b02      	ldr	r3, [sp, #8]
 801e59c:	449b      	add	fp, r3
      for (j = i + 1; j < N; j++) {
 801e59e:	9b01      	ldr	r3, [sp, #4]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801e5a0:	e9ca 0106 	strd	r0, r1, [sl, #24]
      for (j = i + 1; j < N; j++) {
 801e5a4:	f10a 0a10 	add.w	sl, sl, #16
 801e5a8:	4553      	cmp	r3, sl
 801e5aa:	d1b6      	bne.n	801e51a <cblas_zher+0x402>
 801e5ac:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801e5ae:	4413      	add	r3, r2
 801e5b0:	9301      	str	r3, [sp, #4]
 801e5b2:	9a02      	ldr	r2, [sp, #8]
 801e5b4:	9b08      	ldr	r3, [sp, #32]
 801e5b6:	4413      	add	r3, r2
 801e5b8:	9308      	str	r3, [sp, #32]
 801e5ba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801e5bc:	9b07      	ldr	r3, [sp, #28]
 801e5be:	4413      	add	r3, r2
 801e5c0:	9307      	str	r3, [sp, #28]
 801e5c2:	e75f      	b.n	801e484 <cblas_zher+0x36c>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 801e5c4:	2d7a      	cmp	r5, #122	; 0x7a
 801e5c6:	f43f af25 	beq.w	801e414 <cblas_zher+0x2fc>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 801e5ca:	2d79      	cmp	r5, #121	; 0x79
 801e5cc:	f47f ade8 	bne.w	801e1a0 <cblas_zher+0x88>
 801e5d0:	e60f      	b.n	801e1f2 <cblas_zher+0xda>
    INDEX ix = OFFSET(N, incX);
 801e5d2:	9b03      	ldr	r3, [sp, #12]
 801e5d4:	f1c3 0301 	rsb	r3, r3, #1
 801e5d8:	fb03 f302 	mul.w	r3, r3, r2
 801e5dc:	9306      	str	r3, [sp, #24]
 801e5de:	e71f      	b.n	801e420 <cblas_zher+0x308>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801e5e0:	2008      	movs	r0, #8
 801e5e2:	e5cd      	b.n	801e180 <cblas_zher+0x68>
 801e5e4:	f3af 8000 	nop.w
	...

0801e5f0 <cblas_zher2>:

void
cblas_zher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *X, const int incX,
             const void *Y, const int incY, void *A, const int lda)
{
 801e5f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e5f4:	ed2d 8b10 	vpush	{d8-d15}
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801e5f8:	2866      	cmp	r0, #102	; 0x66
 801e5fa:	b0a1      	sub	sp, #132	; 0x84
 801e5fc:	461e      	mov	r6, r3
 801e5fe:	bf0c      	ite	eq
 801e600:	f04f 33ff 	moveq.w	r3, #4294967295
 801e604:	2301      	movne	r3, #1
 801e606:	9313      	str	r3, [sp, #76]	; 0x4c
 801e608:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801e60a:	930c      	str	r3, [sp, #48]	; 0x30
 801e60c:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 801e60e:	930a      	str	r3, [sp, #40]	; 0x28
 801e610:	9b3c      	ldr	r3, [sp, #240]	; 0xf0
 801e612:	930d      	str	r3, [sp, #52]	; 0x34
 801e614:	9b3d      	ldr	r3, [sp, #244]	; 0xf4
 801e616:	930b      	str	r3, [sp, #44]	; 0x2c
 801e618:	460d      	mov	r5, r1
 801e61a:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 801e61c:	931c      	str	r3, [sp, #112]	; 0x70
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801e61e:	3979      	subs	r1, #121	; 0x79
 801e620:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
 801e622:	9209      	str	r2, [sp, #36]	; 0x24
 801e624:	2901      	cmp	r1, #1
 801e626:	4604      	mov	r4, r0
 801e628:	9312      	str	r3, [sp, #72]	; 0x48
 801e62a:	f240 8204 	bls.w	801ea36 <cblas_zher2+0x446>
 801e62e:	2002      	movs	r0, #2
 801e630:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e632:	2b00      	cmp	r3, #0
 801e634:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801e636:	f2c0 81f1 	blt.w	801ea1c <cblas_zher2+0x42c>
 801e63a:	2b00      	cmp	r3, #0
 801e63c:	f040 81d4 	bne.w	801e9e8 <cblas_zher2+0x3f8>
 801e640:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e642:	2b00      	cmp	r3, #0
 801e644:	f040 81e0 	bne.w	801ea08 <cblas_zher2+0x418>
 801e648:	9809      	ldr	r0, [sp, #36]	; 0x24
 801e64a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801e64c:	2801      	cmp	r0, #1
 801e64e:	bfb8      	it	lt
 801e650:	2001      	movlt	r0, #1
 801e652:	4283      	cmp	r3, r0
 801e654:	bfb4      	ite	lt
 801e656:	200a      	movlt	r0, #10
 801e658:	2008      	movge	r0, #8
 801e65a:	4a15      	ldr	r2, [pc, #84]	; (801e6b0 <cblas_zher2+0xc0>)
 801e65c:	4915      	ldr	r1, [pc, #84]	; (801e6b4 <cblas_zher2+0xc4>)
 801e65e:	f00a f853 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801e662:	ed96 7b00 	vldr	d7, [r6]
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801e666:	2200      	movs	r2, #0
 801e668:	ec51 0b17 	vmov	r0, r1, d7
 801e66c:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 801e66e:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801e672:	f00a fce1 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801e676:	ed96 7b02 	vldr	d7, [r6, #8]
 801e67a:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801e67e:	b140      	cbz	r0, 801e692 <cblas_zher2+0xa2>
 801e680:	ec51 0b17 	vmov	r0, r1, d7
 801e684:	2200      	movs	r2, #0
 801e686:	2300      	movs	r3, #0
 801e688:	f00a fcd6 	bl	8029038 <__aeabi_dcmpeq>
 801e68c:	2800      	cmp	r0, #0
 801e68e:	f040 81a6 	bne.w	801e9de <cblas_zher2+0x3ee>
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801e692:	2c65      	cmp	r4, #101	; 0x65
 801e694:	f000 81dc 	beq.w	801ea50 <cblas_zher2+0x460>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801e698:	2c66      	cmp	r4, #102	; 0x66
 801e69a:	d00f      	beq.n	801e6bc <cblas_zher2+0xcc>
      BLAS_ERROR("unrecognized operation");
 801e69c:	4a06      	ldr	r2, [pc, #24]	; (801e6b8 <cblas_zher2+0xc8>)
 801e69e:	4905      	ldr	r1, [pc, #20]	; (801e6b4 <cblas_zher2+0xc4>)
 801e6a0:	2000      	movs	r0, #0
#define BASE double
#include "source_her2.h"
#undef BASE
}
 801e6a2:	b021      	add	sp, #132	; 0x84
 801e6a4:	ecbd 8b10 	vpop	{d8-d15}
 801e6a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e6ac:	f00a b82c 	b.w	8028708 <cblas_xerbla>
 801e6b0:	08031108 	.word	0x08031108
 801e6b4:	08031330 	.word	0x08031330
 801e6b8:	080311b8 	.word	0x080311b8
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801e6bc:	2d7a      	cmp	r5, #122	; 0x7a
 801e6be:	f000 81cd 	beq.w	801ea5c <cblas_zher2+0x46c>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 801e6c2:	2d79      	cmp	r5, #121	; 0x79
 801e6c4:	d1ea      	bne.n	801e69c <cblas_zher2+0xac>
      INDEX ix = OFFSET(N, incX);
 801e6c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      INDEX iy = OFFSET(N, incY);
 801e6c8:	990b      	ldr	r1, [sp, #44]	; 0x2c
      INDEX ix = OFFSET(N, incX);
 801e6ca:	2b00      	cmp	r3, #0
 801e6cc:	bfdd      	ittte	le
 801e6ce:	9a09      	ldrle	r2, [sp, #36]	; 0x24
 801e6d0:	f1c2 0201 	rsble	r2, r2, #1
 801e6d4:	435a      	mulle	r2, r3
 801e6d6:	2200      	movgt	r2, #0
      INDEX iy = OFFSET(N, incY);
 801e6d8:	2900      	cmp	r1, #0
 801e6da:	bfde      	ittt	le
 801e6dc:	9b09      	ldrle	r3, [sp, #36]	; 0x24
 801e6de:	f1c3 0301 	rsble	r3, r3, #1
 801e6e2:	434b      	mulle	r3, r1
      for (i = 0; i < N; i++) {
 801e6e4:	9909      	ldr	r1, [sp, #36]	; 0x24
      INDEX iy = OFFSET(N, incY);
 801e6e6:	bfc8      	it	gt
 801e6e8:	2300      	movgt	r3, #0
      for (i = 0; i < N; i++) {
 801e6ea:	2900      	cmp	r1, #0
 801e6ec:	f340 8177 	ble.w	801e9de <cblas_zher2+0x3ee>
 801e6f0:	990c      	ldr	r1, [sp, #48]	; 0x30
 801e6f2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801e6f4:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 801e6f8:	990d      	ldr	r1, [sp, #52]	; 0x34
 801e6fa:	921e      	str	r2, [sp, #120]	; 0x78
 801e6fc:	eb01 1103 	add.w	r1, r1, r3, lsl #4
 801e700:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801e702:	911d      	str	r1, [sp, #116]	; 0x74
 801e704:	0124      	lsls	r4, r4, #4
 801e706:	3301      	adds	r3, #1
 801e708:	e9dd 560e 	ldrd	r5, r6, [sp, #56]	; 0x38
 801e70c:	011b      	lsls	r3, r3, #4
 801e70e:	9408      	str	r4, [sp, #32]
 801e710:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 801e712:	931a      	str	r3, [sp, #104]	; 0x68
 801e714:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801e716:	9303      	str	r3, [sp, #12]
 801e718:	0124      	lsls	r4, r4, #4
 801e71a:	ed9f 7bcb 	vldr	d7, [pc, #812]	; 801ea48 <cblas_zher2+0x458>
 801e71e:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
        IMAG(A, lda * i + i) = 0;
 801e722:	eeb0 8a47 	vmov.f32	s16, s14
 801e726:	eef0 8a67 	vmov.f32	s17, s15
      for (i = 0; i < N; i++) {
 801e72a:	2000      	movs	r0, #0
 801e72c:	9404      	str	r4, [sp, #16]
 801e72e:	3308      	adds	r3, #8
 801e730:	f106 4400 	add.w	r4, r6, #2147483648	; 0x80000000
 801e734:	9518      	str	r5, [sp, #96]	; 0x60
 801e736:	900d      	str	r0, [sp, #52]	; 0x34
 801e738:	9419      	str	r4, [sp, #100]	; 0x64
 801e73a:	900a      	str	r0, [sp, #40]	; 0x28
 801e73c:	931f      	str	r3, [sp, #124]	; 0x7c
        const BASE Xi_real = CONST_REAL(X, ix);
 801e73e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801e740:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
        const BASE Xi_real = CONST_REAL(X, ix);
 801e744:	e9d4 8900 	ldrd	r8, r9, [r4]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801e748:	4650      	mov	r0, sl
 801e74a:	464b      	mov	r3, r9
 801e74c:	4642      	mov	r2, r8
 801e74e:	4659      	mov	r1, fp
 801e750:	f00a fa0a 	bl	8028b68 <__aeabi_dmul>
        const BASE Xi_imag = CONST_IMAG(X, ix);
 801e754:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801e758:	ed9d ab0e 	vldr	d10, [sp, #56]	; 0x38
 801e75c:	4632      	mov	r2, r6
 801e75e:	463b      	mov	r3, r7
 801e760:	4604      	mov	r4, r0
 801e762:	460d      	mov	r5, r1
 801e764:	ec51 0b1a 	vmov	r0, r1, d10
 801e768:	f00a f9fe 	bl	8028b68 <__aeabi_dmul>
 801e76c:	4602      	mov	r2, r0
 801e76e:	460b      	mov	r3, r1
 801e770:	4620      	mov	r0, r4
 801e772:	4629      	mov	r1, r5
 801e774:	f00a f840 	bl	80287f8 <__aeabi_dsub>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801e778:	464b      	mov	r3, r9
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801e77a:	4604      	mov	r4, r0
 801e77c:	460d      	mov	r5, r1
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801e77e:	4642      	mov	r2, r8
 801e780:	ec51 0b1a 	vmov	r0, r1, d10
 801e784:	f00a f9f0 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801e788:	ec45 4b1f 	vmov	d15, r4, r5
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801e78c:	4632      	mov	r2, r6
 801e78e:	463b      	mov	r3, r7
 801e790:	4604      	mov	r4, r0
 801e792:	460d      	mov	r5, r1
 801e794:	4650      	mov	r0, sl
 801e796:	4659      	mov	r1, fp
 801e798:	f00a f9e6 	bl	8028b68 <__aeabi_dmul>
 801e79c:	4602      	mov	r2, r0
 801e79e:	460b      	mov	r3, r1
 801e7a0:	4620      	mov	r0, r4
 801e7a2:	4629      	mov	r1, r5
 801e7a4:	f00a f82a 	bl	80287fc <__adddf3>
        const BASE Yi_real = CONST_REAL(Y, iy);
 801e7a8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801e7aa:	ed96 7b00 	vldr	d7, [r6]
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 801e7ae:	ed96 9b02 	vldr	d9, [r6, #8]
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801e7b2:	4604      	mov	r4, r0
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801e7b4:	4657      	mov	r7, sl
 801e7b6:	4650      	mov	r0, sl
 801e7b8:	ec5a 9b17 	vmov	r9, sl, d7
 801e7bc:	ee17 2a10 	vmov	r2, s14
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801e7c0:	460d      	mov	r5, r1
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801e7c2:	4653      	mov	r3, sl
 801e7c4:	4659      	mov	r1, fp
        const BASE Yi_real = CONST_REAL(Y, iy);
 801e7c6:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 801e7ca:	ed8d 9b16 	vstr	d9, [sp, #88]	; 0x58
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801e7ce:	f00a f9cb 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801e7d2:	ec45 4b1d 	vmov	d13, r4, r5
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801e7d6:	ec53 2b19 	vmov	r2, r3, d9
 801e7da:	4604      	mov	r4, r0
 801e7dc:	460d      	mov	r5, r1
 801e7de:	ec51 0b1a 	vmov	r0, r1, d10
 801e7e2:	f00a f9c1 	bl	8028b68 <__aeabi_dmul>
 801e7e6:	4602      	mov	r2, r0
 801e7e8:	460b      	mov	r3, r1
 801e7ea:	4620      	mov	r0, r4
 801e7ec:	4629      	mov	r1, r5
 801e7ee:	f00a f805 	bl	80287fc <__adddf3>
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801e7f2:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801e7f6:	4604      	mov	r4, r0
 801e7f8:	460d      	mov	r5, r1
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801e7fa:	4648      	mov	r0, r9
 801e7fc:	4651      	mov	r1, sl
 801e7fe:	f00a f9b3 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801e802:	ec45 4b1c 	vmov	d12, r4, r5
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801e806:	ec53 2b19 	vmov	r2, r3, d9
 801e80a:	4604      	mov	r4, r0
 801e80c:	460d      	mov	r5, r1
 801e80e:	4638      	mov	r0, r7
 801e810:	4659      	mov	r1, fp
 801e812:	f00a f9a9 	bl	8028b68 <__aeabi_dmul>
 801e816:	460b      	mov	r3, r1
 801e818:	4602      	mov	r2, r0
 801e81a:	4629      	mov	r1, r5
 801e81c:	4620      	mov	r0, r4
 801e81e:	f009 ffed 	bl	80287fc <__adddf3>
        for (j = 0; j < i; j++) {
 801e822:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801e824:	ec41 0b1b 	vmov	d11, r0, r1
        for (j = 0; j < i; j++) {
 801e828:	2b00      	cmp	r3, #0
 801e82a:	f000 809f 	beq.w	801e96c <cblas_zher2+0x37c>
 801e82e:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801e830:	f00a f930 	bl	8028a94 <__aeabi_i2d>
 801e834:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801e836:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801e838:	e9cd 0106 	strd	r0, r1, [sp, #24]
 801e83c:	e9dd 451d 	ldrd	r4, r5, [sp, #116]	; 0x74
 801e840:	4619      	mov	r1, r3
 801e842:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801e844:	eb01 1a03 	add.w	sl, r1, r3, lsl #4
 801e848:	eb02 1b03 	add.w	fp, r2, r3, lsl #4
          const BASE Yj_real = CONST_REAL(Y, jy);
 801e84c:	ed94 7b00 	vldr	d7, [r4]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801e850:	ed94 6b02 	vldr	d6, [r4, #8]
          const BASE Yj_real = CONST_REAL(Y, jy);
 801e854:	eeb0 ea47 	vmov.f32	s28, s14
 801e858:	eef0 ea67 	vmov.f32	s29, s15
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e85c:	ec53 2b17 	vmov	r2, r3, d7
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801e860:	eeb0 9a46 	vmov.f32	s18, s12
 801e864:	eef0 9a66 	vmov.f32	s19, s13
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e868:	ec51 0b1f 	vmov	r0, r1, d15
 801e86c:	f00a f97c 	bl	8028b68 <__aeabi_dmul>
 801e870:	ec53 2b19 	vmov	r2, r3, d9
 801e874:	4606      	mov	r6, r0
 801e876:	460f      	mov	r7, r1
 801e878:	ec51 0b1d 	vmov	r0, r1, d13
 801e87c:	f00a f974 	bl	8028b68 <__aeabi_dmul>
 801e880:	4602      	mov	r2, r0
 801e882:	460b      	mov	r3, r1
 801e884:	4630      	mov	r0, r6
 801e886:	4639      	mov	r1, r7
 801e888:	f009 ffb8 	bl	80287fc <__adddf3>
          const BASE Xj_real = CONST_REAL(X, jx);
 801e88c:	e9d5 8900 	ldrd	r8, r9, [r5]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e890:	ec41 0b1a 	vmov	d10, r0, r1
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801e894:	4642      	mov	r2, r8
 801e896:	464b      	mov	r3, r9
 801e898:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Xj_imag = CONST_IMAG(X, jx);
 801e89c:	e9d5 6702 	ldrd	r6, r7, [r5, #8]
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801e8a0:	f00a f962 	bl	8028b68 <__aeabi_dmul>
 801e8a4:	4632      	mov	r2, r6
 801e8a6:	463b      	mov	r3, r7
 801e8a8:	e9cd 0100 	strd	r0, r1, [sp]
 801e8ac:	ec51 0b1b 	vmov	r0, r1, d11
 801e8b0:	f00a f95a 	bl	8028b68 <__aeabi_dmul>
 801e8b4:	4602      	mov	r2, r0
 801e8b6:	460b      	mov	r3, r1
 801e8b8:	e9dd 0100 	ldrd	r0, r1, [sp]
 801e8bc:	f009 ff9e 	bl	80287fc <__adddf3>
 801e8c0:	4602      	mov	r2, r0
 801e8c2:	460b      	mov	r3, r1
 801e8c4:	ec51 0b1a 	vmov	r0, r1, d10
 801e8c8:	f009 ff98 	bl	80287fc <__adddf3>
 801e8cc:	4602      	mov	r2, r0
 801e8ce:	460b      	mov	r3, r1
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e8d0:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801e8d4:	f009 ff92 	bl	80287fc <__adddf3>
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e8d8:	ec53 2b1e 	vmov	r2, r3, d14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e8dc:	e94b 0102 	strd	r0, r1, [fp, #-8]
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e8e0:	ec51 0b1d 	vmov	r0, r1, d13
 801e8e4:	f00a f940 	bl	8028b68 <__aeabi_dmul>
 801e8e8:	ec53 2b19 	vmov	r2, r3, d9
 801e8ec:	ec41 0b19 	vmov	d9, r0, r1
 801e8f0:	ec51 0b1f 	vmov	r0, r1, d15
 801e8f4:	f00a f938 	bl	8028b68 <__aeabi_dmul>
 801e8f8:	4602      	mov	r2, r0
 801e8fa:	460b      	mov	r3, r1
 801e8fc:	ec51 0b19 	vmov	r0, r1, d9
 801e900:	f009 ff7a 	bl	80287f8 <__aeabi_dsub>
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801e904:	4642      	mov	r2, r8
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e906:	ec41 0b19 	vmov	d9, r0, r1
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801e90a:	464b      	mov	r3, r9
 801e90c:	ec51 0b1b 	vmov	r0, r1, d11
 801e910:	f00a f92a 	bl	8028b68 <__aeabi_dmul>
 801e914:	4632      	mov	r2, r6
 801e916:	463b      	mov	r3, r7
 801e918:	4606      	mov	r6, r0
 801e91a:	460f      	mov	r7, r1
 801e91c:	ec51 0b1c 	vmov	r0, r1, d12
 801e920:	f00a f922 	bl	8028b68 <__aeabi_dmul>
 801e924:	4602      	mov	r2, r0
 801e926:	460b      	mov	r3, r1
 801e928:	4630      	mov	r0, r6
 801e92a:	4639      	mov	r1, r7
 801e92c:	f009 ff64 	bl	80287f8 <__aeabi_dsub>
 801e930:	4602      	mov	r2, r0
 801e932:	460b      	mov	r3, r1
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e934:	ec51 0b19 	vmov	r0, r1, d9
 801e938:	f009 ff60 	bl	80287fc <__adddf3>
 801e93c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 801e940:	f00a f912 	bl	8028b68 <__aeabi_dmul>
 801e944:	460b      	mov	r3, r1
 801e946:	4602      	mov	r2, r0
          IMAG(A, lda * i + j) +=
 801e948:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801e94c:	f009 ff56 	bl	80287fc <__adddf3>
 801e950:	9b04      	ldr	r3, [sp, #16]
 801e952:	441c      	add	r4, r3
 801e954:	9b08      	ldr	r3, [sp, #32]
 801e956:	441d      	add	r5, r3
        for (j = 0; j < i; j++) {
 801e958:	9b03      	ldr	r3, [sp, #12]
          IMAG(A, lda * i + j) +=
 801e95a:	e9ca 0102 	strd	r0, r1, [sl, #8]
        for (j = 0; j < i; j++) {
 801e95e:	f10a 0a10 	add.w	sl, sl, #16
 801e962:	4553      	cmp	r3, sl
 801e964:	f10b 0b10 	add.w	fp, fp, #16
 801e968:	f47f af70 	bne.w	801e84c <cblas_zher2+0x25c>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801e96c:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 801e970:	ec51 0b1f 	vmov	r0, r1, d15
 801e974:	f00a f8f8 	bl	8028b68 <__aeabi_dmul>
 801e978:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 801e97c:	4604      	mov	r4, r0
 801e97e:	460d      	mov	r5, r1
 801e980:	ec51 0b1d 	vmov	r0, r1, d13
 801e984:	f00a f8f0 	bl	8028b68 <__aeabi_dmul>
 801e988:	4602      	mov	r2, r0
 801e98a:	460b      	mov	r3, r1
 801e98c:	4620      	mov	r0, r4
 801e98e:	4629      	mov	r1, r5
 801e990:	f009 ff34 	bl	80287fc <__adddf3>
 801e994:	4602      	mov	r2, r0
 801e996:	460b      	mov	r3, r1
 801e998:	f009 ff30 	bl	80287fc <__adddf3>
 801e99c:	9c03      	ldr	r4, [sp, #12]
 801e99e:	4602      	mov	r2, r0
 801e9a0:	460b      	mov	r3, r1
 801e9a2:	e9d4 0100 	ldrd	r0, r1, [r4]
 801e9a6:	f009 ff29 	bl	80287fc <__adddf3>
 801e9aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801e9ac:	9d08      	ldr	r5, [sp, #32]
      for (i = 0; i < N; i++) {
 801e9ae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801e9b0:	442b      	add	r3, r5
 801e9b2:	930c      	str	r3, [sp, #48]	; 0x30
 801e9b4:	9d04      	ldr	r5, [sp, #16]
 801e9b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e9b8:	442b      	add	r3, r5
 801e9ba:	930b      	str	r3, [sp, #44]	; 0x2c
 801e9bc:	9d12      	ldr	r5, [sp, #72]	; 0x48
 801e9be:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801e9c0:	442b      	add	r3, r5
 801e9c2:	930d      	str	r3, [sp, #52]	; 0x34
 801e9c4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801e9c6:	18e3      	adds	r3, r4, r3
 801e9c8:	9303      	str	r3, [sp, #12]
 801e9ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e9cc:	3201      	adds	r2, #1
 801e9ce:	4293      	cmp	r3, r2
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801e9d0:	e9c4 0100 	strd	r0, r1, [r4]
        IMAG(A, lda * i + i) = 0;
 801e9d4:	ed84 8b02 	vstr	d8, [r4, #8]
      for (i = 0; i < N; i++) {
 801e9d8:	920a      	str	r2, [sp, #40]	; 0x28
 801e9da:	f47f aeb0 	bne.w	801e73e <cblas_zher2+0x14e>
 801e9de:	b021      	add	sp, #132	; 0x84
 801e9e0:	ecbd 8b10 	vpop	{d8-d15}
 801e9e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801e9e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e9ea:	2b00      	cmp	r3, #0
 801e9ec:	f43f ae2c 	beq.w	801e648 <cblas_zher2+0x58>
 801e9f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e9f2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801e9f4:	2b01      	cmp	r3, #1
 801e9f6:	bfb8      	it	lt
 801e9f8:	2301      	movlt	r3, #1
 801e9fa:	4293      	cmp	r3, r2
 801e9fc:	f300 81c3 	bgt.w	801ed86 <cblas_zher2+0x796>
 801ea00:	2800      	cmp	r0, #0
 801ea02:	f43f ae2e 	beq.w	801e662 <cblas_zher2+0x72>
 801ea06:	e628      	b.n	801e65a <cblas_zher2+0x6a>
 801ea08:	9809      	ldr	r0, [sp, #36]	; 0x24
 801ea0a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801ea0c:	2801      	cmp	r0, #1
 801ea0e:	bfb8      	it	lt
 801ea10:	2001      	movlt	r0, #1
 801ea12:	4283      	cmp	r3, r0
 801ea14:	bfb4      	ite	lt
 801ea16:	200a      	movlt	r0, #10
 801ea18:	2006      	movge	r0, #6
 801ea1a:	e61e      	b.n	801e65a <cblas_zher2+0x6a>
 801ea1c:	2b00      	cmp	r3, #0
 801ea1e:	f43f ae0f 	beq.w	801e640 <cblas_zher2+0x50>
 801ea22:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ea24:	2b00      	cmp	r3, #0
 801ea26:	f43f ae0f 	beq.w	801e648 <cblas_zher2+0x58>
 801ea2a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801ea2c:	2b00      	cmp	r3, #0
 801ea2e:	bfd4      	ite	le
 801ea30:	200a      	movle	r0, #10
 801ea32:	2003      	movgt	r0, #3
 801ea34:	e611      	b.n	801e65a <cblas_zher2+0x6a>
 801ea36:	3865      	subs	r0, #101	; 0x65
 801ea38:	2801      	cmp	r0, #1
 801ea3a:	bf94      	ite	ls
 801ea3c:	2000      	movls	r0, #0
 801ea3e:	2001      	movhi	r0, #1
 801ea40:	e5f6      	b.n	801e630 <cblas_zher2+0x40>
 801ea42:	bf00      	nop
 801ea44:	f3af 8000 	nop.w
	...
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801ea50:	2d79      	cmp	r5, #121	; 0x79
 801ea52:	d003      	beq.n	801ea5c <cblas_zher2+0x46c>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 801ea54:	2d7a      	cmp	r5, #122	; 0x7a
 801ea56:	f47f ae21 	bne.w	801e69c <cblas_zher2+0xac>
 801ea5a:	e634      	b.n	801e6c6 <cblas_zher2+0xd6>
      INDEX ix = OFFSET(N, incX);
 801ea5c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ea5e:	2a00      	cmp	r2, #0
 801ea60:	bfde      	ittt	le
 801ea62:	9b09      	ldrle	r3, [sp, #36]	; 0x24
 801ea64:	f1c3 0301 	rsble	r3, r3, #1
 801ea68:	4353      	mulle	r3, r2
      INDEX iy = OFFSET(N, incY);
 801ea6a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
      INDEX ix = OFFSET(N, incX);
 801ea6c:	bfc8      	it	gt
 801ea6e:	2300      	movgt	r3, #0
      INDEX iy = OFFSET(N, incY);
 801ea70:	2a00      	cmp	r2, #0
      INDEX ix = OFFSET(N, incX);
 801ea72:	9314      	str	r3, [sp, #80]	; 0x50
      INDEX iy = OFFSET(N, incY);
 801ea74:	f340 8180 	ble.w	801ed78 <cblas_zher2+0x788>
 801ea78:	2300      	movs	r3, #0
 801ea7a:	9316      	str	r3, [sp, #88]	; 0x58
      for (i = 0; i < N; i++) {
 801ea7c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ea7e:	2b00      	cmp	r3, #0
 801ea80:	ddad      	ble.n	801e9de <cblas_zher2+0x3ee>
 801ea82:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801ea84:	991c      	ldr	r1, [sp, #112]	; 0x70
 801ea86:	011a      	lsls	r2, r3, #4
 801ea88:	921e      	str	r2, [sp, #120]	; 0x78
 801ea8a:	3210      	adds	r2, #16
 801ea8c:	921d      	str	r2, [sp, #116]	; 0x74
 801ea8e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801ea90:	f1a1 0310 	sub.w	r3, r1, #16
 801ea94:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ea98:	9303      	str	r3, [sp, #12]
 801ea9a:	f101 0308 	add.w	r3, r1, #8
 801ea9e:	9306      	str	r3, [sp, #24]
 801eaa0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801eaa2:	011b      	lsls	r3, r3, #4
 801eaa4:	931f      	str	r3, [sp, #124]	; 0x7c
 801eaa6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801eaa8:	011b      	lsls	r3, r3, #4
 801eaaa:	9308      	str	r3, [sp, #32]
 801eaac:	2300      	movs	r3, #0
 801eaae:	9312      	str	r3, [sp, #72]	; 0x48
 801eab0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801eab2:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
 801eab6:	011b      	lsls	r3, r3, #4
 801eab8:	931c      	str	r3, [sp, #112]	; 0x70
 801eaba:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801eabc:	941a      	str	r4, [sp, #104]	; 0x68
 801eabe:	ed1f 7b1e 	vldr	d7, [pc, #-120]	; 801ea48 <cblas_zher2+0x458>
 801eac2:	f105 4000 	add.w	r0, r5, #2147483648	; 0x80000000
 801eac6:	011b      	lsls	r3, r3, #4
 801eac8:	901b      	str	r0, [sp, #108]	; 0x6c
 801eaca:	9318      	str	r3, [sp, #96]	; 0x60
        IMAG(A, lda * i + i) = 0;
 801eacc:	eeb0 8a47 	vmov.f32	s16, s14
 801ead0:	eef0 8a67 	vmov.f32	s17, s15
        const BASE Xi_real = CONST_REAL(X, ix);
 801ead4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801ead6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801ead8:	4413      	add	r3, r2
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801eada:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
        const BASE Xi_real = CONST_REAL(X, ix);
 801eade:	e9d3 8900 	ldrd	r8, r9, [r3]
        const BASE Xi_imag = CONST_IMAG(X, ix);
 801eae2:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801eae6:	4642      	mov	r2, r8
 801eae8:	464b      	mov	r3, r9
 801eaea:	4650      	mov	r0, sl
 801eaec:	4659      	mov	r1, fp
 801eaee:	f00a f83b 	bl	8028b68 <__aeabi_dmul>
 801eaf2:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
 801eaf6:	4632      	mov	r2, r6
 801eaf8:	463b      	mov	r3, r7
 801eafa:	4604      	mov	r4, r0
 801eafc:	460d      	mov	r5, r1
 801eafe:	ec51 0b19 	vmov	r0, r1, d9
 801eb02:	f00a f831 	bl	8028b68 <__aeabi_dmul>
 801eb06:	4602      	mov	r2, r0
 801eb08:	460b      	mov	r3, r1
 801eb0a:	4620      	mov	r0, r4
 801eb0c:	4629      	mov	r1, r5
 801eb0e:	f009 fe73 	bl	80287f8 <__aeabi_dsub>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb12:	4642      	mov	r2, r8
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801eb14:	4604      	mov	r4, r0
 801eb16:	460d      	mov	r5, r1
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb18:	464b      	mov	r3, r9
 801eb1a:	ec51 0b19 	vmov	r0, r1, d9
 801eb1e:	f00a f823 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801eb22:	ec45 4b1b 	vmov	d11, r4, r5
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb26:	4632      	mov	r2, r6
 801eb28:	463b      	mov	r3, r7
 801eb2a:	4604      	mov	r4, r0
 801eb2c:	460d      	mov	r5, r1
 801eb2e:	4650      	mov	r0, sl
 801eb30:	4659      	mov	r1, fp
 801eb32:	f00a f819 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801eb36:	eeb0 fa4b 	vmov.f32	s30, s22
 801eb3a:	eef0 fa6b 	vmov.f32	s31, s23
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb3e:	4602      	mov	r2, r0
 801eb40:	460b      	mov	r3, r1
 801eb42:	4620      	mov	r0, r4
 801eb44:	4629      	mov	r1, r5
 801eb46:	f009 fe59 	bl	80287fc <__adddf3>
 801eb4a:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801eb4c:	4689      	mov	r9, r1
 801eb4e:	990d      	ldr	r1, [sp, #52]	; 0x34
 801eb50:	440b      	add	r3, r1
        const BASE Yi_real = CONST_REAL(Y, iy);
 801eb52:	e9d3 6700 	ldrd	r6, r7, [r3]
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 801eb56:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb5a:	4680      	mov	r8, r0
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801eb5c:	4632      	mov	r2, r6
 801eb5e:	463b      	mov	r3, r7
 801eb60:	4650      	mov	r0, sl
 801eb62:	4659      	mov	r1, fp
 801eb64:	f00a f800 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb68:	ec49 8b1a 	vmov	d10, r8, r9
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801eb6c:	4622      	mov	r2, r4
 801eb6e:	462b      	mov	r3, r5
 801eb70:	4680      	mov	r8, r0
 801eb72:	4689      	mov	r9, r1
 801eb74:	ec51 0b19 	vmov	r0, r1, d9
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801eb78:	eeb0 da4a 	vmov.f32	s26, s20
 801eb7c:	eef0 da6a 	vmov.f32	s27, s21
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801eb80:	f009 fff2 	bl	8028b68 <__aeabi_dmul>
 801eb84:	4602      	mov	r2, r0
 801eb86:	460b      	mov	r3, r1
 801eb88:	4640      	mov	r0, r8
 801eb8a:	4649      	mov	r1, r9
 801eb8c:	f009 fe36 	bl	80287fc <__adddf3>
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801eb90:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801eb94:	4680      	mov	r8, r0
 801eb96:	4689      	mov	r9, r1
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801eb98:	4630      	mov	r0, r6
 801eb9a:	4639      	mov	r1, r7
 801eb9c:	f009 ffe4 	bl	8028b68 <__aeabi_dmul>
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801eba0:	ec49 8b1c 	vmov	d12, r8, r9
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801eba4:	4622      	mov	r2, r4
 801eba6:	462b      	mov	r3, r5
 801eba8:	4680      	mov	r8, r0
 801ebaa:	4689      	mov	r9, r1
 801ebac:	4650      	mov	r0, sl
 801ebae:	4659      	mov	r1, fp
 801ebb0:	f009 ffda 	bl	8028b68 <__aeabi_dmul>
 801ebb4:	4602      	mov	r2, r0
 801ebb6:	460b      	mov	r3, r1
 801ebb8:	4640      	mov	r0, r8
 801ebba:	4649      	mov	r1, r9
 801ebbc:	f009 fe1e 	bl	80287fc <__adddf3>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801ebc0:	4632      	mov	r2, r6
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801ebc2:	4680      	mov	r8, r0
 801ebc4:	4689      	mov	r9, r1
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801ebc6:	463b      	mov	r3, r7
 801ebc8:	ec51 0b1b 	vmov	r0, r1, d11
 801ebcc:	f009 ffcc 	bl	8028b68 <__aeabi_dmul>
 801ebd0:	4622      	mov	r2, r4
 801ebd2:	462b      	mov	r3, r5
 801ebd4:	4604      	mov	r4, r0
 801ebd6:	460d      	mov	r5, r1
 801ebd8:	ec51 0b1a 	vmov	r0, r1, d10
 801ebdc:	f009 ffc4 	bl	8028b68 <__aeabi_dmul>
 801ebe0:	4602      	mov	r2, r0
 801ebe2:	460b      	mov	r3, r1
 801ebe4:	4620      	mov	r0, r4
 801ebe6:	4629      	mov	r1, r5
 801ebe8:	f009 fe08 	bl	80287fc <__adddf3>
 801ebec:	4602      	mov	r2, r0
 801ebee:	460b      	mov	r3, r1
 801ebf0:	f009 fe04 	bl	80287fc <__adddf3>
 801ebf4:	9c06      	ldr	r4, [sp, #24]
 801ebf6:	4602      	mov	r2, r0
 801ebf8:	460b      	mov	r3, r1
 801ebfa:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801ebfe:	f009 fdfd 	bl	80287fc <__adddf3>
        for (j = i + 1; j < N; j++) {
 801ec02:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801ec04:	3201      	adds	r2, #1
 801ec06:	9212      	str	r2, [sp, #72]	; 0x48
        INDEX jx = ix + incX;
 801ec08:	9d14      	ldr	r5, [sp, #80]	; 0x50
 801ec0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        INDEX jy = iy + incY;
 801ec0c:	9e16      	ldr	r6, [sp, #88]	; 0x58
        INDEX jx = ix + incX;
 801ec0e:	441d      	add	r5, r3
        INDEX jy = iy + incY;
 801ec10:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        INDEX jx = ix + incX;
 801ec12:	9514      	str	r5, [sp, #80]	; 0x50
        INDEX jy = iy + incY;
 801ec14:	441e      	add	r6, r3
        for (j = i + 1; j < N; j++) {
 801ec16:	9b09      	ldr	r3, [sp, #36]	; 0x24
        INDEX jy = iy + incY;
 801ec18:	9616      	str	r6, [sp, #88]	; 0x58
        for (j = i + 1; j < N; j++) {
 801ec1a:	4293      	cmp	r3, r2
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801ec1c:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(A, lda * i + i) = 0;
 801ec20:	ed84 8b00 	vstr	d8, [r4]
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801ec24:	ec49 8b1b 	vmov	d11, r8, r9
        for (j = i + 1; j < N; j++) {
 801ec28:	f43f aed9 	beq.w	801e9de <cblas_zher2+0x3ee>
 801ec2c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801ec2e:	f009 ff31 	bl	8028a94 <__aeabi_i2d>
 801ec32:	012b      	lsls	r3, r5, #4
 801ec34:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801ec38:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801ec3a:	990d      	ldr	r1, [sp, #52]	; 0x34
 801ec3c:	931c      	str	r3, [sp, #112]	; 0x70
 801ec3e:	f8dd b07c 	ldr.w	fp, [sp, #124]	; 0x7c
 801ec42:	0133      	lsls	r3, r6, #4
 801ec44:	eb02 1a05 	add.w	sl, r2, r5, lsl #4
 801ec48:	9318      	str	r3, [sp, #96]	; 0x60
 801ec4a:	eb01 1506 	add.w	r5, r1, r6, lsl #4
 801ec4e:	3c08      	subs	r4, #8
          const BASE Yj_real = CONST_REAL(Y, jy);
 801ec50:	ed95 7b00 	vldr	d7, [r5]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801ec54:	ed95 6b02 	vldr	d6, [r5, #8]
          const BASE Yj_real = CONST_REAL(Y, jy);
 801ec58:	eeb0 ea47 	vmov.f32	s28, s14
 801ec5c:	eef0 ea67 	vmov.f32	s29, s15
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801ec60:	ec53 2b17 	vmov	r2, r3, d7
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801ec64:	eeb0 9a46 	vmov.f32	s18, s12
 801ec68:	eef0 9a66 	vmov.f32	s19, s13
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801ec6c:	ec51 0b1f 	vmov	r0, r1, d15
 801ec70:	f009 ff7a 	bl	8028b68 <__aeabi_dmul>
 801ec74:	ec53 2b19 	vmov	r2, r3, d9
 801ec78:	4606      	mov	r6, r0
 801ec7a:	460f      	mov	r7, r1
 801ec7c:	ec51 0b1d 	vmov	r0, r1, d13
 801ec80:	f009 ff72 	bl	8028b68 <__aeabi_dmul>
 801ec84:	4602      	mov	r2, r0
 801ec86:	460b      	mov	r3, r1
 801ec88:	4630      	mov	r0, r6
 801ec8a:	4639      	mov	r1, r7
 801ec8c:	f009 fdb6 	bl	80287fc <__adddf3>
          const BASE Xj_real = CONST_REAL(X, jx);
 801ec90:	ed9a ab00 	vldr	d10, [sl]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801ec94:	4606      	mov	r6, r0
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801ec96:	ec53 2b1a 	vmov	r2, r3, d10
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801ec9a:	460f      	mov	r7, r1
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801ec9c:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Xj_imag = CONST_IMAG(X, jx);
 801eca0:	e9da 8902 	ldrd	r8, r9, [sl, #8]
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801eca4:	f009 ff60 	bl	8028b68 <__aeabi_dmul>
 801eca8:	4642      	mov	r2, r8
 801ecaa:	464b      	mov	r3, r9
 801ecac:	e9cd 0100 	strd	r0, r1, [sp]
 801ecb0:	ec51 0b1b 	vmov	r0, r1, d11
 801ecb4:	f009 ff58 	bl	8028b68 <__aeabi_dmul>
 801ecb8:	4602      	mov	r2, r0
 801ecba:	460b      	mov	r3, r1
 801ecbc:	e9dd 0100 	ldrd	r0, r1, [sp]
 801ecc0:	f009 fd9c 	bl	80287fc <__adddf3>
 801ecc4:	4602      	mov	r2, r0
 801ecc6:	460b      	mov	r3, r1
 801ecc8:	4630      	mov	r0, r6
 801ecca:	4639      	mov	r1, r7
 801eccc:	f009 fd96 	bl	80287fc <__adddf3>
 801ecd0:	4602      	mov	r2, r0
 801ecd2:	460b      	mov	r3, r1
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801ecd4:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801ecd8:	f009 fd90 	bl	80287fc <__adddf3>
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801ecdc:	ec53 2b1e 	vmov	r2, r3, d14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801ece0:	e9c4 0104 	strd	r0, r1, [r4, #16]
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801ece4:	ec51 0b1d 	vmov	r0, r1, d13
 801ece8:	f009 ff3e 	bl	8028b68 <__aeabi_dmul>
 801ecec:	ec53 2b19 	vmov	r2, r3, d9
 801ecf0:	4606      	mov	r6, r0
 801ecf2:	460f      	mov	r7, r1
 801ecf4:	ec51 0b1f 	vmov	r0, r1, d15
 801ecf8:	f009 ff36 	bl	8028b68 <__aeabi_dmul>
 801ecfc:	4602      	mov	r2, r0
 801ecfe:	460b      	mov	r3, r1
 801ed00:	4630      	mov	r0, r6
 801ed02:	4639      	mov	r1, r7
 801ed04:	f009 fd78 	bl	80287f8 <__aeabi_dsub>
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801ed08:	ec53 2b1a 	vmov	r2, r3, d10
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801ed0c:	4606      	mov	r6, r0
 801ed0e:	460f      	mov	r7, r1
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801ed10:	ec51 0b1b 	vmov	r0, r1, d11
 801ed14:	f009 ff28 	bl	8028b68 <__aeabi_dmul>
 801ed18:	4642      	mov	r2, r8
 801ed1a:	464b      	mov	r3, r9
 801ed1c:	4680      	mov	r8, r0
 801ed1e:	4689      	mov	r9, r1
 801ed20:	ec51 0b1c 	vmov	r0, r1, d12
 801ed24:	f009 ff20 	bl	8028b68 <__aeabi_dmul>
 801ed28:	4602      	mov	r2, r0
 801ed2a:	460b      	mov	r3, r1
 801ed2c:	4640      	mov	r0, r8
 801ed2e:	4649      	mov	r1, r9
 801ed30:	f009 fd62 	bl	80287f8 <__aeabi_dsub>
 801ed34:	4602      	mov	r2, r0
 801ed36:	460b      	mov	r3, r1
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801ed38:	4630      	mov	r0, r6
 801ed3a:	4639      	mov	r1, r7
 801ed3c:	f009 fd5e 	bl	80287fc <__adddf3>
 801ed40:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801ed44:	f009 ff10 	bl	8028b68 <__aeabi_dmul>
 801ed48:	460b      	mov	r3, r1
 801ed4a:	4602      	mov	r2, r0
          IMAG(A, lda * i + j) +=
 801ed4c:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801ed50:	f009 fd54 	bl	80287fc <__adddf3>
 801ed54:	9b08      	ldr	r3, [sp, #32]
 801ed56:	441d      	add	r5, r3
        for (j = i + 1; j < N; j++) {
 801ed58:	9b03      	ldr	r3, [sp, #12]
          IMAG(A, lda * i + j) +=
 801ed5a:	e9c4 0106 	strd	r0, r1, [r4, #24]
        for (j = i + 1; j < N; j++) {
 801ed5e:	3410      	adds	r4, #16
 801ed60:	42a3      	cmp	r3, r4
 801ed62:	44da      	add	sl, fp
 801ed64:	f47f af74 	bne.w	801ec50 <cblas_zher2+0x660>
 801ed68:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801ed6a:	4413      	add	r3, r2
 801ed6c:	9303      	str	r3, [sp, #12]
 801ed6e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801ed70:	9b06      	ldr	r3, [sp, #24]
 801ed72:	4413      	add	r3, r2
 801ed74:	9306      	str	r3, [sp, #24]
 801ed76:	e6ad      	b.n	801ead4 <cblas_zher2+0x4e4>
      INDEX iy = OFFSET(N, incY);
 801ed78:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ed7a:	f1c3 0301 	rsb	r3, r3, #1
 801ed7e:	fb03 f302 	mul.w	r3, r3, r2
 801ed82:	9316      	str	r3, [sp, #88]	; 0x58
 801ed84:	e67a      	b.n	801ea7c <cblas_zher2+0x48c>
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801ed86:	200a      	movs	r0, #10
 801ed88:	e467      	b.n	801e65a <cblas_zher2+0x6a>
 801ed8a:	bf00      	nop
 801ed8c:	0000      	movs	r0, r0
	...

0801ed90 <cblas_zher2k>:
void
cblas_zher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const double beta, void *C, const int ldc)
{
 801ed90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ed94:	ed2d 8b10 	vpush	{d8-d15}
 801ed98:	b0ab      	sub	sp, #172	; 0xac
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801ed9a:	2865      	cmp	r0, #101	; 0x65
 801ed9c:	9313      	str	r3, [sp, #76]	; 0x4c
 801ed9e:	9b44      	ldr	r3, [sp, #272]	; 0x110
 801eda0:	9317      	str	r3, [sp, #92]	; 0x5c
 801eda2:	e9dd 6345 	ldrd	r6, r3, [sp, #276]	; 0x114
 801eda6:	931b      	str	r3, [sp, #108]	; 0x6c
 801eda8:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 801edaa:	9316      	str	r3, [sp, #88]	; 0x58
 801edac:	9b48      	ldr	r3, [sp, #288]	; 0x120
 801edae:	931a      	str	r3, [sp, #104]	; 0x68
 801edb0:	9b49      	ldr	r3, [sp, #292]	; 0x124
 801edb2:	9318      	str	r3, [sp, #96]	; 0x60
 801edb4:	9b4a      	ldr	r3, [sp, #296]	; 0x128
 801edb6:	9319      	str	r3, [sp, #100]	; 0x64
 801edb8:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
 801edba:	9320      	str	r3, [sp, #128]	; 0x80
 801edbc:	ec5b ab10 	vmov	sl, fp, d0
 801edc0:	4605      	mov	r5, r0
 801edc2:	460f      	mov	r7, r1
 801edc4:	4614      	mov	r4, r2
 801edc6:	f000 8453 	beq.w	801f670 <cblas_zher2k+0x8e0>
 801edca:	2a6f      	cmp	r2, #111	; 0x6f
 801edcc:	f000 80ae 	beq.w	801ef2c <cblas_zher2k+0x19c>
 801edd0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801edd2:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 801edd6:	2a01      	cmp	r2, #1
 801edd8:	f240 83f4 	bls.w	801f5c4 <cblas_zher2k+0x834>
 801eddc:	2002      	movs	r0, #2
 801edde:	f1a4 026f 	sub.w	r2, r4, #111	; 0x6f
 801ede2:	2a02      	cmp	r2, #2
 801ede4:	bf88      	it	hi
 801ede6:	2003      	movhi	r0, #3
 801ede8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801edea:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801edec:	2a00      	cmp	r2, #0
 801edee:	bfb8      	it	lt
 801edf0:	2004      	movlt	r0, #4
 801edf2:	2900      	cmp	r1, #0
 801edf4:	bfb8      	it	lt
 801edf6:	2005      	movlt	r0, #5
 801edf8:	9916      	ldr	r1, [sp, #88]	; 0x58
 801edfa:	2b01      	cmp	r3, #1
 801edfc:	bfb8      	it	lt
 801edfe:	2301      	movlt	r3, #1
 801ee00:	428b      	cmp	r3, r1
 801ee02:	f340 83c6 	ble.w	801f592 <cblas_zher2k+0x802>
 801ee06:	9918      	ldr	r1, [sp, #96]	; 0x60
 801ee08:	428b      	cmp	r3, r1
 801ee0a:	f300 83d1 	bgt.w	801f5b0 <cblas_zher2k+0x820>
 801ee0e:	2a01      	cmp	r2, #1
 801ee10:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801ee12:	bfb8      	it	lt
 801ee14:	2201      	movlt	r2, #1
 801ee16:	429a      	cmp	r2, r3
 801ee18:	bfcc      	ite	gt
 801ee1a:	200e      	movgt	r0, #14
 801ee1c:	2008      	movle	r0, #8
 801ee1e:	4a47      	ldr	r2, [pc, #284]	; (801ef3c <cblas_zher2k+0x1ac>)
 801ee20:	4947      	ldr	r1, [pc, #284]	; (801ef40 <cblas_zher2k+0x1b0>)
 801ee22:	f009 fc71 	bl	8028708 <cblas_xerbla>
    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 801ee26:	4b47      	ldr	r3, [pc, #284]	; (801ef44 <cblas_zher2k+0x1b4>)
 801ee28:	2200      	movs	r2, #0
 801ee2a:	4650      	mov	r0, sl
 801ee2c:	4659      	mov	r1, fp
 801ee2e:	f00a f903 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_real = CONST_REAL0(alpha);
 801ee32:	ed96 7b00 	vldr	d7, [r6]
    BASE alpha_imag = CONST_IMAG0(alpha);
 801ee36:	ed96 8b02 	vldr	d8, [r6, #8]
    const BASE alpha_real = CONST_REAL0(alpha);
 801ee3a:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    BASE alpha_imag = CONST_IMAG0(alpha);
 801ee3e:	ed8d 8b10 	vstr	d8, [sp, #64]	; 0x40
    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 801ee42:	b198      	cbz	r0, 801ee6c <cblas_zher2k+0xdc>
 801ee44:	ec51 0b17 	vmov	r0, r1, d7
 801ee48:	2200      	movs	r2, #0
 801ee4a:	2300      	movs	r3, #0
 801ee4c:	f00a f8f4 	bl	8029038 <__aeabi_dcmpeq>
 801ee50:	b140      	cbz	r0, 801ee64 <cblas_zher2k+0xd4>
 801ee52:	ec51 0b18 	vmov	r0, r1, d8
 801ee56:	2200      	movs	r2, #0
 801ee58:	2300      	movs	r3, #0
 801ee5a:	f00a f8ed 	bl	8029038 <__aeabi_dcmpeq>
 801ee5e:	2800      	cmp	r0, #0
 801ee60:	f040 8392 	bne.w	801f588 <cblas_zher2k+0x7f8>
 801ee64:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801ee66:	2b00      	cmp	r3, #0
 801ee68:	f000 838e 	beq.w	801f588 <cblas_zher2k+0x7f8>
    if (Order == CblasRowMajor) {
 801ee6c:	2d65      	cmp	r5, #101	; 0x65
 801ee6e:	f000 8405 	beq.w	801f67c <cblas_zher2k+0x8ec>
      alpha_imag *= -1;           /* conjugate alpha */
 801ee72:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801ee76:	2f79      	cmp	r7, #121	; 0x79
      alpha_imag *= -1;           /* conjugate alpha */
 801ee78:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 801ee7c:	4602      	mov	r2, r0
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801ee7e:	bf0c      	ite	eq
 801ee80:	217a      	moveq	r1, #122	; 0x7a
 801ee82:	2179      	movne	r1, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801ee84:	2c6f      	cmp	r4, #111	; 0x6f
      alpha_imag *= -1;           /* conjugate alpha */
 801ee86:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801ee8a:	bf0c      	ite	eq
 801ee8c:	2371      	moveq	r3, #113	; 0x71
 801ee8e:	236f      	movne	r3, #111	; 0x6f
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801ee90:	9100      	str	r1, [sp, #0]
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801ee92:	9303      	str	r3, [sp, #12]
    if (beta == 0.0) {
 801ee94:	2200      	movs	r2, #0
 801ee96:	2300      	movs	r3, #0
 801ee98:	4650      	mov	r0, sl
 801ee9a:	4659      	mov	r1, fp
 801ee9c:	f00a f8cc 	bl	8029038 <__aeabi_dcmpeq>
 801eea0:	4604      	mov	r4, r0
 801eea2:	2800      	cmp	r0, #0
 801eea4:	f000 8395 	beq.w	801f5d2 <cblas_zher2k+0x842>
      if (uplo == CblasUpper) {
 801eea8:	9b00      	ldr	r3, [sp, #0]
 801eeaa:	2b79      	cmp	r3, #121	; 0x79
 801eeac:	d04e      	beq.n	801ef4c <cblas_zher2k+0x1bc>
        for (i = 0; i < N; i++) {
 801eeae:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801eeb0:	2b00      	cmp	r3, #0
 801eeb2:	dd1a      	ble.n	801eeea <cblas_zher2k+0x15a>
 801eeb4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801eeb6:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801eeb8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 801eeba:	f8dd c064 	ldr.w	ip, [sp, #100]	; 0x64
 801eebe:	1c5c      	adds	r4, r3, #1
 801eec0:	2100      	movs	r1, #0
            REAL(C, ldc * i + j) = 0.0;
 801eec2:	2600      	movs	r6, #0
 801eec4:	2700      	movs	r7, #0
 801eec6:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 801eec8:	4608      	mov	r0, r1
 801eeca:	3210      	adds	r2, #16
 801eecc:	469e      	mov	lr, r3
 801eece:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
            REAL(C, ldc * i + j) = 0.0;
 801eed2:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 801eed6:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = 0; j <= i; j++) {
 801eeda:	3310      	adds	r3, #16
 801eedc:	429a      	cmp	r2, r3
 801eede:	d1f8      	bne.n	801eed2 <cblas_zher2k+0x142>
        for (i = 0; i < N; i++) {
 801eee0:	3001      	adds	r0, #1
 801eee2:	4285      	cmp	r5, r0
 801eee4:	4471      	add	r1, lr
 801eee6:	4422      	add	r2, r4
 801eee8:	d1f1      	bne.n	801eece <cblas_zher2k+0x13e>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801eeea:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 801eeee:	2200      	movs	r2, #0
 801eef0:	2300      	movs	r3, #0
 801eef2:	f00a f8a1 	bl	8029038 <__aeabi_dcmpeq>
 801eef6:	b158      	cbz	r0, 801ef10 <cblas_zher2k+0x180>
 801eef8:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 801eefc:	2200      	movs	r2, #0
 801eefe:	2300      	movs	r3, #0
 801ef00:	f00a f89a 	bl	8029038 <__aeabi_dcmpeq>
 801ef04:	2800      	cmp	r0, #0
 801ef06:	f040 833f 	bne.w	801f588 <cblas_zher2k+0x7f8>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 801ef0a:	9b00      	ldr	r3, [sp, #0]
 801ef0c:	2b79      	cmp	r3, #121	; 0x79
 801ef0e:	d03e      	beq.n	801ef8e <cblas_zher2k+0x1fe>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801ef10:	9b00      	ldr	r3, [sp, #0]
 801ef12:	2b7a      	cmp	r3, #122	; 0x7a
 801ef14:	f000 81b0 	beq.w	801f278 <cblas_zher2k+0x4e8>
      BLAS_ERROR("unrecognized operation");
 801ef18:	4a0b      	ldr	r2, [pc, #44]	; (801ef48 <cblas_zher2k+0x1b8>)
 801ef1a:	4909      	ldr	r1, [pc, #36]	; (801ef40 <cblas_zher2k+0x1b0>)
 801ef1c:	2000      	movs	r0, #0
#define BASE double
#include "source_her2k.h"
#undef BASE
}
 801ef1e:	b02b      	add	sp, #172	; 0xac
 801ef20:	ecbd 8b10 	vpop	{d8-d15}
 801ef24:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ef28:	f009 bbee 	b.w	8028708 <cblas_xerbla>
 801ef2c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801ef2e:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 801ef32:	2a01      	cmp	r2, #1
 801ef34:	f240 8346 	bls.w	801f5c4 <cblas_zher2k+0x834>
 801ef38:	2002      	movs	r0, #2
 801ef3a:	e755      	b.n	801ede8 <cblas_zher2k+0x58>
 801ef3c:	08031108 	.word	0x08031108
 801ef40:	08031340 	.word	0x08031340
 801ef44:	3ff00000 	.word	0x3ff00000
 801ef48:	080311b8 	.word	0x080311b8
        for (i = 0; i < N; i++) {
 801ef4c:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 801ef4e:	2d00      	cmp	r5, #0
 801ef50:	dd15      	ble.n	801ef7e <cblas_zher2k+0x1ee>
 801ef52:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801ef54:	9819      	ldr	r0, [sp, #100]	; 0x64
 801ef56:	1c5c      	adds	r4, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 801ef58:	2600      	movs	r6, #0
 801ef5a:	2700      	movs	r7, #0
 801ef5c:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 801ef5e:	2100      	movs	r1, #0
 801ef60:	4603      	mov	r3, r0
 801ef62:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 801ef64:	3201      	adds	r2, #1
 801ef66:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 801ef68:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 801ef6c:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = i; j < N; j++) {
 801ef70:	f103 0310 	add.w	r3, r3, #16
 801ef74:	dcf6      	bgt.n	801ef64 <cblas_zher2k+0x1d4>
        for (i = 0; i < N; i++) {
 801ef76:	3101      	adds	r1, #1
 801ef78:	428d      	cmp	r5, r1
 801ef7a:	4420      	add	r0, r4
 801ef7c:	d1f0      	bne.n	801ef60 <cblas_zher2k+0x1d0>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801ef7e:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 801ef82:	2200      	movs	r2, #0
 801ef84:	2300      	movs	r3, #0
 801ef86:	f00a f857 	bl	8029038 <__aeabi_dcmpeq>
 801ef8a:	2800      	cmp	r0, #0
 801ef8c:	d1b4      	bne.n	801eef8 <cblas_zher2k+0x168>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 801ef8e:	9b03      	ldr	r3, [sp, #12]
 801ef90:	2b6f      	cmp	r3, #111	; 0x6f
 801ef92:	f000 839b 	beq.w	801f6cc <cblas_zher2k+0x93c>
    } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 801ef96:	9b03      	ldr	r3, [sp, #12]
 801ef98:	2b71      	cmp	r3, #113	; 0x71
 801ef9a:	d1bd      	bne.n	801ef18 <cblas_zher2k+0x188>
      for (k = 0; k < K; k++) {
 801ef9c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801ef9e:	2b00      	cmp	r3, #0
 801efa0:	f340 82f2 	ble.w	801f588 <cblas_zher2k+0x7f8>
 801efa4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801efa6:	9816      	ldr	r0, [sp, #88]	; 0x58
 801efa8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 801efaa:	f1a3 0210 	sub.w	r2, r3, #16
 801efae:	2100      	movs	r1, #0
 801efb0:	1c43      	adds	r3, r0, #1
 801efb2:	011b      	lsls	r3, r3, #4
 801efb4:	e9cd 111c 	strd	r1, r1, [sp, #112]	; 0x70
            IMAG(C, i * lda + i) = 0.0;
 801efb8:	ed9f 8bad 	vldr	d8, [pc, #692]	; 801f270 <cblas_zher2k+0x4e0>
 801efbc:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 801efc0:	930c      	str	r3, [sp, #48]	; 0x30
 801efc2:	0103      	lsls	r3, r0, #4
      for (k = 0; k < K; k++) {
 801efc4:	9114      	str	r1, [sp, #80]	; 0x50
 801efc6:	920a      	str	r2, [sp, #40]	; 0x28
 801efc8:	931e      	str	r3, [sp, #120]	; 0x78
        for (i = 0; i < N; i++) {
 801efca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801efcc:	2b00      	cmp	r3, #0
 801efce:	f340 8588 	ble.w	801fae2 <cblas_zher2k+0xd52>
 801efd2:	e9dd 321b 	ldrd	r3, r2, [sp, #108]	; 0x6c
 801efd6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801efda:	9312      	str	r3, [sp, #72]	; 0x48
 801efdc:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801efde:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801efe0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801efe4:	9303      	str	r3, [sp, #12]
 801efe6:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801efe8:	3308      	adds	r3, #8
 801efea:	9306      	str	r3, [sp, #24]
 801efec:	2300      	movs	r3, #0
 801efee:	9308      	str	r3, [sp, #32]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801eff0:	9c12      	ldr	r4, [sp, #72]	; 0x48
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801eff2:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801eff6:	e9d4 6700 	ldrd	r6, r7, [r4]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801effa:	ec51 0b19 	vmov	r0, r1, d9
 801effe:	4632      	mov	r2, r6
 801f000:	463b      	mov	r3, r7
 801f002:	f009 fdb1 	bl	8028b68 <__aeabi_dmul>
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801f006:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f00a:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801f00e:	4622      	mov	r2, r4
 801f010:	462b      	mov	r3, r5
 801f012:	4680      	mov	r8, r0
 801f014:	4689      	mov	r9, r1
 801f016:	4650      	mov	r0, sl
 801f018:	4659      	mov	r1, fp
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f01a:	9404      	str	r4, [sp, #16]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f01c:	f009 fda4 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f020:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f024:	4602      	mov	r2, r0
 801f026:	460b      	mov	r3, r1
 801f028:	4640      	mov	r0, r8
 801f02a:	4649      	mov	r1, r9
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f02c:	9405      	str	r4, [sp, #20]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f02e:	f009 fbe5 	bl	80287fc <__adddf3>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f032:	ec53 2b19 	vmov	r2, r3, d9
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f036:	4604      	mov	r4, r0
 801f038:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f03a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 801f03e:	f009 fd93 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f042:	ec45 4b1b 	vmov	d11, r4, r5
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f046:	4632      	mov	r2, r6
 801f048:	463b      	mov	r3, r7
 801f04a:	4604      	mov	r4, r0
 801f04c:	460d      	mov	r5, r1
 801f04e:	4650      	mov	r0, sl
 801f050:	4659      	mov	r1, fp
 801f052:	f009 fd89 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f056:	eeb0 fa4b 	vmov.f32	s30, s22
 801f05a:	eef0 fa6b 	vmov.f32	s31, s23
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801f05e:	9e03      	ldr	r6, [sp, #12]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f060:	4602      	mov	r2, r0
 801f062:	460b      	mov	r3, r1
 801f064:	4620      	mov	r0, r4
 801f066:	4629      	mov	r1, r5
 801f068:	f009 fbc8 	bl	80287fc <__adddf3>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801f06c:	e9d6 8900 	ldrd	r8, r9, [r6]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f070:	4604      	mov	r4, r0
 801f072:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f074:	4642      	mov	r2, r8
 801f076:	464b      	mov	r3, r9
 801f078:	ec51 0b19 	vmov	r0, r1, d9
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801f07c:	9603      	str	r6, [sp, #12]
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f07e:	f009 fd73 	bl	8028b68 <__aeabi_dmul>
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801f082:	e9d6 6702 	ldrd	r6, r7, [r6, #8]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f086:	ec45 4b1a 	vmov	d10, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f08a:	4632      	mov	r2, r6
 801f08c:	4604      	mov	r4, r0
 801f08e:	460d      	mov	r5, r1
 801f090:	463b      	mov	r3, r7
 801f092:	4650      	mov	r0, sl
 801f094:	4659      	mov	r1, fp
 801f096:	f009 fd67 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f09a:	eeb0 ea4a 	vmov.f32	s28, s20
 801f09e:	eef0 ea6a 	vmov.f32	s29, s21
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f0a2:	4602      	mov	r2, r0
 801f0a4:	460b      	mov	r3, r1
 801f0a6:	4620      	mov	r0, r4
 801f0a8:	4629      	mov	r1, r5
 801f0aa:	f009 fba5 	bl	80287f8 <__aeabi_dsub>
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f0ae:	4632      	mov	r2, r6
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f0b0:	4604      	mov	r4, r0
 801f0b2:	460d      	mov	r5, r1
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f0b4:	463b      	mov	r3, r7
 801f0b6:	ec51 0b19 	vmov	r0, r1, d9
 801f0ba:	f009 fd55 	bl	8028b68 <__aeabi_dmul>
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f0be:	ec45 4b1d 	vmov	d13, r4, r5
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f0c2:	4642      	mov	r2, r8
 801f0c4:	4604      	mov	r4, r0
 801f0c6:	460d      	mov	r5, r1
 801f0c8:	464b      	mov	r3, r9
 801f0ca:	4650      	mov	r0, sl
 801f0cc:	4659      	mov	r1, fp
 801f0ce:	f009 fd4b 	bl	8028b68 <__aeabi_dmul>
 801f0d2:	4602      	mov	r2, r0
 801f0d4:	460b      	mov	r3, r1
 801f0d6:	4620      	mov	r0, r4
 801f0d8:	4629      	mov	r1, r5
 801f0da:	f009 fb8f 	bl	80287fc <__adddf3>
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f0de:	ec53 2b1b 	vmov	r2, r3, d11
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f0e2:	4604      	mov	r4, r0
 801f0e4:	460d      	mov	r5, r1
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f0e6:	4640      	mov	r0, r8
 801f0e8:	4649      	mov	r1, r9
 801f0ea:	f009 fd3d 	bl	8028b68 <__aeabi_dmul>
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f0ee:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f0f2:	ec53 2b1a 	vmov	r2, r3, d10
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f0f6:	ee0c 4a10 	vmov	s24, r4
 801f0fa:	ee0c 5a90 	vmov	s25, r5
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f0fe:	4604      	mov	r4, r0
 801f100:	460d      	mov	r5, r1
 801f102:	4630      	mov	r0, r6
 801f104:	4639      	mov	r1, r7
 801f106:	f009 fd2f 	bl	8028b68 <__aeabi_dmul>
 801f10a:	4602      	mov	r2, r0
 801f10c:	460b      	mov	r3, r1
 801f10e:	4620      	mov	r0, r4
 801f110:	4629      	mov	r1, r5
 801f112:	f009 fb71 	bl	80287f8 <__aeabi_dsub>
 801f116:	4602      	mov	r2, r0
 801f118:	460b      	mov	r3, r1
 801f11a:	f009 fb6f 	bl	80287fc <__adddf3>
 801f11e:	9c06      	ldr	r4, [sp, #24]
 801f120:	4602      	mov	r2, r0
 801f122:	460b      	mov	r3, r1
 801f124:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801f128:	f009 fb68 	bl	80287fc <__adddf3>
          for (j = i + 1; j < N; j++) {
 801f12c:	9d08      	ldr	r5, [sp, #32]
 801f12e:	3501      	adds	r5, #1
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f130:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + i) = 0.0;
 801f134:	ed84 8b00 	vstr	d8, [r4]
          for (j = i + 1; j < N; j++) {
 801f138:	9508      	str	r5, [sp, #32]
 801f13a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801f13c:	42aa      	cmp	r2, r5
 801f13e:	f000 84d0 	beq.w	801fae2 <cblas_zher2k+0xd52>
 801f142:	9e03      	ldr	r6, [sp, #12]
 801f144:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
 801f148:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801f14a:	f1a4 0a08 	sub.w	sl, r4, #8
 801f14e:	4634      	mov	r4, r6
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801f150:	e9d4 8904 	ldrd	r8, r9, [r4, #16]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801f154:	ed94 7b06 	vldr	d7, [r4, #24]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f158:	4642      	mov	r2, r8
 801f15a:	464b      	mov	r3, r9
 801f15c:	ec51 0b1f 	vmov	r0, r1, d15
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801f160:	eeb0 9a47 	vmov.f32	s18, s14
 801f164:	eef0 9a67 	vmov.f32	s19, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f168:	f009 fcfe 	bl	8028b68 <__aeabi_dmul>
 801f16c:	ec53 2b19 	vmov	r2, r3, d9
 801f170:	4606      	mov	r6, r0
 801f172:	460f      	mov	r7, r1
 801f174:	ec51 0b1e 	vmov	r0, r1, d14
 801f178:	f009 fcf6 	bl	8028b68 <__aeabi_dmul>
 801f17c:	4602      	mov	r2, r0
 801f17e:	460b      	mov	r3, r1
 801f180:	4630      	mov	r0, r6
 801f182:	4639      	mov	r1, r7
 801f184:	f009 fb38 	bl	80287f8 <__aeabi_dsub>
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 801f188:	ed9b ab04 	vldr	d10, [fp, #16]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f18c:	4606      	mov	r6, r0
 801f18e:	460f      	mov	r7, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801f190:	ec53 2b1a 	vmov	r2, r3, d10
 801f194:	ec51 0b1d 	vmov	r0, r1, d13
 801f198:	f009 fce6 	bl	8028b68 <__aeabi_dmul>
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801f19c:	ed9b bb06 	vldr	d11, [fp, #24]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801f1a0:	e9cd 0100 	strd	r0, r1, [sp]
 801f1a4:	ec53 2b1b 	vmov	r2, r3, d11
 801f1a8:	ec51 0b1c 	vmov	r0, r1, d12
 801f1ac:	f009 fcdc 	bl	8028b68 <__aeabi_dmul>
 801f1b0:	4602      	mov	r2, r0
 801f1b2:	460b      	mov	r3, r1
 801f1b4:	e9dd 0100 	ldrd	r0, r1, [sp]
 801f1b8:	f009 fb1e 	bl	80287f8 <__aeabi_dsub>
 801f1bc:	4602      	mov	r2, r0
 801f1be:	460b      	mov	r3, r1
 801f1c0:	4630      	mov	r0, r6
 801f1c2:	4639      	mov	r1, r7
 801f1c4:	f009 fb1a 	bl	80287fc <__adddf3>
 801f1c8:	4602      	mov	r2, r0
 801f1ca:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f1cc:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 801f1d0:	f009 fb14 	bl	80287fc <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f1d4:	ec53 2b19 	vmov	r2, r3, d9
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f1d8:	e9ca 0104 	strd	r0, r1, [sl, #16]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f1dc:	ec51 0b1f 	vmov	r0, r1, d15
 801f1e0:	f009 fcc2 	bl	8028b68 <__aeabi_dmul>
 801f1e4:	4642      	mov	r2, r8
 801f1e6:	464b      	mov	r3, r9
 801f1e8:	4606      	mov	r6, r0
 801f1ea:	460f      	mov	r7, r1
 801f1ec:	ec51 0b1e 	vmov	r0, r1, d14
 801f1f0:	f009 fcba 	bl	8028b68 <__aeabi_dmul>
 801f1f4:	4602      	mov	r2, r0
 801f1f6:	460b      	mov	r3, r1
 801f1f8:	4630      	mov	r0, r6
 801f1fa:	4639      	mov	r1, r7
 801f1fc:	f009 fafe 	bl	80287fc <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801f200:	ec53 2b1b 	vmov	r2, r3, d11
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f204:	4680      	mov	r8, r0
 801f206:	4689      	mov	r9, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801f208:	ec51 0b1d 	vmov	r0, r1, d13
 801f20c:	f009 fcac 	bl	8028b68 <__aeabi_dmul>
 801f210:	ec53 2b1a 	vmov	r2, r3, d10
 801f214:	4606      	mov	r6, r0
 801f216:	460f      	mov	r7, r1
 801f218:	ec51 0b1c 	vmov	r0, r1, d12
 801f21c:	f009 fca4 	bl	8028b68 <__aeabi_dmul>
 801f220:	4602      	mov	r2, r0
 801f222:	460b      	mov	r3, r1
 801f224:	4630      	mov	r0, r6
 801f226:	4639      	mov	r1, r7
 801f228:	f009 fae8 	bl	80287fc <__adddf3>
 801f22c:	4602      	mov	r2, r0
 801f22e:	460b      	mov	r3, r1
 801f230:	4640      	mov	r0, r8
 801f232:	4649      	mov	r1, r9
 801f234:	f009 fae2 	bl	80287fc <__adddf3>
 801f238:	4602      	mov	r2, r0
 801f23a:	460b      	mov	r3, r1
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f23c:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 801f240:	f009 fadc 	bl	80287fc <__adddf3>
 801f244:	f10b 0b10 	add.w	fp, fp, #16
          for (j = i + 1; j < N; j++) {
 801f248:	455d      	cmp	r5, fp
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f24a:	e9ca 0106 	strd	r0, r1, [sl, #24]
          for (j = i + 1; j < N; j++) {
 801f24e:	f104 0410 	add.w	r4, r4, #16
 801f252:	f10a 0a10 	add.w	sl, sl, #16
 801f256:	f47f af7b 	bne.w	801f150 <cblas_zher2k+0x3c0>
 801f25a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801f25c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801f25e:	3310      	adds	r3, #16
 801f260:	9312      	str	r3, [sp, #72]	; 0x48
 801f262:	9b03      	ldr	r3, [sp, #12]
 801f264:	3310      	adds	r3, #16
 801f266:	9303      	str	r3, [sp, #12]
 801f268:	9b06      	ldr	r3, [sp, #24]
 801f26a:	4413      	add	r3, r2
 801f26c:	9306      	str	r3, [sp, #24]
 801f26e:	e6bf      	b.n	801eff0 <cblas_zher2k+0x260>
	...
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801f278:	9b03      	ldr	r3, [sp, #12]
 801f27a:	2b6f      	cmp	r3, #111	; 0x6f
 801f27c:	f000 8484 	beq.w	801fb88 <cblas_zher2k+0xdf8>
    } else if (uplo == CblasLower && trans == CblasConjTrans) {
 801f280:	9b03      	ldr	r3, [sp, #12]
 801f282:	2b71      	cmp	r3, #113	; 0x71
 801f284:	f47f ae48 	bne.w	801ef18 <cblas_zher2k+0x188>
      for (k = 0; k < K; k++) {
 801f288:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801f28a:	2b00      	cmp	r3, #0
 801f28c:	f340 817c 	ble.w	801f588 <cblas_zher2k+0x7f8>
 801f290:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801f292:	011b      	lsls	r3, r3, #4
 801f294:	9321      	str	r3, [sp, #132]	; 0x84
 801f296:	3310      	adds	r3, #16
 801f298:	931c      	str	r3, [sp, #112]	; 0x70
 801f29a:	9b19      	ldr	r3, [sp, #100]	; 0x64
            IMAG(C, i * lda + i) = 0.0;
 801f29c:	ed1f 8b0c 	vldr	d8, [pc, #-48]	; 801f270 <cblas_zher2k+0x4e0>
      for (k = 0; k < K; k++) {
 801f2a0:	2200      	movs	r2, #0
 801f2a2:	3308      	adds	r3, #8
 801f2a4:	921f      	str	r2, [sp, #124]	; 0x7c
 801f2a6:	9220      	str	r2, [sp, #128]	; 0x80
 801f2a8:	931d      	str	r3, [sp, #116]	; 0x74
        for (i = 0; i < N; i++) {
 801f2aa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f2ac:	2b00      	cmp	r3, #0
 801f2ae:	f340 815c 	ble.w	801f56a <cblas_zher2k+0x7da>
 801f2b2:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801f2b4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801f2b6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801f2ba:	931e      	str	r3, [sp, #120]	; 0x78
 801f2bc:	9304      	str	r3, [sp, #16]
 801f2be:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801f2c0:	9308      	str	r3, [sp, #32]
 801f2c2:	2200      	movs	r2, #0
 801f2c4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801f2c6:	9206      	str	r2, [sp, #24]
 801f2c8:	9212      	str	r2, [sp, #72]	; 0x48
 801f2ca:	9303      	str	r3, [sp, #12]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801f2cc:	9c03      	ldr	r4, [sp, #12]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f2ce:	ed9d ab0e 	vldr	d10, [sp, #56]	; 0x38
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801f2d2:	e9d4 6700 	ldrd	r6, r7, [r4]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f2d6:	ec51 0b1a 	vmov	r0, r1, d10
 801f2da:	4632      	mov	r2, r6
 801f2dc:	463b      	mov	r3, r7
 801f2de:	f009 fc43 	bl	8028b68 <__aeabi_dmul>
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801f2e2:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f2e6:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801f2ea:	4622      	mov	r2, r4
 801f2ec:	462b      	mov	r3, r5
 801f2ee:	4680      	mov	r8, r0
 801f2f0:	4689      	mov	r9, r1
 801f2f2:	4650      	mov	r0, sl
 801f2f4:	4659      	mov	r1, fp
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f2f6:	9414      	str	r4, [sp, #80]	; 0x50
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f2f8:	f009 fc36 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f2fc:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f300:	4602      	mov	r2, r0
 801f302:	460b      	mov	r3, r1
 801f304:	4640      	mov	r0, r8
 801f306:	4649      	mov	r1, r9
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f308:	9415      	str	r4, [sp, #84]	; 0x54
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f30a:	f009 fa77 	bl	80287fc <__adddf3>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f30e:	ec53 2b1a 	vmov	r2, r3, d10
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f312:	4604      	mov	r4, r0
 801f314:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f316:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 801f31a:	f009 fc25 	bl	8028b68 <__aeabi_dmul>
 801f31e:	4632      	mov	r2, r6
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801f320:	9e04      	ldr	r6, [sp, #16]
 801f322:	ed96 9b00 	vldr	d9, [r6]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801f326:	ec45 4b1f 	vmov	d15, r4, r5
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f32a:	463b      	mov	r3, r7
 801f32c:	4604      	mov	r4, r0
 801f32e:	460d      	mov	r5, r1
 801f330:	4650      	mov	r0, sl
 801f332:	4659      	mov	r1, fp
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801f334:	ed8d 9b0a 	vstr	d9, [sp, #40]	; 0x28
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f338:	f009 fc16 	bl	8028b68 <__aeabi_dmul>
 801f33c:	4602      	mov	r2, r0
 801f33e:	460b      	mov	r3, r1
 801f340:	4620      	mov	r0, r4
 801f342:	4629      	mov	r1, r5
 801f344:	f009 fa5a 	bl	80287fc <__adddf3>
 801f348:	46d0      	mov	r8, sl
 801f34a:	46d9      	mov	r9, fp
 801f34c:	4604      	mov	r4, r0
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f34e:	ec5b ab1a 	vmov	sl, fp, d10
 801f352:	ee1a 0a10 	vmov	r0, s20
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801f356:	ed96 ab02 	vldr	d10, [r6, #8]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f35a:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f35c:	ec53 2b19 	vmov	r2, r3, d9
 801f360:	4659      	mov	r1, fp
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801f362:	ed8d ab0c 	vstr	d10, [sp, #48]	; 0x30
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f366:	f009 fbff 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801f36a:	ec45 4b1d 	vmov	d13, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f36e:	ec53 2b1a 	vmov	r2, r3, d10
 801f372:	4604      	mov	r4, r0
 801f374:	460d      	mov	r5, r1
 801f376:	4640      	mov	r0, r8
 801f378:	4649      	mov	r1, r9
 801f37a:	f009 fbf5 	bl	8028b68 <__aeabi_dmul>
 801f37e:	4602      	mov	r2, r0
 801f380:	460b      	mov	r3, r1
 801f382:	4620      	mov	r0, r4
 801f384:	4629      	mov	r1, r5
 801f386:	f009 fa37 	bl	80287f8 <__aeabi_dsub>
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f38a:	ec53 2b1a 	vmov	r2, r3, d10
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f38e:	4604      	mov	r4, r0
 801f390:	460d      	mov	r5, r1
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f392:	4650      	mov	r0, sl
 801f394:	4659      	mov	r1, fp
 801f396:	f009 fbe7 	bl	8028b68 <__aeabi_dmul>
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801f39a:	ec45 4b1c 	vmov	d12, r4, r5
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f39e:	ec53 2b19 	vmov	r2, r3, d9
 801f3a2:	4604      	mov	r4, r0
 801f3a4:	460d      	mov	r5, r1
 801f3a6:	4640      	mov	r0, r8
 801f3a8:	4649      	mov	r1, r9
 801f3aa:	f009 fbdd 	bl	8028b68 <__aeabi_dmul>
 801f3ae:	460b      	mov	r3, r1
 801f3b0:	4602      	mov	r2, r0
 801f3b2:	4629      	mov	r1, r5
 801f3b4:	4620      	mov	r0, r4
 801f3b6:	f009 fa21 	bl	80287fc <__adddf3>
 801f3ba:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 801f3be:	ee0b 3a90 	vmov	s23, r3
          for (j = 0; j < i; j++) {
 801f3c2:	9b12      	ldr	r3, [sp, #72]	; 0x48
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801f3c4:	ee0b 0a10 	vmov	s22, r0
          for (j = 0; j < i; j++) {
 801f3c8:	2b00      	cmp	r3, #0
 801f3ca:	f000 8097 	beq.w	801f4fc <cblas_zher2k+0x76c>
 801f3ce:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801f3d0:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801f3d2:	9d1e      	ldr	r5, [sp, #120]	; 0x78
 801f3d4:	f8dd a06c 	ldr.w	sl, [sp, #108]	; 0x6c
 801f3d8:	4619      	mov	r1, r3
 801f3da:	9b06      	ldr	r3, [sp, #24]
 801f3dc:	eb01 1b03 	add.w	fp, r1, r3, lsl #4
 801f3e0:	eb02 1403 	add.w	r4, r2, r3, lsl #4
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801f3e4:	ed95 7b00 	vldr	d7, [r5]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801f3e8:	ed95 6b02 	vldr	d6, [r5, #8]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801f3ec:	eeb0 ea47 	vmov.f32	s28, s14
 801f3f0:	eef0 ea67 	vmov.f32	s29, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f3f4:	ec53 2b17 	vmov	r2, r3, d7
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801f3f8:	eeb0 9a46 	vmov.f32	s18, s12
 801f3fc:	eef0 9a66 	vmov.f32	s19, s13
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f400:	ec51 0b1f 	vmov	r0, r1, d15
 801f404:	f009 fbb0 	bl	8028b68 <__aeabi_dmul>
 801f408:	ec53 2b19 	vmov	r2, r3, d9
 801f40c:	4606      	mov	r6, r0
 801f40e:	460f      	mov	r7, r1
 801f410:	ec51 0b1d 	vmov	r0, r1, d13
 801f414:	f009 fba8 	bl	8028b68 <__aeabi_dmul>
 801f418:	4602      	mov	r2, r0
 801f41a:	460b      	mov	r3, r1
 801f41c:	4630      	mov	r0, r6
 801f41e:	4639      	mov	r1, r7
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 801f420:	e9da 8900 	ldrd	r8, r9, [sl]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f424:	f009 f9e8 	bl	80287f8 <__aeabi_dsub>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801f428:	4642      	mov	r2, r8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f42a:	4606      	mov	r6, r0
 801f42c:	460f      	mov	r7, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801f42e:	464b      	mov	r3, r9
 801f430:	ec51 0b1c 	vmov	r0, r1, d12
 801f434:	f009 fb98 	bl	8028b68 <__aeabi_dmul>
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801f438:	ed9a ab02 	vldr	d10, [sl, #8]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801f43c:	e9cd 0100 	strd	r0, r1, [sp]
 801f440:	ec53 2b1a 	vmov	r2, r3, d10
 801f444:	ec51 0b1b 	vmov	r0, r1, d11
 801f448:	f009 fb8e 	bl	8028b68 <__aeabi_dmul>
 801f44c:	4602      	mov	r2, r0
 801f44e:	460b      	mov	r3, r1
 801f450:	e9dd 0100 	ldrd	r0, r1, [sp]
 801f454:	f009 f9d0 	bl	80287f8 <__aeabi_dsub>
 801f458:	4602      	mov	r2, r0
 801f45a:	460b      	mov	r3, r1
 801f45c:	4630      	mov	r0, r6
 801f45e:	4639      	mov	r1, r7
 801f460:	f009 f9cc 	bl	80287fc <__adddf3>
 801f464:	4602      	mov	r2, r0
 801f466:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f468:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801f46c:	f009 f9c6 	bl	80287fc <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f470:	ec53 2b19 	vmov	r2, r3, d9
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801f474:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f478:	ec51 0b1f 	vmov	r0, r1, d15
 801f47c:	f009 fb74 	bl	8028b68 <__aeabi_dmul>
 801f480:	ec53 2b1e 	vmov	r2, r3, d14
 801f484:	4606      	mov	r6, r0
 801f486:	460f      	mov	r7, r1
 801f488:	ec51 0b1d 	vmov	r0, r1, d13
 801f48c:	f009 fb6c 	bl	8028b68 <__aeabi_dmul>
 801f490:	4602      	mov	r2, r0
 801f492:	460b      	mov	r3, r1
 801f494:	4630      	mov	r0, r6
 801f496:	4639      	mov	r1, r7
 801f498:	f009 f9b0 	bl	80287fc <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801f49c:	ec53 2b1a 	vmov	r2, r3, d10
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f4a0:	4606      	mov	r6, r0
 801f4a2:	460f      	mov	r7, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801f4a4:	ec51 0b1c 	vmov	r0, r1, d12
 801f4a8:	f009 fb5e 	bl	8028b68 <__aeabi_dmul>
 801f4ac:	4642      	mov	r2, r8
 801f4ae:	464b      	mov	r3, r9
 801f4b0:	4680      	mov	r8, r0
 801f4b2:	4689      	mov	r9, r1
 801f4b4:	ec51 0b1b 	vmov	r0, r1, d11
 801f4b8:	f009 fb56 	bl	8028b68 <__aeabi_dmul>
 801f4bc:	4602      	mov	r2, r0
 801f4be:	460b      	mov	r3, r1
 801f4c0:	4640      	mov	r0, r8
 801f4c2:	4649      	mov	r1, r9
 801f4c4:	f009 f99a 	bl	80287fc <__adddf3>
 801f4c8:	4602      	mov	r2, r0
 801f4ca:	460b      	mov	r3, r1
 801f4cc:	4630      	mov	r0, r6
 801f4ce:	4639      	mov	r1, r7
 801f4d0:	f009 f994 	bl	80287fc <__adddf3>
 801f4d4:	460b      	mov	r3, r1
 801f4d6:	4602      	mov	r2, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f4d8:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801f4dc:	f009 f98e 	bl	80287fc <__adddf3>
          for (j = 0; j < i; j++) {
 801f4e0:	9b03      	ldr	r3, [sp, #12]
 801f4e2:	f10a 0a10 	add.w	sl, sl, #16
 801f4e6:	4553      	cmp	r3, sl
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801f4e8:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j < i; j++) {
 801f4ec:	f105 0510 	add.w	r5, r5, #16
 801f4f0:	f104 0410 	add.w	r4, r4, #16
 801f4f4:	f10b 0b10 	add.w	fp, fp, #16
 801f4f8:	f47f af74 	bne.w	801f3e4 <cblas_zher2k+0x654>
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f4fc:	ec53 2b1f 	vmov	r2, r3, d15
 801f500:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801f504:	f009 fb30 	bl	8028b68 <__aeabi_dmul>
 801f508:	ec53 2b1d 	vmov	r2, r3, d13
 801f50c:	4604      	mov	r4, r0
 801f50e:	460d      	mov	r5, r1
 801f510:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801f514:	f009 fb28 	bl	8028b68 <__aeabi_dmul>
 801f518:	4602      	mov	r2, r0
 801f51a:	460b      	mov	r3, r1
 801f51c:	4620      	mov	r0, r4
 801f51e:	4629      	mov	r1, r5
 801f520:	f009 f96a 	bl	80287f8 <__aeabi_dsub>
 801f524:	4602      	mov	r2, r0
 801f526:	460b      	mov	r3, r1
 801f528:	f009 f968 	bl	80287fc <__adddf3>
 801f52c:	9c08      	ldr	r4, [sp, #32]
 801f52e:	4602      	mov	r2, r0
 801f530:	460b      	mov	r3, r1
 801f532:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801f536:	f009 f961 	bl	80287fc <__adddf3>
 801f53a:	9b03      	ldr	r3, [sp, #12]
 801f53c:	9d16      	ldr	r5, [sp, #88]	; 0x58
        for (i = 0; i < N; i++) {
 801f53e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801f540:	3310      	adds	r3, #16
 801f542:	9303      	str	r3, [sp, #12]
 801f544:	9b04      	ldr	r3, [sp, #16]
 801f546:	3310      	adds	r3, #16
 801f548:	9304      	str	r3, [sp, #16]
 801f54a:	9b06      	ldr	r3, [sp, #24]
 801f54c:	442b      	add	r3, r5
 801f54e:	9306      	str	r3, [sp, #24]
 801f550:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801f552:	18e3      	adds	r3, r4, r3
 801f554:	9308      	str	r3, [sp, #32]
 801f556:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f558:	3201      	adds	r2, #1
 801f55a:	4293      	cmp	r3, r2
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801f55c:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + i) = 0.0;
 801f560:	ed84 8b00 	vstr	d8, [r4]
        for (i = 0; i < N; i++) {
 801f564:	9212      	str	r2, [sp, #72]	; 0x48
 801f566:	f47f aeb1 	bne.w	801f2cc <cblas_zher2k+0x53c>
      for (k = 0; k < K; k++) {
 801f56a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 801f56c:	9921      	ldr	r1, [sp, #132]	; 0x84
 801f56e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801f570:	440a      	add	r2, r1
 801f572:	921b      	str	r2, [sp, #108]	; 0x6c
 801f574:	9918      	ldr	r1, [sp, #96]	; 0x60
 801f576:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801f578:	440a      	add	r2, r1
 801f57a:	921f      	str	r2, [sp, #124]	; 0x7c
 801f57c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801f57e:	3301      	adds	r3, #1
 801f580:	429a      	cmp	r2, r3
 801f582:	9320      	str	r3, [sp, #128]	; 0x80
 801f584:	f47f ae91 	bne.w	801f2aa <cblas_zher2k+0x51a>
 801f588:	b02b      	add	sp, #172	; 0xac
 801f58a:	ecbd 8b10 	vpop	{d8-d15}
 801f58e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801f592:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801f594:	4293      	cmp	r3, r2
 801f596:	dc0b      	bgt.n	801f5b0 <cblas_zher2k+0x820>
 801f598:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f59a:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801f59c:	2b01      	cmp	r3, #1
 801f59e:	bfb8      	it	lt
 801f5a0:	2301      	movlt	r3, #1
 801f5a2:	4293      	cmp	r3, r2
 801f5a4:	f300 8087 	bgt.w	801f6b6 <cblas_zher2k+0x926>
 801f5a8:	2800      	cmp	r0, #0
 801f5aa:	f43f ac3c 	beq.w	801ee26 <cblas_zher2k+0x96>
 801f5ae:	e436      	b.n	801ee1e <cblas_zher2k+0x8e>
 801f5b0:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801f5b2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801f5b4:	2801      	cmp	r0, #1
 801f5b6:	bfb8      	it	lt
 801f5b8:	2001      	movlt	r0, #1
 801f5ba:	4283      	cmp	r3, r0
 801f5bc:	bfb4      	ite	lt
 801f5be:	200e      	movlt	r0, #14
 801f5c0:	200b      	movge	r0, #11
 801f5c2:	e42c      	b.n	801ee1e <cblas_zher2k+0x8e>
 801f5c4:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 801f5c8:	2801      	cmp	r0, #1
 801f5ca:	bf94      	ite	ls
 801f5cc:	2000      	movls	r0, #0
 801f5ce:	2001      	movhi	r0, #1
 801f5d0:	e405      	b.n	801edde <cblas_zher2k+0x4e>
    } else if (beta != 1.0) {
 801f5d2:	4b3d      	ldr	r3, [pc, #244]	; (801f6c8 <cblas_zher2k+0x938>)
 801f5d4:	2200      	movs	r2, #0
 801f5d6:	4650      	mov	r0, sl
 801f5d8:	4659      	mov	r1, fp
 801f5da:	f009 fd2d 	bl	8029038 <__aeabi_dcmpeq>
 801f5de:	2800      	cmp	r0, #0
 801f5e0:	d14f      	bne.n	801f682 <cblas_zher2k+0x8f2>
      if (uplo == CblasUpper) {
 801f5e2:	9b00      	ldr	r3, [sp, #0]
 801f5e4:	2b79      	cmp	r3, #121	; 0x79
        for (i = 0; i < N; i++) {
 801f5e6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
      if (uplo == CblasUpper) {
 801f5e8:	f000 8292 	beq.w	801fb10 <cblas_zher2k+0xd80>
        for (i = 0; i < N; i++) {
 801f5ec:	2b00      	cmp	r3, #0
 801f5ee:	f77f ac7c 	ble.w	801eeea <cblas_zher2k+0x15a>
 801f5f2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801f5f4:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801f5f6:	1c5e      	adds	r6, r3, #1
          IMAG(C, ldc * i + i) = 0.0;
 801f5f8:	ed9f 8b31 	vldr	d8, [pc, #196]	; 801f6c0 <cblas_zher2k+0x930>
 801f5fc:	0131      	lsls	r1, r6, #4
 801f5fe:	f102 0708 	add.w	r7, r2, #8
 801f602:	971c      	str	r7, [sp, #112]	; 0x70
        for (i = 0; i < N; i++) {
 801f604:	4681      	mov	r9, r0
 801f606:	9112      	str	r1, [sp, #72]	; 0x48
 801f608:	eb02 1606 	add.w	r6, r2, r6, lsl #4
 801f60c:	4698      	mov	r8, r3
          REAL(C, ldc * i + i) *= beta;
 801f60e:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 801f612:	465b      	mov	r3, fp
 801f614:	4652      	mov	r2, sl
 801f616:	f009 faa7 	bl	8028b68 <__aeabi_dmul>
        for (i = 0; i < N; i++) {
 801f61a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f61c:	f109 0901 	add.w	r9, r9, #1
 801f620:	454b      	cmp	r3, r9
          REAL(C, ldc * i + i) *= beta;
 801f622:	e947 0102 	strd	r0, r1, [r7, #-8]
          IMAG(C, ldc * i + i) = 0.0;
 801f626:	ed87 8b00 	vstr	d8, [r7]
        for (i = 0; i < N; i++) {
 801f62a:	f43f ac5e 	beq.w	801eeea <cblas_zher2k+0x15a>
          for (j = 0; j < i; j++) {
 801f62e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801f630:	eb03 1408 	add.w	r4, r3, r8, lsl #4
 801f634:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801f636:	eb03 1508 	add.w	r5, r3, r8, lsl #4
            REAL(C, ldc * i + j) *= beta;
 801f63a:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 801f63e:	4652      	mov	r2, sl
 801f640:	465b      	mov	r3, fp
 801f642:	f009 fa91 	bl	8028b68 <__aeabi_dmul>
 801f646:	e945 0102 	strd	r0, r1, [r5, #-8]
            IMAG(C, ldc * i + j) *= beta;
 801f64a:	4652      	mov	r2, sl
 801f64c:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801f650:	465b      	mov	r3, fp
 801f652:	f009 fa89 	bl	8028b68 <__aeabi_dmul>
 801f656:	3410      	adds	r4, #16
 801f658:	e944 0102 	strd	r0, r1, [r4, #-8]
          for (j = 0; j < i; j++) {
 801f65c:	42a6      	cmp	r6, r4
 801f65e:	f105 0510 	add.w	r5, r5, #16
 801f662:	d1ea      	bne.n	801f63a <cblas_zher2k+0x8aa>
 801f664:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801f666:	4498      	add	r8, r3
 801f668:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801f66a:	441e      	add	r6, r3
 801f66c:	441f      	add	r7, r3
 801f66e:	e7ce      	b.n	801f60e <cblas_zher2k+0x87e>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801f670:	2a6f      	cmp	r2, #111	; 0x6f
 801f672:	f000 824a 	beq.w	801fb0a <cblas_zher2k+0xd7a>
 801f676:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f678:	f7ff bbab 	b.w	801edd2 <cblas_zher2k+0x42>
      uplo = Uplo;
 801f67c:	9700      	str	r7, [sp, #0]
      trans = Trans;
 801f67e:	9403      	str	r4, [sp, #12]
 801f680:	e408      	b.n	801ee94 <cblas_zher2k+0x104>
      for (i = 0; i < N; i++) {
 801f682:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f684:	2b00      	cmp	r3, #0
 801f686:	dd0c      	ble.n	801f6a2 <cblas_zher2k+0x912>
 801f688:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801f68a:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 801f68c:	1c5a      	adds	r2, r3, #1
 801f68e:	9b19      	ldr	r3, [sp, #100]	; 0x64
        IMAG(C, ldc * i + i) = 0.0;
 801f690:	2000      	movs	r0, #0
 801f692:	2100      	movs	r1, #0
 801f694:	0112      	lsls	r2, r2, #4
      for (i = 0; i < N; i++) {
 801f696:	3401      	adds	r4, #1
 801f698:	42a5      	cmp	r5, r4
        IMAG(C, ldc * i + i) = 0.0;
 801f69a:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (i = 0; i < N; i++) {
 801f69e:	4413      	add	r3, r2
 801f6a0:	d1f9      	bne.n	801f696 <cblas_zher2k+0x906>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801f6a2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 801f6a6:	2200      	movs	r2, #0
 801f6a8:	2300      	movs	r3, #0
 801f6aa:	f009 fcc5 	bl	8029038 <__aeabi_dcmpeq>
 801f6ae:	2800      	cmp	r0, #0
 801f6b0:	f43f ac2b 	beq.w	801ef0a <cblas_zher2k+0x17a>
 801f6b4:	e420      	b.n	801eef8 <cblas_zher2k+0x168>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801f6b6:	200e      	movs	r0, #14
 801f6b8:	f7ff bbb1 	b.w	801ee1e <cblas_zher2k+0x8e>
 801f6bc:	f3af 8000 	nop.w
	...
 801f6c8:	3ff00000 	.word	0x3ff00000
      for (i = 0; i < N; i++) {
 801f6cc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801f6ce:	2b00      	cmp	r3, #0
 801f6d0:	f77f af5a 	ble.w	801f588 <cblas_zher2k+0x7f8>
 801f6d4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801f6d6:	9819      	ldr	r0, [sp, #100]	; 0x64
 801f6d8:	0119      	lsls	r1, r3, #4
 801f6da:	9126      	str	r1, [sp, #152]	; 0x98
 801f6dc:	3110      	adds	r1, #16
 801f6de:	9123      	str	r1, [sp, #140]	; 0x8c
 801f6e0:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801f6e2:	f1a0 0310 	sub.w	r3, r0, #16
 801f6e6:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 801f6ea:	931e      	str	r3, [sp, #120]	; 0x78
 801f6ec:	f100 0308 	add.w	r3, r0, #8
 801f6f0:	931f      	str	r3, [sp, #124]	; 0x7c
 801f6f2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801f6f4:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801f6f6:	011b      	lsls	r3, r3, #4
 801f6f8:	9325      	str	r3, [sp, #148]	; 0x94
 801f6fa:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801f6fc:	011b      	lsls	r3, r3, #4
 801f6fe:	9324      	str	r3, [sp, #144]	; 0x90
 801f700:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801f702:	2200      	movs	r2, #0
 801f704:	9221      	str	r2, [sp, #132]	; 0x84
 801f706:	9222      	str	r2, [sp, #136]	; 0x88
 801f708:	9220      	str	r2, [sp, #128]	; 0x80
 801f70a:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 801f70e:	920a      	str	r2, [sp, #40]	; 0x28
 801f710:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801f712:	e9cd 231c 	strd	r2, r3, [sp, #112]	; 0x70
          for (k = 0; k < K; k++) {
 801f716:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801f718:	2b00      	cmp	r3, #0
 801f71a:	f340 8232 	ble.w	801fb82 <cblas_zher2k+0xdf2>
          BASE temp_real = 0.0;
 801f71e:	ed9f 7bd4 	vldr	d7, [pc, #848]	; 801fa70 <cblas_zher2k+0xce0>
          for (k = 0; k < K; k++) {
 801f722:	e9dd ba1c 	ldrd	fp, sl, [sp, #112]	; 0x70
          BASE temp_real = 0.0;
 801f726:	eeb0 aa47 	vmov.f32	s20, s14
 801f72a:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f72e:	e9da 6700 	ldrd	r6, r7, [sl]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f732:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
 801f736:	4632      	mov	r2, r6
 801f738:	463b      	mov	r3, r7
 801f73a:	ec51 0b19 	vmov	r0, r1, d9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801f73e:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f742:	f009 fa11 	bl	8028b68 <__aeabi_dmul>
 801f746:	ed9d 8b10 	vldr	d8, [sp, #64]	; 0x40
 801f74a:	4642      	mov	r2, r8
 801f74c:	464b      	mov	r3, r9
 801f74e:	4604      	mov	r4, r0
 801f750:	460d      	mov	r5, r1
 801f752:	ec51 0b18 	vmov	r0, r1, d8
 801f756:	f009 fa07 	bl	8028b68 <__aeabi_dmul>
 801f75a:	4602      	mov	r2, r0
 801f75c:	460b      	mov	r3, r1
 801f75e:	4620      	mov	r0, r4
 801f760:	4629      	mov	r1, r5
 801f762:	f009 f849 	bl	80287f8 <__aeabi_dsub>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801f766:	e9db 2300 	ldrd	r2, r3, [fp]
 801f76a:	f009 f9fd 	bl	8028b68 <__aeabi_dmul>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f76e:	4642      	mov	r2, r8
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801f770:	4604      	mov	r4, r0
 801f772:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f774:	464b      	mov	r3, r9
 801f776:	ec51 0b19 	vmov	r0, r1, d9
 801f77a:	f009 f9f5 	bl	8028b68 <__aeabi_dmul>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801f77e:	46a0      	mov	r8, r4
 801f780:	46a9      	mov	r9, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f782:	4632      	mov	r2, r6
 801f784:	463b      	mov	r3, r7
 801f786:	4604      	mov	r4, r0
 801f788:	460d      	mov	r5, r1
 801f78a:	ec51 0b18 	vmov	r0, r1, d8
 801f78e:	f009 f9eb 	bl	8028b68 <__aeabi_dmul>
 801f792:	4602      	mov	r2, r0
 801f794:	460b      	mov	r3, r1
 801f796:	4620      	mov	r0, r4
 801f798:	4629      	mov	r1, r5
 801f79a:	f009 f82f 	bl	80287fc <__adddf3>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801f79e:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801f7a2:	f009 f9e1 	bl	8028b68 <__aeabi_dmul>
 801f7a6:	4602      	mov	r2, r0
 801f7a8:	460b      	mov	r3, r1
 801f7aa:	4640      	mov	r0, r8
 801f7ac:	4649      	mov	r1, r9
 801f7ae:	f009 f825 	bl	80287fc <__adddf3>
 801f7b2:	4602      	mov	r2, r0
 801f7b4:	460b      	mov	r3, r1
 801f7b6:	ec51 0b1a 	vmov	r0, r1, d10
 801f7ba:	f009 f81f 	bl	80287fc <__adddf3>
 801f7be:	460b      	mov	r3, r1
 801f7c0:	4602      	mov	r2, r0
 801f7c2:	ec43 2b1a 	vmov	d10, r2, r3
          for (k = 0; k < K; k++) {
 801f7c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f7c8:	f10a 0a10 	add.w	sl, sl, #16
 801f7cc:	4553      	cmp	r3, sl
 801f7ce:	f10b 0b10 	add.w	fp, fp, #16
 801f7d2:	d1ac      	bne.n	801f72e <cblas_zher2k+0x99e>
 801f7d4:	ec53 2b1a 	vmov	r2, r3, d10
 801f7d8:	f009 f810 	bl	80287fc <__adddf3>
 801f7dc:	4602      	mov	r2, r0
 801f7de:	460b      	mov	r3, r1
          REAL(C, i * ldc + i) += 2 * temp_real;
 801f7e0:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 801f7e2:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801f7e6:	f009 f809 	bl	80287fc <__adddf3>
        for (j = i + 1; j < N; j++) {
 801f7ea:	9d20      	ldr	r5, [sp, #128]	; 0x80
 801f7ec:	9a13      	ldr	r2, [sp, #76]	; 0x4c
          IMAG(C, i * ldc + i) = 0.0;
 801f7ee:	ed9f 7ba0 	vldr	d7, [pc, #640]	; 801fa70 <cblas_zher2k+0xce0>
        for (j = i + 1; j < N; j++) {
 801f7f2:	3501      	adds	r5, #1
 801f7f4:	42aa      	cmp	r2, r5
          REAL(C, i * ldc + i) += 2 * temp_real;
 801f7f6:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(C, i * ldc + i) = 0.0;
 801f7fa:	ed84 7b00 	vstr	d7, [r4]
        for (j = i + 1; j < N; j++) {
 801f7fe:	9520      	str	r5, [sp, #128]	; 0x80
 801f800:	f43f aec2 	beq.w	801f588 <cblas_zher2k+0x7f8>
 801f804:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801f806:	9916      	ldr	r1, [sp, #88]	; 0x58
 801f808:	9818      	ldr	r0, [sp, #96]	; 0x60
 801f80a:	440a      	add	r2, r1
 801f80c:	9921      	ldr	r1, [sp, #132]	; 0x84
 801f80e:	9222      	str	r2, [sp, #136]	; 0x88
 801f810:	4401      	add	r1, r0
 801f812:	f1a4 0308 	sub.w	r3, r4, #8
 801f816:	9121      	str	r1, [sp, #132]	; 0x84
 801f818:	910c      	str	r1, [sp, #48]	; 0x30
 801f81a:	9214      	str	r2, [sp, #80]	; 0x50
 801f81c:	9319      	str	r3, [sp, #100]	; 0x64
          BASE temp_imag = 0.0;
 801f81e:	ed9f 7b94 	vldr	d7, [pc, #592]	; 801fa70 <cblas_zher2k+0xce0>
          for (k = 0; k < K; k++) {
 801f822:	9b17      	ldr	r3, [sp, #92]	; 0x5c
          BASE temp_imag = 0.0;
 801f824:	eeb0 fa47 	vmov.f32	s30, s14
 801f828:	eef0 fa67 	vmov.f32	s31, s15
          for (k = 0; k < K; k++) {
 801f82c:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 801f82e:	eeb0 ea47 	vmov.f32	s28, s14
 801f832:	eef0 ea67 	vmov.f32	s29, s15
          for (k = 0; k < K; k++) {
 801f836:	f340 811f 	ble.w	801fa78 <cblas_zher2k+0xce8>
 801f83a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801f83c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801f83e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801f842:	9312      	str	r3, [sp, #72]	; 0x48
 801f844:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801f846:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801f848:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801f84c:	9304      	str	r3, [sp, #16]
 801f84e:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801f852:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801f854:	9300      	str	r3, [sp, #0]
 801f856:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801f858:	9303      	str	r3, [sp, #12]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f85a:	9c03      	ldr	r4, [sp, #12]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f85c:	ed9d 8b0e 	vldr	d8, [sp, #56]	; 0x38
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f860:	e9d4 6700 	ldrd	r6, r7, [r4]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f864:	ec51 0b18 	vmov	r0, r1, d8
 801f868:	4632      	mov	r2, r6
 801f86a:	463b      	mov	r3, r7
 801f86c:	f009 f97c 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801f870:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f874:	460d      	mov	r5, r1
 801f876:	4642      	mov	r2, r8
 801f878:	464b      	mov	r3, r9
 801f87a:	4604      	mov	r4, r0
 801f87c:	4659      	mov	r1, fp
 801f87e:	4650      	mov	r0, sl
 801f880:	f009 f972 	bl	8028b68 <__aeabi_dmul>
 801f884:	4602      	mov	r2, r0
 801f886:	460b      	mov	r3, r1
 801f888:	4620      	mov	r0, r4
 801f88a:	4629      	mov	r1, r5
 801f88c:	f008 ffb4 	bl	80287f8 <__aeabi_dsub>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f890:	4642      	mov	r2, r8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f892:	4604      	mov	r4, r0
 801f894:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f896:	464b      	mov	r3, r9
 801f898:	ec51 0b18 	vmov	r0, r1, d8
 801f89c:	f009 f964 	bl	8028b68 <__aeabi_dmul>
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f8a0:	ec45 4b1c 	vmov	d12, r4, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f8a4:	4632      	mov	r2, r6
 801f8a6:	463b      	mov	r3, r7
 801f8a8:	4604      	mov	r4, r0
 801f8aa:	460d      	mov	r5, r1
 801f8ac:	4650      	mov	r0, sl
 801f8ae:	4659      	mov	r1, fp
 801f8b0:	f009 f95a 	bl	8028b68 <__aeabi_dmul>
 801f8b4:	4602      	mov	r2, r0
 801f8b6:	460b      	mov	r3, r1
 801f8b8:	4620      	mov	r0, r4
 801f8ba:	4629      	mov	r1, r5
 801f8bc:	f008 ff9e 	bl	80287fc <__adddf3>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801f8c0:	9e12      	ldr	r6, [sp, #72]	; 0x48
 801f8c2:	ed96 bb00 	vldr	d11, [r6]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f8c6:	4604      	mov	r4, r0
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f8c8:	ec53 2b1b 	vmov	r2, r3, d11
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f8cc:	460d      	mov	r5, r1
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f8ce:	ec51 0b18 	vmov	r0, r1, d8
 801f8d2:	f009 f949 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801f8d6:	e9d6 8902 	ldrd	r8, r9, [r6, #8]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f8da:	ec45 4b1a 	vmov	d10, r4, r5
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f8de:	4642      	mov	r2, r8
 801f8e0:	464b      	mov	r3, r9
 801f8e2:	4604      	mov	r4, r0
 801f8e4:	460d      	mov	r5, r1
 801f8e6:	4650      	mov	r0, sl
 801f8e8:	4659      	mov	r1, fp
 801f8ea:	f009 f93d 	bl	8028b68 <__aeabi_dmul>
 801f8ee:	4602      	mov	r2, r0
 801f8f0:	460b      	mov	r3, r1
 801f8f2:	4620      	mov	r0, r4
 801f8f4:	4629      	mov	r1, r5
 801f8f6:	f008 ff7f 	bl	80287f8 <__aeabi_dsub>
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f8fa:	4642      	mov	r2, r8
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f8fc:	4604      	mov	r4, r0
 801f8fe:	460d      	mov	r5, r1
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f900:	464b      	mov	r3, r9
 801f902:	ec51 0b18 	vmov	r0, r1, d8
 801f906:	f009 f92f 	bl	8028b68 <__aeabi_dmul>
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f90a:	ec45 4b19 	vmov	d9, r4, r5
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f90e:	ec53 2b1b 	vmov	r2, r3, d11
 801f912:	4604      	mov	r4, r0
 801f914:	460d      	mov	r5, r1
 801f916:	4650      	mov	r0, sl
 801f918:	4659      	mov	r1, fp
 801f91a:	f009 f925 	bl	8028b68 <__aeabi_dmul>
 801f91e:	4602      	mov	r2, r0
 801f920:	460b      	mov	r3, r1
 801f922:	4620      	mov	r0, r4
 801f924:	4629      	mov	r1, r5
 801f926:	f008 ff69 	bl	80287fc <__adddf3>
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801f92a:	9f04      	ldr	r7, [sp, #16]
 801f92c:	ed97 7b00 	vldr	d7, [r7]
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f930:	4604      	mov	r4, r0
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f932:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801f936:	eeb0 ba47 	vmov.f32	s22, s14
 801f93a:	eef0 ba67 	vmov.f32	s23, s15
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f93e:	460d      	mov	r5, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f940:	ec51 0b1c 	vmov	r0, r1, d12
 801f944:	f009 f910 	bl	8028b68 <__aeabi_dmul>
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 801f948:	e9d7 8902 	ldrd	r8, r9, [r7, #8]
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f94c:	ec41 0b1d 	vmov	d13, r0, r1
 801f950:	4642      	mov	r2, r8
 801f952:	464b      	mov	r3, r9
 801f954:	ec51 0b1a 	vmov	r0, r1, d10
 801f958:	f009 f906 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801f95c:	9e00      	ldr	r6, [sp, #0]
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f95e:	4602      	mov	r2, r0
 801f960:	460b      	mov	r3, r1
 801f962:	ec51 0b1d 	vmov	r0, r1, d13
 801f966:	f008 ff49 	bl	80287fc <__adddf3>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801f96a:	ed96 8b00 	vldr	d8, [r6]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f96e:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f972:	4606      	mov	r6, r0
 801f974:	460f      	mov	r7, r1
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f976:	ec51 0b18 	vmov	r0, r1, d8
 801f97a:	f009 f8f5 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801f97e:	9b00      	ldr	r3, [sp, #0]
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f980:	f8cd 8018 	str.w	r8, [sp, #24]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801f984:	ed93 6b02 	vldr	d6, [r3, #8]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f988:	ec41 0b1d 	vmov	d13, r0, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f98c:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f990:	ec59 8b16 	vmov	r8, r9, d6
 801f994:	ee16 0a10 	vmov	r0, s12
 801f998:	4622      	mov	r2, r4
 801f99a:	462b      	mov	r3, r5
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f99c:	9107      	str	r1, [sp, #28]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f99e:	4649      	mov	r1, r9
 801f9a0:	f009 f8e2 	bl	8028b68 <__aeabi_dmul>
 801f9a4:	4602      	mov	r2, r0
 801f9a6:	460b      	mov	r3, r1
 801f9a8:	ec51 0b1d 	vmov	r0, r1, d13
 801f9ac:	f008 ff26 	bl	80287fc <__adddf3>
 801f9b0:	4602      	mov	r2, r0
 801f9b2:	460b      	mov	r3, r1
 801f9b4:	4630      	mov	r0, r6
 801f9b6:	4639      	mov	r1, r7
 801f9b8:	f008 ff20 	bl	80287fc <__adddf3>
 801f9bc:	4602      	mov	r2, r0
 801f9be:	460b      	mov	r3, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f9c0:	ec51 0b1e 	vmov	r0, r1, d14
 801f9c4:	f008 ff1a 	bl	80287fc <__adddf3>
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f9c8:	ec53 2b1c 	vmov	r2, r3, d12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f9cc:	4606      	mov	r6, r0
 801f9ce:	460f      	mov	r7, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f9d0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801f9d4:	f009 f8c8 	bl	8028b68 <__aeabi_dmul>
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f9d8:	ec47 6b1e 	vmov	d14, r6, r7
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f9dc:	ec53 2b1b 	vmov	r2, r3, d11
 801f9e0:	4606      	mov	r6, r0
 801f9e2:	460f      	mov	r7, r1
 801f9e4:	ec51 0b1a 	vmov	r0, r1, d10
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f9e8:	9408      	str	r4, [sp, #32]
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f9ea:	f009 f8bd 	bl	8028b68 <__aeabi_dmul>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f9ee:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f9f2:	4602      	mov	r2, r0
 801f9f4:	460b      	mov	r3, r1
 801f9f6:	4630      	mov	r0, r6
 801f9f8:	4639      	mov	r1, r7
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f9fa:	9509      	str	r5, [sp, #36]	; 0x24
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f9fc:	f008 fefe 	bl	80287fc <__adddf3>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801fa00:	ec53 2b18 	vmov	r2, r3, d8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fa04:	4604      	mov	r4, r0
 801fa06:	460d      	mov	r5, r1
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801fa08:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801fa0c:	f009 f8ac 	bl	8028b68 <__aeabi_dmul>
 801fa10:	ec53 2b19 	vmov	r2, r3, d9
 801fa14:	4606      	mov	r6, r0
 801fa16:	460f      	mov	r7, r1
 801fa18:	4640      	mov	r0, r8
 801fa1a:	4649      	mov	r1, r9
 801fa1c:	f009 f8a4 	bl	8028b68 <__aeabi_dmul>
 801fa20:	4602      	mov	r2, r0
 801fa22:	460b      	mov	r3, r1
 801fa24:	4630      	mov	r0, r6
 801fa26:	4639      	mov	r1, r7
 801fa28:	f008 fee8 	bl	80287fc <__adddf3>
 801fa2c:	4602      	mov	r2, r0
 801fa2e:	460b      	mov	r3, r1
 801fa30:	4620      	mov	r0, r4
 801fa32:	4629      	mov	r1, r5
 801fa34:	f008 fee2 	bl	80287fc <__adddf3>
 801fa38:	4602      	mov	r2, r0
 801fa3a:	460b      	mov	r3, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fa3c:	ec51 0b1f 	vmov	r0, r1, d15
 801fa40:	f008 fedc 	bl	80287fc <__adddf3>
 801fa44:	9b00      	ldr	r3, [sp, #0]
 801fa46:	9c03      	ldr	r4, [sp, #12]
 801fa48:	9e12      	ldr	r6, [sp, #72]	; 0x48
 801fa4a:	9f04      	ldr	r7, [sp, #16]
 801fa4c:	3310      	adds	r3, #16
 801fa4e:	9300      	str	r3, [sp, #0]
          for (k = 0; k < K; k++) {
 801fa50:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801fa52:	f104 0210 	add.w	r2, r4, #16
 801fa56:	f106 0410 	add.w	r4, r6, #16
 801fa5a:	9412      	str	r4, [sp, #72]	; 0x48
 801fa5c:	4293      	cmp	r3, r2
 801fa5e:	f107 0410 	add.w	r4, r7, #16
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fa62:	ec41 0b1f 	vmov	d15, r0, r1
          for (k = 0; k < K; k++) {
 801fa66:	9203      	str	r2, [sp, #12]
 801fa68:	9404      	str	r4, [sp, #16]
 801fa6a:	f47f aef6 	bne.w	801f85a <cblas_zher2k+0xaca>
 801fa6e:	e003      	b.n	801fa78 <cblas_zher2k+0xce8>
	...
          REAL(C, i * ldc + j) += temp_real;
 801fa78:	9c19      	ldr	r4, [sp, #100]	; 0x64
 801fa7a:	ec53 2b1e 	vmov	r2, r3, d14
 801fa7e:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801fa82:	f008 febb 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += temp_imag;
 801fa86:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(C, i * ldc + j) += temp_real;
 801fa8a:	e9c4 0104 	strd	r0, r1, [r4, #16]
          IMAG(C, i * ldc + j) += temp_imag;
 801fa8e:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801fa92:	f008 feb3 	bl	80287fc <__adddf3>
 801fa96:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801fa98:	e9c4 0106 	strd	r0, r1, [r4, #24]
        for (j = i + 1; j < N; j++) {
 801fa9c:	9916      	ldr	r1, [sp, #88]	; 0x58
 801fa9e:	440a      	add	r2, r1
 801faa0:	9214      	str	r2, [sp, #80]	; 0x50
 801faa2:	9918      	ldr	r1, [sp, #96]	; 0x60
 801faa4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801faa6:	440a      	add	r2, r1
 801faa8:	920c      	str	r2, [sp, #48]	; 0x30
 801faaa:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801faac:	f104 0310 	add.w	r3, r4, #16
 801fab0:	429a      	cmp	r2, r3
 801fab2:	9319      	str	r3, [sp, #100]	; 0x64
 801fab4:	f47f aeb3 	bne.w	801f81e <cblas_zher2k+0xa8e>
 801fab8:	4613      	mov	r3, r2
 801faba:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801fabc:	4413      	add	r3, r2
 801fabe:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801fac0:	931e      	str	r3, [sp, #120]	; 0x78
 801fac2:	9b25      	ldr	r3, [sp, #148]	; 0x94
 801fac4:	4611      	mov	r1, r2
 801fac6:	4419      	add	r1, r3
 801fac8:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801faca:	911d      	str	r1, [sp, #116]	; 0x74
 801facc:	9924      	ldr	r1, [sp, #144]	; 0x90
 801face:	440a      	add	r2, r1
 801fad0:	921c      	str	r2, [sp, #112]	; 0x70
 801fad2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801fad4:	441a      	add	r2, r3
 801fad6:	920a      	str	r2, [sp, #40]	; 0x28
 801fad8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801fada:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801fadc:	4413      	add	r3, r2
 801fade:	931f      	str	r3, [sp, #124]	; 0x7c
 801fae0:	e619      	b.n	801f716 <cblas_zher2k+0x986>
      for (k = 0; k < K; k++) {
 801fae2:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801fae4:	9916      	ldr	r1, [sp, #88]	; 0x58
 801fae6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801fae8:	440a      	add	r2, r1
 801faea:	921c      	str	r2, [sp, #112]	; 0x70
 801faec:	9918      	ldr	r1, [sp, #96]	; 0x60
 801faee:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801faf0:	440a      	add	r2, r1
 801faf2:	9214      	str	r2, [sp, #80]	; 0x50
 801faf4:	991e      	ldr	r1, [sp, #120]	; 0x78
 801faf6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801faf8:	440a      	add	r2, r1
 801fafa:	920a      	str	r2, [sp, #40]	; 0x28
 801fafc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801fafe:	3301      	adds	r3, #1
 801fb00:	429a      	cmp	r2, r3
 801fb02:	931d      	str	r3, [sp, #116]	; 0x74
 801fb04:	f47f aa61 	bne.w	801efca <cblas_zher2k+0x23a>
 801fb08:	e53e      	b.n	801f588 <cblas_zher2k+0x7f8>
 801fb0a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801fb0c:	f7ff ba0f 	b.w	801ef2e <cblas_zher2k+0x19e>
        for (i = 0; i < N; i++) {
 801fb10:	2b00      	cmp	r3, #0
 801fb12:	f77f aa34 	ble.w	801ef7e <cblas_zher2k+0x1ee>
 801fb16:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801fb18:	ea4f 1802 	mov.w	r8, r2, lsl #4
 801fb1c:	9a19      	ldr	r2, [sp, #100]	; 0x64
          IMAG(C, ldc * i + i) = 0.0;
 801fb1e:	ed1f 8b2c 	vldr	d8, [pc, #-176]	; 801fa70 <cblas_zher2k+0xce0>
 801fb22:	f1a2 0510 	sub.w	r5, r2, #16
        for (i = 0; i < N; i++) {
 801fb26:	4607      	mov	r7, r0
 801fb28:	f108 0910 	add.w	r9, r8, #16
 801fb2c:	eb05 1503 	add.w	r5, r5, r3, lsl #4
 801fb30:	f102 0608 	add.w	r6, r2, #8
          REAL(C, ldc * i + i) *= beta;
 801fb34:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 801fb38:	465b      	mov	r3, fp
 801fb3a:	4652      	mov	r2, sl
 801fb3c:	f009 f814 	bl	8028b68 <__aeabi_dmul>
          for (j = i + 1; j < N; j++) {
 801fb40:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801fb42:	3701      	adds	r7, #1
 801fb44:	42bb      	cmp	r3, r7
          REAL(C, ldc * i + i) *= beta;
 801fb46:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, ldc * i + i) = 0.0;
 801fb4a:	ed86 8b00 	vstr	d8, [r6]
          for (j = i + 1; j < N; j++) {
 801fb4e:	f43f aa16 	beq.w	801ef7e <cblas_zher2k+0x1ee>
 801fb52:	f1a6 0408 	sub.w	r4, r6, #8
            REAL(C, ldc * i + j) *= beta;
 801fb56:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801fb5a:	4652      	mov	r2, sl
 801fb5c:	465b      	mov	r3, fp
 801fb5e:	f009 f803 	bl	8028b68 <__aeabi_dmul>
            IMAG(C, ldc * i + j) *= beta;
 801fb62:	4652      	mov	r2, sl
            REAL(C, ldc * i + j) *= beta;
 801fb64:	e9c4 0104 	strd	r0, r1, [r4, #16]
            IMAG(C, ldc * i + j) *= beta;
 801fb68:	465b      	mov	r3, fp
 801fb6a:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801fb6e:	f008 fffb 	bl	8028b68 <__aeabi_dmul>
 801fb72:	3410      	adds	r4, #16
 801fb74:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = i + 1; j < N; j++) {
 801fb78:	42a5      	cmp	r5, r4
 801fb7a:	d1ec      	bne.n	801fb56 <cblas_zher2k+0xdc6>
 801fb7c:	4445      	add	r5, r8
 801fb7e:	444e      	add	r6, r9
 801fb80:	e7d8      	b.n	801fb34 <cblas_zher2k+0xda4>
          for (k = 0; k < K; k++) {
 801fb82:	2200      	movs	r2, #0
 801fb84:	2300      	movs	r3, #0
 801fb86:	e62b      	b.n	801f7e0 <cblas_zher2k+0xa50>
      for (i = 0; i < N; i++) {
 801fb88:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801fb8a:	2b00      	cmp	r3, #0
 801fb8c:	f77f acfc 	ble.w	801f588 <cblas_zher2k+0x7f8>
 801fb90:	9c20      	ldr	r4, [sp, #128]	; 0x80
 801fb92:	9f19      	ldr	r7, [sp, #100]	; 0x64
 801fb94:	9424      	str	r4, [sp, #144]	; 0x90
 801fb96:	e9dd 5016 	ldrd	r5, r0, [sp, #88]	; 0x58
 801fb9a:	1c63      	adds	r3, r4, #1
 801fb9c:	011a      	lsls	r2, r3, #4
 801fb9e:	9229      	str	r2, [sp, #164]	; 0xa4
 801fba0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 801fba2:	1941      	adds	r1, r0, r5
 801fba4:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801fba8:	ebc0 7c00 	rsb	ip, r0, r0, lsl #28
 801fbac:	931e      	str	r3, [sp, #120]	; 0x78
 801fbae:	eb02 1301 	add.w	r3, r2, r1, lsl #4
 801fbb2:	9306      	str	r3, [sp, #24]
 801fbb4:	4663      	mov	r3, ip
 801fbb6:	2600      	movs	r6, #0
 801fbb8:	011b      	lsls	r3, r3, #4
 801fbba:	e9cd 6325 	strd	r6, r3, [sp, #148]	; 0x94
 801fbbe:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801fbc0:	9623      	str	r6, [sp, #140]	; 0x8c
 801fbc2:	0119      	lsls	r1, r3, #4
 801fbc4:	9128      	str	r1, [sp, #160]	; 0xa0
 801fbc6:	991a      	ldr	r1, [sp, #104]	; 0x68
 801fbc8:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 801fbcc:	931f      	str	r3, [sp, #124]	; 0x7c
 801fbce:	012b      	lsls	r3, r5, #4
 801fbd0:	9327      	str	r3, [sp, #156]	; 0x9c
 801fbd2:	eb02 1300 	add.w	r3, r2, r0, lsl #4
 801fbd6:	931d      	str	r3, [sp, #116]	; 0x74
 801fbd8:	f107 0308 	add.w	r3, r7, #8
 801fbdc:	9322      	str	r3, [sp, #136]	; 0x88
          for (k = 0; k < K; k++) {
 801fbde:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801fbe0:	2b00      	cmp	r3, #0
 801fbe2:	f340 81ea 	ble.w	801ffba <cblas_zher2k+0x122a>
 801fbe6:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fbe8:	9a1d      	ldr	r2, [sp, #116]	; 0x74
          BASE temp_real = 0.0;
 801fbea:	ed1f 7b5f 	vldr	d7, [pc, #-380]	; 801fa70 <cblas_zher2k+0xce0>
 801fbee:	eb03 0a02 	add.w	sl, r3, r2
 801fbf2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801fbf4:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801fbf6:	eeb0 aa47 	vmov.f32	s20, s14
 801fbfa:	eef0 aa67 	vmov.f32	s21, s15
 801fbfe:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801fc02:	e9da 6700 	ldrd	r6, r7, [sl]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fc06:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
 801fc0a:	4632      	mov	r2, r6
 801fc0c:	463b      	mov	r3, r7
 801fc0e:	ec51 0b19 	vmov	r0, r1, d9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801fc12:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fc16:	f008 ffa7 	bl	8028b68 <__aeabi_dmul>
 801fc1a:	ed9d 8b10 	vldr	d8, [sp, #64]	; 0x40
 801fc1e:	4642      	mov	r2, r8
 801fc20:	464b      	mov	r3, r9
 801fc22:	4604      	mov	r4, r0
 801fc24:	460d      	mov	r5, r1
 801fc26:	ec51 0b18 	vmov	r0, r1, d8
 801fc2a:	f008 ff9d 	bl	8028b68 <__aeabi_dmul>
 801fc2e:	4602      	mov	r2, r0
 801fc30:	460b      	mov	r3, r1
 801fc32:	4620      	mov	r0, r4
 801fc34:	4629      	mov	r1, r5
 801fc36:	f008 fddf 	bl	80287f8 <__aeabi_dsub>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801fc3a:	e9db 2300 	ldrd	r2, r3, [fp]
 801fc3e:	f008 ff93 	bl	8028b68 <__aeabi_dmul>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fc42:	4642      	mov	r2, r8
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801fc44:	4604      	mov	r4, r0
 801fc46:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fc48:	464b      	mov	r3, r9
 801fc4a:	ec51 0b19 	vmov	r0, r1, d9
 801fc4e:	f008 ff8b 	bl	8028b68 <__aeabi_dmul>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801fc52:	46a0      	mov	r8, r4
 801fc54:	46a9      	mov	r9, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fc56:	4632      	mov	r2, r6
 801fc58:	463b      	mov	r3, r7
 801fc5a:	4604      	mov	r4, r0
 801fc5c:	460d      	mov	r5, r1
 801fc5e:	ec51 0b18 	vmov	r0, r1, d8
 801fc62:	f008 ff81 	bl	8028b68 <__aeabi_dmul>
 801fc66:	4602      	mov	r2, r0
 801fc68:	460b      	mov	r3, r1
 801fc6a:	4620      	mov	r0, r4
 801fc6c:	4629      	mov	r1, r5
 801fc6e:	f008 fdc5 	bl	80287fc <__adddf3>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801fc72:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801fc76:	f008 ff77 	bl	8028b68 <__aeabi_dmul>
 801fc7a:	4602      	mov	r2, r0
 801fc7c:	460b      	mov	r3, r1
 801fc7e:	4640      	mov	r0, r8
 801fc80:	4649      	mov	r1, r9
 801fc82:	f008 fdbb 	bl	80287fc <__adddf3>
 801fc86:	4602      	mov	r2, r0
 801fc88:	460b      	mov	r3, r1
 801fc8a:	ec51 0b1a 	vmov	r0, r1, d10
 801fc8e:	f008 fdb5 	bl	80287fc <__adddf3>
 801fc92:	460b      	mov	r3, r1
 801fc94:	4602      	mov	r2, r0
 801fc96:	ec43 2b1a 	vmov	d10, r2, r3
          for (k = 0; k < K; k++) {
 801fc9a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801fc9c:	f10a 0a10 	add.w	sl, sl, #16
 801fca0:	4553      	cmp	r3, sl
 801fca2:	f10b 0b10 	add.w	fp, fp, #16
 801fca6:	d1ac      	bne.n	801fc02 <cblas_zher2k+0xe72>
 801fca8:	ec53 2b1a 	vmov	r2, r3, d10
 801fcac:	f008 fda6 	bl	80287fc <__adddf3>
 801fcb0:	4602      	mov	r2, r0
 801fcb2:	460b      	mov	r3, r1
          REAL(C, i * ldc + i) += 2 * temp_real;
 801fcb4:	9c22      	ldr	r4, [sp, #136]	; 0x88
 801fcb6:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801fcba:	f008 fd9f 	bl	80287fc <__adddf3>
      for (i = 0; i < N; i++) {
 801fcbe:	9a25      	ldr	r2, [sp, #148]	; 0x94
 801fcc0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
          IMAG(C, i * ldc + i) = 0.0;
 801fcc2:	ed1f 7b95 	vldr	d7, [pc, #-596]	; 801fa70 <cblas_zher2k+0xce0>
      for (i = 0; i < N; i++) {
 801fcc6:	3201      	adds	r2, #1
 801fcc8:	4293      	cmp	r3, r2
          REAL(C, i * ldc + i) += 2 * temp_real;
 801fcca:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(C, i * ldc + i) = 0.0;
 801fcce:	ed84 7b00 	vstr	d7, [r4]
      for (i = 0; i < N; i++) {
 801fcd2:	9225      	str	r2, [sp, #148]	; 0x94
 801fcd4:	f43f ac58 	beq.w	801f588 <cblas_zher2k+0x7f8>
 801fcd8:	2300      	movs	r3, #0
 801fcda:	9a24      	ldr	r2, [sp, #144]	; 0x90
 801fcdc:	9308      	str	r3, [sp, #32]
 801fcde:	9314      	str	r3, [sp, #80]	; 0x50
 801fce0:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801fce2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801fce6:	931c      	str	r3, [sp, #112]	; 0x70
 801fce8:	9a06      	ldr	r2, [sp, #24]
 801fcea:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801fcec:	4413      	add	r3, r2
 801fcee:	9321      	str	r3, [sp, #132]	; 0x84
          BASE temp_imag = 0.0;
 801fcf0:	ed1f 7ba1 	vldr	d7, [pc, #-644]	; 801fa70 <cblas_zher2k+0xce0>
          for (k = 0; k < K; k++) {
 801fcf4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
          BASE temp_imag = 0.0;
 801fcf6:	eeb0 fa47 	vmov.f32	s30, s14
 801fcfa:	eef0 fa67 	vmov.f32	s31, s15
          for (k = 0; k < K; k++) {
 801fcfe:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 801fd00:	eeb0 ea47 	vmov.f32	s28, s14
 801fd04:	eef0 ea67 	vmov.f32	s29, s15
          for (k = 0; k < K; k++) {
 801fd08:	f340 811a 	ble.w	801ff40 <cblas_zher2k+0x11b0>
 801fd0c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801fd0e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801fd10:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801fd14:	9303      	str	r3, [sp, #12]
 801fd16:	9a08      	ldr	r2, [sp, #32]
 801fd18:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801fd1a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801fd1e:	9300      	str	r3, [sp, #0]
 801fd20:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801fd24:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801fd26:	9312      	str	r3, [sp, #72]	; 0x48
 801fd28:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801fd2a:	9304      	str	r3, [sp, #16]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801fd2c:	9c04      	ldr	r4, [sp, #16]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fd2e:	ed9d 8b0e 	vldr	d8, [sp, #56]	; 0x38
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801fd32:	e9d4 6700 	ldrd	r6, r7, [r4]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fd36:	ec51 0b18 	vmov	r0, r1, d8
 801fd3a:	4632      	mov	r2, r6
 801fd3c:	463b      	mov	r3, r7
 801fd3e:	f008 ff13 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801fd42:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fd46:	460d      	mov	r5, r1
 801fd48:	4642      	mov	r2, r8
 801fd4a:	464b      	mov	r3, r9
 801fd4c:	4604      	mov	r4, r0
 801fd4e:	4659      	mov	r1, fp
 801fd50:	4650      	mov	r0, sl
 801fd52:	f008 ff09 	bl	8028b68 <__aeabi_dmul>
 801fd56:	4602      	mov	r2, r0
 801fd58:	460b      	mov	r3, r1
 801fd5a:	4620      	mov	r0, r4
 801fd5c:	4629      	mov	r1, r5
 801fd5e:	f008 fd4b 	bl	80287f8 <__aeabi_dsub>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fd62:	4642      	mov	r2, r8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fd64:	4604      	mov	r4, r0
 801fd66:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fd68:	464b      	mov	r3, r9
 801fd6a:	ec51 0b18 	vmov	r0, r1, d8
 801fd6e:	f008 fefb 	bl	8028b68 <__aeabi_dmul>
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801fd72:	ec45 4b1c 	vmov	d12, r4, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fd76:	4632      	mov	r2, r6
 801fd78:	463b      	mov	r3, r7
 801fd7a:	4604      	mov	r4, r0
 801fd7c:	460d      	mov	r5, r1
 801fd7e:	4650      	mov	r0, sl
 801fd80:	4659      	mov	r1, fp
 801fd82:	f008 fef1 	bl	8028b68 <__aeabi_dmul>
 801fd86:	4602      	mov	r2, r0
 801fd88:	460b      	mov	r3, r1
 801fd8a:	4620      	mov	r0, r4
 801fd8c:	4629      	mov	r1, r5
 801fd8e:	f008 fd35 	bl	80287fc <__adddf3>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801fd92:	9e03      	ldr	r6, [sp, #12]
 801fd94:	ed96 bb00 	vldr	d11, [r6]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fd98:	4604      	mov	r4, r0
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801fd9a:	ec53 2b1b 	vmov	r2, r3, d11
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fd9e:	460d      	mov	r5, r1
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801fda0:	ec51 0b18 	vmov	r0, r1, d8
 801fda4:	f008 fee0 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801fda8:	e9d6 8902 	ldrd	r8, r9, [r6, #8]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801fdac:	ec45 4b1a 	vmov	d10, r4, r5
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801fdb0:	4642      	mov	r2, r8
 801fdb2:	464b      	mov	r3, r9
 801fdb4:	4604      	mov	r4, r0
 801fdb6:	460d      	mov	r5, r1
 801fdb8:	4650      	mov	r0, sl
 801fdba:	4659      	mov	r1, fp
 801fdbc:	f008 fed4 	bl	8028b68 <__aeabi_dmul>
 801fdc0:	4602      	mov	r2, r0
 801fdc2:	460b      	mov	r3, r1
 801fdc4:	4620      	mov	r0, r4
 801fdc6:	4629      	mov	r1, r5
 801fdc8:	f008 fd16 	bl	80287f8 <__aeabi_dsub>
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801fdcc:	4642      	mov	r2, r8
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801fdce:	4604      	mov	r4, r0
 801fdd0:	460d      	mov	r5, r1
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801fdd2:	464b      	mov	r3, r9
 801fdd4:	ec51 0b18 	vmov	r0, r1, d8
 801fdd8:	f008 fec6 	bl	8028b68 <__aeabi_dmul>
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801fddc:	ec45 4b19 	vmov	d9, r4, r5
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801fde0:	ec53 2b1b 	vmov	r2, r3, d11
 801fde4:	4604      	mov	r4, r0
 801fde6:	460d      	mov	r5, r1
 801fde8:	4650      	mov	r0, sl
 801fdea:	4659      	mov	r1, fp
 801fdec:	f008 febc 	bl	8028b68 <__aeabi_dmul>
 801fdf0:	4602      	mov	r2, r0
 801fdf2:	460b      	mov	r3, r1
 801fdf4:	4620      	mov	r0, r4
 801fdf6:	4629      	mov	r1, r5
 801fdf8:	f008 fd00 	bl	80287fc <__adddf3>
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801fdfc:	9f00      	ldr	r7, [sp, #0]
 801fdfe:	ed97 7b00 	vldr	d7, [r7]
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801fe02:	4604      	mov	r4, r0
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe04:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801fe08:	eeb0 ba47 	vmov.f32	s22, s14
 801fe0c:	eef0 ba67 	vmov.f32	s23, s15
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801fe10:	460d      	mov	r5, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe12:	ec51 0b1c 	vmov	r0, r1, d12
 801fe16:	f008 fea7 	bl	8028b68 <__aeabi_dmul>
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 801fe1a:	e9d7 8902 	ldrd	r8, r9, [r7, #8]
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe1e:	ec41 0b1d 	vmov	d13, r0, r1
 801fe22:	4642      	mov	r2, r8
 801fe24:	464b      	mov	r3, r9
 801fe26:	ec51 0b1a 	vmov	r0, r1, d10
 801fe2a:	f008 fe9d 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801fe2e:	9e12      	ldr	r6, [sp, #72]	; 0x48
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe30:	4602      	mov	r2, r0
 801fe32:	460b      	mov	r3, r1
 801fe34:	ec51 0b1d 	vmov	r0, r1, d13
 801fe38:	f008 fce0 	bl	80287fc <__adddf3>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801fe3c:	ed96 8b00 	vldr	d8, [r6]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801fe40:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe44:	4606      	mov	r6, r0
 801fe46:	460f      	mov	r7, r1
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801fe48:	ec51 0b18 	vmov	r0, r1, d8
 801fe4c:	f008 fe8c 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801fe50:	9b12      	ldr	r3, [sp, #72]	; 0x48
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fe52:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801fe56:	ed93 6b02 	vldr	d6, [r3, #8]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801fe5a:	ec41 0b1d 	vmov	d13, r0, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fe5e:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801fe62:	ec59 8b16 	vmov	r8, r9, d6
 801fe66:	ee16 0a10 	vmov	r0, s12
 801fe6a:	4622      	mov	r2, r4
 801fe6c:	462b      	mov	r3, r5
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fe6e:	910b      	str	r1, [sp, #44]	; 0x2c
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801fe70:	4649      	mov	r1, r9
 801fe72:	f008 fe79 	bl	8028b68 <__aeabi_dmul>
 801fe76:	4602      	mov	r2, r0
 801fe78:	460b      	mov	r3, r1
 801fe7a:	ec51 0b1d 	vmov	r0, r1, d13
 801fe7e:	f008 fcbd 	bl	80287fc <__adddf3>
 801fe82:	4602      	mov	r2, r0
 801fe84:	460b      	mov	r3, r1
 801fe86:	4630      	mov	r0, r6
 801fe88:	4639      	mov	r1, r7
 801fe8a:	f008 fcb7 	bl	80287fc <__adddf3>
 801fe8e:	4602      	mov	r2, r0
 801fe90:	460b      	mov	r3, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe92:	ec51 0b1e 	vmov	r0, r1, d14
 801fe96:	f008 fcb1 	bl	80287fc <__adddf3>
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fe9a:	ec53 2b1c 	vmov	r2, r3, d12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801fe9e:	4606      	mov	r6, r0
 801fea0:	460f      	mov	r7, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fea2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801fea6:	f008 fe5f 	bl	8028b68 <__aeabi_dmul>
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801feaa:	ec47 6b1e 	vmov	d14, r6, r7
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801feae:	ec53 2b1b 	vmov	r2, r3, d11
 801feb2:	4606      	mov	r6, r0
 801feb4:	460f      	mov	r7, r1
 801feb6:	ec51 0b1a 	vmov	r0, r1, d10
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801feba:	940c      	str	r4, [sp, #48]	; 0x30
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801febc:	f008 fe54 	bl	8028b68 <__aeabi_dmul>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801fec0:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fec4:	4602      	mov	r2, r0
 801fec6:	460b      	mov	r3, r1
 801fec8:	4630      	mov	r0, r6
 801feca:	4639      	mov	r1, r7
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801fecc:	950d      	str	r5, [sp, #52]	; 0x34
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fece:	f008 fc95 	bl	80287fc <__adddf3>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801fed2:	ec53 2b18 	vmov	r2, r3, d8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801fed6:	4604      	mov	r4, r0
 801fed8:	460d      	mov	r5, r1
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801feda:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801fede:	f008 fe43 	bl	8028b68 <__aeabi_dmul>
 801fee2:	ec53 2b19 	vmov	r2, r3, d9
 801fee6:	4606      	mov	r6, r0
 801fee8:	460f      	mov	r7, r1
 801feea:	4640      	mov	r0, r8
 801feec:	4649      	mov	r1, r9
 801feee:	f008 fe3b 	bl	8028b68 <__aeabi_dmul>
 801fef2:	4602      	mov	r2, r0
 801fef4:	460b      	mov	r3, r1
 801fef6:	4630      	mov	r0, r6
 801fef8:	4639      	mov	r1, r7
 801fefa:	f008 fc7f 	bl	80287fc <__adddf3>
 801fefe:	4602      	mov	r2, r0
 801ff00:	460b      	mov	r3, r1
 801ff02:	4620      	mov	r0, r4
 801ff04:	4629      	mov	r1, r5
 801ff06:	f008 fc79 	bl	80287fc <__adddf3>
 801ff0a:	4602      	mov	r2, r0
 801ff0c:	460b      	mov	r3, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ff0e:	ec51 0b1f 	vmov	r0, r1, d15
 801ff12:	f008 fc73 	bl	80287fc <__adddf3>
 801ff16:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801ff18:	9c04      	ldr	r4, [sp, #16]
 801ff1a:	9e03      	ldr	r6, [sp, #12]
 801ff1c:	9f00      	ldr	r7, [sp, #0]
 801ff1e:	3310      	adds	r3, #16
 801ff20:	9312      	str	r3, [sp, #72]	; 0x48
          for (k = 0; k < K; k++) {
 801ff22:	9b06      	ldr	r3, [sp, #24]
 801ff24:	f104 0210 	add.w	r2, r4, #16
 801ff28:	f106 0410 	add.w	r4, r6, #16
 801ff2c:	9403      	str	r4, [sp, #12]
 801ff2e:	4293      	cmp	r3, r2
 801ff30:	f107 0410 	add.w	r4, r7, #16
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ff34:	ec41 0b1f 	vmov	d15, r0, r1
          for (k = 0; k < K; k++) {
 801ff38:	9204      	str	r2, [sp, #16]
 801ff3a:	9400      	str	r4, [sp, #0]
 801ff3c:	f47f aef6 	bne.w	801fd2c <cblas_zher2k+0xf9c>
          REAL(C, i * ldc + j) += temp_real;
 801ff40:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 801ff42:	ec53 2b1e 	vmov	r2, r3, d14
 801ff46:	e9d4 0100 	ldrd	r0, r1, [r4]
 801ff4a:	f008 fc57 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += temp_imag;
 801ff4e:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(C, i * ldc + j) += temp_real;
 801ff52:	e9c4 0100 	strd	r0, r1, [r4]
          IMAG(C, i * ldc + j) += temp_imag;
 801ff56:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801ff5a:	f008 fc4f 	bl	80287fc <__adddf3>
 801ff5e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801ff60:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = 0; j < i; j++) {
 801ff64:	9916      	ldr	r1, [sp, #88]	; 0x58
 801ff66:	440a      	add	r2, r1
 801ff68:	9214      	str	r2, [sp, #80]	; 0x50
 801ff6a:	9918      	ldr	r1, [sp, #96]	; 0x60
 801ff6c:	9a08      	ldr	r2, [sp, #32]
 801ff6e:	440a      	add	r2, r1
 801ff70:	9208      	str	r2, [sp, #32]
 801ff72:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801ff74:	f104 0310 	add.w	r3, r4, #16
 801ff78:	429a      	cmp	r2, r3
 801ff7a:	931c      	str	r3, [sp, #112]	; 0x70
 801ff7c:	f47f aeb8 	bne.w	801fcf0 <cblas_zher2k+0xf60>
 801ff80:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801ff82:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801ff84:	4413      	add	r3, r2
 801ff86:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801ff88:	9324      	str	r3, [sp, #144]	; 0x90
 801ff8a:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 801ff8c:	4611      	mov	r1, r2
 801ff8e:	4419      	add	r1, r3
 801ff90:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801ff92:	911e      	str	r1, [sp, #120]	; 0x78
 801ff94:	9928      	ldr	r1, [sp, #160]	; 0xa0
 801ff96:	440a      	add	r2, r1
 801ff98:	9906      	ldr	r1, [sp, #24]
 801ff9a:	921f      	str	r2, [sp, #124]	; 0x7c
 801ff9c:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 801ff9e:	4608      	mov	r0, r1
 801ffa0:	4410      	add	r0, r2
 801ffa2:	9923      	ldr	r1, [sp, #140]	; 0x8c
 801ffa4:	9006      	str	r0, [sp, #24]
 801ffa6:	9818      	ldr	r0, [sp, #96]	; 0x60
 801ffa8:	4401      	add	r1, r0
 801ffaa:	9123      	str	r1, [sp, #140]	; 0x8c
 801ffac:	991d      	ldr	r1, [sp, #116]	; 0x74
 801ffae:	4411      	add	r1, r2
 801ffb0:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801ffb2:	911d      	str	r1, [sp, #116]	; 0x74
 801ffb4:	441a      	add	r2, r3
 801ffb6:	9222      	str	r2, [sp, #136]	; 0x88
 801ffb8:	e611      	b.n	801fbde <cblas_zher2k+0xe4e>
          for (k = 0; k < K; k++) {
 801ffba:	2200      	movs	r2, #0
 801ffbc:	2300      	movs	r3, #0
 801ffbe:	e679      	b.n	801fcb4 <cblas_zher2k+0xf24>

0801ffc0 <cblas_zherk>:
void
cblas_zherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const double alpha, const void *A, const int lda,
             const double beta, void *C, const int ldc)
{
 801ffc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ffc4:	ed2d 8b0c 	vpush	{d8-d13}
 801ffc8:	eeb0 da40 	vmov.f32	s26, s0
 801ffcc:	eef0 da60 	vmov.f32	s27, s1
 801ffd0:	b093      	sub	sp, #76	; 0x4c
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 801ffd2:	2865      	cmp	r0, #101	; 0x65
 801ffd4:	9303      	str	r3, [sp, #12]
 801ffd6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 801ffd8:	9301      	str	r3, [sp, #4]
 801ffda:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 801ffdc:	9304      	str	r3, [sp, #16]
 801ffde:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801ffe0:	9306      	str	r3, [sp, #24]
 801ffe2:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801ffe4:	930b      	str	r3, [sp, #44]	; 0x2c
 801ffe6:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 801ffe8:	9309      	str	r3, [sp, #36]	; 0x24
 801ffea:	ec5b ab11 	vmov	sl, fp, d1
 801ffee:	4604      	mov	r4, r0
 801fff0:	460e      	mov	r6, r1
 801fff2:	4615      	mov	r5, r2
 801fff4:	f000 81af 	beq.w	8020356 <cblas_zherk+0x396>
 801fff8:	2a6f      	cmp	r2, #111	; 0x6f
 801fffa:	d023      	beq.n	8020044 <cblas_zherk+0x84>
 801fffc:	9b01      	ldr	r3, [sp, #4]
 801fffe:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 8020002:	2a01      	cmp	r2, #1
 8020004:	f240 81a0 	bls.w	8020348 <cblas_zherk+0x388>
 8020008:	2002      	movs	r0, #2
 802000a:	f1a5 026f 	sub.w	r2, r5, #111	; 0x6f
 802000e:	2a02      	cmp	r2, #2
 8020010:	bf88      	it	hi
 8020012:	2003      	movhi	r0, #3
 8020014:	9a03      	ldr	r2, [sp, #12]
 8020016:	9901      	ldr	r1, [sp, #4]
 8020018:	2a00      	cmp	r2, #0
 802001a:	bfb8      	it	lt
 802001c:	2004      	movlt	r0, #4
 802001e:	2b01      	cmp	r3, #1
 8020020:	bfb8      	it	lt
 8020022:	2301      	movlt	r3, #1
 8020024:	2900      	cmp	r1, #0
 8020026:	f2c0 8182 	blt.w	802032e <cblas_zherk+0x36e>
 802002a:	9a06      	ldr	r2, [sp, #24]
 802002c:	4293      	cmp	r3, r2
 802002e:	dc11      	bgt.n	8020054 <cblas_zherk+0x94>
 8020030:	9b03      	ldr	r3, [sp, #12]
 8020032:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8020034:	2b01      	cmp	r3, #1
 8020036:	bfb8      	it	lt
 8020038:	2301      	movlt	r3, #1
 802003a:	4293      	cmp	r3, r2
 802003c:	f300 81ae 	bgt.w	802039c <cblas_zherk+0x3dc>
 8020040:	b1a8      	cbz	r0, 802006e <cblas_zherk+0xae>
 8020042:	e010      	b.n	8020066 <cblas_zherk+0xa6>
 8020044:	9b03      	ldr	r3, [sp, #12]
 8020046:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 802004a:	2a01      	cmp	r2, #1
 802004c:	f240 817c 	bls.w	8020348 <cblas_zherk+0x388>
 8020050:	2002      	movs	r0, #2
 8020052:	e7df      	b.n	8020014 <cblas_zherk+0x54>
 8020054:	9803      	ldr	r0, [sp, #12]
 8020056:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020058:	2801      	cmp	r0, #1
 802005a:	bfb8      	it	lt
 802005c:	2001      	movlt	r0, #1
 802005e:	4283      	cmp	r3, r0
 8020060:	bfb4      	ite	lt
 8020062:	200b      	movlt	r0, #11
 8020064:	2008      	movge	r0, #8
 8020066:	4ac0      	ldr	r2, [pc, #768]	; (8020368 <cblas_zherk+0x3a8>)
 8020068:	49c0      	ldr	r1, [pc, #768]	; (802036c <cblas_zherk+0x3ac>)
 802006a:	f008 fb4d 	bl	8028708 <cblas_xerbla>
  if (beta == 1.0 && (alpha == 0.0 || K == 0))
 802006e:	4bc0      	ldr	r3, [pc, #768]	; (8020370 <cblas_zherk+0x3b0>)
 8020070:	2200      	movs	r2, #0
 8020072:	4650      	mov	r0, sl
 8020074:	4659      	mov	r1, fp
 8020076:	f008 ffdf 	bl	8029038 <__aeabi_dcmpeq>
 802007a:	2800      	cmp	r0, #0
 802007c:	f000 810d 	beq.w	802029a <cblas_zherk+0x2da>
 8020080:	ec51 0b1d 	vmov	r0, r1, d13
 8020084:	2200      	movs	r2, #0
 8020086:	2300      	movs	r3, #0
 8020088:	f008 ffd6 	bl	8029038 <__aeabi_dcmpeq>
 802008c:	2800      	cmp	r0, #0
 802008e:	f040 80ff 	bne.w	8020290 <cblas_zherk+0x2d0>
 8020092:	9b01      	ldr	r3, [sp, #4]
 8020094:	2b00      	cmp	r3, #0
 8020096:	f000 80fb 	beq.w	8020290 <cblas_zherk+0x2d0>
  if (Order == CblasRowMajor) {
 802009a:	2c65      	cmp	r4, #101	; 0x65
 802009c:	f000 8180 	beq.w	80203a0 <cblas_zherk+0x3e0>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80200a0:	2e79      	cmp	r6, #121	; 0x79
  if (beta == 0.0) {
 80200a2:	f04f 0200 	mov.w	r2, #0
 80200a6:	f04f 0300 	mov.w	r3, #0
 80200aa:	4650      	mov	r0, sl
 80200ac:	4659      	mov	r1, fp
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80200ae:	f000 818b 	beq.w	80203c8 <cblas_zherk+0x408>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80200b2:	2d6f      	cmp	r5, #111	; 0x6f
 80200b4:	f000 8272 	beq.w	802059c <cblas_zherk+0x5dc>
  if (beta == 0.0) {
 80200b8:	f008 ffbe 	bl	8029038 <__aeabi_dcmpeq>
 80200bc:	2800      	cmp	r0, #0
 80200be:	f000 815b 	beq.w	8020378 <cblas_zherk+0x3b8>
      for (i = 0; i < N; i++) {
 80200c2:	9b03      	ldr	r3, [sp, #12]
 80200c4:	2b00      	cmp	r3, #0
 80200c6:	f340 80e3 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80200ca:	236f      	movs	r3, #111	; 0x6f
 80200cc:	9305      	str	r3, [sp, #20]
 80200ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80200d0:	980b      	ldr	r0, [sp, #44]	; 0x2c
      for (i = 0; i < N; i++) {
 80200d2:	9d03      	ldr	r5, [sp, #12]
 80200d4:	1c5c      	adds	r4, r3, #1
          REAL(C, ldc * i + j) = 0.0;
 80200d6:	2600      	movs	r6, #0
 80200d8:	2700      	movs	r7, #0
 80200da:	0124      	lsls	r4, r4, #4
      for (i = 0; i < N; i++) {
 80200dc:	2100      	movs	r1, #0
 80200de:	4603      	mov	r3, r0
 80200e0:	460a      	mov	r2, r1
        for (j = i; j < N; j++) {
 80200e2:	3201      	adds	r2, #1
 80200e4:	4295      	cmp	r5, r2
          REAL(C, ldc * i + j) = 0.0;
 80200e6:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 80200ea:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = i; j < N; j++) {
 80200ee:	f103 0310 	add.w	r3, r3, #16
 80200f2:	dcf6      	bgt.n	80200e2 <cblas_zherk+0x122>
      for (i = 0; i < N; i++) {
 80200f4:	3101      	adds	r1, #1
 80200f6:	428d      	cmp	r5, r1
 80200f8:	4420      	add	r0, r4
 80200fa:	dcf0      	bgt.n	80200de <cblas_zherk+0x11e>
  if (alpha == 0.0)
 80200fc:	ec51 0b1d 	vmov	r0, r1, d13
 8020100:	2200      	movs	r2, #0
 8020102:	2300      	movs	r3, #0
 8020104:	f008 ff98 	bl	8029038 <__aeabi_dcmpeq>
 8020108:	2800      	cmp	r0, #0
 802010a:	f040 80c1 	bne.w	8020290 <cblas_zherk+0x2d0>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 802010e:	9b05      	ldr	r3, [sp, #20]
 8020110:	2b6f      	cmp	r3, #111	; 0x6f
 8020112:	f000 8263 	beq.w	80205dc <cblas_zherk+0x61c>
  } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 8020116:	9b05      	ldr	r3, [sp, #20]
 8020118:	2b71      	cmp	r3, #113	; 0x71
 802011a:	f040 80fe 	bne.w	802031a <cblas_zherk+0x35a>
    for (i = 0; i < N; i++) {
 802011e:	9b03      	ldr	r3, [sp, #12]
 8020120:	2b00      	cmp	r3, #0
 8020122:	f340 80b5 	ble.w	8020290 <cblas_zherk+0x2d0>
 8020126:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020128:	3301      	adds	r3, #1
 802012a:	011b      	lsls	r3, r3, #4
 802012c:	930c      	str	r3, [sp, #48]	; 0x30
 802012e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020130:	930a      	str	r3, [sp, #40]	; 0x28
 8020132:	9b06      	ldr	r3, [sp, #24]
 8020134:	011b      	lsls	r3, r3, #4
 8020136:	9308      	str	r3, [sp, #32]
 8020138:	9b04      	ldr	r3, [sp, #16]
 802013a:	3308      	adds	r3, #8
 802013c:	9307      	str	r3, [sp, #28]
 802013e:	2300      	movs	r3, #0
 8020140:	9309      	str	r3, [sp, #36]	; 0x24
        BASE temp_real = 0.0;
 8020142:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020144:	9306      	str	r3, [sp, #24]
 8020146:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020148:	9305      	str	r3, [sp, #20]
        BASE temp_imag = 0.0;
 802014a:	ed9f 7b85 	vldr	d7, [pc, #532]	; 8020360 <cblas_zherk+0x3a0>
        for (k = 0; k < K; k++) {
 802014e:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 8020150:	eeb0 ca47 	vmov.f32	s24, s14
 8020154:	eef0 ca67 	vmov.f32	s25, s15
        for (k = 0; k < K; k++) {
 8020158:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 802015a:	eeb0 ba47 	vmov.f32	s22, s14
 802015e:	eef0 ba67 	vmov.f32	s23, s15
        for (k = 0; k < K; k++) {
 8020162:	dd5c      	ble.n	802021e <cblas_zherk+0x25e>
 8020164:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 8020168:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 802016c:	2300      	movs	r3, #0
 802016e:	461d      	mov	r5, r3
 8020170:	f8dd b01c 	ldr.w	fp, [sp, #28]
 8020174:	9b08      	ldr	r3, [sp, #32]
 8020176:	9302      	str	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8020178:	ed1b 7b02 	vldr	d7, [fp, #-8]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802017c:	e9da 8900 	ldrd	r8, r9, [sl]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8020180:	eeb0 9a47 	vmov.f32	s18, s14
 8020184:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8020188:	ec51 0b17 	vmov	r0, r1, d7
 802018c:	4642      	mov	r2, r8
 802018e:	464b      	mov	r3, r9
 8020190:	f008 fcea 	bl	8028b68 <__aeabi_dmul>
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8020194:	ed9a 8b02 	vldr	d8, [sl, #8]
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 8020198:	f8db 4004 	ldr.w	r4, [fp, #4]
 802019c:	f8db 6000 	ldr.w	r6, [fp]
 80201a0:	f104 4700 	add.w	r7, r4, #2147483648	; 0x80000000
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80201a4:	ec53 2b18 	vmov	r2, r3, d8
 80201a8:	ec41 0b1a 	vmov	d10, r0, r1
 80201ac:	4630      	mov	r0, r6
 80201ae:	4639      	mov	r1, r7
 80201b0:	f008 fcda 	bl	8028b68 <__aeabi_dmul>
 80201b4:	4602      	mov	r2, r0
 80201b6:	460b      	mov	r3, r1
 80201b8:	ec51 0b1a 	vmov	r0, r1, d10
 80201bc:	f008 fb1c 	bl	80287f8 <__aeabi_dsub>
 80201c0:	4602      	mov	r2, r0
 80201c2:	460b      	mov	r3, r1
 80201c4:	ec51 0b1b 	vmov	r0, r1, d11
 80201c8:	f008 fb18 	bl	80287fc <__adddf3>
 80201cc:	ec41 0b17 	vmov	d7, r0, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80201d0:	ec53 2b18 	vmov	r2, r3, d8
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80201d4:	eeb0 ba47 	vmov.f32	s22, s14
 80201d8:	eef0 ba67 	vmov.f32	s23, s15
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80201dc:	ec51 0b19 	vmov	r0, r1, d9
 80201e0:	f008 fcc2 	bl	8028b68 <__aeabi_dmul>
 80201e4:	4642      	mov	r2, r8
 80201e6:	464b      	mov	r3, r9
 80201e8:	4680      	mov	r8, r0
 80201ea:	4689      	mov	r9, r1
 80201ec:	4630      	mov	r0, r6
 80201ee:	4639      	mov	r1, r7
 80201f0:	f008 fcba 	bl	8028b68 <__aeabi_dmul>
 80201f4:	4602      	mov	r2, r0
 80201f6:	460b      	mov	r3, r1
 80201f8:	4640      	mov	r0, r8
 80201fa:	4649      	mov	r1, r9
 80201fc:	f008 fafe 	bl	80287fc <__adddf3>
 8020200:	460b      	mov	r3, r1
 8020202:	4602      	mov	r2, r0
 8020204:	ec51 0b1c 	vmov	r0, r1, d12
 8020208:	f008 faf8 	bl	80287fc <__adddf3>
 802020c:	9b02      	ldr	r3, [sp, #8]
 802020e:	449b      	add	fp, r3
 8020210:	449a      	add	sl, r3
        for (k = 0; k < K; k++) {
 8020212:	9b01      	ldr	r3, [sp, #4]
 8020214:	3501      	adds	r5, #1
 8020216:	42ab      	cmp	r3, r5
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8020218:	ec41 0b1c 	vmov	d12, r0, r1
        for (k = 0; k < K; k++) {
 802021c:	d1ac      	bne.n	8020178 <cblas_zherk+0x1b8>
        REAL(C, i * ldc + j) += alpha * temp_real;
 802021e:	ec59 8b1d 	vmov	r8, r9, d13
 8020222:	ec53 2b1b 	vmov	r2, r3, d11
 8020226:	ee1d 0a10 	vmov	r0, s26
 802022a:	4649      	mov	r1, r9
 802022c:	f008 fc9c 	bl	8028b68 <__aeabi_dmul>
 8020230:	9c06      	ldr	r4, [sp, #24]
 8020232:	4602      	mov	r2, r0
 8020234:	460b      	mov	r3, r1
 8020236:	e9d4 0100 	ldrd	r0, r1, [r4]
 802023a:	f008 fadf 	bl	80287fc <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 802023e:	ec53 2b1c 	vmov	r2, r3, d12
        REAL(C, i * ldc + j) += alpha * temp_real;
 8020242:	e9c4 0100 	strd	r0, r1, [r4]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020246:	ee1d 0a10 	vmov	r0, s26
 802024a:	4649      	mov	r1, r9
 802024c:	f008 fc8c 	bl	8028b68 <__aeabi_dmul>
 8020250:	4602      	mov	r2, r0
 8020252:	460b      	mov	r3, r1
 8020254:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8020258:	f008 fad0 	bl	80287fc <__adddf3>
      for (j = i; j < N; j++) {
 802025c:	9a05      	ldr	r2, [sp, #20]
 802025e:	f104 0310 	add.w	r3, r4, #16
 8020262:	9306      	str	r3, [sp, #24]
 8020264:	9b03      	ldr	r3, [sp, #12]
 8020266:	3201      	adds	r2, #1
 8020268:	4293      	cmp	r3, r2
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 802026a:	e9c4 0102 	strd	r0, r1, [r4, #8]
      for (j = i; j < N; j++) {
 802026e:	9205      	str	r2, [sp, #20]
 8020270:	f73f af6b 	bgt.w	802014a <cblas_zherk+0x18a>
    for (i = 0; i < N; i++) {
 8020274:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020276:	990c      	ldr	r1, [sp, #48]	; 0x30
 8020278:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802027a:	440a      	add	r2, r1
 802027c:	920a      	str	r2, [sp, #40]	; 0x28
 802027e:	9a07      	ldr	r2, [sp, #28]
 8020280:	3210      	adds	r2, #16
 8020282:	9207      	str	r2, [sp, #28]
 8020284:	9a03      	ldr	r2, [sp, #12]
 8020286:	3301      	adds	r3, #1
 8020288:	429a      	cmp	r2, r3
 802028a:	9309      	str	r3, [sp, #36]	; 0x24
 802028c:	f47f af59 	bne.w	8020142 <cblas_zherk+0x182>
#define BASE double
#include "source_herk.h"
#undef BASE
}
 8020290:	b013      	add	sp, #76	; 0x4c
 8020292:	ecbd 8b0c 	vpop	{d8-d13}
 8020296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (Order == CblasRowMajor) {
 802029a:	2c65      	cmp	r4, #101	; 0x65
 802029c:	f47f af00 	bne.w	80200a0 <cblas_zherk+0xe0>
  if (beta == 0.0) {
 80202a0:	2200      	movs	r2, #0
 80202a2:	2300      	movs	r3, #0
 80202a4:	4650      	mov	r0, sl
 80202a6:	4659      	mov	r1, fp
 80202a8:	f008 fec6 	bl	8029038 <__aeabi_dcmpeq>
    uplo = Uplo;
 80202ac:	9602      	str	r6, [sp, #8]
    trans = Trans;
 80202ae:	9505      	str	r5, [sp, #20]
  if (beta == 0.0) {
 80202b0:	2800      	cmp	r0, #0
 80202b2:	f000 82bd 	beq.w	8020830 <cblas_zherk+0x870>
    if (uplo == CblasUpper) {
 80202b6:	9b02      	ldr	r3, [sp, #8]
 80202b8:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 80202ba:	9b03      	ldr	r3, [sp, #12]
    if (uplo == CblasUpper) {
 80202bc:	f000 8412 	beq.w	8020ae4 <cblas_zherk+0xb24>
      for (i = 0; i < N; i++) {
 80202c0:	2b00      	cmp	r3, #0
 80202c2:	f340 8092 	ble.w	80203ea <cblas_zherk+0x42a>
 80202c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80202c8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80202ca:	9d03      	ldr	r5, [sp, #12]
 80202cc:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 80202d0:	1c5c      	adds	r4, r3, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80202d2:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 80202d4:	2600      	movs	r6, #0
 80202d6:	2700      	movs	r7, #0
 80202d8:	0124      	lsls	r4, r4, #4
      for (i = 0; i < N; i++) {
 80202da:	4608      	mov	r0, r1
 80202dc:	3210      	adds	r2, #16
 80202de:	469e      	mov	lr, r3
 80202e0:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
          REAL(C, ldc * i + j) = 0.0;
 80202e4:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 80202e8:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j <= i; j++) {
 80202ec:	3310      	adds	r3, #16
 80202ee:	429a      	cmp	r2, r3
 80202f0:	d1f8      	bne.n	80202e4 <cblas_zherk+0x324>
      for (i = 0; i < N; i++) {
 80202f2:	3001      	adds	r0, #1
 80202f4:	4285      	cmp	r5, r0
 80202f6:	4471      	add	r1, lr
 80202f8:	4422      	add	r2, r4
 80202fa:	dcf1      	bgt.n	80202e0 <cblas_zherk+0x320>
  if (alpha == 0.0)
 80202fc:	ec51 0b1d 	vmov	r0, r1, d13
 8020300:	2200      	movs	r2, #0
 8020302:	2300      	movs	r3, #0
 8020304:	f008 fe98 	bl	8029038 <__aeabi_dcmpeq>
 8020308:	2800      	cmp	r0, #0
 802030a:	d1c1      	bne.n	8020290 <cblas_zherk+0x2d0>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 802030c:	9b02      	ldr	r3, [sp, #8]
 802030e:	2b79      	cmp	r3, #121	; 0x79
 8020310:	f43f aefd 	beq.w	802010e <cblas_zherk+0x14e>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8020314:	9b02      	ldr	r3, [sp, #8]
 8020316:	2b7a      	cmp	r3, #122	; 0x7a
 8020318:	d070      	beq.n	80203fc <cblas_zherk+0x43c>
    BLAS_ERROR("unrecognized operation");
 802031a:	4a16      	ldr	r2, [pc, #88]	; (8020374 <cblas_zherk+0x3b4>)
 802031c:	4913      	ldr	r1, [pc, #76]	; (802036c <cblas_zherk+0x3ac>)
 802031e:	2000      	movs	r0, #0
 8020320:	b013      	add	sp, #76	; 0x4c
 8020322:	ecbd 8b0c 	vpop	{d8-d13}
 8020326:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802032a:	f008 b9ed 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 802032e:	9906      	ldr	r1, [sp, #24]
 8020330:	428b      	cmp	r3, r1
 8020332:	f73f ae8f 	bgt.w	8020054 <cblas_zherk+0x94>
 8020336:	2a01      	cmp	r2, #1
 8020338:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802033a:	bfb8      	it	lt
 802033c:	2201      	movlt	r2, #1
 802033e:	4293      	cmp	r3, r2
 8020340:	bfb4      	ite	lt
 8020342:	200b      	movlt	r0, #11
 8020344:	2005      	movge	r0, #5
 8020346:	e68e      	b.n	8020066 <cblas_zherk+0xa6>
 8020348:	f1a4 0065 	sub.w	r0, r4, #101	; 0x65
 802034c:	2801      	cmp	r0, #1
 802034e:	bf94      	ite	ls
 8020350:	2000      	movls	r0, #0
 8020352:	2001      	movhi	r0, #1
 8020354:	e659      	b.n	802000a <cblas_zherk+0x4a>
 8020356:	2a6f      	cmp	r2, #111	; 0x6f
 8020358:	f000 811e 	beq.w	8020598 <cblas_zherk+0x5d8>
 802035c:	9b03      	ldr	r3, [sp, #12]
 802035e:	e64e      	b.n	801fffe <cblas_zherk+0x3e>
	...
 8020368:	08031108 	.word	0x08031108
 802036c:	08031350 	.word	0x08031350
 8020370:	3ff00000 	.word	0x3ff00000
 8020374:	080311b8 	.word	0x080311b8
  } else if (beta != 1.0) {
 8020378:	4b97      	ldr	r3, [pc, #604]	; (80205d8 <cblas_zherk+0x618>)
 802037a:	2200      	movs	r2, #0
 802037c:	4650      	mov	r0, sl
 802037e:	4659      	mov	r1, fp
 8020380:	f008 fe5a 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 8020384:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 8020386:	2800      	cmp	r0, #0
 8020388:	f000 8213 	beq.w	80207b2 <cblas_zherk+0x7f2>
    for (i = 0; i < N; i++) {
 802038c:	2b00      	cmp	r3, #0
 802038e:	f77f af7f 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8020392:	236f      	movs	r3, #111	; 0x6f
 8020394:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8020396:	2379      	movs	r3, #121	; 0x79
 8020398:	9302      	str	r3, [sp, #8]
 802039a:	e006      	b.n	80203aa <cblas_zherk+0x3ea>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 802039c:	200b      	movs	r0, #11
 802039e:	e662      	b.n	8020066 <cblas_zherk+0xa6>
    for (i = 0; i < N; i++) {
 80203a0:	9b03      	ldr	r3, [sp, #12]
    uplo = Uplo;
 80203a2:	9602      	str	r6, [sp, #8]
    for (i = 0; i < N; i++) {
 80203a4:	2b00      	cmp	r3, #0
    trans = Trans;
 80203a6:	9505      	str	r5, [sp, #20]
    for (i = 0; i < N; i++) {
 80203a8:	dda8      	ble.n	80202fc <cblas_zherk+0x33c>
 80203aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80203ac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80203ae:	9803      	ldr	r0, [sp, #12]
 80203b0:	1c59      	adds	r1, r3, #1
      IMAG(C, ldc * i + i) = 0.0;
 80203b2:	2400      	movs	r4, #0
 80203b4:	2500      	movs	r5, #0
 80203b6:	0109      	lsls	r1, r1, #4
    for (i = 0; i < N; i++) {
 80203b8:	2300      	movs	r3, #0
 80203ba:	3301      	adds	r3, #1
 80203bc:	4298      	cmp	r0, r3
      IMAG(C, ldc * i + i) = 0.0;
 80203be:	e9c2 4502 	strd	r4, r5, [r2, #8]
    for (i = 0; i < N; i++) {
 80203c2:	440a      	add	r2, r1
 80203c4:	dcf9      	bgt.n	80203ba <cblas_zherk+0x3fa>
 80203c6:	e799      	b.n	80202fc <cblas_zherk+0x33c>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80203c8:	2d6f      	cmp	r5, #111	; 0x6f
 80203ca:	f000 81e4 	beq.w	8020796 <cblas_zherk+0x7d6>
  if (beta == 0.0) {
 80203ce:	f008 fe33 	bl	8029038 <__aeabi_dcmpeq>
 80203d2:	2800      	cmp	r0, #0
 80203d4:	f000 81cd 	beq.w	8020772 <cblas_zherk+0x7b2>
      for (i = 0; i < N; i++) {
 80203d8:	9b03      	ldr	r3, [sp, #12]
 80203da:	2b00      	cmp	r3, #0
 80203dc:	f77f af58 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80203e0:	236f      	movs	r3, #111	; 0x6f
 80203e2:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80203e4:	237a      	movs	r3, #122	; 0x7a
 80203e6:	9302      	str	r3, [sp, #8]
 80203e8:	e76d      	b.n	80202c6 <cblas_zherk+0x306>
  if (alpha == 0.0)
 80203ea:	ec51 0b1d 	vmov	r0, r1, d13
 80203ee:	2200      	movs	r2, #0
 80203f0:	2300      	movs	r3, #0
 80203f2:	f008 fe21 	bl	8029038 <__aeabi_dcmpeq>
 80203f6:	2800      	cmp	r0, #0
 80203f8:	d08c      	beq.n	8020314 <cblas_zherk+0x354>
 80203fa:	e749      	b.n	8020290 <cblas_zherk+0x2d0>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80203fc:	9b05      	ldr	r3, [sp, #20]
 80203fe:	2b6f      	cmp	r3, #111	; 0x6f
 8020400:	f000 8288 	beq.w	8020914 <cblas_zherk+0x954>
  } else if (uplo == CblasLower && trans == CblasConjTrans) {
 8020404:	9b05      	ldr	r3, [sp, #20]
 8020406:	2b71      	cmp	r3, #113	; 0x71
 8020408:	d187      	bne.n	802031a <cblas_zherk+0x35a>
    for (i = 0; i < N; i++) {
 802040a:	9b03      	ldr	r3, [sp, #12]
 802040c:	2b00      	cmp	r3, #0
 802040e:	f77f af3f 	ble.w	8020290 <cblas_zherk+0x2d0>
 8020412:	9b06      	ldr	r3, [sp, #24]
 8020414:	011b      	lsls	r3, r3, #4
 8020416:	930c      	str	r3, [sp, #48]	; 0x30
 8020418:	9b04      	ldr	r3, [sp, #16]
 802041a:	3308      	adds	r3, #8
 802041c:	930a      	str	r3, [sp, #40]	; 0x28
 802041e:	2300      	movs	r3, #0
 8020420:	930e      	str	r3, [sp, #56]	; 0x38
 8020422:	2301      	movs	r3, #1
 8020424:	9308      	str	r3, [sp, #32]
 8020426:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020428:	3308      	adds	r3, #8
 802042a:	930d      	str	r3, [sp, #52]	; 0x34
 802042c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802042e:	4619      	mov	r1, r3
 8020430:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020432:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 8020436:	9207      	str	r2, [sp, #28]
 8020438:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802043a:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 802043e:	9306      	str	r3, [sp, #24]
      for (j = 0; j <= i; j++) {
 8020440:	2300      	movs	r3, #0
 8020442:	9305      	str	r3, [sp, #20]
        BASE temp_imag = 0.0;
 8020444:	ed9f 7b62 	vldr	d7, [pc, #392]	; 80205d0 <cblas_zherk+0x610>
        for (k = 0; k < K; k++) {
 8020448:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 802044a:	eeb0 ca47 	vmov.f32	s24, s14
 802044e:	eef0 ca67 	vmov.f32	s25, s15
        for (k = 0; k < K; k++) {
 8020452:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 8020454:	eeb0 ba47 	vmov.f32	s22, s14
 8020458:	eef0 ba67 	vmov.f32	s23, s15
        for (k = 0; k < K; k++) {
 802045c:	dd5c      	ble.n	8020518 <cblas_zherk+0x558>
 802045e:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 8020462:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 8020466:	2300      	movs	r3, #0
 8020468:	461d      	mov	r5, r3
 802046a:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 802046e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020470:	9302      	str	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8020472:	ed1b 7b02 	vldr	d7, [fp, #-8]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8020476:	e9da 8900 	ldrd	r8, r9, [sl]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 802047a:	eeb0 9a47 	vmov.f32	s18, s14
 802047e:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8020482:	ec51 0b17 	vmov	r0, r1, d7
 8020486:	4642      	mov	r2, r8
 8020488:	464b      	mov	r3, r9
 802048a:	f008 fb6d 	bl	8028b68 <__aeabi_dmul>
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 802048e:	ed9a 8b02 	vldr	d8, [sl, #8]
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 8020492:	f8db 4004 	ldr.w	r4, [fp, #4]
 8020496:	f8db 6000 	ldr.w	r6, [fp]
 802049a:	f104 4700 	add.w	r7, r4, #2147483648	; 0x80000000
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 802049e:	ec53 2b18 	vmov	r2, r3, d8
 80204a2:	ec41 0b1a 	vmov	d10, r0, r1
 80204a6:	4630      	mov	r0, r6
 80204a8:	4639      	mov	r1, r7
 80204aa:	f008 fb5d 	bl	8028b68 <__aeabi_dmul>
 80204ae:	4602      	mov	r2, r0
 80204b0:	460b      	mov	r3, r1
 80204b2:	ec51 0b1a 	vmov	r0, r1, d10
 80204b6:	f008 f99f 	bl	80287f8 <__aeabi_dsub>
 80204ba:	4602      	mov	r2, r0
 80204bc:	460b      	mov	r3, r1
 80204be:	ec51 0b1b 	vmov	r0, r1, d11
 80204c2:	f008 f99b 	bl	80287fc <__adddf3>
 80204c6:	ec41 0b17 	vmov	d7, r0, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80204ca:	ec53 2b18 	vmov	r2, r3, d8
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80204ce:	eeb0 ba47 	vmov.f32	s22, s14
 80204d2:	eef0 ba67 	vmov.f32	s23, s15
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80204d6:	ec51 0b19 	vmov	r0, r1, d9
 80204da:	f008 fb45 	bl	8028b68 <__aeabi_dmul>
 80204de:	4642      	mov	r2, r8
 80204e0:	464b      	mov	r3, r9
 80204e2:	4680      	mov	r8, r0
 80204e4:	4689      	mov	r9, r1
 80204e6:	4630      	mov	r0, r6
 80204e8:	4639      	mov	r1, r7
 80204ea:	f008 fb3d 	bl	8028b68 <__aeabi_dmul>
 80204ee:	4602      	mov	r2, r0
 80204f0:	460b      	mov	r3, r1
 80204f2:	4640      	mov	r0, r8
 80204f4:	4649      	mov	r1, r9
 80204f6:	f008 f981 	bl	80287fc <__adddf3>
 80204fa:	460b      	mov	r3, r1
 80204fc:	4602      	mov	r2, r0
 80204fe:	ec51 0b1c 	vmov	r0, r1, d12
 8020502:	f008 f97b 	bl	80287fc <__adddf3>
 8020506:	9b02      	ldr	r3, [sp, #8]
 8020508:	449b      	add	fp, r3
 802050a:	449a      	add	sl, r3
        for (k = 0; k < K; k++) {
 802050c:	9b01      	ldr	r3, [sp, #4]
 802050e:	3501      	adds	r5, #1
 8020510:	42ab      	cmp	r3, r5
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8020512:	ec41 0b1c 	vmov	d12, r0, r1
        for (k = 0; k < K; k++) {
 8020516:	d1ac      	bne.n	8020472 <cblas_zherk+0x4b2>
        REAL(C, i * ldc + j) += alpha * temp_real;
 8020518:	ec59 8b1d 	vmov	r8, r9, d13
 802051c:	ec53 2b1b 	vmov	r2, r3, d11
 8020520:	ee1d 0a10 	vmov	r0, s26
 8020524:	4649      	mov	r1, r9
 8020526:	f008 fb1f 	bl	8028b68 <__aeabi_dmul>
 802052a:	9c06      	ldr	r4, [sp, #24]
 802052c:	4602      	mov	r2, r0
 802052e:	460b      	mov	r3, r1
 8020530:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8020534:	f008 f962 	bl	80287fc <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020538:	ec53 2b1c 	vmov	r2, r3, d12
        REAL(C, i * ldc + j) += alpha * temp_real;
 802053c:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020540:	ee1d 0a10 	vmov	r0, s26
 8020544:	4649      	mov	r1, r9
 8020546:	f008 fb0f 	bl	8028b68 <__aeabi_dmul>
 802054a:	9d07      	ldr	r5, [sp, #28]
 802054c:	4602      	mov	r2, r0
 802054e:	460b      	mov	r3, r1
 8020550:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 8020554:	f008 f952 	bl	80287fc <__adddf3>
 8020558:	f104 0310 	add.w	r3, r4, #16
      for (j = 0; j <= i; j++) {
 802055c:	9a05      	ldr	r2, [sp, #20]
 802055e:	9306      	str	r3, [sp, #24]
 8020560:	f105 0310 	add.w	r3, r5, #16
 8020564:	9307      	str	r3, [sp, #28]
 8020566:	9b08      	ldr	r3, [sp, #32]
 8020568:	3201      	adds	r2, #1
 802056a:	429a      	cmp	r2, r3
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 802056c:	e9c5 0102 	strd	r0, r1, [r5, #8]
      for (j = 0; j <= i; j++) {
 8020570:	9205      	str	r2, [sp, #20]
 8020572:	f47f af67 	bne.w	8020444 <cblas_zherk+0x484>
    for (i = 0; i < N; i++) {
 8020576:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020578:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802057a:	9903      	ldr	r1, [sp, #12]
 802057c:	4413      	add	r3, r2
 802057e:	930e      	str	r3, [sp, #56]	; 0x38
 8020580:	9a08      	ldr	r2, [sp, #32]
 8020582:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020584:	4291      	cmp	r1, r2
 8020586:	f103 0310 	add.w	r3, r3, #16
 802058a:	930a      	str	r3, [sp, #40]	; 0x28
 802058c:	f102 0301 	add.w	r3, r2, #1
 8020590:	f43f ae7e 	beq.w	8020290 <cblas_zherk+0x2d0>
 8020594:	9308      	str	r3, [sp, #32]
 8020596:	e749      	b.n	802042c <cblas_zherk+0x46c>
 8020598:	9b01      	ldr	r3, [sp, #4]
 802059a:	e554      	b.n	8020046 <cblas_zherk+0x86>
  if (beta == 0.0) {
 802059c:	f008 fd4c 	bl	8029038 <__aeabi_dcmpeq>
 80205a0:	2800      	cmp	r0, #0
 80205a2:	f040 8290 	bne.w	8020ac6 <cblas_zherk+0xb06>
  } else if (beta != 1.0) {
 80205a6:	4b0c      	ldr	r3, [pc, #48]	; (80205d8 <cblas_zherk+0x618>)
 80205a8:	2200      	movs	r2, #0
 80205aa:	4650      	mov	r0, sl
 80205ac:	4659      	mov	r1, fp
 80205ae:	f008 fd43 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 80205b2:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 80205b4:	2800      	cmp	r0, #0
 80205b6:	f000 8180 	beq.w	80208ba <cblas_zherk+0x8fa>
    for (i = 0; i < N; i++) {
 80205ba:	2b00      	cmp	r3, #0
 80205bc:	f77f ae68 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80205c0:	2371      	movs	r3, #113	; 0x71
 80205c2:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80205c4:	2379      	movs	r3, #121	; 0x79
 80205c6:	9302      	str	r3, [sp, #8]
 80205c8:	e6ef      	b.n	80203aa <cblas_zherk+0x3ea>
 80205ca:	bf00      	nop
 80205cc:	f3af 8000 	nop.w
	...
 80205d8:	3ff00000 	.word	0x3ff00000
    for (i = 0; i < N; i++) {
 80205dc:	9b03      	ldr	r3, [sp, #12]
 80205de:	2b00      	cmp	r3, #0
 80205e0:	f77f ae56 	ble.w	8020290 <cblas_zherk+0x2d0>
 80205e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80205e6:	9901      	ldr	r1, [sp, #4]
 80205e8:	3301      	adds	r3, #1
 80205ea:	011b      	lsls	r3, r3, #4
 80205ec:	930e      	str	r3, [sp, #56]	; 0x38
 80205ee:	9b06      	ldr	r3, [sp, #24]
 80205f0:	011b      	lsls	r3, r3, #4
 80205f2:	930d      	str	r3, [sp, #52]	; 0x34
 80205f4:	9b04      	ldr	r3, [sp, #16]
 80205f6:	9309      	str	r3, [sp, #36]	; 0x24
 80205f8:	2200      	movs	r2, #0
 80205fa:	920c      	str	r2, [sp, #48]	; 0x30
 80205fc:	920a      	str	r2, [sp, #40]	; 0x28
 80205fe:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 8020602:	9202      	str	r2, [sp, #8]
        BASE temp_real = 0.0;
 8020604:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020606:	9305      	str	r3, [sp, #20]
 8020608:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802060a:	9308      	str	r3, [sp, #32]
 802060c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802060e:	9307      	str	r3, [sp, #28]
        BASE temp_imag = 0.0;
 8020610:	ed9f 7bbd 	vldr	d7, [pc, #756]	; 8020908 <cblas_zherk+0x948>
        for (k = 0; k < K; k++) {
 8020614:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 8020616:	eeb0 aa47 	vmov.f32	s20, s14
 802061a:	eef0 aa67 	vmov.f32	s21, s15
        for (k = 0; k < K; k++) {
 802061e:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 8020620:	ec57 6b17 	vmov	r6, r7, d7
        for (k = 0; k < K; k++) {
 8020624:	dd5e      	ble.n	80206e4 <cblas_zherk+0x724>
 8020626:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 802062a:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 802062e:	ec47 6b1b 	vmov	d11, r6, r7
 8020632:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8020636:	ed9a 7b00 	vldr	d7, [sl]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 802063a:	ed9b 6b00 	vldr	d6, [fp]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802063e:	eeb0 9a47 	vmov.f32	s18, s14
 8020642:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8020646:	ec53 2b16 	vmov	r2, r3, d6
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 802064a:	eeb0 8a46 	vmov.f32	s16, s12
 802064e:	eef0 8a66 	vmov.f32	s17, s13
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8020652:	ec51 0b17 	vmov	r0, r1, d7
 8020656:	f008 fa87 	bl	8028b68 <__aeabi_dmul>
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 802065a:	e9da 4502 	ldrd	r4, r5, [sl, #8]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 802065e:	f8db 600c 	ldr.w	r6, [fp, #12]
 8020662:	f8db 8008 	ldr.w	r8, [fp, #8]
 8020666:	f106 4900 	add.w	r9, r6, #2147483648	; 0x80000000
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802066a:	460f      	mov	r7, r1
 802066c:	4606      	mov	r6, r0
 802066e:	4642      	mov	r2, r8
 8020670:	464b      	mov	r3, r9
 8020672:	4620      	mov	r0, r4
 8020674:	4629      	mov	r1, r5
 8020676:	f008 fa77 	bl	8028b68 <__aeabi_dmul>
 802067a:	4602      	mov	r2, r0
 802067c:	460b      	mov	r3, r1
 802067e:	4630      	mov	r0, r6
 8020680:	4639      	mov	r1, r7
 8020682:	f008 f8b9 	bl	80287f8 <__aeabi_dsub>
 8020686:	4602      	mov	r2, r0
 8020688:	460b      	mov	r3, r1
 802068a:	ec51 0b1b 	vmov	r0, r1, d11
 802068e:	f008 f8b5 	bl	80287fc <__adddf3>
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8020692:	4642      	mov	r2, r8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8020694:	4606      	mov	r6, r0
 8020696:	460f      	mov	r7, r1
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8020698:	464b      	mov	r3, r9
 802069a:	ec51 0b19 	vmov	r0, r1, d9
 802069e:	f008 fa63 	bl	8028b68 <__aeabi_dmul>
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80206a2:	ec47 6b1b 	vmov	d11, r6, r7
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80206a6:	ec53 2b18 	vmov	r2, r3, d8
 80206aa:	4606      	mov	r6, r0
 80206ac:	460f      	mov	r7, r1
 80206ae:	4620      	mov	r0, r4
 80206b0:	4629      	mov	r1, r5
 80206b2:	f008 fa59 	bl	8028b68 <__aeabi_dmul>
 80206b6:	4602      	mov	r2, r0
 80206b8:	460b      	mov	r3, r1
 80206ba:	4630      	mov	r0, r6
 80206bc:	4639      	mov	r1, r7
 80206be:	f008 f89d 	bl	80287fc <__adddf3>
 80206c2:	460b      	mov	r3, r1
 80206c4:	4602      	mov	r2, r0
 80206c6:	ec51 0b1a 	vmov	r0, r1, d10
 80206ca:	f008 f897 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 80206ce:	9b02      	ldr	r3, [sp, #8]
 80206d0:	f10a 0a10 	add.w	sl, sl, #16
 80206d4:	4553      	cmp	r3, sl
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80206d6:	ec41 0b1a 	vmov	d10, r0, r1
        for (k = 0; k < K; k++) {
 80206da:	f10b 0b10 	add.w	fp, fp, #16
 80206de:	d1aa      	bne.n	8020636 <cblas_zherk+0x676>
 80206e0:	ec57 6b1b 	vmov	r6, r7, d11
        REAL(C, i * ldc + j) += alpha * temp_real;
 80206e4:	4630      	mov	r0, r6
 80206e6:	4639      	mov	r1, r7
 80206e8:	ec57 6b1d 	vmov	r6, r7, d13
 80206ec:	ee1d 2a10 	vmov	r2, s26
 80206f0:	463b      	mov	r3, r7
 80206f2:	f008 fa39 	bl	8028b68 <__aeabi_dmul>
 80206f6:	9c08      	ldr	r4, [sp, #32]
 80206f8:	4602      	mov	r2, r0
 80206fa:	460b      	mov	r3, r1
 80206fc:	e9d4 0100 	ldrd	r0, r1, [r4]
 8020700:	f008 f87c 	bl	80287fc <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020704:	ec53 2b1a 	vmov	r2, r3, d10
        REAL(C, i * ldc + j) += alpha * temp_real;
 8020708:	e9c4 0100 	strd	r0, r1, [r4]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 802070c:	ee1d 0a10 	vmov	r0, s26
 8020710:	4639      	mov	r1, r7
 8020712:	f008 fa29 	bl	8028b68 <__aeabi_dmul>
 8020716:	4602      	mov	r2, r0
 8020718:	460b      	mov	r3, r1
 802071a:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 802071e:	f008 f86d 	bl	80287fc <__adddf3>
 8020722:	e9dd 3505 	ldrd	r3, r5, [sp, #20]
 8020726:	442b      	add	r3, r5
      for (j = i; j < N; j++) {
 8020728:	9a07      	ldr	r2, [sp, #28]
 802072a:	9305      	str	r3, [sp, #20]
 802072c:	f104 0310 	add.w	r3, r4, #16
 8020730:	9308      	str	r3, [sp, #32]
 8020732:	9b03      	ldr	r3, [sp, #12]
 8020734:	3201      	adds	r2, #1
 8020736:	4293      	cmp	r3, r2
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020738:	e9c4 0102 	strd	r0, r1, [r4, #8]
      for (j = i; j < N; j++) {
 802073c:	9207      	str	r2, [sp, #28]
 802073e:	f73f af67 	bgt.w	8020610 <cblas_zherk+0x650>
    for (i = 0; i < N; i++) {
 8020742:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020744:	990e      	ldr	r1, [sp, #56]	; 0x38
 8020746:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020748:	440a      	add	r2, r1
 802074a:	920b      	str	r2, [sp, #44]	; 0x2c
 802074c:	9906      	ldr	r1, [sp, #24]
 802074e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8020750:	440a      	add	r2, r1
 8020752:	9909      	ldr	r1, [sp, #36]	; 0x24
 8020754:	920c      	str	r2, [sp, #48]	; 0x30
 8020756:	4608      	mov	r0, r1
 8020758:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802075a:	9902      	ldr	r1, [sp, #8]
 802075c:	4410      	add	r0, r2
 802075e:	4411      	add	r1, r2
 8020760:	9a03      	ldr	r2, [sp, #12]
 8020762:	9009      	str	r0, [sp, #36]	; 0x24
 8020764:	3301      	adds	r3, #1
 8020766:	429a      	cmp	r2, r3
 8020768:	930a      	str	r3, [sp, #40]	; 0x28
 802076a:	9102      	str	r1, [sp, #8]
 802076c:	f47f af4a 	bne.w	8020604 <cblas_zherk+0x644>
 8020770:	e58e      	b.n	8020290 <cblas_zherk+0x2d0>
  } else if (beta != 1.0) {
 8020772:	4b67      	ldr	r3, [pc, #412]	; (8020910 <cblas_zherk+0x950>)
 8020774:	2200      	movs	r2, #0
 8020776:	4650      	mov	r0, sl
 8020778:	4659      	mov	r1, fp
 802077a:	f008 fc5d 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 802077e:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 8020780:	2800      	cmp	r0, #0
 8020782:	f040 80b2 	bne.w	80208ea <cblas_zherk+0x92a>
      for (i = 0; i < N; i++) {
 8020786:	2b00      	cmp	r3, #0
 8020788:	f77f ad82 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 802078c:	236f      	movs	r3, #111	; 0x6f
 802078e:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8020790:	237a      	movs	r3, #122	; 0x7a
 8020792:	9302      	str	r3, [sp, #8]
 8020794:	e053      	b.n	802083e <cblas_zherk+0x87e>
  if (beta == 0.0) {
 8020796:	f008 fc4f 	bl	8029038 <__aeabi_dcmpeq>
 802079a:	2800      	cmp	r0, #0
 802079c:	f000 8093 	beq.w	80208c6 <cblas_zherk+0x906>
      for (i = 0; i < N; i++) {
 80207a0:	9b03      	ldr	r3, [sp, #12]
 80207a2:	2b00      	cmp	r3, #0
 80207a4:	f77f ad74 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80207a8:	2371      	movs	r3, #113	; 0x71
 80207aa:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80207ac:	237a      	movs	r3, #122	; 0x7a
 80207ae:	9302      	str	r3, [sp, #8]
 80207b0:	e589      	b.n	80202c6 <cblas_zherk+0x306>
      for (i = 0; i < N; i++) {
 80207b2:	2b00      	cmp	r3, #0
 80207b4:	f77f ad6c 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80207b8:	236f      	movs	r3, #111	; 0x6f
 80207ba:	9305      	str	r3, [sp, #20]
 80207bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80207be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80207c0:	011b      	lsls	r3, r3, #4
 80207c2:	f103 0610 	add.w	r6, r3, #16
 80207c6:	9302      	str	r3, [sp, #8]
 80207c8:	9b03      	ldr	r3, [sp, #12]
 80207ca:	f1a2 0510 	sub.w	r5, r2, #16
        IMAG(C, ldc * i + i) = 0;
 80207ce:	ed9f 8b4e 	vldr	d8, [pc, #312]	; 8020908 <cblas_zherk+0x948>
 80207d2:	eb05 1503 	add.w	r5, r5, r3, lsl #4
      for (i = 0; i < N; i++) {
 80207d6:	2300      	movs	r3, #0
 80207d8:	46b1      	mov	r9, r6
 80207da:	f102 0708 	add.w	r7, r2, #8
 80207de:	461e      	mov	r6, r3
        REAL(C, ldc * i + i) *= beta;
 80207e0:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 80207e4:	465b      	mov	r3, fp
 80207e6:	4652      	mov	r2, sl
 80207e8:	f008 f9be 	bl	8028b68 <__aeabi_dmul>
        for (j = i + 1; j < N; j++) {
 80207ec:	9b03      	ldr	r3, [sp, #12]
 80207ee:	3601      	adds	r6, #1
 80207f0:	42b3      	cmp	r3, r6
        REAL(C, ldc * i + i) *= beta;
 80207f2:	e947 0102 	strd	r0, r1, [r7, #-8]
        IMAG(C, ldc * i + i) = 0;
 80207f6:	ed87 8b00 	vstr	d8, [r7]
        for (j = i + 1; j < N; j++) {
 80207fa:	f77f ac7f 	ble.w	80200fc <cblas_zherk+0x13c>
 80207fe:	f1a7 0408 	sub.w	r4, r7, #8
          REAL(C, ldc * i + j) *= beta;
 8020802:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 8020806:	4652      	mov	r2, sl
 8020808:	465b      	mov	r3, fp
 802080a:	f008 f9ad 	bl	8028b68 <__aeabi_dmul>
          IMAG(C, ldc * i + j) *= beta;
 802080e:	4652      	mov	r2, sl
          REAL(C, ldc * i + j) *= beta;
 8020810:	e9c4 0104 	strd	r0, r1, [r4, #16]
          IMAG(C, ldc * i + j) *= beta;
 8020814:	465b      	mov	r3, fp
 8020816:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 802081a:	f008 f9a5 	bl	8028b68 <__aeabi_dmul>
 802081e:	3410      	adds	r4, #16
 8020820:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = i + 1; j < N; j++) {
 8020824:	42a5      	cmp	r5, r4
 8020826:	d1ec      	bne.n	8020802 <cblas_zherk+0x842>
 8020828:	9b02      	ldr	r3, [sp, #8]
 802082a:	444f      	add	r7, r9
 802082c:	441d      	add	r5, r3
 802082e:	e7d7      	b.n	80207e0 <cblas_zherk+0x820>
    if (uplo == CblasUpper) {
 8020830:	9b02      	ldr	r3, [sp, #8]
 8020832:	2b79      	cmp	r3, #121	; 0x79
 8020834:	d061      	beq.n	80208fa <cblas_zherk+0x93a>
      for (i = 0; i < N; i++) {
 8020836:	9b03      	ldr	r3, [sp, #12]
 8020838:	2b00      	cmp	r3, #0
 802083a:	f77f add6 	ble.w	80203ea <cblas_zherk+0x42a>
        for (j = 0; j < i; j++) {
 802083e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8020840:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8020842:	1c53      	adds	r3, r2, #1
        IMAG(C, ldc * i + i) = 0;
 8020844:	ed9f 8b30 	vldr	d8, [pc, #192]	; 8020908 <cblas_zherk+0x948>
 8020848:	f101 0708 	add.w	r7, r1, #8
 802084c:	0118      	lsls	r0, r3, #4
 802084e:	970d      	str	r7, [sp, #52]	; 0x34
 8020850:	9007      	str	r0, [sp, #28]
 8020852:	eb01 1903 	add.w	r9, r1, r3, lsl #4
      for (i = 0; i < N; i++) {
 8020856:	4690      	mov	r8, r2
      for (i = 0; i < N; i++) {
 8020858:	2600      	movs	r6, #0
        REAL(C, ldc * i + i) *= beta;
 802085a:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 802085e:	465b      	mov	r3, fp
 8020860:	4652      	mov	r2, sl
 8020862:	f008 f981 	bl	8028b68 <__aeabi_dmul>
      for (i = 0; i < N; i++) {
 8020866:	9b03      	ldr	r3, [sp, #12]
 8020868:	3601      	adds	r6, #1
 802086a:	42b3      	cmp	r3, r6
        REAL(C, ldc * i + i) *= beta;
 802086c:	e947 0102 	strd	r0, r1, [r7, #-8]
        IMAG(C, ldc * i + i) = 0;
 8020870:	ed87 8b00 	vstr	d8, [r7]
      for (i = 0; i < N; i++) {
 8020874:	f77f adb9 	ble.w	80203ea <cblas_zherk+0x42a>
        for (j = 0; j < i; j++) {
 8020878:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802087a:	eb03 1408 	add.w	r4, r3, r8, lsl #4
 802087e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8020880:	eb03 1508 	add.w	r5, r3, r8, lsl #4
          REAL(C, ldc * i + j) *= beta;
 8020884:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 8020888:	4652      	mov	r2, sl
 802088a:	465b      	mov	r3, fp
 802088c:	f008 f96c 	bl	8028b68 <__aeabi_dmul>
 8020890:	e945 0102 	strd	r0, r1, [r5, #-8]
          IMAG(C, ldc * i + j) *= beta;
 8020894:	4652      	mov	r2, sl
 8020896:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 802089a:	465b      	mov	r3, fp
 802089c:	f008 f964 	bl	8028b68 <__aeabi_dmul>
 80208a0:	3410      	adds	r4, #16
 80208a2:	e944 0102 	strd	r0, r1, [r4, #-8]
        for (j = 0; j < i; j++) {
 80208a6:	45a1      	cmp	r9, r4
 80208a8:	f105 0510 	add.w	r5, r5, #16
 80208ac:	d1ea      	bne.n	8020884 <cblas_zherk+0x8c4>
 80208ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80208b0:	4498      	add	r8, r3
 80208b2:	9b07      	ldr	r3, [sp, #28]
 80208b4:	4499      	add	r9, r3
 80208b6:	441f      	add	r7, r3
 80208b8:	e7cf      	b.n	802085a <cblas_zherk+0x89a>
      for (i = 0; i < N; i++) {
 80208ba:	2b00      	cmp	r3, #0
 80208bc:	f77f ace8 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80208c0:	2371      	movs	r3, #113	; 0x71
 80208c2:	9305      	str	r3, [sp, #20]
 80208c4:	e77a      	b.n	80207bc <cblas_zherk+0x7fc>
  } else if (beta != 1.0) {
 80208c6:	4b12      	ldr	r3, [pc, #72]	; (8020910 <cblas_zherk+0x950>)
 80208c8:	2200      	movs	r2, #0
 80208ca:	4650      	mov	r0, sl
 80208cc:	4659      	mov	r1, fp
 80208ce:	f008 fbb3 	bl	8029038 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 80208d2:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 80208d4:	2800      	cmp	r0, #0
 80208d6:	f040 80fe 	bne.w	8020ad6 <cblas_zherk+0xb16>
      for (i = 0; i < N; i++) {
 80208da:	2b00      	cmp	r3, #0
 80208dc:	f77f acd8 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80208e0:	2371      	movs	r3, #113	; 0x71
 80208e2:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80208e4:	237a      	movs	r3, #122	; 0x7a
 80208e6:	9302      	str	r3, [sp, #8]
 80208e8:	e7a9      	b.n	802083e <cblas_zherk+0x87e>
    for (i = 0; i < N; i++) {
 80208ea:	2b00      	cmp	r3, #0
 80208ec:	f77f acd0 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 80208f0:	236f      	movs	r3, #111	; 0x6f
 80208f2:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80208f4:	237a      	movs	r3, #122	; 0x7a
 80208f6:	9302      	str	r3, [sp, #8]
 80208f8:	e557      	b.n	80203aa <cblas_zherk+0x3ea>
      for (i = 0; i < N; i++) {
 80208fa:	9b03      	ldr	r3, [sp, #12]
 80208fc:	2b00      	cmp	r3, #0
 80208fe:	f73f af5d 	bgt.w	80207bc <cblas_zherk+0x7fc>
 8020902:	f7ff bbfb 	b.w	80200fc <cblas_zherk+0x13c>
 8020906:	bf00      	nop
	...
 8020910:	3ff00000 	.word	0x3ff00000
    for (i = 0; i < N; i++) {
 8020914:	9b03      	ldr	r3, [sp, #12]
 8020916:	2b00      	cmp	r3, #0
 8020918:	f77f acba 	ble.w	8020290 <cblas_zherk+0x2d0>
 802091c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802091e:	9801      	ldr	r0, [sp, #4]
 8020920:	3301      	adds	r3, #1
 8020922:	011b      	lsls	r3, r3, #4
 8020924:	9311      	str	r3, [sp, #68]	; 0x44
 8020926:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020928:	2200      	movs	r2, #0
 802092a:	920e      	str	r2, [sp, #56]	; 0x38
 802092c:	920f      	str	r2, [sp, #60]	; 0x3c
 802092e:	f103 0210 	add.w	r2, r3, #16
 8020932:	920a      	str	r2, [sp, #40]	; 0x28
 8020934:	9a06      	ldr	r2, [sp, #24]
 8020936:	0112      	lsls	r2, r2, #4
 8020938:	9210      	str	r2, [sp, #64]	; 0x40
 802093a:	9a04      	ldr	r2, [sp, #16]
 802093c:	920c      	str	r2, [sp, #48]	; 0x30
 802093e:	eb02 1100 	add.w	r1, r2, r0, lsl #4
 8020942:	3308      	adds	r3, #8
 8020944:	9102      	str	r1, [sp, #8]
 8020946:	930d      	str	r3, [sp, #52]	; 0x34
 8020948:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802094a:	4619      	mov	r1, r3
 802094c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802094e:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 8020952:	9208      	str	r2, [sp, #32]
 8020954:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8020956:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 802095a:	9307      	str	r3, [sp, #28]
        BASE temp_real = 0.0;
 802095c:	2300      	movs	r3, #0
 802095e:	9305      	str	r3, [sp, #20]
        BASE temp_imag = 0.0;
 8020960:	ed9f 7b69 	vldr	d7, [pc, #420]	; 8020b08 <cblas_zherk+0xb48>
        for (k = 0; k < K; k++) {
 8020964:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 8020966:	eeb0 aa47 	vmov.f32	s20, s14
 802096a:	eef0 aa67 	vmov.f32	s21, s15
        for (k = 0; k < K; k++) {
 802096e:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 8020970:	ec57 6b17 	vmov	r6, r7, d7
        for (k = 0; k < K; k++) {
 8020974:	dd5e      	ble.n	8020a34 <cblas_zherk+0xa74>
 8020976:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 802097a:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 802097e:	ec47 6b1b 	vmov	d11, r6, r7
 8020982:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8020986:	ed9a 7b00 	vldr	d7, [sl]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 802098a:	ed9b 6b00 	vldr	d6, [fp]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802098e:	eeb0 9a47 	vmov.f32	s18, s14
 8020992:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8020996:	ec53 2b16 	vmov	r2, r3, d6
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 802099a:	eeb0 8a46 	vmov.f32	s16, s12
 802099e:	eef0 8a66 	vmov.f32	s17, s13
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80209a2:	ec51 0b17 	vmov	r0, r1, d7
 80209a6:	f008 f8df 	bl	8028b68 <__aeabi_dmul>
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80209aa:	e9da 4502 	ldrd	r4, r5, [sl, #8]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 80209ae:	f8db 600c 	ldr.w	r6, [fp, #12]
 80209b2:	f8db 8008 	ldr.w	r8, [fp, #8]
 80209b6:	f106 4900 	add.w	r9, r6, #2147483648	; 0x80000000
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80209ba:	460f      	mov	r7, r1
 80209bc:	4606      	mov	r6, r0
 80209be:	4642      	mov	r2, r8
 80209c0:	464b      	mov	r3, r9
 80209c2:	4620      	mov	r0, r4
 80209c4:	4629      	mov	r1, r5
 80209c6:	f008 f8cf 	bl	8028b68 <__aeabi_dmul>
 80209ca:	4602      	mov	r2, r0
 80209cc:	460b      	mov	r3, r1
 80209ce:	4630      	mov	r0, r6
 80209d0:	4639      	mov	r1, r7
 80209d2:	f007 ff11 	bl	80287f8 <__aeabi_dsub>
 80209d6:	4602      	mov	r2, r0
 80209d8:	460b      	mov	r3, r1
 80209da:	ec51 0b1b 	vmov	r0, r1, d11
 80209de:	f007 ff0d 	bl	80287fc <__adddf3>
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80209e2:	4642      	mov	r2, r8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80209e4:	4606      	mov	r6, r0
 80209e6:	460f      	mov	r7, r1
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80209e8:	464b      	mov	r3, r9
 80209ea:	ec51 0b19 	vmov	r0, r1, d9
 80209ee:	f008 f8bb 	bl	8028b68 <__aeabi_dmul>
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80209f2:	ec47 6b1b 	vmov	d11, r6, r7
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80209f6:	ec53 2b18 	vmov	r2, r3, d8
 80209fa:	4606      	mov	r6, r0
 80209fc:	460f      	mov	r7, r1
 80209fe:	4620      	mov	r0, r4
 8020a00:	4629      	mov	r1, r5
 8020a02:	f008 f8b1 	bl	8028b68 <__aeabi_dmul>
 8020a06:	4602      	mov	r2, r0
 8020a08:	460b      	mov	r3, r1
 8020a0a:	4630      	mov	r0, r6
 8020a0c:	4639      	mov	r1, r7
 8020a0e:	f007 fef5 	bl	80287fc <__adddf3>
 8020a12:	460b      	mov	r3, r1
 8020a14:	4602      	mov	r2, r0
 8020a16:	ec51 0b1a 	vmov	r0, r1, d10
 8020a1a:	f007 feef 	bl	80287fc <__adddf3>
        for (k = 0; k < K; k++) {
 8020a1e:	9b02      	ldr	r3, [sp, #8]
 8020a20:	f10a 0a10 	add.w	sl, sl, #16
 8020a24:	4553      	cmp	r3, sl
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8020a26:	ec41 0b1a 	vmov	d10, r0, r1
        for (k = 0; k < K; k++) {
 8020a2a:	f10b 0b10 	add.w	fp, fp, #16
 8020a2e:	d1aa      	bne.n	8020986 <cblas_zherk+0x9c6>
 8020a30:	ec57 6b1b 	vmov	r6, r7, d11
        REAL(C, i * ldc + j) += alpha * temp_real;
 8020a34:	4632      	mov	r2, r6
 8020a36:	463b      	mov	r3, r7
 8020a38:	ec57 6b1d 	vmov	r6, r7, d13
 8020a3c:	ee1d 0a10 	vmov	r0, s26
 8020a40:	4639      	mov	r1, r7
 8020a42:	f008 f891 	bl	8028b68 <__aeabi_dmul>
 8020a46:	9c07      	ldr	r4, [sp, #28]
 8020a48:	4602      	mov	r2, r0
 8020a4a:	460b      	mov	r3, r1
 8020a4c:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8020a50:	f007 fed4 	bl	80287fc <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020a54:	ec53 2b1a 	vmov	r2, r3, d10
        REAL(C, i * ldc + j) += alpha * temp_real;
 8020a58:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8020a5c:	ee1d 0a10 	vmov	r0, s26
 8020a60:	4639      	mov	r1, r7
 8020a62:	f008 f881 	bl	8028b68 <__aeabi_dmul>
 8020a66:	9d08      	ldr	r5, [sp, #32]
 8020a68:	4602      	mov	r2, r0
 8020a6a:	460b      	mov	r3, r1
 8020a6c:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 8020a70:	f007 fec4 	bl	80287fc <__adddf3>
 8020a74:	e9c5 0102 	strd	r0, r1, [r5, #8]
      for (j = 0; j <= i; j++) {
 8020a78:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 8020a7c:	440a      	add	r2, r1
 8020a7e:	9205      	str	r2, [sp, #20]
 8020a80:	f104 0210 	add.w	r2, r4, #16
 8020a84:	9207      	str	r2, [sp, #28]
 8020a86:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020a88:	f105 0310 	add.w	r3, r5, #16
 8020a8c:	429a      	cmp	r2, r3
 8020a8e:	9308      	str	r3, [sp, #32]
 8020a90:	f47f af66 	bne.w	8020960 <cblas_zherk+0x9a0>
    for (i = 0; i < N; i++) {
 8020a94:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8020a96:	9909      	ldr	r1, [sp, #36]	; 0x24
 8020a98:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020a9a:	440a      	add	r2, r1
 8020a9c:	920e      	str	r2, [sp, #56]	; 0x38
 8020a9e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8020aa0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020aa2:	440a      	add	r2, r1
 8020aa4:	990c      	ldr	r1, [sp, #48]	; 0x30
 8020aa6:	920a      	str	r2, [sp, #40]	; 0x28
 8020aa8:	4608      	mov	r0, r1
 8020aaa:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020aac:	9902      	ldr	r1, [sp, #8]
 8020aae:	4410      	add	r0, r2
 8020ab0:	4411      	add	r1, r2
 8020ab2:	9a03      	ldr	r2, [sp, #12]
 8020ab4:	900c      	str	r0, [sp, #48]	; 0x30
 8020ab6:	3301      	adds	r3, #1
 8020ab8:	429a      	cmp	r2, r3
 8020aba:	930f      	str	r3, [sp, #60]	; 0x3c
 8020abc:	9102      	str	r1, [sp, #8]
 8020abe:	f47f af43 	bne.w	8020948 <cblas_zherk+0x988>
 8020ac2:	f7ff bbe5 	b.w	8020290 <cblas_zherk+0x2d0>
      for (i = 0; i < N; i++) {
 8020ac6:	9b03      	ldr	r3, [sp, #12]
 8020ac8:	2b00      	cmp	r3, #0
 8020aca:	f77f abe1 	ble.w	8020290 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8020ace:	2371      	movs	r3, #113	; 0x71
 8020ad0:	9305      	str	r3, [sp, #20]
 8020ad2:	f7ff bafc 	b.w	80200ce <cblas_zherk+0x10e>
    for (i = 0; i < N; i++) {
 8020ad6:	2b00      	cmp	r3, #0
 8020ad8:	dd09      	ble.n	8020aee <cblas_zherk+0xb2e>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8020ada:	2371      	movs	r3, #113	; 0x71
 8020adc:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8020ade:	237a      	movs	r3, #122	; 0x7a
 8020ae0:	9302      	str	r3, [sp, #8]
 8020ae2:	e462      	b.n	80203aa <cblas_zherk+0x3ea>
      for (i = 0; i < N; i++) {
 8020ae4:	2b00      	cmp	r3, #0
 8020ae6:	f73f aaf2 	bgt.w	80200ce <cblas_zherk+0x10e>
 8020aea:	f7ff bb07 	b.w	80200fc <cblas_zherk+0x13c>
  if (alpha == 0.0)
 8020aee:	ec51 0b1d 	vmov	r0, r1, d13
 8020af2:	2200      	movs	r2, #0
 8020af4:	2300      	movs	r3, #0
 8020af6:	f008 fa9f 	bl	8029038 <__aeabi_dcmpeq>
 8020afa:	2800      	cmp	r0, #0
 8020afc:	f43f ac85 	beq.w	802040a <cblas_zherk+0x44a>
 8020b00:	f7ff bbc6 	b.w	8020290 <cblas_zherk+0x2d0>
 8020b04:	f3af 8000 	nop.w
	...

08020b10 <cblas_zscal>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_zscal (const int N, const void *alpha, void *X, const int incX)
{
 8020b10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020b14:	ed2d 8b06 	vpush	{d8-d10}
 8020b18:	b083      	sub	sp, #12
  if (incX <= 0) {
 8020b1a:	2b00      	cmp	r3, #0
 8020b1c:	9001      	str	r0, [sp, #4]
 8020b1e:	dd48      	ble.n	8020bb2 <cblas_zscal+0xa2>
  for (i = 0; i < N; i++) {
 8020b20:	2800      	cmp	r0, #0
 8020b22:	dd46      	ble.n	8020bb2 <cblas_zscal+0xa2>
  const BASE alpha_real = CONST_REAL0(alpha);
 8020b24:	ed91 7b00 	vldr	d7, [r1]
 8020b28:	eeb0 9a47 	vmov.f32	s18, s14
 8020b2c:	eef0 9a67 	vmov.f32	s19, s15
  const BASE alpha_imag = CONST_IMAG0(alpha);
 8020b30:	ed91 7b02 	vldr	d7, [r1, #8]
 8020b34:	4693      	mov	fp, r2
 8020b36:	011f      	lsls	r7, r3, #4
 8020b38:	f102 0a08 	add.w	sl, r2, #8
  for (i = 0; i < N; i++) {
 8020b3c:	2600      	movs	r6, #0
  const BASE alpha_imag = CONST_IMAG0(alpha);
 8020b3e:	eeb0 8a47 	vmov.f32	s16, s14
 8020b42:	eef0 8a67 	vmov.f32	s17, s15
    const BASE x_real = REAL(X, ix);
 8020b46:	e95a 8902 	ldrd	r8, r9, [sl, #-8]
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 8020b4a:	ec51 0b19 	vmov	r0, r1, d9
 8020b4e:	4642      	mov	r2, r8
 8020b50:	464b      	mov	r3, r9
    const BASE x_imag = IMAG(X, ix);
 8020b52:	e9db 4502 	ldrd	r4, r5, [fp, #8]
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 8020b56:	f008 f807 	bl	8028b68 <__aeabi_dmul>
 8020b5a:	4622      	mov	r2, r4
 8020b5c:	462b      	mov	r3, r5
 8020b5e:	ec41 0b1a 	vmov	d10, r0, r1
 8020b62:	ec51 0b18 	vmov	r0, r1, d8
 8020b66:	f007 ffff 	bl	8028b68 <__aeabi_dmul>
 8020b6a:	4602      	mov	r2, r0
 8020b6c:	460b      	mov	r3, r1
 8020b6e:	ec51 0b1a 	vmov	r0, r1, d10
 8020b72:	f007 fe41 	bl	80287f8 <__aeabi_dsub>
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 8020b76:	4642      	mov	r2, r8
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 8020b78:	e94a 0102 	strd	r0, r1, [sl, #-8]
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 8020b7c:	464b      	mov	r3, r9
 8020b7e:	ec51 0b18 	vmov	r0, r1, d8
 8020b82:	f007 fff1 	bl	8028b68 <__aeabi_dmul>
 8020b86:	4622      	mov	r2, r4
 8020b88:	462b      	mov	r3, r5
 8020b8a:	4604      	mov	r4, r0
 8020b8c:	460d      	mov	r5, r1
 8020b8e:	ec51 0b19 	vmov	r0, r1, d9
 8020b92:	f007 ffe9 	bl	8028b68 <__aeabi_dmul>
 8020b96:	460b      	mov	r3, r1
 8020b98:	4602      	mov	r2, r0
 8020b9a:	4629      	mov	r1, r5
 8020b9c:	4620      	mov	r0, r4
 8020b9e:	f007 fe2d 	bl	80287fc <__adddf3>
  for (i = 0; i < N; i++) {
 8020ba2:	9b01      	ldr	r3, [sp, #4]
 8020ba4:	3601      	adds	r6, #1
 8020ba6:	42b3      	cmp	r3, r6
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 8020ba8:	e9cb 0102 	strd	r0, r1, [fp, #8]
  for (i = 0; i < N; i++) {
 8020bac:	44ba      	add	sl, r7
 8020bae:	44bb      	add	fp, r7
 8020bb0:	d1c9      	bne.n	8020b46 <cblas_zscal+0x36>
#define BASE double
#include "source_scal_c.h"
#undef BASE
}
 8020bb2:	b003      	add	sp, #12
 8020bb4:	ecbd 8b06 	vpop	{d8-d10}
 8020bb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08020bbc <cblas_zswap>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_zswap (const int N, void *X, const int incX, void *Y, const int incY)
{
 8020bbc:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8020bc0:	9f08      	ldr	r7, [sp, #32]
  INDEX ix = OFFSET(N, incX);
 8020bc2:	1e16      	subs	r6, r2, #0
 8020bc4:	bfda      	itte	le
 8020bc6:	f1c0 0c01 	rsble	ip, r0, #1
 8020bca:	fb0c fc06 	mulle.w	ip, ip, r6
 8020bce:	f04f 0c00 	movgt.w	ip, #0
  INDEX iy = OFFSET(N, incY);
 8020bd2:	2f00      	cmp	r7, #0
 8020bd4:	bfda      	itte	le
 8020bd6:	f1c0 0501 	rsble	r5, r0, #1
 8020bda:	437d      	mulle	r5, r7
 8020bdc:	2500      	movgt	r5, #0
  for (i = 0; i < N; i++) {
 8020bde:	2800      	cmp	r0, #0
 8020be0:	dd23      	ble.n	8020c2a <cblas_zswap+0x6e>
 8020be2:	eb03 1205 	add.w	r2, r3, r5, lsl #4
 8020be6:	eb01 140c 	add.w	r4, r1, ip, lsl #4
 8020bea:	eb03 1305 	add.w	r3, r3, r5, lsl #4
 8020bee:	0136      	lsls	r6, r6, #4
 8020bf0:	013f      	lsls	r7, r7, #4
 8020bf2:	3408      	adds	r4, #8
 8020bf4:	eb01 110c 	add.w	r1, r1, ip, lsl #4
 8020bf8:	3208      	adds	r2, #8
 8020bfa:	2500      	movs	r5, #0
    REAL(X, ix) = REAL(Y, iy);
 8020bfc:	ed12 7b02 	vldr	d7, [r2, #-8]
    const BASE tmp_real = REAL(X, ix);
 8020c00:	e954 ab02 	ldrd	sl, fp, [r4, #-8]
    const BASE tmp_imag = IMAG(X, ix);
 8020c04:	e9d1 8902 	ldrd	r8, r9, [r1, #8]
    REAL(X, ix) = REAL(Y, iy);
 8020c08:	ed04 7b02 	vstr	d7, [r4, #-8]
    IMAG(X, ix) = IMAG(Y, iy);
 8020c0c:	ed93 7b02 	vldr	d7, [r3, #8]
  for (i = 0; i < N; i++) {
 8020c10:	3501      	adds	r5, #1
 8020c12:	42a8      	cmp	r0, r5
    IMAG(X, ix) = IMAG(Y, iy);
 8020c14:	ed81 7b02 	vstr	d7, [r1, #8]
    REAL(Y, iy) = tmp_real;
 8020c18:	4434      	add	r4, r6
 8020c1a:	e942 ab02 	strd	sl, fp, [r2, #-8]
    IMAG(Y, iy) = tmp_imag;
 8020c1e:	4431      	add	r1, r6
 8020c20:	e9c3 8902 	strd	r8, r9, [r3, #8]
  for (i = 0; i < N; i++) {
 8020c24:	443a      	add	r2, r7
 8020c26:	443b      	add	r3, r7
 8020c28:	d1e8      	bne.n	8020bfc <cblas_zswap+0x40>
#define BASE double
#include "source_swap_c.h"
#undef BASE
}
 8020c2a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8020c2e:	4770      	bx	lr

08020c30 <cblas_zsymm>:
void
cblas_zsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 8020c30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020c34:	ed2d 8b10 	vpush	{d8-d15}
 8020c38:	b09d      	sub	sp, #116	; 0x74
 8020c3a:	298d      	cmp	r1, #141	; 0x8d
 8020c3c:	9307      	str	r3, [sp, #28]
 8020c3e:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8020c40:	930a      	str	r3, [sp, #40]	; 0x28
 8020c42:	e9dd 8337 	ldrd	r8, r3, [sp, #220]	; 0xdc
 8020c46:	930f      	str	r3, [sp, #60]	; 0x3c
 8020c48:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 8020c4a:	930e      	str	r3, [sp, #56]	; 0x38
 8020c4c:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8020c4e:	9311      	str	r3, [sp, #68]	; 0x44
 8020c50:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 8020c52:	9314      	str	r3, [sp, #80]	; 0x50
 8020c54:	e9dd 733c 	ldrd	r7, r3, [sp, #240]	; 0xf0
 8020c58:	9310      	str	r3, [sp, #64]	; 0x40
 8020c5a:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 8020c5c:	9313      	str	r3, [sp, #76]	; 0x4c
 8020c5e:	460c      	mov	r4, r1
 8020c60:	4606      	mov	r6, r0
 8020c62:	4615      	mov	r5, r2
 8020c64:	f000 8135 	beq.w	8020ed2 <cblas_zsymm+0x2a2>
 8020c68:	298e      	cmp	r1, #142	; 0x8e
 8020c6a:	f001 80cd 	beq.w	8021e08 <cblas_zsymm+0x11d8>
 8020c6e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020c70:	2002      	movs	r0, #2
 8020c72:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 8020c76:	2a01      	cmp	r2, #1
 8020c78:	9a07      	ldr	r2, [sp, #28]
 8020c7a:	bf88      	it	hi
 8020c7c:	2003      	movhi	r0, #3
 8020c7e:	2a00      	cmp	r2, #0
 8020c80:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020c82:	bfb8      	it	lt
 8020c84:	2004      	movlt	r0, #4
 8020c86:	2b01      	cmp	r3, #1
 8020c88:	bfb8      	it	lt
 8020c8a:	2301      	movlt	r3, #1
 8020c8c:	2a00      	cmp	r2, #0
 8020c8e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8020c90:	f2c0 8114 	blt.w	8020ebc <cblas_zsymm+0x28c>
 8020c94:	4293      	cmp	r3, r2
 8020c96:	f340 808c 	ble.w	8020db2 <cblas_zsymm+0x182>
 8020c9a:	2e65      	cmp	r6, #101	; 0x65
 8020c9c:	f000 84bb 	beq.w	8021616 <cblas_zsymm+0x9e6>
 8020ca0:	2e66      	cmp	r6, #102	; 0x66
 8020ca2:	f001 80a0 	beq.w	8021de6 <cblas_zsymm+0x11b6>
 8020ca6:	2008      	movs	r0, #8
 8020ca8:	4a91      	ldr	r2, [pc, #580]	; (8020ef0 <cblas_zsymm+0x2c0>)
 8020caa:	4992      	ldr	r1, [pc, #584]	; (8020ef4 <cblas_zsymm+0x2c4>)
 8020cac:	f007 fd2c 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8020cb0:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8020cb4:	2200      	movs	r2, #0
 8020cb6:	ec51 0b17 	vmov	r0, r1, d7
    const BASE alpha_real = CONST_REAL0(alpha);
 8020cba:	eeb0 fa47 	vmov.f32	s30, s14
 8020cbe:	eef0 fa67 	vmov.f32	s31, s15
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8020cc2:	2300      	movs	r3, #0
 8020cc4:	f008 f9b8 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8020cc8:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8020ccc:	e9d7 ab00 	ldrd	sl, fp, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8020cd0:	ed8d 7b04 	vstr	d7, [sp, #16]
    const BASE beta_imag = CONST_IMAG0(beta);
 8020cd4:	ed97 8b02 	vldr	d8, [r7, #8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8020cd8:	b170      	cbz	r0, 8020cf8 <cblas_zsymm+0xc8>
 8020cda:	ec51 0b17 	vmov	r0, r1, d7
 8020cde:	2200      	movs	r2, #0
 8020ce0:	2300      	movs	r3, #0
 8020ce2:	f008 f9a9 	bl	8029038 <__aeabi_dcmpeq>
 8020ce6:	b138      	cbz	r0, 8020cf8 <cblas_zsymm+0xc8>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8020ce8:	4b83      	ldr	r3, [pc, #524]	; (8020ef8 <cblas_zsymm+0x2c8>)
 8020cea:	2200      	movs	r2, #0
 8020cec:	4650      	mov	r0, sl
 8020cee:	4659      	mov	r1, fp
 8020cf0:	f008 f9a2 	bl	8029038 <__aeabi_dcmpeq>
 8020cf4:	2800      	cmp	r0, #0
 8020cf6:	d166      	bne.n	8020dc6 <cblas_zsymm+0x196>
    if (Order == CblasRowMajor) {
 8020cf8:	2e65      	cmp	r6, #101	; 0x65
 8020cfa:	f000 80f1 	beq.w	8020ee0 <cblas_zsymm+0x2b0>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8020cfe:	2d79      	cmp	r5, #121	; 0x79
 8020d00:	bf0c      	ite	eq
 8020d02:	237a      	moveq	r3, #122	; 0x7a
 8020d04:	2379      	movne	r3, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8020d06:	2c8d      	cmp	r4, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8020d08:	930b      	str	r3, [sp, #44]	; 0x2c
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8020d0a:	bf0c      	ite	eq
 8020d0c:	238e      	moveq	r3, #142	; 0x8e
 8020d0e:	238d      	movne	r3, #141	; 0x8d
 8020d10:	9309      	str	r3, [sp, #36]	; 0x24
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8020d12:	2200      	movs	r2, #0
 8020d14:	2300      	movs	r3, #0
 8020d16:	4650      	mov	r0, sl
 8020d18:	4659      	mov	r1, fp
 8020d1a:	f008 f98d 	bl	8029038 <__aeabi_dcmpeq>
 8020d1e:	2200      	movs	r2, #0
 8020d20:	2800      	cmp	r0, #0
 8020d22:	d05d      	beq.n	8020de0 <cblas_zsymm+0x1b0>
 8020d24:	ec51 0b18 	vmov	r0, r1, d8
 8020d28:	2300      	movs	r3, #0
 8020d2a:	f008 f985 	bl	8029038 <__aeabi_dcmpeq>
 8020d2e:	2800      	cmp	r0, #0
 8020d30:	d064      	beq.n	8020dfc <cblas_zsymm+0x1cc>
      for (i = 0; i < n1; i++) {
 8020d32:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020d34:	2b00      	cmp	r3, #0
 8020d36:	dd1c      	ble.n	8020d72 <cblas_zsymm+0x142>
 8020d38:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8020d3a:	9d07      	ldr	r5, [sp, #28]
 8020d3c:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 8020d40:	0114      	lsls	r4, r2, #4
 8020d42:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020d44:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 8020d48:	0100      	lsls	r0, r0, #4
 8020d4a:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 8020d4e:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 8020d50:	2600      	movs	r6, #0
 8020d52:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 8020d54:	2d00      	cmp	r5, #0
 8020d56:	bfc8      	it	gt
 8020d58:	1883      	addgt	r3, r0, r2
 8020d5a:	dd06      	ble.n	8020d6a <cblas_zsymm+0x13a>
          REAL(C, ldc * i + j) = 0.0;
 8020d5c:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 8020d60:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 8020d64:	3310      	adds	r3, #16
 8020d66:	429a      	cmp	r2, r3
 8020d68:	d1f8      	bne.n	8020d5c <cblas_zsymm+0x12c>
      for (i = 0; i < n1; i++) {
 8020d6a:	3101      	adds	r1, #1
 8020d6c:	458c      	cmp	ip, r1
 8020d6e:	4422      	add	r2, r4
 8020d70:	d1f0      	bne.n	8020d54 <cblas_zsymm+0x124>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8020d72:	ec51 0b1f 	vmov	r0, r1, d15
 8020d76:	2200      	movs	r2, #0
 8020d78:	2300      	movs	r3, #0
 8020d7a:	f008 f95d 	bl	8029038 <__aeabi_dcmpeq>
 8020d7e:	b130      	cbz	r0, 8020d8e <cblas_zsymm+0x15e>
 8020d80:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8020d84:	2200      	movs	r2, #0
 8020d86:	2300      	movs	r3, #0
 8020d88:	f008 f956 	bl	8029038 <__aeabi_dcmpeq>
 8020d8c:	bb18      	cbnz	r0, 8020dd6 <cblas_zsymm+0x1a6>
    if (side == CblasLeft && uplo == CblasUpper) {
 8020d8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020d90:	2b8d      	cmp	r3, #141	; 0x8d
 8020d92:	f000 80b5 	beq.w	8020f00 <cblas_zsymm+0x2d0>
    } else if (side == CblasRight && uplo == CblasUpper) {
 8020d96:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020d98:	2b8e      	cmp	r3, #142	; 0x8e
 8020d9a:	f000 8265 	beq.w	8021268 <cblas_zsymm+0x638>
      BLAS_ERROR("unrecognized operation");
 8020d9e:	4a57      	ldr	r2, [pc, #348]	; (8020efc <cblas_zsymm+0x2cc>)
 8020da0:	4954      	ldr	r1, [pc, #336]	; (8020ef4 <cblas_zsymm+0x2c4>)
 8020da2:	2000      	movs	r0, #0
#define BASE double
#include "source_symm_c.h"
#undef BASE
}
 8020da4:	b01d      	add	sp, #116	; 0x74
 8020da6:	ecbd 8b10 	vpop	{d8-d15}
 8020daa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020dae:	f007 bcab 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8020db2:	2e65      	cmp	r6, #101	; 0x65
 8020db4:	f000 843e 	beq.w	8021634 <cblas_zsymm+0xa04>
 8020db8:	2e66      	cmp	r6, #102	; 0x66
 8020dba:	f000 87bc 	beq.w	8021d36 <cblas_zsymm+0x1106>
 8020dbe:	2800      	cmp	r0, #0
 8020dc0:	f43f af76 	beq.w	8020cb0 <cblas_zsymm+0x80>
 8020dc4:	e770      	b.n	8020ca8 <cblas_zsymm+0x78>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8020dc6:	ec51 0b18 	vmov	r0, r1, d8
 8020dca:	2200      	movs	r2, #0
 8020dcc:	2300      	movs	r3, #0
 8020dce:	f008 f933 	bl	8029038 <__aeabi_dcmpeq>
 8020dd2:	2800      	cmp	r0, #0
 8020dd4:	d090      	beq.n	8020cf8 <cblas_zsymm+0xc8>
 8020dd6:	b01d      	add	sp, #116	; 0x74
 8020dd8:	ecbd 8b10 	vpop	{d8-d15}
 8020ddc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8020de0:	4b45      	ldr	r3, [pc, #276]	; (8020ef8 <cblas_zsymm+0x2c8>)
 8020de2:	4650      	mov	r0, sl
 8020de4:	4659      	mov	r1, fp
 8020de6:	f008 f927 	bl	8029038 <__aeabi_dcmpeq>
 8020dea:	b138      	cbz	r0, 8020dfc <cblas_zsymm+0x1cc>
 8020dec:	ec51 0b18 	vmov	r0, r1, d8
 8020df0:	2200      	movs	r2, #0
 8020df2:	2300      	movs	r3, #0
 8020df4:	f008 f920 	bl	8029038 <__aeabi_dcmpeq>
 8020df8:	2800      	cmp	r0, #0
 8020dfa:	d1ba      	bne.n	8020d72 <cblas_zsymm+0x142>
      for (i = 0; i < n1; i++) {
 8020dfc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020dfe:	2b00      	cmp	r3, #0
 8020e00:	ddb7      	ble.n	8020d72 <cblas_zsymm+0x142>
 8020e02:	9a07      	ldr	r2, [sp, #28]
 8020e04:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8020e08:	011b      	lsls	r3, r3, #4
 8020e0a:	9306      	str	r3, [sp, #24]
 8020e0c:	3308      	adds	r3, #8
 8020e0e:	9308      	str	r3, [sp, #32]
 8020e10:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8020e12:	011b      	lsls	r3, r3, #4
 8020e14:	9303      	str	r3, [sp, #12]
 8020e16:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020e18:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020e1c:	9301      	str	r3, [sp, #4]
 8020e1e:	2300      	movs	r3, #0
 8020e20:	9302      	str	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 8020e22:	9b07      	ldr	r3, [sp, #28]
 8020e24:	2b00      	cmp	r3, #0
 8020e26:	dd3e      	ble.n	8020ea6 <cblas_zsymm+0x276>
 8020e28:	9b06      	ldr	r3, [sp, #24]
 8020e2a:	9a08      	ldr	r2, [sp, #32]
 8020e2c:	4619      	mov	r1, r3
 8020e2e:	9b01      	ldr	r3, [sp, #4]
 8020e30:	eb01 0803 	add.w	r8, r1, r3
 8020e34:	eb02 0903 	add.w	r9, r2, r3
          const BASE Cij_real = REAL(C, ldc * i + j);
 8020e38:	e959 4502 	ldrd	r4, r5, [r9, #-8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8020e3c:	4650      	mov	r0, sl
 8020e3e:	4622      	mov	r2, r4
 8020e40:	462b      	mov	r3, r5
 8020e42:	4659      	mov	r1, fp
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 8020e44:	e9d8 6702 	ldrd	r6, r7, [r8, #8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8020e48:	f007 fe8e 	bl	8028b68 <__aeabi_dmul>
 8020e4c:	4632      	mov	r2, r6
 8020e4e:	ec41 0b19 	vmov	d9, r0, r1
 8020e52:	463b      	mov	r3, r7
 8020e54:	ec51 0b18 	vmov	r0, r1, d8
 8020e58:	f007 fe86 	bl	8028b68 <__aeabi_dmul>
 8020e5c:	4602      	mov	r2, r0
 8020e5e:	460b      	mov	r3, r1
 8020e60:	ec51 0b19 	vmov	r0, r1, d9
 8020e64:	f007 fcc8 	bl	80287f8 <__aeabi_dsub>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8020e68:	4632      	mov	r2, r6
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8020e6a:	e949 0102 	strd	r0, r1, [r9, #-8]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8020e6e:	463b      	mov	r3, r7
 8020e70:	4650      	mov	r0, sl
 8020e72:	4659      	mov	r1, fp
 8020e74:	f007 fe78 	bl	8028b68 <__aeabi_dmul>
 8020e78:	4622      	mov	r2, r4
 8020e7a:	462b      	mov	r3, r5
 8020e7c:	4604      	mov	r4, r0
 8020e7e:	460d      	mov	r5, r1
 8020e80:	ec51 0b18 	vmov	r0, r1, d8
 8020e84:	f007 fe70 	bl	8028b68 <__aeabi_dmul>
 8020e88:	460b      	mov	r3, r1
 8020e8a:	4602      	mov	r2, r0
 8020e8c:	4629      	mov	r1, r5
 8020e8e:	4620      	mov	r0, r4
 8020e90:	f007 fcb4 	bl	80287fc <__adddf3>
        for (j = 0; j < n2; j++) {
 8020e94:	9b01      	ldr	r3, [sp, #4]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8020e96:	e9c8 0102 	strd	r0, r1, [r8, #8]
        for (j = 0; j < n2; j++) {
 8020e9a:	f108 0810 	add.w	r8, r8, #16
 8020e9e:	4543      	cmp	r3, r8
 8020ea0:	f109 0910 	add.w	r9, r9, #16
 8020ea4:	d1c8      	bne.n	8020e38 <cblas_zsymm+0x208>
      for (i = 0; i < n1; i++) {
 8020ea6:	9a01      	ldr	r2, [sp, #4]
 8020ea8:	9903      	ldr	r1, [sp, #12]
 8020eaa:	9b02      	ldr	r3, [sp, #8]
 8020eac:	440a      	add	r2, r1
 8020eae:	9201      	str	r2, [sp, #4]
 8020eb0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020eb2:	3301      	adds	r3, #1
 8020eb4:	429a      	cmp	r2, r3
 8020eb6:	9302      	str	r3, [sp, #8]
 8020eb8:	d1b3      	bne.n	8020e22 <cblas_zsymm+0x1f2>
 8020eba:	e75a      	b.n	8020d72 <cblas_zsymm+0x142>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8020ebc:	429a      	cmp	r2, r3
 8020ebe:	f6ff aeec 	blt.w	8020c9a <cblas_zsymm+0x6a>
 8020ec2:	2e65      	cmp	r6, #101	; 0x65
 8020ec4:	f000 872c 	beq.w	8021d20 <cblas_zsymm+0x10f0>
 8020ec8:	2e66      	cmp	r6, #102	; 0x66
 8020eca:	f000 87ac 	beq.w	8021e26 <cblas_zsymm+0x11f6>
 8020ece:	2005      	movs	r0, #5
 8020ed0:	e6ea      	b.n	8020ca8 <cblas_zsymm+0x78>
 8020ed2:	3865      	subs	r0, #101	; 0x65
 8020ed4:	2801      	cmp	r0, #1
 8020ed6:	9b07      	ldr	r3, [sp, #28]
 8020ed8:	bf94      	ite	ls
 8020eda:	2000      	movls	r0, #0
 8020edc:	2001      	movhi	r0, #1
 8020ede:	e6c8      	b.n	8020c72 <cblas_zsymm+0x42>
      uplo = Uplo;
 8020ee0:	9a07      	ldr	r2, [sp, #28]
 8020ee2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020ee4:	950b      	str	r5, [sp, #44]	; 0x2c
      side = Side;
 8020ee6:	e9cd 4209 	strd	r4, r2, [sp, #36]	; 0x24
 8020eea:	9307      	str	r3, [sp, #28]
 8020eec:	e711      	b.n	8020d12 <cblas_zsymm+0xe2>
 8020eee:	bf00      	nop
 8020ef0:	08031108 	.word	0x08031108
 8020ef4:	08031360 	.word	0x08031360
 8020ef8:	3ff00000 	.word	0x3ff00000
 8020efc:	080311b8 	.word	0x080311b8
    if (side == CblasLeft && uplo == CblasUpper) {
 8020f00:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020f02:	2b79      	cmp	r3, #121	; 0x79
 8020f04:	f000 83a5 	beq.w	8021652 <cblas_zsymm+0xa22>
    } else if (side == CblasLeft && uplo == CblasLower) {
 8020f08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020f0a:	2b7a      	cmp	r3, #122	; 0x7a
 8020f0c:	f47f af47 	bne.w	8020d9e <cblas_zsymm+0x16e>
      for (i = 0; i < n1; i++) {
 8020f10:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020f12:	2b00      	cmp	r3, #0
 8020f14:	f77f af5f 	ble.w	8020dd6 <cblas_zsymm+0x1a6>
 8020f18:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020f1a:	3301      	adds	r3, #1
 8020f1c:	011a      	lsls	r2, r3, #4
 8020f1e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020f20:	9216      	str	r2, [sp, #88]	; 0x58
 8020f22:	3a10      	subs	r2, #16
 8020f24:	9215      	str	r2, [sp, #84]	; 0x54
 8020f26:	f103 0208 	add.w	r2, r3, #8
 8020f2a:	e9cd 230d 	strd	r2, r3, [sp, #52]	; 0x34
 8020f2e:	9301      	str	r3, [sp, #4]
 8020f30:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8020f32:	011b      	lsls	r3, r3, #4
 8020f34:	9303      	str	r3, [sp, #12]
 8020f36:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8020f38:	011b      	lsls	r3, r3, #4
 8020f3a:	9302      	str	r3, [sp, #8]
 8020f3c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8020f3e:	3308      	adds	r3, #8
 8020f40:	9317      	str	r3, [sp, #92]	; 0x5c
 8020f42:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020f44:	2100      	movs	r1, #0
 8020f46:	3308      	adds	r3, #8
 8020f48:	910f      	str	r1, [sp, #60]	; 0x3c
 8020f4a:	9112      	str	r1, [sp, #72]	; 0x48
 8020f4c:	910c      	str	r1, [sp, #48]	; 0x30
 8020f4e:	9318      	str	r3, [sp, #96]	; 0x60
        for (j = 0; j < n2; j++) {
 8020f50:	9b07      	ldr	r3, [sp, #28]
 8020f52:	2b00      	cmp	r3, #0
 8020f54:	f340 8168 	ble.w	8021228 <cblas_zsymm+0x5f8>
 8020f58:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8020f5a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8020f5c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020f60:	9308      	str	r3, [sp, #32]
 8020f62:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8020f64:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8020f66:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020f6a:	9306      	str	r3, [sp, #24]
 8020f6c:	2308      	movs	r3, #8
 8020f6e:	930b      	str	r3, [sp, #44]	; 0x2c
 8020f70:	2300      	movs	r3, #0
 8020f72:	9309      	str	r3, [sp, #36]	; 0x24
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8020f74:	9c08      	ldr	r4, [sp, #32]
 8020f76:	e954 6702 	ldrd	r6, r7, [r4, #-8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020f7a:	ec51 0b1f 	vmov	r0, r1, d15
 8020f7e:	4632      	mov	r2, r6
 8020f80:	463b      	mov	r3, r7
 8020f82:	f007 fdf1 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8020f86:	e9d4 8900 	ldrd	r8, r9, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020f8a:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8020f8e:	4604      	mov	r4, r0
 8020f90:	460d      	mov	r5, r1
 8020f92:	4642      	mov	r2, r8
 8020f94:	464b      	mov	r3, r9
 8020f96:	4650      	mov	r0, sl
 8020f98:	4659      	mov	r1, fp
 8020f9a:	f007 fde5 	bl	8028b68 <__aeabi_dmul>
 8020f9e:	4602      	mov	r2, r0
 8020fa0:	460b      	mov	r3, r1
 8020fa2:	4620      	mov	r0, r4
 8020fa4:	4629      	mov	r1, r5
 8020fa6:	f007 fc27 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020faa:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020fac:	4604      	mov	r4, r0
 8020fae:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020fb0:	464b      	mov	r3, r9
 8020fb2:	ec51 0b1f 	vmov	r0, r1, d15
 8020fb6:	f007 fdd7 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020fba:	ec45 4b1b 	vmov	d11, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020fbe:	4632      	mov	r2, r6
 8020fc0:	463b      	mov	r3, r7
 8020fc2:	4604      	mov	r4, r0
 8020fc4:	460d      	mov	r5, r1
 8020fc6:	4650      	mov	r0, sl
 8020fc8:	4659      	mov	r1, fp
 8020fca:	f007 fdcd 	bl	8028b68 <__aeabi_dmul>
 8020fce:	460b      	mov	r3, r1
 8020fd0:	4602      	mov	r2, r0
 8020fd2:	4629      	mov	r1, r5
 8020fd4:	4620      	mov	r0, r4
 8020fd6:	f007 fc11 	bl	80287fc <__adddf3>
          BASE temp2_imag = 0.0;
 8020fda:	ed9f 7ba1 	vldr	d7, [pc, #644]	; 8021260 <cblas_zsymm+0x630>
          for (k = 0; k < i; k++) {
 8020fde:	9b0c      	ldr	r3, [sp, #48]	; 0x30
          BASE temp2_imag = 0.0;
 8020fe0:	eeb0 da47 	vmov.f32	s26, s14
 8020fe4:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020fe8:	ec41 0b1e 	vmov	d14, r0, r1
          BASE temp2_real = 0.0;
 8020fec:	eeb0 ca47 	vmov.f32	s24, s14
 8020ff0:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < i; k++) {
 8020ff4:	2b00      	cmp	r3, #0
 8020ff6:	f000 8094 	beq.w	8021122 <cblas_zsymm+0x4f2>
 8020ffa:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8020ffc:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020ffe:	9909      	ldr	r1, [sp, #36]	; 0x24
 8021000:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8021004:	4610      	mov	r0, r2
 8021006:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021008:	eb03 1a01 	add.w	sl, r3, r1, lsl #4
 802100c:	eb00 0902 	add.w	r9, r0, r2
 8021010:	eb03 0802 	add.w	r8, r3, r2
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8021014:	e9db 6700 	ldrd	r6, r7, [fp]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8021018:	ec51 0b1b 	vmov	r0, r1, d11
 802101c:	4632      	mov	r2, r6
 802101e:	463b      	mov	r3, r7
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8021020:	e9db 4502 	ldrd	r4, r5, [fp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8021024:	f007 fda0 	bl	8028b68 <__aeabi_dmul>
 8021028:	4622      	mov	r2, r4
 802102a:	ec41 0b18 	vmov	d8, r0, r1
 802102e:	462b      	mov	r3, r5
 8021030:	ec51 0b1e 	vmov	r0, r1, d14
 8021034:	f007 fd98 	bl	8028b68 <__aeabi_dmul>
 8021038:	4602      	mov	r2, r0
 802103a:	460b      	mov	r3, r1
 802103c:	ec51 0b18 	vmov	r0, r1, d8
 8021040:	f007 fbda 	bl	80287f8 <__aeabi_dsub>
 8021044:	4602      	mov	r2, r0
 8021046:	460b      	mov	r3, r1
 8021048:	e958 0102 	ldrd	r0, r1, [r8, #-8]
 802104c:	f007 fbd6 	bl	80287fc <__adddf3>
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8021050:	ed19 8b02 	vldr	d8, [r9, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8021054:	ed99 9b00 	vldr	d9, [r9]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8021058:	4632      	mov	r2, r6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 802105a:	e948 0102 	strd	r0, r1, [r8, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 802105e:	463b      	mov	r3, r7
 8021060:	ec51 0b1e 	vmov	r0, r1, d14
 8021064:	f007 fd80 	bl	8028b68 <__aeabi_dmul>
 8021068:	4622      	mov	r2, r4
 802106a:	ec41 0b1a 	vmov	d10, r0, r1
 802106e:	462b      	mov	r3, r5
 8021070:	ec51 0b1b 	vmov	r0, r1, d11
 8021074:	f007 fd78 	bl	8028b68 <__aeabi_dmul>
 8021078:	4602      	mov	r2, r0
 802107a:	460b      	mov	r3, r1
 802107c:	ec51 0b1a 	vmov	r0, r1, d10
 8021080:	f007 fbbc 	bl	80287fc <__adddf3>
 8021084:	4602      	mov	r2, r0
 8021086:	460b      	mov	r3, r1
 8021088:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 802108c:	f007 fbb6 	bl	80287fc <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8021090:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8021094:	e9ca 0102 	strd	r0, r1, [sl, #8]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8021098:	4630      	mov	r0, r6
 802109a:	4639      	mov	r1, r7
 802109c:	f007 fd64 	bl	8028b68 <__aeabi_dmul>
 80210a0:	ec53 2b19 	vmov	r2, r3, d9
 80210a4:	ec41 0b1a 	vmov	d10, r0, r1
 80210a8:	4620      	mov	r0, r4
 80210aa:	4629      	mov	r1, r5
 80210ac:	f007 fd5c 	bl	8028b68 <__aeabi_dmul>
 80210b0:	4602      	mov	r2, r0
 80210b2:	460b      	mov	r3, r1
 80210b4:	ec51 0b1a 	vmov	r0, r1, d10
 80210b8:	f007 fb9e 	bl	80287f8 <__aeabi_dsub>
 80210bc:	4602      	mov	r2, r0
 80210be:	460b      	mov	r3, r1
 80210c0:	ec51 0b1c 	vmov	r0, r1, d12
 80210c4:	f007 fb9a 	bl	80287fc <__adddf3>
 80210c8:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80210cc:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80210d0:	eeb0 ca47 	vmov.f32	s24, s14
 80210d4:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80210d8:	4630      	mov	r0, r6
 80210da:	4639      	mov	r1, r7
 80210dc:	f007 fd44 	bl	8028b68 <__aeabi_dmul>
 80210e0:	ec53 2b18 	vmov	r2, r3, d8
 80210e4:	4606      	mov	r6, r0
 80210e6:	460f      	mov	r7, r1
 80210e8:	4620      	mov	r0, r4
 80210ea:	4629      	mov	r1, r5
 80210ec:	f007 fd3c 	bl	8028b68 <__aeabi_dmul>
 80210f0:	4602      	mov	r2, r0
 80210f2:	460b      	mov	r3, r1
 80210f4:	4630      	mov	r0, r6
 80210f6:	4639      	mov	r1, r7
 80210f8:	f007 fb80 	bl	80287fc <__adddf3>
 80210fc:	460b      	mov	r3, r1
 80210fe:	4602      	mov	r2, r0
 8021100:	ec51 0b1d 	vmov	r0, r1, d13
 8021104:	f007 fb7a 	bl	80287fc <__adddf3>
 8021108:	9b02      	ldr	r3, [sp, #8]
 802110a:	4499      	add	r9, r3
 802110c:	9b03      	ldr	r3, [sp, #12]
 802110e:	4498      	add	r8, r3
 8021110:	449a      	add	sl, r3
          for (k = 0; k < i; k++) {
 8021112:	9b01      	ldr	r3, [sp, #4]
 8021114:	f10b 0b10 	add.w	fp, fp, #16
 8021118:	455b      	cmp	r3, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 802111a:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < i; k++) {
 802111e:	f47f af79 	bne.w	8021014 <cblas_zsymm+0x3e4>
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8021122:	9b01      	ldr	r3, [sp, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8021124:	9c0d      	ldr	r4, [sp, #52]	; 0x34
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8021126:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 802112a:	ec51 0b1b 	vmov	r0, r1, d11
 802112e:	4642      	mov	r2, r8
 8021130:	464b      	mov	r3, r9
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8021132:	e954 6702 	ldrd	r6, r7, [r4, #-8]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8021136:	f007 fd17 	bl	8028b68 <__aeabi_dmul>
 802113a:	4632      	mov	r2, r6
 802113c:	463b      	mov	r3, r7
 802113e:	4604      	mov	r4, r0
 8021140:	460d      	mov	r5, r1
 8021142:	ec51 0b1e 	vmov	r0, r1, d14
 8021146:	f007 fd0f 	bl	8028b68 <__aeabi_dmul>
 802114a:	4602      	mov	r2, r0
 802114c:	460b      	mov	r3, r1
 802114e:	4620      	mov	r0, r4
 8021150:	4629      	mov	r1, r5
 8021152:	f007 fb53 	bl	80287fc <__adddf3>
 8021156:	9b06      	ldr	r3, [sp, #24]
 8021158:	e9d3 2300 	ldrd	r2, r3, [r3]
 802115c:	f007 fb4e 	bl	80287fc <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8021160:	4632      	mov	r2, r6
 8021162:	463b      	mov	r3, r7
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8021164:	4682      	mov	sl, r0
 8021166:	468b      	mov	fp, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8021168:	ec51 0b1b 	vmov	r0, r1, d11
 802116c:	f007 fcfc 	bl	8028b68 <__aeabi_dmul>
 8021170:	4642      	mov	r2, r8
 8021172:	464b      	mov	r3, r9
 8021174:	4604      	mov	r4, r0
 8021176:	460d      	mov	r5, r1
 8021178:	ec51 0b1e 	vmov	r0, r1, d14
 802117c:	f007 fcf4 	bl	8028b68 <__aeabi_dmul>
 8021180:	4602      	mov	r2, r0
 8021182:	460b      	mov	r3, r1
 8021184:	4620      	mov	r0, r4
 8021186:	4629      	mov	r1, r5
 8021188:	f007 fb36 	bl	80287f8 <__aeabi_dsub>
 802118c:	9a06      	ldr	r2, [sp, #24]
 802118e:	e952 2302 	ldrd	r2, r3, [r2, #-8]
 8021192:	f007 fb33 	bl	80287fc <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021196:	ec53 2b1c 	vmov	r2, r3, d12
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 802119a:	4604      	mov	r4, r0
 802119c:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 802119e:	ec51 0b1f 	vmov	r0, r1, d15
 80211a2:	f007 fce1 	bl	8028b68 <__aeabi_dmul>
 80211a6:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 80211aa:	ec53 2b1d 	vmov	r2, r3, d13
 80211ae:	4606      	mov	r6, r0
 80211b0:	460f      	mov	r7, r1
 80211b2:	4640      	mov	r0, r8
 80211b4:	4649      	mov	r1, r9
 80211b6:	f007 fcd7 	bl	8028b68 <__aeabi_dmul>
 80211ba:	4602      	mov	r2, r0
 80211bc:	460b      	mov	r3, r1
 80211be:	4630      	mov	r0, r6
 80211c0:	4639      	mov	r1, r7
 80211c2:	f007 fb19 	bl	80287f8 <__aeabi_dsub>
 80211c6:	4602      	mov	r2, r0
 80211c8:	460b      	mov	r3, r1
 80211ca:	4620      	mov	r0, r4
 80211cc:	4629      	mov	r1, r5
 80211ce:	f007 fb15 	bl	80287fc <__adddf3>
 80211d2:	9e06      	ldr	r6, [sp, #24]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80211d4:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80211d8:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80211dc:	ec51 0b1f 	vmov	r0, r1, d15
 80211e0:	f007 fcc2 	bl	8028b68 <__aeabi_dmul>
 80211e4:	ec53 2b1c 	vmov	r2, r3, d12
 80211e8:	4604      	mov	r4, r0
 80211ea:	460d      	mov	r5, r1
 80211ec:	4640      	mov	r0, r8
 80211ee:	4649      	mov	r1, r9
 80211f0:	f007 fcba 	bl	8028b68 <__aeabi_dmul>
 80211f4:	4602      	mov	r2, r0
 80211f6:	460b      	mov	r3, r1
 80211f8:	4620      	mov	r0, r4
 80211fa:	4629      	mov	r1, r5
 80211fc:	f007 fafe 	bl	80287fc <__adddf3>
 8021200:	4652      	mov	r2, sl
 8021202:	465b      	mov	r3, fp
 8021204:	f007 fafa 	bl	80287fc <__adddf3>
 8021208:	9a08      	ldr	r2, [sp, #32]
        for (j = 0; j < n2; j++) {
 802120a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802120c:	3210      	adds	r2, #16
 802120e:	9208      	str	r2, [sp, #32]
 8021210:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021212:	3301      	adds	r3, #1
 8021214:	3210      	adds	r2, #16
 8021216:	920b      	str	r2, [sp, #44]	; 0x2c
 8021218:	9309      	str	r3, [sp, #36]	; 0x24
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802121a:	e8e6 0104 	strd	r0, r1, [r6], #16
        for (j = 0; j < n2; j++) {
 802121e:	9a07      	ldr	r2, [sp, #28]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021220:	9606      	str	r6, [sp, #24]
        for (j = 0; j < n2; j++) {
 8021222:	429a      	cmp	r2, r3
 8021224:	f47f aea6 	bne.w	8020f74 <cblas_zsymm+0x344>
      for (i = 0; i < n1; i++) {
 8021228:	9901      	ldr	r1, [sp, #4]
 802122a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802122c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802122e:	4608      	mov	r0, r1
 8021230:	4410      	add	r0, r2
 8021232:	9001      	str	r0, [sp, #4]
 8021234:	e9dd 1012 	ldrd	r1, r0, [sp, #72]	; 0x48
 8021238:	4401      	add	r1, r0
 802123a:	9112      	str	r1, [sp, #72]	; 0x48
 802123c:	9814      	ldr	r0, [sp, #80]	; 0x50
 802123e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8021240:	4401      	add	r1, r0
 8021242:	910f      	str	r1, [sp, #60]	; 0x3c
 8021244:	9815      	ldr	r0, [sp, #84]	; 0x54
 8021246:	990e      	ldr	r1, [sp, #56]	; 0x38
 8021248:	4401      	add	r1, r0
 802124a:	910e      	str	r1, [sp, #56]	; 0x38
 802124c:	990d      	ldr	r1, [sp, #52]	; 0x34
 802124e:	4411      	add	r1, r2
 8021250:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021252:	910d      	str	r1, [sp, #52]	; 0x34
 8021254:	3301      	adds	r3, #1
 8021256:	429a      	cmp	r2, r3
 8021258:	930c      	str	r3, [sp, #48]	; 0x30
 802125a:	f47f ae79 	bne.w	8020f50 <cblas_zsymm+0x320>
 802125e:	e5ba      	b.n	8020dd6 <cblas_zsymm+0x1a6>
	...
    } else if (side == CblasRight && uplo == CblasUpper) {
 8021268:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802126a:	2b79      	cmp	r3, #121	; 0x79
 802126c:	f000 83c0 	beq.w	80219f0 <cblas_zsymm+0xdc0>
    } else if (side == CblasRight && uplo == CblasLower) {
 8021270:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8021272:	2b7a      	cmp	r3, #122	; 0x7a
 8021274:	f47f ad93 	bne.w	8020d9e <cblas_zsymm+0x16e>
      for (i = 0; i < n1; i++) {
 8021278:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802127a:	2b00      	cmp	r3, #0
 802127c:	f77f adab 	ble.w	8020dd6 <cblas_zsymm+0x1a6>
 8021280:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021282:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8021284:	0112      	lsls	r2, r2, #4
 8021286:	9215      	str	r2, [sp, #84]	; 0x54
 8021288:	9a14      	ldr	r2, [sp, #80]	; 0x50
 802128a:	0112      	lsls	r2, r2, #4
 802128c:	3301      	adds	r3, #1
 802128e:	9213      	str	r2, [sp, #76]	; 0x4c
 8021290:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8021292:	920d      	str	r2, [sp, #52]	; 0x34
 8021294:	011a      	lsls	r2, r3, #4
 8021296:	9211      	str	r2, [sp, #68]	; 0x44
 8021298:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802129a:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 802129e:	9314      	str	r3, [sp, #80]	; 0x50
 80212a0:	2300      	movs	r3, #0
 80212a2:	9312      	str	r3, [sp, #72]	; 0x48
        for (j = 0; j < n2; j++) {
 80212a4:	9b07      	ldr	r3, [sp, #28]
 80212a6:	2b00      	cmp	r3, #0
 80212a8:	f340 8547 	ble.w	8021d3a <cblas_zsymm+0x110a>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80212ac:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 80212ae:	e9d4 8900 	ldrd	r8, r9, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80212b2:	ec53 2b1f 	vmov	r2, r3, d15
 80212b6:	4640      	mov	r0, r8
 80212b8:	4649      	mov	r1, r9
 80212ba:	f007 fc55 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80212be:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80212c2:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80212c6:	4604      	mov	r4, r0
 80212c8:	460d      	mov	r5, r1
 80212ca:	4652      	mov	r2, sl
 80212cc:	465b      	mov	r3, fp
 80212ce:	4630      	mov	r0, r6
 80212d0:	4639      	mov	r1, r7
 80212d2:	f007 fc49 	bl	8028b68 <__aeabi_dmul>
 80212d6:	4602      	mov	r2, r0
 80212d8:	460b      	mov	r3, r1
 80212da:	4620      	mov	r0, r4
 80212dc:	4629      	mov	r1, r5
 80212de:	f007 fa8b 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80212e2:	4652      	mov	r2, sl
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80212e4:	4604      	mov	r4, r0
 80212e6:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80212e8:	465b      	mov	r3, fp
 80212ea:	4640      	mov	r0, r8
 80212ec:	4649      	mov	r1, r9
 80212ee:	f007 fc3b 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80212f2:	ec45 4b1b 	vmov	d11, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80212f6:	ec53 2b1f 	vmov	r2, r3, d15
 80212fa:	4604      	mov	r4, r0
 80212fc:	460d      	mov	r5, r1
 80212fe:	4630      	mov	r0, r6
 8021300:	4639      	mov	r1, r7
 8021302:	f007 fc31 	bl	8028b68 <__aeabi_dmul>
 8021306:	460b      	mov	r3, r1
 8021308:	4602      	mov	r2, r0
 802130a:	4629      	mov	r1, r5
 802130c:	4620      	mov	r0, r4
 802130e:	f007 fa75 	bl	80287fc <__adddf3>
 8021312:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021314:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8021316:	940b      	str	r4, [sp, #44]	; 0x2c
 8021318:	3308      	adds	r3, #8
 802131a:	9308      	str	r3, [sp, #32]
 802131c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802131e:	9303      	str	r3, [sp, #12]
 8021320:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8021322:	9309      	str	r3, [sp, #36]	; 0x24
          BASE temp2_imag = 0.0;
 8021324:	ed1f 7b32 	vldr	d7, [pc, #-200]	; 8021260 <cblas_zsymm+0x630>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021328:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802132a:	9306      	str	r3, [sp, #24]
 802132c:	ec41 0b1a 	vmov	d10, r0, r1
          BASE temp2_imag = 0.0;
 8021330:	eeb0 da47 	vmov.f32	s26, s14
 8021334:	eef0 da67 	vmov.f32	s27, s15
        for (j = 0; j < n2; j++) {
 8021338:	2300      	movs	r3, #0
 802133a:	930c      	str	r3, [sp, #48]	; 0x30
          BASE temp2_real = 0.0;
 802133c:	eeb0 ca47 	vmov.f32	s24, s14
 8021340:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8021344:	9c08      	ldr	r4, [sp, #32]
 8021346:	e9d4 6700 	ldrd	r6, r7, [r4]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 802134a:	ec53 2b1b 	vmov	r2, r3, d11
 802134e:	4630      	mov	r0, r6
 8021350:	4639      	mov	r1, r7
 8021352:	f007 fc09 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8021356:	e954 8902 	ldrd	r8, r9, [r4, #-8]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 802135a:	ec5b ab1a 	vmov	sl, fp, d10
 802135e:	4604      	mov	r4, r0
 8021360:	465b      	mov	r3, fp
 8021362:	460d      	mov	r5, r1
 8021364:	ee1a 2a10 	vmov	r2, s20
 8021368:	4640      	mov	r0, r8
 802136a:	4649      	mov	r1, r9
 802136c:	f007 fbfc 	bl	8028b68 <__aeabi_dmul>
 8021370:	4602      	mov	r2, r0
 8021372:	460b      	mov	r3, r1
 8021374:	4620      	mov	r0, r4
 8021376:	4629      	mov	r1, r5
 8021378:	f007 fa40 	bl	80287fc <__adddf3>
 802137c:	9b06      	ldr	r3, [sp, #24]
 802137e:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 8021382:	f007 fa3b 	bl	80287fc <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8021386:	ec53 2b1b 	vmov	r2, r3, d11
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 802138a:	4604      	mov	r4, r0
 802138c:	460d      	mov	r5, r1
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 802138e:	4640      	mov	r0, r8
 8021390:	4649      	mov	r1, r9
 8021392:	f007 fbe9 	bl	8028b68 <__aeabi_dmul>
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8021396:	46a0      	mov	r8, r4
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8021398:	465b      	mov	r3, fp
 802139a:	4604      	mov	r4, r0
 802139c:	ee1a 2a10 	vmov	r2, s20
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80213a0:	46a9      	mov	r9, r5
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80213a2:	4630      	mov	r0, r6
 80213a4:	460d      	mov	r5, r1
 80213a6:	4639      	mov	r1, r7
 80213a8:	f007 fbde 	bl	8028b68 <__aeabi_dmul>
 80213ac:	4602      	mov	r2, r0
 80213ae:	460b      	mov	r3, r1
 80213b0:	4620      	mov	r0, r4
 80213b2:	4629      	mov	r1, r5
 80213b4:	f007 fa20 	bl	80287f8 <__aeabi_dsub>
 80213b8:	9a06      	ldr	r2, [sp, #24]
 80213ba:	e9d2 2300 	ldrd	r2, r3, [r2]
 80213be:	f007 fa1d 	bl	80287fc <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80213c2:	ec53 2b1c 	vmov	r2, r3, d12
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80213c6:	4604      	mov	r4, r0
 80213c8:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80213ca:	ec51 0b1f 	vmov	r0, r1, d15
 80213ce:	f007 fbcb 	bl	8028b68 <__aeabi_dmul>
 80213d2:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80213d6:	ec53 2b1d 	vmov	r2, r3, d13
 80213da:	4606      	mov	r6, r0
 80213dc:	460f      	mov	r7, r1
 80213de:	4650      	mov	r0, sl
 80213e0:	4659      	mov	r1, fp
 80213e2:	f007 fbc1 	bl	8028b68 <__aeabi_dmul>
 80213e6:	4602      	mov	r2, r0
 80213e8:	460b      	mov	r3, r1
 80213ea:	4630      	mov	r0, r6
 80213ec:	4639      	mov	r1, r7
 80213ee:	f007 fa03 	bl	80287f8 <__aeabi_dsub>
 80213f2:	4602      	mov	r2, r0
 80213f4:	460b      	mov	r3, r1
 80213f6:	4620      	mov	r0, r4
 80213f8:	4629      	mov	r1, r5
 80213fa:	f007 f9ff 	bl	80287fc <__adddf3>
 80213fe:	9e06      	ldr	r6, [sp, #24]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021400:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021404:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021408:	ec51 0b1f 	vmov	r0, r1, d15
 802140c:	f007 fbac 	bl	8028b68 <__aeabi_dmul>
 8021410:	ec53 2b1c 	vmov	r2, r3, d12
 8021414:	4604      	mov	r4, r0
 8021416:	460d      	mov	r5, r1
 8021418:	4650      	mov	r0, sl
 802141a:	4659      	mov	r1, fp
 802141c:	f007 fba4 	bl	8028b68 <__aeabi_dmul>
 8021420:	4602      	mov	r2, r0
 8021422:	460b      	mov	r3, r1
 8021424:	4620      	mov	r0, r4
 8021426:	4629      	mov	r1, r5
 8021428:	f007 f9e8 	bl	80287fc <__adddf3>
 802142c:	4642      	mov	r2, r8
 802142e:	464b      	mov	r3, r9
 8021430:	f007 f9e4 	bl	80287fc <__adddf3>
        for (j = 0; j < n2; j++) {
 8021434:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8021436:	9a07      	ldr	r2, [sp, #28]
 8021438:	3301      	adds	r3, #1
 802143a:	429a      	cmp	r2, r3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802143c:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8021440:	930c      	str	r3, [sp, #48]	; 0x30
 8021442:	f000 847a 	beq.w	8021d3a <cblas_zsymm+0x110a>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8021446:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8021448:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802144c:	ec51 0b1f 	vmov	r0, r1, d15
 8021450:	4632      	mov	r2, r6
 8021452:	463b      	mov	r3, r7
 8021454:	f007 fb88 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8021458:	e9d4 8906 	ldrd	r8, r9, [r4, #24]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802145c:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8021460:	4604      	mov	r4, r0
 8021462:	460d      	mov	r5, r1
 8021464:	4642      	mov	r2, r8
 8021466:	464b      	mov	r3, r9
 8021468:	4650      	mov	r0, sl
 802146a:	4659      	mov	r1, fp
 802146c:	f007 fb7c 	bl	8028b68 <__aeabi_dmul>
 8021470:	4602      	mov	r2, r0
 8021472:	460b      	mov	r3, r1
 8021474:	4620      	mov	r0, r4
 8021476:	4629      	mov	r1, r5
 8021478:	f007 f9be 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802147c:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802147e:	4604      	mov	r4, r0
 8021480:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021482:	464b      	mov	r3, r9
 8021484:	ec51 0b1f 	vmov	r0, r1, d15
 8021488:	f007 fb6e 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802148c:	ec45 4b1b 	vmov	d11, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021490:	4632      	mov	r2, r6
 8021492:	463b      	mov	r3, r7
 8021494:	4604      	mov	r4, r0
 8021496:	460d      	mov	r5, r1
 8021498:	4650      	mov	r0, sl
 802149a:	4659      	mov	r1, fp
 802149c:	f007 fb64 	bl	8028b68 <__aeabi_dmul>
 80214a0:	4602      	mov	r2, r0
 80214a2:	460b      	mov	r3, r1
 80214a4:	4620      	mov	r0, r4
 80214a6:	4629      	mov	r1, r5
 80214a8:	f007 f9a8 	bl	80287fc <__adddf3>
 80214ac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80214ae:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80214b0:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 80214b4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80214b6:	9301      	str	r3, [sp, #4]
          BASE temp2_imag = 0.0;
 80214b8:	ed1f 7b97 	vldr	d7, [pc, #-604]	; 8021260 <cblas_zsymm+0x630>
 80214bc:	f103 0b08 	add.w	fp, r3, #8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80214c0:	ec41 0b1a 	vmov	d10, r0, r1
          BASE temp2_imag = 0.0;
 80214c4:	eeb0 da47 	vmov.f32	s26, s14
 80214c8:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80214cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80214ce:	9302      	str	r3, [sp, #8]
          BASE temp2_real = 0.0;
 80214d0:	eeb0 ca47 	vmov.f32	s24, s14
 80214d4:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80214d8:	e9da 8900 	ldrd	r8, r9, [sl]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80214dc:	ec51 0b1b 	vmov	r0, r1, d11
 80214e0:	4642      	mov	r2, r8
 80214e2:	464b      	mov	r3, r9
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80214e4:	e9da 4502 	ldrd	r4, r5, [sl, #8]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 80214e8:	f007 fb3e 	bl	8028b68 <__aeabi_dmul>
 80214ec:	4622      	mov	r2, r4
 80214ee:	4606      	mov	r6, r0
 80214f0:	460f      	mov	r7, r1
 80214f2:	462b      	mov	r3, r5
 80214f4:	ec51 0b1a 	vmov	r0, r1, d10
 80214f8:	f007 fb36 	bl	8028b68 <__aeabi_dmul>
 80214fc:	4602      	mov	r2, r0
 80214fe:	460b      	mov	r3, r1
 8021500:	4630      	mov	r0, r6
 8021502:	4639      	mov	r1, r7
 8021504:	f007 f978 	bl	80287f8 <__aeabi_dsub>
 8021508:	4602      	mov	r2, r0
 802150a:	460b      	mov	r3, r1
 802150c:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8021510:	f007 f974 	bl	80287fc <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8021514:	9b02      	ldr	r3, [sp, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8021516:	4622      	mov	r2, r4
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8021518:	ed93 8b00 	vldr	d8, [r3]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 802151c:	ed93 9b02 	vldr	d9, [r3, #8]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8021520:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8021524:	462b      	mov	r3, r5
 8021526:	ec51 0b1b 	vmov	r0, r1, d11
 802152a:	f007 fb1d 	bl	8028b68 <__aeabi_dmul>
 802152e:	4642      	mov	r2, r8
 8021530:	4606      	mov	r6, r0
 8021532:	460f      	mov	r7, r1
 8021534:	464b      	mov	r3, r9
 8021536:	ec51 0b1a 	vmov	r0, r1, d10
 802153a:	f007 fb15 	bl	8028b68 <__aeabi_dmul>
 802153e:	4602      	mov	r2, r0
 8021540:	460b      	mov	r3, r1
 8021542:	4630      	mov	r0, r6
 8021544:	4639      	mov	r1, r7
 8021546:	f007 f959 	bl	80287fc <__adddf3>
 802154a:	9e01      	ldr	r6, [sp, #4]
 802154c:	4602      	mov	r2, r0
 802154e:	460b      	mov	r3, r1
 8021550:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8021554:	f007 f952 	bl	80287fc <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021558:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 802155c:	e9c6 0102 	strd	r0, r1, [r6, #8]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021560:	4640      	mov	r0, r8
 8021562:	4649      	mov	r1, r9
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8021564:	9601      	str	r6, [sp, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021566:	f007 faff 	bl	8028b68 <__aeabi_dmul>
 802156a:	ec53 2b19 	vmov	r2, r3, d9
 802156e:	4606      	mov	r6, r0
 8021570:	460f      	mov	r7, r1
 8021572:	4620      	mov	r0, r4
 8021574:	4629      	mov	r1, r5
 8021576:	f007 faf7 	bl	8028b68 <__aeabi_dmul>
 802157a:	4602      	mov	r2, r0
 802157c:	460b      	mov	r3, r1
 802157e:	4630      	mov	r0, r6
 8021580:	4639      	mov	r1, r7
 8021582:	f007 f939 	bl	80287f8 <__aeabi_dsub>
 8021586:	4602      	mov	r2, r0
 8021588:	460b      	mov	r3, r1
 802158a:	ec51 0b1c 	vmov	r0, r1, d12
 802158e:	f007 f935 	bl	80287fc <__adddf3>
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8021592:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021596:	4606      	mov	r6, r0
 8021598:	460f      	mov	r7, r1
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 802159a:	4620      	mov	r0, r4
 802159c:	4629      	mov	r1, r5
 802159e:	f007 fae3 	bl	8028b68 <__aeabi_dmul>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 80215a2:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 80215a6:	ec53 2b19 	vmov	r2, r3, d9
 80215aa:	4606      	mov	r6, r0
 80215ac:	460f      	mov	r7, r1
 80215ae:	4640      	mov	r0, r8
 80215b0:	4649      	mov	r1, r9
 80215b2:	f007 fad9 	bl	8028b68 <__aeabi_dmul>
 80215b6:	4602      	mov	r2, r0
 80215b8:	460b      	mov	r3, r1
 80215ba:	4630      	mov	r0, r6
 80215bc:	4639      	mov	r1, r7
 80215be:	f007 f91d 	bl	80287fc <__adddf3>
 80215c2:	460b      	mov	r3, r1
 80215c4:	4602      	mov	r2, r0
 80215c6:	ec51 0b1d 	vmov	r0, r1, d13
 80215ca:	f007 f917 	bl	80287fc <__adddf3>
 80215ce:	9b02      	ldr	r3, [sp, #8]
 80215d0:	9e01      	ldr	r6, [sp, #4]
 80215d2:	3310      	adds	r3, #16
 80215d4:	9302      	str	r3, [sp, #8]
 80215d6:	f106 0310 	add.w	r3, r6, #16
 80215da:	9301      	str	r3, [sp, #4]
          for (k = 0; k < j; k++) {
 80215dc:	9b03      	ldr	r3, [sp, #12]
 80215de:	f10a 0a10 	add.w	sl, sl, #16
 80215e2:	4553      	cmp	r3, sl
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 80215e4:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < j; k++) {
 80215e8:	f10b 0b10 	add.w	fp, fp, #16
 80215ec:	f47f af74 	bne.w	80214d8 <cblas_zsymm+0x8a8>
 80215f0:	9b06      	ldr	r3, [sp, #24]
 80215f2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80215f4:	3310      	adds	r3, #16
 80215f6:	9306      	str	r3, [sp, #24]
 80215f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80215fa:	3310      	adds	r3, #16
 80215fc:	930b      	str	r3, [sp, #44]	; 0x2c
 80215fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8021600:	4413      	add	r3, r2
 8021602:	9a03      	ldr	r2, [sp, #12]
 8021604:	9309      	str	r3, [sp, #36]	; 0x24
 8021606:	4611      	mov	r1, r2
 8021608:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802160a:	9a08      	ldr	r2, [sp, #32]
 802160c:	4419      	add	r1, r3
 802160e:	441a      	add	r2, r3
 8021610:	9103      	str	r1, [sp, #12]
 8021612:	9208      	str	r2, [sp, #32]
 8021614:	e696      	b.n	8021344 <cblas_zsymm+0x714>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8021616:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021618:	9a14      	ldr	r2, [sp, #80]	; 0x50
 802161a:	2b01      	cmp	r3, #1
 802161c:	bfb8      	it	lt
 802161e:	2301      	movlt	r3, #1
 8021620:	4293      	cmp	r3, r2
 8021622:	f300 8381 	bgt.w	8021d28 <cblas_zsymm+0x10f8>
 8021626:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021628:	4293      	cmp	r3, r2
 802162a:	bfcc      	ite	gt
 802162c:	200d      	movgt	r0, #13
 802162e:	2008      	movle	r0, #8
 8021630:	f7ff bb3a 	b.w	8020ca8 <cblas_zsymm+0x78>
 8021634:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021636:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8021638:	2b01      	cmp	r3, #1
 802163a:	bfb8      	it	lt
 802163c:	2301      	movlt	r3, #1
 802163e:	4293      	cmp	r3, r2
 8021640:	f300 8372 	bgt.w	8021d28 <cblas_zsymm+0x10f8>
 8021644:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021646:	4293      	cmp	r3, r2
 8021648:	f77f abb9 	ble.w	8020dbe <cblas_zsymm+0x18e>
 802164c:	200d      	movs	r0, #13
 802164e:	f7ff bb2b 	b.w	8020ca8 <cblas_zsymm+0x78>
      for (i = 0; i < n1; i++) {
 8021652:	990a      	ldr	r1, [sp, #40]	; 0x28
 8021654:	2900      	cmp	r1, #0
 8021656:	f77f abbe 	ble.w	8020dd6 <cblas_zsymm+0x1a6>
 802165a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802165c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802165e:	920b      	str	r2, [sp, #44]	; 0x2c
 8021660:	3301      	adds	r3, #1
 8021662:	0118      	lsls	r0, r3, #4
 8021664:	f1a2 0310 	sub.w	r3, r2, #16
 8021668:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 802166c:	9302      	str	r3, [sp, #8]
 802166e:	f102 0308 	add.w	r3, r2, #8
 8021672:	930e      	str	r3, [sp, #56]	; 0x38
 8021674:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8021676:	901b      	str	r0, [sp, #108]	; 0x6c
 8021678:	011a      	lsls	r2, r3, #4
 802167a:	9206      	str	r2, [sp, #24]
 802167c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802167e:	2400      	movs	r4, #0
 8021680:	e9cd 2315 	strd	r2, r3, [sp, #84]	; 0x54
 8021684:	3810      	subs	r0, #16
 8021686:	0111      	lsls	r1, r2, #4
 8021688:	2301      	movs	r3, #1
 802168a:	9417      	str	r4, [sp, #92]	; 0x5c
 802168c:	901a      	str	r0, [sp, #104]	; 0x68
 802168e:	9418      	str	r4, [sp, #96]	; 0x60
 8021690:	9103      	str	r1, [sp, #12]
 8021692:	930d      	str	r3, [sp, #52]	; 0x34
        for (j = 0; j < n2; j++) {
 8021694:	9b07      	ldr	r3, [sp, #28]
 8021696:	2b00      	cmp	r3, #0
 8021698:	f340 83b3 	ble.w	8021e02 <cblas_zsymm+0x11d2>
 802169c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802169e:	9918      	ldr	r1, [sp, #96]	; 0x60
 80216a0:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80216a2:	1a5a      	subs	r2, r3, r1
 80216a4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80216a6:	1a1b      	subs	r3, r3, r0
 80216a8:	011b      	lsls	r3, r3, #4
 80216aa:	3308      	adds	r3, #8
 80216ac:	9312      	str	r3, [sp, #72]	; 0x48
 80216ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80216b0:	9319      	str	r3, [sp, #100]	; 0x64
 80216b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80216b4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 80216b8:	9309      	str	r3, [sp, #36]	; 0x24
 80216ba:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80216bc:	0112      	lsls	r2, r2, #4
 80216be:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 80216c2:	3208      	adds	r2, #8
 80216c4:	9308      	str	r3, [sp, #32]
 80216c6:	2300      	movs	r3, #0
 80216c8:	920f      	str	r2, [sp, #60]	; 0x3c
 80216ca:	930c      	str	r3, [sp, #48]	; 0x30
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80216cc:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80216ce:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80216d2:	ec51 0b1f 	vmov	r0, r1, d15
 80216d6:	4632      	mov	r2, r6
 80216d8:	463b      	mov	r3, r7
 80216da:	f007 fa45 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80216de:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80216e2:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80216e6:	4642      	mov	r2, r8
 80216e8:	464b      	mov	r3, r9
 80216ea:	4604      	mov	r4, r0
 80216ec:	460d      	mov	r5, r1
 80216ee:	4650      	mov	r0, sl
 80216f0:	4659      	mov	r1, fp
 80216f2:	f007 fa39 	bl	8028b68 <__aeabi_dmul>
 80216f6:	4602      	mov	r2, r0
 80216f8:	460b      	mov	r3, r1
 80216fa:	4620      	mov	r0, r4
 80216fc:	4629      	mov	r1, r5
 80216fe:	f007 f87b 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021702:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021704:	4604      	mov	r4, r0
 8021706:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021708:	464b      	mov	r3, r9
 802170a:	ec51 0b1f 	vmov	r0, r1, d15
 802170e:	f007 fa2b 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021712:	ec45 4b18 	vmov	d8, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021716:	4632      	mov	r2, r6
 8021718:	463b      	mov	r3, r7
 802171a:	4604      	mov	r4, r0
 802171c:	460d      	mov	r5, r1
 802171e:	4650      	mov	r0, sl
 8021720:	4659      	mov	r1, fp
 8021722:	f007 fa21 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021726:	eeb0 ba48 	vmov.f32	s22, s16
 802172a:	eef0 ba68 	vmov.f32	s23, s17
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802172e:	4602      	mov	r2, r0
 8021730:	460b      	mov	r3, r1
 8021732:	4620      	mov	r0, r4
 8021734:	4629      	mov	r1, r5
 8021736:	f007 f861 	bl	80287fc <__adddf3>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 802173a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 802173c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 802173e:	e953 6702 	ldrd	r6, r7, [r3, #-8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021742:	4682      	mov	sl, r0
 8021744:	468b      	mov	fp, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8021746:	4632      	mov	r2, r6
 8021748:	463b      	mov	r3, r7
 802174a:	ec51 0b18 	vmov	r0, r1, d8
 802174e:	f007 fa0b 	bl	8028b68 <__aeabi_dmul>
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8021752:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8021756:	4604      	mov	r4, r0
 8021758:	460d      	mov	r5, r1
 802175a:	4642      	mov	r2, r8
 802175c:	464b      	mov	r3, r9
 802175e:	4650      	mov	r0, sl
 8021760:	4659      	mov	r1, fp
 8021762:	f007 fa01 	bl	8028b68 <__aeabi_dmul>
 8021766:	4602      	mov	r2, r0
 8021768:	460b      	mov	r3, r1
 802176a:	4620      	mov	r0, r4
 802176c:	4629      	mov	r1, r5
 802176e:	f007 f843 	bl	80287f8 <__aeabi_dsub>
 8021772:	9c08      	ldr	r4, [sp, #32]
 8021774:	4602      	mov	r2, r0
 8021776:	460b      	mov	r3, r1
 8021778:	e9d4 0100 	ldrd	r0, r1, [r4]
 802177c:	f007 f83e 	bl	80287fc <__adddf3>
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8021780:	4642      	mov	r2, r8
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8021782:	e9c4 0100 	strd	r0, r1, [r4]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8021786:	464b      	mov	r3, r9
 8021788:	ec51 0b18 	vmov	r0, r1, d8
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 802178c:	9408      	str	r4, [sp, #32]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 802178e:	f007 f9eb 	bl	8028b68 <__aeabi_dmul>
 8021792:	4632      	mov	r2, r6
 8021794:	4604      	mov	r4, r0
 8021796:	463b      	mov	r3, r7
 8021798:	460d      	mov	r5, r1
 802179a:	4650      	mov	r0, sl
 802179c:	4659      	mov	r1, fp
 802179e:	f007 f9e3 	bl	8028b68 <__aeabi_dmul>
 80217a2:	4602      	mov	r2, r0
 80217a4:	460b      	mov	r3, r1
 80217a6:	4620      	mov	r0, r4
 80217a8:	4629      	mov	r1, r5
 80217aa:	f007 f827 	bl	80287fc <__adddf3>
 80217ae:	9c08      	ldr	r4, [sp, #32]
 80217b0:	4602      	mov	r2, r0
 80217b2:	460b      	mov	r3, r1
 80217b4:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 80217b8:	f007 f820 	bl	80287fc <__adddf3>
          BASE temp2_imag = 0.0;
 80217bc:	ed9f 7b8a 	vldr	d7, [pc, #552]	; 80219e8 <cblas_zsymm+0xdb8>
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 80217c0:	e9c4 0102 	strd	r0, r1, [r4, #8]
          BASE temp2_imag = 0.0;
 80217c4:	eeb0 da47 	vmov.f32	s26, s14
 80217c8:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 80217cc:	eeb0 ca47 	vmov.f32	s24, s14
 80217d0:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 80217d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80217d6:	990d      	ldr	r1, [sp, #52]	; 0x34
 80217d8:	428a      	cmp	r2, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80217da:	ec4b ab1a 	vmov	d10, sl, fp
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 80217de:	4623      	mov	r3, r4
          for (k = i + 1; k < n1; k++) {
 80217e0:	f340 8090 	ble.w	8021904 <cblas_zsymm+0xcd4>
 80217e4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80217e6:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80217e8:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 80217ec:	4422      	add	r2, r4
 80217ee:	9201      	str	r2, [sp, #4]
 80217f0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80217f2:	eb02 0a03 	add.w	sl, r2, r3
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80217f6:	e9db 4504 	ldrd	r4, r5, [fp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 80217fa:	ec51 0b1b 	vmov	r0, r1, d11
 80217fe:	4622      	mov	r2, r4
 8021800:	462b      	mov	r3, r5
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8021802:	e9db 8906 	ldrd	r8, r9, [fp, #24]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8021806:	f007 f9af 	bl	8028b68 <__aeabi_dmul>
 802180a:	4642      	mov	r2, r8
 802180c:	4606      	mov	r6, r0
 802180e:	460f      	mov	r7, r1
 8021810:	464b      	mov	r3, r9
 8021812:	ec51 0b1a 	vmov	r0, r1, d10
 8021816:	f007 f9a7 	bl	8028b68 <__aeabi_dmul>
 802181a:	4602      	mov	r2, r0
 802181c:	460b      	mov	r3, r1
 802181e:	4630      	mov	r0, r6
 8021820:	4639      	mov	r1, r7
 8021822:	f006 ffe9 	bl	80287f8 <__aeabi_dsub>
 8021826:	4602      	mov	r2, r0
 8021828:	460b      	mov	r3, r1
 802182a:	e95a 0102 	ldrd	r0, r1, [sl, #-8]
 802182e:	f006 ffe5 	bl	80287fc <__adddf3>
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8021832:	9b01      	ldr	r3, [sp, #4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8021834:	4622      	mov	r2, r4
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8021836:	ed13 8b02 	vldr	d8, [r3, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 802183a:	ed93 9b00 	vldr	d9, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 802183e:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8021842:	462b      	mov	r3, r5
 8021844:	ec51 0b1a 	vmov	r0, r1, d10
 8021848:	f007 f98e 	bl	8028b68 <__aeabi_dmul>
 802184c:	4642      	mov	r2, r8
 802184e:	4606      	mov	r6, r0
 8021850:	460f      	mov	r7, r1
 8021852:	464b      	mov	r3, r9
 8021854:	ec51 0b1b 	vmov	r0, r1, d11
 8021858:	f007 f986 	bl	8028b68 <__aeabi_dmul>
 802185c:	4602      	mov	r2, r0
 802185e:	460b      	mov	r3, r1
 8021860:	4630      	mov	r0, r6
 8021862:	4639      	mov	r1, r7
 8021864:	f006 ffca 	bl	80287fc <__adddf3>
 8021868:	4602      	mov	r2, r0
 802186a:	460b      	mov	r3, r1
 802186c:	e9da 0100 	ldrd	r0, r1, [sl]
 8021870:	f006 ffc4 	bl	80287fc <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8021874:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8021878:	e9ca 0100 	strd	r0, r1, [sl]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 802187c:	4620      	mov	r0, r4
 802187e:	4629      	mov	r1, r5
 8021880:	f007 f972 	bl	8028b68 <__aeabi_dmul>
 8021884:	ec53 2b19 	vmov	r2, r3, d9
 8021888:	4606      	mov	r6, r0
 802188a:	460f      	mov	r7, r1
 802188c:	4640      	mov	r0, r8
 802188e:	4649      	mov	r1, r9
 8021890:	f007 f96a 	bl	8028b68 <__aeabi_dmul>
 8021894:	4602      	mov	r2, r0
 8021896:	460b      	mov	r3, r1
 8021898:	4630      	mov	r0, r6
 802189a:	4639      	mov	r1, r7
 802189c:	f006 ffac 	bl	80287f8 <__aeabi_dsub>
 80218a0:	4602      	mov	r2, r0
 80218a2:	460b      	mov	r3, r1
 80218a4:	ec51 0b1c 	vmov	r0, r1, d12
 80218a8:	f006 ffa8 	bl	80287fc <__adddf3>
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80218ac:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80218b0:	4606      	mov	r6, r0
 80218b2:	460f      	mov	r7, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80218b4:	4620      	mov	r0, r4
 80218b6:	4629      	mov	r1, r5
 80218b8:	f007 f956 	bl	8028b68 <__aeabi_dmul>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80218bc:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80218c0:	ec53 2b18 	vmov	r2, r3, d8
 80218c4:	4606      	mov	r6, r0
 80218c6:	460f      	mov	r7, r1
 80218c8:	4640      	mov	r0, r8
 80218ca:	4649      	mov	r1, r9
 80218cc:	f007 f94c 	bl	8028b68 <__aeabi_dmul>
 80218d0:	4602      	mov	r2, r0
 80218d2:	460b      	mov	r3, r1
 80218d4:	4630      	mov	r0, r6
 80218d6:	4639      	mov	r1, r7
 80218d8:	f006 ff90 	bl	80287fc <__adddf3>
 80218dc:	4602      	mov	r2, r0
 80218de:	460b      	mov	r3, r1
 80218e0:	ec51 0b1d 	vmov	r0, r1, d13
 80218e4:	f006 ff8a 	bl	80287fc <__adddf3>
 80218e8:	9b01      	ldr	r3, [sp, #4]
 80218ea:	9a06      	ldr	r2, [sp, #24]
 80218ec:	4413      	add	r3, r2
 80218ee:	9301      	str	r3, [sp, #4]
 80218f0:	9b03      	ldr	r3, [sp, #12]
 80218f2:	449a      	add	sl, r3
          for (k = i + 1; k < n1; k++) {
 80218f4:	9b02      	ldr	r3, [sp, #8]
 80218f6:	f10b 0b10 	add.w	fp, fp, #16
 80218fa:	455b      	cmp	r3, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80218fc:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = i + 1; k < n1; k++) {
 8021900:	f47f af79 	bne.w	80217f6 <cblas_zsymm+0xbc6>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021904:	ec53 2b1c 	vmov	r2, r3, d12
 8021908:	ec51 0b1f 	vmov	r0, r1, d15
 802190c:	f007 f92c 	bl	8028b68 <__aeabi_dmul>
 8021910:	e9dd 7804 	ldrd	r7, r8, [sp, #16]
 8021914:	ec5a 9b1d 	vmov	r9, sl, d13
 8021918:	4604      	mov	r4, r0
 802191a:	460d      	mov	r5, r1
 802191c:	ee1d 2a10 	vmov	r2, s26
 8021920:	4653      	mov	r3, sl
 8021922:	4638      	mov	r0, r7
 8021924:	4641      	mov	r1, r8
 8021926:	f007 f91f 	bl	8028b68 <__aeabi_dmul>
 802192a:	4602      	mov	r2, r0
 802192c:	460b      	mov	r3, r1
 802192e:	4620      	mov	r0, r4
 8021930:	4629      	mov	r1, r5
 8021932:	f006 ff61 	bl	80287f8 <__aeabi_dsub>
 8021936:	9e08      	ldr	r6, [sp, #32]
 8021938:	4602      	mov	r2, r0
 802193a:	460b      	mov	r3, r1
 802193c:	e9d6 0100 	ldrd	r0, r1, [r6]
 8021940:	f006 ff5c 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021944:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021948:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802194c:	4653      	mov	r3, sl
 802194e:	ec51 0b1f 	vmov	r0, r1, d15
 8021952:	f007 f909 	bl	8028b68 <__aeabi_dmul>
 8021956:	ec53 2b1c 	vmov	r2, r3, d12
 802195a:	4604      	mov	r4, r0
 802195c:	460d      	mov	r5, r1
 802195e:	4638      	mov	r0, r7
 8021960:	4641      	mov	r1, r8
 8021962:	f007 f901 	bl	8028b68 <__aeabi_dmul>
 8021966:	4602      	mov	r2, r0
 8021968:	460b      	mov	r3, r1
 802196a:	4620      	mov	r0, r4
 802196c:	4629      	mov	r1, r5
 802196e:	f006 ff45 	bl	80287fc <__adddf3>
 8021972:	4602      	mov	r2, r0
 8021974:	460b      	mov	r3, r1
 8021976:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 802197a:	f006 ff3f 	bl	80287fc <__adddf3>
 802197e:	9b09      	ldr	r3, [sp, #36]	; 0x24
        for (j = 0; j < n2; j++) {
 8021980:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8021982:	3310      	adds	r3, #16
 8021984:	9309      	str	r3, [sp, #36]	; 0x24
 8021986:	f106 0310 	add.w	r3, r6, #16
 802198a:	9308      	str	r3, [sp, #32]
 802198c:	9b07      	ldr	r3, [sp, #28]
 802198e:	3201      	adds	r2, #1
 8021990:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021992:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8021996:	920c      	str	r2, [sp, #48]	; 0x30
 8021998:	f47f ae98 	bne.w	80216cc <cblas_zsymm+0xa9c>
      for (i = 0; i < n1; i++) {
 802199c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802199e:	9a18      	ldr	r2, [sp, #96]	; 0x60
 80219a0:	3301      	adds	r3, #1
 80219a2:	930d      	str	r3, [sp, #52]	; 0x34
 80219a4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80219a6:	4611      	mov	r1, r2
 80219a8:	4419      	add	r1, r3
 80219aa:	9118      	str	r1, [sp, #96]	; 0x60
 80219ac:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80219ae:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80219b0:	4608      	mov	r0, r1
 80219b2:	4410      	add	r0, r2
 80219b4:	900b      	str	r0, [sp, #44]	; 0x2c
 80219b6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80219b8:	9913      	ldr	r1, [sp, #76]	; 0x4c
 80219ba:	4604      	mov	r4, r0
 80219bc:	440c      	add	r4, r1
 80219be:	9802      	ldr	r0, [sp, #8]
 80219c0:	9417      	str	r4, [sp, #92]	; 0x5c
 80219c2:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 80219c4:	4420      	add	r0, r4
 80219c6:	9002      	str	r0, [sp, #8]
 80219c8:	9816      	ldr	r0, [sp, #88]	; 0x58
 80219ca:	4418      	add	r0, r3
 80219cc:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80219ce:	9016      	str	r0, [sp, #88]	; 0x58
 80219d0:	440b      	add	r3, r1
 80219d2:	9315      	str	r3, [sp, #84]	; 0x54
 80219d4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80219d6:	4413      	add	r3, r2
 80219d8:	930e      	str	r3, [sp, #56]	; 0x38
 80219da:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80219dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80219de:	4293      	cmp	r3, r2
 80219e0:	f73f ae58 	bgt.w	8021694 <cblas_zsymm+0xa64>
 80219e4:	f7ff b9f7 	b.w	8020dd6 <cblas_zsymm+0x1a6>
	...
      for (i = 0; i < n1; i++) {
 80219f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80219f2:	2b00      	cmp	r3, #0
 80219f4:	f77f a9ef 	ble.w	8020dd6 <cblas_zsymm+0x1a6>
 80219f8:	980e      	ldr	r0, [sp, #56]	; 0x38
 80219fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80219fc:	1c42      	adds	r2, r0, #1
 80219fe:	0112      	lsls	r2, r2, #4
 8021a00:	920c      	str	r2, [sp, #48]	; 0x30
 8021a02:	0102      	lsls	r2, r0, #4
 8021a04:	920b      	str	r2, [sp, #44]	; 0x2c
 8021a06:	9a07      	ldr	r2, [sp, #28]
 8021a08:	3b10      	subs	r3, #16
 8021a0a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021a0e:	9317      	str	r3, [sp, #92]	; 0x5c
 8021a10:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8021a12:	011b      	lsls	r3, r3, #4
 8021a14:	9316      	str	r3, [sp, #88]	; 0x58
 8021a16:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8021a18:	2100      	movs	r1, #0
 8021a1a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021a1e:	910e      	str	r1, [sp, #56]	; 0x38
 8021a20:	9112      	str	r1, [sp, #72]	; 0x48
 8021a22:	9115      	str	r1, [sp, #84]	; 0x54
 8021a24:	930d      	str	r3, [sp, #52]	; 0x34
        for (j = 0; j < n2; j++) {
 8021a26:	9b07      	ldr	r3, [sp, #28]
 8021a28:	2b00      	cmp	r3, #0
 8021a2a:	f340 81c7 	ble.w	8021dbc <cblas_zsymm+0x118c>
 8021a2e:	e9dd 3211 	ldrd	r3, r2, [sp, #68]	; 0x44
 8021a32:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021a36:	9308      	str	r3, [sp, #32]
 8021a38:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8021a3a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8021a3c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021a40:	9303      	str	r3, [sp, #12]
 8021a42:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8021a44:	9302      	str	r3, [sp, #8]
 8021a46:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021a48:	9306      	str	r3, [sp, #24]
 8021a4a:	2300      	movs	r3, #0
 8021a4c:	9309      	str	r3, [sp, #36]	; 0x24
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8021a4e:	9c08      	ldr	r4, [sp, #32]
 8021a50:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021a54:	ec51 0b1f 	vmov	r0, r1, d15
 8021a58:	4632      	mov	r2, r6
 8021a5a:	463b      	mov	r3, r7
 8021a5c:	f007 f884 	bl	8028b68 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8021a60:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021a64:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8021a68:	4642      	mov	r2, r8
 8021a6a:	464b      	mov	r3, r9
 8021a6c:	4604      	mov	r4, r0
 8021a6e:	460d      	mov	r5, r1
 8021a70:	4650      	mov	r0, sl
 8021a72:	4659      	mov	r1, fp
 8021a74:	f007 f878 	bl	8028b68 <__aeabi_dmul>
 8021a78:	4602      	mov	r2, r0
 8021a7a:	460b      	mov	r3, r1
 8021a7c:	4620      	mov	r0, r4
 8021a7e:	4629      	mov	r1, r5
 8021a80:	f006 feba 	bl	80287f8 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021a84:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021a86:	4604      	mov	r4, r0
 8021a88:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021a8a:	464b      	mov	r3, r9
 8021a8c:	ec51 0b1f 	vmov	r0, r1, d15
 8021a90:	f007 f86a 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021a94:	ec45 4b19 	vmov	d9, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021a98:	4632      	mov	r2, r6
 8021a9a:	463b      	mov	r3, r7
 8021a9c:	4604      	mov	r4, r0
 8021a9e:	460d      	mov	r5, r1
 8021aa0:	4650      	mov	r0, sl
 8021aa2:	4659      	mov	r1, fp
 8021aa4:	f007 f860 	bl	8028b68 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8021aa8:	eeb0 ba49 	vmov.f32	s22, s18
 8021aac:	eef0 ba69 	vmov.f32	s23, s19
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021ab0:	4602      	mov	r2, r0
 8021ab2:	460b      	mov	r3, r1
 8021ab4:	4620      	mov	r0, r4
 8021ab6:	4629      	mov	r1, r5
 8021ab8:	f006 fea0 	bl	80287fc <__adddf3>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8021abc:	9c06      	ldr	r4, [sp, #24]
 8021abe:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021ac2:	468c      	mov	ip, r1
 8021ac4:	4683      	mov	fp, r0
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8021ac6:	4632      	mov	r2, r6
 8021ac8:	463b      	mov	r3, r7
 8021aca:	ec51 0b19 	vmov	r0, r1, d9
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021ace:	ec4c bb18 	vmov	d8, fp, ip
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8021ad2:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8021ad6:	eeb0 aa48 	vmov.f32	s20, s16
 8021ada:	eef0 aa68 	vmov.f32	s21, s17
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8021ade:	f007 f843 	bl	8028b68 <__aeabi_dmul>
 8021ae2:	4642      	mov	r2, r8
 8021ae4:	4604      	mov	r4, r0
 8021ae6:	460d      	mov	r5, r1
 8021ae8:	464b      	mov	r3, r9
 8021aea:	ec51 0b18 	vmov	r0, r1, d8
 8021aee:	f007 f83b 	bl	8028b68 <__aeabi_dmul>
 8021af2:	4602      	mov	r2, r0
 8021af4:	460b      	mov	r3, r1
 8021af6:	4620      	mov	r0, r4
 8021af8:	4629      	mov	r1, r5
 8021afa:	f006 fe7d 	bl	80287f8 <__aeabi_dsub>
 8021afe:	9c03      	ldr	r4, [sp, #12]
 8021b00:	4602      	mov	r2, r0
 8021b02:	460b      	mov	r3, r1
 8021b04:	e9d4 0100 	ldrd	r0, r1, [r4]
 8021b08:	f006 fe78 	bl	80287fc <__adddf3>
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8021b0c:	4642      	mov	r2, r8
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8021b0e:	e9c4 0100 	strd	r0, r1, [r4]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8021b12:	464b      	mov	r3, r9
 8021b14:	ec51 0b19 	vmov	r0, r1, d9
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8021b18:	9403      	str	r4, [sp, #12]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8021b1a:	f007 f825 	bl	8028b68 <__aeabi_dmul>
 8021b1e:	4632      	mov	r2, r6
 8021b20:	4604      	mov	r4, r0
 8021b22:	460d      	mov	r5, r1
 8021b24:	463b      	mov	r3, r7
 8021b26:	ec51 0b18 	vmov	r0, r1, d8
 8021b2a:	f007 f81d 	bl	8028b68 <__aeabi_dmul>
 8021b2e:	4602      	mov	r2, r0
 8021b30:	460b      	mov	r3, r1
 8021b32:	4620      	mov	r0, r4
 8021b34:	4629      	mov	r1, r5
 8021b36:	f006 fe61 	bl	80287fc <__adddf3>
 8021b3a:	9c03      	ldr	r4, [sp, #12]
 8021b3c:	4602      	mov	r2, r0
 8021b3e:	460b      	mov	r3, r1
 8021b40:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8021b44:	f006 fe5a 	bl	80287fc <__adddf3>
          for (k = j + 1; k < n2; k++) {
 8021b48:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8021b4a:	9a07      	ldr	r2, [sp, #28]
 8021b4c:	3501      	adds	r5, #1
 8021b4e:	42aa      	cmp	r2, r5
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8021b50:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (k = j + 1; k < n2; k++) {
 8021b54:	9509      	str	r5, [sp, #36]	; 0x24
 8021b56:	f000 8101 	beq.w	8021d5c <cblas_zsymm+0x112c>
          BASE temp2_imag = 0.0;
 8021b5a:	ed1f 7b5d 	vldr	d7, [pc, #-372]	; 80219e8 <cblas_zsymm+0xdb8>
          for (k = j + 1; k < n2; k++) {
 8021b5e:	9d08      	ldr	r5, [sp, #32]
 8021b60:	f8dd a018 	ldr.w	sl, [sp, #24]
 8021b64:	9501      	str	r5, [sp, #4]
 8021b66:	46a3      	mov	fp, r4
          BASE temp2_imag = 0.0;
 8021b68:	eeb0 da47 	vmov.f32	s26, s14
 8021b6c:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 8021b70:	eeb0 ca47 	vmov.f32	s24, s14
 8021b74:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8021b78:	e9da 8904 	ldrd	r8, r9, [sl, #16]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8021b7c:	ec51 0b1b 	vmov	r0, r1, d11
 8021b80:	4642      	mov	r2, r8
 8021b82:	464b      	mov	r3, r9
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8021b84:	e9da 4506 	ldrd	r4, r5, [sl, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8021b88:	f006 ffee 	bl	8028b68 <__aeabi_dmul>
 8021b8c:	4622      	mov	r2, r4
 8021b8e:	4606      	mov	r6, r0
 8021b90:	460f      	mov	r7, r1
 8021b92:	462b      	mov	r3, r5
 8021b94:	ec51 0b1a 	vmov	r0, r1, d10
 8021b98:	f006 ffe6 	bl	8028b68 <__aeabi_dmul>
 8021b9c:	4602      	mov	r2, r0
 8021b9e:	460b      	mov	r3, r1
 8021ba0:	4630      	mov	r0, r6
 8021ba2:	4639      	mov	r1, r7
 8021ba4:	f006 fe28 	bl	80287f8 <__aeabi_dsub>
 8021ba8:	4602      	mov	r2, r0
 8021baa:	460b      	mov	r3, r1
 8021bac:	e9db 0104 	ldrd	r0, r1, [fp, #16]
 8021bb0:	f006 fe24 	bl	80287fc <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8021bb4:	9b01      	ldr	r3, [sp, #4]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8021bb6:	4622      	mov	r2, r4
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8021bb8:	ed93 8b04 	vldr	d8, [r3, #16]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 8021bbc:	ed93 9b06 	vldr	d9, [r3, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8021bc0:	e9cb 0104 	strd	r0, r1, [fp, #16]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8021bc4:	462b      	mov	r3, r5
 8021bc6:	ec51 0b1b 	vmov	r0, r1, d11
 8021bca:	f006 ffcd 	bl	8028b68 <__aeabi_dmul>
 8021bce:	4642      	mov	r2, r8
 8021bd0:	4606      	mov	r6, r0
 8021bd2:	460f      	mov	r7, r1
 8021bd4:	464b      	mov	r3, r9
 8021bd6:	ec51 0b1a 	vmov	r0, r1, d10
 8021bda:	f006 ffc5 	bl	8028b68 <__aeabi_dmul>
 8021bde:	4602      	mov	r2, r0
 8021be0:	460b      	mov	r3, r1
 8021be2:	4630      	mov	r0, r6
 8021be4:	4639      	mov	r1, r7
 8021be6:	f006 fe09 	bl	80287fc <__adddf3>
 8021bea:	4602      	mov	r2, r0
 8021bec:	460b      	mov	r3, r1
 8021bee:	e9db 0106 	ldrd	r0, r1, [fp, #24]
 8021bf2:	f006 fe03 	bl	80287fc <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021bf6:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8021bfa:	e9cb 0106 	strd	r0, r1, [fp, #24]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021bfe:	4640      	mov	r0, r8
 8021c00:	4649      	mov	r1, r9
 8021c02:	f006 ffb1 	bl	8028b68 <__aeabi_dmul>
 8021c06:	ec53 2b19 	vmov	r2, r3, d9
 8021c0a:	4606      	mov	r6, r0
 8021c0c:	460f      	mov	r7, r1
 8021c0e:	4620      	mov	r0, r4
 8021c10:	4629      	mov	r1, r5
 8021c12:	f006 ffa9 	bl	8028b68 <__aeabi_dmul>
 8021c16:	4602      	mov	r2, r0
 8021c18:	460b      	mov	r3, r1
 8021c1a:	4630      	mov	r0, r6
 8021c1c:	4639      	mov	r1, r7
 8021c1e:	f006 fdeb 	bl	80287f8 <__aeabi_dsub>
 8021c22:	4602      	mov	r2, r0
 8021c24:	460b      	mov	r3, r1
 8021c26:	ec51 0b1c 	vmov	r0, r1, d12
 8021c2a:	f006 fde7 	bl	80287fc <__adddf3>
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8021c2e:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021c32:	4606      	mov	r6, r0
 8021c34:	460f      	mov	r7, r1
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8021c36:	4620      	mov	r0, r4
 8021c38:	4629      	mov	r1, r5
 8021c3a:	f006 ff95 	bl	8028b68 <__aeabi_dmul>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8021c3e:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8021c42:	ec53 2b19 	vmov	r2, r3, d9
 8021c46:	4606      	mov	r6, r0
 8021c48:	460f      	mov	r7, r1
 8021c4a:	4640      	mov	r0, r8
 8021c4c:	4649      	mov	r1, r9
 8021c4e:	f006 ff8b 	bl	8028b68 <__aeabi_dmul>
 8021c52:	4602      	mov	r2, r0
 8021c54:	460b      	mov	r3, r1
 8021c56:	4630      	mov	r0, r6
 8021c58:	4639      	mov	r1, r7
 8021c5a:	f006 fdcf 	bl	80287fc <__adddf3>
 8021c5e:	460b      	mov	r3, r1
 8021c60:	4602      	mov	r2, r0
 8021c62:	ec51 0b1d 	vmov	r0, r1, d13
 8021c66:	f006 fdc9 	bl	80287fc <__adddf3>
 8021c6a:	9b01      	ldr	r3, [sp, #4]
 8021c6c:	3310      	adds	r3, #16
 8021c6e:	9301      	str	r3, [sp, #4]
          for (k = j + 1; k < n2; k++) {
 8021c70:	9b02      	ldr	r3, [sp, #8]
 8021c72:	f10a 0a10 	add.w	sl, sl, #16
 8021c76:	4553      	cmp	r3, sl
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8021c78:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = j + 1; k < n2; k++) {
 8021c7c:	f10b 0b10 	add.w	fp, fp, #16
 8021c80:	f47f af7a 	bne.w	8021b78 <cblas_zsymm+0xf48>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021c84:	ec53 2b1c 	vmov	r2, r3, d12
 8021c88:	ec51 0b1f 	vmov	r0, r1, d15
 8021c8c:	f006 ff6c 	bl	8028b68 <__aeabi_dmul>
 8021c90:	e9dd 7804 	ldrd	r7, r8, [sp, #16]
 8021c94:	ec5a 9b1d 	vmov	r9, sl, d13
 8021c98:	4604      	mov	r4, r0
 8021c9a:	460d      	mov	r5, r1
 8021c9c:	ee1d 2a10 	vmov	r2, s26
 8021ca0:	4653      	mov	r3, sl
 8021ca2:	4638      	mov	r0, r7
 8021ca4:	4641      	mov	r1, r8
 8021ca6:	f006 ff5f 	bl	8028b68 <__aeabi_dmul>
 8021caa:	4602      	mov	r2, r0
 8021cac:	460b      	mov	r3, r1
 8021cae:	4620      	mov	r0, r4
 8021cb0:	4629      	mov	r1, r5
 8021cb2:	f006 fda1 	bl	80287f8 <__aeabi_dsub>
 8021cb6:	9e03      	ldr	r6, [sp, #12]
 8021cb8:	4602      	mov	r2, r0
 8021cba:	460b      	mov	r3, r1
 8021cbc:	e9d6 0100 	ldrd	r0, r1, [r6]
 8021cc0:	f006 fd9c 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021cc4:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021cc8:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021ccc:	4653      	mov	r3, sl
 8021cce:	ec51 0b1f 	vmov	r0, r1, d15
 8021cd2:	f006 ff49 	bl	8028b68 <__aeabi_dmul>
 8021cd6:	ec53 2b1c 	vmov	r2, r3, d12
 8021cda:	4604      	mov	r4, r0
 8021cdc:	460d      	mov	r5, r1
 8021cde:	4638      	mov	r0, r7
 8021ce0:	4641      	mov	r1, r8
 8021ce2:	f006 ff41 	bl	8028b68 <__aeabi_dmul>
 8021ce6:	4602      	mov	r2, r0
 8021ce8:	460b      	mov	r3, r1
 8021cea:	4620      	mov	r0, r4
 8021cec:	4629      	mov	r1, r5
 8021cee:	f006 fd85 	bl	80287fc <__adddf3>
 8021cf2:	4602      	mov	r2, r0
 8021cf4:	460b      	mov	r3, r1
 8021cf6:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8021cfa:	f006 fd7f 	bl	80287fc <__adddf3>
 8021cfe:	9b08      	ldr	r3, [sp, #32]
 8021d00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8021d02:	3310      	adds	r3, #16
 8021d04:	9308      	str	r3, [sp, #32]
 8021d06:	9b06      	ldr	r3, [sp, #24]
 8021d08:	4413      	add	r3, r2
 8021d0a:	9306      	str	r3, [sp, #24]
 8021d0c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021d0e:	9b02      	ldr	r3, [sp, #8]
 8021d10:	4413      	add	r3, r2
 8021d12:	9302      	str	r3, [sp, #8]
 8021d14:	f106 0310 	add.w	r3, r6, #16
 8021d18:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8021d1c:	9303      	str	r3, [sp, #12]
 8021d1e:	e696      	b.n	8021a4e <cblas_zsymm+0xe1e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8021d20:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8021d22:	2b00      	cmp	r3, #0
 8021d24:	dc78      	bgt.n	8021e18 <cblas_zsymm+0x11e8>
 8021d26:	2301      	movs	r3, #1
 8021d28:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021d2a:	429a      	cmp	r2, r3
 8021d2c:	bfb4      	ite	lt
 8021d2e:	200d      	movlt	r0, #13
 8021d30:	200a      	movge	r0, #10
 8021d32:	f7fe bfb9 	b.w	8020ca8 <cblas_zsymm+0x78>
 8021d36:	9b07      	ldr	r3, [sp, #28]
 8021d38:	e47d      	b.n	8021636 <cblas_zsymm+0xa06>
      for (i = 0; i < n1; i++) {
 8021d3a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021d3c:	9915      	ldr	r1, [sp, #84]	; 0x54
 8021d3e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8021d40:	440a      	add	r2, r1
 8021d42:	9210      	str	r2, [sp, #64]	; 0x40
 8021d44:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8021d46:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8021d48:	440a      	add	r2, r1
 8021d4a:	920d      	str	r2, [sp, #52]	; 0x34
 8021d4c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021d4e:	3301      	adds	r3, #1
 8021d50:	429a      	cmp	r2, r3
 8021d52:	9312      	str	r3, [sp, #72]	; 0x48
 8021d54:	f47f aaa6 	bne.w	80212a4 <cblas_zsymm+0x674>
 8021d58:	f7ff b83d 	b.w	8020dd6 <cblas_zsymm+0x1a6>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021d5c:	2200      	movs	r2, #0
 8021d5e:	2300      	movs	r3, #0
 8021d60:	ec51 0b1f 	vmov	r0, r1, d15
 8021d64:	f006 ff00 	bl	8028b68 <__aeabi_dmul>
 8021d68:	2200      	movs	r2, #0
 8021d6a:	4606      	mov	r6, r0
 8021d6c:	460f      	mov	r7, r1
 8021d6e:	2300      	movs	r3, #0
 8021d70:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8021d74:	f006 fef8 	bl	8028b68 <__aeabi_dmul>
 8021d78:	4604      	mov	r4, r0
 8021d7a:	460d      	mov	r5, r1
 8021d7c:	4622      	mov	r2, r4
 8021d7e:	462b      	mov	r3, r5
 8021d80:	4630      	mov	r0, r6
 8021d82:	4639      	mov	r1, r7
 8021d84:	f006 fd38 	bl	80287f8 <__aeabi_dsub>
 8021d88:	460b      	mov	r3, r1
 8021d8a:	990d      	ldr	r1, [sp, #52]	; 0x34
 8021d8c:	4602      	mov	r2, r0
 8021d8e:	e951 0104 	ldrd	r0, r1, [r1, #-16]
 8021d92:	f006 fd33 	bl	80287fc <__adddf3>
 8021d96:	4680      	mov	r8, r0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021d98:	4620      	mov	r0, r4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021d9a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8021d9c:	4689      	mov	r9, r1
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021d9e:	4632      	mov	r2, r6
 8021da0:	463b      	mov	r3, r7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021da2:	e944 8904 	strd	r8, r9, [r4, #-16]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021da6:	4629      	mov	r1, r5
 8021da8:	f006 fd28 	bl	80287fc <__adddf3>
 8021dac:	4602      	mov	r2, r0
 8021dae:	460b      	mov	r3, r1
 8021db0:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8021db4:	f006 fd22 	bl	80287fc <__adddf3>
 8021db8:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (i = 0; i < n1; i++) {
 8021dbc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8021dbe:	9916      	ldr	r1, [sp, #88]	; 0x58
 8021dc0:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021dc2:	440a      	add	r2, r1
 8021dc4:	920d      	str	r2, [sp, #52]	; 0x34
 8021dc6:	9914      	ldr	r1, [sp, #80]	; 0x50
 8021dc8:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8021dca:	440a      	add	r2, r1
 8021dcc:	9212      	str	r2, [sp, #72]	; 0x48
 8021dce:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8021dd0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8021dd2:	440a      	add	r2, r1
 8021dd4:	920e      	str	r2, [sp, #56]	; 0x38
 8021dd6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021dd8:	3301      	adds	r3, #1
 8021dda:	429a      	cmp	r2, r3
 8021ddc:	9315      	str	r3, [sp, #84]	; 0x54
 8021dde:	f47f ae22 	bne.w	8021a26 <cblas_zsymm+0xdf6>
 8021de2:	f7fe bff8 	b.w	8020dd6 <cblas_zsymm+0x1a6>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8021de6:	9b07      	ldr	r3, [sp, #28]
 8021de8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8021dea:	2b01      	cmp	r3, #1
 8021dec:	bfb8      	it	lt
 8021dee:	2301      	movlt	r3, #1
 8021df0:	4293      	cmp	r3, r2
 8021df2:	dc99      	bgt.n	8021d28 <cblas_zsymm+0x10f8>
 8021df4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021df6:	4293      	cmp	r3, r2
 8021df8:	bfd4      	ite	le
 8021dfa:	2008      	movle	r0, #8
 8021dfc:	200d      	movgt	r0, #13
 8021dfe:	f7fe bf53 	b.w	8020ca8 <cblas_zsymm+0x78>
 8021e02:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021e04:	9319      	str	r3, [sp, #100]	; 0x64
 8021e06:	e5c9      	b.n	802199c <cblas_zsymm+0xd6c>
 8021e08:	3865      	subs	r0, #101	; 0x65
 8021e0a:	2801      	cmp	r0, #1
 8021e0c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021e0e:	bf94      	ite	ls
 8021e10:	2000      	movls	r0, #0
 8021e12:	2001      	movhi	r0, #1
 8021e14:	f7fe bf2d 	b.w	8020c72 <cblas_zsymm+0x42>
 8021e18:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8021e1a:	2b00      	cmp	r3, #0
 8021e1c:	bfcc      	ite	gt
 8021e1e:	2005      	movgt	r0, #5
 8021e20:	200d      	movle	r0, #13
 8021e22:	f7fe bf41 	b.w	8020ca8 <cblas_zsymm+0x78>
 8021e26:	9b07      	ldr	r3, [sp, #28]
 8021e28:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8021e2a:	2b01      	cmp	r3, #1
 8021e2c:	bfb8      	it	lt
 8021e2e:	2301      	movlt	r3, #1
 8021e30:	429a      	cmp	r2, r3
 8021e32:	f6ff af79 	blt.w	8021d28 <cblas_zsymm+0x10f8>
 8021e36:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021e38:	429a      	cmp	r2, r3
 8021e3a:	bfac      	ite	ge
 8021e3c:	2005      	movge	r0, #5
 8021e3e:	200d      	movlt	r0, #13
 8021e40:	f7fe bf32 	b.w	8020ca8 <cblas_zsymm+0x78>
 8021e44:	0000      	movs	r0, r0
	...

08021e48 <cblas_zsyr2k>:
void
cblas_zsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const void *beta, void *C, const int ldc)
{
 8021e48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021e4c:	ed2d 8b10 	vpush	{d8-d15}
 8021e50:	b09d      	sub	sp, #116	; 0x74
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8021e52:	2865      	cmp	r0, #101	; 0x65
 8021e54:	9304      	str	r3, [sp, #16]
 8021e56:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8021e58:	930c      	str	r3, [sp, #48]	; 0x30
 8021e5a:	e9dd 8337 	ldrd	r8, r3, [sp, #220]	; 0xdc
 8021e5e:	9311      	str	r3, [sp, #68]	; 0x44
 8021e60:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 8021e62:	930d      	str	r3, [sp, #52]	; 0x34
 8021e64:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 8021e66:	9312      	str	r3, [sp, #72]	; 0x48
 8021e68:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 8021e6a:	930e      	str	r3, [sp, #56]	; 0x38
 8021e6c:	e9dd 733c 	ldrd	r7, r3, [sp, #240]	; 0xf0
 8021e70:	9315      	str	r3, [sp, #84]	; 0x54
 8021e72:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 8021e74:	9316      	str	r3, [sp, #88]	; 0x58
 8021e76:	4605      	mov	r5, r0
 8021e78:	460e      	mov	r6, r1
 8021e7a:	4614      	mov	r4, r2
 8021e7c:	f000 815d 	beq.w	802213a <cblas_zsyr2k+0x2f2>
 8021e80:	2a6f      	cmp	r2, #111	; 0x6f
 8021e82:	f000 80b7 	beq.w	8021ff4 <cblas_zsyr2k+0x1ac>
 8021e86:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8021e88:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 8021e8c:	2a01      	cmp	r2, #1
 8021e8e:	f240 813f 	bls.w	8022110 <cblas_zsyr2k+0x2c8>
 8021e92:	2002      	movs	r0, #2
 8021e94:	f1a4 026f 	sub.w	r2, r4, #111	; 0x6f
 8021e98:	2a02      	cmp	r2, #2
 8021e9a:	bf88      	it	hi
 8021e9c:	2003      	movhi	r0, #3
 8021e9e:	9a04      	ldr	r2, [sp, #16]
 8021ea0:	990c      	ldr	r1, [sp, #48]	; 0x30
 8021ea2:	2a00      	cmp	r2, #0
 8021ea4:	bfb8      	it	lt
 8021ea6:	2004      	movlt	r0, #4
 8021ea8:	2900      	cmp	r1, #0
 8021eaa:	bfb8      	it	lt
 8021eac:	2005      	movlt	r0, #5
 8021eae:	990d      	ldr	r1, [sp, #52]	; 0x34
 8021eb0:	2b01      	cmp	r3, #1
 8021eb2:	bfb8      	it	lt
 8021eb4:	2301      	movlt	r3, #1
 8021eb6:	428b      	cmp	r3, r1
 8021eb8:	f340 811b 	ble.w	80220f2 <cblas_zsyr2k+0x2aa>
 8021ebc:	990e      	ldr	r1, [sp, #56]	; 0x38
 8021ebe:	428b      	cmp	r3, r1
 8021ec0:	f300 810d 	bgt.w	80220de <cblas_zsyr2k+0x296>
 8021ec4:	2a01      	cmp	r2, #1
 8021ec6:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021ec8:	bfb8      	it	lt
 8021eca:	2201      	movlt	r2, #1
 8021ecc:	429a      	cmp	r2, r3
 8021ece:	bfcc      	ite	gt
 8021ed0:	200e      	movgt	r0, #14
 8021ed2:	2008      	movle	r0, #8
 8021ed4:	4a9d      	ldr	r2, [pc, #628]	; (802214c <cblas_zsyr2k+0x304>)
 8021ed6:	499e      	ldr	r1, [pc, #632]	; (8022150 <cblas_zsyr2k+0x308>)
 8021ed8:	f006 fc16 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8021edc:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8021ee0:	2200      	movs	r2, #0
 8021ee2:	ec51 0b17 	vmov	r0, r1, d7
 8021ee6:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 8021ee8:	ed8d 7b06 	vstr	d7, [sp, #24]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8021eec:	f007 f8a4 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8021ef0:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8021ef4:	ed97 8b00 	vldr	d8, [r7]
    const BASE beta_imag = CONST_IMAG0(beta);
 8021ef8:	ed97 9b02 	vldr	d9, [r7, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8021efc:	eeb0 ba48 	vmov.f32	s22, s16
 8021f00:	eef0 ba68 	vmov.f32	s23, s17
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8021f04:	ed8d 7b08 	vstr	d7, [sp, #32]
    const BASE beta_imag = CONST_IMAG0(beta);
 8021f08:	eeb0 aa49 	vmov.f32	s20, s18
 8021f0c:	eef0 aa69 	vmov.f32	s21, s19
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8021f10:	b178      	cbz	r0, 8021f32 <cblas_zsyr2k+0xea>
 8021f12:	ec51 0b17 	vmov	r0, r1, d7
 8021f16:	2200      	movs	r2, #0
 8021f18:	2300      	movs	r3, #0
 8021f1a:	f007 f88d 	bl	8029038 <__aeabi_dcmpeq>
 8021f1e:	b140      	cbz	r0, 8021f32 <cblas_zsyr2k+0xea>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8021f20:	4b8c      	ldr	r3, [pc, #560]	; (8022154 <cblas_zsyr2k+0x30c>)
 8021f22:	ec51 0b18 	vmov	r0, r1, d8
 8021f26:	2200      	movs	r2, #0
 8021f28:	f007 f886 	bl	8029038 <__aeabi_dcmpeq>
 8021f2c:	2800      	cmp	r0, #0
 8021f2e:	f040 80f6 	bne.w	802211e <cblas_zsyr2k+0x2d6>
    if (Order == CblasRowMajor) {
 8021f32:	2d65      	cmp	r5, #101	; 0x65
 8021f34:	f000 8106 	beq.w	8022144 <cblas_zsyr2k+0x2fc>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8021f38:	2e79      	cmp	r6, #121	; 0x79
 8021f3a:	bf0c      	ite	eq
 8021f3c:	237a      	moveq	r3, #122	; 0x7a
 8021f3e:	2379      	movne	r3, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8021f40:	2c6f      	cmp	r4, #111	; 0x6f
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8021f42:	930f      	str	r3, [sp, #60]	; 0x3c
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8021f44:	bf0c      	ite	eq
 8021f46:	2370      	moveq	r3, #112	; 0x70
 8021f48:	236f      	movne	r3, #111	; 0x6f
 8021f4a:	9310      	str	r3, [sp, #64]	; 0x40
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8021f4c:	2200      	movs	r2, #0
 8021f4e:	ec51 0b1b 	vmov	r0, r1, d11
 8021f52:	2300      	movs	r3, #0
 8021f54:	f007 f870 	bl	8029038 <__aeabi_dcmpeq>
 8021f58:	2200      	movs	r2, #0
 8021f5a:	2800      	cmp	r0, #0
 8021f5c:	d052      	beq.n	8022004 <cblas_zsyr2k+0x1bc>
 8021f5e:	ec51 0b1a 	vmov	r0, r1, d10
 8021f62:	2300      	movs	r3, #0
 8021f64:	f007 f868 	bl	8029038 <__aeabi_dcmpeq>
 8021f68:	2800      	cmp	r0, #0
 8021f6a:	d05a      	beq.n	8022022 <cblas_zsyr2k+0x1da>
      if (uplo == CblasUpper) {
 8021f6c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021f6e:	2b79      	cmp	r3, #121	; 0x79
 8021f70:	f000 80f4 	beq.w	802215c <cblas_zsyr2k+0x314>
        for (i = 0; i < N; i++) {
 8021f74:	9b04      	ldr	r3, [sp, #16]
 8021f76:	2b00      	cmp	r3, #0
 8021f78:	dd1a      	ble.n	8021fb0 <cblas_zsyr2k+0x168>
 8021f7a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021f7c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8021f7e:	9d04      	ldr	r5, [sp, #16]
 8021f80:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
 8021f84:	1c5c      	adds	r4, r3, #1
 8021f86:	2100      	movs	r1, #0
            REAL(C, ldc * i + j) = 0.0;
 8021f88:	2600      	movs	r6, #0
 8021f8a:	2700      	movs	r7, #0
 8021f8c:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 8021f8e:	4608      	mov	r0, r1
 8021f90:	3210      	adds	r2, #16
 8021f92:	469e      	mov	lr, r3
 8021f94:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
            REAL(C, ldc * i + j) = 0.0;
 8021f98:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8021f9c:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = 0; j <= i; j++) {
 8021fa0:	3310      	adds	r3, #16
 8021fa2:	429a      	cmp	r2, r3
 8021fa4:	d1f8      	bne.n	8021f98 <cblas_zsyr2k+0x150>
        for (i = 0; i < N; i++) {
 8021fa6:	3001      	adds	r0, #1
 8021fa8:	4285      	cmp	r5, r0
 8021faa:	4471      	add	r1, lr
 8021fac:	4422      	add	r2, r4
 8021fae:	d1f1      	bne.n	8021f94 <cblas_zsyr2k+0x14c>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8021fb0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8021fb4:	2200      	movs	r2, #0
 8021fb6:	2300      	movs	r3, #0
 8021fb8:	f007 f83e 	bl	8029038 <__aeabi_dcmpeq>
 8021fbc:	b160      	cbz	r0, 8021fd8 <cblas_zsyr2k+0x190>
 8021fbe:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8021fc2:	2200      	movs	r2, #0
 8021fc4:	2300      	movs	r3, #0
 8021fc6:	f007 f837 	bl	8029038 <__aeabi_dcmpeq>
 8021fca:	2800      	cmp	r0, #0
 8021fcc:	f040 80b0 	bne.w	8022130 <cblas_zsyr2k+0x2e8>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8021fd0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021fd2:	2b79      	cmp	r3, #121	; 0x79
 8021fd4:	f000 80e4 	beq.w	80221a0 <cblas_zsyr2k+0x358>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8021fd8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021fda:	2b7a      	cmp	r3, #122	; 0x7a
 8021fdc:	f000 823c 	beq.w	8022458 <cblas_zsyr2k+0x610>
      BLAS_ERROR("unrecognized operation");
 8021fe0:	4a5d      	ldr	r2, [pc, #372]	; (8022158 <cblas_zsyr2k+0x310>)
 8021fe2:	495b      	ldr	r1, [pc, #364]	; (8022150 <cblas_zsyr2k+0x308>)
 8021fe4:	2000      	movs	r0, #0
#define BASE double
#include "source_syr2k_c.h"
#undef BASE
}
 8021fe6:	b01d      	add	sp, #116	; 0x74
 8021fe8:	ecbd 8b10 	vpop	{d8-d15}
 8021fec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021ff0:	f006 bb8a 	b.w	8028708 <cblas_xerbla>
 8021ff4:	9b04      	ldr	r3, [sp, #16]
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8021ff6:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 8021ffa:	2a01      	cmp	r2, #1
 8021ffc:	f240 8088 	bls.w	8022110 <cblas_zsyr2k+0x2c8>
 8022000:	2002      	movs	r0, #2
 8022002:	e74c      	b.n	8021e9e <cblas_zsyr2k+0x56>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8022004:	4b53      	ldr	r3, [pc, #332]	; (8022154 <cblas_zsyr2k+0x30c>)
 8022006:	ec51 0b1b 	vmov	r0, r1, d11
 802200a:	f007 f815 	bl	8029038 <__aeabi_dcmpeq>
 802200e:	b140      	cbz	r0, 8022022 <cblas_zsyr2k+0x1da>
 8022010:	ec51 0b1a 	vmov	r0, r1, d10
 8022014:	2200      	movs	r2, #0
 8022016:	2300      	movs	r3, #0
 8022018:	f007 f80e 	bl	8029038 <__aeabi_dcmpeq>
 802201c:	2800      	cmp	r0, #0
 802201e:	f040 8363 	bne.w	80226e8 <cblas_zsyr2k+0x8a0>
      if (uplo == CblasUpper) {
 8022022:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8022024:	2b79      	cmp	r3, #121	; 0x79
        for (i = 0; i < N; i++) {
 8022026:	9b04      	ldr	r3, [sp, #16]
      if (uplo == CblasUpper) {
 8022028:	f000 85fb 	beq.w	8022c22 <cblas_zsyr2k+0xdda>
        for (i = 0; i < N; i++) {
 802202c:	2b00      	cmp	r3, #0
 802202e:	ddbf      	ble.n	8021fb0 <cblas_zsyr2k+0x168>
 8022030:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8022032:	011b      	lsls	r3, r3, #4
 8022034:	930b      	str	r3, [sp, #44]	; 0x2c
 8022036:	3310      	adds	r3, #16
 8022038:	930a      	str	r3, [sp, #40]	; 0x28
 802203a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802203c:	9302      	str	r3, [sp, #8]
 802203e:	3310      	adds	r3, #16
 8022040:	9300      	str	r3, [sp, #0]
 8022042:	2300      	movs	r3, #0
 8022044:	9305      	str	r3, [sp, #20]
 8022046:	9b02      	ldr	r3, [sp, #8]
 8022048:	ec59 8b1b 	vmov	r8, r9, d11
 802204c:	f103 0a08 	add.w	sl, r3, #8
 8022050:	469b      	mov	fp, r3
            const BASE Cij_real = REAL(C, ldc * i + j);
 8022052:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022056:	4640      	mov	r0, r8
 8022058:	4622      	mov	r2, r4
 802205a:	462b      	mov	r3, r5
 802205c:	4649      	mov	r1, r9
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 802205e:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022062:	f006 fd81 	bl	8028b68 <__aeabi_dmul>
 8022066:	4632      	mov	r2, r6
 8022068:	ec41 0b19 	vmov	d9, r0, r1
 802206c:	463b      	mov	r3, r7
 802206e:	ec51 0b1a 	vmov	r0, r1, d10
 8022072:	f006 fd79 	bl	8028b68 <__aeabi_dmul>
 8022076:	4602      	mov	r2, r0
 8022078:	460b      	mov	r3, r1
 802207a:	ec51 0b19 	vmov	r0, r1, d9
 802207e:	f006 fbbb 	bl	80287f8 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022082:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022084:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022088:	463b      	mov	r3, r7
 802208a:	4640      	mov	r0, r8
 802208c:	4649      	mov	r1, r9
 802208e:	f006 fd6b 	bl	8028b68 <__aeabi_dmul>
 8022092:	4622      	mov	r2, r4
 8022094:	462b      	mov	r3, r5
 8022096:	4604      	mov	r4, r0
 8022098:	460d      	mov	r5, r1
 802209a:	ec51 0b1a 	vmov	r0, r1, d10
 802209e:	f006 fd63 	bl	8028b68 <__aeabi_dmul>
 80220a2:	460b      	mov	r3, r1
 80220a4:	4602      	mov	r2, r0
 80220a6:	4629      	mov	r1, r5
 80220a8:	4620      	mov	r0, r4
 80220aa:	f006 fba7 	bl	80287fc <__adddf3>
          for (j = 0; j <= i; j++) {
 80220ae:	9b00      	ldr	r3, [sp, #0]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80220b0:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j <= i; j++) {
 80220b4:	f10b 0b10 	add.w	fp, fp, #16
 80220b8:	455b      	cmp	r3, fp
 80220ba:	f10a 0a10 	add.w	sl, sl, #16
 80220be:	d1c8      	bne.n	8022052 <cblas_zsyr2k+0x20a>
        for (i = 0; i < N; i++) {
 80220c0:	9a02      	ldr	r2, [sp, #8]
 80220c2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80220c4:	9b05      	ldr	r3, [sp, #20]
 80220c6:	440a      	add	r2, r1
 80220c8:	9202      	str	r2, [sp, #8]
 80220ca:	990a      	ldr	r1, [sp, #40]	; 0x28
 80220cc:	9a00      	ldr	r2, [sp, #0]
 80220ce:	440a      	add	r2, r1
 80220d0:	9200      	str	r2, [sp, #0]
 80220d2:	9a04      	ldr	r2, [sp, #16]
 80220d4:	3301      	adds	r3, #1
 80220d6:	429a      	cmp	r2, r3
 80220d8:	9305      	str	r3, [sp, #20]
 80220da:	d1b4      	bne.n	8022046 <cblas_zsyr2k+0x1fe>
 80220dc:	e768      	b.n	8021fb0 <cblas_zsyr2k+0x168>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80220de:	9804      	ldr	r0, [sp, #16]
 80220e0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80220e2:	2801      	cmp	r0, #1
 80220e4:	bfb8      	it	lt
 80220e6:	2001      	movlt	r0, #1
 80220e8:	4283      	cmp	r3, r0
 80220ea:	bfb4      	ite	lt
 80220ec:	200e      	movlt	r0, #14
 80220ee:	200b      	movge	r0, #11
 80220f0:	e6f0      	b.n	8021ed4 <cblas_zsyr2k+0x8c>
 80220f2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80220f4:	4293      	cmp	r3, r2
 80220f6:	dcf2      	bgt.n	80220de <cblas_zsyr2k+0x296>
 80220f8:	9b04      	ldr	r3, [sp, #16]
 80220fa:	9a16      	ldr	r2, [sp, #88]	; 0x58
 80220fc:	2b01      	cmp	r3, #1
 80220fe:	bfb8      	it	lt
 8022100:	2301      	movlt	r3, #1
 8022102:	4293      	cmp	r3, r2
 8022104:	f300 8442 	bgt.w	802298c <cblas_zsyr2k+0xb44>
 8022108:	2800      	cmp	r0, #0
 802210a:	f43f aee7 	beq.w	8021edc <cblas_zsyr2k+0x94>
 802210e:	e6e1      	b.n	8021ed4 <cblas_zsyr2k+0x8c>
 8022110:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 8022114:	2801      	cmp	r0, #1
 8022116:	bf94      	ite	ls
 8022118:	2000      	movls	r0, #0
 802211a:	2001      	movhi	r0, #1
 802211c:	e6ba      	b.n	8021e94 <cblas_zsyr2k+0x4c>
        && (beta_real == 1.0 && beta_imag == 0.0))
 802211e:	ec51 0b19 	vmov	r0, r1, d9
 8022122:	2200      	movs	r2, #0
 8022124:	2300      	movs	r3, #0
 8022126:	f006 ff87 	bl	8029038 <__aeabi_dcmpeq>
 802212a:	2800      	cmp	r0, #0
 802212c:	f43f af01 	beq.w	8021f32 <cblas_zsyr2k+0xea>
 8022130:	b01d      	add	sp, #116	; 0x74
 8022132:	ecbd 8b10 	vpop	{d8-d15}
 8022136:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 802213a:	2a6f      	cmp	r2, #111	; 0x6f
 802213c:	f000 85c5 	beq.w	8022cca <cblas_zsyr2k+0xe82>
 8022140:	9b04      	ldr	r3, [sp, #16]
 8022142:	e6a1      	b.n	8021e88 <cblas_zsyr2k+0x40>
      trans = Trans;
 8022144:	e9cd 640f 	strd	r6, r4, [sp, #60]	; 0x3c
 8022148:	e700      	b.n	8021f4c <cblas_zsyr2k+0x104>
 802214a:	bf00      	nop
 802214c:	08031108 	.word	0x08031108
 8022150:	08031370 	.word	0x08031370
 8022154:	3ff00000 	.word	0x3ff00000
 8022158:	080311b8 	.word	0x080311b8
        for (i = 0; i < N; i++) {
 802215c:	9d04      	ldr	r5, [sp, #16]
 802215e:	2d00      	cmp	r5, #0
 8022160:	dd15      	ble.n	802218e <cblas_zsyr2k+0x346>
 8022162:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8022164:	9815      	ldr	r0, [sp, #84]	; 0x54
 8022166:	1c5c      	adds	r4, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 8022168:	2600      	movs	r6, #0
 802216a:	2700      	movs	r7, #0
 802216c:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 802216e:	2100      	movs	r1, #0
 8022170:	4603      	mov	r3, r0
 8022172:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 8022174:	3201      	adds	r2, #1
 8022176:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 8022178:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 802217c:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = i; j < N; j++) {
 8022180:	f103 0310 	add.w	r3, r3, #16
 8022184:	dcf6      	bgt.n	8022174 <cblas_zsyr2k+0x32c>
        for (i = 0; i < N; i++) {
 8022186:	3101      	adds	r1, #1
 8022188:	428d      	cmp	r5, r1
 802218a:	4420      	add	r0, r4
 802218c:	d1f0      	bne.n	8022170 <cblas_zsyr2k+0x328>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 802218e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8022192:	2200      	movs	r2, #0
 8022194:	2300      	movs	r3, #0
 8022196:	f006 ff4f 	bl	8029038 <__aeabi_dcmpeq>
 802219a:	2800      	cmp	r0, #0
 802219c:	f47f af0f 	bne.w	8021fbe <cblas_zsyr2k+0x176>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 80221a0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80221a2:	2b6f      	cmp	r3, #111	; 0x6f
 80221a4:	f000 82aa 	beq.w	80226fc <cblas_zsyr2k+0x8b4>
    } else if (uplo == CblasUpper && trans == CblasTrans) {
 80221a8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80221aa:	2b70      	cmp	r3, #112	; 0x70
 80221ac:	f47f af18 	bne.w	8021fe0 <cblas_zsyr2k+0x198>
      for (k = 0; k < K; k++) {
 80221b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80221b2:	2b00      	cmp	r3, #0
 80221b4:	ddbc      	ble.n	8022130 <cblas_zsyr2k+0x2e8>
 80221b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80221b8:	2200      	movs	r2, #0
 80221ba:	3301      	adds	r3, #1
 80221bc:	e9cd 2213 	strd	r2, r2, [sp, #76]	; 0x4c
 80221c0:	011b      	lsls	r3, r3, #4
 80221c2:	9210      	str	r2, [sp, #64]	; 0x40
 80221c4:	930f      	str	r3, [sp, #60]	; 0x3c
        for (i = 0; i < N; i++) {
 80221c6:	9b04      	ldr	r3, [sp, #16]
 80221c8:	2b00      	cmp	r3, #0
 80221ca:	f340 8135 	ble.w	8022438 <cblas_zsyr2k+0x5f0>
 80221ce:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80221d0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80221d2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80221d6:	9302      	str	r3, [sp, #8]
 80221d8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80221da:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80221dc:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80221e0:	930b      	str	r3, [sp, #44]	; 0x2c
 80221e2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80221e4:	930a      	str	r3, [sp, #40]	; 0x28
 80221e6:	2300      	movs	r3, #0
 80221e8:	9305      	str	r3, [sp, #20]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 80221ea:	9f02      	ldr	r7, [sp, #8]
 80221ec:	ed97 7b00 	vldr	d7, [r7]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80221f0:	ed9d ab06 	vldr	d10, [sp, #24]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 80221f4:	eeb0 ba47 	vmov.f32	s22, s14
 80221f8:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80221fc:	ec53 2b17 	vmov	r2, r3, d7
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8022200:	ed97 7b02 	vldr	d7, [r7, #8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8022204:	ec51 0b1a 	vmov	r0, r1, d10
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8022208:	eeb0 8a47 	vmov.f32	s16, s14
 802220c:	eef0 8a67 	vmov.f32	s17, s15
 8022210:	eeb0 fa47 	vmov.f32	s30, s14
 8022214:	eef0 fa67 	vmov.f32	s31, s15
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8022218:	f006 fca6 	bl	8028b68 <__aeabi_dmul>
 802221c:	ed9d 9b08 	vldr	d9, [sp, #32]
 8022220:	ec53 2b18 	vmov	r2, r3, d8
 8022224:	4604      	mov	r4, r0
 8022226:	460d      	mov	r5, r1
 8022228:	ec51 0b19 	vmov	r0, r1, d9
 802222c:	f006 fc9c 	bl	8028b68 <__aeabi_dmul>
 8022230:	4602      	mov	r2, r0
 8022232:	460b      	mov	r3, r1
 8022234:	4620      	mov	r0, r4
 8022236:	4629      	mov	r1, r5
 8022238:	f006 fade 	bl	80287f8 <__aeabi_dsub>
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802223c:	ec53 2b18 	vmov	r2, r3, d8
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8022240:	4604      	mov	r4, r0
 8022242:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8022244:	ec51 0b1a 	vmov	r0, r1, d10
 8022248:	f006 fc8e 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 802224c:	ec45 4b1e 	vmov	d14, r4, r5
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8022250:	ec53 2b1b 	vmov	r2, r3, d11
 8022254:	4604      	mov	r4, r0
 8022256:	460d      	mov	r5, r1
 8022258:	ec51 0b19 	vmov	r0, r1, d9
 802225c:	f006 fc84 	bl	8028b68 <__aeabi_dmul>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8022260:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8022262:	4602      	mov	r2, r0
 8022264:	460b      	mov	r3, r1
 8022266:	4620      	mov	r0, r4
 8022268:	4629      	mov	r1, r5
 802226a:	f006 fac7 	bl	80287fc <__adddf3>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 802226e:	e9d6 8900 	ldrd	r8, r9, [r6]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8022272:	4604      	mov	r4, r0
 8022274:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8022276:	4642      	mov	r2, r8
 8022278:	464b      	mov	r3, r9
 802227a:	ec51 0b1a 	vmov	r0, r1, d10
 802227e:	f006 fc73 	bl	8028b68 <__aeabi_dmul>
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8022282:	ed96 8b02 	vldr	d8, [r6, #8]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8022286:	ec45 4b1c 	vmov	d12, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 802228a:	ec53 2b18 	vmov	r2, r3, d8
 802228e:	4604      	mov	r4, r0
 8022290:	460d      	mov	r5, r1
 8022292:	ec51 0b19 	vmov	r0, r1, d9
 8022296:	f006 fc67 	bl	8028b68 <__aeabi_dmul>
 802229a:	4602      	mov	r2, r0
 802229c:	460b      	mov	r3, r1
 802229e:	4620      	mov	r0, r4
 80222a0:	4629      	mov	r1, r5
 80222a2:	f006 faa9 	bl	80287f8 <__aeabi_dsub>
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80222a6:	ec53 2b18 	vmov	r2, r3, d8
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80222aa:	4604      	mov	r4, r0
 80222ac:	460d      	mov	r5, r1
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80222ae:	ec51 0b1a 	vmov	r0, r1, d10
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80222b2:	e9cd 4500 	strd	r4, r5, [sp]
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80222b6:	f006 fc57 	bl	8028b68 <__aeabi_dmul>
 80222ba:	4642      	mov	r2, r8
 80222bc:	4604      	mov	r4, r0
 80222be:	460d      	mov	r5, r1
 80222c0:	464b      	mov	r3, r9
 80222c2:	ec51 0b19 	vmov	r0, r1, d9
 80222c6:	f006 fc4f 	bl	8028b68 <__aeabi_dmul>
 80222ca:	4602      	mov	r2, r0
 80222cc:	460b      	mov	r3, r1
 80222ce:	4620      	mov	r0, r4
 80222d0:	4629      	mov	r1, r5
 80222d2:	f006 fa93 	bl	80287fc <__adddf3>
 80222d6:	4635      	mov	r5, r6
 80222d8:	ec41 0b19 	vmov	d9, r0, r1
 80222dc:	f8dd a008 	ldr.w	sl, [sp, #8]
 80222e0:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80222e2:	f8dd b014 	ldr.w	fp, [sp, #20]
 80222e6:	ec57 6b1b 	vmov	r6, r7, d11
 80222ea:	e012      	b.n	8022312 <cblas_zsyr2k+0x4ca>
 80222ec:	ed9a 7b06 	vldr	d7, [sl, #24]
 80222f0:	eeb0 fa47 	vmov.f32	s30, s14
 80222f4:	eef0 fa67 	vmov.f32	s31, s15
 80222f8:	ed95 7b06 	vldr	d7, [r5, #24]
 80222fc:	e9da 6704 	ldrd	r6, r7, [sl, #16]
 8022300:	eeb0 8a47 	vmov.f32	s16, s14
 8022304:	eef0 8a67 	vmov.f32	s17, s15
 8022308:	e9d5 8904 	ldrd	r8, r9, [r5, #16]
 802230c:	f10a 0a10 	add.w	sl, sl, #16
 8022310:	3510      	adds	r5, #16
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8022312:	4642      	mov	r2, r8
 8022314:	464b      	mov	r3, r9
 8022316:	ec51 0b1e 	vmov	r0, r1, d14
 802231a:	eeb0 da48 	vmov.f32	s26, s16
 802231e:	eef0 da68 	vmov.f32	s27, s17
 8022322:	f006 fc21 	bl	8028b68 <__aeabi_dmul>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8022326:	eeb0 aa4f 	vmov.f32	s20, s30
 802232a:	eef0 aa6f 	vmov.f32	s21, s31
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802232e:	ec53 2b18 	vmov	r2, r3, d8
 8022332:	ec41 0b18 	vmov	d8, r0, r1
 8022336:	ec51 0b1c 	vmov	r0, r1, d12
 802233a:	f006 fc15 	bl	8028b68 <__aeabi_dmul>
 802233e:	4602      	mov	r2, r0
 8022340:	460b      	mov	r3, r1
 8022342:	ec51 0b18 	vmov	r0, r1, d8
 8022346:	f006 fa57 	bl	80287f8 <__aeabi_dsub>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 802234a:	ed9d bb00 	vldr	d11, [sp]
 802234e:	4632      	mov	r2, r6
 8022350:	463b      	mov	r3, r7
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8022352:	ec41 0b18 	vmov	d8, r0, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8022356:	ec51 0b1b 	vmov	r0, r1, d11
 802235a:	f006 fc05 	bl	8028b68 <__aeabi_dmul>
 802235e:	ec53 2b1f 	vmov	r2, r3, d15
 8022362:	ec41 0b1f 	vmov	d15, r0, r1
 8022366:	ec51 0b19 	vmov	r0, r1, d9
 802236a:	f006 fbfd 	bl	8028b68 <__aeabi_dmul>
 802236e:	4602      	mov	r2, r0
 8022370:	460b      	mov	r3, r1
 8022372:	ec51 0b1f 	vmov	r0, r1, d15
 8022376:	f006 fa3f 	bl	80287f8 <__aeabi_dsub>
 802237a:	4602      	mov	r2, r0
 802237c:	460b      	mov	r3, r1
 802237e:	ec51 0b18 	vmov	r0, r1, d8
 8022382:	f006 fa3b 	bl	80287fc <__adddf3>
 8022386:	4602      	mov	r2, r0
 8022388:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802238a:	e9d4 0100 	ldrd	r0, r1, [r4]
 802238e:	f006 fa35 	bl	80287fc <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8022392:	ec53 2b1d 	vmov	r2, r3, d13
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8022396:	e9c4 0100 	strd	r0, r1, [r4]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802239a:	ec51 0b1e 	vmov	r0, r1, d14
 802239e:	f006 fbe3 	bl	8028b68 <__aeabi_dmul>
 80223a2:	4642      	mov	r2, r8
 80223a4:	464b      	mov	r3, r9
 80223a6:	4680      	mov	r8, r0
 80223a8:	4689      	mov	r9, r1
 80223aa:	ec51 0b1c 	vmov	r0, r1, d12
 80223ae:	f006 fbdb 	bl	8028b68 <__aeabi_dmul>
 80223b2:	4602      	mov	r2, r0
 80223b4:	460b      	mov	r3, r1
 80223b6:	4640      	mov	r0, r8
 80223b8:	4649      	mov	r1, r9
 80223ba:	f006 fa1f 	bl	80287fc <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80223be:	ec53 2b1a 	vmov	r2, r3, d10
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80223c2:	4680      	mov	r8, r0
 80223c4:	4689      	mov	r9, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80223c6:	ec51 0b1b 	vmov	r0, r1, d11
 80223ca:	f006 fbcd 	bl	8028b68 <__aeabi_dmul>
 80223ce:	4632      	mov	r2, r6
 80223d0:	463b      	mov	r3, r7
 80223d2:	4606      	mov	r6, r0
 80223d4:	460f      	mov	r7, r1
 80223d6:	ec51 0b19 	vmov	r0, r1, d9
 80223da:	f006 fbc5 	bl	8028b68 <__aeabi_dmul>
 80223de:	4602      	mov	r2, r0
 80223e0:	460b      	mov	r3, r1
 80223e2:	4630      	mov	r0, r6
 80223e4:	4639      	mov	r1, r7
 80223e6:	f006 fa09 	bl	80287fc <__adddf3>
 80223ea:	4602      	mov	r2, r0
 80223ec:	460b      	mov	r3, r1
 80223ee:	4640      	mov	r0, r8
 80223f0:	4649      	mov	r1, r9
 80223f2:	f006 fa03 	bl	80287fc <__adddf3>
 80223f6:	460b      	mov	r3, r1
 80223f8:	4602      	mov	r2, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80223fa:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 80223fe:	f006 f9fd 	bl	80287fc <__adddf3>
          for (j = i; j < N; j++) {
 8022402:	9b04      	ldr	r3, [sp, #16]
 8022404:	f10b 0b01 	add.w	fp, fp, #1
 8022408:	455b      	cmp	r3, fp
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802240a:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = i; j < N; j++) {
 802240e:	f104 0410 	add.w	r4, r4, #16
 8022412:	f73f af6b 	bgt.w	80222ec <cblas_zsyr2k+0x4a4>
        for (i = 0; i < N; i++) {
 8022416:	9a02      	ldr	r2, [sp, #8]
 8022418:	990f      	ldr	r1, [sp, #60]	; 0x3c
 802241a:	9b05      	ldr	r3, [sp, #20]
 802241c:	3210      	adds	r2, #16
 802241e:	9202      	str	r2, [sp, #8]
 8022420:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022422:	3210      	adds	r2, #16
 8022424:	920b      	str	r2, [sp, #44]	; 0x2c
 8022426:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8022428:	440a      	add	r2, r1
 802242a:	920a      	str	r2, [sp, #40]	; 0x28
 802242c:	9a04      	ldr	r2, [sp, #16]
 802242e:	3301      	adds	r3, #1
 8022430:	429a      	cmp	r2, r3
 8022432:	9305      	str	r3, [sp, #20]
 8022434:	f47f aed9 	bne.w	80221ea <cblas_zsyr2k+0x3a2>
      for (k = 0; k < K; k++) {
 8022438:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802243a:	990d      	ldr	r1, [sp, #52]	; 0x34
 802243c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802243e:	440a      	add	r2, r1
 8022440:	9213      	str	r2, [sp, #76]	; 0x4c
 8022442:	990e      	ldr	r1, [sp, #56]	; 0x38
 8022444:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022446:	440a      	add	r2, r1
 8022448:	9210      	str	r2, [sp, #64]	; 0x40
 802244a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802244c:	3301      	adds	r3, #1
 802244e:	429a      	cmp	r2, r3
 8022450:	9314      	str	r3, [sp, #80]	; 0x50
 8022452:	f47f aeb8 	bne.w	80221c6 <cblas_zsyr2k+0x37e>
 8022456:	e66b      	b.n	8022130 <cblas_zsyr2k+0x2e8>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8022458:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802245a:	2b6f      	cmp	r3, #111	; 0x6f
 802245c:	f000 82a0 	beq.w	80229a0 <cblas_zsyr2k+0xb58>
    } else if (uplo == CblasLower && trans == CblasTrans) {
 8022460:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022462:	2b70      	cmp	r3, #112	; 0x70
 8022464:	f47f adbc 	bne.w	8021fe0 <cblas_zsyr2k+0x198>
      for (k = 0; k < K; k++) {
 8022468:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802246a:	2b00      	cmp	r3, #0
 802246c:	f77f ae60 	ble.w	8022130 <cblas_zsyr2k+0x2e8>
 8022470:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022472:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8022474:	930b      	str	r3, [sp, #44]	; 0x2c
 8022476:	0112      	lsls	r2, r2, #4
 8022478:	920f      	str	r2, [sp, #60]	; 0x3c
 802247a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802247c:	0112      	lsls	r2, r2, #4
 802247e:	9210      	str	r2, [sp, #64]	; 0x40
 8022480:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8022482:	920a      	str	r2, [sp, #40]	; 0x28
 8022484:	9a04      	ldr	r2, [sp, #16]
 8022486:	3310      	adds	r3, #16
 8022488:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802248c:	930d      	str	r3, [sp, #52]	; 0x34
 802248e:	2300      	movs	r3, #0
 8022490:	930e      	str	r3, [sp, #56]	; 0x38
        for (i = 0; i < N; i++) {
 8022492:	9b04      	ldr	r3, [sp, #16]
 8022494:	2b00      	cmp	r3, #0
 8022496:	f340 8113 	ble.w	80226c0 <cblas_zsyr2k+0x878>
 802249a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802249c:	3308      	adds	r3, #8
 802249e:	9302      	str	r3, [sp, #8]
 80224a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80224a2:	3310      	adds	r3, #16
 80224a4:	9300      	str	r3, [sp, #0]
 80224a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80224a8:	9305      	str	r3, [sp, #20]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 80224aa:	9c00      	ldr	r4, [sp, #0]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80224ac:	ed9d 8b06 	vldr	d8, [sp, #24]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 80224b0:	e954 6704 	ldrd	r6, r7, [r4, #-16]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80224b4:	ec51 0b18 	vmov	r0, r1, d8
 80224b8:	463b      	mov	r3, r7
 80224ba:	4632      	mov	r2, r6
 80224bc:	f006 fb54 	bl	8028b68 <__aeabi_dmul>
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 80224c0:	e954 8902 	ldrd	r8, r9, [r4, #-8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80224c4:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 80224c8:	4642      	mov	r2, r8
 80224ca:	464b      	mov	r3, r9
 80224cc:	4604      	mov	r4, r0
 80224ce:	460d      	mov	r5, r1
 80224d0:	4650      	mov	r0, sl
 80224d2:	4659      	mov	r1, fp
 80224d4:	f006 fb48 	bl	8028b68 <__aeabi_dmul>
 80224d8:	4602      	mov	r2, r0
 80224da:	460b      	mov	r3, r1
 80224dc:	4620      	mov	r0, r4
 80224de:	4629      	mov	r1, r5
 80224e0:	f006 f98a 	bl	80287f8 <__aeabi_dsub>
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 80224e4:	4642      	mov	r2, r8
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80224e6:	4604      	mov	r4, r0
 80224e8:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 80224ea:	464b      	mov	r3, r9
 80224ec:	ec51 0b18 	vmov	r0, r1, d8
 80224f0:	f006 fb3a 	bl	8028b68 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80224f4:	ec45 4b1e 	vmov	d14, r4, r5
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 80224f8:	463b      	mov	r3, r7
 80224fa:	4604      	mov	r4, r0
 80224fc:	460d      	mov	r5, r1
 80224fe:	4632      	mov	r2, r6
 8022500:	4650      	mov	r0, sl
 8022502:	4659      	mov	r1, fp
 8022504:	f006 fb30 	bl	8028b68 <__aeabi_dmul>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8022508:	9f05      	ldr	r7, [sp, #20]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802250a:	4602      	mov	r2, r0
 802250c:	460b      	mov	r3, r1
 802250e:	4620      	mov	r0, r4
 8022510:	4629      	mov	r1, r5
 8022512:	f006 f973 	bl	80287fc <__adddf3>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8022516:	ed97 9b00 	vldr	d9, [r7]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802251a:	4604      	mov	r4, r0
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 802251c:	ec53 2b19 	vmov	r2, r3, d9
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8022520:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8022522:	ec51 0b18 	vmov	r0, r1, d8
 8022526:	f006 fb1f 	bl	8028b68 <__aeabi_dmul>
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 802252a:	e9d7 8902 	ldrd	r8, r9, [r7, #8]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802252e:	ec45 4b1c 	vmov	d12, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8022532:	4642      	mov	r2, r8
 8022534:	4604      	mov	r4, r0
 8022536:	460d      	mov	r5, r1
 8022538:	464b      	mov	r3, r9
 802253a:	4650      	mov	r0, sl
 802253c:	4659      	mov	r1, fp
 802253e:	f006 fb13 	bl	8028b68 <__aeabi_dmul>
 8022542:	4602      	mov	r2, r0
 8022544:	460b      	mov	r3, r1
 8022546:	4620      	mov	r0, r4
 8022548:	4629      	mov	r1, r5
 802254a:	f006 f955 	bl	80287f8 <__aeabi_dsub>
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 802254e:	4642      	mov	r2, r8
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8022550:	4604      	mov	r4, r0
 8022552:	460d      	mov	r5, r1
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8022554:	464b      	mov	r3, r9
 8022556:	ec51 0b18 	vmov	r0, r1, d8
 802255a:	f006 fb05 	bl	8028b68 <__aeabi_dmul>
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 802255e:	ec45 4b1b 	vmov	d11, r4, r5
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8022562:	ec53 2b19 	vmov	r2, r3, d9
 8022566:	4604      	mov	r4, r0
 8022568:	460d      	mov	r5, r1
 802256a:	4650      	mov	r0, sl
 802256c:	4659      	mov	r1, fp
 802256e:	f006 fafb 	bl	8028b68 <__aeabi_dmul>
 8022572:	460b      	mov	r3, r1
 8022574:	4602      	mov	r2, r0
 8022576:	4629      	mov	r1, r5
 8022578:	4620      	mov	r0, r4
 802257a:	f006 f93f 	bl	80287fc <__adddf3>
 802257e:	9b02      	ldr	r3, [sp, #8]
 8022580:	e9dd 5b0a 	ldrd	r5, fp, [sp, #40]	; 0x28
 8022584:	ec41 0b1a 	vmov	d10, r0, r1
          for (j = 0; j <= i; j++) {
 8022588:	f1a3 0a08 	sub.w	sl, r3, #8
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 802258c:	461c      	mov	r4, r3
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 802258e:	ed95 7b00 	vldr	d7, [r5]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 8022592:	ed95 6b02 	vldr	d6, [r5, #8]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 8022596:	eeb0 da47 	vmov.f32	s26, s14
 802259a:	eef0 da67 	vmov.f32	s27, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802259e:	ec53 2b17 	vmov	r2, r3, d7
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80225a2:	eeb0 8a46 	vmov.f32	s16, s12
 80225a6:	eef0 8a66 	vmov.f32	s17, s13
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80225aa:	ec51 0b1e 	vmov	r0, r1, d14
 80225ae:	f006 fadb 	bl	8028b68 <__aeabi_dmul>
 80225b2:	ec53 2b18 	vmov	r2, r3, d8
 80225b6:	4606      	mov	r6, r0
 80225b8:	460f      	mov	r7, r1
 80225ba:	ec51 0b1c 	vmov	r0, r1, d12
 80225be:	f006 fad3 	bl	8028b68 <__aeabi_dmul>
 80225c2:	4602      	mov	r2, r0
 80225c4:	460b      	mov	r3, r1
 80225c6:	4630      	mov	r0, r6
 80225c8:	4639      	mov	r1, r7
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 80225ca:	e9db 8900 	ldrd	r8, r9, [fp]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80225ce:	f006 f913 	bl	80287f8 <__aeabi_dsub>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80225d2:	4642      	mov	r2, r8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80225d4:	4606      	mov	r6, r0
 80225d6:	460f      	mov	r7, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80225d8:	464b      	mov	r3, r9
 80225da:	ec51 0b1b 	vmov	r0, r1, d11
 80225de:	f006 fac3 	bl	8028b68 <__aeabi_dmul>
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80225e2:	ed9b 9b02 	vldr	d9, [fp, #8]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80225e6:	ec41 0b1f 	vmov	d15, r0, r1
 80225ea:	ec53 2b19 	vmov	r2, r3, d9
 80225ee:	ec51 0b1a 	vmov	r0, r1, d10
 80225f2:	f006 fab9 	bl	8028b68 <__aeabi_dmul>
 80225f6:	4602      	mov	r2, r0
 80225f8:	460b      	mov	r3, r1
 80225fa:	ec51 0b1f 	vmov	r0, r1, d15
 80225fe:	f006 f8fb 	bl	80287f8 <__aeabi_dsub>
 8022602:	4602      	mov	r2, r0
 8022604:	460b      	mov	r3, r1
 8022606:	4630      	mov	r0, r6
 8022608:	4639      	mov	r1, r7
 802260a:	f006 f8f7 	bl	80287fc <__adddf3>
 802260e:	4602      	mov	r2, r0
 8022610:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8022612:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8022616:	f006 f8f1 	bl	80287fc <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802261a:	ec53 2b18 	vmov	r2, r3, d8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802261e:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8022622:	ec51 0b1e 	vmov	r0, r1, d14
 8022626:	f006 fa9f 	bl	8028b68 <__aeabi_dmul>
 802262a:	ec53 2b1d 	vmov	r2, r3, d13
 802262e:	4606      	mov	r6, r0
 8022630:	460f      	mov	r7, r1
 8022632:	ec51 0b1c 	vmov	r0, r1, d12
 8022636:	f006 fa97 	bl	8028b68 <__aeabi_dmul>
 802263a:	4602      	mov	r2, r0
 802263c:	460b      	mov	r3, r1
 802263e:	4630      	mov	r0, r6
 8022640:	4639      	mov	r1, r7
 8022642:	f006 f8db 	bl	80287fc <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8022646:	ec53 2b19 	vmov	r2, r3, d9
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802264a:	4606      	mov	r6, r0
 802264c:	460f      	mov	r7, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 802264e:	ec51 0b1b 	vmov	r0, r1, d11
 8022652:	f006 fa89 	bl	8028b68 <__aeabi_dmul>
 8022656:	4642      	mov	r2, r8
 8022658:	464b      	mov	r3, r9
 802265a:	4680      	mov	r8, r0
 802265c:	4689      	mov	r9, r1
 802265e:	ec51 0b1a 	vmov	r0, r1, d10
 8022662:	f006 fa81 	bl	8028b68 <__aeabi_dmul>
 8022666:	4602      	mov	r2, r0
 8022668:	460b      	mov	r3, r1
 802266a:	4640      	mov	r0, r8
 802266c:	4649      	mov	r1, r9
 802266e:	f006 f8c5 	bl	80287fc <__adddf3>
 8022672:	4602      	mov	r2, r0
 8022674:	460b      	mov	r3, r1
 8022676:	4630      	mov	r0, r6
 8022678:	4639      	mov	r1, r7
 802267a:	f006 f8bf 	bl	80287fc <__adddf3>
 802267e:	460b      	mov	r3, r1
 8022680:	4602      	mov	r2, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8022682:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8022686:	f006 f8b9 	bl	80287fc <__adddf3>
          for (j = 0; j <= i; j++) {
 802268a:	9b00      	ldr	r3, [sp, #0]
 802268c:	f10b 0b10 	add.w	fp, fp, #16
 8022690:	455b      	cmp	r3, fp
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8022692:	e9ca 0102 	strd	r0, r1, [sl, #8]
          for (j = 0; j <= i; j++) {
 8022696:	f105 0510 	add.w	r5, r5, #16
 802269a:	f104 0410 	add.w	r4, r4, #16
 802269e:	f10a 0a10 	add.w	sl, sl, #16
 80226a2:	f47f af74 	bne.w	802258e <cblas_zsyr2k+0x746>
        for (i = 0; i < N; i++) {
 80226a6:	9a05      	ldr	r2, [sp, #20]
 80226a8:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80226aa:	3210      	adds	r2, #16
 80226ac:	9205      	str	r2, [sp, #20]
 80226ae:	9a02      	ldr	r2, [sp, #8]
 80226b0:	440a      	add	r2, r1
 80226b2:	9202      	str	r2, [sp, #8]
 80226b4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80226b6:	3310      	adds	r3, #16
 80226b8:	429a      	cmp	r2, r3
 80226ba:	9300      	str	r3, [sp, #0]
 80226bc:	f47f aef5 	bne.w	80224aa <cblas_zsyr2k+0x662>
      for (k = 0; k < K; k++) {
 80226c0:	990d      	ldr	r1, [sp, #52]	; 0x34
 80226c2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80226c4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80226c6:	4608      	mov	r0, r1
 80226c8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80226ca:	4411      	add	r1, r2
 80226cc:	4410      	add	r0, r2
 80226ce:	910b      	str	r1, [sp, #44]	; 0x2c
 80226d0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80226d2:	9910      	ldr	r1, [sp, #64]	; 0x40
 80226d4:	900d      	str	r0, [sp, #52]	; 0x34
 80226d6:	440a      	add	r2, r1
 80226d8:	920a      	str	r2, [sp, #40]	; 0x28
 80226da:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80226dc:	3301      	adds	r3, #1
 80226de:	429a      	cmp	r2, r3
 80226e0:	930e      	str	r3, [sp, #56]	; 0x38
 80226e2:	f47f aed6 	bne.w	8022492 <cblas_zsyr2k+0x64a>
 80226e6:	e523      	b.n	8022130 <cblas_zsyr2k+0x2e8>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80226e8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80226ec:	2200      	movs	r2, #0
 80226ee:	2300      	movs	r3, #0
 80226f0:	f006 fca2 	bl	8029038 <__aeabi_dcmpeq>
 80226f4:	2800      	cmp	r0, #0
 80226f6:	f43f ac6b 	beq.w	8021fd0 <cblas_zsyr2k+0x188>
 80226fa:	e460      	b.n	8021fbe <cblas_zsyr2k+0x176>
      for (i = 0; i < N; i++) {
 80226fc:	9b04      	ldr	r3, [sp, #16]
 80226fe:	2b00      	cmp	r3, #0
 8022700:	f77f ad16 	ble.w	8022130 <cblas_zsyr2k+0x2e8>
 8022704:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8022706:	990c      	ldr	r1, [sp, #48]	; 0x30
 8022708:	3301      	adds	r3, #1
 802270a:	011b      	lsls	r3, r3, #4
 802270c:	931b      	str	r3, [sp, #108]	; 0x6c
 802270e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8022710:	2200      	movs	r2, #0
 8022712:	e9cd 2317 	strd	r2, r3, [sp, #92]	; 0x5c
 8022716:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8022718:	9216      	str	r2, [sp, #88]	; 0x58
 802271a:	011b      	lsls	r3, r3, #4
 802271c:	931a      	str	r3, [sp, #104]	; 0x68
 802271e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8022720:	9215      	str	r2, [sp, #84]	; 0x54
 8022722:	011b      	lsls	r3, r3, #4
 8022724:	9319      	str	r3, [sp, #100]	; 0x64
 8022726:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8022728:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 802272c:	9205      	str	r2, [sp, #20]
 802272e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8022730:	e9cd 2313 	strd	r2, r3, [sp, #76]	; 0x4c
          BASE temp_real = 0.0;
 8022734:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8022736:	930a      	str	r3, [sp, #40]	; 0x28
 8022738:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802273a:	930b      	str	r3, [sp, #44]	; 0x2c
 802273c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 802273e:	9310      	str	r3, [sp, #64]	; 0x40
 8022740:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8022742:	930f      	str	r3, [sp, #60]	; 0x3c
          BASE temp_imag = 0.0;
 8022744:	ed9f 7b94 	vldr	d7, [pc, #592]	; 8022998 <cblas_zsyr2k+0xb50>
          for (k = 0; k < K; k++) {
 8022748:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802274a:	2b00      	cmp	r3, #0
          BASE temp_imag = 0.0;
 802274c:	ed8d 7b02 	vstr	d7, [sp, #8]
          BASE temp_real = 0.0;
 8022750:	ed8d 7b00 	vstr	d7, [sp]
          for (k = 0; k < K; k++) {
 8022754:	f340 80a6 	ble.w	80228a4 <cblas_zsyr2k+0xa5c>
 8022758:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802275a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802275c:	e9dd 4a13 	ldrd	r4, sl, [sp, #76]	; 0x4c
 8022760:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
 8022764:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8022766:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8022768:	eb03 1502 	add.w	r5, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802276c:	ed9a 7b00 	vldr	d7, [sl]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8022770:	ed95 6b00 	vldr	d6, [r5]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8022774:	eeb0 ea47 	vmov.f32	s28, s14
 8022778:	eef0 ea67 	vmov.f32	s29, s15
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 802277c:	ed95 5b02 	vldr	d5, [r5, #8]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8022780:	eeb0 da46 	vmov.f32	s26, s12
 8022784:	eef0 da66 	vmov.f32	s27, s13
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022788:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 802278c:	eeb0 9a45 	vmov.f32	s18, s10
 8022790:	eef0 9a65 	vmov.f32	s19, s11
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022794:	ec51 0b17 	vmov	r0, r1, d7
 8022798:	f006 f9e6 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 802279c:	ed9a 8b02 	vldr	d8, [sl, #8]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80227a0:	ec53 2b19 	vmov	r2, r3, d9
 80227a4:	4606      	mov	r6, r0
 80227a6:	460f      	mov	r7, r1
 80227a8:	ec51 0b18 	vmov	r0, r1, d8
 80227ac:	f006 f9dc 	bl	8028b68 <__aeabi_dmul>
 80227b0:	4602      	mov	r2, r0
 80227b2:	460b      	mov	r3, r1
 80227b4:	4630      	mov	r0, r6
 80227b6:	4639      	mov	r1, r7
 80227b8:	f006 f81e 	bl	80287f8 <__aeabi_dsub>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 80227bc:	ed94 ab00 	vldr	d10, [r4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80227c0:	ed9b bb00 	vldr	d11, [fp]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80227c4:	4606      	mov	r6, r0
 80227c6:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80227c8:	ec53 2b1b 	vmov	r2, r3, d11
 80227cc:	ec51 0b1a 	vmov	r0, r1, d10
 80227d0:	f006 f9ca 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 80227d4:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80227d8:	ed9b cb02 	vldr	d12, [fp, #8]
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80227dc:	ec41 0b1f 	vmov	d15, r0, r1
 80227e0:	ec53 2b1c 	vmov	r2, r3, d12
 80227e4:	4640      	mov	r0, r8
 80227e6:	4649      	mov	r1, r9
 80227e8:	f006 f9be 	bl	8028b68 <__aeabi_dmul>
 80227ec:	4602      	mov	r2, r0
 80227ee:	460b      	mov	r3, r1
 80227f0:	ec51 0b1f 	vmov	r0, r1, d15
 80227f4:	f006 f800 	bl	80287f8 <__aeabi_dsub>
 80227f8:	4602      	mov	r2, r0
 80227fa:	460b      	mov	r3, r1
 80227fc:	4630      	mov	r0, r6
 80227fe:	4639      	mov	r1, r7
 8022800:	f005 fffc 	bl	80287fc <__adddf3>
 8022804:	4602      	mov	r2, r0
 8022806:	460b      	mov	r3, r1
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022808:	e9dd 0100 	ldrd	r0, r1, [sp]
 802280c:	f005 fff6 	bl	80287fc <__adddf3>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022810:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022814:	4606      	mov	r6, r0
 8022816:	460f      	mov	r7, r1
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022818:	ec51 0b1e 	vmov	r0, r1, d14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 802281c:	e9cd 6700 	strd	r6, r7, [sp]
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022820:	f006 f9a2 	bl	8028b68 <__aeabi_dmul>
 8022824:	ec53 2b1d 	vmov	r2, r3, d13
 8022828:	4606      	mov	r6, r0
 802282a:	460f      	mov	r7, r1
 802282c:	ec51 0b18 	vmov	r0, r1, d8
 8022830:	f006 f99a 	bl	8028b68 <__aeabi_dmul>
 8022834:	4602      	mov	r2, r0
 8022836:	460b      	mov	r3, r1
 8022838:	4630      	mov	r0, r6
 802283a:	4639      	mov	r1, r7
 802283c:	f005 ffde 	bl	80287fc <__adddf3>
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8022840:	ec53 2b1c 	vmov	r2, r3, d12
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022844:	4606      	mov	r6, r0
 8022846:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8022848:	ec51 0b1a 	vmov	r0, r1, d10
 802284c:	f006 f98c 	bl	8028b68 <__aeabi_dmul>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022850:	ec47 6b18 	vmov	d8, r6, r7
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8022854:	ec53 2b1b 	vmov	r2, r3, d11
 8022858:	4606      	mov	r6, r0
 802285a:	460f      	mov	r7, r1
 802285c:	4640      	mov	r0, r8
 802285e:	4649      	mov	r1, r9
 8022860:	f006 f982 	bl	8028b68 <__aeabi_dmul>
 8022864:	4602      	mov	r2, r0
 8022866:	460b      	mov	r3, r1
 8022868:	4630      	mov	r0, r6
 802286a:	4639      	mov	r1, r7
 802286c:	f005 ffc6 	bl	80287fc <__adddf3>
 8022870:	4602      	mov	r2, r0
 8022872:	460b      	mov	r3, r1
 8022874:	ec51 0b18 	vmov	r0, r1, d8
 8022878:	f005 ffc0 	bl	80287fc <__adddf3>
 802287c:	460b      	mov	r3, r1
 802287e:	4602      	mov	r2, r0
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022880:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8022884:	f005 ffba 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 8022888:	9b05      	ldr	r3, [sp, #20]
 802288a:	f10a 0a10 	add.w	sl, sl, #16
 802288e:	459a      	cmp	sl, r3
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022890:	e9cd 0102 	strd	r0, r1, [sp, #8]
          for (k = 0; k < K; k++) {
 8022894:	f105 0510 	add.w	r5, r5, #16
 8022898:	f104 0410 	add.w	r4, r4, #16
 802289c:	f10b 0b10 	add.w	fp, fp, #16
 80228a0:	f47f af64 	bne.w	802276c <cblas_zsyr2k+0x924>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80228a4:	ed9d 9b00 	vldr	d9, [sp]
 80228a8:	ed9d 8b06 	vldr	d8, [sp, #24]
 80228ac:	ec53 2b19 	vmov	r2, r3, d9
 80228b0:	ec51 0b18 	vmov	r0, r1, d8
 80228b4:	f006 f958 	bl	8028b68 <__aeabi_dmul>
 80228b8:	e9dd 9a02 	ldrd	r9, sl, [sp, #8]
 80228bc:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 80228c0:	4604      	mov	r4, r0
 80228c2:	460d      	mov	r5, r1
 80228c4:	464a      	mov	r2, r9
 80228c6:	4653      	mov	r3, sl
 80228c8:	4638      	mov	r0, r7
 80228ca:	4641      	mov	r1, r8
 80228cc:	f006 f94c 	bl	8028b68 <__aeabi_dmul>
 80228d0:	4602      	mov	r2, r0
 80228d2:	460b      	mov	r3, r1
 80228d4:	4620      	mov	r0, r4
 80228d6:	4629      	mov	r1, r5
 80228d8:	f005 ff8e 	bl	80287f8 <__aeabi_dsub>
 80228dc:	9e10      	ldr	r6, [sp, #64]	; 0x40
 80228de:	4602      	mov	r2, r0
 80228e0:	460b      	mov	r3, r1
 80228e2:	e9d6 0100 	ldrd	r0, r1, [r6]
 80228e6:	f005 ff89 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80228ea:	464a      	mov	r2, r9
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80228ec:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80228f0:	4653      	mov	r3, sl
 80228f2:	ec51 0b18 	vmov	r0, r1, d8
 80228f6:	f006 f937 	bl	8028b68 <__aeabi_dmul>
 80228fa:	ec53 2b19 	vmov	r2, r3, d9
 80228fe:	460d      	mov	r5, r1
 8022900:	4604      	mov	r4, r0
 8022902:	4641      	mov	r1, r8
 8022904:	4638      	mov	r0, r7
 8022906:	f006 f92f 	bl	8028b68 <__aeabi_dmul>
 802290a:	4602      	mov	r2, r0
 802290c:	460b      	mov	r3, r1
 802290e:	4620      	mov	r0, r4
 8022910:	4629      	mov	r1, r5
 8022912:	f005 ff73 	bl	80287fc <__adddf3>
 8022916:	4602      	mov	r2, r0
 8022918:	460b      	mov	r3, r1
 802291a:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 802291e:	f005 ff6d 	bl	80287fc <__adddf3>
 8022922:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022924:	9d0d      	ldr	r5, [sp, #52]	; 0x34
        for (j = i; j < N; j++) {
 8022926:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8022928:	442b      	add	r3, r5
 802292a:	930b      	str	r3, [sp, #44]	; 0x2c
 802292c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 802292e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022930:	442b      	add	r3, r5
 8022932:	930a      	str	r3, [sp, #40]	; 0x28
 8022934:	f106 0310 	add.w	r3, r6, #16
 8022938:	9310      	str	r3, [sp, #64]	; 0x40
 802293a:	9b04      	ldr	r3, [sp, #16]
 802293c:	3201      	adds	r2, #1
 802293e:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022940:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = i; j < N; j++) {
 8022944:	920f      	str	r2, [sp, #60]	; 0x3c
 8022946:	f73f aefd 	bgt.w	8022744 <cblas_zsyr2k+0x8fc>
      for (i = 0; i < N; i++) {
 802294a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 802294c:	991b      	ldr	r1, [sp, #108]	; 0x6c
 802294e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8022950:	440a      	add	r2, r1
 8022952:	9218      	str	r2, [sp, #96]	; 0x60
 8022954:	990d      	ldr	r1, [sp, #52]	; 0x34
 8022956:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8022958:	440a      	add	r2, r1
 802295a:	9217      	str	r2, [sp, #92]	; 0x5c
 802295c:	990e      	ldr	r1, [sp, #56]	; 0x38
 802295e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8022960:	440a      	add	r2, r1
 8022962:	9914      	ldr	r1, [sp, #80]	; 0x50
 8022964:	9216      	str	r2, [sp, #88]	; 0x58
 8022966:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8022968:	4608      	mov	r0, r1
 802296a:	4410      	add	r0, r2
 802296c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 802296e:	9014      	str	r0, [sp, #80]	; 0x50
 8022970:	9819      	ldr	r0, [sp, #100]	; 0x64
 8022972:	4401      	add	r1, r0
 8022974:	9113      	str	r1, [sp, #76]	; 0x4c
 8022976:	9905      	ldr	r1, [sp, #20]
 8022978:	4411      	add	r1, r2
 802297a:	9a04      	ldr	r2, [sp, #16]
 802297c:	9105      	str	r1, [sp, #20]
 802297e:	3301      	adds	r3, #1
 8022980:	429a      	cmp	r2, r3
 8022982:	9315      	str	r3, [sp, #84]	; 0x54
 8022984:	f47f aed6 	bne.w	8022734 <cblas_zsyr2k+0x8ec>
 8022988:	f7ff bbd2 	b.w	8022130 <cblas_zsyr2k+0x2e8>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 802298c:	200e      	movs	r0, #14
 802298e:	f7ff baa1 	b.w	8021ed4 <cblas_zsyr2k+0x8c>
 8022992:	bf00      	nop
 8022994:	f3af 8000 	nop.w
	...
      for (i = 0; i < N; i++) {
 80229a0:	9b04      	ldr	r3, [sp, #16]
 80229a2:	2b00      	cmp	r3, #0
 80229a4:	f77f abc4 	ble.w	8022130 <cblas_zsyr2k+0x2e8>
 80229a8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80229aa:	990c      	ldr	r1, [sp, #48]	; 0x30
 80229ac:	3301      	adds	r3, #1
 80229ae:	011b      	lsls	r3, r3, #4
 80229b0:	931b      	str	r3, [sp, #108]	; 0x6c
 80229b2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80229b4:	3310      	adds	r3, #16
 80229b6:	9310      	str	r3, [sp, #64]	; 0x40
 80229b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80229ba:	011b      	lsls	r3, r3, #4
 80229bc:	931a      	str	r3, [sp, #104]	; 0x68
 80229be:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80229c0:	011b      	lsls	r3, r3, #4
 80229c2:	9319      	str	r3, [sp, #100]	; 0x64
 80229c4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80229c6:	2200      	movs	r2, #0
 80229c8:	9217      	str	r2, [sp, #92]	; 0x5c
 80229ca:	9218      	str	r2, [sp, #96]	; 0x60
 80229cc:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 80229d0:	9205      	str	r2, [sp, #20]
 80229d2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80229d4:	e9cd 2313 	strd	r2, r3, [sp, #76]	; 0x4c
          BASE temp_real = 0.0;
 80229d8:	2300      	movs	r3, #0
 80229da:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
 80229de:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80229e0:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80229e2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80229e6:	930f      	str	r3, [sp, #60]	; 0x3c
          BASE temp_imag = 0.0;
 80229e8:	ed1f 7b15 	vldr	d7, [pc, #-84]	; 8022998 <cblas_zsyr2k+0xb50>
          for (k = 0; k < K; k++) {
 80229ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80229ee:	2b00      	cmp	r3, #0
          BASE temp_imag = 0.0;
 80229f0:	ed8d 7b02 	vstr	d7, [sp, #8]
          BASE temp_real = 0.0;
 80229f4:	ed8d 7b00 	vstr	d7, [sp]
          for (k = 0; k < K; k++) {
 80229f8:	f340 80a6 	ble.w	8022b48 <cblas_zsyr2k+0xd00>
 80229fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80229fe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022a00:	e9dd 5a13 	ldrd	r5, sl, [sp, #76]	; 0x4c
 8022a04:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
 8022a08:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8022a0a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8022a0c:	eb03 1402 	add.w	r4, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8022a10:	ed9a 7b00 	vldr	d7, [sl]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8022a14:	ed94 6b00 	vldr	d6, [r4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8022a18:	eeb0 ea47 	vmov.f32	s28, s14
 8022a1c:	eef0 ea67 	vmov.f32	s29, s15
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8022a20:	ed94 5b02 	vldr	d5, [r4, #8]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8022a24:	eeb0 da46 	vmov.f32	s26, s12
 8022a28:	eef0 da66 	vmov.f32	s27, s13
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022a2c:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8022a30:	eeb0 9a45 	vmov.f32	s18, s10
 8022a34:	eef0 9a65 	vmov.f32	s19, s11
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022a38:	ec51 0b17 	vmov	r0, r1, d7
 8022a3c:	f006 f894 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8022a40:	ed9a 8b02 	vldr	d8, [sl, #8]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022a44:	ec53 2b19 	vmov	r2, r3, d9
 8022a48:	4606      	mov	r6, r0
 8022a4a:	460f      	mov	r7, r1
 8022a4c:	ec51 0b18 	vmov	r0, r1, d8
 8022a50:	f006 f88a 	bl	8028b68 <__aeabi_dmul>
 8022a54:	4602      	mov	r2, r0
 8022a56:	460b      	mov	r3, r1
 8022a58:	4630      	mov	r0, r6
 8022a5a:	4639      	mov	r1, r7
 8022a5c:	f005 fecc 	bl	80287f8 <__aeabi_dsub>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8022a60:	ed95 ab00 	vldr	d10, [r5]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022a64:	ed9b bb00 	vldr	d11, [fp]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022a68:	4606      	mov	r6, r0
 8022a6a:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8022a6c:	ec53 2b1b 	vmov	r2, r3, d11
 8022a70:	ec51 0b1a 	vmov	r0, r1, d10
 8022a74:	f006 f878 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 8022a78:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8022a7c:	ed9b cb02 	vldr	d12, [fp, #8]
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8022a80:	ec41 0b1f 	vmov	d15, r0, r1
 8022a84:	ec53 2b1c 	vmov	r2, r3, d12
 8022a88:	4640      	mov	r0, r8
 8022a8a:	4649      	mov	r1, r9
 8022a8c:	f006 f86c 	bl	8028b68 <__aeabi_dmul>
 8022a90:	4602      	mov	r2, r0
 8022a92:	460b      	mov	r3, r1
 8022a94:	ec51 0b1f 	vmov	r0, r1, d15
 8022a98:	f005 feae 	bl	80287f8 <__aeabi_dsub>
 8022a9c:	4602      	mov	r2, r0
 8022a9e:	460b      	mov	r3, r1
 8022aa0:	4630      	mov	r0, r6
 8022aa2:	4639      	mov	r1, r7
 8022aa4:	f005 feaa 	bl	80287fc <__adddf3>
 8022aa8:	4602      	mov	r2, r0
 8022aaa:	460b      	mov	r3, r1
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022aac:	e9dd 0100 	ldrd	r0, r1, [sp]
 8022ab0:	f005 fea4 	bl	80287fc <__adddf3>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022ab4:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022ab8:	4606      	mov	r6, r0
 8022aba:	460f      	mov	r7, r1
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022abc:	ec51 0b1e 	vmov	r0, r1, d14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8022ac0:	e9cd 6700 	strd	r6, r7, [sp]
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022ac4:	f006 f850 	bl	8028b68 <__aeabi_dmul>
 8022ac8:	ec53 2b1d 	vmov	r2, r3, d13
 8022acc:	4606      	mov	r6, r0
 8022ace:	460f      	mov	r7, r1
 8022ad0:	ec51 0b18 	vmov	r0, r1, d8
 8022ad4:	f006 f848 	bl	8028b68 <__aeabi_dmul>
 8022ad8:	4602      	mov	r2, r0
 8022ada:	460b      	mov	r3, r1
 8022adc:	4630      	mov	r0, r6
 8022ade:	4639      	mov	r1, r7
 8022ae0:	f005 fe8c 	bl	80287fc <__adddf3>
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8022ae4:	ec53 2b1c 	vmov	r2, r3, d12
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022ae8:	4606      	mov	r6, r0
 8022aea:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8022aec:	ec51 0b1a 	vmov	r0, r1, d10
 8022af0:	f006 f83a 	bl	8028b68 <__aeabi_dmul>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022af4:	ec47 6b18 	vmov	d8, r6, r7
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8022af8:	ec53 2b1b 	vmov	r2, r3, d11
 8022afc:	4606      	mov	r6, r0
 8022afe:	460f      	mov	r7, r1
 8022b00:	4640      	mov	r0, r8
 8022b02:	4649      	mov	r1, r9
 8022b04:	f006 f830 	bl	8028b68 <__aeabi_dmul>
 8022b08:	4602      	mov	r2, r0
 8022b0a:	460b      	mov	r3, r1
 8022b0c:	4630      	mov	r0, r6
 8022b0e:	4639      	mov	r1, r7
 8022b10:	f005 fe74 	bl	80287fc <__adddf3>
 8022b14:	4602      	mov	r2, r0
 8022b16:	460b      	mov	r3, r1
 8022b18:	ec51 0b18 	vmov	r0, r1, d8
 8022b1c:	f005 fe6e 	bl	80287fc <__adddf3>
 8022b20:	460b      	mov	r3, r1
 8022b22:	4602      	mov	r2, r0
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022b24:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8022b28:	f005 fe68 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 8022b2c:	9b05      	ldr	r3, [sp, #20]
 8022b2e:	f10a 0a10 	add.w	sl, sl, #16
 8022b32:	4553      	cmp	r3, sl
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8022b34:	e9cd 0102 	strd	r0, r1, [sp, #8]
          for (k = 0; k < K; k++) {
 8022b38:	f104 0410 	add.w	r4, r4, #16
 8022b3c:	f105 0510 	add.w	r5, r5, #16
 8022b40:	f10b 0b10 	add.w	fp, fp, #16
 8022b44:	f47f af64 	bne.w	8022a10 <cblas_zsyr2k+0xbc8>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022b48:	ed9d 9b00 	vldr	d9, [sp]
 8022b4c:	ed9d 8b06 	vldr	d8, [sp, #24]
 8022b50:	ec53 2b19 	vmov	r2, r3, d9
 8022b54:	ec51 0b18 	vmov	r0, r1, d8
 8022b58:	f006 f806 	bl	8028b68 <__aeabi_dmul>
 8022b5c:	e9dd 9a02 	ldrd	r9, sl, [sp, #8]
 8022b60:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 8022b64:	4604      	mov	r4, r0
 8022b66:	460d      	mov	r5, r1
 8022b68:	464a      	mov	r2, r9
 8022b6a:	4653      	mov	r3, sl
 8022b6c:	4638      	mov	r0, r7
 8022b6e:	4641      	mov	r1, r8
 8022b70:	f005 fffa 	bl	8028b68 <__aeabi_dmul>
 8022b74:	4602      	mov	r2, r0
 8022b76:	460b      	mov	r3, r1
 8022b78:	4620      	mov	r0, r4
 8022b7a:	4629      	mov	r1, r5
 8022b7c:	f005 fe3c 	bl	80287f8 <__aeabi_dsub>
 8022b80:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8022b82:	4602      	mov	r2, r0
 8022b84:	460b      	mov	r3, r1
 8022b86:	e9d6 0100 	ldrd	r0, r1, [r6]
 8022b8a:	f005 fe37 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022b8e:	464a      	mov	r2, r9
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022b90:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022b94:	4653      	mov	r3, sl
 8022b96:	ec51 0b18 	vmov	r0, r1, d8
 8022b9a:	f005 ffe5 	bl	8028b68 <__aeabi_dmul>
 8022b9e:	ec53 2b19 	vmov	r2, r3, d9
 8022ba2:	4604      	mov	r4, r0
 8022ba4:	460d      	mov	r5, r1
 8022ba6:	4638      	mov	r0, r7
 8022ba8:	4641      	mov	r1, r8
 8022baa:	f005 ffdd 	bl	8028b68 <__aeabi_dmul>
 8022bae:	4602      	mov	r2, r0
 8022bb0:	460b      	mov	r3, r1
 8022bb2:	4620      	mov	r0, r4
 8022bb4:	4629      	mov	r1, r5
 8022bb6:	f005 fe21 	bl	80287fc <__adddf3>
 8022bba:	4602      	mov	r2, r0
 8022bbc:	460b      	mov	r3, r1
 8022bbe:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8022bc2:	f005 fe1b 	bl	80287fc <__adddf3>
 8022bc6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022bc8:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j <= i; j++) {
 8022bcc:	990d      	ldr	r1, [sp, #52]	; 0x34
 8022bce:	440a      	add	r2, r1
 8022bd0:	920b      	str	r2, [sp, #44]	; 0x2c
 8022bd2:	990e      	ldr	r1, [sp, #56]	; 0x38
 8022bd4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8022bd6:	440a      	add	r2, r1
 8022bd8:	920a      	str	r2, [sp, #40]	; 0x28
 8022bda:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022bdc:	f106 0310 	add.w	r3, r6, #16
 8022be0:	429a      	cmp	r2, r3
 8022be2:	930f      	str	r3, [sp, #60]	; 0x3c
 8022be4:	f47f af00 	bne.w	80229e8 <cblas_zsyr2k+0xba0>
      for (i = 0; i < N; i++) {
 8022be8:	e9dd 1216 	ldrd	r1, r2, [sp, #88]	; 0x58
 8022bec:	440a      	add	r2, r1
 8022bee:	9217      	str	r2, [sp, #92]	; 0x5c
 8022bf0:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8022bf2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022bf4:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8022bf6:	440a      	add	r2, r1
 8022bf8:	9914      	ldr	r1, [sp, #80]	; 0x50
 8022bfa:	9210      	str	r2, [sp, #64]	; 0x40
 8022bfc:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8022bfe:	4608      	mov	r0, r1
 8022c00:	4410      	add	r0, r2
 8022c02:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8022c04:	9014      	str	r0, [sp, #80]	; 0x50
 8022c06:	9819      	ldr	r0, [sp, #100]	; 0x64
 8022c08:	4401      	add	r1, r0
 8022c0a:	9113      	str	r1, [sp, #76]	; 0x4c
 8022c0c:	9905      	ldr	r1, [sp, #20]
 8022c0e:	4411      	add	r1, r2
 8022c10:	9a04      	ldr	r2, [sp, #16]
 8022c12:	9105      	str	r1, [sp, #20]
 8022c14:	3301      	adds	r3, #1
 8022c16:	429a      	cmp	r2, r3
 8022c18:	9318      	str	r3, [sp, #96]	; 0x60
 8022c1a:	f47f aedd 	bne.w	80229d8 <cblas_zsyr2k+0xb90>
 8022c1e:	f7ff ba87 	b.w	8022130 <cblas_zsyr2k+0x2e8>
        for (i = 0; i < N; i++) {
 8022c22:	2b00      	cmp	r3, #0
 8022c24:	f77f aab3 	ble.w	802218e <cblas_zsyr2k+0x346>
 8022c28:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8022c2a:	3301      	adds	r3, #1
 8022c2c:	011b      	lsls	r3, r3, #4
 8022c2e:	9305      	str	r3, [sp, #20]
 8022c30:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8022c32:	9302      	str	r3, [sp, #8]
 8022c34:	2300      	movs	r3, #0
 8022c36:	9300      	str	r3, [sp, #0]
 8022c38:	f8dd a008 	ldr.w	sl, [sp, #8]
 8022c3c:	f8dd b000 	ldr.w	fp, [sp]
 8022c40:	ec59 8b1b 	vmov	r8, r9, d11
            const BASE Cij_real = REAL(C, ldc * i + j);
 8022c44:	e9da 4500 	ldrd	r4, r5, [sl]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022c48:	4640      	mov	r0, r8
 8022c4a:	4622      	mov	r2, r4
 8022c4c:	462b      	mov	r3, r5
 8022c4e:	4649      	mov	r1, r9
 8022c50:	f005 ff8a 	bl	8028b68 <__aeabi_dmul>
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8022c54:	e9da 6702 	ldrd	r6, r7, [sl, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022c58:	ec41 0b19 	vmov	d9, r0, r1
 8022c5c:	4632      	mov	r2, r6
 8022c5e:	463b      	mov	r3, r7
 8022c60:	ec51 0b1a 	vmov	r0, r1, d10
 8022c64:	f005 ff80 	bl	8028b68 <__aeabi_dmul>
 8022c68:	4602      	mov	r2, r0
 8022c6a:	460b      	mov	r3, r1
 8022c6c:	ec51 0b19 	vmov	r0, r1, d9
 8022c70:	f005 fdc2 	bl	80287f8 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022c74:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022c76:	e9ca 0100 	strd	r0, r1, [sl]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022c7a:	463b      	mov	r3, r7
 8022c7c:	4640      	mov	r0, r8
 8022c7e:	4649      	mov	r1, r9
 8022c80:	f005 ff72 	bl	8028b68 <__aeabi_dmul>
 8022c84:	4622      	mov	r2, r4
 8022c86:	462b      	mov	r3, r5
 8022c88:	4604      	mov	r4, r0
 8022c8a:	460d      	mov	r5, r1
 8022c8c:	ec51 0b1a 	vmov	r0, r1, d10
 8022c90:	f005 ff6a 	bl	8028b68 <__aeabi_dmul>
 8022c94:	460b      	mov	r3, r1
 8022c96:	4602      	mov	r2, r0
 8022c98:	4629      	mov	r1, r5
 8022c9a:	4620      	mov	r0, r4
 8022c9c:	f005 fdae 	bl	80287fc <__adddf3>
          for (j = i; j < N; j++) {
 8022ca0:	9b04      	ldr	r3, [sp, #16]
 8022ca2:	f10b 0b01 	add.w	fp, fp, #1
 8022ca6:	455b      	cmp	r3, fp
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022ca8:	e9ca 0102 	strd	r0, r1, [sl, #8]
          for (j = i; j < N; j++) {
 8022cac:	f10a 0a10 	add.w	sl, sl, #16
 8022cb0:	dcc8      	bgt.n	8022c44 <cblas_zsyr2k+0xdfc>
        for (i = 0; i < N; i++) {
 8022cb2:	9a02      	ldr	r2, [sp, #8]
 8022cb4:	9905      	ldr	r1, [sp, #20]
 8022cb6:	9b00      	ldr	r3, [sp, #0]
 8022cb8:	440a      	add	r2, r1
 8022cba:	9202      	str	r2, [sp, #8]
 8022cbc:	9a04      	ldr	r2, [sp, #16]
 8022cbe:	3301      	adds	r3, #1
 8022cc0:	429a      	cmp	r2, r3
 8022cc2:	9300      	str	r3, [sp, #0]
 8022cc4:	d1b8      	bne.n	8022c38 <cblas_zsyr2k+0xdf0>
 8022cc6:	f7ff ba62 	b.w	802218e <cblas_zsyr2k+0x346>
 8022cca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022ccc:	f7ff b993 	b.w	8021ff6 <cblas_zsyr2k+0x1ae>

08022cd0 <cblas_zsyrk>:
void
cblas_zsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const void *alpha, const void *A, const int lda,
             const void *beta, void *C, const int ldc)
{
 8022cd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022cd4:	ed2d 8b0e 	vpush	{d8-d14}
 8022cd8:	b093      	sub	sp, #76	; 0x4c
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8022cda:	2865      	cmp	r0, #101	; 0x65
 8022cdc:	9303      	str	r3, [sp, #12]
 8022cde:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8022ce0:	9301      	str	r3, [sp, #4]
 8022ce2:	e9dd 832b 	ldrd	r8, r3, [sp, #172]	; 0xac
 8022ce6:	9304      	str	r3, [sp, #16]
 8022ce8:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8022cea:	9306      	str	r3, [sp, #24]
 8022cec:	e9dd 732e 	ldrd	r7, r3, [sp, #184]	; 0xb8
 8022cf0:	930c      	str	r3, [sp, #48]	; 0x30
 8022cf2:	9b30      	ldr	r3, [sp, #192]	; 0xc0
 8022cf4:	930b      	str	r3, [sp, #44]	; 0x2c
 8022cf6:	4606      	mov	r6, r0
 8022cf8:	460c      	mov	r4, r1
 8022cfa:	4615      	mov	r5, r2
 8022cfc:	f000 815a 	beq.w	8022fb4 <cblas_zsyrk+0x2e4>
 8022d00:	2a6f      	cmp	r2, #111	; 0x6f
 8022d02:	d023      	beq.n	8022d4c <cblas_zsyrk+0x7c>
 8022d04:	9b01      	ldr	r3, [sp, #4]
 8022d06:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8022d0a:	2a01      	cmp	r2, #1
 8022d0c:	f240 814b 	bls.w	8022fa6 <cblas_zsyrk+0x2d6>
 8022d10:	2002      	movs	r0, #2
 8022d12:	f1a5 026f 	sub.w	r2, r5, #111	; 0x6f
 8022d16:	2a02      	cmp	r2, #2
 8022d18:	bf88      	it	hi
 8022d1a:	2003      	movhi	r0, #3
 8022d1c:	9a03      	ldr	r2, [sp, #12]
 8022d1e:	9901      	ldr	r1, [sp, #4]
 8022d20:	2a00      	cmp	r2, #0
 8022d22:	bfb8      	it	lt
 8022d24:	2004      	movlt	r0, #4
 8022d26:	2b01      	cmp	r3, #1
 8022d28:	bfb8      	it	lt
 8022d2a:	2301      	movlt	r3, #1
 8022d2c:	2900      	cmp	r1, #0
 8022d2e:	f2c0 812d 	blt.w	8022f8c <cblas_zsyrk+0x2bc>
 8022d32:	9a06      	ldr	r2, [sp, #24]
 8022d34:	4293      	cmp	r3, r2
 8022d36:	dc11      	bgt.n	8022d5c <cblas_zsyrk+0x8c>
 8022d38:	9b03      	ldr	r3, [sp, #12]
 8022d3a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8022d3c:	2b01      	cmp	r3, #1
 8022d3e:	bfb8      	it	lt
 8022d40:	2301      	movlt	r3, #1
 8022d42:	4293      	cmp	r3, r2
 8022d44:	f300 8345 	bgt.w	80233d2 <cblas_zsyrk+0x702>
 8022d48:	b1a8      	cbz	r0, 8022d76 <cblas_zsyrk+0xa6>
 8022d4a:	e010      	b.n	8022d6e <cblas_zsyrk+0x9e>
 8022d4c:	9b03      	ldr	r3, [sp, #12]
 8022d4e:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8022d52:	2a01      	cmp	r2, #1
 8022d54:	f240 8127 	bls.w	8022fa6 <cblas_zsyrk+0x2d6>
 8022d58:	2002      	movs	r0, #2
 8022d5a:	e7df      	b.n	8022d1c <cblas_zsyrk+0x4c>
 8022d5c:	9803      	ldr	r0, [sp, #12]
 8022d5e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022d60:	2801      	cmp	r0, #1
 8022d62:	bfb8      	it	lt
 8022d64:	2001      	movlt	r0, #1
 8022d66:	4298      	cmp	r0, r3
 8022d68:	bfcc      	ite	gt
 8022d6a:	200b      	movgt	r0, #11
 8022d6c:	2008      	movle	r0, #8
 8022d6e:	4a97      	ldr	r2, [pc, #604]	; (8022fcc <cblas_zsyrk+0x2fc>)
 8022d70:	4997      	ldr	r1, [pc, #604]	; (8022fd0 <cblas_zsyrk+0x300>)
 8022d72:	f005 fcc9 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8022d76:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8022d7a:	2200      	movs	r2, #0
 8022d7c:	ec51 0b17 	vmov	r0, r1, d7
    const BASE alpha_real = CONST_REAL0(alpha);
 8022d80:	eeb0 da47 	vmov.f32	s26, s14
 8022d84:	eef0 da67 	vmov.f32	s27, s15
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8022d88:	2300      	movs	r3, #0
 8022d8a:	f006 f955 	bl	8029038 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8022d8e:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8022d92:	ed97 8b00 	vldr	d8, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8022d96:	eeb0 ea47 	vmov.f32	s28, s14
 8022d9a:	eef0 ea67 	vmov.f32	s29, s15
    const BASE beta_imag = CONST_IMAG0(beta);
 8022d9e:	ed97 9b02 	vldr	d9, [r7, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8022da2:	eeb0 ba48 	vmov.f32	s22, s16
 8022da6:	eef0 ba68 	vmov.f32	s23, s17
    const BASE beta_imag = CONST_IMAG0(beta);
 8022daa:	eeb0 aa49 	vmov.f32	s20, s18
 8022dae:	eef0 aa69 	vmov.f32	s21, s19
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8022db2:	b178      	cbz	r0, 8022dd4 <cblas_zsyrk+0x104>
 8022db4:	ec51 0b17 	vmov	r0, r1, d7
 8022db8:	2200      	movs	r2, #0
 8022dba:	2300      	movs	r3, #0
 8022dbc:	f006 f93c 	bl	8029038 <__aeabi_dcmpeq>
 8022dc0:	b140      	cbz	r0, 8022dd4 <cblas_zsyrk+0x104>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8022dc2:	4b84      	ldr	r3, [pc, #528]	; (8022fd4 <cblas_zsyrk+0x304>)
 8022dc4:	ec51 0b18 	vmov	r0, r1, d8
 8022dc8:	2200      	movs	r2, #0
 8022dca:	f006 f935 	bl	8029038 <__aeabi_dcmpeq>
 8022dce:	2800      	cmp	r0, #0
 8022dd0:	f040 80ce 	bne.w	8022f70 <cblas_zsyrk+0x2a0>
    if (Order == CblasRowMajor) {
 8022dd4:	2e65      	cmp	r6, #101	; 0x65
 8022dd6:	f000 80f2 	beq.w	8022fbe <cblas_zsyrk+0x2ee>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8022dda:	2c79      	cmp	r4, #121	; 0x79
 8022ddc:	bf0c      	ite	eq
 8022dde:	237a      	moveq	r3, #122	; 0x7a
 8022de0:	2379      	movne	r3, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8022de2:	2d6f      	cmp	r5, #111	; 0x6f
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8022de4:	930a      	str	r3, [sp, #40]	; 0x28
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8022de6:	bf0c      	ite	eq
 8022de8:	2370      	moveq	r3, #112	; 0x70
 8022dea:	236f      	movne	r3, #111	; 0x6f
 8022dec:	930d      	str	r3, [sp, #52]	; 0x34
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8022dee:	2200      	movs	r2, #0
 8022df0:	ec51 0b1b 	vmov	r0, r1, d11
 8022df4:	2300      	movs	r3, #0
 8022df6:	f006 f91f 	bl	8029038 <__aeabi_dcmpeq>
 8022dfa:	2200      	movs	r2, #0
 8022dfc:	2800      	cmp	r0, #0
 8022dfe:	d04a      	beq.n	8022e96 <cblas_zsyrk+0x1c6>
 8022e00:	ec51 0b1a 	vmov	r0, r1, d10
 8022e04:	2300      	movs	r3, #0
 8022e06:	f006 f917 	bl	8029038 <__aeabi_dcmpeq>
 8022e0a:	2800      	cmp	r0, #0
 8022e0c:	d052      	beq.n	8022eb4 <cblas_zsyrk+0x1e4>
      if (uplo == CblasUpper) {
 8022e0e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022e10:	2b79      	cmp	r3, #121	; 0x79
 8022e12:	f000 80e3 	beq.w	8022fdc <cblas_zsyrk+0x30c>
        for (i = 0; i < N; i++) {
 8022e16:	9b03      	ldr	r3, [sp, #12]
 8022e18:	2b00      	cmp	r3, #0
 8022e1a:	dd1a      	ble.n	8022e52 <cblas_zsyrk+0x182>
 8022e1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022e1e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022e20:	9d03      	ldr	r5, [sp, #12]
 8022e22:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 8022e26:	1c5c      	adds	r4, r3, #1
 8022e28:	2100      	movs	r1, #0
            REAL(C, ldc * i + j) = 0.0;
 8022e2a:	2600      	movs	r6, #0
 8022e2c:	2700      	movs	r7, #0
 8022e2e:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 8022e30:	4608      	mov	r0, r1
 8022e32:	3210      	adds	r2, #16
 8022e34:	469e      	mov	lr, r3
 8022e36:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
            REAL(C, ldc * i + j) = 0.0;
 8022e3a:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8022e3e:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = 0; j <= i; j++) {
 8022e42:	3310      	adds	r3, #16
 8022e44:	429a      	cmp	r2, r3
 8022e46:	d1f8      	bne.n	8022e3a <cblas_zsyrk+0x16a>
        for (i = 0; i < N; i++) {
 8022e48:	3001      	adds	r0, #1
 8022e4a:	4285      	cmp	r5, r0
 8022e4c:	4471      	add	r1, lr
 8022e4e:	4422      	add	r2, r4
 8022e50:	d1f1      	bne.n	8022e36 <cblas_zsyrk+0x166>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8022e52:	ec51 0b1d 	vmov	r0, r1, d13
 8022e56:	2200      	movs	r2, #0
 8022e58:	2300      	movs	r3, #0
 8022e5a:	f006 f8ed 	bl	8029038 <__aeabi_dcmpeq>
 8022e5e:	b160      	cbz	r0, 8022e7a <cblas_zsyrk+0x1aa>
 8022e60:	ec51 0b1e 	vmov	r0, r1, d14
 8022e64:	2200      	movs	r2, #0
 8022e66:	2300      	movs	r3, #0
 8022e68:	f006 f8e6 	bl	8029038 <__aeabi_dcmpeq>
 8022e6c:	2800      	cmp	r0, #0
 8022e6e:	f040 8088 	bne.w	8022f82 <cblas_zsyrk+0x2b2>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8022e72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022e74:	2b79      	cmp	r3, #121	; 0x79
 8022e76:	f000 80d3 	beq.w	8023020 <cblas_zsyrk+0x350>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8022e7a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022e7c:	2b7a      	cmp	r3, #122	; 0x7a
 8022e7e:	f000 81b3 	beq.w	80231e8 <cblas_zsyrk+0x518>
      BLAS_ERROR("unrecognized operation");
 8022e82:	4a55      	ldr	r2, [pc, #340]	; (8022fd8 <cblas_zsyrk+0x308>)
 8022e84:	4952      	ldr	r1, [pc, #328]	; (8022fd0 <cblas_zsyrk+0x300>)
 8022e86:	2000      	movs	r0, #0
#define BASE double
#include "source_syrk_c.h"
#undef BASE
}
 8022e88:	b013      	add	sp, #76	; 0x4c
 8022e8a:	ecbd 8b0e 	vpop	{d8-d14}
 8022e8e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022e92:	f005 bc39 	b.w	8028708 <cblas_xerbla>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8022e96:	4b4f      	ldr	r3, [pc, #316]	; (8022fd4 <cblas_zsyrk+0x304>)
 8022e98:	ec51 0b1b 	vmov	r0, r1, d11
 8022e9c:	f006 f8cc 	bl	8029038 <__aeabi_dcmpeq>
 8022ea0:	b140      	cbz	r0, 8022eb4 <cblas_zsyrk+0x1e4>
 8022ea2:	ec51 0b1a 	vmov	r0, r1, d10
 8022ea6:	2200      	movs	r2, #0
 8022ea8:	2300      	movs	r3, #0
 8022eaa:	f006 f8c5 	bl	8029038 <__aeabi_dcmpeq>
 8022eae:	2800      	cmp	r0, #0
 8022eb0:	f040 8285 	bne.w	80233be <cblas_zsyrk+0x6ee>
      if (uplo == CblasUpper) {
 8022eb4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022eb6:	2b79      	cmp	r3, #121	; 0x79
        for (i = 0; i < N; i++) {
 8022eb8:	9b03      	ldr	r3, [sp, #12]
      if (uplo == CblasUpper) {
 8022eba:	f000 8461 	beq.w	8023780 <cblas_zsyrk+0xab0>
        for (i = 0; i < N; i++) {
 8022ebe:	2b00      	cmp	r3, #0
 8022ec0:	ddc7      	ble.n	8022e52 <cblas_zsyrk+0x182>
 8022ec2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022ec4:	011b      	lsls	r3, r3, #4
 8022ec6:	9309      	str	r3, [sp, #36]	; 0x24
 8022ec8:	3310      	adds	r3, #16
 8022eca:	9308      	str	r3, [sp, #32]
 8022ecc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022ece:	9305      	str	r3, [sp, #20]
 8022ed0:	3310      	adds	r3, #16
 8022ed2:	9302      	str	r3, [sp, #8]
 8022ed4:	2300      	movs	r3, #0
 8022ed6:	9307      	str	r3, [sp, #28]
 8022ed8:	9b05      	ldr	r3, [sp, #20]
 8022eda:	ec59 8b1b 	vmov	r8, r9, d11
 8022ede:	f103 0a08 	add.w	sl, r3, #8
 8022ee2:	469b      	mov	fp, r3
            const BASE Cij_real = REAL(C, ldc * i + j);
 8022ee4:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022ee8:	4640      	mov	r0, r8
 8022eea:	4622      	mov	r2, r4
 8022eec:	462b      	mov	r3, r5
 8022eee:	4649      	mov	r1, r9
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8022ef0:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022ef4:	f005 fe38 	bl	8028b68 <__aeabi_dmul>
 8022ef8:	4632      	mov	r2, r6
 8022efa:	ec41 0b19 	vmov	d9, r0, r1
 8022efe:	463b      	mov	r3, r7
 8022f00:	ec51 0b1a 	vmov	r0, r1, d10
 8022f04:	f005 fe30 	bl	8028b68 <__aeabi_dmul>
 8022f08:	4602      	mov	r2, r0
 8022f0a:	460b      	mov	r3, r1
 8022f0c:	ec51 0b19 	vmov	r0, r1, d9
 8022f10:	f005 fc72 	bl	80287f8 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022f14:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022f16:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022f1a:	463b      	mov	r3, r7
 8022f1c:	4640      	mov	r0, r8
 8022f1e:	4649      	mov	r1, r9
 8022f20:	f005 fe22 	bl	8028b68 <__aeabi_dmul>
 8022f24:	4622      	mov	r2, r4
 8022f26:	462b      	mov	r3, r5
 8022f28:	4604      	mov	r4, r0
 8022f2a:	460d      	mov	r5, r1
 8022f2c:	ec51 0b1a 	vmov	r0, r1, d10
 8022f30:	f005 fe1a 	bl	8028b68 <__aeabi_dmul>
 8022f34:	460b      	mov	r3, r1
 8022f36:	4602      	mov	r2, r0
 8022f38:	4629      	mov	r1, r5
 8022f3a:	4620      	mov	r0, r4
 8022f3c:	f005 fc5e 	bl	80287fc <__adddf3>
          for (j = 0; j <= i; j++) {
 8022f40:	9b02      	ldr	r3, [sp, #8]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022f42:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j <= i; j++) {
 8022f46:	f10b 0b10 	add.w	fp, fp, #16
 8022f4a:	455b      	cmp	r3, fp
 8022f4c:	f10a 0a10 	add.w	sl, sl, #16
 8022f50:	d1c8      	bne.n	8022ee4 <cblas_zsyrk+0x214>
        for (i = 0; i < N; i++) {
 8022f52:	9a05      	ldr	r2, [sp, #20]
 8022f54:	9909      	ldr	r1, [sp, #36]	; 0x24
 8022f56:	9b07      	ldr	r3, [sp, #28]
 8022f58:	440a      	add	r2, r1
 8022f5a:	9205      	str	r2, [sp, #20]
 8022f5c:	9908      	ldr	r1, [sp, #32]
 8022f5e:	9a02      	ldr	r2, [sp, #8]
 8022f60:	440a      	add	r2, r1
 8022f62:	9202      	str	r2, [sp, #8]
 8022f64:	9a03      	ldr	r2, [sp, #12]
 8022f66:	3301      	adds	r3, #1
 8022f68:	429a      	cmp	r2, r3
 8022f6a:	9307      	str	r3, [sp, #28]
 8022f6c:	d1b4      	bne.n	8022ed8 <cblas_zsyrk+0x208>
 8022f6e:	e770      	b.n	8022e52 <cblas_zsyrk+0x182>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8022f70:	ec51 0b19 	vmov	r0, r1, d9
 8022f74:	2200      	movs	r2, #0
 8022f76:	2300      	movs	r3, #0
 8022f78:	f006 f85e 	bl	8029038 <__aeabi_dcmpeq>
 8022f7c:	2800      	cmp	r0, #0
 8022f7e:	f43f af29 	beq.w	8022dd4 <cblas_zsyrk+0x104>
 8022f82:	b013      	add	sp, #76	; 0x4c
 8022f84:	ecbd 8b0e 	vpop	{d8-d14}
 8022f88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8022f8c:	9906      	ldr	r1, [sp, #24]
 8022f8e:	428b      	cmp	r3, r1
 8022f90:	f73f aee4 	bgt.w	8022d5c <cblas_zsyrk+0x8c>
 8022f94:	2a01      	cmp	r2, #1
 8022f96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022f98:	bfb8      	it	lt
 8022f9a:	2201      	movlt	r2, #1
 8022f9c:	4293      	cmp	r3, r2
 8022f9e:	bfb4      	ite	lt
 8022fa0:	200b      	movlt	r0, #11
 8022fa2:	2005      	movge	r0, #5
 8022fa4:	e6e3      	b.n	8022d6e <cblas_zsyrk+0x9e>
 8022fa6:	f1a6 0065 	sub.w	r0, r6, #101	; 0x65
 8022faa:	2801      	cmp	r0, #1
 8022fac:	bf94      	ite	ls
 8022fae:	2000      	movls	r0, #0
 8022fb0:	2001      	movhi	r0, #1
 8022fb2:	e6ae      	b.n	8022d12 <cblas_zsyrk+0x42>
 8022fb4:	2a6f      	cmp	r2, #111	; 0x6f
 8022fb6:	f000 8437 	beq.w	8023828 <cblas_zsyrk+0xb58>
 8022fba:	9b03      	ldr	r3, [sp, #12]
 8022fbc:	e6a3      	b.n	8022d06 <cblas_zsyrk+0x36>
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8022fbe:	2d6f      	cmp	r5, #111	; 0x6f
 8022fc0:	bf0c      	ite	eq
 8022fc2:	236f      	moveq	r3, #111	; 0x6f
 8022fc4:	2370      	movne	r3, #112	; 0x70
      uplo = Uplo;
 8022fc6:	940a      	str	r4, [sp, #40]	; 0x28
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8022fc8:	930d      	str	r3, [sp, #52]	; 0x34
 8022fca:	e710      	b.n	8022dee <cblas_zsyrk+0x11e>
 8022fcc:	08031108 	.word	0x08031108
 8022fd0:	08031384 	.word	0x08031384
 8022fd4:	3ff00000 	.word	0x3ff00000
 8022fd8:	080311b8 	.word	0x080311b8
        for (i = 0; i < N; i++) {
 8022fdc:	9d03      	ldr	r5, [sp, #12]
 8022fde:	2d00      	cmp	r5, #0
 8022fe0:	dd15      	ble.n	802300e <cblas_zsyrk+0x33e>
 8022fe2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022fe4:	980c      	ldr	r0, [sp, #48]	; 0x30
 8022fe6:	1c5c      	adds	r4, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 8022fe8:	2600      	movs	r6, #0
 8022fea:	2700      	movs	r7, #0
 8022fec:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 8022fee:	2100      	movs	r1, #0
 8022ff0:	4603      	mov	r3, r0
 8022ff2:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 8022ff4:	3201      	adds	r2, #1
 8022ff6:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 8022ff8:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8022ffc:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = i; j < N; j++) {
 8023000:	f103 0310 	add.w	r3, r3, #16
 8023004:	dcf6      	bgt.n	8022ff4 <cblas_zsyrk+0x324>
        for (i = 0; i < N; i++) {
 8023006:	3101      	adds	r1, #1
 8023008:	428d      	cmp	r5, r1
 802300a:	4420      	add	r0, r4
 802300c:	d1f0      	bne.n	8022ff0 <cblas_zsyrk+0x320>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 802300e:	ec51 0b1d 	vmov	r0, r1, d13
 8023012:	2200      	movs	r2, #0
 8023014:	2300      	movs	r3, #0
 8023016:	f006 f80f 	bl	8029038 <__aeabi_dcmpeq>
 802301a:	2800      	cmp	r0, #0
 802301c:	f47f af20 	bne.w	8022e60 <cblas_zsyrk+0x190>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8023020:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023022:	2b6f      	cmp	r3, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8023024:	9b03      	ldr	r3, [sp, #12]
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8023026:	f000 81d6 	beq.w	80233d6 <cblas_zsyrk+0x706>
      for (i = 0; i < N; i++) {
 802302a:	2b00      	cmp	r3, #0
 802302c:	dda9      	ble.n	8022f82 <cblas_zsyrk+0x2b2>
 802302e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8023030:	3301      	adds	r3, #1
 8023032:	011b      	lsls	r3, r3, #4
 8023034:	930a      	str	r3, [sp, #40]	; 0x28
 8023036:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023038:	9309      	str	r3, [sp, #36]	; 0x24
 802303a:	9b06      	ldr	r3, [sp, #24]
 802303c:	011b      	lsls	r3, r3, #4
 802303e:	9307      	str	r3, [sp, #28]
 8023040:	9b04      	ldr	r3, [sp, #16]
 8023042:	3308      	adds	r3, #8
 8023044:	9306      	str	r3, [sp, #24]
 8023046:	2300      	movs	r3, #0
 8023048:	9308      	str	r3, [sp, #32]
          BASE temp_real = 0.0;
 802304a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802304c:	9305      	str	r3, [sp, #20]
 802304e:	9b08      	ldr	r3, [sp, #32]
 8023050:	9302      	str	r3, [sp, #8]
          BASE temp_imag = 0.0;
 8023052:	ed9f 7b63 	vldr	d7, [pc, #396]	; 80231e0 <cblas_zsyrk+0x510>
          for (k = 0; k < K; k++) {
 8023056:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 8023058:	eeb0 ca47 	vmov.f32	s24, s14
 802305c:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < K; k++) {
 8023060:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 8023062:	eeb0 ba47 	vmov.f32	s22, s14
 8023066:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 802306a:	dd5c      	ble.n	8023126 <cblas_zsyrk+0x456>
 802306c:	9b04      	ldr	r3, [sp, #16]
 802306e:	9a02      	ldr	r2, [sp, #8]
 8023070:	f8dd b018 	ldr.w	fp, [sp, #24]
 8023074:	9d07      	ldr	r5, [sp, #28]
 8023076:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 802307a:	2300      	movs	r3, #0
 802307c:	461c      	mov	r4, r3
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 802307e:	ed1b 7b02 	vldr	d7, [fp, #-8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8023082:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8023086:	eeb0 aa47 	vmov.f32	s20, s14
 802308a:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 802308e:	ed9a 5b02 	vldr	d5, [sl, #8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8023092:	eeb0 9a46 	vmov.f32	s18, s12
 8023096:	eef0 9a66 	vmov.f32	s19, s13
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 802309a:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 802309e:	eeb0 8a45 	vmov.f32	s16, s10
 80230a2:	eef0 8a65 	vmov.f32	s17, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80230a6:	ec51 0b17 	vmov	r0, r1, d7
 80230aa:	f005 fd5d 	bl	8028b68 <__aeabi_dmul>
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 80230ae:	e9db 8900 	ldrd	r8, r9, [fp]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80230b2:	ec53 2b18 	vmov	r2, r3, d8
 80230b6:	4606      	mov	r6, r0
 80230b8:	460f      	mov	r7, r1
 80230ba:	4640      	mov	r0, r8
 80230bc:	4649      	mov	r1, r9
 80230be:	f005 fd53 	bl	8028b68 <__aeabi_dmul>
 80230c2:	4602      	mov	r2, r0
 80230c4:	460b      	mov	r3, r1
 80230c6:	4630      	mov	r0, r6
 80230c8:	4639      	mov	r1, r7
 80230ca:	f005 fb95 	bl	80287f8 <__aeabi_dsub>
 80230ce:	4602      	mov	r2, r0
 80230d0:	460b      	mov	r3, r1
 80230d2:	ec51 0b1b 	vmov	r0, r1, d11
 80230d6:	f005 fb91 	bl	80287fc <__adddf3>
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80230da:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80230de:	4606      	mov	r6, r0
 80230e0:	460f      	mov	r7, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80230e2:	ec51 0b1a 	vmov	r0, r1, d10
 80230e6:	f005 fd3f 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80230ea:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80230ee:	ec53 2b19 	vmov	r2, r3, d9
 80230f2:	4606      	mov	r6, r0
 80230f4:	460f      	mov	r7, r1
 80230f6:	4640      	mov	r0, r8
 80230f8:	4649      	mov	r1, r9
 80230fa:	f005 fd35 	bl	8028b68 <__aeabi_dmul>
 80230fe:	4602      	mov	r2, r0
 8023100:	460b      	mov	r3, r1
 8023102:	4630      	mov	r0, r6
 8023104:	4639      	mov	r1, r7
 8023106:	f005 fb79 	bl	80287fc <__adddf3>
 802310a:	460b      	mov	r3, r1
 802310c:	4602      	mov	r2, r0
 802310e:	ec51 0b1c 	vmov	r0, r1, d12
 8023112:	f005 fb73 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 8023116:	9b01      	ldr	r3, [sp, #4]
 8023118:	3401      	adds	r4, #1
 802311a:	42a3      	cmp	r3, r4
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 802311c:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < K; k++) {
 8023120:	44ab      	add	fp, r5
 8023122:	44aa      	add	sl, r5
 8023124:	d1ab      	bne.n	802307e <cblas_zsyrk+0x3ae>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8023126:	ec53 2b1b 	vmov	r2, r3, d11
 802312a:	ec51 0b1d 	vmov	r0, r1, d13
 802312e:	f005 fd1b 	bl	8028b68 <__aeabi_dmul>
 8023132:	ec5a 9b1c 	vmov	r9, sl, d12
 8023136:	ec58 7b1e 	vmov	r7, r8, d14
 802313a:	4604      	mov	r4, r0
 802313c:	460d      	mov	r5, r1
 802313e:	ee1c 2a10 	vmov	r2, s24
 8023142:	4653      	mov	r3, sl
 8023144:	ee1e 0a10 	vmov	r0, s28
 8023148:	4641      	mov	r1, r8
 802314a:	f005 fd0d 	bl	8028b68 <__aeabi_dmul>
 802314e:	4602      	mov	r2, r0
 8023150:	460b      	mov	r3, r1
 8023152:	4620      	mov	r0, r4
 8023154:	4629      	mov	r1, r5
 8023156:	f005 fb4f 	bl	80287f8 <__aeabi_dsub>
 802315a:	9e05      	ldr	r6, [sp, #20]
 802315c:	4602      	mov	r2, r0
 802315e:	460b      	mov	r3, r1
 8023160:	e9d6 0100 	ldrd	r0, r1, [r6]
 8023164:	f005 fb4a 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023168:	ee1c 2a10 	vmov	r2, s24
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 802316c:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023170:	4653      	mov	r3, sl
 8023172:	ec51 0b1d 	vmov	r0, r1, d13
 8023176:	f005 fcf7 	bl	8028b68 <__aeabi_dmul>
 802317a:	ec53 2b1b 	vmov	r2, r3, d11
 802317e:	4604      	mov	r4, r0
 8023180:	460d      	mov	r5, r1
 8023182:	ee1e 0a10 	vmov	r0, s28
 8023186:	4641      	mov	r1, r8
 8023188:	f005 fcee 	bl	8028b68 <__aeabi_dmul>
 802318c:	4602      	mov	r2, r0
 802318e:	460b      	mov	r3, r1
 8023190:	4620      	mov	r0, r4
 8023192:	4629      	mov	r1, r5
 8023194:	f005 fb32 	bl	80287fc <__adddf3>
 8023198:	4602      	mov	r2, r0
 802319a:	460b      	mov	r3, r1
 802319c:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 80231a0:	f005 fb2c 	bl	80287fc <__adddf3>
        for (j = i; j < N; j++) {
 80231a4:	9a02      	ldr	r2, [sp, #8]
 80231a6:	f106 0310 	add.w	r3, r6, #16
 80231aa:	9305      	str	r3, [sp, #20]
 80231ac:	9b03      	ldr	r3, [sp, #12]
 80231ae:	3201      	adds	r2, #1
 80231b0:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80231b2:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = i; j < N; j++) {
 80231b6:	9202      	str	r2, [sp, #8]
 80231b8:	f73f af4b 	bgt.w	8023052 <cblas_zsyrk+0x382>
      for (i = 0; i < N; i++) {
 80231bc:	e9dd 2109 	ldrd	r2, r1, [sp, #36]	; 0x24
 80231c0:	440a      	add	r2, r1
 80231c2:	9209      	str	r2, [sp, #36]	; 0x24
 80231c4:	9a06      	ldr	r2, [sp, #24]
 80231c6:	9b08      	ldr	r3, [sp, #32]
 80231c8:	3210      	adds	r2, #16
 80231ca:	9206      	str	r2, [sp, #24]
 80231cc:	9a03      	ldr	r2, [sp, #12]
 80231ce:	3301      	adds	r3, #1
 80231d0:	429a      	cmp	r2, r3
 80231d2:	9308      	str	r3, [sp, #32]
 80231d4:	f47f af39 	bne.w	802304a <cblas_zsyrk+0x37a>
 80231d8:	e6d3      	b.n	8022f82 <cblas_zsyrk+0x2b2>
 80231da:	bf00      	nop
 80231dc:	f3af 8000 	nop.w
	...
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80231e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80231ea:	2b6f      	cmp	r3, #111	; 0x6f
      for (i = 0; i < N; i++) {
 80231ec:	9b03      	ldr	r3, [sp, #12]
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80231ee:	f000 81d6 	beq.w	802359e <cblas_zsyrk+0x8ce>
      for (i = 0; i < N; i++) {
 80231f2:	2b00      	cmp	r3, #0
 80231f4:	f77f aec5 	ble.w	8022f82 <cblas_zsyrk+0x2b2>
 80231f8:	9b06      	ldr	r3, [sp, #24]
 80231fa:	011b      	lsls	r3, r3, #4
 80231fc:	9309      	str	r3, [sp, #36]	; 0x24
 80231fe:	9b04      	ldr	r3, [sp, #16]
 8023200:	3308      	adds	r3, #8
 8023202:	9308      	str	r3, [sp, #32]
 8023204:	2300      	movs	r3, #0
 8023206:	930a      	str	r3, [sp, #40]	; 0x28
 8023208:	2301      	movs	r3, #1
 802320a:	9307      	str	r3, [sp, #28]
 802320c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802320e:	3308      	adds	r3, #8
 8023210:	930e      	str	r3, [sp, #56]	; 0x38
 8023212:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023214:	4619      	mov	r1, r3
 8023216:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023218:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 802321c:	9206      	str	r2, [sp, #24]
 802321e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8023220:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8023224:	9305      	str	r3, [sp, #20]
        for (j = 0; j <= i; j++) {
 8023226:	2300      	movs	r3, #0
 8023228:	9302      	str	r3, [sp, #8]
          BASE temp_imag = 0.0;
 802322a:	ed1f 7b13 	vldr	d7, [pc, #-76]	; 80231e0 <cblas_zsyrk+0x510>
          for (k = 0; k < K; k++) {
 802322e:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 8023230:	eeb0 ca47 	vmov.f32	s24, s14
 8023234:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < K; k++) {
 8023238:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 802323a:	eeb0 ba47 	vmov.f32	s22, s14
 802323e:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 8023242:	dd5c      	ble.n	80232fe <cblas_zsyrk+0x62e>
 8023244:	9b04      	ldr	r3, [sp, #16]
 8023246:	9a02      	ldr	r2, [sp, #8]
 8023248:	f8dd b020 	ldr.w	fp, [sp, #32]
 802324c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 802324e:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 8023252:	2300      	movs	r3, #0
 8023254:	461c      	mov	r4, r3
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8023256:	ed1b 7b02 	vldr	d7, [fp, #-8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802325a:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 802325e:	eeb0 aa47 	vmov.f32	s20, s14
 8023262:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8023266:	ed9a 5b02 	vldr	d5, [sl, #8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802326a:	eeb0 9a46 	vmov.f32	s18, s12
 802326e:	eef0 9a66 	vmov.f32	s19, s13
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8023272:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8023276:	eeb0 8a45 	vmov.f32	s16, s10
 802327a:	eef0 8a65 	vmov.f32	s17, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 802327e:	ec51 0b17 	vmov	r0, r1, d7
 8023282:	f005 fc71 	bl	8028b68 <__aeabi_dmul>
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8023286:	e9db 8900 	ldrd	r8, r9, [fp]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 802328a:	ec53 2b18 	vmov	r2, r3, d8
 802328e:	4606      	mov	r6, r0
 8023290:	460f      	mov	r7, r1
 8023292:	4640      	mov	r0, r8
 8023294:	4649      	mov	r1, r9
 8023296:	f005 fc67 	bl	8028b68 <__aeabi_dmul>
 802329a:	4602      	mov	r2, r0
 802329c:	460b      	mov	r3, r1
 802329e:	4630      	mov	r0, r6
 80232a0:	4639      	mov	r1, r7
 80232a2:	f005 faa9 	bl	80287f8 <__aeabi_dsub>
 80232a6:	4602      	mov	r2, r0
 80232a8:	460b      	mov	r3, r1
 80232aa:	ec51 0b1b 	vmov	r0, r1, d11
 80232ae:	f005 faa5 	bl	80287fc <__adddf3>
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80232b2:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80232b6:	4606      	mov	r6, r0
 80232b8:	460f      	mov	r7, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80232ba:	ec51 0b1a 	vmov	r0, r1, d10
 80232be:	f005 fc53 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80232c2:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80232c6:	ec53 2b19 	vmov	r2, r3, d9
 80232ca:	4606      	mov	r6, r0
 80232cc:	460f      	mov	r7, r1
 80232ce:	4640      	mov	r0, r8
 80232d0:	4649      	mov	r1, r9
 80232d2:	f005 fc49 	bl	8028b68 <__aeabi_dmul>
 80232d6:	4602      	mov	r2, r0
 80232d8:	460b      	mov	r3, r1
 80232da:	4630      	mov	r0, r6
 80232dc:	4639      	mov	r1, r7
 80232de:	f005 fa8d 	bl	80287fc <__adddf3>
 80232e2:	460b      	mov	r3, r1
 80232e4:	4602      	mov	r2, r0
 80232e6:	ec51 0b1c 	vmov	r0, r1, d12
 80232ea:	f005 fa87 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 80232ee:	9b01      	ldr	r3, [sp, #4]
 80232f0:	3401      	adds	r4, #1
 80232f2:	42a3      	cmp	r3, r4
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80232f4:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < K; k++) {
 80232f8:	44ab      	add	fp, r5
 80232fa:	44aa      	add	sl, r5
 80232fc:	d1ab      	bne.n	8023256 <cblas_zsyrk+0x586>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80232fe:	ec53 2b1b 	vmov	r2, r3, d11
 8023302:	ec51 0b1d 	vmov	r0, r1, d13
 8023306:	f005 fc2f 	bl	8028b68 <__aeabi_dmul>
 802330a:	ec5a 9b1c 	vmov	r9, sl, d12
 802330e:	ec58 7b1e 	vmov	r7, r8, d14
 8023312:	4604      	mov	r4, r0
 8023314:	460d      	mov	r5, r1
 8023316:	ee1c 2a10 	vmov	r2, s24
 802331a:	4653      	mov	r3, sl
 802331c:	ee1e 0a10 	vmov	r0, s28
 8023320:	4641      	mov	r1, r8
 8023322:	f005 fc21 	bl	8028b68 <__aeabi_dmul>
 8023326:	4602      	mov	r2, r0
 8023328:	460b      	mov	r3, r1
 802332a:	4620      	mov	r0, r4
 802332c:	4629      	mov	r1, r5
 802332e:	f005 fa63 	bl	80287f8 <__aeabi_dsub>
 8023332:	9e05      	ldr	r6, [sp, #20]
 8023334:	4602      	mov	r2, r0
 8023336:	460b      	mov	r3, r1
 8023338:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 802333c:	f005 fa5e 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023340:	ee1c 2a10 	vmov	r2, s24
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8023344:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023348:	4653      	mov	r3, sl
 802334a:	ec51 0b1d 	vmov	r0, r1, d13
 802334e:	f005 fc0b 	bl	8028b68 <__aeabi_dmul>
 8023352:	ec53 2b1b 	vmov	r2, r3, d11
 8023356:	4604      	mov	r4, r0
 8023358:	460d      	mov	r5, r1
 802335a:	ee1e 0a10 	vmov	r0, s28
 802335e:	4641      	mov	r1, r8
 8023360:	f005 fc02 	bl	8028b68 <__aeabi_dmul>
 8023364:	4602      	mov	r2, r0
 8023366:	460b      	mov	r3, r1
 8023368:	4620      	mov	r0, r4
 802336a:	4629      	mov	r1, r5
 802336c:	f005 fa46 	bl	80287fc <__adddf3>
 8023370:	9c06      	ldr	r4, [sp, #24]
 8023372:	4602      	mov	r2, r0
 8023374:	460b      	mov	r3, r1
 8023376:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 802337a:	f005 fa3f 	bl	80287fc <__adddf3>
 802337e:	f106 0310 	add.w	r3, r6, #16
        for (j = 0; j <= i; j++) {
 8023382:	9a02      	ldr	r2, [sp, #8]
 8023384:	9305      	str	r3, [sp, #20]
 8023386:	f104 0310 	add.w	r3, r4, #16
 802338a:	9306      	str	r3, [sp, #24]
 802338c:	9b07      	ldr	r3, [sp, #28]
 802338e:	3201      	adds	r2, #1
 8023390:	429a      	cmp	r2, r3
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023392:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = 0; j <= i; j++) {
 8023396:	9202      	str	r2, [sp, #8]
 8023398:	f47f af47 	bne.w	802322a <cblas_zsyrk+0x55a>
      for (i = 0; i < N; i++) {
 802339c:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
 80233a0:	4413      	add	r3, r2
 80233a2:	9903      	ldr	r1, [sp, #12]
 80233a4:	9a07      	ldr	r2, [sp, #28]
 80233a6:	930a      	str	r3, [sp, #40]	; 0x28
 80233a8:	9b08      	ldr	r3, [sp, #32]
 80233aa:	4291      	cmp	r1, r2
 80233ac:	f103 0310 	add.w	r3, r3, #16
 80233b0:	9308      	str	r3, [sp, #32]
 80233b2:	f102 0301 	add.w	r3, r2, #1
 80233b6:	f43f ade4 	beq.w	8022f82 <cblas_zsyrk+0x2b2>
 80233ba:	9307      	str	r3, [sp, #28]
 80233bc:	e729      	b.n	8023212 <cblas_zsyrk+0x542>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80233be:	ec51 0b1d 	vmov	r0, r1, d13
 80233c2:	2200      	movs	r2, #0
 80233c4:	2300      	movs	r3, #0
 80233c6:	f005 fe37 	bl	8029038 <__aeabi_dcmpeq>
 80233ca:	2800      	cmp	r0, #0
 80233cc:	f43f ad51 	beq.w	8022e72 <cblas_zsyrk+0x1a2>
 80233d0:	e546      	b.n	8022e60 <cblas_zsyrk+0x190>
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 80233d2:	200b      	movs	r0, #11
 80233d4:	e4cb      	b.n	8022d6e <cblas_zsyrk+0x9e>
      for (i = 0; i < N; i++) {
 80233d6:	2b00      	cmp	r3, #0
 80233d8:	f77f add3 	ble.w	8022f82 <cblas_zsyrk+0x2b2>
 80233dc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80233de:	9901      	ldr	r1, [sp, #4]
 80233e0:	3301      	adds	r3, #1
 80233e2:	011b      	lsls	r3, r3, #4
 80233e4:	930e      	str	r3, [sp, #56]	; 0x38
 80233e6:	9b06      	ldr	r3, [sp, #24]
 80233e8:	011b      	lsls	r3, r3, #4
 80233ea:	930d      	str	r3, [sp, #52]	; 0x34
 80233ec:	9b04      	ldr	r3, [sp, #16]
 80233ee:	9309      	str	r3, [sp, #36]	; 0x24
 80233f0:	2200      	movs	r2, #0
 80233f2:	920b      	str	r2, [sp, #44]	; 0x2c
 80233f4:	920a      	str	r2, [sp, #40]	; 0x28
 80233f6:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 80233fa:	9202      	str	r2, [sp, #8]
          BASE temp_real = 0.0;
 80233fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80233fe:	9305      	str	r3, [sp, #20]
 8023400:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023402:	9308      	str	r3, [sp, #32]
 8023404:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023406:	9307      	str	r3, [sp, #28]
          BASE temp_imag = 0.0;
 8023408:	ed1f 7b8b 	vldr	d7, [pc, #-556]	; 80231e0 <cblas_zsyrk+0x510>
          for (k = 0; k < K; k++) {
 802340c:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 802340e:	eeb0 aa47 	vmov.f32	s20, s14
 8023412:	eef0 aa67 	vmov.f32	s21, s15
          for (k = 0; k < K; k++) {
 8023416:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 8023418:	eeb0 ba47 	vmov.f32	s22, s14
 802341c:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 8023420:	dd56      	ble.n	80234d0 <cblas_zsyrk+0x800>
 8023422:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 8023426:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 802342a:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802342e:	ed9b 7b00 	vldr	d7, [fp]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023432:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8023436:	eeb0 9a47 	vmov.f32	s18, s14
 802343a:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802343e:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023442:	eeb0 8a46 	vmov.f32	s16, s12
 8023446:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802344a:	ec51 0b17 	vmov	r0, r1, d7
 802344e:	f005 fb8b 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8023452:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8023456:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802345a:	4604      	mov	r4, r0
 802345c:	460d      	mov	r5, r1
 802345e:	4642      	mov	r2, r8
 8023460:	464b      	mov	r3, r9
 8023462:	4630      	mov	r0, r6
 8023464:	4639      	mov	r1, r7
 8023466:	f005 fb7f 	bl	8028b68 <__aeabi_dmul>
 802346a:	4602      	mov	r2, r0
 802346c:	460b      	mov	r3, r1
 802346e:	4620      	mov	r0, r4
 8023470:	4629      	mov	r1, r5
 8023472:	f005 f9c1 	bl	80287f8 <__aeabi_dsub>
 8023476:	4602      	mov	r2, r0
 8023478:	460b      	mov	r3, r1
 802347a:	ec51 0b1b 	vmov	r0, r1, d11
 802347e:	f005 f9bd 	bl	80287fc <__adddf3>
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8023482:	4642      	mov	r2, r8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8023484:	4604      	mov	r4, r0
 8023486:	460d      	mov	r5, r1
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8023488:	464b      	mov	r3, r9
 802348a:	ec51 0b19 	vmov	r0, r1, d9
 802348e:	f005 fb6b 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8023492:	ec45 4b1b 	vmov	d11, r4, r5
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8023496:	ec53 2b18 	vmov	r2, r3, d8
 802349a:	4604      	mov	r4, r0
 802349c:	460d      	mov	r5, r1
 802349e:	4630      	mov	r0, r6
 80234a0:	4639      	mov	r1, r7
 80234a2:	f005 fb61 	bl	8028b68 <__aeabi_dmul>
 80234a6:	4602      	mov	r2, r0
 80234a8:	460b      	mov	r3, r1
 80234aa:	4620      	mov	r0, r4
 80234ac:	4629      	mov	r1, r5
 80234ae:	f005 f9a5 	bl	80287fc <__adddf3>
 80234b2:	460b      	mov	r3, r1
 80234b4:	4602      	mov	r2, r0
 80234b6:	ec51 0b1a 	vmov	r0, r1, d10
 80234ba:	f005 f99f 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 80234be:	9b02      	ldr	r3, [sp, #8]
 80234c0:	f10b 0b10 	add.w	fp, fp, #16
 80234c4:	455b      	cmp	r3, fp
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80234c6:	ec41 0b1a 	vmov	d10, r0, r1
          for (k = 0; k < K; k++) {
 80234ca:	f10a 0a10 	add.w	sl, sl, #16
 80234ce:	d1ae      	bne.n	802342e <cblas_zsyrk+0x75e>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80234d0:	ec53 2b1d 	vmov	r2, r3, d13
 80234d4:	ec51 0b1b 	vmov	r0, r1, d11
 80234d8:	f005 fb46 	bl	8028b68 <__aeabi_dmul>
 80234dc:	ec5a 9b1a 	vmov	r9, sl, d10
 80234e0:	ec58 7b1e 	vmov	r7, r8, d14
 80234e4:	4604      	mov	r4, r0
 80234e6:	460d      	mov	r5, r1
 80234e8:	ee1a 2a10 	vmov	r2, s20
 80234ec:	4653      	mov	r3, sl
 80234ee:	ee1e 0a10 	vmov	r0, s28
 80234f2:	4641      	mov	r1, r8
 80234f4:	f005 fb38 	bl	8028b68 <__aeabi_dmul>
 80234f8:	4602      	mov	r2, r0
 80234fa:	460b      	mov	r3, r1
 80234fc:	4620      	mov	r0, r4
 80234fe:	4629      	mov	r1, r5
 8023500:	f005 f97a 	bl	80287f8 <__aeabi_dsub>
 8023504:	9e08      	ldr	r6, [sp, #32]
 8023506:	4602      	mov	r2, r0
 8023508:	460b      	mov	r3, r1
 802350a:	e9d6 0100 	ldrd	r0, r1, [r6]
 802350e:	f005 f975 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023512:	ee1a 2a10 	vmov	r2, s20
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8023516:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 802351a:	4653      	mov	r3, sl
 802351c:	ec51 0b1d 	vmov	r0, r1, d13
 8023520:	f005 fb22 	bl	8028b68 <__aeabi_dmul>
 8023524:	ee1e 2a10 	vmov	r2, s28
 8023528:	460d      	mov	r5, r1
 802352a:	4643      	mov	r3, r8
 802352c:	4604      	mov	r4, r0
 802352e:	ec51 0b1b 	vmov	r0, r1, d11
 8023532:	f005 fb19 	bl	8028b68 <__aeabi_dmul>
 8023536:	4602      	mov	r2, r0
 8023538:	460b      	mov	r3, r1
 802353a:	4620      	mov	r0, r4
 802353c:	4629      	mov	r1, r5
 802353e:	f005 f95d 	bl	80287fc <__adddf3>
 8023542:	4602      	mov	r2, r0
 8023544:	460b      	mov	r3, r1
 8023546:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 802354a:	f005 f957 	bl	80287fc <__adddf3>
 802354e:	e9dd 3505 	ldrd	r3, r5, [sp, #20]
 8023552:	442b      	add	r3, r5
        for (j = i; j < N; j++) {
 8023554:	9a07      	ldr	r2, [sp, #28]
 8023556:	9305      	str	r3, [sp, #20]
 8023558:	f106 0310 	add.w	r3, r6, #16
 802355c:	9308      	str	r3, [sp, #32]
 802355e:	9b03      	ldr	r3, [sp, #12]
 8023560:	3201      	adds	r2, #1
 8023562:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8023564:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = i; j < N; j++) {
 8023568:	9207      	str	r2, [sp, #28]
 802356a:	f73f af4d 	bgt.w	8023408 <cblas_zsyrk+0x738>
      for (i = 0; i < N; i++) {
 802356e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023570:	990e      	ldr	r1, [sp, #56]	; 0x38
 8023572:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023574:	440a      	add	r2, r1
 8023576:	920c      	str	r2, [sp, #48]	; 0x30
 8023578:	9906      	ldr	r1, [sp, #24]
 802357a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802357c:	440a      	add	r2, r1
 802357e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8023580:	920b      	str	r2, [sp, #44]	; 0x2c
 8023582:	4608      	mov	r0, r1
 8023584:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8023586:	9902      	ldr	r1, [sp, #8]
 8023588:	4410      	add	r0, r2
 802358a:	4411      	add	r1, r2
 802358c:	9a03      	ldr	r2, [sp, #12]
 802358e:	9009      	str	r0, [sp, #36]	; 0x24
 8023590:	3301      	adds	r3, #1
 8023592:	429a      	cmp	r2, r3
 8023594:	930a      	str	r3, [sp, #40]	; 0x28
 8023596:	9102      	str	r1, [sp, #8]
 8023598:	f47f af30 	bne.w	80233fc <cblas_zsyrk+0x72c>
 802359c:	e4f1      	b.n	8022f82 <cblas_zsyrk+0x2b2>
      for (i = 0; i < N; i++) {
 802359e:	2b00      	cmp	r3, #0
 80235a0:	f77f acef 	ble.w	8022f82 <cblas_zsyrk+0x2b2>
 80235a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80235a6:	9801      	ldr	r0, [sp, #4]
 80235a8:	3301      	adds	r3, #1
 80235aa:	011b      	lsls	r3, r3, #4
 80235ac:	9311      	str	r3, [sp, #68]	; 0x44
 80235ae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80235b0:	2200      	movs	r2, #0
 80235b2:	920d      	str	r2, [sp, #52]	; 0x34
 80235b4:	920f      	str	r2, [sp, #60]	; 0x3c
 80235b6:	f103 0210 	add.w	r2, r3, #16
 80235ba:	9209      	str	r2, [sp, #36]	; 0x24
 80235bc:	9a06      	ldr	r2, [sp, #24]
 80235be:	0112      	lsls	r2, r2, #4
 80235c0:	9210      	str	r2, [sp, #64]	; 0x40
 80235c2:	9a04      	ldr	r2, [sp, #16]
 80235c4:	920a      	str	r2, [sp, #40]	; 0x28
 80235c6:	eb02 1100 	add.w	r1, r2, r0, lsl #4
 80235ca:	3308      	adds	r3, #8
 80235cc:	9102      	str	r1, [sp, #8]
 80235ce:	930e      	str	r3, [sp, #56]	; 0x38
 80235d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80235d2:	4619      	mov	r1, r3
 80235d4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80235d6:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 80235da:	9208      	str	r2, [sp, #32]
 80235dc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80235de:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 80235e2:	9307      	str	r3, [sp, #28]
          BASE temp_real = 0.0;
 80235e4:	2300      	movs	r3, #0
 80235e6:	9305      	str	r3, [sp, #20]
          BASE temp_imag = 0.0;
 80235e8:	ed9f 7b91 	vldr	d7, [pc, #580]	; 8023830 <cblas_zsyrk+0xb60>
          for (k = 0; k < K; k++) {
 80235ec:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 80235ee:	eeb0 ba47 	vmov.f32	s22, s14
 80235f2:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 80235f6:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 80235f8:	eeb0 aa47 	vmov.f32	s20, s14
 80235fc:	eef0 aa67 	vmov.f32	s21, s15
          for (k = 0; k < K; k++) {
 8023600:	dd56      	ble.n	80236b0 <cblas_zsyrk+0x9e0>
 8023602:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 8023606:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 802360a:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802360e:	ed9b 7b00 	vldr	d7, [fp]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023612:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8023616:	eeb0 9a47 	vmov.f32	s18, s14
 802361a:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802361e:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023622:	eeb0 8a46 	vmov.f32	s16, s12
 8023626:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802362a:	ec51 0b17 	vmov	r0, r1, d7
 802362e:	f005 fa9b 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8023632:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8023636:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802363a:	4604      	mov	r4, r0
 802363c:	460d      	mov	r5, r1
 802363e:	4642      	mov	r2, r8
 8023640:	464b      	mov	r3, r9
 8023642:	4630      	mov	r0, r6
 8023644:	4639      	mov	r1, r7
 8023646:	f005 fa8f 	bl	8028b68 <__aeabi_dmul>
 802364a:	4602      	mov	r2, r0
 802364c:	460b      	mov	r3, r1
 802364e:	4620      	mov	r0, r4
 8023650:	4629      	mov	r1, r5
 8023652:	f005 f8d1 	bl	80287f8 <__aeabi_dsub>
 8023656:	4602      	mov	r2, r0
 8023658:	460b      	mov	r3, r1
 802365a:	ec51 0b1a 	vmov	r0, r1, d10
 802365e:	f005 f8cd 	bl	80287fc <__adddf3>
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8023662:	4642      	mov	r2, r8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8023664:	4604      	mov	r4, r0
 8023666:	460d      	mov	r5, r1
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8023668:	464b      	mov	r3, r9
 802366a:	ec51 0b19 	vmov	r0, r1, d9
 802366e:	f005 fa7b 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8023672:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8023676:	ec53 2b18 	vmov	r2, r3, d8
 802367a:	4604      	mov	r4, r0
 802367c:	460d      	mov	r5, r1
 802367e:	4630      	mov	r0, r6
 8023680:	4639      	mov	r1, r7
 8023682:	f005 fa71 	bl	8028b68 <__aeabi_dmul>
 8023686:	4602      	mov	r2, r0
 8023688:	460b      	mov	r3, r1
 802368a:	4620      	mov	r0, r4
 802368c:	4629      	mov	r1, r5
 802368e:	f005 f8b5 	bl	80287fc <__adddf3>
 8023692:	460b      	mov	r3, r1
 8023694:	4602      	mov	r2, r0
 8023696:	ec51 0b1b 	vmov	r0, r1, d11
 802369a:	f005 f8af 	bl	80287fc <__adddf3>
          for (k = 0; k < K; k++) {
 802369e:	9b02      	ldr	r3, [sp, #8]
 80236a0:	f10b 0b10 	add.w	fp, fp, #16
 80236a4:	455b      	cmp	r3, fp
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80236a6:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < K; k++) {
 80236aa:	f10a 0a10 	add.w	sl, sl, #16
 80236ae:	d1ae      	bne.n	802360e <cblas_zsyrk+0x93e>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80236b0:	ec53 2b1a 	vmov	r2, r3, d10
 80236b4:	ec51 0b1d 	vmov	r0, r1, d13
 80236b8:	f005 fa56 	bl	8028b68 <__aeabi_dmul>
 80236bc:	ec5a 9b1b 	vmov	r9, sl, d11
 80236c0:	ec58 7b1e 	vmov	r7, r8, d14
 80236c4:	4604      	mov	r4, r0
 80236c6:	460d      	mov	r5, r1
 80236c8:	ee1b 2a10 	vmov	r2, s22
 80236cc:	4653      	mov	r3, sl
 80236ce:	ee1e 0a10 	vmov	r0, s28
 80236d2:	4641      	mov	r1, r8
 80236d4:	f005 fa48 	bl	8028b68 <__aeabi_dmul>
 80236d8:	4602      	mov	r2, r0
 80236da:	460b      	mov	r3, r1
 80236dc:	4620      	mov	r0, r4
 80236de:	4629      	mov	r1, r5
 80236e0:	f005 f88a 	bl	80287f8 <__aeabi_dsub>
 80236e4:	9e07      	ldr	r6, [sp, #28]
 80236e6:	4602      	mov	r2, r0
 80236e8:	460b      	mov	r3, r1
 80236ea:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 80236ee:	f005 f885 	bl	80287fc <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80236f2:	ee1b 2a10 	vmov	r2, s22
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80236f6:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80236fa:	4653      	mov	r3, sl
 80236fc:	ec51 0b1d 	vmov	r0, r1, d13
 8023700:	f005 fa32 	bl	8028b68 <__aeabi_dmul>
 8023704:	ec53 2b1a 	vmov	r2, r3, d10
 8023708:	4604      	mov	r4, r0
 802370a:	460d      	mov	r5, r1
 802370c:	ee1e 0a10 	vmov	r0, s28
 8023710:	4641      	mov	r1, r8
 8023712:	f005 fa29 	bl	8028b68 <__aeabi_dmul>
 8023716:	4602      	mov	r2, r0
 8023718:	460b      	mov	r3, r1
 802371a:	4620      	mov	r0, r4
 802371c:	4629      	mov	r1, r5
 802371e:	f005 f86d 	bl	80287fc <__adddf3>
 8023722:	9c08      	ldr	r4, [sp, #32]
 8023724:	4602      	mov	r2, r0
 8023726:	460b      	mov	r3, r1
 8023728:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 802372c:	f005 f866 	bl	80287fc <__adddf3>
 8023730:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = 0; j <= i; j++) {
 8023734:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 8023738:	440a      	add	r2, r1
 802373a:	9205      	str	r2, [sp, #20]
 802373c:	f106 0210 	add.w	r2, r6, #16
 8023740:	9207      	str	r2, [sp, #28]
 8023742:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8023744:	f104 0310 	add.w	r3, r4, #16
 8023748:	429a      	cmp	r2, r3
 802374a:	9308      	str	r3, [sp, #32]
 802374c:	f47f af4c 	bne.w	80235e8 <cblas_zsyrk+0x918>
      for (i = 0; i < N; i++) {
 8023750:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8023752:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8023754:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8023756:	440a      	add	r2, r1
 8023758:	920d      	str	r2, [sp, #52]	; 0x34
 802375a:	9911      	ldr	r1, [sp, #68]	; 0x44
 802375c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802375e:	440a      	add	r2, r1
 8023760:	990a      	ldr	r1, [sp, #40]	; 0x28
 8023762:	9209      	str	r2, [sp, #36]	; 0x24
 8023764:	4608      	mov	r0, r1
 8023766:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023768:	9902      	ldr	r1, [sp, #8]
 802376a:	4410      	add	r0, r2
 802376c:	4411      	add	r1, r2
 802376e:	9a03      	ldr	r2, [sp, #12]
 8023770:	900a      	str	r0, [sp, #40]	; 0x28
 8023772:	3301      	adds	r3, #1
 8023774:	429a      	cmp	r2, r3
 8023776:	930f      	str	r3, [sp, #60]	; 0x3c
 8023778:	9102      	str	r1, [sp, #8]
 802377a:	f47f af29 	bne.w	80235d0 <cblas_zsyrk+0x900>
 802377e:	e400      	b.n	8022f82 <cblas_zsyrk+0x2b2>
        for (i = 0; i < N; i++) {
 8023780:	2b00      	cmp	r3, #0
 8023782:	f77f ac44 	ble.w	802300e <cblas_zsyrk+0x33e>
 8023786:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8023788:	3301      	adds	r3, #1
 802378a:	011b      	lsls	r3, r3, #4
 802378c:	9307      	str	r3, [sp, #28]
 802378e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023790:	9305      	str	r3, [sp, #20]
 8023792:	2300      	movs	r3, #0
 8023794:	9302      	str	r3, [sp, #8]
 8023796:	f8dd a014 	ldr.w	sl, [sp, #20]
 802379a:	f8dd b008 	ldr.w	fp, [sp, #8]
 802379e:	ec59 8b1b 	vmov	r8, r9, d11
            const BASE Cij_real = REAL(C, ldc * i + j);
 80237a2:	e9da 4500 	ldrd	r4, r5, [sl]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80237a6:	4640      	mov	r0, r8
 80237a8:	4622      	mov	r2, r4
 80237aa:	462b      	mov	r3, r5
 80237ac:	4649      	mov	r1, r9
 80237ae:	f005 f9db 	bl	8028b68 <__aeabi_dmul>
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 80237b2:	e9da 6702 	ldrd	r6, r7, [sl, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80237b6:	ec41 0b19 	vmov	d9, r0, r1
 80237ba:	4632      	mov	r2, r6
 80237bc:	463b      	mov	r3, r7
 80237be:	ec51 0b1a 	vmov	r0, r1, d10
 80237c2:	f005 f9d1 	bl	8028b68 <__aeabi_dmul>
 80237c6:	4602      	mov	r2, r0
 80237c8:	460b      	mov	r3, r1
 80237ca:	ec51 0b19 	vmov	r0, r1, d9
 80237ce:	f005 f813 	bl	80287f8 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80237d2:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80237d4:	e9ca 0100 	strd	r0, r1, [sl]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80237d8:	463b      	mov	r3, r7
 80237da:	4640      	mov	r0, r8
 80237dc:	4649      	mov	r1, r9
 80237de:	f005 f9c3 	bl	8028b68 <__aeabi_dmul>
 80237e2:	4622      	mov	r2, r4
 80237e4:	462b      	mov	r3, r5
 80237e6:	4604      	mov	r4, r0
 80237e8:	460d      	mov	r5, r1
 80237ea:	ec51 0b1a 	vmov	r0, r1, d10
 80237ee:	f005 f9bb 	bl	8028b68 <__aeabi_dmul>
 80237f2:	460b      	mov	r3, r1
 80237f4:	4602      	mov	r2, r0
 80237f6:	4629      	mov	r1, r5
 80237f8:	4620      	mov	r0, r4
 80237fa:	f004 ffff 	bl	80287fc <__adddf3>
          for (j = i; j < N; j++) {
 80237fe:	9b03      	ldr	r3, [sp, #12]
 8023800:	f10b 0b01 	add.w	fp, fp, #1
 8023804:	455b      	cmp	r3, fp
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8023806:	e9ca 0102 	strd	r0, r1, [sl, #8]
          for (j = i; j < N; j++) {
 802380a:	f10a 0a10 	add.w	sl, sl, #16
 802380e:	dcc8      	bgt.n	80237a2 <cblas_zsyrk+0xad2>
        for (i = 0; i < N; i++) {
 8023810:	9a05      	ldr	r2, [sp, #20]
 8023812:	9907      	ldr	r1, [sp, #28]
 8023814:	9b02      	ldr	r3, [sp, #8]
 8023816:	440a      	add	r2, r1
 8023818:	9205      	str	r2, [sp, #20]
 802381a:	9a03      	ldr	r2, [sp, #12]
 802381c:	3301      	adds	r3, #1
 802381e:	429a      	cmp	r2, r3
 8023820:	9302      	str	r3, [sp, #8]
 8023822:	d1b8      	bne.n	8023796 <cblas_zsyrk+0xac6>
 8023824:	f7ff bbf3 	b.w	802300e <cblas_zsyrk+0x33e>
 8023828:	9b01      	ldr	r3, [sp, #4]
 802382a:	f7ff ba90 	b.w	8022d4e <cblas_zsyrk+0x7e>
 802382e:	bf00      	nop
	...

08023838 <cblas_ztrmm>:
cblas_ztrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8023838:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802383c:	ed2d 8b10 	vpush	{d8-d15}
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8023840:	2b71      	cmp	r3, #113	; 0x71
 8023842:	b097      	sub	sp, #92	; 0x5c
 8023844:	461e      	mov	r6, r3
 8023846:	bf0c      	ite	eq
 8023848:	f04f 33ff 	moveq.w	r3, #4294967295
 802384c:	2301      	movne	r3, #1
 802384e:	ee0d 3a10 	vmov	s26, r3
 8023852:	f89d 30c0 	ldrb.w	r3, [sp, #192]	; 0xc0
 8023856:	9302      	str	r3, [sp, #8]
 8023858:	9b31      	ldr	r3, [sp, #196]	; 0xc4
 802385a:	9306      	str	r3, [sp, #24]
 802385c:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 802385e:	9307      	str	r3, [sp, #28]
 8023860:	e9dd 8333 	ldrd	r8, r3, [sp, #204]	; 0xcc
 8023864:	9310      	str	r3, [sp, #64]	; 0x40
 8023866:	e9dd 4335 	ldrd	r4, r3, [sp, #212]	; 0xd4
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 802386a:	298d      	cmp	r1, #141	; 0x8d
 802386c:	930f      	str	r3, [sp, #60]	; 0x3c
 802386e:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8023870:	930c      	str	r3, [sp, #48]	; 0x30
 8023872:	460d      	mov	r5, r1
 8023874:	4617      	mov	r7, r2
 8023876:	d06d      	beq.n	8023954 <cblas_ztrmm+0x11c>
 8023878:	298e      	cmp	r1, #142	; 0x8e
 802387a:	f000 8505 	beq.w	8024288 <cblas_ztrmm+0xa50>
 802387e:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8023882:	2302      	movs	r3, #2
 8023884:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 8023888:	2a01      	cmp	r2, #1
 802388a:	9a02      	ldr	r2, [sp, #8]
 802388c:	f1a6 016f 	sub.w	r1, r6, #111	; 0x6f
 8023890:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8023894:	bf88      	it	hi
 8023896:	2303      	movhi	r3, #3
 8023898:	b2d2      	uxtb	r2, r2
 802389a:	2902      	cmp	r1, #2
 802389c:	bf88      	it	hi
 802389e:	2304      	movhi	r3, #4
 80238a0:	2a02      	cmp	r2, #2
 80238a2:	9a06      	ldr	r2, [sp, #24]
 80238a4:	bf28      	it	cs
 80238a6:	2305      	movcs	r3, #5
 80238a8:	2a00      	cmp	r2, #0
 80238aa:	9a07      	ldr	r2, [sp, #28]
 80238ac:	bfb8      	it	lt
 80238ae:	2306      	movlt	r3, #6
 80238b0:	2a00      	cmp	r2, #0
 80238b2:	bfb8      	it	lt
 80238b4:	2307      	movlt	r3, #7
 80238b6:	f1bc 0f01 	cmp.w	ip, #1
 80238ba:	bfb8      	it	lt
 80238bc:	f04f 0c01 	movlt.w	ip, #1
 80238c0:	45a4      	cmp	ip, r4
 80238c2:	dd3a      	ble.n	802393a <cblas_ztrmm+0x102>
 80238c4:	2865      	cmp	r0, #101	; 0x65
 80238c6:	f000 8156 	beq.w	8023b76 <cblas_ztrmm+0x33e>
 80238ca:	9b06      	ldr	r3, [sp, #24]
 80238cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80238ce:	2b01      	cmp	r3, #1
 80238d0:	bfb8      	it	lt
 80238d2:	2301      	movlt	r3, #1
 80238d4:	4293      	cmp	r3, r2
 80238d6:	bfcc      	ite	gt
 80238d8:	230c      	movgt	r3, #12
 80238da:	230a      	movle	r3, #10
 80238dc:	4ab8      	ldr	r2, [pc, #736]	; (8023bc0 <cblas_ztrmm+0x388>)
 80238de:	49b9      	ldr	r1, [pc, #740]	; (8023bc4 <cblas_ztrmm+0x38c>)
 80238e0:	4618      	mov	r0, r3
 80238e2:	f004 ff11 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 80238e6:	ed98 7b00 	vldr	d7, [r8]
 80238ea:	eeb0 fa47 	vmov.f32	s30, s14
 80238ee:	eef0 fa67 	vmov.f32	s31, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80238f2:	ed98 7b02 	vldr	d7, [r8, #8]
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 80238f6:	2d8d      	cmp	r5, #141	; 0x8d
 80238f8:	bf0c      	ite	eq
 80238fa:	258e      	moveq	r5, #142	; 0x8e
 80238fc:	258d      	movne	r5, #141	; 0x8d
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80238fe:	ed8d 7b04 	vstr	d7, [sp, #16]
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8023902:	2f79      	cmp	r7, #121	; 0x79
 8023904:	bf0c      	ite	eq
 8023906:	277a      	moveq	r7, #122	; 0x7a
 8023908:	2779      	movne	r7, #121	; 0x79
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 802390a:	2e6f      	cmp	r6, #111	; 0x6f
 802390c:	bf0c      	ite	eq
 802390e:	266f      	moveq	r6, #111	; 0x6f
 8023910:	2670      	movne	r6, #112	; 0x70
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8023912:	2d8d      	cmp	r5, #141	; 0x8d
 8023914:	d027      	beq.n	8023966 <cblas_ztrmm+0x12e>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8023916:	2d8e      	cmp	r5, #142	; 0x8e
 8023918:	d105      	bne.n	8023926 <cblas_ztrmm+0xee>
 802391a:	2f79      	cmp	r7, #121	; 0x79
 802391c:	f000 8156 	beq.w	8023bcc <cblas_ztrmm+0x394>
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8023920:	2f7a      	cmp	r7, #122	; 0x7a
 8023922:	f000 8284 	beq.w	8023e2e <cblas_ztrmm+0x5f6>
      BLAS_ERROR("unrecognized operation");
 8023926:	4aa8      	ldr	r2, [pc, #672]	; (8023bc8 <cblas_ztrmm+0x390>)
 8023928:	49a6      	ldr	r1, [pc, #664]	; (8023bc4 <cblas_ztrmm+0x38c>)
 802392a:	2000      	movs	r0, #0
#define BASE double
#include "source_trmm_c.h"
#undef BASE
}
 802392c:	b017      	add	sp, #92	; 0x5c
 802392e:	ecbd 8b10 	vpop	{d8-d15}
 8023932:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023936:	f004 bee7 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 802393a:	2865      	cmp	r0, #101	; 0x65
 802393c:	f000 8385 	beq.w	802404a <cblas_ztrmm+0x812>
 8023940:	9a06      	ldr	r2, [sp, #24]
 8023942:	990c      	ldr	r1, [sp, #48]	; 0x30
 8023944:	2a01      	cmp	r2, #1
 8023946:	bfb8      	it	lt
 8023948:	2201      	movlt	r2, #1
 802394a:	428a      	cmp	r2, r1
 802394c:	f340 8134 	ble.w	8023bb8 <cblas_ztrmm+0x380>
 8023950:	230c      	movs	r3, #12
 8023952:	e7c3      	b.n	80238dc <cblas_ztrmm+0xa4>
 8023954:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8023958:	2b01      	cmp	r3, #1
 802395a:	f8dd c018 	ldr.w	ip, [sp, #24]
 802395e:	bf94      	ite	ls
 8023960:	2300      	movls	r3, #0
 8023962:	2301      	movhi	r3, #1
 8023964:	e78e      	b.n	8023884 <cblas_ztrmm+0x4c>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8023966:	2f79      	cmp	r7, #121	; 0x79
 8023968:	f000 837e 	beq.w	8024068 <cblas_ztrmm+0x830>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 802396c:	2f7a      	cmp	r7, #122	; 0x7a
 802396e:	d1da      	bne.n	8023926 <cblas_ztrmm+0xee>
 8023970:	2e6f      	cmp	r6, #111	; 0x6f
 8023972:	f000 8721 	beq.w	80247b8 <cblas_ztrmm+0xf80>
      for (i = 0; i < n1; i++) {
 8023976:	9b07      	ldr	r3, [sp, #28]
 8023978:	2b00      	cmp	r3, #0
 802397a:	f340 80f7 	ble.w	8023b6c <cblas_ztrmm+0x334>
 802397e:	3401      	adds	r4, #1
 8023980:	0122      	lsls	r2, r4, #4
 8023982:	9910      	ldr	r1, [sp, #64]	; 0x40
 8023984:	9214      	str	r2, [sp, #80]	; 0x50
 8023986:	f1a2 0308 	sub.w	r3, r2, #8
 802398a:	18cb      	adds	r3, r1, r3
 802398c:	930d      	str	r3, [sp, #52]	; 0x34
 802398e:	f1a2 0310 	sub.w	r3, r2, #16
 8023992:	9303      	str	r3, [sp, #12]
 8023994:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023996:	9312      	str	r3, [sp, #72]	; 0x48
 8023998:	011a      	lsls	r2, r3, #4
 802399a:	2300      	movs	r3, #0
 802399c:	9311      	str	r3, [sp, #68]	; 0x44
 802399e:	2301      	movs	r3, #1
 80239a0:	9201      	str	r2, [sp, #4]
 80239a2:	930b      	str	r3, [sp, #44]	; 0x2c
        for (j = 0; j < n2; j++) {
 80239a4:	9b06      	ldr	r3, [sp, #24]
 80239a6:	2b00      	cmp	r3, #0
 80239a8:	f341 81cb 	ble.w	8024d42 <cblas_ztrmm+0x150a>
 80239ac:	e9dd 2311 	ldrd	r2, r3, [sp, #68]	; 0x44
 80239b0:	1a9b      	subs	r3, r3, r2
 80239b2:	011b      	lsls	r3, r3, #4
 80239b4:	3308      	adds	r3, #8
 80239b6:	930e      	str	r3, [sp, #56]	; 0x38
 80239b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80239ba:	9313      	str	r3, [sp, #76]	; 0x4c
 80239bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80239be:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80239c2:	9308      	str	r3, [sp, #32]
 80239c4:	2300      	movs	r3, #0
 80239c6:	9309      	str	r3, [sp, #36]	; 0x24
          if (nonunit) {
 80239c8:	9b02      	ldr	r3, [sp, #8]
 80239ca:	2b83      	cmp	r3, #131	; 0x83
 80239cc:	f000 8508 	beq.w	80243e0 <cblas_ztrmm+0xba8>
            temp_real = REAL(B, i * ldb + j);
 80239d0:	9b08      	ldr	r3, [sp, #32]
 80239d2:	461a      	mov	r2, r3
 80239d4:	ecb2 7b02 	vldmia	r2!, {d7}
 80239d8:	eeb0 ba47 	vmov.f32	s22, s14
 80239dc:	eef0 ba67 	vmov.f32	s23, s15
            temp_imag = IMAG(B, i * ldb + j);
 80239e0:	ed93 7b02 	vldr	d7, [r3, #8]
            temp_real = REAL(B, i * ldb + j);
 80239e4:	920a      	str	r2, [sp, #40]	; 0x28
            temp_imag = IMAG(B, i * ldb + j);
 80239e6:	eeb0 ca47 	vmov.f32	s24, s14
 80239ea:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 80239ee:	9e07      	ldr	r6, [sp, #28]
 80239f0:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80239f2:	42ae      	cmp	r6, r5
 80239f4:	dd62      	ble.n	8023abc <cblas_ztrmm+0x284>
 80239f6:	ee1d 0a10 	vmov	r0, s26
 80239fa:	f005 f84b 	bl	8028a94 <__aeabi_i2d>
 80239fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8023a00:	9a08      	ldr	r2, [sp, #32]
 8023a02:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8023a04:	ec41 0b1e 	vmov	d14, r0, r1
 8023a08:	eb03 0a02 	add.w	sl, r3, r2
 8023a0c:	46b3      	mov	fp, r6
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8023a0e:	e9d4 2300 	ldrd	r2, r3, [r4]
 8023a12:	ec51 0b1e 	vmov	r0, r1, d14
 8023a16:	f005 f8a7 	bl	8028b68 <__aeabi_dmul>
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8023a1a:	ed14 7b02 	vldr	d7, [r4, #-8]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023a1e:	ed1a 6b02 	vldr	d6, [sl, #-8]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8023a22:	eeb0 aa47 	vmov.f32	s20, s14
 8023a26:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8023a2a:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023a2e:	eeb0 9a46 	vmov.f32	s18, s12
 8023a32:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8023a36:	4680      	mov	r8, r0
 8023a38:	4689      	mov	r9, r1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8023a3a:	ec51 0b17 	vmov	r0, r1, d7
 8023a3e:	f005 f893 	bl	8028b68 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8023a42:	ed9a 8b00 	vldr	d8, [sl]
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8023a46:	4606      	mov	r6, r0
 8023a48:	ec53 2b18 	vmov	r2, r3, d8
 8023a4c:	460f      	mov	r7, r1
 8023a4e:	4640      	mov	r0, r8
 8023a50:	4649      	mov	r1, r9
 8023a52:	f005 f889 	bl	8028b68 <__aeabi_dmul>
 8023a56:	4602      	mov	r2, r0
 8023a58:	460b      	mov	r3, r1
 8023a5a:	4630      	mov	r0, r6
 8023a5c:	4639      	mov	r1, r7
 8023a5e:	f004 fecb 	bl	80287f8 <__aeabi_dsub>
 8023a62:	4602      	mov	r2, r0
 8023a64:	460b      	mov	r3, r1
 8023a66:	ec51 0b1b 	vmov	r0, r1, d11
 8023a6a:	f004 fec7 	bl	80287fc <__adddf3>
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8023a6e:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8023a72:	4606      	mov	r6, r0
 8023a74:	460f      	mov	r7, r1
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8023a76:	ec51 0b1a 	vmov	r0, r1, d10
 8023a7a:	f005 f875 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8023a7e:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8023a82:	ec53 2b19 	vmov	r2, r3, d9
 8023a86:	4606      	mov	r6, r0
 8023a88:	460f      	mov	r7, r1
 8023a8a:	4640      	mov	r0, r8
 8023a8c:	4649      	mov	r1, r9
 8023a8e:	f005 f86b 	bl	8028b68 <__aeabi_dmul>
 8023a92:	4602      	mov	r2, r0
 8023a94:	460b      	mov	r3, r1
 8023a96:	4630      	mov	r0, r6
 8023a98:	4639      	mov	r1, r7
 8023a9a:	f004 feaf 	bl	80287fc <__adddf3>
 8023a9e:	460b      	mov	r3, r1
 8023aa0:	4602      	mov	r2, r0
 8023aa2:	ec51 0b1c 	vmov	r0, r1, d12
 8023aa6:	f004 fea9 	bl	80287fc <__adddf3>
 8023aaa:	9b03      	ldr	r3, [sp, #12]
          for (k = i + 1; k < n1; k++) {
 8023aac:	3501      	adds	r5, #1
 8023aae:	441c      	add	r4, r3
 8023ab0:	9b01      	ldr	r3, [sp, #4]
 8023ab2:	45ab      	cmp	fp, r5
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8023ab4:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = i + 1; k < n1; k++) {
 8023ab8:	449a      	add	sl, r3
 8023aba:	d1a8      	bne.n	8023a0e <cblas_ztrmm+0x1d6>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023abc:	ec5b ab1b 	vmov	sl, fp, d11
 8023ac0:	ec53 2b1f 	vmov	r2, r3, d15
 8023ac4:	ee1b 0a10 	vmov	r0, s22
 8023ac8:	4659      	mov	r1, fp
 8023aca:	f005 f84d 	bl	8028b68 <__aeabi_dmul>
 8023ace:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8023ad2:	ec57 6b1c 	vmov	r6, r7, d12
 8023ad6:	4604      	mov	r4, r0
 8023ad8:	460d      	mov	r5, r1
 8023ada:	4642      	mov	r2, r8
 8023adc:	464b      	mov	r3, r9
 8023ade:	ee1c 0a10 	vmov	r0, s24
 8023ae2:	4639      	mov	r1, r7
 8023ae4:	f005 f840 	bl	8028b68 <__aeabi_dmul>
 8023ae8:	4602      	mov	r2, r0
 8023aea:	460b      	mov	r3, r1
 8023aec:	4620      	mov	r0, r4
 8023aee:	4629      	mov	r1, r5
 8023af0:	f004 fe82 	bl	80287f8 <__aeabi_dsub>
 8023af4:	9c08      	ldr	r4, [sp, #32]
 8023af6:	e8e4 0104 	strd	r0, r1, [r4], #16
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023afa:	ec53 2b1f 	vmov	r2, r3, d15
 8023afe:	ee1c 0a10 	vmov	r0, s24
 8023b02:	4639      	mov	r1, r7
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023b04:	9408      	str	r4, [sp, #32]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023b06:	f005 f82f 	bl	8028b68 <__aeabi_dmul>
 8023b0a:	4642      	mov	r2, r8
 8023b0c:	464b      	mov	r3, r9
 8023b0e:	4604      	mov	r4, r0
 8023b10:	460d      	mov	r5, r1
 8023b12:	ee1b 0a10 	vmov	r0, s22
 8023b16:	4659      	mov	r1, fp
 8023b18:	f005 f826 	bl	8028b68 <__aeabi_dmul>
 8023b1c:	4602      	mov	r2, r0
 8023b1e:	460b      	mov	r3, r1
 8023b20:	4620      	mov	r0, r4
 8023b22:	4629      	mov	r1, r5
 8023b24:	f004 fe6a 	bl	80287fc <__adddf3>
 8023b28:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        for (j = 0; j < n2; j++) {
 8023b2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023b2c:	e9c2 0100 	strd	r0, r1, [r2]
        for (j = 0; j < n2; j++) {
 8023b30:	9a06      	ldr	r2, [sp, #24]
 8023b32:	3301      	adds	r3, #1
 8023b34:	429a      	cmp	r2, r3
 8023b36:	9309      	str	r3, [sp, #36]	; 0x24
 8023b38:	f47f af46 	bne.w	80239c8 <cblas_ztrmm+0x190>
      for (i = 0; i < n1; i++) {
 8023b3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8023b3e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8023b40:	3301      	adds	r3, #1
 8023b42:	930b      	str	r3, [sp, #44]	; 0x2c
 8023b44:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8023b46:	4611      	mov	r1, r2
 8023b48:	4419      	add	r1, r3
 8023b4a:	910d      	str	r1, [sp, #52]	; 0x34
 8023b4c:	9912      	ldr	r1, [sp, #72]	; 0x48
 8023b4e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023b50:	4608      	mov	r0, r1
 8023b52:	9911      	ldr	r1, [sp, #68]	; 0x44
 8023b54:	4410      	add	r0, r2
 8023b56:	4411      	add	r1, r2
 8023b58:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023b5a:	9012      	str	r0, [sp, #72]	; 0x48
 8023b5c:	441a      	add	r2, r3
 8023b5e:	9210      	str	r2, [sp, #64]	; 0x40
 8023b60:	9b07      	ldr	r3, [sp, #28]
 8023b62:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8023b64:	9111      	str	r1, [sp, #68]	; 0x44
 8023b66:	4293      	cmp	r3, r2
 8023b68:	f73f af1c 	bgt.w	80239a4 <cblas_ztrmm+0x16c>
 8023b6c:	b017      	add	sp, #92	; 0x5c
 8023b6e:	ecbd 8b10 	vpop	{d8-d15}
 8023b72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8023b76:	4613      	mov	r3, r2
 8023b78:	2a01      	cmp	r2, #1
 8023b7a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023b7c:	bfb8      	it	lt
 8023b7e:	2301      	movlt	r3, #1
 8023b80:	4293      	cmp	r3, r2
 8023b82:	bfcc      	ite	gt
 8023b84:	230c      	movgt	r3, #12
 8023b86:	230a      	movle	r3, #10
 8023b88:	4a0d      	ldr	r2, [pc, #52]	; (8023bc0 <cblas_ztrmm+0x388>)
 8023b8a:	490e      	ldr	r1, [pc, #56]	; (8023bc4 <cblas_ztrmm+0x38c>)
 8023b8c:	4618      	mov	r0, r3
 8023b8e:	f004 fdbb 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8023b92:	ed98 7b00 	vldr	d7, [r8]
 8023b96:	eeb0 fa47 	vmov.f32	s30, s14
 8023b9a:	eef0 fa67 	vmov.f32	s31, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8023b9e:	ed98 7b02 	vldr	d7, [r8, #8]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8023ba2:	2e6f      	cmp	r6, #111	; 0x6f
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8023ba4:	ed8d 7b04 	vstr	d7, [sp, #16]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8023ba8:	9b07      	ldr	r3, [sp, #28]
 8023baa:	f000 8364 	beq.w	8024276 <cblas_ztrmm+0xa3e>
 8023bae:	9a06      	ldr	r2, [sp, #24]
 8023bb0:	2670      	movs	r6, #112	; 0x70
 8023bb2:	e9cd 3206 	strd	r3, r2, [sp, #24]
 8023bb6:	e6ac      	b.n	8023912 <cblas_ztrmm+0xda>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8023bb8:	2b00      	cmp	r3, #0
 8023bba:	f43f ae94 	beq.w	80238e6 <cblas_ztrmm+0xae>
 8023bbe:	e68d      	b.n	80238dc <cblas_ztrmm+0xa4>
 8023bc0:	08031108 	.word	0x08031108
 8023bc4:	08031394 	.word	0x08031394
 8023bc8:	080311b8 	.word	0x080311b8
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8023bcc:	2e6f      	cmp	r6, #111	; 0x6f
      for (i = 0; i < n1; i++) {
 8023bce:	9b07      	ldr	r3, [sp, #28]
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8023bd0:	f000 8765 	beq.w	8024a9e <cblas_ztrmm+0x1266>
      for (i = 0; i < n1; i++) {
 8023bd4:	2b00      	cmp	r3, #0
 8023bd6:	ddc9      	ble.n	8023b6c <cblas_ztrmm+0x334>
 8023bd8:	1c62      	adds	r2, r4, #1
 8023bda:	0121      	lsls	r1, r4, #4
 8023bdc:	0112      	lsls	r2, r2, #4
 8023bde:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8023be0:	920e      	str	r2, [sp, #56]	; 0x38
 8023be2:	f101 0210 	add.w	r2, r1, #16
 8023be6:	920b      	str	r2, [sp, #44]	; 0x2c
 8023be8:	9a06      	ldr	r2, [sp, #24]
 8023bea:	910d      	str	r1, [sp, #52]	; 0x34
 8023bec:	3b10      	subs	r3, #16
 8023bee:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8023bf2:	9315      	str	r3, [sp, #84]	; 0x54
 8023bf4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023bf6:	011b      	lsls	r3, r3, #4
 8023bf8:	9314      	str	r3, [sp, #80]	; 0x50
 8023bfa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8023bfc:	2000      	movs	r0, #0
 8023bfe:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8023c02:	9011      	str	r0, [sp, #68]	; 0x44
 8023c04:	9013      	str	r0, [sp, #76]	; 0x4c
 8023c06:	9312      	str	r3, [sp, #72]	; 0x48
        for (j = 0; j < n2; j++) {
 8023c08:	9b06      	ldr	r3, [sp, #24]
 8023c0a:	2b00      	cmp	r3, #0
 8023c0c:	f340 8479 	ble.w	8024502 <cblas_ztrmm+0xcca>
 8023c10:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8023c12:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8023c14:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8023c18:	9303      	str	r3, [sp, #12]
 8023c1a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8023c1c:	9308      	str	r3, [sp, #32]
 8023c1e:	461a      	mov	r2, r3
 8023c20:	2300      	movs	r3, #0
 8023c22:	930a      	str	r3, [sp, #40]	; 0x28
          if (nonunit) {
 8023c24:	9b02      	ldr	r3, [sp, #8]
 8023c26:	3208      	adds	r2, #8
 8023c28:	9209      	str	r2, [sp, #36]	; 0x24
 8023c2a:	2b83      	cmp	r3, #131	; 0x83
        for (j = 0; j < n2; j++) {
 8023c2c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8023c2e:	9201      	str	r2, [sp, #4]
          if (nonunit) {
 8023c30:	f000 80b8 	beq.w	8023da4 <cblas_ztrmm+0x56c>
            temp_real = REAL(B, i * ldb + j);
 8023c34:	9b03      	ldr	r3, [sp, #12]
 8023c36:	ed93 7b00 	vldr	d7, [r3]
 8023c3a:	eeb0 aa47 	vmov.f32	s20, s14
 8023c3e:	eef0 aa67 	vmov.f32	s21, s15
            temp_imag = IMAG(B, i * ldb + j);
 8023c42:	ed93 7b02 	vldr	d7, [r3, #8]
 8023c46:	eeb0 ba47 	vmov.f32	s22, s14
 8023c4a:	eef0 ba67 	vmov.f32	s23, s15
          for (k = j + 1; k < n2; k++) {
 8023c4e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023c50:	9a06      	ldr	r2, [sp, #24]
 8023c52:	3301      	adds	r3, #1
 8023c54:	429a      	cmp	r2, r3
 8023c56:	930a      	str	r3, [sp, #40]	; 0x28
 8023c58:	f000 8420 	beq.w	802449c <cblas_ztrmm+0xc64>
 8023c5c:	ee1d 0a10 	vmov	r0, s26
 8023c60:	f004 ff18 	bl	8028a94 <__aeabi_i2d>
 8023c64:	9d03      	ldr	r5, [sp, #12]
 8023c66:	9c08      	ldr	r4, [sp, #32]
 8023c68:	ec41 0b1c 	vmov	d12, r0, r1
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8023c6c:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 8023c70:	ec51 0b1c 	vmov	r0, r1, d12
 8023c74:	f004 ff78 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023c78:	ed94 7b04 	vldr	d7, [r4, #16]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023c7c:	ed95 6b04 	vldr	d6, [r5, #16]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023c80:	eeb0 9a47 	vmov.f32	s18, s14
 8023c84:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023c88:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023c8c:	eeb0 8a46 	vmov.f32	s16, s12
 8023c90:	eef0 8a66 	vmov.f32	s17, s13
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8023c94:	4680      	mov	r8, r0
 8023c96:	4689      	mov	r9, r1
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023c98:	ec51 0b17 	vmov	r0, r1, d7
 8023c9c:	f004 ff64 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8023ca0:	e9d5 ab06 	ldrd	sl, fp, [r5, #24]
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023ca4:	4606      	mov	r6, r0
 8023ca6:	460f      	mov	r7, r1
 8023ca8:	4652      	mov	r2, sl
 8023caa:	465b      	mov	r3, fp
 8023cac:	4640      	mov	r0, r8
 8023cae:	4649      	mov	r1, r9
 8023cb0:	f004 ff5a 	bl	8028b68 <__aeabi_dmul>
 8023cb4:	4602      	mov	r2, r0
 8023cb6:	460b      	mov	r3, r1
 8023cb8:	4630      	mov	r0, r6
 8023cba:	4639      	mov	r1, r7
 8023cbc:	f004 fd9c 	bl	80287f8 <__aeabi_dsub>
 8023cc0:	4602      	mov	r2, r0
 8023cc2:	460b      	mov	r3, r1
 8023cc4:	ec51 0b1a 	vmov	r0, r1, d10
 8023cc8:	f004 fd98 	bl	80287fc <__adddf3>
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023ccc:	4652      	mov	r2, sl
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023cce:	4606      	mov	r6, r0
 8023cd0:	460f      	mov	r7, r1
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023cd2:	465b      	mov	r3, fp
 8023cd4:	ec51 0b19 	vmov	r0, r1, d9
 8023cd8:	f004 ff46 	bl	8028b68 <__aeabi_dmul>
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023cdc:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023ce0:	ec53 2b18 	vmov	r2, r3, d8
 8023ce4:	4606      	mov	r6, r0
 8023ce6:	460f      	mov	r7, r1
 8023ce8:	4640      	mov	r0, r8
 8023cea:	4649      	mov	r1, r9
 8023cec:	f004 ff3c 	bl	8028b68 <__aeabi_dmul>
 8023cf0:	4602      	mov	r2, r0
 8023cf2:	460b      	mov	r3, r1
 8023cf4:	4630      	mov	r0, r6
 8023cf6:	4639      	mov	r1, r7
 8023cf8:	f004 fd80 	bl	80287fc <__adddf3>
 8023cfc:	460b      	mov	r3, r1
 8023cfe:	4602      	mov	r2, r0
 8023d00:	ec51 0b1b 	vmov	r0, r1, d11
 8023d04:	f004 fd7a 	bl	80287fc <__adddf3>
          for (k = j + 1; k < n2; k++) {
 8023d08:	9b01      	ldr	r3, [sp, #4]
 8023d0a:	3410      	adds	r4, #16
 8023d0c:	42a3      	cmp	r3, r4
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023d0e:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = j + 1; k < n2; k++) {
 8023d12:	f105 0510 	add.w	r5, r5, #16
 8023d16:	d1a9      	bne.n	8023c6c <cblas_ztrmm+0x434>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023d18:	ec53 2b1f 	vmov	r2, r3, d15
 8023d1c:	ec51 0b1a 	vmov	r0, r1, d10
 8023d20:	f004 ff22 	bl	8028b68 <__aeabi_dmul>
 8023d24:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 8023d28:	ec58 7b1b 	vmov	r7, r8, d11
 8023d2c:	4604      	mov	r4, r0
 8023d2e:	460d      	mov	r5, r1
 8023d30:	464a      	mov	r2, r9
 8023d32:	4653      	mov	r3, sl
 8023d34:	ee1b 0a10 	vmov	r0, s22
 8023d38:	4641      	mov	r1, r8
 8023d3a:	f004 ff15 	bl	8028b68 <__aeabi_dmul>
 8023d3e:	4602      	mov	r2, r0
 8023d40:	460b      	mov	r3, r1
 8023d42:	4620      	mov	r0, r4
 8023d44:	4629      	mov	r1, r5
 8023d46:	f004 fd57 	bl	80287f8 <__aeabi_dsub>
 8023d4a:	9e03      	ldr	r6, [sp, #12]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023d4c:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023d4e:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023d52:	4653      	mov	r3, sl
 8023d54:	ec51 0b1a 	vmov	r0, r1, d10
 8023d58:	f004 ff06 	bl	8028b68 <__aeabi_dmul>
 8023d5c:	ec53 2b1f 	vmov	r2, r3, d15
 8023d60:	4604      	mov	r4, r0
 8023d62:	460d      	mov	r5, r1
 8023d64:	ee1b 0a10 	vmov	r0, s22
 8023d68:	4641      	mov	r1, r8
 8023d6a:	f004 fefd 	bl	8028b68 <__aeabi_dmul>
 8023d6e:	4602      	mov	r2, r0
 8023d70:	460b      	mov	r3, r1
 8023d72:	4620      	mov	r0, r4
 8023d74:	4629      	mov	r1, r5
 8023d76:	f004 fd41 	bl	80287fc <__adddf3>
 8023d7a:	9b08      	ldr	r3, [sp, #32]
 8023d7c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8023d7e:	4413      	add	r3, r2
 8023d80:	9308      	str	r3, [sp, #32]
 8023d82:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8023d84:	9b01      	ldr	r3, [sp, #4]
 8023d86:	4413      	add	r3, r2
 8023d88:	9301      	str	r3, [sp, #4]
 8023d8a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023d8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8023d8e:	4413      	add	r3, r2
 8023d90:	9309      	str	r3, [sp, #36]	; 0x24
 8023d92:	f106 0310 	add.w	r3, r6, #16
 8023d96:	9303      	str	r3, [sp, #12]
          if (nonunit) {
 8023d98:	9b02      	ldr	r3, [sp, #8]
 8023d9a:	2b83      	cmp	r3, #131	; 0x83
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023d9c:	e9c6 0102 	strd	r0, r1, [r6, #8]
          if (nonunit) {
 8023da0:	f47f af48 	bne.w	8023c34 <cblas_ztrmm+0x3fc>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023da4:	ee1d 0a10 	vmov	r0, s26
 8023da8:	f004 fe74 	bl	8028a94 <__aeabi_i2d>
 8023dac:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8023dae:	e9d4 2300 	ldrd	r2, r3, [r4]
 8023db2:	f004 fed9 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8023db6:	e954 8902 	ldrd	r8, r9, [r4, #-8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023dba:	9c03      	ldr	r4, [sp, #12]
 8023dbc:	ed94 7b00 	vldr	d7, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023dc0:	4682      	mov	sl, r0
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023dc2:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023dc6:	eeb0 8a47 	vmov.f32	s16, s14
 8023dca:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023dce:	468b      	mov	fp, r1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023dd0:	4640      	mov	r0, r8
 8023dd2:	4649      	mov	r1, r9
 8023dd4:	f004 fec8 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8023dd8:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023ddc:	460d      	mov	r5, r1
 8023dde:	4604      	mov	r4, r0
 8023de0:	4632      	mov	r2, r6
 8023de2:	463b      	mov	r3, r7
 8023de4:	4650      	mov	r0, sl
 8023de6:	4659      	mov	r1, fp
 8023de8:	f004 febe 	bl	8028b68 <__aeabi_dmul>
 8023dec:	4602      	mov	r2, r0
 8023dee:	460b      	mov	r3, r1
 8023df0:	4620      	mov	r0, r4
 8023df2:	4629      	mov	r1, r5
 8023df4:	f004 fd00 	bl	80287f8 <__aeabi_dsub>
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8023df8:	4632      	mov	r2, r6
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023dfa:	4604      	mov	r4, r0
 8023dfc:	460d      	mov	r5, r1
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8023dfe:	463b      	mov	r3, r7
 8023e00:	4640      	mov	r0, r8
 8023e02:	4649      	mov	r1, r9
 8023e04:	f004 feb0 	bl	8028b68 <__aeabi_dmul>
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023e08:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8023e0c:	ec53 2b18 	vmov	r2, r3, d8
 8023e10:	4604      	mov	r4, r0
 8023e12:	460d      	mov	r5, r1
 8023e14:	4650      	mov	r0, sl
 8023e16:	4659      	mov	r1, fp
 8023e18:	f004 fea6 	bl	8028b68 <__aeabi_dmul>
 8023e1c:	4602      	mov	r2, r0
 8023e1e:	460b      	mov	r3, r1
 8023e20:	4620      	mov	r0, r4
 8023e22:	4629      	mov	r1, r5
 8023e24:	f004 fcea 	bl	80287fc <__adddf3>
 8023e28:	ec41 0b1b 	vmov	d11, r0, r1
 8023e2c:	e70f      	b.n	8023c4e <cblas_ztrmm+0x416>
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8023e2e:	2e6f      	cmp	r6, #111	; 0x6f
      for (i = 0; i < n1; i++) {
 8023e30:	9b07      	ldr	r3, [sp, #28]
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8023e32:	f000 8791 	beq.w	8024d58 <cblas_ztrmm+0x1520>
      for (i = 0; i < n1; i++) {
 8023e36:	2b00      	cmp	r3, #0
 8023e38:	f77f ae98 	ble.w	8023b6c <cblas_ztrmm+0x334>
 8023e3c:	9906      	ldr	r1, [sp, #24]
 8023e3e:	1e4b      	subs	r3, r1, #1
 8023e40:	fb03 1004 	mla	r0, r3, r4, r1
 8023e44:	1c62      	adds	r2, r4, #1
 8023e46:	43e6      	mvns	r6, r4
 8023e48:	ebc4 7c04 	rsb	ip, r4, r4, lsl #28
 8023e4c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8023e4e:	0124      	lsls	r4, r4, #4
 8023e50:	9411      	str	r4, [sp, #68]	; 0x44
 8023e52:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8023e54:	940b      	str	r4, [sp, #44]	; 0x2c
 8023e56:	0112      	lsls	r2, r2, #4
 8023e58:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8023e5a:	460f      	mov	r7, r1
 8023e5c:	9910      	ldr	r1, [sp, #64]	; 0x40
 8023e5e:	f1a2 0510 	sub.w	r5, r2, #16
 8023e62:	fb03 4505 	mla	r5, r3, r5, r4
 8023e66:	3910      	subs	r1, #16
 8023e68:	fb03 4302 	mla	r3, r3, r2, r4
 8023e6c:	9310      	str	r3, [sp, #64]	; 0x40
 8023e6e:	eb01 1300 	add.w	r3, r1, r0, lsl #4
 8023e72:	9312      	str	r3, [sp, #72]	; 0x48
 8023e74:	0133      	lsls	r3, r6, #4
 8023e76:	930c      	str	r3, [sp, #48]	; 0x30
 8023e78:	ea4f 130c 	mov.w	r3, ip, lsl #4
 8023e7c:	930d      	str	r3, [sp, #52]	; 0x34
 8023e7e:	013b      	lsls	r3, r7, #4
 8023e80:	930f      	str	r3, [sp, #60]	; 0x3c
 8023e82:	2300      	movs	r3, #0
 8023e84:	9513      	str	r5, [sp, #76]	; 0x4c
 8023e86:	930e      	str	r3, [sp, #56]	; 0x38
        for (j = n2; j > 0 && j--;) {
 8023e88:	9b06      	ldr	r3, [sp, #24]
 8023e8a:	2b00      	cmp	r3, #0
 8023e8c:	f340 80d1 	ble.w	8024032 <cblas_ztrmm+0x7fa>
 8023e90:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023e92:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8023e94:	9303      	str	r3, [sp, #12]
 8023e96:	440a      	add	r2, r1
 8023e98:	9209      	str	r2, [sp, #36]	; 0x24
 8023e9a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8023e9c:	9201      	str	r2, [sp, #4]
 8023e9e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8023ea0:	9208      	str	r2, [sp, #32]
 8023ea2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023ea4:	920a      	str	r2, [sp, #40]	; 0x28
          for (k = 0; k < j; k++) {
 8023ea6:	9b03      	ldr	r3, [sp, #12]
 8023ea8:	3b01      	subs	r3, #1
 8023eaa:	9303      	str	r3, [sp, #12]
 8023eac:	f000 82e0 	beq.w	8024470 <cblas_ztrmm+0xc38>
 8023eb0:	ee1d 0a10 	vmov	r0, s26
 8023eb4:	f004 fdee 	bl	8028a94 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 8023eb8:	ed9f 7b69 	vldr	d7, [pc, #420]	; 8024060 <cblas_ztrmm+0x828>
 8023ebc:	ec41 0b1c 	vmov	d12, r0, r1
 8023ec0:	eeb0 ba47 	vmov.f32	s22, s14
 8023ec4:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < j; k++) {
 8023ec8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8023eca:	9c08      	ldr	r4, [sp, #32]
          BASE temp_real = 0.0;
 8023ecc:	eeb0 aa47 	vmov.f32	s20, s14
 8023ed0:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8023ed4:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8023ed8:	ec51 0b1c 	vmov	r0, r1, d12
 8023edc:	f004 fe44 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023ee0:	ed94 7b00 	vldr	d7, [r4]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023ee4:	ed95 6b00 	vldr	d6, [r5]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023ee8:	eeb0 9a47 	vmov.f32	s18, s14
 8023eec:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023ef0:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023ef4:	eeb0 8a46 	vmov.f32	s16, s12
 8023ef8:	eef0 8a66 	vmov.f32	s17, s13
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8023efc:	4680      	mov	r8, r0
 8023efe:	4689      	mov	r9, r1
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023f00:	ec51 0b17 	vmov	r0, r1, d7
 8023f04:	f004 fe30 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8023f08:	e9d5 ab02 	ldrd	sl, fp, [r5, #8]
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023f0c:	4606      	mov	r6, r0
 8023f0e:	460f      	mov	r7, r1
 8023f10:	4652      	mov	r2, sl
 8023f12:	465b      	mov	r3, fp
 8023f14:	4640      	mov	r0, r8
 8023f16:	4649      	mov	r1, r9
 8023f18:	f004 fe26 	bl	8028b68 <__aeabi_dmul>
 8023f1c:	4602      	mov	r2, r0
 8023f1e:	460b      	mov	r3, r1
 8023f20:	4630      	mov	r0, r6
 8023f22:	4639      	mov	r1, r7
 8023f24:	f004 fc68 	bl	80287f8 <__aeabi_dsub>
 8023f28:	4602      	mov	r2, r0
 8023f2a:	460b      	mov	r3, r1
 8023f2c:	ec51 0b1a 	vmov	r0, r1, d10
 8023f30:	f004 fc64 	bl	80287fc <__adddf3>
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023f34:	4652      	mov	r2, sl
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023f36:	4606      	mov	r6, r0
 8023f38:	460f      	mov	r7, r1
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023f3a:	465b      	mov	r3, fp
 8023f3c:	ec51 0b19 	vmov	r0, r1, d9
 8023f40:	f004 fe12 	bl	8028b68 <__aeabi_dmul>
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023f44:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023f48:	ec53 2b18 	vmov	r2, r3, d8
 8023f4c:	4606      	mov	r6, r0
 8023f4e:	460f      	mov	r7, r1
 8023f50:	4640      	mov	r0, r8
 8023f52:	4649      	mov	r1, r9
 8023f54:	f004 fe08 	bl	8028b68 <__aeabi_dmul>
 8023f58:	4602      	mov	r2, r0
 8023f5a:	460b      	mov	r3, r1
 8023f5c:	4630      	mov	r0, r6
 8023f5e:	4639      	mov	r1, r7
 8023f60:	f004 fc4c 	bl	80287fc <__adddf3>
 8023f64:	460b      	mov	r3, r1
 8023f66:	4602      	mov	r2, r0
 8023f68:	ec51 0b1b 	vmov	r0, r1, d11
 8023f6c:	f004 fc46 	bl	80287fc <__adddf3>
          for (k = 0; k < j; k++) {
 8023f70:	9b01      	ldr	r3, [sp, #4]
 8023f72:	3410      	adds	r4, #16
 8023f74:	42a3      	cmp	r3, r4
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023f76:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < j; k++) {
 8023f7a:	f105 0510 	add.w	r5, r5, #16
 8023f7e:	d1a9      	bne.n	8023ed4 <cblas_ztrmm+0x69c>
          if (nonunit) {
 8023f80:	9b02      	ldr	r3, [sp, #8]
 8023f82:	2b83      	cmp	r3, #131	; 0x83
 8023f84:	f000 818a 	beq.w	802429c <cblas_ztrmm+0xa64>
            temp_real += REAL(B, i * ldb + j);
 8023f88:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8023f8a:	ec51 0b1a 	vmov	r0, r1, d10
 8023f8e:	e956 2304 	ldrd	r2, r3, [r6, #-16]
 8023f92:	f004 fc33 	bl	80287fc <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 8023f96:	e956 2302 	ldrd	r2, r3, [r6, #-8]
            temp_real += REAL(B, i * ldb + j);
 8023f9a:	4682      	mov	sl, r0
 8023f9c:	468b      	mov	fp, r1
            temp_imag += IMAG(B, i * ldb + j);
 8023f9e:	ec51 0b1b 	vmov	r0, r1, d11
 8023fa2:	f004 fc2b 	bl	80287fc <__adddf3>
 8023fa6:	f1a6 0810 	sub.w	r8, r6, #16
 8023faa:	4604      	mov	r4, r0
 8023fac:	460d      	mov	r5, r1
 8023fae:	f1a6 0908 	sub.w	r9, r6, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023fb2:	ec53 2b1f 	vmov	r2, r3, d15
 8023fb6:	4650      	mov	r0, sl
 8023fb8:	4659      	mov	r1, fp
 8023fba:	f004 fdd5 	bl	8028b68 <__aeabi_dmul>
 8023fbe:	ed9d 8b04 	vldr	d8, [sp, #16]
 8023fc2:	4606      	mov	r6, r0
 8023fc4:	ec53 2b18 	vmov	r2, r3, d8
 8023fc8:	460f      	mov	r7, r1
 8023fca:	4620      	mov	r0, r4
 8023fcc:	4629      	mov	r1, r5
 8023fce:	f004 fdcb 	bl	8028b68 <__aeabi_dmul>
 8023fd2:	4602      	mov	r2, r0
 8023fd4:	460b      	mov	r3, r1
 8023fd6:	4630      	mov	r0, r6
 8023fd8:	4639      	mov	r1, r7
 8023fda:	f004 fc0d 	bl	80287f8 <__aeabi_dsub>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023fde:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023fe2:	e9c8 0100 	strd	r0, r1, [r8]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023fe6:	4620      	mov	r0, r4
 8023fe8:	4629      	mov	r1, r5
 8023fea:	f004 fdbd 	bl	8028b68 <__aeabi_dmul>
 8023fee:	ec53 2b18 	vmov	r2, r3, d8
 8023ff2:	4604      	mov	r4, r0
 8023ff4:	460d      	mov	r5, r1
 8023ff6:	4650      	mov	r0, sl
 8023ff8:	4659      	mov	r1, fp
 8023ffa:	f004 fdb5 	bl	8028b68 <__aeabi_dmul>
 8023ffe:	4602      	mov	r2, r0
 8024000:	460b      	mov	r3, r1
 8024002:	4620      	mov	r0, r4
 8024004:	4629      	mov	r1, r5
 8024006:	f004 fbf9 	bl	80287fc <__adddf3>
 802400a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802400c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802400e:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 8024012:	4614      	mov	r4, r2
 8024014:	441c      	add	r4, r3
 8024016:	9a08      	ldr	r2, [sp, #32]
 8024018:	940a      	str	r4, [sp, #40]	; 0x28
 802401a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 802401c:	4422      	add	r2, r4
 802401e:	9208      	str	r2, [sp, #32]
 8024020:	9a01      	ldr	r2, [sp, #4]
 8024022:	441a      	add	r2, r3
        for (j = n2; j > 0 && j--;) {
 8024024:	9b03      	ldr	r3, [sp, #12]
 8024026:	9201      	str	r2, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024028:	e9c9 0100 	strd	r0, r1, [r9]
        for (j = n2; j > 0 && j--;) {
 802402c:	2b00      	cmp	r3, #0
 802402e:	f47f af3a 	bne.w	8023ea6 <cblas_ztrmm+0x66e>
      for (i = 0; i < n1; i++) {
 8024032:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8024034:	9911      	ldr	r1, [sp, #68]	; 0x44
 8024036:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8024038:	440a      	add	r2, r1
 802403a:	920b      	str	r2, [sp, #44]	; 0x2c
 802403c:	9a07      	ldr	r2, [sp, #28]
 802403e:	3301      	adds	r3, #1
 8024040:	429a      	cmp	r2, r3
 8024042:	930e      	str	r3, [sp, #56]	; 0x38
 8024044:	f47f af20 	bne.w	8023e88 <cblas_ztrmm+0x650>
 8024048:	e590      	b.n	8023b6c <cblas_ztrmm+0x334>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 802404a:	9a07      	ldr	r2, [sp, #28]
 802404c:	990c      	ldr	r1, [sp, #48]	; 0x30
 802404e:	2a01      	cmp	r2, #1
 8024050:	bfb8      	it	lt
 8024052:	2201      	movlt	r2, #1
 8024054:	428a      	cmp	r2, r1
 8024056:	f340 8113 	ble.w	8024280 <cblas_ztrmm+0xa48>
 802405a:	230c      	movs	r3, #12
 802405c:	e594      	b.n	8023b88 <cblas_ztrmm+0x350>
 802405e:	bf00      	nop
	...
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8024068:	2e6f      	cmp	r6, #111	; 0x6f
 802406a:	f000 825b 	beq.w	8024524 <cblas_ztrmm+0xcec>
      for (i = n1; i > 0 && i--;) {
 802406e:	9807      	ldr	r0, [sp, #28]
 8024070:	2800      	cmp	r0, #0
 8024072:	f77f ad7b 	ble.w	8023b6c <cblas_ztrmm+0x334>
 8024076:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024078:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 802407a:	9f10      	ldr	r7, [sp, #64]	; 0x40
 802407c:	1e42      	subs	r2, r0, #1
 802407e:	0119      	lsls	r1, r3, #4
 8024080:	fb02 6601 	mla	r6, r2, r1, r6
 8024084:	ebc3 7503 	rsb	r5, r3, r3, lsl #28
 8024088:	9101      	str	r1, [sp, #4]
 802408a:	1c63      	adds	r3, r4, #1
 802408c:	eb07 1100 	add.w	r1, r7, r0, lsl #4
 8024090:	012d      	lsls	r5, r5, #4
 8024092:	011b      	lsls	r3, r3, #4
 8024094:	910b      	str	r1, [sp, #44]	; 0x2c
 8024096:	f106 0108 	add.w	r1, r6, #8
 802409a:	9208      	str	r2, [sp, #32]
 802409c:	43e4      	mvns	r4, r4
 802409e:	910d      	str	r1, [sp, #52]	; 0x34
 80240a0:	fb02 f105 	mul.w	r1, r2, r5
 80240a4:	fb02 7203 	mla	r2, r2, r3, r7
 80240a8:	3b10      	subs	r3, #16
 80240aa:	9303      	str	r3, [sp, #12]
 80240ac:	0123      	lsls	r3, r4, #4
 80240ae:	950f      	str	r5, [sp, #60]	; 0x3c
 80240b0:	910a      	str	r1, [sp, #40]	; 0x28
 80240b2:	920c      	str	r2, [sp, #48]	; 0x30
 80240b4:	930e      	str	r3, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 80240b6:	9b06      	ldr	r3, [sp, #24]
 80240b8:	2b00      	cmp	r3, #0
 80240ba:	f340 80c6 	ble.w	802424a <cblas_ztrmm+0xa12>
 80240be:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80240c0:	9307      	str	r3, [sp, #28]
 80240c2:	2300      	movs	r3, #0
 80240c4:	9309      	str	r3, [sp, #36]	; 0x24
          for (k = 0; k < i; k++) {
 80240c6:	9b08      	ldr	r3, [sp, #32]
 80240c8:	2b00      	cmp	r3, #0
 80240ca:	f000 81dc 	beq.w	8024486 <cblas_ztrmm+0xc4e>
 80240ce:	ee1d 0a10 	vmov	r0, s26
 80240d2:	f004 fcdf 	bl	8028a94 <__aeabi_i2d>
 80240d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80240d8:	9a07      	ldr	r2, [sp, #28]
 80240da:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80240dc:	f8dd b020 	ldr.w	fp, [sp, #32]
          BASE temp_imag = 0.0;
 80240e0:	ed1f 7b21 	vldr	d7, [pc, #-132]	; 8024060 <cblas_ztrmm+0x828>
 80240e4:	eb03 0a02 	add.w	sl, r3, r2
 80240e8:	ec41 0b1e 	vmov	d14, r0, r1
 80240ec:	eeb0 ca47 	vmov.f32	s24, s14
 80240f0:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < i; k++) {
 80240f4:	2300      	movs	r3, #0
 80240f6:	461d      	mov	r5, r3
          BASE temp_real = 0.0;
 80240f8:	eeb0 ba47 	vmov.f32	s22, s14
 80240fc:	eef0 ba67 	vmov.f32	s23, s15
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8024100:	e954 2302 	ldrd	r2, r3, [r4, #-8]
 8024104:	ec51 0b1e 	vmov	r0, r1, d14
 8024108:	f004 fd2e 	bl	8028b68 <__aeabi_dmul>
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 802410c:	ed14 7b04 	vldr	d7, [r4, #-16]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8024110:	ed1a 6b02 	vldr	d6, [sl, #-8]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8024114:	eeb0 aa47 	vmov.f32	s20, s14
 8024118:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 802411c:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8024120:	eeb0 9a46 	vmov.f32	s18, s12
 8024124:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8024128:	4680      	mov	r8, r0
 802412a:	4689      	mov	r9, r1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 802412c:	ec51 0b17 	vmov	r0, r1, d7
 8024130:	f004 fd1a 	bl	8028b68 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8024134:	ed9a 8b00 	vldr	d8, [sl]
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8024138:	4606      	mov	r6, r0
 802413a:	ec53 2b18 	vmov	r2, r3, d8
 802413e:	460f      	mov	r7, r1
 8024140:	4640      	mov	r0, r8
 8024142:	4649      	mov	r1, r9
 8024144:	f004 fd10 	bl	8028b68 <__aeabi_dmul>
 8024148:	4602      	mov	r2, r0
 802414a:	460b      	mov	r3, r1
 802414c:	4630      	mov	r0, r6
 802414e:	4639      	mov	r1, r7
 8024150:	f004 fb52 	bl	80287f8 <__aeabi_dsub>
 8024154:	4602      	mov	r2, r0
 8024156:	460b      	mov	r3, r1
 8024158:	ec51 0b1b 	vmov	r0, r1, d11
 802415c:	f004 fb4e 	bl	80287fc <__adddf3>
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8024160:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8024164:	4606      	mov	r6, r0
 8024166:	460f      	mov	r7, r1
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8024168:	ec51 0b1a 	vmov	r0, r1, d10
 802416c:	f004 fcfc 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8024170:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8024174:	ec53 2b19 	vmov	r2, r3, d9
 8024178:	4606      	mov	r6, r0
 802417a:	460f      	mov	r7, r1
 802417c:	4640      	mov	r0, r8
 802417e:	4649      	mov	r1, r9
 8024180:	f004 fcf2 	bl	8028b68 <__aeabi_dmul>
 8024184:	4602      	mov	r2, r0
 8024186:	460b      	mov	r3, r1
 8024188:	4630      	mov	r0, r6
 802418a:	4639      	mov	r1, r7
 802418c:	f004 fb36 	bl	80287fc <__adddf3>
 8024190:	460b      	mov	r3, r1
 8024192:	4602      	mov	r2, r0
 8024194:	ec51 0b1c 	vmov	r0, r1, d12
 8024198:	f004 fb30 	bl	80287fc <__adddf3>
 802419c:	9b03      	ldr	r3, [sp, #12]
          for (k = 0; k < i; k++) {
 802419e:	3501      	adds	r5, #1
 80241a0:	441c      	add	r4, r3
 80241a2:	9b01      	ldr	r3, [sp, #4]
 80241a4:	45ab      	cmp	fp, r5
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 80241a6:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < i; k++) {
 80241aa:	449a      	add	sl, r3
 80241ac:	d1a8      	bne.n	8024100 <cblas_ztrmm+0x8c8>
          if (nonunit) {
 80241ae:	9b02      	ldr	r3, [sp, #8]
 80241b0:	2b83      	cmp	r3, #131	; 0x83
 80241b2:	f000 80c5 	beq.w	8024340 <cblas_ztrmm+0xb08>
            temp_real += REAL(B, i * ldb + j);
 80241b6:	9e07      	ldr	r6, [sp, #28]
 80241b8:	ec51 0b1b 	vmov	r0, r1, d11
 80241bc:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 80241c0:	f004 fb1c 	bl	80287fc <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 80241c4:	e9d6 2300 	ldrd	r2, r3, [r6]
            temp_real += REAL(B, i * ldb + j);
 80241c8:	4680      	mov	r8, r0
 80241ca:	4689      	mov	r9, r1
            temp_imag += IMAG(B, i * ldb + j);
 80241cc:	ec51 0b1c 	vmov	r0, r1, d12
 80241d0:	f004 fb14 	bl	80287fc <__adddf3>
 80241d4:	f1a6 0a08 	sub.w	sl, r6, #8
 80241d8:	4604      	mov	r4, r0
 80241da:	460d      	mov	r5, r1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80241dc:	ec53 2b1f 	vmov	r2, r3, d15
 80241e0:	4640      	mov	r0, r8
 80241e2:	4649      	mov	r1, r9
 80241e4:	f004 fcc0 	bl	8028b68 <__aeabi_dmul>
 80241e8:	ed9d 8b04 	vldr	d8, [sp, #16]
 80241ec:	4606      	mov	r6, r0
 80241ee:	ec53 2b18 	vmov	r2, r3, d8
 80241f2:	460f      	mov	r7, r1
 80241f4:	4620      	mov	r0, r4
 80241f6:	4629      	mov	r1, r5
 80241f8:	f004 fcb6 	bl	8028b68 <__aeabi_dmul>
 80241fc:	4602      	mov	r2, r0
 80241fe:	460b      	mov	r3, r1
 8024200:	4630      	mov	r0, r6
 8024202:	4639      	mov	r1, r7
 8024204:	f004 faf8 	bl	80287f8 <__aeabi_dsub>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024208:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 802420c:	e9ca 0100 	strd	r0, r1, [sl]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024210:	4620      	mov	r0, r4
 8024212:	4629      	mov	r1, r5
 8024214:	f004 fca8 	bl	8028b68 <__aeabi_dmul>
 8024218:	ec53 2b18 	vmov	r2, r3, d8
 802421c:	4604      	mov	r4, r0
 802421e:	460d      	mov	r5, r1
 8024220:	4640      	mov	r0, r8
 8024222:	4649      	mov	r1, r9
 8024224:	f004 fca0 	bl	8028b68 <__aeabi_dmul>
 8024228:	4602      	mov	r2, r0
 802422a:	460b      	mov	r3, r1
 802422c:	4620      	mov	r0, r4
 802422e:	4629      	mov	r1, r5
 8024230:	f004 fae4 	bl	80287fc <__adddf3>
 8024234:	9a07      	ldr	r2, [sp, #28]
        for (j = 0; j < n2; j++) {
 8024236:	9b09      	ldr	r3, [sp, #36]	; 0x24
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024238:	e8e2 0104 	strd	r0, r1, [r2], #16
 802423c:	9207      	str	r2, [sp, #28]
        for (j = 0; j < n2; j++) {
 802423e:	9a06      	ldr	r2, [sp, #24]
 8024240:	3301      	adds	r3, #1
 8024242:	429a      	cmp	r2, r3
 8024244:	9309      	str	r3, [sp, #36]	; 0x24
 8024246:	f47f af3e 	bne.w	80240c6 <cblas_ztrmm+0x88e>
      for (i = n1; i > 0 && i--;) {
 802424a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802424c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802424e:	4413      	add	r3, r2
 8024250:	930c      	str	r3, [sp, #48]	; 0x30
 8024252:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8024254:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8024256:	4413      	add	r3, r2
 8024258:	930d      	str	r3, [sp, #52]	; 0x34
 802425a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802425c:	9a01      	ldr	r2, [sp, #4]
 802425e:	3b10      	subs	r3, #16
 8024260:	930b      	str	r3, [sp, #44]	; 0x2c
 8024262:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024264:	4413      	add	r3, r2
 8024266:	930a      	str	r3, [sp, #40]	; 0x28
 8024268:	9b08      	ldr	r3, [sp, #32]
 802426a:	2b00      	cmp	r3, #0
 802426c:	f43f ac7e 	beq.w	8023b6c <cblas_ztrmm+0x334>
 8024270:	3b01      	subs	r3, #1
 8024272:	9308      	str	r3, [sp, #32]
 8024274:	e71f      	b.n	80240b6 <cblas_ztrmm+0x87e>
 8024276:	9a06      	ldr	r2, [sp, #24]
 8024278:	e9cd 3206 	strd	r3, r2, [sp, #24]
 802427c:	f7ff bb49 	b.w	8023912 <cblas_ztrmm+0xda>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8024280:	2b00      	cmp	r3, #0
 8024282:	f43f ac86 	beq.w	8023b92 <cblas_ztrmm+0x35a>
 8024286:	e47f      	b.n	8023b88 <cblas_ztrmm+0x350>
 8024288:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 802428c:	2b01      	cmp	r3, #1
 802428e:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8024292:	bf94      	ite	ls
 8024294:	2300      	movls	r3, #0
 8024296:	2301      	movhi	r3, #1
 8024298:	f7ff baf4 	b.w	8023884 <cblas_ztrmm+0x4c>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 802429c:	ee1d 0a10 	vmov	r0, s26
 80242a0:	f004 fbf8 	bl	8028a94 <__aeabi_i2d>
 80242a4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80242a6:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80242aa:	f004 fc5d 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 80242ae:	e9d6 8900 	ldrd	r8, r9, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 80242b2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80242b4:	ed16 7b04 	vldr	d7, [r6, #-16]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80242b8:	4604      	mov	r4, r0
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80242ba:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 80242be:	eeb0 9a47 	vmov.f32	s18, s14
 80242c2:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80242c6:	460d      	mov	r5, r1
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80242c8:	4640      	mov	r0, r8
 80242ca:	4649      	mov	r1, r9
 80242cc:	f004 fc4c 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 80242d0:	e956 6702 	ldrd	r6, r7, [r6, #-8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80242d4:	ec45 4b18 	vmov	d8, r4, r5
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80242d8:	4632      	mov	r2, r6
 80242da:	4604      	mov	r4, r0
 80242dc:	460d      	mov	r5, r1
 80242de:	463b      	mov	r3, r7
 80242e0:	ec51 0b18 	vmov	r0, r1, d8
 80242e4:	f004 fc40 	bl	8028b68 <__aeabi_dmul>
 80242e8:	4602      	mov	r2, r0
 80242ea:	460b      	mov	r3, r1
 80242ec:	4620      	mov	r0, r4
 80242ee:	4629      	mov	r1, r5
 80242f0:	f004 fa82 	bl	80287f8 <__aeabi_dsub>
 80242f4:	ec53 2b1a 	vmov	r2, r3, d10
 80242f8:	f004 fa80 	bl	80287fc <__adddf3>
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80242fc:	4632      	mov	r2, r6
 80242fe:	463b      	mov	r3, r7
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024300:	4682      	mov	sl, r0
 8024302:	468b      	mov	fp, r1
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024304:	4640      	mov	r0, r8
 8024306:	4649      	mov	r1, r9
 8024308:	f004 fc2e 	bl	8028b68 <__aeabi_dmul>
 802430c:	ec53 2b19 	vmov	r2, r3, d9
 8024310:	4604      	mov	r4, r0
 8024312:	460d      	mov	r5, r1
 8024314:	ec51 0b18 	vmov	r0, r1, d8
 8024318:	f004 fc26 	bl	8028b68 <__aeabi_dmul>
 802431c:	4602      	mov	r2, r0
 802431e:	460b      	mov	r3, r1
 8024320:	4620      	mov	r0, r4
 8024322:	4629      	mov	r1, r5
 8024324:	f004 fa6a 	bl	80287fc <__adddf3>
 8024328:	ec53 2b1b 	vmov	r2, r3, d11
 802432c:	f004 fa66 	bl	80287fc <__adddf3>
 8024330:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8024332:	4604      	mov	r4, r0
 8024334:	f1a6 0810 	sub.w	r8, r6, #16
 8024338:	460d      	mov	r5, r1
 802433a:	f1a6 0908 	sub.w	r9, r6, #8
 802433e:	e638      	b.n	8023fb2 <cblas_ztrmm+0x77a>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8024340:	ee1d 0a10 	vmov	r0, s26
 8024344:	f004 fba6 	bl	8028a94 <__aeabi_i2d>
 8024348:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 802434a:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 802434e:	f004 fc0b 	bl	8028b68 <__aeabi_dmul>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8024352:	e9d6 ab00 	ldrd	sl, fp, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024356:	9e07      	ldr	r6, [sp, #28]
 8024358:	ed16 7b02 	vldr	d7, [r6, #-8]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802435c:	4604      	mov	r4, r0
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 802435e:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024362:	eeb0 9a47 	vmov.f32	s18, s14
 8024366:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802436a:	460d      	mov	r5, r1
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 802436c:	4650      	mov	r0, sl
 802436e:	4659      	mov	r1, fp
 8024370:	f004 fbfa 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024374:	e9d6 6700 	ldrd	r6, r7, [r6]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8024378:	ec45 4b18 	vmov	d8, r4, r5
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 802437c:	4632      	mov	r2, r6
 802437e:	4604      	mov	r4, r0
 8024380:	460d      	mov	r5, r1
 8024382:	463b      	mov	r3, r7
 8024384:	ec51 0b18 	vmov	r0, r1, d8
 8024388:	f004 fbee 	bl	8028b68 <__aeabi_dmul>
 802438c:	4602      	mov	r2, r0
 802438e:	460b      	mov	r3, r1
 8024390:	4620      	mov	r0, r4
 8024392:	4629      	mov	r1, r5
 8024394:	f004 fa30 	bl	80287f8 <__aeabi_dsub>
 8024398:	ec53 2b1b 	vmov	r2, r3, d11
 802439c:	f004 fa2e 	bl	80287fc <__adddf3>
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80243a0:	4632      	mov	r2, r6
 80243a2:	463b      	mov	r3, r7
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80243a4:	4680      	mov	r8, r0
 80243a6:	4689      	mov	r9, r1
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80243a8:	4650      	mov	r0, sl
 80243aa:	4659      	mov	r1, fp
 80243ac:	f004 fbdc 	bl	8028b68 <__aeabi_dmul>
 80243b0:	ec53 2b19 	vmov	r2, r3, d9
 80243b4:	4604      	mov	r4, r0
 80243b6:	460d      	mov	r5, r1
 80243b8:	ec51 0b18 	vmov	r0, r1, d8
 80243bc:	f004 fbd4 	bl	8028b68 <__aeabi_dmul>
 80243c0:	4602      	mov	r2, r0
 80243c2:	460b      	mov	r3, r1
 80243c4:	4620      	mov	r0, r4
 80243c6:	4629      	mov	r1, r5
 80243c8:	f004 fa18 	bl	80287fc <__adddf3>
 80243cc:	ec53 2b1c 	vmov	r2, r3, d12
 80243d0:	f004 fa14 	bl	80287fc <__adddf3>
 80243d4:	9e07      	ldr	r6, [sp, #28]
 80243d6:	4604      	mov	r4, r0
 80243d8:	f1a6 0a08 	sub.w	sl, r6, #8
 80243dc:	460d      	mov	r5, r1
 80243de:	e6fd      	b.n	80241dc <cblas_ztrmm+0x9a4>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80243e0:	ee1d 0a10 	vmov	r0, s26
 80243e4:	f004 fb56 	bl	8028a94 <__aeabi_i2d>
            const BASE Bij_real = REAL(B, i * ldb + j);
 80243e8:	9c08      	ldr	r4, [sp, #32]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80243ea:	9e10      	ldr	r6, [sp, #64]	; 0x40
            const BASE Bij_real = REAL(B, i * ldb + j);
 80243ec:	4625      	mov	r5, r4
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80243ee:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80243f2:	f004 fbb9 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_real = REAL(B, i * ldb + j);
 80243f6:	ecb5 7b02 	vldmia	r5!, {d7}
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 80243fa:	e9d6 8900 	ldrd	r8, r9, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 80243fe:	eeb0 8a47 	vmov.f32	s16, s14
 8024402:	eef0 8a67 	vmov.f32	s17, s15
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024406:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802440a:	4682      	mov	sl, r0
 802440c:	468b      	mov	fp, r1
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 802440e:	4640      	mov	r0, r8
 8024410:	4649      	mov	r1, r9
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024412:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024416:	950a      	str	r5, [sp, #40]	; 0x28
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024418:	f004 fba6 	bl	8028b68 <__aeabi_dmul>
 802441c:	4632      	mov	r2, r6
 802441e:	4604      	mov	r4, r0
 8024420:	460d      	mov	r5, r1
 8024422:	463b      	mov	r3, r7
 8024424:	4650      	mov	r0, sl
 8024426:	4659      	mov	r1, fp
 8024428:	f004 fb9e 	bl	8028b68 <__aeabi_dmul>
 802442c:	4602      	mov	r2, r0
 802442e:	460b      	mov	r3, r1
 8024430:	4620      	mov	r0, r4
 8024432:	4629      	mov	r1, r5
 8024434:	f004 f9e0 	bl	80287f8 <__aeabi_dsub>
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8024438:	4632      	mov	r2, r6
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 802443a:	4604      	mov	r4, r0
 802443c:	460d      	mov	r5, r1
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 802443e:	463b      	mov	r3, r7
 8024440:	4640      	mov	r0, r8
 8024442:	4649      	mov	r1, r9
 8024444:	f004 fb90 	bl	8028b68 <__aeabi_dmul>
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024448:	ec45 4b1b 	vmov	d11, r4, r5
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 802444c:	ec53 2b18 	vmov	r2, r3, d8
 8024450:	4604      	mov	r4, r0
 8024452:	460d      	mov	r5, r1
 8024454:	4650      	mov	r0, sl
 8024456:	4659      	mov	r1, fp
 8024458:	f004 fb86 	bl	8028b68 <__aeabi_dmul>
 802445c:	4602      	mov	r2, r0
 802445e:	460b      	mov	r3, r1
 8024460:	4620      	mov	r0, r4
 8024462:	4629      	mov	r1, r5
 8024464:	f004 f9ca 	bl	80287fc <__adddf3>
 8024468:	ec41 0b1c 	vmov	d12, r0, r1
 802446c:	f7ff babf 	b.w	80239ee <cblas_ztrmm+0x1b6>
          BASE temp_imag = 0.0;
 8024470:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 80247b0 <cblas_ztrmm+0xf78>
 8024474:	eeb0 ba47 	vmov.f32	s22, s14
 8024478:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 802447c:	eeb0 aa47 	vmov.f32	s20, s14
 8024480:	eef0 aa67 	vmov.f32	s21, s15
 8024484:	e57c      	b.n	8023f80 <cblas_ztrmm+0x748>
          BASE temp_imag = 0.0;
 8024486:	ed9f 7bca 	vldr	d7, [pc, #808]	; 80247b0 <cblas_ztrmm+0xf78>
 802448a:	eeb0 ca47 	vmov.f32	s24, s14
 802448e:	eef0 ca67 	vmov.f32	s25, s15
          BASE temp_real = 0.0;
 8024492:	eeb0 ba47 	vmov.f32	s22, s14
 8024496:	eef0 ba67 	vmov.f32	s23, s15
 802449a:	e688      	b.n	80241ae <cblas_ztrmm+0x976>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 802449c:	ec53 2b1f 	vmov	r2, r3, d15
 80244a0:	ec51 0b1a 	vmov	r0, r1, d10
 80244a4:	f004 fb60 	bl	8028b68 <__aeabi_dmul>
 80244a8:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 80244ac:	ec58 7b1b 	vmov	r7, r8, d11
 80244b0:	4604      	mov	r4, r0
 80244b2:	460d      	mov	r5, r1
 80244b4:	464a      	mov	r2, r9
 80244b6:	4653      	mov	r3, sl
 80244b8:	ee1b 0a10 	vmov	r0, s22
 80244bc:	4641      	mov	r1, r8
 80244be:	f004 fb53 	bl	8028b68 <__aeabi_dmul>
 80244c2:	4602      	mov	r2, r0
 80244c4:	460b      	mov	r3, r1
 80244c6:	4620      	mov	r0, r4
 80244c8:	4629      	mov	r1, r5
 80244ca:	f004 f995 	bl	80287f8 <__aeabi_dsub>
 80244ce:	9e12      	ldr	r6, [sp, #72]	; 0x48
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80244d0:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80244d2:	e946 0104 	strd	r0, r1, [r6, #-16]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80244d6:	4653      	mov	r3, sl
 80244d8:	ec51 0b1a 	vmov	r0, r1, d10
 80244dc:	f004 fb44 	bl	8028b68 <__aeabi_dmul>
 80244e0:	ec53 2b1f 	vmov	r2, r3, d15
 80244e4:	4604      	mov	r4, r0
 80244e6:	460d      	mov	r5, r1
 80244e8:	ee1b 0a10 	vmov	r0, s22
 80244ec:	4641      	mov	r1, r8
 80244ee:	f004 fb3b 	bl	8028b68 <__aeabi_dmul>
 80244f2:	4602      	mov	r2, r0
 80244f4:	460b      	mov	r3, r1
 80244f6:	4620      	mov	r0, r4
 80244f8:	4629      	mov	r1, r5
 80244fa:	f004 f97f 	bl	80287fc <__adddf3>
 80244fe:	e946 0102 	strd	r0, r1, [r6, #-8]
      for (i = 0; i < n1; i++) {
 8024502:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8024504:	9914      	ldr	r1, [sp, #80]	; 0x50
 8024506:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8024508:	440a      	add	r2, r1
 802450a:	9212      	str	r2, [sp, #72]	; 0x48
 802450c:	990c      	ldr	r1, [sp, #48]	; 0x30
 802450e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8024510:	440a      	add	r2, r1
 8024512:	9211      	str	r2, [sp, #68]	; 0x44
 8024514:	9a07      	ldr	r2, [sp, #28]
 8024516:	3301      	adds	r3, #1
 8024518:	429a      	cmp	r2, r3
 802451a:	9313      	str	r3, [sp, #76]	; 0x4c
 802451c:	f47f ab74 	bne.w	8023c08 <cblas_ztrmm+0x3d0>
 8024520:	f7ff bb24 	b.w	8023b6c <cblas_ztrmm+0x334>
      for (i = 0; i < n1; i++) {
 8024524:	9a07      	ldr	r2, [sp, #28]
 8024526:	2a00      	cmp	r2, #0
 8024528:	f77f ab20 	ble.w	8023b6c <cblas_ztrmm+0x334>
 802452c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802452e:	9309      	str	r3, [sp, #36]	; 0x24
 8024530:	3b10      	subs	r3, #16
 8024532:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8024536:	930b      	str	r3, [sp, #44]	; 0x2c
 8024538:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802453a:	9311      	str	r3, [sp, #68]	; 0x44
 802453c:	3401      	adds	r4, #1
 802453e:	0121      	lsls	r1, r4, #4
 8024540:	011a      	lsls	r2, r3, #4
 8024542:	2300      	movs	r3, #0
 8024544:	9114      	str	r1, [sp, #80]	; 0x50
 8024546:	9310      	str	r3, [sp, #64]	; 0x40
 8024548:	3910      	subs	r1, #16
 802454a:	2301      	movs	r3, #1
 802454c:	9113      	str	r1, [sp, #76]	; 0x4c
 802454e:	920e      	str	r2, [sp, #56]	; 0x38
 8024550:	930a      	str	r3, [sp, #40]	; 0x28
        for (j = 0; j < n2; j++) {
 8024552:	9b06      	ldr	r3, [sp, #24]
 8024554:	2b00      	cmp	r3, #0
 8024556:	f340 829f 	ble.w	8024a98 <cblas_ztrmm+0x1260>
 802455a:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 802455e:	1a9b      	subs	r3, r3, r2
 8024560:	011b      	lsls	r3, r3, #4
 8024562:	3308      	adds	r3, #8
 8024564:	930d      	str	r3, [sp, #52]	; 0x34
 8024566:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024568:	9312      	str	r3, [sp, #72]	; 0x48
 802456a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802456c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8024570:	9301      	str	r3, [sp, #4]
 8024572:	2300      	movs	r3, #0
 8024574:	9303      	str	r3, [sp, #12]
          if (nonunit) {
 8024576:	9b02      	ldr	r3, [sp, #8]
 8024578:	2b83      	cmp	r3, #131	; 0x83
 802457a:	f000 80d1 	beq.w	8024720 <cblas_ztrmm+0xee8>
            temp_real = REAL(B, i * ldb + j);
 802457e:	9b01      	ldr	r3, [sp, #4]
 8024580:	461a      	mov	r2, r3
 8024582:	ecb2 7b02 	vldmia	r2!, {d7}
 8024586:	eeb0 ba47 	vmov.f32	s22, s14
 802458a:	eef0 ba67 	vmov.f32	s23, s15
            temp_imag = IMAG(B, i * ldb + j);
 802458e:	ed93 7b02 	vldr	d7, [r3, #8]
            temp_real = REAL(B, i * ldb + j);
 8024592:	9208      	str	r2, [sp, #32]
            temp_imag = IMAG(B, i * ldb + j);
 8024594:	eeb0 ca47 	vmov.f32	s24, s14
 8024598:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 802459c:	9b07      	ldr	r3, [sp, #28]
 802459e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80245a0:	4293      	cmp	r3, r2
 80245a2:	dd63      	ble.n	802466c <cblas_ztrmm+0xe34>
 80245a4:	ee1d 0a10 	vmov	r0, s26
 80245a8:	f004 fa74 	bl	8028a94 <__aeabi_i2d>
 80245ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80245ae:	9a01      	ldr	r2, [sp, #4]
 80245b0:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 80245b4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80245b6:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 80245ba:	4413      	add	r3, r2
 80245bc:	ec41 0b1e 	vmov	d14, r0, r1
 80245c0:	461c      	mov	r4, r3
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80245c2:	e9da 2306 	ldrd	r2, r3, [sl, #24]
 80245c6:	ec51 0b1e 	vmov	r0, r1, d14
 80245ca:	f004 facd 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80245ce:	ed9a 7b04 	vldr	d7, [sl, #16]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 80245d2:	ed14 6b02 	vldr	d6, [r4, #-8]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80245d6:	eeb0 aa47 	vmov.f32	s20, s14
 80245da:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80245de:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 80245e2:	eeb0 9a46 	vmov.f32	s18, s12
 80245e6:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80245ea:	4680      	mov	r8, r0
 80245ec:	4689      	mov	r9, r1
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80245ee:	ec51 0b17 	vmov	r0, r1, d7
 80245f2:	f004 fab9 	bl	8028b68 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 80245f6:	ed94 8b00 	vldr	d8, [r4]
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80245fa:	4606      	mov	r6, r0
 80245fc:	ec53 2b18 	vmov	r2, r3, d8
 8024600:	460f      	mov	r7, r1
 8024602:	4640      	mov	r0, r8
 8024604:	4649      	mov	r1, r9
 8024606:	f004 faaf 	bl	8028b68 <__aeabi_dmul>
 802460a:	4602      	mov	r2, r0
 802460c:	460b      	mov	r3, r1
 802460e:	4630      	mov	r0, r6
 8024610:	4639      	mov	r1, r7
 8024612:	f004 f8f1 	bl	80287f8 <__aeabi_dsub>
 8024616:	4602      	mov	r2, r0
 8024618:	460b      	mov	r3, r1
 802461a:	ec51 0b1b 	vmov	r0, r1, d11
 802461e:	f004 f8ed 	bl	80287fc <__adddf3>
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8024622:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8024626:	4606      	mov	r6, r0
 8024628:	460f      	mov	r7, r1
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 802462a:	ec51 0b1a 	vmov	r0, r1, d10
 802462e:	f004 fa9b 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8024632:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8024636:	ec53 2b19 	vmov	r2, r3, d9
 802463a:	4606      	mov	r6, r0
 802463c:	460f      	mov	r7, r1
 802463e:	4640      	mov	r0, r8
 8024640:	4649      	mov	r1, r9
 8024642:	f004 fa91 	bl	8028b68 <__aeabi_dmul>
 8024646:	4602      	mov	r2, r0
 8024648:	460b      	mov	r3, r1
 802464a:	4630      	mov	r0, r6
 802464c:	4639      	mov	r1, r7
 802464e:	f004 f8d5 	bl	80287fc <__adddf3>
 8024652:	4602      	mov	r2, r0
 8024654:	460b      	mov	r3, r1
 8024656:	ec51 0b1c 	vmov	r0, r1, d12
 802465a:	f004 f8cf 	bl	80287fc <__adddf3>
 802465e:	f10a 0a10 	add.w	sl, sl, #16
          for (k = i + 1; k < n1; k++) {
 8024662:	4555      	cmp	r5, sl
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8024664:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = i + 1; k < n1; k++) {
 8024668:	445c      	add	r4, fp
 802466a:	d1aa      	bne.n	80245c2 <cblas_ztrmm+0xd8a>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 802466c:	ec5b ab1b 	vmov	sl, fp, d11
 8024670:	ec53 2b1f 	vmov	r2, r3, d15
 8024674:	ee1b 0a10 	vmov	r0, s22
 8024678:	4659      	mov	r1, fp
 802467a:	f004 fa75 	bl	8028b68 <__aeabi_dmul>
 802467e:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8024682:	ec57 6b1c 	vmov	r6, r7, d12
 8024686:	4604      	mov	r4, r0
 8024688:	460d      	mov	r5, r1
 802468a:	4642      	mov	r2, r8
 802468c:	464b      	mov	r3, r9
 802468e:	ee1c 0a10 	vmov	r0, s24
 8024692:	4639      	mov	r1, r7
 8024694:	f004 fa68 	bl	8028b68 <__aeabi_dmul>
 8024698:	4602      	mov	r2, r0
 802469a:	460b      	mov	r3, r1
 802469c:	4620      	mov	r0, r4
 802469e:	4629      	mov	r1, r5
 80246a0:	f004 f8aa 	bl	80287f8 <__aeabi_dsub>
 80246a4:	9c01      	ldr	r4, [sp, #4]
 80246a6:	e8e4 0104 	strd	r0, r1, [r4], #16
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80246aa:	ec53 2b1f 	vmov	r2, r3, d15
 80246ae:	ee1c 0a10 	vmov	r0, s24
 80246b2:	4639      	mov	r1, r7
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80246b4:	9401      	str	r4, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80246b6:	f004 fa57 	bl	8028b68 <__aeabi_dmul>
 80246ba:	4642      	mov	r2, r8
 80246bc:	464b      	mov	r3, r9
 80246be:	4604      	mov	r4, r0
 80246c0:	460d      	mov	r5, r1
 80246c2:	ee1b 0a10 	vmov	r0, s22
 80246c6:	4659      	mov	r1, fp
 80246c8:	f004 fa4e 	bl	8028b68 <__aeabi_dmul>
 80246cc:	4602      	mov	r2, r0
 80246ce:	460b      	mov	r3, r1
 80246d0:	4620      	mov	r0, r4
 80246d2:	4629      	mov	r1, r5
 80246d4:	f004 f892 	bl	80287fc <__adddf3>
 80246d8:	9a08      	ldr	r2, [sp, #32]
        for (j = 0; j < n2; j++) {
 80246da:	9b03      	ldr	r3, [sp, #12]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80246dc:	e9c2 0100 	strd	r0, r1, [r2]
        for (j = 0; j < n2; j++) {
 80246e0:	9a06      	ldr	r2, [sp, #24]
 80246e2:	3301      	adds	r3, #1
 80246e4:	429a      	cmp	r2, r3
 80246e6:	9303      	str	r3, [sp, #12]
 80246e8:	f47f af45 	bne.w	8024576 <cblas_ztrmm+0xd3e>
      for (i = 0; i < n1; i++) {
 80246ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80246ee:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80246f0:	3301      	adds	r3, #1
 80246f2:	930a      	str	r3, [sp, #40]	; 0x28
 80246f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80246f6:	4413      	add	r3, r2
 80246f8:	9309      	str	r3, [sp, #36]	; 0x24
 80246fa:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80246fc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80246fe:	4413      	add	r3, r2
 8024700:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8024702:	930b      	str	r3, [sp, #44]	; 0x2c
 8024704:	4611      	mov	r1, r2
 8024706:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024708:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802470a:	441a      	add	r2, r3
 802470c:	4419      	add	r1, r3
 802470e:	9210      	str	r2, [sp, #64]	; 0x40
 8024710:	9b07      	ldr	r3, [sp, #28]
 8024712:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8024714:	9111      	str	r1, [sp, #68]	; 0x44
 8024716:	4293      	cmp	r3, r2
 8024718:	f73f af1b 	bgt.w	8024552 <cblas_ztrmm+0xd1a>
 802471c:	f7ff ba26 	b.w	8023b6c <cblas_ztrmm+0x334>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8024720:	ee1d 0a10 	vmov	r0, s26
 8024724:	f004 f9b6 	bl	8028a94 <__aeabi_i2d>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024728:	9c01      	ldr	r4, [sp, #4]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802472a:	9e09      	ldr	r6, [sp, #36]	; 0x24
            const BASE Bij_real = REAL(B, i * ldb + j);
 802472c:	4625      	mov	r5, r4
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802472e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8024732:	f004 fa19 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024736:	ecb5 7b02 	vldmia	r5!, {d7}
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 802473a:	e9d6 8900 	ldrd	r8, r9, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 802473e:	eeb0 8a47 	vmov.f32	s16, s14
 8024742:	eef0 8a67 	vmov.f32	s17, s15
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024746:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802474a:	4682      	mov	sl, r0
 802474c:	468b      	mov	fp, r1
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 802474e:	4640      	mov	r0, r8
 8024750:	4649      	mov	r1, r9
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024752:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024756:	9508      	str	r5, [sp, #32]
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024758:	f004 fa06 	bl	8028b68 <__aeabi_dmul>
 802475c:	4632      	mov	r2, r6
 802475e:	4604      	mov	r4, r0
 8024760:	460d      	mov	r5, r1
 8024762:	463b      	mov	r3, r7
 8024764:	4650      	mov	r0, sl
 8024766:	4659      	mov	r1, fp
 8024768:	f004 f9fe 	bl	8028b68 <__aeabi_dmul>
 802476c:	4602      	mov	r2, r0
 802476e:	460b      	mov	r3, r1
 8024770:	4620      	mov	r0, r4
 8024772:	4629      	mov	r1, r5
 8024774:	f004 f840 	bl	80287f8 <__aeabi_dsub>
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8024778:	4632      	mov	r2, r6
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 802477a:	4604      	mov	r4, r0
 802477c:	460d      	mov	r5, r1
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 802477e:	463b      	mov	r3, r7
 8024780:	4640      	mov	r0, r8
 8024782:	4649      	mov	r1, r9
 8024784:	f004 f9f0 	bl	8028b68 <__aeabi_dmul>
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024788:	ec45 4b1b 	vmov	d11, r4, r5
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 802478c:	ec53 2b18 	vmov	r2, r3, d8
 8024790:	4604      	mov	r4, r0
 8024792:	460d      	mov	r5, r1
 8024794:	4650      	mov	r0, sl
 8024796:	4659      	mov	r1, fp
 8024798:	f004 f9e6 	bl	8028b68 <__aeabi_dmul>
 802479c:	4602      	mov	r2, r0
 802479e:	460b      	mov	r3, r1
 80247a0:	4620      	mov	r0, r4
 80247a2:	4629      	mov	r1, r5
 80247a4:	f004 f82a 	bl	80287fc <__adddf3>
 80247a8:	ec41 0b1c 	vmov	d12, r0, r1
 80247ac:	e6f6      	b.n	802459c <cblas_ztrmm+0xd64>
 80247ae:	bf00      	nop
	...
      for (i = n1; i > 0 && i--;) {
 80247b8:	9907      	ldr	r1, [sp, #28]
 80247ba:	2900      	cmp	r1, #0
 80247bc:	f77f a9d6 	ble.w	8023b6c <cblas_ztrmm+0x334>
 80247c0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80247c2:	0117      	lsls	r7, r2, #4
 80247c4:	ebc2 7502 	rsb	r5, r2, r2, lsl #28
 80247c8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80247ca:	970b      	str	r7, [sp, #44]	; 0x2c
 80247cc:	1c63      	adds	r3, r4, #1
 80247ce:	1e4e      	subs	r6, r1, #1
 80247d0:	011b      	lsls	r3, r3, #4
 80247d2:	f1a2 0e10 	sub.w	lr, r2, #16
 80247d6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80247d8:	9608      	str	r6, [sp, #32]
 80247da:	f1a3 0010 	sub.w	r0, r3, #16
 80247de:	46bc      	mov	ip, r7
 80247e0:	4637      	mov	r7, r6
 80247e2:	012d      	lsls	r5, r5, #4
 80247e4:	fb07 2000 	mla	r0, r7, r0, r2
 80247e8:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80247ea:	950e      	str	r5, [sp, #56]	; 0x38
 80247ec:	fb07 2203 	mla	r2, r7, r3, r2
 80247f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80247f2:	920c      	str	r2, [sp, #48]	; 0x30
 80247f4:	fb04 1106 	mla	r1, r4, r6, r1
 80247f8:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80247fa:	900a      	str	r0, [sp, #40]	; 0x28
 80247fc:	43e5      	mvns	r5, r4
 80247fe:	fb07 f303 	mul.w	r3, r7, r3
 8024802:	eb0e 1201 	add.w	r2, lr, r1, lsl #4
 8024806:	fb07 660c 	mla	r6, r7, ip, r6
 802480a:	ebc4 7404 	rsb	r4, r4, r4, lsl #28
 802480e:	9307      	str	r3, [sp, #28]
 8024810:	012b      	lsls	r3, r5, #4
 8024812:	9209      	str	r2, [sp, #36]	; 0x24
 8024814:	930f      	str	r3, [sp, #60]	; 0x3c
 8024816:	f106 0208 	add.w	r2, r6, #8
 802481a:	0123      	lsls	r3, r4, #4
 802481c:	920d      	str	r2, [sp, #52]	; 0x34
 802481e:	9310      	str	r3, [sp, #64]	; 0x40
        for (j = 0; j < n2; j++) {
 8024820:	9b06      	ldr	r3, [sp, #24]
 8024822:	2b00      	cmp	r3, #0
 8024824:	f340 80c4 	ble.w	80249b0 <cblas_ztrmm+0x1178>
 8024828:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802482a:	9301      	str	r3, [sp, #4]
 802482c:	2300      	movs	r3, #0
 802482e:	9303      	str	r3, [sp, #12]
          for (k = 0; k < i; k++) {
 8024830:	9b08      	ldr	r3, [sp, #32]
 8024832:	2b00      	cmp	r3, #0
 8024834:	f000 8125 	beq.w	8024a82 <cblas_ztrmm+0x124a>
 8024838:	ee1d 0a10 	vmov	r0, s26
 802483c:	f004 f92a 	bl	8028a94 <__aeabi_i2d>
 8024840:	9b07      	ldr	r3, [sp, #28]
 8024842:	9a01      	ldr	r2, [sp, #4]
 8024844:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
          BASE temp_imag = 0.0;
 8024848:	ed1f 7b27 	vldr	d7, [pc, #-156]	; 80247b0 <cblas_ztrmm+0xf78>
          for (k = 0; k < i; k++) {
 802484c:	e9dd a50a 	ldrd	sl, r5, [sp, #40]	; 0x28
          BASE temp_imag = 0.0;
 8024850:	eeb0 ca47 	vmov.f32	s24, s14
 8024854:	eef0 ca67 	vmov.f32	s25, s15
          BASE temp_real = 0.0;
 8024858:	eeb0 ba47 	vmov.f32	s22, s14
 802485c:	eef0 ba67 	vmov.f32	s23, s15
 8024860:	4413      	add	r3, r2
 8024862:	ec41 0b1e 	vmov	d14, r0, r1
          for (k = 0; k < i; k++) {
 8024866:	461c      	mov	r4, r3
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8024868:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 802486c:	ec51 0b1e 	vmov	r0, r1, d14
 8024870:	f004 f97a 	bl	8028b68 <__aeabi_dmul>
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8024874:	ed9a 7b00 	vldr	d7, [sl]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8024878:	ed14 6b02 	vldr	d6, [r4, #-8]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802487c:	eeb0 aa47 	vmov.f32	s20, s14
 8024880:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8024884:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8024888:	eeb0 9a46 	vmov.f32	s18, s12
 802488c:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8024890:	4680      	mov	r8, r0
 8024892:	4689      	mov	r9, r1
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8024894:	ec51 0b17 	vmov	r0, r1, d7
 8024898:	f004 f966 	bl	8028b68 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 802489c:	ed94 8b00 	vldr	d8, [r4]
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80248a0:	4606      	mov	r6, r0
 80248a2:	ec53 2b18 	vmov	r2, r3, d8
 80248a6:	460f      	mov	r7, r1
 80248a8:	4640      	mov	r0, r8
 80248aa:	4649      	mov	r1, r9
 80248ac:	f004 f95c 	bl	8028b68 <__aeabi_dmul>
 80248b0:	4602      	mov	r2, r0
 80248b2:	460b      	mov	r3, r1
 80248b4:	4630      	mov	r0, r6
 80248b6:	4639      	mov	r1, r7
 80248b8:	f003 ff9e 	bl	80287f8 <__aeabi_dsub>
 80248bc:	4602      	mov	r2, r0
 80248be:	460b      	mov	r3, r1
 80248c0:	ec51 0b1b 	vmov	r0, r1, d11
 80248c4:	f003 ff9a 	bl	80287fc <__adddf3>
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80248c8:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80248cc:	4606      	mov	r6, r0
 80248ce:	460f      	mov	r7, r1
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80248d0:	ec51 0b1a 	vmov	r0, r1, d10
 80248d4:	f004 f948 	bl	8028b68 <__aeabi_dmul>
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80248d8:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80248dc:	ec53 2b19 	vmov	r2, r3, d9
 80248e0:	4606      	mov	r6, r0
 80248e2:	460f      	mov	r7, r1
 80248e4:	4640      	mov	r0, r8
 80248e6:	4649      	mov	r1, r9
 80248e8:	f004 f93e 	bl	8028b68 <__aeabi_dmul>
 80248ec:	4602      	mov	r2, r0
 80248ee:	460b      	mov	r3, r1
 80248f0:	4630      	mov	r0, r6
 80248f2:	4639      	mov	r1, r7
 80248f4:	f003 ff82 	bl	80287fc <__adddf3>
 80248f8:	4602      	mov	r2, r0
 80248fa:	460b      	mov	r3, r1
 80248fc:	ec51 0b1c 	vmov	r0, r1, d12
 8024900:	f003 ff7c 	bl	80287fc <__adddf3>
 8024904:	f10a 0a10 	add.w	sl, sl, #16
          for (k = 0; k < i; k++) {
 8024908:	45d3      	cmp	fp, sl
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 802490a:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < i; k++) {
 802490e:	442c      	add	r4, r5
 8024910:	d1aa      	bne.n	8024868 <cblas_ztrmm+0x1030>
          if (nonunit) {
 8024912:	9b02      	ldr	r3, [sp, #8]
 8024914:	2b83      	cmp	r3, #131	; 0x83
 8024916:	d066      	beq.n	80249e6 <cblas_ztrmm+0x11ae>
            temp_real += REAL(B, i * ldb + j);
 8024918:	9e01      	ldr	r6, [sp, #4]
 802491a:	ec51 0b1b 	vmov	r0, r1, d11
 802491e:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 8024922:	f003 ff6b 	bl	80287fc <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 8024926:	e9d6 2300 	ldrd	r2, r3, [r6]
            temp_real += REAL(B, i * ldb + j);
 802492a:	4604      	mov	r4, r0
 802492c:	460d      	mov	r5, r1
            temp_imag += IMAG(B, i * ldb + j);
 802492e:	ec51 0b1c 	vmov	r0, r1, d12
 8024932:	9601      	str	r6, [sp, #4]
 8024934:	f003 ff62 	bl	80287fc <__adddf3>
 8024938:	9b01      	ldr	r3, [sp, #4]
 802493a:	4606      	mov	r6, r0
 802493c:	460f      	mov	r7, r1
 802493e:	f1a3 0a08 	sub.w	sl, r3, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024942:	ec53 2b1f 	vmov	r2, r3, d15
 8024946:	4620      	mov	r0, r4
 8024948:	4629      	mov	r1, r5
 802494a:	f004 f90d 	bl	8028b68 <__aeabi_dmul>
 802494e:	ed9d 8b04 	vldr	d8, [sp, #16]
 8024952:	4680      	mov	r8, r0
 8024954:	ec53 2b18 	vmov	r2, r3, d8
 8024958:	4689      	mov	r9, r1
 802495a:	4630      	mov	r0, r6
 802495c:	4639      	mov	r1, r7
 802495e:	f004 f903 	bl	8028b68 <__aeabi_dmul>
 8024962:	4602      	mov	r2, r0
 8024964:	460b      	mov	r3, r1
 8024966:	4640      	mov	r0, r8
 8024968:	4649      	mov	r1, r9
 802496a:	f003 ff45 	bl	80287f8 <__aeabi_dsub>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 802496e:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024972:	e9ca 0100 	strd	r0, r1, [sl]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024976:	4630      	mov	r0, r6
 8024978:	4639      	mov	r1, r7
 802497a:	f004 f8f5 	bl	8028b68 <__aeabi_dmul>
 802497e:	ec53 2b18 	vmov	r2, r3, d8
 8024982:	4606      	mov	r6, r0
 8024984:	460f      	mov	r7, r1
 8024986:	4620      	mov	r0, r4
 8024988:	4629      	mov	r1, r5
 802498a:	f004 f8ed 	bl	8028b68 <__aeabi_dmul>
 802498e:	4602      	mov	r2, r0
 8024990:	460b      	mov	r3, r1
 8024992:	4630      	mov	r0, r6
 8024994:	4639      	mov	r1, r7
 8024996:	f003 ff31 	bl	80287fc <__adddf3>
 802499a:	9a01      	ldr	r2, [sp, #4]
        for (j = 0; j < n2; j++) {
 802499c:	9b03      	ldr	r3, [sp, #12]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 802499e:	e8e2 0104 	strd	r0, r1, [r2], #16
 80249a2:	9201      	str	r2, [sp, #4]
        for (j = 0; j < n2; j++) {
 80249a4:	9a06      	ldr	r2, [sp, #24]
 80249a6:	3301      	adds	r3, #1
 80249a8:	429a      	cmp	r2, r3
 80249aa:	9303      	str	r3, [sp, #12]
 80249ac:	f47f af40 	bne.w	8024830 <cblas_ztrmm+0xff8>
      for (i = n1; i > 0 && i--;) {
 80249b0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80249b2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80249b4:	4611      	mov	r1, r2
 80249b6:	4419      	add	r1, r3
 80249b8:	910c      	str	r1, [sp, #48]	; 0x30
 80249ba:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
 80249be:	440a      	add	r2, r1
 80249c0:	920d      	str	r2, [sp, #52]	; 0x34
 80249c2:	9910      	ldr	r1, [sp, #64]	; 0x40
 80249c4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80249c6:	440a      	add	r2, r1
 80249c8:	920a      	str	r2, [sp, #40]	; 0x28
 80249ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80249cc:	441a      	add	r2, r3
 80249ce:	9209      	str	r2, [sp, #36]	; 0x24
 80249d0:	9b07      	ldr	r3, [sp, #28]
 80249d2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80249d4:	4413      	add	r3, r2
 80249d6:	9307      	str	r3, [sp, #28]
 80249d8:	9b08      	ldr	r3, [sp, #32]
 80249da:	2b00      	cmp	r3, #0
 80249dc:	f43f a8c6 	beq.w	8023b6c <cblas_ztrmm+0x334>
 80249e0:	3b01      	subs	r3, #1
 80249e2:	9308      	str	r3, [sp, #32]
 80249e4:	e71c      	b.n	8024820 <cblas_ztrmm+0xfe8>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80249e6:	ee1d 0a10 	vmov	r0, s26
 80249ea:	f004 f853 	bl	8028a94 <__aeabi_i2d>
 80249ee:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80249f0:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80249f4:	f004 f8b8 	bl	8028b68 <__aeabi_dmul>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 80249f8:	e9d4 8900 	ldrd	r8, r9, [r4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 80249fc:	9c01      	ldr	r4, [sp, #4]
 80249fe:	ed14 7b02 	vldr	d7, [r4, #-8]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8024a02:	4682      	mov	sl, r0
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024a04:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024a08:	eeb0 8a47 	vmov.f32	s16, s14
 8024a0c:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8024a10:	468b      	mov	fp, r1
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024a12:	4640      	mov	r0, r8
 8024a14:	4649      	mov	r1, r9
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024a16:	e9d4 6700 	ldrd	r6, r7, [r4]
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024a1a:	f004 f8a5 	bl	8028b68 <__aeabi_dmul>
 8024a1e:	4632      	mov	r2, r6
 8024a20:	463b      	mov	r3, r7
 8024a22:	4604      	mov	r4, r0
 8024a24:	460d      	mov	r5, r1
 8024a26:	4650      	mov	r0, sl
 8024a28:	4659      	mov	r1, fp
 8024a2a:	f004 f89d 	bl	8028b68 <__aeabi_dmul>
 8024a2e:	4602      	mov	r2, r0
 8024a30:	460b      	mov	r3, r1
 8024a32:	4620      	mov	r0, r4
 8024a34:	4629      	mov	r1, r5
 8024a36:	f003 fedf 	bl	80287f8 <__aeabi_dsub>
 8024a3a:	ec53 2b1b 	vmov	r2, r3, d11
 8024a3e:	f003 fedd 	bl	80287fc <__adddf3>
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8024a42:	4632      	mov	r2, r6
 8024a44:	463b      	mov	r3, r7
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8024a46:	4604      	mov	r4, r0
 8024a48:	460d      	mov	r5, r1
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8024a4a:	4640      	mov	r0, r8
 8024a4c:	4649      	mov	r1, r9
 8024a4e:	f004 f88b 	bl	8028b68 <__aeabi_dmul>
 8024a52:	ec53 2b18 	vmov	r2, r3, d8
 8024a56:	4606      	mov	r6, r0
 8024a58:	460f      	mov	r7, r1
 8024a5a:	4650      	mov	r0, sl
 8024a5c:	4659      	mov	r1, fp
 8024a5e:	f004 f883 	bl	8028b68 <__aeabi_dmul>
 8024a62:	4602      	mov	r2, r0
 8024a64:	460b      	mov	r3, r1
 8024a66:	4630      	mov	r0, r6
 8024a68:	4639      	mov	r1, r7
 8024a6a:	f003 fec7 	bl	80287fc <__adddf3>
 8024a6e:	ec53 2b1c 	vmov	r2, r3, d12
 8024a72:	f003 fec3 	bl	80287fc <__adddf3>
 8024a76:	9b01      	ldr	r3, [sp, #4]
 8024a78:	4606      	mov	r6, r0
 8024a7a:	f1a3 0a08 	sub.w	sl, r3, #8
 8024a7e:	460f      	mov	r7, r1
 8024a80:	e75f      	b.n	8024942 <cblas_ztrmm+0x110a>
          BASE temp_imag = 0.0;
 8024a82:	ed1f 7bb5 	vldr	d7, [pc, #-724]	; 80247b0 <cblas_ztrmm+0xf78>
 8024a86:	eeb0 ca47 	vmov.f32	s24, s14
 8024a8a:	eef0 ca67 	vmov.f32	s25, s15
          BASE temp_real = 0.0;
 8024a8e:	eeb0 ba47 	vmov.f32	s22, s14
 8024a92:	eef0 ba67 	vmov.f32	s23, s15
 8024a96:	e73c      	b.n	8024912 <cblas_ztrmm+0x10da>
 8024a98:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024a9a:	9312      	str	r3, [sp, #72]	; 0x48
 8024a9c:	e626      	b.n	80246ec <cblas_ztrmm+0xeb4>
      for (i = 0; i < n1; i++) {
 8024a9e:	2b00      	cmp	r3, #0
 8024aa0:	f77f a864 	ble.w	8023b6c <cblas_ztrmm+0x334>
 8024aa4:	1c63      	adds	r3, r4, #1
 8024aa6:	43e4      	mvns	r4, r4
 8024aa8:	9a06      	ldr	r2, [sp, #24]
 8024aaa:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8024aac:	0124      	lsls	r4, r4, #4
 8024aae:	940c      	str	r4, [sp, #48]	; 0x30
 8024ab0:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8024ab2:	011b      	lsls	r3, r3, #4
 8024ab4:	1e51      	subs	r1, r2, #1
 8024ab6:	4610      	mov	r0, r2
 8024ab8:	fb03 4101 	mla	r1, r3, r1, r4
 8024abc:	3b10      	subs	r3, #16
 8024abe:	012d      	lsls	r5, r5, #4
 8024ac0:	0112      	lsls	r2, r2, #4
 8024ac2:	9303      	str	r3, [sp, #12]
 8024ac4:	eb04 1300 	add.w	r3, r4, r0, lsl #4
 8024ac8:	950e      	str	r5, [sp, #56]	; 0x38
 8024aca:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8024acc:	930f      	str	r3, [sp, #60]	; 0x3c
 8024ace:	f1a2 0310 	sub.w	r3, r2, #16
 8024ad2:	9311      	str	r3, [sp, #68]	; 0x44
 8024ad4:	2300      	movs	r3, #0
 8024ad6:	950b      	str	r5, [sp, #44]	; 0x2c
 8024ad8:	9110      	str	r1, [sp, #64]	; 0x40
 8024ada:	930d      	str	r3, [sp, #52]	; 0x34
        for (j = n2; j > 0 && j--;) {
 8024adc:	9b06      	ldr	r3, [sp, #24]
 8024ade:	2b00      	cmp	r3, #0
 8024ae0:	f340 80c6 	ble.w	8024c70 <cblas_ztrmm+0x1438>
 8024ae4:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8024ae6:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8024ae8:	9308      	str	r3, [sp, #32]
 8024aea:	440a      	add	r2, r1
 8024aec:	9201      	str	r2, [sp, #4]
 8024aee:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8024af0:	9209      	str	r2, [sp, #36]	; 0x24
 8024af2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024af4:	920a      	str	r2, [sp, #40]	; 0x28
          for (k = 0; k < j; k++) {
 8024af6:	9b08      	ldr	r3, [sp, #32]
 8024af8:	3b01      	subs	r3, #1
 8024afa:	9308      	str	r3, [sp, #32]
 8024afc:	f000 8116 	beq.w	8024d2c <cblas_ztrmm+0x14f4>
 8024b00:	ee1d 0a10 	vmov	r0, s26
 8024b04:	f003 ffc6 	bl	8028a94 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 8024b08:	ed9f 7b91 	vldr	d7, [pc, #580]	; 8024d50 <cblas_ztrmm+0x1518>
 8024b0c:	ec41 0b1c 	vmov	d12, r0, r1
 8024b10:	eeb0 ba47 	vmov.f32	s22, s14
 8024b14:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < j; k++) {
 8024b18:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8024b1a:	9d09      	ldr	r5, [sp, #36]	; 0x24
          BASE temp_real = 0.0;
 8024b1c:	eeb0 aa47 	vmov.f32	s20, s14
 8024b20:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8024b24:	e955 2302 	ldrd	r2, r3, [r5, #-8]
 8024b28:	ec51 0b1c 	vmov	r0, r1, d12
 8024b2c:	f004 f81c 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_real = REAL(B, i * ldb + k);
 8024b30:	ed94 6b00 	vldr	d6, [r4]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8024b34:	ed15 7b04 	vldr	d7, [r5, #-16]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8024b38:	eeb0 8a46 	vmov.f32	s16, s12
 8024b3c:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024b40:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8024b44:	eeb0 9a47 	vmov.f32	s18, s14
 8024b48:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8024b4c:	4680      	mov	r8, r0
 8024b4e:	4689      	mov	r9, r1
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024b50:	ec51 0b17 	vmov	r0, r1, d7
 8024b54:	f004 f808 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8024b58:	e9d4 ab02 	ldrd	sl, fp, [r4, #8]
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024b5c:	4606      	mov	r6, r0
 8024b5e:	460f      	mov	r7, r1
 8024b60:	4652      	mov	r2, sl
 8024b62:	465b      	mov	r3, fp
 8024b64:	4640      	mov	r0, r8
 8024b66:	4649      	mov	r1, r9
 8024b68:	f003 fffe 	bl	8028b68 <__aeabi_dmul>
 8024b6c:	4602      	mov	r2, r0
 8024b6e:	460b      	mov	r3, r1
 8024b70:	4630      	mov	r0, r6
 8024b72:	4639      	mov	r1, r7
 8024b74:	f003 fe40 	bl	80287f8 <__aeabi_dsub>
 8024b78:	4602      	mov	r2, r0
 8024b7a:	460b      	mov	r3, r1
 8024b7c:	ec51 0b1a 	vmov	r0, r1, d10
 8024b80:	f003 fe3c 	bl	80287fc <__adddf3>
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024b84:	4652      	mov	r2, sl
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024b86:	4606      	mov	r6, r0
 8024b88:	460f      	mov	r7, r1
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024b8a:	465b      	mov	r3, fp
 8024b8c:	ec51 0b19 	vmov	r0, r1, d9
 8024b90:	f003 ffea 	bl	8028b68 <__aeabi_dmul>
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024b94:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024b98:	ec53 2b18 	vmov	r2, r3, d8
 8024b9c:	4606      	mov	r6, r0
 8024b9e:	460f      	mov	r7, r1
 8024ba0:	4640      	mov	r0, r8
 8024ba2:	4649      	mov	r1, r9
 8024ba4:	f003 ffe0 	bl	8028b68 <__aeabi_dmul>
 8024ba8:	4602      	mov	r2, r0
 8024baa:	460b      	mov	r3, r1
 8024bac:	4630      	mov	r0, r6
 8024bae:	4639      	mov	r1, r7
 8024bb0:	f003 fe24 	bl	80287fc <__adddf3>
 8024bb4:	460b      	mov	r3, r1
 8024bb6:	4602      	mov	r2, r0
 8024bb8:	ec51 0b1b 	vmov	r0, r1, d11
 8024bbc:	f003 fe1e 	bl	80287fc <__adddf3>
 8024bc0:	9b03      	ldr	r3, [sp, #12]
 8024bc2:	441d      	add	r5, r3
          for (k = 0; k < j; k++) {
 8024bc4:	9b01      	ldr	r3, [sp, #4]
 8024bc6:	3410      	adds	r4, #16
 8024bc8:	42a3      	cmp	r3, r4
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024bca:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < j; k++) {
 8024bce:	d1a9      	bne.n	8024b24 <cblas_ztrmm+0x12ec>
          if (nonunit) {
 8024bd0:	9b02      	ldr	r3, [sp, #8]
 8024bd2:	2b83      	cmp	r3, #131	; 0x83
 8024bd4:	d059      	beq.n	8024c8a <cblas_ztrmm+0x1452>
            temp_real += REAL(B, i * ldb + j);
 8024bd6:	9c01      	ldr	r4, [sp, #4]
 8024bd8:	4626      	mov	r6, r4
 8024bda:	e8f6 2302 	ldrd	r2, r3, [r6], #8
 8024bde:	ec51 0b1a 	vmov	r0, r1, d10
 8024be2:	f003 fe0b 	bl	80287fc <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 8024be6:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
            temp_real += REAL(B, i * ldb + j);
 8024bea:	4682      	mov	sl, r0
 8024bec:	468b      	mov	fp, r1
            temp_imag += IMAG(B, i * ldb + j);
 8024bee:	ec51 0b1b 	vmov	r0, r1, d11
 8024bf2:	f003 fe03 	bl	80287fc <__adddf3>
 8024bf6:	4604      	mov	r4, r0
 8024bf8:	460d      	mov	r5, r1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024bfa:	ec53 2b1f 	vmov	r2, r3, d15
 8024bfe:	4650      	mov	r0, sl
 8024c00:	4659      	mov	r1, fp
 8024c02:	f003 ffb1 	bl	8028b68 <__aeabi_dmul>
 8024c06:	ed9d 8b04 	vldr	d8, [sp, #16]
 8024c0a:	4680      	mov	r8, r0
 8024c0c:	ec53 2b18 	vmov	r2, r3, d8
 8024c10:	4689      	mov	r9, r1
 8024c12:	4620      	mov	r0, r4
 8024c14:	4629      	mov	r1, r5
 8024c16:	f003 ffa7 	bl	8028b68 <__aeabi_dmul>
 8024c1a:	4602      	mov	r2, r0
 8024c1c:	460b      	mov	r3, r1
 8024c1e:	4640      	mov	r0, r8
 8024c20:	4649      	mov	r1, r9
 8024c22:	f003 fde9 	bl	80287f8 <__aeabi_dsub>
 8024c26:	9f01      	ldr	r7, [sp, #4]
 8024c28:	e867 0104 	strd	r0, r1, [r7], #-16
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024c2c:	ec53 2b1f 	vmov	r2, r3, d15
 8024c30:	4620      	mov	r0, r4
 8024c32:	4629      	mov	r1, r5
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024c34:	9701      	str	r7, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024c36:	f003 ff97 	bl	8028b68 <__aeabi_dmul>
 8024c3a:	ec53 2b18 	vmov	r2, r3, d8
 8024c3e:	4604      	mov	r4, r0
 8024c40:	460d      	mov	r5, r1
 8024c42:	4650      	mov	r0, sl
 8024c44:	4659      	mov	r1, fp
 8024c46:	f003 ff8f 	bl	8028b68 <__aeabi_dmul>
 8024c4a:	4602      	mov	r2, r0
 8024c4c:	460b      	mov	r3, r1
 8024c4e:	4620      	mov	r0, r4
 8024c50:	4629      	mov	r1, r5
 8024c52:	f003 fdd3 	bl	80287fc <__adddf3>
 8024c56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024c58:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8024c5a:	4413      	add	r3, r2
 8024c5c:	930a      	str	r3, [sp, #40]	; 0x28
 8024c5e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024c60:	3b10      	subs	r3, #16
 8024c62:	9309      	str	r3, [sp, #36]	; 0x24
        for (j = n2; j > 0 && j--;) {
 8024c64:	9b08      	ldr	r3, [sp, #32]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024c66:	e9c6 0100 	strd	r0, r1, [r6]
        for (j = n2; j > 0 && j--;) {
 8024c6a:	2b00      	cmp	r3, #0
 8024c6c:	f47f af43 	bne.w	8024af6 <cblas_ztrmm+0x12be>
      for (i = 0; i < n1; i++) {
 8024c70:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8024c72:	990e      	ldr	r1, [sp, #56]	; 0x38
 8024c74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8024c76:	440a      	add	r2, r1
 8024c78:	920b      	str	r2, [sp, #44]	; 0x2c
 8024c7a:	9a07      	ldr	r2, [sp, #28]
 8024c7c:	3301      	adds	r3, #1
 8024c7e:	429a      	cmp	r2, r3
 8024c80:	930d      	str	r3, [sp, #52]	; 0x34
 8024c82:	f47f af2b 	bne.w	8024adc <cblas_ztrmm+0x12a4>
 8024c86:	f7fe bf71 	b.w	8023b6c <cblas_ztrmm+0x334>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024c8a:	ee1d 0a10 	vmov	r0, s26
 8024c8e:	f003 ff01 	bl	8028a94 <__aeabi_i2d>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024c92:	f8dd 8004 	ldr.w	r8, [sp, #4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024c96:	9f0a      	ldr	r7, [sp, #40]	; 0x28
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024c98:	4646      	mov	r6, r8
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024c9a:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8024c9e:	f003 ff63 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024ca2:	ecb6 7b02 	vldmia	r6!, {d7}
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8024ca6:	e9d7 ab00 	ldrd	sl, fp, [r7]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024caa:	eeb0 9a47 	vmov.f32	s18, s14
 8024cae:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024cb2:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024cb6:	4604      	mov	r4, r0
 8024cb8:	460d      	mov	r5, r1
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024cba:	4650      	mov	r0, sl
 8024cbc:	4659      	mov	r1, fp
 8024cbe:	f003 ff53 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024cc2:	e9d8 8902 	ldrd	r8, r9, [r8, #8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024cc6:	ec45 4b18 	vmov	d8, r4, r5
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024cca:	4642      	mov	r2, r8
 8024ccc:	4604      	mov	r4, r0
 8024cce:	460d      	mov	r5, r1
 8024cd0:	464b      	mov	r3, r9
 8024cd2:	ec51 0b18 	vmov	r0, r1, d8
 8024cd6:	f003 ff47 	bl	8028b68 <__aeabi_dmul>
 8024cda:	4602      	mov	r2, r0
 8024cdc:	460b      	mov	r3, r1
 8024cde:	4620      	mov	r0, r4
 8024ce0:	4629      	mov	r1, r5
 8024ce2:	f003 fd89 	bl	80287f8 <__aeabi_dsub>
 8024ce6:	ec53 2b1a 	vmov	r2, r3, d10
 8024cea:	f003 fd87 	bl	80287fc <__adddf3>
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024cee:	4642      	mov	r2, r8
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024cf0:	4604      	mov	r4, r0
 8024cf2:	460d      	mov	r5, r1
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024cf4:	464b      	mov	r3, r9
 8024cf6:	4650      	mov	r0, sl
 8024cf8:	4659      	mov	r1, fp
 8024cfa:	f003 ff35 	bl	8028b68 <__aeabi_dmul>
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024cfe:	46a2      	mov	sl, r4
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024d00:	ec53 2b19 	vmov	r2, r3, d9
 8024d04:	4604      	mov	r4, r0
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024d06:	46ab      	mov	fp, r5
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024d08:	460d      	mov	r5, r1
 8024d0a:	ec51 0b18 	vmov	r0, r1, d8
 8024d0e:	f003 ff2b 	bl	8028b68 <__aeabi_dmul>
 8024d12:	4602      	mov	r2, r0
 8024d14:	460b      	mov	r3, r1
 8024d16:	4620      	mov	r0, r4
 8024d18:	4629      	mov	r1, r5
 8024d1a:	f003 fd6f 	bl	80287fc <__adddf3>
 8024d1e:	ec53 2b1b 	vmov	r2, r3, d11
 8024d22:	f003 fd6b 	bl	80287fc <__adddf3>
 8024d26:	4604      	mov	r4, r0
 8024d28:	460d      	mov	r5, r1
 8024d2a:	e766      	b.n	8024bfa <cblas_ztrmm+0x13c2>
          BASE temp_imag = 0.0;
 8024d2c:	ed9f 7b08 	vldr	d7, [pc, #32]	; 8024d50 <cblas_ztrmm+0x1518>
 8024d30:	eeb0 ba47 	vmov.f32	s22, s14
 8024d34:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 8024d38:	eeb0 aa47 	vmov.f32	s20, s14
 8024d3c:	eef0 aa67 	vmov.f32	s21, s15
 8024d40:	e746      	b.n	8024bd0 <cblas_ztrmm+0x1398>
 8024d42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024d44:	9313      	str	r3, [sp, #76]	; 0x4c
 8024d46:	f7fe bef9 	b.w	8023b3c <cblas_ztrmm+0x304>
 8024d4a:	bf00      	nop
 8024d4c:	f3af 8000 	nop.w
	...
      for (i = 0; i < n1; i++) {
 8024d58:	2b00      	cmp	r3, #0
 8024d5a:	f77e af07 	ble.w	8023b6c <cblas_ztrmm+0x334>
 8024d5e:	0121      	lsls	r1, r4, #4
 8024d60:	3401      	adds	r4, #1
 8024d62:	0124      	lsls	r4, r4, #4
 8024d64:	940e      	str	r4, [sp, #56]	; 0x38
 8024d66:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8024d68:	9b06      	ldr	r3, [sp, #24]
 8024d6a:	9103      	str	r1, [sp, #12]
 8024d6c:	f101 0208 	add.w	r2, r1, #8
 8024d70:	18a2      	adds	r2, r4, r2
 8024d72:	9214      	str	r2, [sp, #80]	; 0x50
 8024d74:	f101 0210 	add.w	r2, r1, #16
 8024d78:	920d      	str	r2, [sp, #52]	; 0x34
 8024d7a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8024d7c:	3b01      	subs	r3, #1
 8024d7e:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8024d82:	9301      	str	r3, [sp, #4]
 8024d84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024d86:	2000      	movs	r0, #0
 8024d88:	011b      	lsls	r3, r3, #4
 8024d8a:	9011      	str	r0, [sp, #68]	; 0x44
 8024d8c:	9012      	str	r0, [sp, #72]	; 0x48
 8024d8e:	9313      	str	r3, [sp, #76]	; 0x4c
        for (j = 0; j < n2; j++) {
 8024d90:	9b06      	ldr	r3, [sp, #24]
 8024d92:	2b00      	cmp	r3, #0
 8024d94:	f340 813c 	ble.w	8025010 <cblas_ztrmm+0x17d8>
 8024d98:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8024d9a:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8024d9c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8024da0:	9308      	str	r3, [sp, #32]
 8024da2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8024da4:	3308      	adds	r3, #8
 8024da6:	930a      	str	r3, [sp, #40]	; 0x28
 8024da8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8024daa:	9309      	str	r3, [sp, #36]	; 0x24
 8024dac:	2300      	movs	r3, #0
 8024dae:	930b      	str	r3, [sp, #44]	; 0x2c
          if (nonunit) {
 8024db0:	9b02      	ldr	r3, [sp, #8]
 8024db2:	2b83      	cmp	r3, #131	; 0x83
 8024db4:	f000 80b4 	beq.w	8024f20 <cblas_ztrmm+0x16e8>
            temp_real = REAL(B, i * ldb + j);
 8024db8:	9b08      	ldr	r3, [sp, #32]
 8024dba:	ed93 7b00 	vldr	d7, [r3]
 8024dbe:	eeb0 aa47 	vmov.f32	s20, s14
 8024dc2:	eef0 aa67 	vmov.f32	s21, s15
            temp_imag = IMAG(B, i * ldb + j);
 8024dc6:	ed93 7b02 	vldr	d7, [r3, #8]
 8024dca:	eeb0 ba47 	vmov.f32	s22, s14
 8024dce:	eef0 ba67 	vmov.f32	s23, s15
          for (k = j + 1; k < n2; k++) {
 8024dd2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024dd4:	9a06      	ldr	r2, [sp, #24]
 8024dd6:	3301      	adds	r3, #1
 8024dd8:	429a      	cmp	r2, r3
 8024dda:	930b      	str	r3, [sp, #44]	; 0x2c
 8024ddc:	f000 80e5 	beq.w	8024faa <cblas_ztrmm+0x1772>
 8024de0:	ee1d 0a10 	vmov	r0, s26
 8024de4:	f003 fe56 	bl	8028a94 <__aeabi_i2d>
 8024de8:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 8024dec:	ec41 0b1c 	vmov	d12, r0, r1
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8024df0:	e9d5 2300 	ldrd	r2, r3, [r5]
 8024df4:	ec51 0b1c 	vmov	r0, r1, d12
 8024df8:	f003 feb6 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_real = REAL(B, i * ldb + k);
 8024dfc:	ed94 6b04 	vldr	d6, [r4, #16]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8024e00:	ed15 7b02 	vldr	d7, [r5, #-8]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8024e04:	eeb0 8a46 	vmov.f32	s16, s12
 8024e08:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024e0c:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8024e10:	eeb0 9a47 	vmov.f32	s18, s14
 8024e14:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8024e18:	4680      	mov	r8, r0
 8024e1a:	4689      	mov	r9, r1
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024e1c:	ec51 0b17 	vmov	r0, r1, d7
 8024e20:	f003 fea2 	bl	8028b68 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8024e24:	e9d4 ab06 	ldrd	sl, fp, [r4, #24]
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024e28:	4606      	mov	r6, r0
 8024e2a:	460f      	mov	r7, r1
 8024e2c:	4652      	mov	r2, sl
 8024e2e:	465b      	mov	r3, fp
 8024e30:	4640      	mov	r0, r8
 8024e32:	4649      	mov	r1, r9
 8024e34:	f003 fe98 	bl	8028b68 <__aeabi_dmul>
 8024e38:	4602      	mov	r2, r0
 8024e3a:	460b      	mov	r3, r1
 8024e3c:	4630      	mov	r0, r6
 8024e3e:	4639      	mov	r1, r7
 8024e40:	f003 fcda 	bl	80287f8 <__aeabi_dsub>
 8024e44:	4602      	mov	r2, r0
 8024e46:	460b      	mov	r3, r1
 8024e48:	ec51 0b1a 	vmov	r0, r1, d10
 8024e4c:	f003 fcd6 	bl	80287fc <__adddf3>
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024e50:	4652      	mov	r2, sl
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024e52:	4606      	mov	r6, r0
 8024e54:	460f      	mov	r7, r1
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024e56:	465b      	mov	r3, fp
 8024e58:	ec51 0b19 	vmov	r0, r1, d9
 8024e5c:	f003 fe84 	bl	8028b68 <__aeabi_dmul>
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024e60:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024e64:	ec53 2b18 	vmov	r2, r3, d8
 8024e68:	4606      	mov	r6, r0
 8024e6a:	460f      	mov	r7, r1
 8024e6c:	4640      	mov	r0, r8
 8024e6e:	4649      	mov	r1, r9
 8024e70:	f003 fe7a 	bl	8028b68 <__aeabi_dmul>
 8024e74:	4602      	mov	r2, r0
 8024e76:	460b      	mov	r3, r1
 8024e78:	4630      	mov	r0, r6
 8024e7a:	4639      	mov	r1, r7
 8024e7c:	f003 fcbe 	bl	80287fc <__adddf3>
 8024e80:	460b      	mov	r3, r1
 8024e82:	4602      	mov	r2, r0
 8024e84:	ec51 0b1b 	vmov	r0, r1, d11
 8024e88:	f003 fcb8 	bl	80287fc <__adddf3>
 8024e8c:	9b03      	ldr	r3, [sp, #12]
 8024e8e:	441d      	add	r5, r3
          for (k = j + 1; k < n2; k++) {
 8024e90:	9b01      	ldr	r3, [sp, #4]
 8024e92:	3410      	adds	r4, #16
 8024e94:	429c      	cmp	r4, r3
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024e96:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = j + 1; k < n2; k++) {
 8024e9a:	d1a9      	bne.n	8024df0 <cblas_ztrmm+0x15b8>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024e9c:	ec53 2b1f 	vmov	r2, r3, d15
 8024ea0:	ec51 0b1a 	vmov	r0, r1, d10
 8024ea4:	f003 fe60 	bl	8028b68 <__aeabi_dmul>
 8024ea8:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 8024eac:	ec58 7b1b 	vmov	r7, r8, d11
 8024eb0:	4604      	mov	r4, r0
 8024eb2:	460d      	mov	r5, r1
 8024eb4:	464a      	mov	r2, r9
 8024eb6:	4653      	mov	r3, sl
 8024eb8:	ee1b 0a10 	vmov	r0, s22
 8024ebc:	4641      	mov	r1, r8
 8024ebe:	f003 fe53 	bl	8028b68 <__aeabi_dmul>
 8024ec2:	4602      	mov	r2, r0
 8024ec4:	460b      	mov	r3, r1
 8024ec6:	4620      	mov	r0, r4
 8024ec8:	4629      	mov	r1, r5
 8024eca:	f003 fc95 	bl	80287f8 <__aeabi_dsub>
 8024ece:	9e08      	ldr	r6, [sp, #32]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024ed0:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024ed2:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024ed6:	4653      	mov	r3, sl
 8024ed8:	ec51 0b1a 	vmov	r0, r1, d10
 8024edc:	f003 fe44 	bl	8028b68 <__aeabi_dmul>
 8024ee0:	ec53 2b1f 	vmov	r2, r3, d15
 8024ee4:	4604      	mov	r4, r0
 8024ee6:	460d      	mov	r5, r1
 8024ee8:	ee1b 0a10 	vmov	r0, s22
 8024eec:	4641      	mov	r1, r8
 8024eee:	f003 fe3b 	bl	8028b68 <__aeabi_dmul>
 8024ef2:	4602      	mov	r2, r0
 8024ef4:	460b      	mov	r3, r1
 8024ef6:	4620      	mov	r0, r4
 8024ef8:	4629      	mov	r1, r5
 8024efa:	f003 fc7f 	bl	80287fc <__adddf3>
 8024efe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024f00:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8024f02:	4413      	add	r3, r2
 8024f04:	9309      	str	r3, [sp, #36]	; 0x24
 8024f06:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8024f08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024f0a:	4413      	add	r3, r2
 8024f0c:	930a      	str	r3, [sp, #40]	; 0x28
 8024f0e:	f106 0310 	add.w	r3, r6, #16
 8024f12:	9308      	str	r3, [sp, #32]
          if (nonunit) {
 8024f14:	9b02      	ldr	r3, [sp, #8]
 8024f16:	2b83      	cmp	r3, #131	; 0x83
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024f18:	e9c6 0102 	strd	r0, r1, [r6, #8]
          if (nonunit) {
 8024f1c:	f47f af4c 	bne.w	8024db8 <cblas_ztrmm+0x1580>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024f20:	ee1d 0a10 	vmov	r0, s26
 8024f24:	f003 fdb6 	bl	8028a94 <__aeabi_i2d>
 8024f28:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8024f2a:	e9d4 2300 	ldrd	r2, r3, [r4]
 8024f2e:	f003 fe1b 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8024f32:	e954 8902 	ldrd	r8, r9, [r4, #-8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024f36:	9c08      	ldr	r4, [sp, #32]
 8024f38:	ed94 7b00 	vldr	d7, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024f3c:	4682      	mov	sl, r0
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024f3e:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024f42:	eeb0 8a47 	vmov.f32	s16, s14
 8024f46:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024f4a:	468b      	mov	fp, r1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024f4c:	4640      	mov	r0, r8
 8024f4e:	4649      	mov	r1, r9
 8024f50:	f003 fe0a 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024f54:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024f58:	460d      	mov	r5, r1
 8024f5a:	4604      	mov	r4, r0
 8024f5c:	4632      	mov	r2, r6
 8024f5e:	463b      	mov	r3, r7
 8024f60:	4650      	mov	r0, sl
 8024f62:	4659      	mov	r1, fp
 8024f64:	f003 fe00 	bl	8028b68 <__aeabi_dmul>
 8024f68:	4602      	mov	r2, r0
 8024f6a:	460b      	mov	r3, r1
 8024f6c:	4620      	mov	r0, r4
 8024f6e:	4629      	mov	r1, r5
 8024f70:	f003 fc42 	bl	80287f8 <__aeabi_dsub>
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024f74:	4632      	mov	r2, r6
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024f76:	4604      	mov	r4, r0
 8024f78:	460d      	mov	r5, r1
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024f7a:	463b      	mov	r3, r7
 8024f7c:	4640      	mov	r0, r8
 8024f7e:	4649      	mov	r1, r9
 8024f80:	f003 fdf2 	bl	8028b68 <__aeabi_dmul>
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024f84:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024f88:	ec53 2b18 	vmov	r2, r3, d8
 8024f8c:	4604      	mov	r4, r0
 8024f8e:	460d      	mov	r5, r1
 8024f90:	4650      	mov	r0, sl
 8024f92:	4659      	mov	r1, fp
 8024f94:	f003 fde8 	bl	8028b68 <__aeabi_dmul>
 8024f98:	4602      	mov	r2, r0
 8024f9a:	460b      	mov	r3, r1
 8024f9c:	4620      	mov	r0, r4
 8024f9e:	4629      	mov	r1, r5
 8024fa0:	f003 fc2c 	bl	80287fc <__adddf3>
 8024fa4:	ec41 0b1b 	vmov	d11, r0, r1
 8024fa8:	e713      	b.n	8024dd2 <cblas_ztrmm+0x159a>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024faa:	ec53 2b1f 	vmov	r2, r3, d15
 8024fae:	ec51 0b1a 	vmov	r0, r1, d10
 8024fb2:	f003 fdd9 	bl	8028b68 <__aeabi_dmul>
 8024fb6:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 8024fba:	ec58 7b1b 	vmov	r7, r8, d11
 8024fbe:	4604      	mov	r4, r0
 8024fc0:	460d      	mov	r5, r1
 8024fc2:	464a      	mov	r2, r9
 8024fc4:	4653      	mov	r3, sl
 8024fc6:	ee1b 0a10 	vmov	r0, s22
 8024fca:	4641      	mov	r1, r8
 8024fcc:	f003 fdcc 	bl	8028b68 <__aeabi_dmul>
 8024fd0:	4602      	mov	r2, r0
 8024fd2:	460b      	mov	r3, r1
 8024fd4:	4620      	mov	r0, r4
 8024fd6:	4629      	mov	r1, r5
 8024fd8:	f003 fc0e 	bl	80287f8 <__aeabi_dsub>
 8024fdc:	9e01      	ldr	r6, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024fde:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024fe0:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024fe4:	4653      	mov	r3, sl
 8024fe6:	ec51 0b1a 	vmov	r0, r1, d10
 8024fea:	f003 fdbd 	bl	8028b68 <__aeabi_dmul>
 8024fee:	ec53 2b1f 	vmov	r2, r3, d15
 8024ff2:	4604      	mov	r4, r0
 8024ff4:	460d      	mov	r5, r1
 8024ff6:	ee1b 0a10 	vmov	r0, s22
 8024ffa:	4641      	mov	r1, r8
 8024ffc:	f003 fdb4 	bl	8028b68 <__aeabi_dmul>
 8025000:	4602      	mov	r2, r0
 8025002:	460b      	mov	r3, r1
 8025004:	4620      	mov	r0, r4
 8025006:	4629      	mov	r1, r5
 8025008:	f003 fbf8 	bl	80287fc <__adddf3>
 802500c:	e9c6 0102 	strd	r0, r1, [r6, #8]
      for (i = 0; i < n1; i++) {
 8025010:	9a01      	ldr	r2, [sp, #4]
 8025012:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8025014:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8025016:	440a      	add	r2, r1
 8025018:	9201      	str	r2, [sp, #4]
 802501a:	990c      	ldr	r1, [sp, #48]	; 0x30
 802501c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 802501e:	440a      	add	r2, r1
 8025020:	9211      	str	r2, [sp, #68]	; 0x44
 8025022:	9a07      	ldr	r2, [sp, #28]
 8025024:	3301      	adds	r3, #1
 8025026:	429a      	cmp	r2, r3
 8025028:	9312      	str	r3, [sp, #72]	; 0x48
 802502a:	f47f aeb1 	bne.w	8024d90 <cblas_ztrmm+0x1558>
 802502e:	f7fe bd9d 	b.w	8023b6c <cblas_ztrmm+0x334>
 8025032:	bf00      	nop
 8025034:	0000      	movs	r0, r0
	...

08025038 <cblas_ztrmv>:
void
cblas_ztrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 8025038:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802503c:	ed2d 8b0e 	vpush	{d8-d14}
 8025040:	b093      	sub	sp, #76	; 0x4c
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8025042:	2a71      	cmp	r2, #113	; 0x71
 8025044:	930b      	str	r3, [sp, #44]	; 0x2c
 8025046:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8025048:	9306      	str	r3, [sp, #24]
 802504a:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 802504c:	9309      	str	r3, [sp, #36]	; 0x24
 802504e:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8025050:	9307      	str	r3, [sp, #28]
 8025052:	e9dd 452b 	ldrd	r4, r5, [sp, #172]	; 0xac
 8025056:	4606      	mov	r6, r0
 8025058:	460f      	mov	r7, r1
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 802505a:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 802505e:	f000 8122 	beq.w	80252a6 <cblas_ztrmv+0x26e>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8025062:	2b01      	cmp	r3, #1
 8025064:	4690      	mov	r8, r2
 8025066:	d934      	bls.n	80250d2 <cblas_ztrmv+0x9a>
 8025068:	2002      	movs	r0, #2
 802506a:	3a6f      	subs	r2, #111	; 0x6f
 802506c:	2301      	movs	r3, #1
 802506e:	2a02      	cmp	r2, #2
 8025070:	ee0e 3a10 	vmov	s28, r3
 8025074:	bf88      	it	hi
 8025076:	2003      	movhi	r0, #3
 8025078:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802507a:	337d      	adds	r3, #125	; 0x7d
 802507c:	b2db      	uxtb	r3, r3
 802507e:	2b01      	cmp	r3, #1
 8025080:	9b06      	ldr	r3, [sp, #24]
 8025082:	d934      	bls.n	80250ee <cblas_ztrmv+0xb6>
 8025084:	2b00      	cmp	r3, #0
 8025086:	db2a      	blt.n	80250de <cblas_ztrmv+0xa6>
 8025088:	2b01      	cmp	r3, #1
 802508a:	bfb8      	it	lt
 802508c:	2301      	movlt	r3, #1
 802508e:	42ab      	cmp	r3, r5
 8025090:	f340 8113 	ble.w	80252ba <cblas_ztrmv+0x282>
 8025094:	9b07      	ldr	r3, [sp, #28]
 8025096:	2b00      	cmp	r3, #0
 8025098:	bf0c      	ite	eq
 802509a:	2009      	moveq	r0, #9
 802509c:	2007      	movne	r0, #7
 802509e:	4aba      	ldr	r2, [pc, #744]	; (8025388 <cblas_ztrmv+0x350>)
 80250a0:	49ba      	ldr	r1, [pc, #744]	; (802538c <cblas_ztrmv+0x354>)
 80250a2:	f003 fb31 	bl	8028708 <cblas_xerbla>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80250a6:	2e65      	cmp	r6, #101	; 0x65
 80250a8:	d030      	beq.n	802510c <cblas_ztrmv+0xd4>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80250aa:	2e66      	cmp	r6, #102	; 0x66
 80250ac:	d107      	bne.n	80250be <cblas_ztrmv+0x86>
 80250ae:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 80250b2:	f000 8293 	beq.w	80255dc <cblas_ztrmv+0x5a4>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80250b6:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80250ba:	f000 8104 	beq.w	80252c6 <cblas_ztrmv+0x28e>
    BLAS_ERROR("unrecognized operation");
 80250be:	4ab4      	ldr	r2, [pc, #720]	; (8025390 <cblas_ztrmv+0x358>)
 80250c0:	49b2      	ldr	r1, [pc, #712]	; (802538c <cblas_ztrmv+0x354>)
 80250c2:	2000      	movs	r0, #0
#define BASE double
#include "source_trmv_c.h"
#undef BASE
}
 80250c4:	b013      	add	sp, #76	; 0x4c
 80250c6:	ecbd 8b0e 	vpop	{d8-d14}
 80250ca:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80250ce:	f003 bb1b 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80250d2:	3865      	subs	r0, #101	; 0x65
 80250d4:	2801      	cmp	r0, #1
 80250d6:	bf94      	ite	ls
 80250d8:	2000      	movls	r0, #0
 80250da:	2001      	movhi	r0, #1
 80250dc:	e7c5      	b.n	802506a <cblas_ztrmv+0x32>
 80250de:	2d00      	cmp	r5, #0
 80250e0:	ddd8      	ble.n	8025094 <cblas_ztrmv+0x5c>
 80250e2:	9b07      	ldr	r3, [sp, #28]
 80250e4:	2b00      	cmp	r3, #0
 80250e6:	bf0c      	ite	eq
 80250e8:	2009      	moveq	r0, #9
 80250ea:	2005      	movne	r0, #5
 80250ec:	e7d7      	b.n	802509e <cblas_ztrmv+0x66>
 80250ee:	2b00      	cmp	r3, #0
 80250f0:	dbf5      	blt.n	80250de <cblas_ztrmv+0xa6>
 80250f2:	9b06      	ldr	r3, [sp, #24]
 80250f4:	2b01      	cmp	r3, #1
 80250f6:	bfb8      	it	lt
 80250f8:	2301      	movlt	r3, #1
 80250fa:	42ab      	cmp	r3, r5
 80250fc:	dcca      	bgt.n	8025094 <cblas_ztrmv+0x5c>
 80250fe:	9b07      	ldr	r3, [sp, #28]
 8025100:	2b00      	cmp	r3, #0
 8025102:	f000 84bb 	beq.w	8025a7c <cblas_ztrmv+0xa44>
 8025106:	2800      	cmp	r0, #0
 8025108:	d0cd      	beq.n	80250a6 <cblas_ztrmv+0x6e>
 802510a:	e7c8      	b.n	802509e <cblas_ztrmv+0x66>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 802510c:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8025110:	f000 8140 	beq.w	8025394 <cblas_ztrmv+0x35c>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8025114:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8025118:	d1d1      	bne.n	80250be <cblas_ztrmv+0x86>
 802511a:	2f79      	cmp	r7, #121	; 0x79
 802511c:	f000 8388 	beq.w	8025830 <cblas_ztrmv+0x7f8>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8025120:	2f7a      	cmp	r7, #122	; 0x7a
 8025122:	d1cc      	bne.n	80250be <cblas_ztrmv+0x86>
    INDEX ix = OFFSET(N, incX);
 8025124:	9a07      	ldr	r2, [sp, #28]
 8025126:	2a00      	cmp	r2, #0
 8025128:	bfde      	ittt	le
 802512a:	9b06      	ldrle	r3, [sp, #24]
 802512c:	f1c3 0301 	rsble	r3, r3, #1
 8025130:	4353      	mulle	r3, r2
    for (i = 0; i < N; i++) {
 8025132:	9a06      	ldr	r2, [sp, #24]
    INDEX ix = OFFSET(N, incX);
 8025134:	bfc8      	it	gt
 8025136:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8025138:	2a00      	cmp	r2, #0
 802513a:	f340 80af 	ble.w	802529c <cblas_ztrmv+0x264>
 802513e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8025140:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8025144:	3208      	adds	r2, #8
 8025146:	9208      	str	r2, [sp, #32]
 8025148:	9a07      	ldr	r2, [sp, #28]
 802514a:	3501      	adds	r5, #1
 802514c:	4413      	add	r3, r2
 802514e:	0129      	lsls	r1, r5, #4
 8025150:	930d      	str	r3, [sp, #52]	; 0x34
 8025152:	0113      	lsls	r3, r2, #4
 8025154:	910e      	str	r1, [sp, #56]	; 0x38
 8025156:	f104 0008 	add.w	r0, r4, #8
 802515a:	3910      	subs	r1, #16
 802515c:	9302      	str	r3, [sp, #8]
 802515e:	2300      	movs	r3, #0
 8025160:	900a      	str	r0, [sp, #40]	; 0x28
 8025162:	9104      	str	r1, [sp, #16]
 8025164:	930c      	str	r3, [sp, #48]	; 0x30
      const INDEX j_min = i + 1;
 8025166:	9c0c      	ldr	r4, [sp, #48]	; 0x30
      for (j = j_min; j < N; j++) {
 8025168:	9b06      	ldr	r3, [sp, #24]
      const INDEX j_min = i + 1;
 802516a:	3401      	adds	r4, #1
      for (j = j_min; j < N; j++) {
 802516c:	42a3      	cmp	r3, r4
      const INDEX j_min = i + 1;
 802516e:	940c      	str	r4, [sp, #48]	; 0x30
      for (j = j_min; j < N; j++) {
 8025170:	f340 8353 	ble.w	802581a <cblas_ztrmv+0x7e2>
 8025174:	ee1e 0a10 	vmov	r0, s28
 8025178:	f003 fc8c 	bl	8028a94 <__aeabi_i2d>
 802517c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802517e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8025180:	9401      	str	r4, [sp, #4]
      BASE temp_i = 0.0;
 8025182:	ed9f 7b7f 	vldr	d7, [pc, #508]	; 8025380 <cblas_ztrmv+0x348>
 8025186:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
 802518a:	9b04      	ldr	r3, [sp, #16]
 802518c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802518e:	eeb0 ba47 	vmov.f32	s22, s14
 8025192:	eef0 ba67 	vmov.f32	s23, s15
 8025196:	ec41 0b1c 	vmov	d12, r0, r1
      BASE temp_r = 0.0;
 802519a:	eeb0 aa47 	vmov.f32	s20, s14
 802519e:	eef0 aa67 	vmov.f32	s21, s15
 80251a2:	eb03 0a02 	add.w	sl, r3, r2
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80251a6:	ed1a 7b02 	vldr	d7, [sl, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80251aa:	e9da 2300 	ldrd	r2, r3, [sl]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80251ae:	eeb0 8a47 	vmov.f32	s16, s14
 80251b2:	eef0 8a67 	vmov.f32	s17, s15
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80251b6:	ec51 0b1c 	vmov	r0, r1, d12
 80251ba:	f003 fcd5 	bl	8028b68 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 80251be:	e9db 8900 	ldrd	r8, r9, [fp]
        temp_r += A_real * x_real - A_imag * x_imag;
 80251c2:	ec53 2b18 	vmov	r2, r3, d8
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80251c6:	4604      	mov	r4, r0
 80251c8:	460d      	mov	r5, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 80251ca:	4640      	mov	r0, r8
 80251cc:	4649      	mov	r1, r9
 80251ce:	f003 fccb 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 80251d2:	ed9b 9b02 	vldr	d9, [fp, #8]
        temp_r += A_real * x_real - A_imag * x_imag;
 80251d6:	4606      	mov	r6, r0
 80251d8:	460f      	mov	r7, r1
 80251da:	4622      	mov	r2, r4
 80251dc:	462b      	mov	r3, r5
 80251de:	ec51 0b19 	vmov	r0, r1, d9
 80251e2:	f003 fcc1 	bl	8028b68 <__aeabi_dmul>
 80251e6:	4602      	mov	r2, r0
 80251e8:	460b      	mov	r3, r1
 80251ea:	4630      	mov	r0, r6
 80251ec:	4639      	mov	r1, r7
 80251ee:	f003 fb03 	bl	80287f8 <__aeabi_dsub>
 80251f2:	4602      	mov	r2, r0
 80251f4:	460b      	mov	r3, r1
 80251f6:	ec51 0b1a 	vmov	r0, r1, d10
 80251fa:	f003 faff 	bl	80287fc <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 80251fe:	ec53 2b18 	vmov	r2, r3, d8
        temp_r += A_real * x_real - A_imag * x_imag;
 8025202:	4606      	mov	r6, r0
 8025204:	460f      	mov	r7, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 8025206:	ec51 0b19 	vmov	r0, r1, d9
 802520a:	f003 fcad 	bl	8028b68 <__aeabi_dmul>
        temp_r += A_real * x_real - A_imag * x_imag;
 802520e:	ec47 6b1a 	vmov	d10, r6, r7
        temp_i += A_real * x_imag + A_imag * x_real;
 8025212:	4622      	mov	r2, r4
 8025214:	462b      	mov	r3, r5
 8025216:	4606      	mov	r6, r0
 8025218:	460f      	mov	r7, r1
 802521a:	4640      	mov	r0, r8
 802521c:	4649      	mov	r1, r9
 802521e:	f003 fca3 	bl	8028b68 <__aeabi_dmul>
 8025222:	4602      	mov	r2, r0
 8025224:	460b      	mov	r3, r1
 8025226:	4630      	mov	r0, r6
 8025228:	4639      	mov	r1, r7
 802522a:	f003 fae7 	bl	80287fc <__adddf3>
 802522e:	4602      	mov	r2, r0
 8025230:	460b      	mov	r3, r1
 8025232:	ec51 0b1b 	vmov	r0, r1, d11
 8025236:	f003 fae1 	bl	80287fc <__adddf3>
 802523a:	9a04      	ldr	r2, [sp, #16]
      for (j = j_min; j < N; j++) {
 802523c:	9b01      	ldr	r3, [sp, #4]
 802523e:	4492      	add	sl, r2
 8025240:	9a02      	ldr	r2, [sp, #8]
 8025242:	4493      	add	fp, r2
 8025244:	9a06      	ldr	r2, [sp, #24]
 8025246:	3301      	adds	r3, #1
 8025248:	429a      	cmp	r2, r3
        temp_i += A_real * x_imag + A_imag * x_real;
 802524a:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = j_min; j < N; j++) {
 802524e:	9301      	str	r3, [sp, #4]
 8025250:	d1a9      	bne.n	80251a6 <cblas_ztrmv+0x16e>
      if (nonunit) {
 8025252:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025254:	2b83      	cmp	r3, #131	; 0x83
 8025256:	d03d      	beq.n	80252d4 <cblas_ztrmv+0x29c>
        REAL(X, ix) += temp_r;
 8025258:	9c08      	ldr	r4, [sp, #32]
 802525a:	ec53 2b1a 	vmov	r2, r3, d10
 802525e:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8025262:	f003 facb 	bl	80287fc <__adddf3>
        IMAG(X, ix) += temp_i;
 8025266:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(X, ix) += temp_r;
 802526a:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 802526e:	e9d4 0100 	ldrd	r0, r1, [r4]
 8025272:	f003 fac3 	bl	80287fc <__adddf3>
 8025276:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 802527a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802527c:	9a07      	ldr	r2, [sp, #28]
 802527e:	4413      	add	r3, r2
 8025280:	930d      	str	r3, [sp, #52]	; 0x34
 8025282:	9a02      	ldr	r2, [sp, #8]
 8025284:	9b08      	ldr	r3, [sp, #32]
 8025286:	4413      	add	r3, r2
 8025288:	9308      	str	r3, [sp, #32]
 802528a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802528c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802528e:	4413      	add	r3, r2
 8025290:	930a      	str	r3, [sp, #40]	; 0x28
 8025292:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8025294:	9b06      	ldr	r3, [sp, #24]
 8025296:	4293      	cmp	r3, r2
 8025298:	f47f af65 	bne.w	8025166 <cblas_ztrmv+0x12e>
 802529c:	b013      	add	sp, #76	; 0x4c
 802529e:	ecbd 8b0e 	vpop	{d8-d14}
 80252a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80252a6:	2b01      	cmp	r3, #1
 80252a8:	d95e      	bls.n	8025368 <cblas_ztrmv+0x330>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 80252aa:	f04f 33ff 	mov.w	r3, #4294967295
 80252ae:	ee0e 3a10 	vmov	s28, r3
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80252b2:	f04f 0870 	mov.w	r8, #112	; 0x70
 80252b6:	2002      	movs	r0, #2
 80252b8:	e6de      	b.n	8025078 <cblas_ztrmv+0x40>
 80252ba:	9b07      	ldr	r3, [sp, #28]
 80252bc:	2b00      	cmp	r3, #0
 80252be:	bf0c      	ite	eq
 80252c0:	2009      	moveq	r0, #9
 80252c2:	2004      	movne	r0, #4
 80252c4:	e6eb      	b.n	802509e <cblas_ztrmv+0x66>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80252c6:	2f7a      	cmp	r7, #122	; 0x7a
 80252c8:	f000 82b2 	beq.w	8025830 <cblas_ztrmv+0x7f8>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 80252cc:	2f79      	cmp	r7, #121	; 0x79
 80252ce:	f47f aef6 	bne.w	80250be <cblas_ztrmv+0x86>
 80252d2:	e727      	b.n	8025124 <cblas_ztrmv+0xec>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80252d4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        const BASE x_real = REAL(X, ix);
 80252d6:	9c08      	ldr	r4, [sp, #32]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80252d8:	ee1e 0a10 	vmov	r0, s28
 80252dc:	f003 fbda 	bl	8028a94 <__aeabi_i2d>
 80252e0:	e9d5 2300 	ldrd	r2, r3, [r5]
 80252e4:	f003 fc40 	bl	8028b68 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80252e8:	e955 ab02 	ldrd	sl, fp, [r5, #-8]
        const BASE x_real = REAL(X, ix);
 80252ec:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80252f0:	4680      	mov	r8, r0
 80252f2:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80252f4:	4652      	mov	r2, sl
 80252f6:	465b      	mov	r3, fp
 80252f8:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 80252fc:	e9d4 6700 	ldrd	r6, r7, [r4]
 8025300:	9408      	str	r4, [sp, #32]
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8025302:	f003 fc31 	bl	8028b68 <__aeabi_dmul>
 8025306:	4642      	mov	r2, r8
 8025308:	4604      	mov	r4, r0
 802530a:	460d      	mov	r5, r1
 802530c:	464b      	mov	r3, r9
 802530e:	4630      	mov	r0, r6
 8025310:	4639      	mov	r1, r7
 8025312:	f003 fc29 	bl	8028b68 <__aeabi_dmul>
 8025316:	4602      	mov	r2, r0
 8025318:	460b      	mov	r3, r1
 802531a:	4620      	mov	r0, r4
 802531c:	4629      	mov	r1, r5
 802531e:	f003 fa6b 	bl	80287f8 <__aeabi_dsub>
 8025322:	ec53 2b1a 	vmov	r2, r3, d10
 8025326:	f003 fa69 	bl	80287fc <__adddf3>
 802532a:	9c08      	ldr	r4, [sp, #32]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 802532c:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 802532e:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8025332:	465b      	mov	r3, fp
 8025334:	4630      	mov	r0, r6
 8025336:	4639      	mov	r1, r7
 8025338:	f003 fc16 	bl	8028b68 <__aeabi_dmul>
 802533c:	4642      	mov	r2, r8
 802533e:	4604      	mov	r4, r0
 8025340:	464b      	mov	r3, r9
 8025342:	460d      	mov	r5, r1
 8025344:	ec51 0b18 	vmov	r0, r1, d8
 8025348:	f003 fc0e 	bl	8028b68 <__aeabi_dmul>
 802534c:	4602      	mov	r2, r0
 802534e:	460b      	mov	r3, r1
 8025350:	4620      	mov	r0, r4
 8025352:	4629      	mov	r1, r5
 8025354:	f003 fa52 	bl	80287fc <__adddf3>
 8025358:	ec53 2b1b 	vmov	r2, r3, d11
 802535c:	f003 fa4e 	bl	80287fc <__adddf3>
 8025360:	9c08      	ldr	r4, [sp, #32]
 8025362:	e9c4 0100 	strd	r0, r1, [r4]
 8025366:	e788      	b.n	802527a <cblas_ztrmv+0x242>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8025368:	3865      	subs	r0, #101	; 0x65
 802536a:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 802536c:	f04f 33ff 	mov.w	r3, #4294967295
 8025370:	ee0e 3a10 	vmov	s28, r3
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8025374:	bf94      	ite	ls
 8025376:	2000      	movls	r0, #0
 8025378:	2001      	movhi	r0, #1
 802537a:	f04f 0870 	mov.w	r8, #112	; 0x70
 802537e:	e67b      	b.n	8025078 <cblas_ztrmv+0x40>
	...
 8025388:	08031108 	.word	0x08031108
 802538c:	080313a4 	.word	0x080313a4
 8025390:	080311b8 	.word	0x080311b8
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8025394:	2f79      	cmp	r7, #121	; 0x79
 8025396:	f000 812b 	beq.w	80255f0 <cblas_ztrmv+0x5b8>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 802539a:	2f7a      	cmp	r7, #122	; 0x7a
 802539c:	f47f ae8f 	bne.w	80250be <cblas_ztrmv+0x86>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80253a0:	9b07      	ldr	r3, [sp, #28]
    for (i = N; i > 0 && i--;) {
 80253a2:	9e06      	ldr	r6, [sp, #24]
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80253a4:	9f07      	ldr	r7, [sp, #28]
 80253a6:	2b00      	cmp	r3, #0
 80253a8:	9b06      	ldr	r3, [sp, #24]
 80253aa:	bfd8      	it	le
 80253ac:	9a07      	ldrle	r2, [sp, #28]
 80253ae:	f103 33ff 	add.w	r3, r3, #4294967295
 80253b2:	9308      	str	r3, [sp, #32]
 80253b4:	bfd8      	it	le
 80253b6:	4252      	negle	r2, r2
 80253b8:	9908      	ldr	r1, [sp, #32]
 80253ba:	bfcc      	ite	gt
 80253bc:	2200      	movgt	r2, #0
 80253be:	435a      	mulle	r2, r3
    for (i = N; i > 0 && i--;) {
 80253c0:	2e00      	cmp	r6, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80253c2:	fb01 2e07 	mla	lr, r1, r7, r2
    for (i = N; i > 0 && i--;) {
 80253c6:	f77f af69 	ble.w	802529c <cblas_ztrmv+0x264>
 80253ca:	9809      	ldr	r0, [sp, #36]	; 0x24
 80253cc:	eb00 1e0e 	add.w	lr, r0, lr, lsl #4
 80253d0:	fb05 6c01 	mla	ip, r5, r1, r6
 80253d4:	ebc7 7107 	rsb	r1, r7, r7, lsl #28
 80253d8:	f10e 0708 	add.w	r7, lr, #8
 80253dc:	9701      	str	r7, [sp, #4]
 80253de:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80253e0:	1c6b      	adds	r3, r5, #1
 80253e2:	011b      	lsls	r3, r3, #4
 80253e4:	eb07 1702 	add.w	r7, r7, r2, lsl #4
 80253e8:	9a08      	ldr	r2, [sp, #32]
 80253ea:	970d      	str	r7, [sp, #52]	; 0x34
 80253ec:	f1a3 0610 	sub.w	r6, r3, #16
 80253f0:	43e8      	mvns	r0, r5
 80253f2:	fb02 4606 	mla	r6, r2, r6, r4
 80253f6:	fb03 4202 	mla	r2, r3, r2, r4
 80253fa:	ebc5 7505 	rsb	r5, r5, r5, lsl #28
 80253fe:	9204      	str	r2, [sp, #16]
 8025400:	0102      	lsls	r2, r0, #4
 8025402:	9209      	str	r2, [sp, #36]	; 0x24
 8025404:	012a      	lsls	r2, r5, #4
 8025406:	920a      	str	r2, [sp, #40]	; 0x28
 8025408:	010a      	lsls	r2, r1, #4
 802540a:	9907      	ldr	r1, [sp, #28]
 802540c:	9602      	str	r6, [sp, #8]
 802540e:	f1a4 0810 	sub.w	r8, r4, #16
 8025412:	eb08 170c 	add.w	r7, r8, ip, lsl #4
 8025416:	010b      	lsls	r3, r1, #4
 8025418:	9706      	str	r7, [sp, #24]
 802541a:	920c      	str	r2, [sp, #48]	; 0x30
 802541c:	9307      	str	r3, [sp, #28]
      for (j = 0; j < j_max; j++) {
 802541e:	9b08      	ldr	r3, [sp, #32]
 8025420:	2b00      	cmp	r3, #0
 8025422:	f000 8319 	beq.w	8025a58 <cblas_ztrmv+0xa20>
 8025426:	ee1e 0a10 	vmov	r0, s28
 802542a:	f003 fb33 	bl	8028a94 <__aeabi_i2d>
 802542e:	ed9f 7b6e 	vldr	d7, [pc, #440]	; 80255e8 <cblas_ztrmv+0x5b0>
 8025432:	e9dd 5706 	ldrd	r5, r7, [sp, #24]
 8025436:	eeb0 ca47 	vmov.f32	s24, s14
 802543a:	eef0 ca67 	vmov.f32	s25, s15
 802543e:	eeb0 ba47 	vmov.f32	s22, s14
 8025442:	eef0 ba67 	vmov.f32	s23, s15
 8025446:	ec41 0b1d 	vmov	d13, r0, r1
 802544a:	9e02      	ldr	r6, [sp, #8]
 802544c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
        const BASE A_real = CONST_REAL(A, lda * i + j);
 802544e:	ed96 7b00 	vldr	d7, [r6]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8025452:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 8025456:	eeb0 9a47 	vmov.f32	s18, s14
 802545a:	eef0 9a67 	vmov.f32	s19, s15
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 802545e:	ec51 0b1d 	vmov	r0, r1, d13
 8025462:	f003 fb81 	bl	8028b68 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 8025466:	ed94 8b00 	vldr	d8, [r4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 802546a:	4680      	mov	r8, r0
 802546c:	4689      	mov	r9, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 802546e:	ec53 2b19 	vmov	r2, r3, d9
 8025472:	ec51 0b18 	vmov	r0, r1, d8
 8025476:	f003 fb77 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 802547a:	e9d4 ab02 	ldrd	sl, fp, [r4, #8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 802547e:	ec49 8b1a 	vmov	d10, r8, r9
        temp_r += A_real * x_real - A_imag * x_imag;
 8025482:	4680      	mov	r8, r0
 8025484:	ec53 2b1a 	vmov	r2, r3, d10
 8025488:	4689      	mov	r9, r1
 802548a:	4650      	mov	r0, sl
 802548c:	4659      	mov	r1, fp
 802548e:	f003 fb6b 	bl	8028b68 <__aeabi_dmul>
 8025492:	4602      	mov	r2, r0
 8025494:	460b      	mov	r3, r1
 8025496:	4640      	mov	r0, r8
 8025498:	4649      	mov	r1, r9
 802549a:	f003 f9ad 	bl	80287f8 <__aeabi_dsub>
 802549e:	4602      	mov	r2, r0
 80254a0:	460b      	mov	r3, r1
 80254a2:	ec51 0b1b 	vmov	r0, r1, d11
 80254a6:	f003 f9a9 	bl	80287fc <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 80254aa:	ec53 2b19 	vmov	r2, r3, d9
        temp_r += A_real * x_real - A_imag * x_imag;
 80254ae:	4680      	mov	r8, r0
 80254b0:	4689      	mov	r9, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 80254b2:	4650      	mov	r0, sl
 80254b4:	4659      	mov	r1, fp
 80254b6:	f003 fb57 	bl	8028b68 <__aeabi_dmul>
        temp_r += A_real * x_real - A_imag * x_imag;
 80254ba:	ec49 8b1b 	vmov	d11, r8, r9
        temp_i += A_real * x_imag + A_imag * x_real;
 80254be:	ec53 2b1a 	vmov	r2, r3, d10
 80254c2:	4680      	mov	r8, r0
 80254c4:	4689      	mov	r9, r1
 80254c6:	ec51 0b18 	vmov	r0, r1, d8
 80254ca:	f003 fb4d 	bl	8028b68 <__aeabi_dmul>
 80254ce:	4602      	mov	r2, r0
 80254d0:	460b      	mov	r3, r1
 80254d2:	4640      	mov	r0, r8
 80254d4:	4649      	mov	r1, r9
 80254d6:	f003 f991 	bl	80287fc <__adddf3>
 80254da:	4602      	mov	r2, r0
 80254dc:	460b      	mov	r3, r1
 80254de:	ec51 0b1c 	vmov	r0, r1, d12
 80254e2:	f003 f98b 	bl	80287fc <__adddf3>
 80254e6:	3610      	adds	r6, #16
      for (j = 0; j < j_max; j++) {
 80254e8:	42b5      	cmp	r5, r6
        temp_i += A_real * x_imag + A_imag * x_real;
 80254ea:	ec41 0b1c 	vmov	d12, r0, r1
      for (j = 0; j < j_max; j++) {
 80254ee:	443c      	add	r4, r7
 80254f0:	d1ad      	bne.n	802544e <cblas_ztrmv+0x416>
      if (nonunit) {
 80254f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80254f4:	2b83      	cmp	r3, #131	; 0x83
 80254f6:	d027      	beq.n	8025548 <cblas_ztrmv+0x510>
        REAL(X, ix) += temp_r;
 80254f8:	9c01      	ldr	r4, [sp, #4]
 80254fa:	ec53 2b1b 	vmov	r2, r3, d11
 80254fe:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8025502:	f003 f97b 	bl	80287fc <__adddf3>
        IMAG(X, ix) += temp_i;
 8025506:	ec53 2b1c 	vmov	r2, r3, d12
        REAL(X, ix) += temp_r;
 802550a:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 802550e:	e9d4 0100 	ldrd	r0, r1, [r4]
 8025512:	f003 f973 	bl	80287fc <__adddf3>
 8025516:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 802551a:	9a04      	ldr	r2, [sp, #16]
 802551c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802551e:	4611      	mov	r1, r2
 8025520:	4419      	add	r1, r3
 8025522:	9a02      	ldr	r2, [sp, #8]
 8025524:	9104      	str	r1, [sp, #16]
 8025526:	990a      	ldr	r1, [sp, #40]	; 0x28
 8025528:	440a      	add	r2, r1
 802552a:	9202      	str	r2, [sp, #8]
 802552c:	9a06      	ldr	r2, [sp, #24]
 802552e:	441a      	add	r2, r3
 8025530:	9206      	str	r2, [sp, #24]
 8025532:	9b01      	ldr	r3, [sp, #4]
 8025534:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8025536:	4413      	add	r3, r2
 8025538:	9301      	str	r3, [sp, #4]
 802553a:	9b08      	ldr	r3, [sp, #32]
 802553c:	2b00      	cmp	r3, #0
 802553e:	f43f aead 	beq.w	802529c <cblas_ztrmv+0x264>
 8025542:	3b01      	subs	r3, #1
 8025544:	9308      	str	r3, [sp, #32]
 8025546:	e76a      	b.n	802541e <cblas_ztrmv+0x3e6>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8025548:	9d04      	ldr	r5, [sp, #16]
        const BASE x_real = REAL(X, ix);
 802554a:	9c01      	ldr	r4, [sp, #4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 802554c:	ee1e 0a10 	vmov	r0, s28
 8025550:	f003 faa0 	bl	8028a94 <__aeabi_i2d>
 8025554:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8025558:	f003 fb06 	bl	8028b68 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 802555c:	e9d5 ab00 	ldrd	sl, fp, [r5]
        const BASE x_real = REAL(X, ix);
 8025560:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8025564:	4680      	mov	r8, r0
 8025566:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8025568:	4652      	mov	r2, sl
 802556a:	465b      	mov	r3, fp
 802556c:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 8025570:	e9d4 6700 	ldrd	r6, r7, [r4]
 8025574:	9401      	str	r4, [sp, #4]
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8025576:	f003 faf7 	bl	8028b68 <__aeabi_dmul>
 802557a:	4642      	mov	r2, r8
 802557c:	4604      	mov	r4, r0
 802557e:	460d      	mov	r5, r1
 8025580:	464b      	mov	r3, r9
 8025582:	4630      	mov	r0, r6
 8025584:	4639      	mov	r1, r7
 8025586:	f003 faef 	bl	8028b68 <__aeabi_dmul>
 802558a:	4602      	mov	r2, r0
 802558c:	460b      	mov	r3, r1
 802558e:	4620      	mov	r0, r4
 8025590:	4629      	mov	r1, r5
 8025592:	f003 f931 	bl	80287f8 <__aeabi_dsub>
 8025596:	ec53 2b1b 	vmov	r2, r3, d11
 802559a:	f003 f92f 	bl	80287fc <__adddf3>
 802559e:	9c01      	ldr	r4, [sp, #4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80255a0:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80255a2:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80255a6:	465b      	mov	r3, fp
 80255a8:	4630      	mov	r0, r6
 80255aa:	4639      	mov	r1, r7
 80255ac:	f003 fadc 	bl	8028b68 <__aeabi_dmul>
 80255b0:	4642      	mov	r2, r8
 80255b2:	4604      	mov	r4, r0
 80255b4:	464b      	mov	r3, r9
 80255b6:	460d      	mov	r5, r1
 80255b8:	ec51 0b18 	vmov	r0, r1, d8
 80255bc:	f003 fad4 	bl	8028b68 <__aeabi_dmul>
 80255c0:	4602      	mov	r2, r0
 80255c2:	460b      	mov	r3, r1
 80255c4:	4620      	mov	r0, r4
 80255c6:	4629      	mov	r1, r5
 80255c8:	f003 f918 	bl	80287fc <__adddf3>
 80255cc:	ec53 2b1c 	vmov	r2, r3, d12
 80255d0:	f003 f914 	bl	80287fc <__adddf3>
 80255d4:	9c01      	ldr	r4, [sp, #4]
 80255d6:	e9c4 0100 	strd	r0, r1, [r4]
 80255da:	e79e      	b.n	802551a <cblas_ztrmv+0x4e2>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80255dc:	2f7a      	cmp	r7, #122	; 0x7a
 80255de:	d007      	beq.n	80255f0 <cblas_ztrmv+0x5b8>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 80255e0:	2f79      	cmp	r7, #121	; 0x79
 80255e2:	f47f ad6c 	bne.w	80250be <cblas_ztrmv+0x86>
 80255e6:	e6db      	b.n	80253a0 <cblas_ztrmv+0x368>
	...
    INDEX ix = OFFSET(N, incX);
 80255f0:	9a07      	ldr	r2, [sp, #28]
    for (i = 0; i < N; i++) {
 80255f2:	9806      	ldr	r0, [sp, #24]
    INDEX ix = OFFSET(N, incX);
 80255f4:	2a00      	cmp	r2, #0
 80255f6:	bfdd      	ittte	le
 80255f8:	9b06      	ldrle	r3, [sp, #24]
 80255fa:	f1c3 0301 	rsble	r3, r3, #1
 80255fe:	4353      	mulle	r3, r2
 8025600:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8025602:	2800      	cmp	r0, #0
 8025604:	f77f ae4a 	ble.w	802529c <cblas_ztrmv+0x264>
 8025608:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802560a:	9408      	str	r4, [sp, #32]
 802560c:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8025610:	3208      	adds	r2, #8
 8025612:	9204      	str	r2, [sp, #16]
 8025614:	9a07      	ldr	r2, [sp, #28]
 8025616:	3501      	adds	r5, #1
 8025618:	4413      	add	r3, r2
 802561a:	012d      	lsls	r5, r5, #4
 802561c:	f1a4 0110 	sub.w	r1, r4, #16
 8025620:	930c      	str	r3, [sp, #48]	; 0x30
 8025622:	0113      	lsls	r3, r2, #4
 8025624:	f1a5 0410 	sub.w	r4, r5, #16
 8025628:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 802562c:	9302      	str	r3, [sp, #8]
 802562e:	2300      	movs	r3, #0
 8025630:	950e      	str	r5, [sp, #56]	; 0x38
 8025632:	940d      	str	r4, [sp, #52]	; 0x34
 8025634:	9101      	str	r1, [sp, #4]
 8025636:	930a      	str	r3, [sp, #40]	; 0x28
      const INDEX j_min = i + 1;
 8025638:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      for (j = j_min; j < N; j++) {
 802563a:	9a06      	ldr	r2, [sp, #24]
      const INDEX j_min = i + 1;
 802563c:	3301      	adds	r3, #1
      for (j = j_min; j < N; j++) {
 802563e:	429a      	cmp	r2, r3
      const INDEX j_min = i + 1;
 8025640:	930a      	str	r3, [sp, #40]	; 0x28
      for (j = j_min; j < N; j++) {
 8025642:	f340 80df 	ble.w	8025804 <cblas_ztrmv+0x7cc>
 8025646:	ee1e 0a10 	vmov	r0, s28
 802564a:	f003 fa23 	bl	8028a94 <__aeabi_i2d>
      BASE temp_i = 0.0;
 802564e:	ed1f 7b1a 	vldr	d7, [pc, #-104]	; 80255e8 <cblas_ztrmv+0x5b0>
 8025652:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8025654:	9a0c      	ldr	r2, [sp, #48]	; 0x30
      for (j = j_min; j < N; j++) {
 8025656:	f8dd b020 	ldr.w	fp, [sp, #32]
      BASE temp_i = 0.0;
 802565a:	eeb0 ba47 	vmov.f32	s22, s14
 802565e:	eef0 ba67 	vmov.f32	s23, s15
 8025662:	ec41 0b1c 	vmov	d12, r0, r1
      BASE temp_r = 0.0;
 8025666:	eeb0 aa47 	vmov.f32	s20, s14
 802566a:	eef0 aa67 	vmov.f32	s21, s15
 802566e:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE A_real = CONST_REAL(A, lda * i + j);
 8025672:	ed9b 7b04 	vldr	d7, [fp, #16]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8025676:	e9db 2306 	ldrd	r2, r3, [fp, #24]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 802567a:	eeb0 8a47 	vmov.f32	s16, s14
 802567e:	eef0 8a67 	vmov.f32	s17, s15
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8025682:	ec51 0b1c 	vmov	r0, r1, d12
 8025686:	f003 fa6f 	bl	8028b68 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 802568a:	e9da 6700 	ldrd	r6, r7, [sl]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 802568e:	4604      	mov	r4, r0
 8025690:	460d      	mov	r5, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 8025692:	ec53 2b18 	vmov	r2, r3, d8
 8025696:	4630      	mov	r0, r6
 8025698:	4639      	mov	r1, r7
 802569a:	f003 fa65 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 802569e:	e9da 8902 	ldrd	r8, r9, [sl, #8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80256a2:	ec45 4b19 	vmov	d9, r4, r5
        temp_r += A_real * x_real - A_imag * x_imag;
 80256a6:	4604      	mov	r4, r0
 80256a8:	ec53 2b19 	vmov	r2, r3, d9
 80256ac:	460d      	mov	r5, r1
 80256ae:	4640      	mov	r0, r8
 80256b0:	4649      	mov	r1, r9
 80256b2:	f003 fa59 	bl	8028b68 <__aeabi_dmul>
 80256b6:	4602      	mov	r2, r0
 80256b8:	460b      	mov	r3, r1
 80256ba:	4620      	mov	r0, r4
 80256bc:	4629      	mov	r1, r5
 80256be:	f003 f89b 	bl	80287f8 <__aeabi_dsub>
 80256c2:	4602      	mov	r2, r0
 80256c4:	460b      	mov	r3, r1
 80256c6:	ec51 0b1a 	vmov	r0, r1, d10
 80256ca:	f003 f897 	bl	80287fc <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 80256ce:	ec53 2b18 	vmov	r2, r3, d8
        temp_r += A_real * x_real - A_imag * x_imag;
 80256d2:	4604      	mov	r4, r0
 80256d4:	460d      	mov	r5, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 80256d6:	4640      	mov	r0, r8
 80256d8:	4649      	mov	r1, r9
 80256da:	f003 fa45 	bl	8028b68 <__aeabi_dmul>
        temp_r += A_real * x_real - A_imag * x_imag;
 80256de:	ec45 4b1a 	vmov	d10, r4, r5
        temp_i += A_real * x_imag + A_imag * x_real;
 80256e2:	ec53 2b19 	vmov	r2, r3, d9
 80256e6:	4604      	mov	r4, r0
 80256e8:	460d      	mov	r5, r1
 80256ea:	4630      	mov	r0, r6
 80256ec:	4639      	mov	r1, r7
 80256ee:	f003 fa3b 	bl	8028b68 <__aeabi_dmul>
 80256f2:	4602      	mov	r2, r0
 80256f4:	460b      	mov	r3, r1
 80256f6:	4620      	mov	r0, r4
 80256f8:	4629      	mov	r1, r5
 80256fa:	f003 f87f 	bl	80287fc <__adddf3>
 80256fe:	460b      	mov	r3, r1
 8025700:	4602      	mov	r2, r0
 8025702:	ec51 0b1b 	vmov	r0, r1, d11
 8025706:	f003 f879 	bl	80287fc <__adddf3>
 802570a:	9b02      	ldr	r3, [sp, #8]
 802570c:	449a      	add	sl, r3
      for (j = j_min; j < N; j++) {
 802570e:	9b01      	ldr	r3, [sp, #4]
 8025710:	f10b 0b10 	add.w	fp, fp, #16
 8025714:	455b      	cmp	r3, fp
        temp_i += A_real * x_imag + A_imag * x_real;
 8025716:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = j_min; j < N; j++) {
 802571a:	d1aa      	bne.n	8025672 <cblas_ztrmv+0x63a>
      if (nonunit) {
 802571c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802571e:	2b83      	cmp	r3, #131	; 0x83
 8025720:	d026      	beq.n	8025770 <cblas_ztrmv+0x738>
        REAL(X, ix) += temp_r;
 8025722:	9c04      	ldr	r4, [sp, #16]
 8025724:	ec53 2b1a 	vmov	r2, r3, d10
 8025728:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 802572c:	f003 f866 	bl	80287fc <__adddf3>
        IMAG(X, ix) += temp_i;
 8025730:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(X, ix) += temp_r;
 8025734:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 8025738:	e9d4 0100 	ldrd	r0, r1, [r4]
 802573c:	f003 f85e 	bl	80287fc <__adddf3>
 8025740:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 8025744:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025746:	9a07      	ldr	r2, [sp, #28]
 8025748:	4413      	add	r3, r2
 802574a:	930c      	str	r3, [sp, #48]	; 0x30
 802574c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802574e:	9b08      	ldr	r3, [sp, #32]
 8025750:	4413      	add	r3, r2
 8025752:	9308      	str	r3, [sp, #32]
 8025754:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8025756:	9b01      	ldr	r3, [sp, #4]
 8025758:	4413      	add	r3, r2
 802575a:	9301      	str	r3, [sp, #4]
 802575c:	9a02      	ldr	r2, [sp, #8]
 802575e:	9b04      	ldr	r3, [sp, #16]
 8025760:	4413      	add	r3, r2
 8025762:	9304      	str	r3, [sp, #16]
 8025764:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8025766:	9b06      	ldr	r3, [sp, #24]
 8025768:	4293      	cmp	r3, r2
 802576a:	f47f af65 	bne.w	8025638 <cblas_ztrmv+0x600>
 802576e:	e595      	b.n	802529c <cblas_ztrmv+0x264>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8025770:	9d08      	ldr	r5, [sp, #32]
        const BASE x_real = REAL(X, ix);
 8025772:	9c04      	ldr	r4, [sp, #16]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8025774:	ee1e 0a10 	vmov	r0, s28
 8025778:	f003 f98c 	bl	8028a94 <__aeabi_i2d>
 802577c:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8025780:	f003 f9f2 	bl	8028b68 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8025784:	e9d5 ab00 	ldrd	sl, fp, [r5]
        const BASE x_real = REAL(X, ix);
 8025788:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 802578c:	4680      	mov	r8, r0
 802578e:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8025790:	4652      	mov	r2, sl
 8025792:	465b      	mov	r3, fp
 8025794:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 8025798:	e9d4 6700 	ldrd	r6, r7, [r4]
 802579c:	9404      	str	r4, [sp, #16]
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 802579e:	f003 f9e3 	bl	8028b68 <__aeabi_dmul>
 80257a2:	4642      	mov	r2, r8
 80257a4:	4604      	mov	r4, r0
 80257a6:	460d      	mov	r5, r1
 80257a8:	464b      	mov	r3, r9
 80257aa:	4630      	mov	r0, r6
 80257ac:	4639      	mov	r1, r7
 80257ae:	f003 f9db 	bl	8028b68 <__aeabi_dmul>
 80257b2:	4602      	mov	r2, r0
 80257b4:	460b      	mov	r3, r1
 80257b6:	4620      	mov	r0, r4
 80257b8:	4629      	mov	r1, r5
 80257ba:	f003 f81d 	bl	80287f8 <__aeabi_dsub>
 80257be:	ec53 2b1a 	vmov	r2, r3, d10
 80257c2:	f003 f81b 	bl	80287fc <__adddf3>
 80257c6:	9c04      	ldr	r4, [sp, #16]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80257c8:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80257ca:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80257ce:	465b      	mov	r3, fp
 80257d0:	4630      	mov	r0, r6
 80257d2:	4639      	mov	r1, r7
 80257d4:	f003 f9c8 	bl	8028b68 <__aeabi_dmul>
 80257d8:	4642      	mov	r2, r8
 80257da:	4604      	mov	r4, r0
 80257dc:	464b      	mov	r3, r9
 80257de:	460d      	mov	r5, r1
 80257e0:	ec51 0b18 	vmov	r0, r1, d8
 80257e4:	f003 f9c0 	bl	8028b68 <__aeabi_dmul>
 80257e8:	4602      	mov	r2, r0
 80257ea:	460b      	mov	r3, r1
 80257ec:	4620      	mov	r0, r4
 80257ee:	4629      	mov	r1, r5
 80257f0:	f003 f804 	bl	80287fc <__adddf3>
 80257f4:	ec53 2b1b 	vmov	r2, r3, d11
 80257f8:	f003 f800 	bl	80287fc <__adddf3>
 80257fc:	9c04      	ldr	r4, [sp, #16]
 80257fe:	e9c4 0100 	strd	r0, r1, [r4]
 8025802:	e79f      	b.n	8025744 <cblas_ztrmv+0x70c>
      BASE temp_i = 0.0;
 8025804:	ed1f 7b88 	vldr	d7, [pc, #-544]	; 80255e8 <cblas_ztrmv+0x5b0>
 8025808:	eeb0 ba47 	vmov.f32	s22, s14
 802580c:	eef0 ba67 	vmov.f32	s23, s15
      BASE temp_r = 0.0;
 8025810:	eeb0 aa47 	vmov.f32	s20, s14
 8025814:	eef0 aa67 	vmov.f32	s21, s15
 8025818:	e780      	b.n	802571c <cblas_ztrmv+0x6e4>
      BASE temp_i = 0.0;
 802581a:	ed1f 7b8d 	vldr	d7, [pc, #-564]	; 80255e8 <cblas_ztrmv+0x5b0>
 802581e:	eeb0 ba47 	vmov.f32	s22, s14
 8025822:	eef0 ba67 	vmov.f32	s23, s15
      BASE temp_r = 0.0;
 8025826:	eeb0 aa47 	vmov.f32	s20, s14
 802582a:	eef0 aa67 	vmov.f32	s21, s15
 802582e:	e510      	b.n	8025252 <cblas_ztrmv+0x21a>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8025830:	9b07      	ldr	r3, [sp, #28]
 8025832:	9e07      	ldr	r6, [sp, #28]
 8025834:	2b00      	cmp	r3, #0
 8025836:	bfd8      	it	le
 8025838:	9a07      	ldrle	r2, [sp, #28]
 802583a:	9b06      	ldr	r3, [sp, #24]
 802583c:	bfd8      	it	le
 802583e:	4251      	negle	r1, r2
 8025840:	f103 33ff 	add.w	r3, r3, #4294967295
 8025844:	bfd8      	it	le
 8025846:	4359      	mulle	r1, r3
 8025848:	9308      	str	r3, [sp, #32]
    for (i = N; i > 0 && i--;) {
 802584a:	9b06      	ldr	r3, [sp, #24]
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 802584c:	9f08      	ldr	r7, [sp, #32]
 802584e:	bfc8      	it	gt
 8025850:	2100      	movgt	r1, #0
    for (i = N; i > 0 && i--;) {
 8025852:	2b00      	cmp	r3, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8025854:	fb07 1206 	mla	r2, r7, r6, r1
    for (i = N; i > 0 && i--;) {
 8025858:	f77f ad20 	ble.w	802529c <cblas_ztrmv+0x264>
 802585c:	9809      	ldr	r0, [sp, #36]	; 0x24
 802585e:	eb00 1202 	add.w	r2, r0, r2, lsl #4
 8025862:	f102 0c08 	add.w	ip, r2, #8
 8025866:	9a06      	ldr	r2, [sp, #24]
 8025868:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
 802586c:	eb04 1202 	add.w	r2, r4, r2, lsl #4
 8025870:	920d      	str	r2, [sp, #52]	; 0x34
 8025872:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8025874:	1c6b      	adds	r3, r5, #1
 8025876:	011b      	lsls	r3, r3, #4
 8025878:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 802587c:	43ed      	mvns	r5, r5
 802587e:	9211      	str	r2, [sp, #68]	; 0x44
 8025880:	fb03 4207 	mla	r2, r3, r7, r4
 8025884:	3b10      	subs	r3, #16
 8025886:	ebc6 7006 	rsb	r0, r6, r6, lsl #28
 802588a:	9309      	str	r3, [sp, #36]	; 0x24
 802588c:	012b      	lsls	r3, r5, #4
 802588e:	930f      	str	r3, [sp, #60]	; 0x3c
 8025890:	0103      	lsls	r3, r0, #4
 8025892:	9310      	str	r3, [sp, #64]	; 0x40
 8025894:	0133      	lsls	r3, r6, #4
 8025896:	920e      	str	r2, [sp, #56]	; 0x38
 8025898:	930a      	str	r3, [sp, #40]	; 0x28
      for (j = 0; j < j_max; j++) {
 802589a:	9b08      	ldr	r3, [sp, #32]
 802589c:	2b00      	cmp	r3, #0
 802589e:	f000 80e6 	beq.w	8025a6e <cblas_ztrmv+0xa36>
 80258a2:	ee1e 0a10 	vmov	r0, s28
 80258a6:	f003 f8f5 	bl	8028a94 <__aeabi_i2d>
 80258aa:	ed1f 7bb1 	vldr	d7, [pc, #-708]	; 80255e8 <cblas_ztrmv+0x5b0>
 80258ae:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80258b0:	9301      	str	r3, [sp, #4]
 80258b2:	ed8d 7b04 	vstr	d7, [sp, #16]
 80258b6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80258b8:	9306      	str	r3, [sp, #24]
 80258ba:	ed8d 7b02 	vstr	d7, [sp, #8]
 80258be:	2300      	movs	r3, #0
 80258c0:	ec41 0b19 	vmov	d9, r0, r1
 80258c4:	9307      	str	r3, [sp, #28]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80258c6:	9b01      	ldr	r3, [sp, #4]
        const BASE x_real = REAL(X, jx);
 80258c8:	9e06      	ldr	r6, [sp, #24]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80258ca:	e953 ab04 	ldrd	sl, fp, [r3, #-16]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80258ce:	ec51 0b19 	vmov	r0, r1, d9
 80258d2:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 80258d6:	f003 f947 	bl	8028b68 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 80258da:	ed96 8b00 	vldr	d8, [r6]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80258de:	4604      	mov	r4, r0
 80258e0:	460d      	mov	r5, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 80258e2:	4652      	mov	r2, sl
 80258e4:	465b      	mov	r3, fp
 80258e6:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, jx);
 80258ea:	e9d6 8902 	ldrd	r8, r9, [r6, #8]
 80258ee:	9606      	str	r6, [sp, #24]
        temp_r += A_real * x_real - A_imag * x_imag;
 80258f0:	f003 f93a 	bl	8028b68 <__aeabi_dmul>
 80258f4:	4622      	mov	r2, r4
 80258f6:	462b      	mov	r3, r5
 80258f8:	4606      	mov	r6, r0
 80258fa:	460f      	mov	r7, r1
 80258fc:	4640      	mov	r0, r8
 80258fe:	4649      	mov	r1, r9
 8025900:	f003 f932 	bl	8028b68 <__aeabi_dmul>
 8025904:	4602      	mov	r2, r0
 8025906:	460b      	mov	r3, r1
 8025908:	4630      	mov	r0, r6
 802590a:	4639      	mov	r1, r7
 802590c:	f002 ff74 	bl	80287f8 <__aeabi_dsub>
 8025910:	4602      	mov	r2, r0
 8025912:	460b      	mov	r3, r1
 8025914:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8025918:	f002 ff70 	bl	80287fc <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 802591c:	4652      	mov	r2, sl
        temp_r += A_real * x_real - A_imag * x_imag;
 802591e:	4606      	mov	r6, r0
 8025920:	460f      	mov	r7, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 8025922:	465b      	mov	r3, fp
 8025924:	4640      	mov	r0, r8
 8025926:	4649      	mov	r1, r9
        temp_r += A_real * x_real - A_imag * x_imag;
 8025928:	e9cd 6702 	strd	r6, r7, [sp, #8]
        temp_i += A_real * x_imag + A_imag * x_real;
 802592c:	f003 f91c 	bl	8028b68 <__aeabi_dmul>
 8025930:	4622      	mov	r2, r4
 8025932:	462b      	mov	r3, r5
 8025934:	4604      	mov	r4, r0
 8025936:	460d      	mov	r5, r1
 8025938:	ec51 0b18 	vmov	r0, r1, d8
 802593c:	f003 f914 	bl	8028b68 <__aeabi_dmul>
 8025940:	4602      	mov	r2, r0
 8025942:	460b      	mov	r3, r1
 8025944:	4620      	mov	r0, r4
 8025946:	4629      	mov	r1, r5
 8025948:	f002 ff58 	bl	80287fc <__adddf3>
 802594c:	4602      	mov	r2, r0
 802594e:	460b      	mov	r3, r1
 8025950:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8025954:	f002 ff52 	bl	80287fc <__adddf3>
 8025958:	9b01      	ldr	r3, [sp, #4]
 802595a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802595c:	9e06      	ldr	r6, [sp, #24]
      for (j = 0; j < j_max; j++) {
 802595e:	9c07      	ldr	r4, [sp, #28]
 8025960:	4413      	add	r3, r2
 8025962:	9301      	str	r3, [sp, #4]
 8025964:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8025966:	18f3      	adds	r3, r6, r3
 8025968:	9306      	str	r3, [sp, #24]
 802596a:	9b08      	ldr	r3, [sp, #32]
 802596c:	3401      	adds	r4, #1
 802596e:	42a3      	cmp	r3, r4
        temp_i += A_real * x_imag + A_imag * x_real;
 8025970:	e9cd 0104 	strd	r0, r1, [sp, #16]
      for (j = 0; j < j_max; j++) {
 8025974:	9407      	str	r4, [sp, #28]
 8025976:	d1a6      	bne.n	80258c6 <cblas_ztrmv+0x88e>
      if (nonunit) {
 8025978:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802597a:	2b83      	cmp	r3, #131	; 0x83
 802597c:	d022      	beq.n	80259c4 <cblas_ztrmv+0x98c>
        REAL(X, ix) += temp_r;
 802597e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8025980:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8025984:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8025988:	f002 ff38 	bl	80287fc <__adddf3>
        IMAG(X, ix) += temp_i;
 802598c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
        REAL(X, ix) += temp_r;
 8025990:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 8025994:	e9d4 0100 	ldrd	r0, r1, [r4]
 8025998:	f002 ff30 	bl	80287fc <__adddf3>
 802599c:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 80259a0:	e9dd 320e 	ldrd	r3, r2, [sp, #56]	; 0x38
 80259a4:	4413      	add	r3, r2
 80259a6:	930e      	str	r3, [sp, #56]	; 0x38
 80259a8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80259aa:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80259ac:	3b10      	subs	r3, #16
 80259ae:	930d      	str	r3, [sp, #52]	; 0x34
 80259b0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80259b2:	4413      	add	r3, r2
 80259b4:	930c      	str	r3, [sp, #48]	; 0x30
 80259b6:	9b08      	ldr	r3, [sp, #32]
 80259b8:	2b00      	cmp	r3, #0
 80259ba:	f43f ac6f 	beq.w	802529c <cblas_ztrmv+0x264>
 80259be:	3b01      	subs	r3, #1
 80259c0:	9308      	str	r3, [sp, #32]
 80259c2:	e76a      	b.n	802589a <cblas_ztrmv+0x862>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80259c4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
        const BASE x_real = REAL(X, ix);
 80259c6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80259c8:	ee1e 0a10 	vmov	r0, s28
 80259cc:	f003 f862 	bl	8028a94 <__aeabi_i2d>
 80259d0:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 80259d4:	f003 f8c8 	bl	8028b68 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80259d8:	e9d5 ab00 	ldrd	sl, fp, [r5]
        const BASE x_real = REAL(X, ix);
 80259dc:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80259e0:	4680      	mov	r8, r0
 80259e2:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80259e4:	4652      	mov	r2, sl
 80259e6:	465b      	mov	r3, fp
 80259e8:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 80259ec:	e9d4 6700 	ldrd	r6, r7, [r4]
 80259f0:	940c      	str	r4, [sp, #48]	; 0x30
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80259f2:	f003 f8b9 	bl	8028b68 <__aeabi_dmul>
 80259f6:	4642      	mov	r2, r8
 80259f8:	4604      	mov	r4, r0
 80259fa:	460d      	mov	r5, r1
 80259fc:	464b      	mov	r3, r9
 80259fe:	4630      	mov	r0, r6
 8025a00:	4639      	mov	r1, r7
 8025a02:	f003 f8b1 	bl	8028b68 <__aeabi_dmul>
 8025a06:	4602      	mov	r2, r0
 8025a08:	460b      	mov	r3, r1
 8025a0a:	4620      	mov	r0, r4
 8025a0c:	4629      	mov	r1, r5
 8025a0e:	f002 fef3 	bl	80287f8 <__aeabi_dsub>
 8025a12:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8025a16:	f002 fef1 	bl	80287fc <__adddf3>
 8025a1a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8025a1c:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8025a1e:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8025a22:	465b      	mov	r3, fp
 8025a24:	4630      	mov	r0, r6
 8025a26:	4639      	mov	r1, r7
 8025a28:	f003 f89e 	bl	8028b68 <__aeabi_dmul>
 8025a2c:	4642      	mov	r2, r8
 8025a2e:	4604      	mov	r4, r0
 8025a30:	464b      	mov	r3, r9
 8025a32:	460d      	mov	r5, r1
 8025a34:	ec51 0b18 	vmov	r0, r1, d8
 8025a38:	f003 f896 	bl	8028b68 <__aeabi_dmul>
 8025a3c:	4602      	mov	r2, r0
 8025a3e:	460b      	mov	r3, r1
 8025a40:	4620      	mov	r0, r4
 8025a42:	4629      	mov	r1, r5
 8025a44:	f002 feda 	bl	80287fc <__adddf3>
 8025a48:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8025a4c:	f002 fed6 	bl	80287fc <__adddf3>
 8025a50:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8025a52:	e9c4 0100 	strd	r0, r1, [r4]
 8025a56:	e7a3      	b.n	80259a0 <cblas_ztrmv+0x968>
      for (j = 0; j < j_max; j++) {
 8025a58:	ed9f 7b0b 	vldr	d7, [pc, #44]	; 8025a88 <cblas_ztrmv+0xa50>
 8025a5c:	eeb0 ca47 	vmov.f32	s24, s14
 8025a60:	eef0 ca67 	vmov.f32	s25, s15
 8025a64:	eeb0 ba47 	vmov.f32	s22, s14
 8025a68:	eef0 ba67 	vmov.f32	s23, s15
 8025a6c:	e541      	b.n	80254f2 <cblas_ztrmv+0x4ba>
      for (j = 0; j < j_max; j++) {
 8025a6e:	ed9f 7b06 	vldr	d7, [pc, #24]	; 8025a88 <cblas_ztrmv+0xa50>
 8025a72:	ed8d 7b04 	vstr	d7, [sp, #16]
 8025a76:	ed8d 7b02 	vstr	d7, [sp, #8]
 8025a7a:	e77d      	b.n	8025978 <cblas_ztrmv+0x940>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8025a7c:	2009      	movs	r0, #9
 8025a7e:	f7ff bb0e 	b.w	802509e <cblas_ztrmv+0x66>
 8025a82:	bf00      	nop
 8025a84:	f3af 8000 	nop.w
	...

08025a90 <xhypot>:
{
 8025a90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 8025a92:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 8025a96:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  if (xabs < yabs) {
 8025a9a:	4639      	mov	r1, r7
 8025a9c:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 8025a9e:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 8025aa0:	4614      	mov	r4, r2
  if (xabs < yabs) {
 8025aa2:	f003 fad3 	bl	802904c <__aeabi_dcmplt>
 8025aa6:	b928      	cbnz	r0, 8025ab4 <xhypot+0x24>
 8025aa8:	4632      	mov	r2, r6
 8025aaa:	463b      	mov	r3, r7
    min = yabs ;
 8025aac:	4626      	mov	r6, r4
 8025aae:	462f      	mov	r7, r5
    max = xabs ;
 8025ab0:	4614      	mov	r4, r2
 8025ab2:	461d      	mov	r5, r3
  if (min == 0) 
 8025ab4:	2200      	movs	r2, #0
 8025ab6:	2300      	movs	r3, #0
 8025ab8:	4630      	mov	r0, r6
 8025aba:	4639      	mov	r1, r7
 8025abc:	f003 fabc 	bl	8029038 <__aeabi_dcmpeq>
 8025ac0:	b9c8      	cbnz	r0, 8025af6 <xhypot+0x66>
    double u = min / max ;
 8025ac2:	4622      	mov	r2, r4
 8025ac4:	462b      	mov	r3, r5
 8025ac6:	4630      	mov	r0, r6
 8025ac8:	4639      	mov	r1, r7
 8025aca:	f003 f977 	bl	8028dbc <__aeabi_ddiv>
 8025ace:	4602      	mov	r2, r0
 8025ad0:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 8025ad2:	f003 f849 	bl	8028b68 <__aeabi_dmul>
 8025ad6:	4b09      	ldr	r3, [pc, #36]	; (8025afc <xhypot+0x6c>)
 8025ad8:	2200      	movs	r2, #0
 8025ada:	f002 fe8f 	bl	80287fc <__adddf3>
 8025ade:	ec41 0b10 	vmov	d0, r0, r1
 8025ae2:	f00b f897 	bl	8030c14 <sqrt>
 8025ae6:	4620      	mov	r0, r4
 8025ae8:	4629      	mov	r1, r5
 8025aea:	ec53 2b10 	vmov	r2, r3, d0
 8025aee:	f003 f83b 	bl	8028b68 <__aeabi_dmul>
 8025af2:	4604      	mov	r4, r0
 8025af4:	460d      	mov	r5, r1
}
 8025af6:	4620      	mov	r0, r4
 8025af8:	4629      	mov	r1, r5
 8025afa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025afc:	3ff00000 	.word	0x3ff00000

08025b00 <cblas_ztrsm>:
cblas_ztrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8025b00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025b04:	ed2d 8b0a 	vpush	{d8-d12}
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8025b08:	2b71      	cmp	r3, #113	; 0x71
 8025b0a:	b095      	sub	sp, #84	; 0x54
 8025b0c:	461d      	mov	r5, r3
 8025b0e:	bf0c      	ite	eq
 8025b10:	f04f 33ff 	moveq.w	r3, #4294967295
 8025b14:	2301      	movne	r3, #1
 8025b16:	ee0c 3a10 	vmov	s24, r3
 8025b1a:	f89d 30a0 	ldrb.w	r3, [sp, #160]	; 0xa0
 8025b1e:	9305      	str	r3, [sp, #20]
 8025b20:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 8025b22:	9302      	str	r3, [sp, #8]
 8025b24:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8025b26:	9306      	str	r3, [sp, #24]
 8025b28:	e9dd 732b 	ldrd	r7, r3, [sp, #172]	; 0xac
 8025b2c:	930a      	str	r3, [sp, #40]	; 0x28
 8025b2e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8025b30:	9301      	str	r3, [sp, #4]
 8025b32:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8025b34:	930c      	str	r3, [sp, #48]	; 0x30
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025b36:	298d      	cmp	r1, #141	; 0x8d
 8025b38:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8025b3a:	930b      	str	r3, [sp, #44]	; 0x2c
 8025b3c:	460c      	mov	r4, r1
 8025b3e:	4616      	mov	r6, r2
 8025b40:	d06c      	beq.n	8025c1c <cblas_ztrsm+0x11c>
 8025b42:	298e      	cmp	r1, #142	; 0x8e
 8025b44:	f000 85ff 	beq.w	8026746 <cblas_ztrsm+0xc46>
 8025b48:	f8dd c018 	ldr.w	ip, [sp, #24]
 8025b4c:	2302      	movs	r3, #2
 8025b4e:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 8025b52:	2a01      	cmp	r2, #1
 8025b54:	9a05      	ldr	r2, [sp, #20]
 8025b56:	f1a5 016f 	sub.w	r1, r5, #111	; 0x6f
 8025b5a:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8025b5e:	bf88      	it	hi
 8025b60:	2303      	movhi	r3, #3
 8025b62:	b2d2      	uxtb	r2, r2
 8025b64:	2902      	cmp	r1, #2
 8025b66:	bf88      	it	hi
 8025b68:	2304      	movhi	r3, #4
 8025b6a:	2a02      	cmp	r2, #2
 8025b6c:	9a02      	ldr	r2, [sp, #8]
 8025b6e:	bf28      	it	cs
 8025b70:	2305      	movcs	r3, #5
 8025b72:	2a00      	cmp	r2, #0
 8025b74:	9a06      	ldr	r2, [sp, #24]
 8025b76:	bfb8      	it	lt
 8025b78:	2306      	movlt	r3, #6
 8025b7a:	2a00      	cmp	r2, #0
 8025b7c:	bfb8      	it	lt
 8025b7e:	2307      	movlt	r3, #7
 8025b80:	9a01      	ldr	r2, [sp, #4]
 8025b82:	f1bc 0f01 	cmp.w	ip, #1
 8025b86:	bfb8      	it	lt
 8025b88:	f04f 0c01 	movlt.w	ip, #1
 8025b8c:	4594      	cmp	ip, r2
 8025b8e:	dd38      	ble.n	8025c02 <cblas_ztrsm+0x102>
 8025b90:	2865      	cmp	r0, #101	; 0x65
 8025b92:	f000 8189 	beq.w	8025ea8 <cblas_ztrsm+0x3a8>
 8025b96:	9b02      	ldr	r3, [sp, #8]
 8025b98:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8025b9a:	2b01      	cmp	r3, #1
 8025b9c:	bfb8      	it	lt
 8025b9e:	2301      	movlt	r3, #1
 8025ba0:	4293      	cmp	r3, r2
 8025ba2:	bfcc      	ite	gt
 8025ba4:	230c      	movgt	r3, #12
 8025ba6:	230a      	movle	r3, #10
 8025ba8:	4abb      	ldr	r2, [pc, #748]	; (8025e98 <cblas_ztrsm+0x398>)
 8025baa:	49bc      	ldr	r1, [pc, #752]	; (8025e9c <cblas_ztrsm+0x39c>)
 8025bac:	4618      	mov	r0, r3
 8025bae:	f002 fdab 	bl	8028708 <cblas_xerbla>
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8025bb2:	2c8d      	cmp	r4, #141	; 0x8d
    const BASE alpha_real = CONST_REAL0(alpha);
 8025bb4:	ed97 7b00 	vldr	d7, [r7]
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8025bb8:	bf0c      	ite	eq
 8025bba:	248e      	moveq	r4, #142	; 0x8e
 8025bbc:	248d      	movne	r4, #141	; 0x8d
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8025bbe:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
    const BASE alpha_real = CONST_REAL0(alpha);
 8025bc2:	eeb0 8a47 	vmov.f32	s16, s14
 8025bc6:	eef0 8a67 	vmov.f32	s17, s15
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8025bca:	2e79      	cmp	r6, #121	; 0x79
 8025bcc:	bf0c      	ite	eq
 8025bce:	267a      	moveq	r6, #122	; 0x7a
 8025bd0:	2679      	movne	r6, #121	; 0x79
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 8025bd2:	2d6f      	cmp	r5, #111	; 0x6f
 8025bd4:	bf0c      	ite	eq
 8025bd6:	256f      	moveq	r5, #111	; 0x6f
 8025bd8:	2570      	movne	r5, #112	; 0x70
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8025bda:	2c8d      	cmp	r4, #141	; 0x8d
 8025bdc:	d027      	beq.n	8025c2e <cblas_ztrsm+0x12e>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8025bde:	2c8e      	cmp	r4, #142	; 0x8e
 8025be0:	d105      	bne.n	8025bee <cblas_ztrsm+0xee>
 8025be2:	2e79      	cmp	r6, #121	; 0x79
 8025be4:	f000 8183 	beq.w	8025eee <cblas_ztrsm+0x3ee>
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8025be8:	2e7a      	cmp	r6, #122	; 0x7a
 8025bea:	f000 82f7 	beq.w	80261dc <cblas_ztrsm+0x6dc>
      BLAS_ERROR("unrecognized operation");
 8025bee:	4aac      	ldr	r2, [pc, #688]	; (8025ea0 <cblas_ztrsm+0x3a0>)
 8025bf0:	49aa      	ldr	r1, [pc, #680]	; (8025e9c <cblas_ztrsm+0x39c>)
 8025bf2:	2000      	movs	r0, #0
#define BASE double
#include "source_trsm_c.h"
#undef BASE
}
 8025bf4:	b015      	add	sp, #84	; 0x54
 8025bf6:	ecbd 8b0a 	vpop	{d8-d12}
 8025bfa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8025bfe:	f002 bd83 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025c02:	2865      	cmp	r0, #101	; 0x65
 8025c04:	f000 845d 	beq.w	80264c2 <cblas_ztrsm+0x9c2>
 8025c08:	9a02      	ldr	r2, [sp, #8]
 8025c0a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8025c0c:	2a01      	cmp	r2, #1
 8025c0e:	bfb8      	it	lt
 8025c10:	2201      	movlt	r2, #1
 8025c12:	428a      	cmp	r2, r1
 8025c14:	f340 8167 	ble.w	8025ee6 <cblas_ztrsm+0x3e6>
 8025c18:	230c      	movs	r3, #12
 8025c1a:	e7c5      	b.n	8025ba8 <cblas_ztrsm+0xa8>
 8025c1c:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8025c20:	2b01      	cmp	r3, #1
 8025c22:	f8dd c008 	ldr.w	ip, [sp, #8]
 8025c26:	bf94      	ite	ls
 8025c28:	2300      	movls	r3, #0
 8025c2a:	2301      	movhi	r3, #1
 8025c2c:	e78f      	b.n	8025b4e <cblas_ztrsm+0x4e>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8025c2e:	2e79      	cmp	r6, #121	; 0x79
 8025c30:	f000 8454 	beq.w	80264dc <cblas_ztrsm+0x9dc>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8025c34:	2e7a      	cmp	r6, #122	; 0x7a
 8025c36:	d1da      	bne.n	8025bee <cblas_ztrsm+0xee>
 8025c38:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025c3a:	4b9a      	ldr	r3, [pc, #616]	; (8025ea4 <cblas_ztrsm+0x3a4>)
 8025c3c:	ec51 0b18 	vmov	r0, r1, d8
 8025c40:	f04f 0200 	mov.w	r2, #0
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8025c44:	f000 86c4 	beq.w	80269d0 <cblas_ztrsm+0xed0>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025c48:	f003 f9f6 	bl	8029038 <__aeabi_dcmpeq>
 8025c4c:	2800      	cmp	r0, #0
 8025c4e:	f040 8597 	bne.w	8026780 <cblas_ztrsm+0xc80>
        for (i = 0; i < n1; i++) {
 8025c52:	9b06      	ldr	r3, [sp, #24]
 8025c54:	2b00      	cmp	r3, #0
 8025c56:	f340 85df 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8025c5a:	9a02      	ldr	r2, [sp, #8]
 8025c5c:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8025c60:	011b      	lsls	r3, r3, #4
 8025c62:	9307      	str	r3, [sp, #28]
 8025c64:	3308      	adds	r3, #8
 8025c66:	9308      	str	r3, [sp, #32]
 8025c68:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025c6a:	011b      	lsls	r3, r3, #4
 8025c6c:	9303      	str	r3, [sp, #12]
 8025c6e:	0113      	lsls	r3, r2, #4
 8025c70:	9310      	str	r3, [sp, #64]	; 0x40
 8025c72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025c74:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8025c78:	9300      	str	r3, [sp, #0]
 8025c7a:	2300      	movs	r3, #0
 8025c7c:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8025c7e:	9b02      	ldr	r3, [sp, #8]
 8025c80:	2b00      	cmp	r3, #0
 8025c82:	dd3e      	ble.n	8025d02 <cblas_ztrsm+0x202>
 8025c84:	9b07      	ldr	r3, [sp, #28]
 8025c86:	9a08      	ldr	r2, [sp, #32]
 8025c88:	4619      	mov	r1, r3
 8025c8a:	9b00      	ldr	r3, [sp, #0]
 8025c8c:	eb01 0803 	add.w	r8, r1, r3
 8025c90:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025c94:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025c98:	ec53 2b18 	vmov	r2, r3, d8
 8025c9c:	4630      	mov	r0, r6
 8025c9e:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025ca0:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025ca4:	f002 ff60 	bl	8028b68 <__aeabi_dmul>
 8025ca8:	4652      	mov	r2, sl
 8025caa:	ec41 0b19 	vmov	d9, r0, r1
 8025cae:	465b      	mov	r3, fp
 8025cb0:	4620      	mov	r0, r4
 8025cb2:	4629      	mov	r1, r5
 8025cb4:	f002 ff58 	bl	8028b68 <__aeabi_dmul>
 8025cb8:	4602      	mov	r2, r0
 8025cba:	460b      	mov	r3, r1
 8025cbc:	ec51 0b19 	vmov	r0, r1, d9
 8025cc0:	f002 fd9a 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025cc4:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025cc8:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025ccc:	4620      	mov	r0, r4
 8025cce:	4629      	mov	r1, r5
 8025cd0:	f002 ff4a 	bl	8028b68 <__aeabi_dmul>
 8025cd4:	4652      	mov	r2, sl
 8025cd6:	465b      	mov	r3, fp
 8025cd8:	4604      	mov	r4, r0
 8025cda:	460d      	mov	r5, r1
 8025cdc:	4630      	mov	r0, r6
 8025cde:	4639      	mov	r1, r7
 8025ce0:	f002 ff42 	bl	8028b68 <__aeabi_dmul>
 8025ce4:	460b      	mov	r3, r1
 8025ce6:	4602      	mov	r2, r0
 8025ce8:	4629      	mov	r1, r5
 8025cea:	4620      	mov	r0, r4
 8025cec:	f002 fd86 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 8025cf0:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025cf2:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8025cf6:	f108 0810 	add.w	r8, r8, #16
 8025cfa:	4543      	cmp	r3, r8
 8025cfc:	f109 0910 	add.w	r9, r9, #16
 8025d00:	d1c8      	bne.n	8025c94 <cblas_ztrsm+0x194>
        for (i = 0; i < n1; i++) {
 8025d02:	9a00      	ldr	r2, [sp, #0]
 8025d04:	9903      	ldr	r1, [sp, #12]
 8025d06:	9b04      	ldr	r3, [sp, #16]
 8025d08:	440a      	add	r2, r1
 8025d0a:	9200      	str	r2, [sp, #0]
 8025d0c:	9a06      	ldr	r2, [sp, #24]
 8025d0e:	3301      	adds	r3, #1
 8025d10:	429a      	cmp	r2, r3
 8025d12:	9304      	str	r3, [sp, #16]
 8025d14:	d1b3      	bne.n	8025c7e <cblas_ztrsm+0x17e>
 8025d16:	9806      	ldr	r0, [sp, #24]
 8025d18:	9901      	ldr	r1, [sp, #4]
 8025d1a:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8025d1c:	1e42      	subs	r2, r0, #1
 8025d1e:	460b      	mov	r3, r1
 8025d20:	fb03 f302 	mul.w	r3, r3, r2
 8025d24:	ebc4 7504 	rsb	r5, r4, r4, lsl #28
 8025d28:	18c6      	adds	r6, r0, r3
 8025d2a:	012c      	lsls	r4, r5, #4
 8025d2c:	980a      	ldr	r0, [sp, #40]	; 0x28
 8025d2e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8025d30:	9207      	str	r2, [sp, #28]
 8025d32:	f1a0 0c10 	sub.w	ip, r0, #16
 8025d36:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 8025d3a:	fb01 2002 	mla	r0, r1, r2, r2
 8025d3e:	9309      	str	r3, [sp, #36]	; 0x24
 8025d40:	eb0c 1306 	add.w	r3, ip, r6, lsl #4
 8025d44:	4617      	mov	r7, r2
 8025d46:	9306      	str	r3, [sp, #24]
 8025d48:	460a      	mov	r2, r1
 8025d4a:	eb05 1300 	add.w	r3, r5, r0, lsl #4
 8025d4e:	ebc2 7202 	rsb	r2, r2, r2, lsl #28
 8025d52:	930a      	str	r3, [sp, #40]	; 0x28
 8025d54:	9b03      	ldr	r3, [sp, #12]
 8025d56:	940e      	str	r4, [sp, #56]	; 0x38
 8025d58:	0112      	lsls	r2, r2, #4
 8025d5a:	461c      	mov	r4, r3
 8025d5c:	920f      	str	r2, [sp, #60]	; 0x3c
 8025d5e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025d60:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8025d62:	43c9      	mvns	r1, r1
 8025d64:	fb04 3007 	mla	r0, r4, r7, r3
 8025d68:	0109      	lsls	r1, r1, #4
 8025d6a:	4413      	add	r3, r2
 8025d6c:	9008      	str	r0, [sp, #32]
 8025d6e:	910b      	str	r1, [sp, #44]	; 0x2c
 8025d70:	930d      	str	r3, [sp, #52]	; 0x34
        if (nonunit) {
 8025d72:	9b05      	ldr	r3, [sp, #20]
 8025d74:	2b83      	cmp	r3, #131	; 0x83
 8025d76:	f001 8442 	beq.w	80275fe <cblas_ztrsm+0x1afe>
        for (k = 0; k < i; k++) {
 8025d7a:	9b07      	ldr	r3, [sp, #28]
 8025d7c:	2b00      	cmp	r3, #0
 8025d7e:	f000 854b 	beq.w	8026818 <cblas_ztrsm+0xd18>
 8025d82:	ee1c 0a10 	vmov	r0, s24
 8025d86:	f002 fe85 	bl	8028a94 <__aeabi_i2d>
 8025d8a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8025d8c:	9301      	str	r3, [sp, #4]
 8025d8e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025d90:	9304      	str	r3, [sp, #16]
 8025d92:	ec41 0b1b 	vmov	d11, r0, r1
 8025d96:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8025d98:	9300      	str	r3, [sp, #0]
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8025d9a:	9c00      	ldr	r4, [sp, #0]
 8025d9c:	ec51 0b1b 	vmov	r0, r1, d11
 8025da0:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8025da4:	f002 fee0 	bl	8028b68 <__aeabi_dmul>
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8025da8:	ed94 7b00 	vldr	d7, [r4]
          for (j = 0; j < n2; j++) {
 8025dac:	9b02      	ldr	r3, [sp, #8]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8025dae:	eeb0 9a47 	vmov.f32	s18, s14
 8025db2:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 8025db6:	2b00      	cmp	r3, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8025db8:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8025dbc:	dd49      	ble.n	8025e52 <cblas_ztrsm+0x352>
 8025dbe:	9b04      	ldr	r3, [sp, #16]
 8025dc0:	9c08      	ldr	r4, [sp, #32]
 8025dc2:	9d01      	ldr	r5, [sp, #4]
 8025dc4:	f103 0b08 	add.w	fp, r3, #8
 8025dc8:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025dca:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8025dce:	ec51 0b19 	vmov	r0, r1, d9
 8025dd2:	4632      	mov	r2, r6
 8025dd4:	463b      	mov	r3, r7
 8025dd6:	f002 fec7 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025dda:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8025dde:	ec41 0b1a 	vmov	d10, r0, r1
 8025de2:	4642      	mov	r2, r8
 8025de4:	464b      	mov	r3, r9
 8025de6:	ec51 0b18 	vmov	r0, r1, d8
 8025dea:	f002 febd 	bl	8028b68 <__aeabi_dmul>
 8025dee:	4602      	mov	r2, r0
 8025df0:	460b      	mov	r3, r1
 8025df2:	ec51 0b1a 	vmov	r0, r1, d10
 8025df6:	f002 fcff 	bl	80287f8 <__aeabi_dsub>
 8025dfa:	4602      	mov	r2, r0
 8025dfc:	460b      	mov	r3, r1
 8025dfe:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8025e02:	f002 fcf9 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8025e06:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8025e08:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8025e0c:	464b      	mov	r3, r9
 8025e0e:	ec51 0b19 	vmov	r0, r1, d9
 8025e12:	f002 fea9 	bl	8028b68 <__aeabi_dmul>
 8025e16:	4632      	mov	r2, r6
 8025e18:	463b      	mov	r3, r7
 8025e1a:	4606      	mov	r6, r0
 8025e1c:	460f      	mov	r7, r1
 8025e1e:	ec51 0b18 	vmov	r0, r1, d8
 8025e22:	f002 fea1 	bl	8028b68 <__aeabi_dmul>
 8025e26:	4602      	mov	r2, r0
 8025e28:	460b      	mov	r3, r1
 8025e2a:	4630      	mov	r0, r6
 8025e2c:	4639      	mov	r1, r7
 8025e2e:	f002 fce5 	bl	80287fc <__adddf3>
 8025e32:	4602      	mov	r2, r0
 8025e34:	460b      	mov	r3, r1
 8025e36:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8025e3a:	f002 fcdd 	bl	80287f8 <__aeabi_dsub>
 8025e3e:	f10a 0a10 	add.w	sl, sl, #16
 8025e42:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8025e46:	4555      	cmp	r5, sl
 8025e48:	f104 0410 	add.w	r4, r4, #16
 8025e4c:	f10b 0b10 	add.w	fp, fp, #16
 8025e50:	d1bb      	bne.n	8025dca <cblas_ztrsm+0x2ca>
        for (k = 0; k < i; k++) {
 8025e52:	9904      	ldr	r1, [sp, #16]
 8025e54:	9a03      	ldr	r2, [sp, #12]
 8025e56:	9b00      	ldr	r3, [sp, #0]
 8025e58:	4608      	mov	r0, r1
 8025e5a:	9901      	ldr	r1, [sp, #4]
 8025e5c:	4410      	add	r0, r2
 8025e5e:	4411      	add	r1, r2
 8025e60:	9a06      	ldr	r2, [sp, #24]
 8025e62:	9004      	str	r0, [sp, #16]
 8025e64:	3310      	adds	r3, #16
 8025e66:	429a      	cmp	r2, r3
 8025e68:	9300      	str	r3, [sp, #0]
 8025e6a:	9101      	str	r1, [sp, #4]
 8025e6c:	d195      	bne.n	8025d9a <cblas_ztrsm+0x29a>
 8025e6e:	9a06      	ldr	r2, [sp, #24]
 8025e70:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025e72:	4611      	mov	r1, r2
 8025e74:	4419      	add	r1, r3
 8025e76:	9a08      	ldr	r2, [sp, #32]
 8025e78:	9106      	str	r1, [sp, #24]
 8025e7a:	990e      	ldr	r1, [sp, #56]	; 0x38
 8025e7c:	440a      	add	r2, r1
 8025e7e:	9208      	str	r2, [sp, #32]
 8025e80:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8025e82:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8025e84:	440a      	add	r2, r1
 8025e86:	9209      	str	r2, [sp, #36]	; 0x24
 8025e88:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8025e8a:	441a      	add	r2, r3
 8025e8c:	9b07      	ldr	r3, [sp, #28]
 8025e8e:	920a      	str	r2, [sp, #40]	; 0x28
 8025e90:	3b01      	subs	r3, #1
 8025e92:	9307      	str	r3, [sp, #28]
 8025e94:	e76d      	b.n	8025d72 <cblas_ztrsm+0x272>
 8025e96:	bf00      	nop
 8025e98:	08031108 	.word	0x08031108
 8025e9c:	080313b4 	.word	0x080313b4
 8025ea0:	080311b8 	.word	0x080311b8
 8025ea4:	3ff00000 	.word	0x3ff00000
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025ea8:	9b06      	ldr	r3, [sp, #24]
 8025eaa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8025eac:	2b01      	cmp	r3, #1
 8025eae:	bfb8      	it	lt
 8025eb0:	2301      	movlt	r3, #1
 8025eb2:	4293      	cmp	r3, r2
 8025eb4:	bfcc      	ite	gt
 8025eb6:	230c      	movgt	r3, #12
 8025eb8:	230a      	movle	r3, #10
 8025eba:	4ac5      	ldr	r2, [pc, #788]	; (80261d0 <cblas_ztrsm+0x6d0>)
 8025ebc:	49c5      	ldr	r1, [pc, #788]	; (80261d4 <cblas_ztrsm+0x6d4>)
 8025ebe:	4618      	mov	r0, r3
 8025ec0:	f002 fc22 	bl	8028708 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8025ec4:	ed97 7b00 	vldr	d7, [r7]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8025ec8:	2d6f      	cmp	r5, #111	; 0x6f
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8025eca:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
    const BASE alpha_real = CONST_REAL0(alpha);
 8025ece:	eeb0 8a47 	vmov.f32	s16, s14
 8025ed2:	eef0 8a67 	vmov.f32	s17, s15
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8025ed6:	9b06      	ldr	r3, [sp, #24]
 8025ed8:	f000 842b 	beq.w	8026732 <cblas_ztrsm+0xc32>
 8025edc:	9a02      	ldr	r2, [sp, #8]
 8025ede:	9206      	str	r2, [sp, #24]
 8025ee0:	2570      	movs	r5, #112	; 0x70
 8025ee2:	9302      	str	r3, [sp, #8]
 8025ee4:	e679      	b.n	8025bda <cblas_ztrsm+0xda>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025ee6:	2b00      	cmp	r3, #0
 8025ee8:	f43f ae63 	beq.w	8025bb2 <cblas_ztrsm+0xb2>
 8025eec:	e65c      	b.n	8025ba8 <cblas_ztrsm+0xa8>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8025eee:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025ef0:	4bb9      	ldr	r3, [pc, #740]	; (80261d8 <cblas_ztrsm+0x6d8>)
 8025ef2:	ec51 0b18 	vmov	r0, r1, d8
 8025ef6:	f04f 0200 	mov.w	r2, #0
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8025efa:	f000 863e 	beq.w	8026b7a <cblas_ztrsm+0x107a>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025efe:	f003 f89b 	bl	8029038 <__aeabi_dcmpeq>
 8025f02:	2800      	cmp	r0, #0
 8025f04:	f040 8465 	bne.w	80267d2 <cblas_ztrsm+0xcd2>
        for (i = 0; i < n1; i++) {
 8025f08:	9b06      	ldr	r3, [sp, #24]
 8025f0a:	2b00      	cmp	r3, #0
 8025f0c:	f340 8484 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8025f10:	9a02      	ldr	r2, [sp, #8]
 8025f12:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8025f14:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8025f18:	011b      	lsls	r3, r3, #4
 8025f1a:	9307      	str	r3, [sp, #28]
 8025f1c:	3308      	adds	r3, #8
 8025f1e:	9308      	str	r3, [sp, #32]
 8025f20:	0113      	lsls	r3, r2, #4
 8025f22:	9310      	str	r3, [sp, #64]	; 0x40
 8025f24:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025f26:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8025f2a:	0109      	lsls	r1, r1, #4
 8025f2c:	9300      	str	r3, [sp, #0]
 8025f2e:	2300      	movs	r3, #0
 8025f30:	9103      	str	r1, [sp, #12]
 8025f32:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8025f34:	9b02      	ldr	r3, [sp, #8]
 8025f36:	2b00      	cmp	r3, #0
 8025f38:	dd3d      	ble.n	8025fb6 <cblas_ztrsm+0x4b6>
 8025f3a:	9b00      	ldr	r3, [sp, #0]
 8025f3c:	9907      	ldr	r1, [sp, #28]
 8025f3e:	9a08      	ldr	r2, [sp, #32]
 8025f40:	eb03 0801 	add.w	r8, r3, r1
 8025f44:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025f48:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025f4c:	ec53 2b18 	vmov	r2, r3, d8
 8025f50:	4630      	mov	r0, r6
 8025f52:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025f54:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025f58:	f002 fe06 	bl	8028b68 <__aeabi_dmul>
 8025f5c:	4652      	mov	r2, sl
 8025f5e:	ec41 0b19 	vmov	d9, r0, r1
 8025f62:	465b      	mov	r3, fp
 8025f64:	4620      	mov	r0, r4
 8025f66:	4629      	mov	r1, r5
 8025f68:	f002 fdfe 	bl	8028b68 <__aeabi_dmul>
 8025f6c:	4602      	mov	r2, r0
 8025f6e:	460b      	mov	r3, r1
 8025f70:	ec51 0b19 	vmov	r0, r1, d9
 8025f74:	f002 fc40 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025f78:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025f7c:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025f80:	4620      	mov	r0, r4
 8025f82:	4629      	mov	r1, r5
 8025f84:	f002 fdf0 	bl	8028b68 <__aeabi_dmul>
 8025f88:	4652      	mov	r2, sl
 8025f8a:	465b      	mov	r3, fp
 8025f8c:	4604      	mov	r4, r0
 8025f8e:	460d      	mov	r5, r1
 8025f90:	4630      	mov	r0, r6
 8025f92:	4639      	mov	r1, r7
 8025f94:	f002 fde8 	bl	8028b68 <__aeabi_dmul>
 8025f98:	460b      	mov	r3, r1
 8025f9a:	4602      	mov	r2, r0
 8025f9c:	4629      	mov	r1, r5
 8025f9e:	4620      	mov	r0, r4
 8025fa0:	f002 fc2c 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 8025fa4:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025fa6:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8025faa:	f108 0810 	add.w	r8, r8, #16
 8025fae:	4598      	cmp	r8, r3
 8025fb0:	f109 0910 	add.w	r9, r9, #16
 8025fb4:	d1c8      	bne.n	8025f48 <cblas_ztrsm+0x448>
        for (i = 0; i < n1; i++) {
 8025fb6:	9a00      	ldr	r2, [sp, #0]
 8025fb8:	9903      	ldr	r1, [sp, #12]
 8025fba:	9b04      	ldr	r3, [sp, #16]
 8025fbc:	440a      	add	r2, r1
 8025fbe:	9200      	str	r2, [sp, #0]
 8025fc0:	9a06      	ldr	r2, [sp, #24]
 8025fc2:	3301      	adds	r3, #1
 8025fc4:	429a      	cmp	r2, r3
 8025fc6:	9304      	str	r3, [sp, #16]
 8025fc8:	d1b4      	bne.n	8025f34 <cblas_ztrsm+0x434>
 8025fca:	9a01      	ldr	r2, [sp, #4]
 8025fcc:	980c      	ldr	r0, [sp, #48]	; 0x30
 8025fce:	9007      	str	r0, [sp, #28]
 8025fd0:	43d1      	mvns	r1, r2
 8025fd2:	1c53      	adds	r3, r2, #1
 8025fd4:	0109      	lsls	r1, r1, #4
 8025fd6:	9a02      	ldr	r2, [sp, #8]
 8025fd8:	9109      	str	r1, [sp, #36]	; 0x24
 8025fda:	990a      	ldr	r1, [sp, #40]	; 0x28
 8025fdc:	9810      	ldr	r0, [sp, #64]	; 0x40
 8025fde:	011b      	lsls	r3, r3, #4
 8025fe0:	3a01      	subs	r2, #1
 8025fe2:	fb03 1202 	mla	r2, r3, r2, r1
 8025fe6:	3b10      	subs	r3, #16
 8025fe8:	3810      	subs	r0, #16
 8025fea:	9308      	str	r3, [sp, #32]
        for (j = n2; j > 0 && j--;) {
 8025fec:	2300      	movs	r3, #0
 8025fee:	900d      	str	r0, [sp, #52]	; 0x34
 8025ff0:	920c      	str	r2, [sp, #48]	; 0x30
 8025ff2:	930b      	str	r3, [sp, #44]	; 0x2c
 8025ff4:	9b02      	ldr	r3, [sp, #8]
 8025ff6:	2b00      	cmp	r3, #0
 8025ff8:	f340 8413 	ble.w	8026822 <cblas_ztrsm+0xd22>
 8025ffc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8025ffe:	9907      	ldr	r1, [sp, #28]
 8026000:	9301      	str	r3, [sp, #4]
          if (nonunit) {
 8026002:	9b05      	ldr	r3, [sp, #20]
 8026004:	440a      	add	r2, r1
 8026006:	9200      	str	r2, [sp, #0]
 8026008:	2b83      	cmp	r3, #131	; 0x83
        for (j = n2; j > 0 && j--;) {
 802600a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802600c:	9204      	str	r2, [sp, #16]
          if (nonunit) {
 802600e:	d074      	beq.n	80260fa <cblas_ztrsm+0x5fa>
 8026010:	9b00      	ldr	r3, [sp, #0]
 8026012:	ed93 7b02 	vldr	d7, [r3, #8]
 8026016:	eeb0 8a47 	vmov.f32	s16, s14
 802601a:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Bij_real = REAL(B, ldb * i + j);
 802601e:	9b00      	ldr	r3, [sp, #0]
            for (k = 0; k < j; k++) {
 8026020:	9c01      	ldr	r4, [sp, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026022:	ed93 7b00 	vldr	d7, [r3]
            for (k = 0; k < j; k++) {
 8026026:	2c01      	cmp	r4, #1
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026028:	eeb0 9a47 	vmov.f32	s18, s14
 802602c:	eef0 9a67 	vmov.f32	s19, s15
            for (k = 0; k < j; k++) {
 8026030:	f000 83f7 	beq.w	8026822 <cblas_ztrsm+0xd22>
 8026034:	ee1c 0a10 	vmov	r0, s24
 8026038:	f002 fd2c 	bl	8028a94 <__aeabi_i2d>
 802603c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802603e:	9e07      	ldr	r6, [sp, #28]
 8026040:	9f08      	ldr	r7, [sp, #32]
 8026042:	ec41 0b1b 	vmov	d11, r0, r1
 8026046:	eb03 1b04 	add.w	fp, r3, r4, lsl #4
 802604a:	f106 0a08 	add.w	sl, r6, #8
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802604e:	e95b 2302 	ldrd	r2, r3, [fp, #-8]
 8026052:	ec51 0b1b 	vmov	r0, r1, d11
 8026056:	f002 fd87 	bl	8028b68 <__aeabi_dmul>
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802605a:	e95b 8904 	ldrd	r8, r9, [fp, #-16]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802605e:	4604      	mov	r4, r0
 8026060:	460d      	mov	r5, r1
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8026062:	4642      	mov	r2, r8
 8026064:	464b      	mov	r3, r9
 8026066:	ec51 0b19 	vmov	r0, r1, d9
 802606a:	f002 fd7d 	bl	8028b68 <__aeabi_dmul>
 802606e:	ec53 2b18 	vmov	r2, r3, d8
 8026072:	ec41 0b1a 	vmov	d10, r0, r1
 8026076:	4620      	mov	r0, r4
 8026078:	4629      	mov	r1, r5
 802607a:	f002 fd75 	bl	8028b68 <__aeabi_dmul>
 802607e:	4602      	mov	r2, r0
 8026080:	460b      	mov	r3, r1
 8026082:	ec51 0b1a 	vmov	r0, r1, d10
 8026086:	f002 fbb7 	bl	80287f8 <__aeabi_dsub>
 802608a:	4602      	mov	r2, r0
 802608c:	460b      	mov	r3, r1
 802608e:	e95a 0102 	ldrd	r0, r1, [sl, #-8]
 8026092:	f002 fbb1 	bl	80287f8 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8026096:	ec53 2b18 	vmov	r2, r3, d8
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 802609a:	e94a 0102 	strd	r0, r1, [sl, #-8]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 802609e:	4640      	mov	r0, r8
 80260a0:	4649      	mov	r1, r9
 80260a2:	f002 fd61 	bl	8028b68 <__aeabi_dmul>
 80260a6:	4622      	mov	r2, r4
 80260a8:	462b      	mov	r3, r5
 80260aa:	4604      	mov	r4, r0
 80260ac:	460d      	mov	r5, r1
 80260ae:	ec51 0b19 	vmov	r0, r1, d9
 80260b2:	f002 fd59 	bl	8028b68 <__aeabi_dmul>
 80260b6:	4602      	mov	r2, r0
 80260b8:	460b      	mov	r3, r1
 80260ba:	4620      	mov	r0, r4
 80260bc:	4629      	mov	r1, r5
 80260be:	f002 fb9d 	bl	80287fc <__adddf3>
 80260c2:	460b      	mov	r3, r1
 80260c4:	4602      	mov	r2, r0
 80260c6:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 80260ca:	f002 fb95 	bl	80287f8 <__aeabi_dsub>
            for (k = 0; k < j; k++) {
 80260ce:	9b00      	ldr	r3, [sp, #0]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80260d0:	e9c6 0102 	strd	r0, r1, [r6, #8]
            for (k = 0; k < j; k++) {
 80260d4:	3610      	adds	r6, #16
 80260d6:	429e      	cmp	r6, r3
 80260d8:	44bb      	add	fp, r7
 80260da:	f10a 0a10 	add.w	sl, sl, #16
 80260de:	d1b6      	bne.n	802604e <cblas_ztrsm+0x54e>
 80260e0:	9b01      	ldr	r3, [sp, #4]
 80260e2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80260e4:	3b01      	subs	r3, #1
 80260e6:	9301      	str	r3, [sp, #4]
 80260e8:	9b00      	ldr	r3, [sp, #0]
 80260ea:	3b10      	subs	r3, #16
 80260ec:	9300      	str	r3, [sp, #0]
 80260ee:	9b04      	ldr	r3, [sp, #16]
 80260f0:	4413      	add	r3, r2
 80260f2:	9304      	str	r3, [sp, #16]
          if (nonunit) {
 80260f4:	9b05      	ldr	r3, [sp, #20]
 80260f6:	2b83      	cmp	r3, #131	; 0x83
 80260f8:	d18a      	bne.n	8026010 <cblas_ztrsm+0x510>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 80260fa:	ee1c 0a10 	vmov	r0, s24
 80260fe:	f002 fcc9 	bl	8028a94 <__aeabi_i2d>
 8026102:	9c04      	ldr	r4, [sp, #16]
 8026104:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8026108:	f002 fd2e 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 802610c:	e9d4 4500 	ldrd	r4, r5, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026110:	4606      	mov	r6, r0
 8026112:	460f      	mov	r7, r1
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8026114:	4632      	mov	r2, r6
 8026116:	463b      	mov	r3, r7
 8026118:	4620      	mov	r0, r4
 802611a:	4629      	mov	r1, r5
 802611c:	f7ff fcb8 	bl	8025a90 <xhypot>
 8026120:	4680      	mov	r8, r0
 8026122:	4689      	mov	r9, r1
            const BASE a_real = Ajj_real / s;
 8026124:	4620      	mov	r0, r4
 8026126:	4629      	mov	r1, r5
 8026128:	4642      	mov	r2, r8
 802612a:	464b      	mov	r3, r9
 802612c:	f002 fe46 	bl	8028dbc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 8026130:	4642      	mov	r2, r8
            const BASE a_real = Ajj_real / s;
 8026132:	4682      	mov	sl, r0
 8026134:	468b      	mov	fp, r1
            const BASE a_imag = Ajj_imag / s;
 8026136:	464b      	mov	r3, r9
 8026138:	4630      	mov	r0, r6
 802613a:	4639      	mov	r1, r7
 802613c:	f002 fe3e 	bl	8028dbc <__aeabi_ddiv>
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026140:	9e00      	ldr	r6, [sp, #0]
 8026142:	ed96 7b00 	vldr	d7, [r6]
            const BASE a_imag = Ajj_imag / s;
 8026146:	4604      	mov	r4, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026148:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 802614c:	eeb0 9a47 	vmov.f32	s18, s14
 8026150:	eef0 9a67 	vmov.f32	s19, s15
            const BASE a_imag = Ajj_imag / s;
 8026154:	460d      	mov	r5, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026156:	4650      	mov	r0, sl
 8026158:	4659      	mov	r1, fp
 802615a:	f002 fd05 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802615e:	e9d6 6702 	ldrd	r6, r7, [r6, #8]
            const BASE a_imag = Ajj_imag / s;
 8026162:	ec45 4b18 	vmov	d8, r4, r5
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026166:	4632      	mov	r2, r6
 8026168:	4604      	mov	r4, r0
 802616a:	460d      	mov	r5, r1
 802616c:	463b      	mov	r3, r7
 802616e:	ec51 0b18 	vmov	r0, r1, d8
 8026172:	f002 fcf9 	bl	8028b68 <__aeabi_dmul>
 8026176:	4602      	mov	r2, r0
 8026178:	460b      	mov	r3, r1
 802617a:	4620      	mov	r0, r4
 802617c:	4629      	mov	r1, r5
 802617e:	f002 fb3d 	bl	80287fc <__adddf3>
 8026182:	4642      	mov	r2, r8
 8026184:	464b      	mov	r3, r9
 8026186:	f002 fe19 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802618a:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802618c:	9e00      	ldr	r6, [sp, #0]
 802618e:	4604      	mov	r4, r0
 8026190:	460d      	mov	r5, r1
 8026192:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026196:	463b      	mov	r3, r7
 8026198:	4650      	mov	r0, sl
 802619a:	4659      	mov	r1, fp
 802619c:	f002 fce4 	bl	8028b68 <__aeabi_dmul>
 80261a0:	ec53 2b19 	vmov	r2, r3, d9
 80261a4:	4604      	mov	r4, r0
 80261a6:	460d      	mov	r5, r1
 80261a8:	ec51 0b18 	vmov	r0, r1, d8
 80261ac:	f002 fcdc 	bl	8028b68 <__aeabi_dmul>
 80261b0:	4602      	mov	r2, r0
 80261b2:	460b      	mov	r3, r1
 80261b4:	4620      	mov	r0, r4
 80261b6:	4629      	mov	r1, r5
 80261b8:	f002 fb1e 	bl	80287f8 <__aeabi_dsub>
 80261bc:	4642      	mov	r2, r8
 80261be:	464b      	mov	r3, r9
 80261c0:	f002 fdfc 	bl	8028dbc <__aeabi_ddiv>
 80261c4:	e9c6 0102 	strd	r0, r1, [r6, #8]
 80261c8:	ec41 0b18 	vmov	d8, r0, r1
 80261cc:	e727      	b.n	802601e <cblas_ztrsm+0x51e>
 80261ce:	bf00      	nop
 80261d0:	08031108 	.word	0x08031108
 80261d4:	080313b4 	.word	0x080313b4
 80261d8:	3ff00000 	.word	0x3ff00000
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 80261dc:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80261de:	4bbe      	ldr	r3, [pc, #760]	; (80264d8 <cblas_ztrsm+0x9d8>)
 80261e0:	ec51 0b18 	vmov	r0, r1, d8
 80261e4:	f04f 0200 	mov.w	r2, #0
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 80261e8:	f000 85e9 	beq.w	8026dbe <cblas_ztrsm+0x12be>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80261ec:	f002 ff24 	bl	8029038 <__aeabi_dcmpeq>
 80261f0:	2800      	cmp	r0, #0
 80261f2:	f040 82b2 	bne.w	802675a <cblas_ztrsm+0xc5a>
        for (i = 0; i < n1; i++) {
 80261f6:	9b06      	ldr	r3, [sp, #24]
 80261f8:	2b00      	cmp	r3, #0
 80261fa:	f340 830d 	ble.w	8026818 <cblas_ztrsm+0xd18>
 80261fe:	9a02      	ldr	r2, [sp, #8]
 8026200:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8026204:	011b      	lsls	r3, r3, #4
 8026206:	9307      	str	r3, [sp, #28]
 8026208:	3308      	adds	r3, #8
 802620a:	9308      	str	r3, [sp, #32]
 802620c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802620e:	011b      	lsls	r3, r3, #4
 8026210:	9303      	str	r3, [sp, #12]
 8026212:	0113      	lsls	r3, r2, #4
 8026214:	9310      	str	r3, [sp, #64]	; 0x40
 8026216:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026218:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802621c:	9300      	str	r3, [sp, #0]
 802621e:	2300      	movs	r3, #0
 8026220:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8026222:	9b02      	ldr	r3, [sp, #8]
 8026224:	2b00      	cmp	r3, #0
 8026226:	dd3d      	ble.n	80262a4 <cblas_ztrsm+0x7a4>
 8026228:	9b00      	ldr	r3, [sp, #0]
 802622a:	9907      	ldr	r1, [sp, #28]
 802622c:	9a08      	ldr	r2, [sp, #32]
 802622e:	eb03 0801 	add.w	r8, r3, r1
 8026232:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026236:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802623a:	ec53 2b18 	vmov	r2, r3, d8
 802623e:	4630      	mov	r0, r6
 8026240:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026242:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8026246:	f002 fc8f 	bl	8028b68 <__aeabi_dmul>
 802624a:	4652      	mov	r2, sl
 802624c:	ec41 0b19 	vmov	d9, r0, r1
 8026250:	465b      	mov	r3, fp
 8026252:	4620      	mov	r0, r4
 8026254:	4629      	mov	r1, r5
 8026256:	f002 fc87 	bl	8028b68 <__aeabi_dmul>
 802625a:	4602      	mov	r2, r0
 802625c:	460b      	mov	r3, r1
 802625e:	ec51 0b19 	vmov	r0, r1, d9
 8026262:	f002 fac9 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026266:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802626a:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802626e:	4620      	mov	r0, r4
 8026270:	4629      	mov	r1, r5
 8026272:	f002 fc79 	bl	8028b68 <__aeabi_dmul>
 8026276:	4652      	mov	r2, sl
 8026278:	465b      	mov	r3, fp
 802627a:	4604      	mov	r4, r0
 802627c:	460d      	mov	r5, r1
 802627e:	4630      	mov	r0, r6
 8026280:	4639      	mov	r1, r7
 8026282:	f002 fc71 	bl	8028b68 <__aeabi_dmul>
 8026286:	460b      	mov	r3, r1
 8026288:	4602      	mov	r2, r0
 802628a:	4629      	mov	r1, r5
 802628c:	4620      	mov	r0, r4
 802628e:	f002 fab5 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 8026292:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026294:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8026298:	f108 0810 	add.w	r8, r8, #16
 802629c:	4598      	cmp	r8, r3
 802629e:	f109 0910 	add.w	r9, r9, #16
 80262a2:	d1c8      	bne.n	8026236 <cblas_ztrsm+0x736>
        for (i = 0; i < n1; i++) {
 80262a4:	9a00      	ldr	r2, [sp, #0]
 80262a6:	9903      	ldr	r1, [sp, #12]
 80262a8:	9b04      	ldr	r3, [sp, #16]
 80262aa:	440a      	add	r2, r1
 80262ac:	9200      	str	r2, [sp, #0]
 80262ae:	9a06      	ldr	r2, [sp, #24]
 80262b0:	3301      	adds	r3, #1
 80262b2:	429a      	cmp	r2, r3
 80262b4:	9304      	str	r3, [sp, #16]
 80262b6:	d1b4      	bne.n	8026222 <cblas_ztrsm+0x722>
 80262b8:	9b01      	ldr	r3, [sp, #4]
 80262ba:	1c59      	adds	r1, r3, #1
 80262bc:	0109      	lsls	r1, r1, #4
 80262be:	0118      	lsls	r0, r3, #4
 80262c0:	910d      	str	r1, [sp, #52]	; 0x34
 80262c2:	990a      	ldr	r1, [sp, #40]	; 0x28
 80262c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80262c6:	9001      	str	r0, [sp, #4]
 80262c8:	f100 0208 	add.w	r2, r0, #8
 80262cc:	188a      	adds	r2, r1, r2
 80262ce:	9211      	str	r2, [sp, #68]	; 0x44
 80262d0:	f100 0210 	add.w	r2, r0, #16
 80262d4:	920e      	str	r2, [sp, #56]	; 0x38
 80262d6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80262d8:	3b10      	subs	r3, #16
            for (k = j + 1; k < n2; k++) {
 80262da:	2400      	movs	r4, #0
 80262dc:	441a      	add	r2, r3
 80262de:	940f      	str	r4, [sp, #60]	; 0x3c
 80262e0:	9200      	str	r2, [sp, #0]
 80262e2:	9410      	str	r4, [sp, #64]	; 0x40
        for (j = 0; j < n2; j++) {
 80262e4:	9b02      	ldr	r3, [sp, #8]
 80262e6:	2b00      	cmp	r3, #0
 80262e8:	f340 8287 	ble.w	80267fa <cblas_ztrsm+0xcfa>
 80262ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80262ee:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80262f0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80262f4:	9304      	str	r3, [sp, #16]
 80262f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80262f8:	3308      	adds	r3, #8
 80262fa:	9309      	str	r3, [sp, #36]	; 0x24
 80262fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80262fe:	9307      	str	r3, [sp, #28]
 8026300:	2300      	movs	r3, #0
 8026302:	9308      	str	r3, [sp, #32]
          if (nonunit) {
 8026304:	9b05      	ldr	r3, [sp, #20]
 8026306:	2b83      	cmp	r3, #131	; 0x83
 8026308:	d070      	beq.n	80263ec <cblas_ztrsm+0x8ec>
 802630a:	9b04      	ldr	r3, [sp, #16]
 802630c:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026310:	9c04      	ldr	r4, [sp, #16]
            for (k = j + 1; k < n2; k++) {
 8026312:	9b08      	ldr	r3, [sp, #32]
 8026314:	9a02      	ldr	r2, [sp, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026316:	ed94 7b00 	vldr	d7, [r4]
            for (k = j + 1; k < n2; k++) {
 802631a:	3301      	adds	r3, #1
 802631c:	429a      	cmp	r2, r3
 802631e:	9308      	str	r3, [sp, #32]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026320:	eeb0 8a47 	vmov.f32	s16, s14
 8026324:	eef0 8a67 	vmov.f32	s17, s15
            for (k = j + 1; k < n2; k++) {
 8026328:	f000 8267 	beq.w	80267fa <cblas_ztrsm+0xcfa>
 802632c:	ee1c 0a10 	vmov	r0, s24
 8026330:	f002 fbb0 	bl	8028a94 <__aeabi_i2d>
 8026334:	f8dd b01c 	ldr.w	fp, [sp, #28]
 8026338:	ec41 0b1a 	vmov	d10, r0, r1
 802633c:	46a2      	mov	sl, r4
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802633e:	e9db 2300 	ldrd	r2, r3, [fp]
 8026342:	ec51 0b1a 	vmov	r0, r1, d10
 8026346:	f002 fc0f 	bl	8028b68 <__aeabi_dmul>
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802634a:	e95b 4502 	ldrd	r4, r5, [fp, #-8]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802634e:	4680      	mov	r8, r0
 8026350:	4689      	mov	r9, r1
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8026352:	4622      	mov	r2, r4
 8026354:	462b      	mov	r3, r5
 8026356:	ec51 0b18 	vmov	r0, r1, d8
 802635a:	f002 fc05 	bl	8028b68 <__aeabi_dmul>
 802635e:	4632      	mov	r2, r6
 8026360:	ec41 0b19 	vmov	d9, r0, r1
 8026364:	463b      	mov	r3, r7
 8026366:	4640      	mov	r0, r8
 8026368:	4649      	mov	r1, r9
 802636a:	f002 fbfd 	bl	8028b68 <__aeabi_dmul>
 802636e:	4602      	mov	r2, r0
 8026370:	460b      	mov	r3, r1
 8026372:	ec51 0b19 	vmov	r0, r1, d9
 8026376:	f002 fa3f 	bl	80287f8 <__aeabi_dsub>
 802637a:	4602      	mov	r2, r0
 802637c:	460b      	mov	r3, r1
 802637e:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 8026382:	f002 fa39 	bl	80287f8 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8026386:	4632      	mov	r2, r6
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8026388:	e9ca 0104 	strd	r0, r1, [sl, #16]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 802638c:	463b      	mov	r3, r7
 802638e:	4620      	mov	r0, r4
 8026390:	4629      	mov	r1, r5
 8026392:	f002 fbe9 	bl	8028b68 <__aeabi_dmul>
 8026396:	4642      	mov	r2, r8
 8026398:	464b      	mov	r3, r9
 802639a:	4680      	mov	r8, r0
 802639c:	4689      	mov	r9, r1
 802639e:	ec51 0b18 	vmov	r0, r1, d8
 80263a2:	f002 fbe1 	bl	8028b68 <__aeabi_dmul>
 80263a6:	4602      	mov	r2, r0
 80263a8:	460b      	mov	r3, r1
 80263aa:	4640      	mov	r0, r8
 80263ac:	4649      	mov	r1, r9
 80263ae:	f002 fa25 	bl	80287fc <__adddf3>
 80263b2:	460b      	mov	r3, r1
 80263b4:	4602      	mov	r2, r0
 80263b6:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 80263ba:	f002 fa1d 	bl	80287f8 <__aeabi_dsub>
 80263be:	9b01      	ldr	r3, [sp, #4]
 80263c0:	449b      	add	fp, r3
            for (k = j + 1; k < n2; k++) {
 80263c2:	9b00      	ldr	r3, [sp, #0]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80263c4:	e9ca 0106 	strd	r0, r1, [sl, #24]
            for (k = j + 1; k < n2; k++) {
 80263c8:	f10a 0a10 	add.w	sl, sl, #16
 80263cc:	459a      	cmp	sl, r3
 80263ce:	d1b6      	bne.n	802633e <cblas_ztrsm+0x83e>
 80263d0:	9b04      	ldr	r3, [sp, #16]
 80263d2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80263d4:	3310      	adds	r3, #16
 80263d6:	9304      	str	r3, [sp, #16]
 80263d8:	9b07      	ldr	r3, [sp, #28]
 80263da:	4413      	add	r3, r2
 80263dc:	9307      	str	r3, [sp, #28]
 80263de:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80263e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80263e2:	4413      	add	r3, r2
 80263e4:	9309      	str	r3, [sp, #36]	; 0x24
          if (nonunit) {
 80263e6:	9b05      	ldr	r3, [sp, #20]
 80263e8:	2b83      	cmp	r3, #131	; 0x83
 80263ea:	d18e      	bne.n	802630a <cblas_ztrsm+0x80a>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 80263ec:	ee1c 0a10 	vmov	r0, s24
 80263f0:	f002 fb50 	bl	8028a94 <__aeabi_i2d>
 80263f4:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80263f6:	e9d4 2300 	ldrd	r2, r3, [r4]
 80263fa:	f002 fbb5 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 80263fe:	e954 4502 	ldrd	r4, r5, [r4, #-8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026402:	4606      	mov	r6, r0
 8026404:	460f      	mov	r7, r1
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8026406:	4632      	mov	r2, r6
 8026408:	463b      	mov	r3, r7
 802640a:	4620      	mov	r0, r4
 802640c:	4629      	mov	r1, r5
 802640e:	f7ff fb3f 	bl	8025a90 <xhypot>
 8026412:	4680      	mov	r8, r0
 8026414:	4689      	mov	r9, r1
            const BASE a_real = Ajj_real / s;
 8026416:	4620      	mov	r0, r4
 8026418:	4629      	mov	r1, r5
 802641a:	4642      	mov	r2, r8
 802641c:	464b      	mov	r3, r9
 802641e:	f002 fccd 	bl	8028dbc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 8026422:	4642      	mov	r2, r8
            const BASE a_real = Ajj_real / s;
 8026424:	4682      	mov	sl, r0
 8026426:	468b      	mov	fp, r1
            const BASE a_imag = Ajj_imag / s;
 8026428:	464b      	mov	r3, r9
 802642a:	4630      	mov	r0, r6
 802642c:	4639      	mov	r1, r7
 802642e:	f002 fcc5 	bl	8028dbc <__aeabi_ddiv>
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026432:	9e04      	ldr	r6, [sp, #16]
 8026434:	ed96 7b00 	vldr	d7, [r6]
            const BASE a_imag = Ajj_imag / s;
 8026438:	4604      	mov	r4, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802643a:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 802643e:	eeb0 9a47 	vmov.f32	s18, s14
 8026442:	eef0 9a67 	vmov.f32	s19, s15
            const BASE a_imag = Ajj_imag / s;
 8026446:	460d      	mov	r5, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026448:	4650      	mov	r0, sl
 802644a:	4659      	mov	r1, fp
 802644c:	f002 fb8c 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026450:	e9d6 6702 	ldrd	r6, r7, [r6, #8]
            const BASE a_imag = Ajj_imag / s;
 8026454:	ec45 4b18 	vmov	d8, r4, r5
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026458:	4632      	mov	r2, r6
 802645a:	463b      	mov	r3, r7
 802645c:	4604      	mov	r4, r0
 802645e:	460d      	mov	r5, r1
 8026460:	ec51 0b18 	vmov	r0, r1, d8
 8026464:	f002 fb80 	bl	8028b68 <__aeabi_dmul>
 8026468:	4602      	mov	r2, r0
 802646a:	460b      	mov	r3, r1
 802646c:	4620      	mov	r0, r4
 802646e:	4629      	mov	r1, r5
 8026470:	f002 f9c4 	bl	80287fc <__adddf3>
 8026474:	4642      	mov	r2, r8
 8026476:	464b      	mov	r3, r9
 8026478:	f002 fca0 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802647c:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802647e:	9e04      	ldr	r6, [sp, #16]
 8026480:	4604      	mov	r4, r0
 8026482:	460d      	mov	r5, r1
 8026484:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026488:	463b      	mov	r3, r7
 802648a:	4650      	mov	r0, sl
 802648c:	4659      	mov	r1, fp
 802648e:	f002 fb6b 	bl	8028b68 <__aeabi_dmul>
 8026492:	ec53 2b19 	vmov	r2, r3, d9
 8026496:	4604      	mov	r4, r0
 8026498:	460d      	mov	r5, r1
 802649a:	ec51 0b18 	vmov	r0, r1, d8
 802649e:	f002 fb63 	bl	8028b68 <__aeabi_dmul>
 80264a2:	4602      	mov	r2, r0
 80264a4:	460b      	mov	r3, r1
 80264a6:	4620      	mov	r0, r4
 80264a8:	4629      	mov	r1, r5
 80264aa:	f002 f9a5 	bl	80287f8 <__aeabi_dsub>
 80264ae:	464b      	mov	r3, r9
 80264b0:	4642      	mov	r2, r8
 80264b2:	f002 fc83 	bl	8028dbc <__aeabi_ddiv>
 80264b6:	9b04      	ldr	r3, [sp, #16]
 80264b8:	4606      	mov	r6, r0
 80264ba:	460f      	mov	r7, r1
 80264bc:	e9c3 6702 	strd	r6, r7, [r3, #8]
 80264c0:	e726      	b.n	8026310 <cblas_ztrsm+0x810>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80264c2:	9a06      	ldr	r2, [sp, #24]
 80264c4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80264c6:	2a01      	cmp	r2, #1
 80264c8:	bfb8      	it	lt
 80264ca:	2201      	movlt	r2, #1
 80264cc:	428a      	cmp	r2, r1
 80264ce:	f340 8135 	ble.w	802673c <cblas_ztrsm+0xc3c>
 80264d2:	230c      	movs	r3, #12
 80264d4:	e4f1      	b.n	8025eba <cblas_ztrsm+0x3ba>
 80264d6:	bf00      	nop
 80264d8:	3ff00000 	.word	0x3ff00000
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80264dc:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80264de:	4bb2      	ldr	r3, [pc, #712]	; (80267a8 <cblas_ztrsm+0xca8>)
 80264e0:	ec51 0b18 	vmov	r0, r1, d8
 80264e4:	f04f 0200 	mov.w	r2, #0
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80264e8:	f000 81a7 	beq.w	802683a <cblas_ztrsm+0xd3a>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80264ec:	f002 fda4 	bl	8029038 <__aeabi_dcmpeq>
 80264f0:	2800      	cmp	r0, #0
 80264f2:	f040 815b 	bne.w	80267ac <cblas_ztrsm+0xcac>
        for (i = 0; i < n1; i++) {
 80264f6:	9b06      	ldr	r3, [sp, #24]
 80264f8:	2b00      	cmp	r3, #0
 80264fa:	f340 818d 	ble.w	8026818 <cblas_ztrsm+0xd18>
 80264fe:	9a02      	ldr	r2, [sp, #8]
 8026500:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8026504:	011b      	lsls	r3, r3, #4
 8026506:	9307      	str	r3, [sp, #28]
 8026508:	3308      	adds	r3, #8
 802650a:	9308      	str	r3, [sp, #32]
 802650c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802650e:	011b      	lsls	r3, r3, #4
 8026510:	9303      	str	r3, [sp, #12]
 8026512:	0113      	lsls	r3, r2, #4
 8026514:	9310      	str	r3, [sp, #64]	; 0x40
 8026516:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026518:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802651c:	9300      	str	r3, [sp, #0]
 802651e:	2300      	movs	r3, #0
 8026520:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8026522:	9b02      	ldr	r3, [sp, #8]
 8026524:	2b00      	cmp	r3, #0
 8026526:	dd3e      	ble.n	80265a6 <cblas_ztrsm+0xaa6>
 8026528:	9b07      	ldr	r3, [sp, #28]
 802652a:	9a08      	ldr	r2, [sp, #32]
 802652c:	4619      	mov	r1, r3
 802652e:	9b00      	ldr	r3, [sp, #0]
 8026530:	eb01 0803 	add.w	r8, r1, r3
 8026534:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026538:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802653c:	ec53 2b18 	vmov	r2, r3, d8
 8026540:	4630      	mov	r0, r6
 8026542:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026544:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8026548:	f002 fb0e 	bl	8028b68 <__aeabi_dmul>
 802654c:	4652      	mov	r2, sl
 802654e:	ec41 0b19 	vmov	d9, r0, r1
 8026552:	465b      	mov	r3, fp
 8026554:	4620      	mov	r0, r4
 8026556:	4629      	mov	r1, r5
 8026558:	f002 fb06 	bl	8028b68 <__aeabi_dmul>
 802655c:	4602      	mov	r2, r0
 802655e:	460b      	mov	r3, r1
 8026560:	ec51 0b19 	vmov	r0, r1, d9
 8026564:	f002 f948 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026568:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802656c:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026570:	4620      	mov	r0, r4
 8026572:	4629      	mov	r1, r5
 8026574:	f002 faf8 	bl	8028b68 <__aeabi_dmul>
 8026578:	4652      	mov	r2, sl
 802657a:	465b      	mov	r3, fp
 802657c:	4604      	mov	r4, r0
 802657e:	460d      	mov	r5, r1
 8026580:	4630      	mov	r0, r6
 8026582:	4639      	mov	r1, r7
 8026584:	f002 faf0 	bl	8028b68 <__aeabi_dmul>
 8026588:	460b      	mov	r3, r1
 802658a:	4602      	mov	r2, r0
 802658c:	4629      	mov	r1, r5
 802658e:	4620      	mov	r0, r4
 8026590:	f002 f934 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 8026594:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026596:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 802659a:	f108 0810 	add.w	r8, r8, #16
 802659e:	4543      	cmp	r3, r8
 80265a0:	f109 0910 	add.w	r9, r9, #16
 80265a4:	d1c8      	bne.n	8026538 <cblas_ztrsm+0xa38>
        for (i = 0; i < n1; i++) {
 80265a6:	9a00      	ldr	r2, [sp, #0]
 80265a8:	9903      	ldr	r1, [sp, #12]
 80265aa:	9b04      	ldr	r3, [sp, #16]
 80265ac:	440a      	add	r2, r1
 80265ae:	9200      	str	r2, [sp, #0]
 80265b0:	9a06      	ldr	r2, [sp, #24]
 80265b2:	3301      	adds	r3, #1
 80265b4:	429a      	cmp	r2, r3
 80265b6:	9304      	str	r3, [sp, #16]
 80265b8:	d1b3      	bne.n	8026522 <cblas_ztrsm+0xa22>
 80265ba:	9810      	ldr	r0, [sp, #64]	; 0x40
 80265bc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80265be:	9b01      	ldr	r3, [sp, #4]
 80265c0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80265c2:	4606      	mov	r6, r0
 80265c4:	9806      	ldr	r0, [sp, #24]
 80265c6:	011c      	lsls	r4, r3, #4
 80265c8:	f1a2 0310 	sub.w	r3, r2, #16
 80265cc:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 80265d0:	9307      	str	r3, [sp, #28]
 80265d2:	f104 0310 	add.w	r3, r4, #16
 80265d6:	2500      	movs	r5, #0
 80265d8:	9311      	str	r3, [sp, #68]	; 0x44
 80265da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80265dc:	9412      	str	r4, [sp, #72]	; 0x48
 80265de:	e9cd 520d 	strd	r5, r2, [sp, #52]	; 0x34
 80265e2:	e9cd 1308 	strd	r1, r3, [sp, #32]
 80265e6:	440e      	add	r6, r1
 80265e8:	f101 0308 	add.w	r3, r1, #8
 80265ec:	950f      	str	r5, [sp, #60]	; 0x3c
 80265ee:	9610      	str	r6, [sp, #64]	; 0x40
 80265f0:	9313      	str	r3, [sp, #76]	; 0x4c
        if (nonunit) {
 80265f2:	9b05      	ldr	r3, [sp, #20]
 80265f4:	2b83      	cmp	r3, #131	; 0x83
 80265f6:	f000 864f 	beq.w	8027298 <cblas_ztrsm+0x1798>
        for (k = i + 1; k < n1; k++) {
 80265fa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80265fc:	9a06      	ldr	r2, [sp, #24]
 80265fe:	3301      	adds	r3, #1
 8026600:	429a      	cmp	r2, r3
 8026602:	930d      	str	r3, [sp, #52]	; 0x34
 8026604:	f340 8108 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8026608:	ee1c 0a10 	vmov	r0, s24
 802660c:	f002 fa42 	bl	8028a94 <__aeabi_i2d>
 8026610:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026612:	ec41 0b1b 	vmov	d11, r0, r1
 8026616:	4619      	mov	r1, r3
 8026618:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802661a:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 802661e:	9204      	str	r2, [sp, #16]
 8026620:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026622:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8026626:	9301      	str	r3, [sp, #4]
 8026628:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802662a:	9300      	str	r3, [sp, #0]
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 802662c:	9c00      	ldr	r4, [sp, #0]
 802662e:	ec51 0b1b 	vmov	r0, r1, d11
 8026632:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 8026636:	f002 fa97 	bl	8028b68 <__aeabi_dmul>
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802663a:	ed94 7b04 	vldr	d7, [r4, #16]
          for (j = 0; j < n2; j++) {
 802663e:	9b02      	ldr	r3, [sp, #8]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8026640:	eeb0 9a47 	vmov.f32	s18, s14
 8026644:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 8026648:	2b00      	cmp	r3, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 802664a:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 802664e:	dd49      	ble.n	80266e4 <cblas_ztrsm+0xbe4>
 8026650:	9b04      	ldr	r3, [sp, #16]
 8026652:	9c08      	ldr	r4, [sp, #32]
 8026654:	9d01      	ldr	r5, [sp, #4]
 8026656:	f103 0b08 	add.w	fp, r3, #8
 802665a:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 802665c:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8026660:	ec51 0b19 	vmov	r0, r1, d9
 8026664:	4632      	mov	r2, r6
 8026666:	463b      	mov	r3, r7
 8026668:	f002 fa7e 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802666c:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8026670:	ec41 0b1a 	vmov	d10, r0, r1
 8026674:	4642      	mov	r2, r8
 8026676:	464b      	mov	r3, r9
 8026678:	ec51 0b18 	vmov	r0, r1, d8
 802667c:	f002 fa74 	bl	8028b68 <__aeabi_dmul>
 8026680:	4602      	mov	r2, r0
 8026682:	460b      	mov	r3, r1
 8026684:	ec51 0b1a 	vmov	r0, r1, d10
 8026688:	f002 f8b6 	bl	80287f8 <__aeabi_dsub>
 802668c:	4602      	mov	r2, r0
 802668e:	460b      	mov	r3, r1
 8026690:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8026694:	f002 f8b0 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8026698:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 802669a:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 802669e:	464b      	mov	r3, r9
 80266a0:	ec51 0b19 	vmov	r0, r1, d9
 80266a4:	f002 fa60 	bl	8028b68 <__aeabi_dmul>
 80266a8:	4632      	mov	r2, r6
 80266aa:	463b      	mov	r3, r7
 80266ac:	4606      	mov	r6, r0
 80266ae:	460f      	mov	r7, r1
 80266b0:	ec51 0b18 	vmov	r0, r1, d8
 80266b4:	f002 fa58 	bl	8028b68 <__aeabi_dmul>
 80266b8:	4602      	mov	r2, r0
 80266ba:	460b      	mov	r3, r1
 80266bc:	4630      	mov	r0, r6
 80266be:	4639      	mov	r1, r7
 80266c0:	f002 f89c 	bl	80287fc <__adddf3>
 80266c4:	4602      	mov	r2, r0
 80266c6:	460b      	mov	r3, r1
 80266c8:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 80266cc:	f002 f894 	bl	80287f8 <__aeabi_dsub>
 80266d0:	f10a 0a10 	add.w	sl, sl, #16
 80266d4:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 80266d8:	4555      	cmp	r5, sl
 80266da:	f104 0410 	add.w	r4, r4, #16
 80266de:	f10b 0b10 	add.w	fp, fp, #16
 80266e2:	d1bb      	bne.n	802665c <cblas_ztrsm+0xb5c>
        for (k = i + 1; k < n1; k++) {
 80266e4:	9904      	ldr	r1, [sp, #16]
 80266e6:	9a03      	ldr	r2, [sp, #12]
 80266e8:	9b00      	ldr	r3, [sp, #0]
 80266ea:	4608      	mov	r0, r1
 80266ec:	9901      	ldr	r1, [sp, #4]
 80266ee:	4410      	add	r0, r2
 80266f0:	4411      	add	r1, r2
 80266f2:	9a07      	ldr	r2, [sp, #28]
 80266f4:	9004      	str	r0, [sp, #16]
 80266f6:	3310      	adds	r3, #16
 80266f8:	429a      	cmp	r2, r3
 80266fa:	9300      	str	r3, [sp, #0]
 80266fc:	9101      	str	r1, [sp, #4]
 80266fe:	d195      	bne.n	802662c <cblas_ztrsm+0xb2c>
 8026700:	4613      	mov	r3, r2
 8026702:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8026704:	4413      	add	r3, r2
 8026706:	9307      	str	r3, [sp, #28]
 8026708:	9a03      	ldr	r2, [sp, #12]
 802670a:	9b08      	ldr	r3, [sp, #32]
 802670c:	4413      	add	r3, r2
 802670e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8026710:	9308      	str	r3, [sp, #32]
 8026712:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026714:	4611      	mov	r1, r2
 8026716:	4419      	add	r1, r3
 8026718:	910f      	str	r1, [sp, #60]	; 0x3c
 802671a:	990a      	ldr	r1, [sp, #40]	; 0x28
 802671c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 802671e:	4608      	mov	r0, r1
 8026720:	9909      	ldr	r1, [sp, #36]	; 0x24
 8026722:	4419      	add	r1, r3
 8026724:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026726:	9109      	str	r1, [sp, #36]	; 0x24
 8026728:	4410      	add	r0, r2
 802672a:	4413      	add	r3, r2
 802672c:	900a      	str	r0, [sp, #40]	; 0x28
 802672e:	930e      	str	r3, [sp, #56]	; 0x38
 8026730:	e75f      	b.n	80265f2 <cblas_ztrsm+0xaf2>
 8026732:	9a02      	ldr	r2, [sp, #8]
 8026734:	9206      	str	r2, [sp, #24]
 8026736:	9302      	str	r3, [sp, #8]
 8026738:	f7ff ba4f 	b.w	8025bda <cblas_ztrsm+0xda>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 802673c:	2b00      	cmp	r3, #0
 802673e:	f43f abc1 	beq.w	8025ec4 <cblas_ztrsm+0x3c4>
 8026742:	f7ff bbba 	b.w	8025eba <cblas_ztrsm+0x3ba>
 8026746:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 802674a:	2b01      	cmp	r3, #1
 802674c:	f8dd c018 	ldr.w	ip, [sp, #24]
 8026750:	bf94      	ite	ls
 8026752:	2300      	movls	r3, #0
 8026754:	2301      	movhi	r3, #1
 8026756:	f7ff b9fa 	b.w	8025b4e <cblas_ztrsm+0x4e>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802675a:	2200      	movs	r2, #0
 802675c:	2300      	movs	r3, #0
 802675e:	4650      	mov	r0, sl
 8026760:	4659      	mov	r1, fp
 8026762:	f002 fc69 	bl	8029038 <__aeabi_dcmpeq>
 8026766:	2800      	cmp	r0, #0
 8026768:	f43f ad45 	beq.w	80261f6 <cblas_ztrsm+0x6f6>
      for (i = 0; i < n1; i++) {
 802676c:	9b06      	ldr	r3, [sp, #24]
 802676e:	2b00      	cmp	r3, #0
 8026770:	dd52      	ble.n	8026818 <cblas_ztrsm+0xd18>
 8026772:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026774:	011b      	lsls	r3, r3, #4
 8026776:	9303      	str	r3, [sp, #12]
 8026778:	9b02      	ldr	r3, [sp, #8]
 802677a:	011b      	lsls	r3, r3, #4
 802677c:	9310      	str	r3, [sp, #64]	; 0x40
 802677e:	e59b      	b.n	80262b8 <cblas_ztrsm+0x7b8>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8026780:	2200      	movs	r2, #0
 8026782:	2300      	movs	r3, #0
 8026784:	4650      	mov	r0, sl
 8026786:	4659      	mov	r1, fp
 8026788:	f002 fc56 	bl	8029038 <__aeabi_dcmpeq>
 802678c:	2800      	cmp	r0, #0
 802678e:	f43f aa60 	beq.w	8025c52 <cblas_ztrsm+0x152>
      for (i = n1; i > 0 && i--;) {
 8026792:	9b06      	ldr	r3, [sp, #24]
 8026794:	2b00      	cmp	r3, #0
 8026796:	dd3f      	ble.n	8026818 <cblas_ztrsm+0xd18>
 8026798:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802679a:	011b      	lsls	r3, r3, #4
 802679c:	9303      	str	r3, [sp, #12]
 802679e:	9b02      	ldr	r3, [sp, #8]
 80267a0:	011b      	lsls	r3, r3, #4
 80267a2:	9310      	str	r3, [sp, #64]	; 0x40
 80267a4:	f7ff bab7 	b.w	8025d16 <cblas_ztrsm+0x216>
 80267a8:	3ff00000 	.word	0x3ff00000
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80267ac:	2200      	movs	r2, #0
 80267ae:	2300      	movs	r3, #0
 80267b0:	4650      	mov	r0, sl
 80267b2:	4659      	mov	r1, fp
 80267b4:	f002 fc40 	bl	8029038 <__aeabi_dcmpeq>
 80267b8:	2800      	cmp	r0, #0
 80267ba:	f43f ae9c 	beq.w	80264f6 <cblas_ztrsm+0x9f6>
      for (i = 0; i < n1; i++) {
 80267be:	9b06      	ldr	r3, [sp, #24]
 80267c0:	2b00      	cmp	r3, #0
 80267c2:	dd29      	ble.n	8026818 <cblas_ztrsm+0xd18>
 80267c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80267c6:	011b      	lsls	r3, r3, #4
 80267c8:	9303      	str	r3, [sp, #12]
 80267ca:	9b02      	ldr	r3, [sp, #8]
 80267cc:	011b      	lsls	r3, r3, #4
 80267ce:	9310      	str	r3, [sp, #64]	; 0x40
 80267d0:	e6f3      	b.n	80265ba <cblas_ztrsm+0xaba>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80267d2:	2200      	movs	r2, #0
 80267d4:	2300      	movs	r3, #0
 80267d6:	4650      	mov	r0, sl
 80267d8:	4659      	mov	r1, fp
 80267da:	f002 fc2d 	bl	8029038 <__aeabi_dcmpeq>
 80267de:	2800      	cmp	r0, #0
 80267e0:	f43f ab92 	beq.w	8025f08 <cblas_ztrsm+0x408>
      for (i = 0; i < n1; i++) {
 80267e4:	9b06      	ldr	r3, [sp, #24]
 80267e6:	2b00      	cmp	r3, #0
 80267e8:	dd16      	ble.n	8026818 <cblas_ztrsm+0xd18>
 80267ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80267ec:	011b      	lsls	r3, r3, #4
 80267ee:	9303      	str	r3, [sp, #12]
 80267f0:	9b02      	ldr	r3, [sp, #8]
 80267f2:	011b      	lsls	r3, r3, #4
 80267f4:	9310      	str	r3, [sp, #64]	; 0x40
 80267f6:	f7ff bbe8 	b.w	8025fca <cblas_ztrsm+0x4ca>
      for (i = 0; i < n1; i++) {
 80267fa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80267fc:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80267fe:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8026800:	440a      	add	r2, r1
 8026802:	920f      	str	r2, [sp, #60]	; 0x3c
 8026804:	9903      	ldr	r1, [sp, #12]
 8026806:	9a00      	ldr	r2, [sp, #0]
 8026808:	440a      	add	r2, r1
 802680a:	9200      	str	r2, [sp, #0]
 802680c:	9a06      	ldr	r2, [sp, #24]
 802680e:	3301      	adds	r3, #1
 8026810:	429a      	cmp	r2, r3
 8026812:	9310      	str	r3, [sp, #64]	; 0x40
 8026814:	f73f ad66 	bgt.w	80262e4 <cblas_ztrsm+0x7e4>
 8026818:	b015      	add	sp, #84	; 0x54
 802681a:	ecbd 8b0a 	vpop	{d8-d12}
 802681e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i = 0; i < n1; i++) {
 8026822:	9a07      	ldr	r2, [sp, #28]
 8026824:	9903      	ldr	r1, [sp, #12]
 8026826:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026828:	440a      	add	r2, r1
 802682a:	9207      	str	r2, [sp, #28]
 802682c:	9a06      	ldr	r2, [sp, #24]
 802682e:	3301      	adds	r3, #1
 8026830:	429a      	cmp	r2, r3
 8026832:	930b      	str	r3, [sp, #44]	; 0x2c
 8026834:	f73f abde 	bgt.w	8025ff4 <cblas_ztrsm+0x4f4>
 8026838:	e7ee      	b.n	8026818 <cblas_ztrsm+0xd18>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802683a:	f002 fbfd 	bl	8029038 <__aeabi_dcmpeq>
 802683e:	2800      	cmp	r0, #0
 8026840:	f000 83f0 	beq.w	8027024 <cblas_ztrsm+0x1524>
 8026844:	2200      	movs	r2, #0
 8026846:	2300      	movs	r3, #0
 8026848:	4650      	mov	r0, sl
 802684a:	4659      	mov	r1, fp
 802684c:	f002 fbf4 	bl	8029038 <__aeabi_dcmpeq>
 8026850:	2800      	cmp	r0, #0
 8026852:	f000 83e7 	beq.w	8027024 <cblas_ztrsm+0x1524>
      for (i = n1; i > 0 && i--;) {
 8026856:	9b06      	ldr	r3, [sp, #24]
 8026858:	2b00      	cmp	r3, #0
 802685a:	dddd      	ble.n	8026818 <cblas_ztrsm+0xd18>
 802685c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802685e:	011b      	lsls	r3, r3, #4
 8026860:	9303      	str	r3, [sp, #12]
 8026862:	9b02      	ldr	r3, [sp, #8]
 8026864:	011b      	lsls	r3, r3, #4
 8026866:	9310      	str	r3, [sp, #64]	; 0x40
 8026868:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802686a:	9c01      	ldr	r4, [sp, #4]
 802686c:	ebc2 7102 	rsb	r1, r2, r2, lsl #28
 8026870:	9a06      	ldr	r2, [sp, #24]
 8026872:	3a01      	subs	r2, #1
 8026874:	4610      	mov	r0, r2
 8026876:	9207      	str	r2, [sp, #28]
 8026878:	43e2      	mvns	r2, r4
 802687a:	0112      	lsls	r2, r2, #4
 802687c:	1c63      	adds	r3, r4, #1
 802687e:	920b      	str	r2, [sp, #44]	; 0x2c
 8026880:	4602      	mov	r2, r0
 8026882:	980a      	ldr	r0, [sp, #40]	; 0x28
 8026884:	011b      	lsls	r3, r3, #4
 8026886:	0109      	lsls	r1, r1, #4
 8026888:	910e      	str	r1, [sp, #56]	; 0x38
 802688a:	fb03 0102 	mla	r1, r3, r2, r0
 802688e:	3b10      	subs	r3, #16
 8026890:	9309      	str	r3, [sp, #36]	; 0x24
 8026892:	f100 0310 	add.w	r3, r0, #16
 8026896:	930f      	str	r3, [sp, #60]	; 0x3c
 8026898:	9b03      	ldr	r3, [sp, #12]
 802689a:	910a      	str	r1, [sp, #40]	; 0x28
 802689c:	4618      	mov	r0, r3
 802689e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80268a0:	fb00 3202 	mla	r2, r0, r2, r3
 80268a4:	9208      	str	r2, [sp, #32]
 80268a6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80268a8:	4413      	add	r3, r2
 80268aa:	930d      	str	r3, [sp, #52]	; 0x34
        if (nonunit) {
 80268ac:	9b05      	ldr	r3, [sp, #20]
 80268ae:	2b83      	cmp	r3, #131	; 0x83
 80268b0:	f000 847f 	beq.w	80271b2 <cblas_ztrsm+0x16b2>
        for (k = 0; k < i; k++) {
 80268b4:	9b07      	ldr	r3, [sp, #28]
 80268b6:	2b00      	cmp	r3, #0
 80268b8:	d0ae      	beq.n	8026818 <cblas_ztrsm+0xd18>
 80268ba:	ee1c 0a10 	vmov	r0, s24
 80268be:	f002 f8e9 	bl	8028a94 <__aeabi_i2d>
 80268c2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80268c4:	9a07      	ldr	r2, [sp, #28]
 80268c6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80268ca:	9300      	str	r3, [sp, #0]
 80268cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80268ce:	9301      	str	r3, [sp, #4]
 80268d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80268d2:	9304      	str	r3, [sp, #16]
 80268d4:	ec41 0b1b 	vmov	d11, r0, r1
 80268d8:	2300      	movs	r3, #0
 80268da:	9306      	str	r3, [sp, #24]
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 80268dc:	9c00      	ldr	r4, [sp, #0]
 80268de:	ec51 0b1b 	vmov	r0, r1, d11
 80268e2:	e954 2302 	ldrd	r2, r3, [r4, #-8]
 80268e6:	f002 f93f 	bl	8028b68 <__aeabi_dmul>
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 80268ea:	ed14 7b04 	vldr	d7, [r4, #-16]
          for (j = 0; j < n2; j++) {
 80268ee:	9b02      	ldr	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 80268f0:	eeb0 9a47 	vmov.f32	s18, s14
 80268f4:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 80268f8:	2b00      	cmp	r3, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 80268fa:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 80268fe:	dd49      	ble.n	8026994 <cblas_ztrsm+0xe94>
 8026900:	9b04      	ldr	r3, [sp, #16]
 8026902:	9c08      	ldr	r4, [sp, #32]
 8026904:	9d01      	ldr	r5, [sp, #4]
 8026906:	f103 0b08 	add.w	fp, r3, #8
 802690a:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 802690c:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8026910:	ec51 0b19 	vmov	r0, r1, d9
 8026914:	4632      	mov	r2, r6
 8026916:	463b      	mov	r3, r7
 8026918:	f002 f926 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802691c:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8026920:	ec41 0b1a 	vmov	d10, r0, r1
 8026924:	4642      	mov	r2, r8
 8026926:	464b      	mov	r3, r9
 8026928:	ec51 0b18 	vmov	r0, r1, d8
 802692c:	f002 f91c 	bl	8028b68 <__aeabi_dmul>
 8026930:	4602      	mov	r2, r0
 8026932:	460b      	mov	r3, r1
 8026934:	ec51 0b1a 	vmov	r0, r1, d10
 8026938:	f001 ff5e 	bl	80287f8 <__aeabi_dsub>
 802693c:	4602      	mov	r2, r0
 802693e:	460b      	mov	r3, r1
 8026940:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8026944:	f001 ff58 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8026948:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 802694a:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 802694e:	464b      	mov	r3, r9
 8026950:	ec51 0b19 	vmov	r0, r1, d9
 8026954:	f002 f908 	bl	8028b68 <__aeabi_dmul>
 8026958:	4632      	mov	r2, r6
 802695a:	463b      	mov	r3, r7
 802695c:	4606      	mov	r6, r0
 802695e:	460f      	mov	r7, r1
 8026960:	ec51 0b18 	vmov	r0, r1, d8
 8026964:	f002 f900 	bl	8028b68 <__aeabi_dmul>
 8026968:	4602      	mov	r2, r0
 802696a:	460b      	mov	r3, r1
 802696c:	4630      	mov	r0, r6
 802696e:	4639      	mov	r1, r7
 8026970:	f001 ff44 	bl	80287fc <__adddf3>
 8026974:	4602      	mov	r2, r0
 8026976:	460b      	mov	r3, r1
 8026978:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 802697c:	f001 ff3c 	bl	80287f8 <__aeabi_dsub>
 8026980:	f10a 0a10 	add.w	sl, sl, #16
 8026984:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8026988:	45aa      	cmp	sl, r5
 802698a:	f104 0410 	add.w	r4, r4, #16
 802698e:	f10b 0b10 	add.w	fp, fp, #16
 8026992:	d1bb      	bne.n	802690c <cblas_ztrsm+0xe0c>
        for (k = 0; k < i; k++) {
 8026994:	9a00      	ldr	r2, [sp, #0]
 8026996:	9909      	ldr	r1, [sp, #36]	; 0x24
 8026998:	9b06      	ldr	r3, [sp, #24]
 802699a:	440a      	add	r2, r1
 802699c:	9904      	ldr	r1, [sp, #16]
 802699e:	9200      	str	r2, [sp, #0]
 80269a0:	4608      	mov	r0, r1
 80269a2:	9a03      	ldr	r2, [sp, #12]
 80269a4:	9901      	ldr	r1, [sp, #4]
 80269a6:	4410      	add	r0, r2
 80269a8:	4411      	add	r1, r2
 80269aa:	9a07      	ldr	r2, [sp, #28]
 80269ac:	9004      	str	r0, [sp, #16]
 80269ae:	3301      	adds	r3, #1
 80269b0:	429a      	cmp	r2, r3
 80269b2:	9306      	str	r3, [sp, #24]
 80269b4:	9101      	str	r1, [sp, #4]
 80269b6:	d191      	bne.n	80268dc <cblas_ztrsm+0xddc>
 80269b8:	9b08      	ldr	r3, [sp, #32]
 80269ba:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80269bc:	4413      	add	r3, r2
 80269be:	9308      	str	r3, [sp, #32]
 80269c0:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
 80269c4:	4413      	add	r3, r2
 80269c6:	930a      	str	r3, [sp, #40]	; 0x28
 80269c8:	9b07      	ldr	r3, [sp, #28]
 80269ca:	3b01      	subs	r3, #1
 80269cc:	9307      	str	r3, [sp, #28]
 80269ce:	e76d      	b.n	80268ac <cblas_ztrsm+0xdac>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80269d0:	f002 fb32 	bl	8029038 <__aeabi_dcmpeq>
 80269d4:	2800      	cmp	r0, #0
 80269d6:	f000 8389 	beq.w	80270ec <cblas_ztrsm+0x15ec>
 80269da:	2200      	movs	r2, #0
 80269dc:	2300      	movs	r3, #0
 80269de:	4650      	mov	r0, sl
 80269e0:	4659      	mov	r1, fp
 80269e2:	f002 fb29 	bl	8029038 <__aeabi_dcmpeq>
 80269e6:	2800      	cmp	r0, #0
 80269e8:	f000 8380 	beq.w	80270ec <cblas_ztrsm+0x15ec>
      for (i = 0; i < n1; i++) {
 80269ec:	9b06      	ldr	r3, [sp, #24]
 80269ee:	2b00      	cmp	r3, #0
 80269f0:	f77f af12 	ble.w	8026818 <cblas_ztrsm+0xd18>
 80269f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80269f6:	011b      	lsls	r3, r3, #4
 80269f8:	9303      	str	r3, [sp, #12]
 80269fa:	9b02      	ldr	r3, [sp, #8]
 80269fc:	011b      	lsls	r3, r3, #4
 80269fe:	9310      	str	r3, [sp, #64]	; 0x40
 8026a00:	9a01      	ldr	r2, [sp, #4]
 8026a02:	9810      	ldr	r0, [sp, #64]	; 0x40
 8026a04:	990c      	ldr	r1, [sp, #48]	; 0x30
        for (i = 0; i < n1; i++) {
 8026a06:	9108      	str	r1, [sp, #32]
 8026a08:	3201      	adds	r2, #1
 8026a0a:	0112      	lsls	r2, r2, #4
 8026a0c:	4605      	mov	r5, r0
 8026a0e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8026a10:	9212      	str	r2, [sp, #72]	; 0x48
 8026a12:	f1a2 0308 	sub.w	r3, r2, #8
 8026a16:	18c3      	adds	r3, r0, r3
 8026a18:	2400      	movs	r4, #0
 8026a1a:	930d      	str	r3, [sp, #52]	; 0x34
 8026a1c:	f1a2 0310 	sub.w	r3, r2, #16
 8026a20:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
 8026a24:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026a26:	930e      	str	r3, [sp, #56]	; 0x38
 8026a28:	440d      	add	r5, r1
 8026a2a:	f101 0308 	add.w	r3, r1, #8
 8026a2e:	9411      	str	r4, [sp, #68]	; 0x44
 8026a30:	9510      	str	r5, [sp, #64]	; 0x40
 8026a32:	900f      	str	r0, [sp, #60]	; 0x3c
 8026a34:	9313      	str	r3, [sp, #76]	; 0x4c
        if (nonunit) {
 8026a36:	9b05      	ldr	r3, [sp, #20]
 8026a38:	2b83      	cmp	r3, #131	; 0x83
 8026a3a:	f000 8506 	beq.w	802744a <cblas_ztrsm+0x194a>
        for (k = i + 1; k < n1; k++) {
 8026a3e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026a40:	9a06      	ldr	r2, [sp, #24]
 8026a42:	3301      	adds	r3, #1
 8026a44:	429a      	cmp	r2, r3
 8026a46:	930a      	str	r3, [sp, #40]	; 0x28
 8026a48:	f77f aee6 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8026a4c:	ee1c 0a10 	vmov	r0, s24
 8026a50:	f002 f820 	bl	8028a94 <__aeabi_i2d>
 8026a54:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026a56:	ec41 0b1b 	vmov	d11, r0, r1
 8026a5a:	4619      	mov	r1, r3
 8026a5c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026a5e:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 8026a62:	9204      	str	r2, [sp, #16]
 8026a64:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026a66:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8026a6a:	9301      	str	r3, [sp, #4]
 8026a6c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8026a6e:	9300      	str	r3, [sp, #0]
 8026a70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026a72:	9307      	str	r3, [sp, #28]
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8026a74:	9c00      	ldr	r4, [sp, #0]
 8026a76:	ec51 0b1b 	vmov	r0, r1, d11
 8026a7a:	e9d4 2300 	ldrd	r2, r3, [r4]
 8026a7e:	f002 f873 	bl	8028b68 <__aeabi_dmul>
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8026a82:	ed14 7b02 	vldr	d7, [r4, #-8]
          for (j = 0; j < n2; j++) {
 8026a86:	9b02      	ldr	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8026a88:	eeb0 9a47 	vmov.f32	s18, s14
 8026a8c:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 8026a90:	2b00      	cmp	r3, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8026a92:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8026a96:	dd49      	ble.n	8026b2c <cblas_ztrsm+0x102c>
 8026a98:	9b04      	ldr	r3, [sp, #16]
 8026a9a:	9c08      	ldr	r4, [sp, #32]
 8026a9c:	9d01      	ldr	r5, [sp, #4]
 8026a9e:	f103 0b08 	add.w	fp, r3, #8
 8026aa2:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026aa4:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8026aa8:	ec51 0b19 	vmov	r0, r1, d9
 8026aac:	4632      	mov	r2, r6
 8026aae:	463b      	mov	r3, r7
 8026ab0:	f002 f85a 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026ab4:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8026ab8:	ec41 0b1a 	vmov	d10, r0, r1
 8026abc:	4642      	mov	r2, r8
 8026abe:	464b      	mov	r3, r9
 8026ac0:	ec51 0b18 	vmov	r0, r1, d8
 8026ac4:	f002 f850 	bl	8028b68 <__aeabi_dmul>
 8026ac8:	4602      	mov	r2, r0
 8026aca:	460b      	mov	r3, r1
 8026acc:	ec51 0b1a 	vmov	r0, r1, d10
 8026ad0:	f001 fe92 	bl	80287f8 <__aeabi_dsub>
 8026ad4:	4602      	mov	r2, r0
 8026ad6:	460b      	mov	r3, r1
 8026ad8:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8026adc:	f001 fe8c 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8026ae0:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8026ae2:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8026ae6:	464b      	mov	r3, r9
 8026ae8:	ec51 0b19 	vmov	r0, r1, d9
 8026aec:	f002 f83c 	bl	8028b68 <__aeabi_dmul>
 8026af0:	4632      	mov	r2, r6
 8026af2:	463b      	mov	r3, r7
 8026af4:	4606      	mov	r6, r0
 8026af6:	460f      	mov	r7, r1
 8026af8:	ec51 0b18 	vmov	r0, r1, d8
 8026afc:	f002 f834 	bl	8028b68 <__aeabi_dmul>
 8026b00:	4602      	mov	r2, r0
 8026b02:	460b      	mov	r3, r1
 8026b04:	4630      	mov	r0, r6
 8026b06:	4639      	mov	r1, r7
 8026b08:	f001 fe78 	bl	80287fc <__adddf3>
 8026b0c:	4602      	mov	r2, r0
 8026b0e:	460b      	mov	r3, r1
 8026b10:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8026b14:	f001 fe70 	bl	80287f8 <__aeabi_dsub>
 8026b18:	f10a 0a10 	add.w	sl, sl, #16
 8026b1c:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8026b20:	4555      	cmp	r5, sl
 8026b22:	f104 0410 	add.w	r4, r4, #16
 8026b26:	f10b 0b10 	add.w	fp, fp, #16
 8026b2a:	d1bb      	bne.n	8026aa4 <cblas_ztrsm+0xfa4>
        for (k = i + 1; k < n1; k++) {
 8026b2c:	9904      	ldr	r1, [sp, #16]
 8026b2e:	9a03      	ldr	r2, [sp, #12]
 8026b30:	9b07      	ldr	r3, [sp, #28]
 8026b32:	4608      	mov	r0, r1
 8026b34:	9901      	ldr	r1, [sp, #4]
 8026b36:	4411      	add	r1, r2
 8026b38:	4410      	add	r0, r2
 8026b3a:	9101      	str	r1, [sp, #4]
 8026b3c:	9a00      	ldr	r2, [sp, #0]
 8026b3e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8026b40:	9004      	str	r0, [sp, #16]
 8026b42:	440a      	add	r2, r1
 8026b44:	9200      	str	r2, [sp, #0]
 8026b46:	9a06      	ldr	r2, [sp, #24]
 8026b48:	3301      	adds	r3, #1
 8026b4a:	429a      	cmp	r2, r3
 8026b4c:	9307      	str	r3, [sp, #28]
 8026b4e:	d191      	bne.n	8026a74 <cblas_ztrsm+0xf74>
 8026b50:	9b08      	ldr	r3, [sp, #32]
 8026b52:	9a03      	ldr	r2, [sp, #12]
 8026b54:	4413      	add	r3, r2
 8026b56:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8026b58:	9308      	str	r3, [sp, #32]
 8026b5a:	4611      	mov	r1, r2
 8026b5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026b5e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026b60:	441a      	add	r2, r3
 8026b62:	920e      	str	r2, [sp, #56]	; 0x38
 8026b64:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8026b66:	4419      	add	r1, r3
 8026b68:	9111      	str	r1, [sp, #68]	; 0x44
 8026b6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8026b6c:	4611      	mov	r1, r2
 8026b6e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8026b70:	4419      	add	r1, r3
 8026b72:	441a      	add	r2, r3
 8026b74:	910d      	str	r1, [sp, #52]	; 0x34
 8026b76:	920f      	str	r2, [sp, #60]	; 0x3c
 8026b78:	e75d      	b.n	8026a36 <cblas_ztrsm+0xf36>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8026b7a:	f002 fa5d 	bl	8029038 <__aeabi_dcmpeq>
 8026b7e:	2800      	cmp	r0, #0
 8026b80:	f000 84da 	beq.w	8027538 <cblas_ztrsm+0x1a38>
 8026b84:	2200      	movs	r2, #0
 8026b86:	2300      	movs	r3, #0
 8026b88:	4650      	mov	r0, sl
 8026b8a:	4659      	mov	r1, fp
 8026b8c:	f002 fa54 	bl	8029038 <__aeabi_dcmpeq>
 8026b90:	2800      	cmp	r0, #0
 8026b92:	f000 84d1 	beq.w	8027538 <cblas_ztrsm+0x1a38>
      for (i = 0; i < n1; i++) {
 8026b96:	9b06      	ldr	r3, [sp, #24]
 8026b98:	2b00      	cmp	r3, #0
 8026b9a:	f77f ae3d 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8026b9e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026ba0:	011b      	lsls	r3, r3, #4
 8026ba2:	9303      	str	r3, [sp, #12]
 8026ba4:	9b02      	ldr	r3, [sp, #8]
 8026ba6:	011b      	lsls	r3, r3, #4
 8026ba8:	9310      	str	r3, [sp, #64]	; 0x40
 8026baa:	9a01      	ldr	r2, [sp, #4]
 8026bac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026bae:	3201      	adds	r2, #1
 8026bb0:	0112      	lsls	r2, r2, #4
 8026bb2:	9209      	str	r2, [sp, #36]	; 0x24
 8026bb4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026bb6:	3b10      	subs	r3, #16
            for (k = j + 1; k < n2; k++) {
 8026bb8:	2100      	movs	r1, #0
 8026bba:	441a      	add	r2, r3
 8026bbc:	910d      	str	r1, [sp, #52]	; 0x34
 8026bbe:	9200      	str	r2, [sp, #0]
 8026bc0:	910e      	str	r1, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 8026bc2:	9b02      	ldr	r3, [sp, #8]
 8026bc4:	2b00      	cmp	r3, #0
 8026bc6:	f340 80ea 	ble.w	8026d9e <cblas_ztrsm+0x129e>
 8026bca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026bcc:	9304      	str	r3, [sp, #16]
 8026bce:	3308      	adds	r3, #8
 8026bd0:	e9dd 210c 	ldrd	r2, r1, [sp, #48]	; 0x30
 8026bd4:	9308      	str	r3, [sp, #32]
 8026bd6:	2300      	movs	r3, #0
 8026bd8:	9307      	str	r3, [sp, #28]
          if (nonunit) {
 8026bda:	9b05      	ldr	r3, [sp, #20]
 8026bdc:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8026be0:	2b83      	cmp	r3, #131	; 0x83
 8026be2:	9201      	str	r2, [sp, #4]
 8026be4:	d070      	beq.n	8026cc8 <cblas_ztrsm+0x11c8>
 8026be6:	9b01      	ldr	r3, [sp, #4]
 8026be8:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026bec:	9c01      	ldr	r4, [sp, #4]
            for (k = j + 1; k < n2; k++) {
 8026bee:	9b07      	ldr	r3, [sp, #28]
 8026bf0:	9a02      	ldr	r2, [sp, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026bf2:	ed94 7b00 	vldr	d7, [r4]
            for (k = j + 1; k < n2; k++) {
 8026bf6:	3301      	adds	r3, #1
 8026bf8:	429a      	cmp	r2, r3
 8026bfa:	9307      	str	r3, [sp, #28]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026bfc:	eeb0 8a47 	vmov.f32	s16, s14
 8026c00:	eef0 8a67 	vmov.f32	s17, s15
            for (k = j + 1; k < n2; k++) {
 8026c04:	f000 80cb 	beq.w	8026d9e <cblas_ztrsm+0x129e>
 8026c08:	ee1c 0a10 	vmov	r0, s24
 8026c0c:	f001 ff42 	bl	8028a94 <__aeabi_i2d>
 8026c10:	f8dd b010 	ldr.w	fp, [sp, #16]
 8026c14:	ec41 0b1a 	vmov	d10, r0, r1
 8026c18:	46a2      	mov	sl, r4
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8026c1a:	e9db 2306 	ldrd	r2, r3, [fp, #24]
 8026c1e:	ec51 0b1a 	vmov	r0, r1, d10
 8026c22:	f001 ffa1 	bl	8028b68 <__aeabi_dmul>
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8026c26:	e9db 8904 	ldrd	r8, r9, [fp, #16]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8026c2a:	4604      	mov	r4, r0
 8026c2c:	460d      	mov	r5, r1
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8026c2e:	4642      	mov	r2, r8
 8026c30:	464b      	mov	r3, r9
 8026c32:	ec51 0b18 	vmov	r0, r1, d8
 8026c36:	f001 ff97 	bl	8028b68 <__aeabi_dmul>
 8026c3a:	4632      	mov	r2, r6
 8026c3c:	ec41 0b19 	vmov	d9, r0, r1
 8026c40:	463b      	mov	r3, r7
 8026c42:	4620      	mov	r0, r4
 8026c44:	4629      	mov	r1, r5
 8026c46:	f001 ff8f 	bl	8028b68 <__aeabi_dmul>
 8026c4a:	4602      	mov	r2, r0
 8026c4c:	460b      	mov	r3, r1
 8026c4e:	ec51 0b19 	vmov	r0, r1, d9
 8026c52:	f001 fdd1 	bl	80287f8 <__aeabi_dsub>
 8026c56:	4602      	mov	r2, r0
 8026c58:	460b      	mov	r3, r1
 8026c5a:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 8026c5e:	f001 fdcb 	bl	80287f8 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8026c62:	4632      	mov	r2, r6
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8026c64:	e9ca 0104 	strd	r0, r1, [sl, #16]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8026c68:	463b      	mov	r3, r7
 8026c6a:	4640      	mov	r0, r8
 8026c6c:	4649      	mov	r1, r9
 8026c6e:	f001 ff7b 	bl	8028b68 <__aeabi_dmul>
 8026c72:	4622      	mov	r2, r4
 8026c74:	462b      	mov	r3, r5
 8026c76:	4604      	mov	r4, r0
 8026c78:	460d      	mov	r5, r1
 8026c7a:	ec51 0b18 	vmov	r0, r1, d8
 8026c7e:	f001 ff73 	bl	8028b68 <__aeabi_dmul>
 8026c82:	4602      	mov	r2, r0
 8026c84:	460b      	mov	r3, r1
 8026c86:	4620      	mov	r0, r4
 8026c88:	4629      	mov	r1, r5
 8026c8a:	f001 fdb7 	bl	80287fc <__adddf3>
 8026c8e:	460b      	mov	r3, r1
 8026c90:	4602      	mov	r2, r0
 8026c92:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 8026c96:	f001 fdaf 	bl	80287f8 <__aeabi_dsub>
            for (k = j + 1; k < n2; k++) {
 8026c9a:	9b00      	ldr	r3, [sp, #0]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8026c9c:	e9ca 0106 	strd	r0, r1, [sl, #24]
            for (k = j + 1; k < n2; k++) {
 8026ca0:	f10a 0a10 	add.w	sl, sl, #16
 8026ca4:	4553      	cmp	r3, sl
 8026ca6:	f10b 0b10 	add.w	fp, fp, #16
 8026caa:	d1b6      	bne.n	8026c1a <cblas_ztrsm+0x111a>
 8026cac:	9a04      	ldr	r2, [sp, #16]
 8026cae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8026cb0:	4611      	mov	r1, r2
 8026cb2:	9a01      	ldr	r2, [sp, #4]
 8026cb4:	3210      	adds	r2, #16
 8026cb6:	9201      	str	r2, [sp, #4]
 8026cb8:	9a08      	ldr	r2, [sp, #32]
 8026cba:	4419      	add	r1, r3
 8026cbc:	441a      	add	r2, r3
          if (nonunit) {
 8026cbe:	9b05      	ldr	r3, [sp, #20]
 8026cc0:	9104      	str	r1, [sp, #16]
 8026cc2:	2b83      	cmp	r3, #131	; 0x83
 8026cc4:	9208      	str	r2, [sp, #32]
 8026cc6:	d18e      	bne.n	8026be6 <cblas_ztrsm+0x10e6>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026cc8:	ee1c 0a10 	vmov	r0, s24
 8026ccc:	f001 fee2 	bl	8028a94 <__aeabi_i2d>
 8026cd0:	9c08      	ldr	r4, [sp, #32]
 8026cd2:	e9d4 2300 	ldrd	r2, r3, [r4]
 8026cd6:	f001 ff47 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8026cda:	e954 4502 	ldrd	r4, r5, [r4, #-8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026cde:	4606      	mov	r6, r0
 8026ce0:	460f      	mov	r7, r1
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8026ce2:	4632      	mov	r2, r6
 8026ce4:	463b      	mov	r3, r7
 8026ce6:	4620      	mov	r0, r4
 8026ce8:	4629      	mov	r1, r5
 8026cea:	f7fe fed1 	bl	8025a90 <xhypot>
 8026cee:	4682      	mov	sl, r0
 8026cf0:	468b      	mov	fp, r1
            const BASE a_real = Ajj_real / s;
 8026cf2:	4620      	mov	r0, r4
 8026cf4:	4629      	mov	r1, r5
 8026cf6:	4652      	mov	r2, sl
 8026cf8:	465b      	mov	r3, fp
 8026cfa:	f002 f85f 	bl	8028dbc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 8026cfe:	4652      	mov	r2, sl
            const BASE a_real = Ajj_real / s;
 8026d00:	4604      	mov	r4, r0
 8026d02:	460d      	mov	r5, r1
            const BASE a_imag = Ajj_imag / s;
 8026d04:	465b      	mov	r3, fp
 8026d06:	4630      	mov	r0, r6
 8026d08:	4639      	mov	r1, r7
 8026d0a:	f002 f857 	bl	8028dbc <__aeabi_ddiv>
            const BASE a_real = Ajj_real / s;
 8026d0e:	ec45 4b19 	vmov	d9, r4, r5
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026d12:	9d01      	ldr	r5, [sp, #4]
 8026d14:	ed95 7b00 	vldr	d7, [r5]
            const BASE a_imag = Ajj_imag / s;
 8026d18:	4680      	mov	r8, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026d1a:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026d1e:	eeb0 8a47 	vmov.f32	s16, s14
 8026d22:	eef0 8a67 	vmov.f32	s17, s15
            const BASE a_imag = Ajj_imag / s;
 8026d26:	4689      	mov	r9, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026d28:	ec51 0b19 	vmov	r0, r1, d9
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026d2c:	e9d5 6702 	ldrd	r6, r7, [r5, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026d30:	f001 ff1a 	bl	8028b68 <__aeabi_dmul>
 8026d34:	4632      	mov	r2, r6
 8026d36:	463b      	mov	r3, r7
 8026d38:	4604      	mov	r4, r0
 8026d3a:	460d      	mov	r5, r1
 8026d3c:	4640      	mov	r0, r8
 8026d3e:	4649      	mov	r1, r9
 8026d40:	f001 ff12 	bl	8028b68 <__aeabi_dmul>
 8026d44:	4602      	mov	r2, r0
 8026d46:	460b      	mov	r3, r1
 8026d48:	4620      	mov	r0, r4
 8026d4a:	4629      	mov	r1, r5
 8026d4c:	f001 fd56 	bl	80287fc <__adddf3>
 8026d50:	4652      	mov	r2, sl
 8026d52:	465b      	mov	r3, fp
 8026d54:	f002 f832 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026d58:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026d5a:	9e01      	ldr	r6, [sp, #4]
 8026d5c:	4604      	mov	r4, r0
 8026d5e:	460d      	mov	r5, r1
 8026d60:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026d64:	463b      	mov	r3, r7
 8026d66:	ec51 0b19 	vmov	r0, r1, d9
 8026d6a:	f001 fefd 	bl	8028b68 <__aeabi_dmul>
 8026d6e:	ec53 2b18 	vmov	r2, r3, d8
 8026d72:	460d      	mov	r5, r1
 8026d74:	4604      	mov	r4, r0
 8026d76:	4649      	mov	r1, r9
 8026d78:	4640      	mov	r0, r8
 8026d7a:	f001 fef5 	bl	8028b68 <__aeabi_dmul>
 8026d7e:	4602      	mov	r2, r0
 8026d80:	460b      	mov	r3, r1
 8026d82:	4620      	mov	r0, r4
 8026d84:	4629      	mov	r1, r5
 8026d86:	f001 fd37 	bl	80287f8 <__aeabi_dsub>
 8026d8a:	4652      	mov	r2, sl
 8026d8c:	465b      	mov	r3, fp
 8026d8e:	f002 f815 	bl	8028dbc <__aeabi_ddiv>
 8026d92:	9d01      	ldr	r5, [sp, #4]
 8026d94:	4606      	mov	r6, r0
 8026d96:	460f      	mov	r7, r1
 8026d98:	e9c5 6702 	strd	r6, r7, [r5, #8]
 8026d9c:	e726      	b.n	8026bec <cblas_ztrsm+0x10ec>
      for (i = 0; i < n1; i++) {
 8026d9e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8026da0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8026da2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026da4:	440a      	add	r2, r1
 8026da6:	920d      	str	r2, [sp, #52]	; 0x34
 8026da8:	9903      	ldr	r1, [sp, #12]
 8026daa:	9a00      	ldr	r2, [sp, #0]
 8026dac:	440a      	add	r2, r1
 8026dae:	9200      	str	r2, [sp, #0]
 8026db0:	9a06      	ldr	r2, [sp, #24]
 8026db2:	3301      	adds	r3, #1
 8026db4:	429a      	cmp	r2, r3
 8026db6:	930e      	str	r3, [sp, #56]	; 0x38
 8026db8:	f73f af03 	bgt.w	8026bc2 <cblas_ztrsm+0x10c2>
 8026dbc:	e52c      	b.n	8026818 <cblas_ztrsm+0xd18>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8026dbe:	f002 f93b 	bl	8029038 <__aeabi_dcmpeq>
 8026dc2:	2800      	cmp	r0, #0
 8026dc4:	f000 82df 	beq.w	8027386 <cblas_ztrsm+0x1886>
 8026dc8:	2200      	movs	r2, #0
 8026dca:	2300      	movs	r3, #0
 8026dcc:	4650      	mov	r0, sl
 8026dce:	4659      	mov	r1, fp
 8026dd0:	f002 f932 	bl	8029038 <__aeabi_dcmpeq>
 8026dd4:	2800      	cmp	r0, #0
 8026dd6:	f000 82d6 	beq.w	8027386 <cblas_ztrsm+0x1886>
      for (i = 0; i < n1; i++) {
 8026dda:	9b06      	ldr	r3, [sp, #24]
 8026ddc:	2b00      	cmp	r3, #0
 8026dde:	f77f ad1b 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8026de2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026de4:	011b      	lsls	r3, r3, #4
 8026de6:	9303      	str	r3, [sp, #12]
 8026de8:	9b02      	ldr	r3, [sp, #8]
 8026dea:	011b      	lsls	r3, r3, #4
 8026dec:	9310      	str	r3, [sp, #64]	; 0x40
 8026dee:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8026df0:	9408      	str	r4, [sp, #32]
 8026df2:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8026df4:	9b02      	ldr	r3, [sp, #8]
 8026df6:	9a01      	ldr	r2, [sp, #4]
 8026df8:	3c10      	subs	r4, #16
 8026dfa:	3b01      	subs	r3, #1
 8026dfc:	940e      	str	r4, [sp, #56]	; 0x38
 8026dfe:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8026e00:	fb02 f003 	mul.w	r0, r2, r3
 8026e04:	fb02 3303 	mla	r3, r2, r3, r3
 8026e08:	ebc2 7102 	rsb	r1, r2, r2, lsl #28
 8026e0c:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8026e10:	43d2      	mvns	r2, r2
 8026e12:	930d      	str	r3, [sp, #52]	; 0x34
 8026e14:	010b      	lsls	r3, r1, #4
 8026e16:	930a      	str	r3, [sp, #40]	; 0x28
 8026e18:	0113      	lsls	r3, r2, #4
 8026e1a:	eb04 1000 	add.w	r0, r4, r0, lsl #4
 8026e1e:	9309      	str	r3, [sp, #36]	; 0x24
        for (j = n2; j > 0 && j--;) {
 8026e20:	2300      	movs	r3, #0
 8026e22:	900c      	str	r0, [sp, #48]	; 0x30
 8026e24:	930b      	str	r3, [sp, #44]	; 0x2c
 8026e26:	9b02      	ldr	r3, [sp, #8]
 8026e28:	2b00      	cmp	r3, #0
 8026e2a:	f340 80ee 	ble.w	802700a <cblas_ztrsm+0x150a>
 8026e2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026e30:	9908      	ldr	r1, [sp, #32]
 8026e32:	9301      	str	r3, [sp, #4]
 8026e34:	440a      	add	r2, r1
 8026e36:	9200      	str	r2, [sp, #0]
 8026e38:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8026e3a:	9207      	str	r2, [sp, #28]
 8026e3c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8026e3e:	9204      	str	r2, [sp, #16]
 8026e40:	9b01      	ldr	r3, [sp, #4]
 8026e42:	3b01      	subs	r3, #1
 8026e44:	9301      	str	r3, [sp, #4]
          if (nonunit) {
 8026e46:	9b05      	ldr	r3, [sp, #20]
 8026e48:	2b83      	cmp	r3, #131	; 0x83
 8026e4a:	d076      	beq.n	8026f3a <cblas_ztrsm+0x143a>
 8026e4c:	9b00      	ldr	r3, [sp, #0]
 8026e4e:	ed93 7b02 	vldr	d7, [r3, #8]
 8026e52:	eeb0 9a47 	vmov.f32	s18, s14
 8026e56:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026e5a:	9f00      	ldr	r7, [sp, #0]
            for (k = 0; k < j; k++) {
 8026e5c:	9b01      	ldr	r3, [sp, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026e5e:	ed97 7b00 	vldr	d7, [r7]
 8026e62:	eeb0 aa47 	vmov.f32	s20, s14
 8026e66:	eef0 aa67 	vmov.f32	s21, s15
            for (k = 0; k < j; k++) {
 8026e6a:	2b00      	cmp	r3, #0
 8026e6c:	f000 80cd 	beq.w	802700a <cblas_ztrsm+0x150a>
 8026e70:	ee1c 0a10 	vmov	r0, s24
 8026e74:	f001 fe0e 	bl	8028a94 <__aeabi_i2d>
 8026e78:	9b08      	ldr	r3, [sp, #32]
 8026e7a:	9e04      	ldr	r6, [sp, #16]
 8026e7c:	ec41 0b1b 	vmov	d11, r0, r1
 8026e80:	f103 0b08 	add.w	fp, r3, #8
 8026e84:	469a      	mov	sl, r3
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8026e86:	ed96 7b00 	vldr	d7, [r6]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8026e8a:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8026e8e:	eeb0 8a47 	vmov.f32	s16, s14
 8026e92:	eef0 8a67 	vmov.f32	s17, s15
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8026e96:	ec51 0b1b 	vmov	r0, r1, d11
 8026e9a:	f001 fe65 	bl	8028b68 <__aeabi_dmul>
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8026e9e:	ec53 2b18 	vmov	r2, r3, d8
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8026ea2:	4680      	mov	r8, r0
 8026ea4:	4689      	mov	r9, r1
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8026ea6:	ec51 0b1a 	vmov	r0, r1, d10
 8026eaa:	f001 fe5d 	bl	8028b68 <__aeabi_dmul>
 8026eae:	ec53 2b19 	vmov	r2, r3, d9
 8026eb2:	4604      	mov	r4, r0
 8026eb4:	460d      	mov	r5, r1
 8026eb6:	4640      	mov	r0, r8
 8026eb8:	4649      	mov	r1, r9
 8026eba:	f001 fe55 	bl	8028b68 <__aeabi_dmul>
 8026ebe:	4602      	mov	r2, r0
 8026ec0:	460b      	mov	r3, r1
 8026ec2:	4620      	mov	r0, r4
 8026ec4:	4629      	mov	r1, r5
 8026ec6:	f001 fc97 	bl	80287f8 <__aeabi_dsub>
 8026eca:	4602      	mov	r2, r0
 8026ecc:	460b      	mov	r3, r1
 8026ece:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8026ed2:	f001 fc91 	bl	80287f8 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8026ed6:	ec53 2b19 	vmov	r2, r3, d9
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8026eda:	e94b 0102 	strd	r0, r1, [fp, #-8]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8026ede:	ec51 0b18 	vmov	r0, r1, d8
 8026ee2:	f001 fe41 	bl	8028b68 <__aeabi_dmul>
 8026ee6:	4642      	mov	r2, r8
 8026ee8:	464b      	mov	r3, r9
 8026eea:	4604      	mov	r4, r0
 8026eec:	460d      	mov	r5, r1
 8026eee:	ec51 0b1a 	vmov	r0, r1, d10
 8026ef2:	f001 fe39 	bl	8028b68 <__aeabi_dmul>
 8026ef6:	4602      	mov	r2, r0
 8026ef8:	460b      	mov	r3, r1
 8026efa:	4620      	mov	r0, r4
 8026efc:	4629      	mov	r1, r5
 8026efe:	f001 fc7d 	bl	80287fc <__adddf3>
 8026f02:	4602      	mov	r2, r0
 8026f04:	460b      	mov	r3, r1
 8026f06:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8026f0a:	f001 fc75 	bl	80287f8 <__aeabi_dsub>
 8026f0e:	f10a 0a10 	add.w	sl, sl, #16
 8026f12:	e94a 0102 	strd	r0, r1, [sl, #-8]
            for (k = 0; k < j; k++) {
 8026f16:	45ba      	cmp	sl, r7
 8026f18:	f106 0610 	add.w	r6, r6, #16
 8026f1c:	f10b 0b10 	add.w	fp, fp, #16
 8026f20:	d1b1      	bne.n	8026e86 <cblas_ztrsm+0x1386>
 8026f22:	9b04      	ldr	r3, [sp, #16]
 8026f24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026f26:	4413      	add	r3, r2
 8026f28:	9304      	str	r3, [sp, #16]
 8026f2a:	9b00      	ldr	r3, [sp, #0]
 8026f2c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8026f2e:	3b10      	subs	r3, #16
 8026f30:	9300      	str	r3, [sp, #0]
 8026f32:	9b07      	ldr	r3, [sp, #28]
 8026f34:	4413      	add	r3, r2
 8026f36:	9307      	str	r3, [sp, #28]
 8026f38:	e782      	b.n	8026e40 <cblas_ztrsm+0x1340>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026f3a:	ee1c 0a10 	vmov	r0, s24
 8026f3e:	f001 fda9 	bl	8028a94 <__aeabi_i2d>
 8026f42:	9c07      	ldr	r4, [sp, #28]
 8026f44:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8026f48:	f001 fe0e 	bl	8028b68 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8026f4c:	e9d4 6700 	ldrd	r6, r7, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026f50:	460d      	mov	r5, r1
 8026f52:	4604      	mov	r4, r0
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8026f54:	4622      	mov	r2, r4
 8026f56:	462b      	mov	r3, r5
 8026f58:	4630      	mov	r0, r6
 8026f5a:	4639      	mov	r1, r7
 8026f5c:	f7fe fd98 	bl	8025a90 <xhypot>
 8026f60:	4682      	mov	sl, r0
 8026f62:	468b      	mov	fp, r1
            const BASE a_real = Ajj_real / s;
 8026f64:	4630      	mov	r0, r6
 8026f66:	4639      	mov	r1, r7
 8026f68:	4652      	mov	r2, sl
 8026f6a:	465b      	mov	r3, fp
 8026f6c:	f001 ff26 	bl	8028dbc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 8026f70:	4652      	mov	r2, sl
            const BASE a_real = Ajj_real / s;
 8026f72:	4606      	mov	r6, r0
 8026f74:	460f      	mov	r7, r1
            const BASE a_imag = Ajj_imag / s;
 8026f76:	465b      	mov	r3, fp
 8026f78:	4620      	mov	r0, r4
 8026f7a:	4629      	mov	r1, r5
 8026f7c:	f001 ff1e 	bl	8028dbc <__aeabi_ddiv>
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026f80:	9c00      	ldr	r4, [sp, #0]
 8026f82:	ed94 7b00 	vldr	d7, [r4]
            const BASE a_imag = Ajj_imag / s;
 8026f86:	4680      	mov	r8, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026f88:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026f8c:	eeb0 9a47 	vmov.f32	s18, s14
 8026f90:	eef0 9a67 	vmov.f32	s19, s15
            const BASE a_imag = Ajj_imag / s;
 8026f94:	4689      	mov	r9, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026f96:	4630      	mov	r0, r6
 8026f98:	4639      	mov	r1, r7
 8026f9a:	f001 fde5 	bl	8028b68 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026f9e:	ed94 8b02 	vldr	d8, [r4, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026fa2:	460d      	mov	r5, r1
 8026fa4:	ec53 2b18 	vmov	r2, r3, d8
 8026fa8:	4604      	mov	r4, r0
 8026faa:	4649      	mov	r1, r9
 8026fac:	4640      	mov	r0, r8
 8026fae:	f001 fddb 	bl	8028b68 <__aeabi_dmul>
 8026fb2:	4602      	mov	r2, r0
 8026fb4:	460b      	mov	r3, r1
 8026fb6:	4620      	mov	r0, r4
 8026fb8:	4629      	mov	r1, r5
 8026fba:	f001 fc1f 	bl	80287fc <__adddf3>
 8026fbe:	4652      	mov	r2, sl
 8026fc0:	465b      	mov	r3, fp
 8026fc2:	f001 fefb 	bl	8028dbc <__aeabi_ddiv>
 8026fc6:	4604      	mov	r4, r0
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026fc8:	4630      	mov	r0, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026fca:	9e00      	ldr	r6, [sp, #0]
 8026fcc:	460d      	mov	r5, r1
 8026fce:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026fd2:	ec53 2b18 	vmov	r2, r3, d8
 8026fd6:	4639      	mov	r1, r7
 8026fd8:	f001 fdc6 	bl	8028b68 <__aeabi_dmul>
 8026fdc:	ec53 2b19 	vmov	r2, r3, d9
 8026fe0:	4604      	mov	r4, r0
 8026fe2:	460d      	mov	r5, r1
 8026fe4:	4640      	mov	r0, r8
 8026fe6:	4649      	mov	r1, r9
 8026fe8:	f001 fdbe 	bl	8028b68 <__aeabi_dmul>
 8026fec:	4602      	mov	r2, r0
 8026fee:	460b      	mov	r3, r1
 8026ff0:	4620      	mov	r0, r4
 8026ff2:	4629      	mov	r1, r5
 8026ff4:	f001 fc00 	bl	80287f8 <__aeabi_dsub>
 8026ff8:	4652      	mov	r2, sl
 8026ffa:	465b      	mov	r3, fp
 8026ffc:	f001 fede 	bl	8028dbc <__aeabi_ddiv>
 8027000:	e9c6 0102 	strd	r0, r1, [r6, #8]
 8027004:	ec41 0b19 	vmov	d9, r0, r1
 8027008:	e727      	b.n	8026e5a <cblas_ztrsm+0x135a>
      for (i = 0; i < n1; i++) {
 802700a:	9a08      	ldr	r2, [sp, #32]
 802700c:	9903      	ldr	r1, [sp, #12]
 802700e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027010:	440a      	add	r2, r1
 8027012:	9208      	str	r2, [sp, #32]
 8027014:	9a06      	ldr	r2, [sp, #24]
 8027016:	3301      	adds	r3, #1
 8027018:	429a      	cmp	r2, r3
 802701a:	930b      	str	r3, [sp, #44]	; 0x2c
 802701c:	f73f af03 	bgt.w	8026e26 <cblas_ztrsm+0x1326>
 8027020:	f7ff bbfa 	b.w	8026818 <cblas_ztrsm+0xd18>
        for (i = 0; i < n1; i++) {
 8027024:	9b06      	ldr	r3, [sp, #24]
 8027026:	2b00      	cmp	r3, #0
 8027028:	f77f abf6 	ble.w	8026818 <cblas_ztrsm+0xd18>
 802702c:	9a02      	ldr	r2, [sp, #8]
 802702e:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8027032:	011b      	lsls	r3, r3, #4
 8027034:	9307      	str	r3, [sp, #28]
 8027036:	3308      	adds	r3, #8
 8027038:	9308      	str	r3, [sp, #32]
 802703a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802703c:	011b      	lsls	r3, r3, #4
 802703e:	9303      	str	r3, [sp, #12]
 8027040:	0113      	lsls	r3, r2, #4
 8027042:	9310      	str	r3, [sp, #64]	; 0x40
 8027044:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027046:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802704a:	9300      	str	r3, [sp, #0]
 802704c:	2300      	movs	r3, #0
 802704e:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8027050:	9b02      	ldr	r3, [sp, #8]
 8027052:	2b00      	cmp	r3, #0
 8027054:	dd3e      	ble.n	80270d4 <cblas_ztrsm+0x15d4>
 8027056:	9b07      	ldr	r3, [sp, #28]
 8027058:	9a08      	ldr	r2, [sp, #32]
 802705a:	4619      	mov	r1, r3
 802705c:	9b00      	ldr	r3, [sp, #0]
 802705e:	eb01 0803 	add.w	r8, r1, r3
 8027062:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8027066:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802706a:	ec53 2b18 	vmov	r2, r3, d8
 802706e:	4630      	mov	r0, r6
 8027070:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8027072:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8027076:	f001 fd77 	bl	8028b68 <__aeabi_dmul>
 802707a:	4652      	mov	r2, sl
 802707c:	ec41 0b19 	vmov	d9, r0, r1
 8027080:	465b      	mov	r3, fp
 8027082:	4620      	mov	r0, r4
 8027084:	4629      	mov	r1, r5
 8027086:	f001 fd6f 	bl	8028b68 <__aeabi_dmul>
 802708a:	4602      	mov	r2, r0
 802708c:	460b      	mov	r3, r1
 802708e:	ec51 0b19 	vmov	r0, r1, d9
 8027092:	f001 fbb1 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8027096:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802709a:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802709e:	4620      	mov	r0, r4
 80270a0:	4629      	mov	r1, r5
 80270a2:	f001 fd61 	bl	8028b68 <__aeabi_dmul>
 80270a6:	4652      	mov	r2, sl
 80270a8:	465b      	mov	r3, fp
 80270aa:	4604      	mov	r4, r0
 80270ac:	460d      	mov	r5, r1
 80270ae:	4630      	mov	r0, r6
 80270b0:	4639      	mov	r1, r7
 80270b2:	f001 fd59 	bl	8028b68 <__aeabi_dmul>
 80270b6:	460b      	mov	r3, r1
 80270b8:	4602      	mov	r2, r0
 80270ba:	4629      	mov	r1, r5
 80270bc:	4620      	mov	r0, r4
 80270be:	f001 fb9d 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 80270c2:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80270c4:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 80270c8:	f108 0810 	add.w	r8, r8, #16
 80270cc:	4543      	cmp	r3, r8
 80270ce:	f109 0910 	add.w	r9, r9, #16
 80270d2:	d1c8      	bne.n	8027066 <cblas_ztrsm+0x1566>
        for (i = 0; i < n1; i++) {
 80270d4:	9a00      	ldr	r2, [sp, #0]
 80270d6:	9903      	ldr	r1, [sp, #12]
 80270d8:	9b04      	ldr	r3, [sp, #16]
 80270da:	440a      	add	r2, r1
 80270dc:	9200      	str	r2, [sp, #0]
 80270de:	9a06      	ldr	r2, [sp, #24]
 80270e0:	3301      	adds	r3, #1
 80270e2:	429a      	cmp	r2, r3
 80270e4:	9304      	str	r3, [sp, #16]
 80270e6:	d1b3      	bne.n	8027050 <cblas_ztrsm+0x1550>
 80270e8:	f7ff bbbe 	b.w	8026868 <cblas_ztrsm+0xd68>
        for (i = 0; i < n1; i++) {
 80270ec:	9b06      	ldr	r3, [sp, #24]
 80270ee:	2b00      	cmp	r3, #0
 80270f0:	f77f ab92 	ble.w	8026818 <cblas_ztrsm+0xd18>
 80270f4:	9a02      	ldr	r2, [sp, #8]
 80270f6:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 80270fa:	011b      	lsls	r3, r3, #4
 80270fc:	9307      	str	r3, [sp, #28]
 80270fe:	3308      	adds	r3, #8
 8027100:	9308      	str	r3, [sp, #32]
 8027102:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027104:	011b      	lsls	r3, r3, #4
 8027106:	9303      	str	r3, [sp, #12]
 8027108:	0113      	lsls	r3, r2, #4
 802710a:	9310      	str	r3, [sp, #64]	; 0x40
 802710c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802710e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8027112:	9300      	str	r3, [sp, #0]
 8027114:	2300      	movs	r3, #0
 8027116:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8027118:	9b02      	ldr	r3, [sp, #8]
 802711a:	2b00      	cmp	r3, #0
 802711c:	dd3e      	ble.n	802719c <cblas_ztrsm+0x169c>
 802711e:	9b07      	ldr	r3, [sp, #28]
 8027120:	9a08      	ldr	r2, [sp, #32]
 8027122:	4619      	mov	r1, r3
 8027124:	9b00      	ldr	r3, [sp, #0]
 8027126:	eb01 0803 	add.w	r8, r1, r3
 802712a:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 802712e:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8027132:	ec53 2b18 	vmov	r2, r3, d8
 8027136:	4630      	mov	r0, r6
 8027138:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802713a:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802713e:	f001 fd13 	bl	8028b68 <__aeabi_dmul>
 8027142:	4652      	mov	r2, sl
 8027144:	ec41 0b19 	vmov	d9, r0, r1
 8027148:	465b      	mov	r3, fp
 802714a:	4620      	mov	r0, r4
 802714c:	4629      	mov	r1, r5
 802714e:	f001 fd0b 	bl	8028b68 <__aeabi_dmul>
 8027152:	4602      	mov	r2, r0
 8027154:	460b      	mov	r3, r1
 8027156:	ec51 0b19 	vmov	r0, r1, d9
 802715a:	f001 fb4d 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802715e:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8027162:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8027166:	4620      	mov	r0, r4
 8027168:	4629      	mov	r1, r5
 802716a:	f001 fcfd 	bl	8028b68 <__aeabi_dmul>
 802716e:	4652      	mov	r2, sl
 8027170:	465b      	mov	r3, fp
 8027172:	4604      	mov	r4, r0
 8027174:	460d      	mov	r5, r1
 8027176:	4630      	mov	r0, r6
 8027178:	4639      	mov	r1, r7
 802717a:	f001 fcf5 	bl	8028b68 <__aeabi_dmul>
 802717e:	460b      	mov	r3, r1
 8027180:	4602      	mov	r2, r0
 8027182:	4629      	mov	r1, r5
 8027184:	4620      	mov	r0, r4
 8027186:	f001 fb39 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 802718a:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802718c:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8027190:	f108 0810 	add.w	r8, r8, #16
 8027194:	4543      	cmp	r3, r8
 8027196:	f109 0910 	add.w	r9, r9, #16
 802719a:	d1c8      	bne.n	802712e <cblas_ztrsm+0x162e>
        for (i = 0; i < n1; i++) {
 802719c:	9a00      	ldr	r2, [sp, #0]
 802719e:	9903      	ldr	r1, [sp, #12]
 80271a0:	9b04      	ldr	r3, [sp, #16]
 80271a2:	440a      	add	r2, r1
 80271a4:	9200      	str	r2, [sp, #0]
 80271a6:	9a06      	ldr	r2, [sp, #24]
 80271a8:	3301      	adds	r3, #1
 80271aa:	429a      	cmp	r2, r3
 80271ac:	9304      	str	r3, [sp, #16]
 80271ae:	d1b3      	bne.n	8027118 <cblas_ztrsm+0x1618>
 80271b0:	e426      	b.n	8026a00 <cblas_ztrsm+0xf00>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80271b2:	ee1c 0a10 	vmov	r0, s24
 80271b6:	f001 fc6d 	bl	8028a94 <__aeabi_i2d>
 80271ba:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80271bc:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80271c0:	f001 fcd2 	bl	8028b68 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 80271c4:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80271c8:	4606      	mov	r6, r0
 80271ca:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 80271cc:	4620      	mov	r0, r4
 80271ce:	4629      	mov	r1, r5
 80271d0:	4632      	mov	r2, r6
 80271d2:	463b      	mov	r3, r7
 80271d4:	f7fe fc5c 	bl	8025a90 <xhypot>
 80271d8:	4680      	mov	r8, r0
 80271da:	4689      	mov	r9, r1
          const BASE a_real = Aii_real / s;
 80271dc:	4620      	mov	r0, r4
 80271de:	4629      	mov	r1, r5
 80271e0:	4642      	mov	r2, r8
 80271e2:	464b      	mov	r3, r9
 80271e4:	f001 fdea 	bl	8028dbc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 80271e8:	464b      	mov	r3, r9
          const BASE a_real = Aii_real / s;
 80271ea:	4604      	mov	r4, r0
 80271ec:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 80271ee:	4642      	mov	r2, r8
 80271f0:	4630      	mov	r0, r6
 80271f2:	4639      	mov	r1, r7
 80271f4:	f001 fde2 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 80271f8:	9b02      	ldr	r3, [sp, #8]
 80271fa:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 80271fc:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 8027200:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8027204:	f77f ab56 	ble.w	80268b4 <cblas_ztrsm+0xdb4>
 8027208:	9b08      	ldr	r3, [sp, #32]
 802720a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802720c:	441a      	add	r2, r3
 802720e:	f103 0a08 	add.w	sl, r3, #8
 8027212:	9200      	str	r2, [sp, #0]
 8027214:	469b      	mov	fp, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8027216:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802721a:	ec51 0b19 	vmov	r0, r1, d9
 802721e:	4622      	mov	r2, r4
 8027220:	462b      	mov	r3, r5
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8027222:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8027226:	f001 fc9f 	bl	8028b68 <__aeabi_dmul>
 802722a:	4632      	mov	r2, r6
 802722c:	ec41 0b1a 	vmov	d10, r0, r1
 8027230:	463b      	mov	r3, r7
 8027232:	ec51 0b18 	vmov	r0, r1, d8
 8027236:	f001 fc97 	bl	8028b68 <__aeabi_dmul>
 802723a:	4602      	mov	r2, r0
 802723c:	460b      	mov	r3, r1
 802723e:	ec51 0b1a 	vmov	r0, r1, d10
 8027242:	f001 fadb 	bl	80287fc <__adddf3>
 8027246:	4642      	mov	r2, r8
 8027248:	464b      	mov	r3, r9
 802724a:	f001 fdb7 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802724e:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8027250:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8027254:	463b      	mov	r3, r7
 8027256:	ec51 0b19 	vmov	r0, r1, d9
 802725a:	f001 fc85 	bl	8028b68 <__aeabi_dmul>
 802725e:	4622      	mov	r2, r4
 8027260:	462b      	mov	r3, r5
 8027262:	4604      	mov	r4, r0
 8027264:	460d      	mov	r5, r1
 8027266:	ec51 0b18 	vmov	r0, r1, d8
 802726a:	f001 fc7d 	bl	8028b68 <__aeabi_dmul>
 802726e:	4602      	mov	r2, r0
 8027270:	460b      	mov	r3, r1
 8027272:	4620      	mov	r0, r4
 8027274:	4629      	mov	r1, r5
 8027276:	f001 fabf 	bl	80287f8 <__aeabi_dsub>
 802727a:	464b      	mov	r3, r9
 802727c:	4642      	mov	r2, r8
 802727e:	f001 fd9d 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8027282:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8027284:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j < n2; j++) {
 8027288:	f10b 0b10 	add.w	fp, fp, #16
 802728c:	455b      	cmp	r3, fp
 802728e:	f10a 0a10 	add.w	sl, sl, #16
 8027292:	d1c0      	bne.n	8027216 <cblas_ztrsm+0x1716>
 8027294:	f7ff bb0e 	b.w	80268b4 <cblas_ztrsm+0xdb4>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8027298:	ee1c 0a10 	vmov	r0, s24
 802729c:	f001 fbfa 	bl	8028a94 <__aeabi_i2d>
 80272a0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 80272a2:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80272a6:	f001 fc5f 	bl	8028b68 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 80272aa:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80272ae:	4606      	mov	r6, r0
 80272b0:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 80272b2:	4620      	mov	r0, r4
 80272b4:	4629      	mov	r1, r5
 80272b6:	4632      	mov	r2, r6
 80272b8:	463b      	mov	r3, r7
 80272ba:	f7fe fbe9 	bl	8025a90 <xhypot>
 80272be:	4682      	mov	sl, r0
 80272c0:	468b      	mov	fp, r1
          const BASE a_real = Aii_real / s;
 80272c2:	4620      	mov	r0, r4
 80272c4:	4629      	mov	r1, r5
 80272c6:	4652      	mov	r2, sl
 80272c8:	465b      	mov	r3, fp
 80272ca:	f001 fd77 	bl	8028dbc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 80272ce:	465b      	mov	r3, fp
          const BASE a_real = Aii_real / s;
 80272d0:	4604      	mov	r4, r0
 80272d2:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 80272d4:	4652      	mov	r2, sl
 80272d6:	4630      	mov	r0, r6
 80272d8:	4639      	mov	r1, r7
 80272da:	f001 fd6f 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 80272de:	9b02      	ldr	r3, [sp, #8]
 80272e0:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 80272e2:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 80272e6:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 80272ea:	f77f a986 	ble.w	80265fa <cblas_ztrsm+0xafa>
 80272ee:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80272f0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80272f2:	4413      	add	r3, r2
 80272f4:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 80272f8:	9300      	str	r3, [sp, #0]
 80272fa:	eb01 1402 	add.w	r4, r1, r2, lsl #4
 80272fe:	4613      	mov	r3, r2
 8027300:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8027302:	eb02 1503 	add.w	r5, r2, r3, lsl #4
            const BASE Bij_real = REAL(B, ldb * i + j);
 8027306:	e955 6702 	ldrd	r6, r7, [r5, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802730a:	ec51 0b19 	vmov	r0, r1, d9
 802730e:	4632      	mov	r2, r6
 8027310:	463b      	mov	r3, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8027312:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8027316:	f001 fc27 	bl	8028b68 <__aeabi_dmul>
 802731a:	4642      	mov	r2, r8
 802731c:	ec41 0b1a 	vmov	d10, r0, r1
 8027320:	464b      	mov	r3, r9
 8027322:	ec51 0b18 	vmov	r0, r1, d8
 8027326:	f001 fc1f 	bl	8028b68 <__aeabi_dmul>
 802732a:	4602      	mov	r2, r0
 802732c:	460b      	mov	r3, r1
 802732e:	ec51 0b1a 	vmov	r0, r1, d10
 8027332:	f001 fa63 	bl	80287fc <__adddf3>
 8027336:	4652      	mov	r2, sl
 8027338:	465b      	mov	r3, fp
 802733a:	f001 fd3f 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802733e:	4642      	mov	r2, r8
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8027340:	e945 0102 	strd	r0, r1, [r5, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8027344:	464b      	mov	r3, r9
 8027346:	ec51 0b19 	vmov	r0, r1, d9
 802734a:	f001 fc0d 	bl	8028b68 <__aeabi_dmul>
 802734e:	4632      	mov	r2, r6
 8027350:	463b      	mov	r3, r7
 8027352:	4606      	mov	r6, r0
 8027354:	460f      	mov	r7, r1
 8027356:	ec51 0b18 	vmov	r0, r1, d8
 802735a:	f001 fc05 	bl	8028b68 <__aeabi_dmul>
 802735e:	4602      	mov	r2, r0
 8027360:	460b      	mov	r3, r1
 8027362:	4630      	mov	r0, r6
 8027364:	4639      	mov	r1, r7
 8027366:	f001 fa47 	bl	80287f8 <__aeabi_dsub>
 802736a:	465b      	mov	r3, fp
 802736c:	4652      	mov	r2, sl
 802736e:	f001 fd25 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8027372:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8027374:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = 0; j < n2; j++) {
 8027378:	3410      	adds	r4, #16
 802737a:	42a3      	cmp	r3, r4
 802737c:	f105 0510 	add.w	r5, r5, #16
 8027380:	d1c1      	bne.n	8027306 <cblas_ztrsm+0x1806>
 8027382:	f7ff b93a 	b.w	80265fa <cblas_ztrsm+0xafa>
        for (i = 0; i < n1; i++) {
 8027386:	9b06      	ldr	r3, [sp, #24]
 8027388:	2b00      	cmp	r3, #0
 802738a:	f77f aa45 	ble.w	8026818 <cblas_ztrsm+0xd18>
 802738e:	9a02      	ldr	r2, [sp, #8]
 8027390:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8027392:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8027396:	011b      	lsls	r3, r3, #4
 8027398:	9307      	str	r3, [sp, #28]
 802739a:	3308      	adds	r3, #8
 802739c:	9308      	str	r3, [sp, #32]
 802739e:	0113      	lsls	r3, r2, #4
 80273a0:	9310      	str	r3, [sp, #64]	; 0x40
 80273a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80273a4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80273a8:	0109      	lsls	r1, r1, #4
 80273aa:	9300      	str	r3, [sp, #0]
 80273ac:	2300      	movs	r3, #0
 80273ae:	9103      	str	r1, [sp, #12]
 80273b0:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 80273b2:	9b02      	ldr	r3, [sp, #8]
 80273b4:	2b00      	cmp	r3, #0
 80273b6:	dd3d      	ble.n	8027434 <cblas_ztrsm+0x1934>
 80273b8:	9b00      	ldr	r3, [sp, #0]
 80273ba:	9907      	ldr	r1, [sp, #28]
 80273bc:	9a08      	ldr	r2, [sp, #32]
 80273be:	eb03 0801 	add.w	r8, r3, r1
 80273c2:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 80273c6:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80273ca:	ec53 2b18 	vmov	r2, r3, d8
 80273ce:	4630      	mov	r0, r6
 80273d0:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80273d2:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80273d6:	f001 fbc7 	bl	8028b68 <__aeabi_dmul>
 80273da:	4652      	mov	r2, sl
 80273dc:	ec41 0b19 	vmov	d9, r0, r1
 80273e0:	465b      	mov	r3, fp
 80273e2:	4620      	mov	r0, r4
 80273e4:	4629      	mov	r1, r5
 80273e6:	f001 fbbf 	bl	8028b68 <__aeabi_dmul>
 80273ea:	4602      	mov	r2, r0
 80273ec:	460b      	mov	r3, r1
 80273ee:	ec51 0b19 	vmov	r0, r1, d9
 80273f2:	f001 fa01 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80273f6:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80273fa:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80273fe:	4620      	mov	r0, r4
 8027400:	4629      	mov	r1, r5
 8027402:	f001 fbb1 	bl	8028b68 <__aeabi_dmul>
 8027406:	4652      	mov	r2, sl
 8027408:	465b      	mov	r3, fp
 802740a:	4604      	mov	r4, r0
 802740c:	460d      	mov	r5, r1
 802740e:	4630      	mov	r0, r6
 8027410:	4639      	mov	r1, r7
 8027412:	f001 fba9 	bl	8028b68 <__aeabi_dmul>
 8027416:	460b      	mov	r3, r1
 8027418:	4602      	mov	r2, r0
 802741a:	4629      	mov	r1, r5
 802741c:	4620      	mov	r0, r4
 802741e:	f001 f9ed 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 8027422:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8027424:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8027428:	f108 0810 	add.w	r8, r8, #16
 802742c:	4598      	cmp	r8, r3
 802742e:	f109 0910 	add.w	r9, r9, #16
 8027432:	d1c8      	bne.n	80273c6 <cblas_ztrsm+0x18c6>
        for (i = 0; i < n1; i++) {
 8027434:	9a00      	ldr	r2, [sp, #0]
 8027436:	9903      	ldr	r1, [sp, #12]
 8027438:	9b04      	ldr	r3, [sp, #16]
 802743a:	440a      	add	r2, r1
 802743c:	9200      	str	r2, [sp, #0]
 802743e:	9a06      	ldr	r2, [sp, #24]
 8027440:	3301      	adds	r3, #1
 8027442:	429a      	cmp	r2, r3
 8027444:	9304      	str	r3, [sp, #16]
 8027446:	d1b4      	bne.n	80273b2 <cblas_ztrsm+0x18b2>
 8027448:	e4d1      	b.n	8026dee <cblas_ztrsm+0x12ee>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 802744a:	ee1c 0a10 	vmov	r0, s24
 802744e:	f001 fb21 	bl	8028a94 <__aeabi_i2d>
 8027452:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8027454:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8027458:	f001 fb86 	bl	8028b68 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 802745c:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8027460:	4606      	mov	r6, r0
 8027462:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 8027464:	4620      	mov	r0, r4
 8027466:	4629      	mov	r1, r5
 8027468:	4632      	mov	r2, r6
 802746a:	463b      	mov	r3, r7
 802746c:	f7fe fb10 	bl	8025a90 <xhypot>
 8027470:	4682      	mov	sl, r0
 8027472:	468b      	mov	fp, r1
          const BASE a_real = Aii_real / s;
 8027474:	4620      	mov	r0, r4
 8027476:	4629      	mov	r1, r5
 8027478:	4652      	mov	r2, sl
 802747a:	465b      	mov	r3, fp
 802747c:	f001 fc9e 	bl	8028dbc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 8027480:	465b      	mov	r3, fp
          const BASE a_real = Aii_real / s;
 8027482:	4604      	mov	r4, r0
 8027484:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 8027486:	4652      	mov	r2, sl
 8027488:	4630      	mov	r0, r6
 802748a:	4639      	mov	r1, r7
 802748c:	f001 fc96 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8027490:	9b02      	ldr	r3, [sp, #8]
 8027492:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 8027494:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 8027498:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 802749c:	f77f aacf 	ble.w	8026a3e <cblas_ztrsm+0xf3e>
 80274a0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80274a2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80274a4:	4413      	add	r3, r2
 80274a6:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 80274aa:	9300      	str	r3, [sp, #0]
 80274ac:	eb01 1402 	add.w	r4, r1, r2, lsl #4
 80274b0:	4613      	mov	r3, r2
 80274b2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80274b4:	eb02 1503 	add.w	r5, r2, r3, lsl #4
            const BASE Bij_real = REAL(B, ldb * i + j);
 80274b8:	e955 6702 	ldrd	r6, r7, [r5, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80274bc:	ec51 0b19 	vmov	r0, r1, d9
 80274c0:	4632      	mov	r2, r6
 80274c2:	463b      	mov	r3, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80274c4:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80274c8:	f001 fb4e 	bl	8028b68 <__aeabi_dmul>
 80274cc:	4642      	mov	r2, r8
 80274ce:	ec41 0b1a 	vmov	d10, r0, r1
 80274d2:	464b      	mov	r3, r9
 80274d4:	ec51 0b18 	vmov	r0, r1, d8
 80274d8:	f001 fb46 	bl	8028b68 <__aeabi_dmul>
 80274dc:	4602      	mov	r2, r0
 80274de:	460b      	mov	r3, r1
 80274e0:	ec51 0b1a 	vmov	r0, r1, d10
 80274e4:	f001 f98a 	bl	80287fc <__adddf3>
 80274e8:	4652      	mov	r2, sl
 80274ea:	465b      	mov	r3, fp
 80274ec:	f001 fc66 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80274f0:	4642      	mov	r2, r8
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80274f2:	e945 0102 	strd	r0, r1, [r5, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80274f6:	464b      	mov	r3, r9
 80274f8:	ec51 0b19 	vmov	r0, r1, d9
 80274fc:	f001 fb34 	bl	8028b68 <__aeabi_dmul>
 8027500:	4632      	mov	r2, r6
 8027502:	463b      	mov	r3, r7
 8027504:	4606      	mov	r6, r0
 8027506:	460f      	mov	r7, r1
 8027508:	ec51 0b18 	vmov	r0, r1, d8
 802750c:	f001 fb2c 	bl	8028b68 <__aeabi_dmul>
 8027510:	4602      	mov	r2, r0
 8027512:	460b      	mov	r3, r1
 8027514:	4630      	mov	r0, r6
 8027516:	4639      	mov	r1, r7
 8027518:	f001 f96e 	bl	80287f8 <__aeabi_dsub>
 802751c:	465b      	mov	r3, fp
 802751e:	4652      	mov	r2, sl
 8027520:	f001 fc4c 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8027524:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8027526:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = 0; j < n2; j++) {
 802752a:	3410      	adds	r4, #16
 802752c:	42a3      	cmp	r3, r4
 802752e:	f105 0510 	add.w	r5, r5, #16
 8027532:	d1c1      	bne.n	80274b8 <cblas_ztrsm+0x19b8>
 8027534:	f7ff ba83 	b.w	8026a3e <cblas_ztrsm+0xf3e>
        for (i = 0; i < n1; i++) {
 8027538:	9b06      	ldr	r3, [sp, #24]
 802753a:	2b00      	cmp	r3, #0
 802753c:	f77f a96c 	ble.w	8026818 <cblas_ztrsm+0xd18>
 8027540:	9a02      	ldr	r2, [sp, #8]
 8027542:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8027546:	011b      	lsls	r3, r3, #4
 8027548:	9307      	str	r3, [sp, #28]
 802754a:	3308      	adds	r3, #8
 802754c:	9308      	str	r3, [sp, #32]
 802754e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027550:	011b      	lsls	r3, r3, #4
 8027552:	9303      	str	r3, [sp, #12]
 8027554:	0113      	lsls	r3, r2, #4
 8027556:	9310      	str	r3, [sp, #64]	; 0x40
 8027558:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802755a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802755e:	9300      	str	r3, [sp, #0]
 8027560:	2300      	movs	r3, #0
 8027562:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8027564:	9b02      	ldr	r3, [sp, #8]
 8027566:	2b00      	cmp	r3, #0
 8027568:	dd3d      	ble.n	80275e6 <cblas_ztrsm+0x1ae6>
 802756a:	9b00      	ldr	r3, [sp, #0]
 802756c:	9907      	ldr	r1, [sp, #28]
 802756e:	9a08      	ldr	r2, [sp, #32]
 8027570:	eb03 0801 	add.w	r8, r3, r1
 8027574:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8027578:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802757c:	ec53 2b18 	vmov	r2, r3, d8
 8027580:	4630      	mov	r0, r6
 8027582:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8027584:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8027588:	f001 faee 	bl	8028b68 <__aeabi_dmul>
 802758c:	4652      	mov	r2, sl
 802758e:	ec41 0b19 	vmov	d9, r0, r1
 8027592:	465b      	mov	r3, fp
 8027594:	4620      	mov	r0, r4
 8027596:	4629      	mov	r1, r5
 8027598:	f001 fae6 	bl	8028b68 <__aeabi_dmul>
 802759c:	4602      	mov	r2, r0
 802759e:	460b      	mov	r3, r1
 80275a0:	ec51 0b19 	vmov	r0, r1, d9
 80275a4:	f001 f928 	bl	80287f8 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80275a8:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80275ac:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80275b0:	4620      	mov	r0, r4
 80275b2:	4629      	mov	r1, r5
 80275b4:	f001 fad8 	bl	8028b68 <__aeabi_dmul>
 80275b8:	4652      	mov	r2, sl
 80275ba:	465b      	mov	r3, fp
 80275bc:	4604      	mov	r4, r0
 80275be:	460d      	mov	r5, r1
 80275c0:	4630      	mov	r0, r6
 80275c2:	4639      	mov	r1, r7
 80275c4:	f001 fad0 	bl	8028b68 <__aeabi_dmul>
 80275c8:	460b      	mov	r3, r1
 80275ca:	4602      	mov	r2, r0
 80275cc:	4629      	mov	r1, r5
 80275ce:	4620      	mov	r0, r4
 80275d0:	f001 f914 	bl	80287fc <__adddf3>
          for (j = 0; j < n2; j++) {
 80275d4:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80275d6:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 80275da:	f108 0810 	add.w	r8, r8, #16
 80275de:	4598      	cmp	r8, r3
 80275e0:	f109 0910 	add.w	r9, r9, #16
 80275e4:	d1c8      	bne.n	8027578 <cblas_ztrsm+0x1a78>
        for (i = 0; i < n1; i++) {
 80275e6:	9a00      	ldr	r2, [sp, #0]
 80275e8:	9903      	ldr	r1, [sp, #12]
 80275ea:	9b04      	ldr	r3, [sp, #16]
 80275ec:	440a      	add	r2, r1
 80275ee:	9200      	str	r2, [sp, #0]
 80275f0:	9a06      	ldr	r2, [sp, #24]
 80275f2:	3301      	adds	r3, #1
 80275f4:	429a      	cmp	r2, r3
 80275f6:	9304      	str	r3, [sp, #16]
 80275f8:	d1b4      	bne.n	8027564 <cblas_ztrsm+0x1a64>
 80275fa:	f7ff bad6 	b.w	8026baa <cblas_ztrsm+0x10aa>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80275fe:	ee1c 0a10 	vmov	r0, s24
 8027602:	f001 fa47 	bl	8028a94 <__aeabi_i2d>
 8027606:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8027608:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802760c:	f001 faac 	bl	8028b68 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8027610:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8027614:	4606      	mov	r6, r0
 8027616:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 8027618:	4620      	mov	r0, r4
 802761a:	4629      	mov	r1, r5
 802761c:	4632      	mov	r2, r6
 802761e:	463b      	mov	r3, r7
 8027620:	f7fe fa36 	bl	8025a90 <xhypot>
 8027624:	4680      	mov	r8, r0
 8027626:	4689      	mov	r9, r1
          const BASE a_real = Aii_real / s;
 8027628:	4620      	mov	r0, r4
 802762a:	4629      	mov	r1, r5
 802762c:	4642      	mov	r2, r8
 802762e:	464b      	mov	r3, r9
 8027630:	f001 fbc4 	bl	8028dbc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 8027634:	464b      	mov	r3, r9
          const BASE a_real = Aii_real / s;
 8027636:	4604      	mov	r4, r0
 8027638:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 802763a:	4642      	mov	r2, r8
 802763c:	4630      	mov	r0, r6
 802763e:	4639      	mov	r1, r7
 8027640:	f001 fbbc 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8027644:	9b02      	ldr	r3, [sp, #8]
 8027646:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 8027648:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 802764c:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8027650:	f77e ab93 	ble.w	8025d7a <cblas_ztrsm+0x27a>
 8027654:	9b08      	ldr	r3, [sp, #32]
 8027656:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8027658:	189a      	adds	r2, r3, r2
 802765a:	f103 0a08 	add.w	sl, r3, #8
 802765e:	9200      	str	r2, [sp, #0]
 8027660:	469b      	mov	fp, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8027662:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8027666:	ec51 0b19 	vmov	r0, r1, d9
 802766a:	4622      	mov	r2, r4
 802766c:	462b      	mov	r3, r5
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802766e:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8027672:	f001 fa79 	bl	8028b68 <__aeabi_dmul>
 8027676:	4632      	mov	r2, r6
 8027678:	ec41 0b1a 	vmov	d10, r0, r1
 802767c:	463b      	mov	r3, r7
 802767e:	ec51 0b18 	vmov	r0, r1, d8
 8027682:	f001 fa71 	bl	8028b68 <__aeabi_dmul>
 8027686:	4602      	mov	r2, r0
 8027688:	460b      	mov	r3, r1
 802768a:	ec51 0b1a 	vmov	r0, r1, d10
 802768e:	f001 f8b5 	bl	80287fc <__adddf3>
 8027692:	4642      	mov	r2, r8
 8027694:	464b      	mov	r3, r9
 8027696:	f001 fb91 	bl	8028dbc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802769a:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802769c:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80276a0:	463b      	mov	r3, r7
 80276a2:	ec51 0b19 	vmov	r0, r1, d9
 80276a6:	f001 fa5f 	bl	8028b68 <__aeabi_dmul>
 80276aa:	4622      	mov	r2, r4
 80276ac:	462b      	mov	r3, r5
 80276ae:	4604      	mov	r4, r0
 80276b0:	460d      	mov	r5, r1
 80276b2:	ec51 0b18 	vmov	r0, r1, d8
 80276b6:	f001 fa57 	bl	8028b68 <__aeabi_dmul>
 80276ba:	4602      	mov	r2, r0
 80276bc:	460b      	mov	r3, r1
 80276be:	4620      	mov	r0, r4
 80276c0:	4629      	mov	r1, r5
 80276c2:	f001 f899 	bl	80287f8 <__aeabi_dsub>
 80276c6:	464b      	mov	r3, r9
 80276c8:	4642      	mov	r2, r8
 80276ca:	f001 fb77 	bl	8028dbc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 80276ce:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80276d0:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j < n2; j++) {
 80276d4:	f10b 0b10 	add.w	fp, fp, #16
 80276d8:	459b      	cmp	fp, r3
 80276da:	f10a 0a10 	add.w	sl, sl, #16
 80276de:	d1c0      	bne.n	8027662 <cblas_ztrsm+0x1b62>
 80276e0:	f7fe bb4b 	b.w	8025d7a <cblas_ztrsm+0x27a>

080276e4 <xhypot>:
{
 80276e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 80276e6:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 80276ea:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  if (xabs < yabs) {
 80276ee:	4639      	mov	r1, r7
 80276f0:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 80276f2:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 80276f4:	4614      	mov	r4, r2
  if (xabs < yabs) {
 80276f6:	f001 fca9 	bl	802904c <__aeabi_dcmplt>
 80276fa:	b928      	cbnz	r0, 8027708 <xhypot+0x24>
 80276fc:	4632      	mov	r2, r6
 80276fe:	463b      	mov	r3, r7
    min = yabs ;
 8027700:	4626      	mov	r6, r4
 8027702:	462f      	mov	r7, r5
    max = xabs ;
 8027704:	4614      	mov	r4, r2
 8027706:	461d      	mov	r5, r3
  if (min == 0) 
 8027708:	2200      	movs	r2, #0
 802770a:	2300      	movs	r3, #0
 802770c:	4630      	mov	r0, r6
 802770e:	4639      	mov	r1, r7
 8027710:	f001 fc92 	bl	8029038 <__aeabi_dcmpeq>
 8027714:	b9c8      	cbnz	r0, 802774a <xhypot+0x66>
    double u = min / max ;
 8027716:	4622      	mov	r2, r4
 8027718:	462b      	mov	r3, r5
 802771a:	4630      	mov	r0, r6
 802771c:	4639      	mov	r1, r7
 802771e:	f001 fb4d 	bl	8028dbc <__aeabi_ddiv>
 8027722:	4602      	mov	r2, r0
 8027724:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 8027726:	f001 fa1f 	bl	8028b68 <__aeabi_dmul>
 802772a:	4b09      	ldr	r3, [pc, #36]	; (8027750 <xhypot+0x6c>)
 802772c:	2200      	movs	r2, #0
 802772e:	f001 f865 	bl	80287fc <__adddf3>
 8027732:	ec41 0b10 	vmov	d0, r0, r1
 8027736:	f009 fa6d 	bl	8030c14 <sqrt>
 802773a:	4620      	mov	r0, r4
 802773c:	4629      	mov	r1, r5
 802773e:	ec53 2b10 	vmov	r2, r3, d0
 8027742:	f001 fa11 	bl	8028b68 <__aeabi_dmul>
 8027746:	4604      	mov	r4, r0
 8027748:	460d      	mov	r5, r1
}
 802774a:	4620      	mov	r0, r4
 802774c:	4629      	mov	r1, r5
 802774e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027750:	3ff00000 	.word	0x3ff00000

08027754 <cblas_ztrsv>:
void
cblas_ztrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 8027754:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027758:	ed2d 8b08 	vpush	{d8-d11}
 802775c:	b099      	sub	sp, #100	; 0x64
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 802775e:	2a71      	cmp	r2, #113	; 0x71
 8027760:	930b      	str	r3, [sp, #44]	; 0x2c
 8027762:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8027764:	9305      	str	r3, [sp, #20]
 8027766:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8027768:	9310      	str	r3, [sp, #64]	; 0x40
 802776a:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 802776c:	930a      	str	r3, [sp, #40]	; 0x28
 802776e:	e9dd 542d 	ldrd	r5, r4, [sp, #180]	; 0xb4
 8027772:	4607      	mov	r7, r0
 8027774:	460e      	mov	r6, r1
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027776:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 802777a:	f000 81b9 	beq.w	8027af0 <cblas_ztrsv+0x39c>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 802777e:	2b01      	cmp	r3, #1
 8027780:	4690      	mov	r8, r2
 8027782:	d93f      	bls.n	8027804 <cblas_ztrsv+0xb0>
 8027784:	2002      	movs	r0, #2
 8027786:	3a6f      	subs	r2, #111	; 0x6f
 8027788:	2a02      	cmp	r2, #2
 802778a:	f04f 0301 	mov.w	r3, #1
 802778e:	bf88      	it	hi
 8027790:	2003      	movhi	r0, #3
 8027792:	930f      	str	r3, [sp, #60]	; 0x3c
 8027794:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027796:	337d      	adds	r3, #125	; 0x7d
 8027798:	b2db      	uxtb	r3, r3
 802779a:	2b01      	cmp	r3, #1
 802779c:	9b05      	ldr	r3, [sp, #20]
 802779e:	f240 8190 	bls.w	8027ac2 <cblas_ztrsv+0x36e>
 80277a2:	2b00      	cmp	r3, #0
 80277a4:	f2c0 8184 	blt.w	8027ab0 <cblas_ztrsv+0x35c>
 80277a8:	2b01      	cmp	r3, #1
 80277aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80277ac:	bfb8      	it	lt
 80277ae:	2301      	movlt	r3, #1
 80277b0:	4293      	cmp	r3, r2
 80277b2:	f340 828b 	ble.w	8027ccc <cblas_ztrsv+0x578>
 80277b6:	2c00      	cmp	r4, #0
 80277b8:	bf0c      	ite	eq
 80277ba:	2009      	moveq	r0, #9
 80277bc:	2007      	movne	r0, #7
 80277be:	4ac9      	ldr	r2, [pc, #804]	; (8027ae4 <cblas_ztrsv+0x390>)
 80277c0:	49c9      	ldr	r1, [pc, #804]	; (8027ae8 <cblas_ztrsv+0x394>)
 80277c2:	f000 ffa1 	bl	8028708 <cblas_xerbla>
  if (N == 0)
 80277c6:	9b05      	ldr	r3, [sp, #20]
 80277c8:	2b00      	cmp	r3, #0
 80277ca:	f000 816c 	beq.w	8027aa6 <cblas_ztrsv+0x352>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80277ce:	2f65      	cmp	r7, #101	; 0x65
 80277d0:	f000 8198 	beq.w	8027b04 <cblas_ztrsv+0x3b0>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80277d4:	2f66      	cmp	r7, #102	; 0x66
 80277d6:	d10b      	bne.n	80277f0 <cblas_ztrsv+0x9c>
 80277d8:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 80277dc:	d018      	beq.n	8027810 <cblas_ztrsv+0xbc>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80277de:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80277e2:	d105      	bne.n	80277f0 <cblas_ztrsv+0x9c>
 80277e4:	2e7a      	cmp	r6, #122	; 0x7a
 80277e6:	f000 833a 	beq.w	8027e5e <cblas_ztrsv+0x70a>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 80277ea:	2e79      	cmp	r6, #121	; 0x79
 80277ec:	f000 8198 	beq.w	8027b20 <cblas_ztrsv+0x3cc>
    BLAS_ERROR("unrecognized operation");
 80277f0:	4abe      	ldr	r2, [pc, #760]	; (8027aec <cblas_ztrsv+0x398>)
 80277f2:	49bd      	ldr	r1, [pc, #756]	; (8027ae8 <cblas_ztrsv+0x394>)
 80277f4:	2000      	movs	r0, #0
#define BASE double
#include "source_trsv_c.h"
#undef BASE
}
 80277f6:	b019      	add	sp, #100	; 0x64
 80277f8:	ecbd 8b08 	vpop	{d8-d11}
 80277fc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027800:	f000 bf82 	b.w	8028708 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027804:	3865      	subs	r0, #101	; 0x65
 8027806:	2801      	cmp	r0, #1
 8027808:	bf94      	ite	ls
 802780a:	2000      	movls	r0, #0
 802780c:	2001      	movhi	r0, #1
 802780e:	e7ba      	b.n	8027786 <cblas_ztrsv+0x32>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8027810:	2e7a      	cmp	r6, #122	; 0x7a
 8027812:	f040 8315 	bne.w	8027e40 <cblas_ztrsv+0x6ec>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8027816:	9b05      	ldr	r3, [sp, #20]
 8027818:	2c00      	cmp	r4, #0
 802781a:	f103 38ff 	add.w	r8, r3, #4294967295
    if (nonunit) {
 802781e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ix = OFFSET(N, incX) + incX * (N - 1);
 8027820:	bfd6      	itet	le
 8027822:	f1c4 0900 	rsble	r9, r4, #0
 8027826:	f04f 0900 	movgt.w	r9, #0
 802782a:	fb08 f909 	mulle.w	r9, r8, r9
    if (nonunit) {
 802782e:	2b83      	cmp	r3, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 8027830:	fb08 9904 	mla	r9, r8, r4, r9
    if (nonunit) {
 8027834:	d174      	bne.n	8027920 <cblas_ztrsv+0x1cc>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8027836:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8027838:	980f      	ldr	r0, [sp, #60]	; 0x3c
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 802783a:	fb08 8603 	mla	r6, r8, r3, r8
 802783e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027840:	eb03 1606 	add.w	r6, r3, r6, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8027844:	f001 f926 	bl	8028a94 <__aeabi_i2d>
 8027848:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 802784c:	f001 f98c 	bl	8028b68 <__aeabi_dmul>
      const BASE x_real = REAL(X, ix);
 8027850:	eb05 1709 	add.w	r7, r5, r9, lsl #4
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8027854:	e9d6 ab00 	ldrd	sl, fp, [r6]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8027858:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE x_real = REAL(X, ix);
 802785c:	9700      	str	r7, [sp, #0]
 802785e:	9f00      	ldr	r7, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8027860:	eb05 1609 	add.w	r6, r5, r9, lsl #4
      const BASE s = xhypot(a_real, a_imag);
 8027864:	ec53 2b1a 	vmov	r2, r3, d10
      const BASE x_imag = IMAG(X, ix);
 8027868:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 802786a:	4650      	mov	r0, sl
 802786c:	4659      	mov	r1, fp
      const BASE x_real = REAL(X, ix);
 802786e:	ed97 9b00 	vldr	d9, [r7]
      const BASE x_imag = IMAG(X, ix);
 8027872:	ed96 8b00 	vldr	d8, [r6]
 8027876:	9602      	str	r6, [sp, #8]
      const BASE s = xhypot(a_real, a_imag);
 8027878:	f7ff ff34 	bl	80276e4 <xhypot>
 802787c:	ec41 0b1b 	vmov	d11, r0, r1
      const BASE b_real = a_real / s;
 8027880:	4650      	mov	r0, sl
 8027882:	ec53 2b1b 	vmov	r2, r3, d11
 8027886:	4659      	mov	r1, fp
 8027888:	f001 fa98 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 802788c:	ec53 2b1b 	vmov	r2, r3, d11
      const BASE b_real = a_real / s;
 8027890:	4682      	mov	sl, r0
 8027892:	468b      	mov	fp, r1
      const BASE b_imag = a_imag / s;
 8027894:	ec51 0b1a 	vmov	r0, r1, d10
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8027898:	eeb0 aa49 	vmov.f32	s20, s18
 802789c:	eef0 aa69 	vmov.f32	s21, s19
      const BASE b_imag = a_imag / s;
 80278a0:	f001 fa8c 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 80278a4:	4656      	mov	r6, sl
 80278a6:	465f      	mov	r7, fp
      const BASE b_imag = a_imag / s;
 80278a8:	4682      	mov	sl, r0
 80278aa:	468b      	mov	fp, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80278ac:	4632      	mov	r2, r6
 80278ae:	463b      	mov	r3, r7
 80278b0:	ec51 0b19 	vmov	r0, r1, d9
 80278b4:	f001 f958 	bl	8028b68 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 80278b8:	ec4b ab19 	vmov	d9, sl, fp
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80278bc:	4682      	mov	sl, r0
 80278be:	ec53 2b19 	vmov	r2, r3, d9
 80278c2:	468b      	mov	fp, r1
 80278c4:	ec51 0b18 	vmov	r0, r1, d8
 80278c8:	f001 f94e 	bl	8028b68 <__aeabi_dmul>
 80278cc:	4602      	mov	r2, r0
 80278ce:	460b      	mov	r3, r1
 80278d0:	4650      	mov	r0, sl
 80278d2:	4659      	mov	r1, fp
 80278d4:	f000 ff92 	bl	80287fc <__adddf3>
 80278d8:	ec53 2b1b 	vmov	r2, r3, d11
 80278dc:	f001 fa6e 	bl	8028dbc <__aeabi_ddiv>
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80278e0:	463b      	mov	r3, r7
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80278e2:	9f00      	ldr	r7, [sp, #0]
 80278e4:	4682      	mov	sl, r0
 80278e6:	468b      	mov	fp, r1
 80278e8:	e9c7 ab00 	strd	sl, fp, [r7]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80278ec:	4632      	mov	r2, r6
 80278ee:	ec51 0b18 	vmov	r0, r1, d8
 80278f2:	f001 f939 	bl	8028b68 <__aeabi_dmul>
 80278f6:	ec53 2b19 	vmov	r2, r3, d9
 80278fa:	4682      	mov	sl, r0
 80278fc:	468b      	mov	fp, r1
 80278fe:	ec51 0b1a 	vmov	r0, r1, d10
 8027902:	f001 f931 	bl	8028b68 <__aeabi_dmul>
 8027906:	4602      	mov	r2, r0
 8027908:	460b      	mov	r3, r1
 802790a:	4650      	mov	r0, sl
 802790c:	4659      	mov	r1, fp
 802790e:	f000 ff73 	bl	80287f8 <__aeabi_dsub>
 8027912:	ec53 2b1b 	vmov	r2, r3, d11
 8027916:	f001 fa51 	bl	8028dbc <__aeabi_ddiv>
 802791a:	9e02      	ldr	r6, [sp, #8]
 802791c:	e9c6 0100 	strd	r0, r1, [r6]
    for (i = N - 1; i > 0 && i--;) {
 8027920:	f1b8 0f00 	cmp.w	r8, #0
    ix -= incX;
 8027924:	eba9 0c04 	sub.w	ip, r9, r4
    for (i = N - 1; i > 0 && i--;) {
 8027928:	f340 80bd 	ble.w	8027aa6 <cblas_ztrsv+0x352>
 802792c:	990a      	ldr	r1, [sp, #40]	; 0x28
 802792e:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 8027932:	f108 33ff 	add.w	r3, r8, #4294967295
 8027936:	fb01 f703 	mul.w	r7, r1, r3
 802793a:	4640      	mov	r0, r8
 802793c:	fb01 3303 	mla	r3, r1, r3, r3
 8027940:	183a      	adds	r2, r7, r0
 8027942:	011b      	lsls	r3, r3, #4
 8027944:	9805      	ldr	r0, [sp, #20]
 8027946:	9313      	str	r3, [sp, #76]	; 0x4c
 8027948:	eb05 1c0c 	add.w	ip, r5, ip, lsl #4
 802794c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802794e:	4407      	add	r7, r0
 8027950:	43cd      	mvns	r5, r1
 8027952:	ebc1 7001 	rsb	r0, r1, r1, lsl #28
 8027956:	f10c 0108 	add.w	r1, ip, #8
 802795a:	ebc2 7602 	rsb	r6, r2, r2, lsl #28
 802795e:	910a      	str	r1, [sp, #40]	; 0x28
 8027960:	eb03 1107 	add.w	r1, r3, r7, lsl #4
 8027964:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8027968:	930c      	str	r3, [sp, #48]	; 0x30
 802796a:	0133      	lsls	r3, r6, #4
 802796c:	9314      	str	r3, [sp, #80]	; 0x50
 802796e:	012b      	lsls	r3, r5, #4
 8027970:	ebc4 7e04 	rsb	lr, r4, r4, lsl #28
 8027974:	930e      	str	r3, [sp, #56]	; 0x38
 8027976:	0103      	lsls	r3, r0, #4
 8027978:	0124      	lsls	r4, r4, #4
 802797a:	9310      	str	r3, [sp, #64]	; 0x40
 802797c:	ea4f 130e 	mov.w	r3, lr, lsl #4
 8027980:	9311      	str	r3, [sp, #68]	; 0x44
 8027982:	f1a4 0308 	sub.w	r3, r4, #8
 8027986:	9408      	str	r4, [sp, #32]
 8027988:	9106      	str	r1, [sp, #24]
 802798a:	9312      	str	r3, [sp, #72]	; 0x48
      BASE tmp_real = REAL(X, ix);
 802798c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      for (j = i + 1; j < N; j++) {
 802798e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
      BASE tmp_real = REAL(X, ix);
 8027990:	ed13 7b02 	vldr	d7, [r3, #-8]
 8027994:	ed8d 7b00 	vstr	d7, [sp]
      BASE tmp_imag = IMAG(X, ix);
 8027998:	ed93 7b00 	vldr	d7, [r3]
      for (j = i + 1; j < N; j++) {
 802799c:	9b05      	ldr	r3, [sp, #20]
 802799e:	4293      	cmp	r3, r2
      BASE tmp_imag = IMAG(X, ix);
 80279a0:	ed8d 7b02 	vstr	d7, [sp, #8]
      for (j = i + 1; j < N; j++) {
 80279a4:	dd61      	ble.n	8027a6a <cblas_ztrsv+0x316>
 80279a6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80279a8:	f001 f874 	bl	8028a94 <__aeabi_i2d>
 80279ac:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80279ae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80279b0:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80279b2:	ec41 0b1a 	vmov	d10, r0, r1
 80279b6:	189d      	adds	r5, r3, r2
 80279b8:	4626      	mov	r6, r4
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 80279ba:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80279be:	ec51 0b1a 	vmov	r0, r1, d10
 80279c2:	f001 f8d1 	bl	8028b68 <__aeabi_dmul>
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 80279c6:	ed96 7b00 	vldr	d7, [r6]
        const BASE x_real = REAL(X, jx);
 80279ca:	ed95 6b00 	vldr	d6, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 80279ce:	eeb0 9a47 	vmov.f32	s18, s14
 80279d2:	eef0 9a67 	vmov.f32	s19, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80279d6:	ec53 2b16 	vmov	r2, r3, d6
        const BASE x_real = REAL(X, jx);
 80279da:	eeb0 8a46 	vmov.f32	s16, s12
 80279de:	eef0 8a66 	vmov.f32	s17, s13
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 80279e2:	4682      	mov	sl, r0
 80279e4:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80279e6:	ec51 0b17 	vmov	r0, r1, d7
 80279ea:	f001 f8bd 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 80279ee:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80279f2:	4604      	mov	r4, r0
        const BASE x_real = REAL(X, jx);
 80279f4:	462f      	mov	r7, r5
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80279f6:	4642      	mov	r2, r8
 80279f8:	460d      	mov	r5, r1
 80279fa:	464b      	mov	r3, r9
 80279fc:	4650      	mov	r0, sl
 80279fe:	4659      	mov	r1, fp
 8027a00:	f001 f8b2 	bl	8028b68 <__aeabi_dmul>
 8027a04:	4602      	mov	r2, r0
 8027a06:	460b      	mov	r3, r1
 8027a08:	4620      	mov	r0, r4
 8027a0a:	4629      	mov	r1, r5
 8027a0c:	f000 fef4 	bl	80287f8 <__aeabi_dsub>
 8027a10:	4602      	mov	r2, r0
 8027a12:	460b      	mov	r3, r1
 8027a14:	e9dd 0100 	ldrd	r0, r1, [sp]
 8027a18:	f000 feee 	bl	80287f8 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027a1c:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027a1e:	4604      	mov	r4, r0
 8027a20:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027a22:	464b      	mov	r3, r9
 8027a24:	ec51 0b19 	vmov	r0, r1, d9
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027a28:	e9cd 4500 	strd	r4, r5, [sp]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027a2c:	f001 f89c 	bl	8028b68 <__aeabi_dmul>
 8027a30:	ec53 2b18 	vmov	r2, r3, d8
 8027a34:	460d      	mov	r5, r1
 8027a36:	4604      	mov	r4, r0
 8027a38:	4659      	mov	r1, fp
 8027a3a:	4650      	mov	r0, sl
 8027a3c:	f001 f894 	bl	8028b68 <__aeabi_dmul>
 8027a40:	4602      	mov	r2, r0
 8027a42:	460b      	mov	r3, r1
 8027a44:	4620      	mov	r0, r4
 8027a46:	4629      	mov	r1, r5
 8027a48:	f000 fed8 	bl	80287fc <__adddf3>
 8027a4c:	460b      	mov	r3, r1
 8027a4e:	4602      	mov	r2, r0
 8027a50:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8027a54:	f000 fed0 	bl	80287f8 <__aeabi_dsub>
 8027a58:	9b08      	ldr	r3, [sp, #32]
 8027a5a:	18fb      	adds	r3, r7, r3
 8027a5c:	461d      	mov	r5, r3
      for (j = i + 1; j < N; j++) {
 8027a5e:	9b06      	ldr	r3, [sp, #24]
 8027a60:	3610      	adds	r6, #16
 8027a62:	42b3      	cmp	r3, r6
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027a64:	e9cd 0102 	strd	r0, r1, [sp, #8]
      for (j = i + 1; j < N; j++) {
 8027a68:	d1a7      	bne.n	80279ba <cblas_ztrsv+0x266>
      if (nonunit) {
 8027a6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027a6c:	2b83      	cmp	r3, #131	; 0x83
 8027a6e:	f000 82ab 	beq.w	8027fc8 <cblas_ztrsv+0x874>
        REAL(X, ix) = tmp_real;
 8027a72:	ed9d 7b00 	vldr	d7, [sp]
 8027a76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027a78:	ed03 7b02 	vstr	d7, [r3, #-8]
        IMAG(X, ix) = tmp_imag;
 8027a7c:	ed9d 7b02 	vldr	d7, [sp, #8]
 8027a80:	ed83 7b00 	vstr	d7, [r3]
    for (i = N - 1; i > 0 && i--;) {
 8027a84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027a86:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027a88:	4413      	add	r3, r2
 8027a8a:	930c      	str	r3, [sp, #48]	; 0x30
 8027a8c:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8027a8e:	9b06      	ldr	r3, [sp, #24]
 8027a90:	4413      	add	r3, r2
 8027a92:	9306      	str	r3, [sp, #24]
 8027a94:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8027a96:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027a98:	4413      	add	r3, r2
 8027a9a:	930a      	str	r3, [sp, #40]	; 0x28
 8027a9c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8027a9e:	3b01      	subs	r3, #1
 8027aa0:	930d      	str	r3, [sp, #52]	; 0x34
 8027aa2:	f47f af73 	bne.w	802798c <cblas_ztrsv+0x238>
 8027aa6:	b019      	add	sp, #100	; 0x64
 8027aa8:	ecbd 8b08 	vpop	{d8-d11}
 8027aac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027ab0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027ab2:	2b00      	cmp	r3, #0
 8027ab4:	f77f ae7f 	ble.w	80277b6 <cblas_ztrsv+0x62>
 8027ab8:	2c00      	cmp	r4, #0
 8027aba:	bf0c      	ite	eq
 8027abc:	2009      	moveq	r0, #9
 8027abe:	2005      	movne	r0, #5
 8027ac0:	e67d      	b.n	80277be <cblas_ztrsv+0x6a>
 8027ac2:	2b00      	cmp	r3, #0
 8027ac4:	dbf4      	blt.n	8027ab0 <cblas_ztrsv+0x35c>
 8027ac6:	9b05      	ldr	r3, [sp, #20]
 8027ac8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027aca:	2b01      	cmp	r3, #1
 8027acc:	bfb8      	it	lt
 8027ace:	2301      	movlt	r3, #1
 8027ad0:	4293      	cmp	r3, r2
 8027ad2:	f73f ae70 	bgt.w	80277b6 <cblas_ztrsv+0x62>
 8027ad6:	2c00      	cmp	r4, #0
 8027ad8:	f000 83f4 	beq.w	80282c4 <cblas_ztrsv+0xb70>
 8027adc:	2800      	cmp	r0, #0
 8027ade:	f43f ae72 	beq.w	80277c6 <cblas_ztrsv+0x72>
 8027ae2:	e66c      	b.n	80277be <cblas_ztrsv+0x6a>
 8027ae4:	08031108 	.word	0x08031108
 8027ae8:	080313c4 	.word	0x080313c4
 8027aec:	080311b8 	.word	0x080311b8
 8027af0:	2b01      	cmp	r3, #1
 8027af2:	f240 81a9 	bls.w	8027e48 <cblas_ztrsv+0x6f4>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8027af6:	f04f 33ff 	mov.w	r3, #4294967295
 8027afa:	930f      	str	r3, [sp, #60]	; 0x3c
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027afc:	f04f 0870 	mov.w	r8, #112	; 0x70
 8027b00:	2002      	movs	r0, #2
 8027b02:	e647      	b.n	8027794 <cblas_ztrsv+0x40>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8027b04:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8027b08:	f000 80e5 	beq.w	8027cd6 <cblas_ztrsv+0x582>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8027b0c:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8027b10:	f47f ae6e 	bne.w	80277f0 <cblas_ztrsv+0x9c>
 8027b14:	2e79      	cmp	r6, #121	; 0x79
 8027b16:	f000 81a2 	beq.w	8027e5e <cblas_ztrsv+0x70a>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8027b1a:	2e7a      	cmp	r6, #122	; 0x7a
 8027b1c:	f47f ae68 	bne.w	80277f0 <cblas_ztrsv+0x9c>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8027b20:	9b05      	ldr	r3, [sp, #20]
 8027b22:	2c00      	cmp	r4, #0
 8027b24:	f103 33ff 	add.w	r3, r3, #4294967295
 8027b28:	bfd8      	it	le
 8027b2a:	f1c4 0a00 	rsble	sl, r4, #0
 8027b2e:	9312      	str	r3, [sp, #72]	; 0x48
 8027b30:	bfd8      	it	le
 8027b32:	fb03 fa0a 	mulle.w	sl, r3, sl
 8027b36:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8027b38:	bfc8      	it	gt
 8027b3a:	f04f 0a00 	movgt.w	sl, #0
 8027b3e:	fb03 aa04 	mla	sl, r3, r4, sl
    if (nonunit) {
 8027b42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027b44:	2b83      	cmp	r3, #131	; 0x83
 8027b46:	f000 83d0 	beq.w	80282ea <cblas_ztrsv+0xb96>
    for (i = N - 1; i > 0 && i--;) {
 8027b4a:	9812      	ldr	r0, [sp, #72]	; 0x48
 8027b4c:	2800      	cmp	r0, #0
    ix -= incX;
 8027b4e:	ebaa 0a04 	sub.w	sl, sl, r4
    for (i = N - 1; i > 0 && i--;) {
 8027b52:	dda8      	ble.n	8027aa6 <cblas_ztrsv+0x352>
 8027b54:	990a      	ldr	r1, [sp, #40]	; 0x28
 8027b56:	4602      	mov	r2, r0
 8027b58:	1c4b      	adds	r3, r1, #1
 8027b5a:	fb03 f202 	mul.w	r2, r3, r2
 8027b5e:	ebc2 7202 	rsb	r2, r2, r2, lsl #28
 8027b62:	0112      	lsls	r2, r2, #4
 8027b64:	9217      	str	r2, [sp, #92]	; 0x5c
 8027b66:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8027b68:	011b      	lsls	r3, r3, #4
 8027b6a:	eb05 1a0a 	add.w	sl, r5, sl, lsl #4
 8027b6e:	4605      	mov	r5, r0
 8027b70:	1e46      	subs	r6, r0, #1
 8027b72:	fb05 2203 	mla	r2, r5, r3, r2
 8027b76:	ebc4 7004 	rsb	r0, r4, r4, lsl #28
 8027b7a:	9210      	str	r2, [sp, #64]	; 0x40
 8027b7c:	f1a3 0210 	sub.w	r2, r3, #16
 8027b80:	fb03 f306 	mul.w	r3, r3, r6
 8027b84:	0124      	lsls	r4, r4, #4
 8027b86:	43c9      	mvns	r1, r1
 8027b88:	9316      	str	r3, [sp, #88]	; 0x58
 8027b8a:	0103      	lsls	r3, r0, #4
 8027b8c:	f10a 0708 	add.w	r7, sl, #8
 8027b90:	0109      	lsls	r1, r1, #4
 8027b92:	9314      	str	r3, [sp, #80]	; 0x50
 8027b94:	f1a4 0308 	sub.w	r3, r4, #8
 8027b98:	9611      	str	r6, [sp, #68]	; 0x44
 8027b9a:	940c      	str	r4, [sp, #48]	; 0x30
 8027b9c:	970e      	str	r7, [sp, #56]	; 0x38
 8027b9e:	9113      	str	r1, [sp, #76]	; 0x4c
 8027ba0:	920d      	str	r2, [sp, #52]	; 0x34
 8027ba2:	9315      	str	r3, [sp, #84]	; 0x54
      BASE tmp_real = REAL(X, ix);
 8027ba4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027ba6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    for (i = N - 1; i > 0 && i--;) {
 8027ba8:	9911      	ldr	r1, [sp, #68]	; 0x44
 8027baa:	930a      	str	r3, [sp, #40]	; 0x28
      BASE tmp_real = REAL(X, ix);
 8027bac:	ed12 7b02 	vldr	d7, [r2, #-8]
 8027bb0:	ed8d 7b06 	vstr	d7, [sp, #24]
      BASE tmp_imag = IMAG(X, ix);
 8027bb4:	ed92 7b00 	vldr	d7, [r2]
      for (j = i + 1; j < N; j++) {
 8027bb8:	9a05      	ldr	r2, [sp, #20]
    for (i = N - 1; i > 0 && i--;) {
 8027bba:	9112      	str	r1, [sp, #72]	; 0x48
      for (j = i + 1; j < N; j++) {
 8027bbc:	429a      	cmp	r2, r3
      BASE tmp_imag = IMAG(X, ix);
 8027bbe:	ed8d 7b08 	vstr	d7, [sp, #32]
      for (j = i + 1; j < N; j++) {
 8027bc2:	dd67      	ble.n	8027c94 <cblas_ztrsv+0x540>
 8027bc4:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027bc6:	f000 ff65 	bl	8028a94 <__aeabi_i2d>
 8027bca:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8027bcc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027bce:	4413      	add	r3, r2
 8027bd0:	9300      	str	r3, [sp, #0]
 8027bd2:	ec41 0b19 	vmov	d9, r0, r1
 8027bd6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027bd8:	9302      	str	r3, [sp, #8]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8027bda:	9c02      	ldr	r4, [sp, #8]
 8027bdc:	ec51 0b19 	vmov	r0, r1, d9
 8027be0:	e954 2302 	ldrd	r2, r3, [r4, #-8]
 8027be4:	f000 ffc0 	bl	8028b68 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 8027be8:	9d00      	ldr	r5, [sp, #0]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8027bea:	9402      	str	r4, [sp, #8]
        const BASE x_real = REAL(X, jx);
 8027bec:	ed95 7b00 	vldr	d7, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8027bf0:	e954 6704 	ldrd	r6, r7, [r4, #-16]
        const BASE x_real = REAL(X, jx);
 8027bf4:	eeb0 8a47 	vmov.f32	s16, s14
 8027bf8:	eef0 8a67 	vmov.f32	s17, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027bfc:	ec53 2b17 	vmov	r2, r3, d7
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8027c00:	4682      	mov	sl, r0
 8027c02:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027c04:	4630      	mov	r0, r6
 8027c06:	4639      	mov	r1, r7
 8027c08:	f000 ffae 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8027c0c:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027c10:	4604      	mov	r4, r0
 8027c12:	460d      	mov	r5, r1
 8027c14:	4642      	mov	r2, r8
 8027c16:	464b      	mov	r3, r9
 8027c18:	4650      	mov	r0, sl
 8027c1a:	4659      	mov	r1, fp
 8027c1c:	f000 ffa4 	bl	8028b68 <__aeabi_dmul>
 8027c20:	4602      	mov	r2, r0
 8027c22:	460b      	mov	r3, r1
 8027c24:	4620      	mov	r0, r4
 8027c26:	4629      	mov	r1, r5
 8027c28:	f000 fde6 	bl	80287f8 <__aeabi_dsub>
 8027c2c:	4602      	mov	r2, r0
 8027c2e:	460b      	mov	r3, r1
 8027c30:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8027c34:	f000 fde0 	bl	80287f8 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027c38:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027c3a:	4604      	mov	r4, r0
 8027c3c:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027c3e:	464b      	mov	r3, r9
 8027c40:	4630      	mov	r0, r6
 8027c42:	4639      	mov	r1, r7
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027c44:	e9cd 4506 	strd	r4, r5, [sp, #24]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027c48:	f000 ff8e 	bl	8028b68 <__aeabi_dmul>
 8027c4c:	ec53 2b18 	vmov	r2, r3, d8
 8027c50:	4604      	mov	r4, r0
 8027c52:	460d      	mov	r5, r1
 8027c54:	4650      	mov	r0, sl
 8027c56:	4659      	mov	r1, fp
 8027c58:	f000 ff86 	bl	8028b68 <__aeabi_dmul>
 8027c5c:	4602      	mov	r2, r0
 8027c5e:	460b      	mov	r3, r1
 8027c60:	4620      	mov	r0, r4
 8027c62:	4629      	mov	r1, r5
 8027c64:	f000 fdca 	bl	80287fc <__adddf3>
 8027c68:	4602      	mov	r2, r0
 8027c6a:	460b      	mov	r3, r1
 8027c6c:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8027c70:	f000 fdc2 	bl	80287f8 <__aeabi_dsub>
 8027c74:	9b02      	ldr	r3, [sp, #8]
 8027c76:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8027c78:	9d00      	ldr	r5, [sp, #0]
      for (j = i + 1; j < N; j++) {
 8027c7a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027c7c:	4423      	add	r3, r4
 8027c7e:	9302      	str	r3, [sp, #8]
 8027c80:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027c82:	18eb      	adds	r3, r5, r3
 8027c84:	9300      	str	r3, [sp, #0]
 8027c86:	9b05      	ldr	r3, [sp, #20]
 8027c88:	3201      	adds	r2, #1
 8027c8a:	4293      	cmp	r3, r2
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027c8c:	e9cd 0108 	strd	r0, r1, [sp, #32]
      for (j = i + 1; j < N; j++) {
 8027c90:	920a      	str	r2, [sp, #40]	; 0x28
 8027c92:	d1a2      	bne.n	8027bda <cblas_ztrsv+0x486>
      if (nonunit) {
 8027c94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027c96:	2b83      	cmp	r3, #131	; 0x83
 8027c98:	f000 81f8 	beq.w	802808c <cblas_ztrsv+0x938>
        REAL(X, ix) = tmp_real;
 8027c9c:	ed9d 7b06 	vldr	d7, [sp, #24]
 8027ca0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027ca2:	ed03 7b02 	vstr	d7, [r3, #-8]
        IMAG(X, ix) = tmp_imag;
 8027ca6:	ed9d 7b08 	vldr	d7, [sp, #32]
 8027caa:	ed83 7b00 	vstr	d7, [r3]
    for (i = N - 1; i > 0 && i--;) {
 8027cae:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027cb0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8027cb2:	4413      	add	r3, r2
 8027cb4:	9310      	str	r3, [sp, #64]	; 0x40
 8027cb6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8027cb8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027cba:	4413      	add	r3, r2
 8027cbc:	930e      	str	r3, [sp, #56]	; 0x38
 8027cbe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8027cc0:	2b00      	cmp	r3, #0
 8027cc2:	f43f aef0 	beq.w	8027aa6 <cblas_ztrsv+0x352>
 8027cc6:	3b01      	subs	r3, #1
 8027cc8:	9311      	str	r3, [sp, #68]	; 0x44
 8027cca:	e76b      	b.n	8027ba4 <cblas_ztrsv+0x450>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027ccc:	2c00      	cmp	r4, #0
 8027cce:	bf0c      	ite	eq
 8027cd0:	2009      	moveq	r0, #9
 8027cd2:	2004      	movne	r0, #4
 8027cd4:	e573      	b.n	80277be <cblas_ztrsv+0x6a>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8027cd6:	2e79      	cmp	r6, #121	; 0x79
 8027cd8:	f43f ad9d 	beq.w	8027816 <cblas_ztrsv+0xc2>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 8027cdc:	2e7a      	cmp	r6, #122	; 0x7a
 8027cde:	f47f ad87 	bne.w	80277f0 <cblas_ztrsv+0x9c>
    ix = OFFSET(N, incX);
 8027ce2:	2c00      	cmp	r4, #0
 8027ce4:	f340 82f1 	ble.w	80282ca <cblas_ztrsv+0xb76>
 8027ce8:	46a3      	mov	fp, r4
 8027cea:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 8027cee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027cf0:	2b83      	cmp	r3, #131	; 0x83
 8027cf2:	f000 836b 	beq.w	80283cc <cblas_ztrsv+0xc78>
    for (i = 1; i < N; i++) {
 8027cf6:	9b05      	ldr	r3, [sp, #20]
 8027cf8:	2b01      	cmp	r3, #1
 8027cfa:	f77f aed4 	ble.w	8027aa6 <cblas_ztrsv+0x352>
 8027cfe:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027d00:	f000 fec8 	bl	8028a94 <__aeabi_i2d>
 8027d04:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027d06:	920d      	str	r2, [sp, #52]	; 0x34
 8027d08:	ec41 0b1a 	vmov	d10, r0, r1
 8027d0c:	0121      	lsls	r1, r4, #4
 8027d0e:	9108      	str	r1, [sp, #32]
 8027d10:	eb05 110b 	add.w	r1, r5, fp, lsl #4
 8027d14:	1c53      	adds	r3, r2, #1
 8027d16:	910c      	str	r1, [sp, #48]	; 0x30
 8027d18:	eb05 110a 	add.w	r1, r5, sl, lsl #4
 8027d1c:	9111      	str	r1, [sp, #68]	; 0x44
 8027d1e:	0119      	lsls	r1, r3, #4
 8027d20:	910f      	str	r1, [sp, #60]	; 0x3c
 8027d22:	9910      	ldr	r1, [sp, #64]	; 0x40
 8027d24:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 8027d28:	9306      	str	r3, [sp, #24]
 8027d2a:	2301      	movs	r3, #1
 8027d2c:	930e      	str	r3, [sp, #56]	; 0x38
      BASE tmp_real = REAL(X, ix);
 8027d2e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027d30:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8027d32:	ed93 7b00 	vldr	d7, [r3]
 8027d36:	ed8d 7b00 	vstr	d7, [sp]
      BASE tmp_imag = IMAG(X, ix);
 8027d3a:	ed93 7b02 	vldr	d7, [r3, #8]
 8027d3e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027d40:	ed8d 7b02 	vstr	d7, [sp, #8]
      for (j = 0; j < i; j++) {
 8027d44:	eb03 1402 	add.w	r4, r3, r2, lsl #4
      BASE tmp_imag = IMAG(X, ix);
 8027d48:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8027d4a:	4626      	mov	r6, r4
 8027d4c:	461d      	mov	r5, r3
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8027d4e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8027d52:	ec51 0b1a 	vmov	r0, r1, d10
 8027d56:	f000 ff07 	bl	8028b68 <__aeabi_dmul>
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8027d5a:	ed96 7b00 	vldr	d7, [r6]
        const BASE x_real = REAL(X, jx);
 8027d5e:	ed95 6b00 	vldr	d6, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8027d62:	eeb0 9a47 	vmov.f32	s18, s14
 8027d66:	eef0 9a67 	vmov.f32	s19, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027d6a:	ec53 2b16 	vmov	r2, r3, d6
        const BASE x_real = REAL(X, jx);
 8027d6e:	eeb0 8a46 	vmov.f32	s16, s12
 8027d72:	eef0 8a66 	vmov.f32	s17, s13
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8027d76:	4682      	mov	sl, r0
 8027d78:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027d7a:	ec51 0b17 	vmov	r0, r1, d7
 8027d7e:	f000 fef3 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8027d82:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027d86:	4604      	mov	r4, r0
        const BASE x_real = REAL(X, jx);
 8027d88:	462f      	mov	r7, r5
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027d8a:	4642      	mov	r2, r8
 8027d8c:	460d      	mov	r5, r1
 8027d8e:	464b      	mov	r3, r9
 8027d90:	4650      	mov	r0, sl
 8027d92:	4659      	mov	r1, fp
 8027d94:	f000 fee8 	bl	8028b68 <__aeabi_dmul>
 8027d98:	4602      	mov	r2, r0
 8027d9a:	460b      	mov	r3, r1
 8027d9c:	4620      	mov	r0, r4
 8027d9e:	4629      	mov	r1, r5
 8027da0:	f000 fd2a 	bl	80287f8 <__aeabi_dsub>
 8027da4:	4602      	mov	r2, r0
 8027da6:	460b      	mov	r3, r1
 8027da8:	e9dd 0100 	ldrd	r0, r1, [sp]
 8027dac:	f000 fd24 	bl	80287f8 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027db0:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027db2:	4604      	mov	r4, r0
 8027db4:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027db6:	464b      	mov	r3, r9
 8027db8:	ec51 0b19 	vmov	r0, r1, d9
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027dbc:	e9cd 4500 	strd	r4, r5, [sp]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027dc0:	f000 fed2 	bl	8028b68 <__aeabi_dmul>
 8027dc4:	ec53 2b18 	vmov	r2, r3, d8
 8027dc8:	460d      	mov	r5, r1
 8027dca:	4604      	mov	r4, r0
 8027dcc:	4659      	mov	r1, fp
 8027dce:	4650      	mov	r0, sl
 8027dd0:	f000 feca 	bl	8028b68 <__aeabi_dmul>
 8027dd4:	4602      	mov	r2, r0
 8027dd6:	460b      	mov	r3, r1
 8027dd8:	4620      	mov	r0, r4
 8027dda:	4629      	mov	r1, r5
 8027ddc:	f000 fd0e 	bl	80287fc <__adddf3>
 8027de0:	460b      	mov	r3, r1
 8027de2:	4602      	mov	r2, r0
 8027de4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8027de8:	f000 fd06 	bl	80287f8 <__aeabi_dsub>
 8027dec:	9b08      	ldr	r3, [sp, #32]
 8027dee:	18fb      	adds	r3, r7, r3
 8027df0:	461d      	mov	r5, r3
      for (j = 0; j < i; j++) {
 8027df2:	9b06      	ldr	r3, [sp, #24]
 8027df4:	3610      	adds	r6, #16
 8027df6:	42b3      	cmp	r3, r6
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027df8:	e9cd 0102 	strd	r0, r1, [sp, #8]
      for (j = 0; j < i; j++) {
 8027dfc:	d1a7      	bne.n	8027d4e <cblas_ztrsv+0x5fa>
      if (nonunit) {
 8027dfe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027e00:	2b83      	cmp	r3, #131	; 0x83
 8027e02:	f000 81a5 	beq.w	8028150 <cblas_ztrsv+0x9fc>
        REAL(X, ix) = tmp_real;
 8027e06:	ed9d 7b00 	vldr	d7, [sp]
 8027e0a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027e0c:	ed83 7b00 	vstr	d7, [r3]
        IMAG(X, ix) = tmp_imag;
 8027e10:	ed9d 7b02 	vldr	d7, [sp, #8]
 8027e14:	ed83 7b02 	vstr	d7, [r3, #8]
    for (i = 1; i < N; i++) {
 8027e18:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8027e1a:	9908      	ldr	r1, [sp, #32]
 8027e1c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027e1e:	440a      	add	r2, r1
 8027e20:	920c      	str	r2, [sp, #48]	; 0x30
 8027e22:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8027e24:	9a06      	ldr	r2, [sp, #24]
 8027e26:	440a      	add	r2, r1
 8027e28:	9206      	str	r2, [sp, #24]
 8027e2a:	990a      	ldr	r1, [sp, #40]	; 0x28
 8027e2c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8027e2e:	440a      	add	r2, r1
 8027e30:	920d      	str	r2, [sp, #52]	; 0x34
 8027e32:	9a05      	ldr	r2, [sp, #20]
 8027e34:	3301      	adds	r3, #1
 8027e36:	429a      	cmp	r2, r3
 8027e38:	930e      	str	r3, [sp, #56]	; 0x38
 8027e3a:	f47f af78 	bne.w	8027d2e <cblas_ztrsv+0x5da>
 8027e3e:	e632      	b.n	8027aa6 <cblas_ztrsv+0x352>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 8027e40:	2e79      	cmp	r6, #121	; 0x79
 8027e42:	f47f acd5 	bne.w	80277f0 <cblas_ztrsv+0x9c>
 8027e46:	e74c      	b.n	8027ce2 <cblas_ztrsv+0x58e>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027e48:	3865      	subs	r0, #101	; 0x65
 8027e4a:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8027e4c:	f04f 33ff 	mov.w	r3, #4294967295
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027e50:	bf94      	ite	ls
 8027e52:	2000      	movls	r0, #0
 8027e54:	2001      	movhi	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8027e56:	930f      	str	r3, [sp, #60]	; 0x3c
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027e58:	f04f 0870 	mov.w	r8, #112	; 0x70
 8027e5c:	e49a      	b.n	8027794 <cblas_ztrsv+0x40>
    ix = OFFSET(N, incX);
 8027e5e:	2c00      	cmp	r4, #0
 8027e60:	f340 823b 	ble.w	80282da <cblas_ztrsv+0xb86>
 8027e64:	46a3      	mov	fp, r4
 8027e66:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 8027e6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027e6c:	2b83      	cmp	r3, #131	; 0x83
 8027e6e:	f000 831a 	beq.w	80284a6 <cblas_ztrsv+0xd52>
    for (i = 1; i < N; i++) {
 8027e72:	9b05      	ldr	r3, [sp, #20]
 8027e74:	2b01      	cmp	r3, #1
 8027e76:	f77f ae16 	ble.w	8027aa6 <cblas_ztrsv+0x352>
 8027e7a:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027e7c:	f000 fe0a 	bl	8028a94 <__aeabi_i2d>
 8027e80:	0122      	lsls	r2, r4, #4
 8027e82:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027e84:	920d      	str	r2, [sp, #52]	; 0x34
 8027e86:	eb05 120b 	add.w	r2, r5, fp, lsl #4
 8027e8a:	3301      	adds	r3, #1
 8027e8c:	920f      	str	r2, [sp, #60]	; 0x3c
 8027e8e:	eb05 120a 	add.w	r2, r5, sl, lsl #4
 8027e92:	011b      	lsls	r3, r3, #4
 8027e94:	9213      	str	r2, [sp, #76]	; 0x4c
 8027e96:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8027e98:	9312      	str	r3, [sp, #72]	; 0x48
 8027e9a:	3b10      	subs	r3, #16
 8027e9c:	930e      	str	r3, [sp, #56]	; 0x38
 8027e9e:	18d3      	adds	r3, r2, r3
 8027ea0:	9311      	str	r3, [sp, #68]	; 0x44
 8027ea2:	f102 0318 	add.w	r3, r2, #24
 8027ea6:	9310      	str	r3, [sp, #64]	; 0x40
 8027ea8:	ec41 0b19 	vmov	d9, r0, r1
 8027eac:	2301      	movs	r3, #1
 8027eae:	930c      	str	r3, [sp, #48]	; 0x30
      BASE tmp_real = REAL(X, ix);
 8027eb0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8027eb2:	ed93 7b00 	vldr	d7, [r3]
 8027eb6:	ed8d 7b06 	vstr	d7, [sp, #24]
      BASE tmp_imag = IMAG(X, ix);
 8027eba:	ed93 7b02 	vldr	d7, [r3, #8]
 8027ebe:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027ec0:	9300      	str	r3, [sp, #0]
 8027ec2:	ed8d 7b08 	vstr	d7, [sp, #32]
 8027ec6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027ec8:	9302      	str	r3, [sp, #8]
 8027eca:	2300      	movs	r3, #0
 8027ecc:	930a      	str	r3, [sp, #40]	; 0x28
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8027ece:	9c00      	ldr	r4, [sp, #0]
 8027ed0:	ec51 0b19 	vmov	r0, r1, d9
 8027ed4:	e9d4 2300 	ldrd	r2, r3, [r4]
 8027ed8:	f000 fe46 	bl	8028b68 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 8027edc:	9d02      	ldr	r5, [sp, #8]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8027ede:	9400      	str	r4, [sp, #0]
        const BASE x_real = REAL(X, jx);
 8027ee0:	ed95 7b00 	vldr	d7, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8027ee4:	e954 6702 	ldrd	r6, r7, [r4, #-8]
        const BASE x_real = REAL(X, jx);
 8027ee8:	eeb0 8a47 	vmov.f32	s16, s14
 8027eec:	eef0 8a67 	vmov.f32	s17, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027ef0:	ec53 2b17 	vmov	r2, r3, d7
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8027ef4:	4682      	mov	sl, r0
 8027ef6:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027ef8:	4630      	mov	r0, r6
 8027efa:	4639      	mov	r1, r7
 8027efc:	f000 fe34 	bl	8028b68 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8027f00:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027f04:	4604      	mov	r4, r0
 8027f06:	460d      	mov	r5, r1
 8027f08:	4642      	mov	r2, r8
 8027f0a:	464b      	mov	r3, r9
 8027f0c:	4650      	mov	r0, sl
 8027f0e:	4659      	mov	r1, fp
 8027f10:	f000 fe2a 	bl	8028b68 <__aeabi_dmul>
 8027f14:	4602      	mov	r2, r0
 8027f16:	460b      	mov	r3, r1
 8027f18:	4620      	mov	r0, r4
 8027f1a:	4629      	mov	r1, r5
 8027f1c:	f000 fc6c 	bl	80287f8 <__aeabi_dsub>
 8027f20:	4602      	mov	r2, r0
 8027f22:	460b      	mov	r3, r1
 8027f24:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8027f28:	f000 fc66 	bl	80287f8 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027f2c:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027f2e:	4604      	mov	r4, r0
 8027f30:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027f32:	464b      	mov	r3, r9
 8027f34:	4630      	mov	r0, r6
 8027f36:	4639      	mov	r1, r7
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027f38:	e9cd 4506 	strd	r4, r5, [sp, #24]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027f3c:	f000 fe14 	bl	8028b68 <__aeabi_dmul>
 8027f40:	ec53 2b18 	vmov	r2, r3, d8
 8027f44:	4604      	mov	r4, r0
 8027f46:	460d      	mov	r5, r1
 8027f48:	4650      	mov	r0, sl
 8027f4a:	4659      	mov	r1, fp
 8027f4c:	f000 fe0c 	bl	8028b68 <__aeabi_dmul>
 8027f50:	4602      	mov	r2, r0
 8027f52:	460b      	mov	r3, r1
 8027f54:	4620      	mov	r0, r4
 8027f56:	4629      	mov	r1, r5
 8027f58:	f000 fc50 	bl	80287fc <__adddf3>
 8027f5c:	4602      	mov	r2, r0
 8027f5e:	460b      	mov	r3, r1
 8027f60:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8027f64:	f000 fc48 	bl	80287f8 <__aeabi_dsub>
 8027f68:	9b00      	ldr	r3, [sp, #0]
 8027f6a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 8027f6c:	9d02      	ldr	r5, [sp, #8]
      for (j = 0; j < i; j++) {
 8027f6e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027f70:	4423      	add	r3, r4
 8027f72:	9300      	str	r3, [sp, #0]
 8027f74:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8027f76:	18eb      	adds	r3, r5, r3
 8027f78:	9302      	str	r3, [sp, #8]
 8027f7a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027f7c:	3201      	adds	r2, #1
 8027f7e:	429a      	cmp	r2, r3
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027f80:	e9cd 0108 	strd	r0, r1, [sp, #32]
      for (j = 0; j < i; j++) {
 8027f84:	920a      	str	r2, [sp, #40]	; 0x28
 8027f86:	d1a2      	bne.n	8027ece <cblas_ztrsv+0x77a>
      if (nonunit) {
 8027f88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027f8a:	2b83      	cmp	r3, #131	; 0x83
 8027f8c:	f000 813d 	beq.w	802820a <cblas_ztrsv+0xab6>
        REAL(X, ix) = tmp_real;
 8027f90:	ed9d 7b06 	vldr	d7, [sp, #24]
 8027f94:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8027f96:	ed83 7b00 	vstr	d7, [r3]
        IMAG(X, ix) = tmp_imag;
 8027f9a:	ed9d 7b08 	vldr	d7, [sp, #32]
 8027f9e:	ed83 7b02 	vstr	d7, [r3, #8]
    for (i = 1; i < N; i++) {
 8027fa2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8027fa4:	990d      	ldr	r1, [sp, #52]	; 0x34
 8027fa6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027fa8:	440a      	add	r2, r1
 8027faa:	920f      	str	r2, [sp, #60]	; 0x3c
 8027fac:	e9dd 2111 	ldrd	r2, r1, [sp, #68]	; 0x44
 8027fb0:	440a      	add	r2, r1
 8027fb2:	9211      	str	r2, [sp, #68]	; 0x44
 8027fb4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8027fb6:	3210      	adds	r2, #16
 8027fb8:	9210      	str	r2, [sp, #64]	; 0x40
 8027fba:	9a05      	ldr	r2, [sp, #20]
 8027fbc:	3301      	adds	r3, #1
 8027fbe:	429a      	cmp	r2, r3
 8027fc0:	930c      	str	r3, [sp, #48]	; 0x30
 8027fc2:	f47f af75 	bne.w	8027eb0 <cblas_ztrsv+0x75c>
 8027fc6:	e56e      	b.n	8027aa6 <cblas_ztrsv+0x352>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8027fc8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8027fca:	9b14      	ldr	r3, [sp, #80]	; 0x50
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8027fcc:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027fce:	189c      	adds	r4, r3, r2
 8027fd0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027fd2:	441c      	add	r4, r3
 8027fd4:	f000 fd5e 	bl	8028a94 <__aeabi_i2d>
 8027fd8:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8027fdc:	f000 fdc4 	bl	8028b68 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8027fe0:	e9d4 4500 	ldrd	r4, r5, [r4]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8027fe4:	4606      	mov	r6, r0
 8027fe6:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 8027fe8:	4632      	mov	r2, r6
 8027fea:	463b      	mov	r3, r7
 8027fec:	4620      	mov	r0, r4
 8027fee:	4629      	mov	r1, r5
 8027ff0:	f7ff fb78 	bl	80276e4 <xhypot>
 8027ff4:	4682      	mov	sl, r0
 8027ff6:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 8027ff8:	4620      	mov	r0, r4
 8027ffa:	4629      	mov	r1, r5
 8027ffc:	4652      	mov	r2, sl
 8027ffe:	465b      	mov	r3, fp
 8028000:	f000 fedc 	bl	8028dbc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 8028004:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 8028006:	4604      	mov	r4, r0
 8028008:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 802800a:	465b      	mov	r3, fp
 802800c:	4630      	mov	r0, r6
 802800e:	4639      	mov	r1, r7
 8028010:	f000 fed4 	bl	8028dbc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028014:	e9dd 2300 	ldrd	r2, r3, [sp]
        const BASE b_imag = a_imag / s;
 8028018:	4680      	mov	r8, r0
 802801a:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802801c:	4620      	mov	r0, r4
 802801e:	4629      	mov	r1, r5
 8028020:	f000 fda2 	bl	8028b68 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 8028024:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028026:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802802a:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 802802c:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802802e:	4640      	mov	r0, r8
 8028030:	460d      	mov	r5, r1
 8028032:	4649      	mov	r1, r9
 8028034:	f000 fd98 	bl	8028b68 <__aeabi_dmul>
 8028038:	4602      	mov	r2, r0
 802803a:	460b      	mov	r3, r1
 802803c:	4620      	mov	r0, r4
 802803e:	4629      	mov	r1, r5
 8028040:	f000 fbdc 	bl	80287fc <__adddf3>
 8028044:	4652      	mov	r2, sl
 8028046:	465b      	mov	r3, fp
 8028048:	f000 feb8 	bl	8028dbc <__aeabi_ddiv>
 802804c:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 802804e:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028050:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8028052:	460d      	mov	r5, r1
 8028054:	e946 4502 	strd	r4, r5, [r6, #-8]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8028058:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802805c:	4639      	mov	r1, r7
 802805e:	f000 fd83 	bl	8028b68 <__aeabi_dmul>
 8028062:	e9dd 2300 	ldrd	r2, r3, [sp]
 8028066:	4604      	mov	r4, r0
 8028068:	460d      	mov	r5, r1
 802806a:	4640      	mov	r0, r8
 802806c:	4649      	mov	r1, r9
 802806e:	f000 fd7b 	bl	8028b68 <__aeabi_dmul>
 8028072:	4602      	mov	r2, r0
 8028074:	460b      	mov	r3, r1
 8028076:	4620      	mov	r0, r4
 8028078:	4629      	mov	r1, r5
 802807a:	f000 fbbd 	bl	80287f8 <__aeabi_dsub>
 802807e:	4652      	mov	r2, sl
 8028080:	465b      	mov	r3, fp
 8028082:	f000 fe9b 	bl	8028dbc <__aeabi_ddiv>
 8028086:	e9c6 0100 	strd	r0, r1, [r6]
 802808a:	e4fb      	b.n	8027a84 <cblas_ztrsv+0x330>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 802808c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 802808e:	9b10      	ldr	r3, [sp, #64]	; 0x40
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8028090:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8028092:	189c      	adds	r4, r3, r2
 8028094:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8028096:	441c      	add	r4, r3
 8028098:	f000 fcfc 	bl	8028a94 <__aeabi_i2d>
 802809c:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80280a0:	f000 fd62 	bl	8028b68 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 80280a4:	e9d4 4500 	ldrd	r4, r5, [r4]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80280a8:	4606      	mov	r6, r0
 80280aa:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 80280ac:	4632      	mov	r2, r6
 80280ae:	463b      	mov	r3, r7
 80280b0:	4620      	mov	r0, r4
 80280b2:	4629      	mov	r1, r5
 80280b4:	f7ff fb16 	bl	80276e4 <xhypot>
 80280b8:	4682      	mov	sl, r0
 80280ba:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 80280bc:	4620      	mov	r0, r4
 80280be:	4629      	mov	r1, r5
 80280c0:	4652      	mov	r2, sl
 80280c2:	465b      	mov	r3, fp
 80280c4:	f000 fe7a 	bl	8028dbc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 80280c8:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 80280ca:	4604      	mov	r4, r0
 80280cc:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 80280ce:	465b      	mov	r3, fp
 80280d0:	4630      	mov	r0, r6
 80280d2:	4639      	mov	r1, r7
 80280d4:	f000 fe72 	bl	8028dbc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80280d8:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
        const BASE b_imag = a_imag / s;
 80280dc:	4680      	mov	r8, r0
 80280de:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80280e0:	4620      	mov	r0, r4
 80280e2:	4629      	mov	r1, r5
 80280e4:	f000 fd40 	bl	8028b68 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 80280e8:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80280ea:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80280ee:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 80280f0:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80280f2:	4640      	mov	r0, r8
 80280f4:	460d      	mov	r5, r1
 80280f6:	4649      	mov	r1, r9
 80280f8:	f000 fd36 	bl	8028b68 <__aeabi_dmul>
 80280fc:	4602      	mov	r2, r0
 80280fe:	460b      	mov	r3, r1
 8028100:	4620      	mov	r0, r4
 8028102:	4629      	mov	r1, r5
 8028104:	f000 fb7a 	bl	80287fc <__adddf3>
 8028108:	4652      	mov	r2, sl
 802810a:	465b      	mov	r3, fp
 802810c:	f000 fe56 	bl	8028dbc <__aeabi_ddiv>
 8028110:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8028112:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028114:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8028116:	460d      	mov	r5, r1
 8028118:	e946 4502 	strd	r4, r5, [r6, #-8]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 802811c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8028120:	4639      	mov	r1, r7
 8028122:	f000 fd21 	bl	8028b68 <__aeabi_dmul>
 8028126:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802812a:	4604      	mov	r4, r0
 802812c:	460d      	mov	r5, r1
 802812e:	4640      	mov	r0, r8
 8028130:	4649      	mov	r1, r9
 8028132:	f000 fd19 	bl	8028b68 <__aeabi_dmul>
 8028136:	4602      	mov	r2, r0
 8028138:	460b      	mov	r3, r1
 802813a:	4620      	mov	r0, r4
 802813c:	4629      	mov	r1, r5
 802813e:	f000 fb5b 	bl	80287f8 <__aeabi_dsub>
 8028142:	4652      	mov	r2, sl
 8028144:	465b      	mov	r3, fp
 8028146:	f000 fe39 	bl	8028dbc <__aeabi_ddiv>
 802814a:	e9c6 0100 	strd	r0, r1, [r6]
 802814e:	e5ae      	b.n	8027cae <cblas_ztrsv+0x55a>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8028150:	9c06      	ldr	r4, [sp, #24]
 8028152:	ec51 0b1a 	vmov	r0, r1, d10
 8028156:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802815a:	f000 fd05 	bl	8028b68 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 802815e:	e9d4 4500 	ldrd	r4, r5, [r4]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8028162:	4606      	mov	r6, r0
 8028164:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 8028166:	4632      	mov	r2, r6
 8028168:	463b      	mov	r3, r7
 802816a:	4620      	mov	r0, r4
 802816c:	4629      	mov	r1, r5
 802816e:	f7ff fab9 	bl	80276e4 <xhypot>
 8028172:	4682      	mov	sl, r0
 8028174:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 8028176:	4620      	mov	r0, r4
 8028178:	4629      	mov	r1, r5
 802817a:	4652      	mov	r2, sl
 802817c:	465b      	mov	r3, fp
 802817e:	f000 fe1d 	bl	8028dbc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 8028182:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 8028184:	4604      	mov	r4, r0
 8028186:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 8028188:	465b      	mov	r3, fp
 802818a:	4630      	mov	r0, r6
 802818c:	4639      	mov	r1, r7
 802818e:	f000 fe15 	bl	8028dbc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028192:	e9dd 2300 	ldrd	r2, r3, [sp]
        const BASE b_imag = a_imag / s;
 8028196:	4680      	mov	r8, r0
 8028198:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802819a:	4620      	mov	r0, r4
 802819c:	4629      	mov	r1, r5
 802819e:	f000 fce3 	bl	8028b68 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 80281a2:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80281a4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80281a8:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 80281aa:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80281ac:	4640      	mov	r0, r8
 80281ae:	460d      	mov	r5, r1
 80281b0:	4649      	mov	r1, r9
 80281b2:	f000 fcd9 	bl	8028b68 <__aeabi_dmul>
 80281b6:	4602      	mov	r2, r0
 80281b8:	460b      	mov	r3, r1
 80281ba:	4620      	mov	r0, r4
 80281bc:	4629      	mov	r1, r5
 80281be:	f000 fb1d 	bl	80287fc <__adddf3>
 80281c2:	4652      	mov	r2, sl
 80281c4:	465b      	mov	r3, fp
 80281c6:	f000 fdf9 	bl	8028dbc <__aeabi_ddiv>
 80281ca:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80281cc:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80281ce:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80281d0:	460d      	mov	r5, r1
 80281d2:	e9c6 4500 	strd	r4, r5, [r6]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80281d6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80281da:	4639      	mov	r1, r7
 80281dc:	f000 fcc4 	bl	8028b68 <__aeabi_dmul>
 80281e0:	e9dd 2300 	ldrd	r2, r3, [sp]
 80281e4:	4604      	mov	r4, r0
 80281e6:	460d      	mov	r5, r1
 80281e8:	4640      	mov	r0, r8
 80281ea:	4649      	mov	r1, r9
 80281ec:	f000 fcbc 	bl	8028b68 <__aeabi_dmul>
 80281f0:	4602      	mov	r2, r0
 80281f2:	460b      	mov	r3, r1
 80281f4:	4620      	mov	r0, r4
 80281f6:	4629      	mov	r1, r5
 80281f8:	f000 fafe 	bl	80287f8 <__aeabi_dsub>
 80281fc:	4652      	mov	r2, sl
 80281fe:	465b      	mov	r3, fp
 8028200:	f000 fddc 	bl	8028dbc <__aeabi_ddiv>
 8028204:	e9c6 0102 	strd	r0, r1, [r6, #8]
 8028208:	e606      	b.n	8027e18 <cblas_ztrsv+0x6c4>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 802820a:	9c11      	ldr	r4, [sp, #68]	; 0x44
 802820c:	ec51 0b19 	vmov	r0, r1, d9
 8028210:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 8028214:	f000 fca8 	bl	8028b68 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8028218:	e9d4 4504 	ldrd	r4, r5, [r4, #16]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 802821c:	4606      	mov	r6, r0
 802821e:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 8028220:	4632      	mov	r2, r6
 8028222:	463b      	mov	r3, r7
 8028224:	4620      	mov	r0, r4
 8028226:	4629      	mov	r1, r5
 8028228:	f7ff fa5c 	bl	80276e4 <xhypot>
 802822c:	4682      	mov	sl, r0
 802822e:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 8028230:	4620      	mov	r0, r4
 8028232:	4629      	mov	r1, r5
 8028234:	4652      	mov	r2, sl
 8028236:	465b      	mov	r3, fp
 8028238:	f000 fdc0 	bl	8028dbc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 802823c:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 802823e:	4604      	mov	r4, r0
 8028240:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 8028242:	465b      	mov	r3, fp
 8028244:	4630      	mov	r0, r6
 8028246:	4639      	mov	r1, r7
 8028248:	f000 fdb8 	bl	8028dbc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802824c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
        const BASE b_imag = a_imag / s;
 8028250:	4680      	mov	r8, r0
 8028252:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028254:	4620      	mov	r0, r4
 8028256:	4629      	mov	r1, r5
 8028258:	f000 fc86 	bl	8028b68 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 802825c:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802825e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8028262:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 8028264:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028266:	4640      	mov	r0, r8
 8028268:	460d      	mov	r5, r1
 802826a:	4649      	mov	r1, r9
 802826c:	f000 fc7c 	bl	8028b68 <__aeabi_dmul>
 8028270:	4602      	mov	r2, r0
 8028272:	460b      	mov	r3, r1
 8028274:	4620      	mov	r0, r4
 8028276:	4629      	mov	r1, r5
 8028278:	f000 fac0 	bl	80287fc <__adddf3>
 802827c:	4652      	mov	r2, sl
 802827e:	465b      	mov	r3, fp
 8028280:	f000 fd9c 	bl	8028dbc <__aeabi_ddiv>
 8028284:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8028286:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8028288:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 802828a:	460d      	mov	r5, r1
 802828c:	e9c6 4500 	strd	r4, r5, [r6]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8028290:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8028294:	4639      	mov	r1, r7
 8028296:	f000 fc67 	bl	8028b68 <__aeabi_dmul>
 802829a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802829e:	4604      	mov	r4, r0
 80282a0:	460d      	mov	r5, r1
 80282a2:	4640      	mov	r0, r8
 80282a4:	4649      	mov	r1, r9
 80282a6:	f000 fc5f 	bl	8028b68 <__aeabi_dmul>
 80282aa:	4602      	mov	r2, r0
 80282ac:	460b      	mov	r3, r1
 80282ae:	4620      	mov	r0, r4
 80282b0:	4629      	mov	r1, r5
 80282b2:	f000 faa1 	bl	80287f8 <__aeabi_dsub>
 80282b6:	4652      	mov	r2, sl
 80282b8:	465b      	mov	r3, fp
 80282ba:	f000 fd7f 	bl	8028dbc <__aeabi_ddiv>
 80282be:	e9c6 0102 	strd	r0, r1, [r6, #8]
 80282c2:	e66e      	b.n	8027fa2 <cblas_ztrsv+0x84e>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80282c4:	2009      	movs	r0, #9
 80282c6:	f7ff ba7a 	b.w	80277be <cblas_ztrsv+0x6a>
    ix = OFFSET(N, incX);
 80282ca:	9b05      	ldr	r3, [sp, #20]
 80282cc:	f1c3 0a01 	rsb	sl, r3, #1
 80282d0:	fb0a fa04 	mul.w	sl, sl, r4
 80282d4:	eb04 0b0a 	add.w	fp, r4, sl
 80282d8:	e509      	b.n	8027cee <cblas_ztrsv+0x59a>
    ix = OFFSET(N, incX);
 80282da:	9b05      	ldr	r3, [sp, #20]
 80282dc:	f1c3 0a01 	rsb	sl, r3, #1
 80282e0:	fb0a fa04 	mul.w	sl, sl, r4
 80282e4:	eb04 0b0a 	add.w	fp, r4, sl
 80282e8:	e5bf      	b.n	8027e6a <cblas_ztrsv+0x716>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 80282ea:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80282ec:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 80282ee:	980f      	ldr	r0, [sp, #60]	; 0x3c
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 80282f0:	fb02 2603 	mla	r6, r2, r3, r2
 80282f4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80282f6:	eb03 1606 	add.w	r6, r3, r6, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 80282fa:	f000 fbcb 	bl	8028a94 <__aeabi_i2d>
 80282fe:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8028302:	f000 fc31 	bl	8028b68 <__aeabi_dmul>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8028306:	e9d6 8900 	ldrd	r8, r9, [r6]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 802830a:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE x_imag = IMAG(X, ix);
 802830e:	eb05 160a 	add.w	r6, r5, sl, lsl #4
      const BASE s = xhypot(a_real, a_imag);
 8028312:	ec53 2b1a 	vmov	r2, r3, d10
      const BASE x_imag = IMAG(X, ix);
 8028316:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 8028318:	4640      	mov	r0, r8
 802831a:	4649      	mov	r1, r9
      const BASE x_real = REAL(X, ix);
 802831c:	eb05 1b0a 	add.w	fp, r5, sl, lsl #4
      const BASE x_imag = IMAG(X, ix);
 8028320:	ed96 8b00 	vldr	d8, [r6]
      const BASE x_real = REAL(X, ix);
 8028324:	ed9b 9b00 	vldr	d9, [fp]
      const BASE x_imag = IMAG(X, ix);
 8028328:	9600      	str	r6, [sp, #0]
      const BASE s = xhypot(a_real, a_imag);
 802832a:	f7ff f9db 	bl	80276e4 <xhypot>
 802832e:	4606      	mov	r6, r0
 8028330:	460f      	mov	r7, r1
      const BASE b_real = a_real / s;
 8028332:	4632      	mov	r2, r6
 8028334:	4640      	mov	r0, r8
 8028336:	4649      	mov	r1, r9
 8028338:	463b      	mov	r3, r7
 802833a:	f000 fd3f 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 802833e:	4632      	mov	r2, r6
      const BASE b_real = a_real / s;
 8028340:	4680      	mov	r8, r0
 8028342:	4689      	mov	r9, r1
      const BASE b_imag = a_imag / s;
 8028344:	463b      	mov	r3, r7
 8028346:	ec51 0b1a 	vmov	r0, r1, d10
 802834a:	f000 fd37 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 802834e:	ec49 8b1b 	vmov	d11, r8, r9
      const BASE b_imag = a_imag / s;
 8028352:	4680      	mov	r8, r0
 8028354:	4689      	mov	r9, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8028356:	ec53 2b1b 	vmov	r2, r3, d11
 802835a:	ec51 0b19 	vmov	r0, r1, d9
 802835e:	f000 fc03 	bl	8028b68 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 8028362:	ec49 8b1a 	vmov	d10, r8, r9
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8028366:	4680      	mov	r8, r0
 8028368:	ec53 2b1a 	vmov	r2, r3, d10
 802836c:	4689      	mov	r9, r1
 802836e:	ec51 0b18 	vmov	r0, r1, d8
 8028372:	f000 fbf9 	bl	8028b68 <__aeabi_dmul>
 8028376:	4602      	mov	r2, r0
 8028378:	460b      	mov	r3, r1
 802837a:	4640      	mov	r0, r8
 802837c:	4649      	mov	r1, r9
 802837e:	f000 fa3d 	bl	80287fc <__adddf3>
 8028382:	4632      	mov	r2, r6
 8028384:	463b      	mov	r3, r7
 8028386:	f000 fd19 	bl	8028dbc <__aeabi_ddiv>
 802838a:	4680      	mov	r8, r0
 802838c:	4689      	mov	r9, r1
 802838e:	e9cb 8900 	strd	r8, r9, [fp]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8028392:	ec53 2b1b 	vmov	r2, r3, d11
 8028396:	ec51 0b18 	vmov	r0, r1, d8
 802839a:	f000 fbe5 	bl	8028b68 <__aeabi_dmul>
 802839e:	ec53 2b1a 	vmov	r2, r3, d10
 80283a2:	4680      	mov	r8, r0
 80283a4:	4689      	mov	r9, r1
 80283a6:	ec51 0b19 	vmov	r0, r1, d9
 80283aa:	f000 fbdd 	bl	8028b68 <__aeabi_dmul>
 80283ae:	4602      	mov	r2, r0
 80283b0:	460b      	mov	r3, r1
 80283b2:	4640      	mov	r0, r8
 80283b4:	4649      	mov	r1, r9
 80283b6:	f000 fa1f 	bl	80287f8 <__aeabi_dsub>
 80283ba:	4632      	mov	r2, r6
 80283bc:	463b      	mov	r3, r7
 80283be:	f000 fcfd 	bl	8028dbc <__aeabi_ddiv>
 80283c2:	9e00      	ldr	r6, [sp, #0]
 80283c4:	e9c6 0100 	strd	r0, r1, [r6]
 80283c8:	f7ff bbbf 	b.w	8027b4a <cblas_ztrsv+0x3f6>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80283cc:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80283ce:	f000 fb61 	bl	8028a94 <__aeabi_i2d>
 80283d2:	9e10      	ldr	r6, [sp, #64]	; 0x40
 80283d4:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80283d8:	f000 fbc6 	bl	8028b68 <__aeabi_dmul>
      const BASE x_real = REAL(X, ix);
 80283dc:	eb05 170a 	add.w	r7, r5, sl, lsl #4
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 80283e0:	e9d6 8900 	ldrd	r8, r9, [r6]
      const BASE x_real = REAL(X, ix);
 80283e4:	9700      	str	r7, [sp, #0]
 80283e6:	9f00      	ldr	r7, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 80283e8:	eb05 160a 	add.w	r6, r5, sl, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80283ec:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE s = xhypot(a_real, a_imag);
 80283f0:	4602      	mov	r2, r0
 80283f2:	460b      	mov	r3, r1
      const BASE x_imag = IMAG(X, ix);
 80283f4:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 80283f6:	4640      	mov	r0, r8
 80283f8:	4649      	mov	r1, r9
      const BASE x_real = REAL(X, ix);
 80283fa:	ed97 9b00 	vldr	d9, [r7]
      const BASE x_imag = IMAG(X, ix);
 80283fe:	ed96 8b00 	vldr	d8, [r6]
 8028402:	9602      	str	r6, [sp, #8]
      const BASE s = xhypot(a_real, a_imag);
 8028404:	f7ff f96e 	bl	80276e4 <xhypot>
 8028408:	ec41 0b1b 	vmov	d11, r0, r1
      const BASE b_real = a_real / s;
 802840c:	4640      	mov	r0, r8
 802840e:	ec53 2b1b 	vmov	r2, r3, d11
 8028412:	4649      	mov	r1, r9
 8028414:	f000 fcd2 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 8028418:	ec53 2b1b 	vmov	r2, r3, d11
      const BASE b_real = a_real / s;
 802841c:	4680      	mov	r8, r0
 802841e:	4689      	mov	r9, r1
      const BASE b_imag = a_imag / s;
 8028420:	ec51 0b1a 	vmov	r0, r1, d10
 8028424:	f000 fcca 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 8028428:	4646      	mov	r6, r8
 802842a:	464f      	mov	r7, r9
      const BASE b_imag = a_imag / s;
 802842c:	4680      	mov	r8, r0
 802842e:	4689      	mov	r9, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8028430:	4632      	mov	r2, r6
 8028432:	463b      	mov	r3, r7
 8028434:	ec51 0b19 	vmov	r0, r1, d9
 8028438:	f000 fb96 	bl	8028b68 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 802843c:	ec49 8b1a 	vmov	d10, r8, r9
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8028440:	4680      	mov	r8, r0
 8028442:	ec53 2b1a 	vmov	r2, r3, d10
 8028446:	4689      	mov	r9, r1
 8028448:	ec51 0b18 	vmov	r0, r1, d8
 802844c:	f000 fb8c 	bl	8028b68 <__aeabi_dmul>
 8028450:	4602      	mov	r2, r0
 8028452:	460b      	mov	r3, r1
 8028454:	4640      	mov	r0, r8
 8028456:	4649      	mov	r1, r9
 8028458:	f000 f9d0 	bl	80287fc <__adddf3>
 802845c:	ec53 2b1b 	vmov	r2, r3, d11
 8028460:	f000 fcac 	bl	8028dbc <__aeabi_ddiv>
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8028464:	463b      	mov	r3, r7
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8028466:	9f00      	ldr	r7, [sp, #0]
 8028468:	4680      	mov	r8, r0
 802846a:	4689      	mov	r9, r1
 802846c:	e9c7 8900 	strd	r8, r9, [r7]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8028470:	4632      	mov	r2, r6
 8028472:	ec51 0b18 	vmov	r0, r1, d8
 8028476:	f000 fb77 	bl	8028b68 <__aeabi_dmul>
 802847a:	ec53 2b1a 	vmov	r2, r3, d10
 802847e:	4680      	mov	r8, r0
 8028480:	4689      	mov	r9, r1
 8028482:	ec51 0b19 	vmov	r0, r1, d9
 8028486:	f000 fb6f 	bl	8028b68 <__aeabi_dmul>
 802848a:	4602      	mov	r2, r0
 802848c:	460b      	mov	r3, r1
 802848e:	4640      	mov	r0, r8
 8028490:	4649      	mov	r1, r9
 8028492:	f000 f9b1 	bl	80287f8 <__aeabi_dsub>
 8028496:	ec53 2b1b 	vmov	r2, r3, d11
 802849a:	f000 fc8f 	bl	8028dbc <__aeabi_ddiv>
 802849e:	9e02      	ldr	r6, [sp, #8]
 80284a0:	e9c6 0100 	strd	r0, r1, [r6]
 80284a4:	e427      	b.n	8027cf6 <cblas_ztrsv+0x5a2>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80284a6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80284a8:	f000 faf4 	bl	8028a94 <__aeabi_i2d>
 80284ac:	9e10      	ldr	r6, [sp, #64]	; 0x40
 80284ae:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80284b2:	f000 fb59 	bl	8028b68 <__aeabi_dmul>
      const BASE x_real = REAL(X, ix);
 80284b6:	eb05 170a 	add.w	r7, r5, sl, lsl #4
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 80284ba:	e9d6 8900 	ldrd	r8, r9, [r6]
      const BASE x_real = REAL(X, ix);
 80284be:	9700      	str	r7, [sp, #0]
 80284c0:	9f00      	ldr	r7, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 80284c2:	eb05 160a 	add.w	r6, r5, sl, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80284c6:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE s = xhypot(a_real, a_imag);
 80284ca:	4602      	mov	r2, r0
 80284cc:	460b      	mov	r3, r1
      const BASE x_imag = IMAG(X, ix);
 80284ce:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 80284d0:	4640      	mov	r0, r8
 80284d2:	4649      	mov	r1, r9
      const BASE x_real = REAL(X, ix);
 80284d4:	ed97 9b00 	vldr	d9, [r7]
      const BASE x_imag = IMAG(X, ix);
 80284d8:	ed96 8b00 	vldr	d8, [r6]
 80284dc:	9602      	str	r6, [sp, #8]
      const BASE s = xhypot(a_real, a_imag);
 80284de:	f7ff f901 	bl	80276e4 <xhypot>
 80284e2:	ec41 0b1b 	vmov	d11, r0, r1
      const BASE b_real = a_real / s;
 80284e6:	4640      	mov	r0, r8
 80284e8:	ec53 2b1b 	vmov	r2, r3, d11
 80284ec:	4649      	mov	r1, r9
 80284ee:	f000 fc65 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 80284f2:	ec53 2b1b 	vmov	r2, r3, d11
      const BASE b_real = a_real / s;
 80284f6:	4680      	mov	r8, r0
 80284f8:	4689      	mov	r9, r1
      const BASE b_imag = a_imag / s;
 80284fa:	ec51 0b1a 	vmov	r0, r1, d10
 80284fe:	f000 fc5d 	bl	8028dbc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 8028502:	4646      	mov	r6, r8
 8028504:	464f      	mov	r7, r9
      const BASE b_imag = a_imag / s;
 8028506:	4680      	mov	r8, r0
 8028508:	4689      	mov	r9, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 802850a:	4632      	mov	r2, r6
 802850c:	463b      	mov	r3, r7
 802850e:	ec51 0b19 	vmov	r0, r1, d9
 8028512:	f000 fb29 	bl	8028b68 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 8028516:	ec49 8b1a 	vmov	d10, r8, r9
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 802851a:	4680      	mov	r8, r0
 802851c:	ec53 2b1a 	vmov	r2, r3, d10
 8028520:	4689      	mov	r9, r1
 8028522:	ec51 0b18 	vmov	r0, r1, d8
 8028526:	f000 fb1f 	bl	8028b68 <__aeabi_dmul>
 802852a:	4602      	mov	r2, r0
 802852c:	460b      	mov	r3, r1
 802852e:	4640      	mov	r0, r8
 8028530:	4649      	mov	r1, r9
 8028532:	f000 f963 	bl	80287fc <__adddf3>
 8028536:	ec53 2b1b 	vmov	r2, r3, d11
 802853a:	f000 fc3f 	bl	8028dbc <__aeabi_ddiv>
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 802853e:	463b      	mov	r3, r7
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8028540:	9f00      	ldr	r7, [sp, #0]
 8028542:	4680      	mov	r8, r0
 8028544:	4689      	mov	r9, r1
 8028546:	e9c7 8900 	strd	r8, r9, [r7]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 802854a:	4632      	mov	r2, r6
 802854c:	ec51 0b18 	vmov	r0, r1, d8
 8028550:	f000 fb0a 	bl	8028b68 <__aeabi_dmul>
 8028554:	ec53 2b1a 	vmov	r2, r3, d10
 8028558:	4680      	mov	r8, r0
 802855a:	4689      	mov	r9, r1
 802855c:	ec51 0b19 	vmov	r0, r1, d9
 8028560:	f000 fb02 	bl	8028b68 <__aeabi_dmul>
 8028564:	4602      	mov	r2, r0
 8028566:	460b      	mov	r3, r1
 8028568:	4640      	mov	r0, r8
 802856a:	4649      	mov	r1, r9
 802856c:	f000 f944 	bl	80287f8 <__aeabi_dsub>
 8028570:	ec53 2b1b 	vmov	r2, r3, d11
 8028574:	f000 fc22 	bl	8028dbc <__aeabi_ddiv>
 8028578:	9e02      	ldr	r6, [sp, #8]
 802857a:	e9c6 0100 	strd	r0, r1, [r6]
 802857e:	e478      	b.n	8027e72 <cblas_ztrsv+0x71e>

08028580 <cblas_icamax>:
  BASE max = 0.0;
  INDEX ix = 0;
  INDEX i;
  CBLAS_INDEX result = 0;

  if (incX <= 0) {
 8028580:	2a00      	cmp	r2, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_icamax (const int N, const void *X, const int incX)
{
 8028582:	b410      	push	{r4}
    return 0;
 8028584:	f04f 0400 	mov.w	r4, #0
  if (incX <= 0) {
 8028588:	dd1d      	ble.n	80285c6 <cblas_icamax+0x46>
  }

  for (i = 0; i < N; i++) {
 802858a:	2800      	cmp	r0, #0
 802858c:	dd1b      	ble.n	80285c6 <cblas_icamax+0x46>
  BASE max = 0.0;
 802858e:	eddf 6a10 	vldr	s13, [pc, #64]	; 80285d0 <cblas_icamax+0x50>
 8028592:	00d2      	lsls	r2, r2, #3
  for (i = 0; i < N; i++) {
 8028594:	4623      	mov	r3, r4
    const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 8028596:	edd1 7a00 	vldr	s15, [r1]
 802859a:	ed91 7a01 	vldr	s14, [r1, #4]
 802859e:	eef0 7ae7 	vabs.f32	s15, s15
 80285a2:	eeb0 7ac7 	vabs.f32	s14, s14
 80285a6:	ee77 7a87 	vadd.f32	s15, s15, s14

    if (a > max) {
      max = a;
      result = i;
 80285aa:	4411      	add	r1, r2
    if (a > max) {
 80285ac:	eef4 7ae6 	vcmpe.f32	s15, s13
 80285b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      result = i;
 80285b4:	bfc8      	it	gt
 80285b6:	461c      	movgt	r4, r3
  for (i = 0; i < N; i++) {
 80285b8:	f103 0301 	add.w	r3, r3, #1
      max = a;
 80285bc:	bfc8      	it	gt
 80285be:	eef0 6a67 	vmovgt.f32	s13, s15
  for (i = 0; i < N; i++) {
 80285c2:	4298      	cmp	r0, r3
 80285c4:	d1e7      	bne.n	8028596 <cblas_icamax+0x16>
#define BASE float
#include "source_iamax_c.h"
#undef BASE
}
 80285c6:	4620      	mov	r0, r4
 80285c8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80285cc:	4770      	bx	lr
 80285ce:	bf00      	nop
 80285d0:	00000000 	.word	0x00000000

080285d4 <cblas_idamax>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_idamax (const int N, const double *X, const int incX)
{
 80285d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  BASE max = 0.0;
  INDEX ix = 0;
  INDEX i;
  CBLAS_INDEX result = 0;

  if (incX <= 0) {
 80285d8:	2a00      	cmp	r2, #0
 80285da:	b083      	sub	sp, #12
 80285dc:	dd21      	ble.n	8028622 <cblas_idamax+0x4e>
    return 0;
  }

  for (i = 0; i < N; i++) {
 80285de:	2800      	cmp	r0, #0
 80285e0:	4681      	mov	r9, r0
 80285e2:	dd1e      	ble.n	8028622 <cblas_idamax+0x4e>
  CBLAS_INDEX result = 0;
 80285e4:	2500      	movs	r5, #0
  BASE max = 0.0;
 80285e6:	f04f 0a00 	mov.w	sl, #0
 80285ea:	f04f 0b00 	mov.w	fp, #0
  CBLAS_INDEX result = 0;
 80285ee:	9501      	str	r5, [sp, #4]
 80285f0:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 80285f4:	460c      	mov	r4, r1
    if (fabs(X[ix]) > max) {
 80285f6:	e9d4 6300 	ldrd	r6, r3, [r4]
 80285fa:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 80285fe:	4630      	mov	r0, r6
 8028600:	4639      	mov	r1, r7
 8028602:	4652      	mov	r2, sl
 8028604:	465b      	mov	r3, fp
 8028606:	f000 fd3f 	bl	8029088 <__aeabi_dcmpgt>
      max = fabs(X[ix]);
      result = i;
 802860a:	4444      	add	r4, r8
    if (fabs(X[ix]) > max) {
 802860c:	b110      	cbz	r0, 8028614 <cblas_idamax+0x40>
      max = fabs(X[ix]);
 802860e:	46b2      	mov	sl, r6
 8028610:	46bb      	mov	fp, r7
      result = i;
 8028612:	9501      	str	r5, [sp, #4]
  for (i = 0; i < N; i++) {
 8028614:	3501      	adds	r5, #1
 8028616:	45a9      	cmp	r9, r5
 8028618:	d1ed      	bne.n	80285f6 <cblas_idamax+0x22>
#define BASE double
#include "source_iamax_r.h"
#undef BASE
}
 802861a:	9801      	ldr	r0, [sp, #4]
 802861c:	b003      	add	sp, #12
 802861e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 8028622:	2300      	movs	r3, #0
 8028624:	9301      	str	r3, [sp, #4]
 8028626:	9801      	ldr	r0, [sp, #4]
 8028628:	b003      	add	sp, #12
 802862a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802862e:	bf00      	nop

08028630 <cblas_isamax>:
  if (incX <= 0) {
 8028630:	2a00      	cmp	r2, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_isamax (const int N, const float *X, const int incX)
{
 8028632:	b410      	push	{r4}
    return 0;
 8028634:	f04f 0400 	mov.w	r4, #0
  if (incX <= 0) {
 8028638:	dd17      	ble.n	802866a <cblas_isamax+0x3a>
  for (i = 0; i < N; i++) {
 802863a:	2800      	cmp	r0, #0
 802863c:	dd15      	ble.n	802866a <cblas_isamax+0x3a>
  BASE max = 0.0;
 802863e:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8028674 <cblas_isamax+0x44>
 8028642:	0092      	lsls	r2, r2, #2
  for (i = 0; i < N; i++) {
 8028644:	4623      	mov	r3, r4
    if (fabs(X[ix]) > max) {
 8028646:	edd1 7a00 	vldr	s15, [r1]
 802864a:	eef0 7ae7 	vabs.f32	s15, s15
 802864e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8028652:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      result = i;
 8028656:	bfc8      	it	gt
 8028658:	461c      	movgt	r4, r3
  for (i = 0; i < N; i++) {
 802865a:	f103 0301 	add.w	r3, r3, #1
      max = fabs(X[ix]);
 802865e:	bfc8      	it	gt
 8028660:	eeb0 7a67 	vmovgt.f32	s14, s15
  for (i = 0; i < N; i++) {
 8028664:	4298      	cmp	r0, r3
 8028666:	4411      	add	r1, r2
 8028668:	d1ed      	bne.n	8028646 <cblas_isamax+0x16>
#define BASE float
#include "source_iamax_r.h"
#undef BASE
}
 802866a:	4620      	mov	r0, r4
 802866c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8028670:	4770      	bx	lr
 8028672:	bf00      	nop
 8028674:	00000000 	.word	0x00000000

08028678 <cblas_izamax>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_izamax (const int N, const void *X, const int incX)
{
 8028678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802867c:	ed2d 8b02 	vpush	{d8}
 8028680:	b085      	sub	sp, #20
  if (incX <= 0) {
 8028682:	2a00      	cmp	r2, #0
 8028684:	9001      	str	r0, [sp, #4]
 8028686:	dd31      	ble.n	80286ec <cblas_izamax+0x74>
  for (i = 0; i < N; i++) {
 8028688:	2800      	cmp	r0, #0
 802868a:	dd2f      	ble.n	80286ec <cblas_izamax+0x74>
  BASE max = 0.0;
 802868c:	ed9f 7b1c 	vldr	d7, [pc, #112]	; 8028700 <cblas_izamax+0x88>
  CBLAS_INDEX result = 0;
 8028690:	2500      	movs	r5, #0
 8028692:	0113      	lsls	r3, r2, #4
 8028694:	9503      	str	r5, [sp, #12]
 8028696:	9302      	str	r3, [sp, #8]
 8028698:	460c      	mov	r4, r1
  BASE max = 0.0;
 802869a:	eeb0 8a47 	vmov.f32	s16, s14
 802869e:	eef0 8a67 	vmov.f32	s17, s15
    const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 80286a2:	e9d4 2a01 	ldrd	r2, sl, [r4, #4]
 80286a6:	68e3      	ldr	r3, [r4, #12]
 80286a8:	f8d4 8000 	ldr.w	r8, [r4]
 80286ac:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
 80286b0:	f023 4b00 	bic.w	fp, r3, #2147483648	; 0x80000000
 80286b4:	4652      	mov	r2, sl
 80286b6:	465b      	mov	r3, fp
 80286b8:	4640      	mov	r0, r8
 80286ba:	4649      	mov	r1, r9
 80286bc:	f000 f89e 	bl	80287fc <__adddf3>
    if (a > max) {
 80286c0:	ec53 2b18 	vmov	r2, r3, d8
    const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 80286c4:	4606      	mov	r6, r0
 80286c6:	460f      	mov	r7, r1
    if (a > max) {
 80286c8:	f000 fcde 	bl	8029088 <__aeabi_dcmpgt>
      result = i;
 80286cc:	9b02      	ldr	r3, [sp, #8]
 80286ce:	441c      	add	r4, r3
    if (a > max) {
 80286d0:	b110      	cbz	r0, 80286d8 <cblas_izamax+0x60>
      max = a;
 80286d2:	ec47 6b18 	vmov	d8, r6, r7
      result = i;
 80286d6:	9503      	str	r5, [sp, #12]
  for (i = 0; i < N; i++) {
 80286d8:	9b01      	ldr	r3, [sp, #4]
 80286da:	3501      	adds	r5, #1
 80286dc:	42ab      	cmp	r3, r5
 80286de:	d1e0      	bne.n	80286a2 <cblas_izamax+0x2a>
#define BASE double
#include "source_iamax_c.h"
#undef BASE
}
 80286e0:	9803      	ldr	r0, [sp, #12]
 80286e2:	b005      	add	sp, #20
 80286e4:	ecbd 8b02 	vpop	{d8}
 80286e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 80286ec:	2300      	movs	r3, #0
 80286ee:	9303      	str	r3, [sp, #12]
 80286f0:	9803      	ldr	r0, [sp, #12]
 80286f2:	b005      	add	sp, #20
 80286f4:	ecbd 8b02 	vpop	{d8}
 80286f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80286fc:	f3af 8000 	nop.w
	...

08028708 <cblas_xerbla>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_xerbla (int p, const char *rout, const char *form, ...)
{
 8028708:	b40c      	push	{r2, r3}
 802870a:	b500      	push	{lr}
 802870c:	b083      	sub	sp, #12
 802870e:	aa04      	add	r2, sp, #16
 8028710:	f852 5b04 	ldr.w	r5, [r2], #4
  va_list ap;

  va_start (ap, form);
 8028714:	9201      	str	r2, [sp, #4]

  if (p)
 8028716:	b940      	cbnz	r0, 802872a <cblas_xerbla+0x22>
 8028718:	4c08      	ldr	r4, [pc, #32]	; (802873c <cblas_xerbla+0x34>)
    {
      fprintf (stderr, "Parameter %d to routine %s was incorrect\n", p, rout);
    }

  vfprintf (stderr, form, ap);
 802871a:	6823      	ldr	r3, [r4, #0]
 802871c:	9a01      	ldr	r2, [sp, #4]
 802871e:	68d8      	ldr	r0, [r3, #12]
 8028720:	4629      	mov	r1, r5
 8028722:	f007 febf 	bl	80304a4 <vfiprintf>
  va_end (ap);

  abort ();
 8028726:	f007 fa91 	bl	802fc4c <abort>
      fprintf (stderr, "Parameter %d to routine %s was incorrect\n", p, rout);
 802872a:	4c04      	ldr	r4, [pc, #16]	; (802873c <cblas_xerbla+0x34>)
 802872c:	6826      	ldr	r6, [r4, #0]
 802872e:	460b      	mov	r3, r1
 8028730:	4602      	mov	r2, r0
 8028732:	4903      	ldr	r1, [pc, #12]	; (8028740 <cblas_xerbla+0x38>)
 8028734:	68f0      	ldr	r0, [r6, #12]
 8028736:	f007 fc05 	bl	802ff44 <fiprintf>
 802873a:	e7ee      	b.n	802871a <cblas_xerbla+0x12>
 802873c:	200005cc 	.word	0x200005cc
 8028740:	080313d4 	.word	0x080313d4
	...

08028750 <memchr>:
 8028750:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8028754:	2a10      	cmp	r2, #16
 8028756:	db2b      	blt.n	80287b0 <memchr+0x60>
 8028758:	f010 0f07 	tst.w	r0, #7
 802875c:	d008      	beq.n	8028770 <memchr+0x20>
 802875e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8028762:	3a01      	subs	r2, #1
 8028764:	428b      	cmp	r3, r1
 8028766:	d02d      	beq.n	80287c4 <memchr+0x74>
 8028768:	f010 0f07 	tst.w	r0, #7
 802876c:	b342      	cbz	r2, 80287c0 <memchr+0x70>
 802876e:	d1f6      	bne.n	802875e <memchr+0xe>
 8028770:	b4f0      	push	{r4, r5, r6, r7}
 8028772:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8028776:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 802877a:	f022 0407 	bic.w	r4, r2, #7
 802877e:	f07f 0700 	mvns.w	r7, #0
 8028782:	2300      	movs	r3, #0
 8028784:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8028788:	3c08      	subs	r4, #8
 802878a:	ea85 0501 	eor.w	r5, r5, r1
 802878e:	ea86 0601 	eor.w	r6, r6, r1
 8028792:	fa85 f547 	uadd8	r5, r5, r7
 8028796:	faa3 f587 	sel	r5, r3, r7
 802879a:	fa86 f647 	uadd8	r6, r6, r7
 802879e:	faa5 f687 	sel	r6, r5, r7
 80287a2:	b98e      	cbnz	r6, 80287c8 <memchr+0x78>
 80287a4:	d1ee      	bne.n	8028784 <memchr+0x34>
 80287a6:	bcf0      	pop	{r4, r5, r6, r7}
 80287a8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80287ac:	f002 0207 	and.w	r2, r2, #7
 80287b0:	b132      	cbz	r2, 80287c0 <memchr+0x70>
 80287b2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80287b6:	3a01      	subs	r2, #1
 80287b8:	ea83 0301 	eor.w	r3, r3, r1
 80287bc:	b113      	cbz	r3, 80287c4 <memchr+0x74>
 80287be:	d1f8      	bne.n	80287b2 <memchr+0x62>
 80287c0:	2000      	movs	r0, #0
 80287c2:	4770      	bx	lr
 80287c4:	3801      	subs	r0, #1
 80287c6:	4770      	bx	lr
 80287c8:	2d00      	cmp	r5, #0
 80287ca:	bf06      	itte	eq
 80287cc:	4635      	moveq	r5, r6
 80287ce:	3803      	subeq	r0, #3
 80287d0:	3807      	subne	r0, #7
 80287d2:	f015 0f01 	tst.w	r5, #1
 80287d6:	d107      	bne.n	80287e8 <memchr+0x98>
 80287d8:	3001      	adds	r0, #1
 80287da:	f415 7f80 	tst.w	r5, #256	; 0x100
 80287de:	bf02      	ittt	eq
 80287e0:	3001      	addeq	r0, #1
 80287e2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80287e6:	3001      	addeq	r0, #1
 80287e8:	bcf0      	pop	{r4, r5, r6, r7}
 80287ea:	3801      	subs	r0, #1
 80287ec:	4770      	bx	lr
 80287ee:	bf00      	nop

080287f0 <__aeabi_drsub>:
 80287f0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80287f4:	e002      	b.n	80287fc <__adddf3>
 80287f6:	bf00      	nop

080287f8 <__aeabi_dsub>:
 80287f8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080287fc <__adddf3>:
 80287fc:	b530      	push	{r4, r5, lr}
 80287fe:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8028802:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8028806:	ea94 0f05 	teq	r4, r5
 802880a:	bf08      	it	eq
 802880c:	ea90 0f02 	teqeq	r0, r2
 8028810:	bf1f      	itttt	ne
 8028812:	ea54 0c00 	orrsne.w	ip, r4, r0
 8028816:	ea55 0c02 	orrsne.w	ip, r5, r2
 802881a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 802881e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8028822:	f000 80e2 	beq.w	80289ea <__adddf3+0x1ee>
 8028826:	ea4f 5454 	mov.w	r4, r4, lsr #21
 802882a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 802882e:	bfb8      	it	lt
 8028830:	426d      	neglt	r5, r5
 8028832:	dd0c      	ble.n	802884e <__adddf3+0x52>
 8028834:	442c      	add	r4, r5
 8028836:	ea80 0202 	eor.w	r2, r0, r2
 802883a:	ea81 0303 	eor.w	r3, r1, r3
 802883e:	ea82 0000 	eor.w	r0, r2, r0
 8028842:	ea83 0101 	eor.w	r1, r3, r1
 8028846:	ea80 0202 	eor.w	r2, r0, r2
 802884a:	ea81 0303 	eor.w	r3, r1, r3
 802884e:	2d36      	cmp	r5, #54	; 0x36
 8028850:	bf88      	it	hi
 8028852:	bd30      	pophi	{r4, r5, pc}
 8028854:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8028858:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802885c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8028860:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8028864:	d002      	beq.n	802886c <__adddf3+0x70>
 8028866:	4240      	negs	r0, r0
 8028868:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 802886c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8028870:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8028874:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8028878:	d002      	beq.n	8028880 <__adddf3+0x84>
 802887a:	4252      	negs	r2, r2
 802887c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8028880:	ea94 0f05 	teq	r4, r5
 8028884:	f000 80a7 	beq.w	80289d6 <__adddf3+0x1da>
 8028888:	f1a4 0401 	sub.w	r4, r4, #1
 802888c:	f1d5 0e20 	rsbs	lr, r5, #32
 8028890:	db0d      	blt.n	80288ae <__adddf3+0xb2>
 8028892:	fa02 fc0e 	lsl.w	ip, r2, lr
 8028896:	fa22 f205 	lsr.w	r2, r2, r5
 802889a:	1880      	adds	r0, r0, r2
 802889c:	f141 0100 	adc.w	r1, r1, #0
 80288a0:	fa03 f20e 	lsl.w	r2, r3, lr
 80288a4:	1880      	adds	r0, r0, r2
 80288a6:	fa43 f305 	asr.w	r3, r3, r5
 80288aa:	4159      	adcs	r1, r3
 80288ac:	e00e      	b.n	80288cc <__adddf3+0xd0>
 80288ae:	f1a5 0520 	sub.w	r5, r5, #32
 80288b2:	f10e 0e20 	add.w	lr, lr, #32
 80288b6:	2a01      	cmp	r2, #1
 80288b8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80288bc:	bf28      	it	cs
 80288be:	f04c 0c02 	orrcs.w	ip, ip, #2
 80288c2:	fa43 f305 	asr.w	r3, r3, r5
 80288c6:	18c0      	adds	r0, r0, r3
 80288c8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80288cc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80288d0:	d507      	bpl.n	80288e2 <__adddf3+0xe6>
 80288d2:	f04f 0e00 	mov.w	lr, #0
 80288d6:	f1dc 0c00 	rsbs	ip, ip, #0
 80288da:	eb7e 0000 	sbcs.w	r0, lr, r0
 80288de:	eb6e 0101 	sbc.w	r1, lr, r1
 80288e2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80288e6:	d31b      	bcc.n	8028920 <__adddf3+0x124>
 80288e8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80288ec:	d30c      	bcc.n	8028908 <__adddf3+0x10c>
 80288ee:	0849      	lsrs	r1, r1, #1
 80288f0:	ea5f 0030 	movs.w	r0, r0, rrx
 80288f4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80288f8:	f104 0401 	add.w	r4, r4, #1
 80288fc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8028900:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8028904:	f080 809a 	bcs.w	8028a3c <__adddf3+0x240>
 8028908:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 802890c:	bf08      	it	eq
 802890e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8028912:	f150 0000 	adcs.w	r0, r0, #0
 8028916:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802891a:	ea41 0105 	orr.w	r1, r1, r5
 802891e:	bd30      	pop	{r4, r5, pc}
 8028920:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8028924:	4140      	adcs	r0, r0
 8028926:	eb41 0101 	adc.w	r1, r1, r1
 802892a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 802892e:	f1a4 0401 	sub.w	r4, r4, #1
 8028932:	d1e9      	bne.n	8028908 <__adddf3+0x10c>
 8028934:	f091 0f00 	teq	r1, #0
 8028938:	bf04      	itt	eq
 802893a:	4601      	moveq	r1, r0
 802893c:	2000      	moveq	r0, #0
 802893e:	fab1 f381 	clz	r3, r1
 8028942:	bf08      	it	eq
 8028944:	3320      	addeq	r3, #32
 8028946:	f1a3 030b 	sub.w	r3, r3, #11
 802894a:	f1b3 0220 	subs.w	r2, r3, #32
 802894e:	da0c      	bge.n	802896a <__adddf3+0x16e>
 8028950:	320c      	adds	r2, #12
 8028952:	dd08      	ble.n	8028966 <__adddf3+0x16a>
 8028954:	f102 0c14 	add.w	ip, r2, #20
 8028958:	f1c2 020c 	rsb	r2, r2, #12
 802895c:	fa01 f00c 	lsl.w	r0, r1, ip
 8028960:	fa21 f102 	lsr.w	r1, r1, r2
 8028964:	e00c      	b.n	8028980 <__adddf3+0x184>
 8028966:	f102 0214 	add.w	r2, r2, #20
 802896a:	bfd8      	it	le
 802896c:	f1c2 0c20 	rsble	ip, r2, #32
 8028970:	fa01 f102 	lsl.w	r1, r1, r2
 8028974:	fa20 fc0c 	lsr.w	ip, r0, ip
 8028978:	bfdc      	itt	le
 802897a:	ea41 010c 	orrle.w	r1, r1, ip
 802897e:	4090      	lslle	r0, r2
 8028980:	1ae4      	subs	r4, r4, r3
 8028982:	bfa2      	ittt	ge
 8028984:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8028988:	4329      	orrge	r1, r5
 802898a:	bd30      	popge	{r4, r5, pc}
 802898c:	ea6f 0404 	mvn.w	r4, r4
 8028990:	3c1f      	subs	r4, #31
 8028992:	da1c      	bge.n	80289ce <__adddf3+0x1d2>
 8028994:	340c      	adds	r4, #12
 8028996:	dc0e      	bgt.n	80289b6 <__adddf3+0x1ba>
 8028998:	f104 0414 	add.w	r4, r4, #20
 802899c:	f1c4 0220 	rsb	r2, r4, #32
 80289a0:	fa20 f004 	lsr.w	r0, r0, r4
 80289a4:	fa01 f302 	lsl.w	r3, r1, r2
 80289a8:	ea40 0003 	orr.w	r0, r0, r3
 80289ac:	fa21 f304 	lsr.w	r3, r1, r4
 80289b0:	ea45 0103 	orr.w	r1, r5, r3
 80289b4:	bd30      	pop	{r4, r5, pc}
 80289b6:	f1c4 040c 	rsb	r4, r4, #12
 80289ba:	f1c4 0220 	rsb	r2, r4, #32
 80289be:	fa20 f002 	lsr.w	r0, r0, r2
 80289c2:	fa01 f304 	lsl.w	r3, r1, r4
 80289c6:	ea40 0003 	orr.w	r0, r0, r3
 80289ca:	4629      	mov	r1, r5
 80289cc:	bd30      	pop	{r4, r5, pc}
 80289ce:	fa21 f004 	lsr.w	r0, r1, r4
 80289d2:	4629      	mov	r1, r5
 80289d4:	bd30      	pop	{r4, r5, pc}
 80289d6:	f094 0f00 	teq	r4, #0
 80289da:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80289de:	bf06      	itte	eq
 80289e0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80289e4:	3401      	addeq	r4, #1
 80289e6:	3d01      	subne	r5, #1
 80289e8:	e74e      	b.n	8028888 <__adddf3+0x8c>
 80289ea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80289ee:	bf18      	it	ne
 80289f0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80289f4:	d029      	beq.n	8028a4a <__adddf3+0x24e>
 80289f6:	ea94 0f05 	teq	r4, r5
 80289fa:	bf08      	it	eq
 80289fc:	ea90 0f02 	teqeq	r0, r2
 8028a00:	d005      	beq.n	8028a0e <__adddf3+0x212>
 8028a02:	ea54 0c00 	orrs.w	ip, r4, r0
 8028a06:	bf04      	itt	eq
 8028a08:	4619      	moveq	r1, r3
 8028a0a:	4610      	moveq	r0, r2
 8028a0c:	bd30      	pop	{r4, r5, pc}
 8028a0e:	ea91 0f03 	teq	r1, r3
 8028a12:	bf1e      	ittt	ne
 8028a14:	2100      	movne	r1, #0
 8028a16:	2000      	movne	r0, #0
 8028a18:	bd30      	popne	{r4, r5, pc}
 8028a1a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8028a1e:	d105      	bne.n	8028a2c <__adddf3+0x230>
 8028a20:	0040      	lsls	r0, r0, #1
 8028a22:	4149      	adcs	r1, r1
 8028a24:	bf28      	it	cs
 8028a26:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8028a2a:	bd30      	pop	{r4, r5, pc}
 8028a2c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8028a30:	bf3c      	itt	cc
 8028a32:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8028a36:	bd30      	popcc	{r4, r5, pc}
 8028a38:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8028a3c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8028a40:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8028a44:	f04f 0000 	mov.w	r0, #0
 8028a48:	bd30      	pop	{r4, r5, pc}
 8028a4a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8028a4e:	bf1a      	itte	ne
 8028a50:	4619      	movne	r1, r3
 8028a52:	4610      	movne	r0, r2
 8028a54:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8028a58:	bf1c      	itt	ne
 8028a5a:	460b      	movne	r3, r1
 8028a5c:	4602      	movne	r2, r0
 8028a5e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8028a62:	bf06      	itte	eq
 8028a64:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8028a68:	ea91 0f03 	teqeq	r1, r3
 8028a6c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8028a70:	bd30      	pop	{r4, r5, pc}
 8028a72:	bf00      	nop

08028a74 <__aeabi_ui2d>:
 8028a74:	f090 0f00 	teq	r0, #0
 8028a78:	bf04      	itt	eq
 8028a7a:	2100      	moveq	r1, #0
 8028a7c:	4770      	bxeq	lr
 8028a7e:	b530      	push	{r4, r5, lr}
 8028a80:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8028a84:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8028a88:	f04f 0500 	mov.w	r5, #0
 8028a8c:	f04f 0100 	mov.w	r1, #0
 8028a90:	e750      	b.n	8028934 <__adddf3+0x138>
 8028a92:	bf00      	nop

08028a94 <__aeabi_i2d>:
 8028a94:	f090 0f00 	teq	r0, #0
 8028a98:	bf04      	itt	eq
 8028a9a:	2100      	moveq	r1, #0
 8028a9c:	4770      	bxeq	lr
 8028a9e:	b530      	push	{r4, r5, lr}
 8028aa0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8028aa4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8028aa8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8028aac:	bf48      	it	mi
 8028aae:	4240      	negmi	r0, r0
 8028ab0:	f04f 0100 	mov.w	r1, #0
 8028ab4:	e73e      	b.n	8028934 <__adddf3+0x138>
 8028ab6:	bf00      	nop

08028ab8 <__aeabi_f2d>:
 8028ab8:	0042      	lsls	r2, r0, #1
 8028aba:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8028abe:	ea4f 0131 	mov.w	r1, r1, rrx
 8028ac2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8028ac6:	bf1f      	itttt	ne
 8028ac8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8028acc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8028ad0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8028ad4:	4770      	bxne	lr
 8028ad6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8028ada:	bf08      	it	eq
 8028adc:	4770      	bxeq	lr
 8028ade:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8028ae2:	bf04      	itt	eq
 8028ae4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8028ae8:	4770      	bxeq	lr
 8028aea:	b530      	push	{r4, r5, lr}
 8028aec:	f44f 7460 	mov.w	r4, #896	; 0x380
 8028af0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8028af4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8028af8:	e71c      	b.n	8028934 <__adddf3+0x138>
 8028afa:	bf00      	nop

08028afc <__aeabi_ul2d>:
 8028afc:	ea50 0201 	orrs.w	r2, r0, r1
 8028b00:	bf08      	it	eq
 8028b02:	4770      	bxeq	lr
 8028b04:	b530      	push	{r4, r5, lr}
 8028b06:	f04f 0500 	mov.w	r5, #0
 8028b0a:	e00a      	b.n	8028b22 <__aeabi_l2d+0x16>

08028b0c <__aeabi_l2d>:
 8028b0c:	ea50 0201 	orrs.w	r2, r0, r1
 8028b10:	bf08      	it	eq
 8028b12:	4770      	bxeq	lr
 8028b14:	b530      	push	{r4, r5, lr}
 8028b16:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8028b1a:	d502      	bpl.n	8028b22 <__aeabi_l2d+0x16>
 8028b1c:	4240      	negs	r0, r0
 8028b1e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8028b22:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8028b26:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8028b2a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8028b2e:	f43f aed8 	beq.w	80288e2 <__adddf3+0xe6>
 8028b32:	f04f 0203 	mov.w	r2, #3
 8028b36:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8028b3a:	bf18      	it	ne
 8028b3c:	3203      	addne	r2, #3
 8028b3e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8028b42:	bf18      	it	ne
 8028b44:	3203      	addne	r2, #3
 8028b46:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8028b4a:	f1c2 0320 	rsb	r3, r2, #32
 8028b4e:	fa00 fc03 	lsl.w	ip, r0, r3
 8028b52:	fa20 f002 	lsr.w	r0, r0, r2
 8028b56:	fa01 fe03 	lsl.w	lr, r1, r3
 8028b5a:	ea40 000e 	orr.w	r0, r0, lr
 8028b5e:	fa21 f102 	lsr.w	r1, r1, r2
 8028b62:	4414      	add	r4, r2
 8028b64:	e6bd      	b.n	80288e2 <__adddf3+0xe6>
 8028b66:	bf00      	nop

08028b68 <__aeabi_dmul>:
 8028b68:	b570      	push	{r4, r5, r6, lr}
 8028b6a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8028b6e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8028b72:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8028b76:	bf1d      	ittte	ne
 8028b78:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8028b7c:	ea94 0f0c 	teqne	r4, ip
 8028b80:	ea95 0f0c 	teqne	r5, ip
 8028b84:	f000 f8de 	bleq	8028d44 <__aeabi_dmul+0x1dc>
 8028b88:	442c      	add	r4, r5
 8028b8a:	ea81 0603 	eor.w	r6, r1, r3
 8028b8e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8028b92:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8028b96:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8028b9a:	bf18      	it	ne
 8028b9c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8028ba0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8028ba4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8028ba8:	d038      	beq.n	8028c1c <__aeabi_dmul+0xb4>
 8028baa:	fba0 ce02 	umull	ip, lr, r0, r2
 8028bae:	f04f 0500 	mov.w	r5, #0
 8028bb2:	fbe1 e502 	umlal	lr, r5, r1, r2
 8028bb6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8028bba:	fbe0 e503 	umlal	lr, r5, r0, r3
 8028bbe:	f04f 0600 	mov.w	r6, #0
 8028bc2:	fbe1 5603 	umlal	r5, r6, r1, r3
 8028bc6:	f09c 0f00 	teq	ip, #0
 8028bca:	bf18      	it	ne
 8028bcc:	f04e 0e01 	orrne.w	lr, lr, #1
 8028bd0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8028bd4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8028bd8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8028bdc:	d204      	bcs.n	8028be8 <__aeabi_dmul+0x80>
 8028bde:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8028be2:	416d      	adcs	r5, r5
 8028be4:	eb46 0606 	adc.w	r6, r6, r6
 8028be8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8028bec:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8028bf0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8028bf4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8028bf8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8028bfc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8028c00:	bf88      	it	hi
 8028c02:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8028c06:	d81e      	bhi.n	8028c46 <__aeabi_dmul+0xde>
 8028c08:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8028c0c:	bf08      	it	eq
 8028c0e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8028c12:	f150 0000 	adcs.w	r0, r0, #0
 8028c16:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8028c1a:	bd70      	pop	{r4, r5, r6, pc}
 8028c1c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8028c20:	ea46 0101 	orr.w	r1, r6, r1
 8028c24:	ea40 0002 	orr.w	r0, r0, r2
 8028c28:	ea81 0103 	eor.w	r1, r1, r3
 8028c2c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8028c30:	bfc2      	ittt	gt
 8028c32:	ebd4 050c 	rsbsgt	r5, r4, ip
 8028c36:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8028c3a:	bd70      	popgt	{r4, r5, r6, pc}
 8028c3c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8028c40:	f04f 0e00 	mov.w	lr, #0
 8028c44:	3c01      	subs	r4, #1
 8028c46:	f300 80ab 	bgt.w	8028da0 <__aeabi_dmul+0x238>
 8028c4a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8028c4e:	bfde      	ittt	le
 8028c50:	2000      	movle	r0, #0
 8028c52:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8028c56:	bd70      	pople	{r4, r5, r6, pc}
 8028c58:	f1c4 0400 	rsb	r4, r4, #0
 8028c5c:	3c20      	subs	r4, #32
 8028c5e:	da35      	bge.n	8028ccc <__aeabi_dmul+0x164>
 8028c60:	340c      	adds	r4, #12
 8028c62:	dc1b      	bgt.n	8028c9c <__aeabi_dmul+0x134>
 8028c64:	f104 0414 	add.w	r4, r4, #20
 8028c68:	f1c4 0520 	rsb	r5, r4, #32
 8028c6c:	fa00 f305 	lsl.w	r3, r0, r5
 8028c70:	fa20 f004 	lsr.w	r0, r0, r4
 8028c74:	fa01 f205 	lsl.w	r2, r1, r5
 8028c78:	ea40 0002 	orr.w	r0, r0, r2
 8028c7c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8028c80:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8028c84:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8028c88:	fa21 f604 	lsr.w	r6, r1, r4
 8028c8c:	eb42 0106 	adc.w	r1, r2, r6
 8028c90:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8028c94:	bf08      	it	eq
 8028c96:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8028c9a:	bd70      	pop	{r4, r5, r6, pc}
 8028c9c:	f1c4 040c 	rsb	r4, r4, #12
 8028ca0:	f1c4 0520 	rsb	r5, r4, #32
 8028ca4:	fa00 f304 	lsl.w	r3, r0, r4
 8028ca8:	fa20 f005 	lsr.w	r0, r0, r5
 8028cac:	fa01 f204 	lsl.w	r2, r1, r4
 8028cb0:	ea40 0002 	orr.w	r0, r0, r2
 8028cb4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8028cb8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8028cbc:	f141 0100 	adc.w	r1, r1, #0
 8028cc0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8028cc4:	bf08      	it	eq
 8028cc6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8028cca:	bd70      	pop	{r4, r5, r6, pc}
 8028ccc:	f1c4 0520 	rsb	r5, r4, #32
 8028cd0:	fa00 f205 	lsl.w	r2, r0, r5
 8028cd4:	ea4e 0e02 	orr.w	lr, lr, r2
 8028cd8:	fa20 f304 	lsr.w	r3, r0, r4
 8028cdc:	fa01 f205 	lsl.w	r2, r1, r5
 8028ce0:	ea43 0302 	orr.w	r3, r3, r2
 8028ce4:	fa21 f004 	lsr.w	r0, r1, r4
 8028ce8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8028cec:	fa21 f204 	lsr.w	r2, r1, r4
 8028cf0:	ea20 0002 	bic.w	r0, r0, r2
 8028cf4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8028cf8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8028cfc:	bf08      	it	eq
 8028cfe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8028d02:	bd70      	pop	{r4, r5, r6, pc}
 8028d04:	f094 0f00 	teq	r4, #0
 8028d08:	d10f      	bne.n	8028d2a <__aeabi_dmul+0x1c2>
 8028d0a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8028d0e:	0040      	lsls	r0, r0, #1
 8028d10:	eb41 0101 	adc.w	r1, r1, r1
 8028d14:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8028d18:	bf08      	it	eq
 8028d1a:	3c01      	subeq	r4, #1
 8028d1c:	d0f7      	beq.n	8028d0e <__aeabi_dmul+0x1a6>
 8028d1e:	ea41 0106 	orr.w	r1, r1, r6
 8028d22:	f095 0f00 	teq	r5, #0
 8028d26:	bf18      	it	ne
 8028d28:	4770      	bxne	lr
 8028d2a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8028d2e:	0052      	lsls	r2, r2, #1
 8028d30:	eb43 0303 	adc.w	r3, r3, r3
 8028d34:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8028d38:	bf08      	it	eq
 8028d3a:	3d01      	subeq	r5, #1
 8028d3c:	d0f7      	beq.n	8028d2e <__aeabi_dmul+0x1c6>
 8028d3e:	ea43 0306 	orr.w	r3, r3, r6
 8028d42:	4770      	bx	lr
 8028d44:	ea94 0f0c 	teq	r4, ip
 8028d48:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8028d4c:	bf18      	it	ne
 8028d4e:	ea95 0f0c 	teqne	r5, ip
 8028d52:	d00c      	beq.n	8028d6e <__aeabi_dmul+0x206>
 8028d54:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8028d58:	bf18      	it	ne
 8028d5a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8028d5e:	d1d1      	bne.n	8028d04 <__aeabi_dmul+0x19c>
 8028d60:	ea81 0103 	eor.w	r1, r1, r3
 8028d64:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8028d68:	f04f 0000 	mov.w	r0, #0
 8028d6c:	bd70      	pop	{r4, r5, r6, pc}
 8028d6e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8028d72:	bf06      	itte	eq
 8028d74:	4610      	moveq	r0, r2
 8028d76:	4619      	moveq	r1, r3
 8028d78:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8028d7c:	d019      	beq.n	8028db2 <__aeabi_dmul+0x24a>
 8028d7e:	ea94 0f0c 	teq	r4, ip
 8028d82:	d102      	bne.n	8028d8a <__aeabi_dmul+0x222>
 8028d84:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8028d88:	d113      	bne.n	8028db2 <__aeabi_dmul+0x24a>
 8028d8a:	ea95 0f0c 	teq	r5, ip
 8028d8e:	d105      	bne.n	8028d9c <__aeabi_dmul+0x234>
 8028d90:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8028d94:	bf1c      	itt	ne
 8028d96:	4610      	movne	r0, r2
 8028d98:	4619      	movne	r1, r3
 8028d9a:	d10a      	bne.n	8028db2 <__aeabi_dmul+0x24a>
 8028d9c:	ea81 0103 	eor.w	r1, r1, r3
 8028da0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8028da4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8028da8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8028dac:	f04f 0000 	mov.w	r0, #0
 8028db0:	bd70      	pop	{r4, r5, r6, pc}
 8028db2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8028db6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8028dba:	bd70      	pop	{r4, r5, r6, pc}

08028dbc <__aeabi_ddiv>:
 8028dbc:	b570      	push	{r4, r5, r6, lr}
 8028dbe:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8028dc2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8028dc6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8028dca:	bf1d      	ittte	ne
 8028dcc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8028dd0:	ea94 0f0c 	teqne	r4, ip
 8028dd4:	ea95 0f0c 	teqne	r5, ip
 8028dd8:	f000 f8a7 	bleq	8028f2a <__aeabi_ddiv+0x16e>
 8028ddc:	eba4 0405 	sub.w	r4, r4, r5
 8028de0:	ea81 0e03 	eor.w	lr, r1, r3
 8028de4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8028de8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8028dec:	f000 8088 	beq.w	8028f00 <__aeabi_ddiv+0x144>
 8028df0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8028df4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8028df8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8028dfc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8028e00:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8028e04:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8028e08:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8028e0c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8028e10:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8028e14:	429d      	cmp	r5, r3
 8028e16:	bf08      	it	eq
 8028e18:	4296      	cmpeq	r6, r2
 8028e1a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8028e1e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8028e22:	d202      	bcs.n	8028e2a <__aeabi_ddiv+0x6e>
 8028e24:	085b      	lsrs	r3, r3, #1
 8028e26:	ea4f 0232 	mov.w	r2, r2, rrx
 8028e2a:	1ab6      	subs	r6, r6, r2
 8028e2c:	eb65 0503 	sbc.w	r5, r5, r3
 8028e30:	085b      	lsrs	r3, r3, #1
 8028e32:	ea4f 0232 	mov.w	r2, r2, rrx
 8028e36:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8028e3a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8028e3e:	ebb6 0e02 	subs.w	lr, r6, r2
 8028e42:	eb75 0e03 	sbcs.w	lr, r5, r3
 8028e46:	bf22      	ittt	cs
 8028e48:	1ab6      	subcs	r6, r6, r2
 8028e4a:	4675      	movcs	r5, lr
 8028e4c:	ea40 000c 	orrcs.w	r0, r0, ip
 8028e50:	085b      	lsrs	r3, r3, #1
 8028e52:	ea4f 0232 	mov.w	r2, r2, rrx
 8028e56:	ebb6 0e02 	subs.w	lr, r6, r2
 8028e5a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8028e5e:	bf22      	ittt	cs
 8028e60:	1ab6      	subcs	r6, r6, r2
 8028e62:	4675      	movcs	r5, lr
 8028e64:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8028e68:	085b      	lsrs	r3, r3, #1
 8028e6a:	ea4f 0232 	mov.w	r2, r2, rrx
 8028e6e:	ebb6 0e02 	subs.w	lr, r6, r2
 8028e72:	eb75 0e03 	sbcs.w	lr, r5, r3
 8028e76:	bf22      	ittt	cs
 8028e78:	1ab6      	subcs	r6, r6, r2
 8028e7a:	4675      	movcs	r5, lr
 8028e7c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8028e80:	085b      	lsrs	r3, r3, #1
 8028e82:	ea4f 0232 	mov.w	r2, r2, rrx
 8028e86:	ebb6 0e02 	subs.w	lr, r6, r2
 8028e8a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8028e8e:	bf22      	ittt	cs
 8028e90:	1ab6      	subcs	r6, r6, r2
 8028e92:	4675      	movcs	r5, lr
 8028e94:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8028e98:	ea55 0e06 	orrs.w	lr, r5, r6
 8028e9c:	d018      	beq.n	8028ed0 <__aeabi_ddiv+0x114>
 8028e9e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8028ea2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8028ea6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8028eaa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8028eae:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8028eb2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8028eb6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8028eba:	d1c0      	bne.n	8028e3e <__aeabi_ddiv+0x82>
 8028ebc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8028ec0:	d10b      	bne.n	8028eda <__aeabi_ddiv+0x11e>
 8028ec2:	ea41 0100 	orr.w	r1, r1, r0
 8028ec6:	f04f 0000 	mov.w	r0, #0
 8028eca:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8028ece:	e7b6      	b.n	8028e3e <__aeabi_ddiv+0x82>
 8028ed0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8028ed4:	bf04      	itt	eq
 8028ed6:	4301      	orreq	r1, r0
 8028ed8:	2000      	moveq	r0, #0
 8028eda:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8028ede:	bf88      	it	hi
 8028ee0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8028ee4:	f63f aeaf 	bhi.w	8028c46 <__aeabi_dmul+0xde>
 8028ee8:	ebb5 0c03 	subs.w	ip, r5, r3
 8028eec:	bf04      	itt	eq
 8028eee:	ebb6 0c02 	subseq.w	ip, r6, r2
 8028ef2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8028ef6:	f150 0000 	adcs.w	r0, r0, #0
 8028efa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8028efe:	bd70      	pop	{r4, r5, r6, pc}
 8028f00:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8028f04:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8028f08:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8028f0c:	bfc2      	ittt	gt
 8028f0e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8028f12:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8028f16:	bd70      	popgt	{r4, r5, r6, pc}
 8028f18:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8028f1c:	f04f 0e00 	mov.w	lr, #0
 8028f20:	3c01      	subs	r4, #1
 8028f22:	e690      	b.n	8028c46 <__aeabi_dmul+0xde>
 8028f24:	ea45 0e06 	orr.w	lr, r5, r6
 8028f28:	e68d      	b.n	8028c46 <__aeabi_dmul+0xde>
 8028f2a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8028f2e:	ea94 0f0c 	teq	r4, ip
 8028f32:	bf08      	it	eq
 8028f34:	ea95 0f0c 	teqeq	r5, ip
 8028f38:	f43f af3b 	beq.w	8028db2 <__aeabi_dmul+0x24a>
 8028f3c:	ea94 0f0c 	teq	r4, ip
 8028f40:	d10a      	bne.n	8028f58 <__aeabi_ddiv+0x19c>
 8028f42:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8028f46:	f47f af34 	bne.w	8028db2 <__aeabi_dmul+0x24a>
 8028f4a:	ea95 0f0c 	teq	r5, ip
 8028f4e:	f47f af25 	bne.w	8028d9c <__aeabi_dmul+0x234>
 8028f52:	4610      	mov	r0, r2
 8028f54:	4619      	mov	r1, r3
 8028f56:	e72c      	b.n	8028db2 <__aeabi_dmul+0x24a>
 8028f58:	ea95 0f0c 	teq	r5, ip
 8028f5c:	d106      	bne.n	8028f6c <__aeabi_ddiv+0x1b0>
 8028f5e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8028f62:	f43f aefd 	beq.w	8028d60 <__aeabi_dmul+0x1f8>
 8028f66:	4610      	mov	r0, r2
 8028f68:	4619      	mov	r1, r3
 8028f6a:	e722      	b.n	8028db2 <__aeabi_dmul+0x24a>
 8028f6c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8028f70:	bf18      	it	ne
 8028f72:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8028f76:	f47f aec5 	bne.w	8028d04 <__aeabi_dmul+0x19c>
 8028f7a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8028f7e:	f47f af0d 	bne.w	8028d9c <__aeabi_dmul+0x234>
 8028f82:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8028f86:	f47f aeeb 	bne.w	8028d60 <__aeabi_dmul+0x1f8>
 8028f8a:	e712      	b.n	8028db2 <__aeabi_dmul+0x24a>

08028f8c <__gedf2>:
 8028f8c:	f04f 3cff 	mov.w	ip, #4294967295
 8028f90:	e006      	b.n	8028fa0 <__cmpdf2+0x4>
 8028f92:	bf00      	nop

08028f94 <__ledf2>:
 8028f94:	f04f 0c01 	mov.w	ip, #1
 8028f98:	e002      	b.n	8028fa0 <__cmpdf2+0x4>
 8028f9a:	bf00      	nop

08028f9c <__cmpdf2>:
 8028f9c:	f04f 0c01 	mov.w	ip, #1
 8028fa0:	f84d cd04 	str.w	ip, [sp, #-4]!
 8028fa4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8028fa8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8028fac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8028fb0:	bf18      	it	ne
 8028fb2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8028fb6:	d01b      	beq.n	8028ff0 <__cmpdf2+0x54>
 8028fb8:	b001      	add	sp, #4
 8028fba:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8028fbe:	bf0c      	ite	eq
 8028fc0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8028fc4:	ea91 0f03 	teqne	r1, r3
 8028fc8:	bf02      	ittt	eq
 8028fca:	ea90 0f02 	teqeq	r0, r2
 8028fce:	2000      	moveq	r0, #0
 8028fd0:	4770      	bxeq	lr
 8028fd2:	f110 0f00 	cmn.w	r0, #0
 8028fd6:	ea91 0f03 	teq	r1, r3
 8028fda:	bf58      	it	pl
 8028fdc:	4299      	cmppl	r1, r3
 8028fde:	bf08      	it	eq
 8028fe0:	4290      	cmpeq	r0, r2
 8028fe2:	bf2c      	ite	cs
 8028fe4:	17d8      	asrcs	r0, r3, #31
 8028fe6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8028fea:	f040 0001 	orr.w	r0, r0, #1
 8028fee:	4770      	bx	lr
 8028ff0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8028ff4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8028ff8:	d102      	bne.n	8029000 <__cmpdf2+0x64>
 8028ffa:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8028ffe:	d107      	bne.n	8029010 <__cmpdf2+0x74>
 8029000:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8029004:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8029008:	d1d6      	bne.n	8028fb8 <__cmpdf2+0x1c>
 802900a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802900e:	d0d3      	beq.n	8028fb8 <__cmpdf2+0x1c>
 8029010:	f85d 0b04 	ldr.w	r0, [sp], #4
 8029014:	4770      	bx	lr
 8029016:	bf00      	nop

08029018 <__aeabi_cdrcmple>:
 8029018:	4684      	mov	ip, r0
 802901a:	4610      	mov	r0, r2
 802901c:	4662      	mov	r2, ip
 802901e:	468c      	mov	ip, r1
 8029020:	4619      	mov	r1, r3
 8029022:	4663      	mov	r3, ip
 8029024:	e000      	b.n	8029028 <__aeabi_cdcmpeq>
 8029026:	bf00      	nop

08029028 <__aeabi_cdcmpeq>:
 8029028:	b501      	push	{r0, lr}
 802902a:	f7ff ffb7 	bl	8028f9c <__cmpdf2>
 802902e:	2800      	cmp	r0, #0
 8029030:	bf48      	it	mi
 8029032:	f110 0f00 	cmnmi.w	r0, #0
 8029036:	bd01      	pop	{r0, pc}

08029038 <__aeabi_dcmpeq>:
 8029038:	f84d ed08 	str.w	lr, [sp, #-8]!
 802903c:	f7ff fff4 	bl	8029028 <__aeabi_cdcmpeq>
 8029040:	bf0c      	ite	eq
 8029042:	2001      	moveq	r0, #1
 8029044:	2000      	movne	r0, #0
 8029046:	f85d fb08 	ldr.w	pc, [sp], #8
 802904a:	bf00      	nop

0802904c <__aeabi_dcmplt>:
 802904c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8029050:	f7ff ffea 	bl	8029028 <__aeabi_cdcmpeq>
 8029054:	bf34      	ite	cc
 8029056:	2001      	movcc	r0, #1
 8029058:	2000      	movcs	r0, #0
 802905a:	f85d fb08 	ldr.w	pc, [sp], #8
 802905e:	bf00      	nop

08029060 <__aeabi_dcmple>:
 8029060:	f84d ed08 	str.w	lr, [sp, #-8]!
 8029064:	f7ff ffe0 	bl	8029028 <__aeabi_cdcmpeq>
 8029068:	bf94      	ite	ls
 802906a:	2001      	movls	r0, #1
 802906c:	2000      	movhi	r0, #0
 802906e:	f85d fb08 	ldr.w	pc, [sp], #8
 8029072:	bf00      	nop

08029074 <__aeabi_dcmpge>:
 8029074:	f84d ed08 	str.w	lr, [sp, #-8]!
 8029078:	f7ff ffce 	bl	8029018 <__aeabi_cdrcmple>
 802907c:	bf94      	ite	ls
 802907e:	2001      	movls	r0, #1
 8029080:	2000      	movhi	r0, #0
 8029082:	f85d fb08 	ldr.w	pc, [sp], #8
 8029086:	bf00      	nop

08029088 <__aeabi_dcmpgt>:
 8029088:	f84d ed08 	str.w	lr, [sp, #-8]!
 802908c:	f7ff ffc4 	bl	8029018 <__aeabi_cdrcmple>
 8029090:	bf34      	ite	cc
 8029092:	2001      	movcc	r0, #1
 8029094:	2000      	movcs	r0, #0
 8029096:	f85d fb08 	ldr.w	pc, [sp], #8
 802909a:	bf00      	nop

0802909c <__aeabi_dcmpun>:
 802909c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80290a0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80290a4:	d102      	bne.n	80290ac <__aeabi_dcmpun+0x10>
 80290a6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80290aa:	d10a      	bne.n	80290c2 <__aeabi_dcmpun+0x26>
 80290ac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80290b0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80290b4:	d102      	bne.n	80290bc <__aeabi_dcmpun+0x20>
 80290b6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80290ba:	d102      	bne.n	80290c2 <__aeabi_dcmpun+0x26>
 80290bc:	f04f 0000 	mov.w	r0, #0
 80290c0:	4770      	bx	lr
 80290c2:	f04f 0001 	mov.w	r0, #1
 80290c6:	4770      	bx	lr

080290c8 <__aeabi_d2f>:
 80290c8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80290cc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80290d0:	bf24      	itt	cs
 80290d2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80290d6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80290da:	d90d      	bls.n	80290f8 <__aeabi_d2f+0x30>
 80290dc:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80290e0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80290e4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80290e8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80290ec:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80290f0:	bf08      	it	eq
 80290f2:	f020 0001 	biceq.w	r0, r0, #1
 80290f6:	4770      	bx	lr
 80290f8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80290fc:	d121      	bne.n	8029142 <__aeabi_d2f+0x7a>
 80290fe:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8029102:	bfbc      	itt	lt
 8029104:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8029108:	4770      	bxlt	lr
 802910a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802910e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8029112:	f1c2 0218 	rsb	r2, r2, #24
 8029116:	f1c2 0c20 	rsb	ip, r2, #32
 802911a:	fa10 f30c 	lsls.w	r3, r0, ip
 802911e:	fa20 f002 	lsr.w	r0, r0, r2
 8029122:	bf18      	it	ne
 8029124:	f040 0001 	orrne.w	r0, r0, #1
 8029128:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802912c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8029130:	fa03 fc0c 	lsl.w	ip, r3, ip
 8029134:	ea40 000c 	orr.w	r0, r0, ip
 8029138:	fa23 f302 	lsr.w	r3, r3, r2
 802913c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8029140:	e7cc      	b.n	80290dc <__aeabi_d2f+0x14>
 8029142:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8029146:	d107      	bne.n	8029158 <__aeabi_d2f+0x90>
 8029148:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 802914c:	bf1e      	ittt	ne
 802914e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8029152:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8029156:	4770      	bxne	lr
 8029158:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 802915c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8029160:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8029164:	4770      	bx	lr
 8029166:	bf00      	nop

08029168 <__aeabi_uldivmod>:
 8029168:	b953      	cbnz	r3, 8029180 <__aeabi_uldivmod+0x18>
 802916a:	b94a      	cbnz	r2, 8029180 <__aeabi_uldivmod+0x18>
 802916c:	2900      	cmp	r1, #0
 802916e:	bf08      	it	eq
 8029170:	2800      	cmpeq	r0, #0
 8029172:	bf1c      	itt	ne
 8029174:	f04f 31ff 	movne.w	r1, #4294967295
 8029178:	f04f 30ff 	movne.w	r0, #4294967295
 802917c:	f000 b972 	b.w	8029464 <__aeabi_idiv0>
 8029180:	f1ad 0c08 	sub.w	ip, sp, #8
 8029184:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8029188:	f000 f806 	bl	8029198 <__udivmoddi4>
 802918c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8029190:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8029194:	b004      	add	sp, #16
 8029196:	4770      	bx	lr

08029198 <__udivmoddi4>:
 8029198:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802919c:	9e08      	ldr	r6, [sp, #32]
 802919e:	4604      	mov	r4, r0
 80291a0:	4688      	mov	r8, r1
 80291a2:	2b00      	cmp	r3, #0
 80291a4:	d14b      	bne.n	802923e <__udivmoddi4+0xa6>
 80291a6:	428a      	cmp	r2, r1
 80291a8:	4615      	mov	r5, r2
 80291aa:	d967      	bls.n	802927c <__udivmoddi4+0xe4>
 80291ac:	fab2 f282 	clz	r2, r2
 80291b0:	b14a      	cbz	r2, 80291c6 <__udivmoddi4+0x2e>
 80291b2:	f1c2 0720 	rsb	r7, r2, #32
 80291b6:	fa01 f302 	lsl.w	r3, r1, r2
 80291ba:	fa20 f707 	lsr.w	r7, r0, r7
 80291be:	4095      	lsls	r5, r2
 80291c0:	ea47 0803 	orr.w	r8, r7, r3
 80291c4:	4094      	lsls	r4, r2
 80291c6:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80291ca:	0c23      	lsrs	r3, r4, #16
 80291cc:	fbb8 f7fe 	udiv	r7, r8, lr
 80291d0:	fa1f fc85 	uxth.w	ip, r5
 80291d4:	fb0e 8817 	mls	r8, lr, r7, r8
 80291d8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80291dc:	fb07 f10c 	mul.w	r1, r7, ip
 80291e0:	4299      	cmp	r1, r3
 80291e2:	d909      	bls.n	80291f8 <__udivmoddi4+0x60>
 80291e4:	18eb      	adds	r3, r5, r3
 80291e6:	f107 30ff 	add.w	r0, r7, #4294967295
 80291ea:	f080 811b 	bcs.w	8029424 <__udivmoddi4+0x28c>
 80291ee:	4299      	cmp	r1, r3
 80291f0:	f240 8118 	bls.w	8029424 <__udivmoddi4+0x28c>
 80291f4:	3f02      	subs	r7, #2
 80291f6:	442b      	add	r3, r5
 80291f8:	1a5b      	subs	r3, r3, r1
 80291fa:	b2a4      	uxth	r4, r4
 80291fc:	fbb3 f0fe 	udiv	r0, r3, lr
 8029200:	fb0e 3310 	mls	r3, lr, r0, r3
 8029204:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8029208:	fb00 fc0c 	mul.w	ip, r0, ip
 802920c:	45a4      	cmp	ip, r4
 802920e:	d909      	bls.n	8029224 <__udivmoddi4+0x8c>
 8029210:	192c      	adds	r4, r5, r4
 8029212:	f100 33ff 	add.w	r3, r0, #4294967295
 8029216:	f080 8107 	bcs.w	8029428 <__udivmoddi4+0x290>
 802921a:	45a4      	cmp	ip, r4
 802921c:	f240 8104 	bls.w	8029428 <__udivmoddi4+0x290>
 8029220:	3802      	subs	r0, #2
 8029222:	442c      	add	r4, r5
 8029224:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8029228:	eba4 040c 	sub.w	r4, r4, ip
 802922c:	2700      	movs	r7, #0
 802922e:	b11e      	cbz	r6, 8029238 <__udivmoddi4+0xa0>
 8029230:	40d4      	lsrs	r4, r2
 8029232:	2300      	movs	r3, #0
 8029234:	e9c6 4300 	strd	r4, r3, [r6]
 8029238:	4639      	mov	r1, r7
 802923a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802923e:	428b      	cmp	r3, r1
 8029240:	d909      	bls.n	8029256 <__udivmoddi4+0xbe>
 8029242:	2e00      	cmp	r6, #0
 8029244:	f000 80eb 	beq.w	802941e <__udivmoddi4+0x286>
 8029248:	2700      	movs	r7, #0
 802924a:	e9c6 0100 	strd	r0, r1, [r6]
 802924e:	4638      	mov	r0, r7
 8029250:	4639      	mov	r1, r7
 8029252:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8029256:	fab3 f783 	clz	r7, r3
 802925a:	2f00      	cmp	r7, #0
 802925c:	d147      	bne.n	80292ee <__udivmoddi4+0x156>
 802925e:	428b      	cmp	r3, r1
 8029260:	d302      	bcc.n	8029268 <__udivmoddi4+0xd0>
 8029262:	4282      	cmp	r2, r0
 8029264:	f200 80fa 	bhi.w	802945c <__udivmoddi4+0x2c4>
 8029268:	1a84      	subs	r4, r0, r2
 802926a:	eb61 0303 	sbc.w	r3, r1, r3
 802926e:	2001      	movs	r0, #1
 8029270:	4698      	mov	r8, r3
 8029272:	2e00      	cmp	r6, #0
 8029274:	d0e0      	beq.n	8029238 <__udivmoddi4+0xa0>
 8029276:	e9c6 4800 	strd	r4, r8, [r6]
 802927a:	e7dd      	b.n	8029238 <__udivmoddi4+0xa0>
 802927c:	b902      	cbnz	r2, 8029280 <__udivmoddi4+0xe8>
 802927e:	deff      	udf	#255	; 0xff
 8029280:	fab2 f282 	clz	r2, r2
 8029284:	2a00      	cmp	r2, #0
 8029286:	f040 808f 	bne.w	80293a8 <__udivmoddi4+0x210>
 802928a:	1b49      	subs	r1, r1, r5
 802928c:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8029290:	fa1f f885 	uxth.w	r8, r5
 8029294:	2701      	movs	r7, #1
 8029296:	fbb1 fcfe 	udiv	ip, r1, lr
 802929a:	0c23      	lsrs	r3, r4, #16
 802929c:	fb0e 111c 	mls	r1, lr, ip, r1
 80292a0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80292a4:	fb08 f10c 	mul.w	r1, r8, ip
 80292a8:	4299      	cmp	r1, r3
 80292aa:	d907      	bls.n	80292bc <__udivmoddi4+0x124>
 80292ac:	18eb      	adds	r3, r5, r3
 80292ae:	f10c 30ff 	add.w	r0, ip, #4294967295
 80292b2:	d202      	bcs.n	80292ba <__udivmoddi4+0x122>
 80292b4:	4299      	cmp	r1, r3
 80292b6:	f200 80cd 	bhi.w	8029454 <__udivmoddi4+0x2bc>
 80292ba:	4684      	mov	ip, r0
 80292bc:	1a59      	subs	r1, r3, r1
 80292be:	b2a3      	uxth	r3, r4
 80292c0:	fbb1 f0fe 	udiv	r0, r1, lr
 80292c4:	fb0e 1410 	mls	r4, lr, r0, r1
 80292c8:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80292cc:	fb08 f800 	mul.w	r8, r8, r0
 80292d0:	45a0      	cmp	r8, r4
 80292d2:	d907      	bls.n	80292e4 <__udivmoddi4+0x14c>
 80292d4:	192c      	adds	r4, r5, r4
 80292d6:	f100 33ff 	add.w	r3, r0, #4294967295
 80292da:	d202      	bcs.n	80292e2 <__udivmoddi4+0x14a>
 80292dc:	45a0      	cmp	r8, r4
 80292de:	f200 80b6 	bhi.w	802944e <__udivmoddi4+0x2b6>
 80292e2:	4618      	mov	r0, r3
 80292e4:	eba4 0408 	sub.w	r4, r4, r8
 80292e8:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80292ec:	e79f      	b.n	802922e <__udivmoddi4+0x96>
 80292ee:	f1c7 0c20 	rsb	ip, r7, #32
 80292f2:	40bb      	lsls	r3, r7
 80292f4:	fa22 fe0c 	lsr.w	lr, r2, ip
 80292f8:	ea4e 0e03 	orr.w	lr, lr, r3
 80292fc:	fa01 f407 	lsl.w	r4, r1, r7
 8029300:	fa20 f50c 	lsr.w	r5, r0, ip
 8029304:	fa21 f30c 	lsr.w	r3, r1, ip
 8029308:	ea4f 481e 	mov.w	r8, lr, lsr #16
 802930c:	4325      	orrs	r5, r4
 802930e:	fbb3 f9f8 	udiv	r9, r3, r8
 8029312:	0c2c      	lsrs	r4, r5, #16
 8029314:	fb08 3319 	mls	r3, r8, r9, r3
 8029318:	fa1f fa8e 	uxth.w	sl, lr
 802931c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8029320:	fb09 f40a 	mul.w	r4, r9, sl
 8029324:	429c      	cmp	r4, r3
 8029326:	fa02 f207 	lsl.w	r2, r2, r7
 802932a:	fa00 f107 	lsl.w	r1, r0, r7
 802932e:	d90b      	bls.n	8029348 <__udivmoddi4+0x1b0>
 8029330:	eb1e 0303 	adds.w	r3, lr, r3
 8029334:	f109 30ff 	add.w	r0, r9, #4294967295
 8029338:	f080 8087 	bcs.w	802944a <__udivmoddi4+0x2b2>
 802933c:	429c      	cmp	r4, r3
 802933e:	f240 8084 	bls.w	802944a <__udivmoddi4+0x2b2>
 8029342:	f1a9 0902 	sub.w	r9, r9, #2
 8029346:	4473      	add	r3, lr
 8029348:	1b1b      	subs	r3, r3, r4
 802934a:	b2ad      	uxth	r5, r5
 802934c:	fbb3 f0f8 	udiv	r0, r3, r8
 8029350:	fb08 3310 	mls	r3, r8, r0, r3
 8029354:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8029358:	fb00 fa0a 	mul.w	sl, r0, sl
 802935c:	45a2      	cmp	sl, r4
 802935e:	d908      	bls.n	8029372 <__udivmoddi4+0x1da>
 8029360:	eb1e 0404 	adds.w	r4, lr, r4
 8029364:	f100 33ff 	add.w	r3, r0, #4294967295
 8029368:	d26b      	bcs.n	8029442 <__udivmoddi4+0x2aa>
 802936a:	45a2      	cmp	sl, r4
 802936c:	d969      	bls.n	8029442 <__udivmoddi4+0x2aa>
 802936e:	3802      	subs	r0, #2
 8029370:	4474      	add	r4, lr
 8029372:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8029376:	fba0 8902 	umull	r8, r9, r0, r2
 802937a:	eba4 040a 	sub.w	r4, r4, sl
 802937e:	454c      	cmp	r4, r9
 8029380:	46c2      	mov	sl, r8
 8029382:	464b      	mov	r3, r9
 8029384:	d354      	bcc.n	8029430 <__udivmoddi4+0x298>
 8029386:	d051      	beq.n	802942c <__udivmoddi4+0x294>
 8029388:	2e00      	cmp	r6, #0
 802938a:	d069      	beq.n	8029460 <__udivmoddi4+0x2c8>
 802938c:	ebb1 050a 	subs.w	r5, r1, sl
 8029390:	eb64 0403 	sbc.w	r4, r4, r3
 8029394:	fa04 fc0c 	lsl.w	ip, r4, ip
 8029398:	40fd      	lsrs	r5, r7
 802939a:	40fc      	lsrs	r4, r7
 802939c:	ea4c 0505 	orr.w	r5, ip, r5
 80293a0:	e9c6 5400 	strd	r5, r4, [r6]
 80293a4:	2700      	movs	r7, #0
 80293a6:	e747      	b.n	8029238 <__udivmoddi4+0xa0>
 80293a8:	f1c2 0320 	rsb	r3, r2, #32
 80293ac:	fa20 f703 	lsr.w	r7, r0, r3
 80293b0:	4095      	lsls	r5, r2
 80293b2:	fa01 f002 	lsl.w	r0, r1, r2
 80293b6:	fa21 f303 	lsr.w	r3, r1, r3
 80293ba:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80293be:	4338      	orrs	r0, r7
 80293c0:	0c01      	lsrs	r1, r0, #16
 80293c2:	fbb3 f7fe 	udiv	r7, r3, lr
 80293c6:	fa1f f885 	uxth.w	r8, r5
 80293ca:	fb0e 3317 	mls	r3, lr, r7, r3
 80293ce:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80293d2:	fb07 f308 	mul.w	r3, r7, r8
 80293d6:	428b      	cmp	r3, r1
 80293d8:	fa04 f402 	lsl.w	r4, r4, r2
 80293dc:	d907      	bls.n	80293ee <__udivmoddi4+0x256>
 80293de:	1869      	adds	r1, r5, r1
 80293e0:	f107 3cff 	add.w	ip, r7, #4294967295
 80293e4:	d22f      	bcs.n	8029446 <__udivmoddi4+0x2ae>
 80293e6:	428b      	cmp	r3, r1
 80293e8:	d92d      	bls.n	8029446 <__udivmoddi4+0x2ae>
 80293ea:	3f02      	subs	r7, #2
 80293ec:	4429      	add	r1, r5
 80293ee:	1acb      	subs	r3, r1, r3
 80293f0:	b281      	uxth	r1, r0
 80293f2:	fbb3 f0fe 	udiv	r0, r3, lr
 80293f6:	fb0e 3310 	mls	r3, lr, r0, r3
 80293fa:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80293fe:	fb00 f308 	mul.w	r3, r0, r8
 8029402:	428b      	cmp	r3, r1
 8029404:	d907      	bls.n	8029416 <__udivmoddi4+0x27e>
 8029406:	1869      	adds	r1, r5, r1
 8029408:	f100 3cff 	add.w	ip, r0, #4294967295
 802940c:	d217      	bcs.n	802943e <__udivmoddi4+0x2a6>
 802940e:	428b      	cmp	r3, r1
 8029410:	d915      	bls.n	802943e <__udivmoddi4+0x2a6>
 8029412:	3802      	subs	r0, #2
 8029414:	4429      	add	r1, r5
 8029416:	1ac9      	subs	r1, r1, r3
 8029418:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 802941c:	e73b      	b.n	8029296 <__udivmoddi4+0xfe>
 802941e:	4637      	mov	r7, r6
 8029420:	4630      	mov	r0, r6
 8029422:	e709      	b.n	8029238 <__udivmoddi4+0xa0>
 8029424:	4607      	mov	r7, r0
 8029426:	e6e7      	b.n	80291f8 <__udivmoddi4+0x60>
 8029428:	4618      	mov	r0, r3
 802942a:	e6fb      	b.n	8029224 <__udivmoddi4+0x8c>
 802942c:	4541      	cmp	r1, r8
 802942e:	d2ab      	bcs.n	8029388 <__udivmoddi4+0x1f0>
 8029430:	ebb8 0a02 	subs.w	sl, r8, r2
 8029434:	eb69 020e 	sbc.w	r2, r9, lr
 8029438:	3801      	subs	r0, #1
 802943a:	4613      	mov	r3, r2
 802943c:	e7a4      	b.n	8029388 <__udivmoddi4+0x1f0>
 802943e:	4660      	mov	r0, ip
 8029440:	e7e9      	b.n	8029416 <__udivmoddi4+0x27e>
 8029442:	4618      	mov	r0, r3
 8029444:	e795      	b.n	8029372 <__udivmoddi4+0x1da>
 8029446:	4667      	mov	r7, ip
 8029448:	e7d1      	b.n	80293ee <__udivmoddi4+0x256>
 802944a:	4681      	mov	r9, r0
 802944c:	e77c      	b.n	8029348 <__udivmoddi4+0x1b0>
 802944e:	3802      	subs	r0, #2
 8029450:	442c      	add	r4, r5
 8029452:	e747      	b.n	80292e4 <__udivmoddi4+0x14c>
 8029454:	f1ac 0c02 	sub.w	ip, ip, #2
 8029458:	442b      	add	r3, r5
 802945a:	e72f      	b.n	80292bc <__udivmoddi4+0x124>
 802945c:	4638      	mov	r0, r7
 802945e:	e708      	b.n	8029272 <__udivmoddi4+0xda>
 8029460:	4637      	mov	r7, r6
 8029462:	e6e9      	b.n	8029238 <__udivmoddi4+0xa0>

08029464 <__aeabi_idiv0>:
 8029464:	4770      	bx	lr
 8029466:	bf00      	nop

08029468 <CalibrationSetup>:
//
//	return;
//}

void CalibrationSetup()		// Set up calibration parameter matrices
{
 8029468:	b5b0      	push	{r4, r5, r7, lr}
 802946a:	b096      	sub	sp, #88	; 0x58
 802946c:	af02      	add	r7, sp, #8
	gsl_matrix_view Kom;
	gsl_matrix_view Tom;

	for (int i = 0; i < 6; i++)
 802946e:	2300      	movs	r3, #0
 8029470:	64fb      	str	r3, [r7, #76]	; 0x4c
 8029472:	e047      	b.n	8029504 <CalibrationSetup+0x9c>
	{
		Kom = gsl_matrix_view_array(&Kom_init[i][0][0], 3, 3);	// Gyro scale factor matrix
 8029474:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8029476:	4613      	mov	r3, r2
 8029478:	00db      	lsls	r3, r3, #3
 802947a:	4413      	add	r3, r2
 802947c:	00db      	lsls	r3, r3, #3
 802947e:	4a2a      	ldr	r2, [pc, #168]	; (8029528 <CalibrationSetup+0xc0>)
 8029480:	1899      	adds	r1, r3, r2
 8029482:	4638      	mov	r0, r7
 8029484:	2303      	movs	r3, #3
 8029486:	2203      	movs	r2, #3
 8029488:	f7db fe7c 	bl	8005184 <gsl_matrix_view_array>
 802948c:	f107 0434 	add.w	r4, r7, #52	; 0x34
 8029490:	463d      	mov	r5, r7
 8029492:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8029494:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8029496:	e895 0003 	ldmia.w	r5, {r0, r1}
 802949a:	e884 0003 	stmia.w	r4, {r0, r1}
		Tom = gsl_matrix_view_array(&Tom_init[i][0][0], 3, 3);	// Gyro nonorthogonality matrix
 802949e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80294a0:	4613      	mov	r3, r2
 80294a2:	00db      	lsls	r3, r3, #3
 80294a4:	4413      	add	r3, r2
 80294a6:	00db      	lsls	r3, r3, #3
 80294a8:	4a20      	ldr	r2, [pc, #128]	; (802952c <CalibrationSetup+0xc4>)
 80294aa:	1899      	adds	r1, r3, r2
 80294ac:	4638      	mov	r0, r7
 80294ae:	2303      	movs	r3, #3
 80294b0:	2203      	movs	r2, #3
 80294b2:	f7db fe67 	bl	8005184 <gsl_matrix_view_array>
 80294b6:	f107 041c 	add.w	r4, r7, #28
 80294ba:	463d      	mov	r5, r7
 80294bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80294be:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80294c0:	e895 0003 	ldmia.w	r5, {r0, r1}
 80294c4:	e884 0003 	stmia.w	r4, {r0, r1}
		TKom[i] = gsl_matrix_alloc(3, 3);				// Product of scale factor and nonorthogonality matrices
 80294c8:	2103      	movs	r1, #3
 80294ca:	2003      	movs	r0, #3
 80294cc:	f7d9 ffa2 	bl	8003414 <gsl_matrix_alloc>
 80294d0:	4601      	mov	r1, r0
 80294d2:	4a17      	ldr	r2, [pc, #92]	; (8029530 <CalibrationSetup+0xc8>)
 80294d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294d6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

		gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, &Tom.matrix, &Kom.matrix, 0.0, TKom[i]);			// Compute product of T and K
 80294da:	4a15      	ldr	r2, [pc, #84]	; (8029530 <CalibrationSetup+0xc8>)
 80294dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80294e2:	f107 0134 	add.w	r1, r7, #52	; 0x34
 80294e6:	f107 021c 	add.w	r2, r7, #28
 80294ea:	9300      	str	r3, [sp, #0]
 80294ec:	ed9f 1b0a 	vldr	d1, [pc, #40]	; 8029518 <CalibrationSetup+0xb0>
 80294f0:	460b      	mov	r3, r1
 80294f2:	ed9f 0b0b 	vldr	d0, [pc, #44]	; 8029520 <CalibrationSetup+0xb8>
 80294f6:	216f      	movs	r1, #111	; 0x6f
 80294f8:	206f      	movs	r0, #111	; 0x6f
 80294fa:	f7d8 f90b 	bl	8001714 <gsl_blas_dgemm>
	for (int i = 0; i < 6; i++)
 80294fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029500:	3301      	adds	r3, #1
 8029502:	64fb      	str	r3, [r7, #76]	; 0x4c
 8029504:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029506:	2b05      	cmp	r3, #5
 8029508:	ddb4      	ble.n	8029474 <CalibrationSetup+0xc>
	}

	return;
 802950a:	bf00      	nop
}
 802950c:	3750      	adds	r7, #80	; 0x50
 802950e:	46bd      	mov	sp, r7
 8029510:	bdb0      	pop	{r4, r5, r7, pc}
 8029512:	bf00      	nop
 8029514:	f3af 8000 	nop.w
	...
 8029524:	3ff00000 	.word	0x3ff00000
 8029528:	20000240 	.word	0x20000240
 802952c:	200003f0 	.word	0x200003f0
 8029530:	20001a20 	.word	0x20001a20

08029534 <PolyVal>:

float PolyVal(float x, double poly[4])		// Evaluate polynomial using Horner's Method
{
 8029534:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029538:	b087      	sub	sp, #28
 802953a:	af00      	add	r7, sp, #0
 802953c:	ed87 0a05 	vstr	s0, [r7, #20]
 8029540:	6138      	str	r0, [r7, #16]
	return poly[0] + x*(poly[1] + x*(poly[2] + x*poly[3])); // y = poly[0] + poly[1]*x + poly[2]*x^2 + poly[3]*x^3
 8029542:	693b      	ldr	r3, [r7, #16]
 8029544:	e9d3 8900 	ldrd	r8, r9, [r3]
 8029548:	6978      	ldr	r0, [r7, #20]
 802954a:	f7ff fab5 	bl	8028ab8 <__aeabi_f2d>
 802954e:	e9c7 0102 	strd	r0, r1, [r7, #8]
 8029552:	693b      	ldr	r3, [r7, #16]
 8029554:	3308      	adds	r3, #8
 8029556:	e9d3 ab00 	ldrd	sl, fp, [r3]
 802955a:	6978      	ldr	r0, [r7, #20]
 802955c:	f7ff faac 	bl	8028ab8 <__aeabi_f2d>
 8029560:	e9c7 0100 	strd	r0, r1, [r7]
 8029564:	693b      	ldr	r3, [r7, #16]
 8029566:	3310      	adds	r3, #16
 8029568:	e9d3 5600 	ldrd	r5, r6, [r3]
 802956c:	6978      	ldr	r0, [r7, #20]
 802956e:	f7ff faa3 	bl	8028ab8 <__aeabi_f2d>
 8029572:	693b      	ldr	r3, [r7, #16]
 8029574:	3318      	adds	r3, #24
 8029576:	e9d3 3400 	ldrd	r3, r4, [r3]
 802957a:	461a      	mov	r2, r3
 802957c:	4623      	mov	r3, r4
 802957e:	f7ff faf3 	bl	8028b68 <__aeabi_dmul>
 8029582:	4603      	mov	r3, r0
 8029584:	460c      	mov	r4, r1
 8029586:	461a      	mov	r2, r3
 8029588:	4623      	mov	r3, r4
 802958a:	4628      	mov	r0, r5
 802958c:	4631      	mov	r1, r6
 802958e:	f7ff f935 	bl	80287fc <__adddf3>
 8029592:	4603      	mov	r3, r0
 8029594:	460c      	mov	r4, r1
 8029596:	461a      	mov	r2, r3
 8029598:	4623      	mov	r3, r4
 802959a:	e9d7 0100 	ldrd	r0, r1, [r7]
 802959e:	f7ff fae3 	bl	8028b68 <__aeabi_dmul>
 80295a2:	4603      	mov	r3, r0
 80295a4:	460c      	mov	r4, r1
 80295a6:	461a      	mov	r2, r3
 80295a8:	4623      	mov	r3, r4
 80295aa:	4650      	mov	r0, sl
 80295ac:	4659      	mov	r1, fp
 80295ae:	f7ff f925 	bl	80287fc <__adddf3>
 80295b2:	4603      	mov	r3, r0
 80295b4:	460c      	mov	r4, r1
 80295b6:	461a      	mov	r2, r3
 80295b8:	4623      	mov	r3, r4
 80295ba:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 80295be:	f7ff fad3 	bl	8028b68 <__aeabi_dmul>
 80295c2:	4603      	mov	r3, r0
 80295c4:	460c      	mov	r4, r1
 80295c6:	461a      	mov	r2, r3
 80295c8:	4623      	mov	r3, r4
 80295ca:	4640      	mov	r0, r8
 80295cc:	4649      	mov	r1, r9
 80295ce:	f7ff f915 	bl	80287fc <__adddf3>
 80295d2:	4603      	mov	r3, r0
 80295d4:	460c      	mov	r4, r1
 80295d6:	4618      	mov	r0, r3
 80295d8:	4621      	mov	r1, r4
 80295da:	f7ff fd75 	bl	80290c8 <__aeabi_d2f>
 80295de:	4603      	mov	r3, r0
 80295e0:	ee07 3a90 	vmov	s15, r3
}
 80295e4:	eeb0 0a67 	vmov.f32	s0, s15
 80295e8:	371c      	adds	r7, #28
 80295ea:	46bd      	mov	sp, r7
 80295ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080295f0 <Calibrate>:

void Calibrate(struct RxBuffer *rawData, struct CalibBuffer *calibData, int I[nIMUs], int csCount)
{
 80295f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80295f2:	b09b      	sub	sp, #108	; 0x6c
 80295f4:	af00      	add	r7, sp, #0
 80295f6:	60f8      	str	r0, [r7, #12]
 80295f8:	60b9      	str	r1, [r7, #8]
 80295fa:	607a      	str	r2, [r7, #4]
 80295fc:	603b      	str	r3, [r7, #0]
	double omLin[3];
	double omCalib[3] = {0.0};
 80295fe:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8029602:	2200      	movs	r2, #0
 8029604:	601a      	str	r2, [r3, #0]
 8029606:	605a      	str	r2, [r3, #4]
 8029608:	609a      	str	r2, [r3, #8]
 802960a:	60da      	str	r2, [r3, #12]
 802960c:	611a      	str	r2, [r3, #16]
 802960e:	615a      	str	r2, [r3, #20]

	// Apply nonlinearity correction to gyro measurements
	omLin[0] = (double)PolyVal((float)rawData[csCount].RxBuffer_OMX[I[csCount]], &pnlom[csCount][0][0]);
 8029610:	683b      	ldr	r3, [r7, #0]
 8029612:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029616:	fb02 f303 	mul.w	r3, r2, r3
 802961a:	68fa      	ldr	r2, [r7, #12]
 802961c:	4413      	add	r3, r2
 802961e:	683a      	ldr	r2, [r7, #0]
 8029620:	0092      	lsls	r2, r2, #2
 8029622:	6879      	ldr	r1, [r7, #4]
 8029624:	440a      	add	r2, r1
 8029626:	6812      	ldr	r2, [r2, #0]
 8029628:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 802962c:	ee07 3a90 	vmov	s15, r3
 8029630:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8029634:	683a      	ldr	r2, [r7, #0]
 8029636:	4613      	mov	r3, r2
 8029638:	005b      	lsls	r3, r3, #1
 802963a:	4413      	add	r3, r2
 802963c:	015b      	lsls	r3, r3, #5
 802963e:	4aa2      	ldr	r2, [pc, #648]	; (80298c8 <Calibrate+0x2d8>)
 8029640:	4413      	add	r3, r2
 8029642:	4618      	mov	r0, r3
 8029644:	eeb0 0a67 	vmov.f32	s0, s15
 8029648:	f7ff ff74 	bl	8029534 <PolyVal>
 802964c:	ee10 3a10 	vmov	r3, s0
 8029650:	4618      	mov	r0, r3
 8029652:	f7ff fa31 	bl	8028ab8 <__aeabi_f2d>
 8029656:	4603      	mov	r3, r0
 8029658:	460c      	mov	r4, r1
 802965a:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
	omLin[1] = (double)PolyVal((float)rawData[csCount].RxBuffer_OMY[I[csCount]], &pnlom[csCount][1][0]);
 802965e:	683b      	ldr	r3, [r7, #0]
 8029660:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029664:	fb02 f303 	mul.w	r3, r2, r3
 8029668:	68fa      	ldr	r2, [r7, #12]
 802966a:	4413      	add	r3, r2
 802966c:	683a      	ldr	r2, [r7, #0]
 802966e:	0092      	lsls	r2, r2, #2
 8029670:	6879      	ldr	r1, [r7, #4]
 8029672:	440a      	add	r2, r1
 8029674:	6812      	ldr	r2, [r2, #0]
 8029676:	3264      	adds	r2, #100	; 0x64
 8029678:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 802967c:	ee07 3a90 	vmov	s15, r3
 8029680:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8029684:	683a      	ldr	r2, [r7, #0]
 8029686:	4613      	mov	r3, r2
 8029688:	005b      	lsls	r3, r3, #1
 802968a:	4413      	add	r3, r2
 802968c:	015b      	lsls	r3, r3, #5
 802968e:	3320      	adds	r3, #32
 8029690:	4a8d      	ldr	r2, [pc, #564]	; (80298c8 <Calibrate+0x2d8>)
 8029692:	4413      	add	r3, r2
 8029694:	4618      	mov	r0, r3
 8029696:	eeb0 0a67 	vmov.f32	s0, s15
 802969a:	f7ff ff4b 	bl	8029534 <PolyVal>
 802969e:	ee10 3a10 	vmov	r3, s0
 80296a2:	4618      	mov	r0, r3
 80296a4:	f7ff fa08 	bl	8028ab8 <__aeabi_f2d>
 80296a8:	4603      	mov	r3, r0
 80296aa:	460c      	mov	r4, r1
 80296ac:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
	omLin[2] = (double)PolyVal((float)rawData[csCount].RxBuffer_OMZ[I[csCount]], &pnlom[csCount][2][0]);
 80296b0:	683b      	ldr	r3, [r7, #0]
 80296b2:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80296b6:	fb02 f303 	mul.w	r3, r2, r3
 80296ba:	68fa      	ldr	r2, [r7, #12]
 80296bc:	4413      	add	r3, r2
 80296be:	683a      	ldr	r2, [r7, #0]
 80296c0:	0092      	lsls	r2, r2, #2
 80296c2:	6879      	ldr	r1, [r7, #4]
 80296c4:	440a      	add	r2, r1
 80296c6:	6812      	ldr	r2, [r2, #0]
 80296c8:	32c8      	adds	r2, #200	; 0xc8
 80296ca:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80296ce:	ee07 3a90 	vmov	s15, r3
 80296d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80296d6:	683a      	ldr	r2, [r7, #0]
 80296d8:	4613      	mov	r3, r2
 80296da:	005b      	lsls	r3, r3, #1
 80296dc:	4413      	add	r3, r2
 80296de:	015b      	lsls	r3, r3, #5
 80296e0:	3340      	adds	r3, #64	; 0x40
 80296e2:	4a79      	ldr	r2, [pc, #484]	; (80298c8 <Calibrate+0x2d8>)
 80296e4:	4413      	add	r3, r2
 80296e6:	4618      	mov	r0, r3
 80296e8:	eeb0 0a67 	vmov.f32	s0, s15
 80296ec:	f7ff ff22 	bl	8029534 <PolyVal>
 80296f0:	ee10 3a10 	vmov	r3, s0
 80296f4:	4618      	mov	r0, r3
 80296f6:	f7ff f9df 	bl	8028ab8 <__aeabi_f2d>
 80296fa:	4603      	mov	r3, r0
 80296fc:	460c      	mov	r4, r1
 80296fe:	e9c7 3418 	strd	r3, r4, [r7, #96]	; 0x60
	gsl_vector_view omLinVec = gsl_vector_view_array(omLin, 3);
 8029702:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8029706:	f107 0150 	add.w	r1, r7, #80	; 0x50
 802970a:	2203      	movs	r2, #3
 802970c:	4618      	mov	r0, r3
 802970e:	f7dd fbe9 	bl	8006ee4 <gsl_vector_view_array>
	gsl_vector_view omCalibVec = gsl_vector_view_array(omCalib, 3);
 8029712:	f107 0310 	add.w	r3, r7, #16
 8029716:	f107 0138 	add.w	r1, r7, #56	; 0x38
 802971a:	2203      	movs	r2, #3
 802971c:	4618      	mov	r0, r3
 802971e:	f7dd fbe1 	bl	8006ee4 <gsl_vector_view_array>

	// Apply nonorthogonality and scale factor corrections to gyro measurements
	gsl_blas_dgemv(CblasNoTrans, 1.0, TKom[csCount], &omLinVec.vector, 0.0, &omCalibVec.vector);
 8029722:	4a6a      	ldr	r2, [pc, #424]	; (80298cc <Calibrate+0x2dc>)
 8029724:	683b      	ldr	r3, [r7, #0]
 8029726:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 802972a:	f107 0310 	add.w	r3, r7, #16
 802972e:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8029732:	ed9f 1b61 	vldr	d1, [pc, #388]	; 80298b8 <Calibrate+0x2c8>
 8029736:	ed9f 0b62 	vldr	d0, [pc, #392]	; 80298c0 <Calibrate+0x2d0>
 802973a:	206f      	movs	r0, #111	; 0x6f
 802973c:	f7d7 f934 	bl	80009a8 <gsl_blas_dgemv>

	// Write calibrated gyro measurements to calibData
	calibData[csCount].RxBuffer_OMX[I[csCount]] = (float)omCalib[0];
 8029740:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 8029744:	683a      	ldr	r2, [r7, #0]
 8029746:	f44f 6116 	mov.w	r1, #2400	; 0x960
 802974a:	fb01 f202 	mul.w	r2, r1, r2
 802974e:	68b9      	ldr	r1, [r7, #8]
 8029750:	188d      	adds	r5, r1, r2
 8029752:	683a      	ldr	r2, [r7, #0]
 8029754:	0092      	lsls	r2, r2, #2
 8029756:	6879      	ldr	r1, [r7, #4]
 8029758:	440a      	add	r2, r1
 802975a:	6816      	ldr	r6, [r2, #0]
 802975c:	4618      	mov	r0, r3
 802975e:	4621      	mov	r1, r4
 8029760:	f7ff fcb2 	bl	80290c8 <__aeabi_d2f>
 8029764:	4602      	mov	r2, r0
 8029766:	00b3      	lsls	r3, r6, #2
 8029768:	442b      	add	r3, r5
 802976a:	601a      	str	r2, [r3, #0]
	calibData[csCount].RxBuffer_OMY[I[csCount]] = (float)omCalib[1];
 802976c:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 8029770:	683a      	ldr	r2, [r7, #0]
 8029772:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8029776:	fb01 f202 	mul.w	r2, r1, r2
 802977a:	68b9      	ldr	r1, [r7, #8]
 802977c:	188d      	adds	r5, r1, r2
 802977e:	683a      	ldr	r2, [r7, #0]
 8029780:	0092      	lsls	r2, r2, #2
 8029782:	6879      	ldr	r1, [r7, #4]
 8029784:	440a      	add	r2, r1
 8029786:	6816      	ldr	r6, [r2, #0]
 8029788:	4618      	mov	r0, r3
 802978a:	4621      	mov	r1, r4
 802978c:	f7ff fc9c 	bl	80290c8 <__aeabi_d2f>
 8029790:	4602      	mov	r2, r0
 8029792:	f106 0364 	add.w	r3, r6, #100	; 0x64
 8029796:	009b      	lsls	r3, r3, #2
 8029798:	442b      	add	r3, r5
 802979a:	601a      	str	r2, [r3, #0]
	calibData[csCount].RxBuffer_OMZ[I[csCount]] = (float)omCalib[2];
 802979c:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
 80297a0:	683a      	ldr	r2, [r7, #0]
 80297a2:	f44f 6116 	mov.w	r1, #2400	; 0x960
 80297a6:	fb01 f202 	mul.w	r2, r1, r2
 80297aa:	68b9      	ldr	r1, [r7, #8]
 80297ac:	188d      	adds	r5, r1, r2
 80297ae:	683a      	ldr	r2, [r7, #0]
 80297b0:	0092      	lsls	r2, r2, #2
 80297b2:	6879      	ldr	r1, [r7, #4]
 80297b4:	440a      	add	r2, r1
 80297b6:	6816      	ldr	r6, [r2, #0]
 80297b8:	4618      	mov	r0, r3
 80297ba:	4621      	mov	r1, r4
 80297bc:	f7ff fc84 	bl	80290c8 <__aeabi_d2f>
 80297c0:	4602      	mov	r2, r0
 80297c2:	f106 03c8 	add.w	r3, r6, #200	; 0xc8
 80297c6:	009b      	lsls	r3, r3, #2
 80297c8:	442b      	add	r3, r5
 80297ca:	601a      	str	r2, [r3, #0]

	// Pass uncalibrated accelerometer measurements directly to calibData (to be calibrated offline)
	calibData[csCount].RxBuffer_AX[I[csCount]] = rawData[csCount].RxBuffer_AX[I[csCount]];
 80297cc:	683b      	ldr	r3, [r7, #0]
 80297ce:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80297d2:	fb02 f303 	mul.w	r3, r2, r3
 80297d6:	68fa      	ldr	r2, [r7, #12]
 80297d8:	4413      	add	r3, r2
 80297da:	683a      	ldr	r2, [r7, #0]
 80297dc:	0092      	lsls	r2, r2, #2
 80297de:	6879      	ldr	r1, [r7, #4]
 80297e0:	440a      	add	r2, r1
 80297e2:	6812      	ldr	r2, [r2, #0]
 80297e4:	f502 7296 	add.w	r2, r2, #300	; 0x12c
 80297e8:	f933 0012 	ldrsh.w	r0, [r3, r2, lsl #1]
 80297ec:	683b      	ldr	r3, [r7, #0]
 80297ee:	f44f 6216 	mov.w	r2, #2400	; 0x960
 80297f2:	fb02 f303 	mul.w	r3, r2, r3
 80297f6:	68ba      	ldr	r2, [r7, #8]
 80297f8:	441a      	add	r2, r3
 80297fa:	683b      	ldr	r3, [r7, #0]
 80297fc:	009b      	lsls	r3, r3, #2
 80297fe:	6879      	ldr	r1, [r7, #4]
 8029800:	440b      	add	r3, r1
 8029802:	681b      	ldr	r3, [r3, #0]
 8029804:	ee07 0a90 	vmov	s15, r0
 8029808:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802980c:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 8029810:	009b      	lsls	r3, r3, #2
 8029812:	4413      	add	r3, r2
 8029814:	edc3 7a00 	vstr	s15, [r3]
	calibData[csCount].RxBuffer_AY[I[csCount]] = rawData[csCount].RxBuffer_AY[I[csCount]];
 8029818:	683b      	ldr	r3, [r7, #0]
 802981a:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802981e:	fb02 f303 	mul.w	r3, r2, r3
 8029822:	68fa      	ldr	r2, [r7, #12]
 8029824:	4413      	add	r3, r2
 8029826:	683a      	ldr	r2, [r7, #0]
 8029828:	0092      	lsls	r2, r2, #2
 802982a:	6879      	ldr	r1, [r7, #4]
 802982c:	440a      	add	r2, r1
 802982e:	6812      	ldr	r2, [r2, #0]
 8029830:	f502 72c8 	add.w	r2, r2, #400	; 0x190
 8029834:	f933 0012 	ldrsh.w	r0, [r3, r2, lsl #1]
 8029838:	683b      	ldr	r3, [r7, #0]
 802983a:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802983e:	fb02 f303 	mul.w	r3, r2, r3
 8029842:	68ba      	ldr	r2, [r7, #8]
 8029844:	441a      	add	r2, r3
 8029846:	683b      	ldr	r3, [r7, #0]
 8029848:	009b      	lsls	r3, r3, #2
 802984a:	6879      	ldr	r1, [r7, #4]
 802984c:	440b      	add	r3, r1
 802984e:	681b      	ldr	r3, [r3, #0]
 8029850:	ee07 0a90 	vmov	s15, r0
 8029854:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8029858:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 802985c:	009b      	lsls	r3, r3, #2
 802985e:	4413      	add	r3, r2
 8029860:	edc3 7a00 	vstr	s15, [r3]
	calibData[csCount].RxBuffer_AZ[I[csCount]] = rawData[csCount].RxBuffer_AZ[I[csCount]];
 8029864:	683b      	ldr	r3, [r7, #0]
 8029866:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802986a:	fb02 f303 	mul.w	r3, r2, r3
 802986e:	68fa      	ldr	r2, [r7, #12]
 8029870:	4413      	add	r3, r2
 8029872:	683a      	ldr	r2, [r7, #0]
 8029874:	0092      	lsls	r2, r2, #2
 8029876:	6879      	ldr	r1, [r7, #4]
 8029878:	440a      	add	r2, r1
 802987a:	6812      	ldr	r2, [r2, #0]
 802987c:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
 8029880:	f933 0012 	ldrsh.w	r0, [r3, r2, lsl #1]
 8029884:	683b      	ldr	r3, [r7, #0]
 8029886:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802988a:	fb02 f303 	mul.w	r3, r2, r3
 802988e:	68ba      	ldr	r2, [r7, #8]
 8029890:	441a      	add	r2, r3
 8029892:	683b      	ldr	r3, [r7, #0]
 8029894:	009b      	lsls	r3, r3, #2
 8029896:	6879      	ldr	r1, [r7, #4]
 8029898:	440b      	add	r3, r1
 802989a:	681b      	ldr	r3, [r3, #0]
 802989c:	ee07 0a90 	vmov	s15, r0
 80298a0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80298a4:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 80298a8:	009b      	lsls	r3, r3, #2
 80298aa:	4413      	add	r3, r2
 80298ac:	edc3 7a00 	vstr	s15, [r3]

//		if (csCount == 5)
//			__NOP();

	return;
 80298b0:	bf00      	nop
}
 80298b2:	376c      	adds	r7, #108	; 0x6c
 80298b4:	46bd      	mov	sp, r7
 80298b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...
 80298c4:	3ff00000 	.word	0x3ff00000
 80298c8:	20000000 	.word	0x20000000
 80298cc:	20001a20 	.word	0x20001a20

080298d0 <SystemClock_Config>:
 * PPL value can be generated from the .ioc file in the project
 * IMPORTANT:
 * When use external clock source HSEState must be set to RCC_HSE_ON (Flash chip purpose)
 */
void SystemClock_Config(void)
{
 80298d0:	b580      	push	{r7, lr}
 80298d2:	b094      	sub	sp, #80	; 0x50
 80298d4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80298d6:	f107 0320 	add.w	r3, r7, #32
 80298da:	2230      	movs	r2, #48	; 0x30
 80298dc:	2100      	movs	r1, #0
 80298de:	4618      	mov	r0, r3
 80298e0:	f006 fbf0 	bl	80300c4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80298e4:	f107 030c 	add.w	r3, r7, #12
 80298e8:	2200      	movs	r2, #0
 80298ea:	601a      	str	r2, [r3, #0]
 80298ec:	605a      	str	r2, [r3, #4]
 80298ee:	609a      	str	r2, [r3, #8]
 80298f0:	60da      	str	r2, [r3, #12]
 80298f2:	611a      	str	r2, [r3, #16]

  // Configure the main internal regulator output voltage
  __HAL_RCC_PWR_CLK_ENABLE();
 80298f4:	2300      	movs	r3, #0
 80298f6:	60bb      	str	r3, [r7, #8]
 80298f8:	4b29      	ldr	r3, [pc, #164]	; (80299a0 <SystemClock_Config+0xd0>)
 80298fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80298fc:	4a28      	ldr	r2, [pc, #160]	; (80299a0 <SystemClock_Config+0xd0>)
 80298fe:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8029902:	6413      	str	r3, [r2, #64]	; 0x40
 8029904:	4b26      	ldr	r3, [pc, #152]	; (80299a0 <SystemClock_Config+0xd0>)
 8029906:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8029908:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802990c:	60bb      	str	r3, [r7, #8]
 802990e:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8029910:	2300      	movs	r3, #0
 8029912:	607b      	str	r3, [r7, #4]
 8029914:	4b23      	ldr	r3, [pc, #140]	; (80299a4 <SystemClock_Config+0xd4>)
 8029916:	681b      	ldr	r3, [r3, #0]
 8029918:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 802991c:	4a21      	ldr	r2, [pc, #132]	; (80299a4 <SystemClock_Config+0xd4>)
 802991e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8029922:	6013      	str	r3, [r2, #0]
 8029924:	4b1f      	ldr	r3, [pc, #124]	; (80299a4 <SystemClock_Config+0xd4>)
 8029926:	681b      	ldr	r3, [r3, #0]
 8029928:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 802992c:	607b      	str	r3, [r7, #4]
 802992e:	687b      	ldr	r3, [r7, #4]
  // Initializes the CPU, AHB and APB busses clocks
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8029930:	2301      	movs	r3, #1
 8029932:	623b      	str	r3, [r7, #32]
   RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8029934:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8029938:	627b      	str	r3, [r7, #36]	; 0x24
   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 802993a:	2302      	movs	r3, #2
 802993c:	63bb      	str	r3, [r7, #56]	; 0x38
   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 802993e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8029942:	63fb      	str	r3, [r7, #60]	; 0x3c
   RCC_OscInitStruct.PLL.PLLM = 8;
 8029944:	2308      	movs	r3, #8
 8029946:	643b      	str	r3, [r7, #64]	; 0x40
   RCC_OscInitStruct.PLL.PLLN = 336;
 8029948:	f44f 73a8 	mov.w	r3, #336	; 0x150
 802994c:	647b      	str	r3, [r7, #68]	; 0x44
   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 802994e:	2304      	movs	r3, #4
 8029950:	64bb      	str	r3, [r7, #72]	; 0x48
   RCC_OscInitStruct.PLL.PLLQ = 7;
 8029952:	2307      	movs	r3, #7
 8029954:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8029956:	f107 0320 	add.w	r3, r7, #32
 802995a:	4618      	mov	r0, r3
 802995c:	f003 f93c 	bl	802cbd8 <HAL_RCC_OscConfig>
 8029960:	4603      	mov	r3, r0
 8029962:	2b00      	cmp	r3, #0
 8029964:	d001      	beq.n	802996a <SystemClock_Config+0x9a>
  {
    Error_Handler();
 8029966:	f000 fec5 	bl	802a6f4 <Error_Handler>
  }
  // Initializes the CPU, AHB and APB busses clocks
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 802996a:	230f      	movs	r3, #15
 802996c:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 802996e:	2302      	movs	r3, #2
 8029970:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8029972:	2300      	movs	r3, #0
 8029974:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8029976:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 802997a:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 802997c:	2300      	movs	r3, #0
 802997e:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8029980:	f107 030c 	add.w	r3, r7, #12
 8029984:	2102      	movs	r1, #2
 8029986:	4618      	mov	r0, r3
 8029988:	f003 fb96 	bl	802d0b8 <HAL_RCC_ClockConfig>
 802998c:	4603      	mov	r3, r0
 802998e:	2b00      	cmp	r3, #0
 8029990:	d001      	beq.n	8029996 <SystemClock_Config+0xc6>
  {
    Error_Handler();
 8029992:	f000 feaf 	bl	802a6f4 <Error_Handler>
  }
}
 8029996:	bf00      	nop
 8029998:	3750      	adds	r7, #80	; 0x50
 802999a:	46bd      	mov	sp, r7
 802999c:	bd80      	pop	{r7, pc}
 802999e:	bf00      	nop
 80299a0:	40023800 	.word	0x40023800
 80299a4:	40007000 	.word	0x40007000

080299a8 <HAL_SPI_TxRxCpltCallback>:
 *SPI DMA handler, being called after completed one transmit&receive
 *PULL up SPI CS pin after done with transmission, disable SPI DMA
 *Check if data in FIFO, Set flag accordingly for the FSM
 */
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
 80299a8:	b580      	push	{r7, lr}
 80299aa:	b082      	sub	sp, #8
 80299ac:	af00      	add	r7, sp, #0
 80299ae:	6078      	str	r0, [r7, #4]
	while( hspi1.State == HAL_SPI_STATE_BUSY );
 80299b0:	bf00      	nop
 80299b2:	4b0c      	ldr	r3, [pc, #48]	; (80299e4 <HAL_SPI_TxRxCpltCallback+0x3c>)
 80299b4:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 80299b8:	b2db      	uxtb	r3, r3
 80299ba:	2b02      	cmp	r3, #2
 80299bc:	d0f9      	beq.n	80299b2 <HAL_SPI_TxRxCpltCallback+0xa>
	HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 80299be:	4b0a      	ldr	r3, [pc, #40]	; (80299e8 <HAL_SPI_TxRxCpltCallback+0x40>)
 80299c0:	6818      	ldr	r0, [r3, #0]
 80299c2:	4b0a      	ldr	r3, [pc, #40]	; (80299ec <HAL_SPI_TxRxCpltCallback+0x44>)
 80299c4:	881b      	ldrh	r3, [r3, #0]
 80299c6:	2201      	movs	r2, #1
 80299c8:	4619      	mov	r1, r3
 80299ca:	f003 f8eb 	bl	802cba4 <HAL_GPIO_WritePin>
	HAL_SPI_DMAPause(&hspi1);
 80299ce:	4805      	ldr	r0, [pc, #20]	; (80299e4 <HAL_SPI_TxRxCpltCallback+0x3c>)
 80299d0:	f004 f9a0 	bl	802dd14 <HAL_SPI_DMAPause>
//	{
//		 state = 0;															// If empty,
//		 BUFFER_ORDER = 0;
//	}
//	else state = 1;
	FSM_CHECKED_FLAG = 0;													// Set flag to check FSM on next main program iteration
 80299d4:	4b06      	ldr	r3, [pc, #24]	; (80299f0 <HAL_SPI_TxRxCpltCallback+0x48>)
 80299d6:	2200      	movs	r2, #0
 80299d8:	601a      	str	r2, [r3, #0]

}
 80299da:	bf00      	nop
 80299dc:	3708      	adds	r7, #8
 80299de:	46bd      	mov	sp, r7
 80299e0:	bd80      	pop	{r7, pc}
 80299e2:	bf00      	nop
 80299e4:	20001bc0 	.word	0x20001bc0
 80299e8:	20001a38 	.word	0x20001a38
 80299ec:	20001a3c 	.word	0x20001a3c
 80299f0:	20000698 	.word	0x20000698

080299f4 <DMA_FSM_BURST6>:
 * state 1: read execution
 * 			BUFFER_ORDER  6 read execution
 * 			BUFFER_ORDER: 0 data storage
 */
void DMA_FSM_BURST6(int *csCount, struct RxBuffer *My, int I[nIMUs])
{
 80299f4:	b590      	push	{r4, r7, lr}
 80299f6:	b087      	sub	sp, #28
 80299f8:	af02      	add	r7, sp, #8
 80299fa:	60f8      	str	r0, [r7, #12]
 80299fc:	60b9      	str	r1, [r7, #8]
 80299fe:	607a      	str	r2, [r7, #4]
	FSM_CHECKED_FLAG = 1;
 8029a00:	4b7b      	ldr	r3, [pc, #492]	; (8029bf0 <DMA_FSM_BURST6+0x1fc>)
 8029a02:	2201      	movs	r2, #1
 8029a04:	601a      	str	r2, [r3, #0]
	if(((EDMA[2]&isEmptyDMA)==isEmptyDMA))													// Check if FIFO is empty (logical AND between FIFO_S2 register value and isEmpty bit)
 8029a06:	4b7b      	ldr	r3, [pc, #492]	; (8029bf4 <DMA_FSM_BURST6+0x200>)
 8029a08:	789b      	ldrb	r3, [r3, #2]
 8029a0a:	f003 0310 	and.w	r3, r3, #16
 8029a0e:	2b00      	cmp	r3, #0
 8029a10:	d01e      	beq.n	8029a50 <DMA_FSM_BURST6+0x5c>
	{																						// If empty, reset FIFO data available flag, change to next IMU in array, and read its FIFO status register
		fFIFO_DATA_AVAIL = 0;
 8029a12:	4b79      	ldr	r3, [pc, #484]	; (8029bf8 <DMA_FSM_BURST6+0x204>)
 8029a14:	2200      	movs	r2, #0
 8029a16:	601a      	str	r2, [r3, #0]
		*csCount = *csCount ==(nIMUs-1)? 0 : *csCount+1;
 8029a18:	68fb      	ldr	r3, [r7, #12]
 8029a1a:	681b      	ldr	r3, [r3, #0]
 8029a1c:	2b05      	cmp	r3, #5
 8029a1e:	d003      	beq.n	8029a28 <DMA_FSM_BURST6+0x34>
 8029a20:	68fb      	ldr	r3, [r7, #12]
 8029a22:	681b      	ldr	r3, [r3, #0]
 8029a24:	3301      	adds	r3, #1
 8029a26:	e000      	b.n	8029a2a <DMA_FSM_BURST6+0x36>
 8029a28:	2300      	movs	r3, #0
 8029a2a:	68fa      	ldr	r2, [r7, #12]
 8029a2c:	6013      	str	r3, [r2, #0]
		chipSelection(*csCount);
 8029a2e:	68fb      	ldr	r3, [r7, #12]
 8029a30:	681b      	ldr	r3, [r3, #0]
 8029a32:	4618      	mov	r0, r3
 8029a34:	f000 fa46 	bl	8029ec4 <chipSelection>
		spi_DMA_RX(FIFO_S2, EDMA, Ports, Pins,2);
 8029a38:	4b70      	ldr	r3, [pc, #448]	; (8029bfc <DMA_FSM_BURST6+0x208>)
 8029a3a:	681a      	ldr	r2, [r3, #0]
 8029a3c:	4b70      	ldr	r3, [pc, #448]	; (8029c00 <DMA_FSM_BURST6+0x20c>)
 8029a3e:	8819      	ldrh	r1, [r3, #0]
 8029a40:	2302      	movs	r3, #2
 8029a42:	9300      	str	r3, [sp, #0]
 8029a44:	460b      	mov	r3, r1
 8029a46:	496b      	ldr	r1, [pc, #428]	; (8029bf4 <DMA_FSM_BURST6+0x200>)
 8029a48:	486e      	ldr	r0, [pc, #440]	; (8029c04 <DMA_FSM_BURST6+0x210>)
 8029a4a:	f001 fc49 	bl	802b2e0 <spi_DMA_RX>
				fFIFO_DATA_AVAIL = 0;
				spi_DMA_RX(FIFO_S2, EDMA, Ports, Pins, 2);
				break;
		}
	}
}
 8029a4e:	e0cb      	b.n	8029be8 <DMA_FSM_BURST6+0x1f4>
		switch (fFIFO_DATA_AVAIL)
 8029a50:	4b69      	ldr	r3, [pc, #420]	; (8029bf8 <DMA_FSM_BURST6+0x204>)
 8029a52:	681b      	ldr	r3, [r3, #0]
 8029a54:	2b00      	cmp	r3, #0
 8029a56:	d002      	beq.n	8029a5e <DMA_FSM_BURST6+0x6a>
 8029a58:	2b01      	cmp	r3, #1
 8029a5a:	d00f      	beq.n	8029a7c <DMA_FSM_BURST6+0x88>
}
 8029a5c:	e0c4      	b.n	8029be8 <DMA_FSM_BURST6+0x1f4>
				fFIFO_DATA_AVAIL = 1;														// Set FIFO data available flag to indicate read was initiated
 8029a5e:	4b66      	ldr	r3, [pc, #408]	; (8029bf8 <DMA_FSM_BURST6+0x204>)
 8029a60:	2201      	movs	r2, #1
 8029a62:	601a      	str	r2, [r3, #0]
				spi_DMA_RX(&FIFO_ADD6[0], TEMP6, Ports, Pins, 13);								// Initiate read
 8029a64:	4b65      	ldr	r3, [pc, #404]	; (8029bfc <DMA_FSM_BURST6+0x208>)
 8029a66:	681a      	ldr	r2, [r3, #0]
 8029a68:	4b65      	ldr	r3, [pc, #404]	; (8029c00 <DMA_FSM_BURST6+0x20c>)
 8029a6a:	8819      	ldrh	r1, [r3, #0]
 8029a6c:	230d      	movs	r3, #13
 8029a6e:	9300      	str	r3, [sp, #0]
 8029a70:	460b      	mov	r3, r1
 8029a72:	4965      	ldr	r1, [pc, #404]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029a74:	4865      	ldr	r0, [pc, #404]	; (8029c0c <DMA_FSM_BURST6+0x218>)
 8029a76:	f001 fc33 	bl	802b2e0 <spi_DMA_RX>
				break;
 8029a7a:	e0b5      	b.n	8029be8 <DMA_FSM_BURST6+0x1f4>
				My[*csCount].RxBuffer_OMX[I[*csCount]] = (int16_t)((TEMP6[4]<<8)|(TEMP6[2]));
 8029a7c:	4b62      	ldr	r3, [pc, #392]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029a7e:	791b      	ldrb	r3, [r3, #4]
 8029a80:	021b      	lsls	r3, r3, #8
 8029a82:	b218      	sxth	r0, r3
 8029a84:	4b60      	ldr	r3, [pc, #384]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029a86:	789b      	ldrb	r3, [r3, #2]
 8029a88:	b219      	sxth	r1, r3
 8029a8a:	68fb      	ldr	r3, [r7, #12]
 8029a8c:	681b      	ldr	r3, [r3, #0]
 8029a8e:	461a      	mov	r2, r3
 8029a90:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8029a94:	fb03 f302 	mul.w	r3, r3, r2
 8029a98:	68ba      	ldr	r2, [r7, #8]
 8029a9a:	4413      	add	r3, r2
 8029a9c:	68fa      	ldr	r2, [r7, #12]
 8029a9e:	6812      	ldr	r2, [r2, #0]
 8029aa0:	0092      	lsls	r2, r2, #2
 8029aa2:	687c      	ldr	r4, [r7, #4]
 8029aa4:	4422      	add	r2, r4
 8029aa6:	6812      	ldr	r2, [r2, #0]
 8029aa8:	4301      	orrs	r1, r0
 8029aaa:	b209      	sxth	r1, r1
 8029aac:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_OMY[I[*csCount]] =  (int16_t)((TEMP6[8]<<8)|(TEMP6[6]));
 8029ab0:	4b55      	ldr	r3, [pc, #340]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029ab2:	7a1b      	ldrb	r3, [r3, #8]
 8029ab4:	021b      	lsls	r3, r3, #8
 8029ab6:	b218      	sxth	r0, r3
 8029ab8:	4b53      	ldr	r3, [pc, #332]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029aba:	799b      	ldrb	r3, [r3, #6]
 8029abc:	b219      	sxth	r1, r3
 8029abe:	68fb      	ldr	r3, [r7, #12]
 8029ac0:	681b      	ldr	r3, [r3, #0]
 8029ac2:	461a      	mov	r2, r3
 8029ac4:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8029ac8:	fb03 f302 	mul.w	r3, r3, r2
 8029acc:	68ba      	ldr	r2, [r7, #8]
 8029ace:	4413      	add	r3, r2
 8029ad0:	68fa      	ldr	r2, [r7, #12]
 8029ad2:	6812      	ldr	r2, [r2, #0]
 8029ad4:	0092      	lsls	r2, r2, #2
 8029ad6:	687c      	ldr	r4, [r7, #4]
 8029ad8:	4422      	add	r2, r4
 8029ada:	6812      	ldr	r2, [r2, #0]
 8029adc:	4301      	orrs	r1, r0
 8029ade:	b209      	sxth	r1, r1
 8029ae0:	3264      	adds	r2, #100	; 0x64
 8029ae2:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_OMZ[I[*csCount]] = (int16_t)((TEMP6[12]<<8)|(TEMP6[10]));
 8029ae6:	4b48      	ldr	r3, [pc, #288]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029ae8:	7b1b      	ldrb	r3, [r3, #12]
 8029aea:	021b      	lsls	r3, r3, #8
 8029aec:	b218      	sxth	r0, r3
 8029aee:	4b46      	ldr	r3, [pc, #280]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029af0:	7a9b      	ldrb	r3, [r3, #10]
 8029af2:	b219      	sxth	r1, r3
 8029af4:	68fb      	ldr	r3, [r7, #12]
 8029af6:	681b      	ldr	r3, [r3, #0]
 8029af8:	461a      	mov	r2, r3
 8029afa:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8029afe:	fb03 f302 	mul.w	r3, r3, r2
 8029b02:	68ba      	ldr	r2, [r7, #8]
 8029b04:	4413      	add	r3, r2
 8029b06:	68fa      	ldr	r2, [r7, #12]
 8029b08:	6812      	ldr	r2, [r2, #0]
 8029b0a:	0092      	lsls	r2, r2, #2
 8029b0c:	687c      	ldr	r4, [r7, #4]
 8029b0e:	4422      	add	r2, r4
 8029b10:	6812      	ldr	r2, [r2, #0]
 8029b12:	4301      	orrs	r1, r0
 8029b14:	b209      	sxth	r1, r1
 8029b16:	32c8      	adds	r2, #200	; 0xc8
 8029b18:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_AX[I[*csCount]] =  (int16_t)((TEMP6[16]<<8)|(TEMP6[14]));
 8029b1c:	4b3a      	ldr	r3, [pc, #232]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029b1e:	7c1b      	ldrb	r3, [r3, #16]
 8029b20:	021b      	lsls	r3, r3, #8
 8029b22:	b218      	sxth	r0, r3
 8029b24:	4b38      	ldr	r3, [pc, #224]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029b26:	7b9b      	ldrb	r3, [r3, #14]
 8029b28:	b219      	sxth	r1, r3
 8029b2a:	68fb      	ldr	r3, [r7, #12]
 8029b2c:	681b      	ldr	r3, [r3, #0]
 8029b2e:	461a      	mov	r2, r3
 8029b30:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8029b34:	fb03 f302 	mul.w	r3, r3, r2
 8029b38:	68ba      	ldr	r2, [r7, #8]
 8029b3a:	4413      	add	r3, r2
 8029b3c:	68fa      	ldr	r2, [r7, #12]
 8029b3e:	6812      	ldr	r2, [r2, #0]
 8029b40:	0092      	lsls	r2, r2, #2
 8029b42:	687c      	ldr	r4, [r7, #4]
 8029b44:	4422      	add	r2, r4
 8029b46:	6812      	ldr	r2, [r2, #0]
 8029b48:	4301      	orrs	r1, r0
 8029b4a:	b209      	sxth	r1, r1
 8029b4c:	f502 7296 	add.w	r2, r2, #300	; 0x12c
 8029b50:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_AY[I[*csCount]] = (int16_t)((TEMP6[20]<<8)|(TEMP6[18]));
 8029b54:	4b2c      	ldr	r3, [pc, #176]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029b56:	7d1b      	ldrb	r3, [r3, #20]
 8029b58:	021b      	lsls	r3, r3, #8
 8029b5a:	b218      	sxth	r0, r3
 8029b5c:	4b2a      	ldr	r3, [pc, #168]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029b5e:	7c9b      	ldrb	r3, [r3, #18]
 8029b60:	b219      	sxth	r1, r3
 8029b62:	68fb      	ldr	r3, [r7, #12]
 8029b64:	681b      	ldr	r3, [r3, #0]
 8029b66:	461a      	mov	r2, r3
 8029b68:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8029b6c:	fb03 f302 	mul.w	r3, r3, r2
 8029b70:	68ba      	ldr	r2, [r7, #8]
 8029b72:	4413      	add	r3, r2
 8029b74:	68fa      	ldr	r2, [r7, #12]
 8029b76:	6812      	ldr	r2, [r2, #0]
 8029b78:	0092      	lsls	r2, r2, #2
 8029b7a:	687c      	ldr	r4, [r7, #4]
 8029b7c:	4422      	add	r2, r4
 8029b7e:	6812      	ldr	r2, [r2, #0]
 8029b80:	4301      	orrs	r1, r0
 8029b82:	b209      	sxth	r1, r1
 8029b84:	f502 72c8 	add.w	r2, r2, #400	; 0x190
 8029b88:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_AZ[I[*csCount]] = (int16_t)((TEMP6[24]<<8)|(TEMP6[22]));
 8029b8c:	4b1e      	ldr	r3, [pc, #120]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029b8e:	7e1b      	ldrb	r3, [r3, #24]
 8029b90:	021b      	lsls	r3, r3, #8
 8029b92:	b218      	sxth	r0, r3
 8029b94:	4b1c      	ldr	r3, [pc, #112]	; (8029c08 <DMA_FSM_BURST6+0x214>)
 8029b96:	7d9b      	ldrb	r3, [r3, #22]
 8029b98:	b219      	sxth	r1, r3
 8029b9a:	68fb      	ldr	r3, [r7, #12]
 8029b9c:	681b      	ldr	r3, [r3, #0]
 8029b9e:	461a      	mov	r2, r3
 8029ba0:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8029ba4:	fb03 f302 	mul.w	r3, r3, r2
 8029ba8:	68ba      	ldr	r2, [r7, #8]
 8029baa:	4413      	add	r3, r2
 8029bac:	68fa      	ldr	r2, [r7, #12]
 8029bae:	6812      	ldr	r2, [r2, #0]
 8029bb0:	0092      	lsls	r2, r2, #2
 8029bb2:	687c      	ldr	r4, [r7, #4]
 8029bb4:	4422      	add	r2, r4
 8029bb6:	6812      	ldr	r2, [r2, #0]
 8029bb8:	4301      	orrs	r1, r0
 8029bba:	b209      	sxth	r1, r1
 8029bbc:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
 8029bc0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				DP_FLAG = 1;
 8029bc4:	4b12      	ldr	r3, [pc, #72]	; (8029c10 <DMA_FSM_BURST6+0x21c>)
 8029bc6:	2201      	movs	r2, #1
 8029bc8:	601a      	str	r2, [r3, #0]
				fFIFO_DATA_AVAIL = 0;
 8029bca:	4b0b      	ldr	r3, [pc, #44]	; (8029bf8 <DMA_FSM_BURST6+0x204>)
 8029bcc:	2200      	movs	r2, #0
 8029bce:	601a      	str	r2, [r3, #0]
				spi_DMA_RX(FIFO_S2, EDMA, Ports, Pins, 2);
 8029bd0:	4b0a      	ldr	r3, [pc, #40]	; (8029bfc <DMA_FSM_BURST6+0x208>)
 8029bd2:	681a      	ldr	r2, [r3, #0]
 8029bd4:	4b0a      	ldr	r3, [pc, #40]	; (8029c00 <DMA_FSM_BURST6+0x20c>)
 8029bd6:	8819      	ldrh	r1, [r3, #0]
 8029bd8:	2302      	movs	r3, #2
 8029bda:	9300      	str	r3, [sp, #0]
 8029bdc:	460b      	mov	r3, r1
 8029bde:	4905      	ldr	r1, [pc, #20]	; (8029bf4 <DMA_FSM_BURST6+0x200>)
 8029be0:	4808      	ldr	r0, [pc, #32]	; (8029c04 <DMA_FSM_BURST6+0x210>)
 8029be2:	f001 fb7d 	bl	802b2e0 <spi_DMA_RX>
				break;
 8029be6:	bf00      	nop
}
 8029be8:	bf00      	nop
 8029bea:	3714      	adds	r7, #20
 8029bec:	46bd      	mov	sp, r7
 8029bee:	bd90      	pop	{r4, r7, pc}
 8029bf0:	20000698 	.word	0x20000698
 8029bf4:	20000694 	.word	0x20000694
 8029bf8:	20000678 	.word	0x20000678
 8029bfc:	20001a38 	.word	0x20001a38
 8029c00:	20001a3c 	.word	0x20001a3c
 8029c04:	200005b0 	.word	0x200005b0
 8029c08:	2000065c 	.word	0x2000065c
 8029c0c:	200005a0 	.word	0x200005a0
 8029c10:	2000069c 	.word	0x2000069c

08029c14 <MX_GPIO_Init>:
  * @param None
  * @retval None
  */
#include "main.h"
void MX_GPIO_Init(void)
{
 8029c14:	b580      	push	{r7, lr}
 8029c16:	b08a      	sub	sp, #40	; 0x28
 8029c18:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8029c1a:	f107 0314 	add.w	r3, r7, #20
 8029c1e:	2200      	movs	r2, #0
 8029c20:	601a      	str	r2, [r3, #0]
 8029c22:	605a      	str	r2, [r3, #4]
 8029c24:	609a      	str	r2, [r3, #8]
 8029c26:	60da      	str	r2, [r3, #12]
 8029c28:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
 8029c2a:	2300      	movs	r3, #0
 8029c2c:	613b      	str	r3, [r7, #16]
 8029c2e:	4b3b      	ldr	r3, [pc, #236]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c32:	4a3a      	ldr	r2, [pc, #232]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c34:	f043 0304 	orr.w	r3, r3, #4
 8029c38:	6313      	str	r3, [r2, #48]	; 0x30
 8029c3a:	4b38      	ldr	r3, [pc, #224]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c3c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c3e:	f003 0304 	and.w	r3, r3, #4
 8029c42:	613b      	str	r3, [r7, #16]
 8029c44:	693b      	ldr	r3, [r7, #16]
	__HAL_RCC_GPIOH_CLK_ENABLE();
 8029c46:	2300      	movs	r3, #0
 8029c48:	60fb      	str	r3, [r7, #12]
 8029c4a:	4b34      	ldr	r3, [pc, #208]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c4e:	4a33      	ldr	r2, [pc, #204]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c50:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8029c54:	6313      	str	r3, [r2, #48]	; 0x30
 8029c56:	4b31      	ldr	r3, [pc, #196]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c5a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8029c5e:	60fb      	str	r3, [r7, #12]
 8029c60:	68fb      	ldr	r3, [r7, #12]
	__HAL_RCC_GPIOA_CLK_ENABLE();
 8029c62:	2300      	movs	r3, #0
 8029c64:	60bb      	str	r3, [r7, #8]
 8029c66:	4b2d      	ldr	r3, [pc, #180]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c6a:	4a2c      	ldr	r2, [pc, #176]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c6c:	f043 0301 	orr.w	r3, r3, #1
 8029c70:	6313      	str	r3, [r2, #48]	; 0x30
 8029c72:	4b2a      	ldr	r3, [pc, #168]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c74:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c76:	f003 0301 	and.w	r3, r3, #1
 8029c7a:	60bb      	str	r3, [r7, #8]
 8029c7c:	68bb      	ldr	r3, [r7, #8]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 8029c7e:	2300      	movs	r3, #0
 8029c80:	607b      	str	r3, [r7, #4]
 8029c82:	4b26      	ldr	r3, [pc, #152]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c86:	4a25      	ldr	r2, [pc, #148]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c88:	f043 0302 	orr.w	r3, r3, #2
 8029c8c:	6313      	str	r3, [r2, #48]	; 0x30
 8029c8e:	4b23      	ldr	r3, [pc, #140]	; (8029d1c <MX_GPIO_Init+0x108>)
 8029c90:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8029c92:	f003 0302 	and.w	r3, r3, #2
 8029c96:	607b      	str	r3, [r7, #4]
 8029c98:	687b      	ldr	r3, [r7, #4]

	GPIO_InitStruct.Pin = GPIO_PIN_8;
 8029c9a:	f44f 7380 	mov.w	r3, #256	; 0x100
 8029c9e:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8029ca0:	2301      	movs	r3, #1
 8029ca2:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8029ca4:	2300      	movs	r3, #0
 8029ca6:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8029ca8:	2300      	movs	r3, #0
 8029caa:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8029cac:	f107 0314 	add.w	r3, r7, #20
 8029cb0:	4619      	mov	r1, r3
 8029cb2:	481b      	ldr	r0, [pc, #108]	; (8029d20 <MX_GPIO_Init+0x10c>)
 8029cb4:	f002 fddc 	bl	802c870 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_15;
 8029cb8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8029cbc:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8029cbe:	2300      	movs	r3, #0
 8029cc0:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8029cc2:	2302      	movs	r3, #2
 8029cc4:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8029cc6:	2300      	movs	r3, #0
 8029cc8:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8029cca:	f107 0314 	add.w	r3, r7, #20
 8029cce:	4619      	mov	r1, r3
 8029cd0:	4813      	ldr	r0, [pc, #76]	; (8029d20 <MX_GPIO_Init+0x10c>)
 8029cd2:	f002 fdcd 	bl	802c870 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_3|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_2;
 8029cd6:	f24e 033c 	movw	r3, #57404	; 0xe03c
 8029cda:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8029cdc:	2301      	movs	r3, #1
 8029cde:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8029ce0:	2300      	movs	r3, #0
 8029ce2:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8029ce4:	2300      	movs	r3, #0
 8029ce6:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8029ce8:	f107 0314 	add.w	r3, r7, #20
 8029cec:	4619      	mov	r1, r3
 8029cee:	480d      	ldr	r0, [pc, #52]	; (8029d24 <MX_GPIO_Init+0x110>)
 8029cf0:	f002 fdbe 	bl	802c870 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_0|GPIO_PIN_10|GPIO_PIN_7;
 8029cf4:	f640 4381 	movw	r3, #3201	; 0xc81
 8029cf8:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8029cfa:	2301      	movs	r3, #1
 8029cfc:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8029cfe:	2300      	movs	r3, #0
 8029d00:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8029d02:	2300      	movs	r3, #0
 8029d04:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8029d06:	f107 0314 	add.w	r3, r7, #20
 8029d0a:	4619      	mov	r1, r3
 8029d0c:	4806      	ldr	r0, [pc, #24]	; (8029d28 <MX_GPIO_Init+0x114>)
 8029d0e:	f002 fdaf 	bl	802c870 <HAL_GPIO_Init>

}
 8029d12:	bf00      	nop
 8029d14:	3728      	adds	r7, #40	; 0x28
 8029d16:	46bd      	mov	sp, r7
 8029d18:	bd80      	pop	{r7, pc}
 8029d1a:	bf00      	nop
 8029d1c:	40023800 	.word	0x40023800
 8029d20:	40020000 	.word	0x40020000
 8029d24:	40020400 	.word	0x40020400
 8029d28:	40020800 	.word	0x40020800

08029d2c <Buffer_Init>:

//Set struct My to zero after declaration
//Input My, pass by pointer
//Output NONE
void Buffer_Init(struct RxBuffer My[])
{
 8029d2c:	b580      	push	{r7, lr}
 8029d2e:	b084      	sub	sp, #16
 8029d30:	af00      	add	r7, sp, #0
 8029d32:	6078      	str	r0, [r7, #4]
	for(int i = 0; i<nIMUs; i++)
 8029d34:	2300      	movs	r3, #0
 8029d36:	60fb      	str	r3, [r7, #12]
 8029d38:	e053      	b.n	8029de2 <Buffer_Init+0xb6>
	{
		memset (My[i].RxBuffer_OMX, 0, sizeof(My[i].RxBuffer_OMX));
 8029d3a:	68fb      	ldr	r3, [r7, #12]
 8029d3c:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029d40:	fb02 f303 	mul.w	r3, r2, r3
 8029d44:	687a      	ldr	r2, [r7, #4]
 8029d46:	4413      	add	r3, r2
 8029d48:	22c8      	movs	r2, #200	; 0xc8
 8029d4a:	2100      	movs	r1, #0
 8029d4c:	4618      	mov	r0, r3
 8029d4e:	f006 f9b9 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_OMY, 0, sizeof(My[i].RxBuffer_OMY));
 8029d52:	68fb      	ldr	r3, [r7, #12]
 8029d54:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029d58:	fb02 f303 	mul.w	r3, r2, r3
 8029d5c:	687a      	ldr	r2, [r7, #4]
 8029d5e:	4413      	add	r3, r2
 8029d60:	33c8      	adds	r3, #200	; 0xc8
 8029d62:	22c8      	movs	r2, #200	; 0xc8
 8029d64:	2100      	movs	r1, #0
 8029d66:	4618      	mov	r0, r3
 8029d68:	f006 f9ac 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_OMZ, 0, sizeof(My[i].RxBuffer_OMZ));
 8029d6c:	68fb      	ldr	r3, [r7, #12]
 8029d6e:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029d72:	fb02 f303 	mul.w	r3, r2, r3
 8029d76:	687a      	ldr	r2, [r7, #4]
 8029d78:	4413      	add	r3, r2
 8029d7a:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8029d7e:	22c8      	movs	r2, #200	; 0xc8
 8029d80:	2100      	movs	r1, #0
 8029d82:	4618      	mov	r0, r3
 8029d84:	f006 f99e 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_AX,  0, sizeof(My[i].RxBuffer_AX));
 8029d88:	68fb      	ldr	r3, [r7, #12]
 8029d8a:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029d8e:	fb02 f303 	mul.w	r3, r2, r3
 8029d92:	687a      	ldr	r2, [r7, #4]
 8029d94:	4413      	add	r3, r2
 8029d96:	f503 7316 	add.w	r3, r3, #600	; 0x258
 8029d9a:	22c8      	movs	r2, #200	; 0xc8
 8029d9c:	2100      	movs	r1, #0
 8029d9e:	4618      	mov	r0, r3
 8029da0:	f006 f990 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_AY,  0, sizeof(My[i].RxBuffer_AY));
 8029da4:	68fb      	ldr	r3, [r7, #12]
 8029da6:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029daa:	fb02 f303 	mul.w	r3, r2, r3
 8029dae:	687a      	ldr	r2, [r7, #4]
 8029db0:	4413      	add	r3, r2
 8029db2:	f503 7348 	add.w	r3, r3, #800	; 0x320
 8029db6:	22c8      	movs	r2, #200	; 0xc8
 8029db8:	2100      	movs	r1, #0
 8029dba:	4618      	mov	r0, r3
 8029dbc:	f006 f982 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_AZ,  0, sizeof(My[i].RxBuffer_AZ));
 8029dc0:	68fb      	ldr	r3, [r7, #12]
 8029dc2:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029dc6:	fb02 f303 	mul.w	r3, r2, r3
 8029dca:	687a      	ldr	r2, [r7, #4]
 8029dcc:	4413      	add	r3, r2
 8029dce:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8029dd2:	22c8      	movs	r2, #200	; 0xc8
 8029dd4:	2100      	movs	r1, #0
 8029dd6:	4618      	mov	r0, r3
 8029dd8:	f006 f974 	bl	80300c4 <memset>
	for(int i = 0; i<nIMUs; i++)
 8029ddc:	68fb      	ldr	r3, [r7, #12]
 8029dde:	3301      	adds	r3, #1
 8029de0:	60fb      	str	r3, [r7, #12]
 8029de2:	68fb      	ldr	r3, [r7, #12]
 8029de4:	2b05      	cmp	r3, #5
 8029de6:	dda8      	ble.n	8029d3a <Buffer_Init+0xe>
	}
}
 8029de8:	bf00      	nop
 8029dea:	3710      	adds	r7, #16
 8029dec:	46bd      	mov	sp, r7
 8029dee:	bd80      	pop	{r7, pc}

08029df0 <Calib_Buffer_Init>:

void Calib_Buffer_Init(struct CalibBuffer My[])
{
 8029df0:	b580      	push	{r7, lr}
 8029df2:	b084      	sub	sp, #16
 8029df4:	af00      	add	r7, sp, #0
 8029df6:	6078      	str	r0, [r7, #4]
	for(int i = 0; i<nIMUs; i++)
 8029df8:	2300      	movs	r3, #0
 8029dfa:	60fb      	str	r3, [r7, #12]
 8029dfc:	e05a      	b.n	8029eb4 <Calib_Buffer_Init+0xc4>
	{
		memset (My[i].RxBuffer_OMX, 0, sizeof(My[i].RxBuffer_OMX));
 8029dfe:	68fb      	ldr	r3, [r7, #12]
 8029e00:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029e04:	fb02 f303 	mul.w	r3, r2, r3
 8029e08:	687a      	ldr	r2, [r7, #4]
 8029e0a:	4413      	add	r3, r2
 8029e0c:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029e10:	2100      	movs	r1, #0
 8029e12:	4618      	mov	r0, r3
 8029e14:	f006 f956 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_OMY, 0, sizeof(My[i].RxBuffer_OMY));
 8029e18:	68fb      	ldr	r3, [r7, #12]
 8029e1a:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029e1e:	fb02 f303 	mul.w	r3, r2, r3
 8029e22:	687a      	ldr	r2, [r7, #4]
 8029e24:	4413      	add	r3, r2
 8029e26:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8029e2a:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029e2e:	2100      	movs	r1, #0
 8029e30:	4618      	mov	r0, r3
 8029e32:	f006 f947 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_OMZ, 0, sizeof(My[i].RxBuffer_OMZ));
 8029e36:	68fb      	ldr	r3, [r7, #12]
 8029e38:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029e3c:	fb02 f303 	mul.w	r3, r2, r3
 8029e40:	687a      	ldr	r2, [r7, #4]
 8029e42:	4413      	add	r3, r2
 8029e44:	f503 7348 	add.w	r3, r3, #800	; 0x320
 8029e48:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029e4c:	2100      	movs	r1, #0
 8029e4e:	4618      	mov	r0, r3
 8029e50:	f006 f938 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_AX,  0, sizeof(My[i].RxBuffer_AX));
 8029e54:	68fb      	ldr	r3, [r7, #12]
 8029e56:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029e5a:	fb02 f303 	mul.w	r3, r2, r3
 8029e5e:	687a      	ldr	r2, [r7, #4]
 8029e60:	4413      	add	r3, r2
 8029e62:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 8029e66:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029e6a:	2100      	movs	r1, #0
 8029e6c:	4618      	mov	r0, r3
 8029e6e:	f006 f929 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_AY,  0, sizeof(My[i].RxBuffer_AY));
 8029e72:	68fb      	ldr	r3, [r7, #12]
 8029e74:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029e78:	fb02 f303 	mul.w	r3, r2, r3
 8029e7c:	687a      	ldr	r2, [r7, #4]
 8029e7e:	4413      	add	r3, r2
 8029e80:	f503 63c8 	add.w	r3, r3, #1600	; 0x640
 8029e84:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029e88:	2100      	movs	r1, #0
 8029e8a:	4618      	mov	r0, r3
 8029e8c:	f006 f91a 	bl	80300c4 <memset>
		memset (My[i].RxBuffer_AZ,  0, sizeof(My[i].RxBuffer_AZ));
 8029e90:	68fb      	ldr	r3, [r7, #12]
 8029e92:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029e96:	fb02 f303 	mul.w	r3, r2, r3
 8029e9a:	687a      	ldr	r2, [r7, #4]
 8029e9c:	4413      	add	r3, r2
 8029e9e:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 8029ea2:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029ea6:	2100      	movs	r1, #0
 8029ea8:	4618      	mov	r0, r3
 8029eaa:	f006 f90b 	bl	80300c4 <memset>
	for(int i = 0; i<nIMUs; i++)
 8029eae:	68fb      	ldr	r3, [r7, #12]
 8029eb0:	3301      	adds	r3, #1
 8029eb2:	60fb      	str	r3, [r7, #12]
 8029eb4:	68fb      	ldr	r3, [r7, #12]
 8029eb6:	2b05      	cmp	r3, #5
 8029eb8:	dda1      	ble.n	8029dfe <Calib_Buffer_Init+0xe>
	}
}
 8029eba:	bf00      	nop
 8029ebc:	3710      	adds	r7, #16
 8029ebe:	46bd      	mov	sp, r7
 8029ec0:	bd80      	pop	{r7, pc}
	...

08029ec4 <chipSelection>:
}

//SPI chip selection
//Output: change CS GPIO globally
void chipSelection(int cs)
{
 8029ec4:	b580      	push	{r7, lr}
 8029ec6:	b082      	sub	sp, #8
 8029ec8:	af00      	add	r7, sp, #0
 8029eca:	6078      	str	r0, [r7, #4]
	switch(cs)
 8029ecc:	687b      	ldr	r3, [r7, #4]
 8029ece:	2b05      	cmp	r3, #5
 8029ed0:	d86b      	bhi.n	8029faa <chipSelection+0xe6>
 8029ed2:	a201      	add	r2, pc, #4	; (adr r2, 8029ed8 <chipSelection+0x14>)
 8029ed4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8029ed8:	08029ef1 	.word	0x08029ef1
 8029edc:	08029f11 	.word	0x08029f11
 8029ee0:	08029f31 	.word	0x08029f31
 8029ee4:	08029f51 	.word	0x08029f51
 8029ee8:	08029f6f 	.word	0x08029f6f
 8029eec:	08029f8d 	.word	0x08029f8d
	{
	  case 0:
		  Ports = GPIOB;
 8029ef0:	4b30      	ldr	r3, [pc, #192]	; (8029fb4 <chipSelection+0xf0>)
 8029ef2:	4a31      	ldr	r2, [pc, #196]	; (8029fb8 <chipSelection+0xf4>)
 8029ef4:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_15;
 8029ef6:	4b31      	ldr	r3, [pc, #196]	; (8029fbc <chipSelection+0xf8>)
 8029ef8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8029efc:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029efe:	4b2d      	ldr	r3, [pc, #180]	; (8029fb4 <chipSelection+0xf0>)
 8029f00:	6818      	ldr	r0, [r3, #0]
 8029f02:	4b2e      	ldr	r3, [pc, #184]	; (8029fbc <chipSelection+0xf8>)
 8029f04:	881b      	ldrh	r3, [r3, #0]
 8029f06:	2201      	movs	r2, #1
 8029f08:	4619      	mov	r1, r3
 8029f0a:	f002 fe4b 	bl	802cba4 <HAL_GPIO_WritePin>
		  break;
 8029f0e:	e04c      	b.n	8029faa <chipSelection+0xe6>
	  case 1:
		  Ports = GPIOB;
 8029f10:	4b28      	ldr	r3, [pc, #160]	; (8029fb4 <chipSelection+0xf0>)
 8029f12:	4a29      	ldr	r2, [pc, #164]	; (8029fb8 <chipSelection+0xf4>)
 8029f14:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_14;
 8029f16:	4b29      	ldr	r3, [pc, #164]	; (8029fbc <chipSelection+0xf8>)
 8029f18:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8029f1c:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029f1e:	4b25      	ldr	r3, [pc, #148]	; (8029fb4 <chipSelection+0xf0>)
 8029f20:	6818      	ldr	r0, [r3, #0]
 8029f22:	4b26      	ldr	r3, [pc, #152]	; (8029fbc <chipSelection+0xf8>)
 8029f24:	881b      	ldrh	r3, [r3, #0]
 8029f26:	2201      	movs	r2, #1
 8029f28:	4619      	mov	r1, r3
 8029f2a:	f002 fe3b 	bl	802cba4 <HAL_GPIO_WritePin>
		  break;
 8029f2e:	e03c      	b.n	8029faa <chipSelection+0xe6>
	  case 2:
		  Ports = GPIOB;
 8029f30:	4b20      	ldr	r3, [pc, #128]	; (8029fb4 <chipSelection+0xf0>)
 8029f32:	4a21      	ldr	r2, [pc, #132]	; (8029fb8 <chipSelection+0xf4>)
 8029f34:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_13;
 8029f36:	4b21      	ldr	r3, [pc, #132]	; (8029fbc <chipSelection+0xf8>)
 8029f38:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8029f3c:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029f3e:	4b1d      	ldr	r3, [pc, #116]	; (8029fb4 <chipSelection+0xf0>)
 8029f40:	6818      	ldr	r0, [r3, #0]
 8029f42:	4b1e      	ldr	r3, [pc, #120]	; (8029fbc <chipSelection+0xf8>)
 8029f44:	881b      	ldrh	r3, [r3, #0]
 8029f46:	2201      	movs	r2, #1
 8029f48:	4619      	mov	r1, r3
 8029f4a:	f002 fe2b 	bl	802cba4 <HAL_GPIO_WritePin>
		  break;
 8029f4e:	e02c      	b.n	8029faa <chipSelection+0xe6>
	  case 3:
		  Ports = GPIOB;
 8029f50:	4b18      	ldr	r3, [pc, #96]	; (8029fb4 <chipSelection+0xf0>)
 8029f52:	4a19      	ldr	r2, [pc, #100]	; (8029fb8 <chipSelection+0xf4>)
 8029f54:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_3;
 8029f56:	4b19      	ldr	r3, [pc, #100]	; (8029fbc <chipSelection+0xf8>)
 8029f58:	2208      	movs	r2, #8
 8029f5a:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029f5c:	4b15      	ldr	r3, [pc, #84]	; (8029fb4 <chipSelection+0xf0>)
 8029f5e:	6818      	ldr	r0, [r3, #0]
 8029f60:	4b16      	ldr	r3, [pc, #88]	; (8029fbc <chipSelection+0xf8>)
 8029f62:	881b      	ldrh	r3, [r3, #0]
 8029f64:	2201      	movs	r2, #1
 8029f66:	4619      	mov	r1, r3
 8029f68:	f002 fe1c 	bl	802cba4 <HAL_GPIO_WritePin>
		  break;
 8029f6c:	e01d      	b.n	8029faa <chipSelection+0xe6>
	  case 4:
		  Ports = GPIOB;
 8029f6e:	4b11      	ldr	r3, [pc, #68]	; (8029fb4 <chipSelection+0xf0>)
 8029f70:	4a11      	ldr	r2, [pc, #68]	; (8029fb8 <chipSelection+0xf4>)
 8029f72:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_4;
 8029f74:	4b11      	ldr	r3, [pc, #68]	; (8029fbc <chipSelection+0xf8>)
 8029f76:	2210      	movs	r2, #16
 8029f78:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029f7a:	4b0e      	ldr	r3, [pc, #56]	; (8029fb4 <chipSelection+0xf0>)
 8029f7c:	6818      	ldr	r0, [r3, #0]
 8029f7e:	4b0f      	ldr	r3, [pc, #60]	; (8029fbc <chipSelection+0xf8>)
 8029f80:	881b      	ldrh	r3, [r3, #0]
 8029f82:	2201      	movs	r2, #1
 8029f84:	4619      	mov	r1, r3
 8029f86:	f002 fe0d 	bl	802cba4 <HAL_GPIO_WritePin>
		  break;
 8029f8a:	e00e      	b.n	8029faa <chipSelection+0xe6>
	  case 5:
		  Ports = GPIOB;
 8029f8c:	4b09      	ldr	r3, [pc, #36]	; (8029fb4 <chipSelection+0xf0>)
 8029f8e:	4a0a      	ldr	r2, [pc, #40]	; (8029fb8 <chipSelection+0xf4>)
 8029f90:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_5;
 8029f92:	4b0a      	ldr	r3, [pc, #40]	; (8029fbc <chipSelection+0xf8>)
 8029f94:	2220      	movs	r2, #32
 8029f96:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029f98:	4b06      	ldr	r3, [pc, #24]	; (8029fb4 <chipSelection+0xf0>)
 8029f9a:	6818      	ldr	r0, [r3, #0]
 8029f9c:	4b07      	ldr	r3, [pc, #28]	; (8029fbc <chipSelection+0xf8>)
 8029f9e:	881b      	ldrh	r3, [r3, #0]
 8029fa0:	2201      	movs	r2, #1
 8029fa2:	4619      	mov	r1, r3
 8029fa4:	f002 fdfe 	bl	802cba4 <HAL_GPIO_WritePin>
		  break;
 8029fa8:	bf00      	nop
	}
}
 8029faa:	bf00      	nop
 8029fac:	3708      	adds	r7, #8
 8029fae:	46bd      	mov	sp, r7
 8029fb0:	bd80      	pop	{r7, pc}
 8029fb2:	bf00      	nop
 8029fb4:	20001a38 	.word	0x20001a38
 8029fb8:	40020400 	.word	0x40020400
 8029fbc:	20001a3c 	.word	0x20001a3c

08029fc0 <resetAll>:
//Reset configuration for all IMUs on the board (not just ones in use)
//Wait 5ms for proper reset
void resetAll()
{
 8029fc0:	b580      	push	{r7, lr}
 8029fc2:	b082      	sub	sp, #8
 8029fc4:	af00      	add	r7, sp, #0
	//for(int i =0; i<nIMUs;i++)
//	for(int i = nIMUs-1; i>=0; i--)
	for(int i = 5; i>=0; i--)
 8029fc6:	2305      	movs	r3, #5
 8029fc8:	607b      	str	r3, [r7, #4]
 8029fca:	e010      	b.n	8029fee <resetAll+0x2e>
	{
		chipSelection(i);
 8029fcc:	6878      	ldr	r0, [r7, #4]
 8029fce:	f7ff ff79 	bl	8029ec4 <chipSelection>
		IMU_reset(Ports, Pins);
 8029fd2:	4b0a      	ldr	r3, [pc, #40]	; (8029ffc <resetAll+0x3c>)
 8029fd4:	681a      	ldr	r2, [r3, #0]
 8029fd6:	4b0a      	ldr	r3, [pc, #40]	; (802a000 <resetAll+0x40>)
 8029fd8:	881b      	ldrh	r3, [r3, #0]
 8029fda:	4619      	mov	r1, r3
 8029fdc:	4610      	mov	r0, r2
 8029fde:	f000 f919 	bl	802a214 <IMU_reset>
		HAL_Delay(5);
 8029fe2:	2005      	movs	r0, #5
 8029fe4:	f001 ff80 	bl	802bee8 <HAL_Delay>
	for(int i = 5; i>=0; i--)
 8029fe8:	687b      	ldr	r3, [r7, #4]
 8029fea:	3b01      	subs	r3, #1
 8029fec:	607b      	str	r3, [r7, #4]
 8029fee:	687b      	ldr	r3, [r7, #4]
 8029ff0:	2b00      	cmp	r3, #0
 8029ff2:	daeb      	bge.n	8029fcc <resetAll+0xc>
	}
}
 8029ff4:	bf00      	nop
 8029ff6:	3708      	adds	r7, #8
 8029ff8:	46bd      	mov	sp, r7
 8029ffa:	bd80      	pop	{r7, pc}
 8029ffc:	20001a38 	.word	0x20001a38
 802a000:	20001a3c 	.word	0x20001a3c

0802a004 <setupAll>:
//Configure all IMUs on the board (not just ones in use)
void setupAll()
{
 802a004:	b580      	push	{r7, lr}
 802a006:	b082      	sub	sp, #8
 802a008:	af00      	add	r7, sp, #0
	//for (int i = 0; i<nIMUs; i++)
//	for(int i = nIMUs-1; i>=0; i--)
	for(int i = 5; i>=0; i--)
 802a00a:	2305      	movs	r3, #5
 802a00c:	607b      	str	r3, [r7, #4]
 802a00e:	e02d      	b.n	802a06c <setupAll+0x68>
	{
		chipSelection(i);
 802a010:	6878      	ldr	r0, [r7, #4]
 802a012:	f7ff ff57 	bl	8029ec4 <chipSelection>
		IMU_config(Ports, Pins);
 802a016:	4b19      	ldr	r3, [pc, #100]	; (802a07c <setupAll+0x78>)
 802a018:	681a      	ldr	r2, [r3, #0]
 802a01a:	4b19      	ldr	r3, [pc, #100]	; (802a080 <setupAll+0x7c>)
 802a01c:	881b      	ldrh	r3, [r3, #0]
 802a01e:	4619      	mov	r1, r3
 802a020:	4610      	mov	r0, r2
 802a022:	f000 f89f 	bl	802a164 <IMU_config>
		PEDO_config(Ports, Pins);
 802a026:	4b15      	ldr	r3, [pc, #84]	; (802a07c <setupAll+0x78>)
 802a028:	681a      	ldr	r2, [r3, #0]
 802a02a:	4b15      	ldr	r3, [pc, #84]	; (802a080 <setupAll+0x7c>)
 802a02c:	881b      	ldrh	r3, [r3, #0]
 802a02e:	4619      	mov	r1, r3
 802a030:	4610      	mov	r0, r2
 802a032:	f000 f827 	bl	802a084 <PEDO_config>
		TimeStamp_config(Ports, Pins);
 802a036:	4b11      	ldr	r3, [pc, #68]	; (802a07c <setupAll+0x78>)
 802a038:	681a      	ldr	r2, [r3, #0]
 802a03a:	4b11      	ldr	r3, [pc, #68]	; (802a080 <setupAll+0x7c>)
 802a03c:	881b      	ldrh	r3, [r3, #0]
 802a03e:	4619      	mov	r1, r3
 802a040:	4610      	mov	r0, r2
 802a042:	f000 f93f 	bl	802a2c4 <TimeStamp_config>
		INTTrigger(Ports, Pins);											//Sync ODR with PWM
 802a046:	4b0d      	ldr	r3, [pc, #52]	; (802a07c <setupAll+0x78>)
 802a048:	681a      	ldr	r2, [r3, #0]
 802a04a:	4b0d      	ldr	r3, [pc, #52]	; (802a080 <setupAll+0x7c>)
 802a04c:	881b      	ldrh	r3, [r3, #0]
 802a04e:	4619      	mov	r1, r3
 802a050:	4610      	mov	r0, r2
 802a052:	f000 f985 	bl	802a360 <INTTrigger>
		FIFO_config(Ports, Pins);
 802a056:	4b09      	ldr	r3, [pc, #36]	; (802a07c <setupAll+0x78>)
 802a058:	681a      	ldr	r2, [r3, #0]
 802a05a:	4b09      	ldr	r3, [pc, #36]	; (802a080 <setupAll+0x7c>)
 802a05c:	881b      	ldrh	r3, [r3, #0]
 802a05e:	4619      	mov	r1, r3
 802a060:	4610      	mov	r0, r2
 802a062:	f000 f9c3 	bl	802a3ec <FIFO_config>
	for(int i = 5; i>=0; i--)
 802a066:	687b      	ldr	r3, [r7, #4]
 802a068:	3b01      	subs	r3, #1
 802a06a:	607b      	str	r3, [r7, #4]
 802a06c:	687b      	ldr	r3, [r7, #4]
 802a06e:	2b00      	cmp	r3, #0
 802a070:	dace      	bge.n	802a010 <setupAll+0xc>
	}
}
 802a072:	bf00      	nop
 802a074:	3708      	adds	r7, #8
 802a076:	46bd      	mov	sp, r7
 802a078:	bd80      	pop	{r7, pc}
 802a07a:	bf00      	nop
 802a07c:	20001a38 	.word	0x20001a38
 802a080:	20001a3c 	.word	0x20001a3c

0802a084 <PEDO_config>:
	return (int16_t)((uint8_t)(temp[1])<<8 | (uint8_t)(temp[0]));
}


void PEDO_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 802a084:	b580      	push	{r7, lr}
 802a086:	b090      	sub	sp, #64	; 0x40
 802a088:	af00      	add	r7, sp, #0
 802a08a:	6078      	str	r0, [r7, #4]
 802a08c:	460b      	mov	r3, r1
 802a08e:	807b      	strh	r3, [r7, #2]
	uint16_t add[2] = {(0x80|CTRL10_C<<8),(0x80|INT1_CTRL<<8)};
 802a090:	4b31      	ldr	r3, [pc, #196]	; (802a158 <PEDO_config+0xd4>)
 802a092:	681b      	ldr	r3, [r3, #0]
 802a094:	63bb      	str	r3, [r7, #56]	; 0x38
	uint8_t r1[1] = {0};
 802a096:	2300      	movs	r3, #0
 802a098:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
	spi_RX(&add[0],r1,Port,Pin);
 802a09c:	887b      	ldrh	r3, [r7, #2]
 802a09e:	f107 0134 	add.w	r1, r7, #52	; 0x34
 802a0a2:	f107 0038 	add.w	r0, r7, #56	; 0x38
 802a0a6:	687a      	ldr	r2, [r7, #4]
 802a0a8:	f001 f938 	bl	802b31c <spi_RX>
	uint8_t r2[1] = {0};
 802a0ac:	2300      	movs	r3, #0
 802a0ae:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
	spi_RX(&add[1],r2,Port,Pin);
 802a0b2:	887a      	ldrh	r2, [r7, #2]
 802a0b4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 802a0b8:	f107 0338 	add.w	r3, r7, #56	; 0x38
 802a0bc:	1c98      	adds	r0, r3, #2
 802a0be:	4613      	mov	r3, r2
 802a0c0:	687a      	ldr	r2, [r7, #4]
 802a0c2:	f001 f92b 	bl	802b31c <spi_RX>
	uint16_t pedo_config[6]  	= {
 802a0c6:	4a25      	ldr	r2, [pc, #148]	; (802a15c <PEDO_config+0xd8>)
 802a0c8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 802a0cc:	ca07      	ldmia	r2, {r0, r1, r2}
 802a0ce:	e883 0007 	stmia.w	r3, {r0, r1, r2}
									(FUNC_CFG_ACCESS<<8|0x00),
									(CTRL1_XL<<8|accelcfg16k),///changed
									(CTRL10_C<<8|0b00110100),
									(INT1_CTRL<<8|0b10111011)
									};
	uint16_t pedo_configcheck[6] = {
 802a0d2:	4a23      	ldr	r2, [pc, #140]	; (802a160 <PEDO_config+0xdc>)
 802a0d4:	f107 0318 	add.w	r3, r7, #24
 802a0d8:	ca07      	ldmia	r2, {r0, r1, r2}
 802a0da:	e883 0007 	stmia.w	r3, {r0, r1, r2}
									((0x80|CTRL1_XL)<<8),
								    ((0x80|CTRL10_C)<<8),
									((0x80|INT1_CTRL)<<8)
									};

	uint8_t shouldbe[6] = {0};											//The actual configuration we write to register
 802a0de:	f107 0310 	add.w	r3, r7, #16
 802a0e2:	2200      	movs	r2, #0
 802a0e4:	601a      	str	r2, [r3, #0]
 802a0e6:	809a      	strh	r2, [r3, #4]
	uint8_t actual_16[6] = {0};											//The actual configuration we read from register
 802a0e8:	f107 0308 	add.w	r3, r7, #8
 802a0ec:	2200      	movs	r2, #0
 802a0ee:	601a      	str	r2, [r3, #0]
 802a0f0:	809a      	strh	r2, [r3, #4]

	for(int i = 0; i < 6; i ++)
 802a0f2:	2300      	movs	r3, #0
 802a0f4:	63fb      	str	r3, [r7, #60]	; 0x3c
 802a0f6:	e027      	b.n	802a148 <PEDO_config+0xc4>
	{
		spi_write(&pedo_config[i],Port,Pin);
 802a0f8:	f107 0224 	add.w	r2, r7, #36	; 0x24
 802a0fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a0fe:	005b      	lsls	r3, r3, #1
 802a100:	4413      	add	r3, r2
 802a102:	887a      	ldrh	r2, [r7, #2]
 802a104:	6879      	ldr	r1, [r7, #4]
 802a106:	4618      	mov	r0, r3
 802a108:	f001 f930 	bl	802b36c <spi_write>
		spi_RX(&pedo_configcheck[i], &actual_16[i],Port,Pin);
 802a10c:	f107 0218 	add.w	r2, r7, #24
 802a110:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a112:	005b      	lsls	r3, r3, #1
 802a114:	18d0      	adds	r0, r2, r3
 802a116:	f107 0208 	add.w	r2, r7, #8
 802a11a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a11c:	18d1      	adds	r1, r2, r3
 802a11e:	887b      	ldrh	r3, [r7, #2]
 802a120:	687a      	ldr	r2, [r7, #4]
 802a122:	f001 f8fb 	bl	802b31c <spi_RX>
		shouldbe[i] = pedo_config[i];
 802a126:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a128:	005b      	lsls	r3, r3, #1
 802a12a:	f107 0240 	add.w	r2, r7, #64	; 0x40
 802a12e:	4413      	add	r3, r2
 802a130:	f833 3c1c 	ldrh.w	r3, [r3, #-28]
 802a134:	b2d9      	uxtb	r1, r3
 802a136:	f107 0210 	add.w	r2, r7, #16
 802a13a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a13c:	4413      	add	r3, r2
 802a13e:	460a      	mov	r2, r1
 802a140:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i < 6; i ++)
 802a142:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a144:	3301      	adds	r3, #1
 802a146:	63fb      	str	r3, [r7, #60]	; 0x3c
 802a148:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a14a:	2b05      	cmp	r3, #5
 802a14c:	ddd4      	ble.n	802a0f8 <PEDO_config+0x74>
	}
}
 802a14e:	bf00      	nop
 802a150:	3740      	adds	r7, #64	; 0x40
 802a152:	46bd      	mov	sp, r7
 802a154:	bd80      	pop	{r7, pc}
 802a156:	bf00      	nop
 802a158:	08030e48 	.word	0x08030e48
 802a15c:	08030e4c 	.word	0x08030e4c
 802a160:	08030e58 	.word	0x08030e58

0802a164 <IMU_config>:



void IMU_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 802a164:	b5b0      	push	{r4, r5, r7, lr}
 802a166:	b094      	sub	sp, #80	; 0x50
 802a168:	af00      	add	r7, sp, #0
 802a16a:	6078      	str	r0, [r7, #4]
 802a16c:	460b      	mov	r3, r1
 802a16e:	807b      	strh	r3, [r7, #2]
	uint16_t IMU_configbuffer[9] 	  = {(INT1_CTRL<<8|intctrl),
 802a170:	4b26      	ldr	r3, [pc, #152]	; (802a20c <IMU_config+0xa8>)
 802a172:	f107 0438 	add.w	r4, r7, #56	; 0x38
 802a176:	461d      	mov	r5, r3
 802a178:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802a17a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802a17c:	682b      	ldr	r3, [r5, #0]
 802a17e:	8023      	strh	r3, [r4, #0]
											(CTRL6_C<<8|ctrl6),
											(CTRL3_C<<8|ctrl3),
											(CTRL5_C<<8|ctrl5),
											(CTRL8_XL<<8|ctrl8cfg),
											(MASTER_CONFIG<<8|MASTER_SENSOR)};
	uint16_t IMU_configbuffercheck[9] = {((0x80|INT1_CTRL)<<8),
 802a180:	4b23      	ldr	r3, [pc, #140]	; (802a210 <IMU_config+0xac>)
 802a182:	f107 0424 	add.w	r4, r7, #36	; 0x24
 802a186:	461d      	mov	r5, r3
 802a188:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802a18a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802a18c:	682b      	ldr	r3, [r5, #0]
 802a18e:	8023      	strh	r3, [r4, #0]
											((0x80|CTRL3_C)<<8),
											((0x80|CTRL5_C)<<8),
											((0x80|CTRL8_XL)<<8),
											((0x80|MASTER_CONFIG)<<8)};

	uint8_t shouldbe[9] = {0};											//The actual configuration we write to register
 802a190:	f107 0318 	add.w	r3, r7, #24
 802a194:	2200      	movs	r2, #0
 802a196:	601a      	str	r2, [r3, #0]
 802a198:	605a      	str	r2, [r3, #4]
 802a19a:	721a      	strb	r2, [r3, #8]
	uint8_t actual_16[9] = {0};										    //The actual configuration we read from register
 802a19c:	f107 030c 	add.w	r3, r7, #12
 802a1a0:	2200      	movs	r2, #0
 802a1a2:	601a      	str	r2, [r3, #0]
 802a1a4:	605a      	str	r2, [r3, #4]
 802a1a6:	721a      	strb	r2, [r3, #8]
	for (int i =0; i<9;i++)
 802a1a8:	2300      	movs	r3, #0
 802a1aa:	64fb      	str	r3, [r7, #76]	; 0x4c
 802a1ac:	e027      	b.n	802a1fe <IMU_config+0x9a>
	{
		spi_write(&IMU_configbuffer[i],Port,Pin);
 802a1ae:	f107 0238 	add.w	r2, r7, #56	; 0x38
 802a1b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a1b4:	005b      	lsls	r3, r3, #1
 802a1b6:	4413      	add	r3, r2
 802a1b8:	887a      	ldrh	r2, [r7, #2]
 802a1ba:	6879      	ldr	r1, [r7, #4]
 802a1bc:	4618      	mov	r0, r3
 802a1be:	f001 f8d5 	bl	802b36c <spi_write>
		spi_RX(&IMU_configbuffercheck[i], &actual_16[i],Port,Pin);
 802a1c2:	f107 0224 	add.w	r2, r7, #36	; 0x24
 802a1c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a1c8:	005b      	lsls	r3, r3, #1
 802a1ca:	18d0      	adds	r0, r2, r3
 802a1cc:	f107 020c 	add.w	r2, r7, #12
 802a1d0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a1d2:	18d1      	adds	r1, r2, r3
 802a1d4:	887b      	ldrh	r3, [r7, #2]
 802a1d6:	687a      	ldr	r2, [r7, #4]
 802a1d8:	f001 f8a0 	bl	802b31c <spi_RX>
		shouldbe[i] = IMU_configbuffer[i];
 802a1dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a1de:	005b      	lsls	r3, r3, #1
 802a1e0:	f107 0250 	add.w	r2, r7, #80	; 0x50
 802a1e4:	4413      	add	r3, r2
 802a1e6:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 802a1ea:	b2d9      	uxtb	r1, r3
 802a1ec:	f107 0218 	add.w	r2, r7, #24
 802a1f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a1f2:	4413      	add	r3, r2
 802a1f4:	460a      	mov	r2, r1
 802a1f6:	701a      	strb	r2, [r3, #0]
	for (int i =0; i<9;i++)
 802a1f8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a1fa:	3301      	adds	r3, #1
 802a1fc:	64fb      	str	r3, [r7, #76]	; 0x4c
 802a1fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a200:	2b08      	cmp	r3, #8
 802a202:	ddd4      	ble.n	802a1ae <IMU_config+0x4a>
	}
}
 802a204:	bf00      	nop
 802a206:	3750      	adds	r7, #80	; 0x50
 802a208:	46bd      	mov	sp, r7
 802a20a:	bdb0      	pop	{r4, r5, r7, pc}
 802a20c:	08030e64 	.word	0x08030e64
 802a210:	08030e78 	.word	0x08030e78

0802a214 <IMU_reset>:


void IMU_reset(GPIO_TypeDef* Port, uint16_t Pin)
{
 802a214:	b580      	push	{r7, lr}
 802a216:	b08a      	sub	sp, #40	; 0x28
 802a218:	af00      	add	r7, sp, #0
 802a21a:	6078      	str	r0, [r7, #4]
 802a21c:	460b      	mov	r3, r1
 802a21e:	807b      	strh	r3, [r7, #2]
	uint16_t reset_buffer[3] = {(CTRL3_C<<8|0b10000001),
 802a220:	4a26      	ldr	r2, [pc, #152]	; (802a2bc <IMU_reset+0xa8>)
 802a222:	f107 031c 	add.w	r3, r7, #28
 802a226:	e892 0003 	ldmia.w	r2, {r0, r1}
 802a22a:	6018      	str	r0, [r3, #0]
 802a22c:	3304      	adds	r3, #4
 802a22e:	8019      	strh	r1, [r3, #0]
								(CTRL10_C<<8|ctrl10_pedo_reset),
								(TIMESTAMP2_REG<<8|timerreset),

								};
	uint16_t reset_buffercheck[3] = {
 802a230:	4a23      	ldr	r2, [pc, #140]	; (802a2c0 <IMU_reset+0xac>)
 802a232:	f107 0314 	add.w	r3, r7, #20
 802a236:	e892 0003 	ldmia.w	r2, {r0, r1}
 802a23a:	6018      	str	r0, [r3, #0]
 802a23c:	3304      	adds	r3, #4
 802a23e:	8019      	strh	r1, [r3, #0]
									((0x80|CTRL3_C)<<8),
									((0x80|CTRL10_C)<<8),
									((0x80|TIMESTAMP2_REG)<<8),

									};
	uint8_t shouldbe[3] = {0,0,0};									//The actual configuration we write to register
 802a240:	2300      	movs	r3, #0
 802a242:	743b      	strb	r3, [r7, #16]
 802a244:	2300      	movs	r3, #0
 802a246:	747b      	strb	r3, [r7, #17]
 802a248:	2300      	movs	r3, #0
 802a24a:	74bb      	strb	r3, [r7, #18]
	uint8_t actual_16[3] = {0,0,0};									//The actual configuration we read from register
 802a24c:	2300      	movs	r3, #0
 802a24e:	733b      	strb	r3, [r7, #12]
 802a250:	2300      	movs	r3, #0
 802a252:	737b      	strb	r3, [r7, #13]
 802a254:	2300      	movs	r3, #0
 802a256:	73bb      	strb	r3, [r7, #14]

	for (int i =0; i<3;i++)
 802a258:	2300      	movs	r3, #0
 802a25a:	627b      	str	r3, [r7, #36]	; 0x24
 802a25c:	e027      	b.n	802a2ae <IMU_reset+0x9a>
	{
		spi_write(&reset_buffer[i],Port,Pin);
 802a25e:	f107 021c 	add.w	r2, r7, #28
 802a262:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a264:	005b      	lsls	r3, r3, #1
 802a266:	4413      	add	r3, r2
 802a268:	887a      	ldrh	r2, [r7, #2]
 802a26a:	6879      	ldr	r1, [r7, #4]
 802a26c:	4618      	mov	r0, r3
 802a26e:	f001 f87d 	bl	802b36c <spi_write>
		spi_RX(&reset_buffercheck[i], &actual_16[i],Port,Pin);
 802a272:	f107 0214 	add.w	r2, r7, #20
 802a276:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a278:	005b      	lsls	r3, r3, #1
 802a27a:	18d0      	adds	r0, r2, r3
 802a27c:	f107 020c 	add.w	r2, r7, #12
 802a280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a282:	18d1      	adds	r1, r2, r3
 802a284:	887b      	ldrh	r3, [r7, #2]
 802a286:	687a      	ldr	r2, [r7, #4]
 802a288:	f001 f848 	bl	802b31c <spi_RX>
		shouldbe[i] = reset_buffer[i];
 802a28c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a28e:	005b      	lsls	r3, r3, #1
 802a290:	f107 0228 	add.w	r2, r7, #40	; 0x28
 802a294:	4413      	add	r3, r2
 802a296:	f833 3c0c 	ldrh.w	r3, [r3, #-12]
 802a29a:	b2d9      	uxtb	r1, r3
 802a29c:	f107 0210 	add.w	r2, r7, #16
 802a2a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a2a2:	4413      	add	r3, r2
 802a2a4:	460a      	mov	r2, r1
 802a2a6:	701a      	strb	r2, [r3, #0]
	for (int i =0; i<3;i++)
 802a2a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a2aa:	3301      	adds	r3, #1
 802a2ac:	627b      	str	r3, [r7, #36]	; 0x24
 802a2ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a2b0:	2b02      	cmp	r3, #2
 802a2b2:	ddd4      	ble.n	802a25e <IMU_reset+0x4a>
	}
}
 802a2b4:	bf00      	nop
 802a2b6:	3728      	adds	r7, #40	; 0x28
 802a2b8:	46bd      	mov	sp, r7
 802a2ba:	bd80      	pop	{r7, pc}
 802a2bc:	08030e8c 	.word	0x08030e8c
 802a2c0:	08030e94 	.word	0x08030e94

0802a2c4 <TimeStamp_config>:



void TimeStamp_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 802a2c4:	b580      	push	{r7, lr}
 802a2c6:	b08a      	sub	sp, #40	; 0x28
 802a2c8:	af00      	add	r7, sp, #0
 802a2ca:	6078      	str	r0, [r7, #4]
 802a2cc:	460b      	mov	r3, r1
 802a2ce:	807b      	strh	r3, [r7, #2]
	uint16_t timestamp_buffer[4] 	=  {(CTRL1_XL<<8|0b11111100),
 802a2d0:	4a21      	ldr	r2, [pc, #132]	; (802a358 <TimeStamp_config+0x94>)
 802a2d2:	f107 031c 	add.w	r3, r7, #28
 802a2d6:	e892 0003 	ldmia.w	r2, {r0, r1}
 802a2da:	e883 0003 	stmia.w	r3, {r0, r1}
										(WAKE_UP_DUR<<8|wakeupcfg),
										(CTRL10_C<<8|0b110100),
										(MD1_CFG<<8|mdcfg)};

	uint16_t timestamp_buffercheck[4] = {((0x80|CTRL1_XL)<<8),
 802a2de:	4a1f      	ldr	r2, [pc, #124]	; (802a35c <TimeStamp_config+0x98>)
 802a2e0:	f107 0314 	add.w	r3, r7, #20
 802a2e4:	e892 0003 	ldmia.w	r2, {r0, r1}
 802a2e8:	e883 0003 	stmia.w	r3, {r0, r1}
										((0x80|WAKE_UP_DUR)<<8),
										((0x80|CTRL10_C)<<8),
										((0x80|MD1_CFG)<<8)};
	uint8_t  shouldbe[4] = {0};											//The actual configuration we write to register
 802a2ec:	2300      	movs	r3, #0
 802a2ee:	613b      	str	r3, [r7, #16]
	uint8_t actual_16[4] = {0};											//The actual configuration we read from register
 802a2f0:	2300      	movs	r3, #0
 802a2f2:	60fb      	str	r3, [r7, #12]
	for(int i = 0; i < 4; i ++)
 802a2f4:	2300      	movs	r3, #0
 802a2f6:	627b      	str	r3, [r7, #36]	; 0x24
 802a2f8:	e027      	b.n	802a34a <TimeStamp_config+0x86>
	{
		spi_write(&timestamp_buffer[i],Port,Pin);
 802a2fa:	f107 021c 	add.w	r2, r7, #28
 802a2fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a300:	005b      	lsls	r3, r3, #1
 802a302:	4413      	add	r3, r2
 802a304:	887a      	ldrh	r2, [r7, #2]
 802a306:	6879      	ldr	r1, [r7, #4]
 802a308:	4618      	mov	r0, r3
 802a30a:	f001 f82f 	bl	802b36c <spi_write>
		spi_RX(&timestamp_buffercheck[i], &actual_16[i],Port,Pin);
 802a30e:	f107 0214 	add.w	r2, r7, #20
 802a312:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a314:	005b      	lsls	r3, r3, #1
 802a316:	18d0      	adds	r0, r2, r3
 802a318:	f107 020c 	add.w	r2, r7, #12
 802a31c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a31e:	18d1      	adds	r1, r2, r3
 802a320:	887b      	ldrh	r3, [r7, #2]
 802a322:	687a      	ldr	r2, [r7, #4]
 802a324:	f000 fffa 	bl	802b31c <spi_RX>
		shouldbe[i] = timestamp_buffer[i];
 802a328:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a32a:	005b      	lsls	r3, r3, #1
 802a32c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 802a330:	4413      	add	r3, r2
 802a332:	f833 3c0c 	ldrh.w	r3, [r3, #-12]
 802a336:	b2d9      	uxtb	r1, r3
 802a338:	f107 0210 	add.w	r2, r7, #16
 802a33c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a33e:	4413      	add	r3, r2
 802a340:	460a      	mov	r2, r1
 802a342:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i < 4; i ++)
 802a344:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a346:	3301      	adds	r3, #1
 802a348:	627b      	str	r3, [r7, #36]	; 0x24
 802a34a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a34c:	2b03      	cmp	r3, #3
 802a34e:	ddd4      	ble.n	802a2fa <TimeStamp_config+0x36>
	}
}
 802a350:	bf00      	nop
 802a352:	3728      	adds	r7, #40	; 0x28
 802a354:	46bd      	mov	sp, r7
 802a356:	bd80      	pop	{r7, pc}
 802a358:	08030e9c 	.word	0x08030e9c
 802a35c:	08030ea4 	.word	0x08030ea4

0802a360 <INTTrigger>:
//Sync ODR with PWM
void INTTrigger(GPIO_TypeDef* Port, uint16_t Pin)
{
 802a360:	b580      	push	{r7, lr}
 802a362:	b088      	sub	sp, #32
 802a364:	af00      	add	r7, sp, #0
 802a366:	6078      	str	r0, [r7, #4]
 802a368:	460b      	mov	r3, r1
 802a36a:	807b      	strh	r3, [r7, #2]
	uint16_t INTTrigger_buffer[2] = {
 802a36c:	4b1d      	ldr	r3, [pc, #116]	; (802a3e4 <INTTrigger+0x84>)
 802a36e:	681b      	ldr	r3, [r3, #0]
 802a370:	61bb      	str	r3, [r7, #24]
			(CTRL6_C<<8|ctrl6edge),
			(CTRL4_C<<8|ctrl4)
				};
	uint16_t INTTrigger_checkbuffer[2] = {
 802a372:	4b1d      	ldr	r3, [pc, #116]	; (802a3e8 <INTTrigger+0x88>)
 802a374:	681b      	ldr	r3, [r3, #0]
 802a376:	617b      	str	r3, [r7, #20]
				((READ|CTRL6_C)<<8),
				((READ|CTRL4_C)<<8)
					};
	uint8_t  shouldbe[2] = {0};											//The actual configuration we write to register
 802a378:	2300      	movs	r3, #0
 802a37a:	823b      	strh	r3, [r7, #16]
	uint8_t actual_16[2] = {0};											//The actual configuration we read from register
 802a37c:	2300      	movs	r3, #0
 802a37e:	81bb      	strh	r3, [r7, #12]
	for(int i = 0; i <2;i++)
 802a380:	2300      	movs	r3, #0
 802a382:	61fb      	str	r3, [r7, #28]
 802a384:	e027      	b.n	802a3d6 <INTTrigger+0x76>
	{
		spi_write(&INTTrigger_buffer[i],Port,Pin);
 802a386:	f107 0218 	add.w	r2, r7, #24
 802a38a:	69fb      	ldr	r3, [r7, #28]
 802a38c:	005b      	lsls	r3, r3, #1
 802a38e:	4413      	add	r3, r2
 802a390:	887a      	ldrh	r2, [r7, #2]
 802a392:	6879      	ldr	r1, [r7, #4]
 802a394:	4618      	mov	r0, r3
 802a396:	f000 ffe9 	bl	802b36c <spi_write>
		spi_RX(&INTTrigger_checkbuffer[i], &actual_16[i],Port,Pin);
 802a39a:	f107 0214 	add.w	r2, r7, #20
 802a39e:	69fb      	ldr	r3, [r7, #28]
 802a3a0:	005b      	lsls	r3, r3, #1
 802a3a2:	18d0      	adds	r0, r2, r3
 802a3a4:	f107 020c 	add.w	r2, r7, #12
 802a3a8:	69fb      	ldr	r3, [r7, #28]
 802a3aa:	18d1      	adds	r1, r2, r3
 802a3ac:	887b      	ldrh	r3, [r7, #2]
 802a3ae:	687a      	ldr	r2, [r7, #4]
 802a3b0:	f000 ffb4 	bl	802b31c <spi_RX>
		shouldbe[i] = INTTrigger_buffer[i];
 802a3b4:	69fb      	ldr	r3, [r7, #28]
 802a3b6:	005b      	lsls	r3, r3, #1
 802a3b8:	f107 0220 	add.w	r2, r7, #32
 802a3bc:	4413      	add	r3, r2
 802a3be:	f833 3c08 	ldrh.w	r3, [r3, #-8]
 802a3c2:	b2d9      	uxtb	r1, r3
 802a3c4:	f107 0210 	add.w	r2, r7, #16
 802a3c8:	69fb      	ldr	r3, [r7, #28]
 802a3ca:	4413      	add	r3, r2
 802a3cc:	460a      	mov	r2, r1
 802a3ce:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i <2;i++)
 802a3d0:	69fb      	ldr	r3, [r7, #28]
 802a3d2:	3301      	adds	r3, #1
 802a3d4:	61fb      	str	r3, [r7, #28]
 802a3d6:	69fb      	ldr	r3, [r7, #28]
 802a3d8:	2b01      	cmp	r3, #1
 802a3da:	ddd4      	ble.n	802a386 <INTTrigger+0x26>
	}


}
 802a3dc:	bf00      	nop
 802a3de:	3720      	adds	r7, #32
 802a3e0:	46bd      	mov	sp, r7
 802a3e2:	bd80      	pop	{r7, pc}
 802a3e4:	08030eac 	.word	0x08030eac
 802a3e8:	08030eb0 	.word	0x08030eb0

0802a3ec <FIFO_config>:



void FIFO_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 802a3ec:	b5b0      	push	{r4, r5, r7, lr}
 802a3ee:	b094      	sub	sp, #80	; 0x50
 802a3f0:	af00      	add	r7, sp, #0
 802a3f2:	6078      	str	r0, [r7, #4]
 802a3f4:	460b      	mov	r3, r1
 802a3f6:	807b      	strh	r3, [r7, #2]
	uint16_t FIFO_config[9]      =  {(FIFO_CTRL5<<8|fiforeset),
 802a3f8:	4b26      	ldr	r3, [pc, #152]	; (802a494 <FIFO_config+0xa8>)
 802a3fa:	f107 0438 	add.w	r4, r7, #56	; 0x38
 802a3fe:	461d      	mov	r5, r3
 802a400:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802a402:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802a404:	682b      	ldr	r3, [r5, #0]
 802a406:	8023      	strh	r3, [r4, #0]
									(FIFO_CTRL3<<8|deccfgno),//deccfg833
									(FIFO_CTRL4<<8|notimestamp),//fifo4cfg),////notimestamp
									(FIFO_CTRL1<<8|0b11111011),
									(FIFO_CTRL2<<8|fifo2cfgNOts),
									(FIFO_CTRL5<<8|fifo16k)};
	uint16_t FIFO_configcheck[9] = {((0x80|FIFO_CTRL5)<<8),
 802a408:	4b23      	ldr	r3, [pc, #140]	; (802a498 <FIFO_config+0xac>)
 802a40a:	f107 0424 	add.w	r4, r7, #36	; 0x24
 802a40e:	461d      	mov	r5, r3
 802a410:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802a412:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 802a414:	682b      	ldr	r3, [r5, #0]
 802a416:	8023      	strh	r3, [r4, #0]
									((0x80|FIFO_CTRL3)<<8),
									((0x80|FIFO_CTRL4)<<8),
									((0x80|FIFO_CTRL1)<<8),
									((0x80|FIFO_CTRL2)<<8),
									((0x80|FIFO_CTRL5)<<8)};
	uint8_t  shouldbe[9] = {0}; 									//The actual configuration we write to register
 802a418:	f107 0318 	add.w	r3, r7, #24
 802a41c:	2200      	movs	r2, #0
 802a41e:	601a      	str	r2, [r3, #0]
 802a420:	605a      	str	r2, [r3, #4]
 802a422:	721a      	strb	r2, [r3, #8]
	uint8_t actual_16[9] = {0};										//The actual configuration we read from register
 802a424:	f107 030c 	add.w	r3, r7, #12
 802a428:	2200      	movs	r2, #0
 802a42a:	601a      	str	r2, [r3, #0]
 802a42c:	605a      	str	r2, [r3, #4]
 802a42e:	721a      	strb	r2, [r3, #8]
	for (int i =0; i<9;i++)
 802a430:	2300      	movs	r3, #0
 802a432:	64fb      	str	r3, [r7, #76]	; 0x4c
 802a434:	e027      	b.n	802a486 <FIFO_config+0x9a>
	{
		spi_write(&FIFO_config[i],Port,Pin);
 802a436:	f107 0238 	add.w	r2, r7, #56	; 0x38
 802a43a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a43c:	005b      	lsls	r3, r3, #1
 802a43e:	4413      	add	r3, r2
 802a440:	887a      	ldrh	r2, [r7, #2]
 802a442:	6879      	ldr	r1, [r7, #4]
 802a444:	4618      	mov	r0, r3
 802a446:	f000 ff91 	bl	802b36c <spi_write>
		spi_RX(&FIFO_configcheck[i], &actual_16[i],Port,Pin);
 802a44a:	f107 0224 	add.w	r2, r7, #36	; 0x24
 802a44e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a450:	005b      	lsls	r3, r3, #1
 802a452:	18d0      	adds	r0, r2, r3
 802a454:	f107 020c 	add.w	r2, r7, #12
 802a458:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a45a:	18d1      	adds	r1, r2, r3
 802a45c:	887b      	ldrh	r3, [r7, #2]
 802a45e:	687a      	ldr	r2, [r7, #4]
 802a460:	f000 ff5c 	bl	802b31c <spi_RX>

		shouldbe[i] = FIFO_config[i];
 802a464:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a466:	005b      	lsls	r3, r3, #1
 802a468:	f107 0250 	add.w	r2, r7, #80	; 0x50
 802a46c:	4413      	add	r3, r2
 802a46e:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 802a472:	b2d9      	uxtb	r1, r3
 802a474:	f107 0218 	add.w	r2, r7, #24
 802a478:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a47a:	4413      	add	r3, r2
 802a47c:	460a      	mov	r2, r1
 802a47e:	701a      	strb	r2, [r3, #0]
	for (int i =0; i<9;i++)
 802a480:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a482:	3301      	adds	r3, #1
 802a484:	64fb      	str	r3, [r7, #76]	; 0x4c
 802a486:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802a488:	2b08      	cmp	r3, #8
 802a48a:	ddd4      	ble.n	802a436 <FIFO_config+0x4a>
	}
}
 802a48c:	bf00      	nop
 802a48e:	3750      	adds	r7, #80	; 0x50
 802a490:	46bd      	mov	sp, r7
 802a492:	bdb0      	pop	{r4, r5, r7, pc}
 802a494:	08030eb4 	.word	0x08030eb4
 802a498:	08030ec8 	.word	0x08030ec8

0802a49c <main>:
volatile int FSM_CHECKED_FLAG = 0;											// Ensure FSM is checked only once per callback
int DP_FLAG = 0;															// Start Data Processing Flag
#endif

int main(void)
{
 802a49c:	b580      	push	{r7, lr}
 802a49e:	f5ad 4da9 	sub.w	sp, sp, #21632	; 0x5480
 802a4a2:	b08a      	sub	sp, #40	; 0x28
 802a4a4:	af02      	add	r7, sp, #8
	HAL_Init();    															// Reset of all peripherals, Initializes the Flash interface and the Systick.
 802a4a6:	f001 fcad 	bl	802be04 <HAL_Init>
	SystemClock_Config();    												// Configure the system clock
 802a4aa:	f7ff fa11 	bl	80298d0 <SystemClock_Config>
	MX_GPIO_Init();   														// Initialize all configured peripherals
 802a4ae:	f7ff fbb1 	bl	8029c14 <MX_GPIO_Init>
	MX_DMA_Init();															// Initialize DMA UART and SPI,placed before protocol configuration
 802a4b2:	f001 fb69 	bl	802bb88 <MX_DMA_Init>
	MX_USART1_UART_Init();
 802a4b6:	f001 fb13 	bl	802bae0 <MX_USART1_UART_Init>
	MX_USART2_UART_Init();
 802a4ba:	f001 fb3b 	bl	802bb34 <MX_USART2_UART_Init>
	//MX_TIM3_Init();														// PWM timer initialization
	MX_TIM4_Init();															// PWM timer initialization
 802a4be:	f000 fe2b 	bl	802b118 <MX_TIM4_Init>
	HAL_TIM_PWM_Stop(&htim4,TIM_CHANNEL_1);									// Initialize PWM to be stopped
 802a4c2:	2100      	movs	r1, #0
 802a4c4:	4880      	ldr	r0, [pc, #512]	; (802a6c8 <main+0x22c>)
 802a4c6:	f003 fefb 	bl	802e2c0 <HAL_TIM_PWM_Stop>
	MX_SPI1_Init();
 802a4ca:	f000 fe9b 	bl	802b204 <MX_SPI1_Init>
	struct RxBuffer rawData[nIMUs];											// Input buffer for raw data
	struct CalibBuffer calibData[nIMUs];										// Input buffer for calibrated data
	Buffer_Init(rawData);													// Initialize buffer contents to zeros
 802a4ce:	f507 5362 	add.w	r3, r7, #14464	; 0x3880
 802a4d2:	3b08      	subs	r3, #8
 802a4d4:	4618      	mov	r0, r3
 802a4d6:	f7ff fc29 	bl	8029d2c <Buffer_Init>
	Calib_Buffer_Init(calibData);
 802a4da:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 802a4de:	3b68      	subs	r3, #104	; 0x68
 802a4e0:	4618      	mov	r0, r3
 802a4e2:	f7ff fc85 	bl	8029df0 <Calib_Buffer_Init>
	int I[nIMUs] = {0};																// Declaration of buffer indices for each IMU
 802a4e6:	f107 0320 	add.w	r3, r7, #32
 802a4ea:	461a      	mov	r2, r3
 802a4ec:	2300      	movs	r3, #0
 802a4ee:	6013      	str	r3, [r2, #0]
 802a4f0:	6053      	str	r3, [r2, #4]
 802a4f2:	6093      	str	r3, [r2, #8]
 802a4f4:	60d3      	str	r3, [r2, #12]
 802a4f6:	6113      	str	r3, [r2, #16]
 802a4f8:	6153      	str	r3, [r2, #20]
//	Indices_Init(&I);
	int rpNumbers_[nIMUs] = {0};											// rpNumber is to keep track the number of data left in the buffer(Mismatch)
 802a4fa:	f107 0320 	add.w	r3, r7, #32
 802a4fe:	3b18      	subs	r3, #24
 802a500:	461a      	mov	r2, r3
 802a502:	2300      	movs	r3, #0
 802a504:	6013      	str	r3, [r2, #0]
 802a506:	6053      	str	r3, [r2, #4]
 802a508:	6093      	str	r3, [r2, #8]
 802a50a:	60d3      	str	r3, [r2, #12]
 802a50c:	6113      	str	r3, [r2, #16]
 802a50e:	6153      	str	r3, [r2, #20]
	int csCount=0;															// csCount is the ID of each IMU
 802a510:	f107 0320 	add.w	r3, r7, #32
 802a514:	3b1c      	subs	r3, #28
 802a516:	2200      	movs	r2, #0
 802a518:	601a      	str	r2, [r3, #0]
	int fPWMStarted = 0;
 802a51a:	2300      	movs	r3, #0
 802a51c:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 802a520:	f102 021c 	add.w	r2, r2, #28
 802a524:	6013      	str	r3, [r2, #0]
	uint32_t startTime = 0;
 802a526:	2300      	movs	r3, #0
 802a528:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 802a52c:	f102 0218 	add.w	r2, r2, #24
 802a530:	6013      	str	r3, [r2, #0]

	resetAll();																// Reset all IMU
 802a532:	f7ff fd45 	bl	8029fc0 <resetAll>
	setupAll();																// IMU configuration
 802a536:	f7ff fd65 	bl	802a004 <setupAll>
	CalibrationSetup();														// Set up calibration parameters
 802a53a:	f7fe ff95 	bl	8029468 <CalibrationSetup>
	#ifdef SPIDMA
	MX_SPI1_Init_8BIT();													// Initialize SPI with 8 bit per transmission for burst read
 802a53e:	f000 fe99 	bl	802b274 <MX_SPI1_Init_8BIT>
	spi_DMA_RX(FIFO_S2, EDMA,Ports,Pins,2);									// Read FIFO_S2 into EDMA to initialize FSM
 802a542:	4b62      	ldr	r3, [pc, #392]	; (802a6cc <main+0x230>)
 802a544:	681a      	ldr	r2, [r3, #0]
 802a546:	4b62      	ldr	r3, [pc, #392]	; (802a6d0 <main+0x234>)
 802a548:	8819      	ldrh	r1, [r3, #0]
 802a54a:	2302      	movs	r3, #2
 802a54c:	9300      	str	r3, [sp, #0]
 802a54e:	460b      	mov	r3, r1
 802a550:	4960      	ldr	r1, [pc, #384]	; (802a6d4 <main+0x238>)
 802a552:	4861      	ldr	r0, [pc, #388]	; (802a6d8 <main+0x23c>)
 802a554:	f000 fec4 	bl	802b2e0 <spi_DMA_RX>
	#endif
	//HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);								//PWM(GPIO C6) start, use to synchronize IMUs FIFO rate
//	while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15));								//Check if the Board Synchronization pin is pull up(Active high)
	//HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1);								//PWM(GPIO B6) start, use to synchronize IMUs FIFO rate

	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_SET);									// Turn on red LED
 802a558:	2201      	movs	r2, #1
 802a55a:	2104      	movs	r1, #4
 802a55c:	485f      	ldr	r0, [pc, #380]	; (802a6dc <main+0x240>)
 802a55e:	f002 fb21 	bl	802cba4 <HAL_GPIO_WritePin>
		#ifdef LOCAL_PROCESS_TIMEOUT
		if(HAL_GetTick()<=timeout)
		{
		#endif
//			switch(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15))					// Dedicated start/stop pin
			switch(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_10))					// USART1 RX as start/stop pin
 802a562:	f44f 6180 	mov.w	r1, #1024	; 0x400
 802a566:	485e      	ldr	r0, [pc, #376]	; (802a6e0 <main+0x244>)
 802a568:	f002 fb04 	bl	802cb74 <HAL_GPIO_ReadPin>
 802a56c:	4603      	mov	r3, r0
 802a56e:	2b00      	cmp	r3, #0
 802a570:	f000 8093 	beq.w	802a69a <main+0x1fe>
 802a574:	2b01      	cmp	r3, #1
 802a576:	d1f4      	bne.n	802a562 <main+0xc6>
			{
				case 1:
					if (!fPWMStarted)
 802a578:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 802a57c:	f103 031c 	add.w	r3, r3, #28
 802a580:	681b      	ldr	r3, [r3, #0]
 802a582:	2b00      	cmp	r3, #0
 802a584:	d11c      	bne.n	802a5c0 <main+0x124>
					{
						startTime = HAL_GetTick();										// Pause to let DHU UART ports initialize
 802a586:	f001 fca3 	bl	802bed0 <HAL_GetTick>
 802a58a:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 802a58e:	f103 0318 	add.w	r3, r3, #24
 802a592:	6018      	str	r0, [r3, #0]
						while ((HAL_GetTick() - startTime) < 100);
 802a594:	bf00      	nop
 802a596:	f001 fc9b 	bl	802bed0 <HAL_GetTick>
 802a59a:	4602      	mov	r2, r0
 802a59c:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 802a5a0:	f103 0318 	add.w	r3, r3, #24
 802a5a4:	681b      	ldr	r3, [r3, #0]
 802a5a6:	1ad3      	subs	r3, r2, r3
 802a5a8:	2b63      	cmp	r3, #99	; 0x63
 802a5aa:	d9f4      	bls.n	802a596 <main+0xfa>
						HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1);						//PWM(GPIO B6) start, use to synchronize IMUs FIFO rate
 802a5ac:	2100      	movs	r1, #0
 802a5ae:	4846      	ldr	r0, [pc, #280]	; (802a6c8 <main+0x22c>)
 802a5b0:	f003 fe54 	bl	802e25c <HAL_TIM_PWM_Start>
						fPWMStarted = 1;
 802a5b4:	2301      	movs	r3, #1
 802a5b6:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 802a5ba:	f102 021c 	add.w	r2, r2, #28
 802a5be:	6013      	str	r3, [r2, #0]
						//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);			//Turn on green LED
					}

					if (!FSM_CHECKED_FLAG) DMA_FSM_BURST6(&csCount, rawData, I);			//Option:DMA_FSM_BURST6(&csCount,rawData,&I); DMA_FSM_BURST2(&csCount,rawData,&I)
 802a5c0:	4b48      	ldr	r3, [pc, #288]	; (802a6e4 <main+0x248>)
 802a5c2:	681b      	ldr	r3, [r3, #0]
 802a5c4:	2b00      	cmp	r3, #0
 802a5c6:	d10a      	bne.n	802a5de <main+0x142>
 802a5c8:	f107 0220 	add.w	r2, r7, #32
 802a5cc:	f507 5162 	add.w	r1, r7, #14464	; 0x3880
 802a5d0:	3908      	subs	r1, #8
 802a5d2:	f107 0320 	add.w	r3, r7, #32
 802a5d6:	3b1c      	subs	r3, #28
 802a5d8:	4618      	mov	r0, r3
 802a5da:	f7ff fa0b 	bl	80299f4 <DMA_FSM_BURST6>
																					//Notice: Make sure to change PWM rate at a right speed when switch to BURST2
																					//Otherwise: program is likely to enter hard fault interrupt because of buffer overflow
					if(DP_FLAG)														//Data retrieval completed (one set)
 802a5de:	4b42      	ldr	r3, [pc, #264]	; (802a6e8 <main+0x24c>)
 802a5e0:	681b      	ldr	r3, [r3, #0]
 802a5e2:	2b00      	cmp	r3, #0
 802a5e4:	d06b      	beq.n	802a6be <main+0x222>
					{																//Start to process data
						DP_FLAG = 0;
 802a5e6:	4b40      	ldr	r3, [pc, #256]	; (802a6e8 <main+0x24c>)
 802a5e8:	2200      	movs	r2, #0
 802a5ea:	601a      	str	r2, [r3, #0]
						Calibrate(rawData, calibData, I, csCount);					// Calibrate raw data and store in calibData
 802a5ec:	f107 0320 	add.w	r3, r7, #32
 802a5f0:	3b1c      	subs	r3, #28
 802a5f2:	681b      	ldr	r3, [r3, #0]
 802a5f4:	f107 0220 	add.w	r2, r7, #32
 802a5f8:	f107 01a0 	add.w	r1, r7, #160	; 0xa0
 802a5fc:	3968      	subs	r1, #104	; 0x68
 802a5fe:	f507 5062 	add.w	r0, r7, #14464	; 0x3880
 802a602:	3808      	subs	r0, #8
 802a604:	f7fe fff4 	bl	80295f0 <Calibrate>
						OMEmean(calibData, I, rpNumbers_, csCount);					// Take sum of gyro measurements from each IMU and average when all IMUs have produced data
 802a608:	f107 0320 	add.w	r3, r7, #32
 802a60c:	3b1c      	subs	r3, #28
 802a60e:	681b      	ldr	r3, [r3, #0]
 802a610:	f107 0220 	add.w	r2, r7, #32
 802a614:	3a18      	subs	r2, #24
 802a616:	f107 0120 	add.w	r1, r7, #32
 802a61a:	f107 00a0 	add.w	r0, r7, #160	; 0xa0
 802a61e:	3868      	subs	r0, #104	; 0x68
 802a620:	f000 f86c 	bl	802a6fc <OMEmean>
						IntegrateOmBar(calibData);									// Integrate gyro measurements according to high speed algorithm from Savage (1998a)
 802a624:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 802a628:	3b68      	subs	r3, #104	; 0x68
 802a62a:	4618      	mov	r0, r3
 802a62c:	f000 fa1e 	bl	802aa6c <IntegrateOmBar>
						if(sets == 4)												// Once gyro measurements have been integrated over 8 time steps
 802a630:	4b2e      	ldr	r3, [pc, #184]	; (802a6ec <main+0x250>)
 802a632:	681b      	ldr	r3, [r3, #0]
 802a634:	2b04      	cmp	r3, #4
 802a636:	d107      	bne.n	802a648 <main+0x1ac>
						{
							TransmitData(calibData);											// Send data over UART
 802a638:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 802a63c:	3b68      	subs	r3, #104	; 0x68
 802a63e:	4618      	mov	r0, r3
 802a640:	f001 fada 	bl	802bbf8 <TransmitData>
							ResetIntegration();										// Reset integration
 802a644:	f000 fcfa 	bl	802b03c <ResetIntegration>
						}
						I[csCount] = I[csCount] < RX_BUFFER_SIZE - 1? I[csCount]+1 : 0;	// Increment buffer index
 802a648:	f107 0320 	add.w	r3, r7, #32
 802a64c:	3b1c      	subs	r3, #28
 802a64e:	681a      	ldr	r2, [r3, #0]
 802a650:	f107 0320 	add.w	r3, r7, #32
 802a654:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a658:	2b62      	cmp	r3, #98	; 0x62
 802a65a:	dc09      	bgt.n	802a670 <main+0x1d4>
 802a65c:	f107 0320 	add.w	r3, r7, #32
 802a660:	3b1c      	subs	r3, #28
 802a662:	681a      	ldr	r2, [r3, #0]
 802a664:	f107 0320 	add.w	r3, r7, #32
 802a668:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802a66c:	1c5a      	adds	r2, r3, #1
 802a66e:	e000      	b.n	802a672 <main+0x1d6>
 802a670:	2200      	movs	r2, #0
 802a672:	f107 0320 	add.w	r3, r7, #32
 802a676:	3b1c      	subs	r3, #28
 802a678:	6819      	ldr	r1, [r3, #0]
 802a67a:	f107 0320 	add.w	r3, r7, #32
 802a67e:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
						c[csCount]++;												//Count total number of frames read for each IMU
 802a682:	f107 0320 	add.w	r3, r7, #32
 802a686:	3b1c      	subs	r3, #28
 802a688:	681b      	ldr	r3, [r3, #0]
 802a68a:	4a19      	ldr	r2, [pc, #100]	; (802a6f0 <main+0x254>)
 802a68c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802a690:	3201      	adds	r2, #1
 802a692:	4917      	ldr	r1, [pc, #92]	; (802a6f0 <main+0x254>)
 802a694:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
//						else
//						{
//							HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET );
//						}
//					}
					break;
 802a698:	e011      	b.n	802a6be <main+0x222>
				case 0:
					if (fPWMStarted)
 802a69a:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 802a69e:	f103 031c 	add.w	r3, r3, #28
 802a6a2:	681b      	ldr	r3, [r3, #0]
 802a6a4:	2b00      	cmp	r3, #0
 802a6a6:	d00c      	beq.n	802a6c2 <main+0x226>
					{
						HAL_TIM_PWM_Stop(&htim4,TIM_CHANNEL_1);
 802a6a8:	2100      	movs	r1, #0
 802a6aa:	4807      	ldr	r0, [pc, #28]	; (802a6c8 <main+0x22c>)
 802a6ac:	f003 fe08 	bl	802e2c0 <HAL_TIM_PWM_Stop>
						fPWMStarted = 0;
 802a6b0:	2300      	movs	r3, #0
 802a6b2:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 802a6b6:	f102 021c 	add.w	r2, r2, #28
 802a6ba:	6013      	str	r3, [r2, #0]
						//HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET );		// Turn off green LED
					}
					break;
 802a6bc:	e001      	b.n	802a6c2 <main+0x226>
					break;
 802a6be:	bf00      	nop
 802a6c0:	e74f      	b.n	802a562 <main+0xc6>
					break;
 802a6c2:	bf00      	nop
			switch(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_10))					// USART1 RX as start/stop pin
 802a6c4:	e74d      	b.n	802a562 <main+0xc6>
 802a6c6:	bf00      	nop
 802a6c8:	20001a40 	.word	0x20001a40
 802a6cc:	20001a38 	.word	0x20001a38
 802a6d0:	20001a3c 	.word	0x20001a3c
 802a6d4:	20000694 	.word	0x20000694
 802a6d8:	200005b0 	.word	0x200005b0
 802a6dc:	40020400 	.word	0x40020400
 802a6e0:	40020000 	.word	0x40020000
 802a6e4:	20000698 	.word	0x20000698
 802a6e8:	2000069c 	.word	0x2000069c
 802a6ec:	20001a08 	.word	0x20001a08
 802a6f0:	2000067c 	.word	0x2000067c

0802a6f4 <Error_Handler>:




void Error_Handler(void)
{
 802a6f4:	b480      	push	{r7}
 802a6f6:	af00      	add	r7, sp, #0
	while(1);
 802a6f8:	e7fe      	b.n	802a6f8 <Error_Handler+0x4>
	...

0802a6fc <OMEmean>:
 * 			 shows the number of data hasn't yet being processed
 * 			 Usually shows 0,1,2,3
 * 			 When rpNumebers shows hundreds, FIFO speed(PWM) is too fast
 */
void OMEmean(struct CalibBuffer *calibData, int I[nIMUs], int *rpNumbers, int csCount)
{
 802a6fc:	b490      	push	{r4, r7}
 802a6fe:	b08a      	sub	sp, #40	; 0x28
 802a700:	af00      	add	r7, sp, #0
 802a702:	60f8      	str	r0, [r7, #12]
 802a704:	60b9      	str	r1, [r7, #8]
 802a706:	607a      	str	r2, [r7, #4]
 802a708:	603b      	str	r3, [r7, #0]
	int nFlag = 0;
 802a70a:	2300      	movs	r3, #0
 802a70c:	627b      	str	r3, [r7, #36]	; 0x24

	Sum_OMX[rpNumbers[csCount]] += calibData[csCount].RxBuffer_OMX[I[csCount]];
 802a70e:	683b      	ldr	r3, [r7, #0]
 802a710:	009b      	lsls	r3, r3, #2
 802a712:	687a      	ldr	r2, [r7, #4]
 802a714:	4413      	add	r3, r2
 802a716:	681b      	ldr	r3, [r3, #0]
 802a718:	4aad      	ldr	r2, [pc, #692]	; (802a9d0 <OMEmean+0x2d4>)
 802a71a:	009b      	lsls	r3, r3, #2
 802a71c:	4413      	add	r3, r2
 802a71e:	ed93 7a00 	vldr	s14, [r3]
 802a722:	683b      	ldr	r3, [r7, #0]
 802a724:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802a728:	fb02 f303 	mul.w	r3, r2, r3
 802a72c:	68fa      	ldr	r2, [r7, #12]
 802a72e:	441a      	add	r2, r3
 802a730:	683b      	ldr	r3, [r7, #0]
 802a732:	009b      	lsls	r3, r3, #2
 802a734:	68b9      	ldr	r1, [r7, #8]
 802a736:	440b      	add	r3, r1
 802a738:	681b      	ldr	r3, [r3, #0]
 802a73a:	009b      	lsls	r3, r3, #2
 802a73c:	4413      	add	r3, r2
 802a73e:	edd3 7a00 	vldr	s15, [r3]
 802a742:	683b      	ldr	r3, [r7, #0]
 802a744:	009b      	lsls	r3, r3, #2
 802a746:	687a      	ldr	r2, [r7, #4]
 802a748:	4413      	add	r3, r2
 802a74a:	681b      	ldr	r3, [r3, #0]
 802a74c:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a750:	4a9f      	ldr	r2, [pc, #636]	; (802a9d0 <OMEmean+0x2d4>)
 802a752:	009b      	lsls	r3, r3, #2
 802a754:	4413      	add	r3, r2
 802a756:	edc3 7a00 	vstr	s15, [r3]
	Sum_OMY[rpNumbers[csCount]] += calibData[csCount].RxBuffer_OMY[I[csCount]];
 802a75a:	683b      	ldr	r3, [r7, #0]
 802a75c:	009b      	lsls	r3, r3, #2
 802a75e:	687a      	ldr	r2, [r7, #4]
 802a760:	4413      	add	r3, r2
 802a762:	681b      	ldr	r3, [r3, #0]
 802a764:	4a9b      	ldr	r2, [pc, #620]	; (802a9d4 <OMEmean+0x2d8>)
 802a766:	009b      	lsls	r3, r3, #2
 802a768:	4413      	add	r3, r2
 802a76a:	ed93 7a00 	vldr	s14, [r3]
 802a76e:	683b      	ldr	r3, [r7, #0]
 802a770:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802a774:	fb02 f303 	mul.w	r3, r2, r3
 802a778:	68fa      	ldr	r2, [r7, #12]
 802a77a:	441a      	add	r2, r3
 802a77c:	683b      	ldr	r3, [r7, #0]
 802a77e:	009b      	lsls	r3, r3, #2
 802a780:	68b9      	ldr	r1, [r7, #8]
 802a782:	440b      	add	r3, r1
 802a784:	681b      	ldr	r3, [r3, #0]
 802a786:	3364      	adds	r3, #100	; 0x64
 802a788:	009b      	lsls	r3, r3, #2
 802a78a:	4413      	add	r3, r2
 802a78c:	edd3 7a00 	vldr	s15, [r3]
 802a790:	683b      	ldr	r3, [r7, #0]
 802a792:	009b      	lsls	r3, r3, #2
 802a794:	687a      	ldr	r2, [r7, #4]
 802a796:	4413      	add	r3, r2
 802a798:	681b      	ldr	r3, [r3, #0]
 802a79a:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a79e:	4a8d      	ldr	r2, [pc, #564]	; (802a9d4 <OMEmean+0x2d8>)
 802a7a0:	009b      	lsls	r3, r3, #2
 802a7a2:	4413      	add	r3, r2
 802a7a4:	edc3 7a00 	vstr	s15, [r3]
	Sum_OMZ[rpNumbers[csCount]] += calibData[csCount].RxBuffer_OMZ[I[csCount]];
 802a7a8:	683b      	ldr	r3, [r7, #0]
 802a7aa:	009b      	lsls	r3, r3, #2
 802a7ac:	687a      	ldr	r2, [r7, #4]
 802a7ae:	4413      	add	r3, r2
 802a7b0:	681b      	ldr	r3, [r3, #0]
 802a7b2:	4a89      	ldr	r2, [pc, #548]	; (802a9d8 <OMEmean+0x2dc>)
 802a7b4:	009b      	lsls	r3, r3, #2
 802a7b6:	4413      	add	r3, r2
 802a7b8:	ed93 7a00 	vldr	s14, [r3]
 802a7bc:	683b      	ldr	r3, [r7, #0]
 802a7be:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802a7c2:	fb02 f303 	mul.w	r3, r2, r3
 802a7c6:	68fa      	ldr	r2, [r7, #12]
 802a7c8:	441a      	add	r2, r3
 802a7ca:	683b      	ldr	r3, [r7, #0]
 802a7cc:	009b      	lsls	r3, r3, #2
 802a7ce:	68b9      	ldr	r1, [r7, #8]
 802a7d0:	440b      	add	r3, r1
 802a7d2:	681b      	ldr	r3, [r3, #0]
 802a7d4:	33c8      	adds	r3, #200	; 0xc8
 802a7d6:	009b      	lsls	r3, r3, #2
 802a7d8:	4413      	add	r3, r2
 802a7da:	edd3 7a00 	vldr	s15, [r3]
 802a7de:	683b      	ldr	r3, [r7, #0]
 802a7e0:	009b      	lsls	r3, r3, #2
 802a7e2:	687a      	ldr	r2, [r7, #4]
 802a7e4:	4413      	add	r3, r2
 802a7e6:	681b      	ldr	r3, [r3, #0]
 802a7e8:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a7ec:	4a7a      	ldr	r2, [pc, #488]	; (802a9d8 <OMEmean+0x2dc>)
 802a7ee:	009b      	lsls	r3, r3, #2
 802a7f0:	4413      	add	r3, r2
 802a7f2:	edc3 7a00 	vstr	s15, [r3]
	sumIndex[csCount][rpNumbers[csCount]] = I[csCount];
 802a7f6:	683b      	ldr	r3, [r7, #0]
 802a7f8:	009b      	lsls	r3, r3, #2
 802a7fa:	68ba      	ldr	r2, [r7, #8]
 802a7fc:	441a      	add	r2, r3
 802a7fe:	683b      	ldr	r3, [r7, #0]
 802a800:	009b      	lsls	r3, r3, #2
 802a802:	6879      	ldr	r1, [r7, #4]
 802a804:	440b      	add	r3, r1
 802a806:	681b      	ldr	r3, [r3, #0]
 802a808:	6812      	ldr	r2, [r2, #0]
 802a80a:	4874      	ldr	r0, [pc, #464]	; (802a9dc <OMEmean+0x2e0>)
 802a80c:	6839      	ldr	r1, [r7, #0]
 802a80e:	2464      	movs	r4, #100	; 0x64
 802a810:	fb04 f101 	mul.w	r1, r4, r1
 802a814:	440b      	add	r3, r1
 802a816:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
	rpNumbers[csCount]++;
 802a81a:	683b      	ldr	r3, [r7, #0]
 802a81c:	009b      	lsls	r3, r3, #2
 802a81e:	687a      	ldr	r2, [r7, #4]
 802a820:	4413      	add	r3, r2
 802a822:	681a      	ldr	r2, [r3, #0]
 802a824:	3201      	adds	r2, #1
 802a826:	601a      	str	r2, [r3, #0]

	if(LenArr < rpNumbers[csCount])
 802a828:	683b      	ldr	r3, [r7, #0]
 802a82a:	009b      	lsls	r3, r3, #2
 802a82c:	687a      	ldr	r2, [r7, #4]
 802a82e:	4413      	add	r3, r2
 802a830:	681a      	ldr	r2, [r3, #0]
 802a832:	4b6b      	ldr	r3, [pc, #428]	; (802a9e0 <OMEmean+0x2e4>)
 802a834:	681b      	ldr	r3, [r3, #0]
 802a836:	429a      	cmp	r2, r3
 802a838:	dd06      	ble.n	802a848 <OMEmean+0x14c>
	{
		LenArr = rpNumbers[csCount];
 802a83a:	683b      	ldr	r3, [r7, #0]
 802a83c:	009b      	lsls	r3, r3, #2
 802a83e:	687a      	ldr	r2, [r7, #4]
 802a840:	4413      	add	r3, r2
 802a842:	681b      	ldr	r3, [r3, #0]
 802a844:	4a66      	ldr	r2, [pc, #408]	; (802a9e0 <OMEmean+0x2e4>)
 802a846:	6013      	str	r3, [r2, #0]
	}

	for(int i = 0; i < nIMUs; i++)
 802a848:	2300      	movs	r3, #0
 802a84a:	623b      	str	r3, [r7, #32]
 802a84c:	e00c      	b.n	802a868 <OMEmean+0x16c>
	{
		if(rpNumbers[i]>0)
 802a84e:	6a3b      	ldr	r3, [r7, #32]
 802a850:	009b      	lsls	r3, r3, #2
 802a852:	687a      	ldr	r2, [r7, #4]
 802a854:	4413      	add	r3, r2
 802a856:	681b      	ldr	r3, [r3, #0]
 802a858:	2b00      	cmp	r3, #0
 802a85a:	dd02      	ble.n	802a862 <OMEmean+0x166>
		{
			nFlag++;
 802a85c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a85e:	3301      	adds	r3, #1
 802a860:	627b      	str	r3, [r7, #36]	; 0x24
	for(int i = 0; i < nIMUs; i++)
 802a862:	6a3b      	ldr	r3, [r7, #32]
 802a864:	3301      	adds	r3, #1
 802a866:	623b      	str	r3, [r7, #32]
 802a868:	6a3b      	ldr	r3, [r7, #32]
 802a86a:	2b05      	cmp	r3, #5
 802a86c:	ddef      	ble.n	802a84e <OMEmean+0x152>
		}
	}

	if(nFlag == nIMUs)
 802a86e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a870:	2b06      	cmp	r3, #6
 802a872:	f040 80a8 	bne.w	802a9c6 <OMEmean+0x2ca>
	{
		OMEbarOJ.OME[0][OMEIndex] =  (float) ((float)Sum_OMX[0]/(float)nIMUs);
 802a876:	4b56      	ldr	r3, [pc, #344]	; (802a9d0 <OMEmean+0x2d4>)
 802a878:	ed93 7a00 	vldr	s14, [r3]
 802a87c:	4b59      	ldr	r3, [pc, #356]	; (802a9e4 <OMEmean+0x2e8>)
 802a87e:	681b      	ldr	r3, [r3, #0]
 802a880:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 802a884:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802a888:	4a57      	ldr	r2, [pc, #348]	; (802a9e8 <OMEmean+0x2ec>)
 802a88a:	009b      	lsls	r3, r3, #2
 802a88c:	4413      	add	r3, r2
 802a88e:	edc3 7a00 	vstr	s15, [r3]
		OMEbarOJ.OME[1][OMEIndex] =  (float) ((float)Sum_OMY[0]/(float)nIMUs);
 802a892:	4b50      	ldr	r3, [pc, #320]	; (802a9d4 <OMEmean+0x2d8>)
 802a894:	ed93 7a00 	vldr	s14, [r3]
 802a898:	4b52      	ldr	r3, [pc, #328]	; (802a9e4 <OMEmean+0x2e8>)
 802a89a:	681b      	ldr	r3, [r3, #0]
 802a89c:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 802a8a0:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802a8a4:	4a50      	ldr	r2, [pc, #320]	; (802a9e8 <OMEmean+0x2ec>)
 802a8a6:	3364      	adds	r3, #100	; 0x64
 802a8a8:	009b      	lsls	r3, r3, #2
 802a8aa:	4413      	add	r3, r2
 802a8ac:	edc3 7a00 	vstr	s15, [r3]
		OMEbarOJ.OME[2][OMEIndex] =  (float) ((float)Sum_OMZ[0]/(float)nIMUs);
 802a8b0:	4b49      	ldr	r3, [pc, #292]	; (802a9d8 <OMEmean+0x2dc>)
 802a8b2:	ed93 7a00 	vldr	s14, [r3]
 802a8b6:	4b4b      	ldr	r3, [pc, #300]	; (802a9e4 <OMEmean+0x2e8>)
 802a8b8:	681b      	ldr	r3, [r3, #0]
 802a8ba:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 802a8be:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802a8c2:	4a49      	ldr	r2, [pc, #292]	; (802a9e8 <OMEmean+0x2ec>)
 802a8c4:	33c8      	adds	r3, #200	; 0xc8
 802a8c6:	009b      	lsls	r3, r3, #2
 802a8c8:	4413      	add	r3, r2
 802a8ca:	edc3 7a00 	vstr	s15, [r3]
		OMEIndex = OMEIndex < RX_BUFFER_SIZE? OMEIndex+1 : 0;
 802a8ce:	4b45      	ldr	r3, [pc, #276]	; (802a9e4 <OMEmean+0x2e8>)
 802a8d0:	681b      	ldr	r3, [r3, #0]
 802a8d2:	2b63      	cmp	r3, #99	; 0x63
 802a8d4:	dc03      	bgt.n	802a8de <OMEmean+0x1e2>
 802a8d6:	4b43      	ldr	r3, [pc, #268]	; (802a9e4 <OMEmean+0x2e8>)
 802a8d8:	681b      	ldr	r3, [r3, #0]
 802a8da:	3301      	adds	r3, #1
 802a8dc:	e000      	b.n	802a8e0 <OMEmean+0x1e4>
 802a8de:	2300      	movs	r3, #0
 802a8e0:	4a40      	ldr	r2, [pc, #256]	; (802a9e4 <OMEmean+0x2e8>)
 802a8e2:	6013      	str	r3, [r2, #0]

		for (int k = 0; k < nIMUs; k++)	sendIndex[k] = sumIndex[k][0];
 802a8e4:	2300      	movs	r3, #0
 802a8e6:	61fb      	str	r3, [r7, #28]
 802a8e8:	e00e      	b.n	802a908 <OMEmean+0x20c>
 802a8ea:	4a3c      	ldr	r2, [pc, #240]	; (802a9dc <OMEmean+0x2e0>)
 802a8ec:	69fb      	ldr	r3, [r7, #28]
 802a8ee:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802a8f2:	fb01 f303 	mul.w	r3, r1, r3
 802a8f6:	4413      	add	r3, r2
 802a8f8:	681a      	ldr	r2, [r3, #0]
 802a8fa:	493c      	ldr	r1, [pc, #240]	; (802a9ec <OMEmean+0x2f0>)
 802a8fc:	69fb      	ldr	r3, [r7, #28]
 802a8fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 802a902:	69fb      	ldr	r3, [r7, #28]
 802a904:	3301      	adds	r3, #1
 802a906:	61fb      	str	r3, [r7, #28]
 802a908:	69fb      	ldr	r3, [r7, #28]
 802a90a:	2b05      	cmp	r3, #5
 802a90c:	dded      	ble.n	802a8ea <OMEmean+0x1ee>

		for(int j = 1; j<(LenArr+1); j++)											// Shift sum arrays left by 1
 802a90e:	2301      	movs	r3, #1
 802a910:	61bb      	str	r3, [r7, #24]
 802a912:	e03f      	b.n	802a994 <OMEmean+0x298>
		{
			Sum_OMX[j-1] = Sum_OMX[j];
 802a914:	69bb      	ldr	r3, [r7, #24]
 802a916:	3b01      	subs	r3, #1
 802a918:	492d      	ldr	r1, [pc, #180]	; (802a9d0 <OMEmean+0x2d4>)
 802a91a:	69ba      	ldr	r2, [r7, #24]
 802a91c:	0092      	lsls	r2, r2, #2
 802a91e:	440a      	add	r2, r1
 802a920:	6812      	ldr	r2, [r2, #0]
 802a922:	492b      	ldr	r1, [pc, #172]	; (802a9d0 <OMEmean+0x2d4>)
 802a924:	009b      	lsls	r3, r3, #2
 802a926:	440b      	add	r3, r1
 802a928:	601a      	str	r2, [r3, #0]
			Sum_OMY[j-1] = Sum_OMY[j];
 802a92a:	69bb      	ldr	r3, [r7, #24]
 802a92c:	3b01      	subs	r3, #1
 802a92e:	4929      	ldr	r1, [pc, #164]	; (802a9d4 <OMEmean+0x2d8>)
 802a930:	69ba      	ldr	r2, [r7, #24]
 802a932:	0092      	lsls	r2, r2, #2
 802a934:	440a      	add	r2, r1
 802a936:	6812      	ldr	r2, [r2, #0]
 802a938:	4926      	ldr	r1, [pc, #152]	; (802a9d4 <OMEmean+0x2d8>)
 802a93a:	009b      	lsls	r3, r3, #2
 802a93c:	440b      	add	r3, r1
 802a93e:	601a      	str	r2, [r3, #0]
			Sum_OMZ[j-1] = Sum_OMZ[j];
 802a940:	69bb      	ldr	r3, [r7, #24]
 802a942:	3b01      	subs	r3, #1
 802a944:	4924      	ldr	r1, [pc, #144]	; (802a9d8 <OMEmean+0x2dc>)
 802a946:	69ba      	ldr	r2, [r7, #24]
 802a948:	0092      	lsls	r2, r2, #2
 802a94a:	440a      	add	r2, r1
 802a94c:	6812      	ldr	r2, [r2, #0]
 802a94e:	4922      	ldr	r1, [pc, #136]	; (802a9d8 <OMEmean+0x2dc>)
 802a950:	009b      	lsls	r3, r3, #2
 802a952:	440b      	add	r3, r1
 802a954:	601a      	str	r2, [r3, #0]

			for (int k = 0; k < nIMUs; k++)	sumIndex[k][j - 1] = sumIndex[k][j];
 802a956:	2300      	movs	r3, #0
 802a958:	617b      	str	r3, [r7, #20]
 802a95a:	e015      	b.n	802a988 <OMEmean+0x28c>
 802a95c:	69bb      	ldr	r3, [r7, #24]
 802a95e:	3b01      	subs	r3, #1
 802a960:	481e      	ldr	r0, [pc, #120]	; (802a9dc <OMEmean+0x2e0>)
 802a962:	697a      	ldr	r2, [r7, #20]
 802a964:	2164      	movs	r1, #100	; 0x64
 802a966:	fb01 f102 	mul.w	r1, r1, r2
 802a96a:	69ba      	ldr	r2, [r7, #24]
 802a96c:	440a      	add	r2, r1
 802a96e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 802a972:	481a      	ldr	r0, [pc, #104]	; (802a9dc <OMEmean+0x2e0>)
 802a974:	6979      	ldr	r1, [r7, #20]
 802a976:	2464      	movs	r4, #100	; 0x64
 802a978:	fb04 f101 	mul.w	r1, r4, r1
 802a97c:	440b      	add	r3, r1
 802a97e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 802a982:	697b      	ldr	r3, [r7, #20]
 802a984:	3301      	adds	r3, #1
 802a986:	617b      	str	r3, [r7, #20]
 802a988:	697b      	ldr	r3, [r7, #20]
 802a98a:	2b05      	cmp	r3, #5
 802a98c:	dde6      	ble.n	802a95c <OMEmean+0x260>
		for(int j = 1; j<(LenArr+1); j++)											// Shift sum arrays left by 1
 802a98e:	69bb      	ldr	r3, [r7, #24]
 802a990:	3301      	adds	r3, #1
 802a992:	61bb      	str	r3, [r7, #24]
 802a994:	4b12      	ldr	r3, [pc, #72]	; (802a9e0 <OMEmean+0x2e4>)
 802a996:	681b      	ldr	r3, [r3, #0]
 802a998:	3301      	adds	r3, #1
 802a99a:	69ba      	ldr	r2, [r7, #24]
 802a99c:	429a      	cmp	r2, r3
 802a99e:	dbb9      	blt.n	802a914 <OMEmean+0x218>
		}

		for (int z = 0; z < nIMUs; z++)
 802a9a0:	2300      	movs	r3, #0
 802a9a2:	613b      	str	r3, [r7, #16]
 802a9a4:	e00c      	b.n	802a9c0 <OMEmean+0x2c4>
		{
			if(z < nIMUs)
 802a9a6:	693b      	ldr	r3, [r7, #16]
 802a9a8:	2b05      	cmp	r3, #5
 802a9aa:	dc06      	bgt.n	802a9ba <OMEmean+0x2be>
			{
				rpNumbers[z]--;
 802a9ac:	693b      	ldr	r3, [r7, #16]
 802a9ae:	009b      	lsls	r3, r3, #2
 802a9b0:	687a      	ldr	r2, [r7, #4]
 802a9b2:	4413      	add	r3, r2
 802a9b4:	681a      	ldr	r2, [r3, #0]
 802a9b6:	3a01      	subs	r2, #1
 802a9b8:	601a      	str	r2, [r3, #0]
		for (int z = 0; z < nIMUs; z++)
 802a9ba:	693b      	ldr	r3, [r7, #16]
 802a9bc:	3301      	adds	r3, #1
 802a9be:	613b      	str	r3, [r7, #16]
 802a9c0:	693b      	ldr	r3, [r7, #16]
 802a9c2:	2b05      	cmp	r3, #5
 802a9c4:	ddef      	ble.n	802a9a6 <OMEmean+0x2aa>
			}
		}
	}
}
 802a9c6:	bf00      	nop
 802a9c8:	3728      	adds	r7, #40	; 0x28
 802a9ca:	46bd      	mov	sp, r7
 802a9cc:	bc90      	pop	{r4, r7}
 802a9ce:	4770      	bx	lr
 802a9d0:	200006a0 	.word	0x200006a0
 802a9d4:	20000830 	.word	0x20000830
 802a9d8:	200009c0 	.word	0x200009c0
 802a9dc:	20000b50 	.word	0x20000b50
 802a9e0:	2000197c 	.word	0x2000197c
 802a9e4:	20001978 	.word	0x20001978
 802a9e8:	200014c8 	.word	0x200014c8
 802a9ec:	200014b0 	.word	0x200014b0

0802a9f0 <ArrShifter>:

void ArrShifter()
{
 802a9f0:	b480      	push	{r7}
 802a9f2:	b083      	sub	sp, #12
 802a9f4:	af00      	add	r7, sp, #0
	for(int j = 2; j < OMEIndex+2; j++)
 802a9f6:	2302      	movs	r3, #2
 802a9f8:	607b      	str	r3, [r7, #4]
 802a9fa:	e027      	b.n	802aa4c <ArrShifter+0x5c>
	{
		OMEbarOJ.OME[0][j-2] = OMEbarOJ.OME[0][j];
 802a9fc:	687b      	ldr	r3, [r7, #4]
 802a9fe:	3b02      	subs	r3, #2
 802aa00:	4918      	ldr	r1, [pc, #96]	; (802aa64 <ArrShifter+0x74>)
 802aa02:	687a      	ldr	r2, [r7, #4]
 802aa04:	0092      	lsls	r2, r2, #2
 802aa06:	440a      	add	r2, r1
 802aa08:	6812      	ldr	r2, [r2, #0]
 802aa0a:	4916      	ldr	r1, [pc, #88]	; (802aa64 <ArrShifter+0x74>)
 802aa0c:	009b      	lsls	r3, r3, #2
 802aa0e:	440b      	add	r3, r1
 802aa10:	601a      	str	r2, [r3, #0]
		OMEbarOJ.OME[1][j-2] = OMEbarOJ.OME[1][j];
 802aa12:	687b      	ldr	r3, [r7, #4]
 802aa14:	3b02      	subs	r3, #2
 802aa16:	4913      	ldr	r1, [pc, #76]	; (802aa64 <ArrShifter+0x74>)
 802aa18:	687a      	ldr	r2, [r7, #4]
 802aa1a:	3264      	adds	r2, #100	; 0x64
 802aa1c:	0092      	lsls	r2, r2, #2
 802aa1e:	440a      	add	r2, r1
 802aa20:	6812      	ldr	r2, [r2, #0]
 802aa22:	4910      	ldr	r1, [pc, #64]	; (802aa64 <ArrShifter+0x74>)
 802aa24:	3364      	adds	r3, #100	; 0x64
 802aa26:	009b      	lsls	r3, r3, #2
 802aa28:	440b      	add	r3, r1
 802aa2a:	601a      	str	r2, [r3, #0]
		OMEbarOJ.OME[2][j-2] = OMEbarOJ.OME[2][j];
 802aa2c:	687b      	ldr	r3, [r7, #4]
 802aa2e:	3b02      	subs	r3, #2
 802aa30:	490c      	ldr	r1, [pc, #48]	; (802aa64 <ArrShifter+0x74>)
 802aa32:	687a      	ldr	r2, [r7, #4]
 802aa34:	32c8      	adds	r2, #200	; 0xc8
 802aa36:	0092      	lsls	r2, r2, #2
 802aa38:	440a      	add	r2, r1
 802aa3a:	6812      	ldr	r2, [r2, #0]
 802aa3c:	4909      	ldr	r1, [pc, #36]	; (802aa64 <ArrShifter+0x74>)
 802aa3e:	33c8      	adds	r3, #200	; 0xc8
 802aa40:	009b      	lsls	r3, r3, #2
 802aa42:	440b      	add	r3, r1
 802aa44:	601a      	str	r2, [r3, #0]
	for(int j = 2; j < OMEIndex+2; j++)
 802aa46:	687b      	ldr	r3, [r7, #4]
 802aa48:	3301      	adds	r3, #1
 802aa4a:	607b      	str	r3, [r7, #4]
 802aa4c:	4b06      	ldr	r3, [pc, #24]	; (802aa68 <ArrShifter+0x78>)
 802aa4e:	681b      	ldr	r3, [r3, #0]
 802aa50:	3302      	adds	r3, #2
 802aa52:	687a      	ldr	r2, [r7, #4]
 802aa54:	429a      	cmp	r2, r3
 802aa56:	dbd1      	blt.n	802a9fc <ArrShifter+0xc>
	}
}
 802aa58:	bf00      	nop
 802aa5a:	370c      	adds	r7, #12
 802aa5c:	46bd      	mov	sp, r7
 802aa5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802aa62:	4770      	bx	lr
 802aa64:	200014c8 	.word	0x200014c8
 802aa68:	20001978 	.word	0x20001978

0802aa6c <IntegrateOmBar>:

//Purpose: numerical integration algorithm
//tx_bytes structure: phi (bytes 0-11), gamma (bytes 12-23), ombar, accelerometer
//Input: None
void IntegrateOmBar(struct CalibBuffer *calibData)
{
 802aa6c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 802aa70:	b086      	sub	sp, #24
 802aa72:	af00      	add	r7, sp, #0
 802aa74:	6078      	str	r0, [r7, #4]
	if(OMEIndex%3 == 0 && OMEIndex > 0)
 802aa76:	4bc0      	ldr	r3, [pc, #768]	; (802ad78 <IntegrateOmBar+0x30c>)
 802aa78:	6819      	ldr	r1, [r3, #0]
 802aa7a:	4bc0      	ldr	r3, [pc, #768]	; (802ad7c <IntegrateOmBar+0x310>)
 802aa7c:	fb83 3201 	smull	r3, r2, r3, r1
 802aa80:	17cb      	asrs	r3, r1, #31
 802aa82:	1ad2      	subs	r2, r2, r3
 802aa84:	4613      	mov	r3, r2
 802aa86:	005b      	lsls	r3, r3, #1
 802aa88:	4413      	add	r3, r2
 802aa8a:	1aca      	subs	r2, r1, r3
 802aa8c:	2a00      	cmp	r2, #0
 802aa8e:	f040 82b7 	bne.w	802b000 <IntegrateOmBar+0x594>
 802aa92:	4bb9      	ldr	r3, [pc, #740]	; (802ad78 <IntegrateOmBar+0x30c>)
 802aa94:	681b      	ldr	r3, [r3, #0]
 802aa96:	2b00      	cmp	r3, #0
 802aa98:	f340 82b2 	ble.w	802b000 <IntegrateOmBar+0x594>
	{
		sets++;
 802aa9c:	4bb8      	ldr	r3, [pc, #736]	; (802ad80 <IntegrateOmBar+0x314>)
 802aa9e:	681b      	ldr	r3, [r3, #0]
 802aaa0:	3301      	adds	r3, #1
 802aaa2:	4ab7      	ldr	r2, [pc, #732]	; (802ad80 <IntegrateOmBar+0x314>)
 802aaa4:	6013      	str	r3, [r2, #0]
		for(int i = 0; i<3;i++)
 802aaa6:	2300      	movs	r3, #0
 802aaa8:	617b      	str	r3, [r7, #20]
 802aaaa:	e0be      	b.n	802ac2a <IntegrateOmBar+0x1be>
		{
			if(alf == 1)
 802aaac:	4bb5      	ldr	r3, [pc, #724]	; (802ad84 <IntegrateOmBar+0x318>)
 802aaae:	681b      	ldr	r3, [r3, #0]
 802aab0:	2b01      	cmp	r3, #1
 802aab2:	d109      	bne.n	802aac8 <IntegrateOmBar+0x5c>
			{
				al[0][i] = lastal[i];
 802aab4:	4ab4      	ldr	r2, [pc, #720]	; (802ad88 <IntegrateOmBar+0x31c>)
 802aab6:	697b      	ldr	r3, [r7, #20]
 802aab8:	009b      	lsls	r3, r3, #2
 802aaba:	4413      	add	r3, r2
 802aabc:	681a      	ldr	r2, [r3, #0]
 802aabe:	49b3      	ldr	r1, [pc, #716]	; (802ad8c <IntegrateOmBar+0x320>)
 802aac0:	697b      	ldr	r3, [r7, #20]
 802aac2:	009b      	lsls	r3, r3, #2
 802aac4:	440b      	add	r3, r1
 802aac6:	601a      	str	r2, [r3, #0]
			}
			alf = 1;
 802aac8:	4bae      	ldr	r3, [pc, #696]	; (802ad84 <IntegrateOmBar+0x318>)
 802aaca:	2201      	movs	r2, #1
 802aacc:	601a      	str	r2, [r3, #0]
			al[1][i] = al[0][i] + 0.25 * dt  * (OMEbarOJ.OME[i][0] + OMEbarOJ.OME[i][1]);					// Trapezoidal rule to calculate intermediate alpha
 802aace:	4aaf      	ldr	r2, [pc, #700]	; (802ad8c <IntegrateOmBar+0x320>)
 802aad0:	697b      	ldr	r3, [r7, #20]
 802aad2:	009b      	lsls	r3, r3, #2
 802aad4:	4413      	add	r3, r2
 802aad6:	681b      	ldr	r3, [r3, #0]
 802aad8:	4618      	mov	r0, r3
 802aada:	f7fd ffed 	bl	8028ab8 <__aeabi_f2d>
 802aade:	4604      	mov	r4, r0
 802aae0:	460d      	mov	r5, r1
 802aae2:	4bab      	ldr	r3, [pc, #684]	; (802ad90 <IntegrateOmBar+0x324>)
 802aae4:	e9d3 0100 	ldrd	r0, r1, [r3]
 802aae8:	f04f 0200 	mov.w	r2, #0
 802aaec:	4ba9      	ldr	r3, [pc, #676]	; (802ad94 <IntegrateOmBar+0x328>)
 802aaee:	f7fe f83b 	bl	8028b68 <__aeabi_dmul>
 802aaf2:	4602      	mov	r2, r0
 802aaf4:	460b      	mov	r3, r1
 802aaf6:	4690      	mov	r8, r2
 802aaf8:	4699      	mov	r9, r3
 802aafa:	4aa7      	ldr	r2, [pc, #668]	; (802ad98 <IntegrateOmBar+0x32c>)
 802aafc:	697b      	ldr	r3, [r7, #20]
 802aafe:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802ab02:	fb01 f303 	mul.w	r3, r1, r3
 802ab06:	4413      	add	r3, r2
 802ab08:	ed93 7a00 	vldr	s14, [r3]
 802ab0c:	4aa2      	ldr	r2, [pc, #648]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ab0e:	697b      	ldr	r3, [r7, #20]
 802ab10:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802ab14:	fb01 f303 	mul.w	r3, r1, r3
 802ab18:	4413      	add	r3, r2
 802ab1a:	3304      	adds	r3, #4
 802ab1c:	edd3 7a00 	vldr	s15, [r3]
 802ab20:	ee77 7a27 	vadd.f32	s15, s14, s15
 802ab24:	ee17 0a90 	vmov	r0, s15
 802ab28:	f7fd ffc6 	bl	8028ab8 <__aeabi_f2d>
 802ab2c:	4602      	mov	r2, r0
 802ab2e:	460b      	mov	r3, r1
 802ab30:	4640      	mov	r0, r8
 802ab32:	4649      	mov	r1, r9
 802ab34:	f7fe f818 	bl	8028b68 <__aeabi_dmul>
 802ab38:	4602      	mov	r2, r0
 802ab3a:	460b      	mov	r3, r1
 802ab3c:	4620      	mov	r0, r4
 802ab3e:	4629      	mov	r1, r5
 802ab40:	f7fd fe5c 	bl	80287fc <__adddf3>
 802ab44:	4603      	mov	r3, r0
 802ab46:	460c      	mov	r4, r1
 802ab48:	4618      	mov	r0, r3
 802ab4a:	4621      	mov	r1, r4
 802ab4c:	f7fe fabc 	bl	80290c8 <__aeabi_d2f>
 802ab50:	4601      	mov	r1, r0
 802ab52:	4a8e      	ldr	r2, [pc, #568]	; (802ad8c <IntegrateOmBar+0x320>)
 802ab54:	697b      	ldr	r3, [r7, #20]
 802ab56:	3303      	adds	r3, #3
 802ab58:	009b      	lsls	r3, r3, #2
 802ab5a:	4413      	add	r3, r2
 802ab5c:	6019      	str	r1, [r3, #0]
			al[2][i] = al[0][i] + dt/6 * (OMEbarOJ.OME[i][0] + 4*OMEbarOJ.OME[i][1] + OMEbarOJ.OME[i][2]);
 802ab5e:	4a8b      	ldr	r2, [pc, #556]	; (802ad8c <IntegrateOmBar+0x320>)
 802ab60:	697b      	ldr	r3, [r7, #20]
 802ab62:	009b      	lsls	r3, r3, #2
 802ab64:	4413      	add	r3, r2
 802ab66:	681b      	ldr	r3, [r3, #0]
 802ab68:	4618      	mov	r0, r3
 802ab6a:	f7fd ffa5 	bl	8028ab8 <__aeabi_f2d>
 802ab6e:	4604      	mov	r4, r0
 802ab70:	460d      	mov	r5, r1
 802ab72:	4b87      	ldr	r3, [pc, #540]	; (802ad90 <IntegrateOmBar+0x324>)
 802ab74:	e9d3 0100 	ldrd	r0, r1, [r3]
 802ab78:	f04f 0200 	mov.w	r2, #0
 802ab7c:	4b87      	ldr	r3, [pc, #540]	; (802ad9c <IntegrateOmBar+0x330>)
 802ab7e:	f7fe f91d 	bl	8028dbc <__aeabi_ddiv>
 802ab82:	4602      	mov	r2, r0
 802ab84:	460b      	mov	r3, r1
 802ab86:	4690      	mov	r8, r2
 802ab88:	4699      	mov	r9, r3
 802ab8a:	4a83      	ldr	r2, [pc, #524]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ab8c:	697b      	ldr	r3, [r7, #20]
 802ab8e:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802ab92:	fb01 f303 	mul.w	r3, r1, r3
 802ab96:	4413      	add	r3, r2
 802ab98:	ed93 7a00 	vldr	s14, [r3]
 802ab9c:	4a7e      	ldr	r2, [pc, #504]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ab9e:	697b      	ldr	r3, [r7, #20]
 802aba0:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802aba4:	fb01 f303 	mul.w	r3, r1, r3
 802aba8:	4413      	add	r3, r2
 802abaa:	3304      	adds	r3, #4
 802abac:	edd3 7a00 	vldr	s15, [r3]
 802abb0:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 802abb4:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802abb8:	ee37 7a27 	vadd.f32	s14, s14, s15
 802abbc:	4a76      	ldr	r2, [pc, #472]	; (802ad98 <IntegrateOmBar+0x32c>)
 802abbe:	697b      	ldr	r3, [r7, #20]
 802abc0:	f44f 71c8 	mov.w	r1, #400	; 0x190
 802abc4:	fb01 f303 	mul.w	r3, r1, r3
 802abc8:	4413      	add	r3, r2
 802abca:	3308      	adds	r3, #8
 802abcc:	edd3 7a00 	vldr	s15, [r3]
 802abd0:	ee77 7a27 	vadd.f32	s15, s14, s15
 802abd4:	ee17 0a90 	vmov	r0, s15
 802abd8:	f7fd ff6e 	bl	8028ab8 <__aeabi_f2d>
 802abdc:	4602      	mov	r2, r0
 802abde:	460b      	mov	r3, r1
 802abe0:	4640      	mov	r0, r8
 802abe2:	4649      	mov	r1, r9
 802abe4:	f7fd ffc0 	bl	8028b68 <__aeabi_dmul>
 802abe8:	4602      	mov	r2, r0
 802abea:	460b      	mov	r3, r1
 802abec:	4620      	mov	r0, r4
 802abee:	4629      	mov	r1, r5
 802abf0:	f7fd fe04 	bl	80287fc <__adddf3>
 802abf4:	4603      	mov	r3, r0
 802abf6:	460c      	mov	r4, r1
 802abf8:	4618      	mov	r0, r3
 802abfa:	4621      	mov	r1, r4
 802abfc:	f7fe fa64 	bl	80290c8 <__aeabi_d2f>
 802ac00:	4601      	mov	r1, r0
 802ac02:	4a62      	ldr	r2, [pc, #392]	; (802ad8c <IntegrateOmBar+0x320>)
 802ac04:	697b      	ldr	r3, [r7, #20]
 802ac06:	3306      	adds	r3, #6
 802ac08:	009b      	lsls	r3, r3, #2
 802ac0a:	4413      	add	r3, r2
 802ac0c:	6019      	str	r1, [r3, #0]
			lastal[i] = al[2][i];
 802ac0e:	4a5f      	ldr	r2, [pc, #380]	; (802ad8c <IntegrateOmBar+0x320>)
 802ac10:	697b      	ldr	r3, [r7, #20]
 802ac12:	3306      	adds	r3, #6
 802ac14:	009b      	lsls	r3, r3, #2
 802ac16:	4413      	add	r3, r2
 802ac18:	681a      	ldr	r2, [r3, #0]
 802ac1a:	495b      	ldr	r1, [pc, #364]	; (802ad88 <IntegrateOmBar+0x31c>)
 802ac1c:	697b      	ldr	r3, [r7, #20]
 802ac1e:	009b      	lsls	r3, r3, #2
 802ac20:	440b      	add	r3, r1
 802ac22:	601a      	str	r2, [r3, #0]
		for(int i = 0; i<3;i++)
 802ac24:	697b      	ldr	r3, [r7, #20]
 802ac26:	3301      	adds	r3, #1
 802ac28:	617b      	str	r3, [r7, #20]
 802ac2a:	697b      	ldr	r3, [r7, #20]
 802ac2c:	2b02      	cmp	r3, #2
 802ac2e:	f77f af3d 	ble.w	802aaac <IntegrateOmBar+0x40>
		}

		for(int i = 0; i<3;i++)
 802ac32:	2300      	movs	r3, #0
 802ac34:	613b      	str	r3, [r7, #16]
 802ac36:	e11d      	b.n	802ae74 <IntegrateOmBar+0x408>
		{
			bd[i][0] = 0.5*((al[i][1]*OMEbarOJ.OME[2][i]) - (al[i][2]*OMEbarOJ.OME[1][i]));
 802ac38:	4954      	ldr	r1, [pc, #336]	; (802ad8c <IntegrateOmBar+0x320>)
 802ac3a:	693a      	ldr	r2, [r7, #16]
 802ac3c:	4613      	mov	r3, r2
 802ac3e:	005b      	lsls	r3, r3, #1
 802ac40:	4413      	add	r3, r2
 802ac42:	009b      	lsls	r3, r3, #2
 802ac44:	440b      	add	r3, r1
 802ac46:	3304      	adds	r3, #4
 802ac48:	ed93 7a00 	vldr	s14, [r3]
 802ac4c:	4a52      	ldr	r2, [pc, #328]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ac4e:	693b      	ldr	r3, [r7, #16]
 802ac50:	33c8      	adds	r3, #200	; 0xc8
 802ac52:	009b      	lsls	r3, r3, #2
 802ac54:	4413      	add	r3, r2
 802ac56:	edd3 7a00 	vldr	s15, [r3]
 802ac5a:	ee27 7a27 	vmul.f32	s14, s14, s15
 802ac5e:	494b      	ldr	r1, [pc, #300]	; (802ad8c <IntegrateOmBar+0x320>)
 802ac60:	693a      	ldr	r2, [r7, #16]
 802ac62:	4613      	mov	r3, r2
 802ac64:	005b      	lsls	r3, r3, #1
 802ac66:	4413      	add	r3, r2
 802ac68:	009b      	lsls	r3, r3, #2
 802ac6a:	440b      	add	r3, r1
 802ac6c:	3308      	adds	r3, #8
 802ac6e:	edd3 6a00 	vldr	s13, [r3]
 802ac72:	4a49      	ldr	r2, [pc, #292]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ac74:	693b      	ldr	r3, [r7, #16]
 802ac76:	3364      	adds	r3, #100	; 0x64
 802ac78:	009b      	lsls	r3, r3, #2
 802ac7a:	4413      	add	r3, r2
 802ac7c:	edd3 7a00 	vldr	s15, [r3]
 802ac80:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802ac84:	ee77 7a67 	vsub.f32	s15, s14, s15
 802ac88:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802ac8c:	ee67 7a87 	vmul.f32	s15, s15, s14
 802ac90:	4943      	ldr	r1, [pc, #268]	; (802ada0 <IntegrateOmBar+0x334>)
 802ac92:	693a      	ldr	r2, [r7, #16]
 802ac94:	4613      	mov	r3, r2
 802ac96:	005b      	lsls	r3, r3, #1
 802ac98:	4413      	add	r3, r2
 802ac9a:	009b      	lsls	r3, r3, #2
 802ac9c:	440b      	add	r3, r1
 802ac9e:	edc3 7a00 	vstr	s15, [r3]
			bd[i][1] = 0.5*((al[i][2]*OMEbarOJ.OME[0][i]) - (al[i][0]*OMEbarOJ.OME[2][i]));
 802aca2:	493a      	ldr	r1, [pc, #232]	; (802ad8c <IntegrateOmBar+0x320>)
 802aca4:	693a      	ldr	r2, [r7, #16]
 802aca6:	4613      	mov	r3, r2
 802aca8:	005b      	lsls	r3, r3, #1
 802acaa:	4413      	add	r3, r2
 802acac:	009b      	lsls	r3, r3, #2
 802acae:	440b      	add	r3, r1
 802acb0:	3308      	adds	r3, #8
 802acb2:	ed93 7a00 	vldr	s14, [r3]
 802acb6:	4a38      	ldr	r2, [pc, #224]	; (802ad98 <IntegrateOmBar+0x32c>)
 802acb8:	693b      	ldr	r3, [r7, #16]
 802acba:	009b      	lsls	r3, r3, #2
 802acbc:	4413      	add	r3, r2
 802acbe:	edd3 7a00 	vldr	s15, [r3]
 802acc2:	ee27 7a27 	vmul.f32	s14, s14, s15
 802acc6:	4931      	ldr	r1, [pc, #196]	; (802ad8c <IntegrateOmBar+0x320>)
 802acc8:	693a      	ldr	r2, [r7, #16]
 802acca:	4613      	mov	r3, r2
 802accc:	005b      	lsls	r3, r3, #1
 802acce:	4413      	add	r3, r2
 802acd0:	009b      	lsls	r3, r3, #2
 802acd2:	440b      	add	r3, r1
 802acd4:	edd3 6a00 	vldr	s13, [r3]
 802acd8:	4a2f      	ldr	r2, [pc, #188]	; (802ad98 <IntegrateOmBar+0x32c>)
 802acda:	693b      	ldr	r3, [r7, #16]
 802acdc:	33c8      	adds	r3, #200	; 0xc8
 802acde:	009b      	lsls	r3, r3, #2
 802ace0:	4413      	add	r3, r2
 802ace2:	edd3 7a00 	vldr	s15, [r3]
 802ace6:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802acea:	ee77 7a67 	vsub.f32	s15, s14, s15
 802acee:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802acf2:	ee67 7a87 	vmul.f32	s15, s15, s14
 802acf6:	492a      	ldr	r1, [pc, #168]	; (802ada0 <IntegrateOmBar+0x334>)
 802acf8:	693a      	ldr	r2, [r7, #16]
 802acfa:	4613      	mov	r3, r2
 802acfc:	005b      	lsls	r3, r3, #1
 802acfe:	4413      	add	r3, r2
 802ad00:	009b      	lsls	r3, r3, #2
 802ad02:	440b      	add	r3, r1
 802ad04:	3304      	adds	r3, #4
 802ad06:	edc3 7a00 	vstr	s15, [r3]
			bd[i][2] = 0.5*((al[i][0]*OMEbarOJ.OME[1][i]) - (al[i][1]*OMEbarOJ.OME[0][i]));
 802ad0a:	4920      	ldr	r1, [pc, #128]	; (802ad8c <IntegrateOmBar+0x320>)
 802ad0c:	693a      	ldr	r2, [r7, #16]
 802ad0e:	4613      	mov	r3, r2
 802ad10:	005b      	lsls	r3, r3, #1
 802ad12:	4413      	add	r3, r2
 802ad14:	009b      	lsls	r3, r3, #2
 802ad16:	440b      	add	r3, r1
 802ad18:	ed93 7a00 	vldr	s14, [r3]
 802ad1c:	4a1e      	ldr	r2, [pc, #120]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ad1e:	693b      	ldr	r3, [r7, #16]
 802ad20:	3364      	adds	r3, #100	; 0x64
 802ad22:	009b      	lsls	r3, r3, #2
 802ad24:	4413      	add	r3, r2
 802ad26:	edd3 7a00 	vldr	s15, [r3]
 802ad2a:	ee27 7a27 	vmul.f32	s14, s14, s15
 802ad2e:	4917      	ldr	r1, [pc, #92]	; (802ad8c <IntegrateOmBar+0x320>)
 802ad30:	693a      	ldr	r2, [r7, #16]
 802ad32:	4613      	mov	r3, r2
 802ad34:	005b      	lsls	r3, r3, #1
 802ad36:	4413      	add	r3, r2
 802ad38:	009b      	lsls	r3, r3, #2
 802ad3a:	440b      	add	r3, r1
 802ad3c:	3304      	adds	r3, #4
 802ad3e:	edd3 6a00 	vldr	s13, [r3]
 802ad42:	4a15      	ldr	r2, [pc, #84]	; (802ad98 <IntegrateOmBar+0x32c>)
 802ad44:	693b      	ldr	r3, [r7, #16]
 802ad46:	009b      	lsls	r3, r3, #2
 802ad48:	4413      	add	r3, r2
 802ad4a:	edd3 7a00 	vldr	s15, [r3]
 802ad4e:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802ad52:	ee77 7a67 	vsub.f32	s15, s14, s15
 802ad56:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802ad5a:	ee67 7a87 	vmul.f32	s15, s15, s14
 802ad5e:	4910      	ldr	r1, [pc, #64]	; (802ada0 <IntegrateOmBar+0x334>)
 802ad60:	693a      	ldr	r2, [r7, #16]
 802ad62:	4613      	mov	r3, r2
 802ad64:	005b      	lsls	r3, r3, #1
 802ad66:	4413      	add	r3, r2
 802ad68:	009b      	lsls	r3, r3, #2
 802ad6a:	440b      	add	r3, r1
 802ad6c:	3308      	adds	r3, #8
 802ad6e:	edc3 7a00 	vstr	s15, [r3]
			for(int j =0;j<3;j++)
 802ad72:	2300      	movs	r3, #0
 802ad74:	60fb      	str	r3, [r7, #12]
 802ad76:	e077      	b.n	802ae68 <IntegrateOmBar+0x3fc>
 802ad78:	20001978 	.word	0x20001978
 802ad7c:	55555556 	.word	0x55555556
 802ad80:	20001a08 	.word	0x20001a08
 802ad84:	20001a04 	.word	0x20001a04
 802ad88:	200019c8 	.word	0x200019c8
 802ad8c:	20001980 	.word	0x20001980
 802ad90:	200005b8 	.word	0x200005b8
 802ad94:	3fd00000 	.word	0x3fd00000
 802ad98:	200014c8 	.word	0x200014c8
 802ad9c:	40180000 	.word	0x40180000
 802ada0:	200019d4 	.word	0x200019d4
			{
				gd[i][j] = 0.5* (al[i][j] - (((sets-1)*2+i)*(dt/2) * OMEbarOJ.OME[j][i]));
 802ada4:	4999      	ldr	r1, [pc, #612]	; (802b00c <IntegrateOmBar+0x5a0>)
 802ada6:	693a      	ldr	r2, [r7, #16]
 802ada8:	4613      	mov	r3, r2
 802adaa:	005b      	lsls	r3, r3, #1
 802adac:	4413      	add	r3, r2
 802adae:	68fa      	ldr	r2, [r7, #12]
 802adb0:	4413      	add	r3, r2
 802adb2:	009b      	lsls	r3, r3, #2
 802adb4:	440b      	add	r3, r1
 802adb6:	681b      	ldr	r3, [r3, #0]
 802adb8:	4618      	mov	r0, r3
 802adba:	f7fd fe7d 	bl	8028ab8 <__aeabi_f2d>
 802adbe:	4604      	mov	r4, r0
 802adc0:	460d      	mov	r5, r1
 802adc2:	4b93      	ldr	r3, [pc, #588]	; (802b010 <IntegrateOmBar+0x5a4>)
 802adc4:	681b      	ldr	r3, [r3, #0]
 802adc6:	3b01      	subs	r3, #1
 802adc8:	005a      	lsls	r2, r3, #1
 802adca:	693b      	ldr	r3, [r7, #16]
 802adcc:	4413      	add	r3, r2
 802adce:	4618      	mov	r0, r3
 802add0:	f7fd fe60 	bl	8028a94 <__aeabi_i2d>
 802add4:	4680      	mov	r8, r0
 802add6:	4689      	mov	r9, r1
 802add8:	4b8e      	ldr	r3, [pc, #568]	; (802b014 <IntegrateOmBar+0x5a8>)
 802adda:	e9d3 0100 	ldrd	r0, r1, [r3]
 802adde:	f04f 0200 	mov.w	r2, #0
 802ade2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802ade6:	f7fd ffe9 	bl	8028dbc <__aeabi_ddiv>
 802adea:	4602      	mov	r2, r0
 802adec:	460b      	mov	r3, r1
 802adee:	4640      	mov	r0, r8
 802adf0:	4649      	mov	r1, r9
 802adf2:	f7fd feb9 	bl	8028b68 <__aeabi_dmul>
 802adf6:	4602      	mov	r2, r0
 802adf8:	460b      	mov	r3, r1
 802adfa:	4690      	mov	r8, r2
 802adfc:	4699      	mov	r9, r3
 802adfe:	4986      	ldr	r1, [pc, #536]	; (802b018 <IntegrateOmBar+0x5ac>)
 802ae00:	68fb      	ldr	r3, [r7, #12]
 802ae02:	2264      	movs	r2, #100	; 0x64
 802ae04:	fb02 f203 	mul.w	r2, r2, r3
 802ae08:	693b      	ldr	r3, [r7, #16]
 802ae0a:	4413      	add	r3, r2
 802ae0c:	009b      	lsls	r3, r3, #2
 802ae0e:	440b      	add	r3, r1
 802ae10:	681b      	ldr	r3, [r3, #0]
 802ae12:	4618      	mov	r0, r3
 802ae14:	f7fd fe50 	bl	8028ab8 <__aeabi_f2d>
 802ae18:	4602      	mov	r2, r0
 802ae1a:	460b      	mov	r3, r1
 802ae1c:	4640      	mov	r0, r8
 802ae1e:	4649      	mov	r1, r9
 802ae20:	f7fd fea2 	bl	8028b68 <__aeabi_dmul>
 802ae24:	4602      	mov	r2, r0
 802ae26:	460b      	mov	r3, r1
 802ae28:	4620      	mov	r0, r4
 802ae2a:	4629      	mov	r1, r5
 802ae2c:	f7fd fce4 	bl	80287f8 <__aeabi_dsub>
 802ae30:	4603      	mov	r3, r0
 802ae32:	460c      	mov	r4, r1
 802ae34:	4618      	mov	r0, r3
 802ae36:	4621      	mov	r1, r4
 802ae38:	f04f 0200 	mov.w	r2, #0
 802ae3c:	4b77      	ldr	r3, [pc, #476]	; (802b01c <IntegrateOmBar+0x5b0>)
 802ae3e:	f7fd fe93 	bl	8028b68 <__aeabi_dmul>
 802ae42:	4603      	mov	r3, r0
 802ae44:	460c      	mov	r4, r1
 802ae46:	4618      	mov	r0, r3
 802ae48:	4621      	mov	r1, r4
 802ae4a:	f7fe f93d 	bl	80290c8 <__aeabi_d2f>
 802ae4e:	4974      	ldr	r1, [pc, #464]	; (802b020 <IntegrateOmBar+0x5b4>)
 802ae50:	693a      	ldr	r2, [r7, #16]
 802ae52:	4613      	mov	r3, r2
 802ae54:	005b      	lsls	r3, r3, #1
 802ae56:	4413      	add	r3, r2
 802ae58:	68fa      	ldr	r2, [r7, #12]
 802ae5a:	4413      	add	r3, r2
 802ae5c:	009b      	lsls	r3, r3, #2
 802ae5e:	440b      	add	r3, r1
 802ae60:	6018      	str	r0, [r3, #0]
			for(int j =0;j<3;j++)
 802ae62:	68fb      	ldr	r3, [r7, #12]
 802ae64:	3301      	adds	r3, #1
 802ae66:	60fb      	str	r3, [r7, #12]
 802ae68:	68fb      	ldr	r3, [r7, #12]
 802ae6a:	2b02      	cmp	r3, #2
 802ae6c:	dd9a      	ble.n	802ada4 <IntegrateOmBar+0x338>
		for(int i = 0; i<3;i++)
 802ae6e:	693b      	ldr	r3, [r7, #16]
 802ae70:	3301      	adds	r3, #1
 802ae72:	613b      	str	r3, [r7, #16]
 802ae74:	693b      	ldr	r3, [r7, #16]
 802ae76:	2b02      	cmp	r3, #2
 802ae78:	f77f aede 	ble.w	802ac38 <IntegrateOmBar+0x1cc>
			}
		}

		for(int i = 0; i<3; i++)
 802ae7c:	2300      	movs	r3, #0
 802ae7e:	60bb      	str	r3, [r7, #8]
 802ae80:	e0b3      	b.n	802afea <IntegrateOmBar+0x57e>
		{
			be[i] += (dt/6)*((bd[0][i]) + 4*(bd[1][i]) + (bd[2][i]));
 802ae82:	4a68      	ldr	r2, [pc, #416]	; (802b024 <IntegrateOmBar+0x5b8>)
 802ae84:	68bb      	ldr	r3, [r7, #8]
 802ae86:	009b      	lsls	r3, r3, #2
 802ae88:	4413      	add	r3, r2
 802ae8a:	681b      	ldr	r3, [r3, #0]
 802ae8c:	4618      	mov	r0, r3
 802ae8e:	f7fd fe13 	bl	8028ab8 <__aeabi_f2d>
 802ae92:	4604      	mov	r4, r0
 802ae94:	460d      	mov	r5, r1
 802ae96:	4b5f      	ldr	r3, [pc, #380]	; (802b014 <IntegrateOmBar+0x5a8>)
 802ae98:	e9d3 0100 	ldrd	r0, r1, [r3]
 802ae9c:	f04f 0200 	mov.w	r2, #0
 802aea0:	4b61      	ldr	r3, [pc, #388]	; (802b028 <IntegrateOmBar+0x5bc>)
 802aea2:	f7fd ff8b 	bl	8028dbc <__aeabi_ddiv>
 802aea6:	4602      	mov	r2, r0
 802aea8:	460b      	mov	r3, r1
 802aeaa:	4690      	mov	r8, r2
 802aeac:	4699      	mov	r9, r3
 802aeae:	4a5f      	ldr	r2, [pc, #380]	; (802b02c <IntegrateOmBar+0x5c0>)
 802aeb0:	68bb      	ldr	r3, [r7, #8]
 802aeb2:	009b      	lsls	r3, r3, #2
 802aeb4:	4413      	add	r3, r2
 802aeb6:	ed93 7a00 	vldr	s14, [r3]
 802aeba:	4a5c      	ldr	r2, [pc, #368]	; (802b02c <IntegrateOmBar+0x5c0>)
 802aebc:	68bb      	ldr	r3, [r7, #8]
 802aebe:	3303      	adds	r3, #3
 802aec0:	009b      	lsls	r3, r3, #2
 802aec2:	4413      	add	r3, r2
 802aec4:	edd3 7a00 	vldr	s15, [r3]
 802aec8:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 802aecc:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802aed0:	ee37 7a27 	vadd.f32	s14, s14, s15
 802aed4:	4a55      	ldr	r2, [pc, #340]	; (802b02c <IntegrateOmBar+0x5c0>)
 802aed6:	68bb      	ldr	r3, [r7, #8]
 802aed8:	3306      	adds	r3, #6
 802aeda:	009b      	lsls	r3, r3, #2
 802aedc:	4413      	add	r3, r2
 802aede:	edd3 7a00 	vldr	s15, [r3]
 802aee2:	ee77 7a27 	vadd.f32	s15, s14, s15
 802aee6:	ee17 0a90 	vmov	r0, s15
 802aeea:	f7fd fde5 	bl	8028ab8 <__aeabi_f2d>
 802aeee:	4602      	mov	r2, r0
 802aef0:	460b      	mov	r3, r1
 802aef2:	4640      	mov	r0, r8
 802aef4:	4649      	mov	r1, r9
 802aef6:	f7fd fe37 	bl	8028b68 <__aeabi_dmul>
 802aefa:	4602      	mov	r2, r0
 802aefc:	460b      	mov	r3, r1
 802aefe:	4620      	mov	r0, r4
 802af00:	4629      	mov	r1, r5
 802af02:	f7fd fc7b 	bl	80287fc <__adddf3>
 802af06:	4603      	mov	r3, r0
 802af08:	460c      	mov	r4, r1
 802af0a:	4618      	mov	r0, r3
 802af0c:	4621      	mov	r1, r4
 802af0e:	f7fe f8db 	bl	80290c8 <__aeabi_d2f>
 802af12:	4601      	mov	r1, r0
 802af14:	4a43      	ldr	r2, [pc, #268]	; (802b024 <IntegrateOmBar+0x5b8>)
 802af16:	68bb      	ldr	r3, [r7, #8]
 802af18:	009b      	lsls	r3, r3, #2
 802af1a:	4413      	add	r3, r2
 802af1c:	6019      	str	r1, [r3, #0]
			gam[i].t += (dt/6)*(gd[0][i] + 4*gd[1][i] + gd[2][i]);
 802af1e:	4a44      	ldr	r2, [pc, #272]	; (802b030 <IntegrateOmBar+0x5c4>)
 802af20:	68bb      	ldr	r3, [r7, #8]
 802af22:	009b      	lsls	r3, r3, #2
 802af24:	4413      	add	r3, r2
 802af26:	681b      	ldr	r3, [r3, #0]
 802af28:	4618      	mov	r0, r3
 802af2a:	f7fd fdc5 	bl	8028ab8 <__aeabi_f2d>
 802af2e:	4604      	mov	r4, r0
 802af30:	460d      	mov	r5, r1
 802af32:	4b38      	ldr	r3, [pc, #224]	; (802b014 <IntegrateOmBar+0x5a8>)
 802af34:	e9d3 0100 	ldrd	r0, r1, [r3]
 802af38:	f04f 0200 	mov.w	r2, #0
 802af3c:	4b3a      	ldr	r3, [pc, #232]	; (802b028 <IntegrateOmBar+0x5bc>)
 802af3e:	f7fd ff3d 	bl	8028dbc <__aeabi_ddiv>
 802af42:	4602      	mov	r2, r0
 802af44:	460b      	mov	r3, r1
 802af46:	4690      	mov	r8, r2
 802af48:	4699      	mov	r9, r3
 802af4a:	4a35      	ldr	r2, [pc, #212]	; (802b020 <IntegrateOmBar+0x5b4>)
 802af4c:	68bb      	ldr	r3, [r7, #8]
 802af4e:	009b      	lsls	r3, r3, #2
 802af50:	4413      	add	r3, r2
 802af52:	ed93 7a00 	vldr	s14, [r3]
 802af56:	4a32      	ldr	r2, [pc, #200]	; (802b020 <IntegrateOmBar+0x5b4>)
 802af58:	68bb      	ldr	r3, [r7, #8]
 802af5a:	3303      	adds	r3, #3
 802af5c:	009b      	lsls	r3, r3, #2
 802af5e:	4413      	add	r3, r2
 802af60:	edd3 7a00 	vldr	s15, [r3]
 802af64:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 802af68:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802af6c:	ee37 7a27 	vadd.f32	s14, s14, s15
 802af70:	4a2b      	ldr	r2, [pc, #172]	; (802b020 <IntegrateOmBar+0x5b4>)
 802af72:	68bb      	ldr	r3, [r7, #8]
 802af74:	3306      	adds	r3, #6
 802af76:	009b      	lsls	r3, r3, #2
 802af78:	4413      	add	r3, r2
 802af7a:	edd3 7a00 	vldr	s15, [r3]
 802af7e:	ee77 7a27 	vadd.f32	s15, s14, s15
 802af82:	ee17 0a90 	vmov	r0, s15
 802af86:	f7fd fd97 	bl	8028ab8 <__aeabi_f2d>
 802af8a:	4602      	mov	r2, r0
 802af8c:	460b      	mov	r3, r1
 802af8e:	4640      	mov	r0, r8
 802af90:	4649      	mov	r1, r9
 802af92:	f7fd fde9 	bl	8028b68 <__aeabi_dmul>
 802af96:	4602      	mov	r2, r0
 802af98:	460b      	mov	r3, r1
 802af9a:	4620      	mov	r0, r4
 802af9c:	4629      	mov	r1, r5
 802af9e:	f7fd fc2d 	bl	80287fc <__adddf3>
 802afa2:	4603      	mov	r3, r0
 802afa4:	460c      	mov	r4, r1
 802afa6:	4618      	mov	r0, r3
 802afa8:	4621      	mov	r1, r4
 802afaa:	f7fe f88d 	bl	80290c8 <__aeabi_d2f>
 802afae:	4601      	mov	r1, r0
 802afb0:	4a1f      	ldr	r2, [pc, #124]	; (802b030 <IntegrateOmBar+0x5c4>)
 802afb2:	68bb      	ldr	r3, [r7, #8]
 802afb4:	009b      	lsls	r3, r3, #2
 802afb6:	4413      	add	r3, r2
 802afb8:	6019      	str	r1, [r3, #0]
			phi[i].t = al[2][i]+be[i];
 802afba:	4a14      	ldr	r2, [pc, #80]	; (802b00c <IntegrateOmBar+0x5a0>)
 802afbc:	68bb      	ldr	r3, [r7, #8]
 802afbe:	3306      	adds	r3, #6
 802afc0:	009b      	lsls	r3, r3, #2
 802afc2:	4413      	add	r3, r2
 802afc4:	ed93 7a00 	vldr	s14, [r3]
 802afc8:	4a16      	ldr	r2, [pc, #88]	; (802b024 <IntegrateOmBar+0x5b8>)
 802afca:	68bb      	ldr	r3, [r7, #8]
 802afcc:	009b      	lsls	r3, r3, #2
 802afce:	4413      	add	r3, r2
 802afd0:	edd3 7a00 	vldr	s15, [r3]
 802afd4:	ee77 7a27 	vadd.f32	s15, s14, s15
 802afd8:	4a16      	ldr	r2, [pc, #88]	; (802b034 <IntegrateOmBar+0x5c8>)
 802afda:	68bb      	ldr	r3, [r7, #8]
 802afdc:	009b      	lsls	r3, r3, #2
 802afde:	4413      	add	r3, r2
 802afe0:	edc3 7a00 	vstr	s15, [r3]
		for(int i = 0; i<3; i++)
 802afe4:	68bb      	ldr	r3, [r7, #8]
 802afe6:	3301      	adds	r3, #1
 802afe8:	60bb      	str	r3, [r7, #8]
 802afea:	68bb      	ldr	r3, [r7, #8]
 802afec:	2b02      	cmp	r3, #2
 802afee:	f77f af48 	ble.w	802ae82 <IntegrateOmBar+0x416>
		}
//		if (sets > 2)
//		{
//			__NOP();
//		}
		ArrShifter();
 802aff2:	f7ff fcfd 	bl	802a9f0 <ArrShifter>
		OMEIndex = OMEIndex - 2;
 802aff6:	4b10      	ldr	r3, [pc, #64]	; (802b038 <IntegrateOmBar+0x5cc>)
 802aff8:	681b      	ldr	r3, [r3, #0]
 802affa:	3b02      	subs	r3, #2
 802affc:	4a0e      	ldr	r2, [pc, #56]	; (802b038 <IntegrateOmBar+0x5cc>)
 802affe:	6013      	str	r3, [r2, #0]
	}
}
 802b000:	bf00      	nop
 802b002:	3718      	adds	r7, #24
 802b004:	46bd      	mov	sp, r7
 802b006:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 802b00a:	bf00      	nop
 802b00c:	20001980 	.word	0x20001980
 802b010:	20001a08 	.word	0x20001a08
 802b014:	200005b8 	.word	0x200005b8
 802b018:	200014c8 	.word	0x200014c8
 802b01c:	3fe00000 	.word	0x3fe00000
 802b020:	200019a4 	.word	0x200019a4
 802b024:	200019f8 	.word	0x200019f8
 802b028:	40180000 	.word	0x40180000
 802b02c:	200019d4 	.word	0x200019d4
 802b030:	20001d6c 	.word	0x20001d6c
 802b034:	20001d60 	.word	0x20001d60
 802b038:	20001978 	.word	0x20001978

0802b03c <ResetIntegration>:

void ResetIntegration()
{
 802b03c:	b480      	push	{r7}
 802b03e:	b083      	sub	sp, #12
 802b040:	af00      	add	r7, sp, #0
	for(int i = 0; i < 3; i++)
 802b042:	2300      	movs	r3, #0
 802b044:	607b      	str	r3, [r7, #4]
 802b046:	e04b      	b.n	802b0e0 <ResetIntegration+0xa4>
	{
		lastal[i] = 0;
 802b048:	4a2b      	ldr	r2, [pc, #172]	; (802b0f8 <ResetIntegration+0xbc>)
 802b04a:	687b      	ldr	r3, [r7, #4]
 802b04c:	009b      	lsls	r3, r3, #2
 802b04e:	4413      	add	r3, r2
 802b050:	f04f 0200 	mov.w	r2, #0
 802b054:	601a      	str	r2, [r3, #0]
		be[i] = 0;
 802b056:	4a29      	ldr	r2, [pc, #164]	; (802b0fc <ResetIntegration+0xc0>)
 802b058:	687b      	ldr	r3, [r7, #4]
 802b05a:	009b      	lsls	r3, r3, #2
 802b05c:	4413      	add	r3, r2
 802b05e:	f04f 0200 	mov.w	r2, #0
 802b062:	601a      	str	r2, [r3, #0]
		gam[i].t = 0;
 802b064:	4a26      	ldr	r2, [pc, #152]	; (802b100 <ResetIntegration+0xc4>)
 802b066:	687b      	ldr	r3, [r7, #4]
 802b068:	009b      	lsls	r3, r3, #2
 802b06a:	4413      	add	r3, r2
 802b06c:	f04f 0200 	mov.w	r2, #0
 802b070:	601a      	str	r2, [r3, #0]
		phi[i].t = 0;
 802b072:	4a24      	ldr	r2, [pc, #144]	; (802b104 <ResetIntegration+0xc8>)
 802b074:	687b      	ldr	r3, [r7, #4]
 802b076:	009b      	lsls	r3, r3, #2
 802b078:	4413      	add	r3, r2
 802b07a:	f04f 0200 	mov.w	r2, #0
 802b07e:	601a      	str	r2, [r3, #0]
		for(int j = 0; j < 3; j++)
 802b080:	2300      	movs	r3, #0
 802b082:	603b      	str	r3, [r7, #0]
 802b084:	e026      	b.n	802b0d4 <ResetIntegration+0x98>
		{
			al[j][i] = 0;
 802b086:	4920      	ldr	r1, [pc, #128]	; (802b108 <ResetIntegration+0xcc>)
 802b088:	683a      	ldr	r2, [r7, #0]
 802b08a:	4613      	mov	r3, r2
 802b08c:	005b      	lsls	r3, r3, #1
 802b08e:	4413      	add	r3, r2
 802b090:	687a      	ldr	r2, [r7, #4]
 802b092:	4413      	add	r3, r2
 802b094:	009b      	lsls	r3, r3, #2
 802b096:	440b      	add	r3, r1
 802b098:	f04f 0200 	mov.w	r2, #0
 802b09c:	601a      	str	r2, [r3, #0]
			bd[j][i] = 0;
 802b09e:	491b      	ldr	r1, [pc, #108]	; (802b10c <ResetIntegration+0xd0>)
 802b0a0:	683a      	ldr	r2, [r7, #0]
 802b0a2:	4613      	mov	r3, r2
 802b0a4:	005b      	lsls	r3, r3, #1
 802b0a6:	4413      	add	r3, r2
 802b0a8:	687a      	ldr	r2, [r7, #4]
 802b0aa:	4413      	add	r3, r2
 802b0ac:	009b      	lsls	r3, r3, #2
 802b0ae:	440b      	add	r3, r1
 802b0b0:	f04f 0200 	mov.w	r2, #0
 802b0b4:	601a      	str	r2, [r3, #0]
			gd[j][i] = 0;
 802b0b6:	4916      	ldr	r1, [pc, #88]	; (802b110 <ResetIntegration+0xd4>)
 802b0b8:	683a      	ldr	r2, [r7, #0]
 802b0ba:	4613      	mov	r3, r2
 802b0bc:	005b      	lsls	r3, r3, #1
 802b0be:	4413      	add	r3, r2
 802b0c0:	687a      	ldr	r2, [r7, #4]
 802b0c2:	4413      	add	r3, r2
 802b0c4:	009b      	lsls	r3, r3, #2
 802b0c6:	440b      	add	r3, r1
 802b0c8:	f04f 0200 	mov.w	r2, #0
 802b0cc:	601a      	str	r2, [r3, #0]
		for(int j = 0; j < 3; j++)
 802b0ce:	683b      	ldr	r3, [r7, #0]
 802b0d0:	3301      	adds	r3, #1
 802b0d2:	603b      	str	r3, [r7, #0]
 802b0d4:	683b      	ldr	r3, [r7, #0]
 802b0d6:	2b02      	cmp	r3, #2
 802b0d8:	ddd5      	ble.n	802b086 <ResetIntegration+0x4a>
	for(int i = 0; i < 3; i++)
 802b0da:	687b      	ldr	r3, [r7, #4]
 802b0dc:	3301      	adds	r3, #1
 802b0de:	607b      	str	r3, [r7, #4]
 802b0e0:	687b      	ldr	r3, [r7, #4]
 802b0e2:	2b02      	cmp	r3, #2
 802b0e4:	ddb0      	ble.n	802b048 <ResetIntegration+0xc>
		}
	}
	sets=0;
 802b0e6:	4b0b      	ldr	r3, [pc, #44]	; (802b114 <ResetIntegration+0xd8>)
 802b0e8:	2200      	movs	r2, #0
 802b0ea:	601a      	str	r2, [r3, #0]
}
 802b0ec:	bf00      	nop
 802b0ee:	370c      	adds	r7, #12
 802b0f0:	46bd      	mov	sp, r7
 802b0f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b0f6:	4770      	bx	lr
 802b0f8:	200019c8 	.word	0x200019c8
 802b0fc:	200019f8 	.word	0x200019f8
 802b100:	20001d6c 	.word	0x20001d6c
 802b104:	20001d60 	.word	0x20001d60
 802b108:	20001980 	.word	0x20001980
 802b10c:	200019d4 	.word	0x200019d4
 802b110:	200019a4 	.word	0x200019a4
 802b114:	20001a08 	.word	0x20001a08

0802b118 <MX_TIM4_Init>:
//PWM configuration (stm32f4xx_hal_msp.c defines Port and Pin)
//Variable for changing PWM frequency
//GPIO B6
//1.Prescaler 2.Period 3.Pulse
void MX_TIM4_Init(void)
{
 802b118:	b580      	push	{r7, lr}
 802b11a:	b08e      	sub	sp, #56	; 0x38
 802b11c:	af00      	add	r7, sp, #0
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 802b11e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 802b122:	2200      	movs	r2, #0
 802b124:	601a      	str	r2, [r3, #0]
 802b126:	605a      	str	r2, [r3, #4]
 802b128:	609a      	str	r2, [r3, #8]
 802b12a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 802b12c:	f107 0320 	add.w	r3, r7, #32
 802b130:	2200      	movs	r2, #0
 802b132:	601a      	str	r2, [r3, #0]
 802b134:	605a      	str	r2, [r3, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 802b136:	1d3b      	adds	r3, r7, #4
 802b138:	2200      	movs	r2, #0
 802b13a:	601a      	str	r2, [r3, #0]
 802b13c:	605a      	str	r2, [r3, #4]
 802b13e:	609a      	str	r2, [r3, #8]
 802b140:	60da      	str	r2, [r3, #12]
 802b142:	611a      	str	r2, [r3, #16]
 802b144:	615a      	str	r2, [r3, #20]
 802b146:	619a      	str	r2, [r3, #24]
  htim4.Instance = TIM4;
 802b148:	4b2c      	ldr	r3, [pc, #176]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b14a:	4a2d      	ldr	r2, [pc, #180]	; (802b200 <MX_TIM4_Init+0xe8>)
 802b14c:	601a      	str	r2, [r3, #0]
  htim4.Init.Prescaler = 52499;
 802b14e:	4b2b      	ldr	r3, [pc, #172]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b150:	f64c 5213 	movw	r2, #52499	; 0xcd13
 802b154:	605a      	str	r2, [r3, #4]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 802b156:	4b29      	ldr	r3, [pc, #164]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b158:	2200      	movs	r2, #0
 802b15a:	609a      	str	r2, [r3, #8]
  htim4.Init.Period = 1;
 802b15c:	4b27      	ldr	r3, [pc, #156]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b15e:	2201      	movs	r2, #1
 802b160:	60da      	str	r2, [r3, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 802b162:	4b26      	ldr	r3, [pc, #152]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b164:	2200      	movs	r2, #0
 802b166:	611a      	str	r2, [r3, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 802b168:	4b24      	ldr	r3, [pc, #144]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b16a:	2200      	movs	r2, #0
 802b16c:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 802b16e:	4823      	ldr	r0, [pc, #140]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b170:	f003 f814 	bl	802e19c <HAL_TIM_Base_Init>
 802b174:	4603      	mov	r3, r0
 802b176:	2b00      	cmp	r3, #0
 802b178:	d001      	beq.n	802b17e <MX_TIM4_Init+0x66>
  {
    Error_Handler();
 802b17a:	f7ff fabb 	bl	802a6f4 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 802b17e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 802b182:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 802b184:	f107 0328 	add.w	r3, r7, #40	; 0x28
 802b188:	4619      	mov	r1, r3
 802b18a:	481c      	ldr	r0, [pc, #112]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b18c:	f003 f9aa 	bl	802e4e4 <HAL_TIM_ConfigClockSource>
 802b190:	4603      	mov	r3, r0
 802b192:	2b00      	cmp	r3, #0
 802b194:	d001      	beq.n	802b19a <MX_TIM4_Init+0x82>
  {
    Error_Handler();
 802b196:	f7ff faad 	bl	802a6f4 <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 802b19a:	4818      	ldr	r0, [pc, #96]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b19c:	f003 f829 	bl	802e1f2 <HAL_TIM_PWM_Init>
 802b1a0:	4603      	mov	r3, r0
 802b1a2:	2b00      	cmp	r3, #0
 802b1a4:	d001      	beq.n	802b1aa <MX_TIM4_Init+0x92>
  {
    Error_Handler();
 802b1a6:	f7ff faa5 	bl	802a6f4 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 802b1aa:	2300      	movs	r3, #0
 802b1ac:	623b      	str	r3, [r7, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 802b1ae:	2300      	movs	r3, #0
 802b1b0:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 802b1b2:	f107 0320 	add.w	r3, r7, #32
 802b1b6:	4619      	mov	r1, r3
 802b1b8:	4810      	ldr	r0, [pc, #64]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b1ba:	f003 fd17 	bl	802ebec <HAL_TIMEx_MasterConfigSynchronization>
 802b1be:	4603      	mov	r3, r0
 802b1c0:	2b00      	cmp	r3, #0
 802b1c2:	d001      	beq.n	802b1c8 <MX_TIM4_Init+0xb0>
  {
    Error_Handler();
 802b1c4:	f7ff fa96 	bl	802a6f4 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 802b1c8:	2360      	movs	r3, #96	; 0x60
 802b1ca:	607b      	str	r3, [r7, #4]
  sConfigOC.Pulse = 1;
 802b1cc:	2301      	movs	r3, #1
 802b1ce:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 802b1d0:	2300      	movs	r3, #0
 802b1d2:	60fb      	str	r3, [r7, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 802b1d4:	2304      	movs	r3, #4
 802b1d6:	617b      	str	r3, [r7, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 802b1d8:	1d3b      	adds	r3, r7, #4
 802b1da:	2200      	movs	r2, #0
 802b1dc:	4619      	mov	r1, r3
 802b1de:	4807      	ldr	r0, [pc, #28]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b1e0:	f003 f8ba 	bl	802e358 <HAL_TIM_PWM_ConfigChannel>
 802b1e4:	4603      	mov	r3, r0
 802b1e6:	2b00      	cmp	r3, #0
 802b1e8:	d001      	beq.n	802b1ee <MX_TIM4_Init+0xd6>
  {
    Error_Handler();
 802b1ea:	f7ff fa83 	bl	802a6f4 <Error_Handler>
  }
  HAL_TIM_MspPostInit(&htim4);
 802b1ee:	4803      	ldr	r0, [pc, #12]	; (802b1fc <MX_TIM4_Init+0xe4>)
 802b1f0:	f000 f942 	bl	802b478 <HAL_TIM_MspPostInit>

}
 802b1f4:	bf00      	nop
 802b1f6:	3738      	adds	r7, #56	; 0x38
 802b1f8:	46bd      	mov	sp, r7
 802b1fa:	bd80      	pop	{r7, pc}
 802b1fc:	20001a40 	.word	0x20001a40
 802b200:	40000800 	.word	0x40000800

0802b204 <MX_SPI1_Init>:
   *PA5     ------> SPI1_SCK
   *PA6     ------> SPI1_MISO
   *PA7     ------> SPI1_MOSI
   */
void MX_SPI1_Init(void)
{
 802b204:	b580      	push	{r7, lr}
 802b206:	af00      	add	r7, sp, #0
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 802b208:	4b18      	ldr	r3, [pc, #96]	; (802b26c <MX_SPI1_Init+0x68>)
 802b20a:	4a19      	ldr	r2, [pc, #100]	; (802b270 <MX_SPI1_Init+0x6c>)
 802b20c:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 802b20e:	4b17      	ldr	r3, [pc, #92]	; (802b26c <MX_SPI1_Init+0x68>)
 802b210:	f44f 7282 	mov.w	r2, #260	; 0x104
 802b214:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 802b216:	4b15      	ldr	r3, [pc, #84]	; (802b26c <MX_SPI1_Init+0x68>)
 802b218:	2200      	movs	r2, #0
 802b21a:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_16BIT;							//SPI Mode 3 configuration
 802b21c:	4b13      	ldr	r3, [pc, #76]	; (802b26c <MX_SPI1_Init+0x68>)
 802b21e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802b222:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;						//SPI Mode 3 configuration
 802b224:	4b11      	ldr	r3, [pc, #68]	; (802b26c <MX_SPI1_Init+0x68>)
 802b226:	2202      	movs	r2, #2
 802b228:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;							//SPI Mode 3 configuration
 802b22a:	4b10      	ldr	r3, [pc, #64]	; (802b26c <MX_SPI1_Init+0x68>)
 802b22c:	2201      	movs	r2, #1
 802b22e:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 802b230:	4b0e      	ldr	r3, [pc, #56]	; (802b26c <MX_SPI1_Init+0x68>)
 802b232:	f44f 7200 	mov.w	r2, #512	; 0x200
 802b236:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;			//SPI clock rate: system clock/pre-scaler
 802b238:	4b0c      	ldr	r3, [pc, #48]	; (802b26c <MX_SPI1_Init+0x68>)
 802b23a:	2218      	movs	r2, #24
 802b23c:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 802b23e:	4b0b      	ldr	r3, [pc, #44]	; (802b26c <MX_SPI1_Init+0x68>)
 802b240:	2200      	movs	r2, #0
 802b242:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 802b244:	4b09      	ldr	r3, [pc, #36]	; (802b26c <MX_SPI1_Init+0x68>)
 802b246:	2200      	movs	r2, #0
 802b248:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802b24a:	4b08      	ldr	r3, [pc, #32]	; (802b26c <MX_SPI1_Init+0x68>)
 802b24c:	2200      	movs	r2, #0
 802b24e:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 802b250:	4b06      	ldr	r3, [pc, #24]	; (802b26c <MX_SPI1_Init+0x68>)
 802b252:	220a      	movs	r2, #10
 802b254:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 802b256:	4805      	ldr	r0, [pc, #20]	; (802b26c <MX_SPI1_Init+0x68>)
 802b258:	f002 f920 	bl	802d49c <HAL_SPI_Init>
 802b25c:	4603      	mov	r3, r0
 802b25e:	2b00      	cmp	r3, #0
 802b260:	d001      	beq.n	802b266 <MX_SPI1_Init+0x62>
  {
    Error_Handler();
 802b262:	f7ff fa47 	bl	802a6f4 <Error_Handler>
  }
}
 802b266:	bf00      	nop
 802b268:	bd80      	pop	{r7, pc}
 802b26a:	bf00      	nop
 802b26c:	20001bc0 	.word	0x20001bc0
 802b270:	40013000 	.word	0x40013000

0802b274 <MX_SPI1_Init_8BIT>:

void MX_SPI1_Init_8BIT(void)
{
 802b274:	b580      	push	{r7, lr}
 802b276:	af00      	add	r7, sp, #0
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 802b278:	4b17      	ldr	r3, [pc, #92]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b27a:	4a18      	ldr	r2, [pc, #96]	; (802b2dc <MX_SPI1_Init_8BIT+0x68>)
 802b27c:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 802b27e:	4b16      	ldr	r3, [pc, #88]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b280:	f44f 7282 	mov.w	r2, #260	; 0x104
 802b284:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 802b286:	4b14      	ldr	r3, [pc, #80]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b288:	2200      	movs	r2, #0
 802b28a:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 802b28c:	4b12      	ldr	r3, [pc, #72]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b28e:	2200      	movs	r2, #0
 802b290:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;						//SPI Mode 3 configuration for LSM6DSL SPI requirement
 802b292:	4b11      	ldr	r3, [pc, #68]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b294:	2202      	movs	r2, #2
 802b296:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;							//SPI Mode 3 configuration for LSM6DSL SPI requirement
 802b298:	4b0f      	ldr	r3, [pc, #60]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b29a:	2201      	movs	r2, #1
 802b29c:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 802b29e:	4b0e      	ldr	r3, [pc, #56]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2a0:	f44f 7200 	mov.w	r2, #512	; 0x200
 802b2a4:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;			//SPI clock rate: system clock/pre-scaler
 802b2a6:	4b0c      	ldr	r3, [pc, #48]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2a8:	2218      	movs	r2, #24
 802b2aa:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 802b2ac:	4b0a      	ldr	r3, [pc, #40]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2ae:	2200      	movs	r2, #0
 802b2b0:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 802b2b2:	4b09      	ldr	r3, [pc, #36]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2b4:	2200      	movs	r2, #0
 802b2b6:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802b2b8:	4b07      	ldr	r3, [pc, #28]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2ba:	2200      	movs	r2, #0
 802b2bc:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 802b2be:	4b06      	ldr	r3, [pc, #24]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2c0:	220a      	movs	r2, #10
 802b2c2:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 802b2c4:	4804      	ldr	r0, [pc, #16]	; (802b2d8 <MX_SPI1_Init_8BIT+0x64>)
 802b2c6:	f002 f8e9 	bl	802d49c <HAL_SPI_Init>
 802b2ca:	4603      	mov	r3, r0
 802b2cc:	2b00      	cmp	r3, #0
 802b2ce:	d001      	beq.n	802b2d4 <MX_SPI1_Init_8BIT+0x60>
  {
    Error_Handler();
 802b2d0:	f7ff fa10 	bl	802a6f4 <Error_Handler>
  }
}
 802b2d4:	bf00      	nop
 802b2d6:	bd80      	pop	{r7, pc}
 802b2d8:	20001bc0 	.word	0x20001bc0
 802b2dc:	40013000 	.word	0x40013000

0802b2e0 <spi_DMA_RX>:

//SPI DMA function
//Input : tx/rx data address, Port and Pin for CS and byte to transmit and receive
//Output: None
void spi_DMA_RX(uint8_t *txdata, uint8_t *rxdata,GPIO_TypeDef* Port, uint16_t Pin, int byteNumber)
{
 802b2e0:	b580      	push	{r7, lr}
 802b2e2:	b084      	sub	sp, #16
 802b2e4:	af00      	add	r7, sp, #0
 802b2e6:	60f8      	str	r0, [r7, #12]
 802b2e8:	60b9      	str	r1, [r7, #8]
 802b2ea:	607a      	str	r2, [r7, #4]
 802b2ec:	807b      	strh	r3, [r7, #2]
	 HAL_SPI_DMAResume(&hspi1);
 802b2ee:	480a      	ldr	r0, [pc, #40]	; (802b318 <spi_DMA_RX+0x38>)
 802b2f0:	f002 fd32 	bl	802dd58 <HAL_SPI_DMAResume>
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET );
 802b2f4:	887b      	ldrh	r3, [r7, #2]
 802b2f6:	2200      	movs	r2, #0
 802b2f8:	4619      	mov	r1, r3
 802b2fa:	6878      	ldr	r0, [r7, #4]
 802b2fc:	f001 fc52 	bl	802cba4 <HAL_GPIO_WritePin>
	 HAL_SPI_TransmitReceive_DMA( &hspi1, txdata, (uint8_t*)rxdata, byteNumber);
 802b300:	69bb      	ldr	r3, [r7, #24]
 802b302:	b29b      	uxth	r3, r3
 802b304:	68ba      	ldr	r2, [r7, #8]
 802b306:	68f9      	ldr	r1, [r7, #12]
 802b308:	4803      	ldr	r0, [pc, #12]	; (802b318 <spi_DMA_RX+0x38>)
 802b30a:	f002 fc01 	bl	802db10 <HAL_SPI_TransmitReceive_DMA>
}
 802b30e:	bf00      	nop
 802b310:	3710      	adds	r7, #16
 802b312:	46bd      	mov	sp, r7
 802b314:	bd80      	pop	{r7, pc}
 802b316:	bf00      	nop
 802b318:	20001bc0 	.word	0x20001bc0

0802b31c <spi_RX>:

//SPI polling code, one byte per transmission
//Better use with 16 bits clock cycle confirguation
void spi_RX(uint16_t *txdata, uint8_t *rxdata,GPIO_TypeDef* Port, uint16_t Pin)
{
 802b31c:	b580      	push	{r7, lr}
 802b31e:	b086      	sub	sp, #24
 802b320:	af02      	add	r7, sp, #8
 802b322:	60f8      	str	r0, [r7, #12]
 802b324:	60b9      	str	r1, [r7, #8]
 802b326:	607a      	str	r2, [r7, #4]
 802b328:	807b      	strh	r3, [r7, #2]
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET );
 802b32a:	887b      	ldrh	r3, [r7, #2]
 802b32c:	2200      	movs	r2, #0
 802b32e:	4619      	mov	r1, r3
 802b330:	6878      	ldr	r0, [r7, #4]
 802b332:	f001 fc37 	bl	802cba4 <HAL_GPIO_WritePin>
	 HAL_SPI_TransmitReceive( &hspi1, (uint8_t*)txdata, rxdata, 1, 100);
 802b336:	2364      	movs	r3, #100	; 0x64
 802b338:	9300      	str	r3, [sp, #0]
 802b33a:	2301      	movs	r3, #1
 802b33c:	68ba      	ldr	r2, [r7, #8]
 802b33e:	68f9      	ldr	r1, [r7, #12]
 802b340:	4809      	ldr	r0, [pc, #36]	; (802b368 <spi_RX+0x4c>)
 802b342:	f002 fa43 	bl	802d7cc <HAL_SPI_TransmitReceive>
	 while( hspi1.State == HAL_SPI_STATE_BUSY );
 802b346:	bf00      	nop
 802b348:	4b07      	ldr	r3, [pc, #28]	; (802b368 <spi_RX+0x4c>)
 802b34a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802b34e:	b2db      	uxtb	r3, r3
 802b350:	2b02      	cmp	r3, #2
 802b352:	d0f9      	beq.n	802b348 <spi_RX+0x2c>
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_SET );
 802b354:	887b      	ldrh	r3, [r7, #2]
 802b356:	2201      	movs	r2, #1
 802b358:	4619      	mov	r1, r3
 802b35a:	6878      	ldr	r0, [r7, #4]
 802b35c:	f001 fc22 	bl	802cba4 <HAL_GPIO_WritePin>
}
 802b360:	bf00      	nop
 802b362:	3710      	adds	r7, #16
 802b364:	46bd      	mov	sp, r7
 802b366:	bd80      	pop	{r7, pc}
 802b368:	20001bc0 	.word	0x20001bc0

0802b36c <spi_write>:

//SPI write without reading it back
//Use in configuration
void spi_write(uint16_t *txadddata, GPIO_TypeDef* Port, uint16_t Pin)
{
 802b36c:	b580      	push	{r7, lr}
 802b36e:	b084      	sub	sp, #16
 802b370:	af00      	add	r7, sp, #0
 802b372:	60f8      	str	r0, [r7, #12]
 802b374:	60b9      	str	r1, [r7, #8]
 802b376:	4613      	mov	r3, r2
 802b378:	80fb      	strh	r3, [r7, #6]
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET );
 802b37a:	88fb      	ldrh	r3, [r7, #6]
 802b37c:	2200      	movs	r2, #0
 802b37e:	4619      	mov	r1, r3
 802b380:	68b8      	ldr	r0, [r7, #8]
 802b382:	f001 fc0f 	bl	802cba4 <HAL_GPIO_WritePin>
	 HAL_SPI_Transmit( &hspi1, (uint8_t*)txadddata, 1, 100);
 802b386:	2364      	movs	r3, #100	; 0x64
 802b388:	2201      	movs	r2, #1
 802b38a:	68f9      	ldr	r1, [r7, #12]
 802b38c:	4809      	ldr	r0, [pc, #36]	; (802b3b4 <spi_write+0x48>)
 802b38e:	f002 f8e9 	bl	802d564 <HAL_SPI_Transmit>
	 while( hspi1.State == HAL_SPI_STATE_BUSY );
 802b392:	bf00      	nop
 802b394:	4b07      	ldr	r3, [pc, #28]	; (802b3b4 <spi_write+0x48>)
 802b396:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802b39a:	b2db      	uxtb	r3, r3
 802b39c:	2b02      	cmp	r3, #2
 802b39e:	d0f9      	beq.n	802b394 <spi_write+0x28>
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_SET );
 802b3a0:	88fb      	ldrh	r3, [r7, #6]
 802b3a2:	2201      	movs	r2, #1
 802b3a4:	4619      	mov	r1, r3
 802b3a6:	68b8      	ldr	r0, [r7, #8]
 802b3a8:	f001 fbfc 	bl	802cba4 <HAL_GPIO_WritePin>
}
 802b3ac:	bf00      	nop
 802b3ae:	3710      	adds	r7, #16
 802b3b0:	46bd      	mov	sp, r7
 802b3b2:	bd80      	pop	{r7, pc}
 802b3b4:	20001bc0 	.word	0x20001bc0

0802b3b8 <HAL_MspInit>:
extern DMA_HandleTypeDef hdma_usart1_rx;
extern DMA_HandleTypeDef hdma_spi1_rx;
extern DMA_HandleTypeDef hdma_spi1_tx;

void HAL_MspInit(void)
{
 802b3b8:	b580      	push	{r7, lr}
 802b3ba:	b082      	sub	sp, #8
 802b3bc:	af00      	add	r7, sp, #0
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 802b3be:	2300      	movs	r3, #0
 802b3c0:	607b      	str	r3, [r7, #4]
 802b3c2:	4b10      	ldr	r3, [pc, #64]	; (802b404 <HAL_MspInit+0x4c>)
 802b3c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b3c6:	4a0f      	ldr	r2, [pc, #60]	; (802b404 <HAL_MspInit+0x4c>)
 802b3c8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802b3cc:	6453      	str	r3, [r2, #68]	; 0x44
 802b3ce:	4b0d      	ldr	r3, [pc, #52]	; (802b404 <HAL_MspInit+0x4c>)
 802b3d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b3d2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 802b3d6:	607b      	str	r3, [r7, #4]
 802b3d8:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 802b3da:	2300      	movs	r3, #0
 802b3dc:	603b      	str	r3, [r7, #0]
 802b3de:	4b09      	ldr	r3, [pc, #36]	; (802b404 <HAL_MspInit+0x4c>)
 802b3e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b3e2:	4a08      	ldr	r2, [pc, #32]	; (802b404 <HAL_MspInit+0x4c>)
 802b3e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802b3e8:	6413      	str	r3, [r2, #64]	; 0x40
 802b3ea:	4b06      	ldr	r3, [pc, #24]	; (802b404 <HAL_MspInit+0x4c>)
 802b3ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b3ee:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802b3f2:	603b      	str	r3, [r7, #0]
 802b3f4:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 802b3f6:	2007      	movs	r0, #7
 802b3f8:	f000 fe68 	bl	802c0cc <HAL_NVIC_SetPriorityGrouping>
}
 802b3fc:	bf00      	nop
 802b3fe:	3708      	adds	r7, #8
 802b400:	46bd      	mov	sp, r7
 802b402:	bd80      	pop	{r7, pc}
 802b404:	40023800 	.word	0x40023800

0802b408 <HAL_TIM_Base_MspInit>:


void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 802b408:	b480      	push	{r7}
 802b40a:	b085      	sub	sp, #20
 802b40c:	af00      	add	r7, sp, #0
 802b40e:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM3)
 802b410:	687b      	ldr	r3, [r7, #4]
 802b412:	681b      	ldr	r3, [r3, #0]
 802b414:	4a15      	ldr	r2, [pc, #84]	; (802b46c <HAL_TIM_Base_MspInit+0x64>)
 802b416:	4293      	cmp	r3, r2
 802b418:	d10e      	bne.n	802b438 <HAL_TIM_Base_MspInit+0x30>
  {
    __HAL_RCC_TIM3_CLK_ENABLE();
 802b41a:	2300      	movs	r3, #0
 802b41c:	60fb      	str	r3, [r7, #12]
 802b41e:	4b14      	ldr	r3, [pc, #80]	; (802b470 <HAL_TIM_Base_MspInit+0x68>)
 802b420:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b422:	4a13      	ldr	r2, [pc, #76]	; (802b470 <HAL_TIM_Base_MspInit+0x68>)
 802b424:	f043 0302 	orr.w	r3, r3, #2
 802b428:	6413      	str	r3, [r2, #64]	; 0x40
 802b42a:	4b11      	ldr	r3, [pc, #68]	; (802b470 <HAL_TIM_Base_MspInit+0x68>)
 802b42c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b42e:	f003 0302 	and.w	r3, r3, #2
 802b432:	60fb      	str	r3, [r7, #12]
 802b434:	68fb      	ldr	r3, [r7, #12]
  else if(htim_base->Instance==TIM4)
  {
    __HAL_RCC_TIM4_CLK_ENABLE();
  }

}
 802b436:	e012      	b.n	802b45e <HAL_TIM_Base_MspInit+0x56>
  else if(htim_base->Instance==TIM4)
 802b438:	687b      	ldr	r3, [r7, #4]
 802b43a:	681b      	ldr	r3, [r3, #0]
 802b43c:	4a0d      	ldr	r2, [pc, #52]	; (802b474 <HAL_TIM_Base_MspInit+0x6c>)
 802b43e:	4293      	cmp	r3, r2
 802b440:	d10d      	bne.n	802b45e <HAL_TIM_Base_MspInit+0x56>
    __HAL_RCC_TIM4_CLK_ENABLE();
 802b442:	2300      	movs	r3, #0
 802b444:	60bb      	str	r3, [r7, #8]
 802b446:	4b0a      	ldr	r3, [pc, #40]	; (802b470 <HAL_TIM_Base_MspInit+0x68>)
 802b448:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b44a:	4a09      	ldr	r2, [pc, #36]	; (802b470 <HAL_TIM_Base_MspInit+0x68>)
 802b44c:	f043 0304 	orr.w	r3, r3, #4
 802b450:	6413      	str	r3, [r2, #64]	; 0x40
 802b452:	4b07      	ldr	r3, [pc, #28]	; (802b470 <HAL_TIM_Base_MspInit+0x68>)
 802b454:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b456:	f003 0304 	and.w	r3, r3, #4
 802b45a:	60bb      	str	r3, [r7, #8]
 802b45c:	68bb      	ldr	r3, [r7, #8]
}
 802b45e:	bf00      	nop
 802b460:	3714      	adds	r7, #20
 802b462:	46bd      	mov	sp, r7
 802b464:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b468:	4770      	bx	lr
 802b46a:	bf00      	nop
 802b46c:	40000400 	.word	0x40000400
 802b470:	40023800 	.word	0x40023800
 802b474:	40000800 	.word	0x40000800

0802b478 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 802b478:	b580      	push	{r7, lr}
 802b47a:	b08a      	sub	sp, #40	; 0x28
 802b47c:	af00      	add	r7, sp, #0
 802b47e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802b480:	f107 0314 	add.w	r3, r7, #20
 802b484:	2200      	movs	r2, #0
 802b486:	601a      	str	r2, [r3, #0]
 802b488:	605a      	str	r2, [r3, #4]
 802b48a:	609a      	str	r2, [r3, #8]
 802b48c:	60da      	str	r2, [r3, #12]
 802b48e:	611a      	str	r2, [r3, #16]
  if(htim->Instance==TIM3)
 802b490:	687b      	ldr	r3, [r7, #4]
 802b492:	681b      	ldr	r3, [r3, #0]
 802b494:	4a24      	ldr	r2, [pc, #144]	; (802b528 <HAL_TIM_MspPostInit+0xb0>)
 802b496:	4293      	cmp	r3, r2
 802b498:	d11e      	bne.n	802b4d8 <HAL_TIM_MspPostInit+0x60>
  {
    __HAL_RCC_GPIOC_CLK_ENABLE();
 802b49a:	2300      	movs	r3, #0
 802b49c:	613b      	str	r3, [r7, #16]
 802b49e:	4b23      	ldr	r3, [pc, #140]	; (802b52c <HAL_TIM_MspPostInit+0xb4>)
 802b4a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b4a2:	4a22      	ldr	r2, [pc, #136]	; (802b52c <HAL_TIM_MspPostInit+0xb4>)
 802b4a4:	f043 0304 	orr.w	r3, r3, #4
 802b4a8:	6313      	str	r3, [r2, #48]	; 0x30
 802b4aa:	4b20      	ldr	r3, [pc, #128]	; (802b52c <HAL_TIM_MspPostInit+0xb4>)
 802b4ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b4ae:	f003 0304 	and.w	r3, r3, #4
 802b4b2:	613b      	str	r3, [r7, #16]
 802b4b4:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 802b4b6:	2340      	movs	r3, #64	; 0x40
 802b4b8:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802b4ba:	2302      	movs	r3, #2
 802b4bc:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802b4be:	2300      	movs	r3, #0
 802b4c0:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802b4c2:	2300      	movs	r3, #0
 802b4c4:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 802b4c6:	2302      	movs	r3, #2
 802b4c8:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 802b4ca:	f107 0314 	add.w	r3, r7, #20
 802b4ce:	4619      	mov	r1, r3
 802b4d0:	4817      	ldr	r0, [pc, #92]	; (802b530 <HAL_TIM_MspPostInit+0xb8>)
 802b4d2:	f001 f9cd 	bl	802c870 <HAL_GPIO_Init>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  }

}
 802b4d6:	e022      	b.n	802b51e <HAL_TIM_MspPostInit+0xa6>
  else if(htim->Instance==TIM4)
 802b4d8:	687b      	ldr	r3, [r7, #4]
 802b4da:	681b      	ldr	r3, [r3, #0]
 802b4dc:	4a15      	ldr	r2, [pc, #84]	; (802b534 <HAL_TIM_MspPostInit+0xbc>)
 802b4de:	4293      	cmp	r3, r2
 802b4e0:	d11d      	bne.n	802b51e <HAL_TIM_MspPostInit+0xa6>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 802b4e2:	2300      	movs	r3, #0
 802b4e4:	60fb      	str	r3, [r7, #12]
 802b4e6:	4b11      	ldr	r3, [pc, #68]	; (802b52c <HAL_TIM_MspPostInit+0xb4>)
 802b4e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b4ea:	4a10      	ldr	r2, [pc, #64]	; (802b52c <HAL_TIM_MspPostInit+0xb4>)
 802b4ec:	f043 0302 	orr.w	r3, r3, #2
 802b4f0:	6313      	str	r3, [r2, #48]	; 0x30
 802b4f2:	4b0e      	ldr	r3, [pc, #56]	; (802b52c <HAL_TIM_MspPostInit+0xb4>)
 802b4f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b4f6:	f003 0302 	and.w	r3, r3, #2
 802b4fa:	60fb      	str	r3, [r7, #12]
 802b4fc:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 802b4fe:	2340      	movs	r3, #64	; 0x40
 802b500:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802b502:	2302      	movs	r3, #2
 802b504:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802b506:	2300      	movs	r3, #0
 802b508:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802b50a:	2300      	movs	r3, #0
 802b50c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 802b50e:	2302      	movs	r3, #2
 802b510:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 802b512:	f107 0314 	add.w	r3, r7, #20
 802b516:	4619      	mov	r1, r3
 802b518:	4807      	ldr	r0, [pc, #28]	; (802b538 <HAL_TIM_MspPostInit+0xc0>)
 802b51a:	f001 f9a9 	bl	802c870 <HAL_GPIO_Init>
}
 802b51e:	bf00      	nop
 802b520:	3728      	adds	r7, #40	; 0x28
 802b522:	46bd      	mov	sp, r7
 802b524:	bd80      	pop	{r7, pc}
 802b526:	bf00      	nop
 802b528:	40000400 	.word	0x40000400
 802b52c:	40023800 	.word	0x40023800
 802b530:	40020800 	.word	0x40020800
 802b534:	40000800 	.word	0x40000800
 802b538:	40020400 	.word	0x40020400

0802b53c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 802b53c:	b580      	push	{r7, lr}
 802b53e:	b08c      	sub	sp, #48	; 0x30
 802b540:	af00      	add	r7, sp, #0
 802b542:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802b544:	f107 031c 	add.w	r3, r7, #28
 802b548:	2200      	movs	r2, #0
 802b54a:	601a      	str	r2, [r3, #0]
 802b54c:	605a      	str	r2, [r3, #4]
 802b54e:	609a      	str	r2, [r3, #8]
 802b550:	60da      	str	r2, [r3, #12]
 802b552:	611a      	str	r2, [r3, #16]
  if(huart->Instance==USART1)
 802b554:	687b      	ldr	r3, [r7, #4]
 802b556:	681b      	ldr	r3, [r3, #0]
 802b558:	4a66      	ldr	r2, [pc, #408]	; (802b6f4 <HAL_UART_MspInit+0x1b8>)
 802b55a:	4293      	cmp	r3, r2
 802b55c:	f040 8094 	bne.w	802b688 <HAL_UART_MspInit+0x14c>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 802b560:	2300      	movs	r3, #0
 802b562:	61bb      	str	r3, [r7, #24]
 802b564:	4b64      	ldr	r3, [pc, #400]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b566:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b568:	4a63      	ldr	r2, [pc, #396]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b56a:	f043 0310 	orr.w	r3, r3, #16
 802b56e:	6453      	str	r3, [r2, #68]	; 0x44
 802b570:	4b61      	ldr	r3, [pc, #388]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b572:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b574:	f003 0310 	and.w	r3, r3, #16
 802b578:	61bb      	str	r3, [r7, #24]
 802b57a:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 802b57c:	2300      	movs	r3, #0
 802b57e:	617b      	str	r3, [r7, #20]
 802b580:	4b5d      	ldr	r3, [pc, #372]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b582:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b584:	4a5c      	ldr	r2, [pc, #368]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b586:	f043 0301 	orr.w	r3, r3, #1
 802b58a:	6313      	str	r3, [r2, #48]	; 0x30
 802b58c:	4b5a      	ldr	r3, [pc, #360]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b58e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b590:	f003 0301 	and.w	r3, r3, #1
 802b594:	617b      	str	r3, [r7, #20]
 802b596:	697b      	ldr	r3, [r7, #20]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 802b598:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 802b59c:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802b59e:	2302      	movs	r3, #2
 802b5a0:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802b5a2:	2300      	movs	r3, #0
 802b5a4:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802b5a6:	2303      	movs	r3, #3
 802b5a8:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 802b5aa:	2307      	movs	r3, #7
 802b5ac:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802b5ae:	f107 031c 	add.w	r3, r7, #28
 802b5b2:	4619      	mov	r1, r3
 802b5b4:	4851      	ldr	r0, [pc, #324]	; (802b6fc <HAL_UART_MspInit+0x1c0>)
 802b5b6:	f001 f95b 	bl	802c870 <HAL_GPIO_Init>

    /* USART1 DMA Init */
    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
 802b5ba:	4b51      	ldr	r3, [pc, #324]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5bc:	4a51      	ldr	r2, [pc, #324]	; (802b704 <HAL_UART_MspInit+0x1c8>)
 802b5be:	601a      	str	r2, [r3, #0]
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
 802b5c0:	4b4f      	ldr	r3, [pc, #316]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5c2:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802b5c6:	605a      	str	r2, [r3, #4]
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802b5c8:	4b4d      	ldr	r3, [pc, #308]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5ca:	2240      	movs	r2, #64	; 0x40
 802b5cc:	609a      	str	r2, [r3, #8]
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802b5ce:	4b4c      	ldr	r3, [pc, #304]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5d0:	2200      	movs	r2, #0
 802b5d2:	60da      	str	r2, [r3, #12]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 802b5d4:	4b4a      	ldr	r3, [pc, #296]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5d6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802b5da:	611a      	str	r2, [r3, #16]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802b5dc:	4b48      	ldr	r3, [pc, #288]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5de:	2200      	movs	r2, #0
 802b5e0:	615a      	str	r2, [r3, #20]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 802b5e2:	4b47      	ldr	r3, [pc, #284]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5e4:	2200      	movs	r2, #0
 802b5e6:	619a      	str	r2, [r3, #24]
    hdma_usart1_tx.Init.Mode = DMA_CIRCULAR;
 802b5e8:	4b45      	ldr	r3, [pc, #276]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5ea:	f44f 7280 	mov.w	r2, #256	; 0x100
 802b5ee:	61da      	str	r2, [r3, #28]
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
 802b5f0:	4b43      	ldr	r3, [pc, #268]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5f2:	2200      	movs	r2, #0
 802b5f4:	621a      	str	r2, [r3, #32]
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802b5f6:	4b42      	ldr	r3, [pc, #264]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5f8:	2200      	movs	r2, #0
 802b5fa:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 802b5fc:	4840      	ldr	r0, [pc, #256]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b5fe:	f000 fda7 	bl	802c150 <HAL_DMA_Init>
 802b602:	4603      	mov	r3, r0
 802b604:	2b00      	cmp	r3, #0
 802b606:	d001      	beq.n	802b60c <HAL_UART_MspInit+0xd0>
    {
      Error_Handler();
 802b608:	f7ff f874 	bl	802a6f4 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx);
 802b60c:	687b      	ldr	r3, [r7, #4]
 802b60e:	4a3c      	ldr	r2, [pc, #240]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b610:	631a      	str	r2, [r3, #48]	; 0x30
 802b612:	4a3b      	ldr	r2, [pc, #236]	; (802b700 <HAL_UART_MspInit+0x1c4>)
 802b614:	687b      	ldr	r3, [r7, #4]
 802b616:	6393      	str	r3, [r2, #56]	; 0x38

    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
 802b618:	4b3b      	ldr	r3, [pc, #236]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b61a:	4a3c      	ldr	r2, [pc, #240]	; (802b70c <HAL_UART_MspInit+0x1d0>)
 802b61c:	601a      	str	r2, [r3, #0]
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 802b61e:	4b3a      	ldr	r3, [pc, #232]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b620:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802b624:	605a      	str	r2, [r3, #4]
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 802b626:	4b38      	ldr	r3, [pc, #224]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b628:	2200      	movs	r2, #0
 802b62a:	609a      	str	r2, [r3, #8]
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 802b62c:	4b36      	ldr	r3, [pc, #216]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b62e:	2200      	movs	r2, #0
 802b630:	60da      	str	r2, [r3, #12]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 802b632:	4b35      	ldr	r3, [pc, #212]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b634:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802b638:	611a      	str	r2, [r3, #16]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802b63a:	4b33      	ldr	r3, [pc, #204]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b63c:	2200      	movs	r2, #0
 802b63e:	615a      	str	r2, [r3, #20]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 802b640:	4b31      	ldr	r3, [pc, #196]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b642:	2200      	movs	r2, #0
 802b644:	619a      	str	r2, [r3, #24]
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR; ///
 802b646:	4b30      	ldr	r3, [pc, #192]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b648:	f44f 7280 	mov.w	r2, #256	; 0x100
 802b64c:	61da      	str	r2, [r3, #28]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
 802b64e:	4b2e      	ldr	r3, [pc, #184]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b650:	2200      	movs	r2, #0
 802b652:	621a      	str	r2, [r3, #32]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802b654:	4b2c      	ldr	r3, [pc, #176]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b656:	2200      	movs	r2, #0
 802b658:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 802b65a:	482b      	ldr	r0, [pc, #172]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b65c:	f000 fd78 	bl	802c150 <HAL_DMA_Init>
 802b660:	4603      	mov	r3, r0
 802b662:	2b00      	cmp	r3, #0
 802b664:	d001      	beq.n	802b66a <HAL_UART_MspInit+0x12e>
    {
      Error_Handler();
 802b666:	f7ff f845 	bl	802a6f4 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmarx,hdma_usart1_rx);
 802b66a:	687b      	ldr	r3, [r7, #4]
 802b66c:	4a26      	ldr	r2, [pc, #152]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b66e:	635a      	str	r2, [r3, #52]	; 0x34
 802b670:	4a25      	ldr	r2, [pc, #148]	; (802b708 <HAL_UART_MspInit+0x1cc>)
 802b672:	687b      	ldr	r3, [r7, #4]
 802b674:	6393      	str	r3, [r2, #56]	; 0x38

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 802b676:	2200      	movs	r2, #0
 802b678:	2100      	movs	r1, #0
 802b67a:	2025      	movs	r0, #37	; 0x25
 802b67c:	f000 fd31 	bl	802c0e2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 802b680:	2025      	movs	r0, #37	; 0x25
 802b682:	f000 fd4a 	bl	802c11a <HAL_NVIC_EnableIRQ>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  }

}
 802b686:	e030      	b.n	802b6ea <HAL_UART_MspInit+0x1ae>
  else if(huart->Instance==USART2)
 802b688:	687b      	ldr	r3, [r7, #4]
 802b68a:	681b      	ldr	r3, [r3, #0]
 802b68c:	4a20      	ldr	r2, [pc, #128]	; (802b710 <HAL_UART_MspInit+0x1d4>)
 802b68e:	4293      	cmp	r3, r2
 802b690:	d12b      	bne.n	802b6ea <HAL_UART_MspInit+0x1ae>
    __HAL_RCC_USART2_CLK_ENABLE();
 802b692:	2300      	movs	r3, #0
 802b694:	613b      	str	r3, [r7, #16]
 802b696:	4b18      	ldr	r3, [pc, #96]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b698:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b69a:	4a17      	ldr	r2, [pc, #92]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b69c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802b6a0:	6413      	str	r3, [r2, #64]	; 0x40
 802b6a2:	4b15      	ldr	r3, [pc, #84]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b6a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b6a6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802b6aa:	613b      	str	r3, [r7, #16]
 802b6ac:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 802b6ae:	2300      	movs	r3, #0
 802b6b0:	60fb      	str	r3, [r7, #12]
 802b6b2:	4b11      	ldr	r3, [pc, #68]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b6b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b6b6:	4a10      	ldr	r2, [pc, #64]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b6b8:	f043 0301 	orr.w	r3, r3, #1
 802b6bc:	6313      	str	r3, [r2, #48]	; 0x30
 802b6be:	4b0e      	ldr	r3, [pc, #56]	; (802b6f8 <HAL_UART_MspInit+0x1bc>)
 802b6c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b6c2:	f003 0301 	and.w	r3, r3, #1
 802b6c6:	60fb      	str	r3, [r7, #12]
 802b6c8:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 802b6ca:	230c      	movs	r3, #12
 802b6cc:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802b6ce:	2302      	movs	r3, #2
 802b6d0:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802b6d2:	2300      	movs	r3, #0
 802b6d4:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802b6d6:	2300      	movs	r3, #0
 802b6d8:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802b6da:	2307      	movs	r3, #7
 802b6dc:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802b6de:	f107 031c 	add.w	r3, r7, #28
 802b6e2:	4619      	mov	r1, r3
 802b6e4:	4805      	ldr	r0, [pc, #20]	; (802b6fc <HAL_UART_MspInit+0x1c0>)
 802b6e6:	f001 f8c3 	bl	802c870 <HAL_GPIO_Init>
}
 802b6ea:	bf00      	nop
 802b6ec:	3730      	adds	r7, #48	; 0x30
 802b6ee:	46bd      	mov	sp, r7
 802b6f0:	bd80      	pop	{r7, pc}
 802b6f2:	bf00      	nop
 802b6f4:	40011000 	.word	0x40011000
 802b6f8:	40023800 	.word	0x40023800
 802b6fc:	40020000 	.word	0x40020000
 802b700:	20001ac0 	.word	0x20001ac0
 802b704:	400264b8 	.word	0x400264b8
 802b708:	20001b20 	.word	0x20001b20
 802b70c:	40026440 	.word	0x40026440
 802b710:	40004400 	.word	0x40004400

0802b714 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 802b714:	b580      	push	{r7, lr}
 802b716:	b08a      	sub	sp, #40	; 0x28
 802b718:	af00      	add	r7, sp, #0
 802b71a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802b71c:	f107 0314 	add.w	r3, r7, #20
 802b720:	2200      	movs	r2, #0
 802b722:	601a      	str	r2, [r3, #0]
 802b724:	605a      	str	r2, [r3, #4]
 802b726:	609a      	str	r2, [r3, #8]
 802b728:	60da      	str	r2, [r3, #12]
 802b72a:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 802b72c:	687b      	ldr	r3, [r7, #4]
 802b72e:	681b      	ldr	r3, [r3, #0]
 802b730:	4a4a      	ldr	r2, [pc, #296]	; (802b85c <HAL_SPI_MspInit+0x148>)
 802b732:	4293      	cmp	r3, r2
 802b734:	f040 808e 	bne.w	802b854 <HAL_SPI_MspInit+0x140>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 802b738:	2300      	movs	r3, #0
 802b73a:	613b      	str	r3, [r7, #16]
 802b73c:	4b48      	ldr	r3, [pc, #288]	; (802b860 <HAL_SPI_MspInit+0x14c>)
 802b73e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b740:	4a47      	ldr	r2, [pc, #284]	; (802b860 <HAL_SPI_MspInit+0x14c>)
 802b742:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802b746:	6453      	str	r3, [r2, #68]	; 0x44
 802b748:	4b45      	ldr	r3, [pc, #276]	; (802b860 <HAL_SPI_MspInit+0x14c>)
 802b74a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b74c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 802b750:	613b      	str	r3, [r7, #16]
 802b752:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 802b754:	2300      	movs	r3, #0
 802b756:	60fb      	str	r3, [r7, #12]
 802b758:	4b41      	ldr	r3, [pc, #260]	; (802b860 <HAL_SPI_MspInit+0x14c>)
 802b75a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b75c:	4a40      	ldr	r2, [pc, #256]	; (802b860 <HAL_SPI_MspInit+0x14c>)
 802b75e:	f043 0301 	orr.w	r3, r3, #1
 802b762:	6313      	str	r3, [r2, #48]	; 0x30
 802b764:	4b3e      	ldr	r3, [pc, #248]	; (802b860 <HAL_SPI_MspInit+0x14c>)
 802b766:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b768:	f003 0301 	and.w	r3, r3, #1
 802b76c:	60fb      	str	r3, [r7, #12]
 802b76e:	68fb      	ldr	r3, [r7, #12]
    PA4     ------> SPI1_NSS
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 802b770:	23f0      	movs	r3, #240	; 0xf0
 802b772:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802b774:	2302      	movs	r3, #2
 802b776:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802b778:	2300      	movs	r3, #0
 802b77a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802b77c:	2303      	movs	r3, #3
 802b77e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 802b780:	2305      	movs	r3, #5
 802b782:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802b784:	f107 0314 	add.w	r3, r7, #20
 802b788:	4619      	mov	r1, r3
 802b78a:	4836      	ldr	r0, [pc, #216]	; (802b864 <HAL_SPI_MspInit+0x150>)
 802b78c:	f001 f870 	bl	802c870 <HAL_GPIO_Init>

    /* SPI1 DMA Init */
    /* SPI1_RX Init */
    hdma_spi1_rx.Instance = DMA2_Stream0;
 802b790:	4b35      	ldr	r3, [pc, #212]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b792:	4a36      	ldr	r2, [pc, #216]	; (802b86c <HAL_SPI_MspInit+0x158>)
 802b794:	601a      	str	r2, [r3, #0]
    hdma_spi1_rx.Init.Channel = DMA_CHANNEL_3;
 802b796:	4b34      	ldr	r3, [pc, #208]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b798:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
 802b79c:	605a      	str	r2, [r3, #4]
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 802b79e:	4b32      	ldr	r3, [pc, #200]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7a0:	2200      	movs	r2, #0
 802b7a2:	609a      	str	r2, [r3, #8]
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 802b7a4:	4b30      	ldr	r3, [pc, #192]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7a6:	2200      	movs	r2, #0
 802b7a8:	60da      	str	r2, [r3, #12]
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
 802b7aa:	4b2f      	ldr	r3, [pc, #188]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7ac:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802b7b0:	611a      	str	r2, [r3, #16]
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 802b7b2:	4b2d      	ldr	r3, [pc, #180]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7b4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802b7b8:	615a      	str	r2, [r3, #20]
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 802b7ba:	4b2b      	ldr	r3, [pc, #172]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7bc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 802b7c0:	619a      	str	r2, [r3, #24]
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
 802b7c2:	4b29      	ldr	r3, [pc, #164]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7c4:	2200      	movs	r2, #0
 802b7c6:	61da      	str	r2, [r3, #28]
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 802b7c8:	4b27      	ldr	r3, [pc, #156]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7ca:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802b7ce:	621a      	str	r2, [r3, #32]
    hdma_spi1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802b7d0:	4b25      	ldr	r3, [pc, #148]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7d2:	2200      	movs	r2, #0
 802b7d4:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
 802b7d6:	4824      	ldr	r0, [pc, #144]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7d8:	f000 fcba 	bl	802c150 <HAL_DMA_Init>
 802b7dc:	4603      	mov	r3, r0
 802b7de:	2b00      	cmp	r3, #0
 802b7e0:	d001      	beq.n	802b7e6 <HAL_SPI_MspInit+0xd2>
    {
      Error_Handler();
 802b7e2:	f7fe ff87 	bl	802a6f4 <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi1_rx);
 802b7e6:	687b      	ldr	r3, [r7, #4]
 802b7e8:	4a1f      	ldr	r2, [pc, #124]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7ea:	64da      	str	r2, [r3, #76]	; 0x4c
 802b7ec:	4a1e      	ldr	r2, [pc, #120]	; (802b868 <HAL_SPI_MspInit+0x154>)
 802b7ee:	687b      	ldr	r3, [r7, #4]
 802b7f0:	6393      	str	r3, [r2, #56]	; 0x38

    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA2_Stream3;
 802b7f2:	4b1f      	ldr	r3, [pc, #124]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b7f4:	4a1f      	ldr	r2, [pc, #124]	; (802b874 <HAL_SPI_MspInit+0x160>)
 802b7f6:	601a      	str	r2, [r3, #0]
    hdma_spi1_tx.Init.Channel = DMA_CHANNEL_3;
 802b7f8:	4b1d      	ldr	r3, [pc, #116]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b7fa:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
 802b7fe:	605a      	str	r2, [r3, #4]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802b800:	4b1b      	ldr	r3, [pc, #108]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b802:	2240      	movs	r2, #64	; 0x40
 802b804:	609a      	str	r2, [r3, #8]
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802b806:	4b1a      	ldr	r3, [pc, #104]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b808:	2200      	movs	r2, #0
 802b80a:	60da      	str	r2, [r3, #12]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 802b80c:	4b18      	ldr	r3, [pc, #96]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b80e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802b812:	611a      	str	r2, [r3, #16]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 802b814:	4b16      	ldr	r3, [pc, #88]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b816:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802b81a:	615a      	str	r2, [r3, #20]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 802b81c:	4b14      	ldr	r3, [pc, #80]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b81e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 802b822:	619a      	str	r2, [r3, #24]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 802b824:	4b12      	ldr	r3, [pc, #72]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b826:	2200      	movs	r2, #0
 802b828:	61da      	str	r2, [r3, #28]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_MEDIUM;
 802b82a:	4b11      	ldr	r3, [pc, #68]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b82c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802b830:	621a      	str	r2, [r3, #32]
    hdma_spi1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802b832:	4b0f      	ldr	r3, [pc, #60]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b834:	2200      	movs	r2, #0
 802b836:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 802b838:	480d      	ldr	r0, [pc, #52]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b83a:	f000 fc89 	bl	802c150 <HAL_DMA_Init>
 802b83e:	4603      	mov	r3, r0
 802b840:	2b00      	cmp	r3, #0
 802b842:	d001      	beq.n	802b848 <HAL_SPI_MspInit+0x134>
    {
      Error_Handler();
 802b844:	f7fe ff56 	bl	802a6f4 <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 802b848:	687b      	ldr	r3, [r7, #4]
 802b84a:	4a09      	ldr	r2, [pc, #36]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b84c:	649a      	str	r2, [r3, #72]	; 0x48
 802b84e:	4a08      	ldr	r2, [pc, #32]	; (802b870 <HAL_SPI_MspInit+0x15c>)
 802b850:	687b      	ldr	r3, [r7, #4]
 802b852:	6393      	str	r3, [r2, #56]	; 0x38

  }

}
 802b854:	bf00      	nop
 802b856:	3728      	adds	r7, #40	; 0x28
 802b858:	46bd      	mov	sp, r7
 802b85a:	bd80      	pop	{r7, pc}
 802b85c:	40013000 	.word	0x40013000
 802b860:	40023800 	.word	0x40023800
 802b864:	40020000 	.word	0x40020000
 802b868:	20001c58 	.word	0x20001c58
 802b86c:	40026410 	.word	0x40026410
 802b870:	20001cb8 	.word	0x20001cb8
 802b874:	40026458 	.word	0x40026458

0802b878 <NMI_Handler>:
extern DMA_HandleTypeDef hdma_spi1_rx;
extern DMA_HandleTypeDef hdma_spi1_tx;
extern UART_HandleTypeDef huart1;

void NMI_Handler(void)
{
 802b878:	b480      	push	{r7}
 802b87a:	af00      	add	r7, sp, #0
	__NOP();
 802b87c:	bf00      	nop
}
 802b87e:	bf00      	nop
 802b880:	46bd      	mov	sp, r7
 802b882:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b886:	4770      	bx	lr

0802b888 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 802b888:	b480      	push	{r7}
 802b88a:	af00      	add	r7, sp, #0
  while (1)
 802b88c:	e7fe      	b.n	802b88c <HardFault_Handler+0x4>

0802b88e <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 802b88e:	b480      	push	{r7}
 802b890:	af00      	add	r7, sp, #0
  while (1)
 802b892:	e7fe      	b.n	802b892 <MemManage_Handler+0x4>

0802b894 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 802b894:	b480      	push	{r7}
 802b896:	af00      	add	r7, sp, #0
  while (1)
 802b898:	e7fe      	b.n	802b898 <BusFault_Handler+0x4>

0802b89a <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 802b89a:	b480      	push	{r7}
 802b89c:	af00      	add	r7, sp, #0
  while (1)
 802b89e:	e7fe      	b.n	802b89e <UsageFault_Handler+0x4>

0802b8a0 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 802b8a0:	b480      	push	{r7}
 802b8a2:	af00      	add	r7, sp, #0
}
 802b8a4:	bf00      	nop
 802b8a6:	46bd      	mov	sp, r7
 802b8a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b8ac:	4770      	bx	lr

0802b8ae <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 802b8ae:	b480      	push	{r7}
 802b8b0:	af00      	add	r7, sp, #0
}
 802b8b2:	bf00      	nop
 802b8b4:	46bd      	mov	sp, r7
 802b8b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b8ba:	4770      	bx	lr

0802b8bc <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 802b8bc:	b480      	push	{r7}
 802b8be:	af00      	add	r7, sp, #0
}
 802b8c0:	bf00      	nop
 802b8c2:	46bd      	mov	sp, r7
 802b8c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b8c8:	4770      	bx	lr

0802b8ca <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 802b8ca:	b580      	push	{r7, lr}
 802b8cc:	af00      	add	r7, sp, #0
  HAL_IncTick();
 802b8ce:	f000 faeb 	bl	802bea8 <HAL_IncTick>
}
 802b8d2:	bf00      	nop
 802b8d4:	bd80      	pop	{r7, pc}
	...

0802b8d8 <USART1_IRQHandler>:


void USART1_IRQHandler(void)
{
 802b8d8:	b580      	push	{r7, lr}
 802b8da:	af00      	add	r7, sp, #0
  HAL_UART_IRQHandler(&huart1);
 802b8dc:	4802      	ldr	r0, [pc, #8]	; (802b8e8 <USART1_IRQHandler+0x10>)
 802b8de:	f003 fb63 	bl	802efa8 <HAL_UART_IRQHandler>
}
 802b8e2:	bf00      	nop
 802b8e4:	bd80      	pop	{r7, pc}
 802b8e6:	bf00      	nop
 802b8e8:	20001b80 	.word	0x20001b80

0802b8ec <DMA2_Stream2_IRQHandler>:

/**
  * @brief This function handles DMA2 stream2 global interrupt.
  */
void DMA2_Stream2_IRQHandler(void)
{
 802b8ec:	b580      	push	{r7, lr}
 802b8ee:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 802b8f0:	4802      	ldr	r0, [pc, #8]	; (802b8fc <DMA2_Stream2_IRQHandler+0x10>)
 802b8f2:	f000 fd55 	bl	802c3a0 <HAL_DMA_IRQHandler>
}
 802b8f6:	bf00      	nop
 802b8f8:	bd80      	pop	{r7, pc}
 802b8fa:	bf00      	nop
 802b8fc:	20001b20 	.word	0x20001b20

0802b900 <DMA2_Stream7_IRQHandler>:

/**
  * @brief This function handles DMA2 stream7 global interrupt.
  */
void DMA2_Stream7_IRQHandler(void)
{
 802b900:	b580      	push	{r7, lr}
 802b902:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 802b904:	4802      	ldr	r0, [pc, #8]	; (802b910 <DMA2_Stream7_IRQHandler+0x10>)
 802b906:	f000 fd4b 	bl	802c3a0 <HAL_DMA_IRQHandler>
}
 802b90a:	bf00      	nop
 802b90c:	bd80      	pop	{r7, pc}
 802b90e:	bf00      	nop
 802b910:	20001ac0 	.word	0x20001ac0

0802b914 <DMA2_Stream0_IRQHandler>:


void DMA2_Stream0_IRQHandler(void)
{
 802b914:	b580      	push	{r7, lr}
 802b916:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
 802b918:	4802      	ldr	r0, [pc, #8]	; (802b924 <DMA2_Stream0_IRQHandler+0x10>)
 802b91a:	f000 fd41 	bl	802c3a0 <HAL_DMA_IRQHandler>
}
 802b91e:	bf00      	nop
 802b920:	bd80      	pop	{r7, pc}
 802b922:	bf00      	nop
 802b924:	20001c58 	.word	0x20001c58

0802b928 <DMA2_Stream3_IRQHandler>:

/**
  * @brief This function handles DMA2 stream3 global interrupt.
  */
void DMA2_Stream3_IRQHandler(void)
{
 802b928:	b580      	push	{r7, lr}
 802b92a:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 802b92c:	4802      	ldr	r0, [pc, #8]	; (802b938 <DMA2_Stream3_IRQHandler+0x10>)
 802b92e:	f000 fd37 	bl	802c3a0 <HAL_DMA_IRQHandler>
}
 802b932:	bf00      	nop
 802b934:	bd80      	pop	{r7, pc}
 802b936:	bf00      	nop
 802b938:	20001cb8 	.word	0x20001cb8

0802b93c <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 802b93c:	b480      	push	{r7}
 802b93e:	af00      	add	r7, sp, #0
	return 1;
 802b940:	2301      	movs	r3, #1
}
 802b942:	4618      	mov	r0, r3
 802b944:	46bd      	mov	sp, r7
 802b946:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b94a:	4770      	bx	lr

0802b94c <_kill>:

int _kill(int pid, int sig)
{
 802b94c:	b580      	push	{r7, lr}
 802b94e:	b082      	sub	sp, #8
 802b950:	af00      	add	r7, sp, #0
 802b952:	6078      	str	r0, [r7, #4]
 802b954:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
 802b956:	f004 f981 	bl	802fc5c <__errno>
 802b95a:	4602      	mov	r2, r0
 802b95c:	2316      	movs	r3, #22
 802b95e:	6013      	str	r3, [r2, #0]
	return -1;
 802b960:	f04f 33ff 	mov.w	r3, #4294967295
}
 802b964:	4618      	mov	r0, r3
 802b966:	3708      	adds	r7, #8
 802b968:	46bd      	mov	sp, r7
 802b96a:	bd80      	pop	{r7, pc}

0802b96c <_exit>:

void _exit (int status)
{
 802b96c:	b580      	push	{r7, lr}
 802b96e:	b082      	sub	sp, #8
 802b970:	af00      	add	r7, sp, #0
 802b972:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
 802b974:	f04f 31ff 	mov.w	r1, #4294967295
 802b978:	6878      	ldr	r0, [r7, #4]
 802b97a:	f7ff ffe7 	bl	802b94c <_kill>
	while (1) {}		/* Make sure we hang here */
 802b97e:	e7fe      	b.n	802b97e <_exit+0x12>

0802b980 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 802b980:	b580      	push	{r7, lr}
 802b982:	b086      	sub	sp, #24
 802b984:	af00      	add	r7, sp, #0
 802b986:	60f8      	str	r0, [r7, #12]
 802b988:	60b9      	str	r1, [r7, #8]
 802b98a:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802b98c:	2300      	movs	r3, #0
 802b98e:	617b      	str	r3, [r7, #20]
 802b990:	e00a      	b.n	802b9a8 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 802b992:	f3af 8000 	nop.w
 802b996:	4601      	mov	r1, r0
 802b998:	68bb      	ldr	r3, [r7, #8]
 802b99a:	1c5a      	adds	r2, r3, #1
 802b99c:	60ba      	str	r2, [r7, #8]
 802b99e:	b2ca      	uxtb	r2, r1
 802b9a0:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802b9a2:	697b      	ldr	r3, [r7, #20]
 802b9a4:	3301      	adds	r3, #1
 802b9a6:	617b      	str	r3, [r7, #20]
 802b9a8:	697a      	ldr	r2, [r7, #20]
 802b9aa:	687b      	ldr	r3, [r7, #4]
 802b9ac:	429a      	cmp	r2, r3
 802b9ae:	dbf0      	blt.n	802b992 <_read+0x12>
	}

return len;
 802b9b0:	687b      	ldr	r3, [r7, #4]
}
 802b9b2:	4618      	mov	r0, r3
 802b9b4:	3718      	adds	r7, #24
 802b9b6:	46bd      	mov	sp, r7
 802b9b8:	bd80      	pop	{r7, pc}

0802b9ba <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 802b9ba:	b580      	push	{r7, lr}
 802b9bc:	b086      	sub	sp, #24
 802b9be:	af00      	add	r7, sp, #0
 802b9c0:	60f8      	str	r0, [r7, #12]
 802b9c2:	60b9      	str	r1, [r7, #8]
 802b9c4:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802b9c6:	2300      	movs	r3, #0
 802b9c8:	617b      	str	r3, [r7, #20]
 802b9ca:	e009      	b.n	802b9e0 <_write+0x26>
	{
		__io_putchar(*ptr++);
 802b9cc:	68bb      	ldr	r3, [r7, #8]
 802b9ce:	1c5a      	adds	r2, r3, #1
 802b9d0:	60ba      	str	r2, [r7, #8]
 802b9d2:	781b      	ldrb	r3, [r3, #0]
 802b9d4:	4618      	mov	r0, r3
 802b9d6:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802b9da:	697b      	ldr	r3, [r7, #20]
 802b9dc:	3301      	adds	r3, #1
 802b9de:	617b      	str	r3, [r7, #20]
 802b9e0:	697a      	ldr	r2, [r7, #20]
 802b9e2:	687b      	ldr	r3, [r7, #4]
 802b9e4:	429a      	cmp	r2, r3
 802b9e6:	dbf1      	blt.n	802b9cc <_write+0x12>
	}
	return len;
 802b9e8:	687b      	ldr	r3, [r7, #4]
}
 802b9ea:	4618      	mov	r0, r3
 802b9ec:	3718      	adds	r7, #24
 802b9ee:	46bd      	mov	sp, r7
 802b9f0:	bd80      	pop	{r7, pc}

0802b9f2 <_close>:

int _close(int file)
{
 802b9f2:	b480      	push	{r7}
 802b9f4:	b083      	sub	sp, #12
 802b9f6:	af00      	add	r7, sp, #0
 802b9f8:	6078      	str	r0, [r7, #4]
	return -1;
 802b9fa:	f04f 33ff 	mov.w	r3, #4294967295
}
 802b9fe:	4618      	mov	r0, r3
 802ba00:	370c      	adds	r7, #12
 802ba02:	46bd      	mov	sp, r7
 802ba04:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ba08:	4770      	bx	lr

0802ba0a <_fstat>:


int _fstat(int file, struct stat *st)
{
 802ba0a:	b480      	push	{r7}
 802ba0c:	b083      	sub	sp, #12
 802ba0e:	af00      	add	r7, sp, #0
 802ba10:	6078      	str	r0, [r7, #4]
 802ba12:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 802ba14:	683b      	ldr	r3, [r7, #0]
 802ba16:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 802ba1a:	605a      	str	r2, [r3, #4]
	return 0;
 802ba1c:	2300      	movs	r3, #0
}
 802ba1e:	4618      	mov	r0, r3
 802ba20:	370c      	adds	r7, #12
 802ba22:	46bd      	mov	sp, r7
 802ba24:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ba28:	4770      	bx	lr

0802ba2a <_isatty>:

int _isatty(int file)
{
 802ba2a:	b480      	push	{r7}
 802ba2c:	b083      	sub	sp, #12
 802ba2e:	af00      	add	r7, sp, #0
 802ba30:	6078      	str	r0, [r7, #4]
	return 1;
 802ba32:	2301      	movs	r3, #1
}
 802ba34:	4618      	mov	r0, r3
 802ba36:	370c      	adds	r7, #12
 802ba38:	46bd      	mov	sp, r7
 802ba3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ba3e:	4770      	bx	lr

0802ba40 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 802ba40:	b480      	push	{r7}
 802ba42:	b085      	sub	sp, #20
 802ba44:	af00      	add	r7, sp, #0
 802ba46:	60f8      	str	r0, [r7, #12]
 802ba48:	60b9      	str	r1, [r7, #8]
 802ba4a:	607a      	str	r2, [r7, #4]
	return 0;
 802ba4c:	2300      	movs	r3, #0
}
 802ba4e:	4618      	mov	r0, r3
 802ba50:	3714      	adds	r7, #20
 802ba52:	46bd      	mov	sp, r7
 802ba54:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ba58:	4770      	bx	lr
	...

0802ba5c <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 802ba5c:	b580      	push	{r7, lr}
 802ba5e:	b084      	sub	sp, #16
 802ba60:	af00      	add	r7, sp, #0
 802ba62:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 802ba64:	4b11      	ldr	r3, [pc, #68]	; (802baac <_sbrk+0x50>)
 802ba66:	681b      	ldr	r3, [r3, #0]
 802ba68:	2b00      	cmp	r3, #0
 802ba6a:	d102      	bne.n	802ba72 <_sbrk+0x16>
		heap_end = &end;
 802ba6c:	4b0f      	ldr	r3, [pc, #60]	; (802baac <_sbrk+0x50>)
 802ba6e:	4a10      	ldr	r2, [pc, #64]	; (802bab0 <_sbrk+0x54>)
 802ba70:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 802ba72:	4b0e      	ldr	r3, [pc, #56]	; (802baac <_sbrk+0x50>)
 802ba74:	681b      	ldr	r3, [r3, #0]
 802ba76:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
 802ba78:	4b0c      	ldr	r3, [pc, #48]	; (802baac <_sbrk+0x50>)
 802ba7a:	681a      	ldr	r2, [r3, #0]
 802ba7c:	687b      	ldr	r3, [r7, #4]
 802ba7e:	4413      	add	r3, r2
 802ba80:	466a      	mov	r2, sp
 802ba82:	4293      	cmp	r3, r2
 802ba84:	d907      	bls.n	802ba96 <_sbrk+0x3a>
	{
		errno = ENOMEM;
 802ba86:	f004 f8e9 	bl	802fc5c <__errno>
 802ba8a:	4602      	mov	r2, r0
 802ba8c:	230c      	movs	r3, #12
 802ba8e:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
 802ba90:	f04f 33ff 	mov.w	r3, #4294967295
 802ba94:	e006      	b.n	802baa4 <_sbrk+0x48>
	}

	heap_end += incr;
 802ba96:	4b05      	ldr	r3, [pc, #20]	; (802baac <_sbrk+0x50>)
 802ba98:	681a      	ldr	r2, [r3, #0]
 802ba9a:	687b      	ldr	r3, [r7, #4]
 802ba9c:	4413      	add	r3, r2
 802ba9e:	4a03      	ldr	r2, [pc, #12]	; (802baac <_sbrk+0x50>)
 802baa0:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
 802baa2:	68fb      	ldr	r3, [r7, #12]
}
 802baa4:	4618      	mov	r0, r3
 802baa6:	3710      	adds	r7, #16
 802baa8:	46bd      	mov	sp, r7
 802baaa:	bd80      	pop	{r7, pc}
 802baac:	20001a0c 	.word	0x20001a0c
 802bab0:	20004820 	.word	0x20004820

0802bab4 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 802bab4:	b480      	push	{r7}
 802bab6:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 802bab8:	4b08      	ldr	r3, [pc, #32]	; (802badc <SystemInit+0x28>)
 802baba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 802babe:	4a07      	ldr	r2, [pc, #28]	; (802badc <SystemInit+0x28>)
 802bac0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 802bac4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 802bac8:	4b04      	ldr	r3, [pc, #16]	; (802badc <SystemInit+0x28>)
 802baca:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802bace:	609a      	str	r2, [r3, #8]
#endif
}
 802bad0:	bf00      	nop
 802bad2:	46bd      	mov	sp, r7
 802bad4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bad8:	4770      	bx	lr
 802bada:	bf00      	nop
 802badc:	e000ed00 	.word	0xe000ed00

0802bae0 <MX_USART1_UART_Init>:
 *PA10    ------> USART1_RX
 *UART1 is connected to the Hirose Connector in PCB
*/

void MX_USART1_UART_Init(void)
{
 802bae0:	b580      	push	{r7, lr}
 802bae2:	af00      	add	r7, sp, #0
  huart1.Instance = USART1;
 802bae4:	4b11      	ldr	r3, [pc, #68]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bae6:	4a12      	ldr	r2, [pc, #72]	; (802bb30 <MX_USART1_UART_Init+0x50>)
 802bae8:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 802baea:	4b10      	ldr	r3, [pc, #64]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802baec:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 802baf0:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 802baf2:	4b0e      	ldr	r3, [pc, #56]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802baf4:	2200      	movs	r2, #0
 802baf6:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 802baf8:	4b0c      	ldr	r3, [pc, #48]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bafa:	2200      	movs	r2, #0
 802bafc:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 802bafe:	4b0b      	ldr	r3, [pc, #44]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bb00:	2200      	movs	r2, #0
 802bb02:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 802bb04:	4b09      	ldr	r3, [pc, #36]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bb06:	220c      	movs	r2, #12
 802bb08:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802bb0a:	4b08      	ldr	r3, [pc, #32]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bb0c:	2200      	movs	r2, #0
 802bb0e:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 802bb10:	4b06      	ldr	r3, [pc, #24]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bb12:	2200      	movs	r2, #0
 802bb14:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 802bb16:	4805      	ldr	r0, [pc, #20]	; (802bb2c <MX_USART1_UART_Init+0x4c>)
 802bb18:	f003 f8d6 	bl	802ecc8 <HAL_UART_Init>
 802bb1c:	4603      	mov	r3, r0
 802bb1e:	2b00      	cmp	r3, #0
 802bb20:	d001      	beq.n	802bb26 <MX_USART1_UART_Init+0x46>
  {
    Error_Handler();
 802bb22:	f7fe fde7 	bl	802a6f4 <Error_Handler>
  }
}
 802bb26:	bf00      	nop
 802bb28:	bd80      	pop	{r7, pc}
 802bb2a:	bf00      	nop
 802bb2c:	20001b80 	.word	0x20001b80
 802bb30:	40011000 	.word	0x40011000

0802bb34 <MX_USART2_UART_Init>:
 *PA2     ------> USART2_TX
 *PA3     ------> USART2_RX
 *UART2 is connected to USB in STM32
*/
void MX_USART2_UART_Init(void)
{
 802bb34:	b580      	push	{r7, lr}
 802bb36:	af00      	add	r7, sp, #0
  huart2.Instance = USART2;
 802bb38:	4b11      	ldr	r3, [pc, #68]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb3a:	4a12      	ldr	r2, [pc, #72]	; (802bb84 <MX_USART2_UART_Init+0x50>)
 802bb3c:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 802bb3e:	4b10      	ldr	r3, [pc, #64]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb40:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 802bb44:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 802bb46:	4b0e      	ldr	r3, [pc, #56]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb48:	2200      	movs	r2, #0
 802bb4a:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 802bb4c:	4b0c      	ldr	r3, [pc, #48]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb4e:	2200      	movs	r2, #0
 802bb50:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 802bb52:	4b0b      	ldr	r3, [pc, #44]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb54:	2200      	movs	r2, #0
 802bb56:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 802bb58:	4b09      	ldr	r3, [pc, #36]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb5a:	220c      	movs	r2, #12
 802bb5c:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802bb5e:	4b08      	ldr	r3, [pc, #32]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb60:	2200      	movs	r2, #0
 802bb62:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 802bb64:	4b06      	ldr	r3, [pc, #24]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb66:	2200      	movs	r2, #0
 802bb68:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802bb6a:	4805      	ldr	r0, [pc, #20]	; (802bb80 <MX_USART2_UART_Init+0x4c>)
 802bb6c:	f003 f8ac 	bl	802ecc8 <HAL_UART_Init>
 802bb70:	4603      	mov	r3, r0
 802bb72:	2b00      	cmp	r3, #0
 802bb74:	d001      	beq.n	802bb7a <MX_USART2_UART_Init+0x46>
  {
    Error_Handler();
 802bb76:	f7fe fdbd 	bl	802a6f4 <Error_Handler>
  }
}
 802bb7a:	bf00      	nop
 802bb7c:	bd80      	pop	{r7, pc}
 802bb7e:	bf00      	nop
 802bb80:	20001c18 	.word	0x20001c18
 802bb84:	40004400 	.word	0x40004400

0802bb88 <MX_DMA_Init>:

/*
 * Enable DMA controller clock
 */
void MX_DMA_Init(void)
{
 802bb88:	b580      	push	{r7, lr}
 802bb8a:	b082      	sub	sp, #8
 802bb8c:	af00      	add	r7, sp, #0

  // DMA controller clock enable
  __HAL_RCC_DMA2_CLK_ENABLE();
 802bb8e:	2300      	movs	r3, #0
 802bb90:	607b      	str	r3, [r7, #4]
 802bb92:	4b18      	ldr	r3, [pc, #96]	; (802bbf4 <MX_DMA_Init+0x6c>)
 802bb94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802bb96:	4a17      	ldr	r2, [pc, #92]	; (802bbf4 <MX_DMA_Init+0x6c>)
 802bb98:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 802bb9c:	6313      	str	r3, [r2, #48]	; 0x30
 802bb9e:	4b15      	ldr	r3, [pc, #84]	; (802bbf4 <MX_DMA_Init+0x6c>)
 802bba0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802bba2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802bba6:	607b      	str	r3, [r7, #4]
 802bba8:	687b      	ldr	r3, [r7, #4]
  /* UART DMA
     DMA interrupt init
     DMA2_Stream2_IRQn interrupt configuration
     DMA2_Stream7_IRQn interrupt configuration
   */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
 802bbaa:	2200      	movs	r2, #0
 802bbac:	2100      	movs	r1, #0
 802bbae:	203a      	movs	r0, #58	; 0x3a
 802bbb0:	f000 fa97 	bl	802c0e2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 802bbb4:	203a      	movs	r0, #58	; 0x3a
 802bbb6:	f000 fab0 	bl	802c11a <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0);
 802bbba:	2200      	movs	r2, #0
 802bbbc:	2100      	movs	r1, #0
 802bbbe:	2046      	movs	r0, #70	; 0x46
 802bbc0:	f000 fa8f 	bl	802c0e2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
 802bbc4:	2046      	movs	r0, #70	; 0x46
 802bbc6:	f000 faa8 	bl	802c11a <HAL_NVIC_EnableIRQ>
  /*SPI DMA
    DMA interrupt init
    DMA2_Stream0_IRQn interrupt configuration
    DMA2_Stream3_IRQn interrupt configuration
   */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
 802bbca:	2200      	movs	r2, #0
 802bbcc:	2100      	movs	r1, #0
 802bbce:	2038      	movs	r0, #56	; 0x38
 802bbd0:	f000 fa87 	bl	802c0e2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 802bbd4:	2038      	movs	r0, #56	; 0x38
 802bbd6:	f000 faa0 	bl	802c11a <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
 802bbda:	2200      	movs	r2, #0
 802bbdc:	2100      	movs	r1, #0
 802bbde:	203b      	movs	r0, #59	; 0x3b
 802bbe0:	f000 fa7f 	bl	802c0e2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 802bbe4:	203b      	movs	r0, #59	; 0x3b
 802bbe6:	f000 fa98 	bl	802c11a <HAL_NVIC_EnableIRQ>

}
 802bbea:	bf00      	nop
 802bbec:	3708      	adds	r7, #8
 802bbee:	46bd      	mov	sp, r7
 802bbf0:	bd80      	pop	{r7, pc}
 802bbf2:	bf00      	nop
 802bbf4:	40023800 	.word	0x40023800

0802bbf8 <TransmitData>:

void TransmitData(struct CalibBuffer *calibData)
{
 802bbf8:	b580      	push	{r7, lr}
 802bbfa:	b086      	sub	sp, #24
 802bbfc:	af00      	add	r7, sp, #0
 802bbfe:	6078      	str	r0, [r7, #4]
	for (int i = 0; i < 3; i++)
 802bc00:	2300      	movs	r3, #0
 802bc02:	617b      	str	r3, [r7, #20]
 802bc04:	e025      	b.n	802bc52 <TransmitData+0x5a>
	{
		tx_bytes[i].t = phi[i].t;
 802bc06:	4a5a      	ldr	r2, [pc, #360]	; (802bd70 <TransmitData+0x178>)
 802bc08:	697b      	ldr	r3, [r7, #20]
 802bc0a:	009b      	lsls	r3, r3, #2
 802bc0c:	4413      	add	r3, r2
 802bc0e:	681a      	ldr	r2, [r3, #0]
 802bc10:	4958      	ldr	r1, [pc, #352]	; (802bd74 <TransmitData+0x17c>)
 802bc12:	697b      	ldr	r3, [r7, #20]
 802bc14:	009b      	lsls	r3, r3, #2
 802bc16:	440b      	add	r3, r1
 802bc18:	601a      	str	r2, [r3, #0]
		tx_bytes[i+3].t = gam[i].t;								//Combine ga & phi together
 802bc1a:	697b      	ldr	r3, [r7, #20]
 802bc1c:	3303      	adds	r3, #3
 802bc1e:	4956      	ldr	r1, [pc, #344]	; (802bd78 <TransmitData+0x180>)
 802bc20:	697a      	ldr	r2, [r7, #20]
 802bc22:	0092      	lsls	r2, r2, #2
 802bc24:	440a      	add	r2, r1
 802bc26:	6812      	ldr	r2, [r2, #0]
 802bc28:	4952      	ldr	r1, [pc, #328]	; (802bd74 <TransmitData+0x17c>)
 802bc2a:	009b      	lsls	r3, r3, #2
 802bc2c:	440b      	add	r3, r1
 802bc2e:	601a      	str	r2, [r3, #0]
		tx_bytes[i+6].t = OMEbarOJ.OME[i][0];
 802bc30:	697b      	ldr	r3, [r7, #20]
 802bc32:	3306      	adds	r3, #6
 802bc34:	4951      	ldr	r1, [pc, #324]	; (802bd7c <TransmitData+0x184>)
 802bc36:	697a      	ldr	r2, [r7, #20]
 802bc38:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802bc3c:	fb00 f202 	mul.w	r2, r0, r2
 802bc40:	440a      	add	r2, r1
 802bc42:	6812      	ldr	r2, [r2, #0]
 802bc44:	494b      	ldr	r1, [pc, #300]	; (802bd74 <TransmitData+0x17c>)
 802bc46:	009b      	lsls	r3, r3, #2
 802bc48:	440b      	add	r3, r1
 802bc4a:	601a      	str	r2, [r3, #0]
	for (int i = 0; i < 3; i++)
 802bc4c:	697b      	ldr	r3, [r7, #20]
 802bc4e:	3301      	adds	r3, #1
 802bc50:	617b      	str	r3, [r7, #20]
 802bc52:	697b      	ldr	r3, [r7, #20]
 802bc54:	2b02      	cmp	r3, #2
 802bc56:	ddd6      	ble.n	802bc06 <TransmitData+0xe>
	}
//		tx_bytes[9].t = 0.0;										//Placeholder for temperature
	for (int k = 0; k < nIMUs; k++)
 802bc58:	2300      	movs	r3, #0
 802bc5a:	613b      	str	r3, [r7, #16]
 802bc5c:	e04d      	b.n	802bcfa <TransmitData+0x102>
	{
		tx_bytes[k*3 + 9].t = calibData[k].RxBuffer_AX[sendIndex[k]];
 802bc5e:	693b      	ldr	r3, [r7, #16]
 802bc60:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802bc64:	fb02 f303 	mul.w	r3, r2, r3
 802bc68:	687a      	ldr	r2, [r7, #4]
 802bc6a:	18d1      	adds	r1, r2, r3
 802bc6c:	4a44      	ldr	r2, [pc, #272]	; (802bd80 <TransmitData+0x188>)
 802bc6e:	693b      	ldr	r3, [r7, #16]
 802bc70:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 802bc74:	693a      	ldr	r2, [r7, #16]
 802bc76:	4613      	mov	r3, r2
 802bc78:	005b      	lsls	r3, r3, #1
 802bc7a:	4413      	add	r3, r2
 802bc7c:	3309      	adds	r3, #9
 802bc7e:	f500 7296 	add.w	r2, r0, #300	; 0x12c
 802bc82:	0092      	lsls	r2, r2, #2
 802bc84:	440a      	add	r2, r1
 802bc86:	6812      	ldr	r2, [r2, #0]
 802bc88:	493a      	ldr	r1, [pc, #232]	; (802bd74 <TransmitData+0x17c>)
 802bc8a:	009b      	lsls	r3, r3, #2
 802bc8c:	440b      	add	r3, r1
 802bc8e:	601a      	str	r2, [r3, #0]
		tx_bytes[k*3 + 10].t = calibData[k].RxBuffer_AY[sendIndex[k]];
 802bc90:	693b      	ldr	r3, [r7, #16]
 802bc92:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802bc96:	fb02 f303 	mul.w	r3, r2, r3
 802bc9a:	687a      	ldr	r2, [r7, #4]
 802bc9c:	18d1      	adds	r1, r2, r3
 802bc9e:	4a38      	ldr	r2, [pc, #224]	; (802bd80 <TransmitData+0x188>)
 802bca0:	693b      	ldr	r3, [r7, #16]
 802bca2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 802bca6:	693a      	ldr	r2, [r7, #16]
 802bca8:	4613      	mov	r3, r2
 802bcaa:	005b      	lsls	r3, r3, #1
 802bcac:	4413      	add	r3, r2
 802bcae:	330a      	adds	r3, #10
 802bcb0:	f500 72c8 	add.w	r2, r0, #400	; 0x190
 802bcb4:	0092      	lsls	r2, r2, #2
 802bcb6:	440a      	add	r2, r1
 802bcb8:	6812      	ldr	r2, [r2, #0]
 802bcba:	492e      	ldr	r1, [pc, #184]	; (802bd74 <TransmitData+0x17c>)
 802bcbc:	009b      	lsls	r3, r3, #2
 802bcbe:	440b      	add	r3, r1
 802bcc0:	601a      	str	r2, [r3, #0]
		tx_bytes[k*3 + 11].t = calibData[k].RxBuffer_AZ[sendIndex[k]];
 802bcc2:	693b      	ldr	r3, [r7, #16]
 802bcc4:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802bcc8:	fb02 f303 	mul.w	r3, r2, r3
 802bccc:	687a      	ldr	r2, [r7, #4]
 802bcce:	18d1      	adds	r1, r2, r3
 802bcd0:	4a2b      	ldr	r2, [pc, #172]	; (802bd80 <TransmitData+0x188>)
 802bcd2:	693b      	ldr	r3, [r7, #16]
 802bcd4:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 802bcd8:	693a      	ldr	r2, [r7, #16]
 802bcda:	4613      	mov	r3, r2
 802bcdc:	005b      	lsls	r3, r3, #1
 802bcde:	4413      	add	r3, r2
 802bce0:	330b      	adds	r3, #11
 802bce2:	f500 72fa 	add.w	r2, r0, #500	; 0x1f4
 802bce6:	0092      	lsls	r2, r2, #2
 802bce8:	440a      	add	r2, r1
 802bcea:	6812      	ldr	r2, [r2, #0]
 802bcec:	4921      	ldr	r1, [pc, #132]	; (802bd74 <TransmitData+0x17c>)
 802bcee:	009b      	lsls	r3, r3, #2
 802bcf0:	440b      	add	r3, r1
 802bcf2:	601a      	str	r2, [r3, #0]
	for (int k = 0; k < nIMUs; k++)
 802bcf4:	693b      	ldr	r3, [r7, #16]
 802bcf6:	3301      	adds	r3, #1
 802bcf8:	613b      	str	r3, [r7, #16]
 802bcfa:	693b      	ldr	r3, [r7, #16]
 802bcfc:	2b05      	cmp	r3, #5
 802bcfe:	ddae      	ble.n	802bc5e <TransmitData+0x66>
//		{
//			tx_bytes[i].tbytes[j] = (uint8_t)(j + i*4);
//		}
//	}
	//UART
	HAL_UART_DMAResume(&huart1);								//Start UART
 802bd00:	4820      	ldr	r0, [pc, #128]	; (802bd84 <TransmitData+0x18c>)
 802bd02:	f003 f8ff 	bl	802ef04 <HAL_UART_DMAResume>
	HAL_UART_Transmit_DMA(&huart1, tx_bytes[0].tbytes, NBYTES);			//Transmit bytes with DMA
 802bd06:	226c      	movs	r2, #108	; 0x6c
 802bd08:	491a      	ldr	r1, [pc, #104]	; (802bd74 <TransmitData+0x17c>)
 802bd0a:	481e      	ldr	r0, [pc, #120]	; (802bd84 <TransmitData+0x18c>)
 802bd0c:	f003 f82a 	bl	802ed64 <HAL_UART_Transmit_DMA>
	for (int i = 0; i < NWORDS; i++)
 802bd10:	2300      	movs	r3, #0
 802bd12:	60fb      	str	r3, [r7, #12]
 802bd14:	e012      	b.n	802bd3c <TransmitData+0x144>
	{
		tx_bytesBuffer[iTx_bytesBuffer][i] = tx_bytes[i];
 802bd16:	4b1c      	ldr	r3, [pc, #112]	; (802bd88 <TransmitData+0x190>)
 802bd18:	681a      	ldr	r2, [r3, #0]
 802bd1a:	491c      	ldr	r1, [pc, #112]	; (802bd8c <TransmitData+0x194>)
 802bd1c:	4613      	mov	r3, r2
 802bd1e:	005b      	lsls	r3, r3, #1
 802bd20:	4413      	add	r3, r2
 802bd22:	00da      	lsls	r2, r3, #3
 802bd24:	4413      	add	r3, r2
 802bd26:	68fa      	ldr	r2, [r7, #12]
 802bd28:	4413      	add	r3, r2
 802bd2a:	4812      	ldr	r0, [pc, #72]	; (802bd74 <TransmitData+0x17c>)
 802bd2c:	68fa      	ldr	r2, [r7, #12]
 802bd2e:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 802bd32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for (int i = 0; i < NWORDS; i++)
 802bd36:	68fb      	ldr	r3, [r7, #12]
 802bd38:	3301      	adds	r3, #1
 802bd3a:	60fb      	str	r3, [r7, #12]
 802bd3c:	68fb      	ldr	r3, [r7, #12]
 802bd3e:	2b1a      	cmp	r3, #26
 802bd40:	dde9      	ble.n	802bd16 <TransmitData+0x11e>
	}
	if (iTx_bytesBuffer >= 99)
 802bd42:	4b11      	ldr	r3, [pc, #68]	; (802bd88 <TransmitData+0x190>)
 802bd44:	681b      	ldr	r3, [r3, #0]
 802bd46:	2b62      	cmp	r3, #98	; 0x62
 802bd48:	dd08      	ble.n	802bd5c <TransmitData+0x164>
	{
		iTx_bytesBuffer = 0;
 802bd4a:	4b0f      	ldr	r3, [pc, #60]	; (802bd88 <TransmitData+0x190>)
 802bd4c:	2200      	movs	r2, #0
 802bd4e:	601a      	str	r2, [r3, #0]
		iTx_bytesBufferRollover++;
 802bd50:	4b0f      	ldr	r3, [pc, #60]	; (802bd90 <TransmitData+0x198>)
 802bd52:	681b      	ldr	r3, [r3, #0]
 802bd54:	3301      	adds	r3, #1
 802bd56:	4a0e      	ldr	r2, [pc, #56]	; (802bd90 <TransmitData+0x198>)
 802bd58:	6013      	str	r3, [r2, #0]
//		if (iTx_bytesBufferRollover > 0)
//	if (iTx_bytesBuffer > 4)
//	{
//		__NOP();
//	}
}
 802bd5a:	e004      	b.n	802bd66 <TransmitData+0x16e>
		iTx_bytesBuffer++;
 802bd5c:	4b0a      	ldr	r3, [pc, #40]	; (802bd88 <TransmitData+0x190>)
 802bd5e:	681b      	ldr	r3, [r3, #0]
 802bd60:	3301      	adds	r3, #1
 802bd62:	4a09      	ldr	r2, [pc, #36]	; (802bd88 <TransmitData+0x190>)
 802bd64:	6013      	str	r3, [r2, #0]
}
 802bd66:	bf00      	nop
 802bd68:	3718      	adds	r7, #24
 802bd6a:	46bd      	mov	sp, r7
 802bd6c:	bd80      	pop	{r7, pc}
 802bd6e:	bf00      	nop
 802bd70:	20001d60 	.word	0x20001d60
 802bd74:	20001d7c 	.word	0x20001d7c
 802bd78:	20001d6c 	.word	0x20001d6c
 802bd7c:	200014c8 	.word	0x200014c8
 802bd80:	200014b0 	.word	0x200014b0
 802bd84:	20001b80 	.word	0x20001b80
 802bd88:	20001a10 	.word	0x20001a10
 802bd8c:	20001de8 	.word	0x20001de8
 802bd90:	20001a14 	.word	0x20001a14

0802bd94 <HAL_UART_TxCpltCallback>:

// UART DMA handler
// Being call after done with the transmission
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 802bd94:	b580      	push	{r7, lr}
 802bd96:	b082      	sub	sp, #8
 802bd98:	af00      	add	r7, sp, #0
 802bd9a:	6078      	str	r0, [r7, #4]
	HAL_UART_DMAPause(&huart1);									  //Pause UART
 802bd9c:	4803      	ldr	r0, [pc, #12]	; (802bdac <HAL_UART_TxCpltCallback+0x18>)
 802bd9e:	f003 f84d 	bl	802ee3c <HAL_UART_DMAPause>
}
 802bda2:	bf00      	nop
 802bda4:	3708      	adds	r7, #8
 802bda6:	46bd      	mov	sp, r7
 802bda8:	bd80      	pop	{r7, pc}
 802bdaa:	bf00      	nop
 802bdac:	20001b80 	.word	0x20001b80

0802bdb0 <Reset_Handler>:
*/

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:    ldr   sp, =_estack    		 /* set stack pointer */
 802bdb0:	f8df d034 	ldr.w	sp, [pc, #52]	; 802bde8 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 802bdb4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 802bdb6:	e003      	b.n	802bdc0 <LoopCopyDataInit>

0802bdb8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 802bdb8:	4b0c      	ldr	r3, [pc, #48]	; (802bdec <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 802bdba:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 802bdbc:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 802bdbe:	3104      	adds	r1, #4

0802bdc0 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 802bdc0:	480b      	ldr	r0, [pc, #44]	; (802bdf0 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 802bdc2:	4b0c      	ldr	r3, [pc, #48]	; (802bdf4 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 802bdc4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 802bdc6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 802bdc8:	d3f6      	bcc.n	802bdb8 <CopyDataInit>
  ldr  r2, =_sbss
 802bdca:	4a0b      	ldr	r2, [pc, #44]	; (802bdf8 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 802bdcc:	e002      	b.n	802bdd4 <LoopFillZerobss>

0802bdce <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 802bdce:	2300      	movs	r3, #0
  str  r3, [r2], #4
 802bdd0:	f842 3b04 	str.w	r3, [r2], #4

0802bdd4 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 802bdd4:	4b09      	ldr	r3, [pc, #36]	; (802bdfc <LoopFillZerobss+0x28>)
  cmp  r2, r3
 802bdd6:	429a      	cmp	r2, r3
  bcc  FillZerobss
 802bdd8:	d3f9      	bcc.n	802bdce <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 802bdda:	f7ff fe6b 	bl	802bab4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 802bdde:	f004 f93d 	bl	803005c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 802bde2:	f7fe fb5b 	bl	802a49c <main>
  bx  lr    
 802bde6:	4770      	bx	lr
Reset_Handler:    ldr   sp, =_estack    		 /* set stack pointer */
 802bde8:	20018000 	.word	0x20018000
  ldr  r3, =_sidata
 802bdec:	080314ac 	.word	0x080314ac
  ldr  r0, =_sdata
 802bdf0:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 802bdf4:	20000634 	.word	0x20000634
  ldr  r2, =_sbss
 802bdf8:	20000634 	.word	0x20000634
  ldr  r3, = _ebss
 802bdfc:	20004820 	.word	0x20004820

0802be00 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 802be00:	e7fe      	b.n	802be00 <ADC_IRQHandler>
	...

0802be04 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802be04:	b580      	push	{r7, lr}
 802be06:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 802be08:	4b0e      	ldr	r3, [pc, #56]	; (802be44 <HAL_Init+0x40>)
 802be0a:	681b      	ldr	r3, [r3, #0]
 802be0c:	4a0d      	ldr	r2, [pc, #52]	; (802be44 <HAL_Init+0x40>)
 802be0e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802be12:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 802be14:	4b0b      	ldr	r3, [pc, #44]	; (802be44 <HAL_Init+0x40>)
 802be16:	681b      	ldr	r3, [r3, #0]
 802be18:	4a0a      	ldr	r2, [pc, #40]	; (802be44 <HAL_Init+0x40>)
 802be1a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802be1e:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 802be20:	4b08      	ldr	r3, [pc, #32]	; (802be44 <HAL_Init+0x40>)
 802be22:	681b      	ldr	r3, [r3, #0]
 802be24:	4a07      	ldr	r2, [pc, #28]	; (802be44 <HAL_Init+0x40>)
 802be26:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802be2a:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 802be2c:	2003      	movs	r0, #3
 802be2e:	f000 f94d 	bl	802c0cc <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 802be32:	2000      	movs	r0, #0
 802be34:	f000 f808 	bl	802be48 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 802be38:	f7ff fabe 	bl	802b3b8 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 802be3c:	2300      	movs	r3, #0
}
 802be3e:	4618      	mov	r0, r3
 802be40:	bd80      	pop	{r7, pc}
 802be42:	bf00      	nop
 802be44:	40023c00 	.word	0x40023c00

0802be48 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 802be48:	b580      	push	{r7, lr}
 802be4a:	b082      	sub	sp, #8
 802be4c:	af00      	add	r7, sp, #0
 802be4e:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 802be50:	4b12      	ldr	r3, [pc, #72]	; (802be9c <HAL_InitTick+0x54>)
 802be52:	681a      	ldr	r2, [r3, #0]
 802be54:	4b12      	ldr	r3, [pc, #72]	; (802bea0 <HAL_InitTick+0x58>)
 802be56:	781b      	ldrb	r3, [r3, #0]
 802be58:	4619      	mov	r1, r3
 802be5a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 802be5e:	fbb3 f3f1 	udiv	r3, r3, r1
 802be62:	fbb2 f3f3 	udiv	r3, r2, r3
 802be66:	4618      	mov	r0, r3
 802be68:	f000 f965 	bl	802c136 <HAL_SYSTICK_Config>
 802be6c:	4603      	mov	r3, r0
 802be6e:	2b00      	cmp	r3, #0
 802be70:	d001      	beq.n	802be76 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 802be72:	2301      	movs	r3, #1
 802be74:	e00e      	b.n	802be94 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 802be76:	687b      	ldr	r3, [r7, #4]
 802be78:	2b0f      	cmp	r3, #15
 802be7a:	d80a      	bhi.n	802be92 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 802be7c:	2200      	movs	r2, #0
 802be7e:	6879      	ldr	r1, [r7, #4]
 802be80:	f04f 30ff 	mov.w	r0, #4294967295
 802be84:	f000 f92d 	bl	802c0e2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 802be88:	4a06      	ldr	r2, [pc, #24]	; (802bea4 <HAL_InitTick+0x5c>)
 802be8a:	687b      	ldr	r3, [r7, #4]
 802be8c:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 802be8e:	2300      	movs	r3, #0
 802be90:	e000      	b.n	802be94 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 802be92:	2301      	movs	r3, #1
}
 802be94:	4618      	mov	r0, r3
 802be96:	3708      	adds	r7, #8
 802be98:	46bd      	mov	sp, r7
 802be9a:	bd80      	pop	{r7, pc}
 802be9c:	200005c0 	.word	0x200005c0
 802bea0:	200005c8 	.word	0x200005c8
 802bea4:	200005c4 	.word	0x200005c4

0802bea8 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 802bea8:	b480      	push	{r7}
 802beaa:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 802beac:	4b06      	ldr	r3, [pc, #24]	; (802bec8 <HAL_IncTick+0x20>)
 802beae:	781b      	ldrb	r3, [r3, #0]
 802beb0:	461a      	mov	r2, r3
 802beb2:	4b06      	ldr	r3, [pc, #24]	; (802becc <HAL_IncTick+0x24>)
 802beb4:	681b      	ldr	r3, [r3, #0]
 802beb6:	4413      	add	r3, r2
 802beb8:	4a04      	ldr	r2, [pc, #16]	; (802becc <HAL_IncTick+0x24>)
 802beba:	6013      	str	r3, [r2, #0]
}
 802bebc:	bf00      	nop
 802bebe:	46bd      	mov	sp, r7
 802bec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bec4:	4770      	bx	lr
 802bec6:	bf00      	nop
 802bec8:	200005c8 	.word	0x200005c8
 802becc:	20004818 	.word	0x20004818

0802bed0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 802bed0:	b480      	push	{r7}
 802bed2:	af00      	add	r7, sp, #0
  return uwTick;
 802bed4:	4b03      	ldr	r3, [pc, #12]	; (802bee4 <HAL_GetTick+0x14>)
 802bed6:	681b      	ldr	r3, [r3, #0]
}
 802bed8:	4618      	mov	r0, r3
 802beda:	46bd      	mov	sp, r7
 802bedc:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bee0:	4770      	bx	lr
 802bee2:	bf00      	nop
 802bee4:	20004818 	.word	0x20004818

0802bee8 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 802bee8:	b580      	push	{r7, lr}
 802beea:	b084      	sub	sp, #16
 802beec:	af00      	add	r7, sp, #0
 802beee:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 802bef0:	f7ff ffee 	bl	802bed0 <HAL_GetTick>
 802bef4:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 802bef6:	687b      	ldr	r3, [r7, #4]
 802bef8:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 802befa:	68fb      	ldr	r3, [r7, #12]
 802befc:	f1b3 3fff 	cmp.w	r3, #4294967295
 802bf00:	d005      	beq.n	802bf0e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 802bf02:	4b09      	ldr	r3, [pc, #36]	; (802bf28 <HAL_Delay+0x40>)
 802bf04:	781b      	ldrb	r3, [r3, #0]
 802bf06:	461a      	mov	r2, r3
 802bf08:	68fb      	ldr	r3, [r7, #12]
 802bf0a:	4413      	add	r3, r2
 802bf0c:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 802bf0e:	bf00      	nop
 802bf10:	f7ff ffde 	bl	802bed0 <HAL_GetTick>
 802bf14:	4602      	mov	r2, r0
 802bf16:	68bb      	ldr	r3, [r7, #8]
 802bf18:	1ad3      	subs	r3, r2, r3
 802bf1a:	68fa      	ldr	r2, [r7, #12]
 802bf1c:	429a      	cmp	r2, r3
 802bf1e:	d8f7      	bhi.n	802bf10 <HAL_Delay+0x28>
  {
  }
}
 802bf20:	bf00      	nop
 802bf22:	3710      	adds	r7, #16
 802bf24:	46bd      	mov	sp, r7
 802bf26:	bd80      	pop	{r7, pc}
 802bf28:	200005c8 	.word	0x200005c8

0802bf2c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 802bf2c:	b480      	push	{r7}
 802bf2e:	b085      	sub	sp, #20
 802bf30:	af00      	add	r7, sp, #0
 802bf32:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 802bf34:	687b      	ldr	r3, [r7, #4]
 802bf36:	f003 0307 	and.w	r3, r3, #7
 802bf3a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802bf3c:	4b0c      	ldr	r3, [pc, #48]	; (802bf70 <__NVIC_SetPriorityGrouping+0x44>)
 802bf3e:	68db      	ldr	r3, [r3, #12]
 802bf40:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802bf42:	68ba      	ldr	r2, [r7, #8]
 802bf44:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 802bf48:	4013      	ands	r3, r2
 802bf4a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802bf4c:	68fb      	ldr	r3, [r7, #12]
 802bf4e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802bf50:	68bb      	ldr	r3, [r7, #8]
 802bf52:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802bf54:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 802bf58:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802bf5c:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 802bf5e:	4a04      	ldr	r2, [pc, #16]	; (802bf70 <__NVIC_SetPriorityGrouping+0x44>)
 802bf60:	68bb      	ldr	r3, [r7, #8]
 802bf62:	60d3      	str	r3, [r2, #12]
}
 802bf64:	bf00      	nop
 802bf66:	3714      	adds	r7, #20
 802bf68:	46bd      	mov	sp, r7
 802bf6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bf6e:	4770      	bx	lr
 802bf70:	e000ed00 	.word	0xe000ed00

0802bf74 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 802bf74:	b480      	push	{r7}
 802bf76:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802bf78:	4b04      	ldr	r3, [pc, #16]	; (802bf8c <__NVIC_GetPriorityGrouping+0x18>)
 802bf7a:	68db      	ldr	r3, [r3, #12]
 802bf7c:	0a1b      	lsrs	r3, r3, #8
 802bf7e:	f003 0307 	and.w	r3, r3, #7
}
 802bf82:	4618      	mov	r0, r3
 802bf84:	46bd      	mov	sp, r7
 802bf86:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bf8a:	4770      	bx	lr
 802bf8c:	e000ed00 	.word	0xe000ed00

0802bf90 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 802bf90:	b480      	push	{r7}
 802bf92:	b083      	sub	sp, #12
 802bf94:	af00      	add	r7, sp, #0
 802bf96:	4603      	mov	r3, r0
 802bf98:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802bf9a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802bf9e:	2b00      	cmp	r3, #0
 802bfa0:	db0b      	blt.n	802bfba <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802bfa2:	79fb      	ldrb	r3, [r7, #7]
 802bfa4:	f003 021f 	and.w	r2, r3, #31
 802bfa8:	4907      	ldr	r1, [pc, #28]	; (802bfc8 <__NVIC_EnableIRQ+0x38>)
 802bfaa:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802bfae:	095b      	lsrs	r3, r3, #5
 802bfb0:	2001      	movs	r0, #1
 802bfb2:	fa00 f202 	lsl.w	r2, r0, r2
 802bfb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 802bfba:	bf00      	nop
 802bfbc:	370c      	adds	r7, #12
 802bfbe:	46bd      	mov	sp, r7
 802bfc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bfc4:	4770      	bx	lr
 802bfc6:	bf00      	nop
 802bfc8:	e000e100 	.word	0xe000e100

0802bfcc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 802bfcc:	b480      	push	{r7}
 802bfce:	b083      	sub	sp, #12
 802bfd0:	af00      	add	r7, sp, #0
 802bfd2:	4603      	mov	r3, r0
 802bfd4:	6039      	str	r1, [r7, #0]
 802bfd6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802bfd8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802bfdc:	2b00      	cmp	r3, #0
 802bfde:	db0a      	blt.n	802bff6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802bfe0:	683b      	ldr	r3, [r7, #0]
 802bfe2:	b2da      	uxtb	r2, r3
 802bfe4:	490c      	ldr	r1, [pc, #48]	; (802c018 <__NVIC_SetPriority+0x4c>)
 802bfe6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802bfea:	0112      	lsls	r2, r2, #4
 802bfec:	b2d2      	uxtb	r2, r2
 802bfee:	440b      	add	r3, r1
 802bff0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 802bff4:	e00a      	b.n	802c00c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802bff6:	683b      	ldr	r3, [r7, #0]
 802bff8:	b2da      	uxtb	r2, r3
 802bffa:	4908      	ldr	r1, [pc, #32]	; (802c01c <__NVIC_SetPriority+0x50>)
 802bffc:	79fb      	ldrb	r3, [r7, #7]
 802bffe:	f003 030f 	and.w	r3, r3, #15
 802c002:	3b04      	subs	r3, #4
 802c004:	0112      	lsls	r2, r2, #4
 802c006:	b2d2      	uxtb	r2, r2
 802c008:	440b      	add	r3, r1
 802c00a:	761a      	strb	r2, [r3, #24]
}
 802c00c:	bf00      	nop
 802c00e:	370c      	adds	r7, #12
 802c010:	46bd      	mov	sp, r7
 802c012:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c016:	4770      	bx	lr
 802c018:	e000e100 	.word	0xe000e100
 802c01c:	e000ed00 	.word	0xe000ed00

0802c020 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 802c020:	b480      	push	{r7}
 802c022:	b089      	sub	sp, #36	; 0x24
 802c024:	af00      	add	r7, sp, #0
 802c026:	60f8      	str	r0, [r7, #12]
 802c028:	60b9      	str	r1, [r7, #8]
 802c02a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 802c02c:	68fb      	ldr	r3, [r7, #12]
 802c02e:	f003 0307 	and.w	r3, r3, #7
 802c032:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802c034:	69fb      	ldr	r3, [r7, #28]
 802c036:	f1c3 0307 	rsb	r3, r3, #7
 802c03a:	2b04      	cmp	r3, #4
 802c03c:	bf28      	it	cs
 802c03e:	2304      	movcs	r3, #4
 802c040:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802c042:	69fb      	ldr	r3, [r7, #28]
 802c044:	3304      	adds	r3, #4
 802c046:	2b06      	cmp	r3, #6
 802c048:	d902      	bls.n	802c050 <NVIC_EncodePriority+0x30>
 802c04a:	69fb      	ldr	r3, [r7, #28]
 802c04c:	3b03      	subs	r3, #3
 802c04e:	e000      	b.n	802c052 <NVIC_EncodePriority+0x32>
 802c050:	2300      	movs	r3, #0
 802c052:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802c054:	f04f 32ff 	mov.w	r2, #4294967295
 802c058:	69bb      	ldr	r3, [r7, #24]
 802c05a:	fa02 f303 	lsl.w	r3, r2, r3
 802c05e:	43da      	mvns	r2, r3
 802c060:	68bb      	ldr	r3, [r7, #8]
 802c062:	401a      	ands	r2, r3
 802c064:	697b      	ldr	r3, [r7, #20]
 802c066:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802c068:	f04f 31ff 	mov.w	r1, #4294967295
 802c06c:	697b      	ldr	r3, [r7, #20]
 802c06e:	fa01 f303 	lsl.w	r3, r1, r3
 802c072:	43d9      	mvns	r1, r3
 802c074:	687b      	ldr	r3, [r7, #4]
 802c076:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802c078:	4313      	orrs	r3, r2
         );
}
 802c07a:	4618      	mov	r0, r3
 802c07c:	3724      	adds	r7, #36	; 0x24
 802c07e:	46bd      	mov	sp, r7
 802c080:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c084:	4770      	bx	lr
	...

0802c088 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 802c088:	b580      	push	{r7, lr}
 802c08a:	b082      	sub	sp, #8
 802c08c:	af00      	add	r7, sp, #0
 802c08e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 802c090:	687b      	ldr	r3, [r7, #4]
 802c092:	3b01      	subs	r3, #1
 802c094:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 802c098:	d301      	bcc.n	802c09e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 802c09a:	2301      	movs	r3, #1
 802c09c:	e00f      	b.n	802c0be <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 802c09e:	4a0a      	ldr	r2, [pc, #40]	; (802c0c8 <SysTick_Config+0x40>)
 802c0a0:	687b      	ldr	r3, [r7, #4]
 802c0a2:	3b01      	subs	r3, #1
 802c0a4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 802c0a6:	210f      	movs	r1, #15
 802c0a8:	f04f 30ff 	mov.w	r0, #4294967295
 802c0ac:	f7ff ff8e 	bl	802bfcc <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 802c0b0:	4b05      	ldr	r3, [pc, #20]	; (802c0c8 <SysTick_Config+0x40>)
 802c0b2:	2200      	movs	r2, #0
 802c0b4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 802c0b6:	4b04      	ldr	r3, [pc, #16]	; (802c0c8 <SysTick_Config+0x40>)
 802c0b8:	2207      	movs	r2, #7
 802c0ba:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 802c0bc:	2300      	movs	r3, #0
}
 802c0be:	4618      	mov	r0, r3
 802c0c0:	3708      	adds	r7, #8
 802c0c2:	46bd      	mov	sp, r7
 802c0c4:	bd80      	pop	{r7, pc}
 802c0c6:	bf00      	nop
 802c0c8:	e000e010 	.word	0xe000e010

0802c0cc <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 802c0cc:	b580      	push	{r7, lr}
 802c0ce:	b082      	sub	sp, #8
 802c0d0:	af00      	add	r7, sp, #0
 802c0d2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 802c0d4:	6878      	ldr	r0, [r7, #4]
 802c0d6:	f7ff ff29 	bl	802bf2c <__NVIC_SetPriorityGrouping>
}
 802c0da:	bf00      	nop
 802c0dc:	3708      	adds	r7, #8
 802c0de:	46bd      	mov	sp, r7
 802c0e0:	bd80      	pop	{r7, pc}

0802c0e2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 802c0e2:	b580      	push	{r7, lr}
 802c0e4:	b086      	sub	sp, #24
 802c0e6:	af00      	add	r7, sp, #0
 802c0e8:	4603      	mov	r3, r0
 802c0ea:	60b9      	str	r1, [r7, #8]
 802c0ec:	607a      	str	r2, [r7, #4]
 802c0ee:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 802c0f0:	2300      	movs	r3, #0
 802c0f2:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 802c0f4:	f7ff ff3e 	bl	802bf74 <__NVIC_GetPriorityGrouping>
 802c0f8:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 802c0fa:	687a      	ldr	r2, [r7, #4]
 802c0fc:	68b9      	ldr	r1, [r7, #8]
 802c0fe:	6978      	ldr	r0, [r7, #20]
 802c100:	f7ff ff8e 	bl	802c020 <NVIC_EncodePriority>
 802c104:	4602      	mov	r2, r0
 802c106:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802c10a:	4611      	mov	r1, r2
 802c10c:	4618      	mov	r0, r3
 802c10e:	f7ff ff5d 	bl	802bfcc <__NVIC_SetPriority>
}
 802c112:	bf00      	nop
 802c114:	3718      	adds	r7, #24
 802c116:	46bd      	mov	sp, r7
 802c118:	bd80      	pop	{r7, pc}

0802c11a <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 802c11a:	b580      	push	{r7, lr}
 802c11c:	b082      	sub	sp, #8
 802c11e:	af00      	add	r7, sp, #0
 802c120:	4603      	mov	r3, r0
 802c122:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 802c124:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802c128:	4618      	mov	r0, r3
 802c12a:	f7ff ff31 	bl	802bf90 <__NVIC_EnableIRQ>
}
 802c12e:	bf00      	nop
 802c130:	3708      	adds	r7, #8
 802c132:	46bd      	mov	sp, r7
 802c134:	bd80      	pop	{r7, pc}

0802c136 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 802c136:	b580      	push	{r7, lr}
 802c138:	b082      	sub	sp, #8
 802c13a:	af00      	add	r7, sp, #0
 802c13c:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 802c13e:	6878      	ldr	r0, [r7, #4]
 802c140:	f7ff ffa2 	bl	802c088 <SysTick_Config>
 802c144:	4603      	mov	r3, r0
}
 802c146:	4618      	mov	r0, r3
 802c148:	3708      	adds	r7, #8
 802c14a:	46bd      	mov	sp, r7
 802c14c:	bd80      	pop	{r7, pc}
	...

0802c150 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 802c150:	b580      	push	{r7, lr}
 802c152:	b086      	sub	sp, #24
 802c154:	af00      	add	r7, sp, #0
 802c156:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 802c158:	2300      	movs	r3, #0
 802c15a:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 802c15c:	f7ff feb8 	bl	802bed0 <HAL_GetTick>
 802c160:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 802c162:	687b      	ldr	r3, [r7, #4]
 802c164:	2b00      	cmp	r3, #0
 802c166:	d101      	bne.n	802c16c <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 802c168:	2301      	movs	r3, #1
 802c16a:	e099      	b.n	802c2a0 <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 802c16c:	687b      	ldr	r3, [r7, #4]
 802c16e:	2200      	movs	r2, #0
 802c170:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 802c174:	687b      	ldr	r3, [r7, #4]
 802c176:	2202      	movs	r2, #2
 802c178:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 802c17c:	687b      	ldr	r3, [r7, #4]
 802c17e:	681b      	ldr	r3, [r3, #0]
 802c180:	681a      	ldr	r2, [r3, #0]
 802c182:	687b      	ldr	r3, [r7, #4]
 802c184:	681b      	ldr	r3, [r3, #0]
 802c186:	f022 0201 	bic.w	r2, r2, #1
 802c18a:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 802c18c:	e00f      	b.n	802c1ae <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 802c18e:	f7ff fe9f 	bl	802bed0 <HAL_GetTick>
 802c192:	4602      	mov	r2, r0
 802c194:	693b      	ldr	r3, [r7, #16]
 802c196:	1ad3      	subs	r3, r2, r3
 802c198:	2b05      	cmp	r3, #5
 802c19a:	d908      	bls.n	802c1ae <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 802c19c:	687b      	ldr	r3, [r7, #4]
 802c19e:	2220      	movs	r2, #32
 802c1a0:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 802c1a2:	687b      	ldr	r3, [r7, #4]
 802c1a4:	2203      	movs	r2, #3
 802c1a6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 802c1aa:	2303      	movs	r3, #3
 802c1ac:	e078      	b.n	802c2a0 <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 802c1ae:	687b      	ldr	r3, [r7, #4]
 802c1b0:	681b      	ldr	r3, [r3, #0]
 802c1b2:	681b      	ldr	r3, [r3, #0]
 802c1b4:	f003 0301 	and.w	r3, r3, #1
 802c1b8:	2b00      	cmp	r3, #0
 802c1ba:	d1e8      	bne.n	802c18e <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 802c1bc:	687b      	ldr	r3, [r7, #4]
 802c1be:	681b      	ldr	r3, [r3, #0]
 802c1c0:	681b      	ldr	r3, [r3, #0]
 802c1c2:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 802c1c4:	697a      	ldr	r2, [r7, #20]
 802c1c6:	4b38      	ldr	r3, [pc, #224]	; (802c2a8 <HAL_DMA_Init+0x158>)
 802c1c8:	4013      	ands	r3, r2
 802c1ca:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802c1cc:	687b      	ldr	r3, [r7, #4]
 802c1ce:	685a      	ldr	r2, [r3, #4]
 802c1d0:	687b      	ldr	r3, [r7, #4]
 802c1d2:	689b      	ldr	r3, [r3, #8]
 802c1d4:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 802c1d6:	687b      	ldr	r3, [r7, #4]
 802c1d8:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802c1da:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 802c1dc:	687b      	ldr	r3, [r7, #4]
 802c1de:	691b      	ldr	r3, [r3, #16]
 802c1e0:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802c1e2:	687b      	ldr	r3, [r7, #4]
 802c1e4:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 802c1e6:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802c1e8:	687b      	ldr	r3, [r7, #4]
 802c1ea:	699b      	ldr	r3, [r3, #24]
 802c1ec:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 802c1ee:	687b      	ldr	r3, [r7, #4]
 802c1f0:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802c1f2:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 802c1f4:	687b      	ldr	r3, [r7, #4]
 802c1f6:	6a1b      	ldr	r3, [r3, #32]
 802c1f8:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802c1fa:	697a      	ldr	r2, [r7, #20]
 802c1fc:	4313      	orrs	r3, r2
 802c1fe:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 802c200:	687b      	ldr	r3, [r7, #4]
 802c202:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802c204:	2b04      	cmp	r3, #4
 802c206:	d107      	bne.n	802c218 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 802c208:	687b      	ldr	r3, [r7, #4]
 802c20a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802c20c:	687b      	ldr	r3, [r7, #4]
 802c20e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c210:	4313      	orrs	r3, r2
 802c212:	697a      	ldr	r2, [r7, #20]
 802c214:	4313      	orrs	r3, r2
 802c216:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 802c218:	687b      	ldr	r3, [r7, #4]
 802c21a:	681b      	ldr	r3, [r3, #0]
 802c21c:	697a      	ldr	r2, [r7, #20]
 802c21e:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 802c220:	687b      	ldr	r3, [r7, #4]
 802c222:	681b      	ldr	r3, [r3, #0]
 802c224:	695b      	ldr	r3, [r3, #20]
 802c226:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 802c228:	697b      	ldr	r3, [r7, #20]
 802c22a:	f023 0307 	bic.w	r3, r3, #7
 802c22e:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 802c230:	687b      	ldr	r3, [r7, #4]
 802c232:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802c234:	697a      	ldr	r2, [r7, #20]
 802c236:	4313      	orrs	r3, r2
 802c238:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 802c23a:	687b      	ldr	r3, [r7, #4]
 802c23c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802c23e:	2b04      	cmp	r3, #4
 802c240:	d117      	bne.n	802c272 <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 802c242:	687b      	ldr	r3, [r7, #4]
 802c244:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802c246:	697a      	ldr	r2, [r7, #20]
 802c248:	4313      	orrs	r3, r2
 802c24a:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 802c24c:	687b      	ldr	r3, [r7, #4]
 802c24e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c250:	2b00      	cmp	r3, #0
 802c252:	d00e      	beq.n	802c272 <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 802c254:	6878      	ldr	r0, [r7, #4]
 802c256:	f000 fa91 	bl	802c77c <DMA_CheckFifoParam>
 802c25a:	4603      	mov	r3, r0
 802c25c:	2b00      	cmp	r3, #0
 802c25e:	d008      	beq.n	802c272 <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 802c260:	687b      	ldr	r3, [r7, #4]
 802c262:	2240      	movs	r2, #64	; 0x40
 802c264:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 802c266:	687b      	ldr	r3, [r7, #4]
 802c268:	2201      	movs	r2, #1
 802c26a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
 802c26e:	2301      	movs	r3, #1
 802c270:	e016      	b.n	802c2a0 <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 802c272:	687b      	ldr	r3, [r7, #4]
 802c274:	681b      	ldr	r3, [r3, #0]
 802c276:	697a      	ldr	r2, [r7, #20]
 802c278:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 802c27a:	6878      	ldr	r0, [r7, #4]
 802c27c:	f000 fa48 	bl	802c710 <DMA_CalcBaseAndBitshift>
 802c280:	4603      	mov	r3, r0
 802c282:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 802c284:	687b      	ldr	r3, [r7, #4]
 802c286:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c288:	223f      	movs	r2, #63	; 0x3f
 802c28a:	409a      	lsls	r2, r3
 802c28c:	68fb      	ldr	r3, [r7, #12]
 802c28e:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802c290:	687b      	ldr	r3, [r7, #4]
 802c292:	2200      	movs	r2, #0
 802c294:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 802c296:	687b      	ldr	r3, [r7, #4]
 802c298:	2201      	movs	r2, #1
 802c29a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 802c29e:	2300      	movs	r3, #0
}
 802c2a0:	4618      	mov	r0, r3
 802c2a2:	3718      	adds	r7, #24
 802c2a4:	46bd      	mov	sp, r7
 802c2a6:	bd80      	pop	{r7, pc}
 802c2a8:	f010803f 	.word	0xf010803f

0802c2ac <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802c2ac:	b580      	push	{r7, lr}
 802c2ae:	b086      	sub	sp, #24
 802c2b0:	af00      	add	r7, sp, #0
 802c2b2:	60f8      	str	r0, [r7, #12]
 802c2b4:	60b9      	str	r1, [r7, #8]
 802c2b6:	607a      	str	r2, [r7, #4]
 802c2b8:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 802c2ba:	2300      	movs	r3, #0
 802c2bc:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 802c2be:	68fb      	ldr	r3, [r7, #12]
 802c2c0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c2c2:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 802c2c4:	68fb      	ldr	r3, [r7, #12]
 802c2c6:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 802c2ca:	2b01      	cmp	r3, #1
 802c2cc:	d101      	bne.n	802c2d2 <HAL_DMA_Start_IT+0x26>
 802c2ce:	2302      	movs	r3, #2
 802c2d0:	e040      	b.n	802c354 <HAL_DMA_Start_IT+0xa8>
 802c2d2:	68fb      	ldr	r3, [r7, #12]
 802c2d4:	2201      	movs	r2, #1
 802c2d6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 802c2da:	68fb      	ldr	r3, [r7, #12]
 802c2dc:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 802c2e0:	b2db      	uxtb	r3, r3
 802c2e2:	2b01      	cmp	r3, #1
 802c2e4:	d12f      	bne.n	802c346 <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 802c2e6:	68fb      	ldr	r3, [r7, #12]
 802c2e8:	2202      	movs	r2, #2
 802c2ea:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802c2ee:	68fb      	ldr	r3, [r7, #12]
 802c2f0:	2200      	movs	r2, #0
 802c2f2:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 802c2f4:	683b      	ldr	r3, [r7, #0]
 802c2f6:	687a      	ldr	r2, [r7, #4]
 802c2f8:	68b9      	ldr	r1, [r7, #8]
 802c2fa:	68f8      	ldr	r0, [r7, #12]
 802c2fc:	f000 f9da 	bl	802c6b4 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 802c300:	68fb      	ldr	r3, [r7, #12]
 802c302:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c304:	223f      	movs	r2, #63	; 0x3f
 802c306:	409a      	lsls	r2, r3
 802c308:	693b      	ldr	r3, [r7, #16]
 802c30a:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 802c30c:	68fb      	ldr	r3, [r7, #12]
 802c30e:	681b      	ldr	r3, [r3, #0]
 802c310:	681a      	ldr	r2, [r3, #0]
 802c312:	68fb      	ldr	r3, [r7, #12]
 802c314:	681b      	ldr	r3, [r3, #0]
 802c316:	f042 0216 	orr.w	r2, r2, #22
 802c31a:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 802c31c:	68fb      	ldr	r3, [r7, #12]
 802c31e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c320:	2b00      	cmp	r3, #0
 802c322:	d007      	beq.n	802c334 <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 802c324:	68fb      	ldr	r3, [r7, #12]
 802c326:	681b      	ldr	r3, [r3, #0]
 802c328:	681a      	ldr	r2, [r3, #0]
 802c32a:	68fb      	ldr	r3, [r7, #12]
 802c32c:	681b      	ldr	r3, [r3, #0]
 802c32e:	f042 0208 	orr.w	r2, r2, #8
 802c332:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 802c334:	68fb      	ldr	r3, [r7, #12]
 802c336:	681b      	ldr	r3, [r3, #0]
 802c338:	681a      	ldr	r2, [r3, #0]
 802c33a:	68fb      	ldr	r3, [r7, #12]
 802c33c:	681b      	ldr	r3, [r3, #0]
 802c33e:	f042 0201 	orr.w	r2, r2, #1
 802c342:	601a      	str	r2, [r3, #0]
 802c344:	e005      	b.n	802c352 <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 802c346:	68fb      	ldr	r3, [r7, #12]
 802c348:	2200      	movs	r2, #0
 802c34a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 802c34e:	2302      	movs	r3, #2
 802c350:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 802c352:	7dfb      	ldrb	r3, [r7, #23]
}
 802c354:	4618      	mov	r0, r3
 802c356:	3718      	adds	r7, #24
 802c358:	46bd      	mov	sp, r7
 802c35a:	bd80      	pop	{r7, pc}

0802c35c <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 802c35c:	b480      	push	{r7}
 802c35e:	b083      	sub	sp, #12
 802c360:	af00      	add	r7, sp, #0
 802c362:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 802c364:	687b      	ldr	r3, [r7, #4]
 802c366:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 802c36a:	b2db      	uxtb	r3, r3
 802c36c:	2b02      	cmp	r3, #2
 802c36e:	d004      	beq.n	802c37a <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802c370:	687b      	ldr	r3, [r7, #4]
 802c372:	2280      	movs	r2, #128	; 0x80
 802c374:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 802c376:	2301      	movs	r3, #1
 802c378:	e00c      	b.n	802c394 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 802c37a:	687b      	ldr	r3, [r7, #4]
 802c37c:	2205      	movs	r2, #5
 802c37e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 802c382:	687b      	ldr	r3, [r7, #4]
 802c384:	681b      	ldr	r3, [r3, #0]
 802c386:	681a      	ldr	r2, [r3, #0]
 802c388:	687b      	ldr	r3, [r7, #4]
 802c38a:	681b      	ldr	r3, [r3, #0]
 802c38c:	f022 0201 	bic.w	r2, r2, #1
 802c390:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 802c392:	2300      	movs	r3, #0
}
 802c394:	4618      	mov	r0, r3
 802c396:	370c      	adds	r7, #12
 802c398:	46bd      	mov	sp, r7
 802c39a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c39e:	4770      	bx	lr

0802c3a0 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 802c3a0:	b580      	push	{r7, lr}
 802c3a2:	b086      	sub	sp, #24
 802c3a4:	af00      	add	r7, sp, #0
 802c3a6:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
 802c3a8:	2300      	movs	r3, #0
 802c3aa:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 802c3ac:	4b92      	ldr	r3, [pc, #584]	; (802c5f8 <HAL_DMA_IRQHandler+0x258>)
 802c3ae:	681b      	ldr	r3, [r3, #0]
 802c3b0:	4a92      	ldr	r2, [pc, #584]	; (802c5fc <HAL_DMA_IRQHandler+0x25c>)
 802c3b2:	fba2 2303 	umull	r2, r3, r2, r3
 802c3b6:	0a9b      	lsrs	r3, r3, #10
 802c3b8:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 802c3ba:	687b      	ldr	r3, [r7, #4]
 802c3bc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c3be:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 802c3c0:	693b      	ldr	r3, [r7, #16]
 802c3c2:	681b      	ldr	r3, [r3, #0]
 802c3c4:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 802c3c6:	687b      	ldr	r3, [r7, #4]
 802c3c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c3ca:	2208      	movs	r2, #8
 802c3cc:	409a      	lsls	r2, r3
 802c3ce:	68fb      	ldr	r3, [r7, #12]
 802c3d0:	4013      	ands	r3, r2
 802c3d2:	2b00      	cmp	r3, #0
 802c3d4:	d01a      	beq.n	802c40c <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 802c3d6:	687b      	ldr	r3, [r7, #4]
 802c3d8:	681b      	ldr	r3, [r3, #0]
 802c3da:	681b      	ldr	r3, [r3, #0]
 802c3dc:	f003 0304 	and.w	r3, r3, #4
 802c3e0:	2b00      	cmp	r3, #0
 802c3e2:	d013      	beq.n	802c40c <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 802c3e4:	687b      	ldr	r3, [r7, #4]
 802c3e6:	681b      	ldr	r3, [r3, #0]
 802c3e8:	681a      	ldr	r2, [r3, #0]
 802c3ea:	687b      	ldr	r3, [r7, #4]
 802c3ec:	681b      	ldr	r3, [r3, #0]
 802c3ee:	f022 0204 	bic.w	r2, r2, #4
 802c3f2:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 802c3f4:	687b      	ldr	r3, [r7, #4]
 802c3f6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c3f8:	2208      	movs	r2, #8
 802c3fa:	409a      	lsls	r2, r3
 802c3fc:	693b      	ldr	r3, [r7, #16]
 802c3fe:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 802c400:	687b      	ldr	r3, [r7, #4]
 802c402:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802c404:	f043 0201 	orr.w	r2, r3, #1
 802c408:	687b      	ldr	r3, [r7, #4]
 802c40a:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 802c40c:	687b      	ldr	r3, [r7, #4]
 802c40e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c410:	2201      	movs	r2, #1
 802c412:	409a      	lsls	r2, r3
 802c414:	68fb      	ldr	r3, [r7, #12]
 802c416:	4013      	ands	r3, r2
 802c418:	2b00      	cmp	r3, #0
 802c41a:	d012      	beq.n	802c442 <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 802c41c:	687b      	ldr	r3, [r7, #4]
 802c41e:	681b      	ldr	r3, [r3, #0]
 802c420:	695b      	ldr	r3, [r3, #20]
 802c422:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802c426:	2b00      	cmp	r3, #0
 802c428:	d00b      	beq.n	802c442 <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 802c42a:	687b      	ldr	r3, [r7, #4]
 802c42c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c42e:	2201      	movs	r2, #1
 802c430:	409a      	lsls	r2, r3
 802c432:	693b      	ldr	r3, [r7, #16]
 802c434:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 802c436:	687b      	ldr	r3, [r7, #4]
 802c438:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802c43a:	f043 0202 	orr.w	r2, r3, #2
 802c43e:	687b      	ldr	r3, [r7, #4]
 802c440:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 802c442:	687b      	ldr	r3, [r7, #4]
 802c444:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c446:	2204      	movs	r2, #4
 802c448:	409a      	lsls	r2, r3
 802c44a:	68fb      	ldr	r3, [r7, #12]
 802c44c:	4013      	ands	r3, r2
 802c44e:	2b00      	cmp	r3, #0
 802c450:	d012      	beq.n	802c478 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 802c452:	687b      	ldr	r3, [r7, #4]
 802c454:	681b      	ldr	r3, [r3, #0]
 802c456:	681b      	ldr	r3, [r3, #0]
 802c458:	f003 0302 	and.w	r3, r3, #2
 802c45c:	2b00      	cmp	r3, #0
 802c45e:	d00b      	beq.n	802c478 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 802c460:	687b      	ldr	r3, [r7, #4]
 802c462:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c464:	2204      	movs	r2, #4
 802c466:	409a      	lsls	r2, r3
 802c468:	693b      	ldr	r3, [r7, #16]
 802c46a:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 802c46c:	687b      	ldr	r3, [r7, #4]
 802c46e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802c470:	f043 0204 	orr.w	r2, r3, #4
 802c474:	687b      	ldr	r3, [r7, #4]
 802c476:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 802c478:	687b      	ldr	r3, [r7, #4]
 802c47a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c47c:	2210      	movs	r2, #16
 802c47e:	409a      	lsls	r2, r3
 802c480:	68fb      	ldr	r3, [r7, #12]
 802c482:	4013      	ands	r3, r2
 802c484:	2b00      	cmp	r3, #0
 802c486:	d043      	beq.n	802c510 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 802c488:	687b      	ldr	r3, [r7, #4]
 802c48a:	681b      	ldr	r3, [r3, #0]
 802c48c:	681b      	ldr	r3, [r3, #0]
 802c48e:	f003 0308 	and.w	r3, r3, #8
 802c492:	2b00      	cmp	r3, #0
 802c494:	d03c      	beq.n	802c510 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 802c496:	687b      	ldr	r3, [r7, #4]
 802c498:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c49a:	2210      	movs	r2, #16
 802c49c:	409a      	lsls	r2, r3
 802c49e:	693b      	ldr	r3, [r7, #16]
 802c4a0:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 802c4a2:	687b      	ldr	r3, [r7, #4]
 802c4a4:	681b      	ldr	r3, [r3, #0]
 802c4a6:	681b      	ldr	r3, [r3, #0]
 802c4a8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 802c4ac:	2b00      	cmp	r3, #0
 802c4ae:	d018      	beq.n	802c4e2 <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 802c4b0:	687b      	ldr	r3, [r7, #4]
 802c4b2:	681b      	ldr	r3, [r3, #0]
 802c4b4:	681b      	ldr	r3, [r3, #0]
 802c4b6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 802c4ba:	2b00      	cmp	r3, #0
 802c4bc:	d108      	bne.n	802c4d0 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 802c4be:	687b      	ldr	r3, [r7, #4]
 802c4c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c4c2:	2b00      	cmp	r3, #0
 802c4c4:	d024      	beq.n	802c510 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 802c4c6:	687b      	ldr	r3, [r7, #4]
 802c4c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c4ca:	6878      	ldr	r0, [r7, #4]
 802c4cc:	4798      	blx	r3
 802c4ce:	e01f      	b.n	802c510 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 802c4d0:	687b      	ldr	r3, [r7, #4]
 802c4d2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c4d4:	2b00      	cmp	r3, #0
 802c4d6:	d01b      	beq.n	802c510 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 802c4d8:	687b      	ldr	r3, [r7, #4]
 802c4da:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c4dc:	6878      	ldr	r0, [r7, #4]
 802c4de:	4798      	blx	r3
 802c4e0:	e016      	b.n	802c510 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 802c4e2:	687b      	ldr	r3, [r7, #4]
 802c4e4:	681b      	ldr	r3, [r3, #0]
 802c4e6:	681b      	ldr	r3, [r3, #0]
 802c4e8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802c4ec:	2b00      	cmp	r3, #0
 802c4ee:	d107      	bne.n	802c500 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 802c4f0:	687b      	ldr	r3, [r7, #4]
 802c4f2:	681b      	ldr	r3, [r3, #0]
 802c4f4:	681a      	ldr	r2, [r3, #0]
 802c4f6:	687b      	ldr	r3, [r7, #4]
 802c4f8:	681b      	ldr	r3, [r3, #0]
 802c4fa:	f022 0208 	bic.w	r2, r2, #8
 802c4fe:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 802c500:	687b      	ldr	r3, [r7, #4]
 802c502:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c504:	2b00      	cmp	r3, #0
 802c506:	d003      	beq.n	802c510 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 802c508:	687b      	ldr	r3, [r7, #4]
 802c50a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c50c:	6878      	ldr	r0, [r7, #4]
 802c50e:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 802c510:	687b      	ldr	r3, [r7, #4]
 802c512:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c514:	2220      	movs	r2, #32
 802c516:	409a      	lsls	r2, r3
 802c518:	68fb      	ldr	r3, [r7, #12]
 802c51a:	4013      	ands	r3, r2
 802c51c:	2b00      	cmp	r3, #0
 802c51e:	f000 808e 	beq.w	802c63e <HAL_DMA_IRQHandler+0x29e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 802c522:	687b      	ldr	r3, [r7, #4]
 802c524:	681b      	ldr	r3, [r3, #0]
 802c526:	681b      	ldr	r3, [r3, #0]
 802c528:	f003 0310 	and.w	r3, r3, #16
 802c52c:	2b00      	cmp	r3, #0
 802c52e:	f000 8086 	beq.w	802c63e <HAL_DMA_IRQHandler+0x29e>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 802c532:	687b      	ldr	r3, [r7, #4]
 802c534:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c536:	2220      	movs	r2, #32
 802c538:	409a      	lsls	r2, r3
 802c53a:	693b      	ldr	r3, [r7, #16]
 802c53c:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 802c53e:	687b      	ldr	r3, [r7, #4]
 802c540:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 802c544:	b2db      	uxtb	r3, r3
 802c546:	2b05      	cmp	r3, #5
 802c548:	d136      	bne.n	802c5b8 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 802c54a:	687b      	ldr	r3, [r7, #4]
 802c54c:	681b      	ldr	r3, [r3, #0]
 802c54e:	681a      	ldr	r2, [r3, #0]
 802c550:	687b      	ldr	r3, [r7, #4]
 802c552:	681b      	ldr	r3, [r3, #0]
 802c554:	f022 0216 	bic.w	r2, r2, #22
 802c558:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 802c55a:	687b      	ldr	r3, [r7, #4]
 802c55c:	681b      	ldr	r3, [r3, #0]
 802c55e:	695a      	ldr	r2, [r3, #20]
 802c560:	687b      	ldr	r3, [r7, #4]
 802c562:	681b      	ldr	r3, [r3, #0]
 802c564:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802c568:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 802c56a:	687b      	ldr	r3, [r7, #4]
 802c56c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c56e:	2b00      	cmp	r3, #0
 802c570:	d103      	bne.n	802c57a <HAL_DMA_IRQHandler+0x1da>
 802c572:	687b      	ldr	r3, [r7, #4]
 802c574:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802c576:	2b00      	cmp	r3, #0
 802c578:	d007      	beq.n	802c58a <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 802c57a:	687b      	ldr	r3, [r7, #4]
 802c57c:	681b      	ldr	r3, [r3, #0]
 802c57e:	681a      	ldr	r2, [r3, #0]
 802c580:	687b      	ldr	r3, [r7, #4]
 802c582:	681b      	ldr	r3, [r3, #0]
 802c584:	f022 0208 	bic.w	r2, r2, #8
 802c588:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 802c58a:	687b      	ldr	r3, [r7, #4]
 802c58c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802c58e:	223f      	movs	r2, #63	; 0x3f
 802c590:	409a      	lsls	r2, r3
 802c592:	693b      	ldr	r3, [r7, #16]
 802c594:	609a      	str	r2, [r3, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 802c596:	687b      	ldr	r3, [r7, #4]
 802c598:	2200      	movs	r2, #0
 802c59a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 802c59e:	687b      	ldr	r3, [r7, #4]
 802c5a0:	2201      	movs	r2, #1
 802c5a2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
 802c5a6:	687b      	ldr	r3, [r7, #4]
 802c5a8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802c5aa:	2b00      	cmp	r3, #0
 802c5ac:	d07d      	beq.n	802c6aa <HAL_DMA_IRQHandler+0x30a>
        {
          hdma->XferAbortCallback(hdma);
 802c5ae:	687b      	ldr	r3, [r7, #4]
 802c5b0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802c5b2:	6878      	ldr	r0, [r7, #4]
 802c5b4:	4798      	blx	r3
        }
        return;
 802c5b6:	e078      	b.n	802c6aa <HAL_DMA_IRQHandler+0x30a>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 802c5b8:	687b      	ldr	r3, [r7, #4]
 802c5ba:	681b      	ldr	r3, [r3, #0]
 802c5bc:	681b      	ldr	r3, [r3, #0]
 802c5be:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 802c5c2:	2b00      	cmp	r3, #0
 802c5c4:	d01c      	beq.n	802c600 <HAL_DMA_IRQHandler+0x260>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 802c5c6:	687b      	ldr	r3, [r7, #4]
 802c5c8:	681b      	ldr	r3, [r3, #0]
 802c5ca:	681b      	ldr	r3, [r3, #0]
 802c5cc:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 802c5d0:	2b00      	cmp	r3, #0
 802c5d2:	d108      	bne.n	802c5e6 <HAL_DMA_IRQHandler+0x246>
        {
          if(hdma->XferM1CpltCallback != NULL)
 802c5d4:	687b      	ldr	r3, [r7, #4]
 802c5d6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802c5d8:	2b00      	cmp	r3, #0
 802c5da:	d030      	beq.n	802c63e <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 802c5dc:	687b      	ldr	r3, [r7, #4]
 802c5de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802c5e0:	6878      	ldr	r0, [r7, #4]
 802c5e2:	4798      	blx	r3
 802c5e4:	e02b      	b.n	802c63e <HAL_DMA_IRQHandler+0x29e>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 802c5e6:	687b      	ldr	r3, [r7, #4]
 802c5e8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802c5ea:	2b00      	cmp	r3, #0
 802c5ec:	d027      	beq.n	802c63e <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 802c5ee:	687b      	ldr	r3, [r7, #4]
 802c5f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802c5f2:	6878      	ldr	r0, [r7, #4]
 802c5f4:	4798      	blx	r3
 802c5f6:	e022      	b.n	802c63e <HAL_DMA_IRQHandler+0x29e>
 802c5f8:	200005c0 	.word	0x200005c0
 802c5fc:	1b4e81b5 	.word	0x1b4e81b5
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 802c600:	687b      	ldr	r3, [r7, #4]
 802c602:	681b      	ldr	r3, [r3, #0]
 802c604:	681b      	ldr	r3, [r3, #0]
 802c606:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802c60a:	2b00      	cmp	r3, #0
 802c60c:	d10f      	bne.n	802c62e <HAL_DMA_IRQHandler+0x28e>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 802c60e:	687b      	ldr	r3, [r7, #4]
 802c610:	681b      	ldr	r3, [r3, #0]
 802c612:	681a      	ldr	r2, [r3, #0]
 802c614:	687b      	ldr	r3, [r7, #4]
 802c616:	681b      	ldr	r3, [r3, #0]
 802c618:	f022 0210 	bic.w	r2, r2, #16
 802c61c:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 802c61e:	687b      	ldr	r3, [r7, #4]
 802c620:	2200      	movs	r2, #0
 802c622:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 802c626:	687b      	ldr	r3, [r7, #4]
 802c628:	2201      	movs	r2, #1
 802c62a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
 802c62e:	687b      	ldr	r3, [r7, #4]
 802c630:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802c632:	2b00      	cmp	r3, #0
 802c634:	d003      	beq.n	802c63e <HAL_DMA_IRQHandler+0x29e>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 802c636:	687b      	ldr	r3, [r7, #4]
 802c638:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802c63a:	6878      	ldr	r0, [r7, #4]
 802c63c:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 802c63e:	687b      	ldr	r3, [r7, #4]
 802c640:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802c642:	2b00      	cmp	r3, #0
 802c644:	d032      	beq.n	802c6ac <HAL_DMA_IRQHandler+0x30c>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 802c646:	687b      	ldr	r3, [r7, #4]
 802c648:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802c64a:	f003 0301 	and.w	r3, r3, #1
 802c64e:	2b00      	cmp	r3, #0
 802c650:	d022      	beq.n	802c698 <HAL_DMA_IRQHandler+0x2f8>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 802c652:	687b      	ldr	r3, [r7, #4]
 802c654:	2205      	movs	r2, #5
 802c656:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 802c65a:	687b      	ldr	r3, [r7, #4]
 802c65c:	681b      	ldr	r3, [r3, #0]
 802c65e:	681a      	ldr	r2, [r3, #0]
 802c660:	687b      	ldr	r3, [r7, #4]
 802c662:	681b      	ldr	r3, [r3, #0]
 802c664:	f022 0201 	bic.w	r2, r2, #1
 802c668:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 802c66a:	68bb      	ldr	r3, [r7, #8]
 802c66c:	3301      	adds	r3, #1
 802c66e:	60bb      	str	r3, [r7, #8]
 802c670:	697a      	ldr	r2, [r7, #20]
 802c672:	429a      	cmp	r2, r3
 802c674:	d307      	bcc.n	802c686 <HAL_DMA_IRQHandler+0x2e6>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 802c676:	687b      	ldr	r3, [r7, #4]
 802c678:	681b      	ldr	r3, [r3, #0]
 802c67a:	681b      	ldr	r3, [r3, #0]
 802c67c:	f003 0301 	and.w	r3, r3, #1
 802c680:	2b00      	cmp	r3, #0
 802c682:	d1f2      	bne.n	802c66a <HAL_DMA_IRQHandler+0x2ca>
 802c684:	e000      	b.n	802c688 <HAL_DMA_IRQHandler+0x2e8>
          break;
 802c686:	bf00      	nop

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 802c688:	687b      	ldr	r3, [r7, #4]
 802c68a:	2200      	movs	r2, #0
 802c68c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 802c690:	687b      	ldr	r3, [r7, #4]
 802c692:	2201      	movs	r2, #1
 802c694:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
 802c698:	687b      	ldr	r3, [r7, #4]
 802c69a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802c69c:	2b00      	cmp	r3, #0
 802c69e:	d005      	beq.n	802c6ac <HAL_DMA_IRQHandler+0x30c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 802c6a0:	687b      	ldr	r3, [r7, #4]
 802c6a2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802c6a4:	6878      	ldr	r0, [r7, #4]
 802c6a6:	4798      	blx	r3
 802c6a8:	e000      	b.n	802c6ac <HAL_DMA_IRQHandler+0x30c>
        return;
 802c6aa:	bf00      	nop
    }
  }
}
 802c6ac:	3718      	adds	r7, #24
 802c6ae:	46bd      	mov	sp, r7
 802c6b0:	bd80      	pop	{r7, pc}
 802c6b2:	bf00      	nop

0802c6b4 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802c6b4:	b480      	push	{r7}
 802c6b6:	b085      	sub	sp, #20
 802c6b8:	af00      	add	r7, sp, #0
 802c6ba:	60f8      	str	r0, [r7, #12]
 802c6bc:	60b9      	str	r1, [r7, #8]
 802c6be:	607a      	str	r2, [r7, #4]
 802c6c0:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 802c6c2:	68fb      	ldr	r3, [r7, #12]
 802c6c4:	681b      	ldr	r3, [r3, #0]
 802c6c6:	681a      	ldr	r2, [r3, #0]
 802c6c8:	68fb      	ldr	r3, [r7, #12]
 802c6ca:	681b      	ldr	r3, [r3, #0]
 802c6cc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 802c6d0:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 802c6d2:	68fb      	ldr	r3, [r7, #12]
 802c6d4:	681b      	ldr	r3, [r3, #0]
 802c6d6:	683a      	ldr	r2, [r7, #0]
 802c6d8:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 802c6da:	68fb      	ldr	r3, [r7, #12]
 802c6dc:	689b      	ldr	r3, [r3, #8]
 802c6de:	2b40      	cmp	r3, #64	; 0x40
 802c6e0:	d108      	bne.n	802c6f4 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 802c6e2:	68fb      	ldr	r3, [r7, #12]
 802c6e4:	681b      	ldr	r3, [r3, #0]
 802c6e6:	687a      	ldr	r2, [r7, #4]
 802c6e8:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 802c6ea:	68fb      	ldr	r3, [r7, #12]
 802c6ec:	681b      	ldr	r3, [r3, #0]
 802c6ee:	68ba      	ldr	r2, [r7, #8]
 802c6f0:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 802c6f2:	e007      	b.n	802c704 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 802c6f4:	68fb      	ldr	r3, [r7, #12]
 802c6f6:	681b      	ldr	r3, [r3, #0]
 802c6f8:	68ba      	ldr	r2, [r7, #8]
 802c6fa:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 802c6fc:	68fb      	ldr	r3, [r7, #12]
 802c6fe:	681b      	ldr	r3, [r3, #0]
 802c700:	687a      	ldr	r2, [r7, #4]
 802c702:	60da      	str	r2, [r3, #12]
}
 802c704:	bf00      	nop
 802c706:	3714      	adds	r7, #20
 802c708:	46bd      	mov	sp, r7
 802c70a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c70e:	4770      	bx	lr

0802c710 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 802c710:	b480      	push	{r7}
 802c712:	b085      	sub	sp, #20
 802c714:	af00      	add	r7, sp, #0
 802c716:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 802c718:	687b      	ldr	r3, [r7, #4]
 802c71a:	681b      	ldr	r3, [r3, #0]
 802c71c:	b2db      	uxtb	r3, r3
 802c71e:	3b10      	subs	r3, #16
 802c720:	4a14      	ldr	r2, [pc, #80]	; (802c774 <DMA_CalcBaseAndBitshift+0x64>)
 802c722:	fba2 2303 	umull	r2, r3, r2, r3
 802c726:	091b      	lsrs	r3, r3, #4
 802c728:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 802c72a:	4a13      	ldr	r2, [pc, #76]	; (802c778 <DMA_CalcBaseAndBitshift+0x68>)
 802c72c:	68fb      	ldr	r3, [r7, #12]
 802c72e:	4413      	add	r3, r2
 802c730:	781b      	ldrb	r3, [r3, #0]
 802c732:	461a      	mov	r2, r3
 802c734:	687b      	ldr	r3, [r7, #4]
 802c736:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
 802c738:	68fb      	ldr	r3, [r7, #12]
 802c73a:	2b03      	cmp	r3, #3
 802c73c:	d909      	bls.n	802c752 <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 802c73e:	687b      	ldr	r3, [r7, #4]
 802c740:	681b      	ldr	r3, [r3, #0]
 802c742:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 802c746:	f023 0303 	bic.w	r3, r3, #3
 802c74a:	1d1a      	adds	r2, r3, #4
 802c74c:	687b      	ldr	r3, [r7, #4]
 802c74e:	659a      	str	r2, [r3, #88]	; 0x58
 802c750:	e007      	b.n	802c762 <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 802c752:	687b      	ldr	r3, [r7, #4]
 802c754:	681b      	ldr	r3, [r3, #0]
 802c756:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 802c75a:	f023 0303 	bic.w	r3, r3, #3
 802c75e:	687a      	ldr	r2, [r7, #4]
 802c760:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
 802c762:	687b      	ldr	r3, [r7, #4]
 802c764:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
 802c766:	4618      	mov	r0, r3
 802c768:	3714      	adds	r7, #20
 802c76a:	46bd      	mov	sp, r7
 802c76c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c770:	4770      	bx	lr
 802c772:	bf00      	nop
 802c774:	aaaaaaab 	.word	0xaaaaaaab
 802c778:	08030ef4 	.word	0x08030ef4

0802c77c <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 802c77c:	b480      	push	{r7}
 802c77e:	b085      	sub	sp, #20
 802c780:	af00      	add	r7, sp, #0
 802c782:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 802c784:	2300      	movs	r3, #0
 802c786:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 802c788:	687b      	ldr	r3, [r7, #4]
 802c78a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802c78c:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 802c78e:	687b      	ldr	r3, [r7, #4]
 802c790:	699b      	ldr	r3, [r3, #24]
 802c792:	2b00      	cmp	r3, #0
 802c794:	d11f      	bne.n	802c7d6 <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 802c796:	68bb      	ldr	r3, [r7, #8]
 802c798:	2b03      	cmp	r3, #3
 802c79a:	d855      	bhi.n	802c848 <DMA_CheckFifoParam+0xcc>
 802c79c:	a201      	add	r2, pc, #4	; (adr r2, 802c7a4 <DMA_CheckFifoParam+0x28>)
 802c79e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802c7a2:	bf00      	nop
 802c7a4:	0802c7b5 	.word	0x0802c7b5
 802c7a8:	0802c7c7 	.word	0x0802c7c7
 802c7ac:	0802c7b5 	.word	0x0802c7b5
 802c7b0:	0802c849 	.word	0x0802c849
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802c7b4:	687b      	ldr	r3, [r7, #4]
 802c7b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c7b8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 802c7bc:	2b00      	cmp	r3, #0
 802c7be:	d045      	beq.n	802c84c <DMA_CheckFifoParam+0xd0>
      {
        status = HAL_ERROR;
 802c7c0:	2301      	movs	r3, #1
 802c7c2:	73fb      	strb	r3, [r7, #15]
      }
      break;
 802c7c4:	e042      	b.n	802c84c <DMA_CheckFifoParam+0xd0>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 802c7c6:	687b      	ldr	r3, [r7, #4]
 802c7c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c7ca:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 802c7ce:	d13f      	bne.n	802c850 <DMA_CheckFifoParam+0xd4>
      {
        status = HAL_ERROR;
 802c7d0:	2301      	movs	r3, #1
 802c7d2:	73fb      	strb	r3, [r7, #15]
      }
      break;
 802c7d4:	e03c      	b.n	802c850 <DMA_CheckFifoParam+0xd4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 802c7d6:	687b      	ldr	r3, [r7, #4]
 802c7d8:	699b      	ldr	r3, [r3, #24]
 802c7da:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 802c7de:	d121      	bne.n	802c824 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 802c7e0:	68bb      	ldr	r3, [r7, #8]
 802c7e2:	2b03      	cmp	r3, #3
 802c7e4:	d836      	bhi.n	802c854 <DMA_CheckFifoParam+0xd8>
 802c7e6:	a201      	add	r2, pc, #4	; (adr r2, 802c7ec <DMA_CheckFifoParam+0x70>)
 802c7e8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802c7ec:	0802c7fd 	.word	0x0802c7fd
 802c7f0:	0802c803 	.word	0x0802c803
 802c7f4:	0802c7fd 	.word	0x0802c7fd
 802c7f8:	0802c815 	.word	0x0802c815
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 802c7fc:	2301      	movs	r3, #1
 802c7fe:	73fb      	strb	r3, [r7, #15]
      break;
 802c800:	e02f      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802c802:	687b      	ldr	r3, [r7, #4]
 802c804:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c806:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 802c80a:	2b00      	cmp	r3, #0
 802c80c:	d024      	beq.n	802c858 <DMA_CheckFifoParam+0xdc>
      {
        status = HAL_ERROR;
 802c80e:	2301      	movs	r3, #1
 802c810:	73fb      	strb	r3, [r7, #15]
      }
      break;
 802c812:	e021      	b.n	802c858 <DMA_CheckFifoParam+0xdc>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 802c814:	687b      	ldr	r3, [r7, #4]
 802c816:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c818:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 802c81c:	d11e      	bne.n	802c85c <DMA_CheckFifoParam+0xe0>
      {
        status = HAL_ERROR;
 802c81e:	2301      	movs	r3, #1
 802c820:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 802c822:	e01b      	b.n	802c85c <DMA_CheckFifoParam+0xe0>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 802c824:	68bb      	ldr	r3, [r7, #8]
 802c826:	2b02      	cmp	r3, #2
 802c828:	d902      	bls.n	802c830 <DMA_CheckFifoParam+0xb4>
 802c82a:	2b03      	cmp	r3, #3
 802c82c:	d003      	beq.n	802c836 <DMA_CheckFifoParam+0xba>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 802c82e:	e018      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      status = HAL_ERROR;
 802c830:	2301      	movs	r3, #1
 802c832:	73fb      	strb	r3, [r7, #15]
      break;
 802c834:	e015      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802c836:	687b      	ldr	r3, [r7, #4]
 802c838:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c83a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 802c83e:	2b00      	cmp	r3, #0
 802c840:	d00e      	beq.n	802c860 <DMA_CheckFifoParam+0xe4>
        status = HAL_ERROR;
 802c842:	2301      	movs	r3, #1
 802c844:	73fb      	strb	r3, [r7, #15]
      break;
 802c846:	e00b      	b.n	802c860 <DMA_CheckFifoParam+0xe4>
      break;
 802c848:	bf00      	nop
 802c84a:	e00a      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      break;
 802c84c:	bf00      	nop
 802c84e:	e008      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      break;
 802c850:	bf00      	nop
 802c852:	e006      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      break;
 802c854:	bf00      	nop
 802c856:	e004      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      break;
 802c858:	bf00      	nop
 802c85a:	e002      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      break;   
 802c85c:	bf00      	nop
 802c85e:	e000      	b.n	802c862 <DMA_CheckFifoParam+0xe6>
      break;
 802c860:	bf00      	nop
    }
  } 
  
  return status; 
 802c862:	7bfb      	ldrb	r3, [r7, #15]
}
 802c864:	4618      	mov	r0, r3
 802c866:	3714      	adds	r7, #20
 802c868:	46bd      	mov	sp, r7
 802c86a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c86e:	4770      	bx	lr

0802c870 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 802c870:	b480      	push	{r7}
 802c872:	b089      	sub	sp, #36	; 0x24
 802c874:	af00      	add	r7, sp, #0
 802c876:	6078      	str	r0, [r7, #4]
 802c878:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 802c87a:	2300      	movs	r3, #0
 802c87c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 802c87e:	2300      	movs	r3, #0
 802c880:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 802c882:	2300      	movs	r3, #0
 802c884:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 802c886:	2300      	movs	r3, #0
 802c888:	61fb      	str	r3, [r7, #28]
 802c88a:	e159      	b.n	802cb40 <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 802c88c:	2201      	movs	r2, #1
 802c88e:	69fb      	ldr	r3, [r7, #28]
 802c890:	fa02 f303 	lsl.w	r3, r2, r3
 802c894:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 802c896:	683b      	ldr	r3, [r7, #0]
 802c898:	681b      	ldr	r3, [r3, #0]
 802c89a:	697a      	ldr	r2, [r7, #20]
 802c89c:	4013      	ands	r3, r2
 802c89e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 802c8a0:	693a      	ldr	r2, [r7, #16]
 802c8a2:	697b      	ldr	r3, [r7, #20]
 802c8a4:	429a      	cmp	r2, r3
 802c8a6:	f040 8148 	bne.w	802cb3a <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 802c8aa:	683b      	ldr	r3, [r7, #0]
 802c8ac:	685b      	ldr	r3, [r3, #4]
 802c8ae:	2b01      	cmp	r3, #1
 802c8b0:	d00b      	beq.n	802c8ca <HAL_GPIO_Init+0x5a>
 802c8b2:	683b      	ldr	r3, [r7, #0]
 802c8b4:	685b      	ldr	r3, [r3, #4]
 802c8b6:	2b02      	cmp	r3, #2
 802c8b8:	d007      	beq.n	802c8ca <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 802c8ba:	683b      	ldr	r3, [r7, #0]
 802c8bc:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 802c8be:	2b11      	cmp	r3, #17
 802c8c0:	d003      	beq.n	802c8ca <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 802c8c2:	683b      	ldr	r3, [r7, #0]
 802c8c4:	685b      	ldr	r3, [r3, #4]
 802c8c6:	2b12      	cmp	r3, #18
 802c8c8:	d130      	bne.n	802c92c <HAL_GPIO_Init+0xbc>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 802c8ca:	687b      	ldr	r3, [r7, #4]
 802c8cc:	689b      	ldr	r3, [r3, #8]
 802c8ce:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 802c8d0:	69fb      	ldr	r3, [r7, #28]
 802c8d2:	005b      	lsls	r3, r3, #1
 802c8d4:	2203      	movs	r2, #3
 802c8d6:	fa02 f303 	lsl.w	r3, r2, r3
 802c8da:	43db      	mvns	r3, r3
 802c8dc:	69ba      	ldr	r2, [r7, #24]
 802c8de:	4013      	ands	r3, r2
 802c8e0:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 802c8e2:	683b      	ldr	r3, [r7, #0]
 802c8e4:	68da      	ldr	r2, [r3, #12]
 802c8e6:	69fb      	ldr	r3, [r7, #28]
 802c8e8:	005b      	lsls	r3, r3, #1
 802c8ea:	fa02 f303 	lsl.w	r3, r2, r3
 802c8ee:	69ba      	ldr	r2, [r7, #24]
 802c8f0:	4313      	orrs	r3, r2
 802c8f2:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 802c8f4:	687b      	ldr	r3, [r7, #4]
 802c8f6:	69ba      	ldr	r2, [r7, #24]
 802c8f8:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 802c8fa:	687b      	ldr	r3, [r7, #4]
 802c8fc:	685b      	ldr	r3, [r3, #4]
 802c8fe:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 802c900:	2201      	movs	r2, #1
 802c902:	69fb      	ldr	r3, [r7, #28]
 802c904:	fa02 f303 	lsl.w	r3, r2, r3
 802c908:	43db      	mvns	r3, r3
 802c90a:	69ba      	ldr	r2, [r7, #24]
 802c90c:	4013      	ands	r3, r2
 802c90e:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 802c910:	683b      	ldr	r3, [r7, #0]
 802c912:	685b      	ldr	r3, [r3, #4]
 802c914:	091b      	lsrs	r3, r3, #4
 802c916:	f003 0201 	and.w	r2, r3, #1
 802c91a:	69fb      	ldr	r3, [r7, #28]
 802c91c:	fa02 f303 	lsl.w	r3, r2, r3
 802c920:	69ba      	ldr	r2, [r7, #24]
 802c922:	4313      	orrs	r3, r2
 802c924:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 802c926:	687b      	ldr	r3, [r7, #4]
 802c928:	69ba      	ldr	r2, [r7, #24]
 802c92a:	605a      	str	r2, [r3, #4]
       }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 802c92c:	687b      	ldr	r3, [r7, #4]
 802c92e:	68db      	ldr	r3, [r3, #12]
 802c930:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 802c932:	69fb      	ldr	r3, [r7, #28]
 802c934:	005b      	lsls	r3, r3, #1
 802c936:	2203      	movs	r2, #3
 802c938:	fa02 f303 	lsl.w	r3, r2, r3
 802c93c:	43db      	mvns	r3, r3
 802c93e:	69ba      	ldr	r2, [r7, #24]
 802c940:	4013      	ands	r3, r2
 802c942:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 802c944:	683b      	ldr	r3, [r7, #0]
 802c946:	689a      	ldr	r2, [r3, #8]
 802c948:	69fb      	ldr	r3, [r7, #28]
 802c94a:	005b      	lsls	r3, r3, #1
 802c94c:	fa02 f303 	lsl.w	r3, r2, r3
 802c950:	69ba      	ldr	r2, [r7, #24]
 802c952:	4313      	orrs	r3, r2
 802c954:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 802c956:	687b      	ldr	r3, [r7, #4]
 802c958:	69ba      	ldr	r2, [r7, #24]
 802c95a:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 802c95c:	683b      	ldr	r3, [r7, #0]
 802c95e:	685b      	ldr	r3, [r3, #4]
 802c960:	2b02      	cmp	r3, #2
 802c962:	d003      	beq.n	802c96c <HAL_GPIO_Init+0xfc>
 802c964:	683b      	ldr	r3, [r7, #0]
 802c966:	685b      	ldr	r3, [r3, #4]
 802c968:	2b12      	cmp	r3, #18
 802c96a:	d123      	bne.n	802c9b4 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 802c96c:	69fb      	ldr	r3, [r7, #28]
 802c96e:	08da      	lsrs	r2, r3, #3
 802c970:	687b      	ldr	r3, [r7, #4]
 802c972:	3208      	adds	r2, #8
 802c974:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802c978:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 802c97a:	69fb      	ldr	r3, [r7, #28]
 802c97c:	f003 0307 	and.w	r3, r3, #7
 802c980:	009b      	lsls	r3, r3, #2
 802c982:	220f      	movs	r2, #15
 802c984:	fa02 f303 	lsl.w	r3, r2, r3
 802c988:	43db      	mvns	r3, r3
 802c98a:	69ba      	ldr	r2, [r7, #24]
 802c98c:	4013      	ands	r3, r2
 802c98e:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 802c990:	683b      	ldr	r3, [r7, #0]
 802c992:	691a      	ldr	r2, [r3, #16]
 802c994:	69fb      	ldr	r3, [r7, #28]
 802c996:	f003 0307 	and.w	r3, r3, #7
 802c99a:	009b      	lsls	r3, r3, #2
 802c99c:	fa02 f303 	lsl.w	r3, r2, r3
 802c9a0:	69ba      	ldr	r2, [r7, #24]
 802c9a2:	4313      	orrs	r3, r2
 802c9a4:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 802c9a6:	69fb      	ldr	r3, [r7, #28]
 802c9a8:	08da      	lsrs	r2, r3, #3
 802c9aa:	687b      	ldr	r3, [r7, #4]
 802c9ac:	3208      	adds	r2, #8
 802c9ae:	69b9      	ldr	r1, [r7, #24]
 802c9b0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 802c9b4:	687b      	ldr	r3, [r7, #4]
 802c9b6:	681b      	ldr	r3, [r3, #0]
 802c9b8:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 802c9ba:	69fb      	ldr	r3, [r7, #28]
 802c9bc:	005b      	lsls	r3, r3, #1
 802c9be:	2203      	movs	r2, #3
 802c9c0:	fa02 f303 	lsl.w	r3, r2, r3
 802c9c4:	43db      	mvns	r3, r3
 802c9c6:	69ba      	ldr	r2, [r7, #24]
 802c9c8:	4013      	ands	r3, r2
 802c9ca:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 802c9cc:	683b      	ldr	r3, [r7, #0]
 802c9ce:	685b      	ldr	r3, [r3, #4]
 802c9d0:	f003 0203 	and.w	r2, r3, #3
 802c9d4:	69fb      	ldr	r3, [r7, #28]
 802c9d6:	005b      	lsls	r3, r3, #1
 802c9d8:	fa02 f303 	lsl.w	r3, r2, r3
 802c9dc:	69ba      	ldr	r2, [r7, #24]
 802c9de:	4313      	orrs	r3, r2
 802c9e0:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 802c9e2:	687b      	ldr	r3, [r7, #4]
 802c9e4:	69ba      	ldr	r2, [r7, #24]
 802c9e6:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 802c9e8:	683b      	ldr	r3, [r7, #0]
 802c9ea:	685b      	ldr	r3, [r3, #4]
 802c9ec:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802c9f0:	2b00      	cmp	r3, #0
 802c9f2:	f000 80a2 	beq.w	802cb3a <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 802c9f6:	2300      	movs	r3, #0
 802c9f8:	60fb      	str	r3, [r7, #12]
 802c9fa:	4b56      	ldr	r3, [pc, #344]	; (802cb54 <HAL_GPIO_Init+0x2e4>)
 802c9fc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802c9fe:	4a55      	ldr	r2, [pc, #340]	; (802cb54 <HAL_GPIO_Init+0x2e4>)
 802ca00:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802ca04:	6453      	str	r3, [r2, #68]	; 0x44
 802ca06:	4b53      	ldr	r3, [pc, #332]	; (802cb54 <HAL_GPIO_Init+0x2e4>)
 802ca08:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802ca0a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 802ca0e:	60fb      	str	r3, [r7, #12]
 802ca10:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 802ca12:	4a51      	ldr	r2, [pc, #324]	; (802cb58 <HAL_GPIO_Init+0x2e8>)
 802ca14:	69fb      	ldr	r3, [r7, #28]
 802ca16:	089b      	lsrs	r3, r3, #2
 802ca18:	3302      	adds	r3, #2
 802ca1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802ca1e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 802ca20:	69fb      	ldr	r3, [r7, #28]
 802ca22:	f003 0303 	and.w	r3, r3, #3
 802ca26:	009b      	lsls	r3, r3, #2
 802ca28:	220f      	movs	r2, #15
 802ca2a:	fa02 f303 	lsl.w	r3, r2, r3
 802ca2e:	43db      	mvns	r3, r3
 802ca30:	69ba      	ldr	r2, [r7, #24]
 802ca32:	4013      	ands	r3, r2
 802ca34:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 802ca36:	687b      	ldr	r3, [r7, #4]
 802ca38:	4a48      	ldr	r2, [pc, #288]	; (802cb5c <HAL_GPIO_Init+0x2ec>)
 802ca3a:	4293      	cmp	r3, r2
 802ca3c:	d019      	beq.n	802ca72 <HAL_GPIO_Init+0x202>
 802ca3e:	687b      	ldr	r3, [r7, #4]
 802ca40:	4a47      	ldr	r2, [pc, #284]	; (802cb60 <HAL_GPIO_Init+0x2f0>)
 802ca42:	4293      	cmp	r3, r2
 802ca44:	d013      	beq.n	802ca6e <HAL_GPIO_Init+0x1fe>
 802ca46:	687b      	ldr	r3, [r7, #4]
 802ca48:	4a46      	ldr	r2, [pc, #280]	; (802cb64 <HAL_GPIO_Init+0x2f4>)
 802ca4a:	4293      	cmp	r3, r2
 802ca4c:	d00d      	beq.n	802ca6a <HAL_GPIO_Init+0x1fa>
 802ca4e:	687b      	ldr	r3, [r7, #4]
 802ca50:	4a45      	ldr	r2, [pc, #276]	; (802cb68 <HAL_GPIO_Init+0x2f8>)
 802ca52:	4293      	cmp	r3, r2
 802ca54:	d007      	beq.n	802ca66 <HAL_GPIO_Init+0x1f6>
 802ca56:	687b      	ldr	r3, [r7, #4]
 802ca58:	4a44      	ldr	r2, [pc, #272]	; (802cb6c <HAL_GPIO_Init+0x2fc>)
 802ca5a:	4293      	cmp	r3, r2
 802ca5c:	d101      	bne.n	802ca62 <HAL_GPIO_Init+0x1f2>
 802ca5e:	2304      	movs	r3, #4
 802ca60:	e008      	b.n	802ca74 <HAL_GPIO_Init+0x204>
 802ca62:	2307      	movs	r3, #7
 802ca64:	e006      	b.n	802ca74 <HAL_GPIO_Init+0x204>
 802ca66:	2303      	movs	r3, #3
 802ca68:	e004      	b.n	802ca74 <HAL_GPIO_Init+0x204>
 802ca6a:	2302      	movs	r3, #2
 802ca6c:	e002      	b.n	802ca74 <HAL_GPIO_Init+0x204>
 802ca6e:	2301      	movs	r3, #1
 802ca70:	e000      	b.n	802ca74 <HAL_GPIO_Init+0x204>
 802ca72:	2300      	movs	r3, #0
 802ca74:	69fa      	ldr	r2, [r7, #28]
 802ca76:	f002 0203 	and.w	r2, r2, #3
 802ca7a:	0092      	lsls	r2, r2, #2
 802ca7c:	4093      	lsls	r3, r2
 802ca7e:	69ba      	ldr	r2, [r7, #24]
 802ca80:	4313      	orrs	r3, r2
 802ca82:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 802ca84:	4934      	ldr	r1, [pc, #208]	; (802cb58 <HAL_GPIO_Init+0x2e8>)
 802ca86:	69fb      	ldr	r3, [r7, #28]
 802ca88:	089b      	lsrs	r3, r3, #2
 802ca8a:	3302      	adds	r3, #2
 802ca8c:	69ba      	ldr	r2, [r7, #24]
 802ca8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 802ca92:	4b37      	ldr	r3, [pc, #220]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802ca94:	681b      	ldr	r3, [r3, #0]
 802ca96:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802ca98:	693b      	ldr	r3, [r7, #16]
 802ca9a:	43db      	mvns	r3, r3
 802ca9c:	69ba      	ldr	r2, [r7, #24]
 802ca9e:	4013      	ands	r3, r2
 802caa0:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 802caa2:	683b      	ldr	r3, [r7, #0]
 802caa4:	685b      	ldr	r3, [r3, #4]
 802caa6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 802caaa:	2b00      	cmp	r3, #0
 802caac:	d003      	beq.n	802cab6 <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 802caae:	69ba      	ldr	r2, [r7, #24]
 802cab0:	693b      	ldr	r3, [r7, #16]
 802cab2:	4313      	orrs	r3, r2
 802cab4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 802cab6:	4a2e      	ldr	r2, [pc, #184]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cab8:	69bb      	ldr	r3, [r7, #24]
 802caba:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 802cabc:	4b2c      	ldr	r3, [pc, #176]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cabe:	685b      	ldr	r3, [r3, #4]
 802cac0:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802cac2:	693b      	ldr	r3, [r7, #16]
 802cac4:	43db      	mvns	r3, r3
 802cac6:	69ba      	ldr	r2, [r7, #24]
 802cac8:	4013      	ands	r3, r2
 802caca:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 802cacc:	683b      	ldr	r3, [r7, #0]
 802cace:	685b      	ldr	r3, [r3, #4]
 802cad0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802cad4:	2b00      	cmp	r3, #0
 802cad6:	d003      	beq.n	802cae0 <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 802cad8:	69ba      	ldr	r2, [r7, #24]
 802cada:	693b      	ldr	r3, [r7, #16]
 802cadc:	4313      	orrs	r3, r2
 802cade:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 802cae0:	4a23      	ldr	r2, [pc, #140]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cae2:	69bb      	ldr	r3, [r7, #24]
 802cae4:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 802cae6:	4b22      	ldr	r3, [pc, #136]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cae8:	689b      	ldr	r3, [r3, #8]
 802caea:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802caec:	693b      	ldr	r3, [r7, #16]
 802caee:	43db      	mvns	r3, r3
 802caf0:	69ba      	ldr	r2, [r7, #24]
 802caf2:	4013      	ands	r3, r2
 802caf4:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 802caf6:	683b      	ldr	r3, [r7, #0]
 802caf8:	685b      	ldr	r3, [r3, #4]
 802cafa:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 802cafe:	2b00      	cmp	r3, #0
 802cb00:	d003      	beq.n	802cb0a <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 802cb02:	69ba      	ldr	r2, [r7, #24]
 802cb04:	693b      	ldr	r3, [r7, #16]
 802cb06:	4313      	orrs	r3, r2
 802cb08:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 802cb0a:	4a19      	ldr	r2, [pc, #100]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cb0c:	69bb      	ldr	r3, [r7, #24]
 802cb0e:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 802cb10:	4b17      	ldr	r3, [pc, #92]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cb12:	68db      	ldr	r3, [r3, #12]
 802cb14:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802cb16:	693b      	ldr	r3, [r7, #16]
 802cb18:	43db      	mvns	r3, r3
 802cb1a:	69ba      	ldr	r2, [r7, #24]
 802cb1c:	4013      	ands	r3, r2
 802cb1e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 802cb20:	683b      	ldr	r3, [r7, #0]
 802cb22:	685b      	ldr	r3, [r3, #4]
 802cb24:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 802cb28:	2b00      	cmp	r3, #0
 802cb2a:	d003      	beq.n	802cb34 <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 802cb2c:	69ba      	ldr	r2, [r7, #24]
 802cb2e:	693b      	ldr	r3, [r7, #16]
 802cb30:	4313      	orrs	r3, r2
 802cb32:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 802cb34:	4a0e      	ldr	r2, [pc, #56]	; (802cb70 <HAL_GPIO_Init+0x300>)
 802cb36:	69bb      	ldr	r3, [r7, #24]
 802cb38:	60d3      	str	r3, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 802cb3a:	69fb      	ldr	r3, [r7, #28]
 802cb3c:	3301      	adds	r3, #1
 802cb3e:	61fb      	str	r3, [r7, #28]
 802cb40:	69fb      	ldr	r3, [r7, #28]
 802cb42:	2b0f      	cmp	r3, #15
 802cb44:	f67f aea2 	bls.w	802c88c <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 802cb48:	bf00      	nop
 802cb4a:	3724      	adds	r7, #36	; 0x24
 802cb4c:	46bd      	mov	sp, r7
 802cb4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cb52:	4770      	bx	lr
 802cb54:	40023800 	.word	0x40023800
 802cb58:	40013800 	.word	0x40013800
 802cb5c:	40020000 	.word	0x40020000
 802cb60:	40020400 	.word	0x40020400
 802cb64:	40020800 	.word	0x40020800
 802cb68:	40020c00 	.word	0x40020c00
 802cb6c:	40021000 	.word	0x40021000
 802cb70:	40013c00 	.word	0x40013c00

0802cb74 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 802cb74:	b480      	push	{r7}
 802cb76:	b085      	sub	sp, #20
 802cb78:	af00      	add	r7, sp, #0
 802cb7a:	6078      	str	r0, [r7, #4]
 802cb7c:	460b      	mov	r3, r1
 802cb7e:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 802cb80:	687b      	ldr	r3, [r7, #4]
 802cb82:	691a      	ldr	r2, [r3, #16]
 802cb84:	887b      	ldrh	r3, [r7, #2]
 802cb86:	4013      	ands	r3, r2
 802cb88:	2b00      	cmp	r3, #0
 802cb8a:	d002      	beq.n	802cb92 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 802cb8c:	2301      	movs	r3, #1
 802cb8e:	73fb      	strb	r3, [r7, #15]
 802cb90:	e001      	b.n	802cb96 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 802cb92:	2300      	movs	r3, #0
 802cb94:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 802cb96:	7bfb      	ldrb	r3, [r7, #15]
}
 802cb98:	4618      	mov	r0, r3
 802cb9a:	3714      	adds	r7, #20
 802cb9c:	46bd      	mov	sp, r7
 802cb9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cba2:	4770      	bx	lr

0802cba4 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 802cba4:	b480      	push	{r7}
 802cba6:	b083      	sub	sp, #12
 802cba8:	af00      	add	r7, sp, #0
 802cbaa:	6078      	str	r0, [r7, #4]
 802cbac:	460b      	mov	r3, r1
 802cbae:	807b      	strh	r3, [r7, #2]
 802cbb0:	4613      	mov	r3, r2
 802cbb2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 802cbb4:	787b      	ldrb	r3, [r7, #1]
 802cbb6:	2b00      	cmp	r3, #0
 802cbb8:	d003      	beq.n	802cbc2 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 802cbba:	887a      	ldrh	r2, [r7, #2]
 802cbbc:	687b      	ldr	r3, [r7, #4]
 802cbbe:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 802cbc0:	e003      	b.n	802cbca <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 802cbc2:	887b      	ldrh	r3, [r7, #2]
 802cbc4:	041a      	lsls	r2, r3, #16
 802cbc6:	687b      	ldr	r3, [r7, #4]
 802cbc8:	619a      	str	r2, [r3, #24]
}
 802cbca:	bf00      	nop
 802cbcc:	370c      	adds	r7, #12
 802cbce:	46bd      	mov	sp, r7
 802cbd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cbd4:	4770      	bx	lr
	...

0802cbd8 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 802cbd8:	b580      	push	{r7, lr}
 802cbda:	b086      	sub	sp, #24
 802cbdc:	af00      	add	r7, sp, #0
 802cbde:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 802cbe0:	687b      	ldr	r3, [r7, #4]
 802cbe2:	2b00      	cmp	r3, #0
 802cbe4:	d101      	bne.n	802cbea <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 802cbe6:	2301      	movs	r3, #1
 802cbe8:	e25b      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 802cbea:	687b      	ldr	r3, [r7, #4]
 802cbec:	681b      	ldr	r3, [r3, #0]
 802cbee:	f003 0301 	and.w	r3, r3, #1
 802cbf2:	2b00      	cmp	r3, #0
 802cbf4:	d075      	beq.n	802cce2 <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 802cbf6:	4ba3      	ldr	r3, [pc, #652]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cbf8:	689b      	ldr	r3, [r3, #8]
 802cbfa:	f003 030c 	and.w	r3, r3, #12
 802cbfe:	2b04      	cmp	r3, #4
 802cc00:	d00c      	beq.n	802cc1c <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 802cc02:	4ba0      	ldr	r3, [pc, #640]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc04:	689b      	ldr	r3, [r3, #8]
 802cc06:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 802cc0a:	2b08      	cmp	r3, #8
 802cc0c:	d112      	bne.n	802cc34 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 802cc0e:	4b9d      	ldr	r3, [pc, #628]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc10:	685b      	ldr	r3, [r3, #4]
 802cc12:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802cc16:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 802cc1a:	d10b      	bne.n	802cc34 <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802cc1c:	4b99      	ldr	r3, [pc, #612]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc1e:	681b      	ldr	r3, [r3, #0]
 802cc20:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802cc24:	2b00      	cmp	r3, #0
 802cc26:	d05b      	beq.n	802cce0 <HAL_RCC_OscConfig+0x108>
 802cc28:	687b      	ldr	r3, [r7, #4]
 802cc2a:	685b      	ldr	r3, [r3, #4]
 802cc2c:	2b00      	cmp	r3, #0
 802cc2e:	d157      	bne.n	802cce0 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 802cc30:	2301      	movs	r3, #1
 802cc32:	e236      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802cc34:	687b      	ldr	r3, [r7, #4]
 802cc36:	685b      	ldr	r3, [r3, #4]
 802cc38:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 802cc3c:	d106      	bne.n	802cc4c <HAL_RCC_OscConfig+0x74>
 802cc3e:	4b91      	ldr	r3, [pc, #580]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc40:	681b      	ldr	r3, [r3, #0]
 802cc42:	4a90      	ldr	r2, [pc, #576]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc44:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802cc48:	6013      	str	r3, [r2, #0]
 802cc4a:	e01d      	b.n	802cc88 <HAL_RCC_OscConfig+0xb0>
 802cc4c:	687b      	ldr	r3, [r7, #4]
 802cc4e:	685b      	ldr	r3, [r3, #4]
 802cc50:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 802cc54:	d10c      	bne.n	802cc70 <HAL_RCC_OscConfig+0x98>
 802cc56:	4b8b      	ldr	r3, [pc, #556]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc58:	681b      	ldr	r3, [r3, #0]
 802cc5a:	4a8a      	ldr	r2, [pc, #552]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc5c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 802cc60:	6013      	str	r3, [r2, #0]
 802cc62:	4b88      	ldr	r3, [pc, #544]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc64:	681b      	ldr	r3, [r3, #0]
 802cc66:	4a87      	ldr	r2, [pc, #540]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc68:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802cc6c:	6013      	str	r3, [r2, #0]
 802cc6e:	e00b      	b.n	802cc88 <HAL_RCC_OscConfig+0xb0>
 802cc70:	4b84      	ldr	r3, [pc, #528]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc72:	681b      	ldr	r3, [r3, #0]
 802cc74:	4a83      	ldr	r2, [pc, #524]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc76:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802cc7a:	6013      	str	r3, [r2, #0]
 802cc7c:	4b81      	ldr	r3, [pc, #516]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc7e:	681b      	ldr	r3, [r3, #0]
 802cc80:	4a80      	ldr	r2, [pc, #512]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cc82:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 802cc86:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 802cc88:	687b      	ldr	r3, [r7, #4]
 802cc8a:	685b      	ldr	r3, [r3, #4]
 802cc8c:	2b00      	cmp	r3, #0
 802cc8e:	d013      	beq.n	802ccb8 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802cc90:	f7ff f91e 	bl	802bed0 <HAL_GetTick>
 802cc94:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802cc96:	e008      	b.n	802ccaa <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 802cc98:	f7ff f91a 	bl	802bed0 <HAL_GetTick>
 802cc9c:	4602      	mov	r2, r0
 802cc9e:	693b      	ldr	r3, [r7, #16]
 802cca0:	1ad3      	subs	r3, r2, r3
 802cca2:	2b64      	cmp	r3, #100	; 0x64
 802cca4:	d901      	bls.n	802ccaa <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 802cca6:	2303      	movs	r3, #3
 802cca8:	e1fb      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802ccaa:	4b76      	ldr	r3, [pc, #472]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ccac:	681b      	ldr	r3, [r3, #0]
 802ccae:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802ccb2:	2b00      	cmp	r3, #0
 802ccb4:	d0f0      	beq.n	802cc98 <HAL_RCC_OscConfig+0xc0>
 802ccb6:	e014      	b.n	802cce2 <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802ccb8:	f7ff f90a 	bl	802bed0 <HAL_GetTick>
 802ccbc:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 802ccbe:	e008      	b.n	802ccd2 <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 802ccc0:	f7ff f906 	bl	802bed0 <HAL_GetTick>
 802ccc4:	4602      	mov	r2, r0
 802ccc6:	693b      	ldr	r3, [r7, #16]
 802ccc8:	1ad3      	subs	r3, r2, r3
 802ccca:	2b64      	cmp	r3, #100	; 0x64
 802cccc:	d901      	bls.n	802ccd2 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 802ccce:	2303      	movs	r3, #3
 802ccd0:	e1e7      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 802ccd2:	4b6c      	ldr	r3, [pc, #432]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ccd4:	681b      	ldr	r3, [r3, #0]
 802ccd6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802ccda:	2b00      	cmp	r3, #0
 802ccdc:	d1f0      	bne.n	802ccc0 <HAL_RCC_OscConfig+0xe8>
 802ccde:	e000      	b.n	802cce2 <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802cce0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 802cce2:	687b      	ldr	r3, [r7, #4]
 802cce4:	681b      	ldr	r3, [r3, #0]
 802cce6:	f003 0302 	and.w	r3, r3, #2
 802ccea:	2b00      	cmp	r3, #0
 802ccec:	d063      	beq.n	802cdb6 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 802ccee:	4b65      	ldr	r3, [pc, #404]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ccf0:	689b      	ldr	r3, [r3, #8]
 802ccf2:	f003 030c 	and.w	r3, r3, #12
 802ccf6:	2b00      	cmp	r3, #0
 802ccf8:	d00b      	beq.n	802cd12 <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 802ccfa:	4b62      	ldr	r3, [pc, #392]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ccfc:	689b      	ldr	r3, [r3, #8]
 802ccfe:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 802cd02:	2b08      	cmp	r3, #8
 802cd04:	d11c      	bne.n	802cd40 <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 802cd06:	4b5f      	ldr	r3, [pc, #380]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd08:	685b      	ldr	r3, [r3, #4]
 802cd0a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802cd0e:	2b00      	cmp	r3, #0
 802cd10:	d116      	bne.n	802cd40 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 802cd12:	4b5c      	ldr	r3, [pc, #368]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd14:	681b      	ldr	r3, [r3, #0]
 802cd16:	f003 0302 	and.w	r3, r3, #2
 802cd1a:	2b00      	cmp	r3, #0
 802cd1c:	d005      	beq.n	802cd2a <HAL_RCC_OscConfig+0x152>
 802cd1e:	687b      	ldr	r3, [r7, #4]
 802cd20:	68db      	ldr	r3, [r3, #12]
 802cd22:	2b01      	cmp	r3, #1
 802cd24:	d001      	beq.n	802cd2a <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 802cd26:	2301      	movs	r3, #1
 802cd28:	e1bb      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 802cd2a:	4b56      	ldr	r3, [pc, #344]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd2c:	681b      	ldr	r3, [r3, #0]
 802cd2e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 802cd32:	687b      	ldr	r3, [r7, #4]
 802cd34:	691b      	ldr	r3, [r3, #16]
 802cd36:	00db      	lsls	r3, r3, #3
 802cd38:	4952      	ldr	r1, [pc, #328]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd3a:	4313      	orrs	r3, r2
 802cd3c:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 802cd3e:	e03a      	b.n	802cdb6 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 802cd40:	687b      	ldr	r3, [r7, #4]
 802cd42:	68db      	ldr	r3, [r3, #12]
 802cd44:	2b00      	cmp	r3, #0
 802cd46:	d020      	beq.n	802cd8a <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 802cd48:	4b4f      	ldr	r3, [pc, #316]	; (802ce88 <HAL_RCC_OscConfig+0x2b0>)
 802cd4a:	2201      	movs	r2, #1
 802cd4c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 802cd4e:	f7ff f8bf 	bl	802bed0 <HAL_GetTick>
 802cd52:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802cd54:	e008      	b.n	802cd68 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 802cd56:	f7ff f8bb 	bl	802bed0 <HAL_GetTick>
 802cd5a:	4602      	mov	r2, r0
 802cd5c:	693b      	ldr	r3, [r7, #16]
 802cd5e:	1ad3      	subs	r3, r2, r3
 802cd60:	2b02      	cmp	r3, #2
 802cd62:	d901      	bls.n	802cd68 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 802cd64:	2303      	movs	r3, #3
 802cd66:	e19c      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802cd68:	4b46      	ldr	r3, [pc, #280]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd6a:	681b      	ldr	r3, [r3, #0]
 802cd6c:	f003 0302 	and.w	r3, r3, #2
 802cd70:	2b00      	cmp	r3, #0
 802cd72:	d0f0      	beq.n	802cd56 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 802cd74:	4b43      	ldr	r3, [pc, #268]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd76:	681b      	ldr	r3, [r3, #0]
 802cd78:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 802cd7c:	687b      	ldr	r3, [r7, #4]
 802cd7e:	691b      	ldr	r3, [r3, #16]
 802cd80:	00db      	lsls	r3, r3, #3
 802cd82:	4940      	ldr	r1, [pc, #256]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cd84:	4313      	orrs	r3, r2
 802cd86:	600b      	str	r3, [r1, #0]
 802cd88:	e015      	b.n	802cdb6 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 802cd8a:	4b3f      	ldr	r3, [pc, #252]	; (802ce88 <HAL_RCC_OscConfig+0x2b0>)
 802cd8c:	2200      	movs	r2, #0
 802cd8e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 802cd90:	f7ff f89e 	bl	802bed0 <HAL_GetTick>
 802cd94:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 802cd96:	e008      	b.n	802cdaa <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 802cd98:	f7ff f89a 	bl	802bed0 <HAL_GetTick>
 802cd9c:	4602      	mov	r2, r0
 802cd9e:	693b      	ldr	r3, [r7, #16]
 802cda0:	1ad3      	subs	r3, r2, r3
 802cda2:	2b02      	cmp	r3, #2
 802cda4:	d901      	bls.n	802cdaa <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 802cda6:	2303      	movs	r3, #3
 802cda8:	e17b      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 802cdaa:	4b36      	ldr	r3, [pc, #216]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cdac:	681b      	ldr	r3, [r3, #0]
 802cdae:	f003 0302 	and.w	r3, r3, #2
 802cdb2:	2b00      	cmp	r3, #0
 802cdb4:	d1f0      	bne.n	802cd98 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802cdb6:	687b      	ldr	r3, [r7, #4]
 802cdb8:	681b      	ldr	r3, [r3, #0]
 802cdba:	f003 0308 	and.w	r3, r3, #8
 802cdbe:	2b00      	cmp	r3, #0
 802cdc0:	d030      	beq.n	802ce24 <HAL_RCC_OscConfig+0x24c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 802cdc2:	687b      	ldr	r3, [r7, #4]
 802cdc4:	695b      	ldr	r3, [r3, #20]
 802cdc6:	2b00      	cmp	r3, #0
 802cdc8:	d016      	beq.n	802cdf8 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 802cdca:	4b30      	ldr	r3, [pc, #192]	; (802ce8c <HAL_RCC_OscConfig+0x2b4>)
 802cdcc:	2201      	movs	r2, #1
 802cdce:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 802cdd0:	f7ff f87e 	bl	802bed0 <HAL_GetTick>
 802cdd4:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802cdd6:	e008      	b.n	802cdea <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 802cdd8:	f7ff f87a 	bl	802bed0 <HAL_GetTick>
 802cddc:	4602      	mov	r2, r0
 802cdde:	693b      	ldr	r3, [r7, #16]
 802cde0:	1ad3      	subs	r3, r2, r3
 802cde2:	2b02      	cmp	r3, #2
 802cde4:	d901      	bls.n	802cdea <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 802cde6:	2303      	movs	r3, #3
 802cde8:	e15b      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802cdea:	4b26      	ldr	r3, [pc, #152]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802cdec:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 802cdee:	f003 0302 	and.w	r3, r3, #2
 802cdf2:	2b00      	cmp	r3, #0
 802cdf4:	d0f0      	beq.n	802cdd8 <HAL_RCC_OscConfig+0x200>
 802cdf6:	e015      	b.n	802ce24 <HAL_RCC_OscConfig+0x24c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 802cdf8:	4b24      	ldr	r3, [pc, #144]	; (802ce8c <HAL_RCC_OscConfig+0x2b4>)
 802cdfa:	2200      	movs	r2, #0
 802cdfc:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 802cdfe:	f7ff f867 	bl	802bed0 <HAL_GetTick>
 802ce02:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 802ce04:	e008      	b.n	802ce18 <HAL_RCC_OscConfig+0x240>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 802ce06:	f7ff f863 	bl	802bed0 <HAL_GetTick>
 802ce0a:	4602      	mov	r2, r0
 802ce0c:	693b      	ldr	r3, [r7, #16]
 802ce0e:	1ad3      	subs	r3, r2, r3
 802ce10:	2b02      	cmp	r3, #2
 802ce12:	d901      	bls.n	802ce18 <HAL_RCC_OscConfig+0x240>
        {
          return HAL_TIMEOUT;
 802ce14:	2303      	movs	r3, #3
 802ce16:	e144      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 802ce18:	4b1a      	ldr	r3, [pc, #104]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ce1a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 802ce1c:	f003 0302 	and.w	r3, r3, #2
 802ce20:	2b00      	cmp	r3, #0
 802ce22:	d1f0      	bne.n	802ce06 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 802ce24:	687b      	ldr	r3, [r7, #4]
 802ce26:	681b      	ldr	r3, [r3, #0]
 802ce28:	f003 0304 	and.w	r3, r3, #4
 802ce2c:	2b00      	cmp	r3, #0
 802ce2e:	f000 80a0 	beq.w	802cf72 <HAL_RCC_OscConfig+0x39a>
  {
    FlagStatus       pwrclkchanged = RESET;
 802ce32:	2300      	movs	r3, #0
 802ce34:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 802ce36:	4b13      	ldr	r3, [pc, #76]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ce38:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802ce3a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802ce3e:	2b00      	cmp	r3, #0
 802ce40:	d10f      	bne.n	802ce62 <HAL_RCC_OscConfig+0x28a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 802ce42:	2300      	movs	r3, #0
 802ce44:	60bb      	str	r3, [r7, #8]
 802ce46:	4b0f      	ldr	r3, [pc, #60]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ce48:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802ce4a:	4a0e      	ldr	r2, [pc, #56]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ce4c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802ce50:	6413      	str	r3, [r2, #64]	; 0x40
 802ce52:	4b0c      	ldr	r3, [pc, #48]	; (802ce84 <HAL_RCC_OscConfig+0x2ac>)
 802ce54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802ce56:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802ce5a:	60bb      	str	r3, [r7, #8]
 802ce5c:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 802ce5e:	2301      	movs	r3, #1
 802ce60:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 802ce62:	4b0b      	ldr	r3, [pc, #44]	; (802ce90 <HAL_RCC_OscConfig+0x2b8>)
 802ce64:	681b      	ldr	r3, [r3, #0]
 802ce66:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802ce6a:	2b00      	cmp	r3, #0
 802ce6c:	d121      	bne.n	802ceb2 <HAL_RCC_OscConfig+0x2da>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 802ce6e:	4b08      	ldr	r3, [pc, #32]	; (802ce90 <HAL_RCC_OscConfig+0x2b8>)
 802ce70:	681b      	ldr	r3, [r3, #0]
 802ce72:	4a07      	ldr	r2, [pc, #28]	; (802ce90 <HAL_RCC_OscConfig+0x2b8>)
 802ce74:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802ce78:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 802ce7a:	f7ff f829 	bl	802bed0 <HAL_GetTick>
 802ce7e:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 802ce80:	e011      	b.n	802cea6 <HAL_RCC_OscConfig+0x2ce>
 802ce82:	bf00      	nop
 802ce84:	40023800 	.word	0x40023800
 802ce88:	42470000 	.word	0x42470000
 802ce8c:	42470e80 	.word	0x42470e80
 802ce90:	40007000 	.word	0x40007000
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802ce94:	f7ff f81c 	bl	802bed0 <HAL_GetTick>
 802ce98:	4602      	mov	r2, r0
 802ce9a:	693b      	ldr	r3, [r7, #16]
 802ce9c:	1ad3      	subs	r3, r2, r3
 802ce9e:	2b02      	cmp	r3, #2
 802cea0:	d901      	bls.n	802cea6 <HAL_RCC_OscConfig+0x2ce>
        {
          return HAL_TIMEOUT;
 802cea2:	2303      	movs	r3, #3
 802cea4:	e0fd      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 802cea6:	4b81      	ldr	r3, [pc, #516]	; (802d0ac <HAL_RCC_OscConfig+0x4d4>)
 802cea8:	681b      	ldr	r3, [r3, #0]
 802ceaa:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802ceae:	2b00      	cmp	r3, #0
 802ceb0:	d0f0      	beq.n	802ce94 <HAL_RCC_OscConfig+0x2bc>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 802ceb2:	687b      	ldr	r3, [r7, #4]
 802ceb4:	689b      	ldr	r3, [r3, #8]
 802ceb6:	2b01      	cmp	r3, #1
 802ceb8:	d106      	bne.n	802cec8 <HAL_RCC_OscConfig+0x2f0>
 802ceba:	4b7d      	ldr	r3, [pc, #500]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cebc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802cebe:	4a7c      	ldr	r2, [pc, #496]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cec0:	f043 0301 	orr.w	r3, r3, #1
 802cec4:	6713      	str	r3, [r2, #112]	; 0x70
 802cec6:	e01c      	b.n	802cf02 <HAL_RCC_OscConfig+0x32a>
 802cec8:	687b      	ldr	r3, [r7, #4]
 802ceca:	689b      	ldr	r3, [r3, #8]
 802cecc:	2b05      	cmp	r3, #5
 802cece:	d10c      	bne.n	802ceea <HAL_RCC_OscConfig+0x312>
 802ced0:	4b77      	ldr	r3, [pc, #476]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802ced2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802ced4:	4a76      	ldr	r2, [pc, #472]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802ced6:	f043 0304 	orr.w	r3, r3, #4
 802ceda:	6713      	str	r3, [r2, #112]	; 0x70
 802cedc:	4b74      	ldr	r3, [pc, #464]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cede:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802cee0:	4a73      	ldr	r2, [pc, #460]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cee2:	f043 0301 	orr.w	r3, r3, #1
 802cee6:	6713      	str	r3, [r2, #112]	; 0x70
 802cee8:	e00b      	b.n	802cf02 <HAL_RCC_OscConfig+0x32a>
 802ceea:	4b71      	ldr	r3, [pc, #452]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802ceec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802ceee:	4a70      	ldr	r2, [pc, #448]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cef0:	f023 0301 	bic.w	r3, r3, #1
 802cef4:	6713      	str	r3, [r2, #112]	; 0x70
 802cef6:	4b6e      	ldr	r3, [pc, #440]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cef8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802cefa:	4a6d      	ldr	r2, [pc, #436]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cefc:	f023 0304 	bic.w	r3, r3, #4
 802cf00:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 802cf02:	687b      	ldr	r3, [r7, #4]
 802cf04:	689b      	ldr	r3, [r3, #8]
 802cf06:	2b00      	cmp	r3, #0
 802cf08:	d015      	beq.n	802cf36 <HAL_RCC_OscConfig+0x35e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 802cf0a:	f7fe ffe1 	bl	802bed0 <HAL_GetTick>
 802cf0e:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 802cf10:	e00a      	b.n	802cf28 <HAL_RCC_OscConfig+0x350>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 802cf12:	f7fe ffdd 	bl	802bed0 <HAL_GetTick>
 802cf16:	4602      	mov	r2, r0
 802cf18:	693b      	ldr	r3, [r7, #16]
 802cf1a:	1ad3      	subs	r3, r2, r3
 802cf1c:	f241 3288 	movw	r2, #5000	; 0x1388
 802cf20:	4293      	cmp	r3, r2
 802cf22:	d901      	bls.n	802cf28 <HAL_RCC_OscConfig+0x350>
        {
          return HAL_TIMEOUT;
 802cf24:	2303      	movs	r3, #3
 802cf26:	e0bc      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 802cf28:	4b61      	ldr	r3, [pc, #388]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cf2a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802cf2c:	f003 0302 	and.w	r3, r3, #2
 802cf30:	2b00      	cmp	r3, #0
 802cf32:	d0ee      	beq.n	802cf12 <HAL_RCC_OscConfig+0x33a>
 802cf34:	e014      	b.n	802cf60 <HAL_RCC_OscConfig+0x388>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 802cf36:	f7fe ffcb 	bl	802bed0 <HAL_GetTick>
 802cf3a:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 802cf3c:	e00a      	b.n	802cf54 <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 802cf3e:	f7fe ffc7 	bl	802bed0 <HAL_GetTick>
 802cf42:	4602      	mov	r2, r0
 802cf44:	693b      	ldr	r3, [r7, #16]
 802cf46:	1ad3      	subs	r3, r2, r3
 802cf48:	f241 3288 	movw	r2, #5000	; 0x1388
 802cf4c:	4293      	cmp	r3, r2
 802cf4e:	d901      	bls.n	802cf54 <HAL_RCC_OscConfig+0x37c>
        {
          return HAL_TIMEOUT;
 802cf50:	2303      	movs	r3, #3
 802cf52:	e0a6      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 802cf54:	4b56      	ldr	r3, [pc, #344]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cf56:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802cf58:	f003 0302 	and.w	r3, r3, #2
 802cf5c:	2b00      	cmp	r3, #0
 802cf5e:	d1ee      	bne.n	802cf3e <HAL_RCC_OscConfig+0x366>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 802cf60:	7dfb      	ldrb	r3, [r7, #23]
 802cf62:	2b01      	cmp	r3, #1
 802cf64:	d105      	bne.n	802cf72 <HAL_RCC_OscConfig+0x39a>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 802cf66:	4b52      	ldr	r3, [pc, #328]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cf68:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802cf6a:	4a51      	ldr	r2, [pc, #324]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cf6c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 802cf70:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 802cf72:	687b      	ldr	r3, [r7, #4]
 802cf74:	699b      	ldr	r3, [r3, #24]
 802cf76:	2b00      	cmp	r3, #0
 802cf78:	f000 8092 	beq.w	802d0a0 <HAL_RCC_OscConfig+0x4c8>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 802cf7c:	4b4c      	ldr	r3, [pc, #304]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cf7e:	689b      	ldr	r3, [r3, #8]
 802cf80:	f003 030c 	and.w	r3, r3, #12
 802cf84:	2b08      	cmp	r3, #8
 802cf86:	d05c      	beq.n	802d042 <HAL_RCC_OscConfig+0x46a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 802cf88:	687b      	ldr	r3, [r7, #4]
 802cf8a:	699b      	ldr	r3, [r3, #24]
 802cf8c:	2b02      	cmp	r3, #2
 802cf8e:	d141      	bne.n	802d014 <HAL_RCC_OscConfig+0x43c>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 802cf90:	4b48      	ldr	r3, [pc, #288]	; (802d0b4 <HAL_RCC_OscConfig+0x4dc>)
 802cf92:	2200      	movs	r2, #0
 802cf94:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802cf96:	f7fe ff9b 	bl	802bed0 <HAL_GetTick>
 802cf9a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802cf9c:	e008      	b.n	802cfb0 <HAL_RCC_OscConfig+0x3d8>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802cf9e:	f7fe ff97 	bl	802bed0 <HAL_GetTick>
 802cfa2:	4602      	mov	r2, r0
 802cfa4:	693b      	ldr	r3, [r7, #16]
 802cfa6:	1ad3      	subs	r3, r2, r3
 802cfa8:	2b02      	cmp	r3, #2
 802cfaa:	d901      	bls.n	802cfb0 <HAL_RCC_OscConfig+0x3d8>
          {
            return HAL_TIMEOUT;
 802cfac:	2303      	movs	r3, #3
 802cfae:	e078      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802cfb0:	4b3f      	ldr	r3, [pc, #252]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cfb2:	681b      	ldr	r3, [r3, #0]
 802cfb4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802cfb8:	2b00      	cmp	r3, #0
 802cfba:	d1f0      	bne.n	802cf9e <HAL_RCC_OscConfig+0x3c6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 802cfbc:	687b      	ldr	r3, [r7, #4]
 802cfbe:	69da      	ldr	r2, [r3, #28]
 802cfc0:	687b      	ldr	r3, [r7, #4]
 802cfc2:	6a1b      	ldr	r3, [r3, #32]
 802cfc4:	431a      	orrs	r2, r3
 802cfc6:	687b      	ldr	r3, [r7, #4]
 802cfc8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802cfca:	019b      	lsls	r3, r3, #6
 802cfcc:	431a      	orrs	r2, r3
 802cfce:	687b      	ldr	r3, [r7, #4]
 802cfd0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802cfd2:	085b      	lsrs	r3, r3, #1
 802cfd4:	3b01      	subs	r3, #1
 802cfd6:	041b      	lsls	r3, r3, #16
 802cfd8:	431a      	orrs	r2, r3
 802cfda:	687b      	ldr	r3, [r7, #4]
 802cfdc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802cfde:	061b      	lsls	r3, r3, #24
 802cfe0:	4933      	ldr	r1, [pc, #204]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802cfe2:	4313      	orrs	r3, r2
 802cfe4:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 802cfe6:	4b33      	ldr	r3, [pc, #204]	; (802d0b4 <HAL_RCC_OscConfig+0x4dc>)
 802cfe8:	2201      	movs	r2, #1
 802cfea:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802cfec:	f7fe ff70 	bl	802bed0 <HAL_GetTick>
 802cff0:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 802cff2:	e008      	b.n	802d006 <HAL_RCC_OscConfig+0x42e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802cff4:	f7fe ff6c 	bl	802bed0 <HAL_GetTick>
 802cff8:	4602      	mov	r2, r0
 802cffa:	693b      	ldr	r3, [r7, #16]
 802cffc:	1ad3      	subs	r3, r2, r3
 802cffe:	2b02      	cmp	r3, #2
 802d000:	d901      	bls.n	802d006 <HAL_RCC_OscConfig+0x42e>
          {
            return HAL_TIMEOUT;
 802d002:	2303      	movs	r3, #3
 802d004:	e04d      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 802d006:	4b2a      	ldr	r3, [pc, #168]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802d008:	681b      	ldr	r3, [r3, #0]
 802d00a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802d00e:	2b00      	cmp	r3, #0
 802d010:	d0f0      	beq.n	802cff4 <HAL_RCC_OscConfig+0x41c>
 802d012:	e045      	b.n	802d0a0 <HAL_RCC_OscConfig+0x4c8>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 802d014:	4b27      	ldr	r3, [pc, #156]	; (802d0b4 <HAL_RCC_OscConfig+0x4dc>)
 802d016:	2200      	movs	r2, #0
 802d018:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802d01a:	f7fe ff59 	bl	802bed0 <HAL_GetTick>
 802d01e:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802d020:	e008      	b.n	802d034 <HAL_RCC_OscConfig+0x45c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802d022:	f7fe ff55 	bl	802bed0 <HAL_GetTick>
 802d026:	4602      	mov	r2, r0
 802d028:	693b      	ldr	r3, [r7, #16]
 802d02a:	1ad3      	subs	r3, r2, r3
 802d02c:	2b02      	cmp	r3, #2
 802d02e:	d901      	bls.n	802d034 <HAL_RCC_OscConfig+0x45c>
          {
            return HAL_TIMEOUT;
 802d030:	2303      	movs	r3, #3
 802d032:	e036      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802d034:	4b1e      	ldr	r3, [pc, #120]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802d036:	681b      	ldr	r3, [r3, #0]
 802d038:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802d03c:	2b00      	cmp	r3, #0
 802d03e:	d1f0      	bne.n	802d022 <HAL_RCC_OscConfig+0x44a>
 802d040:	e02e      	b.n	802d0a0 <HAL_RCC_OscConfig+0x4c8>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 802d042:	687b      	ldr	r3, [r7, #4]
 802d044:	699b      	ldr	r3, [r3, #24]
 802d046:	2b01      	cmp	r3, #1
 802d048:	d101      	bne.n	802d04e <HAL_RCC_OscConfig+0x476>
      {
        return HAL_ERROR;
 802d04a:	2301      	movs	r3, #1
 802d04c:	e029      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 802d04e:	4b18      	ldr	r3, [pc, #96]	; (802d0b0 <HAL_RCC_OscConfig+0x4d8>)
 802d050:	689b      	ldr	r3, [r3, #8]
 802d052:	60fb      	str	r3, [r7, #12]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 802d054:	68fb      	ldr	r3, [r7, #12]
 802d056:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 802d05a:	687b      	ldr	r3, [r7, #4]
 802d05c:	69db      	ldr	r3, [r3, #28]
 802d05e:	429a      	cmp	r2, r3
 802d060:	d11c      	bne.n	802d09c <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 802d062:	68fb      	ldr	r3, [r7, #12]
 802d064:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 802d068:	687b      	ldr	r3, [r7, #4]
 802d06a:	6a1b      	ldr	r3, [r3, #32]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 802d06c:	429a      	cmp	r2, r3
 802d06e:	d115      	bne.n	802d09c <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 802d070:	68fa      	ldr	r2, [r7, #12]
 802d072:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 802d076:	4013      	ands	r3, r2
 802d078:	687a      	ldr	r2, [r7, #4]
 802d07a:	6a52      	ldr	r2, [r2, #36]	; 0x24
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 802d07c:	4293      	cmp	r3, r2
 802d07e:	d10d      	bne.n	802d09c <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 802d080:	68fb      	ldr	r3, [r7, #12]
 802d082:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 802d086:	687b      	ldr	r3, [r7, #4]
 802d088:	6a9b      	ldr	r3, [r3, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 802d08a:	429a      	cmp	r2, r3
 802d08c:	d106      	bne.n	802d09c <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 802d08e:	68fb      	ldr	r3, [r7, #12]
 802d090:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 802d094:	687b      	ldr	r3, [r7, #4]
 802d096:	6adb      	ldr	r3, [r3, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 802d098:	429a      	cmp	r2, r3
 802d09a:	d001      	beq.n	802d0a0 <HAL_RCC_OscConfig+0x4c8>
        {
          return HAL_ERROR;
 802d09c:	2301      	movs	r3, #1
 802d09e:	e000      	b.n	802d0a2 <HAL_RCC_OscConfig+0x4ca>
        }
      }
    }
  }
  return HAL_OK;
 802d0a0:	2300      	movs	r3, #0
}
 802d0a2:	4618      	mov	r0, r3
 802d0a4:	3718      	adds	r7, #24
 802d0a6:	46bd      	mov	sp, r7
 802d0a8:	bd80      	pop	{r7, pc}
 802d0aa:	bf00      	nop
 802d0ac:	40007000 	.word	0x40007000
 802d0b0:	40023800 	.word	0x40023800
 802d0b4:	42470060 	.word	0x42470060

0802d0b8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 802d0b8:	b580      	push	{r7, lr}
 802d0ba:	b084      	sub	sp, #16
 802d0bc:	af00      	add	r7, sp, #0
 802d0be:	6078      	str	r0, [r7, #4]
 802d0c0:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 802d0c2:	687b      	ldr	r3, [r7, #4]
 802d0c4:	2b00      	cmp	r3, #0
 802d0c6:	d101      	bne.n	802d0cc <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 802d0c8:	2301      	movs	r3, #1
 802d0ca:	e0cc      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 802d0cc:	4b68      	ldr	r3, [pc, #416]	; (802d270 <HAL_RCC_ClockConfig+0x1b8>)
 802d0ce:	681b      	ldr	r3, [r3, #0]
 802d0d0:	f003 030f 	and.w	r3, r3, #15
 802d0d4:	683a      	ldr	r2, [r7, #0]
 802d0d6:	429a      	cmp	r2, r3
 802d0d8:	d90c      	bls.n	802d0f4 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 802d0da:	4b65      	ldr	r3, [pc, #404]	; (802d270 <HAL_RCC_ClockConfig+0x1b8>)
 802d0dc:	683a      	ldr	r2, [r7, #0]
 802d0de:	b2d2      	uxtb	r2, r2
 802d0e0:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 802d0e2:	4b63      	ldr	r3, [pc, #396]	; (802d270 <HAL_RCC_ClockConfig+0x1b8>)
 802d0e4:	681b      	ldr	r3, [r3, #0]
 802d0e6:	f003 030f 	and.w	r3, r3, #15
 802d0ea:	683a      	ldr	r2, [r7, #0]
 802d0ec:	429a      	cmp	r2, r3
 802d0ee:	d001      	beq.n	802d0f4 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 802d0f0:	2301      	movs	r3, #1
 802d0f2:	e0b8      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 802d0f4:	687b      	ldr	r3, [r7, #4]
 802d0f6:	681b      	ldr	r3, [r3, #0]
 802d0f8:	f003 0302 	and.w	r3, r3, #2
 802d0fc:	2b00      	cmp	r3, #0
 802d0fe:	d020      	beq.n	802d142 <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802d100:	687b      	ldr	r3, [r7, #4]
 802d102:	681b      	ldr	r3, [r3, #0]
 802d104:	f003 0304 	and.w	r3, r3, #4
 802d108:	2b00      	cmp	r3, #0
 802d10a:	d005      	beq.n	802d118 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 802d10c:	4b59      	ldr	r3, [pc, #356]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d10e:	689b      	ldr	r3, [r3, #8]
 802d110:	4a58      	ldr	r2, [pc, #352]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d112:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 802d116:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802d118:	687b      	ldr	r3, [r7, #4]
 802d11a:	681b      	ldr	r3, [r3, #0]
 802d11c:	f003 0308 	and.w	r3, r3, #8
 802d120:	2b00      	cmp	r3, #0
 802d122:	d005      	beq.n	802d130 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 802d124:	4b53      	ldr	r3, [pc, #332]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d126:	689b      	ldr	r3, [r3, #8]
 802d128:	4a52      	ldr	r2, [pc, #328]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d12a:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 802d12e:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 802d130:	4b50      	ldr	r3, [pc, #320]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d132:	689b      	ldr	r3, [r3, #8]
 802d134:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 802d138:	687b      	ldr	r3, [r7, #4]
 802d13a:	689b      	ldr	r3, [r3, #8]
 802d13c:	494d      	ldr	r1, [pc, #308]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d13e:	4313      	orrs	r3, r2
 802d140:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 802d142:	687b      	ldr	r3, [r7, #4]
 802d144:	681b      	ldr	r3, [r3, #0]
 802d146:	f003 0301 	and.w	r3, r3, #1
 802d14a:	2b00      	cmp	r3, #0
 802d14c:	d044      	beq.n	802d1d8 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802d14e:	687b      	ldr	r3, [r7, #4]
 802d150:	685b      	ldr	r3, [r3, #4]
 802d152:	2b01      	cmp	r3, #1
 802d154:	d107      	bne.n	802d166 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802d156:	4b47      	ldr	r3, [pc, #284]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d158:	681b      	ldr	r3, [r3, #0]
 802d15a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802d15e:	2b00      	cmp	r3, #0
 802d160:	d119      	bne.n	802d196 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 802d162:	2301      	movs	r3, #1
 802d164:	e07f      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 802d166:	687b      	ldr	r3, [r7, #4]
 802d168:	685b      	ldr	r3, [r3, #4]
 802d16a:	2b02      	cmp	r3, #2
 802d16c:	d003      	beq.n	802d176 <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 802d16e:	687b      	ldr	r3, [r7, #4]
 802d170:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 802d172:	2b03      	cmp	r3, #3
 802d174:	d107      	bne.n	802d186 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 802d176:	4b3f      	ldr	r3, [pc, #252]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d178:	681b      	ldr	r3, [r3, #0]
 802d17a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802d17e:	2b00      	cmp	r3, #0
 802d180:	d109      	bne.n	802d196 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 802d182:	2301      	movs	r3, #1
 802d184:	e06f      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802d186:	4b3b      	ldr	r3, [pc, #236]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d188:	681b      	ldr	r3, [r3, #0]
 802d18a:	f003 0302 	and.w	r3, r3, #2
 802d18e:	2b00      	cmp	r3, #0
 802d190:	d101      	bne.n	802d196 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 802d192:	2301      	movs	r3, #1
 802d194:	e067      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 802d196:	4b37      	ldr	r3, [pc, #220]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d198:	689b      	ldr	r3, [r3, #8]
 802d19a:	f023 0203 	bic.w	r2, r3, #3
 802d19e:	687b      	ldr	r3, [r7, #4]
 802d1a0:	685b      	ldr	r3, [r3, #4]
 802d1a2:	4934      	ldr	r1, [pc, #208]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d1a4:	4313      	orrs	r3, r2
 802d1a6:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 802d1a8:	f7fe fe92 	bl	802bed0 <HAL_GetTick>
 802d1ac:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802d1ae:	e00a      	b.n	802d1c6 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802d1b0:	f7fe fe8e 	bl	802bed0 <HAL_GetTick>
 802d1b4:	4602      	mov	r2, r0
 802d1b6:	68fb      	ldr	r3, [r7, #12]
 802d1b8:	1ad3      	subs	r3, r2, r3
 802d1ba:	f241 3288 	movw	r2, #5000	; 0x1388
 802d1be:	4293      	cmp	r3, r2
 802d1c0:	d901      	bls.n	802d1c6 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 802d1c2:	2303      	movs	r3, #3
 802d1c4:	e04f      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802d1c6:	4b2b      	ldr	r3, [pc, #172]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d1c8:	689b      	ldr	r3, [r3, #8]
 802d1ca:	f003 020c 	and.w	r2, r3, #12
 802d1ce:	687b      	ldr	r3, [r7, #4]
 802d1d0:	685b      	ldr	r3, [r3, #4]
 802d1d2:	009b      	lsls	r3, r3, #2
 802d1d4:	429a      	cmp	r2, r3
 802d1d6:	d1eb      	bne.n	802d1b0 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 802d1d8:	4b25      	ldr	r3, [pc, #148]	; (802d270 <HAL_RCC_ClockConfig+0x1b8>)
 802d1da:	681b      	ldr	r3, [r3, #0]
 802d1dc:	f003 030f 	and.w	r3, r3, #15
 802d1e0:	683a      	ldr	r2, [r7, #0]
 802d1e2:	429a      	cmp	r2, r3
 802d1e4:	d20c      	bcs.n	802d200 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 802d1e6:	4b22      	ldr	r3, [pc, #136]	; (802d270 <HAL_RCC_ClockConfig+0x1b8>)
 802d1e8:	683a      	ldr	r2, [r7, #0]
 802d1ea:	b2d2      	uxtb	r2, r2
 802d1ec:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 802d1ee:	4b20      	ldr	r3, [pc, #128]	; (802d270 <HAL_RCC_ClockConfig+0x1b8>)
 802d1f0:	681b      	ldr	r3, [r3, #0]
 802d1f2:	f003 030f 	and.w	r3, r3, #15
 802d1f6:	683a      	ldr	r2, [r7, #0]
 802d1f8:	429a      	cmp	r2, r3
 802d1fa:	d001      	beq.n	802d200 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 802d1fc:	2301      	movs	r3, #1
 802d1fe:	e032      	b.n	802d266 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802d200:	687b      	ldr	r3, [r7, #4]
 802d202:	681b      	ldr	r3, [r3, #0]
 802d204:	f003 0304 	and.w	r3, r3, #4
 802d208:	2b00      	cmp	r3, #0
 802d20a:	d008      	beq.n	802d21e <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 802d20c:	4b19      	ldr	r3, [pc, #100]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d20e:	689b      	ldr	r3, [r3, #8]
 802d210:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 802d214:	687b      	ldr	r3, [r7, #4]
 802d216:	68db      	ldr	r3, [r3, #12]
 802d218:	4916      	ldr	r1, [pc, #88]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d21a:	4313      	orrs	r3, r2
 802d21c:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802d21e:	687b      	ldr	r3, [r7, #4]
 802d220:	681b      	ldr	r3, [r3, #0]
 802d222:	f003 0308 	and.w	r3, r3, #8
 802d226:	2b00      	cmp	r3, #0
 802d228:	d009      	beq.n	802d23e <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 802d22a:	4b12      	ldr	r3, [pc, #72]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d22c:	689b      	ldr	r3, [r3, #8]
 802d22e:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 802d232:	687b      	ldr	r3, [r7, #4]
 802d234:	691b      	ldr	r3, [r3, #16]
 802d236:	00db      	lsls	r3, r3, #3
 802d238:	490e      	ldr	r1, [pc, #56]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d23a:	4313      	orrs	r3, r2
 802d23c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 802d23e:	f000 f821 	bl	802d284 <HAL_RCC_GetSysClockFreq>
 802d242:	4601      	mov	r1, r0
 802d244:	4b0b      	ldr	r3, [pc, #44]	; (802d274 <HAL_RCC_ClockConfig+0x1bc>)
 802d246:	689b      	ldr	r3, [r3, #8]
 802d248:	091b      	lsrs	r3, r3, #4
 802d24a:	f003 030f 	and.w	r3, r3, #15
 802d24e:	4a0a      	ldr	r2, [pc, #40]	; (802d278 <HAL_RCC_ClockConfig+0x1c0>)
 802d250:	5cd3      	ldrb	r3, [r2, r3]
 802d252:	fa21 f303 	lsr.w	r3, r1, r3
 802d256:	4a09      	ldr	r2, [pc, #36]	; (802d27c <HAL_RCC_ClockConfig+0x1c4>)
 802d258:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 802d25a:	4b09      	ldr	r3, [pc, #36]	; (802d280 <HAL_RCC_ClockConfig+0x1c8>)
 802d25c:	681b      	ldr	r3, [r3, #0]
 802d25e:	4618      	mov	r0, r3
 802d260:	f7fe fdf2 	bl	802be48 <HAL_InitTick>

  return HAL_OK;
 802d264:	2300      	movs	r3, #0
}
 802d266:	4618      	mov	r0, r3
 802d268:	3710      	adds	r7, #16
 802d26a:	46bd      	mov	sp, r7
 802d26c:	bd80      	pop	{r7, pc}
 802d26e:	bf00      	nop
 802d270:	40023c00 	.word	0x40023c00
 802d274:	40023800 	.word	0x40023800
 802d278:	08030edc 	.word	0x08030edc
 802d27c:	200005c0 	.word	0x200005c0
 802d280:	200005c4 	.word	0x200005c4

0802d284 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 802d284:	b5f0      	push	{r4, r5, r6, r7, lr}
 802d286:	b085      	sub	sp, #20
 802d288:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 802d28a:	2300      	movs	r3, #0
 802d28c:	607b      	str	r3, [r7, #4]
 802d28e:	2300      	movs	r3, #0
 802d290:	60fb      	str	r3, [r7, #12]
 802d292:	2300      	movs	r3, #0
 802d294:	603b      	str	r3, [r7, #0]
  uint32_t sysclockfreq = 0U;
 802d296:	2300      	movs	r3, #0
 802d298:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 802d29a:	4b63      	ldr	r3, [pc, #396]	; (802d428 <HAL_RCC_GetSysClockFreq+0x1a4>)
 802d29c:	689b      	ldr	r3, [r3, #8]
 802d29e:	f003 030c 	and.w	r3, r3, #12
 802d2a2:	2b04      	cmp	r3, #4
 802d2a4:	d007      	beq.n	802d2b6 <HAL_RCC_GetSysClockFreq+0x32>
 802d2a6:	2b08      	cmp	r3, #8
 802d2a8:	d008      	beq.n	802d2bc <HAL_RCC_GetSysClockFreq+0x38>
 802d2aa:	2b00      	cmp	r3, #0
 802d2ac:	f040 80b4 	bne.w	802d418 <HAL_RCC_GetSysClockFreq+0x194>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 802d2b0:	4b5e      	ldr	r3, [pc, #376]	; (802d42c <HAL_RCC_GetSysClockFreq+0x1a8>)
 802d2b2:	60bb      	str	r3, [r7, #8]
       break;
 802d2b4:	e0b3      	b.n	802d41e <HAL_RCC_GetSysClockFreq+0x19a>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 802d2b6:	4b5e      	ldr	r3, [pc, #376]	; (802d430 <HAL_RCC_GetSysClockFreq+0x1ac>)
 802d2b8:	60bb      	str	r3, [r7, #8]
      break;
 802d2ba:	e0b0      	b.n	802d41e <HAL_RCC_GetSysClockFreq+0x19a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 802d2bc:	4b5a      	ldr	r3, [pc, #360]	; (802d428 <HAL_RCC_GetSysClockFreq+0x1a4>)
 802d2be:	685b      	ldr	r3, [r3, #4]
 802d2c0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 802d2c4:	607b      	str	r3, [r7, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 802d2c6:	4b58      	ldr	r3, [pc, #352]	; (802d428 <HAL_RCC_GetSysClockFreq+0x1a4>)
 802d2c8:	685b      	ldr	r3, [r3, #4]
 802d2ca:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802d2ce:	2b00      	cmp	r3, #0
 802d2d0:	d04a      	beq.n	802d368 <HAL_RCC_GetSysClockFreq+0xe4>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 802d2d2:	4b55      	ldr	r3, [pc, #340]	; (802d428 <HAL_RCC_GetSysClockFreq+0x1a4>)
 802d2d4:	685b      	ldr	r3, [r3, #4]
 802d2d6:	099b      	lsrs	r3, r3, #6
 802d2d8:	f04f 0400 	mov.w	r4, #0
 802d2dc:	f240 11ff 	movw	r1, #511	; 0x1ff
 802d2e0:	f04f 0200 	mov.w	r2, #0
 802d2e4:	ea03 0501 	and.w	r5, r3, r1
 802d2e8:	ea04 0602 	and.w	r6, r4, r2
 802d2ec:	4629      	mov	r1, r5
 802d2ee:	4632      	mov	r2, r6
 802d2f0:	f04f 0300 	mov.w	r3, #0
 802d2f4:	f04f 0400 	mov.w	r4, #0
 802d2f8:	0154      	lsls	r4, r2, #5
 802d2fa:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 802d2fe:	014b      	lsls	r3, r1, #5
 802d300:	4619      	mov	r1, r3
 802d302:	4622      	mov	r2, r4
 802d304:	1b49      	subs	r1, r1, r5
 802d306:	eb62 0206 	sbc.w	r2, r2, r6
 802d30a:	f04f 0300 	mov.w	r3, #0
 802d30e:	f04f 0400 	mov.w	r4, #0
 802d312:	0194      	lsls	r4, r2, #6
 802d314:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 802d318:	018b      	lsls	r3, r1, #6
 802d31a:	1a5b      	subs	r3, r3, r1
 802d31c:	eb64 0402 	sbc.w	r4, r4, r2
 802d320:	f04f 0100 	mov.w	r1, #0
 802d324:	f04f 0200 	mov.w	r2, #0
 802d328:	00e2      	lsls	r2, r4, #3
 802d32a:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 802d32e:	00d9      	lsls	r1, r3, #3
 802d330:	460b      	mov	r3, r1
 802d332:	4614      	mov	r4, r2
 802d334:	195b      	adds	r3, r3, r5
 802d336:	eb44 0406 	adc.w	r4, r4, r6
 802d33a:	f04f 0100 	mov.w	r1, #0
 802d33e:	f04f 0200 	mov.w	r2, #0
 802d342:	0262      	lsls	r2, r4, #9
 802d344:	ea42 52d3 	orr.w	r2, r2, r3, lsr #23
 802d348:	0259      	lsls	r1, r3, #9
 802d34a:	460b      	mov	r3, r1
 802d34c:	4614      	mov	r4, r2
 802d34e:	4618      	mov	r0, r3
 802d350:	4621      	mov	r1, r4
 802d352:	687b      	ldr	r3, [r7, #4]
 802d354:	f04f 0400 	mov.w	r4, #0
 802d358:	461a      	mov	r2, r3
 802d35a:	4623      	mov	r3, r4
 802d35c:	f7fb ff04 	bl	8029168 <__aeabi_uldivmod>
 802d360:	4603      	mov	r3, r0
 802d362:	460c      	mov	r4, r1
 802d364:	60fb      	str	r3, [r7, #12]
 802d366:	e049      	b.n	802d3fc <HAL_RCC_GetSysClockFreq+0x178>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 802d368:	4b2f      	ldr	r3, [pc, #188]	; (802d428 <HAL_RCC_GetSysClockFreq+0x1a4>)
 802d36a:	685b      	ldr	r3, [r3, #4]
 802d36c:	099b      	lsrs	r3, r3, #6
 802d36e:	f04f 0400 	mov.w	r4, #0
 802d372:	f240 11ff 	movw	r1, #511	; 0x1ff
 802d376:	f04f 0200 	mov.w	r2, #0
 802d37a:	ea03 0501 	and.w	r5, r3, r1
 802d37e:	ea04 0602 	and.w	r6, r4, r2
 802d382:	4629      	mov	r1, r5
 802d384:	4632      	mov	r2, r6
 802d386:	f04f 0300 	mov.w	r3, #0
 802d38a:	f04f 0400 	mov.w	r4, #0
 802d38e:	0154      	lsls	r4, r2, #5
 802d390:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 802d394:	014b      	lsls	r3, r1, #5
 802d396:	4619      	mov	r1, r3
 802d398:	4622      	mov	r2, r4
 802d39a:	1b49      	subs	r1, r1, r5
 802d39c:	eb62 0206 	sbc.w	r2, r2, r6
 802d3a0:	f04f 0300 	mov.w	r3, #0
 802d3a4:	f04f 0400 	mov.w	r4, #0
 802d3a8:	0194      	lsls	r4, r2, #6
 802d3aa:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 802d3ae:	018b      	lsls	r3, r1, #6
 802d3b0:	1a5b      	subs	r3, r3, r1
 802d3b2:	eb64 0402 	sbc.w	r4, r4, r2
 802d3b6:	f04f 0100 	mov.w	r1, #0
 802d3ba:	f04f 0200 	mov.w	r2, #0
 802d3be:	00e2      	lsls	r2, r4, #3
 802d3c0:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 802d3c4:	00d9      	lsls	r1, r3, #3
 802d3c6:	460b      	mov	r3, r1
 802d3c8:	4614      	mov	r4, r2
 802d3ca:	195b      	adds	r3, r3, r5
 802d3cc:	eb44 0406 	adc.w	r4, r4, r6
 802d3d0:	f04f 0100 	mov.w	r1, #0
 802d3d4:	f04f 0200 	mov.w	r2, #0
 802d3d8:	02a2      	lsls	r2, r4, #10
 802d3da:	ea42 5293 	orr.w	r2, r2, r3, lsr #22
 802d3de:	0299      	lsls	r1, r3, #10
 802d3e0:	460b      	mov	r3, r1
 802d3e2:	4614      	mov	r4, r2
 802d3e4:	4618      	mov	r0, r3
 802d3e6:	4621      	mov	r1, r4
 802d3e8:	687b      	ldr	r3, [r7, #4]
 802d3ea:	f04f 0400 	mov.w	r4, #0
 802d3ee:	461a      	mov	r2, r3
 802d3f0:	4623      	mov	r3, r4
 802d3f2:	f7fb feb9 	bl	8029168 <__aeabi_uldivmod>
 802d3f6:	4603      	mov	r3, r0
 802d3f8:	460c      	mov	r4, r1
 802d3fa:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 802d3fc:	4b0a      	ldr	r3, [pc, #40]	; (802d428 <HAL_RCC_GetSysClockFreq+0x1a4>)
 802d3fe:	685b      	ldr	r3, [r3, #4]
 802d400:	0c1b      	lsrs	r3, r3, #16
 802d402:	f003 0303 	and.w	r3, r3, #3
 802d406:	3301      	adds	r3, #1
 802d408:	005b      	lsls	r3, r3, #1
 802d40a:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco/pllp;
 802d40c:	68fa      	ldr	r2, [r7, #12]
 802d40e:	683b      	ldr	r3, [r7, #0]
 802d410:	fbb2 f3f3 	udiv	r3, r2, r3
 802d414:	60bb      	str	r3, [r7, #8]
      break;
 802d416:	e002      	b.n	802d41e <HAL_RCC_GetSysClockFreq+0x19a>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 802d418:	4b04      	ldr	r3, [pc, #16]	; (802d42c <HAL_RCC_GetSysClockFreq+0x1a8>)
 802d41a:	60bb      	str	r3, [r7, #8]
      break;
 802d41c:	bf00      	nop
    }
  }
  return sysclockfreq;
 802d41e:	68bb      	ldr	r3, [r7, #8]
}
 802d420:	4618      	mov	r0, r3
 802d422:	3714      	adds	r7, #20
 802d424:	46bd      	mov	sp, r7
 802d426:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802d428:	40023800 	.word	0x40023800
 802d42c:	00f42400 	.word	0x00f42400
 802d430:	007a1200 	.word	0x007a1200

0802d434 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 802d434:	b480      	push	{r7}
 802d436:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 802d438:	4b03      	ldr	r3, [pc, #12]	; (802d448 <HAL_RCC_GetHCLKFreq+0x14>)
 802d43a:	681b      	ldr	r3, [r3, #0]
}
 802d43c:	4618      	mov	r0, r3
 802d43e:	46bd      	mov	sp, r7
 802d440:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d444:	4770      	bx	lr
 802d446:	bf00      	nop
 802d448:	200005c0 	.word	0x200005c0

0802d44c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 802d44c:	b580      	push	{r7, lr}
 802d44e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 802d450:	f7ff fff0 	bl	802d434 <HAL_RCC_GetHCLKFreq>
 802d454:	4601      	mov	r1, r0
 802d456:	4b05      	ldr	r3, [pc, #20]	; (802d46c <HAL_RCC_GetPCLK1Freq+0x20>)
 802d458:	689b      	ldr	r3, [r3, #8]
 802d45a:	0a9b      	lsrs	r3, r3, #10
 802d45c:	f003 0307 	and.w	r3, r3, #7
 802d460:	4a03      	ldr	r2, [pc, #12]	; (802d470 <HAL_RCC_GetPCLK1Freq+0x24>)
 802d462:	5cd3      	ldrb	r3, [r2, r3]
 802d464:	fa21 f303 	lsr.w	r3, r1, r3
}
 802d468:	4618      	mov	r0, r3
 802d46a:	bd80      	pop	{r7, pc}
 802d46c:	40023800 	.word	0x40023800
 802d470:	08030eec 	.word	0x08030eec

0802d474 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 802d474:	b580      	push	{r7, lr}
 802d476:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 802d478:	f7ff ffdc 	bl	802d434 <HAL_RCC_GetHCLKFreq>
 802d47c:	4601      	mov	r1, r0
 802d47e:	4b05      	ldr	r3, [pc, #20]	; (802d494 <HAL_RCC_GetPCLK2Freq+0x20>)
 802d480:	689b      	ldr	r3, [r3, #8]
 802d482:	0b5b      	lsrs	r3, r3, #13
 802d484:	f003 0307 	and.w	r3, r3, #7
 802d488:	4a03      	ldr	r2, [pc, #12]	; (802d498 <HAL_RCC_GetPCLK2Freq+0x24>)
 802d48a:	5cd3      	ldrb	r3, [r2, r3]
 802d48c:	fa21 f303 	lsr.w	r3, r1, r3
}
 802d490:	4618      	mov	r0, r3
 802d492:	bd80      	pop	{r7, pc}
 802d494:	40023800 	.word	0x40023800
 802d498:	08030eec 	.word	0x08030eec

0802d49c <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 802d49c:	b580      	push	{r7, lr}
 802d49e:	b082      	sub	sp, #8
 802d4a0:	af00      	add	r7, sp, #0
 802d4a2:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 802d4a4:	687b      	ldr	r3, [r7, #4]
 802d4a6:	2b00      	cmp	r3, #0
 802d4a8:	d101      	bne.n	802d4ae <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 802d4aa:	2301      	movs	r3, #1
 802d4ac:	e056      	b.n	802d55c <HAL_SPI_Init+0xc0>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802d4ae:	687b      	ldr	r3, [r7, #4]
 802d4b0:	2200      	movs	r2, #0
 802d4b2:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 802d4b4:	687b      	ldr	r3, [r7, #4]
 802d4b6:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802d4ba:	b2db      	uxtb	r3, r3
 802d4bc:	2b00      	cmp	r3, #0
 802d4be:	d106      	bne.n	802d4ce <HAL_SPI_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 802d4c0:	687b      	ldr	r3, [r7, #4]
 802d4c2:	2200      	movs	r2, #0
 802d4c4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 802d4c8:	6878      	ldr	r0, [r7, #4]
 802d4ca:	f7fe f923 	bl	802b714 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 802d4ce:	687b      	ldr	r3, [r7, #4]
 802d4d0:	2202      	movs	r2, #2
 802d4d2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 802d4d6:	687b      	ldr	r3, [r7, #4]
 802d4d8:	681b      	ldr	r3, [r3, #0]
 802d4da:	681a      	ldr	r2, [r3, #0]
 802d4dc:	687b      	ldr	r3, [r7, #4]
 802d4de:	681b      	ldr	r3, [r3, #0]
 802d4e0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802d4e4:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 802d4e6:	687b      	ldr	r3, [r7, #4]
 802d4e8:	685a      	ldr	r2, [r3, #4]
 802d4ea:	687b      	ldr	r3, [r7, #4]
 802d4ec:	689b      	ldr	r3, [r3, #8]
 802d4ee:	431a      	orrs	r2, r3
 802d4f0:	687b      	ldr	r3, [r7, #4]
 802d4f2:	68db      	ldr	r3, [r3, #12]
 802d4f4:	431a      	orrs	r2, r3
 802d4f6:	687b      	ldr	r3, [r7, #4]
 802d4f8:	691b      	ldr	r3, [r3, #16]
 802d4fa:	431a      	orrs	r2, r3
 802d4fc:	687b      	ldr	r3, [r7, #4]
 802d4fe:	695b      	ldr	r3, [r3, #20]
 802d500:	431a      	orrs	r2, r3
 802d502:	687b      	ldr	r3, [r7, #4]
 802d504:	699b      	ldr	r3, [r3, #24]
 802d506:	f403 7300 	and.w	r3, r3, #512	; 0x200
 802d50a:	431a      	orrs	r2, r3
 802d50c:	687b      	ldr	r3, [r7, #4]
 802d50e:	69db      	ldr	r3, [r3, #28]
 802d510:	431a      	orrs	r2, r3
 802d512:	687b      	ldr	r3, [r7, #4]
 802d514:	6a1b      	ldr	r3, [r3, #32]
 802d516:	ea42 0103 	orr.w	r1, r2, r3
 802d51a:	687b      	ldr	r3, [r7, #4]
 802d51c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802d51e:	687b      	ldr	r3, [r7, #4]
 802d520:	681b      	ldr	r3, [r3, #0]
 802d522:	430a      	orrs	r2, r1
 802d524:	601a      	str	r2, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 802d526:	687b      	ldr	r3, [r7, #4]
 802d528:	699b      	ldr	r3, [r3, #24]
 802d52a:	0c1b      	lsrs	r3, r3, #16
 802d52c:	f003 0104 	and.w	r1, r3, #4
 802d530:	687b      	ldr	r3, [r7, #4]
 802d532:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802d534:	687b      	ldr	r3, [r7, #4]
 802d536:	681b      	ldr	r3, [r3, #0]
 802d538:	430a      	orrs	r2, r1
 802d53a:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 802d53c:	687b      	ldr	r3, [r7, #4]
 802d53e:	681b      	ldr	r3, [r3, #0]
 802d540:	69da      	ldr	r2, [r3, #28]
 802d542:	687b      	ldr	r3, [r7, #4]
 802d544:	681b      	ldr	r3, [r3, #0]
 802d546:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 802d54a:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 802d54c:	687b      	ldr	r3, [r7, #4]
 802d54e:	2200      	movs	r2, #0
 802d550:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 802d552:	687b      	ldr	r3, [r7, #4]
 802d554:	2201      	movs	r2, #1
 802d556:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
 802d55a:	2300      	movs	r3, #0
}
 802d55c:	4618      	mov	r0, r3
 802d55e:	3708      	adds	r7, #8
 802d560:	46bd      	mov	sp, r7
 802d562:	bd80      	pop	{r7, pc}

0802d564 <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 802d564:	b580      	push	{r7, lr}
 802d566:	b088      	sub	sp, #32
 802d568:	af00      	add	r7, sp, #0
 802d56a:	60f8      	str	r0, [r7, #12]
 802d56c:	60b9      	str	r1, [r7, #8]
 802d56e:	603b      	str	r3, [r7, #0]
 802d570:	4613      	mov	r3, r2
 802d572:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 802d574:	2300      	movs	r3, #0
 802d576:	77fb      	strb	r3, [r7, #31]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 802d578:	68fb      	ldr	r3, [r7, #12]
 802d57a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802d57e:	2b01      	cmp	r3, #1
 802d580:	d101      	bne.n	802d586 <HAL_SPI_Transmit+0x22>
 802d582:	2302      	movs	r3, #2
 802d584:	e11e      	b.n	802d7c4 <HAL_SPI_Transmit+0x260>
 802d586:	68fb      	ldr	r3, [r7, #12]
 802d588:	2201      	movs	r2, #1
 802d58a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802d58e:	f7fe fc9f 	bl	802bed0 <HAL_GetTick>
 802d592:	61b8      	str	r0, [r7, #24]
  initial_TxXferCount = Size;
 802d594:	88fb      	ldrh	r3, [r7, #6]
 802d596:	82fb      	strh	r3, [r7, #22]

  if (hspi->State != HAL_SPI_STATE_READY)
 802d598:	68fb      	ldr	r3, [r7, #12]
 802d59a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802d59e:	b2db      	uxtb	r3, r3
 802d5a0:	2b01      	cmp	r3, #1
 802d5a2:	d002      	beq.n	802d5aa <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 802d5a4:	2302      	movs	r3, #2
 802d5a6:	77fb      	strb	r3, [r7, #31]
    goto error;
 802d5a8:	e103      	b.n	802d7b2 <HAL_SPI_Transmit+0x24e>
  }

  if ((pData == NULL) || (Size == 0U))
 802d5aa:	68bb      	ldr	r3, [r7, #8]
 802d5ac:	2b00      	cmp	r3, #0
 802d5ae:	d002      	beq.n	802d5b6 <HAL_SPI_Transmit+0x52>
 802d5b0:	88fb      	ldrh	r3, [r7, #6]
 802d5b2:	2b00      	cmp	r3, #0
 802d5b4:	d102      	bne.n	802d5bc <HAL_SPI_Transmit+0x58>
  {
    errorcode = HAL_ERROR;
 802d5b6:	2301      	movs	r3, #1
 802d5b8:	77fb      	strb	r3, [r7, #31]
    goto error;
 802d5ba:	e0fa      	b.n	802d7b2 <HAL_SPI_Transmit+0x24e>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 802d5bc:	68fb      	ldr	r3, [r7, #12]
 802d5be:	2203      	movs	r2, #3
 802d5c0:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802d5c4:	68fb      	ldr	r3, [r7, #12]
 802d5c6:	2200      	movs	r2, #0
 802d5c8:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 802d5ca:	68fb      	ldr	r3, [r7, #12]
 802d5cc:	68ba      	ldr	r2, [r7, #8]
 802d5ce:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferSize  = Size;
 802d5d0:	68fb      	ldr	r3, [r7, #12]
 802d5d2:	88fa      	ldrh	r2, [r7, #6]
 802d5d4:	869a      	strh	r2, [r3, #52]	; 0x34
  hspi->TxXferCount = Size;
 802d5d6:	68fb      	ldr	r3, [r7, #12]
 802d5d8:	88fa      	ldrh	r2, [r7, #6]
 802d5da:	86da      	strh	r2, [r3, #54]	; 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 802d5dc:	68fb      	ldr	r3, [r7, #12]
 802d5de:	2200      	movs	r2, #0
 802d5e0:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferSize  = 0U;
 802d5e2:	68fb      	ldr	r3, [r7, #12]
 802d5e4:	2200      	movs	r2, #0
 802d5e6:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 802d5e8:	68fb      	ldr	r3, [r7, #12]
 802d5ea:	2200      	movs	r2, #0
 802d5ec:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->TxISR       = NULL;
 802d5ee:	68fb      	ldr	r3, [r7, #12]
 802d5f0:	2200      	movs	r2, #0
 802d5f2:	645a      	str	r2, [r3, #68]	; 0x44
  hspi->RxISR       = NULL;
 802d5f4:	68fb      	ldr	r3, [r7, #12]
 802d5f6:	2200      	movs	r2, #0
 802d5f8:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802d5fa:	68fb      	ldr	r3, [r7, #12]
 802d5fc:	689b      	ldr	r3, [r3, #8]
 802d5fe:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802d602:	d107      	bne.n	802d614 <HAL_SPI_Transmit+0xb0>
  {
    SPI_1LINE_TX(hspi);
 802d604:	68fb      	ldr	r3, [r7, #12]
 802d606:	681b      	ldr	r3, [r3, #0]
 802d608:	681a      	ldr	r2, [r3, #0]
 802d60a:	68fb      	ldr	r3, [r7, #12]
 802d60c:	681b      	ldr	r3, [r3, #0]
 802d60e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 802d612:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802d614:	68fb      	ldr	r3, [r7, #12]
 802d616:	681b      	ldr	r3, [r3, #0]
 802d618:	681b      	ldr	r3, [r3, #0]
 802d61a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802d61e:	2b40      	cmp	r3, #64	; 0x40
 802d620:	d007      	beq.n	802d632 <HAL_SPI_Transmit+0xce>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 802d622:	68fb      	ldr	r3, [r7, #12]
 802d624:	681b      	ldr	r3, [r3, #0]
 802d626:	681a      	ldr	r2, [r3, #0]
 802d628:	68fb      	ldr	r3, [r7, #12]
 802d62a:	681b      	ldr	r3, [r3, #0]
 802d62c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802d630:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 802d632:	68fb      	ldr	r3, [r7, #12]
 802d634:	68db      	ldr	r3, [r3, #12]
 802d636:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 802d63a:	d14b      	bne.n	802d6d4 <HAL_SPI_Transmit+0x170>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802d63c:	68fb      	ldr	r3, [r7, #12]
 802d63e:	685b      	ldr	r3, [r3, #4]
 802d640:	2b00      	cmp	r3, #0
 802d642:	d002      	beq.n	802d64a <HAL_SPI_Transmit+0xe6>
 802d644:	8afb      	ldrh	r3, [r7, #22]
 802d646:	2b01      	cmp	r3, #1
 802d648:	d13e      	bne.n	802d6c8 <HAL_SPI_Transmit+0x164>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802d64a:	68fb      	ldr	r3, [r7, #12]
 802d64c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d64e:	881a      	ldrh	r2, [r3, #0]
 802d650:	68fb      	ldr	r3, [r7, #12]
 802d652:	681b      	ldr	r3, [r3, #0]
 802d654:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 802d656:	68fb      	ldr	r3, [r7, #12]
 802d658:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d65a:	1c9a      	adds	r2, r3, #2
 802d65c:	68fb      	ldr	r3, [r7, #12]
 802d65e:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802d660:	68fb      	ldr	r3, [r7, #12]
 802d662:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d664:	b29b      	uxth	r3, r3
 802d666:	3b01      	subs	r3, #1
 802d668:	b29a      	uxth	r2, r3
 802d66a:	68fb      	ldr	r3, [r7, #12]
 802d66c:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 802d66e:	e02b      	b.n	802d6c8 <HAL_SPI_Transmit+0x164>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 802d670:	68fb      	ldr	r3, [r7, #12]
 802d672:	681b      	ldr	r3, [r3, #0]
 802d674:	689b      	ldr	r3, [r3, #8]
 802d676:	f003 0302 	and.w	r3, r3, #2
 802d67a:	2b02      	cmp	r3, #2
 802d67c:	d112      	bne.n	802d6a4 <HAL_SPI_Transmit+0x140>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802d67e:	68fb      	ldr	r3, [r7, #12]
 802d680:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d682:	881a      	ldrh	r2, [r3, #0]
 802d684:	68fb      	ldr	r3, [r7, #12]
 802d686:	681b      	ldr	r3, [r3, #0]
 802d688:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 802d68a:	68fb      	ldr	r3, [r7, #12]
 802d68c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d68e:	1c9a      	adds	r2, r3, #2
 802d690:	68fb      	ldr	r3, [r7, #12]
 802d692:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802d694:	68fb      	ldr	r3, [r7, #12]
 802d696:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d698:	b29b      	uxth	r3, r3
 802d69a:	3b01      	subs	r3, #1
 802d69c:	b29a      	uxth	r2, r3
 802d69e:	68fb      	ldr	r3, [r7, #12]
 802d6a0:	86da      	strh	r2, [r3, #54]	; 0x36
 802d6a2:	e011      	b.n	802d6c8 <HAL_SPI_Transmit+0x164>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 802d6a4:	f7fe fc14 	bl	802bed0 <HAL_GetTick>
 802d6a8:	4602      	mov	r2, r0
 802d6aa:	69bb      	ldr	r3, [r7, #24]
 802d6ac:	1ad3      	subs	r3, r2, r3
 802d6ae:	683a      	ldr	r2, [r7, #0]
 802d6b0:	429a      	cmp	r2, r3
 802d6b2:	d803      	bhi.n	802d6bc <HAL_SPI_Transmit+0x158>
 802d6b4:	683b      	ldr	r3, [r7, #0]
 802d6b6:	f1b3 3fff 	cmp.w	r3, #4294967295
 802d6ba:	d102      	bne.n	802d6c2 <HAL_SPI_Transmit+0x15e>
 802d6bc:	683b      	ldr	r3, [r7, #0]
 802d6be:	2b00      	cmp	r3, #0
 802d6c0:	d102      	bne.n	802d6c8 <HAL_SPI_Transmit+0x164>
        {
          errorcode = HAL_TIMEOUT;
 802d6c2:	2303      	movs	r3, #3
 802d6c4:	77fb      	strb	r3, [r7, #31]
          goto error;
 802d6c6:	e074      	b.n	802d7b2 <HAL_SPI_Transmit+0x24e>
    while (hspi->TxXferCount > 0U)
 802d6c8:	68fb      	ldr	r3, [r7, #12]
 802d6ca:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d6cc:	b29b      	uxth	r3, r3
 802d6ce:	2b00      	cmp	r3, #0
 802d6d0:	d1ce      	bne.n	802d670 <HAL_SPI_Transmit+0x10c>
 802d6d2:	e04c      	b.n	802d76e <HAL_SPI_Transmit+0x20a>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802d6d4:	68fb      	ldr	r3, [r7, #12]
 802d6d6:	685b      	ldr	r3, [r3, #4]
 802d6d8:	2b00      	cmp	r3, #0
 802d6da:	d002      	beq.n	802d6e2 <HAL_SPI_Transmit+0x17e>
 802d6dc:	8afb      	ldrh	r3, [r7, #22]
 802d6de:	2b01      	cmp	r3, #1
 802d6e0:	d140      	bne.n	802d764 <HAL_SPI_Transmit+0x200>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 802d6e2:	68fb      	ldr	r3, [r7, #12]
 802d6e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802d6e6:	68fb      	ldr	r3, [r7, #12]
 802d6e8:	681b      	ldr	r3, [r3, #0]
 802d6ea:	330c      	adds	r3, #12
 802d6ec:	7812      	ldrb	r2, [r2, #0]
 802d6ee:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 802d6f0:	68fb      	ldr	r3, [r7, #12]
 802d6f2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d6f4:	1c5a      	adds	r2, r3, #1
 802d6f6:	68fb      	ldr	r3, [r7, #12]
 802d6f8:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802d6fa:	68fb      	ldr	r3, [r7, #12]
 802d6fc:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d6fe:	b29b      	uxth	r3, r3
 802d700:	3b01      	subs	r3, #1
 802d702:	b29a      	uxth	r2, r3
 802d704:	68fb      	ldr	r3, [r7, #12]
 802d706:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while (hspi->TxXferCount > 0U)
 802d708:	e02c      	b.n	802d764 <HAL_SPI_Transmit+0x200>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 802d70a:	68fb      	ldr	r3, [r7, #12]
 802d70c:	681b      	ldr	r3, [r3, #0]
 802d70e:	689b      	ldr	r3, [r3, #8]
 802d710:	f003 0302 	and.w	r3, r3, #2
 802d714:	2b02      	cmp	r3, #2
 802d716:	d113      	bne.n	802d740 <HAL_SPI_Transmit+0x1dc>
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 802d718:	68fb      	ldr	r3, [r7, #12]
 802d71a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802d71c:	68fb      	ldr	r3, [r7, #12]
 802d71e:	681b      	ldr	r3, [r3, #0]
 802d720:	330c      	adds	r3, #12
 802d722:	7812      	ldrb	r2, [r2, #0]
 802d724:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 802d726:	68fb      	ldr	r3, [r7, #12]
 802d728:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d72a:	1c5a      	adds	r2, r3, #1
 802d72c:	68fb      	ldr	r3, [r7, #12]
 802d72e:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802d730:	68fb      	ldr	r3, [r7, #12]
 802d732:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d734:	b29b      	uxth	r3, r3
 802d736:	3b01      	subs	r3, #1
 802d738:	b29a      	uxth	r2, r3
 802d73a:	68fb      	ldr	r3, [r7, #12]
 802d73c:	86da      	strh	r2, [r3, #54]	; 0x36
 802d73e:	e011      	b.n	802d764 <HAL_SPI_Transmit+0x200>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 802d740:	f7fe fbc6 	bl	802bed0 <HAL_GetTick>
 802d744:	4602      	mov	r2, r0
 802d746:	69bb      	ldr	r3, [r7, #24]
 802d748:	1ad3      	subs	r3, r2, r3
 802d74a:	683a      	ldr	r2, [r7, #0]
 802d74c:	429a      	cmp	r2, r3
 802d74e:	d803      	bhi.n	802d758 <HAL_SPI_Transmit+0x1f4>
 802d750:	683b      	ldr	r3, [r7, #0]
 802d752:	f1b3 3fff 	cmp.w	r3, #4294967295
 802d756:	d102      	bne.n	802d75e <HAL_SPI_Transmit+0x1fa>
 802d758:	683b      	ldr	r3, [r7, #0]
 802d75a:	2b00      	cmp	r3, #0
 802d75c:	d102      	bne.n	802d764 <HAL_SPI_Transmit+0x200>
        {
          errorcode = HAL_TIMEOUT;
 802d75e:	2303      	movs	r3, #3
 802d760:	77fb      	strb	r3, [r7, #31]
          goto error;
 802d762:	e026      	b.n	802d7b2 <HAL_SPI_Transmit+0x24e>
    while (hspi->TxXferCount > 0U)
 802d764:	68fb      	ldr	r3, [r7, #12]
 802d766:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d768:	b29b      	uxth	r3, r3
 802d76a:	2b00      	cmp	r3, #0
 802d76c:	d1cd      	bne.n	802d70a <HAL_SPI_Transmit+0x1a6>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 802d76e:	69ba      	ldr	r2, [r7, #24]
 802d770:	6839      	ldr	r1, [r7, #0]
 802d772:	68f8      	ldr	r0, [r7, #12]
 802d774:	f000 fcd0 	bl	802e118 <SPI_EndRxTxTransaction>
 802d778:	4603      	mov	r3, r0
 802d77a:	2b00      	cmp	r3, #0
 802d77c:	d002      	beq.n	802d784 <HAL_SPI_Transmit+0x220>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 802d77e:	68fb      	ldr	r3, [r7, #12]
 802d780:	2220      	movs	r2, #32
 802d782:	655a      	str	r2, [r3, #84]	; 0x54
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 802d784:	68fb      	ldr	r3, [r7, #12]
 802d786:	689b      	ldr	r3, [r3, #8]
 802d788:	2b00      	cmp	r3, #0
 802d78a:	d10a      	bne.n	802d7a2 <HAL_SPI_Transmit+0x23e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 802d78c:	2300      	movs	r3, #0
 802d78e:	613b      	str	r3, [r7, #16]
 802d790:	68fb      	ldr	r3, [r7, #12]
 802d792:	681b      	ldr	r3, [r3, #0]
 802d794:	68db      	ldr	r3, [r3, #12]
 802d796:	613b      	str	r3, [r7, #16]
 802d798:	68fb      	ldr	r3, [r7, #12]
 802d79a:	681b      	ldr	r3, [r3, #0]
 802d79c:	689b      	ldr	r3, [r3, #8]
 802d79e:	613b      	str	r3, [r7, #16]
 802d7a0:	693b      	ldr	r3, [r7, #16]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 802d7a2:	68fb      	ldr	r3, [r7, #12]
 802d7a4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d7a6:	2b00      	cmp	r3, #0
 802d7a8:	d002      	beq.n	802d7b0 <HAL_SPI_Transmit+0x24c>
  {
    errorcode = HAL_ERROR;
 802d7aa:	2301      	movs	r3, #1
 802d7ac:	77fb      	strb	r3, [r7, #31]
 802d7ae:	e000      	b.n	802d7b2 <HAL_SPI_Transmit+0x24e>
  }

error:
 802d7b0:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 802d7b2:	68fb      	ldr	r3, [r7, #12]
 802d7b4:	2201      	movs	r2, #1
 802d7b6:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802d7ba:	68fb      	ldr	r3, [r7, #12]
 802d7bc:	2200      	movs	r2, #0
 802d7be:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  return errorcode;
 802d7c2:	7ffb      	ldrb	r3, [r7, #31]
}
 802d7c4:	4618      	mov	r0, r3
 802d7c6:	3720      	adds	r7, #32
 802d7c8:	46bd      	mov	sp, r7
 802d7ca:	bd80      	pop	{r7, pc}

0802d7cc <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 802d7cc:	b580      	push	{r7, lr}
 802d7ce:	b08c      	sub	sp, #48	; 0x30
 802d7d0:	af00      	add	r7, sp, #0
 802d7d2:	60f8      	str	r0, [r7, #12]
 802d7d4:	60b9      	str	r1, [r7, #8]
 802d7d6:	607a      	str	r2, [r7, #4]
 802d7d8:	807b      	strh	r3, [r7, #2]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  uint32_t             tickstart;

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 802d7da:	2301      	movs	r3, #1
 802d7dc:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef    errorcode = HAL_OK;
 802d7de:	2300      	movs	r3, #0
 802d7e0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 802d7e4:	68fb      	ldr	r3, [r7, #12]
 802d7e6:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802d7ea:	2b01      	cmp	r3, #1
 802d7ec:	d101      	bne.n	802d7f2 <HAL_SPI_TransmitReceive+0x26>
 802d7ee:	2302      	movs	r3, #2
 802d7f0:	e18a      	b.n	802db08 <HAL_SPI_TransmitReceive+0x33c>
 802d7f2:	68fb      	ldr	r3, [r7, #12]
 802d7f4:	2201      	movs	r2, #1
 802d7f6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802d7fa:	f7fe fb69 	bl	802bed0 <HAL_GetTick>
 802d7fe:	6278      	str	r0, [r7, #36]	; 0x24

  /* Init temporary variables */
  tmp_state           = hspi->State;
 802d800:	68fb      	ldr	r3, [r7, #12]
 802d802:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802d806:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  tmp_mode            = hspi->Init.Mode;
 802d80a:	68fb      	ldr	r3, [r7, #12]
 802d80c:	685b      	ldr	r3, [r3, #4]
 802d80e:	61fb      	str	r3, [r7, #28]
  initial_TxXferCount = Size;
 802d810:	887b      	ldrh	r3, [r7, #2]
 802d812:	837b      	strh	r3, [r7, #26]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 802d814:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802d818:	2b01      	cmp	r3, #1
 802d81a:	d00f      	beq.n	802d83c <HAL_SPI_TransmitReceive+0x70>
 802d81c:	69fb      	ldr	r3, [r7, #28]
 802d81e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802d822:	d107      	bne.n	802d834 <HAL_SPI_TransmitReceive+0x68>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 802d824:	68fb      	ldr	r3, [r7, #12]
 802d826:	689b      	ldr	r3, [r3, #8]
 802d828:	2b00      	cmp	r3, #0
 802d82a:	d103      	bne.n	802d834 <HAL_SPI_TransmitReceive+0x68>
 802d82c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802d830:	2b04      	cmp	r3, #4
 802d832:	d003      	beq.n	802d83c <HAL_SPI_TransmitReceive+0x70>
  {
    errorcode = HAL_BUSY;
 802d834:	2302      	movs	r3, #2
 802d836:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    goto error;
 802d83a:	e15b      	b.n	802daf4 <HAL_SPI_TransmitReceive+0x328>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 802d83c:	68bb      	ldr	r3, [r7, #8]
 802d83e:	2b00      	cmp	r3, #0
 802d840:	d005      	beq.n	802d84e <HAL_SPI_TransmitReceive+0x82>
 802d842:	687b      	ldr	r3, [r7, #4]
 802d844:	2b00      	cmp	r3, #0
 802d846:	d002      	beq.n	802d84e <HAL_SPI_TransmitReceive+0x82>
 802d848:	887b      	ldrh	r3, [r7, #2]
 802d84a:	2b00      	cmp	r3, #0
 802d84c:	d103      	bne.n	802d856 <HAL_SPI_TransmitReceive+0x8a>
  {
    errorcode = HAL_ERROR;
 802d84e:	2301      	movs	r3, #1
 802d850:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    goto error;
 802d854:	e14e      	b.n	802daf4 <HAL_SPI_TransmitReceive+0x328>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 802d856:	68fb      	ldr	r3, [r7, #12]
 802d858:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802d85c:	b2db      	uxtb	r3, r3
 802d85e:	2b04      	cmp	r3, #4
 802d860:	d003      	beq.n	802d86a <HAL_SPI_TransmitReceive+0x9e>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 802d862:	68fb      	ldr	r3, [r7, #12]
 802d864:	2205      	movs	r2, #5
 802d866:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802d86a:	68fb      	ldr	r3, [r7, #12]
 802d86c:	2200      	movs	r2, #0
 802d86e:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 802d870:	68fb      	ldr	r3, [r7, #12]
 802d872:	687a      	ldr	r2, [r7, #4]
 802d874:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferCount = Size;
 802d876:	68fb      	ldr	r3, [r7, #12]
 802d878:	887a      	ldrh	r2, [r7, #2]
 802d87a:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 802d87c:	68fb      	ldr	r3, [r7, #12]
 802d87e:	887a      	ldrh	r2, [r7, #2]
 802d880:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 802d882:	68fb      	ldr	r3, [r7, #12]
 802d884:	68ba      	ldr	r2, [r7, #8]
 802d886:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferCount = Size;
 802d888:	68fb      	ldr	r3, [r7, #12]
 802d88a:	887a      	ldrh	r2, [r7, #2]
 802d88c:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->TxXferSize  = Size;
 802d88e:	68fb      	ldr	r3, [r7, #12]
 802d890:	887a      	ldrh	r2, [r7, #2]
 802d892:	869a      	strh	r2, [r3, #52]	; 0x34

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 802d894:	68fb      	ldr	r3, [r7, #12]
 802d896:	2200      	movs	r2, #0
 802d898:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 802d89a:	68fb      	ldr	r3, [r7, #12]
 802d89c:	2200      	movs	r2, #0
 802d89e:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802d8a0:	68fb      	ldr	r3, [r7, #12]
 802d8a2:	681b      	ldr	r3, [r3, #0]
 802d8a4:	681b      	ldr	r3, [r3, #0]
 802d8a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802d8aa:	2b40      	cmp	r3, #64	; 0x40
 802d8ac:	d007      	beq.n	802d8be <HAL_SPI_TransmitReceive+0xf2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 802d8ae:	68fb      	ldr	r3, [r7, #12]
 802d8b0:	681b      	ldr	r3, [r3, #0]
 802d8b2:	681a      	ldr	r2, [r3, #0]
 802d8b4:	68fb      	ldr	r3, [r7, #12]
 802d8b6:	681b      	ldr	r3, [r3, #0]
 802d8b8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802d8bc:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 802d8be:	68fb      	ldr	r3, [r7, #12]
 802d8c0:	68db      	ldr	r3, [r3, #12]
 802d8c2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 802d8c6:	d178      	bne.n	802d9ba <HAL_SPI_TransmitReceive+0x1ee>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802d8c8:	68fb      	ldr	r3, [r7, #12]
 802d8ca:	685b      	ldr	r3, [r3, #4]
 802d8cc:	2b00      	cmp	r3, #0
 802d8ce:	d002      	beq.n	802d8d6 <HAL_SPI_TransmitReceive+0x10a>
 802d8d0:	8b7b      	ldrh	r3, [r7, #26]
 802d8d2:	2b01      	cmp	r3, #1
 802d8d4:	d166      	bne.n	802d9a4 <HAL_SPI_TransmitReceive+0x1d8>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802d8d6:	68fb      	ldr	r3, [r7, #12]
 802d8d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d8da:	881a      	ldrh	r2, [r3, #0]
 802d8dc:	68fb      	ldr	r3, [r7, #12]
 802d8de:	681b      	ldr	r3, [r3, #0]
 802d8e0:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 802d8e2:	68fb      	ldr	r3, [r7, #12]
 802d8e4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d8e6:	1c9a      	adds	r2, r3, #2
 802d8e8:	68fb      	ldr	r3, [r7, #12]
 802d8ea:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802d8ec:	68fb      	ldr	r3, [r7, #12]
 802d8ee:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d8f0:	b29b      	uxth	r3, r3
 802d8f2:	3b01      	subs	r3, #1
 802d8f4:	b29a      	uxth	r2, r3
 802d8f6:	68fb      	ldr	r3, [r7, #12]
 802d8f8:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802d8fa:	e053      	b.n	802d9a4 <HAL_SPI_TransmitReceive+0x1d8>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 802d8fc:	68fb      	ldr	r3, [r7, #12]
 802d8fe:	681b      	ldr	r3, [r3, #0]
 802d900:	689b      	ldr	r3, [r3, #8]
 802d902:	f003 0302 	and.w	r3, r3, #2
 802d906:	2b02      	cmp	r3, #2
 802d908:	d11b      	bne.n	802d942 <HAL_SPI_TransmitReceive+0x176>
 802d90a:	68fb      	ldr	r3, [r7, #12]
 802d90c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d90e:	b29b      	uxth	r3, r3
 802d910:	2b00      	cmp	r3, #0
 802d912:	d016      	beq.n	802d942 <HAL_SPI_TransmitReceive+0x176>
 802d914:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802d916:	2b01      	cmp	r3, #1
 802d918:	d113      	bne.n	802d942 <HAL_SPI_TransmitReceive+0x176>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802d91a:	68fb      	ldr	r3, [r7, #12]
 802d91c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d91e:	881a      	ldrh	r2, [r3, #0]
 802d920:	68fb      	ldr	r3, [r7, #12]
 802d922:	681b      	ldr	r3, [r3, #0]
 802d924:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 802d926:	68fb      	ldr	r3, [r7, #12]
 802d928:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d92a:	1c9a      	adds	r2, r3, #2
 802d92c:	68fb      	ldr	r3, [r7, #12]
 802d92e:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802d930:	68fb      	ldr	r3, [r7, #12]
 802d932:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d934:	b29b      	uxth	r3, r3
 802d936:	3b01      	subs	r3, #1
 802d938:	b29a      	uxth	r2, r3
 802d93a:	68fb      	ldr	r3, [r7, #12]
 802d93c:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 802d93e:	2300      	movs	r3, #0
 802d940:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 802d942:	68fb      	ldr	r3, [r7, #12]
 802d944:	681b      	ldr	r3, [r3, #0]
 802d946:	689b      	ldr	r3, [r3, #8]
 802d948:	f003 0301 	and.w	r3, r3, #1
 802d94c:	2b01      	cmp	r3, #1
 802d94e:	d119      	bne.n	802d984 <HAL_SPI_TransmitReceive+0x1b8>
 802d950:	68fb      	ldr	r3, [r7, #12]
 802d952:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802d954:	b29b      	uxth	r3, r3
 802d956:	2b00      	cmp	r3, #0
 802d958:	d014      	beq.n	802d984 <HAL_SPI_TransmitReceive+0x1b8>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 802d95a:	68fb      	ldr	r3, [r7, #12]
 802d95c:	681b      	ldr	r3, [r3, #0]
 802d95e:	68da      	ldr	r2, [r3, #12]
 802d960:	68fb      	ldr	r3, [r7, #12]
 802d962:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d964:	b292      	uxth	r2, r2
 802d966:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 802d968:	68fb      	ldr	r3, [r7, #12]
 802d96a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d96c:	1c9a      	adds	r2, r3, #2
 802d96e:	68fb      	ldr	r3, [r7, #12]
 802d970:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 802d972:	68fb      	ldr	r3, [r7, #12]
 802d974:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802d976:	b29b      	uxth	r3, r3
 802d978:	3b01      	subs	r3, #1
 802d97a:	b29a      	uxth	r2, r3
 802d97c:	68fb      	ldr	r3, [r7, #12]
 802d97e:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 802d980:	2301      	movs	r3, #1
 802d982:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 802d984:	f7fe faa4 	bl	802bed0 <HAL_GetTick>
 802d988:	4602      	mov	r2, r0
 802d98a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802d98c:	1ad3      	subs	r3, r2, r3
 802d98e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802d990:	429a      	cmp	r2, r3
 802d992:	d807      	bhi.n	802d9a4 <HAL_SPI_TransmitReceive+0x1d8>
 802d994:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802d996:	f1b3 3fff 	cmp.w	r3, #4294967295
 802d99a:	d003      	beq.n	802d9a4 <HAL_SPI_TransmitReceive+0x1d8>
      {
        errorcode = HAL_TIMEOUT;
 802d99c:	2303      	movs	r3, #3
 802d99e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        goto error;
 802d9a2:	e0a7      	b.n	802daf4 <HAL_SPI_TransmitReceive+0x328>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802d9a4:	68fb      	ldr	r3, [r7, #12]
 802d9a6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d9a8:	b29b      	uxth	r3, r3
 802d9aa:	2b00      	cmp	r3, #0
 802d9ac:	d1a6      	bne.n	802d8fc <HAL_SPI_TransmitReceive+0x130>
 802d9ae:	68fb      	ldr	r3, [r7, #12]
 802d9b0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802d9b2:	b29b      	uxth	r3, r3
 802d9b4:	2b00      	cmp	r3, #0
 802d9b6:	d1a1      	bne.n	802d8fc <HAL_SPI_TransmitReceive+0x130>
 802d9b8:	e07c      	b.n	802dab4 <HAL_SPI_TransmitReceive+0x2e8>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802d9ba:	68fb      	ldr	r3, [r7, #12]
 802d9bc:	685b      	ldr	r3, [r3, #4]
 802d9be:	2b00      	cmp	r3, #0
 802d9c0:	d002      	beq.n	802d9c8 <HAL_SPI_TransmitReceive+0x1fc>
 802d9c2:	8b7b      	ldrh	r3, [r7, #26]
 802d9c4:	2b01      	cmp	r3, #1
 802d9c6:	d16b      	bne.n	802daa0 <HAL_SPI_TransmitReceive+0x2d4>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 802d9c8:	68fb      	ldr	r3, [r7, #12]
 802d9ca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802d9cc:	68fb      	ldr	r3, [r7, #12]
 802d9ce:	681b      	ldr	r3, [r3, #0]
 802d9d0:	330c      	adds	r3, #12
 802d9d2:	7812      	ldrb	r2, [r2, #0]
 802d9d4:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 802d9d6:	68fb      	ldr	r3, [r7, #12]
 802d9d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802d9da:	1c5a      	adds	r2, r3, #1
 802d9dc:	68fb      	ldr	r3, [r7, #12]
 802d9de:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802d9e0:	68fb      	ldr	r3, [r7, #12]
 802d9e2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802d9e4:	b29b      	uxth	r3, r3
 802d9e6:	3b01      	subs	r3, #1
 802d9e8:	b29a      	uxth	r2, r3
 802d9ea:	68fb      	ldr	r3, [r7, #12]
 802d9ec:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802d9ee:	e057      	b.n	802daa0 <HAL_SPI_TransmitReceive+0x2d4>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 802d9f0:	68fb      	ldr	r3, [r7, #12]
 802d9f2:	681b      	ldr	r3, [r3, #0]
 802d9f4:	689b      	ldr	r3, [r3, #8]
 802d9f6:	f003 0302 	and.w	r3, r3, #2
 802d9fa:	2b02      	cmp	r3, #2
 802d9fc:	d11c      	bne.n	802da38 <HAL_SPI_TransmitReceive+0x26c>
 802d9fe:	68fb      	ldr	r3, [r7, #12]
 802da00:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802da02:	b29b      	uxth	r3, r3
 802da04:	2b00      	cmp	r3, #0
 802da06:	d017      	beq.n	802da38 <HAL_SPI_TransmitReceive+0x26c>
 802da08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802da0a:	2b01      	cmp	r3, #1
 802da0c:	d114      	bne.n	802da38 <HAL_SPI_TransmitReceive+0x26c>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 802da0e:	68fb      	ldr	r3, [r7, #12]
 802da10:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802da12:	68fb      	ldr	r3, [r7, #12]
 802da14:	681b      	ldr	r3, [r3, #0]
 802da16:	330c      	adds	r3, #12
 802da18:	7812      	ldrb	r2, [r2, #0]
 802da1a:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 802da1c:	68fb      	ldr	r3, [r7, #12]
 802da1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802da20:	1c5a      	adds	r2, r3, #1
 802da22:	68fb      	ldr	r3, [r7, #12]
 802da24:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802da26:	68fb      	ldr	r3, [r7, #12]
 802da28:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802da2a:	b29b      	uxth	r3, r3
 802da2c:	3b01      	subs	r3, #1
 802da2e:	b29a      	uxth	r2, r3
 802da30:	68fb      	ldr	r3, [r7, #12]
 802da32:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 802da34:	2300      	movs	r3, #0
 802da36:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 802da38:	68fb      	ldr	r3, [r7, #12]
 802da3a:	681b      	ldr	r3, [r3, #0]
 802da3c:	689b      	ldr	r3, [r3, #8]
 802da3e:	f003 0301 	and.w	r3, r3, #1
 802da42:	2b01      	cmp	r3, #1
 802da44:	d119      	bne.n	802da7a <HAL_SPI_TransmitReceive+0x2ae>
 802da46:	68fb      	ldr	r3, [r7, #12]
 802da48:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802da4a:	b29b      	uxth	r3, r3
 802da4c:	2b00      	cmp	r3, #0
 802da4e:	d014      	beq.n	802da7a <HAL_SPI_TransmitReceive+0x2ae>
      {
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 802da50:	68fb      	ldr	r3, [r7, #12]
 802da52:	681b      	ldr	r3, [r3, #0]
 802da54:	68da      	ldr	r2, [r3, #12]
 802da56:	68fb      	ldr	r3, [r7, #12]
 802da58:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802da5a:	b2d2      	uxtb	r2, r2
 802da5c:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 802da5e:	68fb      	ldr	r3, [r7, #12]
 802da60:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802da62:	1c5a      	adds	r2, r3, #1
 802da64:	68fb      	ldr	r3, [r7, #12]
 802da66:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 802da68:	68fb      	ldr	r3, [r7, #12]
 802da6a:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802da6c:	b29b      	uxth	r3, r3
 802da6e:	3b01      	subs	r3, #1
 802da70:	b29a      	uxth	r2, r3
 802da72:	68fb      	ldr	r3, [r7, #12]
 802da74:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 802da76:	2301      	movs	r3, #1
 802da78:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 802da7a:	f7fe fa29 	bl	802bed0 <HAL_GetTick>
 802da7e:	4602      	mov	r2, r0
 802da80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802da82:	1ad3      	subs	r3, r2, r3
 802da84:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802da86:	429a      	cmp	r2, r3
 802da88:	d803      	bhi.n	802da92 <HAL_SPI_TransmitReceive+0x2c6>
 802da8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802da8c:	f1b3 3fff 	cmp.w	r3, #4294967295
 802da90:	d102      	bne.n	802da98 <HAL_SPI_TransmitReceive+0x2cc>
 802da92:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802da94:	2b00      	cmp	r3, #0
 802da96:	d103      	bne.n	802daa0 <HAL_SPI_TransmitReceive+0x2d4>
      {
        errorcode = HAL_TIMEOUT;
 802da98:	2303      	movs	r3, #3
 802da9a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        goto error;
 802da9e:	e029      	b.n	802daf4 <HAL_SPI_TransmitReceive+0x328>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802daa0:	68fb      	ldr	r3, [r7, #12]
 802daa2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802daa4:	b29b      	uxth	r3, r3
 802daa6:	2b00      	cmp	r3, #0
 802daa8:	d1a2      	bne.n	802d9f0 <HAL_SPI_TransmitReceive+0x224>
 802daaa:	68fb      	ldr	r3, [r7, #12]
 802daac:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802daae:	b29b      	uxth	r3, r3
 802dab0:	2b00      	cmp	r3, #0
 802dab2:	d19d      	bne.n	802d9f0 <HAL_SPI_TransmitReceive+0x224>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 802dab4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802dab6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 802dab8:	68f8      	ldr	r0, [r7, #12]
 802daba:	f000 fb2d 	bl	802e118 <SPI_EndRxTxTransaction>
 802dabe:	4603      	mov	r3, r0
 802dac0:	2b00      	cmp	r3, #0
 802dac2:	d006      	beq.n	802dad2 <HAL_SPI_TransmitReceive+0x306>
  {
    errorcode = HAL_ERROR;
 802dac4:	2301      	movs	r3, #1
 802dac6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 802daca:	68fb      	ldr	r3, [r7, #12]
 802dacc:	2220      	movs	r2, #32
 802dace:	655a      	str	r2, [r3, #84]	; 0x54
    goto error;
 802dad0:	e010      	b.n	802daf4 <HAL_SPI_TransmitReceive+0x328>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 802dad2:	68fb      	ldr	r3, [r7, #12]
 802dad4:	689b      	ldr	r3, [r3, #8]
 802dad6:	2b00      	cmp	r3, #0
 802dad8:	d10b      	bne.n	802daf2 <HAL_SPI_TransmitReceive+0x326>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 802dada:	2300      	movs	r3, #0
 802dadc:	617b      	str	r3, [r7, #20]
 802dade:	68fb      	ldr	r3, [r7, #12]
 802dae0:	681b      	ldr	r3, [r3, #0]
 802dae2:	68db      	ldr	r3, [r3, #12]
 802dae4:	617b      	str	r3, [r7, #20]
 802dae6:	68fb      	ldr	r3, [r7, #12]
 802dae8:	681b      	ldr	r3, [r3, #0]
 802daea:	689b      	ldr	r3, [r3, #8]
 802daec:	617b      	str	r3, [r7, #20]
 802daee:	697b      	ldr	r3, [r7, #20]
 802daf0:	e000      	b.n	802daf4 <HAL_SPI_TransmitReceive+0x328>
  }

error :
 802daf2:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 802daf4:	68fb      	ldr	r3, [r7, #12]
 802daf6:	2201      	movs	r2, #1
 802daf8:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 802dafc:	68fb      	ldr	r3, [r7, #12]
 802dafe:	2200      	movs	r2, #0
 802db00:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  return errorcode;
 802db04:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
}
 802db08:	4618      	mov	r0, r3
 802db0a:	3730      	adds	r7, #48	; 0x30
 802db0c:	46bd      	mov	sp, r7
 802db0e:	bd80      	pop	{r7, pc}

0802db10 <HAL_SPI_TransmitReceive_DMA>:
  * @param  Size amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
                                              uint16_t Size)
{
 802db10:	b580      	push	{r7, lr}
 802db12:	b086      	sub	sp, #24
 802db14:	af00      	add	r7, sp, #0
 802db16:	60f8      	str	r0, [r7, #12]
 802db18:	60b9      	str	r1, [r7, #8]
 802db1a:	607a      	str	r2, [r7, #4]
 802db1c:	807b      	strh	r3, [r7, #2]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  HAL_StatusTypeDef errorcode = HAL_OK;
 802db1e:	2300      	movs	r3, #0
 802db20:	75fb      	strb	r3, [r7, #23]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 802db22:	68fb      	ldr	r3, [r7, #12]
 802db24:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802db28:	2b01      	cmp	r3, #1
 802db2a:	d101      	bne.n	802db30 <HAL_SPI_TransmitReceive_DMA+0x20>
 802db2c:	2302      	movs	r3, #2
 802db2e:	e0e3      	b.n	802dcf8 <HAL_SPI_TransmitReceive_DMA+0x1e8>
 802db30:	68fb      	ldr	r3, [r7, #12]
 802db32:	2201      	movs	r2, #1
 802db34:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Init temporary variables */
  tmp_state           = hspi->State;
 802db38:	68fb      	ldr	r3, [r7, #12]
 802db3a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802db3e:	75bb      	strb	r3, [r7, #22]
  tmp_mode            = hspi->Init.Mode;
 802db40:	68fb      	ldr	r3, [r7, #12]
 802db42:	685b      	ldr	r3, [r3, #4]
 802db44:	613b      	str	r3, [r7, #16]

  if (!((tmp_state == HAL_SPI_STATE_READY) ||
 802db46:	7dbb      	ldrb	r3, [r7, #22]
 802db48:	2b01      	cmp	r3, #1
 802db4a:	d00d      	beq.n	802db68 <HAL_SPI_TransmitReceive_DMA+0x58>
 802db4c:	693b      	ldr	r3, [r7, #16]
 802db4e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802db52:	d106      	bne.n	802db62 <HAL_SPI_TransmitReceive_DMA+0x52>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 802db54:	68fb      	ldr	r3, [r7, #12]
 802db56:	689b      	ldr	r3, [r3, #8]
 802db58:	2b00      	cmp	r3, #0
 802db5a:	d102      	bne.n	802db62 <HAL_SPI_TransmitReceive_DMA+0x52>
 802db5c:	7dbb      	ldrb	r3, [r7, #22]
 802db5e:	2b04      	cmp	r3, #4
 802db60:	d002      	beq.n	802db68 <HAL_SPI_TransmitReceive_DMA+0x58>
  {
    errorcode = HAL_BUSY;
 802db62:	2302      	movs	r3, #2
 802db64:	75fb      	strb	r3, [r7, #23]
    goto error;
 802db66:	e0c2      	b.n	802dcee <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 802db68:	68bb      	ldr	r3, [r7, #8]
 802db6a:	2b00      	cmp	r3, #0
 802db6c:	d005      	beq.n	802db7a <HAL_SPI_TransmitReceive_DMA+0x6a>
 802db6e:	687b      	ldr	r3, [r7, #4]
 802db70:	2b00      	cmp	r3, #0
 802db72:	d002      	beq.n	802db7a <HAL_SPI_TransmitReceive_DMA+0x6a>
 802db74:	887b      	ldrh	r3, [r7, #2]
 802db76:	2b00      	cmp	r3, #0
 802db78:	d102      	bne.n	802db80 <HAL_SPI_TransmitReceive_DMA+0x70>
  {
    errorcode = HAL_ERROR;
 802db7a:	2301      	movs	r3, #1
 802db7c:	75fb      	strb	r3, [r7, #23]
    goto error;
 802db7e:	e0b6      	b.n	802dcee <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 802db80:	68fb      	ldr	r3, [r7, #12]
 802db82:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802db86:	b2db      	uxtb	r3, r3
 802db88:	2b04      	cmp	r3, #4
 802db8a:	d003      	beq.n	802db94 <HAL_SPI_TransmitReceive_DMA+0x84>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 802db8c:	68fb      	ldr	r3, [r7, #12]
 802db8e:	2205      	movs	r2, #5
 802db90:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802db94:	68fb      	ldr	r3, [r7, #12]
 802db96:	2200      	movs	r2, #0
 802db98:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 802db9a:	68fb      	ldr	r3, [r7, #12]
 802db9c:	68ba      	ldr	r2, [r7, #8]
 802db9e:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferSize  = Size;
 802dba0:	68fb      	ldr	r3, [r7, #12]
 802dba2:	887a      	ldrh	r2, [r7, #2]
 802dba4:	869a      	strh	r2, [r3, #52]	; 0x34
  hspi->TxXferCount = Size;
 802dba6:	68fb      	ldr	r3, [r7, #12]
 802dba8:	887a      	ldrh	r2, [r7, #2]
 802dbaa:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 802dbac:	68fb      	ldr	r3, [r7, #12]
 802dbae:	687a      	ldr	r2, [r7, #4]
 802dbb0:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferSize  = Size;
 802dbb2:	68fb      	ldr	r3, [r7, #12]
 802dbb4:	887a      	ldrh	r2, [r7, #2]
 802dbb6:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->RxXferCount = Size;
 802dbb8:	68fb      	ldr	r3, [r7, #12]
 802dbba:	887a      	ldrh	r2, [r7, #2]
 802dbbc:	87da      	strh	r2, [r3, #62]	; 0x3e

  /* Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 802dbbe:	68fb      	ldr	r3, [r7, #12]
 802dbc0:	2200      	movs	r2, #0
 802dbc2:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 802dbc4:	68fb      	ldr	r3, [r7, #12]
 802dbc6:	2200      	movs	r2, #0
 802dbc8:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 802dbca:	68fb      	ldr	r3, [r7, #12]
 802dbcc:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802dbd0:	b2db      	uxtb	r3, r3
 802dbd2:	2b04      	cmp	r3, #4
 802dbd4:	d108      	bne.n	802dbe8 <HAL_SPI_TransmitReceive_DMA+0xd8>
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 802dbd6:	68fb      	ldr	r3, [r7, #12]
 802dbd8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802dbda:	4a49      	ldr	r2, [pc, #292]	; (802dd00 <HAL_SPI_TransmitReceive_DMA+0x1f0>)
 802dbdc:	641a      	str	r2, [r3, #64]	; 0x40
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 802dbde:	68fb      	ldr	r3, [r7, #12]
 802dbe0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802dbe2:	4a48      	ldr	r2, [pc, #288]	; (802dd04 <HAL_SPI_TransmitReceive_DMA+0x1f4>)
 802dbe4:	63da      	str	r2, [r3, #60]	; 0x3c
 802dbe6:	e007      	b.n	802dbf8 <HAL_SPI_TransmitReceive_DMA+0xe8>
  }
  else
  {
    /* Set the SPI Tx/Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 802dbe8:	68fb      	ldr	r3, [r7, #12]
 802dbea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802dbec:	4a46      	ldr	r2, [pc, #280]	; (802dd08 <HAL_SPI_TransmitReceive_DMA+0x1f8>)
 802dbee:	641a      	str	r2, [r3, #64]	; 0x40
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 802dbf0:	68fb      	ldr	r3, [r7, #12]
 802dbf2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802dbf4:	4a45      	ldr	r2, [pc, #276]	; (802dd0c <HAL_SPI_TransmitReceive_DMA+0x1fc>)
 802dbf6:	63da      	str	r2, [r3, #60]	; 0x3c
  }

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 802dbf8:	68fb      	ldr	r3, [r7, #12]
 802dbfa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802dbfc:	4a44      	ldr	r2, [pc, #272]	; (802dd10 <HAL_SPI_TransmitReceive_DMA+0x200>)
 802dbfe:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set the DMA AbortCpltCallback */
  hspi->hdmarx->XferAbortCallback = NULL;
 802dc00:	68fb      	ldr	r3, [r7, #12]
 802dc02:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802dc04:	2200      	movs	r2, #0
 802dc06:	651a      	str	r2, [r3, #80]	; 0x50

  /* Enable the Rx DMA Stream/Channel  */
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 802dc08:	68fb      	ldr	r3, [r7, #12]
 802dc0a:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 802dc0c:	68fb      	ldr	r3, [r7, #12]
 802dc0e:	681b      	ldr	r3, [r3, #0]
 802dc10:	330c      	adds	r3, #12
 802dc12:	4619      	mov	r1, r3
 802dc14:	68fb      	ldr	r3, [r7, #12]
 802dc16:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802dc18:	461a      	mov	r2, r3
                                 hspi->RxXferCount))
 802dc1a:	68fb      	ldr	r3, [r7, #12]
 802dc1c:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802dc1e:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 802dc20:	f7fe fb44 	bl	802c2ac <HAL_DMA_Start_IT>
 802dc24:	4603      	mov	r3, r0
 802dc26:	2b00      	cmp	r3, #0
 802dc28:	d00c      	beq.n	802dc44 <HAL_SPI_TransmitReceive_DMA+0x134>
  {
    /* Update SPI error code */
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 802dc2a:	68fb      	ldr	r3, [r7, #12]
 802dc2c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802dc2e:	f043 0210 	orr.w	r2, r3, #16
 802dc32:	68fb      	ldr	r3, [r7, #12]
 802dc34:	655a      	str	r2, [r3, #84]	; 0x54
    errorcode = HAL_ERROR;
 802dc36:	2301      	movs	r3, #1
 802dc38:	75fb      	strb	r3, [r7, #23]

    hspi->State = HAL_SPI_STATE_READY;
 802dc3a:	68fb      	ldr	r3, [r7, #12]
 802dc3c:	2201      	movs	r2, #1
 802dc3e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    goto error;
 802dc42:	e054      	b.n	802dcee <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  /* Enable Rx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 802dc44:	68fb      	ldr	r3, [r7, #12]
 802dc46:	681b      	ldr	r3, [r3, #0]
 802dc48:	685a      	ldr	r2, [r3, #4]
 802dc4a:	68fb      	ldr	r3, [r7, #12]
 802dc4c:	681b      	ldr	r3, [r3, #0]
 802dc4e:	f042 0201 	orr.w	r2, r2, #1
 802dc52:	605a      	str	r2, [r3, #4]

  /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
  is performed in DMA reception complete callback  */
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 802dc54:	68fb      	ldr	r3, [r7, #12]
 802dc56:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802dc58:	2200      	movs	r2, #0
 802dc5a:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->hdmatx->XferCpltCallback     = NULL;
 802dc5c:	68fb      	ldr	r3, [r7, #12]
 802dc5e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802dc60:	2200      	movs	r2, #0
 802dc62:	63da      	str	r2, [r3, #60]	; 0x3c
  hspi->hdmatx->XferErrorCallback    = NULL;
 802dc64:	68fb      	ldr	r3, [r7, #12]
 802dc66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802dc68:	2200      	movs	r2, #0
 802dc6a:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi->hdmatx->XferAbortCallback    = NULL;
 802dc6c:	68fb      	ldr	r3, [r7, #12]
 802dc6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802dc70:	2200      	movs	r2, #0
 802dc72:	651a      	str	r2, [r3, #80]	; 0x50

  /* Enable the Tx DMA Stream/Channel  */
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 802dc74:	68fb      	ldr	r3, [r7, #12]
 802dc76:	6c98      	ldr	r0, [r3, #72]	; 0x48
 802dc78:	68fb      	ldr	r3, [r7, #12]
 802dc7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802dc7c:	4619      	mov	r1, r3
 802dc7e:	68fb      	ldr	r3, [r7, #12]
 802dc80:	681b      	ldr	r3, [r3, #0]
 802dc82:	330c      	adds	r3, #12
 802dc84:	461a      	mov	r2, r3
                                 hspi->TxXferCount))
 802dc86:	68fb      	ldr	r3, [r7, #12]
 802dc88:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802dc8a:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 802dc8c:	f7fe fb0e 	bl	802c2ac <HAL_DMA_Start_IT>
 802dc90:	4603      	mov	r3, r0
 802dc92:	2b00      	cmp	r3, #0
 802dc94:	d00c      	beq.n	802dcb0 <HAL_SPI_TransmitReceive_DMA+0x1a0>
  {
    /* Update SPI error code */
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 802dc96:	68fb      	ldr	r3, [r7, #12]
 802dc98:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802dc9a:	f043 0210 	orr.w	r2, r3, #16
 802dc9e:	68fb      	ldr	r3, [r7, #12]
 802dca0:	655a      	str	r2, [r3, #84]	; 0x54
    errorcode = HAL_ERROR;
 802dca2:	2301      	movs	r3, #1
 802dca4:	75fb      	strb	r3, [r7, #23]

    hspi->State = HAL_SPI_STATE_READY;
 802dca6:	68fb      	ldr	r3, [r7, #12]
 802dca8:	2201      	movs	r2, #1
 802dcaa:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    goto error;
 802dcae:	e01e      	b.n	802dcee <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802dcb0:	68fb      	ldr	r3, [r7, #12]
 802dcb2:	681b      	ldr	r3, [r3, #0]
 802dcb4:	681b      	ldr	r3, [r3, #0]
 802dcb6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802dcba:	2b40      	cmp	r3, #64	; 0x40
 802dcbc:	d007      	beq.n	802dcce <HAL_SPI_TransmitReceive_DMA+0x1be>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 802dcbe:	68fb      	ldr	r3, [r7, #12]
 802dcc0:	681b      	ldr	r3, [r3, #0]
 802dcc2:	681a      	ldr	r2, [r3, #0]
 802dcc4:	68fb      	ldr	r3, [r7, #12]
 802dcc6:	681b      	ldr	r3, [r3, #0]
 802dcc8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802dccc:	601a      	str	r2, [r3, #0]
  }
  /* Enable the SPI Error Interrupt Bit */
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 802dcce:	68fb      	ldr	r3, [r7, #12]
 802dcd0:	681b      	ldr	r3, [r3, #0]
 802dcd2:	685a      	ldr	r2, [r3, #4]
 802dcd4:	68fb      	ldr	r3, [r7, #12]
 802dcd6:	681b      	ldr	r3, [r3, #0]
 802dcd8:	f042 0220 	orr.w	r2, r2, #32
 802dcdc:	605a      	str	r2, [r3, #4]

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 802dcde:	68fb      	ldr	r3, [r7, #12]
 802dce0:	681b      	ldr	r3, [r3, #0]
 802dce2:	685a      	ldr	r2, [r3, #4]
 802dce4:	68fb      	ldr	r3, [r7, #12]
 802dce6:	681b      	ldr	r3, [r3, #0]
 802dce8:	f042 0202 	orr.w	r2, r2, #2
 802dcec:	605a      	str	r2, [r3, #4]

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802dcee:	68fb      	ldr	r3, [r7, #12]
 802dcf0:	2200      	movs	r2, #0
 802dcf2:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  return errorcode;
 802dcf6:	7dfb      	ldrb	r3, [r7, #23]
}
 802dcf8:	4618      	mov	r0, r3
 802dcfa:	3718      	adds	r7, #24
 802dcfc:	46bd      	mov	sp, r7
 802dcfe:	bd80      	pop	{r7, pc}
 802dd00:	0802df01 	.word	0x0802df01
 802dd04:	0802dded 	.word	0x0802dded
 802dd08:	0802df1d 	.word	0x0802df1d
 802dd0c:	0802de71 	.word	0x0802de71
 802dd10:	0802df39 	.word	0x0802df39

0802dd14 <HAL_SPI_DMAPause>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
 802dd14:	b480      	push	{r7}
 802dd16:	b083      	sub	sp, #12
 802dd18:	af00      	add	r7, sp, #0
 802dd1a:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hspi);
 802dd1c:	687b      	ldr	r3, [r7, #4]
 802dd1e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802dd22:	2b01      	cmp	r3, #1
 802dd24:	d101      	bne.n	802dd2a <HAL_SPI_DMAPause+0x16>
 802dd26:	2302      	movs	r3, #2
 802dd28:	e010      	b.n	802dd4c <HAL_SPI_DMAPause+0x38>
 802dd2a:	687b      	ldr	r3, [r7, #4]
 802dd2c:	2201      	movs	r2, #1
 802dd2e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802dd32:	687b      	ldr	r3, [r7, #4]
 802dd34:	681b      	ldr	r3, [r3, #0]
 802dd36:	685a      	ldr	r2, [r3, #4]
 802dd38:	687b      	ldr	r3, [r7, #4]
 802dd3a:	681b      	ldr	r3, [r3, #0]
 802dd3c:	f022 0203 	bic.w	r2, r2, #3
 802dd40:	605a      	str	r2, [r3, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802dd42:	687b      	ldr	r3, [r7, #4]
 802dd44:	2200      	movs	r2, #0
 802dd46:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 802dd4a:	2300      	movs	r3, #0
}
 802dd4c:	4618      	mov	r0, r3
 802dd4e:	370c      	adds	r7, #12
 802dd50:	46bd      	mov	sp, r7
 802dd52:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dd56:	4770      	bx	lr

0802dd58 <HAL_SPI_DMAResume>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
 802dd58:	b480      	push	{r7}
 802dd5a:	b083      	sub	sp, #12
 802dd5c:	af00      	add	r7, sp, #0
 802dd5e:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hspi);
 802dd60:	687b      	ldr	r3, [r7, #4]
 802dd62:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802dd66:	2b01      	cmp	r3, #1
 802dd68:	d101      	bne.n	802dd6e <HAL_SPI_DMAResume+0x16>
 802dd6a:	2302      	movs	r3, #2
 802dd6c:	e010      	b.n	802dd90 <HAL_SPI_DMAResume+0x38>
 802dd6e:	687b      	ldr	r3, [r7, #4]
 802dd70:	2201      	movs	r2, #1
 802dd72:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Enable the SPI DMA Tx & Rx requests */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802dd76:	687b      	ldr	r3, [r7, #4]
 802dd78:	681b      	ldr	r3, [r3, #0]
 802dd7a:	685a      	ldr	r2, [r3, #4]
 802dd7c:	687b      	ldr	r3, [r7, #4]
 802dd7e:	681b      	ldr	r3, [r3, #0]
 802dd80:	f042 0203 	orr.w	r2, r2, #3
 802dd84:	605a      	str	r2, [r3, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802dd86:	687b      	ldr	r3, [r7, #4]
 802dd88:	2200      	movs	r2, #0
 802dd8a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 802dd8e:	2300      	movs	r3, #0
}
 802dd90:	4618      	mov	r0, r3
 802dd92:	370c      	adds	r7, #12
 802dd94:	46bd      	mov	sp, r7
 802dd96:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dd9a:	4770      	bx	lr

0802dd9c <HAL_SPI_RxCpltCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
 802dd9c:	b480      	push	{r7}
 802dd9e:	b083      	sub	sp, #12
 802dda0:	af00      	add	r7, sp, #0
 802dda2:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback should be implemented in the user file
   */
}
 802dda4:	bf00      	nop
 802dda6:	370c      	adds	r7, #12
 802dda8:	46bd      	mov	sp, r7
 802ddaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ddae:	4770      	bx	lr

0802ddb0 <HAL_SPI_RxHalfCpltCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 802ddb0:	b480      	push	{r7}
 802ddb2:	b083      	sub	sp, #12
 802ddb4:	af00      	add	r7, sp, #0
 802ddb6:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   */
}
 802ddb8:	bf00      	nop
 802ddba:	370c      	adds	r7, #12
 802ddbc:	46bd      	mov	sp, r7
 802ddbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ddc2:	4770      	bx	lr

0802ddc4 <HAL_SPI_TxRxHalfCpltCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 802ddc4:	b480      	push	{r7}
 802ddc6:	b083      	sub	sp, #12
 802ddc8:	af00      	add	r7, sp, #0
 802ddca:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   */
}
 802ddcc:	bf00      	nop
 802ddce:	370c      	adds	r7, #12
 802ddd0:	46bd      	mov	sp, r7
 802ddd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ddd6:	4770      	bx	lr

0802ddd8 <HAL_SPI_ErrorCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 802ddd8:	b480      	push	{r7}
 802ddda:	b083      	sub	sp, #12
 802dddc:	af00      	add	r7, sp, #0
 802ddde:	6078      	str	r0, [r7, #4]
            the HAL_SPI_ErrorCallback should be implemented in the user file
   */
  /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
            and user can use HAL_SPI_GetError() API to check the latest error occurred
   */
}
 802dde0:	bf00      	nop
 802dde2:	370c      	adds	r7, #12
 802dde4:	46bd      	mov	sp, r7
 802dde6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ddea:	4770      	bx	lr

0802ddec <SPI_DMAReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802ddec:	b580      	push	{r7, lr}
 802ddee:	b084      	sub	sp, #16
 802ddf0:	af00      	add	r7, sp, #0
 802ddf2:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802ddf4:	687b      	ldr	r3, [r7, #4]
 802ddf6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802ddf8:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802ddfa:	f7fe f869 	bl	802bed0 <HAL_GetTick>
 802ddfe:	60b8      	str	r0, [r7, #8]

  /* DMA Normal Mode */
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
 802de00:	687b      	ldr	r3, [r7, #4]
 802de02:	681b      	ldr	r3, [r3, #0]
 802de04:	681b      	ldr	r3, [r3, #0]
 802de06:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802de0a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802de0e:	d029      	beq.n	802de64 <SPI_DMAReceiveCplt+0x78>
  {
    /* Disable ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 802de10:	68fb      	ldr	r3, [r7, #12]
 802de12:	681b      	ldr	r3, [r3, #0]
 802de14:	685a      	ldr	r2, [r3, #4]
 802de16:	68fb      	ldr	r3, [r7, #12]
 802de18:	681b      	ldr	r3, [r3, #0]
 802de1a:	f022 0220 	bic.w	r2, r2, #32
 802de1e:	605a      	str	r2, [r3, #4]
      READ_REG(hspi->Instance->DR);
    }
#endif /* USE_SPI_CRC */

    /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802de20:	68fb      	ldr	r3, [r7, #12]
 802de22:	681b      	ldr	r3, [r3, #0]
 802de24:	685a      	ldr	r2, [r3, #4]
 802de26:	68fb      	ldr	r3, [r7, #12]
 802de28:	681b      	ldr	r3, [r3, #0]
 802de2a:	f022 0203 	bic.w	r2, r2, #3
 802de2e:	605a      	str	r2, [r3, #4]

    /* Check the end of the transaction */
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 802de30:	68ba      	ldr	r2, [r7, #8]
 802de32:	2164      	movs	r1, #100	; 0x64
 802de34:	68f8      	ldr	r0, [r7, #12]
 802de36:	f000 f909 	bl	802e04c <SPI_EndRxTransaction>
 802de3a:	4603      	mov	r3, r0
 802de3c:	2b00      	cmp	r3, #0
 802de3e:	d002      	beq.n	802de46 <SPI_DMAReceiveCplt+0x5a>
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 802de40:	68fb      	ldr	r3, [r7, #12]
 802de42:	2220      	movs	r2, #32
 802de44:	655a      	str	r2, [r3, #84]	; 0x54
    }

    hspi->RxXferCount = 0U;
 802de46:	68fb      	ldr	r3, [r7, #12]
 802de48:	2200      	movs	r2, #0
 802de4a:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 802de4c:	68fb      	ldr	r3, [r7, #12]
 802de4e:	2201      	movs	r2, #1
 802de50:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    }
#endif /* USE_SPI_CRC */

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 802de54:	68fb      	ldr	r3, [r7, #12]
 802de56:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802de58:	2b00      	cmp	r3, #0
 802de5a:	d003      	beq.n	802de64 <SPI_DMAReceiveCplt+0x78>
    {
      /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
 802de5c:	68f8      	ldr	r0, [r7, #12]
 802de5e:	f7ff ffbb 	bl	802ddd8 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      return;
 802de62:	e002      	b.n	802de6a <SPI_DMAReceiveCplt+0x7e>
  }
  /* Call user Rx complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->RxCpltCallback(hspi);
#else
  HAL_SPI_RxCpltCallback(hspi);
 802de64:	68f8      	ldr	r0, [r7, #12]
 802de66:	f7ff ff99 	bl	802dd9c <HAL_SPI_RxCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802de6a:	3710      	adds	r7, #16
 802de6c:	46bd      	mov	sp, r7
 802de6e:	bd80      	pop	{r7, pc}

0802de70 <SPI_DMATransmitReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802de70:	b580      	push	{r7, lr}
 802de72:	b084      	sub	sp, #16
 802de74:	af00      	add	r7, sp, #0
 802de76:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802de78:	687b      	ldr	r3, [r7, #4]
 802de7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802de7c:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802de7e:	f7fe f827 	bl	802bed0 <HAL_GetTick>
 802de82:	60b8      	str	r0, [r7, #8]

  /* DMA Normal Mode */
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
 802de84:	687b      	ldr	r3, [r7, #4]
 802de86:	681b      	ldr	r3, [r3, #0]
 802de88:	681b      	ldr	r3, [r3, #0]
 802de8a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802de8e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802de92:	d02f      	beq.n	802def4 <SPI_DMATransmitReceiveCplt+0x84>
  {
    /* Disable ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 802de94:	68fb      	ldr	r3, [r7, #12]
 802de96:	681b      	ldr	r3, [r3, #0]
 802de98:	685a      	ldr	r2, [r3, #4]
 802de9a:	68fb      	ldr	r3, [r7, #12]
 802de9c:	681b      	ldr	r3, [r3, #0]
 802de9e:	f022 0220 	bic.w	r2, r2, #32
 802dea2:	605a      	str	r2, [r3, #4]
      READ_REG(hspi->Instance->DR);
    }
#endif /* USE_SPI_CRC */

    /* Check the end of the transaction */
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 802dea4:	68ba      	ldr	r2, [r7, #8]
 802dea6:	2164      	movs	r1, #100	; 0x64
 802dea8:	68f8      	ldr	r0, [r7, #12]
 802deaa:	f000 f935 	bl	802e118 <SPI_EndRxTxTransaction>
 802deae:	4603      	mov	r3, r0
 802deb0:	2b00      	cmp	r3, #0
 802deb2:	d005      	beq.n	802dec0 <SPI_DMATransmitReceiveCplt+0x50>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802deb4:	68fb      	ldr	r3, [r7, #12]
 802deb6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802deb8:	f043 0220 	orr.w	r2, r3, #32
 802debc:	68fb      	ldr	r3, [r7, #12]
 802debe:	655a      	str	r2, [r3, #84]	; 0x54
    }

    /* Disable Rx/Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802dec0:	68fb      	ldr	r3, [r7, #12]
 802dec2:	681b      	ldr	r3, [r3, #0]
 802dec4:	685a      	ldr	r2, [r3, #4]
 802dec6:	68fb      	ldr	r3, [r7, #12]
 802dec8:	681b      	ldr	r3, [r3, #0]
 802deca:	f022 0203 	bic.w	r2, r2, #3
 802dece:	605a      	str	r2, [r3, #4]

    hspi->TxXferCount = 0U;
 802ded0:	68fb      	ldr	r3, [r7, #12]
 802ded2:	2200      	movs	r2, #0
 802ded4:	86da      	strh	r2, [r3, #54]	; 0x36
    hspi->RxXferCount = 0U;
 802ded6:	68fb      	ldr	r3, [r7, #12]
 802ded8:	2200      	movs	r2, #0
 802deda:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 802dedc:	68fb      	ldr	r3, [r7, #12]
 802dede:	2201      	movs	r2, #1
 802dee0:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    }
#endif /* USE_SPI_CRC */

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 802dee4:	68fb      	ldr	r3, [r7, #12]
 802dee6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802dee8:	2b00      	cmp	r3, #0
 802deea:	d003      	beq.n	802def4 <SPI_DMATransmitReceiveCplt+0x84>
    {
      /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
 802deec:	68f8      	ldr	r0, [r7, #12]
 802deee:	f7ff ff73 	bl	802ddd8 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      return;
 802def2:	e002      	b.n	802defa <SPI_DMATransmitReceiveCplt+0x8a>
  }
  /* Call user TxRx complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->TxRxCpltCallback(hspi);
#else
  HAL_SPI_TxRxCpltCallback(hspi);
 802def4:	68f8      	ldr	r0, [r7, #12]
 802def6:	f7fb fd57 	bl	80299a8 <HAL_SPI_TxRxCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802defa:	3710      	adds	r7, #16
 802defc:	46bd      	mov	sp, r7
 802defe:	bd80      	pop	{r7, pc}

0802df00 <SPI_DMAHalfReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802df00:	b580      	push	{r7, lr}
 802df02:	b084      	sub	sp, #16
 802df04:	af00      	add	r7, sp, #0
 802df06:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802df08:	687b      	ldr	r3, [r7, #4]
 802df0a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802df0c:	60fb      	str	r3, [r7, #12]

  /* Call user Rx half complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->RxHalfCpltCallback(hspi);
#else
  HAL_SPI_RxHalfCpltCallback(hspi);
 802df0e:	68f8      	ldr	r0, [r7, #12]
 802df10:	f7ff ff4e 	bl	802ddb0 <HAL_SPI_RxHalfCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802df14:	bf00      	nop
 802df16:	3710      	adds	r7, #16
 802df18:	46bd      	mov	sp, r7
 802df1a:	bd80      	pop	{r7, pc}

0802df1c <SPI_DMAHalfTransmitReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802df1c:	b580      	push	{r7, lr}
 802df1e:	b084      	sub	sp, #16
 802df20:	af00      	add	r7, sp, #0
 802df22:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802df24:	687b      	ldr	r3, [r7, #4]
 802df26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802df28:	60fb      	str	r3, [r7, #12]

  /* Call user TxRx half complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->TxRxHalfCpltCallback(hspi);
#else
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 802df2a:	68f8      	ldr	r0, [r7, #12]
 802df2c:	f7ff ff4a 	bl	802ddc4 <HAL_SPI_TxRxHalfCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802df30:	bf00      	nop
 802df32:	3710      	adds	r7, #16
 802df34:	46bd      	mov	sp, r7
 802df36:	bd80      	pop	{r7, pc}

0802df38 <SPI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
 802df38:	b580      	push	{r7, lr}
 802df3a:	b084      	sub	sp, #16
 802df3c:	af00      	add	r7, sp, #0
 802df3e:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802df40:	687b      	ldr	r3, [r7, #4]
 802df42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802df44:	60fb      	str	r3, [r7, #12]

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802df46:	68fb      	ldr	r3, [r7, #12]
 802df48:	681b      	ldr	r3, [r3, #0]
 802df4a:	685a      	ldr	r2, [r3, #4]
 802df4c:	68fb      	ldr	r3, [r7, #12]
 802df4e:	681b      	ldr	r3, [r3, #0]
 802df50:	f022 0203 	bic.w	r2, r2, #3
 802df54:	605a      	str	r2, [r3, #4]

  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 802df56:	68fb      	ldr	r3, [r7, #12]
 802df58:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802df5a:	f043 0210 	orr.w	r2, r3, #16
 802df5e:	68fb      	ldr	r3, [r7, #12]
 802df60:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 802df62:	68fb      	ldr	r3, [r7, #12]
 802df64:	2201      	movs	r2, #1
 802df66:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 802df6a:	68f8      	ldr	r0, [r7, #12]
 802df6c:	f7ff ff34 	bl	802ddd8 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802df70:	bf00      	nop
 802df72:	3710      	adds	r7, #16
 802df74:	46bd      	mov	sp, r7
 802df76:	bd80      	pop	{r7, pc}

0802df78 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 802df78:	b580      	push	{r7, lr}
 802df7a:	b084      	sub	sp, #16
 802df7c:	af00      	add	r7, sp, #0
 802df7e:	60f8      	str	r0, [r7, #12]
 802df80:	60b9      	str	r1, [r7, #8]
 802df82:	603b      	str	r3, [r7, #0]
 802df84:	4613      	mov	r3, r2
 802df86:	71fb      	strb	r3, [r7, #7]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 802df88:	e04c      	b.n	802e024 <SPI_WaitFlagStateUntilTimeout+0xac>
  {
    if (Timeout != HAL_MAX_DELAY)
 802df8a:	683b      	ldr	r3, [r7, #0]
 802df8c:	f1b3 3fff 	cmp.w	r3, #4294967295
 802df90:	d048      	beq.n	802e024 <SPI_WaitFlagStateUntilTimeout+0xac>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 802df92:	f7fd ff9d 	bl	802bed0 <HAL_GetTick>
 802df96:	4602      	mov	r2, r0
 802df98:	69bb      	ldr	r3, [r7, #24]
 802df9a:	1ad3      	subs	r3, r2, r3
 802df9c:	683a      	ldr	r2, [r7, #0]
 802df9e:	429a      	cmp	r2, r3
 802dfa0:	d902      	bls.n	802dfa8 <SPI_WaitFlagStateUntilTimeout+0x30>
 802dfa2:	683b      	ldr	r3, [r7, #0]
 802dfa4:	2b00      	cmp	r3, #0
 802dfa6:	d13d      	bne.n	802e024 <SPI_WaitFlagStateUntilTimeout+0xac>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 802dfa8:	68fb      	ldr	r3, [r7, #12]
 802dfaa:	681b      	ldr	r3, [r3, #0]
 802dfac:	685a      	ldr	r2, [r3, #4]
 802dfae:	68fb      	ldr	r3, [r7, #12]
 802dfb0:	681b      	ldr	r3, [r3, #0]
 802dfb2:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 802dfb6:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802dfb8:	68fb      	ldr	r3, [r7, #12]
 802dfba:	685b      	ldr	r3, [r3, #4]
 802dfbc:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802dfc0:	d111      	bne.n	802dfe6 <SPI_WaitFlagStateUntilTimeout+0x6e>
 802dfc2:	68fb      	ldr	r3, [r7, #12]
 802dfc4:	689b      	ldr	r3, [r3, #8]
 802dfc6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802dfca:	d004      	beq.n	802dfd6 <SPI_WaitFlagStateUntilTimeout+0x5e>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 802dfcc:	68fb      	ldr	r3, [r7, #12]
 802dfce:	689b      	ldr	r3, [r3, #8]
 802dfd0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802dfd4:	d107      	bne.n	802dfe6 <SPI_WaitFlagStateUntilTimeout+0x6e>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 802dfd6:	68fb      	ldr	r3, [r7, #12]
 802dfd8:	681b      	ldr	r3, [r3, #0]
 802dfda:	681a      	ldr	r2, [r3, #0]
 802dfdc:	68fb      	ldr	r3, [r7, #12]
 802dfde:	681b      	ldr	r3, [r3, #0]
 802dfe0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802dfe4:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 802dfe6:	68fb      	ldr	r3, [r7, #12]
 802dfe8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802dfea:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 802dfee:	d10f      	bne.n	802e010 <SPI_WaitFlagStateUntilTimeout+0x98>
        {
          SPI_RESET_CRC(hspi);
 802dff0:	68fb      	ldr	r3, [r7, #12]
 802dff2:	681b      	ldr	r3, [r3, #0]
 802dff4:	681a      	ldr	r2, [r3, #0]
 802dff6:	68fb      	ldr	r3, [r7, #12]
 802dff8:	681b      	ldr	r3, [r3, #0]
 802dffa:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 802dffe:	601a      	str	r2, [r3, #0]
 802e000:	68fb      	ldr	r3, [r7, #12]
 802e002:	681b      	ldr	r3, [r3, #0]
 802e004:	681a      	ldr	r2, [r3, #0]
 802e006:	68fb      	ldr	r3, [r7, #12]
 802e008:	681b      	ldr	r3, [r3, #0]
 802e00a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 802e00e:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 802e010:	68fb      	ldr	r3, [r7, #12]
 802e012:	2201      	movs	r2, #1
 802e014:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 802e018:	68fb      	ldr	r3, [r7, #12]
 802e01a:	2200      	movs	r2, #0
 802e01c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

        return HAL_TIMEOUT;
 802e020:	2303      	movs	r3, #3
 802e022:	e00f      	b.n	802e044 <SPI_WaitFlagStateUntilTimeout+0xcc>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 802e024:	68fb      	ldr	r3, [r7, #12]
 802e026:	681b      	ldr	r3, [r3, #0]
 802e028:	689a      	ldr	r2, [r3, #8]
 802e02a:	68bb      	ldr	r3, [r7, #8]
 802e02c:	4013      	ands	r3, r2
 802e02e:	68ba      	ldr	r2, [r7, #8]
 802e030:	429a      	cmp	r2, r3
 802e032:	bf0c      	ite	eq
 802e034:	2301      	moveq	r3, #1
 802e036:	2300      	movne	r3, #0
 802e038:	b2db      	uxtb	r3, r3
 802e03a:	461a      	mov	r2, r3
 802e03c:	79fb      	ldrb	r3, [r7, #7]
 802e03e:	429a      	cmp	r2, r3
 802e040:	d1a3      	bne.n	802df8a <SPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }

  return HAL_OK;
 802e042:	2300      	movs	r3, #0
}
 802e044:	4618      	mov	r0, r3
 802e046:	3710      	adds	r7, #16
 802e048:	46bd      	mov	sp, r7
 802e04a:	bd80      	pop	{r7, pc}

0802e04c <SPI_EndRxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
 802e04c:	b580      	push	{r7, lr}
 802e04e:	b086      	sub	sp, #24
 802e050:	af02      	add	r7, sp, #8
 802e052:	60f8      	str	r0, [r7, #12]
 802e054:	60b9      	str	r1, [r7, #8]
 802e056:	607a      	str	r2, [r7, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802e058:	68fb      	ldr	r3, [r7, #12]
 802e05a:	685b      	ldr	r3, [r3, #4]
 802e05c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802e060:	d111      	bne.n	802e086 <SPI_EndRxTransaction+0x3a>
 802e062:	68fb      	ldr	r3, [r7, #12]
 802e064:	689b      	ldr	r3, [r3, #8]
 802e066:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802e06a:	d004      	beq.n	802e076 <SPI_EndRxTransaction+0x2a>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 802e06c:	68fb      	ldr	r3, [r7, #12]
 802e06e:	689b      	ldr	r3, [r3, #8]
 802e070:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802e074:	d107      	bne.n	802e086 <SPI_EndRxTransaction+0x3a>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 802e076:	68fb      	ldr	r3, [r7, #12]
 802e078:	681b      	ldr	r3, [r3, #0]
 802e07a:	681a      	ldr	r2, [r3, #0]
 802e07c:	68fb      	ldr	r3, [r7, #12]
 802e07e:	681b      	ldr	r3, [r3, #0]
 802e080:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802e084:	601a      	str	r2, [r3, #0]
  }

  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 802e086:	68fb      	ldr	r3, [r7, #12]
 802e088:	685b      	ldr	r3, [r3, #4]
 802e08a:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802e08e:	d12a      	bne.n	802e0e6 <SPI_EndRxTransaction+0x9a>
  {
    if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
 802e090:	68fb      	ldr	r3, [r7, #12]
 802e092:	689b      	ldr	r3, [r3, #8]
 802e094:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802e098:	d012      	beq.n	802e0c0 <SPI_EndRxTransaction+0x74>
    {
      /* Control the BSY flag */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 802e09a:	687b      	ldr	r3, [r7, #4]
 802e09c:	9300      	str	r3, [sp, #0]
 802e09e:	68bb      	ldr	r3, [r7, #8]
 802e0a0:	2200      	movs	r2, #0
 802e0a2:	2180      	movs	r1, #128	; 0x80
 802e0a4:	68f8      	ldr	r0, [r7, #12]
 802e0a6:	f7ff ff67 	bl	802df78 <SPI_WaitFlagStateUntilTimeout>
 802e0aa:	4603      	mov	r3, r0
 802e0ac:	2b00      	cmp	r3, #0
 802e0ae:	d02d      	beq.n	802e10c <SPI_EndRxTransaction+0xc0>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802e0b0:	68fb      	ldr	r3, [r7, #12]
 802e0b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802e0b4:	f043 0220 	orr.w	r2, r3, #32
 802e0b8:	68fb      	ldr	r3, [r7, #12]
 802e0ba:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 802e0bc:	2303      	movs	r3, #3
 802e0be:	e026      	b.n	802e10e <SPI_EndRxTransaction+0xc2>
      }
    }
    else
    {
      /* Wait the RXNE reset */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 802e0c0:	687b      	ldr	r3, [r7, #4]
 802e0c2:	9300      	str	r3, [sp, #0]
 802e0c4:	68bb      	ldr	r3, [r7, #8]
 802e0c6:	2200      	movs	r2, #0
 802e0c8:	2101      	movs	r1, #1
 802e0ca:	68f8      	ldr	r0, [r7, #12]
 802e0cc:	f7ff ff54 	bl	802df78 <SPI_WaitFlagStateUntilTimeout>
 802e0d0:	4603      	mov	r3, r0
 802e0d2:	2b00      	cmp	r3, #0
 802e0d4:	d01a      	beq.n	802e10c <SPI_EndRxTransaction+0xc0>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802e0d6:	68fb      	ldr	r3, [r7, #12]
 802e0d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802e0da:	f043 0220 	orr.w	r2, r3, #32
 802e0de:	68fb      	ldr	r3, [r7, #12]
 802e0e0:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 802e0e2:	2303      	movs	r3, #3
 802e0e4:	e013      	b.n	802e10e <SPI_EndRxTransaction+0xc2>
    }
  }
  else
  {
    /* Wait the RXNE reset */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 802e0e6:	687b      	ldr	r3, [r7, #4]
 802e0e8:	9300      	str	r3, [sp, #0]
 802e0ea:	68bb      	ldr	r3, [r7, #8]
 802e0ec:	2200      	movs	r2, #0
 802e0ee:	2101      	movs	r1, #1
 802e0f0:	68f8      	ldr	r0, [r7, #12]
 802e0f2:	f7ff ff41 	bl	802df78 <SPI_WaitFlagStateUntilTimeout>
 802e0f6:	4603      	mov	r3, r0
 802e0f8:	2b00      	cmp	r3, #0
 802e0fa:	d007      	beq.n	802e10c <SPI_EndRxTransaction+0xc0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802e0fc:	68fb      	ldr	r3, [r7, #12]
 802e0fe:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802e100:	f043 0220 	orr.w	r2, r3, #32
 802e104:	68fb      	ldr	r3, [r7, #12]
 802e106:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 802e108:	2303      	movs	r3, #3
 802e10a:	e000      	b.n	802e10e <SPI_EndRxTransaction+0xc2>
    }
  }
  return HAL_OK;
 802e10c:	2300      	movs	r3, #0
}
 802e10e:	4618      	mov	r0, r3
 802e110:	3710      	adds	r7, #16
 802e112:	46bd      	mov	sp, r7
 802e114:	bd80      	pop	{r7, pc}
	...

0802e118 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 802e118:	b580      	push	{r7, lr}
 802e11a:	b088      	sub	sp, #32
 802e11c:	af02      	add	r7, sp, #8
 802e11e:	60f8      	str	r0, [r7, #12]
 802e120:	60b9      	str	r1, [r7, #8]
 802e122:	607a      	str	r2, [r7, #4]
  /* Timeout in s */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 802e124:	4b1b      	ldr	r3, [pc, #108]	; (802e194 <SPI_EndRxTxTransaction+0x7c>)
 802e126:	681b      	ldr	r3, [r3, #0]
 802e128:	4a1b      	ldr	r2, [pc, #108]	; (802e198 <SPI_EndRxTxTransaction+0x80>)
 802e12a:	fba2 2303 	umull	r2, r3, r2, r3
 802e12e:	0d5b      	lsrs	r3, r3, #21
 802e130:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802e134:	fb02 f303 	mul.w	r3, r2, r3
 802e138:	617b      	str	r3, [r7, #20]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 802e13a:	68fb      	ldr	r3, [r7, #12]
 802e13c:	685b      	ldr	r3, [r3, #4]
 802e13e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802e142:	d112      	bne.n	802e16a <SPI_EndRxTxTransaction+0x52>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 802e144:	687b      	ldr	r3, [r7, #4]
 802e146:	9300      	str	r3, [sp, #0]
 802e148:	68bb      	ldr	r3, [r7, #8]
 802e14a:	2200      	movs	r2, #0
 802e14c:	2180      	movs	r1, #128	; 0x80
 802e14e:	68f8      	ldr	r0, [r7, #12]
 802e150:	f7ff ff12 	bl	802df78 <SPI_WaitFlagStateUntilTimeout>
 802e154:	4603      	mov	r3, r0
 802e156:	2b00      	cmp	r3, #0
 802e158:	d016      	beq.n	802e188 <SPI_EndRxTxTransaction+0x70>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802e15a:	68fb      	ldr	r3, [r7, #12]
 802e15c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802e15e:	f043 0220 	orr.w	r2, r3, #32
 802e162:	68fb      	ldr	r3, [r7, #12]
 802e164:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 802e166:	2303      	movs	r3, #3
 802e168:	e00f      	b.n	802e18a <SPI_EndRxTxTransaction+0x72>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 802e16a:	697b      	ldr	r3, [r7, #20]
 802e16c:	2b00      	cmp	r3, #0
 802e16e:	d00a      	beq.n	802e186 <SPI_EndRxTxTransaction+0x6e>
      {
        break;
      }
      count--;
 802e170:	697b      	ldr	r3, [r7, #20]
 802e172:	3b01      	subs	r3, #1
 802e174:	617b      	str	r3, [r7, #20]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 802e176:	68fb      	ldr	r3, [r7, #12]
 802e178:	681b      	ldr	r3, [r3, #0]
 802e17a:	689b      	ldr	r3, [r3, #8]
 802e17c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802e180:	2b80      	cmp	r3, #128	; 0x80
 802e182:	d0f2      	beq.n	802e16a <SPI_EndRxTxTransaction+0x52>
 802e184:	e000      	b.n	802e188 <SPI_EndRxTxTransaction+0x70>
        break;
 802e186:	bf00      	nop
  }

  return HAL_OK;
 802e188:	2300      	movs	r3, #0
}
 802e18a:	4618      	mov	r0, r3
 802e18c:	3718      	adds	r7, #24
 802e18e:	46bd      	mov	sp, r7
 802e190:	bd80      	pop	{r7, pc}
 802e192:	bf00      	nop
 802e194:	200005c0 	.word	0x200005c0
 802e198:	165e9f81 	.word	0x165e9f81

0802e19c <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 802e19c:	b580      	push	{r7, lr}
 802e19e:	b082      	sub	sp, #8
 802e1a0:	af00      	add	r7, sp, #0
 802e1a2:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 802e1a4:	687b      	ldr	r3, [r7, #4]
 802e1a6:	2b00      	cmp	r3, #0
 802e1a8:	d101      	bne.n	802e1ae <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 802e1aa:	2301      	movs	r3, #1
 802e1ac:	e01d      	b.n	802e1ea <HAL_TIM_Base_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 802e1ae:	687b      	ldr	r3, [r7, #4]
 802e1b0:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 802e1b4:	b2db      	uxtb	r3, r3
 802e1b6:	2b00      	cmp	r3, #0
 802e1b8:	d106      	bne.n	802e1c8 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 802e1ba:	687b      	ldr	r3, [r7, #4]
 802e1bc:	2200      	movs	r2, #0
 802e1be:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 802e1c2:	6878      	ldr	r0, [r7, #4]
 802e1c4:	f7fd f920 	bl	802b408 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 802e1c8:	687b      	ldr	r3, [r7, #4]
 802e1ca:	2202      	movs	r2, #2
 802e1cc:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 802e1d0:	687b      	ldr	r3, [r7, #4]
 802e1d2:	681a      	ldr	r2, [r3, #0]
 802e1d4:	687b      	ldr	r3, [r7, #4]
 802e1d6:	3304      	adds	r3, #4
 802e1d8:	4619      	mov	r1, r3
 802e1da:	4610      	mov	r0, r2
 802e1dc:	f000 fa3a 	bl	802e654 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 802e1e0:	687b      	ldr	r3, [r7, #4]
 802e1e2:	2201      	movs	r2, #1
 802e1e4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 802e1e8:	2300      	movs	r3, #0
}
 802e1ea:	4618      	mov	r0, r3
 802e1ec:	3708      	adds	r7, #8
 802e1ee:	46bd      	mov	sp, r7
 802e1f0:	bd80      	pop	{r7, pc}

0802e1f2 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 802e1f2:	b580      	push	{r7, lr}
 802e1f4:	b082      	sub	sp, #8
 802e1f6:	af00      	add	r7, sp, #0
 802e1f8:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 802e1fa:	687b      	ldr	r3, [r7, #4]
 802e1fc:	2b00      	cmp	r3, #0
 802e1fe:	d101      	bne.n	802e204 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 802e200:	2301      	movs	r3, #1
 802e202:	e01d      	b.n	802e240 <HAL_TIM_PWM_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 802e204:	687b      	ldr	r3, [r7, #4]
 802e206:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 802e20a:	b2db      	uxtb	r3, r3
 802e20c:	2b00      	cmp	r3, #0
 802e20e:	d106      	bne.n	802e21e <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 802e210:	687b      	ldr	r3, [r7, #4]
 802e212:	2200      	movs	r2, #0
 802e214:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 802e218:	6878      	ldr	r0, [r7, #4]
 802e21a:	f000 f815 	bl	802e248 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 802e21e:	687b      	ldr	r3, [r7, #4]
 802e220:	2202      	movs	r2, #2
 802e222:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 802e226:	687b      	ldr	r3, [r7, #4]
 802e228:	681a      	ldr	r2, [r3, #0]
 802e22a:	687b      	ldr	r3, [r7, #4]
 802e22c:	3304      	adds	r3, #4
 802e22e:	4619      	mov	r1, r3
 802e230:	4610      	mov	r0, r2
 802e232:	f000 fa0f 	bl	802e654 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 802e236:	687b      	ldr	r3, [r7, #4]
 802e238:	2201      	movs	r2, #1
 802e23a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 802e23e:	2300      	movs	r3, #0
}
 802e240:	4618      	mov	r0, r3
 802e242:	3708      	adds	r7, #8
 802e244:	46bd      	mov	sp, r7
 802e246:	bd80      	pop	{r7, pc}

0802e248 <HAL_TIM_PWM_MspInit>:
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 802e248:	b480      	push	{r7}
 802e24a:	b083      	sub	sp, #12
 802e24c:	af00      	add	r7, sp, #0
 802e24e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */
}
 802e250:	bf00      	nop
 802e252:	370c      	adds	r7, #12
 802e254:	46bd      	mov	sp, r7
 802e256:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e25a:	4770      	bx	lr

0802e25c <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 802e25c:	b580      	push	{r7, lr}
 802e25e:	b084      	sub	sp, #16
 802e260:	af00      	add	r7, sp, #0
 802e262:	6078      	str	r0, [r7, #4]
 802e264:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 802e266:	687b      	ldr	r3, [r7, #4]
 802e268:	681b      	ldr	r3, [r3, #0]
 802e26a:	2201      	movs	r2, #1
 802e26c:	6839      	ldr	r1, [r7, #0]
 802e26e:	4618      	mov	r0, r3
 802e270:	f000 fc96 	bl	802eba0 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 802e274:	687b      	ldr	r3, [r7, #4]
 802e276:	681b      	ldr	r3, [r3, #0]
 802e278:	4a10      	ldr	r2, [pc, #64]	; (802e2bc <HAL_TIM_PWM_Start+0x60>)
 802e27a:	4293      	cmp	r3, r2
 802e27c:	d107      	bne.n	802e28e <HAL_TIM_PWM_Start+0x32>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 802e27e:	687b      	ldr	r3, [r7, #4]
 802e280:	681b      	ldr	r3, [r3, #0]
 802e282:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 802e284:	687b      	ldr	r3, [r7, #4]
 802e286:	681b      	ldr	r3, [r3, #0]
 802e288:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802e28c:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 802e28e:	687b      	ldr	r3, [r7, #4]
 802e290:	681b      	ldr	r3, [r3, #0]
 802e292:	689b      	ldr	r3, [r3, #8]
 802e294:	f003 0307 	and.w	r3, r3, #7
 802e298:	60fb      	str	r3, [r7, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 802e29a:	68fb      	ldr	r3, [r7, #12]
 802e29c:	2b06      	cmp	r3, #6
 802e29e:	d007      	beq.n	802e2b0 <HAL_TIM_PWM_Start+0x54>
  {
    __HAL_TIM_ENABLE(htim);
 802e2a0:	687b      	ldr	r3, [r7, #4]
 802e2a2:	681b      	ldr	r3, [r3, #0]
 802e2a4:	681a      	ldr	r2, [r3, #0]
 802e2a6:	687b      	ldr	r3, [r7, #4]
 802e2a8:	681b      	ldr	r3, [r3, #0]
 802e2aa:	f042 0201 	orr.w	r2, r2, #1
 802e2ae:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 802e2b0:	2300      	movs	r3, #0
}
 802e2b2:	4618      	mov	r0, r3
 802e2b4:	3710      	adds	r7, #16
 802e2b6:	46bd      	mov	sp, r7
 802e2b8:	bd80      	pop	{r7, pc}
 802e2ba:	bf00      	nop
 802e2bc:	40010000 	.word	0x40010000

0802e2c0 <HAL_TIM_PWM_Stop>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 802e2c0:	b580      	push	{r7, lr}
 802e2c2:	b082      	sub	sp, #8
 802e2c4:	af00      	add	r7, sp, #0
 802e2c6:	6078      	str	r0, [r7, #4]
 802e2c8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 802e2ca:	687b      	ldr	r3, [r7, #4]
 802e2cc:	681b      	ldr	r3, [r3, #0]
 802e2ce:	2200      	movs	r2, #0
 802e2d0:	6839      	ldr	r1, [r7, #0]
 802e2d2:	4618      	mov	r0, r3
 802e2d4:	f000 fc64 	bl	802eba0 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 802e2d8:	687b      	ldr	r3, [r7, #4]
 802e2da:	681b      	ldr	r3, [r3, #0]
 802e2dc:	4a1d      	ldr	r2, [pc, #116]	; (802e354 <HAL_TIM_PWM_Stop+0x94>)
 802e2de:	4293      	cmp	r3, r2
 802e2e0:	d117      	bne.n	802e312 <HAL_TIM_PWM_Stop+0x52>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
 802e2e2:	687b      	ldr	r3, [r7, #4]
 802e2e4:	681b      	ldr	r3, [r3, #0]
 802e2e6:	6a1a      	ldr	r2, [r3, #32]
 802e2e8:	f241 1311 	movw	r3, #4369	; 0x1111
 802e2ec:	4013      	ands	r3, r2
 802e2ee:	2b00      	cmp	r3, #0
 802e2f0:	d10f      	bne.n	802e312 <HAL_TIM_PWM_Stop+0x52>
 802e2f2:	687b      	ldr	r3, [r7, #4]
 802e2f4:	681b      	ldr	r3, [r3, #0]
 802e2f6:	6a1a      	ldr	r2, [r3, #32]
 802e2f8:	f240 4344 	movw	r3, #1092	; 0x444
 802e2fc:	4013      	ands	r3, r2
 802e2fe:	2b00      	cmp	r3, #0
 802e300:	d107      	bne.n	802e312 <HAL_TIM_PWM_Stop+0x52>
 802e302:	687b      	ldr	r3, [r7, #4]
 802e304:	681b      	ldr	r3, [r3, #0]
 802e306:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 802e308:	687b      	ldr	r3, [r7, #4]
 802e30a:	681b      	ldr	r3, [r3, #0]
 802e30c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802e310:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 802e312:	687b      	ldr	r3, [r7, #4]
 802e314:	681b      	ldr	r3, [r3, #0]
 802e316:	6a1a      	ldr	r2, [r3, #32]
 802e318:	f241 1311 	movw	r3, #4369	; 0x1111
 802e31c:	4013      	ands	r3, r2
 802e31e:	2b00      	cmp	r3, #0
 802e320:	d10f      	bne.n	802e342 <HAL_TIM_PWM_Stop+0x82>
 802e322:	687b      	ldr	r3, [r7, #4]
 802e324:	681b      	ldr	r3, [r3, #0]
 802e326:	6a1a      	ldr	r2, [r3, #32]
 802e328:	f240 4344 	movw	r3, #1092	; 0x444
 802e32c:	4013      	ands	r3, r2
 802e32e:	2b00      	cmp	r3, #0
 802e330:	d107      	bne.n	802e342 <HAL_TIM_PWM_Stop+0x82>
 802e332:	687b      	ldr	r3, [r7, #4]
 802e334:	681b      	ldr	r3, [r3, #0]
 802e336:	681a      	ldr	r2, [r3, #0]
 802e338:	687b      	ldr	r3, [r7, #4]
 802e33a:	681b      	ldr	r3, [r3, #0]
 802e33c:	f022 0201 	bic.w	r2, r2, #1
 802e340:	601a      	str	r2, [r3, #0]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 802e342:	687b      	ldr	r3, [r7, #4]
 802e344:	2201      	movs	r2, #1
 802e346:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
 802e34a:	2300      	movs	r3, #0
}
 802e34c:	4618      	mov	r0, r3
 802e34e:	3708      	adds	r7, #8
 802e350:	46bd      	mov	sp, r7
 802e352:	bd80      	pop	{r7, pc}
 802e354:	40010000 	.word	0x40010000

0802e358 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 802e358:	b580      	push	{r7, lr}
 802e35a:	b084      	sub	sp, #16
 802e35c:	af00      	add	r7, sp, #0
 802e35e:	60f8      	str	r0, [r7, #12]
 802e360:	60b9      	str	r1, [r7, #8]
 802e362:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 802e364:	68fb      	ldr	r3, [r7, #12]
 802e366:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 802e36a:	2b01      	cmp	r3, #1
 802e36c:	d101      	bne.n	802e372 <HAL_TIM_PWM_ConfigChannel+0x1a>
 802e36e:	2302      	movs	r3, #2
 802e370:	e0b4      	b.n	802e4dc <HAL_TIM_PWM_ConfigChannel+0x184>
 802e372:	68fb      	ldr	r3, [r7, #12]
 802e374:	2201      	movs	r2, #1
 802e376:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 802e37a:	68fb      	ldr	r3, [r7, #12]
 802e37c:	2202      	movs	r2, #2
 802e37e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  switch (Channel)
 802e382:	687b      	ldr	r3, [r7, #4]
 802e384:	2b0c      	cmp	r3, #12
 802e386:	f200 809f 	bhi.w	802e4c8 <HAL_TIM_PWM_ConfigChannel+0x170>
 802e38a:	a201      	add	r2, pc, #4	; (adr r2, 802e390 <HAL_TIM_PWM_ConfigChannel+0x38>)
 802e38c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802e390:	0802e3c5 	.word	0x0802e3c5
 802e394:	0802e4c9 	.word	0x0802e4c9
 802e398:	0802e4c9 	.word	0x0802e4c9
 802e39c:	0802e4c9 	.word	0x0802e4c9
 802e3a0:	0802e405 	.word	0x0802e405
 802e3a4:	0802e4c9 	.word	0x0802e4c9
 802e3a8:	0802e4c9 	.word	0x0802e4c9
 802e3ac:	0802e4c9 	.word	0x0802e4c9
 802e3b0:	0802e447 	.word	0x0802e447
 802e3b4:	0802e4c9 	.word	0x0802e4c9
 802e3b8:	0802e4c9 	.word	0x0802e4c9
 802e3bc:	0802e4c9 	.word	0x0802e4c9
 802e3c0:	0802e487 	.word	0x0802e487
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 802e3c4:	68fb      	ldr	r3, [r7, #12]
 802e3c6:	681b      	ldr	r3, [r3, #0]
 802e3c8:	68b9      	ldr	r1, [r7, #8]
 802e3ca:	4618      	mov	r0, r3
 802e3cc:	f000 f9c2 	bl	802e754 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 802e3d0:	68fb      	ldr	r3, [r7, #12]
 802e3d2:	681b      	ldr	r3, [r3, #0]
 802e3d4:	699a      	ldr	r2, [r3, #24]
 802e3d6:	68fb      	ldr	r3, [r7, #12]
 802e3d8:	681b      	ldr	r3, [r3, #0]
 802e3da:	f042 0208 	orr.w	r2, r2, #8
 802e3de:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 802e3e0:	68fb      	ldr	r3, [r7, #12]
 802e3e2:	681b      	ldr	r3, [r3, #0]
 802e3e4:	699a      	ldr	r2, [r3, #24]
 802e3e6:	68fb      	ldr	r3, [r7, #12]
 802e3e8:	681b      	ldr	r3, [r3, #0]
 802e3ea:	f022 0204 	bic.w	r2, r2, #4
 802e3ee:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 802e3f0:	68fb      	ldr	r3, [r7, #12]
 802e3f2:	681b      	ldr	r3, [r3, #0]
 802e3f4:	6999      	ldr	r1, [r3, #24]
 802e3f6:	68bb      	ldr	r3, [r7, #8]
 802e3f8:	691a      	ldr	r2, [r3, #16]
 802e3fa:	68fb      	ldr	r3, [r7, #12]
 802e3fc:	681b      	ldr	r3, [r3, #0]
 802e3fe:	430a      	orrs	r2, r1
 802e400:	619a      	str	r2, [r3, #24]
      break;
 802e402:	e062      	b.n	802e4ca <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 802e404:	68fb      	ldr	r3, [r7, #12]
 802e406:	681b      	ldr	r3, [r3, #0]
 802e408:	68b9      	ldr	r1, [r7, #8]
 802e40a:	4618      	mov	r0, r3
 802e40c:	f000 fa08 	bl	802e820 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 802e410:	68fb      	ldr	r3, [r7, #12]
 802e412:	681b      	ldr	r3, [r3, #0]
 802e414:	699a      	ldr	r2, [r3, #24]
 802e416:	68fb      	ldr	r3, [r7, #12]
 802e418:	681b      	ldr	r3, [r3, #0]
 802e41a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802e41e:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 802e420:	68fb      	ldr	r3, [r7, #12]
 802e422:	681b      	ldr	r3, [r3, #0]
 802e424:	699a      	ldr	r2, [r3, #24]
 802e426:	68fb      	ldr	r3, [r7, #12]
 802e428:	681b      	ldr	r3, [r3, #0]
 802e42a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 802e42e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 802e430:	68fb      	ldr	r3, [r7, #12]
 802e432:	681b      	ldr	r3, [r3, #0]
 802e434:	6999      	ldr	r1, [r3, #24]
 802e436:	68bb      	ldr	r3, [r7, #8]
 802e438:	691b      	ldr	r3, [r3, #16]
 802e43a:	021a      	lsls	r2, r3, #8
 802e43c:	68fb      	ldr	r3, [r7, #12]
 802e43e:	681b      	ldr	r3, [r3, #0]
 802e440:	430a      	orrs	r2, r1
 802e442:	619a      	str	r2, [r3, #24]
      break;
 802e444:	e041      	b.n	802e4ca <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 802e446:	68fb      	ldr	r3, [r7, #12]
 802e448:	681b      	ldr	r3, [r3, #0]
 802e44a:	68b9      	ldr	r1, [r7, #8]
 802e44c:	4618      	mov	r0, r3
 802e44e:	f000 fa53 	bl	802e8f8 <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 802e452:	68fb      	ldr	r3, [r7, #12]
 802e454:	681b      	ldr	r3, [r3, #0]
 802e456:	69da      	ldr	r2, [r3, #28]
 802e458:	68fb      	ldr	r3, [r7, #12]
 802e45a:	681b      	ldr	r3, [r3, #0]
 802e45c:	f042 0208 	orr.w	r2, r2, #8
 802e460:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 802e462:	68fb      	ldr	r3, [r7, #12]
 802e464:	681b      	ldr	r3, [r3, #0]
 802e466:	69da      	ldr	r2, [r3, #28]
 802e468:	68fb      	ldr	r3, [r7, #12]
 802e46a:	681b      	ldr	r3, [r3, #0]
 802e46c:	f022 0204 	bic.w	r2, r2, #4
 802e470:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 802e472:	68fb      	ldr	r3, [r7, #12]
 802e474:	681b      	ldr	r3, [r3, #0]
 802e476:	69d9      	ldr	r1, [r3, #28]
 802e478:	68bb      	ldr	r3, [r7, #8]
 802e47a:	691a      	ldr	r2, [r3, #16]
 802e47c:	68fb      	ldr	r3, [r7, #12]
 802e47e:	681b      	ldr	r3, [r3, #0]
 802e480:	430a      	orrs	r2, r1
 802e482:	61da      	str	r2, [r3, #28]
      break;
 802e484:	e021      	b.n	802e4ca <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 802e486:	68fb      	ldr	r3, [r7, #12]
 802e488:	681b      	ldr	r3, [r3, #0]
 802e48a:	68b9      	ldr	r1, [r7, #8]
 802e48c:	4618      	mov	r0, r3
 802e48e:	f000 fa9d 	bl	802e9cc <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 802e492:	68fb      	ldr	r3, [r7, #12]
 802e494:	681b      	ldr	r3, [r3, #0]
 802e496:	69da      	ldr	r2, [r3, #28]
 802e498:	68fb      	ldr	r3, [r7, #12]
 802e49a:	681b      	ldr	r3, [r3, #0]
 802e49c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802e4a0:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 802e4a2:	68fb      	ldr	r3, [r7, #12]
 802e4a4:	681b      	ldr	r3, [r3, #0]
 802e4a6:	69da      	ldr	r2, [r3, #28]
 802e4a8:	68fb      	ldr	r3, [r7, #12]
 802e4aa:	681b      	ldr	r3, [r3, #0]
 802e4ac:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 802e4b0:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 802e4b2:	68fb      	ldr	r3, [r7, #12]
 802e4b4:	681b      	ldr	r3, [r3, #0]
 802e4b6:	69d9      	ldr	r1, [r3, #28]
 802e4b8:	68bb      	ldr	r3, [r7, #8]
 802e4ba:	691b      	ldr	r3, [r3, #16]
 802e4bc:	021a      	lsls	r2, r3, #8
 802e4be:	68fb      	ldr	r3, [r7, #12]
 802e4c0:	681b      	ldr	r3, [r3, #0]
 802e4c2:	430a      	orrs	r2, r1
 802e4c4:	61da      	str	r2, [r3, #28]
      break;
 802e4c6:	e000      	b.n	802e4ca <HAL_TIM_PWM_ConfigChannel+0x172>
    }

    default:
      break;
 802e4c8:	bf00      	nop
  }

  htim->State = HAL_TIM_STATE_READY;
 802e4ca:	68fb      	ldr	r3, [r7, #12]
 802e4cc:	2201      	movs	r2, #1
 802e4ce:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 802e4d2:	68fb      	ldr	r3, [r7, #12]
 802e4d4:	2200      	movs	r2, #0
 802e4d6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 802e4da:	2300      	movs	r3, #0
}
 802e4dc:	4618      	mov	r0, r3
 802e4de:	3710      	adds	r7, #16
 802e4e0:	46bd      	mov	sp, r7
 802e4e2:	bd80      	pop	{r7, pc}

0802e4e4 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 802e4e4:	b580      	push	{r7, lr}
 802e4e6:	b084      	sub	sp, #16
 802e4e8:	af00      	add	r7, sp, #0
 802e4ea:	6078      	str	r0, [r7, #4]
 802e4ec:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 802e4ee:	687b      	ldr	r3, [r7, #4]
 802e4f0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 802e4f4:	2b01      	cmp	r3, #1
 802e4f6:	d101      	bne.n	802e4fc <HAL_TIM_ConfigClockSource+0x18>
 802e4f8:	2302      	movs	r3, #2
 802e4fa:	e0a6      	b.n	802e64a <HAL_TIM_ConfigClockSource+0x166>
 802e4fc:	687b      	ldr	r3, [r7, #4]
 802e4fe:	2201      	movs	r2, #1
 802e500:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 802e504:	687b      	ldr	r3, [r7, #4]
 802e506:	2202      	movs	r2, #2
 802e508:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 802e50c:	687b      	ldr	r3, [r7, #4]
 802e50e:	681b      	ldr	r3, [r3, #0]
 802e510:	689b      	ldr	r3, [r3, #8]
 802e512:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 802e514:	68fb      	ldr	r3, [r7, #12]
 802e516:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 802e51a:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 802e51c:	68fb      	ldr	r3, [r7, #12]
 802e51e:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802e522:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 802e524:	687b      	ldr	r3, [r7, #4]
 802e526:	681b      	ldr	r3, [r3, #0]
 802e528:	68fa      	ldr	r2, [r7, #12]
 802e52a:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 802e52c:	683b      	ldr	r3, [r7, #0]
 802e52e:	681b      	ldr	r3, [r3, #0]
 802e530:	2b40      	cmp	r3, #64	; 0x40
 802e532:	d067      	beq.n	802e604 <HAL_TIM_ConfigClockSource+0x120>
 802e534:	2b40      	cmp	r3, #64	; 0x40
 802e536:	d80b      	bhi.n	802e550 <HAL_TIM_ConfigClockSource+0x6c>
 802e538:	2b10      	cmp	r3, #16
 802e53a:	d073      	beq.n	802e624 <HAL_TIM_ConfigClockSource+0x140>
 802e53c:	2b10      	cmp	r3, #16
 802e53e:	d802      	bhi.n	802e546 <HAL_TIM_ConfigClockSource+0x62>
 802e540:	2b00      	cmp	r3, #0
 802e542:	d06f      	beq.n	802e624 <HAL_TIM_ConfigClockSource+0x140>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
      break;
    }

    default:
      break;
 802e544:	e078      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 802e546:	2b20      	cmp	r3, #32
 802e548:	d06c      	beq.n	802e624 <HAL_TIM_ConfigClockSource+0x140>
 802e54a:	2b30      	cmp	r3, #48	; 0x30
 802e54c:	d06a      	beq.n	802e624 <HAL_TIM_ConfigClockSource+0x140>
      break;
 802e54e:	e073      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 802e550:	2b70      	cmp	r3, #112	; 0x70
 802e552:	d00d      	beq.n	802e570 <HAL_TIM_ConfigClockSource+0x8c>
 802e554:	2b70      	cmp	r3, #112	; 0x70
 802e556:	d804      	bhi.n	802e562 <HAL_TIM_ConfigClockSource+0x7e>
 802e558:	2b50      	cmp	r3, #80	; 0x50
 802e55a:	d033      	beq.n	802e5c4 <HAL_TIM_ConfigClockSource+0xe0>
 802e55c:	2b60      	cmp	r3, #96	; 0x60
 802e55e:	d041      	beq.n	802e5e4 <HAL_TIM_ConfigClockSource+0x100>
      break;
 802e560:	e06a      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 802e562:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 802e566:	d066      	beq.n	802e636 <HAL_TIM_ConfigClockSource+0x152>
 802e568:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 802e56c:	d017      	beq.n	802e59e <HAL_TIM_ConfigClockSource+0xba>
      break;
 802e56e:	e063      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
 802e570:	687b      	ldr	r3, [r7, #4]
 802e572:	6818      	ldr	r0, [r3, #0]
 802e574:	683b      	ldr	r3, [r7, #0]
 802e576:	6899      	ldr	r1, [r3, #8]
 802e578:	683b      	ldr	r3, [r7, #0]
 802e57a:	685a      	ldr	r2, [r3, #4]
 802e57c:	683b      	ldr	r3, [r7, #0]
 802e57e:	68db      	ldr	r3, [r3, #12]
 802e580:	f000 faee 	bl	802eb60 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 802e584:	687b      	ldr	r3, [r7, #4]
 802e586:	681b      	ldr	r3, [r3, #0]
 802e588:	689b      	ldr	r3, [r3, #8]
 802e58a:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 802e58c:	68fb      	ldr	r3, [r7, #12]
 802e58e:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 802e592:	60fb      	str	r3, [r7, #12]
      htim->Instance->SMCR = tmpsmcr;
 802e594:	687b      	ldr	r3, [r7, #4]
 802e596:	681b      	ldr	r3, [r3, #0]
 802e598:	68fa      	ldr	r2, [r7, #12]
 802e59a:	609a      	str	r2, [r3, #8]
      break;
 802e59c:	e04c      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
 802e59e:	687b      	ldr	r3, [r7, #4]
 802e5a0:	6818      	ldr	r0, [r3, #0]
 802e5a2:	683b      	ldr	r3, [r7, #0]
 802e5a4:	6899      	ldr	r1, [r3, #8]
 802e5a6:	683b      	ldr	r3, [r7, #0]
 802e5a8:	685a      	ldr	r2, [r3, #4]
 802e5aa:	683b      	ldr	r3, [r7, #0]
 802e5ac:	68db      	ldr	r3, [r3, #12]
 802e5ae:	f000 fad7 	bl	802eb60 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 802e5b2:	687b      	ldr	r3, [r7, #4]
 802e5b4:	681b      	ldr	r3, [r3, #0]
 802e5b6:	689a      	ldr	r2, [r3, #8]
 802e5b8:	687b      	ldr	r3, [r7, #4]
 802e5ba:	681b      	ldr	r3, [r3, #0]
 802e5bc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 802e5c0:	609a      	str	r2, [r3, #8]
      break;
 802e5c2:	e039      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
 802e5c4:	687b      	ldr	r3, [r7, #4]
 802e5c6:	6818      	ldr	r0, [r3, #0]
 802e5c8:	683b      	ldr	r3, [r7, #0]
 802e5ca:	6859      	ldr	r1, [r3, #4]
 802e5cc:	683b      	ldr	r3, [r7, #0]
 802e5ce:	68db      	ldr	r3, [r3, #12]
 802e5d0:	461a      	mov	r2, r3
 802e5d2:	f000 fa4b 	bl	802ea6c <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 802e5d6:	687b      	ldr	r3, [r7, #4]
 802e5d8:	681b      	ldr	r3, [r3, #0]
 802e5da:	2150      	movs	r1, #80	; 0x50
 802e5dc:	4618      	mov	r0, r3
 802e5de:	f000 faa4 	bl	802eb2a <TIM_ITRx_SetConfig>
      break;
 802e5e2:	e029      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI2_ConfigInputStage(htim->Instance,
 802e5e4:	687b      	ldr	r3, [r7, #4]
 802e5e6:	6818      	ldr	r0, [r3, #0]
 802e5e8:	683b      	ldr	r3, [r7, #0]
 802e5ea:	6859      	ldr	r1, [r3, #4]
 802e5ec:	683b      	ldr	r3, [r7, #0]
 802e5ee:	68db      	ldr	r3, [r3, #12]
 802e5f0:	461a      	mov	r2, r3
 802e5f2:	f000 fa6a 	bl	802eaca <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 802e5f6:	687b      	ldr	r3, [r7, #4]
 802e5f8:	681b      	ldr	r3, [r3, #0]
 802e5fa:	2160      	movs	r1, #96	; 0x60
 802e5fc:	4618      	mov	r0, r3
 802e5fe:	f000 fa94 	bl	802eb2a <TIM_ITRx_SetConfig>
      break;
 802e602:	e019      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
 802e604:	687b      	ldr	r3, [r7, #4]
 802e606:	6818      	ldr	r0, [r3, #0]
 802e608:	683b      	ldr	r3, [r7, #0]
 802e60a:	6859      	ldr	r1, [r3, #4]
 802e60c:	683b      	ldr	r3, [r7, #0]
 802e60e:	68db      	ldr	r3, [r3, #12]
 802e610:	461a      	mov	r2, r3
 802e612:	f000 fa2b 	bl	802ea6c <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 802e616:	687b      	ldr	r3, [r7, #4]
 802e618:	681b      	ldr	r3, [r3, #0]
 802e61a:	2140      	movs	r1, #64	; 0x40
 802e61c:	4618      	mov	r0, r3
 802e61e:	f000 fa84 	bl	802eb2a <TIM_ITRx_SetConfig>
      break;
 802e622:	e009      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 802e624:	687b      	ldr	r3, [r7, #4]
 802e626:	681a      	ldr	r2, [r3, #0]
 802e628:	683b      	ldr	r3, [r7, #0]
 802e62a:	681b      	ldr	r3, [r3, #0]
 802e62c:	4619      	mov	r1, r3
 802e62e:	4610      	mov	r0, r2
 802e630:	f000 fa7b 	bl	802eb2a <TIM_ITRx_SetConfig>
      break;
 802e634:	e000      	b.n	802e638 <HAL_TIM_ConfigClockSource+0x154>
      break;
 802e636:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 802e638:	687b      	ldr	r3, [r7, #4]
 802e63a:	2201      	movs	r2, #1
 802e63c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 802e640:	687b      	ldr	r3, [r7, #4]
 802e642:	2200      	movs	r2, #0
 802e644:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 802e648:	2300      	movs	r3, #0
}
 802e64a:	4618      	mov	r0, r3
 802e64c:	3710      	adds	r7, #16
 802e64e:	46bd      	mov	sp, r7
 802e650:	bd80      	pop	{r7, pc}
	...

0802e654 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 802e654:	b480      	push	{r7}
 802e656:	b085      	sub	sp, #20
 802e658:	af00      	add	r7, sp, #0
 802e65a:	6078      	str	r0, [r7, #4]
 802e65c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 802e65e:	687b      	ldr	r3, [r7, #4]
 802e660:	681b      	ldr	r3, [r3, #0]
 802e662:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 802e664:	687b      	ldr	r3, [r7, #4]
 802e666:	4a34      	ldr	r2, [pc, #208]	; (802e738 <TIM_Base_SetConfig+0xe4>)
 802e668:	4293      	cmp	r3, r2
 802e66a:	d00f      	beq.n	802e68c <TIM_Base_SetConfig+0x38>
 802e66c:	687b      	ldr	r3, [r7, #4]
 802e66e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802e672:	d00b      	beq.n	802e68c <TIM_Base_SetConfig+0x38>
 802e674:	687b      	ldr	r3, [r7, #4]
 802e676:	4a31      	ldr	r2, [pc, #196]	; (802e73c <TIM_Base_SetConfig+0xe8>)
 802e678:	4293      	cmp	r3, r2
 802e67a:	d007      	beq.n	802e68c <TIM_Base_SetConfig+0x38>
 802e67c:	687b      	ldr	r3, [r7, #4]
 802e67e:	4a30      	ldr	r2, [pc, #192]	; (802e740 <TIM_Base_SetConfig+0xec>)
 802e680:	4293      	cmp	r3, r2
 802e682:	d003      	beq.n	802e68c <TIM_Base_SetConfig+0x38>
 802e684:	687b      	ldr	r3, [r7, #4]
 802e686:	4a2f      	ldr	r2, [pc, #188]	; (802e744 <TIM_Base_SetConfig+0xf0>)
 802e688:	4293      	cmp	r3, r2
 802e68a:	d108      	bne.n	802e69e <TIM_Base_SetConfig+0x4a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 802e68c:	68fb      	ldr	r3, [r7, #12]
 802e68e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802e692:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 802e694:	683b      	ldr	r3, [r7, #0]
 802e696:	685b      	ldr	r3, [r3, #4]
 802e698:	68fa      	ldr	r2, [r7, #12]
 802e69a:	4313      	orrs	r3, r2
 802e69c:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 802e69e:	687b      	ldr	r3, [r7, #4]
 802e6a0:	4a25      	ldr	r2, [pc, #148]	; (802e738 <TIM_Base_SetConfig+0xe4>)
 802e6a2:	4293      	cmp	r3, r2
 802e6a4:	d01b      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6a6:	687b      	ldr	r3, [r7, #4]
 802e6a8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802e6ac:	d017      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6ae:	687b      	ldr	r3, [r7, #4]
 802e6b0:	4a22      	ldr	r2, [pc, #136]	; (802e73c <TIM_Base_SetConfig+0xe8>)
 802e6b2:	4293      	cmp	r3, r2
 802e6b4:	d013      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6b6:	687b      	ldr	r3, [r7, #4]
 802e6b8:	4a21      	ldr	r2, [pc, #132]	; (802e740 <TIM_Base_SetConfig+0xec>)
 802e6ba:	4293      	cmp	r3, r2
 802e6bc:	d00f      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6be:	687b      	ldr	r3, [r7, #4]
 802e6c0:	4a20      	ldr	r2, [pc, #128]	; (802e744 <TIM_Base_SetConfig+0xf0>)
 802e6c2:	4293      	cmp	r3, r2
 802e6c4:	d00b      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6c6:	687b      	ldr	r3, [r7, #4]
 802e6c8:	4a1f      	ldr	r2, [pc, #124]	; (802e748 <TIM_Base_SetConfig+0xf4>)
 802e6ca:	4293      	cmp	r3, r2
 802e6cc:	d007      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6ce:	687b      	ldr	r3, [r7, #4]
 802e6d0:	4a1e      	ldr	r2, [pc, #120]	; (802e74c <TIM_Base_SetConfig+0xf8>)
 802e6d2:	4293      	cmp	r3, r2
 802e6d4:	d003      	beq.n	802e6de <TIM_Base_SetConfig+0x8a>
 802e6d6:	687b      	ldr	r3, [r7, #4]
 802e6d8:	4a1d      	ldr	r2, [pc, #116]	; (802e750 <TIM_Base_SetConfig+0xfc>)
 802e6da:	4293      	cmp	r3, r2
 802e6dc:	d108      	bne.n	802e6f0 <TIM_Base_SetConfig+0x9c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 802e6de:	68fb      	ldr	r3, [r7, #12]
 802e6e0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802e6e4:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 802e6e6:	683b      	ldr	r3, [r7, #0]
 802e6e8:	68db      	ldr	r3, [r3, #12]
 802e6ea:	68fa      	ldr	r2, [r7, #12]
 802e6ec:	4313      	orrs	r3, r2
 802e6ee:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 802e6f0:	68fb      	ldr	r3, [r7, #12]
 802e6f2:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 802e6f6:	683b      	ldr	r3, [r7, #0]
 802e6f8:	695b      	ldr	r3, [r3, #20]
 802e6fa:	4313      	orrs	r3, r2
 802e6fc:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 802e6fe:	687b      	ldr	r3, [r7, #4]
 802e700:	68fa      	ldr	r2, [r7, #12]
 802e702:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 802e704:	683b      	ldr	r3, [r7, #0]
 802e706:	689a      	ldr	r2, [r3, #8]
 802e708:	687b      	ldr	r3, [r7, #4]
 802e70a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 802e70c:	683b      	ldr	r3, [r7, #0]
 802e70e:	681a      	ldr	r2, [r3, #0]
 802e710:	687b      	ldr	r3, [r7, #4]
 802e712:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 802e714:	687b      	ldr	r3, [r7, #4]
 802e716:	4a08      	ldr	r2, [pc, #32]	; (802e738 <TIM_Base_SetConfig+0xe4>)
 802e718:	4293      	cmp	r3, r2
 802e71a:	d103      	bne.n	802e724 <TIM_Base_SetConfig+0xd0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 802e71c:	683b      	ldr	r3, [r7, #0]
 802e71e:	691a      	ldr	r2, [r3, #16]
 802e720:	687b      	ldr	r3, [r7, #4]
 802e722:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 802e724:	687b      	ldr	r3, [r7, #4]
 802e726:	2201      	movs	r2, #1
 802e728:	615a      	str	r2, [r3, #20]
}
 802e72a:	bf00      	nop
 802e72c:	3714      	adds	r7, #20
 802e72e:	46bd      	mov	sp, r7
 802e730:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e734:	4770      	bx	lr
 802e736:	bf00      	nop
 802e738:	40010000 	.word	0x40010000
 802e73c:	40000400 	.word	0x40000400
 802e740:	40000800 	.word	0x40000800
 802e744:	40000c00 	.word	0x40000c00
 802e748:	40014000 	.word	0x40014000
 802e74c:	40014400 	.word	0x40014400
 802e750:	40014800 	.word	0x40014800

0802e754 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802e754:	b480      	push	{r7}
 802e756:	b087      	sub	sp, #28
 802e758:	af00      	add	r7, sp, #0
 802e75a:	6078      	str	r0, [r7, #4]
 802e75c:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 802e75e:	687b      	ldr	r3, [r7, #4]
 802e760:	6a1b      	ldr	r3, [r3, #32]
 802e762:	f023 0201 	bic.w	r2, r3, #1
 802e766:	687b      	ldr	r3, [r7, #4]
 802e768:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802e76a:	687b      	ldr	r3, [r7, #4]
 802e76c:	6a1b      	ldr	r3, [r3, #32]
 802e76e:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802e770:	687b      	ldr	r3, [r7, #4]
 802e772:	685b      	ldr	r3, [r3, #4]
 802e774:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 802e776:	687b      	ldr	r3, [r7, #4]
 802e778:	699b      	ldr	r3, [r3, #24]
 802e77a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 802e77c:	68fb      	ldr	r3, [r7, #12]
 802e77e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802e782:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 802e784:	68fb      	ldr	r3, [r7, #12]
 802e786:	f023 0303 	bic.w	r3, r3, #3
 802e78a:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 802e78c:	683b      	ldr	r3, [r7, #0]
 802e78e:	681b      	ldr	r3, [r3, #0]
 802e790:	68fa      	ldr	r2, [r7, #12]
 802e792:	4313      	orrs	r3, r2
 802e794:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 802e796:	697b      	ldr	r3, [r7, #20]
 802e798:	f023 0302 	bic.w	r3, r3, #2
 802e79c:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 802e79e:	683b      	ldr	r3, [r7, #0]
 802e7a0:	689b      	ldr	r3, [r3, #8]
 802e7a2:	697a      	ldr	r2, [r7, #20]
 802e7a4:	4313      	orrs	r3, r2
 802e7a6:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 802e7a8:	687b      	ldr	r3, [r7, #4]
 802e7aa:	4a1c      	ldr	r2, [pc, #112]	; (802e81c <TIM_OC1_SetConfig+0xc8>)
 802e7ac:	4293      	cmp	r3, r2
 802e7ae:	d10c      	bne.n	802e7ca <TIM_OC1_SetConfig+0x76>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 802e7b0:	697b      	ldr	r3, [r7, #20]
 802e7b2:	f023 0308 	bic.w	r3, r3, #8
 802e7b6:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 802e7b8:	683b      	ldr	r3, [r7, #0]
 802e7ba:	68db      	ldr	r3, [r3, #12]
 802e7bc:	697a      	ldr	r2, [r7, #20]
 802e7be:	4313      	orrs	r3, r2
 802e7c0:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 802e7c2:	697b      	ldr	r3, [r7, #20]
 802e7c4:	f023 0304 	bic.w	r3, r3, #4
 802e7c8:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802e7ca:	687b      	ldr	r3, [r7, #4]
 802e7cc:	4a13      	ldr	r2, [pc, #76]	; (802e81c <TIM_OC1_SetConfig+0xc8>)
 802e7ce:	4293      	cmp	r3, r2
 802e7d0:	d111      	bne.n	802e7f6 <TIM_OC1_SetConfig+0xa2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 802e7d2:	693b      	ldr	r3, [r7, #16]
 802e7d4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802e7d8:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 802e7da:	693b      	ldr	r3, [r7, #16]
 802e7dc:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 802e7e0:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 802e7e2:	683b      	ldr	r3, [r7, #0]
 802e7e4:	695b      	ldr	r3, [r3, #20]
 802e7e6:	693a      	ldr	r2, [r7, #16]
 802e7e8:	4313      	orrs	r3, r2
 802e7ea:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 802e7ec:	683b      	ldr	r3, [r7, #0]
 802e7ee:	699b      	ldr	r3, [r3, #24]
 802e7f0:	693a      	ldr	r2, [r7, #16]
 802e7f2:	4313      	orrs	r3, r2
 802e7f4:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802e7f6:	687b      	ldr	r3, [r7, #4]
 802e7f8:	693a      	ldr	r2, [r7, #16]
 802e7fa:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 802e7fc:	687b      	ldr	r3, [r7, #4]
 802e7fe:	68fa      	ldr	r2, [r7, #12]
 802e800:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 802e802:	683b      	ldr	r3, [r7, #0]
 802e804:	685a      	ldr	r2, [r3, #4]
 802e806:	687b      	ldr	r3, [r7, #4]
 802e808:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802e80a:	687b      	ldr	r3, [r7, #4]
 802e80c:	697a      	ldr	r2, [r7, #20]
 802e80e:	621a      	str	r2, [r3, #32]
}
 802e810:	bf00      	nop
 802e812:	371c      	adds	r7, #28
 802e814:	46bd      	mov	sp, r7
 802e816:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e81a:	4770      	bx	lr
 802e81c:	40010000 	.word	0x40010000

0802e820 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802e820:	b480      	push	{r7}
 802e822:	b087      	sub	sp, #28
 802e824:	af00      	add	r7, sp, #0
 802e826:	6078      	str	r0, [r7, #4]
 802e828:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 802e82a:	687b      	ldr	r3, [r7, #4]
 802e82c:	6a1b      	ldr	r3, [r3, #32]
 802e82e:	f023 0210 	bic.w	r2, r3, #16
 802e832:	687b      	ldr	r3, [r7, #4]
 802e834:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802e836:	687b      	ldr	r3, [r7, #4]
 802e838:	6a1b      	ldr	r3, [r3, #32]
 802e83a:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802e83c:	687b      	ldr	r3, [r7, #4]
 802e83e:	685b      	ldr	r3, [r3, #4]
 802e840:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 802e842:	687b      	ldr	r3, [r7, #4]
 802e844:	699b      	ldr	r3, [r3, #24]
 802e846:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 802e848:	68fb      	ldr	r3, [r7, #12]
 802e84a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 802e84e:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 802e850:	68fb      	ldr	r3, [r7, #12]
 802e852:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802e856:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 802e858:	683b      	ldr	r3, [r7, #0]
 802e85a:	681b      	ldr	r3, [r3, #0]
 802e85c:	021b      	lsls	r3, r3, #8
 802e85e:	68fa      	ldr	r2, [r7, #12]
 802e860:	4313      	orrs	r3, r2
 802e862:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 802e864:	697b      	ldr	r3, [r7, #20]
 802e866:	f023 0320 	bic.w	r3, r3, #32
 802e86a:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 802e86c:	683b      	ldr	r3, [r7, #0]
 802e86e:	689b      	ldr	r3, [r3, #8]
 802e870:	011b      	lsls	r3, r3, #4
 802e872:	697a      	ldr	r2, [r7, #20]
 802e874:	4313      	orrs	r3, r2
 802e876:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 802e878:	687b      	ldr	r3, [r7, #4]
 802e87a:	4a1e      	ldr	r2, [pc, #120]	; (802e8f4 <TIM_OC2_SetConfig+0xd4>)
 802e87c:	4293      	cmp	r3, r2
 802e87e:	d10d      	bne.n	802e89c <TIM_OC2_SetConfig+0x7c>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 802e880:	697b      	ldr	r3, [r7, #20]
 802e882:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802e886:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 802e888:	683b      	ldr	r3, [r7, #0]
 802e88a:	68db      	ldr	r3, [r3, #12]
 802e88c:	011b      	lsls	r3, r3, #4
 802e88e:	697a      	ldr	r2, [r7, #20]
 802e890:	4313      	orrs	r3, r2
 802e892:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 802e894:	697b      	ldr	r3, [r7, #20]
 802e896:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802e89a:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802e89c:	687b      	ldr	r3, [r7, #4]
 802e89e:	4a15      	ldr	r2, [pc, #84]	; (802e8f4 <TIM_OC2_SetConfig+0xd4>)
 802e8a0:	4293      	cmp	r3, r2
 802e8a2:	d113      	bne.n	802e8cc <TIM_OC2_SetConfig+0xac>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 802e8a4:	693b      	ldr	r3, [r7, #16]
 802e8a6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802e8aa:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 802e8ac:	693b      	ldr	r3, [r7, #16]
 802e8ae:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 802e8b2:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 802e8b4:	683b      	ldr	r3, [r7, #0]
 802e8b6:	695b      	ldr	r3, [r3, #20]
 802e8b8:	009b      	lsls	r3, r3, #2
 802e8ba:	693a      	ldr	r2, [r7, #16]
 802e8bc:	4313      	orrs	r3, r2
 802e8be:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 802e8c0:	683b      	ldr	r3, [r7, #0]
 802e8c2:	699b      	ldr	r3, [r3, #24]
 802e8c4:	009b      	lsls	r3, r3, #2
 802e8c6:	693a      	ldr	r2, [r7, #16]
 802e8c8:	4313      	orrs	r3, r2
 802e8ca:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802e8cc:	687b      	ldr	r3, [r7, #4]
 802e8ce:	693a      	ldr	r2, [r7, #16]
 802e8d0:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 802e8d2:	687b      	ldr	r3, [r7, #4]
 802e8d4:	68fa      	ldr	r2, [r7, #12]
 802e8d6:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 802e8d8:	683b      	ldr	r3, [r7, #0]
 802e8da:	685a      	ldr	r2, [r3, #4]
 802e8dc:	687b      	ldr	r3, [r7, #4]
 802e8de:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802e8e0:	687b      	ldr	r3, [r7, #4]
 802e8e2:	697a      	ldr	r2, [r7, #20]
 802e8e4:	621a      	str	r2, [r3, #32]
}
 802e8e6:	bf00      	nop
 802e8e8:	371c      	adds	r7, #28
 802e8ea:	46bd      	mov	sp, r7
 802e8ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e8f0:	4770      	bx	lr
 802e8f2:	bf00      	nop
 802e8f4:	40010000 	.word	0x40010000

0802e8f8 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802e8f8:	b480      	push	{r7}
 802e8fa:	b087      	sub	sp, #28
 802e8fc:	af00      	add	r7, sp, #0
 802e8fe:	6078      	str	r0, [r7, #4]
 802e900:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 802e902:	687b      	ldr	r3, [r7, #4]
 802e904:	6a1b      	ldr	r3, [r3, #32]
 802e906:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 802e90a:	687b      	ldr	r3, [r7, #4]
 802e90c:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802e90e:	687b      	ldr	r3, [r7, #4]
 802e910:	6a1b      	ldr	r3, [r3, #32]
 802e912:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802e914:	687b      	ldr	r3, [r7, #4]
 802e916:	685b      	ldr	r3, [r3, #4]
 802e918:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 802e91a:	687b      	ldr	r3, [r7, #4]
 802e91c:	69db      	ldr	r3, [r3, #28]
 802e91e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 802e920:	68fb      	ldr	r3, [r7, #12]
 802e922:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802e926:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 802e928:	68fb      	ldr	r3, [r7, #12]
 802e92a:	f023 0303 	bic.w	r3, r3, #3
 802e92e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 802e930:	683b      	ldr	r3, [r7, #0]
 802e932:	681b      	ldr	r3, [r3, #0]
 802e934:	68fa      	ldr	r2, [r7, #12]
 802e936:	4313      	orrs	r3, r2
 802e938:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 802e93a:	697b      	ldr	r3, [r7, #20]
 802e93c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 802e940:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 802e942:	683b      	ldr	r3, [r7, #0]
 802e944:	689b      	ldr	r3, [r3, #8]
 802e946:	021b      	lsls	r3, r3, #8
 802e948:	697a      	ldr	r2, [r7, #20]
 802e94a:	4313      	orrs	r3, r2
 802e94c:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 802e94e:	687b      	ldr	r3, [r7, #4]
 802e950:	4a1d      	ldr	r2, [pc, #116]	; (802e9c8 <TIM_OC3_SetConfig+0xd0>)
 802e952:	4293      	cmp	r3, r2
 802e954:	d10d      	bne.n	802e972 <TIM_OC3_SetConfig+0x7a>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 802e956:	697b      	ldr	r3, [r7, #20]
 802e958:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 802e95c:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 802e95e:	683b      	ldr	r3, [r7, #0]
 802e960:	68db      	ldr	r3, [r3, #12]
 802e962:	021b      	lsls	r3, r3, #8
 802e964:	697a      	ldr	r2, [r7, #20]
 802e966:	4313      	orrs	r3, r2
 802e968:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 802e96a:	697b      	ldr	r3, [r7, #20]
 802e96c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802e970:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802e972:	687b      	ldr	r3, [r7, #4]
 802e974:	4a14      	ldr	r2, [pc, #80]	; (802e9c8 <TIM_OC3_SetConfig+0xd0>)
 802e976:	4293      	cmp	r3, r2
 802e978:	d113      	bne.n	802e9a2 <TIM_OC3_SetConfig+0xaa>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 802e97a:	693b      	ldr	r3, [r7, #16]
 802e97c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802e980:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 802e982:	693b      	ldr	r3, [r7, #16]
 802e984:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802e988:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 802e98a:	683b      	ldr	r3, [r7, #0]
 802e98c:	695b      	ldr	r3, [r3, #20]
 802e98e:	011b      	lsls	r3, r3, #4
 802e990:	693a      	ldr	r2, [r7, #16]
 802e992:	4313      	orrs	r3, r2
 802e994:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 802e996:	683b      	ldr	r3, [r7, #0]
 802e998:	699b      	ldr	r3, [r3, #24]
 802e99a:	011b      	lsls	r3, r3, #4
 802e99c:	693a      	ldr	r2, [r7, #16]
 802e99e:	4313      	orrs	r3, r2
 802e9a0:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802e9a2:	687b      	ldr	r3, [r7, #4]
 802e9a4:	693a      	ldr	r2, [r7, #16]
 802e9a6:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 802e9a8:	687b      	ldr	r3, [r7, #4]
 802e9aa:	68fa      	ldr	r2, [r7, #12]
 802e9ac:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 802e9ae:	683b      	ldr	r3, [r7, #0]
 802e9b0:	685a      	ldr	r2, [r3, #4]
 802e9b2:	687b      	ldr	r3, [r7, #4]
 802e9b4:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802e9b6:	687b      	ldr	r3, [r7, #4]
 802e9b8:	697a      	ldr	r2, [r7, #20]
 802e9ba:	621a      	str	r2, [r3, #32]
}
 802e9bc:	bf00      	nop
 802e9be:	371c      	adds	r7, #28
 802e9c0:	46bd      	mov	sp, r7
 802e9c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e9c6:	4770      	bx	lr
 802e9c8:	40010000 	.word	0x40010000

0802e9cc <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802e9cc:	b480      	push	{r7}
 802e9ce:	b087      	sub	sp, #28
 802e9d0:	af00      	add	r7, sp, #0
 802e9d2:	6078      	str	r0, [r7, #4]
 802e9d4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 802e9d6:	687b      	ldr	r3, [r7, #4]
 802e9d8:	6a1b      	ldr	r3, [r3, #32]
 802e9da:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 802e9de:	687b      	ldr	r3, [r7, #4]
 802e9e0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802e9e2:	687b      	ldr	r3, [r7, #4]
 802e9e4:	6a1b      	ldr	r3, [r3, #32]
 802e9e6:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802e9e8:	687b      	ldr	r3, [r7, #4]
 802e9ea:	685b      	ldr	r3, [r3, #4]
 802e9ec:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 802e9ee:	687b      	ldr	r3, [r7, #4]
 802e9f0:	69db      	ldr	r3, [r3, #28]
 802e9f2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 802e9f4:	68fb      	ldr	r3, [r7, #12]
 802e9f6:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 802e9fa:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 802e9fc:	68fb      	ldr	r3, [r7, #12]
 802e9fe:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802ea02:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 802ea04:	683b      	ldr	r3, [r7, #0]
 802ea06:	681b      	ldr	r3, [r3, #0]
 802ea08:	021b      	lsls	r3, r3, #8
 802ea0a:	68fa      	ldr	r2, [r7, #12]
 802ea0c:	4313      	orrs	r3, r2
 802ea0e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 802ea10:	693b      	ldr	r3, [r7, #16]
 802ea12:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802ea16:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 802ea18:	683b      	ldr	r3, [r7, #0]
 802ea1a:	689b      	ldr	r3, [r3, #8]
 802ea1c:	031b      	lsls	r3, r3, #12
 802ea1e:	693a      	ldr	r2, [r7, #16]
 802ea20:	4313      	orrs	r3, r2
 802ea22:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802ea24:	687b      	ldr	r3, [r7, #4]
 802ea26:	4a10      	ldr	r2, [pc, #64]	; (802ea68 <TIM_OC4_SetConfig+0x9c>)
 802ea28:	4293      	cmp	r3, r2
 802ea2a:	d109      	bne.n	802ea40 <TIM_OC4_SetConfig+0x74>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 802ea2c:	697b      	ldr	r3, [r7, #20]
 802ea2e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 802ea32:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 802ea34:	683b      	ldr	r3, [r7, #0]
 802ea36:	695b      	ldr	r3, [r3, #20]
 802ea38:	019b      	lsls	r3, r3, #6
 802ea3a:	697a      	ldr	r2, [r7, #20]
 802ea3c:	4313      	orrs	r3, r2
 802ea3e:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802ea40:	687b      	ldr	r3, [r7, #4]
 802ea42:	697a      	ldr	r2, [r7, #20]
 802ea44:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 802ea46:	687b      	ldr	r3, [r7, #4]
 802ea48:	68fa      	ldr	r2, [r7, #12]
 802ea4a:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 802ea4c:	683b      	ldr	r3, [r7, #0]
 802ea4e:	685a      	ldr	r2, [r3, #4]
 802ea50:	687b      	ldr	r3, [r7, #4]
 802ea52:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802ea54:	687b      	ldr	r3, [r7, #4]
 802ea56:	693a      	ldr	r2, [r7, #16]
 802ea58:	621a      	str	r2, [r3, #32]
}
 802ea5a:	bf00      	nop
 802ea5c:	371c      	adds	r7, #28
 802ea5e:	46bd      	mov	sp, r7
 802ea60:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ea64:	4770      	bx	lr
 802ea66:	bf00      	nop
 802ea68:	40010000 	.word	0x40010000

0802ea6c <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 802ea6c:	b480      	push	{r7}
 802ea6e:	b087      	sub	sp, #28
 802ea70:	af00      	add	r7, sp, #0
 802ea72:	60f8      	str	r0, [r7, #12]
 802ea74:	60b9      	str	r1, [r7, #8]
 802ea76:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 802ea78:	68fb      	ldr	r3, [r7, #12]
 802ea7a:	6a1b      	ldr	r3, [r3, #32]
 802ea7c:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 802ea7e:	68fb      	ldr	r3, [r7, #12]
 802ea80:	6a1b      	ldr	r3, [r3, #32]
 802ea82:	f023 0201 	bic.w	r2, r3, #1
 802ea86:	68fb      	ldr	r3, [r7, #12]
 802ea88:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 802ea8a:	68fb      	ldr	r3, [r7, #12]
 802ea8c:	699b      	ldr	r3, [r3, #24]
 802ea8e:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 802ea90:	693b      	ldr	r3, [r7, #16]
 802ea92:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802ea96:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 802ea98:	687b      	ldr	r3, [r7, #4]
 802ea9a:	011b      	lsls	r3, r3, #4
 802ea9c:	693a      	ldr	r2, [r7, #16]
 802ea9e:	4313      	orrs	r3, r2
 802eaa0:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 802eaa2:	697b      	ldr	r3, [r7, #20]
 802eaa4:	f023 030a 	bic.w	r3, r3, #10
 802eaa8:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 802eaaa:	697a      	ldr	r2, [r7, #20]
 802eaac:	68bb      	ldr	r3, [r7, #8]
 802eaae:	4313      	orrs	r3, r2
 802eab0:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 802eab2:	68fb      	ldr	r3, [r7, #12]
 802eab4:	693a      	ldr	r2, [r7, #16]
 802eab6:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 802eab8:	68fb      	ldr	r3, [r7, #12]
 802eaba:	697a      	ldr	r2, [r7, #20]
 802eabc:	621a      	str	r2, [r3, #32]
}
 802eabe:	bf00      	nop
 802eac0:	371c      	adds	r7, #28
 802eac2:	46bd      	mov	sp, r7
 802eac4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802eac8:	4770      	bx	lr

0802eaca <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 802eaca:	b480      	push	{r7}
 802eacc:	b087      	sub	sp, #28
 802eace:	af00      	add	r7, sp, #0
 802ead0:	60f8      	str	r0, [r7, #12]
 802ead2:	60b9      	str	r1, [r7, #8]
 802ead4:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 802ead6:	68fb      	ldr	r3, [r7, #12]
 802ead8:	6a1b      	ldr	r3, [r3, #32]
 802eada:	f023 0210 	bic.w	r2, r3, #16
 802eade:	68fb      	ldr	r3, [r7, #12]
 802eae0:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 802eae2:	68fb      	ldr	r3, [r7, #12]
 802eae4:	699b      	ldr	r3, [r3, #24]
 802eae6:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 802eae8:	68fb      	ldr	r3, [r7, #12]
 802eaea:	6a1b      	ldr	r3, [r3, #32]
 802eaec:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 802eaee:	697b      	ldr	r3, [r7, #20]
 802eaf0:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 802eaf4:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 802eaf6:	687b      	ldr	r3, [r7, #4]
 802eaf8:	031b      	lsls	r3, r3, #12
 802eafa:	697a      	ldr	r2, [r7, #20]
 802eafc:	4313      	orrs	r3, r2
 802eafe:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 802eb00:	693b      	ldr	r3, [r7, #16]
 802eb02:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 802eb06:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 802eb08:	68bb      	ldr	r3, [r7, #8]
 802eb0a:	011b      	lsls	r3, r3, #4
 802eb0c:	693a      	ldr	r2, [r7, #16]
 802eb0e:	4313      	orrs	r3, r2
 802eb10:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 802eb12:	68fb      	ldr	r3, [r7, #12]
 802eb14:	697a      	ldr	r2, [r7, #20]
 802eb16:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 802eb18:	68fb      	ldr	r3, [r7, #12]
 802eb1a:	693a      	ldr	r2, [r7, #16]
 802eb1c:	621a      	str	r2, [r3, #32]
}
 802eb1e:	bf00      	nop
 802eb20:	371c      	adds	r7, #28
 802eb22:	46bd      	mov	sp, r7
 802eb24:	f85d 7b04 	ldr.w	r7, [sp], #4
 802eb28:	4770      	bx	lr

0802eb2a <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 802eb2a:	b480      	push	{r7}
 802eb2c:	b085      	sub	sp, #20
 802eb2e:	af00      	add	r7, sp, #0
 802eb30:	6078      	str	r0, [r7, #4]
 802eb32:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 802eb34:	687b      	ldr	r3, [r7, #4]
 802eb36:	689b      	ldr	r3, [r3, #8]
 802eb38:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 802eb3a:	68fb      	ldr	r3, [r7, #12]
 802eb3c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802eb40:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 802eb42:	683a      	ldr	r2, [r7, #0]
 802eb44:	68fb      	ldr	r3, [r7, #12]
 802eb46:	4313      	orrs	r3, r2
 802eb48:	f043 0307 	orr.w	r3, r3, #7
 802eb4c:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 802eb4e:	687b      	ldr	r3, [r7, #4]
 802eb50:	68fa      	ldr	r2, [r7, #12]
 802eb52:	609a      	str	r2, [r3, #8]
}
 802eb54:	bf00      	nop
 802eb56:	3714      	adds	r7, #20
 802eb58:	46bd      	mov	sp, r7
 802eb5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802eb5e:	4770      	bx	lr

0802eb60 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 802eb60:	b480      	push	{r7}
 802eb62:	b087      	sub	sp, #28
 802eb64:	af00      	add	r7, sp, #0
 802eb66:	60f8      	str	r0, [r7, #12]
 802eb68:	60b9      	str	r1, [r7, #8]
 802eb6a:	607a      	str	r2, [r7, #4]
 802eb6c:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 802eb6e:	68fb      	ldr	r3, [r7, #12]
 802eb70:	689b      	ldr	r3, [r3, #8]
 802eb72:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 802eb74:	697b      	ldr	r3, [r7, #20]
 802eb76:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802eb7a:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 802eb7c:	683b      	ldr	r3, [r7, #0]
 802eb7e:	021a      	lsls	r2, r3, #8
 802eb80:	687b      	ldr	r3, [r7, #4]
 802eb82:	431a      	orrs	r2, r3
 802eb84:	68bb      	ldr	r3, [r7, #8]
 802eb86:	4313      	orrs	r3, r2
 802eb88:	697a      	ldr	r2, [r7, #20]
 802eb8a:	4313      	orrs	r3, r2
 802eb8c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 802eb8e:	68fb      	ldr	r3, [r7, #12]
 802eb90:	697a      	ldr	r2, [r7, #20]
 802eb92:	609a      	str	r2, [r3, #8]
}
 802eb94:	bf00      	nop
 802eb96:	371c      	adds	r7, #28
 802eb98:	46bd      	mov	sp, r7
 802eb9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802eb9e:	4770      	bx	lr

0802eba0 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 802eba0:	b480      	push	{r7}
 802eba2:	b087      	sub	sp, #28
 802eba4:	af00      	add	r7, sp, #0
 802eba6:	60f8      	str	r0, [r7, #12]
 802eba8:	60b9      	str	r1, [r7, #8]
 802ebaa:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 802ebac:	68bb      	ldr	r3, [r7, #8]
 802ebae:	f003 031f 	and.w	r3, r3, #31
 802ebb2:	2201      	movs	r2, #1
 802ebb4:	fa02 f303 	lsl.w	r3, r2, r3
 802ebb8:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 802ebba:	68fb      	ldr	r3, [r7, #12]
 802ebbc:	6a1a      	ldr	r2, [r3, #32]
 802ebbe:	697b      	ldr	r3, [r7, #20]
 802ebc0:	43db      	mvns	r3, r3
 802ebc2:	401a      	ands	r2, r3
 802ebc4:	68fb      	ldr	r3, [r7, #12]
 802ebc6:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 802ebc8:	68fb      	ldr	r3, [r7, #12]
 802ebca:	6a1a      	ldr	r2, [r3, #32]
 802ebcc:	68bb      	ldr	r3, [r7, #8]
 802ebce:	f003 031f 	and.w	r3, r3, #31
 802ebd2:	6879      	ldr	r1, [r7, #4]
 802ebd4:	fa01 f303 	lsl.w	r3, r1, r3
 802ebd8:	431a      	orrs	r2, r3
 802ebda:	68fb      	ldr	r3, [r7, #12]
 802ebdc:	621a      	str	r2, [r3, #32]
}
 802ebde:	bf00      	nop
 802ebe0:	371c      	adds	r7, #28
 802ebe2:	46bd      	mov	sp, r7
 802ebe4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ebe8:	4770      	bx	lr
	...

0802ebec <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 802ebec:	b480      	push	{r7}
 802ebee:	b085      	sub	sp, #20
 802ebf0:	af00      	add	r7, sp, #0
 802ebf2:	6078      	str	r0, [r7, #4]
 802ebf4:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 802ebf6:	687b      	ldr	r3, [r7, #4]
 802ebf8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 802ebfc:	2b01      	cmp	r3, #1
 802ebfe:	d101      	bne.n	802ec04 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 802ec00:	2302      	movs	r3, #2
 802ec02:	e050      	b.n	802eca6 <HAL_TIMEx_MasterConfigSynchronization+0xba>
 802ec04:	687b      	ldr	r3, [r7, #4]
 802ec06:	2201      	movs	r2, #1
 802ec08:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 802ec0c:	687b      	ldr	r3, [r7, #4]
 802ec0e:	2202      	movs	r2, #2
 802ec10:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 802ec14:	687b      	ldr	r3, [r7, #4]
 802ec16:	681b      	ldr	r3, [r3, #0]
 802ec18:	685b      	ldr	r3, [r3, #4]
 802ec1a:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 802ec1c:	687b      	ldr	r3, [r7, #4]
 802ec1e:	681b      	ldr	r3, [r3, #0]
 802ec20:	689b      	ldr	r3, [r3, #8]
 802ec22:	60bb      	str	r3, [r7, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 802ec24:	68fb      	ldr	r3, [r7, #12]
 802ec26:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802ec2a:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 802ec2c:	683b      	ldr	r3, [r7, #0]
 802ec2e:	681b      	ldr	r3, [r3, #0]
 802ec30:	68fa      	ldr	r2, [r7, #12]
 802ec32:	4313      	orrs	r3, r2
 802ec34:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 802ec36:	687b      	ldr	r3, [r7, #4]
 802ec38:	681b      	ldr	r3, [r3, #0]
 802ec3a:	68fa      	ldr	r2, [r7, #12]
 802ec3c:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 802ec3e:	687b      	ldr	r3, [r7, #4]
 802ec40:	681b      	ldr	r3, [r3, #0]
 802ec42:	4a1c      	ldr	r2, [pc, #112]	; (802ecb4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>)
 802ec44:	4293      	cmp	r3, r2
 802ec46:	d018      	beq.n	802ec7a <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802ec48:	687b      	ldr	r3, [r7, #4]
 802ec4a:	681b      	ldr	r3, [r3, #0]
 802ec4c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802ec50:	d013      	beq.n	802ec7a <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802ec52:	687b      	ldr	r3, [r7, #4]
 802ec54:	681b      	ldr	r3, [r3, #0]
 802ec56:	4a18      	ldr	r2, [pc, #96]	; (802ecb8 <HAL_TIMEx_MasterConfigSynchronization+0xcc>)
 802ec58:	4293      	cmp	r3, r2
 802ec5a:	d00e      	beq.n	802ec7a <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802ec5c:	687b      	ldr	r3, [r7, #4]
 802ec5e:	681b      	ldr	r3, [r3, #0]
 802ec60:	4a16      	ldr	r2, [pc, #88]	; (802ecbc <HAL_TIMEx_MasterConfigSynchronization+0xd0>)
 802ec62:	4293      	cmp	r3, r2
 802ec64:	d009      	beq.n	802ec7a <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802ec66:	687b      	ldr	r3, [r7, #4]
 802ec68:	681b      	ldr	r3, [r3, #0]
 802ec6a:	4a15      	ldr	r2, [pc, #84]	; (802ecc0 <HAL_TIMEx_MasterConfigSynchronization+0xd4>)
 802ec6c:	4293      	cmp	r3, r2
 802ec6e:	d004      	beq.n	802ec7a <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802ec70:	687b      	ldr	r3, [r7, #4]
 802ec72:	681b      	ldr	r3, [r3, #0]
 802ec74:	4a13      	ldr	r2, [pc, #76]	; (802ecc4 <HAL_TIMEx_MasterConfigSynchronization+0xd8>)
 802ec76:	4293      	cmp	r3, r2
 802ec78:	d10c      	bne.n	802ec94 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 802ec7a:	68bb      	ldr	r3, [r7, #8]
 802ec7c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802ec80:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 802ec82:	683b      	ldr	r3, [r7, #0]
 802ec84:	685b      	ldr	r3, [r3, #4]
 802ec86:	68ba      	ldr	r2, [r7, #8]
 802ec88:	4313      	orrs	r3, r2
 802ec8a:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 802ec8c:	687b      	ldr	r3, [r7, #4]
 802ec8e:	681b      	ldr	r3, [r3, #0]
 802ec90:	68ba      	ldr	r2, [r7, #8]
 802ec92:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 802ec94:	687b      	ldr	r3, [r7, #4]
 802ec96:	2201      	movs	r2, #1
 802ec98:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 802ec9c:	687b      	ldr	r3, [r7, #4]
 802ec9e:	2200      	movs	r2, #0
 802eca0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 802eca4:	2300      	movs	r3, #0
}
 802eca6:	4618      	mov	r0, r3
 802eca8:	3714      	adds	r7, #20
 802ecaa:	46bd      	mov	sp, r7
 802ecac:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ecb0:	4770      	bx	lr
 802ecb2:	bf00      	nop
 802ecb4:	40010000 	.word	0x40010000
 802ecb8:	40000400 	.word	0x40000400
 802ecbc:	40000800 	.word	0x40000800
 802ecc0:	40000c00 	.word	0x40000c00
 802ecc4:	40014000 	.word	0x40014000

0802ecc8 <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 802ecc8:	b580      	push	{r7, lr}
 802ecca:	b082      	sub	sp, #8
 802eccc:	af00      	add	r7, sp, #0
 802ecce:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 802ecd0:	687b      	ldr	r3, [r7, #4]
 802ecd2:	2b00      	cmp	r3, #0
 802ecd4:	d101      	bne.n	802ecda <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 802ecd6:	2301      	movs	r3, #1
 802ecd8:	e03f      	b.n	802ed5a <HAL_UART_Init+0x92>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if (huart->gState == HAL_UART_STATE_RESET)
 802ecda:	687b      	ldr	r3, [r7, #4]
 802ecdc:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802ece0:	b2db      	uxtb	r3, r3
 802ece2:	2b00      	cmp	r3, #0
 802ece4:	d106      	bne.n	802ecf4 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 802ece6:	687b      	ldr	r3, [r7, #4]
 802ece8:	2200      	movs	r2, #0
 802ecea:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 802ecee:	6878      	ldr	r0, [r7, #4]
 802ecf0:	f7fc fc24 	bl	802b53c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 802ecf4:	687b      	ldr	r3, [r7, #4]
 802ecf6:	2224      	movs	r2, #36	; 0x24
 802ecf8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 802ecfc:	687b      	ldr	r3, [r7, #4]
 802ecfe:	681b      	ldr	r3, [r3, #0]
 802ed00:	68da      	ldr	r2, [r3, #12]
 802ed02:	687b      	ldr	r3, [r7, #4]
 802ed04:	681b      	ldr	r3, [r3, #0]
 802ed06:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 802ed0a:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 802ed0c:	6878      	ldr	r0, [r7, #4]
 802ed0e:	f000 fc21 	bl	802f554 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 802ed12:	687b      	ldr	r3, [r7, #4]
 802ed14:	681b      	ldr	r3, [r3, #0]
 802ed16:	691a      	ldr	r2, [r3, #16]
 802ed18:	687b      	ldr	r3, [r7, #4]
 802ed1a:	681b      	ldr	r3, [r3, #0]
 802ed1c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 802ed20:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 802ed22:	687b      	ldr	r3, [r7, #4]
 802ed24:	681b      	ldr	r3, [r3, #0]
 802ed26:	695a      	ldr	r2, [r3, #20]
 802ed28:	687b      	ldr	r3, [r7, #4]
 802ed2a:	681b      	ldr	r3, [r3, #0]
 802ed2c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 802ed30:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 802ed32:	687b      	ldr	r3, [r7, #4]
 802ed34:	681b      	ldr	r3, [r3, #0]
 802ed36:	68da      	ldr	r2, [r3, #12]
 802ed38:	687b      	ldr	r3, [r7, #4]
 802ed3a:	681b      	ldr	r3, [r3, #0]
 802ed3c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 802ed40:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 802ed42:	687b      	ldr	r3, [r7, #4]
 802ed44:	2200      	movs	r2, #0
 802ed46:	63da      	str	r2, [r3, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 802ed48:	687b      	ldr	r3, [r7, #4]
 802ed4a:	2220      	movs	r2, #32
 802ed4c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 802ed50:	687b      	ldr	r3, [r7, #4]
 802ed52:	2220      	movs	r2, #32
 802ed54:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  return HAL_OK;
 802ed58:	2300      	movs	r3, #0
}
 802ed5a:	4618      	mov	r0, r3
 802ed5c:	3708      	adds	r7, #8
 802ed5e:	46bd      	mov	sp, r7
 802ed60:	bd80      	pop	{r7, pc}
	...

0802ed64 <HAL_UART_Transmit_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 802ed64:	b580      	push	{r7, lr}
 802ed66:	b086      	sub	sp, #24
 802ed68:	af00      	add	r7, sp, #0
 802ed6a:	60f8      	str	r0, [r7, #12]
 802ed6c:	60b9      	str	r1, [r7, #8]
 802ed6e:	4613      	mov	r3, r2
 802ed70:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 802ed72:	68fb      	ldr	r3, [r7, #12]
 802ed74:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802ed78:	b2db      	uxtb	r3, r3
 802ed7a:	2b20      	cmp	r3, #32
 802ed7c:	d153      	bne.n	802ee26 <HAL_UART_Transmit_DMA+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 802ed7e:	68bb      	ldr	r3, [r7, #8]
 802ed80:	2b00      	cmp	r3, #0
 802ed82:	d002      	beq.n	802ed8a <HAL_UART_Transmit_DMA+0x26>
 802ed84:	88fb      	ldrh	r3, [r7, #6]
 802ed86:	2b00      	cmp	r3, #0
 802ed88:	d101      	bne.n	802ed8e <HAL_UART_Transmit_DMA+0x2a>
    {
      return HAL_ERROR;
 802ed8a:	2301      	movs	r3, #1
 802ed8c:	e04c      	b.n	802ee28 <HAL_UART_Transmit_DMA+0xc4>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 802ed8e:	68fb      	ldr	r3, [r7, #12]
 802ed90:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 802ed94:	2b01      	cmp	r3, #1
 802ed96:	d101      	bne.n	802ed9c <HAL_UART_Transmit_DMA+0x38>
 802ed98:	2302      	movs	r3, #2
 802ed9a:	e045      	b.n	802ee28 <HAL_UART_Transmit_DMA+0xc4>
 802ed9c:	68fb      	ldr	r3, [r7, #12]
 802ed9e:	2201      	movs	r2, #1
 802eda0:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    huart->pTxBuffPtr = pData;
 802eda4:	68ba      	ldr	r2, [r7, #8]
 802eda6:	68fb      	ldr	r3, [r7, #12]
 802eda8:	621a      	str	r2, [r3, #32]
    huart->TxXferSize = Size;
 802edaa:	68fb      	ldr	r3, [r7, #12]
 802edac:	88fa      	ldrh	r2, [r7, #6]
 802edae:	849a      	strh	r2, [r3, #36]	; 0x24
    huart->TxXferCount = Size;
 802edb0:	68fb      	ldr	r3, [r7, #12]
 802edb2:	88fa      	ldrh	r2, [r7, #6]
 802edb4:	84da      	strh	r2, [r3, #38]	; 0x26

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802edb6:	68fb      	ldr	r3, [r7, #12]
 802edb8:	2200      	movs	r2, #0
 802edba:	63da      	str	r2, [r3, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802edbc:	68fb      	ldr	r3, [r7, #12]
 802edbe:	2221      	movs	r2, #33	; 0x21
 802edc0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802edc4:	68fb      	ldr	r3, [r7, #12]
 802edc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802edc8:	4a19      	ldr	r2, [pc, #100]	; (802ee30 <HAL_UART_Transmit_DMA+0xcc>)
 802edca:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802edcc:	68fb      	ldr	r3, [r7, #12]
 802edce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802edd0:	4a18      	ldr	r2, [pc, #96]	; (802ee34 <HAL_UART_Transmit_DMA+0xd0>)
 802edd2:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 802edd4:	68fb      	ldr	r3, [r7, #12]
 802edd6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802edd8:	4a17      	ldr	r2, [pc, #92]	; (802ee38 <HAL_UART_Transmit_DMA+0xd4>)
 802edda:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA abort callback */
    huart->hdmatx->XferAbortCallback = NULL;
 802eddc:	68fb      	ldr	r3, [r7, #12]
 802edde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802ede0:	2200      	movs	r2, #0
 802ede2:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the UART transmit DMA stream */
    tmp = (uint32_t *)&pData;
 802ede4:	f107 0308 	add.w	r3, r7, #8
 802ede8:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 802edea:	68fb      	ldr	r3, [r7, #12]
 802edec:	6b18      	ldr	r0, [r3, #48]	; 0x30
 802edee:	697b      	ldr	r3, [r7, #20]
 802edf0:	6819      	ldr	r1, [r3, #0]
 802edf2:	68fb      	ldr	r3, [r7, #12]
 802edf4:	681b      	ldr	r3, [r3, #0]
 802edf6:	3304      	adds	r3, #4
 802edf8:	461a      	mov	r2, r3
 802edfa:	88fb      	ldrh	r3, [r7, #6]
 802edfc:	f7fd fa56 	bl	802c2ac <HAL_DMA_Start_IT>

    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 802ee00:	68fb      	ldr	r3, [r7, #12]
 802ee02:	681b      	ldr	r3, [r3, #0]
 802ee04:	f06f 0240 	mvn.w	r2, #64	; 0x40
 802ee08:	601a      	str	r2, [r3, #0]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 802ee0a:	68fb      	ldr	r3, [r7, #12]
 802ee0c:	2200      	movs	r2, #0
 802ee0e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802ee12:	68fb      	ldr	r3, [r7, #12]
 802ee14:	681b      	ldr	r3, [r3, #0]
 802ee16:	695a      	ldr	r2, [r3, #20]
 802ee18:	68fb      	ldr	r3, [r7, #12]
 802ee1a:	681b      	ldr	r3, [r3, #0]
 802ee1c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802ee20:	615a      	str	r2, [r3, #20]

    return HAL_OK;
 802ee22:	2300      	movs	r3, #0
 802ee24:	e000      	b.n	802ee28 <HAL_UART_Transmit_DMA+0xc4>
  }
  else
  {
    return HAL_BUSY;
 802ee26:	2302      	movs	r3, #2
  }
}
 802ee28:	4618      	mov	r0, r3
 802ee2a:	3718      	adds	r7, #24
 802ee2c:	46bd      	mov	sp, r7
 802ee2e:	bd80      	pop	{r7, pc}
 802ee30:	0802f1e5 	.word	0x0802f1e5
 802ee34:	0802f237 	.word	0x0802f237
 802ee38:	0802f253 	.word	0x0802f253

0802ee3c <HAL_UART_DMAPause>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
{
 802ee3c:	b480      	push	{r7}
 802ee3e:	b085      	sub	sp, #20
 802ee40:	af00      	add	r7, sp, #0
 802ee42:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 802ee44:	2300      	movs	r3, #0
 802ee46:	60fb      	str	r3, [r7, #12]

  /* Process Locked */
  __HAL_LOCK(huart);
 802ee48:	687b      	ldr	r3, [r7, #4]
 802ee4a:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 802ee4e:	2b01      	cmp	r3, #1
 802ee50:	d101      	bne.n	802ee56 <HAL_UART_DMAPause+0x1a>
 802ee52:	2302      	movs	r3, #2
 802ee54:	e050      	b.n	802eef8 <HAL_UART_DMAPause+0xbc>
 802ee56:	687b      	ldr	r3, [r7, #4]
 802ee58:	2201      	movs	r2, #1
 802ee5a:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 802ee5e:	687b      	ldr	r3, [r7, #4]
 802ee60:	681b      	ldr	r3, [r3, #0]
 802ee62:	695b      	ldr	r3, [r3, #20]
 802ee64:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802ee68:	2b80      	cmp	r3, #128	; 0x80
 802ee6a:	bf0c      	ite	eq
 802ee6c:	2301      	moveq	r3, #1
 802ee6e:	2300      	movne	r3, #0
 802ee70:	b2db      	uxtb	r3, r3
 802ee72:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 802ee74:	687b      	ldr	r3, [r7, #4]
 802ee76:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802ee7a:	b2db      	uxtb	r3, r3
 802ee7c:	2b21      	cmp	r3, #33	; 0x21
 802ee7e:	d10a      	bne.n	802ee96 <HAL_UART_DMAPause+0x5a>
 802ee80:	68fb      	ldr	r3, [r7, #12]
 802ee82:	2b00      	cmp	r3, #0
 802ee84:	d007      	beq.n	802ee96 <HAL_UART_DMAPause+0x5a>
  {
    /* Disable the UART DMA Tx request */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802ee86:	687b      	ldr	r3, [r7, #4]
 802ee88:	681b      	ldr	r3, [r3, #0]
 802ee8a:	695a      	ldr	r2, [r3, #20]
 802ee8c:	687b      	ldr	r3, [r7, #4]
 802ee8e:	681b      	ldr	r3, [r3, #0]
 802ee90:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802ee94:	615a      	str	r2, [r3, #20]
  }

  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 802ee96:	687b      	ldr	r3, [r7, #4]
 802ee98:	681b      	ldr	r3, [r3, #0]
 802ee9a:	695b      	ldr	r3, [r3, #20]
 802ee9c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802eea0:	2b40      	cmp	r3, #64	; 0x40
 802eea2:	bf0c      	ite	eq
 802eea4:	2301      	moveq	r3, #1
 802eea6:	2300      	movne	r3, #0
 802eea8:	b2db      	uxtb	r3, r3
 802eeaa:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 802eeac:	687b      	ldr	r3, [r7, #4]
 802eeae:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802eeb2:	b2db      	uxtb	r3, r3
 802eeb4:	2b22      	cmp	r3, #34	; 0x22
 802eeb6:	d11a      	bne.n	802eeee <HAL_UART_DMAPause+0xb2>
 802eeb8:	68fb      	ldr	r3, [r7, #12]
 802eeba:	2b00      	cmp	r3, #0
 802eebc:	d017      	beq.n	802eeee <HAL_UART_DMAPause+0xb2>
  {
    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 802eebe:	687b      	ldr	r3, [r7, #4]
 802eec0:	681b      	ldr	r3, [r3, #0]
 802eec2:	68da      	ldr	r2, [r3, #12]
 802eec4:	687b      	ldr	r3, [r7, #4]
 802eec6:	681b      	ldr	r3, [r3, #0]
 802eec8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802eecc:	60da      	str	r2, [r3, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802eece:	687b      	ldr	r3, [r7, #4]
 802eed0:	681b      	ldr	r3, [r3, #0]
 802eed2:	695a      	ldr	r2, [r3, #20]
 802eed4:	687b      	ldr	r3, [r7, #4]
 802eed6:	681b      	ldr	r3, [r3, #0]
 802eed8:	f022 0201 	bic.w	r2, r2, #1
 802eedc:	615a      	str	r2, [r3, #20]

    /* Disable the UART DMA Rx request */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802eede:	687b      	ldr	r3, [r7, #4]
 802eee0:	681b      	ldr	r3, [r3, #0]
 802eee2:	695a      	ldr	r2, [r3, #20]
 802eee4:	687b      	ldr	r3, [r7, #4]
 802eee6:	681b      	ldr	r3, [r3, #0]
 802eee8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802eeec:	615a      	str	r2, [r3, #20]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 802eeee:	687b      	ldr	r3, [r7, #4]
 802eef0:	2200      	movs	r2, #0
 802eef2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 802eef6:	2300      	movs	r3, #0
}
 802eef8:	4618      	mov	r0, r3
 802eefa:	3714      	adds	r7, #20
 802eefc:	46bd      	mov	sp, r7
 802eefe:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ef02:	4770      	bx	lr

0802ef04 <HAL_UART_DMAResume>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
{
 802ef04:	b480      	push	{r7}
 802ef06:	b085      	sub	sp, #20
 802ef08:	af00      	add	r7, sp, #0
 802ef0a:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(huart);
 802ef0c:	687b      	ldr	r3, [r7, #4]
 802ef0e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 802ef12:	2b01      	cmp	r3, #1
 802ef14:	d101      	bne.n	802ef1a <HAL_UART_DMAResume+0x16>
 802ef16:	2302      	movs	r3, #2
 802ef18:	e03f      	b.n	802ef9a <HAL_UART_DMAResume+0x96>
 802ef1a:	687b      	ldr	r3, [r7, #4]
 802ef1c:	2201      	movs	r2, #1
 802ef1e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 802ef22:	687b      	ldr	r3, [r7, #4]
 802ef24:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802ef28:	b2db      	uxtb	r3, r3
 802ef2a:	2b21      	cmp	r3, #33	; 0x21
 802ef2c:	d107      	bne.n	802ef3e <HAL_UART_DMAResume+0x3a>
  {
    /* Enable the UART DMA Tx request */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802ef2e:	687b      	ldr	r3, [r7, #4]
 802ef30:	681b      	ldr	r3, [r3, #0]
 802ef32:	695a      	ldr	r2, [r3, #20]
 802ef34:	687b      	ldr	r3, [r7, #4]
 802ef36:	681b      	ldr	r3, [r3, #0]
 802ef38:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802ef3c:	615a      	str	r2, [r3, #20]
  }

  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 802ef3e:	687b      	ldr	r3, [r7, #4]
 802ef40:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802ef44:	b2db      	uxtb	r3, r3
 802ef46:	2b22      	cmp	r3, #34	; 0x22
 802ef48:	d122      	bne.n	802ef90 <HAL_UART_DMAResume+0x8c>
  {
    /* Clear the Overrun flag before resuming the Rx transfer*/
    __HAL_UART_CLEAR_OREFLAG(huart);
 802ef4a:	2300      	movs	r3, #0
 802ef4c:	60fb      	str	r3, [r7, #12]
 802ef4e:	687b      	ldr	r3, [r7, #4]
 802ef50:	681b      	ldr	r3, [r3, #0]
 802ef52:	681b      	ldr	r3, [r3, #0]
 802ef54:	60fb      	str	r3, [r7, #12]
 802ef56:	687b      	ldr	r3, [r7, #4]
 802ef58:	681b      	ldr	r3, [r3, #0]
 802ef5a:	685b      	ldr	r3, [r3, #4]
 802ef5c:	60fb      	str	r3, [r7, #12]
 802ef5e:	68fb      	ldr	r3, [r7, #12]

    /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 802ef60:	687b      	ldr	r3, [r7, #4]
 802ef62:	681b      	ldr	r3, [r3, #0]
 802ef64:	68da      	ldr	r2, [r3, #12]
 802ef66:	687b      	ldr	r3, [r7, #4]
 802ef68:	681b      	ldr	r3, [r3, #0]
 802ef6a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802ef6e:	60da      	str	r2, [r3, #12]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802ef70:	687b      	ldr	r3, [r7, #4]
 802ef72:	681b      	ldr	r3, [r3, #0]
 802ef74:	695a      	ldr	r2, [r3, #20]
 802ef76:	687b      	ldr	r3, [r7, #4]
 802ef78:	681b      	ldr	r3, [r3, #0]
 802ef7a:	f042 0201 	orr.w	r2, r2, #1
 802ef7e:	615a      	str	r2, [r3, #20]

    /* Enable the UART DMA Rx request */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802ef80:	687b      	ldr	r3, [r7, #4]
 802ef82:	681b      	ldr	r3, [r3, #0]
 802ef84:	695a      	ldr	r2, [r3, #20]
 802ef86:	687b      	ldr	r3, [r7, #4]
 802ef88:	681b      	ldr	r3, [r3, #0]
 802ef8a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802ef8e:	615a      	str	r2, [r3, #20]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 802ef90:	687b      	ldr	r3, [r7, #4]
 802ef92:	2200      	movs	r2, #0
 802ef94:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 802ef98:	2300      	movs	r3, #0
}
 802ef9a:	4618      	mov	r0, r3
 802ef9c:	3714      	adds	r7, #20
 802ef9e:	46bd      	mov	sp, r7
 802efa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802efa4:	4770      	bx	lr
	...

0802efa8 <HAL_UART_IRQHandler>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 802efa8:	b580      	push	{r7, lr}
 802efaa:	b088      	sub	sp, #32
 802efac:	af00      	add	r7, sp, #0
 802efae:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 802efb0:	687b      	ldr	r3, [r7, #4]
 802efb2:	681b      	ldr	r3, [r3, #0]
 802efb4:	681b      	ldr	r3, [r3, #0]
 802efb6:	61fb      	str	r3, [r7, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 802efb8:	687b      	ldr	r3, [r7, #4]
 802efba:	681b      	ldr	r3, [r3, #0]
 802efbc:	68db      	ldr	r3, [r3, #12]
 802efbe:	61bb      	str	r3, [r7, #24]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 802efc0:	687b      	ldr	r3, [r7, #4]
 802efc2:	681b      	ldr	r3, [r3, #0]
 802efc4:	695b      	ldr	r3, [r3, #20]
 802efc6:	617b      	str	r3, [r7, #20]
  uint32_t errorflags = 0x00U;
 802efc8:	2300      	movs	r3, #0
 802efca:	613b      	str	r3, [r7, #16]
  uint32_t dmarequest = 0x00U;
 802efcc:	2300      	movs	r3, #0
 802efce:	60fb      	str	r3, [r7, #12]

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
 802efd0:	69fb      	ldr	r3, [r7, #28]
 802efd2:	f003 030f 	and.w	r3, r3, #15
 802efd6:	613b      	str	r3, [r7, #16]
  if (errorflags == RESET)
 802efd8:	693b      	ldr	r3, [r7, #16]
 802efda:	2b00      	cmp	r3, #0
 802efdc:	d10d      	bne.n	802effa <HAL_UART_IRQHandler+0x52>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 802efde:	69fb      	ldr	r3, [r7, #28]
 802efe0:	f003 0320 	and.w	r3, r3, #32
 802efe4:	2b00      	cmp	r3, #0
 802efe6:	d008      	beq.n	802effa <HAL_UART_IRQHandler+0x52>
 802efe8:	69bb      	ldr	r3, [r7, #24]
 802efea:	f003 0320 	and.w	r3, r3, #32
 802efee:	2b00      	cmp	r3, #0
 802eff0:	d003      	beq.n	802effa <HAL_UART_IRQHandler+0x52>
    {
      UART_Receive_IT(huart);
 802eff2:	6878      	ldr	r0, [r7, #4]
 802eff4:	f000 fa2d 	bl	802f452 <UART_Receive_IT>
      return;
 802eff8:	e0d1      	b.n	802f19e <HAL_UART_IRQHandler+0x1f6>
    }
  }

  /* If some errors occur */
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 802effa:	693b      	ldr	r3, [r7, #16]
 802effc:	2b00      	cmp	r3, #0
 802effe:	f000 80b0 	beq.w	802f162 <HAL_UART_IRQHandler+0x1ba>
 802f002:	697b      	ldr	r3, [r7, #20]
 802f004:	f003 0301 	and.w	r3, r3, #1
 802f008:	2b00      	cmp	r3, #0
 802f00a:	d105      	bne.n	802f018 <HAL_UART_IRQHandler+0x70>
 802f00c:	69bb      	ldr	r3, [r7, #24]
 802f00e:	f403 7390 	and.w	r3, r3, #288	; 0x120
 802f012:	2b00      	cmp	r3, #0
 802f014:	f000 80a5 	beq.w	802f162 <HAL_UART_IRQHandler+0x1ba>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 802f018:	69fb      	ldr	r3, [r7, #28]
 802f01a:	f003 0301 	and.w	r3, r3, #1
 802f01e:	2b00      	cmp	r3, #0
 802f020:	d00a      	beq.n	802f038 <HAL_UART_IRQHandler+0x90>
 802f022:	69bb      	ldr	r3, [r7, #24]
 802f024:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802f028:	2b00      	cmp	r3, #0
 802f02a:	d005      	beq.n	802f038 <HAL_UART_IRQHandler+0x90>
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 802f02c:	687b      	ldr	r3, [r7, #4]
 802f02e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f030:	f043 0201 	orr.w	r2, r3, #1
 802f034:	687b      	ldr	r3, [r7, #4]
 802f036:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART noise error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802f038:	69fb      	ldr	r3, [r7, #28]
 802f03a:	f003 0304 	and.w	r3, r3, #4
 802f03e:	2b00      	cmp	r3, #0
 802f040:	d00a      	beq.n	802f058 <HAL_UART_IRQHandler+0xb0>
 802f042:	697b      	ldr	r3, [r7, #20]
 802f044:	f003 0301 	and.w	r3, r3, #1
 802f048:	2b00      	cmp	r3, #0
 802f04a:	d005      	beq.n	802f058 <HAL_UART_IRQHandler+0xb0>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 802f04c:	687b      	ldr	r3, [r7, #4]
 802f04e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f050:	f043 0202 	orr.w	r2, r3, #2
 802f054:	687b      	ldr	r3, [r7, #4]
 802f056:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART frame error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802f058:	69fb      	ldr	r3, [r7, #28]
 802f05a:	f003 0302 	and.w	r3, r3, #2
 802f05e:	2b00      	cmp	r3, #0
 802f060:	d00a      	beq.n	802f078 <HAL_UART_IRQHandler+0xd0>
 802f062:	697b      	ldr	r3, [r7, #20]
 802f064:	f003 0301 	and.w	r3, r3, #1
 802f068:	2b00      	cmp	r3, #0
 802f06a:	d005      	beq.n	802f078 <HAL_UART_IRQHandler+0xd0>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 802f06c:	687b      	ldr	r3, [r7, #4]
 802f06e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f070:	f043 0204 	orr.w	r2, r3, #4
 802f074:	687b      	ldr	r3, [r7, #4]
 802f076:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART Over-Run interrupt occurred --------------------------------------*/
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 802f078:	69fb      	ldr	r3, [r7, #28]
 802f07a:	f003 0308 	and.w	r3, r3, #8
 802f07e:	2b00      	cmp	r3, #0
 802f080:	d00f      	beq.n	802f0a2 <HAL_UART_IRQHandler+0xfa>
 802f082:	69bb      	ldr	r3, [r7, #24]
 802f084:	f003 0320 	and.w	r3, r3, #32
 802f088:	2b00      	cmp	r3, #0
 802f08a:	d104      	bne.n	802f096 <HAL_UART_IRQHandler+0xee>
 802f08c:	697b      	ldr	r3, [r7, #20]
 802f08e:	f003 0301 	and.w	r3, r3, #1
 802f092:	2b00      	cmp	r3, #0
 802f094:	d005      	beq.n	802f0a2 <HAL_UART_IRQHandler+0xfa>
    {
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 802f096:	687b      	ldr	r3, [r7, #4]
 802f098:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f09a:	f043 0208 	orr.w	r2, r3, #8
 802f09e:	687b      	ldr	r3, [r7, #4]
 802f0a0:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 802f0a2:	687b      	ldr	r3, [r7, #4]
 802f0a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f0a6:	2b00      	cmp	r3, #0
 802f0a8:	d078      	beq.n	802f19c <HAL_UART_IRQHandler+0x1f4>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 802f0aa:	69fb      	ldr	r3, [r7, #28]
 802f0ac:	f003 0320 	and.w	r3, r3, #32
 802f0b0:	2b00      	cmp	r3, #0
 802f0b2:	d007      	beq.n	802f0c4 <HAL_UART_IRQHandler+0x11c>
 802f0b4:	69bb      	ldr	r3, [r7, #24]
 802f0b6:	f003 0320 	and.w	r3, r3, #32
 802f0ba:	2b00      	cmp	r3, #0
 802f0bc:	d002      	beq.n	802f0c4 <HAL_UART_IRQHandler+0x11c>
      {
        UART_Receive_IT(huart);
 802f0be:	6878      	ldr	r0, [r7, #4]
 802f0c0:	f000 f9c7 	bl	802f452 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 802f0c4:	687b      	ldr	r3, [r7, #4]
 802f0c6:	681b      	ldr	r3, [r3, #0]
 802f0c8:	695b      	ldr	r3, [r3, #20]
 802f0ca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802f0ce:	2b40      	cmp	r3, #64	; 0x40
 802f0d0:	bf0c      	ite	eq
 802f0d2:	2301      	moveq	r3, #1
 802f0d4:	2300      	movne	r3, #0
 802f0d6:	b2db      	uxtb	r3, r3
 802f0d8:	60fb      	str	r3, [r7, #12]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 802f0da:	687b      	ldr	r3, [r7, #4]
 802f0dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f0de:	f003 0308 	and.w	r3, r3, #8
 802f0e2:	2b00      	cmp	r3, #0
 802f0e4:	d102      	bne.n	802f0ec <HAL_UART_IRQHandler+0x144>
 802f0e6:	68fb      	ldr	r3, [r7, #12]
 802f0e8:	2b00      	cmp	r3, #0
 802f0ea:	d031      	beq.n	802f150 <HAL_UART_IRQHandler+0x1a8>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 802f0ec:	6878      	ldr	r0, [r7, #4]
 802f0ee:	f000 f910 	bl	802f312 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802f0f2:	687b      	ldr	r3, [r7, #4]
 802f0f4:	681b      	ldr	r3, [r3, #0]
 802f0f6:	695b      	ldr	r3, [r3, #20]
 802f0f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802f0fc:	2b40      	cmp	r3, #64	; 0x40
 802f0fe:	d123      	bne.n	802f148 <HAL_UART_IRQHandler+0x1a0>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802f100:	687b      	ldr	r3, [r7, #4]
 802f102:	681b      	ldr	r3, [r3, #0]
 802f104:	695a      	ldr	r2, [r3, #20]
 802f106:	687b      	ldr	r3, [r7, #4]
 802f108:	681b      	ldr	r3, [r3, #0]
 802f10a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802f10e:	615a      	str	r2, [r3, #20]

          /* Abort the UART DMA Rx stream */
          if (huart->hdmarx != NULL)
 802f110:	687b      	ldr	r3, [r7, #4]
 802f112:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802f114:	2b00      	cmp	r3, #0
 802f116:	d013      	beq.n	802f140 <HAL_UART_IRQHandler+0x198>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 802f118:	687b      	ldr	r3, [r7, #4]
 802f11a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802f11c:	4a21      	ldr	r2, [pc, #132]	; (802f1a4 <HAL_UART_IRQHandler+0x1fc>)
 802f11e:	651a      	str	r2, [r3, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 802f120:	687b      	ldr	r3, [r7, #4]
 802f122:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802f124:	4618      	mov	r0, r3
 802f126:	f7fd f919 	bl	802c35c <HAL_DMA_Abort_IT>
 802f12a:	4603      	mov	r3, r0
 802f12c:	2b00      	cmp	r3, #0
 802f12e:	d016      	beq.n	802f15e <HAL_UART_IRQHandler+0x1b6>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 802f130:	687b      	ldr	r3, [r7, #4]
 802f132:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802f134:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802f136:	687a      	ldr	r2, [r7, #4]
 802f138:	6b52      	ldr	r2, [r2, #52]	; 0x34
 802f13a:	4610      	mov	r0, r2
 802f13c:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802f13e:	e00e      	b.n	802f15e <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 802f140:	6878      	ldr	r0, [r7, #4]
 802f142:	f000 f845 	bl	802f1d0 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802f146:	e00a      	b.n	802f15e <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 802f148:	6878      	ldr	r0, [r7, #4]
 802f14a:	f000 f841 	bl	802f1d0 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802f14e:	e006      	b.n	802f15e <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 802f150:	6878      	ldr	r0, [r7, #4]
 802f152:	f000 f83d 	bl	802f1d0 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

        huart->ErrorCode = HAL_UART_ERROR_NONE;
 802f156:	687b      	ldr	r3, [r7, #4]
 802f158:	2200      	movs	r2, #0
 802f15a:	63da      	str	r2, [r3, #60]	; 0x3c
      }
    }
    return;
 802f15c:	e01e      	b.n	802f19c <HAL_UART_IRQHandler+0x1f4>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802f15e:	bf00      	nop
    return;
 802f160:	e01c      	b.n	802f19c <HAL_UART_IRQHandler+0x1f4>
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 802f162:	69fb      	ldr	r3, [r7, #28]
 802f164:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802f168:	2b00      	cmp	r3, #0
 802f16a:	d008      	beq.n	802f17e <HAL_UART_IRQHandler+0x1d6>
 802f16c:	69bb      	ldr	r3, [r7, #24]
 802f16e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802f172:	2b00      	cmp	r3, #0
 802f174:	d003      	beq.n	802f17e <HAL_UART_IRQHandler+0x1d6>
  {
    UART_Transmit_IT(huart);
 802f176:	6878      	ldr	r0, [r7, #4]
 802f178:	f000 f8fd 	bl	802f376 <UART_Transmit_IT>
    return;
 802f17c:	e00f      	b.n	802f19e <HAL_UART_IRQHandler+0x1f6>
  }

  /* UART in mode Transmitter end --------------------------------------------*/
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 802f17e:	69fb      	ldr	r3, [r7, #28]
 802f180:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802f184:	2b00      	cmp	r3, #0
 802f186:	d00a      	beq.n	802f19e <HAL_UART_IRQHandler+0x1f6>
 802f188:	69bb      	ldr	r3, [r7, #24]
 802f18a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802f18e:	2b00      	cmp	r3, #0
 802f190:	d005      	beq.n	802f19e <HAL_UART_IRQHandler+0x1f6>
  {
    UART_EndTransmit_IT(huart);
 802f192:	6878      	ldr	r0, [r7, #4]
 802f194:	f000 f945 	bl	802f422 <UART_EndTransmit_IT>
    return;
 802f198:	bf00      	nop
 802f19a:	e000      	b.n	802f19e <HAL_UART_IRQHandler+0x1f6>
    return;
 802f19c:	bf00      	nop
  }
}
 802f19e:	3720      	adds	r7, #32
 802f1a0:	46bd      	mov	sp, r7
 802f1a2:	bd80      	pop	{r7, pc}
 802f1a4:	0802f34f 	.word	0x0802f34f

0802f1a8 <HAL_UART_TxHalfCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 802f1a8:	b480      	push	{r7}
 802f1aa:	b083      	sub	sp, #12
 802f1ac:	af00      	add	r7, sp, #0
 802f1ae:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback could be implemented in the user file
   */
}
 802f1b0:	bf00      	nop
 802f1b2:	370c      	adds	r7, #12
 802f1b4:	46bd      	mov	sp, r7
 802f1b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f1ba:	4770      	bx	lr

0802f1bc <HAL_UART_RxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 802f1bc:	b480      	push	{r7}
 802f1be:	b083      	sub	sp, #12
 802f1c0:	af00      	add	r7, sp, #0
 802f1c2:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
 802f1c4:	bf00      	nop
 802f1c6:	370c      	adds	r7, #12
 802f1c8:	46bd      	mov	sp, r7
 802f1ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f1ce:	4770      	bx	lr

0802f1d0 <HAL_UART_ErrorCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 802f1d0:	b480      	push	{r7}
 802f1d2:	b083      	sub	sp, #12
 802f1d4:	af00      	add	r7, sp, #0
 802f1d6:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_ErrorCallback could be implemented in the user file
   */
}
 802f1d8:	bf00      	nop
 802f1da:	370c      	adds	r7, #12
 802f1dc:	46bd      	mov	sp, r7
 802f1de:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f1e2:	4770      	bx	lr

0802f1e4 <UART_DMATransmitCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 802f1e4:	b580      	push	{r7, lr}
 802f1e6:	b084      	sub	sp, #16
 802f1e8:	af00      	add	r7, sp, #0
 802f1ea:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802f1ec:	687b      	ldr	r3, [r7, #4]
 802f1ee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802f1f0:	60fb      	str	r3, [r7, #12]
  /* DMA Normal mode*/
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 802f1f2:	687b      	ldr	r3, [r7, #4]
 802f1f4:	681b      	ldr	r3, [r3, #0]
 802f1f6:	681b      	ldr	r3, [r3, #0]
 802f1f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802f1fc:	2b00      	cmp	r3, #0
 802f1fe:	d113      	bne.n	802f228 <UART_DMATransmitCplt+0x44>
  {
    huart->TxXferCount = 0x00U;
 802f200:	68fb      	ldr	r3, [r7, #12]
 802f202:	2200      	movs	r2, #0
 802f204:	84da      	strh	r2, [r3, #38]	; 0x26

    /* Disable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802f206:	68fb      	ldr	r3, [r7, #12]
 802f208:	681b      	ldr	r3, [r3, #0]
 802f20a:	695a      	ldr	r2, [r3, #20]
 802f20c:	68fb      	ldr	r3, [r7, #12]
 802f20e:	681b      	ldr	r3, [r3, #0]
 802f210:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802f214:	615a      	str	r2, [r3, #20]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802f216:	68fb      	ldr	r3, [r7, #12]
 802f218:	681b      	ldr	r3, [r3, #0]
 802f21a:	68da      	ldr	r2, [r3, #12]
 802f21c:	68fb      	ldr	r3, [r7, #12]
 802f21e:	681b      	ldr	r3, [r3, #0]
 802f220:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802f224:	60da      	str	r2, [r3, #12]
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 802f226:	e002      	b.n	802f22e <UART_DMATransmitCplt+0x4a>
    HAL_UART_TxCpltCallback(huart);
 802f228:	68f8      	ldr	r0, [r7, #12]
 802f22a:	f7fc fdb3 	bl	802bd94 <HAL_UART_TxCpltCallback>
}
 802f22e:	bf00      	nop
 802f230:	3710      	adds	r7, #16
 802f232:	46bd      	mov	sp, r7
 802f234:	bd80      	pop	{r7, pc}

0802f236 <UART_DMATxHalfCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 802f236:	b580      	push	{r7, lr}
 802f238:	b084      	sub	sp, #16
 802f23a:	af00      	add	r7, sp, #0
 802f23c:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802f23e:	687b      	ldr	r3, [r7, #4]
 802f240:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802f242:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 802f244:	68f8      	ldr	r0, [r7, #12]
 802f246:	f7ff ffaf 	bl	802f1a8 <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802f24a:	bf00      	nop
 802f24c:	3710      	adds	r7, #16
 802f24e:	46bd      	mov	sp, r7
 802f250:	bd80      	pop	{r7, pc}

0802f252 <UART_DMAError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 802f252:	b580      	push	{r7, lr}
 802f254:	b084      	sub	sp, #16
 802f256:	af00      	add	r7, sp, #0
 802f258:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 802f25a:	2300      	movs	r3, #0
 802f25c:	60fb      	str	r3, [r7, #12]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802f25e:	687b      	ldr	r3, [r7, #4]
 802f260:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802f262:	60bb      	str	r3, [r7, #8]

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 802f264:	68bb      	ldr	r3, [r7, #8]
 802f266:	681b      	ldr	r3, [r3, #0]
 802f268:	695b      	ldr	r3, [r3, #20]
 802f26a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802f26e:	2b80      	cmp	r3, #128	; 0x80
 802f270:	bf0c      	ite	eq
 802f272:	2301      	moveq	r3, #1
 802f274:	2300      	movne	r3, #0
 802f276:	b2db      	uxtb	r3, r3
 802f278:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 802f27a:	68bb      	ldr	r3, [r7, #8]
 802f27c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802f280:	b2db      	uxtb	r3, r3
 802f282:	2b21      	cmp	r3, #33	; 0x21
 802f284:	d108      	bne.n	802f298 <UART_DMAError+0x46>
 802f286:	68fb      	ldr	r3, [r7, #12]
 802f288:	2b00      	cmp	r3, #0
 802f28a:	d005      	beq.n	802f298 <UART_DMAError+0x46>
  {
    huart->TxXferCount = 0x00U;
 802f28c:	68bb      	ldr	r3, [r7, #8]
 802f28e:	2200      	movs	r2, #0
 802f290:	84da      	strh	r2, [r3, #38]	; 0x26
    UART_EndTxTransfer(huart);
 802f292:	68b8      	ldr	r0, [r7, #8]
 802f294:	f000 f827 	bl	802f2e6 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 802f298:	68bb      	ldr	r3, [r7, #8]
 802f29a:	681b      	ldr	r3, [r3, #0]
 802f29c:	695b      	ldr	r3, [r3, #20]
 802f29e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802f2a2:	2b40      	cmp	r3, #64	; 0x40
 802f2a4:	bf0c      	ite	eq
 802f2a6:	2301      	moveq	r3, #1
 802f2a8:	2300      	movne	r3, #0
 802f2aa:	b2db      	uxtb	r3, r3
 802f2ac:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 802f2ae:	68bb      	ldr	r3, [r7, #8]
 802f2b0:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802f2b4:	b2db      	uxtb	r3, r3
 802f2b6:	2b22      	cmp	r3, #34	; 0x22
 802f2b8:	d108      	bne.n	802f2cc <UART_DMAError+0x7a>
 802f2ba:	68fb      	ldr	r3, [r7, #12]
 802f2bc:	2b00      	cmp	r3, #0
 802f2be:	d005      	beq.n	802f2cc <UART_DMAError+0x7a>
  {
    huart->RxXferCount = 0x00U;
 802f2c0:	68bb      	ldr	r3, [r7, #8]
 802f2c2:	2200      	movs	r2, #0
 802f2c4:	85da      	strh	r2, [r3, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 802f2c6:	68b8      	ldr	r0, [r7, #8]
 802f2c8:	f000 f823 	bl	802f312 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802f2cc:	68bb      	ldr	r3, [r7, #8]
 802f2ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802f2d0:	f043 0210 	orr.w	r2, r3, #16
 802f2d4:	68bb      	ldr	r3, [r7, #8]
 802f2d6:	63da      	str	r2, [r3, #60]	; 0x3c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802f2d8:	68b8      	ldr	r0, [r7, #8]
 802f2da:	f7ff ff79 	bl	802f1d0 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802f2de:	bf00      	nop
 802f2e0:	3710      	adds	r7, #16
 802f2e2:	46bd      	mov	sp, r7
 802f2e4:	bd80      	pop	{r7, pc}

0802f2e6 <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 802f2e6:	b480      	push	{r7}
 802f2e8:	b083      	sub	sp, #12
 802f2ea:	af00      	add	r7, sp, #0
 802f2ec:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 802f2ee:	687b      	ldr	r3, [r7, #4]
 802f2f0:	681b      	ldr	r3, [r3, #0]
 802f2f2:	68da      	ldr	r2, [r3, #12]
 802f2f4:	687b      	ldr	r3, [r7, #4]
 802f2f6:	681b      	ldr	r3, [r3, #0]
 802f2f8:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 802f2fc:	60da      	str	r2, [r3, #12]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802f2fe:	687b      	ldr	r3, [r7, #4]
 802f300:	2220      	movs	r2, #32
 802f302:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
}
 802f306:	bf00      	nop
 802f308:	370c      	adds	r7, #12
 802f30a:	46bd      	mov	sp, r7
 802f30c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f310:	4770      	bx	lr

0802f312 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 802f312:	b480      	push	{r7}
 802f314:	b083      	sub	sp, #12
 802f316:	af00      	add	r7, sp, #0
 802f318:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 802f31a:	687b      	ldr	r3, [r7, #4]
 802f31c:	681b      	ldr	r3, [r3, #0]
 802f31e:	68da      	ldr	r2, [r3, #12]
 802f320:	687b      	ldr	r3, [r7, #4]
 802f322:	681b      	ldr	r3, [r3, #0]
 802f324:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 802f328:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802f32a:	687b      	ldr	r3, [r7, #4]
 802f32c:	681b      	ldr	r3, [r3, #0]
 802f32e:	695a      	ldr	r2, [r3, #20]
 802f330:	687b      	ldr	r3, [r7, #4]
 802f332:	681b      	ldr	r3, [r3, #0]
 802f334:	f022 0201 	bic.w	r2, r2, #1
 802f338:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 802f33a:	687b      	ldr	r3, [r7, #4]
 802f33c:	2220      	movs	r2, #32
 802f33e:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
}
 802f342:	bf00      	nop
 802f344:	370c      	adds	r7, #12
 802f346:	46bd      	mov	sp, r7
 802f348:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f34c:	4770      	bx	lr

0802f34e <UART_DMAAbortOnError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 802f34e:	b580      	push	{r7, lr}
 802f350:	b084      	sub	sp, #16
 802f352:	af00      	add	r7, sp, #0
 802f354:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802f356:	687b      	ldr	r3, [r7, #4]
 802f358:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802f35a:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0x00U;
 802f35c:	68fb      	ldr	r3, [r7, #12]
 802f35e:	2200      	movs	r2, #0
 802f360:	85da      	strh	r2, [r3, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 802f362:	68fb      	ldr	r3, [r7, #12]
 802f364:	2200      	movs	r2, #0
 802f366:	84da      	strh	r2, [r3, #38]	; 0x26
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802f368:	68f8      	ldr	r0, [r7, #12]
 802f36a:	f7ff ff31 	bl	802f1d0 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802f36e:	bf00      	nop
 802f370:	3710      	adds	r7, #16
 802f372:	46bd      	mov	sp, r7
 802f374:	bd80      	pop	{r7, pc}

0802f376 <UART_Transmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
 802f376:	b480      	push	{r7}
 802f378:	b085      	sub	sp, #20
 802f37a:	af00      	add	r7, sp, #0
 802f37c:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 802f37e:	687b      	ldr	r3, [r7, #4]
 802f380:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802f384:	b2db      	uxtb	r3, r3
 802f386:	2b21      	cmp	r3, #33	; 0x21
 802f388:	d144      	bne.n	802f414 <UART_Transmit_IT+0x9e>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 802f38a:	687b      	ldr	r3, [r7, #4]
 802f38c:	689b      	ldr	r3, [r3, #8]
 802f38e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 802f392:	d11a      	bne.n	802f3ca <UART_Transmit_IT+0x54>
    {
      tmp = (uint16_t *) huart->pTxBuffPtr;
 802f394:	687b      	ldr	r3, [r7, #4]
 802f396:	6a1b      	ldr	r3, [r3, #32]
 802f398:	60fb      	str	r3, [r7, #12]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 802f39a:	68fb      	ldr	r3, [r7, #12]
 802f39c:	881b      	ldrh	r3, [r3, #0]
 802f39e:	461a      	mov	r2, r3
 802f3a0:	687b      	ldr	r3, [r7, #4]
 802f3a2:	681b      	ldr	r3, [r3, #0]
 802f3a4:	f3c2 0208 	ubfx	r2, r2, #0, #9
 802f3a8:	605a      	str	r2, [r3, #4]
      if (huart->Init.Parity == UART_PARITY_NONE)
 802f3aa:	687b      	ldr	r3, [r7, #4]
 802f3ac:	691b      	ldr	r3, [r3, #16]
 802f3ae:	2b00      	cmp	r3, #0
 802f3b0:	d105      	bne.n	802f3be <UART_Transmit_IT+0x48>
      {
        huart->pTxBuffPtr += 2U;
 802f3b2:	687b      	ldr	r3, [r7, #4]
 802f3b4:	6a1b      	ldr	r3, [r3, #32]
 802f3b6:	1c9a      	adds	r2, r3, #2
 802f3b8:	687b      	ldr	r3, [r7, #4]
 802f3ba:	621a      	str	r2, [r3, #32]
 802f3bc:	e00e      	b.n	802f3dc <UART_Transmit_IT+0x66>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 802f3be:	687b      	ldr	r3, [r7, #4]
 802f3c0:	6a1b      	ldr	r3, [r3, #32]
 802f3c2:	1c5a      	adds	r2, r3, #1
 802f3c4:	687b      	ldr	r3, [r7, #4]
 802f3c6:	621a      	str	r2, [r3, #32]
 802f3c8:	e008      	b.n	802f3dc <UART_Transmit_IT+0x66>
      }
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 802f3ca:	687b      	ldr	r3, [r7, #4]
 802f3cc:	6a1b      	ldr	r3, [r3, #32]
 802f3ce:	1c59      	adds	r1, r3, #1
 802f3d0:	687a      	ldr	r2, [r7, #4]
 802f3d2:	6211      	str	r1, [r2, #32]
 802f3d4:	781a      	ldrb	r2, [r3, #0]
 802f3d6:	687b      	ldr	r3, [r7, #4]
 802f3d8:	681b      	ldr	r3, [r3, #0]
 802f3da:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 802f3dc:	687b      	ldr	r3, [r7, #4]
 802f3de:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 802f3e0:	b29b      	uxth	r3, r3
 802f3e2:	3b01      	subs	r3, #1
 802f3e4:	b29b      	uxth	r3, r3
 802f3e6:	687a      	ldr	r2, [r7, #4]
 802f3e8:	4619      	mov	r1, r3
 802f3ea:	84d1      	strh	r1, [r2, #38]	; 0x26
 802f3ec:	2b00      	cmp	r3, #0
 802f3ee:	d10f      	bne.n	802f410 <UART_Transmit_IT+0x9a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 802f3f0:	687b      	ldr	r3, [r7, #4]
 802f3f2:	681b      	ldr	r3, [r3, #0]
 802f3f4:	68da      	ldr	r2, [r3, #12]
 802f3f6:	687b      	ldr	r3, [r7, #4]
 802f3f8:	681b      	ldr	r3, [r3, #0]
 802f3fa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802f3fe:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 802f400:	687b      	ldr	r3, [r7, #4]
 802f402:	681b      	ldr	r3, [r3, #0]
 802f404:	68da      	ldr	r2, [r3, #12]
 802f406:	687b      	ldr	r3, [r7, #4]
 802f408:	681b      	ldr	r3, [r3, #0]
 802f40a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802f40e:	60da      	str	r2, [r3, #12]
    }
    return HAL_OK;
 802f410:	2300      	movs	r3, #0
 802f412:	e000      	b.n	802f416 <UART_Transmit_IT+0xa0>
  }
  else
  {
    return HAL_BUSY;
 802f414:	2302      	movs	r3, #2
  }
}
 802f416:	4618      	mov	r0, r3
 802f418:	3714      	adds	r7, #20
 802f41a:	46bd      	mov	sp, r7
 802f41c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802f420:	4770      	bx	lr

0802f422 <UART_EndTransmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 802f422:	b580      	push	{r7, lr}
 802f424:	b082      	sub	sp, #8
 802f426:	af00      	add	r7, sp, #0
 802f428:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 802f42a:	687b      	ldr	r3, [r7, #4]
 802f42c:	681b      	ldr	r3, [r3, #0]
 802f42e:	68da      	ldr	r2, [r3, #12]
 802f430:	687b      	ldr	r3, [r7, #4]
 802f432:	681b      	ldr	r3, [r3, #0]
 802f434:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802f438:	60da      	str	r2, [r3, #12]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802f43a:	687b      	ldr	r3, [r7, #4]
 802f43c:	2220      	movs	r2, #32
 802f43e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 802f442:	6878      	ldr	r0, [r7, #4]
 802f444:	f7fc fca6 	bl	802bd94 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

  return HAL_OK;
 802f448:	2300      	movs	r3, #0
}
 802f44a:	4618      	mov	r0, r3
 802f44c:	3708      	adds	r7, #8
 802f44e:	46bd      	mov	sp, r7
 802f450:	bd80      	pop	{r7, pc}

0802f452 <UART_Receive_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 802f452:	b580      	push	{r7, lr}
 802f454:	b084      	sub	sp, #16
 802f456:	af00      	add	r7, sp, #0
 802f458:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 802f45a:	687b      	ldr	r3, [r7, #4]
 802f45c:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802f460:	b2db      	uxtb	r3, r3
 802f462:	2b22      	cmp	r3, #34	; 0x22
 802f464:	d171      	bne.n	802f54a <UART_Receive_IT+0xf8>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 802f466:	687b      	ldr	r3, [r7, #4]
 802f468:	689b      	ldr	r3, [r3, #8]
 802f46a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 802f46e:	d123      	bne.n	802f4b8 <UART_Receive_IT+0x66>
    {
      tmp = (uint16_t *) huart->pRxBuffPtr;
 802f470:	687b      	ldr	r3, [r7, #4]
 802f472:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802f474:	60fb      	str	r3, [r7, #12]
      if (huart->Init.Parity == UART_PARITY_NONE)
 802f476:	687b      	ldr	r3, [r7, #4]
 802f478:	691b      	ldr	r3, [r3, #16]
 802f47a:	2b00      	cmp	r3, #0
 802f47c:	d10e      	bne.n	802f49c <UART_Receive_IT+0x4a>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 802f47e:	687b      	ldr	r3, [r7, #4]
 802f480:	681b      	ldr	r3, [r3, #0]
 802f482:	685b      	ldr	r3, [r3, #4]
 802f484:	b29b      	uxth	r3, r3
 802f486:	f3c3 0308 	ubfx	r3, r3, #0, #9
 802f48a:	b29a      	uxth	r2, r3
 802f48c:	68fb      	ldr	r3, [r7, #12]
 802f48e:	801a      	strh	r2, [r3, #0]
        huart->pRxBuffPtr += 2U;
 802f490:	687b      	ldr	r3, [r7, #4]
 802f492:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802f494:	1c9a      	adds	r2, r3, #2
 802f496:	687b      	ldr	r3, [r7, #4]
 802f498:	629a      	str	r2, [r3, #40]	; 0x28
 802f49a:	e029      	b.n	802f4f0 <UART_Receive_IT+0x9e>
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 802f49c:	687b      	ldr	r3, [r7, #4]
 802f49e:	681b      	ldr	r3, [r3, #0]
 802f4a0:	685b      	ldr	r3, [r3, #4]
 802f4a2:	b29b      	uxth	r3, r3
 802f4a4:	b2db      	uxtb	r3, r3
 802f4a6:	b29a      	uxth	r2, r3
 802f4a8:	68fb      	ldr	r3, [r7, #12]
 802f4aa:	801a      	strh	r2, [r3, #0]
        huart->pRxBuffPtr += 1U;
 802f4ac:	687b      	ldr	r3, [r7, #4]
 802f4ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802f4b0:	1c5a      	adds	r2, r3, #1
 802f4b2:	687b      	ldr	r3, [r7, #4]
 802f4b4:	629a      	str	r2, [r3, #40]	; 0x28
 802f4b6:	e01b      	b.n	802f4f0 <UART_Receive_IT+0x9e>
      }
    }
    else
    {
      if (huart->Init.Parity == UART_PARITY_NONE)
 802f4b8:	687b      	ldr	r3, [r7, #4]
 802f4ba:	691b      	ldr	r3, [r3, #16]
 802f4bc:	2b00      	cmp	r3, #0
 802f4be:	d10a      	bne.n	802f4d6 <UART_Receive_IT+0x84>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 802f4c0:	687b      	ldr	r3, [r7, #4]
 802f4c2:	681b      	ldr	r3, [r3, #0]
 802f4c4:	6858      	ldr	r0, [r3, #4]
 802f4c6:	687b      	ldr	r3, [r7, #4]
 802f4c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802f4ca:	1c59      	adds	r1, r3, #1
 802f4cc:	687a      	ldr	r2, [r7, #4]
 802f4ce:	6291      	str	r1, [r2, #40]	; 0x28
 802f4d0:	b2c2      	uxtb	r2, r0
 802f4d2:	701a      	strb	r2, [r3, #0]
 802f4d4:	e00c      	b.n	802f4f0 <UART_Receive_IT+0x9e>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 802f4d6:	687b      	ldr	r3, [r7, #4]
 802f4d8:	681b      	ldr	r3, [r3, #0]
 802f4da:	685b      	ldr	r3, [r3, #4]
 802f4dc:	b2da      	uxtb	r2, r3
 802f4de:	687b      	ldr	r3, [r7, #4]
 802f4e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802f4e2:	1c58      	adds	r0, r3, #1
 802f4e4:	6879      	ldr	r1, [r7, #4]
 802f4e6:	6288      	str	r0, [r1, #40]	; 0x28
 802f4e8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 802f4ec:	b2d2      	uxtb	r2, r2
 802f4ee:	701a      	strb	r2, [r3, #0]
      }
    }

    if (--huart->RxXferCount == 0U)
 802f4f0:	687b      	ldr	r3, [r7, #4]
 802f4f2:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 802f4f4:	b29b      	uxth	r3, r3
 802f4f6:	3b01      	subs	r3, #1
 802f4f8:	b29b      	uxth	r3, r3
 802f4fa:	687a      	ldr	r2, [r7, #4]
 802f4fc:	4619      	mov	r1, r3
 802f4fe:	85d1      	strh	r1, [r2, #46]	; 0x2e
 802f500:	2b00      	cmp	r3, #0
 802f502:	d120      	bne.n	802f546 <UART_Receive_IT+0xf4>
    {
      /* Disable the UART Data Register not empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 802f504:	687b      	ldr	r3, [r7, #4]
 802f506:	681b      	ldr	r3, [r3, #0]
 802f508:	68da      	ldr	r2, [r3, #12]
 802f50a:	687b      	ldr	r3, [r7, #4]
 802f50c:	681b      	ldr	r3, [r3, #0]
 802f50e:	f022 0220 	bic.w	r2, r2, #32
 802f512:	60da      	str	r2, [r3, #12]

      /* Disable the UART Parity Error Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 802f514:	687b      	ldr	r3, [r7, #4]
 802f516:	681b      	ldr	r3, [r3, #0]
 802f518:	68da      	ldr	r2, [r3, #12]
 802f51a:	687b      	ldr	r3, [r7, #4]
 802f51c:	681b      	ldr	r3, [r3, #0]
 802f51e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802f522:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 802f524:	687b      	ldr	r3, [r7, #4]
 802f526:	681b      	ldr	r3, [r3, #0]
 802f528:	695a      	ldr	r2, [r3, #20]
 802f52a:	687b      	ldr	r3, [r7, #4]
 802f52c:	681b      	ldr	r3, [r3, #0]
 802f52e:	f022 0201 	bic.w	r2, r2, #1
 802f532:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 802f534:	687b      	ldr	r3, [r7, #4]
 802f536:	2220      	movs	r2, #32
 802f538:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 802f53c:	6878      	ldr	r0, [r7, #4]
 802f53e:	f7ff fe3d 	bl	802f1bc <HAL_UART_RxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

      return HAL_OK;
 802f542:	2300      	movs	r3, #0
 802f544:	e002      	b.n	802f54c <UART_Receive_IT+0xfa>
    }
    return HAL_OK;
 802f546:	2300      	movs	r3, #0
 802f548:	e000      	b.n	802f54c <UART_Receive_IT+0xfa>
  }
  else
  {
    return HAL_BUSY;
 802f54a:	2302      	movs	r3, #2
  }
}
 802f54c:	4618      	mov	r0, r3
 802f54e:	3710      	adds	r7, #16
 802f550:	46bd      	mov	sp, r7
 802f552:	bd80      	pop	{r7, pc}

0802f554 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 802f554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802f558:	b085      	sub	sp, #20
 802f55a:	af00      	add	r7, sp, #0
 802f55c:	6078      	str	r0, [r7, #4]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 802f55e:	687b      	ldr	r3, [r7, #4]
 802f560:	681b      	ldr	r3, [r3, #0]
 802f562:	691b      	ldr	r3, [r3, #16]
 802f564:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 802f568:	687b      	ldr	r3, [r7, #4]
 802f56a:	68da      	ldr	r2, [r3, #12]
 802f56c:	687b      	ldr	r3, [r7, #4]
 802f56e:	681b      	ldr	r3, [r3, #0]
 802f570:	430a      	orrs	r2, r1
 802f572:	611a      	str	r2, [r3, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 802f574:	687b      	ldr	r3, [r7, #4]
 802f576:	689a      	ldr	r2, [r3, #8]
 802f578:	687b      	ldr	r3, [r7, #4]
 802f57a:	691b      	ldr	r3, [r3, #16]
 802f57c:	431a      	orrs	r2, r3
 802f57e:	687b      	ldr	r3, [r7, #4]
 802f580:	695b      	ldr	r3, [r3, #20]
 802f582:	431a      	orrs	r2, r3
 802f584:	687b      	ldr	r3, [r7, #4]
 802f586:	69db      	ldr	r3, [r3, #28]
 802f588:	4313      	orrs	r3, r2
 802f58a:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR1,
 802f58c:	687b      	ldr	r3, [r7, #4]
 802f58e:	681b      	ldr	r3, [r3, #0]
 802f590:	68db      	ldr	r3, [r3, #12]
 802f592:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 802f596:	f023 030c 	bic.w	r3, r3, #12
 802f59a:	687a      	ldr	r2, [r7, #4]
 802f59c:	6812      	ldr	r2, [r2, #0]
 802f59e:	68f9      	ldr	r1, [r7, #12]
 802f5a0:	430b      	orrs	r3, r1
 802f5a2:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 802f5a4:	687b      	ldr	r3, [r7, #4]
 802f5a6:	681b      	ldr	r3, [r3, #0]
 802f5a8:	695b      	ldr	r3, [r3, #20]
 802f5aa:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 802f5ae:	687b      	ldr	r3, [r7, #4]
 802f5b0:	699a      	ldr	r2, [r3, #24]
 802f5b2:	687b      	ldr	r3, [r7, #4]
 802f5b4:	681b      	ldr	r3, [r3, #0]
 802f5b6:	430a      	orrs	r2, r1
 802f5b8:	615a      	str	r2, [r3, #20]

  /* Check the Over Sampling */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 802f5ba:	687b      	ldr	r3, [r7, #4]
 802f5bc:	69db      	ldr	r3, [r3, #28]
 802f5be:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802f5c2:	f040 818b 	bne.w	802f8dc <UART_SetConfig+0x388>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 802f5c6:	687b      	ldr	r3, [r7, #4]
 802f5c8:	681b      	ldr	r3, [r3, #0]
 802f5ca:	4ac1      	ldr	r2, [pc, #772]	; (802f8d0 <UART_SetConfig+0x37c>)
 802f5cc:	4293      	cmp	r3, r2
 802f5ce:	d005      	beq.n	802f5dc <UART_SetConfig+0x88>
 802f5d0:	687b      	ldr	r3, [r7, #4]
 802f5d2:	681b      	ldr	r3, [r3, #0]
 802f5d4:	4abf      	ldr	r2, [pc, #764]	; (802f8d4 <UART_SetConfig+0x380>)
 802f5d6:	4293      	cmp	r3, r2
 802f5d8:	f040 80bd 	bne.w	802f756 <UART_SetConfig+0x202>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 802f5dc:	f7fd ff4a 	bl	802d474 <HAL_RCC_GetPCLK2Freq>
 802f5e0:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 802f5e2:	68bb      	ldr	r3, [r7, #8]
 802f5e4:	461d      	mov	r5, r3
 802f5e6:	f04f 0600 	mov.w	r6, #0
 802f5ea:	46a8      	mov	r8, r5
 802f5ec:	46b1      	mov	r9, r6
 802f5ee:	eb18 0308 	adds.w	r3, r8, r8
 802f5f2:	eb49 0409 	adc.w	r4, r9, r9
 802f5f6:	4698      	mov	r8, r3
 802f5f8:	46a1      	mov	r9, r4
 802f5fa:	eb18 0805 	adds.w	r8, r8, r5
 802f5fe:	eb49 0906 	adc.w	r9, r9, r6
 802f602:	f04f 0100 	mov.w	r1, #0
 802f606:	f04f 0200 	mov.w	r2, #0
 802f60a:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802f60e:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802f612:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802f616:	4688      	mov	r8, r1
 802f618:	4691      	mov	r9, r2
 802f61a:	eb18 0005 	adds.w	r0, r8, r5
 802f61e:	eb49 0106 	adc.w	r1, r9, r6
 802f622:	687b      	ldr	r3, [r7, #4]
 802f624:	685b      	ldr	r3, [r3, #4]
 802f626:	461d      	mov	r5, r3
 802f628:	f04f 0600 	mov.w	r6, #0
 802f62c:	196b      	adds	r3, r5, r5
 802f62e:	eb46 0406 	adc.w	r4, r6, r6
 802f632:	461a      	mov	r2, r3
 802f634:	4623      	mov	r3, r4
 802f636:	f7f9 fd97 	bl	8029168 <__aeabi_uldivmod>
 802f63a:	4603      	mov	r3, r0
 802f63c:	460c      	mov	r4, r1
 802f63e:	461a      	mov	r2, r3
 802f640:	4ba5      	ldr	r3, [pc, #660]	; (802f8d8 <UART_SetConfig+0x384>)
 802f642:	fba3 2302 	umull	r2, r3, r3, r2
 802f646:	095b      	lsrs	r3, r3, #5
 802f648:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802f64c:	68bb      	ldr	r3, [r7, #8]
 802f64e:	461d      	mov	r5, r3
 802f650:	f04f 0600 	mov.w	r6, #0
 802f654:	46a9      	mov	r9, r5
 802f656:	46b2      	mov	sl, r6
 802f658:	eb19 0309 	adds.w	r3, r9, r9
 802f65c:	eb4a 040a 	adc.w	r4, sl, sl
 802f660:	4699      	mov	r9, r3
 802f662:	46a2      	mov	sl, r4
 802f664:	eb19 0905 	adds.w	r9, r9, r5
 802f668:	eb4a 0a06 	adc.w	sl, sl, r6
 802f66c:	f04f 0100 	mov.w	r1, #0
 802f670:	f04f 0200 	mov.w	r2, #0
 802f674:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802f678:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802f67c:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802f680:	4689      	mov	r9, r1
 802f682:	4692      	mov	sl, r2
 802f684:	eb19 0005 	adds.w	r0, r9, r5
 802f688:	eb4a 0106 	adc.w	r1, sl, r6
 802f68c:	687b      	ldr	r3, [r7, #4]
 802f68e:	685b      	ldr	r3, [r3, #4]
 802f690:	461d      	mov	r5, r3
 802f692:	f04f 0600 	mov.w	r6, #0
 802f696:	196b      	adds	r3, r5, r5
 802f698:	eb46 0406 	adc.w	r4, r6, r6
 802f69c:	461a      	mov	r2, r3
 802f69e:	4623      	mov	r3, r4
 802f6a0:	f7f9 fd62 	bl	8029168 <__aeabi_uldivmod>
 802f6a4:	4603      	mov	r3, r0
 802f6a6:	460c      	mov	r4, r1
 802f6a8:	461a      	mov	r2, r3
 802f6aa:	4b8b      	ldr	r3, [pc, #556]	; (802f8d8 <UART_SetConfig+0x384>)
 802f6ac:	fba3 1302 	umull	r1, r3, r3, r2
 802f6b0:	095b      	lsrs	r3, r3, #5
 802f6b2:	2164      	movs	r1, #100	; 0x64
 802f6b4:	fb01 f303 	mul.w	r3, r1, r3
 802f6b8:	1ad3      	subs	r3, r2, r3
 802f6ba:	00db      	lsls	r3, r3, #3
 802f6bc:	3332      	adds	r3, #50	; 0x32
 802f6be:	4a86      	ldr	r2, [pc, #536]	; (802f8d8 <UART_SetConfig+0x384>)
 802f6c0:	fba2 2303 	umull	r2, r3, r2, r3
 802f6c4:	095b      	lsrs	r3, r3, #5
 802f6c6:	005b      	lsls	r3, r3, #1
 802f6c8:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 802f6cc:	4498      	add	r8, r3
 802f6ce:	68bb      	ldr	r3, [r7, #8]
 802f6d0:	461d      	mov	r5, r3
 802f6d2:	f04f 0600 	mov.w	r6, #0
 802f6d6:	46a9      	mov	r9, r5
 802f6d8:	46b2      	mov	sl, r6
 802f6da:	eb19 0309 	adds.w	r3, r9, r9
 802f6de:	eb4a 040a 	adc.w	r4, sl, sl
 802f6e2:	4699      	mov	r9, r3
 802f6e4:	46a2      	mov	sl, r4
 802f6e6:	eb19 0905 	adds.w	r9, r9, r5
 802f6ea:	eb4a 0a06 	adc.w	sl, sl, r6
 802f6ee:	f04f 0100 	mov.w	r1, #0
 802f6f2:	f04f 0200 	mov.w	r2, #0
 802f6f6:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802f6fa:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802f6fe:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802f702:	4689      	mov	r9, r1
 802f704:	4692      	mov	sl, r2
 802f706:	eb19 0005 	adds.w	r0, r9, r5
 802f70a:	eb4a 0106 	adc.w	r1, sl, r6
 802f70e:	687b      	ldr	r3, [r7, #4]
 802f710:	685b      	ldr	r3, [r3, #4]
 802f712:	461d      	mov	r5, r3
 802f714:	f04f 0600 	mov.w	r6, #0
 802f718:	196b      	adds	r3, r5, r5
 802f71a:	eb46 0406 	adc.w	r4, r6, r6
 802f71e:	461a      	mov	r2, r3
 802f720:	4623      	mov	r3, r4
 802f722:	f7f9 fd21 	bl	8029168 <__aeabi_uldivmod>
 802f726:	4603      	mov	r3, r0
 802f728:	460c      	mov	r4, r1
 802f72a:	461a      	mov	r2, r3
 802f72c:	4b6a      	ldr	r3, [pc, #424]	; (802f8d8 <UART_SetConfig+0x384>)
 802f72e:	fba3 1302 	umull	r1, r3, r3, r2
 802f732:	095b      	lsrs	r3, r3, #5
 802f734:	2164      	movs	r1, #100	; 0x64
 802f736:	fb01 f303 	mul.w	r3, r1, r3
 802f73a:	1ad3      	subs	r3, r2, r3
 802f73c:	00db      	lsls	r3, r3, #3
 802f73e:	3332      	adds	r3, #50	; 0x32
 802f740:	4a65      	ldr	r2, [pc, #404]	; (802f8d8 <UART_SetConfig+0x384>)
 802f742:	fba2 2303 	umull	r2, r3, r2, r3
 802f746:	095b      	lsrs	r3, r3, #5
 802f748:	f003 0207 	and.w	r2, r3, #7
 802f74c:	687b      	ldr	r3, [r7, #4]
 802f74e:	681b      	ldr	r3, [r3, #0]
 802f750:	4442      	add	r2, r8
 802f752:	609a      	str	r2, [r3, #8]
 802f754:	e26f      	b.n	802fc36 <UART_SetConfig+0x6e2>
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 802f756:	f7fd fe79 	bl	802d44c <HAL_RCC_GetPCLK1Freq>
 802f75a:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 802f75c:	68bb      	ldr	r3, [r7, #8]
 802f75e:	461d      	mov	r5, r3
 802f760:	f04f 0600 	mov.w	r6, #0
 802f764:	46a8      	mov	r8, r5
 802f766:	46b1      	mov	r9, r6
 802f768:	eb18 0308 	adds.w	r3, r8, r8
 802f76c:	eb49 0409 	adc.w	r4, r9, r9
 802f770:	4698      	mov	r8, r3
 802f772:	46a1      	mov	r9, r4
 802f774:	eb18 0805 	adds.w	r8, r8, r5
 802f778:	eb49 0906 	adc.w	r9, r9, r6
 802f77c:	f04f 0100 	mov.w	r1, #0
 802f780:	f04f 0200 	mov.w	r2, #0
 802f784:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802f788:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802f78c:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802f790:	4688      	mov	r8, r1
 802f792:	4691      	mov	r9, r2
 802f794:	eb18 0005 	adds.w	r0, r8, r5
 802f798:	eb49 0106 	adc.w	r1, r9, r6
 802f79c:	687b      	ldr	r3, [r7, #4]
 802f79e:	685b      	ldr	r3, [r3, #4]
 802f7a0:	461d      	mov	r5, r3
 802f7a2:	f04f 0600 	mov.w	r6, #0
 802f7a6:	196b      	adds	r3, r5, r5
 802f7a8:	eb46 0406 	adc.w	r4, r6, r6
 802f7ac:	461a      	mov	r2, r3
 802f7ae:	4623      	mov	r3, r4
 802f7b0:	f7f9 fcda 	bl	8029168 <__aeabi_uldivmod>
 802f7b4:	4603      	mov	r3, r0
 802f7b6:	460c      	mov	r4, r1
 802f7b8:	461a      	mov	r2, r3
 802f7ba:	4b47      	ldr	r3, [pc, #284]	; (802f8d8 <UART_SetConfig+0x384>)
 802f7bc:	fba3 2302 	umull	r2, r3, r3, r2
 802f7c0:	095b      	lsrs	r3, r3, #5
 802f7c2:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802f7c6:	68bb      	ldr	r3, [r7, #8]
 802f7c8:	461d      	mov	r5, r3
 802f7ca:	f04f 0600 	mov.w	r6, #0
 802f7ce:	46a9      	mov	r9, r5
 802f7d0:	46b2      	mov	sl, r6
 802f7d2:	eb19 0309 	adds.w	r3, r9, r9
 802f7d6:	eb4a 040a 	adc.w	r4, sl, sl
 802f7da:	4699      	mov	r9, r3
 802f7dc:	46a2      	mov	sl, r4
 802f7de:	eb19 0905 	adds.w	r9, r9, r5
 802f7e2:	eb4a 0a06 	adc.w	sl, sl, r6
 802f7e6:	f04f 0100 	mov.w	r1, #0
 802f7ea:	f04f 0200 	mov.w	r2, #0
 802f7ee:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802f7f2:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802f7f6:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802f7fa:	4689      	mov	r9, r1
 802f7fc:	4692      	mov	sl, r2
 802f7fe:	eb19 0005 	adds.w	r0, r9, r5
 802f802:	eb4a 0106 	adc.w	r1, sl, r6
 802f806:	687b      	ldr	r3, [r7, #4]
 802f808:	685b      	ldr	r3, [r3, #4]
 802f80a:	461d      	mov	r5, r3
 802f80c:	f04f 0600 	mov.w	r6, #0
 802f810:	196b      	adds	r3, r5, r5
 802f812:	eb46 0406 	adc.w	r4, r6, r6
 802f816:	461a      	mov	r2, r3
 802f818:	4623      	mov	r3, r4
 802f81a:	f7f9 fca5 	bl	8029168 <__aeabi_uldivmod>
 802f81e:	4603      	mov	r3, r0
 802f820:	460c      	mov	r4, r1
 802f822:	461a      	mov	r2, r3
 802f824:	4b2c      	ldr	r3, [pc, #176]	; (802f8d8 <UART_SetConfig+0x384>)
 802f826:	fba3 1302 	umull	r1, r3, r3, r2
 802f82a:	095b      	lsrs	r3, r3, #5
 802f82c:	2164      	movs	r1, #100	; 0x64
 802f82e:	fb01 f303 	mul.w	r3, r1, r3
 802f832:	1ad3      	subs	r3, r2, r3
 802f834:	00db      	lsls	r3, r3, #3
 802f836:	3332      	adds	r3, #50	; 0x32
 802f838:	4a27      	ldr	r2, [pc, #156]	; (802f8d8 <UART_SetConfig+0x384>)
 802f83a:	fba2 2303 	umull	r2, r3, r2, r3
 802f83e:	095b      	lsrs	r3, r3, #5
 802f840:	005b      	lsls	r3, r3, #1
 802f842:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 802f846:	4498      	add	r8, r3
 802f848:	68bb      	ldr	r3, [r7, #8]
 802f84a:	461d      	mov	r5, r3
 802f84c:	f04f 0600 	mov.w	r6, #0
 802f850:	46a9      	mov	r9, r5
 802f852:	46b2      	mov	sl, r6
 802f854:	eb19 0309 	adds.w	r3, r9, r9
 802f858:	eb4a 040a 	adc.w	r4, sl, sl
 802f85c:	4699      	mov	r9, r3
 802f85e:	46a2      	mov	sl, r4
 802f860:	eb19 0905 	adds.w	r9, r9, r5
 802f864:	eb4a 0a06 	adc.w	sl, sl, r6
 802f868:	f04f 0100 	mov.w	r1, #0
 802f86c:	f04f 0200 	mov.w	r2, #0
 802f870:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802f874:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802f878:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802f87c:	4689      	mov	r9, r1
 802f87e:	4692      	mov	sl, r2
 802f880:	eb19 0005 	adds.w	r0, r9, r5
 802f884:	eb4a 0106 	adc.w	r1, sl, r6
 802f888:	687b      	ldr	r3, [r7, #4]
 802f88a:	685b      	ldr	r3, [r3, #4]
 802f88c:	461d      	mov	r5, r3
 802f88e:	f04f 0600 	mov.w	r6, #0
 802f892:	196b      	adds	r3, r5, r5
 802f894:	eb46 0406 	adc.w	r4, r6, r6
 802f898:	461a      	mov	r2, r3
 802f89a:	4623      	mov	r3, r4
 802f89c:	f7f9 fc64 	bl	8029168 <__aeabi_uldivmod>
 802f8a0:	4603      	mov	r3, r0
 802f8a2:	460c      	mov	r4, r1
 802f8a4:	461a      	mov	r2, r3
 802f8a6:	4b0c      	ldr	r3, [pc, #48]	; (802f8d8 <UART_SetConfig+0x384>)
 802f8a8:	fba3 1302 	umull	r1, r3, r3, r2
 802f8ac:	095b      	lsrs	r3, r3, #5
 802f8ae:	2164      	movs	r1, #100	; 0x64
 802f8b0:	fb01 f303 	mul.w	r3, r1, r3
 802f8b4:	1ad3      	subs	r3, r2, r3
 802f8b6:	00db      	lsls	r3, r3, #3
 802f8b8:	3332      	adds	r3, #50	; 0x32
 802f8ba:	4a07      	ldr	r2, [pc, #28]	; (802f8d8 <UART_SetConfig+0x384>)
 802f8bc:	fba2 2303 	umull	r2, r3, r2, r3
 802f8c0:	095b      	lsrs	r3, r3, #5
 802f8c2:	f003 0207 	and.w	r2, r3, #7
 802f8c6:	687b      	ldr	r3, [r7, #4]
 802f8c8:	681b      	ldr	r3, [r3, #0]
 802f8ca:	4442      	add	r2, r8
 802f8cc:	609a      	str	r2, [r3, #8]
    {
      pclk = HAL_RCC_GetPCLK1Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
    }
  }
}
 802f8ce:	e1b2      	b.n	802fc36 <UART_SetConfig+0x6e2>
 802f8d0:	40011000 	.word	0x40011000
 802f8d4:	40011400 	.word	0x40011400
 802f8d8:	51eb851f 	.word	0x51eb851f
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 802f8dc:	687b      	ldr	r3, [r7, #4]
 802f8de:	681b      	ldr	r3, [r3, #0]
 802f8e0:	4ad7      	ldr	r2, [pc, #860]	; (802fc40 <UART_SetConfig+0x6ec>)
 802f8e2:	4293      	cmp	r3, r2
 802f8e4:	d005      	beq.n	802f8f2 <UART_SetConfig+0x39e>
 802f8e6:	687b      	ldr	r3, [r7, #4]
 802f8e8:	681b      	ldr	r3, [r3, #0]
 802f8ea:	4ad6      	ldr	r2, [pc, #856]	; (802fc44 <UART_SetConfig+0x6f0>)
 802f8ec:	4293      	cmp	r3, r2
 802f8ee:	f040 80d1 	bne.w	802fa94 <UART_SetConfig+0x540>
      pclk = HAL_RCC_GetPCLK2Freq();
 802f8f2:	f7fd fdbf 	bl	802d474 <HAL_RCC_GetPCLK2Freq>
 802f8f6:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 802f8f8:	68bb      	ldr	r3, [r7, #8]
 802f8fa:	469a      	mov	sl, r3
 802f8fc:	f04f 0b00 	mov.w	fp, #0
 802f900:	46d0      	mov	r8, sl
 802f902:	46d9      	mov	r9, fp
 802f904:	eb18 0308 	adds.w	r3, r8, r8
 802f908:	eb49 0409 	adc.w	r4, r9, r9
 802f90c:	4698      	mov	r8, r3
 802f90e:	46a1      	mov	r9, r4
 802f910:	eb18 080a 	adds.w	r8, r8, sl
 802f914:	eb49 090b 	adc.w	r9, r9, fp
 802f918:	f04f 0100 	mov.w	r1, #0
 802f91c:	f04f 0200 	mov.w	r2, #0
 802f920:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802f924:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802f928:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802f92c:	4688      	mov	r8, r1
 802f92e:	4691      	mov	r9, r2
 802f930:	eb1a 0508 	adds.w	r5, sl, r8
 802f934:	eb4b 0609 	adc.w	r6, fp, r9
 802f938:	687b      	ldr	r3, [r7, #4]
 802f93a:	685b      	ldr	r3, [r3, #4]
 802f93c:	4619      	mov	r1, r3
 802f93e:	f04f 0200 	mov.w	r2, #0
 802f942:	f04f 0300 	mov.w	r3, #0
 802f946:	f04f 0400 	mov.w	r4, #0
 802f94a:	0094      	lsls	r4, r2, #2
 802f94c:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802f950:	008b      	lsls	r3, r1, #2
 802f952:	461a      	mov	r2, r3
 802f954:	4623      	mov	r3, r4
 802f956:	4628      	mov	r0, r5
 802f958:	4631      	mov	r1, r6
 802f95a:	f7f9 fc05 	bl	8029168 <__aeabi_uldivmod>
 802f95e:	4603      	mov	r3, r0
 802f960:	460c      	mov	r4, r1
 802f962:	461a      	mov	r2, r3
 802f964:	4bb8      	ldr	r3, [pc, #736]	; (802fc48 <UART_SetConfig+0x6f4>)
 802f966:	fba3 2302 	umull	r2, r3, r3, r2
 802f96a:	095b      	lsrs	r3, r3, #5
 802f96c:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802f970:	68bb      	ldr	r3, [r7, #8]
 802f972:	469b      	mov	fp, r3
 802f974:	f04f 0c00 	mov.w	ip, #0
 802f978:	46d9      	mov	r9, fp
 802f97a:	46e2      	mov	sl, ip
 802f97c:	eb19 0309 	adds.w	r3, r9, r9
 802f980:	eb4a 040a 	adc.w	r4, sl, sl
 802f984:	4699      	mov	r9, r3
 802f986:	46a2      	mov	sl, r4
 802f988:	eb19 090b 	adds.w	r9, r9, fp
 802f98c:	eb4a 0a0c 	adc.w	sl, sl, ip
 802f990:	f04f 0100 	mov.w	r1, #0
 802f994:	f04f 0200 	mov.w	r2, #0
 802f998:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802f99c:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802f9a0:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802f9a4:	4689      	mov	r9, r1
 802f9a6:	4692      	mov	sl, r2
 802f9a8:	eb1b 0509 	adds.w	r5, fp, r9
 802f9ac:	eb4c 060a 	adc.w	r6, ip, sl
 802f9b0:	687b      	ldr	r3, [r7, #4]
 802f9b2:	685b      	ldr	r3, [r3, #4]
 802f9b4:	4619      	mov	r1, r3
 802f9b6:	f04f 0200 	mov.w	r2, #0
 802f9ba:	f04f 0300 	mov.w	r3, #0
 802f9be:	f04f 0400 	mov.w	r4, #0
 802f9c2:	0094      	lsls	r4, r2, #2
 802f9c4:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802f9c8:	008b      	lsls	r3, r1, #2
 802f9ca:	461a      	mov	r2, r3
 802f9cc:	4623      	mov	r3, r4
 802f9ce:	4628      	mov	r0, r5
 802f9d0:	4631      	mov	r1, r6
 802f9d2:	f7f9 fbc9 	bl	8029168 <__aeabi_uldivmod>
 802f9d6:	4603      	mov	r3, r0
 802f9d8:	460c      	mov	r4, r1
 802f9da:	461a      	mov	r2, r3
 802f9dc:	4b9a      	ldr	r3, [pc, #616]	; (802fc48 <UART_SetConfig+0x6f4>)
 802f9de:	fba3 1302 	umull	r1, r3, r3, r2
 802f9e2:	095b      	lsrs	r3, r3, #5
 802f9e4:	2164      	movs	r1, #100	; 0x64
 802f9e6:	fb01 f303 	mul.w	r3, r1, r3
 802f9ea:	1ad3      	subs	r3, r2, r3
 802f9ec:	011b      	lsls	r3, r3, #4
 802f9ee:	3332      	adds	r3, #50	; 0x32
 802f9f0:	4a95      	ldr	r2, [pc, #596]	; (802fc48 <UART_SetConfig+0x6f4>)
 802f9f2:	fba2 2303 	umull	r2, r3, r2, r3
 802f9f6:	095b      	lsrs	r3, r3, #5
 802f9f8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802f9fc:	4498      	add	r8, r3
 802f9fe:	68bb      	ldr	r3, [r7, #8]
 802fa00:	469b      	mov	fp, r3
 802fa02:	f04f 0c00 	mov.w	ip, #0
 802fa06:	46d9      	mov	r9, fp
 802fa08:	46e2      	mov	sl, ip
 802fa0a:	eb19 0309 	adds.w	r3, r9, r9
 802fa0e:	eb4a 040a 	adc.w	r4, sl, sl
 802fa12:	4699      	mov	r9, r3
 802fa14:	46a2      	mov	sl, r4
 802fa16:	eb19 090b 	adds.w	r9, r9, fp
 802fa1a:	eb4a 0a0c 	adc.w	sl, sl, ip
 802fa1e:	f04f 0100 	mov.w	r1, #0
 802fa22:	f04f 0200 	mov.w	r2, #0
 802fa26:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802fa2a:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802fa2e:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802fa32:	4689      	mov	r9, r1
 802fa34:	4692      	mov	sl, r2
 802fa36:	eb1b 0509 	adds.w	r5, fp, r9
 802fa3a:	eb4c 060a 	adc.w	r6, ip, sl
 802fa3e:	687b      	ldr	r3, [r7, #4]
 802fa40:	685b      	ldr	r3, [r3, #4]
 802fa42:	4619      	mov	r1, r3
 802fa44:	f04f 0200 	mov.w	r2, #0
 802fa48:	f04f 0300 	mov.w	r3, #0
 802fa4c:	f04f 0400 	mov.w	r4, #0
 802fa50:	0094      	lsls	r4, r2, #2
 802fa52:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802fa56:	008b      	lsls	r3, r1, #2
 802fa58:	461a      	mov	r2, r3
 802fa5a:	4623      	mov	r3, r4
 802fa5c:	4628      	mov	r0, r5
 802fa5e:	4631      	mov	r1, r6
 802fa60:	f7f9 fb82 	bl	8029168 <__aeabi_uldivmod>
 802fa64:	4603      	mov	r3, r0
 802fa66:	460c      	mov	r4, r1
 802fa68:	461a      	mov	r2, r3
 802fa6a:	4b77      	ldr	r3, [pc, #476]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fa6c:	fba3 1302 	umull	r1, r3, r3, r2
 802fa70:	095b      	lsrs	r3, r3, #5
 802fa72:	2164      	movs	r1, #100	; 0x64
 802fa74:	fb01 f303 	mul.w	r3, r1, r3
 802fa78:	1ad3      	subs	r3, r2, r3
 802fa7a:	011b      	lsls	r3, r3, #4
 802fa7c:	3332      	adds	r3, #50	; 0x32
 802fa7e:	4a72      	ldr	r2, [pc, #456]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fa80:	fba2 2303 	umull	r2, r3, r2, r3
 802fa84:	095b      	lsrs	r3, r3, #5
 802fa86:	f003 020f 	and.w	r2, r3, #15
 802fa8a:	687b      	ldr	r3, [r7, #4]
 802fa8c:	681b      	ldr	r3, [r3, #0]
 802fa8e:	4442      	add	r2, r8
 802fa90:	609a      	str	r2, [r3, #8]
 802fa92:	e0d0      	b.n	802fc36 <UART_SetConfig+0x6e2>
      pclk = HAL_RCC_GetPCLK1Freq();
 802fa94:	f7fd fcda 	bl	802d44c <HAL_RCC_GetPCLK1Freq>
 802fa98:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 802fa9a:	68bb      	ldr	r3, [r7, #8]
 802fa9c:	469a      	mov	sl, r3
 802fa9e:	f04f 0b00 	mov.w	fp, #0
 802faa2:	46d0      	mov	r8, sl
 802faa4:	46d9      	mov	r9, fp
 802faa6:	eb18 0308 	adds.w	r3, r8, r8
 802faaa:	eb49 0409 	adc.w	r4, r9, r9
 802faae:	4698      	mov	r8, r3
 802fab0:	46a1      	mov	r9, r4
 802fab2:	eb18 080a 	adds.w	r8, r8, sl
 802fab6:	eb49 090b 	adc.w	r9, r9, fp
 802faba:	f04f 0100 	mov.w	r1, #0
 802fabe:	f04f 0200 	mov.w	r2, #0
 802fac2:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802fac6:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802faca:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802face:	4688      	mov	r8, r1
 802fad0:	4691      	mov	r9, r2
 802fad2:	eb1a 0508 	adds.w	r5, sl, r8
 802fad6:	eb4b 0609 	adc.w	r6, fp, r9
 802fada:	687b      	ldr	r3, [r7, #4]
 802fadc:	685b      	ldr	r3, [r3, #4]
 802fade:	4619      	mov	r1, r3
 802fae0:	f04f 0200 	mov.w	r2, #0
 802fae4:	f04f 0300 	mov.w	r3, #0
 802fae8:	f04f 0400 	mov.w	r4, #0
 802faec:	0094      	lsls	r4, r2, #2
 802faee:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802faf2:	008b      	lsls	r3, r1, #2
 802faf4:	461a      	mov	r2, r3
 802faf6:	4623      	mov	r3, r4
 802faf8:	4628      	mov	r0, r5
 802fafa:	4631      	mov	r1, r6
 802fafc:	f7f9 fb34 	bl	8029168 <__aeabi_uldivmod>
 802fb00:	4603      	mov	r3, r0
 802fb02:	460c      	mov	r4, r1
 802fb04:	461a      	mov	r2, r3
 802fb06:	4b50      	ldr	r3, [pc, #320]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fb08:	fba3 2302 	umull	r2, r3, r3, r2
 802fb0c:	095b      	lsrs	r3, r3, #5
 802fb0e:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802fb12:	68bb      	ldr	r3, [r7, #8]
 802fb14:	469b      	mov	fp, r3
 802fb16:	f04f 0c00 	mov.w	ip, #0
 802fb1a:	46d9      	mov	r9, fp
 802fb1c:	46e2      	mov	sl, ip
 802fb1e:	eb19 0309 	adds.w	r3, r9, r9
 802fb22:	eb4a 040a 	adc.w	r4, sl, sl
 802fb26:	4699      	mov	r9, r3
 802fb28:	46a2      	mov	sl, r4
 802fb2a:	eb19 090b 	adds.w	r9, r9, fp
 802fb2e:	eb4a 0a0c 	adc.w	sl, sl, ip
 802fb32:	f04f 0100 	mov.w	r1, #0
 802fb36:	f04f 0200 	mov.w	r2, #0
 802fb3a:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802fb3e:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802fb42:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802fb46:	4689      	mov	r9, r1
 802fb48:	4692      	mov	sl, r2
 802fb4a:	eb1b 0509 	adds.w	r5, fp, r9
 802fb4e:	eb4c 060a 	adc.w	r6, ip, sl
 802fb52:	687b      	ldr	r3, [r7, #4]
 802fb54:	685b      	ldr	r3, [r3, #4]
 802fb56:	4619      	mov	r1, r3
 802fb58:	f04f 0200 	mov.w	r2, #0
 802fb5c:	f04f 0300 	mov.w	r3, #0
 802fb60:	f04f 0400 	mov.w	r4, #0
 802fb64:	0094      	lsls	r4, r2, #2
 802fb66:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802fb6a:	008b      	lsls	r3, r1, #2
 802fb6c:	461a      	mov	r2, r3
 802fb6e:	4623      	mov	r3, r4
 802fb70:	4628      	mov	r0, r5
 802fb72:	4631      	mov	r1, r6
 802fb74:	f7f9 faf8 	bl	8029168 <__aeabi_uldivmod>
 802fb78:	4603      	mov	r3, r0
 802fb7a:	460c      	mov	r4, r1
 802fb7c:	461a      	mov	r2, r3
 802fb7e:	4b32      	ldr	r3, [pc, #200]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fb80:	fba3 1302 	umull	r1, r3, r3, r2
 802fb84:	095b      	lsrs	r3, r3, #5
 802fb86:	2164      	movs	r1, #100	; 0x64
 802fb88:	fb01 f303 	mul.w	r3, r1, r3
 802fb8c:	1ad3      	subs	r3, r2, r3
 802fb8e:	011b      	lsls	r3, r3, #4
 802fb90:	3332      	adds	r3, #50	; 0x32
 802fb92:	4a2d      	ldr	r2, [pc, #180]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fb94:	fba2 2303 	umull	r2, r3, r2, r3
 802fb98:	095b      	lsrs	r3, r3, #5
 802fb9a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802fb9e:	4498      	add	r8, r3
 802fba0:	68bb      	ldr	r3, [r7, #8]
 802fba2:	469b      	mov	fp, r3
 802fba4:	f04f 0c00 	mov.w	ip, #0
 802fba8:	46d9      	mov	r9, fp
 802fbaa:	46e2      	mov	sl, ip
 802fbac:	eb19 0309 	adds.w	r3, r9, r9
 802fbb0:	eb4a 040a 	adc.w	r4, sl, sl
 802fbb4:	4699      	mov	r9, r3
 802fbb6:	46a2      	mov	sl, r4
 802fbb8:	eb19 090b 	adds.w	r9, r9, fp
 802fbbc:	eb4a 0a0c 	adc.w	sl, sl, ip
 802fbc0:	f04f 0100 	mov.w	r1, #0
 802fbc4:	f04f 0200 	mov.w	r2, #0
 802fbc8:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802fbcc:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802fbd0:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802fbd4:	4689      	mov	r9, r1
 802fbd6:	4692      	mov	sl, r2
 802fbd8:	eb1b 0509 	adds.w	r5, fp, r9
 802fbdc:	eb4c 060a 	adc.w	r6, ip, sl
 802fbe0:	687b      	ldr	r3, [r7, #4]
 802fbe2:	685b      	ldr	r3, [r3, #4]
 802fbe4:	4619      	mov	r1, r3
 802fbe6:	f04f 0200 	mov.w	r2, #0
 802fbea:	f04f 0300 	mov.w	r3, #0
 802fbee:	f04f 0400 	mov.w	r4, #0
 802fbf2:	0094      	lsls	r4, r2, #2
 802fbf4:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802fbf8:	008b      	lsls	r3, r1, #2
 802fbfa:	461a      	mov	r2, r3
 802fbfc:	4623      	mov	r3, r4
 802fbfe:	4628      	mov	r0, r5
 802fc00:	4631      	mov	r1, r6
 802fc02:	f7f9 fab1 	bl	8029168 <__aeabi_uldivmod>
 802fc06:	4603      	mov	r3, r0
 802fc08:	460c      	mov	r4, r1
 802fc0a:	461a      	mov	r2, r3
 802fc0c:	4b0e      	ldr	r3, [pc, #56]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fc0e:	fba3 1302 	umull	r1, r3, r3, r2
 802fc12:	095b      	lsrs	r3, r3, #5
 802fc14:	2164      	movs	r1, #100	; 0x64
 802fc16:	fb01 f303 	mul.w	r3, r1, r3
 802fc1a:	1ad3      	subs	r3, r2, r3
 802fc1c:	011b      	lsls	r3, r3, #4
 802fc1e:	3332      	adds	r3, #50	; 0x32
 802fc20:	4a09      	ldr	r2, [pc, #36]	; (802fc48 <UART_SetConfig+0x6f4>)
 802fc22:	fba2 2303 	umull	r2, r3, r2, r3
 802fc26:	095b      	lsrs	r3, r3, #5
 802fc28:	f003 020f 	and.w	r2, r3, #15
 802fc2c:	687b      	ldr	r3, [r7, #4]
 802fc2e:	681b      	ldr	r3, [r3, #0]
 802fc30:	4442      	add	r2, r8
 802fc32:	609a      	str	r2, [r3, #8]
}
 802fc34:	e7ff      	b.n	802fc36 <UART_SetConfig+0x6e2>
 802fc36:	bf00      	nop
 802fc38:	3714      	adds	r7, #20
 802fc3a:	46bd      	mov	sp, r7
 802fc3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802fc40:	40011000 	.word	0x40011000
 802fc44:	40011400 	.word	0x40011400
 802fc48:	51eb851f 	.word	0x51eb851f

0802fc4c <abort>:
 802fc4c:	b508      	push	{r3, lr}
 802fc4e:	2006      	movs	r0, #6
 802fc50:	f000 fdf2 	bl	8030838 <raise>
 802fc54:	2001      	movs	r0, #1
 802fc56:	f7fb fe89 	bl	802b96c <_exit>
	...

0802fc5c <__errno>:
 802fc5c:	4b01      	ldr	r3, [pc, #4]	; (802fc64 <__errno+0x8>)
 802fc5e:	6818      	ldr	r0, [r3, #0]
 802fc60:	4770      	bx	lr
 802fc62:	bf00      	nop
 802fc64:	200005cc 	.word	0x200005cc

0802fc68 <__sflush_r>:
 802fc68:	898a      	ldrh	r2, [r1, #12]
 802fc6a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802fc6e:	4605      	mov	r5, r0
 802fc70:	0710      	lsls	r0, r2, #28
 802fc72:	460c      	mov	r4, r1
 802fc74:	d458      	bmi.n	802fd28 <__sflush_r+0xc0>
 802fc76:	684b      	ldr	r3, [r1, #4]
 802fc78:	2b00      	cmp	r3, #0
 802fc7a:	dc05      	bgt.n	802fc88 <__sflush_r+0x20>
 802fc7c:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 802fc7e:	2b00      	cmp	r3, #0
 802fc80:	dc02      	bgt.n	802fc88 <__sflush_r+0x20>
 802fc82:	2000      	movs	r0, #0
 802fc84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802fc88:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802fc8a:	2e00      	cmp	r6, #0
 802fc8c:	d0f9      	beq.n	802fc82 <__sflush_r+0x1a>
 802fc8e:	2300      	movs	r3, #0
 802fc90:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 802fc94:	682f      	ldr	r7, [r5, #0]
 802fc96:	6a21      	ldr	r1, [r4, #32]
 802fc98:	602b      	str	r3, [r5, #0]
 802fc9a:	d032      	beq.n	802fd02 <__sflush_r+0x9a>
 802fc9c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 802fc9e:	89a3      	ldrh	r3, [r4, #12]
 802fca0:	075a      	lsls	r2, r3, #29
 802fca2:	d505      	bpl.n	802fcb0 <__sflush_r+0x48>
 802fca4:	6863      	ldr	r3, [r4, #4]
 802fca6:	1ac0      	subs	r0, r0, r3
 802fca8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802fcaa:	b10b      	cbz	r3, 802fcb0 <__sflush_r+0x48>
 802fcac:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802fcae:	1ac0      	subs	r0, r0, r3
 802fcb0:	2300      	movs	r3, #0
 802fcb2:	4602      	mov	r2, r0
 802fcb4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802fcb6:	6a21      	ldr	r1, [r4, #32]
 802fcb8:	4628      	mov	r0, r5
 802fcba:	47b0      	blx	r6
 802fcbc:	1c43      	adds	r3, r0, #1
 802fcbe:	89a3      	ldrh	r3, [r4, #12]
 802fcc0:	d106      	bne.n	802fcd0 <__sflush_r+0x68>
 802fcc2:	6829      	ldr	r1, [r5, #0]
 802fcc4:	291d      	cmp	r1, #29
 802fcc6:	d848      	bhi.n	802fd5a <__sflush_r+0xf2>
 802fcc8:	4a29      	ldr	r2, [pc, #164]	; (802fd70 <__sflush_r+0x108>)
 802fcca:	40ca      	lsrs	r2, r1
 802fccc:	07d6      	lsls	r6, r2, #31
 802fcce:	d544      	bpl.n	802fd5a <__sflush_r+0xf2>
 802fcd0:	2200      	movs	r2, #0
 802fcd2:	6062      	str	r2, [r4, #4]
 802fcd4:	04d9      	lsls	r1, r3, #19
 802fcd6:	6922      	ldr	r2, [r4, #16]
 802fcd8:	6022      	str	r2, [r4, #0]
 802fcda:	d504      	bpl.n	802fce6 <__sflush_r+0x7e>
 802fcdc:	1c42      	adds	r2, r0, #1
 802fcde:	d101      	bne.n	802fce4 <__sflush_r+0x7c>
 802fce0:	682b      	ldr	r3, [r5, #0]
 802fce2:	b903      	cbnz	r3, 802fce6 <__sflush_r+0x7e>
 802fce4:	6560      	str	r0, [r4, #84]	; 0x54
 802fce6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802fce8:	602f      	str	r7, [r5, #0]
 802fcea:	2900      	cmp	r1, #0
 802fcec:	d0c9      	beq.n	802fc82 <__sflush_r+0x1a>
 802fcee:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802fcf2:	4299      	cmp	r1, r3
 802fcf4:	d002      	beq.n	802fcfc <__sflush_r+0x94>
 802fcf6:	4628      	mov	r0, r5
 802fcf8:	f000 f9ec 	bl	80300d4 <_free_r>
 802fcfc:	2000      	movs	r0, #0
 802fcfe:	6360      	str	r0, [r4, #52]	; 0x34
 802fd00:	e7c0      	b.n	802fc84 <__sflush_r+0x1c>
 802fd02:	2301      	movs	r3, #1
 802fd04:	4628      	mov	r0, r5
 802fd06:	47b0      	blx	r6
 802fd08:	1c41      	adds	r1, r0, #1
 802fd0a:	d1c8      	bne.n	802fc9e <__sflush_r+0x36>
 802fd0c:	682b      	ldr	r3, [r5, #0]
 802fd0e:	2b00      	cmp	r3, #0
 802fd10:	d0c5      	beq.n	802fc9e <__sflush_r+0x36>
 802fd12:	2b1d      	cmp	r3, #29
 802fd14:	d001      	beq.n	802fd1a <__sflush_r+0xb2>
 802fd16:	2b16      	cmp	r3, #22
 802fd18:	d101      	bne.n	802fd1e <__sflush_r+0xb6>
 802fd1a:	602f      	str	r7, [r5, #0]
 802fd1c:	e7b1      	b.n	802fc82 <__sflush_r+0x1a>
 802fd1e:	89a3      	ldrh	r3, [r4, #12]
 802fd20:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802fd24:	81a3      	strh	r3, [r4, #12]
 802fd26:	e7ad      	b.n	802fc84 <__sflush_r+0x1c>
 802fd28:	690f      	ldr	r7, [r1, #16]
 802fd2a:	2f00      	cmp	r7, #0
 802fd2c:	d0a9      	beq.n	802fc82 <__sflush_r+0x1a>
 802fd2e:	0793      	lsls	r3, r2, #30
 802fd30:	680e      	ldr	r6, [r1, #0]
 802fd32:	bf08      	it	eq
 802fd34:	694b      	ldreq	r3, [r1, #20]
 802fd36:	600f      	str	r7, [r1, #0]
 802fd38:	bf18      	it	ne
 802fd3a:	2300      	movne	r3, #0
 802fd3c:	eba6 0807 	sub.w	r8, r6, r7
 802fd40:	608b      	str	r3, [r1, #8]
 802fd42:	f1b8 0f00 	cmp.w	r8, #0
 802fd46:	dd9c      	ble.n	802fc82 <__sflush_r+0x1a>
 802fd48:	4643      	mov	r3, r8
 802fd4a:	463a      	mov	r2, r7
 802fd4c:	6a21      	ldr	r1, [r4, #32]
 802fd4e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 802fd50:	4628      	mov	r0, r5
 802fd52:	47b0      	blx	r6
 802fd54:	2800      	cmp	r0, #0
 802fd56:	dc06      	bgt.n	802fd66 <__sflush_r+0xfe>
 802fd58:	89a3      	ldrh	r3, [r4, #12]
 802fd5a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802fd5e:	81a3      	strh	r3, [r4, #12]
 802fd60:	f04f 30ff 	mov.w	r0, #4294967295
 802fd64:	e78e      	b.n	802fc84 <__sflush_r+0x1c>
 802fd66:	4407      	add	r7, r0
 802fd68:	eba8 0800 	sub.w	r8, r8, r0
 802fd6c:	e7e9      	b.n	802fd42 <__sflush_r+0xda>
 802fd6e:	bf00      	nop
 802fd70:	20400001 	.word	0x20400001

0802fd74 <_fflush_r>:
 802fd74:	b538      	push	{r3, r4, r5, lr}
 802fd76:	690b      	ldr	r3, [r1, #16]
 802fd78:	4605      	mov	r5, r0
 802fd7a:	460c      	mov	r4, r1
 802fd7c:	b1db      	cbz	r3, 802fdb6 <_fflush_r+0x42>
 802fd7e:	b118      	cbz	r0, 802fd88 <_fflush_r+0x14>
 802fd80:	6983      	ldr	r3, [r0, #24]
 802fd82:	b90b      	cbnz	r3, 802fd88 <_fflush_r+0x14>
 802fd84:	f000 f872 	bl	802fe6c <__sinit>
 802fd88:	4b0c      	ldr	r3, [pc, #48]	; (802fdbc <_fflush_r+0x48>)
 802fd8a:	429c      	cmp	r4, r3
 802fd8c:	d109      	bne.n	802fda2 <_fflush_r+0x2e>
 802fd8e:	686c      	ldr	r4, [r5, #4]
 802fd90:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802fd94:	b17b      	cbz	r3, 802fdb6 <_fflush_r+0x42>
 802fd96:	4621      	mov	r1, r4
 802fd98:	4628      	mov	r0, r5
 802fd9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802fd9e:	f7ff bf63 	b.w	802fc68 <__sflush_r>
 802fda2:	4b07      	ldr	r3, [pc, #28]	; (802fdc0 <_fflush_r+0x4c>)
 802fda4:	429c      	cmp	r4, r3
 802fda6:	d101      	bne.n	802fdac <_fflush_r+0x38>
 802fda8:	68ac      	ldr	r4, [r5, #8]
 802fdaa:	e7f1      	b.n	802fd90 <_fflush_r+0x1c>
 802fdac:	4b05      	ldr	r3, [pc, #20]	; (802fdc4 <_fflush_r+0x50>)
 802fdae:	429c      	cmp	r4, r3
 802fdb0:	bf08      	it	eq
 802fdb2:	68ec      	ldreq	r4, [r5, #12]
 802fdb4:	e7ec      	b.n	802fd90 <_fflush_r+0x1c>
 802fdb6:	2000      	movs	r0, #0
 802fdb8:	bd38      	pop	{r3, r4, r5, pc}
 802fdba:	bf00      	nop
 802fdbc:	08031420 	.word	0x08031420
 802fdc0:	08031440 	.word	0x08031440
 802fdc4:	08031400 	.word	0x08031400

0802fdc8 <fflush>:
 802fdc8:	4601      	mov	r1, r0
 802fdca:	b920      	cbnz	r0, 802fdd6 <fflush+0xe>
 802fdcc:	4b04      	ldr	r3, [pc, #16]	; (802fde0 <fflush+0x18>)
 802fdce:	4905      	ldr	r1, [pc, #20]	; (802fde4 <fflush+0x1c>)
 802fdd0:	6818      	ldr	r0, [r3, #0]
 802fdd2:	f000 b8c9 	b.w	802ff68 <_fwalk_reent>
 802fdd6:	4b04      	ldr	r3, [pc, #16]	; (802fde8 <fflush+0x20>)
 802fdd8:	6818      	ldr	r0, [r3, #0]
 802fdda:	f7ff bfcb 	b.w	802fd74 <_fflush_r>
 802fdde:	bf00      	nop
 802fde0:	08031460 	.word	0x08031460
 802fde4:	0802fd75 	.word	0x0802fd75
 802fde8:	200005cc 	.word	0x200005cc

0802fdec <std>:
 802fdec:	2300      	movs	r3, #0
 802fdee:	b510      	push	{r4, lr}
 802fdf0:	4604      	mov	r4, r0
 802fdf2:	e9c0 3300 	strd	r3, r3, [r0]
 802fdf6:	6083      	str	r3, [r0, #8]
 802fdf8:	8181      	strh	r1, [r0, #12]
 802fdfa:	6643      	str	r3, [r0, #100]	; 0x64
 802fdfc:	81c2      	strh	r2, [r0, #14]
 802fdfe:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802fe02:	6183      	str	r3, [r0, #24]
 802fe04:	4619      	mov	r1, r3
 802fe06:	2208      	movs	r2, #8
 802fe08:	305c      	adds	r0, #92	; 0x5c
 802fe0a:	f000 f95b 	bl	80300c4 <memset>
 802fe0e:	4b05      	ldr	r3, [pc, #20]	; (802fe24 <std+0x38>)
 802fe10:	6263      	str	r3, [r4, #36]	; 0x24
 802fe12:	4b05      	ldr	r3, [pc, #20]	; (802fe28 <std+0x3c>)
 802fe14:	62a3      	str	r3, [r4, #40]	; 0x28
 802fe16:	4b05      	ldr	r3, [pc, #20]	; (802fe2c <std+0x40>)
 802fe18:	62e3      	str	r3, [r4, #44]	; 0x2c
 802fe1a:	4b05      	ldr	r3, [pc, #20]	; (802fe30 <std+0x44>)
 802fe1c:	6224      	str	r4, [r4, #32]
 802fe1e:	6323      	str	r3, [r4, #48]	; 0x30
 802fe20:	bd10      	pop	{r4, pc}
 802fe22:	bf00      	nop
 802fe24:	08030871 	.word	0x08030871
 802fe28:	08030893 	.word	0x08030893
 802fe2c:	080308cb 	.word	0x080308cb
 802fe30:	080308ef 	.word	0x080308ef

0802fe34 <_cleanup_r>:
 802fe34:	4901      	ldr	r1, [pc, #4]	; (802fe3c <_cleanup_r+0x8>)
 802fe36:	f000 b897 	b.w	802ff68 <_fwalk_reent>
 802fe3a:	bf00      	nop
 802fe3c:	0802fd75 	.word	0x0802fd75

0802fe40 <__sfmoreglue>:
 802fe40:	b570      	push	{r4, r5, r6, lr}
 802fe42:	1e4a      	subs	r2, r1, #1
 802fe44:	2568      	movs	r5, #104	; 0x68
 802fe46:	4355      	muls	r5, r2
 802fe48:	460e      	mov	r6, r1
 802fe4a:	f105 0174 	add.w	r1, r5, #116	; 0x74
 802fe4e:	f000 f98f 	bl	8030170 <_malloc_r>
 802fe52:	4604      	mov	r4, r0
 802fe54:	b140      	cbz	r0, 802fe68 <__sfmoreglue+0x28>
 802fe56:	2100      	movs	r1, #0
 802fe58:	e9c0 1600 	strd	r1, r6, [r0]
 802fe5c:	300c      	adds	r0, #12
 802fe5e:	60a0      	str	r0, [r4, #8]
 802fe60:	f105 0268 	add.w	r2, r5, #104	; 0x68
 802fe64:	f000 f92e 	bl	80300c4 <memset>
 802fe68:	4620      	mov	r0, r4
 802fe6a:	bd70      	pop	{r4, r5, r6, pc}

0802fe6c <__sinit>:
 802fe6c:	6983      	ldr	r3, [r0, #24]
 802fe6e:	b510      	push	{r4, lr}
 802fe70:	4604      	mov	r4, r0
 802fe72:	bb33      	cbnz	r3, 802fec2 <__sinit+0x56>
 802fe74:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 802fe78:	6503      	str	r3, [r0, #80]	; 0x50
 802fe7a:	4b12      	ldr	r3, [pc, #72]	; (802fec4 <__sinit+0x58>)
 802fe7c:	4a12      	ldr	r2, [pc, #72]	; (802fec8 <__sinit+0x5c>)
 802fe7e:	681b      	ldr	r3, [r3, #0]
 802fe80:	6282      	str	r2, [r0, #40]	; 0x28
 802fe82:	4298      	cmp	r0, r3
 802fe84:	bf04      	itt	eq
 802fe86:	2301      	moveq	r3, #1
 802fe88:	6183      	streq	r3, [r0, #24]
 802fe8a:	f000 f81f 	bl	802fecc <__sfp>
 802fe8e:	6060      	str	r0, [r4, #4]
 802fe90:	4620      	mov	r0, r4
 802fe92:	f000 f81b 	bl	802fecc <__sfp>
 802fe96:	60a0      	str	r0, [r4, #8]
 802fe98:	4620      	mov	r0, r4
 802fe9a:	f000 f817 	bl	802fecc <__sfp>
 802fe9e:	2200      	movs	r2, #0
 802fea0:	60e0      	str	r0, [r4, #12]
 802fea2:	2104      	movs	r1, #4
 802fea4:	6860      	ldr	r0, [r4, #4]
 802fea6:	f7ff ffa1 	bl	802fdec <std>
 802feaa:	2201      	movs	r2, #1
 802feac:	2109      	movs	r1, #9
 802feae:	68a0      	ldr	r0, [r4, #8]
 802feb0:	f7ff ff9c 	bl	802fdec <std>
 802feb4:	2202      	movs	r2, #2
 802feb6:	2112      	movs	r1, #18
 802feb8:	68e0      	ldr	r0, [r4, #12]
 802feba:	f7ff ff97 	bl	802fdec <std>
 802febe:	2301      	movs	r3, #1
 802fec0:	61a3      	str	r3, [r4, #24]
 802fec2:	bd10      	pop	{r4, pc}
 802fec4:	08031460 	.word	0x08031460
 802fec8:	0802fe35 	.word	0x0802fe35

0802fecc <__sfp>:
 802fecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fece:	4b1b      	ldr	r3, [pc, #108]	; (802ff3c <__sfp+0x70>)
 802fed0:	681e      	ldr	r6, [r3, #0]
 802fed2:	69b3      	ldr	r3, [r6, #24]
 802fed4:	4607      	mov	r7, r0
 802fed6:	b913      	cbnz	r3, 802fede <__sfp+0x12>
 802fed8:	4630      	mov	r0, r6
 802feda:	f7ff ffc7 	bl	802fe6c <__sinit>
 802fede:	3648      	adds	r6, #72	; 0x48
 802fee0:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 802fee4:	3b01      	subs	r3, #1
 802fee6:	d503      	bpl.n	802fef0 <__sfp+0x24>
 802fee8:	6833      	ldr	r3, [r6, #0]
 802feea:	b133      	cbz	r3, 802fefa <__sfp+0x2e>
 802feec:	6836      	ldr	r6, [r6, #0]
 802feee:	e7f7      	b.n	802fee0 <__sfp+0x14>
 802fef0:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 802fef4:	b16d      	cbz	r5, 802ff12 <__sfp+0x46>
 802fef6:	3468      	adds	r4, #104	; 0x68
 802fef8:	e7f4      	b.n	802fee4 <__sfp+0x18>
 802fefa:	2104      	movs	r1, #4
 802fefc:	4638      	mov	r0, r7
 802fefe:	f7ff ff9f 	bl	802fe40 <__sfmoreglue>
 802ff02:	6030      	str	r0, [r6, #0]
 802ff04:	2800      	cmp	r0, #0
 802ff06:	d1f1      	bne.n	802feec <__sfp+0x20>
 802ff08:	230c      	movs	r3, #12
 802ff0a:	603b      	str	r3, [r7, #0]
 802ff0c:	4604      	mov	r4, r0
 802ff0e:	4620      	mov	r0, r4
 802ff10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802ff12:	4b0b      	ldr	r3, [pc, #44]	; (802ff40 <__sfp+0x74>)
 802ff14:	6665      	str	r5, [r4, #100]	; 0x64
 802ff16:	e9c4 5500 	strd	r5, r5, [r4]
 802ff1a:	60a5      	str	r5, [r4, #8]
 802ff1c:	e9c4 3503 	strd	r3, r5, [r4, #12]
 802ff20:	e9c4 5505 	strd	r5, r5, [r4, #20]
 802ff24:	2208      	movs	r2, #8
 802ff26:	4629      	mov	r1, r5
 802ff28:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 802ff2c:	f000 f8ca 	bl	80300c4 <memset>
 802ff30:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 802ff34:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 802ff38:	e7e9      	b.n	802ff0e <__sfp+0x42>
 802ff3a:	bf00      	nop
 802ff3c:	08031460 	.word	0x08031460
 802ff40:	ffff0001 	.word	0xffff0001

0802ff44 <fiprintf>:
 802ff44:	b40e      	push	{r1, r2, r3}
 802ff46:	b503      	push	{r0, r1, lr}
 802ff48:	4601      	mov	r1, r0
 802ff4a:	ab03      	add	r3, sp, #12
 802ff4c:	4805      	ldr	r0, [pc, #20]	; (802ff64 <fiprintf+0x20>)
 802ff4e:	f853 2b04 	ldr.w	r2, [r3], #4
 802ff52:	6800      	ldr	r0, [r0, #0]
 802ff54:	9301      	str	r3, [sp, #4]
 802ff56:	f000 f98f 	bl	8030278 <_vfiprintf_r>
 802ff5a:	b002      	add	sp, #8
 802ff5c:	f85d eb04 	ldr.w	lr, [sp], #4
 802ff60:	b003      	add	sp, #12
 802ff62:	4770      	bx	lr
 802ff64:	200005cc 	.word	0x200005cc

0802ff68 <_fwalk_reent>:
 802ff68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802ff6c:	4680      	mov	r8, r0
 802ff6e:	4689      	mov	r9, r1
 802ff70:	f100 0448 	add.w	r4, r0, #72	; 0x48
 802ff74:	2600      	movs	r6, #0
 802ff76:	b914      	cbnz	r4, 802ff7e <_fwalk_reent+0x16>
 802ff78:	4630      	mov	r0, r6
 802ff7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802ff7e:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 802ff82:	3f01      	subs	r7, #1
 802ff84:	d501      	bpl.n	802ff8a <_fwalk_reent+0x22>
 802ff86:	6824      	ldr	r4, [r4, #0]
 802ff88:	e7f5      	b.n	802ff76 <_fwalk_reent+0xe>
 802ff8a:	89ab      	ldrh	r3, [r5, #12]
 802ff8c:	2b01      	cmp	r3, #1
 802ff8e:	d907      	bls.n	802ffa0 <_fwalk_reent+0x38>
 802ff90:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 802ff94:	3301      	adds	r3, #1
 802ff96:	d003      	beq.n	802ffa0 <_fwalk_reent+0x38>
 802ff98:	4629      	mov	r1, r5
 802ff9a:	4640      	mov	r0, r8
 802ff9c:	47c8      	blx	r9
 802ff9e:	4306      	orrs	r6, r0
 802ffa0:	3568      	adds	r5, #104	; 0x68
 802ffa2:	e7ee      	b.n	802ff82 <_fwalk_reent+0x1a>

0802ffa4 <_fwrite_r>:
 802ffa4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802ffa8:	9c08      	ldr	r4, [sp, #32]
 802ffaa:	4689      	mov	r9, r1
 802ffac:	4617      	mov	r7, r2
 802ffae:	fb02 f803 	mul.w	r8, r2, r3
 802ffb2:	4606      	mov	r6, r0
 802ffb4:	b118      	cbz	r0, 802ffbe <_fwrite_r+0x1a>
 802ffb6:	6983      	ldr	r3, [r0, #24]
 802ffb8:	b90b      	cbnz	r3, 802ffbe <_fwrite_r+0x1a>
 802ffba:	f7ff ff57 	bl	802fe6c <__sinit>
 802ffbe:	4b1d      	ldr	r3, [pc, #116]	; (8030034 <_fwrite_r+0x90>)
 802ffc0:	429c      	cmp	r4, r3
 802ffc2:	d11a      	bne.n	802fffa <_fwrite_r+0x56>
 802ffc4:	6874      	ldr	r4, [r6, #4]
 802ffc6:	89a3      	ldrh	r3, [r4, #12]
 802ffc8:	071b      	lsls	r3, r3, #28
 802ffca:	d520      	bpl.n	803000e <_fwrite_r+0x6a>
 802ffcc:	6923      	ldr	r3, [r4, #16]
 802ffce:	b1f3      	cbz	r3, 803000e <_fwrite_r+0x6a>
 802ffd0:	2500      	movs	r5, #0
 802ffd2:	4545      	cmp	r5, r8
 802ffd4:	d029      	beq.n	803002a <_fwrite_r+0x86>
 802ffd6:	68a3      	ldr	r3, [r4, #8]
 802ffd8:	f819 1005 	ldrb.w	r1, [r9, r5]
 802ffdc:	3b01      	subs	r3, #1
 802ffde:	2b00      	cmp	r3, #0
 802ffe0:	60a3      	str	r3, [r4, #8]
 802ffe2:	da04      	bge.n	802ffee <_fwrite_r+0x4a>
 802ffe4:	69a2      	ldr	r2, [r4, #24]
 802ffe6:	4293      	cmp	r3, r2
 802ffe8:	db19      	blt.n	803001e <_fwrite_r+0x7a>
 802ffea:	290a      	cmp	r1, #10
 802ffec:	d017      	beq.n	803001e <_fwrite_r+0x7a>
 802ffee:	6823      	ldr	r3, [r4, #0]
 802fff0:	1c5a      	adds	r2, r3, #1
 802fff2:	6022      	str	r2, [r4, #0]
 802fff4:	7019      	strb	r1, [r3, #0]
 802fff6:	3501      	adds	r5, #1
 802fff8:	e7eb      	b.n	802ffd2 <_fwrite_r+0x2e>
 802fffa:	4b0f      	ldr	r3, [pc, #60]	; (8030038 <_fwrite_r+0x94>)
 802fffc:	429c      	cmp	r4, r3
 802fffe:	d101      	bne.n	8030004 <_fwrite_r+0x60>
 8030000:	68b4      	ldr	r4, [r6, #8]
 8030002:	e7e0      	b.n	802ffc6 <_fwrite_r+0x22>
 8030004:	4b0d      	ldr	r3, [pc, #52]	; (803003c <_fwrite_r+0x98>)
 8030006:	429c      	cmp	r4, r3
 8030008:	bf08      	it	eq
 803000a:	68f4      	ldreq	r4, [r6, #12]
 803000c:	e7db      	b.n	802ffc6 <_fwrite_r+0x22>
 803000e:	4621      	mov	r1, r4
 8030010:	4630      	mov	r0, r6
 8030012:	f000 fcd5 	bl	80309c0 <__swsetup_r>
 8030016:	2800      	cmp	r0, #0
 8030018:	d0da      	beq.n	802ffd0 <_fwrite_r+0x2c>
 803001a:	2500      	movs	r5, #0
 803001c:	e005      	b.n	803002a <_fwrite_r+0x86>
 803001e:	4622      	mov	r2, r4
 8030020:	4630      	mov	r0, r6
 8030022:	f000 fc69 	bl	80308f8 <__swbuf_r>
 8030026:	3001      	adds	r0, #1
 8030028:	d1e5      	bne.n	802fff6 <_fwrite_r+0x52>
 803002a:	fbb5 f0f7 	udiv	r0, r5, r7
 803002e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8030032:	bf00      	nop
 8030034:	08031420 	.word	0x08031420
 8030038:	08031440 	.word	0x08031440
 803003c:	08031400 	.word	0x08031400

08030040 <fwrite>:
 8030040:	b507      	push	{r0, r1, r2, lr}
 8030042:	9300      	str	r3, [sp, #0]
 8030044:	4613      	mov	r3, r2
 8030046:	460a      	mov	r2, r1
 8030048:	4601      	mov	r1, r0
 803004a:	4803      	ldr	r0, [pc, #12]	; (8030058 <fwrite+0x18>)
 803004c:	6800      	ldr	r0, [r0, #0]
 803004e:	f7ff ffa9 	bl	802ffa4 <_fwrite_r>
 8030052:	b003      	add	sp, #12
 8030054:	f85d fb04 	ldr.w	pc, [sp], #4
 8030058:	200005cc 	.word	0x200005cc

0803005c <__libc_init_array>:
 803005c:	b570      	push	{r4, r5, r6, lr}
 803005e:	4e0d      	ldr	r6, [pc, #52]	; (8030094 <__libc_init_array+0x38>)
 8030060:	4c0d      	ldr	r4, [pc, #52]	; (8030098 <__libc_init_array+0x3c>)
 8030062:	1ba4      	subs	r4, r4, r6
 8030064:	10a4      	asrs	r4, r4, #2
 8030066:	2500      	movs	r5, #0
 8030068:	42a5      	cmp	r5, r4
 803006a:	d109      	bne.n	8030080 <__libc_init_array+0x24>
 803006c:	4e0b      	ldr	r6, [pc, #44]	; (803009c <__libc_init_array+0x40>)
 803006e:	4c0c      	ldr	r4, [pc, #48]	; (80300a0 <__libc_init_array+0x44>)
 8030070:	f000 fedc 	bl	8030e2c <_init>
 8030074:	1ba4      	subs	r4, r4, r6
 8030076:	10a4      	asrs	r4, r4, #2
 8030078:	2500      	movs	r5, #0
 803007a:	42a5      	cmp	r5, r4
 803007c:	d105      	bne.n	803008a <__libc_init_array+0x2e>
 803007e:	bd70      	pop	{r4, r5, r6, pc}
 8030080:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8030084:	4798      	blx	r3
 8030086:	3501      	adds	r5, #1
 8030088:	e7ee      	b.n	8030068 <__libc_init_array+0xc>
 803008a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 803008e:	4798      	blx	r3
 8030090:	3501      	adds	r5, #1
 8030092:	e7f2      	b.n	803007a <__libc_init_array+0x1e>
 8030094:	080314a4 	.word	0x080314a4
 8030098:	080314a4 	.word	0x080314a4
 803009c:	080314a4 	.word	0x080314a4
 80300a0:	080314a8 	.word	0x080314a8

080300a4 <malloc>:
 80300a4:	4b02      	ldr	r3, [pc, #8]	; (80300b0 <malloc+0xc>)
 80300a6:	4601      	mov	r1, r0
 80300a8:	6818      	ldr	r0, [r3, #0]
 80300aa:	f000 b861 	b.w	8030170 <_malloc_r>
 80300ae:	bf00      	nop
 80300b0:	200005cc 	.word	0x200005cc

080300b4 <free>:
 80300b4:	4b02      	ldr	r3, [pc, #8]	; (80300c0 <free+0xc>)
 80300b6:	4601      	mov	r1, r0
 80300b8:	6818      	ldr	r0, [r3, #0]
 80300ba:	f000 b80b 	b.w	80300d4 <_free_r>
 80300be:	bf00      	nop
 80300c0:	200005cc 	.word	0x200005cc

080300c4 <memset>:
 80300c4:	4402      	add	r2, r0
 80300c6:	4603      	mov	r3, r0
 80300c8:	4293      	cmp	r3, r2
 80300ca:	d100      	bne.n	80300ce <memset+0xa>
 80300cc:	4770      	bx	lr
 80300ce:	f803 1b01 	strb.w	r1, [r3], #1
 80300d2:	e7f9      	b.n	80300c8 <memset+0x4>

080300d4 <_free_r>:
 80300d4:	b538      	push	{r3, r4, r5, lr}
 80300d6:	4605      	mov	r5, r0
 80300d8:	2900      	cmp	r1, #0
 80300da:	d045      	beq.n	8030168 <_free_r+0x94>
 80300dc:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80300e0:	1f0c      	subs	r4, r1, #4
 80300e2:	2b00      	cmp	r3, #0
 80300e4:	bfb8      	it	lt
 80300e6:	18e4      	addlt	r4, r4, r3
 80300e8:	f000 fd5e 	bl	8030ba8 <__malloc_lock>
 80300ec:	4a1f      	ldr	r2, [pc, #124]	; (803016c <_free_r+0x98>)
 80300ee:	6813      	ldr	r3, [r2, #0]
 80300f0:	4610      	mov	r0, r2
 80300f2:	b933      	cbnz	r3, 8030102 <_free_r+0x2e>
 80300f4:	6063      	str	r3, [r4, #4]
 80300f6:	6014      	str	r4, [r2, #0]
 80300f8:	4628      	mov	r0, r5
 80300fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80300fe:	f000 bd54 	b.w	8030baa <__malloc_unlock>
 8030102:	42a3      	cmp	r3, r4
 8030104:	d90c      	bls.n	8030120 <_free_r+0x4c>
 8030106:	6821      	ldr	r1, [r4, #0]
 8030108:	1862      	adds	r2, r4, r1
 803010a:	4293      	cmp	r3, r2
 803010c:	bf04      	itt	eq
 803010e:	681a      	ldreq	r2, [r3, #0]
 8030110:	685b      	ldreq	r3, [r3, #4]
 8030112:	6063      	str	r3, [r4, #4]
 8030114:	bf04      	itt	eq
 8030116:	1852      	addeq	r2, r2, r1
 8030118:	6022      	streq	r2, [r4, #0]
 803011a:	6004      	str	r4, [r0, #0]
 803011c:	e7ec      	b.n	80300f8 <_free_r+0x24>
 803011e:	4613      	mov	r3, r2
 8030120:	685a      	ldr	r2, [r3, #4]
 8030122:	b10a      	cbz	r2, 8030128 <_free_r+0x54>
 8030124:	42a2      	cmp	r2, r4
 8030126:	d9fa      	bls.n	803011e <_free_r+0x4a>
 8030128:	6819      	ldr	r1, [r3, #0]
 803012a:	1858      	adds	r0, r3, r1
 803012c:	42a0      	cmp	r0, r4
 803012e:	d10b      	bne.n	8030148 <_free_r+0x74>
 8030130:	6820      	ldr	r0, [r4, #0]
 8030132:	4401      	add	r1, r0
 8030134:	1858      	adds	r0, r3, r1
 8030136:	4282      	cmp	r2, r0
 8030138:	6019      	str	r1, [r3, #0]
 803013a:	d1dd      	bne.n	80300f8 <_free_r+0x24>
 803013c:	6810      	ldr	r0, [r2, #0]
 803013e:	6852      	ldr	r2, [r2, #4]
 8030140:	605a      	str	r2, [r3, #4]
 8030142:	4401      	add	r1, r0
 8030144:	6019      	str	r1, [r3, #0]
 8030146:	e7d7      	b.n	80300f8 <_free_r+0x24>
 8030148:	d902      	bls.n	8030150 <_free_r+0x7c>
 803014a:	230c      	movs	r3, #12
 803014c:	602b      	str	r3, [r5, #0]
 803014e:	e7d3      	b.n	80300f8 <_free_r+0x24>
 8030150:	6820      	ldr	r0, [r4, #0]
 8030152:	1821      	adds	r1, r4, r0
 8030154:	428a      	cmp	r2, r1
 8030156:	bf04      	itt	eq
 8030158:	6811      	ldreq	r1, [r2, #0]
 803015a:	6852      	ldreq	r2, [r2, #4]
 803015c:	6062      	str	r2, [r4, #4]
 803015e:	bf04      	itt	eq
 8030160:	1809      	addeq	r1, r1, r0
 8030162:	6021      	streq	r1, [r4, #0]
 8030164:	605c      	str	r4, [r3, #4]
 8030166:	e7c7      	b.n	80300f8 <_free_r+0x24>
 8030168:	bd38      	pop	{r3, r4, r5, pc}
 803016a:	bf00      	nop
 803016c:	20001a18 	.word	0x20001a18

08030170 <_malloc_r>:
 8030170:	b570      	push	{r4, r5, r6, lr}
 8030172:	1ccd      	adds	r5, r1, #3
 8030174:	f025 0503 	bic.w	r5, r5, #3
 8030178:	3508      	adds	r5, #8
 803017a:	2d0c      	cmp	r5, #12
 803017c:	bf38      	it	cc
 803017e:	250c      	movcc	r5, #12
 8030180:	2d00      	cmp	r5, #0
 8030182:	4606      	mov	r6, r0
 8030184:	db01      	blt.n	803018a <_malloc_r+0x1a>
 8030186:	42a9      	cmp	r1, r5
 8030188:	d903      	bls.n	8030192 <_malloc_r+0x22>
 803018a:	230c      	movs	r3, #12
 803018c:	6033      	str	r3, [r6, #0]
 803018e:	2000      	movs	r0, #0
 8030190:	bd70      	pop	{r4, r5, r6, pc}
 8030192:	f000 fd09 	bl	8030ba8 <__malloc_lock>
 8030196:	4a21      	ldr	r2, [pc, #132]	; (803021c <_malloc_r+0xac>)
 8030198:	6814      	ldr	r4, [r2, #0]
 803019a:	4621      	mov	r1, r4
 803019c:	b991      	cbnz	r1, 80301c4 <_malloc_r+0x54>
 803019e:	4c20      	ldr	r4, [pc, #128]	; (8030220 <_malloc_r+0xb0>)
 80301a0:	6823      	ldr	r3, [r4, #0]
 80301a2:	b91b      	cbnz	r3, 80301ac <_malloc_r+0x3c>
 80301a4:	4630      	mov	r0, r6
 80301a6:	f000 fb0f 	bl	80307c8 <_sbrk_r>
 80301aa:	6020      	str	r0, [r4, #0]
 80301ac:	4629      	mov	r1, r5
 80301ae:	4630      	mov	r0, r6
 80301b0:	f000 fb0a 	bl	80307c8 <_sbrk_r>
 80301b4:	1c43      	adds	r3, r0, #1
 80301b6:	d124      	bne.n	8030202 <_malloc_r+0x92>
 80301b8:	230c      	movs	r3, #12
 80301ba:	6033      	str	r3, [r6, #0]
 80301bc:	4630      	mov	r0, r6
 80301be:	f000 fcf4 	bl	8030baa <__malloc_unlock>
 80301c2:	e7e4      	b.n	803018e <_malloc_r+0x1e>
 80301c4:	680b      	ldr	r3, [r1, #0]
 80301c6:	1b5b      	subs	r3, r3, r5
 80301c8:	d418      	bmi.n	80301fc <_malloc_r+0x8c>
 80301ca:	2b0b      	cmp	r3, #11
 80301cc:	d90f      	bls.n	80301ee <_malloc_r+0x7e>
 80301ce:	600b      	str	r3, [r1, #0]
 80301d0:	50cd      	str	r5, [r1, r3]
 80301d2:	18cc      	adds	r4, r1, r3
 80301d4:	4630      	mov	r0, r6
 80301d6:	f000 fce8 	bl	8030baa <__malloc_unlock>
 80301da:	f104 000b 	add.w	r0, r4, #11
 80301de:	1d23      	adds	r3, r4, #4
 80301e0:	f020 0007 	bic.w	r0, r0, #7
 80301e4:	1ac3      	subs	r3, r0, r3
 80301e6:	d0d3      	beq.n	8030190 <_malloc_r+0x20>
 80301e8:	425a      	negs	r2, r3
 80301ea:	50e2      	str	r2, [r4, r3]
 80301ec:	e7d0      	b.n	8030190 <_malloc_r+0x20>
 80301ee:	428c      	cmp	r4, r1
 80301f0:	684b      	ldr	r3, [r1, #4]
 80301f2:	bf16      	itet	ne
 80301f4:	6063      	strne	r3, [r4, #4]
 80301f6:	6013      	streq	r3, [r2, #0]
 80301f8:	460c      	movne	r4, r1
 80301fa:	e7eb      	b.n	80301d4 <_malloc_r+0x64>
 80301fc:	460c      	mov	r4, r1
 80301fe:	6849      	ldr	r1, [r1, #4]
 8030200:	e7cc      	b.n	803019c <_malloc_r+0x2c>
 8030202:	1cc4      	adds	r4, r0, #3
 8030204:	f024 0403 	bic.w	r4, r4, #3
 8030208:	42a0      	cmp	r0, r4
 803020a:	d005      	beq.n	8030218 <_malloc_r+0xa8>
 803020c:	1a21      	subs	r1, r4, r0
 803020e:	4630      	mov	r0, r6
 8030210:	f000 fada 	bl	80307c8 <_sbrk_r>
 8030214:	3001      	adds	r0, #1
 8030216:	d0cf      	beq.n	80301b8 <_malloc_r+0x48>
 8030218:	6025      	str	r5, [r4, #0]
 803021a:	e7db      	b.n	80301d4 <_malloc_r+0x64>
 803021c:	20001a18 	.word	0x20001a18
 8030220:	20001a1c 	.word	0x20001a1c

08030224 <__sfputc_r>:
 8030224:	6893      	ldr	r3, [r2, #8]
 8030226:	3b01      	subs	r3, #1
 8030228:	2b00      	cmp	r3, #0
 803022a:	b410      	push	{r4}
 803022c:	6093      	str	r3, [r2, #8]
 803022e:	da08      	bge.n	8030242 <__sfputc_r+0x1e>
 8030230:	6994      	ldr	r4, [r2, #24]
 8030232:	42a3      	cmp	r3, r4
 8030234:	db01      	blt.n	803023a <__sfputc_r+0x16>
 8030236:	290a      	cmp	r1, #10
 8030238:	d103      	bne.n	8030242 <__sfputc_r+0x1e>
 803023a:	f85d 4b04 	ldr.w	r4, [sp], #4
 803023e:	f000 bb5b 	b.w	80308f8 <__swbuf_r>
 8030242:	6813      	ldr	r3, [r2, #0]
 8030244:	1c58      	adds	r0, r3, #1
 8030246:	6010      	str	r0, [r2, #0]
 8030248:	7019      	strb	r1, [r3, #0]
 803024a:	4608      	mov	r0, r1
 803024c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8030250:	4770      	bx	lr

08030252 <__sfputs_r>:
 8030252:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030254:	4606      	mov	r6, r0
 8030256:	460f      	mov	r7, r1
 8030258:	4614      	mov	r4, r2
 803025a:	18d5      	adds	r5, r2, r3
 803025c:	42ac      	cmp	r4, r5
 803025e:	d101      	bne.n	8030264 <__sfputs_r+0x12>
 8030260:	2000      	movs	r0, #0
 8030262:	e007      	b.n	8030274 <__sfputs_r+0x22>
 8030264:	463a      	mov	r2, r7
 8030266:	f814 1b01 	ldrb.w	r1, [r4], #1
 803026a:	4630      	mov	r0, r6
 803026c:	f7ff ffda 	bl	8030224 <__sfputc_r>
 8030270:	1c43      	adds	r3, r0, #1
 8030272:	d1f3      	bne.n	803025c <__sfputs_r+0xa>
 8030274:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08030278 <_vfiprintf_r>:
 8030278:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 803027c:	460c      	mov	r4, r1
 803027e:	b09d      	sub	sp, #116	; 0x74
 8030280:	4617      	mov	r7, r2
 8030282:	461d      	mov	r5, r3
 8030284:	4606      	mov	r6, r0
 8030286:	b118      	cbz	r0, 8030290 <_vfiprintf_r+0x18>
 8030288:	6983      	ldr	r3, [r0, #24]
 803028a:	b90b      	cbnz	r3, 8030290 <_vfiprintf_r+0x18>
 803028c:	f7ff fdee 	bl	802fe6c <__sinit>
 8030290:	4b7c      	ldr	r3, [pc, #496]	; (8030484 <_vfiprintf_r+0x20c>)
 8030292:	429c      	cmp	r4, r3
 8030294:	d158      	bne.n	8030348 <_vfiprintf_r+0xd0>
 8030296:	6874      	ldr	r4, [r6, #4]
 8030298:	89a3      	ldrh	r3, [r4, #12]
 803029a:	0718      	lsls	r0, r3, #28
 803029c:	d55e      	bpl.n	803035c <_vfiprintf_r+0xe4>
 803029e:	6923      	ldr	r3, [r4, #16]
 80302a0:	2b00      	cmp	r3, #0
 80302a2:	d05b      	beq.n	803035c <_vfiprintf_r+0xe4>
 80302a4:	2300      	movs	r3, #0
 80302a6:	9309      	str	r3, [sp, #36]	; 0x24
 80302a8:	2320      	movs	r3, #32
 80302aa:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80302ae:	2330      	movs	r3, #48	; 0x30
 80302b0:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80302b4:	9503      	str	r5, [sp, #12]
 80302b6:	f04f 0b01 	mov.w	fp, #1
 80302ba:	46b8      	mov	r8, r7
 80302bc:	4645      	mov	r5, r8
 80302be:	f815 3b01 	ldrb.w	r3, [r5], #1
 80302c2:	b10b      	cbz	r3, 80302c8 <_vfiprintf_r+0x50>
 80302c4:	2b25      	cmp	r3, #37	; 0x25
 80302c6:	d154      	bne.n	8030372 <_vfiprintf_r+0xfa>
 80302c8:	ebb8 0a07 	subs.w	sl, r8, r7
 80302cc:	d00b      	beq.n	80302e6 <_vfiprintf_r+0x6e>
 80302ce:	4653      	mov	r3, sl
 80302d0:	463a      	mov	r2, r7
 80302d2:	4621      	mov	r1, r4
 80302d4:	4630      	mov	r0, r6
 80302d6:	f7ff ffbc 	bl	8030252 <__sfputs_r>
 80302da:	3001      	adds	r0, #1
 80302dc:	f000 80c2 	beq.w	8030464 <_vfiprintf_r+0x1ec>
 80302e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80302e2:	4453      	add	r3, sl
 80302e4:	9309      	str	r3, [sp, #36]	; 0x24
 80302e6:	f898 3000 	ldrb.w	r3, [r8]
 80302ea:	2b00      	cmp	r3, #0
 80302ec:	f000 80ba 	beq.w	8030464 <_vfiprintf_r+0x1ec>
 80302f0:	2300      	movs	r3, #0
 80302f2:	f04f 32ff 	mov.w	r2, #4294967295
 80302f6:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80302fa:	9304      	str	r3, [sp, #16]
 80302fc:	9307      	str	r3, [sp, #28]
 80302fe:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8030302:	931a      	str	r3, [sp, #104]	; 0x68
 8030304:	46a8      	mov	r8, r5
 8030306:	2205      	movs	r2, #5
 8030308:	f818 1b01 	ldrb.w	r1, [r8], #1
 803030c:	485e      	ldr	r0, [pc, #376]	; (8030488 <_vfiprintf_r+0x210>)
 803030e:	f7f8 fa1f 	bl	8028750 <memchr>
 8030312:	9b04      	ldr	r3, [sp, #16]
 8030314:	bb78      	cbnz	r0, 8030376 <_vfiprintf_r+0xfe>
 8030316:	06d9      	lsls	r1, r3, #27
 8030318:	bf44      	itt	mi
 803031a:	2220      	movmi	r2, #32
 803031c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8030320:	071a      	lsls	r2, r3, #28
 8030322:	bf44      	itt	mi
 8030324:	222b      	movmi	r2, #43	; 0x2b
 8030326:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 803032a:	782a      	ldrb	r2, [r5, #0]
 803032c:	2a2a      	cmp	r2, #42	; 0x2a
 803032e:	d02a      	beq.n	8030386 <_vfiprintf_r+0x10e>
 8030330:	9a07      	ldr	r2, [sp, #28]
 8030332:	46a8      	mov	r8, r5
 8030334:	2000      	movs	r0, #0
 8030336:	250a      	movs	r5, #10
 8030338:	4641      	mov	r1, r8
 803033a:	f811 3b01 	ldrb.w	r3, [r1], #1
 803033e:	3b30      	subs	r3, #48	; 0x30
 8030340:	2b09      	cmp	r3, #9
 8030342:	d969      	bls.n	8030418 <_vfiprintf_r+0x1a0>
 8030344:	b360      	cbz	r0, 80303a0 <_vfiprintf_r+0x128>
 8030346:	e024      	b.n	8030392 <_vfiprintf_r+0x11a>
 8030348:	4b50      	ldr	r3, [pc, #320]	; (803048c <_vfiprintf_r+0x214>)
 803034a:	429c      	cmp	r4, r3
 803034c:	d101      	bne.n	8030352 <_vfiprintf_r+0xda>
 803034e:	68b4      	ldr	r4, [r6, #8]
 8030350:	e7a2      	b.n	8030298 <_vfiprintf_r+0x20>
 8030352:	4b4f      	ldr	r3, [pc, #316]	; (8030490 <_vfiprintf_r+0x218>)
 8030354:	429c      	cmp	r4, r3
 8030356:	bf08      	it	eq
 8030358:	68f4      	ldreq	r4, [r6, #12]
 803035a:	e79d      	b.n	8030298 <_vfiprintf_r+0x20>
 803035c:	4621      	mov	r1, r4
 803035e:	4630      	mov	r0, r6
 8030360:	f000 fb2e 	bl	80309c0 <__swsetup_r>
 8030364:	2800      	cmp	r0, #0
 8030366:	d09d      	beq.n	80302a4 <_vfiprintf_r+0x2c>
 8030368:	f04f 30ff 	mov.w	r0, #4294967295
 803036c:	b01d      	add	sp, #116	; 0x74
 803036e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8030372:	46a8      	mov	r8, r5
 8030374:	e7a2      	b.n	80302bc <_vfiprintf_r+0x44>
 8030376:	4a44      	ldr	r2, [pc, #272]	; (8030488 <_vfiprintf_r+0x210>)
 8030378:	1a80      	subs	r0, r0, r2
 803037a:	fa0b f000 	lsl.w	r0, fp, r0
 803037e:	4318      	orrs	r0, r3
 8030380:	9004      	str	r0, [sp, #16]
 8030382:	4645      	mov	r5, r8
 8030384:	e7be      	b.n	8030304 <_vfiprintf_r+0x8c>
 8030386:	9a03      	ldr	r2, [sp, #12]
 8030388:	1d11      	adds	r1, r2, #4
 803038a:	6812      	ldr	r2, [r2, #0]
 803038c:	9103      	str	r1, [sp, #12]
 803038e:	2a00      	cmp	r2, #0
 8030390:	db01      	blt.n	8030396 <_vfiprintf_r+0x11e>
 8030392:	9207      	str	r2, [sp, #28]
 8030394:	e004      	b.n	80303a0 <_vfiprintf_r+0x128>
 8030396:	4252      	negs	r2, r2
 8030398:	f043 0302 	orr.w	r3, r3, #2
 803039c:	9207      	str	r2, [sp, #28]
 803039e:	9304      	str	r3, [sp, #16]
 80303a0:	f898 3000 	ldrb.w	r3, [r8]
 80303a4:	2b2e      	cmp	r3, #46	; 0x2e
 80303a6:	d10e      	bne.n	80303c6 <_vfiprintf_r+0x14e>
 80303a8:	f898 3001 	ldrb.w	r3, [r8, #1]
 80303ac:	2b2a      	cmp	r3, #42	; 0x2a
 80303ae:	d138      	bne.n	8030422 <_vfiprintf_r+0x1aa>
 80303b0:	9b03      	ldr	r3, [sp, #12]
 80303b2:	1d1a      	adds	r2, r3, #4
 80303b4:	681b      	ldr	r3, [r3, #0]
 80303b6:	9203      	str	r2, [sp, #12]
 80303b8:	2b00      	cmp	r3, #0
 80303ba:	bfb8      	it	lt
 80303bc:	f04f 33ff 	movlt.w	r3, #4294967295
 80303c0:	f108 0802 	add.w	r8, r8, #2
 80303c4:	9305      	str	r3, [sp, #20]
 80303c6:	4d33      	ldr	r5, [pc, #204]	; (8030494 <_vfiprintf_r+0x21c>)
 80303c8:	f898 1000 	ldrb.w	r1, [r8]
 80303cc:	2203      	movs	r2, #3
 80303ce:	4628      	mov	r0, r5
 80303d0:	f7f8 f9be 	bl	8028750 <memchr>
 80303d4:	b140      	cbz	r0, 80303e8 <_vfiprintf_r+0x170>
 80303d6:	2340      	movs	r3, #64	; 0x40
 80303d8:	1b40      	subs	r0, r0, r5
 80303da:	fa03 f000 	lsl.w	r0, r3, r0
 80303de:	9b04      	ldr	r3, [sp, #16]
 80303e0:	4303      	orrs	r3, r0
 80303e2:	f108 0801 	add.w	r8, r8, #1
 80303e6:	9304      	str	r3, [sp, #16]
 80303e8:	f898 1000 	ldrb.w	r1, [r8]
 80303ec:	482a      	ldr	r0, [pc, #168]	; (8030498 <_vfiprintf_r+0x220>)
 80303ee:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80303f2:	2206      	movs	r2, #6
 80303f4:	f108 0701 	add.w	r7, r8, #1
 80303f8:	f7f8 f9aa 	bl	8028750 <memchr>
 80303fc:	2800      	cmp	r0, #0
 80303fe:	d037      	beq.n	8030470 <_vfiprintf_r+0x1f8>
 8030400:	4b26      	ldr	r3, [pc, #152]	; (803049c <_vfiprintf_r+0x224>)
 8030402:	bb1b      	cbnz	r3, 803044c <_vfiprintf_r+0x1d4>
 8030404:	9b03      	ldr	r3, [sp, #12]
 8030406:	3307      	adds	r3, #7
 8030408:	f023 0307 	bic.w	r3, r3, #7
 803040c:	3308      	adds	r3, #8
 803040e:	9303      	str	r3, [sp, #12]
 8030410:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8030412:	444b      	add	r3, r9
 8030414:	9309      	str	r3, [sp, #36]	; 0x24
 8030416:	e750      	b.n	80302ba <_vfiprintf_r+0x42>
 8030418:	fb05 3202 	mla	r2, r5, r2, r3
 803041c:	2001      	movs	r0, #1
 803041e:	4688      	mov	r8, r1
 8030420:	e78a      	b.n	8030338 <_vfiprintf_r+0xc0>
 8030422:	2300      	movs	r3, #0
 8030424:	f108 0801 	add.w	r8, r8, #1
 8030428:	9305      	str	r3, [sp, #20]
 803042a:	4619      	mov	r1, r3
 803042c:	250a      	movs	r5, #10
 803042e:	4640      	mov	r0, r8
 8030430:	f810 2b01 	ldrb.w	r2, [r0], #1
 8030434:	3a30      	subs	r2, #48	; 0x30
 8030436:	2a09      	cmp	r2, #9
 8030438:	d903      	bls.n	8030442 <_vfiprintf_r+0x1ca>
 803043a:	2b00      	cmp	r3, #0
 803043c:	d0c3      	beq.n	80303c6 <_vfiprintf_r+0x14e>
 803043e:	9105      	str	r1, [sp, #20]
 8030440:	e7c1      	b.n	80303c6 <_vfiprintf_r+0x14e>
 8030442:	fb05 2101 	mla	r1, r5, r1, r2
 8030446:	2301      	movs	r3, #1
 8030448:	4680      	mov	r8, r0
 803044a:	e7f0      	b.n	803042e <_vfiprintf_r+0x1b6>
 803044c:	ab03      	add	r3, sp, #12
 803044e:	9300      	str	r3, [sp, #0]
 8030450:	4622      	mov	r2, r4
 8030452:	4b13      	ldr	r3, [pc, #76]	; (80304a0 <_vfiprintf_r+0x228>)
 8030454:	a904      	add	r1, sp, #16
 8030456:	4630      	mov	r0, r6
 8030458:	f3af 8000 	nop.w
 803045c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8030460:	4681      	mov	r9, r0
 8030462:	d1d5      	bne.n	8030410 <_vfiprintf_r+0x198>
 8030464:	89a3      	ldrh	r3, [r4, #12]
 8030466:	065b      	lsls	r3, r3, #25
 8030468:	f53f af7e 	bmi.w	8030368 <_vfiprintf_r+0xf0>
 803046c:	9809      	ldr	r0, [sp, #36]	; 0x24
 803046e:	e77d      	b.n	803036c <_vfiprintf_r+0xf4>
 8030470:	ab03      	add	r3, sp, #12
 8030472:	9300      	str	r3, [sp, #0]
 8030474:	4622      	mov	r2, r4
 8030476:	4b0a      	ldr	r3, [pc, #40]	; (80304a0 <_vfiprintf_r+0x228>)
 8030478:	a904      	add	r1, sp, #16
 803047a:	4630      	mov	r0, r6
 803047c:	f000 f892 	bl	80305a4 <_printf_i>
 8030480:	e7ec      	b.n	803045c <_vfiprintf_r+0x1e4>
 8030482:	bf00      	nop
 8030484:	08031420 	.word	0x08031420
 8030488:	08031464 	.word	0x08031464
 803048c:	08031440 	.word	0x08031440
 8030490:	08031400 	.word	0x08031400
 8030494:	0803146a 	.word	0x0803146a
 8030498:	0803146e 	.word	0x0803146e
 803049c:	00000000 	.word	0x00000000
 80304a0:	08030253 	.word	0x08030253

080304a4 <vfiprintf>:
 80304a4:	4613      	mov	r3, r2
 80304a6:	460a      	mov	r2, r1
 80304a8:	4601      	mov	r1, r0
 80304aa:	4802      	ldr	r0, [pc, #8]	; (80304b4 <vfiprintf+0x10>)
 80304ac:	6800      	ldr	r0, [r0, #0]
 80304ae:	f7ff bee3 	b.w	8030278 <_vfiprintf_r>
 80304b2:	bf00      	nop
 80304b4:	200005cc 	.word	0x200005cc

080304b8 <_printf_common>:
 80304b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80304bc:	4691      	mov	r9, r2
 80304be:	461f      	mov	r7, r3
 80304c0:	688a      	ldr	r2, [r1, #8]
 80304c2:	690b      	ldr	r3, [r1, #16]
 80304c4:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80304c8:	4293      	cmp	r3, r2
 80304ca:	bfb8      	it	lt
 80304cc:	4613      	movlt	r3, r2
 80304ce:	f8c9 3000 	str.w	r3, [r9]
 80304d2:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 80304d6:	4606      	mov	r6, r0
 80304d8:	460c      	mov	r4, r1
 80304da:	b112      	cbz	r2, 80304e2 <_printf_common+0x2a>
 80304dc:	3301      	adds	r3, #1
 80304de:	f8c9 3000 	str.w	r3, [r9]
 80304e2:	6823      	ldr	r3, [r4, #0]
 80304e4:	0699      	lsls	r1, r3, #26
 80304e6:	bf42      	ittt	mi
 80304e8:	f8d9 3000 	ldrmi.w	r3, [r9]
 80304ec:	3302      	addmi	r3, #2
 80304ee:	f8c9 3000 	strmi.w	r3, [r9]
 80304f2:	6825      	ldr	r5, [r4, #0]
 80304f4:	f015 0506 	ands.w	r5, r5, #6
 80304f8:	d107      	bne.n	803050a <_printf_common+0x52>
 80304fa:	f104 0a19 	add.w	sl, r4, #25
 80304fe:	68e3      	ldr	r3, [r4, #12]
 8030500:	f8d9 2000 	ldr.w	r2, [r9]
 8030504:	1a9b      	subs	r3, r3, r2
 8030506:	42ab      	cmp	r3, r5
 8030508:	dc28      	bgt.n	803055c <_printf_common+0xa4>
 803050a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 803050e:	6822      	ldr	r2, [r4, #0]
 8030510:	3300      	adds	r3, #0
 8030512:	bf18      	it	ne
 8030514:	2301      	movne	r3, #1
 8030516:	0692      	lsls	r2, r2, #26
 8030518:	d42d      	bmi.n	8030576 <_printf_common+0xbe>
 803051a:	f104 0243 	add.w	r2, r4, #67	; 0x43
 803051e:	4639      	mov	r1, r7
 8030520:	4630      	mov	r0, r6
 8030522:	47c0      	blx	r8
 8030524:	3001      	adds	r0, #1
 8030526:	d020      	beq.n	803056a <_printf_common+0xb2>
 8030528:	6823      	ldr	r3, [r4, #0]
 803052a:	68e5      	ldr	r5, [r4, #12]
 803052c:	f8d9 2000 	ldr.w	r2, [r9]
 8030530:	f003 0306 	and.w	r3, r3, #6
 8030534:	2b04      	cmp	r3, #4
 8030536:	bf08      	it	eq
 8030538:	1aad      	subeq	r5, r5, r2
 803053a:	68a3      	ldr	r3, [r4, #8]
 803053c:	6922      	ldr	r2, [r4, #16]
 803053e:	bf0c      	ite	eq
 8030540:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8030544:	2500      	movne	r5, #0
 8030546:	4293      	cmp	r3, r2
 8030548:	bfc4      	itt	gt
 803054a:	1a9b      	subgt	r3, r3, r2
 803054c:	18ed      	addgt	r5, r5, r3
 803054e:	f04f 0900 	mov.w	r9, #0
 8030552:	341a      	adds	r4, #26
 8030554:	454d      	cmp	r5, r9
 8030556:	d11a      	bne.n	803058e <_printf_common+0xd6>
 8030558:	2000      	movs	r0, #0
 803055a:	e008      	b.n	803056e <_printf_common+0xb6>
 803055c:	2301      	movs	r3, #1
 803055e:	4652      	mov	r2, sl
 8030560:	4639      	mov	r1, r7
 8030562:	4630      	mov	r0, r6
 8030564:	47c0      	blx	r8
 8030566:	3001      	adds	r0, #1
 8030568:	d103      	bne.n	8030572 <_printf_common+0xba>
 803056a:	f04f 30ff 	mov.w	r0, #4294967295
 803056e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8030572:	3501      	adds	r5, #1
 8030574:	e7c3      	b.n	80304fe <_printf_common+0x46>
 8030576:	18e1      	adds	r1, r4, r3
 8030578:	1c5a      	adds	r2, r3, #1
 803057a:	2030      	movs	r0, #48	; 0x30
 803057c:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8030580:	4422      	add	r2, r4
 8030582:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8030586:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 803058a:	3302      	adds	r3, #2
 803058c:	e7c5      	b.n	803051a <_printf_common+0x62>
 803058e:	2301      	movs	r3, #1
 8030590:	4622      	mov	r2, r4
 8030592:	4639      	mov	r1, r7
 8030594:	4630      	mov	r0, r6
 8030596:	47c0      	blx	r8
 8030598:	3001      	adds	r0, #1
 803059a:	d0e6      	beq.n	803056a <_printf_common+0xb2>
 803059c:	f109 0901 	add.w	r9, r9, #1
 80305a0:	e7d8      	b.n	8030554 <_printf_common+0x9c>
	...

080305a4 <_printf_i>:
 80305a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80305a8:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 80305ac:	460c      	mov	r4, r1
 80305ae:	7e09      	ldrb	r1, [r1, #24]
 80305b0:	b085      	sub	sp, #20
 80305b2:	296e      	cmp	r1, #110	; 0x6e
 80305b4:	4617      	mov	r7, r2
 80305b6:	4606      	mov	r6, r0
 80305b8:	4698      	mov	r8, r3
 80305ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80305bc:	f000 80b3 	beq.w	8030726 <_printf_i+0x182>
 80305c0:	d822      	bhi.n	8030608 <_printf_i+0x64>
 80305c2:	2963      	cmp	r1, #99	; 0x63
 80305c4:	d036      	beq.n	8030634 <_printf_i+0x90>
 80305c6:	d80a      	bhi.n	80305de <_printf_i+0x3a>
 80305c8:	2900      	cmp	r1, #0
 80305ca:	f000 80b9 	beq.w	8030740 <_printf_i+0x19c>
 80305ce:	2958      	cmp	r1, #88	; 0x58
 80305d0:	f000 8083 	beq.w	80306da <_printf_i+0x136>
 80305d4:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80305d8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 80305dc:	e032      	b.n	8030644 <_printf_i+0xa0>
 80305de:	2964      	cmp	r1, #100	; 0x64
 80305e0:	d001      	beq.n	80305e6 <_printf_i+0x42>
 80305e2:	2969      	cmp	r1, #105	; 0x69
 80305e4:	d1f6      	bne.n	80305d4 <_printf_i+0x30>
 80305e6:	6820      	ldr	r0, [r4, #0]
 80305e8:	6813      	ldr	r3, [r2, #0]
 80305ea:	0605      	lsls	r5, r0, #24
 80305ec:	f103 0104 	add.w	r1, r3, #4
 80305f0:	d52a      	bpl.n	8030648 <_printf_i+0xa4>
 80305f2:	681b      	ldr	r3, [r3, #0]
 80305f4:	6011      	str	r1, [r2, #0]
 80305f6:	2b00      	cmp	r3, #0
 80305f8:	da03      	bge.n	8030602 <_printf_i+0x5e>
 80305fa:	222d      	movs	r2, #45	; 0x2d
 80305fc:	425b      	negs	r3, r3
 80305fe:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8030602:	486f      	ldr	r0, [pc, #444]	; (80307c0 <_printf_i+0x21c>)
 8030604:	220a      	movs	r2, #10
 8030606:	e039      	b.n	803067c <_printf_i+0xd8>
 8030608:	2973      	cmp	r1, #115	; 0x73
 803060a:	f000 809d 	beq.w	8030748 <_printf_i+0x1a4>
 803060e:	d808      	bhi.n	8030622 <_printf_i+0x7e>
 8030610:	296f      	cmp	r1, #111	; 0x6f
 8030612:	d020      	beq.n	8030656 <_printf_i+0xb2>
 8030614:	2970      	cmp	r1, #112	; 0x70
 8030616:	d1dd      	bne.n	80305d4 <_printf_i+0x30>
 8030618:	6823      	ldr	r3, [r4, #0]
 803061a:	f043 0320 	orr.w	r3, r3, #32
 803061e:	6023      	str	r3, [r4, #0]
 8030620:	e003      	b.n	803062a <_printf_i+0x86>
 8030622:	2975      	cmp	r1, #117	; 0x75
 8030624:	d017      	beq.n	8030656 <_printf_i+0xb2>
 8030626:	2978      	cmp	r1, #120	; 0x78
 8030628:	d1d4      	bne.n	80305d4 <_printf_i+0x30>
 803062a:	2378      	movs	r3, #120	; 0x78
 803062c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8030630:	4864      	ldr	r0, [pc, #400]	; (80307c4 <_printf_i+0x220>)
 8030632:	e055      	b.n	80306e0 <_printf_i+0x13c>
 8030634:	6813      	ldr	r3, [r2, #0]
 8030636:	1d19      	adds	r1, r3, #4
 8030638:	681b      	ldr	r3, [r3, #0]
 803063a:	6011      	str	r1, [r2, #0]
 803063c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8030640:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8030644:	2301      	movs	r3, #1
 8030646:	e08c      	b.n	8030762 <_printf_i+0x1be>
 8030648:	681b      	ldr	r3, [r3, #0]
 803064a:	6011      	str	r1, [r2, #0]
 803064c:	f010 0f40 	tst.w	r0, #64	; 0x40
 8030650:	bf18      	it	ne
 8030652:	b21b      	sxthne	r3, r3
 8030654:	e7cf      	b.n	80305f6 <_printf_i+0x52>
 8030656:	6813      	ldr	r3, [r2, #0]
 8030658:	6825      	ldr	r5, [r4, #0]
 803065a:	1d18      	adds	r0, r3, #4
 803065c:	6010      	str	r0, [r2, #0]
 803065e:	0628      	lsls	r0, r5, #24
 8030660:	d501      	bpl.n	8030666 <_printf_i+0xc2>
 8030662:	681b      	ldr	r3, [r3, #0]
 8030664:	e002      	b.n	803066c <_printf_i+0xc8>
 8030666:	0668      	lsls	r0, r5, #25
 8030668:	d5fb      	bpl.n	8030662 <_printf_i+0xbe>
 803066a:	881b      	ldrh	r3, [r3, #0]
 803066c:	4854      	ldr	r0, [pc, #336]	; (80307c0 <_printf_i+0x21c>)
 803066e:	296f      	cmp	r1, #111	; 0x6f
 8030670:	bf14      	ite	ne
 8030672:	220a      	movne	r2, #10
 8030674:	2208      	moveq	r2, #8
 8030676:	2100      	movs	r1, #0
 8030678:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 803067c:	6865      	ldr	r5, [r4, #4]
 803067e:	60a5      	str	r5, [r4, #8]
 8030680:	2d00      	cmp	r5, #0
 8030682:	f2c0 8095 	blt.w	80307b0 <_printf_i+0x20c>
 8030686:	6821      	ldr	r1, [r4, #0]
 8030688:	f021 0104 	bic.w	r1, r1, #4
 803068c:	6021      	str	r1, [r4, #0]
 803068e:	2b00      	cmp	r3, #0
 8030690:	d13d      	bne.n	803070e <_printf_i+0x16a>
 8030692:	2d00      	cmp	r5, #0
 8030694:	f040 808e 	bne.w	80307b4 <_printf_i+0x210>
 8030698:	4665      	mov	r5, ip
 803069a:	2a08      	cmp	r2, #8
 803069c:	d10b      	bne.n	80306b6 <_printf_i+0x112>
 803069e:	6823      	ldr	r3, [r4, #0]
 80306a0:	07db      	lsls	r3, r3, #31
 80306a2:	d508      	bpl.n	80306b6 <_printf_i+0x112>
 80306a4:	6923      	ldr	r3, [r4, #16]
 80306a6:	6862      	ldr	r2, [r4, #4]
 80306a8:	429a      	cmp	r2, r3
 80306aa:	bfde      	ittt	le
 80306ac:	2330      	movle	r3, #48	; 0x30
 80306ae:	f805 3c01 	strble.w	r3, [r5, #-1]
 80306b2:	f105 35ff 	addle.w	r5, r5, #4294967295
 80306b6:	ebac 0305 	sub.w	r3, ip, r5
 80306ba:	6123      	str	r3, [r4, #16]
 80306bc:	f8cd 8000 	str.w	r8, [sp]
 80306c0:	463b      	mov	r3, r7
 80306c2:	aa03      	add	r2, sp, #12
 80306c4:	4621      	mov	r1, r4
 80306c6:	4630      	mov	r0, r6
 80306c8:	f7ff fef6 	bl	80304b8 <_printf_common>
 80306cc:	3001      	adds	r0, #1
 80306ce:	d14d      	bne.n	803076c <_printf_i+0x1c8>
 80306d0:	f04f 30ff 	mov.w	r0, #4294967295
 80306d4:	b005      	add	sp, #20
 80306d6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80306da:	4839      	ldr	r0, [pc, #228]	; (80307c0 <_printf_i+0x21c>)
 80306dc:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 80306e0:	6813      	ldr	r3, [r2, #0]
 80306e2:	6821      	ldr	r1, [r4, #0]
 80306e4:	1d1d      	adds	r5, r3, #4
 80306e6:	681b      	ldr	r3, [r3, #0]
 80306e8:	6015      	str	r5, [r2, #0]
 80306ea:	060a      	lsls	r2, r1, #24
 80306ec:	d50b      	bpl.n	8030706 <_printf_i+0x162>
 80306ee:	07ca      	lsls	r2, r1, #31
 80306f0:	bf44      	itt	mi
 80306f2:	f041 0120 	orrmi.w	r1, r1, #32
 80306f6:	6021      	strmi	r1, [r4, #0]
 80306f8:	b91b      	cbnz	r3, 8030702 <_printf_i+0x15e>
 80306fa:	6822      	ldr	r2, [r4, #0]
 80306fc:	f022 0220 	bic.w	r2, r2, #32
 8030700:	6022      	str	r2, [r4, #0]
 8030702:	2210      	movs	r2, #16
 8030704:	e7b7      	b.n	8030676 <_printf_i+0xd2>
 8030706:	064d      	lsls	r5, r1, #25
 8030708:	bf48      	it	mi
 803070a:	b29b      	uxthmi	r3, r3
 803070c:	e7ef      	b.n	80306ee <_printf_i+0x14a>
 803070e:	4665      	mov	r5, ip
 8030710:	fbb3 f1f2 	udiv	r1, r3, r2
 8030714:	fb02 3311 	mls	r3, r2, r1, r3
 8030718:	5cc3      	ldrb	r3, [r0, r3]
 803071a:	f805 3d01 	strb.w	r3, [r5, #-1]!
 803071e:	460b      	mov	r3, r1
 8030720:	2900      	cmp	r1, #0
 8030722:	d1f5      	bne.n	8030710 <_printf_i+0x16c>
 8030724:	e7b9      	b.n	803069a <_printf_i+0xf6>
 8030726:	6813      	ldr	r3, [r2, #0]
 8030728:	6825      	ldr	r5, [r4, #0]
 803072a:	6961      	ldr	r1, [r4, #20]
 803072c:	1d18      	adds	r0, r3, #4
 803072e:	6010      	str	r0, [r2, #0]
 8030730:	0628      	lsls	r0, r5, #24
 8030732:	681b      	ldr	r3, [r3, #0]
 8030734:	d501      	bpl.n	803073a <_printf_i+0x196>
 8030736:	6019      	str	r1, [r3, #0]
 8030738:	e002      	b.n	8030740 <_printf_i+0x19c>
 803073a:	066a      	lsls	r2, r5, #25
 803073c:	d5fb      	bpl.n	8030736 <_printf_i+0x192>
 803073e:	8019      	strh	r1, [r3, #0]
 8030740:	2300      	movs	r3, #0
 8030742:	6123      	str	r3, [r4, #16]
 8030744:	4665      	mov	r5, ip
 8030746:	e7b9      	b.n	80306bc <_printf_i+0x118>
 8030748:	6813      	ldr	r3, [r2, #0]
 803074a:	1d19      	adds	r1, r3, #4
 803074c:	6011      	str	r1, [r2, #0]
 803074e:	681d      	ldr	r5, [r3, #0]
 8030750:	6862      	ldr	r2, [r4, #4]
 8030752:	2100      	movs	r1, #0
 8030754:	4628      	mov	r0, r5
 8030756:	f7f7 fffb 	bl	8028750 <memchr>
 803075a:	b108      	cbz	r0, 8030760 <_printf_i+0x1bc>
 803075c:	1b40      	subs	r0, r0, r5
 803075e:	6060      	str	r0, [r4, #4]
 8030760:	6863      	ldr	r3, [r4, #4]
 8030762:	6123      	str	r3, [r4, #16]
 8030764:	2300      	movs	r3, #0
 8030766:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 803076a:	e7a7      	b.n	80306bc <_printf_i+0x118>
 803076c:	6923      	ldr	r3, [r4, #16]
 803076e:	462a      	mov	r2, r5
 8030770:	4639      	mov	r1, r7
 8030772:	4630      	mov	r0, r6
 8030774:	47c0      	blx	r8
 8030776:	3001      	adds	r0, #1
 8030778:	d0aa      	beq.n	80306d0 <_printf_i+0x12c>
 803077a:	6823      	ldr	r3, [r4, #0]
 803077c:	079b      	lsls	r3, r3, #30
 803077e:	d413      	bmi.n	80307a8 <_printf_i+0x204>
 8030780:	68e0      	ldr	r0, [r4, #12]
 8030782:	9b03      	ldr	r3, [sp, #12]
 8030784:	4298      	cmp	r0, r3
 8030786:	bfb8      	it	lt
 8030788:	4618      	movlt	r0, r3
 803078a:	e7a3      	b.n	80306d4 <_printf_i+0x130>
 803078c:	2301      	movs	r3, #1
 803078e:	464a      	mov	r2, r9
 8030790:	4639      	mov	r1, r7
 8030792:	4630      	mov	r0, r6
 8030794:	47c0      	blx	r8
 8030796:	3001      	adds	r0, #1
 8030798:	d09a      	beq.n	80306d0 <_printf_i+0x12c>
 803079a:	3501      	adds	r5, #1
 803079c:	68e3      	ldr	r3, [r4, #12]
 803079e:	9a03      	ldr	r2, [sp, #12]
 80307a0:	1a9b      	subs	r3, r3, r2
 80307a2:	42ab      	cmp	r3, r5
 80307a4:	dcf2      	bgt.n	803078c <_printf_i+0x1e8>
 80307a6:	e7eb      	b.n	8030780 <_printf_i+0x1dc>
 80307a8:	2500      	movs	r5, #0
 80307aa:	f104 0919 	add.w	r9, r4, #25
 80307ae:	e7f5      	b.n	803079c <_printf_i+0x1f8>
 80307b0:	2b00      	cmp	r3, #0
 80307b2:	d1ac      	bne.n	803070e <_printf_i+0x16a>
 80307b4:	7803      	ldrb	r3, [r0, #0]
 80307b6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80307ba:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80307be:	e76c      	b.n	803069a <_printf_i+0xf6>
 80307c0:	08031475 	.word	0x08031475
 80307c4:	08031486 	.word	0x08031486

080307c8 <_sbrk_r>:
 80307c8:	b538      	push	{r3, r4, r5, lr}
 80307ca:	4c06      	ldr	r4, [pc, #24]	; (80307e4 <_sbrk_r+0x1c>)
 80307cc:	2300      	movs	r3, #0
 80307ce:	4605      	mov	r5, r0
 80307d0:	4608      	mov	r0, r1
 80307d2:	6023      	str	r3, [r4, #0]
 80307d4:	f7fb f942 	bl	802ba5c <_sbrk>
 80307d8:	1c43      	adds	r3, r0, #1
 80307da:	d102      	bne.n	80307e2 <_sbrk_r+0x1a>
 80307dc:	6823      	ldr	r3, [r4, #0]
 80307de:	b103      	cbz	r3, 80307e2 <_sbrk_r+0x1a>
 80307e0:	602b      	str	r3, [r5, #0]
 80307e2:	bd38      	pop	{r3, r4, r5, pc}
 80307e4:	2000481c 	.word	0x2000481c

080307e8 <_raise_r>:
 80307e8:	291f      	cmp	r1, #31
 80307ea:	b538      	push	{r3, r4, r5, lr}
 80307ec:	4604      	mov	r4, r0
 80307ee:	460d      	mov	r5, r1
 80307f0:	d904      	bls.n	80307fc <_raise_r+0x14>
 80307f2:	2316      	movs	r3, #22
 80307f4:	6003      	str	r3, [r0, #0]
 80307f6:	f04f 30ff 	mov.w	r0, #4294967295
 80307fa:	bd38      	pop	{r3, r4, r5, pc}
 80307fc:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80307fe:	b112      	cbz	r2, 8030806 <_raise_r+0x1e>
 8030800:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8030804:	b94b      	cbnz	r3, 803081a <_raise_r+0x32>
 8030806:	4620      	mov	r0, r4
 8030808:	f000 f830 	bl	803086c <_getpid_r>
 803080c:	462a      	mov	r2, r5
 803080e:	4601      	mov	r1, r0
 8030810:	4620      	mov	r0, r4
 8030812:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8030816:	f000 b817 	b.w	8030848 <_kill_r>
 803081a:	2b01      	cmp	r3, #1
 803081c:	d00a      	beq.n	8030834 <_raise_r+0x4c>
 803081e:	1c59      	adds	r1, r3, #1
 8030820:	d103      	bne.n	803082a <_raise_r+0x42>
 8030822:	2316      	movs	r3, #22
 8030824:	6003      	str	r3, [r0, #0]
 8030826:	2001      	movs	r0, #1
 8030828:	e7e7      	b.n	80307fa <_raise_r+0x12>
 803082a:	2400      	movs	r4, #0
 803082c:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 8030830:	4628      	mov	r0, r5
 8030832:	4798      	blx	r3
 8030834:	2000      	movs	r0, #0
 8030836:	e7e0      	b.n	80307fa <_raise_r+0x12>

08030838 <raise>:
 8030838:	4b02      	ldr	r3, [pc, #8]	; (8030844 <raise+0xc>)
 803083a:	4601      	mov	r1, r0
 803083c:	6818      	ldr	r0, [r3, #0]
 803083e:	f7ff bfd3 	b.w	80307e8 <_raise_r>
 8030842:	bf00      	nop
 8030844:	200005cc 	.word	0x200005cc

08030848 <_kill_r>:
 8030848:	b538      	push	{r3, r4, r5, lr}
 803084a:	4c07      	ldr	r4, [pc, #28]	; (8030868 <_kill_r+0x20>)
 803084c:	2300      	movs	r3, #0
 803084e:	4605      	mov	r5, r0
 8030850:	4608      	mov	r0, r1
 8030852:	4611      	mov	r1, r2
 8030854:	6023      	str	r3, [r4, #0]
 8030856:	f7fb f879 	bl	802b94c <_kill>
 803085a:	1c43      	adds	r3, r0, #1
 803085c:	d102      	bne.n	8030864 <_kill_r+0x1c>
 803085e:	6823      	ldr	r3, [r4, #0]
 8030860:	b103      	cbz	r3, 8030864 <_kill_r+0x1c>
 8030862:	602b      	str	r3, [r5, #0]
 8030864:	bd38      	pop	{r3, r4, r5, pc}
 8030866:	bf00      	nop
 8030868:	2000481c 	.word	0x2000481c

0803086c <_getpid_r>:
 803086c:	f7fb b866 	b.w	802b93c <_getpid>

08030870 <__sread>:
 8030870:	b510      	push	{r4, lr}
 8030872:	460c      	mov	r4, r1
 8030874:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8030878:	f000 f998 	bl	8030bac <_read_r>
 803087c:	2800      	cmp	r0, #0
 803087e:	bfab      	itete	ge
 8030880:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8030882:	89a3      	ldrhlt	r3, [r4, #12]
 8030884:	181b      	addge	r3, r3, r0
 8030886:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 803088a:	bfac      	ite	ge
 803088c:	6563      	strge	r3, [r4, #84]	; 0x54
 803088e:	81a3      	strhlt	r3, [r4, #12]
 8030890:	bd10      	pop	{r4, pc}

08030892 <__swrite>:
 8030892:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8030896:	461f      	mov	r7, r3
 8030898:	898b      	ldrh	r3, [r1, #12]
 803089a:	05db      	lsls	r3, r3, #23
 803089c:	4605      	mov	r5, r0
 803089e:	460c      	mov	r4, r1
 80308a0:	4616      	mov	r6, r2
 80308a2:	d505      	bpl.n	80308b0 <__swrite+0x1e>
 80308a4:	2302      	movs	r3, #2
 80308a6:	2200      	movs	r2, #0
 80308a8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80308ac:	f000 f906 	bl	8030abc <_lseek_r>
 80308b0:	89a3      	ldrh	r3, [r4, #12]
 80308b2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80308b6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80308ba:	81a3      	strh	r3, [r4, #12]
 80308bc:	4632      	mov	r2, r6
 80308be:	463b      	mov	r3, r7
 80308c0:	4628      	mov	r0, r5
 80308c2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80308c6:	f000 b869 	b.w	803099c <_write_r>

080308ca <__sseek>:
 80308ca:	b510      	push	{r4, lr}
 80308cc:	460c      	mov	r4, r1
 80308ce:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80308d2:	f000 f8f3 	bl	8030abc <_lseek_r>
 80308d6:	1c43      	adds	r3, r0, #1
 80308d8:	89a3      	ldrh	r3, [r4, #12]
 80308da:	bf15      	itete	ne
 80308dc:	6560      	strne	r0, [r4, #84]	; 0x54
 80308de:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80308e2:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80308e6:	81a3      	strheq	r3, [r4, #12]
 80308e8:	bf18      	it	ne
 80308ea:	81a3      	strhne	r3, [r4, #12]
 80308ec:	bd10      	pop	{r4, pc}

080308ee <__sclose>:
 80308ee:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80308f2:	f000 b8d3 	b.w	8030a9c <_close_r>
	...

080308f8 <__swbuf_r>:
 80308f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80308fa:	460e      	mov	r6, r1
 80308fc:	4614      	mov	r4, r2
 80308fe:	4605      	mov	r5, r0
 8030900:	b118      	cbz	r0, 803090a <__swbuf_r+0x12>
 8030902:	6983      	ldr	r3, [r0, #24]
 8030904:	b90b      	cbnz	r3, 803090a <__swbuf_r+0x12>
 8030906:	f7ff fab1 	bl	802fe6c <__sinit>
 803090a:	4b21      	ldr	r3, [pc, #132]	; (8030990 <__swbuf_r+0x98>)
 803090c:	429c      	cmp	r4, r3
 803090e:	d12a      	bne.n	8030966 <__swbuf_r+0x6e>
 8030910:	686c      	ldr	r4, [r5, #4]
 8030912:	69a3      	ldr	r3, [r4, #24]
 8030914:	60a3      	str	r3, [r4, #8]
 8030916:	89a3      	ldrh	r3, [r4, #12]
 8030918:	071a      	lsls	r2, r3, #28
 803091a:	d52e      	bpl.n	803097a <__swbuf_r+0x82>
 803091c:	6923      	ldr	r3, [r4, #16]
 803091e:	b363      	cbz	r3, 803097a <__swbuf_r+0x82>
 8030920:	6923      	ldr	r3, [r4, #16]
 8030922:	6820      	ldr	r0, [r4, #0]
 8030924:	1ac0      	subs	r0, r0, r3
 8030926:	6963      	ldr	r3, [r4, #20]
 8030928:	b2f6      	uxtb	r6, r6
 803092a:	4283      	cmp	r3, r0
 803092c:	4637      	mov	r7, r6
 803092e:	dc04      	bgt.n	803093a <__swbuf_r+0x42>
 8030930:	4621      	mov	r1, r4
 8030932:	4628      	mov	r0, r5
 8030934:	f7ff fa1e 	bl	802fd74 <_fflush_r>
 8030938:	bb28      	cbnz	r0, 8030986 <__swbuf_r+0x8e>
 803093a:	68a3      	ldr	r3, [r4, #8]
 803093c:	3b01      	subs	r3, #1
 803093e:	60a3      	str	r3, [r4, #8]
 8030940:	6823      	ldr	r3, [r4, #0]
 8030942:	1c5a      	adds	r2, r3, #1
 8030944:	6022      	str	r2, [r4, #0]
 8030946:	701e      	strb	r6, [r3, #0]
 8030948:	6963      	ldr	r3, [r4, #20]
 803094a:	3001      	adds	r0, #1
 803094c:	4283      	cmp	r3, r0
 803094e:	d004      	beq.n	803095a <__swbuf_r+0x62>
 8030950:	89a3      	ldrh	r3, [r4, #12]
 8030952:	07db      	lsls	r3, r3, #31
 8030954:	d519      	bpl.n	803098a <__swbuf_r+0x92>
 8030956:	2e0a      	cmp	r6, #10
 8030958:	d117      	bne.n	803098a <__swbuf_r+0x92>
 803095a:	4621      	mov	r1, r4
 803095c:	4628      	mov	r0, r5
 803095e:	f7ff fa09 	bl	802fd74 <_fflush_r>
 8030962:	b190      	cbz	r0, 803098a <__swbuf_r+0x92>
 8030964:	e00f      	b.n	8030986 <__swbuf_r+0x8e>
 8030966:	4b0b      	ldr	r3, [pc, #44]	; (8030994 <__swbuf_r+0x9c>)
 8030968:	429c      	cmp	r4, r3
 803096a:	d101      	bne.n	8030970 <__swbuf_r+0x78>
 803096c:	68ac      	ldr	r4, [r5, #8]
 803096e:	e7d0      	b.n	8030912 <__swbuf_r+0x1a>
 8030970:	4b09      	ldr	r3, [pc, #36]	; (8030998 <__swbuf_r+0xa0>)
 8030972:	429c      	cmp	r4, r3
 8030974:	bf08      	it	eq
 8030976:	68ec      	ldreq	r4, [r5, #12]
 8030978:	e7cb      	b.n	8030912 <__swbuf_r+0x1a>
 803097a:	4621      	mov	r1, r4
 803097c:	4628      	mov	r0, r5
 803097e:	f000 f81f 	bl	80309c0 <__swsetup_r>
 8030982:	2800      	cmp	r0, #0
 8030984:	d0cc      	beq.n	8030920 <__swbuf_r+0x28>
 8030986:	f04f 37ff 	mov.w	r7, #4294967295
 803098a:	4638      	mov	r0, r7
 803098c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 803098e:	bf00      	nop
 8030990:	08031420 	.word	0x08031420
 8030994:	08031440 	.word	0x08031440
 8030998:	08031400 	.word	0x08031400

0803099c <_write_r>:
 803099c:	b538      	push	{r3, r4, r5, lr}
 803099e:	4c07      	ldr	r4, [pc, #28]	; (80309bc <_write_r+0x20>)
 80309a0:	4605      	mov	r5, r0
 80309a2:	4608      	mov	r0, r1
 80309a4:	4611      	mov	r1, r2
 80309a6:	2200      	movs	r2, #0
 80309a8:	6022      	str	r2, [r4, #0]
 80309aa:	461a      	mov	r2, r3
 80309ac:	f7fb f805 	bl	802b9ba <_write>
 80309b0:	1c43      	adds	r3, r0, #1
 80309b2:	d102      	bne.n	80309ba <_write_r+0x1e>
 80309b4:	6823      	ldr	r3, [r4, #0]
 80309b6:	b103      	cbz	r3, 80309ba <_write_r+0x1e>
 80309b8:	602b      	str	r3, [r5, #0]
 80309ba:	bd38      	pop	{r3, r4, r5, pc}
 80309bc:	2000481c 	.word	0x2000481c

080309c0 <__swsetup_r>:
 80309c0:	4b32      	ldr	r3, [pc, #200]	; (8030a8c <__swsetup_r+0xcc>)
 80309c2:	b570      	push	{r4, r5, r6, lr}
 80309c4:	681d      	ldr	r5, [r3, #0]
 80309c6:	4606      	mov	r6, r0
 80309c8:	460c      	mov	r4, r1
 80309ca:	b125      	cbz	r5, 80309d6 <__swsetup_r+0x16>
 80309cc:	69ab      	ldr	r3, [r5, #24]
 80309ce:	b913      	cbnz	r3, 80309d6 <__swsetup_r+0x16>
 80309d0:	4628      	mov	r0, r5
 80309d2:	f7ff fa4b 	bl	802fe6c <__sinit>
 80309d6:	4b2e      	ldr	r3, [pc, #184]	; (8030a90 <__swsetup_r+0xd0>)
 80309d8:	429c      	cmp	r4, r3
 80309da:	d10f      	bne.n	80309fc <__swsetup_r+0x3c>
 80309dc:	686c      	ldr	r4, [r5, #4]
 80309de:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80309e2:	b29a      	uxth	r2, r3
 80309e4:	0715      	lsls	r5, r2, #28
 80309e6:	d42c      	bmi.n	8030a42 <__swsetup_r+0x82>
 80309e8:	06d0      	lsls	r0, r2, #27
 80309ea:	d411      	bmi.n	8030a10 <__swsetup_r+0x50>
 80309ec:	2209      	movs	r2, #9
 80309ee:	6032      	str	r2, [r6, #0]
 80309f0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80309f4:	81a3      	strh	r3, [r4, #12]
 80309f6:	f04f 30ff 	mov.w	r0, #4294967295
 80309fa:	e03e      	b.n	8030a7a <__swsetup_r+0xba>
 80309fc:	4b25      	ldr	r3, [pc, #148]	; (8030a94 <__swsetup_r+0xd4>)
 80309fe:	429c      	cmp	r4, r3
 8030a00:	d101      	bne.n	8030a06 <__swsetup_r+0x46>
 8030a02:	68ac      	ldr	r4, [r5, #8]
 8030a04:	e7eb      	b.n	80309de <__swsetup_r+0x1e>
 8030a06:	4b24      	ldr	r3, [pc, #144]	; (8030a98 <__swsetup_r+0xd8>)
 8030a08:	429c      	cmp	r4, r3
 8030a0a:	bf08      	it	eq
 8030a0c:	68ec      	ldreq	r4, [r5, #12]
 8030a0e:	e7e6      	b.n	80309de <__swsetup_r+0x1e>
 8030a10:	0751      	lsls	r1, r2, #29
 8030a12:	d512      	bpl.n	8030a3a <__swsetup_r+0x7a>
 8030a14:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8030a16:	b141      	cbz	r1, 8030a2a <__swsetup_r+0x6a>
 8030a18:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8030a1c:	4299      	cmp	r1, r3
 8030a1e:	d002      	beq.n	8030a26 <__swsetup_r+0x66>
 8030a20:	4630      	mov	r0, r6
 8030a22:	f7ff fb57 	bl	80300d4 <_free_r>
 8030a26:	2300      	movs	r3, #0
 8030a28:	6363      	str	r3, [r4, #52]	; 0x34
 8030a2a:	89a3      	ldrh	r3, [r4, #12]
 8030a2c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8030a30:	81a3      	strh	r3, [r4, #12]
 8030a32:	2300      	movs	r3, #0
 8030a34:	6063      	str	r3, [r4, #4]
 8030a36:	6923      	ldr	r3, [r4, #16]
 8030a38:	6023      	str	r3, [r4, #0]
 8030a3a:	89a3      	ldrh	r3, [r4, #12]
 8030a3c:	f043 0308 	orr.w	r3, r3, #8
 8030a40:	81a3      	strh	r3, [r4, #12]
 8030a42:	6923      	ldr	r3, [r4, #16]
 8030a44:	b94b      	cbnz	r3, 8030a5a <__swsetup_r+0x9a>
 8030a46:	89a3      	ldrh	r3, [r4, #12]
 8030a48:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8030a4c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8030a50:	d003      	beq.n	8030a5a <__swsetup_r+0x9a>
 8030a52:	4621      	mov	r1, r4
 8030a54:	4630      	mov	r0, r6
 8030a56:	f000 f867 	bl	8030b28 <__smakebuf_r>
 8030a5a:	89a2      	ldrh	r2, [r4, #12]
 8030a5c:	f012 0301 	ands.w	r3, r2, #1
 8030a60:	d00c      	beq.n	8030a7c <__swsetup_r+0xbc>
 8030a62:	2300      	movs	r3, #0
 8030a64:	60a3      	str	r3, [r4, #8]
 8030a66:	6963      	ldr	r3, [r4, #20]
 8030a68:	425b      	negs	r3, r3
 8030a6a:	61a3      	str	r3, [r4, #24]
 8030a6c:	6923      	ldr	r3, [r4, #16]
 8030a6e:	b953      	cbnz	r3, 8030a86 <__swsetup_r+0xc6>
 8030a70:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8030a74:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8030a78:	d1ba      	bne.n	80309f0 <__swsetup_r+0x30>
 8030a7a:	bd70      	pop	{r4, r5, r6, pc}
 8030a7c:	0792      	lsls	r2, r2, #30
 8030a7e:	bf58      	it	pl
 8030a80:	6963      	ldrpl	r3, [r4, #20]
 8030a82:	60a3      	str	r3, [r4, #8]
 8030a84:	e7f2      	b.n	8030a6c <__swsetup_r+0xac>
 8030a86:	2000      	movs	r0, #0
 8030a88:	e7f7      	b.n	8030a7a <__swsetup_r+0xba>
 8030a8a:	bf00      	nop
 8030a8c:	200005cc 	.word	0x200005cc
 8030a90:	08031420 	.word	0x08031420
 8030a94:	08031440 	.word	0x08031440
 8030a98:	08031400 	.word	0x08031400

08030a9c <_close_r>:
 8030a9c:	b538      	push	{r3, r4, r5, lr}
 8030a9e:	4c06      	ldr	r4, [pc, #24]	; (8030ab8 <_close_r+0x1c>)
 8030aa0:	2300      	movs	r3, #0
 8030aa2:	4605      	mov	r5, r0
 8030aa4:	4608      	mov	r0, r1
 8030aa6:	6023      	str	r3, [r4, #0]
 8030aa8:	f7fa ffa3 	bl	802b9f2 <_close>
 8030aac:	1c43      	adds	r3, r0, #1
 8030aae:	d102      	bne.n	8030ab6 <_close_r+0x1a>
 8030ab0:	6823      	ldr	r3, [r4, #0]
 8030ab2:	b103      	cbz	r3, 8030ab6 <_close_r+0x1a>
 8030ab4:	602b      	str	r3, [r5, #0]
 8030ab6:	bd38      	pop	{r3, r4, r5, pc}
 8030ab8:	2000481c 	.word	0x2000481c

08030abc <_lseek_r>:
 8030abc:	b538      	push	{r3, r4, r5, lr}
 8030abe:	4c07      	ldr	r4, [pc, #28]	; (8030adc <_lseek_r+0x20>)
 8030ac0:	4605      	mov	r5, r0
 8030ac2:	4608      	mov	r0, r1
 8030ac4:	4611      	mov	r1, r2
 8030ac6:	2200      	movs	r2, #0
 8030ac8:	6022      	str	r2, [r4, #0]
 8030aca:	461a      	mov	r2, r3
 8030acc:	f7fa ffb8 	bl	802ba40 <_lseek>
 8030ad0:	1c43      	adds	r3, r0, #1
 8030ad2:	d102      	bne.n	8030ada <_lseek_r+0x1e>
 8030ad4:	6823      	ldr	r3, [r4, #0]
 8030ad6:	b103      	cbz	r3, 8030ada <_lseek_r+0x1e>
 8030ad8:	602b      	str	r3, [r5, #0]
 8030ada:	bd38      	pop	{r3, r4, r5, pc}
 8030adc:	2000481c 	.word	0x2000481c

08030ae0 <__swhatbuf_r>:
 8030ae0:	b570      	push	{r4, r5, r6, lr}
 8030ae2:	460e      	mov	r6, r1
 8030ae4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8030ae8:	2900      	cmp	r1, #0
 8030aea:	b096      	sub	sp, #88	; 0x58
 8030aec:	4614      	mov	r4, r2
 8030aee:	461d      	mov	r5, r3
 8030af0:	da07      	bge.n	8030b02 <__swhatbuf_r+0x22>
 8030af2:	2300      	movs	r3, #0
 8030af4:	602b      	str	r3, [r5, #0]
 8030af6:	89b3      	ldrh	r3, [r6, #12]
 8030af8:	061a      	lsls	r2, r3, #24
 8030afa:	d410      	bmi.n	8030b1e <__swhatbuf_r+0x3e>
 8030afc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8030b00:	e00e      	b.n	8030b20 <__swhatbuf_r+0x40>
 8030b02:	466a      	mov	r2, sp
 8030b04:	f000 f864 	bl	8030bd0 <_fstat_r>
 8030b08:	2800      	cmp	r0, #0
 8030b0a:	dbf2      	blt.n	8030af2 <__swhatbuf_r+0x12>
 8030b0c:	9a01      	ldr	r2, [sp, #4]
 8030b0e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8030b12:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8030b16:	425a      	negs	r2, r3
 8030b18:	415a      	adcs	r2, r3
 8030b1a:	602a      	str	r2, [r5, #0]
 8030b1c:	e7ee      	b.n	8030afc <__swhatbuf_r+0x1c>
 8030b1e:	2340      	movs	r3, #64	; 0x40
 8030b20:	2000      	movs	r0, #0
 8030b22:	6023      	str	r3, [r4, #0]
 8030b24:	b016      	add	sp, #88	; 0x58
 8030b26:	bd70      	pop	{r4, r5, r6, pc}

08030b28 <__smakebuf_r>:
 8030b28:	898b      	ldrh	r3, [r1, #12]
 8030b2a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8030b2c:	079d      	lsls	r5, r3, #30
 8030b2e:	4606      	mov	r6, r0
 8030b30:	460c      	mov	r4, r1
 8030b32:	d507      	bpl.n	8030b44 <__smakebuf_r+0x1c>
 8030b34:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8030b38:	6023      	str	r3, [r4, #0]
 8030b3a:	6123      	str	r3, [r4, #16]
 8030b3c:	2301      	movs	r3, #1
 8030b3e:	6163      	str	r3, [r4, #20]
 8030b40:	b002      	add	sp, #8
 8030b42:	bd70      	pop	{r4, r5, r6, pc}
 8030b44:	ab01      	add	r3, sp, #4
 8030b46:	466a      	mov	r2, sp
 8030b48:	f7ff ffca 	bl	8030ae0 <__swhatbuf_r>
 8030b4c:	9900      	ldr	r1, [sp, #0]
 8030b4e:	4605      	mov	r5, r0
 8030b50:	4630      	mov	r0, r6
 8030b52:	f7ff fb0d 	bl	8030170 <_malloc_r>
 8030b56:	b948      	cbnz	r0, 8030b6c <__smakebuf_r+0x44>
 8030b58:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8030b5c:	059a      	lsls	r2, r3, #22
 8030b5e:	d4ef      	bmi.n	8030b40 <__smakebuf_r+0x18>
 8030b60:	f023 0303 	bic.w	r3, r3, #3
 8030b64:	f043 0302 	orr.w	r3, r3, #2
 8030b68:	81a3      	strh	r3, [r4, #12]
 8030b6a:	e7e3      	b.n	8030b34 <__smakebuf_r+0xc>
 8030b6c:	4b0d      	ldr	r3, [pc, #52]	; (8030ba4 <__smakebuf_r+0x7c>)
 8030b6e:	62b3      	str	r3, [r6, #40]	; 0x28
 8030b70:	89a3      	ldrh	r3, [r4, #12]
 8030b72:	6020      	str	r0, [r4, #0]
 8030b74:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8030b78:	81a3      	strh	r3, [r4, #12]
 8030b7a:	9b00      	ldr	r3, [sp, #0]
 8030b7c:	6163      	str	r3, [r4, #20]
 8030b7e:	9b01      	ldr	r3, [sp, #4]
 8030b80:	6120      	str	r0, [r4, #16]
 8030b82:	b15b      	cbz	r3, 8030b9c <__smakebuf_r+0x74>
 8030b84:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8030b88:	4630      	mov	r0, r6
 8030b8a:	f000 f833 	bl	8030bf4 <_isatty_r>
 8030b8e:	b128      	cbz	r0, 8030b9c <__smakebuf_r+0x74>
 8030b90:	89a3      	ldrh	r3, [r4, #12]
 8030b92:	f023 0303 	bic.w	r3, r3, #3
 8030b96:	f043 0301 	orr.w	r3, r3, #1
 8030b9a:	81a3      	strh	r3, [r4, #12]
 8030b9c:	89a3      	ldrh	r3, [r4, #12]
 8030b9e:	431d      	orrs	r5, r3
 8030ba0:	81a5      	strh	r5, [r4, #12]
 8030ba2:	e7cd      	b.n	8030b40 <__smakebuf_r+0x18>
 8030ba4:	0802fe35 	.word	0x0802fe35

08030ba8 <__malloc_lock>:
 8030ba8:	4770      	bx	lr

08030baa <__malloc_unlock>:
 8030baa:	4770      	bx	lr

08030bac <_read_r>:
 8030bac:	b538      	push	{r3, r4, r5, lr}
 8030bae:	4c07      	ldr	r4, [pc, #28]	; (8030bcc <_read_r+0x20>)
 8030bb0:	4605      	mov	r5, r0
 8030bb2:	4608      	mov	r0, r1
 8030bb4:	4611      	mov	r1, r2
 8030bb6:	2200      	movs	r2, #0
 8030bb8:	6022      	str	r2, [r4, #0]
 8030bba:	461a      	mov	r2, r3
 8030bbc:	f7fa fee0 	bl	802b980 <_read>
 8030bc0:	1c43      	adds	r3, r0, #1
 8030bc2:	d102      	bne.n	8030bca <_read_r+0x1e>
 8030bc4:	6823      	ldr	r3, [r4, #0]
 8030bc6:	b103      	cbz	r3, 8030bca <_read_r+0x1e>
 8030bc8:	602b      	str	r3, [r5, #0]
 8030bca:	bd38      	pop	{r3, r4, r5, pc}
 8030bcc:	2000481c 	.word	0x2000481c

08030bd0 <_fstat_r>:
 8030bd0:	b538      	push	{r3, r4, r5, lr}
 8030bd2:	4c07      	ldr	r4, [pc, #28]	; (8030bf0 <_fstat_r+0x20>)
 8030bd4:	2300      	movs	r3, #0
 8030bd6:	4605      	mov	r5, r0
 8030bd8:	4608      	mov	r0, r1
 8030bda:	4611      	mov	r1, r2
 8030bdc:	6023      	str	r3, [r4, #0]
 8030bde:	f7fa ff14 	bl	802ba0a <_fstat>
 8030be2:	1c43      	adds	r3, r0, #1
 8030be4:	d102      	bne.n	8030bec <_fstat_r+0x1c>
 8030be6:	6823      	ldr	r3, [r4, #0]
 8030be8:	b103      	cbz	r3, 8030bec <_fstat_r+0x1c>
 8030bea:	602b      	str	r3, [r5, #0]
 8030bec:	bd38      	pop	{r3, r4, r5, pc}
 8030bee:	bf00      	nop
 8030bf0:	2000481c 	.word	0x2000481c

08030bf4 <_isatty_r>:
 8030bf4:	b538      	push	{r3, r4, r5, lr}
 8030bf6:	4c06      	ldr	r4, [pc, #24]	; (8030c10 <_isatty_r+0x1c>)
 8030bf8:	2300      	movs	r3, #0
 8030bfa:	4605      	mov	r5, r0
 8030bfc:	4608      	mov	r0, r1
 8030bfe:	6023      	str	r3, [r4, #0]
 8030c00:	f7fa ff13 	bl	802ba2a <_isatty>
 8030c04:	1c43      	adds	r3, r0, #1
 8030c06:	d102      	bne.n	8030c0e <_isatty_r+0x1a>
 8030c08:	6823      	ldr	r3, [r4, #0]
 8030c0a:	b103      	cbz	r3, 8030c0e <_isatty_r+0x1a>
 8030c0c:	602b      	str	r3, [r5, #0]
 8030c0e:	bd38      	pop	{r3, r4, r5, pc}
 8030c10:	2000481c 	.word	0x2000481c

08030c14 <sqrt>:
 8030c14:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8030c18:	ed2d 8b02 	vpush	{d8}
 8030c1c:	b08b      	sub	sp, #44	; 0x2c
 8030c1e:	ec55 4b10 	vmov	r4, r5, d0
 8030c22:	f000 f851 	bl	8030cc8 <__ieee754_sqrt>
 8030c26:	4b26      	ldr	r3, [pc, #152]	; (8030cc0 <sqrt+0xac>)
 8030c28:	eeb0 8a40 	vmov.f32	s16, s0
 8030c2c:	eef0 8a60 	vmov.f32	s17, s1
 8030c30:	f993 6000 	ldrsb.w	r6, [r3]
 8030c34:	1c73      	adds	r3, r6, #1
 8030c36:	d02a      	beq.n	8030c8e <sqrt+0x7a>
 8030c38:	4622      	mov	r2, r4
 8030c3a:	462b      	mov	r3, r5
 8030c3c:	4620      	mov	r0, r4
 8030c3e:	4629      	mov	r1, r5
 8030c40:	f7f8 fa2c 	bl	802909c <__aeabi_dcmpun>
 8030c44:	4607      	mov	r7, r0
 8030c46:	bb10      	cbnz	r0, 8030c8e <sqrt+0x7a>
 8030c48:	f04f 0800 	mov.w	r8, #0
 8030c4c:	f04f 0900 	mov.w	r9, #0
 8030c50:	4642      	mov	r2, r8
 8030c52:	464b      	mov	r3, r9
 8030c54:	4620      	mov	r0, r4
 8030c56:	4629      	mov	r1, r5
 8030c58:	f7f8 f9f8 	bl	802904c <__aeabi_dcmplt>
 8030c5c:	b1b8      	cbz	r0, 8030c8e <sqrt+0x7a>
 8030c5e:	2301      	movs	r3, #1
 8030c60:	9300      	str	r3, [sp, #0]
 8030c62:	4b18      	ldr	r3, [pc, #96]	; (8030cc4 <sqrt+0xb0>)
 8030c64:	9301      	str	r3, [sp, #4]
 8030c66:	9708      	str	r7, [sp, #32]
 8030c68:	e9cd 4504 	strd	r4, r5, [sp, #16]
 8030c6c:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8030c70:	b9b6      	cbnz	r6, 8030ca0 <sqrt+0x8c>
 8030c72:	e9cd 8906 	strd	r8, r9, [sp, #24]
 8030c76:	4668      	mov	r0, sp
 8030c78:	f000 f8d6 	bl	8030e28 <matherr>
 8030c7c:	b1d0      	cbz	r0, 8030cb4 <sqrt+0xa0>
 8030c7e:	9b08      	ldr	r3, [sp, #32]
 8030c80:	b11b      	cbz	r3, 8030c8a <sqrt+0x76>
 8030c82:	f7fe ffeb 	bl	802fc5c <__errno>
 8030c86:	9b08      	ldr	r3, [sp, #32]
 8030c88:	6003      	str	r3, [r0, #0]
 8030c8a:	ed9d 8b06 	vldr	d8, [sp, #24]
 8030c8e:	eeb0 0a48 	vmov.f32	s0, s16
 8030c92:	eef0 0a68 	vmov.f32	s1, s17
 8030c96:	b00b      	add	sp, #44	; 0x2c
 8030c98:	ecbd 8b02 	vpop	{d8}
 8030c9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8030ca0:	4642      	mov	r2, r8
 8030ca2:	464b      	mov	r3, r9
 8030ca4:	4640      	mov	r0, r8
 8030ca6:	4649      	mov	r1, r9
 8030ca8:	f7f8 f888 	bl	8028dbc <__aeabi_ddiv>
 8030cac:	2e02      	cmp	r6, #2
 8030cae:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8030cb2:	d1e0      	bne.n	8030c76 <sqrt+0x62>
 8030cb4:	f7fe ffd2 	bl	802fc5c <__errno>
 8030cb8:	2321      	movs	r3, #33	; 0x21
 8030cba:	6003      	str	r3, [r0, #0]
 8030cbc:	e7df      	b.n	8030c7e <sqrt+0x6a>
 8030cbe:	bf00      	nop
 8030cc0:	20000630 	.word	0x20000630
 8030cc4:	08031497 	.word	0x08031497

08030cc8 <__ieee754_sqrt>:
 8030cc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8030ccc:	4955      	ldr	r1, [pc, #340]	; (8030e24 <__ieee754_sqrt+0x15c>)
 8030cce:	ec55 4b10 	vmov	r4, r5, d0
 8030cd2:	43a9      	bics	r1, r5
 8030cd4:	462b      	mov	r3, r5
 8030cd6:	462a      	mov	r2, r5
 8030cd8:	d112      	bne.n	8030d00 <__ieee754_sqrt+0x38>
 8030cda:	ee10 2a10 	vmov	r2, s0
 8030cde:	ee10 0a10 	vmov	r0, s0
 8030ce2:	4629      	mov	r1, r5
 8030ce4:	f7f7 ff40 	bl	8028b68 <__aeabi_dmul>
 8030ce8:	4602      	mov	r2, r0
 8030cea:	460b      	mov	r3, r1
 8030cec:	4620      	mov	r0, r4
 8030cee:	4629      	mov	r1, r5
 8030cf0:	f7f7 fd84 	bl	80287fc <__adddf3>
 8030cf4:	4604      	mov	r4, r0
 8030cf6:	460d      	mov	r5, r1
 8030cf8:	ec45 4b10 	vmov	d0, r4, r5
 8030cfc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8030d00:	2d00      	cmp	r5, #0
 8030d02:	ee10 0a10 	vmov	r0, s0
 8030d06:	4621      	mov	r1, r4
 8030d08:	dc0f      	bgt.n	8030d2a <__ieee754_sqrt+0x62>
 8030d0a:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
 8030d0e:	4330      	orrs	r0, r6
 8030d10:	d0f2      	beq.n	8030cf8 <__ieee754_sqrt+0x30>
 8030d12:	b155      	cbz	r5, 8030d2a <__ieee754_sqrt+0x62>
 8030d14:	ee10 2a10 	vmov	r2, s0
 8030d18:	4620      	mov	r0, r4
 8030d1a:	4629      	mov	r1, r5
 8030d1c:	f7f7 fd6c 	bl	80287f8 <__aeabi_dsub>
 8030d20:	4602      	mov	r2, r0
 8030d22:	460b      	mov	r3, r1
 8030d24:	f7f8 f84a 	bl	8028dbc <__aeabi_ddiv>
 8030d28:	e7e4      	b.n	8030cf4 <__ieee754_sqrt+0x2c>
 8030d2a:	151b      	asrs	r3, r3, #20
 8030d2c:	d073      	beq.n	8030e16 <__ieee754_sqrt+0x14e>
 8030d2e:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 8030d32:	07dd      	lsls	r5, r3, #31
 8030d34:	f3c2 0213 	ubfx	r2, r2, #0, #20
 8030d38:	bf48      	it	mi
 8030d3a:	0fc8      	lsrmi	r0, r1, #31
 8030d3c:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8030d40:	bf44      	itt	mi
 8030d42:	0049      	lslmi	r1, r1, #1
 8030d44:	eb00 0242 	addmi.w	r2, r0, r2, lsl #1
 8030d48:	2500      	movs	r5, #0
 8030d4a:	1058      	asrs	r0, r3, #1
 8030d4c:	0fcb      	lsrs	r3, r1, #31
 8030d4e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 8030d52:	0049      	lsls	r1, r1, #1
 8030d54:	2316      	movs	r3, #22
 8030d56:	462c      	mov	r4, r5
 8030d58:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 8030d5c:	19a7      	adds	r7, r4, r6
 8030d5e:	4297      	cmp	r7, r2
 8030d60:	bfde      	ittt	le
 8030d62:	19bc      	addle	r4, r7, r6
 8030d64:	1bd2      	suble	r2, r2, r7
 8030d66:	19ad      	addle	r5, r5, r6
 8030d68:	0fcf      	lsrs	r7, r1, #31
 8030d6a:	3b01      	subs	r3, #1
 8030d6c:	eb07 0242 	add.w	r2, r7, r2, lsl #1
 8030d70:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030d74:	ea4f 0656 	mov.w	r6, r6, lsr #1
 8030d78:	d1f0      	bne.n	8030d5c <__ieee754_sqrt+0x94>
 8030d7a:	f04f 0c20 	mov.w	ip, #32
 8030d7e:	469e      	mov	lr, r3
 8030d80:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 8030d84:	42a2      	cmp	r2, r4
 8030d86:	eb06 070e 	add.w	r7, r6, lr
 8030d8a:	dc02      	bgt.n	8030d92 <__ieee754_sqrt+0xca>
 8030d8c:	d112      	bne.n	8030db4 <__ieee754_sqrt+0xec>
 8030d8e:	428f      	cmp	r7, r1
 8030d90:	d810      	bhi.n	8030db4 <__ieee754_sqrt+0xec>
 8030d92:	2f00      	cmp	r7, #0
 8030d94:	eb07 0e06 	add.w	lr, r7, r6
 8030d98:	da42      	bge.n	8030e20 <__ieee754_sqrt+0x158>
 8030d9a:	f1be 0f00 	cmp.w	lr, #0
 8030d9e:	db3f      	blt.n	8030e20 <__ieee754_sqrt+0x158>
 8030da0:	f104 0801 	add.w	r8, r4, #1
 8030da4:	1b12      	subs	r2, r2, r4
 8030da6:	428f      	cmp	r7, r1
 8030da8:	bf88      	it	hi
 8030daa:	f102 32ff 	addhi.w	r2, r2, #4294967295
 8030dae:	1bc9      	subs	r1, r1, r7
 8030db0:	4433      	add	r3, r6
 8030db2:	4644      	mov	r4, r8
 8030db4:	0052      	lsls	r2, r2, #1
 8030db6:	f1bc 0c01 	subs.w	ip, ip, #1
 8030dba:	eb02 72d1 	add.w	r2, r2, r1, lsr #31
 8030dbe:	ea4f 0656 	mov.w	r6, r6, lsr #1
 8030dc2:	ea4f 0141 	mov.w	r1, r1, lsl #1
 8030dc6:	d1dd      	bne.n	8030d84 <__ieee754_sqrt+0xbc>
 8030dc8:	430a      	orrs	r2, r1
 8030dca:	d006      	beq.n	8030dda <__ieee754_sqrt+0x112>
 8030dcc:	1c5c      	adds	r4, r3, #1
 8030dce:	bf13      	iteet	ne
 8030dd0:	3301      	addne	r3, #1
 8030dd2:	3501      	addeq	r5, #1
 8030dd4:	4663      	moveq	r3, ip
 8030dd6:	f023 0301 	bicne.w	r3, r3, #1
 8030dda:	106a      	asrs	r2, r5, #1
 8030ddc:	085b      	lsrs	r3, r3, #1
 8030dde:	07e9      	lsls	r1, r5, #31
 8030de0:	f102 527f 	add.w	r2, r2, #1069547520	; 0x3fc00000
 8030de4:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
 8030de8:	bf48      	it	mi
 8030dea:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 8030dee:	eb02 5500 	add.w	r5, r2, r0, lsl #20
 8030df2:	461c      	mov	r4, r3
 8030df4:	e780      	b.n	8030cf8 <__ieee754_sqrt+0x30>
 8030df6:	0aca      	lsrs	r2, r1, #11
 8030df8:	3815      	subs	r0, #21
 8030dfa:	0549      	lsls	r1, r1, #21
 8030dfc:	2a00      	cmp	r2, #0
 8030dfe:	d0fa      	beq.n	8030df6 <__ieee754_sqrt+0x12e>
 8030e00:	02d6      	lsls	r6, r2, #11
 8030e02:	d50a      	bpl.n	8030e1a <__ieee754_sqrt+0x152>
 8030e04:	f1c3 0420 	rsb	r4, r3, #32
 8030e08:	fa21 f404 	lsr.w	r4, r1, r4
 8030e0c:	1e5d      	subs	r5, r3, #1
 8030e0e:	4099      	lsls	r1, r3
 8030e10:	4322      	orrs	r2, r4
 8030e12:	1b43      	subs	r3, r0, r5
 8030e14:	e78b      	b.n	8030d2e <__ieee754_sqrt+0x66>
 8030e16:	4618      	mov	r0, r3
 8030e18:	e7f0      	b.n	8030dfc <__ieee754_sqrt+0x134>
 8030e1a:	0052      	lsls	r2, r2, #1
 8030e1c:	3301      	adds	r3, #1
 8030e1e:	e7ef      	b.n	8030e00 <__ieee754_sqrt+0x138>
 8030e20:	46a0      	mov	r8, r4
 8030e22:	e7bf      	b.n	8030da4 <__ieee754_sqrt+0xdc>
 8030e24:	7ff00000 	.word	0x7ff00000

08030e28 <matherr>:
 8030e28:	2000      	movs	r0, #0
 8030e2a:	4770      	bx	lr

08030e2c <_init>:
 8030e2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030e2e:	bf00      	nop
 8030e30:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8030e32:	bc08      	pop	{r3}
 8030e34:	469e      	mov	lr, r3
 8030e36:	4770      	bx	lr

08030e38 <_fini>:
 8030e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8030e3a:	bf00      	nop
 8030e3c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8030e3e:	bc08      	pop	{r3}
 8030e40:	469e      	mov	lr, r3
 8030e42:	4770      	bx	lr
