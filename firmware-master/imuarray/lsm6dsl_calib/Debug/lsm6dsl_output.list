
lsm6dsl_output.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002ff28  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000007c4  080300c8  080300c8  000400c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0803088c  0803088c  0005010c  2**0
                  CONTENTS
  4 .ARM          00000008  0803088c  0803088c  0004088c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08030894  08030894  0005010c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08030894  08030894  00040894  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08030898  08030898  00040898  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000010c  20000000  0803089c  00050000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00004200  2000010c  080309a8  0005010c  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000430c  080309a8  0005430c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0005010c  2**0
                  CONTENTS, READONLY
 12 .debug_info   000868c1  00000000  00000000  0005013c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00015c1f  00000000  00000000  000d69fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00001e98  00000000  00000000  000ec620  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00006fb0  00000000  00000000  000ee4b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00019a3a  00000000  00000000  000f5468  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0004648d  00000000  00000000  0010eea2  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00094f71  00000000  00000000  0015532f  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      000000c7  00000000  00000000  001ea2a0  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000af00  00000000  00000000  001ea368  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    00052e65  00000000  00000000  001f5268  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	2000010c 	.word	0x2000010c
 80001bc:	00000000 	.word	0x00000000
 80001c0:	080300b0 	.word	0x080300b0

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000110 	.word	0x20000110
 80001dc:	080300b0 	.word	0x080300b0

080001e0 <gsl_blas_sdsdot>:
#define INT(X) ((int)(X))

int
gsl_blas_sdsdot (float alpha, const gsl_vector_float * X,
                 const gsl_vector_float * Y, float *result)
{
 80001e0:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 80001e2:	680b      	ldr	r3, [r1, #0]
{
 80001e4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80001e6:	6800      	ldr	r0, [r0, #0]
 80001e8:	4298      	cmp	r0, r3
{
 80001ea:	b083      	sub	sp, #12
  if (X->size == Y->size)
 80001ec:	d008      	beq.n	8000200 <gsl_blas_sdsdot+0x20>
                      INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80001ee:	490b      	ldr	r1, [pc, #44]	; (800021c <gsl_blas_sdsdot+0x3c>)
 80001f0:	480b      	ldr	r0, [pc, #44]	; (8000220 <gsl_blas_sdsdot+0x40>)
 80001f2:	2313      	movs	r3, #19
 80001f4:	2239      	movs	r2, #57	; 0x39
 80001f6:	f002 fb33 	bl	8002860 <gsl_error>
 80001fa:	2013      	movs	r0, #19
    }
}
 80001fc:	b003      	add	sp, #12
 80001fe:	bd30      	pop	{r4, r5, pc}
        cblas_sdsdot (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
 8000200:	684b      	ldr	r3, [r1, #4]
 8000202:	9300      	str	r3, [sp, #0]
 8000204:	688b      	ldr	r3, [r1, #8]
 8000206:	4615      	mov	r5, r2
 8000208:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800020c:	f007 f9aa 	bl	8007564 <cblas_sdsdot>
      return GSL_SUCCESS;
 8000210:	2000      	movs	r0, #0
      *result =
 8000212:	ed85 0a00 	vstr	s0, [r5]
}
 8000216:	b003      	add	sp, #12
 8000218:	bd30      	pop	{r4, r5, pc}
 800021a:	bf00      	nop
 800021c:	08030180 	.word	0x08030180
 8000220:	08030188 	.word	0x08030188

08000224 <gsl_blas_dsdot>:

int
gsl_blas_dsdot (const gsl_vector_float * X, const gsl_vector_float * Y,
                double *result)
{
 8000224:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 8000226:	680b      	ldr	r3, [r1, #0]
{
 8000228:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800022a:	6800      	ldr	r0, [r0, #0]
 800022c:	4298      	cmp	r0, r3
{
 800022e:	b083      	sub	sp, #12
  if (X->size == Y->size)
 8000230:	d008      	beq.n	8000244 <gsl_blas_dsdot+0x20>
                     INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000232:	490b      	ldr	r1, [pc, #44]	; (8000260 <gsl_blas_dsdot+0x3c>)
 8000234:	480b      	ldr	r0, [pc, #44]	; (8000264 <gsl_blas_dsdot+0x40>)
 8000236:	2313      	movs	r3, #19
 8000238:	224a      	movs	r2, #74	; 0x4a
 800023a:	f002 fb11 	bl	8002860 <gsl_error>
 800023e:	2013      	movs	r0, #19
    }
}
 8000240:	b003      	add	sp, #12
 8000242:	bd30      	pop	{r4, r5, pc}
        cblas_dsdot (INT (X->size), X->data, INT (X->stride), Y->data,
 8000244:	684b      	ldr	r3, [r1, #4]
 8000246:	9300      	str	r3, [sp, #0]
 8000248:	688b      	ldr	r3, [r1, #8]
 800024a:	4615      	mov	r5, r2
 800024c:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 8000250:	f00c ffec 	bl	800d22c <cblas_dsdot>
      return GSL_SUCCESS;
 8000254:	2000      	movs	r0, #0
      *result =
 8000256:	ed85 0b00 	vstr	d0, [r5]
}
 800025a:	b003      	add	sp, #12
 800025c:	bd30      	pop	{r4, r5, pc}
 800025e:	bf00      	nop
 8000260:	08030180 	.word	0x08030180
 8000264:	08030188 	.word	0x08030188

08000268 <gsl_blas_sdot>:

int
gsl_blas_sdot (const gsl_vector_float * X, const gsl_vector_float * Y,
               float *result)
{
 8000268:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 800026a:	680b      	ldr	r3, [r1, #0]
{
 800026c:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800026e:	6800      	ldr	r0, [r0, #0]
 8000270:	4298      	cmp	r0, r3
{
 8000272:	b083      	sub	sp, #12
  if (X->size == Y->size)
 8000274:	d008      	beq.n	8000288 <gsl_blas_sdot+0x20>
                    INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000276:	490b      	ldr	r1, [pc, #44]	; (80002a4 <gsl_blas_sdot+0x3c>)
 8000278:	480b      	ldr	r0, [pc, #44]	; (80002a8 <gsl_blas_sdot+0x40>)
 800027a:	2313      	movs	r3, #19
 800027c:	225b      	movs	r2, #91	; 0x5b
 800027e:	f002 faef 	bl	8002860 <gsl_error>
 8000282:	2013      	movs	r0, #19
    }
}
 8000284:	b003      	add	sp, #12
 8000286:	bd30      	pop	{r4, r5, pc}
        cblas_sdot (INT (X->size), X->data, INT (X->stride), Y->data,
 8000288:	684b      	ldr	r3, [r1, #4]
 800028a:	9300      	str	r3, [sp, #0]
 800028c:	688b      	ldr	r3, [r1, #8]
 800028e:	4615      	mov	r5, r2
 8000290:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 8000294:	f007 f93e 	bl	8007514 <cblas_sdot>
      return GSL_SUCCESS;
 8000298:	2000      	movs	r0, #0
      *result =
 800029a:	ed85 0a00 	vstr	s0, [r5]
}
 800029e:	b003      	add	sp, #12
 80002a0:	bd30      	pop	{r4, r5, pc}
 80002a2:	bf00      	nop
 80002a4:	08030180 	.word	0x08030180
 80002a8:	08030188 	.word	0x08030188

080002ac <gsl_blas_ddot>:

int
gsl_blas_ddot (const gsl_vector * X, const gsl_vector * Y, double *result)
{
 80002ac:	b530      	push	{r4, r5, lr}
  if (X->size == Y->size)
 80002ae:	680b      	ldr	r3, [r1, #0]
{
 80002b0:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80002b2:	6800      	ldr	r0, [r0, #0]
 80002b4:	4298      	cmp	r0, r3
{
 80002b6:	b083      	sub	sp, #12
  if (X->size == Y->size)
 80002b8:	d008      	beq.n	80002cc <gsl_blas_ddot+0x20>
                    INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80002ba:	490b      	ldr	r1, [pc, #44]	; (80002e8 <gsl_blas_ddot+0x3c>)
 80002bc:	480b      	ldr	r0, [pc, #44]	; (80002ec <gsl_blas_ddot+0x40>)
 80002be:	2313      	movs	r3, #19
 80002c0:	226b      	movs	r2, #107	; 0x6b
 80002c2:	f002 facd 	bl	8002860 <gsl_error>
 80002c6:	2013      	movs	r0, #19
    }
}
 80002c8:	b003      	add	sp, #12
 80002ca:	bd30      	pop	{r4, r5, pc}
        cblas_ddot (INT (X->size), X->data, INT (X->stride), Y->data,
 80002cc:	684b      	ldr	r3, [r1, #4]
 80002ce:	9300      	str	r3, [sp, #0]
 80002d0:	688b      	ldr	r3, [r1, #8]
 80002d2:	4615      	mov	r5, r2
 80002d4:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80002d8:	f00b fb76 	bl	800b9c8 <cblas_ddot>
      return GSL_SUCCESS;
 80002dc:	2000      	movs	r0, #0
      *result =
 80002de:	ed85 0b00 	vstr	d0, [r5]
}
 80002e2:	b003      	add	sp, #12
 80002e4:	bd30      	pop	{r4, r5, pc}
 80002e6:	bf00      	nop
 80002e8:	08030180 	.word	0x08030180
 80002ec:	08030188 	.word	0x08030188

080002f0 <gsl_blas_cdotu>:


int
gsl_blas_cdotu (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotu)
{
 80002f0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80002f2:	680b      	ldr	r3, [r1, #0]
{
 80002f4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80002f6:	6800      	ldr	r0, [r0, #0]
 80002f8:	4298      	cmp	r0, r3
{
 80002fa:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80002fc:	d008      	beq.n	8000310 <gsl_blas_cdotu+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotu));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80002fe:	490a      	ldr	r1, [pc, #40]	; (8000328 <gsl_blas_cdotu+0x38>)
 8000300:	480a      	ldr	r0, [pc, #40]	; (800032c <gsl_blas_cdotu+0x3c>)
 8000302:	2313      	movs	r3, #19
 8000304:	227c      	movs	r2, #124	; 0x7c
 8000306:	f002 faab 	bl	8002860 <gsl_error>
 800030a:	2013      	movs	r0, #19
    }
}
 800030c:	b002      	add	sp, #8
 800030e:	bd10      	pop	{r4, pc}
      cblas_cdotu_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 8000310:	684b      	ldr	r3, [r1, #4]
 8000312:	e9cd 3200 	strd	r3, r2, [sp]
 8000316:	688b      	ldr	r3, [r1, #8]
 8000318:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800031c:	f011 fbf8 	bl	8011b10 <cblas_cdotu_sub>
      return GSL_SUCCESS;
 8000320:	2000      	movs	r0, #0
}
 8000322:	b002      	add	sp, #8
 8000324:	bd10      	pop	{r4, pc}
 8000326:	bf00      	nop
 8000328:	08030180 	.word	0x08030180
 800032c:	08030188 	.word	0x08030188

08000330 <gsl_blas_cdotc>:


int
gsl_blas_cdotc (const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y, gsl_complex_float * dotc)
{
 8000330:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000332:	680b      	ldr	r3, [r1, #0]
{
 8000334:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000336:	6800      	ldr	r0, [r0, #0]
 8000338:	4298      	cmp	r0, r3
{
 800033a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800033c:	d008      	beq.n	8000350 <gsl_blas_cdotc+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotc));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800033e:	490a      	ldr	r1, [pc, #40]	; (8000368 <gsl_blas_cdotc+0x38>)
 8000340:	480a      	ldr	r0, [pc, #40]	; (800036c <gsl_blas_cdotc+0x3c>)
 8000342:	2313      	movs	r3, #19
 8000344:	228d      	movs	r2, #141	; 0x8d
 8000346:	f002 fa8b 	bl	8002860 <gsl_error>
 800034a:	2013      	movs	r0, #19
    }
}
 800034c:	b002      	add	sp, #8
 800034e:	bd10      	pop	{r4, pc}
      cblas_cdotc_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 8000350:	684b      	ldr	r3, [r1, #4]
 8000352:	e9cd 3200 	strd	r3, r2, [sp]
 8000356:	688b      	ldr	r3, [r1, #8]
 8000358:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800035c:	f011 fb44 	bl	80119e8 <cblas_cdotc_sub>
      return GSL_SUCCESS;
 8000360:	2000      	movs	r0, #0
}
 8000362:	b002      	add	sp, #8
 8000364:	bd10      	pop	{r4, pc}
 8000366:	bf00      	nop
 8000368:	08030180 	.word	0x08030180
 800036c:	08030188 	.word	0x08030188

08000370 <gsl_blas_zdotu>:


int
gsl_blas_zdotu (const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_complex * dotu)
{
 8000370:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000372:	680b      	ldr	r3, [r1, #0]
{
 8000374:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000376:	6800      	ldr	r0, [r0, #0]
 8000378:	4298      	cmp	r0, r3
{
 800037a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800037c:	d008      	beq.n	8000390 <gsl_blas_zdotu+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotu));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800037e:	490a      	ldr	r1, [pc, #40]	; (80003a8 <gsl_blas_zdotu+0x38>)
 8000380:	480a      	ldr	r0, [pc, #40]	; (80003ac <gsl_blas_zdotu+0x3c>)
 8000382:	2313      	movs	r3, #19
 8000384:	229e      	movs	r2, #158	; 0x9e
 8000386:	f002 fa6b 	bl	8002860 <gsl_error>
 800038a:	2013      	movs	r0, #19
    }
}
 800038c:	b002      	add	sp, #8
 800038e:	bd10      	pop	{r4, pc}
      cblas_zdotu_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 8000390:	684b      	ldr	r3, [r1, #4]
 8000392:	e9cd 3200 	strd	r3, r2, [sp]
 8000396:	688b      	ldr	r3, [r1, #8]
 8000398:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800039c:	f019 f9cc 	bl	8019738 <cblas_zdotu_sub>
      return GSL_SUCCESS;
 80003a0:	2000      	movs	r0, #0
}
 80003a2:	b002      	add	sp, #8
 80003a4:	bd10      	pop	{r4, pc}
 80003a6:	bf00      	nop
 80003a8:	08030180 	.word	0x08030180
 80003ac:	08030188 	.word	0x08030188

080003b0 <gsl_blas_zdotc>:


int
gsl_blas_zdotc (const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_complex * dotc)
{
 80003b0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80003b2:	680b      	ldr	r3, [r1, #0]
{
 80003b4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80003b6:	6800      	ldr	r0, [r0, #0]
 80003b8:	4298      	cmp	r0, r3
{
 80003ba:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80003bc:	d008      	beq.n	80003d0 <gsl_blas_zdotc+0x20>
                       INT (Y->stride), GSL_COMPLEX_P (dotc));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80003be:	490a      	ldr	r1, [pc, #40]	; (80003e8 <gsl_blas_zdotc+0x38>)
 80003c0:	480a      	ldr	r0, [pc, #40]	; (80003ec <gsl_blas_zdotc+0x3c>)
 80003c2:	2313      	movs	r3, #19
 80003c4:	22af      	movs	r2, #175	; 0xaf
 80003c6:	f002 fa4b 	bl	8002860 <gsl_error>
 80003ca:	2013      	movs	r0, #19
    }
}
 80003cc:	b002      	add	sp, #8
 80003ce:	bd10      	pop	{r4, pc}
      cblas_zdotc_sub (INT (X->size), X->data, INT (X->stride), Y->data,
 80003d0:	684b      	ldr	r3, [r1, #4]
 80003d2:	e9cd 3200 	strd	r3, r2, [sp]
 80003d6:	688b      	ldr	r3, [r1, #8]
 80003d8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80003dc:	f019 f91c 	bl	8019618 <cblas_zdotc_sub>
      return GSL_SUCCESS;
 80003e0:	2000      	movs	r0, #0
}
 80003e2:	b002      	add	sp, #8
 80003e4:	bd10      	pop	{r4, pc}
 80003e6:	bf00      	nop
 80003e8:	08030180 	.word	0x08030180
 80003ec:	08030188 	.word	0x08030188

080003f0 <gsl_blas_snrm2>:
/* Norms of vectors */

float
gsl_blas_snrm2 (const gsl_vector_float * X)
{
  return cblas_snrm2 (INT (X->size), X->data, INT (X->stride));
 80003f0:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 80003f4:	6800      	ldr	r0, [r0, #0]
 80003f6:	f007 be2d 	b.w	8008054 <cblas_snrm2>
 80003fa:	bf00      	nop

080003fc <gsl_blas_dnrm2>:
}

double
gsl_blas_dnrm2 (const gsl_vector * X)
{
  return cblas_dnrm2 (INT (X->size), X->data, INT (X->stride));
 80003fc:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000400:	6800      	ldr	r0, [r0, #0]
 8000402:	f00c b999 	b.w	800c738 <cblas_dnrm2>
 8000406:	bf00      	nop

08000408 <gsl_blas_scnrm2>:
}

float
gsl_blas_scnrm2 (const gsl_vector_complex_float * X)
{
  return cblas_scnrm2 (INT (X->size), X->data, INT (X->stride));
 8000408:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 800040c:	6800      	ldr	r0, [r0, #0]
 800040e:	f006 bfdf 	b.w	80073d0 <cblas_scnrm2>
 8000412:	bf00      	nop

08000414 <gsl_blas_dznrm2>:
}

double
gsl_blas_dznrm2 (const gsl_vector_complex * X)
{
  return cblas_dznrm2 (INT (X->size), X->data, INT (X->stride));
 8000414:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000418:	6800      	ldr	r0, [r0, #0]
 800041a:	f011 b9ad 	b.w	8011778 <cblas_dznrm2>
 800041e:	bf00      	nop

08000420 <gsl_blas_sasum>:
/* Absolute sums of vectors */

float
gsl_blas_sasum (const gsl_vector_float * X)
{
  return cblas_sasum (INT (X->size), X->data, INT (X->stride));
 8000420:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000424:	6800      	ldr	r0, [r0, #0]
 8000426:	f006 befb 	b.w	8007220 <cblas_sasum>
 800042a:	bf00      	nop

0800042c <gsl_blas_dasum>:
}

double
gsl_blas_dasum (const gsl_vector * X)
{
  return cblas_dasum (INT (X->size), X->data, INT (X->stride));
 800042c:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000430:	6800      	ldr	r0, [r0, #0]
 8000432:	f00b b9c3 	b.w	800b7bc <cblas_dasum>
 8000436:	bf00      	nop

08000438 <gsl_blas_scasum>:
}

float
gsl_blas_scasum (const gsl_vector_complex_float * X)
{
  return cblas_scasum (INT (X->size), X->data, INT (X->stride));
 8000438:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 800043c:	6800      	ldr	r0, [r0, #0]
 800043e:	f006 bf85 	b.w	800734c <cblas_scasum>
 8000442:	bf00      	nop

08000444 <gsl_blas_dzasum>:
}

double
gsl_blas_dzasum (const gsl_vector_complex * X)
{
  return cblas_dzasum (INT (X->size), X->data, INT (X->stride));
 8000444:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000448:	6800      	ldr	r0, [r0, #0]
 800044a:	f011 b959 	b.w	8011700 <cblas_dzasum>
 800044e:	bf00      	nop

08000450 <gsl_blas_isamax>:
/* Maximum elements of vectors */

CBLAS_INDEX_t
gsl_blas_isamax (const gsl_vector_float * X)
{
  return cblas_isamax (INT (X->size), X->data, INT (X->stride));
 8000450:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000454:	6800      	ldr	r0, [r0, #0]
 8000456:	f027 ba8b 	b.w	8027970 <cblas_isamax>
 800045a:	bf00      	nop

0800045c <gsl_blas_idamax>:
}

CBLAS_INDEX_t
gsl_blas_idamax (const gsl_vector * X)
{
  return cblas_idamax (INT (X->size), X->data, INT (X->stride));
 800045c:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000460:	6800      	ldr	r0, [r0, #0]
 8000462:	f027 ba57 	b.w	8027914 <cblas_idamax>
 8000466:	bf00      	nop

08000468 <gsl_blas_icamax>:
}

CBLAS_INDEX_t
gsl_blas_icamax (const gsl_vector_complex_float * X)
{
  return cblas_icamax (INT (X->size), X->data, INT (X->stride));
 8000468:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 800046c:	6800      	ldr	r0, [r0, #0]
 800046e:	f027 ba27 	b.w	80278c0 <cblas_icamax>
 8000472:	bf00      	nop

08000474 <gsl_blas_izamax>:
}

CBLAS_INDEX_t
gsl_blas_izamax (const gsl_vector_complex * X)
{
  return cblas_izamax (INT (X->size), X->data, INT (X->stride));
 8000474:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000478:	6800      	ldr	r0, [r0, #0]
 800047a:	f027 ba9d 	b.w	80279b8 <cblas_izamax>
 800047e:	bf00      	nop

08000480 <gsl_blas_sswap>:

/* Swap vectors */

int
gsl_blas_sswap (gsl_vector_float * X, gsl_vector_float * Y)
{
 8000480:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000482:	680b      	ldr	r3, [r1, #0]
{
 8000484:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000486:	6800      	ldr	r0, [r0, #0]
 8000488:	4298      	cmp	r0, r3
{
 800048a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800048c:	d009      	beq.n	80004a2 <gsl_blas_sswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800048e:	490a      	ldr	r1, [pc, #40]	; (80004b8 <gsl_blas_sswap+0x38>)
 8000490:	480a      	ldr	r0, [pc, #40]	; (80004bc <gsl_blas_sswap+0x3c>)
 8000492:	2313      	movs	r3, #19
 8000494:	f240 120f 	movw	r2, #271	; 0x10f
 8000498:	f002 f9e2 	bl	8002860 <gsl_error>
 800049c:	2013      	movs	r0, #19
    }
}
 800049e:	b002      	add	sp, #8
 80004a0:	bd10      	pop	{r4, pc}
      cblas_sswap (INT (X->size), X->data, INT (X->stride), Y->data,
 80004a2:	684b      	ldr	r3, [r1, #4]
 80004a4:	9300      	str	r3, [sp, #0]
 80004a6:	688b      	ldr	r3, [r1, #8]
 80004a8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80004ac:	f008 f878 	bl	80085a0 <cblas_sswap>
      return GSL_SUCCESS;
 80004b0:	2000      	movs	r0, #0
}
 80004b2:	b002      	add	sp, #8
 80004b4:	bd10      	pop	{r4, pc}
 80004b6:	bf00      	nop
 80004b8:	08030180 	.word	0x08030180
 80004bc:	08030188 	.word	0x08030188

080004c0 <gsl_blas_dswap>:

int
gsl_blas_dswap (gsl_vector * X, gsl_vector * Y)
{
 80004c0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80004c2:	680b      	ldr	r3, [r1, #0]
{
 80004c4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80004c6:	6800      	ldr	r0, [r0, #0]
 80004c8:	4298      	cmp	r0, r3
{
 80004ca:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80004cc:	d009      	beq.n	80004e2 <gsl_blas_dswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80004ce:	490a      	ldr	r1, [pc, #40]	; (80004f8 <gsl_blas_dswap+0x38>)
 80004d0:	480a      	ldr	r0, [pc, #40]	; (80004fc <gsl_blas_dswap+0x3c>)
 80004d2:	2313      	movs	r3, #19
 80004d4:	f44f 728f 	mov.w	r2, #286	; 0x11e
 80004d8:	f002 f9c2 	bl	8002860 <gsl_error>
 80004dc:	2013      	movs	r0, #19
    };
}
 80004de:	b002      	add	sp, #8
 80004e0:	bd10      	pop	{r4, pc}
      cblas_dswap (INT (X->size), X->data, INT (X->stride), Y->data,
 80004e2:	684b      	ldr	r3, [r1, #4]
 80004e4:	9300      	str	r3, [sp, #0]
 80004e6:	688b      	ldr	r3, [r1, #8]
 80004e8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80004ec:	f00c fedc 	bl	800d2a8 <cblas_dswap>
      return GSL_SUCCESS;
 80004f0:	2000      	movs	r0, #0
}
 80004f2:	b002      	add	sp, #8
 80004f4:	bd10      	pop	{r4, pc}
 80004f6:	bf00      	nop
 80004f8:	08030180 	.word	0x08030180
 80004fc:	08030188 	.word	0x08030188

08000500 <gsl_blas_cswap>:

int
gsl_blas_cswap (gsl_vector_complex_float * X, gsl_vector_complex_float * Y)
{
 8000500:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000502:	680b      	ldr	r3, [r1, #0]
{
 8000504:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000506:	6800      	ldr	r0, [r0, #0]
 8000508:	4298      	cmp	r0, r3
{
 800050a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800050c:	d009      	beq.n	8000522 <gsl_blas_cswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800050e:	490a      	ldr	r1, [pc, #40]	; (8000538 <gsl_blas_cswap+0x38>)
 8000510:	480a      	ldr	r0, [pc, #40]	; (800053c <gsl_blas_cswap+0x3c>)
 8000512:	2313      	movs	r3, #19
 8000514:	f240 122d 	movw	r2, #301	; 0x12d
 8000518:	f002 f9a2 	bl	8002860 <gsl_error>
 800051c:	2013      	movs	r0, #19
    }
}
 800051e:	b002      	add	sp, #8
 8000520:	bd10      	pop	{r4, pc}
      cblas_cswap (INT (X->size), X->data, INT (X->stride), Y->data,
 8000522:	684b      	ldr	r3, [r1, #4]
 8000524:	9300      	str	r3, [sp, #0]
 8000526:	688b      	ldr	r3, [r1, #8]
 8000528:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800052c:	f014 ff6a 	bl	8015404 <cblas_cswap>
      return GSL_SUCCESS;
 8000530:	2000      	movs	r0, #0
}
 8000532:	b002      	add	sp, #8
 8000534:	bd10      	pop	{r4, pc}
 8000536:	bf00      	nop
 8000538:	08030180 	.word	0x08030180
 800053c:	08030188 	.word	0x08030188

08000540 <gsl_blas_zswap>:

int
gsl_blas_zswap (gsl_vector_complex * X, gsl_vector_complex * Y)
{
 8000540:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000542:	680b      	ldr	r3, [r1, #0]
{
 8000544:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000546:	6800      	ldr	r0, [r0, #0]
 8000548:	4298      	cmp	r0, r3
{
 800054a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800054c:	d009      	beq.n	8000562 <gsl_blas_zswap+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800054e:	490a      	ldr	r1, [pc, #40]	; (8000578 <gsl_blas_zswap+0x38>)
 8000550:	480a      	ldr	r0, [pc, #40]	; (800057c <gsl_blas_zswap+0x3c>)
 8000552:	2313      	movs	r3, #19
 8000554:	f44f 729e 	mov.w	r2, #316	; 0x13c
 8000558:	f002 f982 	bl	8002860 <gsl_error>
 800055c:	2013      	movs	r0, #19
    }
}
 800055e:	b002      	add	sp, #8
 8000560:	bd10      	pop	{r4, pc}
      cblas_zswap (INT (X->size), X->data, INT (X->stride), Y->data,
 8000562:	684b      	ldr	r3, [r1, #4]
 8000564:	9300      	str	r3, [sp, #0]
 8000566:	688b      	ldr	r3, [r1, #8]
 8000568:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800056c:	f01f fcc6 	bl	801fefc <cblas_zswap>
      return GSL_SUCCESS;
 8000570:	2000      	movs	r0, #0
}
 8000572:	b002      	add	sp, #8
 8000574:	bd10      	pop	{r4, pc}
 8000576:	bf00      	nop
 8000578:	08030180 	.word	0x08030180
 800057c:	08030188 	.word	0x08030188

08000580 <gsl_blas_scopy>:

/* Copy vectors */

int
gsl_blas_scopy (const gsl_vector_float * X, gsl_vector_float * Y)
{
 8000580:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000582:	680b      	ldr	r3, [r1, #0]
{
 8000584:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000586:	6800      	ldr	r0, [r0, #0]
 8000588:	4298      	cmp	r0, r3
{
 800058a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800058c:	d009      	beq.n	80005a2 <gsl_blas_scopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800058e:	490a      	ldr	r1, [pc, #40]	; (80005b8 <gsl_blas_scopy+0x38>)
 8000590:	480a      	ldr	r0, [pc, #40]	; (80005bc <gsl_blas_scopy+0x3c>)
 8000592:	2313      	movs	r3, #19
 8000594:	f44f 72a7 	mov.w	r2, #334	; 0x14e
 8000598:	f002 f962 	bl	8002860 <gsl_error>
 800059c:	2013      	movs	r0, #19
    }
}
 800059e:	b002      	add	sp, #8
 80005a0:	bd10      	pop	{r4, pc}
      cblas_scopy (INT (X->size), X->data, INT (X->stride), Y->data,
 80005a2:	684b      	ldr	r3, [r1, #4]
 80005a4:	9300      	str	r3, [sp, #0]
 80005a6:	688b      	ldr	r3, [r1, #8]
 80005a8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80005ac:	f006 ff92 	bl	80074d4 <cblas_scopy>
      return GSL_SUCCESS;
 80005b0:	2000      	movs	r0, #0
}
 80005b2:	b002      	add	sp, #8
 80005b4:	bd10      	pop	{r4, pc}
 80005b6:	bf00      	nop
 80005b8:	08030180 	.word	0x08030180
 80005bc:	08030188 	.word	0x08030188

080005c0 <gsl_blas_dcopy>:

int
gsl_blas_dcopy (const gsl_vector * X, gsl_vector * Y)
{
 80005c0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80005c2:	680b      	ldr	r3, [r1, #0]
{
 80005c4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80005c6:	6800      	ldr	r0, [r0, #0]
 80005c8:	4298      	cmp	r0, r3
{
 80005ca:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80005cc:	d009      	beq.n	80005e2 <gsl_blas_dcopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80005ce:	490a      	ldr	r1, [pc, #40]	; (80005f8 <gsl_blas_dcopy+0x38>)
 80005d0:	480a      	ldr	r0, [pc, #40]	; (80005fc <gsl_blas_dcopy+0x3c>)
 80005d2:	2313      	movs	r3, #19
 80005d4:	f240 125d 	movw	r2, #349	; 0x15d
 80005d8:	f002 f942 	bl	8002860 <gsl_error>
 80005dc:	2013      	movs	r0, #19
    }
}
 80005de:	b002      	add	sp, #8
 80005e0:	bd10      	pop	{r4, pc}
      cblas_dcopy (INT (X->size), X->data, INT (X->stride), Y->data,
 80005e2:	684b      	ldr	r3, [r1, #4]
 80005e4:	9300      	str	r3, [sp, #0]
 80005e6:	688b      	ldr	r3, [r1, #8]
 80005e8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80005ec:	f00b f9ca 	bl	800b984 <cblas_dcopy>
      return GSL_SUCCESS;
 80005f0:	2000      	movs	r0, #0
}
 80005f2:	b002      	add	sp, #8
 80005f4:	bd10      	pop	{r4, pc}
 80005f6:	bf00      	nop
 80005f8:	08030180 	.word	0x08030180
 80005fc:	08030188 	.word	0x08030188

08000600 <gsl_blas_ccopy>:

int
gsl_blas_ccopy (const gsl_vector_complex_float * X,
                gsl_vector_complex_float * Y)
{
 8000600:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000602:	680b      	ldr	r3, [r1, #0]
{
 8000604:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000606:	6800      	ldr	r0, [r0, #0]
 8000608:	4298      	cmp	r0, r3
{
 800060a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800060c:	d009      	beq.n	8000622 <gsl_blas_ccopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800060e:	490a      	ldr	r1, [pc, #40]	; (8000638 <gsl_blas_ccopy+0x38>)
 8000610:	480a      	ldr	r0, [pc, #40]	; (800063c <gsl_blas_ccopy+0x3c>)
 8000612:	2313      	movs	r3, #19
 8000614:	f240 126d 	movw	r2, #365	; 0x16d
 8000618:	f002 f922 	bl	8002860 <gsl_error>
 800061c:	2013      	movs	r0, #19
    }
}
 800061e:	b002      	add	sp, #8
 8000620:	bd10      	pop	{r4, pc}
      cblas_ccopy (INT (X->size), X->data, INT (X->stride), Y->data,
 8000622:	684b      	ldr	r3, [r1, #4]
 8000624:	9300      	str	r3, [sp, #0]
 8000626:	688b      	ldr	r3, [r1, #8]
 8000628:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800062c:	f011 f9ba 	bl	80119a4 <cblas_ccopy>
      return GSL_SUCCESS;
 8000630:	2000      	movs	r0, #0
}
 8000632:	b002      	add	sp, #8
 8000634:	bd10      	pop	{r4, pc}
 8000636:	bf00      	nop
 8000638:	08030180 	.word	0x08030180
 800063c:	08030188 	.word	0x08030188

08000640 <gsl_blas_zcopy>:

int
gsl_blas_zcopy (const gsl_vector_complex * X, gsl_vector_complex * Y)
{
 8000640:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000642:	680b      	ldr	r3, [r1, #0]
{
 8000644:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000646:	6800      	ldr	r0, [r0, #0]
 8000648:	4298      	cmp	r0, r3
{
 800064a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800064c:	d009      	beq.n	8000662 <gsl_blas_zcopy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800064e:	490a      	ldr	r1, [pc, #40]	; (8000678 <gsl_blas_zcopy+0x38>)
 8000650:	480a      	ldr	r0, [pc, #40]	; (800067c <gsl_blas_zcopy+0x3c>)
 8000652:	2313      	movs	r3, #19
 8000654:	f44f 72be 	mov.w	r2, #380	; 0x17c
 8000658:	f002 f902 	bl	8002860 <gsl_error>
 800065c:	2013      	movs	r0, #19
    }
}
 800065e:	b002      	add	sp, #8
 8000660:	bd10      	pop	{r4, pc}
      cblas_zcopy (INT (X->size), X->data, INT (X->stride), Y->data,
 8000662:	684b      	ldr	r3, [r1, #4]
 8000664:	9300      	str	r3, [sp, #0]
 8000666:	688b      	ldr	r3, [r1, #8]
 8000668:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800066c:	f018 ffae 	bl	80195cc <cblas_zcopy>
      return GSL_SUCCESS;
 8000670:	2000      	movs	r0, #0
}
 8000672:	b002      	add	sp, #8
 8000674:	bd10      	pop	{r4, pc}
 8000676:	bf00      	nop
 8000678:	08030180 	.word	0x08030180
 800067c:	08030188 	.word	0x08030188

08000680 <gsl_blas_saxpy>:

/* Compute Y = alpha X + Y */

int
gsl_blas_saxpy (float alpha, const gsl_vector_float * X, gsl_vector_float * Y)
{
 8000680:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000682:	680b      	ldr	r3, [r1, #0]
{
 8000684:	4604      	mov	r4, r0
  if (X->size == Y->size)
 8000686:	6800      	ldr	r0, [r0, #0]
 8000688:	4298      	cmp	r0, r3
{
 800068a:	b082      	sub	sp, #8
  if (X->size == Y->size)
 800068c:	d009      	beq.n	80006a2 <gsl_blas_saxpy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800068e:	490a      	ldr	r1, [pc, #40]	; (80006b8 <gsl_blas_saxpy+0x38>)
 8000690:	480a      	ldr	r0, [pc, #40]	; (80006bc <gsl_blas_saxpy+0x3c>)
 8000692:	2313      	movs	r3, #19
 8000694:	f44f 72c7 	mov.w	r2, #398	; 0x18e
 8000698:	f002 f8e2 	bl	8002860 <gsl_error>
 800069c:	2013      	movs	r0, #19
    }
}
 800069e:	b002      	add	sp, #8
 80006a0:	bd10      	pop	{r4, pc}
      cblas_saxpy (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
 80006a2:	684b      	ldr	r3, [r1, #4]
 80006a4:	9300      	str	r3, [sp, #0]
 80006a6:	688b      	ldr	r3, [r1, #8]
 80006a8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80006ac:	f006 fdd0 	bl	8007250 <cblas_saxpy>
      return GSL_SUCCESS;
 80006b0:	2000      	movs	r0, #0
}
 80006b2:	b002      	add	sp, #8
 80006b4:	bd10      	pop	{r4, pc}
 80006b6:	bf00      	nop
 80006b8:	08030180 	.word	0x08030180
 80006bc:	08030188 	.word	0x08030188

080006c0 <gsl_blas_daxpy>:

int
gsl_blas_daxpy (double alpha, const gsl_vector * X, gsl_vector * Y)
{
 80006c0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80006c2:	680b      	ldr	r3, [r1, #0]
{
 80006c4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80006c6:	6800      	ldr	r0, [r0, #0]
 80006c8:	4298      	cmp	r0, r3
{
 80006ca:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80006cc:	d009      	beq.n	80006e2 <gsl_blas_daxpy+0x22>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80006ce:	490a      	ldr	r1, [pc, #40]	; (80006f8 <gsl_blas_daxpy+0x38>)
 80006d0:	480a      	ldr	r0, [pc, #40]	; (80006fc <gsl_blas_daxpy+0x3c>)
 80006d2:	2313      	movs	r3, #19
 80006d4:	f240 129d 	movw	r2, #413	; 0x19d
 80006d8:	f002 f8c2 	bl	8002860 <gsl_error>
 80006dc:	2013      	movs	r0, #19
    }
}
 80006de:	b002      	add	sp, #8
 80006e0:	bd10      	pop	{r4, pc}
      cblas_daxpy (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
 80006e2:	684b      	ldr	r3, [r1, #4]
 80006e4:	9300      	str	r3, [sp, #0]
 80006e6:	688b      	ldr	r3, [r1, #8]
 80006e8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80006ec:	f00b f88c 	bl	800b808 <cblas_daxpy>
      return GSL_SUCCESS;
 80006f0:	2000      	movs	r0, #0
}
 80006f2:	b002      	add	sp, #8
 80006f4:	bd10      	pop	{r4, pc}
 80006f6:	bf00      	nop
 80006f8:	08030180 	.word	0x08030180
 80006fc:	08030188 	.word	0x08030188

08000700 <gsl_blas_caxpy>:

int
gsl_blas_caxpy (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                gsl_vector_complex_float * Y)
{
 8000700:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 8000702:	680b      	ldr	r3, [r1, #0]
{
 8000704:	4602      	mov	r2, r0
  if (X->size == Y->size)
 8000706:	6800      	ldr	r0, [r0, #0]
{
 8000708:	b084      	sub	sp, #16
  if (X->size == Y->size)
 800070a:	4298      	cmp	r0, r3
{
 800070c:	ed8d 0a02 	vstr	s0, [sp, #8]
 8000710:	edcd 0a03 	vstr	s1, [sp, #12]
  if (X->size == Y->size)
 8000714:	d009      	beq.n	800072a <gsl_blas_caxpy+0x2a>
                   INT (X->stride), Y->data, INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000716:	490b      	ldr	r1, [pc, #44]	; (8000744 <gsl_blas_caxpy+0x44>)
 8000718:	480b      	ldr	r0, [pc, #44]	; (8000748 <gsl_blas_caxpy+0x48>)
 800071a:	2313      	movs	r3, #19
 800071c:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
 8000720:	f002 f89e 	bl	8002860 <gsl_error>
 8000724:	2013      	movs	r0, #19
    }
}
 8000726:	b004      	add	sp, #16
 8000728:	bd10      	pop	{r4, pc}
      cblas_caxpy (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 800072a:	e9d1 4301 	ldrd	r4, r3, [r1, #4]
 800072e:	e9cd 3400 	strd	r3, r4, [sp]
 8000732:	a902      	add	r1, sp, #8
 8000734:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
 8000738:	f011 f8e4 	bl	8011904 <cblas_caxpy>
      return GSL_SUCCESS;
 800073c:	2000      	movs	r0, #0
}
 800073e:	b004      	add	sp, #16
 8000740:	bd10      	pop	{r4, pc}
 8000742:	bf00      	nop
 8000744:	08030180 	.word	0x08030180
 8000748:	08030188 	.word	0x08030188

0800074c <gsl_blas_zaxpy>:

int
gsl_blas_zaxpy (const gsl_complex alpha, const gsl_vector_complex * X,
                gsl_vector_complex * Y)
{
 800074c:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 800074e:	680b      	ldr	r3, [r1, #0]
{
 8000750:	4602      	mov	r2, r0
  if (X->size == Y->size)
 8000752:	6800      	ldr	r0, [r0, #0]
{
 8000754:	b086      	sub	sp, #24
  if (X->size == Y->size)
 8000756:	4298      	cmp	r0, r3
{
 8000758:	ed8d 0b02 	vstr	d0, [sp, #8]
 800075c:	ed8d 1b04 	vstr	d1, [sp, #16]
  if (X->size == Y->size)
 8000760:	d009      	beq.n	8000776 <gsl_blas_zaxpy+0x2a>
                   INT (X->stride), Y->data, INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000762:	490b      	ldr	r1, [pc, #44]	; (8000790 <gsl_blas_zaxpy+0x44>)
 8000764:	480b      	ldr	r0, [pc, #44]	; (8000794 <gsl_blas_zaxpy+0x48>)
 8000766:	2313      	movs	r3, #19
 8000768:	f44f 72df 	mov.w	r2, #446	; 0x1be
 800076c:	f002 f878 	bl	8002860 <gsl_error>
 8000770:	2013      	movs	r0, #19
    }
}
 8000772:	b006      	add	sp, #24
 8000774:	bd10      	pop	{r4, pc}
      cblas_zaxpy (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 8000776:	e9d1 4301 	ldrd	r4, r3, [r1, #4]
 800077a:	e9cd 3400 	strd	r3, r4, [sp]
 800077e:	a902      	add	r1, sp, #8
 8000780:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
 8000784:	f018 fe8e 	bl	80194a4 <cblas_zaxpy>
      return GSL_SUCCESS;
 8000788:	2000      	movs	r0, #0
}
 800078a:	b006      	add	sp, #24
 800078c:	bd10      	pop	{r4, pc}
 800078e:	bf00      	nop
 8000790:	08030180 	.word	0x08030180
 8000794:	08030188 	.word	0x08030188

08000798 <gsl_blas_srotg>:

/* Generate rotation */

int
gsl_blas_srotg (float a[], float b[], float c[], float s[])
{
 8000798:	b508      	push	{r3, lr}
  cblas_srotg (a, b, c, s);
 800079a:	f007 fce7 	bl	800816c <cblas_srotg>
  return GSL_SUCCESS;
}
 800079e:	2000      	movs	r0, #0
 80007a0:	bd08      	pop	{r3, pc}
 80007a2:	bf00      	nop

080007a4 <gsl_blas_drotg>:

int
gsl_blas_drotg (double a[], double b[], double c[], double s[])
{
 80007a4:	b508      	push	{r3, lr}
  cblas_drotg (a, b, c, s);
 80007a6:	f00c f8c3 	bl	800c930 <cblas_drotg>
  return GSL_SUCCESS;
}
 80007aa:	2000      	movs	r0, #0
 80007ac:	bd08      	pop	{r3, pc}
 80007ae:	bf00      	nop

080007b0 <gsl_blas_srot>:

/* Apply rotation to vectors */

int
gsl_blas_srot (gsl_vector_float * X, gsl_vector_float * Y, float c, float s)
{
 80007b0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80007b2:	680b      	ldr	r3, [r1, #0]
{
 80007b4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80007b6:	6800      	ldr	r0, [r0, #0]
 80007b8:	4298      	cmp	r0, r3
{
 80007ba:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80007bc:	d009      	beq.n	80007d2 <gsl_blas_srot+0x22>
                  INT (Y->stride), c, s);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80007be:	490a      	ldr	r1, [pc, #40]	; (80007e8 <gsl_blas_srot+0x38>)
 80007c0:	480a      	ldr	r0, [pc, #40]	; (80007ec <gsl_blas_srot+0x3c>)
 80007c2:	2313      	movs	r3, #19
 80007c4:	f240 12df 	movw	r2, #479	; 0x1df
 80007c8:	f002 f84a 	bl	8002860 <gsl_error>
 80007cc:	2013      	movs	r0, #19
    }
}
 80007ce:	b002      	add	sp, #8
 80007d0:	bd10      	pop	{r4, pc}
      cblas_srot (INT (X->size), X->data, INT (X->stride), Y->data,
 80007d2:	684b      	ldr	r3, [r1, #4]
 80007d4:	9300      	str	r3, [sp, #0]
 80007d6:	688b      	ldr	r3, [r1, #8]
 80007d8:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80007dc:	f007 fc96 	bl	800810c <cblas_srot>
      return GSL_SUCCESS;
 80007e0:	2000      	movs	r0, #0
}
 80007e2:	b002      	add	sp, #8
 80007e4:	bd10      	pop	{r4, pc}
 80007e6:	bf00      	nop
 80007e8:	08030180 	.word	0x08030180
 80007ec:	08030188 	.word	0x08030188

080007f0 <gsl_blas_drot>:

int
gsl_blas_drot (gsl_vector * X, gsl_vector * Y, const double c, const double s)
{
 80007f0:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 80007f2:	680b      	ldr	r3, [r1, #0]
{
 80007f4:	4604      	mov	r4, r0
  if (X->size == Y->size)
 80007f6:	6800      	ldr	r0, [r0, #0]
 80007f8:	4298      	cmp	r0, r3
{
 80007fa:	b082      	sub	sp, #8
  if (X->size == Y->size)
 80007fc:	d009      	beq.n	8000812 <gsl_blas_drot+0x22>
                  INT (Y->stride), c, s);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80007fe:	490a      	ldr	r1, [pc, #40]	; (8000828 <gsl_blas_drot+0x38>)
 8000800:	480a      	ldr	r0, [pc, #40]	; (800082c <gsl_blas_drot+0x3c>)
 8000802:	2313      	movs	r3, #19
 8000804:	f44f 72f7 	mov.w	r2, #494	; 0x1ee
 8000808:	f002 f82a 	bl	8002860 <gsl_error>
 800080c:	2013      	movs	r0, #19
    }
}
 800080e:	b002      	add	sp, #8
 8000810:	bd10      	pop	{r4, pc}
      cblas_drot (INT (X->size), X->data, INT (X->stride), Y->data,
 8000812:	684b      	ldr	r3, [r1, #4]
 8000814:	9300      	str	r3, [sp, #0]
 8000816:	688b      	ldr	r3, [r1, #8]
 8000818:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 800081c:	f00c f816 	bl	800c84c <cblas_drot>
      return GSL_SUCCESS;
 8000820:	2000      	movs	r0, #0
}
 8000822:	b002      	add	sp, #8
 8000824:	bd10      	pop	{r4, pc}
 8000826:	bf00      	nop
 8000828:	08030180 	.word	0x08030180
 800082c:	08030188 	.word	0x08030188

08000830 <gsl_blas_srotmg>:

/* Generate modified rotation */

int
gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[])
{
 8000830:	b508      	push	{r3, lr}
  cblas_srotmg (d1, d2, b1, b2, P);
 8000832:	f007 fd8b 	bl	800834c <cblas_srotmg>
  return GSL_SUCCESS;
}
 8000836:	2000      	movs	r0, #0
 8000838:	bd08      	pop	{r3, pc}
 800083a:	bf00      	nop

0800083c <gsl_blas_drotmg>:

int
gsl_blas_drotmg (double d1[], double d2[], double b1[], double b2, double P[])
{
 800083c:	b508      	push	{r3, lr}
  cblas_drotmg (d1, d2, b1, b2, P);
 800083e:	f00c fa3b 	bl	800ccb8 <cblas_drotmg>
  return GSL_SUCCESS;
}
 8000842:	2000      	movs	r0, #0
 8000844:	bd08      	pop	{r3, pc}
 8000846:	bf00      	nop

08000848 <gsl_blas_srotm>:

/* Apply modified rotation */

int
gsl_blas_srotm (gsl_vector_float * X, gsl_vector_float * Y, const float P[])
{
 8000848:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 800084a:	680b      	ldr	r3, [r1, #0]
{
 800084c:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800084e:	6800      	ldr	r0, [r0, #0]
 8000850:	4298      	cmp	r0, r3
{
 8000852:	b082      	sub	sp, #8
  if (X->size == Y->size)
 8000854:	d009      	beq.n	800086a <gsl_blas_srotm+0x22>
                   INT (Y->stride), P);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000856:	490a      	ldr	r1, [pc, #40]	; (8000880 <gsl_blas_srotm+0x38>)
 8000858:	480a      	ldr	r0, [pc, #40]	; (8000884 <gsl_blas_srotm+0x3c>)
 800085a:	2313      	movs	r3, #19
 800085c:	f240 2211 	movw	r2, #529	; 0x211
 8000860:	f001 fffe 	bl	8002860 <gsl_error>
 8000864:	2013      	movs	r0, #19
    }
}
 8000866:	b002      	add	sp, #8
 8000868:	bd10      	pop	{r4, pc}
      cblas_srotm (INT (X->size), X->data, INT (X->stride), Y->data,
 800086a:	684b      	ldr	r3, [r1, #4]
 800086c:	e9cd 3200 	strd	r3, r2, [sp]
 8000870:	688b      	ldr	r3, [r1, #8]
 8000872:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 8000876:	f007 fcfb 	bl	8008270 <cblas_srotm>
      return GSL_SUCCESS;
 800087a:	2000      	movs	r0, #0
}
 800087c:	b002      	add	sp, #8
 800087e:	bd10      	pop	{r4, pc}
 8000880:	08030180 	.word	0x08030180
 8000884:	08030188 	.word	0x08030188

08000888 <gsl_blas_drotm>:

int
gsl_blas_drotm (gsl_vector * X, gsl_vector * Y, const double P[])
{
 8000888:	b510      	push	{r4, lr}
  if (X->size == Y->size)
 800088a:	680b      	ldr	r3, [r1, #0]
{
 800088c:	4604      	mov	r4, r0
  if (X->size == Y->size)
 800088e:	6800      	ldr	r0, [r0, #0]
 8000890:	4298      	cmp	r0, r3
{
 8000892:	b082      	sub	sp, #8
  if (X->size == Y->size)
 8000894:	d009      	beq.n	80008aa <gsl_blas_drotm+0x22>
                   INT (Y->stride), P);
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000896:	490a      	ldr	r1, [pc, #40]	; (80008c0 <gsl_blas_drotm+0x38>)
 8000898:	480a      	ldr	r0, [pc, #40]	; (80008c4 <gsl_blas_drotm+0x3c>)
 800089a:	2313      	movs	r3, #19
 800089c:	f44f 7208 	mov.w	r2, #544	; 0x220
 80008a0:	f001 ffde 	bl	8002860 <gsl_error>
 80008a4:	2013      	movs	r0, #19
    }
}
 80008a6:	b002      	add	sp, #8
 80008a8:	bd10      	pop	{r4, pc}
      cblas_drotm (INT (X->size), X->data, INT (X->stride), Y->data,
 80008aa:	684b      	ldr	r3, [r1, #4]
 80008ac:	e9cd 3200 	strd	r3, r2, [sp]
 80008b0:	688b      	ldr	r3, [r1, #8]
 80008b2:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
 80008b6:	f00c f917 	bl	800cae8 <cblas_drotm>
      return GSL_SUCCESS;
 80008ba:	2000      	movs	r0, #0
}
 80008bc:	b002      	add	sp, #8
 80008be:	bd10      	pop	{r4, pc}
 80008c0:	08030180 	.word	0x08030180
 80008c4:	08030188 	.word	0x08030188

080008c8 <gsl_blas_sscal>:
/* Scale vector */

void
gsl_blas_sscal (float alpha, gsl_vector_float * X)
{
  cblas_sscal (INT (X->size), alpha, X->data, INT (X->stride));
 80008c8:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 80008cc:	6800      	ldr	r0, [r0, #0]
 80008ce:	f007 be55 	b.w	800857c <cblas_sscal>
 80008d2:	bf00      	nop

080008d4 <gsl_blas_dscal>:
}

void
gsl_blas_dscal (double alpha, gsl_vector * X)
{
  cblas_dscal (INT (X->size), alpha, X->data, INT (X->stride));
 80008d4:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 80008d8:	6800      	ldr	r0, [r0, #0]
 80008da:	f00c bc8b 	b.w	800d1f4 <cblas_dscal>
 80008de:	bf00      	nop

080008e0 <gsl_blas_cscal>:
}

void
gsl_blas_cscal (const gsl_complex_float alpha, gsl_vector_complex_float * X)
{
 80008e0:	b500      	push	{lr}
 80008e2:	b083      	sub	sp, #12
  cblas_cscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 80008e4:	e9d0 3201 	ldrd	r3, r2, [r0, #4]
 80008e8:	4669      	mov	r1, sp
 80008ea:	6800      	ldr	r0, [r0, #0]
{
 80008ec:	ed8d 0a00 	vstr	s0, [sp]
 80008f0:	edcd 0a01 	vstr	s1, [sp, #4]
  cblas_cscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 80008f4:	f014 fd42 	bl	801537c <cblas_cscal>
               INT (X->stride));
}
 80008f8:	b003      	add	sp, #12
 80008fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80008fe:	bf00      	nop

08000900 <gsl_blas_zscal>:

void
gsl_blas_zscal (const gsl_complex alpha, gsl_vector_complex * X)
{
 8000900:	b500      	push	{lr}
 8000902:	b085      	sub	sp, #20
  cblas_zscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 8000904:	e9d0 3201 	ldrd	r3, r2, [r0, #4]
 8000908:	4669      	mov	r1, sp
 800090a:	6800      	ldr	r0, [r0, #0]
{
 800090c:	ed8d 0b00 	vstr	d0, [sp]
 8000910:	ed8d 1b02 	vstr	d1, [sp, #8]
  cblas_zscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
 8000914:	f01f fa9c 	bl	801fe50 <cblas_zscal>
               INT (X->stride));
}
 8000918:	b005      	add	sp, #20
 800091a:	f85d fb04 	ldr.w	pc, [sp], #4
 800091e:	bf00      	nop

08000920 <gsl_blas_csscal>:

void
gsl_blas_csscal (float alpha, gsl_vector_complex_float * X)
{
  cblas_csscal (INT (X->size), alpha, X->data, INT (X->stride));
 8000920:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000924:	6800      	ldr	r0, [r0, #0]
 8000926:	f014 bd4f 	b.w	80153c8 <cblas_csscal>
 800092a:	bf00      	nop

0800092c <gsl_blas_zdscal>:
}

void
gsl_blas_zdscal (double alpha, gsl_vector_complex * X)
{
  cblas_zdscal (INT (X->size), alpha, X->data, INT (X->stride));
 800092c:	e9d0 2101 	ldrd	r2, r1, [r0, #4]
 8000930:	6800      	ldr	r0, [r0, #0]
 8000932:	f018 bf8d 	b.w	8019850 <cblas_zdscal>
 8000936:	bf00      	nop

08000938 <gsl_blas_sgemv>:

int
gsl_blas_sgemv (CBLAS_TRANSPOSE_t TransA, float alpha,
                const gsl_matrix_float * A, const gsl_vector_float * X,
                float beta, gsl_vector_float * Y)
{
 8000938:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 800093a:	286f      	cmp	r0, #111	; 0x6f
  const size_t N = A->size2;
 800093c:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 8000940:	b087      	sub	sp, #28
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000942:	d011      	beq.n	8000968 <gsl_blas_sgemv+0x30>
      || (TransA == CblasTrans && M == X->size && N == Y->size))
 8000944:	2870      	cmp	r0, #112	; 0x70
 8000946:	d105      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
 8000948:	6816      	ldr	r6, [r2, #0]
 800094a:	42a6      	cmp	r6, r4
 800094c:	d102      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
 800094e:	681e      	ldr	r6, [r3, #0]
 8000950:	42ae      	cmp	r6, r5
 8000952:	d00f      	beq.n	8000974 <gsl_blas_sgemv+0x3c>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000954:	4912      	ldr	r1, [pc, #72]	; (80009a0 <gsl_blas_sgemv+0x68>)
 8000956:	4813      	ldr	r0, [pc, #76]	; (80009a4 <gsl_blas_sgemv+0x6c>)
 8000958:	2313      	movs	r3, #19
 800095a:	f240 2266 	movw	r2, #614	; 0x266
 800095e:	f001 ff7f 	bl	8002860 <gsl_error>
 8000962:	2013      	movs	r0, #19
    }
}
 8000964:	b007      	add	sp, #28
 8000966:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000968:	6816      	ldr	r6, [r2, #0]
 800096a:	42ae      	cmp	r6, r5
 800096c:	d1f2      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
 800096e:	681e      	ldr	r6, [r3, #0]
 8000970:	42a6      	cmp	r6, r4
 8000972:	d1ef      	bne.n	8000954 <gsl_blas_sgemv+0x1c>
      cblas_sgemv (CblasRowMajor, TransA, INT (M), INT (N), alpha, A->data,
 8000974:	e9d3 6301 	ldrd	r6, r3, [r3, #4]
 8000978:	e9d2 ec01 	ldrd	lr, ip, [r2, #4]
 800097c:	9605      	str	r6, [sp, #20]
 800097e:	e9d1 7602 	ldrd	r7, r6, [r1, #8]
 8000982:	4622      	mov	r2, r4
 8000984:	9304      	str	r3, [sp, #16]
 8000986:	4601      	mov	r1, r0
 8000988:	e9cd ce02 	strd	ip, lr, [sp, #8]
 800098c:	e9cd 6700 	strd	r6, r7, [sp]
 8000990:	462b      	mov	r3, r5
 8000992:	2065      	movs	r0, #101	; 0x65
 8000994:	f007 f8d2 	bl	8007b3c <cblas_sgemv>
      return GSL_SUCCESS;
 8000998:	2000      	movs	r0, #0
}
 800099a:	b007      	add	sp, #28
 800099c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800099e:	bf00      	nop
 80009a0:	08030180 	.word	0x08030180
 80009a4:	08030188 	.word	0x08030188

080009a8 <gsl_blas_dgemv>:


int
gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransA, double alpha, const gsl_matrix * A,
                const gsl_vector * X, double beta, gsl_vector * Y)
{
 80009a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 80009aa:	286f      	cmp	r0, #111	; 0x6f
  const size_t N = A->size2;
 80009ac:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 80009b0:	b087      	sub	sp, #28
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 80009b2:	d011      	beq.n	80009d8 <gsl_blas_dgemv+0x30>
      || (TransA == CblasTrans && M == X->size && N == Y->size))
 80009b4:	2870      	cmp	r0, #112	; 0x70
 80009b6:	d105      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
 80009b8:	6816      	ldr	r6, [r2, #0]
 80009ba:	42a6      	cmp	r6, r4
 80009bc:	d102      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
 80009be:	681e      	ldr	r6, [r3, #0]
 80009c0:	42ae      	cmp	r6, r5
 80009c2:	d00f      	beq.n	80009e4 <gsl_blas_dgemv+0x3c>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80009c4:	4912      	ldr	r1, [pc, #72]	; (8000a10 <gsl_blas_dgemv+0x68>)
 80009c6:	4813      	ldr	r0, [pc, #76]	; (8000a14 <gsl_blas_dgemv+0x6c>)
 80009c8:	2313      	movs	r3, #19
 80009ca:	f44f 721f 	mov.w	r2, #636	; 0x27c
 80009ce:	f001 ff47 	bl	8002860 <gsl_error>
 80009d2:	2013      	movs	r0, #19
    }
}
 80009d4:	b007      	add	sp, #28
 80009d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 80009d8:	6816      	ldr	r6, [r2, #0]
 80009da:	42ae      	cmp	r6, r5
 80009dc:	d1f2      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
 80009de:	681e      	ldr	r6, [r3, #0]
 80009e0:	42a6      	cmp	r6, r4
 80009e2:	d1ef      	bne.n	80009c4 <gsl_blas_dgemv+0x1c>
      cblas_dgemv (CblasRowMajor, TransA, INT (M), INT (N), alpha, A->data,
 80009e4:	e9d3 6301 	ldrd	r6, r3, [r3, #4]
 80009e8:	e9d2 ec01 	ldrd	lr, ip, [r2, #4]
 80009ec:	9605      	str	r6, [sp, #20]
 80009ee:	e9d1 7602 	ldrd	r7, r6, [r1, #8]
 80009f2:	4622      	mov	r2, r4
 80009f4:	9304      	str	r3, [sp, #16]
 80009f6:	4601      	mov	r1, r0
 80009f8:	e9cd ce02 	strd	ip, lr, [sp, #8]
 80009fc:	e9cd 6700 	strd	r6, r7, [sp]
 8000a00:	462b      	mov	r3, r5
 8000a02:	2065      	movs	r0, #101	; 0x65
 8000a04:	f00b fb68 	bl	800c0d8 <cblas_dgemv>
      return GSL_SUCCESS;
 8000a08:	2000      	movs	r0, #0
}
 8000a0a:	b007      	add	sp, #28
 8000a0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000a0e:	bf00      	nop
 8000a10:	08030180 	.word	0x08030180
 8000a14:	08030188 	.word	0x08030188

08000a18 <gsl_blas_cgemv>:
int
gsl_blas_cgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_vector_complex_float * X,
                const gsl_complex_float beta, gsl_vector_complex_float * Y)
{
 8000a18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000a1c:	286f      	cmp	r0, #111	; 0x6f
{
 8000a1e:	b08c      	sub	sp, #48	; 0x30
  const size_t N = A->size2;
 8000a20:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 8000a24:	460e      	mov	r6, r1
 8000a26:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
 8000a2a:	edcd 0a0b 	vstr	s1, [sp, #44]	; 0x2c
 8000a2e:	ed8d 1a08 	vstr	s2, [sp, #32]
 8000a32:	edcd 1a09 	vstr	s3, [sp, #36]	; 0x24
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000a36:	d015      	beq.n	8000a64 <gsl_blas_cgemv+0x4c>
      || (TransA == CblasTrans && M == X->size && N == Y->size)
 8000a38:	2870      	cmp	r0, #112	; 0x70
 8000a3a:	d110      	bne.n	8000a5e <gsl_blas_cgemv+0x46>
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000a3c:	6811      	ldr	r1, [r2, #0]
 8000a3e:	42a1      	cmp	r1, r4
 8000a40:	d102      	bne.n	8000a48 <gsl_blas_cgemv+0x30>
 8000a42:	6819      	ldr	r1, [r3, #0]
 8000a44:	42a9      	cmp	r1, r5
 8000a46:	d013      	beq.n	8000a70 <gsl_blas_cgemv+0x58>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000a48:	4918      	ldr	r1, [pc, #96]	; (8000aac <gsl_blas_cgemv+0x94>)
 8000a4a:	4819      	ldr	r0, [pc, #100]	; (8000ab0 <gsl_blas_cgemv+0x98>)
 8000a4c:	2313      	movs	r3, #19
 8000a4e:	f240 2296 	movw	r2, #662	; 0x296
 8000a52:	f001 ff05 	bl	8002860 <gsl_error>
 8000a56:	2013      	movs	r0, #19
    }
}
 8000a58:	b00c      	add	sp, #48	; 0x30
 8000a5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000a5e:	2871      	cmp	r0, #113	; 0x71
 8000a60:	d0ec      	beq.n	8000a3c <gsl_blas_cgemv+0x24>
 8000a62:	e7f1      	b.n	8000a48 <gsl_blas_cgemv+0x30>
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000a64:	6811      	ldr	r1, [r2, #0]
 8000a66:	42a9      	cmp	r1, r5
 8000a68:	d1ee      	bne.n	8000a48 <gsl_blas_cgemv+0x30>
 8000a6a:	6819      	ldr	r1, [r3, #0]
 8000a6c:	42a1      	cmp	r1, r4
 8000a6e:	d1eb      	bne.n	8000a48 <gsl_blas_cgemv+0x30>
      cblas_cgemv (CblasRowMajor, TransA, INT (M), INT (N),
 8000a70:	e9d3 1801 	ldrd	r1, r8, [r3, #4]
 8000a74:	e9d2 c701 	ldrd	ip, r7, [r2, #4]
 8000a78:	9107      	str	r1, [sp, #28]
 8000a7a:	f8cd 8018 	str.w	r8, [sp, #24]
 8000a7e:	462b      	mov	r3, r5
 8000a80:	4622      	mov	r2, r4
 8000a82:	e9d6 5402 	ldrd	r5, r4, [r6, #8]
 8000a86:	f10d 0e20 	add.w	lr, sp, #32
 8000a8a:	4601      	mov	r1, r0
 8000a8c:	a80a      	add	r0, sp, #40	; 0x28
 8000a8e:	9000      	str	r0, [sp, #0]
 8000a90:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 8000a94:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8000a98:	f8cd e014 	str.w	lr, [sp, #20]
 8000a9c:	2065      	movs	r0, #101	; 0x65
 8000a9e:	f011 fc95 	bl	80123cc <cblas_cgemv>
      return GSL_SUCCESS;
 8000aa2:	2000      	movs	r0, #0
}
 8000aa4:	b00c      	add	sp, #48	; 0x30
 8000aa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000aaa:	bf00      	nop
 8000aac:	08030180 	.word	0x08030180
 8000ab0:	08030188 	.word	0x08030188

08000ab4 <gsl_blas_zgemv>:

int
gsl_blas_zgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex alpha,
                const gsl_matrix_complex * A, const gsl_vector_complex * X,
                const gsl_complex beta, gsl_vector_complex * Y)
{
 8000ab4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000ab8:	286f      	cmp	r0, #111	; 0x6f
{
 8000aba:	b090      	sub	sp, #64	; 0x40
  const size_t N = A->size2;
 8000abc:	e9d1 4500 	ldrd	r4, r5, [r1]
{
 8000ac0:	ed8d 0b0c 	vstr	d0, [sp, #48]	; 0x30
 8000ac4:	ed8d 1b0e 	vstr	d1, [sp, #56]	; 0x38
 8000ac8:	ed8d 2b08 	vstr	d2, [sp, #32]
 8000acc:	ed8d 3b0a 	vstr	d3, [sp, #40]	; 0x28
 8000ad0:	460e      	mov	r6, r1
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000ad2:	d015      	beq.n	8000b00 <gsl_blas_zgemv+0x4c>
      || (TransA == CblasTrans && M == X->size && N == Y->size)
 8000ad4:	2870      	cmp	r0, #112	; 0x70
 8000ad6:	d110      	bne.n	8000afa <gsl_blas_zgemv+0x46>
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000ad8:	6811      	ldr	r1, [r2, #0]
 8000ada:	42a1      	cmp	r1, r4
 8000adc:	d102      	bne.n	8000ae4 <gsl_blas_zgemv+0x30>
 8000ade:	6819      	ldr	r1, [r3, #0]
 8000ae0:	42a9      	cmp	r1, r5
 8000ae2:	d013      	beq.n	8000b0c <gsl_blas_zgemv+0x58>
                   INT (Y->stride));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000ae4:	4918      	ldr	r1, [pc, #96]	; (8000b48 <gsl_blas_zgemv+0x94>)
 8000ae6:	4819      	ldr	r0, [pc, #100]	; (8000b4c <gsl_blas_zgemv+0x98>)
 8000ae8:	2313      	movs	r3, #19
 8000aea:	f240 22af 	movw	r2, #687	; 0x2af
 8000aee:	f001 feb7 	bl	8002860 <gsl_error>
 8000af2:	2013      	movs	r0, #19
    }
}
 8000af4:	b010      	add	sp, #64	; 0x40
 8000af6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      || (TransA == CblasConjTrans && M == X->size && N == Y->size))
 8000afa:	2871      	cmp	r0, #113	; 0x71
 8000afc:	d0ec      	beq.n	8000ad8 <gsl_blas_zgemv+0x24>
 8000afe:	e7f1      	b.n	8000ae4 <gsl_blas_zgemv+0x30>
  if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
 8000b00:	6811      	ldr	r1, [r2, #0]
 8000b02:	42a9      	cmp	r1, r5
 8000b04:	d1ee      	bne.n	8000ae4 <gsl_blas_zgemv+0x30>
 8000b06:	6819      	ldr	r1, [r3, #0]
 8000b08:	42a1      	cmp	r1, r4
 8000b0a:	d1eb      	bne.n	8000ae4 <gsl_blas_zgemv+0x30>
      cblas_zgemv (CblasRowMajor, TransA, INT (M), INT (N),
 8000b0c:	e9d3 1801 	ldrd	r1, r8, [r3, #4]
 8000b10:	e9d2 c701 	ldrd	ip, r7, [r2, #4]
 8000b14:	9107      	str	r1, [sp, #28]
 8000b16:	f8cd 8018 	str.w	r8, [sp, #24]
 8000b1a:	462b      	mov	r3, r5
 8000b1c:	4622      	mov	r2, r4
 8000b1e:	e9d6 5402 	ldrd	r5, r4, [r6, #8]
 8000b22:	f10d 0e20 	add.w	lr, sp, #32
 8000b26:	4601      	mov	r1, r0
 8000b28:	a80c      	add	r0, sp, #48	; 0x30
 8000b2a:	9000      	str	r0, [sp, #0]
 8000b2c:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 8000b30:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8000b34:	f8cd e014 	str.w	lr, [sp, #20]
 8000b38:	2065      	movs	r0, #101	; 0x65
 8000b3a:	f019 fd15 	bl	801a568 <cblas_zgemv>
      return GSL_SUCCESS;
 8000b3e:	2000      	movs	r0, #0
}
 8000b40:	b010      	add	sp, #64	; 0x40
 8000b42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000b46:	bf00      	nop
 8000b48:	08030180 	.word	0x08030180
 8000b4c:	08030188 	.word	0x08030188

08000b50 <gsl_blas_chemv>:
int
gsl_blas_chemv (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_vector_complex_float * X,
                const gsl_complex_float beta, gsl_vector_complex_float * Y)
{
 8000b50:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000b52:	e9d1 6500 	ldrd	r6, r5, [r1]
{
 8000b56:	b08d      	sub	sp, #52	; 0x34
  if (M != N)
 8000b58:	42ae      	cmp	r6, r5
{
 8000b5a:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
 8000b5e:	edcd 0a0b 	vstr	s1, [sp, #44]	; 0x2c
 8000b62:	ed8d 1a08 	vstr	s2, [sp, #32]
 8000b66:	edcd 1a09 	vstr	s3, [sp, #36]	; 0x24
  if (M != N)
 8000b6a:	d127      	bne.n	8000bbc <gsl_blas_chemv+0x6c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000b6c:	6815      	ldr	r5, [r2, #0]
 8000b6e:	42b5      	cmp	r5, r6
 8000b70:	d103      	bne.n	8000b7a <gsl_blas_chemv+0x2a>
 8000b72:	460c      	mov	r4, r1
 8000b74:	6819      	ldr	r1, [r3, #0]
 8000b76:	42a9      	cmp	r1, r5
 8000b78:	d009      	beq.n	8000b8e <gsl_blas_chemv+0x3e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000b7a:	4915      	ldr	r1, [pc, #84]	; (8000bd0 <gsl_blas_chemv+0x80>)
 8000b7c:	4815      	ldr	r0, [pc, #84]	; (8000bd4 <gsl_blas_chemv+0x84>)
 8000b7e:	2313      	movs	r3, #19
 8000b80:	f240 22c6 	movw	r2, #710	; 0x2c6
 8000b84:	f001 fe6c 	bl	8002860 <gsl_error>
 8000b88:	2013      	movs	r0, #19

  cblas_chemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
               INT (A->tda), X->data, INT (X->stride), GSL_COMPLEX_P (&beta),
               Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000b8a:	b00d      	add	sp, #52	; 0x34
 8000b8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_chemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
 8000b8e:	e9d3 7301 	ldrd	r7, r3, [r3, #4]
 8000b92:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000b96:	9706      	str	r7, [sp, #24]
 8000b98:	9305      	str	r3, [sp, #20]
 8000b9a:	460a      	mov	r2, r1
 8000b9c:	4601      	mov	r1, r0
 8000b9e:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 8000ba2:	af08      	add	r7, sp, #32
 8000ba4:	e9cd 0501 	strd	r0, r5, [sp, #4]
 8000ba8:	9300      	str	r3, [sp, #0]
 8000baa:	e9cd 6703 	strd	r6, r7, [sp, #12]
 8000bae:	ab0a      	add	r3, sp, #40	; 0x28
 8000bb0:	2065      	movs	r0, #101	; 0x65
 8000bb2:	f012 fddf 	bl	8013774 <cblas_chemv>
  return GSL_SUCCESS;
 8000bb6:	2000      	movs	r0, #0
}
 8000bb8:	b00d      	add	sp, #52	; 0x34
 8000bba:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000bbc:	4904      	ldr	r1, [pc, #16]	; (8000bd0 <gsl_blas_chemv+0x80>)
 8000bbe:	4806      	ldr	r0, [pc, #24]	; (8000bd8 <gsl_blas_chemv+0x88>)
 8000bc0:	2314      	movs	r3, #20
 8000bc2:	f240 22c2 	movw	r2, #706	; 0x2c2
 8000bc6:	f001 fe4b 	bl	8002860 <gsl_error>
 8000bca:	2014      	movs	r0, #20
}
 8000bcc:	b00d      	add	sp, #52	; 0x34
 8000bce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000bd0:	08030180 	.word	0x08030180
 8000bd4:	08030188 	.word	0x08030188
 8000bd8:	08030198 	.word	0x08030198

08000bdc <gsl_blas_zhemv>:

int
gsl_blas_zhemv (CBLAS_UPLO_t Uplo, const gsl_complex alpha,
                const gsl_matrix_complex * A, const gsl_vector_complex * X,
                const gsl_complex beta, gsl_vector_complex * Y)
{
 8000bdc:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000bde:	e9d1 6500 	ldrd	r6, r5, [r1]
{
 8000be2:	b091      	sub	sp, #68	; 0x44
  if (M != N)
 8000be4:	42ae      	cmp	r6, r5
{
 8000be6:	ed8d 0b0c 	vstr	d0, [sp, #48]	; 0x30
 8000bea:	ed8d 1b0e 	vstr	d1, [sp, #56]	; 0x38
 8000bee:	ed8d 2b08 	vstr	d2, [sp, #32]
 8000bf2:	ed8d 3b0a 	vstr	d3, [sp, #40]	; 0x28
  if (M != N)
 8000bf6:	d127      	bne.n	8000c48 <gsl_blas_zhemv+0x6c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000bf8:	6815      	ldr	r5, [r2, #0]
 8000bfa:	42b5      	cmp	r5, r6
 8000bfc:	d103      	bne.n	8000c06 <gsl_blas_zhemv+0x2a>
 8000bfe:	460c      	mov	r4, r1
 8000c00:	6819      	ldr	r1, [r3, #0]
 8000c02:	42a9      	cmp	r1, r5
 8000c04:	d009      	beq.n	8000c1a <gsl_blas_zhemv+0x3e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000c06:	4915      	ldr	r1, [pc, #84]	; (8000c5c <gsl_blas_zhemv+0x80>)
 8000c08:	4815      	ldr	r0, [pc, #84]	; (8000c60 <gsl_blas_zhemv+0x84>)
 8000c0a:	2313      	movs	r3, #19
 8000c0c:	f240 22dd 	movw	r2, #733	; 0x2dd
 8000c10:	f001 fe26 	bl	8002860 <gsl_error>
 8000c14:	2013      	movs	r0, #19

  cblas_zhemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
               INT (A->tda), X->data, INT (X->stride), GSL_COMPLEX_P (&beta),
               Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000c16:	b011      	add	sp, #68	; 0x44
 8000c18:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_zhemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
 8000c1a:	e9d3 7301 	ldrd	r7, r3, [r3, #4]
 8000c1e:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000c22:	9706      	str	r7, [sp, #24]
 8000c24:	9305      	str	r3, [sp, #20]
 8000c26:	460a      	mov	r2, r1
 8000c28:	4601      	mov	r1, r0
 8000c2a:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 8000c2e:	af08      	add	r7, sp, #32
 8000c30:	e9cd 0501 	strd	r0, r5, [sp, #4]
 8000c34:	9300      	str	r3, [sp, #0]
 8000c36:	e9cd 6703 	strd	r6, r7, [sp, #12]
 8000c3a:	ab0c      	add	r3, sp, #48	; 0x30
 8000c3c:	2065      	movs	r0, #101	; 0x65
 8000c3e:	f01b fed3 	bl	801c9e8 <cblas_zhemv>
  return GSL_SUCCESS;
 8000c42:	2000      	movs	r0, #0
}
 8000c44:	b011      	add	sp, #68	; 0x44
 8000c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000c48:	4904      	ldr	r1, [pc, #16]	; (8000c5c <gsl_blas_zhemv+0x80>)
 8000c4a:	4806      	ldr	r0, [pc, #24]	; (8000c64 <gsl_blas_zhemv+0x88>)
 8000c4c:	2314      	movs	r3, #20
 8000c4e:	f240 22d9 	movw	r2, #729	; 0x2d9
 8000c52:	f001 fe05 	bl	8002860 <gsl_error>
 8000c56:	2014      	movs	r0, #20
}
 8000c58:	b011      	add	sp, #68	; 0x44
 8000c5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c5c:	08030180 	.word	0x08030180
 8000c60:	08030188 	.word	0x08030188
 8000c64:	08030198 	.word	0x08030198

08000c68 <gsl_blas_ssymv>:
/* SYMV */

int
gsl_blas_ssymv (CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A,
                const gsl_vector_float * X, float beta, gsl_vector_float * Y)
{
 8000c68:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000c6a:	e9d1 6500 	ldrd	r6, r5, [r1]
 8000c6e:	42ae      	cmp	r6, r5
{
 8000c70:	b087      	sub	sp, #28
  if (M != N)
 8000c72:	d124      	bne.n	8000cbe <gsl_blas_ssymv+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000c74:	6815      	ldr	r5, [r2, #0]
 8000c76:	42b5      	cmp	r5, r6
 8000c78:	d103      	bne.n	8000c82 <gsl_blas_ssymv+0x1a>
 8000c7a:	460c      	mov	r4, r1
 8000c7c:	6819      	ldr	r1, [r3, #0]
 8000c7e:	42a9      	cmp	r1, r5
 8000c80:	d009      	beq.n	8000c96 <gsl_blas_ssymv+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000c82:	4914      	ldr	r1, [pc, #80]	; (8000cd4 <gsl_blas_ssymv+0x6c>)
 8000c84:	4814      	ldr	r0, [pc, #80]	; (8000cd8 <gsl_blas_ssymv+0x70>)
 8000c86:	2313      	movs	r3, #19
 8000c88:	f240 22f6 	movw	r2, #758	; 0x2f6
 8000c8c:	f001 fde8 	bl	8002860 <gsl_error>
 8000c90:	2013      	movs	r0, #19
    }

  cblas_ssymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
               X->data, INT (X->stride), beta, Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000c92:	b007      	add	sp, #28
 8000c94:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_ssymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
 8000c96:	e9d3 c701 	ldrd	ip, r7, [r3, #4]
 8000c9a:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000c9e:	f8cd c010 	str.w	ip, [sp, #16]
 8000ca2:	68a3      	ldr	r3, [r4, #8]
 8000ca4:	9300      	str	r3, [sp, #0]
 8000ca6:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8000caa:	9703      	str	r7, [sp, #12]
 8000cac:	460a      	mov	r2, r1
 8000cae:	68e3      	ldr	r3, [r4, #12]
 8000cb0:	4601      	mov	r1, r0
 8000cb2:	2065      	movs	r0, #101	; 0x65
 8000cb4:	f007 ffae 	bl	8008c14 <cblas_ssymv>
  return GSL_SUCCESS;
 8000cb8:	2000      	movs	r0, #0
}
 8000cba:	b007      	add	sp, #28
 8000cbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000cbe:	4905      	ldr	r1, [pc, #20]	; (8000cd4 <gsl_blas_ssymv+0x6c>)
 8000cc0:	4806      	ldr	r0, [pc, #24]	; (8000cdc <gsl_blas_ssymv+0x74>)
 8000cc2:	2314      	movs	r3, #20
 8000cc4:	f240 22f2 	movw	r2, #754	; 0x2f2
 8000cc8:	f001 fdca 	bl	8002860 <gsl_error>
 8000ccc:	2014      	movs	r0, #20
}
 8000cce:	b007      	add	sp, #28
 8000cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000cd2:	bf00      	nop
 8000cd4:	08030180 	.word	0x08030180
 8000cd8:	08030188 	.word	0x08030188
 8000cdc:	08030198 	.word	0x08030198

08000ce0 <gsl_blas_dsymv>:

int
gsl_blas_dsymv (CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A,
                const gsl_vector * X, double beta, gsl_vector * Y)
{
 8000ce0:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000ce2:	e9d1 6500 	ldrd	r6, r5, [r1]
 8000ce6:	42ae      	cmp	r6, r5
{
 8000ce8:	b087      	sub	sp, #28
  if (M != N)
 8000cea:	d124      	bne.n	8000d36 <gsl_blas_dsymv+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size || N != Y->size)
 8000cec:	6815      	ldr	r5, [r2, #0]
 8000cee:	42b5      	cmp	r5, r6
 8000cf0:	d103      	bne.n	8000cfa <gsl_blas_dsymv+0x1a>
 8000cf2:	460c      	mov	r4, r1
 8000cf4:	6819      	ldr	r1, [r3, #0]
 8000cf6:	42a9      	cmp	r1, r5
 8000cf8:	d009      	beq.n	8000d0e <gsl_blas_dsymv+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000cfa:	4914      	ldr	r1, [pc, #80]	; (8000d4c <gsl_blas_dsymv+0x6c>)
 8000cfc:	4814      	ldr	r0, [pc, #80]	; (8000d50 <gsl_blas_dsymv+0x70>)
 8000cfe:	2313      	movs	r3, #19
 8000d00:	f240 320b 	movw	r2, #779	; 0x30b
 8000d04:	f001 fdac 	bl	8002860 <gsl_error>
 8000d08:	2013      	movs	r0, #19
    }

  cblas_dsymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
               X->data, INT (X->stride), beta, Y->data, INT (Y->stride));
  return GSL_SUCCESS;
}
 8000d0a:	b007      	add	sp, #28
 8000d0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_dsymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
 8000d0e:	e9d3 c701 	ldrd	ip, r7, [r3, #4]
 8000d12:	e9d2 6501 	ldrd	r6, r5, [r2, #4]
 8000d16:	f8cd c010 	str.w	ip, [sp, #16]
 8000d1a:	68a3      	ldr	r3, [r4, #8]
 8000d1c:	9300      	str	r3, [sp, #0]
 8000d1e:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8000d22:	9703      	str	r7, [sp, #12]
 8000d24:	460a      	mov	r2, r1
 8000d26:	68e3      	ldr	r3, [r4, #12]
 8000d28:	4601      	mov	r1, r0
 8000d2a:	2065      	movs	r0, #101	; 0x65
 8000d2c:	f00c ff4a 	bl	800dbc4 <cblas_dsymv>
  return GSL_SUCCESS;
 8000d30:	2000      	movs	r0, #0
}
 8000d32:	b007      	add	sp, #28
 8000d34:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000d36:	4905      	ldr	r1, [pc, #20]	; (8000d4c <gsl_blas_dsymv+0x6c>)
 8000d38:	4806      	ldr	r0, [pc, #24]	; (8000d54 <gsl_blas_dsymv+0x74>)
 8000d3a:	2314      	movs	r3, #20
 8000d3c:	f240 3207 	movw	r2, #775	; 0x307
 8000d40:	f001 fd8e 	bl	8002860 <gsl_error>
 8000d44:	2014      	movs	r0, #20
}
 8000d46:	b007      	add	sp, #28
 8000d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000d4a:	bf00      	nop
 8000d4c:	08030180 	.word	0x08030180
 8000d50:	08030188 	.word	0x08030188
 8000d54:	08030198 	.word	0x08030198

08000d58 <gsl_blas_strmv>:

int
gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
                gsl_vector_float * X)
{
 8000d58:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000d5a:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000d5e:	b087      	sub	sp, #28
  if (M != N)
 8000d60:	42a6      	cmp	r6, r4
{
 8000d62:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000d64:	d11e      	bne.n	8000da4 <gsl_blas_strmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000d66:	682c      	ldr	r4, [r5, #0]
 8000d68:	42b4      	cmp	r4, r6
 8000d6a:	d111      	bne.n	8000d90 <gsl_blas_strmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_strmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000d6c:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000d70:	9400      	str	r4, [sp, #0]
 8000d72:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000d76:	4613      	mov	r3, r2
 8000d78:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000d7c:	460a      	mov	r2, r1
 8000d7e:	9704      	str	r7, [sp, #16]
 8000d80:	4601      	mov	r1, r0
 8000d82:	9401      	str	r4, [sp, #4]
 8000d84:	2065      	movs	r0, #101	; 0x65
 8000d86:	f009 fc83 	bl	800a690 <cblas_strmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000d8a:	2000      	movs	r0, #0
}
 8000d8c:	b007      	add	sp, #28
 8000d8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000d90:	4909      	ldr	r1, [pc, #36]	; (8000db8 <gsl_blas_strmv+0x60>)
 8000d92:	480a      	ldr	r0, [pc, #40]	; (8000dbc <gsl_blas_strmv+0x64>)
 8000d94:	2313      	movs	r3, #19
 8000d96:	f44f 7249 	mov.w	r2, #804	; 0x324
 8000d9a:	f001 fd61 	bl	8002860 <gsl_error>
 8000d9e:	2013      	movs	r0, #19
}
 8000da0:	b007      	add	sp, #28
 8000da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000da4:	4904      	ldr	r1, [pc, #16]	; (8000db8 <gsl_blas_strmv+0x60>)
 8000da6:	4806      	ldr	r0, [pc, #24]	; (8000dc0 <gsl_blas_strmv+0x68>)
 8000da8:	2314      	movs	r3, #20
 8000daa:	f44f 7248 	mov.w	r2, #800	; 0x320
 8000dae:	f001 fd57 	bl	8002860 <gsl_error>
 8000db2:	2014      	movs	r0, #20
}
 8000db4:	b007      	add	sp, #28
 8000db6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000db8:	08030180 	.word	0x08030180
 8000dbc:	08030188 	.word	0x08030188
 8000dc0:	08030198 	.word	0x08030198

08000dc4 <gsl_blas_dtrmv>:


int
gsl_blas_dtrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
{
 8000dc4:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000dc6:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000dca:	b087      	sub	sp, #28
  if (M != N)
 8000dcc:	42a6      	cmp	r6, r4
{
 8000dce:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000dd0:	d11e      	bne.n	8000e10 <gsl_blas_dtrmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000dd2:	682c      	ldr	r4, [r5, #0]
 8000dd4:	42b4      	cmp	r4, r6
 8000dd6:	d111      	bne.n	8000dfc <gsl_blas_dtrmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dtrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000dd8:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000ddc:	9400      	str	r4, [sp, #0]
 8000dde:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000de2:	4613      	mov	r3, r2
 8000de4:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000de8:	460a      	mov	r2, r1
 8000dea:	9704      	str	r7, [sp, #16]
 8000dec:	4601      	mov	r1, r0
 8000dee:	9401      	str	r4, [sp, #4]
 8000df0:	2065      	movs	r0, #101	; 0x65
 8000df2:	f00f f91b 	bl	801002c <cblas_dtrmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000df6:	2000      	movs	r0, #0
}
 8000df8:	b007      	add	sp, #28
 8000dfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000dfc:	4909      	ldr	r1, [pc, #36]	; (8000e24 <gsl_blas_dtrmv+0x60>)
 8000dfe:	480a      	ldr	r0, [pc, #40]	; (8000e28 <gsl_blas_dtrmv+0x64>)
 8000e00:	2313      	movs	r3, #19
 8000e02:	f240 323a 	movw	r2, #826	; 0x33a
 8000e06:	f001 fd2b 	bl	8002860 <gsl_error>
 8000e0a:	2013      	movs	r0, #19
}
 8000e0c:	b007      	add	sp, #28
 8000e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000e10:	4904      	ldr	r1, [pc, #16]	; (8000e24 <gsl_blas_dtrmv+0x60>)
 8000e12:	4806      	ldr	r0, [pc, #24]	; (8000e2c <gsl_blas_dtrmv+0x68>)
 8000e14:	2314      	movs	r3, #20
 8000e16:	f240 3236 	movw	r2, #822	; 0x336
 8000e1a:	f001 fd21 	bl	8002860 <gsl_error>
 8000e1e:	2014      	movs	r0, #20
}
 8000e20:	b007      	add	sp, #28
 8000e22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e24:	08030180 	.word	0x08030180
 8000e28:	08030188 	.word	0x08030188
 8000e2c:	08030198 	.word	0x08030198

08000e30 <gsl_blas_ctrmv>:

int
gsl_blas_ctrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A,
                gsl_vector_complex_float * X)
{
 8000e30:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000e32:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000e36:	b087      	sub	sp, #28
  if (M != N)
 8000e38:	42a6      	cmp	r6, r4
{
 8000e3a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000e3c:	d11e      	bne.n	8000e7c <gsl_blas_ctrmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000e3e:	682c      	ldr	r4, [r5, #0]
 8000e40:	42b4      	cmp	r4, r6
 8000e42:	d111      	bne.n	8000e68 <gsl_blas_ctrmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ctrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000e44:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000e48:	9400      	str	r4, [sp, #0]
 8000e4a:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000e4e:	4613      	mov	r3, r2
 8000e50:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000e54:	460a      	mov	r2, r1
 8000e56:	9704      	str	r7, [sp, #16]
 8000e58:	4601      	mov	r1, r0
 8000e5a:	9401      	str	r4, [sp, #4]
 8000e5c:	2065      	movs	r0, #101	; 0x65
 8000e5e:	f016 fba1 	bl	80175a4 <cblas_ctrmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000e62:	2000      	movs	r0, #0
}
 8000e64:	b007      	add	sp, #28
 8000e66:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000e68:	4909      	ldr	r1, [pc, #36]	; (8000e90 <gsl_blas_ctrmv+0x60>)
 8000e6a:	480a      	ldr	r0, [pc, #40]	; (8000e94 <gsl_blas_ctrmv+0x64>)
 8000e6c:	2313      	movs	r3, #19
 8000e6e:	f240 3251 	movw	r2, #849	; 0x351
 8000e72:	f001 fcf5 	bl	8002860 <gsl_error>
 8000e76:	2013      	movs	r0, #19
}
 8000e78:	b007      	add	sp, #28
 8000e7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000e7c:	4904      	ldr	r1, [pc, #16]	; (8000e90 <gsl_blas_ctrmv+0x60>)
 8000e7e:	4806      	ldr	r0, [pc, #24]	; (8000e98 <gsl_blas_ctrmv+0x68>)
 8000e80:	2314      	movs	r3, #20
 8000e82:	f240 324d 	movw	r2, #845	; 0x34d
 8000e86:	f001 fceb 	bl	8002860 <gsl_error>
 8000e8a:	2014      	movs	r0, #20
}
 8000e8c:	b007      	add	sp, #28
 8000e8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000e90:	08030180 	.word	0x08030180
 8000e94:	08030188 	.word	0x08030188
 8000e98:	08030198 	.word	0x08030198

08000e9c <gsl_blas_ztrmv>:

int
gsl_blas_ztrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex * A,
                gsl_vector_complex * X)
{
 8000e9c:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000e9e:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000ea2:	b087      	sub	sp, #28
  if (M != N)
 8000ea4:	42a6      	cmp	r6, r4
{
 8000ea6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000ea8:	d11e      	bne.n	8000ee8 <gsl_blas_ztrmv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000eaa:	682c      	ldr	r4, [r5, #0]
 8000eac:	42b4      	cmp	r4, r6
 8000eae:	d111      	bne.n	8000ed4 <gsl_blas_ztrmv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ztrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000eb0:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000eb4:	9400      	str	r4, [sp, #0]
 8000eb6:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000eba:	4613      	mov	r3, r2
 8000ebc:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000ec0:	460a      	mov	r2, r1
 8000ec2:	9704      	str	r7, [sp, #16]
 8000ec4:	4601      	mov	r1, r0
 8000ec6:	9401      	str	r4, [sp, #4]
 8000ec8:	2065      	movs	r0, #101	; 0x65
 8000eca:	f023 fa55 	bl	8024378 <cblas_ztrmv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000ece:	2000      	movs	r0, #0
}
 8000ed0:	b007      	add	sp, #28
 8000ed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000ed4:	4909      	ldr	r1, [pc, #36]	; (8000efc <gsl_blas_ztrmv+0x60>)
 8000ed6:	480a      	ldr	r0, [pc, #40]	; (8000f00 <gsl_blas_ztrmv+0x64>)
 8000ed8:	2313      	movs	r3, #19
 8000eda:	f44f 725a 	mov.w	r2, #872	; 0x368
 8000ede:	f001 fcbf 	bl	8002860 <gsl_error>
 8000ee2:	2013      	movs	r0, #19
}
 8000ee4:	b007      	add	sp, #28
 8000ee6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000ee8:	4904      	ldr	r1, [pc, #16]	; (8000efc <gsl_blas_ztrmv+0x60>)
 8000eea:	4806      	ldr	r0, [pc, #24]	; (8000f04 <gsl_blas_ztrmv+0x68>)
 8000eec:	2314      	movs	r3, #20
 8000eee:	f44f 7259 	mov.w	r2, #868	; 0x364
 8000ef2:	f001 fcb5 	bl	8002860 <gsl_error>
 8000ef6:	2014      	movs	r0, #20
}
 8000ef8:	b007      	add	sp, #28
 8000efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000efc:	08030180 	.word	0x08030180
 8000f00:	08030188 	.word	0x08030188
 8000f04:	08030198 	.word	0x08030198

08000f08 <gsl_blas_strsv>:

int
gsl_blas_strsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
                gsl_vector_float * X)
{
 8000f08:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000f0a:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000f0e:	b087      	sub	sp, #28
  if (M != N)
 8000f10:	42a6      	cmp	r6, r4
{
 8000f12:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000f14:	d11e      	bne.n	8000f54 <gsl_blas_strsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000f16:	682c      	ldr	r4, [r5, #0]
 8000f18:	42b4      	cmp	r4, r6
 8000f1a:	d111      	bne.n	8000f40 <gsl_blas_strsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_strsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000f1c:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000f20:	9400      	str	r4, [sp, #0]
 8000f22:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000f26:	4613      	mov	r3, r2
 8000f28:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000f2c:	460a      	mov	r2, r1
 8000f2e:	9704      	str	r7, [sp, #16]
 8000f30:	4601      	mov	r1, r0
 8000f32:	9401      	str	r4, [sp, #4]
 8000f34:	2065      	movs	r0, #101	; 0x65
 8000f36:	f00a fa47 	bl	800b3c8 <cblas_strsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000f3a:	2000      	movs	r0, #0
}
 8000f3c:	b007      	add	sp, #28
 8000f3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000f40:	4909      	ldr	r1, [pc, #36]	; (8000f68 <gsl_blas_strsv+0x60>)
 8000f42:	480a      	ldr	r0, [pc, #40]	; (8000f6c <gsl_blas_strsv+0x64>)
 8000f44:	2313      	movs	r3, #19
 8000f46:	f240 3281 	movw	r2, #897	; 0x381
 8000f4a:	f001 fc89 	bl	8002860 <gsl_error>
 8000f4e:	2013      	movs	r0, #19
}
 8000f50:	b007      	add	sp, #28
 8000f52:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000f54:	4904      	ldr	r1, [pc, #16]	; (8000f68 <gsl_blas_strsv+0x60>)
 8000f56:	4806      	ldr	r0, [pc, #24]	; (8000f70 <gsl_blas_strsv+0x68>)
 8000f58:	2314      	movs	r3, #20
 8000f5a:	f240 327d 	movw	r2, #893	; 0x37d
 8000f5e:	f001 fc7f 	bl	8002860 <gsl_error>
 8000f62:	2014      	movs	r0, #20
}
 8000f64:	b007      	add	sp, #28
 8000f66:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000f68:	08030180 	.word	0x08030180
 8000f6c:	08030188 	.word	0x08030188
 8000f70:	08030198 	.word	0x08030198

08000f74 <gsl_blas_dtrsv>:


int
gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
{
 8000f74:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000f76:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000f7a:	b087      	sub	sp, #28
  if (M != N)
 8000f7c:	42a6      	cmp	r6, r4
{
 8000f7e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000f80:	d11e      	bne.n	8000fc0 <gsl_blas_dtrsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000f82:	682c      	ldr	r4, [r5, #0]
 8000f84:	42b4      	cmp	r4, r6
 8000f86:	d111      	bne.n	8000fac <gsl_blas_dtrsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dtrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000f88:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000f8c:	9400      	str	r4, [sp, #0]
 8000f8e:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000f92:	4613      	mov	r3, r2
 8000f94:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8000f98:	460a      	mov	r2, r1
 8000f9a:	9704      	str	r7, [sp, #16]
 8000f9c:	4601      	mov	r1, r0
 8000f9e:	9401      	str	r4, [sp, #4]
 8000fa0:	2065      	movs	r0, #101	; 0x65
 8000fa2:	f010 f917 	bl	80111d4 <cblas_dtrsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8000fa6:	2000      	movs	r0, #0
}
 8000fa8:	b007      	add	sp, #28
 8000faa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8000fac:	4909      	ldr	r1, [pc, #36]	; (8000fd4 <gsl_blas_dtrsv+0x60>)
 8000fae:	480a      	ldr	r0, [pc, #40]	; (8000fd8 <gsl_blas_dtrsv+0x64>)
 8000fb0:	2313      	movs	r3, #19
 8000fb2:	f240 3297 	movw	r2, #919	; 0x397
 8000fb6:	f001 fc53 	bl	8002860 <gsl_error>
 8000fba:	2013      	movs	r0, #19
}
 8000fbc:	b007      	add	sp, #28
 8000fbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8000fc0:	4904      	ldr	r1, [pc, #16]	; (8000fd4 <gsl_blas_dtrsv+0x60>)
 8000fc2:	4806      	ldr	r0, [pc, #24]	; (8000fdc <gsl_blas_dtrsv+0x68>)
 8000fc4:	2314      	movs	r3, #20
 8000fc6:	f240 3293 	movw	r2, #915	; 0x393
 8000fca:	f001 fc49 	bl	8002860 <gsl_error>
 8000fce:	2014      	movs	r0, #20
}
 8000fd0:	b007      	add	sp, #28
 8000fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000fd4:	08030180 	.word	0x08030180
 8000fd8:	08030188 	.word	0x08030188
 8000fdc:	08030198 	.word	0x08030198

08000fe0 <gsl_blas_ctrsv>:

int
gsl_blas_ctrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A,
                gsl_vector_complex_float * X)
{
 8000fe0:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8000fe2:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8000fe6:	b087      	sub	sp, #28
  if (M != N)
 8000fe8:	42a6      	cmp	r6, r4
{
 8000fea:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8000fec:	d11e      	bne.n	800102c <gsl_blas_ctrsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 8000fee:	682c      	ldr	r4, [r5, #0]
 8000ff0:	42b4      	cmp	r4, r6
 8000ff2:	d111      	bne.n	8001018 <gsl_blas_ctrsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ctrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8000ff4:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8000ff8:	9400      	str	r4, [sp, #0]
 8000ffa:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 8000ffe:	4613      	mov	r3, r2
 8001000:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8001004:	460a      	mov	r2, r1
 8001006:	9704      	str	r7, [sp, #16]
 8001008:	4601      	mov	r1, r0
 800100a:	9401      	str	r4, [sp, #4]
 800100c:	2065      	movs	r0, #101	; 0x65
 800100e:	f017 fe2d 	bl	8018c6c <cblas_ctrsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 8001012:	2000      	movs	r0, #0
}
 8001014:	b007      	add	sp, #28
 8001016:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001018:	4909      	ldr	r1, [pc, #36]	; (8001040 <gsl_blas_ctrsv+0x60>)
 800101a:	480a      	ldr	r0, [pc, #40]	; (8001044 <gsl_blas_ctrsv+0x64>)
 800101c:	2313      	movs	r3, #19
 800101e:	f240 32ae 	movw	r2, #942	; 0x3ae
 8001022:	f001 fc1d 	bl	8002860 <gsl_error>
 8001026:	2013      	movs	r0, #19
}
 8001028:	b007      	add	sp, #28
 800102a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 800102c:	4904      	ldr	r1, [pc, #16]	; (8001040 <gsl_blas_ctrsv+0x60>)
 800102e:	4806      	ldr	r0, [pc, #24]	; (8001048 <gsl_blas_ctrsv+0x68>)
 8001030:	2314      	movs	r3, #20
 8001032:	f240 32aa 	movw	r2, #938	; 0x3aa
 8001036:	f001 fc13 	bl	8002860 <gsl_error>
 800103a:	2014      	movs	r0, #20
}
 800103c:	b007      	add	sp, #28
 800103e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001040:	08030180 	.word	0x08030180
 8001044:	08030188 	.word	0x08030188
 8001048:	08030198 	.word	0x08030198

0800104c <gsl_blas_ztrsv>:

int
gsl_blas_ztrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
                CBLAS_DIAG_t Diag, const gsl_matrix_complex * A,
                gsl_vector_complex * X)
{
 800104c:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 800104e:	e9d3 6400 	ldrd	r6, r4, [r3]
{
 8001052:	b087      	sub	sp, #28
  if (M != N)
 8001054:	42a6      	cmp	r6, r4
{
 8001056:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  if (M != N)
 8001058:	d11e      	bne.n	8001098 <gsl_blas_ztrsv+0x4c>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (N != X->size)
 800105a:	682c      	ldr	r4, [r5, #0]
 800105c:	42b4      	cmp	r4, r6
 800105e:	d111      	bne.n	8001084 <gsl_blas_ztrsv+0x38>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ztrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
 8001060:	e9d5 7601 	ldrd	r7, r6, [r5, #4]
 8001064:	9400      	str	r4, [sp, #0]
 8001066:	e9d3 5402 	ldrd	r5, r4, [r3, #8]
 800106a:	4613      	mov	r3, r2
 800106c:	e9cd 5602 	strd	r5, r6, [sp, #8]
 8001070:	460a      	mov	r2, r1
 8001072:	9704      	str	r7, [sp, #16]
 8001074:	4601      	mov	r1, r0
 8001076:	9401      	str	r4, [sp, #4]
 8001078:	2065      	movs	r0, #101	; 0x65
 800107a:	f025 fd0b 	bl	8026a94 <cblas_ztrsv>
               INT (A->tda), X->data, INT (X->stride));
  return GSL_SUCCESS;
 800107e:	2000      	movs	r0, #0
}
 8001080:	b007      	add	sp, #28
 8001082:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001084:	4909      	ldr	r1, [pc, #36]	; (80010ac <gsl_blas_ztrsv+0x60>)
 8001086:	480a      	ldr	r0, [pc, #40]	; (80010b0 <gsl_blas_ztrsv+0x64>)
 8001088:	2313      	movs	r3, #19
 800108a:	f240 32c5 	movw	r2, #965	; 0x3c5
 800108e:	f001 fbe7 	bl	8002860 <gsl_error>
 8001092:	2013      	movs	r0, #19
}
 8001094:	b007      	add	sp, #28
 8001096:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001098:	4904      	ldr	r1, [pc, #16]	; (80010ac <gsl_blas_ztrsv+0x60>)
 800109a:	4806      	ldr	r0, [pc, #24]	; (80010b4 <gsl_blas_ztrsv+0x68>)
 800109c:	2314      	movs	r3, #20
 800109e:	f240 32c1 	movw	r2, #961	; 0x3c1
 80010a2:	f001 fbdd 	bl	8002860 <gsl_error>
 80010a6:	2014      	movs	r0, #20
}
 80010a8:	b007      	add	sp, #28
 80010aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80010ac:	08030180 	.word	0x08030180
 80010b0:	08030188 	.word	0x08030188
 80010b4:	08030198 	.word	0x08030198

080010b8 <gsl_blas_sger>:
/* GER */

int
gsl_blas_sger (float alpha, const gsl_vector_float * X,
               const gsl_vector_float * Y, gsl_matrix_float * A)
{
 80010b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 80010ba:	6803      	ldr	r3, [r0, #0]
  const size_t M = A->size1;
 80010bc:	6814      	ldr	r4, [r2, #0]
  if (X->size == M && Y->size == N)
 80010be:	42a3      	cmp	r3, r4
{
 80010c0:	b087      	sub	sp, #28
  if (X->size == M && Y->size == N)
 80010c2:	d103      	bne.n	80010cc <gsl_blas_sger+0x14>
  const size_t N = A->size2;
 80010c4:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 80010c6:	680c      	ldr	r4, [r1, #0]
 80010c8:	42ac      	cmp	r4, r5
 80010ca:	d009      	beq.n	80010e0 <gsl_blas_sger+0x28>
                  INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80010cc:	490e      	ldr	r1, [pc, #56]	; (8001108 <gsl_blas_sger+0x50>)
 80010ce:	480f      	ldr	r0, [pc, #60]	; (800110c <gsl_blas_sger+0x54>)
 80010d0:	2313      	movs	r3, #19
 80010d2:	f44f 7278 	mov.w	r2, #992	; 0x3e0
 80010d6:	f001 fbc3 	bl	8002860 <gsl_error>
 80010da:	2013      	movs	r0, #19
    }
}
 80010dc:	b007      	add	sp, #28
 80010de:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_sger (CblasRowMajor, INT (M), INT (N), alpha, X->data,
 80010e0:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 80010e4:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 80010e8:	9504      	str	r5, [sp, #16]
 80010ea:	6845      	ldr	r5, [r0, #4]
 80010ec:	9500      	str	r5, [sp, #0]
 80010ee:	e9cd 6701 	strd	r6, r7, [sp, #4]
 80010f2:	9203      	str	r2, [sp, #12]
 80010f4:	4619      	mov	r1, r3
 80010f6:	4622      	mov	r2, r4
 80010f8:	6883      	ldr	r3, [r0, #8]
 80010fa:	2065      	movs	r0, #101	; 0x65
 80010fc:	f006 fe96 	bl	8007e2c <cblas_sger>
      return GSL_SUCCESS;
 8001100:	2000      	movs	r0, #0
}
 8001102:	b007      	add	sp, #28
 8001104:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001106:	bf00      	nop
 8001108:	08030180 	.word	0x08030180
 800110c:	08030188 	.word	0x08030188

08001110 <gsl_blas_dger>:


int
gsl_blas_dger (double alpha, const gsl_vector * X, const gsl_vector * Y,
               gsl_matrix * A)
{
 8001110:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 8001112:	6803      	ldr	r3, [r0, #0]
  const size_t M = A->size1;
 8001114:	6814      	ldr	r4, [r2, #0]
  if (X->size == M && Y->size == N)
 8001116:	42a3      	cmp	r3, r4
{
 8001118:	b087      	sub	sp, #28
  if (X->size == M && Y->size == N)
 800111a:	d103      	bne.n	8001124 <gsl_blas_dger+0x14>
  const size_t N = A->size2;
 800111c:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 800111e:	680c      	ldr	r4, [r1, #0]
 8001120:	42ac      	cmp	r4, r5
 8001122:	d009      	beq.n	8001138 <gsl_blas_dger+0x28>
                  INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001124:	490e      	ldr	r1, [pc, #56]	; (8001160 <gsl_blas_dger+0x50>)
 8001126:	480f      	ldr	r0, [pc, #60]	; (8001164 <gsl_blas_dger+0x54>)
 8001128:	2313      	movs	r3, #19
 800112a:	f240 32f5 	movw	r2, #1013	; 0x3f5
 800112e:	f001 fb97 	bl	8002860 <gsl_error>
 8001132:	2013      	movs	r0, #19
    }
}
 8001134:	b007      	add	sp, #28
 8001136:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_dger (CblasRowMajor, INT (M), INT (N), alpha, X->data,
 8001138:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 800113c:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 8001140:	9504      	str	r5, [sp, #16]
 8001142:	6845      	ldr	r5, [r0, #4]
 8001144:	9500      	str	r5, [sp, #0]
 8001146:	e9cd 6701 	strd	r6, r7, [sp, #4]
 800114a:	9203      	str	r2, [sp, #12]
 800114c:	4619      	mov	r1, r3
 800114e:	4622      	mov	r2, r4
 8001150:	6883      	ldr	r3, [r0, #8]
 8001152:	2065      	movs	r0, #101	; 0x65
 8001154:	f00b f990 	bl	800c478 <cblas_dger>
      return GSL_SUCCESS;
 8001158:	2000      	movs	r0, #0
}
 800115a:	b007      	add	sp, #28
 800115c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800115e:	bf00      	nop
 8001160:	08030180 	.word	0x08030180
 8001164:	08030188 	.word	0x08030188

08001168 <gsl_blas_cgeru>:
int
gsl_blas_cgeru (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
 8001168:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 800116a:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 800116c:	6804      	ldr	r4, [r0, #0]
{
 800116e:	b089      	sub	sp, #36	; 0x24
  if (X->size == M && Y->size == N)
 8001170:	429c      	cmp	r4, r3
{
 8001172:	ed8d 0a06 	vstr	s0, [sp, #24]
 8001176:	edcd 0a07 	vstr	s1, [sp, #28]
  if (X->size == M && Y->size == N)
 800117a:	d103      	bne.n	8001184 <gsl_blas_cgeru+0x1c>
  const size_t N = A->size2;
 800117c:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 800117e:	680b      	ldr	r3, [r1, #0]
 8001180:	42ab      	cmp	r3, r5
 8001182:	d009      	beq.n	8001198 <gsl_blas_cgeru+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001184:	490f      	ldr	r1, [pc, #60]	; (80011c4 <gsl_blas_cgeru+0x5c>)
 8001186:	4810      	ldr	r0, [pc, #64]	; (80011c8 <gsl_blas_cgeru+0x60>)
 8001188:	2313      	movs	r3, #19
 800118a:	f240 420e 	movw	r2, #1038	; 0x40e
 800118e:	f001 fb67 	bl	8002860 <gsl_error>
 8001192:	2013      	movs	r0, #19
    }
}
 8001194:	b009      	add	sp, #36	; 0x24
 8001196:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_cgeru (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 8001198:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 800119c:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 80011a0:	9505      	str	r5, [sp, #20]
 80011a2:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 80011a6:	4621      	mov	r1, r4
 80011a8:	e9cd 0500 	strd	r0, r5, [sp]
 80011ac:	9204      	str	r2, [sp, #16]
 80011ae:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80011b2:	461a      	mov	r2, r3
 80011b4:	2065      	movs	r0, #101	; 0x65
 80011b6:	ab06      	add	r3, sp, #24
 80011b8:	f011 fd14 	bl	8012be4 <cblas_cgeru>
      return GSL_SUCCESS;
 80011bc:	2000      	movs	r0, #0
}
 80011be:	b009      	add	sp, #36	; 0x24
 80011c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80011c2:	bf00      	nop
 80011c4:	08030180 	.word	0x08030180
 80011c8:	08030188 	.word	0x08030188

080011cc <gsl_blas_zgeru>:

int
gsl_blas_zgeru (const gsl_complex alpha, const gsl_vector_complex * X,
                const gsl_vector_complex * Y, gsl_matrix_complex * A)
{
 80011cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 80011ce:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 80011d0:	6804      	ldr	r4, [r0, #0]
{
 80011d2:	b08b      	sub	sp, #44	; 0x2c
  if (X->size == M && Y->size == N)
 80011d4:	429c      	cmp	r4, r3
{
 80011d6:	ed8d 0b06 	vstr	d0, [sp, #24]
 80011da:	ed8d 1b08 	vstr	d1, [sp, #32]
  if (X->size == M && Y->size == N)
 80011de:	d103      	bne.n	80011e8 <gsl_blas_zgeru+0x1c>
  const size_t N = A->size2;
 80011e0:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 80011e2:	680b      	ldr	r3, [r1, #0]
 80011e4:	42ab      	cmp	r3, r5
 80011e6:	d009      	beq.n	80011fc <gsl_blas_zgeru+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80011e8:	490f      	ldr	r1, [pc, #60]	; (8001228 <gsl_blas_zgeru+0x5c>)
 80011ea:	4810      	ldr	r0, [pc, #64]	; (800122c <gsl_blas_zgeru+0x60>)
 80011ec:	2313      	movs	r3, #19
 80011ee:	f240 4222 	movw	r2, #1058	; 0x422
 80011f2:	f001 fb35 	bl	8002860 <gsl_error>
 80011f6:	2013      	movs	r0, #19
    }
}
 80011f8:	b00b      	add	sp, #44	; 0x2c
 80011fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_zgeru (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 80011fc:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 8001200:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 8001204:	9505      	str	r5, [sp, #20]
 8001206:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 800120a:	4621      	mov	r1, r4
 800120c:	e9cd 0500 	strd	r0, r5, [sp]
 8001210:	9204      	str	r2, [sp, #16]
 8001212:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001216:	461a      	mov	r2, r3
 8001218:	2065      	movs	r0, #101	; 0x65
 800121a:	ab06      	add	r3, sp, #24
 800121c:	f01a f8f8 	bl	801b410 <cblas_zgeru>
      return GSL_SUCCESS;
 8001220:	2000      	movs	r0, #0
}
 8001222:	b00b      	add	sp, #44	; 0x2c
 8001224:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001226:	bf00      	nop
 8001228:	08030180 	.word	0x08030180
 800122c:	08030188 	.word	0x08030188

08001230 <gsl_blas_cgerc>:
int
gsl_blas_cgerc (const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
 8001230:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 8001232:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 8001234:	6804      	ldr	r4, [r0, #0]
{
 8001236:	b089      	sub	sp, #36	; 0x24
  if (X->size == M && Y->size == N)
 8001238:	429c      	cmp	r4, r3
{
 800123a:	ed8d 0a06 	vstr	s0, [sp, #24]
 800123e:	edcd 0a07 	vstr	s1, [sp, #28]
  if (X->size == M && Y->size == N)
 8001242:	d103      	bne.n	800124c <gsl_blas_cgerc+0x1c>
  const size_t N = A->size2;
 8001244:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 8001246:	680b      	ldr	r3, [r1, #0]
 8001248:	42ab      	cmp	r3, r5
 800124a:	d009      	beq.n	8001260 <gsl_blas_cgerc+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800124c:	490f      	ldr	r1, [pc, #60]	; (800128c <gsl_blas_cgerc+0x5c>)
 800124e:	4810      	ldr	r0, [pc, #64]	; (8001290 <gsl_blas_cgerc+0x60>)
 8001250:	2313      	movs	r3, #19
 8001252:	f240 423b 	movw	r2, #1083	; 0x43b
 8001256:	f001 fb03 	bl	8002860 <gsl_error>
 800125a:	2013      	movs	r0, #19
    }
}
 800125c:	b009      	add	sp, #36	; 0x24
 800125e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_cgerc (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 8001260:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 8001264:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 8001268:	9505      	str	r5, [sp, #20]
 800126a:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 800126e:	4621      	mov	r1, r4
 8001270:	e9cd 0500 	strd	r0, r5, [sp]
 8001274:	9204      	str	r2, [sp, #16]
 8001276:	e9cd 6702 	strd	r6, r7, [sp, #8]
 800127a:	461a      	mov	r2, r3
 800127c:	2065      	movs	r0, #101	; 0x65
 800127e:	ab06      	add	r3, sp, #24
 8001280:	f011 fb3c 	bl	80128fc <cblas_cgerc>
      return GSL_SUCCESS;
 8001284:	2000      	movs	r0, #0
}
 8001286:	b009      	add	sp, #36	; 0x24
 8001288:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800128a:	bf00      	nop
 800128c:	08030180 	.word	0x08030180
 8001290:	08030188 	.word	0x08030188

08001294 <gsl_blas_zgerc>:


int
gsl_blas_zgerc (const gsl_complex alpha, const gsl_vector_complex * X,
                const gsl_vector_complex * Y, gsl_matrix_complex * A)
{
 8001294:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
 8001296:	6813      	ldr	r3, [r2, #0]
  const size_t N = A->size2;

  if (X->size == M && Y->size == N)
 8001298:	6804      	ldr	r4, [r0, #0]
{
 800129a:	b08b      	sub	sp, #44	; 0x2c
  if (X->size == M && Y->size == N)
 800129c:	429c      	cmp	r4, r3
{
 800129e:	ed8d 0b06 	vstr	d0, [sp, #24]
 80012a2:	ed8d 1b08 	vstr	d1, [sp, #32]
  if (X->size == M && Y->size == N)
 80012a6:	d103      	bne.n	80012b0 <gsl_blas_zgerc+0x1c>
  const size_t N = A->size2;
 80012a8:	6855      	ldr	r5, [r2, #4]
  if (X->size == M && Y->size == N)
 80012aa:	680b      	ldr	r3, [r1, #0]
 80012ac:	42ab      	cmp	r3, r5
 80012ae:	d009      	beq.n	80012c4 <gsl_blas_zgerc+0x30>
                   A->data, INT (A->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80012b0:	490f      	ldr	r1, [pc, #60]	; (80012f0 <gsl_blas_zgerc+0x5c>)
 80012b2:	4810      	ldr	r0, [pc, #64]	; (80012f4 <gsl_blas_zgerc+0x60>)
 80012b4:	2313      	movs	r3, #19
 80012b6:	f44f 628a 	mov.w	r2, #1104	; 0x450
 80012ba:	f001 fad1 	bl	8002860 <gsl_error>
 80012be:	2013      	movs	r0, #19
    }
}
 80012c0:	b00b      	add	sp, #44	; 0x2c
 80012c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      cblas_zgerc (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
 80012c4:	e9d2 5202 	ldrd	r5, r2, [r2, #8]
 80012c8:	e9d1 7601 	ldrd	r7, r6, [r1, #4]
 80012cc:	9505      	str	r5, [sp, #20]
 80012ce:	e9d0 5001 	ldrd	r5, r0, [r0, #4]
 80012d2:	4621      	mov	r1, r4
 80012d4:	e9cd 0500 	strd	r0, r5, [sp]
 80012d8:	9204      	str	r2, [sp, #16]
 80012da:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80012de:	461a      	mov	r2, r3
 80012e0:	2065      	movs	r0, #101	; 0x65
 80012e2:	ab06      	add	r3, sp, #24
 80012e4:	f019 fe3c 	bl	801af60 <cblas_zgerc>
      return GSL_SUCCESS;
 80012e8:	2000      	movs	r0, #0
}
 80012ea:	b00b      	add	sp, #44	; 0x2c
 80012ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80012ee:	bf00      	nop
 80012f0:	08030180 	.word	0x08030180
 80012f4:	08030188 	.word	0x08030188

080012f8 <gsl_blas_cher>:

int
gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha,
               const gsl_vector_complex_float * X,
               gsl_matrix_complex_float * A)
{
 80012f8:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;
 80012fa:	e9d2 4500 	ldrd	r4, r5, [r2]

  if (M != N)
 80012fe:	42ac      	cmp	r4, r5
{
 8001300:	b084      	sub	sp, #16
  if (M != N)
 8001302:	d11c      	bne.n	800133e <gsl_blas_cher+0x46>
 8001304:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 8001306:	6809      	ldr	r1, [r1, #0]
 8001308:	42a1      	cmp	r1, r4
 800130a:	d10e      	bne.n	800132a <gsl_blas_cher+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_cher (CblasRowMajor, Uplo, INT (M), alpha, X->data, INT (X->stride),
 800130c:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 8001310:	685c      	ldr	r4, [r3, #4]
 8001312:	9602      	str	r6, [sp, #8]
 8001314:	e9cd 4500 	strd	r4, r5, [sp]
 8001318:	460a      	mov	r2, r1
 800131a:	689b      	ldr	r3, [r3, #8]
 800131c:	4601      	mov	r1, r0
 800131e:	2065      	movs	r0, #101	; 0x65
 8001320:	f012 fcec 	bl	8013cfc <cblas_cher>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 8001324:	2000      	movs	r0, #0
}
 8001326:	b004      	add	sp, #16
 8001328:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800132a:	490a      	ldr	r1, [pc, #40]	; (8001354 <gsl_blas_cher+0x5c>)
 800132c:	480a      	ldr	r0, [pc, #40]	; (8001358 <gsl_blas_cher+0x60>)
 800132e:	2313      	movs	r3, #19
 8001330:	f240 4264 	movw	r2, #1124	; 0x464
 8001334:	f001 fa94 	bl	8002860 <gsl_error>
 8001338:	2013      	movs	r0, #19
}
 800133a:	b004      	add	sp, #16
 800133c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 800133e:	4905      	ldr	r1, [pc, #20]	; (8001354 <gsl_blas_cher+0x5c>)
 8001340:	4806      	ldr	r0, [pc, #24]	; (800135c <gsl_blas_cher+0x64>)
 8001342:	2314      	movs	r3, #20
 8001344:	f44f 628c 	mov.w	r2, #1120	; 0x460
 8001348:	f001 fa8a 	bl	8002860 <gsl_error>
 800134c:	2014      	movs	r0, #20
}
 800134e:	b004      	add	sp, #16
 8001350:	bd70      	pop	{r4, r5, r6, pc}
 8001352:	bf00      	nop
 8001354:	08030180 	.word	0x08030180
 8001358:	08030188 	.word	0x08030188
 800135c:	08030198 	.word	0x08030198

08001360 <gsl_blas_zher>:


int
gsl_blas_zher (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector_complex * X,
               gsl_matrix_complex * A)
{
 8001360:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8001362:	e9d2 4500 	ldrd	r4, r5, [r2]
 8001366:	42ac      	cmp	r4, r5
{
 8001368:	b084      	sub	sp, #16
  if (M != N)
 800136a:	d11c      	bne.n	80013a6 <gsl_blas_zher+0x46>
 800136c:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 800136e:	6809      	ldr	r1, [r1, #0]
 8001370:	42a1      	cmp	r1, r4
 8001372:	d10e      	bne.n	8001392 <gsl_blas_zher+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_zher (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 8001374:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 8001378:	685c      	ldr	r4, [r3, #4]
 800137a:	9602      	str	r6, [sp, #8]
 800137c:	e9cd 4500 	strd	r4, r5, [sp]
 8001380:	460a      	mov	r2, r1
 8001382:	689b      	ldr	r3, [r3, #8]
 8001384:	4601      	mov	r1, r0
 8001386:	2065      	movs	r0, #101	; 0x65
 8001388:	f01c f866 	bl	801d458 <cblas_zher>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 800138c:	2000      	movs	r0, #0
}
 800138e:	b004      	add	sp, #16
 8001390:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001392:	490a      	ldr	r1, [pc, #40]	; (80013bc <gsl_blas_zher+0x5c>)
 8001394:	480a      	ldr	r0, [pc, #40]	; (80013c0 <gsl_blas_zher+0x60>)
 8001396:	2313      	movs	r3, #19
 8001398:	f240 427a 	movw	r2, #1146	; 0x47a
 800139c:	f001 fa60 	bl	8002860 <gsl_error>
 80013a0:	2013      	movs	r0, #19
}
 80013a2:	b004      	add	sp, #16
 80013a4:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 80013a6:	4905      	ldr	r1, [pc, #20]	; (80013bc <gsl_blas_zher+0x5c>)
 80013a8:	4806      	ldr	r0, [pc, #24]	; (80013c4 <gsl_blas_zher+0x64>)
 80013aa:	2314      	movs	r3, #20
 80013ac:	f240 4276 	movw	r2, #1142	; 0x476
 80013b0:	f001 fa56 	bl	8002860 <gsl_error>
 80013b4:	2014      	movs	r0, #20
}
 80013b6:	b004      	add	sp, #16
 80013b8:	bd70      	pop	{r4, r5, r6, pc}
 80013ba:	bf00      	nop
 80013bc:	08030180 	.word	0x08030180
 80013c0:	08030188 	.word	0x08030188
 80013c4:	08030198 	.word	0x08030198

080013c8 <gsl_blas_cher2>:
int
gsl_blas_cher2 (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha,
                const gsl_vector_complex_float * X,
                const gsl_vector_complex_float * Y,
                gsl_matrix_complex_float * A)
{
 80013c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 80013ca:	e9d3 5400 	ldrd	r5, r4, [r3]
{
 80013ce:	b089      	sub	sp, #36	; 0x24
  if (M != N)
 80013d0:	42a5      	cmp	r5, r4
{
 80013d2:	ed8d 0a06 	vstr	s0, [sp, #24]
 80013d6:	edcd 0a07 	vstr	s1, [sp, #28]
  if (M != N)
 80013da:	d124      	bne.n	8001426 <gsl_blas_cher2+0x5e>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 80013dc:	680c      	ldr	r4, [r1, #0]
 80013de:	42ac      	cmp	r4, r5
 80013e0:	d102      	bne.n	80013e8 <gsl_blas_cher2+0x20>
 80013e2:	6815      	ldr	r5, [r2, #0]
 80013e4:	42a5      	cmp	r5, r4
 80013e6:	d009      	beq.n	80013fc <gsl_blas_cher2+0x34>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80013e8:	4914      	ldr	r1, [pc, #80]	; (800143c <gsl_blas_cher2+0x74>)
 80013ea:	4815      	ldr	r0, [pc, #84]	; (8001440 <gsl_blas_cher2+0x78>)
 80013ec:	2313      	movs	r3, #19
 80013ee:	f240 4294 	movw	r2, #1172	; 0x494
 80013f2:	f001 fa35 	bl	8002860 <gsl_error>
 80013f6:	2013      	movs	r0, #19

  cblas_cher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
               INT (X->stride), Y->data, INT (Y->stride), A->data,
               INT (A->tda));
  return GSL_SUCCESS;
}
 80013f8:	b009      	add	sp, #36	; 0x24
 80013fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_cher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
 80013fc:	e9d3 4302 	ldrd	r4, r3, [r3, #8]
 8001400:	e9d2 7601 	ldrd	r7, r6, [r2, #4]
 8001404:	9405      	str	r4, [sp, #20]
 8001406:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 800140a:	9304      	str	r3, [sp, #16]
 800140c:	9200      	str	r2, [sp, #0]
 800140e:	4601      	mov	r1, r0
 8001410:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001414:	462a      	mov	r2, r5
 8001416:	9401      	str	r4, [sp, #4]
 8001418:	ab06      	add	r3, sp, #24
 800141a:	2065      	movs	r0, #101	; 0x65
 800141c:	f012 fdde 	bl	8013fdc <cblas_cher2>
  return GSL_SUCCESS;
 8001420:	2000      	movs	r0, #0
}
 8001422:	b009      	add	sp, #36	; 0x24
 8001424:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001426:	4905      	ldr	r1, [pc, #20]	; (800143c <gsl_blas_cher2+0x74>)
 8001428:	4806      	ldr	r0, [pc, #24]	; (8001444 <gsl_blas_cher2+0x7c>)
 800142a:	2314      	movs	r3, #20
 800142c:	f44f 6292 	mov.w	r2, #1168	; 0x490
 8001430:	f001 fa16 	bl	8002860 <gsl_error>
 8001434:	2014      	movs	r0, #20
}
 8001436:	b009      	add	sp, #36	; 0x24
 8001438:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800143a:	bf00      	nop
 800143c:	08030180 	.word	0x08030180
 8001440:	08030188 	.word	0x08030188
 8001444:	08030198 	.word	0x08030198

08001448 <gsl_blas_zher2>:

int
gsl_blas_zher2 (CBLAS_UPLO_t Uplo, const gsl_complex alpha,
                const gsl_vector_complex * X, const gsl_vector_complex * Y,
                gsl_matrix_complex * A)
{
 8001448:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 800144a:	e9d3 5400 	ldrd	r5, r4, [r3]
{
 800144e:	b08b      	sub	sp, #44	; 0x2c
  if (M != N)
 8001450:	42a5      	cmp	r5, r4
{
 8001452:	ed8d 0b06 	vstr	d0, [sp, #24]
 8001456:	ed8d 1b08 	vstr	d1, [sp, #32]
  if (M != N)
 800145a:	d124      	bne.n	80014a6 <gsl_blas_zher2+0x5e>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 800145c:	680c      	ldr	r4, [r1, #0]
 800145e:	42ac      	cmp	r4, r5
 8001460:	d102      	bne.n	8001468 <gsl_blas_zher2+0x20>
 8001462:	6815      	ldr	r5, [r2, #0]
 8001464:	42a5      	cmp	r5, r4
 8001466:	d009      	beq.n	800147c <gsl_blas_zher2+0x34>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001468:	4914      	ldr	r1, [pc, #80]	; (80014bc <gsl_blas_zher2+0x74>)
 800146a:	4815      	ldr	r0, [pc, #84]	; (80014c0 <gsl_blas_zher2+0x78>)
 800146c:	2313      	movs	r3, #19
 800146e:	f240 42ac 	movw	r2, #1196	; 0x4ac
 8001472:	f001 f9f5 	bl	8002860 <gsl_error>
 8001476:	2013      	movs	r0, #19

  cblas_zher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
               INT (X->stride), Y->data, INT (Y->stride), A->data,
               INT (A->tda));
  return GSL_SUCCESS;
}
 8001478:	b00b      	add	sp, #44	; 0x2c
 800147a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_zher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
 800147c:	e9d3 4302 	ldrd	r4, r3, [r3, #8]
 8001480:	e9d2 7601 	ldrd	r7, r6, [r2, #4]
 8001484:	9405      	str	r4, [sp, #20]
 8001486:	e9d1 4201 	ldrd	r4, r2, [r1, #4]
 800148a:	9304      	str	r3, [sp, #16]
 800148c:	9200      	str	r2, [sp, #0]
 800148e:	4601      	mov	r1, r0
 8001490:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001494:	462a      	mov	r2, r5
 8001496:	9401      	str	r4, [sp, #4]
 8001498:	ab06      	add	r3, sp, #24
 800149a:	2065      	movs	r0, #101	; 0x65
 800149c:	f01c fa48 	bl	801d930 <cblas_zher2>
  return GSL_SUCCESS;
 80014a0:	2000      	movs	r0, #0
}
 80014a2:	b00b      	add	sp, #44	; 0x2c
 80014a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 80014a6:	4905      	ldr	r1, [pc, #20]	; (80014bc <gsl_blas_zher2+0x74>)
 80014a8:	4806      	ldr	r0, [pc, #24]	; (80014c4 <gsl_blas_zher2+0x7c>)
 80014aa:	2314      	movs	r3, #20
 80014ac:	f44f 6295 	mov.w	r2, #1192	; 0x4a8
 80014b0:	f001 f9d6 	bl	8002860 <gsl_error>
 80014b4:	2014      	movs	r0, #20
}
 80014b6:	b00b      	add	sp, #44	; 0x2c
 80014b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80014ba:	bf00      	nop
 80014bc:	08030180 	.word	0x08030180
 80014c0:	08030188 	.word	0x08030188
 80014c4:	08030198 	.word	0x08030198

080014c8 <gsl_blas_ssyr>:
/* SYR */

int
gsl_blas_ssyr (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
               gsl_matrix_float * A)
{
 80014c8:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 80014ca:	e9d2 4500 	ldrd	r4, r5, [r2]
 80014ce:	42ac      	cmp	r4, r5
{
 80014d0:	b084      	sub	sp, #16
  if (M != N)
 80014d2:	d11c      	bne.n	800150e <gsl_blas_ssyr+0x46>
 80014d4:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 80014d6:	6809      	ldr	r1, [r1, #0]
 80014d8:	42a1      	cmp	r1, r4
 80014da:	d10e      	bne.n	80014fa <gsl_blas_ssyr+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ssyr (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 80014dc:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 80014e0:	685c      	ldr	r4, [r3, #4]
 80014e2:	9602      	str	r6, [sp, #8]
 80014e4:	e9cd 4500 	strd	r4, r5, [sp]
 80014e8:	460a      	mov	r2, r1
 80014ea:	689b      	ldr	r3, [r3, #8]
 80014ec:	4601      	mov	r1, r0
 80014ee:	2065      	movs	r0, #101	; 0x65
 80014f0:	f007 fd60 	bl	8008fb4 <cblas_ssyr>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 80014f4:	2000      	movs	r0, #0
}
 80014f6:	b004      	add	sp, #16
 80014f8:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80014fa:	490a      	ldr	r1, [pc, #40]	; (8001524 <gsl_blas_ssyr+0x5c>)
 80014fc:	480a      	ldr	r0, [pc, #40]	; (8001528 <gsl_blas_ssyr+0x60>)
 80014fe:	2313      	movs	r3, #19
 8001500:	f240 42c5 	movw	r2, #1221	; 0x4c5
 8001504:	f001 f9ac 	bl	8002860 <gsl_error>
 8001508:	2013      	movs	r0, #19
}
 800150a:	b004      	add	sp, #16
 800150c:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 800150e:	4905      	ldr	r1, [pc, #20]	; (8001524 <gsl_blas_ssyr+0x5c>)
 8001510:	4806      	ldr	r0, [pc, #24]	; (800152c <gsl_blas_ssyr+0x64>)
 8001512:	2314      	movs	r3, #20
 8001514:	f240 42c1 	movw	r2, #1217	; 0x4c1
 8001518:	f001 f9a2 	bl	8002860 <gsl_error>
 800151c:	2014      	movs	r0, #20
}
 800151e:	b004      	add	sp, #16
 8001520:	bd70      	pop	{r4, r5, r6, pc}
 8001522:	bf00      	nop
 8001524:	08030180 	.word	0x08030180
 8001528:	08030188 	.word	0x08030188
 800152c:	08030198 	.word	0x08030198

08001530 <gsl_blas_dsyr>:


int
gsl_blas_dsyr (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * X,
               gsl_matrix * A)
{
 8001530:	b570      	push	{r4, r5, r6, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8001532:	e9d2 4500 	ldrd	r4, r5, [r2]
 8001536:	42ac      	cmp	r4, r5
{
 8001538:	b084      	sub	sp, #16
  if (M != N)
 800153a:	d11c      	bne.n	8001576 <gsl_blas_dsyr+0x46>
 800153c:	460b      	mov	r3, r1
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N)
 800153e:	6809      	ldr	r1, [r1, #0]
 8001540:	42a1      	cmp	r1, r4
 8001542:	d10e      	bne.n	8001562 <gsl_blas_dsyr+0x32>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dsyr (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 8001544:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 8001548:	685c      	ldr	r4, [r3, #4]
 800154a:	9602      	str	r6, [sp, #8]
 800154c:	e9cd 4500 	strd	r4, r5, [sp]
 8001550:	460a      	mov	r2, r1
 8001552:	689b      	ldr	r3, [r3, #8]
 8001554:	4601      	mov	r1, r0
 8001556:	2065      	movs	r0, #101	; 0x65
 8001558:	f00c fdae 	bl	800e0b8 <cblas_dsyr>
              A->data, INT (A->tda));
  return GSL_SUCCESS;
 800155c:	2000      	movs	r0, #0
}
 800155e:	b004      	add	sp, #16
 8001560:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001562:	490a      	ldr	r1, [pc, #40]	; (800158c <gsl_blas_dsyr+0x5c>)
 8001564:	480a      	ldr	r0, [pc, #40]	; (8001590 <gsl_blas_dsyr+0x60>)
 8001566:	2313      	movs	r3, #19
 8001568:	f240 42db 	movw	r2, #1243	; 0x4db
 800156c:	f001 f978 	bl	8002860 <gsl_error>
 8001570:	2013      	movs	r0, #19
}
 8001572:	b004      	add	sp, #16
 8001574:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001576:	4905      	ldr	r1, [pc, #20]	; (800158c <gsl_blas_dsyr+0x5c>)
 8001578:	4806      	ldr	r0, [pc, #24]	; (8001594 <gsl_blas_dsyr+0x64>)
 800157a:	2314      	movs	r3, #20
 800157c:	f240 42d7 	movw	r2, #1239	; 0x4d7
 8001580:	f001 f96e 	bl	8002860 <gsl_error>
 8001584:	2014      	movs	r0, #20
}
 8001586:	b004      	add	sp, #16
 8001588:	bd70      	pop	{r4, r5, r6, pc}
 800158a:	bf00      	nop
 800158c:	08030180 	.word	0x08030180
 8001590:	08030188 	.word	0x08030188
 8001594:	08030198 	.word	0x08030198

08001598 <gsl_blas_ssyr2>:
/* SYR2 */

int
gsl_blas_ssyr2 (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
                const gsl_vector_float * Y, gsl_matrix_float * A)
{
 8001598:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 800159a:	e9d3 4500 	ldrd	r4, r5, [r3]
 800159e:	42ac      	cmp	r4, r5
{
 80015a0:	b087      	sub	sp, #28
  if (M != N)
 80015a2:	d124      	bne.n	80015ee <gsl_blas_ssyr2+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 80015a4:	680d      	ldr	r5, [r1, #0]
 80015a6:	42a5      	cmp	r5, r4
 80015a8:	460e      	mov	r6, r1
 80015aa:	d102      	bne.n	80015b2 <gsl_blas_ssyr2+0x1a>
 80015ac:	6811      	ldr	r1, [r2, #0]
 80015ae:	42a9      	cmp	r1, r5
 80015b0:	d009      	beq.n	80015c6 <gsl_blas_ssyr2+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80015b2:	4914      	ldr	r1, [pc, #80]	; (8001604 <gsl_blas_ssyr2+0x6c>)
 80015b4:	4814      	ldr	r0, [pc, #80]	; (8001608 <gsl_blas_ssyr2+0x70>)
 80015b6:	2313      	movs	r3, #19
 80015b8:	f240 42f3 	movw	r2, #1267	; 0x4f3
 80015bc:	f001 f950 	bl	8002860 <gsl_error>
 80015c0:	2013      	movs	r0, #19
    }

  cblas_ssyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
               Y->data, INT (Y->stride), A->data, INT (A->tda));
  return GSL_SUCCESS;
}
 80015c2:	b007      	add	sp, #28
 80015c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_ssyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 80015c6:	e9d3 c702 	ldrd	ip, r7, [r3, #8]
 80015ca:	e9d2 5401 	ldrd	r5, r4, [r2, #4]
 80015ce:	f8cd c010 	str.w	ip, [sp, #16]
 80015d2:	6873      	ldr	r3, [r6, #4]
 80015d4:	9300      	str	r3, [sp, #0]
 80015d6:	e9cd 4501 	strd	r4, r5, [sp, #4]
 80015da:	9703      	str	r7, [sp, #12]
 80015dc:	460a      	mov	r2, r1
 80015de:	68b3      	ldr	r3, [r6, #8]
 80015e0:	4601      	mov	r1, r0
 80015e2:	2065      	movs	r0, #101	; 0x65
 80015e4:	f007 fdc2 	bl	800916c <cblas_ssyr2>
  return GSL_SUCCESS;
 80015e8:	2000      	movs	r0, #0
}
 80015ea:	b007      	add	sp, #28
 80015ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 80015ee:	4905      	ldr	r1, [pc, #20]	; (8001604 <gsl_blas_ssyr2+0x6c>)
 80015f0:	4806      	ldr	r0, [pc, #24]	; (800160c <gsl_blas_ssyr2+0x74>)
 80015f2:	2314      	movs	r3, #20
 80015f4:	f240 42ef 	movw	r2, #1263	; 0x4ef
 80015f8:	f001 f932 	bl	8002860 <gsl_error>
 80015fc:	2014      	movs	r0, #20
}
 80015fe:	b007      	add	sp, #28
 8001600:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001602:	bf00      	nop
 8001604:	08030180 	.word	0x08030180
 8001608:	08030188 	.word	0x08030188
 800160c:	08030198 	.word	0x08030198

08001610 <gsl_blas_dsyr2>:


int
gsl_blas_dsyr2 (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * X,
                const gsl_vector * Y, gsl_matrix * A)
{
 8001610:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = A->size1;
  const size_t N = A->size2;

  if (M != N)
 8001612:	e9d3 4500 	ldrd	r4, r5, [r3]
 8001616:	42ac      	cmp	r4, r5
{
 8001618:	b087      	sub	sp, #28
  if (M != N)
 800161a:	d124      	bne.n	8001666 <gsl_blas_dsyr2+0x56>
    {
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
    }
  else if (X->size != N || Y->size != N)
 800161c:	680d      	ldr	r5, [r1, #0]
 800161e:	42a5      	cmp	r5, r4
 8001620:	460e      	mov	r6, r1
 8001622:	d102      	bne.n	800162a <gsl_blas_dsyr2+0x1a>
 8001624:	6811      	ldr	r1, [r2, #0]
 8001626:	42a9      	cmp	r1, r5
 8001628:	d009      	beq.n	800163e <gsl_blas_dsyr2+0x2e>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800162a:	4914      	ldr	r1, [pc, #80]	; (800167c <gsl_blas_dsyr2+0x6c>)
 800162c:	4814      	ldr	r0, [pc, #80]	; (8001680 <gsl_blas_dsyr2+0x70>)
 800162e:	2313      	movs	r3, #19
 8001630:	f240 5209 	movw	r2, #1289	; 0x509
 8001634:	f001 f914 	bl	8002860 <gsl_error>
 8001638:	2013      	movs	r0, #19
    }

  cblas_dsyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
               Y->data, INT (Y->stride), A->data, INT (A->tda));
  return GSL_SUCCESS;
}
 800163a:	b007      	add	sp, #28
 800163c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cblas_dsyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
 800163e:	e9d3 c702 	ldrd	ip, r7, [r3, #8]
 8001642:	e9d2 5401 	ldrd	r5, r4, [r2, #4]
 8001646:	f8cd c010 	str.w	ip, [sp, #16]
 800164a:	6873      	ldr	r3, [r6, #4]
 800164c:	9300      	str	r3, [sp, #0]
 800164e:	e9cd 4501 	strd	r4, r5, [sp, #4]
 8001652:	9703      	str	r7, [sp, #12]
 8001654:	460a      	mov	r2, r1
 8001656:	68b3      	ldr	r3, [r6, #8]
 8001658:	4601      	mov	r1, r0
 800165a:	2065      	movs	r0, #101	; 0x65
 800165c:	f00c fe56 	bl	800e30c <cblas_dsyr2>
  return GSL_SUCCESS;
 8001660:	2000      	movs	r0, #0
}
 8001662:	b007      	add	sp, #28
 8001664:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
 8001666:	4905      	ldr	r1, [pc, #20]	; (800167c <gsl_blas_dsyr2+0x6c>)
 8001668:	4806      	ldr	r0, [pc, #24]	; (8001684 <gsl_blas_dsyr2+0x74>)
 800166a:	2314      	movs	r3, #20
 800166c:	f240 5205 	movw	r2, #1285	; 0x505
 8001670:	f001 f8f6 	bl	8002860 <gsl_error>
 8001674:	2014      	movs	r0, #20
}
 8001676:	b007      	add	sp, #28
 8001678:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800167a:	bf00      	nop
 800167c:	08030180 	.word	0x08030180
 8001680:	08030188 	.word	0x08030188
 8001684:	08030198 	.word	0x08030198

08001688 <gsl_blas_sgemm>:

int
gsl_blas_sgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                float alpha, const gsl_matrix_float * A,
                const gsl_matrix_float * B, float beta, gsl_matrix_float * C)
{
 8001688:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800168c:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800168e:	286f      	cmp	r0, #111	; 0x6f
{
 8001690:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 8001694:	e9d2 e700 	ldrd	lr, r7, [r2]
  const size_t M = C->size1;
 8001698:	f8dc 6000 	ldr.w	r6, [ip]
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800169c:	d102      	bne.n	80016a4 <gsl_blas_sgemm+0x1c>
 800169e:	4674      	mov	r4, lr
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 80016a0:	46be      	mov	lr, r7
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80016a2:	4627      	mov	r7, r4
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80016a4:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80016a6:	e9d3 4500 	ldrd	r4, r5, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80016aa:	d102      	bne.n	80016b2 <gsl_blas_sgemm+0x2a>
 80016ac:	46a0      	mov	r8, r4
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80016ae:	462c      	mov	r4, r5
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80016b0:	4645      	mov	r5, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80016b2:	42be      	cmp	r6, r7
 80016b4:	d105      	bne.n	80016c2 <gsl_blas_sgemm+0x3a>
  const size_t N = C->size2;
 80016b6:	f8dc 7004 	ldr.w	r7, [ip, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80016ba:	42bc      	cmp	r4, r7
 80016bc:	d101      	bne.n	80016c2 <gsl_blas_sgemm+0x3a>
 80016be:	45ae      	cmp	lr, r5
 80016c0:	d00a      	beq.n	80016d8 <gsl_blas_sgemm+0x50>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80016c2:	4912      	ldr	r1, [pc, #72]	; (800170c <gsl_blas_sgemm+0x84>)
 80016c4:	4812      	ldr	r0, [pc, #72]	; (8001710 <gsl_blas_sgemm+0x88>)
 80016c6:	2313      	movs	r3, #19
 80016c8:	f44f 62a6 	mov.w	r2, #1328	; 0x530
 80016cc:	f001 f8c8 	bl	8002860 <gsl_error>
 80016d0:	2013      	movs	r0, #19
    }
}
 80016d2:	b008      	add	sp, #32
 80016d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      cblas_sgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 80016d8:	e9dc 8c02 	ldrd	r8, ip, [ip, #8]
 80016dc:	f8cd e004 	str.w	lr, [sp, #4]
 80016e0:	e9d3 e702 	ldrd	lr, r7, [r3, #8]
 80016e4:	9400      	str	r4, [sp, #0]
 80016e6:	e9d2 5402 	ldrd	r5, r4, [r2, #8]
 80016ea:	4633      	mov	r3, r6
 80016ec:	460a      	mov	r2, r1
 80016ee:	e9cd ec05 	strd	lr, ip, [sp, #20]
 80016f2:	4601      	mov	r1, r0
 80016f4:	e9cd 5703 	strd	r5, r7, [sp, #12]
 80016f8:	f8cd 801c 	str.w	r8, [sp, #28]
 80016fc:	9402      	str	r4, [sp, #8]
 80016fe:	2065      	movs	r0, #101	; 0x65
 8001700:	f005 ff7c 	bl	80075fc <cblas_sgemm>
      return GSL_SUCCESS;
 8001704:	2000      	movs	r0, #0
}
 8001706:	b008      	add	sp, #32
 8001708:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800170c:	08030180 	.word	0x08030180
 8001710:	08030188 	.word	0x08030188

08001714 <gsl_blas_dgemm>:

int
gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                double alpha, const gsl_matrix * A, const gsl_matrix * B,
                double beta, gsl_matrix * C)
{
 8001714:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001718:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800171a:	286f      	cmp	r0, #111	; 0x6f
{
 800171c:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 8001720:	e9d2 e700 	ldrd	lr, r7, [r2]
  const size_t M = C->size1;
 8001724:	f8dc 6000 	ldr.w	r6, [ip]
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 8001728:	d102      	bne.n	8001730 <gsl_blas_dgemm+0x1c>
 800172a:	4674      	mov	r4, lr
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 800172c:	46be      	mov	lr, r7
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800172e:	4627      	mov	r7, r4
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001730:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 8001732:	e9d3 4500 	ldrd	r4, r5, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001736:	d102      	bne.n	800173e <gsl_blas_dgemm+0x2a>
 8001738:	46a0      	mov	r8, r4
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 800173a:	462c      	mov	r4, r5
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 800173c:	4645      	mov	r5, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 800173e:	42be      	cmp	r6, r7
 8001740:	d105      	bne.n	800174e <gsl_blas_dgemm+0x3a>
  const size_t N = C->size2;
 8001742:	f8dc 7004 	ldr.w	r7, [ip, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 8001746:	42bc      	cmp	r4, r7
 8001748:	d101      	bne.n	800174e <gsl_blas_dgemm+0x3a>
 800174a:	45ae      	cmp	lr, r5
 800174c:	d00a      	beq.n	8001764 <gsl_blas_dgemm+0x50>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800174e:	4912      	ldr	r1, [pc, #72]	; (8001798 <gsl_blas_dgemm+0x84>)
 8001750:	4812      	ldr	r0, [pc, #72]	; (800179c <gsl_blas_dgemm+0x88>)
 8001752:	2313      	movs	r3, #19
 8001754:	f240 524a 	movw	r2, #1354	; 0x54a
 8001758:	f001 f882 	bl	8002860 <gsl_error>
 800175c:	2013      	movs	r0, #19
    }
}
 800175e:	b008      	add	sp, #32
 8001760:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      cblas_dgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 8001764:	e9dc 8c02 	ldrd	r8, ip, [ip, #8]
 8001768:	f8cd e004 	str.w	lr, [sp, #4]
 800176c:	e9d3 e702 	ldrd	lr, r7, [r3, #8]
 8001770:	9400      	str	r4, [sp, #0]
 8001772:	e9d2 5402 	ldrd	r5, r4, [r2, #8]
 8001776:	4633      	mov	r3, r6
 8001778:	460a      	mov	r2, r1
 800177a:	e9cd ec05 	strd	lr, ip, [sp, #20]
 800177e:	4601      	mov	r1, r0
 8001780:	e9cd 5703 	strd	r5, r7, [sp, #12]
 8001784:	f8cd 801c 	str.w	r8, [sp, #28]
 8001788:	9402      	str	r4, [sp, #8]
 800178a:	2065      	movs	r0, #101	; 0x65
 800178c:	f00a f956 	bl	800ba3c <cblas_dgemm>
      return GSL_SUCCESS;
 8001790:	2000      	movs	r0, #0
}
 8001792:	b008      	add	sp, #32
 8001794:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001798:	08030180 	.word	0x08030180
 800179c:	08030188 	.word	0x08030188

080017a0 <gsl_blas_cgemm>:
gsl_blas_cgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_matrix_complex_float * B,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 80017a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80017a4:	b08e      	sub	sp, #56	; 0x38
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80017a6:	286f      	cmp	r0, #111	; 0x6f
{
 80017a8:	9c14      	ldr	r4, [sp, #80]	; 0x50
 80017aa:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 80017ae:	e9d2 7500 	ldrd	r7, r5, [r2]
  const size_t M = C->size1;
 80017b2:	f8d4 e000 	ldr.w	lr, [r4]
{
 80017b6:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 80017ba:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 80017be:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80017c2:	d102      	bne.n	80017ca <gsl_blas_cgemm+0x2a>
 80017c4:	463e      	mov	r6, r7
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 80017c6:	462f      	mov	r7, r5
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 80017c8:	4635      	mov	r5, r6
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80017ca:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80017cc:	e9d3 6c00 	ldrd	r6, ip, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80017d0:	d102      	bne.n	80017d8 <gsl_blas_cgemm+0x38>
 80017d2:	46b0      	mov	r8, r6
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 80017d4:	4666      	mov	r6, ip
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 80017d6:	46c4      	mov	ip, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80017d8:	45ae      	cmp	lr, r5
 80017da:	d104      	bne.n	80017e6 <gsl_blas_cgemm+0x46>
  const size_t N = C->size2;
 80017dc:	6865      	ldr	r5, [r4, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 80017de:	42ae      	cmp	r6, r5
 80017e0:	d101      	bne.n	80017e6 <gsl_blas_cgemm+0x46>
 80017e2:	4567      	cmp	r7, ip
 80017e4:	d00a      	beq.n	80017fc <gsl_blas_cgemm+0x5c>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80017e6:	4914      	ldr	r1, [pc, #80]	; (8001838 <gsl_blas_cgemm+0x98>)
 80017e8:	4814      	ldr	r0, [pc, #80]	; (800183c <gsl_blas_cgemm+0x9c>)
 80017ea:	2313      	movs	r3, #19
 80017ec:	f240 5267 	movw	r2, #1383	; 0x567
 80017f0:	f001 f836 	bl	8002860 <gsl_error>
 80017f4:	2013      	movs	r0, #19
    }
}
 80017f6:	b00e      	add	sp, #56	; 0x38
 80017f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      cblas_cgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 80017fc:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001800:	9701      	str	r7, [sp, #4]
 8001802:	9600      	str	r6, [sp, #0]
 8001804:	e9d3 8702 	ldrd	r8, r7, [r3, #8]
 8001808:	9509      	str	r5, [sp, #36]	; 0x24
 800180a:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
 800180e:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001812:	9408      	str	r4, [sp, #32]
 8001814:	ac0c      	add	r4, sp, #48	; 0x30
 8001816:	460a      	mov	r2, r1
 8001818:	e9cd 8c06 	strd	r8, ip, [sp, #24]
 800181c:	4601      	mov	r1, r0
 800181e:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001822:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001826:	4673      	mov	r3, lr
 8001828:	2065      	movs	r0, #101	; 0x65
 800182a:	f010 f9ff 	bl	8011c2c <cblas_cgemm>
      return GSL_SUCCESS;
 800182e:	2000      	movs	r0, #0
}
 8001830:	b00e      	add	sp, #56	; 0x38
 8001832:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001836:	bf00      	nop
 8001838:	08030180 	.word	0x08030180
 800183c:	08030188 	.word	0x08030188

08001840 <gsl_blas_zgemm>:
int
gsl_blas_zgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_matrix_complex * B, const gsl_complex beta,
                gsl_matrix_complex * C)
{
 8001840:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001844:	b093      	sub	sp, #76	; 0x4c
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 8001846:	286f      	cmp	r0, #111	; 0x6f
{
 8001848:	f8dd c068 	ldr.w	ip, [sp, #104]	; 0x68
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 800184c:	e9d2 e700 	ldrd	lr, r7, [r2]
{
 8001850:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 8001854:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8001858:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 800185c:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
  const size_t M = C->size1;
 8001860:	f8dc 6000 	ldr.w	r6, [ip]
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 8001864:	d102      	bne.n	800186c <gsl_blas_zgemm+0x2c>
 8001866:	4674      	mov	r4, lr
  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
 8001868:	46be      	mov	lr, r7
  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
 800186a:	4627      	mov	r7, r4
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 800186c:	296f      	cmp	r1, #111	; 0x6f
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 800186e:	e9d3 4500 	ldrd	r4, r5, [r3]
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001872:	d102      	bne.n	800187a <gsl_blas_zgemm+0x3a>
 8001874:	46a0      	mov	r8, r4
  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
 8001876:	462c      	mov	r4, r5
  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
 8001878:	4645      	mov	r5, r8

  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 800187a:	42be      	cmp	r6, r7
 800187c:	d105      	bne.n	800188a <gsl_blas_zgemm+0x4a>
  const size_t N = C->size2;
 800187e:	f8dc 7004 	ldr.w	r7, [ip, #4]
  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
 8001882:	42bc      	cmp	r4, r7
 8001884:	d101      	bne.n	800188a <gsl_blas_zgemm+0x4a>
 8001886:	45ae      	cmp	lr, r5
 8001888:	d00a      	beq.n	80018a0 <gsl_blas_zgemm+0x60>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800188a:	4915      	ldr	r1, [pc, #84]	; (80018e0 <gsl_blas_zgemm+0xa0>)
 800188c:	4815      	ldr	r0, [pc, #84]	; (80018e4 <gsl_blas_zgemm+0xa4>)
 800188e:	2313      	movs	r3, #19
 8001890:	f240 5283 	movw	r2, #1411	; 0x583
 8001894:	f000 ffe4 	bl	8002860 <gsl_error>
 8001898:	2013      	movs	r0, #19
    }
}
 800189a:	b013      	add	sp, #76	; 0x4c
 800189c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      cblas_zgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
 80018a0:	e9dc 5902 	ldrd	r5, r9, [ip, #8]
 80018a4:	f8cd e004 	str.w	lr, [sp, #4]
 80018a8:	9400      	str	r4, [sp, #0]
 80018aa:	e9d3 8c02 	ldrd	r8, ip, [r3, #8]
 80018ae:	9509      	str	r5, [sp, #36]	; 0x24
 80018b0:	e9d2 7502 	ldrd	r7, r5, [r2, #8]
 80018b4:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 80018b8:	ac0e      	add	r4, sp, #56	; 0x38
 80018ba:	460a      	mov	r2, r1
 80018bc:	e9cd 8e06 	strd	r8, lr, [sp, #24]
 80018c0:	4601      	mov	r1, r0
 80018c2:	e9cd 7c04 	strd	r7, ip, [sp, #16]
 80018c6:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80018ca:	f8cd 9020 	str.w	r9, [sp, #32]
 80018ce:	4633      	mov	r3, r6
 80018d0:	2065      	movs	r0, #101	; 0x65
 80018d2:	f017 ffe5 	bl	80198a0 <cblas_zgemm>
      return GSL_SUCCESS;
 80018d6:	2000      	movs	r0, #0
}
 80018d8:	b013      	add	sp, #76	; 0x4c
 80018da:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80018de:	bf00      	nop
 80018e0:	08030180 	.word	0x08030180
 80018e4:	08030188 	.word	0x08030188

080018e8 <gsl_blas_ssymm>:

int
gsl_blas_ssymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, float alpha,
                const gsl_matrix_float * A, const gsl_matrix_float * B,
                float beta, gsl_matrix_float * C)
{
 80018e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 80018ea:	e9d2 6400 	ldrd	r6, r4, [r2]
{
 80018ee:	b089      	sub	sp, #36	; 0x24
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 80018f0:	42a6      	cmp	r6, r4
{
 80018f2:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (MA != NA)
 80018f4:	d134      	bne.n	8001960 <gsl_blas_ssymm+0x78>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 80018f6:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 80018f8:	e9d5 4700 	ldrd	r4, r7, [r5]
  const size_t NB = B->size2;
 80018fc:	e9d3 ce00 	ldrd	ip, lr, [r3]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001900:	d011      	beq.n	8001926 <gsl_blas_ssymm+0x3e>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001902:	288e      	cmp	r0, #142	; 0x8e
 8001904:	d105      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 8001906:	4564      	cmp	r4, ip
 8001908:	d103      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800190a:	42b7      	cmp	r7, r6
 800190c:	d101      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800190e:	4577      	cmp	r7, lr
 8001910:	d00f      	beq.n	8001932 <gsl_blas_ssymm+0x4a>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001912:	4918      	ldr	r1, [pc, #96]	; (8001974 <gsl_blas_ssymm+0x8c>)
 8001914:	4818      	ldr	r0, [pc, #96]	; (8001978 <gsl_blas_ssymm+0x90>)
 8001916:	2313      	movs	r3, #19
 8001918:	f240 52a5 	movw	r2, #1445	; 0x5a5
 800191c:	f000 ffa0 	bl	8002860 <gsl_error>
 8001920:	2013      	movs	r0, #19
    }

}
 8001922:	b009      	add	sp, #36	; 0x24
 8001924:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001926:	42b4      	cmp	r4, r6
 8001928:	d1f3      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800192a:	4577      	cmp	r7, lr
 800192c:	d1f1      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
 800192e:	4564      	cmp	r4, ip
 8001930:	d1ef      	bne.n	8001912 <gsl_blas_ssymm+0x2a>
      cblas_ssymm (CblasRowMajor, Side, Uplo, INT (M), INT (N), alpha,
 8001932:	e9d5 6e02 	ldrd	r6, lr, [r5, #8]
 8001936:	9700      	str	r7, [sp, #0]
 8001938:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 800193c:	9606      	str	r6, [sp, #24]
 800193e:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001942:	460a      	mov	r2, r1
 8001944:	9301      	str	r3, [sp, #4]
 8001946:	4601      	mov	r1, r0
 8001948:	e9cd 7503 	strd	r7, r5, [sp, #12]
 800194c:	f8cd e014 	str.w	lr, [sp, #20]
 8001950:	4623      	mov	r3, r4
 8001952:	9602      	str	r6, [sp, #8]
 8001954:	2065      	movs	r0, #101	; 0x65
 8001956:	f006 fe45 	bl	80085e4 <cblas_ssymm>
      return GSL_SUCCESS;
 800195a:	2000      	movs	r0, #0
}
 800195c:	b009      	add	sp, #36	; 0x24
 800195e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001960:	4904      	ldr	r1, [pc, #16]	; (8001974 <gsl_blas_ssymm+0x8c>)
 8001962:	4806      	ldr	r0, [pc, #24]	; (800197c <gsl_blas_ssymm+0x94>)
 8001964:	2314      	movs	r3, #20
 8001966:	f44f 62b3 	mov.w	r2, #1432	; 0x598
 800196a:	f000 ff79 	bl	8002860 <gsl_error>
 800196e:	2014      	movs	r0, #20
}
 8001970:	b009      	add	sp, #36	; 0x24
 8001972:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001974:	08030180 	.word	0x08030180
 8001978:	08030188 	.word	0x08030188
 800197c:	080301b0 	.word	0x080301b0

08001980 <gsl_blas_dsymm>:

int
gsl_blas_dsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, double alpha,
                const gsl_matrix * A, const gsl_matrix * B, double beta,
                gsl_matrix * C)
{
 8001980:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 8001982:	e9d2 6400 	ldrd	r6, r4, [r2]
{
 8001986:	b089      	sub	sp, #36	; 0x24
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001988:	42a6      	cmp	r6, r4
{
 800198a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (MA != NA)
 800198c:	d134      	bne.n	80019f8 <gsl_blas_dsymm+0x78>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 800198e:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001990:	e9d5 4700 	ldrd	r4, r7, [r5]
  const size_t NB = B->size2;
 8001994:	e9d3 ce00 	ldrd	ip, lr, [r3]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001998:	d011      	beq.n	80019be <gsl_blas_dsymm+0x3e>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 800199a:	288e      	cmp	r0, #142	; 0x8e
 800199c:	d105      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 800199e:	4564      	cmp	r4, ip
 80019a0:	d103      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019a2:	42b7      	cmp	r7, r6
 80019a4:	d101      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019a6:	4577      	cmp	r7, lr
 80019a8:	d00f      	beq.n	80019ca <gsl_blas_dsymm+0x4a>
                   C->data, INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80019aa:	4918      	ldr	r1, [pc, #96]	; (8001a0c <gsl_blas_dsymm+0x8c>)
 80019ac:	4818      	ldr	r0, [pc, #96]	; (8001a10 <gsl_blas_dsymm+0x90>)
 80019ae:	2313      	movs	r3, #19
 80019b0:	f240 52c6 	movw	r2, #1478	; 0x5c6
 80019b4:	f000 ff54 	bl	8002860 <gsl_error>
 80019b8:	2013      	movs	r0, #19
    }
}
 80019ba:	b009      	add	sp, #36	; 0x24
 80019bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 80019be:	42b4      	cmp	r4, r6
 80019c0:	d1f3      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019c2:	4577      	cmp	r7, lr
 80019c4:	d1f1      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
 80019c6:	4564      	cmp	r4, ip
 80019c8:	d1ef      	bne.n	80019aa <gsl_blas_dsymm+0x2a>
      cblas_dsymm (CblasRowMajor, Side, Uplo, INT (M), INT (N), alpha,
 80019ca:	e9d5 6e02 	ldrd	r6, lr, [r5, #8]
 80019ce:	9700      	str	r7, [sp, #0]
 80019d0:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 80019d4:	9606      	str	r6, [sp, #24]
 80019d6:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 80019da:	460a      	mov	r2, r1
 80019dc:	9301      	str	r3, [sp, #4]
 80019de:	4601      	mov	r1, r0
 80019e0:	e9cd 7503 	strd	r7, r5, [sp, #12]
 80019e4:	f8cd e014 	str.w	lr, [sp, #20]
 80019e8:	4623      	mov	r3, r4
 80019ea:	9602      	str	r6, [sp, #8]
 80019ec:	2065      	movs	r0, #101	; 0x65
 80019ee:	f00b fc83 	bl	800d2f8 <cblas_dsymm>
      return GSL_SUCCESS;
 80019f2:	2000      	movs	r0, #0
}
 80019f4:	b009      	add	sp, #36	; 0x24
 80019f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 80019f8:	4904      	ldr	r1, [pc, #16]	; (8001a0c <gsl_blas_dsymm+0x8c>)
 80019fa:	4806      	ldr	r0, [pc, #24]	; (8001a14 <gsl_blas_dsymm+0x94>)
 80019fc:	2314      	movs	r3, #20
 80019fe:	f240 52b9 	movw	r2, #1465	; 0x5b9
 8001a02:	f000 ff2d 	bl	8002860 <gsl_error>
 8001a06:	2014      	movs	r0, #20
}
 8001a08:	b009      	add	sp, #36	; 0x24
 8001a0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a0c:	08030180 	.word	0x08030180
 8001a10:	08030188 	.word	0x08030188
 8001a14:	080301b0 	.word	0x080301b0

08001a18 <gsl_blas_csymm>:
gsl_blas_csymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_matrix_complex_float * B,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8001a18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001a1c:	4614      	mov	r4, r2
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
 8001a1e:	6812      	ldr	r2, [r2, #0]
  const size_t NA = A->size2;
 8001a20:	6867      	ldr	r7, [r4, #4]
{
 8001a22:	b08e      	sub	sp, #56	; 0x38
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001a24:	42ba      	cmp	r2, r7
{
 8001a26:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8001a28:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
 8001a2c:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 8001a30:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 8001a34:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  if (MA != NA)
 8001a38:	d13d      	bne.n	8001ab6 <gsl_blas_csymm+0x9e>
 8001a3a:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001a3c:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001a3e:	e9d6 3700 	ldrd	r3, r7, [r6]
  const size_t NB = B->size2;
 8001a42:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001a46:	d012      	beq.n	8001a6e <gsl_blas_csymm+0x56>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001a48:	288e      	cmp	r0, #142	; 0x8e
 8001a4a:	d105      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a4c:	4563      	cmp	r3, ip
 8001a4e:	d103      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a50:	4297      	cmp	r7, r2
 8001a52:	d101      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a54:	4577      	cmp	r7, lr
 8001a56:	d010      	beq.n	8001a7a <gsl_blas_csymm+0x62>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001a58:	491c      	ldr	r1, [pc, #112]	; (8001acc <gsl_blas_csymm+0xb4>)
 8001a5a:	481d      	ldr	r0, [pc, #116]	; (8001ad0 <gsl_blas_csymm+0xb8>)
 8001a5c:	2313      	movs	r3, #19
 8001a5e:	f240 52e9 	movw	r2, #1513	; 0x5e9
 8001a62:	f000 fefd 	bl	8002860 <gsl_error>
 8001a66:	2013      	movs	r0, #19
    }
}
 8001a68:	b00e      	add	sp, #56	; 0x38
 8001a6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001a6e:	4293      	cmp	r3, r2
 8001a70:	d1f2      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a72:	4577      	cmp	r7, lr
 8001a74:	d1f0      	bne.n	8001a58 <gsl_blas_csymm+0x40>
 8001a76:	4563      	cmp	r3, ip
 8001a78:	d1ee      	bne.n	8001a58 <gsl_blas_csymm+0x40>
      cblas_csymm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001a7a:	e9d6 8e02 	ldrd	r8, lr, [r6, #8]
 8001a7e:	9700      	str	r7, [sp, #0]
 8001a80:	f8cd 8020 	str.w	r8, [sp, #32]
 8001a84:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001a88:	f8cd e01c 	str.w	lr, [sp, #28]
 8001a8c:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001a90:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001a94:	460a      	mov	r2, r1
 8001a96:	4601      	mov	r1, r0
 8001a98:	a80c      	add	r0, sp, #48	; 0x30
 8001a9a:	9001      	str	r0, [sp, #4]
 8001a9c:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001aa0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001aa4:	f8cd c018 	str.w	ip, [sp, #24]
 8001aa8:	2065      	movs	r0, #101	; 0x65
 8001aaa:	f013 fce5 	bl	8015478 <cblas_csymm>
      return GSL_SUCCESS;
 8001aae:	2000      	movs	r0, #0
}
 8001ab0:	b00e      	add	sp, #56	; 0x38
 8001ab2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001ab6:	4905      	ldr	r1, [pc, #20]	; (8001acc <gsl_blas_csymm+0xb4>)
 8001ab8:	4806      	ldr	r0, [pc, #24]	; (8001ad4 <gsl_blas_csymm+0xbc>)
 8001aba:	2314      	movs	r3, #20
 8001abc:	f240 52db 	movw	r2, #1499	; 0x5db
 8001ac0:	f000 fece 	bl	8002860 <gsl_error>
 8001ac4:	2014      	movs	r0, #20
}
 8001ac6:	b00e      	add	sp, #56	; 0x38
 8001ac8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001acc:	08030180 	.word	0x08030180
 8001ad0:	08030188 	.word	0x08030188
 8001ad4:	080301b0 	.word	0x080301b0

08001ad8 <gsl_blas_zsymm>:
int
gsl_blas_zsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_matrix_complex * B, const gsl_complex beta,
                gsl_matrix_complex * C)
{
 8001ad8:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 8001ada:	e9d2 7600 	ldrd	r7, r6, [r2]
{
 8001ade:	b093      	sub	sp, #76	; 0x4c
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001ae0:	42b7      	cmp	r7, r6
{
 8001ae2:	4614      	mov	r4, r2
 8001ae4:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 8001ae8:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8001aec:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 8001af0:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
 8001af4:	9a18      	ldr	r2, [sp, #96]	; 0x60
  if (MA != NA)
 8001af6:	d13a      	bne.n	8001b6e <gsl_blas_zsymm+0x96>
 8001af8:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001afa:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001afc:	e9d2 3600 	ldrd	r3, r6, [r2]
  const size_t NB = B->size2;
 8001b00:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001b04:	d011      	beq.n	8001b2a <gsl_blas_zsymm+0x52>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001b06:	288e      	cmp	r0, #142	; 0x8e
 8001b08:	d105      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b0a:	4563      	cmp	r3, ip
 8001b0c:	d103      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b0e:	42be      	cmp	r6, r7
 8001b10:	d101      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b12:	4576      	cmp	r6, lr
 8001b14:	d00f      	beq.n	8001b36 <gsl_blas_zsymm+0x5e>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001b16:	491b      	ldr	r1, [pc, #108]	; (8001b84 <gsl_blas_zsymm+0xac>)
 8001b18:	481b      	ldr	r0, [pc, #108]	; (8001b88 <gsl_blas_zsymm+0xb0>)
 8001b1a:	2313      	movs	r3, #19
 8001b1c:	f240 620a 	movw	r2, #1546	; 0x60a
 8001b20:	f000 fe9e 	bl	8002860 <gsl_error>
 8001b24:	2013      	movs	r0, #19
    }
}
 8001b26:	b013      	add	sp, #76	; 0x4c
 8001b28:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001b2a:	42bb      	cmp	r3, r7
 8001b2c:	d1f3      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b2e:	4576      	cmp	r6, lr
 8001b30:	d1f1      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
 8001b32:	4563      	cmp	r3, ip
 8001b34:	d1ef      	bne.n	8001b16 <gsl_blas_zsymm+0x3e>
      cblas_zsymm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001b36:	e9d2 7e02 	ldrd	r7, lr, [r2, #8]
 8001b3a:	9600      	str	r6, [sp, #0]
 8001b3c:	9708      	str	r7, [sp, #32]
 8001b3e:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001b42:	f8cd e01c 	str.w	lr, [sp, #28]
 8001b46:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001b4a:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001b4e:	460a      	mov	r2, r1
 8001b50:	4601      	mov	r1, r0
 8001b52:	a80e      	add	r0, sp, #56	; 0x38
 8001b54:	9001      	str	r0, [sp, #4]
 8001b56:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001b5a:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001b5e:	f8cd c018 	str.w	ip, [sp, #24]
 8001b62:	2065      	movs	r0, #101	; 0x65
 8001b64:	f01e fa04 	bl	801ff70 <cblas_zsymm>
      return GSL_SUCCESS;
 8001b68:	2000      	movs	r0, #0
}
 8001b6a:	b013      	add	sp, #76	; 0x4c
 8001b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001b6e:	4905      	ldr	r1, [pc, #20]	; (8001b84 <gsl_blas_zsymm+0xac>)
 8001b70:	4806      	ldr	r0, [pc, #24]	; (8001b8c <gsl_blas_zsymm+0xb4>)
 8001b72:	2314      	movs	r3, #20
 8001b74:	f240 52fc 	movw	r2, #1532	; 0x5fc
 8001b78:	f000 fe72 	bl	8002860 <gsl_error>
 8001b7c:	2014      	movs	r0, #20
}
 8001b7e:	b013      	add	sp, #76	; 0x4c
 8001b80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001b82:	bf00      	nop
 8001b84:	08030180 	.word	0x08030180
 8001b88:	08030188 	.word	0x08030188
 8001b8c:	080301b0 	.word	0x080301b0

08001b90 <gsl_blas_chemm>:
gsl_blas_chemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_matrix_complex_float * B,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8001b90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b94:	4614      	mov	r4, r2
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
 8001b96:	6812      	ldr	r2, [r2, #0]
  const size_t NA = A->size2;
 8001b98:	6867      	ldr	r7, [r4, #4]
{
 8001b9a:	b08e      	sub	sp, #56	; 0x38
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001b9c:	42ba      	cmp	r2, r7
{
 8001b9e:	9e14      	ldr	r6, [sp, #80]	; 0x50
 8001ba0:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
 8001ba4:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 8001ba8:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 8001bac:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  if (MA != NA)
 8001bb0:	d13d      	bne.n	8001c2e <gsl_blas_chemm+0x9e>
 8001bb2:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001bb4:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001bb6:	e9d6 3700 	ldrd	r3, r7, [r6]
  const size_t NB = B->size2;
 8001bba:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001bbe:	d012      	beq.n	8001be6 <gsl_blas_chemm+0x56>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001bc0:	288e      	cmp	r0, #142	; 0x8e
 8001bc2:	d105      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bc4:	4563      	cmp	r3, ip
 8001bc6:	d103      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bc8:	4297      	cmp	r7, r2
 8001bca:	d101      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bcc:	4577      	cmp	r7, lr
 8001bce:	d010      	beq.n	8001bf2 <gsl_blas_chemm+0x62>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001bd0:	491c      	ldr	r1, [pc, #112]	; (8001c44 <gsl_blas_chemm+0xb4>)
 8001bd2:	481d      	ldr	r0, [pc, #116]	; (8001c48 <gsl_blas_chemm+0xb8>)
 8001bd4:	2313      	movs	r3, #19
 8001bd6:	f240 622f 	movw	r2, #1583	; 0x62f
 8001bda:	f000 fe41 	bl	8002860 <gsl_error>
 8001bde:	2013      	movs	r0, #19
    }

}
 8001be0:	b00e      	add	sp, #56	; 0x38
 8001be2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d1f2      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bea:	4577      	cmp	r7, lr
 8001bec:	d1f0      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
 8001bee:	4563      	cmp	r3, ip
 8001bf0:	d1ee      	bne.n	8001bd0 <gsl_blas_chemm+0x40>
      cblas_chemm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001bf2:	e9d6 8e02 	ldrd	r8, lr, [r6, #8]
 8001bf6:	9700      	str	r7, [sp, #0]
 8001bf8:	f8cd 8020 	str.w	r8, [sp, #32]
 8001bfc:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001c00:	f8cd e01c 	str.w	lr, [sp, #28]
 8001c04:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001c08:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001c0c:	460a      	mov	r2, r1
 8001c0e:	4601      	mov	r1, r0
 8001c10:	a80c      	add	r0, sp, #48	; 0x30
 8001c12:	9001      	str	r0, [sp, #4]
 8001c14:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001c18:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001c1c:	f8cd c018 	str.w	ip, [sp, #24]
 8001c20:	2065      	movs	r0, #101	; 0x65
 8001c22:	f011 f953 	bl	8012ecc <cblas_chemm>
      return GSL_SUCCESS;
 8001c26:	2000      	movs	r0, #0
}
 8001c28:	b00e      	add	sp, #56	; 0x38
 8001c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001c2e:	4905      	ldr	r1, [pc, #20]	; (8001c44 <gsl_blas_chemm+0xb4>)
 8001c30:	4806      	ldr	r0, [pc, #24]	; (8001c4c <gsl_blas_chemm+0xbc>)
 8001c32:	2314      	movs	r3, #20
 8001c34:	f240 6221 	movw	r2, #1569	; 0x621
 8001c38:	f000 fe12 	bl	8002860 <gsl_error>
 8001c3c:	2014      	movs	r0, #20
}
 8001c3e:	b00e      	add	sp, #56	; 0x38
 8001c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001c44:	08030180 	.word	0x08030180
 8001c48:	08030188 	.word	0x08030188
 8001c4c:	080301b0 	.word	0x080301b0

08001c50 <gsl_blas_zhemm>:
int
gsl_blas_zhemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_matrix_complex * B, const gsl_complex beta,
                gsl_matrix_complex * C)
{
 8001c50:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;
 8001c52:	e9d2 7600 	ldrd	r7, r6, [r2]
{
 8001c56:	b093      	sub	sp, #76	; 0x4c
  const size_t MB = B->size1;
  const size_t NB = B->size2;

  if (MA != NA)
 8001c58:	42b7      	cmp	r7, r6
{
 8001c5a:	4614      	mov	r4, r2
 8001c5c:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 8001c60:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8001c64:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 8001c68:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
 8001c6c:	9a18      	ldr	r2, [sp, #96]	; 0x60
  if (MA != NA)
 8001c6e:	d13a      	bne.n	8001ce6 <gsl_blas_zhemm+0x96>
 8001c70:	461d      	mov	r5, r3
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001c72:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = C->size2;
 8001c74:	e9d2 3600 	ldrd	r3, r6, [r2]
  const size_t NB = B->size2;
 8001c78:	e9d5 ce00 	ldrd	ip, lr, [r5]
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001c7c:	d011      	beq.n	8001ca2 <gsl_blas_zhemm+0x52>
      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
 8001c7e:	288e      	cmp	r0, #142	; 0x8e
 8001c80:	d105      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001c82:	4563      	cmp	r3, ip
 8001c84:	d103      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001c86:	42be      	cmp	r6, r7
 8001c88:	d101      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001c8a:	4576      	cmp	r6, lr
 8001c8c:	d00f      	beq.n	8001cae <gsl_blas_zhemm+0x5e>
                   INT (C->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001c8e:	491b      	ldr	r1, [pc, #108]	; (8001cfc <gsl_blas_zhemm+0xac>)
 8001c90:	481b      	ldr	r0, [pc, #108]	; (8001d00 <gsl_blas_zhemm+0xb0>)
 8001c92:	2313      	movs	r3, #19
 8001c94:	f240 6252 	movw	r2, #1618	; 0x652
 8001c98:	f000 fde2 	bl	8002860 <gsl_error>
 8001c9c:	2013      	movs	r0, #19
    }
}
 8001c9e:	b013      	add	sp, #76	; 0x4c
 8001ca0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
 8001ca2:	42bb      	cmp	r3, r7
 8001ca4:	d1f3      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001ca6:	4576      	cmp	r6, lr
 8001ca8:	d1f1      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
 8001caa:	4563      	cmp	r3, ip
 8001cac:	d1ef      	bne.n	8001c8e <gsl_blas_zhemm+0x3e>
      cblas_zhemm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
 8001cae:	e9d2 7e02 	ldrd	r7, lr, [r2, #8]
 8001cb2:	9600      	str	r6, [sp, #0]
 8001cb4:	9708      	str	r7, [sp, #32]
 8001cb6:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8001cba:	f8cd e01c 	str.w	lr, [sp, #28]
 8001cbe:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001cc2:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8001cc6:	460a      	mov	r2, r1
 8001cc8:	4601      	mov	r1, r0
 8001cca:	a80e      	add	r0, sp, #56	; 0x38
 8001ccc:	9001      	str	r0, [sp, #4]
 8001cce:	e9cd 6704 	strd	r6, r7, [sp, #16]
 8001cd2:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8001cd6:	f8cd c018 	str.w	ip, [sp, #24]
 8001cda:	2065      	movs	r0, #101	; 0x65
 8001cdc:	f019 fdf0 	bl	801b8c0 <cblas_zhemm>
      return GSL_SUCCESS;
 8001ce0:	2000      	movs	r0, #0
}
 8001ce2:	b013      	add	sp, #76	; 0x4c
 8001ce4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 8001ce6:	4905      	ldr	r1, [pc, #20]	; (8001cfc <gsl_blas_zhemm+0xac>)
 8001ce8:	4806      	ldr	r0, [pc, #24]	; (8001d04 <gsl_blas_zhemm+0xb4>)
 8001cea:	2314      	movs	r3, #20
 8001cec:	f240 6244 	movw	r2, #1604	; 0x644
 8001cf0:	f000 fdb6 	bl	8002860 <gsl_error>
 8001cf4:	2014      	movs	r0, #20
}
 8001cf6:	b013      	add	sp, #76	; 0x4c
 8001cf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001cfa:	bf00      	nop
 8001cfc:	08030180 	.word	0x08030180
 8001d00:	08030188 	.word	0x08030188
 8001d04:	080301b0 	.word	0x080301b0

08001d08 <gsl_blas_ssyrk>:
/* SYRK */

int
gsl_blas_ssyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
                const gsl_matrix_float * A, float beta, gsl_matrix_float * C)
{
 8001d08:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d0a:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001d0c:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d10:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001d14:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d16:	d102      	bne.n	8001d1e <gsl_blas_ssyrk+0x16>
 8001d18:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d1a:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d1c:	4665      	mov	r5, ip

  if (M != N)
 8001d1e:	42bc      	cmp	r4, r7
 8001d20:	d11d      	bne.n	8001d5e <gsl_blas_ssyrk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001d22:	42ac      	cmp	r4, r5
 8001d24:	d111      	bne.n	8001d4a <gsl_blas_ssyrk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_ssyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001d26:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001d2a:	9600      	str	r6, [sp, #0]
 8001d2c:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001d30:	460a      	mov	r2, r1
 8001d32:	9301      	str	r3, [sp, #4]
 8001d34:	4601      	mov	r1, r0
 8001d36:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001d3a:	9504      	str	r5, [sp, #16]
 8001d3c:	4623      	mov	r3, r4
 8001d3e:	2065      	movs	r0, #101	; 0x65
 8001d40:	f007 fe5a 	bl	80099f8 <cblas_ssyrk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001d44:	2000      	movs	r0, #0
}
 8001d46:	b007      	add	sp, #28
 8001d48:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001d4a:	490a      	ldr	r1, [pc, #40]	; (8001d74 <gsl_blas_ssyrk+0x6c>)
 8001d4c:	480a      	ldr	r0, [pc, #40]	; (8001d78 <gsl_blas_ssyrk+0x70>)
 8001d4e:	2313      	movs	r3, #19
 8001d50:	f240 6267 	movw	r2, #1639	; 0x667
 8001d54:	f000 fd84 	bl	8002860 <gsl_error>
 8001d58:	2013      	movs	r0, #19
}
 8001d5a:	b007      	add	sp, #28
 8001d5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001d5e:	4905      	ldr	r1, [pc, #20]	; (8001d74 <gsl_blas_ssyrk+0x6c>)
 8001d60:	4806      	ldr	r0, [pc, #24]	; (8001d7c <gsl_blas_ssyrk+0x74>)
 8001d62:	2314      	movs	r3, #20
 8001d64:	f240 6263 	movw	r2, #1635	; 0x663
 8001d68:	f000 fd7a 	bl	8002860 <gsl_error>
 8001d6c:	2014      	movs	r0, #20
}
 8001d6e:	b007      	add	sp, #28
 8001d70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d72:	bf00      	nop
 8001d74:	08030180 	.word	0x08030180
 8001d78:	08030188 	.word	0x08030188
 8001d7c:	080301c8 	.word	0x080301c8

08001d80 <gsl_blas_dsyrk>:


int
gsl_blas_dsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
                const gsl_matrix * A, double beta, gsl_matrix * C)
{
 8001d80:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d82:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001d84:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d88:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001d8c:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d8e:	d102      	bne.n	8001d96 <gsl_blas_dsyrk+0x16>
 8001d90:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001d92:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001d94:	4665      	mov	r5, ip

  if (M != N)
 8001d96:	42bc      	cmp	r4, r7
 8001d98:	d11d      	bne.n	8001dd6 <gsl_blas_dsyrk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001d9a:	42ac      	cmp	r4, r5
 8001d9c:	d111      	bne.n	8001dc2 <gsl_blas_dsyrk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_dsyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001d9e:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001da2:	9600      	str	r6, [sp, #0]
 8001da4:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001da8:	460a      	mov	r2, r1
 8001daa:	9301      	str	r3, [sp, #4]
 8001dac:	4601      	mov	r1, r0
 8001dae:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001db2:	9504      	str	r5, [sp, #16]
 8001db4:	4623      	mov	r3, r4
 8001db6:	2065      	movs	r0, #101	; 0x65
 8001db8:	f00d f8b6 	bl	800ef28 <cblas_dsyrk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001dbc:	2000      	movs	r0, #0

}
 8001dbe:	b007      	add	sp, #28
 8001dc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001dc2:	490a      	ldr	r1, [pc, #40]	; (8001dec <gsl_blas_dsyrk+0x6c>)
 8001dc4:	480a      	ldr	r0, [pc, #40]	; (8001df0 <gsl_blas_dsyrk+0x70>)
 8001dc6:	2313      	movs	r3, #19
 8001dc8:	f240 627f 	movw	r2, #1663	; 0x67f
 8001dcc:	f000 fd48 	bl	8002860 <gsl_error>
 8001dd0:	2013      	movs	r0, #19
}
 8001dd2:	b007      	add	sp, #28
 8001dd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001dd6:	4905      	ldr	r1, [pc, #20]	; (8001dec <gsl_blas_dsyrk+0x6c>)
 8001dd8:	4806      	ldr	r0, [pc, #24]	; (8001df4 <gsl_blas_dsyrk+0x74>)
 8001dda:	2314      	movs	r3, #20
 8001ddc:	f240 627b 	movw	r2, #1659	; 0x67b
 8001de0:	f000 fd3e 	bl	8002860 <gsl_error>
 8001de4:	2014      	movs	r0, #20
}
 8001de6:	b007      	add	sp, #28
 8001de8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001dea:	bf00      	nop
 8001dec:	08030180 	.word	0x08030180
 8001df0:	08030188 	.word	0x08030188
 8001df4:	080301c8 	.word	0x080301c8

08001df8 <gsl_blas_csyrk>:
int
gsl_blas_csyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8001df8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001dfa:	4614      	mov	r4, r2
 8001dfc:	460a      	mov	r2, r1
 8001dfe:	b08d      	sub	sp, #52	; 0x34
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e00:	2a6f      	cmp	r2, #111	; 0x6f
{
 8001e02:	4601      	mov	r1, r0
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001e04:	e9d4 6500 	ldrd	r6, r5, [r4]
  const size_t N = C->size2;
 8001e08:	e9d3 0700 	ldrd	r0, r7, [r3]
{
 8001e0c:	ed8d 0a0a 	vstr	s0, [sp, #40]	; 0x28
 8001e10:	edcd 0a0b 	vstr	s1, [sp, #44]	; 0x2c
 8001e14:	ed8d 1a08 	vstr	s2, [sp, #32]
 8001e18:	edcd 1a09 	vstr	s3, [sp, #36]	; 0x24
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e1c:	d102      	bne.n	8001e24 <gsl_blas_csyrk+0x2c>
 8001e1e:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001e20:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e22:	4665      	mov	r5, ip

  if (M != N)
 8001e24:	42b8      	cmp	r0, r7
 8001e26:	d11f      	bne.n	8001e68 <gsl_blas_csyrk+0x70>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001e28:	42a8      	cmp	r0, r5
 8001e2a:	d113      	bne.n	8001e54 <gsl_blas_csyrk+0x5c>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_csyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K),
 8001e2c:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001e30:	9600      	str	r6, [sp, #0]
 8001e32:	9506      	str	r5, [sp, #24]
 8001e34:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001e38:	4603      	mov	r3, r0
 8001e3a:	ae08      	add	r6, sp, #32
 8001e3c:	a80a      	add	r0, sp, #40	; 0x28
 8001e3e:	e9cd 0401 	strd	r0, r4, [sp, #4]
 8001e42:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8001e46:	9705      	str	r7, [sp, #20]
 8001e48:	2065      	movs	r0, #101	; 0x65
 8001e4a:	f014 fb3b 	bl	80164c4 <cblas_csyrk>
               GSL_COMPLEX_P (&alpha), A->data, INT (A->tda),
               GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001e4e:	2000      	movs	r0, #0
}
 8001e50:	b00d      	add	sp, #52	; 0x34
 8001e52:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001e54:	4909      	ldr	r1, [pc, #36]	; (8001e7c <gsl_blas_csyrk+0x84>)
 8001e56:	480a      	ldr	r0, [pc, #40]	; (8001e80 <gsl_blas_csyrk+0x88>)
 8001e58:	2313      	movs	r3, #19
 8001e5a:	f240 629a 	movw	r2, #1690	; 0x69a
 8001e5e:	f000 fcff 	bl	8002860 <gsl_error>
 8001e62:	2013      	movs	r0, #19
}
 8001e64:	b00d      	add	sp, #52	; 0x34
 8001e66:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001e68:	4904      	ldr	r1, [pc, #16]	; (8001e7c <gsl_blas_csyrk+0x84>)
 8001e6a:	4806      	ldr	r0, [pc, #24]	; (8001e84 <gsl_blas_csyrk+0x8c>)
 8001e6c:	2314      	movs	r3, #20
 8001e6e:	f240 6296 	movw	r2, #1686	; 0x696
 8001e72:	f000 fcf5 	bl	8002860 <gsl_error>
 8001e76:	2014      	movs	r0, #20
}
 8001e78:	b00d      	add	sp, #52	; 0x34
 8001e7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001e7c:	08030180 	.word	0x08030180
 8001e80:	08030188 	.word	0x08030188
 8001e84:	080301c8 	.word	0x080301c8

08001e88 <gsl_blas_zsyrk>:

int
gsl_blas_zsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                const gsl_complex beta, gsl_matrix_complex * C)
{
 8001e88:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e8a:	4614      	mov	r4, r2
 8001e8c:	460a      	mov	r2, r1
 8001e8e:	b091      	sub	sp, #68	; 0x44
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001e90:	2a6f      	cmp	r2, #111	; 0x6f
{
 8001e92:	4601      	mov	r1, r0
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001e94:	e9d4 6500 	ldrd	r6, r5, [r4]
  const size_t N = C->size2;
 8001e98:	e9d3 0700 	ldrd	r0, r7, [r3]
{
 8001e9c:	ed8d 0b0c 	vstr	d0, [sp, #48]	; 0x30
 8001ea0:	ed8d 1b0e 	vstr	d1, [sp, #56]	; 0x38
 8001ea4:	ed8d 2b08 	vstr	d2, [sp, #32]
 8001ea8:	ed8d 3b0a 	vstr	d3, [sp, #40]	; 0x28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001eac:	d102      	bne.n	8001eb4 <gsl_blas_zsyrk+0x2c>
 8001eae:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001eb0:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001eb2:	4665      	mov	r5, ip

  if (M != N)
 8001eb4:	42b8      	cmp	r0, r7
 8001eb6:	d11f      	bne.n	8001ef8 <gsl_blas_zsyrk+0x70>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001eb8:	42a8      	cmp	r0, r5
 8001eba:	d113      	bne.n	8001ee4 <gsl_blas_zsyrk+0x5c>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_zsyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K),
 8001ebc:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001ec0:	9600      	str	r6, [sp, #0]
 8001ec2:	9506      	str	r5, [sp, #24]
 8001ec4:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 8001ec8:	4603      	mov	r3, r0
 8001eca:	ae08      	add	r6, sp, #32
 8001ecc:	a80c      	add	r0, sp, #48	; 0x30
 8001ece:	e9cd 0401 	strd	r0, r4, [sp, #4]
 8001ed2:	e9cd 5603 	strd	r5, r6, [sp, #12]
 8001ed6:	9705      	str	r7, [sp, #20]
 8001ed8:	2065      	movs	r0, #101	; 0x65
 8001eda:	f020 f899 	bl	8022010 <cblas_zsyrk>
               GSL_COMPLEX_P (&alpha), A->data, INT (A->tda),
               GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001ede:	2000      	movs	r0, #0
}
 8001ee0:	b011      	add	sp, #68	; 0x44
 8001ee2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001ee4:	4909      	ldr	r1, [pc, #36]	; (8001f0c <gsl_blas_zsyrk+0x84>)
 8001ee6:	480a      	ldr	r0, [pc, #40]	; (8001f10 <gsl_blas_zsyrk+0x88>)
 8001ee8:	2313      	movs	r3, #19
 8001eea:	f240 62b4 	movw	r2, #1716	; 0x6b4
 8001eee:	f000 fcb7 	bl	8002860 <gsl_error>
 8001ef2:	2013      	movs	r0, #19
}
 8001ef4:	b011      	add	sp, #68	; 0x44
 8001ef6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001ef8:	4904      	ldr	r1, [pc, #16]	; (8001f0c <gsl_blas_zsyrk+0x84>)
 8001efa:	4806      	ldr	r0, [pc, #24]	; (8001f14 <gsl_blas_zsyrk+0x8c>)
 8001efc:	2314      	movs	r3, #20
 8001efe:	f44f 62d6 	mov.w	r2, #1712	; 0x6b0
 8001f02:	f000 fcad 	bl	8002860 <gsl_error>
 8001f06:	2014      	movs	r0, #20
}
 8001f08:	b011      	add	sp, #68	; 0x44
 8001f0a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f0c:	08030180 	.word	0x08030180
 8001f10:	08030188 	.word	0x08030188
 8001f14:	080301c8 	.word	0x080301c8

08001f18 <gsl_blas_cherk>:

int
gsl_blas_cherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
                const gsl_matrix_complex_float * A, float beta,
                gsl_matrix_complex_float * C)
{
 8001f18:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f1a:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001f1c:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001f20:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001f24:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f26:	d102      	bne.n	8001f2e <gsl_blas_cherk+0x16>
 8001f28:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001f2a:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f2c:	4665      	mov	r5, ip

  if (M != N)
 8001f2e:	42bc      	cmp	r4, r7
 8001f30:	d11d      	bne.n	8001f6e <gsl_blas_cherk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001f32:	42ac      	cmp	r4, r5
 8001f34:	d111      	bne.n	8001f5a <gsl_blas_cherk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_cherk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001f36:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001f3a:	9600      	str	r6, [sp, #0]
 8001f3c:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001f40:	460a      	mov	r2, r1
 8001f42:	9301      	str	r3, [sp, #4]
 8001f44:	4601      	mov	r1, r0
 8001f46:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001f4a:	9504      	str	r5, [sp, #16]
 8001f4c:	4623      	mov	r3, r4
 8001f4e:	2065      	movs	r0, #101	; 0x65
 8001f50:	f012 fea6 	bl	8014ca0 <cblas_cherk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001f54:	2000      	movs	r0, #0
}
 8001f56:	b007      	add	sp, #28
 8001f58:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001f5a:	490a      	ldr	r1, [pc, #40]	; (8001f84 <gsl_blas_cherk+0x6c>)
 8001f5c:	480a      	ldr	r0, [pc, #40]	; (8001f88 <gsl_blas_cherk+0x70>)
 8001f5e:	2313      	movs	r3, #19
 8001f60:	f240 62cf 	movw	r2, #1743	; 0x6cf
 8001f64:	f000 fc7c 	bl	8002860 <gsl_error>
 8001f68:	2013      	movs	r0, #19
}
 8001f6a:	b007      	add	sp, #28
 8001f6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001f6e:	4905      	ldr	r1, [pc, #20]	; (8001f84 <gsl_blas_cherk+0x6c>)
 8001f70:	4806      	ldr	r0, [pc, #24]	; (8001f8c <gsl_blas_cherk+0x74>)
 8001f72:	2314      	movs	r3, #20
 8001f74:	f240 62cb 	movw	r2, #1739	; 0x6cb
 8001f78:	f000 fc72 	bl	8002860 <gsl_error>
 8001f7c:	2014      	movs	r0, #20
}
 8001f7e:	b007      	add	sp, #28
 8001f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f82:	bf00      	nop
 8001f84:	08030180 	.word	0x08030180
 8001f88:	08030188 	.word	0x08030188
 8001f8c:	080301c8 	.word	0x080301c8

08001f90 <gsl_blas_zherk>:

int
gsl_blas_zherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
                const gsl_matrix_complex * A, double beta,
                gsl_matrix_complex * C)
{
 8001f90:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f92:	296f      	cmp	r1, #111	; 0x6f
  const size_t N = C->size2;
 8001f94:	e9d3 4700 	ldrd	r4, r7, [r3]
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001f98:	e9d2 6500 	ldrd	r6, r5, [r2]
{
 8001f9c:	b087      	sub	sp, #28
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001f9e:	d102      	bne.n	8001fa6 <gsl_blas_zherk+0x16>
 8001fa0:	46b4      	mov	ip, r6
  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8001fa2:	462e      	mov	r6, r5
  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8001fa4:	4665      	mov	r5, ip

  if (M != N)
 8001fa6:	42bc      	cmp	r4, r7
 8001fa8:	d11d      	bne.n	8001fe6 <gsl_blas_zherk+0x56>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != J)
 8001faa:	42ac      	cmp	r4, r5
 8001fac:	d111      	bne.n	8001fd2 <gsl_blas_zherk+0x42>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
    }

  cblas_zherk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
 8001fae:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8001fb2:	9600      	str	r6, [sp, #0]
 8001fb4:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 8001fb8:	460a      	mov	r2, r1
 8001fba:	9301      	str	r3, [sp, #4]
 8001fbc:	4601      	mov	r1, r0
 8001fbe:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8001fc2:	9504      	str	r5, [sp, #16]
 8001fc4:	4623      	mov	r3, r4
 8001fc6:	2065      	movs	r0, #101	; 0x65
 8001fc8:	f01d f99a 	bl	801f300 <cblas_zherk>
               INT (A->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;
 8001fcc:	2000      	movs	r0, #0
}
 8001fce:	b007      	add	sp, #28
 8001fd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8001fd2:	490a      	ldr	r1, [pc, #40]	; (8001ffc <gsl_blas_zherk+0x6c>)
 8001fd4:	480a      	ldr	r0, [pc, #40]	; (8002000 <gsl_blas_zherk+0x70>)
 8001fd6:	2313      	movs	r3, #19
 8001fd8:	f44f 62dd 	mov.w	r2, #1768	; 0x6e8
 8001fdc:	f000 fc40 	bl	8002860 <gsl_error>
 8001fe0:	2013      	movs	r0, #19
}
 8001fe2:	b007      	add	sp, #28
 8001fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8001fe6:	4905      	ldr	r1, [pc, #20]	; (8001ffc <gsl_blas_zherk+0x6c>)
 8001fe8:	4806      	ldr	r0, [pc, #24]	; (8002004 <gsl_blas_zherk+0x74>)
 8001fea:	2314      	movs	r3, #20
 8001fec:	f240 62e4 	movw	r2, #1764	; 0x6e4
 8001ff0:	f000 fc36 	bl	8002860 <gsl_error>
 8001ff4:	2014      	movs	r0, #20
}
 8001ff6:	b007      	add	sp, #28
 8001ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001ffa:	bf00      	nop
 8001ffc:	08030180 	.word	0x08030180
 8002000:	08030188 	.word	0x08030188
 8002004:	080301c8 	.word	0x080301c8

08002008 <gsl_blas_ssyr2k>:

int
gsl_blas_ssyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
                 const gsl_matrix_float * A, const gsl_matrix_float * B,
                 float beta, gsl_matrix_float * C)
{
 8002008:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800200c:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800200e:	296f      	cmp	r1, #111	; 0x6f
{
 8002010:	9e10      	ldr	r6, [sp, #64]	; 0x40
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002012:	e9d3 ec00 	ldrd	lr, ip, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002016:	e9d2 8700 	ldrd	r8, r7, [r2]
  const size_t N = C->size2;
 800201a:	e9d6 5400 	ldrd	r5, r4, [r6]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800201e:	d105      	bne.n	800202c <gsl_blas_ssyr2k+0x24>
 8002020:	46ba      	mov	sl, r7
 8002022:	46f1      	mov	r9, lr
 8002024:	4647      	mov	r7, r8
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002026:	46e6      	mov	lr, ip
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8002028:	46d0      	mov	r8, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 800202a:	46cc      	mov	ip, r9

  if (M != N)
 800202c:	42a5      	cmp	r5, r4
 800202e:	d110      	bne.n	8002052 <gsl_blas_ssyr2k+0x4a>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 8002030:	42bd      	cmp	r5, r7
 8002032:	d103      	bne.n	800203c <gsl_blas_ssyr2k+0x34>
 8002034:	4565      	cmp	r5, ip
 8002036:	d101      	bne.n	800203c <gsl_blas_ssyr2k+0x34>
 8002038:	45c6      	cmp	lr, r8
 800203a:	d015      	beq.n	8002068 <gsl_blas_ssyr2k+0x60>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800203c:	4917      	ldr	r1, [pc, #92]	; (800209c <gsl_blas_ssyr2k+0x94>)
 800203e:	4818      	ldr	r0, [pc, #96]	; (80020a0 <gsl_blas_ssyr2k+0x98>)
 8002040:	2313      	movs	r3, #19
 8002042:	f240 7204 	movw	r2, #1796	; 0x704
 8002046:	f000 fc0b 	bl	8002860 <gsl_error>
 800204a:	2013      	movs	r0, #19

  cblas_ssyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
                INT (A->tda), B->data, INT (B->tda), beta, C->data,
                INT (C->tda));
  return GSL_SUCCESS;
}
 800204c:	b008      	add	sp, #32
 800204e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8002052:	4912      	ldr	r1, [pc, #72]	; (800209c <gsl_blas_ssyr2k+0x94>)
 8002054:	4813      	ldr	r0, [pc, #76]	; (80020a4 <gsl_blas_ssyr2k+0x9c>)
 8002056:	2314      	movs	r3, #20
 8002058:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 800205c:	f000 fc00 	bl	8002860 <gsl_error>
 8002060:	2014      	movs	r0, #20
}
 8002062:	b008      	add	sp, #32
 8002064:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_ssyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
 8002068:	e9d6 4802 	ldrd	r4, r8, [r6, #8]
 800206c:	f8cd e000 	str.w	lr, [sp]
 8002070:	e9d3 c702 	ldrd	ip, r7, [r3, #8]
 8002074:	9406      	str	r4, [sp, #24]
 8002076:	e9d2 6402 	ldrd	r6, r4, [r2, #8]
 800207a:	462b      	mov	r3, r5
 800207c:	460a      	mov	r2, r1
 800207e:	e9cd 7c03 	strd	r7, ip, [sp, #12]
 8002082:	4601      	mov	r1, r0
 8002084:	e9cd 4601 	strd	r4, r6, [sp, #4]
 8002088:	f8cd 8014 	str.w	r8, [sp, #20]
 800208c:	2065      	movs	r0, #101	; 0x65
 800208e:	f007 f9a7 	bl	80093e0 <cblas_ssyr2k>
  return GSL_SUCCESS;
 8002092:	2000      	movs	r0, #0
}
 8002094:	b008      	add	sp, #32
 8002096:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800209a:	bf00      	nop
 800209c:	08030180 	.word	0x08030180
 80020a0:	08030188 	.word	0x08030188
 80020a4:	080301c8 	.word	0x080301c8

080020a8 <gsl_blas_dsyr2k>:

int
gsl_blas_dsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
                 const gsl_matrix * A, const gsl_matrix * B, double beta,
                 gsl_matrix * C)
{
 80020a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80020ac:	b088      	sub	sp, #32
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80020ae:	296f      	cmp	r1, #111	; 0x6f
{
 80020b0:	9d10      	ldr	r5, [sp, #64]	; 0x40
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80020b2:	e9d3 c700 	ldrd	ip, r7, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80020b6:	e9d2 e600 	ldrd	lr, r6, [r2]
  const size_t N = C->size2;
 80020ba:	e9d5 4800 	ldrd	r4, r8, [r5]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80020be:	d105      	bne.n	80020cc <gsl_blas_dsyr2k+0x24>
 80020c0:	46b2      	mov	sl, r6
 80020c2:	46e1      	mov	r9, ip
 80020c4:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80020c6:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 80020c8:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 80020ca:	464f      	mov	r7, r9

  if (M != N)
 80020cc:	4544      	cmp	r4, r8
 80020ce:	d110      	bne.n	80020f2 <gsl_blas_dsyr2k+0x4a>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 80020d0:	42b4      	cmp	r4, r6
 80020d2:	d103      	bne.n	80020dc <gsl_blas_dsyr2k+0x34>
 80020d4:	42bc      	cmp	r4, r7
 80020d6:	d101      	bne.n	80020dc <gsl_blas_dsyr2k+0x34>
 80020d8:	45f4      	cmp	ip, lr
 80020da:	d015      	beq.n	8002108 <gsl_blas_dsyr2k+0x60>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80020dc:	4917      	ldr	r1, [pc, #92]	; (800213c <gsl_blas_dsyr2k+0x94>)
 80020de:	4818      	ldr	r0, [pc, #96]	; (8002140 <gsl_blas_dsyr2k+0x98>)
 80020e0:	2313      	movs	r3, #19
 80020e2:	f44f 62e4 	mov.w	r2, #1824	; 0x720
 80020e6:	f000 fbbb 	bl	8002860 <gsl_error>
 80020ea:	2013      	movs	r0, #19

  cblas_dsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
                INT (A->tda), B->data, INT (B->tda), beta, C->data,
                INT (C->tda));
  return GSL_SUCCESS;
}
 80020ec:	b008      	add	sp, #32
 80020ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 80020f2:	4912      	ldr	r1, [pc, #72]	; (800213c <gsl_blas_dsyr2k+0x94>)
 80020f4:	4813      	ldr	r0, [pc, #76]	; (8002144 <gsl_blas_dsyr2k+0x9c>)
 80020f6:	2314      	movs	r3, #20
 80020f8:	f240 721c 	movw	r2, #1820	; 0x71c
 80020fc:	f000 fbb0 	bl	8002860 <gsl_error>
 8002100:	2014      	movs	r0, #20
}
 8002102:	b008      	add	sp, #32
 8002104:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_dsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
 8002108:	e9d5 6e02 	ldrd	r6, lr, [r5, #8]
 800210c:	f8cd c000 	str.w	ip, [sp]
 8002110:	e9d3 5702 	ldrd	r5, r7, [r3, #8]
 8002114:	9606      	str	r6, [sp, #24]
 8002116:	e9d2 6302 	ldrd	r6, r3, [r2, #8]
 800211a:	460a      	mov	r2, r1
 800211c:	9301      	str	r3, [sp, #4]
 800211e:	4601      	mov	r1, r0
 8002120:	e9cd 7503 	strd	r7, r5, [sp, #12]
 8002124:	f8cd e014 	str.w	lr, [sp, #20]
 8002128:	4623      	mov	r3, r4
 800212a:	9602      	str	r6, [sp, #8]
 800212c:	2065      	movs	r0, #101	; 0x65
 800212e:	f00c faa7 	bl	800e680 <cblas_dsyr2k>
  return GSL_SUCCESS;
 8002132:	2000      	movs	r0, #0
}
 8002134:	b008      	add	sp, #32
 8002136:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800213a:	bf00      	nop
 800213c:	08030180 	.word	0x08030180
 8002140:	08030188 	.word	0x08030188
 8002144:	080301c8 	.word	0x080301c8

08002148 <gsl_blas_csyr2k>:
gsl_blas_csyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex_float alpha,
                 const gsl_matrix_complex_float * A,
                 const gsl_matrix_complex_float * B,
                 const gsl_complex_float beta, gsl_matrix_complex_float * C)
{
 8002148:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800214c:	b08e      	sub	sp, #56	; 0x38
 800214e:	4614      	mov	r4, r2
 8002150:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8002152:	ed8d 0a0c 	vstr	s0, [sp, #48]	; 0x30
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002156:	296f      	cmp	r1, #111	; 0x6f
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002158:	e9d3 c700 	ldrd	ip, r7, [r3]
{
 800215c:	461d      	mov	r5, r3
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800215e:	e9d4 e600 	ldrd	lr, r6, [r4]
  const size_t N = C->size2;
 8002162:	e9d2 3800 	ldrd	r3, r8, [r2]
{
 8002166:	edcd 0a0d 	vstr	s1, [sp, #52]	; 0x34
 800216a:	ed8d 1a0a 	vstr	s2, [sp, #40]	; 0x28
 800216e:	edcd 1a0b 	vstr	s3, [sp, #44]	; 0x2c
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002172:	d105      	bne.n	8002180 <gsl_blas_csyr2k+0x38>
 8002174:	46b2      	mov	sl, r6
 8002176:	46e1      	mov	r9, ip
 8002178:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 800217a:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 800217c:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 800217e:	464f      	mov	r7, r9

  if (M != N)
 8002180:	4543      	cmp	r3, r8
 8002182:	d110      	bne.n	80021a6 <gsl_blas_csyr2k+0x5e>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 8002184:	42b3      	cmp	r3, r6
 8002186:	d103      	bne.n	8002190 <gsl_blas_csyr2k+0x48>
 8002188:	42bb      	cmp	r3, r7
 800218a:	d101      	bne.n	8002190 <gsl_blas_csyr2k+0x48>
 800218c:	45f4      	cmp	ip, lr
 800218e:	d015      	beq.n	80021bc <gsl_blas_csyr2k+0x74>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8002190:	4919      	ldr	r1, [pc, #100]	; (80021f8 <gsl_blas_csyr2k+0xb0>)
 8002192:	481a      	ldr	r0, [pc, #104]	; (80021fc <gsl_blas_csyr2k+0xb4>)
 8002194:	2313      	movs	r3, #19
 8002196:	f240 723e 	movw	r2, #1854	; 0x73e
 800219a:	f000 fb61 	bl	8002860 <gsl_error>
 800219e:	2013      	movs	r0, #19

  cblas_csyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
}
 80021a0:	b00e      	add	sp, #56	; 0x38
 80021a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 80021a6:	4914      	ldr	r1, [pc, #80]	; (80021f8 <gsl_blas_csyr2k+0xb0>)
 80021a8:	4815      	ldr	r0, [pc, #84]	; (8002200 <gsl_blas_csyr2k+0xb8>)
 80021aa:	2314      	movs	r3, #20
 80021ac:	f240 723a 	movw	r2, #1850	; 0x73a
 80021b0:	f000 fb56 	bl	8002860 <gsl_error>
 80021b4:	2014      	movs	r0, #20
}
 80021b6:	b00e      	add	sp, #56	; 0x38
 80021b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_csyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 80021bc:	e9d2 6e02 	ldrd	r6, lr, [r2, #8]
 80021c0:	f8cd c000 	str.w	ip, [sp]
 80021c4:	9608      	str	r6, [sp, #32]
 80021c6:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 80021ca:	f8cd e01c 	str.w	lr, [sp, #28]
 80021ce:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 80021d2:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 80021d6:	460a      	mov	r2, r1
 80021d8:	4601      	mov	r1, r0
 80021da:	a80c      	add	r0, sp, #48	; 0x30
 80021dc:	9001      	str	r0, [sp, #4]
 80021de:	e9cd 6704 	strd	r6, r7, [sp, #16]
 80021e2:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80021e6:	f8cd c018 	str.w	ip, [sp, #24]
 80021ea:	2065      	movs	r0, #101	; 0x65
 80021ec:	f013 fdd2 	bl	8015d94 <cblas_csyr2k>
  return GSL_SUCCESS;
 80021f0:	2000      	movs	r0, #0
}
 80021f2:	b00e      	add	sp, #56	; 0x38
 80021f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80021f8:	08030180 	.word	0x08030180
 80021fc:	08030188 	.word	0x08030188
 8002200:	080301c8 	.word	0x080301c8

08002204 <gsl_blas_zsyr2k>:
int
gsl_blas_zsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex alpha, const gsl_matrix_complex * A,
                 const gsl_matrix_complex * B, const gsl_complex beta,
                 gsl_matrix_complex * C)
{
 8002204:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002208:	b092      	sub	sp, #72	; 0x48
 800220a:	4614      	mov	r4, r2
 800220c:	9a1a      	ldr	r2, [sp, #104]	; 0x68
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800220e:	296f      	cmp	r1, #111	; 0x6f
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002210:	e9d3 c700 	ldrd	ip, r7, [r3]
{
 8002214:	461d      	mov	r5, r3
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002216:	e9d4 e600 	ldrd	lr, r6, [r4]
{
 800221a:	ed8d 0b0e 	vstr	d0, [sp, #56]	; 0x38
 800221e:	ed8d 1b10 	vstr	d1, [sp, #64]	; 0x40
 8002222:	ed8d 2b0a 	vstr	d2, [sp, #40]	; 0x28
 8002226:	ed8d 3b0c 	vstr	d3, [sp, #48]	; 0x30
  const size_t N = C->size2;
 800222a:	e9d2 3800 	ldrd	r3, r8, [r2]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800222e:	d105      	bne.n	800223c <gsl_blas_zsyr2k+0x38>
 8002230:	46b2      	mov	sl, r6
 8002232:	46e1      	mov	r9, ip
 8002234:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002236:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8002238:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 800223a:	464f      	mov	r7, r9

  if (M != N)
 800223c:	4543      	cmp	r3, r8
 800223e:	d110      	bne.n	8002262 <gsl_blas_zsyr2k+0x5e>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 8002240:	42b3      	cmp	r3, r6
 8002242:	d103      	bne.n	800224c <gsl_blas_zsyr2k+0x48>
 8002244:	42bb      	cmp	r3, r7
 8002246:	d101      	bne.n	800224c <gsl_blas_zsyr2k+0x48>
 8002248:	45f4      	cmp	ip, lr
 800224a:	d015      	beq.n	8002278 <gsl_blas_zsyr2k+0x74>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800224c:	4919      	ldr	r1, [pc, #100]	; (80022b4 <gsl_blas_zsyr2k+0xb0>)
 800224e:	481a      	ldr	r0, [pc, #104]	; (80022b8 <gsl_blas_zsyr2k+0xb4>)
 8002250:	2313      	movs	r3, #19
 8002252:	f240 725c 	movw	r2, #1884	; 0x75c
 8002256:	f000 fb03 	bl	8002860 <gsl_error>
 800225a:	2013      	movs	r0, #19

  cblas_zsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
  return GSL_SUCCESS;
}
 800225c:	b012      	add	sp, #72	; 0x48
 800225e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8002262:	4914      	ldr	r1, [pc, #80]	; (80022b4 <gsl_blas_zsyr2k+0xb0>)
 8002264:	4815      	ldr	r0, [pc, #84]	; (80022bc <gsl_blas_zsyr2k+0xb8>)
 8002266:	2314      	movs	r3, #20
 8002268:	f44f 62eb 	mov.w	r2, #1880	; 0x758
 800226c:	f000 faf8 	bl	8002860 <gsl_error>
 8002270:	2014      	movs	r0, #20
}
 8002272:	b012      	add	sp, #72	; 0x48
 8002274:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_zsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 8002278:	e9d2 6e02 	ldrd	r6, lr, [r2, #8]
 800227c:	f8cd c000 	str.w	ip, [sp]
 8002280:	9608      	str	r6, [sp, #32]
 8002282:	e9d5 7602 	ldrd	r7, r6, [r5, #8]
 8002286:	f8cd e01c 	str.w	lr, [sp, #28]
 800228a:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 800228e:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 8002292:	460a      	mov	r2, r1
 8002294:	4601      	mov	r1, r0
 8002296:	a80e      	add	r0, sp, #56	; 0x38
 8002298:	9001      	str	r0, [sp, #4]
 800229a:	e9cd 6704 	strd	r6, r7, [sp, #16]
 800229e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 80022a2:	f8cd c018 	str.w	ip, [sp, #24]
 80022a6:	2065      	movs	r0, #101	; 0x65
 80022a8:	f01e ff6e 	bl	8021188 <cblas_zsyr2k>
  return GSL_SUCCESS;
 80022ac:	2000      	movs	r0, #0
}
 80022ae:	b012      	add	sp, #72	; 0x48
 80022b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80022b4:	08030180 	.word	0x08030180
 80022b8:	08030188 	.word	0x08030188
 80022bc:	080301c8 	.word	0x080301c8

080022c0 <gsl_blas_cher2k>:
gsl_blas_cher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex_float alpha,
                 const gsl_matrix_complex_float * A,
                 const gsl_matrix_complex_float * B, float beta,
                 gsl_matrix_complex_float * C)
{
 80022c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80022c4:	b08a      	sub	sp, #40	; 0x28
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80022c6:	296f      	cmp	r1, #111	; 0x6f
{
 80022c8:	9e12      	ldr	r6, [sp, #72]	; 0x48
 80022ca:	ed8d 0a08 	vstr	s0, [sp, #32]
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80022ce:	e9d3 ec00 	ldrd	lr, ip, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80022d2:	e9d2 8700 	ldrd	r8, r7, [r2]
  const size_t N = C->size2;
 80022d6:	e9d6 4500 	ldrd	r4, r5, [r6]
{
 80022da:	edcd 0a09 	vstr	s1, [sp, #36]	; 0x24
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 80022de:	d105      	bne.n	80022ec <gsl_blas_cher2k+0x2c>
 80022e0:	46ba      	mov	sl, r7
 80022e2:	46f1      	mov	r9, lr
 80022e4:	4647      	mov	r7, r8
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 80022e6:	46e6      	mov	lr, ip
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 80022e8:	46d0      	mov	r8, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 80022ea:	46cc      	mov	ip, r9

  if (M != N)
 80022ec:	42ac      	cmp	r4, r5
 80022ee:	d110      	bne.n	8002312 <gsl_blas_cher2k+0x52>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 80022f0:	42bc      	cmp	r4, r7
 80022f2:	d103      	bne.n	80022fc <gsl_blas_cher2k+0x3c>
 80022f4:	4564      	cmp	r4, ip
 80022f6:	d101      	bne.n	80022fc <gsl_blas_cher2k+0x3c>
 80022f8:	45c6      	cmp	lr, r8
 80022fa:	d015      	beq.n	8002328 <gsl_blas_cher2k+0x68>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80022fc:	4918      	ldr	r1, [pc, #96]	; (8002360 <gsl_blas_cher2k+0xa0>)
 80022fe:	4819      	ldr	r0, [pc, #100]	; (8002364 <gsl_blas_cher2k+0xa4>)
 8002300:	2313      	movs	r3, #19
 8002302:	f240 727b 	movw	r2, #1915	; 0x77b
 8002306:	f000 faab 	bl	8002860 <gsl_error>
 800230a:	2013      	movs	r0, #19
  cblas_cher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;

}
 800230c:	b00a      	add	sp, #40	; 0x28
 800230e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 8002312:	4913      	ldr	r1, [pc, #76]	; (8002360 <gsl_blas_cher2k+0xa0>)
 8002314:	4814      	ldr	r0, [pc, #80]	; (8002368 <gsl_blas_cher2k+0xa8>)
 8002316:	2314      	movs	r3, #20
 8002318:	f240 7277 	movw	r2, #1911	; 0x777
 800231c:	f000 faa0 	bl	8002860 <gsl_error>
 8002320:	2014      	movs	r0, #20
}
 8002322:	b00a      	add	sp, #40	; 0x28
 8002324:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_cher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 8002328:	e9d6 7502 	ldrd	r7, r5, [r6, #8]
 800232c:	f8cd e000 	str.w	lr, [sp]
 8002330:	e9d3 e602 	ldrd	lr, r6, [r3, #8]
 8002334:	9707      	str	r7, [sp, #28]
 8002336:	e9d2 7302 	ldrd	r7, r3, [r2, #8]
 800233a:	9506      	str	r5, [sp, #24]
 800233c:	ad08      	add	r5, sp, #32
 800233e:	9302      	str	r3, [sp, #8]
 8002340:	460a      	mov	r2, r1
 8002342:	e9cd 6e04 	strd	r6, lr, [sp, #16]
 8002346:	4601      	mov	r1, r0
 8002348:	eeb0 0a41 	vmov.f32	s0, s2
 800234c:	4623      	mov	r3, r4
 800234e:	9703      	str	r7, [sp, #12]
 8002350:	9501      	str	r5, [sp, #4]
 8002352:	2065      	movs	r0, #101	; 0x65
 8002354:	f012 f814 	bl	8014380 <cblas_cher2k>
  return GSL_SUCCESS;
 8002358:	2000      	movs	r0, #0
}
 800235a:	b00a      	add	sp, #40	; 0x28
 800235c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002360:	08030180 	.word	0x08030180
 8002364:	08030188 	.word	0x08030188
 8002368:	080301c8 	.word	0x080301c8

0800236c <gsl_blas_zher2k>:
int
gsl_blas_zher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
                 const gsl_complex alpha, const gsl_matrix_complex * A,
                 const gsl_matrix_complex * B, double beta,
                 gsl_matrix_complex * C)
{
 800236c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002370:	b08c      	sub	sp, #48	; 0x30
  const size_t M = C->size1;
  const size_t N = C->size2;
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 8002372:	296f      	cmp	r1, #111	; 0x6f
{
 8002374:	9d14      	ldr	r5, [sp, #80]	; 0x50
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002376:	e9d3 c700 	ldrd	ip, r7, [r3]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800237a:	e9d2 e600 	ldrd	lr, r6, [r2]
{
 800237e:	ed8d 0b08 	vstr	d0, [sp, #32]
 8002382:	ed8d 1b0a 	vstr	d1, [sp, #40]	; 0x28
  const size_t N = C->size2;
 8002386:	e9d5 4800 	ldrd	r4, r8, [r5]
  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
 800238a:	d105      	bne.n	8002398 <gsl_blas_zher2k+0x2c>
 800238c:	46b2      	mov	sl, r6
 800238e:	46e1      	mov	r9, ip
 8002390:	4676      	mov	r6, lr
  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
 8002392:	46bc      	mov	ip, r7
  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
 8002394:	46d6      	mov	lr, sl
  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
 8002396:	464f      	mov	r7, r9

  if (M != N)
 8002398:	4544      	cmp	r4, r8
 800239a:	d110      	bne.n	80023be <gsl_blas_zher2k+0x52>
    {
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
    }
  else if (N != MA || N != MB || NA != NB)
 800239c:	42b4      	cmp	r4, r6
 800239e:	d103      	bne.n	80023a8 <gsl_blas_zher2k+0x3c>
 80023a0:	42bc      	cmp	r4, r7
 80023a2:	d101      	bne.n	80023a8 <gsl_blas_zher2k+0x3c>
 80023a4:	45f4      	cmp	ip, lr
 80023a6:	d015      	beq.n	80023d4 <gsl_blas_zher2k+0x68>
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80023a8:	4919      	ldr	r1, [pc, #100]	; (8002410 <gsl_blas_zher2k+0xa4>)
 80023aa:	481a      	ldr	r0, [pc, #104]	; (8002414 <gsl_blas_zher2k+0xa8>)
 80023ac:	2313      	movs	r3, #19
 80023ae:	f240 7299 	movw	r2, #1945	; 0x799
 80023b2:	f000 fa55 	bl	8002860 <gsl_error>
 80023b6:	2013      	movs	r0, #19
  cblas_zher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
                INT (B->tda), beta, C->data, INT (C->tda));
  return GSL_SUCCESS;

}
 80023b8:	b00c      	add	sp, #48	; 0x30
 80023ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
 80023be:	4914      	ldr	r1, [pc, #80]	; (8002410 <gsl_blas_zher2k+0xa4>)
 80023c0:	4815      	ldr	r0, [pc, #84]	; (8002418 <gsl_blas_zher2k+0xac>)
 80023c2:	2314      	movs	r3, #20
 80023c4:	f240 7295 	movw	r2, #1941	; 0x795
 80023c8:	f000 fa4a 	bl	8002860 <gsl_error>
 80023cc:	2014      	movs	r0, #20
}
 80023ce:	b00c      	add	sp, #48	; 0x30
 80023d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  cblas_zher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
 80023d4:	e9d5 6502 	ldrd	r6, r5, [r5, #8]
 80023d8:	eeb0 0a42 	vmov.f32	s0, s4
 80023dc:	eef0 0a62 	vmov.f32	s1, s5
 80023e0:	f8cd c000 	str.w	ip, [sp]
 80023e4:	e9d3 ec02 	ldrd	lr, ip, [r3, #8]
 80023e8:	9607      	str	r6, [sp, #28]
 80023ea:	e9d2 7602 	ldrd	r7, r6, [r2, #8]
 80023ee:	9506      	str	r5, [sp, #24]
 80023f0:	ad08      	add	r5, sp, #32
 80023f2:	460a      	mov	r2, r1
 80023f4:	e9cd ce04 	strd	ip, lr, [sp, #16]
 80023f8:	4601      	mov	r1, r0
 80023fa:	e9cd 6702 	strd	r6, r7, [sp, #8]
 80023fe:	4623      	mov	r3, r4
 8002400:	9501      	str	r5, [sp, #4]
 8002402:	2065      	movs	r0, #101	; 0x65
 8002404:	f01b fe64 	bl	801e0d0 <cblas_zher2k>
  return GSL_SUCCESS;
 8002408:	2000      	movs	r0, #0
}
 800240a:	b00c      	add	sp, #48	; 0x30
 800240c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002410:	08030180 	.word	0x08030180
 8002414:	08030188 	.word	0x08030188
 8002418:	080301c8 	.word	0x080301c8

0800241c <gsl_blas_strmm>:

int
gsl_blas_strmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha,
                const gsl_matrix_float * A, gsl_matrix_float * B)
{
 800241c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800241e:	b089      	sub	sp, #36	; 0x24
 8002420:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002424:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002428:	42af      	cmp	r7, r5
 800242a:	d127      	bne.n	800247c <gsl_blas_strmm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800242c:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 800242e:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002432:	d00d      	beq.n	8002450 <gsl_blas_strmm+0x34>
 8002434:	288e      	cmp	r0, #142	; 0x8e
 8002436:	d101      	bne.n	800243c <gsl_blas_strmm+0x20>
 8002438:	42bd      	cmp	r5, r7
 800243a:	d00b      	beq.n	8002454 <gsl_blas_strmm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800243c:	4914      	ldr	r1, [pc, #80]	; (8002490 <gsl_blas_strmm+0x74>)
 800243e:	4815      	ldr	r0, [pc, #84]	; (8002494 <gsl_blas_strmm+0x78>)
 8002440:	2313      	movs	r3, #19
 8002442:	f240 72bc 	movw	r2, #1980	; 0x7bc
 8002446:	f000 fa0b 	bl	8002860 <gsl_error>
 800244a:	2013      	movs	r0, #19
    }
}
 800244c:	b009      	add	sp, #36	; 0x24
 800244e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002450:	45bc      	cmp	ip, r7
 8002452:	d1f3      	bne.n	800243c <gsl_blas_strmm+0x20>
      cblas_strmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 8002454:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002458:	9502      	str	r5, [sp, #8]
 800245a:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 800245e:	e9cd 3c00 	strd	r3, ip, [sp]
 8002462:	e9cd 6705 	strd	r6, r7, [sp, #20]
 8002466:	4613      	mov	r3, r2
 8002468:	e9cd 4503 	strd	r4, r5, [sp, #12]
 800246c:	460a      	mov	r2, r1
 800246e:	4601      	mov	r1, r0
 8002470:	2065      	movs	r0, #101	; 0x65
 8002472:	f007 fd47 	bl	8009f04 <cblas_strmm>
      return GSL_SUCCESS;
 8002476:	2000      	movs	r0, #0
}
 8002478:	b009      	add	sp, #36	; 0x24
 800247a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800247c:	4904      	ldr	r1, [pc, #16]	; (8002490 <gsl_blas_strmm+0x74>)
 800247e:	4806      	ldr	r0, [pc, #24]	; (8002498 <gsl_blas_strmm+0x7c>)
 8002480:	2314      	movs	r3, #20
 8002482:	f240 72b1 	movw	r2, #1969	; 0x7b1
 8002486:	f000 f9eb 	bl	8002860 <gsl_error>
 800248a:	2014      	movs	r0, #20
}
 800248c:	b009      	add	sp, #36	; 0x24
 800248e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002490:	08030180 	.word	0x08030180
 8002494:	08030188 	.word	0x08030188
 8002498:	080301b0 	.word	0x080301b0

0800249c <gsl_blas_dtrmm>:

int
gsl_blas_dtrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha,
                const gsl_matrix * A, gsl_matrix * B)
{
 800249c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800249e:	b089      	sub	sp, #36	; 0x24
 80024a0:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80024a4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80024a8:	42af      	cmp	r7, r5
 80024aa:	d127      	bne.n	80024fc <gsl_blas_dtrmm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80024ac:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80024ae:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80024b2:	d00d      	beq.n	80024d0 <gsl_blas_dtrmm+0x34>
 80024b4:	288e      	cmp	r0, #142	; 0x8e
 80024b6:	d101      	bne.n	80024bc <gsl_blas_dtrmm+0x20>
 80024b8:	42bd      	cmp	r5, r7
 80024ba:	d00b      	beq.n	80024d4 <gsl_blas_dtrmm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80024bc:	4914      	ldr	r1, [pc, #80]	; (8002510 <gsl_blas_dtrmm+0x74>)
 80024be:	4815      	ldr	r0, [pc, #84]	; (8002514 <gsl_blas_dtrmm+0x78>)
 80024c0:	2313      	movs	r3, #19
 80024c2:	f44f 62fb 	mov.w	r2, #2008	; 0x7d8
 80024c6:	f000 f9cb 	bl	8002860 <gsl_error>
 80024ca:	2013      	movs	r0, #19
    }
}
 80024cc:	b009      	add	sp, #36	; 0x24
 80024ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80024d0:	45bc      	cmp	ip, r7
 80024d2:	d1f3      	bne.n	80024bc <gsl_blas_dtrmm+0x20>
      cblas_dtrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 80024d4:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 80024d8:	9502      	str	r5, [sp, #8]
 80024da:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 80024de:	e9cd 3c00 	strd	r3, ip, [sp]
 80024e2:	e9cd 6705 	strd	r6, r7, [sp, #20]
 80024e6:	4613      	mov	r3, r2
 80024e8:	e9cd 4503 	strd	r4, r5, [sp, #12]
 80024ec:	460a      	mov	r2, r1
 80024ee:	4601      	mov	r1, r0
 80024f0:	2065      	movs	r0, #101	; 0x65
 80024f2:	f00d f8a5 	bl	800f640 <cblas_dtrmm>
      return GSL_SUCCESS;
 80024f6:	2000      	movs	r0, #0
}
 80024f8:	b009      	add	sp, #36	; 0x24
 80024fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 80024fc:	4904      	ldr	r1, [pc, #16]	; (8002510 <gsl_blas_dtrmm+0x74>)
 80024fe:	4806      	ldr	r0, [pc, #24]	; (8002518 <gsl_blas_dtrmm+0x7c>)
 8002500:	2314      	movs	r3, #20
 8002502:	f240 72cd 	movw	r2, #1997	; 0x7cd
 8002506:	f000 f9ab 	bl	8002860 <gsl_error>
 800250a:	2014      	movs	r0, #20
}
 800250c:	b009      	add	sp, #36	; 0x24
 800250e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002510:	08030180 	.word	0x08030180
 8002514:	08030188 	.word	0x08030188
 8002518:	080301b0 	.word	0x080301b0

0800251c <gsl_blas_ctrmm>:
gsl_blas_ctrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                gsl_matrix_complex_float * B)
{
 800251c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800251e:	b08b      	sub	sp, #44	; 0x2c
 8002520:	e9dd 4610 	ldrd	r4, r6, [sp, #64]	; 0x40
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002524:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002528:	42af      	cmp	r7, r5
{
 800252a:	ed8d 0a08 	vstr	s0, [sp, #32]
 800252e:	edcd 0a09 	vstr	s1, [sp, #36]	; 0x24
  if (MA != NA)
 8002532:	d12a      	bne.n	800258a <gsl_blas_ctrmm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002534:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 8002536:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800253a:	d00d      	beq.n	8002558 <gsl_blas_ctrmm+0x3c>
 800253c:	288e      	cmp	r0, #142	; 0x8e
 800253e:	d101      	bne.n	8002544 <gsl_blas_ctrmm+0x28>
 8002540:	42bd      	cmp	r5, r7
 8002542:	d00b      	beq.n	800255c <gsl_blas_ctrmm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8002544:	4916      	ldr	r1, [pc, #88]	; (80025a0 <gsl_blas_ctrmm+0x84>)
 8002546:	4817      	ldr	r0, [pc, #92]	; (80025a4 <gsl_blas_ctrmm+0x88>)
 8002548:	2313      	movs	r3, #19
 800254a:	f240 72f7 	movw	r2, #2039	; 0x7f7
 800254e:	f000 f987 	bl	8002860 <gsl_error>
 8002552:	2013      	movs	r0, #19
    }
}
 8002554:	b00b      	add	sp, #44	; 0x2c
 8002556:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002558:	45bc      	cmp	ip, r7
 800255a:	d1f3      	bne.n	8002544 <gsl_blas_ctrmm+0x28>
      cblas_ctrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 800255c:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002560:	9502      	str	r5, [sp, #8]
 8002562:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 8002566:	ad08      	add	r5, sp, #32
 8002568:	9300      	str	r3, [sp, #0]
 800256a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800256e:	4613      	mov	r3, r2
 8002570:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002574:	460a      	mov	r2, r1
 8002576:	f8cd c004 	str.w	ip, [sp, #4]
 800257a:	4601      	mov	r1, r0
 800257c:	9503      	str	r5, [sp, #12]
 800257e:	2065      	movs	r0, #101	; 0x65
 8002580:	f014 fa9a 	bl	8016ab8 <cblas_ctrmm>
      return GSL_SUCCESS;
 8002584:	2000      	movs	r0, #0
}
 8002586:	b00b      	add	sp, #44	; 0x2c
 8002588:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800258a:	4905      	ldr	r1, [pc, #20]	; (80025a0 <gsl_blas_ctrmm+0x84>)
 800258c:	4806      	ldr	r0, [pc, #24]	; (80025a8 <gsl_blas_ctrmm+0x8c>)
 800258e:	2314      	movs	r3, #20
 8002590:	f240 72eb 	movw	r2, #2027	; 0x7eb
 8002594:	f000 f964 	bl	8002860 <gsl_error>
 8002598:	2014      	movs	r0, #20
}
 800259a:	b00b      	add	sp, #44	; 0x2c
 800259c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800259e:	bf00      	nop
 80025a0:	08030180 	.word	0x08030180
 80025a4:	08030188 	.word	0x08030188
 80025a8:	080301b0 	.word	0x080301b0

080025ac <gsl_blas_ztrmm>:
int
gsl_blas_ztrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                gsl_matrix_complex * B)
{
 80025ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80025ae:	b08d      	sub	sp, #52	; 0x34
 80025b0:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80025b4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80025b8:	42af      	cmp	r7, r5
{
 80025ba:	ed8d 0b08 	vstr	d0, [sp, #32]
 80025be:	ed8d 1b0a 	vstr	d1, [sp, #40]	; 0x28
  if (MA != NA)
 80025c2:	d12a      	bne.n	800261a <gsl_blas_ztrmm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80025c4:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80025c6:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80025ca:	d00d      	beq.n	80025e8 <gsl_blas_ztrmm+0x3c>
 80025cc:	288e      	cmp	r0, #142	; 0x8e
 80025ce:	d101      	bne.n	80025d4 <gsl_blas_ztrmm+0x28>
 80025d0:	42bd      	cmp	r5, r7
 80025d2:	d00b      	beq.n	80025ec <gsl_blas_ztrmm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80025d4:	4916      	ldr	r1, [pc, #88]	; (8002630 <gsl_blas_ztrmm+0x84>)
 80025d6:	4817      	ldr	r0, [pc, #92]	; (8002634 <gsl_blas_ztrmm+0x88>)
 80025d8:	2313      	movs	r3, #19
 80025da:	f640 0215 	movw	r2, #2069	; 0x815
 80025de:	f000 f93f 	bl	8002860 <gsl_error>
 80025e2:	2013      	movs	r0, #19
    }
}
 80025e4:	b00d      	add	sp, #52	; 0x34
 80025e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80025e8:	45bc      	cmp	ip, r7
 80025ea:	d1f3      	bne.n	80025d4 <gsl_blas_ztrmm+0x28>
      cblas_ztrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 80025ec:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 80025f0:	9502      	str	r5, [sp, #8]
 80025f2:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 80025f6:	ad08      	add	r5, sp, #32
 80025f8:	9300      	str	r3, [sp, #0]
 80025fa:	e9cd 6706 	strd	r6, r7, [sp, #24]
 80025fe:	4613      	mov	r3, r2
 8002600:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002604:	460a      	mov	r2, r1
 8002606:	f8cd c004 	str.w	ip, [sp, #4]
 800260a:	4601      	mov	r1, r0
 800260c:	9503      	str	r5, [sp, #12]
 800260e:	2065      	movs	r0, #101	; 0x65
 8002610:	f020 fab2 	bl	8022b78 <cblas_ztrmm>
      return GSL_SUCCESS;
 8002614:	2000      	movs	r0, #0
}
 8002616:	b00d      	add	sp, #52	; 0x34
 8002618:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800261a:	4905      	ldr	r1, [pc, #20]	; (8002630 <gsl_blas_ztrmm+0x84>)
 800261c:	4806      	ldr	r0, [pc, #24]	; (8002638 <gsl_blas_ztrmm+0x8c>)
 800261e:	2314      	movs	r3, #20
 8002620:	f640 0209 	movw	r2, #2057	; 0x809
 8002624:	f000 f91c 	bl	8002860 <gsl_error>
 8002628:	2014      	movs	r0, #20
}
 800262a:	b00d      	add	sp, #52	; 0x34
 800262c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800262e:	bf00      	nop
 8002630:	08030180 	.word	0x08030180
 8002634:	08030188 	.word	0x08030188
 8002638:	080301b0 	.word	0x080301b0

0800263c <gsl_blas_strsm>:

int
gsl_blas_strsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha,
                const gsl_matrix_float * A, gsl_matrix_float * B)
{
 800263c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800263e:	b089      	sub	sp, #36	; 0x24
 8002640:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002644:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002648:	42af      	cmp	r7, r5
 800264a:	d127      	bne.n	800269c <gsl_blas_strsm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800264c:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 800264e:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002652:	d00d      	beq.n	8002670 <gsl_blas_strsm+0x34>
 8002654:	288e      	cmp	r0, #142	; 0x8e
 8002656:	d101      	bne.n	800265c <gsl_blas_strsm+0x20>
 8002658:	42bd      	cmp	r5, r7
 800265a:	d00b      	beq.n	8002674 <gsl_blas_strsm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 800265c:	4914      	ldr	r1, [pc, #80]	; (80026b0 <gsl_blas_strsm+0x74>)
 800265e:	4815      	ldr	r0, [pc, #84]	; (80026b4 <gsl_blas_strsm+0x78>)
 8002660:	2313      	movs	r3, #19
 8002662:	f640 0233 	movw	r2, #2099	; 0x833
 8002666:	f000 f8fb 	bl	8002860 <gsl_error>
 800266a:	2013      	movs	r0, #19
    }
}
 800266c:	b009      	add	sp, #36	; 0x24
 800266e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002670:	45bc      	cmp	ip, r7
 8002672:	d1f3      	bne.n	800265c <gsl_blas_strsm+0x20>
      cblas_strsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 8002674:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002678:	9502      	str	r5, [sp, #8]
 800267a:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 800267e:	e9cd 3c00 	strd	r3, ip, [sp]
 8002682:	e9cd 6705 	strd	r6, r7, [sp, #20]
 8002686:	4613      	mov	r3, r2
 8002688:	e9cd 4503 	strd	r4, r5, [sp, #12]
 800268c:	460a      	mov	r2, r1
 800268e:	4601      	mov	r1, r0
 8002690:	2065      	movs	r0, #101	; 0x65
 8002692:	f008 f9d1 	bl	800aa38 <cblas_strsm>
      return GSL_SUCCESS;
 8002696:	2000      	movs	r0, #0
}
 8002698:	b009      	add	sp, #36	; 0x24
 800269a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800269c:	4904      	ldr	r1, [pc, #16]	; (80026b0 <gsl_blas_strsm+0x74>)
 800269e:	4806      	ldr	r0, [pc, #24]	; (80026b8 <gsl_blas_strsm+0x7c>)
 80026a0:	2314      	movs	r3, #20
 80026a2:	f640 0228 	movw	r2, #2088	; 0x828
 80026a6:	f000 f8db 	bl	8002860 <gsl_error>
 80026aa:	2014      	movs	r0, #20
}
 80026ac:	b009      	add	sp, #36	; 0x24
 80026ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80026b0:	08030180 	.word	0x08030180
 80026b4:	08030188 	.word	0x08030188
 80026b8:	080301b0 	.word	0x080301b0

080026bc <gsl_blas_dtrsm>:

int
gsl_blas_dtrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha,
                const gsl_matrix * A, gsl_matrix * B)
{
 80026bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80026be:	b089      	sub	sp, #36	; 0x24
 80026c0:	e9dd 460e 	ldrd	r4, r6, [sp, #56]	; 0x38
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80026c4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80026c8:	42af      	cmp	r7, r5
 80026ca:	d127      	bne.n	800271c <gsl_blas_dtrsm+0x60>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80026cc:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80026ce:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80026d2:	d00d      	beq.n	80026f0 <gsl_blas_dtrsm+0x34>
 80026d4:	288e      	cmp	r0, #142	; 0x8e
 80026d6:	d101      	bne.n	80026dc <gsl_blas_dtrsm+0x20>
 80026d8:	42bd      	cmp	r5, r7
 80026da:	d00b      	beq.n	80026f4 <gsl_blas_dtrsm+0x38>
                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80026dc:	4914      	ldr	r1, [pc, #80]	; (8002730 <gsl_blas_dtrsm+0x74>)
 80026de:	4815      	ldr	r0, [pc, #84]	; (8002734 <gsl_blas_dtrsm+0x78>)
 80026e0:	2313      	movs	r3, #19
 80026e2:	f640 024f 	movw	r2, #2127	; 0x84f
 80026e6:	f000 f8bb 	bl	8002860 <gsl_error>
 80026ea:	2013      	movs	r0, #19
    }
}
 80026ec:	b009      	add	sp, #36	; 0x24
 80026ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80026f0:	45bc      	cmp	ip, r7
 80026f2:	d1f3      	bne.n	80026dc <gsl_blas_dtrsm+0x20>
      cblas_dtrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 80026f4:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 80026f8:	9502      	str	r5, [sp, #8]
 80026fa:	e9d4 5402 	ldrd	r5, r4, [r4, #8]
 80026fe:	e9cd 3c00 	strd	r3, ip, [sp]
 8002702:	e9cd 6705 	strd	r6, r7, [sp, #20]
 8002706:	4613      	mov	r3, r2
 8002708:	e9cd 4503 	strd	r4, r5, [sp, #12]
 800270c:	460a      	mov	r2, r1
 800270e:	4601      	mov	r1, r0
 8002710:	2065      	movs	r0, #101	; 0x65
 8002712:	f00d fef9 	bl	8010508 <cblas_dtrsm>
      return GSL_SUCCESS;
 8002716:	2000      	movs	r0, #0
}
 8002718:	b009      	add	sp, #36	; 0x24
 800271a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800271c:	4904      	ldr	r1, [pc, #16]	; (8002730 <gsl_blas_dtrsm+0x74>)
 800271e:	4806      	ldr	r0, [pc, #24]	; (8002738 <gsl_blas_dtrsm+0x7c>)
 8002720:	2314      	movs	r3, #20
 8002722:	f640 0244 	movw	r2, #2116	; 0x844
 8002726:	f000 f89b 	bl	8002860 <gsl_error>
 800272a:	2014      	movs	r0, #20
}
 800272c:	b009      	add	sp, #36	; 0x24
 800272e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002730:	08030180 	.word	0x08030180
 8002734:	08030188 	.word	0x08030188
 8002738:	080301b0 	.word	0x080301b0

0800273c <gsl_blas_ctrsm>:
gsl_blas_ctrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex_float alpha,
                const gsl_matrix_complex_float * A,
                gsl_matrix_complex_float * B)
{
 800273c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800273e:	b08b      	sub	sp, #44	; 0x2c
 8002740:	e9dd 4610 	ldrd	r4, r6, [sp, #64]	; 0x40
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 8002744:	e9d4 7500 	ldrd	r7, r5, [r4]
 8002748:	42af      	cmp	r7, r5
{
 800274a:	ed8d 0a08 	vstr	s0, [sp, #32]
 800274e:	edcd 0a09 	vstr	s1, [sp, #36]	; 0x24
  if (MA != NA)
 8002752:	d12a      	bne.n	80027aa <gsl_blas_ctrsm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002754:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 8002756:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 800275a:	d00d      	beq.n	8002778 <gsl_blas_ctrsm+0x3c>
 800275c:	288e      	cmp	r0, #142	; 0x8e
 800275e:	d101      	bne.n	8002764 <gsl_blas_ctrsm+0x28>
 8002760:	42bd      	cmp	r5, r7
 8002762:	d00b      	beq.n	800277c <gsl_blas_ctrsm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 8002764:	4916      	ldr	r1, [pc, #88]	; (80027c0 <gsl_blas_ctrsm+0x84>)
 8002766:	4817      	ldr	r0, [pc, #92]	; (80027c4 <gsl_blas_ctrsm+0x88>)
 8002768:	2313      	movs	r3, #19
 800276a:	f640 026e 	movw	r2, #2158	; 0x86e
 800276e:	f000 f877 	bl	8002860 <gsl_error>
 8002772:	2013      	movs	r0, #19
    }
}
 8002774:	b00b      	add	sp, #44	; 0x2c
 8002776:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002778:	45bc      	cmp	ip, r7
 800277a:	d1f3      	bne.n	8002764 <gsl_blas_ctrsm+0x28>
      cblas_ctrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 800277c:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002780:	9502      	str	r5, [sp, #8]
 8002782:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 8002786:	ad08      	add	r5, sp, #32
 8002788:	9300      	str	r3, [sp, #0]
 800278a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800278e:	4613      	mov	r3, r2
 8002790:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002794:	460a      	mov	r2, r1
 8002796:	f8cd c004 	str.w	ip, [sp, #4]
 800279a:	4601      	mov	r1, r0
 800279c:	9503      	str	r5, [sp, #12]
 800279e:	2065      	movs	r0, #101	; 0x65
 80027a0:	f015 f9f2 	bl	8017b88 <cblas_ctrsm>
      return GSL_SUCCESS;
 80027a4:	2000      	movs	r0, #0
}
 80027a6:	b00b      	add	sp, #44	; 0x2c
 80027a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 80027aa:	4905      	ldr	r1, [pc, #20]	; (80027c0 <gsl_blas_ctrsm+0x84>)
 80027ac:	4806      	ldr	r0, [pc, #24]	; (80027c8 <gsl_blas_ctrsm+0x8c>)
 80027ae:	2314      	movs	r3, #20
 80027b0:	f640 0262 	movw	r2, #2146	; 0x862
 80027b4:	f000 f854 	bl	8002860 <gsl_error>
 80027b8:	2014      	movs	r0, #20
}
 80027ba:	b00b      	add	sp, #44	; 0x2c
 80027bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80027be:	bf00      	nop
 80027c0:	08030180 	.word	0x08030180
 80027c4:	08030188 	.word	0x08030188
 80027c8:	080301b0 	.word	0x080301b0

080027cc <gsl_blas_ztrsm>:
int
gsl_blas_ztrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
                const gsl_complex alpha, const gsl_matrix_complex * A,
                gsl_matrix_complex * B)
{
 80027cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80027ce:	b08d      	sub	sp, #52	; 0x34
 80027d0:	e9dd 4612 	ldrd	r4, r6, [sp, #72]	; 0x48
  const size_t M = B->size1;
  const size_t N = B->size2;
  const size_t MA = A->size1;
  const size_t NA = A->size2;

  if (MA != NA)
 80027d4:	e9d4 7500 	ldrd	r7, r5, [r4]
 80027d8:	42af      	cmp	r7, r5
{
 80027da:	ed8d 0b08 	vstr	d0, [sp, #32]
 80027de:	ed8d 1b0a 	vstr	d1, [sp, #40]	; 0x28
  if (MA != NA)
 80027e2:	d12a      	bne.n	800283a <gsl_blas_ztrsm+0x6e>
    {
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
    }

  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80027e4:	288d      	cmp	r0, #141	; 0x8d
  const size_t N = B->size2;
 80027e6:	e9d6 c500 	ldrd	ip, r5, [r6]
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 80027ea:	d00d      	beq.n	8002808 <gsl_blas_ztrsm+0x3c>
 80027ec:	288e      	cmp	r0, #142	; 0x8e
 80027ee:	d101      	bne.n	80027f4 <gsl_blas_ztrsm+0x28>
 80027f0:	42bd      	cmp	r5, r7
 80027f2:	d00b      	beq.n	800280c <gsl_blas_ztrsm+0x40>
                   INT (B->tda));
      return GSL_SUCCESS;
    }
  else
    {
      GSL_ERROR ("invalid length", GSL_EBADLEN);
 80027f4:	4916      	ldr	r1, [pc, #88]	; (8002850 <gsl_blas_ztrsm+0x84>)
 80027f6:	4817      	ldr	r0, [pc, #92]	; (8002854 <gsl_blas_ztrsm+0x88>)
 80027f8:	2313      	movs	r3, #19
 80027fa:	f640 028c 	movw	r2, #2188	; 0x88c
 80027fe:	f000 f82f 	bl	8002860 <gsl_error>
 8002802:	2013      	movs	r0, #19
    }
}
 8002804:	b00d      	add	sp, #52	; 0x34
 8002806:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
 8002808:	45bc      	cmp	ip, r7
 800280a:	d1f3      	bne.n	80027f4 <gsl_blas_ztrsm+0x28>
      cblas_ztrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
 800280c:	e9d6 7602 	ldrd	r7, r6, [r6, #8]
 8002810:	9502      	str	r5, [sp, #8]
 8002812:	e9d4 e402 	ldrd	lr, r4, [r4, #8]
 8002816:	ad08      	add	r5, sp, #32
 8002818:	9300      	str	r3, [sp, #0]
 800281a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 800281e:	4613      	mov	r3, r2
 8002820:	e9cd 4e04 	strd	r4, lr, [sp, #16]
 8002824:	460a      	mov	r2, r1
 8002826:	f8cd c004 	str.w	ip, [sp, #4]
 800282a:	4601      	mov	r1, r0
 800282c:	9503      	str	r5, [sp, #12]
 800282e:	2065      	movs	r0, #101	; 0x65
 8002830:	f022 fb06 	bl	8024e40 <cblas_ztrsm>
      return GSL_SUCCESS;
 8002834:	2000      	movs	r0, #0
}
 8002836:	b00d      	add	sp, #52	; 0x34
 8002838:	bdf0      	pop	{r4, r5, r6, r7, pc}
      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
 800283a:	4905      	ldr	r1, [pc, #20]	; (8002850 <gsl_blas_ztrsm+0x84>)
 800283c:	4806      	ldr	r0, [pc, #24]	; (8002858 <gsl_blas_ztrsm+0x8c>)
 800283e:	2314      	movs	r3, #20
 8002840:	f44f 6208 	mov.w	r2, #2176	; 0x880
 8002844:	f000 f80c 	bl	8002860 <gsl_error>
 8002848:	2014      	movs	r0, #20
}
 800284a:	b00d      	add	sp, #52	; 0x34
 800284c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800284e:	bf00      	nop
 8002850:	08030180 	.word	0x08030180
 8002854:	08030188 	.word	0x08030188
 8002858:	080301b0 	.word	0x080301b0

0800285c <no_error_handler>:
  reason = 0;
  file = 0;
  line = 0;
  gsl_errno = 0;
  return;
}
 800285c:	4770      	bx	lr
 800285e:	bf00      	nop

08002860 <gsl_error>:
{
 8002860:	b570      	push	{r4, r5, r6, lr}
  if (gsl_error_handler) 
 8002862:	4c0f      	ldr	r4, [pc, #60]	; (80028a0 <gsl_error+0x40>)
 8002864:	6825      	ldr	r5, [r4, #0]
 8002866:	b11d      	cbz	r5, 8002870 <gsl_error+0x10>
      (*gsl_error_handler) (reason, file, line, gsl_errno);
 8002868:	46ac      	mov	ip, r5
}
 800286a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      (*gsl_error_handler) (reason, file, line, gsl_errno);
 800286e:	4760      	bx	ip
  fflush (stdout);
 8002870:	4d0c      	ldr	r5, [pc, #48]	; (80028a4 <gsl_error+0x44>)
 8002872:	4604      	mov	r4, r0
  gsl_stream_printf ("ERROR", file, line, reason);
 8002874:	4623      	mov	r3, r4
 8002876:	480c      	ldr	r0, [pc, #48]	; (80028a8 <gsl_error+0x48>)
 8002878:	f000 f82c 	bl	80028d4 <gsl_stream_printf>
  fflush (stdout);
 800287c:	682b      	ldr	r3, [r5, #0]
 800287e:	6898      	ldr	r0, [r3, #8]
 8002880:	f02c fbe4 	bl	802f04c <fflush>
  fprintf (stderr, "Default GSL error handler invoked.\n");
 8002884:	682b      	ldr	r3, [r5, #0]
 8002886:	4809      	ldr	r0, [pc, #36]	; (80028ac <gsl_error+0x4c>)
 8002888:	68db      	ldr	r3, [r3, #12]
 800288a:	2223      	movs	r2, #35	; 0x23
 800288c:	2101      	movs	r1, #1
 800288e:	f02c fd19 	bl	802f2c4 <fwrite>
  fflush (stderr);
 8002892:	682b      	ldr	r3, [r5, #0]
 8002894:	68d8      	ldr	r0, [r3, #12]
 8002896:	f02c fbd9 	bl	802f04c <fflush>
  abort ();
 800289a:	f02c fb19 	bl	802eed0 <abort>
 800289e:	bf00      	nop
 80028a0:	20000128 	.word	0x20000128
 80028a4:	200000a4 	.word	0x200000a4
 80028a8:	080301e0 	.word	0x080301e0
 80028ac:	080301e8 	.word	0x080301e8

080028b0 <gsl_set_error_handler>:
  gsl_error_handler_t * previous_handler = gsl_error_handler;
 80028b0:	4b02      	ldr	r3, [pc, #8]	; (80028bc <gsl_set_error_handler+0xc>)
 80028b2:	681a      	ldr	r2, [r3, #0]
  gsl_error_handler = new_handler;
 80028b4:	6018      	str	r0, [r3, #0]
}
 80028b6:	4610      	mov	r0, r2
 80028b8:	4770      	bx	lr
 80028ba:	bf00      	nop
 80028bc:	20000128 	.word	0x20000128

080028c0 <gsl_set_error_handler_off>:
  gsl_error_handler_t * previous_handler = gsl_error_handler;
 80028c0:	4b02      	ldr	r3, [pc, #8]	; (80028cc <gsl_set_error_handler_off+0xc>)
  gsl_error_handler = no_error_handler;
 80028c2:	4a03      	ldr	r2, [pc, #12]	; (80028d0 <gsl_set_error_handler_off+0x10>)
  gsl_error_handler_t * previous_handler = gsl_error_handler;
 80028c4:	6818      	ldr	r0, [r3, #0]
  gsl_error_handler = no_error_handler;
 80028c6:	601a      	str	r2, [r3, #0]
}
 80028c8:	4770      	bx	lr
 80028ca:	bf00      	nop
 80028cc:	20000128 	.word	0x20000128
 80028d0:	0800285d 	.word	0x0800285d

080028d4 <gsl_stream_printf>:
gsl_stream_handler_t * gsl_stream_handler = NULL;

void
gsl_stream_printf (const char *label, const char *file, int line, 
                   const char *reason)
{
 80028d4:	b530      	push	{r4, r5, lr}
  if (gsl_stream == NULL)
 80028d6:	4d0e      	ldr	r5, [pc, #56]	; (8002910 <gsl_stream_printf+0x3c>)
 80028d8:	682c      	ldr	r4, [r5, #0]
{
 80028da:	b083      	sub	sp, #12
  if (gsl_stream == NULL)
 80028dc:	b134      	cbz	r4, 80028ec <gsl_stream_printf+0x18>
    {
      gsl_stream = stderr;
    }
  if (gsl_stream_handler)
 80028de:	686c      	ldr	r4, [r5, #4]
 80028e0:	b15c      	cbz	r4, 80028fa <gsl_stream_printf+0x26>
    {
      (*gsl_stream_handler) (label, file, line, reason);
 80028e2:	46a4      	mov	ip, r4
      return;
    }
  fprintf (gsl_stream, "gsl: %s:%d: %s: %s\n", file, line, label, reason);

}
 80028e4:	b003      	add	sp, #12
 80028e6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
      (*gsl_stream_handler) (label, file, line, reason);
 80028ea:	4760      	bx	ip
      gsl_stream = stderr;
 80028ec:	4c09      	ldr	r4, [pc, #36]	; (8002914 <gsl_stream_printf+0x40>)
 80028ee:	6824      	ldr	r4, [r4, #0]
 80028f0:	68e4      	ldr	r4, [r4, #12]
 80028f2:	602c      	str	r4, [r5, #0]
  if (gsl_stream_handler)
 80028f4:	686c      	ldr	r4, [r5, #4]
 80028f6:	2c00      	cmp	r4, #0
 80028f8:	d1f3      	bne.n	80028e2 <gsl_stream_printf+0xe>
  fprintf (gsl_stream, "gsl: %s:%d: %s: %s\n", file, line, label, reason);
 80028fa:	e9cd 0300 	strd	r0, r3, [sp]
 80028fe:	4613      	mov	r3, r2
 8002900:	6828      	ldr	r0, [r5, #0]
 8002902:	460a      	mov	r2, r1
 8002904:	4904      	ldr	r1, [pc, #16]	; (8002918 <gsl_stream_printf+0x44>)
 8002906:	f02c fc5f 	bl	802f1c8 <fiprintf>
}
 800290a:	b003      	add	sp, #12
 800290c:	bd30      	pop	{r4, r5, pc}
 800290e:	bf00      	nop
 8002910:	2000012c 	.word	0x2000012c
 8002914:	200000a4 	.word	0x200000a4
 8002918:	0803020c 	.word	0x0803020c

0800291c <gsl_set_stream_handler>:

gsl_stream_handler_t *
gsl_set_stream_handler (gsl_stream_handler_t * new_handler)
{
  gsl_stream_handler_t * previous_handler = gsl_stream_handler;
 800291c:	4b02      	ldr	r3, [pc, #8]	; (8002928 <gsl_set_stream_handler+0xc>)
 800291e:	685a      	ldr	r2, [r3, #4]
  gsl_stream_handler = new_handler;
 8002920:	6058      	str	r0, [r3, #4]
  return previous_handler;
}
 8002922:	4610      	mov	r0, r2
 8002924:	4770      	bx	lr
 8002926:	bf00      	nop
 8002928:	2000012c 	.word	0x2000012c

0800292c <gsl_set_stream>:

FILE *
gsl_set_stream (FILE * new_stream)
{
  FILE * previous_stream;
  if (gsl_stream == NULL) {
 800292c:	4a05      	ldr	r2, [pc, #20]	; (8002944 <gsl_set_stream+0x18>)
 800292e:	6813      	ldr	r3, [r2, #0]
 8002930:	b113      	cbz	r3, 8002938 <gsl_set_stream+0xc>
    gsl_stream = stderr;
  }
  previous_stream = gsl_stream;
  gsl_stream = new_stream;
 8002932:	6010      	str	r0, [r2, #0]
  return previous_stream;
}
 8002934:	4618      	mov	r0, r3
 8002936:	4770      	bx	lr
    gsl_stream = stderr;
 8002938:	4b03      	ldr	r3, [pc, #12]	; (8002948 <gsl_set_stream+0x1c>)
  gsl_stream = new_stream;
 800293a:	6010      	str	r0, [r2, #0]
    gsl_stream = stderr;
 800293c:	681b      	ldr	r3, [r3, #0]
 800293e:	68db      	ldr	r3, [r3, #12]
}
 8002940:	4618      	mov	r0, r3
 8002942:	4770      	bx	lr
 8002944:	2000012c 	.word	0x2000012c
 8002948:	200000a4 	.word	0x200000a4

0800294c <gsl_matrix_complex_long_double_alloc>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

TYPE (gsl_matrix) *
FUNCTION (gsl_matrix, alloc) (const size_t n1, const size_t n2)
{
 800294c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800294e:	4607      	mov	r7, r0
  TYPE (gsl_block) * block;
  TYPE (gsl_matrix) * m;

  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002950:	2018      	movs	r0, #24
{
 8002952:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002954:	f02c fce8 	bl	802f328 <malloc>

  if (m == 0)
 8002958:	4604      	mov	r4, r0
 800295a:	b1b8      	cbz	r0, 800298c <gsl_matrix_complex_long_double_alloc+0x40>
                        GSL_ENOMEM, 0);
    }

  /* FIXME: n1*n2 could overflow for large dimensions */

  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800295c:	fb06 f007 	mul.w	r0, r6, r7
 8002960:	f004 f820 	bl	80069a4 <gsl_block_complex_long_double_alloc>

  if (block == 0)
 8002964:	4605      	mov	r5, r0
 8002966:	b148      	cbz	r0, 800297c <gsl_matrix_complex_long_double_alloc+0x30>
    {
      GSL_ERROR_VAL ("failed to allocate space for block",
                        GSL_ENOMEM, 0);
    }

  m->data = block->data;
 8002968:	6843      	ldr	r3, [r0, #4]
 800296a:	60e3      	str	r3, [r4, #12]
  m->size1 = n1;
  m->size2 = n2;
  m->tda = n2; 
  m->block = block;
  m->owner = 1;
 800296c:	2301      	movs	r3, #1
  m->size2 = n2;
 800296e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8002972:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8002976:	60a6      	str	r6, [r4, #8]

  return m;
}
 8002978:	4620      	mov	r0, r4
 800297a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 800297c:	4907      	ldr	r1, [pc, #28]	; (800299c <gsl_matrix_complex_long_double_alloc+0x50>)
 800297e:	4808      	ldr	r0, [pc, #32]	; (80029a0 <gsl_matrix_complex_long_double_alloc+0x54>)
 8002980:	2308      	movs	r3, #8
 8002982:	2228      	movs	r2, #40	; 0x28
 8002984:	462c      	mov	r4, r5
 8002986:	f7ff ff6b 	bl	8002860 <gsl_error>
 800298a:	e7f5      	b.n	8002978 <gsl_matrix_complex_long_double_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800298c:	4903      	ldr	r1, [pc, #12]	; (800299c <gsl_matrix_complex_long_double_alloc+0x50>)
 800298e:	4805      	ldr	r0, [pc, #20]	; (80029a4 <gsl_matrix_complex_long_double_alloc+0x58>)
 8002990:	2308      	movs	r3, #8
 8002992:	221e      	movs	r2, #30
 8002994:	f7ff ff64 	bl	8002860 <gsl_error>
 8002998:	e7ee      	b.n	8002978 <gsl_matrix_complex_long_double_alloc+0x2c>
 800299a:	bf00      	nop
 800299c:	08030220 	.word	0x08030220
 80029a0:	0803025c 	.word	0x0803025c
 80029a4:	08030230 	.word	0x08030230

080029a8 <gsl_matrix_complex_long_double_calloc>:

TYPE (gsl_matrix) *
FUNCTION (gsl_matrix, calloc) (const size_t n1, const size_t n2)
{
 80029a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80029aa:	4604      	mov	r4, r0
 80029ac:	460e      	mov	r6, r1
  size_t i;

  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80029ae:	f7ff ffcd 	bl	800294c <gsl_matrix_complex_long_double_alloc>

  if (m == 0)
 80029b2:	4605      	mov	r5, r0
 80029b4:	b188      	cbz	r0, 80029da <gsl_matrix_complex_long_double_calloc+0x32>
    return 0;

  /* initialize matrix to zero */
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80029b6:	fb06 f604 	mul.w	r6, r6, r4
 80029ba:	0134      	lsls	r4, r6, #4
 80029bc:	68c0      	ldr	r0, [r0, #12]
 80029be:	4622      	mov	r2, r4
 80029c0:	2100      	movs	r1, #0
 80029c2:	f02c fcc1 	bl	802f348 <memset>

  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80029c6:	0073      	lsls	r3, r6, #1
 80029c8:	d007      	beq.n	80029da <gsl_matrix_complex_long_double_calloc+0x32>
 80029ca:	68eb      	ldr	r3, [r5, #12]
    {
      m->data[i] = 0;
 80029cc:	2600      	movs	r6, #0
 80029ce:	2700      	movs	r7, #0
 80029d0:	18e2      	adds	r2, r4, r3
 80029d2:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80029d6:	4293      	cmp	r3, r2
 80029d8:	d1fb      	bne.n	80029d2 <gsl_matrix_complex_long_double_calloc+0x2a>
    }

  return m;
}
 80029da:	4628      	mov	r0, r5
 80029dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80029de:	bf00      	nop

080029e0 <gsl_matrix_complex_long_double_alloc_from_block>:
FUNCTION (gsl_matrix, alloc_from_block) (TYPE(gsl_block) * block, 
                                         const size_t offset,
                                         const size_t n1, 
                                         const size_t n2,
                                         const size_t d2)
{
 80029e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80029e4:	f8dd 9020 	ldr.w	r9, [sp, #32]
  TYPE (gsl_matrix) * m;

  if (d2 < n2)
 80029e8:	4599      	cmp	r9, r3
 80029ea:	d325      	bcc.n	8002a38 <gsl_matrix_complex_long_double_alloc_from_block+0x58>
    {
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
                        GSL_EINVAL, 0);
    }
  else if (block->size < offset + n1 * d2)
 80029ec:	4690      	mov	r8, r2
 80029ee:	6802      	ldr	r2, [r0, #0]
 80029f0:	461e      	mov	r6, r3
 80029f2:	fb08 1309 	mla	r3, r8, r9, r1
 80029f6:	429a      	cmp	r2, r3
 80029f8:	4605      	mov	r5, r0
 80029fa:	460f      	mov	r7, r1
 80029fc:	d312      	bcc.n	8002a24 <gsl_matrix_complex_long_double_alloc_from_block+0x44>
    {
      GSL_ERROR_VAL ("matrix size exceeds available block size",
                        GSL_EINVAL, 0);
    }

  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80029fe:	2018      	movs	r0, #24
 8002a00:	f02c fc92 	bl	802f328 <malloc>

  if (m == 0)
 8002a04:	4604      	mov	r4, r0
 8002a06:	b1f8      	cbz	r0, 8002a48 <gsl_matrix_complex_long_double_alloc_from_block+0x68>
    {
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
                        GSL_ENOMEM, 0);
    }

  m->data = block->data + MULTIPLICITY * offset;
 8002a08:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8002a0a:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8002a0e:	eb01 1107 	add.w	r1, r1, r7, lsl #4
  m->size2 = n2;
  m->tda = d2;
 8002a12:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8002a16:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->block = block;
  m->owner = 0;
 8002a1a:	2300      	movs	r3, #0
 8002a1c:	6143      	str	r3, [r0, #20]

  return m;
}
 8002a1e:	4620      	mov	r0, r4
 8002a20:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8002a24:	490c      	ldr	r1, [pc, #48]	; (8002a58 <gsl_matrix_complex_long_double_alloc_from_block+0x78>)
 8002a26:	480d      	ldr	r0, [pc, #52]	; (8002a5c <gsl_matrix_complex_long_double_alloc_from_block+0x7c>)
 8002a28:	2304      	movs	r3, #4
 8002a2a:	225b      	movs	r2, #91	; 0x5b
 8002a2c:	2400      	movs	r4, #0
 8002a2e:	f7ff ff17 	bl	8002860 <gsl_error>
}
 8002a32:	4620      	mov	r0, r4
 8002a34:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8002a38:	4907      	ldr	r1, [pc, #28]	; (8002a58 <gsl_matrix_complex_long_double_alloc_from_block+0x78>)
 8002a3a:	4809      	ldr	r0, [pc, #36]	; (8002a60 <gsl_matrix_complex_long_double_alloc_from_block+0x80>)
 8002a3c:	2304      	movs	r3, #4
 8002a3e:	2256      	movs	r2, #86	; 0x56
 8002a40:	f7ff ff0e 	bl	8002860 <gsl_error>
 8002a44:	2400      	movs	r4, #0
 8002a46:	e7ea      	b.n	8002a1e <gsl_matrix_complex_long_double_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002a48:	4903      	ldr	r1, [pc, #12]	; (8002a58 <gsl_matrix_complex_long_double_alloc_from_block+0x78>)
 8002a4a:	4806      	ldr	r0, [pc, #24]	; (8002a64 <gsl_matrix_complex_long_double_alloc_from_block+0x84>)
 8002a4c:	2308      	movs	r3, #8
 8002a4e:	2263      	movs	r2, #99	; 0x63
 8002a50:	f7ff ff06 	bl	8002860 <gsl_error>
 8002a54:	e7e3      	b.n	8002a1e <gsl_matrix_complex_long_double_alloc_from_block+0x3e>
 8002a56:	bf00      	nop
 8002a58:	08030220 	.word	0x08030220
 8002a5c:	080302ac 	.word	0x080302ac
 8002a60:	08030280 	.word	0x08030280
 8002a64:	08030230 	.word	0x08030230

08002a68 <gsl_matrix_complex_long_double_alloc_from_matrix>:
FUNCTION (gsl_matrix, alloc_from_matrix) (TYPE(gsl_matrix) * mm, 
                                          const size_t k1,
                                          const size_t k2,
                                          const size_t n1, 
                                          const size_t n2)
{
 8002a68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002a6c:	461f      	mov	r7, r3
  TYPE (gsl_matrix) * m;

  if (k1 + n1 > mm->size1)
 8002a6e:	6803      	ldr	r3, [r0, #0]
{
 8002a70:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8002a74:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8002a76:	19c8      	adds	r0, r1, r7
 8002a78:	4298      	cmp	r0, r3
 8002a7a:	d826      	bhi.n	8002aca <gsl_matrix_complex_long_double_alloc_from_matrix+0x62>
    {
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
                        GSL_EINVAL, 0);
    }
  else if (k2 + n2 > mm->size2)
 8002a7c:	686b      	ldr	r3, [r5, #4]
 8002a7e:	4690      	mov	r8, r2
 8002a80:	444a      	add	r2, r9
 8002a82:	429a      	cmp	r2, r3
 8002a84:	d817      	bhi.n	8002ab6 <gsl_matrix_complex_long_double_alloc_from_matrix+0x4e>
    {
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
                        GSL_EINVAL, 0);
    }

  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002a86:	2018      	movs	r0, #24
 8002a88:	460e      	mov	r6, r1
 8002a8a:	f02c fc4d 	bl	802f328 <malloc>

  if (m == 0)
 8002a8e:	4604      	mov	r4, r0
 8002a90:	b318      	cbz	r0, 8002ada <gsl_matrix_complex_long_double_alloc_from_matrix+0x72>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
                        GSL_ENOMEM, 0);
    }

  m->data = mm->data + k1 * mm->tda + k2 ;
  m->size1 = n1;
 8002a92:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002a94:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8002a96:	f8c4 9004 	str.w	r9, [r4, #4]
  m->tda = mm->tda;
  m->block = mm->block;
 8002a9a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002a9e:	fb06 8603 	mla	r6, r6, r3, r8
 8002aa2:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 8002aa6:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002aa8:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8002aac:	e9c4 0204 	strd	r0, r2, [r4, #16]

  return m;
}
 8002ab0:	4620      	mov	r0, r4
 8002ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8002ab6:	490c      	ldr	r1, [pc, #48]	; (8002ae8 <gsl_matrix_complex_long_double_alloc_from_matrix+0x80>)
 8002ab8:	480c      	ldr	r0, [pc, #48]	; (8002aec <gsl_matrix_complex_long_double_alloc_from_matrix+0x84>)
 8002aba:	2304      	movs	r3, #4
 8002abc:	2282      	movs	r2, #130	; 0x82
 8002abe:	2400      	movs	r4, #0
 8002ac0:	f7ff fece 	bl	8002860 <gsl_error>
}
 8002ac4:	4620      	mov	r0, r4
 8002ac6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8002aca:	4907      	ldr	r1, [pc, #28]	; (8002ae8 <gsl_matrix_complex_long_double_alloc_from_matrix+0x80>)
 8002acc:	4808      	ldr	r0, [pc, #32]	; (8002af0 <gsl_matrix_complex_long_double_alloc_from_matrix+0x88>)
 8002ace:	2304      	movs	r3, #4
 8002ad0:	227d      	movs	r2, #125	; 0x7d
 8002ad2:	f7ff fec5 	bl	8002860 <gsl_error>
 8002ad6:	2400      	movs	r4, #0
 8002ad8:	e7ea      	b.n	8002ab0 <gsl_matrix_complex_long_double_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002ada:	4903      	ldr	r1, [pc, #12]	; (8002ae8 <gsl_matrix_complex_long_double_alloc_from_matrix+0x80>)
 8002adc:	4805      	ldr	r0, [pc, #20]	; (8002af4 <gsl_matrix_complex_long_double_alloc_from_matrix+0x8c>)
 8002ade:	2308      	movs	r3, #8
 8002ae0:	228a      	movs	r2, #138	; 0x8a
 8002ae2:	f7ff febd 	bl	8002860 <gsl_error>
 8002ae6:	e7e3      	b.n	8002ab0 <gsl_matrix_complex_long_double_alloc_from_matrix+0x48>
 8002ae8:	08030220 	.word	0x08030220
 8002aec:	08030308 	.word	0x08030308
 8002af0:	080302d8 	.word	0x080302d8
 8002af4:	08030230 	.word	0x08030230

08002af8 <gsl_matrix_complex_long_double_free>:

void
FUNCTION (gsl_matrix, free) (TYPE (gsl_matrix) * m)
{
  RETURN_IF_NULL (m);
 8002af8:	b180      	cbz	r0, 8002b1c <gsl_matrix_complex_long_double_free+0x24>

  if (m->owner)
 8002afa:	6943      	ldr	r3, [r0, #20]
{
 8002afc:	b510      	push	{r4, lr}
 8002afe:	4604      	mov	r4, r0
  if (m->owner)
 8002b00:	b923      	cbnz	r3, 8002b0c <gsl_matrix_complex_long_double_free+0x14>
    {
      FUNCTION(gsl_block, free) (m->block);
    }

  free (m);
 8002b02:	4620      	mov	r0, r4
}
 8002b04:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002b08:	f02c bc16 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8002b0c:	6900      	ldr	r0, [r0, #16]
 8002b0e:	f003 ff8b 	bl	8006a28 <gsl_block_complex_long_double_free>
  free (m);
 8002b12:	4620      	mov	r0, r4
}
 8002b14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002b18:	f02c bc0e 	b.w	802f338 <free>
 8002b1c:	4770      	bx	lr
 8002b1e:	bf00      	nop

08002b20 <gsl_matrix_complex_long_double_set_identity>:
void
FUNCTION (gsl_matrix, set_identity) (TYPE (gsl_matrix) * m)
{
 8002b20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  size_t i, j;
  ATOMIC * const data = m->data;
  const size_t p = m->size1 ;
 8002b24:	6807      	ldr	r7, [r0, #0]
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
 8002b26:	1d05      	adds	r5, r0, #4
 8002b28:	e895 5020 	ldmia.w	r5, {r5, ip, lr}

  const BASE zero = ZERO;
  const BASE one = ONE;

  for (i = 0; i < p; i++)
 8002b2c:	b327      	cbz	r7, 8002b78 <gsl_matrix_complex_long_double_set_identity+0x58>
 8002b2e:	2600      	movs	r6, #0
    {
      for (j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b30:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8002b7c <gsl_matrix_complex_long_double_set_identity+0x5c>
 8002b34:	2000      	movs	r0, #0
 8002b36:	2100      	movs	r1, #0
 8002b38:	f04f 0800 	mov.w	r8, #0
  for (i = 0; i < p; i++)
 8002b3c:	4634      	mov	r4, r6
      for (j = 0; j < q; j++)
 8002b3e:	b1bd      	cbz	r5, 8002b70 <gsl_matrix_complex_long_double_set_identity+0x50>
 8002b40:	eb0e 1206 	add.w	r2, lr, r6, lsl #4
 8002b44:	2300      	movs	r3, #0
 8002b46:	e008      	b.n	8002b5a <gsl_matrix_complex_long_double_set_identity+0x3a>
 8002b48:	3301      	adds	r3, #1
 8002b4a:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b4c:	e9c2 0100 	strd	r0, r1, [r2]
 8002b50:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002b54:	f102 0210 	add.w	r2, r2, #16
 8002b58:	d00a      	beq.n	8002b70 <gsl_matrix_complex_long_double_set_identity+0x50>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b5a:	42a3      	cmp	r3, r4
 8002b5c:	d1f4      	bne.n	8002b48 <gsl_matrix_complex_long_double_set_identity+0x28>
      for (j = 0; j < q; j++)
 8002b5e:	3301      	adds	r3, #1
 8002b60:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002b62:	e9c2 8900 	strd	r8, r9, [r2]
 8002b66:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002b6a:	f102 0210 	add.w	r2, r2, #16
 8002b6e:	d1f4      	bne.n	8002b5a <gsl_matrix_complex_long_double_set_identity+0x3a>
  for (i = 0; i < p; i++)
 8002b70:	3401      	adds	r4, #1
 8002b72:	42a7      	cmp	r7, r4
 8002b74:	4466      	add	r6, ip
 8002b76:	d1e2      	bne.n	8002b3e <gsl_matrix_complex_long_double_set_identity+0x1e>
        }
    }
}
 8002b78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002b7c:	3ff00000 	.word	0x3ff00000

08002b80 <gsl_matrix_complex_long_double_set_zero>:
void
FUNCTION (gsl_matrix, set_zero) (TYPE (gsl_matrix) * m)
{
  size_t i, j;
  ATOMIC * const data = m->data;
  const size_t p = m->size1 ;
 8002b80:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 8002b84:	68c2      	ldr	r2, [r0, #12]
{
 8002b86:	b4f0      	push	{r4, r5, r6, r7}
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
 8002b88:	e9d0 5701 	ldrd	r5, r7, [r0, #4]

  const BASE zero = ZERO;

  for (i = 0; i < p; i++)
 8002b8c:	f1bc 0f00 	cmp.w	ip, #0
 8002b90:	d015      	beq.n	8002bbe <gsl_matrix_complex_long_double_set_zero+0x3e>
 8002b92:	ebc5 7605 	rsb	r6, r5, r5, lsl #28
 8002b96:	013f      	lsls	r7, r7, #4
 8002b98:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 8002b9c:	0136      	lsls	r6, r6, #4
 8002b9e:	2400      	movs	r4, #0
    {
      for (j = 0; j < q; j++)
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002ba0:	2000      	movs	r0, #0
 8002ba2:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8002ba4:	1993      	adds	r3, r2, r6
 8002ba6:	b135      	cbz	r5, 8002bb6 <gsl_matrix_complex_long_double_set_zero+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002ba8:	e9c3 0100 	strd	r0, r1, [r3]
 8002bac:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (j = 0; j < q; j++)
 8002bb0:	3310      	adds	r3, #16
 8002bb2:	4293      	cmp	r3, r2
 8002bb4:	d1f8      	bne.n	8002ba8 <gsl_matrix_complex_long_double_set_zero+0x28>
  for (i = 0; i < p; i++)
 8002bb6:	3401      	adds	r4, #1
 8002bb8:	45a4      	cmp	ip, r4
 8002bba:	443a      	add	r2, r7
 8002bbc:	d1f2      	bne.n	8002ba4 <gsl_matrix_complex_long_double_set_zero+0x24>
        }
    }
}
 8002bbe:	bcf0      	pop	{r4, r5, r6, r7}
 8002bc0:	4770      	bx	lr
 8002bc2:	bf00      	nop

08002bc4 <gsl_matrix_complex_long_double_set_all>:

void
FUNCTION (gsl_matrix, set_all) (TYPE (gsl_matrix) * m, BASE x)
{
 8002bc4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  size_t i, j;
  ATOMIC * const data = m->data;
  const size_t p = m->size1 ;
 8002bc8:	f8d0 9000 	ldr.w	r9, [r0]
  ATOMIC * const data = m->data;
 8002bcc:	68c6      	ldr	r6, [r0, #12]
{
 8002bce:	b085      	sub	sp, #20
  const size_t q = m->size2 ;
  const size_t tda = m->tda ;
 8002bd0:	e9d0 c301 	ldrd	ip, r3, [r0, #4]
{
 8002bd4:	ed8d 0b00 	vstr	d0, [sp]
 8002bd8:	ed8d 1b02 	vstr	d1, [sp, #8]

  for (i = 0; i < p; i++)
 8002bdc:	f1b9 0f00 	cmp.w	r9, #0
 8002be0:	d019      	beq.n	8002c16 <gsl_matrix_complex_long_double_set_all+0x52>
 8002be2:	ebcc 7e0c 	rsb	lr, ip, ip, lsl #28
 8002be6:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8002bea:	eb06 160c 	add.w	r6, r6, ip, lsl #4
 8002bee:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
 8002bf2:	2700      	movs	r7, #0
 8002bf4:	466d      	mov	r5, sp
    {
      for (j = 0; j < q; j++)
 8002bf6:	eb06 040e 	add.w	r4, r6, lr
 8002bfa:	f1bc 0f00 	cmp.w	ip, #0
 8002bfe:	d006      	beq.n	8002c0e <gsl_matrix_complex_long_double_set_all+0x4a>
        {
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8002c00:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002c04:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
      for (j = 0; j < q; j++)
 8002c08:	3410      	adds	r4, #16
 8002c0a:	42b4      	cmp	r4, r6
 8002c0c:	d1f8      	bne.n	8002c00 <gsl_matrix_complex_long_double_set_all+0x3c>
  for (i = 0; i < p; i++)
 8002c0e:	3701      	adds	r7, #1
 8002c10:	45b9      	cmp	r9, r7
 8002c12:	4446      	add	r6, r8
 8002c14:	d1ef      	bne.n	8002bf6 <gsl_matrix_complex_long_double_set_all+0x32>
        }
    }
}
 8002c16:	b005      	add	sp, #20
 8002c18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002c1c <gsl_matrix_complex_alloc>:
{
 8002c1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c1e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002c20:	2018      	movs	r0, #24
{
 8002c22:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002c24:	f02c fb80 	bl	802f328 <malloc>
  if (m == 0)
 8002c28:	4604      	mov	r4, r0
 8002c2a:	b1b8      	cbz	r0, 8002c5c <gsl_matrix_complex_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8002c2c:	fb06 f007 	mul.w	r0, r6, r7
 8002c30:	f003 ff06 	bl	8006a40 <gsl_block_complex_alloc>
  if (block == 0)
 8002c34:	4605      	mov	r5, r0
 8002c36:	b148      	cbz	r0, 8002c4c <gsl_matrix_complex_alloc+0x30>
  m->data = block->data;
 8002c38:	6843      	ldr	r3, [r0, #4]
 8002c3a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8002c3c:	2301      	movs	r3, #1
  m->size2 = n2;
 8002c3e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8002c42:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8002c46:	60a6      	str	r6, [r4, #8]
}
 8002c48:	4620      	mov	r0, r4
 8002c4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8002c4c:	4907      	ldr	r1, [pc, #28]	; (8002c6c <gsl_matrix_complex_alloc+0x50>)
 8002c4e:	4808      	ldr	r0, [pc, #32]	; (8002c70 <gsl_matrix_complex_alloc+0x54>)
 8002c50:	2308      	movs	r3, #8
 8002c52:	2228      	movs	r2, #40	; 0x28
 8002c54:	462c      	mov	r4, r5
 8002c56:	f7ff fe03 	bl	8002860 <gsl_error>
 8002c5a:	e7f5      	b.n	8002c48 <gsl_matrix_complex_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002c5c:	4903      	ldr	r1, [pc, #12]	; (8002c6c <gsl_matrix_complex_alloc+0x50>)
 8002c5e:	4805      	ldr	r0, [pc, #20]	; (8002c74 <gsl_matrix_complex_alloc+0x58>)
 8002c60:	2308      	movs	r3, #8
 8002c62:	221e      	movs	r2, #30
 8002c64:	f7ff fdfc 	bl	8002860 <gsl_error>
 8002c68:	e7ee      	b.n	8002c48 <gsl_matrix_complex_alloc+0x2c>
 8002c6a:	bf00      	nop
 8002c6c:	08030220 	.word	0x08030220
 8002c70:	0803025c 	.word	0x0803025c
 8002c74:	08030230 	.word	0x08030230

08002c78 <gsl_matrix_complex_calloc>:
{
 8002c78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002c7a:	4604      	mov	r4, r0
 8002c7c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8002c7e:	f7ff ffcd 	bl	8002c1c <gsl_matrix_complex_alloc>
  if (m == 0)
 8002c82:	4605      	mov	r5, r0
 8002c84:	b188      	cbz	r0, 8002caa <gsl_matrix_complex_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8002c86:	fb06 f604 	mul.w	r6, r6, r4
 8002c8a:	0134      	lsls	r4, r6, #4
 8002c8c:	68c0      	ldr	r0, [r0, #12]
 8002c8e:	4622      	mov	r2, r4
 8002c90:	2100      	movs	r1, #0
 8002c92:	f02c fb59 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002c96:	0073      	lsls	r3, r6, #1
 8002c98:	d007      	beq.n	8002caa <gsl_matrix_complex_calloc+0x32>
 8002c9a:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 8002c9c:	2600      	movs	r6, #0
 8002c9e:	2700      	movs	r7, #0
 8002ca0:	18e2      	adds	r2, r4, r3
 8002ca2:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002ca6:	4293      	cmp	r3, r2
 8002ca8:	d1fb      	bne.n	8002ca2 <gsl_matrix_complex_calloc+0x2a>
}
 8002caa:	4628      	mov	r0, r5
 8002cac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002cae:	bf00      	nop

08002cb0 <gsl_matrix_complex_alloc_from_block>:
{
 8002cb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002cb4:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8002cb8:	4599      	cmp	r9, r3
 8002cba:	d325      	bcc.n	8002d08 <gsl_matrix_complex_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8002cbc:	4690      	mov	r8, r2
 8002cbe:	6802      	ldr	r2, [r0, #0]
 8002cc0:	461e      	mov	r6, r3
 8002cc2:	fb08 1309 	mla	r3, r8, r9, r1
 8002cc6:	429a      	cmp	r2, r3
 8002cc8:	4605      	mov	r5, r0
 8002cca:	460f      	mov	r7, r1
 8002ccc:	d312      	bcc.n	8002cf4 <gsl_matrix_complex_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002cce:	2018      	movs	r0, #24
 8002cd0:	f02c fb2a 	bl	802f328 <malloc>
  if (m == 0)
 8002cd4:	4604      	mov	r4, r0
 8002cd6:	b1f8      	cbz	r0, 8002d18 <gsl_matrix_complex_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8002cd8:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8002cda:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8002cde:	eb01 1107 	add.w	r1, r1, r7, lsl #4
  m->tda = d2;
 8002ce2:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8002ce6:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8002cea:	2300      	movs	r3, #0
 8002cec:	6143      	str	r3, [r0, #20]
}
 8002cee:	4620      	mov	r0, r4
 8002cf0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8002cf4:	490c      	ldr	r1, [pc, #48]	; (8002d28 <gsl_matrix_complex_alloc_from_block+0x78>)
 8002cf6:	480d      	ldr	r0, [pc, #52]	; (8002d2c <gsl_matrix_complex_alloc_from_block+0x7c>)
 8002cf8:	2304      	movs	r3, #4
 8002cfa:	225b      	movs	r2, #91	; 0x5b
 8002cfc:	2400      	movs	r4, #0
 8002cfe:	f7ff fdaf 	bl	8002860 <gsl_error>
}
 8002d02:	4620      	mov	r0, r4
 8002d04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8002d08:	4907      	ldr	r1, [pc, #28]	; (8002d28 <gsl_matrix_complex_alloc_from_block+0x78>)
 8002d0a:	4809      	ldr	r0, [pc, #36]	; (8002d30 <gsl_matrix_complex_alloc_from_block+0x80>)
 8002d0c:	2304      	movs	r3, #4
 8002d0e:	2256      	movs	r2, #86	; 0x56
 8002d10:	f7ff fda6 	bl	8002860 <gsl_error>
 8002d14:	2400      	movs	r4, #0
 8002d16:	e7ea      	b.n	8002cee <gsl_matrix_complex_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002d18:	4903      	ldr	r1, [pc, #12]	; (8002d28 <gsl_matrix_complex_alloc_from_block+0x78>)
 8002d1a:	4806      	ldr	r0, [pc, #24]	; (8002d34 <gsl_matrix_complex_alloc_from_block+0x84>)
 8002d1c:	2308      	movs	r3, #8
 8002d1e:	2263      	movs	r2, #99	; 0x63
 8002d20:	f7ff fd9e 	bl	8002860 <gsl_error>
 8002d24:	e7e3      	b.n	8002cee <gsl_matrix_complex_alloc_from_block+0x3e>
 8002d26:	bf00      	nop
 8002d28:	08030220 	.word	0x08030220
 8002d2c:	080302ac 	.word	0x080302ac
 8002d30:	08030280 	.word	0x08030280
 8002d34:	08030230 	.word	0x08030230

08002d38 <gsl_matrix_complex_alloc_from_matrix>:
{
 8002d38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002d3c:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8002d3e:	6803      	ldr	r3, [r0, #0]
{
 8002d40:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8002d44:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8002d46:	19c8      	adds	r0, r1, r7
 8002d48:	4298      	cmp	r0, r3
 8002d4a:	d826      	bhi.n	8002d9a <gsl_matrix_complex_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8002d4c:	686b      	ldr	r3, [r5, #4]
 8002d4e:	4690      	mov	r8, r2
 8002d50:	444a      	add	r2, r9
 8002d52:	429a      	cmp	r2, r3
 8002d54:	d817      	bhi.n	8002d86 <gsl_matrix_complex_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002d56:	2018      	movs	r0, #24
 8002d58:	460e      	mov	r6, r1
 8002d5a:	f02c fae5 	bl	802f328 <malloc>
  if (m == 0)
 8002d5e:	4604      	mov	r4, r0
 8002d60:	b318      	cbz	r0, 8002daa <gsl_matrix_complex_alloc_from_matrix+0x72>
  m->size1 = n1;
 8002d62:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002d64:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8002d66:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8002d6a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002d6e:	fb06 8603 	mla	r6, r6, r3, r8
 8002d72:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 8002d76:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8002d78:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8002d7c:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8002d80:	4620      	mov	r0, r4
 8002d82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8002d86:	490c      	ldr	r1, [pc, #48]	; (8002db8 <gsl_matrix_complex_alloc_from_matrix+0x80>)
 8002d88:	480c      	ldr	r0, [pc, #48]	; (8002dbc <gsl_matrix_complex_alloc_from_matrix+0x84>)
 8002d8a:	2304      	movs	r3, #4
 8002d8c:	2282      	movs	r2, #130	; 0x82
 8002d8e:	2400      	movs	r4, #0
 8002d90:	f7ff fd66 	bl	8002860 <gsl_error>
}
 8002d94:	4620      	mov	r0, r4
 8002d96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8002d9a:	4907      	ldr	r1, [pc, #28]	; (8002db8 <gsl_matrix_complex_alloc_from_matrix+0x80>)
 8002d9c:	4808      	ldr	r0, [pc, #32]	; (8002dc0 <gsl_matrix_complex_alloc_from_matrix+0x88>)
 8002d9e:	2304      	movs	r3, #4
 8002da0:	227d      	movs	r2, #125	; 0x7d
 8002da2:	f7ff fd5d 	bl	8002860 <gsl_error>
 8002da6:	2400      	movs	r4, #0
 8002da8:	e7ea      	b.n	8002d80 <gsl_matrix_complex_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002daa:	4903      	ldr	r1, [pc, #12]	; (8002db8 <gsl_matrix_complex_alloc_from_matrix+0x80>)
 8002dac:	4805      	ldr	r0, [pc, #20]	; (8002dc4 <gsl_matrix_complex_alloc_from_matrix+0x8c>)
 8002dae:	2308      	movs	r3, #8
 8002db0:	228a      	movs	r2, #138	; 0x8a
 8002db2:	f7ff fd55 	bl	8002860 <gsl_error>
 8002db6:	e7e3      	b.n	8002d80 <gsl_matrix_complex_alloc_from_matrix+0x48>
 8002db8:	08030220 	.word	0x08030220
 8002dbc:	08030308 	.word	0x08030308
 8002dc0:	080302d8 	.word	0x080302d8
 8002dc4:	08030230 	.word	0x08030230

08002dc8 <gsl_matrix_complex_free>:
  RETURN_IF_NULL (m);
 8002dc8:	b180      	cbz	r0, 8002dec <gsl_matrix_complex_free+0x24>
  if (m->owner)
 8002dca:	6943      	ldr	r3, [r0, #20]
{
 8002dcc:	b510      	push	{r4, lr}
 8002dce:	4604      	mov	r4, r0
  if (m->owner)
 8002dd0:	b923      	cbnz	r3, 8002ddc <gsl_matrix_complex_free+0x14>
  free (m);
 8002dd2:	4620      	mov	r0, r4
}
 8002dd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002dd8:	f02c baae 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8002ddc:	6900      	ldr	r0, [r0, #16]
 8002dde:	f003 fe71 	bl	8006ac4 <gsl_block_complex_free>
  free (m);
 8002de2:	4620      	mov	r0, r4
}
 8002de4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8002de8:	f02c baa6 	b.w	802f338 <free>
 8002dec:	4770      	bx	lr
 8002dee:	bf00      	nop

08002df0 <gsl_matrix_complex_set_identity>:
{
 8002df0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  const size_t p = m->size1 ;
 8002df4:	6807      	ldr	r7, [r0, #0]
  const size_t tda = m->tda ;
 8002df6:	1d05      	adds	r5, r0, #4
 8002df8:	e895 5020 	ldmia.w	r5, {r5, ip, lr}
  for (i = 0; i < p; i++)
 8002dfc:	b327      	cbz	r7, 8002e48 <gsl_matrix_complex_set_identity+0x58>
 8002dfe:	2600      	movs	r6, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e00:	f8df 9048 	ldr.w	r9, [pc, #72]	; 8002e4c <gsl_matrix_complex_set_identity+0x5c>
 8002e04:	2000      	movs	r0, #0
 8002e06:	2100      	movs	r1, #0
 8002e08:	f04f 0800 	mov.w	r8, #0
  for (i = 0; i < p; i++)
 8002e0c:	4634      	mov	r4, r6
      for (j = 0; j < q; j++)
 8002e0e:	b1bd      	cbz	r5, 8002e40 <gsl_matrix_complex_set_identity+0x50>
 8002e10:	eb0e 1206 	add.w	r2, lr, r6, lsl #4
 8002e14:	2300      	movs	r3, #0
 8002e16:	e008      	b.n	8002e2a <gsl_matrix_complex_set_identity+0x3a>
 8002e18:	3301      	adds	r3, #1
 8002e1a:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e1c:	e9c2 0100 	strd	r0, r1, [r2]
 8002e20:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002e24:	f102 0210 	add.w	r2, r2, #16
 8002e28:	d00a      	beq.n	8002e40 <gsl_matrix_complex_set_identity+0x50>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e2a:	42a3      	cmp	r3, r4
 8002e2c:	d1f4      	bne.n	8002e18 <gsl_matrix_complex_set_identity+0x28>
      for (j = 0; j < q; j++)
 8002e2e:	3301      	adds	r3, #1
 8002e30:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8002e32:	e9c2 8900 	strd	r8, r9, [r2]
 8002e36:	e9c2 0102 	strd	r0, r1, [r2, #8]
      for (j = 0; j < q; j++)
 8002e3a:	f102 0210 	add.w	r2, r2, #16
 8002e3e:	d1f4      	bne.n	8002e2a <gsl_matrix_complex_set_identity+0x3a>
  for (i = 0; i < p; i++)
 8002e40:	3401      	adds	r4, #1
 8002e42:	42a7      	cmp	r7, r4
 8002e44:	4466      	add	r6, ip
 8002e46:	d1e2      	bne.n	8002e0e <gsl_matrix_complex_set_identity+0x1e>
}
 8002e48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002e4c:	3ff00000 	.word	0x3ff00000

08002e50 <gsl_matrix_complex_set_zero>:
  const size_t p = m->size1 ;
 8002e50:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 8002e54:	68c2      	ldr	r2, [r0, #12]
{
 8002e56:	b4f0      	push	{r4, r5, r6, r7}
  const size_t tda = m->tda ;
 8002e58:	e9d0 5701 	ldrd	r5, r7, [r0, #4]
  for (i = 0; i < p; i++)
 8002e5c:	f1bc 0f00 	cmp.w	ip, #0
 8002e60:	d015      	beq.n	8002e8e <gsl_matrix_complex_set_zero+0x3e>
 8002e62:	ebc5 7605 	rsb	r6, r5, r5, lsl #28
 8002e66:	013f      	lsls	r7, r7, #4
 8002e68:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 8002e6c:	0136      	lsls	r6, r6, #4
 8002e6e:	2400      	movs	r4, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002e70:	2000      	movs	r0, #0
 8002e72:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8002e74:	1993      	adds	r3, r2, r6
 8002e76:	b135      	cbz	r5, 8002e86 <gsl_matrix_complex_set_zero+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8002e78:	e9c3 0100 	strd	r0, r1, [r3]
 8002e7c:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (j = 0; j < q; j++)
 8002e80:	3310      	adds	r3, #16
 8002e82:	4293      	cmp	r3, r2
 8002e84:	d1f8      	bne.n	8002e78 <gsl_matrix_complex_set_zero+0x28>
  for (i = 0; i < p; i++)
 8002e86:	3401      	adds	r4, #1
 8002e88:	45a4      	cmp	ip, r4
 8002e8a:	443a      	add	r2, r7
 8002e8c:	d1f2      	bne.n	8002e74 <gsl_matrix_complex_set_zero+0x24>
}
 8002e8e:	bcf0      	pop	{r4, r5, r6, r7}
 8002e90:	4770      	bx	lr
 8002e92:	bf00      	nop

08002e94 <gsl_matrix_complex_set_all>:
{
 8002e94:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  const size_t p = m->size1 ;
 8002e98:	f8d0 9000 	ldr.w	r9, [r0]
  ATOMIC * const data = m->data;
 8002e9c:	68c6      	ldr	r6, [r0, #12]
{
 8002e9e:	b085      	sub	sp, #20
  const size_t tda = m->tda ;
 8002ea0:	e9d0 c301 	ldrd	ip, r3, [r0, #4]
{
 8002ea4:	ed8d 0b00 	vstr	d0, [sp]
 8002ea8:	ed8d 1b02 	vstr	d1, [sp, #8]
  for (i = 0; i < p; i++)
 8002eac:	f1b9 0f00 	cmp.w	r9, #0
 8002eb0:	d019      	beq.n	8002ee6 <gsl_matrix_complex_set_all+0x52>
 8002eb2:	ebcc 7e0c 	rsb	lr, ip, ip, lsl #28
 8002eb6:	ea4f 1803 	mov.w	r8, r3, lsl #4
 8002eba:	eb06 160c 	add.w	r6, r6, ip, lsl #4
 8002ebe:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
 8002ec2:	2700      	movs	r7, #0
 8002ec4:	466d      	mov	r5, sp
      for (j = 0; j < q; j++)
 8002ec6:	eb06 040e 	add.w	r4, r6, lr
 8002eca:	f1bc 0f00 	cmp.w	ip, #0
 8002ece:	d006      	beq.n	8002ede <gsl_matrix_complex_set_all+0x4a>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8002ed0:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8002ed4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
      for (j = 0; j < q; j++)
 8002ed8:	3410      	adds	r4, #16
 8002eda:	42b4      	cmp	r4, r6
 8002edc:	d1f8      	bne.n	8002ed0 <gsl_matrix_complex_set_all+0x3c>
  for (i = 0; i < p; i++)
 8002ede:	3701      	adds	r7, #1
 8002ee0:	45b9      	cmp	r9, r7
 8002ee2:	4446      	add	r6, r8
 8002ee4:	d1ef      	bne.n	8002ec6 <gsl_matrix_complex_set_all+0x32>
}
 8002ee6:	b005      	add	sp, #20
 8002ee8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08002eec <gsl_matrix_complex_float_alloc>:
{
 8002eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002eee:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002ef0:	2018      	movs	r0, #24
{
 8002ef2:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002ef4:	f02c fa18 	bl	802f328 <malloc>
  if (m == 0)
 8002ef8:	4604      	mov	r4, r0
 8002efa:	b1b8      	cbz	r0, 8002f2c <gsl_matrix_complex_float_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8002efc:	fb06 f007 	mul.w	r0, r6, r7
 8002f00:	f003 fdec 	bl	8006adc <gsl_block_complex_float_alloc>
  if (block == 0)
 8002f04:	4605      	mov	r5, r0
 8002f06:	b148      	cbz	r0, 8002f1c <gsl_matrix_complex_float_alloc+0x30>
  m->data = block->data;
 8002f08:	6843      	ldr	r3, [r0, #4]
 8002f0a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8002f0c:	2301      	movs	r3, #1
  m->size2 = n2;
 8002f0e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8002f12:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8002f16:	60a6      	str	r6, [r4, #8]
}
 8002f18:	4620      	mov	r0, r4
 8002f1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8002f1c:	4907      	ldr	r1, [pc, #28]	; (8002f3c <gsl_matrix_complex_float_alloc+0x50>)
 8002f1e:	4808      	ldr	r0, [pc, #32]	; (8002f40 <gsl_matrix_complex_float_alloc+0x54>)
 8002f20:	2308      	movs	r3, #8
 8002f22:	2228      	movs	r2, #40	; 0x28
 8002f24:	462c      	mov	r4, r5
 8002f26:	f7ff fc9b 	bl	8002860 <gsl_error>
 8002f2a:	e7f5      	b.n	8002f18 <gsl_matrix_complex_float_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002f2c:	4903      	ldr	r1, [pc, #12]	; (8002f3c <gsl_matrix_complex_float_alloc+0x50>)
 8002f2e:	4805      	ldr	r0, [pc, #20]	; (8002f44 <gsl_matrix_complex_float_alloc+0x58>)
 8002f30:	2308      	movs	r3, #8
 8002f32:	221e      	movs	r2, #30
 8002f34:	f7ff fc94 	bl	8002860 <gsl_error>
 8002f38:	e7ee      	b.n	8002f18 <gsl_matrix_complex_float_alloc+0x2c>
 8002f3a:	bf00      	nop
 8002f3c:	08030220 	.word	0x08030220
 8002f40:	0803025c 	.word	0x0803025c
 8002f44:	08030230 	.word	0x08030230

08002f48 <gsl_matrix_complex_float_calloc>:
{
 8002f48:	b570      	push	{r4, r5, r6, lr}
 8002f4a:	4604      	mov	r4, r0
 8002f4c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8002f4e:	f7ff ffcd 	bl	8002eec <gsl_matrix_complex_float_alloc>
  if (m == 0)
 8002f52:	4605      	mov	r5, r0
 8002f54:	b180      	cbz	r0, 8002f78 <gsl_matrix_complex_float_calloc+0x30>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8002f56:	fb06 f604 	mul.w	r6, r6, r4
 8002f5a:	00f4      	lsls	r4, r6, #3
 8002f5c:	68c0      	ldr	r0, [r0, #12]
 8002f5e:	4622      	mov	r2, r4
 8002f60:	2100      	movs	r1, #0
 8002f62:	f02c f9f1 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002f66:	0073      	lsls	r3, r6, #1
 8002f68:	d006      	beq.n	8002f78 <gsl_matrix_complex_float_calloc+0x30>
 8002f6a:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 8002f6c:	2100      	movs	r1, #0
 8002f6e:	18e2      	adds	r2, r4, r3
 8002f70:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8002f74:	4293      	cmp	r3, r2
 8002f76:	d1fb      	bne.n	8002f70 <gsl_matrix_complex_float_calloc+0x28>
}
 8002f78:	4628      	mov	r0, r5
 8002f7a:	bd70      	pop	{r4, r5, r6, pc}

08002f7c <gsl_matrix_complex_float_alloc_from_block>:
{
 8002f7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002f80:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8002f84:	4599      	cmp	r9, r3
 8002f86:	d325      	bcc.n	8002fd4 <gsl_matrix_complex_float_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8002f88:	4690      	mov	r8, r2
 8002f8a:	6802      	ldr	r2, [r0, #0]
 8002f8c:	461e      	mov	r6, r3
 8002f8e:	fb08 1309 	mla	r3, r8, r9, r1
 8002f92:	429a      	cmp	r2, r3
 8002f94:	4605      	mov	r5, r0
 8002f96:	460f      	mov	r7, r1
 8002f98:	d312      	bcc.n	8002fc0 <gsl_matrix_complex_float_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8002f9a:	2018      	movs	r0, #24
 8002f9c:	f02c f9c4 	bl	802f328 <malloc>
  if (m == 0)
 8002fa0:	4604      	mov	r4, r0
 8002fa2:	b1f8      	cbz	r0, 8002fe4 <gsl_matrix_complex_float_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8002fa4:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8002fa6:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8002faa:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
  m->tda = d2;
 8002fae:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8002fb2:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8002fb6:	2300      	movs	r3, #0
 8002fb8:	6143      	str	r3, [r0, #20]
}
 8002fba:	4620      	mov	r0, r4
 8002fbc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8002fc0:	490c      	ldr	r1, [pc, #48]	; (8002ff4 <gsl_matrix_complex_float_alloc_from_block+0x78>)
 8002fc2:	480d      	ldr	r0, [pc, #52]	; (8002ff8 <gsl_matrix_complex_float_alloc_from_block+0x7c>)
 8002fc4:	2304      	movs	r3, #4
 8002fc6:	225b      	movs	r2, #91	; 0x5b
 8002fc8:	2400      	movs	r4, #0
 8002fca:	f7ff fc49 	bl	8002860 <gsl_error>
}
 8002fce:	4620      	mov	r0, r4
 8002fd0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8002fd4:	4907      	ldr	r1, [pc, #28]	; (8002ff4 <gsl_matrix_complex_float_alloc_from_block+0x78>)
 8002fd6:	4809      	ldr	r0, [pc, #36]	; (8002ffc <gsl_matrix_complex_float_alloc_from_block+0x80>)
 8002fd8:	2304      	movs	r3, #4
 8002fda:	2256      	movs	r2, #86	; 0x56
 8002fdc:	f7ff fc40 	bl	8002860 <gsl_error>
 8002fe0:	2400      	movs	r4, #0
 8002fe2:	e7ea      	b.n	8002fba <gsl_matrix_complex_float_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8002fe4:	4903      	ldr	r1, [pc, #12]	; (8002ff4 <gsl_matrix_complex_float_alloc_from_block+0x78>)
 8002fe6:	4806      	ldr	r0, [pc, #24]	; (8003000 <gsl_matrix_complex_float_alloc_from_block+0x84>)
 8002fe8:	2308      	movs	r3, #8
 8002fea:	2263      	movs	r2, #99	; 0x63
 8002fec:	f7ff fc38 	bl	8002860 <gsl_error>
 8002ff0:	e7e3      	b.n	8002fba <gsl_matrix_complex_float_alloc_from_block+0x3e>
 8002ff2:	bf00      	nop
 8002ff4:	08030220 	.word	0x08030220
 8002ff8:	080302ac 	.word	0x080302ac
 8002ffc:	08030280 	.word	0x08030280
 8003000:	08030230 	.word	0x08030230

08003004 <gsl_matrix_complex_float_alloc_from_matrix>:
{
 8003004:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003008:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 800300a:	6803      	ldr	r3, [r0, #0]
{
 800300c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003010:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003012:	19c8      	adds	r0, r1, r7
 8003014:	4298      	cmp	r0, r3
 8003016:	d826      	bhi.n	8003066 <gsl_matrix_complex_float_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003018:	686b      	ldr	r3, [r5, #4]
 800301a:	4690      	mov	r8, r2
 800301c:	444a      	add	r2, r9
 800301e:	429a      	cmp	r2, r3
 8003020:	d817      	bhi.n	8003052 <gsl_matrix_complex_float_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003022:	2018      	movs	r0, #24
 8003024:	460e      	mov	r6, r1
 8003026:	f02c f97f 	bl	802f328 <malloc>
  if (m == 0)
 800302a:	4604      	mov	r4, r0
 800302c:	b318      	cbz	r0, 8003076 <gsl_matrix_complex_float_alloc_from_matrix+0x72>
  m->size1 = n1;
 800302e:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003030:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003032:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003036:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 800303a:	fb06 8603 	mla	r6, r6, r3, r8
 800303e:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003042:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003044:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003048:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 800304c:	4620      	mov	r0, r4
 800304e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003052:	490c      	ldr	r1, [pc, #48]	; (8003084 <gsl_matrix_complex_float_alloc_from_matrix+0x80>)
 8003054:	480c      	ldr	r0, [pc, #48]	; (8003088 <gsl_matrix_complex_float_alloc_from_matrix+0x84>)
 8003056:	2304      	movs	r3, #4
 8003058:	2282      	movs	r2, #130	; 0x82
 800305a:	2400      	movs	r4, #0
 800305c:	f7ff fc00 	bl	8002860 <gsl_error>
}
 8003060:	4620      	mov	r0, r4
 8003062:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003066:	4907      	ldr	r1, [pc, #28]	; (8003084 <gsl_matrix_complex_float_alloc_from_matrix+0x80>)
 8003068:	4808      	ldr	r0, [pc, #32]	; (800308c <gsl_matrix_complex_float_alloc_from_matrix+0x88>)
 800306a:	2304      	movs	r3, #4
 800306c:	227d      	movs	r2, #125	; 0x7d
 800306e:	f7ff fbf7 	bl	8002860 <gsl_error>
 8003072:	2400      	movs	r4, #0
 8003074:	e7ea      	b.n	800304c <gsl_matrix_complex_float_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003076:	4903      	ldr	r1, [pc, #12]	; (8003084 <gsl_matrix_complex_float_alloc_from_matrix+0x80>)
 8003078:	4805      	ldr	r0, [pc, #20]	; (8003090 <gsl_matrix_complex_float_alloc_from_matrix+0x8c>)
 800307a:	2308      	movs	r3, #8
 800307c:	228a      	movs	r2, #138	; 0x8a
 800307e:	f7ff fbef 	bl	8002860 <gsl_error>
 8003082:	e7e3      	b.n	800304c <gsl_matrix_complex_float_alloc_from_matrix+0x48>
 8003084:	08030220 	.word	0x08030220
 8003088:	08030308 	.word	0x08030308
 800308c:	080302d8 	.word	0x080302d8
 8003090:	08030230 	.word	0x08030230

08003094 <gsl_matrix_complex_float_free>:
  RETURN_IF_NULL (m);
 8003094:	b180      	cbz	r0, 80030b8 <gsl_matrix_complex_float_free+0x24>
  if (m->owner)
 8003096:	6943      	ldr	r3, [r0, #20]
{
 8003098:	b510      	push	{r4, lr}
 800309a:	4604      	mov	r4, r0
  if (m->owner)
 800309c:	b923      	cbnz	r3, 80030a8 <gsl_matrix_complex_float_free+0x14>
  free (m);
 800309e:	4620      	mov	r0, r4
}
 80030a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80030a4:	f02c b948 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 80030a8:	6900      	ldr	r0, [r0, #16]
 80030aa:	f003 fd59 	bl	8006b60 <gsl_block_complex_float_free>
  free (m);
 80030ae:	4620      	mov	r0, r4
}
 80030b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80030b4:	f02c b940 	b.w	802f338 <free>
 80030b8:	4770      	bx	lr
 80030ba:	bf00      	nop

080030bc <gsl_matrix_complex_float_set_identity>:
{
 80030bc:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 80030be:	6807      	ldr	r7, [r0, #0]
  const size_t tda = m->tda ;
 80030c0:	1d04      	adds	r4, r0, #4
 80030c2:	e894 5010 	ldmia.w	r4, {r4, ip, lr}
  for (i = 0; i < p; i++)
 80030c6:	b1bf      	cbz	r7, 80030f8 <gsl_matrix_complex_float_set_identity+0x3c>
 80030c8:	2500      	movs	r5, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030ca:	2100      	movs	r1, #0
  for (i = 0; i < p; i++)
 80030cc:	4628      	mov	r0, r5
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030ce:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
      for (j = 0; j < q; j++)
 80030d2:	b16c      	cbz	r4, 80030f0 <gsl_matrix_complex_float_set_identity+0x34>
 80030d4:	eb0e 02c5 	add.w	r2, lr, r5, lsl #3
 80030d8:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030da:	4283      	cmp	r3, r0
      for (j = 0; j < q; j++)
 80030dc:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030e0:	bf0c      	ite	eq
 80030e2:	6016      	streq	r6, [r2, #0]
 80030e4:	6011      	strne	r1, [r2, #0]
      for (j = 0; j < q; j++)
 80030e6:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80030e8:	6051      	str	r1, [r2, #4]
      for (j = 0; j < q; j++)
 80030ea:	f102 0208 	add.w	r2, r2, #8
 80030ee:	d1f4      	bne.n	80030da <gsl_matrix_complex_float_set_identity+0x1e>
  for (i = 0; i < p; i++)
 80030f0:	3001      	adds	r0, #1
 80030f2:	4287      	cmp	r7, r0
 80030f4:	4465      	add	r5, ip
 80030f6:	d1ec      	bne.n	80030d2 <gsl_matrix_complex_float_set_identity+0x16>
}
 80030f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80030fa:	bf00      	nop

080030fc <gsl_matrix_complex_float_set_zero>:
{
 80030fc:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80030fe:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003100:	68c1      	ldr	r1, [r0, #12]
  const size_t tda = m->tda ;
 8003102:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003106:	b197      	cbz	r7, 800312e <gsl_matrix_complex_float_set_zero+0x32>
 8003108:	ebc4 7544 	rsb	r5, r4, r4, lsl #29
 800310c:	00f6      	lsls	r6, r6, #3
 800310e:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 8003112:	00ed      	lsls	r5, r5, #3
 8003114:	2000      	movs	r0, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003116:	2200      	movs	r2, #0
      for (j = 0; j < q; j++)
 8003118:	194b      	adds	r3, r1, r5
 800311a:	b124      	cbz	r4, 8003126 <gsl_matrix_complex_float_set_zero+0x2a>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800311c:	601a      	str	r2, [r3, #0]
 800311e:	605a      	str	r2, [r3, #4]
      for (j = 0; j < q; j++)
 8003120:	3308      	adds	r3, #8
 8003122:	428b      	cmp	r3, r1
 8003124:	d1fa      	bne.n	800311c <gsl_matrix_complex_float_set_zero+0x20>
  for (i = 0; i < p; i++)
 8003126:	3001      	adds	r0, #1
 8003128:	4287      	cmp	r7, r0
 800312a:	4431      	add	r1, r6
 800312c:	d1f4      	bne.n	8003118 <gsl_matrix_complex_float_set_zero+0x1c>
}
 800312e:	bcf0      	pop	{r4, r5, r6, r7}
 8003130:	4770      	bx	lr
 8003132:	bf00      	nop

08003134 <gsl_matrix_complex_float_set_all>:
{
 8003134:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 8003136:	f8d0 e000 	ldr.w	lr, [r0]
  ATOMIC * const data = m->data;
 800313a:	68c5      	ldr	r5, [r0, #12]
{
 800313c:	b083      	sub	sp, #12
  const size_t tda = m->tda ;
 800313e:	e9d0 6301 	ldrd	r6, r3, [r0, #4]
{
 8003142:	ed8d 0a00 	vstr	s0, [sp]
 8003146:	edcd 0a01 	vstr	s1, [sp, #4]
  for (i = 0; i < p; i++)
 800314a:	f1be 0f00 	cmp.w	lr, #0
 800314e:	d012      	beq.n	8003176 <gsl_matrix_complex_float_set_all+0x42>
 8003150:	ea4f 0cc3 	mov.w	ip, r3, lsl #3
 8003154:	2700      	movs	r7, #0
 8003156:	466c      	mov	r4, sp
      for (j = 0; j < q; j++)
 8003158:	2300      	movs	r3, #0
 800315a:	b146      	cbz	r6, 800316e <gsl_matrix_complex_float_set_all+0x3a>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 800315c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8003160:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
      for (j = 0; j < q; j++)
 8003164:	3301      	adds	r3, #1
 8003166:	429e      	cmp	r6, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003168:	e882 0003 	stmia.w	r2, {r0, r1}
      for (j = 0; j < q; j++)
 800316c:	d1f6      	bne.n	800315c <gsl_matrix_complex_float_set_all+0x28>
  for (i = 0; i < p; i++)
 800316e:	3701      	adds	r7, #1
 8003170:	45be      	cmp	lr, r7
 8003172:	4465      	add	r5, ip
 8003174:	d1f0      	bne.n	8003158 <gsl_matrix_complex_float_set_all+0x24>
}
 8003176:	b003      	add	sp, #12
 8003178:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800317a:	bf00      	nop

0800317c <gsl_matrix_long_double_alloc>:
{
 800317c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800317e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003180:	2018      	movs	r0, #24
{
 8003182:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003184:	f02c f8d0 	bl	802f328 <malloc>
  if (m == 0)
 8003188:	4604      	mov	r4, r0
 800318a:	b1b8      	cbz	r0, 80031bc <gsl_matrix_long_double_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800318c:	fb06 f007 	mul.w	r0, r6, r7
 8003190:	f003 fcf2 	bl	8006b78 <gsl_block_long_double_alloc>
  if (block == 0)
 8003194:	4605      	mov	r5, r0
 8003196:	b148      	cbz	r0, 80031ac <gsl_matrix_long_double_alloc+0x30>
  m->data = block->data;
 8003198:	6843      	ldr	r3, [r0, #4]
 800319a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 800319c:	2301      	movs	r3, #1
  m->size2 = n2;
 800319e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 80031a2:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 80031a6:	60a6      	str	r6, [r4, #8]
}
 80031a8:	4620      	mov	r0, r4
 80031aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80031ac:	4907      	ldr	r1, [pc, #28]	; (80031cc <gsl_matrix_long_double_alloc+0x50>)
 80031ae:	4808      	ldr	r0, [pc, #32]	; (80031d0 <gsl_matrix_long_double_alloc+0x54>)
 80031b0:	2308      	movs	r3, #8
 80031b2:	2228      	movs	r2, #40	; 0x28
 80031b4:	462c      	mov	r4, r5
 80031b6:	f7ff fb53 	bl	8002860 <gsl_error>
 80031ba:	e7f5      	b.n	80031a8 <gsl_matrix_long_double_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80031bc:	4903      	ldr	r1, [pc, #12]	; (80031cc <gsl_matrix_long_double_alloc+0x50>)
 80031be:	4805      	ldr	r0, [pc, #20]	; (80031d4 <gsl_matrix_long_double_alloc+0x58>)
 80031c0:	2308      	movs	r3, #8
 80031c2:	221e      	movs	r2, #30
 80031c4:	f7ff fb4c 	bl	8002860 <gsl_error>
 80031c8:	e7ee      	b.n	80031a8 <gsl_matrix_long_double_alloc+0x2c>
 80031ca:	bf00      	nop
 80031cc:	08030220 	.word	0x08030220
 80031d0:	0803025c 	.word	0x0803025c
 80031d4:	08030230 	.word	0x08030230

080031d8 <gsl_matrix_long_double_calloc>:
{
 80031d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80031da:	4604      	mov	r4, r0
 80031dc:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80031de:	f7ff ffcd 	bl	800317c <gsl_matrix_long_double_alloc>
  if (m == 0)
 80031e2:	4605      	mov	r5, r0
 80031e4:	b180      	cbz	r0, 8003208 <gsl_matrix_long_double_calloc+0x30>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80031e6:	fb06 f604 	mul.w	r6, r6, r4
 80031ea:	00f4      	lsls	r4, r6, #3
 80031ec:	68c0      	ldr	r0, [r0, #12]
 80031ee:	4622      	mov	r2, r4
 80031f0:	2100      	movs	r1, #0
 80031f2:	f02c f8a9 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80031f6:	b13e      	cbz	r6, 8003208 <gsl_matrix_long_double_calloc+0x30>
 80031f8:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 80031fa:	2600      	movs	r6, #0
 80031fc:	2700      	movs	r7, #0
 80031fe:	18e2      	adds	r2, r4, r3
 8003200:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003204:	4293      	cmp	r3, r2
 8003206:	d1fb      	bne.n	8003200 <gsl_matrix_long_double_calloc+0x28>
}
 8003208:	4628      	mov	r0, r5
 800320a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800320c <gsl_matrix_long_double_alloc_from_block>:
{
 800320c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003210:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003214:	4599      	cmp	r9, r3
 8003216:	d325      	bcc.n	8003264 <gsl_matrix_long_double_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003218:	4690      	mov	r8, r2
 800321a:	6802      	ldr	r2, [r0, #0]
 800321c:	461e      	mov	r6, r3
 800321e:	fb08 1309 	mla	r3, r8, r9, r1
 8003222:	429a      	cmp	r2, r3
 8003224:	4605      	mov	r5, r0
 8003226:	460f      	mov	r7, r1
 8003228:	d312      	bcc.n	8003250 <gsl_matrix_long_double_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800322a:	2018      	movs	r0, #24
 800322c:	f02c f87c 	bl	802f328 <malloc>
  if (m == 0)
 8003230:	4604      	mov	r4, r0
 8003232:	b1f8      	cbz	r0, 8003274 <gsl_matrix_long_double_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003234:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003236:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800323a:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
  m->tda = d2;
 800323e:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003242:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003246:	2300      	movs	r3, #0
 8003248:	6143      	str	r3, [r0, #20]
}
 800324a:	4620      	mov	r0, r4
 800324c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003250:	490c      	ldr	r1, [pc, #48]	; (8003284 <gsl_matrix_long_double_alloc_from_block+0x78>)
 8003252:	480d      	ldr	r0, [pc, #52]	; (8003288 <gsl_matrix_long_double_alloc_from_block+0x7c>)
 8003254:	2304      	movs	r3, #4
 8003256:	225b      	movs	r2, #91	; 0x5b
 8003258:	2400      	movs	r4, #0
 800325a:	f7ff fb01 	bl	8002860 <gsl_error>
}
 800325e:	4620      	mov	r0, r4
 8003260:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003264:	4907      	ldr	r1, [pc, #28]	; (8003284 <gsl_matrix_long_double_alloc_from_block+0x78>)
 8003266:	4809      	ldr	r0, [pc, #36]	; (800328c <gsl_matrix_long_double_alloc_from_block+0x80>)
 8003268:	2304      	movs	r3, #4
 800326a:	2256      	movs	r2, #86	; 0x56
 800326c:	f7ff faf8 	bl	8002860 <gsl_error>
 8003270:	2400      	movs	r4, #0
 8003272:	e7ea      	b.n	800324a <gsl_matrix_long_double_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003274:	4903      	ldr	r1, [pc, #12]	; (8003284 <gsl_matrix_long_double_alloc_from_block+0x78>)
 8003276:	4806      	ldr	r0, [pc, #24]	; (8003290 <gsl_matrix_long_double_alloc_from_block+0x84>)
 8003278:	2308      	movs	r3, #8
 800327a:	2263      	movs	r2, #99	; 0x63
 800327c:	f7ff faf0 	bl	8002860 <gsl_error>
 8003280:	e7e3      	b.n	800324a <gsl_matrix_long_double_alloc_from_block+0x3e>
 8003282:	bf00      	nop
 8003284:	08030220 	.word	0x08030220
 8003288:	080302ac 	.word	0x080302ac
 800328c:	08030280 	.word	0x08030280
 8003290:	08030230 	.word	0x08030230

08003294 <gsl_matrix_long_double_alloc_from_matrix>:
{
 8003294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003298:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 800329a:	6803      	ldr	r3, [r0, #0]
{
 800329c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80032a0:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 80032a2:	19c8      	adds	r0, r1, r7
 80032a4:	4298      	cmp	r0, r3
 80032a6:	d826      	bhi.n	80032f6 <gsl_matrix_long_double_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80032a8:	686b      	ldr	r3, [r5, #4]
 80032aa:	4690      	mov	r8, r2
 80032ac:	444a      	add	r2, r9
 80032ae:	429a      	cmp	r2, r3
 80032b0:	d817      	bhi.n	80032e2 <gsl_matrix_long_double_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80032b2:	2018      	movs	r0, #24
 80032b4:	460e      	mov	r6, r1
 80032b6:	f02c f837 	bl	802f328 <malloc>
  if (m == 0)
 80032ba:	4604      	mov	r4, r0
 80032bc:	b318      	cbz	r0, 8003306 <gsl_matrix_long_double_alloc_from_matrix+0x72>
  m->size1 = n1;
 80032be:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80032c0:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80032c2:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80032c6:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80032ca:	fb06 8603 	mla	r6, r6, r3, r8
 80032ce:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 80032d2:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 80032d4:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 80032d8:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 80032dc:	4620      	mov	r0, r4
 80032de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 80032e2:	490c      	ldr	r1, [pc, #48]	; (8003314 <gsl_matrix_long_double_alloc_from_matrix+0x80>)
 80032e4:	480c      	ldr	r0, [pc, #48]	; (8003318 <gsl_matrix_long_double_alloc_from_matrix+0x84>)
 80032e6:	2304      	movs	r3, #4
 80032e8:	2282      	movs	r2, #130	; 0x82
 80032ea:	2400      	movs	r4, #0
 80032ec:	f7ff fab8 	bl	8002860 <gsl_error>
}
 80032f0:	4620      	mov	r0, r4
 80032f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 80032f6:	4907      	ldr	r1, [pc, #28]	; (8003314 <gsl_matrix_long_double_alloc_from_matrix+0x80>)
 80032f8:	4808      	ldr	r0, [pc, #32]	; (800331c <gsl_matrix_long_double_alloc_from_matrix+0x88>)
 80032fa:	2304      	movs	r3, #4
 80032fc:	227d      	movs	r2, #125	; 0x7d
 80032fe:	f7ff faaf 	bl	8002860 <gsl_error>
 8003302:	2400      	movs	r4, #0
 8003304:	e7ea      	b.n	80032dc <gsl_matrix_long_double_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003306:	4903      	ldr	r1, [pc, #12]	; (8003314 <gsl_matrix_long_double_alloc_from_matrix+0x80>)
 8003308:	4805      	ldr	r0, [pc, #20]	; (8003320 <gsl_matrix_long_double_alloc_from_matrix+0x8c>)
 800330a:	2308      	movs	r3, #8
 800330c:	228a      	movs	r2, #138	; 0x8a
 800330e:	f7ff faa7 	bl	8002860 <gsl_error>
 8003312:	e7e3      	b.n	80032dc <gsl_matrix_long_double_alloc_from_matrix+0x48>
 8003314:	08030220 	.word	0x08030220
 8003318:	08030308 	.word	0x08030308
 800331c:	080302d8 	.word	0x080302d8
 8003320:	08030230 	.word	0x08030230

08003324 <gsl_matrix_long_double_free>:
  RETURN_IF_NULL (m);
 8003324:	b180      	cbz	r0, 8003348 <gsl_matrix_long_double_free+0x24>
  if (m->owner)
 8003326:	6943      	ldr	r3, [r0, #20]
{
 8003328:	b510      	push	{r4, lr}
 800332a:	4604      	mov	r4, r0
  if (m->owner)
 800332c:	b923      	cbnz	r3, 8003338 <gsl_matrix_long_double_free+0x14>
  free (m);
 800332e:	4620      	mov	r0, r4
}
 8003330:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003334:	f02c b800 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003338:	6900      	ldr	r0, [r0, #16]
 800333a:	f003 fc5f 	bl	8006bfc <gsl_block_long_double_free>
  free (m);
 800333e:	4620      	mov	r0, r4
}
 8003340:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003344:	f02b bff8 	b.w	802f338 <free>
 8003348:	4770      	bx	lr
 800334a:	bf00      	nop

0800334c <gsl_matrix_long_double_set_identity>:
{
 800334c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const size_t p = m->size1 ;
 8003350:	f8d0 e000 	ldr.w	lr, [r0]
  const size_t tda = m->tda ;
 8003354:	1d05      	adds	r5, r0, #4
 8003356:	e895 0c20 	ldmia.w	r5, {r5, sl, fp}
  for (i = 0; i < p; i++)
 800335a:	f1be 0f00 	cmp.w	lr, #0
 800335e:	d01c      	beq.n	800339a <gsl_matrix_long_double_set_identity+0x4e>
 8003360:	f04f 0c00 	mov.w	ip, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003364:	f8df 9038 	ldr.w	r9, [pc, #56]	; 80033a0 <gsl_matrix_long_double_set_identity+0x54>
 8003368:	f04f 0800 	mov.w	r8, #0
 800336c:	2600      	movs	r6, #0
 800336e:	2700      	movs	r7, #0
  for (i = 0; i < p; i++)
 8003370:	4664      	mov	r4, ip
      for (j = 0; j < q; j++)
 8003372:	b175      	cbz	r5, 8003392 <gsl_matrix_long_double_set_identity+0x46>
 8003374:	eb0b 02cc 	add.w	r2, fp, ip, lsl #3
 8003378:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800337a:	429c      	cmp	r4, r3
      for (j = 0; j < q; j++)
 800337c:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003380:	bf19      	ittee	ne
 8003382:	4630      	movne	r0, r6
 8003384:	4639      	movne	r1, r7
 8003386:	4640      	moveq	r0, r8
 8003388:	4649      	moveq	r1, r9
      for (j = 0; j < q; j++)
 800338a:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800338c:	e8e2 0102 	strd	r0, r1, [r2], #8
      for (j = 0; j < q; j++)
 8003390:	d1f3      	bne.n	800337a <gsl_matrix_long_double_set_identity+0x2e>
  for (i = 0; i < p; i++)
 8003392:	3401      	adds	r4, #1
 8003394:	45a6      	cmp	lr, r4
 8003396:	44d4      	add	ip, sl
 8003398:	d1eb      	bne.n	8003372 <gsl_matrix_long_double_set_identity+0x26>
}
 800339a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800339e:	bf00      	nop
 80033a0:	3ff00000 	.word	0x3ff00000

080033a4 <gsl_matrix_long_double_set_zero>:
  const size_t p = m->size1 ;
 80033a4:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 80033a8:	68c2      	ldr	r2, [r0, #12]
{
 80033aa:	b4f0      	push	{r4, r5, r6, r7}
  const size_t tda = m->tda ;
 80033ac:	e9d0 5701 	ldrd	r5, r7, [r0, #4]
  for (i = 0; i < p; i++)
 80033b0:	f1bc 0f00 	cmp.w	ip, #0
 80033b4:	d012      	beq.n	80033dc <gsl_matrix_long_double_set_zero+0x38>
 80033b6:	ebc5 7645 	rsb	r6, r5, r5, lsl #29
 80033ba:	00ff      	lsls	r7, r7, #3
 80033bc:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 80033c0:	00f6      	lsls	r6, r6, #3
 80033c2:	2400      	movs	r4, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80033c4:	2000      	movs	r0, #0
 80033c6:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 80033c8:	1993      	adds	r3, r2, r6
 80033ca:	b11d      	cbz	r5, 80033d4 <gsl_matrix_long_double_set_zero+0x30>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80033cc:	e8e3 0102 	strd	r0, r1, [r3], #8
      for (j = 0; j < q; j++)
 80033d0:	4293      	cmp	r3, r2
 80033d2:	d1fb      	bne.n	80033cc <gsl_matrix_long_double_set_zero+0x28>
  for (i = 0; i < p; i++)
 80033d4:	3401      	adds	r4, #1
 80033d6:	45a4      	cmp	ip, r4
 80033d8:	443a      	add	r2, r7
 80033da:	d1f5      	bne.n	80033c8 <gsl_matrix_long_double_set_zero+0x24>
}
 80033dc:	bcf0      	pop	{r4, r5, r6, r7}
 80033de:	4770      	bx	lr

080033e0 <gsl_matrix_long_double_set_all>:
{
 80033e0:	b470      	push	{r4, r5, r6}
  const size_t p = m->size1 ;
 80033e2:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80033e4:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80033e6:	e9d0 4501 	ldrd	r4, r5, [r0, #4]
  for (i = 0; i < p; i++)
 80033ea:	b186      	cbz	r6, 800340e <gsl_matrix_long_double_set_all+0x2e>
 80033ec:	ebc4 7044 	rsb	r0, r4, r4, lsl #29
 80033f0:	00ed      	lsls	r5, r5, #3
 80033f2:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80033f6:	00c0      	lsls	r0, r0, #3
 80033f8:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 80033fa:	1813      	adds	r3, r2, r0
 80033fc:	b11c      	cbz	r4, 8003406 <gsl_matrix_long_double_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 80033fe:	eca3 0b02 	vstmia	r3!, {d0}
      for (j = 0; j < q; j++)
 8003402:	4293      	cmp	r3, r2
 8003404:	d1fb      	bne.n	80033fe <gsl_matrix_long_double_set_all+0x1e>
  for (i = 0; i < p; i++)
 8003406:	3101      	adds	r1, #1
 8003408:	428e      	cmp	r6, r1
 800340a:	442a      	add	r2, r5
 800340c:	d1f5      	bne.n	80033fa <gsl_matrix_long_double_set_all+0x1a>
}
 800340e:	bc70      	pop	{r4, r5, r6}
 8003410:	4770      	bx	lr
 8003412:	bf00      	nop

08003414 <gsl_matrix_alloc>:
{
 8003414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003416:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003418:	2018      	movs	r0, #24
{
 800341a:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800341c:	f02b ff84 	bl	802f328 <malloc>
  if (m == 0)
 8003420:	4604      	mov	r4, r0
 8003422:	b1b8      	cbz	r0, 8003454 <gsl_matrix_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8003424:	fb06 f007 	mul.w	r0, r6, r7
 8003428:	f003 fbf4 	bl	8006c14 <gsl_block_alloc>
  if (block == 0)
 800342c:	4605      	mov	r5, r0
 800342e:	b148      	cbz	r0, 8003444 <gsl_matrix_alloc+0x30>
  m->data = block->data;
 8003430:	6843      	ldr	r3, [r0, #4]
 8003432:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8003434:	2301      	movs	r3, #1
  m->size2 = n2;
 8003436:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 800343a:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 800343e:	60a6      	str	r6, [r4, #8]
}
 8003440:	4620      	mov	r0, r4
 8003442:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8003444:	4907      	ldr	r1, [pc, #28]	; (8003464 <gsl_matrix_alloc+0x50>)
 8003446:	4808      	ldr	r0, [pc, #32]	; (8003468 <gsl_matrix_alloc+0x54>)
 8003448:	2308      	movs	r3, #8
 800344a:	2228      	movs	r2, #40	; 0x28
 800344c:	462c      	mov	r4, r5
 800344e:	f7ff fa07 	bl	8002860 <gsl_error>
 8003452:	e7f5      	b.n	8003440 <gsl_matrix_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003454:	4903      	ldr	r1, [pc, #12]	; (8003464 <gsl_matrix_alloc+0x50>)
 8003456:	4805      	ldr	r0, [pc, #20]	; (800346c <gsl_matrix_alloc+0x58>)
 8003458:	2308      	movs	r3, #8
 800345a:	221e      	movs	r2, #30
 800345c:	f7ff fa00 	bl	8002860 <gsl_error>
 8003460:	e7ee      	b.n	8003440 <gsl_matrix_alloc+0x2c>
 8003462:	bf00      	nop
 8003464:	08030220 	.word	0x08030220
 8003468:	0803025c 	.word	0x0803025c
 800346c:	08030230 	.word	0x08030230

08003470 <gsl_matrix_calloc>:
{
 8003470:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003472:	4604      	mov	r4, r0
 8003474:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8003476:	f7ff ffcd 	bl	8003414 <gsl_matrix_alloc>
  if (m == 0)
 800347a:	4605      	mov	r5, r0
 800347c:	b180      	cbz	r0, 80034a0 <gsl_matrix_calloc+0x30>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 800347e:	fb06 f604 	mul.w	r6, r6, r4
 8003482:	00f4      	lsls	r4, r6, #3
 8003484:	68c0      	ldr	r0, [r0, #12]
 8003486:	4622      	mov	r2, r4
 8003488:	2100      	movs	r1, #0
 800348a:	f02b ff5d 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 800348e:	b13e      	cbz	r6, 80034a0 <gsl_matrix_calloc+0x30>
 8003490:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 8003492:	2600      	movs	r6, #0
 8003494:	2700      	movs	r7, #0
 8003496:	18e2      	adds	r2, r4, r3
 8003498:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 800349c:	4293      	cmp	r3, r2
 800349e:	d1fb      	bne.n	8003498 <gsl_matrix_calloc+0x28>
}
 80034a0:	4628      	mov	r0, r5
 80034a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080034a4 <gsl_matrix_alloc_from_block>:
{
 80034a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80034a8:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 80034ac:	4599      	cmp	r9, r3
 80034ae:	d325      	bcc.n	80034fc <gsl_matrix_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 80034b0:	4690      	mov	r8, r2
 80034b2:	6802      	ldr	r2, [r0, #0]
 80034b4:	461e      	mov	r6, r3
 80034b6:	fb08 1309 	mla	r3, r8, r9, r1
 80034ba:	429a      	cmp	r2, r3
 80034bc:	4605      	mov	r5, r0
 80034be:	460f      	mov	r7, r1
 80034c0:	d312      	bcc.n	80034e8 <gsl_matrix_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80034c2:	2018      	movs	r0, #24
 80034c4:	f02b ff30 	bl	802f328 <malloc>
  if (m == 0)
 80034c8:	4604      	mov	r4, r0
 80034ca:	b1f8      	cbz	r0, 800350c <gsl_matrix_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 80034cc:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 80034ce:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 80034d2:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
  m->tda = d2;
 80034d6:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80034da:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80034de:	2300      	movs	r3, #0
 80034e0:	6143      	str	r3, [r0, #20]
}
 80034e2:	4620      	mov	r0, r4
 80034e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 80034e8:	490c      	ldr	r1, [pc, #48]	; (800351c <gsl_matrix_alloc_from_block+0x78>)
 80034ea:	480d      	ldr	r0, [pc, #52]	; (8003520 <gsl_matrix_alloc_from_block+0x7c>)
 80034ec:	2304      	movs	r3, #4
 80034ee:	225b      	movs	r2, #91	; 0x5b
 80034f0:	2400      	movs	r4, #0
 80034f2:	f7ff f9b5 	bl	8002860 <gsl_error>
}
 80034f6:	4620      	mov	r0, r4
 80034f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 80034fc:	4907      	ldr	r1, [pc, #28]	; (800351c <gsl_matrix_alloc_from_block+0x78>)
 80034fe:	4809      	ldr	r0, [pc, #36]	; (8003524 <gsl_matrix_alloc_from_block+0x80>)
 8003500:	2304      	movs	r3, #4
 8003502:	2256      	movs	r2, #86	; 0x56
 8003504:	f7ff f9ac 	bl	8002860 <gsl_error>
 8003508:	2400      	movs	r4, #0
 800350a:	e7ea      	b.n	80034e2 <gsl_matrix_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800350c:	4903      	ldr	r1, [pc, #12]	; (800351c <gsl_matrix_alloc_from_block+0x78>)
 800350e:	4806      	ldr	r0, [pc, #24]	; (8003528 <gsl_matrix_alloc_from_block+0x84>)
 8003510:	2308      	movs	r3, #8
 8003512:	2263      	movs	r2, #99	; 0x63
 8003514:	f7ff f9a4 	bl	8002860 <gsl_error>
 8003518:	e7e3      	b.n	80034e2 <gsl_matrix_alloc_from_block+0x3e>
 800351a:	bf00      	nop
 800351c:	08030220 	.word	0x08030220
 8003520:	080302ac 	.word	0x080302ac
 8003524:	08030280 	.word	0x08030280
 8003528:	08030230 	.word	0x08030230

0800352c <gsl_matrix_alloc_from_matrix>:
{
 800352c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003530:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003532:	6803      	ldr	r3, [r0, #0]
{
 8003534:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003538:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 800353a:	19c8      	adds	r0, r1, r7
 800353c:	4298      	cmp	r0, r3
 800353e:	d826      	bhi.n	800358e <gsl_matrix_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003540:	686b      	ldr	r3, [r5, #4]
 8003542:	4690      	mov	r8, r2
 8003544:	444a      	add	r2, r9
 8003546:	429a      	cmp	r2, r3
 8003548:	d817      	bhi.n	800357a <gsl_matrix_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800354a:	2018      	movs	r0, #24
 800354c:	460e      	mov	r6, r1
 800354e:	f02b feeb 	bl	802f328 <malloc>
  if (m == 0)
 8003552:	4604      	mov	r4, r0
 8003554:	b318      	cbz	r0, 800359e <gsl_matrix_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003556:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003558:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 800355a:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 800355e:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003562:	fb06 8603 	mla	r6, r6, r3, r8
 8003566:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
  m->owner = 0;
 800356a:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 800356c:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003570:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003574:	4620      	mov	r0, r4
 8003576:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 800357a:	490c      	ldr	r1, [pc, #48]	; (80035ac <gsl_matrix_alloc_from_matrix+0x80>)
 800357c:	480c      	ldr	r0, [pc, #48]	; (80035b0 <gsl_matrix_alloc_from_matrix+0x84>)
 800357e:	2304      	movs	r3, #4
 8003580:	2282      	movs	r2, #130	; 0x82
 8003582:	2400      	movs	r4, #0
 8003584:	f7ff f96c 	bl	8002860 <gsl_error>
}
 8003588:	4620      	mov	r0, r4
 800358a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 800358e:	4907      	ldr	r1, [pc, #28]	; (80035ac <gsl_matrix_alloc_from_matrix+0x80>)
 8003590:	4808      	ldr	r0, [pc, #32]	; (80035b4 <gsl_matrix_alloc_from_matrix+0x88>)
 8003592:	2304      	movs	r3, #4
 8003594:	227d      	movs	r2, #125	; 0x7d
 8003596:	f7ff f963 	bl	8002860 <gsl_error>
 800359a:	2400      	movs	r4, #0
 800359c:	e7ea      	b.n	8003574 <gsl_matrix_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800359e:	4903      	ldr	r1, [pc, #12]	; (80035ac <gsl_matrix_alloc_from_matrix+0x80>)
 80035a0:	4805      	ldr	r0, [pc, #20]	; (80035b8 <gsl_matrix_alloc_from_matrix+0x8c>)
 80035a2:	2308      	movs	r3, #8
 80035a4:	228a      	movs	r2, #138	; 0x8a
 80035a6:	f7ff f95b 	bl	8002860 <gsl_error>
 80035aa:	e7e3      	b.n	8003574 <gsl_matrix_alloc_from_matrix+0x48>
 80035ac:	08030220 	.word	0x08030220
 80035b0:	08030308 	.word	0x08030308
 80035b4:	080302d8 	.word	0x080302d8
 80035b8:	08030230 	.word	0x08030230

080035bc <gsl_matrix_free>:
  RETURN_IF_NULL (m);
 80035bc:	b180      	cbz	r0, 80035e0 <gsl_matrix_free+0x24>
  if (m->owner)
 80035be:	6943      	ldr	r3, [r0, #20]
{
 80035c0:	b510      	push	{r4, lr}
 80035c2:	4604      	mov	r4, r0
  if (m->owner)
 80035c4:	b923      	cbnz	r3, 80035d0 <gsl_matrix_free+0x14>
  free (m);
 80035c6:	4620      	mov	r0, r4
}
 80035c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80035cc:	f02b beb4 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 80035d0:	6900      	ldr	r0, [r0, #16]
 80035d2:	f003 fb61 	bl	8006c98 <gsl_block_free>
  free (m);
 80035d6:	4620      	mov	r0, r4
}
 80035d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80035dc:	f02b beac 	b.w	802f338 <free>
 80035e0:	4770      	bx	lr
 80035e2:	bf00      	nop

080035e4 <gsl_matrix_set_identity>:
{
 80035e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const size_t p = m->size1 ;
 80035e8:	f8d0 e000 	ldr.w	lr, [r0]
  const size_t tda = m->tda ;
 80035ec:	1d05      	adds	r5, r0, #4
 80035ee:	e895 0c20 	ldmia.w	r5, {r5, sl, fp}
  for (i = 0; i < p; i++)
 80035f2:	f1be 0f00 	cmp.w	lr, #0
 80035f6:	d01c      	beq.n	8003632 <gsl_matrix_set_identity+0x4e>
 80035f8:	f04f 0c00 	mov.w	ip, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80035fc:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8003638 <gsl_matrix_set_identity+0x54>
 8003600:	f04f 0800 	mov.w	r8, #0
 8003604:	2600      	movs	r6, #0
 8003606:	2700      	movs	r7, #0
  for (i = 0; i < p; i++)
 8003608:	4664      	mov	r4, ip
      for (j = 0; j < q; j++)
 800360a:	b175      	cbz	r5, 800362a <gsl_matrix_set_identity+0x46>
 800360c:	eb0b 02cc 	add.w	r2, fp, ip, lsl #3
 8003610:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003612:	429c      	cmp	r4, r3
      for (j = 0; j < q; j++)
 8003614:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003618:	bf19      	ittee	ne
 800361a:	4630      	movne	r0, r6
 800361c:	4639      	movne	r1, r7
 800361e:	4640      	moveq	r0, r8
 8003620:	4649      	moveq	r1, r9
      for (j = 0; j < q; j++)
 8003622:	429d      	cmp	r5, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003624:	e8e2 0102 	strd	r0, r1, [r2], #8
      for (j = 0; j < q; j++)
 8003628:	d1f3      	bne.n	8003612 <gsl_matrix_set_identity+0x2e>
  for (i = 0; i < p; i++)
 800362a:	3401      	adds	r4, #1
 800362c:	45a6      	cmp	lr, r4
 800362e:	44d4      	add	ip, sl
 8003630:	d1eb      	bne.n	800360a <gsl_matrix_set_identity+0x26>
}
 8003632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003636:	bf00      	nop
 8003638:	3ff00000 	.word	0x3ff00000

0800363c <gsl_matrix_set_zero>:
  const size_t p = m->size1 ;
 800363c:	f8d0 c000 	ldr.w	ip, [r0]
  ATOMIC * const data = m->data;
 8003640:	68c2      	ldr	r2, [r0, #12]
{
 8003642:	b4f0      	push	{r4, r5, r6, r7}
  const size_t tda = m->tda ;
 8003644:	e9d0 5701 	ldrd	r5, r7, [r0, #4]
  for (i = 0; i < p; i++)
 8003648:	f1bc 0f00 	cmp.w	ip, #0
 800364c:	d012      	beq.n	8003674 <gsl_matrix_set_zero+0x38>
 800364e:	ebc5 7645 	rsb	r6, r5, r5, lsl #29
 8003652:	00ff      	lsls	r7, r7, #3
 8003654:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 8003658:	00f6      	lsls	r6, r6, #3
 800365a:	2400      	movs	r4, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800365c:	2000      	movs	r0, #0
 800365e:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8003660:	1993      	adds	r3, r2, r6
 8003662:	b11d      	cbz	r5, 800366c <gsl_matrix_set_zero+0x30>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003664:	e8e3 0102 	strd	r0, r1, [r3], #8
      for (j = 0; j < q; j++)
 8003668:	4293      	cmp	r3, r2
 800366a:	d1fb      	bne.n	8003664 <gsl_matrix_set_zero+0x28>
  for (i = 0; i < p; i++)
 800366c:	3401      	adds	r4, #1
 800366e:	45a4      	cmp	ip, r4
 8003670:	443a      	add	r2, r7
 8003672:	d1f5      	bne.n	8003660 <gsl_matrix_set_zero+0x24>
}
 8003674:	bcf0      	pop	{r4, r5, r6, r7}
 8003676:	4770      	bx	lr

08003678 <gsl_matrix_set_all>:
{
 8003678:	b470      	push	{r4, r5, r6}
  const size_t p = m->size1 ;
 800367a:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 800367c:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800367e:	e9d0 4501 	ldrd	r4, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8003682:	b186      	cbz	r6, 80036a6 <gsl_matrix_set_all+0x2e>
 8003684:	ebc4 7044 	rsb	r0, r4, r4, lsl #29
 8003688:	00ed      	lsls	r5, r5, #3
 800368a:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 800368e:	00c0      	lsls	r0, r0, #3
 8003690:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8003692:	1813      	adds	r3, r2, r0
 8003694:	b11c      	cbz	r4, 800369e <gsl_matrix_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003696:	eca3 0b02 	vstmia	r3!, {d0}
      for (j = 0; j < q; j++)
 800369a:	4293      	cmp	r3, r2
 800369c:	d1fb      	bne.n	8003696 <gsl_matrix_set_all+0x1e>
  for (i = 0; i < p; i++)
 800369e:	3101      	adds	r1, #1
 80036a0:	428e      	cmp	r6, r1
 80036a2:	442a      	add	r2, r5
 80036a4:	d1f5      	bne.n	8003692 <gsl_matrix_set_all+0x1a>
}
 80036a6:	bc70      	pop	{r4, r5, r6}
 80036a8:	4770      	bx	lr
 80036aa:	bf00      	nop

080036ac <gsl_matrix_float_alloc>:
{
 80036ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80036ae:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80036b0:	2018      	movs	r0, #24
{
 80036b2:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80036b4:	f02b fe38 	bl	802f328 <malloc>
  if (m == 0)
 80036b8:	4604      	mov	r4, r0
 80036ba:	b1b8      	cbz	r0, 80036ec <gsl_matrix_float_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 80036bc:	fb06 f007 	mul.w	r0, r6, r7
 80036c0:	f003 faf6 	bl	8006cb0 <gsl_block_float_alloc>
  if (block == 0)
 80036c4:	4605      	mov	r5, r0
 80036c6:	b148      	cbz	r0, 80036dc <gsl_matrix_float_alloc+0x30>
  m->data = block->data;
 80036c8:	6843      	ldr	r3, [r0, #4]
 80036ca:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 80036cc:	2301      	movs	r3, #1
  m->size2 = n2;
 80036ce:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 80036d2:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 80036d6:	60a6      	str	r6, [r4, #8]
}
 80036d8:	4620      	mov	r0, r4
 80036da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80036dc:	4907      	ldr	r1, [pc, #28]	; (80036fc <gsl_matrix_float_alloc+0x50>)
 80036de:	4808      	ldr	r0, [pc, #32]	; (8003700 <gsl_matrix_float_alloc+0x54>)
 80036e0:	2308      	movs	r3, #8
 80036e2:	2228      	movs	r2, #40	; 0x28
 80036e4:	462c      	mov	r4, r5
 80036e6:	f7ff f8bb 	bl	8002860 <gsl_error>
 80036ea:	e7f5      	b.n	80036d8 <gsl_matrix_float_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80036ec:	4903      	ldr	r1, [pc, #12]	; (80036fc <gsl_matrix_float_alloc+0x50>)
 80036ee:	4805      	ldr	r0, [pc, #20]	; (8003704 <gsl_matrix_float_alloc+0x58>)
 80036f0:	2308      	movs	r3, #8
 80036f2:	221e      	movs	r2, #30
 80036f4:	f7ff f8b4 	bl	8002860 <gsl_error>
 80036f8:	e7ee      	b.n	80036d8 <gsl_matrix_float_alloc+0x2c>
 80036fa:	bf00      	nop
 80036fc:	08030220 	.word	0x08030220
 8003700:	0803025c 	.word	0x0803025c
 8003704:	08030230 	.word	0x08030230

08003708 <gsl_matrix_float_calloc>:
{
 8003708:	b570      	push	{r4, r5, r6, lr}
 800370a:	4604      	mov	r4, r0
 800370c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 800370e:	f7ff ffcd 	bl	80036ac <gsl_matrix_float_alloc>
  if (m == 0)
 8003712:	4605      	mov	r5, r0
 8003714:	b178      	cbz	r0, 8003736 <gsl_matrix_float_calloc+0x2e>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003716:	fb06 f604 	mul.w	r6, r6, r4
 800371a:	00b4      	lsls	r4, r6, #2
 800371c:	68c0      	ldr	r0, [r0, #12]
 800371e:	4622      	mov	r2, r4
 8003720:	2100      	movs	r1, #0
 8003722:	f02b fe11 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003726:	b136      	cbz	r6, 8003736 <gsl_matrix_float_calloc+0x2e>
 8003728:	68eb      	ldr	r3, [r5, #12]
      m->data[i] = 0;
 800372a:	2100      	movs	r1, #0
 800372c:	18e2      	adds	r2, r4, r3
 800372e:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003732:	4293      	cmp	r3, r2
 8003734:	d1fb      	bne.n	800372e <gsl_matrix_float_calloc+0x26>
}
 8003736:	4628      	mov	r0, r5
 8003738:	bd70      	pop	{r4, r5, r6, pc}
 800373a:	bf00      	nop

0800373c <gsl_matrix_float_alloc_from_block>:
{
 800373c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003740:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003744:	4599      	cmp	r9, r3
 8003746:	d325      	bcc.n	8003794 <gsl_matrix_float_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003748:	4690      	mov	r8, r2
 800374a:	6802      	ldr	r2, [r0, #0]
 800374c:	461e      	mov	r6, r3
 800374e:	fb08 1309 	mla	r3, r8, r9, r1
 8003752:	429a      	cmp	r2, r3
 8003754:	4605      	mov	r5, r0
 8003756:	460f      	mov	r7, r1
 8003758:	d312      	bcc.n	8003780 <gsl_matrix_float_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800375a:	2018      	movs	r0, #24
 800375c:	f02b fde4 	bl	802f328 <malloc>
  if (m == 0)
 8003760:	4604      	mov	r4, r0
 8003762:	b1f8      	cbz	r0, 80037a4 <gsl_matrix_float_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003764:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003766:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800376a:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 800376e:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003772:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003776:	2300      	movs	r3, #0
 8003778:	6143      	str	r3, [r0, #20]
}
 800377a:	4620      	mov	r0, r4
 800377c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003780:	490c      	ldr	r1, [pc, #48]	; (80037b4 <gsl_matrix_float_alloc_from_block+0x78>)
 8003782:	480d      	ldr	r0, [pc, #52]	; (80037b8 <gsl_matrix_float_alloc_from_block+0x7c>)
 8003784:	2304      	movs	r3, #4
 8003786:	225b      	movs	r2, #91	; 0x5b
 8003788:	2400      	movs	r4, #0
 800378a:	f7ff f869 	bl	8002860 <gsl_error>
}
 800378e:	4620      	mov	r0, r4
 8003790:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003794:	4907      	ldr	r1, [pc, #28]	; (80037b4 <gsl_matrix_float_alloc_from_block+0x78>)
 8003796:	4809      	ldr	r0, [pc, #36]	; (80037bc <gsl_matrix_float_alloc_from_block+0x80>)
 8003798:	2304      	movs	r3, #4
 800379a:	2256      	movs	r2, #86	; 0x56
 800379c:	f7ff f860 	bl	8002860 <gsl_error>
 80037a0:	2400      	movs	r4, #0
 80037a2:	e7ea      	b.n	800377a <gsl_matrix_float_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80037a4:	4903      	ldr	r1, [pc, #12]	; (80037b4 <gsl_matrix_float_alloc_from_block+0x78>)
 80037a6:	4806      	ldr	r0, [pc, #24]	; (80037c0 <gsl_matrix_float_alloc_from_block+0x84>)
 80037a8:	2308      	movs	r3, #8
 80037aa:	2263      	movs	r2, #99	; 0x63
 80037ac:	f7ff f858 	bl	8002860 <gsl_error>
 80037b0:	e7e3      	b.n	800377a <gsl_matrix_float_alloc_from_block+0x3e>
 80037b2:	bf00      	nop
 80037b4:	08030220 	.word	0x08030220
 80037b8:	080302ac 	.word	0x080302ac
 80037bc:	08030280 	.word	0x08030280
 80037c0:	08030230 	.word	0x08030230

080037c4 <gsl_matrix_float_alloc_from_matrix>:
{
 80037c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80037c8:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 80037ca:	6803      	ldr	r3, [r0, #0]
{
 80037cc:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80037d0:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 80037d2:	19c8      	adds	r0, r1, r7
 80037d4:	4298      	cmp	r0, r3
 80037d6:	d826      	bhi.n	8003826 <gsl_matrix_float_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80037d8:	686b      	ldr	r3, [r5, #4]
 80037da:	4690      	mov	r8, r2
 80037dc:	444a      	add	r2, r9
 80037de:	429a      	cmp	r2, r3
 80037e0:	d817      	bhi.n	8003812 <gsl_matrix_float_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80037e2:	2018      	movs	r0, #24
 80037e4:	460e      	mov	r6, r1
 80037e6:	f02b fd9f 	bl	802f328 <malloc>
  if (m == 0)
 80037ea:	4604      	mov	r4, r0
 80037ec:	b318      	cbz	r0, 8003836 <gsl_matrix_float_alloc_from_matrix+0x72>
  m->size1 = n1;
 80037ee:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80037f0:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80037f2:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80037f6:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80037fa:	fb06 8603 	mla	r6, r6, r3, r8
 80037fe:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003802:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003804:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003808:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 800380c:	4620      	mov	r0, r4
 800380e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003812:	490c      	ldr	r1, [pc, #48]	; (8003844 <gsl_matrix_float_alloc_from_matrix+0x80>)
 8003814:	480c      	ldr	r0, [pc, #48]	; (8003848 <gsl_matrix_float_alloc_from_matrix+0x84>)
 8003816:	2304      	movs	r3, #4
 8003818:	2282      	movs	r2, #130	; 0x82
 800381a:	2400      	movs	r4, #0
 800381c:	f7ff f820 	bl	8002860 <gsl_error>
}
 8003820:	4620      	mov	r0, r4
 8003822:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003826:	4907      	ldr	r1, [pc, #28]	; (8003844 <gsl_matrix_float_alloc_from_matrix+0x80>)
 8003828:	4808      	ldr	r0, [pc, #32]	; (800384c <gsl_matrix_float_alloc_from_matrix+0x88>)
 800382a:	2304      	movs	r3, #4
 800382c:	227d      	movs	r2, #125	; 0x7d
 800382e:	f7ff f817 	bl	8002860 <gsl_error>
 8003832:	2400      	movs	r4, #0
 8003834:	e7ea      	b.n	800380c <gsl_matrix_float_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003836:	4903      	ldr	r1, [pc, #12]	; (8003844 <gsl_matrix_float_alloc_from_matrix+0x80>)
 8003838:	4805      	ldr	r0, [pc, #20]	; (8003850 <gsl_matrix_float_alloc_from_matrix+0x8c>)
 800383a:	2308      	movs	r3, #8
 800383c:	228a      	movs	r2, #138	; 0x8a
 800383e:	f7ff f80f 	bl	8002860 <gsl_error>
 8003842:	e7e3      	b.n	800380c <gsl_matrix_float_alloc_from_matrix+0x48>
 8003844:	08030220 	.word	0x08030220
 8003848:	08030308 	.word	0x08030308
 800384c:	080302d8 	.word	0x080302d8
 8003850:	08030230 	.word	0x08030230

08003854 <gsl_matrix_float_free>:
  RETURN_IF_NULL (m);
 8003854:	b180      	cbz	r0, 8003878 <gsl_matrix_float_free+0x24>
  if (m->owner)
 8003856:	6943      	ldr	r3, [r0, #20]
{
 8003858:	b510      	push	{r4, lr}
 800385a:	4604      	mov	r4, r0
  if (m->owner)
 800385c:	b923      	cbnz	r3, 8003868 <gsl_matrix_float_free+0x14>
  free (m);
 800385e:	4620      	mov	r0, r4
}
 8003860:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003864:	f02b bd68 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003868:	6900      	ldr	r0, [r0, #16]
 800386a:	f003 fa61 	bl	8006d30 <gsl_block_float_free>
  free (m);
 800386e:	4620      	mov	r0, r4
}
 8003870:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003874:	f02b bd60 	b.w	802f338 <free>
 8003878:	4770      	bx	lr
 800387a:	bf00      	nop

0800387c <gsl_matrix_float_set_identity>:
{
 800387c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800387e:	6805      	ldr	r5, [r0, #0]
  const size_t tda = m->tda ;
 8003880:	1d04      	adds	r4, r0, #4
 8003882:	ccd0      	ldmia	r4, {r4, r6, r7}
  for (i = 0; i < p; i++)
 8003884:	b1cd      	cbz	r5, 80038ba <gsl_matrix_float_set_identity+0x3e>
 8003886:	2000      	movs	r0, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003888:	eddf 6a0d 	vldr	s13, [pc, #52]	; 80038c0 <gsl_matrix_float_set_identity+0x44>
  for (i = 0; i < p; i++)
 800388c:	4601      	mov	r1, r0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800388e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
      for (j = 0; j < q; j++)
 8003892:	b174      	cbz	r4, 80038b2 <gsl_matrix_float_set_identity+0x36>
 8003894:	eb07 0280 	add.w	r2, r7, r0, lsl #2
 8003898:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800389a:	4299      	cmp	r1, r3
      for (j = 0; j < q; j++)
 800389c:	f103 0301 	add.w	r3, r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80038a0:	bf14      	ite	ne
 80038a2:	eef0 7a66 	vmovne.f32	s15, s13
 80038a6:	eef0 7a47 	vmoveq.f32	s15, s14
      for (j = 0; j < q; j++)
 80038aa:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80038ac:	ece2 7a01 	vstmia	r2!, {s15}
      for (j = 0; j < q; j++)
 80038b0:	d1f3      	bne.n	800389a <gsl_matrix_float_set_identity+0x1e>
  for (i = 0; i < p; i++)
 80038b2:	3101      	adds	r1, #1
 80038b4:	428d      	cmp	r5, r1
 80038b6:	4430      	add	r0, r6
 80038b8:	d1eb      	bne.n	8003892 <gsl_matrix_float_set_identity+0x16>
}
 80038ba:	bcf0      	pop	{r4, r5, r6, r7}
 80038bc:	4770      	bx	lr
 80038be:	bf00      	nop
 80038c0:	00000000 	.word	0x00000000

080038c4 <gsl_matrix_float_set_zero>:
{
 80038c4:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80038c6:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80038c8:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80038ca:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 80038ce:	b18f      	cbz	r7, 80038f4 <gsl_matrix_float_set_zero+0x30>
 80038d0:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 80038d4:	00b6      	lsls	r6, r6, #2
 80038d6:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80038da:	00ad      	lsls	r5, r5, #2
 80038dc:	2000      	movs	r0, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80038de:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 80038e0:	1953      	adds	r3, r2, r5
 80038e2:	b11c      	cbz	r4, 80038ec <gsl_matrix_float_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80038e4:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 80038e8:	4293      	cmp	r3, r2
 80038ea:	d1fb      	bne.n	80038e4 <gsl_matrix_float_set_zero+0x20>
  for (i = 0; i < p; i++)
 80038ec:	3001      	adds	r0, #1
 80038ee:	4287      	cmp	r7, r0
 80038f0:	4432      	add	r2, r6
 80038f2:	d1f5      	bne.n	80038e0 <gsl_matrix_float_set_zero+0x1c>
}
 80038f4:	bcf0      	pop	{r4, r5, r6, r7}
 80038f6:	4770      	bx	lr

080038f8 <gsl_matrix_float_set_all>:
{
 80038f8:	b470      	push	{r4, r5, r6}
  const size_t p = m->size1 ;
 80038fa:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80038fc:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80038fe:	e9d0 4501 	ldrd	r4, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8003902:	b186      	cbz	r6, 8003926 <gsl_matrix_float_set_all+0x2e>
 8003904:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 8003908:	00ad      	lsls	r5, r5, #2
 800390a:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 800390e:	0080      	lsls	r0, r0, #2
 8003910:	2100      	movs	r1, #0
      for (j = 0; j < q; j++)
 8003912:	1813      	adds	r3, r2, r0
 8003914:	b11c      	cbz	r4, 800391e <gsl_matrix_float_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003916:	eca3 0a01 	vstmia	r3!, {s0}
      for (j = 0; j < q; j++)
 800391a:	4293      	cmp	r3, r2
 800391c:	d1fb      	bne.n	8003916 <gsl_matrix_float_set_all+0x1e>
  for (i = 0; i < p; i++)
 800391e:	3101      	adds	r1, #1
 8003920:	428e      	cmp	r6, r1
 8003922:	442a      	add	r2, r5
 8003924:	d1f5      	bne.n	8003912 <gsl_matrix_float_set_all+0x1a>
}
 8003926:	bc70      	pop	{r4, r5, r6}
 8003928:	4770      	bx	lr
 800392a:	bf00      	nop

0800392c <gsl_matrix_ulong_alloc>:
{
 800392c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800392e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003930:	2018      	movs	r0, #24
{
 8003932:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003934:	f02b fcf8 	bl	802f328 <malloc>
  if (m == 0)
 8003938:	4604      	mov	r4, r0
 800393a:	b1b8      	cbz	r0, 800396c <gsl_matrix_ulong_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800393c:	fb06 f007 	mul.w	r0, r6, r7
 8003940:	f003 fa02 	bl	8006d48 <gsl_block_ulong_alloc>
  if (block == 0)
 8003944:	4605      	mov	r5, r0
 8003946:	b148      	cbz	r0, 800395c <gsl_matrix_ulong_alloc+0x30>
  m->data = block->data;
 8003948:	6843      	ldr	r3, [r0, #4]
 800394a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 800394c:	2301      	movs	r3, #1
  m->size2 = n2;
 800394e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8003952:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8003956:	60a6      	str	r6, [r4, #8]
}
 8003958:	4620      	mov	r0, r4
 800395a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 800395c:	4907      	ldr	r1, [pc, #28]	; (800397c <gsl_matrix_ulong_alloc+0x50>)
 800395e:	4808      	ldr	r0, [pc, #32]	; (8003980 <gsl_matrix_ulong_alloc+0x54>)
 8003960:	2308      	movs	r3, #8
 8003962:	2228      	movs	r2, #40	; 0x28
 8003964:	462c      	mov	r4, r5
 8003966:	f7fe ff7b 	bl	8002860 <gsl_error>
 800396a:	e7f5      	b.n	8003958 <gsl_matrix_ulong_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800396c:	4903      	ldr	r1, [pc, #12]	; (800397c <gsl_matrix_ulong_alloc+0x50>)
 800396e:	4805      	ldr	r0, [pc, #20]	; (8003984 <gsl_matrix_ulong_alloc+0x58>)
 8003970:	2308      	movs	r3, #8
 8003972:	221e      	movs	r2, #30
 8003974:	f7fe ff74 	bl	8002860 <gsl_error>
 8003978:	e7ee      	b.n	8003958 <gsl_matrix_ulong_alloc+0x2c>
 800397a:	bf00      	nop
 800397c:	08030220 	.word	0x08030220
 8003980:	0803025c 	.word	0x0803025c
 8003984:	08030230 	.word	0x08030230

08003988 <gsl_matrix_ulong_calloc>:
{
 8003988:	b570      	push	{r4, r5, r6, lr}
 800398a:	4604      	mov	r4, r0
 800398c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 800398e:	f7ff ffcd 	bl	800392c <gsl_matrix_ulong_alloc>
  if (m == 0)
 8003992:	4605      	mov	r5, r0
 8003994:	b188      	cbz	r0, 80039ba <gsl_matrix_ulong_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003996:	fb06 f604 	mul.w	r6, r6, r4
 800399a:	00b4      	lsls	r4, r6, #2
 800399c:	68c0      	ldr	r0, [r0, #12]
 800399e:	4622      	mov	r2, r4
 80039a0:	2100      	movs	r1, #0
 80039a2:	f02b fcd1 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80039a6:	b146      	cbz	r6, 80039ba <gsl_matrix_ulong_calloc+0x32>
      m->data[i] = 0;
 80039a8:	68eb      	ldr	r3, [r5, #12]
 80039aa:	1f22      	subs	r2, r4, #4
 80039ac:	441a      	add	r2, r3
 80039ae:	2100      	movs	r1, #0
 80039b0:	3b04      	subs	r3, #4
 80039b2:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80039b6:	4293      	cmp	r3, r2
 80039b8:	d1fb      	bne.n	80039b2 <gsl_matrix_ulong_calloc+0x2a>
}
 80039ba:	4628      	mov	r0, r5
 80039bc:	bd70      	pop	{r4, r5, r6, pc}
 80039be:	bf00      	nop

080039c0 <gsl_matrix_ulong_alloc_from_block>:
{
 80039c0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80039c4:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 80039c8:	4599      	cmp	r9, r3
 80039ca:	d325      	bcc.n	8003a18 <gsl_matrix_ulong_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 80039cc:	4690      	mov	r8, r2
 80039ce:	6802      	ldr	r2, [r0, #0]
 80039d0:	461e      	mov	r6, r3
 80039d2:	fb08 1309 	mla	r3, r8, r9, r1
 80039d6:	429a      	cmp	r2, r3
 80039d8:	4605      	mov	r5, r0
 80039da:	460f      	mov	r7, r1
 80039dc:	d312      	bcc.n	8003a04 <gsl_matrix_ulong_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80039de:	2018      	movs	r0, #24
 80039e0:	f02b fca2 	bl	802f328 <malloc>
  if (m == 0)
 80039e4:	4604      	mov	r4, r0
 80039e6:	b1f8      	cbz	r0, 8003a28 <gsl_matrix_ulong_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 80039e8:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 80039ea:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 80039ee:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 80039f2:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80039f6:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80039fa:	2300      	movs	r3, #0
 80039fc:	6143      	str	r3, [r0, #20]
}
 80039fe:	4620      	mov	r0, r4
 8003a00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003a04:	490c      	ldr	r1, [pc, #48]	; (8003a38 <gsl_matrix_ulong_alloc_from_block+0x78>)
 8003a06:	480d      	ldr	r0, [pc, #52]	; (8003a3c <gsl_matrix_ulong_alloc_from_block+0x7c>)
 8003a08:	2304      	movs	r3, #4
 8003a0a:	225b      	movs	r2, #91	; 0x5b
 8003a0c:	2400      	movs	r4, #0
 8003a0e:	f7fe ff27 	bl	8002860 <gsl_error>
}
 8003a12:	4620      	mov	r0, r4
 8003a14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003a18:	4907      	ldr	r1, [pc, #28]	; (8003a38 <gsl_matrix_ulong_alloc_from_block+0x78>)
 8003a1a:	4809      	ldr	r0, [pc, #36]	; (8003a40 <gsl_matrix_ulong_alloc_from_block+0x80>)
 8003a1c:	2304      	movs	r3, #4
 8003a1e:	2256      	movs	r2, #86	; 0x56
 8003a20:	f7fe ff1e 	bl	8002860 <gsl_error>
 8003a24:	2400      	movs	r4, #0
 8003a26:	e7ea      	b.n	80039fe <gsl_matrix_ulong_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003a28:	4903      	ldr	r1, [pc, #12]	; (8003a38 <gsl_matrix_ulong_alloc_from_block+0x78>)
 8003a2a:	4806      	ldr	r0, [pc, #24]	; (8003a44 <gsl_matrix_ulong_alloc_from_block+0x84>)
 8003a2c:	2308      	movs	r3, #8
 8003a2e:	2263      	movs	r2, #99	; 0x63
 8003a30:	f7fe ff16 	bl	8002860 <gsl_error>
 8003a34:	e7e3      	b.n	80039fe <gsl_matrix_ulong_alloc_from_block+0x3e>
 8003a36:	bf00      	nop
 8003a38:	08030220 	.word	0x08030220
 8003a3c:	080302ac 	.word	0x080302ac
 8003a40:	08030280 	.word	0x08030280
 8003a44:	08030230 	.word	0x08030230

08003a48 <gsl_matrix_ulong_alloc_from_matrix>:
{
 8003a48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003a4c:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003a4e:	6803      	ldr	r3, [r0, #0]
{
 8003a50:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003a54:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003a56:	19c8      	adds	r0, r1, r7
 8003a58:	4298      	cmp	r0, r3
 8003a5a:	d826      	bhi.n	8003aaa <gsl_matrix_ulong_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003a5c:	686b      	ldr	r3, [r5, #4]
 8003a5e:	4690      	mov	r8, r2
 8003a60:	444a      	add	r2, r9
 8003a62:	429a      	cmp	r2, r3
 8003a64:	d817      	bhi.n	8003a96 <gsl_matrix_ulong_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003a66:	2018      	movs	r0, #24
 8003a68:	460e      	mov	r6, r1
 8003a6a:	f02b fc5d 	bl	802f328 <malloc>
  if (m == 0)
 8003a6e:	4604      	mov	r4, r0
 8003a70:	b318      	cbz	r0, 8003aba <gsl_matrix_ulong_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003a72:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003a74:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003a76:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003a7a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003a7e:	fb06 8603 	mla	r6, r6, r3, r8
 8003a82:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003a86:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003a88:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003a8c:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003a90:	4620      	mov	r0, r4
 8003a92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003a96:	490c      	ldr	r1, [pc, #48]	; (8003ac8 <gsl_matrix_ulong_alloc_from_matrix+0x80>)
 8003a98:	480c      	ldr	r0, [pc, #48]	; (8003acc <gsl_matrix_ulong_alloc_from_matrix+0x84>)
 8003a9a:	2304      	movs	r3, #4
 8003a9c:	2282      	movs	r2, #130	; 0x82
 8003a9e:	2400      	movs	r4, #0
 8003aa0:	f7fe fede 	bl	8002860 <gsl_error>
}
 8003aa4:	4620      	mov	r0, r4
 8003aa6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003aaa:	4907      	ldr	r1, [pc, #28]	; (8003ac8 <gsl_matrix_ulong_alloc_from_matrix+0x80>)
 8003aac:	4808      	ldr	r0, [pc, #32]	; (8003ad0 <gsl_matrix_ulong_alloc_from_matrix+0x88>)
 8003aae:	2304      	movs	r3, #4
 8003ab0:	227d      	movs	r2, #125	; 0x7d
 8003ab2:	f7fe fed5 	bl	8002860 <gsl_error>
 8003ab6:	2400      	movs	r4, #0
 8003ab8:	e7ea      	b.n	8003a90 <gsl_matrix_ulong_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003aba:	4903      	ldr	r1, [pc, #12]	; (8003ac8 <gsl_matrix_ulong_alloc_from_matrix+0x80>)
 8003abc:	4805      	ldr	r0, [pc, #20]	; (8003ad4 <gsl_matrix_ulong_alloc_from_matrix+0x8c>)
 8003abe:	2308      	movs	r3, #8
 8003ac0:	228a      	movs	r2, #138	; 0x8a
 8003ac2:	f7fe fecd 	bl	8002860 <gsl_error>
 8003ac6:	e7e3      	b.n	8003a90 <gsl_matrix_ulong_alloc_from_matrix+0x48>
 8003ac8:	08030220 	.word	0x08030220
 8003acc:	08030308 	.word	0x08030308
 8003ad0:	080302d8 	.word	0x080302d8
 8003ad4:	08030230 	.word	0x08030230

08003ad8 <gsl_matrix_ulong_free>:
  RETURN_IF_NULL (m);
 8003ad8:	b180      	cbz	r0, 8003afc <gsl_matrix_ulong_free+0x24>
  if (m->owner)
 8003ada:	6943      	ldr	r3, [r0, #20]
{
 8003adc:	b510      	push	{r4, lr}
 8003ade:	4604      	mov	r4, r0
  if (m->owner)
 8003ae0:	b923      	cbnz	r3, 8003aec <gsl_matrix_ulong_free+0x14>
  free (m);
 8003ae2:	4620      	mov	r0, r4
}
 8003ae4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003ae8:	f02b bc26 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003aec:	6900      	ldr	r0, [r0, #16]
 8003aee:	f003 f96d 	bl	8006dcc <gsl_block_ulong_free>
  free (m);
 8003af2:	4620      	mov	r0, r4
}
 8003af4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003af8:	f02b bc1e 	b.w	802f338 <free>
 8003afc:	4770      	bx	lr
 8003afe:	bf00      	nop

08003b00 <gsl_matrix_ulong_set_identity>:
{
 8003b00:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003b02:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8003b04:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8003b06:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8003b0a:	b19e      	cbz	r6, 8003b34 <gsl_matrix_ulong_set_identity+0x34>
 8003b0c:	2500      	movs	r5, #0
 8003b0e:	3f04      	subs	r7, #4
 8003b10:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8003b12:	b15c      	cbz	r4, 8003b2c <gsl_matrix_ulong_set_identity+0x2c>
 8003b14:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8003b18:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003b1a:	1ac1      	subs	r1, r0, r3
 8003b1c:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8003b20:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003b22:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8003b24:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003b26:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8003b2a:	d1f6      	bne.n	8003b1a <gsl_matrix_ulong_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8003b2c:	3001      	adds	r0, #1
 8003b2e:	4286      	cmp	r6, r0
 8003b30:	4465      	add	r5, ip
 8003b32:	d1ee      	bne.n	8003b12 <gsl_matrix_ulong_set_identity+0x12>
}
 8003b34:	bcf0      	pop	{r4, r5, r6, r7}
 8003b36:	4770      	bx	lr

08003b38 <gsl_matrix_ulong_set_zero>:
{
 8003b38:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003b3a:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003b3c:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003b3e:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003b42:	b18f      	cbz	r7, 8003b68 <gsl_matrix_ulong_set_zero+0x30>
 8003b44:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003b48:	2000      	movs	r0, #0
 8003b4a:	00b6      	lsls	r6, r6, #2
 8003b4c:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003b50:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003b52:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8003b54:	1953      	adds	r3, r2, r5
 8003b56:	b11c      	cbz	r4, 8003b60 <gsl_matrix_ulong_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003b58:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003b5c:	4293      	cmp	r3, r2
 8003b5e:	d1fb      	bne.n	8003b58 <gsl_matrix_ulong_set_zero+0x20>
  for (i = 0; i < p; i++)
 8003b60:	3001      	adds	r0, #1
 8003b62:	4287      	cmp	r7, r0
 8003b64:	4432      	add	r2, r6
 8003b66:	d1f5      	bne.n	8003b54 <gsl_matrix_ulong_set_zero+0x1c>
}
 8003b68:	bcf0      	pop	{r4, r5, r6, r7}
 8003b6a:	4770      	bx	lr

08003b6c <gsl_matrix_ulong_set_all>:
{
 8003b6c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003b6e:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003b70:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003b72:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003b76:	b187      	cbz	r7, 8003b9a <gsl_matrix_ulong_set_all+0x2e>
 8003b78:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003b7c:	00b6      	lsls	r6, r6, #2
 8003b7e:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003b82:	00ad      	lsls	r5, r5, #2
 8003b84:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 8003b86:	1953      	adds	r3, r2, r5
 8003b88:	b11c      	cbz	r4, 8003b92 <gsl_matrix_ulong_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003b8a:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003b8e:	4293      	cmp	r3, r2
 8003b90:	d1fb      	bne.n	8003b8a <gsl_matrix_ulong_set_all+0x1e>
  for (i = 0; i < p; i++)
 8003b92:	3001      	adds	r0, #1
 8003b94:	4287      	cmp	r7, r0
 8003b96:	4432      	add	r2, r6
 8003b98:	d1f5      	bne.n	8003b86 <gsl_matrix_ulong_set_all+0x1a>
}
 8003b9a:	bcf0      	pop	{r4, r5, r6, r7}
 8003b9c:	4770      	bx	lr
 8003b9e:	bf00      	nop

08003ba0 <gsl_matrix_long_alloc>:
{
 8003ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003ba2:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003ba4:	2018      	movs	r0, #24
{
 8003ba6:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003ba8:	f02b fbbe 	bl	802f328 <malloc>
  if (m == 0)
 8003bac:	4604      	mov	r4, r0
 8003bae:	b1b8      	cbz	r0, 8003be0 <gsl_matrix_long_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8003bb0:	fb06 f007 	mul.w	r0, r6, r7
 8003bb4:	f003 f916 	bl	8006de4 <gsl_block_long_alloc>
  if (block == 0)
 8003bb8:	4605      	mov	r5, r0
 8003bba:	b148      	cbz	r0, 8003bd0 <gsl_matrix_long_alloc+0x30>
  m->data = block->data;
 8003bbc:	6843      	ldr	r3, [r0, #4]
 8003bbe:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8003bc0:	2301      	movs	r3, #1
  m->size2 = n2;
 8003bc2:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8003bc6:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8003bca:	60a6      	str	r6, [r4, #8]
}
 8003bcc:	4620      	mov	r0, r4
 8003bce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8003bd0:	4907      	ldr	r1, [pc, #28]	; (8003bf0 <gsl_matrix_long_alloc+0x50>)
 8003bd2:	4808      	ldr	r0, [pc, #32]	; (8003bf4 <gsl_matrix_long_alloc+0x54>)
 8003bd4:	2308      	movs	r3, #8
 8003bd6:	2228      	movs	r2, #40	; 0x28
 8003bd8:	462c      	mov	r4, r5
 8003bda:	f7fe fe41 	bl	8002860 <gsl_error>
 8003bde:	e7f5      	b.n	8003bcc <gsl_matrix_long_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003be0:	4903      	ldr	r1, [pc, #12]	; (8003bf0 <gsl_matrix_long_alloc+0x50>)
 8003be2:	4805      	ldr	r0, [pc, #20]	; (8003bf8 <gsl_matrix_long_alloc+0x58>)
 8003be4:	2308      	movs	r3, #8
 8003be6:	221e      	movs	r2, #30
 8003be8:	f7fe fe3a 	bl	8002860 <gsl_error>
 8003bec:	e7ee      	b.n	8003bcc <gsl_matrix_long_alloc+0x2c>
 8003bee:	bf00      	nop
 8003bf0:	08030220 	.word	0x08030220
 8003bf4:	0803025c 	.word	0x0803025c
 8003bf8:	08030230 	.word	0x08030230

08003bfc <gsl_matrix_long_calloc>:
{
 8003bfc:	b570      	push	{r4, r5, r6, lr}
 8003bfe:	4604      	mov	r4, r0
 8003c00:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8003c02:	f7ff ffcd 	bl	8003ba0 <gsl_matrix_long_alloc>
  if (m == 0)
 8003c06:	4605      	mov	r5, r0
 8003c08:	b188      	cbz	r0, 8003c2e <gsl_matrix_long_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003c0a:	fb06 f604 	mul.w	r6, r6, r4
 8003c0e:	00b4      	lsls	r4, r6, #2
 8003c10:	68c0      	ldr	r0, [r0, #12]
 8003c12:	4622      	mov	r2, r4
 8003c14:	2100      	movs	r1, #0
 8003c16:	f02b fb97 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003c1a:	b146      	cbz	r6, 8003c2e <gsl_matrix_long_calloc+0x32>
      m->data[i] = 0;
 8003c1c:	68eb      	ldr	r3, [r5, #12]
 8003c1e:	1f22      	subs	r2, r4, #4
 8003c20:	441a      	add	r2, r3
 8003c22:	2100      	movs	r1, #0
 8003c24:	3b04      	subs	r3, #4
 8003c26:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003c2a:	4293      	cmp	r3, r2
 8003c2c:	d1fb      	bne.n	8003c26 <gsl_matrix_long_calloc+0x2a>
}
 8003c2e:	4628      	mov	r0, r5
 8003c30:	bd70      	pop	{r4, r5, r6, pc}
 8003c32:	bf00      	nop

08003c34 <gsl_matrix_long_alloc_from_block>:
{
 8003c34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003c38:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003c3c:	4599      	cmp	r9, r3
 8003c3e:	d325      	bcc.n	8003c8c <gsl_matrix_long_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003c40:	4690      	mov	r8, r2
 8003c42:	6802      	ldr	r2, [r0, #0]
 8003c44:	461e      	mov	r6, r3
 8003c46:	fb08 1309 	mla	r3, r8, r9, r1
 8003c4a:	429a      	cmp	r2, r3
 8003c4c:	4605      	mov	r5, r0
 8003c4e:	460f      	mov	r7, r1
 8003c50:	d312      	bcc.n	8003c78 <gsl_matrix_long_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003c52:	2018      	movs	r0, #24
 8003c54:	f02b fb68 	bl	802f328 <malloc>
  if (m == 0)
 8003c58:	4604      	mov	r4, r0
 8003c5a:	b1f8      	cbz	r0, 8003c9c <gsl_matrix_long_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003c5c:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003c5e:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8003c62:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 8003c66:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003c6a:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003c6e:	2300      	movs	r3, #0
 8003c70:	6143      	str	r3, [r0, #20]
}
 8003c72:	4620      	mov	r0, r4
 8003c74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003c78:	490c      	ldr	r1, [pc, #48]	; (8003cac <gsl_matrix_long_alloc_from_block+0x78>)
 8003c7a:	480d      	ldr	r0, [pc, #52]	; (8003cb0 <gsl_matrix_long_alloc_from_block+0x7c>)
 8003c7c:	2304      	movs	r3, #4
 8003c7e:	225b      	movs	r2, #91	; 0x5b
 8003c80:	2400      	movs	r4, #0
 8003c82:	f7fe fded 	bl	8002860 <gsl_error>
}
 8003c86:	4620      	mov	r0, r4
 8003c88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003c8c:	4907      	ldr	r1, [pc, #28]	; (8003cac <gsl_matrix_long_alloc_from_block+0x78>)
 8003c8e:	4809      	ldr	r0, [pc, #36]	; (8003cb4 <gsl_matrix_long_alloc_from_block+0x80>)
 8003c90:	2304      	movs	r3, #4
 8003c92:	2256      	movs	r2, #86	; 0x56
 8003c94:	f7fe fde4 	bl	8002860 <gsl_error>
 8003c98:	2400      	movs	r4, #0
 8003c9a:	e7ea      	b.n	8003c72 <gsl_matrix_long_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003c9c:	4903      	ldr	r1, [pc, #12]	; (8003cac <gsl_matrix_long_alloc_from_block+0x78>)
 8003c9e:	4806      	ldr	r0, [pc, #24]	; (8003cb8 <gsl_matrix_long_alloc_from_block+0x84>)
 8003ca0:	2308      	movs	r3, #8
 8003ca2:	2263      	movs	r2, #99	; 0x63
 8003ca4:	f7fe fddc 	bl	8002860 <gsl_error>
 8003ca8:	e7e3      	b.n	8003c72 <gsl_matrix_long_alloc_from_block+0x3e>
 8003caa:	bf00      	nop
 8003cac:	08030220 	.word	0x08030220
 8003cb0:	080302ac 	.word	0x080302ac
 8003cb4:	08030280 	.word	0x08030280
 8003cb8:	08030230 	.word	0x08030230

08003cbc <gsl_matrix_long_alloc_from_matrix>:
{
 8003cbc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003cc0:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003cc2:	6803      	ldr	r3, [r0, #0]
{
 8003cc4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003cc8:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003cca:	19c8      	adds	r0, r1, r7
 8003ccc:	4298      	cmp	r0, r3
 8003cce:	d826      	bhi.n	8003d1e <gsl_matrix_long_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003cd0:	686b      	ldr	r3, [r5, #4]
 8003cd2:	4690      	mov	r8, r2
 8003cd4:	444a      	add	r2, r9
 8003cd6:	429a      	cmp	r2, r3
 8003cd8:	d817      	bhi.n	8003d0a <gsl_matrix_long_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003cda:	2018      	movs	r0, #24
 8003cdc:	460e      	mov	r6, r1
 8003cde:	f02b fb23 	bl	802f328 <malloc>
  if (m == 0)
 8003ce2:	4604      	mov	r4, r0
 8003ce4:	b318      	cbz	r0, 8003d2e <gsl_matrix_long_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003ce6:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003ce8:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003cea:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003cee:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003cf2:	fb06 8603 	mla	r6, r6, r3, r8
 8003cf6:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003cfa:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003cfc:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003d00:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003d04:	4620      	mov	r0, r4
 8003d06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003d0a:	490c      	ldr	r1, [pc, #48]	; (8003d3c <gsl_matrix_long_alloc_from_matrix+0x80>)
 8003d0c:	480c      	ldr	r0, [pc, #48]	; (8003d40 <gsl_matrix_long_alloc_from_matrix+0x84>)
 8003d0e:	2304      	movs	r3, #4
 8003d10:	2282      	movs	r2, #130	; 0x82
 8003d12:	2400      	movs	r4, #0
 8003d14:	f7fe fda4 	bl	8002860 <gsl_error>
}
 8003d18:	4620      	mov	r0, r4
 8003d1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003d1e:	4907      	ldr	r1, [pc, #28]	; (8003d3c <gsl_matrix_long_alloc_from_matrix+0x80>)
 8003d20:	4808      	ldr	r0, [pc, #32]	; (8003d44 <gsl_matrix_long_alloc_from_matrix+0x88>)
 8003d22:	2304      	movs	r3, #4
 8003d24:	227d      	movs	r2, #125	; 0x7d
 8003d26:	f7fe fd9b 	bl	8002860 <gsl_error>
 8003d2a:	2400      	movs	r4, #0
 8003d2c:	e7ea      	b.n	8003d04 <gsl_matrix_long_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003d2e:	4903      	ldr	r1, [pc, #12]	; (8003d3c <gsl_matrix_long_alloc_from_matrix+0x80>)
 8003d30:	4805      	ldr	r0, [pc, #20]	; (8003d48 <gsl_matrix_long_alloc_from_matrix+0x8c>)
 8003d32:	2308      	movs	r3, #8
 8003d34:	228a      	movs	r2, #138	; 0x8a
 8003d36:	f7fe fd93 	bl	8002860 <gsl_error>
 8003d3a:	e7e3      	b.n	8003d04 <gsl_matrix_long_alloc_from_matrix+0x48>
 8003d3c:	08030220 	.word	0x08030220
 8003d40:	08030308 	.word	0x08030308
 8003d44:	080302d8 	.word	0x080302d8
 8003d48:	08030230 	.word	0x08030230

08003d4c <gsl_matrix_long_free>:
  RETURN_IF_NULL (m);
 8003d4c:	b180      	cbz	r0, 8003d70 <gsl_matrix_long_free+0x24>
  if (m->owner)
 8003d4e:	6943      	ldr	r3, [r0, #20]
{
 8003d50:	b510      	push	{r4, lr}
 8003d52:	4604      	mov	r4, r0
  if (m->owner)
 8003d54:	b923      	cbnz	r3, 8003d60 <gsl_matrix_long_free+0x14>
  free (m);
 8003d56:	4620      	mov	r0, r4
}
 8003d58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003d5c:	f02b baec 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003d60:	6900      	ldr	r0, [r0, #16]
 8003d62:	f003 f881 	bl	8006e68 <gsl_block_long_free>
  free (m);
 8003d66:	4620      	mov	r0, r4
}
 8003d68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003d6c:	f02b bae4 	b.w	802f338 <free>
 8003d70:	4770      	bx	lr
 8003d72:	bf00      	nop

08003d74 <gsl_matrix_long_set_identity>:
{
 8003d74:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003d76:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8003d78:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8003d7a:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8003d7e:	b19e      	cbz	r6, 8003da8 <gsl_matrix_long_set_identity+0x34>
 8003d80:	2500      	movs	r5, #0
 8003d82:	3f04      	subs	r7, #4
 8003d84:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8003d86:	b15c      	cbz	r4, 8003da0 <gsl_matrix_long_set_identity+0x2c>
 8003d88:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8003d8c:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003d8e:	1ac1      	subs	r1, r0, r3
 8003d90:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8003d94:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003d96:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8003d98:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8003d9a:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8003d9e:	d1f6      	bne.n	8003d8e <gsl_matrix_long_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8003da0:	3001      	adds	r0, #1
 8003da2:	4286      	cmp	r6, r0
 8003da4:	4465      	add	r5, ip
 8003da6:	d1ee      	bne.n	8003d86 <gsl_matrix_long_set_identity+0x12>
}
 8003da8:	bcf0      	pop	{r4, r5, r6, r7}
 8003daa:	4770      	bx	lr

08003dac <gsl_matrix_long_set_zero>:
{
 8003dac:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003dae:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003db0:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003db2:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003db6:	b18f      	cbz	r7, 8003ddc <gsl_matrix_long_set_zero+0x30>
 8003db8:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003dbc:	2000      	movs	r0, #0
 8003dbe:	00b6      	lsls	r6, r6, #2
 8003dc0:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003dc4:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003dc6:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8003dc8:	1953      	adds	r3, r2, r5
 8003dca:	b11c      	cbz	r4, 8003dd4 <gsl_matrix_long_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8003dcc:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003dd0:	4293      	cmp	r3, r2
 8003dd2:	d1fb      	bne.n	8003dcc <gsl_matrix_long_set_zero+0x20>
  for (i = 0; i < p; i++)
 8003dd4:	3001      	adds	r0, #1
 8003dd6:	4287      	cmp	r7, r0
 8003dd8:	4432      	add	r2, r6
 8003dda:	d1f5      	bne.n	8003dc8 <gsl_matrix_long_set_zero+0x1c>
}
 8003ddc:	bcf0      	pop	{r4, r5, r6, r7}
 8003dde:	4770      	bx	lr

08003de0 <gsl_matrix_long_set_all>:
{
 8003de0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003de2:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8003de4:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8003de6:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8003dea:	b187      	cbz	r7, 8003e0e <gsl_matrix_long_set_all+0x2e>
 8003dec:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8003df0:	00b6      	lsls	r6, r6, #2
 8003df2:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8003df6:	00ad      	lsls	r5, r5, #2
 8003df8:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 8003dfa:	1953      	adds	r3, r2, r5
 8003dfc:	b11c      	cbz	r4, 8003e06 <gsl_matrix_long_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8003dfe:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8003e02:	4293      	cmp	r3, r2
 8003e04:	d1fb      	bne.n	8003dfe <gsl_matrix_long_set_all+0x1e>
  for (i = 0; i < p; i++)
 8003e06:	3001      	adds	r0, #1
 8003e08:	4287      	cmp	r7, r0
 8003e0a:	4432      	add	r2, r6
 8003e0c:	d1f5      	bne.n	8003dfa <gsl_matrix_long_set_all+0x1a>
}
 8003e0e:	bcf0      	pop	{r4, r5, r6, r7}
 8003e10:	4770      	bx	lr
 8003e12:	bf00      	nop

08003e14 <gsl_matrix_uint_alloc>:
{
 8003e14:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e16:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003e18:	2018      	movs	r0, #24
{
 8003e1a:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003e1c:	f02b fa84 	bl	802f328 <malloc>
  if (m == 0)
 8003e20:	4604      	mov	r4, r0
 8003e22:	b1b8      	cbz	r0, 8003e54 <gsl_matrix_uint_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8003e24:	fb06 f007 	mul.w	r0, r6, r7
 8003e28:	f003 f82a 	bl	8006e80 <gsl_block_uint_alloc>
  if (block == 0)
 8003e2c:	4605      	mov	r5, r0
 8003e2e:	b148      	cbz	r0, 8003e44 <gsl_matrix_uint_alloc+0x30>
  m->data = block->data;
 8003e30:	6843      	ldr	r3, [r0, #4]
 8003e32:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8003e34:	2301      	movs	r3, #1
  m->size2 = n2;
 8003e36:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8003e3a:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8003e3e:	60a6      	str	r6, [r4, #8]
}
 8003e40:	4620      	mov	r0, r4
 8003e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8003e44:	4907      	ldr	r1, [pc, #28]	; (8003e64 <gsl_matrix_uint_alloc+0x50>)
 8003e46:	4808      	ldr	r0, [pc, #32]	; (8003e68 <gsl_matrix_uint_alloc+0x54>)
 8003e48:	2308      	movs	r3, #8
 8003e4a:	2228      	movs	r2, #40	; 0x28
 8003e4c:	462c      	mov	r4, r5
 8003e4e:	f7fe fd07 	bl	8002860 <gsl_error>
 8003e52:	e7f5      	b.n	8003e40 <gsl_matrix_uint_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003e54:	4903      	ldr	r1, [pc, #12]	; (8003e64 <gsl_matrix_uint_alloc+0x50>)
 8003e56:	4805      	ldr	r0, [pc, #20]	; (8003e6c <gsl_matrix_uint_alloc+0x58>)
 8003e58:	2308      	movs	r3, #8
 8003e5a:	221e      	movs	r2, #30
 8003e5c:	f7fe fd00 	bl	8002860 <gsl_error>
 8003e60:	e7ee      	b.n	8003e40 <gsl_matrix_uint_alloc+0x2c>
 8003e62:	bf00      	nop
 8003e64:	08030220 	.word	0x08030220
 8003e68:	0803025c 	.word	0x0803025c
 8003e6c:	08030230 	.word	0x08030230

08003e70 <gsl_matrix_uint_calloc>:
{
 8003e70:	b570      	push	{r4, r5, r6, lr}
 8003e72:	4604      	mov	r4, r0
 8003e74:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8003e76:	f7ff ffcd 	bl	8003e14 <gsl_matrix_uint_alloc>
  if (m == 0)
 8003e7a:	4605      	mov	r5, r0
 8003e7c:	b188      	cbz	r0, 8003ea2 <gsl_matrix_uint_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8003e7e:	fb06 f604 	mul.w	r6, r6, r4
 8003e82:	00b4      	lsls	r4, r6, #2
 8003e84:	68c0      	ldr	r0, [r0, #12]
 8003e86:	4622      	mov	r2, r4
 8003e88:	2100      	movs	r1, #0
 8003e8a:	f02b fa5d 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003e8e:	b146      	cbz	r6, 8003ea2 <gsl_matrix_uint_calloc+0x32>
      m->data[i] = 0;
 8003e90:	68eb      	ldr	r3, [r5, #12]
 8003e92:	1f22      	subs	r2, r4, #4
 8003e94:	441a      	add	r2, r3
 8003e96:	2100      	movs	r1, #0
 8003e98:	3b04      	subs	r3, #4
 8003e9a:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8003e9e:	4293      	cmp	r3, r2
 8003ea0:	d1fb      	bne.n	8003e9a <gsl_matrix_uint_calloc+0x2a>
}
 8003ea2:	4628      	mov	r0, r5
 8003ea4:	bd70      	pop	{r4, r5, r6, pc}
 8003ea6:	bf00      	nop

08003ea8 <gsl_matrix_uint_alloc_from_block>:
{
 8003ea8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003eac:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8003eb0:	4599      	cmp	r9, r3
 8003eb2:	d325      	bcc.n	8003f00 <gsl_matrix_uint_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8003eb4:	4690      	mov	r8, r2
 8003eb6:	6802      	ldr	r2, [r0, #0]
 8003eb8:	461e      	mov	r6, r3
 8003eba:	fb08 1309 	mla	r3, r8, r9, r1
 8003ebe:	429a      	cmp	r2, r3
 8003ec0:	4605      	mov	r5, r0
 8003ec2:	460f      	mov	r7, r1
 8003ec4:	d312      	bcc.n	8003eec <gsl_matrix_uint_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003ec6:	2018      	movs	r0, #24
 8003ec8:	f02b fa2e 	bl	802f328 <malloc>
  if (m == 0)
 8003ecc:	4604      	mov	r4, r0
 8003ece:	b1f8      	cbz	r0, 8003f10 <gsl_matrix_uint_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8003ed0:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8003ed2:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8003ed6:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 8003eda:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8003ede:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8003ee2:	2300      	movs	r3, #0
 8003ee4:	6143      	str	r3, [r0, #20]
}
 8003ee6:	4620      	mov	r0, r4
 8003ee8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8003eec:	490c      	ldr	r1, [pc, #48]	; (8003f20 <gsl_matrix_uint_alloc_from_block+0x78>)
 8003eee:	480d      	ldr	r0, [pc, #52]	; (8003f24 <gsl_matrix_uint_alloc_from_block+0x7c>)
 8003ef0:	2304      	movs	r3, #4
 8003ef2:	225b      	movs	r2, #91	; 0x5b
 8003ef4:	2400      	movs	r4, #0
 8003ef6:	f7fe fcb3 	bl	8002860 <gsl_error>
}
 8003efa:	4620      	mov	r0, r4
 8003efc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8003f00:	4907      	ldr	r1, [pc, #28]	; (8003f20 <gsl_matrix_uint_alloc_from_block+0x78>)
 8003f02:	4809      	ldr	r0, [pc, #36]	; (8003f28 <gsl_matrix_uint_alloc_from_block+0x80>)
 8003f04:	2304      	movs	r3, #4
 8003f06:	2256      	movs	r2, #86	; 0x56
 8003f08:	f7fe fcaa 	bl	8002860 <gsl_error>
 8003f0c:	2400      	movs	r4, #0
 8003f0e:	e7ea      	b.n	8003ee6 <gsl_matrix_uint_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003f10:	4903      	ldr	r1, [pc, #12]	; (8003f20 <gsl_matrix_uint_alloc_from_block+0x78>)
 8003f12:	4806      	ldr	r0, [pc, #24]	; (8003f2c <gsl_matrix_uint_alloc_from_block+0x84>)
 8003f14:	2308      	movs	r3, #8
 8003f16:	2263      	movs	r2, #99	; 0x63
 8003f18:	f7fe fca2 	bl	8002860 <gsl_error>
 8003f1c:	e7e3      	b.n	8003ee6 <gsl_matrix_uint_alloc_from_block+0x3e>
 8003f1e:	bf00      	nop
 8003f20:	08030220 	.word	0x08030220
 8003f24:	080302ac 	.word	0x080302ac
 8003f28:	08030280 	.word	0x08030280
 8003f2c:	08030230 	.word	0x08030230

08003f30 <gsl_matrix_uint_alloc_from_matrix>:
{
 8003f30:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003f34:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8003f36:	6803      	ldr	r3, [r0, #0]
{
 8003f38:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8003f3c:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8003f3e:	19c8      	adds	r0, r1, r7
 8003f40:	4298      	cmp	r0, r3
 8003f42:	d826      	bhi.n	8003f92 <gsl_matrix_uint_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 8003f44:	686b      	ldr	r3, [r5, #4]
 8003f46:	4690      	mov	r8, r2
 8003f48:	444a      	add	r2, r9
 8003f4a:	429a      	cmp	r2, r3
 8003f4c:	d817      	bhi.n	8003f7e <gsl_matrix_uint_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8003f4e:	2018      	movs	r0, #24
 8003f50:	460e      	mov	r6, r1
 8003f52:	f02b f9e9 	bl	802f328 <malloc>
  if (m == 0)
 8003f56:	4604      	mov	r4, r0
 8003f58:	b318      	cbz	r0, 8003fa2 <gsl_matrix_uint_alloc_from_matrix+0x72>
  m->size1 = n1;
 8003f5a:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003f5c:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8003f5e:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8003f62:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003f66:	fb06 8603 	mla	r6, r6, r3, r8
 8003f6a:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 8003f6e:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8003f70:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8003f74:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8003f78:	4620      	mov	r0, r4
 8003f7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8003f7e:	490c      	ldr	r1, [pc, #48]	; (8003fb0 <gsl_matrix_uint_alloc_from_matrix+0x80>)
 8003f80:	480c      	ldr	r0, [pc, #48]	; (8003fb4 <gsl_matrix_uint_alloc_from_matrix+0x84>)
 8003f82:	2304      	movs	r3, #4
 8003f84:	2282      	movs	r2, #130	; 0x82
 8003f86:	2400      	movs	r4, #0
 8003f88:	f7fe fc6a 	bl	8002860 <gsl_error>
}
 8003f8c:	4620      	mov	r0, r4
 8003f8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8003f92:	4907      	ldr	r1, [pc, #28]	; (8003fb0 <gsl_matrix_uint_alloc_from_matrix+0x80>)
 8003f94:	4808      	ldr	r0, [pc, #32]	; (8003fb8 <gsl_matrix_uint_alloc_from_matrix+0x88>)
 8003f96:	2304      	movs	r3, #4
 8003f98:	227d      	movs	r2, #125	; 0x7d
 8003f9a:	f7fe fc61 	bl	8002860 <gsl_error>
 8003f9e:	2400      	movs	r4, #0
 8003fa0:	e7ea      	b.n	8003f78 <gsl_matrix_uint_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8003fa2:	4903      	ldr	r1, [pc, #12]	; (8003fb0 <gsl_matrix_uint_alloc_from_matrix+0x80>)
 8003fa4:	4805      	ldr	r0, [pc, #20]	; (8003fbc <gsl_matrix_uint_alloc_from_matrix+0x8c>)
 8003fa6:	2308      	movs	r3, #8
 8003fa8:	228a      	movs	r2, #138	; 0x8a
 8003faa:	f7fe fc59 	bl	8002860 <gsl_error>
 8003fae:	e7e3      	b.n	8003f78 <gsl_matrix_uint_alloc_from_matrix+0x48>
 8003fb0:	08030220 	.word	0x08030220
 8003fb4:	08030308 	.word	0x08030308
 8003fb8:	080302d8 	.word	0x080302d8
 8003fbc:	08030230 	.word	0x08030230

08003fc0 <gsl_matrix_uint_free>:
  RETURN_IF_NULL (m);
 8003fc0:	b180      	cbz	r0, 8003fe4 <gsl_matrix_uint_free+0x24>
  if (m->owner)
 8003fc2:	6943      	ldr	r3, [r0, #20]
{
 8003fc4:	b510      	push	{r4, lr}
 8003fc6:	4604      	mov	r4, r0
  if (m->owner)
 8003fc8:	b923      	cbnz	r3, 8003fd4 <gsl_matrix_uint_free+0x14>
  free (m);
 8003fca:	4620      	mov	r0, r4
}
 8003fcc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003fd0:	f02b b9b2 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8003fd4:	6900      	ldr	r0, [r0, #16]
 8003fd6:	f002 ff95 	bl	8006f04 <gsl_block_uint_free>
  free (m);
 8003fda:	4620      	mov	r0, r4
}
 8003fdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8003fe0:	f02b b9aa 	b.w	802f338 <free>
 8003fe4:	4770      	bx	lr
 8003fe6:	bf00      	nop

08003fe8 <gsl_matrix_uint_set_identity>:
{
 8003fe8:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8003fea:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8003fec:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8003fee:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8003ff2:	b19e      	cbz	r6, 800401c <gsl_matrix_uint_set_identity+0x34>
 8003ff4:	2500      	movs	r5, #0
 8003ff6:	3f04      	subs	r7, #4
 8003ff8:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8003ffa:	b15c      	cbz	r4, 8004014 <gsl_matrix_uint_set_identity+0x2c>
 8003ffc:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8004000:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004002:	1ac1      	subs	r1, r0, r3
 8004004:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8004008:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800400a:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 800400c:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800400e:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8004012:	d1f6      	bne.n	8004002 <gsl_matrix_uint_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8004014:	3001      	adds	r0, #1
 8004016:	4286      	cmp	r6, r0
 8004018:	4465      	add	r5, ip
 800401a:	d1ee      	bne.n	8003ffa <gsl_matrix_uint_set_identity+0x12>
}
 800401c:	bcf0      	pop	{r4, r5, r6, r7}
 800401e:	4770      	bx	lr

08004020 <gsl_matrix_uint_set_zero>:
{
 8004020:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004022:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004024:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8004026:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 800402a:	b18f      	cbz	r7, 8004050 <gsl_matrix_uint_set_zero+0x30>
 800402c:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8004030:	2000      	movs	r0, #0
 8004032:	00b6      	lsls	r6, r6, #2
 8004034:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 8004038:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800403a:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 800403c:	1953      	adds	r3, r2, r5
 800403e:	b11c      	cbz	r4, 8004048 <gsl_matrix_uint_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004040:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8004044:	4293      	cmp	r3, r2
 8004046:	d1fb      	bne.n	8004040 <gsl_matrix_uint_set_zero+0x20>
  for (i = 0; i < p; i++)
 8004048:	3001      	adds	r0, #1
 800404a:	4287      	cmp	r7, r0
 800404c:	4432      	add	r2, r6
 800404e:	d1f5      	bne.n	800403c <gsl_matrix_uint_set_zero+0x1c>
}
 8004050:	bcf0      	pop	{r4, r5, r6, r7}
 8004052:	4770      	bx	lr

08004054 <gsl_matrix_uint_set_all>:
{
 8004054:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004056:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004058:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800405a:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 800405e:	b187      	cbz	r7, 8004082 <gsl_matrix_uint_set_all+0x2e>
 8004060:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 8004064:	00b6      	lsls	r6, r6, #2
 8004066:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 800406a:	00ad      	lsls	r5, r5, #2
 800406c:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 800406e:	1953      	adds	r3, r2, r5
 8004070:	b11c      	cbz	r4, 800407a <gsl_matrix_uint_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8004072:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 8004076:	4293      	cmp	r3, r2
 8004078:	d1fb      	bne.n	8004072 <gsl_matrix_uint_set_all+0x1e>
  for (i = 0; i < p; i++)
 800407a:	3001      	adds	r0, #1
 800407c:	4287      	cmp	r7, r0
 800407e:	4432      	add	r2, r6
 8004080:	d1f5      	bne.n	800406e <gsl_matrix_uint_set_all+0x1a>
}
 8004082:	bcf0      	pop	{r4, r5, r6, r7}
 8004084:	4770      	bx	lr
 8004086:	bf00      	nop

08004088 <gsl_matrix_int_alloc>:
{
 8004088:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800408a:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800408c:	2018      	movs	r0, #24
{
 800408e:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004090:	f02b f94a 	bl	802f328 <malloc>
  if (m == 0)
 8004094:	4604      	mov	r4, r0
 8004096:	b1b8      	cbz	r0, 80040c8 <gsl_matrix_int_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8004098:	fb06 f007 	mul.w	r0, r6, r7
 800409c:	f002 ff3e 	bl	8006f1c <gsl_block_int_alloc>
  if (block == 0)
 80040a0:	4605      	mov	r5, r0
 80040a2:	b148      	cbz	r0, 80040b8 <gsl_matrix_int_alloc+0x30>
  m->data = block->data;
 80040a4:	6843      	ldr	r3, [r0, #4]
 80040a6:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 80040a8:	2301      	movs	r3, #1
  m->size2 = n2;
 80040aa:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 80040ae:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 80040b2:	60a6      	str	r6, [r4, #8]
}
 80040b4:	4620      	mov	r0, r4
 80040b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80040b8:	4907      	ldr	r1, [pc, #28]	; (80040d8 <gsl_matrix_int_alloc+0x50>)
 80040ba:	4808      	ldr	r0, [pc, #32]	; (80040dc <gsl_matrix_int_alloc+0x54>)
 80040bc:	2308      	movs	r3, #8
 80040be:	2228      	movs	r2, #40	; 0x28
 80040c0:	462c      	mov	r4, r5
 80040c2:	f7fe fbcd 	bl	8002860 <gsl_error>
 80040c6:	e7f5      	b.n	80040b4 <gsl_matrix_int_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80040c8:	4903      	ldr	r1, [pc, #12]	; (80040d8 <gsl_matrix_int_alloc+0x50>)
 80040ca:	4805      	ldr	r0, [pc, #20]	; (80040e0 <gsl_matrix_int_alloc+0x58>)
 80040cc:	2308      	movs	r3, #8
 80040ce:	221e      	movs	r2, #30
 80040d0:	f7fe fbc6 	bl	8002860 <gsl_error>
 80040d4:	e7ee      	b.n	80040b4 <gsl_matrix_int_alloc+0x2c>
 80040d6:	bf00      	nop
 80040d8:	08030220 	.word	0x08030220
 80040dc:	0803025c 	.word	0x0803025c
 80040e0:	08030230 	.word	0x08030230

080040e4 <gsl_matrix_int_calloc>:
{
 80040e4:	b570      	push	{r4, r5, r6, lr}
 80040e6:	4604      	mov	r4, r0
 80040e8:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80040ea:	f7ff ffcd 	bl	8004088 <gsl_matrix_int_alloc>
  if (m == 0)
 80040ee:	4605      	mov	r5, r0
 80040f0:	b188      	cbz	r0, 8004116 <gsl_matrix_int_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80040f2:	fb06 f604 	mul.w	r6, r6, r4
 80040f6:	00b4      	lsls	r4, r6, #2
 80040f8:	68c0      	ldr	r0, [r0, #12]
 80040fa:	4622      	mov	r2, r4
 80040fc:	2100      	movs	r1, #0
 80040fe:	f02b f923 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004102:	b146      	cbz	r6, 8004116 <gsl_matrix_int_calloc+0x32>
      m->data[i] = 0;
 8004104:	68eb      	ldr	r3, [r5, #12]
 8004106:	1f22      	subs	r2, r4, #4
 8004108:	441a      	add	r2, r3
 800410a:	2100      	movs	r1, #0
 800410c:	3b04      	subs	r3, #4
 800410e:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004112:	4293      	cmp	r3, r2
 8004114:	d1fb      	bne.n	800410e <gsl_matrix_int_calloc+0x2a>
}
 8004116:	4628      	mov	r0, r5
 8004118:	bd70      	pop	{r4, r5, r6, pc}
 800411a:	bf00      	nop

0800411c <gsl_matrix_int_alloc_from_block>:
{
 800411c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004120:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004124:	4599      	cmp	r9, r3
 8004126:	d325      	bcc.n	8004174 <gsl_matrix_int_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8004128:	4690      	mov	r8, r2
 800412a:	6802      	ldr	r2, [r0, #0]
 800412c:	461e      	mov	r6, r3
 800412e:	fb08 1309 	mla	r3, r8, r9, r1
 8004132:	429a      	cmp	r2, r3
 8004134:	4605      	mov	r5, r0
 8004136:	460f      	mov	r7, r1
 8004138:	d312      	bcc.n	8004160 <gsl_matrix_int_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800413a:	2018      	movs	r0, #24
 800413c:	f02b f8f4 	bl	802f328 <malloc>
  if (m == 0)
 8004140:	4604      	mov	r4, r0
 8004142:	b1f8      	cbz	r0, 8004184 <gsl_matrix_int_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 8004144:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8004146:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800414a:	eb01 0187 	add.w	r1, r1, r7, lsl #2
  m->tda = d2;
 800414e:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8004152:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8004156:	2300      	movs	r3, #0
 8004158:	6143      	str	r3, [r0, #20]
}
 800415a:	4620      	mov	r0, r4
 800415c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8004160:	490c      	ldr	r1, [pc, #48]	; (8004194 <gsl_matrix_int_alloc_from_block+0x78>)
 8004162:	480d      	ldr	r0, [pc, #52]	; (8004198 <gsl_matrix_int_alloc_from_block+0x7c>)
 8004164:	2304      	movs	r3, #4
 8004166:	225b      	movs	r2, #91	; 0x5b
 8004168:	2400      	movs	r4, #0
 800416a:	f7fe fb79 	bl	8002860 <gsl_error>
}
 800416e:	4620      	mov	r0, r4
 8004170:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8004174:	4907      	ldr	r1, [pc, #28]	; (8004194 <gsl_matrix_int_alloc_from_block+0x78>)
 8004176:	4809      	ldr	r0, [pc, #36]	; (800419c <gsl_matrix_int_alloc_from_block+0x80>)
 8004178:	2304      	movs	r3, #4
 800417a:	2256      	movs	r2, #86	; 0x56
 800417c:	f7fe fb70 	bl	8002860 <gsl_error>
 8004180:	2400      	movs	r4, #0
 8004182:	e7ea      	b.n	800415a <gsl_matrix_int_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004184:	4903      	ldr	r1, [pc, #12]	; (8004194 <gsl_matrix_int_alloc_from_block+0x78>)
 8004186:	4806      	ldr	r0, [pc, #24]	; (80041a0 <gsl_matrix_int_alloc_from_block+0x84>)
 8004188:	2308      	movs	r3, #8
 800418a:	2263      	movs	r2, #99	; 0x63
 800418c:	f7fe fb68 	bl	8002860 <gsl_error>
 8004190:	e7e3      	b.n	800415a <gsl_matrix_int_alloc_from_block+0x3e>
 8004192:	bf00      	nop
 8004194:	08030220 	.word	0x08030220
 8004198:	080302ac 	.word	0x080302ac
 800419c:	08030280 	.word	0x08030280
 80041a0:	08030230 	.word	0x08030230

080041a4 <gsl_matrix_int_alloc_from_matrix>:
{
 80041a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80041a8:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 80041aa:	6803      	ldr	r3, [r0, #0]
{
 80041ac:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80041b0:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 80041b2:	19c8      	adds	r0, r1, r7
 80041b4:	4298      	cmp	r0, r3
 80041b6:	d826      	bhi.n	8004206 <gsl_matrix_int_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80041b8:	686b      	ldr	r3, [r5, #4]
 80041ba:	4690      	mov	r8, r2
 80041bc:	444a      	add	r2, r9
 80041be:	429a      	cmp	r2, r3
 80041c0:	d817      	bhi.n	80041f2 <gsl_matrix_int_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80041c2:	2018      	movs	r0, #24
 80041c4:	460e      	mov	r6, r1
 80041c6:	f02b f8af 	bl	802f328 <malloc>
  if (m == 0)
 80041ca:	4604      	mov	r4, r0
 80041cc:	b318      	cbz	r0, 8004216 <gsl_matrix_int_alloc_from_matrix+0x72>
  m->size1 = n1;
 80041ce:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80041d0:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80041d2:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80041d6:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80041da:	fb06 8603 	mla	r6, r6, r3, r8
 80041de:	eb01 0686 	add.w	r6, r1, r6, lsl #2
  m->owner = 0;
 80041e2:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 80041e4:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 80041e8:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 80041ec:	4620      	mov	r0, r4
 80041ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 80041f2:	490c      	ldr	r1, [pc, #48]	; (8004224 <gsl_matrix_int_alloc_from_matrix+0x80>)
 80041f4:	480c      	ldr	r0, [pc, #48]	; (8004228 <gsl_matrix_int_alloc_from_matrix+0x84>)
 80041f6:	2304      	movs	r3, #4
 80041f8:	2282      	movs	r2, #130	; 0x82
 80041fa:	2400      	movs	r4, #0
 80041fc:	f7fe fb30 	bl	8002860 <gsl_error>
}
 8004200:	4620      	mov	r0, r4
 8004202:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8004206:	4907      	ldr	r1, [pc, #28]	; (8004224 <gsl_matrix_int_alloc_from_matrix+0x80>)
 8004208:	4808      	ldr	r0, [pc, #32]	; (800422c <gsl_matrix_int_alloc_from_matrix+0x88>)
 800420a:	2304      	movs	r3, #4
 800420c:	227d      	movs	r2, #125	; 0x7d
 800420e:	f7fe fb27 	bl	8002860 <gsl_error>
 8004212:	2400      	movs	r4, #0
 8004214:	e7ea      	b.n	80041ec <gsl_matrix_int_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004216:	4903      	ldr	r1, [pc, #12]	; (8004224 <gsl_matrix_int_alloc_from_matrix+0x80>)
 8004218:	4805      	ldr	r0, [pc, #20]	; (8004230 <gsl_matrix_int_alloc_from_matrix+0x8c>)
 800421a:	2308      	movs	r3, #8
 800421c:	228a      	movs	r2, #138	; 0x8a
 800421e:	f7fe fb1f 	bl	8002860 <gsl_error>
 8004222:	e7e3      	b.n	80041ec <gsl_matrix_int_alloc_from_matrix+0x48>
 8004224:	08030220 	.word	0x08030220
 8004228:	08030308 	.word	0x08030308
 800422c:	080302d8 	.word	0x080302d8
 8004230:	08030230 	.word	0x08030230

08004234 <gsl_matrix_int_free>:
  RETURN_IF_NULL (m);
 8004234:	b180      	cbz	r0, 8004258 <gsl_matrix_int_free+0x24>
  if (m->owner)
 8004236:	6943      	ldr	r3, [r0, #20]
{
 8004238:	b510      	push	{r4, lr}
 800423a:	4604      	mov	r4, r0
  if (m->owner)
 800423c:	b923      	cbnz	r3, 8004248 <gsl_matrix_int_free+0x14>
  free (m);
 800423e:	4620      	mov	r0, r4
}
 8004240:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004244:	f02b b878 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004248:	6900      	ldr	r0, [r0, #16]
 800424a:	f002 fea9 	bl	8006fa0 <gsl_block_int_free>
  free (m);
 800424e:	4620      	mov	r0, r4
}
 8004250:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004254:	f02b b870 	b.w	802f338 <free>
 8004258:	4770      	bx	lr
 800425a:	bf00      	nop

0800425c <gsl_matrix_int_set_identity>:
{
 800425c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800425e:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004260:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 8004262:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 8004266:	b19e      	cbz	r6, 8004290 <gsl_matrix_int_set_identity+0x34>
 8004268:	2500      	movs	r5, #0
 800426a:	3f04      	subs	r7, #4
 800426c:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 800426e:	b15c      	cbz	r4, 8004288 <gsl_matrix_int_set_identity+0x2c>
 8004270:	eb07 0285 	add.w	r2, r7, r5, lsl #2
 8004274:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004276:	1ac1      	subs	r1, r0, r3
 8004278:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 800427c:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800427e:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8004280:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004282:	f842 1f04 	str.w	r1, [r2, #4]!
      for (j = 0; j < q; j++)
 8004286:	d1f6      	bne.n	8004276 <gsl_matrix_int_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8004288:	3001      	adds	r0, #1
 800428a:	4286      	cmp	r6, r0
 800428c:	4465      	add	r5, ip
 800428e:	d1ee      	bne.n	800426e <gsl_matrix_int_set_identity+0x12>
}
 8004290:	bcf0      	pop	{r4, r5, r6, r7}
 8004292:	4770      	bx	lr

08004294 <gsl_matrix_int_set_zero>:
{
 8004294:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004296:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004298:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800429a:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 800429e:	b18f      	cbz	r7, 80042c4 <gsl_matrix_int_set_zero+0x30>
 80042a0:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 80042a4:	2000      	movs	r0, #0
 80042a6:	00b6      	lsls	r6, r6, #2
 80042a8:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80042ac:	00ad      	lsls	r5, r5, #2
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80042ae:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 80042b0:	1953      	adds	r3, r2, r5
 80042b2:	b11c      	cbz	r4, 80042bc <gsl_matrix_int_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 80042b4:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 80042b8:	4293      	cmp	r3, r2
 80042ba:	d1fb      	bne.n	80042b4 <gsl_matrix_int_set_zero+0x20>
  for (i = 0; i < p; i++)
 80042bc:	3001      	adds	r0, #1
 80042be:	4287      	cmp	r7, r0
 80042c0:	4432      	add	r2, r6
 80042c2:	d1f5      	bne.n	80042b0 <gsl_matrix_int_set_zero+0x1c>
}
 80042c4:	bcf0      	pop	{r4, r5, r6, r7}
 80042c6:	4770      	bx	lr

080042c8 <gsl_matrix_int_set_all>:
{
 80042c8:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80042ca:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80042cc:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80042ce:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 80042d2:	b187      	cbz	r7, 80042f6 <gsl_matrix_int_set_all+0x2e>
 80042d4:	ebc4 7584 	rsb	r5, r4, r4, lsl #30
 80042d8:	00b6      	lsls	r6, r6, #2
 80042da:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 80042de:	00ad      	lsls	r5, r5, #2
 80042e0:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 80042e2:	1953      	adds	r3, r2, r5
 80042e4:	b11c      	cbz	r4, 80042ee <gsl_matrix_int_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 80042e6:	f843 1b04 	str.w	r1, [r3], #4
      for (j = 0; j < q; j++)
 80042ea:	4293      	cmp	r3, r2
 80042ec:	d1fb      	bne.n	80042e6 <gsl_matrix_int_set_all+0x1e>
  for (i = 0; i < p; i++)
 80042ee:	3001      	adds	r0, #1
 80042f0:	4287      	cmp	r7, r0
 80042f2:	4432      	add	r2, r6
 80042f4:	d1f5      	bne.n	80042e2 <gsl_matrix_int_set_all+0x1a>
}
 80042f6:	bcf0      	pop	{r4, r5, r6, r7}
 80042f8:	4770      	bx	lr
 80042fa:	bf00      	nop

080042fc <gsl_matrix_ushort_alloc>:
{
 80042fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80042fe:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004300:	2018      	movs	r0, #24
{
 8004302:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004304:	f02b f810 	bl	802f328 <malloc>
  if (m == 0)
 8004308:	4604      	mov	r4, r0
 800430a:	b1b8      	cbz	r0, 800433c <gsl_matrix_ushort_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 800430c:	fb06 f007 	mul.w	r0, r6, r7
 8004310:	f002 fe52 	bl	8006fb8 <gsl_block_ushort_alloc>
  if (block == 0)
 8004314:	4605      	mov	r5, r0
 8004316:	b148      	cbz	r0, 800432c <gsl_matrix_ushort_alloc+0x30>
  m->data = block->data;
 8004318:	6843      	ldr	r3, [r0, #4]
 800431a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 800431c:	2301      	movs	r3, #1
  m->size2 = n2;
 800431e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8004322:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8004326:	60a6      	str	r6, [r4, #8]
}
 8004328:	4620      	mov	r0, r4
 800432a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 800432c:	4907      	ldr	r1, [pc, #28]	; (800434c <gsl_matrix_ushort_alloc+0x50>)
 800432e:	4808      	ldr	r0, [pc, #32]	; (8004350 <gsl_matrix_ushort_alloc+0x54>)
 8004330:	2308      	movs	r3, #8
 8004332:	2228      	movs	r2, #40	; 0x28
 8004334:	462c      	mov	r4, r5
 8004336:	f7fe fa93 	bl	8002860 <gsl_error>
 800433a:	e7f5      	b.n	8004328 <gsl_matrix_ushort_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800433c:	4903      	ldr	r1, [pc, #12]	; (800434c <gsl_matrix_ushort_alloc+0x50>)
 800433e:	4805      	ldr	r0, [pc, #20]	; (8004354 <gsl_matrix_ushort_alloc+0x58>)
 8004340:	2308      	movs	r3, #8
 8004342:	221e      	movs	r2, #30
 8004344:	f7fe fa8c 	bl	8002860 <gsl_error>
 8004348:	e7ee      	b.n	8004328 <gsl_matrix_ushort_alloc+0x2c>
 800434a:	bf00      	nop
 800434c:	08030220 	.word	0x08030220
 8004350:	0803025c 	.word	0x0803025c
 8004354:	08030230 	.word	0x08030230

08004358 <gsl_matrix_ushort_calloc>:
{
 8004358:	b570      	push	{r4, r5, r6, lr}
 800435a:	4604      	mov	r4, r0
 800435c:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 800435e:	f7ff ffcd 	bl	80042fc <gsl_matrix_ushort_alloc>
  if (m == 0)
 8004362:	4605      	mov	r5, r0
 8004364:	b188      	cbz	r0, 800438a <gsl_matrix_ushort_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8004366:	fb06 f604 	mul.w	r6, r6, r4
 800436a:	0074      	lsls	r4, r6, #1
 800436c:	68c0      	ldr	r0, [r0, #12]
 800436e:	4622      	mov	r2, r4
 8004370:	2100      	movs	r1, #0
 8004372:	f02a ffe9 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004376:	b146      	cbz	r6, 800438a <gsl_matrix_ushort_calloc+0x32>
      m->data[i] = 0;
 8004378:	68eb      	ldr	r3, [r5, #12]
 800437a:	1ea2      	subs	r2, r4, #2
 800437c:	441a      	add	r2, r3
 800437e:	2100      	movs	r1, #0
 8004380:	3b02      	subs	r3, #2
 8004382:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004386:	4293      	cmp	r3, r2
 8004388:	d1fb      	bne.n	8004382 <gsl_matrix_ushort_calloc+0x2a>
}
 800438a:	4628      	mov	r0, r5
 800438c:	bd70      	pop	{r4, r5, r6, pc}
 800438e:	bf00      	nop

08004390 <gsl_matrix_ushort_alloc_from_block>:
{
 8004390:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004394:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004398:	4599      	cmp	r9, r3
 800439a:	d325      	bcc.n	80043e8 <gsl_matrix_ushort_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 800439c:	4690      	mov	r8, r2
 800439e:	6802      	ldr	r2, [r0, #0]
 80043a0:	461e      	mov	r6, r3
 80043a2:	fb08 1309 	mla	r3, r8, r9, r1
 80043a6:	429a      	cmp	r2, r3
 80043a8:	4605      	mov	r5, r0
 80043aa:	460f      	mov	r7, r1
 80043ac:	d312      	bcc.n	80043d4 <gsl_matrix_ushort_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80043ae:	2018      	movs	r0, #24
 80043b0:	f02a ffba 	bl	802f328 <malloc>
  if (m == 0)
 80043b4:	4604      	mov	r4, r0
 80043b6:	b1f8      	cbz	r0, 80043f8 <gsl_matrix_ushort_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 80043b8:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 80043ba:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 80043be:	eb01 0147 	add.w	r1, r1, r7, lsl #1
  m->tda = d2;
 80043c2:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80043c6:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80043ca:	2300      	movs	r3, #0
 80043cc:	6143      	str	r3, [r0, #20]
}
 80043ce:	4620      	mov	r0, r4
 80043d0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 80043d4:	490c      	ldr	r1, [pc, #48]	; (8004408 <gsl_matrix_ushort_alloc_from_block+0x78>)
 80043d6:	480d      	ldr	r0, [pc, #52]	; (800440c <gsl_matrix_ushort_alloc_from_block+0x7c>)
 80043d8:	2304      	movs	r3, #4
 80043da:	225b      	movs	r2, #91	; 0x5b
 80043dc:	2400      	movs	r4, #0
 80043de:	f7fe fa3f 	bl	8002860 <gsl_error>
}
 80043e2:	4620      	mov	r0, r4
 80043e4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 80043e8:	4907      	ldr	r1, [pc, #28]	; (8004408 <gsl_matrix_ushort_alloc_from_block+0x78>)
 80043ea:	4809      	ldr	r0, [pc, #36]	; (8004410 <gsl_matrix_ushort_alloc_from_block+0x80>)
 80043ec:	2304      	movs	r3, #4
 80043ee:	2256      	movs	r2, #86	; 0x56
 80043f0:	f7fe fa36 	bl	8002860 <gsl_error>
 80043f4:	2400      	movs	r4, #0
 80043f6:	e7ea      	b.n	80043ce <gsl_matrix_ushort_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80043f8:	4903      	ldr	r1, [pc, #12]	; (8004408 <gsl_matrix_ushort_alloc_from_block+0x78>)
 80043fa:	4806      	ldr	r0, [pc, #24]	; (8004414 <gsl_matrix_ushort_alloc_from_block+0x84>)
 80043fc:	2308      	movs	r3, #8
 80043fe:	2263      	movs	r2, #99	; 0x63
 8004400:	f7fe fa2e 	bl	8002860 <gsl_error>
 8004404:	e7e3      	b.n	80043ce <gsl_matrix_ushort_alloc_from_block+0x3e>
 8004406:	bf00      	nop
 8004408:	08030220 	.word	0x08030220
 800440c:	080302ac 	.word	0x080302ac
 8004410:	08030280 	.word	0x08030280
 8004414:	08030230 	.word	0x08030230

08004418 <gsl_matrix_ushort_alloc_from_matrix>:
{
 8004418:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800441c:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 800441e:	6803      	ldr	r3, [r0, #0]
{
 8004420:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004424:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8004426:	19c8      	adds	r0, r1, r7
 8004428:	4298      	cmp	r0, r3
 800442a:	d826      	bhi.n	800447a <gsl_matrix_ushort_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 800442c:	686b      	ldr	r3, [r5, #4]
 800442e:	4690      	mov	r8, r2
 8004430:	444a      	add	r2, r9
 8004432:	429a      	cmp	r2, r3
 8004434:	d817      	bhi.n	8004466 <gsl_matrix_ushort_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004436:	2018      	movs	r0, #24
 8004438:	460e      	mov	r6, r1
 800443a:	f02a ff75 	bl	802f328 <malloc>
  if (m == 0)
 800443e:	4604      	mov	r4, r0
 8004440:	b318      	cbz	r0, 800448a <gsl_matrix_ushort_alloc_from_matrix+0x72>
  m->size1 = n1;
 8004442:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004444:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8004446:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 800444a:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 800444e:	fb06 8603 	mla	r6, r6, r3, r8
 8004452:	eb01 0646 	add.w	r6, r1, r6, lsl #1
  m->owner = 0;
 8004456:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004458:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 800445c:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8004460:	4620      	mov	r0, r4
 8004462:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8004466:	490c      	ldr	r1, [pc, #48]	; (8004498 <gsl_matrix_ushort_alloc_from_matrix+0x80>)
 8004468:	480c      	ldr	r0, [pc, #48]	; (800449c <gsl_matrix_ushort_alloc_from_matrix+0x84>)
 800446a:	2304      	movs	r3, #4
 800446c:	2282      	movs	r2, #130	; 0x82
 800446e:	2400      	movs	r4, #0
 8004470:	f7fe f9f6 	bl	8002860 <gsl_error>
}
 8004474:	4620      	mov	r0, r4
 8004476:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 800447a:	4907      	ldr	r1, [pc, #28]	; (8004498 <gsl_matrix_ushort_alloc_from_matrix+0x80>)
 800447c:	4808      	ldr	r0, [pc, #32]	; (80044a0 <gsl_matrix_ushort_alloc_from_matrix+0x88>)
 800447e:	2304      	movs	r3, #4
 8004480:	227d      	movs	r2, #125	; 0x7d
 8004482:	f7fe f9ed 	bl	8002860 <gsl_error>
 8004486:	2400      	movs	r4, #0
 8004488:	e7ea      	b.n	8004460 <gsl_matrix_ushort_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800448a:	4903      	ldr	r1, [pc, #12]	; (8004498 <gsl_matrix_ushort_alloc_from_matrix+0x80>)
 800448c:	4805      	ldr	r0, [pc, #20]	; (80044a4 <gsl_matrix_ushort_alloc_from_matrix+0x8c>)
 800448e:	2308      	movs	r3, #8
 8004490:	228a      	movs	r2, #138	; 0x8a
 8004492:	f7fe f9e5 	bl	8002860 <gsl_error>
 8004496:	e7e3      	b.n	8004460 <gsl_matrix_ushort_alloc_from_matrix+0x48>
 8004498:	08030220 	.word	0x08030220
 800449c:	08030308 	.word	0x08030308
 80044a0:	080302d8 	.word	0x080302d8
 80044a4:	08030230 	.word	0x08030230

080044a8 <gsl_matrix_ushort_free>:
  RETURN_IF_NULL (m);
 80044a8:	b180      	cbz	r0, 80044cc <gsl_matrix_ushort_free+0x24>
  if (m->owner)
 80044aa:	6943      	ldr	r3, [r0, #20]
{
 80044ac:	b510      	push	{r4, lr}
 80044ae:	4604      	mov	r4, r0
  if (m->owner)
 80044b0:	b923      	cbnz	r3, 80044bc <gsl_matrix_ushort_free+0x14>
  free (m);
 80044b2:	4620      	mov	r0, r4
}
 80044b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80044b8:	f02a bf3e 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 80044bc:	6900      	ldr	r0, [r0, #16]
 80044be:	f002 fdbd 	bl	800703c <gsl_block_ushort_free>
  free (m);
 80044c2:	4620      	mov	r0, r4
}
 80044c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80044c8:	f02a bf36 	b.w	802f338 <free>
 80044cc:	4770      	bx	lr
 80044ce:	bf00      	nop

080044d0 <gsl_matrix_ushort_set_identity>:
{
 80044d0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80044d2:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80044d4:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 80044d6:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 80044da:	b19e      	cbz	r6, 8004504 <gsl_matrix_ushort_set_identity+0x34>
 80044dc:	2500      	movs	r5, #0
 80044de:	3f02      	subs	r7, #2
 80044e0:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 80044e2:	b15c      	cbz	r4, 80044fc <gsl_matrix_ushort_set_identity+0x2c>
 80044e4:	eb07 0245 	add.w	r2, r7, r5, lsl #1
 80044e8:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80044ea:	1ac1      	subs	r1, r0, r3
 80044ec:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 80044f0:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80044f2:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 80044f4:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80044f6:	f822 1f02 	strh.w	r1, [r2, #2]!
      for (j = 0; j < q; j++)
 80044fa:	d1f6      	bne.n	80044ea <gsl_matrix_ushort_set_identity+0x1a>
  for (i = 0; i < p; i++)
 80044fc:	3001      	adds	r0, #1
 80044fe:	4286      	cmp	r6, r0
 8004500:	4465      	add	r5, ip
 8004502:	d1ee      	bne.n	80044e2 <gsl_matrix_ushort_set_identity+0x12>
}
 8004504:	bcf0      	pop	{r4, r5, r6, r7}
 8004506:	4770      	bx	lr

08004508 <gsl_matrix_ushort_set_zero>:
{
 8004508:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800450a:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 800450c:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 800450e:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8004512:	b18f      	cbz	r7, 8004538 <gsl_matrix_ushort_set_zero+0x30>
 8004514:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 8004518:	2000      	movs	r0, #0
 800451a:	0076      	lsls	r6, r6, #1
 800451c:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 8004520:	006d      	lsls	r5, r5, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004522:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8004524:	1953      	adds	r3, r2, r5
 8004526:	b11c      	cbz	r4, 8004530 <gsl_matrix_ushort_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004528:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 800452c:	4293      	cmp	r3, r2
 800452e:	d1fb      	bne.n	8004528 <gsl_matrix_ushort_set_zero+0x20>
  for (i = 0; i < p; i++)
 8004530:	3001      	adds	r0, #1
 8004532:	4287      	cmp	r7, r0
 8004534:	4432      	add	r2, r6
 8004536:	d1f5      	bne.n	8004524 <gsl_matrix_ushort_set_zero+0x1c>
}
 8004538:	bcf0      	pop	{r4, r5, r6, r7}
 800453a:	4770      	bx	lr

0800453c <gsl_matrix_ushort_set_all>:
{
 800453c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800453e:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004540:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8004542:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8004546:	b187      	cbz	r7, 800456a <gsl_matrix_ushort_set_all+0x2e>
 8004548:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 800454c:	0076      	lsls	r6, r6, #1
 800454e:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 8004552:	006d      	lsls	r5, r5, #1
 8004554:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 8004556:	1953      	adds	r3, r2, r5
 8004558:	b11c      	cbz	r4, 8004562 <gsl_matrix_ushort_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 800455a:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 800455e:	4293      	cmp	r3, r2
 8004560:	d1fb      	bne.n	800455a <gsl_matrix_ushort_set_all+0x1e>
  for (i = 0; i < p; i++)
 8004562:	3001      	adds	r0, #1
 8004564:	4287      	cmp	r7, r0
 8004566:	4432      	add	r2, r6
 8004568:	d1f5      	bne.n	8004556 <gsl_matrix_ushort_set_all+0x1a>
}
 800456a:	bcf0      	pop	{r4, r5, r6, r7}
 800456c:	4770      	bx	lr
 800456e:	bf00      	nop

08004570 <gsl_matrix_short_alloc>:
{
 8004570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004572:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004574:	2018      	movs	r0, #24
{
 8004576:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004578:	f02a fed6 	bl	802f328 <malloc>
  if (m == 0)
 800457c:	4604      	mov	r4, r0
 800457e:	b1b8      	cbz	r0, 80045b0 <gsl_matrix_short_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8004580:	fb06 f007 	mul.w	r0, r6, r7
 8004584:	f002 fd66 	bl	8007054 <gsl_block_short_alloc>
  if (block == 0)
 8004588:	4605      	mov	r5, r0
 800458a:	b148      	cbz	r0, 80045a0 <gsl_matrix_short_alloc+0x30>
  m->data = block->data;
 800458c:	6843      	ldr	r3, [r0, #4]
 800458e:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8004590:	2301      	movs	r3, #1
  m->size2 = n2;
 8004592:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8004596:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 800459a:	60a6      	str	r6, [r4, #8]
}
 800459c:	4620      	mov	r0, r4
 800459e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 80045a0:	4907      	ldr	r1, [pc, #28]	; (80045c0 <gsl_matrix_short_alloc+0x50>)
 80045a2:	4808      	ldr	r0, [pc, #32]	; (80045c4 <gsl_matrix_short_alloc+0x54>)
 80045a4:	2308      	movs	r3, #8
 80045a6:	2228      	movs	r2, #40	; 0x28
 80045a8:	462c      	mov	r4, r5
 80045aa:	f7fe f959 	bl	8002860 <gsl_error>
 80045ae:	e7f5      	b.n	800459c <gsl_matrix_short_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80045b0:	4903      	ldr	r1, [pc, #12]	; (80045c0 <gsl_matrix_short_alloc+0x50>)
 80045b2:	4805      	ldr	r0, [pc, #20]	; (80045c8 <gsl_matrix_short_alloc+0x58>)
 80045b4:	2308      	movs	r3, #8
 80045b6:	221e      	movs	r2, #30
 80045b8:	f7fe f952 	bl	8002860 <gsl_error>
 80045bc:	e7ee      	b.n	800459c <gsl_matrix_short_alloc+0x2c>
 80045be:	bf00      	nop
 80045c0:	08030220 	.word	0x08030220
 80045c4:	0803025c 	.word	0x0803025c
 80045c8:	08030230 	.word	0x08030230

080045cc <gsl_matrix_short_calloc>:
{
 80045cc:	b570      	push	{r4, r5, r6, lr}
 80045ce:	4604      	mov	r4, r0
 80045d0:	460e      	mov	r6, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 80045d2:	f7ff ffcd 	bl	8004570 <gsl_matrix_short_alloc>
  if (m == 0)
 80045d6:	4605      	mov	r5, r0
 80045d8:	b188      	cbz	r0, 80045fe <gsl_matrix_short_calloc+0x32>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 80045da:	fb06 f604 	mul.w	r6, r6, r4
 80045de:	0074      	lsls	r4, r6, #1
 80045e0:	68c0      	ldr	r0, [r0, #12]
 80045e2:	4622      	mov	r2, r4
 80045e4:	2100      	movs	r1, #0
 80045e6:	f02a feaf 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80045ea:	b146      	cbz	r6, 80045fe <gsl_matrix_short_calloc+0x32>
      m->data[i] = 0;
 80045ec:	68eb      	ldr	r3, [r5, #12]
 80045ee:	1ea2      	subs	r2, r4, #2
 80045f0:	441a      	add	r2, r3
 80045f2:	2100      	movs	r1, #0
 80045f4:	3b02      	subs	r3, #2
 80045f6:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 80045fa:	4293      	cmp	r3, r2
 80045fc:	d1fb      	bne.n	80045f6 <gsl_matrix_short_calloc+0x2a>
}
 80045fe:	4628      	mov	r0, r5
 8004600:	bd70      	pop	{r4, r5, r6, pc}
 8004602:	bf00      	nop

08004604 <gsl_matrix_short_alloc_from_block>:
{
 8004604:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004608:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 800460c:	4599      	cmp	r9, r3
 800460e:	d325      	bcc.n	800465c <gsl_matrix_short_alloc_from_block+0x58>
  else if (block->size < offset + n1 * d2)
 8004610:	4690      	mov	r8, r2
 8004612:	6802      	ldr	r2, [r0, #0]
 8004614:	461e      	mov	r6, r3
 8004616:	fb08 1309 	mla	r3, r8, r9, r1
 800461a:	429a      	cmp	r2, r3
 800461c:	4605      	mov	r5, r0
 800461e:	460f      	mov	r7, r1
 8004620:	d312      	bcc.n	8004648 <gsl_matrix_short_alloc_from_block+0x44>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004622:	2018      	movs	r0, #24
 8004624:	f02a fe80 	bl	802f328 <malloc>
  if (m == 0)
 8004628:	4604      	mov	r4, r0
 800462a:	b1f8      	cbz	r0, 800466c <gsl_matrix_short_alloc_from_block+0x68>
  m->data = block->data + MULTIPLICITY * offset;
 800462c:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 800462e:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8004632:	eb01 0147 	add.w	r1, r1, r7, lsl #1
  m->tda = d2;
 8004636:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 800463a:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 800463e:	2300      	movs	r3, #0
 8004640:	6143      	str	r3, [r0, #20]
}
 8004642:	4620      	mov	r0, r4
 8004644:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8004648:	490c      	ldr	r1, [pc, #48]	; (800467c <gsl_matrix_short_alloc_from_block+0x78>)
 800464a:	480d      	ldr	r0, [pc, #52]	; (8004680 <gsl_matrix_short_alloc_from_block+0x7c>)
 800464c:	2304      	movs	r3, #4
 800464e:	225b      	movs	r2, #91	; 0x5b
 8004650:	2400      	movs	r4, #0
 8004652:	f7fe f905 	bl	8002860 <gsl_error>
}
 8004656:	4620      	mov	r0, r4
 8004658:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 800465c:	4907      	ldr	r1, [pc, #28]	; (800467c <gsl_matrix_short_alloc_from_block+0x78>)
 800465e:	4809      	ldr	r0, [pc, #36]	; (8004684 <gsl_matrix_short_alloc_from_block+0x80>)
 8004660:	2304      	movs	r3, #4
 8004662:	2256      	movs	r2, #86	; 0x56
 8004664:	f7fe f8fc 	bl	8002860 <gsl_error>
 8004668:	2400      	movs	r4, #0
 800466a:	e7ea      	b.n	8004642 <gsl_matrix_short_alloc_from_block+0x3e>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 800466c:	4903      	ldr	r1, [pc, #12]	; (800467c <gsl_matrix_short_alloc_from_block+0x78>)
 800466e:	4806      	ldr	r0, [pc, #24]	; (8004688 <gsl_matrix_short_alloc_from_block+0x84>)
 8004670:	2308      	movs	r3, #8
 8004672:	2263      	movs	r2, #99	; 0x63
 8004674:	f7fe f8f4 	bl	8002860 <gsl_error>
 8004678:	e7e3      	b.n	8004642 <gsl_matrix_short_alloc_from_block+0x3e>
 800467a:	bf00      	nop
 800467c:	08030220 	.word	0x08030220
 8004680:	080302ac 	.word	0x080302ac
 8004684:	08030280 	.word	0x08030280
 8004688:	08030230 	.word	0x08030230

0800468c <gsl_matrix_short_alloc_from_matrix>:
{
 800468c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004690:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8004692:	6803      	ldr	r3, [r0, #0]
{
 8004694:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004698:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 800469a:	19c8      	adds	r0, r1, r7
 800469c:	4298      	cmp	r0, r3
 800469e:	d826      	bhi.n	80046ee <gsl_matrix_short_alloc_from_matrix+0x62>
  else if (k2 + n2 > mm->size2)
 80046a0:	686b      	ldr	r3, [r5, #4]
 80046a2:	4690      	mov	r8, r2
 80046a4:	444a      	add	r2, r9
 80046a6:	429a      	cmp	r2, r3
 80046a8:	d817      	bhi.n	80046da <gsl_matrix_short_alloc_from_matrix+0x4e>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80046aa:	2018      	movs	r0, #24
 80046ac:	460e      	mov	r6, r1
 80046ae:	f02a fe3b 	bl	802f328 <malloc>
  if (m == 0)
 80046b2:	4604      	mov	r4, r0
 80046b4:	b318      	cbz	r0, 80046fe <gsl_matrix_short_alloc_from_matrix+0x72>
  m->size1 = n1;
 80046b6:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80046b8:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 80046ba:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 80046be:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 80046c2:	fb06 8603 	mla	r6, r6, r3, r8
 80046c6:	eb01 0646 	add.w	r6, r1, r6, lsl #1
  m->owner = 0;
 80046ca:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 80046cc:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 80046d0:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 80046d4:	4620      	mov	r0, r4
 80046d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 80046da:	490c      	ldr	r1, [pc, #48]	; (800470c <gsl_matrix_short_alloc_from_matrix+0x80>)
 80046dc:	480c      	ldr	r0, [pc, #48]	; (8004710 <gsl_matrix_short_alloc_from_matrix+0x84>)
 80046de:	2304      	movs	r3, #4
 80046e0:	2282      	movs	r2, #130	; 0x82
 80046e2:	2400      	movs	r4, #0
 80046e4:	f7fe f8bc 	bl	8002860 <gsl_error>
}
 80046e8:	4620      	mov	r0, r4
 80046ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 80046ee:	4907      	ldr	r1, [pc, #28]	; (800470c <gsl_matrix_short_alloc_from_matrix+0x80>)
 80046f0:	4808      	ldr	r0, [pc, #32]	; (8004714 <gsl_matrix_short_alloc_from_matrix+0x88>)
 80046f2:	2304      	movs	r3, #4
 80046f4:	227d      	movs	r2, #125	; 0x7d
 80046f6:	f7fe f8b3 	bl	8002860 <gsl_error>
 80046fa:	2400      	movs	r4, #0
 80046fc:	e7ea      	b.n	80046d4 <gsl_matrix_short_alloc_from_matrix+0x48>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80046fe:	4903      	ldr	r1, [pc, #12]	; (800470c <gsl_matrix_short_alloc_from_matrix+0x80>)
 8004700:	4805      	ldr	r0, [pc, #20]	; (8004718 <gsl_matrix_short_alloc_from_matrix+0x8c>)
 8004702:	2308      	movs	r3, #8
 8004704:	228a      	movs	r2, #138	; 0x8a
 8004706:	f7fe f8ab 	bl	8002860 <gsl_error>
 800470a:	e7e3      	b.n	80046d4 <gsl_matrix_short_alloc_from_matrix+0x48>
 800470c:	08030220 	.word	0x08030220
 8004710:	08030308 	.word	0x08030308
 8004714:	080302d8 	.word	0x080302d8
 8004718:	08030230 	.word	0x08030230

0800471c <gsl_matrix_short_free>:
  RETURN_IF_NULL (m);
 800471c:	b180      	cbz	r0, 8004740 <gsl_matrix_short_free+0x24>
  if (m->owner)
 800471e:	6943      	ldr	r3, [r0, #20]
{
 8004720:	b510      	push	{r4, lr}
 8004722:	4604      	mov	r4, r0
  if (m->owner)
 8004724:	b923      	cbnz	r3, 8004730 <gsl_matrix_short_free+0x14>
  free (m);
 8004726:	4620      	mov	r0, r4
}
 8004728:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 800472c:	f02a be04 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004730:	6900      	ldr	r0, [r0, #16]
 8004732:	f002 fcd1 	bl	80070d8 <gsl_block_short_free>
  free (m);
 8004736:	4620      	mov	r0, r4
}
 8004738:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 800473c:	f02a bdfc 	b.w	802f338 <free>
 8004740:	4770      	bx	lr
 8004742:	bf00      	nop

08004744 <gsl_matrix_short_set_identity>:
{
 8004744:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004746:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004748:	68c7      	ldr	r7, [r0, #12]
  const size_t tda = m->tda ;
 800474a:	e9d0 4c01 	ldrd	r4, ip, [r0, #4]
  for (i = 0; i < p; i++)
 800474e:	b19e      	cbz	r6, 8004778 <gsl_matrix_short_set_identity+0x34>
 8004750:	2500      	movs	r5, #0
 8004752:	3f02      	subs	r7, #2
 8004754:	4628      	mov	r0, r5
      for (j = 0; j < q; j++)
 8004756:	b15c      	cbz	r4, 8004770 <gsl_matrix_short_set_identity+0x2c>
 8004758:	eb07 0245 	add.w	r2, r7, r5, lsl #1
 800475c:	2300      	movs	r3, #0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800475e:	1ac1      	subs	r1, r0, r3
 8004760:	fab1 f181 	clz	r1, r1
      for (j = 0; j < q; j++)
 8004764:	3301      	adds	r3, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004766:	0949      	lsrs	r1, r1, #5
      for (j = 0; j < q; j++)
 8004768:	429c      	cmp	r4, r3
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 800476a:	f822 1f02 	strh.w	r1, [r2, #2]!
      for (j = 0; j < q; j++)
 800476e:	d1f6      	bne.n	800475e <gsl_matrix_short_set_identity+0x1a>
  for (i = 0; i < p; i++)
 8004770:	3001      	adds	r0, #1
 8004772:	4286      	cmp	r6, r0
 8004774:	4465      	add	r5, ip
 8004776:	d1ee      	bne.n	8004756 <gsl_matrix_short_set_identity+0x12>
}
 8004778:	bcf0      	pop	{r4, r5, r6, r7}
 800477a:	4770      	bx	lr

0800477c <gsl_matrix_short_set_zero>:
{
 800477c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 800477e:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004780:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 8004782:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 8004786:	b18f      	cbz	r7, 80047ac <gsl_matrix_short_set_zero+0x30>
 8004788:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 800478c:	2000      	movs	r0, #0
 800478e:	0076      	lsls	r6, r6, #1
 8004790:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 8004794:	006d      	lsls	r5, r5, #1
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004796:	4601      	mov	r1, r0
      for (j = 0; j < q; j++)
 8004798:	1953      	adds	r3, r2, r5
 800479a:	b11c      	cbz	r4, 80047a4 <gsl_matrix_short_set_zero+0x28>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 800479c:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 80047a0:	4293      	cmp	r3, r2
 80047a2:	d1fb      	bne.n	800479c <gsl_matrix_short_set_zero+0x20>
  for (i = 0; i < p; i++)
 80047a4:	3001      	adds	r0, #1
 80047a6:	4287      	cmp	r7, r0
 80047a8:	4432      	add	r2, r6
 80047aa:	d1f5      	bne.n	8004798 <gsl_matrix_short_set_zero+0x1c>
}
 80047ac:	bcf0      	pop	{r4, r5, r6, r7}
 80047ae:	4770      	bx	lr

080047b0 <gsl_matrix_short_set_all>:
{
 80047b0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80047b2:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80047b4:	68c2      	ldr	r2, [r0, #12]
  const size_t tda = m->tda ;
 80047b6:	e9d0 4601 	ldrd	r4, r6, [r0, #4]
  for (i = 0; i < p; i++)
 80047ba:	b187      	cbz	r7, 80047de <gsl_matrix_short_set_all+0x2e>
 80047bc:	ebc4 75c4 	rsb	r5, r4, r4, lsl #31
 80047c0:	0076      	lsls	r6, r6, #1
 80047c2:	eb02 0244 	add.w	r2, r2, r4, lsl #1
 80047c6:	006d      	lsls	r5, r5, #1
 80047c8:	2000      	movs	r0, #0
      for (j = 0; j < q; j++)
 80047ca:	1953      	adds	r3, r2, r5
 80047cc:	b11c      	cbz	r4, 80047d6 <gsl_matrix_short_set_all+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 80047ce:	f823 1b02 	strh.w	r1, [r3], #2
      for (j = 0; j < q; j++)
 80047d2:	4293      	cmp	r3, r2
 80047d4:	d1fb      	bne.n	80047ce <gsl_matrix_short_set_all+0x1e>
  for (i = 0; i < p; i++)
 80047d6:	3001      	adds	r0, #1
 80047d8:	4287      	cmp	r7, r0
 80047da:	4432      	add	r2, r6
 80047dc:	d1f5      	bne.n	80047ca <gsl_matrix_short_set_all+0x1a>
}
 80047de:	bcf0      	pop	{r4, r5, r6, r7}
 80047e0:	4770      	bx	lr
 80047e2:	bf00      	nop

080047e4 <gsl_matrix_uchar_alloc>:
{
 80047e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80047e6:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80047e8:	2018      	movs	r0, #24
{
 80047ea:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 80047ec:	f02a fd9c 	bl	802f328 <malloc>
  if (m == 0)
 80047f0:	4604      	mov	r4, r0
 80047f2:	b1b8      	cbz	r0, 8004824 <gsl_matrix_uchar_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 80047f4:	fb06 f007 	mul.w	r0, r6, r7
 80047f8:	f002 fc7a 	bl	80070f0 <gsl_block_uchar_alloc>
  if (block == 0)
 80047fc:	4605      	mov	r5, r0
 80047fe:	b148      	cbz	r0, 8004814 <gsl_matrix_uchar_alloc+0x30>
  m->data = block->data;
 8004800:	6843      	ldr	r3, [r0, #4]
 8004802:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8004804:	2301      	movs	r3, #1
  m->size2 = n2;
 8004806:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 800480a:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 800480e:	60a6      	str	r6, [r4, #8]
}
 8004810:	4620      	mov	r0, r4
 8004812:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8004814:	4907      	ldr	r1, [pc, #28]	; (8004834 <gsl_matrix_uchar_alloc+0x50>)
 8004816:	4808      	ldr	r0, [pc, #32]	; (8004838 <gsl_matrix_uchar_alloc+0x54>)
 8004818:	2308      	movs	r3, #8
 800481a:	2228      	movs	r2, #40	; 0x28
 800481c:	462c      	mov	r4, r5
 800481e:	f7fe f81f 	bl	8002860 <gsl_error>
 8004822:	e7f5      	b.n	8004810 <gsl_matrix_uchar_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004824:	4903      	ldr	r1, [pc, #12]	; (8004834 <gsl_matrix_uchar_alloc+0x50>)
 8004826:	4805      	ldr	r0, [pc, #20]	; (800483c <gsl_matrix_uchar_alloc+0x58>)
 8004828:	2308      	movs	r3, #8
 800482a:	221e      	movs	r2, #30
 800482c:	f7fe f818 	bl	8002860 <gsl_error>
 8004830:	e7ee      	b.n	8004810 <gsl_matrix_uchar_alloc+0x2c>
 8004832:	bf00      	nop
 8004834:	08030220 	.word	0x08030220
 8004838:	0803025c 	.word	0x0803025c
 800483c:	08030230 	.word	0x08030230

08004840 <gsl_matrix_uchar_calloc>:
{
 8004840:	b570      	push	{r4, r5, r6, lr}
 8004842:	4606      	mov	r6, r0
 8004844:	460c      	mov	r4, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8004846:	f7ff ffcd 	bl	80047e4 <gsl_matrix_uchar_alloc>
  if (m == 0)
 800484a:	4605      	mov	r5, r0
 800484c:	b170      	cbz	r0, 800486c <gsl_matrix_uchar_calloc+0x2c>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 800484e:	fb04 f406 	mul.w	r4, r4, r6
 8004852:	68c0      	ldr	r0, [r0, #12]
 8004854:	4622      	mov	r2, r4
 8004856:	2100      	movs	r1, #0
 8004858:	f02a fd76 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 800485c:	b134      	cbz	r4, 800486c <gsl_matrix_uchar_calloc+0x2c>
 800485e:	2300      	movs	r3, #0
      m->data[i] = 0;
 8004860:	461a      	mov	r2, r3
 8004862:	68e9      	ldr	r1, [r5, #12]
 8004864:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004866:	3301      	adds	r3, #1
 8004868:	429c      	cmp	r4, r3
 800486a:	d1fa      	bne.n	8004862 <gsl_matrix_uchar_calloc+0x22>
}
 800486c:	4628      	mov	r0, r5
 800486e:	bd70      	pop	{r4, r5, r6, pc}

08004870 <gsl_matrix_uchar_alloc_from_block>:
{
 8004870:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004874:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004878:	4599      	cmp	r9, r3
 800487a:	d324      	bcc.n	80048c6 <gsl_matrix_uchar_alloc_from_block+0x56>
  else if (block->size < offset + n1 * d2)
 800487c:	4690      	mov	r8, r2
 800487e:	6802      	ldr	r2, [r0, #0]
 8004880:	461e      	mov	r6, r3
 8004882:	fb08 1309 	mla	r3, r8, r9, r1
 8004886:	429a      	cmp	r2, r3
 8004888:	4605      	mov	r5, r0
 800488a:	460f      	mov	r7, r1
 800488c:	d311      	bcc.n	80048b2 <gsl_matrix_uchar_alloc_from_block+0x42>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 800488e:	2018      	movs	r0, #24
 8004890:	f02a fd4a 	bl	802f328 <malloc>
  if (m == 0)
 8004894:	4604      	mov	r4, r0
 8004896:	b1f0      	cbz	r0, 80048d6 <gsl_matrix_uchar_alloc_from_block+0x66>
  m->data = block->data + MULTIPLICITY * offset;
 8004898:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 800489a:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 800489e:	4439      	add	r1, r7
  m->tda = d2;
 80048a0:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 80048a4:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 80048a8:	2300      	movs	r3, #0
 80048aa:	6143      	str	r3, [r0, #20]
}
 80048ac:	4620      	mov	r0, r4
 80048ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 80048b2:	490c      	ldr	r1, [pc, #48]	; (80048e4 <gsl_matrix_uchar_alloc_from_block+0x74>)
 80048b4:	480c      	ldr	r0, [pc, #48]	; (80048e8 <gsl_matrix_uchar_alloc_from_block+0x78>)
 80048b6:	2304      	movs	r3, #4
 80048b8:	225b      	movs	r2, #91	; 0x5b
 80048ba:	2400      	movs	r4, #0
 80048bc:	f7fd ffd0 	bl	8002860 <gsl_error>
}
 80048c0:	4620      	mov	r0, r4
 80048c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 80048c6:	4907      	ldr	r1, [pc, #28]	; (80048e4 <gsl_matrix_uchar_alloc_from_block+0x74>)
 80048c8:	4808      	ldr	r0, [pc, #32]	; (80048ec <gsl_matrix_uchar_alloc_from_block+0x7c>)
 80048ca:	2304      	movs	r3, #4
 80048cc:	2256      	movs	r2, #86	; 0x56
 80048ce:	f7fd ffc7 	bl	8002860 <gsl_error>
 80048d2:	2400      	movs	r4, #0
 80048d4:	e7ea      	b.n	80048ac <gsl_matrix_uchar_alloc_from_block+0x3c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 80048d6:	4903      	ldr	r1, [pc, #12]	; (80048e4 <gsl_matrix_uchar_alloc_from_block+0x74>)
 80048d8:	4805      	ldr	r0, [pc, #20]	; (80048f0 <gsl_matrix_uchar_alloc_from_block+0x80>)
 80048da:	2308      	movs	r3, #8
 80048dc:	2263      	movs	r2, #99	; 0x63
 80048de:	f7fd ffbf 	bl	8002860 <gsl_error>
 80048e2:	e7e3      	b.n	80048ac <gsl_matrix_uchar_alloc_from_block+0x3c>
 80048e4:	08030220 	.word	0x08030220
 80048e8:	080302ac 	.word	0x080302ac
 80048ec:	08030280 	.word	0x08030280
 80048f0:	08030230 	.word	0x08030230

080048f4 <gsl_matrix_uchar_alloc_from_matrix>:
{
 80048f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80048f8:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 80048fa:	6803      	ldr	r3, [r0, #0]
{
 80048fc:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004900:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8004902:	19c8      	adds	r0, r1, r7
 8004904:	4298      	cmp	r0, r3
 8004906:	d825      	bhi.n	8004954 <gsl_matrix_uchar_alloc_from_matrix+0x60>
  else if (k2 + n2 > mm->size2)
 8004908:	686b      	ldr	r3, [r5, #4]
 800490a:	4690      	mov	r8, r2
 800490c:	444a      	add	r2, r9
 800490e:	429a      	cmp	r2, r3
 8004910:	d816      	bhi.n	8004940 <gsl_matrix_uchar_alloc_from_matrix+0x4c>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004912:	2018      	movs	r0, #24
 8004914:	460e      	mov	r6, r1
 8004916:	f02a fd07 	bl	802f328 <malloc>
  if (m == 0)
 800491a:	4604      	mov	r4, r0
 800491c:	b310      	cbz	r0, 8004964 <gsl_matrix_uchar_alloc_from_matrix+0x70>
  m->size1 = n1;
 800491e:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004920:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8004922:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8004926:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 800492a:	fb06 8603 	mla	r6, r6, r3, r8
 800492e:	440e      	add	r6, r1
  m->owner = 0;
 8004930:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004932:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8004936:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 800493a:	4620      	mov	r0, r4
 800493c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8004940:	490c      	ldr	r1, [pc, #48]	; (8004974 <gsl_matrix_uchar_alloc_from_matrix+0x80>)
 8004942:	480d      	ldr	r0, [pc, #52]	; (8004978 <gsl_matrix_uchar_alloc_from_matrix+0x84>)
 8004944:	2304      	movs	r3, #4
 8004946:	2282      	movs	r2, #130	; 0x82
 8004948:	2400      	movs	r4, #0
 800494a:	f7fd ff89 	bl	8002860 <gsl_error>
}
 800494e:	4620      	mov	r0, r4
 8004950:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8004954:	4907      	ldr	r1, [pc, #28]	; (8004974 <gsl_matrix_uchar_alloc_from_matrix+0x80>)
 8004956:	4809      	ldr	r0, [pc, #36]	; (800497c <gsl_matrix_uchar_alloc_from_matrix+0x88>)
 8004958:	2304      	movs	r3, #4
 800495a:	227d      	movs	r2, #125	; 0x7d
 800495c:	f7fd ff80 	bl	8002860 <gsl_error>
 8004960:	2400      	movs	r4, #0
 8004962:	e7ea      	b.n	800493a <gsl_matrix_uchar_alloc_from_matrix+0x46>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004964:	4903      	ldr	r1, [pc, #12]	; (8004974 <gsl_matrix_uchar_alloc_from_matrix+0x80>)
 8004966:	4806      	ldr	r0, [pc, #24]	; (8004980 <gsl_matrix_uchar_alloc_from_matrix+0x8c>)
 8004968:	2308      	movs	r3, #8
 800496a:	228a      	movs	r2, #138	; 0x8a
 800496c:	f7fd ff78 	bl	8002860 <gsl_error>
 8004970:	e7e3      	b.n	800493a <gsl_matrix_uchar_alloc_from_matrix+0x46>
 8004972:	bf00      	nop
 8004974:	08030220 	.word	0x08030220
 8004978:	08030308 	.word	0x08030308
 800497c:	080302d8 	.word	0x080302d8
 8004980:	08030230 	.word	0x08030230

08004984 <gsl_matrix_uchar_free>:
  RETURN_IF_NULL (m);
 8004984:	b180      	cbz	r0, 80049a8 <gsl_matrix_uchar_free+0x24>
  if (m->owner)
 8004986:	6943      	ldr	r3, [r0, #20]
{
 8004988:	b510      	push	{r4, lr}
 800498a:	4604      	mov	r4, r0
  if (m->owner)
 800498c:	b923      	cbnz	r3, 8004998 <gsl_matrix_uchar_free+0x14>
  free (m);
 800498e:	4620      	mov	r0, r4
}
 8004990:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004994:	f02a bcd0 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004998:	6900      	ldr	r0, [r0, #16]
 800499a:	f002 fbe9 	bl	8007170 <gsl_block_uchar_free>
  free (m);
 800499e:	4620      	mov	r0, r4
}
 80049a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 80049a4:	f02a bcc8 	b.w	802f338 <free>
 80049a8:	4770      	bx	lr
 80049aa:	bf00      	nop

080049ac <gsl_matrix_uchar_set_identity>:
{
 80049ac:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 80049ae:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 80049b0:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  const size_t tda = m->tda ;
 80049b4:	e9d0 c501 	ldrd	ip, r5, [r0, #4]
  for (i = 0; i < p; i++)
 80049b8:	b1d7      	cbz	r7, 80049f0 <gsl_matrix_uchar_set_identity+0x44>
 80049ba:	2600      	movs	r6, #0
 80049bc:	4631      	mov	r1, r6
 80049be:	f1ce 0400 	rsb	r4, lr, #0
 80049c2:	eb0e 000c 	add.w	r0, lr, ip
      for (j = 0; j < q; j++)
 80049c6:	eb0e 0306 	add.w	r3, lr, r6
 80049ca:	f1bc 0f00 	cmp.w	ip, #0
 80049ce:	d008      	beq.n	80049e2 <gsl_matrix_uchar_set_identity+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 80049d0:	191a      	adds	r2, r3, r4
 80049d2:	1a52      	subs	r2, r2, r1
 80049d4:	fab2 f282 	clz	r2, r2
 80049d8:	0952      	lsrs	r2, r2, #5
 80049da:	f803 2b01 	strb.w	r2, [r3], #1
      for (j = 0; j < q; j++)
 80049de:	4283      	cmp	r3, r0
 80049e0:	d1f6      	bne.n	80049d0 <gsl_matrix_uchar_set_identity+0x24>
  for (i = 0; i < p; i++)
 80049e2:	3101      	adds	r1, #1
 80049e4:	428f      	cmp	r7, r1
 80049e6:	eba4 0405 	sub.w	r4, r4, r5
 80049ea:	442e      	add	r6, r5
 80049ec:	4428      	add	r0, r5
 80049ee:	d1ea      	bne.n	80049c6 <gsl_matrix_uchar_set_identity+0x1a>
}
 80049f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80049f2:	bf00      	nop

080049f4 <gsl_matrix_uchar_set_zero>:
{
 80049f4:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 80049f6:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 80049f8:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 80049fc:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004a00:	b186      	cbz	r6, 8004a24 <gsl_matrix_uchar_set_zero+0x30>
 8004a02:	2000      	movs	r0, #0
 8004a04:	4604      	mov	r4, r0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004a06:	4601      	mov	r1, r0
 8004a08:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004a0c:	eb0c 0300 	add.w	r3, ip, r0
 8004a10:	b11f      	cbz	r7, 8004a1a <gsl_matrix_uchar_set_zero+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004a12:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004a16:	4293      	cmp	r3, r2
 8004a18:	d1fb      	bne.n	8004a12 <gsl_matrix_uchar_set_zero+0x1e>
  for (i = 0; i < p; i++)
 8004a1a:	3401      	adds	r4, #1
 8004a1c:	42a6      	cmp	r6, r4
 8004a1e:	4428      	add	r0, r5
 8004a20:	442a      	add	r2, r5
 8004a22:	d1f3      	bne.n	8004a0c <gsl_matrix_uchar_set_zero+0x18>
}
 8004a24:	bcf0      	pop	{r4, r5, r6, r7}
 8004a26:	4770      	bx	lr

08004a28 <gsl_matrix_uchar_set_all>:
{
 8004a28:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004a2a:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004a2c:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 8004a30:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004a34:	b17e      	cbz	r6, 8004a56 <gsl_matrix_uchar_set_all+0x2e>
 8004a36:	2400      	movs	r4, #0
 8004a38:	4620      	mov	r0, r4
 8004a3a:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004a3e:	eb0c 0304 	add.w	r3, ip, r4
 8004a42:	b11f      	cbz	r7, 8004a4c <gsl_matrix_uchar_set_all+0x24>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8004a44:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004a48:	4293      	cmp	r3, r2
 8004a4a:	d1fb      	bne.n	8004a44 <gsl_matrix_uchar_set_all+0x1c>
  for (i = 0; i < p; i++)
 8004a4c:	3001      	adds	r0, #1
 8004a4e:	4286      	cmp	r6, r0
 8004a50:	442c      	add	r4, r5
 8004a52:	442a      	add	r2, r5
 8004a54:	d1f3      	bne.n	8004a3e <gsl_matrix_uchar_set_all+0x16>
}
 8004a56:	bcf0      	pop	{r4, r5, r6, r7}
 8004a58:	4770      	bx	lr
 8004a5a:	bf00      	nop

08004a5c <gsl_matrix_char_alloc>:
{
 8004a5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004a5e:	4607      	mov	r7, r0
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004a60:	2018      	movs	r0, #24
{
 8004a62:	460e      	mov	r6, r1
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004a64:	f02a fc60 	bl	802f328 <malloc>
  if (m == 0)
 8004a68:	4604      	mov	r4, r0
 8004a6a:	b1b8      	cbz	r0, 8004a9c <gsl_matrix_char_alloc+0x40>
  block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
 8004a6c:	fb06 f007 	mul.w	r0, r6, r7
 8004a70:	f002 fb8a 	bl	8007188 <gsl_block_char_alloc>
  if (block == 0)
 8004a74:	4605      	mov	r5, r0
 8004a76:	b148      	cbz	r0, 8004a8c <gsl_matrix_char_alloc+0x30>
  m->data = block->data;
 8004a78:	6843      	ldr	r3, [r0, #4]
 8004a7a:	60e3      	str	r3, [r4, #12]
  m->owner = 1;
 8004a7c:	2301      	movs	r3, #1
  m->size2 = n2;
 8004a7e:	e9c4 7600 	strd	r7, r6, [r4]
  m->owner = 1;
 8004a82:	e9c4 0304 	strd	r0, r3, [r4, #16]
  m->tda = n2; 
 8004a86:	60a6      	str	r6, [r4, #8]
}
 8004a88:	4620      	mov	r0, r4
 8004a8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      GSL_ERROR_VAL ("failed to allocate space for block",
 8004a8c:	4907      	ldr	r1, [pc, #28]	; (8004aac <gsl_matrix_char_alloc+0x50>)
 8004a8e:	4808      	ldr	r0, [pc, #32]	; (8004ab0 <gsl_matrix_char_alloc+0x54>)
 8004a90:	2308      	movs	r3, #8
 8004a92:	2228      	movs	r2, #40	; 0x28
 8004a94:	462c      	mov	r4, r5
 8004a96:	f7fd fee3 	bl	8002860 <gsl_error>
 8004a9a:	e7f5      	b.n	8004a88 <gsl_matrix_char_alloc+0x2c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004a9c:	4903      	ldr	r1, [pc, #12]	; (8004aac <gsl_matrix_char_alloc+0x50>)
 8004a9e:	4805      	ldr	r0, [pc, #20]	; (8004ab4 <gsl_matrix_char_alloc+0x58>)
 8004aa0:	2308      	movs	r3, #8
 8004aa2:	221e      	movs	r2, #30
 8004aa4:	f7fd fedc 	bl	8002860 <gsl_error>
 8004aa8:	e7ee      	b.n	8004a88 <gsl_matrix_char_alloc+0x2c>
 8004aaa:	bf00      	nop
 8004aac:	08030220 	.word	0x08030220
 8004ab0:	0803025c 	.word	0x0803025c
 8004ab4:	08030230 	.word	0x08030230

08004ab8 <gsl_matrix_char_calloc>:
{
 8004ab8:	b570      	push	{r4, r5, r6, lr}
 8004aba:	4606      	mov	r6, r0
 8004abc:	460c      	mov	r4, r1
  TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
 8004abe:	f7ff ffcd 	bl	8004a5c <gsl_matrix_char_alloc>
  if (m == 0)
 8004ac2:	4605      	mov	r5, r0
 8004ac4:	b170      	cbz	r0, 8004ae4 <gsl_matrix_char_calloc+0x2c>
  memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
 8004ac6:	fb04 f406 	mul.w	r4, r4, r6
 8004aca:	68c0      	ldr	r0, [r0, #12]
 8004acc:	4622      	mov	r2, r4
 8004ace:	2100      	movs	r1, #0
 8004ad0:	f02a fc3a 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004ad4:	b134      	cbz	r4, 8004ae4 <gsl_matrix_char_calloc+0x2c>
 8004ad6:	2300      	movs	r3, #0
      m->data[i] = 0;
 8004ad8:	461a      	mov	r2, r3
 8004ada:	68e9      	ldr	r1, [r5, #12]
 8004adc:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
 8004ade:	3301      	adds	r3, #1
 8004ae0:	429c      	cmp	r4, r3
 8004ae2:	d1fa      	bne.n	8004ada <gsl_matrix_char_calloc+0x22>
}
 8004ae4:	4628      	mov	r0, r5
 8004ae6:	bd70      	pop	{r4, r5, r6, pc}

08004ae8 <gsl_matrix_char_alloc_from_block>:
{
 8004ae8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004aec:	f8dd 9020 	ldr.w	r9, [sp, #32]
  if (d2 < n2)
 8004af0:	4599      	cmp	r9, r3
 8004af2:	d324      	bcc.n	8004b3e <gsl_matrix_char_alloc_from_block+0x56>
  else if (block->size < offset + n1 * d2)
 8004af4:	4690      	mov	r8, r2
 8004af6:	6802      	ldr	r2, [r0, #0]
 8004af8:	461e      	mov	r6, r3
 8004afa:	fb08 1309 	mla	r3, r8, r9, r1
 8004afe:	429a      	cmp	r2, r3
 8004b00:	4605      	mov	r5, r0
 8004b02:	460f      	mov	r7, r1
 8004b04:	d311      	bcc.n	8004b2a <gsl_matrix_char_alloc_from_block+0x42>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004b06:	2018      	movs	r0, #24
 8004b08:	f02a fc0e 	bl	802f328 <malloc>
  if (m == 0)
 8004b0c:	4604      	mov	r4, r0
 8004b0e:	b1f0      	cbz	r0, 8004b4e <gsl_matrix_char_alloc_from_block+0x66>
  m->data = block->data + MULTIPLICITY * offset;
 8004b10:	6869      	ldr	r1, [r5, #4]
  m->size1 = n1;
 8004b12:	f8c0 8000 	str.w	r8, [r0]
  m->data = block->data + MULTIPLICITY * offset;
 8004b16:	4439      	add	r1, r7
  m->tda = d2;
 8004b18:	e9c0 6901 	strd	r6, r9, [r0, #4]
  m->data = block->data + MULTIPLICITY * offset;
 8004b1c:	e9c0 1503 	strd	r1, r5, [r0, #12]
  m->owner = 0;
 8004b20:	2300      	movs	r3, #0
 8004b22:	6143      	str	r3, [r0, #20]
}
 8004b24:	4620      	mov	r0, r4
 8004b26:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix size exceeds available block size",
 8004b2a:	490c      	ldr	r1, [pc, #48]	; (8004b5c <gsl_matrix_char_alloc_from_block+0x74>)
 8004b2c:	480c      	ldr	r0, [pc, #48]	; (8004b60 <gsl_matrix_char_alloc_from_block+0x78>)
 8004b2e:	2304      	movs	r3, #4
 8004b30:	225b      	movs	r2, #91	; 0x5b
 8004b32:	2400      	movs	r4, #0
 8004b34:	f7fd fe94 	bl	8002860 <gsl_error>
}
 8004b38:	4620      	mov	r0, r4
 8004b3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
 8004b3e:	4907      	ldr	r1, [pc, #28]	; (8004b5c <gsl_matrix_char_alloc_from_block+0x74>)
 8004b40:	4808      	ldr	r0, [pc, #32]	; (8004b64 <gsl_matrix_char_alloc_from_block+0x7c>)
 8004b42:	2304      	movs	r3, #4
 8004b44:	2256      	movs	r2, #86	; 0x56
 8004b46:	f7fd fe8b 	bl	8002860 <gsl_error>
 8004b4a:	2400      	movs	r4, #0
 8004b4c:	e7ea      	b.n	8004b24 <gsl_matrix_char_alloc_from_block+0x3c>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004b4e:	4903      	ldr	r1, [pc, #12]	; (8004b5c <gsl_matrix_char_alloc_from_block+0x74>)
 8004b50:	4805      	ldr	r0, [pc, #20]	; (8004b68 <gsl_matrix_char_alloc_from_block+0x80>)
 8004b52:	2308      	movs	r3, #8
 8004b54:	2263      	movs	r2, #99	; 0x63
 8004b56:	f7fd fe83 	bl	8002860 <gsl_error>
 8004b5a:	e7e3      	b.n	8004b24 <gsl_matrix_char_alloc_from_block+0x3c>
 8004b5c:	08030220 	.word	0x08030220
 8004b60:	080302ac 	.word	0x080302ac
 8004b64:	08030280 	.word	0x08030280
 8004b68:	08030230 	.word	0x08030230

08004b6c <gsl_matrix_char_alloc_from_matrix>:
{
 8004b6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004b70:	461f      	mov	r7, r3
  if (k1 + n1 > mm->size1)
 8004b72:	6803      	ldr	r3, [r0, #0]
{
 8004b74:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8004b78:	4605      	mov	r5, r0
  if (k1 + n1 > mm->size1)
 8004b7a:	19c8      	adds	r0, r1, r7
 8004b7c:	4298      	cmp	r0, r3
 8004b7e:	d825      	bhi.n	8004bcc <gsl_matrix_char_alloc_from_matrix+0x60>
  else if (k2 + n2 > mm->size2)
 8004b80:	686b      	ldr	r3, [r5, #4]
 8004b82:	4690      	mov	r8, r2
 8004b84:	444a      	add	r2, r9
 8004b86:	429a      	cmp	r2, r3
 8004b88:	d816      	bhi.n	8004bb8 <gsl_matrix_char_alloc_from_matrix+0x4c>
  m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
 8004b8a:	2018      	movs	r0, #24
 8004b8c:	460e      	mov	r6, r1
 8004b8e:	f02a fbcb 	bl	802f328 <malloc>
  if (m == 0)
 8004b92:	4604      	mov	r4, r0
 8004b94:	b310      	cbz	r0, 8004bdc <gsl_matrix_char_alloc_from_matrix+0x70>
  m->size1 = n1;
 8004b96:	6007      	str	r7, [r0, #0]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004b98:	68ab      	ldr	r3, [r5, #8]
  m->size2 = n2;
 8004b9a:	f8c4 9004 	str.w	r9, [r4, #4]
  m->block = mm->block;
 8004b9e:	e9d5 1003 	ldrd	r1, r0, [r5, #12]
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004ba2:	fb06 8603 	mla	r6, r6, r3, r8
 8004ba6:	440e      	add	r6, r1
  m->owner = 0;
 8004ba8:	2200      	movs	r2, #0
  m->data = mm->data + k1 * mm->tda + k2 ;
 8004baa:	e9c4 3602 	strd	r3, r6, [r4, #8]
  m->owner = 0;
 8004bae:	e9c4 0204 	strd	r0, r2, [r4, #16]
}
 8004bb2:	4620      	mov	r0, r4
 8004bb4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
 8004bb8:	490c      	ldr	r1, [pc, #48]	; (8004bec <gsl_matrix_char_alloc_from_matrix+0x80>)
 8004bba:	480d      	ldr	r0, [pc, #52]	; (8004bf0 <gsl_matrix_char_alloc_from_matrix+0x84>)
 8004bbc:	2304      	movs	r3, #4
 8004bbe:	2282      	movs	r2, #130	; 0x82
 8004bc0:	2400      	movs	r4, #0
 8004bc2:	f7fd fe4d 	bl	8002860 <gsl_error>
}
 8004bc6:	4620      	mov	r0, r4
 8004bc8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
 8004bcc:	4907      	ldr	r1, [pc, #28]	; (8004bec <gsl_matrix_char_alloc_from_matrix+0x80>)
 8004bce:	4809      	ldr	r0, [pc, #36]	; (8004bf4 <gsl_matrix_char_alloc_from_matrix+0x88>)
 8004bd0:	2304      	movs	r3, #4
 8004bd2:	227d      	movs	r2, #125	; 0x7d
 8004bd4:	f7fd fe44 	bl	8002860 <gsl_error>
 8004bd8:	2400      	movs	r4, #0
 8004bda:	e7ea      	b.n	8004bb2 <gsl_matrix_char_alloc_from_matrix+0x46>
      GSL_ERROR_VAL ("failed to allocate space for matrix struct",
 8004bdc:	4903      	ldr	r1, [pc, #12]	; (8004bec <gsl_matrix_char_alloc_from_matrix+0x80>)
 8004bde:	4806      	ldr	r0, [pc, #24]	; (8004bf8 <gsl_matrix_char_alloc_from_matrix+0x8c>)
 8004be0:	2308      	movs	r3, #8
 8004be2:	228a      	movs	r2, #138	; 0x8a
 8004be4:	f7fd fe3c 	bl	8002860 <gsl_error>
 8004be8:	e7e3      	b.n	8004bb2 <gsl_matrix_char_alloc_from_matrix+0x46>
 8004bea:	bf00      	nop
 8004bec:	08030220 	.word	0x08030220
 8004bf0:	08030308 	.word	0x08030308
 8004bf4:	080302d8 	.word	0x080302d8
 8004bf8:	08030230 	.word	0x08030230

08004bfc <gsl_matrix_char_free>:
  RETURN_IF_NULL (m);
 8004bfc:	b180      	cbz	r0, 8004c20 <gsl_matrix_char_free+0x24>
  if (m->owner)
 8004bfe:	6943      	ldr	r3, [r0, #20]
{
 8004c00:	b510      	push	{r4, lr}
 8004c02:	4604      	mov	r4, r0
  if (m->owner)
 8004c04:	b923      	cbnz	r3, 8004c10 <gsl_matrix_char_free+0x14>
  free (m);
 8004c06:	4620      	mov	r0, r4
}
 8004c08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004c0c:	f02a bb94 	b.w	802f338 <free>
      FUNCTION(gsl_block, free) (m->block);
 8004c10:	6900      	ldr	r0, [r0, #16]
 8004c12:	f002 faf9 	bl	8007208 <gsl_block_char_free>
  free (m);
 8004c16:	4620      	mov	r0, r4
}
 8004c18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (m);
 8004c1c:	f02a bb8c 	b.w	802f338 <free>
 8004c20:	4770      	bx	lr
 8004c22:	bf00      	nop

08004c24 <gsl_matrix_char_set_identity>:
{
 8004c24:	b5f0      	push	{r4, r5, r6, r7, lr}
  const size_t p = m->size1 ;
 8004c26:	6807      	ldr	r7, [r0, #0]
  ATOMIC * const data = m->data;
 8004c28:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  const size_t tda = m->tda ;
 8004c2c:	e9d0 c501 	ldrd	ip, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004c30:	b1d7      	cbz	r7, 8004c68 <gsl_matrix_char_set_identity+0x44>
 8004c32:	2600      	movs	r6, #0
 8004c34:	4631      	mov	r1, r6
 8004c36:	f1ce 0400 	rsb	r4, lr, #0
 8004c3a:	eb0e 000c 	add.w	r0, lr, ip
      for (j = 0; j < q; j++)
 8004c3e:	eb0e 0306 	add.w	r3, lr, r6
 8004c42:	f1bc 0f00 	cmp.w	ip, #0
 8004c46:	d008      	beq.n	8004c5a <gsl_matrix_char_set_identity+0x36>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
 8004c48:	191a      	adds	r2, r3, r4
 8004c4a:	1a52      	subs	r2, r2, r1
 8004c4c:	fab2 f282 	clz	r2, r2
 8004c50:	0952      	lsrs	r2, r2, #5
 8004c52:	f803 2b01 	strb.w	r2, [r3], #1
      for (j = 0; j < q; j++)
 8004c56:	4283      	cmp	r3, r0
 8004c58:	d1f6      	bne.n	8004c48 <gsl_matrix_char_set_identity+0x24>
  for (i = 0; i < p; i++)
 8004c5a:	3101      	adds	r1, #1
 8004c5c:	428f      	cmp	r7, r1
 8004c5e:	eba4 0405 	sub.w	r4, r4, r5
 8004c62:	442e      	add	r6, r5
 8004c64:	4428      	add	r0, r5
 8004c66:	d1ea      	bne.n	8004c3e <gsl_matrix_char_set_identity+0x1a>
}
 8004c68:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004c6a:	bf00      	nop

08004c6c <gsl_matrix_char_set_zero>:
{
 8004c6c:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004c6e:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004c70:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 8004c74:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004c78:	b186      	cbz	r6, 8004c9c <gsl_matrix_char_set_zero+0x30>
 8004c7a:	2000      	movs	r0, #0
 8004c7c:	4604      	mov	r4, r0
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004c7e:	4601      	mov	r1, r0
 8004c80:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004c84:	eb0c 0300 	add.w	r3, ip, r0
 8004c88:	b11f      	cbz	r7, 8004c92 <gsl_matrix_char_set_zero+0x26>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
 8004c8a:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004c8e:	4293      	cmp	r3, r2
 8004c90:	d1fb      	bne.n	8004c8a <gsl_matrix_char_set_zero+0x1e>
  for (i = 0; i < p; i++)
 8004c92:	3401      	adds	r4, #1
 8004c94:	42a6      	cmp	r6, r4
 8004c96:	4428      	add	r0, r5
 8004c98:	442a      	add	r2, r5
 8004c9a:	d1f3      	bne.n	8004c84 <gsl_matrix_char_set_zero+0x18>
}
 8004c9c:	bcf0      	pop	{r4, r5, r6, r7}
 8004c9e:	4770      	bx	lr

08004ca0 <gsl_matrix_char_set_all>:
{
 8004ca0:	b4f0      	push	{r4, r5, r6, r7}
  const size_t p = m->size1 ;
 8004ca2:	6806      	ldr	r6, [r0, #0]
  ATOMIC * const data = m->data;
 8004ca4:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  const size_t tda = m->tda ;
 8004ca8:	e9d0 7501 	ldrd	r7, r5, [r0, #4]
  for (i = 0; i < p; i++)
 8004cac:	b17e      	cbz	r6, 8004cce <gsl_matrix_char_set_all+0x2e>
 8004cae:	2400      	movs	r4, #0
 8004cb0:	4620      	mov	r0, r4
 8004cb2:	eb0c 0207 	add.w	r2, ip, r7
      for (j = 0; j < q; j++)
 8004cb6:	eb0c 0304 	add.w	r3, ip, r4
 8004cba:	b11f      	cbz	r7, 8004cc4 <gsl_matrix_char_set_all+0x24>
          *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
 8004cbc:	f803 1b01 	strb.w	r1, [r3], #1
      for (j = 0; j < q; j++)
 8004cc0:	4293      	cmp	r3, r2
 8004cc2:	d1fb      	bne.n	8004cbc <gsl_matrix_char_set_all+0x1c>
  for (i = 0; i < p; i++)
 8004cc4:	3001      	adds	r0, #1
 8004cc6:	4286      	cmp	r6, r0
 8004cc8:	442c      	add	r4, r5
 8004cca:	442a      	add	r2, r5
 8004ccc:	d1f3      	bne.n	8004cb6 <gsl_matrix_char_set_all+0x16>
}
 8004cce:	bcf0      	pop	{r4, r5, r6, r7}
 8004cd0:	4770      	bx	lr
 8004cd2:	bf00      	nop
 8004cd4:	0000      	movs	r0, r0
	...

08004cd8 <gsl_matrix_complex_long_double_get>:

INLINE_FUN 
gsl_complex_long_double
gsl_matrix_complex_long_double_get(const gsl_matrix_complex_long_double * m, 
                     const size_t i, const size_t j)
{
 8004cd8:	b510      	push	{r4, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004cda:	4b19      	ldr	r3, [pc, #100]	; (8004d40 <gsl_matrix_complex_long_double_get+0x68>)
 8004cdc:	681b      	ldr	r3, [r3, #0]
{
 8004cde:	b088      	sub	sp, #32
  if (GSL_RANGE_COND(1)) 
 8004ce0:	b12b      	cbz	r3, 8004cee <gsl_matrix_complex_long_double_get+0x16>
    {
      gsl_complex_long_double zero = {{0,0}};

      if (i >= m->size1)
 8004ce2:	6803      	ldr	r3, [r0, #0]
 8004ce4:	428b      	cmp	r3, r1
 8004ce6:	d912      	bls.n	8004d0e <gsl_matrix_complex_long_double_get+0x36>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
        }
      else if (j >= m->size2)
 8004ce8:	6843      	ldr	r3, [r0, #4]
 8004cea:	4293      	cmp	r3, r2
 8004cec:	d922      	bls.n	8004d34 <gsl_matrix_complex_long_double_get+0x5c>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
        }
    }
#endif
  return *(gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
 8004cee:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8004cf2:	fb04 2201 	mla	r2, r4, r1, r2
 8004cf6:	eb03 1102 	add.w	r1, r3, r2, lsl #4
 8004cfa:	c90f      	ldmia	r1, {r0, r1, r2, r3}
 8004cfc:	ac08      	add	r4, sp, #32
 8004cfe:	e904 000f 	stmdb	r4, {r0, r1, r2, r3}
} 
 8004d02:	ed9d 0b04 	vldr	d0, [sp, #16]
 8004d06:	ed9d 1b06 	vldr	d1, [sp, #24]
 8004d0a:	b008      	add	sp, #32
 8004d0c:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
 8004d0e:	490d      	ldr	r1, [pc, #52]	; (8004d44 <gsl_matrix_complex_long_double_get+0x6c>)
 8004d10:	480d      	ldr	r0, [pc, #52]	; (8004d48 <gsl_matrix_complex_long_double_get+0x70>)
 8004d12:	2304      	movs	r3, #4
 8004d14:	f44f 728a 	mov.w	r2, #276	; 0x114
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
 8004d18:	f7fd fda2 	bl	8002860 <gsl_error>
 8004d1c:	2200      	movs	r2, #0
 8004d1e:	2300      	movs	r3, #0
 8004d20:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8004d24:	e9cd 2306 	strd	r2, r3, [sp, #24]
} 
 8004d28:	ed9d 0b04 	vldr	d0, [sp, #16]
 8004d2c:	ed9d 1b06 	vldr	d1, [sp, #24]
 8004d30:	b008      	add	sp, #32
 8004d32:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
 8004d34:	4903      	ldr	r1, [pc, #12]	; (8004d44 <gsl_matrix_complex_long_double_get+0x6c>)
 8004d36:	4805      	ldr	r0, [pc, #20]	; (8004d4c <gsl_matrix_complex_long_double_get+0x74>)
 8004d38:	2304      	movs	r3, #4
 8004d3a:	f44f 728c 	mov.w	r2, #280	; 0x118
 8004d3e:	e7eb      	b.n	8004d18 <gsl_matrix_complex_long_double_get+0x40>
 8004d40:	20000000 	.word	0x20000000
 8004d44:	08030338 	.word	0x08030338
 8004d48:	08030360 	.word	0x08030360
 8004d4c:	0803037c 	.word	0x0803037c

08004d50 <gsl_matrix_complex_long_double_set>:

INLINE_FUN 
void
gsl_matrix_complex_long_double_set(gsl_matrix_complex_long_double * m, 
                     const size_t i, const size_t j, const gsl_complex_long_double x)
{
 8004d50:	b4f0      	push	{r4, r5, r6, r7}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004d52:	4b16      	ldr	r3, [pc, #88]	; (8004dac <gsl_matrix_complex_long_double_set+0x5c>)
 8004d54:	681b      	ldr	r3, [r3, #0]
{
 8004d56:	b084      	sub	sp, #16
 8004d58:	ed8d 0b00 	vstr	d0, [sp]
 8004d5c:	ed8d 1b02 	vstr	d1, [sp, #8]
 8004d60:	460c      	mov	r4, r1
 8004d62:	4616      	mov	r6, r2
  if (GSL_RANGE_COND(1)) 
 8004d64:	b12b      	cbz	r3, 8004d72 <gsl_matrix_complex_long_double_set+0x22>
    {
      if (i >= m->size1)
 8004d66:	6803      	ldr	r3, [r0, #0]
 8004d68:	428b      	cmp	r3, r1
 8004d6a:	d910      	bls.n	8004d8e <gsl_matrix_complex_long_double_set+0x3e>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8004d6c:	6843      	ldr	r3, [r0, #4]
 8004d6e:	4293      	cmp	r3, r2
 8004d70:	d916      	bls.n	8004da0 <gsl_matrix_complex_long_double_set+0x50>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  *(gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) = x ;
 8004d72:	ab04      	add	r3, sp, #16
 8004d74:	e9d0 7502 	ldrd	r7, r5, [r0, #8]
 8004d78:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 8004d7c:	fb07 6404 	mla	r4, r7, r4, r6
 8004d80:	eb05 1404 	add.w	r4, r5, r4, lsl #4
 8004d84:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8004d88:	b004      	add	sp, #16
 8004d8a:	bcf0      	pop	{r4, r5, r6, r7}
 8004d8c:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8004d8e:	4908      	ldr	r1, [pc, #32]	; (8004db0 <gsl_matrix_complex_long_double_set+0x60>)
 8004d90:	4808      	ldr	r0, [pc, #32]	; (8004db4 <gsl_matrix_complex_long_double_set+0x64>)
 8004d92:	2304      	movs	r3, #4
 8004d94:	f240 1229 	movw	r2, #297	; 0x129
}
 8004d98:	b004      	add	sp, #16
 8004d9a:	bcf0      	pop	{r4, r5, r6, r7}
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8004d9c:	f7fd bd60 	b.w	8002860 <gsl_error>
 8004da0:	4903      	ldr	r1, [pc, #12]	; (8004db0 <gsl_matrix_complex_long_double_set+0x60>)
 8004da2:	4805      	ldr	r0, [pc, #20]	; (8004db8 <gsl_matrix_complex_long_double_set+0x68>)
 8004da4:	2304      	movs	r3, #4
 8004da6:	f240 122d 	movw	r2, #301	; 0x12d
 8004daa:	e7f5      	b.n	8004d98 <gsl_matrix_complex_long_double_set+0x48>
 8004dac:	20000000 	.word	0x20000000
 8004db0:	08030338 	.word	0x08030338
 8004db4:	08030360 	.word	0x08030360
 8004db8:	0803037c 	.word	0x0803037c

08004dbc <gsl_matrix_complex_long_double_ptr>:

INLINE_FUN 
gsl_complex_long_double *
gsl_matrix_complex_long_double_ptr(gsl_matrix_complex_long_double * m, 
                             const size_t i, const size_t j)
{
 8004dbc:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004dbe:	4b11      	ldr	r3, [pc, #68]	; (8004e04 <gsl_matrix_complex_long_double_ptr+0x48>)
 8004dc0:	681b      	ldr	r3, [r3, #0]
 8004dc2:	b12b      	cbz	r3, 8004dd0 <gsl_matrix_complex_long_double_ptr+0x14>
    {
      if (i >= m->size1)
 8004dc4:	6803      	ldr	r3, [r0, #0]
 8004dc6:	428b      	cmp	r3, r1
 8004dc8:	d909      	bls.n	8004dde <gsl_matrix_complex_long_double_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8004dca:	6843      	ldr	r3, [r0, #4]
 8004dcc:	4293      	cmp	r3, r2
 8004dce:	d90f      	bls.n	8004df0 <gsl_matrix_complex_long_double_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
 8004dd0:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8004dd4:	fb03 2201 	mla	r2, r3, r1, r2
 8004dd8:	eb00 1002 	add.w	r0, r0, r2, lsl #4
} 
 8004ddc:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8004dde:	490a      	ldr	r1, [pc, #40]	; (8004e08 <gsl_matrix_complex_long_double_ptr+0x4c>)
 8004de0:	480a      	ldr	r0, [pc, #40]	; (8004e0c <gsl_matrix_complex_long_double_ptr+0x50>)
 8004de2:	2304      	movs	r3, #4
 8004de4:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8004de8:	f7fd fd3a 	bl	8002860 <gsl_error>
 8004dec:	2000      	movs	r0, #0
} 
 8004dee:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8004df0:	4905      	ldr	r1, [pc, #20]	; (8004e08 <gsl_matrix_complex_long_double_ptr+0x4c>)
 8004df2:	4807      	ldr	r0, [pc, #28]	; (8004e10 <gsl_matrix_complex_long_double_ptr+0x54>)
 8004df4:	2304      	movs	r3, #4
 8004df6:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8004dfa:	f7fd fd31 	bl	8002860 <gsl_error>
 8004dfe:	2000      	movs	r0, #0
} 
 8004e00:	bd08      	pop	{r3, pc}
 8004e02:	bf00      	nop
 8004e04:	20000000 	.word	0x20000000
 8004e08:	08030338 	.word	0x08030338
 8004e0c:	08030360 	.word	0x08030360
 8004e10:	0803037c 	.word	0x0803037c

08004e14 <gsl_matrix_complex_long_double_const_ptr>:

INLINE_FUN 
const gsl_complex_long_double *
gsl_matrix_complex_long_double_const_ptr(const gsl_matrix_complex_long_double * m, 
                                   const size_t i, const size_t j)
{
 8004e14:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004e16:	4b11      	ldr	r3, [pc, #68]	; (8004e5c <gsl_matrix_complex_long_double_const_ptr+0x48>)
 8004e18:	681b      	ldr	r3, [r3, #0]
 8004e1a:	b12b      	cbz	r3, 8004e28 <gsl_matrix_complex_long_double_const_ptr+0x14>
    {
      if (i >= m->size1)
 8004e1c:	6803      	ldr	r3, [r0, #0]
 8004e1e:	428b      	cmp	r3, r1
 8004e20:	d909      	bls.n	8004e36 <gsl_matrix_complex_long_double_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8004e22:	6843      	ldr	r3, [r0, #4]
 8004e24:	4293      	cmp	r3, r2
 8004e26:	d90f      	bls.n	8004e48 <gsl_matrix_complex_long_double_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
 8004e28:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8004e2c:	fb03 2201 	mla	r2, r3, r1, r2
 8004e30:	eb00 1002 	add.w	r0, r0, r2, lsl #4
} 
 8004e34:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8004e36:	490a      	ldr	r1, [pc, #40]	; (8004e60 <gsl_matrix_complex_long_double_const_ptr+0x4c>)
 8004e38:	480a      	ldr	r0, [pc, #40]	; (8004e64 <gsl_matrix_complex_long_double_const_ptr+0x50>)
 8004e3a:	2304      	movs	r3, #4
 8004e3c:	f240 1253 	movw	r2, #339	; 0x153
 8004e40:	f7fd fd0e 	bl	8002860 <gsl_error>
 8004e44:	2000      	movs	r0, #0
} 
 8004e46:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8004e48:	4905      	ldr	r1, [pc, #20]	; (8004e60 <gsl_matrix_complex_long_double_const_ptr+0x4c>)
 8004e4a:	4807      	ldr	r0, [pc, #28]	; (8004e68 <gsl_matrix_complex_long_double_const_ptr+0x54>)
 8004e4c:	2304      	movs	r3, #4
 8004e4e:	f240 1257 	movw	r2, #343	; 0x157
 8004e52:	f7fd fd05 	bl	8002860 <gsl_error>
 8004e56:	2000      	movs	r0, #0
} 
 8004e58:	bd08      	pop	{r3, pc}
 8004e5a:	bf00      	nop
 8004e5c:	20000000 	.word	0x20000000
 8004e60:	08030338 	.word	0x08030338
 8004e64:	08030360 	.word	0x08030360
 8004e68:	0803037c 	.word	0x0803037c

08004e6c <gsl_matrix_complex_get>:

INLINE_FUN 
gsl_complex
gsl_matrix_complex_get(const gsl_matrix_complex * m, 
                     const size_t i, const size_t j)
{
 8004e6c:	b510      	push	{r4, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004e6e:	4b19      	ldr	r3, [pc, #100]	; (8004ed4 <gsl_matrix_complex_get+0x68>)
 8004e70:	681b      	ldr	r3, [r3, #0]
{
 8004e72:	b088      	sub	sp, #32
  if (GSL_RANGE_COND(1)) 
 8004e74:	b12b      	cbz	r3, 8004e82 <gsl_matrix_complex_get+0x16>
    {
      gsl_complex zero = {{0,0}};

      if (i >= m->size1)
 8004e76:	6803      	ldr	r3, [r0, #0]
 8004e78:	428b      	cmp	r3, r1
 8004e7a:	d912      	bls.n	8004ea2 <gsl_matrix_complex_get+0x36>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
        }
      else if (j >= m->size2)
 8004e7c:	6843      	ldr	r3, [r0, #4]
 8004e7e:	4293      	cmp	r3, r2
 8004e80:	d922      	bls.n	8004ec8 <gsl_matrix_complex_get+0x5c>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
        }
    }
#endif
  return *(gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
 8004e82:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8004e86:	fb04 2201 	mla	r2, r4, r1, r2
 8004e8a:	eb03 1102 	add.w	r1, r3, r2, lsl #4
 8004e8e:	c90f      	ldmia	r1, {r0, r1, r2, r3}
 8004e90:	ac08      	add	r4, sp, #32
 8004e92:	e904 000f 	stmdb	r4, {r0, r1, r2, r3}
} 
 8004e96:	ed9d 0b04 	vldr	d0, [sp, #16]
 8004e9a:	ed9d 1b06 	vldr	d1, [sp, #24]
 8004e9e:	b008      	add	sp, #32
 8004ea0:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
 8004ea2:	490d      	ldr	r1, [pc, #52]	; (8004ed8 <gsl_matrix_complex_get+0x6c>)
 8004ea4:	480d      	ldr	r0, [pc, #52]	; (8004edc <gsl_matrix_complex_get+0x70>)
 8004ea6:	2304      	movs	r3, #4
 8004ea8:	f44f 728a 	mov.w	r2, #276	; 0x114
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
 8004eac:	f7fd fcd8 	bl	8002860 <gsl_error>
 8004eb0:	2200      	movs	r2, #0
 8004eb2:	2300      	movs	r3, #0
 8004eb4:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8004eb8:	e9cd 2306 	strd	r2, r3, [sp, #24]
} 
 8004ebc:	ed9d 0b04 	vldr	d0, [sp, #16]
 8004ec0:	ed9d 1b06 	vldr	d1, [sp, #24]
 8004ec4:	b008      	add	sp, #32
 8004ec6:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
 8004ec8:	4903      	ldr	r1, [pc, #12]	; (8004ed8 <gsl_matrix_complex_get+0x6c>)
 8004eca:	4805      	ldr	r0, [pc, #20]	; (8004ee0 <gsl_matrix_complex_get+0x74>)
 8004ecc:	2304      	movs	r3, #4
 8004ece:	f44f 728c 	mov.w	r2, #280	; 0x118
 8004ed2:	e7eb      	b.n	8004eac <gsl_matrix_complex_get+0x40>
 8004ed4:	20000000 	.word	0x20000000
 8004ed8:	08030398 	.word	0x08030398
 8004edc:	08030360 	.word	0x08030360
 8004ee0:	0803037c 	.word	0x0803037c

08004ee4 <gsl_matrix_complex_set>:

INLINE_FUN 
void
gsl_matrix_complex_set(gsl_matrix_complex * m, 
                     const size_t i, const size_t j, const gsl_complex x)
{
 8004ee4:	b4f0      	push	{r4, r5, r6, r7}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004ee6:	4b16      	ldr	r3, [pc, #88]	; (8004f40 <gsl_matrix_complex_set+0x5c>)
 8004ee8:	681b      	ldr	r3, [r3, #0]
{
 8004eea:	b084      	sub	sp, #16
 8004eec:	ed8d 0b00 	vstr	d0, [sp]
 8004ef0:	ed8d 1b02 	vstr	d1, [sp, #8]
 8004ef4:	460c      	mov	r4, r1
 8004ef6:	4616      	mov	r6, r2
  if (GSL_RANGE_COND(1)) 
 8004ef8:	b12b      	cbz	r3, 8004f06 <gsl_matrix_complex_set+0x22>
    {
      if (i >= m->size1)
 8004efa:	6803      	ldr	r3, [r0, #0]
 8004efc:	428b      	cmp	r3, r1
 8004efe:	d910      	bls.n	8004f22 <gsl_matrix_complex_set+0x3e>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8004f00:	6843      	ldr	r3, [r0, #4]
 8004f02:	4293      	cmp	r3, r2
 8004f04:	d916      	bls.n	8004f34 <gsl_matrix_complex_set+0x50>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  *(gsl_complex *)(m->data + 2*(i * m->tda + j)) = x ;
 8004f06:	ab04      	add	r3, sp, #16
 8004f08:	e9d0 7502 	ldrd	r7, r5, [r0, #8]
 8004f0c:	e913 000f 	ldmdb	r3, {r0, r1, r2, r3}
 8004f10:	fb07 6404 	mla	r4, r7, r4, r6
 8004f14:	eb05 1404 	add.w	r4, r5, r4, lsl #4
 8004f18:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
 8004f1c:	b004      	add	sp, #16
 8004f1e:	bcf0      	pop	{r4, r5, r6, r7}
 8004f20:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8004f22:	4908      	ldr	r1, [pc, #32]	; (8004f44 <gsl_matrix_complex_set+0x60>)
 8004f24:	4808      	ldr	r0, [pc, #32]	; (8004f48 <gsl_matrix_complex_set+0x64>)
 8004f26:	2304      	movs	r3, #4
 8004f28:	f240 1229 	movw	r2, #297	; 0x129
}
 8004f2c:	b004      	add	sp, #16
 8004f2e:	bcf0      	pop	{r4, r5, r6, r7}
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8004f30:	f7fd bc96 	b.w	8002860 <gsl_error>
 8004f34:	4903      	ldr	r1, [pc, #12]	; (8004f44 <gsl_matrix_complex_set+0x60>)
 8004f36:	4805      	ldr	r0, [pc, #20]	; (8004f4c <gsl_matrix_complex_set+0x68>)
 8004f38:	2304      	movs	r3, #4
 8004f3a:	f240 122d 	movw	r2, #301	; 0x12d
 8004f3e:	e7f5      	b.n	8004f2c <gsl_matrix_complex_set+0x48>
 8004f40:	20000000 	.word	0x20000000
 8004f44:	08030398 	.word	0x08030398
 8004f48:	08030360 	.word	0x08030360
 8004f4c:	0803037c 	.word	0x0803037c

08004f50 <gsl_matrix_complex_ptr>:

INLINE_FUN 
gsl_complex *
gsl_matrix_complex_ptr(gsl_matrix_complex * m, 
                             const size_t i, const size_t j)
{
 8004f50:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004f52:	4b11      	ldr	r3, [pc, #68]	; (8004f98 <gsl_matrix_complex_ptr+0x48>)
 8004f54:	681b      	ldr	r3, [r3, #0]
 8004f56:	b12b      	cbz	r3, 8004f64 <gsl_matrix_complex_ptr+0x14>
    {
      if (i >= m->size1)
 8004f58:	6803      	ldr	r3, [r0, #0]
 8004f5a:	428b      	cmp	r3, r1
 8004f5c:	d909      	bls.n	8004f72 <gsl_matrix_complex_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8004f5e:	6843      	ldr	r3, [r0, #4]
 8004f60:	4293      	cmp	r3, r2
 8004f62:	d90f      	bls.n	8004f84 <gsl_matrix_complex_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
 8004f64:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8004f68:	fb03 2201 	mla	r2, r3, r1, r2
 8004f6c:	eb00 1002 	add.w	r0, r0, r2, lsl #4
} 
 8004f70:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8004f72:	490a      	ldr	r1, [pc, #40]	; (8004f9c <gsl_matrix_complex_ptr+0x4c>)
 8004f74:	480a      	ldr	r0, [pc, #40]	; (8004fa0 <gsl_matrix_complex_ptr+0x50>)
 8004f76:	2304      	movs	r3, #4
 8004f78:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8004f7c:	f7fd fc70 	bl	8002860 <gsl_error>
 8004f80:	2000      	movs	r0, #0
} 
 8004f82:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8004f84:	4905      	ldr	r1, [pc, #20]	; (8004f9c <gsl_matrix_complex_ptr+0x4c>)
 8004f86:	4807      	ldr	r0, [pc, #28]	; (8004fa4 <gsl_matrix_complex_ptr+0x54>)
 8004f88:	2304      	movs	r3, #4
 8004f8a:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8004f8e:	f7fd fc67 	bl	8002860 <gsl_error>
 8004f92:	2000      	movs	r0, #0
} 
 8004f94:	bd08      	pop	{r3, pc}
 8004f96:	bf00      	nop
 8004f98:	20000000 	.word	0x20000000
 8004f9c:	08030398 	.word	0x08030398
 8004fa0:	08030360 	.word	0x08030360
 8004fa4:	0803037c 	.word	0x0803037c

08004fa8 <gsl_matrix_complex_const_ptr>:

INLINE_FUN 
const gsl_complex *
gsl_matrix_complex_const_ptr(const gsl_matrix_complex * m, 
                                   const size_t i, const size_t j)
{
 8004fa8:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8004faa:	4b11      	ldr	r3, [pc, #68]	; (8004ff0 <gsl_matrix_complex_const_ptr+0x48>)
 8004fac:	681b      	ldr	r3, [r3, #0]
 8004fae:	b12b      	cbz	r3, 8004fbc <gsl_matrix_complex_const_ptr+0x14>
    {
      if (i >= m->size1)
 8004fb0:	6803      	ldr	r3, [r0, #0]
 8004fb2:	428b      	cmp	r3, r1
 8004fb4:	d909      	bls.n	8004fca <gsl_matrix_complex_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8004fb6:	6843      	ldr	r3, [r0, #4]
 8004fb8:	4293      	cmp	r3, r2
 8004fba:	d90f      	bls.n	8004fdc <gsl_matrix_complex_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
 8004fbc:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8004fc0:	fb03 2201 	mla	r2, r3, r1, r2
 8004fc4:	eb00 1002 	add.w	r0, r0, r2, lsl #4
} 
 8004fc8:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8004fca:	490a      	ldr	r1, [pc, #40]	; (8004ff4 <gsl_matrix_complex_const_ptr+0x4c>)
 8004fcc:	480a      	ldr	r0, [pc, #40]	; (8004ff8 <gsl_matrix_complex_const_ptr+0x50>)
 8004fce:	2304      	movs	r3, #4
 8004fd0:	f240 1253 	movw	r2, #339	; 0x153
 8004fd4:	f7fd fc44 	bl	8002860 <gsl_error>
 8004fd8:	2000      	movs	r0, #0
} 
 8004fda:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8004fdc:	4905      	ldr	r1, [pc, #20]	; (8004ff4 <gsl_matrix_complex_const_ptr+0x4c>)
 8004fde:	4807      	ldr	r0, [pc, #28]	; (8004ffc <gsl_matrix_complex_const_ptr+0x54>)
 8004fe0:	2304      	movs	r3, #4
 8004fe2:	f240 1257 	movw	r2, #343	; 0x157
 8004fe6:	f7fd fc3b 	bl	8002860 <gsl_error>
 8004fea:	2000      	movs	r0, #0
} 
 8004fec:	bd08      	pop	{r3, pc}
 8004fee:	bf00      	nop
 8004ff0:	20000000 	.word	0x20000000
 8004ff4:	08030398 	.word	0x08030398
 8004ff8:	08030360 	.word	0x08030360
 8004ffc:	0803037c 	.word	0x0803037c

08005000 <gsl_matrix_complex_float_get>:

INLINE_FUN 
gsl_complex_float
gsl_matrix_complex_float_get(const gsl_matrix_complex_float * m, 
                     const size_t i, const size_t j)
{
 8005000:	b510      	push	{r4, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005002:	4b1a      	ldr	r3, [pc, #104]	; (800506c <gsl_matrix_complex_float_get+0x6c>)
 8005004:	681b      	ldr	r3, [r3, #0]
{
 8005006:	b084      	sub	sp, #16
  if (GSL_RANGE_COND(1)) 
 8005008:	b12b      	cbz	r3, 8005016 <gsl_matrix_complex_float_get+0x16>
    {
      gsl_complex_float zero = {{0,0}};

      if (i >= m->size1)
 800500a:	6803      	ldr	r3, [r0, #0]
 800500c:	428b      	cmp	r3, r1
 800500e:	d912      	bls.n	8005036 <gsl_matrix_complex_float_get+0x36>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
        }
      else if (j >= m->size2)
 8005010:	6843      	ldr	r3, [r0, #4]
 8005012:	4293      	cmp	r3, r2
 8005014:	d91f      	bls.n	8005056 <gsl_matrix_complex_float_get+0x56>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
        }
    }
#endif
  return *(gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
 8005016:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 800501a:	fb04 2201 	mla	r2, r4, r1, r2
 800501e:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 8005022:	c903      	ldmia	r1, {r0, r1}
 8005024:	ab04      	add	r3, sp, #16
 8005026:	e903 0003 	stmdb	r3, {r0, r1}
} 
 800502a:	ed9d 0a02 	vldr	s0, [sp, #8]
 800502e:	eddd 0a03 	vldr	s1, [sp, #12]
 8005032:	b004      	add	sp, #16
 8005034:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
 8005036:	490e      	ldr	r1, [pc, #56]	; (8005070 <gsl_matrix_complex_float_get+0x70>)
 8005038:	480e      	ldr	r0, [pc, #56]	; (8005074 <gsl_matrix_complex_float_get+0x74>)
 800503a:	2304      	movs	r3, #4
 800503c:	f44f 728a 	mov.w	r2, #276	; 0x114
 8005040:	f7fd fc0e 	bl	8002860 <gsl_error>
 8005044:	2300      	movs	r3, #0
 8005046:	9302      	str	r3, [sp, #8]
 8005048:	9303      	str	r3, [sp, #12]
} 
 800504a:	ed9d 0a02 	vldr	s0, [sp, #8]
 800504e:	eddd 0a03 	vldr	s1, [sp, #12]
 8005052:	b004      	add	sp, #16
 8005054:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
 8005056:	2304      	movs	r3, #4
 8005058:	4905      	ldr	r1, [pc, #20]	; (8005070 <gsl_matrix_complex_float_get+0x70>)
 800505a:	4807      	ldr	r0, [pc, #28]	; (8005078 <gsl_matrix_complex_float_get+0x78>)
 800505c:	f44f 728c 	mov.w	r2, #280	; 0x118
 8005060:	f7fd fbfe 	bl	8002860 <gsl_error>
 8005064:	2300      	movs	r3, #0
 8005066:	9302      	str	r3, [sp, #8]
 8005068:	9303      	str	r3, [sp, #12]
 800506a:	e7de      	b.n	800502a <gsl_matrix_complex_float_get+0x2a>
 800506c:	20000000 	.word	0x20000000
 8005070:	080303bc 	.word	0x080303bc
 8005074:	08030360 	.word	0x08030360
 8005078:	0803037c 	.word	0x0803037c

0800507c <gsl_matrix_complex_float_set>:

INLINE_FUN 
void
gsl_matrix_complex_float_set(gsl_matrix_complex_float * m, 
                     const size_t i, const size_t j, const gsl_complex_float x)
{
 800507c:	b430      	push	{r4, r5}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 800507e:	4b16      	ldr	r3, [pc, #88]	; (80050d8 <gsl_matrix_complex_float_set+0x5c>)
 8005080:	681c      	ldr	r4, [r3, #0]
{
 8005082:	b082      	sub	sp, #8
 8005084:	ed8d 0a00 	vstr	s0, [sp]
 8005088:	460b      	mov	r3, r1
 800508a:	edcd 0a01 	vstr	s1, [sp, #4]
  if (GSL_RANGE_COND(1)) 
 800508e:	b12c      	cbz	r4, 800509c <gsl_matrix_complex_float_set+0x20>
    {
      if (i >= m->size1)
 8005090:	6801      	ldr	r1, [r0, #0]
 8005092:	4299      	cmp	r1, r3
 8005094:	d910      	bls.n	80050b8 <gsl_matrix_complex_float_set+0x3c>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005096:	6841      	ldr	r1, [r0, #4]
 8005098:	4291      	cmp	r1, r2
 800509a:	d916      	bls.n	80050ca <gsl_matrix_complex_float_set+0x4e>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  *(gsl_complex_float *)(m->data + 2*(i * m->tda + j)) = x ;
 800509c:	e9d0 5402 	ldrd	r5, r4, [r0, #8]
 80050a0:	a902      	add	r1, sp, #8
 80050a2:	e911 0003 	ldmdb	r1, {r0, r1}
 80050a6:	fb05 2203 	mla	r2, r5, r3, r2
 80050aa:	eb04 03c2 	add.w	r3, r4, r2, lsl #3
 80050ae:	e883 0003 	stmia.w	r3, {r0, r1}
}
 80050b2:	b002      	add	sp, #8
 80050b4:	bc30      	pop	{r4, r5}
 80050b6:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 80050b8:	4908      	ldr	r1, [pc, #32]	; (80050dc <gsl_matrix_complex_float_set+0x60>)
 80050ba:	4809      	ldr	r0, [pc, #36]	; (80050e0 <gsl_matrix_complex_float_set+0x64>)
 80050bc:	2304      	movs	r3, #4
 80050be:	f240 1229 	movw	r2, #297	; 0x129
}
 80050c2:	b002      	add	sp, #8
 80050c4:	bc30      	pop	{r4, r5}
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 80050c6:	f7fd bbcb 	b.w	8002860 <gsl_error>
 80050ca:	4904      	ldr	r1, [pc, #16]	; (80050dc <gsl_matrix_complex_float_set+0x60>)
 80050cc:	4805      	ldr	r0, [pc, #20]	; (80050e4 <gsl_matrix_complex_float_set+0x68>)
 80050ce:	2304      	movs	r3, #4
 80050d0:	f240 122d 	movw	r2, #301	; 0x12d
 80050d4:	e7f5      	b.n	80050c2 <gsl_matrix_complex_float_set+0x46>
 80050d6:	bf00      	nop
 80050d8:	20000000 	.word	0x20000000
 80050dc:	080303bc 	.word	0x080303bc
 80050e0:	08030360 	.word	0x08030360
 80050e4:	0803037c 	.word	0x0803037c

080050e8 <gsl_matrix_complex_float_ptr>:

INLINE_FUN 
gsl_complex_float *
gsl_matrix_complex_float_ptr(gsl_matrix_complex_float * m, 
                             const size_t i, const size_t j)
{
 80050e8:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80050ea:	4b11      	ldr	r3, [pc, #68]	; (8005130 <gsl_matrix_complex_float_ptr+0x48>)
 80050ec:	681b      	ldr	r3, [r3, #0]
 80050ee:	b12b      	cbz	r3, 80050fc <gsl_matrix_complex_float_ptr+0x14>
    {
      if (i >= m->size1)
 80050f0:	6803      	ldr	r3, [r0, #0]
 80050f2:	428b      	cmp	r3, r1
 80050f4:	d909      	bls.n	800510a <gsl_matrix_complex_float_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80050f6:	6843      	ldr	r3, [r0, #4]
 80050f8:	4293      	cmp	r3, r2
 80050fa:	d90f      	bls.n	800511c <gsl_matrix_complex_float_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
 80050fc:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005100:	fb03 2201 	mla	r2, r3, r1, r2
 8005104:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
} 
 8005108:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 800510a:	490a      	ldr	r1, [pc, #40]	; (8005134 <gsl_matrix_complex_float_ptr+0x4c>)
 800510c:	480a      	ldr	r0, [pc, #40]	; (8005138 <gsl_matrix_complex_float_ptr+0x50>)
 800510e:	2304      	movs	r3, #4
 8005110:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005114:	f7fd fba4 	bl	8002860 <gsl_error>
 8005118:	2000      	movs	r0, #0
} 
 800511a:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 800511c:	4905      	ldr	r1, [pc, #20]	; (8005134 <gsl_matrix_complex_float_ptr+0x4c>)
 800511e:	4807      	ldr	r0, [pc, #28]	; (800513c <gsl_matrix_complex_float_ptr+0x54>)
 8005120:	2304      	movs	r3, #4
 8005122:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005126:	f7fd fb9b 	bl	8002860 <gsl_error>
 800512a:	2000      	movs	r0, #0
} 
 800512c:	bd08      	pop	{r3, pc}
 800512e:	bf00      	nop
 8005130:	20000000 	.word	0x20000000
 8005134:	080303bc 	.word	0x080303bc
 8005138:	08030360 	.word	0x08030360
 800513c:	0803037c 	.word	0x0803037c

08005140 <gsl_matrix_complex_float_const_ptr>:

INLINE_FUN 
const gsl_complex_float *
gsl_matrix_complex_float_const_ptr(const gsl_matrix_complex_float * m, 
                                   const size_t i, const size_t j)
{
 8005140:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005142:	4b11      	ldr	r3, [pc, #68]	; (8005188 <gsl_matrix_complex_float_const_ptr+0x48>)
 8005144:	681b      	ldr	r3, [r3, #0]
 8005146:	b12b      	cbz	r3, 8005154 <gsl_matrix_complex_float_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005148:	6803      	ldr	r3, [r0, #0]
 800514a:	428b      	cmp	r3, r1
 800514c:	d909      	bls.n	8005162 <gsl_matrix_complex_float_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800514e:	6843      	ldr	r3, [r0, #4]
 8005150:	4293      	cmp	r3, r2
 8005152:	d90f      	bls.n	8005174 <gsl_matrix_complex_float_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
 8005154:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005158:	fb03 2201 	mla	r2, r3, r1, r2
 800515c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
} 
 8005160:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005162:	490a      	ldr	r1, [pc, #40]	; (800518c <gsl_matrix_complex_float_const_ptr+0x4c>)
 8005164:	480a      	ldr	r0, [pc, #40]	; (8005190 <gsl_matrix_complex_float_const_ptr+0x50>)
 8005166:	2304      	movs	r3, #4
 8005168:	f240 1253 	movw	r2, #339	; 0x153
 800516c:	f7fd fb78 	bl	8002860 <gsl_error>
 8005170:	2000      	movs	r0, #0
} 
 8005172:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005174:	4905      	ldr	r1, [pc, #20]	; (800518c <gsl_matrix_complex_float_const_ptr+0x4c>)
 8005176:	4807      	ldr	r0, [pc, #28]	; (8005194 <gsl_matrix_complex_float_const_ptr+0x54>)
 8005178:	2304      	movs	r3, #4
 800517a:	f240 1257 	movw	r2, #343	; 0x157
 800517e:	f7fd fb6f 	bl	8002860 <gsl_error>
 8005182:	2000      	movs	r0, #0
} 
 8005184:	bd08      	pop	{r3, pc}
 8005186:	bf00      	nop
 8005188:	20000000 	.word	0x20000000
 800518c:	080303bc 	.word	0x080303bc
 8005190:	08030360 	.word	0x08030360
 8005194:	0803037c 	.word	0x0803037c

08005198 <gsl_matrix_long_double_get>:
INLINE_FUN 
long double
gsl_matrix_long_double_get(const gsl_matrix_long_double * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005198:	4b15      	ldr	r3, [pc, #84]	; (80051f0 <gsl_matrix_long_double_get+0x58>)
 800519a:	681b      	ldr	r3, [r3, #0]
{
 800519c:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 800519e:	b12b      	cbz	r3, 80051ac <gsl_matrix_long_double_get+0x14>
    {
      if (i >= m->size1)
 80051a0:	6803      	ldr	r3, [r0, #0]
 80051a2:	428b      	cmp	r3, r1
 80051a4:	d90b      	bls.n	80051be <gsl_matrix_long_double_get+0x26>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 80051a6:	6843      	ldr	r3, [r0, #4]
 80051a8:	4293      	cmp	r3, r2
 80051aa:	d912      	bls.n	80051d2 <gsl_matrix_long_double_get+0x3a>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 80051ac:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 80051b0:	fb04 2201 	mla	r2, r4, r1, r2
 80051b4:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 80051b8:	ed91 0b00 	vldr	d0, [r1]
} 
 80051bc:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 80051be:	490d      	ldr	r1, [pc, #52]	; (80051f4 <gsl_matrix_long_double_get+0x5c>)
 80051c0:	480d      	ldr	r0, [pc, #52]	; (80051f8 <gsl_matrix_long_double_get+0x60>)
 80051c2:	2304      	movs	r3, #4
 80051c4:	f44f 728b 	mov.w	r2, #278	; 0x116
 80051c8:	f7fd fb4a 	bl	8002860 <gsl_error>
 80051cc:	ed9f 0b06 	vldr	d0, [pc, #24]	; 80051e8 <gsl_matrix_long_double_get+0x50>
} 
 80051d0:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 80051d2:	4908      	ldr	r1, [pc, #32]	; (80051f4 <gsl_matrix_long_double_get+0x5c>)
 80051d4:	4809      	ldr	r0, [pc, #36]	; (80051fc <gsl_matrix_long_double_get+0x64>)
 80051d6:	2304      	movs	r3, #4
 80051d8:	f44f 728d 	mov.w	r2, #282	; 0x11a
 80051dc:	f7fd fb40 	bl	8002860 <gsl_error>
 80051e0:	ed9f 0b01 	vldr	d0, [pc, #4]	; 80051e8 <gsl_matrix_long_double_get+0x50>
} 
 80051e4:	bd10      	pop	{r4, pc}
 80051e6:	bf00      	nop
	...
 80051f0:	20000000 	.word	0x20000000
 80051f4:	080303e0 	.word	0x080303e0
 80051f8:	08030360 	.word	0x08030360
 80051fc:	0803037c 	.word	0x0803037c

08005200 <gsl_matrix_long_double_set>:
INLINE_FUN 
void
gsl_matrix_long_double_set(gsl_matrix_long_double * m, const size_t i, const size_t j, const long double x)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005200:	4b11      	ldr	r3, [pc, #68]	; (8005248 <gsl_matrix_long_double_set+0x48>)
 8005202:	681b      	ldr	r3, [r3, #0]
 8005204:	b12b      	cbz	r3, 8005212 <gsl_matrix_long_double_set+0x12>
    {
      if (i >= m->size1)
 8005206:	6803      	ldr	r3, [r0, #0]
 8005208:	428b      	cmp	r3, r1
 800520a:	d90e      	bls.n	800522a <gsl_matrix_long_double_set+0x2a>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800520c:	6843      	ldr	r3, [r0, #4]
 800520e:	4293      	cmp	r3, r2
 8005210:	d912      	bls.n	8005238 <gsl_matrix_long_double_set+0x38>
{
 8005212:	b410      	push	{r4}
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005214:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005218:	fb04 2201 	mla	r2, r4, r1, r2
 800521c:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 8005220:	ed81 0b00 	vstr	d0, [r1]
}
 8005224:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005228:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 800522a:	4908      	ldr	r1, [pc, #32]	; (800524c <gsl_matrix_long_double_set+0x4c>)
 800522c:	4808      	ldr	r0, [pc, #32]	; (8005250 <gsl_matrix_long_double_set+0x50>)
 800522e:	2304      	movs	r3, #4
 8005230:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005234:	f7fd bb14 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005238:	4904      	ldr	r1, [pc, #16]	; (800524c <gsl_matrix_long_double_set+0x4c>)
 800523a:	4806      	ldr	r0, [pc, #24]	; (8005254 <gsl_matrix_long_double_set+0x54>)
 800523c:	2304      	movs	r3, #4
 800523e:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8005242:	f7fd bb0d 	b.w	8002860 <gsl_error>
 8005246:	bf00      	nop
 8005248:	20000000 	.word	0x20000000
 800524c:	080303e0 	.word	0x080303e0
 8005250:	08030360 	.word	0x08030360
 8005254:	0803037c 	.word	0x0803037c

08005258 <gsl_matrix_long_double_ptr>:

INLINE_FUN 
long double *
gsl_matrix_long_double_ptr(gsl_matrix_long_double * m, const size_t i, const size_t j)
{
 8005258:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 800525a:	4b11      	ldr	r3, [pc, #68]	; (80052a0 <gsl_matrix_long_double_ptr+0x48>)
 800525c:	681b      	ldr	r3, [r3, #0]
 800525e:	b12b      	cbz	r3, 800526c <gsl_matrix_long_double_ptr+0x14>
    {
      if (i >= m->size1)
 8005260:	6803      	ldr	r3, [r0, #0]
 8005262:	428b      	cmp	r3, r1
 8005264:	d909      	bls.n	800527a <gsl_matrix_long_double_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005266:	6843      	ldr	r3, [r0, #4]
 8005268:	4293      	cmp	r3, r2
 800526a:	d90f      	bls.n	800528c <gsl_matrix_long_double_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (long double *) (m->data + (i * m->tda + j)) ;
 800526c:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005270:	fb03 2201 	mla	r2, r3, r1, r2
 8005274:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
} 
 8005278:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 800527a:	490a      	ldr	r1, [pc, #40]	; (80052a4 <gsl_matrix_long_double_ptr+0x4c>)
 800527c:	480a      	ldr	r0, [pc, #40]	; (80052a8 <gsl_matrix_long_double_ptr+0x50>)
 800527e:	2304      	movs	r3, #4
 8005280:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005284:	f7fd faec 	bl	8002860 <gsl_error>
 8005288:	2000      	movs	r0, #0
} 
 800528a:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 800528c:	4905      	ldr	r1, [pc, #20]	; (80052a4 <gsl_matrix_long_double_ptr+0x4c>)
 800528e:	4807      	ldr	r0, [pc, #28]	; (80052ac <gsl_matrix_long_double_ptr+0x54>)
 8005290:	2304      	movs	r3, #4
 8005292:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005296:	f7fd fae3 	bl	8002860 <gsl_error>
 800529a:	2000      	movs	r0, #0
} 
 800529c:	bd08      	pop	{r3, pc}
 800529e:	bf00      	nop
 80052a0:	20000000 	.word	0x20000000
 80052a4:	080303e0 	.word	0x080303e0
 80052a8:	08030360 	.word	0x08030360
 80052ac:	0803037c 	.word	0x0803037c

080052b0 <gsl_matrix_long_double_const_ptr>:

INLINE_FUN 
const long double *
gsl_matrix_long_double_const_ptr(const gsl_matrix_long_double * m, const size_t i, const size_t j)
{
 80052b0:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80052b2:	4b11      	ldr	r3, [pc, #68]	; (80052f8 <gsl_matrix_long_double_const_ptr+0x48>)
 80052b4:	681b      	ldr	r3, [r3, #0]
 80052b6:	b12b      	cbz	r3, 80052c4 <gsl_matrix_long_double_const_ptr+0x14>
    {
      if (i >= m->size1)
 80052b8:	6803      	ldr	r3, [r0, #0]
 80052ba:	428b      	cmp	r3, r1
 80052bc:	d909      	bls.n	80052d2 <gsl_matrix_long_double_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80052be:	6843      	ldr	r3, [r0, #4]
 80052c0:	4293      	cmp	r3, r2
 80052c2:	d90f      	bls.n	80052e4 <gsl_matrix_long_double_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const long double *) (m->data + (i * m->tda + j)) ;
 80052c4:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 80052c8:	fb03 2201 	mla	r2, r3, r1, r2
 80052cc:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
} 
 80052d0:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 80052d2:	490a      	ldr	r1, [pc, #40]	; (80052fc <gsl_matrix_long_double_const_ptr+0x4c>)
 80052d4:	480a      	ldr	r0, [pc, #40]	; (8005300 <gsl_matrix_long_double_const_ptr+0x50>)
 80052d6:	2304      	movs	r3, #4
 80052d8:	f44f 72a9 	mov.w	r2, #338	; 0x152
 80052dc:	f7fd fac0 	bl	8002860 <gsl_error>
 80052e0:	2000      	movs	r0, #0
} 
 80052e2:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 80052e4:	4905      	ldr	r1, [pc, #20]	; (80052fc <gsl_matrix_long_double_const_ptr+0x4c>)
 80052e6:	4807      	ldr	r0, [pc, #28]	; (8005304 <gsl_matrix_long_double_const_ptr+0x54>)
 80052e8:	2304      	movs	r3, #4
 80052ea:	f44f 72ab 	mov.w	r2, #342	; 0x156
 80052ee:	f7fd fab7 	bl	8002860 <gsl_error>
 80052f2:	2000      	movs	r0, #0
} 
 80052f4:	bd08      	pop	{r3, pc}
 80052f6:	bf00      	nop
 80052f8:	20000000 	.word	0x20000000
 80052fc:	080303e0 	.word	0x080303e0
 8005300:	08030360 	.word	0x08030360
 8005304:	0803037c 	.word	0x0803037c

08005308 <gsl_matrix_get>:
INLINE_FUN 
double
gsl_matrix_get(const gsl_matrix * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005308:	4b15      	ldr	r3, [pc, #84]	; (8005360 <gsl_matrix_get+0x58>)
 800530a:	681b      	ldr	r3, [r3, #0]
{
 800530c:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 800530e:	b12b      	cbz	r3, 800531c <gsl_matrix_get+0x14>
    {
      if (i >= m->size1)
 8005310:	6803      	ldr	r3, [r0, #0]
 8005312:	428b      	cmp	r3, r1
 8005314:	d90b      	bls.n	800532e <gsl_matrix_get+0x26>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005316:	6843      	ldr	r3, [r0, #4]
 8005318:	4293      	cmp	r3, r2
 800531a:	d912      	bls.n	8005342 <gsl_matrix_get+0x3a>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 800531c:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005320:	fb04 2201 	mla	r2, r4, r1, r2
 8005324:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 8005328:	ed91 0b00 	vldr	d0, [r1]
} 
 800532c:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 800532e:	490d      	ldr	r1, [pc, #52]	; (8005364 <gsl_matrix_get+0x5c>)
 8005330:	480d      	ldr	r0, [pc, #52]	; (8005368 <gsl_matrix_get+0x60>)
 8005332:	2304      	movs	r3, #4
 8005334:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005338:	f7fd fa92 	bl	8002860 <gsl_error>
 800533c:	ed9f 0b06 	vldr	d0, [pc, #24]	; 8005358 <gsl_matrix_get+0x50>
} 
 8005340:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005342:	4908      	ldr	r1, [pc, #32]	; (8005364 <gsl_matrix_get+0x5c>)
 8005344:	4809      	ldr	r0, [pc, #36]	; (800536c <gsl_matrix_get+0x64>)
 8005346:	2304      	movs	r3, #4
 8005348:	f44f 728d 	mov.w	r2, #282	; 0x11a
 800534c:	f7fd fa88 	bl	8002860 <gsl_error>
 8005350:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8005358 <gsl_matrix_get+0x50>
} 
 8005354:	bd10      	pop	{r4, pc}
 8005356:	bf00      	nop
	...
 8005360:	20000000 	.word	0x20000000
 8005364:	08030400 	.word	0x08030400
 8005368:	08030360 	.word	0x08030360
 800536c:	0803037c 	.word	0x0803037c

08005370 <gsl_matrix_set>:
INLINE_FUN 
void
gsl_matrix_set(gsl_matrix * m, const size_t i, const size_t j, const double x)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005370:	4b11      	ldr	r3, [pc, #68]	; (80053b8 <gsl_matrix_set+0x48>)
 8005372:	681b      	ldr	r3, [r3, #0]
 8005374:	b12b      	cbz	r3, 8005382 <gsl_matrix_set+0x12>
    {
      if (i >= m->size1)
 8005376:	6803      	ldr	r3, [r0, #0]
 8005378:	428b      	cmp	r3, r1
 800537a:	d90e      	bls.n	800539a <gsl_matrix_set+0x2a>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800537c:	6843      	ldr	r3, [r0, #4]
 800537e:	4293      	cmp	r3, r2
 8005380:	d912      	bls.n	80053a8 <gsl_matrix_set+0x38>
{
 8005382:	b410      	push	{r4}
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005384:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005388:	fb04 2201 	mla	r2, r4, r1, r2
 800538c:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 8005390:	ed81 0b00 	vstr	d0, [r1]
}
 8005394:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005398:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 800539a:	4908      	ldr	r1, [pc, #32]	; (80053bc <gsl_matrix_set+0x4c>)
 800539c:	4808      	ldr	r0, [pc, #32]	; (80053c0 <gsl_matrix_set+0x50>)
 800539e:	2304      	movs	r3, #4
 80053a0:	f44f 7295 	mov.w	r2, #298	; 0x12a
 80053a4:	f7fd ba5c 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 80053a8:	4904      	ldr	r1, [pc, #16]	; (80053bc <gsl_matrix_set+0x4c>)
 80053aa:	4806      	ldr	r0, [pc, #24]	; (80053c4 <gsl_matrix_set+0x54>)
 80053ac:	2304      	movs	r3, #4
 80053ae:	f44f 7297 	mov.w	r2, #302	; 0x12e
 80053b2:	f7fd ba55 	b.w	8002860 <gsl_error>
 80053b6:	bf00      	nop
 80053b8:	20000000 	.word	0x20000000
 80053bc:	08030400 	.word	0x08030400
 80053c0:	08030360 	.word	0x08030360
 80053c4:	0803037c 	.word	0x0803037c

080053c8 <gsl_matrix_ptr>:

INLINE_FUN 
double *
gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j)
{
 80053c8:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80053ca:	4b11      	ldr	r3, [pc, #68]	; (8005410 <gsl_matrix_ptr+0x48>)
 80053cc:	681b      	ldr	r3, [r3, #0]
 80053ce:	b12b      	cbz	r3, 80053dc <gsl_matrix_ptr+0x14>
    {
      if (i >= m->size1)
 80053d0:	6803      	ldr	r3, [r0, #0]
 80053d2:	428b      	cmp	r3, r1
 80053d4:	d909      	bls.n	80053ea <gsl_matrix_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80053d6:	6843      	ldr	r3, [r0, #4]
 80053d8:	4293      	cmp	r3, r2
 80053da:	d90f      	bls.n	80053fc <gsl_matrix_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (double *) (m->data + (i * m->tda + j)) ;
 80053dc:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 80053e0:	fb03 2201 	mla	r2, r3, r1, r2
 80053e4:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
} 
 80053e8:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 80053ea:	490a      	ldr	r1, [pc, #40]	; (8005414 <gsl_matrix_ptr+0x4c>)
 80053ec:	480a      	ldr	r0, [pc, #40]	; (8005418 <gsl_matrix_ptr+0x50>)
 80053ee:	2304      	movs	r3, #4
 80053f0:	f44f 729f 	mov.w	r2, #318	; 0x13e
 80053f4:	f7fd fa34 	bl	8002860 <gsl_error>
 80053f8:	2000      	movs	r0, #0
} 
 80053fa:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 80053fc:	4905      	ldr	r1, [pc, #20]	; (8005414 <gsl_matrix_ptr+0x4c>)
 80053fe:	4807      	ldr	r0, [pc, #28]	; (800541c <gsl_matrix_ptr+0x54>)
 8005400:	2304      	movs	r3, #4
 8005402:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005406:	f7fd fa2b 	bl	8002860 <gsl_error>
 800540a:	2000      	movs	r0, #0
} 
 800540c:	bd08      	pop	{r3, pc}
 800540e:	bf00      	nop
 8005410:	20000000 	.word	0x20000000
 8005414:	08030400 	.word	0x08030400
 8005418:	08030360 	.word	0x08030360
 800541c:	0803037c 	.word	0x0803037c

08005420 <gsl_matrix_const_ptr>:

INLINE_FUN 
const double *
gsl_matrix_const_ptr(const gsl_matrix * m, const size_t i, const size_t j)
{
 8005420:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005422:	4b11      	ldr	r3, [pc, #68]	; (8005468 <gsl_matrix_const_ptr+0x48>)
 8005424:	681b      	ldr	r3, [r3, #0]
 8005426:	b12b      	cbz	r3, 8005434 <gsl_matrix_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005428:	6803      	ldr	r3, [r0, #0]
 800542a:	428b      	cmp	r3, r1
 800542c:	d909      	bls.n	8005442 <gsl_matrix_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800542e:	6843      	ldr	r3, [r0, #4]
 8005430:	4293      	cmp	r3, r2
 8005432:	d90f      	bls.n	8005454 <gsl_matrix_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const double *) (m->data + (i * m->tda + j)) ;
 8005434:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005438:	fb03 2201 	mla	r2, r3, r1, r2
 800543c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
} 
 8005440:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005442:	490a      	ldr	r1, [pc, #40]	; (800546c <gsl_matrix_const_ptr+0x4c>)
 8005444:	480a      	ldr	r0, [pc, #40]	; (8005470 <gsl_matrix_const_ptr+0x50>)
 8005446:	2304      	movs	r3, #4
 8005448:	f44f 72a9 	mov.w	r2, #338	; 0x152
 800544c:	f7fd fa08 	bl	8002860 <gsl_error>
 8005450:	2000      	movs	r0, #0
} 
 8005452:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005454:	4905      	ldr	r1, [pc, #20]	; (800546c <gsl_matrix_const_ptr+0x4c>)
 8005456:	4807      	ldr	r0, [pc, #28]	; (8005474 <gsl_matrix_const_ptr+0x54>)
 8005458:	2304      	movs	r3, #4
 800545a:	f44f 72ab 	mov.w	r2, #342	; 0x156
 800545e:	f7fd f9ff 	bl	8002860 <gsl_error>
 8005462:	2000      	movs	r0, #0
} 
 8005464:	bd08      	pop	{r3, pc}
 8005466:	bf00      	nop
 8005468:	20000000 	.word	0x20000000
 800546c:	08030400 	.word	0x08030400
 8005470:	08030360 	.word	0x08030360
 8005474:	0803037c 	.word	0x0803037c

08005478 <gsl_matrix_float_get>:
INLINE_FUN 
float
gsl_matrix_float_get(const gsl_matrix_float * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005478:	4b13      	ldr	r3, [pc, #76]	; (80054c8 <gsl_matrix_float_get+0x50>)
 800547a:	681b      	ldr	r3, [r3, #0]
{
 800547c:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 800547e:	b12b      	cbz	r3, 800548c <gsl_matrix_float_get+0x14>
    {
      if (i >= m->size1)
 8005480:	6803      	ldr	r3, [r0, #0]
 8005482:	428b      	cmp	r3, r1
 8005484:	d90b      	bls.n	800549e <gsl_matrix_float_get+0x26>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005486:	6843      	ldr	r3, [r0, #4]
 8005488:	4293      	cmp	r3, r2
 800548a:	d912      	bls.n	80054b2 <gsl_matrix_float_get+0x3a>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 800548c:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005490:	fb04 2201 	mla	r2, r4, r1, r2
 8005494:	eb03 0182 	add.w	r1, r3, r2, lsl #2
 8005498:	ed91 0a00 	vldr	s0, [r1]
} 
 800549c:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 800549e:	490b      	ldr	r1, [pc, #44]	; (80054cc <gsl_matrix_float_get+0x54>)
 80054a0:	480b      	ldr	r0, [pc, #44]	; (80054d0 <gsl_matrix_float_get+0x58>)
 80054a2:	2304      	movs	r3, #4
 80054a4:	f44f 728b 	mov.w	r2, #278	; 0x116
 80054a8:	f7fd f9da 	bl	8002860 <gsl_error>
 80054ac:	ed9f 0a09 	vldr	s0, [pc, #36]	; 80054d4 <gsl_matrix_float_get+0x5c>
} 
 80054b0:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 80054b2:	4906      	ldr	r1, [pc, #24]	; (80054cc <gsl_matrix_float_get+0x54>)
 80054b4:	4808      	ldr	r0, [pc, #32]	; (80054d8 <gsl_matrix_float_get+0x60>)
 80054b6:	2304      	movs	r3, #4
 80054b8:	f44f 728d 	mov.w	r2, #282	; 0x11a
 80054bc:	f7fd f9d0 	bl	8002860 <gsl_error>
 80054c0:	ed9f 0a04 	vldr	s0, [pc, #16]	; 80054d4 <gsl_matrix_float_get+0x5c>
} 
 80054c4:	bd10      	pop	{r4, pc}
 80054c6:	bf00      	nop
 80054c8:	20000000 	.word	0x20000000
 80054cc:	0803041c 	.word	0x0803041c
 80054d0:	08030360 	.word	0x08030360
 80054d4:	00000000 	.word	0x00000000
 80054d8:	0803037c 	.word	0x0803037c

080054dc <gsl_matrix_float_set>:
INLINE_FUN 
void
gsl_matrix_float_set(gsl_matrix_float * m, const size_t i, const size_t j, const float x)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80054dc:	4b11      	ldr	r3, [pc, #68]	; (8005524 <gsl_matrix_float_set+0x48>)
 80054de:	681b      	ldr	r3, [r3, #0]
 80054e0:	b12b      	cbz	r3, 80054ee <gsl_matrix_float_set+0x12>
    {
      if (i >= m->size1)
 80054e2:	6803      	ldr	r3, [r0, #0]
 80054e4:	428b      	cmp	r3, r1
 80054e6:	d90e      	bls.n	8005506 <gsl_matrix_float_set+0x2a>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80054e8:	6843      	ldr	r3, [r0, #4]
 80054ea:	4293      	cmp	r3, r2
 80054ec:	d912      	bls.n	8005514 <gsl_matrix_float_set+0x38>
{
 80054ee:	b410      	push	{r4}
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 80054f0:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 80054f4:	fb04 2201 	mla	r2, r4, r1, r2
 80054f8:	eb03 0182 	add.w	r1, r3, r2, lsl #2
}
 80054fc:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 8005500:	ed81 0a00 	vstr	s0, [r1]
}
 8005504:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005506:	4908      	ldr	r1, [pc, #32]	; (8005528 <gsl_matrix_float_set+0x4c>)
 8005508:	4808      	ldr	r0, [pc, #32]	; (800552c <gsl_matrix_float_set+0x50>)
 800550a:	2304      	movs	r3, #4
 800550c:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005510:	f7fd b9a6 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005514:	4904      	ldr	r1, [pc, #16]	; (8005528 <gsl_matrix_float_set+0x4c>)
 8005516:	4806      	ldr	r0, [pc, #24]	; (8005530 <gsl_matrix_float_set+0x54>)
 8005518:	2304      	movs	r3, #4
 800551a:	f44f 7297 	mov.w	r2, #302	; 0x12e
 800551e:	f7fd b99f 	b.w	8002860 <gsl_error>
 8005522:	bf00      	nop
 8005524:	20000000 	.word	0x20000000
 8005528:	0803041c 	.word	0x0803041c
 800552c:	08030360 	.word	0x08030360
 8005530:	0803037c 	.word	0x0803037c

08005534 <gsl_matrix_float_ptr>:

INLINE_FUN 
float *
gsl_matrix_float_ptr(gsl_matrix_float * m, const size_t i, const size_t j)
{
 8005534:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005536:	4b11      	ldr	r3, [pc, #68]	; (800557c <gsl_matrix_float_ptr+0x48>)
 8005538:	681b      	ldr	r3, [r3, #0]
 800553a:	b12b      	cbz	r3, 8005548 <gsl_matrix_float_ptr+0x14>
    {
      if (i >= m->size1)
 800553c:	6803      	ldr	r3, [r0, #0]
 800553e:	428b      	cmp	r3, r1
 8005540:	d909      	bls.n	8005556 <gsl_matrix_float_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005542:	6843      	ldr	r3, [r0, #4]
 8005544:	4293      	cmp	r3, r2
 8005546:	d90f      	bls.n	8005568 <gsl_matrix_float_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (float *) (m->data + (i * m->tda + j)) ;
 8005548:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 800554c:	fb03 2201 	mla	r2, r3, r1, r2
 8005550:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 8005554:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005556:	490a      	ldr	r1, [pc, #40]	; (8005580 <gsl_matrix_float_ptr+0x4c>)
 8005558:	480a      	ldr	r0, [pc, #40]	; (8005584 <gsl_matrix_float_ptr+0x50>)
 800555a:	2304      	movs	r3, #4
 800555c:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005560:	f7fd f97e 	bl	8002860 <gsl_error>
 8005564:	2000      	movs	r0, #0
} 
 8005566:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005568:	4905      	ldr	r1, [pc, #20]	; (8005580 <gsl_matrix_float_ptr+0x4c>)
 800556a:	4807      	ldr	r0, [pc, #28]	; (8005588 <gsl_matrix_float_ptr+0x54>)
 800556c:	2304      	movs	r3, #4
 800556e:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005572:	f7fd f975 	bl	8002860 <gsl_error>
 8005576:	2000      	movs	r0, #0
} 
 8005578:	bd08      	pop	{r3, pc}
 800557a:	bf00      	nop
 800557c:	20000000 	.word	0x20000000
 8005580:	0803041c 	.word	0x0803041c
 8005584:	08030360 	.word	0x08030360
 8005588:	0803037c 	.word	0x0803037c

0800558c <gsl_matrix_float_const_ptr>:

INLINE_FUN 
const float *
gsl_matrix_float_const_ptr(const gsl_matrix_float * m, const size_t i, const size_t j)
{
 800558c:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 800558e:	4b11      	ldr	r3, [pc, #68]	; (80055d4 <gsl_matrix_float_const_ptr+0x48>)
 8005590:	681b      	ldr	r3, [r3, #0]
 8005592:	b12b      	cbz	r3, 80055a0 <gsl_matrix_float_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005594:	6803      	ldr	r3, [r0, #0]
 8005596:	428b      	cmp	r3, r1
 8005598:	d909      	bls.n	80055ae <gsl_matrix_float_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800559a:	6843      	ldr	r3, [r0, #4]
 800559c:	4293      	cmp	r3, r2
 800559e:	d90f      	bls.n	80055c0 <gsl_matrix_float_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const float *) (m->data + (i * m->tda + j)) ;
 80055a0:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 80055a4:	fb03 2201 	mla	r2, r3, r1, r2
 80055a8:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 80055ac:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 80055ae:	490a      	ldr	r1, [pc, #40]	; (80055d8 <gsl_matrix_float_const_ptr+0x4c>)
 80055b0:	480a      	ldr	r0, [pc, #40]	; (80055dc <gsl_matrix_float_const_ptr+0x50>)
 80055b2:	2304      	movs	r3, #4
 80055b4:	f44f 72a9 	mov.w	r2, #338	; 0x152
 80055b8:	f7fd f952 	bl	8002860 <gsl_error>
 80055bc:	2000      	movs	r0, #0
} 
 80055be:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 80055c0:	4905      	ldr	r1, [pc, #20]	; (80055d8 <gsl_matrix_float_const_ptr+0x4c>)
 80055c2:	4807      	ldr	r0, [pc, #28]	; (80055e0 <gsl_matrix_float_const_ptr+0x54>)
 80055c4:	2304      	movs	r3, #4
 80055c6:	f44f 72ab 	mov.w	r2, #342	; 0x156
 80055ca:	f7fd f949 	bl	8002860 <gsl_error>
 80055ce:	2000      	movs	r0, #0
} 
 80055d0:	bd08      	pop	{r3, pc}
 80055d2:	bf00      	nop
 80055d4:	20000000 	.word	0x20000000
 80055d8:	0803041c 	.word	0x0803041c
 80055dc:	08030360 	.word	0x08030360
 80055e0:	0803037c 	.word	0x0803037c

080055e4 <gsl_matrix_ulong_get>:
INLINE_FUN 
unsigned long
gsl_matrix_ulong_get(const gsl_matrix_ulong * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80055e4:	4b11      	ldr	r3, [pc, #68]	; (800562c <gsl_matrix_ulong_get+0x48>)
 80055e6:	681b      	ldr	r3, [r3, #0]
{
 80055e8:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 80055ea:	b12b      	cbz	r3, 80055f8 <gsl_matrix_ulong_get+0x14>
    {
      if (i >= m->size1)
 80055ec:	6803      	ldr	r3, [r0, #0]
 80055ee:	428b      	cmp	r3, r1
 80055f0:	d909      	bls.n	8005606 <gsl_matrix_ulong_get+0x22>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 80055f2:	6843      	ldr	r3, [r0, #4]
 80055f4:	4293      	cmp	r3, r2
 80055f6:	d90f      	bls.n	8005618 <gsl_matrix_ulong_get+0x34>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 80055f8:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 80055fc:	fb04 2201 	mla	r2, r4, r1, r2
 8005600:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
} 
 8005604:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 8005606:	490a      	ldr	r1, [pc, #40]	; (8005630 <gsl_matrix_ulong_get+0x4c>)
 8005608:	480a      	ldr	r0, [pc, #40]	; (8005634 <gsl_matrix_ulong_get+0x50>)
 800560a:	2304      	movs	r3, #4
 800560c:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005610:	f7fd f926 	bl	8002860 <gsl_error>
 8005614:	2000      	movs	r0, #0
} 
 8005616:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005618:	4905      	ldr	r1, [pc, #20]	; (8005630 <gsl_matrix_ulong_get+0x4c>)
 800561a:	4807      	ldr	r0, [pc, #28]	; (8005638 <gsl_matrix_ulong_get+0x54>)
 800561c:	2304      	movs	r3, #4
 800561e:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005622:	f7fd f91d 	bl	8002860 <gsl_error>
 8005626:	2000      	movs	r0, #0
} 
 8005628:	bd10      	pop	{r4, pc}
 800562a:	bf00      	nop
 800562c:	20000000 	.word	0x20000000
 8005630:	08030438 	.word	0x08030438
 8005634:	08030360 	.word	0x08030360
 8005638:	0803037c 	.word	0x0803037c

0800563c <gsl_matrix_ulong_set>:

INLINE_FUN 
void
gsl_matrix_ulong_set(gsl_matrix_ulong * m, const size_t i, const size_t j, const unsigned long x)
{
 800563c:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 800563e:	4c12      	ldr	r4, [pc, #72]	; (8005688 <gsl_matrix_ulong_set+0x4c>)
 8005640:	6824      	ldr	r4, [r4, #0]
 8005642:	b12c      	cbz	r4, 8005650 <gsl_matrix_ulong_set+0x14>
    {
      if (i >= m->size1)
 8005644:	6804      	ldr	r4, [r0, #0]
 8005646:	428c      	cmp	r4, r1
 8005648:	d90b      	bls.n	8005662 <gsl_matrix_ulong_set+0x26>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800564a:	6844      	ldr	r4, [r0, #4]
 800564c:	4294      	cmp	r4, r2
 800564e:	d911      	bls.n	8005674 <gsl_matrix_ulong_set+0x38>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005650:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 8005654:	fb04 2201 	mla	r2, r4, r1, r2
}
 8005658:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 800565c:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
 8005660:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005662:	490a      	ldr	r1, [pc, #40]	; (800568c <gsl_matrix_ulong_set+0x50>)
 8005664:	480a      	ldr	r0, [pc, #40]	; (8005690 <gsl_matrix_ulong_set+0x54>)
}
 8005666:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 800566a:	2304      	movs	r3, #4
 800566c:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005670:	f7fd b8f6 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005674:	4905      	ldr	r1, [pc, #20]	; (800568c <gsl_matrix_ulong_set+0x50>)
 8005676:	4807      	ldr	r0, [pc, #28]	; (8005694 <gsl_matrix_ulong_set+0x58>)
}
 8005678:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 800567c:	2304      	movs	r3, #4
 800567e:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8005682:	f7fd b8ed 	b.w	8002860 <gsl_error>
 8005686:	bf00      	nop
 8005688:	20000000 	.word	0x20000000
 800568c:	08030438 	.word	0x08030438
 8005690:	08030360 	.word	0x08030360
 8005694:	0803037c 	.word	0x0803037c

08005698 <gsl_matrix_ulong_ptr>:

INLINE_FUN 
unsigned long *
gsl_matrix_ulong_ptr(gsl_matrix_ulong * m, const size_t i, const size_t j)
{
 8005698:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 800569a:	4b11      	ldr	r3, [pc, #68]	; (80056e0 <gsl_matrix_ulong_ptr+0x48>)
 800569c:	681b      	ldr	r3, [r3, #0]
 800569e:	b12b      	cbz	r3, 80056ac <gsl_matrix_ulong_ptr+0x14>
    {
      if (i >= m->size1)
 80056a0:	6803      	ldr	r3, [r0, #0]
 80056a2:	428b      	cmp	r3, r1
 80056a4:	d909      	bls.n	80056ba <gsl_matrix_ulong_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80056a6:	6843      	ldr	r3, [r0, #4]
 80056a8:	4293      	cmp	r3, r2
 80056aa:	d90f      	bls.n	80056cc <gsl_matrix_ulong_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (unsigned long *) (m->data + (i * m->tda + j)) ;
 80056ac:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 80056b0:	fb03 2201 	mla	r2, r3, r1, r2
 80056b4:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 80056b8:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 80056ba:	490a      	ldr	r1, [pc, #40]	; (80056e4 <gsl_matrix_ulong_ptr+0x4c>)
 80056bc:	480a      	ldr	r0, [pc, #40]	; (80056e8 <gsl_matrix_ulong_ptr+0x50>)
 80056be:	2304      	movs	r3, #4
 80056c0:	f44f 729f 	mov.w	r2, #318	; 0x13e
 80056c4:	f7fd f8cc 	bl	8002860 <gsl_error>
 80056c8:	2000      	movs	r0, #0
} 
 80056ca:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 80056cc:	4905      	ldr	r1, [pc, #20]	; (80056e4 <gsl_matrix_ulong_ptr+0x4c>)
 80056ce:	4807      	ldr	r0, [pc, #28]	; (80056ec <gsl_matrix_ulong_ptr+0x54>)
 80056d0:	2304      	movs	r3, #4
 80056d2:	f44f 72a1 	mov.w	r2, #322	; 0x142
 80056d6:	f7fd f8c3 	bl	8002860 <gsl_error>
 80056da:	2000      	movs	r0, #0
} 
 80056dc:	bd08      	pop	{r3, pc}
 80056de:	bf00      	nop
 80056e0:	20000000 	.word	0x20000000
 80056e4:	08030438 	.word	0x08030438
 80056e8:	08030360 	.word	0x08030360
 80056ec:	0803037c 	.word	0x0803037c

080056f0 <gsl_matrix_ulong_const_ptr>:

INLINE_FUN 
const unsigned long *
gsl_matrix_ulong_const_ptr(const gsl_matrix_ulong * m, const size_t i, const size_t j)
{
 80056f0:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80056f2:	4b11      	ldr	r3, [pc, #68]	; (8005738 <gsl_matrix_ulong_const_ptr+0x48>)
 80056f4:	681b      	ldr	r3, [r3, #0]
 80056f6:	b12b      	cbz	r3, 8005704 <gsl_matrix_ulong_const_ptr+0x14>
    {
      if (i >= m->size1)
 80056f8:	6803      	ldr	r3, [r0, #0]
 80056fa:	428b      	cmp	r3, r1
 80056fc:	d909      	bls.n	8005712 <gsl_matrix_ulong_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80056fe:	6843      	ldr	r3, [r0, #4]
 8005700:	4293      	cmp	r3, r2
 8005702:	d90f      	bls.n	8005724 <gsl_matrix_ulong_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const unsigned long *) (m->data + (i * m->tda + j)) ;
 8005704:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005708:	fb03 2201 	mla	r2, r3, r1, r2
 800570c:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 8005710:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005712:	490a      	ldr	r1, [pc, #40]	; (800573c <gsl_matrix_ulong_const_ptr+0x4c>)
 8005714:	480a      	ldr	r0, [pc, #40]	; (8005740 <gsl_matrix_ulong_const_ptr+0x50>)
 8005716:	2304      	movs	r3, #4
 8005718:	f44f 72a9 	mov.w	r2, #338	; 0x152
 800571c:	f7fd f8a0 	bl	8002860 <gsl_error>
 8005720:	2000      	movs	r0, #0
} 
 8005722:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005724:	4905      	ldr	r1, [pc, #20]	; (800573c <gsl_matrix_ulong_const_ptr+0x4c>)
 8005726:	4807      	ldr	r0, [pc, #28]	; (8005744 <gsl_matrix_ulong_const_ptr+0x54>)
 8005728:	2304      	movs	r3, #4
 800572a:	f44f 72ab 	mov.w	r2, #342	; 0x156
 800572e:	f7fd f897 	bl	8002860 <gsl_error>
 8005732:	2000      	movs	r0, #0
} 
 8005734:	bd08      	pop	{r3, pc}
 8005736:	bf00      	nop
 8005738:	20000000 	.word	0x20000000
 800573c:	08030438 	.word	0x08030438
 8005740:	08030360 	.word	0x08030360
 8005744:	0803037c 	.word	0x0803037c

08005748 <gsl_matrix_long_get>:
INLINE_FUN 
long
gsl_matrix_long_get(const gsl_matrix_long * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005748:	4b11      	ldr	r3, [pc, #68]	; (8005790 <gsl_matrix_long_get+0x48>)
 800574a:	681b      	ldr	r3, [r3, #0]
{
 800574c:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 800574e:	b12b      	cbz	r3, 800575c <gsl_matrix_long_get+0x14>
    {
      if (i >= m->size1)
 8005750:	6803      	ldr	r3, [r0, #0]
 8005752:	428b      	cmp	r3, r1
 8005754:	d909      	bls.n	800576a <gsl_matrix_long_get+0x22>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005756:	6843      	ldr	r3, [r0, #4]
 8005758:	4293      	cmp	r3, r2
 800575a:	d90f      	bls.n	800577c <gsl_matrix_long_get+0x34>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 800575c:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005760:	fb04 2201 	mla	r2, r4, r1, r2
 8005764:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
} 
 8005768:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 800576a:	490a      	ldr	r1, [pc, #40]	; (8005794 <gsl_matrix_long_get+0x4c>)
 800576c:	480a      	ldr	r0, [pc, #40]	; (8005798 <gsl_matrix_long_get+0x50>)
 800576e:	2304      	movs	r3, #4
 8005770:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005774:	f7fd f874 	bl	8002860 <gsl_error>
 8005778:	2000      	movs	r0, #0
} 
 800577a:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 800577c:	4905      	ldr	r1, [pc, #20]	; (8005794 <gsl_matrix_long_get+0x4c>)
 800577e:	4807      	ldr	r0, [pc, #28]	; (800579c <gsl_matrix_long_get+0x54>)
 8005780:	2304      	movs	r3, #4
 8005782:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005786:	f7fd f86b 	bl	8002860 <gsl_error>
 800578a:	2000      	movs	r0, #0
} 
 800578c:	bd10      	pop	{r4, pc}
 800578e:	bf00      	nop
 8005790:	20000000 	.word	0x20000000
 8005794:	08030454 	.word	0x08030454
 8005798:	08030360 	.word	0x08030360
 800579c:	0803037c 	.word	0x0803037c

080057a0 <gsl_matrix_long_set>:

INLINE_FUN 
void
gsl_matrix_long_set(gsl_matrix_long * m, const size_t i, const size_t j, const long x)
{
 80057a0:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80057a2:	4c12      	ldr	r4, [pc, #72]	; (80057ec <gsl_matrix_long_set+0x4c>)
 80057a4:	6824      	ldr	r4, [r4, #0]
 80057a6:	b12c      	cbz	r4, 80057b4 <gsl_matrix_long_set+0x14>
    {
      if (i >= m->size1)
 80057a8:	6804      	ldr	r4, [r0, #0]
 80057aa:	428c      	cmp	r4, r1
 80057ac:	d90b      	bls.n	80057c6 <gsl_matrix_long_set+0x26>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80057ae:	6844      	ldr	r4, [r0, #4]
 80057b0:	4294      	cmp	r4, r2
 80057b2:	d911      	bls.n	80057d8 <gsl_matrix_long_set+0x38>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 80057b4:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 80057b8:	fb04 2201 	mla	r2, r4, r1, r2
}
 80057bc:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 80057c0:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
 80057c4:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 80057c6:	490a      	ldr	r1, [pc, #40]	; (80057f0 <gsl_matrix_long_set+0x50>)
 80057c8:	480a      	ldr	r0, [pc, #40]	; (80057f4 <gsl_matrix_long_set+0x54>)
}
 80057ca:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 80057ce:	2304      	movs	r3, #4
 80057d0:	f44f 7295 	mov.w	r2, #298	; 0x12a
 80057d4:	f7fd b844 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 80057d8:	4905      	ldr	r1, [pc, #20]	; (80057f0 <gsl_matrix_long_set+0x50>)
 80057da:	4807      	ldr	r0, [pc, #28]	; (80057f8 <gsl_matrix_long_set+0x58>)
}
 80057dc:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 80057e0:	2304      	movs	r3, #4
 80057e2:	f44f 7297 	mov.w	r2, #302	; 0x12e
 80057e6:	f7fd b83b 	b.w	8002860 <gsl_error>
 80057ea:	bf00      	nop
 80057ec:	20000000 	.word	0x20000000
 80057f0:	08030454 	.word	0x08030454
 80057f4:	08030360 	.word	0x08030360
 80057f8:	0803037c 	.word	0x0803037c

080057fc <gsl_matrix_long_ptr>:

INLINE_FUN 
long *
gsl_matrix_long_ptr(gsl_matrix_long * m, const size_t i, const size_t j)
{
 80057fc:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80057fe:	4b11      	ldr	r3, [pc, #68]	; (8005844 <gsl_matrix_long_ptr+0x48>)
 8005800:	681b      	ldr	r3, [r3, #0]
 8005802:	b12b      	cbz	r3, 8005810 <gsl_matrix_long_ptr+0x14>
    {
      if (i >= m->size1)
 8005804:	6803      	ldr	r3, [r0, #0]
 8005806:	428b      	cmp	r3, r1
 8005808:	d909      	bls.n	800581e <gsl_matrix_long_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800580a:	6843      	ldr	r3, [r0, #4]
 800580c:	4293      	cmp	r3, r2
 800580e:	d90f      	bls.n	8005830 <gsl_matrix_long_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (long *) (m->data + (i * m->tda + j)) ;
 8005810:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005814:	fb03 2201 	mla	r2, r3, r1, r2
 8005818:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 800581c:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 800581e:	490a      	ldr	r1, [pc, #40]	; (8005848 <gsl_matrix_long_ptr+0x4c>)
 8005820:	480a      	ldr	r0, [pc, #40]	; (800584c <gsl_matrix_long_ptr+0x50>)
 8005822:	2304      	movs	r3, #4
 8005824:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005828:	f7fd f81a 	bl	8002860 <gsl_error>
 800582c:	2000      	movs	r0, #0
} 
 800582e:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005830:	4905      	ldr	r1, [pc, #20]	; (8005848 <gsl_matrix_long_ptr+0x4c>)
 8005832:	4807      	ldr	r0, [pc, #28]	; (8005850 <gsl_matrix_long_ptr+0x54>)
 8005834:	2304      	movs	r3, #4
 8005836:	f44f 72a1 	mov.w	r2, #322	; 0x142
 800583a:	f7fd f811 	bl	8002860 <gsl_error>
 800583e:	2000      	movs	r0, #0
} 
 8005840:	bd08      	pop	{r3, pc}
 8005842:	bf00      	nop
 8005844:	20000000 	.word	0x20000000
 8005848:	08030454 	.word	0x08030454
 800584c:	08030360 	.word	0x08030360
 8005850:	0803037c 	.word	0x0803037c

08005854 <gsl_matrix_long_const_ptr>:

INLINE_FUN 
const long *
gsl_matrix_long_const_ptr(const gsl_matrix_long * m, const size_t i, const size_t j)
{
 8005854:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005856:	4b11      	ldr	r3, [pc, #68]	; (800589c <gsl_matrix_long_const_ptr+0x48>)
 8005858:	681b      	ldr	r3, [r3, #0]
 800585a:	b12b      	cbz	r3, 8005868 <gsl_matrix_long_const_ptr+0x14>
    {
      if (i >= m->size1)
 800585c:	6803      	ldr	r3, [r0, #0]
 800585e:	428b      	cmp	r3, r1
 8005860:	d909      	bls.n	8005876 <gsl_matrix_long_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005862:	6843      	ldr	r3, [r0, #4]
 8005864:	4293      	cmp	r3, r2
 8005866:	d90f      	bls.n	8005888 <gsl_matrix_long_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const long *) (m->data + (i * m->tda + j)) ;
 8005868:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 800586c:	fb03 2201 	mla	r2, r3, r1, r2
 8005870:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 8005874:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005876:	490a      	ldr	r1, [pc, #40]	; (80058a0 <gsl_matrix_long_const_ptr+0x4c>)
 8005878:	480a      	ldr	r0, [pc, #40]	; (80058a4 <gsl_matrix_long_const_ptr+0x50>)
 800587a:	2304      	movs	r3, #4
 800587c:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8005880:	f7fc ffee 	bl	8002860 <gsl_error>
 8005884:	2000      	movs	r0, #0
} 
 8005886:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005888:	4905      	ldr	r1, [pc, #20]	; (80058a0 <gsl_matrix_long_const_ptr+0x4c>)
 800588a:	4807      	ldr	r0, [pc, #28]	; (80058a8 <gsl_matrix_long_const_ptr+0x54>)
 800588c:	2304      	movs	r3, #4
 800588e:	f44f 72ab 	mov.w	r2, #342	; 0x156
 8005892:	f7fc ffe5 	bl	8002860 <gsl_error>
 8005896:	2000      	movs	r0, #0
} 
 8005898:	bd08      	pop	{r3, pc}
 800589a:	bf00      	nop
 800589c:	20000000 	.word	0x20000000
 80058a0:	08030454 	.word	0x08030454
 80058a4:	08030360 	.word	0x08030360
 80058a8:	0803037c 	.word	0x0803037c

080058ac <gsl_matrix_uint_get>:
INLINE_FUN 
unsigned int
gsl_matrix_uint_get(const gsl_matrix_uint * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80058ac:	4b11      	ldr	r3, [pc, #68]	; (80058f4 <gsl_matrix_uint_get+0x48>)
 80058ae:	681b      	ldr	r3, [r3, #0]
{
 80058b0:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 80058b2:	b12b      	cbz	r3, 80058c0 <gsl_matrix_uint_get+0x14>
    {
      if (i >= m->size1)
 80058b4:	6803      	ldr	r3, [r0, #0]
 80058b6:	428b      	cmp	r3, r1
 80058b8:	d909      	bls.n	80058ce <gsl_matrix_uint_get+0x22>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 80058ba:	6843      	ldr	r3, [r0, #4]
 80058bc:	4293      	cmp	r3, r2
 80058be:	d90f      	bls.n	80058e0 <gsl_matrix_uint_get+0x34>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 80058c0:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 80058c4:	fb04 2201 	mla	r2, r4, r1, r2
 80058c8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
} 
 80058cc:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 80058ce:	490a      	ldr	r1, [pc, #40]	; (80058f8 <gsl_matrix_uint_get+0x4c>)
 80058d0:	480a      	ldr	r0, [pc, #40]	; (80058fc <gsl_matrix_uint_get+0x50>)
 80058d2:	2304      	movs	r3, #4
 80058d4:	f44f 728b 	mov.w	r2, #278	; 0x116
 80058d8:	f7fc ffc2 	bl	8002860 <gsl_error>
 80058dc:	2000      	movs	r0, #0
} 
 80058de:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 80058e0:	4905      	ldr	r1, [pc, #20]	; (80058f8 <gsl_matrix_uint_get+0x4c>)
 80058e2:	4807      	ldr	r0, [pc, #28]	; (8005900 <gsl_matrix_uint_get+0x54>)
 80058e4:	2304      	movs	r3, #4
 80058e6:	f44f 728d 	mov.w	r2, #282	; 0x11a
 80058ea:	f7fc ffb9 	bl	8002860 <gsl_error>
 80058ee:	2000      	movs	r0, #0
} 
 80058f0:	bd10      	pop	{r4, pc}
 80058f2:	bf00      	nop
 80058f4:	20000000 	.word	0x20000000
 80058f8:	08030470 	.word	0x08030470
 80058fc:	08030360 	.word	0x08030360
 8005900:	0803037c 	.word	0x0803037c

08005904 <gsl_matrix_uint_set>:

INLINE_FUN 
void
gsl_matrix_uint_set(gsl_matrix_uint * m, const size_t i, const size_t j, const unsigned int x)
{
 8005904:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005906:	4c12      	ldr	r4, [pc, #72]	; (8005950 <gsl_matrix_uint_set+0x4c>)
 8005908:	6824      	ldr	r4, [r4, #0]
 800590a:	b12c      	cbz	r4, 8005918 <gsl_matrix_uint_set+0x14>
    {
      if (i >= m->size1)
 800590c:	6804      	ldr	r4, [r0, #0]
 800590e:	428c      	cmp	r4, r1
 8005910:	d90b      	bls.n	800592a <gsl_matrix_uint_set+0x26>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005912:	6844      	ldr	r4, [r0, #4]
 8005914:	4294      	cmp	r4, r2
 8005916:	d911      	bls.n	800593c <gsl_matrix_uint_set+0x38>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005918:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 800591c:	fb04 2201 	mla	r2, r4, r1, r2
}
 8005920:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 8005924:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
 8005928:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 800592a:	490a      	ldr	r1, [pc, #40]	; (8005954 <gsl_matrix_uint_set+0x50>)
 800592c:	480a      	ldr	r0, [pc, #40]	; (8005958 <gsl_matrix_uint_set+0x54>)
}
 800592e:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005932:	2304      	movs	r3, #4
 8005934:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005938:	f7fc bf92 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 800593c:	4905      	ldr	r1, [pc, #20]	; (8005954 <gsl_matrix_uint_set+0x50>)
 800593e:	4807      	ldr	r0, [pc, #28]	; (800595c <gsl_matrix_uint_set+0x58>)
}
 8005940:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005944:	2304      	movs	r3, #4
 8005946:	f44f 7297 	mov.w	r2, #302	; 0x12e
 800594a:	f7fc bf89 	b.w	8002860 <gsl_error>
 800594e:	bf00      	nop
 8005950:	20000000 	.word	0x20000000
 8005954:	08030470 	.word	0x08030470
 8005958:	08030360 	.word	0x08030360
 800595c:	0803037c 	.word	0x0803037c

08005960 <gsl_matrix_uint_ptr>:

INLINE_FUN 
unsigned int *
gsl_matrix_uint_ptr(gsl_matrix_uint * m, const size_t i, const size_t j)
{
 8005960:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005962:	4b11      	ldr	r3, [pc, #68]	; (80059a8 <gsl_matrix_uint_ptr+0x48>)
 8005964:	681b      	ldr	r3, [r3, #0]
 8005966:	b12b      	cbz	r3, 8005974 <gsl_matrix_uint_ptr+0x14>
    {
      if (i >= m->size1)
 8005968:	6803      	ldr	r3, [r0, #0]
 800596a:	428b      	cmp	r3, r1
 800596c:	d909      	bls.n	8005982 <gsl_matrix_uint_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800596e:	6843      	ldr	r3, [r0, #4]
 8005970:	4293      	cmp	r3, r2
 8005972:	d90f      	bls.n	8005994 <gsl_matrix_uint_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (unsigned int *) (m->data + (i * m->tda + j)) ;
 8005974:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005978:	fb03 2201 	mla	r2, r3, r1, r2
 800597c:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 8005980:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005982:	490a      	ldr	r1, [pc, #40]	; (80059ac <gsl_matrix_uint_ptr+0x4c>)
 8005984:	480a      	ldr	r0, [pc, #40]	; (80059b0 <gsl_matrix_uint_ptr+0x50>)
 8005986:	2304      	movs	r3, #4
 8005988:	f44f 729f 	mov.w	r2, #318	; 0x13e
 800598c:	f7fc ff68 	bl	8002860 <gsl_error>
 8005990:	2000      	movs	r0, #0
} 
 8005992:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005994:	4905      	ldr	r1, [pc, #20]	; (80059ac <gsl_matrix_uint_ptr+0x4c>)
 8005996:	4807      	ldr	r0, [pc, #28]	; (80059b4 <gsl_matrix_uint_ptr+0x54>)
 8005998:	2304      	movs	r3, #4
 800599a:	f44f 72a1 	mov.w	r2, #322	; 0x142
 800599e:	f7fc ff5f 	bl	8002860 <gsl_error>
 80059a2:	2000      	movs	r0, #0
} 
 80059a4:	bd08      	pop	{r3, pc}
 80059a6:	bf00      	nop
 80059a8:	20000000 	.word	0x20000000
 80059ac:	08030470 	.word	0x08030470
 80059b0:	08030360 	.word	0x08030360
 80059b4:	0803037c 	.word	0x0803037c

080059b8 <gsl_matrix_uint_const_ptr>:

INLINE_FUN 
const unsigned int *
gsl_matrix_uint_const_ptr(const gsl_matrix_uint * m, const size_t i, const size_t j)
{
 80059b8:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 80059ba:	4b11      	ldr	r3, [pc, #68]	; (8005a00 <gsl_matrix_uint_const_ptr+0x48>)
 80059bc:	681b      	ldr	r3, [r3, #0]
 80059be:	b12b      	cbz	r3, 80059cc <gsl_matrix_uint_const_ptr+0x14>
    {
      if (i >= m->size1)
 80059c0:	6803      	ldr	r3, [r0, #0]
 80059c2:	428b      	cmp	r3, r1
 80059c4:	d909      	bls.n	80059da <gsl_matrix_uint_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 80059c6:	6843      	ldr	r3, [r0, #4]
 80059c8:	4293      	cmp	r3, r2
 80059ca:	d90f      	bls.n	80059ec <gsl_matrix_uint_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const unsigned int *) (m->data + (i * m->tda + j)) ;
 80059cc:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 80059d0:	fb03 2201 	mla	r2, r3, r1, r2
 80059d4:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 80059d8:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 80059da:	490a      	ldr	r1, [pc, #40]	; (8005a04 <gsl_matrix_uint_const_ptr+0x4c>)
 80059dc:	480a      	ldr	r0, [pc, #40]	; (8005a08 <gsl_matrix_uint_const_ptr+0x50>)
 80059de:	2304      	movs	r3, #4
 80059e0:	f44f 72a9 	mov.w	r2, #338	; 0x152
 80059e4:	f7fc ff3c 	bl	8002860 <gsl_error>
 80059e8:	2000      	movs	r0, #0
} 
 80059ea:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 80059ec:	4905      	ldr	r1, [pc, #20]	; (8005a04 <gsl_matrix_uint_const_ptr+0x4c>)
 80059ee:	4807      	ldr	r0, [pc, #28]	; (8005a0c <gsl_matrix_uint_const_ptr+0x54>)
 80059f0:	2304      	movs	r3, #4
 80059f2:	f44f 72ab 	mov.w	r2, #342	; 0x156
 80059f6:	f7fc ff33 	bl	8002860 <gsl_error>
 80059fa:	2000      	movs	r0, #0
} 
 80059fc:	bd08      	pop	{r3, pc}
 80059fe:	bf00      	nop
 8005a00:	20000000 	.word	0x20000000
 8005a04:	08030470 	.word	0x08030470
 8005a08:	08030360 	.word	0x08030360
 8005a0c:	0803037c 	.word	0x0803037c

08005a10 <gsl_matrix_int_get>:
INLINE_FUN 
int
gsl_matrix_int_get(const gsl_matrix_int * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005a10:	4b11      	ldr	r3, [pc, #68]	; (8005a58 <gsl_matrix_int_get+0x48>)
 8005a12:	681b      	ldr	r3, [r3, #0]
{
 8005a14:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 8005a16:	b12b      	cbz	r3, 8005a24 <gsl_matrix_int_get+0x14>
    {
      if (i >= m->size1)
 8005a18:	6803      	ldr	r3, [r0, #0]
 8005a1a:	428b      	cmp	r3, r1
 8005a1c:	d909      	bls.n	8005a32 <gsl_matrix_int_get+0x22>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005a1e:	6843      	ldr	r3, [r0, #4]
 8005a20:	4293      	cmp	r3, r2
 8005a22:	d90f      	bls.n	8005a44 <gsl_matrix_int_get+0x34>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 8005a24:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005a28:	fb04 2201 	mla	r2, r4, r1, r2
 8005a2c:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
} 
 8005a30:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 8005a32:	490a      	ldr	r1, [pc, #40]	; (8005a5c <gsl_matrix_int_get+0x4c>)
 8005a34:	480a      	ldr	r0, [pc, #40]	; (8005a60 <gsl_matrix_int_get+0x50>)
 8005a36:	2304      	movs	r3, #4
 8005a38:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005a3c:	f7fc ff10 	bl	8002860 <gsl_error>
 8005a40:	2000      	movs	r0, #0
} 
 8005a42:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005a44:	4905      	ldr	r1, [pc, #20]	; (8005a5c <gsl_matrix_int_get+0x4c>)
 8005a46:	4807      	ldr	r0, [pc, #28]	; (8005a64 <gsl_matrix_int_get+0x54>)
 8005a48:	2304      	movs	r3, #4
 8005a4a:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005a4e:	f7fc ff07 	bl	8002860 <gsl_error>
 8005a52:	2000      	movs	r0, #0
} 
 8005a54:	bd10      	pop	{r4, pc}
 8005a56:	bf00      	nop
 8005a58:	20000000 	.word	0x20000000
 8005a5c:	0803048c 	.word	0x0803048c
 8005a60:	08030360 	.word	0x08030360
 8005a64:	0803037c 	.word	0x0803037c

08005a68 <gsl_matrix_int_set>:

INLINE_FUN 
void
gsl_matrix_int_set(gsl_matrix_int * m, const size_t i, const size_t j, const int x)
{
 8005a68:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005a6a:	4c12      	ldr	r4, [pc, #72]	; (8005ab4 <gsl_matrix_int_set+0x4c>)
 8005a6c:	6824      	ldr	r4, [r4, #0]
 8005a6e:	b12c      	cbz	r4, 8005a7c <gsl_matrix_int_set+0x14>
    {
      if (i >= m->size1)
 8005a70:	6804      	ldr	r4, [r0, #0]
 8005a72:	428c      	cmp	r4, r1
 8005a74:	d90b      	bls.n	8005a8e <gsl_matrix_int_set+0x26>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005a76:	6844      	ldr	r4, [r0, #4]
 8005a78:	4294      	cmp	r4, r2
 8005a7a:	d911      	bls.n	8005aa0 <gsl_matrix_int_set+0x38>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005a7c:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 8005a80:	fb04 2201 	mla	r2, r4, r1, r2
}
 8005a84:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 8005a88:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
 8005a8c:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005a8e:	490a      	ldr	r1, [pc, #40]	; (8005ab8 <gsl_matrix_int_set+0x50>)
 8005a90:	480a      	ldr	r0, [pc, #40]	; (8005abc <gsl_matrix_int_set+0x54>)
}
 8005a92:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005a96:	2304      	movs	r3, #4
 8005a98:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005a9c:	f7fc bee0 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005aa0:	4905      	ldr	r1, [pc, #20]	; (8005ab8 <gsl_matrix_int_set+0x50>)
 8005aa2:	4807      	ldr	r0, [pc, #28]	; (8005ac0 <gsl_matrix_int_set+0x58>)
}
 8005aa4:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005aa8:	2304      	movs	r3, #4
 8005aaa:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8005aae:	f7fc bed7 	b.w	8002860 <gsl_error>
 8005ab2:	bf00      	nop
 8005ab4:	20000000 	.word	0x20000000
 8005ab8:	0803048c 	.word	0x0803048c
 8005abc:	08030360 	.word	0x08030360
 8005ac0:	0803037c 	.word	0x0803037c

08005ac4 <gsl_matrix_int_ptr>:

INLINE_FUN 
int *
gsl_matrix_int_ptr(gsl_matrix_int * m, const size_t i, const size_t j)
{
 8005ac4:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005ac6:	4b11      	ldr	r3, [pc, #68]	; (8005b0c <gsl_matrix_int_ptr+0x48>)
 8005ac8:	681b      	ldr	r3, [r3, #0]
 8005aca:	b12b      	cbz	r3, 8005ad8 <gsl_matrix_int_ptr+0x14>
    {
      if (i >= m->size1)
 8005acc:	6803      	ldr	r3, [r0, #0]
 8005ace:	428b      	cmp	r3, r1
 8005ad0:	d909      	bls.n	8005ae6 <gsl_matrix_int_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005ad2:	6843      	ldr	r3, [r0, #4]
 8005ad4:	4293      	cmp	r3, r2
 8005ad6:	d90f      	bls.n	8005af8 <gsl_matrix_int_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (int *) (m->data + (i * m->tda + j)) ;
 8005ad8:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005adc:	fb03 2201 	mla	r2, r3, r1, r2
 8005ae0:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 8005ae4:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005ae6:	490a      	ldr	r1, [pc, #40]	; (8005b10 <gsl_matrix_int_ptr+0x4c>)
 8005ae8:	480a      	ldr	r0, [pc, #40]	; (8005b14 <gsl_matrix_int_ptr+0x50>)
 8005aea:	2304      	movs	r3, #4
 8005aec:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005af0:	f7fc feb6 	bl	8002860 <gsl_error>
 8005af4:	2000      	movs	r0, #0
} 
 8005af6:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005af8:	4905      	ldr	r1, [pc, #20]	; (8005b10 <gsl_matrix_int_ptr+0x4c>)
 8005afa:	4807      	ldr	r0, [pc, #28]	; (8005b18 <gsl_matrix_int_ptr+0x54>)
 8005afc:	2304      	movs	r3, #4
 8005afe:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005b02:	f7fc fead 	bl	8002860 <gsl_error>
 8005b06:	2000      	movs	r0, #0
} 
 8005b08:	bd08      	pop	{r3, pc}
 8005b0a:	bf00      	nop
 8005b0c:	20000000 	.word	0x20000000
 8005b10:	0803048c 	.word	0x0803048c
 8005b14:	08030360 	.word	0x08030360
 8005b18:	0803037c 	.word	0x0803037c

08005b1c <gsl_matrix_int_const_ptr>:

INLINE_FUN 
const int *
gsl_matrix_int_const_ptr(const gsl_matrix_int * m, const size_t i, const size_t j)
{
 8005b1c:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005b1e:	4b11      	ldr	r3, [pc, #68]	; (8005b64 <gsl_matrix_int_const_ptr+0x48>)
 8005b20:	681b      	ldr	r3, [r3, #0]
 8005b22:	b12b      	cbz	r3, 8005b30 <gsl_matrix_int_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005b24:	6803      	ldr	r3, [r0, #0]
 8005b26:	428b      	cmp	r3, r1
 8005b28:	d909      	bls.n	8005b3e <gsl_matrix_int_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005b2a:	6843      	ldr	r3, [r0, #4]
 8005b2c:	4293      	cmp	r3, r2
 8005b2e:	d90f      	bls.n	8005b50 <gsl_matrix_int_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const int *) (m->data + (i * m->tda + j)) ;
 8005b30:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005b34:	fb03 2201 	mla	r2, r3, r1, r2
 8005b38:	eb00 0082 	add.w	r0, r0, r2, lsl #2
} 
 8005b3c:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005b3e:	490a      	ldr	r1, [pc, #40]	; (8005b68 <gsl_matrix_int_const_ptr+0x4c>)
 8005b40:	480a      	ldr	r0, [pc, #40]	; (8005b6c <gsl_matrix_int_const_ptr+0x50>)
 8005b42:	2304      	movs	r3, #4
 8005b44:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8005b48:	f7fc fe8a 	bl	8002860 <gsl_error>
 8005b4c:	2000      	movs	r0, #0
} 
 8005b4e:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005b50:	4905      	ldr	r1, [pc, #20]	; (8005b68 <gsl_matrix_int_const_ptr+0x4c>)
 8005b52:	4807      	ldr	r0, [pc, #28]	; (8005b70 <gsl_matrix_int_const_ptr+0x54>)
 8005b54:	2304      	movs	r3, #4
 8005b56:	f44f 72ab 	mov.w	r2, #342	; 0x156
 8005b5a:	f7fc fe81 	bl	8002860 <gsl_error>
 8005b5e:	2000      	movs	r0, #0
} 
 8005b60:	bd08      	pop	{r3, pc}
 8005b62:	bf00      	nop
 8005b64:	20000000 	.word	0x20000000
 8005b68:	0803048c 	.word	0x0803048c
 8005b6c:	08030360 	.word	0x08030360
 8005b70:	0803037c 	.word	0x0803037c

08005b74 <gsl_matrix_ushort_get>:
INLINE_FUN 
unsigned short
gsl_matrix_ushort_get(const gsl_matrix_ushort * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005b74:	4b11      	ldr	r3, [pc, #68]	; (8005bbc <gsl_matrix_ushort_get+0x48>)
 8005b76:	681b      	ldr	r3, [r3, #0]
{
 8005b78:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 8005b7a:	b12b      	cbz	r3, 8005b88 <gsl_matrix_ushort_get+0x14>
    {
      if (i >= m->size1)
 8005b7c:	6803      	ldr	r3, [r0, #0]
 8005b7e:	428b      	cmp	r3, r1
 8005b80:	d909      	bls.n	8005b96 <gsl_matrix_ushort_get+0x22>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005b82:	6843      	ldr	r3, [r0, #4]
 8005b84:	4293      	cmp	r3, r2
 8005b86:	d90f      	bls.n	8005ba8 <gsl_matrix_ushort_get+0x34>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 8005b88:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005b8c:	fb04 2201 	mla	r2, r4, r1, r2
 8005b90:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
} 
 8005b94:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 8005b96:	490a      	ldr	r1, [pc, #40]	; (8005bc0 <gsl_matrix_ushort_get+0x4c>)
 8005b98:	480a      	ldr	r0, [pc, #40]	; (8005bc4 <gsl_matrix_ushort_get+0x50>)
 8005b9a:	2304      	movs	r3, #4
 8005b9c:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005ba0:	f7fc fe5e 	bl	8002860 <gsl_error>
 8005ba4:	2000      	movs	r0, #0
} 
 8005ba6:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005ba8:	4905      	ldr	r1, [pc, #20]	; (8005bc0 <gsl_matrix_ushort_get+0x4c>)
 8005baa:	4807      	ldr	r0, [pc, #28]	; (8005bc8 <gsl_matrix_ushort_get+0x54>)
 8005bac:	2304      	movs	r3, #4
 8005bae:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005bb2:	f7fc fe55 	bl	8002860 <gsl_error>
 8005bb6:	2000      	movs	r0, #0
} 
 8005bb8:	bd10      	pop	{r4, pc}
 8005bba:	bf00      	nop
 8005bbc:	20000000 	.word	0x20000000
 8005bc0:	080304a4 	.word	0x080304a4
 8005bc4:	08030360 	.word	0x08030360
 8005bc8:	0803037c 	.word	0x0803037c

08005bcc <gsl_matrix_ushort_set>:

INLINE_FUN 
void
gsl_matrix_ushort_set(gsl_matrix_ushort * m, const size_t i, const size_t j, const unsigned short x)
{
 8005bcc:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005bce:	4c12      	ldr	r4, [pc, #72]	; (8005c18 <gsl_matrix_ushort_set+0x4c>)
 8005bd0:	6824      	ldr	r4, [r4, #0]
 8005bd2:	b12c      	cbz	r4, 8005be0 <gsl_matrix_ushort_set+0x14>
    {
      if (i >= m->size1)
 8005bd4:	6804      	ldr	r4, [r0, #0]
 8005bd6:	428c      	cmp	r4, r1
 8005bd8:	d90b      	bls.n	8005bf2 <gsl_matrix_ushort_set+0x26>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005bda:	6844      	ldr	r4, [r0, #4]
 8005bdc:	4294      	cmp	r4, r2
 8005bde:	d911      	bls.n	8005c04 <gsl_matrix_ushort_set+0x38>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005be0:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 8005be4:	fb04 2201 	mla	r2, r4, r1, r2
}
 8005be8:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 8005bec:	f820 3012 	strh.w	r3, [r0, r2, lsl #1]
}
 8005bf0:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005bf2:	490a      	ldr	r1, [pc, #40]	; (8005c1c <gsl_matrix_ushort_set+0x50>)
 8005bf4:	480a      	ldr	r0, [pc, #40]	; (8005c20 <gsl_matrix_ushort_set+0x54>)
}
 8005bf6:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005bfa:	2304      	movs	r3, #4
 8005bfc:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005c00:	f7fc be2e 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005c04:	4905      	ldr	r1, [pc, #20]	; (8005c1c <gsl_matrix_ushort_set+0x50>)
 8005c06:	4807      	ldr	r0, [pc, #28]	; (8005c24 <gsl_matrix_ushort_set+0x58>)
}
 8005c08:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005c0c:	2304      	movs	r3, #4
 8005c0e:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8005c12:	f7fc be25 	b.w	8002860 <gsl_error>
 8005c16:	bf00      	nop
 8005c18:	20000000 	.word	0x20000000
 8005c1c:	080304a4 	.word	0x080304a4
 8005c20:	08030360 	.word	0x08030360
 8005c24:	0803037c 	.word	0x0803037c

08005c28 <gsl_matrix_ushort_ptr>:

INLINE_FUN 
unsigned short *
gsl_matrix_ushort_ptr(gsl_matrix_ushort * m, const size_t i, const size_t j)
{
 8005c28:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005c2a:	4b11      	ldr	r3, [pc, #68]	; (8005c70 <gsl_matrix_ushort_ptr+0x48>)
 8005c2c:	681b      	ldr	r3, [r3, #0]
 8005c2e:	b12b      	cbz	r3, 8005c3c <gsl_matrix_ushort_ptr+0x14>
    {
      if (i >= m->size1)
 8005c30:	6803      	ldr	r3, [r0, #0]
 8005c32:	428b      	cmp	r3, r1
 8005c34:	d909      	bls.n	8005c4a <gsl_matrix_ushort_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005c36:	6843      	ldr	r3, [r0, #4]
 8005c38:	4293      	cmp	r3, r2
 8005c3a:	d90f      	bls.n	8005c5c <gsl_matrix_ushort_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (unsigned short *) (m->data + (i * m->tda + j)) ;
 8005c3c:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005c40:	fb03 2201 	mla	r2, r3, r1, r2
 8005c44:	eb00 0042 	add.w	r0, r0, r2, lsl #1
} 
 8005c48:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005c4a:	490a      	ldr	r1, [pc, #40]	; (8005c74 <gsl_matrix_ushort_ptr+0x4c>)
 8005c4c:	480a      	ldr	r0, [pc, #40]	; (8005c78 <gsl_matrix_ushort_ptr+0x50>)
 8005c4e:	2304      	movs	r3, #4
 8005c50:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005c54:	f7fc fe04 	bl	8002860 <gsl_error>
 8005c58:	2000      	movs	r0, #0
} 
 8005c5a:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005c5c:	4905      	ldr	r1, [pc, #20]	; (8005c74 <gsl_matrix_ushort_ptr+0x4c>)
 8005c5e:	4807      	ldr	r0, [pc, #28]	; (8005c7c <gsl_matrix_ushort_ptr+0x54>)
 8005c60:	2304      	movs	r3, #4
 8005c62:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005c66:	f7fc fdfb 	bl	8002860 <gsl_error>
 8005c6a:	2000      	movs	r0, #0
} 
 8005c6c:	bd08      	pop	{r3, pc}
 8005c6e:	bf00      	nop
 8005c70:	20000000 	.word	0x20000000
 8005c74:	080304a4 	.word	0x080304a4
 8005c78:	08030360 	.word	0x08030360
 8005c7c:	0803037c 	.word	0x0803037c

08005c80 <gsl_matrix_ushort_const_ptr>:

INLINE_FUN 
const unsigned short *
gsl_matrix_ushort_const_ptr(const gsl_matrix_ushort * m, const size_t i, const size_t j)
{
 8005c80:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005c82:	4b11      	ldr	r3, [pc, #68]	; (8005cc8 <gsl_matrix_ushort_const_ptr+0x48>)
 8005c84:	681b      	ldr	r3, [r3, #0]
 8005c86:	b12b      	cbz	r3, 8005c94 <gsl_matrix_ushort_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005c88:	6803      	ldr	r3, [r0, #0]
 8005c8a:	428b      	cmp	r3, r1
 8005c8c:	d909      	bls.n	8005ca2 <gsl_matrix_ushort_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005c8e:	6843      	ldr	r3, [r0, #4]
 8005c90:	4293      	cmp	r3, r2
 8005c92:	d90f      	bls.n	8005cb4 <gsl_matrix_ushort_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const unsigned short *) (m->data + (i * m->tda + j)) ;
 8005c94:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005c98:	fb03 2201 	mla	r2, r3, r1, r2
 8005c9c:	eb00 0042 	add.w	r0, r0, r2, lsl #1
} 
 8005ca0:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005ca2:	490a      	ldr	r1, [pc, #40]	; (8005ccc <gsl_matrix_ushort_const_ptr+0x4c>)
 8005ca4:	480a      	ldr	r0, [pc, #40]	; (8005cd0 <gsl_matrix_ushort_const_ptr+0x50>)
 8005ca6:	2304      	movs	r3, #4
 8005ca8:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8005cac:	f7fc fdd8 	bl	8002860 <gsl_error>
 8005cb0:	2000      	movs	r0, #0
} 
 8005cb2:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005cb4:	4905      	ldr	r1, [pc, #20]	; (8005ccc <gsl_matrix_ushort_const_ptr+0x4c>)
 8005cb6:	4807      	ldr	r0, [pc, #28]	; (8005cd4 <gsl_matrix_ushort_const_ptr+0x54>)
 8005cb8:	2304      	movs	r3, #4
 8005cba:	f44f 72ab 	mov.w	r2, #342	; 0x156
 8005cbe:	f7fc fdcf 	bl	8002860 <gsl_error>
 8005cc2:	2000      	movs	r0, #0
} 
 8005cc4:	bd08      	pop	{r3, pc}
 8005cc6:	bf00      	nop
 8005cc8:	20000000 	.word	0x20000000
 8005ccc:	080304a4 	.word	0x080304a4
 8005cd0:	08030360 	.word	0x08030360
 8005cd4:	0803037c 	.word	0x0803037c

08005cd8 <gsl_matrix_short_get>:
INLINE_FUN 
short
gsl_matrix_short_get(const gsl_matrix_short * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005cd8:	4b11      	ldr	r3, [pc, #68]	; (8005d20 <gsl_matrix_short_get+0x48>)
 8005cda:	681b      	ldr	r3, [r3, #0]
{
 8005cdc:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 8005cde:	b12b      	cbz	r3, 8005cec <gsl_matrix_short_get+0x14>
    {
      if (i >= m->size1)
 8005ce0:	6803      	ldr	r3, [r0, #0]
 8005ce2:	428b      	cmp	r3, r1
 8005ce4:	d909      	bls.n	8005cfa <gsl_matrix_short_get+0x22>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005ce6:	6843      	ldr	r3, [r0, #4]
 8005ce8:	4293      	cmp	r3, r2
 8005cea:	d90f      	bls.n	8005d0c <gsl_matrix_short_get+0x34>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 8005cec:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005cf0:	fb04 2201 	mla	r2, r4, r1, r2
 8005cf4:	f933 0012 	ldrsh.w	r0, [r3, r2, lsl #1]
} 
 8005cf8:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 8005cfa:	490a      	ldr	r1, [pc, #40]	; (8005d24 <gsl_matrix_short_get+0x4c>)
 8005cfc:	480a      	ldr	r0, [pc, #40]	; (8005d28 <gsl_matrix_short_get+0x50>)
 8005cfe:	2304      	movs	r3, #4
 8005d00:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005d04:	f7fc fdac 	bl	8002860 <gsl_error>
 8005d08:	2000      	movs	r0, #0
} 
 8005d0a:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005d0c:	4905      	ldr	r1, [pc, #20]	; (8005d24 <gsl_matrix_short_get+0x4c>)
 8005d0e:	4807      	ldr	r0, [pc, #28]	; (8005d2c <gsl_matrix_short_get+0x54>)
 8005d10:	2304      	movs	r3, #4
 8005d12:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005d16:	f7fc fda3 	bl	8002860 <gsl_error>
 8005d1a:	2000      	movs	r0, #0
} 
 8005d1c:	bd10      	pop	{r4, pc}
 8005d1e:	bf00      	nop
 8005d20:	20000000 	.word	0x20000000
 8005d24:	080304c0 	.word	0x080304c0
 8005d28:	08030360 	.word	0x08030360
 8005d2c:	0803037c 	.word	0x0803037c

08005d30 <gsl_matrix_short_set>:

INLINE_FUN 
void
gsl_matrix_short_set(gsl_matrix_short * m, const size_t i, const size_t j, const short x)
{
 8005d30:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005d32:	4c12      	ldr	r4, [pc, #72]	; (8005d7c <gsl_matrix_short_set+0x4c>)
 8005d34:	6824      	ldr	r4, [r4, #0]
 8005d36:	b12c      	cbz	r4, 8005d44 <gsl_matrix_short_set+0x14>
    {
      if (i >= m->size1)
 8005d38:	6804      	ldr	r4, [r0, #0]
 8005d3a:	428c      	cmp	r4, r1
 8005d3c:	d90b      	bls.n	8005d56 <gsl_matrix_short_set+0x26>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005d3e:	6844      	ldr	r4, [r0, #4]
 8005d40:	4294      	cmp	r4, r2
 8005d42:	d911      	bls.n	8005d68 <gsl_matrix_short_set+0x38>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005d44:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 8005d48:	fb04 2201 	mla	r2, r4, r1, r2
}
 8005d4c:	f85d 4b04 	ldr.w	r4, [sp], #4
  m->data[i * m->tda + j] = x ;
 8005d50:	f820 3012 	strh.w	r3, [r0, r2, lsl #1]
}
 8005d54:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005d56:	490a      	ldr	r1, [pc, #40]	; (8005d80 <gsl_matrix_short_set+0x50>)
 8005d58:	480a      	ldr	r0, [pc, #40]	; (8005d84 <gsl_matrix_short_set+0x54>)
}
 8005d5a:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005d5e:	2304      	movs	r3, #4
 8005d60:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005d64:	f7fc bd7c 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005d68:	4905      	ldr	r1, [pc, #20]	; (8005d80 <gsl_matrix_short_set+0x50>)
 8005d6a:	4807      	ldr	r0, [pc, #28]	; (8005d88 <gsl_matrix_short_set+0x58>)
}
 8005d6c:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005d70:	2304      	movs	r3, #4
 8005d72:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8005d76:	f7fc bd73 	b.w	8002860 <gsl_error>
 8005d7a:	bf00      	nop
 8005d7c:	20000000 	.word	0x20000000
 8005d80:	080304c0 	.word	0x080304c0
 8005d84:	08030360 	.word	0x08030360
 8005d88:	0803037c 	.word	0x0803037c

08005d8c <gsl_matrix_short_ptr>:

INLINE_FUN 
short *
gsl_matrix_short_ptr(gsl_matrix_short * m, const size_t i, const size_t j)
{
 8005d8c:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005d8e:	4b11      	ldr	r3, [pc, #68]	; (8005dd4 <gsl_matrix_short_ptr+0x48>)
 8005d90:	681b      	ldr	r3, [r3, #0]
 8005d92:	b12b      	cbz	r3, 8005da0 <gsl_matrix_short_ptr+0x14>
    {
      if (i >= m->size1)
 8005d94:	6803      	ldr	r3, [r0, #0]
 8005d96:	428b      	cmp	r3, r1
 8005d98:	d909      	bls.n	8005dae <gsl_matrix_short_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005d9a:	6843      	ldr	r3, [r0, #4]
 8005d9c:	4293      	cmp	r3, r2
 8005d9e:	d90f      	bls.n	8005dc0 <gsl_matrix_short_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (short *) (m->data + (i * m->tda + j)) ;
 8005da0:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005da4:	fb03 2201 	mla	r2, r3, r1, r2
 8005da8:	eb00 0042 	add.w	r0, r0, r2, lsl #1
} 
 8005dac:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005dae:	490a      	ldr	r1, [pc, #40]	; (8005dd8 <gsl_matrix_short_ptr+0x4c>)
 8005db0:	480a      	ldr	r0, [pc, #40]	; (8005ddc <gsl_matrix_short_ptr+0x50>)
 8005db2:	2304      	movs	r3, #4
 8005db4:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005db8:	f7fc fd52 	bl	8002860 <gsl_error>
 8005dbc:	2000      	movs	r0, #0
} 
 8005dbe:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005dc0:	4905      	ldr	r1, [pc, #20]	; (8005dd8 <gsl_matrix_short_ptr+0x4c>)
 8005dc2:	4807      	ldr	r0, [pc, #28]	; (8005de0 <gsl_matrix_short_ptr+0x54>)
 8005dc4:	2304      	movs	r3, #4
 8005dc6:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005dca:	f7fc fd49 	bl	8002860 <gsl_error>
 8005dce:	2000      	movs	r0, #0
} 
 8005dd0:	bd08      	pop	{r3, pc}
 8005dd2:	bf00      	nop
 8005dd4:	20000000 	.word	0x20000000
 8005dd8:	080304c0 	.word	0x080304c0
 8005ddc:	08030360 	.word	0x08030360
 8005de0:	0803037c 	.word	0x0803037c

08005de4 <gsl_matrix_short_const_ptr>:

INLINE_FUN 
const short *
gsl_matrix_short_const_ptr(const gsl_matrix_short * m, const size_t i, const size_t j)
{
 8005de4:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005de6:	4b11      	ldr	r3, [pc, #68]	; (8005e2c <gsl_matrix_short_const_ptr+0x48>)
 8005de8:	681b      	ldr	r3, [r3, #0]
 8005dea:	b12b      	cbz	r3, 8005df8 <gsl_matrix_short_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005dec:	6803      	ldr	r3, [r0, #0]
 8005dee:	428b      	cmp	r3, r1
 8005df0:	d909      	bls.n	8005e06 <gsl_matrix_short_const_ptr+0x22>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005df2:	6843      	ldr	r3, [r0, #4]
 8005df4:	4293      	cmp	r3, r2
 8005df6:	d90f      	bls.n	8005e18 <gsl_matrix_short_const_ptr+0x34>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const short *) (m->data + (i * m->tda + j)) ;
 8005df8:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005dfc:	fb03 2201 	mla	r2, r3, r1, r2
 8005e00:	eb00 0042 	add.w	r0, r0, r2, lsl #1
} 
 8005e04:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005e06:	490a      	ldr	r1, [pc, #40]	; (8005e30 <gsl_matrix_short_const_ptr+0x4c>)
 8005e08:	480a      	ldr	r0, [pc, #40]	; (8005e34 <gsl_matrix_short_const_ptr+0x50>)
 8005e0a:	2304      	movs	r3, #4
 8005e0c:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8005e10:	f7fc fd26 	bl	8002860 <gsl_error>
 8005e14:	2000      	movs	r0, #0
} 
 8005e16:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005e18:	4905      	ldr	r1, [pc, #20]	; (8005e30 <gsl_matrix_short_const_ptr+0x4c>)
 8005e1a:	4807      	ldr	r0, [pc, #28]	; (8005e38 <gsl_matrix_short_const_ptr+0x54>)
 8005e1c:	2304      	movs	r3, #4
 8005e1e:	f44f 72ab 	mov.w	r2, #342	; 0x156
 8005e22:	f7fc fd1d 	bl	8002860 <gsl_error>
 8005e26:	2000      	movs	r0, #0
} 
 8005e28:	bd08      	pop	{r3, pc}
 8005e2a:	bf00      	nop
 8005e2c:	20000000 	.word	0x20000000
 8005e30:	080304c0 	.word	0x080304c0
 8005e34:	08030360 	.word	0x08030360
 8005e38:	0803037c 	.word	0x0803037c

08005e3c <gsl_matrix_uchar_get>:
INLINE_FUN 
unsigned char
gsl_matrix_uchar_get(const gsl_matrix_uchar * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005e3c:	4b10      	ldr	r3, [pc, #64]	; (8005e80 <gsl_matrix_uchar_get+0x44>)
 8005e3e:	681b      	ldr	r3, [r3, #0]
{
 8005e40:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 8005e42:	b12b      	cbz	r3, 8005e50 <gsl_matrix_uchar_get+0x14>
    {
      if (i >= m->size1)
 8005e44:	6803      	ldr	r3, [r0, #0]
 8005e46:	428b      	cmp	r3, r1
 8005e48:	d908      	bls.n	8005e5c <gsl_matrix_uchar_get+0x20>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005e4a:	6843      	ldr	r3, [r0, #4]
 8005e4c:	4293      	cmp	r3, r2
 8005e4e:	d90e      	bls.n	8005e6e <gsl_matrix_uchar_get+0x32>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 8005e50:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005e54:	fb04 3101 	mla	r1, r4, r1, r3
 8005e58:	5c88      	ldrb	r0, [r1, r2]
} 
 8005e5a:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 8005e5c:	4909      	ldr	r1, [pc, #36]	; (8005e84 <gsl_matrix_uchar_get+0x48>)
 8005e5e:	480a      	ldr	r0, [pc, #40]	; (8005e88 <gsl_matrix_uchar_get+0x4c>)
 8005e60:	2304      	movs	r3, #4
 8005e62:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005e66:	f7fc fcfb 	bl	8002860 <gsl_error>
 8005e6a:	2000      	movs	r0, #0
} 
 8005e6c:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005e6e:	4905      	ldr	r1, [pc, #20]	; (8005e84 <gsl_matrix_uchar_get+0x48>)
 8005e70:	4806      	ldr	r0, [pc, #24]	; (8005e8c <gsl_matrix_uchar_get+0x50>)
 8005e72:	2304      	movs	r3, #4
 8005e74:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005e78:	f7fc fcf2 	bl	8002860 <gsl_error>
 8005e7c:	2000      	movs	r0, #0
} 
 8005e7e:	bd10      	pop	{r4, pc}
 8005e80:	20000000 	.word	0x20000000
 8005e84:	080304dc 	.word	0x080304dc
 8005e88:	08030360 	.word	0x08030360
 8005e8c:	0803037c 	.word	0x0803037c

08005e90 <gsl_matrix_uchar_set>:

INLINE_FUN 
void
gsl_matrix_uchar_set(gsl_matrix_uchar * m, const size_t i, const size_t j, const unsigned char x)
{
 8005e90:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005e92:	4c11      	ldr	r4, [pc, #68]	; (8005ed8 <gsl_matrix_uchar_set+0x48>)
 8005e94:	6824      	ldr	r4, [r4, #0]
 8005e96:	b12c      	cbz	r4, 8005ea4 <gsl_matrix_uchar_set+0x14>
    {
      if (i >= m->size1)
 8005e98:	6804      	ldr	r4, [r0, #0]
 8005e9a:	428c      	cmp	r4, r1
 8005e9c:	d90a      	bls.n	8005eb4 <gsl_matrix_uchar_set+0x24>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005e9e:	6844      	ldr	r4, [r0, #4]
 8005ea0:	4294      	cmp	r4, r2
 8005ea2:	d910      	bls.n	8005ec6 <gsl_matrix_uchar_set+0x36>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005ea4:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 8005ea8:	fb04 0101 	mla	r1, r4, r1, r0
 8005eac:	548b      	strb	r3, [r1, r2]
}
 8005eae:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005eb2:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005eb4:	4909      	ldr	r1, [pc, #36]	; (8005edc <gsl_matrix_uchar_set+0x4c>)
 8005eb6:	480a      	ldr	r0, [pc, #40]	; (8005ee0 <gsl_matrix_uchar_set+0x50>)
}
 8005eb8:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8005ebc:	2304      	movs	r3, #4
 8005ebe:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8005ec2:	f7fc bccd 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005ec6:	4905      	ldr	r1, [pc, #20]	; (8005edc <gsl_matrix_uchar_set+0x4c>)
 8005ec8:	4806      	ldr	r0, [pc, #24]	; (8005ee4 <gsl_matrix_uchar_set+0x54>)
}
 8005eca:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8005ece:	2304      	movs	r3, #4
 8005ed0:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8005ed4:	f7fc bcc4 	b.w	8002860 <gsl_error>
 8005ed8:	20000000 	.word	0x20000000
 8005edc:	080304dc 	.word	0x080304dc
 8005ee0:	08030360 	.word	0x08030360
 8005ee4:	0803037c 	.word	0x0803037c

08005ee8 <gsl_matrix_uchar_ptr>:

INLINE_FUN 
unsigned char *
gsl_matrix_uchar_ptr(gsl_matrix_uchar * m, const size_t i, const size_t j)
{
 8005ee8:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005eea:	4b10      	ldr	r3, [pc, #64]	; (8005f2c <gsl_matrix_uchar_ptr+0x44>)
 8005eec:	681b      	ldr	r3, [r3, #0]
 8005eee:	b12b      	cbz	r3, 8005efc <gsl_matrix_uchar_ptr+0x14>
    {
      if (i >= m->size1)
 8005ef0:	6803      	ldr	r3, [r0, #0]
 8005ef2:	428b      	cmp	r3, r1
 8005ef4:	d908      	bls.n	8005f08 <gsl_matrix_uchar_ptr+0x20>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005ef6:	6843      	ldr	r3, [r0, #4]
 8005ef8:	4293      	cmp	r3, r2
 8005efa:	d90e      	bls.n	8005f1a <gsl_matrix_uchar_ptr+0x32>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (unsigned char *) (m->data + (i * m->tda + j)) ;
 8005efc:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005f00:	fb03 2201 	mla	r2, r3, r1, r2
 8005f04:	4410      	add	r0, r2
} 
 8005f06:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005f08:	4909      	ldr	r1, [pc, #36]	; (8005f30 <gsl_matrix_uchar_ptr+0x48>)
 8005f0a:	480a      	ldr	r0, [pc, #40]	; (8005f34 <gsl_matrix_uchar_ptr+0x4c>)
 8005f0c:	2304      	movs	r3, #4
 8005f0e:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8005f12:	f7fc fca5 	bl	8002860 <gsl_error>
 8005f16:	2000      	movs	r0, #0
} 
 8005f18:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005f1a:	4905      	ldr	r1, [pc, #20]	; (8005f30 <gsl_matrix_uchar_ptr+0x48>)
 8005f1c:	4806      	ldr	r0, [pc, #24]	; (8005f38 <gsl_matrix_uchar_ptr+0x50>)
 8005f1e:	2304      	movs	r3, #4
 8005f20:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8005f24:	f7fc fc9c 	bl	8002860 <gsl_error>
 8005f28:	2000      	movs	r0, #0
} 
 8005f2a:	bd08      	pop	{r3, pc}
 8005f2c:	20000000 	.word	0x20000000
 8005f30:	080304dc 	.word	0x080304dc
 8005f34:	08030360 	.word	0x08030360
 8005f38:	0803037c 	.word	0x0803037c

08005f3c <gsl_matrix_uchar_const_ptr>:

INLINE_FUN 
const unsigned char *
gsl_matrix_uchar_const_ptr(const gsl_matrix_uchar * m, const size_t i, const size_t j)
{
 8005f3c:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005f3e:	4b10      	ldr	r3, [pc, #64]	; (8005f80 <gsl_matrix_uchar_const_ptr+0x44>)
 8005f40:	681b      	ldr	r3, [r3, #0]
 8005f42:	b12b      	cbz	r3, 8005f50 <gsl_matrix_uchar_const_ptr+0x14>
    {
      if (i >= m->size1)
 8005f44:	6803      	ldr	r3, [r0, #0]
 8005f46:	428b      	cmp	r3, r1
 8005f48:	d908      	bls.n	8005f5c <gsl_matrix_uchar_const_ptr+0x20>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005f4a:	6843      	ldr	r3, [r0, #4]
 8005f4c:	4293      	cmp	r3, r2
 8005f4e:	d90e      	bls.n	8005f6e <gsl_matrix_uchar_const_ptr+0x32>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const unsigned char *) (m->data + (i * m->tda + j)) ;
 8005f50:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8005f54:	fb03 2201 	mla	r2, r3, r1, r2
 8005f58:	4410      	add	r0, r2
} 
 8005f5a:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 8005f5c:	4909      	ldr	r1, [pc, #36]	; (8005f84 <gsl_matrix_uchar_const_ptr+0x48>)
 8005f5e:	480a      	ldr	r0, [pc, #40]	; (8005f88 <gsl_matrix_uchar_const_ptr+0x4c>)
 8005f60:	2304      	movs	r3, #4
 8005f62:	f44f 72a9 	mov.w	r2, #338	; 0x152
 8005f66:	f7fc fc7b 	bl	8002860 <gsl_error>
 8005f6a:	2000      	movs	r0, #0
} 
 8005f6c:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 8005f6e:	4905      	ldr	r1, [pc, #20]	; (8005f84 <gsl_matrix_uchar_const_ptr+0x48>)
 8005f70:	4806      	ldr	r0, [pc, #24]	; (8005f8c <gsl_matrix_uchar_const_ptr+0x50>)
 8005f72:	2304      	movs	r3, #4
 8005f74:	f44f 72ab 	mov.w	r2, #342	; 0x156
 8005f78:	f7fc fc72 	bl	8002860 <gsl_error>
 8005f7c:	2000      	movs	r0, #0
} 
 8005f7e:	bd08      	pop	{r3, pc}
 8005f80:	20000000 	.word	0x20000000
 8005f84:	080304dc 	.word	0x080304dc
 8005f88:	08030360 	.word	0x08030360
 8005f8c:	0803037c 	.word	0x0803037c

08005f90 <gsl_matrix_char_get>:
INLINE_FUN 
char
gsl_matrix_char_get(const gsl_matrix_char * m, const size_t i, const size_t j)
{
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005f90:	4b10      	ldr	r3, [pc, #64]	; (8005fd4 <gsl_matrix_char_get+0x44>)
 8005f92:	681b      	ldr	r3, [r3, #0]
{
 8005f94:	b510      	push	{r4, lr}
  if (GSL_RANGE_COND(1)) 
 8005f96:	b12b      	cbz	r3, 8005fa4 <gsl_matrix_char_get+0x14>
    {
      if (i >= m->size1)
 8005f98:	6803      	ldr	r3, [r0, #0]
 8005f9a:	428b      	cmp	r3, r1
 8005f9c:	d908      	bls.n	8005fb0 <gsl_matrix_char_get+0x20>
        {
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
        }
      else if (j >= m->size2)
 8005f9e:	6843      	ldr	r3, [r0, #4]
 8005fa0:	4293      	cmp	r3, r2
 8005fa2:	d90e      	bls.n	8005fc2 <gsl_matrix_char_get+0x32>
        {
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
        }
    }
#endif
  return m->data[i * m->tda + j] ;
 8005fa4:	e9d0 4302 	ldrd	r4, r3, [r0, #8]
 8005fa8:	fb04 3101 	mla	r1, r4, r1, r3
 8005fac:	5c88      	ldrb	r0, [r1, r2]
} 
 8005fae:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
 8005fb0:	4909      	ldr	r1, [pc, #36]	; (8005fd8 <gsl_matrix_char_get+0x48>)
 8005fb2:	480a      	ldr	r0, [pc, #40]	; (8005fdc <gsl_matrix_char_get+0x4c>)
 8005fb4:	2304      	movs	r3, #4
 8005fb6:	f44f 728b 	mov.w	r2, #278	; 0x116
 8005fba:	f7fc fc51 	bl	8002860 <gsl_error>
 8005fbe:	2000      	movs	r0, #0
} 
 8005fc0:	bd10      	pop	{r4, pc}
          GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
 8005fc2:	4905      	ldr	r1, [pc, #20]	; (8005fd8 <gsl_matrix_char_get+0x48>)
 8005fc4:	4806      	ldr	r0, [pc, #24]	; (8005fe0 <gsl_matrix_char_get+0x50>)
 8005fc6:	2304      	movs	r3, #4
 8005fc8:	f44f 728d 	mov.w	r2, #282	; 0x11a
 8005fcc:	f7fc fc48 	bl	8002860 <gsl_error>
 8005fd0:	2000      	movs	r0, #0
} 
 8005fd2:	bd10      	pop	{r4, pc}
 8005fd4:	20000000 	.word	0x20000000
 8005fd8:	080304f8 	.word	0x080304f8
 8005fdc:	08030360 	.word	0x08030360
 8005fe0:	0803037c 	.word	0x0803037c

08005fe4 <gsl_matrix_char_set>:

INLINE_FUN 
void
gsl_matrix_char_set(gsl_matrix_char * m, const size_t i, const size_t j, const char x)
{
 8005fe4:	b410      	push	{r4}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8005fe6:	4c11      	ldr	r4, [pc, #68]	; (800602c <gsl_matrix_char_set+0x48>)
 8005fe8:	6824      	ldr	r4, [r4, #0]
 8005fea:	b12c      	cbz	r4, 8005ff8 <gsl_matrix_char_set+0x14>
    {
      if (i >= m->size1)
 8005fec:	6804      	ldr	r4, [r0, #0]
 8005fee:	428c      	cmp	r4, r1
 8005ff0:	d90a      	bls.n	8006008 <gsl_matrix_char_set+0x24>
        {
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 8005ff2:	6844      	ldr	r4, [r0, #4]
 8005ff4:	4294      	cmp	r4, r2
 8005ff6:	d910      	bls.n	800601a <gsl_matrix_char_set+0x36>
        {
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  m->data[i * m->tda + j] = x ;
 8005ff8:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
 8005ffc:	fb04 0101 	mla	r1, r4, r1, r0
 8006000:	548b      	strb	r3, [r1, r2]
}
 8006002:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006006:	4770      	bx	lr
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8006008:	4909      	ldr	r1, [pc, #36]	; (8006030 <gsl_matrix_char_set+0x4c>)
 800600a:	480a      	ldr	r0, [pc, #40]	; (8006034 <gsl_matrix_char_set+0x50>)
}
 800600c:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
 8006010:	2304      	movs	r3, #4
 8006012:	f44f 7295 	mov.w	r2, #298	; 0x12a
 8006016:	f7fc bc23 	b.w	8002860 <gsl_error>
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 800601a:	4905      	ldr	r1, [pc, #20]	; (8006030 <gsl_matrix_char_set+0x4c>)
 800601c:	4806      	ldr	r0, [pc, #24]	; (8006038 <gsl_matrix_char_set+0x54>)
}
 800601e:	f85d 4b04 	ldr.w	r4, [sp], #4
          GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
 8006022:	2304      	movs	r3, #4
 8006024:	f44f 7297 	mov.w	r2, #302	; 0x12e
 8006028:	f7fc bc1a 	b.w	8002860 <gsl_error>
 800602c:	20000000 	.word	0x20000000
 8006030:	080304f8 	.word	0x080304f8
 8006034:	08030360 	.word	0x08030360
 8006038:	0803037c 	.word	0x0803037c

0800603c <gsl_matrix_char_ptr>:

INLINE_FUN 
char *
gsl_matrix_char_ptr(gsl_matrix_char * m, const size_t i, const size_t j)
{
 800603c:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 800603e:	4b10      	ldr	r3, [pc, #64]	; (8006080 <gsl_matrix_char_ptr+0x44>)
 8006040:	681b      	ldr	r3, [r3, #0]
 8006042:	b12b      	cbz	r3, 8006050 <gsl_matrix_char_ptr+0x14>
    {
      if (i >= m->size1)
 8006044:	6803      	ldr	r3, [r0, #0]
 8006046:	428b      	cmp	r3, r1
 8006048:	d908      	bls.n	800605c <gsl_matrix_char_ptr+0x20>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800604a:	6843      	ldr	r3, [r0, #4]
 800604c:	4293      	cmp	r3, r2
 800604e:	d90e      	bls.n	800606e <gsl_matrix_char_ptr+0x32>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (char *) (m->data + (i * m->tda + j)) ;
 8006050:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 8006054:	fb03 2201 	mla	r2, r3, r1, r2
 8006058:	4410      	add	r0, r2
} 
 800605a:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 800605c:	4909      	ldr	r1, [pc, #36]	; (8006084 <gsl_matrix_char_ptr+0x48>)
 800605e:	480a      	ldr	r0, [pc, #40]	; (8006088 <gsl_matrix_char_ptr+0x4c>)
 8006060:	2304      	movs	r3, #4
 8006062:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8006066:	f7fc fbfb 	bl	8002860 <gsl_error>
 800606a:	2000      	movs	r0, #0
} 
 800606c:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 800606e:	4905      	ldr	r1, [pc, #20]	; (8006084 <gsl_matrix_char_ptr+0x48>)
 8006070:	4806      	ldr	r0, [pc, #24]	; (800608c <gsl_matrix_char_ptr+0x50>)
 8006072:	2304      	movs	r3, #4
 8006074:	f44f 72a1 	mov.w	r2, #322	; 0x142
 8006078:	f7fc fbf2 	bl	8002860 <gsl_error>
 800607c:	2000      	movs	r0, #0
} 
 800607e:	bd08      	pop	{r3, pc}
 8006080:	20000000 	.word	0x20000000
 8006084:	080304f8 	.word	0x080304f8
 8006088:	08030360 	.word	0x08030360
 800608c:	0803037c 	.word	0x0803037c

08006090 <gsl_matrix_char_const_ptr>:

INLINE_FUN 
const char *
gsl_matrix_char_const_ptr(const gsl_matrix_char * m, const size_t i, const size_t j)
{
 8006090:	b508      	push	{r3, lr}
#if GSL_RANGE_CHECK
  if (GSL_RANGE_COND(1)) 
 8006092:	4b10      	ldr	r3, [pc, #64]	; (80060d4 <gsl_matrix_char_const_ptr+0x44>)
 8006094:	681b      	ldr	r3, [r3, #0]
 8006096:	b12b      	cbz	r3, 80060a4 <gsl_matrix_char_const_ptr+0x14>
    {
      if (i >= m->size1)
 8006098:	6803      	ldr	r3, [r0, #0]
 800609a:	428b      	cmp	r3, r1
 800609c:	d908      	bls.n	80060b0 <gsl_matrix_char_const_ptr+0x20>
        {
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
        }
      else if (j >= m->size2)
 800609e:	6843      	ldr	r3, [r0, #4]
 80060a0:	4293      	cmp	r3, r2
 80060a2:	d90e      	bls.n	80060c2 <gsl_matrix_char_const_ptr+0x32>
        {
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
        }
    }
#endif
  return (const char *) (m->data + (i * m->tda + j)) ;
 80060a4:	e9d0 3002 	ldrd	r3, r0, [r0, #8]
 80060a8:	fb03 2201 	mla	r2, r3, r1, r2
 80060ac:	4410      	add	r0, r2
} 
 80060ae:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
 80060b0:	4909      	ldr	r1, [pc, #36]	; (80060d8 <gsl_matrix_char_const_ptr+0x48>)
 80060b2:	480a      	ldr	r0, [pc, #40]	; (80060dc <gsl_matrix_char_const_ptr+0x4c>)
 80060b4:	2304      	movs	r3, #4
 80060b6:	f44f 72a9 	mov.w	r2, #338	; 0x152
 80060ba:	f7fc fbd1 	bl	8002860 <gsl_error>
 80060be:	2000      	movs	r0, #0
} 
 80060c0:	bd08      	pop	{r3, pc}
          GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
 80060c2:	4905      	ldr	r1, [pc, #20]	; (80060d8 <gsl_matrix_char_const_ptr+0x48>)
 80060c4:	4806      	ldr	r0, [pc, #24]	; (80060e0 <gsl_matrix_char_const_ptr+0x50>)
 80060c6:	2304      	movs	r3, #4
 80060c8:	f44f 72ab 	mov.w	r2, #342	; 0x156
 80060cc:	f7fc fbc8 	bl	8002860 <gsl_error>
 80060d0:	2000      	movs	r0, #0
} 
 80060d2:	bd08      	pop	{r3, pc}
 80060d4:	20000000 	.word	0x20000000
 80060d8:	080304f8 	.word	0x080304f8
 80060dc:	08030360 	.word	0x08030360
 80060e0:	0803037c 	.word	0x0803037c

080060e4 <gsl_vector_complex_long_double_view_array>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

QUALIFIED_VIEW(_gsl_vector,view)
FUNCTION(gsl_vector, view_array) (QUALIFIER ATOMIC * base, size_t n)
{
 80060e4:	b430      	push	{r4, r5}
    v.stride = 1;
    v.block = 0;
    v.owner = 0;

    view.vector = v;
    return view;
 80060e6:	2501      	movs	r5, #1
 80060e8:	2400      	movs	r4, #0
 80060ea:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80060ee:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80060f2:	6002      	str	r2, [r0, #0]
  }
}
 80060f4:	bc30      	pop	{r4, r5}
 80060f6:	4770      	bx	lr

080060f8 <gsl_vector_complex_long_double_view_array_with_stride>:

QUALIFIED_VIEW(_gsl_vector,view)
FUNCTION(gsl_vector, view_array_with_stride) (QUALIFIER ATOMIC * base, 
                                              size_t stride,
                                              size_t n)
{
 80060f8:	b538      	push	{r3, r4, r5, lr}
 80060fa:	4604      	mov	r4, r0
  QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;

  if (stride == 0)
 80060fc:	4615      	mov	r5, r2
 80060fe:	b13a      	cbz	r2, 8006110 <gsl_vector_complex_long_double_view_array_with_stride+0x18>
    v.stride = stride;
    v.block = 0;
    v.owner = 0;

    view.vector = v;
    return view;
 8006100:	2200      	movs	r2, #0
 8006102:	e9c0 3500 	strd	r3, r5, [r0]
 8006106:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800610a:	6102      	str	r2, [r0, #16]
  }
}
 800610c:	4620      	mov	r0, r4
 800610e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006110:	4906      	ldr	r1, [pc, #24]	; (800612c <gsl_vector_complex_long_double_view_array_with_stride+0x34>)
 8006112:	4807      	ldr	r0, [pc, #28]	; (8006130 <gsl_vector_complex_long_double_view_array_with_stride+0x38>)
 8006114:	2304      	movs	r3, #4
 8006116:	2230      	movs	r2, #48	; 0x30
 8006118:	f7fc fba2 	bl	8002860 <gsl_error>
 800611c:	e9c4 5500 	strd	r5, r5, [r4]
 8006120:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006124:	6125      	str	r5, [r4, #16]
}
 8006126:	4620      	mov	r0, r4
 8006128:	bd38      	pop	{r3, r4, r5, pc}
 800612a:	bf00      	nop
 800612c:	08030514 	.word	0x08030514
 8006130:	08030524 	.word	0x08030524

08006134 <gsl_vector_complex_view_array>:
{
 8006134:	b430      	push	{r4, r5}
    return view;
 8006136:	2501      	movs	r5, #1
 8006138:	2400      	movs	r4, #0
 800613a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800613e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006142:	6002      	str	r2, [r0, #0]
}
 8006144:	bc30      	pop	{r4, r5}
 8006146:	4770      	bx	lr

08006148 <gsl_vector_complex_view_array_with_stride>:
{
 8006148:	b538      	push	{r3, r4, r5, lr}
 800614a:	4604      	mov	r4, r0
  if (stride == 0)
 800614c:	4615      	mov	r5, r2
 800614e:	b13a      	cbz	r2, 8006160 <gsl_vector_complex_view_array_with_stride+0x18>
    return view;
 8006150:	2200      	movs	r2, #0
 8006152:	e9c0 3500 	strd	r3, r5, [r0]
 8006156:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800615a:	6102      	str	r2, [r0, #16]
}
 800615c:	4620      	mov	r0, r4
 800615e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006160:	4906      	ldr	r1, [pc, #24]	; (800617c <gsl_vector_complex_view_array_with_stride+0x34>)
 8006162:	4807      	ldr	r0, [pc, #28]	; (8006180 <gsl_vector_complex_view_array_with_stride+0x38>)
 8006164:	2304      	movs	r3, #4
 8006166:	2230      	movs	r2, #48	; 0x30
 8006168:	f7fc fb7a 	bl	8002860 <gsl_error>
 800616c:	e9c4 5500 	strd	r5, r5, [r4]
 8006170:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006174:	6125      	str	r5, [r4, #16]
}
 8006176:	4620      	mov	r0, r4
 8006178:	bd38      	pop	{r3, r4, r5, pc}
 800617a:	bf00      	nop
 800617c:	08030514 	.word	0x08030514
 8006180:	08030524 	.word	0x08030524

08006184 <gsl_vector_complex_float_view_array>:
{
 8006184:	b430      	push	{r4, r5}
    return view;
 8006186:	2501      	movs	r5, #1
 8006188:	2400      	movs	r4, #0
 800618a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800618e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006192:	6002      	str	r2, [r0, #0]
}
 8006194:	bc30      	pop	{r4, r5}
 8006196:	4770      	bx	lr

08006198 <gsl_vector_complex_float_view_array_with_stride>:
{
 8006198:	b538      	push	{r3, r4, r5, lr}
 800619a:	4604      	mov	r4, r0
  if (stride == 0)
 800619c:	4615      	mov	r5, r2
 800619e:	b13a      	cbz	r2, 80061b0 <gsl_vector_complex_float_view_array_with_stride+0x18>
    return view;
 80061a0:	2200      	movs	r2, #0
 80061a2:	e9c0 3500 	strd	r3, r5, [r0]
 80061a6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80061aa:	6102      	str	r2, [r0, #16]
}
 80061ac:	4620      	mov	r0, r4
 80061ae:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80061b0:	4906      	ldr	r1, [pc, #24]	; (80061cc <gsl_vector_complex_float_view_array_with_stride+0x34>)
 80061b2:	4807      	ldr	r0, [pc, #28]	; (80061d0 <gsl_vector_complex_float_view_array_with_stride+0x38>)
 80061b4:	2304      	movs	r3, #4
 80061b6:	2230      	movs	r2, #48	; 0x30
 80061b8:	f7fc fb52 	bl	8002860 <gsl_error>
 80061bc:	e9c4 5500 	strd	r5, r5, [r4]
 80061c0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80061c4:	6125      	str	r5, [r4, #16]
}
 80061c6:	4620      	mov	r0, r4
 80061c8:	bd38      	pop	{r3, r4, r5, pc}
 80061ca:	bf00      	nop
 80061cc:	08030514 	.word	0x08030514
 80061d0:	08030524 	.word	0x08030524

080061d4 <gsl_vector_long_double_view_array>:
{
 80061d4:	b430      	push	{r4, r5}
    return view;
 80061d6:	2501      	movs	r5, #1
 80061d8:	2400      	movs	r4, #0
 80061da:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80061de:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80061e2:	6002      	str	r2, [r0, #0]
}
 80061e4:	bc30      	pop	{r4, r5}
 80061e6:	4770      	bx	lr

080061e8 <gsl_vector_long_double_view_array_with_stride>:
{
 80061e8:	b538      	push	{r3, r4, r5, lr}
 80061ea:	4604      	mov	r4, r0
  if (stride == 0)
 80061ec:	4615      	mov	r5, r2
 80061ee:	b13a      	cbz	r2, 8006200 <gsl_vector_long_double_view_array_with_stride+0x18>
    return view;
 80061f0:	2200      	movs	r2, #0
 80061f2:	e9c0 3500 	strd	r3, r5, [r0]
 80061f6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80061fa:	6102      	str	r2, [r0, #16]
}
 80061fc:	4620      	mov	r0, r4
 80061fe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006200:	4906      	ldr	r1, [pc, #24]	; (800621c <gsl_vector_long_double_view_array_with_stride+0x34>)
 8006202:	4807      	ldr	r0, [pc, #28]	; (8006220 <gsl_vector_long_double_view_array_with_stride+0x38>)
 8006204:	2304      	movs	r3, #4
 8006206:	2230      	movs	r2, #48	; 0x30
 8006208:	f7fc fb2a 	bl	8002860 <gsl_error>
 800620c:	e9c4 5500 	strd	r5, r5, [r4]
 8006210:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006214:	6125      	str	r5, [r4, #16]
}
 8006216:	4620      	mov	r0, r4
 8006218:	bd38      	pop	{r3, r4, r5, pc}
 800621a:	bf00      	nop
 800621c:	08030514 	.word	0x08030514
 8006220:	08030524 	.word	0x08030524

08006224 <gsl_vector_view_array>:
{
 8006224:	b430      	push	{r4, r5}
    return view;
 8006226:	2501      	movs	r5, #1
 8006228:	2400      	movs	r4, #0
 800622a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800622e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006232:	6002      	str	r2, [r0, #0]
}
 8006234:	bc30      	pop	{r4, r5}
 8006236:	4770      	bx	lr

08006238 <gsl_vector_view_array_with_stride>:
{
 8006238:	b538      	push	{r3, r4, r5, lr}
 800623a:	4604      	mov	r4, r0
  if (stride == 0)
 800623c:	4615      	mov	r5, r2
 800623e:	b13a      	cbz	r2, 8006250 <gsl_vector_view_array_with_stride+0x18>
    return view;
 8006240:	2200      	movs	r2, #0
 8006242:	e9c0 3500 	strd	r3, r5, [r0]
 8006246:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800624a:	6102      	str	r2, [r0, #16]
}
 800624c:	4620      	mov	r0, r4
 800624e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006250:	4906      	ldr	r1, [pc, #24]	; (800626c <gsl_vector_view_array_with_stride+0x34>)
 8006252:	4807      	ldr	r0, [pc, #28]	; (8006270 <gsl_vector_view_array_with_stride+0x38>)
 8006254:	2304      	movs	r3, #4
 8006256:	2230      	movs	r2, #48	; 0x30
 8006258:	f7fc fb02 	bl	8002860 <gsl_error>
 800625c:	e9c4 5500 	strd	r5, r5, [r4]
 8006260:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006264:	6125      	str	r5, [r4, #16]
}
 8006266:	4620      	mov	r0, r4
 8006268:	bd38      	pop	{r3, r4, r5, pc}
 800626a:	bf00      	nop
 800626c:	08030514 	.word	0x08030514
 8006270:	08030524 	.word	0x08030524

08006274 <gsl_vector_float_view_array>:
{
 8006274:	b430      	push	{r4, r5}
    return view;
 8006276:	2501      	movs	r5, #1
 8006278:	2400      	movs	r4, #0
 800627a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800627e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006282:	6002      	str	r2, [r0, #0]
}
 8006284:	bc30      	pop	{r4, r5}
 8006286:	4770      	bx	lr

08006288 <gsl_vector_float_view_array_with_stride>:
{
 8006288:	b538      	push	{r3, r4, r5, lr}
 800628a:	4604      	mov	r4, r0
  if (stride == 0)
 800628c:	4615      	mov	r5, r2
 800628e:	b13a      	cbz	r2, 80062a0 <gsl_vector_float_view_array_with_stride+0x18>
    return view;
 8006290:	2200      	movs	r2, #0
 8006292:	e9c0 3500 	strd	r3, r5, [r0]
 8006296:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800629a:	6102      	str	r2, [r0, #16]
}
 800629c:	4620      	mov	r0, r4
 800629e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80062a0:	4906      	ldr	r1, [pc, #24]	; (80062bc <gsl_vector_float_view_array_with_stride+0x34>)
 80062a2:	4807      	ldr	r0, [pc, #28]	; (80062c0 <gsl_vector_float_view_array_with_stride+0x38>)
 80062a4:	2304      	movs	r3, #4
 80062a6:	2230      	movs	r2, #48	; 0x30
 80062a8:	f7fc fada 	bl	8002860 <gsl_error>
 80062ac:	e9c4 5500 	strd	r5, r5, [r4]
 80062b0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80062b4:	6125      	str	r5, [r4, #16]
}
 80062b6:	4620      	mov	r0, r4
 80062b8:	bd38      	pop	{r3, r4, r5, pc}
 80062ba:	bf00      	nop
 80062bc:	08030514 	.word	0x08030514
 80062c0:	08030524 	.word	0x08030524

080062c4 <gsl_vector_ulong_view_array>:
{
 80062c4:	b430      	push	{r4, r5}
    return view;
 80062c6:	2501      	movs	r5, #1
 80062c8:	2400      	movs	r4, #0
 80062ca:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80062ce:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80062d2:	6002      	str	r2, [r0, #0]
}
 80062d4:	bc30      	pop	{r4, r5}
 80062d6:	4770      	bx	lr

080062d8 <gsl_vector_ulong_view_array_with_stride>:
{
 80062d8:	b538      	push	{r3, r4, r5, lr}
 80062da:	4604      	mov	r4, r0
  if (stride == 0)
 80062dc:	4615      	mov	r5, r2
 80062de:	b13a      	cbz	r2, 80062f0 <gsl_vector_ulong_view_array_with_stride+0x18>
    return view;
 80062e0:	2200      	movs	r2, #0
 80062e2:	e9c0 3500 	strd	r3, r5, [r0]
 80062e6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80062ea:	6102      	str	r2, [r0, #16]
}
 80062ec:	4620      	mov	r0, r4
 80062ee:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80062f0:	4906      	ldr	r1, [pc, #24]	; (800630c <gsl_vector_ulong_view_array_with_stride+0x34>)
 80062f2:	4807      	ldr	r0, [pc, #28]	; (8006310 <gsl_vector_ulong_view_array_with_stride+0x38>)
 80062f4:	2304      	movs	r3, #4
 80062f6:	2230      	movs	r2, #48	; 0x30
 80062f8:	f7fc fab2 	bl	8002860 <gsl_error>
 80062fc:	e9c4 5500 	strd	r5, r5, [r4]
 8006300:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006304:	6125      	str	r5, [r4, #16]
}
 8006306:	4620      	mov	r0, r4
 8006308:	bd38      	pop	{r3, r4, r5, pc}
 800630a:	bf00      	nop
 800630c:	08030514 	.word	0x08030514
 8006310:	08030524 	.word	0x08030524

08006314 <gsl_vector_long_view_array>:
{
 8006314:	b430      	push	{r4, r5}
    return view;
 8006316:	2501      	movs	r5, #1
 8006318:	2400      	movs	r4, #0
 800631a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800631e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006322:	6002      	str	r2, [r0, #0]
}
 8006324:	bc30      	pop	{r4, r5}
 8006326:	4770      	bx	lr

08006328 <gsl_vector_long_view_array_with_stride>:
{
 8006328:	b538      	push	{r3, r4, r5, lr}
 800632a:	4604      	mov	r4, r0
  if (stride == 0)
 800632c:	4615      	mov	r5, r2
 800632e:	b13a      	cbz	r2, 8006340 <gsl_vector_long_view_array_with_stride+0x18>
    return view;
 8006330:	2200      	movs	r2, #0
 8006332:	e9c0 3500 	strd	r3, r5, [r0]
 8006336:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800633a:	6102      	str	r2, [r0, #16]
}
 800633c:	4620      	mov	r0, r4
 800633e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006340:	4906      	ldr	r1, [pc, #24]	; (800635c <gsl_vector_long_view_array_with_stride+0x34>)
 8006342:	4807      	ldr	r0, [pc, #28]	; (8006360 <gsl_vector_long_view_array_with_stride+0x38>)
 8006344:	2304      	movs	r3, #4
 8006346:	2230      	movs	r2, #48	; 0x30
 8006348:	f7fc fa8a 	bl	8002860 <gsl_error>
 800634c:	e9c4 5500 	strd	r5, r5, [r4]
 8006350:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006354:	6125      	str	r5, [r4, #16]
}
 8006356:	4620      	mov	r0, r4
 8006358:	bd38      	pop	{r3, r4, r5, pc}
 800635a:	bf00      	nop
 800635c:	08030514 	.word	0x08030514
 8006360:	08030524 	.word	0x08030524

08006364 <gsl_vector_uint_view_array>:
{
 8006364:	b430      	push	{r4, r5}
    return view;
 8006366:	2501      	movs	r5, #1
 8006368:	2400      	movs	r4, #0
 800636a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800636e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006372:	6002      	str	r2, [r0, #0]
}
 8006374:	bc30      	pop	{r4, r5}
 8006376:	4770      	bx	lr

08006378 <gsl_vector_uint_view_array_with_stride>:
{
 8006378:	b538      	push	{r3, r4, r5, lr}
 800637a:	4604      	mov	r4, r0
  if (stride == 0)
 800637c:	4615      	mov	r5, r2
 800637e:	b13a      	cbz	r2, 8006390 <gsl_vector_uint_view_array_with_stride+0x18>
    return view;
 8006380:	2200      	movs	r2, #0
 8006382:	e9c0 3500 	strd	r3, r5, [r0]
 8006386:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800638a:	6102      	str	r2, [r0, #16]
}
 800638c:	4620      	mov	r0, r4
 800638e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006390:	4906      	ldr	r1, [pc, #24]	; (80063ac <gsl_vector_uint_view_array_with_stride+0x34>)
 8006392:	4807      	ldr	r0, [pc, #28]	; (80063b0 <gsl_vector_uint_view_array_with_stride+0x38>)
 8006394:	2304      	movs	r3, #4
 8006396:	2230      	movs	r2, #48	; 0x30
 8006398:	f7fc fa62 	bl	8002860 <gsl_error>
 800639c:	e9c4 5500 	strd	r5, r5, [r4]
 80063a0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80063a4:	6125      	str	r5, [r4, #16]
}
 80063a6:	4620      	mov	r0, r4
 80063a8:	bd38      	pop	{r3, r4, r5, pc}
 80063aa:	bf00      	nop
 80063ac:	08030514 	.word	0x08030514
 80063b0:	08030524 	.word	0x08030524

080063b4 <gsl_vector_int_view_array>:
{
 80063b4:	b430      	push	{r4, r5}
    return view;
 80063b6:	2501      	movs	r5, #1
 80063b8:	2400      	movs	r4, #0
 80063ba:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80063be:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80063c2:	6002      	str	r2, [r0, #0]
}
 80063c4:	bc30      	pop	{r4, r5}
 80063c6:	4770      	bx	lr

080063c8 <gsl_vector_int_view_array_with_stride>:
{
 80063c8:	b538      	push	{r3, r4, r5, lr}
 80063ca:	4604      	mov	r4, r0
  if (stride == 0)
 80063cc:	4615      	mov	r5, r2
 80063ce:	b13a      	cbz	r2, 80063e0 <gsl_vector_int_view_array_with_stride+0x18>
    return view;
 80063d0:	2200      	movs	r2, #0
 80063d2:	e9c0 3500 	strd	r3, r5, [r0]
 80063d6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80063da:	6102      	str	r2, [r0, #16]
}
 80063dc:	4620      	mov	r0, r4
 80063de:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80063e0:	4906      	ldr	r1, [pc, #24]	; (80063fc <gsl_vector_int_view_array_with_stride+0x34>)
 80063e2:	4807      	ldr	r0, [pc, #28]	; (8006400 <gsl_vector_int_view_array_with_stride+0x38>)
 80063e4:	2304      	movs	r3, #4
 80063e6:	2230      	movs	r2, #48	; 0x30
 80063e8:	f7fc fa3a 	bl	8002860 <gsl_error>
 80063ec:	e9c4 5500 	strd	r5, r5, [r4]
 80063f0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80063f4:	6125      	str	r5, [r4, #16]
}
 80063f6:	4620      	mov	r0, r4
 80063f8:	bd38      	pop	{r3, r4, r5, pc}
 80063fa:	bf00      	nop
 80063fc:	08030514 	.word	0x08030514
 8006400:	08030524 	.word	0x08030524

08006404 <gsl_vector_ushort_view_array>:
{
 8006404:	b430      	push	{r4, r5}
    return view;
 8006406:	2501      	movs	r5, #1
 8006408:	2400      	movs	r4, #0
 800640a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800640e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006412:	6002      	str	r2, [r0, #0]
}
 8006414:	bc30      	pop	{r4, r5}
 8006416:	4770      	bx	lr

08006418 <gsl_vector_ushort_view_array_with_stride>:
{
 8006418:	b538      	push	{r3, r4, r5, lr}
 800641a:	4604      	mov	r4, r0
  if (stride == 0)
 800641c:	4615      	mov	r5, r2
 800641e:	b13a      	cbz	r2, 8006430 <gsl_vector_ushort_view_array_with_stride+0x18>
    return view;
 8006420:	2200      	movs	r2, #0
 8006422:	e9c0 3500 	strd	r3, r5, [r0]
 8006426:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800642a:	6102      	str	r2, [r0, #16]
}
 800642c:	4620      	mov	r0, r4
 800642e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006430:	4906      	ldr	r1, [pc, #24]	; (800644c <gsl_vector_ushort_view_array_with_stride+0x34>)
 8006432:	4807      	ldr	r0, [pc, #28]	; (8006450 <gsl_vector_ushort_view_array_with_stride+0x38>)
 8006434:	2304      	movs	r3, #4
 8006436:	2230      	movs	r2, #48	; 0x30
 8006438:	f7fc fa12 	bl	8002860 <gsl_error>
 800643c:	e9c4 5500 	strd	r5, r5, [r4]
 8006440:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006444:	6125      	str	r5, [r4, #16]
}
 8006446:	4620      	mov	r0, r4
 8006448:	bd38      	pop	{r3, r4, r5, pc}
 800644a:	bf00      	nop
 800644c:	08030514 	.word	0x08030514
 8006450:	08030524 	.word	0x08030524

08006454 <gsl_vector_short_view_array>:
{
 8006454:	b430      	push	{r4, r5}
    return view;
 8006456:	2501      	movs	r5, #1
 8006458:	2400      	movs	r4, #0
 800645a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800645e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006462:	6002      	str	r2, [r0, #0]
}
 8006464:	bc30      	pop	{r4, r5}
 8006466:	4770      	bx	lr

08006468 <gsl_vector_short_view_array_with_stride>:
{
 8006468:	b538      	push	{r3, r4, r5, lr}
 800646a:	4604      	mov	r4, r0
  if (stride == 0)
 800646c:	4615      	mov	r5, r2
 800646e:	b13a      	cbz	r2, 8006480 <gsl_vector_short_view_array_with_stride+0x18>
    return view;
 8006470:	2200      	movs	r2, #0
 8006472:	e9c0 3500 	strd	r3, r5, [r0]
 8006476:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800647a:	6102      	str	r2, [r0, #16]
}
 800647c:	4620      	mov	r0, r4
 800647e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006480:	4906      	ldr	r1, [pc, #24]	; (800649c <gsl_vector_short_view_array_with_stride+0x34>)
 8006482:	4807      	ldr	r0, [pc, #28]	; (80064a0 <gsl_vector_short_view_array_with_stride+0x38>)
 8006484:	2304      	movs	r3, #4
 8006486:	2230      	movs	r2, #48	; 0x30
 8006488:	f7fc f9ea 	bl	8002860 <gsl_error>
 800648c:	e9c4 5500 	strd	r5, r5, [r4]
 8006490:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006494:	6125      	str	r5, [r4, #16]
}
 8006496:	4620      	mov	r0, r4
 8006498:	bd38      	pop	{r3, r4, r5, pc}
 800649a:	bf00      	nop
 800649c:	08030514 	.word	0x08030514
 80064a0:	08030524 	.word	0x08030524

080064a4 <gsl_vector_uchar_view_array>:
{
 80064a4:	b430      	push	{r4, r5}
    return view;
 80064a6:	2501      	movs	r5, #1
 80064a8:	2400      	movs	r4, #0
 80064aa:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80064ae:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80064b2:	6002      	str	r2, [r0, #0]
}
 80064b4:	bc30      	pop	{r4, r5}
 80064b6:	4770      	bx	lr

080064b8 <gsl_vector_uchar_view_array_with_stride>:
{
 80064b8:	b538      	push	{r3, r4, r5, lr}
 80064ba:	4604      	mov	r4, r0
  if (stride == 0)
 80064bc:	4615      	mov	r5, r2
 80064be:	b13a      	cbz	r2, 80064d0 <gsl_vector_uchar_view_array_with_stride+0x18>
    return view;
 80064c0:	2200      	movs	r2, #0
 80064c2:	e9c0 3500 	strd	r3, r5, [r0]
 80064c6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80064ca:	6102      	str	r2, [r0, #16]
}
 80064cc:	4620      	mov	r0, r4
 80064ce:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80064d0:	4906      	ldr	r1, [pc, #24]	; (80064ec <gsl_vector_uchar_view_array_with_stride+0x34>)
 80064d2:	4807      	ldr	r0, [pc, #28]	; (80064f0 <gsl_vector_uchar_view_array_with_stride+0x38>)
 80064d4:	2304      	movs	r3, #4
 80064d6:	2230      	movs	r2, #48	; 0x30
 80064d8:	f7fc f9c2 	bl	8002860 <gsl_error>
 80064dc:	e9c4 5500 	strd	r5, r5, [r4]
 80064e0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80064e4:	6125      	str	r5, [r4, #16]
}
 80064e6:	4620      	mov	r0, r4
 80064e8:	bd38      	pop	{r3, r4, r5, pc}
 80064ea:	bf00      	nop
 80064ec:	08030514 	.word	0x08030514
 80064f0:	08030524 	.word	0x08030524

080064f4 <gsl_vector_char_view_array>:
{
 80064f4:	b430      	push	{r4, r5}
    return view;
 80064f6:	2501      	movs	r5, #1
 80064f8:	2400      	movs	r4, #0
 80064fa:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80064fe:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006502:	6002      	str	r2, [r0, #0]
}
 8006504:	bc30      	pop	{r4, r5}
 8006506:	4770      	bx	lr

08006508 <gsl_vector_char_view_array_with_stride>:
{
 8006508:	b538      	push	{r3, r4, r5, lr}
 800650a:	4604      	mov	r4, r0
  if (stride == 0)
 800650c:	4615      	mov	r5, r2
 800650e:	b13a      	cbz	r2, 8006520 <gsl_vector_char_view_array_with_stride+0x18>
    return view;
 8006510:	2200      	movs	r2, #0
 8006512:	e9c0 3500 	strd	r3, r5, [r0]
 8006516:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800651a:	6102      	str	r2, [r0, #16]
}
 800651c:	4620      	mov	r0, r4
 800651e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006520:	4906      	ldr	r1, [pc, #24]	; (800653c <gsl_vector_char_view_array_with_stride+0x34>)
 8006522:	4807      	ldr	r0, [pc, #28]	; (8006540 <gsl_vector_char_view_array_with_stride+0x38>)
 8006524:	2304      	movs	r3, #4
 8006526:	2230      	movs	r2, #48	; 0x30
 8006528:	f7fc f99a 	bl	8002860 <gsl_error>
 800652c:	e9c4 5500 	strd	r5, r5, [r4]
 8006530:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006534:	6125      	str	r5, [r4, #16]
}
 8006536:	4620      	mov	r0, r4
 8006538:	bd38      	pop	{r3, r4, r5, pc}
 800653a:	bf00      	nop
 800653c:	08030514 	.word	0x08030514
 8006540:	08030524 	.word	0x08030524

08006544 <gsl_vector_complex_long_double_const_view_array>:
{
 8006544:	b430      	push	{r4, r5}
    return view;
 8006546:	2501      	movs	r5, #1
 8006548:	2400      	movs	r4, #0
 800654a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800654e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006552:	6002      	str	r2, [r0, #0]
}
 8006554:	bc30      	pop	{r4, r5}
 8006556:	4770      	bx	lr

08006558 <gsl_vector_complex_long_double_const_view_array_with_stride>:
{
 8006558:	b538      	push	{r3, r4, r5, lr}
 800655a:	4604      	mov	r4, r0
  if (stride == 0)
 800655c:	4615      	mov	r5, r2
 800655e:	b13a      	cbz	r2, 8006570 <gsl_vector_complex_long_double_const_view_array_with_stride+0x18>
    return view;
 8006560:	2200      	movs	r2, #0
 8006562:	e9c0 3500 	strd	r3, r5, [r0]
 8006566:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800656a:	6102      	str	r2, [r0, #16]
}
 800656c:	4620      	mov	r0, r4
 800656e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006570:	4906      	ldr	r1, [pc, #24]	; (800658c <gsl_vector_complex_long_double_const_view_array_with_stride+0x34>)
 8006572:	4807      	ldr	r0, [pc, #28]	; (8006590 <gsl_vector_complex_long_double_const_view_array_with_stride+0x38>)
 8006574:	2304      	movs	r3, #4
 8006576:	2230      	movs	r2, #48	; 0x30
 8006578:	f7fc f972 	bl	8002860 <gsl_error>
 800657c:	e9c4 5500 	strd	r5, r5, [r4]
 8006580:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006584:	6125      	str	r5, [r4, #16]
}
 8006586:	4620      	mov	r0, r4
 8006588:	bd38      	pop	{r3, r4, r5, pc}
 800658a:	bf00      	nop
 800658c:	08030514 	.word	0x08030514
 8006590:	08030524 	.word	0x08030524

08006594 <gsl_vector_complex_const_view_array>:
{
 8006594:	b430      	push	{r4, r5}
    return view;
 8006596:	2501      	movs	r5, #1
 8006598:	2400      	movs	r4, #0
 800659a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800659e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80065a2:	6002      	str	r2, [r0, #0]
}
 80065a4:	bc30      	pop	{r4, r5}
 80065a6:	4770      	bx	lr

080065a8 <gsl_vector_complex_const_view_array_with_stride>:
{
 80065a8:	b538      	push	{r3, r4, r5, lr}
 80065aa:	4604      	mov	r4, r0
  if (stride == 0)
 80065ac:	4615      	mov	r5, r2
 80065ae:	b13a      	cbz	r2, 80065c0 <gsl_vector_complex_const_view_array_with_stride+0x18>
    return view;
 80065b0:	2200      	movs	r2, #0
 80065b2:	e9c0 3500 	strd	r3, r5, [r0]
 80065b6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80065ba:	6102      	str	r2, [r0, #16]
}
 80065bc:	4620      	mov	r0, r4
 80065be:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80065c0:	4906      	ldr	r1, [pc, #24]	; (80065dc <gsl_vector_complex_const_view_array_with_stride+0x34>)
 80065c2:	4807      	ldr	r0, [pc, #28]	; (80065e0 <gsl_vector_complex_const_view_array_with_stride+0x38>)
 80065c4:	2304      	movs	r3, #4
 80065c6:	2230      	movs	r2, #48	; 0x30
 80065c8:	f7fc f94a 	bl	8002860 <gsl_error>
 80065cc:	e9c4 5500 	strd	r5, r5, [r4]
 80065d0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80065d4:	6125      	str	r5, [r4, #16]
}
 80065d6:	4620      	mov	r0, r4
 80065d8:	bd38      	pop	{r3, r4, r5, pc}
 80065da:	bf00      	nop
 80065dc:	08030514 	.word	0x08030514
 80065e0:	08030524 	.word	0x08030524

080065e4 <gsl_vector_complex_float_const_view_array>:
{
 80065e4:	b430      	push	{r4, r5}
    return view;
 80065e6:	2501      	movs	r5, #1
 80065e8:	2400      	movs	r4, #0
 80065ea:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80065ee:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80065f2:	6002      	str	r2, [r0, #0]
}
 80065f4:	bc30      	pop	{r4, r5}
 80065f6:	4770      	bx	lr

080065f8 <gsl_vector_complex_float_const_view_array_with_stride>:
{
 80065f8:	b538      	push	{r3, r4, r5, lr}
 80065fa:	4604      	mov	r4, r0
  if (stride == 0)
 80065fc:	4615      	mov	r5, r2
 80065fe:	b13a      	cbz	r2, 8006610 <gsl_vector_complex_float_const_view_array_with_stride+0x18>
    return view;
 8006600:	2200      	movs	r2, #0
 8006602:	e9c0 3500 	strd	r3, r5, [r0]
 8006606:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800660a:	6102      	str	r2, [r0, #16]
}
 800660c:	4620      	mov	r0, r4
 800660e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006610:	4906      	ldr	r1, [pc, #24]	; (800662c <gsl_vector_complex_float_const_view_array_with_stride+0x34>)
 8006612:	4807      	ldr	r0, [pc, #28]	; (8006630 <gsl_vector_complex_float_const_view_array_with_stride+0x38>)
 8006614:	2304      	movs	r3, #4
 8006616:	2230      	movs	r2, #48	; 0x30
 8006618:	f7fc f922 	bl	8002860 <gsl_error>
 800661c:	e9c4 5500 	strd	r5, r5, [r4]
 8006620:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006624:	6125      	str	r5, [r4, #16]
}
 8006626:	4620      	mov	r0, r4
 8006628:	bd38      	pop	{r3, r4, r5, pc}
 800662a:	bf00      	nop
 800662c:	08030514 	.word	0x08030514
 8006630:	08030524 	.word	0x08030524

08006634 <gsl_vector_long_double_const_view_array>:
{
 8006634:	b430      	push	{r4, r5}
    return view;
 8006636:	2501      	movs	r5, #1
 8006638:	2400      	movs	r4, #0
 800663a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800663e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006642:	6002      	str	r2, [r0, #0]
}
 8006644:	bc30      	pop	{r4, r5}
 8006646:	4770      	bx	lr

08006648 <gsl_vector_long_double_const_view_array_with_stride>:
{
 8006648:	b538      	push	{r3, r4, r5, lr}
 800664a:	4604      	mov	r4, r0
  if (stride == 0)
 800664c:	4615      	mov	r5, r2
 800664e:	b13a      	cbz	r2, 8006660 <gsl_vector_long_double_const_view_array_with_stride+0x18>
    return view;
 8006650:	2200      	movs	r2, #0
 8006652:	e9c0 3500 	strd	r3, r5, [r0]
 8006656:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800665a:	6102      	str	r2, [r0, #16]
}
 800665c:	4620      	mov	r0, r4
 800665e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006660:	4906      	ldr	r1, [pc, #24]	; (800667c <gsl_vector_long_double_const_view_array_with_stride+0x34>)
 8006662:	4807      	ldr	r0, [pc, #28]	; (8006680 <gsl_vector_long_double_const_view_array_with_stride+0x38>)
 8006664:	2304      	movs	r3, #4
 8006666:	2230      	movs	r2, #48	; 0x30
 8006668:	f7fc f8fa 	bl	8002860 <gsl_error>
 800666c:	e9c4 5500 	strd	r5, r5, [r4]
 8006670:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006674:	6125      	str	r5, [r4, #16]
}
 8006676:	4620      	mov	r0, r4
 8006678:	bd38      	pop	{r3, r4, r5, pc}
 800667a:	bf00      	nop
 800667c:	08030514 	.word	0x08030514
 8006680:	08030524 	.word	0x08030524

08006684 <gsl_vector_const_view_array>:
{
 8006684:	b430      	push	{r4, r5}
    return view;
 8006686:	2501      	movs	r5, #1
 8006688:	2400      	movs	r4, #0
 800668a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800668e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006692:	6002      	str	r2, [r0, #0]
}
 8006694:	bc30      	pop	{r4, r5}
 8006696:	4770      	bx	lr

08006698 <gsl_vector_const_view_array_with_stride>:
{
 8006698:	b538      	push	{r3, r4, r5, lr}
 800669a:	4604      	mov	r4, r0
  if (stride == 0)
 800669c:	4615      	mov	r5, r2
 800669e:	b13a      	cbz	r2, 80066b0 <gsl_vector_const_view_array_with_stride+0x18>
    return view;
 80066a0:	2200      	movs	r2, #0
 80066a2:	e9c0 3500 	strd	r3, r5, [r0]
 80066a6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80066aa:	6102      	str	r2, [r0, #16]
}
 80066ac:	4620      	mov	r0, r4
 80066ae:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80066b0:	4906      	ldr	r1, [pc, #24]	; (80066cc <gsl_vector_const_view_array_with_stride+0x34>)
 80066b2:	4807      	ldr	r0, [pc, #28]	; (80066d0 <gsl_vector_const_view_array_with_stride+0x38>)
 80066b4:	2304      	movs	r3, #4
 80066b6:	2230      	movs	r2, #48	; 0x30
 80066b8:	f7fc f8d2 	bl	8002860 <gsl_error>
 80066bc:	e9c4 5500 	strd	r5, r5, [r4]
 80066c0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80066c4:	6125      	str	r5, [r4, #16]
}
 80066c6:	4620      	mov	r0, r4
 80066c8:	bd38      	pop	{r3, r4, r5, pc}
 80066ca:	bf00      	nop
 80066cc:	08030514 	.word	0x08030514
 80066d0:	08030524 	.word	0x08030524

080066d4 <gsl_vector_float_const_view_array>:
{
 80066d4:	b430      	push	{r4, r5}
    return view;
 80066d6:	2501      	movs	r5, #1
 80066d8:	2400      	movs	r4, #0
 80066da:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80066de:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80066e2:	6002      	str	r2, [r0, #0]
}
 80066e4:	bc30      	pop	{r4, r5}
 80066e6:	4770      	bx	lr

080066e8 <gsl_vector_float_const_view_array_with_stride>:
{
 80066e8:	b538      	push	{r3, r4, r5, lr}
 80066ea:	4604      	mov	r4, r0
  if (stride == 0)
 80066ec:	4615      	mov	r5, r2
 80066ee:	b13a      	cbz	r2, 8006700 <gsl_vector_float_const_view_array_with_stride+0x18>
    return view;
 80066f0:	2200      	movs	r2, #0
 80066f2:	e9c0 3500 	strd	r3, r5, [r0]
 80066f6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80066fa:	6102      	str	r2, [r0, #16]
}
 80066fc:	4620      	mov	r0, r4
 80066fe:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006700:	4906      	ldr	r1, [pc, #24]	; (800671c <gsl_vector_float_const_view_array_with_stride+0x34>)
 8006702:	4807      	ldr	r0, [pc, #28]	; (8006720 <gsl_vector_float_const_view_array_with_stride+0x38>)
 8006704:	2304      	movs	r3, #4
 8006706:	2230      	movs	r2, #48	; 0x30
 8006708:	f7fc f8aa 	bl	8002860 <gsl_error>
 800670c:	e9c4 5500 	strd	r5, r5, [r4]
 8006710:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006714:	6125      	str	r5, [r4, #16]
}
 8006716:	4620      	mov	r0, r4
 8006718:	bd38      	pop	{r3, r4, r5, pc}
 800671a:	bf00      	nop
 800671c:	08030514 	.word	0x08030514
 8006720:	08030524 	.word	0x08030524

08006724 <gsl_vector_ulong_const_view_array>:
{
 8006724:	b430      	push	{r4, r5}
    return view;
 8006726:	2501      	movs	r5, #1
 8006728:	2400      	movs	r4, #0
 800672a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800672e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006732:	6002      	str	r2, [r0, #0]
}
 8006734:	bc30      	pop	{r4, r5}
 8006736:	4770      	bx	lr

08006738 <gsl_vector_ulong_const_view_array_with_stride>:
{
 8006738:	b538      	push	{r3, r4, r5, lr}
 800673a:	4604      	mov	r4, r0
  if (stride == 0)
 800673c:	4615      	mov	r5, r2
 800673e:	b13a      	cbz	r2, 8006750 <gsl_vector_ulong_const_view_array_with_stride+0x18>
    return view;
 8006740:	2200      	movs	r2, #0
 8006742:	e9c0 3500 	strd	r3, r5, [r0]
 8006746:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800674a:	6102      	str	r2, [r0, #16]
}
 800674c:	4620      	mov	r0, r4
 800674e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006750:	4906      	ldr	r1, [pc, #24]	; (800676c <gsl_vector_ulong_const_view_array_with_stride+0x34>)
 8006752:	4807      	ldr	r0, [pc, #28]	; (8006770 <gsl_vector_ulong_const_view_array_with_stride+0x38>)
 8006754:	2304      	movs	r3, #4
 8006756:	2230      	movs	r2, #48	; 0x30
 8006758:	f7fc f882 	bl	8002860 <gsl_error>
 800675c:	e9c4 5500 	strd	r5, r5, [r4]
 8006760:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006764:	6125      	str	r5, [r4, #16]
}
 8006766:	4620      	mov	r0, r4
 8006768:	bd38      	pop	{r3, r4, r5, pc}
 800676a:	bf00      	nop
 800676c:	08030514 	.word	0x08030514
 8006770:	08030524 	.word	0x08030524

08006774 <gsl_vector_long_const_view_array>:
{
 8006774:	b430      	push	{r4, r5}
    return view;
 8006776:	2501      	movs	r5, #1
 8006778:	2400      	movs	r4, #0
 800677a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800677e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006782:	6002      	str	r2, [r0, #0]
}
 8006784:	bc30      	pop	{r4, r5}
 8006786:	4770      	bx	lr

08006788 <gsl_vector_long_const_view_array_with_stride>:
{
 8006788:	b538      	push	{r3, r4, r5, lr}
 800678a:	4604      	mov	r4, r0
  if (stride == 0)
 800678c:	4615      	mov	r5, r2
 800678e:	b13a      	cbz	r2, 80067a0 <gsl_vector_long_const_view_array_with_stride+0x18>
    return view;
 8006790:	2200      	movs	r2, #0
 8006792:	e9c0 3500 	strd	r3, r5, [r0]
 8006796:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800679a:	6102      	str	r2, [r0, #16]
}
 800679c:	4620      	mov	r0, r4
 800679e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80067a0:	4906      	ldr	r1, [pc, #24]	; (80067bc <gsl_vector_long_const_view_array_with_stride+0x34>)
 80067a2:	4807      	ldr	r0, [pc, #28]	; (80067c0 <gsl_vector_long_const_view_array_with_stride+0x38>)
 80067a4:	2304      	movs	r3, #4
 80067a6:	2230      	movs	r2, #48	; 0x30
 80067a8:	f7fc f85a 	bl	8002860 <gsl_error>
 80067ac:	e9c4 5500 	strd	r5, r5, [r4]
 80067b0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80067b4:	6125      	str	r5, [r4, #16]
}
 80067b6:	4620      	mov	r0, r4
 80067b8:	bd38      	pop	{r3, r4, r5, pc}
 80067ba:	bf00      	nop
 80067bc:	08030514 	.word	0x08030514
 80067c0:	08030524 	.word	0x08030524

080067c4 <gsl_vector_uint_const_view_array>:
{
 80067c4:	b430      	push	{r4, r5}
    return view;
 80067c6:	2501      	movs	r5, #1
 80067c8:	2400      	movs	r4, #0
 80067ca:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80067ce:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80067d2:	6002      	str	r2, [r0, #0]
}
 80067d4:	bc30      	pop	{r4, r5}
 80067d6:	4770      	bx	lr

080067d8 <gsl_vector_uint_const_view_array_with_stride>:
{
 80067d8:	b538      	push	{r3, r4, r5, lr}
 80067da:	4604      	mov	r4, r0
  if (stride == 0)
 80067dc:	4615      	mov	r5, r2
 80067de:	b13a      	cbz	r2, 80067f0 <gsl_vector_uint_const_view_array_with_stride+0x18>
    return view;
 80067e0:	2200      	movs	r2, #0
 80067e2:	e9c0 3500 	strd	r3, r5, [r0]
 80067e6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80067ea:	6102      	str	r2, [r0, #16]
}
 80067ec:	4620      	mov	r0, r4
 80067ee:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80067f0:	4906      	ldr	r1, [pc, #24]	; (800680c <gsl_vector_uint_const_view_array_with_stride+0x34>)
 80067f2:	4807      	ldr	r0, [pc, #28]	; (8006810 <gsl_vector_uint_const_view_array_with_stride+0x38>)
 80067f4:	2304      	movs	r3, #4
 80067f6:	2230      	movs	r2, #48	; 0x30
 80067f8:	f7fc f832 	bl	8002860 <gsl_error>
 80067fc:	e9c4 5500 	strd	r5, r5, [r4]
 8006800:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006804:	6125      	str	r5, [r4, #16]
}
 8006806:	4620      	mov	r0, r4
 8006808:	bd38      	pop	{r3, r4, r5, pc}
 800680a:	bf00      	nop
 800680c:	08030514 	.word	0x08030514
 8006810:	08030524 	.word	0x08030524

08006814 <gsl_vector_int_const_view_array>:
{
 8006814:	b430      	push	{r4, r5}
    return view;
 8006816:	2501      	movs	r5, #1
 8006818:	2400      	movs	r4, #0
 800681a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800681e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006822:	6002      	str	r2, [r0, #0]
}
 8006824:	bc30      	pop	{r4, r5}
 8006826:	4770      	bx	lr

08006828 <gsl_vector_int_const_view_array_with_stride>:
{
 8006828:	b538      	push	{r3, r4, r5, lr}
 800682a:	4604      	mov	r4, r0
  if (stride == 0)
 800682c:	4615      	mov	r5, r2
 800682e:	b13a      	cbz	r2, 8006840 <gsl_vector_int_const_view_array_with_stride+0x18>
    return view;
 8006830:	2200      	movs	r2, #0
 8006832:	e9c0 3500 	strd	r3, r5, [r0]
 8006836:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800683a:	6102      	str	r2, [r0, #16]
}
 800683c:	4620      	mov	r0, r4
 800683e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006840:	4906      	ldr	r1, [pc, #24]	; (800685c <gsl_vector_int_const_view_array_with_stride+0x34>)
 8006842:	4807      	ldr	r0, [pc, #28]	; (8006860 <gsl_vector_int_const_view_array_with_stride+0x38>)
 8006844:	2304      	movs	r3, #4
 8006846:	2230      	movs	r2, #48	; 0x30
 8006848:	f7fc f80a 	bl	8002860 <gsl_error>
 800684c:	e9c4 5500 	strd	r5, r5, [r4]
 8006850:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006854:	6125      	str	r5, [r4, #16]
}
 8006856:	4620      	mov	r0, r4
 8006858:	bd38      	pop	{r3, r4, r5, pc}
 800685a:	bf00      	nop
 800685c:	08030514 	.word	0x08030514
 8006860:	08030524 	.word	0x08030524

08006864 <gsl_vector_ushort_const_view_array>:
{
 8006864:	b430      	push	{r4, r5}
    return view;
 8006866:	2501      	movs	r5, #1
 8006868:	2400      	movs	r4, #0
 800686a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800686e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006872:	6002      	str	r2, [r0, #0]
}
 8006874:	bc30      	pop	{r4, r5}
 8006876:	4770      	bx	lr

08006878 <gsl_vector_ushort_const_view_array_with_stride>:
{
 8006878:	b538      	push	{r3, r4, r5, lr}
 800687a:	4604      	mov	r4, r0
  if (stride == 0)
 800687c:	4615      	mov	r5, r2
 800687e:	b13a      	cbz	r2, 8006890 <gsl_vector_ushort_const_view_array_with_stride+0x18>
    return view;
 8006880:	2200      	movs	r2, #0
 8006882:	e9c0 3500 	strd	r3, r5, [r0]
 8006886:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800688a:	6102      	str	r2, [r0, #16]
}
 800688c:	4620      	mov	r0, r4
 800688e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006890:	4906      	ldr	r1, [pc, #24]	; (80068ac <gsl_vector_ushort_const_view_array_with_stride+0x34>)
 8006892:	4807      	ldr	r0, [pc, #28]	; (80068b0 <gsl_vector_ushort_const_view_array_with_stride+0x38>)
 8006894:	2304      	movs	r3, #4
 8006896:	2230      	movs	r2, #48	; 0x30
 8006898:	f7fb ffe2 	bl	8002860 <gsl_error>
 800689c:	e9c4 5500 	strd	r5, r5, [r4]
 80068a0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80068a4:	6125      	str	r5, [r4, #16]
}
 80068a6:	4620      	mov	r0, r4
 80068a8:	bd38      	pop	{r3, r4, r5, pc}
 80068aa:	bf00      	nop
 80068ac:	08030514 	.word	0x08030514
 80068b0:	08030524 	.word	0x08030524

080068b4 <gsl_vector_short_const_view_array>:
{
 80068b4:	b430      	push	{r4, r5}
    return view;
 80068b6:	2501      	movs	r5, #1
 80068b8:	2400      	movs	r4, #0
 80068ba:	e9c0 5101 	strd	r5, r1, [r0, #4]
 80068be:	e9c0 4403 	strd	r4, r4, [r0, #12]
 80068c2:	6002      	str	r2, [r0, #0]
}
 80068c4:	bc30      	pop	{r4, r5}
 80068c6:	4770      	bx	lr

080068c8 <gsl_vector_short_const_view_array_with_stride>:
{
 80068c8:	b538      	push	{r3, r4, r5, lr}
 80068ca:	4604      	mov	r4, r0
  if (stride == 0)
 80068cc:	4615      	mov	r5, r2
 80068ce:	b13a      	cbz	r2, 80068e0 <gsl_vector_short_const_view_array_with_stride+0x18>
    return view;
 80068d0:	2200      	movs	r2, #0
 80068d2:	e9c0 3500 	strd	r3, r5, [r0]
 80068d6:	e9c0 1202 	strd	r1, r2, [r0, #8]
 80068da:	6102      	str	r2, [r0, #16]
}
 80068dc:	4620      	mov	r0, r4
 80068de:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 80068e0:	4906      	ldr	r1, [pc, #24]	; (80068fc <gsl_vector_short_const_view_array_with_stride+0x34>)
 80068e2:	4807      	ldr	r0, [pc, #28]	; (8006900 <gsl_vector_short_const_view_array_with_stride+0x38>)
 80068e4:	2304      	movs	r3, #4
 80068e6:	2230      	movs	r2, #48	; 0x30
 80068e8:	f7fb ffba 	bl	8002860 <gsl_error>
 80068ec:	e9c4 5500 	strd	r5, r5, [r4]
 80068f0:	e9c4 5502 	strd	r5, r5, [r4, #8]
 80068f4:	6125      	str	r5, [r4, #16]
}
 80068f6:	4620      	mov	r0, r4
 80068f8:	bd38      	pop	{r3, r4, r5, pc}
 80068fa:	bf00      	nop
 80068fc:	08030514 	.word	0x08030514
 8006900:	08030524 	.word	0x08030524

08006904 <gsl_vector_uchar_const_view_array>:
{
 8006904:	b430      	push	{r4, r5}
    return view;
 8006906:	2501      	movs	r5, #1
 8006908:	2400      	movs	r4, #0
 800690a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800690e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006912:	6002      	str	r2, [r0, #0]
}
 8006914:	bc30      	pop	{r4, r5}
 8006916:	4770      	bx	lr

08006918 <gsl_vector_uchar_const_view_array_with_stride>:
{
 8006918:	b538      	push	{r3, r4, r5, lr}
 800691a:	4604      	mov	r4, r0
  if (stride == 0)
 800691c:	4615      	mov	r5, r2
 800691e:	b13a      	cbz	r2, 8006930 <gsl_vector_uchar_const_view_array_with_stride+0x18>
    return view;
 8006920:	2200      	movs	r2, #0
 8006922:	e9c0 3500 	strd	r3, r5, [r0]
 8006926:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800692a:	6102      	str	r2, [r0, #16]
}
 800692c:	4620      	mov	r0, r4
 800692e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006930:	4906      	ldr	r1, [pc, #24]	; (800694c <gsl_vector_uchar_const_view_array_with_stride+0x34>)
 8006932:	4807      	ldr	r0, [pc, #28]	; (8006950 <gsl_vector_uchar_const_view_array_with_stride+0x38>)
 8006934:	2304      	movs	r3, #4
 8006936:	2230      	movs	r2, #48	; 0x30
 8006938:	f7fb ff92 	bl	8002860 <gsl_error>
 800693c:	e9c4 5500 	strd	r5, r5, [r4]
 8006940:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006944:	6125      	str	r5, [r4, #16]
}
 8006946:	4620      	mov	r0, r4
 8006948:	bd38      	pop	{r3, r4, r5, pc}
 800694a:	bf00      	nop
 800694c:	08030514 	.word	0x08030514
 8006950:	08030524 	.word	0x08030524

08006954 <gsl_vector_char_const_view_array>:
{
 8006954:	b430      	push	{r4, r5}
    return view;
 8006956:	2501      	movs	r5, #1
 8006958:	2400      	movs	r4, #0
 800695a:	e9c0 5101 	strd	r5, r1, [r0, #4]
 800695e:	e9c0 4403 	strd	r4, r4, [r0, #12]
 8006962:	6002      	str	r2, [r0, #0]
}
 8006964:	bc30      	pop	{r4, r5}
 8006966:	4770      	bx	lr

08006968 <gsl_vector_char_const_view_array_with_stride>:
{
 8006968:	b538      	push	{r3, r4, r5, lr}
 800696a:	4604      	mov	r4, r0
  if (stride == 0)
 800696c:	4615      	mov	r5, r2
 800696e:	b13a      	cbz	r2, 8006980 <gsl_vector_char_const_view_array_with_stride+0x18>
    return view;
 8006970:	2200      	movs	r2, #0
 8006972:	e9c0 3500 	strd	r3, r5, [r0]
 8006976:	e9c0 1202 	strd	r1, r2, [r0, #8]
 800697a:	6102      	str	r2, [r0, #16]
}
 800697c:	4620      	mov	r0, r4
 800697e:	bd38      	pop	{r3, r4, r5, pc}
      GSL_ERROR_VAL ("stride must be positive integer", 
 8006980:	4906      	ldr	r1, [pc, #24]	; (800699c <gsl_vector_char_const_view_array_with_stride+0x34>)
 8006982:	4807      	ldr	r0, [pc, #28]	; (80069a0 <gsl_vector_char_const_view_array_with_stride+0x38>)
 8006984:	2304      	movs	r3, #4
 8006986:	2230      	movs	r2, #48	; 0x30
 8006988:	f7fb ff6a 	bl	8002860 <gsl_error>
 800698c:	e9c4 5500 	strd	r5, r5, [r4]
 8006990:	e9c4 5502 	strd	r5, r5, [r4, #8]
 8006994:	6125      	str	r5, [r4, #16]
}
 8006996:	4620      	mov	r0, r4
 8006998:	bd38      	pop	{r3, r4, r5, pc}
 800699a:	bf00      	nop
 800699c:	08030514 	.word	0x08030514
 80069a0:	08030524 	.word	0x08030524

080069a4 <gsl_block_complex_long_double_alloc>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

TYPE (gsl_block) *
FUNCTION (gsl_block, alloc) (const size_t n)
{
 80069a4:	b570      	push	{r4, r5, r6, lr}
 80069a6:	4605      	mov	r5, r0
  TYPE (gsl_block) * b;

  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 80069a8:	2008      	movs	r0, #8
 80069aa:	f028 fcbd 	bl	802f328 <malloc>

  if (b == 0)
 80069ae:	4604      	mov	r4, r0
 80069b0:	b140      	cbz	r0, 80069c4 <gsl_block_complex_long_double_alloc+0x20>
    {
      GSL_ERROR_VAL ("failed to allocate space for block struct",
                        GSL_ENOMEM, 0);
    }

  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 80069b2:	0128      	lsls	r0, r5, #4
 80069b4:	f028 fcb8 	bl	802f328 <malloc>
 80069b8:	4606      	mov	r6, r0
 80069ba:	6060      	str	r0, [r4, #4]

  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80069bc:	b148      	cbz	r0, 80069d2 <gsl_block_complex_long_double_alloc+0x2e>

      GSL_ERROR_VAL ("failed to allocate space for block data",
                        GSL_ENOMEM, 0);
    }

  b->size = n;
 80069be:	6025      	str	r5, [r4, #0]

  return b;
}
 80069c0:	4620      	mov	r0, r4
 80069c2:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 80069c4:	4909      	ldr	r1, [pc, #36]	; (80069ec <gsl_block_complex_long_double_alloc+0x48>)
 80069c6:	480a      	ldr	r0, [pc, #40]	; (80069f0 <gsl_block_complex_long_double_alloc+0x4c>)
 80069c8:	2308      	movs	r3, #8
 80069ca:	221d      	movs	r2, #29
 80069cc:	f7fb ff48 	bl	8002860 <gsl_error>
 80069d0:	e7f6      	b.n	80069c0 <gsl_block_complex_long_double_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80069d2:	2d00      	cmp	r5, #0
 80069d4:	d0f3      	beq.n	80069be <gsl_block_complex_long_double_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 80069d6:	4620      	mov	r0, r4
 80069d8:	f028 fcae 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 80069dc:	4903      	ldr	r1, [pc, #12]	; (80069ec <gsl_block_complex_long_double_alloc+0x48>)
 80069de:	4805      	ldr	r0, [pc, #20]	; (80069f4 <gsl_block_complex_long_double_alloc+0x50>)
 80069e0:	2308      	movs	r3, #8
 80069e2:	2227      	movs	r2, #39	; 0x27
 80069e4:	4634      	mov	r4, r6
 80069e6:	f7fb ff3b 	bl	8002860 <gsl_error>
 80069ea:	e7e9      	b.n	80069c0 <gsl_block_complex_long_double_alloc+0x1c>
 80069ec:	08030220 	.word	0x08030220
 80069f0:	08030544 	.word	0x08030544
 80069f4:	08030570 	.word	0x08030570

080069f8 <gsl_block_complex_long_double_calloc>:

TYPE (gsl_block) *
FUNCTION (gsl_block, calloc) (const size_t n)
{
 80069f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80069fa:	4606      	mov	r6, r0
  size_t i;

  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 80069fc:	f7ff ffd2 	bl	80069a4 <gsl_block_complex_long_double_alloc>

  if (b == 0)
 8006a00:	4605      	mov	r5, r0
 8006a02:	b178      	cbz	r0, 8006a24 <gsl_block_complex_long_double_calloc+0x2c>
    return 0;

  /* initialize block to zero; the memset call takes care of padding bytes */
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006a04:	0134      	lsls	r4, r6, #4
 8006a06:	6840      	ldr	r0, [r0, #4]
 8006a08:	4622      	mov	r2, r4
 8006a0a:	2100      	movs	r1, #0
 8006a0c:	f028 fc9c 	bl	802f348 <memset>

  for (i = 0; i < MULTIPLICITY * n; i++)
 8006a10:	0073      	lsls	r3, r6, #1
 8006a12:	d007      	beq.n	8006a24 <gsl_block_complex_long_double_calloc+0x2c>
 8006a14:	686b      	ldr	r3, [r5, #4]
    {
      b->data[i] = 0;
 8006a16:	2600      	movs	r6, #0
 8006a18:	2700      	movs	r7, #0
 8006a1a:	18e2      	adds	r2, r4, r3
 8006a1c:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006a20:	4293      	cmp	r3, r2
 8006a22:	d1fb      	bne.n	8006a1c <gsl_block_complex_long_double_calloc+0x24>
    }

  return b;
}
 8006a24:	4628      	mov	r0, r5
 8006a26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006a28 <gsl_block_complex_long_double_free>:

void
FUNCTION (gsl_block, free) (TYPE (gsl_block) * b)
{
  RETURN_IF_NULL (b);
 8006a28:	b148      	cbz	r0, 8006a3e <gsl_block_complex_long_double_free+0x16>
{
 8006a2a:	b510      	push	{r4, lr}
 8006a2c:	4604      	mov	r4, r0
  free (b->data);
 8006a2e:	6840      	ldr	r0, [r0, #4]
 8006a30:	f028 fc82 	bl	802f338 <free>
  free (b);
 8006a34:	4620      	mov	r0, r4
}
 8006a36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006a3a:	f028 bc7d 	b.w	802f338 <free>
 8006a3e:	4770      	bx	lr

08006a40 <gsl_block_complex_alloc>:
{
 8006a40:	b570      	push	{r4, r5, r6, lr}
 8006a42:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006a44:	2008      	movs	r0, #8
 8006a46:	f028 fc6f 	bl	802f328 <malloc>
  if (b == 0)
 8006a4a:	4604      	mov	r4, r0
 8006a4c:	b140      	cbz	r0, 8006a60 <gsl_block_complex_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006a4e:	0128      	lsls	r0, r5, #4
 8006a50:	f028 fc6a 	bl	802f328 <malloc>
 8006a54:	4606      	mov	r6, r0
 8006a56:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006a58:	b148      	cbz	r0, 8006a6e <gsl_block_complex_alloc+0x2e>
  b->size = n;
 8006a5a:	6025      	str	r5, [r4, #0]
}
 8006a5c:	4620      	mov	r0, r4
 8006a5e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006a60:	4909      	ldr	r1, [pc, #36]	; (8006a88 <gsl_block_complex_alloc+0x48>)
 8006a62:	480a      	ldr	r0, [pc, #40]	; (8006a8c <gsl_block_complex_alloc+0x4c>)
 8006a64:	2308      	movs	r3, #8
 8006a66:	221d      	movs	r2, #29
 8006a68:	f7fb fefa 	bl	8002860 <gsl_error>
 8006a6c:	e7f6      	b.n	8006a5c <gsl_block_complex_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006a6e:	2d00      	cmp	r5, #0
 8006a70:	d0f3      	beq.n	8006a5a <gsl_block_complex_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006a72:	4620      	mov	r0, r4
 8006a74:	f028 fc60 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006a78:	4903      	ldr	r1, [pc, #12]	; (8006a88 <gsl_block_complex_alloc+0x48>)
 8006a7a:	4805      	ldr	r0, [pc, #20]	; (8006a90 <gsl_block_complex_alloc+0x50>)
 8006a7c:	2308      	movs	r3, #8
 8006a7e:	2227      	movs	r2, #39	; 0x27
 8006a80:	4634      	mov	r4, r6
 8006a82:	f7fb feed 	bl	8002860 <gsl_error>
 8006a86:	e7e9      	b.n	8006a5c <gsl_block_complex_alloc+0x1c>
 8006a88:	08030220 	.word	0x08030220
 8006a8c:	08030544 	.word	0x08030544
 8006a90:	08030570 	.word	0x08030570

08006a94 <gsl_block_complex_calloc>:
{
 8006a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006a96:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006a98:	f7ff ffd2 	bl	8006a40 <gsl_block_complex_alloc>
  if (b == 0)
 8006a9c:	4605      	mov	r5, r0
 8006a9e:	b178      	cbz	r0, 8006ac0 <gsl_block_complex_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006aa0:	0134      	lsls	r4, r6, #4
 8006aa2:	6840      	ldr	r0, [r0, #4]
 8006aa4:	4622      	mov	r2, r4
 8006aa6:	2100      	movs	r1, #0
 8006aa8:	f028 fc4e 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006aac:	0073      	lsls	r3, r6, #1
 8006aae:	d007      	beq.n	8006ac0 <gsl_block_complex_calloc+0x2c>
 8006ab0:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8006ab2:	2600      	movs	r6, #0
 8006ab4:	2700      	movs	r7, #0
 8006ab6:	18e2      	adds	r2, r4, r3
 8006ab8:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006abc:	4293      	cmp	r3, r2
 8006abe:	d1fb      	bne.n	8006ab8 <gsl_block_complex_calloc+0x24>
}
 8006ac0:	4628      	mov	r0, r5
 8006ac2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006ac4 <gsl_block_complex_free>:
  RETURN_IF_NULL (b);
 8006ac4:	b148      	cbz	r0, 8006ada <gsl_block_complex_free+0x16>
{
 8006ac6:	b510      	push	{r4, lr}
 8006ac8:	4604      	mov	r4, r0
  free (b->data);
 8006aca:	6840      	ldr	r0, [r0, #4]
 8006acc:	f028 fc34 	bl	802f338 <free>
  free (b);
 8006ad0:	4620      	mov	r0, r4
}
 8006ad2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006ad6:	f028 bc2f 	b.w	802f338 <free>
 8006ada:	4770      	bx	lr

08006adc <gsl_block_complex_float_alloc>:
{
 8006adc:	b570      	push	{r4, r5, r6, lr}
 8006ade:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006ae0:	2008      	movs	r0, #8
 8006ae2:	f028 fc21 	bl	802f328 <malloc>
  if (b == 0)
 8006ae6:	4604      	mov	r4, r0
 8006ae8:	b140      	cbz	r0, 8006afc <gsl_block_complex_float_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006aea:	00e8      	lsls	r0, r5, #3
 8006aec:	f028 fc1c 	bl	802f328 <malloc>
 8006af0:	4606      	mov	r6, r0
 8006af2:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006af4:	b148      	cbz	r0, 8006b0a <gsl_block_complex_float_alloc+0x2e>
  b->size = n;
 8006af6:	6025      	str	r5, [r4, #0]
}
 8006af8:	4620      	mov	r0, r4
 8006afa:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006afc:	4909      	ldr	r1, [pc, #36]	; (8006b24 <gsl_block_complex_float_alloc+0x48>)
 8006afe:	480a      	ldr	r0, [pc, #40]	; (8006b28 <gsl_block_complex_float_alloc+0x4c>)
 8006b00:	2308      	movs	r3, #8
 8006b02:	221d      	movs	r2, #29
 8006b04:	f7fb feac 	bl	8002860 <gsl_error>
 8006b08:	e7f6      	b.n	8006af8 <gsl_block_complex_float_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006b0a:	2d00      	cmp	r5, #0
 8006b0c:	d0f3      	beq.n	8006af6 <gsl_block_complex_float_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006b0e:	4620      	mov	r0, r4
 8006b10:	f028 fc12 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006b14:	4903      	ldr	r1, [pc, #12]	; (8006b24 <gsl_block_complex_float_alloc+0x48>)
 8006b16:	4805      	ldr	r0, [pc, #20]	; (8006b2c <gsl_block_complex_float_alloc+0x50>)
 8006b18:	2308      	movs	r3, #8
 8006b1a:	2227      	movs	r2, #39	; 0x27
 8006b1c:	4634      	mov	r4, r6
 8006b1e:	f7fb fe9f 	bl	8002860 <gsl_error>
 8006b22:	e7e9      	b.n	8006af8 <gsl_block_complex_float_alloc+0x1c>
 8006b24:	08030220 	.word	0x08030220
 8006b28:	08030544 	.word	0x08030544
 8006b2c:	08030570 	.word	0x08030570

08006b30 <gsl_block_complex_float_calloc>:
{
 8006b30:	b570      	push	{r4, r5, r6, lr}
 8006b32:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006b34:	f7ff ffd2 	bl	8006adc <gsl_block_complex_float_alloc>
  if (b == 0)
 8006b38:	4605      	mov	r5, r0
 8006b3a:	b170      	cbz	r0, 8006b5a <gsl_block_complex_float_calloc+0x2a>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006b3c:	00f4      	lsls	r4, r6, #3
 8006b3e:	6840      	ldr	r0, [r0, #4]
 8006b40:	4622      	mov	r2, r4
 8006b42:	2100      	movs	r1, #0
 8006b44:	f028 fc00 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006b48:	0073      	lsls	r3, r6, #1
 8006b4a:	d006      	beq.n	8006b5a <gsl_block_complex_float_calloc+0x2a>
 8006b4c:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8006b4e:	2100      	movs	r1, #0
 8006b50:	18e2      	adds	r2, r4, r3
 8006b52:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006b56:	4293      	cmp	r3, r2
 8006b58:	d1fb      	bne.n	8006b52 <gsl_block_complex_float_calloc+0x22>
}
 8006b5a:	4628      	mov	r0, r5
 8006b5c:	bd70      	pop	{r4, r5, r6, pc}
 8006b5e:	bf00      	nop

08006b60 <gsl_block_complex_float_free>:
  RETURN_IF_NULL (b);
 8006b60:	b148      	cbz	r0, 8006b76 <gsl_block_complex_float_free+0x16>
{
 8006b62:	b510      	push	{r4, lr}
 8006b64:	4604      	mov	r4, r0
  free (b->data);
 8006b66:	6840      	ldr	r0, [r0, #4]
 8006b68:	f028 fbe6 	bl	802f338 <free>
  free (b);
 8006b6c:	4620      	mov	r0, r4
}
 8006b6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006b72:	f028 bbe1 	b.w	802f338 <free>
 8006b76:	4770      	bx	lr

08006b78 <gsl_block_long_double_alloc>:
{
 8006b78:	b570      	push	{r4, r5, r6, lr}
 8006b7a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006b7c:	2008      	movs	r0, #8
 8006b7e:	f028 fbd3 	bl	802f328 <malloc>
  if (b == 0)
 8006b82:	4604      	mov	r4, r0
 8006b84:	b140      	cbz	r0, 8006b98 <gsl_block_long_double_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006b86:	00e8      	lsls	r0, r5, #3
 8006b88:	f028 fbce 	bl	802f328 <malloc>
 8006b8c:	4606      	mov	r6, r0
 8006b8e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006b90:	b148      	cbz	r0, 8006ba6 <gsl_block_long_double_alloc+0x2e>
  b->size = n;
 8006b92:	6025      	str	r5, [r4, #0]
}
 8006b94:	4620      	mov	r0, r4
 8006b96:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006b98:	4909      	ldr	r1, [pc, #36]	; (8006bc0 <gsl_block_long_double_alloc+0x48>)
 8006b9a:	480a      	ldr	r0, [pc, #40]	; (8006bc4 <gsl_block_long_double_alloc+0x4c>)
 8006b9c:	2308      	movs	r3, #8
 8006b9e:	221d      	movs	r2, #29
 8006ba0:	f7fb fe5e 	bl	8002860 <gsl_error>
 8006ba4:	e7f6      	b.n	8006b94 <gsl_block_long_double_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006ba6:	2d00      	cmp	r5, #0
 8006ba8:	d0f3      	beq.n	8006b92 <gsl_block_long_double_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006baa:	4620      	mov	r0, r4
 8006bac:	f028 fbc4 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006bb0:	4903      	ldr	r1, [pc, #12]	; (8006bc0 <gsl_block_long_double_alloc+0x48>)
 8006bb2:	4805      	ldr	r0, [pc, #20]	; (8006bc8 <gsl_block_long_double_alloc+0x50>)
 8006bb4:	2308      	movs	r3, #8
 8006bb6:	2227      	movs	r2, #39	; 0x27
 8006bb8:	4634      	mov	r4, r6
 8006bba:	f7fb fe51 	bl	8002860 <gsl_error>
 8006bbe:	e7e9      	b.n	8006b94 <gsl_block_long_double_alloc+0x1c>
 8006bc0:	08030220 	.word	0x08030220
 8006bc4:	08030544 	.word	0x08030544
 8006bc8:	08030570 	.word	0x08030570

08006bcc <gsl_block_long_double_calloc>:
{
 8006bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006bce:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006bd0:	f7ff ffd2 	bl	8006b78 <gsl_block_long_double_alloc>
  if (b == 0)
 8006bd4:	4605      	mov	r5, r0
 8006bd6:	b170      	cbz	r0, 8006bf6 <gsl_block_long_double_calloc+0x2a>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006bd8:	00f4      	lsls	r4, r6, #3
 8006bda:	6840      	ldr	r0, [r0, #4]
 8006bdc:	4622      	mov	r2, r4
 8006bde:	2100      	movs	r1, #0
 8006be0:	f028 fbb2 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006be4:	b13e      	cbz	r6, 8006bf6 <gsl_block_long_double_calloc+0x2a>
 8006be6:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8006be8:	2600      	movs	r6, #0
 8006bea:	2700      	movs	r7, #0
 8006bec:	18e2      	adds	r2, r4, r3
 8006bee:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006bf2:	4293      	cmp	r3, r2
 8006bf4:	d1fb      	bne.n	8006bee <gsl_block_long_double_calloc+0x22>
}
 8006bf6:	4628      	mov	r0, r5
 8006bf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006bfa:	bf00      	nop

08006bfc <gsl_block_long_double_free>:
  RETURN_IF_NULL (b);
 8006bfc:	b148      	cbz	r0, 8006c12 <gsl_block_long_double_free+0x16>
{
 8006bfe:	b510      	push	{r4, lr}
 8006c00:	4604      	mov	r4, r0
  free (b->data);
 8006c02:	6840      	ldr	r0, [r0, #4]
 8006c04:	f028 fb98 	bl	802f338 <free>
  free (b);
 8006c08:	4620      	mov	r0, r4
}
 8006c0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006c0e:	f028 bb93 	b.w	802f338 <free>
 8006c12:	4770      	bx	lr

08006c14 <gsl_block_alloc>:
{
 8006c14:	b570      	push	{r4, r5, r6, lr}
 8006c16:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006c18:	2008      	movs	r0, #8
 8006c1a:	f028 fb85 	bl	802f328 <malloc>
  if (b == 0)
 8006c1e:	4604      	mov	r4, r0
 8006c20:	b140      	cbz	r0, 8006c34 <gsl_block_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006c22:	00e8      	lsls	r0, r5, #3
 8006c24:	f028 fb80 	bl	802f328 <malloc>
 8006c28:	4606      	mov	r6, r0
 8006c2a:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006c2c:	b148      	cbz	r0, 8006c42 <gsl_block_alloc+0x2e>
  b->size = n;
 8006c2e:	6025      	str	r5, [r4, #0]
}
 8006c30:	4620      	mov	r0, r4
 8006c32:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006c34:	4909      	ldr	r1, [pc, #36]	; (8006c5c <gsl_block_alloc+0x48>)
 8006c36:	480a      	ldr	r0, [pc, #40]	; (8006c60 <gsl_block_alloc+0x4c>)
 8006c38:	2308      	movs	r3, #8
 8006c3a:	221d      	movs	r2, #29
 8006c3c:	f7fb fe10 	bl	8002860 <gsl_error>
 8006c40:	e7f6      	b.n	8006c30 <gsl_block_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006c42:	2d00      	cmp	r5, #0
 8006c44:	d0f3      	beq.n	8006c2e <gsl_block_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006c46:	4620      	mov	r0, r4
 8006c48:	f028 fb76 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006c4c:	4903      	ldr	r1, [pc, #12]	; (8006c5c <gsl_block_alloc+0x48>)
 8006c4e:	4805      	ldr	r0, [pc, #20]	; (8006c64 <gsl_block_alloc+0x50>)
 8006c50:	2308      	movs	r3, #8
 8006c52:	2227      	movs	r2, #39	; 0x27
 8006c54:	4634      	mov	r4, r6
 8006c56:	f7fb fe03 	bl	8002860 <gsl_error>
 8006c5a:	e7e9      	b.n	8006c30 <gsl_block_alloc+0x1c>
 8006c5c:	08030220 	.word	0x08030220
 8006c60:	08030544 	.word	0x08030544
 8006c64:	08030570 	.word	0x08030570

08006c68 <gsl_block_calloc>:
{
 8006c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006c6a:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006c6c:	f7ff ffd2 	bl	8006c14 <gsl_block_alloc>
  if (b == 0)
 8006c70:	4605      	mov	r5, r0
 8006c72:	b170      	cbz	r0, 8006c92 <gsl_block_calloc+0x2a>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006c74:	00f4      	lsls	r4, r6, #3
 8006c76:	6840      	ldr	r0, [r0, #4]
 8006c78:	4622      	mov	r2, r4
 8006c7a:	2100      	movs	r1, #0
 8006c7c:	f028 fb64 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006c80:	b13e      	cbz	r6, 8006c92 <gsl_block_calloc+0x2a>
 8006c82:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8006c84:	2600      	movs	r6, #0
 8006c86:	2700      	movs	r7, #0
 8006c88:	18e2      	adds	r2, r4, r3
 8006c8a:	e8e3 6702 	strd	r6, r7, [r3], #8
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006c8e:	4293      	cmp	r3, r2
 8006c90:	d1fb      	bne.n	8006c8a <gsl_block_calloc+0x22>
}
 8006c92:	4628      	mov	r0, r5
 8006c94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006c96:	bf00      	nop

08006c98 <gsl_block_free>:
  RETURN_IF_NULL (b);
 8006c98:	b148      	cbz	r0, 8006cae <gsl_block_free+0x16>
{
 8006c9a:	b510      	push	{r4, lr}
 8006c9c:	4604      	mov	r4, r0
  free (b->data);
 8006c9e:	6840      	ldr	r0, [r0, #4]
 8006ca0:	f028 fb4a 	bl	802f338 <free>
  free (b);
 8006ca4:	4620      	mov	r0, r4
}
 8006ca6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006caa:	f028 bb45 	b.w	802f338 <free>
 8006cae:	4770      	bx	lr

08006cb0 <gsl_block_float_alloc>:
{
 8006cb0:	b570      	push	{r4, r5, r6, lr}
 8006cb2:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006cb4:	2008      	movs	r0, #8
 8006cb6:	f028 fb37 	bl	802f328 <malloc>
  if (b == 0)
 8006cba:	4604      	mov	r4, r0
 8006cbc:	b140      	cbz	r0, 8006cd0 <gsl_block_float_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006cbe:	00a8      	lsls	r0, r5, #2
 8006cc0:	f028 fb32 	bl	802f328 <malloc>
 8006cc4:	4606      	mov	r6, r0
 8006cc6:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006cc8:	b148      	cbz	r0, 8006cde <gsl_block_float_alloc+0x2e>
  b->size = n;
 8006cca:	6025      	str	r5, [r4, #0]
}
 8006ccc:	4620      	mov	r0, r4
 8006cce:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006cd0:	4909      	ldr	r1, [pc, #36]	; (8006cf8 <gsl_block_float_alloc+0x48>)
 8006cd2:	480a      	ldr	r0, [pc, #40]	; (8006cfc <gsl_block_float_alloc+0x4c>)
 8006cd4:	2308      	movs	r3, #8
 8006cd6:	221d      	movs	r2, #29
 8006cd8:	f7fb fdc2 	bl	8002860 <gsl_error>
 8006cdc:	e7f6      	b.n	8006ccc <gsl_block_float_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006cde:	2d00      	cmp	r5, #0
 8006ce0:	d0f3      	beq.n	8006cca <gsl_block_float_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006ce2:	4620      	mov	r0, r4
 8006ce4:	f028 fb28 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006ce8:	4903      	ldr	r1, [pc, #12]	; (8006cf8 <gsl_block_float_alloc+0x48>)
 8006cea:	4805      	ldr	r0, [pc, #20]	; (8006d00 <gsl_block_float_alloc+0x50>)
 8006cec:	2308      	movs	r3, #8
 8006cee:	2227      	movs	r2, #39	; 0x27
 8006cf0:	4634      	mov	r4, r6
 8006cf2:	f7fb fdb5 	bl	8002860 <gsl_error>
 8006cf6:	e7e9      	b.n	8006ccc <gsl_block_float_alloc+0x1c>
 8006cf8:	08030220 	.word	0x08030220
 8006cfc:	08030544 	.word	0x08030544
 8006d00:	08030570 	.word	0x08030570

08006d04 <gsl_block_float_calloc>:
{
 8006d04:	b570      	push	{r4, r5, r6, lr}
 8006d06:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006d08:	f7ff ffd2 	bl	8006cb0 <gsl_block_float_alloc>
  if (b == 0)
 8006d0c:	4605      	mov	r5, r0
 8006d0e:	b168      	cbz	r0, 8006d2c <gsl_block_float_calloc+0x28>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006d10:	00b4      	lsls	r4, r6, #2
 8006d12:	6840      	ldr	r0, [r0, #4]
 8006d14:	4622      	mov	r2, r4
 8006d16:	2100      	movs	r1, #0
 8006d18:	f028 fb16 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006d1c:	b136      	cbz	r6, 8006d2c <gsl_block_float_calloc+0x28>
 8006d1e:	686b      	ldr	r3, [r5, #4]
      b->data[i] = 0;
 8006d20:	2100      	movs	r1, #0
 8006d22:	18e2      	adds	r2, r4, r3
 8006d24:	f843 1b04 	str.w	r1, [r3], #4
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006d28:	4293      	cmp	r3, r2
 8006d2a:	d1fb      	bne.n	8006d24 <gsl_block_float_calloc+0x20>
}
 8006d2c:	4628      	mov	r0, r5
 8006d2e:	bd70      	pop	{r4, r5, r6, pc}

08006d30 <gsl_block_float_free>:
  RETURN_IF_NULL (b);
 8006d30:	b148      	cbz	r0, 8006d46 <gsl_block_float_free+0x16>
{
 8006d32:	b510      	push	{r4, lr}
 8006d34:	4604      	mov	r4, r0
  free (b->data);
 8006d36:	6840      	ldr	r0, [r0, #4]
 8006d38:	f028 fafe 	bl	802f338 <free>
  free (b);
 8006d3c:	4620      	mov	r0, r4
}
 8006d3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006d42:	f028 baf9 	b.w	802f338 <free>
 8006d46:	4770      	bx	lr

08006d48 <gsl_block_ulong_alloc>:
{
 8006d48:	b570      	push	{r4, r5, r6, lr}
 8006d4a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006d4c:	2008      	movs	r0, #8
 8006d4e:	f028 faeb 	bl	802f328 <malloc>
  if (b == 0)
 8006d52:	4604      	mov	r4, r0
 8006d54:	b140      	cbz	r0, 8006d68 <gsl_block_ulong_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006d56:	00a8      	lsls	r0, r5, #2
 8006d58:	f028 fae6 	bl	802f328 <malloc>
 8006d5c:	4606      	mov	r6, r0
 8006d5e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006d60:	b148      	cbz	r0, 8006d76 <gsl_block_ulong_alloc+0x2e>
  b->size = n;
 8006d62:	6025      	str	r5, [r4, #0]
}
 8006d64:	4620      	mov	r0, r4
 8006d66:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006d68:	4909      	ldr	r1, [pc, #36]	; (8006d90 <gsl_block_ulong_alloc+0x48>)
 8006d6a:	480a      	ldr	r0, [pc, #40]	; (8006d94 <gsl_block_ulong_alloc+0x4c>)
 8006d6c:	2308      	movs	r3, #8
 8006d6e:	221d      	movs	r2, #29
 8006d70:	f7fb fd76 	bl	8002860 <gsl_error>
 8006d74:	e7f6      	b.n	8006d64 <gsl_block_ulong_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006d76:	2d00      	cmp	r5, #0
 8006d78:	d0f3      	beq.n	8006d62 <gsl_block_ulong_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006d7a:	4620      	mov	r0, r4
 8006d7c:	f028 fadc 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006d80:	4903      	ldr	r1, [pc, #12]	; (8006d90 <gsl_block_ulong_alloc+0x48>)
 8006d82:	4805      	ldr	r0, [pc, #20]	; (8006d98 <gsl_block_ulong_alloc+0x50>)
 8006d84:	2308      	movs	r3, #8
 8006d86:	2227      	movs	r2, #39	; 0x27
 8006d88:	4634      	mov	r4, r6
 8006d8a:	f7fb fd69 	bl	8002860 <gsl_error>
 8006d8e:	e7e9      	b.n	8006d64 <gsl_block_ulong_alloc+0x1c>
 8006d90:	08030220 	.word	0x08030220
 8006d94:	08030544 	.word	0x08030544
 8006d98:	08030570 	.word	0x08030570

08006d9c <gsl_block_ulong_calloc>:
{
 8006d9c:	b570      	push	{r4, r5, r6, lr}
 8006d9e:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006da0:	f7ff ffd2 	bl	8006d48 <gsl_block_ulong_alloc>
  if (b == 0)
 8006da4:	4605      	mov	r5, r0
 8006da6:	b178      	cbz	r0, 8006dc8 <gsl_block_ulong_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006da8:	00b4      	lsls	r4, r6, #2
 8006daa:	6840      	ldr	r0, [r0, #4]
 8006dac:	4622      	mov	r2, r4
 8006dae:	2100      	movs	r1, #0
 8006db0:	f028 faca 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006db4:	b146      	cbz	r6, 8006dc8 <gsl_block_ulong_calloc+0x2c>
      b->data[i] = 0;
 8006db6:	686b      	ldr	r3, [r5, #4]
 8006db8:	1f22      	subs	r2, r4, #4
 8006dba:	441a      	add	r2, r3
 8006dbc:	2100      	movs	r1, #0
 8006dbe:	3b04      	subs	r3, #4
 8006dc0:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006dc4:	4293      	cmp	r3, r2
 8006dc6:	d1fb      	bne.n	8006dc0 <gsl_block_ulong_calloc+0x24>
}
 8006dc8:	4628      	mov	r0, r5
 8006dca:	bd70      	pop	{r4, r5, r6, pc}

08006dcc <gsl_block_ulong_free>:
  RETURN_IF_NULL (b);
 8006dcc:	b148      	cbz	r0, 8006de2 <gsl_block_ulong_free+0x16>
{
 8006dce:	b510      	push	{r4, lr}
 8006dd0:	4604      	mov	r4, r0
  free (b->data);
 8006dd2:	6840      	ldr	r0, [r0, #4]
 8006dd4:	f028 fab0 	bl	802f338 <free>
  free (b);
 8006dd8:	4620      	mov	r0, r4
}
 8006dda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006dde:	f028 baab 	b.w	802f338 <free>
 8006de2:	4770      	bx	lr

08006de4 <gsl_block_long_alloc>:
{
 8006de4:	b570      	push	{r4, r5, r6, lr}
 8006de6:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006de8:	2008      	movs	r0, #8
 8006dea:	f028 fa9d 	bl	802f328 <malloc>
  if (b == 0)
 8006dee:	4604      	mov	r4, r0
 8006df0:	b140      	cbz	r0, 8006e04 <gsl_block_long_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006df2:	00a8      	lsls	r0, r5, #2
 8006df4:	f028 fa98 	bl	802f328 <malloc>
 8006df8:	4606      	mov	r6, r0
 8006dfa:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006dfc:	b148      	cbz	r0, 8006e12 <gsl_block_long_alloc+0x2e>
  b->size = n;
 8006dfe:	6025      	str	r5, [r4, #0]
}
 8006e00:	4620      	mov	r0, r4
 8006e02:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006e04:	4909      	ldr	r1, [pc, #36]	; (8006e2c <gsl_block_long_alloc+0x48>)
 8006e06:	480a      	ldr	r0, [pc, #40]	; (8006e30 <gsl_block_long_alloc+0x4c>)
 8006e08:	2308      	movs	r3, #8
 8006e0a:	221d      	movs	r2, #29
 8006e0c:	f7fb fd28 	bl	8002860 <gsl_error>
 8006e10:	e7f6      	b.n	8006e00 <gsl_block_long_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006e12:	2d00      	cmp	r5, #0
 8006e14:	d0f3      	beq.n	8006dfe <gsl_block_long_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006e16:	4620      	mov	r0, r4
 8006e18:	f028 fa8e 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006e1c:	4903      	ldr	r1, [pc, #12]	; (8006e2c <gsl_block_long_alloc+0x48>)
 8006e1e:	4805      	ldr	r0, [pc, #20]	; (8006e34 <gsl_block_long_alloc+0x50>)
 8006e20:	2308      	movs	r3, #8
 8006e22:	2227      	movs	r2, #39	; 0x27
 8006e24:	4634      	mov	r4, r6
 8006e26:	f7fb fd1b 	bl	8002860 <gsl_error>
 8006e2a:	e7e9      	b.n	8006e00 <gsl_block_long_alloc+0x1c>
 8006e2c:	08030220 	.word	0x08030220
 8006e30:	08030544 	.word	0x08030544
 8006e34:	08030570 	.word	0x08030570

08006e38 <gsl_block_long_calloc>:
{
 8006e38:	b570      	push	{r4, r5, r6, lr}
 8006e3a:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006e3c:	f7ff ffd2 	bl	8006de4 <gsl_block_long_alloc>
  if (b == 0)
 8006e40:	4605      	mov	r5, r0
 8006e42:	b178      	cbz	r0, 8006e64 <gsl_block_long_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006e44:	00b4      	lsls	r4, r6, #2
 8006e46:	6840      	ldr	r0, [r0, #4]
 8006e48:	4622      	mov	r2, r4
 8006e4a:	2100      	movs	r1, #0
 8006e4c:	f028 fa7c 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006e50:	b146      	cbz	r6, 8006e64 <gsl_block_long_calloc+0x2c>
      b->data[i] = 0;
 8006e52:	686b      	ldr	r3, [r5, #4]
 8006e54:	1f22      	subs	r2, r4, #4
 8006e56:	441a      	add	r2, r3
 8006e58:	2100      	movs	r1, #0
 8006e5a:	3b04      	subs	r3, #4
 8006e5c:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006e60:	4293      	cmp	r3, r2
 8006e62:	d1fb      	bne.n	8006e5c <gsl_block_long_calloc+0x24>
}
 8006e64:	4628      	mov	r0, r5
 8006e66:	bd70      	pop	{r4, r5, r6, pc}

08006e68 <gsl_block_long_free>:
  RETURN_IF_NULL (b);
 8006e68:	b148      	cbz	r0, 8006e7e <gsl_block_long_free+0x16>
{
 8006e6a:	b510      	push	{r4, lr}
 8006e6c:	4604      	mov	r4, r0
  free (b->data);
 8006e6e:	6840      	ldr	r0, [r0, #4]
 8006e70:	f028 fa62 	bl	802f338 <free>
  free (b);
 8006e74:	4620      	mov	r0, r4
}
 8006e76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006e7a:	f028 ba5d 	b.w	802f338 <free>
 8006e7e:	4770      	bx	lr

08006e80 <gsl_block_uint_alloc>:
{
 8006e80:	b570      	push	{r4, r5, r6, lr}
 8006e82:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006e84:	2008      	movs	r0, #8
 8006e86:	f028 fa4f 	bl	802f328 <malloc>
  if (b == 0)
 8006e8a:	4604      	mov	r4, r0
 8006e8c:	b140      	cbz	r0, 8006ea0 <gsl_block_uint_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006e8e:	00a8      	lsls	r0, r5, #2
 8006e90:	f028 fa4a 	bl	802f328 <malloc>
 8006e94:	4606      	mov	r6, r0
 8006e96:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006e98:	b148      	cbz	r0, 8006eae <gsl_block_uint_alloc+0x2e>
  b->size = n;
 8006e9a:	6025      	str	r5, [r4, #0]
}
 8006e9c:	4620      	mov	r0, r4
 8006e9e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006ea0:	4909      	ldr	r1, [pc, #36]	; (8006ec8 <gsl_block_uint_alloc+0x48>)
 8006ea2:	480a      	ldr	r0, [pc, #40]	; (8006ecc <gsl_block_uint_alloc+0x4c>)
 8006ea4:	2308      	movs	r3, #8
 8006ea6:	221d      	movs	r2, #29
 8006ea8:	f7fb fcda 	bl	8002860 <gsl_error>
 8006eac:	e7f6      	b.n	8006e9c <gsl_block_uint_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006eae:	2d00      	cmp	r5, #0
 8006eb0:	d0f3      	beq.n	8006e9a <gsl_block_uint_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006eb2:	4620      	mov	r0, r4
 8006eb4:	f028 fa40 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006eb8:	4903      	ldr	r1, [pc, #12]	; (8006ec8 <gsl_block_uint_alloc+0x48>)
 8006eba:	4805      	ldr	r0, [pc, #20]	; (8006ed0 <gsl_block_uint_alloc+0x50>)
 8006ebc:	2308      	movs	r3, #8
 8006ebe:	2227      	movs	r2, #39	; 0x27
 8006ec0:	4634      	mov	r4, r6
 8006ec2:	f7fb fccd 	bl	8002860 <gsl_error>
 8006ec6:	e7e9      	b.n	8006e9c <gsl_block_uint_alloc+0x1c>
 8006ec8:	08030220 	.word	0x08030220
 8006ecc:	08030544 	.word	0x08030544
 8006ed0:	08030570 	.word	0x08030570

08006ed4 <gsl_block_uint_calloc>:
{
 8006ed4:	b570      	push	{r4, r5, r6, lr}
 8006ed6:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006ed8:	f7ff ffd2 	bl	8006e80 <gsl_block_uint_alloc>
  if (b == 0)
 8006edc:	4605      	mov	r5, r0
 8006ede:	b178      	cbz	r0, 8006f00 <gsl_block_uint_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006ee0:	00b4      	lsls	r4, r6, #2
 8006ee2:	6840      	ldr	r0, [r0, #4]
 8006ee4:	4622      	mov	r2, r4
 8006ee6:	2100      	movs	r1, #0
 8006ee8:	f028 fa2e 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006eec:	b146      	cbz	r6, 8006f00 <gsl_block_uint_calloc+0x2c>
      b->data[i] = 0;
 8006eee:	686b      	ldr	r3, [r5, #4]
 8006ef0:	1f22      	subs	r2, r4, #4
 8006ef2:	441a      	add	r2, r3
 8006ef4:	2100      	movs	r1, #0
 8006ef6:	3b04      	subs	r3, #4
 8006ef8:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006efc:	4293      	cmp	r3, r2
 8006efe:	d1fb      	bne.n	8006ef8 <gsl_block_uint_calloc+0x24>
}
 8006f00:	4628      	mov	r0, r5
 8006f02:	bd70      	pop	{r4, r5, r6, pc}

08006f04 <gsl_block_uint_free>:
  RETURN_IF_NULL (b);
 8006f04:	b148      	cbz	r0, 8006f1a <gsl_block_uint_free+0x16>
{
 8006f06:	b510      	push	{r4, lr}
 8006f08:	4604      	mov	r4, r0
  free (b->data);
 8006f0a:	6840      	ldr	r0, [r0, #4]
 8006f0c:	f028 fa14 	bl	802f338 <free>
  free (b);
 8006f10:	4620      	mov	r0, r4
}
 8006f12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006f16:	f028 ba0f 	b.w	802f338 <free>
 8006f1a:	4770      	bx	lr

08006f1c <gsl_block_int_alloc>:
{
 8006f1c:	b570      	push	{r4, r5, r6, lr}
 8006f1e:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006f20:	2008      	movs	r0, #8
 8006f22:	f028 fa01 	bl	802f328 <malloc>
  if (b == 0)
 8006f26:	4604      	mov	r4, r0
 8006f28:	b140      	cbz	r0, 8006f3c <gsl_block_int_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006f2a:	00a8      	lsls	r0, r5, #2
 8006f2c:	f028 f9fc 	bl	802f328 <malloc>
 8006f30:	4606      	mov	r6, r0
 8006f32:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006f34:	b148      	cbz	r0, 8006f4a <gsl_block_int_alloc+0x2e>
  b->size = n;
 8006f36:	6025      	str	r5, [r4, #0]
}
 8006f38:	4620      	mov	r0, r4
 8006f3a:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006f3c:	4909      	ldr	r1, [pc, #36]	; (8006f64 <gsl_block_int_alloc+0x48>)
 8006f3e:	480a      	ldr	r0, [pc, #40]	; (8006f68 <gsl_block_int_alloc+0x4c>)
 8006f40:	2308      	movs	r3, #8
 8006f42:	221d      	movs	r2, #29
 8006f44:	f7fb fc8c 	bl	8002860 <gsl_error>
 8006f48:	e7f6      	b.n	8006f38 <gsl_block_int_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006f4a:	2d00      	cmp	r5, #0
 8006f4c:	d0f3      	beq.n	8006f36 <gsl_block_int_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006f4e:	4620      	mov	r0, r4
 8006f50:	f028 f9f2 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006f54:	4903      	ldr	r1, [pc, #12]	; (8006f64 <gsl_block_int_alloc+0x48>)
 8006f56:	4805      	ldr	r0, [pc, #20]	; (8006f6c <gsl_block_int_alloc+0x50>)
 8006f58:	2308      	movs	r3, #8
 8006f5a:	2227      	movs	r2, #39	; 0x27
 8006f5c:	4634      	mov	r4, r6
 8006f5e:	f7fb fc7f 	bl	8002860 <gsl_error>
 8006f62:	e7e9      	b.n	8006f38 <gsl_block_int_alloc+0x1c>
 8006f64:	08030220 	.word	0x08030220
 8006f68:	08030544 	.word	0x08030544
 8006f6c:	08030570 	.word	0x08030570

08006f70 <gsl_block_int_calloc>:
{
 8006f70:	b570      	push	{r4, r5, r6, lr}
 8006f72:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8006f74:	f7ff ffd2 	bl	8006f1c <gsl_block_int_alloc>
  if (b == 0)
 8006f78:	4605      	mov	r5, r0
 8006f7a:	b178      	cbz	r0, 8006f9c <gsl_block_int_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8006f7c:	00b4      	lsls	r4, r6, #2
 8006f7e:	6840      	ldr	r0, [r0, #4]
 8006f80:	4622      	mov	r2, r4
 8006f82:	2100      	movs	r1, #0
 8006f84:	f028 f9e0 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006f88:	b146      	cbz	r6, 8006f9c <gsl_block_int_calloc+0x2c>
      b->data[i] = 0;
 8006f8a:	686b      	ldr	r3, [r5, #4]
 8006f8c:	1f22      	subs	r2, r4, #4
 8006f8e:	441a      	add	r2, r3
 8006f90:	2100      	movs	r1, #0
 8006f92:	3b04      	subs	r3, #4
 8006f94:	f843 1f04 	str.w	r1, [r3, #4]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8006f98:	4293      	cmp	r3, r2
 8006f9a:	d1fb      	bne.n	8006f94 <gsl_block_int_calloc+0x24>
}
 8006f9c:	4628      	mov	r0, r5
 8006f9e:	bd70      	pop	{r4, r5, r6, pc}

08006fa0 <gsl_block_int_free>:
  RETURN_IF_NULL (b);
 8006fa0:	b148      	cbz	r0, 8006fb6 <gsl_block_int_free+0x16>
{
 8006fa2:	b510      	push	{r4, lr}
 8006fa4:	4604      	mov	r4, r0
  free (b->data);
 8006fa6:	6840      	ldr	r0, [r0, #4]
 8006fa8:	f028 f9c6 	bl	802f338 <free>
  free (b);
 8006fac:	4620      	mov	r0, r4
}
 8006fae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8006fb2:	f028 b9c1 	b.w	802f338 <free>
 8006fb6:	4770      	bx	lr

08006fb8 <gsl_block_ushort_alloc>:
{
 8006fb8:	b570      	push	{r4, r5, r6, lr}
 8006fba:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8006fbc:	2008      	movs	r0, #8
 8006fbe:	f028 f9b3 	bl	802f328 <malloc>
  if (b == 0)
 8006fc2:	4604      	mov	r4, r0
 8006fc4:	b140      	cbz	r0, 8006fd8 <gsl_block_ushort_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8006fc6:	0068      	lsls	r0, r5, #1
 8006fc8:	f028 f9ae 	bl	802f328 <malloc>
 8006fcc:	4606      	mov	r6, r0
 8006fce:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006fd0:	b148      	cbz	r0, 8006fe6 <gsl_block_ushort_alloc+0x2e>
  b->size = n;
 8006fd2:	6025      	str	r5, [r4, #0]
}
 8006fd4:	4620      	mov	r0, r4
 8006fd6:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8006fd8:	4909      	ldr	r1, [pc, #36]	; (8007000 <gsl_block_ushort_alloc+0x48>)
 8006fda:	480a      	ldr	r0, [pc, #40]	; (8007004 <gsl_block_ushort_alloc+0x4c>)
 8006fdc:	2308      	movs	r3, #8
 8006fde:	221d      	movs	r2, #29
 8006fe0:	f7fb fc3e 	bl	8002860 <gsl_error>
 8006fe4:	e7f6      	b.n	8006fd4 <gsl_block_ushort_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8006fe6:	2d00      	cmp	r5, #0
 8006fe8:	d0f3      	beq.n	8006fd2 <gsl_block_ushort_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8006fea:	4620      	mov	r0, r4
 8006fec:	f028 f9a4 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8006ff0:	4903      	ldr	r1, [pc, #12]	; (8007000 <gsl_block_ushort_alloc+0x48>)
 8006ff2:	4805      	ldr	r0, [pc, #20]	; (8007008 <gsl_block_ushort_alloc+0x50>)
 8006ff4:	2308      	movs	r3, #8
 8006ff6:	2227      	movs	r2, #39	; 0x27
 8006ff8:	4634      	mov	r4, r6
 8006ffa:	f7fb fc31 	bl	8002860 <gsl_error>
 8006ffe:	e7e9      	b.n	8006fd4 <gsl_block_ushort_alloc+0x1c>
 8007000:	08030220 	.word	0x08030220
 8007004:	08030544 	.word	0x08030544
 8007008:	08030570 	.word	0x08030570

0800700c <gsl_block_ushort_calloc>:
{
 800700c:	b570      	push	{r4, r5, r6, lr}
 800700e:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007010:	f7ff ffd2 	bl	8006fb8 <gsl_block_ushort_alloc>
  if (b == 0)
 8007014:	4605      	mov	r5, r0
 8007016:	b178      	cbz	r0, 8007038 <gsl_block_ushort_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007018:	0074      	lsls	r4, r6, #1
 800701a:	6840      	ldr	r0, [r0, #4]
 800701c:	4622      	mov	r2, r4
 800701e:	2100      	movs	r1, #0
 8007020:	f028 f992 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007024:	b146      	cbz	r6, 8007038 <gsl_block_ushort_calloc+0x2c>
      b->data[i] = 0;
 8007026:	686b      	ldr	r3, [r5, #4]
 8007028:	1ea2      	subs	r2, r4, #2
 800702a:	441a      	add	r2, r3
 800702c:	2100      	movs	r1, #0
 800702e:	3b02      	subs	r3, #2
 8007030:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007034:	4293      	cmp	r3, r2
 8007036:	d1fb      	bne.n	8007030 <gsl_block_ushort_calloc+0x24>
}
 8007038:	4628      	mov	r0, r5
 800703a:	bd70      	pop	{r4, r5, r6, pc}

0800703c <gsl_block_ushort_free>:
  RETURN_IF_NULL (b);
 800703c:	b148      	cbz	r0, 8007052 <gsl_block_ushort_free+0x16>
{
 800703e:	b510      	push	{r4, lr}
 8007040:	4604      	mov	r4, r0
  free (b->data);
 8007042:	6840      	ldr	r0, [r0, #4]
 8007044:	f028 f978 	bl	802f338 <free>
  free (b);
 8007048:	4620      	mov	r0, r4
}
 800704a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 800704e:	f028 b973 	b.w	802f338 <free>
 8007052:	4770      	bx	lr

08007054 <gsl_block_short_alloc>:
{
 8007054:	b570      	push	{r4, r5, r6, lr}
 8007056:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 8007058:	2008      	movs	r0, #8
 800705a:	f028 f965 	bl	802f328 <malloc>
  if (b == 0)
 800705e:	4604      	mov	r4, r0
 8007060:	b140      	cbz	r0, 8007074 <gsl_block_short_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007062:	0068      	lsls	r0, r5, #1
 8007064:	f028 f960 	bl	802f328 <malloc>
 8007068:	4606      	mov	r6, r0
 800706a:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 800706c:	b148      	cbz	r0, 8007082 <gsl_block_short_alloc+0x2e>
  b->size = n;
 800706e:	6025      	str	r5, [r4, #0]
}
 8007070:	4620      	mov	r0, r4
 8007072:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007074:	4909      	ldr	r1, [pc, #36]	; (800709c <gsl_block_short_alloc+0x48>)
 8007076:	480a      	ldr	r0, [pc, #40]	; (80070a0 <gsl_block_short_alloc+0x4c>)
 8007078:	2308      	movs	r3, #8
 800707a:	221d      	movs	r2, #29
 800707c:	f7fb fbf0 	bl	8002860 <gsl_error>
 8007080:	e7f6      	b.n	8007070 <gsl_block_short_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007082:	2d00      	cmp	r5, #0
 8007084:	d0f3      	beq.n	800706e <gsl_block_short_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007086:	4620      	mov	r0, r4
 8007088:	f028 f956 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 800708c:	4903      	ldr	r1, [pc, #12]	; (800709c <gsl_block_short_alloc+0x48>)
 800708e:	4805      	ldr	r0, [pc, #20]	; (80070a4 <gsl_block_short_alloc+0x50>)
 8007090:	2308      	movs	r3, #8
 8007092:	2227      	movs	r2, #39	; 0x27
 8007094:	4634      	mov	r4, r6
 8007096:	f7fb fbe3 	bl	8002860 <gsl_error>
 800709a:	e7e9      	b.n	8007070 <gsl_block_short_alloc+0x1c>
 800709c:	08030220 	.word	0x08030220
 80070a0:	08030544 	.word	0x08030544
 80070a4:	08030570 	.word	0x08030570

080070a8 <gsl_block_short_calloc>:
{
 80070a8:	b570      	push	{r4, r5, r6, lr}
 80070aa:	4606      	mov	r6, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 80070ac:	f7ff ffd2 	bl	8007054 <gsl_block_short_alloc>
  if (b == 0)
 80070b0:	4605      	mov	r5, r0
 80070b2:	b178      	cbz	r0, 80070d4 <gsl_block_short_calloc+0x2c>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 80070b4:	0074      	lsls	r4, r6, #1
 80070b6:	6840      	ldr	r0, [r0, #4]
 80070b8:	4622      	mov	r2, r4
 80070ba:	2100      	movs	r1, #0
 80070bc:	f028 f944 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 80070c0:	b146      	cbz	r6, 80070d4 <gsl_block_short_calloc+0x2c>
      b->data[i] = 0;
 80070c2:	686b      	ldr	r3, [r5, #4]
 80070c4:	1ea2      	subs	r2, r4, #2
 80070c6:	441a      	add	r2, r3
 80070c8:	2100      	movs	r1, #0
 80070ca:	3b02      	subs	r3, #2
 80070cc:	f823 1f02 	strh.w	r1, [r3, #2]!
  for (i = 0; i < MULTIPLICITY * n; i++)
 80070d0:	4293      	cmp	r3, r2
 80070d2:	d1fb      	bne.n	80070cc <gsl_block_short_calloc+0x24>
}
 80070d4:	4628      	mov	r0, r5
 80070d6:	bd70      	pop	{r4, r5, r6, pc}

080070d8 <gsl_block_short_free>:
  RETURN_IF_NULL (b);
 80070d8:	b148      	cbz	r0, 80070ee <gsl_block_short_free+0x16>
{
 80070da:	b510      	push	{r4, lr}
 80070dc:	4604      	mov	r4, r0
  free (b->data);
 80070de:	6840      	ldr	r0, [r0, #4]
 80070e0:	f028 f92a 	bl	802f338 <free>
  free (b);
 80070e4:	4620      	mov	r0, r4
}
 80070e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 80070ea:	f028 b925 	b.w	802f338 <free>
 80070ee:	4770      	bx	lr

080070f0 <gsl_block_uchar_alloc>:
{
 80070f0:	b570      	push	{r4, r5, r6, lr}
 80070f2:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 80070f4:	2008      	movs	r0, #8
 80070f6:	f028 f917 	bl	802f328 <malloc>
  if (b == 0)
 80070fa:	4604      	mov	r4, r0
 80070fc:	b140      	cbz	r0, 8007110 <gsl_block_uchar_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 80070fe:	4628      	mov	r0, r5
 8007100:	f028 f912 	bl	802f328 <malloc>
 8007104:	4606      	mov	r6, r0
 8007106:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 8007108:	b148      	cbz	r0, 800711e <gsl_block_uchar_alloc+0x2e>
  b->size = n;
 800710a:	6025      	str	r5, [r4, #0]
}
 800710c:	4620      	mov	r0, r4
 800710e:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 8007110:	4909      	ldr	r1, [pc, #36]	; (8007138 <gsl_block_uchar_alloc+0x48>)
 8007112:	480a      	ldr	r0, [pc, #40]	; (800713c <gsl_block_uchar_alloc+0x4c>)
 8007114:	2308      	movs	r3, #8
 8007116:	221d      	movs	r2, #29
 8007118:	f7fb fba2 	bl	8002860 <gsl_error>
 800711c:	e7f6      	b.n	800710c <gsl_block_uchar_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 800711e:	2d00      	cmp	r5, #0
 8007120:	d0f3      	beq.n	800710a <gsl_block_uchar_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 8007122:	4620      	mov	r0, r4
 8007124:	f028 f908 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 8007128:	4903      	ldr	r1, [pc, #12]	; (8007138 <gsl_block_uchar_alloc+0x48>)
 800712a:	4805      	ldr	r0, [pc, #20]	; (8007140 <gsl_block_uchar_alloc+0x50>)
 800712c:	2308      	movs	r3, #8
 800712e:	2227      	movs	r2, #39	; 0x27
 8007130:	4634      	mov	r4, r6
 8007132:	f7fb fb95 	bl	8002860 <gsl_error>
 8007136:	e7e9      	b.n	800710c <gsl_block_uchar_alloc+0x1c>
 8007138:	08030220 	.word	0x08030220
 800713c:	08030544 	.word	0x08030544
 8007140:	08030570 	.word	0x08030570

08007144 <gsl_block_uchar_calloc>:
{
 8007144:	b538      	push	{r3, r4, r5, lr}
 8007146:	4605      	mov	r5, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 8007148:	f7ff ffd2 	bl	80070f0 <gsl_block_uchar_alloc>
  if (b == 0)
 800714c:	4604      	mov	r4, r0
 800714e:	b160      	cbz	r0, 800716a <gsl_block_uchar_calloc+0x26>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 8007150:	6840      	ldr	r0, [r0, #4]
 8007152:	462a      	mov	r2, r5
 8007154:	2100      	movs	r1, #0
 8007156:	f028 f8f7 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 800715a:	b135      	cbz	r5, 800716a <gsl_block_uchar_calloc+0x26>
 800715c:	2300      	movs	r3, #0
      b->data[i] = 0;
 800715e:	461a      	mov	r2, r3
 8007160:	6861      	ldr	r1, [r4, #4]
 8007162:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n; i++)
 8007164:	3301      	adds	r3, #1
 8007166:	429d      	cmp	r5, r3
 8007168:	d1fa      	bne.n	8007160 <gsl_block_uchar_calloc+0x1c>
}
 800716a:	4620      	mov	r0, r4
 800716c:	bd38      	pop	{r3, r4, r5, pc}
 800716e:	bf00      	nop

08007170 <gsl_block_uchar_free>:
  RETURN_IF_NULL (b);
 8007170:	b148      	cbz	r0, 8007186 <gsl_block_uchar_free+0x16>
{
 8007172:	b510      	push	{r4, lr}
 8007174:	4604      	mov	r4, r0
  free (b->data);
 8007176:	6840      	ldr	r0, [r0, #4]
 8007178:	f028 f8de 	bl	802f338 <free>
  free (b);
 800717c:	4620      	mov	r0, r4
}
 800717e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 8007182:	f028 b8d9 	b.w	802f338 <free>
 8007186:	4770      	bx	lr

08007188 <gsl_block_char_alloc>:
{
 8007188:	b570      	push	{r4, r5, r6, lr}
 800718a:	4605      	mov	r5, r0
  b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
 800718c:	2008      	movs	r0, #8
 800718e:	f028 f8cb 	bl	802f328 <malloc>
  if (b == 0)
 8007192:	4604      	mov	r4, r0
 8007194:	b140      	cbz	r0, 80071a8 <gsl_block_char_alloc+0x20>
  b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
 8007196:	4628      	mov	r0, r5
 8007198:	f028 f8c6 	bl	802f328 <malloc>
 800719c:	4606      	mov	r6, r0
 800719e:	6060      	str	r0, [r4, #4]
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80071a0:	b148      	cbz	r0, 80071b6 <gsl_block_char_alloc+0x2e>
  b->size = n;
 80071a2:	6025      	str	r5, [r4, #0]
}
 80071a4:	4620      	mov	r0, r4
 80071a6:	bd70      	pop	{r4, r5, r6, pc}
      GSL_ERROR_VAL ("failed to allocate space for block struct",
 80071a8:	4909      	ldr	r1, [pc, #36]	; (80071d0 <gsl_block_char_alloc+0x48>)
 80071aa:	480a      	ldr	r0, [pc, #40]	; (80071d4 <gsl_block_char_alloc+0x4c>)
 80071ac:	2308      	movs	r3, #8
 80071ae:	221d      	movs	r2, #29
 80071b0:	f7fb fb56 	bl	8002860 <gsl_error>
 80071b4:	e7f6      	b.n	80071a4 <gsl_block_char_alloc+0x1c>
  if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
 80071b6:	2d00      	cmp	r5, #0
 80071b8:	d0f3      	beq.n	80071a2 <gsl_block_char_alloc+0x1a>
      free (b);         /* exception in constructor, avoid memory leak */
 80071ba:	4620      	mov	r0, r4
 80071bc:	f028 f8bc 	bl	802f338 <free>
      GSL_ERROR_VAL ("failed to allocate space for block data",
 80071c0:	4903      	ldr	r1, [pc, #12]	; (80071d0 <gsl_block_char_alloc+0x48>)
 80071c2:	4805      	ldr	r0, [pc, #20]	; (80071d8 <gsl_block_char_alloc+0x50>)
 80071c4:	2308      	movs	r3, #8
 80071c6:	2227      	movs	r2, #39	; 0x27
 80071c8:	4634      	mov	r4, r6
 80071ca:	f7fb fb49 	bl	8002860 <gsl_error>
 80071ce:	e7e9      	b.n	80071a4 <gsl_block_char_alloc+0x1c>
 80071d0:	08030220 	.word	0x08030220
 80071d4:	08030544 	.word	0x08030544
 80071d8:	08030570 	.word	0x08030570

080071dc <gsl_block_char_calloc>:
{
 80071dc:	b538      	push	{r3, r4, r5, lr}
 80071de:	4605      	mov	r5, r0
  TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
 80071e0:	f7ff ffd2 	bl	8007188 <gsl_block_char_alloc>
  if (b == 0)
 80071e4:	4604      	mov	r4, r0
 80071e6:	b160      	cbz	r0, 8007202 <gsl_block_char_calloc+0x26>
  memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
 80071e8:	6840      	ldr	r0, [r0, #4]
 80071ea:	462a      	mov	r2, r5
 80071ec:	2100      	movs	r1, #0
 80071ee:	f028 f8ab 	bl	802f348 <memset>
  for (i = 0; i < MULTIPLICITY * n; i++)
 80071f2:	b135      	cbz	r5, 8007202 <gsl_block_char_calloc+0x26>
 80071f4:	2300      	movs	r3, #0
      b->data[i] = 0;
 80071f6:	461a      	mov	r2, r3
 80071f8:	6861      	ldr	r1, [r4, #4]
 80071fa:	54ca      	strb	r2, [r1, r3]
  for (i = 0; i < MULTIPLICITY * n; i++)
 80071fc:	3301      	adds	r3, #1
 80071fe:	429d      	cmp	r5, r3
 8007200:	d1fa      	bne.n	80071f8 <gsl_block_char_calloc+0x1c>
}
 8007202:	4620      	mov	r0, r4
 8007204:	bd38      	pop	{r3, r4, r5, pc}
 8007206:	bf00      	nop

08007208 <gsl_block_char_free>:
  RETURN_IF_NULL (b);
 8007208:	b148      	cbz	r0, 800721e <gsl_block_char_free+0x16>
{
 800720a:	b510      	push	{r4, lr}
 800720c:	4604      	mov	r4, r0
  free (b->data);
 800720e:	6840      	ldr	r0, [r0, #4]
 8007210:	f028 f892 	bl	802f338 <free>
  free (b);
 8007214:	4620      	mov	r0, r4
}
 8007216:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  free (b);
 800721a:	f028 b88d 	b.w	802f338 <free>
 800721e:	4770      	bx	lr

08007220 <cblas_sasum>:
{
  BASE r = 0.0;
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 8007220:	2a00      	cmp	r2, #0
    return 0;
 8007222:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 800724c <cblas_sasum+0x2c>
  if (incX <= 0) {
 8007226:	dd0e      	ble.n	8007246 <cblas_sasum+0x26>
  }

  for (i = 0; i < N; i++) {
 8007228:	2800      	cmp	r0, #0
 800722a:	dd0d      	ble.n	8007248 <cblas_sasum+0x28>
 800722c:	0092      	lsls	r2, r2, #2
 800722e:	2300      	movs	r3, #0
    r += fabs(X[ix]);
 8007230:	edd1 7a00 	vldr	s15, [r1]
  for (i = 0; i < N; i++) {
 8007234:	3301      	adds	r3, #1
    r += fabs(X[ix]);
 8007236:	eef0 7ae7 	vabs.f32	s15, s15
  for (i = 0; i < N; i++) {
 800723a:	4298      	cmp	r0, r3
    r += fabs(X[ix]);
 800723c:	ee30 0a27 	vadd.f32	s0, s0, s15
  for (i = 0; i < N; i++) {
 8007240:	4411      	add	r1, r2
 8007242:	d1f5      	bne.n	8007230 <cblas_sasum+0x10>
 8007244:	4770      	bx	lr
 8007246:	4770      	bx	lr
cblas_sasum (const int N, const float *X, const int incX)
{
#define BASE float
#include "source_asum_r.h"
#undef BASE
}
 8007248:	4770      	bx	lr
 800724a:	bf00      	nop
 800724c:	00000000 	.word	0x00000000

08007250 <cblas_saxpy>:
 */

{
  INDEX i;

  if (alpha == 0.0) {
 8007250:	eeb5 0a40 	vcmp.f32	s0, #0.0
#include "cblas.h"

void
cblas_saxpy (const int N, const float alpha, const float *X, const int incX,
             float *Y, const int incY)
{
 8007254:	b470      	push	{r4, r5, r6}
 8007256:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800725a:	9d03      	ldr	r5, [sp, #12]
 800725c:	d023      	beq.n	80072a6 <cblas_saxpy+0x56>
    return;
  }

  if (incX == 1 && incY == 1) {
 800725e:	2a01      	cmp	r2, #1
 8007260:	d023      	beq.n	80072aa <cblas_saxpy+0x5a>
      Y[i + 1] += alpha * X[i + 1];
      Y[i + 2] += alpha * X[i + 2];
      Y[i + 3] += alpha * X[i + 3];
    }
  } else {
    INDEX ix = OFFSET(N, incX);
 8007262:	2a00      	cmp	r2, #0
 8007264:	dc23      	bgt.n	80072ae <cblas_saxpy+0x5e>
 8007266:	f1c0 0601 	rsb	r6, r0, #1
 800726a:	fb06 f602 	mul.w	r6, r6, r2
    INDEX iy = OFFSET(N, incY);
 800726e:	2d00      	cmp	r5, #0
 8007270:	bfda      	itte	le
 8007272:	f1c0 0401 	rsble	r4, r0, #1
 8007276:	436c      	mulle	r4, r5
 8007278:	2400      	movgt	r4, #0

    for (i = 0; i < N; i++) {
 800727a:	2800      	cmp	r0, #0
 800727c:	dd13      	ble.n	80072a6 <cblas_saxpy+0x56>
 800727e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8007282:	00ad      	lsls	r5, r5, #2
 8007284:	0094      	lsls	r4, r2, #2
 8007286:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 800728a:	2200      	movs	r2, #0
      Y[iy] += alpha * X[ix];
 800728c:	ed91 7a00 	vldr	s14, [r1]
 8007290:	edd3 7a00 	vldr	s15, [r3]
 8007294:	eee7 7a00 	vfma.f32	s15, s14, s0
    for (i = 0; i < N; i++) {
 8007298:	3201      	adds	r2, #1
 800729a:	4290      	cmp	r0, r2
 800729c:	4421      	add	r1, r4
      Y[iy] += alpha * X[ix];
 800729e:	edc3 7a00 	vstr	s15, [r3]
    for (i = 0; i < N; i++) {
 80072a2:	442b      	add	r3, r5
 80072a4:	d1f2      	bne.n	800728c <cblas_saxpy+0x3c>
#define BASE float
#include "source_axpy_r.h"
#undef BASE
}
 80072a6:	bc70      	pop	{r4, r5, r6}
 80072a8:	4770      	bx	lr
  if (incX == 1 && incY == 1) {
 80072aa:	2d01      	cmp	r5, #1
 80072ac:	d001      	beq.n	80072b2 <cblas_saxpy+0x62>
    INDEX ix = OFFSET(N, incX);
 80072ae:	2600      	movs	r6, #0
 80072b0:	e7dd      	b.n	800726e <cblas_saxpy+0x1e>
    const INDEX m = N % 4;
 80072b2:	4244      	negs	r4, r0
 80072b4:	f004 0403 	and.w	r4, r4, #3
 80072b8:	f000 0203 	and.w	r2, r0, #3
 80072bc:	bf58      	it	pl
 80072be:	4262      	negpl	r2, r4
    for (i = 0; i < m; i++) {
 80072c0:	2a00      	cmp	r2, #0
 80072c2:	dd0d      	ble.n	80072e0 <cblas_saxpy+0x90>
 80072c4:	461c      	mov	r4, r3
 80072c6:	460d      	mov	r5, r1
 80072c8:	eb03 0682 	add.w	r6, r3, r2, lsl #2
      Y[i] += alpha * X[i];
 80072cc:	edd4 7a00 	vldr	s15, [r4]
 80072d0:	ecb5 7a01 	vldmia	r5!, {s14}
 80072d4:	eee7 7a00 	vfma.f32	s15, s14, s0
 80072d8:	ece4 7a01 	vstmia	r4!, {s15}
    for (i = 0; i < m; i++) {
 80072dc:	42a6      	cmp	r6, r4
 80072de:	d1f5      	bne.n	80072cc <cblas_saxpy+0x7c>
    for (i = m; i + 3 < N; i += 4) {
 80072e0:	1cd4      	adds	r4, r2, #3
 80072e2:	42a0      	cmp	r0, r4
 80072e4:	dddf      	ble.n	80072a6 <cblas_saxpy+0x56>
 80072e6:	1f04      	subs	r4, r0, #4
 80072e8:	1aa4      	subs	r4, r4, r2
 80072ea:	f024 0403 	bic.w	r4, r4, #3
 80072ee:	f103 0010 	add.w	r0, r3, #16
 80072f2:	4414      	add	r4, r2
 80072f4:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 80072f8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80072fc:	eb00 0284 	add.w	r2, r0, r4, lsl #2
      Y[i] += alpha * X[i];
 8007300:	edd1 5a00 	vldr	s11, [r1]
 8007304:	ed93 6a00 	vldr	s12, [r3]
      Y[i + 1] += alpha * X[i + 1];
 8007308:	edd3 6a01 	vldr	s13, [r3, #4]
      Y[i + 2] += alpha * X[i + 2];
 800730c:	ed93 7a02 	vldr	s14, [r3, #8]
      Y[i + 3] += alpha * X[i + 3];
 8007310:	edd3 7a03 	vldr	s15, [r3, #12]
      Y[i] += alpha * X[i];
 8007314:	eea5 6a80 	vfma.f32	s12, s11, s0
 8007318:	3310      	adds	r3, #16
 800731a:	3110      	adds	r1, #16
 800731c:	ed03 6a04 	vstr	s12, [r3, #-16]
      Y[i + 1] += alpha * X[i + 1];
 8007320:	ed11 6a03 	vldr	s12, [r1, #-12]
 8007324:	eee6 6a00 	vfma.f32	s13, s12, s0
 8007328:	ed43 6a03 	vstr	s13, [r3, #-12]
      Y[i + 2] += alpha * X[i + 2];
 800732c:	ed51 6a02 	vldr	s13, [r1, #-8]
 8007330:	eea6 7a80 	vfma.f32	s14, s13, s0
 8007334:	ed03 7a02 	vstr	s14, [r3, #-8]
      Y[i + 3] += alpha * X[i + 3];
 8007338:	ed11 7a01 	vldr	s14, [r1, #-4]
 800733c:	eee7 7a00 	vfma.f32	s15, s14, s0
 8007340:	ed43 7a01 	vstr	s15, [r3, #-4]
    for (i = m; i + 3 < N; i += 4) {
 8007344:	4293      	cmp	r3, r2
 8007346:	d1db      	bne.n	8007300 <cblas_saxpy+0xb0>
 8007348:	e7ad      	b.n	80072a6 <cblas_saxpy+0x56>
 800734a:	bf00      	nop

0800734c <cblas_scasum>:
{
  BASE r = 0.0;
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 800734c:	2a00      	cmp	r2, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

float
cblas_scasum (const int N, const void *X, const int incX)
{
 800734e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8007352:	dd36      	ble.n	80073c2 <cblas_scasum+0x76>
    return 0;
  }

  for (i = 0; i < N; i++) {
 8007354:	2800      	cmp	r0, #0
 8007356:	4681      	mov	r9, r0
  BASE r = 0.0;
 8007358:	f04f 0a00 	mov.w	sl, #0
  for (i = 0; i < N; i++) {
 800735c:	dd2d      	ble.n	80073ba <cblas_scasum+0x6e>
 800735e:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 8007362:	460c      	mov	r4, r1
 8007364:	2500      	movs	r5, #0
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 8007366:	edd4 7a00 	vldr	s15, [r4]
 800736a:	eef0 7ae7 	vabs.f32	s15, s15
 800736e:	ee17 0a90 	vmov	r0, s15
 8007372:	f020 fd41 	bl	8027df8 <__aeabi_f2d>
 8007376:	edd4 7a01 	vldr	s15, [r4, #4]
 800737a:	eef0 7ae7 	vabs.f32	s15, s15
 800737e:	4606      	mov	r6, r0
 8007380:	ee17 0a90 	vmov	r0, s15
 8007384:	460f      	mov	r7, r1
 8007386:	f020 fd37 	bl	8027df8 <__aeabi_f2d>
 800738a:	4602      	mov	r2, r0
 800738c:	460b      	mov	r3, r1
 800738e:	4630      	mov	r0, r6
 8007390:	4639      	mov	r1, r7
 8007392:	f020 fbd3 	bl	8027b3c <__adddf3>
 8007396:	4606      	mov	r6, r0
 8007398:	4650      	mov	r0, sl
 800739a:	460f      	mov	r7, r1
 800739c:	f020 fd2c 	bl	8027df8 <__aeabi_f2d>
 80073a0:	4602      	mov	r2, r0
 80073a2:	460b      	mov	r3, r1
 80073a4:	4630      	mov	r0, r6
 80073a6:	4639      	mov	r1, r7
 80073a8:	f020 fbc8 	bl	8027b3c <__adddf3>
 80073ac:	f021 f82c 	bl	8028408 <__aeabi_d2f>
  for (i = 0; i < N; i++) {
 80073b0:	3501      	adds	r5, #1
 80073b2:	45a9      	cmp	r9, r5
 80073b4:	4444      	add	r4, r8
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 80073b6:	4682      	mov	sl, r0
  for (i = 0; i < N; i++) {
 80073b8:	d1d5      	bne.n	8007366 <cblas_scasum+0x1a>
#define BASE float
#include "source_asum_c.h"
#undef BASE
}
 80073ba:	ee00 aa10 	vmov	s0, sl
 80073be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return 0;
 80073c2:	f04f 0a00 	mov.w	sl, #0
 80073c6:	ee00 aa10 	vmov	s0, sl
 80073ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80073ce:	bf00      	nop

080073d0 <cblas_scnrm2>:
  BASE scale = 0.0;
  BASE ssq = 1.0;
  INDEX i;
  INDEX ix = 0;

  if (N == 0 || incX < 1) {
 80073d0:	2800      	cmp	r0, #0
 80073d2:	d06a      	beq.n	80074aa <cblas_scnrm2+0xda>
 80073d4:	2a00      	cmp	r2, #0
 80073d6:	dd68      	ble.n	80074aa <cblas_scnrm2+0xda>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

float
cblas_scnrm2 (const int N, const void *X, const int incX)
{
 80073d8:	b538      	push	{r3, r4, r5, lr}
    return 0;
  }

  for (i = 0; i < N; i++) {
 80073da:	2800      	cmp	r0, #0
 80073dc:	ed2d 8b02 	vpush	{d8}
 80073e0:	dd6b      	ble.n	80074ba <cblas_scnrm2+0xea>
  BASE ssq = 1.0;
 80073e2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
  BASE scale = 0.0;
 80073e6:	eddf 6a3a 	vldr	s13, [pc, #232]	; 80074d0 <cblas_scnrm2+0x100>

    if (x != 0.0) {
      const BASE ax = fabs(x);

      if (scale < ax) {
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 80073ea:	eef0 5a48 	vmov.f32	s11, s16
 80073ee:	00d2      	lsls	r2, r2, #3
  for (i = 0; i < N; i++) {
 80073f0:	2300      	movs	r3, #0
 80073f2:	e00f      	b.n	8007414 <cblas_scnrm2+0x44>

    if (y != 0.0) {
      const BASE ay = fabs(y);

      if (scale < ay) {
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 80073f4:	eec6 7a87 	vdiv.f32	s15, s13, s14
        scale = ay;
 80073f8:	eef0 6a47 	vmov.f32	s13, s14
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 80073fc:	ee27 8a88 	vmul.f32	s16, s15, s16
 8007400:	eeb0 7a65 	vmov.f32	s14, s11
 8007404:	eea7 7a88 	vfma.f32	s14, s15, s16
 8007408:	eeb0 8a47 	vmov.f32	s16, s14
  for (i = 0; i < N; i++) {
 800740c:	3301      	adds	r3, #1
 800740e:	4298      	cmp	r0, r3
 8007410:	4411      	add	r1, r2
 8007412:	d02f      	beq.n	8007474 <cblas_scnrm2+0xa4>
    const BASE x = CONST_REAL(X, ix);
 8007414:	ed91 7a00 	vldr	s14, [r1]
    const BASE y = CONST_IMAG(X, ix);
 8007418:	edd1 7a01 	vldr	s15, [r1, #4]
    if (x != 0.0) {
 800741c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8007420:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      const BASE ax = fabs(x);
 8007424:	eeb0 6ac7 	vabs.f32	s12, s14
    if (x != 0.0) {
 8007428:	d010      	beq.n	800744c <cblas_scnrm2+0x7c>
      if (scale < ax) {
 800742a:	eeb4 6ae6 	vcmpe.f32	s12, s13
 800742e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007432:	dd3d      	ble.n	80074b0 <cblas_scnrm2+0xe0>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 8007434:	ee86 7a86 	vdiv.f32	s14, s13, s12
        scale = ax;
 8007438:	eef0 6a46 	vmov.f32	s13, s12
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 800743c:	ee27 8a08 	vmul.f32	s16, s14, s16
 8007440:	eeb0 6a65 	vmov.f32	s12, s11
 8007444:	eea7 6a08 	vfma.f32	s12, s14, s16
 8007448:	eeb0 8a46 	vmov.f32	s16, s12
    if (y != 0.0) {
 800744c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8007450:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      const BASE ay = fabs(y);
 8007454:	eeb0 7ae7 	vabs.f32	s14, s15
    if (y != 0.0) {
 8007458:	d0d8      	beq.n	800740c <cblas_scnrm2+0x3c>
      if (scale < ay) {
 800745a:	eef4 6ac7 	vcmpe.f32	s13, s14
 800745e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007462:	d4c7      	bmi.n	80073f4 <cblas_scnrm2+0x24>
      } else {
        ssq += (ay / scale) * (ay / scale);
 8007464:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  for (i = 0; i < N; i++) {
 8007468:	3301      	adds	r3, #1
 800746a:	4298      	cmp	r0, r3
 800746c:	4411      	add	r1, r2
        ssq += (ay / scale) * (ay / scale);
 800746e:	eea7 8a07 	vfma.f32	s16, s14, s14
  for (i = 0; i < N; i++) {
 8007472:	d1cf      	bne.n	8007414 <cblas_scnrm2+0x44>
 8007474:	ee16 0a90 	vmov	r0, s13
 8007478:	f020 fcbe 	bl	8027df8 <__aeabi_f2d>
 800747c:	4604      	mov	r4, r0
 800747e:	ee18 0a10 	vmov	r0, s16
 8007482:	460d      	mov	r5, r1
 8007484:	f020 fcb8 	bl	8027df8 <__aeabi_f2d>
 8007488:	ec41 0b10 	vmov	d0, r0, r1
    }

    ix += incX;
  }

  return scale * sqrt(ssq);
 800748c:	f028 fd04 	bl	802fe98 <sqrt>
 8007490:	4622      	mov	r2, r4
 8007492:	ec51 0b10 	vmov	r0, r1, d0
 8007496:	462b      	mov	r3, r5
 8007498:	f020 fd06 	bl	8027ea8 <__aeabi_dmul>
 800749c:	f020 ffb4 	bl	8028408 <__aeabi_d2f>
#define BASE float
#include "source_nrm2_c.h"
#undef BASE
}
 80074a0:	ecbd 8b02 	vpop	{d8}
 80074a4:	ee00 0a10 	vmov	s0, r0
 80074a8:	bd38      	pop	{r3, r4, r5, pc}
    return 0;
 80074aa:	ed9f 0a09 	vldr	s0, [pc, #36]	; 80074d0 <cblas_scnrm2+0x100>
 80074ae:	4770      	bx	lr
        ssq += (ax / scale) * (ax / scale);
 80074b0:	ee87 6a26 	vdiv.f32	s12, s14, s13
 80074b4:	eea6 8a06 	vfma.f32	s16, s12, s12
 80074b8:	e7c8      	b.n	800744c <cblas_scnrm2+0x7c>
  for (i = 0; i < N; i++) {
 80074ba:	ed9f 0b03 	vldr	d0, [pc, #12]	; 80074c8 <cblas_scnrm2+0xf8>
 80074be:	2400      	movs	r4, #0
 80074c0:	2500      	movs	r5, #0
 80074c2:	e7e3      	b.n	800748c <cblas_scnrm2+0xbc>
 80074c4:	f3af 8000 	nop.w
 80074c8:	00000000 	.word	0x00000000
 80074cc:	3ff00000 	.word	0x3ff00000
 80074d0:	00000000 	.word	0x00000000

080074d4 <cblas_scopy>:
#include "cblas.h"

void
cblas_scopy (const int N, const float *X, const int incX, float *Y,
             const int incY)
{
 80074d4:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80074d6:	2a00      	cmp	r2, #0
 80074d8:	9e04      	ldr	r6, [sp, #16]
 80074da:	bfda      	itte	le
 80074dc:	f1c0 0701 	rsble	r7, r0, #1
 80074e0:	4357      	mulle	r7, r2
 80074e2:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 80074e4:	2e00      	cmp	r6, #0
 80074e6:	bfda      	itte	le
 80074e8:	f1c0 0401 	rsble	r4, r0, #1
 80074ec:	4374      	mulle	r4, r6
 80074ee:	2400      	movgt	r4, #0

  for (i = 0; i < N; i++) {
 80074f0:	2800      	cmp	r0, #0
 80074f2:	dd0d      	ble.n	8007510 <cblas_scopy+0x3c>
 80074f4:	0095      	lsls	r5, r2, #2
 80074f6:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 80074fa:	00b6      	lsls	r6, r6, #2
 80074fc:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8007500:	2200      	movs	r2, #0
 8007502:	3201      	adds	r2, #1
    Y[iy] = X[ix];
 8007504:	680c      	ldr	r4, [r1, #0]
 8007506:	601c      	str	r4, [r3, #0]
  for (i = 0; i < N; i++) {
 8007508:	4290      	cmp	r0, r2
 800750a:	4429      	add	r1, r5
 800750c:	4433      	add	r3, r6
 800750e:	d1f8      	bne.n	8007502 <cblas_scopy+0x2e>
#define BASE float
#include "source_copy_r.h"
#undef BASE
}
 8007510:	bcf0      	pop	{r4, r5, r6, r7}
 8007512:	4770      	bx	lr

08007514 <cblas_sdot>:
#include "cblas.h"

float
cblas_sdot (const int N, const float *X, const int incX, const float *Y,
            const int incY)
{
 8007514:	b4f0      	push	{r4, r5, r6, r7}
 */

{
  ACC_TYPE r = INIT_VAL;
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 8007516:	2a00      	cmp	r2, #0
 8007518:	9d04      	ldr	r5, [sp, #16]
  INDEX iy = OFFSET(N, incY);

  for (i = 0; i < N; i++) {
 800751a:	ed9f 0a11 	vldr	s0, [pc, #68]	; 8007560 <cblas_sdot+0x4c>
  INDEX ix = OFFSET(N, incX);
 800751e:	bfda      	itte	le
 8007520:	f1c0 0701 	rsble	r7, r0, #1
 8007524:	4357      	mulle	r7, r2
 8007526:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 8007528:	2d00      	cmp	r5, #0
 800752a:	bfda      	itte	le
 800752c:	f1c0 0601 	rsble	r6, r0, #1
 8007530:	436e      	mulle	r6, r5
 8007532:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 8007534:	2800      	cmp	r0, #0
 8007536:	dd11      	ble.n	800755c <cblas_sdot+0x48>
 8007538:	0094      	lsls	r4, r2, #2
 800753a:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 800753e:	00ad      	lsls	r5, r5, #2
 8007540:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8007544:	2200      	movs	r2, #0
    r += X[ix] * Y[iy];
 8007546:	ed91 7a00 	vldr	s14, [r1]
 800754a:	edd3 7a00 	vldr	s15, [r3]
  for (i = 0; i < N; i++) {
 800754e:	3201      	adds	r2, #1
 8007550:	4290      	cmp	r0, r2
    r += X[ix] * Y[iy];
 8007552:	eea7 0a27 	vfma.f32	s0, s14, s15
  for (i = 0; i < N; i++) {
 8007556:	4421      	add	r1, r4
 8007558:	442b      	add	r3, r5
 800755a:	d1f4      	bne.n	8007546 <cblas_sdot+0x32>
#define BASE float
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 800755c:	bcf0      	pop	{r4, r5, r6, r7}
 800755e:	4770      	bx	lr
 8007560:	00000000 	.word	0x00000000

08007564 <cblas_sdsdot>:
#include "cblas.h"

float
cblas_sdsdot (const int N, const float alpha, const float *X, const int incX,
              const float *Y, const int incY)
{
 8007564:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007568:	4682      	mov	sl, r0
  ACC_TYPE r = INIT_VAL;
 800756a:	ee10 0a10 	vmov	r0, s0
 800756e:	4691      	mov	r9, r2
 8007570:	461e      	mov	r6, r3
 8007572:	ee10 8a10 	vmov	r8, s0
 8007576:	460f      	mov	r7, r1
 8007578:	f020 fc3e 	bl	8027df8 <__aeabi_f2d>
  INDEX ix = OFFSET(N, incX);
 800757c:	f1b9 0f00 	cmp.w	r9, #0
 8007580:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  ACC_TYPE r = INIT_VAL;
 8007582:	460d      	mov	r5, r1
  INDEX ix = OFFSET(N, incX);
 8007584:	bfda      	itte	le
 8007586:	f1ca 0101 	rsble	r1, sl, #1
 800758a:	fb01 f109 	mulle.w	r1, r1, r9
 800758e:	2100      	movgt	r1, #0
  INDEX iy = OFFSET(N, incY);
 8007590:	2b00      	cmp	r3, #0
 8007592:	bfda      	itte	le
 8007594:	f1ca 0201 	rsble	r2, sl, #1
 8007598:	435a      	mulle	r2, r3
 800759a:	2200      	movgt	r2, #0
  for (i = 0; i < N; i++) {
 800759c:	f1ba 0f00 	cmp.w	sl, #0
  ACC_TYPE r = INIT_VAL;
 80075a0:	4604      	mov	r4, r0
  for (i = 0; i < N; i++) {
 80075a2:	dd27      	ble.n	80075f4 <cblas_sdsdot+0x90>
 80075a4:	ea4f 0989 	mov.w	r9, r9, lsl #2
 80075a8:	eb07 0781 	add.w	r7, r7, r1, lsl #2
 80075ac:	ea4f 0b83 	mov.w	fp, r3, lsl #2
 80075b0:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 80075b4:	f04f 0800 	mov.w	r8, #0
    r += X[ix] * Y[iy];
 80075b8:	ed97 7a00 	vldr	s14, [r7]
 80075bc:	edd6 7a00 	vldr	s15, [r6]
 80075c0:	ee67 7a27 	vmul.f32	s15, s14, s15
  for (i = 0; i < N; i++) {
 80075c4:	f108 0801 	add.w	r8, r8, #1
    r += X[ix] * Y[iy];
 80075c8:	ee17 0a90 	vmov	r0, s15
 80075cc:	f020 fc14 	bl	8027df8 <__aeabi_f2d>
 80075d0:	4602      	mov	r2, r0
 80075d2:	460b      	mov	r3, r1
 80075d4:	4620      	mov	r0, r4
 80075d6:	4629      	mov	r1, r5
 80075d8:	f020 fab0 	bl	8027b3c <__adddf3>
  for (i = 0; i < N; i++) {
 80075dc:	45c2      	cmp	sl, r8
    r += X[ix] * Y[iy];
 80075de:	4604      	mov	r4, r0
 80075e0:	460d      	mov	r5, r1
 80075e2:	444f      	add	r7, r9
 80075e4:	445e      	add	r6, fp
  for (i = 0; i < N; i++) {
 80075e6:	d1e7      	bne.n	80075b8 <cblas_sdsdot+0x54>
 80075e8:	f020 ff0e 	bl	8028408 <__aeabi_d2f>
 80075ec:	ee00 0a10 	vmov	s0, r0
#define BASE float
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 80075f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80075f4:	ee00 8a10 	vmov	s0, r8
 80075f8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

080075fc <cblas_sgemm>:
cblas_sgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const float alpha, const float *A, const int lda,
             const float *B, const int ldb, const float beta, float *C,
             const int ldc)
{
 80075fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007600:	ed2d 8b02 	vpush	{d8}
 8007604:	b089      	sub	sp, #36	; 0x24
 8007606:	461d      	mov	r5, r3
 8007608:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800760a:	9304      	str	r3, [sp, #16]
 800760c:	e9dd 8317 	ldrd	r8, r3, [sp, #92]	; 0x5c
 8007610:	9303      	str	r3, [sp, #12]
 8007612:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8007614:	9302      	str	r3, [sp, #8]
  INDEX n1, n2;
  INDEX ldf, ldg;
  int TransF, TransG;
  const BASE *F, *G;

  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8007616:	2865      	cmp	r0, #101	; 0x65
 8007618:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800761a:	f8dd 906c 	ldr.w	r9, [sp, #108]	; 0x6c
 800761e:	9301      	str	r3, [sp, #4]
 8007620:	e9dd 6714 	ldrd	r6, r7, [sp, #80]	; 0x50
 8007624:	4682      	mov	sl, r0
 8007626:	460c      	mov	r4, r1
 8007628:	4693      	mov	fp, r2
 800762a:	eeb0 8a40 	vmov.f32	s16, s0
 800762e:	eef0 8a60 	vmov.f32	s17, s1
 8007632:	f000 8106 	beq.w	8007842 <cblas_sgemm+0x246>
 8007636:	2a71      	cmp	r2, #113	; 0x71
 8007638:	bf08      	it	eq
 800763a:	2270      	moveq	r2, #112	; 0x70
 800763c:	2971      	cmp	r1, #113	; 0x71
 800763e:	d069      	beq.n	8007714 <cblas_sgemm+0x118>
 8007640:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8007644:	b2db      	uxtb	r3, r3
 8007646:	2b02      	cmp	r3, #2
 8007648:	d970      	bls.n	800772c <cblas_sgemm+0x130>
 800764a:	2002      	movs	r0, #2
 800764c:	f1ab 036f 	sub.w	r3, fp, #111	; 0x6f
 8007650:	2b02      	cmp	r3, #2
 8007652:	bf88      	it	hi
 8007654:	2003      	movhi	r0, #3
 8007656:	2d00      	cmp	r5, #0
 8007658:	bfb8      	it	lt
 800765a:	2004      	movlt	r0, #4
 800765c:	2e00      	cmp	r6, #0
 800765e:	f2c0 80c8 	blt.w	80077f2 <cblas_sgemm+0x1f6>
 8007662:	2f00      	cmp	r7, #0
 8007664:	db69      	blt.n	800773a <cblas_sgemm+0x13e>
 8007666:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 800766a:	f000 80c9 	beq.w	8007800 <cblas_sgemm+0x204>
 800766e:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8007672:	d06a      	beq.n	800774a <cblas_sgemm+0x14e>
 8007674:	2800      	cmp	r0, #0
 8007676:	f040 8085 	bne.w	8007784 <cblas_sgemm+0x188>

  if (alpha == 0.0 && beta == 1.0)
 800767a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800767e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007682:	d107      	bne.n	8007694 <cblas_sgemm+0x98>
 8007684:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8007688:	eef4 8a67 	vcmp.f32	s17, s15
 800768c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007690:	f000 8087 	beq.w	80077a2 <cblas_sgemm+0x1a6>
    return;

  if (Order == CblasRowMajor) {
 8007694:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8007698:	f000 80e1 	beq.w	800785e <cblas_sgemm+0x262>
  } else {
    n1 = N;
    n2 = M;
    F = B;
    ldf = ldb;
    TransF = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800769c:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 80076a0:	bf14      	ite	ne
 80076a2:	4659      	movne	r1, fp
 80076a4:	2170      	moveq	r1, #112	; 0x70
    G = A;
    ldg = lda;
    TransG = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 80076a6:	2c71      	cmp	r4, #113	; 0x71
 80076a8:	bf14      	ite	ne
 80076aa:	46a3      	movne	fp, r4
 80076ac:	f04f 0b70 	moveq.w	fp, #112	; 0x70
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 80076b0:	eef5 8a40 	vcmp.f32	s17, #0.0
 80076b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80076b8:	d178      	bne.n	80077ac <cblas_sgemm+0x1b0>
    for (i = 0; i < n1; i++) {
 80076ba:	2e00      	cmp	r6, #0
 80076bc:	dd16      	ble.n	80076ec <cblas_sgemm+0xf0>
 80076be:	9b01      	ldr	r3, [sp, #4]
 80076c0:	ebc5 7485 	rsb	r4, r5, r5, lsl #30
 80076c4:	00a4      	lsls	r4, r4, #2
 80076c6:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 80076ca:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 80076ce:	2000      	movs	r0, #0
      for (j = 0; j < n2; j++) {
        C[ldc * i + j] = 0.0;
 80076d0:	f04f 0e00 	mov.w	lr, #0
      for (j = 0; j < n2; j++) {
 80076d4:	2d00      	cmp	r5, #0
 80076d6:	bfc8      	it	gt
 80076d8:	1913      	addgt	r3, r2, r4
 80076da:	dd03      	ble.n	80076e4 <cblas_sgemm+0xe8>
        C[ldc * i + j] = 0.0;
 80076dc:	f843 eb04 	str.w	lr, [r3], #4
      for (j = 0; j < n2; j++) {
 80076e0:	4293      	cmp	r3, r2
 80076e2:	d1fb      	bne.n	80076dc <cblas_sgemm+0xe0>
    for (i = 0; i < n1; i++) {
 80076e4:	3001      	adds	r0, #1
 80076e6:	4286      	cmp	r6, r0
 80076e8:	4462      	add	r2, ip
 80076ea:	d1f3      	bne.n	80076d4 <cblas_sgemm+0xd8>
        C[ldc * i + j] *= beta;
      }
    }
  }

  if (alpha == 0.0)
 80076ec:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80076f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80076f4:	d055      	beq.n	80077a2 <cblas_sgemm+0x1a6>
    return;

  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 80076f6:	296f      	cmp	r1, #111	; 0x6f
 80076f8:	d049      	beq.n	800778e <cblas_sgemm+0x192>
        }
        C[ldc * i + j] += alpha * temp;
      }
    }

  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 80076fa:	2970      	cmp	r1, #112	; 0x70
 80076fc:	f000 80c2 	beq.w	8007884 <cblas_sgemm+0x288>
        C[ldc * i + j] += alpha * temp;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 8007700:	4ab1      	ldr	r2, [pc, #708]	; (80079c8 <cblas_sgemm+0x3cc>)
 8007702:	49b2      	ldr	r1, [pc, #712]	; (80079cc <cblas_sgemm+0x3d0>)
 8007704:	2000      	movs	r0, #0
#define BASE float
#include "source_gemm_r.h"
#undef BASE
}
 8007706:	b009      	add	sp, #36	; 0x24
 8007708:	ecbd 8b02 	vpop	{d8}
 800770c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007710:	f020 b99a 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8007714:	3865      	subs	r0, #101	; 0x65
 8007716:	2801      	cmp	r0, #1
 8007718:	bf94      	ite	ls
 800771a:	2000      	movls	r0, #0
 800771c:	2001      	movhi	r0, #1
 800771e:	2170      	movs	r1, #112	; 0x70
 8007720:	e794      	b.n	800764c <cblas_sgemm+0x50>
 8007722:	2a71      	cmp	r2, #113	; 0x71
 8007724:	f000 8208 	beq.w	8007b38 <cblas_sgemm+0x53c>
 8007728:	4659      	mov	r1, fp
 800772a:	2270      	movs	r2, #112	; 0x70
 800772c:	f1aa 0065 	sub.w	r0, sl, #101	; 0x65
 8007730:	2801      	cmp	r0, #1
 8007732:	bf94      	ite	ls
 8007734:	2000      	movls	r0, #0
 8007736:	2001      	movhi	r0, #1
 8007738:	e788      	b.n	800764c <cblas_sgemm+0x50>
 800773a:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 800773e:	f04f 0006 	mov.w	r0, #6
 8007742:	d05d      	beq.n	8007800 <cblas_sgemm+0x204>
 8007744:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8007748:	d11c      	bne.n	8007784 <cblas_sgemm+0x188>
 800774a:	2a6f      	cmp	r2, #111	; 0x6f
 800774c:	bf0c      	ite	eq
 800774e:	463b      	moveq	r3, r7
 8007750:	4633      	movne	r3, r6
 8007752:	2b01      	cmp	r3, #1
 8007754:	9a02      	ldr	r2, [sp, #8]
 8007756:	bfb8      	it	lt
 8007758:	2301      	movlt	r3, #1
 800775a:	4293      	cmp	r3, r2
 800775c:	bfc8      	it	gt
 800775e:	200b      	movgt	r0, #11
 8007760:	296f      	cmp	r1, #111	; 0x6f
 8007762:	f000 80e7 	beq.w	8007934 <cblas_sgemm+0x338>
 8007766:	2f01      	cmp	r7, #1
 8007768:	463b      	mov	r3, r7
 800776a:	bfb8      	it	lt
 800776c:	2301      	movlt	r3, #1
 800776e:	4543      	cmp	r3, r8
 8007770:	f300 8103 	bgt.w	800797a <cblas_sgemm+0x37e>
 8007774:	2d01      	cmp	r5, #1
 8007776:	462b      	mov	r3, r5
 8007778:	bfb8      	it	lt
 800777a:	2301      	movlt	r3, #1
 800777c:	4599      	cmp	r9, r3
 800777e:	f6bf af79 	bge.w	8007674 <cblas_sgemm+0x78>
 8007782:	200e      	movs	r0, #14
 8007784:	4a92      	ldr	r2, [pc, #584]	; (80079d0 <cblas_sgemm+0x3d4>)
 8007786:	4991      	ldr	r1, [pc, #580]	; (80079cc <cblas_sgemm+0x3d0>)
 8007788:	f020 f95e 	bl	8027a48 <cblas_xerbla>
 800778c:	e775      	b.n	800767a <cblas_sgemm+0x7e>
  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 800778e:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8007792:	f000 80fb 	beq.w	800798c <cblas_sgemm+0x390>
  } else if (TransF == CblasNoTrans && TransG == CblasTrans) {
 8007796:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800779a:	d1b1      	bne.n	8007700 <cblas_sgemm+0x104>
    for (i = 0; i < n1; i++) {
 800779c:	2e00      	cmp	r6, #0
 800779e:	f300 8147 	bgt.w	8007a30 <cblas_sgemm+0x434>
 80077a2:	b009      	add	sp, #36	; 0x24
 80077a4:	ecbd 8b02 	vpop	{d8}
 80077a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 80077ac:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80077b0:	eef4 8a67 	vcmp.f32	s17, s15
 80077b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80077b8:	d098      	beq.n	80076ec <cblas_sgemm+0xf0>
    for (i = 0; i < n1; i++) {
 80077ba:	2e00      	cmp	r6, #0
 80077bc:	dd96      	ble.n	80076ec <cblas_sgemm+0xf0>
 80077be:	9b01      	ldr	r3, [sp, #4]
 80077c0:	ebc5 7485 	rsb	r4, r5, r5, lsl #30
 80077c4:	00a4      	lsls	r4, r4, #2
 80077c6:	ea4f 0c89 	mov.w	ip, r9, lsl #2
 80077ca:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 80077ce:	2000      	movs	r0, #0
      for (j = 0; j < n2; j++) {
 80077d0:	2d00      	cmp	r5, #0
 80077d2:	bfc8      	it	gt
 80077d4:	1913      	addgt	r3, r2, r4
 80077d6:	dd07      	ble.n	80077e8 <cblas_sgemm+0x1ec>
        C[ldc * i + j] *= beta;
 80077d8:	edd3 7a00 	vldr	s15, [r3]
 80077dc:	ee67 7aa8 	vmul.f32	s15, s15, s17
 80077e0:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j < n2; j++) {
 80077e4:	4293      	cmp	r3, r2
 80077e6:	d1f7      	bne.n	80077d8 <cblas_sgemm+0x1dc>
    for (i = 0; i < n1; i++) {
 80077e8:	3001      	adds	r0, #1
 80077ea:	4286      	cmp	r6, r0
 80077ec:	4462      	add	r2, ip
 80077ee:	d1ef      	bne.n	80077d0 <cblas_sgemm+0x1d4>
 80077f0:	e77c      	b.n	80076ec <cblas_sgemm+0xf0>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80077f2:	2f00      	cmp	r7, #0
 80077f4:	dba1      	blt.n	800773a <cblas_sgemm+0x13e>
 80077f6:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 80077fa:	f04f 0005 	mov.w	r0, #5
 80077fe:	d1a1      	bne.n	8007744 <cblas_sgemm+0x148>
 8007800:	2a6f      	cmp	r2, #111	; 0x6f
 8007802:	bf0c      	ite	eq
 8007804:	463b      	moveq	r3, r7
 8007806:	462b      	movne	r3, r5
 8007808:	2b01      	cmp	r3, #1
 800780a:	bfb8      	it	lt
 800780c:	2301      	movlt	r3, #1
 800780e:	4543      	cmp	r3, r8
 8007810:	bfc8      	it	gt
 8007812:	2009      	movgt	r0, #9
 8007814:	296f      	cmp	r1, #111	; 0x6f
 8007816:	f000 80a3 	beq.w	8007960 <cblas_sgemm+0x364>
 800781a:	2f01      	cmp	r7, #1
 800781c:	9a02      	ldr	r2, [sp, #8]
 800781e:	463b      	mov	r3, r7
 8007820:	bfb8      	it	lt
 8007822:	2301      	movlt	r3, #1
 8007824:	4293      	cmp	r3, r2
 8007826:	dd7c      	ble.n	8007922 <cblas_sgemm+0x326>
 8007828:	2e01      	cmp	r6, #1
 800782a:	4630      	mov	r0, r6
 800782c:	bfb8      	it	lt
 800782e:	2001      	movlt	r0, #1
 8007830:	4a67      	ldr	r2, [pc, #412]	; (80079d0 <cblas_sgemm+0x3d4>)
 8007832:	4966      	ldr	r1, [pc, #408]	; (80079cc <cblas_sgemm+0x3d0>)
 8007834:	4581      	cmp	r9, r0
 8007836:	bfb4      	ite	lt
 8007838:	200e      	movlt	r0, #14
 800783a:	200b      	movge	r0, #11
 800783c:	f020 f904 	bl	8027a48 <cblas_xerbla>
 8007840:	e71b      	b.n	800767a <cblas_sgemm+0x7e>
 8007842:	2971      	cmp	r1, #113	; 0x71
 8007844:	f43f af6d 	beq.w	8007722 <cblas_sgemm+0x126>
 8007848:	2a71      	cmp	r2, #113	; 0x71
 800784a:	d07f      	beq.n	800794c <cblas_sgemm+0x350>
 800784c:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8007850:	b2db      	uxtb	r3, r3
 8007852:	2b02      	cmp	r3, #2
 8007854:	4611      	mov	r1, r2
 8007856:	4622      	mov	r2, r4
 8007858:	f63f aef7 	bhi.w	800764a <cblas_sgemm+0x4e>
 800785c:	e766      	b.n	800772c <cblas_sgemm+0x130>
    TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800785e:	2c71      	cmp	r4, #113	; 0x71
 8007860:	e9dd 2002 	ldrd	r2, r0, [sp, #8]
 8007864:	bf18      	it	ne
 8007866:	4621      	movne	r1, r4
    F = A;
 8007868:	9c04      	ldr	r4, [sp, #16]
    G = B;
 800786a:	9004      	str	r0, [sp, #16]
 800786c:	bf08      	it	eq
 800786e:	2170      	moveq	r1, #112	; 0x70
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 8007870:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8007874:	e9cd 8402 	strd	r8, r4, [sp, #8]
 8007878:	4633      	mov	r3, r6
 800787a:	4690      	mov	r8, r2
 800787c:	462e      	mov	r6, r5
 800787e:	d055      	beq.n	800792c <cblas_sgemm+0x330>
 8007880:	461d      	mov	r5, r3
 8007882:	e715      	b.n	80076b0 <cblas_sgemm+0xb4>
  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 8007884:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8007888:	f000 810f 	beq.w	8007aaa <cblas_sgemm+0x4ae>
  } else if (TransF == CblasTrans && TransG == CblasTrans) {
 800788c:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 8007890:	f47f af36 	bne.w	8007700 <cblas_sgemm+0x104>
    for (i = 0; i < n1; i++) {
 8007894:	2e00      	cmp	r6, #0
 8007896:	dd84      	ble.n	80077a2 <cblas_sgemm+0x1a6>
 8007898:	ea4f 0189 	mov.w	r1, r9, lsl #2
 800789c:	e9dd 2a02 	ldrd	r2, sl, [sp, #8]
 80078a0:	9102      	str	r1, [sp, #8]
 80078a2:	9901      	ldr	r1, [sp, #4]
 80078a4:	f8cd 9014 	str.w	r9, [sp, #20]
 80078a8:	eb01 0e85 	add.w	lr, r1, r5, lsl #2
 80078ac:	9904      	ldr	r1, [sp, #16]
 80078ae:	2300      	movs	r3, #0
 80078b0:	eb01 0087 	add.w	r0, r1, r7, lsl #2
 80078b4:	e9cd 5603 	strd	r5, r6, [sp, #12]
 80078b8:	0094      	lsls	r4, r2, #2
 80078ba:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 80078be:	9006      	str	r0, [sp, #24]
 80078c0:	469c      	mov	ip, r3
 80078c2:	460e      	mov	r6, r1
 80078c4:	4699      	mov	r9, r3
      for (j = 0; j < n2; j++) {
 80078c6:	9b03      	ldr	r3, [sp, #12]
 80078c8:	2b00      	cmp	r3, #0
 80078ca:	dd1e      	ble.n	800790a <cblas_sgemm+0x30e>
 80078cc:	9b01      	ldr	r3, [sp, #4]
 80078ce:	9906      	ldr	r1, [sp, #24]
 80078d0:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 80078d4:	2500      	movs	r5, #0
        for (k = 0; k < K; k++) {
 80078d6:	2f00      	cmp	r7, #0
        BASE temp = 0.0;
 80078d8:	eddf 7a3e 	vldr	s15, [pc, #248]	; 80079d4 <cblas_sgemm+0x3d8>
        for (k = 0; k < K; k++) {
 80078dc:	dd0b      	ble.n	80078f6 <cblas_sgemm+0x2fa>
 80078de:	eb06 0285 	add.w	r2, r6, r5, lsl #2
 80078e2:	4653      	mov	r3, sl
          temp += F[ldf * k + i] * G[ldg * j + k];
 80078e4:	ecb2 7a01 	vldmia	r2!, {s14}
 80078e8:	edd3 6a00 	vldr	s13, [r3]
        for (k = 0; k < K; k++) {
 80078ec:	428a      	cmp	r2, r1
          temp += F[ldf * k + i] * G[ldg * j + k];
 80078ee:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 80078f2:	4423      	add	r3, r4
 80078f4:	d1f6      	bne.n	80078e4 <cblas_sgemm+0x2e8>
        C[ldc * i + j] += alpha * temp;
 80078f6:	ed90 7a00 	vldr	s14, [r0]
 80078fa:	eea8 7a27 	vfma.f32	s14, s16, s15
 80078fe:	4445      	add	r5, r8
 8007900:	4459      	add	r1, fp
 8007902:	eca0 7a01 	vstmia	r0!, {s14}
      for (j = 0; j < n2; j++) {
 8007906:	4570      	cmp	r0, lr
 8007908:	d1e5      	bne.n	80078d6 <cblas_sgemm+0x2da>
    for (i = 0; i < n1; i++) {
 800790a:	9b05      	ldr	r3, [sp, #20]
 800790c:	4499      	add	r9, r3
 800790e:	9b02      	ldr	r3, [sp, #8]
 8007910:	449e      	add	lr, r3
 8007912:	9b04      	ldr	r3, [sp, #16]
 8007914:	f10c 0c01 	add.w	ip, ip, #1
 8007918:	4563      	cmp	r3, ip
 800791a:	f10a 0a04 	add.w	sl, sl, #4
 800791e:	d1d2      	bne.n	80078c6 <cblas_sgemm+0x2ca>
 8007920:	e73f      	b.n	80077a2 <cblas_sgemm+0x1a6>
 8007922:	2e01      	cmp	r6, #1
 8007924:	4633      	mov	r3, r6
 8007926:	bfb8      	it	lt
 8007928:	2301      	movlt	r3, #1
 800792a:	e727      	b.n	800777c <cblas_sgemm+0x180>
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800792c:	f04f 0b70 	mov.w	fp, #112	; 0x70
 8007930:	461d      	mov	r5, r3
 8007932:	e6bd      	b.n	80076b0 <cblas_sgemm+0xb4>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8007934:	2d01      	cmp	r5, #1
 8007936:	462b      	mov	r3, r5
 8007938:	bfb8      	it	lt
 800793a:	2301      	movlt	r3, #1
 800793c:	4543      	cmp	r3, r8
 800793e:	f77f af1d 	ble.w	800777c <cblas_sgemm+0x180>
 8007942:	454b      	cmp	r3, r9
 8007944:	bfcc      	ite	gt
 8007946:	200e      	movgt	r0, #14
 8007948:	2009      	movle	r0, #9
 800794a:	e71b      	b.n	8007784 <cblas_sgemm+0x188>
 800794c:	460a      	mov	r2, r1
 800794e:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8007952:	b2db      	uxtb	r3, r3
 8007954:	2b02      	cmp	r3, #2
 8007956:	bf8c      	ite	hi
 8007958:	2002      	movhi	r0, #2
 800795a:	2000      	movls	r0, #0
 800795c:	2170      	movs	r1, #112	; 0x70
 800795e:	e67a      	b.n	8007656 <cblas_sgemm+0x5a>
 8007960:	2e01      	cmp	r6, #1
 8007962:	9a02      	ldr	r2, [sp, #8]
 8007964:	4633      	mov	r3, r6
 8007966:	bfb8      	it	lt
 8007968:	2301      	movlt	r3, #1
 800796a:	4293      	cmp	r3, r2
 800796c:	f77f af06 	ble.w	800777c <cblas_sgemm+0x180>
 8007970:	454b      	cmp	r3, r9
 8007972:	bfcc      	ite	gt
 8007974:	200e      	movgt	r0, #14
 8007976:	200b      	movle	r0, #11
 8007978:	e704      	b.n	8007784 <cblas_sgemm+0x188>
 800797a:	2d01      	cmp	r5, #1
 800797c:	4628      	mov	r0, r5
 800797e:	bfb8      	it	lt
 8007980:	2001      	movlt	r0, #1
 8007982:	4581      	cmp	r9, r0
 8007984:	bfb4      	ite	lt
 8007986:	200e      	movlt	r0, #14
 8007988:	2009      	movge	r0, #9
 800798a:	e6fb      	b.n	8007784 <cblas_sgemm+0x188>
    for (k = 0; k < K; k++) {
 800798c:	2f00      	cmp	r7, #0
 800798e:	f77f af08 	ble.w	80077a2 <cblas_sgemm+0x1a6>
 8007992:	ea4f 0388 	mov.w	r3, r8, lsl #2
 8007996:	9305      	str	r3, [sp, #20]
 8007998:	9b02      	ldr	r3, [sp, #8]
 800799a:	f8dd a010 	ldr.w	sl, [sp, #16]
 800799e:	ea4f 0883 	mov.w	r8, r3, lsl #2
 80079a2:	9b01      	ldr	r3, [sp, #4]
 80079a4:	9701      	str	r7, [sp, #4]
 80079a6:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 80079aa:	ea4f 0e89 	mov.w	lr, r9, lsl #2
 80079ae:	9202      	str	r2, [sp, #8]
 80079b0:	f04f 0b00 	mov.w	fp, #0
 80079b4:	469c      	mov	ip, r3
      for (i = 0; i < n1; i++) {
 80079b6:	2e00      	cmp	r6, #0
 80079b8:	dd32      	ble.n	8007a20 <cblas_sgemm+0x424>
 80079ba:	9b03      	ldr	r3, [sp, #12]
 80079bc:	9902      	ldr	r1, [sp, #8]
 80079be:	2700      	movs	r7, #0
 80079c0:	463c      	mov	r4, r7
 80079c2:	eb03 008b 	add.w	r0, r3, fp, lsl #2
 80079c6:	e00d      	b.n	80079e4 <cblas_sgemm+0x3e8>
 80079c8:	080305a8 	.word	0x080305a8
 80079cc:	08030598 	.word	0x08030598
 80079d0:	08030378 	.word	0x08030378
 80079d4:	00000000 	.word	0x00000000
 80079d8:	3401      	adds	r4, #1
 80079da:	42a6      	cmp	r6, r4
 80079dc:	4440      	add	r0, r8
 80079de:	444f      	add	r7, r9
 80079e0:	4471      	add	r1, lr
 80079e2:	d01d      	beq.n	8007a20 <cblas_sgemm+0x424>
        const BASE temp = alpha * F[ldf * i + k];
 80079e4:	ed90 7a00 	vldr	s14, [r0]
 80079e8:	ee28 7a07 	vmul.f32	s14, s16, s14
        if (temp != 0.0) {
 80079ec:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80079f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80079f4:	d0f0      	beq.n	80079d8 <cblas_sgemm+0x3dc>
          for (j = 0; j < n2; j++) {
 80079f6:	2d00      	cmp	r5, #0
 80079f8:	ddee      	ble.n	80079d8 <cblas_sgemm+0x3dc>
 80079fa:	eb0c 0387 	add.w	r3, ip, r7, lsl #2
 80079fe:	4652      	mov	r2, sl
            C[ldc * i + j] += temp * G[ldg * k + j];
 8007a00:	edd3 7a00 	vldr	s15, [r3]
 8007a04:	ecf2 6a01 	vldmia	r2!, {s13}
 8007a08:	eee6 7a87 	vfma.f32	s15, s13, s14
 8007a0c:	ece3 7a01 	vstmia	r3!, {s15}
          for (j = 0; j < n2; j++) {
 8007a10:	4299      	cmp	r1, r3
 8007a12:	d1f5      	bne.n	8007a00 <cblas_sgemm+0x404>
      for (i = 0; i < n1; i++) {
 8007a14:	3401      	adds	r4, #1
 8007a16:	42a6      	cmp	r6, r4
 8007a18:	4440      	add	r0, r8
 8007a1a:	444f      	add	r7, r9
 8007a1c:	4471      	add	r1, lr
 8007a1e:	d1e1      	bne.n	80079e4 <cblas_sgemm+0x3e8>
    for (k = 0; k < K; k++) {
 8007a20:	9b05      	ldr	r3, [sp, #20]
 8007a22:	449a      	add	sl, r3
 8007a24:	9b01      	ldr	r3, [sp, #4]
 8007a26:	f10b 0b01 	add.w	fp, fp, #1
 8007a2a:	455b      	cmp	r3, fp
 8007a2c:	d1c3      	bne.n	80079b6 <cblas_sgemm+0x3ba>
 8007a2e:	e6b8      	b.n	80077a2 <cblas_sgemm+0x1a6>
 8007a30:	ea4f 0289 	mov.w	r2, r9, lsl #2
 8007a34:	9b02      	ldr	r3, [sp, #8]
 8007a36:	9202      	str	r2, [sp, #8]
 8007a38:	9a01      	ldr	r2, [sp, #4]
 8007a3a:	f8dd e00c 	ldr.w	lr, [sp, #12]
 8007a3e:	9503      	str	r5, [sp, #12]
    for (i = 0; i < n1; i++) {
 8007a40:	f04f 0a00 	mov.w	sl, #0
 8007a44:	009b      	lsls	r3, r3, #2
 8007a46:	eb02 0c85 	add.w	ip, r2, r5, lsl #2
 8007a4a:	9d04      	ldr	r5, [sp, #16]
 8007a4c:	9605      	str	r6, [sp, #20]
 8007a4e:	eb0e 0187 	add.w	r1, lr, r7, lsl #2
 8007a52:	46d3      	mov	fp, sl
 8007a54:	461e      	mov	r6, r3
      for (j = 0; j < n2; j++) {
 8007a56:	9b03      	ldr	r3, [sp, #12]
 8007a58:	2b00      	cmp	r3, #0
 8007a5a:	dd1b      	ble.n	8007a94 <cblas_sgemm+0x498>
 8007a5c:	9b01      	ldr	r3, [sp, #4]
 8007a5e:	2400      	movs	r4, #0
 8007a60:	eb03 008a 	add.w	r0, r3, sl, lsl #2
        for (k = 0; k < K; k++) {
 8007a64:	2f00      	cmp	r7, #0
        BASE temp = 0.0;
 8007a66:	ed5f 7a25 	vldr	s15, [pc, #-148]	; 80079d4 <cblas_sgemm+0x3d8>
        for (k = 0; k < K; k++) {
 8007a6a:	dd0a      	ble.n	8007a82 <cblas_sgemm+0x486>
 8007a6c:	eb05 0284 	add.w	r2, r5, r4, lsl #2
 8007a70:	4673      	mov	r3, lr
          temp += F[ldf * i + k] * G[ldg * j + k];
 8007a72:	ecf3 6a01 	vldmia	r3!, {s13}
 8007a76:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < K; k++) {
 8007a7a:	4299      	cmp	r1, r3
          temp += F[ldf * i + k] * G[ldg * j + k];
 8007a7c:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 8007a80:	d1f7      	bne.n	8007a72 <cblas_sgemm+0x476>
        C[ldc * i + j] += alpha * temp;
 8007a82:	ed90 7a00 	vldr	s14, [r0]
 8007a86:	eea8 7a27 	vfma.f32	s14, s16, s15
 8007a8a:	4444      	add	r4, r8
 8007a8c:	eca0 7a01 	vstmia	r0!, {s14}
      for (j = 0; j < n2; j++) {
 8007a90:	4584      	cmp	ip, r0
 8007a92:	d1e7      	bne.n	8007a64 <cblas_sgemm+0x468>
    for (i = 0; i < n1; i++) {
 8007a94:	9b02      	ldr	r3, [sp, #8]
 8007a96:	449c      	add	ip, r3
 8007a98:	9b05      	ldr	r3, [sp, #20]
 8007a9a:	f10b 0b01 	add.w	fp, fp, #1
 8007a9e:	455b      	cmp	r3, fp
 8007aa0:	44ca      	add	sl, r9
 8007aa2:	44b6      	add	lr, r6
 8007aa4:	4431      	add	r1, r6
 8007aa6:	d1d6      	bne.n	8007a56 <cblas_sgemm+0x45a>
 8007aa8:	e67b      	b.n	80077a2 <cblas_sgemm+0x1a6>
    for (k = 0; k < K; k++) {
 8007aaa:	2f00      	cmp	r7, #0
 8007aac:	f77f ae79 	ble.w	80077a2 <cblas_sgemm+0x1a6>
 8007ab0:	9b02      	ldr	r3, [sp, #8]
 8007ab2:	009b      	lsls	r3, r3, #2
 8007ab4:	9305      	str	r3, [sp, #20]
 8007ab6:	9b03      	ldr	r3, [sp, #12]
 8007ab8:	f04f 0e00 	mov.w	lr, #0
 8007abc:	e9cd 6706 	strd	r6, r7, [sp, #24]
 8007ac0:	eb03 0c86 	add.w	ip, r3, r6, lsl #2
 8007ac4:	9e01      	ldr	r6, [sp, #4]
 8007ac6:	46f2      	mov	sl, lr
 8007ac8:	46f3      	mov	fp, lr
      for (i = 0; i < n1; i++) {
 8007aca:	9b06      	ldr	r3, [sp, #24]
 8007acc:	2b00      	cmp	r3, #0
 8007ace:	dd28      	ble.n	8007b22 <cblas_sgemm+0x526>
 8007ad0:	9b03      	ldr	r3, [sp, #12]
 8007ad2:	eb03 018a 	add.w	r1, r3, sl, lsl #2
 8007ad6:	9b04      	ldr	r3, [sp, #16]
 8007ad8:	2400      	movs	r4, #0
 8007ada:	eb03 078e 	add.w	r7, r3, lr, lsl #2
 8007ade:	e002      	b.n	8007ae6 <cblas_sgemm+0x4ea>
 8007ae0:	458c      	cmp	ip, r1
 8007ae2:	444c      	add	r4, r9
 8007ae4:	d01d      	beq.n	8007b22 <cblas_sgemm+0x526>
        const BASE temp = alpha * F[ldf * k + i];
 8007ae6:	ecb1 7a01 	vldmia	r1!, {s14}
 8007aea:	ee27 7a08 	vmul.f32	s14, s14, s16
        if (temp != 0.0) {
 8007aee:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8007af2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007af6:	d0f3      	beq.n	8007ae0 <cblas_sgemm+0x4e4>
          for (j = 0; j < n2; j++) {
 8007af8:	2d00      	cmp	r5, #0
 8007afa:	ddf1      	ble.n	8007ae0 <cblas_sgemm+0x4e4>
 8007afc:	1928      	adds	r0, r5, r4
 8007afe:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8007b02:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 8007b06:	463a      	mov	r2, r7
            C[ldc * i + j] += temp * G[ldg * k + j];
 8007b08:	edd3 7a00 	vldr	s15, [r3]
 8007b0c:	ecf2 6a01 	vldmia	r2!, {s13}
 8007b10:	eee6 7a87 	vfma.f32	s15, s13, s14
 8007b14:	ece3 7a01 	vstmia	r3!, {s15}
          for (j = 0; j < n2; j++) {
 8007b18:	4283      	cmp	r3, r0
 8007b1a:	d1f5      	bne.n	8007b08 <cblas_sgemm+0x50c>
      for (i = 0; i < n1; i++) {
 8007b1c:	458c      	cmp	ip, r1
 8007b1e:	444c      	add	r4, r9
 8007b20:	d1e1      	bne.n	8007ae6 <cblas_sgemm+0x4ea>
    for (k = 0; k < K; k++) {
 8007b22:	9b05      	ldr	r3, [sp, #20]
 8007b24:	449c      	add	ip, r3
 8007b26:	9b02      	ldr	r3, [sp, #8]
 8007b28:	449a      	add	sl, r3
 8007b2a:	9b07      	ldr	r3, [sp, #28]
 8007b2c:	f10b 0b01 	add.w	fp, fp, #1
 8007b30:	455b      	cmp	r3, fp
 8007b32:	44c6      	add	lr, r8
 8007b34:	d1c9      	bne.n	8007aca <cblas_sgemm+0x4ce>
 8007b36:	e634      	b.n	80077a2 <cblas_sgemm+0x1a6>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8007b38:	2270      	movs	r2, #112	; 0x70
 8007b3a:	e708      	b.n	800794e <cblas_sgemm+0x352>

08007b3c <cblas_sgemv>:
void
cblas_sgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const float alpha, const float *A,
             const int lda, const float *X, const int incX, const float beta,
             float *Y, const int incY)
{
 8007b3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007b40:	ed2d 8b02 	vpush	{d8}
 8007b44:	b083      	sub	sp, #12
 8007b46:	461e      	mov	r6, r3

{
  INDEX i, j;
  INDEX lenX, lenY;

  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8007b48:	2971      	cmp	r1, #113	; 0x71
 8007b4a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8007b4c:	9301      	str	r3, [sp, #4]
 8007b4e:	e9dd ba0e 	ldrd	fp, sl, [sp, #56]	; 0x38
 8007b52:	e9dd 7311 	ldrd	r7, r3, [sp, #68]	; 0x44
 8007b56:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
 8007b5a:	4680      	mov	r8, r0
 8007b5c:	4614      	mov	r4, r2
 8007b5e:	eeb0 8a40 	vmov.f32	s16, s0
 8007b62:	eef0 8a60 	vmov.f32	s17, s1
 8007b66:	f000 80d8 	beq.w	8007d1a <cblas_sgemv+0x1de>

  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8007b6a:	f1a1 026f 	sub.w	r2, r1, #111	; 0x6f
 8007b6e:	2a02      	cmp	r2, #2
 8007b70:	460d      	mov	r5, r1
 8007b72:	f240 80ee 	bls.w	8007d52 <cblas_sgemv+0x216>
 8007b76:	2002      	movs	r0, #2
 8007b78:	2c00      	cmp	r4, #0
 8007b7a:	bfb8      	it	lt
 8007b7c:	2003      	movlt	r0, #3
 8007b7e:	2e00      	cmp	r6, #0
 8007b80:	bfb8      	it	lt
 8007b82:	2004      	movlt	r0, #4
 8007b84:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 8007b88:	f000 80bc 	beq.w	8007d04 <cblas_sgemv+0x1c8>
 8007b8c:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 8007b90:	f000 80a8 	beq.w	8007ce4 <cblas_sgemv+0x1a8>
 8007b94:	2f00      	cmp	r7, #0
 8007b96:	f040 809e 	bne.w	8007cd6 <cblas_sgemv+0x19a>
 8007b9a:	f1b9 0f00 	cmp.w	r9, #0
 8007b9e:	bf14      	ite	ne
 8007ba0:	2009      	movne	r0, #9
 8007ba2:	200c      	moveq	r0, #12
 8007ba4:	4a9d      	ldr	r2, [pc, #628]	; (8007e1c <cblas_sgemv+0x2e0>)
 8007ba6:	499e      	ldr	r1, [pc, #632]	; (8007e20 <cblas_sgemv+0x2e4>)
 8007ba8:	9300      	str	r3, [sp, #0]
 8007baa:	f01f ff4d 	bl	8027a48 <cblas_xerbla>
 8007bae:	9b00      	ldr	r3, [sp, #0]

  if (M == 0 || N == 0)
 8007bb0:	2c00      	cmp	r4, #0
 8007bb2:	f000 808b 	beq.w	8007ccc <cblas_sgemv+0x190>
 8007bb6:	2e00      	cmp	r6, #0
 8007bb8:	f000 8088 	beq.w	8007ccc <cblas_sgemv+0x190>
    return;

  if (alpha == 0.0 && beta == 1.0)
 8007bbc:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8007bc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007bc4:	d106      	bne.n	8007bd4 <cblas_sgemv+0x98>
 8007bc6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8007bca:	eef4 8a67 	vcmp.f32	s17, s15
 8007bce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007bd2:	d07b      	beq.n	8007ccc <cblas_sgemv+0x190>
    return;

  if (Trans == CblasNoTrans) {
 8007bd4:	2d6f      	cmp	r5, #111	; 0x6f
 8007bd6:	d002      	beq.n	8007bde <cblas_sgemv+0xa2>
 8007bd8:	4632      	mov	r2, r6
 8007bda:	4626      	mov	r6, r4
 8007bdc:	4614      	mov	r4, r2
    lenX = M;
    lenY = N;
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 8007bde:	eef5 8a40 	vcmp.f32	s17, #0.0
 8007be2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007be6:	f000 809f 	beq.w	8007d28 <cblas_sgemv+0x1ec>
    INDEX iy = OFFSET(lenY, incY);
    for (i = 0; i < lenY; i++) {
      Y[iy] = 0.0;
      iy += incY;
    }
  } else if (beta != 1.0) {
 8007bea:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8007bee:	eef4 8a67 	vcmp.f32	s17, s15
 8007bf2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007bf6:	d015      	beq.n	8007c24 <cblas_sgemv+0xe8>
    INDEX iy = OFFSET(lenY, incY);
 8007bf8:	f1b9 0f00 	cmp.w	r9, #0
 8007bfc:	f340 8109 	ble.w	8007e12 <cblas_sgemv+0x2d6>
 8007c00:	2200      	movs	r2, #0
    for (i = 0; i < lenY; i++) {
 8007c02:	2c00      	cmp	r4, #0
 8007c04:	dd0e      	ble.n	8007c24 <cblas_sgemv+0xe8>
 8007c06:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8007c0a:	ea4f 0089 	mov.w	r0, r9, lsl #2
 8007c0e:	2100      	movs	r1, #0
      Y[iy] *= beta;
 8007c10:	edd2 7a00 	vldr	s15, [r2]
    for (i = 0; i < lenY; i++) {
 8007c14:	3101      	adds	r1, #1
      Y[iy] *= beta;
 8007c16:	ee67 7aa8 	vmul.f32	s15, s15, s17
    for (i = 0; i < lenY; i++) {
 8007c1a:	428c      	cmp	r4, r1
      Y[iy] *= beta;
 8007c1c:	edc2 7a00 	vstr	s15, [r2]
    for (i = 0; i < lenY; i++) {
 8007c20:	4402      	add	r2, r0
 8007c22:	d1f5      	bne.n	8007c10 <cblas_sgemv+0xd4>
      iy += incY;
    }
  }

  if (alpha == 0.0)
 8007c24:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8007c28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007c2c:	d04e      	beq.n	8007ccc <cblas_sgemv+0x190>
    return;

  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 8007c2e:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 8007c32:	f000 8096 	beq.w	8007d62 <cblas_sgemv+0x226>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 8007c36:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 8007c3a:	d009      	beq.n	8007c50 <cblas_sgemv+0x114>
        }
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8007c3c:	4a79      	ldr	r2, [pc, #484]	; (8007e24 <cblas_sgemv+0x2e8>)
 8007c3e:	4978      	ldr	r1, [pc, #480]	; (8007e20 <cblas_sgemv+0x2e4>)
 8007c40:	2000      	movs	r0, #0
#define BASE float
#include "source_gemv_r.h"
#undef BASE
}
 8007c42:	b003      	add	sp, #12
 8007c44:	ecbd 8b02 	vpop	{d8}
 8007c48:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007c4c:	f01f befc 	b.w	8027a48 <cblas_xerbla>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 8007c50:	2d70      	cmp	r5, #112	; 0x70
 8007c52:	f040 80d0 	bne.w	8007df6 <cblas_sgemv+0x2ba>
    INDEX iy = OFFSET(lenY, incY);
 8007c56:	f1b9 0f00 	cmp.w	r9, #0
 8007c5a:	f340 80d0 	ble.w	8007dfe <cblas_sgemv+0x2c2>
 8007c5e:	2000      	movs	r0, #0
    for (i = 0; i < lenY; i++) {
 8007c60:	2c00      	cmp	r4, #0
 8007c62:	dd33      	ble.n	8007ccc <cblas_sgemv+0x190>
 8007c64:	2f00      	cmp	r7, #0
 8007c66:	f1c6 0e01 	rsb	lr, r6, #1
 8007c6a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8007c6e:	9b01      	ldr	r3, [sp, #4]
 8007c70:	fb0e fe07 	mul.w	lr, lr, r7
      INDEX ix = OFFSET(lenX, incX);
 8007c74:	f04f 0500 	mov.w	r5, #0
 8007c78:	bfc8      	it	gt
 8007c7a:	f04f 0e00 	movgt.w	lr, #0
 8007c7e:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8007c82:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 8007c86:	00bf      	lsls	r7, r7, #2
 8007c88:	46ac      	mov	ip, r5
 8007c8a:	ea4f 088a 	mov.w	r8, sl, lsl #2
 8007c8e:	eb0b 0186 	add.w	r1, fp, r6, lsl #2
      for (j = 0; j < lenX; j++) {
 8007c92:	2e00      	cmp	r6, #0
 8007c94:	eddf 7a64 	vldr	s15, [pc, #400]	; 8007e28 <cblas_sgemv+0x2ec>
 8007c98:	dd0b      	ble.n	8007cb2 <cblas_sgemv+0x176>
 8007c9a:	eb0b 0285 	add.w	r2, fp, r5, lsl #2
 8007c9e:	4673      	mov	r3, lr
        temp += X[ix] * A[lda * i + j];
 8007ca0:	ecb2 7a01 	vldmia	r2!, {s14}
 8007ca4:	edd3 6a00 	vldr	s13, [r3]
      for (j = 0; j < lenX; j++) {
 8007ca8:	4291      	cmp	r1, r2
        temp += X[ix] * A[lda * i + j];
 8007caa:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = 0; j < lenX; j++) {
 8007cae:	443b      	add	r3, r7
 8007cb0:	d1f6      	bne.n	8007ca0 <cblas_sgemv+0x164>
      Y[iy] += alpha * temp;
 8007cb2:	ed90 7a00 	vldr	s14, [r0]
 8007cb6:	eea8 7a27 	vfma.f32	s14, s16, s15
    for (i = 0; i < lenY; i++) {
 8007cba:	f10c 0c01 	add.w	ip, ip, #1
 8007cbe:	4564      	cmp	r4, ip
 8007cc0:	4455      	add	r5, sl
      Y[iy] += alpha * temp;
 8007cc2:	ed80 7a00 	vstr	s14, [r0]
    for (i = 0; i < lenY; i++) {
 8007cc6:	4441      	add	r1, r8
 8007cc8:	4448      	add	r0, r9
 8007cca:	d1e2      	bne.n	8007c92 <cblas_sgemv+0x156>
 8007ccc:	b003      	add	sp, #12
 8007cce:	ecbd 8b02 	vpop	{d8}
 8007cd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8007cd6:	f1b9 0f00 	cmp.w	r9, #0
 8007cda:	d040      	beq.n	8007d5e <cblas_sgemv+0x222>
 8007cdc:	2800      	cmp	r0, #0
 8007cde:	f43f af67 	beq.w	8007bb0 <cblas_sgemv+0x74>
 8007ce2:	e75f      	b.n	8007ba4 <cblas_sgemv+0x68>
 8007ce4:	2c01      	cmp	r4, #1
 8007ce6:	4622      	mov	r2, r4
 8007ce8:	bfb8      	it	lt
 8007cea:	2201      	movlt	r2, #1
 8007cec:	4552      	cmp	r2, sl
 8007cee:	f77f af51 	ble.w	8007b94 <cblas_sgemv+0x58>
 8007cf2:	2f00      	cmp	r7, #0
 8007cf4:	f43f af51 	beq.w	8007b9a <cblas_sgemv+0x5e>
 8007cf8:	f1b9 0f00 	cmp.w	r9, #0
 8007cfc:	bf14      	ite	ne
 8007cfe:	2007      	movne	r0, #7
 8007d00:	200c      	moveq	r0, #12
 8007d02:	e74f      	b.n	8007ba4 <cblas_sgemv+0x68>
 8007d04:	2e01      	cmp	r6, #1
 8007d06:	4632      	mov	r2, r6
 8007d08:	bfb8      	it	lt
 8007d0a:	2201      	movlt	r2, #1
 8007d0c:	4552      	cmp	r2, sl
 8007d0e:	f77f af41 	ble.w	8007b94 <cblas_sgemv+0x58>
 8007d12:	2f00      	cmp	r7, #0
 8007d14:	f43f af41 	beq.w	8007b9a <cblas_sgemv+0x5e>
 8007d18:	e7ee      	b.n	8007cf8 <cblas_sgemv+0x1bc>
 8007d1a:	3865      	subs	r0, #101	; 0x65
 8007d1c:	2801      	cmp	r0, #1
 8007d1e:	bf94      	ite	ls
 8007d20:	2000      	movls	r0, #0
 8007d22:	2001      	movhi	r0, #1
 8007d24:	2570      	movs	r5, #112	; 0x70
 8007d26:	e727      	b.n	8007b78 <cblas_sgemv+0x3c>
    INDEX iy = OFFSET(lenY, incY);
 8007d28:	f1b9 0f00 	cmp.w	r9, #0
 8007d2c:	dd5e      	ble.n	8007dec <cblas_sgemv+0x2b0>
 8007d2e:	2200      	movs	r2, #0
    for (i = 0; i < lenY; i++) {
 8007d30:	2c00      	cmp	r4, #0
 8007d32:	f77f af77 	ble.w	8007c24 <cblas_sgemv+0xe8>
      Y[iy] = 0.0;
 8007d36:	f04f 0c00 	mov.w	ip, #0
 8007d3a:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 8007d3e:	ea4f 0089 	mov.w	r0, r9, lsl #2
    for (i = 0; i < lenY; i++) {
 8007d42:	2100      	movs	r1, #0
 8007d44:	3101      	adds	r1, #1
 8007d46:	428c      	cmp	r4, r1
      Y[iy] = 0.0;
 8007d48:	f8c2 c000 	str.w	ip, [r2]
    for (i = 0; i < lenY; i++) {
 8007d4c:	4402      	add	r2, r0
 8007d4e:	d1f9      	bne.n	8007d44 <cblas_sgemv+0x208>
 8007d50:	e768      	b.n	8007c24 <cblas_sgemv+0xe8>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8007d52:	3865      	subs	r0, #101	; 0x65
 8007d54:	2801      	cmp	r0, #1
 8007d56:	bf94      	ite	ls
 8007d58:	2000      	movls	r0, #0
 8007d5a:	2001      	movhi	r0, #1
 8007d5c:	e70c      	b.n	8007b78 <cblas_sgemv+0x3c>
 8007d5e:	200c      	movs	r0, #12
 8007d60:	e720      	b.n	8007ba4 <cblas_sgemv+0x68>
  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 8007d62:	2d6f      	cmp	r5, #111	; 0x6f
 8007d64:	f43f af77 	beq.w	8007c56 <cblas_sgemv+0x11a>
  } else if ((order == CblasRowMajor && Trans == CblasTrans)
 8007d68:	2d70      	cmp	r5, #112	; 0x70
 8007d6a:	f47f af67 	bne.w	8007c3c <cblas_sgemv+0x100>
    INDEX ix = OFFSET(lenX, incX);
 8007d6e:	2f00      	cmp	r7, #0
 8007d70:	dd4a      	ble.n	8007e08 <cblas_sgemv+0x2cc>
 8007d72:	2000      	movs	r0, #0
    for (j = 0; j < lenX; j++) {
 8007d74:	2e00      	cmp	r6, #0
 8007d76:	dda9      	ble.n	8007ccc <cblas_sgemv+0x190>
 8007d78:	f1b9 0f00 	cmp.w	r9, #0
 8007d7c:	9a01      	ldr	r2, [sp, #4]
 8007d7e:	f1c4 0e01 	rsb	lr, r4, #1
 8007d82:	fb0e fe09 	mul.w	lr, lr, r9
        INDEX iy = OFFSET(lenY, incY);
 8007d86:	f04f 0500 	mov.w	r5, #0
 8007d8a:	bfc8      	it	gt
 8007d8c:	f04f 0e00 	movgt.w	lr, #0
 8007d90:	00bf      	lsls	r7, r7, #2
 8007d92:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 8007d96:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 8007d9a:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8007d9e:	46ac      	mov	ip, r5
 8007da0:	ea4f 088a 	mov.w	r8, sl, lsl #2
 8007da4:	eb0b 0184 	add.w	r1, fp, r4, lsl #2
 8007da8:	e006      	b.n	8007db8 <cblas_sgemv+0x27c>
    for (j = 0; j < lenX; j++) {
 8007daa:	f10c 0c01 	add.w	ip, ip, #1
 8007dae:	4566      	cmp	r6, ip
 8007db0:	4438      	add	r0, r7
 8007db2:	4455      	add	r5, sl
 8007db4:	4441      	add	r1, r8
 8007db6:	d089      	beq.n	8007ccc <cblas_sgemv+0x190>
      const BASE temp = alpha * X[ix];
 8007db8:	ed90 7a00 	vldr	s14, [r0]
 8007dbc:	ee28 7a07 	vmul.f32	s14, s16, s14
      if (temp != 0.0) {
 8007dc0:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8007dc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8007dc8:	d0ef      	beq.n	8007daa <cblas_sgemv+0x26e>
        for (i = 0; i < lenY; i++) {
 8007dca:	2c00      	cmp	r4, #0
 8007dcc:	dded      	ble.n	8007daa <cblas_sgemv+0x26e>
 8007dce:	eb0b 0285 	add.w	r2, fp, r5, lsl #2
 8007dd2:	4673      	mov	r3, lr
          Y[iy] += temp * A[lda * j + i];
 8007dd4:	ecf2 6a01 	vldmia	r2!, {s13}
 8007dd8:	edd3 7a00 	vldr	s15, [r3]
 8007ddc:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (i = 0; i < lenY; i++) {
 8007de0:	428a      	cmp	r2, r1
          Y[iy] += temp * A[lda * j + i];
 8007de2:	edc3 7a00 	vstr	s15, [r3]
        for (i = 0; i < lenY; i++) {
 8007de6:	444b      	add	r3, r9
 8007de8:	d1f4      	bne.n	8007dd4 <cblas_sgemv+0x298>
 8007dea:	e7de      	b.n	8007daa <cblas_sgemv+0x26e>
    INDEX iy = OFFSET(lenY, incY);
 8007dec:	f1c4 0201 	rsb	r2, r4, #1
 8007df0:	fb02 f209 	mul.w	r2, r2, r9
 8007df4:	e79c      	b.n	8007d30 <cblas_sgemv+0x1f4>
             || (order == CblasColMajor && Trans == CblasNoTrans)) {
 8007df6:	2d6f      	cmp	r5, #111	; 0x6f
 8007df8:	f47f af20 	bne.w	8007c3c <cblas_sgemv+0x100>
 8007dfc:	e7b7      	b.n	8007d6e <cblas_sgemv+0x232>
    INDEX iy = OFFSET(lenY, incY);
 8007dfe:	f1c4 0001 	rsb	r0, r4, #1
 8007e02:	fb00 f009 	mul.w	r0, r0, r9
 8007e06:	e72b      	b.n	8007c60 <cblas_sgemv+0x124>
    INDEX ix = OFFSET(lenX, incX);
 8007e08:	f1c6 0001 	rsb	r0, r6, #1
 8007e0c:	fb00 f007 	mul.w	r0, r0, r7
 8007e10:	e7b0      	b.n	8007d74 <cblas_sgemv+0x238>
    INDEX iy = OFFSET(lenY, incY);
 8007e12:	f1c4 0201 	rsb	r2, r4, #1
 8007e16:	fb02 f209 	mul.w	r2, r2, r9
 8007e1a:	e6f2      	b.n	8007c02 <cblas_sgemv+0xc6>
 8007e1c:	08030378 	.word	0x08030378
 8007e20:	080305c0 	.word	0x080305c0
 8007e24:	080305a8 	.word	0x080305a8
 8007e28:	00000000 	.word	0x00000000

08007e2c <cblas_sger>:

void
cblas_sger (const enum CBLAS_ORDER order, const int M, const int N,
            const float alpha, const float *X, const int incX, const float *Y,
            const int incY, float *A, const int lda)
{
 8007e2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e30:	ed2d 8b02 	vpush	{d8}
 8007e34:	b083      	sub	sp, #12
 8007e36:	469a      	mov	sl, r3
 8007e38:	e9dd 930e 	ldrd	r9, r3, [sp, #56]	; 0x38
 */

{
  INDEX i, j;

  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8007e3c:	1e0e      	subs	r6, r1, #0
 8007e3e:	e9dd 4810 	ldrd	r4, r8, [sp, #64]	; 0x40
 8007e42:	9f12      	ldr	r7, [sp, #72]	; 0x48
 8007e44:	9301      	str	r3, [sp, #4]
 8007e46:	4683      	mov	fp, r0
 8007e48:	4615      	mov	r5, r2
 8007e4a:	eeb0 8a40 	vmov.f32	s16, s0
 8007e4e:	db75      	blt.n	8007f3c <cblas_sger+0x110>
 8007e50:	3865      	subs	r0, #101	; 0x65
 8007e52:	2801      	cmp	r0, #1
 8007e54:	bf94      	ite	ls
 8007e56:	2000      	movls	r0, #0
 8007e58:	2001      	movhi	r0, #1
 8007e5a:	2d00      	cmp	r5, #0
 8007e5c:	bfb8      	it	lt
 8007e5e:	2003      	movlt	r0, #3
 8007e60:	f1b9 0f00 	cmp.w	r9, #0
 8007e64:	d156      	bne.n	8007f14 <cblas_sger+0xe8>
 8007e66:	2c00      	cmp	r4, #0
 8007e68:	d14b      	bne.n	8007f02 <cblas_sger+0xd6>
 8007e6a:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8007e6e:	d067      	beq.n	8007f40 <cblas_sger+0x114>
 8007e70:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8007e74:	f000 80c7 	beq.w	8008006 <cblas_sger+0x1da>
 8007e78:	2008      	movs	r0, #8
 8007e7a:	4a73      	ldr	r2, [pc, #460]	; (8008048 <cblas_sger+0x21c>)
 8007e7c:	4973      	ldr	r1, [pc, #460]	; (800804c <cblas_sger+0x220>)
 8007e7e:	f01f fde3 	bl	8027a48 <cblas_xerbla>
        A[lda * i + j] += Y[jy] * tmp;
        jy += incY;
      }
      ix += incX;
    }
  } else if (order == CblasColMajor) {
 8007e82:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8007e86:	d14f      	bne.n	8007f28 <cblas_sger+0xfc>
    INDEX jy = OFFSET(N, incY);
 8007e88:	2c00      	cmp	r4, #0
 8007e8a:	f340 80a1 	ble.w	8007fd0 <cblas_sger+0x1a4>
 8007e8e:	2300      	movs	r3, #0
    for (j = 0; j < N; j++) {
 8007e90:	2d00      	cmp	r5, #0
 8007e92:	dd31      	ble.n	8007ef8 <cblas_sger+0xcc>
 8007e94:	9901      	ldr	r1, [sp, #4]
 8007e96:	f1b9 0f00 	cmp.w	r9, #0
 8007e9a:	f1c6 0201 	rsb	r2, r6, #1
 8007e9e:	fb02 f209 	mul.w	r2, r2, r9
      const BASE tmp = alpha * Y[jy];
      INDEX ix = OFFSET(M, incX);
 8007ea2:	f04f 0c00 	mov.w	ip, #0
 8007ea6:	bfc8      	it	gt
 8007ea8:	2200      	movgt	r2, #0
 8007eaa:	eb01 0b83 	add.w	fp, r1, r3, lsl #2
 8007eae:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
 8007eb2:	ea4f 0189 	mov.w	r1, r9, lsl #2
 8007eb6:	00a4      	lsls	r4, r4, #2
 8007eb8:	46e6      	mov	lr, ip
 8007eba:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8007ebe:	eb08 0286 	add.w	r2, r8, r6, lsl #2
      const BASE tmp = alpha * Y[jy];
 8007ec2:	eddb 6a00 	vldr	s13, [fp]
      for (i = 0; i < M; i++) {
 8007ec6:	2e00      	cmp	r6, #0
      const BASE tmp = alpha * Y[jy];
 8007ec8:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (i = 0; i < M; i++) {
 8007ecc:	dd0d      	ble.n	8007eea <cblas_sger+0xbe>
 8007ece:	eb08 038c 	add.w	r3, r8, ip, lsl #2
 8007ed2:	4650      	mov	r0, sl
        A[i + lda * j] += X[ix] * tmp;
 8007ed4:	ed90 7a00 	vldr	s14, [r0]
 8007ed8:	edd3 7a00 	vldr	s15, [r3]
 8007edc:	eee7 7a26 	vfma.f32	s15, s14, s13
 8007ee0:	4408      	add	r0, r1
 8007ee2:	ece3 7a01 	vstmia	r3!, {s15}
      for (i = 0; i < M; i++) {
 8007ee6:	4293      	cmp	r3, r2
 8007ee8:	d1f4      	bne.n	8007ed4 <cblas_sger+0xa8>
    for (j = 0; j < N; j++) {
 8007eea:	f10e 0e01 	add.w	lr, lr, #1
 8007eee:	4575      	cmp	r5, lr
 8007ef0:	44a3      	add	fp, r4
 8007ef2:	44bc      	add	ip, r7
 8007ef4:	444a      	add	r2, r9
 8007ef6:	d1e4      	bne.n	8007ec2 <cblas_sger+0x96>
#define BASE float
#include "source_ger.h"
#undef BASE
}
 8007ef8:	b003      	add	sp, #12
 8007efa:	ecbd 8b02 	vpop	{d8}
 8007efe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8007f02:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8007f06:	d070      	beq.n	8007fea <cblas_sger+0x1be>
 8007f08:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8007f0c:	f000 8092 	beq.w	8008034 <cblas_sger+0x208>
 8007f10:	2006      	movs	r0, #6
 8007f12:	e7b2      	b.n	8007e7a <cblas_sger+0x4e>
 8007f14:	2c00      	cmp	r4, #0
 8007f16:	d0a8      	beq.n	8007e6a <cblas_sger+0x3e>
 8007f18:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8007f1c:	d05d      	beq.n	8007fda <cblas_sger+0x1ae>
 8007f1e:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8007f22:	d07d      	beq.n	8008020 <cblas_sger+0x1f4>
 8007f24:	2800      	cmp	r0, #0
 8007f26:	d1a8      	bne.n	8007e7a <cblas_sger+0x4e>
        ix += incX;
      }
      jy += incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8007f28:	4a49      	ldr	r2, [pc, #292]	; (8008050 <cblas_sger+0x224>)
 8007f2a:	4948      	ldr	r1, [pc, #288]	; (800804c <cblas_sger+0x220>)
 8007f2c:	2000      	movs	r0, #0
 8007f2e:	b003      	add	sp, #12
 8007f30:	ecbd 8b02 	vpop	{d8}
 8007f34:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007f38:	f01f bd86 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8007f3c:	2002      	movs	r0, #2
 8007f3e:	e78c      	b.n	8007e5a <cblas_sger+0x2e>
 8007f40:	2d01      	cmp	r5, #1
 8007f42:	4628      	mov	r0, r5
 8007f44:	bfb8      	it	lt
 8007f46:	2001      	movlt	r0, #1
 8007f48:	4287      	cmp	r7, r0
 8007f4a:	bfac      	ite	ge
 8007f4c:	2008      	movge	r0, #8
 8007f4e:	200a      	movlt	r0, #10
 8007f50:	4a3d      	ldr	r2, [pc, #244]	; (8008048 <cblas_sger+0x21c>)
 8007f52:	493e      	ldr	r1, [pc, #248]	; (800804c <cblas_sger+0x220>)
 8007f54:	f01f fd78 	bl	8027a48 <cblas_xerbla>
    INDEX ix = OFFSET(M, incX);
 8007f58:	f1b9 0f00 	cmp.w	r9, #0
 8007f5c:	dd4e      	ble.n	8007ffc <cblas_sger+0x1d0>
 8007f5e:	2300      	movs	r3, #0
    for (i = 0; i < M; i++) {
 8007f60:	2e00      	cmp	r6, #0
 8007f62:	ddc9      	ble.n	8007ef8 <cblas_sger+0xcc>
 8007f64:	2c00      	cmp	r4, #0
 8007f66:	f1c5 0201 	rsb	r2, r5, #1
 8007f6a:	eb0a 0a83 	add.w	sl, sl, r3, lsl #2
 8007f6e:	9b01      	ldr	r3, [sp, #4]
 8007f70:	fb02 f204 	mul.w	r2, r2, r4
      INDEX jy = OFFSET(N, incY);
 8007f74:	f04f 0c00 	mov.w	ip, #0
 8007f78:	bfc8      	it	gt
 8007f7a:	2200      	movgt	r2, #0
 8007f7c:	ea4f 0189 	mov.w	r1, r9, lsl #2
 8007f80:	eb03 0b82 	add.w	fp, r3, r2, lsl #2
 8007f84:	46e6      	mov	lr, ip
 8007f86:	00a2      	lsls	r2, r4, #2
 8007f88:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8007f8c:	eb08 0485 	add.w	r4, r8, r5, lsl #2
      const BASE tmp = alpha * X[ix];
 8007f90:	edda 6a00 	vldr	s13, [sl]
      for (j = 0; j < N; j++) {
 8007f94:	2d00      	cmp	r5, #0
      const BASE tmp = alpha * X[ix];
 8007f96:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (j = 0; j < N; j++) {
 8007f9a:	dd0d      	ble.n	8007fb8 <cblas_sger+0x18c>
 8007f9c:	eb08 038c 	add.w	r3, r8, ip, lsl #2
 8007fa0:	4658      	mov	r0, fp
        A[lda * i + j] += Y[jy] * tmp;
 8007fa2:	ed90 7a00 	vldr	s14, [r0]
 8007fa6:	edd3 7a00 	vldr	s15, [r3]
 8007faa:	eee7 7a26 	vfma.f32	s15, s14, s13
 8007fae:	4410      	add	r0, r2
 8007fb0:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j < N; j++) {
 8007fb4:	42a3      	cmp	r3, r4
 8007fb6:	d1f4      	bne.n	8007fa2 <cblas_sger+0x176>
    for (i = 0; i < M; i++) {
 8007fb8:	f10e 0e01 	add.w	lr, lr, #1
 8007fbc:	4576      	cmp	r6, lr
 8007fbe:	448a      	add	sl, r1
 8007fc0:	44bc      	add	ip, r7
 8007fc2:	444c      	add	r4, r9
 8007fc4:	d1e4      	bne.n	8007f90 <cblas_sger+0x164>
 8007fc6:	b003      	add	sp, #12
 8007fc8:	ecbd 8b02 	vpop	{d8}
 8007fcc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    INDEX jy = OFFSET(N, incY);
 8007fd0:	f1c5 0301 	rsb	r3, r5, #1
 8007fd4:	fb03 f304 	mul.w	r3, r3, r4
 8007fd8:	e75a      	b.n	8007e90 <cblas_sger+0x64>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8007fda:	2d01      	cmp	r5, #1
 8007fdc:	462b      	mov	r3, r5
 8007fde:	bfb8      	it	lt
 8007fe0:	2301      	movlt	r3, #1
 8007fe2:	42bb      	cmp	r3, r7
 8007fe4:	dd2d      	ble.n	8008042 <cblas_sger+0x216>
 8007fe6:	200a      	movs	r0, #10
 8007fe8:	e7b2      	b.n	8007f50 <cblas_sger+0x124>
 8007fea:	2d01      	cmp	r5, #1
 8007fec:	4628      	mov	r0, r5
 8007fee:	bfb8      	it	lt
 8007ff0:	2001      	movlt	r0, #1
 8007ff2:	42b8      	cmp	r0, r7
 8007ff4:	bfcc      	ite	gt
 8007ff6:	200a      	movgt	r0, #10
 8007ff8:	2006      	movle	r0, #6
 8007ffa:	e7a9      	b.n	8007f50 <cblas_sger+0x124>
    INDEX ix = OFFSET(M, incX);
 8007ffc:	f1c6 0301 	rsb	r3, r6, #1
 8008000:	fb03 f309 	mul.w	r3, r3, r9
 8008004:	e7ac      	b.n	8007f60 <cblas_sger+0x134>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008006:	2e01      	cmp	r6, #1
 8008008:	4633      	mov	r3, r6
 800800a:	bfb8      	it	lt
 800800c:	2301      	movlt	r3, #1
 800800e:	42bb      	cmp	r3, r7
 8008010:	f77f af32 	ble.w	8007e78 <cblas_sger+0x4c>
 8008014:	4a0c      	ldr	r2, [pc, #48]	; (8008048 <cblas_sger+0x21c>)
 8008016:	490d      	ldr	r1, [pc, #52]	; (800804c <cblas_sger+0x220>)
 8008018:	200a      	movs	r0, #10
 800801a:	f01f fd15 	bl	8027a48 <cblas_xerbla>
  if (order == CblasRowMajor) {
 800801e:	e733      	b.n	8007e88 <cblas_sger+0x5c>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8008020:	2e01      	cmp	r6, #1
 8008022:	4633      	mov	r3, r6
 8008024:	bfb8      	it	lt
 8008026:	2301      	movlt	r3, #1
 8008028:	42bb      	cmp	r3, r7
 800802a:	dcf3      	bgt.n	8008014 <cblas_sger+0x1e8>
 800802c:	2800      	cmp	r0, #0
 800802e:	f43f af2b 	beq.w	8007e88 <cblas_sger+0x5c>
 8008032:	e722      	b.n	8007e7a <cblas_sger+0x4e>
 8008034:	2e01      	cmp	r6, #1
 8008036:	4633      	mov	r3, r6
 8008038:	bfb8      	it	lt
 800803a:	2301      	movlt	r3, #1
 800803c:	429f      	cmp	r7, r3
 800803e:	dbe9      	blt.n	8008014 <cblas_sger+0x1e8>
 8008040:	e766      	b.n	8007f10 <cblas_sger+0xe4>
 8008042:	2800      	cmp	r0, #0
 8008044:	d088      	beq.n	8007f58 <cblas_sger+0x12c>
 8008046:	e783      	b.n	8007f50 <cblas_sger+0x124>
 8008048:	08030378 	.word	0x08030378
 800804c:	080305d0 	.word	0x080305d0
 8008050:	080305a8 	.word	0x080305a8

08008054 <cblas_snrm2>:
  BASE scale = 0.0;
  BASE ssq = 1.0;
  INDEX i;
  INDEX ix = 0;

  if (N <= 0 || incX <= 0) {
 8008054:	2800      	cmp	r0, #0
 8008056:	dd4e      	ble.n	80080f6 <cblas_snrm2+0xa2>
 8008058:	2a00      	cmp	r2, #0
 800805a:	dd4c      	ble.n	80080f6 <cblas_snrm2+0xa2>
    return 0;
  } else if (N == 1) {
 800805c:	2801      	cmp	r0, #1
 800805e:	d04d      	beq.n	80080fc <cblas_snrm2+0xa8>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

float
cblas_snrm2 (const int N, const float *X, const int incX)
{
 8008060:	b538      	push	{r3, r4, r5, lr}
  BASE ssq = 1.0;
 8008062:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8008066:	ed2d 8b02 	vpush	{d8}

    if (x != 0.0) {
      const BASE ax = fabs(x);

      if (scale < ax) {
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 800806a:	eeb0 6a66 	vmov.f32	s12, s13
  BASE scale = 0.0;
 800806e:	ed9f 8a26 	vldr	s16, [pc, #152]	; 8008108 <cblas_snrm2+0xb4>
 8008072:	0092      	lsls	r2, r2, #2
  for (i = 0; i < N; i++) {
 8008074:	2300      	movs	r3, #0
 8008076:	e00f      	b.n	8008098 <cblas_snrm2+0x44>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 8008078:	eec8 7a07 	vdiv.f32	s15, s16, s14
        scale = ax;
 800807c:	eeb0 8a47 	vmov.f32	s16, s14
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 8008080:	ee67 6aa6 	vmul.f32	s13, s15, s13
 8008084:	eeb0 7a46 	vmov.f32	s14, s12
 8008088:	eea7 7aa6 	vfma.f32	s14, s15, s13
 800808c:	eef0 6a47 	vmov.f32	s13, s14
  for (i = 0; i < N; i++) {
 8008090:	3301      	adds	r3, #1
 8008092:	4298      	cmp	r0, r3
 8008094:	4411      	add	r1, r2
 8008096:	d015      	beq.n	80080c4 <cblas_snrm2+0x70>
    const BASE x = X[ix];
 8008098:	edd1 7a00 	vldr	s15, [r1]
    if (x != 0.0) {
 800809c:	eef5 7a40 	vcmp.f32	s15, #0.0
 80080a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      const BASE ax = fabs(x);
 80080a4:	eeb0 7ae7 	vabs.f32	s14, s15
    if (x != 0.0) {
 80080a8:	d0f2      	beq.n	8008090 <cblas_snrm2+0x3c>
      if (scale < ax) {
 80080aa:	eeb4 7ac8 	vcmpe.f32	s14, s16
 80080ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80080b2:	dce1      	bgt.n	8008078 <cblas_snrm2+0x24>
      } else {
        ssq += (ax / scale) * (ax / scale);
 80080b4:	ee87 7a88 	vdiv.f32	s14, s15, s16
  for (i = 0; i < N; i++) {
 80080b8:	3301      	adds	r3, #1
 80080ba:	4298      	cmp	r0, r3
 80080bc:	4411      	add	r1, r2
        ssq += (ax / scale) * (ax / scale);
 80080be:	eee7 6a07 	vfma.f32	s13, s14, s14
  for (i = 0; i < N; i++) {
 80080c2:	d1e9      	bne.n	8008098 <cblas_snrm2+0x44>
    }

    ix += incX;
  }

  return scale * sqrt(ssq);
 80080c4:	ee16 0a90 	vmov	r0, s13
 80080c8:	f01f fe96 	bl	8027df8 <__aeabi_f2d>
 80080cc:	ec41 0b10 	vmov	d0, r0, r1
 80080d0:	f027 fee2 	bl	802fe98 <sqrt>
 80080d4:	ec55 4b10 	vmov	r4, r5, d0
 80080d8:	ee18 0a10 	vmov	r0, s16
 80080dc:	f01f fe8c 	bl	8027df8 <__aeabi_f2d>
 80080e0:	4622      	mov	r2, r4
 80080e2:	462b      	mov	r3, r5
 80080e4:	f01f fee0 	bl	8027ea8 <__aeabi_dmul>
 80080e8:	f020 f98e 	bl	8028408 <__aeabi_d2f>
#define BASE float
#include "source_nrm2_r.h"
#undef BASE
}
 80080ec:	ecbd 8b02 	vpop	{d8}
 80080f0:	ee00 0a10 	vmov	s0, r0
 80080f4:	bd38      	pop	{r3, r4, r5, pc}
    return 0;
 80080f6:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8008108 <cblas_snrm2+0xb4>
 80080fa:	4770      	bx	lr
    return fabs(X[0]);
 80080fc:	ed91 0a00 	vldr	s0, [r1]
 8008100:	eeb0 0ac0 	vabs.f32	s0, s0
 8008104:	4770      	bx	lr
 8008106:	bf00      	nop
 8008108:	00000000 	.word	0x00000000

0800810c <cblas_srot>:
#include "cblas.h"

void
cblas_srot (const int N, float *X, const int incX, float *Y, const int incY,
            const float c, const float s)
{
 800810c:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 800810e:	2a00      	cmp	r2, #0
 8008110:	9d04      	ldr	r5, [sp, #16]
 8008112:	bfda      	itte	le
 8008114:	f1c0 0701 	rsble	r7, r0, #1
 8008118:	4357      	mulle	r7, r2
 800811a:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 800811c:	2d00      	cmp	r5, #0
 800811e:	bfda      	itte	le
 8008120:	f1c0 0601 	rsble	r6, r0, #1
 8008124:	436e      	mulle	r6, r5
 8008126:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 8008128:	2800      	cmp	r0, #0
 800812a:	dd1d      	ble.n	8008168 <cblas_srot+0x5c>
 800812c:	0094      	lsls	r4, r2, #2
 800812e:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 8008132:	00ad      	lsls	r5, r5, #2
 8008134:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8008138:	eeb1 6a60 	vneg.f32	s12, s1
 800813c:	2200      	movs	r2, #0
    const BASE x = X[ix];
    const BASE y = Y[iy];
 800813e:	edd3 7a00 	vldr	s15, [r3]
    const BASE x = X[ix];
 8008142:	edd1 6a00 	vldr	s13, [r1]
    X[ix] = c * x + s * y;
 8008146:	ee27 7aa0 	vmul.f32	s14, s15, s1
    Y[iy] = -s * x + c * y;
 800814a:	ee67 7a80 	vmul.f32	s15, s15, s0
    X[ix] = c * x + s * y;
 800814e:	eea6 7a80 	vfma.f32	s14, s13, s0
  for (i = 0; i < N; i++) {
 8008152:	3201      	adds	r2, #1
 8008154:	4290      	cmp	r0, r2
    Y[iy] = -s * x + c * y;
 8008156:	eee6 7a86 	vfma.f32	s15, s13, s12
    X[ix] = c * x + s * y;
 800815a:	ed81 7a00 	vstr	s14, [r1]
    Y[iy] = -s * x + c * y;
 800815e:	edc3 7a00 	vstr	s15, [r3]
  for (i = 0; i < N; i++) {
 8008162:	4421      	add	r1, r4
 8008164:	442b      	add	r3, r5
 8008166:	d1ea      	bne.n	800813e <cblas_srot+0x32>
#define BASE float
#include "source_rot.h"
#undef BASE
}
 8008168:	bcf0      	pop	{r4, r5, r6, r7}
 800816a:	4770      	bx	lr

0800816c <cblas_srotg>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_srotg (float *a, float *b, float *c, float *s)
{
 800816c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008170:	ed90 7a00 	vldr	s14, [r0]
 8008174:	edd1 6a00 	vldr	s13, [r1]
  const BASE scale = fabs(*a) + fabs(*b);
  BASE r, z;

  if (scale != 0.0) {
 8008178:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 800826c <cblas_srotg+0x100>
 800817c:	ed2d 8b02 	vpush	{d8}
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008180:	eef0 7ac7 	vabs.f32	s15, s14
 8008184:	eeb0 8ae6 	vabs.f32	s16, s13
 8008188:	eef4 7ac8 	vcmpe.f32	s15, s16
  const BASE scale = fabs(*a) + fabs(*b);
 800818c:	ee37 8a88 	vadd.f32	s16, s15, s16
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008190:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  if (scale != 0.0) {
 8008194:	eeb4 8a46 	vcmp.f32	s16, s12
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 8008198:	bfd4      	ite	le
 800819a:	eef0 8a66 	vmovle.f32	s17, s13
 800819e:	eef0 8a47 	vmovgt.f32	s17, s14
  if (scale != 0.0) {
 80081a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80081a6:	4607      	mov	r7, r0
 80081a8:	460c      	mov	r4, r1
 80081aa:	4615      	mov	r5, r2
 80081ac:	461e      	mov	r6, r3
 80081ae:	d110      	bne.n	80081d2 <cblas_srotg+0x66>
    if (fabs(*a) > fabs(*b))
      z = *s;
    if (fabs(*b) >= fabs(*a) && *c != 0.0)
      z = 1.0 / (*c);
  } else {
    *c = 1.0;
 80081b0:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80081b4:	6013      	str	r3, [r2, #0]
    *s = 0.0;
    r = 0.0;
    z = 0.0;
 80081b6:	eef0 7a46 	vmov.f32	s15, s12
    r = 0.0;
 80081ba:	eeb0 7a46 	vmov.f32	s14, s12
    *s = 0.0;
 80081be:	ed86 6a00 	vstr	s12, [r6]
#define BASE float
#include "source_rotg.h"
#undef BASE
}
 80081c2:	ecbd 8b02 	vpop	{d8}
  }

  *a = r;
 80081c6:	ed87 7a00 	vstr	s14, [r7]
  *b = z;
 80081ca:	edc4 7a00 	vstr	s15, [r4]
 80081ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    const BASE bos = *b / scale;
 80081d2:	eec6 7a88 	vdiv.f32	s15, s13, s16
    const BASE aos = *a / scale;
 80081d6:	eec7 6a08 	vdiv.f32	s13, s14, s16
    r = scale * sqrt(aos * aos + bos * bos);
 80081da:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80081de:	eee6 7aa6 	vfma.f32	s15, s13, s13
 80081e2:	ee17 0a90 	vmov	r0, s15
 80081e6:	f01f fe07 	bl	8027df8 <__aeabi_f2d>
 80081ea:	ec41 0b10 	vmov	d0, r0, r1
 80081ee:	f027 fe53 	bl	802fe98 <sqrt>
 80081f2:	ec59 8b10 	vmov	r8, r9, d0
 80081f6:	ee18 0a10 	vmov	r0, s16
 80081fa:	f01f fdfd 	bl	8027df8 <__aeabi_f2d>
 80081fe:	4642      	mov	r2, r8
 8008200:	464b      	mov	r3, r9
 8008202:	f01f fe51 	bl	8027ea8 <__aeabi_dmul>
 8008206:	f020 f8ff 	bl	8028408 <__aeabi_d2f>
    r = GSL_SIGN(roe) * r;
 800820a:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    r = scale * sqrt(aos * aos + bos * bos);
 800820e:	ee07 0a10 	vmov	s14, r0
    *c = *a / r;
 8008212:	edd7 6a00 	vldr	s13, [r7]
    r = GSL_SIGN(roe) * r;
 8008216:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800821a:	bfb8      	it	lt
 800821c:	eeb1 7a47 	vneglt.f32	s14, s14
    *c = *a / r;
 8008220:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z = 1.0;
 8008224:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    *c = *a / r;
 8008228:	edc5 7a00 	vstr	s15, [r5]
    *s = *b / r;
 800822c:	edd4 6a00 	vldr	s13, [r4]
 8008230:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8008234:	edc6 7a00 	vstr	s15, [r6]
    if (fabs(*a) > fabs(*b))
 8008238:	ed97 6a00 	vldr	s12, [r7]
 800823c:	edd4 6a00 	vldr	s13, [r4]
 8008240:	eeb0 6ac6 	vabs.f32	s12, s12
 8008244:	eef0 6ae6 	vabs.f32	s13, s13
    z = 1.0;
 8008248:	eeb4 6ae6 	vcmpe.f32	s12, s13
 800824c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008250:	bfd8      	it	le
 8008252:	eef0 7a65 	vmovle.f32	s15, s11
    if (fabs(*b) >= fabs(*a) && *c != 0.0)
 8008256:	d8b4      	bhi.n	80081c2 <cblas_srotg+0x56>
 8008258:	edd5 6a00 	vldr	s13, [r5]
 800825c:	eef5 6a40 	vcmp.f32	s13, #0.0
 8008260:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008264:	d0ad      	beq.n	80081c2 <cblas_srotg+0x56>
      z = 1.0 / (*c);
 8008266:	eec5 7aa6 	vdiv.f32	s15, s11, s13
 800826a:	e7aa      	b.n	80081c2 <cblas_srotg+0x56>
 800826c:	00000000 	.word	0x00000000

08008270 <cblas_srotm>:
#include "cblas.h"

void
cblas_srotm (const int N, float *X, const int incX, float *Y, const int incY,
             const float *P)
{
 8008270:	b4f0      	push	{r4, r5, r6, r7}
 8008272:	e9dd 5404 	ldrd	r5, r4, [sp, #16]
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX n;
  INDEX i = OFFSET(N, incX);
 8008276:	2a00      	cmp	r2, #0
 8008278:	bfd8      	it	le
 800827a:	f1c0 0701 	rsble	r7, r0, #1
  INDEX j = OFFSET(N, incY);

  BASE h11, h21, h12, h22;

  if (P[0] == -1.0) {
 800827e:	ed94 6a00 	vldr	s12, [r4]
  INDEX i = OFFSET(N, incX);
 8008282:	bfd4      	ite	le
 8008284:	4357      	mulle	r7, r2
 8008286:	2700      	movgt	r7, #0
  if (P[0] == -1.0) {
 8008288:	eeff 5a00 	vmov.f32	s11, #240	; 0xbf800000 -1.0
  INDEX j = OFFSET(N, incY);
 800828c:	2d00      	cmp	r5, #0
 800828e:	bfd8      	it	le
 8008290:	f1c0 0601 	rsble	r6, r0, #1
  if (P[0] == -1.0) {
 8008294:	eeb4 6a65 	vcmp.f32	s12, s11
  INDEX j = OFFSET(N, incY);
 8008298:	bfd4      	ite	le
 800829a:	436e      	mulle	r6, r5
 800829c:	2600      	movgt	r6, #0
  if (P[0] == -1.0) {
 800829e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082a2:	d127      	bne.n	80082f4 <cblas_srotm+0x84>
    h11 = P[1];
 80082a4:	edd4 4a01 	vldr	s9, [r4, #4]
    h21 = P[2];
 80082a8:	edd4 5a02 	vldr	s11, [r4, #8]
    h12 = P[3];
 80082ac:	ed94 6a03 	vldr	s12, [r4, #12]
    h22 = P[4];
 80082b0:	ed94 5a04 	vldr	s10, [r4, #16]
  } else {
    BLAS_ERROR("unrecognized value of P[0]");
    return;
  }

  for (n = 0; n < N; n++) {
 80082b4:	2800      	cmp	r0, #0
 80082b6:	dd1b      	ble.n	80082f0 <cblas_srotm+0x80>
 80082b8:	0094      	lsls	r4, r2, #2
 80082ba:	eb01 0187 	add.w	r1, r1, r7, lsl #2
 80082be:	00ad      	lsls	r5, r5, #2
 80082c0:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 80082c4:	2200      	movs	r2, #0
    const BASE w = X[i];
    const BASE z = Y[j];
 80082c6:	edd3 7a00 	vldr	s15, [r3]
    const BASE w = X[i];
 80082ca:	edd1 6a00 	vldr	s13, [r1]
    X[i] = h11 * w + h12 * z;
 80082ce:	ee26 7a27 	vmul.f32	s14, s12, s15
    Y[j] = h21 * w + h22 * z;
 80082d2:	ee65 7a27 	vmul.f32	s15, s10, s15
    X[i] = h11 * w + h12 * z;
 80082d6:	eea4 7aa6 	vfma.f32	s14, s9, s13
  for (n = 0; n < N; n++) {
 80082da:	3201      	adds	r2, #1
 80082dc:	4290      	cmp	r0, r2
    Y[j] = h21 * w + h22 * z;
 80082de:	eee5 7aa6 	vfma.f32	s15, s11, s13
    X[i] = h11 * w + h12 * z;
 80082e2:	ed81 7a00 	vstr	s14, [r1]
    Y[j] = h21 * w + h22 * z;
 80082e6:	edc3 7a00 	vstr	s15, [r3]
  for (n = 0; n < N; n++) {
 80082ea:	4421      	add	r1, r4
 80082ec:	442b      	add	r3, r5
 80082ee:	d1ea      	bne.n	80082c6 <cblas_srotm+0x56>
#define BASE float
#include "source_rotm.h"
#undef BASE
}
 80082f0:	bcf0      	pop	{r4, r5, r6, r7}
 80082f2:	4770      	bx	lr
  } else if (P[0] == 0.0) {
 80082f4:	eeb5 6a40 	vcmp.f32	s12, #0.0
 80082f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082fc:	d108      	bne.n	8008310 <cblas_srotm+0xa0>
    h22 = 1.0;
 80082fe:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    h21 = P[2];
 8008302:	edd4 5a02 	vldr	s11, [r4, #8]
    h12 = P[3];
 8008306:	ed94 6a03 	vldr	s12, [r4, #12]
    h11 = 1.0;
 800830a:	eef0 4a45 	vmov.f32	s9, s10
 800830e:	e7d1      	b.n	80082b4 <cblas_srotm+0x44>
  } else if (P[0] == 1.0) {
 8008310:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008314:	eeb4 6a67 	vcmp.f32	s12, s15
 8008318:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800831c:	d104      	bne.n	8008328 <cblas_srotm+0xb8>
    h11 = P[1];
 800831e:	edd4 4a01 	vldr	s9, [r4, #4]
    h22 = P[4];
 8008322:	ed94 5a04 	vldr	s10, [r4, #16]
 8008326:	e7c5      	b.n	80082b4 <cblas_srotm+0x44>
  } else if (P[0] == -2.0) {
 8008328:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 800832c:	eeb4 6a67 	vcmp.f32	s12, s15
 8008330:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008334:	d0dc      	beq.n	80082f0 <cblas_srotm+0x80>
 8008336:	bcf0      	pop	{r4, r5, r6, r7}
    BLAS_ERROR("unrecognized value of P[0]");
 8008338:	4a02      	ldr	r2, [pc, #8]	; (8008344 <cblas_srotm+0xd4>)
 800833a:	4903      	ldr	r1, [pc, #12]	; (8008348 <cblas_srotm+0xd8>)
 800833c:	2000      	movs	r0, #0
 800833e:	f01f bb83 	b.w	8027a48 <cblas_xerbla>
 8008342:	bf00      	nop
 8008344:	080305e0 	.word	0x080305e0
 8008348:	080305fc 	.word	0x080305fc

0800834c <cblas_srotmg>:
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const BASE G = 4096.0, G2 = G * G;
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800834c:	ed90 4a00 	vldr	s8, [r0]

  BASE c, s;

  /* case of d1 < 0, appendix A, second to last paragraph */

  if (D1 < 0.0) {
 8008350:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
 8008354:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_srotmg (float *d1, float *d2, float *b1, const float b2, float *P)
{
 8008358:	b430      	push	{r4, r5}
 800835a:	d43f      	bmi.n	80083dc <cblas_srotmg+0x90>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800835c:	ed91 3a00 	vldr	s6, [r1]
    *d2 = 0;
    *b1 = 0;
    return;
  }

  if (D2 * y == 0.0) {
 8008360:	ee63 7a00 	vmul.f32	s15, s6, s0
 8008364:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008368:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800836c:	d02c      	beq.n	80083c8 <cblas_srotmg+0x7c>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800836e:	edd2 3a00 	vldr	s7, [r2]
    P[0] = -2;                  /* case of H = I, page 315 */
    return;
  }

  c = fabs(D1 * x * x);
 8008372:	ee64 6a23 	vmul.f32	s13, s8, s7
  s = fabs(D2 * y * y);
 8008376:	ee27 6a80 	vmul.f32	s12, s15, s0
  c = fabs(D1 * x * x);
 800837a:	ee26 7aa3 	vmul.f32	s14, s13, s7
  s = fabs(D2 * y * y);
 800837e:	eef0 5ac6 	vabs.f32	s11, s12
  c = fabs(D1 * x * x);
 8008382:	eeb0 7ac7 	vabs.f32	s14, s14

  if (c > s) {
 8008386:	eeb4 7ae5 	vcmpe.f32	s14, s11
 800838a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800838e:	dd20      	ble.n	80083d2 <cblas_srotmg+0x86>

    P[0] = 0.0;

    h11 = 1;
    h12 = (D2 * y) / (D1 * x);
    h21 = -y / x;
 8008390:	eeb1 0a40 	vneg.f32	s0, s0
    h12 = (D2 * y) / (D1 * x);
 8008394:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8008398:	2400      	movs	r4, #0
    P[0] = 0.0;
 800839a:	601c      	str	r4, [r3, #0]
    h21 = -y / x;
 800839c:	ee80 5a23 	vdiv.f32	s10, s0, s7
    h22 = 1;

    u = 1 - h21 * h12;
 80083a0:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 80083a4:	eef0 6a65 	vmov.f32	s13, s11
 80083a8:	eee6 6a45 	vfms.f32	s13, s12, s10

    if (u <= 0.0) {             /* the case u <= 0 is rejected */
 80083ac:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 80083b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80083b4:	d912      	bls.n	80083dc <cblas_srotmg+0x90>
      *d2 = 0;
      *b1 = 0;
      return;
    }

    D1 /= u;
 80083b6:	eec4 7a26 	vdiv.f32	s15, s8, s13
    D2 /= u;
 80083ba:	ee83 7a26 	vdiv.f32	s14, s6, s13
    h11 = 1;
 80083be:	eef0 4a65 	vmov.f32	s9, s11
    x *= u;
 80083c2:	ee63 6aa6 	vmul.f32	s13, s7, s13
 80083c6:	e029      	b.n	800841c <cblas_srotmg+0xd0>
    P[0] = -2;                  /* case of H = I, page 315 */
 80083c8:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
 80083cc:	601a      	str	r2, [r3, #0]
#define BASE float
#include "source_rotmg.h"
#undef BASE
}
 80083ce:	bc30      	pop	{r4, r5}
 80083d0:	4770      	bx	lr
  } else {
    /* case of equation A7 */

    if (D2 * y * y < 0.0) {
 80083d2:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
 80083d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80083da:	d50b      	bpl.n	80083f4 <cblas_srotmg+0xa8>
    P[1] = 0;
 80083dc:	2400      	movs	r4, #0
    P[0] = -1;
 80083de:	4d62      	ldr	r5, [pc, #392]	; (8008568 <cblas_srotmg+0x21c>)
    P[1] = 0;
 80083e0:	605c      	str	r4, [r3, #4]
    P[2] = 0;
 80083e2:	609c      	str	r4, [r3, #8]
    P[3] = 0;
 80083e4:	60dc      	str	r4, [r3, #12]
    P[4] = 0;
 80083e6:	611c      	str	r4, [r3, #16]
    P[0] = -1;
 80083e8:	601d      	str	r5, [r3, #0]
    *d1 = 0;
 80083ea:	6004      	str	r4, [r0, #0]
    *d2 = 0;
 80083ec:	600c      	str	r4, [r1, #0]
    *b1 = 0;
 80083ee:	6014      	str	r4, [r2, #0]
 80083f0:	bc30      	pop	{r4, r5}
 80083f2:	4770      	bx	lr
      return;
    }

    P[0] = 1;

    h11 = (D1 * x) / (D2 * y);
 80083f4:	eec6 4aa7 	vdiv.f32	s9, s13, s15
    h12 = 1;
    h21 = -1;
    h22 = x / y;
 80083f8:	eec3 5a80 	vdiv.f32	s11, s7, s0
    P[0] = 1;
 80083fc:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0

    u = 1 + h11 * h22;
 8008400:	eef0 6a46 	vmov.f32	s13, s12
 8008404:	eee4 6aa5 	vfma.f32	s13, s9, s11
    P[0] = 1;
 8008408:	ed83 6a00 	vstr	s12, [r3]

    D1 /= u;
 800840c:	ee84 7a26 	vdiv.f32	s14, s8, s13
    D2 /= u;
 8008410:	eec3 7a26 	vdiv.f32	s15, s6, s13
      BASE tmp = D2;
      D2 = D1;
      D1 = tmp;
    }

    x = y * u;
 8008414:	ee60 6a26 	vmul.f32	s13, s0, s13
    h21 = -1;
 8008418:	eebf 5a00 	vmov.f32	s10, #240	; 0xbf800000 -1.0
  }

  /* rescale D1 to range [1/G2,G2] */

  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800841c:	eddf 3a53 	vldr	s7, [pc, #332]	; 800856c <cblas_srotmg+0x220>
 8008420:	eef4 7ae3 	vcmpe.f32	s15, s7
 8008424:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008428:	d818      	bhi.n	800845c <cblas_srotmg+0x110>
    P[0] = -1;
 800842a:	4c4f      	ldr	r4, [pc, #316]	; (8008568 <cblas_srotmg+0x21c>)
    D1 *= G2;
 800842c:	ed9f 3a50 	vldr	s6, [pc, #320]	; 8008570 <cblas_srotmg+0x224>
    x /= G;
 8008430:	ed9f 4a50 	vldr	s8, [pc, #320]	; 8008574 <cblas_srotmg+0x228>
 8008434:	e00d      	b.n	8008452 <cblas_srotmg+0x106>
    D1 *= G2;
 8008436:	ee67 7a83 	vmul.f32	s15, s15, s6
    x /= G;
 800843a:	ee66 6a84 	vmul.f32	s13, s13, s8
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800843e:	eef4 7ae3 	vcmpe.f32	s15, s7
 8008442:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h11 /= G;
 8008446:	ee64 4a84 	vmul.f32	s9, s9, s8
    h12 /= G;
 800844a:	ee26 6a04 	vmul.f32	s12, s12, s8
    P[0] = -1;
 800844e:	601c      	str	r4, [r3, #0]
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 8008450:	d804      	bhi.n	800845c <cblas_srotmg+0x110>
 8008452:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008456:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800845a:	d1ec      	bne.n	8008436 <cblas_srotmg+0xea>
  }

  while (D1 >= G2) {
 800845c:	eddf 3a44 	vldr	s7, [pc, #272]	; 8008570 <cblas_srotmg+0x224>
 8008460:	eef4 7ae3 	vcmpe.f32	s15, s7
 8008464:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008468:	db12      	blt.n	8008490 <cblas_srotmg+0x144>
    P[0] = -1;
    D1 /= G2;
 800846a:	ed9f 3a40 	vldr	s6, [pc, #256]	; 800856c <cblas_srotmg+0x220>
    x *= G;
 800846e:	ed9f 4a42 	vldr	s8, [pc, #264]	; 8008578 <cblas_srotmg+0x22c>
    D1 /= G2;
 8008472:	ee67 7a83 	vmul.f32	s15, s15, s6
    x *= G;
 8008476:	ee66 6a84 	vmul.f32	s13, s13, s8
  while (D1 >= G2) {
 800847a:	eef4 7ae3 	vcmpe.f32	s15, s7
 800847e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h11 *= G;
 8008482:	ee64 4a84 	vmul.f32	s9, s9, s8
    h12 *= G;
 8008486:	ee26 6a04 	vmul.f32	s12, s12, s8
  while (D1 >= G2) {
 800848a:	daf2      	bge.n	8008472 <cblas_srotmg+0x126>
 800848c:	4c36      	ldr	r4, [pc, #216]	; (8008568 <cblas_srotmg+0x21c>)
 800848e:	601c      	str	r4, [r3, #0]
  }

  /* rescale D2 to range [1/G2,G2] */

  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 8008490:	ed9f 3a36 	vldr	s6, [pc, #216]	; 800856c <cblas_srotmg+0x220>
 8008494:	eeb0 4ac7 	vabs.f32	s8, s14
 8008498:	eeb4 4ac3 	vcmpe.f32	s8, s6
 800849c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80084a0:	d818      	bhi.n	80084d4 <cblas_srotmg+0x188>
    P[0] = -1;
 80084a2:	4c31      	ldr	r4, [pc, #196]	; (8008568 <cblas_srotmg+0x21c>)
    D2 *= G2;
 80084a4:	eddf 2a32 	vldr	s5, [pc, #200]	; 8008570 <cblas_srotmg+0x224>
    h21 /= G;
 80084a8:	eddf 3a32 	vldr	s7, [pc, #200]	; 8008574 <cblas_srotmg+0x228>
 80084ac:	e00d      	b.n	80084ca <cblas_srotmg+0x17e>
    D2 *= G2;
 80084ae:	ee27 7a22 	vmul.f32	s14, s14, s5
    h21 /= G;
 80084b2:	ee25 5a23 	vmul.f32	s10, s10, s7
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 80084b6:	eeb0 4ac7 	vabs.f32	s8, s14
 80084ba:	eeb4 4ac3 	vcmpe.f32	s8, s6
 80084be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h22 /= G;
 80084c2:	ee65 5aa3 	vmul.f32	s11, s11, s7
    P[0] = -1;
 80084c6:	601c      	str	r4, [r3, #0]
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 80084c8:	d804      	bhi.n	80084d4 <cblas_srotmg+0x188>
 80084ca:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80084ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80084d2:	d1ec      	bne.n	80084ae <cblas_srotmg+0x162>
  }

  while (fabs(D2) >= G2) {
 80084d4:	ed9f 3a26 	vldr	s6, [pc, #152]	; 8008570 <cblas_srotmg+0x224>
 80084d8:	eeb4 4ac3 	vcmpe.f32	s8, s6
 80084dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80084e0:	db12      	blt.n	8008508 <cblas_srotmg+0x1bc>
    P[0] = -1;
    D2 /= G2;
 80084e2:	eddf 2a22 	vldr	s5, [pc, #136]	; 800856c <cblas_srotmg+0x220>
    h21 *= G;
 80084e6:	ed9f 4a24 	vldr	s8, [pc, #144]	; 8008578 <cblas_srotmg+0x22c>
    D2 /= G2;
 80084ea:	ee27 7a22 	vmul.f32	s14, s14, s5
    h21 *= G;
 80084ee:	ee25 5a04 	vmul.f32	s10, s10, s8
  while (fabs(D2) >= G2) {
 80084f2:	eef0 3ac7 	vabs.f32	s7, s14
 80084f6:	eef4 3ac3 	vcmpe.f32	s7, s6
 80084fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    h22 *= G;
 80084fe:	ee65 5a84 	vmul.f32	s11, s11, s8
  while (fabs(D2) >= G2) {
 8008502:	daf2      	bge.n	80084ea <cblas_srotmg+0x19e>
 8008504:	4c18      	ldr	r4, [pc, #96]	; (8008568 <cblas_srotmg+0x21c>)
 8008506:	601c      	str	r4, [r3, #0]
  }

  *d1 = D1;
 8008508:	edc0 7a00 	vstr	s15, [r0]
  *d2 = D2;
 800850c:	ed81 7a00 	vstr	s14, [r1]
  *b1 = x;
 8008510:	edc2 6a00 	vstr	s13, [r2]

  if (P[0] == -1.0) {
 8008514:	edd3 7a00 	vldr	s15, [r3]
 8008518:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 800851c:	eef4 7a47 	vcmp.f32	s15, s14
 8008520:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008524:	d109      	bne.n	800853a <cblas_srotmg+0x1ee>
 8008526:	bc30      	pop	{r4, r5}
    P[1] = h11;
 8008528:	edc3 4a01 	vstr	s9, [r3, #4]
    P[2] = h21;
 800852c:	ed83 5a02 	vstr	s10, [r3, #8]
    P[3] = h12;
 8008530:	ed83 6a03 	vstr	s12, [r3, #12]
    P[4] = h22;
 8008534:	edc3 5a04 	vstr	s11, [r3, #16]
 8008538:	4770      	bx	lr
  } else if (P[0] == 0.0) {
 800853a:	eef5 7a40 	vcmp.f32	s15, #0.0
 800853e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008542:	d104      	bne.n	800854e <cblas_srotmg+0x202>
    P[2] = h21;
 8008544:	ed83 5a02 	vstr	s10, [r3, #8]
    P[3] = h12;
 8008548:	ed83 6a03 	vstr	s12, [r3, #12]
 800854c:	e73f      	b.n	80083ce <cblas_srotmg+0x82>
  } else if (P[0] == 1.0) {
 800854e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8008552:	eef4 7a47 	vcmp.f32	s15, s14
 8008556:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    P[1] = h11;
 800855a:	bf04      	itt	eq
 800855c:	edc3 4a01 	vstreq	s9, [r3, #4]
    P[4] = h22;
 8008560:	edc3 5a04 	vstreq	s11, [r3, #16]
 8008564:	e733      	b.n	80083ce <cblas_srotmg+0x82>
 8008566:	bf00      	nop
 8008568:	bf800000 	.word	0xbf800000
 800856c:	33800000 	.word	0x33800000
 8008570:	4b800000 	.word	0x4b800000
 8008574:	39800000 	.word	0x39800000
 8008578:	45800000 	.word	0x45800000

0800857c <cblas_sscal>:

{
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 800857c:	2a00      	cmp	r2, #0
 800857e:	dd0d      	ble.n	800859c <cblas_sscal+0x20>
    return;
  }

  for (i = 0; i < N; i++) {
 8008580:	2800      	cmp	r0, #0
 8008582:	dd0b      	ble.n	800859c <cblas_sscal+0x20>
 8008584:	0092      	lsls	r2, r2, #2
 8008586:	2300      	movs	r3, #0
    X[ix] *= alpha;
 8008588:	edd1 7a00 	vldr	s15, [r1]
  for (i = 0; i < N; i++) {
 800858c:	3301      	adds	r3, #1
    X[ix] *= alpha;
 800858e:	ee67 7a80 	vmul.f32	s15, s15, s0
  for (i = 0; i < N; i++) {
 8008592:	4298      	cmp	r0, r3
    X[ix] *= alpha;
 8008594:	edc1 7a00 	vstr	s15, [r1]
  for (i = 0; i < N; i++) {
 8008598:	4411      	add	r1, r2
 800859a:	d1f5      	bne.n	8008588 <cblas_sscal+0xc>
cblas_sscal (const int N, const float alpha, float *X, const int incX)
{
#define BASE float
#include "source_scal_r.h"
#undef BASE
}
 800859c:	4770      	bx	lr
 800859e:	bf00      	nop

080085a0 <cblas_sswap>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_sswap (const int N, float *X, const int incX, float *Y, const int incY)
{
 80085a0:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80085a2:	2a00      	cmp	r2, #0
 80085a4:	9f04      	ldr	r7, [sp, #16]
 80085a6:	bfda      	itte	le
 80085a8:	f1c0 0501 	rsble	r5, r0, #1
 80085ac:	4355      	mulle	r5, r2
 80085ae:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 80085b0:	2f00      	cmp	r7, #0
 80085b2:	bfda      	itte	le
 80085b4:	f1c0 0401 	rsble	r4, r0, #1
 80085b8:	437c      	mulle	r4, r7
 80085ba:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 80085bc:	2800      	cmp	r0, #0
 80085be:	dd0f      	ble.n	80085e0 <cblas_sswap+0x40>
 80085c0:	0096      	lsls	r6, r2, #2
 80085c2:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 80085c6:	00bf      	lsls	r7, r7, #2
 80085c8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80085cc:	2200      	movs	r2, #0
 80085ce:	3201      	adds	r2, #1
    const BASE tmp = X[ix];
 80085d0:	680c      	ldr	r4, [r1, #0]
    X[ix] = Y[iy];
 80085d2:	681d      	ldr	r5, [r3, #0]
 80085d4:	600d      	str	r5, [r1, #0]
  for (i = 0; i < N; i++) {
 80085d6:	4290      	cmp	r0, r2
    Y[iy] = tmp;
 80085d8:	601c      	str	r4, [r3, #0]
  for (i = 0; i < N; i++) {
 80085da:	4431      	add	r1, r6
 80085dc:	443b      	add	r3, r7
 80085de:	d1f6      	bne.n	80085ce <cblas_sswap+0x2e>
#define BASE float
#include "source_swap_r.h"
#undef BASE
}
 80085e0:	bcf0      	pop	{r4, r5, r6, r7}
 80085e2:	4770      	bx	lr

080085e4 <cblas_ssymm>:
void
cblas_ssymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const float alpha, const float *A, const int lda, const float *B,
             const int ldb, const float beta, float *C, const int ldc)
{
 80085e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80085e8:	ed2d 8b02 	vpush	{d8}
 80085ec:	b08d      	sub	sp, #52	; 0x34
 80085ee:	461e      	mov	r6, r3
 80085f0:	e9dd b318 	ldrd	fp, r3, [sp, #96]	; 0x60
 80085f4:	9301      	str	r3, [sp, #4]
 80085f6:	e9dd 831a 	ldrd	r8, r3, [sp, #104]	; 0x68
 80085fa:	9305      	str	r3, [sp, #20]
 80085fc:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 80085fe:	9303      	str	r3, [sp, #12]
 8008600:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8008602:	9304      	str	r3, [sp, #16]
{
  INDEX i, j, k;
  INDEX n1, n2;
  int uplo, side;

  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8008604:	298d      	cmp	r1, #141	; 0x8d
 8008606:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8008608:	9302      	str	r3, [sp, #8]
 800860a:	460c      	mov	r4, r1
 800860c:	4607      	mov	r7, r0
 800860e:	4615      	mov	r5, r2
 8008610:	eeb0 8a40 	vmov.f32	s16, s0
 8008614:	eef0 8a60 	vmov.f32	s17, s1
 8008618:	f000 80ae 	beq.w	8008778 <cblas_ssymm+0x194>
 800861c:	298e      	cmp	r1, #142	; 0x8e
 800861e:	f000 81d4 	beq.w	80089ca <cblas_ssymm+0x3e6>
 8008622:	465b      	mov	r3, fp
 8008624:	2002      	movs	r0, #2
 8008626:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 800862a:	2a01      	cmp	r2, #1
 800862c:	bf88      	it	hi
 800862e:	2003      	movhi	r0, #3
 8008630:	2e00      	cmp	r6, #0
 8008632:	bfb8      	it	lt
 8008634:	2004      	movlt	r0, #4
 8008636:	2b01      	cmp	r3, #1
 8008638:	bfb8      	it	lt
 800863a:	2301      	movlt	r3, #1
 800863c:	f1bb 0f00 	cmp.w	fp, #0
 8008640:	f2c0 8090 	blt.w	8008764 <cblas_ssymm+0x180>
 8008644:	4543      	cmp	r3, r8
 8008646:	dd54      	ble.n	80086f2 <cblas_ssymm+0x10e>
 8008648:	2f65      	cmp	r7, #101	; 0x65
 800864a:	f000 81a2 	beq.w	8008992 <cblas_ssymm+0x3ae>
 800864e:	2f66      	cmp	r7, #102	; 0x66
 8008650:	f000 81ad 	beq.w	80089ae <cblas_ssymm+0x3ca>
 8008654:	2008      	movs	r0, #8
 8008656:	4a93      	ldr	r2, [pc, #588]	; (80088a4 <cblas_ssymm+0x2c0>)
 8008658:	4993      	ldr	r1, [pc, #588]	; (80088a8 <cblas_ssymm+0x2c4>)
 800865a:	f01f f9f5 	bl	8027a48 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 800865e:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8008662:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008666:	d106      	bne.n	8008676 <cblas_ssymm+0x92>
 8008668:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800866c:	eef4 8a67 	vcmp.f32	s17, s15
 8008670:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008674:	d04d      	beq.n	8008712 <cblas_ssymm+0x12e>
    return;

  if (Order == CblasRowMajor) {
 8008676:	2f65      	cmp	r7, #101	; 0x65
 8008678:	f000 8085 	beq.w	8008786 <cblas_ssymm+0x1a2>
    uplo = Uplo;
    side = Side;
  } else {
    n1 = N;
    n2 = M;
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800867c:	2d79      	cmp	r5, #121	; 0x79
 800867e:	bf0c      	ite	eq
 8008680:	257a      	moveq	r5, #122	; 0x7a
 8008682:	2579      	movne	r5, #121	; 0x79
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8008684:	2c8d      	cmp	r4, #141	; 0x8d
 8008686:	bf0c      	ite	eq
 8008688:	248e      	moveq	r4, #142	; 0x8e
 800868a:	248d      	movne	r4, #141	; 0x8d
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 800868c:	eef5 8a40 	vcmp.f32	s17, #0.0
 8008690:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008694:	d142      	bne.n	800871c <cblas_ssymm+0x138>
    for (i = 0; i < n1; i++) {
 8008696:	f1bb 0f00 	cmp.w	fp, #0
 800869a:	dd16      	ble.n	80086ca <cblas_ssymm+0xe6>
 800869c:	9b02      	ldr	r3, [sp, #8]
 800869e:	0099      	lsls	r1, r3, #2
 80086a0:	9b04      	ldr	r3, [sp, #16]
 80086a2:	ebc6 7286 	rsb	r2, r6, r6, lsl #30
 80086a6:	0092      	lsls	r2, r2, #2
 80086a8:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 80086ac:	2700      	movs	r7, #0
      for (j = 0; j < n2; j++) {
        C[ldc * i + j] = 0.0;
 80086ae:	f04f 0c00 	mov.w	ip, #0
      for (j = 0; j < n2; j++) {
 80086b2:	2e00      	cmp	r6, #0
 80086b4:	bfc8      	it	gt
 80086b6:	1883      	addgt	r3, r0, r2
 80086b8:	dd03      	ble.n	80086c2 <cblas_ssymm+0xde>
        C[ldc * i + j] = 0.0;
 80086ba:	f843 cb04 	str.w	ip, [r3], #4
      for (j = 0; j < n2; j++) {
 80086be:	4283      	cmp	r3, r0
 80086c0:	d1fb      	bne.n	80086ba <cblas_ssymm+0xd6>
    for (i = 0; i < n1; i++) {
 80086c2:	3701      	adds	r7, #1
 80086c4:	45bb      	cmp	fp, r7
 80086c6:	4408      	add	r0, r1
 80086c8:	d1f3      	bne.n	80086b2 <cblas_ssymm+0xce>
        C[ldc * i + j] *= beta;
      }
    }
  }

  if (alpha == 0.0)
 80086ca:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80086ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80086d2:	d01e      	beq.n	8008712 <cblas_ssymm+0x12e>
    return;

  if (side == CblasLeft && uplo == CblasUpper) {
 80086d4:	2c8d      	cmp	r4, #141	; 0x8d
 80086d6:	f000 80ed 	beq.w	80088b4 <cblas_ssymm+0x2d0>
        }
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
      }
    }

  } else if (side == CblasRight && uplo == CblasUpper) {
 80086da:	2c8e      	cmp	r4, #142	; 0x8e
 80086dc:	d057      	beq.n	800878e <cblas_ssymm+0x1aa>
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 80086de:	4a73      	ldr	r2, [pc, #460]	; (80088ac <cblas_ssymm+0x2c8>)
 80086e0:	4971      	ldr	r1, [pc, #452]	; (80088a8 <cblas_ssymm+0x2c4>)
 80086e2:	2000      	movs	r0, #0
#define BASE float
#include "source_symm_r.h"
#undef BASE
}
 80086e4:	b00d      	add	sp, #52	; 0x34
 80086e6:	ecbd 8b02 	vpop	{d8}
 80086ea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80086ee:	f01f b9ab 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80086f2:	2f65      	cmp	r7, #101	; 0x65
 80086f4:	f000 80a4 	beq.w	8008840 <cblas_ssymm+0x25c>
 80086f8:	2f66      	cmp	r7, #102	; 0x66
 80086fa:	f000 80b9 	beq.w	8008870 <cblas_ssymm+0x28c>
 80086fe:	2800      	cmp	r0, #0
 8008700:	d0ad      	beq.n	800865e <cblas_ssymm+0x7a>
 8008702:	e7a8      	b.n	8008656 <cblas_ssymm+0x72>
        C[i * ldc + j] += alpha * temp2;
 8008704:	eee8 7a25 	vfma.f32	s15, s16, s11
      for (j = 0; j < n2; j++) {
 8008708:	4576      	cmp	r6, lr
        C[i * ldc + j] += alpha * temp2;
 800870a:	ed47 7a01 	vstr	s15, [r7, #-4]
      for (j = 0; j < n2; j++) {
 800870e:	f300 81cb 	bgt.w	8008aa8 <cblas_ssymm+0x4c4>
 8008712:	b00d      	add	sp, #52	; 0x34
 8008714:	ecbd 8b02 	vpop	{d8}
 8008718:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 800871c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008720:	eef4 8a67 	vcmp.f32	s17, s15
 8008724:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008728:	d0cf      	beq.n	80086ca <cblas_ssymm+0xe6>
    for (i = 0; i < n1; i++) {
 800872a:	f1bb 0f00 	cmp.w	fp, #0
 800872e:	ddcc      	ble.n	80086ca <cblas_ssymm+0xe6>
 8008730:	9b02      	ldr	r3, [sp, #8]
 8008732:	009f      	lsls	r7, r3, #2
 8008734:	9b04      	ldr	r3, [sp, #16]
 8008736:	ebc6 7186 	rsb	r1, r6, r6, lsl #30
 800873a:	0089      	lsls	r1, r1, #2
 800873c:	eb03 0086 	add.w	r0, r3, r6, lsl #2
 8008740:	2200      	movs	r2, #0
      for (j = 0; j < n2; j++) {
 8008742:	2e00      	cmp	r6, #0
 8008744:	bfc8      	it	gt
 8008746:	1843      	addgt	r3, r0, r1
 8008748:	dd07      	ble.n	800875a <cblas_ssymm+0x176>
        C[ldc * i + j] *= beta;
 800874a:	edd3 7a00 	vldr	s15, [r3]
 800874e:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8008752:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j < n2; j++) {
 8008756:	4283      	cmp	r3, r0
 8008758:	d1f7      	bne.n	800874a <cblas_ssymm+0x166>
    for (i = 0; i < n1; i++) {
 800875a:	3201      	adds	r2, #1
 800875c:	4593      	cmp	fp, r2
 800875e:	4438      	add	r0, r7
 8008760:	d1ef      	bne.n	8008742 <cblas_ssymm+0x15e>
 8008762:	e7b2      	b.n	80086ca <cblas_ssymm+0xe6>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8008764:	4598      	cmp	r8, r3
 8008766:	f6ff af6f 	blt.w	8008648 <cblas_ssymm+0x64>
 800876a:	2f65      	cmp	r7, #101	; 0x65
 800876c:	d075      	beq.n	800885a <cblas_ssymm+0x276>
 800876e:	2f66      	cmp	r7, #102	; 0x66
 8008770:	f000 8242 	beq.w	8008bf8 <cblas_ssymm+0x614>
 8008774:	2005      	movs	r0, #5
 8008776:	e76e      	b.n	8008656 <cblas_ssymm+0x72>
 8008778:	3865      	subs	r0, #101	; 0x65
 800877a:	2801      	cmp	r0, #1
 800877c:	bf94      	ite	ls
 800877e:	2000      	movls	r0, #0
 8008780:	2001      	movhi	r0, #1
 8008782:	4633      	mov	r3, r6
 8008784:	e74f      	b.n	8008626 <cblas_ssymm+0x42>
    uplo = Uplo;
 8008786:	465b      	mov	r3, fp
    side = Side;
 8008788:	46b3      	mov	fp, r6
 800878a:	461e      	mov	r6, r3
 800878c:	e77e      	b.n	800868c <cblas_ssymm+0xa8>
  } else if (side == CblasRight && uplo == CblasUpper) {
 800878e:	2d79      	cmp	r5, #121	; 0x79
 8008790:	f000 81c8 	beq.w	8008b24 <cblas_ssymm+0x540>
  } else if (side == CblasRight && uplo == CblasLower) {
 8008794:	2d7a      	cmp	r5, #122	; 0x7a
 8008796:	d1a2      	bne.n	80086de <cblas_ssymm+0xfa>
    for (i = 0; i < n1; i++) {
 8008798:	f1bb 0f00 	cmp.w	fp, #0
 800879c:	ddb9      	ble.n	8008712 <cblas_ssymm+0x12e>
 800879e:	9a02      	ldr	r2, [sp, #8]
 80087a0:	f8dd a010 	ldr.w	sl, [sp, #16]
 80087a4:	9805      	ldr	r0, [sp, #20]
 80087a6:	0092      	lsls	r2, r2, #2
 80087a8:	9202      	str	r2, [sp, #8]
 80087aa:	9a03      	ldr	r2, [sp, #12]
 80087ac:	0092      	lsls	r2, r2, #2
 80087ae:	9203      	str	r2, [sp, #12]
 80087b0:	9a01      	ldr	r2, [sp, #4]
 80087b2:	f108 0301 	add.w	r3, r8, #1
 80087b6:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 80087ba:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80087be:	9306      	str	r3, [sp, #24]
 80087c0:	2300      	movs	r3, #0
 80087c2:	e9cd 6b04 	strd	r6, fp, [sp, #16]
 80087c6:	eb0a 0986 	add.w	r9, sl, r6, lsl #2
 80087ca:	9301      	str	r3, [sp, #4]
 80087cc:	4684      	mov	ip, r0
 80087ce:	4693      	mov	fp, r2
      for (j = 0; j < n2; j++) {
 80087d0:	9b04      	ldr	r3, [sp, #16]
 80087d2:	2b00      	cmp	r3, #0
 80087d4:	dd59      	ble.n	800888a <cblas_ssymm+0x2a6>
        const BASE temp1 = alpha * B[ldb * i + j];
 80087d6:	4667      	mov	r7, ip
 80087d8:	ecb7 6a01 	vldmia	r7!, {s12}
        BASE temp2 = 0.0;
 80087dc:	eddf 6a34 	vldr	s13, [pc, #208]	; 80088b0 <cblas_ssymm+0x2cc>
        const BASE temp1 = alpha * B[ldb * i + j];
 80087e0:	9806      	ldr	r0, [sp, #24]
 80087e2:	ee28 6a06 	vmul.f32	s12, s16, s12
 80087e6:	4646      	mov	r6, r8
 80087e8:	465d      	mov	r5, fp
 80087ea:	4654      	mov	r4, sl
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
 80087ec:	ed95 7a00 	vldr	s14, [r5]
 80087f0:	edd4 7a00 	vldr	s15, [r4]
 80087f4:	ee68 6a26 	vmul.f32	s13, s16, s13
 80087f8:	eee7 6a06 	vfma.f32	s13, s14, s12
 80087fc:	ee77 6aa6 	vadd.f32	s13, s15, s13
 8008800:	ece4 6a01 	vstmia	r4!, {s13}
      for (j = 0; j < n2; j++) {
 8008804:	454c      	cmp	r4, r9
 8008806:	d040      	beq.n	800888a <cblas_ssymm+0x2a6>
        const BASE temp1 = alpha * B[ldb * i + j];
 8008808:	ecb7 6a01 	vldmia	r7!, {s12}
        BASE temp2 = 0.0;
 800880c:	eddf 6a28 	vldr	s13, [pc, #160]	; 80088b0 <cblas_ssymm+0x2cc>
        const BASE temp1 = alpha * B[ldb * i + j];
 8008810:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = 0; k < j; k++) {
 8008814:	eb0b 0286 	add.w	r2, fp, r6, lsl #2
        const BASE temp1 = alpha * B[ldb * i + j];
 8008818:	4661      	mov	r1, ip
 800881a:	4653      	mov	r3, sl
          const BASE Ajk = A[j * lda + k];
 800881c:	ecb2 7a01 	vldmia	r2!, {s14}
          C[i * ldc + k] += temp1 * Ajk;
 8008820:	edd3 7a00 	vldr	s15, [r3]
 8008824:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = 0; k < j; k++) {
 8008828:	4282      	cmp	r2, r0
          C[i * ldc + k] += temp1 * Ajk;
 800882a:	ece3 7a01 	vstmia	r3!, {s15}
          temp2 += B[ldb * i + k] * Ajk;
 800882e:	ecf1 7a01 	vldmia	r1!, {s15}
 8008832:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = 0; k < j; k++) {
 8008836:	d1f1      	bne.n	800881c <cblas_ssymm+0x238>
 8008838:	4475      	add	r5, lr
 800883a:	4446      	add	r6, r8
 800883c:	4470      	add	r0, lr
 800883e:	e7d5      	b.n	80087ec <cblas_ssymm+0x208>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8008840:	465b      	mov	r3, fp
 8008842:	2b01      	cmp	r3, #1
 8008844:	9a03      	ldr	r2, [sp, #12]
 8008846:	bfb8      	it	lt
 8008848:	2301      	movlt	r3, #1
 800884a:	4293      	cmp	r3, r2
 800884c:	dc0a      	bgt.n	8008864 <cblas_ssymm+0x280>
 800884e:	9a02      	ldr	r2, [sp, #8]
 8008850:	4293      	cmp	r3, r2
 8008852:	f77f af54 	ble.w	80086fe <cblas_ssymm+0x11a>
 8008856:	200d      	movs	r0, #13
 8008858:	e6fd      	b.n	8008656 <cblas_ssymm+0x72>
 800885a:	9b03      	ldr	r3, [sp, #12]
 800885c:	2b00      	cmp	r3, #0
 800885e:	f300 815b 	bgt.w	8008b18 <cblas_ssymm+0x534>
 8008862:	2301      	movs	r3, #1
 8008864:	9a02      	ldr	r2, [sp, #8]
 8008866:	429a      	cmp	r2, r3
 8008868:	bfb4      	ite	lt
 800886a:	200d      	movlt	r0, #13
 800886c:	200a      	movge	r0, #10
 800886e:	e6f2      	b.n	8008656 <cblas_ssymm+0x72>
 8008870:	2e01      	cmp	r6, #1
 8008872:	9a03      	ldr	r2, [sp, #12]
 8008874:	4633      	mov	r3, r6
 8008876:	bfb8      	it	lt
 8008878:	2301      	movlt	r3, #1
 800887a:	4293      	cmp	r3, r2
 800887c:	dde7      	ble.n	800884e <cblas_ssymm+0x26a>
 800887e:	9a02      	ldr	r2, [sp, #8]
 8008880:	4293      	cmp	r3, r2
 8008882:	bfcc      	ite	gt
 8008884:	200d      	movgt	r0, #13
 8008886:	200a      	movle	r0, #10
 8008888:	e6e5      	b.n	8008656 <cblas_ssymm+0x72>
    for (i = 0; i < n1; i++) {
 800888a:	9a02      	ldr	r2, [sp, #8]
 800888c:	9b01      	ldr	r3, [sp, #4]
 800888e:	9903      	ldr	r1, [sp, #12]
 8008890:	4492      	add	sl, r2
 8008892:	4491      	add	r9, r2
 8008894:	9a05      	ldr	r2, [sp, #20]
 8008896:	3301      	adds	r3, #1
 8008898:	429a      	cmp	r2, r3
 800889a:	9301      	str	r3, [sp, #4]
 800889c:	448c      	add	ip, r1
 800889e:	d197      	bne.n	80087d0 <cblas_ssymm+0x1ec>
 80088a0:	e737      	b.n	8008712 <cblas_ssymm+0x12e>
 80088a2:	bf00      	nop
 80088a4:	08030378 	.word	0x08030378
 80088a8:	0803060c 	.word	0x0803060c
 80088ac:	080305a8 	.word	0x080305a8
 80088b0:	00000000 	.word	0x00000000
  if (side == CblasLeft && uplo == CblasUpper) {
 80088b4:	2d79      	cmp	r5, #121	; 0x79
 80088b6:	f000 808f 	beq.w	80089d8 <cblas_ssymm+0x3f4>
  } else if (side == CblasLeft && uplo == CblasLower) {
 80088ba:	2d7a      	cmp	r5, #122	; 0x7a
 80088bc:	f47f af0f 	bne.w	80086de <cblas_ssymm+0xfa>
    for (i = 0; i < n1; i++) {
 80088c0:	f1bb 0f00 	cmp.w	fp, #0
 80088c4:	f77f af25 	ble.w	8008712 <cblas_ssymm+0x12e>
 80088c8:	2300      	movs	r3, #0
 80088ca:	f108 0801 	add.w	r8, r8, #1
 80088ce:	ea4f 0288 	mov.w	r2, r8, lsl #2
 80088d2:	9801      	ldr	r0, [sp, #4]
 80088d4:	9306      	str	r3, [sp, #24]
 80088d6:	9301      	str	r3, [sp, #4]
 80088d8:	4698      	mov	r8, r3
 80088da:	9b03      	ldr	r3, [sp, #12]
 80088dc:	9208      	str	r2, [sp, #32]
 80088de:	3a04      	subs	r2, #4
 80088e0:	9207      	str	r2, [sp, #28]
 80088e2:	009c      	lsls	r4, r3, #2
 80088e4:	9a02      	ldr	r2, [sp, #8]
 80088e6:	9b05      	ldr	r3, [sp, #20]
 80088e8:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 80088ec:	f8dd b010 	ldr.w	fp, [sp, #16]
 80088f0:	9605      	str	r6, [sp, #20]
 80088f2:	4682      	mov	sl, r0
 80088f4:	eb03 0986 	add.w	r9, r3, r6, lsl #2
 80088f8:	0095      	lsls	r5, r2, #2
 80088fa:	469e      	mov	lr, r3
      for (j = 0; j < n2; j++) {
 80088fc:	9b05      	ldr	r3, [sp, #20]
 80088fe:	2b00      	cmp	r3, #0
 8008900:	dd34      	ble.n	800896c <cblas_ssymm+0x388>
 8008902:	9b01      	ldr	r3, [sp, #4]
 8008904:	eb0e 0c83 	add.w	ip, lr, r3, lsl #2
 8008908:	9b06      	ldr	r3, [sp, #24]
 800890a:	2600      	movs	r6, #0
 800890c:	eb0b 0783 	add.w	r7, fp, r3, lsl #2
        const BASE temp1 = alpha * B[ldb * i + j];
 8008910:	ecbc 6a01 	vldmia	ip!, {s12}
        BASE temp2 = 0.0;
 8008914:	ed5f 6a1a 	vldr	s13, [pc, #-104]	; 80088b0 <cblas_ssymm+0x2cc>
        const BASE temp1 = alpha * B[ldb * i + j];
 8008918:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = 0; k < i; k++) {
 800891c:	f1b8 0f00 	cmp.w	r8, #0
 8008920:	d014      	beq.n	800894c <cblas_ssymm+0x368>
 8008922:	eb0b 0386 	add.w	r3, fp, r6, lsl #2
 8008926:	eb0e 0186 	add.w	r1, lr, r6, lsl #2
 800892a:	4652      	mov	r2, sl
          const BASE Aik = A[i * lda + k];
 800892c:	ecb2 7a01 	vldmia	r2!, {s14}
          C[k * ldc + j] += Aik * temp1;
 8008930:	edd3 7a00 	vldr	s15, [r3]
 8008934:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = 0; k < i; k++) {
 8008938:	4290      	cmp	r0, r2
          C[k * ldc + j] += Aik * temp1;
 800893a:	edc3 7a00 	vstr	s15, [r3]
          temp2 += Aik * B[ldb * k + j];
 800893e:	edd1 7a00 	vldr	s15, [r1]
 8008942:	442b      	add	r3, r5
 8008944:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = 0; k < i; k++) {
 8008948:	4421      	add	r1, r4
 800894a:	d1ef      	bne.n	800892c <cblas_ssymm+0x348>
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800894c:	ed90 7a00 	vldr	s14, [r0]
 8008950:	edd7 7a00 	vldr	s15, [r7]
 8008954:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (j = 0; j < n2; j++) {
 8008958:	45e1      	cmp	r9, ip
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800895a:	eee7 6a06 	vfma.f32	s13, s14, s12
      for (j = 0; j < n2; j++) {
 800895e:	f106 0601 	add.w	r6, r6, #1
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 8008962:	ee77 6aa6 	vadd.f32	s13, s15, s13
 8008966:	ece7 6a01 	vstmia	r7!, {s13}
      for (j = 0; j < n2; j++) {
 800896a:	d1d1      	bne.n	8008910 <cblas_ssymm+0x32c>
    for (i = 0; i < n1; i++) {
 800896c:	9b06      	ldr	r3, [sp, #24]
 800896e:	9a02      	ldr	r2, [sp, #8]
 8008970:	4413      	add	r3, r2
 8008972:	9306      	str	r3, [sp, #24]
 8008974:	9b08      	ldr	r3, [sp, #32]
 8008976:	9a03      	ldr	r2, [sp, #12]
 8008978:	4418      	add	r0, r3
 800897a:	9b01      	ldr	r3, [sp, #4]
 800897c:	4413      	add	r3, r2
 800897e:	9301      	str	r3, [sp, #4]
 8008980:	9b07      	ldr	r3, [sp, #28]
 8008982:	449a      	add	sl, r3
 8008984:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008986:	f108 0801 	add.w	r8, r8, #1
 800898a:	4543      	cmp	r3, r8
 800898c:	44a1      	add	r9, r4
 800898e:	d1b5      	bne.n	80088fc <cblas_ssymm+0x318>
 8008990:	e6bf      	b.n	8008712 <cblas_ssymm+0x12e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8008992:	465b      	mov	r3, fp
 8008994:	2b01      	cmp	r3, #1
 8008996:	9a03      	ldr	r2, [sp, #12]
 8008998:	bfb8      	it	lt
 800899a:	2301      	movlt	r3, #1
 800899c:	4293      	cmp	r3, r2
 800899e:	f73f af61 	bgt.w	8008864 <cblas_ssymm+0x280>
 80089a2:	9a02      	ldr	r2, [sp, #8]
 80089a4:	4293      	cmp	r3, r2
 80089a6:	bfcc      	ite	gt
 80089a8:	200d      	movgt	r0, #13
 80089aa:	2008      	movle	r0, #8
 80089ac:	e653      	b.n	8008656 <cblas_ssymm+0x72>
 80089ae:	2e01      	cmp	r6, #1
 80089b0:	9a03      	ldr	r2, [sp, #12]
 80089b2:	4633      	mov	r3, r6
 80089b4:	bfb8      	it	lt
 80089b6:	2301      	movlt	r3, #1
 80089b8:	429a      	cmp	r2, r3
 80089ba:	f6ff af60 	blt.w	800887e <cblas_ssymm+0x29a>
 80089be:	9a02      	ldr	r2, [sp, #8]
 80089c0:	429a      	cmp	r2, r3
 80089c2:	bfac      	ite	ge
 80089c4:	2008      	movge	r0, #8
 80089c6:	200d      	movlt	r0, #13
 80089c8:	e645      	b.n	8008656 <cblas_ssymm+0x72>
 80089ca:	3865      	subs	r0, #101	; 0x65
 80089cc:	2801      	cmp	r0, #1
 80089ce:	bf94      	ite	ls
 80089d0:	2000      	movls	r0, #0
 80089d2:	2001      	movhi	r0, #1
 80089d4:	465b      	mov	r3, fp
 80089d6:	e626      	b.n	8008626 <cblas_ssymm+0x42>
    for (i = 0; i < n1; i++) {
 80089d8:	f1bb 0f00 	cmp.w	fp, #0
 80089dc:	f77f ae99 	ble.w	8008712 <cblas_ssymm+0x12e>
 80089e0:	f108 0801 	add.w	r8, r8, #1
 80089e4:	ea4f 0388 	mov.w	r3, r8, lsl #2
 80089e8:	930b      	str	r3, [sp, #44]	; 0x2c
 80089ea:	3b04      	subs	r3, #4
 80089ec:	930a      	str	r3, [sp, #40]	; 0x28
 80089ee:	9b01      	ldr	r3, [sp, #4]
        C[i * ldc + j] += alpha * temp2;
 80089f0:	ed5f 5a51 	vldr	s11, [pc, #-324]	; 80088b0 <cblas_ssymm+0x2cc>
    for (i = 0; i < n1; i++) {
 80089f4:	2200      	movs	r2, #0
 80089f6:	f103 0804 	add.w	r8, r3, #4
 80089fa:	eb03 008b 	add.w	r0, r3, fp, lsl #2
 80089fe:	9b02      	ldr	r3, [sp, #8]
 8008a00:	9206      	str	r2, [sp, #24]
 8008a02:	9208      	str	r2, [sp, #32]
 8008a04:	9a03      	ldr	r2, [sp, #12]
 8008a06:	9309      	str	r3, [sp, #36]	; 0x24
 8008a08:	009d      	lsls	r5, r3, #2
 8008a0a:	2301      	movs	r3, #1
 8008a0c:	0094      	lsls	r4, r2, #2
 8008a0e:	9207      	str	r2, [sp, #28]
 8008a10:	9301      	str	r3, [sp, #4]
      for (j = 0; j < n2; j++) {
 8008a12:	2e00      	cmp	r6, #0
 8008a14:	dd63      	ble.n	8008ade <cblas_ssymm+0x4fa>
 8008a16:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008a18:	9a07      	ldr	r2, [sp, #28]
 8008a1a:	4619      	mov	r1, r3
 8008a1c:	9b08      	ldr	r3, [sp, #32]
 8008a1e:	4617      	mov	r7, r2
 8008a20:	eba1 0a03 	sub.w	sl, r1, r3
 8008a24:	9a06      	ldr	r2, [sp, #24]
 8008a26:	9905      	ldr	r1, [sp, #20]
 8008a28:	eba7 0902 	sub.w	r9, r7, r2
 8008a2c:	eb01 0c82 	add.w	ip, r1, r2, lsl #2
 8008a30:	9a04      	ldr	r2, [sp, #16]
 8008a32:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8008a36:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8008a3a:	f1aa 0a04 	sub.w	sl, sl, #4
 8008a3e:	f1a9 0904 	sub.w	r9, r9, #4
 8008a42:	eb02 0783 	add.w	r7, r2, r3, lsl #2
 8008a46:	f04f 0e01 	mov.w	lr, #1
        const BASE temp1 = alpha * B[ldb * i + j];
 8008a4a:	ecbc 6a01 	vldmia	ip!, {s12}
        C[i * ldc + j] += temp1 * A[i * lda + i];
 8008a4e:	edd7 7a00 	vldr	s15, [r7]
 8008a52:	ed18 7a01 	vldr	s14, [r8, #-4]
        for (k = i + 1; k < n1; k++) {
 8008a56:	9b01      	ldr	r3, [sp, #4]
        const BASE temp1 = alpha * B[ldb * i + j];
 8008a58:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = i + 1; k < n1; k++) {
 8008a5c:	459b      	cmp	fp, r3
        C[i * ldc + j] += temp1 * A[i * lda + i];
 8008a5e:	eee7 7a06 	vfma.f32	s15, s14, s12
 8008a62:	ece7 7a01 	vstmia	r7!, {s15}
        for (k = i + 1; k < n1; k++) {
 8008a66:	f77f ae4d 	ble.w	8008704 <cblas_ssymm+0x120>
        BASE temp2 = 0.0;
 8008a6a:	ed5f 6a6f 	vldr	s13, [pc, #-444]	; 80088b0 <cblas_ssymm+0x2cc>
 8008a6e:	eb0a 0307 	add.w	r3, sl, r7
 8008a72:	eb09 010c 	add.w	r1, r9, ip
        for (k = i + 1; k < n1; k++) {
 8008a76:	4642      	mov	r2, r8
          const BASE Aik = A[i * lda + k];
 8008a78:	ecb2 7a01 	vldmia	r2!, {s14}
          C[k * ldc + j] += Aik * temp1;
 8008a7c:	edd3 7a00 	vldr	s15, [r3]
 8008a80:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = i + 1; k < n1; k++) {
 8008a84:	4290      	cmp	r0, r2
          C[k * ldc + j] += Aik * temp1;
 8008a86:	edc3 7a00 	vstr	s15, [r3]
          temp2 += Aik * B[ldb * k + j];
 8008a8a:	edd1 7a00 	vldr	s15, [r1]
 8008a8e:	442b      	add	r3, r5
 8008a90:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = i + 1; k < n1; k++) {
 8008a94:	4421      	add	r1, r4
 8008a96:	d1ef      	bne.n	8008a78 <cblas_ssymm+0x494>
        C[i * ldc + j] += alpha * temp2;
 8008a98:	ed57 7a01 	vldr	s15, [r7, #-4]
 8008a9c:	eee8 7a26 	vfma.f32	s15, s16, s13
      for (j = 0; j < n2; j++) {
 8008aa0:	4576      	cmp	r6, lr
        C[i * ldc + j] += alpha * temp2;
 8008aa2:	ed47 7a01 	vstr	s15, [r7, #-4]
      for (j = 0; j < n2; j++) {
 8008aa6:	dd02      	ble.n	8008aae <cblas_ssymm+0x4ca>
 8008aa8:	f10e 0e01 	add.w	lr, lr, #1
 8008aac:	e7cd      	b.n	8008a4a <cblas_ssymm+0x466>
    for (i = 0; i < n1; i++) {
 8008aae:	9b01      	ldr	r3, [sp, #4]
 8008ab0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8008ab2:	3301      	adds	r3, #1
 8008ab4:	9301      	str	r3, [sp, #4]
 8008ab6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008ab8:	4498      	add	r8, r3
 8008aba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008abc:	4611      	mov	r1, r2
 8008abe:	4418      	add	r0, r3
 8008ac0:	9a08      	ldr	r2, [sp, #32]
 8008ac2:	9b02      	ldr	r3, [sp, #8]
 8008ac4:	441a      	add	r2, r3
 8008ac6:	9208      	str	r2, [sp, #32]
 8008ac8:	9a07      	ldr	r2, [sp, #28]
 8008aca:	4419      	add	r1, r3
 8008acc:	9109      	str	r1, [sp, #36]	; 0x24
 8008ace:	9b03      	ldr	r3, [sp, #12]
 8008ad0:	4611      	mov	r1, r2
 8008ad2:	9a06      	ldr	r2, [sp, #24]
 8008ad4:	4419      	add	r1, r3
 8008ad6:	441a      	add	r2, r3
 8008ad8:	9107      	str	r1, [sp, #28]
 8008ada:	9206      	str	r2, [sp, #24]
 8008adc:	e799      	b.n	8008a12 <cblas_ssymm+0x42e>
 8008ade:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8008ae0:	9909      	ldr	r1, [sp, #36]	; 0x24
 8008ae2:	f8dd c004 	ldr.w	ip, [sp, #4]
 8008ae6:	4490      	add	r8, r2
 8008ae8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008aea:	460f      	mov	r7, r1
 8008aec:	4410      	add	r0, r2
 8008aee:	9908      	ldr	r1, [sp, #32]
 8008af0:	9a02      	ldr	r2, [sp, #8]
 8008af2:	4411      	add	r1, r2
 8008af4:	9108      	str	r1, [sp, #32]
 8008af6:	9907      	ldr	r1, [sp, #28]
 8008af8:	4417      	add	r7, r2
 8008afa:	9709      	str	r7, [sp, #36]	; 0x24
 8008afc:	9a03      	ldr	r2, [sp, #12]
 8008afe:	460f      	mov	r7, r1
 8008b00:	9906      	ldr	r1, [sp, #24]
 8008b02:	4663      	mov	r3, ip
 8008b04:	4417      	add	r7, r2
 8008b06:	4411      	add	r1, r2
 8008b08:	3301      	adds	r3, #1
 8008b0a:	45e3      	cmp	fp, ip
 8008b0c:	9707      	str	r7, [sp, #28]
 8008b0e:	9106      	str	r1, [sp, #24]
 8008b10:	9301      	str	r3, [sp, #4]
 8008b12:	f73f af7e 	bgt.w	8008a12 <cblas_ssymm+0x42e>
 8008b16:	e5fc      	b.n	8008712 <cblas_ssymm+0x12e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8008b18:	9b02      	ldr	r3, [sp, #8]
 8008b1a:	2b00      	cmp	r3, #0
 8008b1c:	bfcc      	ite	gt
 8008b1e:	2005      	movgt	r0, #5
 8008b20:	200d      	movle	r0, #13
 8008b22:	e598      	b.n	8008656 <cblas_ssymm+0x72>
    for (i = 0; i < n1; i++) {
 8008b24:	f1bb 0f00 	cmp.w	fp, #0
 8008b28:	f77f adf3 	ble.w	8008712 <cblas_ssymm+0x12e>
 8008b2c:	9b03      	ldr	r3, [sp, #12]
        C[i * ldc + j] += alpha * temp2;
 8008b2e:	ed5f 5aa0 	vldr	s11, [pc, #-640]	; 80088b0 <cblas_ssymm+0x2cc>
 8008b32:	009b      	lsls	r3, r3, #2
 8008b34:	9306      	str	r3, [sp, #24]
 8008b36:	00b3      	lsls	r3, r6, #2
 8008b38:	930a      	str	r3, [sp, #40]	; 0x28
 8008b3a:	9b05      	ldr	r3, [sp, #20]
 8008b3c:	eb03 0c86 	add.w	ip, r3, r6, lsl #2
 8008b40:	9b01      	ldr	r3, [sp, #4]
 8008b42:	f108 0e01 	add.w	lr, r8, #1
    for (i = 0; i < n1; i++) {
 8008b46:	f04f 0a00 	mov.w	sl, #0
 8008b4a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 8008b4e:	e9cd 6b07 	strd	r6, fp, [sp, #28]
 8008b52:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8008b56:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8008b5a:	46d1      	mov	r9, sl
 8008b5c:	9309      	str	r3, [sp, #36]	; 0x24
 8008b5e:	46d3      	mov	fp, sl
      for (j = 0; j < n2; j++) {
 8008b60:	9b07      	ldr	r3, [sp, #28]
 8008b62:	2b00      	cmp	r3, #0
 8008b64:	dd3c      	ble.n	8008be0 <cblas_ssymm+0x5fc>
 8008b66:	9b05      	ldr	r3, [sp, #20]
 8008b68:	9809      	ldr	r0, [sp, #36]	; 0x24
 8008b6a:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 8008b6e:	9b04      	ldr	r3, [sp, #16]
 8008b70:	eb03 048a 	add.w	r4, r3, sl, lsl #2
 8008b74:	9b01      	ldr	r3, [sp, #4]
 8008b76:	ea4f 078a 	mov.w	r7, sl, lsl #2
 8008b7a:	1d1e      	adds	r6, r3, #4
        const BASE temp1 = alpha * B[ldb * i + j];
 8008b7c:	ecb5 6a01 	vldmia	r5!, {s12}
        C[i * ldc + j] += temp1 * A[j * lda + j];
 8008b80:	edd4 7a00 	vldr	s15, [r4]
 8008b84:	ed16 7a01 	vldr	s14, [r6, #-4]
        const BASE temp1 = alpha * B[ldb * i + j];
 8008b88:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (k = j + 1; k < n2; k++) {
 8008b8c:	45ac      	cmp	ip, r5
        C[i * ldc + j] += temp1 * A[j * lda + j];
 8008b8e:	eee7 7a06 	vfma.f32	s15, s14, s12
 8008b92:	ece4 7a01 	vstmia	r4!, {s15}
        for (k = j + 1; k < n2; k++) {
 8008b96:	d01b      	beq.n	8008bd0 <cblas_ssymm+0x5ec>
        BASE temp2 = 0.0;
 8008b98:	ed5f 6abb 	vldr	s13, [pc, #-748]	; 80088b0 <cblas_ssymm+0x2cc>
        for (k = j + 1; k < n2; k++) {
 8008b9c:	4629      	mov	r1, r5
 8008b9e:	4622      	mov	r2, r4
 8008ba0:	4633      	mov	r3, r6
          const BASE Ajk = A[j * lda + k];
 8008ba2:	ecb3 7a01 	vldmia	r3!, {s14}
          C[i * ldc + k] += temp1 * Ajk;
 8008ba6:	edd2 7a00 	vldr	s15, [r2]
 8008baa:	eee6 7a07 	vfma.f32	s15, s12, s14
        for (k = j + 1; k < n2; k++) {
 8008bae:	4283      	cmp	r3, r0
          C[i * ldc + k] += temp1 * Ajk;
 8008bb0:	ece2 7a01 	vstmia	r2!, {s15}
          temp2 += B[ldb * i + k] * Ajk;
 8008bb4:	ecf1 7a01 	vldmia	r1!, {s15}
 8008bb8:	eee7 6a87 	vfma.f32	s13, s15, s14
        for (k = j + 1; k < n2; k++) {
 8008bbc:	d1f1      	bne.n	8008ba2 <cblas_ssymm+0x5be>
        C[i * ldc + j] += alpha * temp2;
 8008bbe:	ed54 7a01 	vldr	s15, [r4, #-4]
 8008bc2:	eee8 7a26 	vfma.f32	s15, s16, s13
 8008bc6:	4476      	add	r6, lr
 8008bc8:	4440      	add	r0, r8
 8008bca:	ed44 7a01 	vstr	s15, [r4, #-4]
      for (j = 0; j < n2; j++) {
 8008bce:	e7d5      	b.n	8008b7c <cblas_ssymm+0x598>
        C[i * ldc + j] += alpha * temp2;
 8008bd0:	eee8 7a25 	vfma.f32	s15, s16, s11
 8008bd4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8008bd6:	9a04      	ldr	r2, [sp, #16]
 8008bd8:	443b      	add	r3, r7
 8008bda:	4413      	add	r3, r2
 8008bdc:	ed43 7a01 	vstr	s15, [r3, #-4]
    for (i = 0; i < n1; i++) {
 8008be0:	9b03      	ldr	r3, [sp, #12]
 8008be2:	449b      	add	fp, r3
 8008be4:	9b02      	ldr	r3, [sp, #8]
 8008be6:	449a      	add	sl, r3
 8008be8:	9b06      	ldr	r3, [sp, #24]
 8008bea:	449c      	add	ip, r3
 8008bec:	9b08      	ldr	r3, [sp, #32]
 8008bee:	f109 0901 	add.w	r9, r9, #1
 8008bf2:	454b      	cmp	r3, r9
 8008bf4:	d1b4      	bne.n	8008b60 <cblas_ssymm+0x57c>
 8008bf6:	e58c      	b.n	8008712 <cblas_ssymm+0x12e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8008bf8:	2e01      	cmp	r6, #1
 8008bfa:	9a03      	ldr	r2, [sp, #12]
 8008bfc:	4633      	mov	r3, r6
 8008bfe:	bfb8      	it	lt
 8008c00:	2301      	movlt	r3, #1
 8008c02:	429a      	cmp	r2, r3
 8008c04:	f6ff ae3b 	blt.w	800887e <cblas_ssymm+0x29a>
 8008c08:	9a02      	ldr	r2, [sp, #8]
 8008c0a:	429a      	cmp	r2, r3
 8008c0c:	bfac      	ite	ge
 8008c0e:	2005      	movge	r0, #5
 8008c10:	200d      	movlt	r0, #13
 8008c12:	e520      	b.n	8008656 <cblas_ssymm+0x72>

08008c14 <cblas_ssymv>:
void
cblas_ssymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const float alpha, const float *A, const int lda,
             const float *X, const int incX, const float beta, float *Y,
             const int incY)
{
 8008c14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008c18:	ed2d 8b02 	vpush	{d8}
 8008c1c:	b089      	sub	sp, #36	; 0x24
 8008c1e:	461c      	mov	r4, r3
 8008c20:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
 8008c24:	4689      	mov	r9, r1
 */

{
  INDEX i, j;

  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8008c26:	3979      	subs	r1, #121	; 0x79
 8008c28:	2901      	cmp	r1, #1
 8008c2a:	e9dd a814 	ldrd	sl, r8, [sp, #80]	; 0x50
 8008c2e:	9f18      	ldr	r7, [sp, #96]	; 0x60
 8008c30:	9301      	str	r3, [sp, #4]
 8008c32:	4683      	mov	fp, r0
 8008c34:	4615      	mov	r5, r2
 8008c36:	eeb0 8a40 	vmov.f32	s16, s0
 8008c3a:	eef0 8a60 	vmov.f32	s17, s1
 8008c3e:	f240 8096 	bls.w	8008d6e <cblas_ssymv+0x15a>
 8008c42:	2002      	movs	r0, #2
 8008c44:	2d00      	cmp	r5, #0
 8008c46:	f2c0 8086 	blt.w	8008d56 <cblas_ssymv+0x142>
 8008c4a:	2d01      	cmp	r5, #1
 8008c4c:	462b      	mov	r3, r5
 8008c4e:	bfb8      	it	lt
 8008c50:	2301      	movlt	r3, #1
 8008c52:	4553      	cmp	r3, sl
 8008c54:	dd72      	ble.n	8008d3c <cblas_ssymv+0x128>
 8008c56:	2e00      	cmp	r6, #0
 8008c58:	d178      	bne.n	8008d4c <cblas_ssymv+0x138>
 8008c5a:	2f00      	cmp	r7, #0
 8008c5c:	bf0c      	ite	eq
 8008c5e:	200b      	moveq	r0, #11
 8008c60:	2008      	movne	r0, #8
 8008c62:	4acf      	ldr	r2, [pc, #828]	; (8008fa0 <cblas_ssymv+0x38c>)
 8008c64:	49cf      	ldr	r1, [pc, #828]	; (8008fa4 <cblas_ssymv+0x390>)
 8008c66:	f01e feef 	bl	8027a48 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 8008c6a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8008c6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c72:	d141      	bne.n	8008cf8 <cblas_ssymv+0xe4>
 8008c74:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008c78:	eef4 8a67 	vcmp.f32	s17, s15
 8008c7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c80:	d035      	beq.n	8008cee <cblas_ssymv+0xda>
    return;

  /* form  y := beta*y */
  if (beta == 0.0) {
 8008c82:	eef5 8a40 	vcmp.f32	s17, #0.0
 8008c86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008c8a:	d141      	bne.n	8008d10 <cblas_ssymv+0xfc>
    INDEX iy = OFFSET(N, incY);
 8008c8c:	2f00      	cmp	r7, #0
 8008c8e:	f340 8102 	ble.w	8008e96 <cblas_ssymv+0x282>
 8008c92:	2300      	movs	r3, #0
    for (i = 0; i < N; i++) {
 8008c94:	2d00      	cmp	r5, #0
 8008c96:	dd0a      	ble.n	8008cae <cblas_ssymv+0x9a>
 8008c98:	9a01      	ldr	r2, [sp, #4]
      Y[iy] = 0.0;
 8008c9a:	2000      	movs	r0, #0
 8008c9c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008ca0:	00b9      	lsls	r1, r7, #2
    for (i = 0; i < N; i++) {
 8008ca2:	2200      	movs	r2, #0
 8008ca4:	3201      	adds	r2, #1
 8008ca6:	4295      	cmp	r5, r2
      Y[iy] = 0.0;
 8008ca8:	6018      	str	r0, [r3, #0]
    for (i = 0; i < N; i++) {
 8008caa:	440b      	add	r3, r1
 8008cac:	d1fa      	bne.n	8008ca4 <cblas_ssymv+0x90>
      Y[iy] *= beta;
      iy += incY;
    }
  }

  if (alpha == 0.0)
 8008cae:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8008cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008cb6:	d01a      	beq.n	8008cee <cblas_ssymv+0xda>
    return;

  /* form  y := alpha*A*x + y */

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8008cb8:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8008cbc:	f000 80e3 	beq.w	8008e86 <cblas_ssymv+0x272>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8008cc0:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 8008cc4:	d059      	beq.n	8008d7a <cblas_ssymv+0x166>
      Y[iy] += alpha * temp2;
      ix -= incX;
      iy -= incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8008cc6:	4ab8      	ldr	r2, [pc, #736]	; (8008fa8 <cblas_ssymv+0x394>)
 8008cc8:	49b6      	ldr	r1, [pc, #728]	; (8008fa4 <cblas_ssymv+0x390>)
 8008cca:	2000      	movs	r0, #0
#define BASE float
#include "source_symv.h"
#undef BASE
}
 8008ccc:	b009      	add	sp, #36	; 0x24
 8008cce:	ecbd 8b02 	vpop	{d8}
 8008cd2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008cd6:	f01e beb7 	b.w	8027a48 <cblas_xerbla>
 8008cda:	9a06      	ldr	r2, [sp, #24]
      Y[iy] += alpha * temp2;
 8008cdc:	eee8 7a07 	vfma.f32	s15, s16, s14
 8008ce0:	fb07 2303 	mla	r3, r7, r3, r2
 8008ce4:	9a01      	ldr	r2, [sp, #4]
 8008ce6:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008cea:	edc3 7a00 	vstr	s15, [r3]
 8008cee:	b009      	add	sp, #36	; 0x24
 8008cf0:	ecbd 8b02 	vpop	{d8}
 8008cf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (beta == 0.0) {
 8008cf8:	eef5 8a40 	vcmp.f32	s17, #0.0
 8008cfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008d00:	d0c4      	beq.n	8008c8c <cblas_ssymv+0x78>
  } else if (beta != 1.0) {
 8008d02:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8008d06:	eef4 8a67 	vcmp.f32	s17, s15
 8008d0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008d0e:	d0d3      	beq.n	8008cb8 <cblas_ssymv+0xa4>
    INDEX iy = OFFSET(N, incY);
 8008d10:	2f00      	cmp	r7, #0
 8008d12:	f340 80b3 	ble.w	8008e7c <cblas_ssymv+0x268>
 8008d16:	2300      	movs	r3, #0
    for (i = 0; i < N; i++) {
 8008d18:	2d00      	cmp	r5, #0
 8008d1a:	ddc8      	ble.n	8008cae <cblas_ssymv+0x9a>
 8008d1c:	9a01      	ldr	r2, [sp, #4]
 8008d1e:	00b9      	lsls	r1, r7, #2
 8008d20:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008d24:	2200      	movs	r2, #0
      Y[iy] *= beta;
 8008d26:	edd3 7a00 	vldr	s15, [r3]
    for (i = 0; i < N; i++) {
 8008d2a:	3201      	adds	r2, #1
      Y[iy] *= beta;
 8008d2c:	ee67 7aa8 	vmul.f32	s15, s15, s17
    for (i = 0; i < N; i++) {
 8008d30:	4295      	cmp	r5, r2
      Y[iy] *= beta;
 8008d32:	edc3 7a00 	vstr	s15, [r3]
    for (i = 0; i < N; i++) {
 8008d36:	440b      	add	r3, r1
 8008d38:	d1f5      	bne.n	8008d26 <cblas_ssymv+0x112>
 8008d3a:	e7b8      	b.n	8008cae <cblas_ssymv+0x9a>
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8008d3c:	2e00      	cmp	r6, #0
 8008d3e:	d08c      	beq.n	8008c5a <cblas_ssymv+0x46>
 8008d40:	2f00      	cmp	r7, #0
 8008d42:	f000 8135 	beq.w	8008fb0 <cblas_ssymv+0x39c>
 8008d46:	2800      	cmp	r0, #0
 8008d48:	d08f      	beq.n	8008c6a <cblas_ssymv+0x56>
 8008d4a:	e78a      	b.n	8008c62 <cblas_ssymv+0x4e>
 8008d4c:	2f00      	cmp	r7, #0
 8008d4e:	bf0c      	ite	eq
 8008d50:	200b      	moveq	r0, #11
 8008d52:	2006      	movne	r0, #6
 8008d54:	e785      	b.n	8008c62 <cblas_ssymv+0x4e>
 8008d56:	f1ba 0f00 	cmp.w	sl, #0
 8008d5a:	f77f af7c 	ble.w	8008c56 <cblas_ssymv+0x42>
 8008d5e:	2e00      	cmp	r6, #0
 8008d60:	f43f af7b 	beq.w	8008c5a <cblas_ssymv+0x46>
 8008d64:	2f00      	cmp	r7, #0
 8008d66:	bf0c      	ite	eq
 8008d68:	200b      	moveq	r0, #11
 8008d6a:	2003      	movne	r0, #3
 8008d6c:	e779      	b.n	8008c62 <cblas_ssymv+0x4e>
 8008d6e:	3865      	subs	r0, #101	; 0x65
 8008d70:	2801      	cmp	r0, #1
 8008d72:	bf94      	ite	ls
 8008d74:	2000      	movls	r0, #0
 8008d76:	2001      	movhi	r0, #1
 8008d78:	e764      	b.n	8008c44 <cblas_ssymv+0x30>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8008d7a:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8008d7e:	f000 808f 	beq.w	8008ea0 <cblas_ssymv+0x28c>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 8008d82:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8008d86:	d19e      	bne.n	8008cc6 <cblas_ssymv+0xb2>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8008d88:	2e00      	cmp	r6, #0
 8008d8a:	f105 32ff 	add.w	r2, r5, #4294967295
 8008d8e:	bfd6      	itet	le
 8008d90:	f1c6 0c00 	rsble	ip, r6, #0
 8008d94:	f04f 0c00 	movgt.w	ip, #0
 8008d98:	fb02 fc0c 	mulle.w	ip, r2, ip
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8008d9c:	2f00      	cmp	r7, #0
 8008d9e:	bfda      	itte	le
 8008da0:	f1c7 0e00 	rsble	lr, r7, #0
 8008da4:	fb02 fe0e 	mulle.w	lr, r2, lr
 8008da8:	f04f 0e00 	movgt.w	lr, #0
 8008dac:	fb02 e307 	mla	r3, r2, r7, lr
    for (i = N; i > 0 && i--;) {
 8008db0:	2d00      	cmp	r5, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8008db2:	fb02 c106 	mla	r1, r2, r6, ip
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 8008db6:	9304      	str	r3, [sp, #16]
    for (i = N; i > 0 && i--;) {
 8008db8:	dd99      	ble.n	8008cee <cblas_ssymv+0xda>
 8008dba:	fb02 f00a 	mul.w	r0, r2, sl
 8008dbe:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 8008dc2:	1813      	adds	r3, r2, r0
 8008dc4:	ebc7 7b87 	rsb	fp, r7, r7, lsl #30
 8008dc8:	ea6f 090a 	mvn.w	r9, sl
 8008dcc:	9105      	str	r1, [sp, #20]
 8008dce:	ebca 7a8a 	rsb	sl, sl, sl, lsl #30
 8008dd2:	9901      	ldr	r1, [sp, #4]
 8008dd4:	9206      	str	r2, [sp, #24]
 8008dd6:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8008dda:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8008dde:	ea4f 048b 	mov.w	r4, fp, lsl #2
 8008de2:	9403      	str	r4, [sp, #12]
 8008de4:	ea4f 048a 	mov.w	r4, sl, lsl #2
 8008de8:	eb01 0e8e 	add.w	lr, r1, lr, lsl #2
 8008dec:	9407      	str	r4, [sp, #28]
 8008dee:	9901      	ldr	r1, [sp, #4]
 8008df0:	9c04      	ldr	r4, [sp, #16]
 8008df2:	f8cd e008 	str.w	lr, [sp, #8]
 8008df6:	ebc6 7586 	rsb	r5, r6, r6, lsl #30
 8008dfa:	f8dd e01c 	ldr.w	lr, [sp, #28]
 8008dfe:	ea4f 0b89 	mov.w	fp, r9, lsl #2
 8008e02:	eb01 0a84 	add.w	sl, r1, r4, lsl #2
 8008e06:	eb08 088c 	add.w	r8, r8, ip, lsl #2
 8008e0a:	9905      	ldr	r1, [sp, #20]
 8008e0c:	9705      	str	r7, [sp, #20]
 8008e0e:	00ad      	lsls	r5, r5, #2
 8008e10:	00b6      	lsls	r6, r6, #2
 8008e12:	ea4f 0987 	mov.w	r9, r7, lsl #2
      BASE temp1 = alpha * X[ix];
 8008e16:	ed91 6a00 	vldr	s12, [r1]
      Y[iy] += temp1 * A[lda * i + i];
 8008e1a:	ed93 7a00 	vldr	s14, [r3]
 8008e1e:	edda 7a00 	vldr	s15, [sl]
      BASE temp1 = alpha * X[ix];
 8008e22:	ee28 6a06 	vmul.f32	s12, s16, s12
      Y[iy] += temp1 * A[lda * i + i];
 8008e26:	eee7 7a06 	vfma.f32	s15, s14, s12
 8008e2a:	edca 7a00 	vstr	s15, [sl]
      for (j = j_min; j < j_max; j++) {
 8008e2e:	2a00      	cmp	r2, #0
 8008e30:	f000 80a2 	beq.w	8008f78 <cblas_ssymv+0x364>
      BASE temp2 = 0.0;
 8008e34:	ed9f 7a5d 	vldr	s14, [pc, #372]	; 8008fac <cblas_ssymv+0x398>
      for (j = j_min; j < j_max; j++) {
 8008e38:	9c02      	ldr	r4, [sp, #8]
 8008e3a:	46c4      	mov	ip, r8
 8008e3c:	4607      	mov	r7, r0
        Y[jy] += temp1 * A[lda * i + j];
 8008e3e:	edd7 6a00 	vldr	s13, [r7]
 8008e42:	edd4 7a00 	vldr	s15, [r4]
 8008e46:	eee6 7a86 	vfma.f32	s15, s13, s12
 8008e4a:	edc4 7a00 	vstr	s15, [r4]
        temp2 += X[jx] * A[lda * i + j];
 8008e4e:	ecf7 7a01 	vldmia	r7!, {s15}
 8008e52:	eddc 6a00 	vldr	s13, [ip]
      for (j = j_min; j < j_max; j++) {
 8008e56:	429f      	cmp	r7, r3
        temp2 += X[jx] * A[lda * i + j];
 8008e58:	eea6 7aa7 	vfma.f32	s14, s13, s15
      for (j = j_min; j < j_max; j++) {
 8008e5c:	444c      	add	r4, r9
 8008e5e:	44b4      	add	ip, r6
 8008e60:	d1ed      	bne.n	8008e3e <cblas_ssymv+0x22a>
      Y[iy] += alpha * temp2;
 8008e62:	edda 7a00 	vldr	s15, [sl]
 8008e66:	9c03      	ldr	r4, [sp, #12]
 8008e68:	eee8 7a07 	vfma.f32	s15, s16, s14
 8008e6c:	4429      	add	r1, r5
 8008e6e:	445b      	add	r3, fp
 8008e70:	4470      	add	r0, lr
 8008e72:	edca 7a00 	vstr	s15, [sl]
    for (i = N; i > 0 && i--;) {
 8008e76:	3a01      	subs	r2, #1
 8008e78:	44a2      	add	sl, r4
 8008e7a:	e7cc      	b.n	8008e16 <cblas_ssymv+0x202>
    INDEX iy = OFFSET(N, incY);
 8008e7c:	f1c5 0301 	rsb	r3, r5, #1
 8008e80:	fb03 f307 	mul.w	r3, r3, r7
 8008e84:	e748      	b.n	8008d18 <cblas_ssymv+0x104>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8008e86:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8008e8a:	d009      	beq.n	8008ea0 <cblas_ssymv+0x28c>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8008e8c:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8008e90:	f47f af19 	bne.w	8008cc6 <cblas_ssymv+0xb2>
 8008e94:	e778      	b.n	8008d88 <cblas_ssymv+0x174>
    INDEX iy = OFFSET(N, incY);
 8008e96:	f1c5 0301 	rsb	r3, r5, #1
 8008e9a:	fb03 f307 	mul.w	r3, r3, r7
 8008e9e:	e6f9      	b.n	8008c94 <cblas_ssymv+0x80>
    INDEX ix = OFFSET(N, incX);
 8008ea0:	2e00      	cmp	r6, #0
 8008ea2:	bfda      	itte	le
 8008ea4:	f1c5 0901 	rsble	r9, r5, #1
 8008ea8:	fb09 f906 	mulle.w	r9, r9, r6
 8008eac:	f04f 0900 	movgt.w	r9, #0
    INDEX iy = OFFSET(N, incY);
 8008eb0:	2f00      	cmp	r7, #0
 8008eb2:	bfda      	itte	le
 8008eb4:	f1c5 0301 	rsble	r3, r5, #1
 8008eb8:	437b      	mulle	r3, r7
 8008eba:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8008ebc:	2d00      	cmp	r5, #0
    INDEX iy = OFFSET(N, incY);
 8008ebe:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 8008ec0:	f77f af15 	ble.w	8008cee <cblas_ssymv+0xda>
 8008ec4:	ebc6 7386 	rsb	r3, r6, r6, lsl #30
 8008ec8:	009b      	lsls	r3, r3, #2
 8008eca:	f10a 0a01 	add.w	sl, sl, #1
 8008ece:	9302      	str	r3, [sp, #8]
 8008ed0:	9b06      	ldr	r3, [sp, #24]
 8008ed2:	9801      	ldr	r0, [sp, #4]
 8008ed4:	9605      	str	r6, [sp, #20]
 8008ed6:	ea4f 028a 	mov.w	r2, sl, lsl #2
 8008eda:	19d9      	adds	r1, r3, r7
 8008edc:	9204      	str	r2, [sp, #16]
 8008ede:	3a04      	subs	r2, #4
 8008ee0:	9203      	str	r2, [sp, #12]
 8008ee2:	eb00 0e83 	add.w	lr, r0, r3, lsl #2
 8008ee6:	f104 0a04 	add.w	sl, r4, #4
 8008eea:	44b1      	add	r9, r6
 8008eec:	00ba      	lsls	r2, r7, #2
 8008eee:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 8008ef2:	ea4f 0c86 	mov.w	ip, r6, lsl #2
 8008ef6:	2300      	movs	r3, #0
 8008ef8:	468b      	mov	fp, r1
      BASE temp1 = alpha * X[ix];
 8008efa:	9902      	ldr	r1, [sp, #8]
      Y[iy] += temp1 * A[lda * i + i];
 8008efc:	ed1a 7a01 	vldr	s14, [sl, #-4]
 8008f00:	edde 7a00 	vldr	s15, [lr]
      BASE temp1 = alpha * X[ix];
 8008f04:	eb01 0189 	add.w	r1, r1, r9, lsl #2
 8008f08:	4441      	add	r1, r8
 8008f0a:	ed91 6a00 	vldr	s12, [r1]
 8008f0e:	ee28 6a06 	vmul.f32	s12, s16, s12
      const INDEX j_min = i + 1;
 8008f12:	1c5e      	adds	r6, r3, #1
      Y[iy] += temp1 * A[lda * i + i];
 8008f14:	eee7 7a06 	vfma.f32	s15, s14, s12
      for (j = j_min; j < j_max; j++) {
 8008f18:	42b5      	cmp	r5, r6
 8008f1a:	ea4f 0089 	mov.w	r0, r9, lsl #2
      BASE temp2 = 0.0;
 8008f1e:	ed9f 7a23 	vldr	s14, [pc, #140]	; 8008fac <cblas_ssymv+0x398>
      Y[iy] += temp1 * A[lda * i + i];
 8008f22:	edce 7a00 	vstr	s15, [lr]
      for (j = j_min; j < j_max; j++) {
 8008f26:	f43f aed8 	beq.w	8008cda <cblas_ssymv+0xc6>
 8008f2a:	9b01      	ldr	r3, [sp, #4]
 8008f2c:	4440      	add	r0, r8
 8008f2e:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 8008f32:	4653      	mov	r3, sl
        Y[jy] += temp1 * A[lda * i + j];
 8008f34:	edd3 6a00 	vldr	s13, [r3]
 8008f38:	edd1 7a00 	vldr	s15, [r1]
 8008f3c:	eee6 7a86 	vfma.f32	s15, s13, s12
 8008f40:	edc1 7a00 	vstr	s15, [r1]
        temp2 += X[jx] * A[lda * i + j];
 8008f44:	ecf3 7a01 	vldmia	r3!, {s15}
 8008f48:	edd0 6a00 	vldr	s13, [r0]
      for (j = j_min; j < j_max; j++) {
 8008f4c:	429c      	cmp	r4, r3
        temp2 += X[jx] * A[lda * i + j];
 8008f4e:	eea6 7aa7 	vfma.f32	s14, s13, s15
      for (j = j_min; j < j_max; j++) {
 8008f52:	4411      	add	r1, r2
 8008f54:	4460      	add	r0, ip
 8008f56:	d1ed      	bne.n	8008f34 <cblas_ssymv+0x320>
      Y[iy] += alpha * temp2;
 8008f58:	edde 7a00 	vldr	s15, [lr]
 8008f5c:	9b05      	ldr	r3, [sp, #20]
 8008f5e:	eee8 7a07 	vfma.f32	s15, s16, s14
 8008f62:	4499      	add	r9, r3
 8008f64:	9b04      	ldr	r3, [sp, #16]
 8008f66:	449a      	add	sl, r3
 8008f68:	9b03      	ldr	r3, [sp, #12]
 8008f6a:	edce 7a00 	vstr	s15, [lr]
    for (i = 0; i < N; i++) {
 8008f6e:	441c      	add	r4, r3
 8008f70:	44bb      	add	fp, r7
      Y[iy] += alpha * temp2;
 8008f72:	4633      	mov	r3, r6
 8008f74:	4496      	add	lr, r2
 8008f76:	e7c0      	b.n	8008efa <cblas_ssymv+0x2e6>
      Y[iy] += alpha * temp2;
 8008f78:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 8008fac <cblas_ssymv+0x398>
 8008f7c:	9a04      	ldr	r2, [sp, #16]
 8008f7e:	9f05      	ldr	r7, [sp, #20]
 8008f80:	9b06      	ldr	r3, [sp, #24]
 8008f82:	eee8 7a07 	vfma.f32	s15, s16, s14
 8008f86:	fb07 2313 	mls	r3, r7, r3, r2
 8008f8a:	9a01      	ldr	r2, [sp, #4]
 8008f8c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008f90:	edc3 7a00 	vstr	s15, [r3]
 8008f94:	b009      	add	sp, #36	; 0x24
 8008f96:	ecbd 8b02 	vpop	{d8}
 8008f9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008f9e:	bf00      	nop
 8008fa0:	08030378 	.word	0x08030378
 8008fa4:	0803061c 	.word	0x0803061c
 8008fa8:	080305a8 	.word	0x080305a8
 8008fac:	00000000 	.word	0x00000000
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8008fb0:	200b      	movs	r0, #11
 8008fb2:	e656      	b.n	8008c62 <cblas_ssymv+0x4e>

08008fb4 <cblas_ssyr>:

void
cblas_ssyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const float alpha, const float *X, const int incX,
            float *A, const int lda)
{
 8008fb4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008fb8:	ed2d 8b02 	vpush	{d8}
 8008fbc:	4689      	mov	r9, r1
 */

{
  INDEX i, j;

  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8008fbe:	3979      	subs	r1, #121	; 0x79
 8008fc0:	2901      	cmp	r1, #1
 8008fc2:	e9dd 740c 	ldrd	r7, r4, [sp, #48]	; 0x30
 8008fc6:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 8008fca:	4682      	mov	sl, r0
 8008fcc:	4615      	mov	r5, r2
 8008fce:	461e      	mov	r6, r3
 8008fd0:	eeb0 8a40 	vmov.f32	s16, s0
 8008fd4:	d935      	bls.n	8009042 <cblas_ssyr+0x8e>
 8008fd6:	2a00      	cmp	r2, #0
 8008fd8:	db22      	blt.n	8009020 <cblas_ssyr+0x6c>
 8008fda:	2f00      	cmp	r7, #0
 8008fdc:	d142      	bne.n	8009064 <cblas_ssyr+0xb0>
 8008fde:	2d01      	cmp	r5, #1
 8008fe0:	4628      	mov	r0, r5
 8008fe2:	bfb8      	it	lt
 8008fe4:	2001      	movlt	r0, #1
 8008fe6:	4a5e      	ldr	r2, [pc, #376]	; (8009160 <cblas_ssyr+0x1ac>)
 8008fe8:	495e      	ldr	r1, [pc, #376]	; (8009164 <cblas_ssyr+0x1b0>)
 8008fea:	4580      	cmp	r8, r0
 8008fec:	bfb4      	ite	lt
 8008fee:	2008      	movlt	r0, #8
 8008ff0:	2006      	movge	r0, #6
 8008ff2:	f01e fd29 	bl	8027a48 <cblas_xerbla>

  if (N == 0)
 8008ff6:	b305      	cbz	r5, 800903a <cblas_ssyr+0x86>
    return;

  if (alpha == 0.0)
 8008ff8:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8008ffc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009000:	d01b      	beq.n	800903a <cblas_ssyr+0x86>
    return;

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8009002:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8009006:	d070      	beq.n	80090ea <cblas_ssyr+0x136>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009008:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 800900c:	d033      	beq.n	8009076 <cblas_ssyr+0xc2>
#define BASE float
#include "source_syr.h"
#undef BASE
}
 800900e:	ecbd 8b02 	vpop	{d8}
        jx += incX;
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8009012:	4a55      	ldr	r2, [pc, #340]	; (8009168 <cblas_ssyr+0x1b4>)
 8009014:	4953      	ldr	r1, [pc, #332]	; (8009164 <cblas_ssyr+0x1b0>)
 8009016:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800901a:	2000      	movs	r0, #0
 800901c:	f01e bd14 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009020:	2f00      	cmp	r7, #0
 8009022:	d0dc      	beq.n	8008fde <cblas_ssyr+0x2a>
 8009024:	f1b8 0f00 	cmp.w	r8, #0
 8009028:	bfd4      	ite	le
 800902a:	2008      	movle	r0, #8
 800902c:	2003      	movgt	r0, #3
 800902e:	4a4c      	ldr	r2, [pc, #304]	; (8009160 <cblas_ssyr+0x1ac>)
 8009030:	494c      	ldr	r1, [pc, #304]	; (8009164 <cblas_ssyr+0x1b0>)
 8009032:	f01e fd09 	bl	8027a48 <cblas_xerbla>
  if (N == 0)
 8009036:	2d00      	cmp	r5, #0
 8009038:	d1de      	bne.n	8008ff8 <cblas_ssyr+0x44>
 800903a:	ecbd 8b02 	vpop	{d8}
 800903e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009042:	2a00      	cmp	r2, #0
 8009044:	dbec      	blt.n	8009020 <cblas_ssyr+0x6c>
 8009046:	2f00      	cmp	r7, #0
 8009048:	d0c9      	beq.n	8008fde <cblas_ssyr+0x2a>
 800904a:	2a01      	cmp	r2, #1
 800904c:	4613      	mov	r3, r2
 800904e:	bfb8      	it	lt
 8009050:	2301      	movlt	r3, #1
 8009052:	4543      	cmp	r3, r8
 8009054:	dc7d      	bgt.n	8009152 <cblas_ssyr+0x19e>
 8009056:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800905a:	2b01      	cmp	r3, #1
 800905c:	bf88      	it	hi
 800905e:	2001      	movhi	r0, #1
 8009060:	d9c9      	bls.n	8008ff6 <cblas_ssyr+0x42>
 8009062:	e7e4      	b.n	800902e <cblas_ssyr+0x7a>
 8009064:	2a01      	cmp	r2, #1
 8009066:	4610      	mov	r0, r2
 8009068:	bfb8      	it	lt
 800906a:	2001      	movlt	r0, #1
 800906c:	4580      	cmp	r8, r0
 800906e:	bfb4      	ite	lt
 8009070:	2008      	movlt	r0, #8
 8009072:	2002      	movge	r0, #2
 8009074:	e7db      	b.n	800902e <cblas_ssyr+0x7a>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8009076:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 800907a:	d03d      	beq.n	80090f8 <cblas_ssyr+0x144>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800907c:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8009080:	d1c5      	bne.n	800900e <cblas_ssyr+0x5a>
    INDEX ix = OFFSET(N, incX);
 8009082:	2f00      	cmp	r7, #0
 8009084:	bfda      	itte	le
 8009086:	f1c5 0c01 	rsble	ip, r5, #1
 800908a:	fb0c fc07 	mulle.w	ip, ip, r7
 800908e:	f04f 0c00 	movgt.w	ip, #0
    for (i = 0; i < N; i++) {
 8009092:	2d00      	cmp	r5, #0
 8009094:	ddd1      	ble.n	800903a <cblas_ssyr+0x86>
 8009096:	f108 0a01 	add.w	sl, r8, #1
 800909a:	f04f 0e00 	mov.w	lr, #0
 800909e:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 80090a2:	46f1      	mov	r9, lr
 80090a4:	1d22      	adds	r2, r4, #4
 80090a6:	00bb      	lsls	r3, r7, #2
 80090a8:	ea4f 018c 	mov.w	r1, ip, lsl #2
 80090ac:	eb06 0b8c 	add.w	fp, r6, ip, lsl #2
      const BASE tmp = alpha * X[ix];
 80090b0:	4431      	add	r1, r6
 80090b2:	edd1 6a00 	vldr	s13, [r1]
 80090b6:	ee68 6a26 	vmul.f32	s13, s16, s13
      for (j = 0; j <= i; j++) {
 80090ba:	eb04 018e 	add.w	r1, r4, lr, lsl #2
      const BASE tmp = alpha * X[ix];
 80090be:	4658      	mov	r0, fp
        A[lda * i + j] += X[jx] * tmp;
 80090c0:	ed90 7a00 	vldr	s14, [r0]
 80090c4:	edd1 7a00 	vldr	s15, [r1]
 80090c8:	eee7 7a26 	vfma.f32	s15, s14, s13
 80090cc:	4418      	add	r0, r3
 80090ce:	ece1 7a01 	vstmia	r1!, {s15}
      for (j = 0; j <= i; j++) {
 80090d2:	428a      	cmp	r2, r1
 80090d4:	d1f4      	bne.n	80090c0 <cblas_ssyr+0x10c>
    for (i = 0; i < N; i++) {
 80090d6:	f109 0901 	add.w	r9, r9, #1
 80090da:	454d      	cmp	r5, r9
      ix += incX;
 80090dc:	44bc      	add	ip, r7
    for (i = 0; i < N; i++) {
 80090de:	44c6      	add	lr, r8
 80090e0:	4452      	add	r2, sl
 80090e2:	d0aa      	beq.n	800903a <cblas_ssyr+0x86>
 80090e4:	ea4f 018c 	mov.w	r1, ip, lsl #2
 80090e8:	e7e2      	b.n	80090b0 <cblas_ssyr+0xfc>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 80090ea:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 80090ee:	d003      	beq.n	80090f8 <cblas_ssyr+0x144>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 80090f0:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 80090f4:	d18b      	bne.n	800900e <cblas_ssyr+0x5a>
 80090f6:	e7c4      	b.n	8009082 <cblas_ssyr+0xce>
    INDEX ix = OFFSET(N, incX);
 80090f8:	2f00      	cmp	r7, #0
 80090fa:	dd2c      	ble.n	8009156 <cblas_ssyr+0x1a2>
 80090fc:	2200      	movs	r2, #0
    for (i = 0; i < N; i++) {
 80090fe:	2d00      	cmp	r5, #0
 8009100:	dd9b      	ble.n	800903a <cblas_ssyr+0x86>
 8009102:	f108 0801 	add.w	r8, r8, #1
 8009106:	ea4f 0888 	mov.w	r8, r8, lsl #2
 800910a:	46a6      	mov	lr, r4
 800910c:	00bb      	lsls	r3, r7, #2
 800910e:	eb06 0987 	add.w	r9, r6, r7, lsl #2
 8009112:	f04f 0c00 	mov.w	ip, #0
      const BASE tmp = alpha * X[ix];
 8009116:	eb06 0182 	add.w	r1, r6, r2, lsl #2
 800911a:	ed91 7a00 	vldr	s14, [r1]
 800911e:	eb09 0482 	add.w	r4, r9, r2, lsl #2
 8009122:	ee67 6a08 	vmul.f32	s13, s14, s16
 8009126:	4670      	mov	r0, lr
 8009128:	4661      	mov	r1, ip
 800912a:	e002      	b.n	8009132 <cblas_ssyr+0x17e>
 800912c:	ed94 7a00 	vldr	s14, [r4]
 8009130:	441c      	add	r4, r3
        A[lda * i + j] += X[jx] * tmp;
 8009132:	edd0 7a00 	vldr	s15, [r0]
 8009136:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = i; j < N; j++) {
 800913a:	3101      	adds	r1, #1
 800913c:	428d      	cmp	r5, r1
        A[lda * i + j] += X[jx] * tmp;
 800913e:	ece0 7a01 	vstmia	r0!, {s15}
      for (j = i; j < N; j++) {
 8009142:	dcf3      	bgt.n	800912c <cblas_ssyr+0x178>
    for (i = 0; i < N; i++) {
 8009144:	f10c 0c01 	add.w	ip, ip, #1
 8009148:	4565      	cmp	r5, ip
      ix += incX;
 800914a:	443a      	add	r2, r7
    for (i = 0; i < N; i++) {
 800914c:	44c6      	add	lr, r8
 800914e:	d1e2      	bne.n	8009116 <cblas_ssyr+0x162>
 8009150:	e773      	b.n	800903a <cblas_ssyr+0x86>
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 8009152:	2008      	movs	r0, #8
 8009154:	e76b      	b.n	800902e <cblas_ssyr+0x7a>
    INDEX ix = OFFSET(N, incX);
 8009156:	f1c5 0201 	rsb	r2, r5, #1
 800915a:	fb02 f207 	mul.w	r2, r2, r7
 800915e:	e7ce      	b.n	80090fe <cblas_ssyr+0x14a>
 8009160:	08030378 	.word	0x08030378
 8009164:	0803062c 	.word	0x0803062c
 8009168:	080305a8 	.word	0x080305a8

0800916c <cblas_ssyr2>:

void
cblas_ssyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const float alpha, const float *X, const int incX,
             const float *Y, const int incY, float *A, const int lda)
{
 800916c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009170:	ed2d 8b02 	vpush	{d8}
 8009174:	b087      	sub	sp, #28
 8009176:	460d      	mov	r5, r1
 8009178:	9300      	str	r3, [sp, #0]
 800917a:	e9dd 6312 	ldrd	r6, r3, [sp, #72]	; 0x48
 800917e:	9301      	str	r3, [sp, #4]
 8009180:	e9dd 7314 	ldrd	r7, r3, [sp, #80]	; 0x50
 */

{
  INDEX i, j;

  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 8009184:	3979      	subs	r1, #121	; 0x79
 8009186:	2901      	cmp	r1, #1
 8009188:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 800918c:	9302      	str	r3, [sp, #8]
 800918e:	4681      	mov	r9, r0
 8009190:	4614      	mov	r4, r2
 8009192:	eeb0 8a40 	vmov.f32	s16, s0
 8009196:	f240 80a7 	bls.w	80092e8 <cblas_ssyr2+0x17c>
 800919a:	2002      	movs	r0, #2
 800919c:	2c00      	cmp	r4, #0
 800919e:	f2c0 8097 	blt.w	80092d0 <cblas_ssyr2+0x164>
 80091a2:	2e00      	cmp	r6, #0
 80091a4:	d17f      	bne.n	80092a6 <cblas_ssyr2+0x13a>
 80091a6:	2f00      	cmp	r7, #0
 80091a8:	f040 8089 	bne.w	80092be <cblas_ssyr2+0x152>
 80091ac:	2c01      	cmp	r4, #1
 80091ae:	4620      	mov	r0, r4
 80091b0:	bfb8      	it	lt
 80091b2:	2001      	movlt	r0, #1
 80091b4:	4580      	cmp	r8, r0
 80091b6:	bfb4      	ite	lt
 80091b8:	200a      	movlt	r0, #10
 80091ba:	2008      	movge	r0, #8
 80091bc:	4a85      	ldr	r2, [pc, #532]	; (80093d4 <cblas_ssyr2+0x268>)
 80091be:	4986      	ldr	r1, [pc, #536]	; (80093d8 <cblas_ssyr2+0x26c>)
 80091c0:	f01e fc42 	bl	8027a48 <cblas_xerbla>

  if (N == 0)
 80091c4:	2c00      	cmp	r4, #0
 80091c6:	d069      	beq.n	800929c <cblas_ssyr2+0x130>
    return;

  if (alpha == 0.0)
 80091c8:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80091cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80091d0:	d064      	beq.n	800929c <cblas_ssyr2+0x130>
    return;

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 80091d2:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 80091d6:	f000 80ef 	beq.w	80093b8 <cblas_ssyr2+0x24c>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 80091da:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 80091de:	f000 8089 	beq.w	80092f4 <cblas_ssyr2+0x188>
      }
      ix += incX;
      iy += incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 80091e2:	4a7e      	ldr	r2, [pc, #504]	; (80093dc <cblas_ssyr2+0x270>)
 80091e4:	497c      	ldr	r1, [pc, #496]	; (80093d8 <cblas_ssyr2+0x26c>)
 80091e6:	2000      	movs	r0, #0
#define BASE float
#include "source_syr2.h"
#undef BASE
}
 80091e8:	b007      	add	sp, #28
 80091ea:	ecbd 8b02 	vpop	{d8}
 80091ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80091f2:	f01e bc29 	b.w	8027a48 <cblas_xerbla>
    INDEX ix = OFFSET(N, incX);
 80091f6:	2e00      	cmp	r6, #0
 80091f8:	bfda      	itte	le
 80091fa:	f1c4 0e01 	rsble	lr, r4, #1
 80091fe:	fb0e fe06 	mulle.w	lr, lr, r6
 8009202:	f04f 0e00 	movgt.w	lr, #0
    INDEX iy = OFFSET(N, incY);
 8009206:	2f00      	cmp	r7, #0
 8009208:	f340 80df 	ble.w	80093ca <cblas_ssyr2+0x25e>
 800920c:	f04f 0900 	mov.w	r9, #0
    for (i = 0; i < N; i++) {
 8009210:	2c00      	cmp	r4, #0
 8009212:	dd43      	ble.n	800929c <cblas_ssyr2+0x130>
 8009214:	9b01      	ldr	r3, [sp, #4]
 8009216:	f8dd a008 	ldr.w	sl, [sp, #8]
 800921a:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 800921e:	9303      	str	r3, [sp, #12]
 8009220:	9b00      	ldr	r3, [sp, #0]
 8009222:	f108 0801 	add.w	r8, r8, #1
 8009226:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 800922a:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 800922e:	ea4f 0c87 	mov.w	ip, r7, lsl #2
 8009232:	00b5      	lsls	r5, r6, #2
 8009234:	9302      	str	r3, [sp, #8]
 8009236:	f04f 0800 	mov.w	r8, #0
      const BASE tmp1 = alpha * X[ix];
 800923a:	9b00      	ldr	r3, [sp, #0]
 800923c:	eb03 028e 	add.w	r2, r3, lr, lsl #2
      const BASE tmp2 = alpha * Y[iy];
 8009240:	9b01      	ldr	r3, [sp, #4]
      const BASE tmp1 = alpha * X[ix];
 8009242:	edd2 7a00 	vldr	s15, [r2]
      const BASE tmp2 = alpha * Y[iy];
 8009246:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 800924a:	edd3 6a00 	vldr	s13, [r3]
 800924e:	9b03      	ldr	r3, [sp, #12]
 8009250:	eb03 0089 	add.w	r0, r3, r9, lsl #2
 8009254:	9b02      	ldr	r3, [sp, #8]
      const BASE tmp1 = alpha * X[ix];
 8009256:	ee67 5a88 	vmul.f32	s11, s15, s16
      const BASE tmp2 = alpha * Y[iy];
 800925a:	eb03 018e 	add.w	r1, r3, lr, lsl #2
 800925e:	ee26 6a88 	vmul.f32	s12, s13, s16
 8009262:	4652      	mov	r2, sl
 8009264:	4643      	mov	r3, r8
 8009266:	e005      	b.n	8009274 <cblas_ssyr2+0x108>
 8009268:	edd0 6a00 	vldr	s13, [r0]
 800926c:	edd1 7a00 	vldr	s15, [r1]
 8009270:	4460      	add	r0, ip
 8009272:	4429      	add	r1, r5
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 8009274:	ee66 7a27 	vmul.f32	s15, s12, s15
 8009278:	ed92 7a00 	vldr	s14, [r2]
 800927c:	eee5 7aa6 	vfma.f32	s15, s11, s13
      for (j = i; j < N; j++) {
 8009280:	3301      	adds	r3, #1
 8009282:	429c      	cmp	r4, r3
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 8009284:	ee77 7a27 	vadd.f32	s15, s14, s15
 8009288:	ece2 7a01 	vstmia	r2!, {s15}
      for (j = i; j < N; j++) {
 800928c:	dcec      	bgt.n	8009268 <cblas_ssyr2+0xfc>
    for (i = 0; i < N; i++) {
 800928e:	f108 0801 	add.w	r8, r8, #1
 8009292:	4544      	cmp	r4, r8
      ix += incX;
 8009294:	44b6      	add	lr, r6
      iy += incY;
 8009296:	44b9      	add	r9, r7
    for (i = 0; i < N; i++) {
 8009298:	44da      	add	sl, fp
 800929a:	d1ce      	bne.n	800923a <cblas_ssyr2+0xce>
 800929c:	b007      	add	sp, #28
 800929e:	ecbd 8b02 	vpop	{d8}
 80092a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 80092a6:	2f00      	cmp	r7, #0
 80092a8:	d080      	beq.n	80091ac <cblas_ssyr2+0x40>
 80092aa:	2c01      	cmp	r4, #1
 80092ac:	4623      	mov	r3, r4
 80092ae:	bfb8      	it	lt
 80092b0:	2301      	movlt	r3, #1
 80092b2:	4543      	cmp	r3, r8
 80092b4:	f300 8087 	bgt.w	80093c6 <cblas_ssyr2+0x25a>
 80092b8:	2800      	cmp	r0, #0
 80092ba:	d083      	beq.n	80091c4 <cblas_ssyr2+0x58>
 80092bc:	e77e      	b.n	80091bc <cblas_ssyr2+0x50>
 80092be:	2c01      	cmp	r4, #1
 80092c0:	4620      	mov	r0, r4
 80092c2:	bfb8      	it	lt
 80092c4:	2001      	movlt	r0, #1
 80092c6:	4580      	cmp	r8, r0
 80092c8:	bfb4      	ite	lt
 80092ca:	200a      	movlt	r0, #10
 80092cc:	2006      	movge	r0, #6
 80092ce:	e775      	b.n	80091bc <cblas_ssyr2+0x50>
 80092d0:	2e00      	cmp	r6, #0
 80092d2:	f43f af68 	beq.w	80091a6 <cblas_ssyr2+0x3a>
 80092d6:	2f00      	cmp	r7, #0
 80092d8:	f43f af68 	beq.w	80091ac <cblas_ssyr2+0x40>
 80092dc:	f1b8 0f00 	cmp.w	r8, #0
 80092e0:	bfd4      	ite	le
 80092e2:	200a      	movle	r0, #10
 80092e4:	2003      	movgt	r0, #3
 80092e6:	e769      	b.n	80091bc <cblas_ssyr2+0x50>
 80092e8:	3865      	subs	r0, #101	; 0x65
 80092ea:	2801      	cmp	r0, #1
 80092ec:	bf94      	ite	ls
 80092ee:	2000      	movls	r0, #0
 80092f0:	2001      	movhi	r0, #1
 80092f2:	e753      	b.n	800919c <cblas_ssyr2+0x30>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 80092f4:	2d7a      	cmp	r5, #122	; 0x7a
 80092f6:	f43f af7e 	beq.w	80091f6 <cblas_ssyr2+0x8a>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 80092fa:	2d79      	cmp	r5, #121	; 0x79
 80092fc:	f47f af71 	bne.w	80091e2 <cblas_ssyr2+0x76>
    INDEX ix = OFFSET(N, incX);
 8009300:	2e00      	cmp	r6, #0
 8009302:	bfda      	itte	le
 8009304:	f1c4 0e01 	rsble	lr, r4, #1
 8009308:	fb0e fe06 	mulle.w	lr, lr, r6
 800930c:	f04f 0e00 	movgt.w	lr, #0
    INDEX iy = OFFSET(N, incY);
 8009310:	2f00      	cmp	r7, #0
 8009312:	bfda      	itte	le
 8009314:	f1c4 0901 	rsble	r9, r4, #1
 8009318:	fb09 f907 	mulle.w	r9, r9, r7
 800931c:	f04f 0900 	movgt.w	r9, #0
    for (i = 0; i < N; i++) {
 8009320:	2c00      	cmp	r4, #0
 8009322:	ddbb      	ble.n	800929c <cblas_ssyr2+0x130>
 8009324:	f108 0301 	add.w	r3, r8, #1
 8009328:	009b      	lsls	r3, r3, #2
 800932a:	9303      	str	r3, [sp, #12]
 800932c:	9b02      	ldr	r3, [sp, #8]
 800932e:	9800      	ldr	r0, [sp, #0]
 8009330:	1d1a      	adds	r2, r3, #4
 8009332:	9b01      	ldr	r3, [sp, #4]
 8009334:	f04f 0a00 	mov.w	sl, #0
 8009338:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 800933c:	eb00 008e 	add.w	r0, r0, lr, lsl #2
 8009340:	9305      	str	r3, [sp, #20]
 8009342:	46d3      	mov	fp, sl
 8009344:	ea4f 0c87 	mov.w	ip, r7, lsl #2
 8009348:	ea4f 0189 	mov.w	r1, r9, lsl #2
 800934c:	00b5      	lsls	r5, r6, #2
 800934e:	ea4f 038e 	mov.w	r3, lr, lsl #2
 8009352:	9004      	str	r0, [sp, #16]
      const BASE tmp1 = alpha * X[ix];
 8009354:	9800      	ldr	r0, [sp, #0]
 8009356:	4403      	add	r3, r0
      const BASE tmp2 = alpha * Y[iy];
 8009358:	9801      	ldr	r0, [sp, #4]
      const BASE tmp1 = alpha * X[ix];
 800935a:	edd3 5a00 	vldr	s11, [r3]
 800935e:	9b02      	ldr	r3, [sp, #8]
      const BASE tmp2 = alpha * Y[iy];
 8009360:	4401      	add	r1, r0
 8009362:	ed91 6a00 	vldr	s12, [r1]
 8009366:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
      const BASE tmp1 = alpha * X[ix];
 800936a:	ee68 5a25 	vmul.f32	s11, s16, s11
      const BASE tmp2 = alpha * Y[iy];
 800936e:	ee28 6a06 	vmul.f32	s12, s16, s12
      for (j = 0; j <= i; j++) {
 8009372:	eb03 038a 	add.w	r3, r3, sl, lsl #2
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 8009376:	edd0 7a00 	vldr	s15, [r0]
 800937a:	edd1 6a00 	vldr	s13, [r1]
 800937e:	ed93 7a00 	vldr	s14, [r3]
 8009382:	ee66 7a27 	vmul.f32	s15, s12, s15
 8009386:	4428      	add	r0, r5
 8009388:	eee6 7aa5 	vfma.f32	s15, s13, s11
 800938c:	4461      	add	r1, ip
 800938e:	ee77 7a27 	vadd.f32	s15, s14, s15
 8009392:	ece3 7a01 	vstmia	r3!, {s15}
      for (j = 0; j <= i; j++) {
 8009396:	429a      	cmp	r2, r3
 8009398:	d1ed      	bne.n	8009376 <cblas_ssyr2+0x20a>
      ix += incX;
 800939a:	9b03      	ldr	r3, [sp, #12]
    for (i = 0; i < N; i++) {
 800939c:	f10b 0b01 	add.w	fp, fp, #1
 80093a0:	455c      	cmp	r4, fp
      ix += incX;
 80093a2:	44b6      	add	lr, r6
      iy += incY;
 80093a4:	44b9      	add	r9, r7
    for (i = 0; i < N; i++) {
 80093a6:	44c2      	add	sl, r8
 80093a8:	441a      	add	r2, r3
 80093aa:	f43f af77 	beq.w	800929c <cblas_ssyr2+0x130>
 80093ae:	ea4f 0189 	mov.w	r1, r9, lsl #2
 80093b2:	ea4f 038e 	mov.w	r3, lr, lsl #2
 80093b6:	e7cd      	b.n	8009354 <cblas_ssyr2+0x1e8>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 80093b8:	2d79      	cmp	r5, #121	; 0x79
 80093ba:	f43f af1c 	beq.w	80091f6 <cblas_ssyr2+0x8a>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 80093be:	2d7a      	cmp	r5, #122	; 0x7a
 80093c0:	f47f af0f 	bne.w	80091e2 <cblas_ssyr2+0x76>
 80093c4:	e79c      	b.n	8009300 <cblas_ssyr2+0x194>
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 80093c6:	200a      	movs	r0, #10
 80093c8:	e6f8      	b.n	80091bc <cblas_ssyr2+0x50>
    INDEX iy = OFFSET(N, incY);
 80093ca:	f1c4 0901 	rsb	r9, r4, #1
 80093ce:	fb09 f907 	mul.w	r9, r9, r7
 80093d2:	e71d      	b.n	8009210 <cblas_ssyr2+0xa4>
 80093d4:	08030378 	.word	0x08030378
 80093d8:	0803063c 	.word	0x0803063c
 80093dc:	080305a8 	.word	0x080305a8

080093e0 <cblas_ssyr2k>:
cblas_ssyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const float alpha, const float *A, const int lda,
              const float *B, const int ldb, const float beta, float *C,
              const int ldc)
{
 80093e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80093e4:	ed2d 8b02 	vpush	{d8}
 80093e8:	b08b      	sub	sp, #44	; 0x2c
 80093ea:	461c      	mov	r4, r3
 80093ec:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80093ee:	9302      	str	r3, [sp, #8]
 80093f0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80093f2:	9300      	str	r3, [sp, #0]
 80093f4:	e9dd 6318 	ldrd	r6, r3, [sp, #96]	; 0x60

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80093f8:	2865      	cmp	r0, #101	; 0x65
 80093fa:	e9dd b71a 	ldrd	fp, r7, [sp, #104]	; 0x68
 80093fe:	f8dd 8070 	ldr.w	r8, [sp, #112]	; 0x70
 8009402:	9301      	str	r3, [sp, #4]
 8009404:	4681      	mov	r9, r0
 8009406:	468a      	mov	sl, r1
 8009408:	4615      	mov	r5, r2
 800940a:	eeb0 8a40 	vmov.f32	s16, s0
 800940e:	eef0 8a60 	vmov.f32	s17, s1
 8009412:	f000 80e7 	beq.w	80095e4 <cblas_ssyr2k+0x204>
 8009416:	2a6f      	cmp	r2, #111	; 0x6f
 8009418:	f000 80c0 	beq.w	800959c <cblas_ssyr2k+0x1bc>
 800941c:	9902      	ldr	r1, [sp, #8]
 800941e:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 8009422:	2a01      	cmp	r2, #1
 8009424:	f240 80d7 	bls.w	80095d6 <cblas_ssyr2k+0x1f6>
 8009428:	2002      	movs	r0, #2
 800942a:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800942e:	b2db      	uxtb	r3, r3
 8009430:	2b03      	cmp	r3, #3
 8009432:	bf28      	it	cs
 8009434:	2003      	movcs	r0, #3
 8009436:	9b02      	ldr	r3, [sp, #8]
 8009438:	2c00      	cmp	r4, #0
 800943a:	bfb8      	it	lt
 800943c:	2004      	movlt	r0, #4
 800943e:	2b00      	cmp	r3, #0
 8009440:	bfb8      	it	lt
 8009442:	2005      	movlt	r0, #5
 8009444:	2901      	cmp	r1, #1
 8009446:	460b      	mov	r3, r1
 8009448:	bfb8      	it	lt
 800944a:	2301      	movlt	r3, #1
 800944c:	42b3      	cmp	r3, r6
 800944e:	f340 80b5 	ble.w	80095bc <cblas_ssyr2k+0x1dc>
 8009452:	455b      	cmp	r3, fp
 8009454:	f300 80a9 	bgt.w	80095aa <cblas_ssyr2k+0x1ca>
 8009458:	2c01      	cmp	r4, #1
 800945a:	4620      	mov	r0, r4
 800945c:	bfb8      	it	lt
 800945e:	2001      	movlt	r0, #1
 8009460:	4580      	cmp	r8, r0
 8009462:	bfb4      	ite	lt
 8009464:	200e      	movlt	r0, #14
 8009466:	2008      	movge	r0, #8
 8009468:	4ad6      	ldr	r2, [pc, #856]	; (80097c4 <cblas_ssyr2k+0x3e4>)
 800946a:	49d7      	ldr	r1, [pc, #860]	; (80097c8 <cblas_ssyr2k+0x3e8>)
 800946c:	f01e faec 	bl	8027a48 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 8009470:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009478:	d107      	bne.n	800948a <cblas_ssyr2k+0xaa>
 800947a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800947e:	eef4 8a67 	vcmp.f32	s17, s15
 8009482:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009486:	f000 8084 	beq.w	8009592 <cblas_ssyr2k+0x1b2>
    return;

  if (Order == CblasRowMajor) {
 800948a:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 800948e:	f000 80ae 	beq.w	80095ee <cblas_ssyr2k+0x20e>
    uplo = Uplo;
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
  } else {
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;

    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 8009492:	f1a5 0370 	sub.w	r3, r5, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009496:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800949a:	b2db      	uxtb	r3, r3
      trans = CblasTrans;
    }
  }

  /* form  C := beta*C */
  if (beta == 0.0) {
 800949c:	eef5 8a40 	vcmp.f32	s17, #0.0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80094a0:	f000 8180 	beq.w	80097a4 <cblas_ssyr2k+0x3c4>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 80094a4:	2b01      	cmp	r3, #1
 80094a6:	f240 8195 	bls.w	80097d4 <cblas_ssyr2k+0x3f4>
  if (beta == 0.0) {
 80094aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80094ae:	f040 814f 	bne.w	8009750 <cblas_ssyr2k+0x370>
    if (uplo == CblasUpper) {
      for (i = 0; i < N; i++) {
 80094b2:	2c00      	cmp	r4, #0
      trans = CblasTrans;
 80094b4:	bfc8      	it	gt
 80094b6:	f04f 0c70 	movgt.w	ip, #112	; 0x70
      for (i = 0; i < N; i++) {
 80094ba:	f340 816c 	ble.w	8009796 <cblas_ssyr2k+0x3b6>
 80094be:	f108 0501 	add.w	r5, r8, #1
        for (j = i; j < N; j++) {
          C[ldc * i + j] = 0.0;
 80094c2:	f04f 0e00 	mov.w	lr, #0
 80094c6:	00ad      	lsls	r5, r5, #2
 80094c8:	4638      	mov	r0, r7
      for (i = 0; i < N; i++) {
 80094ca:	2100      	movs	r1, #0
 80094cc:	4602      	mov	r2, r0
 80094ce:	460b      	mov	r3, r1
        for (j = i; j < N; j++) {
 80094d0:	3301      	adds	r3, #1
 80094d2:	429c      	cmp	r4, r3
          C[ldc * i + j] = 0.0;
 80094d4:	f842 eb04 	str.w	lr, [r2], #4
        for (j = i; j < N; j++) {
 80094d8:	dcfa      	bgt.n	80094d0 <cblas_ssyr2k+0xf0>
      for (i = 0; i < N; i++) {
 80094da:	3101      	adds	r1, #1
 80094dc:	428c      	cmp	r4, r1
 80094de:	4428      	add	r0, r5
 80094e0:	dcf4      	bgt.n	80094cc <cblas_ssyr2k+0xec>
        }
      }
    }
  }

  if (alpha == 0.0)
 80094e2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80094e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80094ea:	d052      	beq.n	8009592 <cblas_ssyr2k+0x1b2>
    return;

  if (uplo == CblasUpper && trans == CblasNoTrans) {
 80094ec:	f1bc 0f6f 	cmp.w	ip, #111	; 0x6f
 80094f0:	f000 817f 	beq.w	80097f2 <cblas_ssyr2k+0x412>
        }
        C[i * ldc + j] += alpha * temp;
      }
    }

  } else if (uplo == CblasUpper && trans == CblasTrans) {
 80094f4:	f1bc 0f70 	cmp.w	ip, #112	; 0x70
 80094f8:	f040 80ad 	bne.w	8009656 <cblas_ssyr2k+0x276>

    for (k = 0; k < K; k++) {
 80094fc:	9b02      	ldr	r3, [sp, #8]
 80094fe:	2b00      	cmp	r3, #0
 8009500:	dd47      	ble.n	8009592 <cblas_ssyr2k+0x1b2>
 8009502:	00b0      	lsls	r0, r6, #2
 8009504:	9003      	str	r0, [sp, #12]
 8009506:	9800      	ldr	r0, [sp, #0]
 8009508:	9706      	str	r7, [sp, #24]
 800950a:	2300      	movs	r3, #0
 800950c:	f106 0a01 	add.w	sl, r6, #1
 8009510:	e9cd 6b04 	strd	r6, fp, [sp, #16]
 8009514:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8009518:	eb00 0984 	add.w	r9, r0, r4, lsl #2
 800951c:	469e      	mov	lr, r3
 800951e:	4698      	mov	r8, r3
 8009520:	469b      	mov	fp, r3
      for (i = 0; i < N; i++) {
 8009522:	2c00      	cmp	r4, #0
 8009524:	dd2a      	ble.n	800957c <cblas_ssyr2k+0x19c>
 8009526:	9b00      	ldr	r3, [sp, #0]
 8009528:	9f06      	ldr	r7, [sp, #24]
 800952a:	eb03 058b 	add.w	r5, r3, fp, lsl #2
 800952e:	9b01      	ldr	r3, [sp, #4]
 8009530:	2600      	movs	r6, #0
 8009532:	eb03 0c88 	add.w	ip, r3, r8, lsl #2
        BASE temp1 = alpha * A[k * lda + i];
 8009536:	ecf5 7a01 	vldmia	r5!, {s15}
        BASE temp2 = alpha * B[k * ldb + i];
 800953a:	ecfc 6a01 	vldmia	ip!, {s13}
        BASE temp1 = alpha * A[k * lda + i];
 800953e:	ee67 5a88 	vmul.f32	s11, s15, s16
        BASE temp2 = alpha * B[k * ldb + i];
 8009542:	ee26 6a88 	vmul.f32	s12, s13, s16
 8009546:	4628      	mov	r0, r5
 8009548:	4661      	mov	r1, ip
 800954a:	463a      	mov	r2, r7
 800954c:	4633      	mov	r3, r6
 800954e:	e003      	b.n	8009558 <cblas_ssyr2k+0x178>
 8009550:	ecf1 6a01 	vldmia	r1!, {s13}
 8009554:	ecf0 7a01 	vldmia	r0!, {s15}
        for (j = i; j < N; j++) {
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 8009558:	ed92 7a00 	vldr	s14, [r2]
 800955c:	ee66 7a27 	vmul.f32	s15, s12, s15
        for (j = i; j < N; j++) {
 8009560:	3301      	adds	r3, #1
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 8009562:	eee5 7aa6 	vfma.f32	s15, s11, s13
        for (j = i; j < N; j++) {
 8009566:	429c      	cmp	r4, r3
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 8009568:	ee77 7a27 	vadd.f32	s15, s14, s15
 800956c:	ece2 7a01 	vstmia	r2!, {s15}
        for (j = i; j < N; j++) {
 8009570:	dcee      	bgt.n	8009550 <cblas_ssyr2k+0x170>
      for (i = 0; i < N; i++) {
 8009572:	45a9      	cmp	r9, r5
 8009574:	f106 0601 	add.w	r6, r6, #1
 8009578:	4457      	add	r7, sl
 800957a:	d1dc      	bne.n	8009536 <cblas_ssyr2k+0x156>
    for (k = 0; k < K; k++) {
 800957c:	9b03      	ldr	r3, [sp, #12]
 800957e:	4499      	add	r9, r3
 8009580:	9b04      	ldr	r3, [sp, #16]
 8009582:	449b      	add	fp, r3
 8009584:	9b05      	ldr	r3, [sp, #20]
 8009586:	4498      	add	r8, r3
 8009588:	9b02      	ldr	r3, [sp, #8]
 800958a:	f10e 0e01 	add.w	lr, lr, #1
 800958e:	4573      	cmp	r3, lr
 8009590:	d1c7      	bne.n	8009522 <cblas_ssyr2k+0x142>
#define BASE float
#include "source_syr2k_r.h"
#undef BASE
}
 8009592:	b00b      	add	sp, #44	; 0x2c
 8009594:	ecbd 8b02 	vpop	{d8}
 8009598:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800959c:	4621      	mov	r1, r4
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800959e:	f1aa 0379 	sub.w	r3, sl, #121	; 0x79
 80095a2:	2b01      	cmp	r3, #1
 80095a4:	d917      	bls.n	80095d6 <cblas_ssyr2k+0x1f6>
 80095a6:	2002      	movs	r0, #2
 80095a8:	e745      	b.n	8009436 <cblas_ssyr2k+0x56>
 80095aa:	2c01      	cmp	r4, #1
 80095ac:	4620      	mov	r0, r4
 80095ae:	bfb8      	it	lt
 80095b0:	2001      	movlt	r0, #1
 80095b2:	4580      	cmp	r8, r0
 80095b4:	bfb4      	ite	lt
 80095b6:	200e      	movlt	r0, #14
 80095b8:	200b      	movge	r0, #11
 80095ba:	e755      	b.n	8009468 <cblas_ssyr2k+0x88>
 80095bc:	455b      	cmp	r3, fp
 80095be:	dcf4      	bgt.n	80095aa <cblas_ssyr2k+0x1ca>
 80095c0:	2c01      	cmp	r4, #1
 80095c2:	4623      	mov	r3, r4
 80095c4:	bfb8      	it	lt
 80095c6:	2301      	movlt	r3, #1
 80095c8:	4543      	cmp	r3, r8
 80095ca:	f300 80e2 	bgt.w	8009792 <cblas_ssyr2k+0x3b2>
 80095ce:	2800      	cmp	r0, #0
 80095d0:	f43f af4e 	beq.w	8009470 <cblas_ssyr2k+0x90>
 80095d4:	e748      	b.n	8009468 <cblas_ssyr2k+0x88>
 80095d6:	f1a9 0065 	sub.w	r0, r9, #101	; 0x65
 80095da:	2801      	cmp	r0, #1
 80095dc:	bf94      	ite	ls
 80095de:	2000      	movls	r0, #0
 80095e0:	2001      	movhi	r0, #1
 80095e2:	e722      	b.n	800942a <cblas_ssyr2k+0x4a>
 80095e4:	2a6f      	cmp	r2, #111	; 0x6f
 80095e6:	f000 815f 	beq.w	80098a8 <cblas_ssyr2k+0x4c8>
 80095ea:	4621      	mov	r1, r4
 80095ec:	e717      	b.n	800941e <cblas_ssyr2k+0x3e>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 80095ee:	2d71      	cmp	r5, #113	; 0x71
  if (beta == 0.0) {
 80095f0:	eef5 8a40 	vcmp.f32	s17, #0.0
 80095f4:	bf14      	ite	ne
 80095f6:	46ac      	movne	ip, r5
 80095f8:	f04f 0c70 	moveq.w	ip, #112	; 0x70
 80095fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009600:	d033      	beq.n	800966a <cblas_ssyr2k+0x28a>
  } else if (beta != 1.0) {
 8009602:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009606:	eef4 8a67 	vcmp.f32	s17, s15
 800960a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800960e:	d045      	beq.n	800969c <cblas_ssyr2k+0x2bc>
    if (uplo == CblasUpper) {
 8009610:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 8009614:	f000 81eb 	beq.w	80099ee <cblas_ssyr2k+0x60e>
      for (i = 0; i < N; i++) {
 8009618:	2c00      	cmp	r4, #0
 800961a:	dd14      	ble.n	8009646 <cblas_ssyr2k+0x266>
 800961c:	f108 0501 	add.w	r5, r8, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009620:	2100      	movs	r1, #0
 8009622:	00ad      	lsls	r5, r5, #2
      for (i = 0; i < N; i++) {
 8009624:	4608      	mov	r0, r1
 8009626:	1d3a      	adds	r2, r7, #4
 8009628:	eb07 0381 	add.w	r3, r7, r1, lsl #2
          C[ldc * i + j] *= beta;
 800962c:	edd3 7a00 	vldr	s15, [r3]
 8009630:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8009634:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j <= i; j++) {
 8009638:	4293      	cmp	r3, r2
 800963a:	d1f7      	bne.n	800962c <cblas_ssyr2k+0x24c>
      for (i = 0; i < N; i++) {
 800963c:	3001      	adds	r0, #1
 800963e:	4284      	cmp	r4, r0
 8009640:	4441      	add	r1, r8
 8009642:	442a      	add	r2, r5
 8009644:	dcf0      	bgt.n	8009628 <cblas_ssyr2k+0x248>
  if (alpha == 0.0)
 8009646:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800964a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800964e:	d0a0      	beq.n	8009592 <cblas_ssyr2k+0x1b2>
        }
      }
    }

  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8009650:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 8009654:	d02f      	beq.n	80096b6 <cblas_ssyr2k+0x2d6>
      }
    }


  } else {
    BLAS_ERROR("unrecognized operation");
 8009656:	4a5d      	ldr	r2, [pc, #372]	; (80097cc <cblas_ssyr2k+0x3ec>)
 8009658:	495b      	ldr	r1, [pc, #364]	; (80097c8 <cblas_ssyr2k+0x3e8>)
 800965a:	2000      	movs	r0, #0
 800965c:	b00b      	add	sp, #44	; 0x2c
 800965e:	ecbd 8b02 	vpop	{d8}
 8009662:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009666:	f01e b9ef 	b.w	8027a48 <cblas_xerbla>
    if (uplo == CblasUpper) {
 800966a:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800966e:	f000 81ba 	beq.w	80099e6 <cblas_ssyr2k+0x606>
      for (i = 0; i < N; i++) {
 8009672:	2c00      	cmp	r4, #0
 8009674:	dde7      	ble.n	8009646 <cblas_ssyr2k+0x266>
 8009676:	f108 0501 	add.w	r5, r8, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800967a:	2000      	movs	r0, #0
          C[ldc * i + j] = 0.0;
 800967c:	f04f 0e00 	mov.w	lr, #0
 8009680:	00ad      	lsls	r5, r5, #2
      for (i = 0; i < N; i++) {
 8009682:	4601      	mov	r1, r0
 8009684:	1d3a      	adds	r2, r7, #4
 8009686:	eb07 0380 	add.w	r3, r7, r0, lsl #2
          C[ldc * i + j] = 0.0;
 800968a:	f843 eb04 	str.w	lr, [r3], #4
        for (j = 0; j <= i; j++) {
 800968e:	429a      	cmp	r2, r3
 8009690:	d1fb      	bne.n	800968a <cblas_ssyr2k+0x2aa>
      for (i = 0; i < N; i++) {
 8009692:	3101      	adds	r1, #1
 8009694:	428c      	cmp	r4, r1
 8009696:	4440      	add	r0, r8
 8009698:	442a      	add	r2, r5
 800969a:	dcf4      	bgt.n	8009686 <cblas_ssyr2k+0x2a6>
  if (alpha == 0.0)
 800969c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80096a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80096a4:	f43f af75 	beq.w	8009592 <cblas_ssyr2k+0x1b2>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 80096a8:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 80096ac:	f43f af1e 	beq.w	80094ec <cblas_ssyr2k+0x10c>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80096b0:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 80096b4:	d1cf      	bne.n	8009656 <cblas_ssyr2k+0x276>
 80096b6:	f1bc 0f6f 	cmp.w	ip, #111	; 0x6f
 80096ba:	f000 8139 	beq.w	8009930 <cblas_ssyr2k+0x550>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 80096be:	f1bc 0f70 	cmp.w	ip, #112	; 0x70
 80096c2:	d1c8      	bne.n	8009656 <cblas_ssyr2k+0x276>
    for (k = 0; k < K; k++) {
 80096c4:	9b02      	ldr	r3, [sp, #8]
 80096c6:	2b00      	cmp	r3, #0
 80096c8:	f77f af63 	ble.w	8009592 <cblas_ssyr2k+0x1b2>
 80096cc:	00b3      	lsls	r3, r6, #2
 80096ce:	f8dd 8000 	ldr.w	r8, [sp]
 80096d2:	9303      	str	r3, [sp, #12]
 80096d4:	ea4f 028b 	mov.w	r2, fp, lsl #2
 80096d8:	f103 0b04 	add.w	fp, r3, #4
 80096dc:	2300      	movs	r3, #0
 80096de:	f8dd 9004 	ldr.w	r9, [sp, #4]
 80096e2:	9200      	str	r2, [sp, #0]
 80096e4:	eb08 0a84 	add.w	sl, r8, r4, lsl #2
 80096e8:	469e      	mov	lr, r3
 80096ea:	9401      	str	r4, [sp, #4]
      for (i = 0; i < N; i++) {
 80096ec:	9b01      	ldr	r3, [sp, #4]
 80096ee:	2b00      	cmp	r3, #0
 80096f0:	dd23      	ble.n	800973a <cblas_ssyr2k+0x35a>
 80096f2:	1d38      	adds	r0, r7, #4
 80096f4:	46cc      	mov	ip, r9
 80096f6:	4645      	mov	r5, r8
 80096f8:	2400      	movs	r4, #0
        BASE temp1 = alpha * A[k * lda + i];
 80096fa:	ecf5 5a01 	vldmia	r5!, {s11}
        BASE temp2 = alpha * B[k * ldb + i];
 80096fe:	ecbc 6a01 	vldmia	ip!, {s12}
        BASE temp1 = alpha * A[k * lda + i];
 8009702:	ee65 5a88 	vmul.f32	s11, s11, s16
        BASE temp2 = alpha * B[k * ldb + i];
 8009706:	ee26 6a08 	vmul.f32	s12, s12, s16
        for (j = 0; j <= i; j++) {
 800970a:	eb07 0384 	add.w	r3, r7, r4, lsl #2
        BASE temp2 = alpha * B[k * ldb + i];
 800970e:	4641      	mov	r1, r8
 8009710:	464a      	mov	r2, r9
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 8009712:	ecf1 7a01 	vldmia	r1!, {s15}
 8009716:	ecf2 6a01 	vldmia	r2!, {s13}
 800971a:	ed93 7a00 	vldr	s14, [r3]
 800971e:	ee67 7a86 	vmul.f32	s15, s15, s12
 8009722:	eee6 7aa5 	vfma.f32	s15, s13, s11
 8009726:	ee77 7a27 	vadd.f32	s15, s14, s15
 800972a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j <= i; j++) {
 800972e:	4283      	cmp	r3, r0
 8009730:	d1ef      	bne.n	8009712 <cblas_ssyr2k+0x332>
      for (i = 0; i < N; i++) {
 8009732:	4555      	cmp	r5, sl
 8009734:	4434      	add	r4, r6
 8009736:	4458      	add	r0, fp
 8009738:	d1df      	bne.n	80096fa <cblas_ssyr2k+0x31a>
    for (k = 0; k < K; k++) {
 800973a:	9b03      	ldr	r3, [sp, #12]
 800973c:	9a00      	ldr	r2, [sp, #0]
 800973e:	449a      	add	sl, r3
 8009740:	4498      	add	r8, r3
 8009742:	9b02      	ldr	r3, [sp, #8]
 8009744:	f10e 0e01 	add.w	lr, lr, #1
 8009748:	4573      	cmp	r3, lr
 800974a:	4491      	add	r9, r2
 800974c:	d1ce      	bne.n	80096ec <cblas_ssyr2k+0x30c>
 800974e:	e720      	b.n	8009592 <cblas_ssyr2k+0x1b2>
  } else if (beta != 1.0) {
 8009750:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009754:	eef4 8a67 	vcmp.f32	s17, s15
 8009758:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800975c:	d01b      	beq.n	8009796 <cblas_ssyr2k+0x3b6>
      for (i = 0; i < N; i++) {
 800975e:	2c00      	cmp	r4, #0
      trans = CblasTrans;
 8009760:	bfc8      	it	gt
 8009762:	f04f 0c70 	movgt.w	ip, #112	; 0x70
      for (i = 0; i < N; i++) {
 8009766:	dd16      	ble.n	8009796 <cblas_ssyr2k+0x3b6>
 8009768:	f108 0501 	add.w	r5, r8, #1
 800976c:	00ad      	lsls	r5, r5, #2
 800976e:	4638      	mov	r0, r7
 8009770:	2100      	movs	r1, #0
 8009772:	4602      	mov	r2, r0
 8009774:	460b      	mov	r3, r1
          C[ldc * i + j] *= beta;
 8009776:	edd2 7a00 	vldr	s15, [r2]
        for (j = i; j < N; j++) {
 800977a:	3301      	adds	r3, #1
          C[ldc * i + j] *= beta;
 800977c:	ee67 7aa8 	vmul.f32	s15, s15, s17
        for (j = i; j < N; j++) {
 8009780:	429c      	cmp	r4, r3
          C[ldc * i + j] *= beta;
 8009782:	ece2 7a01 	vstmia	r2!, {s15}
        for (j = i; j < N; j++) {
 8009786:	dcf6      	bgt.n	8009776 <cblas_ssyr2k+0x396>
      for (i = 0; i < N; i++) {
 8009788:	3101      	adds	r1, #1
 800978a:	428c      	cmp	r4, r1
 800978c:	4428      	add	r0, r5
 800978e:	dcf0      	bgt.n	8009772 <cblas_ssyr2k+0x392>
 8009790:	e6a7      	b.n	80094e2 <cblas_ssyr2k+0x102>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8009792:	200e      	movs	r0, #14
 8009794:	e668      	b.n	8009468 <cblas_ssyr2k+0x88>
  if (alpha == 0.0)
 8009796:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800979a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800979e:	f47f aead 	bne.w	80094fc <cblas_ssyr2k+0x11c>
 80097a2:	e6f6      	b.n	8009592 <cblas_ssyr2k+0x1b2>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 80097a4:	2b01      	cmp	r3, #1
 80097a6:	f240 808f 	bls.w	80098c8 <cblas_ssyr2k+0x4e8>
  if (beta == 0.0) {
 80097aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80097ae:	f040 809c 	bne.w	80098ea <cblas_ssyr2k+0x50a>
      for (i = 0; i < N; i++) {
 80097b2:	2c00      	cmp	r4, #0
 80097b4:	f340 80af 	ble.w	8009916 <cblas_ssyr2k+0x536>
      trans = CblasTrans;
 80097b8:	f04f 0c70 	mov.w	ip, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80097bc:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 80097c0:	e759      	b.n	8009676 <cblas_ssyr2k+0x296>
 80097c2:	bf00      	nop
 80097c4:	08030378 	.word	0x08030378
 80097c8:	0803064c 	.word	0x0803064c
 80097cc:	080305a8 	.word	0x080305a8
 80097d0:	00000000 	.word	0x00000000
  if (beta == 0.0) {
 80097d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80097d8:	d168      	bne.n	80098ac <cblas_ssyr2k+0x4cc>
      for (i = 0; i < N; i++) {
 80097da:	2c00      	cmp	r4, #0
      trans = CblasNoTrans;
 80097dc:	bfc8      	it	gt
 80097de:	f04f 0c6f 	movgt.w	ip, #111	; 0x6f
      for (i = 0; i < N; i++) {
 80097e2:	f73f ae6c 	bgt.w	80094be <cblas_ssyr2k+0xde>
  if (alpha == 0.0)
 80097e6:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80097ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80097ee:	f43f aed0 	beq.w	8009592 <cblas_ssyr2k+0x1b2>
    for (i = 0; i < N; i++) {
 80097f2:	2c00      	cmp	r4, #0
 80097f4:	f77f aecd 	ble.w	8009592 <cblas_ssyr2k+0x1b2>
 80097f8:	2300      	movs	r3, #0
 80097fa:	e9cd 3705 	strd	r3, r7, [sp, #20]
 80097fe:	9304      	str	r3, [sp, #16]
 8009800:	9303      	str	r3, [sp, #12]
 8009802:	00b3      	lsls	r3, r6, #2
 8009804:	9308      	str	r3, [sp, #32]
 8009806:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800980a:	9902      	ldr	r1, [sp, #8]
 800980c:	9307      	str	r3, [sp, #28]
 800980e:	f108 0801 	add.w	r8, r8, #1
 8009812:	9b00      	ldr	r3, [sp, #0]
 8009814:	f8dd a004 	ldr.w	sl, [sp, #4]
 8009818:	ea4f 0288 	mov.w	r2, r8, lsl #2
 800981c:	9209      	str	r2, [sp, #36]	; 0x24
 800981e:	eb03 0581 	add.w	r5, r3, r1, lsl #2
 8009822:	4699      	mov	r9, r3
        BASE temp = 0.0;
 8009824:	e9dd 8e04 	ldrd	r8, lr, [sp, #16]
 8009828:	f8dd c018 	ldr.w	ip, [sp, #24]
 800982c:	9f03      	ldr	r7, [sp, #12]
        for (k = 0; k < K; k++) {
 800982e:	9b02      	ldr	r3, [sp, #8]
        BASE temp = 0.0;
 8009830:	ed1f 7a19 	vldr	s14, [pc, #-100]	; 80097d0 <cblas_ssyr2k+0x3f0>
        for (k = 0; k < K; k++) {
 8009834:	2b00      	cmp	r3, #0
 8009836:	dd17      	ble.n	8009868 <cblas_ssyr2k+0x488>
 8009838:	9b01      	ldr	r3, [sp, #4]
 800983a:	eb03 008e 	add.w	r0, r3, lr, lsl #2
 800983e:	9b00      	ldr	r3, [sp, #0]
 8009840:	4652      	mov	r2, sl
 8009842:	eb03 0188 	add.w	r1, r3, r8, lsl #2
 8009846:	464b      	mov	r3, r9
                   + B[i * ldb + k] * A[j * lda + k]);
 8009848:	ecf2 7a01 	vldmia	r2!, {s15}
 800984c:	ecf1 5a01 	vldmia	r1!, {s11}
          temp += (A[i * lda + k] * B[j * ldb + k]
 8009850:	ecb3 6a01 	vldmia	r3!, {s12}
 8009854:	ecf0 6a01 	vldmia	r0!, {s13}
                   + B[i * ldb + k] * A[j * lda + k]);
 8009858:	ee67 7aa5 	vmul.f32	s15, s15, s11
        for (k = 0; k < K; k++) {
 800985c:	429d      	cmp	r5, r3
                   + B[i * ldb + k] * A[j * lda + k]);
 800985e:	eee6 7a26 	vfma.f32	s15, s12, s13
          temp += (A[i * lda + k] * B[j * ldb + k]
 8009862:	ee37 7a27 	vadd.f32	s14, s14, s15
        for (k = 0; k < K; k++) {
 8009866:	d1ef      	bne.n	8009848 <cblas_ssyr2k+0x468>
        C[i * ldc + j] += alpha * temp;
 8009868:	eddc 7a00 	vldr	s15, [ip]
 800986c:	eee7 7a08 	vfma.f32	s15, s14, s16
      for (j = i; j < N; j++) {
 8009870:	3701      	adds	r7, #1
 8009872:	42bc      	cmp	r4, r7
 8009874:	44de      	add	lr, fp
 8009876:	44b0      	add	r8, r6
        C[i * ldc + j] += alpha * temp;
 8009878:	ecec 7a01 	vstmia	ip!, {s15}
      for (j = i; j < N; j++) {
 800987c:	dcd7      	bgt.n	800982e <cblas_ssyr2k+0x44e>
    for (i = 0; i < N; i++) {
 800987e:	9a06      	ldr	r2, [sp, #24]
 8009880:	9909      	ldr	r1, [sp, #36]	; 0x24
 8009882:	9b03      	ldr	r3, [sp, #12]
 8009884:	440a      	add	r2, r1
 8009886:	9206      	str	r2, [sp, #24]
 8009888:	9a05      	ldr	r2, [sp, #20]
 800988a:	9907      	ldr	r1, [sp, #28]
 800988c:	445a      	add	r2, fp
 800988e:	9205      	str	r2, [sp, #20]
 8009890:	9a04      	ldr	r2, [sp, #16]
 8009892:	4432      	add	r2, r6
 8009894:	3301      	adds	r3, #1
 8009896:	9204      	str	r2, [sp, #16]
 8009898:	9a08      	ldr	r2, [sp, #32]
 800989a:	9303      	str	r3, [sp, #12]
 800989c:	429c      	cmp	r4, r3
 800989e:	4491      	add	r9, r2
 80098a0:	448a      	add	sl, r1
 80098a2:	4415      	add	r5, r2
 80098a4:	d1be      	bne.n	8009824 <cblas_ssyr2k+0x444>
 80098a6:	e674      	b.n	8009592 <cblas_ssyr2k+0x1b2>
 80098a8:	9902      	ldr	r1, [sp, #8]
 80098aa:	e678      	b.n	800959e <cblas_ssyr2k+0x1be>
  } else if (beta != 1.0) {
 80098ac:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80098b0:	eef4 8a67 	vcmp.f32	s17, s15
 80098b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80098b8:	d095      	beq.n	80097e6 <cblas_ssyr2k+0x406>
      for (i = 0; i < N; i++) {
 80098ba:	2c00      	cmp	r4, #0
      trans = CblasNoTrans;
 80098bc:	bfc8      	it	gt
 80098be:	f04f 0c6f 	movgt.w	ip, #111	; 0x6f
      for (i = 0; i < N; i++) {
 80098c2:	f73f af51 	bgt.w	8009768 <cblas_ssyr2k+0x388>
 80098c6:	e78e      	b.n	80097e6 <cblas_ssyr2k+0x406>
  if (beta == 0.0) {
 80098c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80098cc:	d01b      	beq.n	8009906 <cblas_ssyr2k+0x526>
  } else if (beta != 1.0) {
 80098ce:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80098d2:	eef4 8a67 	vcmp.f32	s17, s15
 80098d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80098da:	d023      	beq.n	8009924 <cblas_ssyr2k+0x544>
      for (i = 0; i < N; i++) {
 80098dc:	2c00      	cmp	r4, #0
 80098de:	dd21      	ble.n	8009924 <cblas_ssyr2k+0x544>
      trans = CblasNoTrans;
 80098e0:	f04f 0c6f 	mov.w	ip, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80098e4:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 80098e8:	e698      	b.n	800961c <cblas_ssyr2k+0x23c>
  } else if (beta != 1.0) {
 80098ea:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80098ee:	eef4 8a67 	vcmp.f32	s17, s15
 80098f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80098f6:	d00e      	beq.n	8009916 <cblas_ssyr2k+0x536>
      for (i = 0; i < N; i++) {
 80098f8:	2c00      	cmp	r4, #0
 80098fa:	dd0c      	ble.n	8009916 <cblas_ssyr2k+0x536>
      trans = CblasTrans;
 80098fc:	f04f 0c70 	mov.w	ip, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009900:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 8009904:	e68a      	b.n	800961c <cblas_ssyr2k+0x23c>
      for (i = 0; i < N; i++) {
 8009906:	2c00      	cmp	r4, #0
 8009908:	f77f ae43 	ble.w	8009592 <cblas_ssyr2k+0x1b2>
      trans = CblasNoTrans;
 800990c:	f04f 0c6f 	mov.w	ip, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009910:	f04f 0a7a 	mov.w	sl, #122	; 0x7a
 8009914:	e6af      	b.n	8009676 <cblas_ssyr2k+0x296>
  if (alpha == 0.0)
 8009916:	eeb5 8a40 	vcmp.f32	s16, #0.0
 800991a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800991e:	f47f aed1 	bne.w	80096c4 <cblas_ssyr2k+0x2e4>
 8009922:	e636      	b.n	8009592 <cblas_ssyr2k+0x1b2>
 8009924:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009928:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800992c:	f43f ae31 	beq.w	8009592 <cblas_ssyr2k+0x1b2>
    for (i = 0; i < N; i++) {
 8009930:	2c00      	cmp	r4, #0
 8009932:	f77f ae2e 	ble.w	8009592 <cblas_ssyr2k+0x1b2>
 8009936:	f108 0301 	add.w	r3, r8, #1
 800993a:	009b      	lsls	r3, r3, #2
 800993c:	9307      	str	r3, [sp, #28]
 800993e:	00b3      	lsls	r3, r6, #2
 8009940:	2200      	movs	r2, #0
 8009942:	9306      	str	r3, [sp, #24]
 8009944:	ea4f 038b 	mov.w	r3, fp, lsl #2
 8009948:	9902      	ldr	r1, [sp, #8]
 800994a:	9203      	str	r2, [sp, #12]
 800994c:	9204      	str	r2, [sp, #16]
 800994e:	9305      	str	r3, [sp, #20]
 8009950:	9a01      	ldr	r2, [sp, #4]
 8009952:	9b00      	ldr	r3, [sp, #0]
 8009954:	9402      	str	r4, [sp, #8]
 8009956:	e9cd 7808 	strd	r7, r8, [sp, #32]
 800995a:	f107 0a04 	add.w	sl, r7, #4
 800995e:	eb03 0581 	add.w	r5, r3, r1, lsl #2
 8009962:	4696      	mov	lr, r2
 8009964:	4689      	mov	r9, r1
 8009966:	4698      	mov	r8, r3
 8009968:	9b08      	ldr	r3, [sp, #32]
 800996a:	9a03      	ldr	r2, [sp, #12]
        BASE temp = 0.0;
 800996c:	2700      	movs	r7, #0
 800996e:	46bc      	mov	ip, r7
 8009970:	eb03 0482 	add.w	r4, r3, r2, lsl #2
        for (k = 0; k < K; k++) {
 8009974:	f1b9 0f00 	cmp.w	r9, #0
        BASE temp = 0.0;
 8009978:	ed1f 7a6b 	vldr	s14, [pc, #-428]	; 80097d0 <cblas_ssyr2k+0x3f0>
        for (k = 0; k < K; k++) {
 800997c:	dd17      	ble.n	80099ae <cblas_ssyr2k+0x5ce>
 800997e:	9b01      	ldr	r3, [sp, #4]
 8009980:	eb03 008c 	add.w	r0, r3, ip, lsl #2
 8009984:	9b00      	ldr	r3, [sp, #0]
 8009986:	4672      	mov	r2, lr
 8009988:	eb03 0187 	add.w	r1, r3, r7, lsl #2
 800998c:	4643      	mov	r3, r8
                   + B[i * ldb + k] * A[j * lda + k]);
 800998e:	ecf2 7a01 	vldmia	r2!, {s15}
 8009992:	ecf1 5a01 	vldmia	r1!, {s11}
          temp += (A[i * lda + k] * B[j * ldb + k]
 8009996:	ecb3 6a01 	vldmia	r3!, {s12}
 800999a:	ecf0 6a01 	vldmia	r0!, {s13}
                   + B[i * ldb + k] * A[j * lda + k]);
 800999e:	ee67 7aa5 	vmul.f32	s15, s15, s11
        for (k = 0; k < K; k++) {
 80099a2:	429d      	cmp	r5, r3
                   + B[i * ldb + k] * A[j * lda + k]);
 80099a4:	eee6 7a26 	vfma.f32	s15, s12, s13
          temp += (A[i * lda + k] * B[j * ldb + k]
 80099a8:	ee37 7a27 	vadd.f32	s14, s14, s15
        for (k = 0; k < K; k++) {
 80099ac:	d1ef      	bne.n	800998e <cblas_ssyr2k+0x5ae>
        C[i * ldc + j] += alpha * temp;
 80099ae:	edd4 7a00 	vldr	s15, [r4]
 80099b2:	eee8 7a07 	vfma.f32	s15, s16, s14
 80099b6:	44dc      	add	ip, fp
 80099b8:	4437      	add	r7, r6
 80099ba:	ece4 7a01 	vstmia	r4!, {s15}
      for (j = 0; j <= i; j++) {
 80099be:	45a2      	cmp	sl, r4
 80099c0:	d1d8      	bne.n	8009974 <cblas_ssyr2k+0x594>
    for (i = 0; i < N; i++) {
 80099c2:	9a03      	ldr	r2, [sp, #12]
 80099c4:	9909      	ldr	r1, [sp, #36]	; 0x24
 80099c6:	9b04      	ldr	r3, [sp, #16]
 80099c8:	440a      	add	r2, r1
 80099ca:	9203      	str	r2, [sp, #12]
 80099cc:	9a07      	ldr	r2, [sp, #28]
 80099ce:	9905      	ldr	r1, [sp, #20]
 80099d0:	4492      	add	sl, r2
 80099d2:	9a06      	ldr	r2, [sp, #24]
 80099d4:	4490      	add	r8, r2
 80099d6:	4415      	add	r5, r2
 80099d8:	9a02      	ldr	r2, [sp, #8]
 80099da:	3301      	adds	r3, #1
 80099dc:	429a      	cmp	r2, r3
 80099de:	9304      	str	r3, [sp, #16]
 80099e0:	448e      	add	lr, r1
 80099e2:	d1c1      	bne.n	8009968 <cblas_ssyr2k+0x588>
 80099e4:	e5d5      	b.n	8009592 <cblas_ssyr2k+0x1b2>
      for (i = 0; i < N; i++) {
 80099e6:	2c00      	cmp	r4, #0
 80099e8:	f73f ad69 	bgt.w	80094be <cblas_ssyr2k+0xde>
 80099ec:	e579      	b.n	80094e2 <cblas_ssyr2k+0x102>
      for (i = 0; i < N; i++) {
 80099ee:	2c00      	cmp	r4, #0
 80099f0:	f73f aeba 	bgt.w	8009768 <cblas_ssyr2k+0x388>
 80099f4:	e575      	b.n	80094e2 <cblas_ssyr2k+0x102>
 80099f6:	bf00      	nop

080099f8 <cblas_ssyrk>:
void
cblas_ssyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const float alpha, const float *A, const int lda,
             const float beta, float *C, const int ldc)
{
 80099f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80099fc:	ed2d 8b02 	vpush	{d8}
 8009a00:	b085      	sub	sp, #20
 8009a02:	461f      	mov	r7, r3
 8009a04:	e9dd 5312 	ldrd	r5, r3, [sp, #72]	; 0x48

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8009a08:	2865      	cmp	r0, #101	; 0x65
 8009a0a:	e9dd 4810 	ldrd	r4, r8, [sp, #64]	; 0x40
 8009a0e:	f8dd 9050 	ldr.w	r9, [sp, #80]	; 0x50
 8009a12:	9301      	str	r3, [sp, #4]
 8009a14:	4682      	mov	sl, r0
 8009a16:	460e      	mov	r6, r1
 8009a18:	4693      	mov	fp, r2
 8009a1a:	eeb0 8a40 	vmov.f32	s16, s0
 8009a1e:	eef0 8a60 	vmov.f32	s17, s1
 8009a22:	f000 80c7 	beq.w	8009bb4 <cblas_ssyrk+0x1bc>
 8009a26:	2a6f      	cmp	r2, #111	; 0x6f
 8009a28:	d021      	beq.n	8009a6e <cblas_ssyrk+0x76>
 8009a2a:	4622      	mov	r2, r4
 8009a2c:	f1a6 0379 	sub.w	r3, r6, #121	; 0x79
 8009a30:	2b01      	cmp	r3, #1
 8009a32:	f240 80b8 	bls.w	8009ba6 <cblas_ssyrk+0x1ae>
 8009a36:	2002      	movs	r0, #2
 8009a38:	f1ab 036f 	sub.w	r3, fp, #111	; 0x6f
 8009a3c:	b2db      	uxtb	r3, r3
 8009a3e:	2b03      	cmp	r3, #3
 8009a40:	bf28      	it	cs
 8009a42:	2003      	movcs	r0, #3
 8009a44:	2f00      	cmp	r7, #0
 8009a46:	bfb8      	it	lt
 8009a48:	2004      	movlt	r0, #4
 8009a4a:	2a01      	cmp	r2, #1
 8009a4c:	4613      	mov	r3, r2
 8009a4e:	bfb8      	it	lt
 8009a50:	2301      	movlt	r3, #1
 8009a52:	2c00      	cmp	r4, #0
 8009a54:	f2c0 809b 	blt.w	8009b8e <cblas_ssyrk+0x196>
 8009a58:	42ab      	cmp	r3, r5
 8009a5a:	dc10      	bgt.n	8009a7e <cblas_ssyrk+0x86>
 8009a5c:	2f01      	cmp	r7, #1
 8009a5e:	463b      	mov	r3, r7
 8009a60:	bfb8      	it	lt
 8009a62:	2301      	movlt	r3, #1
 8009a64:	454b      	cmp	r3, r9
 8009a66:	f300 816b 	bgt.w	8009d40 <cblas_ssyrk+0x348>
 8009a6a:	b1a0      	cbz	r0, 8009a96 <cblas_ssyrk+0x9e>
 8009a6c:	e00f      	b.n	8009a8e <cblas_ssyrk+0x96>
 8009a6e:	463a      	mov	r2, r7
 8009a70:	f1a6 0379 	sub.w	r3, r6, #121	; 0x79
 8009a74:	2b01      	cmp	r3, #1
 8009a76:	f240 8096 	bls.w	8009ba6 <cblas_ssyrk+0x1ae>
 8009a7a:	2002      	movs	r0, #2
 8009a7c:	e7e2      	b.n	8009a44 <cblas_ssyrk+0x4c>
 8009a7e:	2f01      	cmp	r7, #1
 8009a80:	4638      	mov	r0, r7
 8009a82:	bfb8      	it	lt
 8009a84:	2001      	movlt	r0, #1
 8009a86:	4581      	cmp	r9, r0
 8009a88:	bfb4      	ite	lt
 8009a8a:	200b      	movlt	r0, #11
 8009a8c:	2008      	movge	r0, #8
 8009a8e:	4ad7      	ldr	r2, [pc, #860]	; (8009dec <cblas_ssyrk+0x3f4>)
 8009a90:	49d7      	ldr	r1, [pc, #860]	; (8009df0 <cblas_ssyrk+0x3f8>)
 8009a92:	f01d ffd9 	bl	8027a48 <cblas_xerbla>

  if (alpha == 0.0 && beta == 1.0)
 8009a96:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009a9e:	d106      	bne.n	8009aae <cblas_ssyrk+0xb6>
 8009aa0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009aa4:	eef4 8a67 	vcmp.f32	s17, s15
 8009aa8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009aac:	d06a      	beq.n	8009b84 <cblas_ssyrk+0x18c>
    return;

  if (Order == CblasRowMajor) {
 8009aae:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8009ab2:	f000 8084 	beq.w	8009bbe <cblas_ssyrk+0x1c6>
    uplo = Uplo;
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
  } else {
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;

    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 8009ab6:	f1ab 0370 	sub.w	r3, fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009aba:	2e79      	cmp	r6, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 8009abc:	b2db      	uxtb	r3, r3
      trans = CblasTrans;
    }
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 8009abe:	eef5 8a40 	vcmp.f32	s17, #0.0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009ac2:	f000 813f 	beq.w	8009d44 <cblas_ssyrk+0x34c>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 8009ac6:	2b01      	cmp	r3, #1
 8009ac8:	f240 8147 	bls.w	8009d5a <cblas_ssyrk+0x362>
  if (beta == 0.0) {
 8009acc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009ad0:	f040 8113 	bne.w	8009cfa <cblas_ssyrk+0x302>
    if (uplo == CblasUpper) {
      for (i = 0; i < N; i++) {
 8009ad4:	2f00      	cmp	r7, #0
      trans = CblasTrans;
 8009ad6:	bfc8      	it	gt
 8009ad8:	2070      	movgt	r0, #112	; 0x70
      for (i = 0; i < N; i++) {
 8009ada:	dd53      	ble.n	8009b84 <cblas_ssyrk+0x18c>
 8009adc:	f109 0e01 	add.w	lr, r9, #1
 8009ae0:	f8dd c004 	ldr.w	ip, [sp, #4]
        for (j = i; j < N; j++) {
          C[ldc * i + j] = 0.0;
 8009ae4:	2100      	movs	r1, #0
 8009ae6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
      for (i = 0; i < N; i++) {
 8009aea:	2600      	movs	r6, #0
 8009aec:	4662      	mov	r2, ip
 8009aee:	4633      	mov	r3, r6
        for (j = i; j < N; j++) {
 8009af0:	3301      	adds	r3, #1
 8009af2:	429f      	cmp	r7, r3
          C[ldc * i + j] = 0.0;
 8009af4:	f842 1b04 	str.w	r1, [r2], #4
        for (j = i; j < N; j++) {
 8009af8:	dcfa      	bgt.n	8009af0 <cblas_ssyrk+0xf8>
      for (i = 0; i < N; i++) {
 8009afa:	3601      	adds	r6, #1
 8009afc:	42b7      	cmp	r7, r6
 8009afe:	44f4      	add	ip, lr
 8009b00:	dcf4      	bgt.n	8009aec <cblas_ssyrk+0xf4>
        }
      }
    }
  }

  if (alpha == 0.0)
 8009b02:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009b06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009b0a:	d03b      	beq.n	8009b84 <cblas_ssyrk+0x18c>
    return;

  if (uplo == CblasUpper && trans == CblasNoTrans) {
 8009b0c:	286f      	cmp	r0, #111	; 0x6f
 8009b0e:	f000 8132 	beq.w	8009d76 <cblas_ssyrk+0x37e>
        }
        C[i * ldc + j] += alpha * temp;
      }
    }

  } else if (uplo == CblasUpper && trans == CblasTrans) {
 8009b12:	2870      	cmp	r0, #112	; 0x70
 8009b14:	f040 8089 	bne.w	8009c2a <cblas_ssyrk+0x232>

    for (i = 0; i < N; i++) {
 8009b18:	2f00      	cmp	r7, #0
 8009b1a:	dd33      	ble.n	8009b84 <cblas_ssyrk+0x18c>
 8009b1c:	f109 0901 	add.w	r9, r9, #1
 8009b20:	2600      	movs	r6, #0
 8009b22:	f8dd a004 	ldr.w	sl, [sp, #4]
 8009b26:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8009b2a:	00ad      	lsls	r5, r5, #2
 8009b2c:	46b3      	mov	fp, r6
 8009b2e:	ea4f 008b 	mov.w	r0, fp, lsl #2
      for (j = i; j < N; j++) {
        BASE temp = 0.0;
 8009b32:	46d6      	mov	lr, sl
 8009b34:	46dc      	mov	ip, fp
        for (k = 0; k < K; k++) {
 8009b36:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 8009b38:	eddf 7aaf 	vldr	s15, [pc, #700]	; 8009df8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 8009b3c:	dd0d      	ble.n	8009b5a <cblas_ssyrk+0x162>
 8009b3e:	4643      	mov	r3, r8
 8009b40:	2100      	movs	r1, #0
          temp += A[k * lda + i] * A[k * lda + j];
 8009b42:	18f2      	adds	r2, r6, r3
 8009b44:	4402      	add	r2, r0
 8009b46:	edd3 6a00 	vldr	s13, [r3]
 8009b4a:	ed92 7a00 	vldr	s14, [r2]
        for (k = 0; k < K; k++) {
 8009b4e:	3101      	adds	r1, #1
 8009b50:	428c      	cmp	r4, r1
          temp += A[k * lda + i] * A[k * lda + j];
 8009b52:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 8009b56:	442b      	add	r3, r5
 8009b58:	d1f3      	bne.n	8009b42 <cblas_ssyrk+0x14a>
        }
        C[i * ldc + j] += alpha * temp;
 8009b5a:	ed9e 7a00 	vldr	s14, [lr]
 8009b5e:	eea7 7a88 	vfma.f32	s14, s15, s16
      for (j = i; j < N; j++) {
 8009b62:	f10c 0c01 	add.w	ip, ip, #1
 8009b66:	4567      	cmp	r7, ip
 8009b68:	f100 0004 	add.w	r0, r0, #4
        C[i * ldc + j] += alpha * temp;
 8009b6c:	ecae 7a01 	vstmia	lr!, {s14}
      for (j = i; j < N; j++) {
 8009b70:	dce1      	bgt.n	8009b36 <cblas_ssyrk+0x13e>
    for (i = 0; i < N; i++) {
 8009b72:	f10b 0b01 	add.w	fp, fp, #1
 8009b76:	455f      	cmp	r7, fp
 8009b78:	44ca      	add	sl, r9
 8009b7a:	f108 0804 	add.w	r8, r8, #4
 8009b7e:	f1a6 0604 	sub.w	r6, r6, #4
 8009b82:	d1d4      	bne.n	8009b2e <cblas_ssyrk+0x136>
#define BASE float
#include "source_syrk_r.h"
#undef BASE
}
 8009b84:	b005      	add	sp, #20
 8009b86:	ecbd 8b02 	vpop	{d8}
 8009b8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8009b8e:	42ab      	cmp	r3, r5
 8009b90:	f73f af75 	bgt.w	8009a7e <cblas_ssyrk+0x86>
 8009b94:	2f01      	cmp	r7, #1
 8009b96:	4638      	mov	r0, r7
 8009b98:	bfb8      	it	lt
 8009b9a:	2001      	movlt	r0, #1
 8009b9c:	4581      	cmp	r9, r0
 8009b9e:	bfb4      	ite	lt
 8009ba0:	200b      	movlt	r0, #11
 8009ba2:	2005      	movge	r0, #5
 8009ba4:	e773      	b.n	8009a8e <cblas_ssyrk+0x96>
 8009ba6:	f1aa 0065 	sub.w	r0, sl, #101	; 0x65
 8009baa:	2801      	cmp	r0, #1
 8009bac:	bf94      	ite	ls
 8009bae:	2000      	movls	r0, #0
 8009bb0:	2001      	movhi	r0, #1
 8009bb2:	e741      	b.n	8009a38 <cblas_ssyrk+0x40>
 8009bb4:	2a6f      	cmp	r2, #111	; 0x6f
 8009bb6:	f000 8117 	beq.w	8009de8 <cblas_ssyrk+0x3f0>
 8009bba:	463a      	mov	r2, r7
 8009bbc:	e736      	b.n	8009a2c <cblas_ssyrk+0x34>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 8009bbe:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
  if (beta == 0.0) {
 8009bc2:	eef5 8a40 	vcmp.f32	s17, #0.0
 8009bc6:	bf14      	ite	ne
 8009bc8:	4658      	movne	r0, fp
 8009bca:	2070      	moveq	r0, #112	; 0x70
 8009bcc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009bd0:	d035      	beq.n	8009c3e <cblas_ssyrk+0x246>
  } else if (beta != 1.0) {
 8009bd2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009bd6:	eef4 8a67 	vcmp.f32	s17, s15
 8009bda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009bde:	d04a      	beq.n	8009c76 <cblas_ssyrk+0x27e>
    if (uplo == CblasUpper) {
 8009be0:	2e79      	cmp	r6, #121	; 0x79
 8009be2:	f000 8187 	beq.w	8009ef4 <cblas_ssyrk+0x4fc>
      for (i = 0; i < N; i++) {
 8009be6:	2f00      	cmp	r7, #0
 8009be8:	dd18      	ble.n	8009c1c <cblas_ssyrk+0x224>
 8009bea:	9b01      	ldr	r3, [sp, #4]
 8009bec:	f109 0e01 	add.w	lr, r9, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009bf0:	f04f 0c00 	mov.w	ip, #0
 8009bf4:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
      for (i = 0; i < N; i++) {
 8009bf8:	4661      	mov	r1, ip
 8009bfa:	1d1a      	adds	r2, r3, #4
 8009bfc:	469a      	mov	sl, r3
 8009bfe:	eb0a 038c 	add.w	r3, sl, ip, lsl #2
          C[ldc * i + j] *= beta;
 8009c02:	edd3 7a00 	vldr	s15, [r3]
 8009c06:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8009c0a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j <= i; j++) {
 8009c0e:	429a      	cmp	r2, r3
 8009c10:	d1f7      	bne.n	8009c02 <cblas_ssyrk+0x20a>
      for (i = 0; i < N; i++) {
 8009c12:	3101      	adds	r1, #1
 8009c14:	428f      	cmp	r7, r1
 8009c16:	44cc      	add	ip, r9
 8009c18:	4472      	add	r2, lr
 8009c1a:	dcf0      	bgt.n	8009bfe <cblas_ssyrk+0x206>
  if (alpha == 0.0)
 8009c1c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009c20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009c24:	d0ae      	beq.n	8009b84 <cblas_ssyrk+0x18c>
      }
    }

  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8009c26:	2e7a      	cmp	r6, #122	; 0x7a
 8009c28:	d02f      	beq.n	8009c8a <cblas_ssyrk+0x292>
        C[i * ldc + j] += alpha * temp;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 8009c2a:	4a72      	ldr	r2, [pc, #456]	; (8009df4 <cblas_ssyrk+0x3fc>)
 8009c2c:	4970      	ldr	r1, [pc, #448]	; (8009df0 <cblas_ssyrk+0x3f8>)
 8009c2e:	2000      	movs	r0, #0
 8009c30:	b005      	add	sp, #20
 8009c32:	ecbd 8b02 	vpop	{d8}
 8009c36:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009c3a:	f01d bf05 	b.w	8027a48 <cblas_xerbla>
    if (uplo == CblasUpper) {
 8009c3e:	2e79      	cmp	r6, #121	; 0x79
 8009c40:	f000 815c 	beq.w	8009efc <cblas_ssyrk+0x504>
      for (i = 0; i < N; i++) {
 8009c44:	2f00      	cmp	r7, #0
 8009c46:	dde9      	ble.n	8009c1c <cblas_ssyrk+0x224>
 8009c48:	9b01      	ldr	r3, [sp, #4]
 8009c4a:	f109 0a01 	add.w	sl, r9, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009c4e:	f04f 0c00 	mov.w	ip, #0
          C[ldc * i + j] = 0.0;
 8009c52:	2100      	movs	r1, #0
 8009c54:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
      for (i = 0; i < N; i++) {
 8009c58:	46e6      	mov	lr, ip
 8009c5a:	1d1a      	adds	r2, r3, #4
 8009c5c:	469b      	mov	fp, r3
 8009c5e:	eb0b 038c 	add.w	r3, fp, ip, lsl #2
          C[ldc * i + j] = 0.0;
 8009c62:	f843 1b04 	str.w	r1, [r3], #4
        for (j = 0; j <= i; j++) {
 8009c66:	429a      	cmp	r2, r3
 8009c68:	d1fb      	bne.n	8009c62 <cblas_ssyrk+0x26a>
      for (i = 0; i < N; i++) {
 8009c6a:	f10e 0e01 	add.w	lr, lr, #1
 8009c6e:	4577      	cmp	r7, lr
 8009c70:	44cc      	add	ip, r9
 8009c72:	4452      	add	r2, sl
 8009c74:	dcf3      	bgt.n	8009c5e <cblas_ssyrk+0x266>
  if (alpha == 0.0)
 8009c76:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009c7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009c7e:	d081      	beq.n	8009b84 <cblas_ssyrk+0x18c>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 8009c80:	2e79      	cmp	r6, #121	; 0x79
 8009c82:	f43f af43 	beq.w	8009b0c <cblas_ssyrk+0x114>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8009c86:	2e7a      	cmp	r6, #122	; 0x7a
 8009c88:	d1cf      	bne.n	8009c2a <cblas_ssyrk+0x232>
 8009c8a:	286f      	cmp	r0, #111	; 0x6f
 8009c8c:	f000 80f8 	beq.w	8009e80 <cblas_ssyrk+0x488>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 8009c90:	2870      	cmp	r0, #112	; 0x70
 8009c92:	d1ca      	bne.n	8009c2a <cblas_ssyrk+0x232>
    for (i = 0; i < N; i++) {
 8009c94:	2f00      	cmp	r7, #0
 8009c96:	f77f af75 	ble.w	8009b84 <cblas_ssyrk+0x18c>
 8009c9a:	2300      	movs	r3, #0
 8009c9c:	00ad      	lsls	r5, r5, #2
 8009c9e:	469b      	mov	fp, r3
 8009ca0:	469a      	mov	sl, r3
 8009ca2:	f04f 0e04 	mov.w	lr, #4
 8009ca6:	9a01      	ldr	r2, [sp, #4]
        BASE temp = 0.0;
 8009ca8:	2600      	movs	r6, #0
 8009caa:	eb02 0c8b 	add.w	ip, r2, fp, lsl #2
        for (k = 0; k < K; k++) {
 8009cae:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 8009cb0:	eddf 7a51 	vldr	s15, [pc, #324]	; 8009df8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 8009cb4:	dd0e      	ble.n	8009cd4 <cblas_ssyrk+0x2dc>
 8009cb6:	eba8 0203 	sub.w	r2, r8, r3
 8009cba:	2000      	movs	r0, #0
          temp += A[k * lda + i] * A[k * lda + j];
 8009cbc:	18d1      	adds	r1, r2, r3
 8009cbe:	4431      	add	r1, r6
 8009cc0:	edd2 6a00 	vldr	s13, [r2]
 8009cc4:	ed91 7a00 	vldr	s14, [r1]
        for (k = 0; k < K; k++) {
 8009cc8:	3001      	adds	r0, #1
 8009cca:	4284      	cmp	r4, r0
          temp += A[k * lda + i] * A[k * lda + j];
 8009ccc:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 8009cd0:	442a      	add	r2, r5
 8009cd2:	d1f3      	bne.n	8009cbc <cblas_ssyrk+0x2c4>
        C[i * ldc + j] += alpha * temp;
 8009cd4:	ed9c 7a00 	vldr	s14, [ip]
 8009cd8:	eea7 7a88 	vfma.f32	s14, s15, s16
 8009cdc:	3604      	adds	r6, #4
      for (j = 0; j <= i; j++) {
 8009cde:	45b6      	cmp	lr, r6
        C[i * ldc + j] += alpha * temp;
 8009ce0:	ecac 7a01 	vstmia	ip!, {s14}
      for (j = 0; j <= i; j++) {
 8009ce4:	d1e3      	bne.n	8009cae <cblas_ssyrk+0x2b6>
    for (i = 0; i < N; i++) {
 8009ce6:	f10a 0a01 	add.w	sl, sl, #1
 8009cea:	4557      	cmp	r7, sl
 8009cec:	44cb      	add	fp, r9
 8009cee:	f10e 0e04 	add.w	lr, lr, #4
 8009cf2:	f1a3 0304 	sub.w	r3, r3, #4
 8009cf6:	d1d6      	bne.n	8009ca6 <cblas_ssyrk+0x2ae>
 8009cf8:	e744      	b.n	8009b84 <cblas_ssyrk+0x18c>
  } else if (beta != 1.0) {
 8009cfa:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009cfe:	eef4 8a67 	vcmp.f32	s17, s15
 8009d02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d06:	f000 8094 	beq.w	8009e32 <cblas_ssyrk+0x43a>
      for (i = 0; i < N; i++) {
 8009d0a:	2f00      	cmp	r7, #0
      trans = CblasTrans;
 8009d0c:	bfc8      	it	gt
 8009d0e:	2070      	movgt	r0, #112	; 0x70
      for (i = 0; i < N; i++) {
 8009d10:	f77f af38 	ble.w	8009b84 <cblas_ssyrk+0x18c>
 8009d14:	f109 0c01 	add.w	ip, r9, #1
 8009d18:	9e01      	ldr	r6, [sp, #4]
 8009d1a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8009d1e:	2100      	movs	r1, #0
 8009d20:	4632      	mov	r2, r6
 8009d22:	460b      	mov	r3, r1
          C[ldc * i + j] *= beta;
 8009d24:	edd2 7a00 	vldr	s15, [r2]
        for (j = i; j < N; j++) {
 8009d28:	3301      	adds	r3, #1
          C[ldc * i + j] *= beta;
 8009d2a:	ee67 7aa8 	vmul.f32	s15, s15, s17
        for (j = i; j < N; j++) {
 8009d2e:	429f      	cmp	r7, r3
          C[ldc * i + j] *= beta;
 8009d30:	ece2 7a01 	vstmia	r2!, {s15}
        for (j = i; j < N; j++) {
 8009d34:	dcf6      	bgt.n	8009d24 <cblas_ssyrk+0x32c>
      for (i = 0; i < N; i++) {
 8009d36:	3101      	adds	r1, #1
 8009d38:	428f      	cmp	r7, r1
 8009d3a:	4466      	add	r6, ip
 8009d3c:	dcf0      	bgt.n	8009d20 <cblas_ssyrk+0x328>
 8009d3e:	e6e0      	b.n	8009b02 <cblas_ssyrk+0x10a>
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8009d40:	200b      	movs	r0, #11
 8009d42:	e6a4      	b.n	8009a8e <cblas_ssyrk+0x96>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 8009d44:	2b01      	cmp	r3, #1
 8009d46:	d965      	bls.n	8009e14 <cblas_ssyrk+0x41c>
  if (beta == 0.0) {
 8009d48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d4c:	d178      	bne.n	8009e40 <cblas_ssyrk+0x448>
      for (i = 0; i < N; i++) {
 8009d4e:	2f00      	cmp	r7, #0
 8009d50:	f340 8089 	ble.w	8009e66 <cblas_ssyrk+0x46e>
      trans = CblasTrans;
 8009d54:	2070      	movs	r0, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009d56:	267a      	movs	r6, #122	; 0x7a
 8009d58:	e776      	b.n	8009c48 <cblas_ssyrk+0x250>
  if (beta == 0.0) {
 8009d5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d5e:	d14d      	bne.n	8009dfc <cblas_ssyrk+0x404>
      for (i = 0; i < N; i++) {
 8009d60:	2f00      	cmp	r7, #0
      trans = CblasNoTrans;
 8009d62:	bfc8      	it	gt
 8009d64:	206f      	movgt	r0, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8009d66:	f73f aeb9 	bgt.w	8009adc <cblas_ssyrk+0xe4>
  if (alpha == 0.0)
 8009d6a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009d6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009d72:	f43f af07 	beq.w	8009b84 <cblas_ssyrk+0x18c>
    for (i = 0; i < N; i++) {
 8009d76:	2f00      	cmp	r7, #0
 8009d78:	f77f af04 	ble.w	8009b84 <cblas_ssyrk+0x18c>
 8009d7c:	f109 0901 	add.w	r9, r9, #1
 8009d80:	ea4f 0389 	mov.w	r3, r9, lsl #2
 8009d84:	f04f 0a00 	mov.w	sl, #0
 8009d88:	9302      	str	r3, [sp, #8]
 8009d8a:	00ab      	lsls	r3, r5, #2
 8009d8c:	f8dd b004 	ldr.w	fp, [sp, #4]
 8009d90:	9301      	str	r3, [sp, #4]
 8009d92:	46d1      	mov	r9, sl
 8009d94:	eb08 0184 	add.w	r1, r8, r4, lsl #2
 8009d98:	46c6      	mov	lr, r8
        BASE temp = 0.0;
 8009d9a:	46d4      	mov	ip, sl
 8009d9c:	465e      	mov	r6, fp
 8009d9e:	4648      	mov	r0, r9
        for (k = 0; k < K; k++) {
 8009da0:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 8009da2:	eddf 7a15 	vldr	s15, [pc, #84]	; 8009df8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 8009da6:	dd0a      	ble.n	8009dbe <cblas_ssyrk+0x3c6>
 8009da8:	eb08 028c 	add.w	r2, r8, ip, lsl #2
 8009dac:	4673      	mov	r3, lr
          temp += A[i * lda + k] * A[j * lda + k];
 8009dae:	ecf3 6a01 	vldmia	r3!, {s13}
 8009db2:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < K; k++) {
 8009db6:	4299      	cmp	r1, r3
          temp += A[i * lda + k] * A[j * lda + k];
 8009db8:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 8009dbc:	d1f7      	bne.n	8009dae <cblas_ssyrk+0x3b6>
        C[i * ldc + j] += alpha * temp;
 8009dbe:	ed96 7a00 	vldr	s14, [r6]
 8009dc2:	eea7 7a88 	vfma.f32	s14, s15, s16
      for (j = i; j < N; j++) {
 8009dc6:	3001      	adds	r0, #1
 8009dc8:	4287      	cmp	r7, r0
 8009dca:	44ac      	add	ip, r5
        C[i * ldc + j] += alpha * temp;
 8009dcc:	eca6 7a01 	vstmia	r6!, {s14}
      for (j = i; j < N; j++) {
 8009dd0:	dce6      	bgt.n	8009da0 <cblas_ssyrk+0x3a8>
    for (i = 0; i < N; i++) {
 8009dd2:	9b02      	ldr	r3, [sp, #8]
 8009dd4:	f109 0901 	add.w	r9, r9, #1
 8009dd8:	449b      	add	fp, r3
 8009dda:	9b01      	ldr	r3, [sp, #4]
 8009ddc:	454f      	cmp	r7, r9
 8009dde:	44aa      	add	sl, r5
 8009de0:	449e      	add	lr, r3
 8009de2:	4419      	add	r1, r3
 8009de4:	d1d9      	bne.n	8009d9a <cblas_ssyrk+0x3a2>
 8009de6:	e6cd      	b.n	8009b84 <cblas_ssyrk+0x18c>
 8009de8:	4622      	mov	r2, r4
 8009dea:	e641      	b.n	8009a70 <cblas_ssyrk+0x78>
 8009dec:	08030378 	.word	0x08030378
 8009df0:	08030660 	.word	0x08030660
 8009df4:	080305a8 	.word	0x080305a8
 8009df8:	00000000 	.word	0x00000000
  } else if (beta != 1.0) {
 8009dfc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009e00:	eef4 8a67 	vcmp.f32	s17, s15
 8009e04:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e08:	d0af      	beq.n	8009d6a <cblas_ssyrk+0x372>
      for (i = 0; i < N; i++) {
 8009e0a:	2f00      	cmp	r7, #0
      trans = CblasNoTrans;
 8009e0c:	bfc8      	it	gt
 8009e0e:	206f      	movgt	r0, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8009e10:	dc80      	bgt.n	8009d14 <cblas_ssyrk+0x31c>
 8009e12:	e7aa      	b.n	8009d6a <cblas_ssyrk+0x372>
  if (beta == 0.0) {
 8009e14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e18:	d01f      	beq.n	8009e5a <cblas_ssyrk+0x462>
  } else if (beta != 1.0) {
 8009e1a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009e1e:	eef4 8a67 	vcmp.f32	s17, s15
 8009e22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e26:	d025      	beq.n	8009e74 <cblas_ssyrk+0x47c>
      for (i = 0; i < N; i++) {
 8009e28:	2f00      	cmp	r7, #0
 8009e2a:	dd23      	ble.n	8009e74 <cblas_ssyrk+0x47c>
      trans = CblasNoTrans;
 8009e2c:	206f      	movs	r0, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009e2e:	267a      	movs	r6, #122	; 0x7a
 8009e30:	e6db      	b.n	8009bea <cblas_ssyrk+0x1f2>
  if (alpha == 0.0)
 8009e32:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009e36:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e3a:	f47f ae6d 	bne.w	8009b18 <cblas_ssyrk+0x120>
 8009e3e:	e6a1      	b.n	8009b84 <cblas_ssyrk+0x18c>
  } else if (beta != 1.0) {
 8009e40:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8009e44:	eef4 8a67 	vcmp.f32	s17, s15
 8009e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e4c:	d00b      	beq.n	8009e66 <cblas_ssyrk+0x46e>
      for (i = 0; i < N; i++) {
 8009e4e:	2f00      	cmp	r7, #0
 8009e50:	f77f ae98 	ble.w	8009b84 <cblas_ssyrk+0x18c>
      trans = CblasTrans;
 8009e54:	2070      	movs	r0, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009e56:	267a      	movs	r6, #122	; 0x7a
 8009e58:	e6c7      	b.n	8009bea <cblas_ssyrk+0x1f2>
      for (i = 0; i < N; i++) {
 8009e5a:	2f00      	cmp	r7, #0
 8009e5c:	f77f ae92 	ble.w	8009b84 <cblas_ssyrk+0x18c>
      trans = CblasNoTrans;
 8009e60:	206f      	movs	r0, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009e62:	267a      	movs	r6, #122	; 0x7a
 8009e64:	e6f0      	b.n	8009c48 <cblas_ssyrk+0x250>
  if (alpha == 0.0)
 8009e66:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009e6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e6e:	f47f af11 	bne.w	8009c94 <cblas_ssyrk+0x29c>
 8009e72:	e687      	b.n	8009b84 <cblas_ssyrk+0x18c>
 8009e74:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8009e78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009e7c:	f43f ae82 	beq.w	8009b84 <cblas_ssyrk+0x18c>
    for (i = 0; i < N; i++) {
 8009e80:	2f00      	cmp	r7, #0
 8009e82:	f77f ae7f 	ble.w	8009b84 <cblas_ssyrk+0x18c>
 8009e86:	f109 0301 	add.w	r3, r9, #1
 8009e8a:	009b      	lsls	r3, r3, #2
 8009e8c:	9302      	str	r3, [sp, #8]
 8009e8e:	9b01      	ldr	r3, [sp, #4]
 8009e90:	9703      	str	r7, [sp, #12]
 8009e92:	f04f 0a00 	mov.w	sl, #0
 8009e96:	f103 0c04 	add.w	ip, r3, #4
 8009e9a:	00ab      	lsls	r3, r5, #2
 8009e9c:	46d3      	mov	fp, sl
 8009e9e:	eb08 0184 	add.w	r1, r8, r4, lsl #2
 8009ea2:	46c6      	mov	lr, r8
 8009ea4:	461f      	mov	r7, r3
 8009ea6:	9b01      	ldr	r3, [sp, #4]
        BASE temp = 0.0;
 8009ea8:	2600      	movs	r6, #0
 8009eaa:	eb03 008a 	add.w	r0, r3, sl, lsl #2
        for (k = 0; k < K; k++) {
 8009eae:	2c00      	cmp	r4, #0
        BASE temp = 0.0;
 8009eb0:	ed5f 7a2f 	vldr	s15, [pc, #-188]	; 8009df8 <cblas_ssyrk+0x400>
        for (k = 0; k < K; k++) {
 8009eb4:	dd0a      	ble.n	8009ecc <cblas_ssyrk+0x4d4>
 8009eb6:	eb08 0286 	add.w	r2, r8, r6, lsl #2
 8009eba:	4673      	mov	r3, lr
          temp += A[i * lda + k] * A[j * lda + k];
 8009ebc:	ecf3 6a01 	vldmia	r3!, {s13}
 8009ec0:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < K; k++) {
 8009ec4:	4299      	cmp	r1, r3
          temp += A[i * lda + k] * A[j * lda + k];
 8009ec6:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < K; k++) {
 8009eca:	d1f7      	bne.n	8009ebc <cblas_ssyrk+0x4c4>
        C[i * ldc + j] += alpha * temp;
 8009ecc:	ed90 7a00 	vldr	s14, [r0]
 8009ed0:	eea7 7a88 	vfma.f32	s14, s15, s16
 8009ed4:	442e      	add	r6, r5
 8009ed6:	eca0 7a01 	vstmia	r0!, {s14}
      for (j = 0; j <= i; j++) {
 8009eda:	4584      	cmp	ip, r0
 8009edc:	d1e7      	bne.n	8009eae <cblas_ssyrk+0x4b6>
    for (i = 0; i < N; i++) {
 8009ede:	9b02      	ldr	r3, [sp, #8]
 8009ee0:	449c      	add	ip, r3
 8009ee2:	9b03      	ldr	r3, [sp, #12]
 8009ee4:	f10b 0b01 	add.w	fp, fp, #1
 8009ee8:	455b      	cmp	r3, fp
 8009eea:	44ca      	add	sl, r9
 8009eec:	44be      	add	lr, r7
 8009eee:	4439      	add	r1, r7
 8009ef0:	d1d9      	bne.n	8009ea6 <cblas_ssyrk+0x4ae>
 8009ef2:	e647      	b.n	8009b84 <cblas_ssyrk+0x18c>
      for (i = 0; i < N; i++) {
 8009ef4:	2f00      	cmp	r7, #0
 8009ef6:	f73f af0d 	bgt.w	8009d14 <cblas_ssyrk+0x31c>
 8009efa:	e602      	b.n	8009b02 <cblas_ssyrk+0x10a>
      for (i = 0; i < N; i++) {
 8009efc:	2f00      	cmp	r7, #0
 8009efe:	f73f aded 	bgt.w	8009adc <cblas_ssyrk+0xe4>
 8009f02:	e5fe      	b.n	8009b02 <cblas_ssyrk+0x10a>

08009f04 <cblas_strmm>:
cblas_strmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const float alpha, const float *A, const int lda, float *B,
             const int ldb)
{
 8009f04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009f08:	ed2d 8b02 	vpush	{d8}
 8009f0c:	b089      	sub	sp, #36	; 0x24
 8009f0e:	4699      	mov	r9, r3
 8009f10:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8009f12:	9301      	str	r3, [sp, #4]
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  int side, uplo, trans;

  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8009f14:	298d      	cmp	r1, #141	; 0x8d
 8009f16:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8009f18:	f89d 5050 	ldrb.w	r5, [sp, #80]	; 0x50
 8009f1c:	9300      	str	r3, [sp, #0]
 8009f1e:	e9dd 6415 	ldrd	r6, r4, [sp, #84]	; 0x54
 8009f22:	e9dd 7b18 	ldrd	r7, fp, [sp, #96]	; 0x60
 8009f26:	4688      	mov	r8, r1
 8009f28:	4692      	mov	sl, r2
 8009f2a:	eeb0 8a40 	vmov.f32	s16, s0
 8009f2e:	d069      	beq.n	800a004 <cblas_strmm+0x100>
 8009f30:	298e      	cmp	r1, #142	; 0x8e
 8009f32:	f000 81fe 	beq.w	800a332 <cblas_strmm+0x42e>
 8009f36:	46a4      	mov	ip, r4
 8009f38:	2302      	movs	r3, #2
 8009f3a:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 8009f3e:	2a01      	cmp	r2, #1
 8009f40:	f1a9 016f 	sub.w	r1, r9, #111	; 0x6f
 8009f44:	f105 027d 	add.w	r2, r5, #125	; 0x7d
 8009f48:	bf88      	it	hi
 8009f4a:	2303      	movhi	r3, #3
 8009f4c:	b2d2      	uxtb	r2, r2
 8009f4e:	2902      	cmp	r1, #2
 8009f50:	bf88      	it	hi
 8009f52:	2304      	movhi	r3, #4
 8009f54:	2a02      	cmp	r2, #2
 8009f56:	bf28      	it	cs
 8009f58:	2305      	movcs	r3, #5
 8009f5a:	2e00      	cmp	r6, #0
 8009f5c:	bfb8      	it	lt
 8009f5e:	2306      	movlt	r3, #6
 8009f60:	2c00      	cmp	r4, #0
 8009f62:	bfb8      	it	lt
 8009f64:	2307      	movlt	r3, #7
 8009f66:	f1bc 0f01 	cmp.w	ip, #1
 8009f6a:	bfb8      	it	lt
 8009f6c:	f04f 0c01 	movlt.w	ip, #1
 8009f70:	45bc      	cmp	ip, r7
 8009f72:	dd3b      	ble.n	8009fec <cblas_strmm+0xe8>
 8009f74:	2865      	cmp	r0, #101	; 0x65
 8009f76:	f000 80ab 	beq.w	800a0d0 <cblas_strmm+0x1cc>
 8009f7a:	2e01      	cmp	r6, #1
 8009f7c:	9a00      	ldr	r2, [sp, #0]
 8009f7e:	4633      	mov	r3, r6
 8009f80:	bfb8      	it	lt
 8009f82:	2301      	movlt	r3, #1
 8009f84:	4293      	cmp	r3, r2
 8009f86:	bfcc      	ite	gt
 8009f88:	230c      	movgt	r3, #12
 8009f8a:	230a      	movle	r3, #10
 8009f8c:	4abc      	ldr	r2, [pc, #752]	; (800a280 <cblas_strmm+0x37c>)
 8009f8e:	49bd      	ldr	r1, [pc, #756]	; (800a284 <cblas_strmm+0x380>)
 8009f90:	4618      	mov	r0, r3
 8009f92:	f01d fd59 	bl	8027a48 <cblas_xerbla>
    uplo = Uplo;
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
  } else {
    n1 = N;
    n2 = M;
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8009f96:	f1b8 0f8d 	cmp.w	r8, #141	; 0x8d
 8009f9a:	bf0c      	ite	eq
 8009f9c:	f04f 088e 	moveq.w	r8, #142	; 0x8e
 8009fa0:	f04f 088d 	movne.w	r8, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8009fa4:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 8009fa8:	bf0c      	ite	eq
 8009faa:	f04f 0a7a 	moveq.w	sl, #122	; 0x7a
 8009fae:	f04f 0a79 	movne.w	sl, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 8009fb2:	f1b9 0f71 	cmp.w	r9, #113	; 0x71
 8009fb6:	bf08      	it	eq
 8009fb8:	f04f 0970 	moveq.w	r9, #112	; 0x70
  }

  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8009fbc:	f1b8 0f8d 	cmp.w	r8, #141	; 0x8d
 8009fc0:	d028      	beq.n	800a014 <cblas_strmm+0x110>

        B[ldb * i + j] = alpha * temp;
      }
    }

  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8009fc2:	f1b8 0f8e 	cmp.w	r8, #142	; 0x8e
 8009fc6:	d107      	bne.n	8009fd8 <cblas_strmm+0xd4>
 8009fc8:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 8009fcc:	f000 809b 	beq.w	800a106 <cblas_strmm+0x202>

        B[ldb * i + j] = alpha * temp;
      }
    }

  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8009fd0:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 8009fd4:	f000 80e9 	beq.w	800a1aa <cblas_strmm+0x2a6>
        B[ldb * i + j] = alpha * temp;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 8009fd8:	4aab      	ldr	r2, [pc, #684]	; (800a288 <cblas_strmm+0x384>)
 8009fda:	49aa      	ldr	r1, [pc, #680]	; (800a284 <cblas_strmm+0x380>)
 8009fdc:	2000      	movs	r0, #0
#define BASE float
#include "source_trmm_r.h"
#undef BASE
}
 8009fde:	b009      	add	sp, #36	; 0x24
 8009fe0:	ecbd 8b02 	vpop	{d8}
 8009fe4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009fe8:	f01d bd2e 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8009fec:	2865      	cmp	r0, #101	; 0x65
 8009fee:	f000 813d 	beq.w	800a26c <cblas_strmm+0x368>
 8009ff2:	2e01      	cmp	r6, #1
 8009ff4:	9900      	ldr	r1, [sp, #0]
 8009ff6:	4632      	mov	r2, r6
 8009ff8:	bfb8      	it	lt
 8009ffa:	2201      	movlt	r2, #1
 8009ffc:	428a      	cmp	r2, r1
 8009ffe:	dd7e      	ble.n	800a0fe <cblas_strmm+0x1fa>
 800a000:	230c      	movs	r3, #12
 800a002:	e7c3      	b.n	8009f8c <cblas_strmm+0x88>
 800a004:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800a008:	2b01      	cmp	r3, #1
 800a00a:	bf94      	ite	ls
 800a00c:	2300      	movls	r3, #0
 800a00e:	2301      	movhi	r3, #1
 800a010:	46b4      	mov	ip, r6
 800a012:	e792      	b.n	8009f3a <cblas_strmm+0x36>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800a014:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a018:	f000 813a 	beq.w	800a290 <cblas_strmm+0x38c>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 800a01c:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a020:	d1da      	bne.n	8009fd8 <cblas_strmm+0xd4>
 800a022:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800a026:	f000 821f 	beq.w	800a468 <cblas_strmm+0x564>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 800a02a:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800a02e:	d1d3      	bne.n	8009fd8 <cblas_strmm+0xd4>
    for (i = 0; i < n1; i++) {
 800a030:	2c00      	cmp	r4, #0
 800a032:	f340 8116 	ble.w	800a262 <cblas_strmm+0x35e>
 800a036:	1c78      	adds	r0, r7, #1
 800a038:	9a00      	ldr	r2, [sp, #0]
 800a03a:	9202      	str	r2, [sp, #8]
 800a03c:	0083      	lsls	r3, r0, #2
 800a03e:	1f18      	subs	r0, r3, #4
 800a040:	9304      	str	r3, [sp, #16]
 800a042:	9b01      	ldr	r3, [sp, #4]
 800a044:	f8cd b014 	str.w	fp, [sp, #20]
 800a048:	0097      	lsls	r7, r2, #2
 800a04a:	2200      	movs	r2, #0
 800a04c:	eb03 0a00 	add.w	sl, r3, r0
 800a050:	9201      	str	r2, [sp, #4]
 800a052:	f04f 0801 	mov.w	r8, #1
 800a056:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800a058:	2e00      	cmp	r6, #0
 800a05a:	bfd8      	it	le
 800a05c:	f8cd 800c 	strle.w	r8, [sp, #12]
 800a060:	f340 8191 	ble.w	800a386 <cblas_strmm+0x482>
 800a064:	9b02      	ldr	r3, [sp, #8]
 800a066:	9a05      	ldr	r2, [sp, #20]
 800a068:	f8cd 800c 	str.w	r8, [sp, #12]
 800a06c:	4619      	mov	r1, r3
 800a06e:	9b01      	ldr	r3, [sp, #4]
 800a070:	eba1 0903 	sub.w	r9, r1, r3
 800a074:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800a078:	eb02 0c83 	add.w	ip, r2, r3, lsl #2
 800a07c:	f04f 0e01 	mov.w	lr, #1
        if (nonunit) {
 800a080:	2d83      	cmp	r5, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 800a082:	bf05      	ittet	eq
 800a084:	eddb 7a00 	vldreq	s15, [fp]
 800a088:	ed9c 7a00 	vldreq	s14, [ip]
          temp = B[i * ldb + j];
 800a08c:	eddc 7a00 	vldrne	s15, [ip]
          temp = A[i * lda + i] * B[i * ldb + j];
 800a090:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = i + 1; k < n1; k++) {
 800a094:	4544      	cmp	r4, r8
 800a096:	f340 8189 	ble.w	800a3ac <cblas_strmm+0x4a8>
 800a09a:	eb09 010c 	add.w	r1, r9, ip
 800a09e:	4652      	mov	r2, sl
 800a0a0:	4643      	mov	r3, r8
          temp += A[lda * k + i] * B[k * ldb + j];
 800a0a2:	edd2 6a00 	vldr	s13, [r2]
 800a0a6:	ed91 7a00 	vldr	s14, [r1]
        for (k = i + 1; k < n1; k++) {
 800a0aa:	3301      	adds	r3, #1
 800a0ac:	429c      	cmp	r4, r3
          temp += A[lda * k + i] * B[k * ldb + j];
 800a0ae:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = i + 1; k < n1; k++) {
 800a0b2:	4402      	add	r2, r0
 800a0b4:	4439      	add	r1, r7
 800a0b6:	d1f4      	bne.n	800a0a2 <cblas_strmm+0x19e>
        B[ldb * i + j] = alpha * temp;
 800a0b8:	ee68 7a27 	vmul.f32	s15, s16, s15
      for (j = 0; j < n2; j++) {
 800a0bc:	4576      	cmp	r6, lr
        B[ldb * i + j] = alpha * temp;
 800a0be:	edcc 7a00 	vstr	s15, [ip]
      for (j = 0; j < n2; j++) {
 800a0c2:	f340 8160 	ble.w	800a386 <cblas_strmm+0x482>
 800a0c6:	f10e 0e01 	add.w	lr, lr, #1
 800a0ca:	f10c 0c04 	add.w	ip, ip, #4
 800a0ce:	e7d7      	b.n	800a080 <cblas_strmm+0x17c>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800a0d0:	2c01      	cmp	r4, #1
 800a0d2:	9a00      	ldr	r2, [sp, #0]
 800a0d4:	4623      	mov	r3, r4
 800a0d6:	bfb8      	it	lt
 800a0d8:	2301      	movlt	r3, #1
 800a0da:	4293      	cmp	r3, r2
 800a0dc:	bfcc      	ite	gt
 800a0de:	230c      	movgt	r3, #12
 800a0e0:	230a      	movle	r3, #10
 800a0e2:	4a67      	ldr	r2, [pc, #412]	; (800a280 <cblas_strmm+0x37c>)
 800a0e4:	4967      	ldr	r1, [pc, #412]	; (800a284 <cblas_strmm+0x380>)
 800a0e6:	4618      	mov	r0, r3
 800a0e8:	f01d fcae 	bl	8027a48 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800a0ec:	f1b9 0f71 	cmp.w	r9, #113	; 0x71
 800a0f0:	4623      	mov	r3, r4
 800a0f2:	d101      	bne.n	800a0f8 <cblas_strmm+0x1f4>
 800a0f4:	f04f 0970 	mov.w	r9, #112	; 0x70
 800a0f8:	4634      	mov	r4, r6
 800a0fa:	461e      	mov	r6, r3
 800a0fc:	e75e      	b.n	8009fbc <cblas_strmm+0xb8>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800a0fe:	2b00      	cmp	r3, #0
 800a100:	f43f af49 	beq.w	8009f96 <cblas_strmm+0x92>
 800a104:	e742      	b.n	8009f8c <cblas_strmm+0x88>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800a106:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800a10a:	f000 8207 	beq.w	800a51c <cblas_strmm+0x618>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 800a10e:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800a112:	f47f af61 	bne.w	8009fd8 <cblas_strmm+0xd4>
    for (i = 0; i < n1; i++) {
 800a116:	2c00      	cmp	r4, #0
 800a118:	f340 80a3 	ble.w	800a262 <cblas_strmm+0x35e>
 800a11c:	00b1      	lsls	r1, r6, #2
 800a11e:	9107      	str	r1, [sp, #28]
 800a120:	9901      	ldr	r1, [sp, #4]
 800a122:	f8cd b00c 	str.w	fp, [sp, #12]
 800a126:	00b8      	lsls	r0, r7, #2
 800a128:	2300      	movs	r3, #0
 800a12a:	f107 0a01 	add.w	sl, r7, #1
 800a12e:	1d02      	adds	r2, r0, #4
 800a130:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 800a134:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800a138:	9302      	str	r3, [sp, #8]
 800a13a:	9106      	str	r1, [sp, #24]
 800a13c:	4691      	mov	r9, r2
 800a13e:	9405      	str	r4, [sp, #20]
 800a140:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800a142:	2e00      	cmp	r6, #0
 800a144:	f340 8115 	ble.w	800a372 <cblas_strmm+0x46e>
 800a148:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800a14c:	9304      	str	r3, [sp, #16]
 800a14e:	9b03      	ldr	r3, [sp, #12]
 800a150:	9906      	ldr	r1, [sp, #24]
 800a152:	eb03 048b 	add.w	r4, r3, fp, lsl #2
 800a156:	9b01      	ldr	r3, [sp, #4]
 800a158:	2700      	movs	r7, #0
 800a15a:	f103 0c04 	add.w	ip, r3, #4
 800a15e:	4698      	mov	r8, r3
        if (nonunit) {
 800a160:	2d83      	cmp	r5, #131	; 0x83
          temp = A[j * lda + j] * B[i * ldb + j];
 800a162:	bf06      	itte	eq
 800a164:	edd8 7a00 	vldreq	s15, [r8]
 800a168:	ed94 7a00 	vldreq	s14, [r4]
          temp = B[i * ldb + j];
 800a16c:	edd4 7a00 	vldrne	s15, [r4]
        for (k = j + 1; k < n2; k++) {
 800a170:	f107 0701 	add.w	r7, r7, #1
          temp = A[j * lda + j] * B[i * ldb + j];
 800a174:	bf08      	it	eq
 800a176:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = j + 1; k < n2; k++) {
 800a17a:	42be      	cmp	r6, r7
 800a17c:	f000 80f0 	beq.w	800a360 <cblas_strmm+0x45c>
 800a180:	f104 0e04 	add.w	lr, r4, #4
 800a184:	4672      	mov	r2, lr
 800a186:	4663      	mov	r3, ip
          temp += A[lda * j + k] * B[i * ldb + k];
 800a188:	ecf3 6a01 	vldmia	r3!, {s13}
 800a18c:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = j + 1; k < n2; k++) {
 800a190:	4299      	cmp	r1, r3
          temp += A[lda * j + k] * B[i * ldb + k];
 800a192:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = j + 1; k < n2; k++) {
 800a196:	d1f7      	bne.n	800a188 <cblas_strmm+0x284>
        B[ldb * i + j] = alpha * temp;
 800a198:	ee68 7a27 	vmul.f32	s15, s16, s15
 800a19c:	44d4      	add	ip, sl
 800a19e:	edc4 7a00 	vstr	s15, [r4]
      for (j = 0; j < n2; j++) {
 800a1a2:	4401      	add	r1, r0
 800a1a4:	44c8      	add	r8, r9
        B[ldb * i + j] = alpha * temp;
 800a1a6:	4674      	mov	r4, lr
 800a1a8:	e7da      	b.n	800a160 <cblas_strmm+0x25c>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800a1aa:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800a1ae:	f000 8216 	beq.w	800a5de <cblas_strmm+0x6da>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 800a1b2:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800a1b6:	f47f af0f 	bne.w	8009fd8 <cblas_strmm+0xd4>
    for (i = 0; i < n1; i++) {
 800a1ba:	2c00      	cmp	r4, #0
 800a1bc:	dd51      	ble.n	800a262 <cblas_strmm+0x35e>
 800a1be:	9b01      	ldr	r3, [sp, #4]
 800a1c0:	9800      	ldr	r0, [sp, #0]
 800a1c2:	1e72      	subs	r2, r6, #1
 800a1c4:	1c79      	adds	r1, r7, #1
 800a1c6:	fb07 6e02 	mla	lr, r7, r2, r6
 800a1ca:	0089      	lsls	r1, r1, #2
 800a1cc:	f1a3 0c04 	sub.w	ip, r3, #4
 800a1d0:	ebc7 7a87 	rsb	sl, r7, r7, lsl #30
 800a1d4:	43fb      	mvns	r3, r7
 800a1d6:	9f01      	ldr	r7, [sp, #4]
 800a1d8:	f1a1 0904 	sub.w	r9, r1, #4
 800a1dc:	0080      	lsls	r0, r0, #2
 800a1de:	9000      	str	r0, [sp, #0]
 800a1e0:	fb02 7009 	mla	r0, r2, r9, r7
 800a1e4:	fb02 7201 	mla	r2, r2, r1, r7
 800a1e8:	9201      	str	r2, [sp, #4]
 800a1ea:	ea4f 0983 	mov.w	r9, r3, lsl #2
 800a1ee:	eb0c 028e 	add.w	r2, ip, lr, lsl #2
 800a1f2:	00b3      	lsls	r3, r6, #2
 800a1f4:	46d8      	mov	r8, fp
 800a1f6:	9002      	str	r0, [sp, #8]
 800a1f8:	9203      	str	r2, [sp, #12]
 800a1fa:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800a1fe:	9304      	str	r3, [sp, #16]
 800a200:	f04f 0b00 	mov.w	fp, #0
      for (j = n2; j > 0 && j--;) {
 800a204:	2e00      	cmp	r6, #0
 800a206:	dd26      	ble.n	800a256 <cblas_strmm+0x352>
 800a208:	9b04      	ldr	r3, [sp, #16]
 800a20a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800a20e:	e9dd c102 	ldrd	ip, r1, [sp, #8]
 800a212:	eb08 0003 	add.w	r0, r8, r3
 800a216:	4637      	mov	r7, r6
        for (k = 0; k < j; k++) {
 800a218:	3f01      	subs	r7, #1
        BASE temp = 0.0;
 800a21a:	eddf 7a1c 	vldr	s15, [pc, #112]	; 800a28c <cblas_strmm+0x388>
        for (k = 0; k < j; k++) {
 800a21e:	d009      	beq.n	800a234 <cblas_strmm+0x330>
 800a220:	4642      	mov	r2, r8
 800a222:	4663      	mov	r3, ip
          temp += A[lda * j + k] * B[i * ldb + k];
 800a224:	ecf3 6a01 	vldmia	r3!, {s13}
 800a228:	ecb2 7a01 	vldmia	r2!, {s14}
        for (k = 0; k < j; k++) {
 800a22c:	428b      	cmp	r3, r1
          temp += A[lda * j + k] * B[i * ldb + k];
 800a22e:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < j; k++) {
 800a232:	d1f7      	bne.n	800a224 <cblas_strmm+0x320>
        if (nonunit) {
 800a234:	2d83      	cmp	r5, #131	; 0x83
 800a236:	f000 8084 	beq.w	800a342 <cblas_strmm+0x43e>
          temp += B[i * ldb + j];
 800a23a:	ed10 7a01 	vldr	s14, [r0, #-4]
 800a23e:	ee77 7a87 	vadd.f32	s15, s15, s14
 800a242:	3804      	subs	r0, #4
        B[ldb * i + j] = alpha * temp;
 800a244:	ee67 7a88 	vmul.f32	s15, s15, s16
 800a248:	44ce      	add	lr, r9
 800a24a:	edc0 7a00 	vstr	s15, [r0]
      for (j = n2; j > 0 && j--;) {
 800a24e:	44d4      	add	ip, sl
 800a250:	4449      	add	r1, r9
 800a252:	2f00      	cmp	r7, #0
 800a254:	d1e0      	bne.n	800a218 <cblas_strmm+0x314>
    for (i = 0; i < n1; i++) {
 800a256:	9b00      	ldr	r3, [sp, #0]
 800a258:	f10b 0b01 	add.w	fp, fp, #1
 800a25c:	455c      	cmp	r4, fp
 800a25e:	4498      	add	r8, r3
 800a260:	d1d0      	bne.n	800a204 <cblas_strmm+0x300>
 800a262:	b009      	add	sp, #36	; 0x24
 800a264:	ecbd 8b02 	vpop	{d8}
 800a268:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800a26c:	2c01      	cmp	r4, #1
 800a26e:	9900      	ldr	r1, [sp, #0]
 800a270:	4622      	mov	r2, r4
 800a272:	bfb8      	it	lt
 800a274:	2201      	movlt	r2, #1
 800a276:	428a      	cmp	r2, r1
 800a278:	dd57      	ble.n	800a32a <cblas_strmm+0x426>
 800a27a:	230c      	movs	r3, #12
 800a27c:	e731      	b.n	800a0e2 <cblas_strmm+0x1de>
 800a27e:	bf00      	nop
 800a280:	08030378 	.word	0x08030378
 800a284:	08030670 	.word	0x08030670
 800a288:	080305a8 	.word	0x080305a8
 800a28c:	00000000 	.word	0x00000000
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800a290:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 800a294:	f000 8092 	beq.w	800a3bc <cblas_strmm+0x4b8>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 800a298:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 800a29c:	f47f ae9c 	bne.w	8009fd8 <cblas_strmm+0xd4>
    for (i = n1; i > 0 && i--;) {
 800a2a0:	2c00      	cmp	r4, #0
 800a2a2:	ddde      	ble.n	800a262 <cblas_strmm+0x35e>
 800a2a4:	43f8      	mvns	r0, r7
 800a2a6:	9a00      	ldr	r2, [sp, #0]
 800a2a8:	0080      	lsls	r0, r0, #2
 800a2aa:	1c7b      	adds	r3, r7, #1
 800a2ac:	9000      	str	r0, [sp, #0]
 800a2ae:	9801      	ldr	r0, [sp, #4]
 800a2b0:	009b      	lsls	r3, r3, #2
 800a2b2:	1e61      	subs	r1, r4, #1
 800a2b4:	ea4f 0c82 	mov.w	ip, r2, lsl #2
 800a2b8:	ebc2 7282 	rsb	r2, r2, r2, lsl #30
 800a2bc:	fb01 0903 	mla	r9, r1, r3, r0
 800a2c0:	1f1f      	subs	r7, r3, #4
 800a2c2:	0093      	lsls	r3, r2, #2
 800a2c4:	eb00 0484 	add.w	r4, r0, r4, lsl #2
 800a2c8:	9301      	str	r3, [sp, #4]
 800a2ca:	fb01 ba0c 	mla	sl, r1, ip, fp
      for (j = 0; j < n2; j++) {
 800a2ce:	2e00      	cmp	r6, #0
 800a2d0:	dd22      	ble.n	800a318 <cblas_strmm+0x414>
 800a2d2:	46d0      	mov	r8, sl
 800a2d4:	f04f 0e00 	mov.w	lr, #0
        BASE temp = 0.0;
 800a2d8:	ed5f 7a14 	vldr	s15, [pc, #-80]	; 800a28c <cblas_strmm+0x388>
        for (k = 0; k < i; k++) {
 800a2dc:	b171      	cbz	r1, 800a2fc <cblas_strmm+0x3f8>
 800a2de:	eb0b 008e 	add.w	r0, fp, lr, lsl #2
 800a2e2:	4622      	mov	r2, r4
 800a2e4:	2300      	movs	r3, #0
          temp += A[lda * k + i] * B[k * ldb + j];
 800a2e6:	ed52 6a01 	vldr	s13, [r2, #-4]
 800a2ea:	ed90 7a00 	vldr	s14, [r0]
        for (k = 0; k < i; k++) {
 800a2ee:	3301      	adds	r3, #1
 800a2f0:	4299      	cmp	r1, r3
          temp += A[lda * k + i] * B[k * ldb + j];
 800a2f2:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < i; k++) {
 800a2f6:	443a      	add	r2, r7
 800a2f8:	4460      	add	r0, ip
 800a2fa:	d1f4      	bne.n	800a2e6 <cblas_strmm+0x3e2>
        if (nonunit) {
 800a2fc:	2d83      	cmp	r5, #131	; 0x83
 800a2fe:	d028      	beq.n	800a352 <cblas_strmm+0x44e>
          temp += B[i * ldb + j];
 800a300:	ed98 7a00 	vldr	s14, [r8]
 800a304:	ee77 7a87 	vadd.f32	s15, s15, s14
        B[ldb * i + j] = alpha * temp;
 800a308:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800a30c:	f10e 0e01 	add.w	lr, lr, #1
 800a310:	4576      	cmp	r6, lr
        B[ldb * i + j] = alpha * temp;
 800a312:	ece8 7a01 	vstmia	r8!, {s15}
      for (j = 0; j < n2; j++) {
 800a316:	d1df      	bne.n	800a2d8 <cblas_strmm+0x3d4>
    for (i = n1; i > 0 && i--;) {
 800a318:	9b00      	ldr	r3, [sp, #0]
 800a31a:	4499      	add	r9, r3
 800a31c:	9b01      	ldr	r3, [sp, #4]
 800a31e:	3c04      	subs	r4, #4
 800a320:	449a      	add	sl, r3
 800a322:	2900      	cmp	r1, #0
 800a324:	d09d      	beq.n	800a262 <cblas_strmm+0x35e>
 800a326:	3901      	subs	r1, #1
 800a328:	e7d1      	b.n	800a2ce <cblas_strmm+0x3ca>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	f43f aede 	beq.w	800a0ec <cblas_strmm+0x1e8>
 800a330:	e6d7      	b.n	800a0e2 <cblas_strmm+0x1de>
 800a332:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800a336:	2b01      	cmp	r3, #1
 800a338:	bf94      	ite	ls
 800a33a:	2300      	movls	r3, #0
 800a33c:	2301      	movhi	r3, #1
 800a33e:	46a4      	mov	ip, r4
 800a340:	e5fb      	b.n	8009f3a <cblas_strmm+0x36>
          temp += A[j * lda + j] * B[i * ldb + j];
 800a342:	ed10 7a01 	vldr	s14, [r0, #-4]
 800a346:	edde 6a00 	vldr	s13, [lr]
 800a34a:	3804      	subs	r0, #4
 800a34c:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a350:	e778      	b.n	800a244 <cblas_strmm+0x340>
          temp += A[i * lda + i] * B[i * ldb + j];
 800a352:	edd9 6a00 	vldr	s13, [r9]
 800a356:	ed98 7a00 	vldr	s14, [r8]
 800a35a:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a35e:	e7d3      	b.n	800a308 <cblas_strmm+0x404>
        B[ldb * i + j] = alpha * temp;
 800a360:	9a07      	ldr	r2, [sp, #28]
 800a362:	9b04      	ldr	r3, [sp, #16]
 800a364:	4413      	add	r3, r2
 800a366:	9a03      	ldr	r2, [sp, #12]
 800a368:	ee67 7a88 	vmul.f32	s15, s15, s16
 800a36c:	4413      	add	r3, r2
 800a36e:	ed43 7a01 	vstr	s15, [r3, #-4]
    for (i = 0; i < n1; i++) {
 800a372:	9a00      	ldr	r2, [sp, #0]
 800a374:	9b02      	ldr	r3, [sp, #8]
 800a376:	4493      	add	fp, r2
 800a378:	9a05      	ldr	r2, [sp, #20]
 800a37a:	3301      	adds	r3, #1
 800a37c:	429a      	cmp	r2, r3
 800a37e:	9302      	str	r3, [sp, #8]
 800a380:	f47f aedf 	bne.w	800a142 <cblas_strmm+0x23e>
 800a384:	e76d      	b.n	800a262 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800a386:	9b04      	ldr	r3, [sp, #16]
 800a388:	9902      	ldr	r1, [sp, #8]
 800a38a:	9a00      	ldr	r2, [sp, #0]
 800a38c:	468c      	mov	ip, r1
 800a38e:	449a      	add	sl, r3
 800a390:	9901      	ldr	r1, [sp, #4]
 800a392:	449b      	add	fp, r3
 800a394:	9b03      	ldr	r3, [sp, #12]
 800a396:	4494      	add	ip, r2
 800a398:	4411      	add	r1, r2
 800a39a:	429c      	cmp	r4, r3
 800a39c:	f108 0801 	add.w	r8, r8, #1
 800a3a0:	f8cd c008 	str.w	ip, [sp, #8]
 800a3a4:	9101      	str	r1, [sp, #4]
 800a3a6:	f73f ae57 	bgt.w	800a058 <cblas_strmm+0x154>
 800a3aa:	e75a      	b.n	800a262 <cblas_strmm+0x35e>
        B[ldb * i + j] = alpha * temp;
 800a3ac:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800a3b0:	4576      	cmp	r6, lr
        B[ldb * i + j] = alpha * temp;
 800a3b2:	edcc 7a00 	vstr	s15, [ip]
      for (j = 0; j < n2; j++) {
 800a3b6:	f73f ae86 	bgt.w	800a0c6 <cblas_strmm+0x1c2>
 800a3ba:	e752      	b.n	800a262 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800a3bc:	2c00      	cmp	r4, #0
 800a3be:	f77f af50 	ble.w	800a262 <cblas_strmm+0x35e>
 800a3c2:	1c78      	adds	r0, r7, #1
 800a3c4:	0083      	lsls	r3, r0, #2
 800a3c6:	9303      	str	r3, [sp, #12]
 800a3c8:	3b04      	subs	r3, #4
 800a3ca:	9302      	str	r3, [sp, #8]
 800a3cc:	9b01      	ldr	r3, [sp, #4]
 800a3ce:	f103 0e04 	add.w	lr, r3, #4
 800a3d2:	eb03 0184 	add.w	r1, r3, r4, lsl #2
 800a3d6:	9b00      	ldr	r3, [sp, #0]
 800a3d8:	9301      	str	r3, [sp, #4]
 800a3da:	0098      	lsls	r0, r3, #2
 800a3dc:	f04f 0a00 	mov.w	sl, #0
 800a3e0:	f04f 0801 	mov.w	r8, #1
      for (j = 0; j < n2; j++) {
 800a3e4:	2e00      	cmp	r6, #0
 800a3e6:	f340 80e9 	ble.w	800a5bc <cblas_strmm+0x6b8>
 800a3ea:	9b01      	ldr	r3, [sp, #4]
 800a3ec:	eba3 090a 	sub.w	r9, r3, sl
 800a3f0:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800a3f4:	eb0b 078a 	add.w	r7, fp, sl, lsl #2
 800a3f8:	f04f 0c01 	mov.w	ip, #1
        if (nonunit) {
 800a3fc:	2d83      	cmp	r5, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 800a3fe:	bf05      	ittet	eq
 800a400:	ed5e 7a01 	vldreq	s15, [lr, #-4]
 800a404:	ed97 7a00 	vldreq	s14, [r7]
          temp = B[i * ldb + j];
 800a408:	edd7 7a00 	vldrne	s15, [r7]
          temp = A[i * lda + i] * B[i * ldb + j];
 800a40c:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = i + 1; k < n1; k++) {
 800a410:	4544      	cmp	r4, r8
 800a412:	dd15      	ble.n	800a440 <cblas_strmm+0x53c>
 800a414:	eb09 0207 	add.w	r2, r9, r7
 800a418:	4673      	mov	r3, lr
          temp += A[lda * i + k] * B[k * ldb + j];
 800a41a:	ecf3 6a01 	vldmia	r3!, {s13}
 800a41e:	ed92 7a00 	vldr	s14, [r2]
        for (k = i + 1; k < n1; k++) {
 800a422:	4299      	cmp	r1, r3
          temp += A[lda * i + k] * B[k * ldb + j];
 800a424:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = i + 1; k < n1; k++) {
 800a428:	4402      	add	r2, r0
 800a42a:	d1f6      	bne.n	800a41a <cblas_strmm+0x516>
        B[ldb * i + j] = alpha * temp;
 800a42c:	ee68 7a27 	vmul.f32	s15, s16, s15
      for (j = 0; j < n2; j++) {
 800a430:	4566      	cmp	r6, ip
        B[ldb * i + j] = alpha * temp;
 800a432:	edc7 7a00 	vstr	s15, [r7]
      for (j = 0; j < n2; j++) {
 800a436:	dd0a      	ble.n	800a44e <cblas_strmm+0x54a>
 800a438:	f10c 0c01 	add.w	ip, ip, #1
 800a43c:	3704      	adds	r7, #4
 800a43e:	e7dd      	b.n	800a3fc <cblas_strmm+0x4f8>
        B[ldb * i + j] = alpha * temp;
 800a440:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800a444:	45b4      	cmp	ip, r6
        B[ldb * i + j] = alpha * temp;
 800a446:	edc7 7a00 	vstr	s15, [r7]
      for (j = 0; j < n2; j++) {
 800a44a:	dbf5      	blt.n	800a438 <cblas_strmm+0x534>
 800a44c:	e709      	b.n	800a262 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800a44e:	9b03      	ldr	r3, [sp, #12]
 800a450:	9a01      	ldr	r2, [sp, #4]
 800a452:	449e      	add	lr, r3
 800a454:	9b02      	ldr	r3, [sp, #8]
 800a456:	4419      	add	r1, r3
 800a458:	9b00      	ldr	r3, [sp, #0]
 800a45a:	4617      	mov	r7, r2
 800a45c:	441f      	add	r7, r3
 800a45e:	f108 0801 	add.w	r8, r8, #1
 800a462:	9701      	str	r7, [sp, #4]
 800a464:	449a      	add	sl, r3
 800a466:	e7bd      	b.n	800a3e4 <cblas_strmm+0x4e0>
    for (i = n1; i > 0 && i--;) {
 800a468:	2c00      	cmp	r4, #0
 800a46a:	f77f aefa 	ble.w	800a262 <cblas_strmm+0x35e>
 800a46e:	1e61      	subs	r1, r4, #1
 800a470:	1c7a      	adds	r2, r7, #1
 800a472:	fb07 4301 	mla	r3, r7, r1, r4
 800a476:	0092      	lsls	r2, r2, #2
 800a478:	ea6f 0807 	mvn.w	r8, r7
 800a47c:	ebc7 7a87 	rsb	sl, r7, r7, lsl #30
 800a480:	9f01      	ldr	r7, [sp, #4]
 800a482:	9800      	ldr	r0, [sp, #0]
 800a484:	9302      	str	r3, [sp, #8]
 800a486:	f1a2 0e04 	sub.w	lr, r2, #4
 800a48a:	9b01      	ldr	r3, [sp, #4]
 800a48c:	fb01 7e0e 	mla	lr, r1, lr, r7
 800a490:	fb01 7702 	mla	r7, r1, r2, r7
 800a494:	9a02      	ldr	r2, [sp, #8]
 800a496:	3b04      	subs	r3, #4
 800a498:	ebc0 7980 	rsb	r9, r0, r0, lsl #30
 800a49c:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 800a4a0:	ea4f 0389 	mov.w	r3, r9, lsl #2
 800a4a4:	ea4f 0c80 	mov.w	ip, r0, lsl #2
 800a4a8:	9300      	str	r3, [sp, #0]
 800a4aa:	ea4f 038a 	mov.w	r3, sl, lsl #2
 800a4ae:	fb01 b90c 	mla	r9, r1, ip, fp
 800a4b2:	ea4f 0888 	mov.w	r8, r8, lsl #2
 800a4b6:	9301      	str	r3, [sp, #4]
      for (j = 0; j < n2; j++) {
 800a4b8:	2e00      	cmp	r6, #0
 800a4ba:	dd1d      	ble.n	800a4f8 <cblas_strmm+0x5f4>
 800a4bc:	46ca      	mov	sl, r9
 800a4be:	2000      	movs	r0, #0
        BASE temp = 0.0;
 800a4c0:	ed5f 7a8e 	vldr	s15, [pc, #-568]	; 800a28c <cblas_strmm+0x388>
        for (k = 0; k < i; k++) {
 800a4c4:	b159      	cbz	r1, 800a4de <cblas_strmm+0x5da>
 800a4c6:	eb0b 0280 	add.w	r2, fp, r0, lsl #2
 800a4ca:	4673      	mov	r3, lr
          temp += A[lda * i + k] * B[k * ldb + j];
 800a4cc:	ecf3 6a01 	vldmia	r3!, {s13}
 800a4d0:	ed92 7a00 	vldr	s14, [r2]
        for (k = 0; k < i; k++) {
 800a4d4:	429c      	cmp	r4, r3
          temp += A[lda * i + k] * B[k * ldb + j];
 800a4d6:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < i; k++) {
 800a4da:	4462      	add	r2, ip
 800a4dc:	d1f6      	bne.n	800a4cc <cblas_strmm+0x5c8>
        if (nonunit) {
 800a4de:	2d83      	cmp	r5, #131	; 0x83
 800a4e0:	d015      	beq.n	800a50e <cblas_strmm+0x60a>
          temp += B[i * ldb + j];
 800a4e2:	ed9a 7a00 	vldr	s14, [sl]
 800a4e6:	ee77 7a87 	vadd.f32	s15, s15, s14
        B[ldb * i + j] = alpha * temp;
 800a4ea:	ee67 7a88 	vmul.f32	s15, s15, s16
      for (j = 0; j < n2; j++) {
 800a4ee:	3001      	adds	r0, #1
 800a4f0:	4286      	cmp	r6, r0
        B[ldb * i + j] = alpha * temp;
 800a4f2:	ecea 7a01 	vstmia	sl!, {s15}
      for (j = 0; j < n2; j++) {
 800a4f6:	d1e3      	bne.n	800a4c0 <cblas_strmm+0x5bc>
    for (i = n1; i > 0 && i--;) {
 800a4f8:	9b00      	ldr	r3, [sp, #0]
 800a4fa:	4499      	add	r9, r3
 800a4fc:	9b01      	ldr	r3, [sp, #4]
 800a4fe:	4447      	add	r7, r8
 800a500:	449e      	add	lr, r3
 800a502:	4444      	add	r4, r8
 800a504:	2900      	cmp	r1, #0
 800a506:	f43f aeac 	beq.w	800a262 <cblas_strmm+0x35e>
 800a50a:	3901      	subs	r1, #1
 800a50c:	e7d4      	b.n	800a4b8 <cblas_strmm+0x5b4>
          temp += A[i * lda + i] * B[i * ldb + j];
 800a50e:	edd7 6a00 	vldr	s13, [r7]
 800a512:	ed9a 7a00 	vldr	s14, [sl]
 800a516:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a51a:	e7e6      	b.n	800a4ea <cblas_strmm+0x5e6>
    for (i = 0; i < n1; i++) {
 800a51c:	2c00      	cmp	r4, #0
 800a51e:	f77f aea0 	ble.w	800a262 <cblas_strmm+0x35e>
 800a522:	43f8      	mvns	r0, r7
 800a524:	1c7b      	adds	r3, r7, #1
 800a526:	9f00      	ldr	r7, [sp, #0]
 800a528:	ea4f 0987 	mov.w	r9, r7, lsl #2
 800a52c:	9f01      	ldr	r7, [sp, #4]
 800a52e:	009b      	lsls	r3, r3, #2
 800a530:	1e71      	subs	r1, r6, #1
 800a532:	00b2      	lsls	r2, r6, #2
 800a534:	46de      	mov	lr, fp
 800a536:	fb03 7101 	mla	r1, r3, r1, r7
 800a53a:	f1a2 0b04 	sub.w	fp, r2, #4
 800a53e:	ea4f 0880 	mov.w	r8, r0, lsl #2
 800a542:	f8cd b004 	str.w	fp, [sp, #4]
 800a546:	9100      	str	r1, [sp, #0]
 800a548:	1f18      	subs	r0, r3, #4
 800a54a:	f04f 0a00 	mov.w	sl, #0
 800a54e:	46bb      	mov	fp, r7
      for (j = n2; j > 0 && j--;) {
 800a550:	2e00      	cmp	r6, #0
 800a552:	dd26      	ble.n	800a5a2 <cblas_strmm+0x69e>
 800a554:	9b01      	ldr	r3, [sp, #4]
 800a556:	f8dd c000 	ldr.w	ip, [sp]
 800a55a:	eb03 010e 	add.w	r1, r3, lr
 800a55e:	4633      	mov	r3, r6
        for (k = 0; k < j; k++) {
 800a560:	1e5a      	subs	r2, r3, #1
 800a562:	2a00      	cmp	r2, #0
        BASE temp = 0.0;
 800a564:	ed5f 7ab7 	vldr	s15, [pc, #-732]	; 800a28c <cblas_strmm+0x388>
        for (k = 0; k < j; k++) {
 800a568:	dd0b      	ble.n	800a582 <cblas_strmm+0x67e>
 800a56a:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 800a56e:	4677      	mov	r7, lr
          temp += A[lda * k + j] * B[i * ldb + k];
 800a570:	ecb7 7a01 	vldmia	r7!, {s14}
 800a574:	ed53 6a01 	vldr	s13, [r3, #-4]
        for (k = 0; k < j; k++) {
 800a578:	428f      	cmp	r7, r1
          temp += A[lda * k + j] * B[i * ldb + k];
 800a57a:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = 0; k < j; k++) {
 800a57e:	4403      	add	r3, r0
 800a580:	d1f6      	bne.n	800a570 <cblas_strmm+0x66c>
        if (nonunit) {
 800a582:	2d83      	cmp	r5, #131	; 0x83
 800a584:	d013      	beq.n	800a5ae <cblas_strmm+0x6aa>
          temp += B[i * ldb + j];
 800a586:	ed91 7a00 	vldr	s14, [r1]
 800a58a:	ee77 7a87 	vadd.f32	s15, s15, s14
        B[ldb * i + j] = alpha * temp;
 800a58e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800a592:	460b      	mov	r3, r1
 800a594:	edc3 7a00 	vstr	s15, [r3]
      for (j = n2; j > 0 && j--;) {
 800a598:	44c4      	add	ip, r8
        B[ldb * i + j] = alpha * temp;
 800a59a:	3904      	subs	r1, #4
      for (j = n2; j > 0 && j--;) {
 800a59c:	4613      	mov	r3, r2
 800a59e:	2a00      	cmp	r2, #0
 800a5a0:	d1de      	bne.n	800a560 <cblas_strmm+0x65c>
    for (i = 0; i < n1; i++) {
 800a5a2:	f10a 0a01 	add.w	sl, sl, #1
 800a5a6:	4554      	cmp	r4, sl
 800a5a8:	44ce      	add	lr, r9
 800a5aa:	d1d1      	bne.n	800a550 <cblas_strmm+0x64c>
 800a5ac:	e659      	b.n	800a262 <cblas_strmm+0x35e>
          temp += A[j * lda + j] * B[i * ldb + j];
 800a5ae:	eddc 6a00 	vldr	s13, [ip]
 800a5b2:	ed91 7a00 	vldr	s14, [r1]
 800a5b6:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a5ba:	e7e8      	b.n	800a58e <cblas_strmm+0x68a>
    for (i = 0; i < n1; i++) {
 800a5bc:	9a03      	ldr	r2, [sp, #12]
 800a5be:	9f01      	ldr	r7, [sp, #4]
 800a5c0:	4496      	add	lr, r2
 800a5c2:	9a02      	ldr	r2, [sp, #8]
 800a5c4:	4411      	add	r1, r2
 800a5c6:	9a00      	ldr	r2, [sp, #0]
 800a5c8:	46bc      	mov	ip, r7
 800a5ca:	4494      	add	ip, r2
 800a5cc:	4544      	cmp	r4, r8
 800a5ce:	f8cd c004 	str.w	ip, [sp, #4]
 800a5d2:	4492      	add	sl, r2
 800a5d4:	f108 0801 	add.w	r8, r8, #1
 800a5d8:	f73f af04 	bgt.w	800a3e4 <cblas_strmm+0x4e0>
 800a5dc:	e641      	b.n	800a262 <cblas_strmm+0x35e>
    for (i = 0; i < n1; i++) {
 800a5de:	2c00      	cmp	r4, #0
 800a5e0:	f77f ae3f 	ble.w	800a262 <cblas_strmm+0x35e>
 800a5e4:	9a01      	ldr	r2, [sp, #4]
 800a5e6:	9900      	ldr	r1, [sp, #0]
 800a5e8:	f8cd b018 	str.w	fp, [sp, #24]
 800a5ec:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 800a5f0:	00b8      	lsls	r0, r7, #2
 800a5f2:	2300      	movs	r3, #0
 800a5f4:	0089      	lsls	r1, r1, #2
 800a5f6:	f107 0a01 	add.w	sl, r7, #1
 800a5fa:	9205      	str	r2, [sp, #20]
 800a5fc:	1d02      	adds	r2, r0, #4
 800a5fe:	9103      	str	r1, [sp, #12]
 800a600:	9302      	str	r3, [sp, #8]
 800a602:	eb0b 0186 	add.w	r1, fp, r6, lsl #2
 800a606:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800a60a:	4691      	mov	r9, r2
 800a60c:	9404      	str	r4, [sp, #16]
 800a60e:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800a610:	2e00      	cmp	r6, #0
 800a612:	dd30      	ble.n	800a676 <cblas_strmm+0x772>
 800a614:	9b06      	ldr	r3, [sp, #24]
 800a616:	9a02      	ldr	r2, [sp, #8]
 800a618:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800a61c:	f8dd c014 	ldr.w	ip, [sp, #20]
 800a620:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 800a624:	2700      	movs	r7, #0
        if (nonunit) {
 800a626:	2d83      	cmp	r5, #131	; 0x83
          temp = A[j * lda + j] * B[i * ldb + j];
 800a628:	bf06      	itte	eq
 800a62a:	edd8 7a00 	vldreq	s15, [r8]
 800a62e:	ed94 7a00 	vldreq	s14, [r4]
          temp = B[i * ldb + j];
 800a632:	edd4 7a00 	vldrne	s15, [r4]
        for (k = j + 1; k < n2; k++) {
 800a636:	f107 0701 	add.w	r7, r7, #1
          temp = A[j * lda + j] * B[i * ldb + j];
 800a63a:	bf08      	it	eq
 800a63c:	ee67 7a87 	vmuleq.f32	s15, s15, s14
        for (k = j + 1; k < n2; k++) {
 800a640:	42be      	cmp	r6, r7
 800a642:	d014      	beq.n	800a66e <cblas_strmm+0x76a>
 800a644:	f104 0e04 	add.w	lr, r4, #4
 800a648:	4672      	mov	r2, lr
 800a64a:	4663      	mov	r3, ip
          temp += A[lda * k + j] * B[i * ldb + k];
 800a64c:	ecb2 7a01 	vldmia	r2!, {s14}
 800a650:	edd3 6a00 	vldr	s13, [r3]
        for (k = j + 1; k < n2; k++) {
 800a654:	428a      	cmp	r2, r1
          temp += A[lda * k + j] * B[i * ldb + k];
 800a656:	eee6 7a87 	vfma.f32	s15, s13, s14
        for (k = j + 1; k < n2; k++) {
 800a65a:	4403      	add	r3, r0
 800a65c:	d1f6      	bne.n	800a64c <cblas_strmm+0x748>
        B[ldb * i + j] = alpha * temp;
 800a65e:	ee68 7a27 	vmul.f32	s15, s16, s15
 800a662:	44d4      	add	ip, sl
 800a664:	edc4 7a00 	vstr	s15, [r4]
      for (j = 0; j < n2; j++) {
 800a668:	44c8      	add	r8, r9
        B[ldb * i + j] = alpha * temp;
 800a66a:	4674      	mov	r4, lr
 800a66c:	e7db      	b.n	800a626 <cblas_strmm+0x722>
 800a66e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800a672:	ed41 7a01 	vstr	s15, [r1, #-4]
    for (i = 0; i < n1; i++) {
 800a676:	9b03      	ldr	r3, [sp, #12]
 800a678:	9a00      	ldr	r2, [sp, #0]
 800a67a:	4419      	add	r1, r3
 800a67c:	9b02      	ldr	r3, [sp, #8]
 800a67e:	4413      	add	r3, r2
 800a680:	9302      	str	r3, [sp, #8]
 800a682:	9b04      	ldr	r3, [sp, #16]
 800a684:	f10b 0b01 	add.w	fp, fp, #1
 800a688:	455b      	cmp	r3, fp
 800a68a:	d1c1      	bne.n	800a610 <cblas_strmm+0x70c>
 800a68c:	e5e9      	b.n	800a262 <cblas_strmm+0x35e>
 800a68e:	bf00      	nop

0800a690 <cblas_strmv>:
void
cblas_strmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const float *A, const int lda, float *X,
             const int incX)
{
 800a690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a694:	b083      	sub	sp, #12

{
  INDEX i, j;

  const int nonunit = (Diag == CblasNonUnit);
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 800a696:	2a71      	cmp	r2, #113	; 0x71
 800a698:	e9dd 570c 	ldrd	r5, r7, [sp, #48]	; 0x30
 800a69c:	e9dd b80e 	ldrd	fp, r8, [sp, #56]	; 0x38
 800a6a0:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800a6a2:	4681      	mov	r9, r0
 800a6a4:	468a      	mov	sl, r1
 800a6a6:	461e      	mov	r6, r3
 800a6a8:	f000 809d 	beq.w	800a7e6 <cblas_strmv+0x156>

  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800a6ac:	3979      	subs	r1, #121	; 0x79
 800a6ae:	2901      	cmp	r1, #1
 800a6b0:	4613      	mov	r3, r2
 800a6b2:	d92f      	bls.n	800a714 <cblas_strmv+0x84>
 800a6b4:	2002      	movs	r0, #2
 800a6b6:	3a6f      	subs	r2, #111	; 0x6f
 800a6b8:	2a02      	cmp	r2, #2
 800a6ba:	bf88      	it	hi
 800a6bc:	2003      	movhi	r0, #3
 800a6be:	f106 027d 	add.w	r2, r6, #125	; 0x7d
 800a6c2:	b2d2      	uxtb	r2, r2
 800a6c4:	2a01      	cmp	r2, #1
 800a6c6:	d933      	bls.n	800a730 <cblas_strmv+0xa0>
 800a6c8:	2d00      	cmp	r5, #0
 800a6ca:	db29      	blt.n	800a720 <cblas_strmv+0x90>
 800a6cc:	2d01      	cmp	r5, #1
 800a6ce:	462a      	mov	r2, r5
 800a6d0:	bfb8      	it	lt
 800a6d2:	2201      	movlt	r2, #1
 800a6d4:	455a      	cmp	r2, fp
 800a6d6:	f340 808d 	ble.w	800a7f4 <cblas_strmv+0x164>
 800a6da:	2c00      	cmp	r4, #0
 800a6dc:	bf0c      	ite	eq
 800a6de:	2009      	moveq	r0, #9
 800a6e0:	2007      	movne	r0, #7
 800a6e2:	4ad1      	ldr	r2, [pc, #836]	; (800aa28 <cblas_strmv+0x398>)
 800a6e4:	49d1      	ldr	r1, [pc, #836]	; (800aa2c <cblas_strmv+0x39c>)
 800a6e6:	9301      	str	r3, [sp, #4]
 800a6e8:	f01d f9ae 	bl	8027a48 <cblas_xerbla>
 800a6ec:	9b01      	ldr	r3, [sp, #4]

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800a6ee:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 800a6f2:	d02b      	beq.n	800a74c <cblas_strmv+0xbc>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800a6f4:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 800a6f8:	d104      	bne.n	800a704 <cblas_strmv+0x74>
 800a6fa:	2b70      	cmp	r3, #112	; 0x70
 800a6fc:	f000 80f5 	beq.w	800a8ea <cblas_strmv+0x25a>
        X[ix] += temp;
      }
      ix -= incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 800a700:	2b6f      	cmp	r3, #111	; 0x6f
 800a702:	d07c      	beq.n	800a7fe <cblas_strmv+0x16e>
        X[ix] += temp;
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 800a704:	4aca      	ldr	r2, [pc, #808]	; (800aa30 <cblas_strmv+0x3a0>)
 800a706:	49c9      	ldr	r1, [pc, #804]	; (800aa2c <cblas_strmv+0x39c>)
 800a708:	2000      	movs	r0, #0
#define BASE float
#include "source_trmv_r.h"
#undef BASE
}
 800a70a:	b003      	add	sp, #12
 800a70c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a710:	f01d b99a 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800a714:	3865      	subs	r0, #101	; 0x65
 800a716:	2801      	cmp	r0, #1
 800a718:	bf94      	ite	ls
 800a71a:	2000      	movls	r0, #0
 800a71c:	2001      	movhi	r0, #1
 800a71e:	e7ca      	b.n	800a6b6 <cblas_strmv+0x26>
 800a720:	f1bb 0f00 	cmp.w	fp, #0
 800a724:	ddd9      	ble.n	800a6da <cblas_strmv+0x4a>
 800a726:	2c00      	cmp	r4, #0
 800a728:	bf0c      	ite	eq
 800a72a:	2009      	moveq	r0, #9
 800a72c:	2005      	movne	r0, #5
 800a72e:	e7d8      	b.n	800a6e2 <cblas_strmv+0x52>
 800a730:	2d00      	cmp	r5, #0
 800a732:	dbf5      	blt.n	800a720 <cblas_strmv+0x90>
 800a734:	2d01      	cmp	r5, #1
 800a736:	462a      	mov	r2, r5
 800a738:	bfb8      	it	lt
 800a73a:	2201      	movlt	r2, #1
 800a73c:	455a      	cmp	r2, fp
 800a73e:	dccc      	bgt.n	800a6da <cblas_strmv+0x4a>
 800a740:	2c00      	cmp	r4, #0
 800a742:	f000 816f 	beq.w	800aa24 <cblas_strmv+0x394>
 800a746:	2800      	cmp	r0, #0
 800a748:	d0d1      	beq.n	800a6ee <cblas_strmv+0x5e>
 800a74a:	e7ca      	b.n	800a6e2 <cblas_strmv+0x52>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800a74c:	2b6f      	cmp	r3, #111	; 0x6f
 800a74e:	d071      	beq.n	800a834 <cblas_strmv+0x1a4>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 800a750:	2b70      	cmp	r3, #112	; 0x70
 800a752:	d1d7      	bne.n	800a704 <cblas_strmv+0x74>
 800a754:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a758:	f000 8116 	beq.w	800a988 <cblas_strmv+0x2f8>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 800a75c:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a760:	d1d0      	bne.n	800a704 <cblas_strmv+0x74>
    INDEX ix = OFFSET(N, incX);
 800a762:	2c00      	cmp	r4, #0
 800a764:	bfda      	itte	le
 800a766:	f1c5 0901 	rsble	r9, r5, #1
 800a76a:	fb09 f904 	mulle.w	r9, r9, r4
 800a76e:	f04f 0900 	movgt.w	r9, #0
    for (i = 0; i < N; i++) {
 800a772:	2d00      	cmp	r5, #0
 800a774:	dd34      	ble.n	800a7e0 <cblas_strmv+0x150>
 800a776:	f10b 0a01 	add.w	sl, fp, #1
 800a77a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800a77e:	ebcb 7b8b 	rsb	fp, fp, fp, lsl #30
 800a782:	ea4f 038b 	mov.w	r3, fp, lsl #2
 800a786:	f1aa 0c04 	sub.w	ip, sl, #4
 800a78a:	eb09 0b04 	add.w	fp, r9, r4
 800a78e:	9301      	str	r3, [sp, #4]
 800a790:	4467      	add	r7, ip
 800a792:	eb08 0989 	add.w	r9, r8, r9, lsl #2
 800a796:	00a0      	lsls	r0, r4, #2
 800a798:	f04f 0e00 	mov.w	lr, #0
      const INDEX j_min = i + 1;
 800a79c:	f10e 0e01 	add.w	lr, lr, #1
      for (j = j_min; j < j_max; j++) {
 800a7a0:	4575      	cmp	r5, lr
      BASE temp = 0.0;
 800a7a2:	eddf 7aa4 	vldr	s15, [pc, #656]	; 800aa34 <cblas_strmv+0x3a4>
      for (j = j_min; j < j_max; j++) {
 800a7a6:	dd0e      	ble.n	800a7c6 <cblas_strmv+0x136>
 800a7a8:	eb08 018b 	add.w	r1, r8, fp, lsl #2
 800a7ac:	463a      	mov	r2, r7
 800a7ae:	4673      	mov	r3, lr
        temp += X[jx] * A[lda * j + i];
 800a7b0:	edd1 6a00 	vldr	s13, [r1]
 800a7b4:	ed92 7a00 	vldr	s14, [r2]
      for (j = j_min; j < j_max; j++) {
 800a7b8:	3301      	adds	r3, #1
 800a7ba:	429d      	cmp	r5, r3
        temp += X[jx] * A[lda * j + i];
 800a7bc:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800a7c0:	4401      	add	r1, r0
 800a7c2:	4462      	add	r2, ip
 800a7c4:	d1f4      	bne.n	800a7b0 <cblas_strmv+0x120>
      if (nonunit) {
 800a7c6:	2e83      	cmp	r6, #131	; 0x83
 800a7c8:	d022      	beq.n	800a810 <cblas_strmv+0x180>
        X[ix] += temp;
 800a7ca:	ed99 7a00 	vldr	s14, [r9]
 800a7ce:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a7d2:	edc9 7a00 	vstr	s15, [r9]
    for (i = 0; i < N; i++) {
 800a7d6:	4575      	cmp	r5, lr
 800a7d8:	44a3      	add	fp, r4
 800a7da:	4481      	add	r9, r0
 800a7dc:	4457      	add	r7, sl
 800a7de:	d1dd      	bne.n	800a79c <cblas_strmv+0x10c>
 800a7e0:	b003      	add	sp, #12
 800a7e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800a7e6:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
 800a7ea:	2b01      	cmp	r3, #1
 800a7ec:	d91b      	bls.n	800a826 <cblas_strmv+0x196>
 800a7ee:	2370      	movs	r3, #112	; 0x70
 800a7f0:	2002      	movs	r0, #2
 800a7f2:	e764      	b.n	800a6be <cblas_strmv+0x2e>
 800a7f4:	2c00      	cmp	r4, #0
 800a7f6:	bf0c      	ite	eq
 800a7f8:	2009      	moveq	r0, #9
 800a7fa:	2004      	movne	r0, #4
 800a7fc:	e771      	b.n	800a6e2 <cblas_strmv+0x52>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 800a7fe:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a802:	f000 80c1 	beq.w	800a988 <cblas_strmv+0x2f8>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 800a806:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a80a:	f47f af7b 	bne.w	800a704 <cblas_strmv+0x74>
 800a80e:	e7a8      	b.n	800a762 <cblas_strmv+0xd2>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800a810:	9b01      	ldr	r3, [sp, #4]
 800a812:	edd9 6a00 	vldr	s13, [r9]
 800a816:	18fb      	adds	r3, r7, r3
 800a818:	ed93 7a00 	vldr	s14, [r3]
 800a81c:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a820:	edc9 7a00 	vstr	s15, [r9]
 800a824:	e7d7      	b.n	800a7d6 <cblas_strmv+0x146>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800a826:	3865      	subs	r0, #101	; 0x65
 800a828:	2801      	cmp	r0, #1
 800a82a:	bf94      	ite	ls
 800a82c:	2000      	movls	r0, #0
 800a82e:	2001      	movhi	r0, #1
 800a830:	2370      	movs	r3, #112	; 0x70
 800a832:	e744      	b.n	800a6be <cblas_strmv+0x2e>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800a834:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a838:	d05f      	beq.n	800a8fa <cblas_strmv+0x26a>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 800a83a:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a83e:	f47f af61 	bne.w	800a704 <cblas_strmv+0x74>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800a842:	2c00      	cmp	r4, #0
 800a844:	bfd8      	it	le
 800a846:	f1c4 0e00 	rsble	lr, r4, #0
 800a84a:	f105 30ff 	add.w	r0, r5, #4294967295
 800a84e:	bfcc      	ite	gt
 800a850:	f04f 0e00 	movgt.w	lr, #0
 800a854:	fb00 fe0e 	mulle.w	lr, r0, lr
    for (i = N; i > 0 && i--;) {
 800a858:	2d00      	cmp	r5, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800a85a:	fb00 ec04 	mla	ip, r0, r4, lr
    for (i = N; i > 0 && i--;) {
 800a85e:	ddbf      	ble.n	800a7e0 <cblas_strmv+0x150>
 800a860:	f10b 0301 	add.w	r3, fp, #1
 800a864:	009b      	lsls	r3, r3, #2
 800a866:	fb00 550b 	mla	r5, r0, fp, r5
 800a86a:	1f39      	subs	r1, r7, #4
 800a86c:	ebc4 7984 	rsb	r9, r4, r4, lsl #30
 800a870:	1f1a      	subs	r2, r3, #4
 800a872:	eb08 0c8c 	add.w	ip, r8, ip, lsl #2
 800a876:	eb08 088e 	add.w	r8, r8, lr, lsl #2
 800a87a:	ea6f 0e0b 	mvn.w	lr, fp
 800a87e:	ebcb 7b8b 	rsb	fp, fp, fp, lsl #30
 800a882:	eb01 0185 	add.w	r1, r1, r5, lsl #2
 800a886:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800a88a:	fb00 7502 	mla	r5, r0, r2, r7
 800a88e:	00a4      	lsls	r4, r4, #2
 800a890:	fb00 7703 	mla	r7, r0, r3, r7
 800a894:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800a898:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
      for (j = j_min; j < j_max; j++) {
 800a89c:	eddf 7a65 	vldr	s15, [pc, #404]	; 800aa34 <cblas_strmv+0x3a4>
 800a8a0:	b150      	cbz	r0, 800a8b8 <cblas_strmv+0x228>
 800a8a2:	462a      	mov	r2, r5
 800a8a4:	4643      	mov	r3, r8
        temp += X[jx] * A[lda * i + j];
 800a8a6:	ecb2 7a01 	vldmia	r2!, {s14}
 800a8aa:	edd3 6a00 	vldr	s13, [r3]
      for (j = j_min; j < j_max; j++) {
 800a8ae:	428a      	cmp	r2, r1
        temp += X[jx] * A[lda * i + j];
 800a8b0:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800a8b4:	4423      	add	r3, r4
 800a8b6:	d1f6      	bne.n	800a8a6 <cblas_strmv+0x216>
      if (nonunit) {
 800a8b8:	2e83      	cmp	r6, #131	; 0x83
 800a8ba:	d00d      	beq.n	800a8d8 <cblas_strmv+0x248>
        X[ix] += temp;
 800a8bc:	ed9c 7a00 	vldr	s14, [ip]
 800a8c0:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a8c4:	edcc 7a00 	vstr	s15, [ip]
    for (i = N; i > 0 && i--;) {
 800a8c8:	44cc      	add	ip, r9
 800a8ca:	4477      	add	r7, lr
 800a8cc:	4455      	add	r5, sl
 800a8ce:	4471      	add	r1, lr
 800a8d0:	2800      	cmp	r0, #0
 800a8d2:	d085      	beq.n	800a7e0 <cblas_strmv+0x150>
 800a8d4:	3801      	subs	r0, #1
 800a8d6:	e7e1      	b.n	800a89c <cblas_strmv+0x20c>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800a8d8:	eddc 6a00 	vldr	s13, [ip]
 800a8dc:	ed97 7a00 	vldr	s14, [r7]
 800a8e0:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a8e4:	edcc 7a00 	vstr	s15, [ip]
 800a8e8:	e7ee      	b.n	800a8c8 <cblas_strmv+0x238>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800a8ea:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800a8ee:	d004      	beq.n	800a8fa <cblas_strmv+0x26a>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 800a8f0:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800a8f4:	f47f af06 	bne.w	800a704 <cblas_strmv+0x74>
 800a8f8:	e7a3      	b.n	800a842 <cblas_strmv+0x1b2>
    INDEX ix = OFFSET(N, incX);
 800a8fa:	2c00      	cmp	r4, #0
 800a8fc:	bfda      	itte	le
 800a8fe:	f1c5 0901 	rsble	r9, r5, #1
 800a902:	fb09 f904 	mulle.w	r9, r9, r4
 800a906:	f04f 0900 	movgt.w	r9, #0
    for (i = 0; i < N; i++) {
 800a90a:	2d00      	cmp	r5, #0
 800a90c:	f77f af68 	ble.w	800a7e0 <cblas_strmv+0x150>
 800a910:	f10b 0301 	add.w	r3, fp, #1
 800a914:	009b      	lsls	r3, r3, #2
 800a916:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800a91a:	f107 0a04 	add.w	sl, r7, #4
 800a91e:	eb07 0085 	add.w	r0, r7, r5, lsl #2
 800a922:	f1a3 0b04 	sub.w	fp, r3, #4
 800a926:	00a7      	lsls	r7, r4, #2
 800a928:	9201      	str	r2, [sp, #4]
 800a92a:	f04f 0e00 	mov.w	lr, #0
      const INDEX j_min = i + 1;
 800a92e:	f10e 0e01 	add.w	lr, lr, #1
      for (j = j_min; j < j_max; j++) {
 800a932:	4575      	cmp	r5, lr
      BASE temp = 0.0;
 800a934:	eddf 7a3f 	vldr	s15, [pc, #252]	; 800aa34 <cblas_strmv+0x3a4>
 800a938:	ea4f 0c89 	mov.w	ip, r9, lsl #2
      for (j = j_min; j < j_max; j++) {
 800a93c:	dd0c      	ble.n	800a958 <cblas_strmv+0x2c8>
 800a93e:	9a01      	ldr	r2, [sp, #4]
 800a940:	eb02 0189 	add.w	r1, r2, r9, lsl #2
 800a944:	4652      	mov	r2, sl
        temp += X[jx] * A[lda * i + j];
 800a946:	ecb2 7a01 	vldmia	r2!, {s14}
 800a94a:	edd1 6a00 	vldr	s13, [r1]
      for (j = j_min; j < j_max; j++) {
 800a94e:	4290      	cmp	r0, r2
        temp += X[jx] * A[lda * i + j];
 800a950:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800a954:	4439      	add	r1, r7
 800a956:	d1f6      	bne.n	800a946 <cblas_strmv+0x2b6>
      if (nonunit) {
 800a958:	2e83      	cmp	r6, #131	; 0x83
 800a95a:	44c4      	add	ip, r8
 800a95c:	d00b      	beq.n	800a976 <cblas_strmv+0x2e6>
        X[ix] += temp;
 800a95e:	ed9c 7a00 	vldr	s14, [ip]
 800a962:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a966:	edcc 7a00 	vstr	s15, [ip]
    for (i = 0; i < N; i++) {
 800a96a:	4575      	cmp	r5, lr
      ix += incX;
 800a96c:	44a1      	add	r9, r4
    for (i = 0; i < N; i++) {
 800a96e:	449a      	add	sl, r3
 800a970:	4458      	add	r0, fp
 800a972:	d1dc      	bne.n	800a92e <cblas_strmv+0x29e>
 800a974:	e734      	b.n	800a7e0 <cblas_strmv+0x150>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800a976:	eddc 6a00 	vldr	s13, [ip]
 800a97a:	ed1a 7a01 	vldr	s14, [sl, #-4]
 800a97e:	eee6 7a87 	vfma.f32	s15, s13, s14
 800a982:	edcc 7a00 	vstr	s15, [ip]
 800a986:	e7f0      	b.n	800a96a <cblas_strmv+0x2da>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800a988:	2c00      	cmp	r4, #0
 800a98a:	bfd8      	it	le
 800a98c:	4263      	negle	r3, r4
 800a98e:	f105 30ff 	add.w	r0, r5, #4294967295
 800a992:	bfcc      	ite	gt
 800a994:	2300      	movgt	r3, #0
 800a996:	4343      	mulle	r3, r0
    for (i = N; i > 0 && i--;) {
 800a998:	2d00      	cmp	r5, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800a99a:	fb00 3e04 	mla	lr, r0, r4, r3
    for (i = N; i > 0 && i--;) {
 800a99e:	f77f af1f 	ble.w	800a7e0 <cblas_strmv+0x150>
 800a9a2:	f10b 0c01 	add.w	ip, fp, #1
 800a9a6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800a9aa:	ebc4 7984 	rsb	r9, r4, r4, lsl #30
 800a9ae:	ea6f 0a0b 	mvn.w	sl, fp
 800a9b2:	eb08 0e8e 	add.w	lr, r8, lr, lsl #2
 800a9b6:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 800a9ba:	eb08 0883 	add.w	r8, r8, r3, lsl #2
 800a9be:	fb0c 7700 	mla	r7, ip, r0, r7
 800a9c2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800a9c6:	f1ac 0c04 	sub.w	ip, ip, #4
 800a9ca:	ea4f 0989 	mov.w	r9, r9, lsl #2
 800a9ce:	00a4      	lsls	r4, r4, #2
      for (j = j_min; j < j_max; j++) {
 800a9d0:	eddf 7a18 	vldr	s15, [pc, #96]	; 800aa34 <cblas_strmv+0x3a4>
 800a9d4:	b168      	cbz	r0, 800a9f2 <cblas_strmv+0x362>
 800a9d6:	4629      	mov	r1, r5
 800a9d8:	4642      	mov	r2, r8
 800a9da:	2300      	movs	r3, #0
        temp += X[jx] * A[lda * j + i];
 800a9dc:	edd2 6a00 	vldr	s13, [r2]
 800a9e0:	ed11 7a01 	vldr	s14, [r1, #-4]
      for (j = j_min; j < j_max; j++) {
 800a9e4:	3301      	adds	r3, #1
 800a9e6:	4298      	cmp	r0, r3
        temp += X[jx] * A[lda * j + i];
 800a9e8:	eee6 7a87 	vfma.f32	s15, s13, s14
      for (j = j_min; j < j_max; j++) {
 800a9ec:	4422      	add	r2, r4
 800a9ee:	4461      	add	r1, ip
 800a9f0:	d1f4      	bne.n	800a9dc <cblas_strmv+0x34c>
      if (nonunit) {
 800a9f2:	2e83      	cmp	r6, #131	; 0x83
 800a9f4:	d00d      	beq.n	800aa12 <cblas_strmv+0x382>
        X[ix] += temp;
 800a9f6:	ed9e 7a00 	vldr	s14, [lr]
 800a9fa:	ee77 7a27 	vadd.f32	s15, s14, s15
 800a9fe:	edce 7a00 	vstr	s15, [lr]
    for (i = N; i > 0 && i--;) {
 800aa02:	44ce      	add	lr, r9
 800aa04:	4457      	add	r7, sl
 800aa06:	3d04      	subs	r5, #4
 800aa08:	2800      	cmp	r0, #0
 800aa0a:	f43f aee9 	beq.w	800a7e0 <cblas_strmv+0x150>
 800aa0e:	3801      	subs	r0, #1
 800aa10:	e7de      	b.n	800a9d0 <cblas_strmv+0x340>
        X[ix] = temp + X[ix] * A[lda * i + i];
 800aa12:	edde 6a00 	vldr	s13, [lr]
 800aa16:	ed97 7a00 	vldr	s14, [r7]
 800aa1a:	eee6 7a87 	vfma.f32	s15, s13, s14
 800aa1e:	edce 7a00 	vstr	s15, [lr]
 800aa22:	e7ee      	b.n	800aa02 <cblas_strmv+0x372>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800aa24:	2009      	movs	r0, #9
 800aa26:	e65c      	b.n	800a6e2 <cblas_strmv+0x52>
 800aa28:	08030378 	.word	0x08030378
 800aa2c:	08030680 	.word	0x08030680
 800aa30:	080305a8 	.word	0x080305a8
 800aa34:	00000000 	.word	0x00000000

0800aa38 <cblas_strsm>:
cblas_strsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const float alpha, const float *A, const int lda, float *B,
             const int ldb)
{
 800aa38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800aa3c:	ed2d 8b02 	vpush	{d8}
 800aa40:	b089      	sub	sp, #36	; 0x24
 800aa42:	469a      	mov	sl, r3
 800aa44:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 800aa48:	9301      	str	r3, [sp, #4]
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  int side, uplo, trans;

  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800aa4a:	298d      	cmp	r1, #141	; 0x8d
 800aa4c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800aa4e:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
 800aa52:	9302      	str	r3, [sp, #8]
 800aa54:	e9dd 4515 	ldrd	r4, r5, [sp, #84]	; 0x54
 800aa58:	e9dd 7818 	ldrd	r7, r8, [sp, #96]	; 0x60
 800aa5c:	460e      	mov	r6, r1
 800aa5e:	4693      	mov	fp, r2
 800aa60:	eeb0 8a40 	vmov.f32	s16, s0
 800aa64:	d064      	beq.n	800ab30 <cblas_strsm+0xf8>
 800aa66:	298e      	cmp	r1, #142	; 0x8e
 800aa68:	f000 825e 	beq.w	800af28 <cblas_strsm+0x4f0>
 800aa6c:	46ac      	mov	ip, r5
 800aa6e:	2302      	movs	r3, #2
 800aa70:	f1ab 0279 	sub.w	r2, fp, #121	; 0x79
 800aa74:	2a01      	cmp	r2, #1
 800aa76:	9a01      	ldr	r2, [sp, #4]
 800aa78:	f1aa 016f 	sub.w	r1, sl, #111	; 0x6f
 800aa7c:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 800aa80:	bf88      	it	hi
 800aa82:	2303      	movhi	r3, #3
 800aa84:	b2d2      	uxtb	r2, r2
 800aa86:	2902      	cmp	r1, #2
 800aa88:	bf88      	it	hi
 800aa8a:	2304      	movhi	r3, #4
 800aa8c:	2a02      	cmp	r2, #2
 800aa8e:	bf28      	it	cs
 800aa90:	2305      	movcs	r3, #5
 800aa92:	2c00      	cmp	r4, #0
 800aa94:	bfb8      	it	lt
 800aa96:	2306      	movlt	r3, #6
 800aa98:	2d00      	cmp	r5, #0
 800aa9a:	bfb8      	it	lt
 800aa9c:	2307      	movlt	r3, #7
 800aa9e:	f1bc 0f01 	cmp.w	ip, #1
 800aaa2:	bfb8      	it	lt
 800aaa4:	f04f 0c01 	movlt.w	ip, #1
 800aaa8:	45bc      	cmp	ip, r7
 800aaaa:	dd35      	ble.n	800ab18 <cblas_strsm+0xe0>
 800aaac:	2865      	cmp	r0, #101	; 0x65
 800aaae:	f000 80c9 	beq.w	800ac44 <cblas_strsm+0x20c>
 800aab2:	2c01      	cmp	r4, #1
 800aab4:	4623      	mov	r3, r4
 800aab6:	bfb8      	it	lt
 800aab8:	2301      	movlt	r3, #1
 800aaba:	454b      	cmp	r3, r9
 800aabc:	bfcc      	ite	gt
 800aabe:	230c      	movgt	r3, #12
 800aac0:	230a      	movle	r3, #10
 800aac2:	4aa4      	ldr	r2, [pc, #656]	; (800ad54 <cblas_strsm+0x31c>)
 800aac4:	49a4      	ldr	r1, [pc, #656]	; (800ad58 <cblas_strsm+0x320>)
 800aac6:	4618      	mov	r0, r3
 800aac8:	f01c ffbe 	bl	8027a48 <cblas_xerbla>
    uplo = Uplo;
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
  } else {
    n1 = N;
    n2 = M;
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800aacc:	2e8d      	cmp	r6, #141	; 0x8d
 800aace:	bf0c      	ite	eq
 800aad0:	268e      	moveq	r6, #142	; 0x8e
 800aad2:	268d      	movne	r6, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800aad4:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 800aad8:	bf0c      	ite	eq
 800aada:	f04f 0b7a 	moveq.w	fp, #122	; 0x7a
 800aade:	f04f 0b79 	movne.w	fp, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800aae2:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
 800aae6:	bf08      	it	eq
 800aae8:	f04f 0a70 	moveq.w	sl, #112	; 0x70
  }

  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800aaec:	2e8d      	cmp	r6, #141	; 0x8d
 800aaee:	d027      	beq.n	800ab40 <cblas_strsm+0x108>
          B[ldb * k + j] -= Aik * B[ldb * i + j];
        }
      }
    }

  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800aaf0:	2e8e      	cmp	r6, #142	; 0x8e
 800aaf2:	d107      	bne.n	800ab04 <cblas_strsm+0xcc>
 800aaf4:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 800aaf8:	f000 80be 	beq.w	800ac78 <cblas_strsm+0x240>
        }
      }
    }


  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800aafc:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 800ab00:	f000 812e 	beq.w	800ad60 <cblas_strsm+0x328>
    }



  } else {
    BLAS_ERROR("unrecognized operation");
 800ab04:	4a95      	ldr	r2, [pc, #596]	; (800ad5c <cblas_strsm+0x324>)
 800ab06:	4994      	ldr	r1, [pc, #592]	; (800ad58 <cblas_strsm+0x320>)
 800ab08:	2000      	movs	r0, #0
#define BASE float
#include "source_trsm_r.h"
#undef BASE
}
 800ab0a:	b009      	add	sp, #36	; 0x24
 800ab0c:	ecbd 8b02 	vpop	{d8}
 800ab10:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ab14:	f01c bf98 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800ab18:	2865      	cmp	r0, #101	; 0x65
 800ab1a:	f000 818f 	beq.w	800ae3c <cblas_strsm+0x404>
 800ab1e:	2c01      	cmp	r4, #1
 800ab20:	4622      	mov	r2, r4
 800ab22:	bfb8      	it	lt
 800ab24:	2201      	movlt	r2, #1
 800ab26:	454a      	cmp	r2, r9
 800ab28:	f340 80a2 	ble.w	800ac70 <cblas_strsm+0x238>
 800ab2c:	230c      	movs	r3, #12
 800ab2e:	e7c8      	b.n	800aac2 <cblas_strsm+0x8a>
 800ab30:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800ab34:	2b01      	cmp	r3, #1
 800ab36:	bf94      	ite	ls
 800ab38:	2300      	movls	r3, #0
 800ab3a:	2301      	movhi	r3, #1
 800ab3c:	46a4      	mov	ip, r4
 800ab3e:	e797      	b.n	800aa70 <cblas_strsm+0x38>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800ab40:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 800ab44:	f000 8182 	beq.w	800ae4c <cblas_strsm+0x414>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 800ab48:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 800ab4c:	d1da      	bne.n	800ab04 <cblas_strsm+0xcc>
 800ab4e:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800ab52:	f000 82ac 	beq.w	800b0ae <cblas_strsm+0x676>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 800ab56:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800ab5a:	d1d3      	bne.n	800ab04 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800ab5c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800ab60:	eeb4 8a67 	vcmp.f32	s16, s15
 800ab64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ab68:	f000 83f5 	beq.w	800b356 <cblas_strsm+0x91e>
      for (i = 0; i < n1; i++) {
 800ab6c:	2d00      	cmp	r5, #0
 800ab6e:	f340 8203 	ble.w	800af78 <cblas_strsm+0x540>
 800ab72:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800ab76:	00a3      	lsls	r3, r4, #2
 800ab78:	0080      	lsls	r0, r0, #2
 800ab7a:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800ab7e:	9303      	str	r3, [sp, #12]
 800ab80:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800ab84:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800ab86:	2c00      	cmp	r4, #0
 800ab88:	bfc8      	it	gt
 800ab8a:	1813      	addgt	r3, r2, r0
 800ab8c:	dd07      	ble.n	800ab9e <cblas_strsm+0x166>
          B[ldb * i + j] *= alpha;
 800ab8e:	edd3 7a00 	vldr	s15, [r3]
 800ab92:	ee67 7a88 	vmul.f32	s15, s15, s16
 800ab96:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800ab9a:	4293      	cmp	r3, r2
 800ab9c:	d1f7      	bne.n	800ab8e <cblas_strsm+0x156>
      for (i = 0; i < n1; i++) {
 800ab9e:	3101      	adds	r1, #1
 800aba0:	428d      	cmp	r5, r1
 800aba2:	4432      	add	r2, r6
 800aba4:	d1ef      	bne.n	800ab86 <cblas_strsm+0x14e>
 800aba6:	f105 3cff 	add.w	ip, r5, #4294967295
 800abaa:	fb0c fa07 	mul.w	sl, ip, r7
 800abae:	9a02      	ldr	r2, [sp, #8]
 800abb0:	fb07 c30c 	mla	r3, r7, ip, ip
 800abb4:	eba3 030a 	sub.w	r3, r3, sl
 800abb8:	1f11      	subs	r1, r2, #4
 800abba:	009b      	lsls	r3, r3, #2
 800abbc:	43fa      	mvns	r2, r7
 800abbe:	9306      	str	r3, [sp, #24]
 800abc0:	0093      	lsls	r3, r2, #2
 800abc2:	9304      	str	r3, [sp, #16]
 800abc4:	ebc9 7389 	rsb	r3, r9, r9, lsl #30
 800abc8:	009b      	lsls	r3, r3, #2
 800abca:	eb0a 0005 	add.w	r0, sl, r5
 800abce:	9305      	str	r3, [sp, #20]
 800abd0:	9b03      	ldr	r3, [sp, #12]
 800abd2:	ebc7 7b87 	rsb	fp, r7, r7, lsl #30
 800abd6:	ebc5 7585 	rsb	r5, r5, r5, lsl #30
 800abda:	eb01 0780 	add.w	r7, r1, r0, lsl #2
 800abde:	9902      	ldr	r1, [sp, #8]
 800abe0:	00ad      	lsls	r5, r5, #2
 800abe2:	4443      	add	r3, r8
 800abe4:	9507      	str	r5, [sp, #28]
 800abe6:	eb01 0a8a 	add.w	sl, r1, sl, lsl #2
 800abea:	fb06 8e0c 	mla	lr, r6, ip, r8
 800abee:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800abf2:	9302      	str	r3, [sp, #8]
      if (nonunit) {
 800abf4:	9b01      	ldr	r3, [sp, #4]
 800abf6:	2b83      	cmp	r3, #131	; 0x83
 800abf8:	f000 819e 	beq.w	800af38 <cblas_strsm+0x500>
      for (k = 0; k < i; k++) {
 800abfc:	f1bc 0f00 	cmp.w	ip, #0
 800ac00:	f000 81ba 	beq.w	800af78 <cblas_strsm+0x540>
 800ac04:	9902      	ldr	r1, [sp, #8]
 800ac06:	4650      	mov	r0, sl
 800ac08:	2500      	movs	r5, #0
        for (j = 0; j < n2; j++) {
 800ac0a:	2c00      	cmp	r4, #0
        const BASE Aik = A[i * lda + k];
 800ac0c:	ecf0 6a01 	vldmia	r0!, {s13}
        for (j = 0; j < n2; j++) {
 800ac10:	dd0c      	ble.n	800ac2c <cblas_strsm+0x1f4>
 800ac12:	eb08 0385 	add.w	r3, r8, r5, lsl #2
 800ac16:	4672      	mov	r2, lr
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 800ac18:	edd3 7a00 	vldr	s15, [r3]
 800ac1c:	ecb2 7a01 	vldmia	r2!, {s14}
 800ac20:	eee7 7a66 	vfms.f32	s15, s14, s13
 800ac24:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800ac28:	428b      	cmp	r3, r1
 800ac2a:	d1f5      	bne.n	800ac18 <cblas_strsm+0x1e0>
      for (k = 0; k < i; k++) {
 800ac2c:	42b8      	cmp	r0, r7
 800ac2e:	444d      	add	r5, r9
 800ac30:	4431      	add	r1, r6
 800ac32:	d1ea      	bne.n	800ac0a <cblas_strsm+0x1d2>
 800ac34:	9b04      	ldr	r3, [sp, #16]
 800ac36:	441f      	add	r7, r3
 800ac38:	9b05      	ldr	r3, [sp, #20]
 800ac3a:	44da      	add	sl, fp
 800ac3c:	449e      	add	lr, r3
 800ac3e:	f10c 3cff 	add.w	ip, ip, #4294967295
 800ac42:	e7d7      	b.n	800abf4 <cblas_strsm+0x1bc>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800ac44:	2d01      	cmp	r5, #1
 800ac46:	462b      	mov	r3, r5
 800ac48:	bfb8      	it	lt
 800ac4a:	2301      	movlt	r3, #1
 800ac4c:	454b      	cmp	r3, r9
 800ac4e:	bfcc      	ite	gt
 800ac50:	230c      	movgt	r3, #12
 800ac52:	230a      	movle	r3, #10
 800ac54:	4a3f      	ldr	r2, [pc, #252]	; (800ad54 <cblas_strsm+0x31c>)
 800ac56:	4940      	ldr	r1, [pc, #256]	; (800ad58 <cblas_strsm+0x320>)
 800ac58:	4618      	mov	r0, r3
 800ac5a:	f01c fef5 	bl	8027a48 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800ac5e:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
 800ac62:	462b      	mov	r3, r5
 800ac64:	d101      	bne.n	800ac6a <cblas_strsm+0x232>
 800ac66:	f04f 0a70 	mov.w	sl, #112	; 0x70
 800ac6a:	4625      	mov	r5, r4
 800ac6c:	461c      	mov	r4, r3
 800ac6e:	e73d      	b.n	800aaec <cblas_strsm+0xb4>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800ac70:	2b00      	cmp	r3, #0
 800ac72:	f43f af2b 	beq.w	800aacc <cblas_strsm+0x94>
 800ac76:	e724      	b.n	800aac2 <cblas_strsm+0x8a>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800ac78:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800ac7c:	f000 8292 	beq.w	800b1a4 <cblas_strsm+0x76c>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 800ac80:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800ac84:	f47f af3e 	bne.w	800ab04 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800ac88:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800ac8c:	eeb4 8a67 	vcmp.f32	s16, s15
 800ac90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ac94:	f000 837f 	beq.w	800b396 <cblas_strsm+0x95e>
      for (i = 0; i < n1; i++) {
 800ac98:	2d00      	cmp	r5, #0
 800ac9a:	f340 816d 	ble.w	800af78 <cblas_strsm+0x540>
 800ac9e:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800aca2:	00a3      	lsls	r3, r4, #2
 800aca4:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800aca8:	0080      	lsls	r0, r0, #2
 800acaa:	9303      	str	r3, [sp, #12]
 800acac:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800acb0:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800acb2:	2c00      	cmp	r4, #0
 800acb4:	bfc8      	it	gt
 800acb6:	1813      	addgt	r3, r2, r0
 800acb8:	dd07      	ble.n	800acca <cblas_strsm+0x292>
          B[ldb * i + j] *= alpha;
 800acba:	edd3 7a00 	vldr	s15, [r3]
 800acbe:	ee67 7a88 	vmul.f32	s15, s15, s16
 800acc2:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800acc6:	4293      	cmp	r3, r2
 800acc8:	d1f7      	bne.n	800acba <cblas_strsm+0x282>
      for (i = 0; i < n1; i++) {
 800acca:	3101      	adds	r1, #1
 800accc:	428d      	cmp	r5, r1
 800acce:	4432      	add	r2, r6
 800acd0:	d1ef      	bne.n	800acb2 <cblas_strsm+0x27a>
 800acd2:	9903      	ldr	r1, [sp, #12]
 800acd4:	f8dd c004 	ldr.w	ip, [sp, #4]
 800acd8:	4441      	add	r1, r8
 800acda:	1c7b      	adds	r3, r7, #1
 800acdc:	468b      	mov	fp, r1
 800acde:	9902      	ldr	r1, [sp, #8]
 800ace0:	009b      	lsls	r3, r3, #2
 800ace2:	43ff      	mvns	r7, r7
 800ace4:	1e62      	subs	r2, r4, #1
 800ace6:	e9cd 4501 	strd	r4, r5, [sp, #4]
 800acea:	fb03 1202 	mla	r2, r3, r2, r1
 800acee:	ea4f 0987 	mov.w	r9, r7, lsl #2
 800acf2:	1f1f      	subs	r7, r3, #4
      for (j = n2; j > 0 && j--;) {
 800acf4:	2300      	movs	r3, #0
 800acf6:	9203      	str	r2, [sp, #12]
 800acf8:	f101 0a04 	add.w	sl, r1, #4
 800acfc:	469e      	mov	lr, r3
 800acfe:	9b01      	ldr	r3, [sp, #4]
 800ad00:	2b00      	cmp	r3, #0
 800ad02:	f340 813e 	ble.w	800af82 <cblas_strsm+0x54a>
 800ad06:	9d03      	ldr	r5, [sp, #12]
 800ad08:	9801      	ldr	r0, [sp, #4]
 800ad0a:	465c      	mov	r4, fp
 800ad0c:	4659      	mov	r1, fp
        if (nonunit) {
 800ad0e:	f1bc 0f83 	cmp.w	ip, #131	; 0x83
      for (j = n2; j > 0 && j--;) {
 800ad12:	f100 30ff 	add.w	r0, r0, #4294967295
        if (nonunit) {
 800ad16:	d107      	bne.n	800ad28 <cblas_strsm+0x2f0>
          B[ldb * i + j] /= Ajj;
 800ad18:	ed54 6a01 	vldr	s13, [r4, #-4]
 800ad1c:	ed95 7a00 	vldr	s14, [r5]
 800ad20:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ad24:	ed44 7a01 	vstr	s15, [r4, #-4]
          BASE Bij = B[ldb * i + j];
 800ad28:	ed71 6a01 	vldmdb	r1!, {s13}
          for (k = 0; k < j; k++) {
 800ad2c:	2800      	cmp	r0, #0
 800ad2e:	f000 8128 	beq.w	800af82 <cblas_strsm+0x54a>
 800ad32:	eb0a 0280 	add.w	r2, sl, r0, lsl #2
 800ad36:	4643      	mov	r3, r8
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 800ad38:	ed12 7a01 	vldr	s14, [r2, #-4]
 800ad3c:	edd3 7a00 	vldr	s15, [r3]
 800ad40:	eee7 7a66 	vfms.f32	s15, s14, s13
 800ad44:	443a      	add	r2, r7
 800ad46:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = 0; k < j; k++) {
 800ad4a:	428b      	cmp	r3, r1
 800ad4c:	d1f4      	bne.n	800ad38 <cblas_strsm+0x300>
 800ad4e:	444d      	add	r5, r9
 800ad50:	3c04      	subs	r4, #4
 800ad52:	e7dc      	b.n	800ad0e <cblas_strsm+0x2d6>
 800ad54:	08030378 	.word	0x08030378
 800ad58:	08030690 	.word	0x08030690
 800ad5c:	080305a8 	.word	0x080305a8
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800ad60:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800ad64:	f000 8280 	beq.w	800b268 <cblas_strsm+0x830>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 800ad68:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800ad6c:	f47f aeca 	bne.w	800ab04 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800ad70:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800ad74:	eeb4 8a67 	vcmp.f32	s16, s15
 800ad78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ad7c:	f000 82e3 	beq.w	800b346 <cblas_strsm+0x90e>
      for (i = 0; i < n1; i++) {
 800ad80:	2d00      	cmp	r5, #0
 800ad82:	f340 80f9 	ble.w	800af78 <cblas_strsm+0x540>
 800ad86:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800ad8a:	00a3      	lsls	r3, r4, #2
 800ad8c:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800ad90:	0080      	lsls	r0, r0, #2
 800ad92:	9303      	str	r3, [sp, #12]
 800ad94:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800ad98:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800ad9a:	2c00      	cmp	r4, #0
 800ad9c:	bfc8      	it	gt
 800ad9e:	1813      	addgt	r3, r2, r0
 800ada0:	dd07      	ble.n	800adb2 <cblas_strsm+0x37a>
          B[ldb * i + j] *= alpha;
 800ada2:	edd3 7a00 	vldr	s15, [r3]
 800ada6:	ee67 7a88 	vmul.f32	s15, s15, s16
 800adaa:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800adae:	4293      	cmp	r3, r2
 800adb0:	d1f7      	bne.n	800ada2 <cblas_strsm+0x36a>
      for (i = 0; i < n1; i++) {
 800adb2:	3101      	adds	r1, #1
 800adb4:	428d      	cmp	r5, r1
 800adb6:	4432      	add	r2, r6
 800adb8:	d1ef      	bne.n	800ad9a <cblas_strsm+0x362>
 800adba:	9a03      	ldr	r2, [sp, #12]
 800adbc:	9604      	str	r6, [sp, #16]
 800adbe:	4611      	mov	r1, r2
 800adc0:	9a02      	ldr	r2, [sp, #8]
 800adc2:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 800adc6:	f107 0a01 	add.w	sl, r7, #1
 800adca:	00b8      	lsls	r0, r7, #2
 800adcc:	9205      	str	r2, [sp, #20]
          for (k = j + 1; k < n2; k++) {
 800adce:	2200      	movs	r2, #0
 800add0:	4441      	add	r1, r8
 800add2:	46c1      	mov	r9, r8
 800add4:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800add8:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800addc:	9203      	str	r2, [sp, #12]
 800adde:	f100 0b04 	add.w	fp, r0, #4
 800ade2:	9501      	str	r5, [sp, #4]
      for (j = 0; j < n2; j++) {
 800ade4:	2c00      	cmp	r4, #0
 800ade6:	f340 80bd 	ble.w	800af64 <cblas_strsm+0x52c>
 800adea:	f8dd e008 	ldr.w	lr, [sp, #8]
 800adee:	9f05      	ldr	r7, [sp, #20]
 800adf0:	46cc      	mov	ip, r9
 800adf2:	464e      	mov	r6, r9
 800adf4:	2500      	movs	r5, #0
        if (nonunit) {
 800adf6:	f1b8 0f83 	cmp.w	r8, #131	; 0x83
 800adfa:	d107      	bne.n	800ae0c <cblas_strsm+0x3d4>
          B[ldb * i + j] /= Ajj;
 800adfc:	eddc 6a00 	vldr	s13, [ip]
 800ae00:	ed9e 7a00 	vldr	s14, [lr]
 800ae04:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800ae08:	edcc 7a00 	vstr	s15, [ip]
          for (k = j + 1; k < n2; k++) {
 800ae0c:	3501      	adds	r5, #1
 800ae0e:	42ac      	cmp	r4, r5
          BASE Bij = B[ldb * i + j];
 800ae10:	ecf6 6a01 	vldmia	r6!, {s13}
          for (k = j + 1; k < n2; k++) {
 800ae14:	f000 80a6 	beq.w	800af64 <cblas_strsm+0x52c>
 800ae18:	463a      	mov	r2, r7
 800ae1a:	4633      	mov	r3, r6
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 800ae1c:	ed92 7a00 	vldr	s14, [r2]
 800ae20:	edd3 7a00 	vldr	s15, [r3]
 800ae24:	eee7 7a66 	vfms.f32	s15, s14, s13
 800ae28:	4402      	add	r2, r0
 800ae2a:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = j + 1; k < n2; k++) {
 800ae2e:	428b      	cmp	r3, r1
 800ae30:	d1f4      	bne.n	800ae1c <cblas_strsm+0x3e4>
 800ae32:	4457      	add	r7, sl
 800ae34:	44de      	add	lr, fp
 800ae36:	f10c 0c04 	add.w	ip, ip, #4
 800ae3a:	e7dc      	b.n	800adf6 <cblas_strsm+0x3be>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800ae3c:	2d01      	cmp	r5, #1
 800ae3e:	462a      	mov	r2, r5
 800ae40:	bfb8      	it	lt
 800ae42:	2201      	movlt	r2, #1
 800ae44:	454a      	cmp	r2, r9
 800ae46:	dd6b      	ble.n	800af20 <cblas_strsm+0x4e8>
 800ae48:	230c      	movs	r3, #12
 800ae4a:	e703      	b.n	800ac54 <cblas_strsm+0x21c>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800ae4c:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 800ae50:	f000 80b2 	beq.w	800afb8 <cblas_strsm+0x580>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 800ae54:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 800ae58:	f47f ae54 	bne.w	800ab04 <cblas_strsm+0xcc>
    if (alpha != 1.0) {
 800ae5c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800ae60:	eeb4 8a67 	vcmp.f32	s16, s15
 800ae64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800ae68:	f000 828d 	beq.w	800b386 <cblas_strsm+0x94e>
      for (i = 0; i < n1; i++) {
 800ae6c:	2d00      	cmp	r5, #0
 800ae6e:	f340 8083 	ble.w	800af78 <cblas_strsm+0x540>
 800ae72:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800ae76:	00a3      	lsls	r3, r4, #2
 800ae78:	0080      	lsls	r0, r0, #2
 800ae7a:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800ae7e:	9303      	str	r3, [sp, #12]
 800ae80:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800ae84:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800ae86:	2c00      	cmp	r4, #0
 800ae88:	bfc8      	it	gt
 800ae8a:	1883      	addgt	r3, r0, r2
 800ae8c:	dd07      	ble.n	800ae9e <cblas_strsm+0x466>
          B[ldb * i + j] *= alpha;
 800ae8e:	edd3 7a00 	vldr	s15, [r3]
 800ae92:	ee67 7a88 	vmul.f32	s15, s15, s16
 800ae96:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800ae9a:	429a      	cmp	r2, r3
 800ae9c:	d1f7      	bne.n	800ae8e <cblas_strsm+0x456>
      for (i = 0; i < n1; i++) {
 800ae9e:	3101      	adds	r1, #1
 800aea0:	428d      	cmp	r5, r1
 800aea2:	4432      	add	r2, r6
 800aea4:	d1ef      	bne.n	800ae86 <cblas_strsm+0x44e>
 800aea6:	00b8      	lsls	r0, r7, #2
 800aea8:	9a02      	ldr	r2, [sp, #8]
 800aeaa:	9007      	str	r0, [sp, #28]
 800aeac:	eb04 0309 	add.w	r3, r4, r9
 800aeb0:	f04f 0b00 	mov.w	fp, #0
 800aeb4:	1d01      	adds	r1, r0, #4
 800aeb6:	009b      	lsls	r3, r3, #2
 800aeb8:	eb02 0e85 	add.w	lr, r2, r5, lsl #2
 800aebc:	9106      	str	r1, [sp, #24]
 800aebe:	1d17      	adds	r7, r2, #4
 800aec0:	9305      	str	r3, [sp, #20]
 800aec2:	46da      	mov	sl, fp
 800aec4:	46c4      	mov	ip, r8
 800aec6:	9504      	str	r5, [sp, #16]
      if (nonunit) {
 800aec8:	9b01      	ldr	r3, [sp, #4]
 800aeca:	2b83      	cmp	r3, #131	; 0x83
 800aecc:	d062      	beq.n	800af94 <cblas_strsm+0x55c>
      for (k = i + 1; k < n1; k++) {
 800aece:	9b04      	ldr	r3, [sp, #16]
 800aed0:	f10a 0a01 	add.w	sl, sl, #1
 800aed4:	4553      	cmp	r3, sl
 800aed6:	dd4f      	ble.n	800af78 <cblas_strsm+0x540>
 800aed8:	9b05      	ldr	r3, [sp, #20]
 800aeda:	44cb      	add	fp, r9
 800aedc:	465d      	mov	r5, fp
 800aede:	eb03 010c 	add.w	r1, r3, ip
 800aee2:	4638      	mov	r0, r7
        for (j = 0; j < n2; j++) {
 800aee4:	2c00      	cmp	r4, #0
        const BASE Aik = A[i * lda + k];
 800aee6:	ecf0 6a01 	vldmia	r0!, {s13}
        for (j = 0; j < n2; j++) {
 800aeea:	dd0c      	ble.n	800af06 <cblas_strsm+0x4ce>
 800aeec:	eb08 0385 	add.w	r3, r8, r5, lsl #2
 800aef0:	4662      	mov	r2, ip
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 800aef2:	edd3 7a00 	vldr	s15, [r3]
 800aef6:	ecb2 7a01 	vldmia	r2!, {s14}
 800aefa:	eee7 7a66 	vfms.f32	s15, s14, s13
 800aefe:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800af02:	4299      	cmp	r1, r3
 800af04:	d1f5      	bne.n	800aef2 <cblas_strsm+0x4ba>
      for (k = i + 1; k < n1; k++) {
 800af06:	4586      	cmp	lr, r0
 800af08:	444d      	add	r5, r9
 800af0a:	4431      	add	r1, r6
 800af0c:	d1ea      	bne.n	800aee4 <cblas_strsm+0x4ac>
 800af0e:	9b07      	ldr	r3, [sp, #28]
 800af10:	9a02      	ldr	r2, [sp, #8]
 800af12:	449e      	add	lr, r3
 800af14:	9b06      	ldr	r3, [sp, #24]
 800af16:	441a      	add	r2, r3
 800af18:	441f      	add	r7, r3
 800af1a:	44b4      	add	ip, r6
 800af1c:	9202      	str	r2, [sp, #8]
 800af1e:	e7d3      	b.n	800aec8 <cblas_strsm+0x490>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800af20:	2b00      	cmp	r3, #0
 800af22:	f43f ae9c 	beq.w	800ac5e <cblas_strsm+0x226>
 800af26:	e695      	b.n	800ac54 <cblas_strsm+0x21c>
 800af28:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800af2c:	2b01      	cmp	r3, #1
 800af2e:	bf94      	ite	ls
 800af30:	2300      	movls	r3, #0
 800af32:	2301      	movhi	r3, #1
 800af34:	46ac      	mov	ip, r5
 800af36:	e59b      	b.n	800aa70 <cblas_strsm+0x38>
        BASE Aii = A[lda * i + i];
 800af38:	9b06      	ldr	r3, [sp, #24]
 800af3a:	9a07      	ldr	r2, [sp, #28]
 800af3c:	18fb      	adds	r3, r7, r3
 800af3e:	4413      	add	r3, r2
        for (j = 0; j < n2; j++) {
 800af40:	2c00      	cmp	r4, #0
        BASE Aii = A[lda * i + i];
 800af42:	edd3 6a01 	vldr	s13, [r3, #4]
        for (j = 0; j < n2; j++) {
 800af46:	f77f ae59 	ble.w	800abfc <cblas_strsm+0x1c4>
 800af4a:	9b03      	ldr	r3, [sp, #12]
 800af4c:	eb0e 0203 	add.w	r2, lr, r3
 800af50:	4673      	mov	r3, lr
          B[ldb * i + j] /= Aii;
 800af52:	ed93 7a00 	vldr	s14, [r3]
 800af56:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800af5a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800af5e:	4293      	cmp	r3, r2
 800af60:	d1f7      	bne.n	800af52 <cblas_strsm+0x51a>
 800af62:	e64b      	b.n	800abfc <cblas_strsm+0x1c4>
    for (i = 0; i < n1; i++) {
 800af64:	9a04      	ldr	r2, [sp, #16]
 800af66:	9b03      	ldr	r3, [sp, #12]
 800af68:	4491      	add	r9, r2
 800af6a:	4411      	add	r1, r2
 800af6c:	9a01      	ldr	r2, [sp, #4]
 800af6e:	3301      	adds	r3, #1
 800af70:	429a      	cmp	r2, r3
 800af72:	9303      	str	r3, [sp, #12]
 800af74:	f73f af36 	bgt.w	800ade4 <cblas_strsm+0x3ac>
 800af78:	b009      	add	sp, #36	; 0x24
 800af7a:	ecbd 8b02 	vpop	{d8}
 800af7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < n1; i++) {
 800af82:	9b02      	ldr	r3, [sp, #8]
 800af84:	f10e 0e01 	add.w	lr, lr, #1
 800af88:	4573      	cmp	r3, lr
 800af8a:	44b3      	add	fp, r6
 800af8c:	44b0      	add	r8, r6
 800af8e:	f73f aeb6 	bgt.w	800acfe <cblas_strsm+0x2c6>
 800af92:	e7f1      	b.n	800af78 <cblas_strsm+0x540>
        BASE Aii = A[lda * i + i];
 800af94:	9b02      	ldr	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 800af96:	2c00      	cmp	r4, #0
        BASE Aii = A[lda * i + i];
 800af98:	edd3 6a00 	vldr	s13, [r3]
        for (j = 0; j < n2; j++) {
 800af9c:	dd97      	ble.n	800aece <cblas_strsm+0x496>
 800af9e:	9b03      	ldr	r3, [sp, #12]
 800afa0:	eb03 020c 	add.w	r2, r3, ip
 800afa4:	4663      	mov	r3, ip
          B[ldb * i + j] /= Aii;
 800afa6:	ed93 7a00 	vldr	s14, [r3]
 800afaa:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800afae:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800afb2:	429a      	cmp	r2, r3
 800afb4:	d1f7      	bne.n	800afa6 <cblas_strsm+0x56e>
 800afb6:	e78a      	b.n	800aece <cblas_strsm+0x496>
    if (alpha != 1.0) {
 800afb8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800afbc:	eeb4 8a67 	vcmp.f32	s16, s15
 800afc0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800afc4:	f000 81d7 	beq.w	800b376 <cblas_strsm+0x93e>
      for (i = 0; i < n1; i++) {
 800afc8:	2d00      	cmp	r5, #0
 800afca:	ddd5      	ble.n	800af78 <cblas_strsm+0x540>
 800afcc:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800afd0:	00a3      	lsls	r3, r4, #2
 800afd2:	0080      	lsls	r0, r0, #2
 800afd4:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800afd8:	9303      	str	r3, [sp, #12]
 800afda:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800afde:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800afe0:	2c00      	cmp	r4, #0
 800afe2:	bfc8      	it	gt
 800afe4:	1883      	addgt	r3, r0, r2
 800afe6:	dd07      	ble.n	800aff8 <cblas_strsm+0x5c0>
          B[ldb * i + j] *= alpha;
 800afe8:	edd3 7a00 	vldr	s15, [r3]
 800afec:	ee67 7a88 	vmul.f32	s15, s15, s16
 800aff0:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800aff4:	429a      	cmp	r2, r3
 800aff6:	d1f7      	bne.n	800afe8 <cblas_strsm+0x5b0>
      for (i = 0; i < n1; i++) {
 800aff8:	3101      	adds	r1, #1
 800affa:	428d      	cmp	r5, r1
 800affc:	4432      	add	r2, r6
 800affe:	d1ef      	bne.n	800afe0 <cblas_strsm+0x5a8>
 800b000:	ebc9 7389 	rsb	r3, r9, r9, lsl #30
 800b004:	f107 0e01 	add.w	lr, r7, #1
 800b008:	009b      	lsls	r3, r3, #2
 800b00a:	43ff      	mvns	r7, r7
 800b00c:	00ba      	lsls	r2, r7, #2
 800b00e:	9305      	str	r3, [sp, #20]
 800b010:	9b03      	ldr	r3, [sp, #12]
 800b012:	9204      	str	r2, [sp, #16]
 800b014:	9a02      	ldr	r2, [sp, #8]
 800b016:	f105 3cff 	add.w	ip, r5, #4294967295
 800b01a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800b01e:	4443      	add	r3, r8
 800b020:	fb0c 2b0e 	mla	fp, ip, lr, r2
 800b024:	9302      	str	r3, [sp, #8]
 800b026:	3204      	adds	r2, #4
 800b028:	4663      	mov	r3, ip
 800b02a:	fb0c 8a06 	mla	sl, ip, r6, r8
 800b02e:	f1ae 0e04 	sub.w	lr, lr, #4
 800b032:	46a4      	mov	ip, r4
 800b034:	9206      	str	r2, [sp, #24]
 800b036:	461c      	mov	r4, r3
      if (nonunit) {
 800b038:	9b01      	ldr	r3, [sp, #4]
 800b03a:	2b83      	cmp	r3, #131	; 0x83
 800b03c:	d025      	beq.n	800b08a <cblas_strsm+0x652>
      for (k = 0; k < i; k++) {
 800b03e:	2c00      	cmp	r4, #0
 800b040:	d09a      	beq.n	800af78 <cblas_strsm+0x540>
 800b042:	9b06      	ldr	r3, [sp, #24]
 800b044:	9902      	ldr	r1, [sp, #8]
 800b046:	2700      	movs	r7, #0
 800b048:	463d      	mov	r5, r7
 800b04a:	eb03 0084 	add.w	r0, r3, r4, lsl #2
        for (j = 0; j < n2; j++) {
 800b04e:	f1bc 0f00 	cmp.w	ip, #0
        const BASE Aki = A[k * lda + i];
 800b052:	ed50 6a01 	vldr	s13, [r0, #-4]
        for (j = 0; j < n2; j++) {
 800b056:	dd0c      	ble.n	800b072 <cblas_strsm+0x63a>
 800b058:	eb08 0387 	add.w	r3, r8, r7, lsl #2
 800b05c:	4652      	mov	r2, sl
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 800b05e:	edd3 7a00 	vldr	s15, [r3]
 800b062:	ecb2 7a01 	vldmia	r2!, {s14}
 800b066:	eee7 7a66 	vfms.f32	s15, s14, s13
 800b06a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b06e:	428b      	cmp	r3, r1
 800b070:	d1f5      	bne.n	800b05e <cblas_strsm+0x626>
      for (k = 0; k < i; k++) {
 800b072:	3501      	adds	r5, #1
 800b074:	42ac      	cmp	r4, r5
 800b076:	4470      	add	r0, lr
 800b078:	444f      	add	r7, r9
 800b07a:	4431      	add	r1, r6
 800b07c:	d1e7      	bne.n	800b04e <cblas_strsm+0x616>
 800b07e:	9b05      	ldr	r3, [sp, #20]
 800b080:	449a      	add	sl, r3
 800b082:	9b04      	ldr	r3, [sp, #16]
 800b084:	3c01      	subs	r4, #1
 800b086:	449b      	add	fp, r3
 800b088:	e7d6      	b.n	800b038 <cblas_strsm+0x600>
        for (j = 0; j < n2; j++) {
 800b08a:	f1bc 0f00 	cmp.w	ip, #0
        BASE Aii = A[lda * i + i];
 800b08e:	eddb 6a00 	vldr	s13, [fp]
        for (j = 0; j < n2; j++) {
 800b092:	ddd4      	ble.n	800b03e <cblas_strsm+0x606>
 800b094:	9b03      	ldr	r3, [sp, #12]
 800b096:	eb03 020a 	add.w	r2, r3, sl
 800b09a:	4653      	mov	r3, sl
          B[ldb * i + j] /= Aii;
 800b09c:	ed93 7a00 	vldr	s14, [r3]
 800b0a0:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800b0a4:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b0a8:	429a      	cmp	r2, r3
 800b0aa:	d1f7      	bne.n	800b09c <cblas_strsm+0x664>
 800b0ac:	e7c7      	b.n	800b03e <cblas_strsm+0x606>
    if (alpha != 1.0) {
 800b0ae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800b0b2:	eeb4 8a67 	vcmp.f32	s16, s15
 800b0b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b0ba:	f000 8154 	beq.w	800b366 <cblas_strsm+0x92e>
      for (i = 0; i < n1; i++) {
 800b0be:	2d00      	cmp	r5, #0
 800b0c0:	f77f af5a 	ble.w	800af78 <cblas_strsm+0x540>
 800b0c4:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800b0c8:	00a3      	lsls	r3, r4, #2
 800b0ca:	0080      	lsls	r0, r0, #2
 800b0cc:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b0d0:	9303      	str	r3, [sp, #12]
 800b0d2:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800b0d6:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800b0d8:	2c00      	cmp	r4, #0
 800b0da:	bfc8      	it	gt
 800b0dc:	1883      	addgt	r3, r0, r2
 800b0de:	dd07      	ble.n	800b0f0 <cblas_strsm+0x6b8>
          B[ldb * i + j] *= alpha;
 800b0e0:	edd3 7a00 	vldr	s15, [r3]
 800b0e4:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b0e8:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b0ec:	429a      	cmp	r2, r3
 800b0ee:	d1f7      	bne.n	800b0e0 <cblas_strsm+0x6a8>
      for (i = 0; i < n1; i++) {
 800b0f0:	3101      	adds	r1, #1
 800b0f2:	428d      	cmp	r5, r1
 800b0f4:	4432      	add	r2, r6
 800b0f6:	d1ef      	bne.n	800b0d8 <cblas_strsm+0x6a0>
 800b0f8:	3701      	adds	r7, #1
 800b0fa:	9902      	ldr	r1, [sp, #8]
 800b0fc:	9104      	str	r1, [sp, #16]
 800b0fe:	00bb      	lsls	r3, r7, #2
 800b100:	f1a3 0e04 	sub.w	lr, r3, #4
 800b104:	9306      	str	r3, [sp, #24]
 800b106:	eb04 0309 	add.w	r3, r4, r9
 800b10a:	2200      	movs	r2, #0
 800b10c:	eb01 000e 	add.w	r0, r1, lr
 800b110:	009b      	lsls	r3, r3, #2
 800b112:	9205      	str	r2, [sp, #20]
 800b114:	9002      	str	r0, [sp, #8]
 800b116:	9307      	str	r3, [sp, #28]
 800b118:	4693      	mov	fp, r2
 800b11a:	46c2      	mov	sl, r8
      if (nonunit) {
 800b11c:	9b01      	ldr	r3, [sp, #4]
 800b11e:	2b83      	cmp	r3, #131	; 0x83
 800b120:	d02e      	beq.n	800b180 <cblas_strsm+0x748>
      for (k = i + 1; k < n1; k++) {
 800b122:	f10b 0b01 	add.w	fp, fp, #1
 800b126:	455d      	cmp	r5, fp
 800b128:	f77f af26 	ble.w	800af78 <cblas_strsm+0x540>
 800b12c:	9b05      	ldr	r3, [sp, #20]
 800b12e:	9f02      	ldr	r7, [sp, #8]
 800b130:	444b      	add	r3, r9
 800b132:	9305      	str	r3, [sp, #20]
 800b134:	469c      	mov	ip, r3
 800b136:	9b07      	ldr	r3, [sp, #28]
 800b138:	4658      	mov	r0, fp
 800b13a:	eb0a 0103 	add.w	r1, sl, r3
        for (j = 0; j < n2; j++) {
 800b13e:	2c00      	cmp	r4, #0
        const BASE Aki = A[k * lda + i];
 800b140:	edd7 6a00 	vldr	s13, [r7]
        for (j = 0; j < n2; j++) {
 800b144:	dd0c      	ble.n	800b160 <cblas_strsm+0x728>
 800b146:	eb08 038c 	add.w	r3, r8, ip, lsl #2
 800b14a:	4652      	mov	r2, sl
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 800b14c:	edd3 7a00 	vldr	s15, [r3]
 800b150:	ecb2 7a01 	vldmia	r2!, {s14}
 800b154:	eee7 7a66 	vfms.f32	s15, s14, s13
 800b158:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b15c:	4299      	cmp	r1, r3
 800b15e:	d1f5      	bne.n	800b14c <cblas_strsm+0x714>
      for (k = i + 1; k < n1; k++) {
 800b160:	3001      	adds	r0, #1
 800b162:	4285      	cmp	r5, r0
 800b164:	4477      	add	r7, lr
 800b166:	44cc      	add	ip, r9
 800b168:	4431      	add	r1, r6
 800b16a:	d1e8      	bne.n	800b13e <cblas_strsm+0x706>
 800b16c:	9a02      	ldr	r2, [sp, #8]
 800b16e:	9b06      	ldr	r3, [sp, #24]
 800b170:	4611      	mov	r1, r2
 800b172:	9a04      	ldr	r2, [sp, #16]
 800b174:	4419      	add	r1, r3
 800b176:	441a      	add	r2, r3
 800b178:	9102      	str	r1, [sp, #8]
 800b17a:	44b2      	add	sl, r6
 800b17c:	9204      	str	r2, [sp, #16]
 800b17e:	e7cd      	b.n	800b11c <cblas_strsm+0x6e4>
        BASE Aii = A[lda * i + i];
 800b180:	9b04      	ldr	r3, [sp, #16]
        for (j = 0; j < n2; j++) {
 800b182:	2c00      	cmp	r4, #0
        BASE Aii = A[lda * i + i];
 800b184:	edd3 6a00 	vldr	s13, [r3]
        for (j = 0; j < n2; j++) {
 800b188:	ddcb      	ble.n	800b122 <cblas_strsm+0x6ea>
 800b18a:	9b03      	ldr	r3, [sp, #12]
 800b18c:	eb0a 0203 	add.w	r2, sl, r3
 800b190:	4653      	mov	r3, sl
          B[ldb * i + j] /= Aii;
 800b192:	ed93 7a00 	vldr	s14, [r3]
 800b196:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800b19a:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b19e:	4293      	cmp	r3, r2
 800b1a0:	d1f7      	bne.n	800b192 <cblas_strsm+0x75a>
 800b1a2:	e7be      	b.n	800b122 <cblas_strsm+0x6ea>
    if (alpha != 1.0) {
 800b1a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800b1a8:	eeb4 8a67 	vcmp.f32	s16, s15
 800b1ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b1b0:	f000 8101 	beq.w	800b3b6 <cblas_strsm+0x97e>
      for (i = 0; i < n1; i++) {
 800b1b4:	2d00      	cmp	r5, #0
 800b1b6:	f77f aedf 	ble.w	800af78 <cblas_strsm+0x540>
 800b1ba:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800b1be:	00a3      	lsls	r3, r4, #2
 800b1c0:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b1c4:	0080      	lsls	r0, r0, #2
 800b1c6:	9303      	str	r3, [sp, #12]
 800b1c8:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800b1cc:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800b1ce:	2c00      	cmp	r4, #0
 800b1d0:	bfc8      	it	gt
 800b1d2:	1813      	addgt	r3, r2, r0
 800b1d4:	dd07      	ble.n	800b1e6 <cblas_strsm+0x7ae>
          B[ldb * i + j] *= alpha;
 800b1d6:	edd3 7a00 	vldr	s15, [r3]
 800b1da:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b1de:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b1e2:	4293      	cmp	r3, r2
 800b1e4:	d1f7      	bne.n	800b1d6 <cblas_strsm+0x79e>
      for (i = 0; i < n1; i++) {
 800b1e6:	3101      	adds	r1, #1
 800b1e8:	428d      	cmp	r5, r1
 800b1ea:	4432      	add	r2, r6
 800b1ec:	d1ef      	bne.n	800b1ce <cblas_strsm+0x796>
 800b1ee:	9b03      	ldr	r3, [sp, #12]
 800b1f0:	f8dd a004 	ldr.w	sl, [sp, #4]
 800b1f4:	9501      	str	r5, [sp, #4]
 800b1f6:	3701      	adds	r7, #1
 800b1f8:	4443      	add	r3, r8
 800b1fa:	4640      	mov	r0, r8
 800b1fc:	4619      	mov	r1, r3
 800b1fe:	00bf      	lsls	r7, r7, #2
          for (k = j + 1; k < n2; k++) {
 800b200:	f04f 0b00 	mov.w	fp, #0
      for (j = 0; j < n2; j++) {
 800b204:	2c00      	cmp	r4, #0
 800b206:	dd27      	ble.n	800b258 <cblas_strsm+0x820>
 800b208:	9b02      	ldr	r3, [sp, #8]
 800b20a:	4680      	mov	r8, r0
 800b20c:	f103 0e04 	add.w	lr, r3, #4
 800b210:	4699      	mov	r9, r3
 800b212:	4684      	mov	ip, r0
 800b214:	2500      	movs	r5, #0
        if (nonunit) {
 800b216:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 800b21a:	d107      	bne.n	800b22c <cblas_strsm+0x7f4>
          B[ldb * i + j] /= Ajj;
 800b21c:	edd8 6a00 	vldr	s13, [r8]
 800b220:	ed99 7a00 	vldr	s14, [r9]
 800b224:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b228:	edc8 7a00 	vstr	s15, [r8]
          for (k = j + 1; k < n2; k++) {
 800b22c:	3501      	adds	r5, #1
 800b22e:	42ac      	cmp	r4, r5
          BASE Bij = B[ldb * i + j];
 800b230:	ecfc 6a01 	vldmia	ip!, {s13}
          for (k = j + 1; k < n2; k++) {
 800b234:	d010      	beq.n	800b258 <cblas_strsm+0x820>
 800b236:	4672      	mov	r2, lr
 800b238:	4663      	mov	r3, ip
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 800b23a:	edd3 7a00 	vldr	s15, [r3]
 800b23e:	ecb2 7a01 	vldmia	r2!, {s14}
 800b242:	eee7 7a66 	vfms.f32	s15, s14, s13
 800b246:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = j + 1; k < n2; k++) {
 800b24a:	428b      	cmp	r3, r1
 800b24c:	d1f5      	bne.n	800b23a <cblas_strsm+0x802>
 800b24e:	44be      	add	lr, r7
 800b250:	44b9      	add	r9, r7
 800b252:	f108 0804 	add.w	r8, r8, #4
 800b256:	e7de      	b.n	800b216 <cblas_strsm+0x7de>
    for (i = 0; i < n1; i++) {
 800b258:	9b01      	ldr	r3, [sp, #4]
 800b25a:	f10b 0b01 	add.w	fp, fp, #1
 800b25e:	455b      	cmp	r3, fp
 800b260:	4430      	add	r0, r6
 800b262:	4431      	add	r1, r6
 800b264:	dcce      	bgt.n	800b204 <cblas_strsm+0x7cc>
 800b266:	e687      	b.n	800af78 <cblas_strsm+0x540>
    if (alpha != 1.0) {
 800b268:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 800b26c:	eeb4 8a67 	vcmp.f32	s16, s15
 800b270:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800b274:	f000 8097 	beq.w	800b3a6 <cblas_strsm+0x96e>
      for (i = 0; i < n1; i++) {
 800b278:	2d00      	cmp	r5, #0
 800b27a:	f77f ae7d 	ble.w	800af78 <cblas_strsm+0x540>
 800b27e:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800b282:	00a3      	lsls	r3, r4, #2
 800b284:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b288:	0080      	lsls	r0, r0, #2
 800b28a:	9303      	str	r3, [sp, #12]
 800b28c:	eb08 0284 	add.w	r2, r8, r4, lsl #2
 800b290:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
 800b292:	2c00      	cmp	r4, #0
 800b294:	bfc8      	it	gt
 800b296:	1813      	addgt	r3, r2, r0
 800b298:	dd07      	ble.n	800b2aa <cblas_strsm+0x872>
          B[ldb * i + j] *= alpha;
 800b29a:	edd3 7a00 	vldr	s15, [r3]
 800b29e:	ee67 7a88 	vmul.f32	s15, s15, s16
 800b2a2:	ece3 7a01 	vstmia	r3!, {s15}
        for (j = 0; j < n2; j++) {
 800b2a6:	4293      	cmp	r3, r2
 800b2a8:	d1f7      	bne.n	800b29a <cblas_strsm+0x862>
      for (i = 0; i < n1; i++) {
 800b2aa:	3101      	adds	r1, #1
 800b2ac:	428d      	cmp	r5, r1
 800b2ae:	4432      	add	r2, r6
 800b2b0:	d1ef      	bne.n	800b292 <cblas_strsm+0x85a>
 800b2b2:	1e63      	subs	r3, r4, #1
 800b2b4:	fb07 f203 	mul.w	r2, r7, r3
 800b2b8:	fb07 3c03 	mla	ip, r7, r3, r3
 800b2bc:	9b03      	ldr	r3, [sp, #12]
 800b2be:	9902      	ldr	r1, [sp, #8]
 800b2c0:	f8dd e004 	ldr.w	lr, [sp, #4]
 800b2c4:	9401      	str	r4, [sp, #4]
 800b2c6:	4443      	add	r3, r8
 800b2c8:	4699      	mov	r9, r3
 800b2ca:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 800b2ce:	ebc7 7a87 	rsb	sl, r7, r7, lsl #30
 800b2d2:	9302      	str	r3, [sp, #8]
 800b2d4:	43ff      	mvns	r7, r7
 800b2d6:	eb01 038c 	add.w	r3, r1, ip, lsl #2
 800b2da:	4640      	mov	r0, r8
 800b2dc:	9303      	str	r3, [sp, #12]
 800b2de:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800b2e2:	ea4f 0887 	mov.w	r8, r7, lsl #2
      for (j = n2; j > 0 && j--;) {
 800b2e6:	f04f 0b00 	mov.w	fp, #0
 800b2ea:	9b01      	ldr	r3, [sp, #4]
 800b2ec:	2b00      	cmp	r3, #0
 800b2ee:	dd23      	ble.n	800b338 <cblas_strsm+0x900>
 800b2f0:	f8dd c00c 	ldr.w	ip, [sp, #12]
 800b2f4:	9c02      	ldr	r4, [sp, #8]
 800b2f6:	464f      	mov	r7, r9
 800b2f8:	4649      	mov	r1, r9
        if (nonunit) {
 800b2fa:	f1be 0f83 	cmp.w	lr, #131	; 0x83
 800b2fe:	d107      	bne.n	800b310 <cblas_strsm+0x8d8>
          B[ldb * i + j] /= Ajj;
 800b300:	ed57 6a01 	vldr	s13, [r7, #-4]
 800b304:	ed9c 7a00 	vldr	s14, [ip]
 800b308:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b30c:	ed47 7a01 	vstr	s15, [r7, #-4]
          BASE Bij = B[ldb * i + j];
 800b310:	ed71 6a01 	vldmdb	r1!, {s13}
          for (k = 0; k < j; k++) {
 800b314:	4281      	cmp	r1, r0
 800b316:	d00f      	beq.n	800b338 <cblas_strsm+0x900>
 800b318:	4622      	mov	r2, r4
 800b31a:	4603      	mov	r3, r0
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 800b31c:	edd3 7a00 	vldr	s15, [r3]
 800b320:	ecb2 7a01 	vldmia	r2!, {s14}
 800b324:	eee7 7a66 	vfms.f32	s15, s14, s13
 800b328:	ece3 7a01 	vstmia	r3!, {s15}
          for (k = 0; k < j; k++) {
 800b32c:	428b      	cmp	r3, r1
 800b32e:	d1f5      	bne.n	800b31c <cblas_strsm+0x8e4>
 800b330:	4454      	add	r4, sl
 800b332:	44c4      	add	ip, r8
 800b334:	3f04      	subs	r7, #4
 800b336:	e7e0      	b.n	800b2fa <cblas_strsm+0x8c2>
    for (i = 0; i < n1; i++) {
 800b338:	f10b 0b01 	add.w	fp, fp, #1
 800b33c:	455d      	cmp	r5, fp
 800b33e:	4430      	add	r0, r6
 800b340:	44b1      	add	r9, r6
 800b342:	dcd2      	bgt.n	800b2ea <cblas_strsm+0x8b2>
 800b344:	e618      	b.n	800af78 <cblas_strsm+0x540>
    for (i = 0; i < n1; i++) {
 800b346:	2d00      	cmp	r5, #0
 800b348:	f77f ae16 	ble.w	800af78 <cblas_strsm+0x540>
 800b34c:	00a3      	lsls	r3, r4, #2
 800b34e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b352:	9303      	str	r3, [sp, #12]
 800b354:	e531      	b.n	800adba <cblas_strsm+0x382>
    for (i = n1; i > 0 && i--;) {
 800b356:	2d00      	cmp	r5, #0
 800b358:	f77f ae0e 	ble.w	800af78 <cblas_strsm+0x540>
 800b35c:	00a3      	lsls	r3, r4, #2
 800b35e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b362:	9303      	str	r3, [sp, #12]
 800b364:	e41f      	b.n	800aba6 <cblas_strsm+0x16e>
    for (i = 0; i < n1; i++) {
 800b366:	2d00      	cmp	r5, #0
 800b368:	f77f ae06 	ble.w	800af78 <cblas_strsm+0x540>
 800b36c:	00a3      	lsls	r3, r4, #2
 800b36e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b372:	9303      	str	r3, [sp, #12]
 800b374:	e6c0      	b.n	800b0f8 <cblas_strsm+0x6c0>
    for (i = n1; i > 0 && i--;) {
 800b376:	2d00      	cmp	r5, #0
 800b378:	f77f adfe 	ble.w	800af78 <cblas_strsm+0x540>
 800b37c:	00a3      	lsls	r3, r4, #2
 800b37e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b382:	9303      	str	r3, [sp, #12]
 800b384:	e63c      	b.n	800b000 <cblas_strsm+0x5c8>
    for (i = 0; i < n1; i++) {
 800b386:	2d00      	cmp	r5, #0
 800b388:	f77f adf6 	ble.w	800af78 <cblas_strsm+0x540>
 800b38c:	00a3      	lsls	r3, r4, #2
 800b38e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b392:	9303      	str	r3, [sp, #12]
 800b394:	e587      	b.n	800aea6 <cblas_strsm+0x46e>
    for (i = 0; i < n1; i++) {
 800b396:	2d00      	cmp	r5, #0
 800b398:	f77f adee 	ble.w	800af78 <cblas_strsm+0x540>
 800b39c:	00a3      	lsls	r3, r4, #2
 800b39e:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b3a2:	9303      	str	r3, [sp, #12]
 800b3a4:	e495      	b.n	800acd2 <cblas_strsm+0x29a>
    for (i = 0; i < n1; i++) {
 800b3a6:	2d00      	cmp	r5, #0
 800b3a8:	f77f ade6 	ble.w	800af78 <cblas_strsm+0x540>
 800b3ac:	00a3      	lsls	r3, r4, #2
 800b3ae:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b3b2:	9303      	str	r3, [sp, #12]
 800b3b4:	e77d      	b.n	800b2b2 <cblas_strsm+0x87a>
    for (i = 0; i < n1; i++) {
 800b3b6:	2d00      	cmp	r5, #0
 800b3b8:	f77f adde 	ble.w	800af78 <cblas_strsm+0x540>
 800b3bc:	00a3      	lsls	r3, r4, #2
 800b3be:	ea4f 0689 	mov.w	r6, r9, lsl #2
 800b3c2:	9303      	str	r3, [sp, #12]
 800b3c4:	e713      	b.n	800b1ee <cblas_strsm+0x7b6>
 800b3c6:	bf00      	nop

0800b3c8 <cblas_strsv>:
void
cblas_strsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const float *A, const int lda, float *X,
             const int incX)
{
 800b3c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b3cc:	b083      	sub	sp, #12

{
  const int nonunit = (Diag == CblasNonUnit);
  INDEX ix, jx;
  INDEX i, j;
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 800b3ce:	2a71      	cmp	r2, #113	; 0x71
 800b3d0:	e9dd 580c 	ldrd	r5, r8, [sp, #48]	; 0x30
 800b3d4:	e9dd 790e 	ldrd	r7, r9, [sp, #56]	; 0x38
 800b3d8:	9c10      	ldr	r4, [sp, #64]	; 0x40
 800b3da:	4683      	mov	fp, r0
 800b3dc:	468a      	mov	sl, r1
 800b3de:	461e      	mov	r6, r3
 800b3e0:	f000 80c2 	beq.w	800b568 <cblas_strsv+0x1a0>

  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b3e4:	3979      	subs	r1, #121	; 0x79
 800b3e6:	2901      	cmp	r1, #1
 800b3e8:	4613      	mov	r3, r2
 800b3ea:	d93c      	bls.n	800b466 <cblas_strsv+0x9e>
 800b3ec:	2002      	movs	r0, #2
 800b3ee:	3a6f      	subs	r2, #111	; 0x6f
 800b3f0:	2a02      	cmp	r2, #2
 800b3f2:	bf88      	it	hi
 800b3f4:	2003      	movhi	r0, #3
 800b3f6:	f106 027d 	add.w	r2, r6, #125	; 0x7d
 800b3fa:	b2d2      	uxtb	r2, r2
 800b3fc:	2a01      	cmp	r2, #1
 800b3fe:	f240 80a3 	bls.w	800b548 <cblas_strsv+0x180>
 800b402:	2d00      	cmp	r5, #0
 800b404:	f2c0 8098 	blt.w	800b538 <cblas_strsv+0x170>
 800b408:	2d01      	cmp	r5, #1
 800b40a:	462a      	mov	r2, r5
 800b40c:	bfb8      	it	lt
 800b40e:	2201      	movlt	r2, #1
 800b410:	4297      	cmp	r7, r2
 800b412:	f280 8120 	bge.w	800b656 <cblas_strsv+0x28e>
 800b416:	2c00      	cmp	r4, #0
 800b418:	bf0c      	ite	eq
 800b41a:	2009      	moveq	r0, #9
 800b41c:	2007      	movne	r0, #7
 800b41e:	4abb      	ldr	r2, [pc, #748]	; (800b70c <cblas_strsv+0x344>)
 800b420:	49bb      	ldr	r1, [pc, #748]	; (800b710 <cblas_strsv+0x348>)
 800b422:	9300      	str	r3, [sp, #0]
 800b424:	f01c fb10 	bl	8027a48 <cblas_xerbla>
 800b428:	9b00      	ldr	r3, [sp, #0]

  if (N == 0)
 800b42a:	2d00      	cmp	r5, #0
 800b42c:	f000 8081 	beq.w	800b532 <cblas_strsv+0x16a>
    return;

  /* form  x := inv( A )*x */

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800b430:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 800b434:	f000 80a0 	beq.w	800b578 <cblas_strsv+0x1b0>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800b438:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 800b43c:	d10b      	bne.n	800b456 <cblas_strsv+0x8e>
 800b43e:	2b70      	cmp	r3, #112	; 0x70
 800b440:	d017      	beq.n	800b472 <cblas_strsv+0xaa>
        X[ix] = tmp;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 800b442:	2b6f      	cmp	r3, #111	; 0x6f
 800b444:	d107      	bne.n	800b456 <cblas_strsv+0x8e>
 800b446:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b44a:	f000 8165 	beq.w	800b718 <cblas_strsv+0x350>
        X[ix] = tmp;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 800b44e:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b452:	f000 809e 	beq.w	800b592 <cblas_strsv+0x1ca>
        X[ix] = tmp;
      }
      ix -= incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 800b456:	4aaf      	ldr	r2, [pc, #700]	; (800b714 <cblas_strsv+0x34c>)
 800b458:	49ad      	ldr	r1, [pc, #692]	; (800b710 <cblas_strsv+0x348>)
 800b45a:	2000      	movs	r0, #0
#define BASE float
#include "source_trsv_r.h"
#undef BASE
}
 800b45c:	b003      	add	sp, #12
 800b45e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b462:	f01c baf1 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b466:	3865      	subs	r0, #101	; 0x65
 800b468:	2801      	cmp	r0, #1
 800b46a:	bf94      	ite	ls
 800b46c:	2000      	movls	r0, #0
 800b46e:	2001      	movhi	r0, #1
 800b470:	e7bd      	b.n	800b3ee <cblas_strsv+0x26>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 800b472:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b476:	f040 813d 	bne.w	800b6f4 <cblas_strsv+0x32c>
    ix = OFFSET(N, incX) + incX * (N - 1);
 800b47a:	2c00      	cmp	r4, #0
 800b47c:	bfd8      	it	le
 800b47e:	4260      	negle	r0, r4
 800b480:	f105 32ff 	add.w	r2, r5, #4294967295
 800b484:	bfcc      	ite	gt
 800b486:	2000      	movgt	r0, #0
 800b488:	4350      	mulle	r0, r2
    if (nonunit) {
 800b48a:	2e83      	cmp	r6, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 800b48c:	fb02 0004 	mla	r0, r2, r4, r0
    if (nonunit) {
 800b490:	d10d      	bne.n	800b4ae <cblas_strsv+0xe6>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 800b492:	fb02 2307 	mla	r3, r2, r7, r2
 800b496:	eb09 0180 	add.w	r1, r9, r0, lsl #2
 800b49a:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800b49e:	ed93 7a00 	vldr	s14, [r3]
 800b4a2:	edd1 6a00 	vldr	s13, [r1]
 800b4a6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b4aa:	edc1 7a00 	vstr	s15, [r1]
    for (i = N - 1; i > 0 && i--;) {
 800b4ae:	2a00      	cmp	r2, #0
 800b4b0:	dd3f      	ble.n	800b532 <cblas_strsv+0x16a>
 800b4b2:	f102 3eff 	add.w	lr, r2, #4294967295
 800b4b6:	fb07 f30e 	mul.w	r3, r7, lr
 800b4ba:	1899      	adds	r1, r3, r2
 800b4bc:	fb07 ee0e 	mla	lr, r7, lr, lr
 800b4c0:	ebc1 7a81 	rsb	sl, r1, r1, lsl #30
 800b4c4:	ea6f 0c07 	mvn.w	ip, r7
 800b4c8:	442b      	add	r3, r5
 800b4ca:	ebc7 7787 	rsb	r7, r7, r7, lsl #30
 800b4ce:	eb09 0980 	add.w	r9, r9, r0, lsl #2
 800b4d2:	ebc4 7084 	rsb	r0, r4, r4, lsl #30
 800b4d6:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800b4da:	eb08 0b83 	add.w	fp, r8, r3, lsl #2
 800b4de:	eb08 0181 	add.w	r1, r8, r1, lsl #2
 800b4e2:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800b4e6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800b4ea:	00bf      	lsls	r7, r7, #2
 800b4ec:	0080      	lsls	r0, r0, #2
 800b4ee:	00a4      	lsls	r4, r4, #2
      BASE tmp = X[ix];
 800b4f0:	eb09 0300 	add.w	r3, r9, r0
      for (j = i + 1; j < N; j++) {
 800b4f4:	4295      	cmp	r5, r2
      BASE tmp = X[ix];
 800b4f6:	edd3 7a00 	vldr	s15, [r3]
      for (j = i + 1; j < N; j++) {
 800b4fa:	bfc8      	it	gt
 800b4fc:	4688      	movgt	r8, r1
 800b4fe:	dd08      	ble.n	800b512 <cblas_strsv+0x14a>
        const BASE Aij = A[lda * i + j];
 800b500:	ecb8 7a01 	vldmia	r8!, {s14}
        tmp -= Aij * X[jx];
 800b504:	edd9 6a00 	vldr	s13, [r9]
      for (j = i + 1; j < N; j++) {
 800b508:	45c3      	cmp	fp, r8
        tmp -= Aij * X[jx];
 800b50a:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = i + 1; j < N; j++) {
 800b50e:	44a1      	add	r9, r4
 800b510:	d1f6      	bne.n	800b500 <cblas_strsv+0x138>
      if (nonunit) {
 800b512:	2e83      	cmp	r6, #131	; 0x83
 800b514:	d106      	bne.n	800b524 <cblas_strsv+0x15c>
        X[ix] = tmp / A[lda * i + i];
 800b516:	eb0a 0801 	add.w	r8, sl, r1
 800b51a:	44f0      	add	r8, lr
 800b51c:	ed98 7a00 	vldr	s14, [r8]
 800b520:	eec7 7a87 	vdiv.f32	s15, s15, s14
    for (i = N - 1; i > 0 && i--;) {
 800b524:	3a01      	subs	r2, #1
 800b526:	4461      	add	r1, ip
 800b528:	44bb      	add	fp, r7
 800b52a:	4699      	mov	r9, r3
 800b52c:	edc3 7a00 	vstr	s15, [r3]
 800b530:	d1de      	bne.n	800b4f0 <cblas_strsv+0x128>
 800b532:	b003      	add	sp, #12
 800b534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b538:	2f00      	cmp	r7, #0
 800b53a:	f77f af6c 	ble.w	800b416 <cblas_strsv+0x4e>
 800b53e:	2c00      	cmp	r4, #0
 800b540:	bf0c      	ite	eq
 800b542:	2009      	moveq	r0, #9
 800b544:	2005      	movne	r0, #5
 800b546:	e76a      	b.n	800b41e <cblas_strsv+0x56>
 800b548:	2d00      	cmp	r5, #0
 800b54a:	dbf5      	blt.n	800b538 <cblas_strsv+0x170>
 800b54c:	2d01      	cmp	r5, #1
 800b54e:	462a      	mov	r2, r5
 800b550:	bfb8      	it	lt
 800b552:	2201      	movlt	r2, #1
 800b554:	42ba      	cmp	r2, r7
 800b556:	f73f af5e 	bgt.w	800b416 <cblas_strsv+0x4e>
 800b55a:	2c00      	cmp	r4, #0
 800b55c:	f000 811e 	beq.w	800b79c <cblas_strsv+0x3d4>
 800b560:	2800      	cmp	r0, #0
 800b562:	f43f af62 	beq.w	800b42a <cblas_strsv+0x62>
 800b566:	e75a      	b.n	800b41e <cblas_strsv+0x56>
 800b568:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
 800b56c:	2b01      	cmp	r3, #1
 800b56e:	f240 80c6 	bls.w	800b6fe <cblas_strsv+0x336>
 800b572:	2370      	movs	r3, #112	; 0x70
 800b574:	2002      	movs	r0, #2
 800b576:	e73e      	b.n	800b3f6 <cblas_strsv+0x2e>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800b578:	2b6f      	cmp	r3, #111	; 0x6f
 800b57a:	d071      	beq.n	800b660 <cblas_strsv+0x298>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 800b57c:	2b70      	cmp	r3, #112	; 0x70
 800b57e:	f47f af6a 	bne.w	800b456 <cblas_strsv+0x8e>
 800b582:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b586:	f000 80c7 	beq.w	800b718 <cblas_strsv+0x350>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 800b58a:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b58e:	f47f af62 	bne.w	800b456 <cblas_strsv+0x8e>
    ix = OFFSET(N, incX) + (N - 1) * incX;
 800b592:	2c00      	cmp	r4, #0
 800b594:	bfd8      	it	le
 800b596:	4263      	negle	r3, r4
 800b598:	f105 3cff 	add.w	ip, r5, #4294967295
 800b59c:	bfcc      	ite	gt
 800b59e:	2300      	movgt	r3, #0
 800b5a0:	fb0c f303 	mulle.w	r3, ip, r3
    if (nonunit) {
 800b5a4:	2e83      	cmp	r6, #131	; 0x83
    ix = OFFSET(N, incX) + (N - 1) * incX;
 800b5a6:	fb0c 3304 	mla	r3, ip, r4, r3
    if (nonunit) {
 800b5aa:	d10d      	bne.n	800b5c8 <cblas_strsv+0x200>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 800b5ac:	fb0c c207 	mla	r2, ip, r7, ip
 800b5b0:	eb09 0183 	add.w	r1, r9, r3, lsl #2
 800b5b4:	eb08 0282 	add.w	r2, r8, r2, lsl #2
 800b5b8:	ed92 7a00 	vldr	s14, [r2]
 800b5bc:	edd1 6a00 	vldr	s13, [r1]
 800b5c0:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b5c4:	edc1 7a00 	vstr	s15, [r1]
    for (i = N - 1; i > 0 && i--;) {
 800b5c8:	f1bc 0f00 	cmp.w	ip, #0
    ix -= incX;
 800b5cc:	eba3 0304 	sub.w	r3, r3, r4
    for (i = N - 1; i > 0 && i--;) {
 800b5d0:	ddaf      	ble.n	800b532 <cblas_strsv+0x16a>
 800b5d2:	1c7a      	adds	r2, r7, #1
 800b5d4:	fb0c fa02 	mul.w	sl, ip, r2
 800b5d8:	ea6f 0e07 	mvn.w	lr, r7
 800b5dc:	0092      	lsls	r2, r2, #2
 800b5de:	f10c 37ff 	add.w	r7, ip, #4294967295
 800b5e2:	ebc4 7b84 	rsb	fp, r4, r4, lsl #30
 800b5e6:	ebca 7a8a 	rsb	sl, sl, sl, lsl #30
 800b5ea:	eb09 0983 	add.w	r9, r9, r3, lsl #2
 800b5ee:	fb02 f307 	mul.w	r3, r2, r7
 800b5f2:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800b5f6:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800b5fa:	fb0c 8802 	mla	r8, ip, r2, r8
 800b5fe:	1f10      	subs	r0, r2, #4
 800b600:	9300      	str	r3, [sp, #0]
 800b602:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800b606:	00a4      	lsls	r4, r4, #2
 800b608:	4663      	mov	r3, ip
      for (j = i + 1; j < N; j++) {
 800b60a:	429d      	cmp	r5, r3
      BASE tmp = X[ix];
 800b60c:	edd9 7a00 	vldr	s15, [r9]
    for (i = N - 1; i > 0 && i--;) {
 800b610:	46bc      	mov	ip, r7
      for (j = i + 1; j < N; j++) {
 800b612:	dd0d      	ble.n	800b630 <cblas_strsv+0x268>
 800b614:	eb04 0109 	add.w	r1, r4, r9
 800b618:	4642      	mov	r2, r8
        tmp -= Aji * X[jx];
 800b61a:	edd1 6a00 	vldr	s13, [r1]
 800b61e:	ed12 7a01 	vldr	s14, [r2, #-4]
      for (j = i + 1; j < N; j++) {
 800b622:	3301      	adds	r3, #1
 800b624:	429d      	cmp	r5, r3
        tmp -= Aji * X[jx];
 800b626:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = i + 1; j < N; j++) {
 800b62a:	4421      	add	r1, r4
 800b62c:	4402      	add	r2, r0
 800b62e:	d1f4      	bne.n	800b61a <cblas_strsv+0x252>
      if (nonunit) {
 800b630:	2e83      	cmp	r6, #131	; 0x83
 800b632:	d107      	bne.n	800b644 <cblas_strsv+0x27c>
        X[ix] = tmp / A[lda * i + i];
 800b634:	9a00      	ldr	r2, [sp, #0]
 800b636:	eb08 030a 	add.w	r3, r8, sl
 800b63a:	4413      	add	r3, r2
 800b63c:	ed93 7a00 	vldr	s14, [r3]
 800b640:	eec7 7a87 	vdiv.f32	s15, s15, s14
 800b644:	44f0      	add	r8, lr
 800b646:	edc9 7a00 	vstr	s15, [r9]
    for (i = N - 1; i > 0 && i--;) {
 800b64a:	44d9      	add	r9, fp
 800b64c:	2f00      	cmp	r7, #0
 800b64e:	f43f af70 	beq.w	800b532 <cblas_strsv+0x16a>
 800b652:	3f01      	subs	r7, #1
 800b654:	e7d8      	b.n	800b608 <cblas_strsv+0x240>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b656:	2c00      	cmp	r4, #0
 800b658:	bf0c      	ite	eq
 800b65a:	2009      	moveq	r0, #9
 800b65c:	2004      	movne	r0, #4
 800b65e:	e6de      	b.n	800b41e <cblas_strsv+0x56>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 800b660:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b664:	f43f af09 	beq.w	800b47a <cblas_strsv+0xb2>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 800b668:	f1ba 0f7a 	cmp.w	sl, #122	; 0x7a
 800b66c:	f47f aef3 	bne.w	800b456 <cblas_strsv+0x8e>
    ix = OFFSET(N, incX);
 800b670:	2c00      	cmp	r4, #0
 800b672:	f340 8095 	ble.w	800b7a0 <cblas_strsv+0x3d8>
 800b676:	46a4      	mov	ip, r4
 800b678:	2200      	movs	r2, #0
    if (nonunit) {
 800b67a:	2e83      	cmp	r6, #131	; 0x83
 800b67c:	d109      	bne.n	800b692 <cblas_strsv+0x2ca>
      X[ix] = X[ix] / A[lda * 0 + 0];
 800b67e:	eb09 0382 	add.w	r3, r9, r2, lsl #2
 800b682:	edd3 6a00 	vldr	s13, [r3]
 800b686:	ed98 7a00 	vldr	s14, [r8]
 800b68a:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b68e:	edc3 7a00 	vstr	s15, [r3]
    for (i = 1; i < N; i++) {
 800b692:	2d01      	cmp	r5, #1
 800b694:	f77f af4d 	ble.w	800b532 <cblas_strsv+0x16a>
 800b698:	1c7b      	adds	r3, r7, #1
 800b69a:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800b69e:	9200      	str	r2, [sp, #0]
 800b6a0:	009a      	lsls	r2, r3, #2
 800b6a2:	9201      	str	r2, [sp, #4]
 800b6a4:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 800b6a8:	00a0      	lsls	r0, r4, #2
 800b6aa:	46ba      	mov	sl, r7
 800b6ac:	f04f 0e01 	mov.w	lr, #1
      BASE tmp = X[ix];
 800b6b0:	eb09 0b8c 	add.w	fp, r9, ip, lsl #2
 800b6b4:	eddb 7a00 	vldr	s15, [fp]
 800b6b8:	9a00      	ldr	r2, [sp, #0]
 800b6ba:	eb08 018a 	add.w	r1, r8, sl, lsl #2
        const BASE Aij = A[lda * i + j];
 800b6be:	ecb1 7a01 	vldmia	r1!, {s14}
        tmp -= Aij * X[jx];
 800b6c2:	edd2 6a00 	vldr	s13, [r2]
      for (j = 0; j < i; j++) {
 800b6c6:	4299      	cmp	r1, r3
        tmp -= Aij * X[jx];
 800b6c8:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = 0; j < i; j++) {
 800b6cc:	4402      	add	r2, r0
 800b6ce:	d1f6      	bne.n	800b6be <cblas_strsv+0x2f6>
      if (nonunit) {
 800b6d0:	2e83      	cmp	r6, #131	; 0x83
        X[ix] = tmp / A[lda * i + i];
 800b6d2:	bf08      	it	eq
 800b6d4:	ed93 7a00 	vldreq	s14, [r3]
 800b6d8:	9a01      	ldr	r2, [sp, #4]
 800b6da:	bf08      	it	eq
 800b6dc:	eec7 7a87 	vdiveq.f32	s15, s15, s14
    for (i = 1; i < N; i++) {
 800b6e0:	f10e 0e01 	add.w	lr, lr, #1
 800b6e4:	4575      	cmp	r5, lr
      ix += incX;
 800b6e6:	44a4      	add	ip, r4
 800b6e8:	4413      	add	r3, r2
 800b6ea:	44ba      	add	sl, r7
 800b6ec:	edcb 7a00 	vstr	s15, [fp]
    for (i = 1; i < N; i++) {
 800b6f0:	d1de      	bne.n	800b6b0 <cblas_strsv+0x2e8>
 800b6f2:	e71e      	b.n	800b532 <cblas_strsv+0x16a>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 800b6f4:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
 800b6f8:	f47f aead 	bne.w	800b456 <cblas_strsv+0x8e>
 800b6fc:	e7b8      	b.n	800b670 <cblas_strsv+0x2a8>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b6fe:	3865      	subs	r0, #101	; 0x65
 800b700:	2801      	cmp	r0, #1
 800b702:	bf94      	ite	ls
 800b704:	2000      	movls	r0, #0
 800b706:	2001      	movhi	r0, #1
 800b708:	2370      	movs	r3, #112	; 0x70
 800b70a:	e674      	b.n	800b3f6 <cblas_strsv+0x2e>
 800b70c:	08030378 	.word	0x08030378
 800b710:	080306a0 	.word	0x080306a0
 800b714:	080305a8 	.word	0x080305a8
    ix = OFFSET(N, incX);
 800b718:	2c00      	cmp	r4, #0
 800b71a:	dd48      	ble.n	800b7ae <cblas_strsv+0x3e6>
 800b71c:	46a6      	mov	lr, r4
 800b71e:	2300      	movs	r3, #0
    if (nonunit) {
 800b720:	2e83      	cmp	r6, #131	; 0x83
 800b722:	d109      	bne.n	800b738 <cblas_strsv+0x370>
      X[ix] = X[ix] / A[lda * 0 + 0];
 800b724:	eb09 0283 	add.w	r2, r9, r3, lsl #2
 800b728:	edd2 6a00 	vldr	s13, [r2]
 800b72c:	ed98 7a00 	vldr	s14, [r8]
 800b730:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800b734:	edc2 7a00 	vstr	s15, [r2]
    for (i = 1; i < N; i++) {
 800b738:	2d01      	cmp	r5, #1
 800b73a:	f77f aefa 	ble.w	800b532 <cblas_strsv+0x16a>
 800b73e:	3701      	adds	r7, #1
 800b740:	00ba      	lsls	r2, r7, #2
 800b742:	1f17      	subs	r7, r2, #4
 800b744:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 800b748:	9201      	str	r2, [sp, #4]
 800b74a:	9300      	str	r3, [sp, #0]
 800b74c:	eb08 0b07 	add.w	fp, r8, r7
 800b750:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 800b754:	2001      	movs	r0, #1
      BASE tmp = X[ix];
 800b756:	eb09 0a8e 	add.w	sl, r9, lr, lsl #2
 800b75a:	edda 7a00 	vldr	s15, [sl]
 800b75e:	9a00      	ldr	r2, [sp, #0]
 800b760:	eb08 0180 	add.w	r1, r8, r0, lsl #2
 800b764:	2300      	movs	r3, #0
        tmp -= Aji * X[jx];
 800b766:	edd2 6a00 	vldr	s13, [r2]
 800b76a:	ed91 7a00 	vldr	s14, [r1]
      for (j = 0; j < i; j++) {
 800b76e:	3301      	adds	r3, #1
 800b770:	4283      	cmp	r3, r0
        tmp -= Aji * X[jx];
 800b772:	eee6 7ac7 	vfms.f32	s15, s13, s14
      for (j = 0; j < i; j++) {
 800b776:	4462      	add	r2, ip
 800b778:	4439      	add	r1, r7
 800b77a:	d1f4      	bne.n	800b766 <cblas_strsv+0x39e>
      if (nonunit) {
 800b77c:	2e83      	cmp	r6, #131	; 0x83
        X[ix] = tmp / A[lda * i + i];
 800b77e:	bf08      	it	eq
 800b780:	ed9b 7a01 	vldreq	s14, [fp, #4]
 800b784:	9b01      	ldr	r3, [sp, #4]
 800b786:	bf08      	it	eq
 800b788:	eec7 7a87 	vdiveq.f32	s15, s15, s14
    for (i = 1; i < N; i++) {
 800b78c:	3001      	adds	r0, #1
 800b78e:	4285      	cmp	r5, r0
      ix += incX;
 800b790:	44a6      	add	lr, r4
 800b792:	449b      	add	fp, r3
 800b794:	edca 7a00 	vstr	s15, [sl]
    for (i = 1; i < N; i++) {
 800b798:	d1dd      	bne.n	800b756 <cblas_strsv+0x38e>
 800b79a:	e6ca      	b.n	800b532 <cblas_strsv+0x16a>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 800b79c:	2009      	movs	r0, #9
 800b79e:	e63e      	b.n	800b41e <cblas_strsv+0x56>
    ix = OFFSET(N, incX);
 800b7a0:	f1c5 0201 	rsb	r2, r5, #1
 800b7a4:	fb02 f204 	mul.w	r2, r2, r4
 800b7a8:	eb04 0c02 	add.w	ip, r4, r2
 800b7ac:	e765      	b.n	800b67a <cblas_strsv+0x2b2>
    ix = OFFSET(N, incX);
 800b7ae:	f1c5 0301 	rsb	r3, r5, #1
 800b7b2:	fb03 f304 	mul.w	r3, r3, r4
 800b7b6:	eb04 0e03 	add.w	lr, r4, r3
 800b7ba:	e7b1      	b.n	800b720 <cblas_strsv+0x358>

0800b7bc <cblas_dasum>:
  if (incX <= 0) {
 800b7bc:	2a00      	cmp	r2, #0
 800b7be:	dd1a      	ble.n	800b7f6 <cblas_dasum+0x3a>
  for (i = 0; i < N; i++) {
 800b7c0:	2800      	cmp	r0, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dasum (const int N, const double *X, const int incX)
{
 800b7c2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b7c6:	4681      	mov	r9, r0
 800b7c8:	dd1a      	ble.n	800b800 <cblas_dasum+0x44>
 800b7ca:	460c      	mov	r4, r1
  BASE r = 0.0;
 800b7cc:	2000      	movs	r0, #0
 800b7ce:	2100      	movs	r1, #0
 800b7d0:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  for (i = 0; i < N; i++) {
 800b7d4:	2500      	movs	r5, #0
    r += fabs(X[ix]);
 800b7d6:	e9d4 6300 	ldrd	r6, r3, [r4]
 800b7da:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 800b7de:	4632      	mov	r2, r6
 800b7e0:	463b      	mov	r3, r7
  for (i = 0; i < N; i++) {
 800b7e2:	3501      	adds	r5, #1
    r += fabs(X[ix]);
 800b7e4:	f01c f9aa 	bl	8027b3c <__adddf3>
  for (i = 0; i < N; i++) {
 800b7e8:	45a9      	cmp	r9, r5
 800b7ea:	4444      	add	r4, r8
 800b7ec:	d1f3      	bne.n	800b7d6 <cblas_dasum+0x1a>
#define BASE double
#include "source_asum_r.h"
#undef BASE
}
 800b7ee:	ec41 0b10 	vmov	d0, r0, r1
 800b7f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return 0;
 800b7f6:	2000      	movs	r0, #0
 800b7f8:	2100      	movs	r1, #0
 800b7fa:	ec41 0b10 	vmov	d0, r0, r1
 800b7fe:	4770      	bx	lr
 800b800:	2000      	movs	r0, #0
 800b802:	2100      	movs	r1, #0
 800b804:	e7f3      	b.n	800b7ee <cblas_dasum+0x32>
 800b806:	bf00      	nop

0800b808 <cblas_daxpy>:
#include "cblas.h"

void
cblas_daxpy (const int N, const double alpha, const double *X, const int incX,
             double *Y, const int incY)
{
 800b808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800b80c:	ec55 4b10 	vmov	r4, r5, d0
 800b810:	b085      	sub	sp, #20
 800b812:	4607      	mov	r7, r0
 800b814:	468a      	mov	sl, r1
  if (alpha == 0.0) {
 800b816:	ee10 0a10 	vmov	r0, s0
 800b81a:	4691      	mov	r9, r2
 800b81c:	461e      	mov	r6, r3
 800b81e:	4629      	mov	r1, r5
 800b820:	2300      	movs	r3, #0
 800b822:	2200      	movs	r2, #0
 800b824:	f01c fda8 	bl	8028378 <__aeabi_dcmpeq>
 800b828:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800b82a:	bb78      	cbnz	r0, 800b88c <cblas_daxpy+0x84>
  if (incX == 1 && incY == 1) {
 800b82c:	f1b9 0f01 	cmp.w	r9, #1
 800b830:	d02f      	beq.n	800b892 <cblas_daxpy+0x8a>
    INDEX ix = OFFSET(N, incX);
 800b832:	f1b9 0f00 	cmp.w	r9, #0
 800b836:	bfdc      	itt	le
 800b838:	f1c7 0001 	rsble	r0, r7, #1
 800b83c:	fb00 f009 	mulle.w	r0, r0, r9
    INDEX iy = OFFSET(N, incY);
 800b840:	2b00      	cmp	r3, #0
 800b842:	bfda      	itte	le
 800b844:	f1c7 0201 	rsble	r2, r7, #1
 800b848:	435a      	mulle	r2, r3
 800b84a:	2200      	movgt	r2, #0
    for (i = 0; i < N; i++) {
 800b84c:	2f00      	cmp	r7, #0
 800b84e:	dd1d      	ble.n	800b88c <cblas_daxpy+0x84>
 800b850:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 800b854:	eb06 06c2 	add.w	r6, r6, r2, lsl #3
 800b858:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800b85c:	eb0a 0ac0 	add.w	sl, sl, r0, lsl #3
 800b860:	f04f 0b00 	mov.w	fp, #0
      Y[iy] += alpha * X[ix];
 800b864:	e9da 2300 	ldrd	r2, r3, [sl]
 800b868:	4620      	mov	r0, r4
 800b86a:	4629      	mov	r1, r5
 800b86c:	f01c fb1c 	bl	8027ea8 <__aeabi_dmul>
 800b870:	4602      	mov	r2, r0
 800b872:	460b      	mov	r3, r1
 800b874:	e9d6 0100 	ldrd	r0, r1, [r6]
 800b878:	f01c f960 	bl	8027b3c <__adddf3>
    for (i = 0; i < N; i++) {
 800b87c:	f10b 0b01 	add.w	fp, fp, #1
 800b880:	455f      	cmp	r7, fp
      Y[iy] += alpha * X[ix];
 800b882:	e9c6 0100 	strd	r0, r1, [r6]
    for (i = 0; i < N; i++) {
 800b886:	44ca      	add	sl, r9
 800b888:	4446      	add	r6, r8
 800b88a:	d1eb      	bne.n	800b864 <cblas_daxpy+0x5c>
#define BASE double
#include "source_axpy_r.h"
#undef BASE
}
 800b88c:	b005      	add	sp, #20
 800b88e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (incX == 1 && incY == 1) {
 800b892:	2b01      	cmp	r3, #1
 800b894:	d1d4      	bne.n	800b840 <cblas_daxpy+0x38>
    const INDEX m = N % 4;
 800b896:	427b      	negs	r3, r7
 800b898:	f003 0303 	and.w	r3, r3, #3
 800b89c:	f007 0b03 	and.w	fp, r7, #3
 800b8a0:	bf58      	it	pl
 800b8a2:	f1c3 0b00 	rsbpl	fp, r3, #0
    for (i = 0; i < m; i++) {
 800b8a6:	f1bb 0f00 	cmp.w	fp, #0
 800b8aa:	dd1b      	ble.n	800b8e4 <cblas_daxpy+0xdc>
 800b8ac:	e9cd b701 	strd	fp, r7, [sp, #4]
 800b8b0:	46b0      	mov	r8, r6
 800b8b2:	eb06 09cb 	add.w	r9, r6, fp, lsl #3
 800b8b6:	9603      	str	r6, [sp, #12]
 800b8b8:	4657      	mov	r7, sl
 800b8ba:	4656      	mov	r6, sl
      Y[i] += alpha * X[i];
 800b8bc:	e9d8 ab00 	ldrd	sl, fp, [r8]
 800b8c0:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 800b8c4:	4622      	mov	r2, r4
 800b8c6:	462b      	mov	r3, r5
 800b8c8:	f01c faee 	bl	8027ea8 <__aeabi_dmul>
 800b8cc:	4652      	mov	r2, sl
 800b8ce:	465b      	mov	r3, fp
 800b8d0:	f01c f934 	bl	8027b3c <__adddf3>
 800b8d4:	e8e8 0102 	strd	r0, r1, [r8], #8
    for (i = 0; i < m; i++) {
 800b8d8:	45c1      	cmp	r9, r8
 800b8da:	d1ef      	bne.n	800b8bc <cblas_daxpy+0xb4>
 800b8dc:	e9dd b701 	ldrd	fp, r7, [sp, #4]
 800b8e0:	46b2      	mov	sl, r6
 800b8e2:	9e03      	ldr	r6, [sp, #12]
    for (i = m; i + 3 < N; i += 4) {
 800b8e4:	f10b 0303 	add.w	r3, fp, #3
 800b8e8:	429f      	cmp	r7, r3
 800b8ea:	ddcf      	ble.n	800b88c <cblas_daxpy+0x84>
 800b8ec:	1f3b      	subs	r3, r7, #4
 800b8ee:	eba3 030b 	sub.w	r3, r3, fp
 800b8f2:	f023 0303 	bic.w	r3, r3, #3
 800b8f6:	f106 0720 	add.w	r7, r6, #32
 800b8fa:	445b      	add	r3, fp
 800b8fc:	eb0a 0acb 	add.w	sl, sl, fp, lsl #3
 800b900:	eb06 06cb 	add.w	r6, r6, fp, lsl #3
 800b904:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
      Y[i] += alpha * X[i];
 800b908:	e9da 2300 	ldrd	r2, r3, [sl]
 800b90c:	4620      	mov	r0, r4
 800b90e:	4629      	mov	r1, r5
 800b910:	f01c faca 	bl	8027ea8 <__aeabi_dmul>
 800b914:	4602      	mov	r2, r0
 800b916:	460b      	mov	r3, r1
 800b918:	e9d6 0100 	ldrd	r0, r1, [r6]
 800b91c:	f01c f90e 	bl	8027b3c <__adddf3>
 800b920:	e9c6 0100 	strd	r0, r1, [r6]
      Y[i + 1] += alpha * X[i + 1];
 800b924:	4620      	mov	r0, r4
 800b926:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 800b92a:	4629      	mov	r1, r5
 800b92c:	f01c fabc 	bl	8027ea8 <__aeabi_dmul>
 800b930:	4602      	mov	r2, r0
 800b932:	460b      	mov	r3, r1
 800b934:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 800b938:	f01c f900 	bl	8027b3c <__adddf3>
 800b93c:	e9c6 0102 	strd	r0, r1, [r6, #8]
      Y[i + 2] += alpha * X[i + 2];
 800b940:	4620      	mov	r0, r4
 800b942:	e9da 2304 	ldrd	r2, r3, [sl, #16]
 800b946:	4629      	mov	r1, r5
 800b948:	f01c faae 	bl	8027ea8 <__aeabi_dmul>
 800b94c:	4602      	mov	r2, r0
 800b94e:	460b      	mov	r3, r1
 800b950:	e9d6 0104 	ldrd	r0, r1, [r6, #16]
 800b954:	f01c f8f2 	bl	8027b3c <__adddf3>
 800b958:	e9c6 0104 	strd	r0, r1, [r6, #16]
      Y[i + 3] += alpha * X[i + 3];
 800b95c:	4620      	mov	r0, r4
 800b95e:	e9da 2306 	ldrd	r2, r3, [sl, #24]
 800b962:	4629      	mov	r1, r5
 800b964:	f01c faa0 	bl	8027ea8 <__aeabi_dmul>
 800b968:	4602      	mov	r2, r0
 800b96a:	460b      	mov	r3, r1
 800b96c:	e9d6 0106 	ldrd	r0, r1, [r6, #24]
 800b970:	f01c f8e4 	bl	8027b3c <__adddf3>
 800b974:	3620      	adds	r6, #32
 800b976:	e946 0102 	strd	r0, r1, [r6, #-8]
    for (i = m; i + 3 < N; i += 4) {
 800b97a:	42be      	cmp	r6, r7
 800b97c:	f10a 0a20 	add.w	sl, sl, #32
 800b980:	d1c2      	bne.n	800b908 <cblas_daxpy+0x100>
 800b982:	e783      	b.n	800b88c <cblas_daxpy+0x84>

0800b984 <cblas_dcopy>:
#include "cblas.h"

void
cblas_dcopy (const int N, const double *X, const int incX, double *Y,
             const int incY)
{
 800b984:	b4f0      	push	{r4, r5, r6, r7}
  INDEX ix = OFFSET(N, incX);
 800b986:	2a00      	cmp	r2, #0
 800b988:	9f04      	ldr	r7, [sp, #16]
 800b98a:	bfda      	itte	le
 800b98c:	f1c0 0501 	rsble	r5, r0, #1
 800b990:	4355      	mulle	r5, r2
 800b992:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 800b994:	2f00      	cmp	r7, #0
 800b996:	bfda      	itte	le
 800b998:	f1c0 0401 	rsble	r4, r0, #1
 800b99c:	437c      	mulle	r4, r7
 800b99e:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 800b9a0:	2800      	cmp	r0, #0
 800b9a2:	dd0f      	ble.n	800b9c4 <cblas_dcopy+0x40>
 800b9a4:	00d6      	lsls	r6, r2, #3
 800b9a6:	eb01 01c5 	add.w	r1, r1, r5, lsl #3
 800b9aa:	00ff      	lsls	r7, r7, #3
 800b9ac:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800b9b0:	2200      	movs	r2, #0
    Y[iy] = X[ix];
 800b9b2:	e9d1 4500 	ldrd	r4, r5, [r1]
  for (i = 0; i < N; i++) {
 800b9b6:	3201      	adds	r2, #1
 800b9b8:	4290      	cmp	r0, r2
    Y[iy] = X[ix];
 800b9ba:	e9c3 4500 	strd	r4, r5, [r3]
  for (i = 0; i < N; i++) {
 800b9be:	4431      	add	r1, r6
 800b9c0:	443b      	add	r3, r7
 800b9c2:	d1f6      	bne.n	800b9b2 <cblas_dcopy+0x2e>
#define BASE double
#include "source_copy_r.h"
#undef BASE
}
 800b9c4:	bcf0      	pop	{r4, r5, r6, r7}
 800b9c6:	4770      	bx	lr

0800b9c8 <cblas_ddot>:
#include "cblas.h"

double
cblas_ddot (const int N, const double *X, const int incX, const double *Y,
            const int incY)
{
 800b9c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  INDEX ix = OFFSET(N, incX);
 800b9cc:	2a00      	cmp	r2, #0
 800b9ce:	4682      	mov	sl, r0
 800b9d0:	980a      	ldr	r0, [sp, #40]	; 0x28
 800b9d2:	bfda      	itte	le
 800b9d4:	f1ca 0701 	rsble	r7, sl, #1
 800b9d8:	4357      	mulle	r7, r2
 800b9da:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 800b9dc:	2800      	cmp	r0, #0
 800b9de:	bfda      	itte	le
 800b9e0:	f1ca 0601 	rsble	r6, sl, #1
 800b9e4:	4346      	mulle	r6, r0
 800b9e6:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 800b9e8:	f1ba 0f00 	cmp.w	sl, #0
 800b9ec:	f04f 0400 	mov.w	r4, #0
 800b9f0:	f04f 0500 	mov.w	r5, #0
 800b9f4:	dd1d      	ble.n	800ba32 <cblas_ddot+0x6a>
 800b9f6:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 800b9fa:	eb01 07c7 	add.w	r7, r1, r7, lsl #3
 800b9fe:	ea4f 0bc0 	mov.w	fp, r0, lsl #3
 800ba02:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 800ba06:	f04f 0800 	mov.w	r8, #0
    r += X[ix] * Y[iy];
 800ba0a:	e9d6 2300 	ldrd	r2, r3, [r6]
 800ba0e:	e9d7 0100 	ldrd	r0, r1, [r7]
 800ba12:	f01c fa49 	bl	8027ea8 <__aeabi_dmul>
 800ba16:	4602      	mov	r2, r0
 800ba18:	460b      	mov	r3, r1
 800ba1a:	4620      	mov	r0, r4
 800ba1c:	4629      	mov	r1, r5
 800ba1e:	f01c f88d 	bl	8027b3c <__adddf3>
  for (i = 0; i < N; i++) {
 800ba22:	f108 0801 	add.w	r8, r8, #1
 800ba26:	45c2      	cmp	sl, r8
 800ba28:	445e      	add	r6, fp
    r += X[ix] * Y[iy];
 800ba2a:	4604      	mov	r4, r0
 800ba2c:	460d      	mov	r5, r1
  for (i = 0; i < N; i++) {
 800ba2e:	444f      	add	r7, r9
 800ba30:	d1eb      	bne.n	800ba0a <cblas_ddot+0x42>
#define BASE double
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 800ba32:	ec45 4b10 	vmov	d0, r4, r5
 800ba36:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800ba3a:	bf00      	nop

0800ba3c <cblas_dgemm>:
cblas_dgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const double alpha, const double *A, const int lda,
             const double *B, const int ldb, const double beta, double *C,
             const int ldc)
{
 800ba3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ba40:	ed2d 8b02 	vpush	{d8}
 800ba44:	eeb0 8a40 	vmov.f32	s16, s0
 800ba48:	eef0 8a60 	vmov.f32	s17, s1
 800ba4c:	b091      	sub	sp, #68	; 0x44
 800ba4e:	2865      	cmp	r0, #101	; 0x65
 800ba50:	9306      	str	r3, [sp, #24]
 800ba52:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800ba54:	9300      	str	r3, [sp, #0]
 800ba56:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800ba58:	9301      	str	r3, [sp, #4]
 800ba5a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800ba5c:	9305      	str	r3, [sp, #20]
 800ba5e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800ba60:	9302      	str	r3, [sp, #8]
 800ba62:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800ba64:	930a      	str	r3, [sp, #40]	; 0x28
 800ba66:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800ba68:	9308      	str	r3, [sp, #32]
 800ba6a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800ba6c:	9309      	str	r3, [sp, #36]	; 0x24
 800ba6e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 800ba70:	9303      	str	r3, [sp, #12]
 800ba72:	ec57 6b11 	vmov	r6, r7, d1
 800ba76:	4680      	mov	r8, r0
 800ba78:	460d      	mov	r5, r1
 800ba7a:	4614      	mov	r4, r2
 800ba7c:	f000 8130 	beq.w	800bce0 <cblas_dgemm+0x2a4>
 800ba80:	2a71      	cmp	r2, #113	; 0x71
 800ba82:	bf08      	it	eq
 800ba84:	2270      	moveq	r2, #112	; 0x70
 800ba86:	2971      	cmp	r1, #113	; 0x71
 800ba88:	d07d      	beq.n	800bb86 <cblas_dgemm+0x14a>
 800ba8a:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800ba8e:	b2db      	uxtb	r3, r3
 800ba90:	2b02      	cmp	r3, #2
 800ba92:	f240 8084 	bls.w	800bb9e <cblas_dgemm+0x162>
 800ba96:	2002      	movs	r0, #2
 800ba98:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 800ba9c:	2b02      	cmp	r3, #2
 800ba9e:	bf88      	it	hi
 800baa0:	2003      	movhi	r0, #3
 800baa2:	9b06      	ldr	r3, [sp, #24]
 800baa4:	2b00      	cmp	r3, #0
 800baa6:	9b00      	ldr	r3, [sp, #0]
 800baa8:	bfb8      	it	lt
 800baaa:	2004      	movlt	r0, #4
 800baac:	2b00      	cmp	r3, #0
 800baae:	9b01      	ldr	r3, [sp, #4]
 800bab0:	f2c0 80eb 	blt.w	800bc8a <cblas_dgemm+0x24e>
 800bab4:	2b00      	cmp	r3, #0
 800bab6:	db79      	blt.n	800bbac <cblas_dgemm+0x170>
 800bab8:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800babc:	f000 80ec 	beq.w	800bc98 <cblas_dgemm+0x25c>
 800bac0:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800bac4:	d07a      	beq.n	800bbbc <cblas_dgemm+0x180>
 800bac6:	2800      	cmp	r0, #0
 800bac8:	f040 8097 	bne.w	800bbfa <cblas_dgemm+0x1be>
  if (alpha == 0.0 && beta == 1.0)
 800bacc:	ec51 0b18 	vmov	r0, r1, d8
 800bad0:	2200      	movs	r2, #0
 800bad2:	2300      	movs	r3, #0
 800bad4:	f01c fc50 	bl	8028378 <__aeabi_dcmpeq>
 800bad8:	b140      	cbz	r0, 800baec <cblas_dgemm+0xb0>
 800bada:	4b94      	ldr	r3, [pc, #592]	; (800bd2c <cblas_dgemm+0x2f0>)
 800badc:	2200      	movs	r2, #0
 800bade:	4630      	mov	r0, r6
 800bae0:	4639      	mov	r1, r7
 800bae2:	f01c fc49 	bl	8028378 <__aeabi_dcmpeq>
 800bae6:	2800      	cmp	r0, #0
 800bae8:	f040 8097 	bne.w	800bc1a <cblas_dgemm+0x1de>
  if (Order == CblasRowMajor) {
 800baec:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800baf0:	f000 8105 	beq.w	800bcfe <cblas_dgemm+0x2c2>
    TransF = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800baf4:	2c71      	cmp	r4, #113	; 0x71
 800baf6:	bf14      	ite	ne
 800baf8:	46a3      	movne	fp, r4
 800bafa:	f04f 0b70 	moveq.w	fp, #112	; 0x70
    TransG = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800bafe:	2d71      	cmp	r5, #113	; 0x71
 800bb00:	bf14      	ite	ne
 800bb02:	462b      	movne	r3, r5
 800bb04:	2370      	moveq	r3, #112	; 0x70
 800bb06:	9304      	str	r3, [sp, #16]
  if (beta == 0.0) {
 800bb08:	2200      	movs	r2, #0
 800bb0a:	2300      	movs	r3, #0
 800bb0c:	4630      	mov	r0, r6
 800bb0e:	4639      	mov	r1, r7
 800bb10:	f01c fc32 	bl	8028378 <__aeabi_dcmpeq>
 800bb14:	2800      	cmp	r0, #0
 800bb16:	f000 8085 	beq.w	800bc24 <cblas_dgemm+0x1e8>
    for (i = 0; i < n1; i++) {
 800bb1a:	9b00      	ldr	r3, [sp, #0]
 800bb1c:	2b00      	cmp	r3, #0
 800bb1e:	dd19      	ble.n	800bb54 <cblas_dgemm+0x118>
 800bb20:	9a03      	ldr	r2, [sp, #12]
 800bb22:	9d06      	ldr	r5, [sp, #24]
 800bb24:	f8dd c000 	ldr.w	ip, [sp]
 800bb28:	00d4      	lsls	r4, r2, #3
 800bb2a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800bb2c:	ebc5 7045 	rsb	r0, r5, r5, lsl #29
 800bb30:	00c0      	lsls	r0, r0, #3
 800bb32:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800bb36:	2100      	movs	r1, #0
        C[ldc * i + j] = 0.0;
 800bb38:	2600      	movs	r6, #0
 800bb3a:	2700      	movs	r7, #0
      for (j = 0; j < n2; j++) {
 800bb3c:	2d00      	cmp	r5, #0
 800bb3e:	bfc8      	it	gt
 800bb40:	1813      	addgt	r3, r2, r0
 800bb42:	dd03      	ble.n	800bb4c <cblas_dgemm+0x110>
        C[ldc * i + j] = 0.0;
 800bb44:	e8e3 6702 	strd	r6, r7, [r3], #8
      for (j = 0; j < n2; j++) {
 800bb48:	4293      	cmp	r3, r2
 800bb4a:	d1fb      	bne.n	800bb44 <cblas_dgemm+0x108>
    for (i = 0; i < n1; i++) {
 800bb4c:	3101      	adds	r1, #1
 800bb4e:	458c      	cmp	ip, r1
 800bb50:	4422      	add	r2, r4
 800bb52:	d1f3      	bne.n	800bb3c <cblas_dgemm+0x100>
  if (alpha == 0.0)
 800bb54:	ec51 0b18 	vmov	r0, r1, d8
 800bb58:	2200      	movs	r2, #0
 800bb5a:	2300      	movs	r3, #0
 800bb5c:	f01c fc0c 	bl	8028378 <__aeabi_dcmpeq>
 800bb60:	2800      	cmp	r0, #0
 800bb62:	d15a      	bne.n	800bc1a <cblas_dgemm+0x1de>
  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 800bb64:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 800bb68:	d04c      	beq.n	800bc04 <cblas_dgemm+0x1c8>
  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 800bb6a:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800bb6e:	f000 80e5 	beq.w	800bd3c <cblas_dgemm+0x300>
    BLAS_ERROR("unrecognized operation");
 800bb72:	4a6f      	ldr	r2, [pc, #444]	; (800bd30 <cblas_dgemm+0x2f4>)
 800bb74:	496f      	ldr	r1, [pc, #444]	; (800bd34 <cblas_dgemm+0x2f8>)
 800bb76:	2000      	movs	r0, #0
#define BASE double
#include "source_gemm_r.h"
#undef BASE
}
 800bb78:	b011      	add	sp, #68	; 0x44
 800bb7a:	ecbd 8b02 	vpop	{d8}
 800bb7e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bb82:	f01b bf61 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800bb86:	3865      	subs	r0, #101	; 0x65
 800bb88:	2801      	cmp	r0, #1
 800bb8a:	bf94      	ite	ls
 800bb8c:	2000      	movls	r0, #0
 800bb8e:	2001      	movhi	r0, #1
 800bb90:	2170      	movs	r1, #112	; 0x70
 800bb92:	e781      	b.n	800ba98 <cblas_dgemm+0x5c>
 800bb94:	2a71      	cmp	r2, #113	; 0x71
 800bb96:	f000 829c 	beq.w	800c0d2 <cblas_dgemm+0x696>
 800bb9a:	4621      	mov	r1, r4
 800bb9c:	2270      	movs	r2, #112	; 0x70
 800bb9e:	f1a8 0065 	sub.w	r0, r8, #101	; 0x65
 800bba2:	2801      	cmp	r0, #1
 800bba4:	bf94      	ite	ls
 800bba6:	2000      	movls	r0, #0
 800bba8:	2001      	movhi	r0, #1
 800bbaa:	e775      	b.n	800ba98 <cblas_dgemm+0x5c>
 800bbac:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800bbb0:	f04f 0006 	mov.w	r0, #6
 800bbb4:	d070      	beq.n	800bc98 <cblas_dgemm+0x25c>
 800bbb6:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800bbba:	d11e      	bne.n	800bbfa <cblas_dgemm+0x1be>
 800bbbc:	2a6f      	cmp	r2, #111	; 0x6f
 800bbbe:	bf0c      	ite	eq
 800bbc0:	9b01      	ldreq	r3, [sp, #4]
 800bbc2:	9b00      	ldrne	r3, [sp, #0]
 800bbc4:	9a08      	ldr	r2, [sp, #32]
 800bbc6:	2b01      	cmp	r3, #1
 800bbc8:	bfb8      	it	lt
 800bbca:	2301      	movlt	r3, #1
 800bbcc:	4293      	cmp	r3, r2
 800bbce:	bfc8      	it	gt
 800bbd0:	200b      	movgt	r0, #11
 800bbd2:	296f      	cmp	r1, #111	; 0x6f
 800bbd4:	f000 8135 	beq.w	800be42 <cblas_dgemm+0x406>
 800bbd8:	9b01      	ldr	r3, [sp, #4]
 800bbda:	9a02      	ldr	r2, [sp, #8]
 800bbdc:	2b01      	cmp	r3, #1
 800bbde:	bfb8      	it	lt
 800bbe0:	2301      	movlt	r3, #1
 800bbe2:	4293      	cmp	r3, r2
 800bbe4:	f300 8149 	bgt.w	800be7a <cblas_dgemm+0x43e>
 800bbe8:	9b06      	ldr	r3, [sp, #24]
 800bbea:	2b01      	cmp	r3, #1
 800bbec:	bfb8      	it	lt
 800bbee:	2301      	movlt	r3, #1
 800bbf0:	9a03      	ldr	r2, [sp, #12]
 800bbf2:	429a      	cmp	r2, r3
 800bbf4:	f6bf af67 	bge.w	800bac6 <cblas_dgemm+0x8a>
 800bbf8:	200e      	movs	r0, #14
 800bbfa:	4a4f      	ldr	r2, [pc, #316]	; (800bd38 <cblas_dgemm+0x2fc>)
 800bbfc:	494d      	ldr	r1, [pc, #308]	; (800bd34 <cblas_dgemm+0x2f8>)
 800bbfe:	f01b ff23 	bl	8027a48 <cblas_xerbla>
 800bc02:	e763      	b.n	800bacc <cblas_dgemm+0x90>
  if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 800bc04:	9b04      	ldr	r3, [sp, #16]
 800bc06:	2b6f      	cmp	r3, #111	; 0x6f
 800bc08:	f000 8141 	beq.w	800be8e <cblas_dgemm+0x452>
  } else if (TransF == CblasNoTrans && TransG == CblasTrans) {
 800bc0c:	9b04      	ldr	r3, [sp, #16]
 800bc0e:	2b70      	cmp	r3, #112	; 0x70
 800bc10:	d1af      	bne.n	800bb72 <cblas_dgemm+0x136>
    for (i = 0; i < n1; i++) {
 800bc12:	9b00      	ldr	r3, [sp, #0]
 800bc14:	2b00      	cmp	r3, #0
 800bc16:	f300 819c 	bgt.w	800bf52 <cblas_dgemm+0x516>
 800bc1a:	b011      	add	sp, #68	; 0x44
 800bc1c:	ecbd 8b02 	vpop	{d8}
 800bc20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 800bc24:	4b41      	ldr	r3, [pc, #260]	; (800bd2c <cblas_dgemm+0x2f0>)
 800bc26:	2200      	movs	r2, #0
 800bc28:	4630      	mov	r0, r6
 800bc2a:	4639      	mov	r1, r7
 800bc2c:	f01c fba4 	bl	8028378 <__aeabi_dcmpeq>
 800bc30:	2800      	cmp	r0, #0
 800bc32:	d18f      	bne.n	800bb54 <cblas_dgemm+0x118>
    for (i = 0; i < n1; i++) {
 800bc34:	9b00      	ldr	r3, [sp, #0]
 800bc36:	2b00      	cmp	r3, #0
 800bc38:	dd8c      	ble.n	800bb54 <cblas_dgemm+0x118>
 800bc3a:	9a03      	ldr	r2, [sp, #12]
 800bc3c:	9b06      	ldr	r3, [sp, #24]
 800bc3e:	f8cd b01c 	str.w	fp, [sp, #28]
 800bc42:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 800bc46:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800bc48:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 800bc4c:	4680      	mov	r8, r0
 800bc4e:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800bc52:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 800bc56:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800bc58:	f1bb 0f00 	cmp.w	fp, #0
 800bc5c:	bfc8      	it	gt
 800bc5e:	eb05 0409 	addgt.w	r4, r5, r9
 800bc62:	dd09      	ble.n	800bc78 <cblas_dgemm+0x23c>
        C[ldc * i + j] *= beta;
 800bc64:	e9d4 0100 	ldrd	r0, r1, [r4]
 800bc68:	4632      	mov	r2, r6
 800bc6a:	463b      	mov	r3, r7
 800bc6c:	f01c f91c 	bl	8027ea8 <__aeabi_dmul>
 800bc70:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j < n2; j++) {
 800bc74:	42ac      	cmp	r4, r5
 800bc76:	d1f5      	bne.n	800bc64 <cblas_dgemm+0x228>
    for (i = 0; i < n1; i++) {
 800bc78:	9b00      	ldr	r3, [sp, #0]
 800bc7a:	f108 0801 	add.w	r8, r8, #1
 800bc7e:	4543      	cmp	r3, r8
 800bc80:	4455      	add	r5, sl
 800bc82:	d1e9      	bne.n	800bc58 <cblas_dgemm+0x21c>
 800bc84:	f8dd b01c 	ldr.w	fp, [sp, #28]
 800bc88:	e764      	b.n	800bb54 <cblas_dgemm+0x118>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800bc8a:	2b00      	cmp	r3, #0
 800bc8c:	db8e      	blt.n	800bbac <cblas_dgemm+0x170>
 800bc8e:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800bc92:	f04f 0005 	mov.w	r0, #5
 800bc96:	d18e      	bne.n	800bbb6 <cblas_dgemm+0x17a>
 800bc98:	2a6f      	cmp	r2, #111	; 0x6f
 800bc9a:	bf0c      	ite	eq
 800bc9c:	9b01      	ldreq	r3, [sp, #4]
 800bc9e:	9b06      	ldrne	r3, [sp, #24]
 800bca0:	9a02      	ldr	r2, [sp, #8]
 800bca2:	2b01      	cmp	r3, #1
 800bca4:	bfb8      	it	lt
 800bca6:	2301      	movlt	r3, #1
 800bca8:	4293      	cmp	r3, r2
 800bcaa:	bfc8      	it	gt
 800bcac:	2009      	movgt	r0, #9
 800bcae:	296f      	cmp	r1, #111	; 0x6f
 800bcb0:	f000 80d5 	beq.w	800be5e <cblas_dgemm+0x422>
 800bcb4:	9b01      	ldr	r3, [sp, #4]
 800bcb6:	9a08      	ldr	r2, [sp, #32]
 800bcb8:	2b01      	cmp	r3, #1
 800bcba:	bfb8      	it	lt
 800bcbc:	2301      	movlt	r3, #1
 800bcbe:	4293      	cmp	r3, r2
 800bcc0:	f340 80ac 	ble.w	800be1c <cblas_dgemm+0x3e0>
 800bcc4:	9800      	ldr	r0, [sp, #0]
 800bcc6:	9b03      	ldr	r3, [sp, #12]
 800bcc8:	4a1b      	ldr	r2, [pc, #108]	; (800bd38 <cblas_dgemm+0x2fc>)
 800bcca:	491a      	ldr	r1, [pc, #104]	; (800bd34 <cblas_dgemm+0x2f8>)
 800bccc:	2801      	cmp	r0, #1
 800bcce:	bfb8      	it	lt
 800bcd0:	2001      	movlt	r0, #1
 800bcd2:	4283      	cmp	r3, r0
 800bcd4:	bfb4      	ite	lt
 800bcd6:	200e      	movlt	r0, #14
 800bcd8:	200b      	movge	r0, #11
 800bcda:	f01b feb5 	bl	8027a48 <cblas_xerbla>
 800bcde:	e6f5      	b.n	800bacc <cblas_dgemm+0x90>
 800bce0:	2971      	cmp	r1, #113	; 0x71
 800bce2:	f43f af57 	beq.w	800bb94 <cblas_dgemm+0x158>
 800bce6:	2a71      	cmp	r2, #113	; 0x71
 800bce8:	f000 80a1 	beq.w	800be2e <cblas_dgemm+0x3f2>
 800bcec:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800bcf0:	b2db      	uxtb	r3, r3
 800bcf2:	2b02      	cmp	r3, #2
 800bcf4:	4611      	mov	r1, r2
 800bcf6:	462a      	mov	r2, r5
 800bcf8:	f63f aecd 	bhi.w	800ba96 <cblas_dgemm+0x5a>
 800bcfc:	e74f      	b.n	800bb9e <cblas_dgemm+0x162>
    TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800bcfe:	9a08      	ldr	r2, [sp, #32]
    F = A;
 800bd00:	9805      	ldr	r0, [sp, #20]
 800bd02:	990a      	ldr	r1, [sp, #40]	; 0x28
 800bd04:	900a      	str	r0, [sp, #40]	; 0x28
    TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800bd06:	2d71      	cmp	r5, #113	; 0x71
 800bd08:	9802      	ldr	r0, [sp, #8]
 800bd0a:	9202      	str	r2, [sp, #8]
 800bd0c:	bf18      	it	ne
 800bd0e:	46ab      	movne	fp, r5
 800bd10:	9a06      	ldr	r2, [sp, #24]
 800bd12:	9b00      	ldr	r3, [sp, #0]
 800bd14:	9008      	str	r0, [sp, #32]
 800bd16:	bf08      	it	eq
 800bd18:	f04f 0b70 	moveq.w	fp, #112	; 0x70
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800bd1c:	2c71      	cmp	r4, #113	; 0x71
    G = B;
 800bd1e:	9105      	str	r1, [sp, #20]
 800bd20:	9200      	str	r2, [sp, #0]
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800bd22:	f000 8080 	beq.w	800be26 <cblas_dgemm+0x3ea>
 800bd26:	9404      	str	r4, [sp, #16]
 800bd28:	9306      	str	r3, [sp, #24]
 800bd2a:	e6ed      	b.n	800bb08 <cblas_dgemm+0xcc>
 800bd2c:	3ff00000 	.word	0x3ff00000
 800bd30:	080305a8 	.word	0x080305a8
 800bd34:	08030598 	.word	0x08030598
 800bd38:	08030378 	.word	0x08030378
  } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 800bd3c:	9b04      	ldr	r3, [sp, #16]
 800bd3e:	2b6f      	cmp	r3, #111	; 0x6f
 800bd40:	f000 8162 	beq.w	800c008 <cblas_dgemm+0x5cc>
  } else if (TransF == CblasTrans && TransG == CblasTrans) {
 800bd44:	9b04      	ldr	r3, [sp, #16]
 800bd46:	2b70      	cmp	r3, #112	; 0x70
 800bd48:	f47f af13 	bne.w	800bb72 <cblas_dgemm+0x136>
    for (i = 0; i < n1; i++) {
 800bd4c:	9b00      	ldr	r3, [sp, #0]
 800bd4e:	2b00      	cmp	r3, #0
 800bd50:	f77f af63 	ble.w	800bc1a <cblas_dgemm+0x1de>
 800bd54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bd56:	9307      	str	r3, [sp, #28]
 800bd58:	9b08      	ldr	r3, [sp, #32]
 800bd5a:	9a06      	ldr	r2, [sp, #24]
 800bd5c:	900b      	str	r0, [sp, #44]	; 0x2c
 800bd5e:	00df      	lsls	r7, r3, #3
 800bd60:	9b03      	ldr	r3, [sp, #12]
 800bd62:	900a      	str	r0, [sp, #40]	; 0x28
 800bd64:	00db      	lsls	r3, r3, #3
 800bd66:	930c      	str	r3, [sp, #48]	; 0x30
 800bd68:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bd6a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800bd6e:	9304      	str	r3, [sp, #16]
 800bd70:	9b02      	ldr	r3, [sp, #8]
 800bd72:	9a01      	ldr	r2, [sp, #4]
 800bd74:	00db      	lsls	r3, r3, #3
 800bd76:	9308      	str	r3, [sp, #32]
 800bd78:	9b05      	ldr	r3, [sp, #20]
 800bd7a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800bd7e:	930d      	str	r3, [sp, #52]	; 0x34
      for (j = 0; j < n2; j++) {
 800bd80:	9b06      	ldr	r3, [sp, #24]
 800bd82:	2b00      	cmp	r3, #0
 800bd84:	dd38      	ble.n	800bdf8 <cblas_dgemm+0x3bc>
 800bd86:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bd88:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800bd8a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800bd8c:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 800bd90:	f04f 0900 	mov.w	r9, #0
        for (k = 0; k < K; k++) {
 800bd94:	9b01      	ldr	r3, [sp, #4]
 800bd96:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800bd98:	f04f 0400 	mov.w	r4, #0
 800bd9c:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800bda0:	dd15      	ble.n	800bdce <cblas_dgemm+0x392>
 800bda2:	9b05      	ldr	r3, [sp, #20]
 800bda4:	f8dd a01c 	ldr.w	sl, [sp, #28]
 800bda8:	eb03 0bc9 	add.w	fp, r3, r9, lsl #3
          temp += F[ldf * k + i] * G[ldg * j + k];
 800bdac:	e9da 2300 	ldrd	r2, r3, [sl]
 800bdb0:	e8fb 0102 	ldrd	r0, r1, [fp], #8
 800bdb4:	f01c f878 	bl	8027ea8 <__aeabi_dmul>
 800bdb8:	4602      	mov	r2, r0
 800bdba:	460b      	mov	r3, r1
 800bdbc:	4620      	mov	r0, r4
 800bdbe:	4629      	mov	r1, r5
 800bdc0:	f01b febc 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800bdc4:	45b3      	cmp	fp, r6
 800bdc6:	44ba      	add	sl, r7
          temp += F[ldf * k + i] * G[ldg * j + k];
 800bdc8:	4604      	mov	r4, r0
 800bdca:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800bdcc:	d1ee      	bne.n	800bdac <cblas_dgemm+0x370>
        C[ldc * i + j] += alpha * temp;
 800bdce:	4622      	mov	r2, r4
 800bdd0:	462b      	mov	r3, r5
 800bdd2:	e9d8 4500 	ldrd	r4, r5, [r8]
 800bdd6:	ec51 0b18 	vmov	r0, r1, d8
 800bdda:	f01c f865 	bl	8027ea8 <__aeabi_dmul>
 800bdde:	462b      	mov	r3, r5
 800bde0:	4622      	mov	r2, r4
 800bde2:	f01b feab 	bl	8027b3c <__adddf3>
 800bde6:	9b02      	ldr	r3, [sp, #8]
 800bde8:	4499      	add	r9, r3
 800bdea:	9b08      	ldr	r3, [sp, #32]
 800bdec:	e8e8 0102 	strd	r0, r1, [r8], #8
      for (j = 0; j < n2; j++) {
 800bdf0:	441e      	add	r6, r3
 800bdf2:	9b04      	ldr	r3, [sp, #16]
 800bdf4:	4598      	cmp	r8, r3
 800bdf6:	d1cd      	bne.n	800bd94 <cblas_dgemm+0x358>
    for (i = 0; i < n1; i++) {
 800bdf8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800bdfa:	9903      	ldr	r1, [sp, #12]
 800bdfc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bdfe:	440a      	add	r2, r1
 800be00:	920b      	str	r2, [sp, #44]	; 0x2c
 800be02:	990c      	ldr	r1, [sp, #48]	; 0x30
 800be04:	9a04      	ldr	r2, [sp, #16]
 800be06:	440a      	add	r2, r1
 800be08:	9204      	str	r2, [sp, #16]
 800be0a:	9a07      	ldr	r2, [sp, #28]
 800be0c:	3208      	adds	r2, #8
 800be0e:	9207      	str	r2, [sp, #28]
 800be10:	9a00      	ldr	r2, [sp, #0]
 800be12:	3301      	adds	r3, #1
 800be14:	429a      	cmp	r2, r3
 800be16:	930a      	str	r3, [sp, #40]	; 0x28
 800be18:	d1b2      	bne.n	800bd80 <cblas_dgemm+0x344>
 800be1a:	e6fe      	b.n	800bc1a <cblas_dgemm+0x1de>
 800be1c:	9b00      	ldr	r3, [sp, #0]
 800be1e:	2b01      	cmp	r3, #1
 800be20:	bfb8      	it	lt
 800be22:	2301      	movlt	r3, #1
 800be24:	e6e4      	b.n	800bbf0 <cblas_dgemm+0x1b4>
    TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
 800be26:	2270      	movs	r2, #112	; 0x70
 800be28:	9204      	str	r2, [sp, #16]
 800be2a:	9306      	str	r3, [sp, #24]
 800be2c:	e66c      	b.n	800bb08 <cblas_dgemm+0xcc>
 800be2e:	460a      	mov	r2, r1
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800be30:	f1a5 036f 	sub.w	r3, r5, #111	; 0x6f
 800be34:	b2db      	uxtb	r3, r3
 800be36:	2b02      	cmp	r3, #2
 800be38:	bf8c      	ite	hi
 800be3a:	2002      	movhi	r0, #2
 800be3c:	2000      	movls	r0, #0
 800be3e:	2170      	movs	r1, #112	; 0x70
 800be40:	e62f      	b.n	800baa2 <cblas_dgemm+0x66>
 800be42:	9b06      	ldr	r3, [sp, #24]
 800be44:	9a02      	ldr	r2, [sp, #8]
 800be46:	2b01      	cmp	r3, #1
 800be48:	bfb8      	it	lt
 800be4a:	2301      	movlt	r3, #1
 800be4c:	4293      	cmp	r3, r2
 800be4e:	f77f aecf 	ble.w	800bbf0 <cblas_dgemm+0x1b4>
 800be52:	9a03      	ldr	r2, [sp, #12]
 800be54:	4293      	cmp	r3, r2
 800be56:	bfcc      	ite	gt
 800be58:	200e      	movgt	r0, #14
 800be5a:	2009      	movle	r0, #9
 800be5c:	e6cd      	b.n	800bbfa <cblas_dgemm+0x1be>
 800be5e:	9b00      	ldr	r3, [sp, #0]
 800be60:	9a08      	ldr	r2, [sp, #32]
 800be62:	2b01      	cmp	r3, #1
 800be64:	bfb8      	it	lt
 800be66:	2301      	movlt	r3, #1
 800be68:	4293      	cmp	r3, r2
 800be6a:	f77f aec1 	ble.w	800bbf0 <cblas_dgemm+0x1b4>
 800be6e:	9a03      	ldr	r2, [sp, #12]
 800be70:	4293      	cmp	r3, r2
 800be72:	bfcc      	ite	gt
 800be74:	200e      	movgt	r0, #14
 800be76:	200b      	movle	r0, #11
 800be78:	e6bf      	b.n	800bbfa <cblas_dgemm+0x1be>
 800be7a:	9806      	ldr	r0, [sp, #24]
 800be7c:	9b03      	ldr	r3, [sp, #12]
 800be7e:	2801      	cmp	r0, #1
 800be80:	bfb8      	it	lt
 800be82:	2001      	movlt	r0, #1
 800be84:	4283      	cmp	r3, r0
 800be86:	bfb4      	ite	lt
 800be88:	200e      	movlt	r0, #14
 800be8a:	2009      	movge	r0, #9
 800be8c:	e6b5      	b.n	800bbfa <cblas_dgemm+0x1be>
    for (k = 0; k < K; k++) {
 800be8e:	9b01      	ldr	r3, [sp, #4]
 800be90:	2b00      	cmp	r3, #0
 800be92:	f77f aec2 	ble.w	800bc1a <cblas_dgemm+0x1de>
 800be96:	9b02      	ldr	r3, [sp, #8]
 800be98:	9a06      	ldr	r2, [sp, #24]
 800be9a:	900b      	str	r0, [sp, #44]	; 0x2c
 800be9c:	00db      	lsls	r3, r3, #3
 800be9e:	930c      	str	r3, [sp, #48]	; 0x30
 800bea0:	9b08      	ldr	r3, [sp, #32]
 800bea2:	00db      	lsls	r3, r3, #3
 800bea4:	9304      	str	r3, [sp, #16]
 800bea6:	9b03      	ldr	r3, [sp, #12]
 800bea8:	00db      	lsls	r3, r3, #3
 800beaa:	9302      	str	r3, [sp, #8]
 800beac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800beae:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800beb2:	930d      	str	r3, [sp, #52]	; 0x34
      for (i = 0; i < n1; i++) {
 800beb4:	9b00      	ldr	r3, [sp, #0]
 800beb6:	2b00      	cmp	r3, #0
 800beb8:	dd40      	ble.n	800bf3c <cblas_dgemm+0x500>
 800beba:	e9dd 100a 	ldrd	r1, r0, [sp, #40]	; 0x28
 800bebe:	2300      	movs	r3, #0
 800bec0:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 800bec4:	eb01 0bc0 	add.w	fp, r1, r0, lsl #3
 800bec8:	4698      	mov	r8, r3
 800beca:	4699      	mov	r9, r3
 800becc:	e00a      	b.n	800bee4 <cblas_dgemm+0x4a8>
 800bece:	9b04      	ldr	r3, [sp, #16]
 800bed0:	449b      	add	fp, r3
 800bed2:	9b03      	ldr	r3, [sp, #12]
 800bed4:	4499      	add	r9, r3
 800bed6:	9b02      	ldr	r3, [sp, #8]
 800bed8:	449a      	add	sl, r3
 800beda:	9b00      	ldr	r3, [sp, #0]
 800bedc:	f108 0801 	add.w	r8, r8, #1
 800bee0:	4543      	cmp	r3, r8
 800bee2:	d02b      	beq.n	800bf3c <cblas_dgemm+0x500>
        const BASE temp = alpha * F[ldf * i + k];
 800bee4:	e9db 2300 	ldrd	r2, r3, [fp]
 800bee8:	ec51 0b18 	vmov	r0, r1, d8
 800beec:	f01b ffdc 	bl	8027ea8 <__aeabi_dmul>
        if (temp != 0.0) {
 800bef0:	2200      	movs	r2, #0
 800bef2:	2300      	movs	r3, #0
        const BASE temp = alpha * F[ldf * i + k];
 800bef4:	4606      	mov	r6, r0
 800bef6:	460f      	mov	r7, r1
        if (temp != 0.0) {
 800bef8:	f01c fa3e 	bl	8028378 <__aeabi_dcmpeq>
 800befc:	2800      	cmp	r0, #0
 800befe:	d1e6      	bne.n	800bece <cblas_dgemm+0x492>
          for (j = 0; j < n2; j++) {
 800bf00:	9b06      	ldr	r3, [sp, #24]
 800bf02:	2b00      	cmp	r3, #0
 800bf04:	dde3      	ble.n	800bece <cblas_dgemm+0x492>
 800bf06:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bf08:	9d05      	ldr	r5, [sp, #20]
 800bf0a:	e9cd 8907 	strd	r8, r9, [sp, #28]
 800bf0e:	eb03 04c9 	add.w	r4, r3, r9, lsl #3
 800bf12:	46b0      	mov	r8, r6
 800bf14:	46b9      	mov	r9, r7
            C[ldc * i + j] += temp * G[ldg * k + j];
 800bf16:	e9d4 6700 	ldrd	r6, r7, [r4]
 800bf1a:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800bf1e:	4642      	mov	r2, r8
 800bf20:	464b      	mov	r3, r9
 800bf22:	f01b ffc1 	bl	8027ea8 <__aeabi_dmul>
 800bf26:	4632      	mov	r2, r6
 800bf28:	463b      	mov	r3, r7
 800bf2a:	f01b fe07 	bl	8027b3c <__adddf3>
 800bf2e:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (j = 0; j < n2; j++) {
 800bf32:	45a2      	cmp	sl, r4
 800bf34:	d1ef      	bne.n	800bf16 <cblas_dgemm+0x4da>
 800bf36:	e9dd 8907 	ldrd	r8, r9, [sp, #28]
 800bf3a:	e7c8      	b.n	800bece <cblas_dgemm+0x492>
    for (k = 0; k < K; k++) {
 800bf3c:	9a05      	ldr	r2, [sp, #20]
 800bf3e:	990c      	ldr	r1, [sp, #48]	; 0x30
 800bf40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800bf42:	440a      	add	r2, r1
 800bf44:	9205      	str	r2, [sp, #20]
 800bf46:	9a01      	ldr	r2, [sp, #4]
 800bf48:	3301      	adds	r3, #1
 800bf4a:	429a      	cmp	r2, r3
 800bf4c:	930b      	str	r3, [sp, #44]	; 0x2c
 800bf4e:	d1b1      	bne.n	800beb4 <cblas_dgemm+0x478>
 800bf50:	e663      	b.n	800bc1a <cblas_dgemm+0x1de>
 800bf52:	9a08      	ldr	r2, [sp, #32]
 800bf54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800bf56:	9304      	str	r3, [sp, #16]
 800bf58:	00d2      	lsls	r2, r2, #3
 800bf5a:	920a      	str	r2, [sp, #40]	; 0x28
 800bf5c:	9a01      	ldr	r2, [sp, #4]
    for (i = 0; i < n1; i++) {
 800bf5e:	9007      	str	r0, [sp, #28]
 800bf60:	eb03 06c2 	add.w	r6, r3, r2, lsl #3
 800bf64:	9b03      	ldr	r3, [sp, #12]
 800bf66:	9a06      	ldr	r2, [sp, #24]
 800bf68:	9008      	str	r0, [sp, #32]
 800bf6a:	00db      	lsls	r3, r3, #3
 800bf6c:	930b      	str	r3, [sp, #44]	; 0x2c
 800bf6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bf70:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
      for (j = 0; j < n2; j++) {
 800bf74:	9b06      	ldr	r3, [sp, #24]
 800bf76:	2b00      	cmp	r3, #0
 800bf78:	dd33      	ble.n	800bfe2 <cblas_dgemm+0x5a6>
 800bf7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800bf7c:	9a07      	ldr	r2, [sp, #28]
 800bf7e:	f04f 0800 	mov.w	r8, #0
 800bf82:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        for (k = 0; k < K; k++) {
 800bf86:	9b01      	ldr	r3, [sp, #4]
 800bf88:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800bf8a:	f04f 0400 	mov.w	r4, #0
 800bf8e:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800bf92:	dd14      	ble.n	800bfbe <cblas_dgemm+0x582>
 800bf94:	9b05      	ldr	r3, [sp, #20]
 800bf96:	f8dd a010 	ldr.w	sl, [sp, #16]
 800bf9a:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
          temp += F[ldf * i + k] * G[ldg * j + k];
 800bf9e:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800bfa2:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 800bfa6:	f01b ff7f 	bl	8027ea8 <__aeabi_dmul>
 800bfaa:	4602      	mov	r2, r0
 800bfac:	460b      	mov	r3, r1
 800bfae:	4620      	mov	r0, r4
 800bfb0:	4629      	mov	r1, r5
 800bfb2:	f01b fdc3 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800bfb6:	4556      	cmp	r6, sl
          temp += F[ldf * i + k] * G[ldg * j + k];
 800bfb8:	4604      	mov	r4, r0
 800bfba:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800bfbc:	d1ef      	bne.n	800bf9e <cblas_dgemm+0x562>
        C[ldc * i + j] += alpha * temp;
 800bfbe:	4622      	mov	r2, r4
 800bfc0:	462b      	mov	r3, r5
 800bfc2:	e9d7 4500 	ldrd	r4, r5, [r7]
 800bfc6:	ec51 0b18 	vmov	r0, r1, d8
 800bfca:	f01b ff6d 	bl	8027ea8 <__aeabi_dmul>
 800bfce:	462b      	mov	r3, r5
 800bfd0:	4622      	mov	r2, r4
 800bfd2:	f01b fdb3 	bl	8027b3c <__adddf3>
 800bfd6:	e8e7 0102 	strd	r0, r1, [r7], #8
      for (j = 0; j < n2; j++) {
 800bfda:	9b02      	ldr	r3, [sp, #8]
 800bfdc:	45b9      	cmp	r9, r7
 800bfde:	4498      	add	r8, r3
 800bfe0:	d1d1      	bne.n	800bf86 <cblas_dgemm+0x54a>
    for (i = 0; i < n1; i++) {
 800bfe2:	9a07      	ldr	r2, [sp, #28]
 800bfe4:	9903      	ldr	r1, [sp, #12]
 800bfe6:	9b08      	ldr	r3, [sp, #32]
 800bfe8:	440a      	add	r2, r1
 800bfea:	9207      	str	r2, [sp, #28]
 800bfec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800bfee:	9904      	ldr	r1, [sp, #16]
 800bff0:	4491      	add	r9, r2
 800bff2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800bff4:	4608      	mov	r0, r1
 800bff6:	4410      	add	r0, r2
 800bff8:	4416      	add	r6, r2
 800bffa:	9a00      	ldr	r2, [sp, #0]
 800bffc:	9004      	str	r0, [sp, #16]
 800bffe:	3301      	adds	r3, #1
 800c000:	429a      	cmp	r2, r3
 800c002:	9308      	str	r3, [sp, #32]
 800c004:	d1b6      	bne.n	800bf74 <cblas_dgemm+0x538>
 800c006:	e608      	b.n	800bc1a <cblas_dgemm+0x1de>
    for (k = 0; k < K; k++) {
 800c008:	9b01      	ldr	r3, [sp, #4]
 800c00a:	2b00      	cmp	r3, #0
 800c00c:	f77f ae05 	ble.w	800bc1a <cblas_dgemm+0x1de>
 800c010:	9b08      	ldr	r3, [sp, #32]
 800c012:	9a00      	ldr	r2, [sp, #0]
 800c014:	900e      	str	r0, [sp, #56]	; 0x38
 800c016:	00db      	lsls	r3, r3, #3
 800c018:	930f      	str	r3, [sp, #60]	; 0x3c
 800c01a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c01c:	e9cd 000b 	strd	r0, r0, [sp, #44]	; 0x2c
 800c020:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c024:	9307      	str	r3, [sp, #28]
      for (i = 0; i < n1; i++) {
 800c026:	9b00      	ldr	r3, [sp, #0]
 800c028:	2b00      	cmp	r3, #0
 800c02a:	dd3f      	ble.n	800c0ac <cblas_dgemm+0x670>
 800c02c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800c02e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c030:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
 800c034:	9b05      	ldr	r3, [sp, #20]
 800c036:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800c038:	f8cd a010 	str.w	sl, [sp, #16]
 800c03c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c040:	930d      	str	r3, [sp, #52]	; 0x34
 800c042:	2300      	movs	r3, #0
 800c044:	4699      	mov	r9, r3
 800c046:	e005      	b.n	800c054 <cblas_dgemm+0x618>
 800c048:	9b03      	ldr	r3, [sp, #12]
 800c04a:	9a04      	ldr	r2, [sp, #16]
 800c04c:	4499      	add	r9, r3
 800c04e:	9b07      	ldr	r3, [sp, #28]
 800c050:	4293      	cmp	r3, r2
 800c052:	d02b      	beq.n	800c0ac <cblas_dgemm+0x670>
        const BASE temp = alpha * F[ldf * k + i];
 800c054:	9c04      	ldr	r4, [sp, #16]
 800c056:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800c05a:	ec53 2b18 	vmov	r2, r3, d8
 800c05e:	9404      	str	r4, [sp, #16]
 800c060:	f01b ff22 	bl	8027ea8 <__aeabi_dmul>
        if (temp != 0.0) {
 800c064:	2200      	movs	r2, #0
 800c066:	2300      	movs	r3, #0
        const BASE temp = alpha * F[ldf * k + i];
 800c068:	4682      	mov	sl, r0
 800c06a:	468b      	mov	fp, r1
        if (temp != 0.0) {
 800c06c:	f01c f984 	bl	8028378 <__aeabi_dcmpeq>
 800c070:	2800      	cmp	r0, #0
 800c072:	d1e9      	bne.n	800c048 <cblas_dgemm+0x60c>
          for (j = 0; j < n2; j++) {
 800c074:	9b06      	ldr	r3, [sp, #24]
 800c076:	2b00      	cmp	r3, #0
 800c078:	dde6      	ble.n	800c048 <cblas_dgemm+0x60c>
 800c07a:	eb03 0809 	add.w	r8, r3, r9
 800c07e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800c080:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 800c082:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 800c086:	eb03 04c9 	add.w	r4, r3, r9, lsl #3
            C[ldc * i + j] += temp * G[ldg * k + j];
 800c08a:	e9d4 6700 	ldrd	r6, r7, [r4]
 800c08e:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800c092:	4652      	mov	r2, sl
 800c094:	465b      	mov	r3, fp
 800c096:	f01b ff07 	bl	8027ea8 <__aeabi_dmul>
 800c09a:	4632      	mov	r2, r6
 800c09c:	463b      	mov	r3, r7
 800c09e:	f01b fd4d 	bl	8027b3c <__adddf3>
 800c0a2:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (j = 0; j < n2; j++) {
 800c0a6:	4544      	cmp	r4, r8
 800c0a8:	d1ef      	bne.n	800c08a <cblas_dgemm+0x64e>
 800c0aa:	e7cd      	b.n	800c048 <cblas_dgemm+0x60c>
    for (k = 0; k < K; k++) {
 800c0ac:	9a07      	ldr	r2, [sp, #28]
 800c0ae:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800c0b0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800c0b2:	440a      	add	r2, r1
 800c0b4:	9207      	str	r2, [sp, #28]
 800c0b6:	9908      	ldr	r1, [sp, #32]
 800c0b8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800c0ba:	440a      	add	r2, r1
 800c0bc:	920c      	str	r2, [sp, #48]	; 0x30
 800c0be:	9902      	ldr	r1, [sp, #8]
 800c0c0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800c0c2:	440a      	add	r2, r1
 800c0c4:	920b      	str	r2, [sp, #44]	; 0x2c
 800c0c6:	9a01      	ldr	r2, [sp, #4]
 800c0c8:	3301      	adds	r3, #1
 800c0ca:	429a      	cmp	r2, r3
 800c0cc:	930e      	str	r3, [sp, #56]	; 0x38
 800c0ce:	d1aa      	bne.n	800c026 <cblas_dgemm+0x5ea>
 800c0d0:	e5a3      	b.n	800bc1a <cblas_dgemm+0x1de>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800c0d2:	2270      	movs	r2, #112	; 0x70
 800c0d4:	e6ac      	b.n	800be30 <cblas_dgemm+0x3f4>
 800c0d6:	bf00      	nop

0800c0d8 <cblas_dgemv>:
void
cblas_dgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const double alpha, const double *A,
             const int lda, const double *X, const int incX,
             const double beta, double *Y, const int incY)
{
 800c0d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c0dc:	ed2d 8b02 	vpush	{d8}
 800c0e0:	eeb0 8a40 	vmov.f32	s16, s0
 800c0e4:	eef0 8a60 	vmov.f32	s17, s1
 800c0e8:	b08b      	sub	sp, #44	; 0x2c
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 800c0ea:	2971      	cmp	r1, #113	; 0x71
 800c0ec:	9301      	str	r3, [sp, #4]
 800c0ee:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800c0f0:	9304      	str	r3, [sp, #16]
 800c0f2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 800c0f4:	9302      	str	r3, [sp, #8]
 800c0f6:	9b18      	ldr	r3, [sp, #96]	; 0x60
 800c0f8:	9306      	str	r3, [sp, #24]
 800c0fa:	9b19      	ldr	r3, [sp, #100]	; 0x64
 800c0fc:	9303      	str	r3, [sp, #12]
 800c0fe:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800c100:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 800c102:	9305      	str	r3, [sp, #20]
 800c104:	ec5b ab11 	vmov	sl, fp, d1
 800c108:	4605      	mov	r5, r0
 800c10a:	4690      	mov	r8, r2
 800c10c:	f000 80f0 	beq.w	800c2f0 <cblas_dgemv+0x218>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800c110:	f1a1 036f 	sub.w	r3, r1, #111	; 0x6f
 800c114:	2b02      	cmp	r3, #2
 800c116:	460c      	mov	r4, r1
 800c118:	f240 811f 	bls.w	800c35a <cblas_dgemv+0x282>
 800c11c:	2002      	movs	r0, #2
 800c11e:	9b01      	ldr	r3, [sp, #4]
 800c120:	f1b8 0f00 	cmp.w	r8, #0
 800c124:	bfb8      	it	lt
 800c126:	2003      	movlt	r0, #3
 800c128:	2b00      	cmp	r3, #0
 800c12a:	bfb8      	it	lt
 800c12c:	2004      	movlt	r0, #4
 800c12e:	2d65      	cmp	r5, #101	; 0x65
 800c130:	f000 80c8 	beq.w	800c2c4 <cblas_dgemv+0x1ec>
 800c134:	2d66      	cmp	r5, #102	; 0x66
 800c136:	f000 80c4 	beq.w	800c2c2 <cblas_dgemv+0x1ea>
 800c13a:	9b03      	ldr	r3, [sp, #12]
 800c13c:	2b00      	cmp	r3, #0
 800c13e:	f040 80d1 	bne.w	800c2e4 <cblas_dgemv+0x20c>
 800c142:	2f00      	cmp	r7, #0
 800c144:	bf14      	ite	ne
 800c146:	2009      	movne	r0, #9
 800c148:	200c      	moveq	r0, #12
 800c14a:	4abf      	ldr	r2, [pc, #764]	; (800c448 <cblas_dgemv+0x370>)
 800c14c:	49bf      	ldr	r1, [pc, #764]	; (800c44c <cblas_dgemv+0x374>)
 800c14e:	f01b fc7b 	bl	8027a48 <cblas_xerbla>
  if (M == 0 || N == 0)
 800c152:	f1b8 0f00 	cmp.w	r8, #0
 800c156:	f000 80af 	beq.w	800c2b8 <cblas_dgemv+0x1e0>
 800c15a:	9b01      	ldr	r3, [sp, #4]
 800c15c:	2b00      	cmp	r3, #0
 800c15e:	f000 80ab 	beq.w	800c2b8 <cblas_dgemv+0x1e0>
  if (alpha == 0.0 && beta == 1.0)
 800c162:	ec51 0b18 	vmov	r0, r1, d8
 800c166:	2200      	movs	r2, #0
 800c168:	2300      	movs	r3, #0
 800c16a:	f01c f905 	bl	8028378 <__aeabi_dcmpeq>
 800c16e:	b140      	cbz	r0, 800c182 <cblas_dgemv+0xaa>
 800c170:	4bb7      	ldr	r3, [pc, #732]	; (800c450 <cblas_dgemv+0x378>)
 800c172:	2200      	movs	r2, #0
 800c174:	4650      	mov	r0, sl
 800c176:	4659      	mov	r1, fp
 800c178:	f01c f8fe 	bl	8028378 <__aeabi_dcmpeq>
 800c17c:	2800      	cmp	r0, #0
 800c17e:	f040 809b 	bne.w	800c2b8 <cblas_dgemv+0x1e0>
  if (Trans == CblasNoTrans) {
 800c182:	2c6f      	cmp	r4, #111	; 0x6f
 800c184:	d003      	beq.n	800c18e <cblas_dgemv+0xb6>
 800c186:	9b01      	ldr	r3, [sp, #4]
 800c188:	f8cd 8004 	str.w	r8, [sp, #4]
 800c18c:	4698      	mov	r8, r3
  if (beta == 0.0) {
 800c18e:	2200      	movs	r2, #0
 800c190:	2300      	movs	r3, #0
 800c192:	4650      	mov	r0, sl
 800c194:	4659      	mov	r1, fp
 800c196:	f01c f8ef 	bl	8028378 <__aeabi_dcmpeq>
 800c19a:	2800      	cmp	r0, #0
 800c19c:	f000 80af 	beq.w	800c2fe <cblas_dgemv+0x226>
    INDEX iy = OFFSET(lenY, incY);
 800c1a0:	2f00      	cmp	r7, #0
 800c1a2:	f340 8145 	ble.w	800c430 <cblas_dgemv+0x358>
 800c1a6:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 800c1a8:	f1b8 0f00 	cmp.w	r8, #0
 800c1ac:	dd0c      	ble.n	800c1c8 <cblas_dgemv+0xf0>
 800c1ae:	9a05      	ldr	r2, [sp, #20]
      Y[iy] = 0.0;
 800c1b0:	ed9f 7ba3 	vldr	d7, [pc, #652]	; 800c440 <cblas_dgemv+0x368>
 800c1b4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800c1b8:	00f9      	lsls	r1, r7, #3
    for (i = 0; i < lenY; i++) {
 800c1ba:	2200      	movs	r2, #0
 800c1bc:	3201      	adds	r2, #1
 800c1be:	4590      	cmp	r8, r2
      Y[iy] = 0.0;
 800c1c0:	ed83 7b00 	vstr	d7, [r3]
    for (i = 0; i < lenY; i++) {
 800c1c4:	440b      	add	r3, r1
 800c1c6:	d1f9      	bne.n	800c1bc <cblas_dgemv+0xe4>
  if (alpha == 0.0)
 800c1c8:	ec51 0b18 	vmov	r0, r1, d8
 800c1cc:	2200      	movs	r2, #0
 800c1ce:	2300      	movs	r3, #0
 800c1d0:	f01c f8d2 	bl	8028378 <__aeabi_dcmpeq>
 800c1d4:	2800      	cmp	r0, #0
 800c1d6:	d16f      	bne.n	800c2b8 <cblas_dgemv+0x1e0>
  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 800c1d8:	2d65      	cmp	r5, #101	; 0x65
 800c1da:	f000 80c6 	beq.w	800c36a <cblas_dgemv+0x292>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 800c1de:	2d66      	cmp	r5, #102	; 0x66
 800c1e0:	d009      	beq.n	800c1f6 <cblas_dgemv+0x11e>
    BLAS_ERROR("unrecognized operation");
 800c1e2:	4a9c      	ldr	r2, [pc, #624]	; (800c454 <cblas_dgemv+0x37c>)
 800c1e4:	4999      	ldr	r1, [pc, #612]	; (800c44c <cblas_dgemv+0x374>)
 800c1e6:	2000      	movs	r0, #0
#define BASE double
#include "source_gemv_r.h"
#undef BASE
}
 800c1e8:	b00b      	add	sp, #44	; 0x2c
 800c1ea:	ecbd 8b02 	vpop	{d8}
 800c1ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c1f2:	f01b bc29 	b.w	8027a48 <cblas_xerbla>
      || (order == CblasColMajor && Trans == CblasTrans)) {
 800c1f6:	2c70      	cmp	r4, #112	; 0x70
 800c1f8:	f040 812e 	bne.w	800c458 <cblas_dgemv+0x380>
    INDEX iy = OFFSET(lenY, incY);
 800c1fc:	2f00      	cmp	r7, #0
 800c1fe:	f340 812f 	ble.w	800c460 <cblas_dgemv+0x388>
 800c202:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 800c204:	f1b8 0f00 	cmp.w	r8, #0
 800c208:	dd56      	ble.n	800c2b8 <cblas_dgemv+0x1e0>
 800c20a:	00fd      	lsls	r5, r7, #3
 800c20c:	9903      	ldr	r1, [sp, #12]
 800c20e:	9801      	ldr	r0, [sp, #4]
 800c210:	9507      	str	r5, [sp, #28]
 800c212:	9d05      	ldr	r5, [sp, #20]
 800c214:	f1c0 0201 	rsb	r2, r0, #1
 800c218:	2900      	cmp	r1, #0
 800c21a:	eb05 0bc3 	add.w	fp, r5, r3, lsl #3
 800c21e:	9b06      	ldr	r3, [sp, #24]
 800c220:	f8cd 8018 	str.w	r8, [sp, #24]
 800c224:	fb02 f201 	mul.w	r2, r2, r1
 800c228:	bfc8      	it	gt
 800c22a:	2200      	movgt	r2, #0
 800c22c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800c230:	9308      	str	r3, [sp, #32]
 800c232:	9b02      	ldr	r3, [sp, #8]
 800c234:	00db      	lsls	r3, r3, #3
 800c236:	9305      	str	r3, [sp, #20]
 800c238:	9b04      	ldr	r3, [sp, #16]
      INDEX ix = OFFSET(lenX, incX);
 800c23a:	2400      	movs	r4, #0
 800c23c:	9403      	str	r4, [sp, #12]
 800c23e:	ea4f 0ac1 	mov.w	sl, r1, lsl #3
 800c242:	eb03 09c0 	add.w	r9, r3, r0, lsl #3
 800c246:	46a0      	mov	r8, r4
      for (j = 0; j < lenX; j++) {
 800c248:	9b01      	ldr	r3, [sp, #4]
 800c24a:	2b00      	cmp	r3, #0
 800c24c:	f04f 0400 	mov.w	r4, #0
 800c250:	f04f 0500 	mov.w	r5, #0
 800c254:	dd15      	ble.n	800c282 <cblas_dgemv+0x1aa>
 800c256:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 800c25a:	9e08      	ldr	r6, [sp, #32]
 800c25c:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        temp += X[ix] * A[lda * i + j];
 800c260:	e9d6 2300 	ldrd	r2, r3, [r6]
 800c264:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 800c268:	f01b fe1e 	bl	8027ea8 <__aeabi_dmul>
 800c26c:	4602      	mov	r2, r0
 800c26e:	460b      	mov	r3, r1
 800c270:	4620      	mov	r0, r4
 800c272:	4629      	mov	r1, r5
 800c274:	f01b fc62 	bl	8027b3c <__adddf3>
      for (j = 0; j < lenX; j++) {
 800c278:	45b9      	cmp	r9, r7
 800c27a:	4456      	add	r6, sl
        temp += X[ix] * A[lda * i + j];
 800c27c:	4604      	mov	r4, r0
 800c27e:	460d      	mov	r5, r1
      for (j = 0; j < lenX; j++) {
 800c280:	d1ee      	bne.n	800c260 <cblas_dgemv+0x188>
      Y[iy] += alpha * temp;
 800c282:	4622      	mov	r2, r4
 800c284:	462b      	mov	r3, r5
 800c286:	ec51 0b18 	vmov	r0, r1, d8
 800c28a:	f01b fe0d 	bl	8027ea8 <__aeabi_dmul>
 800c28e:	4602      	mov	r2, r0
 800c290:	460b      	mov	r3, r1
 800c292:	e9db 0100 	ldrd	r0, r1, [fp]
 800c296:	f01b fc51 	bl	8027b3c <__adddf3>
 800c29a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c29e:	4413      	add	r3, r2
 800c2a0:	9303      	str	r3, [sp, #12]
 800c2a2:	9b05      	ldr	r3, [sp, #20]
 800c2a4:	4499      	add	r9, r3
 800c2a6:	9b07      	ldr	r3, [sp, #28]
 800c2a8:	e9cb 0100 	strd	r0, r1, [fp]
    for (i = 0; i < lenY; i++) {
 800c2ac:	449b      	add	fp, r3
 800c2ae:	9b06      	ldr	r3, [sp, #24]
 800c2b0:	f108 0801 	add.w	r8, r8, #1
 800c2b4:	4543      	cmp	r3, r8
 800c2b6:	d1c7      	bne.n	800c248 <cblas_dgemv+0x170>
 800c2b8:	b00b      	add	sp, #44	; 0x2c
 800c2ba:	ecbd 8b02 	vpop	{d8}
 800c2be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800c2c2:	4643      	mov	r3, r8
 800c2c4:	2b01      	cmp	r3, #1
 800c2c6:	9a02      	ldr	r2, [sp, #8]
 800c2c8:	bfb8      	it	lt
 800c2ca:	2301      	movlt	r3, #1
 800c2cc:	4293      	cmp	r3, r2
 800c2ce:	f77f af34 	ble.w	800c13a <cblas_dgemv+0x62>
 800c2d2:	9b03      	ldr	r3, [sp, #12]
 800c2d4:	2b00      	cmp	r3, #0
 800c2d6:	f43f af34 	beq.w	800c142 <cblas_dgemv+0x6a>
 800c2da:	2f00      	cmp	r7, #0
 800c2dc:	bf14      	ite	ne
 800c2de:	2007      	movne	r0, #7
 800c2e0:	200c      	moveq	r0, #12
 800c2e2:	e732      	b.n	800c14a <cblas_dgemv+0x72>
 800c2e4:	2f00      	cmp	r7, #0
 800c2e6:	d03e      	beq.n	800c366 <cblas_dgemv+0x28e>
 800c2e8:	2800      	cmp	r0, #0
 800c2ea:	f43f af32 	beq.w	800c152 <cblas_dgemv+0x7a>
 800c2ee:	e72c      	b.n	800c14a <cblas_dgemv+0x72>
 800c2f0:	3865      	subs	r0, #101	; 0x65
 800c2f2:	2801      	cmp	r0, #1
 800c2f4:	bf94      	ite	ls
 800c2f6:	2000      	movls	r0, #0
 800c2f8:	2001      	movhi	r0, #1
 800c2fa:	2470      	movs	r4, #112	; 0x70
 800c2fc:	e70f      	b.n	800c11e <cblas_dgemv+0x46>
  } else if (beta != 1.0) {
 800c2fe:	4b54      	ldr	r3, [pc, #336]	; (800c450 <cblas_dgemv+0x378>)
 800c300:	2200      	movs	r2, #0
 800c302:	4650      	mov	r0, sl
 800c304:	4659      	mov	r1, fp
 800c306:	f01c f837 	bl	8028378 <__aeabi_dcmpeq>
 800c30a:	2800      	cmp	r0, #0
 800c30c:	f47f af5c 	bne.w	800c1c8 <cblas_dgemv+0xf0>
    INDEX iy = OFFSET(lenY, incY);
 800c310:	2f00      	cmp	r7, #0
 800c312:	dc03      	bgt.n	800c31c <cblas_dgemv+0x244>
 800c314:	f1c8 0001 	rsb	r0, r8, #1
 800c318:	fb00 f007 	mul.w	r0, r0, r7
    for (i = 0; i < lenY; i++) {
 800c31c:	f1b8 0f00 	cmp.w	r8, #0
 800c320:	f77f af52 	ble.w	800c1c8 <cblas_dgemv+0xf0>
 800c324:	9b05      	ldr	r3, [sp, #20]
 800c326:	9707      	str	r7, [sp, #28]
 800c328:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
 800c32c:	00fb      	lsls	r3, r7, #3
 800c32e:	f04f 0900 	mov.w	r9, #0
 800c332:	462f      	mov	r7, r5
 800c334:	4625      	mov	r5, r4
 800c336:	461c      	mov	r4, r3
      Y[iy] *= beta;
 800c338:	e9d6 0100 	ldrd	r0, r1, [r6]
 800c33c:	4652      	mov	r2, sl
 800c33e:	465b      	mov	r3, fp
 800c340:	f01b fdb2 	bl	8027ea8 <__aeabi_dmul>
    for (i = 0; i < lenY; i++) {
 800c344:	f109 0901 	add.w	r9, r9, #1
 800c348:	45c8      	cmp	r8, r9
      Y[iy] *= beta;
 800c34a:	e9c6 0100 	strd	r0, r1, [r6]
    for (i = 0; i < lenY; i++) {
 800c34e:	4426      	add	r6, r4
 800c350:	d1f2      	bne.n	800c338 <cblas_dgemv+0x260>
 800c352:	462c      	mov	r4, r5
 800c354:	463d      	mov	r5, r7
 800c356:	9f07      	ldr	r7, [sp, #28]
 800c358:	e736      	b.n	800c1c8 <cblas_dgemv+0xf0>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 800c35a:	3865      	subs	r0, #101	; 0x65
 800c35c:	2801      	cmp	r0, #1
 800c35e:	bf94      	ite	ls
 800c360:	2000      	movls	r0, #0
 800c362:	2001      	movhi	r0, #1
 800c364:	e6db      	b.n	800c11e <cblas_dgemv+0x46>
 800c366:	200c      	movs	r0, #12
 800c368:	e6ef      	b.n	800c14a <cblas_dgemv+0x72>
  if ((order == CblasRowMajor && Trans == CblasNoTrans)
 800c36a:	2c6f      	cmp	r4, #111	; 0x6f
 800c36c:	f43f af46 	beq.w	800c1fc <cblas_dgemv+0x124>
  } else if ((order == CblasRowMajor && Trans == CblasTrans)
 800c370:	2c70      	cmp	r4, #112	; 0x70
 800c372:	f47f af36 	bne.w	800c1e2 <cblas_dgemv+0x10a>
    INDEX ix = OFFSET(lenX, incX);
 800c376:	9b03      	ldr	r3, [sp, #12]
 800c378:	2b00      	cmp	r3, #0
 800c37a:	dd76      	ble.n	800c46a <cblas_dgemv+0x392>
 800c37c:	2500      	movs	r5, #0
    for (j = 0; j < lenX; j++) {
 800c37e:	9b01      	ldr	r3, [sp, #4]
 800c380:	2b00      	cmp	r3, #0
 800c382:	dd99      	ble.n	800c2b8 <cblas_dgemv+0x1e0>
 800c384:	9903      	ldr	r1, [sp, #12]
 800c386:	f8cd 801c 	str.w	r8, [sp, #28]
 800c38a:	00c9      	lsls	r1, r1, #3
 800c38c:	9103      	str	r1, [sp, #12]
 800c38e:	9906      	ldr	r1, [sp, #24]
 800c390:	f1c8 0301 	rsb	r3, r8, #1
 800c394:	2f00      	cmp	r7, #0
 800c396:	eb01 05c5 	add.w	r5, r1, r5, lsl #3
 800c39a:	9905      	ldr	r1, [sp, #20]
 800c39c:	fb03 f307 	mul.w	r3, r3, r7
 800c3a0:	bfc8      	it	gt
 800c3a2:	2300      	movgt	r3, #0
 800c3a4:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 800c3a8:	9308      	str	r3, [sp, #32]
 800c3aa:	00fb      	lsls	r3, r7, #3
 800c3ac:	9309      	str	r3, [sp, #36]	; 0x24
 800c3ae:	9b02      	ldr	r3, [sp, #8]
 800c3b0:	00db      	lsls	r3, r3, #3
 800c3b2:	9305      	str	r3, [sp, #20]
 800c3b4:	9b04      	ldr	r3, [sp, #16]
        INDEX iy = OFFSET(lenY, incY);
 800c3b6:	2200      	movs	r2, #0
 800c3b8:	eb03 04c8 	add.w	r4, r3, r8, lsl #3
 800c3bc:	4691      	mov	r9, r2
 800c3be:	4690      	mov	r8, r2
 800c3c0:	e00b      	b.n	800c3da <cblas_dgemv+0x302>
    for (j = 0; j < lenX; j++) {
 800c3c2:	9b03      	ldr	r3, [sp, #12]
 800c3c4:	441d      	add	r5, r3
 800c3c6:	9b02      	ldr	r3, [sp, #8]
 800c3c8:	4498      	add	r8, r3
 800c3ca:	9b05      	ldr	r3, [sp, #20]
 800c3cc:	441c      	add	r4, r3
 800c3ce:	9b01      	ldr	r3, [sp, #4]
 800c3d0:	f109 0901 	add.w	r9, r9, #1
 800c3d4:	454b      	cmp	r3, r9
 800c3d6:	f43f af6f 	beq.w	800c2b8 <cblas_dgemv+0x1e0>
      const BASE temp = alpha * X[ix];
 800c3da:	e9d5 2300 	ldrd	r2, r3, [r5]
 800c3de:	ec51 0b18 	vmov	r0, r1, d8
 800c3e2:	f01b fd61 	bl	8027ea8 <__aeabi_dmul>
      if (temp != 0.0) {
 800c3e6:	2200      	movs	r2, #0
 800c3e8:	2300      	movs	r3, #0
      const BASE temp = alpha * X[ix];
 800c3ea:	4606      	mov	r6, r0
 800c3ec:	460f      	mov	r7, r1
      if (temp != 0.0) {
 800c3ee:	f01b ffc3 	bl	8028378 <__aeabi_dcmpeq>
 800c3f2:	2800      	cmp	r0, #0
 800c3f4:	d1e5      	bne.n	800c3c2 <cblas_dgemv+0x2ea>
        for (i = 0; i < lenY; i++) {
 800c3f6:	9b07      	ldr	r3, [sp, #28]
 800c3f8:	2b00      	cmp	r3, #0
 800c3fa:	dde2      	ble.n	800c3c2 <cblas_dgemv+0x2ea>
 800c3fc:	9b04      	ldr	r3, [sp, #16]
 800c3fe:	9506      	str	r5, [sp, #24]
 800c400:	f8dd a020 	ldr.w	sl, [sp, #32]
 800c404:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800c406:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
          Y[iy] += temp * A[lda * j + i];
 800c40a:	e8fb 0102 	ldrd	r0, r1, [fp], #8
 800c40e:	4632      	mov	r2, r6
 800c410:	463b      	mov	r3, r7
 800c412:	f01b fd49 	bl	8027ea8 <__aeabi_dmul>
 800c416:	4602      	mov	r2, r0
 800c418:	460b      	mov	r3, r1
 800c41a:	e9da 0100 	ldrd	r0, r1, [sl]
 800c41e:	f01b fb8d 	bl	8027b3c <__adddf3>
        for (i = 0; i < lenY; i++) {
 800c422:	45a3      	cmp	fp, r4
          Y[iy] += temp * A[lda * j + i];
 800c424:	e9ca 0100 	strd	r0, r1, [sl]
        for (i = 0; i < lenY; i++) {
 800c428:	44aa      	add	sl, r5
 800c42a:	d1ee      	bne.n	800c40a <cblas_dgemv+0x332>
 800c42c:	9d06      	ldr	r5, [sp, #24]
 800c42e:	e7c8      	b.n	800c3c2 <cblas_dgemv+0x2ea>
    INDEX iy = OFFSET(lenY, incY);
 800c430:	f1c8 0301 	rsb	r3, r8, #1
 800c434:	fb03 f307 	mul.w	r3, r3, r7
 800c438:	e6b6      	b.n	800c1a8 <cblas_dgemv+0xd0>
 800c43a:	bf00      	nop
 800c43c:	f3af 8000 	nop.w
	...
 800c448:	08030378 	.word	0x08030378
 800c44c:	080305c0 	.word	0x080305c0
 800c450:	3ff00000 	.word	0x3ff00000
 800c454:	080305a8 	.word	0x080305a8
             || (order == CblasColMajor && Trans == CblasNoTrans)) {
 800c458:	2c6f      	cmp	r4, #111	; 0x6f
 800c45a:	f47f aec2 	bne.w	800c1e2 <cblas_dgemv+0x10a>
 800c45e:	e78a      	b.n	800c376 <cblas_dgemv+0x29e>
    INDEX iy = OFFSET(lenY, incY);
 800c460:	f1c8 0301 	rsb	r3, r8, #1
 800c464:	fb03 f307 	mul.w	r3, r3, r7
 800c468:	e6cc      	b.n	800c204 <cblas_dgemv+0x12c>
    INDEX ix = OFFSET(lenX, incX);
 800c46a:	9a01      	ldr	r2, [sp, #4]
 800c46c:	f1c2 0501 	rsb	r5, r2, #1
 800c470:	fb05 f503 	mul.w	r5, r5, r3
 800c474:	e783      	b.n	800c37e <cblas_dgemv+0x2a6>
 800c476:	bf00      	nop

0800c478 <cblas_dger>:

void
cblas_dger (const enum CBLAS_ORDER order, const int M, const int N,
            const double alpha, const double *X, const int incX,
            const double *Y, const int incY, double *A, const int lda)
{
 800c478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c47c:	ed2d 8b02 	vpush	{d8}
 800c480:	eeb0 8a40 	vmov.f32	s16, s0
 800c484:	eef0 8a60 	vmov.f32	s17, s1
 800c488:	b08b      	sub	sp, #44	; 0x2c
 800c48a:	461e      	mov	r6, r3
 800c48c:	e9dd 4318 	ldrd	r4, r3, [sp, #96]	; 0x60
 800c490:	9305      	str	r3, [sp, #20]
 800c492:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800c494:	9303      	str	r3, [sp, #12]
 800c496:	1e0b      	subs	r3, r1, #0
 800c498:	e9dd 5716 	ldrd	r5, r7, [sp, #88]	; 0x58
 800c49c:	4680      	mov	r8, r0
 800c49e:	9201      	str	r2, [sp, #4]
 800c4a0:	9304      	str	r3, [sp, #16]
 800c4a2:	f2c0 8095 	blt.w	800c5d0 <cblas_dger+0x158>
 800c4a6:	3865      	subs	r0, #101	; 0x65
 800c4a8:	2801      	cmp	r0, #1
 800c4aa:	bf94      	ite	ls
 800c4ac:	2000      	movls	r0, #0
 800c4ae:	2001      	movhi	r0, #1
 800c4b0:	9b01      	ldr	r3, [sp, #4]
 800c4b2:	2b00      	cmp	r3, #0
 800c4b4:	bfb8      	it	lt
 800c4b6:	2003      	movlt	r0, #3
 800c4b8:	2d00      	cmp	r5, #0
 800c4ba:	d174      	bne.n	800c5a6 <cblas_dger+0x12e>
 800c4bc:	2c00      	cmp	r4, #0
 800c4be:	d168      	bne.n	800c592 <cblas_dger+0x11a>
 800c4c0:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c4c4:	f000 8086 	beq.w	800c5d4 <cblas_dger+0x15c>
 800c4c8:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800c4cc:	f000 8106 	beq.w	800c6dc <cblas_dger+0x264>
 800c4d0:	2008      	movs	r0, #8
 800c4d2:	4a95      	ldr	r2, [pc, #596]	; (800c728 <cblas_dger+0x2b0>)
 800c4d4:	4995      	ldr	r1, [pc, #596]	; (800c72c <cblas_dger+0x2b4>)
 800c4d6:	f01b fab7 	bl	8027a48 <cblas_xerbla>
  } else if (order == CblasColMajor) {
 800c4da:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800c4de:	d16d      	bne.n	800c5bc <cblas_dger+0x144>
    INDEX jy = OFFSET(N, incY);
 800c4e0:	2c00      	cmp	r4, #0
 800c4e2:	f340 80dc 	ble.w	800c69e <cblas_dger+0x226>
 800c4e6:	2300      	movs	r3, #0
    for (j = 0; j < N; j++) {
 800c4e8:	9a01      	ldr	r2, [sp, #4]
 800c4ea:	2a00      	cmp	r2, #0
 800c4ec:	dd4c      	ble.n	800c588 <cblas_dger+0x110>
 800c4ee:	9904      	ldr	r1, [sp, #16]
 800c4f0:	2d00      	cmp	r5, #0
 800c4f2:	f1c1 0201 	rsb	r2, r1, #1
 800c4f6:	fb02 f205 	mul.w	r2, r2, r5
 800c4fa:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
 800c4fe:	bfc8      	it	gt
 800c500:	2200      	movgt	r2, #0
 800c502:	9300      	str	r3, [sp, #0]
 800c504:	eb06 03c2 	add.w	r3, r6, r2, lsl #3
 800c508:	9309      	str	r3, [sp, #36]	; 0x24
 800c50a:	9b03      	ldr	r3, [sp, #12]
 800c50c:	00db      	lsls	r3, r3, #3
 800c50e:	9308      	str	r3, [sp, #32]
 800c510:	9b05      	ldr	r3, [sp, #20]
      INDEX ix = OFFSET(M, incX);
 800c512:	2000      	movs	r0, #0
 800c514:	00e4      	lsls	r4, r4, #3
 800c516:	9002      	str	r0, [sp, #8]
 800c518:	9407      	str	r4, [sp, #28]
 800c51a:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
 800c51e:	9006      	str	r0, [sp, #24]
 800c520:	eb03 0bc1 	add.w	fp, r3, r1, lsl #3
      const BASE tmp = alpha * Y[jy];
 800c524:	9b00      	ldr	r3, [sp, #0]
 800c526:	ec51 0b18 	vmov	r0, r1, d8
 800c52a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800c52e:	f01b fcbb 	bl	8027ea8 <__aeabi_dmul>
      for (i = 0; i < M; i++) {
 800c532:	9b04      	ldr	r3, [sp, #16]
 800c534:	2b00      	cmp	r3, #0
      const BASE tmp = alpha * Y[jy];
 800c536:	4680      	mov	r8, r0
 800c538:	4689      	mov	r9, r1
      for (i = 0; i < M; i++) {
 800c53a:	dd15      	ble.n	800c568 <cblas_dger+0xf0>
 800c53c:	9b05      	ldr	r3, [sp, #20]
 800c53e:	9a02      	ldr	r2, [sp, #8]
 800c540:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800c542:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[i + lda * j] += X[ix] * tmp;
 800c546:	e9d4 6700 	ldrd	r6, r7, [r4]
 800c54a:	e9d5 2300 	ldrd	r2, r3, [r5]
 800c54e:	4640      	mov	r0, r8
 800c550:	4649      	mov	r1, r9
 800c552:	f01b fca9 	bl	8027ea8 <__aeabi_dmul>
 800c556:	4632      	mov	r2, r6
 800c558:	463b      	mov	r3, r7
 800c55a:	f01b faef 	bl	8027b3c <__adddf3>
 800c55e:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (i = 0; i < M; i++) {
 800c562:	455c      	cmp	r4, fp
 800c564:	4455      	add	r5, sl
 800c566:	d1ee      	bne.n	800c546 <cblas_dger+0xce>
    for (j = 0; j < N; j++) {
 800c568:	9a00      	ldr	r2, [sp, #0]
 800c56a:	9907      	ldr	r1, [sp, #28]
 800c56c:	9b06      	ldr	r3, [sp, #24]
 800c56e:	440a      	add	r2, r1
 800c570:	9200      	str	r2, [sp, #0]
 800c572:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 800c576:	440a      	add	r2, r1
 800c578:	9202      	str	r2, [sp, #8]
 800c57a:	9a08      	ldr	r2, [sp, #32]
 800c57c:	4493      	add	fp, r2
 800c57e:	9a01      	ldr	r2, [sp, #4]
 800c580:	3301      	adds	r3, #1
 800c582:	429a      	cmp	r2, r3
 800c584:	9306      	str	r3, [sp, #24]
 800c586:	d1cd      	bne.n	800c524 <cblas_dger+0xac>
#define BASE double
#include "source_ger.h"
#undef BASE
}
 800c588:	b00b      	add	sp, #44	; 0x2c
 800c58a:	ecbd 8b02 	vpop	{d8}
 800c58e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800c592:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c596:	f000 8091 	beq.w	800c6bc <cblas_dger+0x244>
 800c59a:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800c59e:	f000 80b6 	beq.w	800c70e <cblas_dger+0x296>
 800c5a2:	2006      	movs	r0, #6
 800c5a4:	e795      	b.n	800c4d2 <cblas_dger+0x5a>
 800c5a6:	2c00      	cmp	r4, #0
 800c5a8:	d08a      	beq.n	800c4c0 <cblas_dger+0x48>
 800c5aa:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 800c5ae:	d07c      	beq.n	800c6aa <cblas_dger+0x232>
 800c5b0:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 800c5b4:	f000 80a0 	beq.w	800c6f8 <cblas_dger+0x280>
 800c5b8:	2800      	cmp	r0, #0
 800c5ba:	d18a      	bne.n	800c4d2 <cblas_dger+0x5a>
    BLAS_ERROR("unrecognized operation");
 800c5bc:	4a5c      	ldr	r2, [pc, #368]	; (800c730 <cblas_dger+0x2b8>)
 800c5be:	495b      	ldr	r1, [pc, #364]	; (800c72c <cblas_dger+0x2b4>)
 800c5c0:	2000      	movs	r0, #0
 800c5c2:	b00b      	add	sp, #44	; 0x2c
 800c5c4:	ecbd 8b02 	vpop	{d8}
 800c5c8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c5cc:	f01b ba3c 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800c5d0:	2002      	movs	r0, #2
 800c5d2:	e76d      	b.n	800c4b0 <cblas_dger+0x38>
 800c5d4:	9801      	ldr	r0, [sp, #4]
 800c5d6:	9b03      	ldr	r3, [sp, #12]
 800c5d8:	2801      	cmp	r0, #1
 800c5da:	bfb8      	it	lt
 800c5dc:	2001      	movlt	r0, #1
 800c5de:	4283      	cmp	r3, r0
 800c5e0:	bfac      	ite	ge
 800c5e2:	2008      	movge	r0, #8
 800c5e4:	200a      	movlt	r0, #10
 800c5e6:	4a50      	ldr	r2, [pc, #320]	; (800c728 <cblas_dger+0x2b0>)
 800c5e8:	4950      	ldr	r1, [pc, #320]	; (800c72c <cblas_dger+0x2b4>)
 800c5ea:	f01b fa2d 	bl	8027a48 <cblas_xerbla>
    INDEX ix = OFFSET(M, incX);
 800c5ee:	2d00      	cmp	r5, #0
 800c5f0:	dd6e      	ble.n	800c6d0 <cblas_dger+0x258>
 800c5f2:	2300      	movs	r3, #0
    for (i = 0; i < M; i++) {
 800c5f4:	9a04      	ldr	r2, [sp, #16]
 800c5f6:	2a00      	cmp	r2, #0
 800c5f8:	ddc6      	ble.n	800c588 <cblas_dger+0x110>
 800c5fa:	9901      	ldr	r1, [sp, #4]
 800c5fc:	2c00      	cmp	r4, #0
 800c5fe:	f1c1 0201 	rsb	r2, r1, #1
 800c602:	fb02 f204 	mul.w	r2, r2, r4
 800c606:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 800c60a:	bfc8      	it	gt
 800c60c:	2200      	movgt	r2, #0
 800c60e:	9300      	str	r3, [sp, #0]
 800c610:	eb07 03c2 	add.w	r3, r7, r2, lsl #3
 800c614:	9309      	str	r3, [sp, #36]	; 0x24
 800c616:	9b03      	ldr	r3, [sp, #12]
 800c618:	00db      	lsls	r3, r3, #3
 800c61a:	9307      	str	r3, [sp, #28]
 800c61c:	9b05      	ldr	r3, [sp, #20]
      INDEX jy = OFFSET(N, incY);
 800c61e:	2000      	movs	r0, #0
 800c620:	00ed      	lsls	r5, r5, #3
 800c622:	9002      	str	r0, [sp, #8]
 800c624:	9508      	str	r5, [sp, #32]
 800c626:	ea4f 0ac4 	mov.w	sl, r4, lsl #3
 800c62a:	9006      	str	r0, [sp, #24]
 800c62c:	eb03 0bc1 	add.w	fp, r3, r1, lsl #3
      const BASE tmp = alpha * X[ix];
 800c630:	9b00      	ldr	r3, [sp, #0]
 800c632:	ec51 0b18 	vmov	r0, r1, d8
 800c636:	e9d3 2300 	ldrd	r2, r3, [r3]
 800c63a:	f01b fc35 	bl	8027ea8 <__aeabi_dmul>
      for (j = 0; j < N; j++) {
 800c63e:	9b01      	ldr	r3, [sp, #4]
 800c640:	2b00      	cmp	r3, #0
      const BASE tmp = alpha * X[ix];
 800c642:	4680      	mov	r8, r0
 800c644:	4689      	mov	r9, r1
      for (j = 0; j < N; j++) {
 800c646:	dd15      	ble.n	800c674 <cblas_dger+0x1fc>
 800c648:	9b05      	ldr	r3, [sp, #20]
 800c64a:	9a02      	ldr	r2, [sp, #8]
 800c64c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 800c64e:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[lda * i + j] += Y[jy] * tmp;
 800c652:	e9d4 6700 	ldrd	r6, r7, [r4]
 800c656:	e9d5 2300 	ldrd	r2, r3, [r5]
 800c65a:	4640      	mov	r0, r8
 800c65c:	4649      	mov	r1, r9
 800c65e:	f01b fc23 	bl	8027ea8 <__aeabi_dmul>
 800c662:	4632      	mov	r2, r6
 800c664:	463b      	mov	r3, r7
 800c666:	f01b fa69 	bl	8027b3c <__adddf3>
 800c66a:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j < N; j++) {
 800c66e:	455c      	cmp	r4, fp
 800c670:	4455      	add	r5, sl
 800c672:	d1ee      	bne.n	800c652 <cblas_dger+0x1da>
    for (i = 0; i < M; i++) {
 800c674:	9a00      	ldr	r2, [sp, #0]
 800c676:	9908      	ldr	r1, [sp, #32]
 800c678:	9b06      	ldr	r3, [sp, #24]
 800c67a:	440a      	add	r2, r1
 800c67c:	9200      	str	r2, [sp, #0]
 800c67e:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 800c682:	440a      	add	r2, r1
 800c684:	9202      	str	r2, [sp, #8]
 800c686:	9a07      	ldr	r2, [sp, #28]
 800c688:	4493      	add	fp, r2
 800c68a:	9a04      	ldr	r2, [sp, #16]
 800c68c:	3301      	adds	r3, #1
 800c68e:	429a      	cmp	r2, r3
 800c690:	9306      	str	r3, [sp, #24]
 800c692:	d1cd      	bne.n	800c630 <cblas_dger+0x1b8>
 800c694:	b00b      	add	sp, #44	; 0x2c
 800c696:	ecbd 8b02 	vpop	{d8}
 800c69a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    INDEX jy = OFFSET(N, incY);
 800c69e:	9b01      	ldr	r3, [sp, #4]
 800c6a0:	f1c3 0301 	rsb	r3, r3, #1
 800c6a4:	fb03 f304 	mul.w	r3, r3, r4
 800c6a8:	e71e      	b.n	800c4e8 <cblas_dger+0x70>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800c6aa:	9b01      	ldr	r3, [sp, #4]
 800c6ac:	9a03      	ldr	r2, [sp, #12]
 800c6ae:	2b01      	cmp	r3, #1
 800c6b0:	bfb8      	it	lt
 800c6b2:	2301      	movlt	r3, #1
 800c6b4:	4293      	cmp	r3, r2
 800c6b6:	dd32      	ble.n	800c71e <cblas_dger+0x2a6>
 800c6b8:	200a      	movs	r0, #10
 800c6ba:	e794      	b.n	800c5e6 <cblas_dger+0x16e>
 800c6bc:	4618      	mov	r0, r3
 800c6be:	2b01      	cmp	r3, #1
 800c6c0:	9b03      	ldr	r3, [sp, #12]
 800c6c2:	bfb8      	it	lt
 800c6c4:	2001      	movlt	r0, #1
 800c6c6:	4298      	cmp	r0, r3
 800c6c8:	bfcc      	ite	gt
 800c6ca:	200a      	movgt	r0, #10
 800c6cc:	2006      	movle	r0, #6
 800c6ce:	e78a      	b.n	800c5e6 <cblas_dger+0x16e>
    INDEX ix = OFFSET(M, incX);
 800c6d0:	9b04      	ldr	r3, [sp, #16]
 800c6d2:	f1c3 0301 	rsb	r3, r3, #1
 800c6d6:	fb03 f305 	mul.w	r3, r3, r5
 800c6da:	e78b      	b.n	800c5f4 <cblas_dger+0x17c>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800c6dc:	9b04      	ldr	r3, [sp, #16]
 800c6de:	9a03      	ldr	r2, [sp, #12]
 800c6e0:	2b01      	cmp	r3, #1
 800c6e2:	bfb8      	it	lt
 800c6e4:	2301      	movlt	r3, #1
 800c6e6:	4293      	cmp	r3, r2
 800c6e8:	f77f aef2 	ble.w	800c4d0 <cblas_dger+0x58>
 800c6ec:	4a0e      	ldr	r2, [pc, #56]	; (800c728 <cblas_dger+0x2b0>)
 800c6ee:	490f      	ldr	r1, [pc, #60]	; (800c72c <cblas_dger+0x2b4>)
 800c6f0:	200a      	movs	r0, #10
 800c6f2:	f01b f9a9 	bl	8027a48 <cblas_xerbla>
  if (order == CblasRowMajor) {
 800c6f6:	e6f3      	b.n	800c4e0 <cblas_dger+0x68>
  CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
 800c6f8:	9b04      	ldr	r3, [sp, #16]
 800c6fa:	9a03      	ldr	r2, [sp, #12]
 800c6fc:	2b01      	cmp	r3, #1
 800c6fe:	bfb8      	it	lt
 800c700:	2301      	movlt	r3, #1
 800c702:	4293      	cmp	r3, r2
 800c704:	dcf2      	bgt.n	800c6ec <cblas_dger+0x274>
 800c706:	2800      	cmp	r0, #0
 800c708:	f43f aeea 	beq.w	800c4e0 <cblas_dger+0x68>
 800c70c:	e6e1      	b.n	800c4d2 <cblas_dger+0x5a>
 800c70e:	9b04      	ldr	r3, [sp, #16]
 800c710:	9a03      	ldr	r2, [sp, #12]
 800c712:	2b01      	cmp	r3, #1
 800c714:	bfb8      	it	lt
 800c716:	2301      	movlt	r3, #1
 800c718:	429a      	cmp	r2, r3
 800c71a:	dbe7      	blt.n	800c6ec <cblas_dger+0x274>
 800c71c:	e741      	b.n	800c5a2 <cblas_dger+0x12a>
 800c71e:	2800      	cmp	r0, #0
 800c720:	f43f af65 	beq.w	800c5ee <cblas_dger+0x176>
 800c724:	e75f      	b.n	800c5e6 <cblas_dger+0x16e>
 800c726:	bf00      	nop
 800c728:	08030378 	.word	0x08030378
 800c72c:	080305d0 	.word	0x080305d0
 800c730:	080305a8 	.word	0x080305a8
 800c734:	00000000 	.word	0x00000000

0800c738 <cblas_dnrm2>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dnrm2 (const int N, const double *X, const int incX)
{
 800c738:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c73c:	b085      	sub	sp, #20
  if (N <= 0 || incX <= 0) {
 800c73e:	1e03      	subs	r3, r0, #0
 800c740:	9302      	str	r3, [sp, #8]
 800c742:	dd58      	ble.n	800c7f6 <cblas_dnrm2+0xbe>
 800c744:	2a00      	cmp	r2, #0
 800c746:	dd56      	ble.n	800c7f6 <cblas_dnrm2+0xbe>
  } else if (N == 1) {
 800c748:	2b01      	cmp	r3, #1
 800c74a:	d068      	beq.n	800c81e <cblas_dnrm2+0xe6>
  BASE ssq = 1.0;
 800c74c:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 800c838 <cblas_dnrm2+0x100>
 800c750:	00d3      	lsls	r3, r2, #3
 800c752:	ed8d 7b00 	vstr	d7, [sp]
  BASE scale = 0.0;
 800c756:	f04f 0800 	mov.w	r8, #0
 800c75a:	f04f 0900 	mov.w	r9, #0
 800c75e:	9303      	str	r3, [sp, #12]
 800c760:	460c      	mov	r4, r1
  for (i = 0; i < N; i++) {
 800c762:	2500      	movs	r5, #0
 800c764:	e019      	b.n	800c79a <cblas_dnrm2+0x62>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 800c766:	f01b fcc9 	bl	80280fc <__aeabi_ddiv>
 800c76a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800c76e:	4606      	mov	r6, r0
 800c770:	460f      	mov	r7, r1
 800c772:	f01b fb99 	bl	8027ea8 <__aeabi_dmul>
 800c776:	4632      	mov	r2, r6
 800c778:	463b      	mov	r3, r7
 800c77a:	f01b fb95 	bl	8027ea8 <__aeabi_dmul>
 800c77e:	4b32      	ldr	r3, [pc, #200]	; (800c848 <cblas_dnrm2+0x110>)
 800c780:	2200      	movs	r2, #0
 800c782:	f01b f9db 	bl	8027b3c <__adddf3>
 800c786:	e9cd 0100 	strd	r0, r1, [sp]
        scale = ax;
 800c78a:	46d0      	mov	r8, sl
 800c78c:	46d9      	mov	r9, fp
  for (i = 0; i < N; i++) {
 800c78e:	9b03      	ldr	r3, [sp, #12]
 800c790:	441c      	add	r4, r3
 800c792:	9b02      	ldr	r3, [sp, #8]
 800c794:	3501      	adds	r5, #1
 800c796:	42ab      	cmp	r3, r5
 800c798:	d032      	beq.n	800c800 <cblas_dnrm2+0xc8>
    const BASE x = X[ix];
 800c79a:	e9d4 6700 	ldrd	r6, r7, [r4]
    if (x != 0.0) {
 800c79e:	2200      	movs	r2, #0
 800c7a0:	2300      	movs	r3, #0
 800c7a2:	4630      	mov	r0, r6
 800c7a4:	4639      	mov	r1, r7
 800c7a6:	f01b fde7 	bl	8028378 <__aeabi_dcmpeq>
      if (scale < ax) {
 800c7aa:	4642      	mov	r2, r8
 800c7ac:	464b      	mov	r3, r9
    if (x != 0.0) {
 800c7ae:	2800      	cmp	r0, #0
 800c7b0:	d1ed      	bne.n	800c78e <cblas_dnrm2+0x56>
      const BASE ax = fabs(x);
 800c7b2:	f027 4b00 	bic.w	fp, r7, #2147483648	; 0x80000000
      if (scale < ax) {
 800c7b6:	4659      	mov	r1, fp
 800c7b8:	4630      	mov	r0, r6
 800c7ba:	f01b fe05 	bl	80283c8 <__aeabi_dcmpgt>
 800c7be:	4684      	mov	ip, r0
      const BASE ax = fabs(x);
 800c7c0:	46b2      	mov	sl, r6
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 800c7c2:	4632      	mov	r2, r6
 800c7c4:	465b      	mov	r3, fp
 800c7c6:	4640      	mov	r0, r8
 800c7c8:	4649      	mov	r1, r9
      if (scale < ax) {
 800c7ca:	f1bc 0f00 	cmp.w	ip, #0
 800c7ce:	d1ca      	bne.n	800c766 <cblas_dnrm2+0x2e>
        ssq += (ax / scale) * (ax / scale);
 800c7d0:	4642      	mov	r2, r8
 800c7d2:	464b      	mov	r3, r9
 800c7d4:	4630      	mov	r0, r6
 800c7d6:	4639      	mov	r1, r7
 800c7d8:	f01b fc90 	bl	80280fc <__aeabi_ddiv>
 800c7dc:	4602      	mov	r2, r0
 800c7de:	460b      	mov	r3, r1
 800c7e0:	f01b fb62 	bl	8027ea8 <__aeabi_dmul>
 800c7e4:	4602      	mov	r2, r0
 800c7e6:	460b      	mov	r3, r1
 800c7e8:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c7ec:	f01b f9a6 	bl	8027b3c <__adddf3>
 800c7f0:	e9cd 0100 	strd	r0, r1, [sp]
 800c7f4:	e7cb      	b.n	800c78e <cblas_dnrm2+0x56>
    return 0;
 800c7f6:	ed9f 0b12 	vldr	d0, [pc, #72]	; 800c840 <cblas_dnrm2+0x108>
#define BASE double
#include "source_nrm2_r.h"
#undef BASE
}
 800c7fa:	b005      	add	sp, #20
 800c7fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return scale * sqrt(ssq);
 800c800:	ed9d 0b00 	vldr	d0, [sp]
 800c804:	f023 fb48 	bl	802fe98 <sqrt>
 800c808:	4642      	mov	r2, r8
 800c80a:	ec51 0b10 	vmov	r0, r1, d0
 800c80e:	464b      	mov	r3, r9
 800c810:	f01b fb4a 	bl	8027ea8 <__aeabi_dmul>
 800c814:	ec41 0b10 	vmov	d0, r0, r1
 800c818:	b005      	add	sp, #20
 800c81a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return fabs(X[0]);
 800c81e:	684b      	ldr	r3, [r1, #4]
 800c820:	ed91 0a00 	vldr	s0, [r1]
 800c824:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800c828:	ee00 3a90 	vmov	s1, r3
 800c82c:	b005      	add	sp, #20
 800c82e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800c832:	bf00      	nop
 800c834:	f3af 8000 	nop.w
 800c838:	00000000 	.word	0x00000000
 800c83c:	3ff00000 	.word	0x3ff00000
	...
 800c848:	3ff00000 	.word	0x3ff00000

0800c84c <cblas_drot>:
#include "cblas.h"

void
cblas_drot (const int N, double *X, const int incX, double *Y, const int incY,
            const double c, const double s)
{
 800c84c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c850:	ed2d 8b08 	vpush	{d8-d11}
 800c854:	eeb0 8a40 	vmov.f32	s16, s0
 800c858:	eef0 8a60 	vmov.f32	s17, s1
 800c85c:	eeb0 ba41 	vmov.f32	s22, s2
 800c860:	eef0 ba61 	vmov.f32	s23, s3
 800c864:	b083      	sub	sp, #12
 800c866:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 800c868:	2a00      	cmp	r2, #0
 800c86a:	9000      	str	r0, [sp, #0]
 800c86c:	9814      	ldr	r0, [sp, #80]	; 0x50
 800c86e:	bfda      	itte	le
 800c870:	f1c4 0b01 	rsble	fp, r4, #1
 800c874:	fb0b fb02 	mulle.w	fp, fp, r2
 800c878:	f04f 0b00 	movgt.w	fp, #0
  INDEX iy = OFFSET(N, incY);
 800c87c:	2800      	cmp	r0, #0
 800c87e:	bfdc      	itt	le
 800c880:	9c00      	ldrle	r4, [sp, #0]
 800c882:	f1c4 0a01 	rsble	sl, r4, #1
  for (i = 0; i < N; i++) {
 800c886:	9c00      	ldr	r4, [sp, #0]
  INDEX iy = OFFSET(N, incY);
 800c888:	bfd4      	ite	le
 800c88a:	fb0a fa00 	mulle.w	sl, sl, r0
 800c88e:	f04f 0a00 	movgt.w	sl, #0
  for (i = 0; i < N; i++) {
 800c892:	2c00      	cmp	r4, #0
 800c894:	dd47      	ble.n	800c926 <cblas_drot+0xda>
 800c896:	ec56 5b11 	vmov	r5, r6, d1
 800c89a:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 800c89e:	f106 4300 	add.w	r3, r6, #2147483648	; 0x80000000
 800c8a2:	ee0a 3a90 	vmov	s21, r3
 800c8a6:	00d2      	lsls	r2, r2, #3
 800c8a8:	2300      	movs	r3, #0
 800c8aa:	eeb0 aa41 	vmov.f32	s20, s2
 800c8ae:	9201      	str	r2, [sp, #4]
 800c8b0:	eb01 0bcb 	add.w	fp, r1, fp, lsl #3
 800c8b4:	00c7      	lsls	r7, r0, #3
 800c8b6:	461e      	mov	r6, r3
    const BASE x = X[ix];
 800c8b8:	e9db 4500 	ldrd	r4, r5, [fp]
    X[ix] = c * x + s * y;
 800c8bc:	ec53 2b18 	vmov	r2, r3, d8
 800c8c0:	4620      	mov	r0, r4
 800c8c2:	4629      	mov	r1, r5
 800c8c4:	f01b faf0 	bl	8027ea8 <__aeabi_dmul>
    const BASE y = Y[iy];
 800c8c8:	e9da 8900 	ldrd	r8, r9, [sl]
    X[ix] = c * x + s * y;
 800c8cc:	ec53 2b1b 	vmov	r2, r3, d11
 800c8d0:	ec41 0b19 	vmov	d9, r0, r1
 800c8d4:	4640      	mov	r0, r8
 800c8d6:	4649      	mov	r1, r9
 800c8d8:	f01b fae6 	bl	8027ea8 <__aeabi_dmul>
 800c8dc:	4602      	mov	r2, r0
 800c8de:	460b      	mov	r3, r1
 800c8e0:	ec51 0b19 	vmov	r0, r1, d9
 800c8e4:	f01b f92a 	bl	8027b3c <__adddf3>
    Y[iy] = -s * x + c * y;
 800c8e8:	ec53 2b1a 	vmov	r2, r3, d10
    X[ix] = c * x + s * y;
 800c8ec:	e9cb 0100 	strd	r0, r1, [fp]
    Y[iy] = -s * x + c * y;
 800c8f0:	4620      	mov	r0, r4
 800c8f2:	4629      	mov	r1, r5
 800c8f4:	f01b fad8 	bl	8027ea8 <__aeabi_dmul>
 800c8f8:	ec53 2b18 	vmov	r2, r3, d8
 800c8fc:	4604      	mov	r4, r0
 800c8fe:	460d      	mov	r5, r1
 800c900:	4640      	mov	r0, r8
 800c902:	4649      	mov	r1, r9
 800c904:	f01b fad0 	bl	8027ea8 <__aeabi_dmul>
 800c908:	460b      	mov	r3, r1
 800c90a:	4602      	mov	r2, r0
 800c90c:	4629      	mov	r1, r5
 800c90e:	4620      	mov	r0, r4
 800c910:	f01b f914 	bl	8027b3c <__adddf3>
 800c914:	9b01      	ldr	r3, [sp, #4]
 800c916:	449b      	add	fp, r3
  for (i = 0; i < N; i++) {
 800c918:	9b00      	ldr	r3, [sp, #0]
 800c91a:	3601      	adds	r6, #1
 800c91c:	42b3      	cmp	r3, r6
    Y[iy] = -s * x + c * y;
 800c91e:	e9ca 0100 	strd	r0, r1, [sl]
  for (i = 0; i < N; i++) {
 800c922:	44ba      	add	sl, r7
 800c924:	d1c8      	bne.n	800c8b8 <cblas_drot+0x6c>
#define BASE double
#include "source_rot.h"
#undef BASE
}
 800c926:	b003      	add	sp, #12
 800c928:	ecbd 8b08 	vpop	{d8-d11}
 800c92c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c930 <cblas_drotg>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_drotg (double *a, double *b, double *c, double *s)
{
 800c930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c934:	ed2d 8b02 	vpush	{d8}
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 800c938:	ed90 7b00 	vldr	d7, [r0]
 800c93c:	b089      	sub	sp, #36	; 0x24
 800c93e:	ed8d 7b00 	vstr	d7, [sp]
 800c942:	ed91 7b00 	vldr	d7, [r1]
 800c946:	9004      	str	r0, [sp, #16]
 800c948:	4689      	mov	r9, r1
 800c94a:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c94e:	ec5b ab17 	vmov	sl, fp, d7
 800c952:	f021 4500 	bic.w	r5, r1, #2147483648	; 0x80000000
 800c956:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
 800c95a:	4694      	mov	ip, r2
 800c95c:	4698      	mov	r8, r3
 800c95e:	ee17 2a10 	vmov	r2, s14
 800c962:	4629      	mov	r1, r5
 800c964:	463b      	mov	r3, r7
 800c966:	ed8d 7b02 	vstr	d7, [sp, #8]
 800c96a:	ee17 6a10 	vmov	r6, s14
 800c96e:	4604      	mov	r4, r0
 800c970:	f8cd c014 	str.w	ip, [sp, #20]
 800c974:	f01b fd28 	bl	80283c8 <__aeabi_dcmpgt>
 800c978:	bb38      	cbnz	r0, 800c9ca <cblas_drotg+0x9a>
 800c97a:	e9cd ab06 	strd	sl, fp, [sp, #24]
  const BASE scale = fabs(*a) + fabs(*b);
 800c97e:	4632      	mov	r2, r6
 800c980:	463b      	mov	r3, r7
 800c982:	4620      	mov	r0, r4
 800c984:	4629      	mov	r1, r5
 800c986:	f01b f8d9 	bl	8027b3c <__adddf3>
  if (scale != 0.0) {
 800c98a:	f04f 0a00 	mov.w	sl, #0
 800c98e:	f04f 0b00 	mov.w	fp, #0
 800c992:	4652      	mov	r2, sl
 800c994:	465b      	mov	r3, fp
  const BASE scale = fabs(*a) + fabs(*b);
 800c996:	4604      	mov	r4, r0
 800c998:	460d      	mov	r5, r1
  if (scale != 0.0) {
 800c99a:	f01b fced 	bl	8028378 <__aeabi_dcmpeq>
 800c99e:	b1c8      	cbz	r0, 800c9d4 <cblas_drotg+0xa4>
    *c = 1.0;
 800c9a0:	4b4f      	ldr	r3, [pc, #316]	; (800cae0 <cblas_drotg+0x1b0>)
 800c9a2:	9905      	ldr	r1, [sp, #20]
 800c9a4:	2200      	movs	r2, #0
 800c9a6:	e9c1 2300 	strd	r2, r3, [r1]
    *s = 0.0;
 800c9aa:	e9c8 ab00 	strd	sl, fp, [r8]
    z = 0.0;
 800c9ae:	4654      	mov	r4, sl
 800c9b0:	465d      	mov	r5, fp
    r = 0.0;
 800c9b2:	4656      	mov	r6, sl
 800c9b4:	465f      	mov	r7, fp
  *a = r;
 800c9b6:	9b04      	ldr	r3, [sp, #16]
 800c9b8:	e9c3 6700 	strd	r6, r7, [r3]
  *b = z;
 800c9bc:	e9c9 4500 	strd	r4, r5, [r9]
#define BASE double
#include "source_rotg.h"
#undef BASE
}
 800c9c0:	b009      	add	sp, #36	; 0x24
 800c9c2:	ecbd 8b02 	vpop	{d8}
 800c9c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
 800c9ca:	ed9d 7b00 	vldr	d7, [sp]
 800c9ce:	ed8d 7b06 	vstr	d7, [sp, #24]
 800c9d2:	e7d4      	b.n	800c97e <cblas_drotg+0x4e>
    const BASE aos = *a / scale;
 800c9d4:	e9dd 0100 	ldrd	r0, r1, [sp]
 800c9d8:	4622      	mov	r2, r4
 800c9da:	462b      	mov	r3, r5
 800c9dc:	f01b fb8e 	bl	80280fc <__aeabi_ddiv>
    const BASE bos = *b / scale;
 800c9e0:	4622      	mov	r2, r4
    const BASE aos = *a / scale;
 800c9e2:	ec41 0b18 	vmov	d8, r0, r1
    const BASE bos = *b / scale;
 800c9e6:	462b      	mov	r3, r5
 800c9e8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800c9ec:	f01b fb86 	bl	80280fc <__aeabi_ddiv>
    r = scale * sqrt(aos * aos + bos * bos);
 800c9f0:	ec53 2b18 	vmov	r2, r3, d8
    const BASE bos = *b / scale;
 800c9f4:	4606      	mov	r6, r0
 800c9f6:	460f      	mov	r7, r1
    r = scale * sqrt(aos * aos + bos * bos);
 800c9f8:	ee18 0a10 	vmov	r0, s16
 800c9fc:	4619      	mov	r1, r3
 800c9fe:	f01b fa53 	bl	8027ea8 <__aeabi_dmul>
 800ca02:	4632      	mov	r2, r6
 800ca04:	463b      	mov	r3, r7
 800ca06:	4606      	mov	r6, r0
 800ca08:	460f      	mov	r7, r1
 800ca0a:	4610      	mov	r0, r2
 800ca0c:	4619      	mov	r1, r3
 800ca0e:	f01b fa4b 	bl	8027ea8 <__aeabi_dmul>
 800ca12:	4602      	mov	r2, r0
 800ca14:	460b      	mov	r3, r1
 800ca16:	4630      	mov	r0, r6
 800ca18:	4639      	mov	r1, r7
 800ca1a:	f01b f88f 	bl	8027b3c <__adddf3>
 800ca1e:	ec41 0b10 	vmov	d0, r0, r1
 800ca22:	f023 fa39 	bl	802fe98 <sqrt>
 800ca26:	4622      	mov	r2, r4
 800ca28:	462b      	mov	r3, r5
 800ca2a:	ec51 0b10 	vmov	r0, r1, d0
 800ca2e:	f01b fa3b 	bl	8027ea8 <__aeabi_dmul>
    r = GSL_SIGN(roe) * r;
 800ca32:	4652      	mov	r2, sl
    r = scale * sqrt(aos * aos + bos * bos);
 800ca34:	4606      	mov	r6, r0
 800ca36:	460f      	mov	r7, r1
    r = GSL_SIGN(roe) * r;
 800ca38:	465b      	mov	r3, fp
 800ca3a:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800ca3e:	f01b fcb9 	bl	80283b4 <__aeabi_dcmpge>
 800ca42:	2800      	cmp	r0, #0
 800ca44:	d048      	beq.n	800cad8 <cblas_drotg+0x1a8>
    *c = *a / r;
 800ca46:	9904      	ldr	r1, [sp, #16]
 800ca48:	4632      	mov	r2, r6
 800ca4a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800ca4e:	463b      	mov	r3, r7
 800ca50:	f01b fb54 	bl	80280fc <__aeabi_ddiv>
 800ca54:	9a05      	ldr	r2, [sp, #20]
 800ca56:	e9c2 0100 	strd	r0, r1, [r2]
    *s = *b / r;
 800ca5a:	463b      	mov	r3, r7
 800ca5c:	e9d9 0100 	ldrd	r0, r1, [r9]
 800ca60:	4632      	mov	r2, r6
 800ca62:	f01b fb4b 	bl	80280fc <__aeabi_ddiv>
 800ca66:	4604      	mov	r4, r0
 800ca68:	460d      	mov	r5, r1
 800ca6a:	e9c8 4500 	strd	r4, r5, [r8]
    if (fabs(*a) > fabs(*b))
 800ca6e:	9b04      	ldr	r3, [sp, #16]
 800ca70:	685a      	ldr	r2, [r3, #4]
 800ca72:	f8d3 a000 	ldr.w	sl, [r3]
 800ca76:	f8d9 3000 	ldr.w	r3, [r9]
 800ca7a:	9300      	str	r3, [sp, #0]
 800ca7c:	f8d9 3004 	ldr.w	r3, [r9, #4]
 800ca80:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800ca84:	f022 4b00 	bic.w	fp, r2, #2147483648	; 0x80000000
 800ca88:	9301      	str	r3, [sp, #4]
 800ca8a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800ca8e:	4650      	mov	r0, sl
 800ca90:	4659      	mov	r1, fp
 800ca92:	f01b fc99 	bl	80283c8 <__aeabi_dcmpgt>
 800ca96:	b1e0      	cbz	r0, 800cad2 <cblas_drotg+0x1a2>
    if (fabs(*b) >= fabs(*a) && *c != 0.0)
 800ca98:	e9dd 2300 	ldrd	r2, r3, [sp]
 800ca9c:	4650      	mov	r0, sl
 800ca9e:	4659      	mov	r1, fp
 800caa0:	f01b fc7e 	bl	80283a0 <__aeabi_dcmple>
 800caa4:	2800      	cmp	r0, #0
 800caa6:	d086      	beq.n	800c9b6 <cblas_drotg+0x86>
 800caa8:	9b05      	ldr	r3, [sp, #20]
 800caaa:	e9d3 ab00 	ldrd	sl, fp, [r3]
 800caae:	2200      	movs	r2, #0
 800cab0:	2300      	movs	r3, #0
 800cab2:	4650      	mov	r0, sl
 800cab4:	4659      	mov	r1, fp
 800cab6:	f01b fc5f 	bl	8028378 <__aeabi_dcmpeq>
 800caba:	2800      	cmp	r0, #0
 800cabc:	f47f af7b 	bne.w	800c9b6 <cblas_drotg+0x86>
      z = 1.0 / (*c);
 800cac0:	4907      	ldr	r1, [pc, #28]	; (800cae0 <cblas_drotg+0x1b0>)
 800cac2:	4652      	mov	r2, sl
 800cac4:	465b      	mov	r3, fp
 800cac6:	2000      	movs	r0, #0
 800cac8:	f01b fb18 	bl	80280fc <__aeabi_ddiv>
 800cacc:	4604      	mov	r4, r0
 800cace:	460d      	mov	r5, r1
 800cad0:	e771      	b.n	800c9b6 <cblas_drotg+0x86>
    z = 1.0;
 800cad2:	4d03      	ldr	r5, [pc, #12]	; (800cae0 <cblas_drotg+0x1b0>)
 800cad4:	2400      	movs	r4, #0
 800cad6:	e7df      	b.n	800ca98 <cblas_drotg+0x168>
 800cad8:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 800cadc:	461f      	mov	r7, r3
 800cade:	e7b2      	b.n	800ca46 <cblas_drotg+0x116>
 800cae0:	3ff00000 	.word	0x3ff00000
 800cae4:	00000000 	.word	0x00000000

0800cae8 <cblas_drotm>:
#include "cblas.h"

void
cblas_drotm (const int N, double *X, const int incX, double *Y,
             const int incY, const double *P)
{
 800cae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800caec:	ed2d 8b0a 	vpush	{d8-d12}
 800caf0:	b083      	sub	sp, #12
  INDEX i = OFFSET(N, incX);
 800caf2:	1e14      	subs	r4, r2, #0
 800caf4:	e9dd 5716 	ldrd	r5, r7, [sp, #88]	; 0x58
 800caf8:	4698      	mov	r8, r3
 800cafa:	bfdc      	itt	le
 800cafc:	4603      	movle	r3, r0
 800cafe:	f1c3 0601 	rsble	r6, r3, #1
  if (P[0] == -1.0) {
 800cb02:	ed97 7b00 	vldr	d7, [r7]
 800cb06:	9000      	str	r0, [sp, #0]
  INDEX i = OFFSET(N, incX);
 800cb08:	bfd4      	ite	le
 800cb0a:	4366      	mulle	r6, r4
 800cb0c:	2600      	movgt	r6, #0
  INDEX j = OFFSET(N, incY);
 800cb0e:	2d00      	cmp	r5, #0
 800cb10:	bfd8      	it	le
 800cb12:	9b00      	ldrle	r3, [sp, #0]
  if (P[0] == -1.0) {
 800cb14:	eeb0 9a47 	vmov.f32	s18, s14
 800cb18:	eef0 9a67 	vmov.f32	s19, s15
  INDEX j = OFFSET(N, incY);
 800cb1c:	bfd8      	it	le
 800cb1e:	f1c3 0b01 	rsble	fp, r3, #1
 800cb22:	468a      	mov	sl, r1
  if (P[0] == -1.0) {
 800cb24:	4b60      	ldr	r3, [pc, #384]	; (800cca8 <cblas_drotm+0x1c0>)
 800cb26:	ec51 0b17 	vmov	r0, r1, d7
 800cb2a:	f04f 0200 	mov.w	r2, #0
  INDEX j = OFFSET(N, incY);
 800cb2e:	bfd4      	ite	le
 800cb30:	fb0b fb05 	mulle.w	fp, fp, r5
 800cb34:	f04f 0b00 	movgt.w	fp, #0
  if (P[0] == -1.0) {
 800cb38:	f01b fc1e 	bl	8028378 <__aeabi_dcmpeq>
 800cb3c:	2800      	cmp	r0, #0
 800cb3e:	d05f      	beq.n	800cc00 <cblas_drotm+0x118>
    h11 = P[1];
 800cb40:	ed97 7b02 	vldr	d7, [r7, #8]
 800cb44:	eeb0 aa47 	vmov.f32	s20, s14
 800cb48:	eef0 aa67 	vmov.f32	s21, s15
    h21 = P[2];
 800cb4c:	ed97 7b04 	vldr	d7, [r7, #16]
 800cb50:	eeb0 ba47 	vmov.f32	s22, s14
 800cb54:	eef0 ba67 	vmov.f32	s23, s15
    h12 = P[3];
 800cb58:	ed97 7b06 	vldr	d7, [r7, #24]
 800cb5c:	eeb0 9a47 	vmov.f32	s18, s14
 800cb60:	eef0 9a67 	vmov.f32	s19, s15
    h22 = P[4];
 800cb64:	ed97 7b08 	vldr	d7, [r7, #32]
 800cb68:	eeb0 ca47 	vmov.f32	s24, s14
 800cb6c:	eef0 ca67 	vmov.f32	s25, s15
  for (n = 0; n < N; n++) {
 800cb70:	9b00      	ldr	r3, [sp, #0]
 800cb72:	2b00      	cmp	r3, #0
 800cb74:	dd3f      	ble.n	800cbf6 <cblas_drotm+0x10e>
 800cb76:	00e3      	lsls	r3, r4, #3
 800cb78:	9301      	str	r3, [sp, #4]
 800cb7a:	2300      	movs	r3, #0
 800cb7c:	eb0a 0ac6 	add.w	sl, sl, r6, lsl #3
 800cb80:	00ef      	lsls	r7, r5, #3
 800cb82:	eb08 0bcb 	add.w	fp, r8, fp, lsl #3
 800cb86:	461e      	mov	r6, r3
    const BASE w = X[i];
 800cb88:	e9da 4500 	ldrd	r4, r5, [sl]
    X[i] = h11 * w + h12 * z;
 800cb8c:	ec51 0b1a 	vmov	r0, r1, d10
 800cb90:	4622      	mov	r2, r4
 800cb92:	462b      	mov	r3, r5
 800cb94:	f01b f988 	bl	8027ea8 <__aeabi_dmul>
    const BASE z = Y[j];
 800cb98:	e9db 8900 	ldrd	r8, r9, [fp]
    X[i] = h11 * w + h12 * z;
 800cb9c:	ec41 0b18 	vmov	d8, r0, r1
 800cba0:	4642      	mov	r2, r8
 800cba2:	464b      	mov	r3, r9
 800cba4:	ec51 0b19 	vmov	r0, r1, d9
 800cba8:	f01b f97e 	bl	8027ea8 <__aeabi_dmul>
 800cbac:	4602      	mov	r2, r0
 800cbae:	460b      	mov	r3, r1
 800cbb0:	ec51 0b18 	vmov	r0, r1, d8
 800cbb4:	f01a ffc2 	bl	8027b3c <__adddf3>
    Y[j] = h21 * w + h22 * z;
 800cbb8:	4622      	mov	r2, r4
    X[i] = h11 * w + h12 * z;
 800cbba:	e9ca 0100 	strd	r0, r1, [sl]
    Y[j] = h21 * w + h22 * z;
 800cbbe:	462b      	mov	r3, r5
 800cbc0:	ec51 0b1b 	vmov	r0, r1, d11
 800cbc4:	f01b f970 	bl	8027ea8 <__aeabi_dmul>
 800cbc8:	4642      	mov	r2, r8
 800cbca:	464b      	mov	r3, r9
 800cbcc:	4604      	mov	r4, r0
 800cbce:	460d      	mov	r5, r1
 800cbd0:	ec51 0b1c 	vmov	r0, r1, d12
 800cbd4:	f01b f968 	bl	8027ea8 <__aeabi_dmul>
 800cbd8:	460b      	mov	r3, r1
 800cbda:	4602      	mov	r2, r0
 800cbdc:	4629      	mov	r1, r5
 800cbde:	4620      	mov	r0, r4
 800cbe0:	f01a ffac 	bl	8027b3c <__adddf3>
 800cbe4:	9b01      	ldr	r3, [sp, #4]
 800cbe6:	449a      	add	sl, r3
  for (n = 0; n < N; n++) {
 800cbe8:	9b00      	ldr	r3, [sp, #0]
 800cbea:	3601      	adds	r6, #1
 800cbec:	42b3      	cmp	r3, r6
    Y[j] = h21 * w + h22 * z;
 800cbee:	e9cb 0100 	strd	r0, r1, [fp]
  for (n = 0; n < N; n++) {
 800cbf2:	44bb      	add	fp, r7
 800cbf4:	d1c8      	bne.n	800cb88 <cblas_drotm+0xa0>
#define BASE double
#include "source_rotm.h"
#undef BASE
}
 800cbf6:	b003      	add	sp, #12
 800cbf8:	ecbd 8b0a 	vpop	{d8-d12}
 800cbfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (P[0] == 0.0) {
 800cc00:	ec51 0b19 	vmov	r0, r1, d9
 800cc04:	2200      	movs	r2, #0
 800cc06:	2300      	movs	r3, #0
 800cc08:	f01b fbb6 	bl	8028378 <__aeabi_dcmpeq>
 800cc0c:	b1b0      	cbz	r0, 800cc3c <cblas_drotm+0x154>
    h22 = 1.0;
 800cc0e:	ed9f 7b22 	vldr	d7, [pc, #136]	; 800cc98 <cblas_drotm+0x1b0>
    h21 = P[2];
 800cc12:	ed97 6b04 	vldr	d6, [r7, #16]
    h22 = 1.0;
 800cc16:	eeb0 ca47 	vmov.f32	s24, s14
 800cc1a:	eef0 ca67 	vmov.f32	s25, s15
    h11 = 1.0;
 800cc1e:	eeb0 aa47 	vmov.f32	s20, s14
 800cc22:	eef0 aa67 	vmov.f32	s21, s15
    h12 = P[3];
 800cc26:	ed97 7b06 	vldr	d7, [r7, #24]
    h21 = P[2];
 800cc2a:	eeb0 ba46 	vmov.f32	s22, s12
 800cc2e:	eef0 ba66 	vmov.f32	s23, s13
    h12 = P[3];
 800cc32:	eeb0 9a47 	vmov.f32	s18, s14
 800cc36:	eef0 9a67 	vmov.f32	s19, s15
    h22 = 1.0;
 800cc3a:	e799      	b.n	800cb70 <cblas_drotm+0x88>
  } else if (P[0] == 1.0) {
 800cc3c:	4b1b      	ldr	r3, [pc, #108]	; (800ccac <cblas_drotm+0x1c4>)
 800cc3e:	ec51 0b19 	vmov	r0, r1, d9
 800cc42:	2200      	movs	r2, #0
 800cc44:	f01b fb98 	bl	8028378 <__aeabi_dcmpeq>
 800cc48:	b190      	cbz	r0, 800cc70 <cblas_drotm+0x188>
    h11 = P[1];
 800cc4a:	ed97 7b02 	vldr	d7, [r7, #8]
 800cc4e:	eeb0 aa47 	vmov.f32	s20, s14
 800cc52:	eef0 aa67 	vmov.f32	s21, s15
    h22 = P[4];
 800cc56:	ed97 7b08 	vldr	d7, [r7, #32]
 800cc5a:	eeb0 ca47 	vmov.f32	s24, s14
 800cc5e:	eef0 ca67 	vmov.f32	s25, s15
    h21 = -1.0;
 800cc62:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 800cca0 <cblas_drotm+0x1b8>
 800cc66:	eeb0 ba47 	vmov.f32	s22, s14
 800cc6a:	eef0 ba67 	vmov.f32	s23, s15
 800cc6e:	e77f      	b.n	800cb70 <cblas_drotm+0x88>
  } else if (P[0] == -2.0) {
 800cc70:	ec51 0b19 	vmov	r0, r1, d9
 800cc74:	2200      	movs	r2, #0
 800cc76:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 800cc7a:	f01b fb7d 	bl	8028378 <__aeabi_dcmpeq>
 800cc7e:	2800      	cmp	r0, #0
 800cc80:	d1b9      	bne.n	800cbf6 <cblas_drotm+0x10e>
    BLAS_ERROR("unrecognized value of P[0]");
 800cc82:	4a0b      	ldr	r2, [pc, #44]	; (800ccb0 <cblas_drotm+0x1c8>)
 800cc84:	490b      	ldr	r1, [pc, #44]	; (800ccb4 <cblas_drotm+0x1cc>)
 800cc86:	b003      	add	sp, #12
 800cc88:	ecbd 8b0a 	vpop	{d8-d12}
 800cc8c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cc90:	f01a beda 	b.w	8027a48 <cblas_xerbla>
 800cc94:	f3af 8000 	nop.w
 800cc98:	00000000 	.word	0x00000000
 800cc9c:	3ff00000 	.word	0x3ff00000
 800cca0:	00000000 	.word	0x00000000
 800cca4:	bff00000 	.word	0xbff00000
 800cca8:	bff00000 	.word	0xbff00000
 800ccac:	3ff00000 	.word	0x3ff00000
 800ccb0:	080305e0 	.word	0x080305e0
 800ccb4:	080305fc 	.word	0x080305fc

0800ccb8 <cblas_drotmg>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_drotmg (double *d1, double *d2, double *b1, const double b2, double *P)
{
 800ccb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ccbc:	ed2d 8b06 	vpush	{d8-d10}
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800ccc0:	e9d0 ab00 	ldrd	sl, fp, [r0]
 800ccc4:	b093      	sub	sp, #76	; 0x4c
  if (D1 < 0.0) {
 800ccc6:	2400      	movs	r4, #0
 800ccc8:	2500      	movs	r5, #0
 800ccca:	468c      	mov	ip, r1
 800cccc:	4617      	mov	r7, r2
 800ccce:	461e      	mov	r6, r3
 800ccd0:	900f      	str	r0, [sp, #60]	; 0x3c
 800ccd2:	4659      	mov	r1, fp
 800ccd4:	4650      	mov	r0, sl
 800ccd6:	4622      	mov	r2, r4
 800ccd8:	462b      	mov	r3, r5
 800ccda:	e9cd c70d 	strd	ip, r7, [sp, #52]	; 0x34
 800ccde:	ed8d 0b00 	vstr	d0, [sp]
 800cce2:	960c      	str	r6, [sp, #48]	; 0x30
 800cce4:	f01b fb52 	bl	802838c <__aeabi_dcmplt>
 800cce8:	2800      	cmp	r0, #0
 800ccea:	f040 809f 	bne.w	800ce2c <cblas_drotmg+0x174>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800ccee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ccf0:	ed93 7b00 	vldr	d7, [r3]
  if (D2 * y == 0.0) {
 800ccf4:	e9dd 2300 	ldrd	r2, r3, [sp]
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800ccf8:	eeb0 aa47 	vmov.f32	s20, s14
 800ccfc:	eef0 aa67 	vmov.f32	s21, s15
  if (D2 * y == 0.0) {
 800cd00:	ec51 0b17 	vmov	r0, r1, d7
 800cd04:	f01b f8d0 	bl	8027ea8 <__aeabi_dmul>
 800cd08:	4622      	mov	r2, r4
 800cd0a:	462b      	mov	r3, r5
 800cd0c:	4606      	mov	r6, r0
 800cd0e:	460f      	mov	r7, r1
 800cd10:	f01b fb32 	bl	8028378 <__aeabi_dcmpeq>
 800cd14:	2800      	cmp	r0, #0
 800cd16:	d177      	bne.n	800ce08 <cblas_drotmg+0x150>
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800cd18:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cd1a:	ed93 7b00 	vldr	d7, [r3]
  c = fabs(D1 * x * x);
 800cd1e:	4650      	mov	r0, sl
 800cd20:	ec53 2b17 	vmov	r2, r3, d7
  BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
 800cd24:	eeb0 8a47 	vmov.f32	s16, s14
 800cd28:	eef0 8a67 	vmov.f32	s17, s15
  c = fabs(D1 * x * x);
 800cd2c:	4659      	mov	r1, fp
 800cd2e:	f01b f8bb 	bl	8027ea8 <__aeabi_dmul>
  s = fabs(D2 * y * y);
 800cd32:	e9dd 2300 	ldrd	r2, r3, [sp]
  c = fabs(D1 * x * x);
 800cd36:	ec41 0b19 	vmov	d9, r0, r1
  s = fabs(D2 * y * y);
 800cd3a:	4630      	mov	r0, r6
 800cd3c:	4639      	mov	r1, r7
 800cd3e:	f01b f8b3 	bl	8027ea8 <__aeabi_dmul>
  c = fabs(D1 * x * x);
 800cd42:	ec53 2b18 	vmov	r2, r3, d8
  s = fabs(D2 * y * y);
 800cd46:	4680      	mov	r8, r0
 800cd48:	4689      	mov	r9, r1
  c = fabs(D1 * x * x);
 800cd4a:	ec51 0b19 	vmov	r0, r1, d9
  s = fabs(D2 * y * y);
 800cd4e:	e9cd 8902 	strd	r8, r9, [sp, #8]
  c = fabs(D1 * x * x);
 800cd52:	f01b f8a9 	bl	8027ea8 <__aeabi_dmul>
 800cd56:	f021 4900 	bic.w	r9, r1, #2147483648	; 0x80000000
  s = fabs(D2 * y * y);
 800cd5a:	9903      	ldr	r1, [sp, #12]
 800cd5c:	9a02      	ldr	r2, [sp, #8]
  c = fabs(D1 * x * x);
 800cd5e:	4680      	mov	r8, r0
  s = fabs(D2 * y * y);
 800cd60:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
  if (c > s) {
 800cd64:	4640      	mov	r0, r8
 800cd66:	4649      	mov	r1, r9
 800cd68:	f01b fb2e 	bl	80283c8 <__aeabi_dcmpgt>
 800cd6c:	2800      	cmp	r0, #0
 800cd6e:	d056      	beq.n	800ce1e <cblas_drotmg+0x166>
    P[0] = 0.0;
 800cd70:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    h12 = (D2 * y) / (D1 * x);
 800cd72:	4630      	mov	r0, r6
    P[0] = 0.0;
 800cd74:	e9c3 4500 	strd	r4, r5, [r3]
    h12 = (D2 * y) / (D1 * x);
 800cd78:	4639      	mov	r1, r7
 800cd7a:	ec53 2b19 	vmov	r2, r3, d9
 800cd7e:	f01b f9bd 	bl	80280fc <__aeabi_ddiv>
    h21 = -y / x;
 800cd82:	e9dd 2300 	ldrd	r2, r3, [sp]
    h12 = (D2 * y) / (D1 * x);
 800cd86:	4680      	mov	r8, r0
 800cd88:	4689      	mov	r9, r1
    h21 = -y / x;
 800cd8a:	4610      	mov	r0, r2
 800cd8c:	f103 4100 	add.w	r1, r3, #2147483648	; 0x80000000
 800cd90:	ec53 2b18 	vmov	r2, r3, d8
    h12 = (D2 * y) / (D1 * x);
 800cd94:	e9cd 8904 	strd	r8, r9, [sp, #16]
    h21 = -y / x;
 800cd98:	f01b f9b0 	bl	80280fc <__aeabi_ddiv>
 800cd9c:	4602      	mov	r2, r0
 800cd9e:	460b      	mov	r3, r1
    u = 1 - h21 * h12;
 800cda0:	4640      	mov	r0, r8
 800cda2:	4649      	mov	r1, r9
    h21 = -y / x;
 800cda4:	e9cd 2302 	strd	r2, r3, [sp, #8]
    u = 1 - h21 * h12;
 800cda8:	f01b f87e 	bl	8027ea8 <__aeabi_dmul>
 800cdac:	4602      	mov	r2, r0
 800cdae:	460b      	mov	r3, r1
 800cdb0:	2000      	movs	r0, #0
 800cdb2:	49a1      	ldr	r1, [pc, #644]	; (800d038 <cblas_drotmg+0x380>)
 800cdb4:	f01a fec0 	bl	8027b38 <__aeabi_dsub>
    if (u <= 0.0) {             /* the case u <= 0 is rejected */
 800cdb8:	4622      	mov	r2, r4
 800cdba:	462b      	mov	r3, r5
    u = 1 - h21 * h12;
 800cdbc:	4606      	mov	r6, r0
 800cdbe:	460f      	mov	r7, r1
    if (u <= 0.0) {             /* the case u <= 0 is rejected */
 800cdc0:	f01b faee 	bl	80283a0 <__aeabi_dcmple>
 800cdc4:	bb90      	cbnz	r0, 800ce2c <cblas_drotmg+0x174>
    D1 /= u;
 800cdc6:	4650      	mov	r0, sl
 800cdc8:	4659      	mov	r1, fp
 800cdca:	4632      	mov	r2, r6
 800cdcc:	463b      	mov	r3, r7
 800cdce:	f01b f995 	bl	80280fc <__aeabi_ddiv>
    D2 /= u;
 800cdd2:	4632      	mov	r2, r6
 800cdd4:	463b      	mov	r3, r7
    D1 /= u;
 800cdd6:	4604      	mov	r4, r0
 800cdd8:	460d      	mov	r5, r1
    D2 /= u;
 800cdda:	ec51 0b1a 	vmov	r0, r1, d10
 800cdde:	f01b f98d 	bl	80280fc <__aeabi_ddiv>
    h22 = 1;
 800cde2:	ed9f 7b91 	vldr	d7, [pc, #580]	; 800d028 <cblas_drotmg+0x370>
    D2 /= u;
 800cde6:	4682      	mov	sl, r0
 800cde8:	468b      	mov	fp, r1
    x *= u;
 800cdea:	4632      	mov	r2, r6
 800cdec:	ec51 0b18 	vmov	r0, r1, d8
 800cdf0:	463b      	mov	r3, r7
    h22 = 1;
 800cdf2:	ed8d 7b06 	vstr	d7, [sp, #24]
    x *= u;
 800cdf6:	f01b f857 	bl	8027ea8 <__aeabi_dmul>
    h11 = 1;
 800cdfa:	ed9f 7b8b 	vldr	d7, [pc, #556]	; 800d028 <cblas_drotmg+0x370>
    x *= u;
 800cdfe:	e9cd 0100 	strd	r0, r1, [sp]
    h11 = 1;
 800ce02:	ed8d 7b08 	vstr	d7, [sp, #32]
 800ce06:	e073      	b.n	800cef0 <cblas_drotmg+0x238>
    P[0] = -2;                  /* case of H = I, page 315 */
 800ce08:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ce0a:	2200      	movs	r2, #0
 800ce0c:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 800ce10:	e9c1 2300 	strd	r2, r3, [r1]
#define BASE double
#include "source_rotmg.h"
#undef BASE
}
 800ce14:	b013      	add	sp, #76	; 0x4c
 800ce16:	ecbd 8b06 	vpop	{d8-d10}
 800ce1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (D2 * y * y < 0.0) {
 800ce1e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800ce22:	4622      	mov	r2, r4
 800ce24:	462b      	mov	r3, r5
 800ce26:	f01b fab1 	bl	802838c <__aeabi_dcmplt>
 800ce2a:	b1e0      	cbz	r0, 800ce66 <cblas_drotmg+0x1ae>
    P[0] = -1;
 800ce2c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800ce2e:	4983      	ldr	r1, [pc, #524]	; (800d03c <cblas_drotmg+0x384>)
 800ce30:	2000      	movs	r0, #0
 800ce32:	e9c4 0100 	strd	r0, r1, [r4]
    *d1 = 0;
 800ce36:	990f      	ldr	r1, [sp, #60]	; 0x3c
    P[1] = 0;
 800ce38:	2200      	movs	r2, #0
 800ce3a:	2300      	movs	r3, #0
 800ce3c:	e9c4 2302 	strd	r2, r3, [r4, #8]
    P[2] = 0;
 800ce40:	e9c4 2304 	strd	r2, r3, [r4, #16]
    P[3] = 0;
 800ce44:	e9c4 2306 	strd	r2, r3, [r4, #24]
    P[4] = 0;
 800ce48:	e9c4 2308 	strd	r2, r3, [r4, #32]
    *d1 = 0;
 800ce4c:	e9c1 2300 	strd	r2, r3, [r1]
    *d2 = 0;
 800ce50:	990d      	ldr	r1, [sp, #52]	; 0x34
 800ce52:	e9c1 2300 	strd	r2, r3, [r1]
    *b1 = 0;
 800ce56:	990e      	ldr	r1, [sp, #56]	; 0x38
 800ce58:	e9c1 2300 	strd	r2, r3, [r1]
 800ce5c:	b013      	add	sp, #76	; 0x4c
 800ce5e:	ecbd 8b06 	vpop	{d8-d10}
 800ce62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    P[0] = 1;
 800ce66:	ed9f 7b70 	vldr	d7, [pc, #448]	; 800d028 <cblas_drotmg+0x370>
 800ce6a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    h11 = (D1 * x) / (D2 * y);
 800ce6c:	4632      	mov	r2, r6
    P[0] = 1;
 800ce6e:	ed84 7b00 	vstr	d7, [r4]
    h11 = (D1 * x) / (D2 * y);
 800ce72:	463b      	mov	r3, r7
 800ce74:	ec51 0b19 	vmov	r0, r1, d9
 800ce78:	f01b f940 	bl	80280fc <__aeabi_ddiv>
    h22 = x / y;
 800ce7c:	e9dd 2300 	ldrd	r2, r3, [sp]
    h11 = (D1 * x) / (D2 * y);
 800ce80:	4680      	mov	r8, r0
 800ce82:	4689      	mov	r9, r1
    h22 = x / y;
 800ce84:	ec51 0b18 	vmov	r0, r1, d8
    h11 = (D1 * x) / (D2 * y);
 800ce88:	e9cd 8908 	strd	r8, r9, [sp, #32]
    h22 = x / y;
 800ce8c:	f01b f936 	bl	80280fc <__aeabi_ddiv>
 800ce90:	4602      	mov	r2, r0
 800ce92:	460b      	mov	r3, r1
    u = 1 + h11 * h22;
 800ce94:	4640      	mov	r0, r8
 800ce96:	4649      	mov	r1, r9
    h22 = x / y;
 800ce98:	e9cd 2306 	strd	r2, r3, [sp, #24]
    u = 1 + h11 * h22;
 800ce9c:	f01b f804 	bl	8027ea8 <__aeabi_dmul>
 800cea0:	4b65      	ldr	r3, [pc, #404]	; (800d038 <cblas_drotmg+0x380>)
 800cea2:	2200      	movs	r2, #0
 800cea4:	f01a fe4a 	bl	8027b3c <__adddf3>
 800cea8:	4606      	mov	r6, r0
 800ceaa:	460f      	mov	r7, r1
    D1 /= u;
 800ceac:	4650      	mov	r0, sl
 800ceae:	4659      	mov	r1, fp
 800ceb0:	4632      	mov	r2, r6
 800ceb2:	463b      	mov	r3, r7
 800ceb4:	f01b f922 	bl	80280fc <__aeabi_ddiv>
    D2 /= u;
 800ceb8:	4632      	mov	r2, r6
    D1 /= u;
 800ceba:	4604      	mov	r4, r0
 800cebc:	460d      	mov	r5, r1
    D2 /= u;
 800cebe:	463b      	mov	r3, r7
 800cec0:	ec51 0b1a 	vmov	r0, r1, d10
 800cec4:	f01b f91a 	bl	80280fc <__aeabi_ddiv>
    D1 /= u;
 800cec8:	46a2      	mov	sl, r4
 800ceca:	46ab      	mov	fp, r5
    D2 /= u;
 800cecc:	4604      	mov	r4, r0
 800cece:	460d      	mov	r5, r1
    x = y * u;
 800ced0:	4632      	mov	r2, r6
 800ced2:	e9dd 0100 	ldrd	r0, r1, [sp]
 800ced6:	463b      	mov	r3, r7
 800ced8:	f01a ffe6 	bl	8027ea8 <__aeabi_dmul>
    h12 = 1;
 800cedc:	ed9f 7b52 	vldr	d7, [pc, #328]	; 800d028 <cblas_drotmg+0x370>
 800cee0:	ed8d 7b04 	vstr	d7, [sp, #16]
    h21 = -1;
 800cee4:	ed9f 7b52 	vldr	d7, [pc, #328]	; 800d030 <cblas_drotmg+0x378>
    x = y * u;
 800cee8:	e9cd 0100 	strd	r0, r1, [sp]
    h21 = -1;
 800ceec:	ed8d 7b02 	vstr	d7, [sp, #8]
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800cef0:	4b53      	ldr	r3, [pc, #332]	; (800d040 <cblas_drotmg+0x388>)
 800cef2:	2200      	movs	r2, #0
 800cef4:	4620      	mov	r0, r4
 800cef6:	4629      	mov	r1, r5
 800cef8:	f01b fa52 	bl	80283a0 <__aeabi_dcmple>
 800cefc:	2800      	cmp	r0, #0
 800cefe:	d043      	beq.n	800cf88 <cblas_drotmg+0x2d0>
 800cf00:	e9cd ab10 	strd	sl, fp, [sp, #64]	; 0x40
    P[0] = -1;
 800cf04:	ed9f 8b4a 	vldr	d8, [pc, #296]	; 800d030 <cblas_drotmg+0x378>
    x /= G;
 800cf08:	4f4e      	ldr	r7, [pc, #312]	; (800d044 <cblas_drotmg+0x38c>)
 800cf0a:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 800cf0e:	2600      	movs	r6, #0
 800cf10:	e02a      	b.n	800cf68 <cblas_drotmg+0x2b0>
    P[0] = -1;
 800cf12:	ed8b 8b00 	vstr	d8, [fp]
    D1 *= G2;
 800cf16:	f01a ffc7 	bl	8027ea8 <__aeabi_dmul>
    x /= G;
 800cf1a:	4632      	mov	r2, r6
    D1 *= G2;
 800cf1c:	4604      	mov	r4, r0
 800cf1e:	460d      	mov	r5, r1
    x /= G;
 800cf20:	463b      	mov	r3, r7
 800cf22:	e9dd 0100 	ldrd	r0, r1, [sp]
 800cf26:	f01a ffbf 	bl	8027ea8 <__aeabi_dmul>
    h11 /= G;
 800cf2a:	4632      	mov	r2, r6
    x /= G;
 800cf2c:	4680      	mov	r8, r0
 800cf2e:	4689      	mov	r9, r1
    h11 /= G;
 800cf30:	463b      	mov	r3, r7
 800cf32:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    x /= G;
 800cf36:	e9cd 8900 	strd	r8, r9, [sp]
    h11 /= G;
 800cf3a:	f01a ffb5 	bl	8027ea8 <__aeabi_dmul>
    h12 /= G;
 800cf3e:	4632      	mov	r2, r6
    h11 /= G;
 800cf40:	4680      	mov	r8, r0
 800cf42:	4689      	mov	r9, r1
    h12 /= G;
 800cf44:	463b      	mov	r3, r7
 800cf46:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    h11 /= G;
 800cf4a:	e9cd 8908 	strd	r8, r9, [sp, #32]
    h12 /= G;
 800cf4e:	f01a ffab 	bl	8027ea8 <__aeabi_dmul>
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800cf52:	4b3b      	ldr	r3, [pc, #236]	; (800d040 <cblas_drotmg+0x388>)
    h12 /= G;
 800cf54:	4680      	mov	r8, r0
 800cf56:	4689      	mov	r9, r1
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800cf58:	2200      	movs	r2, #0
 800cf5a:	4620      	mov	r0, r4
 800cf5c:	4629      	mov	r1, r5
    h12 /= G;
 800cf5e:	e9cd 8904 	strd	r8, r9, [sp, #16]
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800cf62:	f01b fa1d 	bl	80283a0 <__aeabi_dcmple>
 800cf66:	b168      	cbz	r0, 800cf84 <cblas_drotmg+0x2cc>
 800cf68:	2200      	movs	r2, #0
 800cf6a:	2300      	movs	r3, #0
 800cf6c:	4629      	mov	r1, r5
 800cf6e:	4620      	mov	r0, r4
 800cf70:	f01b fa02 	bl	8028378 <__aeabi_dcmpeq>
 800cf74:	4684      	mov	ip, r0
    D1 *= G2;
 800cf76:	4b34      	ldr	r3, [pc, #208]	; (800d048 <cblas_drotmg+0x390>)
 800cf78:	2200      	movs	r2, #0
 800cf7a:	4620      	mov	r0, r4
 800cf7c:	4629      	mov	r1, r5
  while (D1 <= 1.0 / G2 && D1 != 0.0) {
 800cf7e:	f1bc 0f00 	cmp.w	ip, #0
 800cf82:	d0c6      	beq.n	800cf12 <cblas_drotmg+0x25a>
 800cf84:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
  while (D1 >= G2) {
 800cf88:	4b2f      	ldr	r3, [pc, #188]	; (800d048 <cblas_drotmg+0x390>)
 800cf8a:	2200      	movs	r2, #0
 800cf8c:	4620      	mov	r0, r4
 800cf8e:	4629      	mov	r1, r5
 800cf90:	f01b fa10 	bl	80283b4 <__aeabi_dcmpge>
 800cf94:	2800      	cmp	r0, #0
 800cf96:	d034      	beq.n	800d002 <cblas_drotmg+0x34a>
    x *= G;
 800cf98:	4f2c      	ldr	r7, [pc, #176]	; (800d04c <cblas_drotmg+0x394>)
 800cf9a:	2600      	movs	r6, #0
    D1 /= G2;
 800cf9c:	4b28      	ldr	r3, [pc, #160]	; (800d040 <cblas_drotmg+0x388>)
 800cf9e:	4620      	mov	r0, r4
 800cfa0:	4629      	mov	r1, r5
 800cfa2:	2200      	movs	r2, #0
 800cfa4:	f01a ff80 	bl	8027ea8 <__aeabi_dmul>
    x *= G;
 800cfa8:	4632      	mov	r2, r6
    D1 /= G2;
 800cfaa:	4604      	mov	r4, r0
 800cfac:	460d      	mov	r5, r1
    x *= G;
 800cfae:	463b      	mov	r3, r7
 800cfb0:	e9dd 0100 	ldrd	r0, r1, [sp]
 800cfb4:	f01a ff78 	bl	8027ea8 <__aeabi_dmul>
    h11 *= G;
 800cfb8:	4632      	mov	r2, r6
    x *= G;
 800cfba:	4680      	mov	r8, r0
 800cfbc:	4689      	mov	r9, r1
    h11 *= G;
 800cfbe:	463b      	mov	r3, r7
 800cfc0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    x *= G;
 800cfc4:	e9cd 8900 	strd	r8, r9, [sp]
    h11 *= G;
 800cfc8:	f01a ff6e 	bl	8027ea8 <__aeabi_dmul>
    h12 *= G;
 800cfcc:	4632      	mov	r2, r6
    h11 *= G;
 800cfce:	4680      	mov	r8, r0
 800cfd0:	4689      	mov	r9, r1
    h12 *= G;
 800cfd2:	463b      	mov	r3, r7
 800cfd4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    h11 *= G;
 800cfd8:	e9cd 8908 	strd	r8, r9, [sp, #32]
    h12 *= G;
 800cfdc:	f01a ff64 	bl	8027ea8 <__aeabi_dmul>
  while (D1 >= G2) {
 800cfe0:	4b19      	ldr	r3, [pc, #100]	; (800d048 <cblas_drotmg+0x390>)
    h12 *= G;
 800cfe2:	4680      	mov	r8, r0
 800cfe4:	4689      	mov	r9, r1
  while (D1 >= G2) {
 800cfe6:	2200      	movs	r2, #0
 800cfe8:	4620      	mov	r0, r4
 800cfea:	4629      	mov	r1, r5
    h12 *= G;
 800cfec:	e9cd 8904 	strd	r8, r9, [sp, #16]
  while (D1 >= G2) {
 800cff0:	f01b f9e0 	bl	80283b4 <__aeabi_dcmpge>
 800cff4:	2800      	cmp	r0, #0
 800cff6:	d1d1      	bne.n	800cf9c <cblas_drotmg+0x2e4>
 800cff8:	4b10      	ldr	r3, [pc, #64]	; (800d03c <cblas_drotmg+0x384>)
 800cffa:	990c      	ldr	r1, [sp, #48]	; 0x30
 800cffc:	2200      	movs	r2, #0
 800cffe:	e9c1 2300 	strd	r2, r3, [r1]
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800d002:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
 800d006:	4b0e      	ldr	r3, [pc, #56]	; (800d040 <cblas_drotmg+0x388>)
 800d008:	4650      	mov	r0, sl
 800d00a:	4639      	mov	r1, r7
 800d00c:	2200      	movs	r2, #0
 800d00e:	4656      	mov	r6, sl
 800d010:	f01b f9c6 	bl	80283a0 <__aeabi_dcmple>
 800d014:	2800      	cmp	r0, #0
 800d016:	d054      	beq.n	800d0c2 <cblas_drotmg+0x40a>
 800d018:	ec45 4b19 	vmov	d9, r4, r5
    P[0] = -1;
 800d01c:	ed9f 8b04 	vldr	d8, [pc, #16]	; 800d030 <cblas_drotmg+0x378>
 800d020:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800d022:	e03b      	b.n	800d09c <cblas_drotmg+0x3e4>
 800d024:	f3af 8000 	nop.w
 800d028:	00000000 	.word	0x00000000
 800d02c:	3ff00000 	.word	0x3ff00000
 800d030:	00000000 	.word	0x00000000
 800d034:	bff00000 	.word	0xbff00000
 800d038:	3ff00000 	.word	0x3ff00000
 800d03c:	bff00000 	.word	0xbff00000
 800d040:	3e700000 	.word	0x3e700000
 800d044:	3f300000 	.word	0x3f300000
 800d048:	41700000 	.word	0x41700000
 800d04c:	40b00000 	.word	0x40b00000
 800d050:	ed85 8b00 	vstr	d8, [r5]
    D2 *= G2;
 800d054:	f01a ff28 	bl	8027ea8 <__aeabi_dmul>
    h21 /= G;
 800d058:	4b60      	ldr	r3, [pc, #384]	; (800d1dc <cblas_drotmg+0x524>)
    D2 *= G2;
 800d05a:	4682      	mov	sl, r0
    h21 /= G;
 800d05c:	2200      	movs	r2, #0
    D2 *= G2;
 800d05e:	468b      	mov	fp, r1
    h21 /= G;
 800d060:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800d064:	f01a ff20 	bl	8027ea8 <__aeabi_dmul>
    h22 /= G;
 800d068:	4b5c      	ldr	r3, [pc, #368]	; (800d1dc <cblas_drotmg+0x524>)
    h21 /= G;
 800d06a:	4680      	mov	r8, r0
 800d06c:	4689      	mov	r9, r1
    h22 /= G;
 800d06e:	2200      	movs	r2, #0
 800d070:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    h21 /= G;
 800d074:	e9cd 8902 	strd	r8, r9, [sp, #8]
    h22 /= G;
 800d078:	f01a ff16 	bl	8027ea8 <__aeabi_dmul>
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800d07c:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
    h22 /= G;
 800d080:	4680      	mov	r8, r0
 800d082:	4689      	mov	r9, r1
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800d084:	4b56      	ldr	r3, [pc, #344]	; (800d1e0 <cblas_drotmg+0x528>)
 800d086:	2200      	movs	r2, #0
 800d088:	4650      	mov	r0, sl
 800d08a:	4639      	mov	r1, r7
    h22 /= G;
 800d08c:	e9cd 8906 	strd	r8, r9, [sp, #24]
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800d090:	4656      	mov	r6, sl
 800d092:	f01b f985 	bl	80283a0 <__aeabi_dcmple>
 800d096:	2800      	cmp	r0, #0
 800d098:	f000 808a 	beq.w	800d1b0 <cblas_drotmg+0x4f8>
 800d09c:	2200      	movs	r2, #0
 800d09e:	2300      	movs	r3, #0
 800d0a0:	4659      	mov	r1, fp
 800d0a2:	4650      	mov	r0, sl
 800d0a4:	f01b f968 	bl	8028378 <__aeabi_dcmpeq>
 800d0a8:	4684      	mov	ip, r0
    D2 *= G2;
 800d0aa:	4b4e      	ldr	r3, [pc, #312]	; (800d1e4 <cblas_drotmg+0x52c>)
 800d0ac:	2200      	movs	r2, #0
 800d0ae:	4650      	mov	r0, sl
 800d0b0:	4659      	mov	r1, fp
  while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
 800d0b2:	f1bc 0f00 	cmp.w	ip, #0
 800d0b6:	d0cb      	beq.n	800d050 <cblas_drotmg+0x398>
 800d0b8:	ec55 4b19 	vmov	r4, r5, d9
 800d0bc:	4656      	mov	r6, sl
 800d0be:	f02b 4700 	bic.w	r7, fp, #2147483648	; 0x80000000
  while (fabs(D2) >= G2) {
 800d0c2:	4b48      	ldr	r3, [pc, #288]	; (800d1e4 <cblas_drotmg+0x52c>)
 800d0c4:	4630      	mov	r0, r6
 800d0c6:	4639      	mov	r1, r7
 800d0c8:	2200      	movs	r2, #0
 800d0ca:	f01b f973 	bl	80283b4 <__aeabi_dcmpge>
 800d0ce:	2800      	cmp	r0, #0
 800d0d0:	d033      	beq.n	800d13a <cblas_drotmg+0x482>
    h21 *= G;
 800d0d2:	4f45      	ldr	r7, [pc, #276]	; (800d1e8 <cblas_drotmg+0x530>)
 800d0d4:	ec45 4b18 	vmov	d8, r4, r5
 800d0d8:	2600      	movs	r6, #0
    D2 /= G2;
 800d0da:	4b41      	ldr	r3, [pc, #260]	; (800d1e0 <cblas_drotmg+0x528>)
 800d0dc:	4650      	mov	r0, sl
 800d0de:	4659      	mov	r1, fp
 800d0e0:	2200      	movs	r2, #0
 800d0e2:	f01a fee1 	bl	8027ea8 <__aeabi_dmul>
    h21 *= G;
 800d0e6:	4632      	mov	r2, r6
 800d0e8:	463b      	mov	r3, r7
    D2 /= G2;
 800d0ea:	4682      	mov	sl, r0
 800d0ec:	468b      	mov	fp, r1
    h21 *= G;
 800d0ee:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800d0f2:	f01a fed9 	bl	8027ea8 <__aeabi_dmul>
  while (fabs(D2) >= G2) {
 800d0f6:	f02b 4400 	bic.w	r4, fp, #2147483648	; 0x80000000
    h21 *= G;
 800d0fa:	4680      	mov	r8, r0
 800d0fc:	4689      	mov	r9, r1
    h22 *= G;
 800d0fe:	4632      	mov	r2, r6
 800d100:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 800d104:	463b      	mov	r3, r7
    h21 *= G;
 800d106:	e9cd 8902 	strd	r8, r9, [sp, #8]
  while (fabs(D2) >= G2) {
 800d10a:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
 800d10e:	940b      	str	r4, [sp, #44]	; 0x2c
    h22 *= G;
 800d110:	f01a feca 	bl	8027ea8 <__aeabi_dmul>
  while (fabs(D2) >= G2) {
 800d114:	4b33      	ldr	r3, [pc, #204]	; (800d1e4 <cblas_drotmg+0x52c>)
    h22 *= G;
 800d116:	4680      	mov	r8, r0
 800d118:	4689      	mov	r9, r1
  while (fabs(D2) >= G2) {
 800d11a:	2200      	movs	r2, #0
 800d11c:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    h22 *= G;
 800d120:	e9cd 8906 	strd	r8, r9, [sp, #24]
  while (fabs(D2) >= G2) {
 800d124:	f01b f946 	bl	80283b4 <__aeabi_dcmpge>
 800d128:	2800      	cmp	r0, #0
 800d12a:	d1d6      	bne.n	800d0da <cblas_drotmg+0x422>
 800d12c:	4b2f      	ldr	r3, [pc, #188]	; (800d1ec <cblas_drotmg+0x534>)
 800d12e:	990c      	ldr	r1, [sp, #48]	; 0x30
 800d130:	2200      	movs	r2, #0
 800d132:	e9c1 2300 	strd	r2, r3, [r1]
 800d136:	ec55 4b18 	vmov	r4, r5, d8
  *d1 = D1;
 800d13a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  if (P[0] == -1.0) {
 800d13c:	9e0c      	ldr	r6, [sp, #48]	; 0x30
  *d1 = D1;
 800d13e:	e9c3 4500 	strd	r4, r5, [r3]
  *d2 = D2;
 800d142:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  *b1 = x;
 800d144:	ed9d 7b00 	vldr	d7, [sp]
  *d2 = D2;
 800d148:	e9c3 ab00 	strd	sl, fp, [r3]
  *b1 = x;
 800d14c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d14e:	ed83 7b00 	vstr	d7, [r3]
  if (P[0] == -1.0) {
 800d152:	e9d6 4500 	ldrd	r4, r5, [r6]
 800d156:	4b25      	ldr	r3, [pc, #148]	; (800d1ec <cblas_drotmg+0x534>)
 800d158:	2200      	movs	r2, #0
 800d15a:	4620      	mov	r0, r4
 800d15c:	4629      	mov	r1, r5
 800d15e:	f01b f90b 	bl	8028378 <__aeabi_dcmpeq>
 800d162:	b1a0      	cbz	r0, 800d18e <cblas_drotmg+0x4d6>
    P[1] = h11;
 800d164:	ed9d 7b08 	vldr	d7, [sp, #32]
 800d168:	ed86 7b02 	vstr	d7, [r6, #8]
    P[2] = h21;
 800d16c:	ed9d 7b02 	vldr	d7, [sp, #8]
 800d170:	ed86 7b04 	vstr	d7, [r6, #16]
    P[3] = h12;
 800d174:	ed9d 7b04 	vldr	d7, [sp, #16]
 800d178:	ed86 7b06 	vstr	d7, [r6, #24]
    P[4] = h22;
 800d17c:	ed9d 7b06 	vldr	d7, [sp, #24]
 800d180:	ed86 7b08 	vstr	d7, [r6, #32]
 800d184:	b013      	add	sp, #76	; 0x4c
 800d186:	ecbd 8b06 	vpop	{d8-d10}
 800d18a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (P[0] == 0.0) {
 800d18e:	2200      	movs	r2, #0
 800d190:	2300      	movs	r3, #0
 800d192:	4620      	mov	r0, r4
 800d194:	4629      	mov	r1, r5
 800d196:	f01b f8ef 	bl	8028378 <__aeabi_dcmpeq>
 800d19a:	b160      	cbz	r0, 800d1b6 <cblas_drotmg+0x4fe>
    P[2] = h21;
 800d19c:	ed9d 7b02 	vldr	d7, [sp, #8]
 800d1a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d1a2:	ed83 7b04 	vstr	d7, [r3, #16]
    P[3] = h12;
 800d1a6:	ed9d 7b04 	vldr	d7, [sp, #16]
 800d1aa:	ed83 7b06 	vstr	d7, [r3, #24]
 800d1ae:	e631      	b.n	800ce14 <cblas_drotmg+0x15c>
 800d1b0:	ec55 4b19 	vmov	r4, r5, d9
 800d1b4:	e785      	b.n	800d0c2 <cblas_drotmg+0x40a>
  } else if (P[0] == 1.0) {
 800d1b6:	4b0e      	ldr	r3, [pc, #56]	; (800d1f0 <cblas_drotmg+0x538>)
 800d1b8:	4620      	mov	r0, r4
 800d1ba:	4629      	mov	r1, r5
 800d1bc:	2200      	movs	r2, #0
 800d1be:	f01b f8db 	bl	8028378 <__aeabi_dcmpeq>
 800d1c2:	2800      	cmp	r0, #0
 800d1c4:	f43f ae26 	beq.w	800ce14 <cblas_drotmg+0x15c>
    P[1] = h11;
 800d1c8:	ed9d 7b08 	vldr	d7, [sp, #32]
 800d1cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d1ce:	ed83 7b02 	vstr	d7, [r3, #8]
    P[4] = h22;
 800d1d2:	ed9d 7b06 	vldr	d7, [sp, #24]
 800d1d6:	ed83 7b08 	vstr	d7, [r3, #32]
 800d1da:	e61b      	b.n	800ce14 <cblas_drotmg+0x15c>
 800d1dc:	3f300000 	.word	0x3f300000
 800d1e0:	3e700000 	.word	0x3e700000
 800d1e4:	41700000 	.word	0x41700000
 800d1e8:	40b00000 	.word	0x40b00000
 800d1ec:	bff00000 	.word	0xbff00000
 800d1f0:	3ff00000 	.word	0x3ff00000

0800d1f4 <cblas_dscal>:
  if (incX <= 0) {
 800d1f4:	2a00      	cmp	r2, #0
 800d1f6:	dd18      	ble.n	800d22a <cblas_dscal+0x36>
  for (i = 0; i < N; i++) {
 800d1f8:	2800      	cmp	r0, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_dscal (const int N, const double alpha, double *X, const int incX)
{
 800d1fa:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d1fe:	4681      	mov	r9, r0
 800d200:	dd11      	ble.n	800d226 <cblas_dscal+0x32>
 800d202:	ec57 6b10 	vmov	r6, r7, d0
 800d206:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 800d20a:	460c      	mov	r4, r1
 800d20c:	2500      	movs	r5, #0
    X[ix] *= alpha;
 800d20e:	e9d4 0100 	ldrd	r0, r1, [r4]
 800d212:	4632      	mov	r2, r6
 800d214:	463b      	mov	r3, r7
 800d216:	f01a fe47 	bl	8027ea8 <__aeabi_dmul>
  for (i = 0; i < N; i++) {
 800d21a:	3501      	adds	r5, #1
 800d21c:	45a9      	cmp	r9, r5
    X[ix] *= alpha;
 800d21e:	e9c4 0100 	strd	r0, r1, [r4]
  for (i = 0; i < N; i++) {
 800d222:	4444      	add	r4, r8
 800d224:	d1f3      	bne.n	800d20e <cblas_dscal+0x1a>
#define BASE double
#include "source_scal_r.h"
#undef BASE
}
 800d226:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d22a:	4770      	bx	lr

0800d22c <cblas_dsdot>:
#include "cblas.h"

double
cblas_dsdot (const int N, const float *X, const int incX, const float *Y,
             const int incY)
{
 800d22c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  INDEX ix = OFFSET(N, incX);
 800d230:	2a00      	cmp	r2, #0
 800d232:	4682      	mov	sl, r0
 800d234:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d236:	bfda      	itte	le
 800d238:	f1ca 0701 	rsble	r7, sl, #1
 800d23c:	4357      	mulle	r7, r2
 800d23e:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 800d240:	2800      	cmp	r0, #0
 800d242:	bfda      	itte	le
 800d244:	f1ca 0601 	rsble	r6, sl, #1
 800d248:	4346      	mulle	r6, r0
 800d24a:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 800d24c:	f1ba 0f00 	cmp.w	sl, #0
 800d250:	f04f 0400 	mov.w	r4, #0
 800d254:	f04f 0500 	mov.w	r5, #0
 800d258:	dd21      	ble.n	800d29e <cblas_dsdot+0x72>
 800d25a:	ea4f 0982 	mov.w	r9, r2, lsl #2
 800d25e:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 800d262:	ea4f 0b80 	mov.w	fp, r0, lsl #2
 800d266:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 800d26a:	f04f 0800 	mov.w	r8, #0
    r += X[ix] * Y[iy];
 800d26e:	ed97 7a00 	vldr	s14, [r7]
 800d272:	edd6 7a00 	vldr	s15, [r6]
 800d276:	ee67 7a27 	vmul.f32	s15, s14, s15
  for (i = 0; i < N; i++) {
 800d27a:	f108 0801 	add.w	r8, r8, #1
    r += X[ix] * Y[iy];
 800d27e:	ee17 0a90 	vmov	r0, s15
 800d282:	f01a fdb9 	bl	8027df8 <__aeabi_f2d>
 800d286:	4602      	mov	r2, r0
 800d288:	460b      	mov	r3, r1
 800d28a:	4620      	mov	r0, r4
 800d28c:	4629      	mov	r1, r5
 800d28e:	f01a fc55 	bl	8027b3c <__adddf3>
  for (i = 0; i < N; i++) {
 800d292:	45c2      	cmp	sl, r8
 800d294:	444f      	add	r7, r9
 800d296:	445e      	add	r6, fp
    r += X[ix] * Y[iy];
 800d298:	4604      	mov	r4, r0
 800d29a:	460d      	mov	r5, r1
  for (i = 0; i < N; i++) {
 800d29c:	d1e7      	bne.n	800d26e <cblas_dsdot+0x42>
#define BASE float
#include "source_dot_r.h"
#undef ACC_TYPE
#undef BASE
#undef INIT_VAL
}
 800d29e:	ec45 4b10 	vmov	d0, r4, r5
 800d2a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d2a6:	bf00      	nop

0800d2a8 <cblas_dswap>:
#include "cblas.h"

void
cblas_dswap (const int N, double *X, const int incX, double *Y,
             const int incY)
{
 800d2a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  INDEX ix = OFFSET(N, incX);
 800d2aa:	2a00      	cmp	r2, #0
 800d2ac:	9c05      	ldr	r4, [sp, #20]
 800d2ae:	bfda      	itte	le
 800d2b0:	f1c0 0601 	rsble	r6, r0, #1
 800d2b4:	4356      	mulle	r6, r2
 800d2b6:	2600      	movgt	r6, #0
  INDEX iy = OFFSET(N, incY);
 800d2b8:	2c00      	cmp	r4, #0
 800d2ba:	bfda      	itte	le
 800d2bc:	f1c0 0501 	rsble	r5, r0, #1
 800d2c0:	4365      	mulle	r5, r4
 800d2c2:	2500      	movgt	r5, #0
  for (i = 0; i < N; i++) {
 800d2c4:	2800      	cmp	r0, #0
 800d2c6:	dd15      	ble.n	800d2f4 <cblas_dswap+0x4c>
 800d2c8:	ea4f 0cc2 	mov.w	ip, r2, lsl #3
 800d2cc:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
 800d2d0:	ea4f 0ec4 	mov.w	lr, r4, lsl #3
 800d2d4:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 800d2d8:	2200      	movs	r2, #0
    const BASE tmp = X[ix];
 800d2da:	e9d1 4500 	ldrd	r4, r5, [r1]
    X[ix] = Y[iy];
 800d2de:	e9d3 6700 	ldrd	r6, r7, [r3]
  for (i = 0; i < N; i++) {
 800d2e2:	3201      	adds	r2, #1
 800d2e4:	4290      	cmp	r0, r2
    X[ix] = Y[iy];
 800d2e6:	e9c1 6700 	strd	r6, r7, [r1]
    Y[iy] = tmp;
 800d2ea:	e9c3 4500 	strd	r4, r5, [r3]
  for (i = 0; i < N; i++) {
 800d2ee:	4461      	add	r1, ip
 800d2f0:	4473      	add	r3, lr
 800d2f2:	d1f2      	bne.n	800d2da <cblas_dswap+0x32>
#define BASE double
#include "source_swap_r.h"
#undef BASE
}
 800d2f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d2f6:	bf00      	nop

0800d2f8 <cblas_dsymm>:
cblas_dsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const double alpha, const double *A, const int lda,
             const double *B, const int ldb, const double beta, double *C,
             const int ldc)
{
 800d2f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d2fc:	ed2d 8b06 	vpush	{d8-d10}
 800d300:	eeb0 9a40 	vmov.f32	s18, s0
 800d304:	eef0 9a60 	vmov.f32	s19, s1
 800d308:	b097      	sub	sp, #92	; 0x5c
 800d30a:	298d      	cmp	r1, #141	; 0x8d
 800d30c:	9307      	str	r3, [sp, #28]
 800d30e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800d310:	9306      	str	r3, [sp, #24]
 800d312:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800d314:	930b      	str	r3, [sp, #44]	; 0x2c
 800d316:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800d318:	9309      	str	r3, [sp, #36]	; 0x24
 800d31a:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 800d31c:	930c      	str	r3, [sp, #48]	; 0x30
 800d31e:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 800d320:	930f      	str	r3, [sp, #60]	; 0x3c
 800d322:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 800d324:	930a      	str	r3, [sp, #40]	; 0x28
 800d326:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 800d328:	930e      	str	r3, [sp, #56]	; 0x38
 800d32a:	ec57 6b11 	vmov	r6, r7, d1
 800d32e:	468b      	mov	fp, r1
 800d330:	4604      	mov	r4, r0
 800d332:	4690      	mov	r8, r2
 800d334:	f000 80dd 	beq.w	800d4f2 <cblas_dsymm+0x1fa>
 800d338:	298e      	cmp	r1, #142	; 0x8e
 800d33a:	f000 8296 	beq.w	800d86a <cblas_dsymm+0x572>
 800d33e:	9b06      	ldr	r3, [sp, #24]
 800d340:	2002      	movs	r0, #2
 800d342:	f1a8 0279 	sub.w	r2, r8, #121	; 0x79
 800d346:	2a01      	cmp	r2, #1
 800d348:	9a07      	ldr	r2, [sp, #28]
 800d34a:	bf88      	it	hi
 800d34c:	2003      	movhi	r0, #3
 800d34e:	2a00      	cmp	r2, #0
 800d350:	9a06      	ldr	r2, [sp, #24]
 800d352:	bfb8      	it	lt
 800d354:	2004      	movlt	r0, #4
 800d356:	2b01      	cmp	r3, #1
 800d358:	bfb8      	it	lt
 800d35a:	2301      	movlt	r3, #1
 800d35c:	2a00      	cmp	r2, #0
 800d35e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d360:	f2c0 80bc 	blt.w	800d4dc <cblas_dsymm+0x1e4>
 800d364:	4293      	cmp	r3, r2
 800d366:	dd66      	ble.n	800d436 <cblas_dsymm+0x13e>
 800d368:	2c65      	cmp	r4, #101	; 0x65
 800d36a:	f000 8262 	beq.w	800d832 <cblas_dsymm+0x53a>
 800d36e:	2c66      	cmp	r4, #102	; 0x66
 800d370:	f000 826d 	beq.w	800d84e <cblas_dsymm+0x556>
 800d374:	2008      	movs	r0, #8
 800d376:	4ab8      	ldr	r2, [pc, #736]	; (800d658 <cblas_dsymm+0x360>)
 800d378:	49b8      	ldr	r1, [pc, #736]	; (800d65c <cblas_dsymm+0x364>)
 800d37a:	f01a fb65 	bl	8027a48 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800d37e:	ec51 0b19 	vmov	r0, r1, d9
 800d382:	2200      	movs	r2, #0
 800d384:	2300      	movs	r3, #0
 800d386:	f01a fff7 	bl	8028378 <__aeabi_dcmpeq>
 800d38a:	b138      	cbz	r0, 800d39c <cblas_dsymm+0xa4>
 800d38c:	4bb4      	ldr	r3, [pc, #720]	; (800d660 <cblas_dsymm+0x368>)
 800d38e:	2200      	movs	r2, #0
 800d390:	4630      	mov	r0, r6
 800d392:	4639      	mov	r1, r7
 800d394:	f01a fff0 	bl	8028378 <__aeabi_dcmpeq>
 800d398:	2800      	cmp	r0, #0
 800d39a:	d167      	bne.n	800d46c <cblas_dsymm+0x174>
  if (Order == CblasRowMajor) {
 800d39c:	2c65      	cmp	r4, #101	; 0x65
 800d39e:	f000 80af 	beq.w	800d500 <cblas_dsymm+0x208>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800d3a2:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 800d3a6:	bf0c      	ite	eq
 800d3a8:	237a      	moveq	r3, #122	; 0x7a
 800d3aa:	2379      	movne	r3, #121	; 0x79
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800d3ac:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800d3b0:	9301      	str	r3, [sp, #4]
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800d3b2:	bf0c      	ite	eq
 800d3b4:	f04f 0b8e 	moveq.w	fp, #142	; 0x8e
 800d3b8:	f04f 0b8d 	movne.w	fp, #141	; 0x8d
  if (beta == 0.0) {
 800d3bc:	2200      	movs	r2, #0
 800d3be:	2300      	movs	r3, #0
 800d3c0:	4630      	mov	r0, r6
 800d3c2:	4639      	mov	r1, r7
 800d3c4:	f01a ffd8 	bl	8028378 <__aeabi_dcmpeq>
 800d3c8:	2800      	cmp	r0, #0
 800d3ca:	d054      	beq.n	800d476 <cblas_dsymm+0x17e>
    for (i = 0; i < n1; i++) {
 800d3cc:	9b06      	ldr	r3, [sp, #24]
 800d3ce:	2b00      	cmp	r3, #0
 800d3d0:	dd19      	ble.n	800d406 <cblas_dsymm+0x10e>
 800d3d2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d3d4:	9d07      	ldr	r5, [sp, #28]
 800d3d6:	f8dd c018 	ldr.w	ip, [sp, #24]
 800d3da:	00d4      	lsls	r4, r2, #3
 800d3dc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d3de:	ebc5 7045 	rsb	r0, r5, r5, lsl #29
 800d3e2:	00c0      	lsls	r0, r0, #3
 800d3e4:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800d3e8:	2100      	movs	r1, #0
        C[ldc * i + j] = 0.0;
 800d3ea:	2600      	movs	r6, #0
 800d3ec:	2700      	movs	r7, #0
      for (j = 0; j < n2; j++) {
 800d3ee:	2d00      	cmp	r5, #0
 800d3f0:	bfc8      	it	gt
 800d3f2:	1813      	addgt	r3, r2, r0
 800d3f4:	dd03      	ble.n	800d3fe <cblas_dsymm+0x106>
        C[ldc * i + j] = 0.0;
 800d3f6:	e8e3 6702 	strd	r6, r7, [r3], #8
      for (j = 0; j < n2; j++) {
 800d3fa:	4293      	cmp	r3, r2
 800d3fc:	d1fb      	bne.n	800d3f6 <cblas_dsymm+0xfe>
    for (i = 0; i < n1; i++) {
 800d3fe:	3101      	adds	r1, #1
 800d400:	458c      	cmp	ip, r1
 800d402:	4422      	add	r2, r4
 800d404:	d1f3      	bne.n	800d3ee <cblas_dsymm+0xf6>
  if (alpha == 0.0)
 800d406:	ec51 0b19 	vmov	r0, r1, d9
 800d40a:	2200      	movs	r2, #0
 800d40c:	2300      	movs	r3, #0
 800d40e:	f01a ffb3 	bl	8028378 <__aeabi_dcmpeq>
 800d412:	bb58      	cbnz	r0, 800d46c <cblas_dsymm+0x174>
  if (side == CblasLeft && uplo == CblasUpper) {
 800d414:	f1bb 0f8d 	cmp.w	fp, #141	; 0x8d
 800d418:	f000 815f 	beq.w	800d6da <cblas_dsymm+0x3e2>
  } else if (side == CblasRight && uplo == CblasUpper) {
 800d41c:	f1bb 0f8e 	cmp.w	fp, #142	; 0x8e
 800d420:	d075      	beq.n	800d50e <cblas_dsymm+0x216>
    BLAS_ERROR("unrecognized operation");
 800d422:	4a90      	ldr	r2, [pc, #576]	; (800d664 <cblas_dsymm+0x36c>)
 800d424:	498d      	ldr	r1, [pc, #564]	; (800d65c <cblas_dsymm+0x364>)
 800d426:	2000      	movs	r0, #0
#define BASE double
#include "source_symm_r.h"
#undef BASE
}
 800d428:	b017      	add	sp, #92	; 0x5c
 800d42a:	ecbd 8b06 	vpop	{d8-d10}
 800d42e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d432:	f01a bb09 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800d436:	2c65      	cmp	r4, #101	; 0x65
 800d438:	f000 8116 	beq.w	800d668 <cblas_dsymm+0x370>
 800d43c:	2c66      	cmp	r4, #102	; 0x66
 800d43e:	f000 812b 	beq.w	800d698 <cblas_dsymm+0x3a0>
 800d442:	2800      	cmp	r0, #0
 800d444:	d09b      	beq.n	800d37e <cblas_dsymm+0x86>
 800d446:	e796      	b.n	800d376 <cblas_dsymm+0x7e>
        C[i * ldc + j] += alpha * temp2;
 800d448:	2200      	movs	r2, #0
 800d44a:	2300      	movs	r3, #0
 800d44c:	ec51 0b19 	vmov	r0, r1, d9
 800d450:	f01a fd2a 	bl	8027ea8 <__aeabi_dmul>
 800d454:	4622      	mov	r2, r4
 800d456:	462b      	mov	r3, r5
 800d458:	f01a fb70 	bl	8027b3c <__adddf3>
 800d45c:	9b03      	ldr	r3, [sp, #12]
      for (j = 0; j < n2; j++) {
 800d45e:	9a05      	ldr	r2, [sp, #20]
        C[i * ldc + j] += alpha * temp2;
 800d460:	e943 0102 	strd	r0, r1, [r3, #-8]
      for (j = 0; j < n2; j++) {
 800d464:	9b07      	ldr	r3, [sp, #28]
 800d466:	4293      	cmp	r3, r2
 800d468:	f300 82a0 	bgt.w	800d9ac <cblas_dsymm+0x6b4>
 800d46c:	b017      	add	sp, #92	; 0x5c
 800d46e:	ecbd 8b06 	vpop	{d8-d10}
 800d472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  } else if (beta != 1.0) {
 800d476:	4b7a      	ldr	r3, [pc, #488]	; (800d660 <cblas_dsymm+0x368>)
 800d478:	2200      	movs	r2, #0
 800d47a:	4630      	mov	r0, r6
 800d47c:	4639      	mov	r1, r7
 800d47e:	f01a ff7b 	bl	8028378 <__aeabi_dcmpeq>
 800d482:	2800      	cmp	r0, #0
 800d484:	d1bf      	bne.n	800d406 <cblas_dsymm+0x10e>
    for (i = 0; i < n1; i++) {
 800d486:	9b06      	ldr	r3, [sp, #24]
 800d488:	2b00      	cmp	r3, #0
 800d48a:	ddbc      	ble.n	800d406 <cblas_dsymm+0x10e>
 800d48c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d48e:	9b07      	ldr	r3, [sp, #28]
 800d490:	f8cd b008 	str.w	fp, [sp, #8]
 800d494:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 800d498:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d49a:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 800d49e:	4680      	mov	r8, r0
 800d4a0:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800d4a4:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 800d4a8:	469b      	mov	fp, r3
      for (j = 0; j < n2; j++) {
 800d4aa:	f1bb 0f00 	cmp.w	fp, #0
 800d4ae:	bfc8      	it	gt
 800d4b0:	eb05 0409 	addgt.w	r4, r5, r9
 800d4b4:	dd09      	ble.n	800d4ca <cblas_dsymm+0x1d2>
        C[ldc * i + j] *= beta;
 800d4b6:	e9d4 0100 	ldrd	r0, r1, [r4]
 800d4ba:	4632      	mov	r2, r6
 800d4bc:	463b      	mov	r3, r7
 800d4be:	f01a fcf3 	bl	8027ea8 <__aeabi_dmul>
 800d4c2:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j < n2; j++) {
 800d4c6:	42ac      	cmp	r4, r5
 800d4c8:	d1f5      	bne.n	800d4b6 <cblas_dsymm+0x1be>
    for (i = 0; i < n1; i++) {
 800d4ca:	9b06      	ldr	r3, [sp, #24]
 800d4cc:	f108 0801 	add.w	r8, r8, #1
 800d4d0:	4543      	cmp	r3, r8
 800d4d2:	4455      	add	r5, sl
 800d4d4:	d1e9      	bne.n	800d4aa <cblas_dsymm+0x1b2>
 800d4d6:	f8dd b008 	ldr.w	fp, [sp, #8]
 800d4da:	e794      	b.n	800d406 <cblas_dsymm+0x10e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800d4dc:	429a      	cmp	r2, r3
 800d4de:	f6ff af43 	blt.w	800d368 <cblas_dsymm+0x70>
 800d4e2:	2c65      	cmp	r4, #101	; 0x65
 800d4e4:	f000 80cd 	beq.w	800d682 <cblas_dsymm+0x38a>
 800d4e8:	2c66      	cmp	r4, #102	; 0x66
 800d4ea:	f000 835c 	beq.w	800dba6 <cblas_dsymm+0x8ae>
 800d4ee:	2005      	movs	r0, #5
 800d4f0:	e741      	b.n	800d376 <cblas_dsymm+0x7e>
 800d4f2:	3865      	subs	r0, #101	; 0x65
 800d4f4:	2801      	cmp	r0, #1
 800d4f6:	9b07      	ldr	r3, [sp, #28]
 800d4f8:	bf94      	ite	ls
 800d4fa:	2000      	movls	r0, #0
 800d4fc:	2001      	movhi	r0, #1
 800d4fe:	e720      	b.n	800d342 <cblas_dsymm+0x4a>
    uplo = Uplo;
 800d500:	9b06      	ldr	r3, [sp, #24]
 800d502:	9a07      	ldr	r2, [sp, #28]
 800d504:	f8cd 8004 	str.w	r8, [sp, #4]
    side = Side;
 800d508:	e9cd 2306 	strd	r2, r3, [sp, #24]
 800d50c:	e756      	b.n	800d3bc <cblas_dsymm+0xc4>
  } else if (side == CblasRight && uplo == CblasUpper) {
 800d50e:	9b01      	ldr	r3, [sp, #4]
 800d510:	2b79      	cmp	r3, #121	; 0x79
 800d512:	f000 828e 	beq.w	800da32 <cblas_dsymm+0x73a>
  } else if (side == CblasRight && uplo == CblasLower) {
 800d516:	9b01      	ldr	r3, [sp, #4]
 800d518:	2b7a      	cmp	r3, #122	; 0x7a
 800d51a:	d182      	bne.n	800d422 <cblas_dsymm+0x12a>
    for (i = 0; i < n1; i++) {
 800d51c:	9b06      	ldr	r3, [sp, #24]
 800d51e:	2b00      	cmp	r3, #0
 800d520:	dda4      	ble.n	800d46c <cblas_dsymm+0x174>
 800d522:	990e      	ldr	r1, [sp, #56]	; 0x38
 800d524:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800d526:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d528:	920d      	str	r2, [sp, #52]	; 0x34
 800d52a:	00c9      	lsls	r1, r1, #3
 800d52c:	9110      	str	r1, [sp, #64]	; 0x40
 800d52e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800d530:	900f      	str	r0, [sp, #60]	; 0x3c
 800d532:	00c9      	lsls	r1, r1, #3
 800d534:	9111      	str	r1, [sp, #68]	; 0x44
 800d536:	9907      	ldr	r1, [sp, #28]
 800d538:	3301      	adds	r3, #1
 800d53a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800d53e:	920a      	str	r2, [sp, #40]	; 0x28
 800d540:	00da      	lsls	r2, r3, #3
 800d542:	920e      	str	r2, [sp, #56]	; 0x38
 800d544:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d546:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800d54a:	9312      	str	r3, [sp, #72]	; 0x48
      for (j = 0; j < n2; j++) {
 800d54c:	9b07      	ldr	r3, [sp, #28]
 800d54e:	2b00      	cmp	r3, #0
 800d550:	f340 80af 	ble.w	800d6b2 <cblas_dsymm+0x3ba>
        const BASE temp1 = alpha * B[ldb * i + j];
 800d554:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d556:	4619      	mov	r1, r3
 800d558:	e8f1 2302 	ldrd	r2, r3, [r1], #8
 800d55c:	9108      	str	r1, [sp, #32]
 800d55e:	ec51 0b19 	vmov	r0, r1, d9
 800d562:	f01a fca1 	bl	8027ea8 <__aeabi_dmul>
 800d566:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d568:	9304      	str	r3, [sp, #16]
 800d56a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d56c:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
 800d570:	9303      	str	r3, [sp, #12]
 800d572:	ec41 0b18 	vmov	d8, r0, r1
 800d576:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800d578:	9305      	str	r3, [sp, #20]
        BASE temp2 = 0.0;
 800d57a:	f04f 0800 	mov.w	r8, #0
 800d57e:	f04f 0900 	mov.w	r9, #0
 800d582:	f8cd b008 	str.w	fp, [sp, #8]
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
 800d586:	9b03      	ldr	r3, [sp, #12]
 800d588:	ec51 0b18 	vmov	r0, r1, d8
 800d58c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800d590:	f01a fc8a 	bl	8027ea8 <__aeabi_dmul>
 800d594:	4642      	mov	r2, r8
 800d596:	4604      	mov	r4, r0
 800d598:	460d      	mov	r5, r1
 800d59a:	464b      	mov	r3, r9
 800d59c:	ec51 0b19 	vmov	r0, r1, d9
 800d5a0:	f01a fc82 	bl	8027ea8 <__aeabi_dmul>
 800d5a4:	9e05      	ldr	r6, [sp, #20]
 800d5a6:	4602      	mov	r2, r0
 800d5a8:	460b      	mov	r3, r1
 800d5aa:	4620      	mov	r0, r4
 800d5ac:	4629      	mov	r1, r5
 800d5ae:	e9d6 4500 	ldrd	r4, r5, [r6]
 800d5b2:	f01a fac3 	bl	8027b3c <__adddf3>
 800d5b6:	462b      	mov	r3, r5
 800d5b8:	4622      	mov	r2, r4
 800d5ba:	f01a fabf 	bl	8027b3c <__adddf3>
 800d5be:	e8e6 0102 	strd	r0, r1, [r6], #8
      for (j = 0; j < n2; j++) {
 800d5c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
 800d5c4:	9605      	str	r6, [sp, #20]
      for (j = 0; j < n2; j++) {
 800d5c6:	429e      	cmp	r6, r3
 800d5c8:	d073      	beq.n	800d6b2 <cblas_dsymm+0x3ba>
        const BASE temp1 = alpha * B[ldb * i + j];
 800d5ca:	9c08      	ldr	r4, [sp, #32]
 800d5cc:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800d5d0:	ec53 2b19 	vmov	r2, r3, d9
 800d5d4:	9408      	str	r4, [sp, #32]
 800d5d6:	f01a fc67 	bl	8027ea8 <__aeabi_dmul>
 800d5da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d5dc:	9a04      	ldr	r2, [sp, #16]
 800d5de:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
 800d5e2:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800d5e6:	ec41 0b18 	vmov	d8, r0, r1
 800d5ea:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d5ec:	9301      	str	r3, [sp, #4]
        BASE temp2 = 0.0;
 800d5ee:	f04f 0800 	mov.w	r8, #0
 800d5f2:	f04f 0900 	mov.w	r9, #0
          const BASE Ajk = A[j * lda + k];
 800d5f6:	e8fb 6702 	ldrd	r6, r7, [fp], #8
          C[i * ldc + k] += temp1 * Ajk;
 800d5fa:	e9da 4500 	ldrd	r4, r5, [sl]
 800d5fe:	4632      	mov	r2, r6
 800d600:	463b      	mov	r3, r7
 800d602:	ec51 0b18 	vmov	r0, r1, d8
 800d606:	f01a fc4f 	bl	8027ea8 <__aeabi_dmul>
 800d60a:	4622      	mov	r2, r4
 800d60c:	462b      	mov	r3, r5
 800d60e:	f01a fa95 	bl	8027b3c <__adddf3>
 800d612:	e8ea 0102 	strd	r0, r1, [sl], #8
          temp2 += B[ldb * i + k] * Ajk;
 800d616:	9c01      	ldr	r4, [sp, #4]
 800d618:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800d61c:	4632      	mov	r2, r6
 800d61e:	463b      	mov	r3, r7
 800d620:	9401      	str	r4, [sp, #4]
 800d622:	f01a fc41 	bl	8027ea8 <__aeabi_dmul>
 800d626:	460b      	mov	r3, r1
 800d628:	4602      	mov	r2, r0
 800d62a:	4649      	mov	r1, r9
 800d62c:	4640      	mov	r0, r8
 800d62e:	f01a fa85 	bl	8027b3c <__adddf3>
        for (k = 0; k < j; k++) {
 800d632:	9b02      	ldr	r3, [sp, #8]
 800d634:	459b      	cmp	fp, r3
          temp2 += B[ldb * i + k] * Ajk;
 800d636:	4680      	mov	r8, r0
 800d638:	4689      	mov	r9, r1
        for (k = 0; k < j; k++) {
 800d63a:	d1dc      	bne.n	800d5f6 <cblas_dsymm+0x2fe>
 800d63c:	9a03      	ldr	r2, [sp, #12]
 800d63e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d640:	4611      	mov	r1, r2
 800d642:	4419      	add	r1, r3
 800d644:	9a04      	ldr	r2, [sp, #16]
 800d646:	9103      	str	r1, [sp, #12]
 800d648:	9909      	ldr	r1, [sp, #36]	; 0x24
 800d64a:	440a      	add	r2, r1
 800d64c:	9204      	str	r2, [sp, #16]
 800d64e:	9a02      	ldr	r2, [sp, #8]
 800d650:	441a      	add	r2, r3
 800d652:	9202      	str	r2, [sp, #8]
 800d654:	e797      	b.n	800d586 <cblas_dsymm+0x28e>
 800d656:	bf00      	nop
 800d658:	08030378 	.word	0x08030378
 800d65c:	0803060c 	.word	0x0803060c
 800d660:	3ff00000 	.word	0x3ff00000
 800d664:	080305a8 	.word	0x080305a8
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800d668:	9b06      	ldr	r3, [sp, #24]
 800d66a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d66c:	2b01      	cmp	r3, #1
 800d66e:	bfb8      	it	lt
 800d670:	2301      	movlt	r3, #1
 800d672:	4293      	cmp	r3, r2
 800d674:	dc0a      	bgt.n	800d68c <cblas_dsymm+0x394>
 800d676:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d678:	4293      	cmp	r3, r2
 800d67a:	f77f aee2 	ble.w	800d442 <cblas_dsymm+0x14a>
 800d67e:	200d      	movs	r0, #13
 800d680:	e679      	b.n	800d376 <cblas_dsymm+0x7e>
 800d682:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d684:	2b00      	cmp	r3, #0
 800d686:	f300 81ce 	bgt.w	800da26 <cblas_dsymm+0x72e>
 800d68a:	2301      	movs	r3, #1
 800d68c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d68e:	429a      	cmp	r2, r3
 800d690:	bfb4      	ite	lt
 800d692:	200d      	movlt	r0, #13
 800d694:	200a      	movge	r0, #10
 800d696:	e66e      	b.n	800d376 <cblas_dsymm+0x7e>
 800d698:	9b07      	ldr	r3, [sp, #28]
 800d69a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d69c:	2b01      	cmp	r3, #1
 800d69e:	bfb8      	it	lt
 800d6a0:	2301      	movlt	r3, #1
 800d6a2:	4293      	cmp	r3, r2
 800d6a4:	dde7      	ble.n	800d676 <cblas_dsymm+0x37e>
 800d6a6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d6a8:	4293      	cmp	r3, r2
 800d6aa:	bfcc      	ite	gt
 800d6ac:	200d      	movgt	r0, #13
 800d6ae:	200a      	movle	r0, #10
 800d6b0:	e661      	b.n	800d376 <cblas_dsymm+0x7e>
    for (i = 0; i < n1; i++) {
 800d6b2:	990d      	ldr	r1, [sp, #52]	; 0x34
 800d6b4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800d6b6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d6b8:	4608      	mov	r0, r1
 800d6ba:	4410      	add	r0, r2
 800d6bc:	990c      	ldr	r1, [sp, #48]	; 0x30
 800d6be:	900d      	str	r0, [sp, #52]	; 0x34
 800d6c0:	9811      	ldr	r0, [sp, #68]	; 0x44
 800d6c2:	4401      	add	r1, r0
 800d6c4:	910c      	str	r1, [sp, #48]	; 0x30
 800d6c6:	990a      	ldr	r1, [sp, #40]	; 0x28
 800d6c8:	4411      	add	r1, r2
 800d6ca:	9a06      	ldr	r2, [sp, #24]
 800d6cc:	910a      	str	r1, [sp, #40]	; 0x28
 800d6ce:	3301      	adds	r3, #1
 800d6d0:	429a      	cmp	r2, r3
 800d6d2:	930f      	str	r3, [sp, #60]	; 0x3c
 800d6d4:	f47f af3a 	bne.w	800d54c <cblas_dsymm+0x254>
 800d6d8:	e6c8      	b.n	800d46c <cblas_dsymm+0x174>
  if (side == CblasLeft && uplo == CblasUpper) {
 800d6da:	9b01      	ldr	r3, [sp, #4]
 800d6dc:	2b79      	cmp	r3, #121	; 0x79
 800d6de:	f000 80cb 	beq.w	800d878 <cblas_dsymm+0x580>
  } else if (side == CblasLeft && uplo == CblasLower) {
 800d6e2:	9b01      	ldr	r3, [sp, #4]
 800d6e4:	2b7a      	cmp	r3, #122	; 0x7a
 800d6e6:	f47f ae9c 	bne.w	800d422 <cblas_dsymm+0x12a>
    for (i = 0; i < n1; i++) {
 800d6ea:	9b06      	ldr	r3, [sp, #24]
 800d6ec:	2b00      	cmp	r3, #0
 800d6ee:	f77f aebd 	ble.w	800d46c <cblas_dsymm+0x174>
 800d6f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d6f4:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 800d6f8:	900d      	str	r0, [sp, #52]	; 0x34
 800d6fa:	3301      	adds	r3, #1
 800d6fc:	00db      	lsls	r3, r3, #3
 800d6fe:	f1a3 0208 	sub.w	r2, r3, #8
 800d702:	9312      	str	r3, [sp, #72]	; 0x48
 800d704:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d706:	9211      	str	r2, [sp, #68]	; 0x44
 800d708:	00db      	lsls	r3, r3, #3
 800d70a:	9a07      	ldr	r2, [sp, #28]
 800d70c:	9301      	str	r3, [sp, #4]
 800d70e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d710:	9010      	str	r0, [sp, #64]	; 0x40
 800d712:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800d716:	9309      	str	r3, [sp, #36]	; 0x24
 800d718:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d71a:	9008      	str	r0, [sp, #32]
 800d71c:	00db      	lsls	r3, r3, #3
 800d71e:	9302      	str	r3, [sp, #8]
      for (j = 0; j < n2; j++) {
 800d720:	9b07      	ldr	r3, [sp, #28]
 800d722:	2b00      	cmp	r3, #0
 800d724:	dd6b      	ble.n	800d7fe <cblas_dsymm+0x506>
 800d726:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
 800d72a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800d72e:	9303      	str	r3, [sp, #12]
 800d730:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800d732:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d734:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800d738:	9305      	str	r3, [sp, #20]
 800d73a:	2300      	movs	r3, #0
 800d73c:	9304      	str	r3, [sp, #16]
        const BASE temp1 = alpha * B[ldb * i + j];
 800d73e:	9c03      	ldr	r4, [sp, #12]
 800d740:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800d744:	ec53 2b19 	vmov	r2, r3, d9
 800d748:	9403      	str	r4, [sp, #12]
 800d74a:	f01a fbad 	bl	8027ea8 <__aeabi_dmul>
        for (k = 0; k < i; k++) {
 800d74e:	9b08      	ldr	r3, [sp, #32]
        const BASE temp1 = alpha * B[ldb * i + j];
 800d750:	ec41 0b18 	vmov	d8, r0, r1
        BASE temp2 = 0.0;
 800d754:	2400      	movs	r4, #0
 800d756:	2500      	movs	r5, #0
        for (k = 0; k < i; k++) {
 800d758:	b363      	cbz	r3, 800d7b4 <cblas_dsymm+0x4bc>
 800d75a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d75c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800d75e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800d760:	4619      	mov	r1, r3
 800d762:	9b04      	ldr	r3, [sp, #16]
 800d764:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
 800d768:	eb02 0ac3 	add.w	sl, r2, r3, lsl #3
          const BASE Aik = A[i * lda + k];
 800d76c:	e8f7 8902 	ldrd	r8, r9, [r7], #8
          C[k * ldc + j] += Aik * temp1;
 800d770:	ec51 0b18 	vmov	r0, r1, d8
 800d774:	4642      	mov	r2, r8
 800d776:	464b      	mov	r3, r9
 800d778:	f01a fb96 	bl	8027ea8 <__aeabi_dmul>
 800d77c:	4602      	mov	r2, r0
 800d77e:	460b      	mov	r3, r1
 800d780:	e9d6 0100 	ldrd	r0, r1, [r6]
 800d784:	f01a f9da 	bl	8027b3c <__adddf3>
 800d788:	e9c6 0100 	strd	r0, r1, [r6]
          temp2 += Aik * B[ldb * k + j];
 800d78c:	4640      	mov	r0, r8
 800d78e:	e9da 2300 	ldrd	r2, r3, [sl]
 800d792:	4649      	mov	r1, r9
 800d794:	f01a fb88 	bl	8027ea8 <__aeabi_dmul>
 800d798:	460b      	mov	r3, r1
 800d79a:	4602      	mov	r2, r0
 800d79c:	4629      	mov	r1, r5
 800d79e:	4620      	mov	r0, r4
 800d7a0:	f01a f9cc 	bl	8027b3c <__adddf3>
 800d7a4:	9b02      	ldr	r3, [sp, #8]
 800d7a6:	441e      	add	r6, r3
 800d7a8:	9b01      	ldr	r3, [sp, #4]
        for (k = 0; k < i; k++) {
 800d7aa:	45bb      	cmp	fp, r7
          temp2 += Aik * B[ldb * k + j];
 800d7ac:	4604      	mov	r4, r0
 800d7ae:	460d      	mov	r5, r1
        for (k = 0; k < i; k++) {
 800d7b0:	449a      	add	sl, r3
 800d7b2:	d1db      	bne.n	800d76c <cblas_dsymm+0x474>
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800d7b4:	e9db 2300 	ldrd	r2, r3, [fp]
 800d7b8:	ec51 0b18 	vmov	r0, r1, d8
 800d7bc:	f01a fb74 	bl	8027ea8 <__aeabi_dmul>
 800d7c0:	4622      	mov	r2, r4
 800d7c2:	462b      	mov	r3, r5
 800d7c4:	4604      	mov	r4, r0
 800d7c6:	460d      	mov	r5, r1
 800d7c8:	ec51 0b19 	vmov	r0, r1, d9
 800d7cc:	f01a fb6c 	bl	8027ea8 <__aeabi_dmul>
 800d7d0:	9e05      	ldr	r6, [sp, #20]
 800d7d2:	4602      	mov	r2, r0
 800d7d4:	460b      	mov	r3, r1
 800d7d6:	4620      	mov	r0, r4
 800d7d8:	4629      	mov	r1, r5
 800d7da:	e9d6 4500 	ldrd	r4, r5, [r6]
 800d7de:	f01a f9ad 	bl	8027b3c <__adddf3>
 800d7e2:	4622      	mov	r2, r4
 800d7e4:	462b      	mov	r3, r5
 800d7e6:	f01a f9a9 	bl	8027b3c <__adddf3>
      for (j = 0; j < n2; j++) {
 800d7ea:	9b04      	ldr	r3, [sp, #16]
 800d7ec:	9a03      	ldr	r2, [sp, #12]
 800d7ee:	3301      	adds	r3, #1
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800d7f0:	e8e6 0102 	strd	r0, r1, [r6], #8
      for (j = 0; j < n2; j++) {
 800d7f4:	9304      	str	r3, [sp, #16]
 800d7f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
        C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
 800d7f8:	9605      	str	r6, [sp, #20]
      for (j = 0; j < n2; j++) {
 800d7fa:	4293      	cmp	r3, r2
 800d7fc:	d19f      	bne.n	800d73e <cblas_dsymm+0x446>
    for (i = 0; i < n1; i++) {
 800d7fe:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800d800:	990e      	ldr	r1, [sp, #56]	; 0x38
 800d802:	9b08      	ldr	r3, [sp, #32]
 800d804:	440a      	add	r2, r1
 800d806:	9210      	str	r2, [sp, #64]	; 0x40
 800d808:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800d80a:	9901      	ldr	r1, [sp, #4]
 800d80c:	4493      	add	fp, r2
 800d80e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d810:	440a      	add	r2, r1
 800d812:	9209      	str	r2, [sp, #36]	; 0x24
 800d814:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800d816:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800d818:	440a      	add	r2, r1
 800d81a:	920d      	str	r2, [sp, #52]	; 0x34
 800d81c:	9911      	ldr	r1, [sp, #68]	; 0x44
 800d81e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800d820:	440a      	add	r2, r1
 800d822:	920b      	str	r2, [sp, #44]	; 0x2c
 800d824:	9a06      	ldr	r2, [sp, #24]
 800d826:	3301      	adds	r3, #1
 800d828:	429a      	cmp	r2, r3
 800d82a:	9308      	str	r3, [sp, #32]
 800d82c:	f47f af78 	bne.w	800d720 <cblas_dsymm+0x428>
 800d830:	e61c      	b.n	800d46c <cblas_dsymm+0x174>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800d832:	9b06      	ldr	r3, [sp, #24]
 800d834:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d836:	2b01      	cmp	r3, #1
 800d838:	bfb8      	it	lt
 800d83a:	2301      	movlt	r3, #1
 800d83c:	4293      	cmp	r3, r2
 800d83e:	f73f af25 	bgt.w	800d68c <cblas_dsymm+0x394>
 800d842:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d844:	4293      	cmp	r3, r2
 800d846:	bfcc      	ite	gt
 800d848:	200d      	movgt	r0, #13
 800d84a:	2008      	movle	r0, #8
 800d84c:	e593      	b.n	800d376 <cblas_dsymm+0x7e>
 800d84e:	9b07      	ldr	r3, [sp, #28]
 800d850:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d852:	2b01      	cmp	r3, #1
 800d854:	bfb8      	it	lt
 800d856:	2301      	movlt	r3, #1
 800d858:	429a      	cmp	r2, r3
 800d85a:	f6ff af24 	blt.w	800d6a6 <cblas_dsymm+0x3ae>
 800d85e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d860:	429a      	cmp	r2, r3
 800d862:	bfac      	ite	ge
 800d864:	2008      	movge	r0, #8
 800d866:	200d      	movlt	r0, #13
 800d868:	e585      	b.n	800d376 <cblas_dsymm+0x7e>
 800d86a:	3865      	subs	r0, #101	; 0x65
 800d86c:	2801      	cmp	r0, #1
 800d86e:	9b06      	ldr	r3, [sp, #24]
 800d870:	bf94      	ite	ls
 800d872:	2000      	movls	r0, #0
 800d874:	2001      	movhi	r0, #1
 800d876:	e564      	b.n	800d342 <cblas_dsymm+0x4a>
    for (i = 0; i < n1; i++) {
 800d878:	9a06      	ldr	r2, [sp, #24]
 800d87a:	2a00      	cmp	r2, #0
 800d87c:	f77f adf6 	ble.w	800d46c <cblas_dsymm+0x174>
 800d880:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d882:	9010      	str	r0, [sp, #64]	; 0x40
 800d884:	3301      	adds	r3, #1
 800d886:	00db      	lsls	r3, r3, #3
 800d888:	9315      	str	r3, [sp, #84]	; 0x54
 800d88a:	3b08      	subs	r3, #8
 800d88c:	9314      	str	r3, [sp, #80]	; 0x50
 800d88e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800d890:	9012      	str	r0, [sp, #72]	; 0x48
 800d892:	f103 0108 	add.w	r1, r3, #8
 800d896:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800d89a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d89c:	9108      	str	r1, [sp, #32]
 800d89e:	00da      	lsls	r2, r3, #3
 800d8a0:	9202      	str	r2, [sp, #8]
 800d8a2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800d8a4:	9313      	str	r3, [sp, #76]	; 0x4c
 800d8a6:	00d1      	lsls	r1, r2, #3
 800d8a8:	2301      	movs	r3, #1
 800d8aa:	9101      	str	r1, [sp, #4]
 800d8ac:	9211      	str	r2, [sp, #68]	; 0x44
 800d8ae:	9309      	str	r3, [sp, #36]	; 0x24
      for (j = 0; j < n2; j++) {
 800d8b0:	9b07      	ldr	r3, [sp, #28]
 800d8b2:	2b00      	cmp	r3, #0
 800d8b4:	f340 8098 	ble.w	800d9e8 <cblas_dsymm+0x6f0>
 800d8b8:	e9dd 1312 	ldrd	r1, r3, [sp, #72]	; 0x48
 800d8bc:	1a5a      	subs	r2, r3, r1
 800d8be:	e9dd 0310 	ldrd	r0, r3, [sp, #64]	; 0x40
 800d8c2:	1a1b      	subs	r3, r3, r0
 800d8c4:	00db      	lsls	r3, r3, #3
 800d8c6:	3b08      	subs	r3, #8
 800d8c8:	930d      	str	r3, [sp, #52]	; 0x34
 800d8ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800d8cc:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 800d8d0:	9304      	str	r3, [sp, #16]
 800d8d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d8d4:	00d2      	lsls	r2, r2, #3
 800d8d6:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800d8da:	3a08      	subs	r2, #8
 800d8dc:	9303      	str	r3, [sp, #12]
 800d8de:	2301      	movs	r3, #1
 800d8e0:	920b      	str	r2, [sp, #44]	; 0x2c
 800d8e2:	9305      	str	r3, [sp, #20]
        const BASE temp1 = alpha * B[ldb * i + j];
 800d8e4:	9c04      	ldr	r4, [sp, #16]
 800d8e6:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800d8ea:	ec53 2b19 	vmov	r2, r3, d9
 800d8ee:	9404      	str	r4, [sp, #16]
 800d8f0:	f01a fada 	bl	8027ea8 <__aeabi_dmul>
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800d8f4:	9b03      	ldr	r3, [sp, #12]
 800d8f6:	9a08      	ldr	r2, [sp, #32]
 800d8f8:	e9d3 4500 	ldrd	r4, r5, [r3]
 800d8fc:	e952 2302 	ldrd	r2, r3, [r2, #-8]
        const BASE temp1 = alpha * B[ldb * i + j];
 800d900:	4606      	mov	r6, r0
 800d902:	460f      	mov	r7, r1
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800d904:	f01a fad0 	bl	8027ea8 <__aeabi_dmul>
 800d908:	462b      	mov	r3, r5
 800d90a:	4622      	mov	r2, r4
 800d90c:	f01a f916 	bl	8027b3c <__adddf3>
 800d910:	9b03      	ldr	r3, [sp, #12]
 800d912:	4604      	mov	r4, r0
 800d914:	460d      	mov	r5, r1
 800d916:	4619      	mov	r1, r3
 800d918:	e8e1 4502 	strd	r4, r5, [r1], #8
        const BASE temp1 = alpha * B[ldb * i + j];
 800d91c:	ec47 6b18 	vmov	d8, r6, r7
        for (k = i + 1; k < n1; k++) {
 800d920:	9806      	ldr	r0, [sp, #24]
 800d922:	9e09      	ldr	r6, [sp, #36]	; 0x24
        C[i * ldc + j] += temp1 * A[i * lda + i];
 800d924:	9103      	str	r1, [sp, #12]
        for (k = i + 1; k < n1; k++) {
 800d926:	42b0      	cmp	r0, r6
 800d928:	f77f ad8e 	ble.w	800d448 <cblas_dsymm+0x150>
 800d92c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800d92e:	9b04      	ldr	r3, [sp, #16]
 800d930:	9f08      	ldr	r7, [sp, #32]
 800d932:	1846      	adds	r6, r0, r1
 800d934:	990d      	ldr	r1, [sp, #52]	; 0x34
        BASE temp2 = 0.0;
 800d936:	2400      	movs	r4, #0
 800d938:	2500      	movs	r5, #0
 800d93a:	eb01 0a03 	add.w	sl, r1, r3
          const BASE Aik = A[i * lda + k];
 800d93e:	e8f7 8902 	ldrd	r8, r9, [r7], #8
          C[k * ldc + j] += Aik * temp1;
 800d942:	ec51 0b18 	vmov	r0, r1, d8
 800d946:	4642      	mov	r2, r8
 800d948:	464b      	mov	r3, r9
 800d94a:	f01a faad 	bl	8027ea8 <__aeabi_dmul>
 800d94e:	4602      	mov	r2, r0
 800d950:	460b      	mov	r3, r1
 800d952:	e9d6 0100 	ldrd	r0, r1, [r6]
 800d956:	f01a f8f1 	bl	8027b3c <__adddf3>
 800d95a:	e9c6 0100 	strd	r0, r1, [r6]
          temp2 += Aik * B[ldb * k + j];
 800d95e:	4640      	mov	r0, r8
 800d960:	e9da 2300 	ldrd	r2, r3, [sl]
 800d964:	4649      	mov	r1, r9
 800d966:	f01a fa9f 	bl	8027ea8 <__aeabi_dmul>
 800d96a:	460b      	mov	r3, r1
 800d96c:	4602      	mov	r2, r0
 800d96e:	4629      	mov	r1, r5
 800d970:	4620      	mov	r0, r4
 800d972:	f01a f8e3 	bl	8027b3c <__adddf3>
 800d976:	9b02      	ldr	r3, [sp, #8]
 800d978:	441e      	add	r6, r3
 800d97a:	9b01      	ldr	r3, [sp, #4]
        for (k = i + 1; k < n1; k++) {
 800d97c:	45bb      	cmp	fp, r7
          temp2 += Aik * B[ldb * k + j];
 800d97e:	4604      	mov	r4, r0
 800d980:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 800d982:	449a      	add	sl, r3
 800d984:	d1db      	bne.n	800d93e <cblas_dsymm+0x646>
        C[i * ldc + j] += alpha * temp2;
 800d986:	4602      	mov	r2, r0
 800d988:	460b      	mov	r3, r1
 800d98a:	ec51 0b19 	vmov	r0, r1, d9
 800d98e:	f01a fa8b 	bl	8027ea8 <__aeabi_dmul>
 800d992:	9c03      	ldr	r4, [sp, #12]
 800d994:	4602      	mov	r2, r0
 800d996:	460b      	mov	r3, r1
 800d998:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 800d99c:	f01a f8ce 	bl	8027b3c <__adddf3>
      for (j = 0; j < n2; j++) {
 800d9a0:	9b07      	ldr	r3, [sp, #28]
 800d9a2:	9a05      	ldr	r2, [sp, #20]
 800d9a4:	4293      	cmp	r3, r2
        C[i * ldc + j] += alpha * temp2;
 800d9a6:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (j = 0; j < n2; j++) {
 800d9aa:	dd03      	ble.n	800d9b4 <cblas_dsymm+0x6bc>
 800d9ac:	9b05      	ldr	r3, [sp, #20]
 800d9ae:	3301      	adds	r3, #1
 800d9b0:	9305      	str	r3, [sp, #20]
 800d9b2:	e797      	b.n	800d8e4 <cblas_dsymm+0x5ec>
    for (i = 0; i < n1; i++) {
 800d9b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800d9b6:	9a15      	ldr	r2, [sp, #84]	; 0x54
 800d9b8:	3301      	adds	r3, #1
 800d9ba:	9309      	str	r3, [sp, #36]	; 0x24
 800d9bc:	9b08      	ldr	r3, [sp, #32]
 800d9be:	4413      	add	r3, r2
 800d9c0:	9308      	str	r3, [sp, #32]
 800d9c2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 800d9c4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 800d9c6:	4611      	mov	r1, r2
 800d9c8:	449b      	add	fp, r3
 800d9ca:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800d9cc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800d9ce:	441a      	add	r2, r3
 800d9d0:	9212      	str	r2, [sp, #72]	; 0x48
 800d9d2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 800d9d4:	4419      	add	r1, r3
 800d9d6:	9113      	str	r1, [sp, #76]	; 0x4c
 800d9d8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800d9da:	4611      	mov	r1, r2
 800d9dc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800d9de:	4419      	add	r1, r3
 800d9e0:	441a      	add	r2, r3
 800d9e2:	9111      	str	r1, [sp, #68]	; 0x44
 800d9e4:	9210      	str	r2, [sp, #64]	; 0x40
 800d9e6:	e763      	b.n	800d8b0 <cblas_dsymm+0x5b8>
 800d9e8:	9a08      	ldr	r2, [sp, #32]
 800d9ea:	9915      	ldr	r1, [sp, #84]	; 0x54
 800d9ec:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800d9ee:	440a      	add	r2, r1
 800d9f0:	9208      	str	r2, [sp, #32]
 800d9f2:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800d9f4:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800d9f6:	4608      	mov	r0, r1
 800d9f8:	4493      	add	fp, r2
 800d9fa:	9912      	ldr	r1, [sp, #72]	; 0x48
 800d9fc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800d9fe:	4411      	add	r1, r2
 800da00:	9112      	str	r1, [sp, #72]	; 0x48
 800da02:	9911      	ldr	r1, [sp, #68]	; 0x44
 800da04:	4410      	add	r0, r2
 800da06:	9013      	str	r0, [sp, #76]	; 0x4c
 800da08:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800da0a:	4608      	mov	r0, r1
 800da0c:	9910      	ldr	r1, [sp, #64]	; 0x40
 800da0e:	4410      	add	r0, r2
 800da10:	4411      	add	r1, r2
 800da12:	9a06      	ldr	r2, [sp, #24]
 800da14:	9011      	str	r0, [sp, #68]	; 0x44
 800da16:	4623      	mov	r3, r4
 800da18:	3301      	adds	r3, #1
 800da1a:	42a2      	cmp	r2, r4
 800da1c:	9110      	str	r1, [sp, #64]	; 0x40
 800da1e:	9309      	str	r3, [sp, #36]	; 0x24
 800da20:	f73f af46 	bgt.w	800d8b0 <cblas_dsymm+0x5b8>
 800da24:	e522      	b.n	800d46c <cblas_dsymm+0x174>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800da26:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800da28:	2b00      	cmp	r3, #0
 800da2a:	bfcc      	ite	gt
 800da2c:	2005      	movgt	r0, #5
 800da2e:	200d      	movle	r0, #13
 800da30:	e4a1      	b.n	800d376 <cblas_dsymm+0x7e>
    for (i = 0; i < n1; i++) {
 800da32:	9b06      	ldr	r3, [sp, #24]
 800da34:	2b00      	cmp	r3, #0
 800da36:	f77f ad19 	ble.w	800d46c <cblas_dsymm+0x174>
 800da3a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800da3c:	900d      	str	r0, [sp, #52]	; 0x34
 800da3e:	1c53      	adds	r3, r2, #1
 800da40:	00db      	lsls	r3, r3, #3
 800da42:	9308      	str	r3, [sp, #32]
 800da44:	00d3      	lsls	r3, r2, #3
 800da46:	9305      	str	r3, [sp, #20]
 800da48:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800da4a:	9009      	str	r0, [sp, #36]	; 0x24
 800da4c:	00db      	lsls	r3, r3, #3
 800da4e:	9312      	str	r3, [sp, #72]	; 0x48
 800da50:	9b07      	ldr	r3, [sp, #28]
 800da52:	9010      	str	r0, [sp, #64]	; 0x40
 800da54:	00da      	lsls	r2, r3, #3
 800da56:	9214      	str	r2, [sp, #80]	; 0x50
 800da58:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800da5a:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 800da5e:	9204      	str	r2, [sp, #16]
 800da60:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800da62:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800da66:	9313      	str	r3, [sp, #76]	; 0x4c
      for (j = 0; j < n2; j++) {
 800da68:	9b07      	ldr	r3, [sp, #28]
 800da6a:	2b00      	cmp	r3, #0
 800da6c:	f340 8087 	ble.w	800db7e <cblas_dsymm+0x886>
 800da70:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800da72:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800da74:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800da78:	9303      	str	r3, [sp, #12]
 800da7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800da7c:	00da      	lsls	r2, r3, #3
 800da7e:	9211      	str	r2, [sp, #68]	; 0x44
 800da80:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800da82:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800da86:	9301      	str	r3, [sp, #4]
 800da88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800da8a:	3308      	adds	r3, #8
 800da8c:	9302      	str	r3, [sp, #8]
 800da8e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800da90:	469b      	mov	fp, r3
        const BASE temp1 = alpha * B[ldb * i + j];
 800da92:	9c03      	ldr	r4, [sp, #12]
 800da94:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800da98:	ec53 2b19 	vmov	r2, r3, d9
 800da9c:	9403      	str	r4, [sp, #12]
 800da9e:	f01a fa03 	bl	8027ea8 <__aeabi_dmul>
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800daa2:	9a01      	ldr	r2, [sp, #4]
 800daa4:	9b02      	ldr	r3, [sp, #8]
 800daa6:	e9d2 4500 	ldrd	r4, r5, [r2]
 800daaa:	e953 2302 	ldrd	r2, r3, [r3, #-8]
        const BASE temp1 = alpha * B[ldb * i + j];
 800daae:	4606      	mov	r6, r0
 800dab0:	460f      	mov	r7, r1
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800dab2:	f01a f9f9 	bl	8027ea8 <__aeabi_dmul>
 800dab6:	4622      	mov	r2, r4
 800dab8:	462b      	mov	r3, r5
 800daba:	f01a f83f 	bl	8027b3c <__adddf3>
 800dabe:	9a01      	ldr	r2, [sp, #4]
        for (k = j + 1; k < n2; k++) {
 800dac0:	9b03      	ldr	r3, [sp, #12]
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800dac2:	460d      	mov	r5, r1
 800dac4:	4604      	mov	r4, r0
 800dac6:	4611      	mov	r1, r2
 800dac8:	e8e1 4502 	strd	r4, r5, [r1], #8
        for (k = j + 1; k < n2; k++) {
 800dacc:	9a04      	ldr	r2, [sp, #16]
        C[i * ldc + j] += temp1 * A[j * lda + j];
 800dace:	9101      	str	r1, [sp, #4]
        for (k = j + 1; k < n2; k++) {
 800dad0:	429a      	cmp	r2, r3
        const BASE temp1 = alpha * B[ldb * i + j];
 800dad2:	ec47 6b1a 	vmov	d10, r6, r7
        for (k = j + 1; k < n2; k++) {
 800dad6:	d040      	beq.n	800db5a <cblas_dsymm+0x862>
 800dad8:	9c02      	ldr	r4, [sp, #8]
        BASE temp2 = 0.0;
 800dada:	f04f 0800 	mov.w	r8, #0
 800dade:	f04f 0900 	mov.w	r9, #0
        for (k = j + 1; k < n2; k++) {
 800dae2:	469a      	mov	sl, r3
 800dae4:	460d      	mov	r5, r1
          const BASE Ajk = A[j * lda + k];
 800dae6:	e8f4 6702 	ldrd	r6, r7, [r4], #8
          C[i * ldc + k] += temp1 * Ajk;
 800daea:	ed95 7b00 	vldr	d7, [r5]
 800daee:	4632      	mov	r2, r6
 800daf0:	463b      	mov	r3, r7
 800daf2:	ec51 0b1a 	vmov	r0, r1, d10
 800daf6:	eeb0 8a47 	vmov.f32	s16, s14
 800dafa:	eef0 8a67 	vmov.f32	s17, s15
 800dafe:	f01a f9d3 	bl	8027ea8 <__aeabi_dmul>
 800db02:	ec53 2b18 	vmov	r2, r3, d8
 800db06:	f01a f819 	bl	8027b3c <__adddf3>
 800db0a:	e8e5 0102 	strd	r0, r1, [r5], #8
          temp2 += B[ldb * i + k] * Ajk;
 800db0e:	4632      	mov	r2, r6
 800db10:	463b      	mov	r3, r7
 800db12:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 800db16:	f01a f9c7 	bl	8027ea8 <__aeabi_dmul>
 800db1a:	4602      	mov	r2, r0
 800db1c:	460b      	mov	r3, r1
 800db1e:	4640      	mov	r0, r8
 800db20:	4649      	mov	r1, r9
 800db22:	f01a f80b 	bl	8027b3c <__adddf3>
        for (k = j + 1; k < n2; k++) {
 800db26:	455c      	cmp	r4, fp
          temp2 += B[ldb * i + k] * Ajk;
 800db28:	4680      	mov	r8, r0
 800db2a:	4689      	mov	r9, r1
        for (k = j + 1; k < n2; k++) {
 800db2c:	d1db      	bne.n	800dae6 <cblas_dsymm+0x7ee>
        C[i * ldc + j] += alpha * temp2;
 800db2e:	4602      	mov	r2, r0
 800db30:	460b      	mov	r3, r1
 800db32:	ec51 0b19 	vmov	r0, r1, d9
 800db36:	f01a f9b7 	bl	8027ea8 <__aeabi_dmul>
 800db3a:	9c01      	ldr	r4, [sp, #4]
 800db3c:	4602      	mov	r2, r0
 800db3e:	460b      	mov	r3, r1
 800db40:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 800db44:	f019 fffa 	bl	8027b3c <__adddf3>
 800db48:	9b02      	ldr	r3, [sp, #8]
 800db4a:	9a08      	ldr	r2, [sp, #32]
 800db4c:	4413      	add	r3, r2
 800db4e:	9302      	str	r3, [sp, #8]
 800db50:	9b05      	ldr	r3, [sp, #20]
 800db52:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (j = 0; j < n2; j++) {
 800db56:	449b      	add	fp, r3
 800db58:	e79b      	b.n	800da92 <cblas_dsymm+0x79a>
        C[i * ldc + j] += alpha * temp2;
 800db5a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 800db5c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800db5e:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 800db60:	4413      	add	r3, r2
 800db62:	461e      	mov	r6, r3
 800db64:	2200      	movs	r2, #0
 800db66:	2300      	movs	r3, #0
 800db68:	ec51 0b19 	vmov	r0, r1, d9
 800db6c:	f01a f99c 	bl	8027ea8 <__aeabi_dmul>
 800db70:	4622      	mov	r2, r4
 800db72:	462b      	mov	r3, r5
 800db74:	f019 ffe2 	bl	8027b3c <__adddf3>
 800db78:	443e      	add	r6, r7
 800db7a:	e946 0102 	strd	r0, r1, [r6, #-8]
    for (i = 0; i < n1; i++) {
 800db7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800db80:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800db82:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800db84:	440a      	add	r2, r1
 800db86:	9209      	str	r2, [sp, #36]	; 0x24
 800db88:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
 800db8c:	440a      	add	r2, r1
 800db8e:	920d      	str	r2, [sp, #52]	; 0x34
 800db90:	9912      	ldr	r1, [sp, #72]	; 0x48
 800db92:	9a04      	ldr	r2, [sp, #16]
 800db94:	440a      	add	r2, r1
 800db96:	9204      	str	r2, [sp, #16]
 800db98:	9a06      	ldr	r2, [sp, #24]
 800db9a:	3301      	adds	r3, #1
 800db9c:	429a      	cmp	r2, r3
 800db9e:	9310      	str	r3, [sp, #64]	; 0x40
 800dba0:	f47f af62 	bne.w	800da68 <cblas_dsymm+0x770>
 800dba4:	e462      	b.n	800d46c <cblas_dsymm+0x174>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 800dba6:	9b07      	ldr	r3, [sp, #28]
 800dba8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800dbaa:	2b01      	cmp	r3, #1
 800dbac:	bfb8      	it	lt
 800dbae:	2301      	movlt	r3, #1
 800dbb0:	429a      	cmp	r2, r3
 800dbb2:	f6ff ad78 	blt.w	800d6a6 <cblas_dsymm+0x3ae>
 800dbb6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800dbb8:	429a      	cmp	r2, r3
 800dbba:	bfac      	ite	ge
 800dbbc:	2005      	movge	r0, #5
 800dbbe:	200d      	movlt	r0, #13
 800dbc0:	f7ff bbd9 	b.w	800d376 <cblas_dsymm+0x7e>

0800dbc4 <cblas_dsymv>:
void
cblas_dsymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const double alpha, const double *A, const int lda,
             const double *X, const int incX, const double beta, double *Y,
             const int incY)
{
 800dbc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dbc8:	ed2d 8b04 	vpush	{d8-d9}
 800dbcc:	eeb0 9a40 	vmov.f32	s18, s0
 800dbd0:	eef0 9a60 	vmov.f32	s19, s1
 800dbd4:	b08f      	sub	sp, #60	; 0x3c
 800dbd6:	4688      	mov	r8, r1
 800dbd8:	9308      	str	r3, [sp, #32]
 800dbda:	e9dd a31c 	ldrd	sl, r3, [sp, #112]	; 0x70
 800dbde:	9304      	str	r3, [sp, #16]
 800dbe0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800dbe2:	9303      	str	r3, [sp, #12]
 800dbe4:	3979      	subs	r1, #121	; 0x79
 800dbe6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800dbe8:	9305      	str	r3, [sp, #20]
 800dbea:	2901      	cmp	r1, #1
 800dbec:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800dbee:	9300      	str	r3, [sp, #0]
 800dbf0:	ec57 6b11 	vmov	r6, r7, d1
 800dbf4:	4681      	mov	r9, r0
 800dbf6:	4693      	mov	fp, r2
 800dbf8:	f240 80c9 	bls.w	800dd8e <cblas_dsymv+0x1ca>
 800dbfc:	2002      	movs	r0, #2
 800dbfe:	f1bb 0f00 	cmp.w	fp, #0
 800dc02:	f2c0 80b6 	blt.w	800dd72 <cblas_dsymv+0x1ae>
 800dc06:	465b      	mov	r3, fp
 800dc08:	2b01      	cmp	r3, #1
 800dc0a:	bfb8      	it	lt
 800dc0c:	2301      	movlt	r3, #1
 800dc0e:	4553      	cmp	r3, sl
 800dc10:	f340 809d 	ble.w	800dd4e <cblas_dsymv+0x18a>
 800dc14:	9b03      	ldr	r3, [sp, #12]
 800dc16:	2b00      	cmp	r3, #0
 800dc18:	f040 80a5 	bne.w	800dd66 <cblas_dsymv+0x1a2>
 800dc1c:	9b00      	ldr	r3, [sp, #0]
 800dc1e:	2b00      	cmp	r3, #0
 800dc20:	bf0c      	ite	eq
 800dc22:	200b      	moveq	r0, #11
 800dc24:	2008      	movne	r0, #8
 800dc26:	4a5d      	ldr	r2, [pc, #372]	; (800dd9c <cblas_dsymv+0x1d8>)
 800dc28:	495d      	ldr	r1, [pc, #372]	; (800dda0 <cblas_dsymv+0x1dc>)
 800dc2a:	f019 ff0d 	bl	8027a48 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800dc2e:	2200      	movs	r2, #0
 800dc30:	ec51 0b19 	vmov	r0, r1, d9
 800dc34:	2300      	movs	r3, #0
 800dc36:	f01a fb9f 	bl	8028378 <__aeabi_dcmpeq>
 800dc3a:	2200      	movs	r2, #0
 800dc3c:	2800      	cmp	r0, #0
 800dc3e:	d055      	beq.n	800dcec <cblas_dsymv+0x128>
 800dc40:	4b58      	ldr	r3, [pc, #352]	; (800dda4 <cblas_dsymv+0x1e0>)
 800dc42:	4630      	mov	r0, r6
 800dc44:	4639      	mov	r1, r7
 800dc46:	f01a fb97 	bl	8028378 <__aeabi_dcmpeq>
 800dc4a:	2800      	cmp	r0, #0
 800dc4c:	d149      	bne.n	800dce2 <cblas_dsymv+0x11e>
  if (beta == 0.0) {
 800dc4e:	2200      	movs	r2, #0
 800dc50:	2300      	movs	r3, #0
 800dc52:	4630      	mov	r0, r6
 800dc54:	4639      	mov	r1, r7
 800dc56:	f01a fb8f 	bl	8028378 <__aeabi_dcmpeq>
 800dc5a:	2800      	cmp	r0, #0
 800dc5c:	d055      	beq.n	800dd0a <cblas_dsymv+0x146>
    INDEX iy = OFFSET(N, incY);
 800dc5e:	9a00      	ldr	r2, [sp, #0]
 800dc60:	2a00      	cmp	r2, #0
 800dc62:	f340 816b 	ble.w	800df3c <cblas_dsymv+0x378>
 800dc66:	2300      	movs	r3, #0
    for (i = 0; i < N; i++) {
 800dc68:	f1bb 0f00 	cmp.w	fp, #0
 800dc6c:	dd0d      	ble.n	800dc8a <cblas_dsymv+0xc6>
 800dc6e:	9a05      	ldr	r2, [sp, #20]
 800dc70:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800dc74:	9a00      	ldr	r2, [sp, #0]
      Y[iy] = 0.0;
 800dc76:	2400      	movs	r4, #0
 800dc78:	00d1      	lsls	r1, r2, #3
 800dc7a:	2500      	movs	r5, #0
    for (i = 0; i < N; i++) {
 800dc7c:	2200      	movs	r2, #0
 800dc7e:	3201      	adds	r2, #1
 800dc80:	4593      	cmp	fp, r2
      Y[iy] = 0.0;
 800dc82:	e9c3 4500 	strd	r4, r5, [r3]
    for (i = 0; i < N; i++) {
 800dc86:	440b      	add	r3, r1
 800dc88:	d1f9      	bne.n	800dc7e <cblas_dsymv+0xba>
  if (alpha == 0.0)
 800dc8a:	ec51 0b19 	vmov	r0, r1, d9
 800dc8e:	2200      	movs	r2, #0
 800dc90:	2300      	movs	r3, #0
 800dc92:	f01a fb71 	bl	8028378 <__aeabi_dcmpeq>
 800dc96:	bb20      	cbnz	r0, 800dce2 <cblas_dsymv+0x11e>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800dc98:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 800dc9c:	f000 8146 	beq.w	800df2c <cblas_dsymv+0x368>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800dca0:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 800dca4:	f000 8082 	beq.w	800ddac <cblas_dsymv+0x1e8>
    BLAS_ERROR("unrecognized operation");
 800dca8:	4a3f      	ldr	r2, [pc, #252]	; (800dda8 <cblas_dsymv+0x1e4>)
 800dcaa:	493d      	ldr	r1, [pc, #244]	; (800dda0 <cblas_dsymv+0x1dc>)
 800dcac:	2000      	movs	r0, #0
#define BASE double
#include "source_symv.h"
#undef BASE
}
 800dcae:	b00f      	add	sp, #60	; 0x3c
 800dcb0:	ecbd 8b04 	vpop	{d8-d9}
 800dcb4:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dcb8:	f019 bec6 	b.w	8027a48 <cblas_xerbla>
      Y[iy] += alpha * temp2;
 800dcbc:	9b00      	ldr	r3, [sp, #0]
 800dcbe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800dcc0:	fb03 2606 	mla	r6, r3, r6, r2
      Y[iy] += alpha * temp2;
 800dcc4:	2200      	movs	r2, #0
 800dcc6:	2300      	movs	r3, #0
 800dcc8:	ec51 0b19 	vmov	r0, r1, d9
 800dccc:	f01a f8ec 	bl	8027ea8 <__aeabi_dmul>
 800dcd0:	4622      	mov	r2, r4
 800dcd2:	462b      	mov	r3, r5
 800dcd4:	9f05      	ldr	r7, [sp, #20]
 800dcd6:	f019 ff31 	bl	8027b3c <__adddf3>
 800dcda:	eb07 06c6 	add.w	r6, r7, r6, lsl #3
 800dcde:	e9c6 0100 	strd	r0, r1, [r6]
 800dce2:	b00f      	add	sp, #60	; 0x3c
 800dce4:	ecbd 8b04 	vpop	{d8-d9}
 800dce8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (beta == 0.0) {
 800dcec:	2300      	movs	r3, #0
 800dcee:	4630      	mov	r0, r6
 800dcf0:	4639      	mov	r1, r7
 800dcf2:	f01a fb41 	bl	8028378 <__aeabi_dcmpeq>
 800dcf6:	2800      	cmp	r0, #0
 800dcf8:	d1b1      	bne.n	800dc5e <cblas_dsymv+0x9a>
  } else if (beta != 1.0) {
 800dcfa:	4b2a      	ldr	r3, [pc, #168]	; (800dda4 <cblas_dsymv+0x1e0>)
 800dcfc:	2200      	movs	r2, #0
 800dcfe:	4630      	mov	r0, r6
 800dd00:	4639      	mov	r1, r7
 800dd02:	f01a fb39 	bl	8028378 <__aeabi_dcmpeq>
 800dd06:	2800      	cmp	r0, #0
 800dd08:	d1c6      	bne.n	800dc98 <cblas_dsymv+0xd4>
    INDEX iy = OFFSET(N, incY);
 800dd0a:	9b00      	ldr	r3, [sp, #0]
 800dd0c:	2b00      	cmp	r3, #0
 800dd0e:	f340 8108 	ble.w	800df22 <cblas_dsymv+0x35e>
 800dd12:	2400      	movs	r4, #0
    for (i = 0; i < N; i++) {
 800dd14:	f1bb 0f00 	cmp.w	fp, #0
 800dd18:	ddb7      	ble.n	800dc8a <cblas_dsymv+0xc6>
 800dd1a:	9b05      	ldr	r3, [sp, #20]
 800dd1c:	f8cd a004 	str.w	sl, [sp, #4]
 800dd20:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 800dd24:	9b00      	ldr	r3, [sp, #0]
 800dd26:	00db      	lsls	r3, r3, #3
 800dd28:	46c2      	mov	sl, r8
 800dd2a:	2500      	movs	r5, #0
 800dd2c:	4698      	mov	r8, r3
      Y[iy] *= beta;
 800dd2e:	e9d4 0100 	ldrd	r0, r1, [r4]
 800dd32:	4632      	mov	r2, r6
 800dd34:	463b      	mov	r3, r7
 800dd36:	f01a f8b7 	bl	8027ea8 <__aeabi_dmul>
    for (i = 0; i < N; i++) {
 800dd3a:	3501      	adds	r5, #1
 800dd3c:	45ab      	cmp	fp, r5
      Y[iy] *= beta;
 800dd3e:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 800dd42:	4444      	add	r4, r8
 800dd44:	d1f3      	bne.n	800dd2e <cblas_dsymv+0x16a>
 800dd46:	46d0      	mov	r8, sl
 800dd48:	f8dd a004 	ldr.w	sl, [sp, #4]
 800dd4c:	e79d      	b.n	800dc8a <cblas_dsymv+0xc6>
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 800dd4e:	9b03      	ldr	r3, [sp, #12]
 800dd50:	2b00      	cmp	r3, #0
 800dd52:	f43f af63 	beq.w	800dc1c <cblas_dsymv+0x58>
 800dd56:	9b00      	ldr	r3, [sp, #0]
 800dd58:	2b00      	cmp	r3, #0
 800dd5a:	f000 81a3 	beq.w	800e0a4 <cblas_dsymv+0x4e0>
 800dd5e:	2800      	cmp	r0, #0
 800dd60:	f43f af65 	beq.w	800dc2e <cblas_dsymv+0x6a>
 800dd64:	e75f      	b.n	800dc26 <cblas_dsymv+0x62>
 800dd66:	9b00      	ldr	r3, [sp, #0]
 800dd68:	2b00      	cmp	r3, #0
 800dd6a:	bf0c      	ite	eq
 800dd6c:	200b      	moveq	r0, #11
 800dd6e:	2006      	movne	r0, #6
 800dd70:	e759      	b.n	800dc26 <cblas_dsymv+0x62>
 800dd72:	f1ba 0f00 	cmp.w	sl, #0
 800dd76:	f77f af4d 	ble.w	800dc14 <cblas_dsymv+0x50>
 800dd7a:	9b03      	ldr	r3, [sp, #12]
 800dd7c:	2b00      	cmp	r3, #0
 800dd7e:	f43f af4d 	beq.w	800dc1c <cblas_dsymv+0x58>
 800dd82:	9b00      	ldr	r3, [sp, #0]
 800dd84:	2b00      	cmp	r3, #0
 800dd86:	bf0c      	ite	eq
 800dd88:	200b      	moveq	r0, #11
 800dd8a:	2003      	movne	r0, #3
 800dd8c:	e74b      	b.n	800dc26 <cblas_dsymv+0x62>
 800dd8e:	3865      	subs	r0, #101	; 0x65
 800dd90:	2801      	cmp	r0, #1
 800dd92:	bf94      	ite	ls
 800dd94:	2000      	movls	r0, #0
 800dd96:	2001      	movhi	r0, #1
 800dd98:	e731      	b.n	800dbfe <cblas_dsymv+0x3a>
 800dd9a:	bf00      	nop
 800dd9c:	08030378 	.word	0x08030378
 800dda0:	0803061c 	.word	0x0803061c
 800dda4:	3ff00000 	.word	0x3ff00000
 800dda8:	080305a8 	.word	0x080305a8
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800ddac:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 800ddb0:	f000 80c9 	beq.w	800df46 <cblas_dsymv+0x382>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800ddb4:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 800ddb8:	f47f af76 	bne.w	800dca8 <cblas_dsymv+0xe4>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800ddbc:	9b03      	ldr	r3, [sp, #12]
 800ddbe:	2b00      	cmp	r3, #0
 800ddc0:	f340 8172 	ble.w	800e0a8 <cblas_dsymv+0x4e4>
 800ddc4:	f10b 33ff 	add.w	r3, fp, #4294967295
 800ddc8:	9301      	str	r3, [sp, #4]
 800ddca:	2300      	movs	r3, #0
 800ddcc:	9901      	ldr	r1, [sp, #4]
 800ddce:	9a03      	ldr	r2, [sp, #12]
 800ddd0:	fb01 3002 	mla	r0, r1, r2, r3
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 800ddd4:	9a00      	ldr	r2, [sp, #0]
 800ddd6:	2a00      	cmp	r2, #0
 800ddd8:	bfdc      	itt	le
 800ddda:	4252      	negle	r2, r2
 800dddc:	434a      	mulle	r2, r1
 800ddde:	e9dd 6100 	ldrd	r6, r1, [sp]
 800dde2:	bfc8      	it	gt
 800dde4:	2200      	movgt	r2, #0
 800dde6:	fb01 2406 	mla	r4, r1, r6, r2
    for (i = N; i > 0 && i--;) {
 800ddea:	f1bb 0f00 	cmp.w	fp, #0
    INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 800ddee:	940c      	str	r4, [sp, #48]	; 0x30
    for (i = N; i > 0 && i--;) {
 800ddf0:	f77f af77 	ble.w	800dce2 <cblas_dsymv+0x11e>
 800ddf4:	9d04      	ldr	r5, [sp, #16]
 800ddf6:	9f03      	ldr	r7, [sp, #12]
 800ddf8:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 800ddfc:	9d04      	ldr	r5, [sp, #16]
 800ddfe:	9002      	str	r0, [sp, #8]
 800de00:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 800de04:	460c      	mov	r4, r1
 800de06:	9507      	str	r5, [sp, #28]
 800de08:	fb01 f10a 	mul.w	r1, r1, sl
 800de0c:	9d08      	ldr	r5, [sp, #32]
 800de0e:	9805      	ldr	r0, [sp, #20]
 800de10:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800de12:	eb04 0e01 	add.w	lr, r4, r1
 800de16:	eb05 0bce 	add.w	fp, r5, lr, lsl #3
 800de1a:	ebc7 7447 	rsb	r4, r7, r7, lsl #29
 800de1e:	eb05 05c1 	add.w	r5, r5, r1, lsl #3
 800de22:	ebc6 7646 	rsb	r6, r6, r6, lsl #29
 800de26:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 800de2a:	9504      	str	r5, [sp, #16]
 800de2c:	00e5      	lsls	r5, r4, #3
 800de2e:	ea6f 070a 	mvn.w	r7, sl
 800de32:	9206      	str	r2, [sp, #24]
 800de34:	9509      	str	r5, [sp, #36]	; 0x24
 800de36:	9a03      	ldr	r2, [sp, #12]
 800de38:	9c01      	ldr	r4, [sp, #4]
 800de3a:	940d      	str	r4, [sp, #52]	; 0x34
 800de3c:	00f5      	lsls	r5, r6, #3
 800de3e:	9e00      	ldr	r6, [sp, #0]
 800de40:	950a      	str	r5, [sp, #40]	; 0x28
 800de42:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 800de46:	00fd      	lsls	r5, r7, #3
 800de48:	ebca 7c4a 	rsb	ip, sl, sl, lsl #29
 800de4c:	00d2      	lsls	r2, r2, #3
 800de4e:	9508      	str	r5, [sp, #32]
 800de50:	9303      	str	r3, [sp, #12]
 800de52:	ea4f 05cc 	mov.w	r5, ip, lsl #3
 800de56:	00f3      	lsls	r3, r6, #3
 800de58:	950b      	str	r5, [sp, #44]	; 0x2c
 800de5a:	4698      	mov	r8, r3
 800de5c:	4691      	mov	r9, r2
      BASE temp1 = alpha * X[ix];
 800de5e:	9b02      	ldr	r3, [sp, #8]
 800de60:	ec51 0b19 	vmov	r0, r1, d9
 800de64:	e9d3 2300 	ldrd	r2, r3, [r3]
 800de68:	f01a f81e 	bl	8027ea8 <__aeabi_dmul>
      Y[iy] += temp1 * A[lda * i + i];
 800de6c:	e9db 2300 	ldrd	r2, r3, [fp]
      BASE temp1 = alpha * X[ix];
 800de70:	4604      	mov	r4, r0
 800de72:	460d      	mov	r5, r1
      Y[iy] += temp1 * A[lda * i + i];
 800de74:	f01a f818 	bl	8027ea8 <__aeabi_dmul>
 800de78:	9e03      	ldr	r6, [sp, #12]
 800de7a:	e9d6 2300 	ldrd	r2, r3, [r6]
 800de7e:	f019 fe5d 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 800de82:	9b01      	ldr	r3, [sp, #4]
      BASE temp1 = alpha * X[ix];
 800de84:	ec45 4b18 	vmov	d8, r4, r5
      Y[iy] += temp1 * A[lda * i + i];
 800de88:	4604      	mov	r4, r0
 800de8a:	460d      	mov	r5, r1
 800de8c:	e9c6 4500 	strd	r4, r5, [r6]
      for (j = j_min; j < j_max; j++) {
 800de90:	2b00      	cmp	r3, #0
 800de92:	f000 8101 	beq.w	800e098 <cblas_dsymv+0x4d4>
 800de96:	f8dd a01c 	ldr.w	sl, [sp, #28]
 800de9a:	9f04      	ldr	r7, [sp, #16]
 800de9c:	9e06      	ldr	r6, [sp, #24]
      BASE temp2 = 0.0;
 800de9e:	2400      	movs	r4, #0
 800dea0:	2500      	movs	r5, #0
        Y[jy] += temp1 * A[lda * i + j];
 800dea2:	e9d7 0100 	ldrd	r0, r1, [r7]
 800dea6:	ec53 2b18 	vmov	r2, r3, d8
 800deaa:	f019 fffd 	bl	8027ea8 <__aeabi_dmul>
 800deae:	4602      	mov	r2, r0
 800deb0:	460b      	mov	r3, r1
 800deb2:	e9d6 0100 	ldrd	r0, r1, [r6]
 800deb6:	f019 fe41 	bl	8027b3c <__adddf3>
 800deba:	e9c6 0100 	strd	r0, r1, [r6]
        temp2 += X[jx] * A[lda * i + j];
 800debe:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 800dec2:	e9da 0100 	ldrd	r0, r1, [sl]
 800dec6:	f019 ffef 	bl	8027ea8 <__aeabi_dmul>
 800deca:	4602      	mov	r2, r0
 800decc:	460b      	mov	r3, r1
 800dece:	4620      	mov	r0, r4
 800ded0:	4629      	mov	r1, r5
 800ded2:	f019 fe33 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 800ded6:	455f      	cmp	r7, fp
 800ded8:	4446      	add	r6, r8
        temp2 += X[jx] * A[lda * i + j];
 800deda:	4604      	mov	r4, r0
 800dedc:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 800dede:	44ca      	add	sl, r9
 800dee0:	d1df      	bne.n	800dea2 <cblas_dsymv+0x2de>
      Y[iy] += alpha * temp2;
 800dee2:	4602      	mov	r2, r0
 800dee4:	460b      	mov	r3, r1
 800dee6:	ec51 0b19 	vmov	r0, r1, d9
 800deea:	f019 ffdd 	bl	8027ea8 <__aeabi_dmul>
 800deee:	9c03      	ldr	r4, [sp, #12]
 800def0:	4602      	mov	r2, r0
 800def2:	460b      	mov	r3, r1
 800def4:	e9d4 0100 	ldrd	r0, r1, [r4]
 800def8:	f019 fe20 	bl	8027b3c <__adddf3>
 800defc:	9b02      	ldr	r3, [sp, #8]
 800defe:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800df00:	4413      	add	r3, r2
 800df02:	9302      	str	r3, [sp, #8]
 800df04:	9b08      	ldr	r3, [sp, #32]
 800df06:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800df08:	449b      	add	fp, r3
 800df0a:	9b04      	ldr	r3, [sp, #16]
 800df0c:	4413      	add	r3, r2
 800df0e:	9304      	str	r3, [sp, #16]
 800df10:	9b01      	ldr	r3, [sp, #4]
 800df12:	3b01      	subs	r3, #1
 800df14:	9301      	str	r3, [sp, #4]
 800df16:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800df18:	18e3      	adds	r3, r4, r3
 800df1a:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 800df1e:	9303      	str	r3, [sp, #12]
 800df20:	e79d      	b.n	800de5e <cblas_dsymv+0x29a>
    INDEX iy = OFFSET(N, incY);
 800df22:	f1cb 0401 	rsb	r4, fp, #1
 800df26:	fb04 f403 	mul.w	r4, r4, r3
 800df2a:	e6f3      	b.n	800dd14 <cblas_dsymv+0x150>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800df2c:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 800df30:	d009      	beq.n	800df46 <cblas_dsymv+0x382>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800df32:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 800df36:	f47f aeb7 	bne.w	800dca8 <cblas_dsymv+0xe4>
 800df3a:	e73f      	b.n	800ddbc <cblas_dsymv+0x1f8>
    INDEX iy = OFFSET(N, incY);
 800df3c:	f1cb 0301 	rsb	r3, fp, #1
 800df40:	fb03 f302 	mul.w	r3, r3, r2
 800df44:	e690      	b.n	800dc68 <cblas_dsymv+0xa4>
    INDEX ix = OFFSET(N, incX);
 800df46:	9b03      	ldr	r3, [sp, #12]
    INDEX iy = OFFSET(N, incY);
 800df48:	9900      	ldr	r1, [sp, #0]
    INDEX ix = OFFSET(N, incX);
 800df4a:	2b00      	cmp	r3, #0
 800df4c:	bfda      	itte	le
 800df4e:	f1cb 0201 	rsble	r2, fp, #1
 800df52:	435a      	mulle	r2, r3
 800df54:	2200      	movgt	r2, #0
    INDEX iy = OFFSET(N, incY);
 800df56:	2900      	cmp	r1, #0
 800df58:	bfda      	itte	le
 800df5a:	f1cb 0301 	rsble	r3, fp, #1
 800df5e:	434b      	mulle	r3, r1
 800df60:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 800df62:	f1bb 0f00 	cmp.w	fp, #0
    INDEX iy = OFFSET(N, incY);
 800df66:	930d      	str	r3, [sp, #52]	; 0x34
    for (i = 0; i < N; i++) {
 800df68:	f77f aebb 	ble.w	800dce2 <cblas_dsymv+0x11e>
 800df6c:	9903      	ldr	r1, [sp, #12]
 800df6e:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
 800df72:	f10a 0301 	add.w	r3, sl, #1
 800df76:	00d8      	lsls	r0, r3, #3
 800df78:	440a      	add	r2, r1
 800df7a:	ebc1 7341 	rsb	r3, r1, r1, lsl #29
 800df7e:	00db      	lsls	r3, r3, #3
 800df80:	9206      	str	r2, [sp, #24]
 800df82:	f1a0 0208 	sub.w	r2, r0, #8
 800df86:	920b      	str	r2, [sp, #44]	; 0x2c
 800df88:	9309      	str	r3, [sp, #36]	; 0x24
 800df8a:	9a00      	ldr	r2, [sp, #0]
 800df8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800df8e:	900c      	str	r0, [sp, #48]	; 0x30
 800df90:	1898      	adds	r0, r3, r2
 800df92:	9007      	str	r0, [sp, #28]
 800df94:	00d0      	lsls	r0, r2, #3
 800df96:	9a05      	ldr	r2, [sp, #20]
 800df98:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800df9c:	9301      	str	r3, [sp, #4]
 800df9e:	9b08      	ldr	r3, [sp, #32]
 800dfa0:	461a      	mov	r2, r3
 800dfa2:	3208      	adds	r2, #8
 800dfa4:	9202      	str	r2, [sp, #8]
 800dfa6:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 800dfaa:	00ca      	lsls	r2, r1, #3
 800dfac:	2600      	movs	r6, #0
 800dfae:	4698      	mov	r8, r3
 800dfb0:	4681      	mov	r9, r0
 800dfb2:	4692      	mov	sl, r2
      BASE temp1 = alpha * X[ix];
 800dfb4:	9f06      	ldr	r7, [sp, #24]
 800dfb6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800dfb8:	9a04      	ldr	r2, [sp, #16]
 800dfba:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 800dfbe:	4413      	add	r3, r2
 800dfc0:	e9d3 2300 	ldrd	r2, r3, [r3]
 800dfc4:	ec51 0b19 	vmov	r0, r1, d9
 800dfc8:	f019 ff6e 	bl	8027ea8 <__aeabi_dmul>
      Y[iy] += temp1 * A[lda * i + i];
 800dfcc:	9b02      	ldr	r3, [sp, #8]
 800dfce:	e953 2302 	ldrd	r2, r3, [r3, #-8]
      BASE temp1 = alpha * X[ix];
 800dfd2:	4604      	mov	r4, r0
 800dfd4:	460d      	mov	r5, r1
      Y[iy] += temp1 * A[lda * i + i];
 800dfd6:	f019 ff67 	bl	8027ea8 <__aeabi_dmul>
 800dfda:	9b01      	ldr	r3, [sp, #4]
 800dfdc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800dfe0:	f019 fdac 	bl	8027b3c <__adddf3>
      BASE temp1 = alpha * X[ix];
 800dfe4:	ec45 4b18 	vmov	d8, r4, r5
      Y[iy] += temp1 * A[lda * i + i];
 800dfe8:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 800dfea:	990a      	ldr	r1, [sp, #40]	; 0x28
      Y[iy] += temp1 * A[lda * i + i];
 800dfec:	9b01      	ldr	r3, [sp, #4]
      const INDEX j_min = i + 1;
 800dfee:	1c72      	adds	r2, r6, #1
      Y[iy] += temp1 * A[lda * i + i];
 800dff0:	4604      	mov	r4, r0
      for (j = j_min; j < j_max; j++) {
 800dff2:	4291      	cmp	r1, r2
      Y[iy] += temp1 * A[lda * i + i];
 800dff4:	e9c3 4500 	strd	r4, r5, [r3]
      const INDEX j_min = i + 1;
 800dff8:	9208      	str	r2, [sp, #32]
      for (j = j_min; j < j_max; j++) {
 800dffa:	ea4f 0bc7 	mov.w	fp, r7, lsl #3
 800dffe:	f43f ae5d 	beq.w	800dcbc <cblas_dsymv+0xf8>
 800e002:	9a04      	ldr	r2, [sp, #16]
 800e004:	9907      	ldr	r1, [sp, #28]
 800e006:	9e02      	ldr	r6, [sp, #8]
 800e008:	4493      	add	fp, r2
 800e00a:	9a05      	ldr	r2, [sp, #20]
      BASE temp2 = 0.0;
 800e00c:	2400      	movs	r4, #0
 800e00e:	2500      	movs	r5, #0
 800e010:	eb02 07c1 	add.w	r7, r2, r1, lsl #3
        Y[jy] += temp1 * A[lda * i + j];
 800e014:	e9d6 0100 	ldrd	r0, r1, [r6]
 800e018:	ec53 2b18 	vmov	r2, r3, d8
 800e01c:	f019 ff44 	bl	8027ea8 <__aeabi_dmul>
 800e020:	4602      	mov	r2, r0
 800e022:	460b      	mov	r3, r1
 800e024:	e9d7 0100 	ldrd	r0, r1, [r7]
 800e028:	f019 fd88 	bl	8027b3c <__adddf3>
 800e02c:	e9c7 0100 	strd	r0, r1, [r7]
        temp2 += X[jx] * A[lda * i + j];
 800e030:	e8f6 2302 	ldrd	r2, r3, [r6], #8
 800e034:	e9db 0100 	ldrd	r0, r1, [fp]
 800e038:	f019 ff36 	bl	8027ea8 <__aeabi_dmul>
 800e03c:	4602      	mov	r2, r0
 800e03e:	460b      	mov	r3, r1
 800e040:	4620      	mov	r0, r4
 800e042:	4629      	mov	r1, r5
 800e044:	f019 fd7a 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 800e048:	45b0      	cmp	r8, r6
 800e04a:	444f      	add	r7, r9
        temp2 += X[jx] * A[lda * i + j];
 800e04c:	4604      	mov	r4, r0
 800e04e:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 800e050:	44d3      	add	fp, sl
 800e052:	d1df      	bne.n	800e014 <cblas_dsymv+0x450>
      Y[iy] += alpha * temp2;
 800e054:	4602      	mov	r2, r0
 800e056:	460b      	mov	r3, r1
 800e058:	ec51 0b19 	vmov	r0, r1, d9
 800e05c:	f019 ff24 	bl	8027ea8 <__aeabi_dmul>
 800e060:	9c01      	ldr	r4, [sp, #4]
 800e062:	4602      	mov	r2, r0
 800e064:	460b      	mov	r3, r1
 800e066:	e9d4 0100 	ldrd	r0, r1, [r4]
 800e06a:	f019 fd67 	bl	8027b3c <__adddf3>
 800e06e:	9b06      	ldr	r3, [sp, #24]
 800e070:	9a03      	ldr	r2, [sp, #12]
 800e072:	9e08      	ldr	r6, [sp, #32]
 800e074:	4413      	add	r3, r2
 800e076:	9306      	str	r3, [sp, #24]
 800e078:	9a00      	ldr	r2, [sp, #0]
 800e07a:	9b07      	ldr	r3, [sp, #28]
 800e07c:	4413      	add	r3, r2
 800e07e:	9307      	str	r3, [sp, #28]
 800e080:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e082:	9b02      	ldr	r3, [sp, #8]
 800e084:	4413      	add	r3, r2
 800e086:	9302      	str	r3, [sp, #8]
 800e088:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e08a:	4498      	add	r8, r3
 800e08c:	eb04 0309 	add.w	r3, r4, r9
 800e090:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 800e094:	9301      	str	r3, [sp, #4]
 800e096:	e78d      	b.n	800dfb4 <cblas_dsymv+0x3f0>
      Y[iy] += alpha * temp2;
 800e098:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e09a:	9a00      	ldr	r2, [sp, #0]
 800e09c:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e09e:	fb02 1613 	mls	r6, r2, r3, r1
 800e0a2:	e60f      	b.n	800dcc4 <cblas_dsymv+0x100>
  CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 800e0a4:	200b      	movs	r0, #11
 800e0a6:	e5be      	b.n	800dc26 <cblas_dsymv+0x62>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 800e0a8:	9b03      	ldr	r3, [sp, #12]
 800e0aa:	f10b 32ff 	add.w	r2, fp, #4294967295
 800e0ae:	425b      	negs	r3, r3
 800e0b0:	9201      	str	r2, [sp, #4]
 800e0b2:	fb02 f303 	mul.w	r3, r2, r3
 800e0b6:	e689      	b.n	800ddcc <cblas_dsymv+0x208>

0800e0b8 <cblas_dsyr>:

void
cblas_dsyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const double alpha, const double *X, const int incX,
            double *A, const int lda)
{
 800e0b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e0bc:	ed2d 8b02 	vpush	{d8}
 800e0c0:	eeb0 8a40 	vmov.f32	s16, s0
 800e0c4:	eef0 8a60 	vmov.f32	s17, s1
 800e0c8:	b08b      	sub	sp, #44	; 0x2c
 800e0ca:	460c      	mov	r4, r1
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 800e0cc:	3979      	subs	r1, #121	; 0x79
 800e0ce:	9e18      	ldr	r6, [sp, #96]	; 0x60
 800e0d0:	9303      	str	r3, [sp, #12]
 800e0d2:	4605      	mov	r5, r0
 800e0d4:	9b16      	ldr	r3, [sp, #88]	; 0x58
 800e0d6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800e0d8:	9201      	str	r2, [sp, #4]
 800e0da:	2901      	cmp	r1, #1
 800e0dc:	9302      	str	r3, [sp, #8]
 800e0de:	9005      	str	r0, [sp, #20]
 800e0e0:	9600      	str	r6, [sp, #0]
 800e0e2:	f240 8089 	bls.w	800e1f8 <cblas_dsyr+0x140>
 800e0e6:	2a00      	cmp	r2, #0
 800e0e8:	db0c      	blt.n	800e104 <cblas_dsyr+0x4c>
 800e0ea:	2b00      	cmp	r3, #0
 800e0ec:	f040 809a 	bne.w	800e224 <cblas_dsyr+0x16c>
 800e0f0:	9801      	ldr	r0, [sp, #4]
 800e0f2:	9b00      	ldr	r3, [sp, #0]
 800e0f4:	2801      	cmp	r0, #1
 800e0f6:	bfb8      	it	lt
 800e0f8:	2001      	movlt	r0, #1
 800e0fa:	4283      	cmp	r3, r0
 800e0fc:	bfb4      	ite	lt
 800e0fe:	2008      	movlt	r0, #8
 800e100:	2006      	movge	r0, #6
 800e102:	e007      	b.n	800e114 <cblas_dsyr+0x5c>
 800e104:	9b02      	ldr	r3, [sp, #8]
 800e106:	2b00      	cmp	r3, #0
 800e108:	d0f2      	beq.n	800e0f0 <cblas_dsyr+0x38>
 800e10a:	9b00      	ldr	r3, [sp, #0]
 800e10c:	2b00      	cmp	r3, #0
 800e10e:	bfd4      	ite	le
 800e110:	2008      	movle	r0, #8
 800e112:	2003      	movgt	r0, #3
 800e114:	4a7a      	ldr	r2, [pc, #488]	; (800e300 <cblas_dsyr+0x248>)
 800e116:	497b      	ldr	r1, [pc, #492]	; (800e304 <cblas_dsyr+0x24c>)
 800e118:	f019 fc96 	bl	8027a48 <cblas_xerbla>
  if (N == 0)
 800e11c:	9b01      	ldr	r3, [sp, #4]
 800e11e:	2b00      	cmp	r3, #0
 800e120:	d065      	beq.n	800e1ee <cblas_dsyr+0x136>
  if (alpha == 0.0)
 800e122:	ec51 0b18 	vmov	r0, r1, d8
 800e126:	2200      	movs	r2, #0
 800e128:	2300      	movs	r3, #0
 800e12a:	f01a f925 	bl	8028378 <__aeabi_dcmpeq>
 800e12e:	2800      	cmp	r0, #0
 800e130:	d15d      	bne.n	800e1ee <cblas_dsyr+0x136>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800e132:	2d65      	cmp	r5, #101	; 0x65
 800e134:	f000 80d4 	beq.w	800e2e0 <cblas_dsyr+0x228>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800e138:	2d66      	cmp	r5, #102	; 0x66
 800e13a:	d07b      	beq.n	800e234 <cblas_dsyr+0x17c>
    BLAS_ERROR("unrecognized operation");
 800e13c:	4a72      	ldr	r2, [pc, #456]	; (800e308 <cblas_dsyr+0x250>)
 800e13e:	4971      	ldr	r1, [pc, #452]	; (800e304 <cblas_dsyr+0x24c>)
 800e140:	2000      	movs	r0, #0
#define BASE double
#include "source_syr.h"
#undef BASE
}
 800e142:	b00b      	add	sp, #44	; 0x2c
 800e144:	ecbd 8b02 	vpop	{d8}
 800e148:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e14c:	f019 bc7c 	b.w	8027a48 <cblas_xerbla>
    INDEX ix = OFFSET(N, incX);
 800e150:	9a02      	ldr	r2, [sp, #8]
 800e152:	2a00      	cmp	r2, #0
 800e154:	f340 80cd 	ble.w	800e2f2 <cblas_dsyr+0x23a>
 800e158:	2300      	movs	r3, #0
 800e15a:	9304      	str	r3, [sp, #16]
    for (i = 0; i < N; i++) {
 800e15c:	9b01      	ldr	r3, [sp, #4]
 800e15e:	2b00      	cmp	r3, #0
 800e160:	dd45      	ble.n	800e1ee <cblas_dsyr+0x136>
 800e162:	9b00      	ldr	r3, [sp, #0]
 800e164:	9a03      	ldr	r2, [sp, #12]
 800e166:	3301      	adds	r3, #1
 800e168:	00db      	lsls	r3, r3, #3
 800e16a:	9308      	str	r3, [sp, #32]
 800e16c:	9b05      	ldr	r3, [sp, #20]
 800e16e:	9306      	str	r3, [sp, #24]
 800e170:	9b02      	ldr	r3, [sp, #8]
 800e172:	00df      	lsls	r7, r3, #3
 800e174:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e178:	9307      	str	r3, [sp, #28]
 800e17a:	9700      	str	r7, [sp, #0]
 800e17c:	2300      	movs	r3, #0
 800e17e:	9f01      	ldr	r7, [sp, #4]
 800e180:	9305      	str	r3, [sp, #20]
      const BASE tmp = alpha * X[ix];
 800e182:	9c04      	ldr	r4, [sp, #16]
 800e184:	9b03      	ldr	r3, [sp, #12]
 800e186:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 800e18a:	e9d3 8900 	ldrd	r8, r9, [r3]
 800e18e:	ec53 2b18 	vmov	r2, r3, d8
 800e192:	4640      	mov	r0, r8
 800e194:	4649      	mov	r1, r9
 800e196:	f019 fe87 	bl	8027ea8 <__aeabi_dmul>
 800e19a:	9b07      	ldr	r3, [sp, #28]
 800e19c:	00e4      	lsls	r4, r4, #3
 800e19e:	e9dd 5605 	ldrd	r5, r6, [sp, #20]
 800e1a2:	4682      	mov	sl, r0
 800e1a4:	468b      	mov	fp, r1
      for (j = i; j < N; j++) {
 800e1a6:	441c      	add	r4, r3
 800e1a8:	e003      	b.n	800e1b2 <cblas_dsyr+0xfa>
 800e1aa:	9b00      	ldr	r3, [sp, #0]
 800e1ac:	e9d4 8900 	ldrd	r8, r9, [r4]
 800e1b0:	441c      	add	r4, r3
        A[lda * i + j] += X[jx] * tmp;
 800e1b2:	4642      	mov	r2, r8
 800e1b4:	464b      	mov	r3, r9
 800e1b6:	e9d6 8900 	ldrd	r8, r9, [r6]
 800e1ba:	4650      	mov	r0, sl
 800e1bc:	4659      	mov	r1, fp
 800e1be:	f019 fe73 	bl	8027ea8 <__aeabi_dmul>
 800e1c2:	4642      	mov	r2, r8
 800e1c4:	464b      	mov	r3, r9
 800e1c6:	f019 fcb9 	bl	8027b3c <__adddf3>
      for (j = i; j < N; j++) {
 800e1ca:	3501      	adds	r5, #1
 800e1cc:	42af      	cmp	r7, r5
        A[lda * i + j] += X[jx] * tmp;
 800e1ce:	e8e6 0102 	strd	r0, r1, [r6], #8
      for (j = i; j < N; j++) {
 800e1d2:	dcea      	bgt.n	800e1aa <cblas_dsyr+0xf2>
      ix += incX;
 800e1d4:	9a04      	ldr	r2, [sp, #16]
 800e1d6:	9902      	ldr	r1, [sp, #8]
    for (i = 0; i < N; i++) {
 800e1d8:	9b05      	ldr	r3, [sp, #20]
      ix += incX;
 800e1da:	440a      	add	r2, r1
 800e1dc:	9204      	str	r2, [sp, #16]
    for (i = 0; i < N; i++) {
 800e1de:	9908      	ldr	r1, [sp, #32]
 800e1e0:	9a06      	ldr	r2, [sp, #24]
 800e1e2:	3301      	adds	r3, #1
 800e1e4:	440a      	add	r2, r1
 800e1e6:	429f      	cmp	r7, r3
 800e1e8:	9305      	str	r3, [sp, #20]
 800e1ea:	9206      	str	r2, [sp, #24]
 800e1ec:	d1c9      	bne.n	800e182 <cblas_dsyr+0xca>
 800e1ee:	b00b      	add	sp, #44	; 0x2c
 800e1f0:	ecbd 8b02 	vpop	{d8}
 800e1f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 800e1f8:	9b01      	ldr	r3, [sp, #4]
 800e1fa:	2b00      	cmp	r3, #0
 800e1fc:	db82      	blt.n	800e104 <cblas_dsyr+0x4c>
 800e1fe:	9b02      	ldr	r3, [sp, #8]
 800e200:	2b00      	cmp	r3, #0
 800e202:	f43f af75 	beq.w	800e0f0 <cblas_dsyr+0x38>
 800e206:	9b01      	ldr	r3, [sp, #4]
 800e208:	9a00      	ldr	r2, [sp, #0]
 800e20a:	2b01      	cmp	r3, #1
 800e20c:	bfb8      	it	lt
 800e20e:	2301      	movlt	r3, #1
 800e210:	4293      	cmp	r3, r2
 800e212:	dc6c      	bgt.n	800e2ee <cblas_dsyr+0x236>
 800e214:	f1a5 0365 	sub.w	r3, r5, #101	; 0x65
 800e218:	2b01      	cmp	r3, #1
 800e21a:	bf88      	it	hi
 800e21c:	2001      	movhi	r0, #1
 800e21e:	f67f af7d 	bls.w	800e11c <cblas_dsyr+0x64>
 800e222:	e777      	b.n	800e114 <cblas_dsyr+0x5c>
 800e224:	2a01      	cmp	r2, #1
 800e226:	bfb8      	it	lt
 800e228:	2201      	movlt	r2, #1
 800e22a:	4296      	cmp	r6, r2
 800e22c:	bfb4      	ite	lt
 800e22e:	2008      	movlt	r0, #8
 800e230:	2002      	movge	r0, #2
 800e232:	e76f      	b.n	800e114 <cblas_dsyr+0x5c>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800e234:	2c7a      	cmp	r4, #122	; 0x7a
 800e236:	d08b      	beq.n	800e150 <cblas_dsyr+0x98>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800e238:	2c79      	cmp	r4, #121	; 0x79
 800e23a:	f47f af7f 	bne.w	800e13c <cblas_dsyr+0x84>
    INDEX ix = OFFSET(N, incX);
 800e23e:	9a02      	ldr	r2, [sp, #8]
 800e240:	2a00      	cmp	r2, #0
 800e242:	bfdd      	ittte	le
 800e244:	9b01      	ldrle	r3, [sp, #4]
 800e246:	f1c3 0301 	rsble	r3, r3, #1
 800e24a:	4353      	mulle	r3, r2
 800e24c:	2300      	movgt	r3, #0
 800e24e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 800e250:	9b01      	ldr	r3, [sp, #4]
 800e252:	2b00      	cmp	r3, #0
 800e254:	ddcb      	ble.n	800e1ee <cblas_dsyr+0x136>
 800e256:	9b00      	ldr	r3, [sp, #0]
 800e258:	9903      	ldr	r1, [sp, #12]
 800e25a:	3301      	adds	r3, #1
 800e25c:	00db      	lsls	r3, r3, #3
 800e25e:	9309      	str	r3, [sp, #36]	; 0x24
 800e260:	9b05      	ldr	r3, [sp, #20]
 800e262:	2200      	movs	r2, #0
 800e264:	9204      	str	r2, [sp, #16]
 800e266:	9207      	str	r2, [sp, #28]
 800e268:	f103 0a08 	add.w	sl, r3, #8
 800e26c:	9a06      	ldr	r2, [sp, #24]
 800e26e:	9b02      	ldr	r3, [sp, #8]
 800e270:	ea4f 0bc3 	mov.w	fp, r3, lsl #3
 800e274:	00d3      	lsls	r3, r2, #3
 800e276:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 800e27a:	9208      	str	r2, [sp, #32]
      const BASE tmp = alpha * X[ix];
 800e27c:	9a03      	ldr	r2, [sp, #12]
 800e27e:	4413      	add	r3, r2
 800e280:	e9d3 2300 	ldrd	r2, r3, [r3]
 800e284:	ec51 0b18 	vmov	r0, r1, d8
 800e288:	f019 fe0e 	bl	8027ea8 <__aeabi_dmul>
 800e28c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800e290:	9d08      	ldr	r5, [sp, #32]
 800e292:	4680      	mov	r8, r0
 800e294:	4689      	mov	r9, r1
      for (j = 0; j <= i; j++) {
 800e296:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[lda * i + j] += X[jx] * tmp;
 800e29a:	e9d4 6700 	ldrd	r6, r7, [r4]
 800e29e:	e9d5 2300 	ldrd	r2, r3, [r5]
 800e2a2:	4640      	mov	r0, r8
 800e2a4:	4649      	mov	r1, r9
 800e2a6:	f019 fdff 	bl	8027ea8 <__aeabi_dmul>
 800e2aa:	4632      	mov	r2, r6
 800e2ac:	463b      	mov	r3, r7
 800e2ae:	f019 fc45 	bl	8027b3c <__adddf3>
 800e2b2:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j <= i; j++) {
 800e2b6:	45a2      	cmp	sl, r4
 800e2b8:	445d      	add	r5, fp
 800e2ba:	d1ee      	bne.n	800e29a <cblas_dsyr+0x1e2>
      ix += incX;
 800e2bc:	9a06      	ldr	r2, [sp, #24]
 800e2be:	9902      	ldr	r1, [sp, #8]
 800e2c0:	9800      	ldr	r0, [sp, #0]
    for (i = 0; i < N; i++) {
 800e2c2:	9b07      	ldr	r3, [sp, #28]
      ix += incX;
 800e2c4:	440a      	add	r2, r1
 800e2c6:	9904      	ldr	r1, [sp, #16]
 800e2c8:	9206      	str	r2, [sp, #24]
    for (i = 0; i < N; i++) {
 800e2ca:	4401      	add	r1, r0
 800e2cc:	9104      	str	r1, [sp, #16]
 800e2ce:	9909      	ldr	r1, [sp, #36]	; 0x24
 800e2d0:	448a      	add	sl, r1
 800e2d2:	9901      	ldr	r1, [sp, #4]
 800e2d4:	3301      	adds	r3, #1
 800e2d6:	4299      	cmp	r1, r3
 800e2d8:	9307      	str	r3, [sp, #28]
 800e2da:	d088      	beq.n	800e1ee <cblas_dsyr+0x136>
 800e2dc:	00d3      	lsls	r3, r2, #3
 800e2de:	e7cd      	b.n	800e27c <cblas_dsyr+0x1c4>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800e2e0:	2c79      	cmp	r4, #121	; 0x79
 800e2e2:	f43f af35 	beq.w	800e150 <cblas_dsyr+0x98>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800e2e6:	2c7a      	cmp	r4, #122	; 0x7a
 800e2e8:	f47f af28 	bne.w	800e13c <cblas_dsyr+0x84>
 800e2ec:	e7a7      	b.n	800e23e <cblas_dsyr+0x186>
  CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
 800e2ee:	2008      	movs	r0, #8
 800e2f0:	e710      	b.n	800e114 <cblas_dsyr+0x5c>
    INDEX ix = OFFSET(N, incX);
 800e2f2:	9b01      	ldr	r3, [sp, #4]
 800e2f4:	f1c3 0301 	rsb	r3, r3, #1
 800e2f8:	fb03 f302 	mul.w	r3, r3, r2
 800e2fc:	9304      	str	r3, [sp, #16]
 800e2fe:	e72d      	b.n	800e15c <cblas_dsyr+0xa4>
 800e300:	08030378 	.word	0x08030378
 800e304:	0803062c 	.word	0x0803062c
 800e308:	080305a8 	.word	0x080305a8

0800e30c <cblas_dsyr2>:

void
cblas_dsyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const double alpha, const double *X, const int incX,
             const double *Y, const int incY, double *A, const int lda)
{
 800e30c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e310:	ed2d 8b06 	vpush	{d8-d10}
 800e314:	eeb0 aa40 	vmov.f32	s20, s0
 800e318:	eef0 aa60 	vmov.f32	s21, s1
 800e31c:	b08f      	sub	sp, #60	; 0x3c
 800e31e:	460c      	mov	r4, r1
 800e320:	9307      	str	r3, [sp, #28]
 800e322:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800e324:	9303      	str	r3, [sp, #12]
 800e326:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800e328:	9308      	str	r3, [sp, #32]
 800e32a:	9b20      	ldr	r3, [sp, #128]	; 0x80
 800e32c:	9304      	str	r3, [sp, #16]
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800e32e:	3979      	subs	r1, #121	; 0x79
 800e330:	9b21      	ldr	r3, [sp, #132]	; 0x84
 800e332:	9309      	str	r3, [sp, #36]	; 0x24
 800e334:	2901      	cmp	r1, #1
 800e336:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800e338:	9200      	str	r2, [sp, #0]
 800e33a:	4605      	mov	r5, r0
 800e33c:	9301      	str	r3, [sp, #4]
 800e33e:	f240 80f6 	bls.w	800e52e <cblas_dsyr2+0x222>
 800e342:	2002      	movs	r0, #2
 800e344:	9b00      	ldr	r3, [sp, #0]
 800e346:	2b00      	cmp	r3, #0
 800e348:	9b03      	ldr	r3, [sp, #12]
 800e34a:	f2c0 80e3 	blt.w	800e514 <cblas_dsyr2+0x208>
 800e34e:	2b00      	cmp	r3, #0
 800e350:	f040 80c6 	bne.w	800e4e0 <cblas_dsyr2+0x1d4>
 800e354:	9b04      	ldr	r3, [sp, #16]
 800e356:	2b00      	cmp	r3, #0
 800e358:	f040 80d2 	bne.w	800e500 <cblas_dsyr2+0x1f4>
 800e35c:	9800      	ldr	r0, [sp, #0]
 800e35e:	9b01      	ldr	r3, [sp, #4]
 800e360:	2801      	cmp	r0, #1
 800e362:	bfb8      	it	lt
 800e364:	2001      	movlt	r0, #1
 800e366:	4283      	cmp	r3, r0
 800e368:	bfb4      	ite	lt
 800e36a:	200a      	movlt	r0, #10
 800e36c:	2008      	movge	r0, #8
 800e36e:	4a73      	ldr	r2, [pc, #460]	; (800e53c <cblas_dsyr2+0x230>)
 800e370:	4973      	ldr	r1, [pc, #460]	; (800e540 <cblas_dsyr2+0x234>)
 800e372:	f019 fb69 	bl	8027a48 <cblas_xerbla>
  if (N == 0)
 800e376:	9b00      	ldr	r3, [sp, #0]
 800e378:	2b00      	cmp	r3, #0
 800e37a:	f000 80ac 	beq.w	800e4d6 <cblas_dsyr2+0x1ca>
  if (alpha == 0.0)
 800e37e:	ec51 0b1a 	vmov	r0, r1, d10
 800e382:	2200      	movs	r2, #0
 800e384:	2300      	movs	r3, #0
 800e386:	f019 fff7 	bl	8028378 <__aeabi_dcmpeq>
 800e38a:	2800      	cmp	r0, #0
 800e38c:	f040 80a3 	bne.w	800e4d6 <cblas_dsyr2+0x1ca>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800e390:	2d65      	cmp	r5, #101	; 0x65
 800e392:	f000 8165 	beq.w	800e660 <cblas_dsyr2+0x354>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800e396:	2d66      	cmp	r5, #102	; 0x66
 800e398:	f000 80d6 	beq.w	800e548 <cblas_dsyr2+0x23c>
    BLAS_ERROR("unrecognized operation");
 800e39c:	4a69      	ldr	r2, [pc, #420]	; (800e544 <cblas_dsyr2+0x238>)
 800e39e:	4968      	ldr	r1, [pc, #416]	; (800e540 <cblas_dsyr2+0x234>)
 800e3a0:	2000      	movs	r0, #0
#define BASE double
#include "source_syr2.h"
#undef BASE
}
 800e3a2:	b00f      	add	sp, #60	; 0x3c
 800e3a4:	ecbd 8b06 	vpop	{d8-d10}
 800e3a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e3ac:	f019 bb4c 	b.w	8027a48 <cblas_xerbla>
    INDEX ix = OFFSET(N, incX);
 800e3b0:	9a03      	ldr	r2, [sp, #12]
 800e3b2:	2a00      	cmp	r2, #0
 800e3b4:	bfde      	ittt	le
 800e3b6:	9b00      	ldrle	r3, [sp, #0]
 800e3b8:	f1c3 0301 	rsble	r3, r3, #1
 800e3bc:	4353      	mulle	r3, r2
    INDEX iy = OFFSET(N, incY);
 800e3be:	9a04      	ldr	r2, [sp, #16]
    INDEX ix = OFFSET(N, incX);
 800e3c0:	bfc8      	it	gt
 800e3c2:	2300      	movgt	r3, #0
    INDEX iy = OFFSET(N, incY);
 800e3c4:	2a00      	cmp	r2, #0
    INDEX ix = OFFSET(N, incX);
 800e3c6:	9305      	str	r3, [sp, #20]
    INDEX iy = OFFSET(N, incY);
 800e3c8:	f340 8153 	ble.w	800e672 <cblas_dsyr2+0x366>
 800e3cc:	2300      	movs	r3, #0
 800e3ce:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 800e3d0:	9b00      	ldr	r3, [sp, #0]
 800e3d2:	2b00      	cmp	r3, #0
 800e3d4:	dd7f      	ble.n	800e4d6 <cblas_dsyr2+0x1ca>
 800e3d6:	9b01      	ldr	r3, [sp, #4]
 800e3d8:	3301      	adds	r3, #1
 800e3da:	00db      	lsls	r3, r3, #3
 800e3dc:	930d      	str	r3, [sp, #52]	; 0x34
 800e3de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e3e0:	930a      	str	r3, [sp, #40]	; 0x28
 800e3e2:	9b04      	ldr	r3, [sp, #16]
 800e3e4:	00da      	lsls	r2, r3, #3
 800e3e6:	9202      	str	r2, [sp, #8]
 800e3e8:	9a08      	ldr	r2, [sp, #32]
 800e3ea:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e3ee:	930c      	str	r3, [sp, #48]	; 0x30
 800e3f0:	9b03      	ldr	r3, [sp, #12]
 800e3f2:	00da      	lsls	r2, r3, #3
 800e3f4:	9201      	str	r2, [sp, #4]
 800e3f6:	9a07      	ldr	r2, [sp, #28]
 800e3f8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e3fc:	930b      	str	r3, [sp, #44]	; 0x2c
 800e3fe:	2300      	movs	r3, #0
 800e400:	9309      	str	r3, [sp, #36]	; 0x24
      const BASE tmp1 = alpha * X[ix];
 800e402:	9b07      	ldr	r3, [sp, #28]
 800e404:	461a      	mov	r2, r3
 800e406:	9b05      	ldr	r3, [sp, #20]
 800e408:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e40c:	e9d3 ab00 	ldrd	sl, fp, [r3]
 800e410:	ec59 8b1a 	vmov	r8, r9, d10
 800e414:	ee1a 2a10 	vmov	r2, s20
 800e418:	464b      	mov	r3, r9
 800e41a:	4650      	mov	r0, sl
 800e41c:	4659      	mov	r1, fp
 800e41e:	f019 fd43 	bl	8027ea8 <__aeabi_dmul>
 800e422:	460f      	mov	r7, r1
      const BASE tmp2 = alpha * Y[iy];
 800e424:	9908      	ldr	r1, [sp, #32]
      const BASE tmp1 = alpha * X[ix];
 800e426:	4606      	mov	r6, r0
      const BASE tmp2 = alpha * Y[iy];
 800e428:	4608      	mov	r0, r1
 800e42a:	9906      	ldr	r1, [sp, #24]
 800e42c:	eb00 03c1 	add.w	r3, r0, r1, lsl #3
 800e430:	e9d3 4500 	ldrd	r4, r5, [r3]
 800e434:	ee1a 2a10 	vmov	r2, s20
 800e438:	464b      	mov	r3, r9
 800e43a:	4620      	mov	r0, r4
 800e43c:	4629      	mov	r1, r5
 800e43e:	f019 fd33 	bl	8027ea8 <__aeabi_dmul>
 800e442:	9b05      	ldr	r3, [sp, #20]
      const BASE tmp1 = alpha * X[ix];
 800e444:	ec47 6b18 	vmov	d8, r6, r7
      const BASE tmp2 = alpha * Y[iy];
 800e448:	00df      	lsls	r7, r3, #3
 800e44a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e44c:	ec41 0b19 	vmov	d9, r0, r1
      for (j = i; j < N; j++) {
 800e450:	9906      	ldr	r1, [sp, #24]
 800e452:	441f      	add	r7, r3
 800e454:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e456:	00ce      	lsls	r6, r1, #3
      const BASE tmp2 = alpha * Y[iy];
 800e458:	e9dd 8909 	ldrd	r8, r9, [sp, #36]	; 0x24
 800e45c:	441e      	add	r6, r3
 800e45e:	e007      	b.n	800e470 <cblas_dsyr2+0x164>
 800e460:	9b02      	ldr	r3, [sp, #8]
 800e462:	e9d6 4500 	ldrd	r4, r5, [r6]
 800e466:	441e      	add	r6, r3
 800e468:	9b01      	ldr	r3, [sp, #4]
 800e46a:	e9d7 ab00 	ldrd	sl, fp, [r7]
 800e46e:	441f      	add	r7, r3
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800e470:	4622      	mov	r2, r4
 800e472:	462b      	mov	r3, r5
 800e474:	ec51 0b18 	vmov	r0, r1, d8
 800e478:	f019 fd16 	bl	8027ea8 <__aeabi_dmul>
 800e47c:	4652      	mov	r2, sl
 800e47e:	4604      	mov	r4, r0
 800e480:	460d      	mov	r5, r1
 800e482:	465b      	mov	r3, fp
 800e484:	ec51 0b19 	vmov	r0, r1, d9
 800e488:	f019 fd0e 	bl	8027ea8 <__aeabi_dmul>
 800e48c:	4602      	mov	r2, r0
 800e48e:	460b      	mov	r3, r1
 800e490:	4620      	mov	r0, r4
 800e492:	4629      	mov	r1, r5
 800e494:	e9d9 4500 	ldrd	r4, r5, [r9]
 800e498:	f019 fb50 	bl	8027b3c <__adddf3>
 800e49c:	462b      	mov	r3, r5
 800e49e:	4622      	mov	r2, r4
 800e4a0:	f019 fb4c 	bl	8027b3c <__adddf3>
      for (j = i; j < N; j++) {
 800e4a4:	9b00      	ldr	r3, [sp, #0]
 800e4a6:	f108 0801 	add.w	r8, r8, #1
 800e4aa:	4543      	cmp	r3, r8
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800e4ac:	e8e9 0102 	strd	r0, r1, [r9], #8
      for (j = i; j < N; j++) {
 800e4b0:	dcd6      	bgt.n	800e460 <cblas_dsyr2+0x154>
      ix += incX;
 800e4b2:	9a05      	ldr	r2, [sp, #20]
 800e4b4:	9903      	ldr	r1, [sp, #12]
    for (i = 0; i < N; i++) {
 800e4b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
      ix += incX;
 800e4b8:	440a      	add	r2, r1
 800e4ba:	9205      	str	r2, [sp, #20]
      iy += incY;
 800e4bc:	9904      	ldr	r1, [sp, #16]
 800e4be:	9a06      	ldr	r2, [sp, #24]
 800e4c0:	440a      	add	r2, r1
 800e4c2:	9206      	str	r2, [sp, #24]
    for (i = 0; i < N; i++) {
 800e4c4:	990d      	ldr	r1, [sp, #52]	; 0x34
 800e4c6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800e4c8:	440a      	add	r2, r1
 800e4ca:	920a      	str	r2, [sp, #40]	; 0x28
 800e4cc:	9a00      	ldr	r2, [sp, #0]
 800e4ce:	3301      	adds	r3, #1
 800e4d0:	429a      	cmp	r2, r3
 800e4d2:	9309      	str	r3, [sp, #36]	; 0x24
 800e4d4:	d195      	bne.n	800e402 <cblas_dsyr2+0xf6>
 800e4d6:	b00f      	add	sp, #60	; 0x3c
 800e4d8:	ecbd 8b06 	vpop	{d8-d10}
 800e4dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800e4e0:	9b04      	ldr	r3, [sp, #16]
 800e4e2:	2b00      	cmp	r3, #0
 800e4e4:	f43f af3a 	beq.w	800e35c <cblas_dsyr2+0x50>
 800e4e8:	9b00      	ldr	r3, [sp, #0]
 800e4ea:	9a01      	ldr	r2, [sp, #4]
 800e4ec:	2b01      	cmp	r3, #1
 800e4ee:	bfb8      	it	lt
 800e4f0:	2301      	movlt	r3, #1
 800e4f2:	4293      	cmp	r3, r2
 800e4f4:	f300 80bb 	bgt.w	800e66e <cblas_dsyr2+0x362>
 800e4f8:	2800      	cmp	r0, #0
 800e4fa:	f43f af3c 	beq.w	800e376 <cblas_dsyr2+0x6a>
 800e4fe:	e736      	b.n	800e36e <cblas_dsyr2+0x62>
 800e500:	9800      	ldr	r0, [sp, #0]
 800e502:	9b01      	ldr	r3, [sp, #4]
 800e504:	2801      	cmp	r0, #1
 800e506:	bfb8      	it	lt
 800e508:	2001      	movlt	r0, #1
 800e50a:	4283      	cmp	r3, r0
 800e50c:	bfb4      	ite	lt
 800e50e:	200a      	movlt	r0, #10
 800e510:	2006      	movge	r0, #6
 800e512:	e72c      	b.n	800e36e <cblas_dsyr2+0x62>
 800e514:	2b00      	cmp	r3, #0
 800e516:	f43f af1d 	beq.w	800e354 <cblas_dsyr2+0x48>
 800e51a:	9b04      	ldr	r3, [sp, #16]
 800e51c:	2b00      	cmp	r3, #0
 800e51e:	f43f af1d 	beq.w	800e35c <cblas_dsyr2+0x50>
 800e522:	9b01      	ldr	r3, [sp, #4]
 800e524:	2b00      	cmp	r3, #0
 800e526:	bfd4      	ite	le
 800e528:	200a      	movle	r0, #10
 800e52a:	2003      	movgt	r0, #3
 800e52c:	e71f      	b.n	800e36e <cblas_dsyr2+0x62>
 800e52e:	3865      	subs	r0, #101	; 0x65
 800e530:	2801      	cmp	r0, #1
 800e532:	bf94      	ite	ls
 800e534:	2000      	movls	r0, #0
 800e536:	2001      	movhi	r0, #1
 800e538:	e704      	b.n	800e344 <cblas_dsyr2+0x38>
 800e53a:	bf00      	nop
 800e53c:	08030378 	.word	0x08030378
 800e540:	0803063c 	.word	0x0803063c
 800e544:	080305a8 	.word	0x080305a8
      || (order == CblasColMajor && Uplo == CblasLower)) {
 800e548:	2c7a      	cmp	r4, #122	; 0x7a
 800e54a:	f43f af31 	beq.w	800e3b0 <cblas_dsyr2+0xa4>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 800e54e:	2c79      	cmp	r4, #121	; 0x79
 800e550:	f47f af24 	bne.w	800e39c <cblas_dsyr2+0x90>
    INDEX ix = OFFSET(N, incX);
 800e554:	9a03      	ldr	r2, [sp, #12]
 800e556:	2a00      	cmp	r2, #0
 800e558:	bfde      	ittt	le
 800e55a:	9b00      	ldrle	r3, [sp, #0]
 800e55c:	f1c3 0301 	rsble	r3, r3, #1
 800e560:	4353      	mulle	r3, r2
    INDEX iy = OFFSET(N, incY);
 800e562:	9a04      	ldr	r2, [sp, #16]
    INDEX ix = OFFSET(N, incX);
 800e564:	bfc8      	it	gt
 800e566:	2300      	movgt	r3, #0
    INDEX iy = OFFSET(N, incY);
 800e568:	2a00      	cmp	r2, #0
    INDEX ix = OFFSET(N, incX);
 800e56a:	9305      	str	r3, [sp, #20]
    INDEX iy = OFFSET(N, incY);
 800e56c:	bfdd      	ittte	le
 800e56e:	9b00      	ldrle	r3, [sp, #0]
 800e570:	f1c3 0301 	rsble	r3, r3, #1
 800e574:	4353      	mulle	r3, r2
 800e576:	2300      	movgt	r3, #0
 800e578:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 800e57a:	9b00      	ldr	r3, [sp, #0]
 800e57c:	2b00      	cmp	r3, #0
 800e57e:	ddaa      	ble.n	800e4d6 <cblas_dsyr2+0x1ca>
 800e580:	9b01      	ldr	r3, [sp, #4]
 800e582:	9d07      	ldr	r5, [sp, #28]
 800e584:	3301      	adds	r3, #1
 800e586:	2200      	movs	r2, #0
 800e588:	00db      	lsls	r3, r3, #3
 800e58a:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 800e58e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e590:	9202      	str	r2, [sp, #8]
 800e592:	f103 0908 	add.w	r9, r3, #8
 800e596:	9b04      	ldr	r3, [sp, #16]
 800e598:	9a08      	ldr	r2, [sp, #32]
 800e59a:	00d9      	lsls	r1, r3, #3
 800e59c:	9b06      	ldr	r3, [sp, #24]
 800e59e:	00dc      	lsls	r4, r3, #3
 800e5a0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800e5a4:	930d      	str	r3, [sp, #52]	; 0x34
 800e5a6:	9a05      	ldr	r2, [sp, #20]
 800e5a8:	9b03      	ldr	r3, [sp, #12]
 800e5aa:	00d8      	lsls	r0, r3, #3
 800e5ac:	00d3      	lsls	r3, r2, #3
 800e5ae:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 800e5b2:	920c      	str	r2, [sp, #48]	; 0x30
 800e5b4:	4683      	mov	fp, r0
 800e5b6:	468a      	mov	sl, r1
      const BASE tmp1 = alpha * X[ix];
 800e5b8:	9a07      	ldr	r2, [sp, #28]
 800e5ba:	4413      	add	r3, r2
 800e5bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 800e5c0:	ec51 0b1a 	vmov	r0, r1, d10
 800e5c4:	f019 fc70 	bl	8027ea8 <__aeabi_dmul>
      const BASE tmp2 = alpha * Y[iy];
 800e5c8:	9b08      	ldr	r3, [sp, #32]
 800e5ca:	441c      	add	r4, r3
 800e5cc:	e9d4 2300 	ldrd	r2, r3, [r4]
      const BASE tmp1 = alpha * X[ix];
 800e5d0:	4606      	mov	r6, r0
 800e5d2:	460f      	mov	r7, r1
      const BASE tmp2 = alpha * Y[iy];
 800e5d4:	ec51 0b1a 	vmov	r0, r1, d10
 800e5d8:	f019 fc66 	bl	8027ea8 <__aeabi_dmul>
 800e5dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e5de:	9a02      	ldr	r2, [sp, #8]
 800e5e0:	e9dd 850c 	ldrd	r8, r5, [sp, #48]	; 0x30
      const BASE tmp1 = alpha * X[ix];
 800e5e4:	ec47 6b18 	vmov	d8, r6, r7
      const BASE tmp2 = alpha * Y[iy];
 800e5e8:	ec41 0b19 	vmov	d9, r0, r1
      for (j = 0; j <= i; j++) {
 800e5ec:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
        A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
 800e5f0:	e9d5 2300 	ldrd	r2, r3, [r5]
 800e5f4:	ec51 0b18 	vmov	r0, r1, d8
 800e5f8:	f019 fc56 	bl	8027ea8 <__aeabi_dmul>
 800e5fc:	e9d8 2300 	ldrd	r2, r3, [r8]
 800e600:	4606      	mov	r6, r0
 800e602:	460f      	mov	r7, r1
 800e604:	ec51 0b19 	vmov	r0, r1, d9
 800e608:	f019 fc4e 	bl	8027ea8 <__aeabi_dmul>
 800e60c:	4602      	mov	r2, r0
 800e60e:	460b      	mov	r3, r1
 800e610:	4630      	mov	r0, r6
 800e612:	4639      	mov	r1, r7
 800e614:	e9d4 6700 	ldrd	r6, r7, [r4]
 800e618:	f019 fa90 	bl	8027b3c <__adddf3>
 800e61c:	4632      	mov	r2, r6
 800e61e:	463b      	mov	r3, r7
 800e620:	f019 fa8c 	bl	8027b3c <__adddf3>
 800e624:	e8e4 0102 	strd	r0, r1, [r4], #8
      for (j = 0; j <= i; j++) {
 800e628:	45a1      	cmp	r9, r4
 800e62a:	4455      	add	r5, sl
 800e62c:	44d8      	add	r8, fp
 800e62e:	d1df      	bne.n	800e5f0 <cblas_dsyr2+0x2e4>
      ix += incX;
 800e630:	9905      	ldr	r1, [sp, #20]
 800e632:	9a03      	ldr	r2, [sp, #12]
      iy += incY;
 800e634:	9804      	ldr	r0, [sp, #16]
    for (i = 0; i < N; i++) {
 800e636:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      ix += incX;
 800e638:	4411      	add	r1, r2
      iy += incY;
 800e63a:	9a06      	ldr	r2, [sp, #24]
      ix += incX;
 800e63c:	9105      	str	r1, [sp, #20]
      iy += incY;
 800e63e:	4402      	add	r2, r0
 800e640:	e9dd 4001 	ldrd	r4, r0, [sp, #4]
 800e644:	4420      	add	r0, r4
 800e646:	9002      	str	r0, [sp, #8]
 800e648:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800e64a:	9206      	str	r2, [sp, #24]
    for (i = 0; i < N; i++) {
 800e64c:	4481      	add	r9, r0
 800e64e:	9800      	ldr	r0, [sp, #0]
 800e650:	3301      	adds	r3, #1
 800e652:	4298      	cmp	r0, r3
 800e654:	930a      	str	r3, [sp, #40]	; 0x28
 800e656:	f43f af3e 	beq.w	800e4d6 <cblas_dsyr2+0x1ca>
 800e65a:	00d4      	lsls	r4, r2, #3
 800e65c:	00cb      	lsls	r3, r1, #3
 800e65e:	e7ab      	b.n	800e5b8 <cblas_dsyr2+0x2ac>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 800e660:	2c79      	cmp	r4, #121	; 0x79
 800e662:	f43f aea5 	beq.w	800e3b0 <cblas_dsyr2+0xa4>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 800e666:	2c7a      	cmp	r4, #122	; 0x7a
 800e668:	f47f ae98 	bne.w	800e39c <cblas_dsyr2+0x90>
 800e66c:	e772      	b.n	800e554 <cblas_dsyr2+0x248>
  CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 800e66e:	200a      	movs	r0, #10
 800e670:	e67d      	b.n	800e36e <cblas_dsyr2+0x62>
    INDEX iy = OFFSET(N, incY);
 800e672:	9b00      	ldr	r3, [sp, #0]
 800e674:	f1c3 0301 	rsb	r3, r3, #1
 800e678:	fb03 f302 	mul.w	r3, r3, r2
 800e67c:	9306      	str	r3, [sp, #24]
 800e67e:	e6a7      	b.n	800e3d0 <cblas_dsyr2+0xc4>

0800e680 <cblas_dsyr2k>:
cblas_dsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const double alpha, const double *A, const int lda,
              const double *B, const int ldb, const double beta, double *C,
              const int ldc)
{
 800e680:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e684:	ed2d 8b06 	vpush	{d8-d10}
 800e688:	eeb0 aa40 	vmov.f32	s20, s0
 800e68c:	eef0 aa60 	vmov.f32	s21, s1
 800e690:	b095      	sub	sp, #84	; 0x54
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800e692:	2865      	cmp	r0, #101	; 0x65
 800e694:	9300      	str	r3, [sp, #0]
 800e696:	9b24      	ldr	r3, [sp, #144]	; 0x90
 800e698:	9306      	str	r3, [sp, #24]
 800e69a:	9b25      	ldr	r3, [sp, #148]	; 0x94
 800e69c:	9309      	str	r3, [sp, #36]	; 0x24
 800e69e:	9b26      	ldr	r3, [sp, #152]	; 0x98
 800e6a0:	9302      	str	r3, [sp, #8]
 800e6a2:	9b27      	ldr	r3, [sp, #156]	; 0x9c
 800e6a4:	930a      	str	r3, [sp, #40]	; 0x28
 800e6a6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 800e6a8:	9307      	str	r3, [sp, #28]
 800e6aa:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 800e6ac:	9308      	str	r3, [sp, #32]
 800e6ae:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 800e6b0:	930c      	str	r3, [sp, #48]	; 0x30
 800e6b2:	ec57 6b11 	vmov	r6, r7, d1
 800e6b6:	4605      	mov	r5, r0
 800e6b8:	4688      	mov	r8, r1
 800e6ba:	4693      	mov	fp, r2
 800e6bc:	f000 8133 	beq.w	800e926 <cblas_dsyr2k+0x2a6>
 800e6c0:	2a6f      	cmp	r2, #111	; 0x6f
 800e6c2:	f000 810a 	beq.w	800e8da <cblas_dsyr2k+0x25a>
 800e6c6:	9a06      	ldr	r2, [sp, #24]
 800e6c8:	f1a8 0379 	sub.w	r3, r8, #121	; 0x79
 800e6cc:	2b01      	cmp	r3, #1
 800e6ce:	f240 8123 	bls.w	800e918 <cblas_dsyr2k+0x298>
 800e6d2:	2002      	movs	r0, #2
 800e6d4:	f1ab 036f 	sub.w	r3, fp, #111	; 0x6f
 800e6d8:	b2db      	uxtb	r3, r3
 800e6da:	2b03      	cmp	r3, #3
 800e6dc:	bf28      	it	cs
 800e6de:	2003      	movcs	r0, #3
 800e6e0:	9900      	ldr	r1, [sp, #0]
 800e6e2:	9b06      	ldr	r3, [sp, #24]
 800e6e4:	2900      	cmp	r1, #0
 800e6e6:	bfb8      	it	lt
 800e6e8:	2004      	movlt	r0, #4
 800e6ea:	2b00      	cmp	r3, #0
 800e6ec:	bfb8      	it	lt
 800e6ee:	2005      	movlt	r0, #5
 800e6f0:	4613      	mov	r3, r2
 800e6f2:	2a01      	cmp	r2, #1
 800e6f4:	9a02      	ldr	r2, [sp, #8]
 800e6f6:	bfb8      	it	lt
 800e6f8:	2301      	movlt	r3, #1
 800e6fa:	4293      	cmp	r3, r2
 800e6fc:	9a07      	ldr	r2, [sp, #28]
 800e6fe:	f340 80fd 	ble.w	800e8fc <cblas_dsyr2k+0x27c>
 800e702:	4293      	cmp	r3, r2
 800e704:	f300 80f0 	bgt.w	800e8e8 <cblas_dsyr2k+0x268>
 800e708:	2901      	cmp	r1, #1
 800e70a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e70c:	bfb8      	it	lt
 800e70e:	2101      	movlt	r1, #1
 800e710:	428b      	cmp	r3, r1
 800e712:	bfb4      	ite	lt
 800e714:	200e      	movlt	r0, #14
 800e716:	2008      	movge	r0, #8
 800e718:	4ab2      	ldr	r2, [pc, #712]	; (800e9e4 <cblas_dsyr2k+0x364>)
 800e71a:	49b3      	ldr	r1, [pc, #716]	; (800e9e8 <cblas_dsyr2k+0x368>)
 800e71c:	f019 f994 	bl	8027a48 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800e720:	ec51 0b1a 	vmov	r0, r1, d10
 800e724:	2200      	movs	r2, #0
 800e726:	2300      	movs	r3, #0
 800e728:	f019 fe26 	bl	8028378 <__aeabi_dcmpeq>
 800e72c:	b140      	cbz	r0, 800e740 <cblas_dsyr2k+0xc0>
 800e72e:	4baf      	ldr	r3, [pc, #700]	; (800e9ec <cblas_dsyr2k+0x36c>)
 800e730:	2200      	movs	r2, #0
 800e732:	4630      	mov	r0, r6
 800e734:	4639      	mov	r1, r7
 800e736:	f019 fe1f 	bl	8028378 <__aeabi_dcmpeq>
 800e73a:	2800      	cmp	r0, #0
 800e73c:	f040 80c8 	bne.w	800e8d0 <cblas_dsyr2k+0x250>
  if (Order == CblasRowMajor) {
 800e740:	2d65      	cmp	r5, #101	; 0x65
 800e742:	f000 80f5 	beq.w	800e930 <cblas_dsyr2k+0x2b0>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800e746:	f1ab 0370 	sub.w	r3, fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800e74a:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800e74e:	b2db      	uxtb	r3, r3
  if (beta == 0.0) {
 800e750:	f04f 0200 	mov.w	r2, #0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800e754:	f000 8243 	beq.w	800ebde <cblas_dsyr2k+0x55e>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800e758:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800e75a:	4630      	mov	r0, r6
 800e75c:	f04f 0300 	mov.w	r3, #0
 800e760:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800e762:	f240 8251 	bls.w	800ec08 <cblas_dsyr2k+0x588>
  if (beta == 0.0) {
 800e766:	f019 fe07 	bl	8028378 <__aeabi_dcmpeq>
 800e76a:	2800      	cmp	r0, #0
 800e76c:	f000 81f9 	beq.w	800eb62 <cblas_dsyr2k+0x4e2>
      for (i = 0; i < N; i++) {
 800e770:	9b00      	ldr	r3, [sp, #0]
 800e772:	2b00      	cmp	r3, #0
      trans = CblasTrans;
 800e774:	bfc8      	it	gt
 800e776:	f04f 0b70 	movgt.w	fp, #112	; 0x70
      for (i = 0; i < N; i++) {
 800e77a:	f340 8226 	ble.w	800ebca <cblas_dsyr2k+0x54a>
 800e77e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e780:	9808      	ldr	r0, [sp, #32]
 800e782:	9d00      	ldr	r5, [sp, #0]
 800e784:	1c5c      	adds	r4, r3, #1
          C[ldc * i + j] = 0.0;
 800e786:	2600      	movs	r6, #0
 800e788:	2700      	movs	r7, #0
 800e78a:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800e78c:	2100      	movs	r1, #0
 800e78e:	4602      	mov	r2, r0
 800e790:	460b      	mov	r3, r1
        for (j = i; j < N; j++) {
 800e792:	3301      	adds	r3, #1
 800e794:	429d      	cmp	r5, r3
          C[ldc * i + j] = 0.0;
 800e796:	e8e2 6702 	strd	r6, r7, [r2], #8
        for (j = i; j < N; j++) {
 800e79a:	dcfa      	bgt.n	800e792 <cblas_dsyr2k+0x112>
      for (i = 0; i < N; i++) {
 800e79c:	3101      	adds	r1, #1
 800e79e:	428d      	cmp	r5, r1
 800e7a0:	4420      	add	r0, r4
 800e7a2:	dcf4      	bgt.n	800e78e <cblas_dsyr2k+0x10e>
  if (alpha == 0.0)
 800e7a4:	ec51 0b1a 	vmov	r0, r1, d10
 800e7a8:	2200      	movs	r2, #0
 800e7aa:	2300      	movs	r3, #0
 800e7ac:	f019 fde4 	bl	8028378 <__aeabi_dcmpeq>
 800e7b0:	2800      	cmp	r0, #0
 800e7b2:	f040 808d 	bne.w	800e8d0 <cblas_dsyr2k+0x250>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800e7b6:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 800e7ba:	f000 823a 	beq.w	800ec32 <cblas_dsyr2k+0x5b2>
  } else if (uplo == CblasUpper && trans == CblasTrans) {
 800e7be:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800e7c2:	f040 8104 	bne.w	800e9ce <cblas_dsyr2k+0x34e>
    for (k = 0; k < K; k++) {
 800e7c6:	9b06      	ldr	r3, [sp, #24]
 800e7c8:	2b00      	cmp	r3, #0
 800e7ca:	f340 8081 	ble.w	800e8d0 <cblas_dsyr2k+0x250>
 800e7ce:	9902      	ldr	r1, [sp, #8]
 800e7d0:	1c4b      	adds	r3, r1, #1
 800e7d2:	00db      	lsls	r3, r3, #3
 800e7d4:	2200      	movs	r2, #0
 800e7d6:	930c      	str	r3, [sp, #48]	; 0x30
 800e7d8:	00cb      	lsls	r3, r1, #3
 800e7da:	e9cd 220e 	strd	r2, r2, [sp, #56]	; 0x38
 800e7de:	920d      	str	r2, [sp, #52]	; 0x34
 800e7e0:	9310      	str	r3, [sp, #64]	; 0x40
 800e7e2:	9a00      	ldr	r2, [sp, #0]
 800e7e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e7e6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e7ea:	930b      	str	r3, [sp, #44]	; 0x2c
      for (i = 0; i < N; i++) {
 800e7ec:	9b00      	ldr	r3, [sp, #0]
 800e7ee:	2b00      	cmp	r3, #0
 800e7f0:	dd5c      	ble.n	800e8ac <cblas_dsyr2k+0x22c>
 800e7f2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e7f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e7f6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e7fa:	9301      	str	r3, [sp, #4]
 800e7fc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800e7fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800e800:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800e804:	9305      	str	r3, [sp, #20]
 800e806:	9b08      	ldr	r3, [sp, #32]
 800e808:	9304      	str	r3, [sp, #16]
 800e80a:	2300      	movs	r3, #0
 800e80c:	9303      	str	r3, [sp, #12]
        BASE temp1 = alpha * A[k * lda + i];
 800e80e:	9b01      	ldr	r3, [sp, #4]
 800e810:	e8f3 8902 	ldrd	r8, r9, [r3], #8
 800e814:	9301      	str	r3, [sp, #4]
 800e816:	4640      	mov	r0, r8
 800e818:	ec53 2b1a 	vmov	r2, r3, d10
 800e81c:	4649      	mov	r1, r9
 800e81e:	f019 fb43 	bl	8027ea8 <__aeabi_dmul>
 800e822:	460d      	mov	r5, r1
        BASE temp2 = alpha * B[k * ldb + i];
 800e824:	9905      	ldr	r1, [sp, #20]
 800e826:	e8f1 6702 	ldrd	r6, r7, [r1], #8
        BASE temp1 = alpha * A[k * lda + i];
 800e82a:	4604      	mov	r4, r0
        BASE temp2 = alpha * B[k * ldb + i];
 800e82c:	9105      	str	r1, [sp, #20]
 800e82e:	ec53 2b1a 	vmov	r2, r3, d10
 800e832:	4630      	mov	r0, r6
 800e834:	4639      	mov	r1, r7
 800e836:	f019 fb37 	bl	8027ea8 <__aeabi_dmul>
        BASE temp1 = alpha * A[k * lda + i];
 800e83a:	ec45 4b18 	vmov	d8, r4, r5
        BASE temp2 = alpha * B[k * ldb + i];
 800e83e:	ec41 0b19 	vmov	d9, r0, r1
 800e842:	e9dd 5b04 	ldrd	r5, fp, [sp, #16]
 800e846:	f8dd a004 	ldr.w	sl, [sp, #4]
 800e84a:	9c03      	ldr	r4, [sp, #12]
 800e84c:	e003      	b.n	800e856 <cblas_dsyr2k+0x1d6>
 800e84e:	e8fb 6702 	ldrd	r6, r7, [fp], #8
 800e852:	e8fa 8902 	ldrd	r8, r9, [sl], #8
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800e856:	4632      	mov	r2, r6
 800e858:	463b      	mov	r3, r7
 800e85a:	ec51 0b18 	vmov	r0, r1, d8
 800e85e:	f019 fb23 	bl	8027ea8 <__aeabi_dmul>
 800e862:	4642      	mov	r2, r8
 800e864:	4606      	mov	r6, r0
 800e866:	460f      	mov	r7, r1
 800e868:	464b      	mov	r3, r9
 800e86a:	ec51 0b19 	vmov	r0, r1, d9
 800e86e:	f019 fb1b 	bl	8027ea8 <__aeabi_dmul>
 800e872:	4602      	mov	r2, r0
 800e874:	460b      	mov	r3, r1
 800e876:	4630      	mov	r0, r6
 800e878:	4639      	mov	r1, r7
 800e87a:	e9d5 6700 	ldrd	r6, r7, [r5]
 800e87e:	f019 f95d 	bl	8027b3c <__adddf3>
 800e882:	463b      	mov	r3, r7
 800e884:	4632      	mov	r2, r6
 800e886:	f019 f959 	bl	8027b3c <__adddf3>
        for (j = i; j < N; j++) {
 800e88a:	9b00      	ldr	r3, [sp, #0]
 800e88c:	3401      	adds	r4, #1
 800e88e:	42a3      	cmp	r3, r4
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800e890:	e8e5 0102 	strd	r0, r1, [r5], #8
        for (j = i; j < N; j++) {
 800e894:	dcdb      	bgt.n	800e84e <cblas_dsyr2k+0x1ce>
      for (i = 0; i < N; i++) {
 800e896:	9b03      	ldr	r3, [sp, #12]
 800e898:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e89a:	3301      	adds	r3, #1
 800e89c:	9303      	str	r3, [sp, #12]
 800e89e:	9b04      	ldr	r3, [sp, #16]
 800e8a0:	4413      	add	r3, r2
 800e8a2:	9304      	str	r3, [sp, #16]
 800e8a4:	9a01      	ldr	r2, [sp, #4]
 800e8a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800e8a8:	4293      	cmp	r3, r2
 800e8aa:	d1b0      	bne.n	800e80e <cblas_dsyr2k+0x18e>
    for (k = 0; k < K; k++) {
 800e8ac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800e8ae:	9910      	ldr	r1, [sp, #64]	; 0x40
 800e8b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800e8b2:	440a      	add	r2, r1
 800e8b4:	920b      	str	r2, [sp, #44]	; 0x2c
 800e8b6:	9902      	ldr	r1, [sp, #8]
 800e8b8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800e8ba:	440a      	add	r2, r1
 800e8bc:	920e      	str	r2, [sp, #56]	; 0x38
 800e8be:	9907      	ldr	r1, [sp, #28]
 800e8c0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800e8c2:	440a      	add	r2, r1
 800e8c4:	920d      	str	r2, [sp, #52]	; 0x34
 800e8c6:	9a06      	ldr	r2, [sp, #24]
 800e8c8:	3301      	adds	r3, #1
 800e8ca:	429a      	cmp	r2, r3
 800e8cc:	930f      	str	r3, [sp, #60]	; 0x3c
 800e8ce:	d18d      	bne.n	800e7ec <cblas_dsyr2k+0x16c>
#define BASE double
#include "source_syr2k_r.h"
#undef BASE
}
 800e8d0:	b015      	add	sp, #84	; 0x54
 800e8d2:	ecbd 8b06 	vpop	{d8-d10}
 800e8d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e8da:	9a00      	ldr	r2, [sp, #0]
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800e8dc:	f1a8 0379 	sub.w	r3, r8, #121	; 0x79
 800e8e0:	2b01      	cmp	r3, #1
 800e8e2:	d919      	bls.n	800e918 <cblas_dsyr2k+0x298>
 800e8e4:	2002      	movs	r0, #2
 800e8e6:	e6fb      	b.n	800e6e0 <cblas_dsyr2k+0x60>
 800e8e8:	9800      	ldr	r0, [sp, #0]
 800e8ea:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e8ec:	2801      	cmp	r0, #1
 800e8ee:	bfb8      	it	lt
 800e8f0:	2001      	movlt	r0, #1
 800e8f2:	4283      	cmp	r3, r0
 800e8f4:	bfb4      	ite	lt
 800e8f6:	200e      	movlt	r0, #14
 800e8f8:	200b      	movge	r0, #11
 800e8fa:	e70d      	b.n	800e718 <cblas_dsyr2k+0x98>
 800e8fc:	4293      	cmp	r3, r2
 800e8fe:	dcf3      	bgt.n	800e8e8 <cblas_dsyr2k+0x268>
 800e900:	9b00      	ldr	r3, [sp, #0]
 800e902:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800e904:	2b01      	cmp	r3, #1
 800e906:	bfb8      	it	lt
 800e908:	2301      	movlt	r3, #1
 800e90a:	4293      	cmp	r3, r2
 800e90c:	f300 815b 	bgt.w	800ebc6 <cblas_dsyr2k+0x546>
 800e910:	2800      	cmp	r0, #0
 800e912:	f43f af05 	beq.w	800e720 <cblas_dsyr2k+0xa0>
 800e916:	e6ff      	b.n	800e718 <cblas_dsyr2k+0x98>
 800e918:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 800e91c:	2801      	cmp	r0, #1
 800e91e:	bf94      	ite	ls
 800e920:	2000      	movls	r0, #0
 800e922:	2001      	movhi	r0, #1
 800e924:	e6d6      	b.n	800e6d4 <cblas_dsyr2k+0x54>
 800e926:	2a6f      	cmp	r2, #111	; 0x6f
 800e928:	f000 8216 	beq.w	800ed58 <cblas_dsyr2k+0x6d8>
 800e92c:	9a00      	ldr	r2, [sp, #0]
 800e92e:	e6cb      	b.n	800e6c8 <cblas_dsyr2k+0x48>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 800e930:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
  if (beta == 0.0) {
 800e934:	f04f 0200 	mov.w	r2, #0
 800e938:	f04f 0300 	mov.w	r3, #0
 800e93c:	4630      	mov	r0, r6
 800e93e:	4639      	mov	r1, r7
 800e940:	bf08      	it	eq
 800e942:	f04f 0b70 	moveq.w	fp, #112	; 0x70
 800e946:	f019 fd17 	bl	8028378 <__aeabi_dcmpeq>
    uplo = Uplo;
 800e94a:	f8cd 8004 	str.w	r8, [sp, #4]
  if (beta == 0.0) {
 800e94e:	2800      	cmp	r0, #0
 800e950:	d150      	bne.n	800e9f4 <cblas_dsyr2k+0x374>
  } else if (beta != 1.0) {
 800e952:	4b26      	ldr	r3, [pc, #152]	; (800e9ec <cblas_dsyr2k+0x36c>)
 800e954:	2200      	movs	r2, #0
 800e956:	4630      	mov	r0, r6
 800e958:	4639      	mov	r1, r7
 800e95a:	f019 fd0d 	bl	8028378 <__aeabi_dcmpeq>
 800e95e:	2800      	cmp	r0, #0
 800e960:	d167      	bne.n	800ea32 <cblas_dsyr2k+0x3b2>
    if (uplo == CblasUpper) {
 800e962:	9b01      	ldr	r3, [sp, #4]
 800e964:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800e966:	9b00      	ldr	r3, [sp, #0]
    if (uplo == CblasUpper) {
 800e968:	f000 82d9 	beq.w	800ef1e <cblas_dsyr2k+0x89e>
      for (i = 0; i < N; i++) {
 800e96c:	2b00      	cmp	r3, #0
 800e96e:	dd23      	ble.n	800e9b8 <cblas_dsyr2k+0x338>
 800e970:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e972:	f8cd b00c 	str.w	fp, [sp, #12]
 800e976:	f103 0a01 	add.w	sl, r3, #1
 800e97a:	9b08      	ldr	r3, [sp, #32]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800e97c:	f04f 0800 	mov.w	r8, #0
 800e980:	ea4f 0aca 	mov.w	sl, sl, lsl #3
      for (i = 0; i < N; i++) {
 800e984:	46c1      	mov	r9, r8
 800e986:	f103 0508 	add.w	r5, r3, #8
 800e98a:	469b      	mov	fp, r3
 800e98c:	eb0b 04c8 	add.w	r4, fp, r8, lsl #3
          C[ldc * i + j] *= beta;
 800e990:	e9d4 0100 	ldrd	r0, r1, [r4]
 800e994:	4632      	mov	r2, r6
 800e996:	463b      	mov	r3, r7
 800e998:	f019 fa86 	bl	8027ea8 <__aeabi_dmul>
 800e99c:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j <= i; j++) {
 800e9a0:	42ac      	cmp	r4, r5
 800e9a2:	d1f5      	bne.n	800e990 <cblas_dsyr2k+0x310>
      for (i = 0; i < N; i++) {
 800e9a4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e9a6:	4498      	add	r8, r3
 800e9a8:	9b00      	ldr	r3, [sp, #0]
 800e9aa:	f109 0901 	add.w	r9, r9, #1
 800e9ae:	454b      	cmp	r3, r9
 800e9b0:	4455      	add	r5, sl
 800e9b2:	dceb      	bgt.n	800e98c <cblas_dsyr2k+0x30c>
 800e9b4:	f8dd b00c 	ldr.w	fp, [sp, #12]
  if (alpha == 0.0)
 800e9b8:	ec51 0b1a 	vmov	r0, r1, d10
 800e9bc:	2200      	movs	r2, #0
 800e9be:	2300      	movs	r3, #0
 800e9c0:	f019 fcda 	bl	8028378 <__aeabi_dcmpeq>
 800e9c4:	2800      	cmp	r0, #0
 800e9c6:	d183      	bne.n	800e8d0 <cblas_dsyr2k+0x250>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800e9c8:	9b01      	ldr	r3, [sp, #4]
 800e9ca:	2b7a      	cmp	r3, #122	; 0x7a
 800e9cc:	d041      	beq.n	800ea52 <cblas_dsyr2k+0x3d2>
    BLAS_ERROR("unrecognized operation");
 800e9ce:	4a08      	ldr	r2, [pc, #32]	; (800e9f0 <cblas_dsyr2k+0x370>)
 800e9d0:	4905      	ldr	r1, [pc, #20]	; (800e9e8 <cblas_dsyr2k+0x368>)
 800e9d2:	2000      	movs	r0, #0
 800e9d4:	b015      	add	sp, #84	; 0x54
 800e9d6:	ecbd 8b06 	vpop	{d8-d10}
 800e9da:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e9de:	f019 b833 	b.w	8027a48 <cblas_xerbla>
 800e9e2:	bf00      	nop
 800e9e4:	08030378 	.word	0x08030378
 800e9e8:	0803064c 	.word	0x0803064c
 800e9ec:	3ff00000 	.word	0x3ff00000
 800e9f0:	080305a8 	.word	0x080305a8
    if (uplo == CblasUpper) {
 800e9f4:	9b01      	ldr	r3, [sp, #4]
 800e9f6:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800e9f8:	9b00      	ldr	r3, [sp, #0]
    if (uplo == CblasUpper) {
 800e9fa:	f000 828c 	beq.w	800ef16 <cblas_dsyr2k+0x896>
      for (i = 0; i < N; i++) {
 800e9fe:	2b00      	cmp	r3, #0
 800ea00:	ddda      	ble.n	800e9b8 <cblas_dsyr2k+0x338>
 800ea02:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ea04:	9a08      	ldr	r2, [sp, #32]
 800ea06:	9d00      	ldr	r5, [sp, #0]
 800ea08:	f8dd c020 	ldr.w	ip, [sp, #32]
 800ea0c:	1c5c      	adds	r4, r3, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ea0e:	2100      	movs	r1, #0
          C[ldc * i + j] = 0.0;
 800ea10:	2600      	movs	r6, #0
 800ea12:	2700      	movs	r7, #0
 800ea14:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800ea16:	4608      	mov	r0, r1
 800ea18:	3208      	adds	r2, #8
 800ea1a:	469e      	mov	lr, r3
 800ea1c:	eb0c 03c1 	add.w	r3, ip, r1, lsl #3
          C[ldc * i + j] = 0.0;
 800ea20:	e8e3 6702 	strd	r6, r7, [r3], #8
        for (j = 0; j <= i; j++) {
 800ea24:	429a      	cmp	r2, r3
 800ea26:	d1fb      	bne.n	800ea20 <cblas_dsyr2k+0x3a0>
      for (i = 0; i < N; i++) {
 800ea28:	3001      	adds	r0, #1
 800ea2a:	4285      	cmp	r5, r0
 800ea2c:	4471      	add	r1, lr
 800ea2e:	4422      	add	r2, r4
 800ea30:	dcf4      	bgt.n	800ea1c <cblas_dsyr2k+0x39c>
  if (alpha == 0.0)
 800ea32:	ec51 0b1a 	vmov	r0, r1, d10
 800ea36:	2200      	movs	r2, #0
 800ea38:	2300      	movs	r3, #0
 800ea3a:	f019 fc9d 	bl	8028378 <__aeabi_dcmpeq>
 800ea3e:	2800      	cmp	r0, #0
 800ea40:	f47f af46 	bne.w	800e8d0 <cblas_dsyr2k+0x250>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800ea44:	9b01      	ldr	r3, [sp, #4]
 800ea46:	2b79      	cmp	r3, #121	; 0x79
 800ea48:	f43f aeb5 	beq.w	800e7b6 <cblas_dsyr2k+0x136>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800ea4c:	9b01      	ldr	r3, [sp, #4]
 800ea4e:	2b7a      	cmp	r3, #122	; 0x7a
 800ea50:	d1bd      	bne.n	800e9ce <cblas_dsyr2k+0x34e>
 800ea52:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 800ea56:	f000 81d2 	beq.w	800edfe <cblas_dsyr2k+0x77e>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 800ea5a:	f1bb 0f70 	cmp.w	fp, #112	; 0x70
 800ea5e:	d1b6      	bne.n	800e9ce <cblas_dsyr2k+0x34e>
    for (k = 0; k < K; k++) {
 800ea60:	9b06      	ldr	r3, [sp, #24]
 800ea62:	2b00      	cmp	r3, #0
 800ea64:	f77f af34 	ble.w	800e8d0 <cblas_dsyr2k+0x250>
 800ea68:	9907      	ldr	r1, [sp, #28]
 800ea6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ea6c:	9a02      	ldr	r2, [sp, #8]
 800ea6e:	9305      	str	r3, [sp, #20]
 800ea70:	00c9      	lsls	r1, r1, #3
 800ea72:	910c      	str	r1, [sp, #48]	; 0x30
 800ea74:	990a      	ldr	r1, [sp, #40]	; 0x28
 800ea76:	9107      	str	r1, [sp, #28]
 800ea78:	9900      	ldr	r1, [sp, #0]
 800ea7a:	00d2      	lsls	r2, r2, #3
 800ea7c:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 800ea80:	9309      	str	r3, [sp, #36]	; 0x24
 800ea82:	f102 0308 	add.w	r3, r2, #8
 800ea86:	930a      	str	r3, [sp, #40]	; 0x28
 800ea88:	2300      	movs	r3, #0
 800ea8a:	920d      	str	r2, [sp, #52]	; 0x34
 800ea8c:	930b      	str	r3, [sp, #44]	; 0x2c
      for (i = 0; i < N; i++) {
 800ea8e:	9b00      	ldr	r3, [sp, #0]
 800ea90:	2b00      	cmp	r3, #0
 800ea92:	dd53      	ble.n	800eb3c <cblas_dsyr2k+0x4bc>
 800ea94:	9b08      	ldr	r3, [sp, #32]
 800ea96:	f103 0b08 	add.w	fp, r3, #8
 800ea9a:	9b07      	ldr	r3, [sp, #28]
 800ea9c:	9304      	str	r3, [sp, #16]
 800ea9e:	9b05      	ldr	r3, [sp, #20]
 800eaa0:	9301      	str	r3, [sp, #4]
 800eaa2:	2300      	movs	r3, #0
 800eaa4:	9303      	str	r3, [sp, #12]
        BASE temp1 = alpha * A[k * lda + i];
 800eaa6:	9c01      	ldr	r4, [sp, #4]
 800eaa8:	ec57 6b1a 	vmov	r6, r7, d10
 800eaac:	e8f4 0102 	ldrd	r0, r1, [r4], #8
 800eab0:	ee1a 2a10 	vmov	r2, s20
 800eab4:	463b      	mov	r3, r7
 800eab6:	9401      	str	r4, [sp, #4]
 800eab8:	f019 f9f6 	bl	8027ea8 <__aeabi_dmul>
        BASE temp2 = alpha * B[k * ldb + i];
 800eabc:	9e04      	ldr	r6, [sp, #16]
        BASE temp1 = alpha * A[k * lda + i];
 800eabe:	4604      	mov	r4, r0
 800eac0:	460d      	mov	r5, r1
        BASE temp2 = alpha * B[k * ldb + i];
 800eac2:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800eac6:	ee1a 2a10 	vmov	r2, s20
 800eaca:	463b      	mov	r3, r7
 800eacc:	9604      	str	r6, [sp, #16]
 800eace:	f019 f9eb 	bl	8027ea8 <__aeabi_dmul>
 800ead2:	9b08      	ldr	r3, [sp, #32]
 800ead4:	9a03      	ldr	r2, [sp, #12]
 800ead6:	f8dd a014 	ldr.w	sl, [sp, #20]
        BASE temp1 = alpha * A[k * lda + i];
 800eada:	ec45 4b18 	vmov	d8, r4, r5
        BASE temp2 = alpha * B[k * ldb + i];
 800eade:	ec41 0b19 	vmov	d9, r0, r1
 800eae2:	9d07      	ldr	r5, [sp, #28]
 800eae4:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
 800eae8:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 800eaec:	ec53 2b18 	vmov	r2, r3, d8
 800eaf0:	f019 f9da 	bl	8027ea8 <__aeabi_dmul>
 800eaf4:	e8fa 6702 	ldrd	r6, r7, [sl], #8
 800eaf8:	ec53 2b19 	vmov	r2, r3, d9
 800eafc:	4680      	mov	r8, r0
 800eafe:	4689      	mov	r9, r1
 800eb00:	4630      	mov	r0, r6
 800eb02:	4639      	mov	r1, r7
 800eb04:	f019 f9d0 	bl	8027ea8 <__aeabi_dmul>
 800eb08:	e9d4 6700 	ldrd	r6, r7, [r4]
 800eb0c:	4602      	mov	r2, r0
 800eb0e:	460b      	mov	r3, r1
 800eb10:	4640      	mov	r0, r8
 800eb12:	4649      	mov	r1, r9
 800eb14:	f019 f812 	bl	8027b3c <__adddf3>
 800eb18:	4632      	mov	r2, r6
 800eb1a:	463b      	mov	r3, r7
 800eb1c:	f019 f80e 	bl	8027b3c <__adddf3>
 800eb20:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j <= i; j++) {
 800eb24:	455c      	cmp	r4, fp
 800eb26:	d1df      	bne.n	800eae8 <cblas_dsyr2k+0x468>
      for (i = 0; i < N; i++) {
 800eb28:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800eb2c:	4413      	add	r3, r2
 800eb2e:	9303      	str	r3, [sp, #12]
 800eb30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800eb32:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800eb34:	449b      	add	fp, r3
 800eb36:	9b01      	ldr	r3, [sp, #4]
 800eb38:	4293      	cmp	r3, r2
 800eb3a:	d1b4      	bne.n	800eaa6 <cblas_dsyr2k+0x426>
    for (k = 0; k < K; k++) {
 800eb3c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800eb3e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800eb40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800eb42:	4608      	mov	r0, r1
 800eb44:	4410      	add	r0, r2
 800eb46:	9907      	ldr	r1, [sp, #28]
 800eb48:	9009      	str	r0, [sp, #36]	; 0x24
 800eb4a:	980c      	ldr	r0, [sp, #48]	; 0x30
 800eb4c:	4401      	add	r1, r0
 800eb4e:	9107      	str	r1, [sp, #28]
 800eb50:	9905      	ldr	r1, [sp, #20]
 800eb52:	4411      	add	r1, r2
 800eb54:	9a06      	ldr	r2, [sp, #24]
 800eb56:	9105      	str	r1, [sp, #20]
 800eb58:	3301      	adds	r3, #1
 800eb5a:	429a      	cmp	r2, r3
 800eb5c:	930b      	str	r3, [sp, #44]	; 0x2c
 800eb5e:	d196      	bne.n	800ea8e <cblas_dsyr2k+0x40e>
 800eb60:	e6b6      	b.n	800e8d0 <cblas_dsyr2k+0x250>
  } else if (beta != 1.0) {
 800eb62:	4ba1      	ldr	r3, [pc, #644]	; (800ede8 <cblas_dsyr2k+0x768>)
 800eb64:	2200      	movs	r2, #0
 800eb66:	4630      	mov	r0, r6
 800eb68:	4639      	mov	r1, r7
 800eb6a:	f019 fc05 	bl	8028378 <__aeabi_dcmpeq>
 800eb6e:	bb60      	cbnz	r0, 800ebca <cblas_dsyr2k+0x54a>
      for (i = 0; i < N; i++) {
 800eb70:	9b00      	ldr	r3, [sp, #0]
 800eb72:	2b00      	cmp	r3, #0
      trans = CblasTrans;
 800eb74:	bfc8      	it	gt
 800eb76:	f04f 0b70 	movgt.w	fp, #112	; 0x70
      for (i = 0; i < N; i++) {
 800eb7a:	dd26      	ble.n	800ebca <cblas_dsyr2k+0x54a>
 800eb7c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800eb7e:	f8dd 9020 	ldr.w	r9, [sp, #32]
 800eb82:	f8cd b004 	str.w	fp, [sp, #4]
 800eb86:	f103 0a01 	add.w	sl, r3, #1
 800eb8a:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 800eb8e:	f04f 0800 	mov.w	r8, #0
 800eb92:	46d3      	mov	fp, sl
 800eb94:	46ca      	mov	sl, r9
 800eb96:	46c1      	mov	r9, r8
 800eb98:	f8dd 8000 	ldr.w	r8, [sp]
 800eb9c:	4655      	mov	r5, sl
 800eb9e:	464c      	mov	r4, r9
          C[ldc * i + j] *= beta;
 800eba0:	e9d5 0100 	ldrd	r0, r1, [r5]
 800eba4:	4632      	mov	r2, r6
 800eba6:	463b      	mov	r3, r7
 800eba8:	f019 f97e 	bl	8027ea8 <__aeabi_dmul>
        for (j = i; j < N; j++) {
 800ebac:	3401      	adds	r4, #1
 800ebae:	45a0      	cmp	r8, r4
          C[ldc * i + j] *= beta;
 800ebb0:	e8e5 0102 	strd	r0, r1, [r5], #8
        for (j = i; j < N; j++) {
 800ebb4:	dcf4      	bgt.n	800eba0 <cblas_dsyr2k+0x520>
      for (i = 0; i < N; i++) {
 800ebb6:	f109 0901 	add.w	r9, r9, #1
 800ebba:	45c8      	cmp	r8, r9
 800ebbc:	44da      	add	sl, fp
 800ebbe:	dced      	bgt.n	800eb9c <cblas_dsyr2k+0x51c>
 800ebc0:	f8dd b004 	ldr.w	fp, [sp, #4]
 800ebc4:	e5ee      	b.n	800e7a4 <cblas_dsyr2k+0x124>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 800ebc6:	200e      	movs	r0, #14
 800ebc8:	e5a6      	b.n	800e718 <cblas_dsyr2k+0x98>
  if (alpha == 0.0)
 800ebca:	ec51 0b1a 	vmov	r0, r1, d10
 800ebce:	2200      	movs	r2, #0
 800ebd0:	2300      	movs	r3, #0
 800ebd2:	f019 fbd1 	bl	8028378 <__aeabi_dcmpeq>
 800ebd6:	2800      	cmp	r0, #0
 800ebd8:	f43f adf5 	beq.w	800e7c6 <cblas_dsyr2k+0x146>
 800ebdc:	e678      	b.n	800e8d0 <cblas_dsyr2k+0x250>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800ebde:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800ebe0:	4630      	mov	r0, r6
 800ebe2:	f04f 0300 	mov.w	r3, #0
 800ebe6:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800ebe8:	f240 80c9 	bls.w	800ed7e <cblas_dsyr2k+0x6fe>
  if (beta == 0.0) {
 800ebec:	f019 fbc4 	bl	8028378 <__aeabi_dcmpeq>
 800ebf0:	2800      	cmp	r0, #0
 800ebf2:	f000 80d6 	beq.w	800eda2 <cblas_dsyr2k+0x722>
      for (i = 0; i < N; i++) {
 800ebf6:	9b00      	ldr	r3, [sp, #0]
 800ebf8:	2b00      	cmp	r3, #0
 800ebfa:	f340 80ea 	ble.w	800edd2 <cblas_dsyr2k+0x752>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ebfe:	237a      	movs	r3, #122	; 0x7a
      trans = CblasTrans;
 800ec00:	f04f 0b70 	mov.w	fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ec04:	9301      	str	r3, [sp, #4]
 800ec06:	e6fc      	b.n	800ea02 <cblas_dsyr2k+0x382>
  if (beta == 0.0) {
 800ec08:	f019 fbb6 	bl	8028378 <__aeabi_dcmpeq>
 800ec0c:	2800      	cmp	r0, #0
 800ec0e:	f000 80a5 	beq.w	800ed5c <cblas_dsyr2k+0x6dc>
      for (i = 0; i < N; i++) {
 800ec12:	9b00      	ldr	r3, [sp, #0]
 800ec14:	2b00      	cmp	r3, #0
      trans = CblasNoTrans;
 800ec16:	bfc8      	it	gt
 800ec18:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800ec1c:	f73f adaf 	bgt.w	800e77e <cblas_dsyr2k+0xfe>
  if (alpha == 0.0)
 800ec20:	ec51 0b1a 	vmov	r0, r1, d10
 800ec24:	2200      	movs	r2, #0
 800ec26:	2300      	movs	r3, #0
 800ec28:	f019 fba6 	bl	8028378 <__aeabi_dcmpeq>
 800ec2c:	2800      	cmp	r0, #0
 800ec2e:	f47f ae4f 	bne.w	800e8d0 <cblas_dsyr2k+0x250>
    for (i = 0; i < N; i++) {
 800ec32:	9b00      	ldr	r3, [sp, #0]
 800ec34:	2b00      	cmp	r3, #0
 800ec36:	f77f ae4b 	ble.w	800e8d0 <cblas_dsyr2k+0x250>
 800ec3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ec3c:	9906      	ldr	r1, [sp, #24]
 800ec3e:	3301      	adds	r3, #1
 800ec40:	00db      	lsls	r3, r3, #3
 800ec42:	9313      	str	r3, [sp, #76]	; 0x4c
 800ec44:	9b08      	ldr	r3, [sp, #32]
 800ec46:	2200      	movs	r2, #0
 800ec48:	e9cd 230f 	strd	r2, r3, [sp, #60]	; 0x3c
 800ec4c:	9b02      	ldr	r3, [sp, #8]
 800ec4e:	920e      	str	r2, [sp, #56]	; 0x38
 800ec50:	00db      	lsls	r3, r3, #3
 800ec52:	9312      	str	r3, [sp, #72]	; 0x48
 800ec54:	9b07      	ldr	r3, [sp, #28]
 800ec56:	920d      	str	r2, [sp, #52]	; 0x34
 800ec58:	00db      	lsls	r3, r3, #3
 800ec5a:	9311      	str	r3, [sp, #68]	; 0x44
 800ec5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ec5e:	eb03 02c1 	add.w	r2, r3, r1, lsl #3
 800ec62:	9201      	str	r2, [sp, #4]
 800ec64:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ec66:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
        BASE temp = 0.0;
 800ec6a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800ec6c:	9303      	str	r3, [sp, #12]
 800ec6e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800ec70:	9304      	str	r3, [sp, #16]
 800ec72:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ec74:	9308      	str	r3, [sp, #32]
 800ec76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ec78:	9305      	str	r3, [sp, #20]
        for (k = 0; k < K; k++) {
 800ec7a:	9b06      	ldr	r3, [sp, #24]
 800ec7c:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800ec7e:	f04f 0400 	mov.w	r4, #0
 800ec82:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800ec86:	dd2a      	ble.n	800ecde <cblas_dsyr2k+0x65e>
 800ec88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ec8a:	9a04      	ldr	r2, [sp, #16]
 800ec8c:	e9dd 760b 	ldrd	r7, r6, [sp, #44]	; 0x2c
 800ec90:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800ec94:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ec96:	9a03      	ldr	r2, [sp, #12]
 800ec98:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
          temp += (A[i * lda + k] * B[j * ldb + k]
 800ec9c:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800eca0:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800eca4:	f019 f900 	bl	8027ea8 <__aeabi_dmul>
                   + B[i * ldb + k] * A[j * lda + k]);
 800eca8:	ecb7 8b02 	vldmia	r7!, {d8}
 800ecac:	e8fa 2302 	ldrd	r2, r3, [sl], #8
          temp += (A[i * lda + k] * B[j * ldb + k]
 800ecb0:	4680      	mov	r8, r0
 800ecb2:	4689      	mov	r9, r1
                   + B[i * ldb + k] * A[j * lda + k]);
 800ecb4:	ec51 0b18 	vmov	r0, r1, d8
 800ecb8:	f019 f8f6 	bl	8027ea8 <__aeabi_dmul>
 800ecbc:	4602      	mov	r2, r0
 800ecbe:	460b      	mov	r3, r1
 800ecc0:	4640      	mov	r0, r8
 800ecc2:	4649      	mov	r1, r9
 800ecc4:	f018 ff3a 	bl	8027b3c <__adddf3>
 800ecc8:	460b      	mov	r3, r1
 800ecca:	4602      	mov	r2, r0
          temp += (A[i * lda + k] * B[j * ldb + k]
 800eccc:	4629      	mov	r1, r5
 800ecce:	4620      	mov	r0, r4
 800ecd0:	f018 ff34 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800ecd4:	9b01      	ldr	r3, [sp, #4]
 800ecd6:	42b3      	cmp	r3, r6
          temp += (A[i * lda + k] * B[j * ldb + k]
 800ecd8:	4604      	mov	r4, r0
 800ecda:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800ecdc:	d1de      	bne.n	800ec9c <cblas_dsyr2k+0x61c>
        C[i * ldc + j] += alpha * temp;
 800ecde:	9e08      	ldr	r6, [sp, #32]
 800ece0:	4620      	mov	r0, r4
 800ece2:	4629      	mov	r1, r5
 800ece4:	e9d6 4500 	ldrd	r4, r5, [r6]
 800ece8:	ec53 2b1a 	vmov	r2, r3, d10
 800ecec:	f019 f8dc 	bl	8027ea8 <__aeabi_dmul>
 800ecf0:	4622      	mov	r2, r4
 800ecf2:	462b      	mov	r3, r5
 800ecf4:	f018 ff22 	bl	8027b3c <__adddf3>
 800ecf8:	9a04      	ldr	r2, [sp, #16]
 800ecfa:	9c07      	ldr	r4, [sp, #28]
      for (j = i; j < N; j++) {
 800ecfc:	9b05      	ldr	r3, [sp, #20]
 800ecfe:	4422      	add	r2, r4
 800ed00:	9204      	str	r2, [sp, #16]
 800ed02:	e9dd 4202 	ldrd	r4, r2, [sp, #8]
 800ed06:	4422      	add	r2, r4
        C[i * ldc + j] += alpha * temp;
 800ed08:	e8e6 0102 	strd	r0, r1, [r6], #8
 800ed0c:	9203      	str	r2, [sp, #12]
      for (j = i; j < N; j++) {
 800ed0e:	9a00      	ldr	r2, [sp, #0]
        C[i * ldc + j] += alpha * temp;
 800ed10:	9608      	str	r6, [sp, #32]
      for (j = i; j < N; j++) {
 800ed12:	3301      	adds	r3, #1
 800ed14:	429a      	cmp	r2, r3
 800ed16:	9305      	str	r3, [sp, #20]
 800ed18:	dcaf      	bgt.n	800ec7a <cblas_dsyr2k+0x5fa>
    for (i = 0; i < N; i++) {
 800ed1a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800ed1c:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800ed1e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800ed20:	440a      	add	r2, r1
 800ed22:	9210      	str	r2, [sp, #64]	; 0x40
 800ed24:	9907      	ldr	r1, [sp, #28]
 800ed26:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800ed28:	440a      	add	r2, r1
 800ed2a:	920f      	str	r2, [sp, #60]	; 0x3c
 800ed2c:	9902      	ldr	r1, [sp, #8]
 800ed2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800ed30:	440a      	add	r2, r1
 800ed32:	990c      	ldr	r1, [sp, #48]	; 0x30
 800ed34:	920e      	str	r2, [sp, #56]	; 0x38
 800ed36:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800ed38:	4608      	mov	r0, r1
 800ed3a:	4410      	add	r0, r2
 800ed3c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800ed3e:	900c      	str	r0, [sp, #48]	; 0x30
 800ed40:	9811      	ldr	r0, [sp, #68]	; 0x44
 800ed42:	4401      	add	r1, r0
 800ed44:	910b      	str	r1, [sp, #44]	; 0x2c
 800ed46:	9901      	ldr	r1, [sp, #4]
 800ed48:	4411      	add	r1, r2
 800ed4a:	9a00      	ldr	r2, [sp, #0]
 800ed4c:	9101      	str	r1, [sp, #4]
 800ed4e:	3301      	adds	r3, #1
 800ed50:	429a      	cmp	r2, r3
 800ed52:	930d      	str	r3, [sp, #52]	; 0x34
 800ed54:	d189      	bne.n	800ec6a <cblas_dsyr2k+0x5ea>
 800ed56:	e5bb      	b.n	800e8d0 <cblas_dsyr2k+0x250>
 800ed58:	9a06      	ldr	r2, [sp, #24]
 800ed5a:	e5bf      	b.n	800e8dc <cblas_dsyr2k+0x25c>
  } else if (beta != 1.0) {
 800ed5c:	4b22      	ldr	r3, [pc, #136]	; (800ede8 <cblas_dsyr2k+0x768>)
 800ed5e:	2200      	movs	r2, #0
 800ed60:	4630      	mov	r0, r6
 800ed62:	4639      	mov	r1, r7
 800ed64:	f019 fb08 	bl	8028378 <__aeabi_dcmpeq>
 800ed68:	2800      	cmp	r0, #0
 800ed6a:	f47f af59 	bne.w	800ec20 <cblas_dsyr2k+0x5a0>
      for (i = 0; i < N; i++) {
 800ed6e:	9b00      	ldr	r3, [sp, #0]
 800ed70:	2b00      	cmp	r3, #0
      trans = CblasNoTrans;
 800ed72:	bfc8      	it	gt
 800ed74:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 800ed78:	f73f af00 	bgt.w	800eb7c <cblas_dsyr2k+0x4fc>
 800ed7c:	e750      	b.n	800ec20 <cblas_dsyr2k+0x5a0>
  if (beta == 0.0) {
 800ed7e:	f019 fafb 	bl	8028378 <__aeabi_dcmpeq>
 800ed82:	b9e8      	cbnz	r0, 800edc0 <cblas_dsyr2k+0x740>
  } else if (beta != 1.0) {
 800ed84:	4b18      	ldr	r3, [pc, #96]	; (800ede8 <cblas_dsyr2k+0x768>)
 800ed86:	2200      	movs	r2, #0
 800ed88:	4630      	mov	r0, r6
 800ed8a:	4639      	mov	r1, r7
 800ed8c:	f019 faf4 	bl	8028378 <__aeabi_dcmpeq>
 800ed90:	bb60      	cbnz	r0, 800edec <cblas_dsyr2k+0x76c>
      for (i = 0; i < N; i++) {
 800ed92:	9b00      	ldr	r3, [sp, #0]
 800ed94:	2b00      	cmp	r3, #0
 800ed96:	dd29      	ble.n	800edec <cblas_dsyr2k+0x76c>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ed98:	237a      	movs	r3, #122	; 0x7a
      trans = CblasNoTrans;
 800ed9a:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800ed9e:	9301      	str	r3, [sp, #4]
 800eda0:	e5e6      	b.n	800e970 <cblas_dsyr2k+0x2f0>
  } else if (beta != 1.0) {
 800eda2:	4b11      	ldr	r3, [pc, #68]	; (800ede8 <cblas_dsyr2k+0x768>)
 800eda4:	2200      	movs	r2, #0
 800eda6:	4630      	mov	r0, r6
 800eda8:	4639      	mov	r1, r7
 800edaa:	f019 fae5 	bl	8028378 <__aeabi_dcmpeq>
 800edae:	b980      	cbnz	r0, 800edd2 <cblas_dsyr2k+0x752>
      for (i = 0; i < N; i++) {
 800edb0:	9b00      	ldr	r3, [sp, #0]
 800edb2:	2b00      	cmp	r3, #0
 800edb4:	dd0d      	ble.n	800edd2 <cblas_dsyr2k+0x752>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800edb6:	237a      	movs	r3, #122	; 0x7a
      trans = CblasTrans;
 800edb8:	f04f 0b70 	mov.w	fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800edbc:	9301      	str	r3, [sp, #4]
 800edbe:	e5d7      	b.n	800e970 <cblas_dsyr2k+0x2f0>
      for (i = 0; i < N; i++) {
 800edc0:	9b00      	ldr	r3, [sp, #0]
 800edc2:	2b00      	cmp	r3, #0
 800edc4:	f77f ad84 	ble.w	800e8d0 <cblas_dsyr2k+0x250>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800edc8:	237a      	movs	r3, #122	; 0x7a
      trans = CblasNoTrans;
 800edca:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800edce:	9301      	str	r3, [sp, #4]
 800edd0:	e617      	b.n	800ea02 <cblas_dsyr2k+0x382>
  if (alpha == 0.0)
 800edd2:	ec51 0b1a 	vmov	r0, r1, d10
 800edd6:	2200      	movs	r2, #0
 800edd8:	2300      	movs	r3, #0
 800edda:	f019 facd 	bl	8028378 <__aeabi_dcmpeq>
 800edde:	2800      	cmp	r0, #0
 800ede0:	f43f ae3e 	beq.w	800ea60 <cblas_dsyr2k+0x3e0>
 800ede4:	e574      	b.n	800e8d0 <cblas_dsyr2k+0x250>
 800ede6:	bf00      	nop
 800ede8:	3ff00000 	.word	0x3ff00000
 800edec:	ec51 0b1a 	vmov	r0, r1, d10
 800edf0:	2200      	movs	r2, #0
 800edf2:	2300      	movs	r3, #0
 800edf4:	f019 fac0 	bl	8028378 <__aeabi_dcmpeq>
 800edf8:	2800      	cmp	r0, #0
 800edfa:	f47f ad69 	bne.w	800e8d0 <cblas_dsyr2k+0x250>
    for (i = 0; i < N; i++) {
 800edfe:	9b00      	ldr	r3, [sp, #0]
 800ee00:	2b00      	cmp	r3, #0
 800ee02:	f77f ad65 	ble.w	800e8d0 <cblas_dsyr2k+0x250>
 800ee06:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ee08:	9906      	ldr	r1, [sp, #24]
 800ee0a:	3301      	adds	r3, #1
 800ee0c:	00db      	lsls	r3, r3, #3
 800ee0e:	9313      	str	r3, [sp, #76]	; 0x4c
 800ee10:	9b08      	ldr	r3, [sp, #32]
 800ee12:	3308      	adds	r3, #8
 800ee14:	930b      	str	r3, [sp, #44]	; 0x2c
 800ee16:	9b02      	ldr	r3, [sp, #8]
 800ee18:	00db      	lsls	r3, r3, #3
 800ee1a:	9312      	str	r3, [sp, #72]	; 0x48
 800ee1c:	9b07      	ldr	r3, [sp, #28]
 800ee1e:	00db      	lsls	r3, r3, #3
 800ee20:	9311      	str	r3, [sp, #68]	; 0x44
 800ee22:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ee24:	2200      	movs	r2, #0
 800ee26:	920f      	str	r2, [sp, #60]	; 0x3c
 800ee28:	9210      	str	r2, [sp, #64]	; 0x40
 800ee2a:	eb03 02c1 	add.w	r2, r3, r1, lsl #3
 800ee2e:	9201      	str	r2, [sp, #4]
 800ee30:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ee32:	e9cd 230d 	strd	r2, r3, [sp, #52]	; 0x34
        BASE temp = 0.0;
 800ee36:	2300      	movs	r3, #0
 800ee38:	e9cd 3303 	strd	r3, r3, [sp, #12]
 800ee3c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800ee3e:	9b08      	ldr	r3, [sp, #32]
 800ee40:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800ee44:	9305      	str	r3, [sp, #20]
        for (k = 0; k < K; k++) {
 800ee46:	9b06      	ldr	r3, [sp, #24]
 800ee48:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800ee4a:	f04f 0400 	mov.w	r4, #0
 800ee4e:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800ee52:	dd2a      	ble.n	800eeaa <cblas_dsyr2k+0x82a>
 800ee54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800ee56:	9a04      	ldr	r2, [sp, #16]
 800ee58:	e9dd 760d 	ldrd	r7, r6, [sp, #52]	; 0x34
 800ee5c:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 800ee60:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ee62:	9a03      	ldr	r2, [sp, #12]
 800ee64:	eb03 0ac2 	add.w	sl, r3, r2, lsl #3
          temp += (A[i * lda + k] * B[j * ldb + k]
 800ee68:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800ee6c:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800ee70:	f019 f81a 	bl	8027ea8 <__aeabi_dmul>
                   + B[i * ldb + k] * A[j * lda + k]);
 800ee74:	ecb7 8b02 	vldmia	r7!, {d8}
 800ee78:	e8fa 2302 	ldrd	r2, r3, [sl], #8
          temp += (A[i * lda + k] * B[j * ldb + k]
 800ee7c:	4680      	mov	r8, r0
 800ee7e:	4689      	mov	r9, r1
                   + B[i * ldb + k] * A[j * lda + k]);
 800ee80:	ec51 0b18 	vmov	r0, r1, d8
 800ee84:	f019 f810 	bl	8027ea8 <__aeabi_dmul>
 800ee88:	4602      	mov	r2, r0
 800ee8a:	460b      	mov	r3, r1
 800ee8c:	4640      	mov	r0, r8
 800ee8e:	4649      	mov	r1, r9
 800ee90:	f018 fe54 	bl	8027b3c <__adddf3>
 800ee94:	460b      	mov	r3, r1
 800ee96:	4602      	mov	r2, r0
          temp += (A[i * lda + k] * B[j * ldb + k]
 800ee98:	4629      	mov	r1, r5
 800ee9a:	4620      	mov	r0, r4
 800ee9c:	f018 fe4e 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800eea0:	9b01      	ldr	r3, [sp, #4]
 800eea2:	42b3      	cmp	r3, r6
          temp += (A[i * lda + k] * B[j * ldb + k]
 800eea4:	4604      	mov	r4, r0
 800eea6:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800eea8:	d1de      	bne.n	800ee68 <cblas_dsyr2k+0x7e8>
        C[i * ldc + j] += alpha * temp;
 800eeaa:	9e05      	ldr	r6, [sp, #20]
 800eeac:	4622      	mov	r2, r4
 800eeae:	462b      	mov	r3, r5
 800eeb0:	e9d6 4500 	ldrd	r4, r5, [r6]
 800eeb4:	ec51 0b1a 	vmov	r0, r1, d10
 800eeb8:	f018 fff6 	bl	8027ea8 <__aeabi_dmul>
 800eebc:	4622      	mov	r2, r4
 800eebe:	462b      	mov	r3, r5
 800eec0:	f018 fe3c 	bl	8027b3c <__adddf3>
 800eec4:	9b04      	ldr	r3, [sp, #16]
 800eec6:	9a07      	ldr	r2, [sp, #28]
 800eec8:	4413      	add	r3, r2
 800eeca:	9304      	str	r3, [sp, #16]
 800eecc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800eed0:	e8e6 0102 	strd	r0, r1, [r6], #8
 800eed4:	4413      	add	r3, r2
 800eed6:	9303      	str	r3, [sp, #12]
      for (j = 0; j <= i; j++) {
 800eed8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        C[i * ldc + j] += alpha * temp;
 800eeda:	9605      	str	r6, [sp, #20]
      for (j = 0; j <= i; j++) {
 800eedc:	42b3      	cmp	r3, r6
 800eede:	d1b2      	bne.n	800ee46 <cblas_dsyr2k+0x7c6>
    for (i = 0; i < N; i++) {
 800eee0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800eee2:	990c      	ldr	r1, [sp, #48]	; 0x30
 800eee4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800eee6:	440a      	add	r2, r1
 800eee8:	920f      	str	r2, [sp, #60]	; 0x3c
 800eeea:	9913      	ldr	r1, [sp, #76]	; 0x4c
 800eeec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800eeee:	440a      	add	r2, r1
 800eef0:	990e      	ldr	r1, [sp, #56]	; 0x38
 800eef2:	920b      	str	r2, [sp, #44]	; 0x2c
 800eef4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800eef6:	4608      	mov	r0, r1
 800eef8:	4410      	add	r0, r2
 800eefa:	990d      	ldr	r1, [sp, #52]	; 0x34
 800eefc:	900e      	str	r0, [sp, #56]	; 0x38
 800eefe:	9811      	ldr	r0, [sp, #68]	; 0x44
 800ef00:	4401      	add	r1, r0
 800ef02:	910d      	str	r1, [sp, #52]	; 0x34
 800ef04:	9901      	ldr	r1, [sp, #4]
 800ef06:	4411      	add	r1, r2
 800ef08:	9a00      	ldr	r2, [sp, #0]
 800ef0a:	9101      	str	r1, [sp, #4]
 800ef0c:	3301      	adds	r3, #1
 800ef0e:	429a      	cmp	r2, r3
 800ef10:	9310      	str	r3, [sp, #64]	; 0x40
 800ef12:	d190      	bne.n	800ee36 <cblas_dsyr2k+0x7b6>
 800ef14:	e4dc      	b.n	800e8d0 <cblas_dsyr2k+0x250>
      for (i = 0; i < N; i++) {
 800ef16:	2b00      	cmp	r3, #0
 800ef18:	f73f ac31 	bgt.w	800e77e <cblas_dsyr2k+0xfe>
 800ef1c:	e442      	b.n	800e7a4 <cblas_dsyr2k+0x124>
      for (i = 0; i < N; i++) {
 800ef1e:	2b00      	cmp	r3, #0
 800ef20:	f73f ae2c 	bgt.w	800eb7c <cblas_dsyr2k+0x4fc>
 800ef24:	e43e      	b.n	800e7a4 <cblas_dsyr2k+0x124>
 800ef26:	bf00      	nop

0800ef28 <cblas_dsyrk>:
void
cblas_dsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const double alpha, const double *A, const int lda,
             const double beta, double *C, const int ldc)
{
 800ef28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ef2c:	ed2d 8b02 	vpush	{d8}
 800ef30:	eeb0 8a40 	vmov.f32	s16, s0
 800ef34:	eef0 8a60 	vmov.f32	s17, s1
 800ef38:	b08d      	sub	sp, #52	; 0x34
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800ef3a:	2865      	cmp	r0, #101	; 0x65
 800ef3c:	9301      	str	r3, [sp, #4]
 800ef3e:	e9dd 8318 	ldrd	r8, r3, [sp, #96]	; 0x60
 800ef42:	9303      	str	r3, [sp, #12]
 800ef44:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 800ef46:	9302      	str	r3, [sp, #8]
 800ef48:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 800ef4a:	9307      	str	r3, [sp, #28]
 800ef4c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800ef4e:	9305      	str	r3, [sp, #20]
 800ef50:	ec57 6b11 	vmov	r6, r7, d1
 800ef54:	4605      	mov	r5, r0
 800ef56:	460c      	mov	r4, r1
 800ef58:	4693      	mov	fp, r2
 800ef5a:	f000 8103 	beq.w	800f164 <cblas_dsyrk+0x23c>
 800ef5e:	2a6f      	cmp	r2, #111	; 0x6f
 800ef60:	d024      	beq.n	800efac <cblas_dsyrk+0x84>
 800ef62:	4643      	mov	r3, r8
 800ef64:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 800ef68:	2a01      	cmp	r2, #1
 800ef6a:	f240 80f4 	bls.w	800f156 <cblas_dsyrk+0x22e>
 800ef6e:	2002      	movs	r0, #2
 800ef70:	f1ab 026f 	sub.w	r2, fp, #111	; 0x6f
 800ef74:	b2d2      	uxtb	r2, r2
 800ef76:	2a03      	cmp	r2, #3
 800ef78:	bf28      	it	cs
 800ef7a:	2003      	movcs	r0, #3
 800ef7c:	9a01      	ldr	r2, [sp, #4]
 800ef7e:	2a00      	cmp	r2, #0
 800ef80:	bfb8      	it	lt
 800ef82:	2004      	movlt	r0, #4
 800ef84:	2b01      	cmp	r3, #1
 800ef86:	bfb8      	it	lt
 800ef88:	2301      	movlt	r3, #1
 800ef8a:	f1b8 0f00 	cmp.w	r8, #0
 800ef8e:	f2c0 80d5 	blt.w	800f13c <cblas_dsyrk+0x214>
 800ef92:	9a02      	ldr	r2, [sp, #8]
 800ef94:	4293      	cmp	r3, r2
 800ef96:	dc11      	bgt.n	800efbc <cblas_dsyrk+0x94>
 800ef98:	9b01      	ldr	r3, [sp, #4]
 800ef9a:	9a05      	ldr	r2, [sp, #20]
 800ef9c:	2b01      	cmp	r3, #1
 800ef9e:	bfb8      	it	lt
 800efa0:	2301      	movlt	r3, #1
 800efa2:	4293      	cmp	r3, r2
 800efa4:	f300 81e1 	bgt.w	800f36a <cblas_dsyrk+0x442>
 800efa8:	b1a8      	cbz	r0, 800efd6 <cblas_dsyrk+0xae>
 800efaa:	e010      	b.n	800efce <cblas_dsyrk+0xa6>
 800efac:	9b01      	ldr	r3, [sp, #4]
 800efae:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 800efb2:	2a01      	cmp	r2, #1
 800efb4:	f240 80cf 	bls.w	800f156 <cblas_dsyrk+0x22e>
 800efb8:	2002      	movs	r0, #2
 800efba:	e7df      	b.n	800ef7c <cblas_dsyrk+0x54>
 800efbc:	9801      	ldr	r0, [sp, #4]
 800efbe:	9b05      	ldr	r3, [sp, #20]
 800efc0:	2801      	cmp	r0, #1
 800efc2:	bfb8      	it	lt
 800efc4:	2001      	movlt	r0, #1
 800efc6:	4283      	cmp	r3, r0
 800efc8:	bfb4      	ite	lt
 800efca:	200b      	movlt	r0, #11
 800efcc:	2008      	movge	r0, #8
 800efce:	4a93      	ldr	r2, [pc, #588]	; (800f21c <cblas_dsyrk+0x2f4>)
 800efd0:	4993      	ldr	r1, [pc, #588]	; (800f220 <cblas_dsyrk+0x2f8>)
 800efd2:	f018 fd39 	bl	8027a48 <cblas_xerbla>
  if (alpha == 0.0 && beta == 1.0)
 800efd6:	ec51 0b18 	vmov	r0, r1, d8
 800efda:	2200      	movs	r2, #0
 800efdc:	2300      	movs	r3, #0
 800efde:	f019 f9cb 	bl	8028378 <__aeabi_dcmpeq>
 800efe2:	b140      	cbz	r0, 800eff6 <cblas_dsyrk+0xce>
 800efe4:	4b8f      	ldr	r3, [pc, #572]	; (800f224 <cblas_dsyrk+0x2fc>)
 800efe6:	2200      	movs	r2, #0
 800efe8:	4630      	mov	r0, r6
 800efea:	4639      	mov	r1, r7
 800efec:	f019 f9c4 	bl	8028378 <__aeabi_dcmpeq>
 800eff0:	2800      	cmp	r0, #0
 800eff2:	f040 809e 	bne.w	800f132 <cblas_dsyrk+0x20a>
  if (Order == CblasRowMajor) {
 800eff6:	2d65      	cmp	r5, #101	; 0x65
 800eff8:	f000 80b9 	beq.w	800f16e <cblas_dsyrk+0x246>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800effc:	f1ab 0370 	sub.w	r3, fp, #112	; 0x70
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f000:	2c79      	cmp	r4, #121	; 0x79
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f002:	b2db      	uxtb	r3, r3
  if (beta == 0.0) {
 800f004:	f04f 0200 	mov.w	r2, #0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f008:	f000 81b1 	beq.w	800f36e <cblas_dsyrk+0x446>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f00c:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800f00e:	4630      	mov	r0, r6
 800f010:	f04f 0300 	mov.w	r3, #0
 800f014:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f016:	f240 81bf 	bls.w	800f398 <cblas_dsyrk+0x470>
  if (beta == 0.0) {
 800f01a:	f019 f9ad 	bl	8028378 <__aeabi_dcmpeq>
 800f01e:	2800      	cmp	r0, #0
 800f020:	f000 8193 	beq.w	800f34a <cblas_dsyrk+0x422>
      for (i = 0; i < N; i++) {
 800f024:	9b01      	ldr	r3, [sp, #4]
 800f026:	2b00      	cmp	r3, #0
 800f028:	f340 8083 	ble.w	800f132 <cblas_dsyrk+0x20a>
      trans = CblasTrans;
 800f02c:	2370      	movs	r3, #112	; 0x70
 800f02e:	9304      	str	r3, [sp, #16]
 800f030:	9b05      	ldr	r3, [sp, #20]
 800f032:	9807      	ldr	r0, [sp, #28]
      for (i = 0; i < N; i++) {
 800f034:	9d01      	ldr	r5, [sp, #4]
 800f036:	1c5c      	adds	r4, r3, #1
          C[ldc * i + j] = 0.0;
 800f038:	2600      	movs	r6, #0
 800f03a:	2700      	movs	r7, #0
 800f03c:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800f03e:	2100      	movs	r1, #0
 800f040:	4602      	mov	r2, r0
 800f042:	460b      	mov	r3, r1
        for (j = i; j < N; j++) {
 800f044:	3301      	adds	r3, #1
 800f046:	429d      	cmp	r5, r3
          C[ldc * i + j] = 0.0;
 800f048:	e8e2 6702 	strd	r6, r7, [r2], #8
        for (j = i; j < N; j++) {
 800f04c:	dcfa      	bgt.n	800f044 <cblas_dsyrk+0x11c>
      for (i = 0; i < N; i++) {
 800f04e:	3101      	adds	r1, #1
 800f050:	428d      	cmp	r5, r1
 800f052:	4420      	add	r0, r4
 800f054:	dcf4      	bgt.n	800f040 <cblas_dsyrk+0x118>
  if (alpha == 0.0)
 800f056:	ec51 0b18 	vmov	r0, r1, d8
 800f05a:	2200      	movs	r2, #0
 800f05c:	2300      	movs	r3, #0
 800f05e:	f019 f98b 	bl	8028378 <__aeabi_dcmpeq>
 800f062:	2800      	cmp	r0, #0
 800f064:	d165      	bne.n	800f132 <cblas_dsyrk+0x20a>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800f066:	9b04      	ldr	r3, [sp, #16]
 800f068:	2b6f      	cmp	r3, #111	; 0x6f
 800f06a:	f000 81b2 	beq.w	800f3d2 <cblas_dsyrk+0x4aa>
  } else if (uplo == CblasUpper && trans == CblasTrans) {
 800f06e:	9b04      	ldr	r3, [sp, #16]
 800f070:	2b70      	cmp	r3, #112	; 0x70
 800f072:	f040 80c9 	bne.w	800f208 <cblas_dsyrk+0x2e0>
    for (i = 0; i < N; i++) {
 800f076:	9b01      	ldr	r3, [sp, #4]
 800f078:	2b00      	cmp	r3, #0
 800f07a:	dd5a      	ble.n	800f132 <cblas_dsyrk+0x20a>
 800f07c:	9b05      	ldr	r3, [sp, #20]
 800f07e:	3301      	adds	r3, #1
 800f080:	00db      	lsls	r3, r3, #3
 800f082:	9308      	str	r3, [sp, #32]
 800f084:	9b07      	ldr	r3, [sp, #28]
 800f086:	9306      	str	r3, [sp, #24]
 800f088:	9b03      	ldr	r3, [sp, #12]
 800f08a:	9304      	str	r3, [sp, #16]
 800f08c:	9b02      	ldr	r3, [sp, #8]
 800f08e:	2700      	movs	r7, #0
 800f090:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 800f094:	9705      	str	r7, [sp, #20]
 800f096:	9b05      	ldr	r3, [sp, #20]
        BASE temp = 0.0;
 800f098:	9a06      	ldr	r2, [sp, #24]
 800f09a:	e9cd 2302 	strd	r2, r3, [sp, #8]
 800f09e:	00de      	lsls	r6, r3, #3
        for (k = 0; k < K; k++) {
 800f0a0:	f1b8 0f00 	cmp.w	r8, #0
        BASE temp = 0.0;
 800f0a4:	f04f 0400 	mov.w	r4, #0
 800f0a8:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800f0ac:	dd19      	ble.n	800f0e2 <cblas_dsyrk+0x1ba>
 800f0ae:	f8dd a010 	ldr.w	sl, [sp, #16]
 800f0b2:	f04f 0b00 	mov.w	fp, #0
          temp += A[k * lda + i] * A[k * lda + j];
 800f0b6:	eb07 030a 	add.w	r3, r7, sl
 800f0ba:	4433      	add	r3, r6
 800f0bc:	e9d3 0100 	ldrd	r0, r1, [r3]
 800f0c0:	e9da 2300 	ldrd	r2, r3, [sl]
 800f0c4:	f018 fef0 	bl	8027ea8 <__aeabi_dmul>
 800f0c8:	4602      	mov	r2, r0
 800f0ca:	460b      	mov	r3, r1
 800f0cc:	4620      	mov	r0, r4
 800f0ce:	4629      	mov	r1, r5
 800f0d0:	f018 fd34 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800f0d4:	f10b 0b01 	add.w	fp, fp, #1
 800f0d8:	45d8      	cmp	r8, fp
          temp += A[k * lda + i] * A[k * lda + j];
 800f0da:	4604      	mov	r4, r0
 800f0dc:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800f0de:	44ca      	add	sl, r9
 800f0e0:	d1e9      	bne.n	800f0b6 <cblas_dsyrk+0x18e>
        C[i * ldc + j] += alpha * temp;
 800f0e2:	9b02      	ldr	r3, [sp, #8]
 800f0e4:	4620      	mov	r0, r4
 800f0e6:	4629      	mov	r1, r5
 800f0e8:	e9d3 4500 	ldrd	r4, r5, [r3]
 800f0ec:	ec53 2b18 	vmov	r2, r3, d8
 800f0f0:	f018 feda 	bl	8027ea8 <__aeabi_dmul>
 800f0f4:	4622      	mov	r2, r4
 800f0f6:	462b      	mov	r3, r5
 800f0f8:	f018 fd20 	bl	8027b3c <__adddf3>
 800f0fc:	9a02      	ldr	r2, [sp, #8]
      for (j = i; j < N; j++) {
 800f0fe:	9b03      	ldr	r3, [sp, #12]
        C[i * ldc + j] += alpha * temp;
 800f100:	e8e2 0102 	strd	r0, r1, [r2], #8
 800f104:	9202      	str	r2, [sp, #8]
      for (j = i; j < N; j++) {
 800f106:	9a01      	ldr	r2, [sp, #4]
 800f108:	3301      	adds	r3, #1
 800f10a:	429a      	cmp	r2, r3
 800f10c:	9303      	str	r3, [sp, #12]
 800f10e:	f106 0608 	add.w	r6, r6, #8
 800f112:	dcc5      	bgt.n	800f0a0 <cblas_dsyrk+0x178>
    for (i = 0; i < N; i++) {
 800f114:	9a06      	ldr	r2, [sp, #24]
 800f116:	9908      	ldr	r1, [sp, #32]
 800f118:	9b05      	ldr	r3, [sp, #20]
 800f11a:	440a      	add	r2, r1
 800f11c:	9206      	str	r2, [sp, #24]
 800f11e:	9a04      	ldr	r2, [sp, #16]
 800f120:	3208      	adds	r2, #8
 800f122:	9204      	str	r2, [sp, #16]
 800f124:	9a01      	ldr	r2, [sp, #4]
 800f126:	3301      	adds	r3, #1
 800f128:	429a      	cmp	r2, r3
 800f12a:	9305      	str	r3, [sp, #20]
 800f12c:	f1a7 0708 	sub.w	r7, r7, #8
 800f130:	d1b1      	bne.n	800f096 <cblas_dsyrk+0x16e>
#define BASE double
#include "source_syrk_r.h"
#undef BASE
}
 800f132:	b00d      	add	sp, #52	; 0x34
 800f134:	ecbd 8b02 	vpop	{d8}
 800f138:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800f13c:	9902      	ldr	r1, [sp, #8]
 800f13e:	428b      	cmp	r3, r1
 800f140:	f73f af3c 	bgt.w	800efbc <cblas_dsyrk+0x94>
 800f144:	2a01      	cmp	r2, #1
 800f146:	9b05      	ldr	r3, [sp, #20]
 800f148:	bfb8      	it	lt
 800f14a:	2201      	movlt	r2, #1
 800f14c:	4293      	cmp	r3, r2
 800f14e:	bfb4      	ite	lt
 800f150:	200b      	movlt	r0, #11
 800f152:	2005      	movge	r0, #5
 800f154:	e73b      	b.n	800efce <cblas_dsyrk+0xa6>
 800f156:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 800f15a:	2801      	cmp	r0, #1
 800f15c:	bf94      	ite	ls
 800f15e:	2000      	movls	r0, #0
 800f160:	2001      	movhi	r0, #1
 800f162:	e705      	b.n	800ef70 <cblas_dsyrk+0x48>
 800f164:	2a6f      	cmp	r2, #111	; 0x6f
 800f166:	f000 8120 	beq.w	800f3aa <cblas_dsyrk+0x482>
 800f16a:	9b01      	ldr	r3, [sp, #4]
 800f16c:	e6fa      	b.n	800ef64 <cblas_dsyrk+0x3c>
    trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
 800f16e:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 800f172:	bf14      	ite	ne
 800f174:	465d      	movne	r5, fp
 800f176:	2570      	moveq	r5, #112	; 0x70
  if (beta == 0.0) {
 800f178:	2200      	movs	r2, #0
 800f17a:	2300      	movs	r3, #0
 800f17c:	4630      	mov	r0, r6
 800f17e:	4639      	mov	r1, r7
 800f180:	9504      	str	r5, [sp, #16]
 800f182:	f019 f8f9 	bl	8028378 <__aeabi_dcmpeq>
    uplo = Uplo;
 800f186:	9406      	str	r4, [sp, #24]
  if (beta == 0.0) {
 800f188:	2800      	cmp	r0, #0
 800f18a:	d14f      	bne.n	800f22c <cblas_dsyrk+0x304>
  } else if (beta != 1.0) {
 800f18c:	4b25      	ldr	r3, [pc, #148]	; (800f224 <cblas_dsyrk+0x2fc>)
 800f18e:	2200      	movs	r2, #0
 800f190:	4630      	mov	r0, r6
 800f192:	4639      	mov	r1, r7
 800f194:	f019 f8f0 	bl	8028378 <__aeabi_dcmpeq>
 800f198:	2800      	cmp	r0, #0
 800f19a:	d166      	bne.n	800f26a <cblas_dsyrk+0x342>
    if (uplo == CblasUpper) {
 800f19c:	9b06      	ldr	r3, [sp, #24]
 800f19e:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800f1a0:	9b01      	ldr	r3, [sp, #4]
    if (uplo == CblasUpper) {
 800f1a2:	f000 8249 	beq.w	800f638 <cblas_dsyrk+0x710>
      for (i = 0; i < N; i++) {
 800f1a6:	2b00      	cmp	r3, #0
 800f1a8:	dd23      	ble.n	800f1f2 <cblas_dsyrk+0x2ca>
 800f1aa:	9b05      	ldr	r3, [sp, #20]
 800f1ac:	f8cd 8020 	str.w	r8, [sp, #32]
 800f1b0:	f103 0a01 	add.w	sl, r3, #1
 800f1b4:	9b07      	ldr	r3, [sp, #28]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f1b6:	f04f 0b00 	mov.w	fp, #0
 800f1ba:	ea4f 0aca 	mov.w	sl, sl, lsl #3
      for (i = 0; i < N; i++) {
 800f1be:	46d9      	mov	r9, fp
 800f1c0:	f103 0508 	add.w	r5, r3, #8
 800f1c4:	4698      	mov	r8, r3
 800f1c6:	eb08 04cb 	add.w	r4, r8, fp, lsl #3
          C[ldc * i + j] *= beta;
 800f1ca:	e9d4 0100 	ldrd	r0, r1, [r4]
 800f1ce:	4632      	mov	r2, r6
 800f1d0:	463b      	mov	r3, r7
 800f1d2:	f018 fe69 	bl	8027ea8 <__aeabi_dmul>
 800f1d6:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j <= i; j++) {
 800f1da:	42a5      	cmp	r5, r4
 800f1dc:	d1f5      	bne.n	800f1ca <cblas_dsyrk+0x2a2>
      for (i = 0; i < N; i++) {
 800f1de:	9b05      	ldr	r3, [sp, #20]
 800f1e0:	449b      	add	fp, r3
 800f1e2:	9b01      	ldr	r3, [sp, #4]
 800f1e4:	f109 0901 	add.w	r9, r9, #1
 800f1e8:	454b      	cmp	r3, r9
 800f1ea:	4455      	add	r5, sl
 800f1ec:	dceb      	bgt.n	800f1c6 <cblas_dsyrk+0x29e>
 800f1ee:	f8dd 8020 	ldr.w	r8, [sp, #32]
  if (alpha == 0.0)
 800f1f2:	ec51 0b18 	vmov	r0, r1, d8
 800f1f6:	2200      	movs	r2, #0
 800f1f8:	2300      	movs	r3, #0
 800f1fa:	f019 f8bd 	bl	8028378 <__aeabi_dcmpeq>
 800f1fe:	2800      	cmp	r0, #0
 800f200:	d197      	bne.n	800f132 <cblas_dsyrk+0x20a>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800f202:	9b06      	ldr	r3, [sp, #24]
 800f204:	2b7a      	cmp	r3, #122	; 0x7a
 800f206:	d040      	beq.n	800f28a <cblas_dsyrk+0x362>
    BLAS_ERROR("unrecognized operation");
 800f208:	4a07      	ldr	r2, [pc, #28]	; (800f228 <cblas_dsyrk+0x300>)
 800f20a:	4905      	ldr	r1, [pc, #20]	; (800f220 <cblas_dsyrk+0x2f8>)
 800f20c:	2000      	movs	r0, #0
 800f20e:	b00d      	add	sp, #52	; 0x34
 800f210:	ecbd 8b02 	vpop	{d8}
 800f214:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f218:	f018 bc16 	b.w	8027a48 <cblas_xerbla>
 800f21c:	08030378 	.word	0x08030378
 800f220:	08030660 	.word	0x08030660
 800f224:	3ff00000 	.word	0x3ff00000
 800f228:	080305a8 	.word	0x080305a8
    if (uplo == CblasUpper) {
 800f22c:	9b06      	ldr	r3, [sp, #24]
 800f22e:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 800f230:	9b01      	ldr	r3, [sp, #4]
    if (uplo == CblasUpper) {
 800f232:	f000 81fa 	beq.w	800f62a <cblas_dsyrk+0x702>
      for (i = 0; i < N; i++) {
 800f236:	2b00      	cmp	r3, #0
 800f238:	dddb      	ble.n	800f1f2 <cblas_dsyrk+0x2ca>
 800f23a:	9b05      	ldr	r3, [sp, #20]
 800f23c:	9a07      	ldr	r2, [sp, #28]
 800f23e:	9d01      	ldr	r5, [sp, #4]
 800f240:	f8dd c01c 	ldr.w	ip, [sp, #28]
 800f244:	1c5c      	adds	r4, r3, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f246:	2100      	movs	r1, #0
          C[ldc * i + j] = 0.0;
 800f248:	2600      	movs	r6, #0
 800f24a:	2700      	movs	r7, #0
 800f24c:	00e4      	lsls	r4, r4, #3
      for (i = 0; i < N; i++) {
 800f24e:	4608      	mov	r0, r1
 800f250:	3208      	adds	r2, #8
 800f252:	469e      	mov	lr, r3
 800f254:	eb0c 03c1 	add.w	r3, ip, r1, lsl #3
          C[ldc * i + j] = 0.0;
 800f258:	e8e3 6702 	strd	r6, r7, [r3], #8
        for (j = 0; j <= i; j++) {
 800f25c:	429a      	cmp	r2, r3
 800f25e:	d1fb      	bne.n	800f258 <cblas_dsyrk+0x330>
      for (i = 0; i < N; i++) {
 800f260:	3001      	adds	r0, #1
 800f262:	4285      	cmp	r5, r0
 800f264:	4471      	add	r1, lr
 800f266:	4422      	add	r2, r4
 800f268:	dcf4      	bgt.n	800f254 <cblas_dsyrk+0x32c>
  if (alpha == 0.0)
 800f26a:	ec51 0b18 	vmov	r0, r1, d8
 800f26e:	2200      	movs	r2, #0
 800f270:	2300      	movs	r3, #0
 800f272:	f019 f881 	bl	8028378 <__aeabi_dcmpeq>
 800f276:	2800      	cmp	r0, #0
 800f278:	f47f af5b 	bne.w	800f132 <cblas_dsyrk+0x20a>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 800f27c:	9b06      	ldr	r3, [sp, #24]
 800f27e:	2b79      	cmp	r3, #121	; 0x79
 800f280:	f43f aef1 	beq.w	800f066 <cblas_dsyrk+0x13e>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 800f284:	9b06      	ldr	r3, [sp, #24]
 800f286:	2b7a      	cmp	r3, #122	; 0x7a
 800f288:	d1be      	bne.n	800f208 <cblas_dsyrk+0x2e0>
 800f28a:	9b04      	ldr	r3, [sp, #16]
 800f28c:	2b6f      	cmp	r3, #111	; 0x6f
 800f28e:	f000 816d 	beq.w	800f56c <cblas_dsyrk+0x644>
  } else if (uplo == CblasLower && trans == CblasTrans) {
 800f292:	9b04      	ldr	r3, [sp, #16]
 800f294:	2b70      	cmp	r3, #112	; 0x70
 800f296:	d1b7      	bne.n	800f208 <cblas_dsyrk+0x2e0>
    for (i = 0; i < N; i++) {
 800f298:	9b01      	ldr	r3, [sp, #4]
 800f29a:	2b00      	cmp	r3, #0
 800f29c:	f77f af49 	ble.w	800f132 <cblas_dsyrk+0x20a>
 800f2a0:	9b02      	ldr	r3, [sp, #8]
 800f2a2:	2700      	movs	r7, #0
 800f2a4:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 800f2a8:	2308      	movs	r3, #8
 800f2aa:	9706      	str	r7, [sp, #24]
 800f2ac:	9708      	str	r7, [sp, #32]
 800f2ae:	9304      	str	r3, [sp, #16]
 800f2b0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 800f2b4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f2b8:	9302      	str	r3, [sp, #8]
        BASE temp = 0.0;
 800f2ba:	2600      	movs	r6, #0
        for (k = 0; k < K; k++) {
 800f2bc:	f1b8 0f00 	cmp.w	r8, #0
        BASE temp = 0.0;
 800f2c0:	f04f 0400 	mov.w	r4, #0
 800f2c4:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800f2c8:	dd1a      	ble.n	800f300 <cblas_dsyrk+0x3d8>
 800f2ca:	9b03      	ldr	r3, [sp, #12]
 800f2cc:	f04f 0b00 	mov.w	fp, #0
 800f2d0:	eba3 0a07 	sub.w	sl, r3, r7
          temp += A[k * lda + i] * A[k * lda + j];
 800f2d4:	eb0a 0307 	add.w	r3, sl, r7
 800f2d8:	4433      	add	r3, r6
 800f2da:	e9d3 0100 	ldrd	r0, r1, [r3]
 800f2de:	e9da 2300 	ldrd	r2, r3, [sl]
 800f2e2:	f018 fde1 	bl	8027ea8 <__aeabi_dmul>
 800f2e6:	4602      	mov	r2, r0
 800f2e8:	460b      	mov	r3, r1
 800f2ea:	4620      	mov	r0, r4
 800f2ec:	4629      	mov	r1, r5
 800f2ee:	f018 fc25 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800f2f2:	f10b 0b01 	add.w	fp, fp, #1
 800f2f6:	45d8      	cmp	r8, fp
          temp += A[k * lda + i] * A[k * lda + j];
 800f2f8:	4604      	mov	r4, r0
 800f2fa:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800f2fc:	44ca      	add	sl, r9
 800f2fe:	d1e9      	bne.n	800f2d4 <cblas_dsyrk+0x3ac>
        C[i * ldc + j] += alpha * temp;
 800f300:	9b02      	ldr	r3, [sp, #8]
 800f302:	4620      	mov	r0, r4
 800f304:	4629      	mov	r1, r5
 800f306:	e9d3 4500 	ldrd	r4, r5, [r3]
 800f30a:	ec53 2b18 	vmov	r2, r3, d8
 800f30e:	f018 fdcb 	bl	8027ea8 <__aeabi_dmul>
 800f312:	462b      	mov	r3, r5
 800f314:	4622      	mov	r2, r4
 800f316:	f018 fc11 	bl	8027b3c <__adddf3>
 800f31a:	9b02      	ldr	r3, [sp, #8]
 800f31c:	e8e3 0102 	strd	r0, r1, [r3], #8
 800f320:	9302      	str	r3, [sp, #8]
      for (j = 0; j <= i; j++) {
 800f322:	9b04      	ldr	r3, [sp, #16]
 800f324:	3608      	adds	r6, #8
 800f326:	42b3      	cmp	r3, r6
 800f328:	d1c8      	bne.n	800f2bc <cblas_dsyrk+0x394>
    for (i = 0; i < N; i++) {
 800f32a:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 800f32e:	440a      	add	r2, r1
 800f330:	9206      	str	r2, [sp, #24]
 800f332:	9a04      	ldr	r2, [sp, #16]
 800f334:	9b08      	ldr	r3, [sp, #32]
 800f336:	3208      	adds	r2, #8
 800f338:	9204      	str	r2, [sp, #16]
 800f33a:	9a01      	ldr	r2, [sp, #4]
 800f33c:	3301      	adds	r3, #1
 800f33e:	429a      	cmp	r2, r3
 800f340:	9308      	str	r3, [sp, #32]
 800f342:	f1a7 0708 	sub.w	r7, r7, #8
 800f346:	d1b3      	bne.n	800f2b0 <cblas_dsyrk+0x388>
 800f348:	e6f3      	b.n	800f132 <cblas_dsyrk+0x20a>
  } else if (beta != 1.0) {
 800f34a:	4bba      	ldr	r3, [pc, #744]	; (800f634 <cblas_dsyrk+0x70c>)
 800f34c:	2200      	movs	r2, #0
 800f34e:	4630      	mov	r0, r6
 800f350:	4639      	mov	r1, r7
 800f352:	f019 f811 	bl	8028378 <__aeabi_dcmpeq>
 800f356:	2800      	cmp	r0, #0
 800f358:	f040 80a9 	bne.w	800f4ae <cblas_dsyrk+0x586>
      for (i = 0; i < N; i++) {
 800f35c:	9b01      	ldr	r3, [sp, #4]
 800f35e:	2b00      	cmp	r3, #0
 800f360:	f77f aee7 	ble.w	800f132 <cblas_dsyrk+0x20a>
      trans = CblasTrans;
 800f364:	2370      	movs	r3, #112	; 0x70
 800f366:	9304      	str	r3, [sp, #16]
 800f368:	e0cb      	b.n	800f502 <cblas_dsyrk+0x5da>
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 800f36a:	200b      	movs	r0, #11
 800f36c:	e62f      	b.n	800efce <cblas_dsyrk+0xa6>
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f36e:	2b01      	cmp	r3, #1
  if (beta == 0.0) {
 800f370:	4630      	mov	r0, r6
 800f372:	f04f 0300 	mov.w	r3, #0
 800f376:	4639      	mov	r1, r7
    if (Trans == CblasTrans || Trans == CblasConjTrans) {
 800f378:	f240 8086 	bls.w	800f488 <cblas_dsyrk+0x560>
  if (beta == 0.0) {
 800f37c:	f018 fffc 	bl	8028378 <__aeabi_dcmpeq>
 800f380:	2800      	cmp	r0, #0
 800f382:	f000 809e 	beq.w	800f4c2 <cblas_dsyrk+0x59a>
      for (i = 0; i < N; i++) {
 800f386:	9b01      	ldr	r3, [sp, #4]
 800f388:	2b00      	cmp	r3, #0
 800f38a:	f340 80dc 	ble.w	800f546 <cblas_dsyrk+0x61e>
      trans = CblasTrans;
 800f38e:	2370      	movs	r3, #112	; 0x70
 800f390:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f392:	237a      	movs	r3, #122	; 0x7a
 800f394:	9306      	str	r3, [sp, #24]
 800f396:	e750      	b.n	800f23a <cblas_dsyrk+0x312>
  if (beta == 0.0) {
 800f398:	f018 ffee 	bl	8028378 <__aeabi_dcmpeq>
 800f39c:	b138      	cbz	r0, 800f3ae <cblas_dsyrk+0x486>
      for (i = 0; i < N; i++) {
 800f39e:	9b01      	ldr	r3, [sp, #4]
 800f3a0:	2b00      	cmp	r3, #0
 800f3a2:	dd0d      	ble.n	800f3c0 <cblas_dsyrk+0x498>
      trans = CblasNoTrans;
 800f3a4:	236f      	movs	r3, #111	; 0x6f
 800f3a6:	9304      	str	r3, [sp, #16]
 800f3a8:	e642      	b.n	800f030 <cblas_dsyrk+0x108>
 800f3aa:	4643      	mov	r3, r8
 800f3ac:	e5ff      	b.n	800efae <cblas_dsyrk+0x86>
  } else if (beta != 1.0) {
 800f3ae:	4ba1      	ldr	r3, [pc, #644]	; (800f634 <cblas_dsyrk+0x70c>)
 800f3b0:	2200      	movs	r2, #0
 800f3b2:	4630      	mov	r0, r6
 800f3b4:	4639      	mov	r1, r7
 800f3b6:	f018 ffdf 	bl	8028378 <__aeabi_dcmpeq>
 800f3ba:	2800      	cmp	r0, #0
 800f3bc:	f000 809b 	beq.w	800f4f6 <cblas_dsyrk+0x5ce>
  if (alpha == 0.0)
 800f3c0:	ec51 0b18 	vmov	r0, r1, d8
 800f3c4:	2200      	movs	r2, #0
 800f3c6:	2300      	movs	r3, #0
 800f3c8:	f018 ffd6 	bl	8028378 <__aeabi_dcmpeq>
 800f3cc:	2800      	cmp	r0, #0
 800f3ce:	f47f aeb0 	bne.w	800f132 <cblas_dsyrk+0x20a>
    for (i = 0; i < N; i++) {
 800f3d2:	9b01      	ldr	r3, [sp, #4]
 800f3d4:	2b00      	cmp	r3, #0
 800f3d6:	f77f aeac 	ble.w	800f132 <cblas_dsyrk+0x20a>
 800f3da:	9b05      	ldr	r3, [sp, #20]
 800f3dc:	3301      	adds	r3, #1
 800f3de:	00db      	lsls	r3, r3, #3
 800f3e0:	930a      	str	r3, [sp, #40]	; 0x28
 800f3e2:	9b02      	ldr	r3, [sp, #8]
 800f3e4:	00db      	lsls	r3, r3, #3
 800f3e6:	9309      	str	r3, [sp, #36]	; 0x24
 800f3e8:	9b03      	ldr	r3, [sp, #12]
 800f3ea:	e9cd 3804 	strd	r3, r8, [sp, #16]
 800f3ee:	2200      	movs	r2, #0
 800f3f0:	9208      	str	r2, [sp, #32]
 800f3f2:	9206      	str	r2, [sp, #24]
 800f3f4:	eb03 06c8 	add.w	r6, r3, r8, lsl #3
        BASE temp = 0.0;
 800f3f8:	e9dd 8907 	ldrd	r8, r9, [sp, #28]
 800f3fc:	9f06      	ldr	r7, [sp, #24]
        for (k = 0; k < K; k++) {
 800f3fe:	9b05      	ldr	r3, [sp, #20]
 800f400:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800f402:	f04f 0400 	mov.w	r4, #0
 800f406:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800f40a:	dd14      	ble.n	800f436 <cblas_dsyrk+0x50e>
 800f40c:	9b03      	ldr	r3, [sp, #12]
 800f40e:	f8dd a010 	ldr.w	sl, [sp, #16]
 800f412:	eb03 0bc9 	add.w	fp, r3, r9, lsl #3
          temp += A[i * lda + k] * A[j * lda + k];
 800f416:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800f41a:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 800f41e:	f018 fd43 	bl	8027ea8 <__aeabi_dmul>
 800f422:	4602      	mov	r2, r0
 800f424:	460b      	mov	r3, r1
 800f426:	4620      	mov	r0, r4
 800f428:	4629      	mov	r1, r5
 800f42a:	f018 fb87 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800f42e:	4556      	cmp	r6, sl
          temp += A[i * lda + k] * A[j * lda + k];
 800f430:	4604      	mov	r4, r0
 800f432:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800f434:	d1ef      	bne.n	800f416 <cblas_dsyrk+0x4ee>
        C[i * ldc + j] += alpha * temp;
 800f436:	4620      	mov	r0, r4
 800f438:	4629      	mov	r1, r5
 800f43a:	e9d8 4500 	ldrd	r4, r5, [r8]
 800f43e:	ec53 2b18 	vmov	r2, r3, d8
 800f442:	f018 fd31 	bl	8027ea8 <__aeabi_dmul>
 800f446:	462b      	mov	r3, r5
 800f448:	4622      	mov	r2, r4
 800f44a:	f018 fb77 	bl	8027b3c <__adddf3>
 800f44e:	9b02      	ldr	r3, [sp, #8]
 800f450:	4499      	add	r9, r3
      for (j = i; j < N; j++) {
 800f452:	9b01      	ldr	r3, [sp, #4]
 800f454:	3701      	adds	r7, #1
 800f456:	42bb      	cmp	r3, r7
        C[i * ldc + j] += alpha * temp;
 800f458:	e8e8 0102 	strd	r0, r1, [r8], #8
      for (j = i; j < N; j++) {
 800f45c:	dccf      	bgt.n	800f3fe <cblas_dsyrk+0x4d6>
    for (i = 0; i < N; i++) {
 800f45e:	9a07      	ldr	r2, [sp, #28]
 800f460:	990a      	ldr	r1, [sp, #40]	; 0x28
 800f462:	9b06      	ldr	r3, [sp, #24]
 800f464:	440a      	add	r2, r1
 800f466:	9207      	str	r2, [sp, #28]
 800f468:	9902      	ldr	r1, [sp, #8]
 800f46a:	9a08      	ldr	r2, [sp, #32]
 800f46c:	440a      	add	r2, r1
 800f46e:	9904      	ldr	r1, [sp, #16]
 800f470:	9208      	str	r2, [sp, #32]
 800f472:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800f474:	4608      	mov	r0, r1
 800f476:	4410      	add	r0, r2
 800f478:	4416      	add	r6, r2
 800f47a:	9a01      	ldr	r2, [sp, #4]
 800f47c:	9004      	str	r0, [sp, #16]
 800f47e:	3301      	adds	r3, #1
 800f480:	429a      	cmp	r2, r3
 800f482:	9306      	str	r3, [sp, #24]
 800f484:	d1b8      	bne.n	800f3f8 <cblas_dsyrk+0x4d0>
 800f486:	e654      	b.n	800f132 <cblas_dsyrk+0x20a>
  if (beta == 0.0) {
 800f488:	f018 ff76 	bl	8028378 <__aeabi_dcmpeq>
 800f48c:	bb50      	cbnz	r0, 800f4e4 <cblas_dsyrk+0x5bc>
  } else if (beta != 1.0) {
 800f48e:	4b69      	ldr	r3, [pc, #420]	; (800f634 <cblas_dsyrk+0x70c>)
 800f490:	2200      	movs	r2, #0
 800f492:	4630      	mov	r0, r6
 800f494:	4639      	mov	r1, r7
 800f496:	f018 ff6f 	bl	8028378 <__aeabi_dcmpeq>
 800f49a:	2800      	cmp	r0, #0
 800f49c:	d15d      	bne.n	800f55a <cblas_dsyrk+0x632>
      for (i = 0; i < N; i++) {
 800f49e:	9b01      	ldr	r3, [sp, #4]
 800f4a0:	2b00      	cmp	r3, #0
 800f4a2:	dd5a      	ble.n	800f55a <cblas_dsyrk+0x632>
      trans = CblasNoTrans;
 800f4a4:	236f      	movs	r3, #111	; 0x6f
 800f4a6:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f4a8:	237a      	movs	r3, #122	; 0x7a
 800f4aa:	9306      	str	r3, [sp, #24]
 800f4ac:	e67d      	b.n	800f1aa <cblas_dsyrk+0x282>
  if (alpha == 0.0)
 800f4ae:	ec51 0b18 	vmov	r0, r1, d8
 800f4b2:	2200      	movs	r2, #0
 800f4b4:	2300      	movs	r3, #0
 800f4b6:	f018 ff5f 	bl	8028378 <__aeabi_dcmpeq>
 800f4ba:	2800      	cmp	r0, #0
 800f4bc:	f43f addb 	beq.w	800f076 <cblas_dsyrk+0x14e>
 800f4c0:	e637      	b.n	800f132 <cblas_dsyrk+0x20a>
  } else if (beta != 1.0) {
 800f4c2:	4b5c      	ldr	r3, [pc, #368]	; (800f634 <cblas_dsyrk+0x70c>)
 800f4c4:	2200      	movs	r2, #0
 800f4c6:	4630      	mov	r0, r6
 800f4c8:	4639      	mov	r1, r7
 800f4ca:	f018 ff55 	bl	8028378 <__aeabi_dcmpeq>
 800f4ce:	2800      	cmp	r0, #0
 800f4d0:	d139      	bne.n	800f546 <cblas_dsyrk+0x61e>
      for (i = 0; i < N; i++) {
 800f4d2:	9b01      	ldr	r3, [sp, #4]
 800f4d4:	2b00      	cmp	r3, #0
 800f4d6:	f77f ae2c 	ble.w	800f132 <cblas_dsyrk+0x20a>
      trans = CblasTrans;
 800f4da:	2370      	movs	r3, #112	; 0x70
 800f4dc:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f4de:	237a      	movs	r3, #122	; 0x7a
 800f4e0:	9306      	str	r3, [sp, #24]
 800f4e2:	e662      	b.n	800f1aa <cblas_dsyrk+0x282>
      for (i = 0; i < N; i++) {
 800f4e4:	9b01      	ldr	r3, [sp, #4]
 800f4e6:	2b00      	cmp	r3, #0
 800f4e8:	f77f ae23 	ble.w	800f132 <cblas_dsyrk+0x20a>
      trans = CblasNoTrans;
 800f4ec:	236f      	movs	r3, #111	; 0x6f
 800f4ee:	9304      	str	r3, [sp, #16]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f4f0:	237a      	movs	r3, #122	; 0x7a
 800f4f2:	9306      	str	r3, [sp, #24]
 800f4f4:	e6a1      	b.n	800f23a <cblas_dsyrk+0x312>
      for (i = 0; i < N; i++) {
 800f4f6:	9b01      	ldr	r3, [sp, #4]
 800f4f8:	2b00      	cmp	r3, #0
 800f4fa:	f77f af61 	ble.w	800f3c0 <cblas_dsyrk+0x498>
      trans = CblasNoTrans;
 800f4fe:	236f      	movs	r3, #111	; 0x6f
 800f500:	9304      	str	r3, [sp, #16]
 800f502:	9b05      	ldr	r3, [sp, #20]
      for (i = 0; i < N; i++) {
 800f504:	f8cd 8018 	str.w	r8, [sp, #24]
 800f508:	f103 0a01 	add.w	sl, r3, #1
 800f50c:	f8dd 901c 	ldr.w	r9, [sp, #28]
 800f510:	f8dd 8004 	ldr.w	r8, [sp, #4]
 800f514:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 800f518:	f04f 0b00 	mov.w	fp, #0
 800f51c:	464d      	mov	r5, r9
 800f51e:	465c      	mov	r4, fp
          C[ldc * i + j] *= beta;
 800f520:	e9d5 0100 	ldrd	r0, r1, [r5]
 800f524:	4632      	mov	r2, r6
 800f526:	463b      	mov	r3, r7
 800f528:	f018 fcbe 	bl	8027ea8 <__aeabi_dmul>
        for (j = i; j < N; j++) {
 800f52c:	3401      	adds	r4, #1
 800f52e:	45a0      	cmp	r8, r4
          C[ldc * i + j] *= beta;
 800f530:	e8e5 0102 	strd	r0, r1, [r5], #8
        for (j = i; j < N; j++) {
 800f534:	dcf4      	bgt.n	800f520 <cblas_dsyrk+0x5f8>
      for (i = 0; i < N; i++) {
 800f536:	f10b 0b01 	add.w	fp, fp, #1
 800f53a:	45d8      	cmp	r8, fp
 800f53c:	44d1      	add	r9, sl
 800f53e:	dced      	bgt.n	800f51c <cblas_dsyrk+0x5f4>
 800f540:	f8dd 8018 	ldr.w	r8, [sp, #24]
 800f544:	e587      	b.n	800f056 <cblas_dsyrk+0x12e>
  if (alpha == 0.0)
 800f546:	ec51 0b18 	vmov	r0, r1, d8
 800f54a:	2200      	movs	r2, #0
 800f54c:	2300      	movs	r3, #0
 800f54e:	f018 ff13 	bl	8028378 <__aeabi_dcmpeq>
 800f552:	2800      	cmp	r0, #0
 800f554:	f43f aea0 	beq.w	800f298 <cblas_dsyrk+0x370>
 800f558:	e5eb      	b.n	800f132 <cblas_dsyrk+0x20a>
 800f55a:	ec51 0b18 	vmov	r0, r1, d8
 800f55e:	2200      	movs	r2, #0
 800f560:	2300      	movs	r3, #0
 800f562:	f018 ff09 	bl	8028378 <__aeabi_dcmpeq>
 800f566:	2800      	cmp	r0, #0
 800f568:	f47f ade3 	bne.w	800f132 <cblas_dsyrk+0x20a>
    for (i = 0; i < N; i++) {
 800f56c:	9b01      	ldr	r3, [sp, #4]
 800f56e:	2b00      	cmp	r3, #0
 800f570:	f77f addf 	ble.w	800f132 <cblas_dsyrk+0x20a>
 800f574:	9b05      	ldr	r3, [sp, #20]
 800f576:	f8cd 8018 	str.w	r8, [sp, #24]
 800f57a:	3301      	adds	r3, #1
 800f57c:	00db      	lsls	r3, r3, #3
 800f57e:	930b      	str	r3, [sp, #44]	; 0x2c
 800f580:	9b07      	ldr	r3, [sp, #28]
 800f582:	f103 0108 	add.w	r1, r3, #8
 800f586:	9b02      	ldr	r3, [sp, #8]
 800f588:	00db      	lsls	r3, r3, #3
 800f58a:	930a      	str	r3, [sp, #40]	; 0x28
 800f58c:	9b03      	ldr	r3, [sp, #12]
 800f58e:	9304      	str	r3, [sp, #16]
 800f590:	2200      	movs	r2, #0
 800f592:	9208      	str	r2, [sp, #32]
 800f594:	9209      	str	r2, [sp, #36]	; 0x24
 800f596:	eb03 06c8 	add.w	r6, r3, r8, lsl #3
 800f59a:	4689      	mov	r9, r1
 800f59c:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
        BASE temp = 0.0;
 800f5a0:	f04f 0800 	mov.w	r8, #0
 800f5a4:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        for (k = 0; k < K; k++) {
 800f5a8:	9b06      	ldr	r3, [sp, #24]
 800f5aa:	2b00      	cmp	r3, #0
        BASE temp = 0.0;
 800f5ac:	f04f 0400 	mov.w	r4, #0
 800f5b0:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < K; k++) {
 800f5b4:	dd14      	ble.n	800f5e0 <cblas_dsyrk+0x6b8>
 800f5b6:	9b03      	ldr	r3, [sp, #12]
 800f5b8:	f8dd a010 	ldr.w	sl, [sp, #16]
 800f5bc:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
          temp += A[i * lda + k] * A[j * lda + k];
 800f5c0:	e8fb 2302 	ldrd	r2, r3, [fp], #8
 800f5c4:	e8fa 0102 	ldrd	r0, r1, [sl], #8
 800f5c8:	f018 fc6e 	bl	8027ea8 <__aeabi_dmul>
 800f5cc:	4602      	mov	r2, r0
 800f5ce:	460b      	mov	r3, r1
 800f5d0:	4620      	mov	r0, r4
 800f5d2:	4629      	mov	r1, r5
 800f5d4:	f018 fab2 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 800f5d8:	4556      	cmp	r6, sl
          temp += A[i * lda + k] * A[j * lda + k];
 800f5da:	4604      	mov	r4, r0
 800f5dc:	460d      	mov	r5, r1
        for (k = 0; k < K; k++) {
 800f5de:	d1ef      	bne.n	800f5c0 <cblas_dsyrk+0x698>
        C[i * ldc + j] += alpha * temp;
 800f5e0:	4620      	mov	r0, r4
 800f5e2:	4629      	mov	r1, r5
 800f5e4:	e9d7 4500 	ldrd	r4, r5, [r7]
 800f5e8:	ec53 2b18 	vmov	r2, r3, d8
 800f5ec:	f018 fc5c 	bl	8027ea8 <__aeabi_dmul>
 800f5f0:	462b      	mov	r3, r5
 800f5f2:	4622      	mov	r2, r4
 800f5f4:	f018 faa2 	bl	8027b3c <__adddf3>
 800f5f8:	e8e7 0102 	strd	r0, r1, [r7], #8
      for (j = 0; j <= i; j++) {
 800f5fc:	9b02      	ldr	r3, [sp, #8]
 800f5fe:	45b9      	cmp	r9, r7
 800f600:	4498      	add	r8, r3
 800f602:	d1d1      	bne.n	800f5a8 <cblas_dsyrk+0x680>
    for (i = 0; i < N; i++) {
 800f604:	9a08      	ldr	r2, [sp, #32]
 800f606:	9905      	ldr	r1, [sp, #20]
 800f608:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f60a:	440a      	add	r2, r1
 800f60c:	9208      	str	r2, [sp, #32]
 800f60e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800f610:	9904      	ldr	r1, [sp, #16]
 800f612:	4491      	add	r9, r2
 800f614:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800f616:	4608      	mov	r0, r1
 800f618:	4410      	add	r0, r2
 800f61a:	4416      	add	r6, r2
 800f61c:	9a01      	ldr	r2, [sp, #4]
 800f61e:	9004      	str	r0, [sp, #16]
 800f620:	3301      	adds	r3, #1
 800f622:	429a      	cmp	r2, r3
 800f624:	9309      	str	r3, [sp, #36]	; 0x24
 800f626:	d1b9      	bne.n	800f59c <cblas_dsyrk+0x674>
 800f628:	e583      	b.n	800f132 <cblas_dsyrk+0x20a>
      for (i = 0; i < N; i++) {
 800f62a:	2b00      	cmp	r3, #0
 800f62c:	f73f ad00 	bgt.w	800f030 <cblas_dsyrk+0x108>
 800f630:	e511      	b.n	800f056 <cblas_dsyrk+0x12e>
 800f632:	bf00      	nop
 800f634:	3ff00000 	.word	0x3ff00000
      for (i = 0; i < N; i++) {
 800f638:	2b00      	cmp	r3, #0
 800f63a:	f73f af62 	bgt.w	800f502 <cblas_dsyrk+0x5da>
 800f63e:	e50a      	b.n	800f056 <cblas_dsyrk+0x12e>

0800f640 <cblas_dtrmm>:
cblas_dtrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const double alpha, const double *A, const int lda, double *B,
             const int ldb)
{
 800f640:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f644:	ed2d 8b02 	vpush	{d8}
 800f648:	eeb0 8a40 	vmov.f32	s16, s0
 800f64c:	eef0 8a60 	vmov.f32	s17, s1
 800f650:	b091      	sub	sp, #68	; 0x44
 800f652:	461e      	mov	r6, r3
 800f654:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 800f658:	9300      	str	r3, [sp, #0]
 800f65a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 800f65c:	9301      	str	r3, [sp, #4]
 800f65e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800f660:	9302      	str	r3, [sp, #8]
 800f662:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 800f664:	9306      	str	r3, [sp, #24]
 800f666:	e9dd 5320 	ldrd	r5, r3, [sp, #128]	; 0x80
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800f66a:	298d      	cmp	r1, #141	; 0x8d
 800f66c:	9304      	str	r3, [sp, #16]
 800f66e:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800f670:	9308      	str	r3, [sp, #32]
 800f672:	460c      	mov	r4, r1
 800f674:	4617      	mov	r7, r2
 800f676:	d062      	beq.n	800f73e <cblas_dtrmm+0xfe>
 800f678:	298e      	cmp	r1, #142	; 0x8e
 800f67a:	f000 8294 	beq.w	800fba6 <cblas_dtrmm+0x566>
 800f67e:	f8dd c008 	ldr.w	ip, [sp, #8]
 800f682:	2302      	movs	r3, #2
 800f684:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 800f688:	2a01      	cmp	r2, #1
 800f68a:	9a00      	ldr	r2, [sp, #0]
 800f68c:	f1a6 016f 	sub.w	r1, r6, #111	; 0x6f
 800f690:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 800f694:	bf88      	it	hi
 800f696:	2303      	movhi	r3, #3
 800f698:	b2d2      	uxtb	r2, r2
 800f69a:	2902      	cmp	r1, #2
 800f69c:	bf88      	it	hi
 800f69e:	2304      	movhi	r3, #4
 800f6a0:	2a02      	cmp	r2, #2
 800f6a2:	9a01      	ldr	r2, [sp, #4]
 800f6a4:	bf28      	it	cs
 800f6a6:	2305      	movcs	r3, #5
 800f6a8:	2a00      	cmp	r2, #0
 800f6aa:	9a02      	ldr	r2, [sp, #8]
 800f6ac:	bfb8      	it	lt
 800f6ae:	2306      	movlt	r3, #6
 800f6b0:	2a00      	cmp	r2, #0
 800f6b2:	bfb8      	it	lt
 800f6b4:	2307      	movlt	r3, #7
 800f6b6:	f1bc 0f01 	cmp.w	ip, #1
 800f6ba:	bfb8      	it	lt
 800f6bc:	f04f 0c01 	movlt.w	ip, #1
 800f6c0:	45ac      	cmp	ip, r5
 800f6c2:	dd2f      	ble.n	800f724 <cblas_dtrmm+0xe4>
 800f6c4:	2865      	cmp	r0, #101	; 0x65
 800f6c6:	f000 80c8 	beq.w	800f85a <cblas_dtrmm+0x21a>
 800f6ca:	9b01      	ldr	r3, [sp, #4]
 800f6cc:	9a08      	ldr	r2, [sp, #32]
 800f6ce:	2b01      	cmp	r3, #1
 800f6d0:	bfb8      	it	lt
 800f6d2:	2301      	movlt	r3, #1
 800f6d4:	4293      	cmp	r3, r2
 800f6d6:	bfcc      	ite	gt
 800f6d8:	230c      	movgt	r3, #12
 800f6da:	230a      	movle	r3, #10
 800f6dc:	4ab0      	ldr	r2, [pc, #704]	; (800f9a0 <cblas_dtrmm+0x360>)
 800f6de:	49b1      	ldr	r1, [pc, #708]	; (800f9a4 <cblas_dtrmm+0x364>)
 800f6e0:	4618      	mov	r0, r3
 800f6e2:	f018 f9b1 	bl	8027a48 <cblas_xerbla>
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 800f6e6:	2c8d      	cmp	r4, #141	; 0x8d
 800f6e8:	bf0c      	ite	eq
 800f6ea:	248e      	moveq	r4, #142	; 0x8e
 800f6ec:	248d      	movne	r4, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 800f6ee:	2f79      	cmp	r7, #121	; 0x79
 800f6f0:	bf0c      	ite	eq
 800f6f2:	277a      	moveq	r7, #122	; 0x7a
 800f6f4:	2779      	movne	r7, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800f6f6:	2e71      	cmp	r6, #113	; 0x71
 800f6f8:	bf08      	it	eq
 800f6fa:	2670      	moveq	r6, #112	; 0x70
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800f6fc:	2c8d      	cmp	r4, #141	; 0x8d
 800f6fe:	d027      	beq.n	800f750 <cblas_dtrmm+0x110>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800f700:	2c8e      	cmp	r4, #142	; 0x8e
 800f702:	d105      	bne.n	800f710 <cblas_dtrmm+0xd0>
 800f704:	2f79      	cmp	r7, #121	; 0x79
 800f706:	f000 80c2 	beq.w	800f88e <cblas_dtrmm+0x24e>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800f70a:	2f7a      	cmp	r7, #122	; 0x7a
 800f70c:	f000 814e 	beq.w	800f9ac <cblas_dtrmm+0x36c>
    BLAS_ERROR("unrecognized operation");
 800f710:	4aa5      	ldr	r2, [pc, #660]	; (800f9a8 <cblas_dtrmm+0x368>)
 800f712:	49a4      	ldr	r1, [pc, #656]	; (800f9a4 <cblas_dtrmm+0x364>)
 800f714:	2000      	movs	r0, #0
#define BASE double
#include "source_trmm_r.h"
#undef BASE
}
 800f716:	b011      	add	sp, #68	; 0x44
 800f718:	ecbd 8b02 	vpop	{d8}
 800f71c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f720:	f018 b992 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800f724:	2865      	cmp	r0, #101	; 0x65
 800f726:	f000 81bf 	beq.w	800faa8 <cblas_dtrmm+0x468>
 800f72a:	9a01      	ldr	r2, [sp, #4]
 800f72c:	9908      	ldr	r1, [sp, #32]
 800f72e:	2a01      	cmp	r2, #1
 800f730:	bfb8      	it	lt
 800f732:	2201      	movlt	r2, #1
 800f734:	428a      	cmp	r2, r1
 800f736:	f340 80a6 	ble.w	800f886 <cblas_dtrmm+0x246>
 800f73a:	230c      	movs	r3, #12
 800f73c:	e7ce      	b.n	800f6dc <cblas_dtrmm+0x9c>
 800f73e:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800f742:	2b01      	cmp	r3, #1
 800f744:	f8dd c004 	ldr.w	ip, [sp, #4]
 800f748:	bf94      	ite	ls
 800f74a:	2300      	movls	r3, #0
 800f74c:	2301      	movhi	r3, #1
 800f74e:	e799      	b.n	800f684 <cblas_dtrmm+0x44>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800f750:	2f79      	cmp	r7, #121	; 0x79
 800f752:	f000 81b2 	beq.w	800faba <cblas_dtrmm+0x47a>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 800f756:	2f7a      	cmp	r7, #122	; 0x7a
 800f758:	d1da      	bne.n	800f710 <cblas_dtrmm+0xd0>
 800f75a:	2e6f      	cmp	r6, #111	; 0x6f
 800f75c:	f000 82e1 	beq.w	800fd22 <cblas_dtrmm+0x6e2>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 800f760:	2e70      	cmp	r6, #112	; 0x70
 800f762:	d1d5      	bne.n	800f710 <cblas_dtrmm+0xd0>
    for (i = 0; i < n1; i++) {
 800f764:	9b02      	ldr	r3, [sp, #8]
 800f766:	2b00      	cmp	r3, #0
 800f768:	f340 8199 	ble.w	800fa9e <cblas_dtrmm+0x45e>
 800f76c:	3501      	adds	r5, #1
 800f76e:	00ea      	lsls	r2, r5, #3
 800f770:	f1a2 0a08 	sub.w	sl, r2, #8
 800f774:	920d      	str	r2, [sp, #52]	; 0x34
 800f776:	9a06      	ldr	r2, [sp, #24]
 800f778:	9209      	str	r2, [sp, #36]	; 0x24
 800f77a:	eb02 010a 	add.w	r1, r2, sl
 800f77e:	9a08      	ldr	r2, [sp, #32]
 800f780:	920b      	str	r2, [sp, #44]	; 0x2c
 800f782:	ea4f 0bc2 	mov.w	fp, r2, lsl #3
 800f786:	2200      	movs	r2, #0
 800f788:	920a      	str	r2, [sp, #40]	; 0x28
 800f78a:	2201      	movs	r2, #1
 800f78c:	9106      	str	r1, [sp, #24]
 800f78e:	9205      	str	r2, [sp, #20]
 800f790:	4699      	mov	r9, r3
      for (j = 0; j < n2; j++) {
 800f792:	9b01      	ldr	r3, [sp, #4]
 800f794:	2b00      	cmp	r3, #0
 800f796:	f340 822a 	ble.w	800fbee <cblas_dtrmm+0x5ae>
 800f79a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 800f79e:	1a9b      	subs	r3, r3, r2
 800f7a0:	00db      	lsls	r3, r3, #3
 800f7a2:	9307      	str	r3, [sp, #28]
 800f7a4:	9b05      	ldr	r3, [sp, #20]
 800f7a6:	930c      	str	r3, [sp, #48]	; 0x30
 800f7a8:	9b04      	ldr	r3, [sp, #16]
 800f7aa:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800f7ae:	9302      	str	r3, [sp, #8]
 800f7b0:	2301      	movs	r3, #1
 800f7b2:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 800f7b4:	9b00      	ldr	r3, [sp, #0]
 800f7b6:	2b83      	cmp	r3, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 800f7b8:	9b02      	ldr	r3, [sp, #8]
        if (nonunit) {
 800f7ba:	d034      	beq.n	800f826 <cblas_dtrmm+0x1e6>
        for (k = i + 1; k < n1; k++) {
 800f7bc:	9e05      	ldr	r6, [sp, #20]
 800f7be:	45b1      	cmp	r9, r6
          temp = B[i * ldb + j];
 800f7c0:	e9d3 4500 	ldrd	r4, r5, [r3]
        for (k = i + 1; k < n1; k++) {
 800f7c4:	dd3b      	ble.n	800f83e <cblas_dtrmm+0x1fe>
 800f7c6:	9b07      	ldr	r3, [sp, #28]
 800f7c8:	9a02      	ldr	r2, [sp, #8]
 800f7ca:	9f06      	ldr	r7, [sp, #24]
 800f7cc:	eb03 0802 	add.w	r8, r3, r2
          temp += A[lda * k + i] * B[k * ldb + j];
 800f7d0:	e9d8 2300 	ldrd	r2, r3, [r8]
 800f7d4:	e9d7 0100 	ldrd	r0, r1, [r7]
 800f7d8:	f018 fb66 	bl	8027ea8 <__aeabi_dmul>
 800f7dc:	4602      	mov	r2, r0
 800f7de:	460b      	mov	r3, r1
 800f7e0:	4620      	mov	r0, r4
 800f7e2:	4629      	mov	r1, r5
 800f7e4:	f018 f9aa 	bl	8027b3c <__adddf3>
        for (k = i + 1; k < n1; k++) {
 800f7e8:	3601      	adds	r6, #1
 800f7ea:	45b1      	cmp	r9, r6
 800f7ec:	44d8      	add	r8, fp
          temp += A[lda * k + i] * B[k * ldb + j];
 800f7ee:	4604      	mov	r4, r0
 800f7f0:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 800f7f2:	4457      	add	r7, sl
 800f7f4:	d1ec      	bne.n	800f7d0 <cblas_dtrmm+0x190>
        B[ldb * i + j] = alpha * temp;
 800f7f6:	4602      	mov	r2, r0
 800f7f8:	460b      	mov	r3, r1
 800f7fa:	ec51 0b18 	vmov	r0, r1, d8
 800f7fe:	f018 fb53 	bl	8027ea8 <__aeabi_dmul>
 800f802:	9b02      	ldr	r3, [sp, #8]
      for (j = 0; j < n2; j++) {
 800f804:	9a03      	ldr	r2, [sp, #12]
        B[ldb * i + j] = alpha * temp;
 800f806:	e9c3 0100 	strd	r0, r1, [r3]
      for (j = 0; j < n2; j++) {
 800f80a:	9b01      	ldr	r3, [sp, #4]
 800f80c:	4293      	cmp	r3, r2
 800f80e:	f340 81f0 	ble.w	800fbf2 <cblas_dtrmm+0x5b2>
 800f812:	9b03      	ldr	r3, [sp, #12]
 800f814:	3301      	adds	r3, #1
 800f816:	9303      	str	r3, [sp, #12]
 800f818:	9b02      	ldr	r3, [sp, #8]
 800f81a:	3308      	adds	r3, #8
 800f81c:	9302      	str	r3, [sp, #8]
        if (nonunit) {
 800f81e:	9b00      	ldr	r3, [sp, #0]
 800f820:	2b83      	cmp	r3, #131	; 0x83
          temp = A[i * lda + i] * B[i * ldb + j];
 800f822:	9b02      	ldr	r3, [sp, #8]
        if (nonunit) {
 800f824:	d1ca      	bne.n	800f7bc <cblas_dtrmm+0x17c>
          temp = A[i * lda + i] * B[i * ldb + j];
 800f826:	9909      	ldr	r1, [sp, #36]	; 0x24
 800f828:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f82c:	e9d1 0100 	ldrd	r0, r1, [r1]
 800f830:	f018 fb3a 	bl	8027ea8 <__aeabi_dmul>
        for (k = i + 1; k < n1; k++) {
 800f834:	9e05      	ldr	r6, [sp, #20]
 800f836:	45b1      	cmp	r9, r6
          temp = A[i * lda + i] * B[i * ldb + j];
 800f838:	4604      	mov	r4, r0
 800f83a:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 800f83c:	dcc3      	bgt.n	800f7c6 <cblas_dtrmm+0x186>
        B[ldb * i + j] = alpha * temp;
 800f83e:	ec53 2b18 	vmov	r2, r3, d8
 800f842:	4620      	mov	r0, r4
 800f844:	4629      	mov	r1, r5
 800f846:	f018 fb2f 	bl	8027ea8 <__aeabi_dmul>
 800f84a:	9b02      	ldr	r3, [sp, #8]
      for (j = 0; j < n2; j++) {
 800f84c:	9a03      	ldr	r2, [sp, #12]
        B[ldb * i + j] = alpha * temp;
 800f84e:	e9c3 0100 	strd	r0, r1, [r3]
      for (j = 0; j < n2; j++) {
 800f852:	9b01      	ldr	r3, [sp, #4]
 800f854:	4293      	cmp	r3, r2
 800f856:	dcdc      	bgt.n	800f812 <cblas_dtrmm+0x1d2>
 800f858:	e121      	b.n	800fa9e <cblas_dtrmm+0x45e>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800f85a:	4613      	mov	r3, r2
 800f85c:	2a01      	cmp	r2, #1
 800f85e:	9a08      	ldr	r2, [sp, #32]
 800f860:	bfb8      	it	lt
 800f862:	2301      	movlt	r3, #1
 800f864:	4293      	cmp	r3, r2
 800f866:	bfcc      	ite	gt
 800f868:	230c      	movgt	r3, #12
 800f86a:	230a      	movle	r3, #10
 800f86c:	4a4c      	ldr	r2, [pc, #304]	; (800f9a0 <cblas_dtrmm+0x360>)
 800f86e:	494d      	ldr	r1, [pc, #308]	; (800f9a4 <cblas_dtrmm+0x364>)
 800f870:	4618      	mov	r0, r3
 800f872:	f018 f8e9 	bl	8027a48 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 800f876:	2e71      	cmp	r6, #113	; 0x71
 800f878:	9b02      	ldr	r3, [sp, #8]
 800f87a:	d100      	bne.n	800f87e <cblas_dtrmm+0x23e>
 800f87c:	2670      	movs	r6, #112	; 0x70
 800f87e:	9a01      	ldr	r2, [sp, #4]
 800f880:	e9cd 3201 	strd	r3, r2, [sp, #4]
 800f884:	e73a      	b.n	800f6fc <cblas_dtrmm+0xbc>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800f886:	2b00      	cmp	r3, #0
 800f888:	f43f af2d 	beq.w	800f6e6 <cblas_dtrmm+0xa6>
 800f88c:	e726      	b.n	800f6dc <cblas_dtrmm+0x9c>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 800f88e:	2e6f      	cmp	r6, #111	; 0x6f
 800f890:	f000 82de 	beq.w	800fe50 <cblas_dtrmm+0x810>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 800f894:	2e70      	cmp	r6, #112	; 0x70
 800f896:	f47f af3b 	bne.w	800f710 <cblas_dtrmm+0xd0>
    for (i = 0; i < n1; i++) {
 800f89a:	9b02      	ldr	r3, [sp, #8]
 800f89c:	2b00      	cmp	r3, #0
 800f89e:	f340 80fe 	ble.w	800fa9e <cblas_dtrmm+0x45e>
 800f8a2:	1c6b      	adds	r3, r5, #1
 800f8a4:	00ea      	lsls	r2, r5, #3
 800f8a6:	00db      	lsls	r3, r3, #3
 800f8a8:	9307      	str	r3, [sp, #28]
 800f8aa:	f102 0308 	add.w	r3, r2, #8
 800f8ae:	930a      	str	r3, [sp, #40]	; 0x28
 800f8b0:	9b01      	ldr	r3, [sp, #4]
 800f8b2:	9209      	str	r2, [sp, #36]	; 0x24
 800f8b4:	00da      	lsls	r2, r3, #3
 800f8b6:	920f      	str	r2, [sp, #60]	; 0x3c
 800f8b8:	9a06      	ldr	r2, [sp, #24]
 800f8ba:	2100      	movs	r1, #0
 800f8bc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800f8c0:	910b      	str	r1, [sp, #44]	; 0x2c
 800f8c2:	910c      	str	r1, [sp, #48]	; 0x30
 800f8c4:	930e      	str	r3, [sp, #56]	; 0x38
      for (j = 0; j < n2; j++) {
 800f8c6:	9b01      	ldr	r3, [sp, #4]
 800f8c8:	2b00      	cmp	r3, #0
 800f8ca:	dd5d      	ble.n	800f988 <cblas_dtrmm+0x348>
 800f8cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800f8ce:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
 800f8d2:	00da      	lsls	r2, r3, #3
 800f8d4:	920d      	str	r2, [sp, #52]	; 0x34
 800f8d6:	9a04      	ldr	r2, [sp, #16]
 800f8d8:	eb02 09c3 	add.w	r9, r2, r3, lsl #3
 800f8dc:	9b06      	ldr	r3, [sp, #24]
 800f8de:	9303      	str	r3, [sp, #12]
 800f8e0:	f103 0b08 	add.w	fp, r3, #8
        if (nonunit) {
 800f8e4:	9b00      	ldr	r3, [sp, #0]
 800f8e6:	2b83      	cmp	r3, #131	; 0x83
      for (j = 0; j < n2; j++) {
 800f8e8:	f04f 0a00 	mov.w	sl, #0
        if (nonunit) {
 800f8ec:	d030      	beq.n	800f950 <cblas_dtrmm+0x310>
        for (k = j + 1; k < n2; k++) {
 800f8ee:	9b01      	ldr	r3, [sp, #4]
 800f8f0:	f10a 0a01 	add.w	sl, sl, #1
 800f8f4:	4553      	cmp	r3, sl
          temp = B[i * ldb + j];
 800f8f6:	e9d9 4500 	ldrd	r4, r5, [r9]
        for (k = j + 1; k < n2; k++) {
 800f8fa:	d037      	beq.n	800f96c <cblas_dtrmm+0x32c>
 800f8fc:	f109 0308 	add.w	r3, r9, #8
 800f900:	9305      	str	r3, [sp, #20]
 800f902:	461f      	mov	r7, r3
 800f904:	465e      	mov	r6, fp
          temp += A[lda * j + k] * B[i * ldb + k];
 800f906:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 800f90a:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800f90e:	f018 facb 	bl	8027ea8 <__aeabi_dmul>
 800f912:	4602      	mov	r2, r0
 800f914:	460b      	mov	r3, r1
 800f916:	4620      	mov	r0, r4
 800f918:	4629      	mov	r1, r5
 800f91a:	f018 f90f 	bl	8027b3c <__adddf3>
        for (k = j + 1; k < n2; k++) {
 800f91e:	45b0      	cmp	r8, r6
          temp += A[lda * j + k] * B[i * ldb + k];
 800f920:	4604      	mov	r4, r0
 800f922:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 800f924:	d1ef      	bne.n	800f906 <cblas_dtrmm+0x2c6>
        B[ldb * i + j] = alpha * temp;
 800f926:	4602      	mov	r2, r0
 800f928:	460b      	mov	r3, r1
 800f92a:	ec51 0b18 	vmov	r0, r1, d8
 800f92e:	f018 fabb 	bl	8027ea8 <__aeabi_dmul>
 800f932:	9b07      	ldr	r3, [sp, #28]
 800f934:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800f936:	449b      	add	fp, r3
 800f938:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800f93a:	4498      	add	r8, r3
 800f93c:	9b03      	ldr	r3, [sp, #12]
 800f93e:	4413      	add	r3, r2
 800f940:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 800f942:	9b00      	ldr	r3, [sp, #0]
 800f944:	2b83      	cmp	r3, #131	; 0x83
        B[ldb * i + j] = alpha * temp;
 800f946:	e9c9 0100 	strd	r0, r1, [r9]
 800f94a:	f8dd 9014 	ldr.w	r9, [sp, #20]
        if (nonunit) {
 800f94e:	d1ce      	bne.n	800f8ee <cblas_dtrmm+0x2ae>
          temp = A[j * lda + j] * B[i * ldb + j];
 800f950:	9903      	ldr	r1, [sp, #12]
 800f952:	e9d9 2300 	ldrd	r2, r3, [r9]
 800f956:	e9d1 0100 	ldrd	r0, r1, [r1]
 800f95a:	f018 faa5 	bl	8027ea8 <__aeabi_dmul>
        for (k = j + 1; k < n2; k++) {
 800f95e:	9b01      	ldr	r3, [sp, #4]
 800f960:	f10a 0a01 	add.w	sl, sl, #1
 800f964:	4553      	cmp	r3, sl
          temp = A[j * lda + j] * B[i * ldb + j];
 800f966:	4604      	mov	r4, r0
 800f968:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 800f96a:	d1c7      	bne.n	800f8fc <cblas_dtrmm+0x2bc>
        B[ldb * i + j] = alpha * temp;
 800f96c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800f96e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800f970:	4413      	add	r3, r2
 800f972:	461e      	mov	r6, r3
 800f974:	4620      	mov	r0, r4
 800f976:	ec53 2b18 	vmov	r2, r3, d8
 800f97a:	4629      	mov	r1, r5
 800f97c:	f018 fa94 	bl	8027ea8 <__aeabi_dmul>
 800f980:	9c04      	ldr	r4, [sp, #16]
 800f982:	4426      	add	r6, r4
 800f984:	e946 0102 	strd	r0, r1, [r6, #-8]
    for (i = 0; i < n1; i++) {
 800f988:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800f98a:	9908      	ldr	r1, [sp, #32]
 800f98c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800f98e:	440a      	add	r2, r1
 800f990:	920b      	str	r2, [sp, #44]	; 0x2c
 800f992:	9a02      	ldr	r2, [sp, #8]
 800f994:	3301      	adds	r3, #1
 800f996:	429a      	cmp	r2, r3
 800f998:	930c      	str	r3, [sp, #48]	; 0x30
 800f99a:	d194      	bne.n	800f8c6 <cblas_dtrmm+0x286>
 800f99c:	e07f      	b.n	800fa9e <cblas_dtrmm+0x45e>
 800f99e:	bf00      	nop
 800f9a0:	08030378 	.word	0x08030378
 800f9a4:	08030670 	.word	0x08030670
 800f9a8:	080305a8 	.word	0x080305a8
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 800f9ac:	2e6f      	cmp	r6, #111	; 0x6f
 800f9ae:	f000 82bd 	beq.w	800ff2c <cblas_dtrmm+0x8ec>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 800f9b2:	2e70      	cmp	r6, #112	; 0x70
 800f9b4:	f47f aeac 	bne.w	800f710 <cblas_dtrmm+0xd0>
    for (i = 0; i < n1; i++) {
 800f9b8:	9b02      	ldr	r3, [sp, #8]
 800f9ba:	2b00      	cmp	r3, #0
 800f9bc:	dd6f      	ble.n	800fa9e <cblas_dtrmm+0x45e>
 800f9be:	9901      	ldr	r1, [sp, #4]
 800f9c0:	1e4b      	subs	r3, r1, #1
 800f9c2:	fb05 1003 	mla	r0, r5, r3, r1
 800f9c6:	1c6a      	adds	r2, r5, #1
 800f9c8:	43ee      	mvns	r6, r5
 800f9ca:	ebc5 7c45 	rsb	ip, r5, r5, lsl #29
 800f9ce:	9d08      	ldr	r5, [sp, #32]
 800f9d0:	00ed      	lsls	r5, r5, #3
 800f9d2:	00d2      	lsls	r2, r2, #3
 800f9d4:	460f      	mov	r7, r1
 800f9d6:	9508      	str	r5, [sp, #32]
 800f9d8:	9906      	ldr	r1, [sp, #24]
 800f9da:	9d06      	ldr	r5, [sp, #24]
 800f9dc:	f1a2 0408 	sub.w	r4, r2, #8
 800f9e0:	fb03 5404 	mla	r4, r3, r4, r5
 800f9e4:	3908      	subs	r1, #8
 800f9e6:	fb03 5302 	mla	r3, r3, r2, r5
 800f9ea:	9309      	str	r3, [sp, #36]	; 0x24
 800f9ec:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
 800f9f0:	930b      	str	r3, [sp, #44]	; 0x2c
 800f9f2:	00f3      	lsls	r3, r6, #3
 800f9f4:	9305      	str	r3, [sp, #20]
 800f9f6:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 800f9fa:	9306      	str	r3, [sp, #24]
 800f9fc:	00fb      	lsls	r3, r7, #3
 800f9fe:	930c      	str	r3, [sp, #48]	; 0x30
 800fa00:	2300      	movs	r3, #0
 800fa02:	940a      	str	r4, [sp, #40]	; 0x28
 800fa04:	9307      	str	r3, [sp, #28]
      for (j = n2; j > 0 && j--;) {
 800fa06:	9b01      	ldr	r3, [sp, #4]
 800fa08:	2b00      	cmp	r3, #0
 800fa0a:	dd3e      	ble.n	800fa8a <cblas_dtrmm+0x44a>
 800fa0c:	9a04      	ldr	r2, [sp, #16]
 800fa0e:	990c      	ldr	r1, [sp, #48]	; 0x30
 800fa10:	e9dd b80a 	ldrd	fp, r8, [sp, #40]	; 0x28
 800fa14:	eb02 0901 	add.w	r9, r2, r1
 800fa18:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800fa1a:	9203      	str	r2, [sp, #12]
 800fa1c:	469a      	mov	sl, r3
        for (k = 0; k < j; k++) {
 800fa1e:	f1ba 0a01 	subs.w	sl, sl, #1
        BASE temp = 0.0;
 800fa22:	f04f 0400 	mov.w	r4, #0
 800fa26:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < j; k++) {
 800fa2a:	d011      	beq.n	800fa50 <cblas_dtrmm+0x410>
 800fa2c:	9f04      	ldr	r7, [sp, #16]
 800fa2e:	465e      	mov	r6, fp
          temp += A[lda * j + k] * B[i * ldb + k];
 800fa30:	e8f7 2302 	ldrd	r2, r3, [r7], #8
 800fa34:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800fa38:	f018 fa36 	bl	8027ea8 <__aeabi_dmul>
 800fa3c:	4602      	mov	r2, r0
 800fa3e:	460b      	mov	r3, r1
 800fa40:	4620      	mov	r0, r4
 800fa42:	4629      	mov	r1, r5
 800fa44:	f018 f87a 	bl	8027b3c <__adddf3>
        for (k = 0; k < j; k++) {
 800fa48:	4546      	cmp	r6, r8
          temp += A[lda * j + k] * B[i * ldb + k];
 800fa4a:	4604      	mov	r4, r0
 800fa4c:	460d      	mov	r5, r1
        for (k = 0; k < j; k++) {
 800fa4e:	d1ef      	bne.n	800fa30 <cblas_dtrmm+0x3f0>
        if (nonunit) {
 800fa50:	9b00      	ldr	r3, [sp, #0]
 800fa52:	2b83      	cmp	r3, #131	; 0x83
 800fa54:	f000 80b0 	beq.w	800fbb8 <cblas_dtrmm+0x578>
          temp += B[i * ldb + j];
 800fa58:	e959 2302 	ldrd	r2, r3, [r9, #-8]
 800fa5c:	4620      	mov	r0, r4
 800fa5e:	4629      	mov	r1, r5
 800fa60:	f018 f86c 	bl	8027b3c <__adddf3>
 800fa64:	f1a9 0908 	sub.w	r9, r9, #8
        B[ldb * i + j] = alpha * temp;
 800fa68:	ec53 2b18 	vmov	r2, r3, d8
 800fa6c:	f018 fa1c 	bl	8027ea8 <__aeabi_dmul>
 800fa70:	9a03      	ldr	r2, [sp, #12]
 800fa72:	9b05      	ldr	r3, [sp, #20]
 800fa74:	4614      	mov	r4, r2
 800fa76:	9a06      	ldr	r2, [sp, #24]
 800fa78:	441c      	add	r4, r3
 800fa7a:	e9c9 0100 	strd	r0, r1, [r9]
      for (j = n2; j > 0 && j--;) {
 800fa7e:	9403      	str	r4, [sp, #12]
 800fa80:	4493      	add	fp, r2
 800fa82:	4498      	add	r8, r3
 800fa84:	f1ba 0f00 	cmp.w	sl, #0
 800fa88:	d1c9      	bne.n	800fa1e <cblas_dtrmm+0x3de>
    for (i = 0; i < n1; i++) {
 800fa8a:	9a04      	ldr	r2, [sp, #16]
 800fa8c:	9908      	ldr	r1, [sp, #32]
 800fa8e:	9b07      	ldr	r3, [sp, #28]
 800fa90:	440a      	add	r2, r1
 800fa92:	9204      	str	r2, [sp, #16]
 800fa94:	9a02      	ldr	r2, [sp, #8]
 800fa96:	3301      	adds	r3, #1
 800fa98:	429a      	cmp	r2, r3
 800fa9a:	9307      	str	r3, [sp, #28]
 800fa9c:	d1b3      	bne.n	800fa06 <cblas_dtrmm+0x3c6>
 800fa9e:	b011      	add	sp, #68	; 0x44
 800faa0:	ecbd 8b02 	vpop	{d8}
 800faa4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800faa8:	9a02      	ldr	r2, [sp, #8]
 800faaa:	9908      	ldr	r1, [sp, #32]
 800faac:	2a01      	cmp	r2, #1
 800faae:	bfb8      	it	lt
 800fab0:	2201      	movlt	r2, #1
 800fab2:	428a      	cmp	r2, r1
 800fab4:	dd73      	ble.n	800fb9e <cblas_dtrmm+0x55e>
 800fab6:	230c      	movs	r3, #12
 800fab8:	e6d8      	b.n	800f86c <cblas_dtrmm+0x22c>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 800faba:	2e6f      	cmp	r6, #111	; 0x6f
 800fabc:	f000 80b1 	beq.w	800fc22 <cblas_dtrmm+0x5e2>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 800fac0:	2e70      	cmp	r6, #112	; 0x70
 800fac2:	f47f ae25 	bne.w	800f710 <cblas_dtrmm+0xd0>
    for (i = n1; i > 0 && i--;) {
 800fac6:	9902      	ldr	r1, [sp, #8]
 800fac8:	2900      	cmp	r1, #0
 800faca:	dde8      	ble.n	800fa9e <cblas_dtrmm+0x45e>
 800facc:	1c6b      	adds	r3, r5, #1
 800face:	43ed      	mvns	r5, r5
 800fad0:	00e8      	lsls	r0, r5, #3
 800fad2:	9a08      	ldr	r2, [sp, #32]
 800fad4:	9008      	str	r0, [sp, #32]
 800fad6:	9806      	ldr	r0, [sp, #24]
 800fad8:	00db      	lsls	r3, r3, #3
 800fada:	f101 3bff 	add.w	fp, r1, #4294967295
 800fade:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 800fae2:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 800fae6:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 800faea:	9105      	str	r1, [sp, #20]
 800faec:	f1a3 0a08 	sub.w	sl, r3, #8
 800faf0:	fb0b 0103 	mla	r1, fp, r3, r0
 800faf4:	00d3      	lsls	r3, r2, #3
 800faf6:	9309      	str	r3, [sp, #36]	; 0x24
 800faf8:	9b04      	ldr	r3, [sp, #16]
 800fafa:	9106      	str	r1, [sp, #24]
 800fafc:	fb0b 3309 	mla	r3, fp, r9, r3
 800fb00:	9307      	str	r3, [sp, #28]
      for (j = 0; j < n2; j++) {
 800fb02:	9b01      	ldr	r3, [sp, #4]
 800fb04:	2b00      	cmp	r3, #0
 800fb06:	dd39      	ble.n	800fb7c <cblas_dtrmm+0x53c>
 800fb08:	9b07      	ldr	r3, [sp, #28]
 800fb0a:	9302      	str	r3, [sp, #8]
 800fb0c:	2300      	movs	r3, #0
 800fb0e:	9303      	str	r3, [sp, #12]
        BASE temp = 0.0;
 800fb10:	2400      	movs	r4, #0
 800fb12:	2500      	movs	r5, #0
        for (k = 0; k < i; k++) {
 800fb14:	f1bb 0f00 	cmp.w	fp, #0
 800fb18:	d018      	beq.n	800fb4c <cblas_dtrmm+0x50c>
 800fb1a:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 800fb1e:	9f05      	ldr	r7, [sp, #20]
 800fb20:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 800fb24:	2600      	movs	r6, #0
          temp += A[lda * k + i] * B[k * ldb + j];
 800fb26:	e9d8 2300 	ldrd	r2, r3, [r8]
 800fb2a:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 800fb2e:	f018 f9bb 	bl	8027ea8 <__aeabi_dmul>
 800fb32:	4602      	mov	r2, r0
 800fb34:	460b      	mov	r3, r1
 800fb36:	4620      	mov	r0, r4
 800fb38:	4629      	mov	r1, r5
 800fb3a:	f017 ffff 	bl	8027b3c <__adddf3>
        for (k = 0; k < i; k++) {
 800fb3e:	3601      	adds	r6, #1
 800fb40:	45b3      	cmp	fp, r6
 800fb42:	44c8      	add	r8, r9
          temp += A[lda * k + i] * B[k * ldb + j];
 800fb44:	4604      	mov	r4, r0
 800fb46:	460d      	mov	r5, r1
        for (k = 0; k < i; k++) {
 800fb48:	4457      	add	r7, sl
 800fb4a:	d1ec      	bne.n	800fb26 <cblas_dtrmm+0x4e6>
        if (nonunit) {
 800fb4c:	9b00      	ldr	r3, [sp, #0]
 800fb4e:	2b83      	cmp	r3, #131	; 0x83
 800fb50:	d040      	beq.n	800fbd4 <cblas_dtrmm+0x594>
          temp += B[i * ldb + j];
 800fb52:	9b02      	ldr	r3, [sp, #8]
 800fb54:	4620      	mov	r0, r4
 800fb56:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb5a:	4629      	mov	r1, r5
 800fb5c:	f017 ffee 	bl	8027b3c <__adddf3>
        B[ldb * i + j] = alpha * temp;
 800fb60:	ec53 2b18 	vmov	r2, r3, d8
 800fb64:	f018 f9a0 	bl	8027ea8 <__aeabi_dmul>
 800fb68:	9a02      	ldr	r2, [sp, #8]
      for (j = 0; j < n2; j++) {
 800fb6a:	9b03      	ldr	r3, [sp, #12]
        B[ldb * i + j] = alpha * temp;
 800fb6c:	e8e2 0102 	strd	r0, r1, [r2], #8
 800fb70:	9202      	str	r2, [sp, #8]
      for (j = 0; j < n2; j++) {
 800fb72:	9a01      	ldr	r2, [sp, #4]
 800fb74:	3301      	adds	r3, #1
 800fb76:	429a      	cmp	r2, r3
 800fb78:	9303      	str	r3, [sp, #12]
 800fb7a:	d1c9      	bne.n	800fb10 <cblas_dtrmm+0x4d0>
    for (i = n1; i > 0 && i--;) {
 800fb7c:	9b06      	ldr	r3, [sp, #24]
 800fb7e:	9a08      	ldr	r2, [sp, #32]
 800fb80:	4413      	add	r3, r2
 800fb82:	9306      	str	r3, [sp, #24]
 800fb84:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800fb86:	9b07      	ldr	r3, [sp, #28]
 800fb88:	4413      	add	r3, r2
 800fb8a:	9307      	str	r3, [sp, #28]
 800fb8c:	9b05      	ldr	r3, [sp, #20]
 800fb8e:	3b08      	subs	r3, #8
 800fb90:	9305      	str	r3, [sp, #20]
 800fb92:	f1bb 0f00 	cmp.w	fp, #0
 800fb96:	d082      	beq.n	800fa9e <cblas_dtrmm+0x45e>
 800fb98:	f10b 3bff 	add.w	fp, fp, #4294967295
 800fb9c:	e7b1      	b.n	800fb02 <cblas_dtrmm+0x4c2>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 800fb9e:	2b00      	cmp	r3, #0
 800fba0:	f43f ae69 	beq.w	800f876 <cblas_dtrmm+0x236>
 800fba4:	e662      	b.n	800f86c <cblas_dtrmm+0x22c>
 800fba6:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 800fbaa:	2b01      	cmp	r3, #1
 800fbac:	f8dd c008 	ldr.w	ip, [sp, #8]
 800fbb0:	bf94      	ite	ls
 800fbb2:	2300      	movls	r3, #0
 800fbb4:	2301      	movhi	r3, #1
 800fbb6:	e565      	b.n	800f684 <cblas_dtrmm+0x44>
          temp += A[j * lda + j] * B[i * ldb + j];
 800fbb8:	9903      	ldr	r1, [sp, #12]
 800fbba:	e959 2302 	ldrd	r2, r3, [r9, #-8]
 800fbbe:	e9d1 0100 	ldrd	r0, r1, [r1]
 800fbc2:	f018 f971 	bl	8027ea8 <__aeabi_dmul>
 800fbc6:	4622      	mov	r2, r4
 800fbc8:	462b      	mov	r3, r5
 800fbca:	f017 ffb7 	bl	8027b3c <__adddf3>
 800fbce:	f1a9 0908 	sub.w	r9, r9, #8
 800fbd2:	e749      	b.n	800fa68 <cblas_dtrmm+0x428>
          temp += A[i * lda + i] * B[i * ldb + j];
 800fbd4:	9b02      	ldr	r3, [sp, #8]
 800fbd6:	9906      	ldr	r1, [sp, #24]
 800fbd8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fbdc:	e9d1 0100 	ldrd	r0, r1, [r1]
 800fbe0:	f018 f962 	bl	8027ea8 <__aeabi_dmul>
 800fbe4:	4622      	mov	r2, r4
 800fbe6:	462b      	mov	r3, r5
 800fbe8:	f017 ffa8 	bl	8027b3c <__adddf3>
 800fbec:	e7b8      	b.n	800fb60 <cblas_dtrmm+0x520>
 800fbee:	9b05      	ldr	r3, [sp, #20]
 800fbf0:	930c      	str	r3, [sp, #48]	; 0x30
    for (i = 0; i < n1; i++) {
 800fbf2:	9b05      	ldr	r3, [sp, #20]
 800fbf4:	9a06      	ldr	r2, [sp, #24]
 800fbf6:	3301      	adds	r3, #1
 800fbf8:	9305      	str	r3, [sp, #20]
 800fbfa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800fbfc:	4611      	mov	r1, r2
 800fbfe:	4419      	add	r1, r3
 800fc00:	9106      	str	r1, [sp, #24]
 800fc02:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800fc04:	9a08      	ldr	r2, [sp, #32]
 800fc06:	4608      	mov	r0, r1
 800fc08:	990a      	ldr	r1, [sp, #40]	; 0x28
 800fc0a:	4410      	add	r0, r2
 800fc0c:	4411      	add	r1, r2
 800fc0e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800fc10:	900b      	str	r0, [sp, #44]	; 0x2c
 800fc12:	441a      	add	r2, r3
 800fc14:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800fc16:	910a      	str	r1, [sp, #40]	; 0x28
 800fc18:	4599      	cmp	r9, r3
 800fc1a:	9209      	str	r2, [sp, #36]	; 0x24
 800fc1c:	f73f adb9 	bgt.w	800f792 <cblas_dtrmm+0x152>
 800fc20:	e73d      	b.n	800fa9e <cblas_dtrmm+0x45e>
    for (i = 0; i < n1; i++) {
 800fc22:	9b02      	ldr	r3, [sp, #8]
 800fc24:	2b00      	cmp	r3, #0
 800fc26:	f77f af3a 	ble.w	800fa9e <cblas_dtrmm+0x45e>
 800fc2a:	3501      	adds	r5, #1
 800fc2c:	00ea      	lsls	r2, r5, #3
 800fc2e:	920b      	str	r2, [sp, #44]	; 0x2c
 800fc30:	3a08      	subs	r2, #8
 800fc32:	920a      	str	r2, [sp, #40]	; 0x28
 800fc34:	9a06      	ldr	r2, [sp, #24]
 800fc36:	eb02 0bc3 	add.w	fp, r2, r3, lsl #3
 800fc3a:	9b08      	ldr	r3, [sp, #32]
 800fc3c:	9309      	str	r3, [sp, #36]	; 0x24
 800fc3e:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 800fc42:	2300      	movs	r3, #0
 800fc44:	f102 0108 	add.w	r1, r2, #8
 800fc48:	9307      	str	r3, [sp, #28]
 800fc4a:	2301      	movs	r3, #1
 800fc4c:	9103      	str	r1, [sp, #12]
 800fc4e:	9305      	str	r3, [sp, #20]
      for (j = 0; j < n2; j++) {
 800fc50:	9b01      	ldr	r3, [sp, #4]
 800fc52:	2b00      	cmp	r3, #0
 800fc54:	f340 80e5 	ble.w	800fe22 <cblas_dtrmm+0x7e2>
 800fc58:	9a07      	ldr	r2, [sp, #28]
 800fc5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fc5c:	1a9b      	subs	r3, r3, r2
 800fc5e:	00db      	lsls	r3, r3, #3
 800fc60:	9306      	str	r3, [sp, #24]
 800fc62:	9b04      	ldr	r3, [sp, #16]
 800fc64:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
        if (nonunit) {
 800fc68:	9b00      	ldr	r3, [sp, #0]
 800fc6a:	2b83      	cmp	r3, #131	; 0x83
      for (j = 0; j < n2; j++) {
 800fc6c:	f04f 0a01 	mov.w	sl, #1
        if (nonunit) {
 800fc70:	d02c      	beq.n	800fccc <cblas_dtrmm+0x68c>
        for (k = i + 1; k < n1; k++) {
 800fc72:	9b02      	ldr	r3, [sp, #8]
 800fc74:	9a05      	ldr	r2, [sp, #20]
 800fc76:	4293      	cmp	r3, r2
          temp = B[i * ldb + j];
 800fc78:	e9d9 4500 	ldrd	r4, r5, [r9]
        for (k = i + 1; k < n1; k++) {
 800fc7c:	dd33      	ble.n	800fce6 <cblas_dtrmm+0x6a6>
 800fc7e:	9b06      	ldr	r3, [sp, #24]
 800fc80:	9e03      	ldr	r6, [sp, #12]
 800fc82:	eb03 0709 	add.w	r7, r3, r9
          temp += A[lda * i + k] * B[k * ldb + j];
 800fc86:	e9d7 2300 	ldrd	r2, r3, [r7]
 800fc8a:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800fc8e:	f018 f90b 	bl	8027ea8 <__aeabi_dmul>
 800fc92:	4602      	mov	r2, r0
 800fc94:	460b      	mov	r3, r1
 800fc96:	4620      	mov	r0, r4
 800fc98:	4629      	mov	r1, r5
 800fc9a:	f017 ff4f 	bl	8027b3c <__adddf3>
        for (k = i + 1; k < n1; k++) {
 800fc9e:	45b3      	cmp	fp, r6
 800fca0:	4447      	add	r7, r8
          temp += A[lda * i + k] * B[k * ldb + j];
 800fca2:	4604      	mov	r4, r0
 800fca4:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 800fca6:	d1ee      	bne.n	800fc86 <cblas_dtrmm+0x646>
        B[ldb * i + j] = alpha * temp;
 800fca8:	460b      	mov	r3, r1
 800fcaa:	4602      	mov	r2, r0
 800fcac:	ec51 0b18 	vmov	r0, r1, d8
 800fcb0:	f018 f8fa 	bl	8027ea8 <__aeabi_dmul>
      for (j = 0; j < n2; j++) {
 800fcb4:	9b01      	ldr	r3, [sp, #4]
 800fcb6:	4553      	cmp	r3, sl
        B[ldb * i + j] = alpha * temp;
 800fcb8:	e9c9 0100 	strd	r0, r1, [r9]
      for (j = 0; j < n2; j++) {
 800fcbc:	dd1f      	ble.n	800fcfe <cblas_dtrmm+0x6be>
        if (nonunit) {
 800fcbe:	9b00      	ldr	r3, [sp, #0]
 800fcc0:	2b83      	cmp	r3, #131	; 0x83
 800fcc2:	f10a 0a01 	add.w	sl, sl, #1
 800fcc6:	f109 0908 	add.w	r9, r9, #8
 800fcca:	d1d2      	bne.n	800fc72 <cblas_dtrmm+0x632>
          temp = A[i * lda + i] * B[i * ldb + j];
 800fccc:	9903      	ldr	r1, [sp, #12]
 800fcce:	e9d9 2300 	ldrd	r2, r3, [r9]
 800fcd2:	e951 0102 	ldrd	r0, r1, [r1, #-8]
 800fcd6:	f018 f8e7 	bl	8027ea8 <__aeabi_dmul>
        for (k = i + 1; k < n1; k++) {
 800fcda:	9b02      	ldr	r3, [sp, #8]
 800fcdc:	9a05      	ldr	r2, [sp, #20]
 800fcde:	4293      	cmp	r3, r2
          temp = A[i * lda + i] * B[i * ldb + j];
 800fce0:	4604      	mov	r4, r0
 800fce2:	460d      	mov	r5, r1
        for (k = i + 1; k < n1; k++) {
 800fce4:	dccb      	bgt.n	800fc7e <cblas_dtrmm+0x63e>
        B[ldb * i + j] = alpha * temp;
 800fce6:	ec53 2b18 	vmov	r2, r3, d8
 800fcea:	4620      	mov	r0, r4
 800fcec:	4629      	mov	r1, r5
 800fcee:	f018 f8db 	bl	8027ea8 <__aeabi_dmul>
      for (j = 0; j < n2; j++) {
 800fcf2:	9b01      	ldr	r3, [sp, #4]
 800fcf4:	459a      	cmp	sl, r3
        B[ldb * i + j] = alpha * temp;
 800fcf6:	e9c9 0100 	strd	r0, r1, [r9]
      for (j = 0; j < n2; j++) {
 800fcfa:	dbe0      	blt.n	800fcbe <cblas_dtrmm+0x67e>
 800fcfc:	e6cf      	b.n	800fa9e <cblas_dtrmm+0x45e>
    for (i = 0; i < n1; i++) {
 800fcfe:	9b05      	ldr	r3, [sp, #20]
 800fd00:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800fd02:	3301      	adds	r3, #1
 800fd04:	9305      	str	r3, [sp, #20]
 800fd06:	9b03      	ldr	r3, [sp, #12]
 800fd08:	4413      	add	r3, r2
 800fd0a:	9303      	str	r3, [sp, #12]
 800fd0c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800fd0e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800fd10:	4611      	mov	r1, r2
 800fd12:	449b      	add	fp, r3
 800fd14:	9a07      	ldr	r2, [sp, #28]
 800fd16:	9b08      	ldr	r3, [sp, #32]
 800fd18:	4419      	add	r1, r3
 800fd1a:	441a      	add	r2, r3
 800fd1c:	9109      	str	r1, [sp, #36]	; 0x24
 800fd1e:	9207      	str	r2, [sp, #28]
 800fd20:	e796      	b.n	800fc50 <cblas_dtrmm+0x610>
    for (i = n1; i > 0 && i--;) {
 800fd22:	9a02      	ldr	r2, [sp, #8]
 800fd24:	2a00      	cmp	r2, #0
 800fd26:	f77f aeba 	ble.w	800fa9e <cblas_dtrmm+0x45e>
 800fd2a:	f102 3bff 	add.w	fp, r2, #4294967295
 800fd2e:	9e06      	ldr	r6, [sp, #24]
 800fd30:	f8cd b008 	str.w	fp, [sp, #8]
 800fd34:	fb05 210b 	mla	r1, r5, fp, r2
 800fd38:	1c6b      	adds	r3, r5, #1
 800fd3a:	9a08      	ldr	r2, [sp, #32]
 800fd3c:	00db      	lsls	r3, r3, #3
 800fd3e:	f1a3 0008 	sub.w	r0, r3, #8
 800fd42:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 800fd46:	fb0b 6303 	mla	r3, fp, r3, r6
 800fd4a:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 800fd4e:	9305      	str	r3, [sp, #20]
 800fd50:	00d3      	lsls	r3, r2, #3
 800fd52:	9308      	str	r3, [sp, #32]
 800fd54:	9b04      	ldr	r3, [sp, #16]
 800fd56:	43ec      	mvns	r4, r5
 800fd58:	fb0b 3309 	mla	r3, fp, r9, r3
 800fd5c:	ebc5 7545 	rsb	r5, r5, r5, lsl #29
 800fd60:	9306      	str	r3, [sp, #24]
 800fd62:	00e3      	lsls	r3, r4, #3
 800fd64:	f1a6 0808 	sub.w	r8, r6, #8
 800fd68:	fb0b 6000 	mla	r0, fp, r0, r6
 800fd6c:	9307      	str	r3, [sp, #28]
 800fd6e:	00eb      	lsls	r3, r5, #3
 800fd70:	9003      	str	r0, [sp, #12]
 800fd72:	eb08 08c1 	add.w	r8, r8, r1, lsl #3
 800fd76:	9309      	str	r3, [sp, #36]	; 0x24
      for (j = 0; j < n2; j++) {
 800fd78:	9b01      	ldr	r3, [sp, #4]
 800fd7a:	2b00      	cmp	r3, #0
 800fd7c:	dd30      	ble.n	800fde0 <cblas_dtrmm+0x7a0>
 800fd7e:	f8dd b018 	ldr.w	fp, [sp, #24]
 800fd82:	f04f 0a00 	mov.w	sl, #0
        for (k = 0; k < i; k++) {
 800fd86:	9b02      	ldr	r3, [sp, #8]
        BASE temp = 0.0;
 800fd88:	2400      	movs	r4, #0
 800fd8a:	2500      	movs	r5, #0
        for (k = 0; k < i; k++) {
 800fd8c:	b1a3      	cbz	r3, 800fdb8 <cblas_dtrmm+0x778>
 800fd8e:	9b04      	ldr	r3, [sp, #16]
 800fd90:	9e03      	ldr	r6, [sp, #12]
 800fd92:	eb03 07ca 	add.w	r7, r3, sl, lsl #3
          temp += A[lda * i + k] * B[k * ldb + j];
 800fd96:	e9d7 2300 	ldrd	r2, r3, [r7]
 800fd9a:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 800fd9e:	f018 f883 	bl	8027ea8 <__aeabi_dmul>
 800fda2:	4602      	mov	r2, r0
 800fda4:	460b      	mov	r3, r1
 800fda6:	4620      	mov	r0, r4
 800fda8:	4629      	mov	r1, r5
 800fdaa:	f017 fec7 	bl	8027b3c <__adddf3>
        for (k = 0; k < i; k++) {
 800fdae:	45b0      	cmp	r8, r6
 800fdb0:	444f      	add	r7, r9
          temp += A[lda * i + k] * B[k * ldb + j];
 800fdb2:	4604      	mov	r4, r0
 800fdb4:	460d      	mov	r5, r1
        for (k = 0; k < i; k++) {
 800fdb6:	d1ee      	bne.n	800fd96 <cblas_dtrmm+0x756>
        if (nonunit) {
 800fdb8:	9b00      	ldr	r3, [sp, #0]
 800fdba:	2b83      	cmp	r3, #131	; 0x83
 800fdbc:	d025      	beq.n	800fe0a <cblas_dtrmm+0x7ca>
          temp += B[i * ldb + j];
 800fdbe:	e9db 2300 	ldrd	r2, r3, [fp]
 800fdc2:	4620      	mov	r0, r4
 800fdc4:	4629      	mov	r1, r5
 800fdc6:	f017 feb9 	bl	8027b3c <__adddf3>
        B[ldb * i + j] = alpha * temp;
 800fdca:	ec53 2b18 	vmov	r2, r3, d8
 800fdce:	f018 f86b 	bl	8027ea8 <__aeabi_dmul>
      for (j = 0; j < n2; j++) {
 800fdd2:	9b01      	ldr	r3, [sp, #4]
 800fdd4:	f10a 0a01 	add.w	sl, sl, #1
 800fdd8:	4553      	cmp	r3, sl
        B[ldb * i + j] = alpha * temp;
 800fdda:	e8eb 0102 	strd	r0, r1, [fp], #8
      for (j = 0; j < n2; j++) {
 800fdde:	d1d2      	bne.n	800fd86 <cblas_dtrmm+0x746>
    for (i = n1; i > 0 && i--;) {
 800fde0:	9a05      	ldr	r2, [sp, #20]
 800fde2:	9b07      	ldr	r3, [sp, #28]
 800fde4:	4611      	mov	r1, r2
 800fde6:	4419      	add	r1, r3
 800fde8:	9a06      	ldr	r2, [sp, #24]
 800fdea:	9105      	str	r1, [sp, #20]
 800fdec:	9908      	ldr	r1, [sp, #32]
 800fdee:	440a      	add	r2, r1
 800fdf0:	9206      	str	r2, [sp, #24]
 800fdf2:	9909      	ldr	r1, [sp, #36]	; 0x24
 800fdf4:	9a03      	ldr	r2, [sp, #12]
 800fdf6:	4498      	add	r8, r3
 800fdf8:	9b02      	ldr	r3, [sp, #8]
 800fdfa:	440a      	add	r2, r1
 800fdfc:	9203      	str	r2, [sp, #12]
 800fdfe:	2b00      	cmp	r3, #0
 800fe00:	f43f ae4d 	beq.w	800fa9e <cblas_dtrmm+0x45e>
 800fe04:	3b01      	subs	r3, #1
 800fe06:	9302      	str	r3, [sp, #8]
 800fe08:	e7b6      	b.n	800fd78 <cblas_dtrmm+0x738>
          temp += A[i * lda + i] * B[i * ldb + j];
 800fe0a:	9905      	ldr	r1, [sp, #20]
 800fe0c:	e9db 2300 	ldrd	r2, r3, [fp]
 800fe10:	e9d1 0100 	ldrd	r0, r1, [r1]
 800fe14:	f018 f848 	bl	8027ea8 <__aeabi_dmul>
 800fe18:	4622      	mov	r2, r4
 800fe1a:	462b      	mov	r3, r5
 800fe1c:	f017 fe8e 	bl	8027b3c <__adddf3>
 800fe20:	e7d3      	b.n	800fdca <cblas_dtrmm+0x78a>
 800fe22:	9a03      	ldr	r2, [sp, #12]
 800fe24:	990b      	ldr	r1, [sp, #44]	; 0x2c
 800fe26:	9c05      	ldr	r4, [sp, #20]
 800fe28:	440a      	add	r2, r1
 800fe2a:	9203      	str	r2, [sp, #12]
 800fe2c:	9909      	ldr	r1, [sp, #36]	; 0x24
 800fe2e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800fe30:	4608      	mov	r0, r1
 800fe32:	4493      	add	fp, r2
 800fe34:	9907      	ldr	r1, [sp, #28]
 800fe36:	9a08      	ldr	r2, [sp, #32]
 800fe38:	4410      	add	r0, r2
 800fe3a:	4411      	add	r1, r2
    for (i = 0; i < n1; i++) {
 800fe3c:	9a02      	ldr	r2, [sp, #8]
 800fe3e:	9009      	str	r0, [sp, #36]	; 0x24
 800fe40:	4623      	mov	r3, r4
 800fe42:	3301      	adds	r3, #1
 800fe44:	42a2      	cmp	r2, r4
 800fe46:	9107      	str	r1, [sp, #28]
 800fe48:	9305      	str	r3, [sp, #20]
 800fe4a:	f73f af01 	bgt.w	800fc50 <cblas_dtrmm+0x610>
 800fe4e:	e626      	b.n	800fa9e <cblas_dtrmm+0x45e>
    for (i = 0; i < n1; i++) {
 800fe50:	9b02      	ldr	r3, [sp, #8]
 800fe52:	2b00      	cmp	r3, #0
 800fe54:	f77f ae23 	ble.w	800fa9e <cblas_dtrmm+0x45e>
 800fe58:	9908      	ldr	r1, [sp, #32]
 800fe5a:	9b01      	ldr	r3, [sp, #4]
 800fe5c:	00c9      	lsls	r1, r1, #3
 800fe5e:	f105 0901 	add.w	r9, r5, #1
 800fe62:	9107      	str	r1, [sp, #28]
 800fe64:	43ed      	mvns	r5, r5
 800fe66:	9904      	ldr	r1, [sp, #16]
 800fe68:	9103      	str	r1, [sp, #12]
 800fe6a:	00e9      	lsls	r1, r5, #3
 800fe6c:	1e5a      	subs	r2, r3, #1
 800fe6e:	9104      	str	r1, [sp, #16]
 800fe70:	00db      	lsls	r3, r3, #3
 800fe72:	9906      	ldr	r1, [sp, #24]
 800fe74:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 800fe78:	3b08      	subs	r3, #8
 800fe7a:	fb09 1202 	mla	r2, r9, r2, r1
 800fe7e:	9309      	str	r3, [sp, #36]	; 0x24
 800fe80:	2300      	movs	r3, #0
 800fe82:	9208      	str	r2, [sp, #32]
 800fe84:	f1a9 0908 	sub.w	r9, r9, #8
 800fe88:	9305      	str	r3, [sp, #20]
      for (j = n2; j > 0 && j--;) {
 800fe8a:	9e01      	ldr	r6, [sp, #4]
 800fe8c:	2e00      	cmp	r6, #0
 800fe8e:	dd37      	ble.n	800ff00 <cblas_dtrmm+0x8c0>
 800fe90:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800fe92:	9a03      	ldr	r2, [sp, #12]
 800fe94:	f8dd b020 	ldr.w	fp, [sp, #32]
 800fe98:	eb03 0802 	add.w	r8, r3, r2
        for (k = 0; k < j; k++) {
 800fe9c:	f106 3aff 	add.w	sl, r6, #4294967295
 800fea0:	f1ba 0f00 	cmp.w	sl, #0
        BASE temp = 0.0;
 800fea4:	f04f 0400 	mov.w	r4, #0
 800fea8:	f04f 0500 	mov.w	r5, #0
        for (k = 0; k < j; k++) {
 800feac:	dd14      	ble.n	800fed8 <cblas_dtrmm+0x898>
 800feae:	9b06      	ldr	r3, [sp, #24]
 800feb0:	9f03      	ldr	r7, [sp, #12]
 800feb2:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
          temp += A[lda * k + j] * B[i * ldb + k];
 800feb6:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 800feba:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 800febe:	f017 fff3 	bl	8027ea8 <__aeabi_dmul>
 800fec2:	4602      	mov	r2, r0
 800fec4:	460b      	mov	r3, r1
 800fec6:	4620      	mov	r0, r4
 800fec8:	4629      	mov	r1, r5
 800feca:	f017 fe37 	bl	8027b3c <__adddf3>
        for (k = 0; k < j; k++) {
 800fece:	4547      	cmp	r7, r8
 800fed0:	444e      	add	r6, r9
          temp += A[lda * k + j] * B[i * ldb + k];
 800fed2:	4604      	mov	r4, r0
 800fed4:	460d      	mov	r5, r1
        for (k = 0; k < j; k++) {
 800fed6:	d1ee      	bne.n	800feb6 <cblas_dtrmm+0x876>
        if (nonunit) {
 800fed8:	9b00      	ldr	r3, [sp, #0]
 800feda:	2b83      	cmp	r3, #131	; 0x83
 800fedc:	d01b      	beq.n	800ff16 <cblas_dtrmm+0x8d6>
          temp += B[i * ldb + j];
 800fede:	e9d8 2300 	ldrd	r2, r3, [r8]
 800fee2:	4620      	mov	r0, r4
 800fee4:	4629      	mov	r1, r5
 800fee6:	f017 fe29 	bl	8027b3c <__adddf3>
        B[ldb * i + j] = alpha * temp;
 800feea:	ec53 2b18 	vmov	r2, r3, d8
 800feee:	f017 ffdb 	bl	8027ea8 <__aeabi_dmul>
 800fef2:	9b04      	ldr	r3, [sp, #16]
      for (j = n2; j > 0 && j--;) {
 800fef4:	4656      	mov	r6, sl
        B[ldb * i + j] = alpha * temp;
 800fef6:	e868 0102 	strd	r0, r1, [r8], #-8
      for (j = n2; j > 0 && j--;) {
 800fefa:	449b      	add	fp, r3
 800fefc:	2e00      	cmp	r6, #0
 800fefe:	d1cd      	bne.n	800fe9c <cblas_dtrmm+0x85c>
    for (i = 0; i < n1; i++) {
 800ff00:	9a03      	ldr	r2, [sp, #12]
 800ff02:	9907      	ldr	r1, [sp, #28]
 800ff04:	9b05      	ldr	r3, [sp, #20]
 800ff06:	440a      	add	r2, r1
 800ff08:	9203      	str	r2, [sp, #12]
 800ff0a:	9a02      	ldr	r2, [sp, #8]
 800ff0c:	3301      	adds	r3, #1
 800ff0e:	429a      	cmp	r2, r3
 800ff10:	9305      	str	r3, [sp, #20]
 800ff12:	d1ba      	bne.n	800fe8a <cblas_dtrmm+0x84a>
 800ff14:	e5c3      	b.n	800fa9e <cblas_dtrmm+0x45e>
          temp += A[j * lda + j] * B[i * ldb + j];
 800ff16:	e9d8 2300 	ldrd	r2, r3, [r8]
 800ff1a:	e9db 0100 	ldrd	r0, r1, [fp]
 800ff1e:	f017 ffc3 	bl	8027ea8 <__aeabi_dmul>
 800ff22:	4622      	mov	r2, r4
 800ff24:	462b      	mov	r3, r5
 800ff26:	f017 fe09 	bl	8027b3c <__adddf3>
 800ff2a:	e7de      	b.n	800feea <cblas_dtrmm+0x8aa>
    for (i = 0; i < n1; i++) {
 800ff2c:	9b02      	ldr	r3, [sp, #8]
 800ff2e:	2b00      	cmp	r3, #0
 800ff30:	f77f adb5 	ble.w	800fa9e <cblas_dtrmm+0x45e>
 800ff34:	1c6b      	adds	r3, r5, #1
 800ff36:	00db      	lsls	r3, r3, #3
 800ff38:	9309      	str	r3, [sp, #36]	; 0x24
 800ff3a:	9b06      	ldr	r3, [sp, #24]
 800ff3c:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
 800ff40:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 800ff44:	930e      	str	r3, [sp, #56]	; 0x38
 800ff46:	f10a 0308 	add.w	r3, sl, #8
 800ff4a:	930a      	str	r3, [sp, #40]	; 0x28
 800ff4c:	9b08      	ldr	r3, [sp, #32]
 800ff4e:	2200      	movs	r2, #0
 800ff50:	00db      	lsls	r3, r3, #3
 800ff52:	920b      	str	r2, [sp, #44]	; 0x2c
 800ff54:	920c      	str	r2, [sp, #48]	; 0x30
 800ff56:	930d      	str	r3, [sp, #52]	; 0x34
 800ff58:	9a01      	ldr	r2, [sp, #4]
 800ff5a:	9b04      	ldr	r3, [sp, #16]
 800ff5c:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
      for (j = 0; j < n2; j++) {
 800ff60:	9b01      	ldr	r3, [sp, #4]
 800ff62:	2b00      	cmp	r3, #0
 800ff64:	dd54      	ble.n	8010010 <cblas_dtrmm+0x9d0>
 800ff66:	9b04      	ldr	r3, [sp, #16]
 800ff68:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 800ff6a:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
 800ff6e:	9b06      	ldr	r3, [sp, #24]
 800ff70:	9305      	str	r3, [sp, #20]
 800ff72:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800ff74:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 800ff76:	9b00      	ldr	r3, [sp, #0]
 800ff78:	2b83      	cmp	r3, #131	; 0x83
      for (j = 0; j < n2; j++) {
 800ff7a:	f04f 0900 	mov.w	r9, #0
        if (nonunit) {
 800ff7e:	d031      	beq.n	800ffe4 <cblas_dtrmm+0x9a4>
        for (k = j + 1; k < n2; k++) {
 800ff80:	9b01      	ldr	r3, [sp, #4]
 800ff82:	f109 0901 	add.w	r9, r9, #1
 800ff86:	454b      	cmp	r3, r9
          temp = B[i * ldb + j];
 800ff88:	e9d8 4500 	ldrd	r4, r5, [r8]
        for (k = j + 1; k < n2; k++) {
 800ff8c:	d038      	beq.n	8010000 <cblas_dtrmm+0x9c0>
 800ff8e:	f108 0308 	add.w	r3, r8, #8
 800ff92:	9e03      	ldr	r6, [sp, #12]
 800ff94:	9307      	str	r3, [sp, #28]
 800ff96:	461f      	mov	r7, r3
          temp += A[lda * k + j] * B[i * ldb + k];
 800ff98:	e9d6 2300 	ldrd	r2, r3, [r6]
 800ff9c:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 800ffa0:	f017 ff82 	bl	8027ea8 <__aeabi_dmul>
 800ffa4:	4602      	mov	r2, r0
 800ffa6:	460b      	mov	r3, r1
 800ffa8:	4620      	mov	r0, r4
 800ffaa:	4629      	mov	r1, r5
 800ffac:	f017 fdc6 	bl	8027b3c <__adddf3>
        for (k = j + 1; k < n2; k++) {
 800ffb0:	455f      	cmp	r7, fp
 800ffb2:	4456      	add	r6, sl
          temp += A[lda * k + j] * B[i * ldb + k];
 800ffb4:	4604      	mov	r4, r0
 800ffb6:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 800ffb8:	d1ee      	bne.n	800ff98 <cblas_dtrmm+0x958>
        B[ldb * i + j] = alpha * temp;
 800ffba:	4602      	mov	r2, r0
 800ffbc:	460b      	mov	r3, r1
 800ffbe:	ec51 0b18 	vmov	r0, r1, d8
 800ffc2:	f017 ff71 	bl	8027ea8 <__aeabi_dmul>
 800ffc6:	9b03      	ldr	r3, [sp, #12]
 800ffc8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800ffca:	4413      	add	r3, r2
 800ffcc:	9303      	str	r3, [sp, #12]
 800ffce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800ffd0:	9b05      	ldr	r3, [sp, #20]
 800ffd2:	4413      	add	r3, r2
 800ffd4:	9305      	str	r3, [sp, #20]
        if (nonunit) {
 800ffd6:	9b00      	ldr	r3, [sp, #0]
 800ffd8:	2b83      	cmp	r3, #131	; 0x83
        B[ldb * i + j] = alpha * temp;
 800ffda:	e9c8 0100 	strd	r0, r1, [r8]
 800ffde:	f8dd 801c 	ldr.w	r8, [sp, #28]
        if (nonunit) {
 800ffe2:	d1cd      	bne.n	800ff80 <cblas_dtrmm+0x940>
          temp = A[j * lda + j] * B[i * ldb + j];
 800ffe4:	9905      	ldr	r1, [sp, #20]
 800ffe6:	e9d8 2300 	ldrd	r2, r3, [r8]
 800ffea:	e9d1 0100 	ldrd	r0, r1, [r1]
 800ffee:	f017 ff5b 	bl	8027ea8 <__aeabi_dmul>
        for (k = j + 1; k < n2; k++) {
 800fff2:	9b01      	ldr	r3, [sp, #4]
 800fff4:	f109 0901 	add.w	r9, r9, #1
 800fff8:	454b      	cmp	r3, r9
          temp = A[j * lda + j] * B[i * ldb + j];
 800fffa:	4604      	mov	r4, r0
 800fffc:	460d      	mov	r5, r1
        for (k = j + 1; k < n2; k++) {
 800fffe:	d1c6      	bne.n	800ff8e <cblas_dtrmm+0x94e>
        B[ldb * i + j] = alpha * temp;
 8010000:	ec53 2b18 	vmov	r2, r3, d8
 8010004:	4620      	mov	r0, r4
 8010006:	4629      	mov	r1, r5
 8010008:	f017 ff4e 	bl	8027ea8 <__aeabi_dmul>
 801000c:	e94b 0102 	strd	r0, r1, [fp, #-8]
    for (i = 0; i < n1; i++) {
 8010010:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010012:	9908      	ldr	r1, [sp, #32]
 8010014:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010016:	4493      	add	fp, r2
 8010018:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801001a:	440a      	add	r2, r1
 801001c:	920b      	str	r2, [sp, #44]	; 0x2c
 801001e:	9a02      	ldr	r2, [sp, #8]
 8010020:	3301      	adds	r3, #1
 8010022:	429a      	cmp	r2, r3
 8010024:	930c      	str	r3, [sp, #48]	; 0x30
 8010026:	d19b      	bne.n	800ff60 <cblas_dtrmm+0x920>
 8010028:	e539      	b.n	800fa9e <cblas_dtrmm+0x45e>
 801002a:	bf00      	nop

0801002c <cblas_dtrmv>:
void
cblas_dtrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const double *A, const int lda, double *X,
             const int incX)
{
 801002c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010030:	b08b      	sub	sp, #44	; 0x2c
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 8010032:	2a71      	cmp	r2, #113	; 0x71
 8010034:	9301      	str	r3, [sp, #4]
 8010036:	e9dd 5316 	ldrd	r5, r3, [sp, #88]	; 0x58
 801003a:	9303      	str	r3, [sp, #12]
 801003c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801003e:	9302      	str	r3, [sp, #8]
 8010040:	e9dd b414 	ldrd	fp, r4, [sp, #80]	; 0x50
 8010044:	4606      	mov	r6, r0
 8010046:	460f      	mov	r7, r1
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010048:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 801004c:	f000 80bd 	beq.w	80101ca <cblas_dtrmv+0x19e>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010050:	2b01      	cmp	r3, #1
 8010052:	4690      	mov	r8, r2
 8010054:	d930      	bls.n	80100b8 <cblas_dtrmv+0x8c>
 8010056:	2002      	movs	r0, #2
 8010058:	3a6f      	subs	r2, #111	; 0x6f
 801005a:	2a02      	cmp	r2, #2
 801005c:	bf88      	it	hi
 801005e:	2003      	movhi	r0, #3
 8010060:	9b01      	ldr	r3, [sp, #4]
 8010062:	337d      	adds	r3, #125	; 0x7d
 8010064:	b2db      	uxtb	r3, r3
 8010066:	2b01      	cmp	r3, #1
 8010068:	d934      	bls.n	80100d4 <cblas_dtrmv+0xa8>
 801006a:	f1bb 0f00 	cmp.w	fp, #0
 801006e:	db29      	blt.n	80100c4 <cblas_dtrmv+0x98>
 8010070:	465b      	mov	r3, fp
 8010072:	2b01      	cmp	r3, #1
 8010074:	bfb8      	it	lt
 8010076:	2301      	movlt	r3, #1
 8010078:	42ab      	cmp	r3, r5
 801007a:	f340 80ac 	ble.w	80101d6 <cblas_dtrmv+0x1aa>
 801007e:	9b02      	ldr	r3, [sp, #8]
 8010080:	2b00      	cmp	r3, #0
 8010082:	bf0c      	ite	eq
 8010084:	2009      	moveq	r0, #9
 8010086:	2007      	movne	r0, #7
 8010088:	4aa9      	ldr	r2, [pc, #676]	; (8010330 <cblas_dtrmv+0x304>)
 801008a:	49aa      	ldr	r1, [pc, #680]	; (8010334 <cblas_dtrmv+0x308>)
 801008c:	f017 fcdc 	bl	8027a48 <cblas_xerbla>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8010090:	2e65      	cmp	r6, #101	; 0x65
 8010092:	d02f      	beq.n	80100f4 <cblas_dtrmv+0xc8>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8010094:	2e66      	cmp	r6, #102	; 0x66
 8010096:	d107      	bne.n	80100a8 <cblas_dtrmv+0x7c>
 8010098:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 801009c:	f000 8141 	beq.w	8010322 <cblas_dtrmv+0x2f6>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80100a0:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80100a4:	f000 809d 	beq.w	80101e2 <cblas_dtrmv+0x1b6>
    BLAS_ERROR("unrecognized operation");
 80100a8:	4aa3      	ldr	r2, [pc, #652]	; (8010338 <cblas_dtrmv+0x30c>)
 80100aa:	49a2      	ldr	r1, [pc, #648]	; (8010334 <cblas_dtrmv+0x308>)
 80100ac:	2000      	movs	r0, #0
#define BASE double
#include "source_trmv_r.h"
#undef BASE
}
 80100ae:	b00b      	add	sp, #44	; 0x2c
 80100b0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80100b4:	f017 bcc8 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80100b8:	3865      	subs	r0, #101	; 0x65
 80100ba:	2801      	cmp	r0, #1
 80100bc:	bf94      	ite	ls
 80100be:	2000      	movls	r0, #0
 80100c0:	2001      	movhi	r0, #1
 80100c2:	e7c9      	b.n	8010058 <cblas_dtrmv+0x2c>
 80100c4:	2d00      	cmp	r5, #0
 80100c6:	ddda      	ble.n	801007e <cblas_dtrmv+0x52>
 80100c8:	9b02      	ldr	r3, [sp, #8]
 80100ca:	2b00      	cmp	r3, #0
 80100cc:	bf0c      	ite	eq
 80100ce:	2009      	moveq	r0, #9
 80100d0:	2005      	movne	r0, #5
 80100d2:	e7d9      	b.n	8010088 <cblas_dtrmv+0x5c>
 80100d4:	f1bb 0f00 	cmp.w	fp, #0
 80100d8:	dbf4      	blt.n	80100c4 <cblas_dtrmv+0x98>
 80100da:	465b      	mov	r3, fp
 80100dc:	2b01      	cmp	r3, #1
 80100de:	bfb8      	it	lt
 80100e0:	2301      	movlt	r3, #1
 80100e2:	42ab      	cmp	r3, r5
 80100e4:	dccb      	bgt.n	801007e <cblas_dtrmv+0x52>
 80100e6:	9b02      	ldr	r3, [sp, #8]
 80100e8:	2b00      	cmp	r3, #0
 80100ea:	f000 820a 	beq.w	8010502 <cblas_dtrmv+0x4d6>
 80100ee:	2800      	cmp	r0, #0
 80100f0:	d0ce      	beq.n	8010090 <cblas_dtrmv+0x64>
 80100f2:	e7c9      	b.n	8010088 <cblas_dtrmv+0x5c>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80100f4:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80100f8:	f000 8093 	beq.w	8010222 <cblas_dtrmv+0x1f6>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 80100fc:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8010100:	d1d2      	bne.n	80100a8 <cblas_dtrmv+0x7c>
 8010102:	2f79      	cmp	r7, #121	; 0x79
 8010104:	f000 8186 	beq.w	8010414 <cblas_dtrmv+0x3e8>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8010108:	2f7a      	cmp	r7, #122	; 0x7a
 801010a:	d1cd      	bne.n	80100a8 <cblas_dtrmv+0x7c>
    INDEX ix = OFFSET(N, incX);
 801010c:	9a02      	ldr	r2, [sp, #8]
 801010e:	2a00      	cmp	r2, #0
 8010110:	bfda      	itte	le
 8010112:	f1cb 0301 	rsble	r3, fp, #1
 8010116:	4353      	mulle	r3, r2
 8010118:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 801011a:	f1bb 0f00 	cmp.w	fp, #0
 801011e:	dd51      	ble.n	80101c4 <cblas_dtrmv+0x198>
 8010120:	1c6a      	adds	r2, r5, #1
 8010122:	00d2      	lsls	r2, r2, #3
 8010124:	ebc5 7545 	rsb	r5, r5, r5, lsl #29
 8010128:	f1a2 0a08 	sub.w	sl, r2, #8
 801012c:	9208      	str	r2, [sp, #32]
 801012e:	00ea      	lsls	r2, r5, #3
 8010130:	9209      	str	r2, [sp, #36]	; 0x24
 8010132:	eb04 020a 	add.w	r2, r4, sl
 8010136:	9204      	str	r2, [sp, #16]
 8010138:	9a02      	ldr	r2, [sp, #8]
 801013a:	1899      	adds	r1, r3, r2
 801013c:	9107      	str	r1, [sp, #28]
 801013e:	9903      	ldr	r1, [sp, #12]
 8010140:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 8010144:	9306      	str	r3, [sp, #24]
 8010146:	2300      	movs	r3, #0
 8010148:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 801014c:	9305      	str	r3, [sp, #20]
      const INDEX j_min = i + 1;
 801014e:	9e05      	ldr	r6, [sp, #20]
 8010150:	3601      	adds	r6, #1
      for (j = j_min; j < j_max; j++) {
 8010152:	45b3      	cmp	fp, r6
      const INDEX j_min = i + 1;
 8010154:	9605      	str	r6, [sp, #20]
      BASE temp = 0.0;
 8010156:	f04f 0400 	mov.w	r4, #0
 801015a:	f04f 0500 	mov.w	r5, #0
      for (j = j_min; j < j_max; j++) {
 801015e:	dd17      	ble.n	8010190 <cblas_dtrmv+0x164>
 8010160:	9b03      	ldr	r3, [sp, #12]
 8010162:	9a07      	ldr	r2, [sp, #28]
 8010164:	9f04      	ldr	r7, [sp, #16]
 8010166:	eb03 08c2 	add.w	r8, r3, r2, lsl #3
        temp += X[jx] * A[lda * j + i];
 801016a:	e9d7 2300 	ldrd	r2, r3, [r7]
 801016e:	e9d8 0100 	ldrd	r0, r1, [r8]
 8010172:	f017 fe99 	bl	8027ea8 <__aeabi_dmul>
 8010176:	4602      	mov	r2, r0
 8010178:	460b      	mov	r3, r1
 801017a:	4620      	mov	r0, r4
 801017c:	4629      	mov	r1, r5
 801017e:	f017 fcdd 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 8010182:	3601      	adds	r6, #1
 8010184:	45b3      	cmp	fp, r6
 8010186:	4457      	add	r7, sl
        temp += X[jx] * A[lda * j + i];
 8010188:	4604      	mov	r4, r0
 801018a:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 801018c:	44c8      	add	r8, r9
 801018e:	d1ec      	bne.n	801016a <cblas_dtrmv+0x13e>
      if (nonunit) {
 8010190:	9b01      	ldr	r3, [sp, #4]
 8010192:	2b83      	cmp	r3, #131	; 0x83
 8010194:	d02c      	beq.n	80101f0 <cblas_dtrmv+0x1c4>
        X[ix] += temp;
 8010196:	4622      	mov	r2, r4
 8010198:	9c06      	ldr	r4, [sp, #24]
 801019a:	462b      	mov	r3, r5
 801019c:	e9d4 0100 	ldrd	r0, r1, [r4]
 80101a0:	f017 fccc 	bl	8027b3c <__adddf3>
 80101a4:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 80101a8:	9b07      	ldr	r3, [sp, #28]
 80101aa:	9a02      	ldr	r2, [sp, #8]
 80101ac:	4413      	add	r3, r2
 80101ae:	9307      	str	r3, [sp, #28]
 80101b0:	9b06      	ldr	r3, [sp, #24]
 80101b2:	9a08      	ldr	r2, [sp, #32]
 80101b4:	444b      	add	r3, r9
 80101b6:	9306      	str	r3, [sp, #24]
 80101b8:	9b04      	ldr	r3, [sp, #16]
 80101ba:	4413      	add	r3, r2
 80101bc:	9304      	str	r3, [sp, #16]
 80101be:	9b05      	ldr	r3, [sp, #20]
 80101c0:	459b      	cmp	fp, r3
 80101c2:	d1c4      	bne.n	801014e <cblas_dtrmv+0x122>
 80101c4:	b00b      	add	sp, #44	; 0x2c
 80101c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80101ca:	2b01      	cmp	r3, #1
 80101cc:	d921      	bls.n	8010212 <cblas_dtrmv+0x1e6>
 80101ce:	f04f 0870 	mov.w	r8, #112	; 0x70
 80101d2:	2002      	movs	r0, #2
 80101d4:	e744      	b.n	8010060 <cblas_dtrmv+0x34>
 80101d6:	9b02      	ldr	r3, [sp, #8]
 80101d8:	2b00      	cmp	r3, #0
 80101da:	bf0c      	ite	eq
 80101dc:	2009      	moveq	r0, #9
 80101de:	2004      	movne	r0, #4
 80101e0:	e752      	b.n	8010088 <cblas_dtrmv+0x5c>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80101e2:	2f7a      	cmp	r7, #122	; 0x7a
 80101e4:	f000 8116 	beq.w	8010414 <cblas_dtrmv+0x3e8>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 80101e8:	2f79      	cmp	r7, #121	; 0x79
 80101ea:	f47f af5d 	bne.w	80100a8 <cblas_dtrmv+0x7c>
 80101ee:	e78d      	b.n	801010c <cblas_dtrmv+0xe0>
        X[ix] = temp + X[ix] * A[lda * i + i];
 80101f0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80101f2:	9b04      	ldr	r3, [sp, #16]
 80101f4:	9e06      	ldr	r6, [sp, #24]
 80101f6:	4413      	add	r3, r2
 80101f8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80101fc:	e9d6 2300 	ldrd	r2, r3, [r6]
 8010200:	f017 fe52 	bl	8027ea8 <__aeabi_dmul>
 8010204:	4622      	mov	r2, r4
 8010206:	462b      	mov	r3, r5
 8010208:	f017 fc98 	bl	8027b3c <__adddf3>
 801020c:	e9c6 0100 	strd	r0, r1, [r6]
 8010210:	e7ca      	b.n	80101a8 <cblas_dtrmv+0x17c>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010212:	3865      	subs	r0, #101	; 0x65
 8010214:	2801      	cmp	r0, #1
 8010216:	bf94      	ite	ls
 8010218:	2000      	movls	r0, #0
 801021a:	2001      	movhi	r0, #1
 801021c:	f04f 0870 	mov.w	r8, #112	; 0x70
 8010220:	e71e      	b.n	8010060 <cblas_dtrmv+0x34>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8010222:	2f79      	cmp	r7, #121	; 0x79
 8010224:	f000 808a 	beq.w	801033c <cblas_dtrmv+0x310>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 8010228:	2f7a      	cmp	r7, #122	; 0x7a
 801022a:	f47f af3d 	bne.w	80100a8 <cblas_dtrmv+0x7c>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 801022e:	9b02      	ldr	r3, [sp, #8]
 8010230:	9f02      	ldr	r7, [sp, #8]
 8010232:	2b00      	cmp	r3, #0
 8010234:	bfd8      	it	le
 8010236:	9b02      	ldrle	r3, [sp, #8]
 8010238:	f10b 39ff 	add.w	r9, fp, #4294967295
 801023c:	bfd6      	itet	le
 801023e:	425a      	negle	r2, r3
 8010240:	2200      	movgt	r2, #0
 8010242:	fb09 f202 	mulle.w	r2, r9, r2
    for (i = N; i > 0 && i--;) {
 8010246:	f1bb 0f00 	cmp.w	fp, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 801024a:	fb09 2807 	mla	r8, r9, r7, r2
    for (i = N; i > 0 && i--;) {
 801024e:	ddb9      	ble.n	80101c4 <cblas_dtrmv+0x198>
 8010250:	1c6b      	adds	r3, r5, #1
 8010252:	00db      	lsls	r3, r3, #3
 8010254:	9903      	ldr	r1, [sp, #12]
 8010256:	f1a3 0608 	sub.w	r6, r3, #8
 801025a:	ebc7 7047 	rsb	r0, r7, r7, lsl #29
 801025e:	fb09 4303 	mla	r3, r9, r3, r4
 8010262:	ea6f 0c05 	mvn.w	ip, r5
 8010266:	9303      	str	r3, [sp, #12]
 8010268:	00c3      	lsls	r3, r0, #3
 801026a:	fb09 bb05 	mla	fp, r9, r5, fp
 801026e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8010272:	ebc5 7545 	rsb	r5, r5, r5, lsl #29
 8010276:	9305      	str	r3, [sp, #20]
 8010278:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 801027c:	f1a4 0a08 	sub.w	sl, r4, #8
 8010280:	9207      	str	r2, [sp, #28]
 8010282:	9304      	str	r3, [sp, #16]
 8010284:	fb09 4206 	mla	r2, r9, r6, r4
 8010288:	00eb      	lsls	r3, r5, #3
 801028a:	eb0a 0acb 	add.w	sl, sl, fp, lsl #3
 801028e:	eb01 08c8 	add.w	r8, r1, r8, lsl #3
 8010292:	9202      	str	r2, [sp, #8]
 8010294:	ea4f 0bc7 	mov.w	fp, r7, lsl #3
 8010298:	9306      	str	r3, [sp, #24]
      for (j = j_min; j < j_max; j++) {
 801029a:	2400      	movs	r4, #0
 801029c:	2500      	movs	r5, #0
 801029e:	f1b9 0f00 	cmp.w	r9, #0
 80102a2:	d012      	beq.n	80102ca <cblas_dtrmv+0x29e>
 80102a4:	9f02      	ldr	r7, [sp, #8]
 80102a6:	9e07      	ldr	r6, [sp, #28]
        temp += X[jx] * A[lda * i + j];
 80102a8:	e9d6 2300 	ldrd	r2, r3, [r6]
 80102ac:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 80102b0:	f017 fdfa 	bl	8027ea8 <__aeabi_dmul>
 80102b4:	4602      	mov	r2, r0
 80102b6:	460b      	mov	r3, r1
 80102b8:	4620      	mov	r0, r4
 80102ba:	4629      	mov	r1, r5
 80102bc:	f017 fc3e 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 80102c0:	4557      	cmp	r7, sl
 80102c2:	445e      	add	r6, fp
        temp += X[jx] * A[lda * i + j];
 80102c4:	4604      	mov	r4, r0
 80102c6:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 80102c8:	d1ee      	bne.n	80102a8 <cblas_dtrmv+0x27c>
      if (nonunit) {
 80102ca:	9b01      	ldr	r3, [sp, #4]
 80102cc:	2b83      	cmp	r3, #131	; 0x83
 80102ce:	d01a      	beq.n	8010306 <cblas_dtrmv+0x2da>
        X[ix] += temp;
 80102d0:	e9d8 0100 	ldrd	r0, r1, [r8]
 80102d4:	4622      	mov	r2, r4
 80102d6:	462b      	mov	r3, r5
 80102d8:	f017 fc30 	bl	8027b3c <__adddf3>
 80102dc:	e9c8 0100 	strd	r0, r1, [r8]
    for (i = N; i > 0 && i--;) {
 80102e0:	9b05      	ldr	r3, [sp, #20]
 80102e2:	9a03      	ldr	r2, [sp, #12]
 80102e4:	4498      	add	r8, r3
 80102e6:	9b04      	ldr	r3, [sp, #16]
 80102e8:	4611      	mov	r1, r2
 80102ea:	4419      	add	r1, r3
 80102ec:	9a02      	ldr	r2, [sp, #8]
 80102ee:	9103      	str	r1, [sp, #12]
 80102f0:	9906      	ldr	r1, [sp, #24]
 80102f2:	440a      	add	r2, r1
 80102f4:	9202      	str	r2, [sp, #8]
 80102f6:	449a      	add	sl, r3
 80102f8:	f1b9 0f00 	cmp.w	r9, #0
 80102fc:	f43f af62 	beq.w	80101c4 <cblas_dtrmv+0x198>
 8010300:	f109 39ff 	add.w	r9, r9, #4294967295
 8010304:	e7c9      	b.n	801029a <cblas_dtrmv+0x26e>
        X[ix] = temp + X[ix] * A[lda * i + i];
 8010306:	9b03      	ldr	r3, [sp, #12]
 8010308:	e9d8 0100 	ldrd	r0, r1, [r8]
 801030c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010310:	f017 fdca 	bl	8027ea8 <__aeabi_dmul>
 8010314:	4622      	mov	r2, r4
 8010316:	462b      	mov	r3, r5
 8010318:	f017 fc10 	bl	8027b3c <__adddf3>
 801031c:	e9c8 0100 	strd	r0, r1, [r8]
 8010320:	e7de      	b.n	80102e0 <cblas_dtrmv+0x2b4>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8010322:	2f7a      	cmp	r7, #122	; 0x7a
 8010324:	d00a      	beq.n	801033c <cblas_dtrmv+0x310>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 8010326:	2f79      	cmp	r7, #121	; 0x79
 8010328:	f47f aebe 	bne.w	80100a8 <cblas_dtrmv+0x7c>
 801032c:	e77f      	b.n	801022e <cblas_dtrmv+0x202>
 801032e:	bf00      	nop
 8010330:	08030378 	.word	0x08030378
 8010334:	08030680 	.word	0x08030680
 8010338:	080305a8 	.word	0x080305a8
    INDEX ix = OFFSET(N, incX);
 801033c:	9a02      	ldr	r2, [sp, #8]
 801033e:	2a00      	cmp	r2, #0
 8010340:	bfda      	itte	le
 8010342:	f1cb 0301 	rsble	r3, fp, #1
 8010346:	4353      	mulle	r3, r2
 8010348:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 801034a:	f1bb 0f00 	cmp.w	fp, #0
    INDEX ix = OFFSET(N, incX);
 801034e:	4619      	mov	r1, r3
    for (i = 0; i < N; i++) {
 8010350:	f77f af38 	ble.w	80101c4 <cblas_dtrmv+0x198>
 8010354:	3501      	adds	r5, #1
 8010356:	00eb      	lsls	r3, r5, #3
 8010358:	9308      	str	r3, [sp, #32]
 801035a:	3b08      	subs	r3, #8
 801035c:	9307      	str	r3, [sp, #28]
 801035e:	f104 0308 	add.w	r3, r4, #8
 8010362:	9a03      	ldr	r2, [sp, #12]
 8010364:	9304      	str	r3, [sp, #16]
 8010366:	9b02      	ldr	r3, [sp, #8]
 8010368:	f8cd b014 	str.w	fp, [sp, #20]
 801036c:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8010370:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8010374:	9309      	str	r3, [sp, #36]	; 0x24
 8010376:	2300      	movs	r3, #0
 8010378:	eb04 08cb 	add.w	r8, r4, fp, lsl #3
 801037c:	469a      	mov	sl, r3
 801037e:	468b      	mov	fp, r1
      for (j = j_min; j < j_max; j++) {
 8010380:	9b05      	ldr	r3, [sp, #20]
      const INDEX j_min = i + 1;
 8010382:	f10a 0a01 	add.w	sl, sl, #1
      for (j = j_min; j < j_max; j++) {
 8010386:	4553      	cmp	r3, sl
 8010388:	ea4f 03cb 	mov.w	r3, fp, lsl #3
      BASE temp = 0.0;
 801038c:	f04f 0400 	mov.w	r4, #0
 8010390:	f04f 0500 	mov.w	r5, #0
 8010394:	9306      	str	r3, [sp, #24]
      for (j = j_min; j < j_max; j++) {
 8010396:	dd14      	ble.n	80103c2 <cblas_dtrmv+0x396>
 8010398:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801039a:	9e04      	ldr	r6, [sp, #16]
 801039c:	eb03 07cb 	add.w	r7, r3, fp, lsl #3
        temp += X[jx] * A[lda * i + j];
 80103a0:	e9d7 2300 	ldrd	r2, r3, [r7]
 80103a4:	e8f6 0102 	ldrd	r0, r1, [r6], #8
 80103a8:	f017 fd7e 	bl	8027ea8 <__aeabi_dmul>
 80103ac:	4602      	mov	r2, r0
 80103ae:	460b      	mov	r3, r1
 80103b0:	4620      	mov	r0, r4
 80103b2:	4629      	mov	r1, r5
 80103b4:	f017 fbc2 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 80103b8:	45b0      	cmp	r8, r6
 80103ba:	444f      	add	r7, r9
        temp += X[jx] * A[lda * i + j];
 80103bc:	4604      	mov	r4, r0
 80103be:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 80103c0:	d1ee      	bne.n	80103a0 <cblas_dtrmv+0x374>
      if (nonunit) {
 80103c2:	9b01      	ldr	r3, [sp, #4]
 80103c4:	9a03      	ldr	r2, [sp, #12]
 80103c6:	2b83      	cmp	r3, #131	; 0x83
 80103c8:	9b06      	ldr	r3, [sp, #24]
 80103ca:	4413      	add	r3, r2
 80103cc:	461e      	mov	r6, r3
 80103ce:	d013      	beq.n	80103f8 <cblas_dtrmv+0x3cc>
        X[ix] += temp;
 80103d0:	e9d6 0100 	ldrd	r0, r1, [r6]
 80103d4:	4622      	mov	r2, r4
 80103d6:	462b      	mov	r3, r5
 80103d8:	f017 fbb0 	bl	8027b3c <__adddf3>
 80103dc:	e9c6 0100 	strd	r0, r1, [r6]
      ix += incX;
 80103e0:	9b02      	ldr	r3, [sp, #8]
 80103e2:	9a08      	ldr	r2, [sp, #32]
 80103e4:	449b      	add	fp, r3
    for (i = 0; i < N; i++) {
 80103e6:	9b04      	ldr	r3, [sp, #16]
 80103e8:	4413      	add	r3, r2
 80103ea:	9304      	str	r3, [sp, #16]
 80103ec:	9b07      	ldr	r3, [sp, #28]
 80103ee:	4498      	add	r8, r3
 80103f0:	9b05      	ldr	r3, [sp, #20]
 80103f2:	4553      	cmp	r3, sl
 80103f4:	d1c4      	bne.n	8010380 <cblas_dtrmv+0x354>
 80103f6:	e6e5      	b.n	80101c4 <cblas_dtrmv+0x198>
        X[ix] = temp + X[ix] * A[lda * i + i];
 80103f8:	e9d3 0100 	ldrd	r0, r1, [r3]
 80103fc:	9b04      	ldr	r3, [sp, #16]
 80103fe:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8010402:	f017 fd51 	bl	8027ea8 <__aeabi_dmul>
 8010406:	4622      	mov	r2, r4
 8010408:	462b      	mov	r3, r5
 801040a:	f017 fb97 	bl	8027b3c <__adddf3>
 801040e:	e9c6 0100 	strd	r0, r1, [r6]
 8010412:	e7e5      	b.n	80103e0 <cblas_dtrmv+0x3b4>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8010414:	9b02      	ldr	r3, [sp, #8]
 8010416:	9802      	ldr	r0, [sp, #8]
 8010418:	2b00      	cmp	r3, #0
 801041a:	bfd8      	it	le
 801041c:	9b02      	ldrle	r3, [sp, #8]
 801041e:	f10b 39ff 	add.w	r9, fp, #4294967295
 8010422:	bfd6      	itet	le
 8010424:	425b      	negle	r3, r3
 8010426:	2300      	movgt	r3, #0
 8010428:	fb09 f303 	mulle.w	r3, r9, r3
    for (i = N; i > 0 && i--;) {
 801042c:	f1bb 0f00 	cmp.w	fp, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8010430:	fb09 3200 	mla	r2, r9, r0, r3
    for (i = N; i > 0 && i--;) {
 8010434:	f77f aec6 	ble.w	80101c4 <cblas_dtrmv+0x198>
 8010438:	9e03      	ldr	r6, [sp, #12]
 801043a:	f105 0a01 	add.w	sl, r5, #1
 801043e:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8010442:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8010446:	43ed      	mvns	r5, r5
 8010448:	9307      	str	r3, [sp, #28]
 801044a:	fb0a 4309 	mla	r3, sl, r9, r4
 801044e:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8010452:	ebc0 7140 	rsb	r1, r0, r0, lsl #29
 8010456:	9304      	str	r3, [sp, #16]
 8010458:	00eb      	lsls	r3, r5, #3
 801045a:	9202      	str	r2, [sp, #8]
 801045c:	9305      	str	r3, [sp, #20]
 801045e:	eb04 02cb 	add.w	r2, r4, fp, lsl #3
 8010462:	00cb      	lsls	r3, r1, #3
 8010464:	9203      	str	r2, [sp, #12]
 8010466:	f1aa 0a08 	sub.w	sl, sl, #8
 801046a:	9306      	str	r3, [sp, #24]
 801046c:	ea4f 0bc0 	mov.w	fp, r0, lsl #3
      for (j = j_min; j < j_max; j++) {
 8010470:	2400      	movs	r4, #0
 8010472:	2500      	movs	r5, #0
 8010474:	f1b9 0f00 	cmp.w	r9, #0
 8010478:	d016      	beq.n	80104a8 <cblas_dtrmv+0x47c>
 801047a:	f8dd 800c 	ldr.w	r8, [sp, #12]
 801047e:	9f07      	ldr	r7, [sp, #28]
 8010480:	2600      	movs	r6, #0
        temp += X[jx] * A[lda * j + i];
 8010482:	e958 2302 	ldrd	r2, r3, [r8, #-8]
 8010486:	e9d7 0100 	ldrd	r0, r1, [r7]
 801048a:	f017 fd0d 	bl	8027ea8 <__aeabi_dmul>
 801048e:	4602      	mov	r2, r0
 8010490:	460b      	mov	r3, r1
 8010492:	4620      	mov	r0, r4
 8010494:	4629      	mov	r1, r5
 8010496:	f017 fb51 	bl	8027b3c <__adddf3>
      for (j = j_min; j < j_max; j++) {
 801049a:	3601      	adds	r6, #1
 801049c:	45b1      	cmp	r9, r6
 801049e:	44d0      	add	r8, sl
        temp += X[jx] * A[lda * j + i];
 80104a0:	4604      	mov	r4, r0
 80104a2:	460d      	mov	r5, r1
      for (j = j_min; j < j_max; j++) {
 80104a4:	445f      	add	r7, fp
 80104a6:	d1ec      	bne.n	8010482 <cblas_dtrmv+0x456>
      if (nonunit) {
 80104a8:	9b01      	ldr	r3, [sp, #4]
 80104aa:	2b83      	cmp	r3, #131	; 0x83
 80104ac:	d01a      	beq.n	80104e4 <cblas_dtrmv+0x4b8>
        X[ix] += temp;
 80104ae:	4622      	mov	r2, r4
 80104b0:	9c02      	ldr	r4, [sp, #8]
 80104b2:	462b      	mov	r3, r5
 80104b4:	e9d4 0100 	ldrd	r0, r1, [r4]
 80104b8:	f017 fb40 	bl	8027b3c <__adddf3>
 80104bc:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 80104c0:	9b02      	ldr	r3, [sp, #8]
 80104c2:	9a06      	ldr	r2, [sp, #24]
 80104c4:	4413      	add	r3, r2
 80104c6:	9302      	str	r3, [sp, #8]
 80104c8:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 80104cc:	4413      	add	r3, r2
 80104ce:	9304      	str	r3, [sp, #16]
 80104d0:	9b03      	ldr	r3, [sp, #12]
 80104d2:	3b08      	subs	r3, #8
 80104d4:	9303      	str	r3, [sp, #12]
 80104d6:	f1b9 0f00 	cmp.w	r9, #0
 80104da:	f43f ae73 	beq.w	80101c4 <cblas_dtrmv+0x198>
 80104de:	f109 39ff 	add.w	r9, r9, #4294967295
 80104e2:	e7c5      	b.n	8010470 <cblas_dtrmv+0x444>
        X[ix] = temp + X[ix] * A[lda * i + i];
 80104e4:	9e02      	ldr	r6, [sp, #8]
 80104e6:	9b04      	ldr	r3, [sp, #16]
 80104e8:	e9d6 0100 	ldrd	r0, r1, [r6]
 80104ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80104f0:	f017 fcda 	bl	8027ea8 <__aeabi_dmul>
 80104f4:	4622      	mov	r2, r4
 80104f6:	462b      	mov	r3, r5
 80104f8:	f017 fb20 	bl	8027b3c <__adddf3>
 80104fc:	e9c6 0100 	strd	r0, r1, [r6]
 8010500:	e7de      	b.n	80104c0 <cblas_dtrmv+0x494>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8010502:	2009      	movs	r0, #9
 8010504:	e5c0      	b.n	8010088 <cblas_dtrmv+0x5c>
 8010506:	bf00      	nop

08010508 <cblas_dtrsm>:
cblas_dtrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const double alpha, const double *A, const int lda, double *B,
             const int ldb)
{
 8010508:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801050c:	b093      	sub	sp, #76	; 0x4c
 801050e:	461f      	mov	r7, r3
 8010510:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
 8010514:	9304      	str	r3, [sp, #16]
 8010516:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8010518:	9301      	str	r3, [sp, #4]
 801051a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 801051c:	9306      	str	r3, [sp, #24]
 801051e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8010520:	930c      	str	r3, [sp, #48]	; 0x30
 8010522:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8010524:	9309      	str	r3, [sp, #36]	; 0x24
 8010526:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8010528:	9305      	str	r3, [sp, #20]
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801052a:	298d      	cmp	r1, #141	; 0x8d
 801052c:	9b22      	ldr	r3, [sp, #136]	; 0x88
 801052e:	9303      	str	r3, [sp, #12]
 8010530:	ec55 4b10 	vmov	r4, r5, d0
 8010534:	460e      	mov	r6, r1
 8010536:	4690      	mov	r8, r2
 8010538:	d066      	beq.n	8010608 <cblas_dtrsm+0x100>
 801053a:	298e      	cmp	r1, #142	; 0x8e
 801053c:	f000 8313 	beq.w	8010b66 <cblas_dtrsm+0x65e>
 8010540:	f8dd c018 	ldr.w	ip, [sp, #24]
 8010544:	2302      	movs	r3, #2
 8010546:	f1a8 0279 	sub.w	r2, r8, #121	; 0x79
 801054a:	2a01      	cmp	r2, #1
 801054c:	9a04      	ldr	r2, [sp, #16]
 801054e:	f1a7 016f 	sub.w	r1, r7, #111	; 0x6f
 8010552:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8010556:	bf88      	it	hi
 8010558:	2303      	movhi	r3, #3
 801055a:	b2d2      	uxtb	r2, r2
 801055c:	2902      	cmp	r1, #2
 801055e:	bf88      	it	hi
 8010560:	2304      	movhi	r3, #4
 8010562:	2a02      	cmp	r2, #2
 8010564:	9a01      	ldr	r2, [sp, #4]
 8010566:	bf28      	it	cs
 8010568:	2305      	movcs	r3, #5
 801056a:	2a00      	cmp	r2, #0
 801056c:	9a06      	ldr	r2, [sp, #24]
 801056e:	bfb8      	it	lt
 8010570:	2306      	movlt	r3, #6
 8010572:	2a00      	cmp	r2, #0
 8010574:	bfb8      	it	lt
 8010576:	2307      	movlt	r3, #7
 8010578:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801057a:	f1bc 0f01 	cmp.w	ip, #1
 801057e:	bfb8      	it	lt
 8010580:	f04f 0c01 	movlt.w	ip, #1
 8010584:	4594      	cmp	ip, r2
 8010586:	dd32      	ble.n	80105ee <cblas_dtrsm+0xe6>
 8010588:	2865      	cmp	r0, #101	; 0x65
 801058a:	f000 80f8 	beq.w	801077e <cblas_dtrsm+0x276>
 801058e:	9b01      	ldr	r3, [sp, #4]
 8010590:	9a03      	ldr	r2, [sp, #12]
 8010592:	2b01      	cmp	r3, #1
 8010594:	bfb8      	it	lt
 8010596:	2301      	movlt	r3, #1
 8010598:	4293      	cmp	r3, r2
 801059a:	bfcc      	ite	gt
 801059c:	230c      	movgt	r3, #12
 801059e:	230a      	movle	r3, #10
 80105a0:	4a84      	ldr	r2, [pc, #528]	; (80107b4 <cblas_dtrsm+0x2ac>)
 80105a2:	4985      	ldr	r1, [pc, #532]	; (80107b8 <cblas_dtrsm+0x2b0>)
 80105a4:	4618      	mov	r0, r3
 80105a6:	f017 fa4f 	bl	8027a48 <cblas_xerbla>
    side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 80105aa:	2e8d      	cmp	r6, #141	; 0x8d
 80105ac:	bf0c      	ite	eq
 80105ae:	268e      	moveq	r6, #142	; 0x8e
 80105b0:	268d      	movne	r6, #141	; 0x8d
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 80105b2:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80105b6:	bf0c      	ite	eq
 80105b8:	f04f 087a 	moveq.w	r8, #122	; 0x7a
 80105bc:	f04f 0879 	movne.w	r8, #121	; 0x79
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 80105c0:	2f71      	cmp	r7, #113	; 0x71
 80105c2:	bf08      	it	eq
 80105c4:	2770      	moveq	r7, #112	; 0x70
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80105c6:	2e8d      	cmp	r6, #141	; 0x8d
 80105c8:	d027      	beq.n	801061a <cblas_dtrsm+0x112>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 80105ca:	2e8e      	cmp	r6, #142	; 0x8e
 80105cc:	d107      	bne.n	80105de <cblas_dtrsm+0xd6>
 80105ce:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80105d2:	f000 80f7 	beq.w	80107c4 <cblas_dtrsm+0x2bc>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 80105d6:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 80105da:	f000 8188 	beq.w	80108ee <cblas_dtrsm+0x3e6>
    BLAS_ERROR("unrecognized operation");
 80105de:	4a77      	ldr	r2, [pc, #476]	; (80107bc <cblas_dtrsm+0x2b4>)
 80105e0:	4975      	ldr	r1, [pc, #468]	; (80107b8 <cblas_dtrsm+0x2b0>)
 80105e2:	2000      	movs	r0, #0
#define BASE double
#include "source_trsm_r.h"
#undef BASE
}
 80105e4:	b013      	add	sp, #76	; 0x4c
 80105e6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80105ea:	f017 ba2d 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80105ee:	2865      	cmp	r0, #101	; 0x65
 80105f0:	f000 8210 	beq.w	8010a14 <cblas_dtrsm+0x50c>
 80105f4:	9a01      	ldr	r2, [sp, #4]
 80105f6:	9903      	ldr	r1, [sp, #12]
 80105f8:	2a01      	cmp	r2, #1
 80105fa:	bfb8      	it	lt
 80105fc:	2201      	movlt	r2, #1
 80105fe:	428a      	cmp	r2, r1
 8010600:	f340 80d3 	ble.w	80107aa <cblas_dtrsm+0x2a2>
 8010604:	230c      	movs	r3, #12
 8010606:	e7cb      	b.n	80105a0 <cblas_dtrsm+0x98>
 8010608:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 801060c:	2b01      	cmp	r3, #1
 801060e:	f8dd c004 	ldr.w	ip, [sp, #4]
 8010612:	bf94      	ite	ls
 8010614:	2300      	movls	r3, #0
 8010616:	2301      	movhi	r3, #1
 8010618:	e795      	b.n	8010546 <cblas_dtrsm+0x3e>
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 801061a:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801061e:	f000 8205 	beq.w	8010a2c <cblas_dtrsm+0x524>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8010622:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8010626:	d1da      	bne.n	80105de <cblas_dtrsm+0xd6>
 8010628:	2f6f      	cmp	r7, #111	; 0x6f
 801062a:	f000 83a3 	beq.w	8010d74 <cblas_dtrsm+0x86c>
  } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
 801062e:	2f70      	cmp	r7, #112	; 0x70
 8010630:	d1d5      	bne.n	80105de <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 8010632:	4b63      	ldr	r3, [pc, #396]	; (80107c0 <cblas_dtrsm+0x2b8>)
 8010634:	2200      	movs	r2, #0
 8010636:	4620      	mov	r0, r4
 8010638:	4629      	mov	r1, r5
 801063a:	f017 fe9d 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 801063e:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8010640:	2800      	cmp	r0, #0
 8010642:	f040 8585 	bne.w	8011150 <cblas_dtrsm+0xc48>
      for (i = 0; i < n1; i++) {
 8010646:	2b00      	cmp	r3, #0
 8010648:	f340 82a3 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 801064c:	9a03      	ldr	r2, [sp, #12]
 801064e:	9b01      	ldr	r3, [sp, #4]
 8010650:	f8dd b018 	ldr.w	fp, [sp, #24]
 8010654:	00d2      	lsls	r2, r2, #3
 8010656:	9202      	str	r2, [sp, #8]
 8010658:	00da      	lsls	r2, r3, #3
 801065a:	920e      	str	r2, [sp, #56]	; 0x38
 801065c:	9a05      	ldr	r2, [sp, #20]
 801065e:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8010662:	4680      	mov	r8, r0
 8010664:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010668:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 801066c:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 801066e:	f1ba 0f00 	cmp.w	sl, #0
 8010672:	bfc8      	it	gt
 8010674:	eb07 0609 	addgt.w	r6, r7, r9
 8010678:	dd09      	ble.n	801068e <cblas_dtrsm+0x186>
          B[ldb * i + j] *= alpha;
 801067a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801067e:	4622      	mov	r2, r4
 8010680:	462b      	mov	r3, r5
 8010682:	f017 fc11 	bl	8027ea8 <__aeabi_dmul>
 8010686:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 801068a:	42be      	cmp	r6, r7
 801068c:	d1f5      	bne.n	801067a <cblas_dtrsm+0x172>
      for (i = 0; i < n1; i++) {
 801068e:	9b02      	ldr	r3, [sp, #8]
 8010690:	f108 0801 	add.w	r8, r8, #1
 8010694:	45c3      	cmp	fp, r8
 8010696:	441f      	add	r7, r3
 8010698:	d1e9      	bne.n	801066e <cblas_dtrsm+0x166>
 801069a:	9c06      	ldr	r4, [sp, #24]
 801069c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 801069e:	1e63      	subs	r3, r4, #1
 80106a0:	4620      	mov	r0, r4
 80106a2:	fb03 f206 	mul.w	r2, r3, r6
 80106a6:	461f      	mov	r7, r3
 80106a8:	ebc0 7540 	rsb	r5, r0, r0, lsl #29
 80106ac:	9308      	str	r3, [sp, #32]
 80106ae:	980c      	ldr	r0, [sp, #48]	; 0x30
 80106b0:	fb06 3303 	mla	r3, r6, r3, r3
 80106b4:	1a9b      	subs	r3, r3, r2
 80106b6:	1914      	adds	r4, r2, r4
 80106b8:	3808      	subs	r0, #8
 80106ba:	00db      	lsls	r3, r3, #3
 80106bc:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
 80106c0:	9310      	str	r3, [sp, #64]	; 0x40
 80106c2:	980c      	ldr	r0, [sp, #48]	; 0x30
 80106c4:	9b02      	ldr	r3, [sp, #8]
 80106c6:	9407      	str	r4, [sp, #28]
 80106c8:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 80106cc:	4618      	mov	r0, r3
 80106ce:	9b05      	ldr	r3, [sp, #20]
 80106d0:	920a      	str	r2, [sp, #40]	; 0x28
 80106d2:	43f1      	mvns	r1, r6
 80106d4:	fb00 3207 	mla	r2, r0, r7, r3
 80106d8:	ebc6 7a46 	rsb	sl, r6, r6, lsl #29
 80106dc:	9e03      	ldr	r6, [sp, #12]
 80106de:	9209      	str	r2, [sp, #36]	; 0x24
 80106e0:	00ca      	lsls	r2, r1, #3
 80106e2:	ebc6 7646 	rsb	r6, r6, r6, lsl #29
 80106e6:	920c      	str	r2, [sp, #48]	; 0x30
 80106e8:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80106ec:	920d      	str	r2, [sp, #52]	; 0x34
 80106ee:	00f2      	lsls	r2, r6, #3
 80106f0:	920f      	str	r2, [sp, #60]	; 0x3c
 80106f2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80106f4:	00ed      	lsls	r5, r5, #3
 80106f6:	4413      	add	r3, r2
 80106f8:	9511      	str	r5, [sp, #68]	; 0x44
 80106fa:	930b      	str	r3, [sp, #44]	; 0x2c
      if (nonunit) {
 80106fc:	9b04      	ldr	r3, [sp, #16]
 80106fe:	2b83      	cmp	r3, #131	; 0x83
 8010700:	f000 826e 	beq.w	8010be0 <cblas_dtrsm+0x6d8>
      for (k = 0; k < i; k++) {
 8010704:	9b08      	ldr	r3, [sp, #32]
 8010706:	2b00      	cmp	r3, #0
 8010708:	f000 8243 	beq.w	8010b92 <cblas_dtrsm+0x68a>
 801070c:	e9dd ba0a 	ldrd	fp, sl, [sp, #40]	; 0x28
 8010710:	2300      	movs	r3, #0
 8010712:	9306      	str	r3, [sp, #24]
        for (j = 0; j < n2; j++) {
 8010714:	9b01      	ldr	r3, [sp, #4]
 8010716:	2b00      	cmp	r3, #0
        const BASE Aik = A[i * lda + k];
 8010718:	e8fb 8902 	ldrd	r8, r9, [fp], #8
        for (j = 0; j < n2; j++) {
 801071c:	dd16      	ble.n	801074c <cblas_dtrsm+0x244>
 801071e:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
 8010722:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8010724:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 8010728:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 801072c:	4642      	mov	r2, r8
 801072e:	464b      	mov	r3, r9
 8010730:	f017 fbba 	bl	8027ea8 <__aeabi_dmul>
 8010734:	e9d4 6700 	ldrd	r6, r7, [r4]
 8010738:	4602      	mov	r2, r0
 801073a:	460b      	mov	r3, r1
 801073c:	4630      	mov	r0, r6
 801073e:	4639      	mov	r1, r7
 8010740:	f017 f9fa 	bl	8027b38 <__aeabi_dsub>
 8010744:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010748:	4554      	cmp	r4, sl
 801074a:	d1ed      	bne.n	8010728 <cblas_dtrsm+0x220>
      for (k = 0; k < i; k++) {
 801074c:	9b06      	ldr	r3, [sp, #24]
 801074e:	9a03      	ldr	r2, [sp, #12]
 8010750:	4413      	add	r3, r2
 8010752:	9306      	str	r3, [sp, #24]
 8010754:	9b02      	ldr	r3, [sp, #8]
 8010756:	449a      	add	sl, r3
 8010758:	9b07      	ldr	r3, [sp, #28]
 801075a:	459b      	cmp	fp, r3
 801075c:	d1da      	bne.n	8010714 <cblas_dtrsm+0x20c>
 801075e:	9b07      	ldr	r3, [sp, #28]
 8010760:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8010762:	4413      	add	r3, r2
 8010764:	9307      	str	r3, [sp, #28]
 8010766:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010768:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801076a:	4413      	add	r3, r2
 801076c:	930a      	str	r3, [sp, #40]	; 0x28
 801076e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8010770:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010772:	4413      	add	r3, r2
 8010774:	9309      	str	r3, [sp, #36]	; 0x24
 8010776:	9b08      	ldr	r3, [sp, #32]
 8010778:	3b01      	subs	r3, #1
 801077a:	9308      	str	r3, [sp, #32]
 801077c:	e7be      	b.n	80106fc <cblas_dtrsm+0x1f4>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 801077e:	9b06      	ldr	r3, [sp, #24]
 8010780:	9a03      	ldr	r2, [sp, #12]
 8010782:	2b01      	cmp	r3, #1
 8010784:	bfb8      	it	lt
 8010786:	2301      	movlt	r3, #1
 8010788:	4293      	cmp	r3, r2
 801078a:	bfcc      	ite	gt
 801078c:	230c      	movgt	r3, #12
 801078e:	230a      	movle	r3, #10
 8010790:	4a08      	ldr	r2, [pc, #32]	; (80107b4 <cblas_dtrsm+0x2ac>)
 8010792:	4909      	ldr	r1, [pc, #36]	; (80107b8 <cblas_dtrsm+0x2b0>)
 8010794:	4618      	mov	r0, r3
 8010796:	f017 f957 	bl	8027a48 <cblas_xerbla>
    trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
 801079a:	2f71      	cmp	r7, #113	; 0x71
 801079c:	9b06      	ldr	r3, [sp, #24]
 801079e:	d100      	bne.n	80107a2 <cblas_dtrsm+0x29a>
 80107a0:	2770      	movs	r7, #112	; 0x70
 80107a2:	9a01      	ldr	r2, [sp, #4]
 80107a4:	9206      	str	r2, [sp, #24]
 80107a6:	9301      	str	r3, [sp, #4]
 80107a8:	e70d      	b.n	80105c6 <cblas_dtrsm+0xbe>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80107aa:	2b00      	cmp	r3, #0
 80107ac:	f43f aefd 	beq.w	80105aa <cblas_dtrsm+0xa2>
 80107b0:	e6f6      	b.n	80105a0 <cblas_dtrsm+0x98>
 80107b2:	bf00      	nop
 80107b4:	08030378 	.word	0x08030378
 80107b8:	08030690 	.word	0x08030690
 80107bc:	080305a8 	.word	0x080305a8
 80107c0:	3ff00000 	.word	0x3ff00000
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 80107c4:	2f6f      	cmp	r7, #111	; 0x6f
 80107c6:	f000 8383 	beq.w	8010ed0 <cblas_dtrsm+0x9c8>
  } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
 80107ca:	2f70      	cmp	r7, #112	; 0x70
 80107cc:	f47f af07 	bne.w	80105de <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 80107d0:	4b95      	ldr	r3, [pc, #596]	; (8010a28 <cblas_dtrsm+0x520>)
 80107d2:	2200      	movs	r2, #0
 80107d4:	4620      	mov	r0, r4
 80107d6:	4629      	mov	r1, r5
 80107d8:	f017 fdce 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 80107dc:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 80107de:	2800      	cmp	r0, #0
 80107e0:	f040 84ed 	bne.w	80111be <cblas_dtrsm+0xcb6>
      for (i = 0; i < n1; i++) {
 80107e4:	2b00      	cmp	r3, #0
 80107e6:	f340 81d4 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 80107ea:	9a03      	ldr	r2, [sp, #12]
 80107ec:	9b01      	ldr	r3, [sp, #4]
 80107ee:	f8dd b018 	ldr.w	fp, [sp, #24]
 80107f2:	00d2      	lsls	r2, r2, #3
 80107f4:	9202      	str	r2, [sp, #8]
 80107f6:	00da      	lsls	r2, r3, #3
 80107f8:	920e      	str	r2, [sp, #56]	; 0x38
 80107fa:	9a05      	ldr	r2, [sp, #20]
 80107fc:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8010800:	4680      	mov	r8, r0
 8010802:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010806:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 801080a:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 801080c:	f1ba 0f00 	cmp.w	sl, #0
 8010810:	bfc8      	it	gt
 8010812:	eb07 0609 	addgt.w	r6, r7, r9
 8010816:	dd09      	ble.n	801082c <cblas_dtrsm+0x324>
          B[ldb * i + j] *= alpha;
 8010818:	e9d6 0100 	ldrd	r0, r1, [r6]
 801081c:	4622      	mov	r2, r4
 801081e:	462b      	mov	r3, r5
 8010820:	f017 fb42 	bl	8027ea8 <__aeabi_dmul>
 8010824:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8010828:	42be      	cmp	r6, r7
 801082a:	d1f5      	bne.n	8010818 <cblas_dtrsm+0x310>
      for (i = 0; i < n1; i++) {
 801082c:	9b02      	ldr	r3, [sp, #8]
 801082e:	f108 0801 	add.w	r8, r8, #1
 8010832:	45c3      	cmp	fp, r8
 8010834:	441f      	add	r7, r3
 8010836:	d1e9      	bne.n	801080c <cblas_dtrsm+0x304>
 8010838:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801083a:	980e      	ldr	r0, [sp, #56]	; 0x38
 801083c:	9905      	ldr	r1, [sp, #20]
 801083e:	9108      	str	r1, [sp, #32]
 8010840:	ea6f 0a02 	mvn.w	sl, r2
 8010844:	4604      	mov	r4, r0
 8010846:	1c53      	adds	r3, r2, #1
 8010848:	440c      	add	r4, r1
 801084a:	9a01      	ldr	r2, [sp, #4]
 801084c:	940b      	str	r4, [sp, #44]	; 0x2c
 801084e:	ea4f 01ca 	mov.w	r1, sl, lsl #3
 8010852:	9109      	str	r1, [sp, #36]	; 0x24
 8010854:	990c      	ldr	r1, [sp, #48]	; 0x30
 8010856:	00db      	lsls	r3, r3, #3
 8010858:	3a01      	subs	r2, #1
 801085a:	fb03 1202 	mla	r2, r3, r2, r1
 801085e:	f1a3 0b08 	sub.w	fp, r3, #8
 8010862:	f101 0308 	add.w	r3, r1, #8
 8010866:	930a      	str	r3, [sp, #40]	; 0x28
      for (j = n2; j > 0 && j--;) {
 8010868:	2300      	movs	r3, #0
 801086a:	920d      	str	r2, [sp, #52]	; 0x34
 801086c:	930c      	str	r3, [sp, #48]	; 0x30
 801086e:	9b01      	ldr	r3, [sp, #4]
 8010870:	2b00      	cmp	r3, #0
 8010872:	f340 8191 	ble.w	8010b98 <cblas_dtrsm+0x690>
 8010876:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010878:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801087a:	9307      	str	r3, [sp, #28]
 801087c:	469a      	mov	sl, r3
 801087e:	9b01      	ldr	r3, [sp, #4]
 8010880:	9205      	str	r2, [sp, #20]
 8010882:	9303      	str	r3, [sp, #12]
 8010884:	9b03      	ldr	r3, [sp, #12]
 8010886:	3b01      	subs	r3, #1
 8010888:	9303      	str	r3, [sp, #12]
        if (nonunit) {
 801088a:	9b04      	ldr	r3, [sp, #16]
 801088c:	2b83      	cmp	r3, #131	; 0x83
 801088e:	d109      	bne.n	80108a4 <cblas_dtrsm+0x39c>
          B[ldb * i + j] /= Ajj;
 8010890:	9c07      	ldr	r4, [sp, #28]
 8010892:	9b05      	ldr	r3, [sp, #20]
 8010894:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8010898:	e9d3 2300 	ldrd	r2, r3, [r3]
 801089c:	f017 fc2e 	bl	80280fc <__aeabi_ddiv>
 80108a0:	e944 0102 	strd	r0, r1, [r4, #-8]
          for (k = 0; k < j; k++) {
 80108a4:	9b03      	ldr	r3, [sp, #12]
          BASE Bij = B[ldb * i + j];
 80108a6:	e97a 8902 	ldrd	r8, r9, [sl, #-8]!
          for (k = 0; k < j; k++) {
 80108aa:	2b00      	cmp	r3, #0
 80108ac:	f000 8174 	beq.w	8010b98 <cblas_dtrsm+0x690>
 80108b0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80108b2:	9c08      	ldr	r4, [sp, #32]
 80108b4:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 80108b8:	e955 2302 	ldrd	r2, r3, [r5, #-8]
 80108bc:	4640      	mov	r0, r8
 80108be:	4649      	mov	r1, r9
 80108c0:	f017 faf2 	bl	8027ea8 <__aeabi_dmul>
 80108c4:	e9d4 6700 	ldrd	r6, r7, [r4]
 80108c8:	4602      	mov	r2, r0
 80108ca:	460b      	mov	r3, r1
 80108cc:	4630      	mov	r0, r6
 80108ce:	4639      	mov	r1, r7
 80108d0:	f017 f932 	bl	8027b38 <__aeabi_dsub>
 80108d4:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = 0; k < j; k++) {
 80108d8:	4554      	cmp	r4, sl
 80108da:	445d      	add	r5, fp
 80108dc:	d1ec      	bne.n	80108b8 <cblas_dtrsm+0x3b0>
 80108de:	9b05      	ldr	r3, [sp, #20]
 80108e0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80108e2:	4413      	add	r3, r2
 80108e4:	9305      	str	r3, [sp, #20]
 80108e6:	9b07      	ldr	r3, [sp, #28]
 80108e8:	3b08      	subs	r3, #8
 80108ea:	9307      	str	r3, [sp, #28]
 80108ec:	e7ca      	b.n	8010884 <cblas_dtrsm+0x37c>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 80108ee:	2f6f      	cmp	r7, #111	; 0x6f
 80108f0:	f000 837e 	beq.w	8010ff0 <cblas_dtrsm+0xae8>
  } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
 80108f4:	2f70      	cmp	r7, #112	; 0x70
 80108f6:	f47f ae72 	bne.w	80105de <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 80108fa:	4b4b      	ldr	r3, [pc, #300]	; (8010a28 <cblas_dtrsm+0x520>)
 80108fc:	2200      	movs	r2, #0
 80108fe:	4620      	mov	r0, r4
 8010900:	4629      	mov	r1, r5
 8010902:	f017 fd39 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 8010906:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8010908:	2800      	cmp	r0, #0
 801090a:	f040 840c 	bne.w	8011126 <cblas_dtrsm+0xc1e>
      for (i = 0; i < n1; i++) {
 801090e:	2b00      	cmp	r3, #0
 8010910:	f340 813f 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8010914:	9a03      	ldr	r2, [sp, #12]
 8010916:	9b01      	ldr	r3, [sp, #4]
 8010918:	f8dd b018 	ldr.w	fp, [sp, #24]
 801091c:	00d2      	lsls	r2, r2, #3
 801091e:	9202      	str	r2, [sp, #8]
 8010920:	00da      	lsls	r2, r3, #3
 8010922:	920e      	str	r2, [sp, #56]	; 0x38
 8010924:	9a05      	ldr	r2, [sp, #20]
 8010926:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 801092a:	4680      	mov	r8, r0
 801092c:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010930:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8010934:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 8010936:	f1ba 0f00 	cmp.w	sl, #0
 801093a:	bfc8      	it	gt
 801093c:	eb07 0609 	addgt.w	r6, r7, r9
 8010940:	dd09      	ble.n	8010956 <cblas_dtrsm+0x44e>
          B[ldb * i + j] *= alpha;
 8010942:	e9d6 0100 	ldrd	r0, r1, [r6]
 8010946:	4622      	mov	r2, r4
 8010948:	462b      	mov	r3, r5
 801094a:	f017 faad 	bl	8027ea8 <__aeabi_dmul>
 801094e:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8010952:	42be      	cmp	r6, r7
 8010954:	d1f5      	bne.n	8010942 <cblas_dtrsm+0x43a>
      for (i = 0; i < n1; i++) {
 8010956:	9b02      	ldr	r3, [sp, #8]
 8010958:	f108 0801 	add.w	r8, r8, #1
 801095c:	45c3      	cmp	fp, r8
 801095e:	441f      	add	r7, r3
 8010960:	d1e9      	bne.n	8010936 <cblas_dtrsm+0x42e>
 8010962:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010964:	9805      	ldr	r0, [sp, #20]
 8010966:	990e      	ldr	r1, [sp, #56]	; 0x38
 8010968:	900d      	str	r0, [sp, #52]	; 0x34
 801096a:	1c53      	adds	r3, r2, #1
 801096c:	00db      	lsls	r3, r3, #3
 801096e:	930a      	str	r3, [sp, #40]	; 0x28
 8010970:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010972:	ea4f 0bc2 	mov.w	fp, r2, lsl #3
 8010976:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801097a:	930f      	str	r3, [sp, #60]	; 0x3c
 801097c:	f10b 0308 	add.w	r3, fp, #8
 8010980:	4401      	add	r1, r0
 8010982:	930b      	str	r3, [sp, #44]	; 0x2c
          for (k = j + 1; k < n2; k++) {
 8010984:	2300      	movs	r3, #0
 8010986:	468a      	mov	sl, r1
 8010988:	930e      	str	r3, [sp, #56]	; 0x38
      for (j = 0; j < n2; j++) {
 801098a:	9b01      	ldr	r3, [sp, #4]
 801098c:	2b00      	cmp	r3, #0
 801098e:	f340 80f3 	ble.w	8010b78 <cblas_dtrsm+0x670>
 8010992:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010994:	9305      	str	r3, [sp, #20]
 8010996:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010998:	9307      	str	r3, [sp, #28]
 801099a:	9309      	str	r3, [sp, #36]	; 0x24
 801099c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801099e:	9303      	str	r3, [sp, #12]
 80109a0:	2300      	movs	r3, #0
 80109a2:	9308      	str	r3, [sp, #32]
        if (nonunit) {
 80109a4:	9b04      	ldr	r3, [sp, #16]
 80109a6:	2b83      	cmp	r3, #131	; 0x83
 80109a8:	d109      	bne.n	80109be <cblas_dtrsm+0x4b6>
          B[ldb * i + j] /= Ajj;
 80109aa:	9c07      	ldr	r4, [sp, #28]
 80109ac:	9b05      	ldr	r3, [sp, #20]
 80109ae:	e9d4 0100 	ldrd	r0, r1, [r4]
 80109b2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80109b6:	f017 fba1 	bl	80280fc <__aeabi_ddiv>
 80109ba:	e9c4 0100 	strd	r0, r1, [r4]
          BASE Bij = B[ldb * i + j];
 80109be:	9c09      	ldr	r4, [sp, #36]	; 0x24
          for (k = j + 1; k < n2; k++) {
 80109c0:	9b08      	ldr	r3, [sp, #32]
 80109c2:	9a01      	ldr	r2, [sp, #4]
          BASE Bij = B[ldb * i + j];
 80109c4:	e8f4 8902 	ldrd	r8, r9, [r4], #8
          for (k = j + 1; k < n2; k++) {
 80109c8:	3301      	adds	r3, #1
 80109ca:	429a      	cmp	r2, r3
 80109cc:	9308      	str	r3, [sp, #32]
          BASE Bij = B[ldb * i + j];
 80109ce:	9409      	str	r4, [sp, #36]	; 0x24
          for (k = j + 1; k < n2; k++) {
 80109d0:	f000 80d2 	beq.w	8010b78 <cblas_dtrsm+0x670>
 80109d4:	9d03      	ldr	r5, [sp, #12]
            B[ldb * i + k] -= A[k * lda + j] * Bij;
 80109d6:	e9d5 2300 	ldrd	r2, r3, [r5]
 80109da:	4640      	mov	r0, r8
 80109dc:	4649      	mov	r1, r9
 80109de:	f017 fa63 	bl	8027ea8 <__aeabi_dmul>
 80109e2:	e9d4 6700 	ldrd	r6, r7, [r4]
 80109e6:	4602      	mov	r2, r0
 80109e8:	460b      	mov	r3, r1
 80109ea:	4630      	mov	r0, r6
 80109ec:	4639      	mov	r1, r7
 80109ee:	f017 f8a3 	bl	8027b38 <__aeabi_dsub>
 80109f2:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = j + 1; k < n2; k++) {
 80109f6:	4554      	cmp	r4, sl
 80109f8:	445d      	add	r5, fp
 80109fa:	d1ec      	bne.n	80109d6 <cblas_dtrsm+0x4ce>
 80109fc:	9b03      	ldr	r3, [sp, #12]
 80109fe:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010a00:	4413      	add	r3, r2
 8010a02:	9303      	str	r3, [sp, #12]
 8010a04:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8010a06:	9b05      	ldr	r3, [sp, #20]
 8010a08:	4413      	add	r3, r2
 8010a0a:	9305      	str	r3, [sp, #20]
 8010a0c:	9b07      	ldr	r3, [sp, #28]
 8010a0e:	3308      	adds	r3, #8
 8010a10:	9307      	str	r3, [sp, #28]
 8010a12:	e7c7      	b.n	80109a4 <cblas_dtrsm+0x49c>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8010a14:	9a06      	ldr	r2, [sp, #24]
 8010a16:	9903      	ldr	r1, [sp, #12]
 8010a18:	2a01      	cmp	r2, #1
 8010a1a:	bfb8      	it	lt
 8010a1c:	2201      	movlt	r2, #1
 8010a1e:	428a      	cmp	r2, r1
 8010a20:	f340 809d 	ble.w	8010b5e <cblas_dtrsm+0x656>
 8010a24:	230c      	movs	r3, #12
 8010a26:	e6b3      	b.n	8010790 <cblas_dtrsm+0x288>
 8010a28:	3ff00000 	.word	0x3ff00000
  if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8010a2c:	2f6f      	cmp	r7, #111	; 0x6f
 8010a2e:	f000 80f3 	beq.w	8010c18 <cblas_dtrsm+0x710>
  } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
 8010a32:	2f70      	cmp	r7, #112	; 0x70
 8010a34:	f47f add3 	bne.w	80105de <cblas_dtrsm+0xd6>
    if (alpha != 1.0) {
 8010a38:	4b76      	ldr	r3, [pc, #472]	; (8010c14 <cblas_dtrsm+0x70c>)
 8010a3a:	2200      	movs	r2, #0
 8010a3c:	4620      	mov	r0, r4
 8010a3e:	4629      	mov	r1, r5
 8010a40:	f017 fc9a 	bl	8028378 <__aeabi_dcmpeq>
 8010a44:	2800      	cmp	r0, #0
 8010a46:	f040 839b 	bne.w	8011180 <cblas_dtrsm+0xc78>
      for (i = 0; i < n1; i++) {
 8010a4a:	9906      	ldr	r1, [sp, #24]
 8010a4c:	2900      	cmp	r1, #0
 8010a4e:	f340 80a0 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8010a52:	9a03      	ldr	r2, [sp, #12]
 8010a54:	9b01      	ldr	r3, [sp, #4]
 8010a56:	00d2      	lsls	r2, r2, #3
 8010a58:	9202      	str	r2, [sp, #8]
 8010a5a:	00da      	lsls	r2, r3, #3
 8010a5c:	920e      	str	r2, [sp, #56]	; 0x38
 8010a5e:	9a05      	ldr	r2, [sp, #20]
 8010a60:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8010a64:	4680      	mov	r8, r0
 8010a66:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010a6a:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8010a6e:	469a      	mov	sl, r3
 8010a70:	468b      	mov	fp, r1
        for (j = 0; j < n2; j++) {
 8010a72:	f1ba 0f00 	cmp.w	sl, #0
 8010a76:	bfc8      	it	gt
 8010a78:	eb09 0607 	addgt.w	r6, r9, r7
 8010a7c:	dd09      	ble.n	8010a92 <cblas_dtrsm+0x58a>
          B[ldb * i + j] *= alpha;
 8010a7e:	e9d6 0100 	ldrd	r0, r1, [r6]
 8010a82:	4622      	mov	r2, r4
 8010a84:	462b      	mov	r3, r5
 8010a86:	f017 fa0f 	bl	8027ea8 <__aeabi_dmul>
 8010a8a:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8010a8e:	42b7      	cmp	r7, r6
 8010a90:	d1f5      	bne.n	8010a7e <cblas_dtrsm+0x576>
      for (i = 0; i < n1; i++) {
 8010a92:	9b02      	ldr	r3, [sp, #8]
 8010a94:	f108 0801 	add.w	r8, r8, #1
 8010a98:	45c3      	cmp	fp, r8
 8010a9a:	441f      	add	r7, r3
 8010a9c:	d1e9      	bne.n	8010a72 <cblas_dtrsm+0x56a>
 8010a9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010aa0:	9903      	ldr	r1, [sp, #12]
 8010aa2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8010aa4:	9d06      	ldr	r5, [sp, #24]
 8010aa6:	00d8      	lsls	r0, r3, #3
 8010aa8:	9b01      	ldr	r3, [sp, #4]
 8010aaa:	9011      	str	r0, [sp, #68]	; 0x44
 8010aac:	440b      	add	r3, r1
 8010aae:	00db      	lsls	r3, r3, #3
 8010ab0:	eb02 01c5 	add.w	r1, r2, r5, lsl #3
 8010ab4:	2400      	movs	r4, #0
 8010ab6:	9109      	str	r1, [sp, #36]	; 0x24
 8010ab8:	3208      	adds	r2, #8
 8010aba:	f100 0108 	add.w	r1, r0, #8
 8010abe:	930f      	str	r3, [sp, #60]	; 0x3c
 8010ac0:	9b05      	ldr	r3, [sp, #20]
 8010ac2:	940d      	str	r4, [sp, #52]	; 0x34
 8010ac4:	9110      	str	r1, [sp, #64]	; 0x40
 8010ac6:	920a      	str	r2, [sp, #40]	; 0x28
 8010ac8:	940b      	str	r4, [sp, #44]	; 0x2c
 8010aca:	9308      	str	r3, [sp, #32]
      if (nonunit) {
 8010acc:	9b04      	ldr	r3, [sp, #16]
 8010ace:	2b83      	cmp	r3, #131	; 0x83
 8010ad0:	d072      	beq.n	8010bb8 <cblas_dtrsm+0x6b0>
      for (k = i + 1; k < n1; k++) {
 8010ad2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010ad4:	9a06      	ldr	r2, [sp, #24]
 8010ad6:	3301      	adds	r3, #1
 8010ad8:	429a      	cmp	r2, r3
 8010ada:	930b      	str	r3, [sp, #44]	; 0x2c
 8010adc:	dd59      	ble.n	8010b92 <cblas_dtrsm+0x68a>
 8010ade:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010ae0:	9a03      	ldr	r2, [sp, #12]
 8010ae2:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 8010ae6:	4413      	add	r3, r2
 8010ae8:	930d      	str	r3, [sp, #52]	; 0x34
 8010aea:	9a08      	ldr	r2, [sp, #32]
 8010aec:	9307      	str	r3, [sp, #28]
 8010aee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8010af0:	eb03 0a02 	add.w	sl, r3, r2
        for (j = 0; j < n2; j++) {
 8010af4:	9b01      	ldr	r3, [sp, #4]
 8010af6:	2b00      	cmp	r3, #0
        const BASE Aik = A[i * lda + k];
 8010af8:	e8fb 8902 	ldrd	r8, r9, [fp], #8
        for (j = 0; j < n2; j++) {
 8010afc:	dd16      	ble.n	8010b2c <cblas_dtrsm+0x624>
 8010afe:	9b05      	ldr	r3, [sp, #20]
 8010b00:	9a07      	ldr	r2, [sp, #28]
 8010b02:	9d08      	ldr	r5, [sp, #32]
 8010b04:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aik * B[ldb * i + j];
 8010b08:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8010b0c:	4642      	mov	r2, r8
 8010b0e:	464b      	mov	r3, r9
 8010b10:	f017 f9ca 	bl	8027ea8 <__aeabi_dmul>
 8010b14:	e9d4 6700 	ldrd	r6, r7, [r4]
 8010b18:	4602      	mov	r2, r0
 8010b1a:	460b      	mov	r3, r1
 8010b1c:	4630      	mov	r0, r6
 8010b1e:	4639      	mov	r1, r7
 8010b20:	f017 f80a 	bl	8027b38 <__aeabi_dsub>
 8010b24:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010b28:	45a2      	cmp	sl, r4
 8010b2a:	d1ed      	bne.n	8010b08 <cblas_dtrsm+0x600>
      for (k = i + 1; k < n1; k++) {
 8010b2c:	9b07      	ldr	r3, [sp, #28]
 8010b2e:	9a03      	ldr	r2, [sp, #12]
 8010b30:	4413      	add	r3, r2
 8010b32:	9307      	str	r3, [sp, #28]
 8010b34:	9b02      	ldr	r3, [sp, #8]
 8010b36:	449a      	add	sl, r3
 8010b38:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010b3a:	455b      	cmp	r3, fp
 8010b3c:	d1da      	bne.n	8010af4 <cblas_dtrsm+0x5ec>
 8010b3e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8010b40:	4413      	add	r3, r2
 8010b42:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010b44:	9309      	str	r3, [sp, #36]	; 0x24
 8010b46:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010b48:	4611      	mov	r1, r2
 8010b4a:	4419      	add	r1, r3
 8010b4c:	9a08      	ldr	r2, [sp, #32]
 8010b4e:	910a      	str	r1, [sp, #40]	; 0x28
 8010b50:	9902      	ldr	r1, [sp, #8]
 8010b52:	440a      	add	r2, r1
 8010b54:	9208      	str	r2, [sp, #32]
 8010b56:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8010b58:	441a      	add	r2, r3
 8010b5a:	920c      	str	r2, [sp, #48]	; 0x30
 8010b5c:	e7b6      	b.n	8010acc <cblas_dtrsm+0x5c4>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8010b5e:	2b00      	cmp	r3, #0
 8010b60:	f43f ae1b 	beq.w	801079a <cblas_dtrsm+0x292>
 8010b64:	e614      	b.n	8010790 <cblas_dtrsm+0x288>
 8010b66:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8010b6a:	2b01      	cmp	r3, #1
 8010b6c:	f8dd c018 	ldr.w	ip, [sp, #24]
 8010b70:	bf94      	ite	ls
 8010b72:	2300      	movls	r3, #0
 8010b74:	2301      	movhi	r3, #1
 8010b76:	e4e6      	b.n	8010546 <cblas_dtrsm+0x3e>
    for (i = 0; i < n1; i++) {
 8010b78:	990d      	ldr	r1, [sp, #52]	; 0x34
 8010b7a:	9a02      	ldr	r2, [sp, #8]
 8010b7c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010b7e:	4608      	mov	r0, r1
 8010b80:	4410      	add	r0, r2
 8010b82:	4492      	add	sl, r2
 8010b84:	9a06      	ldr	r2, [sp, #24]
 8010b86:	900d      	str	r0, [sp, #52]	; 0x34
 8010b88:	3301      	adds	r3, #1
 8010b8a:	429a      	cmp	r2, r3
 8010b8c:	930e      	str	r3, [sp, #56]	; 0x38
 8010b8e:	f73f aefc 	bgt.w	801098a <cblas_dtrsm+0x482>
 8010b92:	b013      	add	sp, #76	; 0x4c
 8010b94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (i = 0; i < n1; i++) {
 8010b98:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8010b9a:	9a02      	ldr	r2, [sp, #8]
 8010b9c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010b9e:	4608      	mov	r0, r1
 8010ba0:	9908      	ldr	r1, [sp, #32]
 8010ba2:	4410      	add	r0, r2
 8010ba4:	4411      	add	r1, r2
 8010ba6:	9a06      	ldr	r2, [sp, #24]
 8010ba8:	900b      	str	r0, [sp, #44]	; 0x2c
 8010baa:	3301      	adds	r3, #1
 8010bac:	429a      	cmp	r2, r3
 8010bae:	930c      	str	r3, [sp, #48]	; 0x30
 8010bb0:	9108      	str	r1, [sp, #32]
 8010bb2:	f73f ae5c 	bgt.w	801086e <cblas_dtrsm+0x366>
 8010bb6:	e7ec      	b.n	8010b92 <cblas_dtrsm+0x68a>
        BASE Aii = A[lda * i + i];
 8010bb8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010bba:	e9d3 6700 	ldrd	r6, r7, [r3]
        for (j = 0; j < n2; j++) {
 8010bbe:	9b01      	ldr	r3, [sp, #4]
 8010bc0:	2b00      	cmp	r3, #0
 8010bc2:	dd86      	ble.n	8010ad2 <cblas_dtrsm+0x5ca>
 8010bc4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010bc6:	9c08      	ldr	r4, [sp, #32]
 8010bc8:	191d      	adds	r5, r3, r4
          B[ldb * i + j] /= Aii;
 8010bca:	e9d4 0100 	ldrd	r0, r1, [r4]
 8010bce:	4632      	mov	r2, r6
 8010bd0:	463b      	mov	r3, r7
 8010bd2:	f017 fa93 	bl	80280fc <__aeabi_ddiv>
 8010bd6:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010bda:	42a5      	cmp	r5, r4
 8010bdc:	d1f5      	bne.n	8010bca <cblas_dtrsm+0x6c2>
 8010bde:	e778      	b.n	8010ad2 <cblas_dtrsm+0x5ca>
        BASE Aii = A[lda * i + i];
 8010be0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8010be2:	9b07      	ldr	r3, [sp, #28]
 8010be4:	4413      	add	r3, r2
 8010be6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8010be8:	4413      	add	r3, r2
 8010bea:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 8010bee:	9b01      	ldr	r3, [sp, #4]
 8010bf0:	2b00      	cmp	r3, #0
 8010bf2:	f77f ad87 	ble.w	8010704 <cblas_dtrsm+0x1fc>
 8010bf6:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8010bf8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010bfa:	18e5      	adds	r5, r4, r3
          B[ldb * i + j] /= Aii;
 8010bfc:	e9d4 0100 	ldrd	r0, r1, [r4]
 8010c00:	4632      	mov	r2, r6
 8010c02:	463b      	mov	r3, r7
 8010c04:	f017 fa7a 	bl	80280fc <__aeabi_ddiv>
 8010c08:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010c0c:	42ac      	cmp	r4, r5
 8010c0e:	d1f5      	bne.n	8010bfc <cblas_dtrsm+0x6f4>
 8010c10:	e578      	b.n	8010704 <cblas_dtrsm+0x1fc>
 8010c12:	bf00      	nop
 8010c14:	3ff00000 	.word	0x3ff00000
    if (alpha != 1.0) {
 8010c18:	4ba2      	ldr	r3, [pc, #648]	; (8010ea4 <cblas_dtrsm+0x99c>)
 8010c1a:	2200      	movs	r2, #0
 8010c1c:	4620      	mov	r0, r4
 8010c1e:	4629      	mov	r1, r5
 8010c20:	f017 fbaa 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 8010c24:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8010c26:	2800      	cmp	r0, #0
 8010c28:	f040 829d 	bne.w	8011166 <cblas_dtrsm+0xc5e>
      for (i = 0; i < n1; i++) {
 8010c2c:	2b00      	cmp	r3, #0
 8010c2e:	ddb0      	ble.n	8010b92 <cblas_dtrsm+0x68a>
 8010c30:	9a03      	ldr	r2, [sp, #12]
 8010c32:	9b01      	ldr	r3, [sp, #4]
 8010c34:	f8dd b018 	ldr.w	fp, [sp, #24]
 8010c38:	00d2      	lsls	r2, r2, #3
 8010c3a:	9202      	str	r2, [sp, #8]
 8010c3c:	00da      	lsls	r2, r3, #3
 8010c3e:	920e      	str	r2, [sp, #56]	; 0x38
 8010c40:	9a05      	ldr	r2, [sp, #20]
 8010c42:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8010c46:	4680      	mov	r8, r0
 8010c48:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010c4c:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8010c50:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 8010c52:	f1ba 0f00 	cmp.w	sl, #0
 8010c56:	bfc8      	it	gt
 8010c58:	eb09 0607 	addgt.w	r6, r9, r7
 8010c5c:	dd09      	ble.n	8010c72 <cblas_dtrsm+0x76a>
          B[ldb * i + j] *= alpha;
 8010c5e:	e9d6 0100 	ldrd	r0, r1, [r6]
 8010c62:	4622      	mov	r2, r4
 8010c64:	462b      	mov	r3, r5
 8010c66:	f017 f91f 	bl	8027ea8 <__aeabi_dmul>
 8010c6a:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8010c6e:	42b7      	cmp	r7, r6
 8010c70:	d1f5      	bne.n	8010c5e <cblas_dtrsm+0x756>
      for (i = 0; i < n1; i++) {
 8010c72:	9b02      	ldr	r3, [sp, #8]
 8010c74:	f108 0801 	add.w	r8, r8, #1
 8010c78:	45c3      	cmp	fp, r8
 8010c7a:	441f      	add	r7, r3
 8010c7c:	d1e9      	bne.n	8010c52 <cblas_dtrsm+0x74a>
 8010c7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010c80:	9906      	ldr	r1, [sp, #24]
 8010c82:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8010c84:	1c53      	adds	r3, r2, #1
 8010c86:	ea6f 0a02 	mvn.w	sl, r2
 8010c8a:	3901      	subs	r1, #1
 8010c8c:	00db      	lsls	r3, r3, #3
 8010c8e:	ea4f 00ca 	mov.w	r0, sl, lsl #3
 8010c92:	900d      	str	r0, [sp, #52]	; 0x34
 8010c94:	fb01 4003 	mla	r0, r1, r3, r4
 8010c98:	3b08      	subs	r3, #8
 8010c9a:	930a      	str	r3, [sp, #40]	; 0x28
 8010c9c:	f104 0308 	add.w	r3, r4, #8
 8010ca0:	9a03      	ldr	r2, [sp, #12]
 8010ca2:	900b      	str	r0, [sp, #44]	; 0x2c
 8010ca4:	9310      	str	r3, [sp, #64]	; 0x40
 8010ca6:	9805      	ldr	r0, [sp, #20]
 8010ca8:	9b02      	ldr	r3, [sp, #8]
 8010caa:	9108      	str	r1, [sp, #32]
 8010cac:	fb01 0303 	mla	r3, r1, r3, r0
 8010cb0:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8010cb4:	9309      	str	r3, [sp, #36]	; 0x24
 8010cb6:	00d3      	lsls	r3, r2, #3
 8010cb8:	930f      	str	r3, [sp, #60]	; 0x3c
 8010cba:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010cbc:	18c3      	adds	r3, r0, r3
 8010cbe:	930c      	str	r3, [sp, #48]	; 0x30
      if (nonunit) {
 8010cc0:	9b04      	ldr	r3, [sp, #16]
 8010cc2:	2b83      	cmp	r3, #131	; 0x83
 8010cc4:	d042      	beq.n	8010d4c <cblas_dtrsm+0x844>
      for (k = 0; k < i; k++) {
 8010cc6:	9b08      	ldr	r3, [sp, #32]
 8010cc8:	2b00      	cmp	r3, #0
 8010cca:	f43f af62 	beq.w	8010b92 <cblas_dtrsm+0x68a>
 8010cce:	2300      	movs	r3, #0
 8010cd0:	e9cd 3306 	strd	r3, r3, [sp, #24]
 8010cd4:	9a08      	ldr	r2, [sp, #32]
 8010cd6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010cd8:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 8010cdc:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
        for (j = 0; j < n2; j++) {
 8010ce0:	9b01      	ldr	r3, [sp, #4]
 8010ce2:	2b00      	cmp	r3, #0
        const BASE Aki = A[k * lda + i];
 8010ce4:	e95b 8902 	ldrd	r8, r9, [fp, #-8]
        for (j = 0; j < n2; j++) {
 8010ce8:	dd16      	ble.n	8010d18 <cblas_dtrsm+0x810>
 8010cea:	e9dd 3205 	ldrd	r3, r2, [sp, #20]
 8010cee:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8010cf0:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 8010cf4:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8010cf8:	4642      	mov	r2, r8
 8010cfa:	464b      	mov	r3, r9
 8010cfc:	f017 f8d4 	bl	8027ea8 <__aeabi_dmul>
 8010d00:	e9d4 6700 	ldrd	r6, r7, [r4]
 8010d04:	4602      	mov	r2, r0
 8010d06:	460b      	mov	r3, r1
 8010d08:	4630      	mov	r0, r6
 8010d0a:	4639      	mov	r1, r7
 8010d0c:	f016 ff14 	bl	8027b38 <__aeabi_dsub>
 8010d10:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010d14:	4554      	cmp	r4, sl
 8010d16:	d1ed      	bne.n	8010cf4 <cblas_dtrsm+0x7ec>
      for (k = 0; k < i; k++) {
 8010d18:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010d1a:	9903      	ldr	r1, [sp, #12]
 8010d1c:	9b07      	ldr	r3, [sp, #28]
 8010d1e:	4493      	add	fp, r2
 8010d20:	9a06      	ldr	r2, [sp, #24]
 8010d22:	440a      	add	r2, r1
 8010d24:	9206      	str	r2, [sp, #24]
 8010d26:	9a02      	ldr	r2, [sp, #8]
 8010d28:	4492      	add	sl, r2
 8010d2a:	9a08      	ldr	r2, [sp, #32]
 8010d2c:	3301      	adds	r3, #1
 8010d2e:	429a      	cmp	r2, r3
 8010d30:	9307      	str	r3, [sp, #28]
 8010d32:	d1d5      	bne.n	8010ce0 <cblas_dtrsm+0x7d8>
 8010d34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010d36:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8010d38:	4413      	add	r3, r2
 8010d3a:	9309      	str	r3, [sp, #36]	; 0x24
 8010d3c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010d3e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010d40:	4413      	add	r3, r2
 8010d42:	930b      	str	r3, [sp, #44]	; 0x2c
 8010d44:	9b08      	ldr	r3, [sp, #32]
 8010d46:	3b01      	subs	r3, #1
 8010d48:	9308      	str	r3, [sp, #32]
 8010d4a:	e7b9      	b.n	8010cc0 <cblas_dtrsm+0x7b8>
        BASE Aii = A[lda * i + i];
 8010d4c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010d4e:	e9d3 6700 	ldrd	r6, r7, [r3]
        for (j = 0; j < n2; j++) {
 8010d52:	9b01      	ldr	r3, [sp, #4]
 8010d54:	2b00      	cmp	r3, #0
 8010d56:	ddb6      	ble.n	8010cc6 <cblas_dtrsm+0x7be>
 8010d58:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010d5a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8010d5c:	191d      	adds	r5, r3, r4
          B[ldb * i + j] /= Aii;
 8010d5e:	e9d4 0100 	ldrd	r0, r1, [r4]
 8010d62:	4632      	mov	r2, r6
 8010d64:	463b      	mov	r3, r7
 8010d66:	f017 f9c9 	bl	80280fc <__aeabi_ddiv>
 8010d6a:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010d6e:	42a5      	cmp	r5, r4
 8010d70:	d1f5      	bne.n	8010d5e <cblas_dtrsm+0x856>
 8010d72:	e7a8      	b.n	8010cc6 <cblas_dtrsm+0x7be>
    if (alpha != 1.0) {
 8010d74:	4b4b      	ldr	r3, [pc, #300]	; (8010ea4 <cblas_dtrsm+0x99c>)
 8010d76:	2200      	movs	r2, #0
 8010d78:	4620      	mov	r0, r4
 8010d7a:	4629      	mov	r1, r5
 8010d7c:	f017 fafc 	bl	8028378 <__aeabi_dcmpeq>
 8010d80:	2800      	cmp	r0, #0
 8010d82:	f040 81da 	bne.w	801113a <cblas_dtrsm+0xc32>
      for (i = 0; i < n1; i++) {
 8010d86:	9906      	ldr	r1, [sp, #24]
 8010d88:	2900      	cmp	r1, #0
 8010d8a:	f77f af02 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8010d8e:	9a03      	ldr	r2, [sp, #12]
 8010d90:	9b01      	ldr	r3, [sp, #4]
 8010d92:	00d2      	lsls	r2, r2, #3
 8010d94:	9202      	str	r2, [sp, #8]
 8010d96:	00da      	lsls	r2, r3, #3
 8010d98:	920e      	str	r2, [sp, #56]	; 0x38
 8010d9a:	9a05      	ldr	r2, [sp, #20]
 8010d9c:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8010da0:	4680      	mov	r8, r0
 8010da2:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010da6:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8010daa:	469a      	mov	sl, r3
 8010dac:	468b      	mov	fp, r1
        for (j = 0; j < n2; j++) {
 8010dae:	f1ba 0f00 	cmp.w	sl, #0
 8010db2:	bfc8      	it	gt
 8010db4:	eb09 0607 	addgt.w	r6, r9, r7
 8010db8:	dd09      	ble.n	8010dce <cblas_dtrsm+0x8c6>
          B[ldb * i + j] *= alpha;
 8010dba:	e9d6 0100 	ldrd	r0, r1, [r6]
 8010dbe:	4622      	mov	r2, r4
 8010dc0:	462b      	mov	r3, r5
 8010dc2:	f017 f871 	bl	8027ea8 <__aeabi_dmul>
 8010dc6:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8010dca:	42b7      	cmp	r7, r6
 8010dcc:	d1f5      	bne.n	8010dba <cblas_dtrsm+0x8b2>
      for (i = 0; i < n1; i++) {
 8010dce:	9b02      	ldr	r3, [sp, #8]
 8010dd0:	f108 0801 	add.w	r8, r8, #1
 8010dd4:	45c3      	cmp	fp, r8
 8010dd6:	441f      	add	r7, r3
 8010dd8:	d1e9      	bne.n	8010dae <cblas_dtrsm+0x8a6>
 8010dda:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010ddc:	9903      	ldr	r1, [sp, #12]
 8010dde:	980c      	ldr	r0, [sp, #48]	; 0x30
 8010de0:	900d      	str	r0, [sp, #52]	; 0x34
 8010de2:	f103 0a01 	add.w	sl, r3, #1
 8010de6:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8010dea:	f1a3 0208 	sub.w	r2, r3, #8
 8010dee:	9310      	str	r3, [sp, #64]	; 0x40
 8010df0:	9b01      	ldr	r3, [sp, #4]
 8010df2:	920a      	str	r2, [sp, #40]	; 0x28
 8010df4:	440b      	add	r3, r1
 8010df6:	00db      	lsls	r3, r3, #3
 8010df8:	2100      	movs	r1, #0
 8010dfa:	1882      	adds	r2, r0, r2
 8010dfc:	9311      	str	r3, [sp, #68]	; 0x44
 8010dfe:	9b05      	ldr	r3, [sp, #20]
 8010e00:	910f      	str	r1, [sp, #60]	; 0x3c
 8010e02:	920b      	str	r2, [sp, #44]	; 0x2c
 8010e04:	910c      	str	r1, [sp, #48]	; 0x30
 8010e06:	9309      	str	r3, [sp, #36]	; 0x24
      if (nonunit) {
 8010e08:	9b04      	ldr	r3, [sp, #16]
 8010e0a:	2b83      	cmp	r3, #131	; 0x83
 8010e0c:	d04c      	beq.n	8010ea8 <cblas_dtrsm+0x9a0>
      for (k = i + 1; k < n1; k++) {
 8010e0e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010e10:	9a06      	ldr	r2, [sp, #24]
 8010e12:	3301      	adds	r3, #1
 8010e14:	429a      	cmp	r2, r3
 8010e16:	930c      	str	r3, [sp, #48]	; 0x30
 8010e18:	f77f aebb 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8010e1c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8010e1e:	9903      	ldr	r1, [sp, #12]
 8010e20:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 8010e24:	9308      	str	r3, [sp, #32]
 8010e26:	440a      	add	r2, r1
 8010e28:	920f      	str	r2, [sp, #60]	; 0x3c
 8010e2a:	9911      	ldr	r1, [sp, #68]	; 0x44
 8010e2c:	9207      	str	r2, [sp, #28]
 8010e2e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010e30:	eb02 0a01 	add.w	sl, r2, r1
        for (j = 0; j < n2; j++) {
 8010e34:	9b01      	ldr	r3, [sp, #4]
 8010e36:	2b00      	cmp	r3, #0
        const BASE Aki = A[k * lda + i];
 8010e38:	e9db 8900 	ldrd	r8, r9, [fp]
        for (j = 0; j < n2; j++) {
 8010e3c:	dd16      	ble.n	8010e6c <cblas_dtrsm+0x964>
 8010e3e:	9b05      	ldr	r3, [sp, #20]
 8010e40:	9a07      	ldr	r2, [sp, #28]
 8010e42:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8010e44:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
          B[ldb * k + j] -= Aki * B[ldb * i + j];
 8010e48:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8010e4c:	4642      	mov	r2, r8
 8010e4e:	464b      	mov	r3, r9
 8010e50:	f017 f82a 	bl	8027ea8 <__aeabi_dmul>
 8010e54:	e9d4 6700 	ldrd	r6, r7, [r4]
 8010e58:	4602      	mov	r2, r0
 8010e5a:	460b      	mov	r3, r1
 8010e5c:	4630      	mov	r0, r6
 8010e5e:	4639      	mov	r1, r7
 8010e60:	f016 fe6a 	bl	8027b38 <__aeabi_dsub>
 8010e64:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010e68:	45a2      	cmp	sl, r4
 8010e6a:	d1ed      	bne.n	8010e48 <cblas_dtrsm+0x940>
      for (k = i + 1; k < n1; k++) {
 8010e6c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8010e6e:	9903      	ldr	r1, [sp, #12]
 8010e70:	9b08      	ldr	r3, [sp, #32]
 8010e72:	4493      	add	fp, r2
 8010e74:	9a07      	ldr	r2, [sp, #28]
 8010e76:	440a      	add	r2, r1
 8010e78:	9207      	str	r2, [sp, #28]
 8010e7a:	9a02      	ldr	r2, [sp, #8]
 8010e7c:	4492      	add	sl, r2
 8010e7e:	9a06      	ldr	r2, [sp, #24]
 8010e80:	3301      	adds	r3, #1
 8010e82:	429a      	cmp	r2, r3
 8010e84:	9308      	str	r3, [sp, #32]
 8010e86:	d1d5      	bne.n	8010e34 <cblas_dtrsm+0x92c>
 8010e88:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8010e8a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8010e8c:	4611      	mov	r1, r2
 8010e8e:	4419      	add	r1, r3
 8010e90:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010e92:	910b      	str	r1, [sp, #44]	; 0x2c
 8010e94:	9902      	ldr	r1, [sp, #8]
 8010e96:	440a      	add	r2, r1
 8010e98:	9209      	str	r2, [sp, #36]	; 0x24
 8010e9a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8010e9c:	441a      	add	r2, r3
 8010e9e:	920d      	str	r2, [sp, #52]	; 0x34
 8010ea0:	e7b2      	b.n	8010e08 <cblas_dtrsm+0x900>
 8010ea2:	bf00      	nop
 8010ea4:	3ff00000 	.word	0x3ff00000
        BASE Aii = A[lda * i + i];
 8010ea8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8010eaa:	e9d3 6700 	ldrd	r6, r7, [r3]
        for (j = 0; j < n2; j++) {
 8010eae:	9b01      	ldr	r3, [sp, #4]
 8010eb0:	2b00      	cmp	r3, #0
 8010eb2:	ddac      	ble.n	8010e0e <cblas_dtrsm+0x906>
 8010eb4:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8010eb6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8010eb8:	18e5      	adds	r5, r4, r3
          B[ldb * i + j] /= Aii;
 8010eba:	e9d4 0100 	ldrd	r0, r1, [r4]
 8010ebe:	4632      	mov	r2, r6
 8010ec0:	463b      	mov	r3, r7
 8010ec2:	f017 f91b 	bl	80280fc <__aeabi_ddiv>
 8010ec6:	e8e4 0102 	strd	r0, r1, [r4], #8
        for (j = 0; j < n2; j++) {
 8010eca:	42ac      	cmp	r4, r5
 8010ecc:	d1f5      	bne.n	8010eba <cblas_dtrsm+0x9b2>
 8010ece:	e79e      	b.n	8010e0e <cblas_dtrsm+0x906>
    if (alpha != 1.0) {
 8010ed0:	4baa      	ldr	r3, [pc, #680]	; (801117c <cblas_dtrsm+0xc74>)
 8010ed2:	2200      	movs	r2, #0
 8010ed4:	4620      	mov	r0, r4
 8010ed6:	4629      	mov	r1, r5
 8010ed8:	f017 fa4e 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 8010edc:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8010ede:	2800      	cmp	r0, #0
 8010ee0:	f040 8163 	bne.w	80111aa <cblas_dtrsm+0xca2>
      for (i = 0; i < n1; i++) {
 8010ee4:	2b00      	cmp	r3, #0
 8010ee6:	f77f ae54 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8010eea:	9a03      	ldr	r2, [sp, #12]
 8010eec:	9b01      	ldr	r3, [sp, #4]
 8010eee:	f8dd b018 	ldr.w	fp, [sp, #24]
 8010ef2:	00d2      	lsls	r2, r2, #3
 8010ef4:	9202      	str	r2, [sp, #8]
 8010ef6:	00da      	lsls	r2, r3, #3
 8010ef8:	920e      	str	r2, [sp, #56]	; 0x38
 8010efa:	9a05      	ldr	r2, [sp, #20]
 8010efc:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8010f00:	4680      	mov	r8, r0
 8010f02:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8010f06:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 8010f0a:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 8010f0c:	f1ba 0f00 	cmp.w	sl, #0
 8010f10:	bfc8      	it	gt
 8010f12:	eb07 0609 	addgt.w	r6, r7, r9
 8010f16:	dd09      	ble.n	8010f2c <cblas_dtrsm+0xa24>
          B[ldb * i + j] *= alpha;
 8010f18:	e9d6 0100 	ldrd	r0, r1, [r6]
 8010f1c:	4622      	mov	r2, r4
 8010f1e:	462b      	mov	r3, r5
 8010f20:	f016 ffc2 	bl	8027ea8 <__aeabi_dmul>
 8010f24:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8010f28:	42be      	cmp	r6, r7
 8010f2a:	d1f5      	bne.n	8010f18 <cblas_dtrsm+0xa10>
      for (i = 0; i < n1; i++) {
 8010f2c:	9b02      	ldr	r3, [sp, #8]
 8010f2e:	f108 0801 	add.w	r8, r8, #1
 8010f32:	45c3      	cmp	fp, r8
 8010f34:	441f      	add	r7, r3
 8010f36:	d1e9      	bne.n	8010f0c <cblas_dtrsm+0xa04>
 8010f38:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8010f3a:	9b05      	ldr	r3, [sp, #20]
 8010f3c:	930a      	str	r3, [sp, #40]	; 0x28
 8010f3e:	f102 0a01 	add.w	sl, r2, #1
 8010f42:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8010f44:	441a      	add	r2, r3
 8010f46:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8010f4a:	9309      	str	r3, [sp, #36]	; 0x24
          for (k = j + 1; k < n2; k++) {
 8010f4c:	2300      	movs	r3, #0
 8010f4e:	4693      	mov	fp, r2
 8010f50:	930b      	str	r3, [sp, #44]	; 0x2c
      for (j = 0; j < n2; j++) {
 8010f52:	9b01      	ldr	r3, [sp, #4]
 8010f54:	2b00      	cmp	r3, #0
 8010f56:	dd3e      	ble.n	8010fd6 <cblas_dtrsm+0xace>
 8010f58:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8010f5a:	9305      	str	r3, [sp, #20]
 8010f5c:	461a      	mov	r2, r3
 8010f5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8010f60:	e9cd 3307 	strd	r3, r3, [sp, #28]
 8010f64:	3208      	adds	r2, #8
 8010f66:	9203      	str	r2, [sp, #12]
 8010f68:	f04f 0a00 	mov.w	sl, #0
        if (nonunit) {
 8010f6c:	9b04      	ldr	r3, [sp, #16]
 8010f6e:	2b83      	cmp	r3, #131	; 0x83
 8010f70:	d109      	bne.n	8010f86 <cblas_dtrsm+0xa7e>
          B[ldb * i + j] /= Ajj;
 8010f72:	9c07      	ldr	r4, [sp, #28]
 8010f74:	9b05      	ldr	r3, [sp, #20]
 8010f76:	e9d4 0100 	ldrd	r0, r1, [r4]
 8010f7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8010f7e:	f017 f8bd 	bl	80280fc <__aeabi_ddiv>
 8010f82:	e9c4 0100 	strd	r0, r1, [r4]
          BASE Bij = B[ldb * i + j];
 8010f86:	9c08      	ldr	r4, [sp, #32]
          for (k = j + 1; k < n2; k++) {
 8010f88:	9b01      	ldr	r3, [sp, #4]
          BASE Bij = B[ldb * i + j];
 8010f8a:	e8f4 8902 	ldrd	r8, r9, [r4], #8
          for (k = j + 1; k < n2; k++) {
 8010f8e:	f10a 0a01 	add.w	sl, sl, #1
 8010f92:	4553      	cmp	r3, sl
          BASE Bij = B[ldb * i + j];
 8010f94:	9408      	str	r4, [sp, #32]
          for (k = j + 1; k < n2; k++) {
 8010f96:	d01e      	beq.n	8010fd6 <cblas_dtrsm+0xace>
 8010f98:	9d03      	ldr	r5, [sp, #12]
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 8010f9a:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 8010f9e:	4642      	mov	r2, r8
 8010fa0:	464b      	mov	r3, r9
 8010fa2:	f016 ff81 	bl	8027ea8 <__aeabi_dmul>
 8010fa6:	e9d4 6700 	ldrd	r6, r7, [r4]
 8010faa:	4602      	mov	r2, r0
 8010fac:	460b      	mov	r3, r1
 8010fae:	4630      	mov	r0, r6
 8010fb0:	4639      	mov	r1, r7
 8010fb2:	f016 fdc1 	bl	8027b38 <__aeabi_dsub>
 8010fb6:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = j + 1; k < n2; k++) {
 8010fba:	455c      	cmp	r4, fp
 8010fbc:	d1ed      	bne.n	8010f9a <cblas_dtrsm+0xa92>
 8010fbe:	9a03      	ldr	r2, [sp, #12]
 8010fc0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010fc2:	4611      	mov	r1, r2
 8010fc4:	9a05      	ldr	r2, [sp, #20]
 8010fc6:	4419      	add	r1, r3
 8010fc8:	441a      	add	r2, r3
 8010fca:	9b07      	ldr	r3, [sp, #28]
 8010fcc:	9103      	str	r1, [sp, #12]
 8010fce:	3308      	adds	r3, #8
 8010fd0:	9205      	str	r2, [sp, #20]
 8010fd2:	9307      	str	r3, [sp, #28]
 8010fd4:	e7ca      	b.n	8010f6c <cblas_dtrsm+0xa64>
    for (i = 0; i < n1; i++) {
 8010fd6:	990a      	ldr	r1, [sp, #40]	; 0x28
 8010fd8:	9a02      	ldr	r2, [sp, #8]
 8010fda:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8010fdc:	4608      	mov	r0, r1
 8010fde:	4410      	add	r0, r2
 8010fe0:	4493      	add	fp, r2
 8010fe2:	9a06      	ldr	r2, [sp, #24]
 8010fe4:	900a      	str	r0, [sp, #40]	; 0x28
 8010fe6:	3301      	adds	r3, #1
 8010fe8:	429a      	cmp	r2, r3
 8010fea:	930b      	str	r3, [sp, #44]	; 0x2c
 8010fec:	dcb1      	bgt.n	8010f52 <cblas_dtrsm+0xa4a>
 8010fee:	e5d0      	b.n	8010b92 <cblas_dtrsm+0x68a>
    if (alpha != 1.0) {
 8010ff0:	4b62      	ldr	r3, [pc, #392]	; (801117c <cblas_dtrsm+0xc74>)
 8010ff2:	2200      	movs	r2, #0
 8010ff4:	4620      	mov	r0, r4
 8010ff6:	4629      	mov	r1, r5
 8010ff8:	f017 f9be 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < n1; i++) {
 8010ffc:	9b06      	ldr	r3, [sp, #24]
    if (alpha != 1.0) {
 8010ffe:	2800      	cmp	r0, #0
 8011000:	f040 80c9 	bne.w	8011196 <cblas_dtrsm+0xc8e>
      for (i = 0; i < n1; i++) {
 8011004:	2b00      	cmp	r3, #0
 8011006:	f77f adc4 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 801100a:	9a03      	ldr	r2, [sp, #12]
 801100c:	9b01      	ldr	r3, [sp, #4]
 801100e:	f8dd b018 	ldr.w	fp, [sp, #24]
 8011012:	00d2      	lsls	r2, r2, #3
 8011014:	9202      	str	r2, [sp, #8]
 8011016:	00da      	lsls	r2, r3, #3
 8011018:	920e      	str	r2, [sp, #56]	; 0x38
 801101a:	9a05      	ldr	r2, [sp, #20]
 801101c:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8011020:	4680      	mov	r8, r0
 8011022:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8011026:	eb02 07c3 	add.w	r7, r2, r3, lsl #3
 801102a:	469a      	mov	sl, r3
        for (j = 0; j < n2; j++) {
 801102c:	f1ba 0f00 	cmp.w	sl, #0
 8011030:	bfc8      	it	gt
 8011032:	eb07 0609 	addgt.w	r6, r7, r9
 8011036:	dd09      	ble.n	801104c <cblas_dtrsm+0xb44>
          B[ldb * i + j] *= alpha;
 8011038:	e9d6 0100 	ldrd	r0, r1, [r6]
 801103c:	4622      	mov	r2, r4
 801103e:	462b      	mov	r3, r5
 8011040:	f016 ff32 	bl	8027ea8 <__aeabi_dmul>
 8011044:	e8e6 0102 	strd	r0, r1, [r6], #8
        for (j = 0; j < n2; j++) {
 8011048:	42be      	cmp	r6, r7
 801104a:	d1f5      	bne.n	8011038 <cblas_dtrsm+0xb30>
      for (i = 0; i < n1; i++) {
 801104c:	9b02      	ldr	r3, [sp, #8]
 801104e:	f108 0801 	add.w	r8, r8, #1
 8011052:	45c3      	cmp	fp, r8
 8011054:	441f      	add	r7, r3
 8011056:	d1e9      	bne.n	801102c <cblas_dtrsm+0xb24>
 8011058:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801105a:	9c05      	ldr	r4, [sp, #20]
 801105c:	9b01      	ldr	r3, [sp, #4]
 801105e:	9407      	str	r4, [sp, #28]
 8011060:	4610      	mov	r0, r2
 8011062:	ea6f 0a00 	mvn.w	sl, r0
 8011066:	980e      	ldr	r0, [sp, #56]	; 0x38
 8011068:	4420      	add	r0, r4
 801106a:	3b01      	subs	r3, #1
 801106c:	900a      	str	r0, [sp, #40]	; 0x28
 801106e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8011070:	fb02 f103 	mul.w	r1, r2, r3
 8011074:	fb02 3303 	mla	r3, r2, r3, r3
 8011078:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 801107c:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8011080:	930d      	str	r3, [sp, #52]	; 0x34
 8011082:	00d3      	lsls	r3, r2, #3
 8011084:	9309      	str	r3, [sp, #36]	; 0x24
 8011086:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 801108a:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 801108e:	9308      	str	r3, [sp, #32]
      for (j = n2; j > 0 && j--;) {
 8011090:	2300      	movs	r3, #0
 8011092:	910c      	str	r1, [sp, #48]	; 0x30
 8011094:	930b      	str	r3, [sp, #44]	; 0x2c
 8011096:	9b01      	ldr	r3, [sp, #4]
 8011098:	2b00      	cmp	r3, #0
 801109a:	dd35      	ble.n	8011108 <cblas_dtrsm+0xc00>
 801109c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801109e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80110a0:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 80110a4:	9305      	str	r3, [sp, #20]
 80110a6:	9203      	str	r2, [sp, #12]
 80110a8:	469a      	mov	sl, r3
        if (nonunit) {
 80110aa:	9b04      	ldr	r3, [sp, #16]
 80110ac:	2b83      	cmp	r3, #131	; 0x83
 80110ae:	d109      	bne.n	80110c4 <cblas_dtrsm+0xbbc>
          B[ldb * i + j] /= Ajj;
 80110b0:	9c05      	ldr	r4, [sp, #20]
 80110b2:	9b03      	ldr	r3, [sp, #12]
 80110b4:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 80110b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80110bc:	f017 f81e 	bl	80280fc <__aeabi_ddiv>
 80110c0:	e944 0102 	strd	r0, r1, [r4, #-8]
          BASE Bij = B[ldb * i + j];
 80110c4:	e97a 8902 	ldrd	r8, r9, [sl, #-8]!
          for (k = 0; k < j; k++) {
 80110c8:	9c07      	ldr	r4, [sp, #28]
 80110ca:	45a2      	cmp	sl, r4
 80110cc:	d01c      	beq.n	8011108 <cblas_dtrsm+0xc00>
 80110ce:	465d      	mov	r5, fp
            B[ldb * i + k] -= A[j * lda + k] * Bij;
 80110d0:	e8f5 0102 	ldrd	r0, r1, [r5], #8
 80110d4:	4642      	mov	r2, r8
 80110d6:	464b      	mov	r3, r9
 80110d8:	f016 fee6 	bl	8027ea8 <__aeabi_dmul>
 80110dc:	e9d4 6700 	ldrd	r6, r7, [r4]
 80110e0:	4602      	mov	r2, r0
 80110e2:	460b      	mov	r3, r1
 80110e4:	4630      	mov	r0, r6
 80110e6:	4639      	mov	r1, r7
 80110e8:	f016 fd26 	bl	8027b38 <__aeabi_dsub>
 80110ec:	e8e4 0102 	strd	r0, r1, [r4], #8
          for (k = 0; k < j; k++) {
 80110f0:	4554      	cmp	r4, sl
 80110f2:	d1ed      	bne.n	80110d0 <cblas_dtrsm+0xbc8>
 80110f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80110f6:	9a08      	ldr	r2, [sp, #32]
 80110f8:	449b      	add	fp, r3
 80110fa:	9b03      	ldr	r3, [sp, #12]
 80110fc:	4413      	add	r3, r2
 80110fe:	9303      	str	r3, [sp, #12]
 8011100:	9b05      	ldr	r3, [sp, #20]
 8011102:	3b08      	subs	r3, #8
 8011104:	9305      	str	r3, [sp, #20]
 8011106:	e7d0      	b.n	80110aa <cblas_dtrsm+0xba2>
    for (i = 0; i < n1; i++) {
 8011108:	9907      	ldr	r1, [sp, #28]
 801110a:	9a02      	ldr	r2, [sp, #8]
 801110c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801110e:	4608      	mov	r0, r1
 8011110:	990a      	ldr	r1, [sp, #40]	; 0x28
 8011112:	4410      	add	r0, r2
 8011114:	4411      	add	r1, r2
 8011116:	9a06      	ldr	r2, [sp, #24]
 8011118:	9007      	str	r0, [sp, #28]
 801111a:	3301      	adds	r3, #1
 801111c:	429a      	cmp	r2, r3
 801111e:	930b      	str	r3, [sp, #44]	; 0x2c
 8011120:	910a      	str	r1, [sp, #40]	; 0x28
 8011122:	dcb8      	bgt.n	8011096 <cblas_dtrsm+0xb8e>
 8011124:	e535      	b.n	8010b92 <cblas_dtrsm+0x68a>
    for (i = 0; i < n1; i++) {
 8011126:	2b00      	cmp	r3, #0
 8011128:	f77f ad33 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 801112c:	9b03      	ldr	r3, [sp, #12]
 801112e:	00db      	lsls	r3, r3, #3
 8011130:	9302      	str	r3, [sp, #8]
 8011132:	9b01      	ldr	r3, [sp, #4]
 8011134:	00db      	lsls	r3, r3, #3
 8011136:	930e      	str	r3, [sp, #56]	; 0x38
 8011138:	e413      	b.n	8010962 <cblas_dtrsm+0x45a>
    for (i = 0; i < n1; i++) {
 801113a:	9b06      	ldr	r3, [sp, #24]
 801113c:	2b00      	cmp	r3, #0
 801113e:	f77f ad28 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8011142:	9b03      	ldr	r3, [sp, #12]
 8011144:	00db      	lsls	r3, r3, #3
 8011146:	9302      	str	r3, [sp, #8]
 8011148:	9b01      	ldr	r3, [sp, #4]
 801114a:	00db      	lsls	r3, r3, #3
 801114c:	930e      	str	r3, [sp, #56]	; 0x38
 801114e:	e644      	b.n	8010dda <cblas_dtrsm+0x8d2>
    for (i = n1; i > 0 && i--;) {
 8011150:	2b00      	cmp	r3, #0
 8011152:	f77f ad1e 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8011156:	9b03      	ldr	r3, [sp, #12]
 8011158:	00db      	lsls	r3, r3, #3
 801115a:	9302      	str	r3, [sp, #8]
 801115c:	9b01      	ldr	r3, [sp, #4]
 801115e:	00db      	lsls	r3, r3, #3
 8011160:	930e      	str	r3, [sp, #56]	; 0x38
 8011162:	f7ff ba9a 	b.w	801069a <cblas_dtrsm+0x192>
    for (i = n1; i > 0 && i--;) {
 8011166:	2b00      	cmp	r3, #0
 8011168:	f77f ad13 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 801116c:	9b03      	ldr	r3, [sp, #12]
 801116e:	00db      	lsls	r3, r3, #3
 8011170:	9302      	str	r3, [sp, #8]
 8011172:	9b01      	ldr	r3, [sp, #4]
 8011174:	00db      	lsls	r3, r3, #3
 8011176:	930e      	str	r3, [sp, #56]	; 0x38
 8011178:	e581      	b.n	8010c7e <cblas_dtrsm+0x776>
 801117a:	bf00      	nop
 801117c:	3ff00000 	.word	0x3ff00000
    for (i = 0; i < n1; i++) {
 8011180:	9b06      	ldr	r3, [sp, #24]
 8011182:	2b00      	cmp	r3, #0
 8011184:	f77f ad05 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 8011188:	9b03      	ldr	r3, [sp, #12]
 801118a:	00db      	lsls	r3, r3, #3
 801118c:	9302      	str	r3, [sp, #8]
 801118e:	9b01      	ldr	r3, [sp, #4]
 8011190:	00db      	lsls	r3, r3, #3
 8011192:	930e      	str	r3, [sp, #56]	; 0x38
 8011194:	e483      	b.n	8010a9e <cblas_dtrsm+0x596>
    for (i = 0; i < n1; i++) {
 8011196:	2b00      	cmp	r3, #0
 8011198:	f77f acfb 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 801119c:	9b03      	ldr	r3, [sp, #12]
 801119e:	00db      	lsls	r3, r3, #3
 80111a0:	9302      	str	r3, [sp, #8]
 80111a2:	9b01      	ldr	r3, [sp, #4]
 80111a4:	00db      	lsls	r3, r3, #3
 80111a6:	930e      	str	r3, [sp, #56]	; 0x38
 80111a8:	e756      	b.n	8011058 <cblas_dtrsm+0xb50>
    for (i = 0; i < n1; i++) {
 80111aa:	2b00      	cmp	r3, #0
 80111ac:	f77f acf1 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 80111b0:	9b03      	ldr	r3, [sp, #12]
 80111b2:	00db      	lsls	r3, r3, #3
 80111b4:	9302      	str	r3, [sp, #8]
 80111b6:	9b01      	ldr	r3, [sp, #4]
 80111b8:	00db      	lsls	r3, r3, #3
 80111ba:	930e      	str	r3, [sp, #56]	; 0x38
 80111bc:	e6bc      	b.n	8010f38 <cblas_dtrsm+0xa30>
    for (i = 0; i < n1; i++) {
 80111be:	2b00      	cmp	r3, #0
 80111c0:	f77f ace7 	ble.w	8010b92 <cblas_dtrsm+0x68a>
 80111c4:	9b03      	ldr	r3, [sp, #12]
 80111c6:	00db      	lsls	r3, r3, #3
 80111c8:	9302      	str	r3, [sp, #8]
 80111ca:	9b01      	ldr	r3, [sp, #4]
 80111cc:	00db      	lsls	r3, r3, #3
 80111ce:	930e      	str	r3, [sp, #56]	; 0x38
 80111d0:	f7ff bb32 	b.w	8010838 <cblas_dtrsm+0x330>

080111d4 <cblas_dtrsv>:
void
cblas_dtrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const double *A, const int lda, double *X,
             const int incX)
{
 80111d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80111d8:	b08b      	sub	sp, #44	; 0x2c
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 80111da:	2a71      	cmp	r2, #113	; 0x71
 80111dc:	9300      	str	r3, [sp, #0]
 80111de:	e9dd b314 	ldrd	fp, r3, [sp, #80]	; 0x50
 80111e2:	9302      	str	r3, [sp, #8]
 80111e4:	e9dd a316 	ldrd	sl, r3, [sp, #88]	; 0x58
 80111e8:	9303      	str	r3, [sp, #12]
 80111ea:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80111ec:	9301      	str	r3, [sp, #4]
 80111ee:	4605      	mov	r5, r0
 80111f0:	460c      	mov	r4, r1
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80111f2:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
 80111f6:	f000 80e9 	beq.w	80113cc <cblas_dtrsv+0x1f8>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80111fa:	2b01      	cmp	r3, #1
 80111fc:	4616      	mov	r6, r2
 80111fe:	d939      	bls.n	8011274 <cblas_dtrsv+0xa0>
 8011200:	2002      	movs	r0, #2
 8011202:	3a6f      	subs	r2, #111	; 0x6f
 8011204:	2a02      	cmp	r2, #2
 8011206:	bf88      	it	hi
 8011208:	2003      	movhi	r0, #3
 801120a:	9b00      	ldr	r3, [sp, #0]
 801120c:	337d      	adds	r3, #125	; 0x7d
 801120e:	b2db      	uxtb	r3, r3
 8011210:	2b01      	cmp	r3, #1
 8011212:	f240 80c9 	bls.w	80113a8 <cblas_dtrsv+0x1d4>
 8011216:	f1bb 0f00 	cmp.w	fp, #0
 801121a:	f2c0 80bb 	blt.w	8011394 <cblas_dtrsv+0x1c0>
 801121e:	465b      	mov	r3, fp
 8011220:	2b01      	cmp	r3, #1
 8011222:	bfb8      	it	lt
 8011224:	2301      	movlt	r3, #1
 8011226:	459a      	cmp	sl, r3
 8011228:	f280 8176 	bge.w	8011518 <cblas_dtrsv+0x344>
 801122c:	9b01      	ldr	r3, [sp, #4]
 801122e:	2b00      	cmp	r3, #0
 8011230:	bf0c      	ite	eq
 8011232:	2009      	moveq	r0, #9
 8011234:	2007      	movne	r0, #7
 8011236:	4ab5      	ldr	r2, [pc, #724]	; (801150c <cblas_dtrsv+0x338>)
 8011238:	49b5      	ldr	r1, [pc, #724]	; (8011510 <cblas_dtrsv+0x33c>)
 801123a:	f016 fc05 	bl	8027a48 <cblas_xerbla>
  if (N == 0)
 801123e:	f1bb 0f00 	cmp.w	fp, #0
 8011242:	f000 80a4 	beq.w	801138e <cblas_dtrsv+0x1ba>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8011246:	2d65      	cmp	r5, #101	; 0x65
 8011248:	f000 80c6 	beq.w	80113d8 <cblas_dtrsv+0x204>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 801124c:	2d66      	cmp	r5, #102	; 0x66
 801124e:	d109      	bne.n	8011264 <cblas_dtrsv+0x90>
 8011250:	2e70      	cmp	r6, #112	; 0x70
 8011252:	d015      	beq.n	8011280 <cblas_dtrsv+0xac>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8011254:	2e6f      	cmp	r6, #111	; 0x6f
 8011256:	d105      	bne.n	8011264 <cblas_dtrsv+0x90>
 8011258:	2c7a      	cmp	r4, #122	; 0x7a
 801125a:	f000 81d9 	beq.w	8011610 <cblas_dtrsv+0x43c>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 801125e:	2c79      	cmp	r4, #121	; 0x79
 8011260:	f000 80c6 	beq.w	80113f0 <cblas_dtrsv+0x21c>
    BLAS_ERROR("unrecognized operation");
 8011264:	4aab      	ldr	r2, [pc, #684]	; (8011514 <cblas_dtrsv+0x340>)
 8011266:	49aa      	ldr	r1, [pc, #680]	; (8011510 <cblas_dtrsv+0x33c>)
 8011268:	2000      	movs	r0, #0
#define BASE double
#include "source_trsv_r.h"
#undef BASE
}
 801126a:	b00b      	add	sp, #44	; 0x2c
 801126c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011270:	f016 bbea 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011274:	3865      	subs	r0, #101	; 0x65
 8011276:	2801      	cmp	r0, #1
 8011278:	bf94      	ite	ls
 801127a:	2000      	movls	r0, #0
 801127c:	2001      	movhi	r0, #1
 801127e:	e7c0      	b.n	8011202 <cblas_dtrsv+0x2e>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8011280:	2c7a      	cmp	r4, #122	; 0x7a
 8011282:	f040 81ba 	bne.w	80115fa <cblas_dtrsv+0x426>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8011286:	9b01      	ldr	r3, [sp, #4]
 8011288:	2b00      	cmp	r3, #0
 801128a:	bfd8      	it	le
 801128c:	9b01      	ldrle	r3, [sp, #4]
 801128e:	f10b 35ff 	add.w	r5, fp, #4294967295
 8011292:	bfd8      	it	le
 8011294:	425e      	negle	r6, r3
 8011296:	9b01      	ldr	r3, [sp, #4]
 8011298:	bfcc      	ite	gt
 801129a:	2600      	movgt	r6, #0
 801129c:	436e      	mulle	r6, r5
 801129e:	fb05 6603 	mla	r6, r5, r3, r6
    if (nonunit) {
 80112a2:	9b00      	ldr	r3, [sp, #0]
 80112a4:	2b83      	cmp	r3, #131	; 0x83
 80112a6:	d10f      	bne.n	80112c8 <cblas_dtrsv+0xf4>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 80112a8:	9a02      	ldr	r2, [sp, #8]
 80112aa:	fb05 530a 	mla	r3, r5, sl, r5
 80112ae:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80112b2:	9a03      	ldr	r2, [sp, #12]
 80112b4:	eb02 04c6 	add.w	r4, r2, r6, lsl #3
 80112b8:	e9d4 0100 	ldrd	r0, r1, [r4]
 80112bc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80112c0:	f016 ff1c 	bl	80280fc <__aeabi_ddiv>
 80112c4:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N - 1; i > 0 && i--;) {
 80112c8:	2d00      	cmp	r5, #0
 80112ca:	dd60      	ble.n	801138e <cblas_dtrsv+0x1ba>
 80112cc:	1e6b      	subs	r3, r5, #1
 80112ce:	fb0a f803 	mul.w	r8, sl, r3
 80112d2:	fb0a 3303 	mla	r3, sl, r3, r3
 80112d6:	00db      	lsls	r3, r3, #3
 80112d8:	eb08 0205 	add.w	r2, r8, r5
 80112dc:	9306      	str	r3, [sp, #24]
 80112de:	9b02      	ldr	r3, [sp, #8]
 80112e0:	9c03      	ldr	r4, [sp, #12]
 80112e2:	9504      	str	r5, [sp, #16]
 80112e4:	44d8      	add	r8, fp
 80112e6:	ebc2 7042 	rsb	r0, r2, r2, lsl #29
 80112ea:	9d01      	ldr	r5, [sp, #4]
 80112ec:	f8cd b014 	str.w	fp, [sp, #20]
 80112f0:	ea6f 010a 	mvn.w	r1, sl
 80112f4:	461f      	mov	r7, r3
 80112f6:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 80112fa:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80112fe:	00c2      	lsls	r2, r0, #3
 8011300:	ebca 7a4a 	rsb	sl, sl, sl, lsl #29
 8011304:	9207      	str	r2, [sp, #28]
 8011306:	00ca      	lsls	r2, r1, #3
 8011308:	eb04 06c6 	add.w	r6, r4, r6, lsl #3
 801130c:	9201      	str	r2, [sp, #4]
 801130e:	ebc5 7445 	rsb	r4, r5, r5, lsl #29
 8011312:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 8011316:	9203      	str	r2, [sp, #12]
 8011318:	00e2      	lsls	r2, r4, #3
 801131a:	9202      	str	r2, [sp, #8]
 801131c:	ea4f 09c5 	mov.w	r9, r5, lsl #3
 8011320:	469b      	mov	fp, r3
      BASE tmp = X[ix];
 8011322:	9b02      	ldr	r3, [sp, #8]
 8011324:	eb06 0a03 	add.w	sl, r6, r3
      for (j = i + 1; j < N; j++) {
 8011328:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801132c:	4293      	cmp	r3, r2
      BASE tmp = X[ix];
 801132e:	e9da 4500 	ldrd	r4, r5, [sl]
      for (j = i + 1; j < N; j++) {
 8011332:	bfc8      	it	gt
 8011334:	465f      	movgt	r7, fp
 8011336:	dd10      	ble.n	801135a <cblas_dtrsv+0x186>
        tmp -= Aij * X[jx];
 8011338:	e9d6 2300 	ldrd	r2, r3, [r6]
 801133c:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 8011340:	f016 fdb2 	bl	8027ea8 <__aeabi_dmul>
 8011344:	4602      	mov	r2, r0
 8011346:	460b      	mov	r3, r1
 8011348:	4620      	mov	r0, r4
 801134a:	4629      	mov	r1, r5
 801134c:	f016 fbf4 	bl	8027b38 <__aeabi_dsub>
      for (j = i + 1; j < N; j++) {
 8011350:	45b8      	cmp	r8, r7
 8011352:	444e      	add	r6, r9
        tmp -= Aij * X[jx];
 8011354:	4604      	mov	r4, r0
 8011356:	460d      	mov	r5, r1
      for (j = i + 1; j < N; j++) {
 8011358:	d1ee      	bne.n	8011338 <cblas_dtrsv+0x164>
      if (nonunit) {
 801135a:	9b00      	ldr	r3, [sp, #0]
 801135c:	2b83      	cmp	r3, #131	; 0x83
 801135e:	d10b      	bne.n	8011378 <cblas_dtrsv+0x1a4>
        X[ix] = tmp / A[lda * i + i];
 8011360:	9b07      	ldr	r3, [sp, #28]
 8011362:	9a06      	ldr	r2, [sp, #24]
 8011364:	445b      	add	r3, fp
 8011366:	4413      	add	r3, r2
 8011368:	4620      	mov	r0, r4
 801136a:	4629      	mov	r1, r5
 801136c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011370:	f016 fec4 	bl	80280fc <__aeabi_ddiv>
 8011374:	4604      	mov	r4, r0
 8011376:	460d      	mov	r5, r1
 8011378:	9b01      	ldr	r3, [sp, #4]
 801137a:	449b      	add	fp, r3
 801137c:	9b03      	ldr	r3, [sp, #12]
 801137e:	4498      	add	r8, r3
    for (i = N - 1; i > 0 && i--;) {
 8011380:	9b04      	ldr	r3, [sp, #16]
 8011382:	3b01      	subs	r3, #1
 8011384:	e9ca 4500 	strd	r4, r5, [sl]
 8011388:	4656      	mov	r6, sl
 801138a:	9304      	str	r3, [sp, #16]
 801138c:	d1c9      	bne.n	8011322 <cblas_dtrsv+0x14e>
 801138e:	b00b      	add	sp, #44	; 0x2c
 8011390:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011394:	f1ba 0f00 	cmp.w	sl, #0
 8011398:	f77f af48 	ble.w	801122c <cblas_dtrsv+0x58>
 801139c:	9b01      	ldr	r3, [sp, #4]
 801139e:	2b00      	cmp	r3, #0
 80113a0:	bf0c      	ite	eq
 80113a2:	2009      	moveq	r0, #9
 80113a4:	2005      	movne	r0, #5
 80113a6:	e746      	b.n	8011236 <cblas_dtrsv+0x62>
 80113a8:	f1bb 0f00 	cmp.w	fp, #0
 80113ac:	dbf2      	blt.n	8011394 <cblas_dtrsv+0x1c0>
 80113ae:	465b      	mov	r3, fp
 80113b0:	2b01      	cmp	r3, #1
 80113b2:	bfb8      	it	lt
 80113b4:	2301      	movlt	r3, #1
 80113b6:	4553      	cmp	r3, sl
 80113b8:	f73f af38 	bgt.w	801122c <cblas_dtrsv+0x58>
 80113bc:	9b01      	ldr	r3, [sp, #4]
 80113be:	2b00      	cmp	r3, #0
 80113c0:	f000 818e 	beq.w	80116e0 <cblas_dtrsv+0x50c>
 80113c4:	2800      	cmp	r0, #0
 80113c6:	f43f af3a 	beq.w	801123e <cblas_dtrsv+0x6a>
 80113ca:	e734      	b.n	8011236 <cblas_dtrsv+0x62>
 80113cc:	2b01      	cmp	r3, #1
 80113ce:	f240 8118 	bls.w	8011602 <cblas_dtrsv+0x42e>
 80113d2:	2670      	movs	r6, #112	; 0x70
 80113d4:	2002      	movs	r0, #2
 80113d6:	e718      	b.n	801120a <cblas_dtrsv+0x36>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80113d8:	2e6f      	cmp	r6, #111	; 0x6f
 80113da:	f000 80a3 	beq.w	8011524 <cblas_dtrsv+0x350>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 80113de:	2e70      	cmp	r6, #112	; 0x70
 80113e0:	f47f af40 	bne.w	8011264 <cblas_dtrsv+0x90>
 80113e4:	2c79      	cmp	r4, #121	; 0x79
 80113e6:	f000 8113 	beq.w	8011610 <cblas_dtrsv+0x43c>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 80113ea:	2c7a      	cmp	r4, #122	; 0x7a
 80113ec:	f47f af3a 	bne.w	8011264 <cblas_dtrsv+0x90>
    ix = OFFSET(N, incX) + (N - 1) * incX;
 80113f0:	9b01      	ldr	r3, [sp, #4]
 80113f2:	2b00      	cmp	r3, #0
 80113f4:	bfd8      	it	le
 80113f6:	9a01      	ldrle	r2, [sp, #4]
 80113f8:	f10b 33ff 	add.w	r3, fp, #4294967295
 80113fc:	bfd8      	it	le
 80113fe:	4254      	negle	r4, r2
 8011400:	9305      	str	r3, [sp, #20]
 8011402:	bfd8      	it	le
 8011404:	435c      	mulle	r4, r3
 8011406:	9a05      	ldr	r2, [sp, #20]
 8011408:	9b01      	ldr	r3, [sp, #4]
 801140a:	bfc8      	it	gt
 801140c:	2400      	movgt	r4, #0
 801140e:	fb02 4403 	mla	r4, r2, r3, r4
    if (nonunit) {
 8011412:	9b00      	ldr	r3, [sp, #0]
 8011414:	2b83      	cmp	r3, #131	; 0x83
 8011416:	d10f      	bne.n	8011438 <cblas_dtrsv+0x264>
      X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
 8011418:	fb02 230a 	mla	r3, r2, sl, r2
 801141c:	9a02      	ldr	r2, [sp, #8]
 801141e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8011422:	9a03      	ldr	r2, [sp, #12]
 8011424:	eb02 05c4 	add.w	r5, r2, r4, lsl #3
 8011428:	e9d5 0100 	ldrd	r0, r1, [r5]
 801142c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011430:	f016 fe64 	bl	80280fc <__aeabi_ddiv>
 8011434:	e9c5 0100 	strd	r0, r1, [r5]
    for (i = N - 1; i > 0 && i--;) {
 8011438:	9805      	ldr	r0, [sp, #20]
    ix -= incX;
 801143a:	9d01      	ldr	r5, [sp, #4]
    for (i = N - 1; i > 0 && i--;) {
 801143c:	2800      	cmp	r0, #0
    ix -= incX;
 801143e:	eba4 0405 	sub.w	r4, r4, r5
    for (i = N - 1; i > 0 && i--;) {
 8011442:	dda4      	ble.n	801138e <cblas_dtrsv+0x1ba>
 8011444:	f10a 0301 	add.w	r3, sl, #1
 8011448:	4602      	mov	r2, r0
 801144a:	fb02 f203 	mul.w	r2, r2, r3
 801144e:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8011452:	9f03      	ldr	r7, [sp, #12]
 8011454:	00d2      	lsls	r2, r2, #3
 8011456:	9208      	str	r2, [sp, #32]
 8011458:	9a02      	ldr	r2, [sp, #8]
 801145a:	00db      	lsls	r3, r3, #3
 801145c:	ea6f 0a0a 	mvn.w	sl, sl
 8011460:	1e46      	subs	r6, r0, #1
 8011462:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
 8011466:	fb00 2203 	mla	r2, r0, r3, r2
 801146a:	ebc5 7145 	rsb	r1, r5, r5, lsl #29
 801146e:	9401      	str	r4, [sp, #4]
 8011470:	ea4f 04ca 	mov.w	r4, sl, lsl #3
 8011474:	f1a3 0a08 	sub.w	sl, r3, #8
 8011478:	fb03 f306 	mul.w	r3, r3, r6
 801147c:	9307      	str	r3, [sp, #28]
 801147e:	00cb      	lsls	r3, r1, #3
 8011480:	9604      	str	r6, [sp, #16]
 8011482:	9403      	str	r4, [sp, #12]
 8011484:	9202      	str	r2, [sp, #8]
 8011486:	9306      	str	r3, [sp, #24]
 8011488:	ea4f 09c5 	mov.w	r9, r5, lsl #3
 801148c:	9e05      	ldr	r6, [sp, #20]
      BASE tmp = X[ix];
 801148e:	9b01      	ldr	r3, [sp, #4]
      for (j = i + 1; j < N; j++) {
 8011490:	45b3      	cmp	fp, r6
      BASE tmp = X[ix];
 8011492:	e9d3 4500 	ldrd	r4, r5, [r3]
    for (i = N - 1; i > 0 && i--;) {
 8011496:	9b04      	ldr	r3, [sp, #16]
 8011498:	9305      	str	r3, [sp, #20]
      for (j = i + 1; j < N; j++) {
 801149a:	dd16      	ble.n	80114ca <cblas_dtrsv+0x2f6>
 801149c:	9b01      	ldr	r3, [sp, #4]
 801149e:	9f02      	ldr	r7, [sp, #8]
 80114a0:	eb09 0803 	add.w	r8, r9, r3
        tmp -= Aji * X[jx];
 80114a4:	e957 2302 	ldrd	r2, r3, [r7, #-8]
 80114a8:	e9d8 0100 	ldrd	r0, r1, [r8]
 80114ac:	f016 fcfc 	bl	8027ea8 <__aeabi_dmul>
 80114b0:	4602      	mov	r2, r0
 80114b2:	460b      	mov	r3, r1
 80114b4:	4620      	mov	r0, r4
 80114b6:	4629      	mov	r1, r5
 80114b8:	f016 fb3e 	bl	8027b38 <__aeabi_dsub>
      for (j = i + 1; j < N; j++) {
 80114bc:	3601      	adds	r6, #1
 80114be:	45b3      	cmp	fp, r6
 80114c0:	4457      	add	r7, sl
        tmp -= Aji * X[jx];
 80114c2:	4604      	mov	r4, r0
 80114c4:	460d      	mov	r5, r1
      for (j = i + 1; j < N; j++) {
 80114c6:	44c8      	add	r8, r9
 80114c8:	d1ec      	bne.n	80114a4 <cblas_dtrsv+0x2d0>
      if (nonunit) {
 80114ca:	9b00      	ldr	r3, [sp, #0]
 80114cc:	2b83      	cmp	r3, #131	; 0x83
 80114ce:	d10c      	bne.n	80114ea <cblas_dtrsv+0x316>
        X[ix] = tmp / A[lda * i + i];
 80114d0:	9a08      	ldr	r2, [sp, #32]
 80114d2:	9b02      	ldr	r3, [sp, #8]
 80114d4:	4413      	add	r3, r2
 80114d6:	9a07      	ldr	r2, [sp, #28]
 80114d8:	4413      	add	r3, r2
 80114da:	4620      	mov	r0, r4
 80114dc:	4629      	mov	r1, r5
 80114de:	e9d3 2300 	ldrd	r2, r3, [r3]
 80114e2:	f016 fe0b 	bl	80280fc <__aeabi_ddiv>
 80114e6:	4604      	mov	r4, r0
 80114e8:	460d      	mov	r5, r1
 80114ea:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 80114ee:	440a      	add	r2, r1
 80114f0:	9b01      	ldr	r3, [sp, #4]
 80114f2:	9202      	str	r2, [sp, #8]
 80114f4:	9a06      	ldr	r2, [sp, #24]
 80114f6:	e9c3 4500 	strd	r4, r5, [r3]
    for (i = N - 1; i > 0 && i--;) {
 80114fa:	4413      	add	r3, r2
 80114fc:	9301      	str	r3, [sp, #4]
 80114fe:	9b04      	ldr	r3, [sp, #16]
 8011500:	2b00      	cmp	r3, #0
 8011502:	f43f af44 	beq.w	801138e <cblas_dtrsv+0x1ba>
 8011506:	3b01      	subs	r3, #1
 8011508:	9304      	str	r3, [sp, #16]
 801150a:	e7bf      	b.n	801148c <cblas_dtrsv+0x2b8>
 801150c:	08030378 	.word	0x08030378
 8011510:	080306a0 	.word	0x080306a0
 8011514:	080305a8 	.word	0x080305a8
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011518:	9b01      	ldr	r3, [sp, #4]
 801151a:	2b00      	cmp	r3, #0
 801151c:	bf0c      	ite	eq
 801151e:	2009      	moveq	r0, #9
 8011520:	2004      	movne	r0, #4
 8011522:	e688      	b.n	8011236 <cblas_dtrsv+0x62>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8011524:	2c79      	cmp	r4, #121	; 0x79
 8011526:	f43f aeae 	beq.w	8011286 <cblas_dtrsv+0xb2>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 801152a:	2c7a      	cmp	r4, #122	; 0x7a
 801152c:	f47f ae9a 	bne.w	8011264 <cblas_dtrsv+0x90>
    ix = OFFSET(N, incX);
 8011530:	9b01      	ldr	r3, [sp, #4]
 8011532:	2b00      	cmp	r3, #0
 8011534:	f340 80d6 	ble.w	80116e4 <cblas_dtrsv+0x510>
 8011538:	9b01      	ldr	r3, [sp, #4]
 801153a:	2400      	movs	r4, #0
 801153c:	461e      	mov	r6, r3
    if (nonunit) {
 801153e:	9b00      	ldr	r3, [sp, #0]
 8011540:	2b83      	cmp	r3, #131	; 0x83
 8011542:	d10b      	bne.n	801155c <cblas_dtrsv+0x388>
      X[ix] = X[ix] / A[lda * 0 + 0];
 8011544:	9b03      	ldr	r3, [sp, #12]
 8011546:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
 801154a:	9b02      	ldr	r3, [sp, #8]
 801154c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011550:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011554:	f016 fdd2 	bl	80280fc <__aeabi_ddiv>
 8011558:	e9c5 0100 	strd	r0, r1, [r5]
    for (i = 1; i < N; i++) {
 801155c:	f1bb 0f01 	cmp.w	fp, #1
 8011560:	f77f af15 	ble.w	801138e <cblas_dtrsv+0x1ba>
 8011564:	9b03      	ldr	r3, [sp, #12]
 8011566:	f8cd a010 	str.w	sl, [sp, #16]
 801156a:	f10a 0801 	add.w	r8, sl, #1
 801156e:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 8011572:	9306      	str	r3, [sp, #24]
 8011574:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 8011578:	9307      	str	r3, [sp, #28]
 801157a:	9b02      	ldr	r3, [sp, #8]
 801157c:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 8011580:	9b01      	ldr	r3, [sp, #4]
 8011582:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8011586:	2301      	movs	r3, #1
 8011588:	e9cd ba08 	strd	fp, sl, [sp, #32]
 801158c:	9305      	str	r3, [sp, #20]
 801158e:	46b2      	mov	sl, r6
      BASE tmp = X[ix];
 8011590:	9b03      	ldr	r3, [sp, #12]
 8011592:	9a04      	ldr	r2, [sp, #16]
 8011594:	9e06      	ldr	r6, [sp, #24]
 8011596:	eb03 0bca 	add.w	fp, r3, sl, lsl #3
 801159a:	e9db 4500 	ldrd	r4, r5, [fp]
      for (j = 0; j < i; j++) {
 801159e:	9b02      	ldr	r3, [sp, #8]
 80115a0:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
        tmp -= Aij * X[jx];
 80115a4:	e9d6 2300 	ldrd	r2, r3, [r6]
 80115a8:	e8f7 0102 	ldrd	r0, r1, [r7], #8
 80115ac:	f016 fc7c 	bl	8027ea8 <__aeabi_dmul>
 80115b0:	4602      	mov	r2, r0
 80115b2:	460b      	mov	r3, r1
 80115b4:	4620      	mov	r0, r4
 80115b6:	4629      	mov	r1, r5
 80115b8:	f016 fabe 	bl	8027b38 <__aeabi_dsub>
      for (j = 0; j < i; j++) {
 80115bc:	4547      	cmp	r7, r8
        tmp -= Aij * X[jx];
 80115be:	4604      	mov	r4, r0
 80115c0:	460d      	mov	r5, r1
 80115c2:	444e      	add	r6, r9
      for (j = 0; j < i; j++) {
 80115c4:	d1ee      	bne.n	80115a4 <cblas_dtrsv+0x3d0>
      if (nonunit) {
 80115c6:	9b00      	ldr	r3, [sp, #0]
 80115c8:	2b83      	cmp	r3, #131	; 0x83
 80115ca:	d105      	bne.n	80115d8 <cblas_dtrsv+0x404>
        X[ix] = tmp / A[lda * i + i];
 80115cc:	e9d8 2300 	ldrd	r2, r3, [r8]
 80115d0:	f016 fd94 	bl	80280fc <__aeabi_ddiv>
 80115d4:	4604      	mov	r4, r0
 80115d6:	460d      	mov	r5, r1
      ix += incX;
 80115d8:	9a01      	ldr	r2, [sp, #4]
 80115da:	9909      	ldr	r1, [sp, #36]	; 0x24
    for (i = 1; i < N; i++) {
 80115dc:	9b05      	ldr	r3, [sp, #20]
      ix += incX;
 80115de:	4492      	add	sl, r2
 80115e0:	9a07      	ldr	r2, [sp, #28]
 80115e2:	4490      	add	r8, r2
 80115e4:	9a04      	ldr	r2, [sp, #16]
 80115e6:	440a      	add	r2, r1
 80115e8:	9204      	str	r2, [sp, #16]
    for (i = 1; i < N; i++) {
 80115ea:	9a08      	ldr	r2, [sp, #32]
 80115ec:	3301      	adds	r3, #1
 80115ee:	429a      	cmp	r2, r3
 80115f0:	e9cb 4500 	strd	r4, r5, [fp]
 80115f4:	9305      	str	r3, [sp, #20]
 80115f6:	d1cb      	bne.n	8011590 <cblas_dtrsv+0x3bc>
 80115f8:	e6c9      	b.n	801138e <cblas_dtrsv+0x1ba>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 80115fa:	2c79      	cmp	r4, #121	; 0x79
 80115fc:	f47f ae32 	bne.w	8011264 <cblas_dtrsv+0x90>
 8011600:	e796      	b.n	8011530 <cblas_dtrsv+0x35c>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8011602:	3865      	subs	r0, #101	; 0x65
 8011604:	2801      	cmp	r0, #1
 8011606:	bf94      	ite	ls
 8011608:	2000      	movls	r0, #0
 801160a:	2001      	movhi	r0, #1
 801160c:	2670      	movs	r6, #112	; 0x70
 801160e:	e5fc      	b.n	801120a <cblas_dtrsv+0x36>
    ix = OFFSET(N, incX);
 8011610:	9b01      	ldr	r3, [sp, #4]
 8011612:	2b00      	cmp	r3, #0
 8011614:	dd6d      	ble.n	80116f2 <cblas_dtrsv+0x51e>
 8011616:	9b01      	ldr	r3, [sp, #4]
 8011618:	9304      	str	r3, [sp, #16]
 801161a:	2400      	movs	r4, #0
    if (nonunit) {
 801161c:	9b00      	ldr	r3, [sp, #0]
 801161e:	2b83      	cmp	r3, #131	; 0x83
 8011620:	d10b      	bne.n	801163a <cblas_dtrsv+0x466>
      X[ix] = X[ix] / A[lda * 0 + 0];
 8011622:	9b03      	ldr	r3, [sp, #12]
 8011624:	eb03 05c4 	add.w	r5, r3, r4, lsl #3
 8011628:	9b02      	ldr	r3, [sp, #8]
 801162a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801162e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8011632:	f016 fd63 	bl	80280fc <__aeabi_ddiv>
 8011636:	e9c5 0100 	strd	r0, r1, [r5]
    for (i = 1; i < N; i++) {
 801163a:	f1bb 0f01 	cmp.w	fp, #1
 801163e:	f77f aea6 	ble.w	801138e <cblas_dtrsv+0x1ba>
 8011642:	f10a 0a01 	add.w	sl, sl, #1
 8011646:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 801164a:	f1a3 0a08 	sub.w	sl, r3, #8
 801164e:	9308      	str	r3, [sp, #32]
 8011650:	9b03      	ldr	r3, [sp, #12]
 8011652:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 8011656:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 801165a:	9307      	str	r3, [sp, #28]
 801165c:	9b02      	ldr	r3, [sp, #8]
 801165e:	4453      	add	r3, sl
 8011660:	9305      	str	r3, [sp, #20]
 8011662:	9b01      	ldr	r3, [sp, #4]
 8011664:	00db      	lsls	r3, r3, #3
 8011666:	f04f 0901 	mov.w	r9, #1
 801166a:	469b      	mov	fp, r3
      BASE tmp = X[ix];
 801166c:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8011670:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8011674:	e9d3 4500 	ldrd	r4, r5, [r3]
      for (j = 0; j < i; j++) {
 8011678:	9306      	str	r3, [sp, #24]
 801167a:	9b02      	ldr	r3, [sp, #8]
      BASE tmp = X[ix];
 801167c:	9f07      	ldr	r7, [sp, #28]
 801167e:	eb03 08c9 	add.w	r8, r3, r9, lsl #3
 8011682:	2600      	movs	r6, #0
        tmp -= Aji * X[jx];
 8011684:	e9d8 2300 	ldrd	r2, r3, [r8]
 8011688:	e9d7 0100 	ldrd	r0, r1, [r7]
 801168c:	f016 fc0c 	bl	8027ea8 <__aeabi_dmul>
 8011690:	4602      	mov	r2, r0
 8011692:	460b      	mov	r3, r1
 8011694:	4620      	mov	r0, r4
 8011696:	4629      	mov	r1, r5
 8011698:	f016 fa4e 	bl	8027b38 <__aeabi_dsub>
      for (j = 0; j < i; j++) {
 801169c:	3601      	adds	r6, #1
 801169e:	454e      	cmp	r6, r9
        tmp -= Aji * X[jx];
 80116a0:	4604      	mov	r4, r0
 80116a2:	460d      	mov	r5, r1
 80116a4:	44d0      	add	r8, sl
 80116a6:	445f      	add	r7, fp
      for (j = 0; j < i; j++) {
 80116a8:	d1ec      	bne.n	8011684 <cblas_dtrsv+0x4b0>
      if (nonunit) {
 80116aa:	9b00      	ldr	r3, [sp, #0]
 80116ac:	2b83      	cmp	r3, #131	; 0x83
 80116ae:	d106      	bne.n	80116be <cblas_dtrsv+0x4ea>
        X[ix] = tmp / A[lda * i + i];
 80116b0:	9b05      	ldr	r3, [sp, #20]
 80116b2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80116b6:	f016 fd21 	bl	80280fc <__aeabi_ddiv>
 80116ba:	4604      	mov	r4, r0
 80116bc:	460d      	mov	r5, r1
 80116be:	9b06      	ldr	r3, [sp, #24]
      ix += incX;
 80116c0:	9a01      	ldr	r2, [sp, #4]
 80116c2:	e9c3 4500 	strd	r4, r5, [r3]
 80116c6:	9b04      	ldr	r3, [sp, #16]
 80116c8:	4413      	add	r3, r2
 80116ca:	9304      	str	r3, [sp, #16]
    for (i = 1; i < N; i++) {
 80116cc:	9a08      	ldr	r2, [sp, #32]
 80116ce:	9b05      	ldr	r3, [sp, #20]
 80116d0:	4413      	add	r3, r2
 80116d2:	9305      	str	r3, [sp, #20]
 80116d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80116d6:	f109 0901 	add.w	r9, r9, #1
 80116da:	454b      	cmp	r3, r9
 80116dc:	d1c6      	bne.n	801166c <cblas_dtrsv+0x498>
 80116de:	e656      	b.n	801138e <cblas_dtrsv+0x1ba>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80116e0:	2009      	movs	r0, #9
 80116e2:	e5a8      	b.n	8011236 <cblas_dtrsv+0x62>
    ix = OFFSET(N, incX);
 80116e4:	f1cb 0401 	rsb	r4, fp, #1
 80116e8:	fb04 f403 	mul.w	r4, r4, r3
 80116ec:	4423      	add	r3, r4
 80116ee:	461e      	mov	r6, r3
 80116f0:	e725      	b.n	801153e <cblas_dtrsv+0x36a>
    ix = OFFSET(N, incX);
 80116f2:	f1cb 0401 	rsb	r4, fp, #1
 80116f6:	fb04 f403 	mul.w	r4, r4, r3
 80116fa:	4423      	add	r3, r4
 80116fc:	9304      	str	r3, [sp, #16]
 80116fe:	e78d      	b.n	801161c <cblas_dtrsv+0x448>

08011700 <cblas_dzasum>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dzasum (const int N, const void *X, const int incX)
{
 8011700:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011704:	b083      	sub	sp, #12
  if (incX <= 0) {
 8011706:	2a00      	cmp	r2, #0
 8011708:	9000      	str	r0, [sp, #0]
 801170a:	dd2e      	ble.n	801176a <cblas_dzasum+0x6a>
  for (i = 0; i < N; i++) {
 801170c:	2800      	cmp	r0, #0
  BASE r = 0.0;
 801170e:	f04f 0400 	mov.w	r4, #0
 8011712:	f04f 0500 	mov.w	r5, #0
  for (i = 0; i < N; i++) {
 8011716:	dd23      	ble.n	8011760 <cblas_dzasum+0x60>
 8011718:	0113      	lsls	r3, r2, #4
 801171a:	9301      	str	r3, [sp, #4]
 801171c:	468a      	mov	sl, r1
 801171e:	f04f 0b00 	mov.w	fp, #0
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 8011722:	e9da 2801 	ldrd	r2, r8, [sl, #4]
 8011726:	f8da 300c 	ldr.w	r3, [sl, #12]
 801172a:	f8da 6000 	ldr.w	r6, [sl]
 801172e:	f022 4700 	bic.w	r7, r2, #2147483648	; 0x80000000
 8011732:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
 8011736:	4642      	mov	r2, r8
 8011738:	464b      	mov	r3, r9
 801173a:	4630      	mov	r0, r6
 801173c:	4639      	mov	r1, r7
 801173e:	f016 f9fd 	bl	8027b3c <__adddf3>
 8011742:	460b      	mov	r3, r1
 8011744:	4602      	mov	r2, r0
 8011746:	4629      	mov	r1, r5
 8011748:	4620      	mov	r0, r4
 801174a:	f016 f9f7 	bl	8027b3c <__adddf3>
 801174e:	9b01      	ldr	r3, [sp, #4]
 8011750:	449a      	add	sl, r3
  for (i = 0; i < N; i++) {
 8011752:	9b00      	ldr	r3, [sp, #0]
 8011754:	f10b 0b01 	add.w	fp, fp, #1
 8011758:	455b      	cmp	r3, fp
    r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 801175a:	4604      	mov	r4, r0
 801175c:	460d      	mov	r5, r1
  for (i = 0; i < N; i++) {
 801175e:	d1e0      	bne.n	8011722 <cblas_dzasum+0x22>
#define BASE double
#include "source_asum_c.h"
#undef BASE
}
 8011760:	ec45 4b10 	vmov	d0, r4, r5
 8011764:	b003      	add	sp, #12
 8011766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 801176a:	2400      	movs	r4, #0
 801176c:	2500      	movs	r5, #0
 801176e:	ec45 4b10 	vmov	d0, r4, r5
 8011772:	b003      	add	sp, #12
 8011774:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08011778 <cblas_dznrm2>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

double
cblas_dznrm2 (const int N, const void *X, const int incX)
{
 8011778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801177c:	b089      	sub	sp, #36	; 0x24
  if (N == 0 || incX < 1) {
 801177e:	9006      	str	r0, [sp, #24]
 8011780:	2800      	cmp	r0, #0
 8011782:	f000 808c 	beq.w	801189e <cblas_dznrm2+0x126>
 8011786:	2a00      	cmp	r2, #0
 8011788:	f340 8089 	ble.w	801189e <cblas_dznrm2+0x126>
  BASE ssq = 1.0;
 801178c:	ed9f 7b58 	vldr	d7, [pc, #352]	; 80118f0 <cblas_dznrm2+0x178>
  for (i = 0; i < N; i++) {
 8011790:	2800      	cmp	r0, #0
  BASE ssq = 1.0;
 8011792:	ed8d 7b04 	vstr	d7, [sp, #16]
  BASE scale = 0.0;
 8011796:	f04f 0a00 	mov.w	sl, #0
 801179a:	f04f 0b00 	mov.w	fp, #0
  for (i = 0; i < N; i++) {
 801179e:	f340 8096 	ble.w	80118ce <cblas_dznrm2+0x156>
 80117a2:	0113      	lsls	r3, r2, #4
 80117a4:	9307      	str	r3, [sp, #28]
 80117a6:	460c      	mov	r4, r1
 80117a8:	2500      	movs	r5, #0
 80117aa:	e019      	b.n	80117e0 <cblas_dznrm2+0x68>
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 80117ac:	f016 fca6 	bl	80280fc <__aeabi_ddiv>
 80117b0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80117b4:	4606      	mov	r6, r0
 80117b6:	460f      	mov	r7, r1
 80117b8:	f016 fb76 	bl	8027ea8 <__aeabi_dmul>
 80117bc:	4632      	mov	r2, r6
 80117be:	463b      	mov	r3, r7
 80117c0:	f016 fb72 	bl	8027ea8 <__aeabi_dmul>
 80117c4:	4b4e      	ldr	r3, [pc, #312]	; (8011900 <cblas_dznrm2+0x188>)
 80117c6:	2200      	movs	r2, #0
 80117c8:	f016 f9b8 	bl	8027b3c <__adddf3>
        scale = ay;
 80117cc:	e9dd ab02 	ldrd	sl, fp, [sp, #8]
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 80117d0:	e9cd 0104 	strd	r0, r1, [sp, #16]
  for (i = 0; i < N; i++) {
 80117d4:	9b07      	ldr	r3, [sp, #28]
 80117d6:	441c      	add	r4, r3
 80117d8:	9b06      	ldr	r3, [sp, #24]
 80117da:	3501      	adds	r5, #1
 80117dc:	42ab      	cmp	r3, r5
 80117de:	d076      	beq.n	80118ce <cblas_dznrm2+0x156>
    const BASE x = CONST_REAL(X, ix);
 80117e0:	e9d4 6700 	ldrd	r6, r7, [r4]
    if (x != 0.0) {
 80117e4:	2200      	movs	r2, #0
 80117e6:	2300      	movs	r3, #0
 80117e8:	4630      	mov	r0, r6
 80117ea:	4639      	mov	r1, r7
 80117ec:	f016 fdc4 	bl	8028378 <__aeabi_dcmpeq>
    const BASE y = CONST_IMAG(X, ix);
 80117f0:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
      if (scale < ax) {
 80117f4:	4652      	mov	r2, sl
 80117f6:	465b      	mov	r3, fp
    if (x != 0.0) {
 80117f8:	bb18      	cbnz	r0, 8011842 <cblas_dznrm2+0xca>
      const BASE ax = fabs(x);
 80117fa:	f027 4100 	bic.w	r1, r7, #2147483648	; 0x80000000
 80117fe:	9600      	str	r6, [sp, #0]
 8011800:	9101      	str	r1, [sp, #4]
      if (scale < ax) {
 8011802:	e9dd 0100 	ldrd	r0, r1, [sp]
 8011806:	f016 fddf 	bl	80283c8 <__aeabi_dcmpgt>
 801180a:	4684      	mov	ip, r0
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 801180c:	e9dd 2300 	ldrd	r2, r3, [sp]
 8011810:	4650      	mov	r0, sl
 8011812:	4659      	mov	r1, fp
      if (scale < ax) {
 8011814:	f1bc 0f00 	cmp.w	ip, #0
 8011818:	d046      	beq.n	80118a8 <cblas_dznrm2+0x130>
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 801181a:	f016 fc6f 	bl	80280fc <__aeabi_ddiv>
 801181e:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8011822:	4606      	mov	r6, r0
 8011824:	460f      	mov	r7, r1
 8011826:	f016 fb3f 	bl	8027ea8 <__aeabi_dmul>
 801182a:	4632      	mov	r2, r6
 801182c:	463b      	mov	r3, r7
 801182e:	f016 fb3b 	bl	8027ea8 <__aeabi_dmul>
 8011832:	4b33      	ldr	r3, [pc, #204]	; (8011900 <cblas_dznrm2+0x188>)
 8011834:	2200      	movs	r2, #0
 8011836:	f016 f981 	bl	8027b3c <__adddf3>
        scale = ax;
 801183a:	e9dd ab00 	ldrd	sl, fp, [sp]
        ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
 801183e:	e9cd 0104 	strd	r0, r1, [sp, #16]
    if (y != 0.0) {
 8011842:	2300      	movs	r3, #0
 8011844:	4649      	mov	r1, r9
 8011846:	2200      	movs	r2, #0
 8011848:	4640      	mov	r0, r8
 801184a:	f016 fd95 	bl	8028378 <__aeabi_dcmpeq>
 801184e:	4603      	mov	r3, r0
      if (scale < ay) {
 8011850:	4659      	mov	r1, fp
 8011852:	4650      	mov	r0, sl
    if (y != 0.0) {
 8011854:	2b00      	cmp	r3, #0
 8011856:	d1bd      	bne.n	80117d4 <cblas_dznrm2+0x5c>
      const BASE ay = fabs(y);
 8011858:	f029 4300 	bic.w	r3, r9, #2147483648	; 0x80000000
 801185c:	f8cd 8008 	str.w	r8, [sp, #8]
 8011860:	9303      	str	r3, [sp, #12]
      if (scale < ay) {
 8011862:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8011866:	f016 fd91 	bl	802838c <__aeabi_dcmplt>
 801186a:	4606      	mov	r6, r0
        ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
 801186c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8011870:	4650      	mov	r0, sl
 8011872:	4659      	mov	r1, fp
      if (scale < ay) {
 8011874:	2e00      	cmp	r6, #0
 8011876:	d199      	bne.n	80117ac <cblas_dznrm2+0x34>
        ssq += (ay / scale) * (ay / scale);
 8011878:	4652      	mov	r2, sl
 801187a:	465b      	mov	r3, fp
 801187c:	4640      	mov	r0, r8
 801187e:	4649      	mov	r1, r9
 8011880:	f016 fc3c 	bl	80280fc <__aeabi_ddiv>
 8011884:	4602      	mov	r2, r0
 8011886:	460b      	mov	r3, r1
 8011888:	f016 fb0e 	bl	8027ea8 <__aeabi_dmul>
 801188c:	4602      	mov	r2, r0
 801188e:	460b      	mov	r3, r1
 8011890:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8011894:	f016 f952 	bl	8027b3c <__adddf3>
 8011898:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801189c:	e79a      	b.n	80117d4 <cblas_dznrm2+0x5c>
    return 0;
 801189e:	ed9f 0b16 	vldr	d0, [pc, #88]	; 80118f8 <cblas_dznrm2+0x180>
#define BASE double
#include "source_nrm2_c.h"
#undef BASE
}
 80118a2:	b009      	add	sp, #36	; 0x24
 80118a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ssq += (ax / scale) * (ax / scale);
 80118a8:	4652      	mov	r2, sl
 80118aa:	465b      	mov	r3, fp
 80118ac:	4630      	mov	r0, r6
 80118ae:	4639      	mov	r1, r7
 80118b0:	f016 fc24 	bl	80280fc <__aeabi_ddiv>
 80118b4:	4602      	mov	r2, r0
 80118b6:	460b      	mov	r3, r1
 80118b8:	f016 faf6 	bl	8027ea8 <__aeabi_dmul>
 80118bc:	4602      	mov	r2, r0
 80118be:	460b      	mov	r3, r1
 80118c0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80118c4:	f016 f93a 	bl	8027b3c <__adddf3>
 80118c8:	e9cd 0104 	strd	r0, r1, [sp, #16]
 80118cc:	e7b9      	b.n	8011842 <cblas_dznrm2+0xca>
  return scale * sqrt(ssq);
 80118ce:	ed9d 0b04 	vldr	d0, [sp, #16]
 80118d2:	f01e fae1 	bl	802fe98 <sqrt>
 80118d6:	4652      	mov	r2, sl
 80118d8:	ec51 0b10 	vmov	r0, r1, d0
 80118dc:	465b      	mov	r3, fp
 80118de:	f016 fae3 	bl	8027ea8 <__aeabi_dmul>
 80118e2:	ec41 0b10 	vmov	d0, r0, r1
 80118e6:	b009      	add	sp, #36	; 0x24
 80118e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80118ec:	f3af 8000 	nop.w
 80118f0:	00000000 	.word	0x00000000
 80118f4:	3ff00000 	.word	0x3ff00000
	...
 8011900:	3ff00000 	.word	0x3ff00000

08011904 <cblas_caxpy>:
#include "cblas.h"

void
cblas_caxpy (const int N, const void *alpha, const void *X, const int incX,
             void *Y, const int incY)
{
 8011904:	b4f0      	push	{r4, r5, r6, r7}
 8011906:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 801190a:	2b00      	cmp	r3, #0
 801190c:	bfd8      	it	le
 801190e:	f1c0 0c01 	rsble	ip, r0, #1
  INDEX iy = OFFSET(N, incY);

  const BASE alpha_real = CONST_REAL0(alpha);
 8011912:	ed91 5a00 	vldr	s10, [r1]
  const BASE alpha_imag = CONST_IMAG0(alpha);
 8011916:	edd1 4a01 	vldr	s9, [r1, #4]
  INDEX ix = OFFSET(N, incX);
 801191a:	bfd4      	ite	le
 801191c:	fb0c fc03 	mulle.w	ip, ip, r3
 8011920:	f04f 0c00 	movgt.w	ip, #0
  INDEX iy = OFFSET(N, incY);
 8011924:	2d00      	cmp	r5, #0
 8011926:	bfd8      	it	le
 8011928:	f1c0 0701 	rsble	r7, r0, #1

  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 801192c:	eeb5 5a40 	vcmp.f32	s10, #0.0
  INDEX iy = OFFSET(N, incY);
 8011930:	bfd4      	ite	le
 8011932:	436f      	mulle	r7, r5
 8011934:	2700      	movgt	r7, #0
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 8011936:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801193a:	d104      	bne.n	8011946 <cblas_caxpy+0x42>
 801193c:	eef5 4a40 	vcmp.f32	s9, #0.0
 8011940:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011944:	d02b      	beq.n	801199e <cblas_caxpy+0x9a>
    return;
  }

  for (i = 0; i < N; i++) {
 8011946:	2800      	cmp	r0, #0
 8011948:	dd29      	ble.n	801199e <cblas_caxpy+0x9a>
 801194a:	eb04 01c7 	add.w	r1, r4, r7, lsl #3
 801194e:	00de      	lsls	r6, r3, #3
 8011950:	eb02 02cc 	add.w	r2, r2, ip, lsl #3
 8011954:	eb04 03c7 	add.w	r3, r4, r7, lsl #3
 8011958:	00ed      	lsls	r5, r5, #3
 801195a:	3104      	adds	r1, #4
 801195c:	2400      	movs	r4, #0
    const BASE x_real = CONST_REAL(X, ix);
    const BASE x_imag = CONST_IMAG(X, ix);
 801195e:	ed92 7a01 	vldr	s14, [r2, #4]
    const BASE x_real = CONST_REAL(X, ix);
 8011962:	edd2 5a00 	vldr	s11, [r2]
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8011966:	ed51 6a01 	vldr	s13, [r1, #-4]
 801196a:	ee27 6a64 	vnmul.f32	s12, s14, s9
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801196e:	ee64 7aa5 	vmul.f32	s15, s9, s11
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8011972:	eea5 6a25 	vfma.f32	s12, s10, s11
  for (i = 0; i < N; i++) {
 8011976:	3401      	adds	r4, #1
 8011978:	42a0      	cmp	r0, r4
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801197a:	eee5 7a07 	vfma.f32	s15, s10, s14
 801197e:	4432      	add	r2, r6
 8011980:	eeb0 7a67 	vmov.f32	s14, s15
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8011984:	ee76 7a86 	vadd.f32	s15, s13, s12
 8011988:	ed41 7a01 	vstr	s15, [r1, #-4]
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801198c:	edd3 7a01 	vldr	s15, [r3, #4]
 8011990:	ee77 7a87 	vadd.f32	s15, s15, s14
 8011994:	4429      	add	r1, r5
 8011996:	edc3 7a01 	vstr	s15, [r3, #4]
  for (i = 0; i < N; i++) {
 801199a:	442b      	add	r3, r5
 801199c:	d1df      	bne.n	801195e <cblas_caxpy+0x5a>
#define BASE float
#include "source_axpy_c.h"
#undef BASE
}
 801199e:	bcf0      	pop	{r4, r5, r6, r7}
 80119a0:	4770      	bx	lr
 80119a2:	bf00      	nop

080119a4 <cblas_ccopy>:
#include "cblas.h"

void
cblas_ccopy (const int N, const void *X, const int incX, void *Y,
             const int incY)
{
 80119a4:	b4f0      	push	{r4, r5, r6, r7}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80119a6:	2a00      	cmp	r2, #0
 80119a8:	9e04      	ldr	r6, [sp, #16]
 80119aa:	bfda      	itte	le
 80119ac:	f1c0 0701 	rsble	r7, r0, #1
 80119b0:	4357      	mulle	r7, r2
 80119b2:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 80119b4:	2e00      	cmp	r6, #0
 80119b6:	bfda      	itte	le
 80119b8:	f1c0 0401 	rsble	r4, r0, #1
 80119bc:	4374      	mulle	r4, r6
 80119be:	2400      	movgt	r4, #0

  for (i = 0; i < N; i++) {
 80119c0:	2800      	cmp	r0, #0
 80119c2:	dd0f      	ble.n	80119e4 <cblas_ccopy+0x40>
 80119c4:	00d5      	lsls	r5, r2, #3
 80119c6:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
 80119ca:	00f6      	lsls	r6, r6, #3
 80119cc:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80119d0:	2200      	movs	r2, #0
    REAL(Y, iy) = CONST_REAL(X, ix);
 80119d2:	680c      	ldr	r4, [r1, #0]
 80119d4:	601c      	str	r4, [r3, #0]
  for (i = 0; i < N; i++) {
 80119d6:	3201      	adds	r2, #1
    IMAG(Y, iy) = CONST_IMAG(X, ix);
 80119d8:	684c      	ldr	r4, [r1, #4]
 80119da:	605c      	str	r4, [r3, #4]
  for (i = 0; i < N; i++) {
 80119dc:	4290      	cmp	r0, r2
 80119de:	4429      	add	r1, r5
 80119e0:	4433      	add	r3, r6
 80119e2:	d1f6      	bne.n	80119d2 <cblas_ccopy+0x2e>
#define BASE float
#include "source_copy_c.h"
#undef BASE
}
 80119e4:	bcf0      	pop	{r4, r5, r6, r7}
 80119e6:	4770      	bx	lr

080119e8 <cblas_cdotc_sub>:
#include "cblas.h"

void
cblas_cdotc_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 80119e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80119ec:	ed2d 8b04 	vpush	{d8-d9}
 80119f0:	b087      	sub	sp, #28
 80119f2:	4604      	mov	r4, r0

{
  BASE r_real = 0.0;
  BASE r_imag = 0.0;
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 80119f4:	2a00      	cmp	r2, #0
 80119f6:	9003      	str	r0, [sp, #12]
 80119f8:	9814      	ldr	r0, [sp, #80]	; 0x50
 80119fa:	bfda      	itte	le
 80119fc:	f1c4 0701 	rsble	r7, r4, #1
 8011a00:	4357      	mulle	r7, r2
 8011a02:	2700      	movgt	r7, #0
  INDEX iy = OFFSET(N, incY);
 8011a04:	2800      	cmp	r0, #0
 8011a06:	bfdc      	itt	le
 8011a08:	9c03      	ldrle	r4, [sp, #12]
 8011a0a:	f1c4 0601 	rsble	r6, r4, #1
  for (i = 0; i < N; i++) {
 8011a0e:	9c03      	ldr	r4, [sp, #12]
  INDEX iy = OFFSET(N, incY);
 8011a10:	bfd4      	ite	le
 8011a12:	4346      	mulle	r6, r0
 8011a14:	2600      	movgt	r6, #0
  for (i = 0; i < N; i++) {
 8011a16:	f04f 0b00 	mov.w	fp, #0
 8011a1a:	2c00      	cmp	r4, #0
 8011a1c:	46da      	mov	sl, fp
 8011a1e:	dd6c      	ble.n	8011afa <cblas_cdotc_sub+0x112>
 8011a20:	00d2      	lsls	r2, r2, #3
 8011a22:	9205      	str	r2, [sp, #20]
 8011a24:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 8011a28:	00c2      	lsls	r2, r0, #3
 8011a2a:	2300      	movs	r3, #0
 8011a2c:	eb01 07c7 	add.w	r7, r1, r7, lsl #3
 8011a30:	9204      	str	r2, [sp, #16]
 8011a32:	9302      	str	r3, [sp, #8]
    const BASE x_real = CONST_REAL(X, ix);
 8011a34:	edd7 8a00 	vldr	s17, [r7]
    const BASE x_imag = CONST_IMAG(X, ix);
    const BASE y_real = CONST_REAL(Y, iy);
 8011a38:	ed96 9a00 	vldr	s18, [r6]
    const BASE y_imag = CONST_IMAG(Y, iy);
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011a3c:	6878      	ldr	r0, [r7, #4]
    const BASE y_imag = CONST_IMAG(Y, iy);
 8011a3e:	ed96 8a01 	vldr	s16, [r6, #4]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011a42:	f016 f9d9 	bl	8027df8 <__aeabi_f2d>
 8011a46:	ee68 7a89 	vmul.f32	s15, s17, s18
 8011a4a:	4604      	mov	r4, r0
 8011a4c:	ee17 0a90 	vmov	r0, s15
 8011a50:	460d      	mov	r5, r1
 8011a52:	f016 f9d1 	bl	8027df8 <__aeabi_f2d>
 8011a56:	4680      	mov	r8, r0
 8011a58:	ee18 0a10 	vmov	r0, s16
 8011a5c:	4689      	mov	r9, r1
 8011a5e:	f016 f9cb 	bl	8027df8 <__aeabi_f2d>
 8011a62:	4622      	mov	r2, r4
 8011a64:	462b      	mov	r3, r5
 8011a66:	f016 fa1f 	bl	8027ea8 <__aeabi_dmul>
 8011a6a:	4602      	mov	r2, r0
 8011a6c:	460b      	mov	r3, r1
 8011a6e:	4640      	mov	r0, r8
 8011a70:	4649      	mov	r1, r9
 8011a72:	f016 f863 	bl	8027b3c <__adddf3>
 8011a76:	4680      	mov	r8, r0
 8011a78:	4650      	mov	r0, sl
 8011a7a:	4689      	mov	r9, r1
 8011a7c:	f016 f9bc 	bl	8027df8 <__aeabi_f2d>
 8011a80:	4602      	mov	r2, r0
 8011a82:	460b      	mov	r3, r1
 8011a84:	4640      	mov	r0, r8
 8011a86:	4649      	mov	r1, r9
 8011a88:	f016 f858 	bl	8027b3c <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011a8c:	9400      	str	r4, [sp, #0]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011a8e:	f016 fcbb 	bl	8028408 <__aeabi_d2f>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011a92:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011a96:	4682      	mov	sl, r0
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011a98:	ee19 0a10 	vmov	r0, s18
 8011a9c:	9301      	str	r3, [sp, #4]
 8011a9e:	f016 f9ab 	bl	8027df8 <__aeabi_f2d>
 8011aa2:	4602      	mov	r2, r0
 8011aa4:	460b      	mov	r3, r1
 8011aa6:	e9dd 0100 	ldrd	r0, r1, [sp]
 8011aaa:	f016 f9fd 	bl	8027ea8 <__aeabi_dmul>
 8011aae:	ee68 7a88 	vmul.f32	s15, s17, s16
 8011ab2:	4604      	mov	r4, r0
 8011ab4:	ee17 0a90 	vmov	r0, s15
 8011ab8:	460d      	mov	r5, r1
 8011aba:	f016 f99d 	bl	8027df8 <__aeabi_f2d>
 8011abe:	4602      	mov	r2, r0
 8011ac0:	460b      	mov	r3, r1
 8011ac2:	4620      	mov	r0, r4
 8011ac4:	4629      	mov	r1, r5
 8011ac6:	f016 f839 	bl	8027b3c <__adddf3>
 8011aca:	4604      	mov	r4, r0
 8011acc:	4658      	mov	r0, fp
 8011ace:	460d      	mov	r5, r1
 8011ad0:	f016 f992 	bl	8027df8 <__aeabi_f2d>
 8011ad4:	4602      	mov	r2, r0
 8011ad6:	460b      	mov	r3, r1
 8011ad8:	4620      	mov	r0, r4
 8011ada:	4629      	mov	r1, r5
 8011adc:	f016 f82e 	bl	8027b3c <__adddf3>
 8011ae0:	f016 fc92 	bl	8028408 <__aeabi_d2f>
 8011ae4:	9a05      	ldr	r2, [sp, #20]
  for (i = 0; i < N; i++) {
 8011ae6:	9b02      	ldr	r3, [sp, #8]
 8011ae8:	4417      	add	r7, r2
 8011aea:	9a04      	ldr	r2, [sp, #16]
 8011aec:	4416      	add	r6, r2
 8011aee:	9a03      	ldr	r2, [sp, #12]
 8011af0:	3301      	adds	r3, #1
 8011af2:	429a      	cmp	r2, r3
 8011af4:	9302      	str	r3, [sp, #8]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011af6:	4683      	mov	fp, r0
  for (i = 0; i < N; i++) {
 8011af8:	d19c      	bne.n	8011a34 <cblas_cdotc_sub+0x4c>
    ix += incX;
    iy += incY;
  }
  REAL0(result) = r_real;
 8011afa:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8011afc:	f8c3 a000 	str.w	sl, [r3]
  IMAG0(result) = r_imag;
 8011b00:	f8c3 b004 	str.w	fp, [r3, #4]
#define BASE float
#define CONJ_SIGN (-1.0)
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 8011b04:	b007      	add	sp, #28
 8011b06:	ecbd 8b04 	vpop	{d8-d9}
 8011b0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011b0e:	bf00      	nop

08011b10 <cblas_cdotu_sub>:
#include "cblas.h"

void
cblas_cdotu_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 8011b10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011b14:	ed2d 8b04 	vpush	{d8-d9}
 8011b18:	b085      	sub	sp, #20
 8011b1a:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 8011b1c:	2a00      	cmp	r2, #0
 8011b1e:	9001      	str	r0, [sp, #4]
 8011b20:	9812      	ldr	r0, [sp, #72]	; 0x48
 8011b22:	bfda      	itte	le
 8011b24:	f1c4 0601 	rsble	r6, r4, #1
 8011b28:	4356      	mulle	r6, r2
 8011b2a:	2600      	movgt	r6, #0
  INDEX iy = OFFSET(N, incY);
 8011b2c:	2800      	cmp	r0, #0
 8011b2e:	bfdc      	itt	le
 8011b30:	9c01      	ldrle	r4, [sp, #4]
 8011b32:	f1c4 0701 	rsble	r7, r4, #1
  for (i = 0; i < N; i++) {
 8011b36:	9c01      	ldr	r4, [sp, #4]
  INDEX iy = OFFSET(N, incY);
 8011b38:	bfd4      	ite	le
 8011b3a:	4347      	mulle	r7, r0
 8011b3c:	2700      	movgt	r7, #0
  for (i = 0; i < N; i++) {
 8011b3e:	f04f 0b00 	mov.w	fp, #0
 8011b42:	2c00      	cmp	r4, #0
 8011b44:	46da      	mov	sl, fp
 8011b46:	dd66      	ble.n	8011c16 <cblas_cdotu_sub+0x106>
 8011b48:	00d2      	lsls	r2, r2, #3
 8011b4a:	9203      	str	r2, [sp, #12]
 8011b4c:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
 8011b50:	00c2      	lsls	r2, r0, #3
 8011b52:	2300      	movs	r3, #0
 8011b54:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 8011b58:	9202      	str	r2, [sp, #8]
 8011b5a:	9300      	str	r3, [sp, #0]
    const BASE x_real = CONST_REAL(X, ix);
 8011b5c:	ed96 9a00 	vldr	s18, [r6]
    const BASE y_real = CONST_REAL(Y, iy);
 8011b60:	ed97 8a00 	vldr	s16, [r7]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011b64:	6870      	ldr	r0, [r6, #4]
    const BASE y_imag = CONST_IMAG(Y, iy);
 8011b66:	edd7 8a01 	vldr	s17, [r7, #4]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011b6a:	f016 f945 	bl	8027df8 <__aeabi_f2d>
 8011b6e:	ee69 7a08 	vmul.f32	s15, s18, s16
 8011b72:	4680      	mov	r8, r0
 8011b74:	ee17 0a90 	vmov	r0, s15
 8011b78:	4689      	mov	r9, r1
 8011b7a:	f016 f93d 	bl	8027df8 <__aeabi_f2d>
 8011b7e:	4604      	mov	r4, r0
 8011b80:	ee18 0a90 	vmov	r0, s17
 8011b84:	460d      	mov	r5, r1
 8011b86:	f016 f937 	bl	8027df8 <__aeabi_f2d>
 8011b8a:	4642      	mov	r2, r8
 8011b8c:	464b      	mov	r3, r9
 8011b8e:	f016 f98b 	bl	8027ea8 <__aeabi_dmul>
 8011b92:	4602      	mov	r2, r0
 8011b94:	460b      	mov	r3, r1
 8011b96:	4620      	mov	r0, r4
 8011b98:	4629      	mov	r1, r5
 8011b9a:	f015 ffcd 	bl	8027b38 <__aeabi_dsub>
 8011b9e:	4604      	mov	r4, r0
 8011ba0:	4650      	mov	r0, sl
 8011ba2:	460d      	mov	r5, r1
 8011ba4:	f016 f928 	bl	8027df8 <__aeabi_f2d>
 8011ba8:	4602      	mov	r2, r0
 8011baa:	460b      	mov	r3, r1
 8011bac:	4620      	mov	r0, r4
 8011bae:	4629      	mov	r1, r5
 8011bb0:	f015 ffc4 	bl	8027b3c <__adddf3>
 8011bb4:	f016 fc28 	bl	8028408 <__aeabi_d2f>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011bb8:	ee69 7a28 	vmul.f32	s15, s18, s17
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 8011bbc:	4682      	mov	sl, r0
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011bbe:	ee17 0a90 	vmov	r0, s15
 8011bc2:	f016 f919 	bl	8027df8 <__aeabi_f2d>
 8011bc6:	4604      	mov	r4, r0
 8011bc8:	ee18 0a10 	vmov	r0, s16
 8011bcc:	460d      	mov	r5, r1
 8011bce:	f016 f913 	bl	8027df8 <__aeabi_f2d>
 8011bd2:	4642      	mov	r2, r8
 8011bd4:	464b      	mov	r3, r9
 8011bd6:	f016 f967 	bl	8027ea8 <__aeabi_dmul>
 8011bda:	4602      	mov	r2, r0
 8011bdc:	460b      	mov	r3, r1
 8011bde:	4620      	mov	r0, r4
 8011be0:	4629      	mov	r1, r5
 8011be2:	f015 ffab 	bl	8027b3c <__adddf3>
 8011be6:	4604      	mov	r4, r0
 8011be8:	4658      	mov	r0, fp
 8011bea:	460d      	mov	r5, r1
 8011bec:	f016 f904 	bl	8027df8 <__aeabi_f2d>
 8011bf0:	4602      	mov	r2, r0
 8011bf2:	460b      	mov	r3, r1
 8011bf4:	4620      	mov	r0, r4
 8011bf6:	4629      	mov	r1, r5
 8011bf8:	f015 ffa0 	bl	8027b3c <__adddf3>
 8011bfc:	f016 fc04 	bl	8028408 <__aeabi_d2f>
 8011c00:	9a03      	ldr	r2, [sp, #12]
  for (i = 0; i < N; i++) {
 8011c02:	9b00      	ldr	r3, [sp, #0]
 8011c04:	4416      	add	r6, r2
 8011c06:	9a02      	ldr	r2, [sp, #8]
 8011c08:	4417      	add	r7, r2
 8011c0a:	9a01      	ldr	r2, [sp, #4]
 8011c0c:	3301      	adds	r3, #1
 8011c0e:	429a      	cmp	r2, r3
 8011c10:	9300      	str	r3, [sp, #0]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8011c12:	4683      	mov	fp, r0
  for (i = 0; i < N; i++) {
 8011c14:	d1a2      	bne.n	8011b5c <cblas_cdotu_sub+0x4c>
  REAL0(result) = r_real;
 8011c16:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011c18:	f8c3 a000 	str.w	sl, [r3]
  IMAG0(result) = r_imag;
 8011c1c:	f8c3 b004 	str.w	fp, [r3, #4]
#define BASE float
#define CONJ_SIGN 1.0
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 8011c20:	b005      	add	sp, #20
 8011c22:	ecbd 8b04 	vpop	{d8-d9}
 8011c26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8011c2a:	bf00      	nop

08011c2c <cblas_cgemm>:
cblas_cgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const void *alpha, const void *A, const int lda,
             const void *B, const int ldb, const void *beta, void *C,
             const int ldc)
{
 8011c2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011c30:	b085      	sub	sp, #20
  INDEX n1, n2;
  INDEX ldf, ldg;
  int conjF, conjG, TransF, TransG;
  const BASE *F, *G;

  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8011c32:	2865      	cmp	r0, #101	; 0x65
 8011c34:	e9dd 780e 	ldrd	r7, r8, [sp, #56]	; 0x38
 8011c38:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
 8011c3c:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
 8011c40:	4605      	mov	r5, r0
 8011c42:	468a      	mov	sl, r1
 8011c44:	4614      	mov	r4, r2
 8011c46:	461e      	mov	r6, r3
 8011c48:	f000 819d 	beq.w	8011f86 <cblas_cgemm+0x35a>
 8011c4c:	2a71      	cmp	r2, #113	; 0x71
 8011c4e:	bf08      	it	eq
 8011c50:	2270      	moveq	r2, #112	; 0x70
 8011c52:	2971      	cmp	r1, #113	; 0x71
 8011c54:	f000 8106 	beq.w	8011e64 <cblas_cgemm+0x238>
 8011c58:	f1aa 036f 	sub.w	r3, sl, #111	; 0x6f
 8011c5c:	2b02      	cmp	r3, #2
 8011c5e:	f240 824d 	bls.w	80120fc <cblas_cgemm+0x4d0>
 8011c62:	2002      	movs	r0, #2
 8011c64:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 8011c68:	2b02      	cmp	r3, #2
 8011c6a:	bf88      	it	hi
 8011c6c:	2003      	movhi	r0, #3
 8011c6e:	2e00      	cmp	r6, #0
 8011c70:	bfb8      	it	lt
 8011c72:	2004      	movlt	r0, #4
 8011c74:	2f00      	cmp	r7, #0
 8011c76:	f2c0 815d 	blt.w	8011f34 <cblas_cgemm+0x308>
 8011c7a:	f1b8 0f00 	cmp.w	r8, #0
 8011c7e:	f2c0 80f8 	blt.w	8011e72 <cblas_cgemm+0x246>
 8011c82:	2d65      	cmp	r5, #101	; 0x65
 8011c84:	f000 815d 	beq.w	8011f42 <cblas_cgemm+0x316>
 8011c88:	2d66      	cmp	r5, #102	; 0x66
 8011c8a:	f000 80f8 	beq.w	8011e7e <cblas_cgemm+0x252>
 8011c8e:	2800      	cmp	r0, #0
 8011c90:	f040 8112 	bne.w	8011eb8 <cblas_cgemm+0x28c>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8011c94:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8011c96:	ed93 4a00 	vldr	s8, [r3]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8011c9a:	edd3 3a01 	vldr	s7, [r3, #4]

    const BASE beta_real = CONST_REAL0(beta);
 8011c9e:	9b15      	ldr	r3, [sp, #84]	; 0x54
    const BASE beta_imag = CONST_IMAG0(beta);

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8011ca0:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8011ca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    const BASE beta_real = CONST_REAL0(beta);
 8011ca8:	edd3 5a00 	vldr	s11, [r3]
    const BASE beta_imag = CONST_IMAG0(beta);
 8011cac:	ed93 5a01 	vldr	s10, [r3, #4]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8011cb0:	d10c      	bne.n	8011ccc <cblas_cgemm+0xa0>
 8011cb2:	eef5 3a40 	vcmp.f32	s7, #0.0
 8011cb6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011cba:	d107      	bne.n	8011ccc <cblas_cgemm+0xa0>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8011cbc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8011cc0:	eef4 5a67 	vcmp.f32	s11, s15
 8011cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011cc8:	f000 821f 	beq.w	801210a <cblas_cgemm+0x4de>
      return;

    if (Order == CblasRowMajor) {
 8011ccc:	2d65      	cmp	r5, #101	; 0x65
 8011cce:	f000 8168 	beq.w	8011fa2 <cblas_cgemm+0x376>
    } else {
      n1 = N;
      n2 = M;
      F = (const BASE *)B;
      ldf = ldb;
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 8011cd2:	2c71      	cmp	r4, #113	; 0x71
 8011cd4:	f000 8205 	beq.w	80120e2 <cblas_cgemm+0x4b6>
 8011cd8:	2c6f      	cmp	r4, #111	; 0x6f
 8011cda:	bf0c      	ite	eq
 8011cdc:	256f      	moveq	r5, #111	; 0x6f
 8011cde:	2570      	movne	r5, #112	; 0x70
      TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
      G = (const BASE *)A;
      ldg = lda;
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 8011ce0:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 8011ce4:	eddf 2ac3 	vldr	s5, [pc, #780]	; 8011ff4 <cblas_cgemm+0x3c8>
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 8011ce8:	f000 8203 	beq.w	80120f2 <cblas_cgemm+0x4c6>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8011cec:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8011cf0:	ed9f 3ac0 	vldr	s6, [pc, #768]	; 8011ff4 <cblas_cgemm+0x3c8>
 8011cf4:	bf0c      	ite	eq
 8011cf6:	f04f 0a6f 	moveq.w	sl, #111	; 0x6f
 8011cfa:	f04f 0a70 	movne.w	sl, #112	; 0x70
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8011cfe:	eef5 5a40 	vcmp.f32	s11, #0.0
 8011d02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011d06:	f040 80dc 	bne.w	8011ec2 <cblas_cgemm+0x296>
 8011d0a:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8011d0e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011d12:	f040 80e3 	bne.w	8011edc <cblas_cgemm+0x2b0>
      for (i = 0; i < n1; i++) {
 8011d16:	2f00      	cmp	r7, #0
 8011d18:	dd19      	ble.n	8011d4e <cblas_cgemm+0x122>
 8011d1a:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011d1c:	ebc6 7046 	rsb	r0, r6, r6, lsl #29
 8011d20:	00c0      	lsls	r0, r0, #3
 8011d22:	ea4f 04cb 	mov.w	r4, fp, lsl #3
 8011d26:	eb03 02c6 	add.w	r2, r3, r6, lsl #3
 8011d2a:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8011d2c:	f04f 0c00 	mov.w	ip, #0
        for (j = 0; j < n2; j++) {
 8011d30:	2e00      	cmp	r6, #0
 8011d32:	bfc8      	it	gt
 8011d34:	1813      	addgt	r3, r2, r0
 8011d36:	dd06      	ble.n	8011d46 <cblas_cgemm+0x11a>
          REAL(C, ldc * i + j) = 0.0;
 8011d38:	f8c3 c000 	str.w	ip, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 8011d3c:	f8c3 c004 	str.w	ip, [r3, #4]
        for (j = 0; j < n2; j++) {
 8011d40:	3308      	adds	r3, #8
 8011d42:	429a      	cmp	r2, r3
 8011d44:	d1f8      	bne.n	8011d38 <cblas_cgemm+0x10c>
      for (i = 0; i < n1; i++) {
 8011d46:	3101      	adds	r1, #1
 8011d48:	428f      	cmp	r7, r1
 8011d4a:	4422      	add	r2, r4
 8011d4c:	d1f0      	bne.n	8011d30 <cblas_cgemm+0x104>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8011d4e:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8011d52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011d56:	d104      	bne.n	8011d62 <cblas_cgemm+0x136>
 8011d58:	eef5 3a40 	vcmp.f32	s7, #0.0
 8011d5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011d60:	d07d      	beq.n	8011e5e <cblas_cgemm+0x232>
      return;

    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 8011d62:	2d6f      	cmp	r5, #111	; 0x6f
 8011d64:	f000 8148 	beq.w	8011ff8 <cblas_cgemm+0x3cc>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 8011d68:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8011d6c:	f000 826e 	beq.w	801224c <cblas_cgemm+0x620>
        }
      }

    } else if (TransF == CblasTrans && TransG == CblasTrans) {

      for (i = 0; i < n1; i++) {
 8011d70:	2f00      	cmp	r7, #0
 8011d72:	dd74      	ble.n	8011e5e <cblas_cgemm+0x232>
 8011d74:	ea4f 01cb 	mov.w	r1, fp, lsl #3
 8011d78:	9100      	str	r1, [sp, #0]
 8011d7a:	9916      	ldr	r1, [sp, #88]	; 0x58
 8011d7c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011d7e:	970e      	str	r7, [sp, #56]	; 0x38
 8011d80:	eb01 0ec6 	add.w	lr, r1, r6, lsl #3
 8011d84:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8011d86:	f8cd b05c 	str.w	fp, [sp, #92]	; 0x5c
 8011d8a:	f101 0c04 	add.w	ip, r1, #4
 8011d8e:	9911      	ldr	r1, [sp, #68]	; 0x44
 8011d90:	eb01 01c8 	add.w	r1, r1, r8, lsl #3
 8011d94:	2300      	movs	r3, #0
 8011d96:	e9cd 6101 	strd	r6, r1, [sp, #4]
 8011d9a:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8011d9c:	00d0      	lsls	r0, r2, #3
 8011d9e:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 8011da2:	461f      	mov	r7, r3
 8011da4:	469b      	mov	fp, r3
        for (j = 0; j < n2; j++) {
 8011da6:	9b01      	ldr	r3, [sp, #4]
 8011da8:	2b00      	cmp	r3, #0
 8011daa:	dd4e      	ble.n	8011e4a <cblas_cgemm+0x21e>
 8011dac:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011dae:	9902      	ldr	r1, [sp, #8]
 8011db0:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
 8011db4:	2500      	movs	r5, #0
          BASE temp_real = 0.0;
          BASE temp_imag = 0.0;
 8011db6:	ed9f 5a8d 	vldr	s10, [pc, #564]	; 8011fec <cblas_cgemm+0x3c0>
          for (k = 0; k < K; k++) {
 8011dba:	f1b8 0f00 	cmp.w	r8, #0
          BASE temp_real = 0.0;
 8011dbe:	bfd8      	it	le
 8011dc0:	eef0 4a45 	vmovle.f32	s9, s10
          for (k = 0; k < K; k++) {
 8011dc4:	dd24      	ble.n	8011e10 <cblas_cgemm+0x1e4>
 8011dc6:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 8011dca:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
          BASE temp_real = 0.0;
 8011dce:	eef0 4a45 	vmov.f32	s9, s10
 8011dd2:	eb06 03c5 	add.w	r3, r6, r5, lsl #3
          for (k = 0; k < K; k++) {
 8011dd6:	4662      	mov	r2, ip
            const BASE Fki_real = CONST_REAL(F, ldf * k + i);
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8011dd8:	ed93 7a01 	vldr	s14, [r3, #4]
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8011ddc:	edd2 7a00 	vldr	s15, [r2]
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 8011de0:	ed93 6a00 	vldr	s12, [r3]
            const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 8011de4:	ed52 5a01 	vldr	s11, [r2, #-4]
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8011de8:	ee61 7aa7 	vmul.f32	s15, s3, s15
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8011dec:	ee22 7a07 	vmul.f32	s14, s4, s14

            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8011df0:	ee67 6a86 	vmul.f32	s13, s15, s12
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8011df4:	ee67 7a67 	vnmul.f32	s15, s14, s15
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8011df8:	eee5 6a87 	vfma.f32	s13, s11, s14
 8011dfc:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8011dfe:	4299      	cmp	r1, r3
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8011e00:	eee5 7a86 	vfma.f32	s15, s11, s12
 8011e04:	4402      	add	r2, r0
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8011e06:	ee35 5a26 	vadd.f32	s10, s10, s13
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8011e0a:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 8011e0e:	d1e3      	bne.n	8011dd8 <cblas_cgemm+0x1ac>
          }
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8011e10:	ee25 7a63 	vnmul.f32	s14, s10, s7
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8011e14:	ee63 7aa4 	vmul.f32	s15, s7, s9
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8011e18:	eea4 7a24 	vfma.f32	s14, s8, s9
 8011e1c:	3408      	adds	r4, #8
 8011e1e:	444d      	add	r5, r9
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8011e20:	eee4 7a05 	vfma.f32	s15, s8, s10
 8011e24:	4451      	add	r1, sl
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8011e26:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8011e2a:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8011e2e:	ed14 7a02 	vldr	s14, [r4, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8011e32:	ed54 7a01 	vldr	s15, [r4, #-4]
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8011e36:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8011e3a:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8011e3e:	ed04 7a02 	vstr	s14, [r4, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8011e42:	ed44 7a01 	vstr	s15, [r4, #-4]
        for (j = 0; j < n2; j++) {
 8011e46:	45a6      	cmp	lr, r4
 8011e48:	d1b5      	bne.n	8011db6 <cblas_cgemm+0x18a>
      for (i = 0; i < n1; i++) {
 8011e4a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8011e4c:	449b      	add	fp, r3
 8011e4e:	9b00      	ldr	r3, [sp, #0]
 8011e50:	449e      	add	lr, r3
 8011e52:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011e54:	3701      	adds	r7, #1
 8011e56:	42bb      	cmp	r3, r7
 8011e58:	f10c 0c08 	add.w	ip, ip, #8
 8011e5c:	d1a3      	bne.n	8011da6 <cblas_cgemm+0x17a>
#define BASE float
#include "source_gemm_c.h"
#undef BASE
}
 8011e5e:	b005      	add	sp, #20
 8011e60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8011e64:	3865      	subs	r0, #101	; 0x65
 8011e66:	2801      	cmp	r0, #1
 8011e68:	bf94      	ite	ls
 8011e6a:	2000      	movls	r0, #0
 8011e6c:	2001      	movhi	r0, #1
 8011e6e:	2170      	movs	r1, #112	; 0x70
 8011e70:	e6f8      	b.n	8011c64 <cblas_cgemm+0x38>
 8011e72:	2d65      	cmp	r5, #101	; 0x65
 8011e74:	f04f 0006 	mov.w	r0, #6
 8011e78:	d063      	beq.n	8011f42 <cblas_cgemm+0x316>
 8011e7a:	2d66      	cmp	r5, #102	; 0x66
 8011e7c:	d11c      	bne.n	8011eb8 <cblas_cgemm+0x28c>
 8011e7e:	2a6f      	cmp	r2, #111	; 0x6f
 8011e80:	bf0c      	ite	eq
 8011e82:	4643      	moveq	r3, r8
 8011e84:	463b      	movne	r3, r7
 8011e86:	2b01      	cmp	r3, #1
 8011e88:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011e8a:	bfb8      	it	lt
 8011e8c:	2301      	movlt	r3, #1
 8011e8e:	4293      	cmp	r3, r2
 8011e90:	bfc8      	it	gt
 8011e92:	200b      	movgt	r0, #11
 8011e94:	296f      	cmp	r1, #111	; 0x6f
 8011e96:	f000 81cd 	beq.w	8012234 <cblas_cgemm+0x608>
 8011e9a:	4643      	mov	r3, r8
 8011e9c:	2b01      	cmp	r3, #1
 8011e9e:	bfb8      	it	lt
 8011ea0:	2301      	movlt	r3, #1
 8011ea2:	454b      	cmp	r3, r9
 8011ea4:	f300 8282 	bgt.w	80123ac <cblas_cgemm+0x780>
 8011ea8:	2e01      	cmp	r6, #1
 8011eaa:	4633      	mov	r3, r6
 8011eac:	bfb8      	it	lt
 8011eae:	2301      	movlt	r3, #1
 8011eb0:	459b      	cmp	fp, r3
 8011eb2:	f6bf aeec 	bge.w	8011c8e <cblas_cgemm+0x62>
 8011eb6:	200e      	movs	r0, #14
 8011eb8:	4a4a      	ldr	r2, [pc, #296]	; (8011fe4 <cblas_cgemm+0x3b8>)
 8011eba:	494b      	ldr	r1, [pc, #300]	; (8011fe8 <cblas_cgemm+0x3bc>)
 8011ebc:	f015 fdc4 	bl	8027a48 <cblas_xerbla>
 8011ec0:	e6e8      	b.n	8011c94 <cblas_cgemm+0x68>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8011ec2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8011ec6:	eef4 5a67 	vcmp.f32	s11, s15
 8011eca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011ece:	d105      	bne.n	8011edc <cblas_cgemm+0x2b0>
 8011ed0:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8011ed4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011ed8:	f43f af39 	beq.w	8011d4e <cblas_cgemm+0x122>
      for (i = 0; i < n1; i++) {
 8011edc:	2f00      	cmp	r7, #0
 8011ede:	f77f af36 	ble.w	8011d4e <cblas_cgemm+0x122>
 8011ee2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8011ee4:	ebc6 7446 	rsb	r4, r6, r6, lsl #29
 8011ee8:	00e4      	lsls	r4, r4, #3
 8011eea:	f104 0e04 	add.w	lr, r4, #4
 8011eee:	ea4f 0ccb 	mov.w	ip, fp, lsl #3
 8011ef2:	eb03 01c6 	add.w	r1, r3, r6, lsl #3
 8011ef6:	2000      	movs	r0, #0
        for (j = 0; j < n2; j++) {
 8011ef8:	2e00      	cmp	r6, #0
 8011efa:	dd16      	ble.n	8011f2a <cblas_cgemm+0x2fe>
 8011efc:	1863      	adds	r3, r4, r1
 8011efe:	eb0e 0201 	add.w	r2, lr, r1
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 8011f02:	edd3 6a01 	vldr	s13, [r3, #4]
          const BASE Cij_real = REAL(C, ldc * i + j);
 8011f06:	ed12 6a01 	vldr	s12, [r2, #-4]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8011f0a:	ee26 7ac5 	vnmul.f32	s14, s13, s10
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8011f0e:	ee65 7a06 	vmul.f32	s15, s10, s12
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8011f12:	eea5 7a86 	vfma.f32	s14, s11, s12
 8011f16:	3308      	adds	r3, #8
 8011f18:	3208      	adds	r2, #8
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8011f1a:	eee5 7aa6 	vfma.f32	s15, s11, s13
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8011f1e:	ed02 7a03 	vstr	s14, [r2, #-12]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8011f22:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < n2; j++) {
 8011f26:	4299      	cmp	r1, r3
 8011f28:	d1eb      	bne.n	8011f02 <cblas_cgemm+0x2d6>
      for (i = 0; i < n1; i++) {
 8011f2a:	3001      	adds	r0, #1
 8011f2c:	4287      	cmp	r7, r0
 8011f2e:	4461      	add	r1, ip
 8011f30:	d1e2      	bne.n	8011ef8 <cblas_cgemm+0x2cc>
 8011f32:	e70c      	b.n	8011d4e <cblas_cgemm+0x122>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8011f34:	f1b8 0f00 	cmp.w	r8, #0
 8011f38:	db9b      	blt.n	8011e72 <cblas_cgemm+0x246>
 8011f3a:	2d65      	cmp	r5, #101	; 0x65
 8011f3c:	f04f 0005 	mov.w	r0, #5
 8011f40:	d19b      	bne.n	8011e7a <cblas_cgemm+0x24e>
 8011f42:	2a6f      	cmp	r2, #111	; 0x6f
 8011f44:	bf0c      	ite	eq
 8011f46:	4643      	moveq	r3, r8
 8011f48:	4633      	movne	r3, r6
 8011f4a:	2b01      	cmp	r3, #1
 8011f4c:	bfb8      	it	lt
 8011f4e:	2301      	movlt	r3, #1
 8011f50:	454b      	cmp	r3, r9
 8011f52:	bfc8      	it	gt
 8011f54:	2009      	movgt	r0, #9
 8011f56:	296f      	cmp	r1, #111	; 0x6f
 8011f58:	f000 820f 	beq.w	801237a <cblas_cgemm+0x74e>
 8011f5c:	4643      	mov	r3, r8
 8011f5e:	2b01      	cmp	r3, #1
 8011f60:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8011f62:	bfb8      	it	lt
 8011f64:	2301      	movlt	r3, #1
 8011f66:	4293      	cmp	r3, r2
 8011f68:	f340 80d6 	ble.w	8012118 <cblas_cgemm+0x4ec>
 8011f6c:	2f01      	cmp	r7, #1
 8011f6e:	4638      	mov	r0, r7
 8011f70:	bfb8      	it	lt
 8011f72:	2001      	movlt	r0, #1
 8011f74:	4a1b      	ldr	r2, [pc, #108]	; (8011fe4 <cblas_cgemm+0x3b8>)
 8011f76:	491c      	ldr	r1, [pc, #112]	; (8011fe8 <cblas_cgemm+0x3bc>)
 8011f78:	4583      	cmp	fp, r0
 8011f7a:	bfb4      	ite	lt
 8011f7c:	200e      	movlt	r0, #14
 8011f7e:	200b      	movge	r0, #11
 8011f80:	f015 fd62 	bl	8027a48 <cblas_xerbla>
 8011f84:	e686      	b.n	8011c94 <cblas_cgemm+0x68>
 8011f86:	2971      	cmp	r1, #113	; 0x71
 8011f88:	f000 81f1 	beq.w	801236e <cblas_cgemm+0x742>
 8011f8c:	2a71      	cmp	r2, #113	; 0x71
 8011f8e:	f000 81e6 	beq.w	801235e <cblas_cgemm+0x732>
 8011f92:	f1aa 036f 	sub.w	r3, sl, #111	; 0x6f
 8011f96:	2b02      	cmp	r3, #2
 8011f98:	4611      	mov	r1, r2
 8011f9a:	4652      	mov	r2, sl
 8011f9c:	f63f ae61 	bhi.w	8011c62 <cblas_cgemm+0x36>
 8011fa0:	e0ac      	b.n	80120fc <cblas_cgemm+0x4d0>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 8011fa2:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
 8011fa6:	f000 81fd 	beq.w	80123a4 <cblas_cgemm+0x778>
 8011faa:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8011fae:	eddf 2a11 	vldr	s5, [pc, #68]	; 8011ff4 <cblas_cgemm+0x3c8>
 8011fb2:	bf0c      	ite	eq
 8011fb4:	256f      	moveq	r5, #111	; 0x6f
 8011fb6:	2570      	movne	r5, #112	; 0x70
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8011fb8:	9914      	ldr	r1, [sp, #80]	; 0x50
 8011fba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8011fbc:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
 8011fc0:	463a      	mov	r2, r7
 8011fc2:	2c71      	cmp	r4, #113	; 0x71
 8011fc4:	4637      	mov	r7, r6
 8011fc6:	4689      	mov	r9, r1
 8011fc8:	4616      	mov	r6, r2
 8011fca:	f000 81e3 	beq.w	8012394 <cblas_cgemm+0x768>
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8011fce:	2c6f      	cmp	r4, #111	; 0x6f
 8011fd0:	f040 80a7 	bne.w	8012122 <cblas_cgemm+0x4f6>
      F = (const BASE *)A;
 8011fd4:	9a11      	ldr	r2, [sp, #68]	; 0x44
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8011fd6:	ed9f 3a07 	vldr	s6, [pc, #28]	; 8011ff4 <cblas_cgemm+0x3c8>
      F = (const BASE *)A;
 8011fda:	9213      	str	r2, [sp, #76]	; 0x4c
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8011fdc:	46a2      	mov	sl, r4
      G = (const BASE *)B;
 8011fde:	9311      	str	r3, [sp, #68]	; 0x44
 8011fe0:	e68d      	b.n	8011cfe <cblas_cgemm+0xd2>
 8011fe2:	bf00      	nop
 8011fe4:	08030378 	.word	0x08030378
 8011fe8:	080306b0 	.word	0x080306b0
 8011fec:	00000000 	.word	0x00000000
 8011ff0:	ffffffff 	.word	0xffffffff
 8011ff4:	00000001 	.word	0x00000001
    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 8011ff8:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8011ffc:	f000 8099 	beq.w	8012132 <cblas_cgemm+0x506>
      for (i = 0; i < n1; i++) {
 8012000:	2f00      	cmp	r7, #0
 8012002:	f77f af2c 	ble.w	8011e5e <cblas_cgemm+0x232>
 8012006:	ea4f 02cb 	mov.w	r2, fp, lsl #3
 801200a:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801200c:	9200      	str	r2, [sp, #0]
 801200e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012010:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 8012012:	9601      	str	r6, [sp, #4]
 8012014:	f04f 0a00 	mov.w	sl, #0
 8012018:	00db      	lsls	r3, r3, #3
 801201a:	eb02 0cc6 	add.w	ip, r2, r6, lsl #3
 801201e:	9e11      	ldr	r6, [sp, #68]	; 0x44
 8012020:	970e      	str	r7, [sp, #56]	; 0x38
 8012022:	eb05 01c8 	add.w	r1, r5, r8, lsl #3
 8012026:	46d6      	mov	lr, sl
 8012028:	461f      	mov	r7, r3
        for (j = 0; j < n2; j++) {
 801202a:	9b01      	ldr	r3, [sp, #4]
 801202c:	2b00      	cmp	r3, #0
 801202e:	dd4d      	ble.n	80120cc <cblas_cgemm+0x4a0>
 8012030:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012032:	2400      	movs	r4, #0
 8012034:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
          BASE temp_imag = 0.0;
 8012038:	ed1f 5a14 	vldr	s10, [pc, #-80]	; 8011fec <cblas_cgemm+0x3c0>
          for (k = 0; k < K; k++) {
 801203c:	f1b8 0f00 	cmp.w	r8, #0
          BASE temp_real = 0.0;
 8012040:	bfd8      	it	le
 8012042:	eef0 4a45 	vmovle.f32	s9, s10
          for (k = 0; k < K; k++) {
 8012046:	dd25      	ble.n	8012094 <cblas_cgemm+0x468>
 8012048:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 801204c:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
          BASE temp_real = 0.0;
 8012050:	eef0 4a45 	vmov.f32	s9, s10
 8012054:	eb06 02c4 	add.w	r2, r6, r4, lsl #3
          for (k = 0; k < K; k++) {
 8012058:	462b      	mov	r3, r5
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801205a:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801205e:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 8012062:	ed92 6a00 	vldr	s12, [r2]
            const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 8012066:	edd3 5a00 	vldr	s11, [r3]
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801206a:	ee61 7aa7 	vmul.f32	s15, s3, s15
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 801206e:	ee22 7a07 	vmul.f32	s14, s4, s14
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8012072:	ee67 6a86 	vmul.f32	s13, s15, s12
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8012076:	ee67 7a67 	vnmul.f32	s15, s14, s15
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 801207a:	eee5 6a87 	vfma.f32	s13, s11, s14
 801207e:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8012080:	4299      	cmp	r1, r3
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8012082:	eee5 7a86 	vfma.f32	s15, s11, s12
 8012086:	f102 0208 	add.w	r2, r2, #8
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 801208a:	ee35 5a26 	vadd.f32	s10, s10, s13
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 801208e:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 8012092:	d1e2      	bne.n	801205a <cblas_cgemm+0x42e>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8012094:	ee25 7a63 	vnmul.f32	s14, s10, s7
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8012098:	ee63 7aa4 	vmul.f32	s15, s7, s9
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801209c:	eea4 7a24 	vfma.f32	s14, s8, s9
 80120a0:	3008      	adds	r0, #8
 80120a2:	444c      	add	r4, r9
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80120a4:	eee4 7a05 	vfma.f32	s15, s8, s10
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80120a8:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80120ac:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80120b0:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80120b4:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80120b8:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80120bc:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80120c0:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80120c4:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 80120c8:	4584      	cmp	ip, r0
 80120ca:	d1b5      	bne.n	8012038 <cblas_cgemm+0x40c>
      for (i = 0; i < n1; i++) {
 80120cc:	9b00      	ldr	r3, [sp, #0]
 80120ce:	449c      	add	ip, r3
 80120d0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80120d2:	f10e 0e01 	add.w	lr, lr, #1
 80120d6:	4573      	cmp	r3, lr
 80120d8:	44da      	add	sl, fp
 80120da:	443d      	add	r5, r7
 80120dc:	4439      	add	r1, r7
 80120de:	d1a4      	bne.n	801202a <cblas_cgemm+0x3fe>
 80120e0:	e6bd      	b.n	8011e5e <cblas_cgemm+0x232>
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 80120e2:	f1ba 0f71 	cmp.w	sl, #113	; 0x71
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 80120e6:	ed5f 2a3e 	vldr	s5, [pc, #-248]	; 8011ff0 <cblas_cgemm+0x3c4>
      TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80120ea:	f04f 0570 	mov.w	r5, #112	; 0x70
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 80120ee:	f47f adfd 	bne.w	8011cec <cblas_cgemm+0xc0>
 80120f2:	ed1f 3a41 	vldr	s6, [pc, #-260]	; 8011ff0 <cblas_cgemm+0x3c4>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80120f6:	f04f 0a70 	mov.w	sl, #112	; 0x70
 80120fa:	e600      	b.n	8011cfe <cblas_cgemm+0xd2>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80120fc:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 8012100:	2801      	cmp	r0, #1
 8012102:	bf94      	ite	ls
 8012104:	2000      	movls	r0, #0
 8012106:	2001      	movhi	r0, #1
 8012108:	e5ac      	b.n	8011c64 <cblas_cgemm+0x38>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801210a:	eeb5 5a40 	vcmp.f32	s10, #0.0
 801210e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012112:	f47f addb 	bne.w	8011ccc <cblas_cgemm+0xa0>
 8012116:	e6a2      	b.n	8011e5e <cblas_cgemm+0x232>
 8012118:	2f01      	cmp	r7, #1
 801211a:	463b      	mov	r3, r7
 801211c:	bfb8      	it	lt
 801211e:	2301      	movlt	r3, #1
 8012120:	e6c6      	b.n	8011eb0 <cblas_cgemm+0x284>
      F = (const BASE *)A;
 8012122:	9a11      	ldr	r2, [sp, #68]	; 0x44
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8012124:	ed1f 3a4d 	vldr	s6, [pc, #-308]	; 8011ff4 <cblas_cgemm+0x3c8>
      F = (const BASE *)A;
 8012128:	9213      	str	r2, [sp, #76]	; 0x4c
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801212a:	f04f 0a70 	mov.w	sl, #112	; 0x70
      G = (const BASE *)B;
 801212e:	9311      	str	r3, [sp, #68]	; 0x44
 8012130:	e5e5      	b.n	8011cfe <cblas_cgemm+0xd2>
      for (k = 0; k < K; k++) {
 8012132:	f1b8 0f00 	cmp.w	r8, #0
 8012136:	f77f ae92 	ble.w	8011e5e <cblas_cgemm+0x232>
 801213a:	2300      	movs	r3, #0
 801213c:	9300      	str	r3, [sp, #0]
 801213e:	9302      	str	r3, [sp, #8]
 8012140:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8012142:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012144:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8012148:	3304      	adds	r3, #4
 801214a:	9301      	str	r3, [sp, #4]
 801214c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801214e:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 8012152:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 8012156:	3304      	adds	r3, #4
 8012158:	ea4f 0ec2 	mov.w	lr, r2, lsl #3
 801215c:	469a      	mov	sl, r3
        for (i = 0; i < n1; i++) {
 801215e:	2f00      	cmp	r7, #0
 8012160:	dd5a      	ble.n	8012218 <cblas_cgemm+0x5ec>
 8012162:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012164:	9a00      	ldr	r2, [sp, #0]
 8012166:	9c01      	ldr	r4, [sp, #4]
 8012168:	2500      	movs	r5, #0
 801216a:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 801216e:	46ac      	mov	ip, r5
 8012170:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
 8012174:	e00a      	b.n	801218c <cblas_cgemm+0x560>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 8012176:	eef5 4a40 	vcmp.f32	s9, #0.0
 801217a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801217e:	d118      	bne.n	80121b2 <cblas_cgemm+0x586>
        for (i = 0; i < n1; i++) {
 8012180:	f10c 0c01 	add.w	ip, ip, #1
 8012184:	4567      	cmp	r7, ip
 8012186:	445d      	add	r5, fp
 8012188:	4474      	add	r4, lr
 801218a:	d045      	beq.n	8012218 <cblas_cgemm+0x5ec>
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801218c:	edd4 7a00 	vldr	s15, [r4]
          const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 8012190:	ed14 7a01 	vldr	s14, [r4, #-4]
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8012194:	ee61 7aa7 	vmul.f32	s15, s3, s15
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 8012198:	ee63 4a87 	vmul.f32	s9, s7, s14
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801219c:	ee67 5ae3 	vnmul.f32	s11, s15, s7
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 80121a0:	eee4 4a27 	vfma.f32	s9, s8, s15
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 80121a4:	eee4 5a07 	vfma.f32	s11, s8, s14
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 80121a8:	eef5 5a40 	vcmp.f32	s11, #0.0
 80121ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80121b0:	d0e1      	beq.n	8012176 <cblas_cgemm+0x54a>
            for (j = 0; j < n2; j++) {
 80121b2:	2e00      	cmp	r6, #0
 80121b4:	dde4      	ble.n	8012180 <cblas_cgemm+0x554>
 80121b6:	1970      	adds	r0, r6, r5
 80121b8:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
 80121bc:	eb08 00c0 	add.w	r0, r8, r0, lsl #3
 80121c0:	eb08 03c5 	add.w	r3, r8, r5, lsl #3
 80121c4:	eb0a 01c5 	add.w	r1, sl, r5, lsl #3
 80121c8:	464a      	mov	r2, r9
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 80121ca:	edd2 7a01 	vldr	s15, [r2, #4]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 80121ce:	ed92 5a00 	vldr	s10, [r2]
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 80121d2:	ed51 6a01 	vldr	s13, [r1, #-4]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 80121d6:	ee62 7a27 	vmul.f32	s15, s4, s15
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 80121da:	ee24 7a85 	vmul.f32	s14, s9, s10
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 80121de:	ee27 6ae4 	vnmul.f32	s12, s15, s9
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 80121e2:	eea5 7aa7 	vfma.f32	s14, s11, s15
 80121e6:	3308      	adds	r3, #8
 80121e8:	3208      	adds	r2, #8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 80121ea:	eef0 7a46 	vmov.f32	s15, s12
 80121ee:	eee5 7a85 	vfma.f32	s15, s11, s10
 80121f2:	3108      	adds	r1, #8
 80121f4:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80121f8:	ed41 7a03 	vstr	s15, [r1, #-12]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 80121fc:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012200:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012204:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (j = 0; j < n2; j++) {
 8012208:	4298      	cmp	r0, r3
 801220a:	d1de      	bne.n	80121ca <cblas_cgemm+0x59e>
        for (i = 0; i < n1; i++) {
 801220c:	f10c 0c01 	add.w	ip, ip, #1
 8012210:	4567      	cmp	r7, ip
 8012212:	445d      	add	r5, fp
 8012214:	4474      	add	r4, lr
 8012216:	d1b9      	bne.n	801218c <cblas_cgemm+0x560>
      for (k = 0; k < K; k++) {
 8012218:	9a01      	ldr	r2, [sp, #4]
 801221a:	9912      	ldr	r1, [sp, #72]	; 0x48
 801221c:	9b02      	ldr	r3, [sp, #8]
 801221e:	3208      	adds	r2, #8
 8012220:	9201      	str	r2, [sp, #4]
 8012222:	9a00      	ldr	r2, [sp, #0]
 8012224:	440a      	add	r2, r1
 8012226:	9200      	str	r2, [sp, #0]
 8012228:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801222a:	3301      	adds	r3, #1
 801222c:	429a      	cmp	r2, r3
 801222e:	9302      	str	r3, [sp, #8]
 8012230:	d195      	bne.n	801215e <cblas_cgemm+0x532>
 8012232:	e614      	b.n	8011e5e <cblas_cgemm+0x232>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8012234:	2e01      	cmp	r6, #1
 8012236:	4633      	mov	r3, r6
 8012238:	bfb8      	it	lt
 801223a:	2301      	movlt	r3, #1
 801223c:	454b      	cmp	r3, r9
 801223e:	f77f ae37 	ble.w	8011eb0 <cblas_cgemm+0x284>
 8012242:	455b      	cmp	r3, fp
 8012244:	bfcc      	ite	gt
 8012246:	200e      	movgt	r0, #14
 8012248:	2009      	movle	r0, #9
 801224a:	e635      	b.n	8011eb8 <cblas_cgemm+0x28c>
      for (k = 0; k < K; k++) {
 801224c:	f1b8 0f00 	cmp.w	r8, #0
 8012250:	f77f ae05 	ble.w	8011e5e <cblas_cgemm+0x232>
 8012254:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012256:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
 801225a:	00d2      	lsls	r2, r2, #3
 801225c:	9202      	str	r2, [sp, #8]
 801225e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8012260:	eb02 0cc7 	add.w	ip, r2, r7, lsl #3
 8012264:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012266:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 801226a:	2300      	movs	r3, #0
 801226c:	9203      	str	r2, [sp, #12]
 801226e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8012270:	e9cd 3300 	strd	r3, r3, [sp]
 8012274:	e9cd 780e 	strd	r7, r8, [sp, #56]	; 0x38
 8012278:	3204      	adds	r2, #4
 801227a:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 801227e:	ea4f 0ecb 	mov.w	lr, fp, lsl #3
 8012282:	469a      	mov	sl, r3
 8012284:	4691      	mov	r9, r2
        for (i = 0; i < n1; i++) {
 8012286:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8012288:	2b00      	cmp	r3, #0
 801228a:	dd58      	ble.n	801233e <cblas_cgemm+0x712>
 801228c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801228e:	9a01      	ldr	r2, [sp, #4]
 8012290:	9803      	ldr	r0, [sp, #12]
 8012292:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
 8012296:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8012298:	9a00      	ldr	r2, [sp, #0]
 801229a:	eef8 1ae2 	vcvt.f32.s32	s3, s5
 801229e:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 80122a2:	2500      	movs	r5, #0
 80122a4:	e009      	b.n	80122ba <cblas_cgemm+0x68e>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 80122a6:	eef5 4a40 	vcmp.f32	s9, #0.0
 80122aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80122ae:	d117      	bne.n	80122e0 <cblas_cgemm+0x6b4>
        for (i = 0; i < n1; i++) {
 80122b0:	3408      	adds	r4, #8
 80122b2:	45a4      	cmp	ip, r4
 80122b4:	445d      	add	r5, fp
 80122b6:	4470      	add	r0, lr
 80122b8:	d041      	beq.n	801233e <cblas_cgemm+0x712>
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 80122ba:	edd4 7a01 	vldr	s15, [r4, #4]
          const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 80122be:	ed94 7a00 	vldr	s14, [r4]
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 80122c2:	ee61 7aa7 	vmul.f32	s15, s3, s15
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 80122c6:	ee63 4a87 	vmul.f32	s9, s7, s14
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 80122ca:	ee67 5ae3 	vnmul.f32	s11, s15, s7
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 80122ce:	eee4 4a27 	vfma.f32	s9, s8, s15
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 80122d2:	eee4 5a07 	vfma.f32	s11, s8, s14
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 80122d6:	eef5 5a40 	vcmp.f32	s11, #0.0
 80122da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80122de:	d0e2      	beq.n	80122a6 <cblas_cgemm+0x67a>
            for (j = 0; j < n2; j++) {
 80122e0:	2e00      	cmp	r6, #0
 80122e2:	dde5      	ble.n	80122b0 <cblas_cgemm+0x684>
 80122e4:	eeb8 2ac3 	vcvt.f32.s32	s4, s6
 80122e8:	eb08 03c5 	add.w	r3, r8, r5, lsl #3
 80122ec:	eb09 01c5 	add.w	r1, r9, r5, lsl #3
 80122f0:	463a      	mov	r2, r7
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 80122f2:	edd2 7a01 	vldr	s15, [r2, #4]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 80122f6:	ed92 5a00 	vldr	s10, [r2]
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 80122fa:	ed51 6a01 	vldr	s13, [r1, #-4]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 80122fe:	ee62 7a27 	vmul.f32	s15, s4, s15
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012302:	ee24 7a85 	vmul.f32	s14, s9, s10
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012306:	ee27 6ae4 	vnmul.f32	s12, s15, s9
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801230a:	eea5 7aa7 	vfma.f32	s14, s11, s15
 801230e:	3308      	adds	r3, #8
 8012310:	3208      	adds	r2, #8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 8012312:	eef0 7a46 	vmov.f32	s15, s12
 8012316:	eee5 7a85 	vfma.f32	s15, s11, s10
 801231a:	3108      	adds	r1, #8
 801231c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8012320:	ed41 7a03 	vstr	s15, [r1, #-12]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 8012324:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012328:	ee77 7a87 	vadd.f32	s15, s15, s14
 801232c:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (j = 0; j < n2; j++) {
 8012330:	4298      	cmp	r0, r3
 8012332:	d1de      	bne.n	80122f2 <cblas_cgemm+0x6c6>
        for (i = 0; i < n1; i++) {
 8012334:	3408      	adds	r4, #8
 8012336:	45a4      	cmp	ip, r4
 8012338:	445d      	add	r5, fp
 801233a:	4470      	add	r0, lr
 801233c:	d1bd      	bne.n	80122ba <cblas_cgemm+0x68e>
      for (k = 0; k < K; k++) {
 801233e:	9b02      	ldr	r3, [sp, #8]
 8012340:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8012342:	449c      	add	ip, r3
 8012344:	9b01      	ldr	r3, [sp, #4]
 8012346:	4413      	add	r3, r2
 8012348:	9301      	str	r3, [sp, #4]
 801234a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801234c:	9b00      	ldr	r3, [sp, #0]
 801234e:	4413      	add	r3, r2
 8012350:	9300      	str	r3, [sp, #0]
 8012352:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8012354:	f10a 0a01 	add.w	sl, sl, #1
 8012358:	4553      	cmp	r3, sl
 801235a:	d194      	bne.n	8012286 <cblas_cgemm+0x65a>
 801235c:	e57f      	b.n	8011e5e <cblas_cgemm+0x232>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801235e:	f1a1 036f 	sub.w	r3, r1, #111	; 0x6f
 8012362:	2b02      	cmp	r3, #2
 8012364:	460a      	mov	r2, r1
 8012366:	d92b      	bls.n	80123c0 <cblas_cgemm+0x794>
 8012368:	2170      	movs	r1, #112	; 0x70
 801236a:	2002      	movs	r0, #2
 801236c:	e47f      	b.n	8011c6e <cblas_cgemm+0x42>
 801236e:	2a71      	cmp	r2, #113	; 0x71
 8012370:	d025      	beq.n	80123be <cblas_cgemm+0x792>
 8012372:	4621      	mov	r1, r4
 8012374:	2270      	movs	r2, #112	; 0x70
 8012376:	2000      	movs	r0, #0
 8012378:	e474      	b.n	8011c64 <cblas_cgemm+0x38>
 801237a:	2f01      	cmp	r7, #1
 801237c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801237e:	463b      	mov	r3, r7
 8012380:	bfb8      	it	lt
 8012382:	2301      	movlt	r3, #1
 8012384:	4293      	cmp	r3, r2
 8012386:	f77f ad93 	ble.w	8011eb0 <cblas_cgemm+0x284>
 801238a:	455b      	cmp	r3, fp
 801238c:	bfcc      	ite	gt
 801238e:	200e      	movgt	r0, #14
 8012390:	200b      	movle	r0, #11
 8012392:	e591      	b.n	8011eb8 <cblas_cgemm+0x28c>
      F = (const BASE *)A;
 8012394:	9a11      	ldr	r2, [sp, #68]	; 0x44
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8012396:	ed9f 3a0c 	vldr	s6, [pc, #48]	; 80123c8 <cblas_cgemm+0x79c>
      F = (const BASE *)A;
 801239a:	9213      	str	r2, [sp, #76]	; 0x4c
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801239c:	f04f 0a70 	mov.w	sl, #112	; 0x70
      G = (const BASE *)B;
 80123a0:	9311      	str	r3, [sp, #68]	; 0x44
 80123a2:	e4ac      	b.n	8011cfe <cblas_cgemm+0xd2>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 80123a4:	eddf 2a08 	vldr	s5, [pc, #32]	; 80123c8 <cblas_cgemm+0x79c>
      TransF = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80123a8:	2570      	movs	r5, #112	; 0x70
 80123aa:	e605      	b.n	8011fb8 <cblas_cgemm+0x38c>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80123ac:	2e01      	cmp	r6, #1
 80123ae:	4630      	mov	r0, r6
 80123b0:	bfb8      	it	lt
 80123b2:	2001      	movlt	r0, #1
 80123b4:	4583      	cmp	fp, r0
 80123b6:	bfb4      	ite	lt
 80123b8:	200e      	movlt	r0, #14
 80123ba:	2009      	movge	r0, #9
 80123bc:	e57c      	b.n	8011eb8 <cblas_cgemm+0x28c>
 80123be:	2270      	movs	r2, #112	; 0x70
 80123c0:	2000      	movs	r0, #0
 80123c2:	2170      	movs	r1, #112	; 0x70
 80123c4:	e44e      	b.n	8011c64 <cblas_cgemm+0x38>
 80123c6:	bf00      	nop
 80123c8:	ffffffff 	.word	0xffffffff

080123cc <cblas_cgemv>:
void
cblas_cgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const void *alpha, const void *A,
             const int lda, const void *X, const int incX, const void *beta,
             void *Y, const int incY)
{
 80123cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80123d0:	ed2d 8b04 	vpush	{d8-d9}
 80123d4:	b083      	sub	sp, #12
 80123d6:	4688      	mov	r8, r1
 80123d8:	9915      	ldr	r1, [sp, #84]	; 0x54
 80123da:	9c10      	ldr	r4, [sp, #64]	; 0x40
  INDEX lenX, lenY;

  const BASE alpha_real = CONST_REAL0(alpha);
  const BASE alpha_imag = CONST_IMAG0(alpha);

  const BASE beta_real = CONST_REAL0(beta);
 80123dc:	ed91 9a00 	vldr	s18, [r1]
  const BASE beta_imag = CONST_IMAG0(beta);
 80123e0:	edd1 9a01 	vldr	s19, [r1, #4]
 80123e4:	9911      	ldr	r1, [sp, #68]	; 0x44
 80123e6:	9100      	str	r1, [sp, #0]
 80123e8:	e9dd 9112 	ldrd	r9, r1, [sp, #72]	; 0x48
 80123ec:	9101      	str	r1, [sp, #4]

  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 80123ee:	f1a8 016f 	sub.w	r1, r8, #111	; 0x6f
 80123f2:	2902      	cmp	r1, #2
  const BASE alpha_real = CONST_REAL0(alpha);
 80123f4:	ed94 8a00 	vldr	s16, [r4]
  const BASE alpha_imag = CONST_IMAG0(alpha);
 80123f8:	edd4 8a01 	vldr	s17, [r4, #4]
 80123fc:	9e14      	ldr	r6, [sp, #80]	; 0x50
 80123fe:	e9dd a416 	ldrd	sl, r4, [sp, #88]	; 0x58
 8012402:	4683      	mov	fp, r0
 8012404:	4615      	mov	r5, r2
 8012406:	461f      	mov	r7, r3
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8012408:	d877      	bhi.n	80124fa <cblas_cgemv+0x12e>
 801240a:	3865      	subs	r0, #101	; 0x65
 801240c:	2801      	cmp	r0, #1
 801240e:	bf94      	ite	ls
 8012410:	2000      	movls	r0, #0
 8012412:	2001      	movhi	r0, #1
 8012414:	2d00      	cmp	r5, #0
 8012416:	bfb8      	it	lt
 8012418:	2003      	movlt	r0, #3
 801241a:	2f00      	cmp	r7, #0
 801241c:	bfb8      	it	lt
 801241e:	2004      	movlt	r0, #4
 8012420:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 8012424:	f000 80a5 	beq.w	8012572 <cblas_cgemv+0x1a6>
 8012428:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 801242c:	d06c      	beq.n	8012508 <cblas_cgemv+0x13c>
 801242e:	2e00      	cmp	r6, #0
 8012430:	d165      	bne.n	80124fe <cblas_cgemv+0x132>
 8012432:	2c00      	cmp	r4, #0
 8012434:	bf14      	ite	ne
 8012436:	2009      	movne	r0, #9
 8012438:	200c      	moveq	r0, #12
 801243a:	4ac4      	ldr	r2, [pc, #784]	; (801274c <cblas_cgemv+0x380>)
 801243c:	49c4      	ldr	r1, [pc, #784]	; (8012750 <cblas_cgemv+0x384>)
 801243e:	f015 fb03 	bl	8027a48 <cblas_xerbla>

  if (M == 0 || N == 0)
 8012442:	2d00      	cmp	r5, #0
 8012444:	d054      	beq.n	80124f0 <cblas_cgemv+0x124>
 8012446:	2f00      	cmp	r7, #0
 8012448:	d052      	beq.n	80124f0 <cblas_cgemv+0x124>
    return;

  if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801244a:	eeb5 8a40 	vcmp.f32	s16, #0.0
 801244e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012452:	d104      	bne.n	801245e <cblas_cgemv+0x92>
 8012454:	eef5 8a40 	vcmp.f32	s17, #0.0
 8012458:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801245c:	d03c      	beq.n	80124d8 <cblas_cgemv+0x10c>
      && (beta_real == 1.0 && beta_imag == 0.0))
    return;

  if (TransA == CblasNoTrans) {
 801245e:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8012462:	d002      	beq.n	801246a <cblas_cgemv+0x9e>
 8012464:	463b      	mov	r3, r7
 8012466:	462f      	mov	r7, r5
 8012468:	461d      	mov	r5, r3
    lenY = N;
  }

  /* form  y := beta*y */

  if (beta_real == 0.0 && beta_imag == 0.0) {
 801246a:	eeb5 9a40 	vcmp.f32	s18, #0.0
 801246e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012472:	f040 808e 	bne.w	8012592 <cblas_cgemv+0x1c6>
 8012476:	eef5 9a40 	vcmp.f32	s19, #0.0
 801247a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801247e:	d156      	bne.n	801252e <cblas_cgemv+0x162>
    INDEX iy = OFFSET(lenY, incY);
 8012480:	2c00      	cmp	r4, #0
 8012482:	f340 822b 	ble.w	80128dc <cblas_cgemv+0x510>
 8012486:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8012488:	2d00      	cmp	r5, #0
 801248a:	dd0a      	ble.n	80124a2 <cblas_cgemv+0xd6>
      REAL(Y, iy) = 0.0;
 801248c:	2100      	movs	r1, #0
 801248e:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
 8012492:	00e0      	lsls	r0, r4, #3
    for (i = 0; i < lenY; i++) {
 8012494:	2200      	movs	r2, #0
 8012496:	3201      	adds	r2, #1
 8012498:	4295      	cmp	r5, r2
      REAL(Y, iy) = 0.0;
 801249a:	6019      	str	r1, [r3, #0]
      IMAG(Y, iy) = 0.0;
 801249c:	6059      	str	r1, [r3, #4]
    for (i = 0; i < lenY; i++) {
 801249e:	4403      	add	r3, r0
 80124a0:	d1f9      	bne.n	8012496 <cblas_cgemv+0xca>
      IMAG(Y, iy) = tmpI;
      iy += incY;
    }
  }

  if (alpha_real == 0.0 && alpha_imag == 0.0)
 80124a2:	eeb5 8a40 	vcmp.f32	s16, #0.0
 80124a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80124aa:	d104      	bne.n	80124b6 <cblas_cgemv+0xea>
 80124ac:	eef5 8a40 	vcmp.f32	s17, #0.0
 80124b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80124b4:	d01c      	beq.n	80124f0 <cblas_cgemv+0x124>
    return;

  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 80124b6:	f1bb 0f65 	cmp.w	fp, #101	; 0x65
 80124ba:	d07a      	beq.n	80125b2 <cblas_cgemv+0x1e6>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 80124bc:	f1bb 0f66 	cmp.w	fp, #102	; 0x66
 80124c0:	f000 80db 	beq.w	801267a <cblas_cgemv+0x2ae>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
      iy += incY;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 80124c4:	4aa3      	ldr	r2, [pc, #652]	; (8012754 <cblas_cgemv+0x388>)
 80124c6:	49a2      	ldr	r1, [pc, #648]	; (8012750 <cblas_cgemv+0x384>)
 80124c8:	2000      	movs	r0, #0
#define BASE float
#include "source_gemv_c.h"
#undef BASE
}
 80124ca:	b003      	add	sp, #12
 80124cc:	ecbd 8b04 	vpop	{d8-d9}
 80124d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80124d4:	f015 bab8 	b.w	8027a48 <cblas_xerbla>
      && (beta_real == 1.0 && beta_imag == 0.0))
 80124d8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80124dc:	eeb4 9a67 	vcmp.f32	s18, s15
 80124e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80124e4:	d1bb      	bne.n	801245e <cblas_cgemv+0x92>
 80124e6:	eef5 9a40 	vcmp.f32	s19, #0.0
 80124ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80124ee:	d118      	bne.n	8012522 <cblas_cgemv+0x156>
 80124f0:	b003      	add	sp, #12
 80124f2:	ecbd 8b04 	vpop	{d8-d9}
 80124f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 80124fa:	2002      	movs	r0, #2
 80124fc:	e78a      	b.n	8012414 <cblas_cgemv+0x48>
 80124fe:	2c00      	cmp	r4, #0
 8012500:	d055      	beq.n	80125ae <cblas_cgemv+0x1e2>
 8012502:	2800      	cmp	r0, #0
 8012504:	d09d      	beq.n	8012442 <cblas_cgemv+0x76>
 8012506:	e798      	b.n	801243a <cblas_cgemv+0x6e>
 8012508:	2d01      	cmp	r5, #1
 801250a:	462b      	mov	r3, r5
 801250c:	bfb8      	it	lt
 801250e:	2301      	movlt	r3, #1
 8012510:	454b      	cmp	r3, r9
 8012512:	dd8c      	ble.n	801242e <cblas_cgemv+0x62>
 8012514:	2e00      	cmp	r6, #0
 8012516:	d08c      	beq.n	8012432 <cblas_cgemv+0x66>
 8012518:	2c00      	cmp	r4, #0
 801251a:	bf14      	ite	ne
 801251c:	2007      	movne	r0, #7
 801251e:	200c      	moveq	r0, #12
 8012520:	e78b      	b.n	801243a <cblas_cgemv+0x6e>
  if (TransA == CblasNoTrans) {
 8012522:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8012526:	d002      	beq.n	801252e <cblas_cgemv+0x162>
 8012528:	463b      	mov	r3, r7
 801252a:	462f      	mov	r7, r5
 801252c:	461d      	mov	r5, r3
    INDEX iy = OFFSET(lenY, incY);
 801252e:	2c00      	cmp	r4, #0
 8012530:	dd2a      	ble.n	8012588 <cblas_cgemv+0x1bc>
 8012532:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8012534:	2d00      	cmp	r5, #0
 8012536:	ddb4      	ble.n	80124a2 <cblas_cgemv+0xd6>
 8012538:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
 801253c:	3204      	adds	r2, #4
 801253e:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
 8012542:	00e0      	lsls	r0, r4, #3
 8012544:	2100      	movs	r1, #0
      const BASE y_imag = IMAG(Y, iy);
 8012546:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE y_real = REAL(Y, iy);
 801254a:	ed52 6a01 	vldr	s13, [r2, #-4]
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801254e:	ee27 7ae9 	vnmul.f32	s14, s15, s19
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 8012552:	ee69 7a27 	vmul.f32	s15, s18, s15
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 8012556:	eea9 7a26 	vfma.f32	s14, s18, s13
    for (i = 0; i < lenY; i++) {
 801255a:	3101      	adds	r1, #1
 801255c:	428d      	cmp	r5, r1
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801255e:	eee9 7aa6 	vfma.f32	s15, s19, s13
      REAL(Y, iy) = tmpR;
 8012562:	ed02 7a01 	vstr	s14, [r2, #-4]
      IMAG(Y, iy) = tmpI;
 8012566:	edc3 7a01 	vstr	s15, [r3, #4]
    for (i = 0; i < lenY; i++) {
 801256a:	4402      	add	r2, r0
 801256c:	4403      	add	r3, r0
 801256e:	d1ea      	bne.n	8012546 <cblas_cgemv+0x17a>
 8012570:	e797      	b.n	80124a2 <cblas_cgemv+0xd6>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 8012572:	2f01      	cmp	r7, #1
 8012574:	463b      	mov	r3, r7
 8012576:	bfb8      	it	lt
 8012578:	2301      	movlt	r3, #1
 801257a:	454b      	cmp	r3, r9
 801257c:	f77f af57 	ble.w	801242e <cblas_cgemv+0x62>
 8012580:	2e00      	cmp	r6, #0
 8012582:	f43f af56 	beq.w	8012432 <cblas_cgemv+0x66>
 8012586:	e7c7      	b.n	8012518 <cblas_cgemv+0x14c>
    INDEX iy = OFFSET(lenY, incY);
 8012588:	f1c5 0301 	rsb	r3, r5, #1
 801258c:	fb03 f304 	mul.w	r3, r3, r4
 8012590:	e7d0      	b.n	8012534 <cblas_cgemv+0x168>
  } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8012592:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8012596:	eeb4 9a67 	vcmp.f32	s18, s15
 801259a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801259e:	d1c6      	bne.n	801252e <cblas_cgemv+0x162>
 80125a0:	eef5 9a40 	vcmp.f32	s19, #0.0
 80125a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80125a8:	f43f af7b 	beq.w	80124a2 <cblas_cgemv+0xd6>
 80125ac:	e7bf      	b.n	801252e <cblas_cgemv+0x162>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 80125ae:	200c      	movs	r0, #12
 80125b0:	e743      	b.n	801243a <cblas_cgemv+0x6e>
  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 80125b2:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80125b6:	f000 80d1 	beq.w	801275c <cblas_cgemv+0x390>
  } else if ((order == CblasRowMajor && TransA == CblasTrans)
 80125ba:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 80125be:	f000 812b 	beq.w	8012818 <cblas_cgemv+0x44c>
  } else if (order == CblasRowMajor && TransA == CblasConjTrans) {
 80125c2:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 80125c6:	f47f af7d 	bne.w	80124c4 <cblas_cgemv+0xf8>
    INDEX ix = OFFSET(lenX, incX);
 80125ca:	2e00      	cmp	r6, #0
 80125cc:	f340 8190 	ble.w	80128f0 <cblas_cgemv+0x524>
 80125d0:	2100      	movs	r1, #0
    for (j = 0; j < lenX; j++) {
 80125d2:	2f00      	cmp	r7, #0
 80125d4:	dd8c      	ble.n	80124f0 <cblas_cgemv+0x124>
 80125d6:	2c00      	cmp	r4, #0
 80125d8:	f1c5 0301 	rsb	r3, r5, #1
 80125dc:	fb03 f304 	mul.w	r3, r3, r4
 80125e0:	bfc8      	it	gt
 80125e2:	2300      	movgt	r3, #0
 80125e4:	9801      	ldr	r0, [sp, #4]
 80125e6:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
 80125ea:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 80125ee:	9b00      	ldr	r3, [sp, #0]
      INDEX iy = OFFSET(lenY, incY);
 80125f0:	f04f 0c00 	mov.w	ip, #0
 80125f4:	3204      	adds	r2, #4
 80125f6:	eb00 0bc1 	add.w	fp, r0, r1, lsl #3
 80125fa:	00f6      	lsls	r6, r6, #3
 80125fc:	00e4      	lsls	r4, r4, #3
 80125fe:	9201      	str	r2, [sp, #4]
 8012600:	46e6      	mov	lr, ip
 8012602:	ea4f 08c9 	mov.w	r8, r9, lsl #3
 8012606:	eb03 00c5 	add.w	r0, r3, r5, lsl #3
      BASE x_real = CONST_REAL(X, ix);
 801260a:	eddb 7a00 	vldr	s15, [fp]
      BASE x_imag = CONST_IMAG(X, ix);
 801260e:	ed9b 7a01 	vldr	s14, [fp, #4]
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 8012612:	ee28 5aa7 	vmul.f32	s10, s17, s15
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 8012616:	ee67 5a68 	vnmul.f32	s11, s14, s17
      for (i = 0; i < lenY; i++) {
 801261a:	2d00      	cmp	r5, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801261c:	eea8 5a07 	vfma.f32	s10, s16, s14
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 8012620:	eee8 5a27 	vfma.f32	s11, s16, s15
      for (i = 0; i < lenY; i++) {
 8012624:	dd21      	ble.n	801266a <cblas_cgemv+0x29e>
 8012626:	9b00      	ldr	r3, [sp, #0]
 8012628:	9901      	ldr	r1, [sp, #4]
 801262a:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 801262e:	4652      	mov	r2, sl
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 8012630:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8012634:	ed93 6a00 	vldr	s12, [r3]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 8012638:	ed51 6a01 	vldr	s13, [r1, #-4]
 801263c:	ee25 7a27 	vmul.f32	s14, s10, s15
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 8012640:	ee67 7ae5 	vnmul.f32	s15, s15, s11
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 8012644:	eea5 7a86 	vfma.f32	s14, s11, s12
 8012648:	3308      	adds	r3, #8
      for (i = 0; i < lenY; i++) {
 801264a:	4298      	cmp	r0, r3
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801264c:	eee5 7a06 	vfma.f32	s15, s10, s12
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 8012650:	ee36 7a87 	vadd.f32	s14, s13, s14
 8012654:	ed01 7a01 	vstr	s14, [r1, #-4]
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 8012658:	ed92 7a01 	vldr	s14, [r2, #4]
 801265c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8012660:	4421      	add	r1, r4
 8012662:	edc2 7a01 	vstr	s15, [r2, #4]
      for (i = 0; i < lenY; i++) {
 8012666:	4422      	add	r2, r4
 8012668:	d1e2      	bne.n	8012630 <cblas_cgemv+0x264>
    for (j = 0; j < lenX; j++) {
 801266a:	f10e 0e01 	add.w	lr, lr, #1
 801266e:	4577      	cmp	r7, lr
 8012670:	44b3      	add	fp, r6
 8012672:	44cc      	add	ip, r9
 8012674:	4440      	add	r0, r8
 8012676:	d1c8      	bne.n	801260a <cblas_cgemv+0x23e>
 8012678:	e73a      	b.n	80124f0 <cblas_cgemv+0x124>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801267a:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 801267e:	d06d      	beq.n	801275c <cblas_cgemv+0x390>
             || (order == CblasColMajor && TransA == CblasNoTrans)) {
 8012680:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8012684:	f000 80c8 	beq.w	8012818 <cblas_cgemv+0x44c>
  } else if (order == CblasColMajor && TransA == CblasConjTrans) {
 8012688:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 801268c:	f47f af1a 	bne.w	80124c4 <cblas_cgemv+0xf8>
    INDEX iy = OFFSET(lenY, incY);
 8012690:	2c00      	cmp	r4, #0
 8012692:	f340 8128 	ble.w	80128e6 <cblas_cgemv+0x51a>
 8012696:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8012698:	2d00      	cmp	r5, #0
 801269a:	f77f af29 	ble.w	80124f0 <cblas_cgemv+0x124>
 801269e:	2e00      	cmp	r6, #0
 80126a0:	f1c7 0201 	rsb	r2, r7, #1
 80126a4:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 80126a8:	9b01      	ldr	r3, [sp, #4]
 80126aa:	fb02 f206 	mul.w	r2, r2, r6
 80126ae:	bfc8      	it	gt
 80126b0:	2200      	movgt	r2, #0
 80126b2:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 80126b6:	9b00      	ldr	r3, [sp, #0]
      INDEX ix = OFFSET(lenX, incX);
 80126b8:	2000      	movs	r0, #0
 80126ba:	00e4      	lsls	r4, r4, #3
 80126bc:	00f6      	lsls	r6, r6, #3
 80126be:	4684      	mov	ip, r0
 80126c0:	ea4f 0ec9 	mov.w	lr, r9, lsl #3
 80126c4:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 80126c8:	4698      	mov	r8, r3
      for (j = 0; j < lenX; j++) {
 80126ca:	ed9f 5a23 	vldr	s10, [pc, #140]	; 8012758 <cblas_cgemv+0x38c>
 80126ce:	2f00      	cmp	r7, #0
 80126d0:	eef0 4a45 	vmov.f32	s9, s10
 80126d4:	dd1a      	ble.n	801270c <cblas_cgemv+0x340>
 80126d6:	eb08 03c0 	add.w	r3, r8, r0, lsl #3
 80126da:	465a      	mov	r2, fp
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 80126dc:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_real = CONST_REAL(X, ix);
 80126e0:	ed92 6a00 	vldr	s12, [r2]
        const BASE x_imag = CONST_IMAG(X, ix);
 80126e4:	edd2 5a01 	vldr	s11, [r2, #4]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 80126e8:	edd3 6a00 	vldr	s13, [r3]
        dotI += A_real * x_imag + (-A_imag) * x_real;
 80126ec:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        dotR += A_real * x_real - (-A_imag) * x_imag;
 80126f0:	ee65 7aa7 	vmul.f32	s15, s11, s15
        dotI += A_real * x_imag + (-A_imag) * x_real;
 80126f4:	eea5 7aa6 	vfma.f32	s14, s11, s13
 80126f8:	3308      	adds	r3, #8
      for (j = 0; j < lenX; j++) {
 80126fa:	4299      	cmp	r1, r3
        dotR += A_real * x_real - (-A_imag) * x_imag;
 80126fc:	eee6 7a26 	vfma.f32	s15, s12, s13
 8012700:	4432      	add	r2, r6
        dotI += A_real * x_imag + (-A_imag) * x_real;
 8012702:	ee35 5a07 	vadd.f32	s10, s10, s14
        dotR += A_real * x_real - (-A_imag) * x_imag;
 8012706:	ee74 4aa7 	vadd.f32	s9, s9, s15
      for (j = 0; j < lenX; j++) {
 801270a:	d1e7      	bne.n	80126dc <cblas_cgemv+0x310>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801270c:	ee25 7a68 	vnmul.f32	s14, s10, s17
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 8012710:	ee68 7aa4 	vmul.f32	s15, s17, s9
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 8012714:	eea8 7a24 	vfma.f32	s14, s16, s9
    for (i = 0; i < lenY; i++) {
 8012718:	f10c 0c01 	add.w	ip, ip, #1
 801271c:	4565      	cmp	r5, ip
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801271e:	eee8 7a05 	vfma.f32	s15, s16, s10
 8012722:	4448      	add	r0, r9
 8012724:	4471      	add	r1, lr
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 8012726:	eeb0 6a47 	vmov.f32	s12, s14
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801272a:	eef0 6a67 	vmov.f32	s13, s15
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801272e:	ed9a 7a00 	vldr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 8012732:	edda 7a01 	vldr	s15, [sl, #4]
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 8012736:	ee37 7a06 	vadd.f32	s14, s14, s12
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801273a:	ee77 7aa6 	vadd.f32	s15, s15, s13
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801273e:	ed8a 7a00 	vstr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 8012742:	edca 7a01 	vstr	s15, [sl, #4]
    for (i = 0; i < lenY; i++) {
 8012746:	44a2      	add	sl, r4
 8012748:	d1bf      	bne.n	80126ca <cblas_cgemv+0x2fe>
 801274a:	e6d1      	b.n	80124f0 <cblas_cgemv+0x124>
 801274c:	08030378 	.word	0x08030378
 8012750:	080306c0 	.word	0x080306c0
 8012754:	080305a8 	.word	0x080305a8
 8012758:	00000000 	.word	0x00000000
    INDEX iy = OFFSET(lenY, incY);
 801275c:	2c00      	cmp	r4, #0
 801275e:	f340 80b3 	ble.w	80128c8 <cblas_cgemv+0x4fc>
 8012762:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 8012764:	2d00      	cmp	r5, #0
 8012766:	f77f aec3 	ble.w	80124f0 <cblas_cgemv+0x124>
 801276a:	2e00      	cmp	r6, #0
 801276c:	f1c7 0201 	rsb	r2, r7, #1
 8012770:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 8012774:	9b01      	ldr	r3, [sp, #4]
 8012776:	fb02 f206 	mul.w	r2, r2, r6
 801277a:	bfc8      	it	gt
 801277c:	2200      	movgt	r2, #0
 801277e:	eb03 0bc2 	add.w	fp, r3, r2, lsl #3
 8012782:	9b00      	ldr	r3, [sp, #0]
      INDEX ix = OFFSET(lenX, incX);
 8012784:	2000      	movs	r0, #0
 8012786:	00e4      	lsls	r4, r4, #3
 8012788:	00f6      	lsls	r6, r6, #3
 801278a:	4684      	mov	ip, r0
 801278c:	ea4f 0ec9 	mov.w	lr, r9, lsl #3
 8012790:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 8012794:	4698      	mov	r8, r3
      for (j = 0; j < lenX; j++) {
 8012796:	ed1f 5a10 	vldr	s10, [pc, #-64]	; 8012758 <cblas_cgemv+0x38c>
 801279a:	2f00      	cmp	r7, #0
 801279c:	eef0 4a45 	vmov.f32	s9, s10
 80127a0:	dd1a      	ble.n	80127d8 <cblas_cgemv+0x40c>
 80127a2:	eb08 03c0 	add.w	r3, r8, r0, lsl #3
 80127a6:	465a      	mov	r2, fp
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 80127a8:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_real = CONST_REAL(X, ix);
 80127ac:	ed92 6a00 	vldr	s12, [r2]
        const BASE x_imag = CONST_IMAG(X, ix);
 80127b0:	edd2 5a01 	vldr	s11, [r2, #4]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 80127b4:	edd3 6a00 	vldr	s13, [r3]
        dotI += A_real * x_imag + A_imag * x_real;
 80127b8:	ee26 7a27 	vmul.f32	s14, s12, s15
        dotR += A_real * x_real - A_imag * x_imag;
 80127bc:	ee67 7ae5 	vnmul.f32	s15, s15, s11
        dotI += A_real * x_imag + A_imag * x_real;
 80127c0:	eea5 7aa6 	vfma.f32	s14, s11, s13
 80127c4:	3308      	adds	r3, #8
      for (j = 0; j < lenX; j++) {
 80127c6:	428b      	cmp	r3, r1
        dotR += A_real * x_real - A_imag * x_imag;
 80127c8:	eee6 7a26 	vfma.f32	s15, s12, s13
 80127cc:	4432      	add	r2, r6
        dotI += A_real * x_imag + A_imag * x_real;
 80127ce:	ee35 5a07 	vadd.f32	s10, s10, s14
        dotR += A_real * x_real - A_imag * x_imag;
 80127d2:	ee74 4aa7 	vadd.f32	s9, s9, s15
      for (j = 0; j < lenX; j++) {
 80127d6:	d1e7      	bne.n	80127a8 <cblas_cgemv+0x3dc>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80127d8:	ee25 7a68 	vnmul.f32	s14, s10, s17
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80127dc:	ee68 7aa4 	vmul.f32	s15, s17, s9
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80127e0:	eea8 7a24 	vfma.f32	s14, s16, s9
    for (i = 0; i < lenY; i++) {
 80127e4:	f10c 0c01 	add.w	ip, ip, #1
 80127e8:	4565      	cmp	r5, ip
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80127ea:	eee8 7a05 	vfma.f32	s15, s16, s10
 80127ee:	4448      	add	r0, r9
 80127f0:	4471      	add	r1, lr
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80127f2:	eeb0 6a47 	vmov.f32	s12, s14
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80127f6:	eef0 6a67 	vmov.f32	s13, s15
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 80127fa:	ed9a 7a00 	vldr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 80127fe:	edda 7a01 	vldr	s15, [sl, #4]
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 8012802:	ee37 7a06 	vadd.f32	s14, s14, s12
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 8012806:	ee77 7aa6 	vadd.f32	s15, s15, s13
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801280a:	ed8a 7a00 	vstr	s14, [sl]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801280e:	edca 7a01 	vstr	s15, [sl, #4]
    for (i = 0; i < lenY; i++) {
 8012812:	44a2      	add	sl, r4
 8012814:	d1bf      	bne.n	8012796 <cblas_cgemv+0x3ca>
 8012816:	e66b      	b.n	80124f0 <cblas_cgemv+0x124>
    INDEX ix = OFFSET(lenX, incX);
 8012818:	2e00      	cmp	r6, #0
 801281a:	dd5a      	ble.n	80128d2 <cblas_cgemv+0x506>
 801281c:	2100      	movs	r1, #0
    for (j = 0; j < lenX; j++) {
 801281e:	2f00      	cmp	r7, #0
 8012820:	f77f ae66 	ble.w	80124f0 <cblas_cgemv+0x124>
 8012824:	2c00      	cmp	r4, #0
 8012826:	f1c5 0301 	rsb	r3, r5, #1
 801282a:	fb03 f304 	mul.w	r3, r3, r4
 801282e:	bfc8      	it	gt
 8012830:	2300      	movgt	r3, #0
 8012832:	9801      	ldr	r0, [sp, #4]
 8012834:	eb0a 02c3 	add.w	r2, sl, r3, lsl #3
 8012838:	eb0a 0ac3 	add.w	sl, sl, r3, lsl #3
 801283c:	9b00      	ldr	r3, [sp, #0]
      INDEX iy = OFFSET(lenY, incY);
 801283e:	f04f 0c00 	mov.w	ip, #0
 8012842:	3204      	adds	r2, #4
 8012844:	eb00 0bc1 	add.w	fp, r0, r1, lsl #3
 8012848:	00f6      	lsls	r6, r6, #3
 801284a:	00e4      	lsls	r4, r4, #3
 801284c:	9201      	str	r2, [sp, #4]
 801284e:	46e6      	mov	lr, ip
 8012850:	ea4f 08c9 	mov.w	r8, r9, lsl #3
 8012854:	eb03 00c5 	add.w	r0, r3, r5, lsl #3
      BASE x_real = CONST_REAL(X, ix);
 8012858:	eddb 7a00 	vldr	s15, [fp]
      BASE x_imag = CONST_IMAG(X, ix);
 801285c:	ed9b 7a01 	vldr	s14, [fp, #4]
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 8012860:	ee28 5aa7 	vmul.f32	s10, s17, s15
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 8012864:	ee67 5a68 	vnmul.f32	s11, s14, s17
      for (i = 0; i < lenY; i++) {
 8012868:	2d00      	cmp	r5, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801286a:	eea8 5a07 	vfma.f32	s10, s16, s14
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801286e:	eee8 5a27 	vfma.f32	s11, s16, s15
      for (i = 0; i < lenY; i++) {
 8012872:	dd21      	ble.n	80128b8 <cblas_cgemv+0x4ec>
 8012874:	9b00      	ldr	r3, [sp, #0]
 8012876:	9901      	ldr	r1, [sp, #4]
 8012878:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 801287c:	4652      	mov	r2, sl
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 801287e:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8012882:	ed93 6a00 	vldr	s12, [r3]
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 8012886:	ed51 6a01 	vldr	s13, [r1, #-4]
 801288a:	ee27 7ac5 	vnmul.f32	s14, s15, s10
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801288e:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 8012892:	eea5 7a86 	vfma.f32	s14, s11, s12
 8012896:	3308      	adds	r3, #8
      for (i = 0; i < lenY; i++) {
 8012898:	4298      	cmp	r0, r3
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801289a:	eee5 7a06 	vfma.f32	s15, s10, s12
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801289e:	ee36 7a87 	vadd.f32	s14, s13, s14
 80128a2:	ed01 7a01 	vstr	s14, [r1, #-4]
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 80128a6:	ed92 7a01 	vldr	s14, [r2, #4]
 80128aa:	ee77 7a27 	vadd.f32	s15, s14, s15
 80128ae:	4421      	add	r1, r4
 80128b0:	edc2 7a01 	vstr	s15, [r2, #4]
      for (i = 0; i < lenY; i++) {
 80128b4:	4422      	add	r2, r4
 80128b6:	d1e2      	bne.n	801287e <cblas_cgemv+0x4b2>
    for (j = 0; j < lenX; j++) {
 80128b8:	f10e 0e01 	add.w	lr, lr, #1
 80128bc:	4577      	cmp	r7, lr
 80128be:	44b3      	add	fp, r6
 80128c0:	44cc      	add	ip, r9
 80128c2:	4440      	add	r0, r8
 80128c4:	d1c8      	bne.n	8012858 <cblas_cgemv+0x48c>
 80128c6:	e613      	b.n	80124f0 <cblas_cgemv+0x124>
    INDEX iy = OFFSET(lenY, incY);
 80128c8:	f1c5 0301 	rsb	r3, r5, #1
 80128cc:	fb03 f304 	mul.w	r3, r3, r4
 80128d0:	e748      	b.n	8012764 <cblas_cgemv+0x398>
    INDEX ix = OFFSET(lenX, incX);
 80128d2:	f1c7 0101 	rsb	r1, r7, #1
 80128d6:	fb01 f106 	mul.w	r1, r1, r6
 80128da:	e7a0      	b.n	801281e <cblas_cgemv+0x452>
    INDEX iy = OFFSET(lenY, incY);
 80128dc:	f1c5 0301 	rsb	r3, r5, #1
 80128e0:	fb03 f304 	mul.w	r3, r3, r4
 80128e4:	e5d0      	b.n	8012488 <cblas_cgemv+0xbc>
    INDEX iy = OFFSET(lenY, incY);
 80128e6:	f1c5 0301 	rsb	r3, r5, #1
 80128ea:	fb03 f304 	mul.w	r3, r3, r4
 80128ee:	e6d3      	b.n	8012698 <cblas_cgemv+0x2cc>
    INDEX ix = OFFSET(lenX, incX);
 80128f0:	f1c7 0101 	rsb	r1, r7, #1
 80128f4:	fb01 f106 	mul.w	r1, r1, r6
 80128f8:	e66b      	b.n	80125d2 <cblas_cgemv+0x206>
 80128fa:	bf00      	nop

080128fc <cblas_cgerc>:

void
cblas_cgerc (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 80128fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012900:	b083      	sub	sp, #12
 8012902:	469b      	mov	fp, r3
 */

{
  INDEX i, j;

  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012904:	f1b1 0900 	subs.w	r9, r1, #0
 8012908:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801290a:	9300      	str	r3, [sp, #0]
 801290c:	e9dd 460f 	ldrd	r4, r6, [sp, #60]	; 0x3c
 8012910:	e9dd 530d 	ldrd	r5, r3, [sp, #52]	; 0x34
 8012914:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8012916:	4682      	mov	sl, r0
 8012918:	4690      	mov	r8, r2
 801291a:	f2c0 80bb 	blt.w	8012a94 <cblas_cgerc+0x198>
 801291e:	3865      	subs	r0, #101	; 0x65
 8012920:	2801      	cmp	r0, #1
 8012922:	bf94      	ite	ls
 8012924:	2000      	movls	r0, #0
 8012926:	2001      	movhi	r0, #1
 8012928:	f1b8 0f00 	cmp.w	r8, #0
 801292c:	bfb8      	it	lt
 801292e:	2003      	movlt	r0, #3
 8012930:	2d00      	cmp	r5, #0
 8012932:	f040 8092 	bne.w	8012a5a <cblas_cgerc+0x15e>
 8012936:	2c00      	cmp	r4, #0
 8012938:	d16e      	bne.n	8012a18 <cblas_cgerc+0x11c>
 801293a:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801293e:	f000 80ab 	beq.w	8012a98 <cblas_cgerc+0x19c>
 8012942:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012946:	f040 810f 	bne.w	8012b68 <cblas_cgerc+0x26c>
 801294a:	464a      	mov	r2, r9
 801294c:	2a01      	cmp	r2, #1
 801294e:	bfb8      	it	lt
 8012950:	2201      	movlt	r2, #1
 8012952:	4297      	cmp	r7, r2
 8012954:	db6f      	blt.n	8012a36 <cblas_cgerc+0x13a>
 8012956:	2008      	movs	r0, #8
 8012958:	4a9f      	ldr	r2, [pc, #636]	; (8012bd8 <cblas_cgerc+0x2dc>)
 801295a:	49a0      	ldr	r1, [pc, #640]	; (8012bdc <cblas_cgerc+0x2e0>)
 801295c:	9301      	str	r3, [sp, #4]
 801295e:	f015 f873 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8012962:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012966:	ed9b 4a01 	vldr	s8, [fp, #4]

    if (order == CblasRowMajor) {
 801296a:	9b01      	ldr	r3, [sp, #4]
          jy += incY;
        }
        ix += incX;
      }
    } else if (order == CblasColMajor) {
      INDEX jy = OFFSET(N, incY);
 801296c:	2c00      	cmp	r4, #0
 801296e:	dd6f      	ble.n	8012a50 <cblas_cgerc+0x154>
 8012970:	f04f 0c00 	mov.w	ip, #0
      for (j = 0; j < N; j++) {
 8012974:	f1b8 0f00 	cmp.w	r8, #0
 8012978:	dd4b      	ble.n	8012a12 <cblas_cgerc+0x116>
 801297a:	2d00      	cmp	r5, #0
 801297c:	f1c9 0a01 	rsb	sl, r9, #1
 8012980:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
 8012984:	9b00      	ldr	r3, [sp, #0]
 8012986:	fb0a fa05 	mul.w	sl, sl, r5
 801298a:	bfc8      	it	gt
 801298c:	f04f 0a00 	movgt.w	sl, #0
 8012990:	00e4      	lsls	r4, r4, #3
 8012992:	00ff      	lsls	r7, r7, #3
 8012994:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8012998:	00ed      	lsls	r5, r5, #3
 801299a:	eb06 00c9 	add.w	r0, r6, r9, lsl #3
        const BASE Y_real = CONST_REAL(Y, jy);
        const BASE Y_imag = -CONST_IMAG(Y, jy);
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
        INDEX ix = OFFSET(M, incX);
 801299e:	f04f 0e00 	mov.w	lr, #0
        const BASE Y_imag = -CONST_IMAG(Y, jy);
 80129a2:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE Y_real = CONST_REAL(Y, jy);
 80129a6:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 80129aa:	ee65 4a04 	vmul.f32	s9, s10, s8
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 80129ae:	ee25 5a63 	vnmul.f32	s10, s10, s7
        for (i = 0; i < M; i++) {
 80129b2:	f1b9 0f00 	cmp.w	r9, #0
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 80129b6:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 80129ba:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (i = 0; i < M; i++) {
 80129be:	dd21      	ble.n	8012a04 <cblas_cgerc+0x108>
 80129c0:	1d31      	adds	r1, r6, #4
 80129c2:	4633      	mov	r3, r6
 80129c4:	4652      	mov	r2, sl
          const BASE X_real = CONST_REAL(X, ix);
          const BASE X_imag = CONST_IMAG(X, ix);
 80129c6:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE X_real = CONST_REAL(X, ix);
 80129ca:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 80129ce:	ed51 6a01 	vldr	s13, [r1, #-4]
 80129d2:	ee27 6a45 	vnmul.f32	s12, s14, s10
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 80129d6:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 80129da:	eea4 6aa5 	vfma.f32	s12, s9, s11
 80129de:	3308      	adds	r3, #8
 80129e0:	442a      	add	r2, r5
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 80129e2:	eee4 7a87 	vfma.f32	s15, s9, s14
 80129e6:	3108      	adds	r1, #8
 80129e8:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 80129ec:	ee76 7a86 	vadd.f32	s15, s13, s12
 80129f0:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 80129f4:	ed53 7a01 	vldr	s15, [r3, #-4]
 80129f8:	ee77 7a87 	vadd.f32	s15, s15, s14
 80129fc:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (i = 0; i < M; i++) {
 8012a00:	4298      	cmp	r0, r3
 8012a02:	d1e0      	bne.n	80129c6 <cblas_cgerc+0xca>
      for (j = 0; j < N; j++) {
 8012a04:	f10e 0e01 	add.w	lr, lr, #1
 8012a08:	45f0      	cmp	r8, lr
 8012a0a:	44a4      	add	ip, r4
 8012a0c:	443e      	add	r6, r7
 8012a0e:	4438      	add	r0, r7
 8012a10:	d1c7      	bne.n	80129a2 <cblas_cgerc+0xa6>
#define BASE float
#include "source_gerc.h"
#undef BASE
}
 8012a12:	b003      	add	sp, #12
 8012a14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012a18:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8012a1c:	f000 80b0 	beq.w	8012b80 <cblas_cgerc+0x284>
 8012a20:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012a24:	f040 80c7 	bne.w	8012bb6 <cblas_cgerc+0x2ba>
 8012a28:	464a      	mov	r2, r9
 8012a2a:	2a01      	cmp	r2, #1
 8012a2c:	bfb8      	it	lt
 8012a2e:	2201      	movlt	r2, #1
 8012a30:	4297      	cmp	r7, r2
 8012a32:	f280 80c2 	bge.w	8012bba <cblas_cgerc+0x2be>
 8012a36:	4a68      	ldr	r2, [pc, #416]	; (8012bd8 <cblas_cgerc+0x2dc>)
 8012a38:	4968      	ldr	r1, [pc, #416]	; (8012bdc <cblas_cgerc+0x2e0>)
 8012a3a:	9301      	str	r3, [sp, #4]
 8012a3c:	200a      	movs	r0, #10
 8012a3e:	f015 f803 	bl	8027a48 <cblas_xerbla>
      INDEX jy = OFFSET(N, incY);
 8012a42:	2c00      	cmp	r4, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 8012a44:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012a48:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012a4c:	9b01      	ldr	r3, [sp, #4]
      INDEX jy = OFFSET(N, incY);
 8012a4e:	dc8f      	bgt.n	8012970 <cblas_cgerc+0x74>
 8012a50:	f1c8 0c01 	rsb	ip, r8, #1
 8012a54:	fb0c fc04 	mul.w	ip, ip, r4
 8012a58:	e78c      	b.n	8012974 <cblas_cgerc+0x78>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012a5a:	2c00      	cmp	r4, #0
 8012a5c:	f43f af6d 	beq.w	801293a <cblas_cgerc+0x3e>
 8012a60:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8012a64:	f000 8095 	beq.w	8012b92 <cblas_cgerc+0x296>
 8012a68:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012a6c:	f000 80a9 	beq.w	8012bc2 <cblas_cgerc+0x2c6>
 8012a70:	2800      	cmp	r0, #0
 8012a72:	d17a      	bne.n	8012b6a <cblas_cgerc+0x26e>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012a74:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012a78:	ed9b 4a01 	vldr	s8, [fp, #4]
    } else if (order == CblasColMajor) {
 8012a7c:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012a80:	f43f af74 	beq.w	801296c <cblas_cgerc+0x70>
          ix += incX;
        }
        jy += incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 8012a84:	4a56      	ldr	r2, [pc, #344]	; (8012be0 <cblas_cgerc+0x2e4>)
 8012a86:	4955      	ldr	r1, [pc, #340]	; (8012bdc <cblas_cgerc+0x2e0>)
 8012a88:	2000      	movs	r0, #0
 8012a8a:	b003      	add	sp, #12
 8012a8c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012a90:	f014 bfda 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012a94:	2002      	movs	r0, #2
 8012a96:	e747      	b.n	8012928 <cblas_cgerc+0x2c>
 8012a98:	4640      	mov	r0, r8
 8012a9a:	2801      	cmp	r0, #1
 8012a9c:	bfb8      	it	lt
 8012a9e:	2001      	movlt	r0, #1
 8012aa0:	4287      	cmp	r7, r0
 8012aa2:	bfac      	ite	ge
 8012aa4:	2008      	movge	r0, #8
 8012aa6:	200a      	movlt	r0, #10
 8012aa8:	4a4b      	ldr	r2, [pc, #300]	; (8012bd8 <cblas_cgerc+0x2dc>)
 8012aaa:	494c      	ldr	r1, [pc, #304]	; (8012bdc <cblas_cgerc+0x2e0>)
 8012aac:	9301      	str	r3, [sp, #4]
 8012aae:	f014 ffcb 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012ab2:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012ab6:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012aba:	9b01      	ldr	r3, [sp, #4]
      INDEX ix = OFFSET(M, incX);
 8012abc:	2d00      	cmp	r5, #0
 8012abe:	dd75      	ble.n	8012bac <cblas_cgerc+0x2b0>
 8012ac0:	f04f 0c00 	mov.w	ip, #0
      for (i = 0; i < M; i++) {
 8012ac4:	f1b9 0f00 	cmp.w	r9, #0
 8012ac8:	dda3      	ble.n	8012a12 <cblas_cgerc+0x116>
 8012aca:	2c00      	cmp	r4, #0
 8012acc:	9a00      	ldr	r2, [sp, #0]
 8012ace:	f1c8 0a01 	rsb	sl, r8, #1
 8012ad2:	fb0a fa04 	mul.w	sl, sl, r4
 8012ad6:	bfc8      	it	gt
 8012ad8:	f04f 0a00 	movgt.w	sl, #0
 8012adc:	00ed      	lsls	r5, r5, #3
 8012ade:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
 8012ae2:	00ff      	lsls	r7, r7, #3
 8012ae4:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8012ae8:	00e4      	lsls	r4, r4, #3
 8012aea:	eb06 00c8 	add.w	r0, r6, r8, lsl #3
        INDEX jy = OFFSET(N, incY);
 8012aee:	f04f 0e00 	mov.w	lr, #0
        const BASE X_imag = CONST_IMAG(X, ix);
 8012af2:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE X_real = CONST_REAL(X, ix);
 8012af6:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 8012afa:	ee64 4a45 	vnmul.f32	s9, s8, s10
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 8012afe:	ee25 5a23 	vmul.f32	s10, s10, s7
        for (j = 0; j < N; j++) {
 8012b02:	f1b8 0f00 	cmp.w	r8, #0
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 8012b06:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 8012b0a:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (j = 0; j < N; j++) {
 8012b0e:	dd21      	ble.n	8012b54 <cblas_cgerc+0x258>
 8012b10:	1d31      	adds	r1, r6, #4
 8012b12:	4633      	mov	r3, r6
 8012b14:	4652      	mov	r2, sl
          const BASE Y_imag = -CONST_IMAG(Y, jy);
 8012b16:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE Y_real = CONST_REAL(Y, jy);
 8012b1a:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8012b1e:	ed51 6a01 	vldr	s13, [r1, #-4]
 8012b22:	ee27 6a05 	vmul.f32	s12, s14, s10
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8012b26:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8012b2a:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8012b2e:	3308      	adds	r3, #8
 8012b30:	4422      	add	r2, r4
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8012b32:	eee7 7a64 	vfms.f32	s15, s14, s9
 8012b36:	3108      	adds	r1, #8
 8012b38:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8012b3c:	ee76 7a86 	vadd.f32	s15, s13, s12
 8012b40:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8012b44:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012b48:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012b4c:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < N; j++) {
 8012b50:	4298      	cmp	r0, r3
 8012b52:	d1e0      	bne.n	8012b16 <cblas_cgerc+0x21a>
      for (i = 0; i < M; i++) {
 8012b54:	f10e 0e01 	add.w	lr, lr, #1
 8012b58:	45f1      	cmp	r9, lr
 8012b5a:	44ac      	add	ip, r5
 8012b5c:	443e      	add	r6, r7
 8012b5e:	4438      	add	r0, r7
 8012b60:	d1c7      	bne.n	8012af2 <cblas_cgerc+0x1f6>
 8012b62:	b003      	add	sp, #12
 8012b64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012b68:	2008      	movs	r0, #8
 8012b6a:	4a1b      	ldr	r2, [pc, #108]	; (8012bd8 <cblas_cgerc+0x2dc>)
 8012b6c:	491b      	ldr	r1, [pc, #108]	; (8012bdc <cblas_cgerc+0x2e0>)
 8012b6e:	9301      	str	r3, [sp, #4]
 8012b70:	f014 ff6a 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012b74:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012b78:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012b7c:	9b01      	ldr	r3, [sp, #4]
 8012b7e:	e77d      	b.n	8012a7c <cblas_cgerc+0x180>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012b80:	4640      	mov	r0, r8
 8012b82:	2801      	cmp	r0, #1
 8012b84:	bfb8      	it	lt
 8012b86:	2001      	movlt	r0, #1
 8012b88:	42b8      	cmp	r0, r7
 8012b8a:	bfcc      	ite	gt
 8012b8c:	200a      	movgt	r0, #10
 8012b8e:	2006      	movle	r0, #6
 8012b90:	e78a      	b.n	8012aa8 <cblas_cgerc+0x1ac>
 8012b92:	4642      	mov	r2, r8
 8012b94:	2a01      	cmp	r2, #1
 8012b96:	bfb8      	it	lt
 8012b98:	2201      	movlt	r2, #1
 8012b9a:	42ba      	cmp	r2, r7
 8012b9c:	dc0f      	bgt.n	8012bbe <cblas_cgerc+0x2c2>
 8012b9e:	2800      	cmp	r0, #0
 8012ba0:	d182      	bne.n	8012aa8 <cblas_cgerc+0x1ac>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012ba2:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012ba6:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012baa:	e787      	b.n	8012abc <cblas_cgerc+0x1c0>
      INDEX ix = OFFSET(M, incX);
 8012bac:	f1c9 0c01 	rsb	ip, r9, #1
 8012bb0:	fb0c fc05 	mul.w	ip, ip, r5
 8012bb4:	e786      	b.n	8012ac4 <cblas_cgerc+0x1c8>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012bb6:	2006      	movs	r0, #6
 8012bb8:	e7d7      	b.n	8012b6a <cblas_cgerc+0x26e>
 8012bba:	2006      	movs	r0, #6
 8012bbc:	e6cc      	b.n	8012958 <cblas_cgerc+0x5c>
 8012bbe:	200a      	movs	r0, #10
 8012bc0:	e772      	b.n	8012aa8 <cblas_cgerc+0x1ac>
 8012bc2:	464a      	mov	r2, r9
 8012bc4:	2a01      	cmp	r2, #1
 8012bc6:	bfb8      	it	lt
 8012bc8:	2201      	movlt	r2, #1
 8012bca:	42ba      	cmp	r2, r7
 8012bcc:	f73f af33 	bgt.w	8012a36 <cblas_cgerc+0x13a>
 8012bd0:	2800      	cmp	r0, #0
 8012bd2:	f43f af4f 	beq.w	8012a74 <cblas_cgerc+0x178>
 8012bd6:	e6bf      	b.n	8012958 <cblas_cgerc+0x5c>
 8012bd8:	08030378 	.word	0x08030378
 8012bdc:	080306d0 	.word	0x080306d0
 8012be0:	080305a8 	.word	0x080305a8

08012be4 <cblas_cgeru>:

void
cblas_cgeru (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 8012be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012be8:	b083      	sub	sp, #12
 8012bea:	469b      	mov	fp, r3
 */

{
  INDEX i, j;

  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012bec:	f1b1 0900 	subs.w	r9, r1, #0
 8012bf0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8012bf2:	9300      	str	r3, [sp, #0]
 8012bf4:	e9dd 460f 	ldrd	r4, r6, [sp, #60]	; 0x3c
 8012bf8:	e9dd 530d 	ldrd	r5, r3, [sp, #52]	; 0x34
 8012bfc:	9f11      	ldr	r7, [sp, #68]	; 0x44
 8012bfe:	4682      	mov	sl, r0
 8012c00:	4690      	mov	r8, r2
 8012c02:	f2c0 80bb 	blt.w	8012d7c <cblas_cgeru+0x198>
 8012c06:	3865      	subs	r0, #101	; 0x65
 8012c08:	2801      	cmp	r0, #1
 8012c0a:	bf94      	ite	ls
 8012c0c:	2000      	movls	r0, #0
 8012c0e:	2001      	movhi	r0, #1
 8012c10:	f1b8 0f00 	cmp.w	r8, #0
 8012c14:	bfb8      	it	lt
 8012c16:	2003      	movlt	r0, #3
 8012c18:	2d00      	cmp	r5, #0
 8012c1a:	f040 8092 	bne.w	8012d42 <cblas_cgeru+0x15e>
 8012c1e:	2c00      	cmp	r4, #0
 8012c20:	d16e      	bne.n	8012d00 <cblas_cgeru+0x11c>
 8012c22:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8012c26:	f000 80ab 	beq.w	8012d80 <cblas_cgeru+0x19c>
 8012c2a:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012c2e:	f040 810f 	bne.w	8012e50 <cblas_cgeru+0x26c>
 8012c32:	464a      	mov	r2, r9
 8012c34:	2a01      	cmp	r2, #1
 8012c36:	bfb8      	it	lt
 8012c38:	2201      	movlt	r2, #1
 8012c3a:	4297      	cmp	r7, r2
 8012c3c:	db6f      	blt.n	8012d1e <cblas_cgeru+0x13a>
 8012c3e:	2008      	movs	r0, #8
 8012c40:	4a9f      	ldr	r2, [pc, #636]	; (8012ec0 <cblas_cgeru+0x2dc>)
 8012c42:	49a0      	ldr	r1, [pc, #640]	; (8012ec4 <cblas_cgeru+0x2e0>)
 8012c44:	9301      	str	r3, [sp, #4]
 8012c46:	f014 feff 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8012c4a:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012c4e:	ed9b 4a01 	vldr	s8, [fp, #4]

    if (order == CblasRowMajor) {
 8012c52:	9b01      	ldr	r3, [sp, #4]
          jy += incY;
        }
        ix += incX;
      }
    } else if (order == CblasColMajor) {
      INDEX jy = OFFSET(N, incY);
 8012c54:	2c00      	cmp	r4, #0
 8012c56:	dd6f      	ble.n	8012d38 <cblas_cgeru+0x154>
 8012c58:	f04f 0c00 	mov.w	ip, #0
      for (j = 0; j < N; j++) {
 8012c5c:	f1b8 0f00 	cmp.w	r8, #0
 8012c60:	dd4b      	ble.n	8012cfa <cblas_cgeru+0x116>
 8012c62:	2d00      	cmp	r5, #0
 8012c64:	f1c9 0a01 	rsb	sl, r9, #1
 8012c68:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
 8012c6c:	9b00      	ldr	r3, [sp, #0]
 8012c6e:	fb0a fa05 	mul.w	sl, sl, r5
 8012c72:	bfc8      	it	gt
 8012c74:	f04f 0a00 	movgt.w	sl, #0
 8012c78:	00e4      	lsls	r4, r4, #3
 8012c7a:	00ff      	lsls	r7, r7, #3
 8012c7c:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8012c80:	00ed      	lsls	r5, r5, #3
 8012c82:	eb06 00c9 	add.w	r0, r6, r9, lsl #3
        const BASE Y_real = CONST_REAL(Y, jy);
        const BASE Y_imag = CONST_IMAG(Y, jy);
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
        INDEX ix = OFFSET(M, incX);
 8012c86:	f04f 0e00 	mov.w	lr, #0
        const BASE Y_imag = CONST_IMAG(Y, jy);
 8012c8a:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE Y_real = CONST_REAL(Y, jy);
 8012c8e:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 8012c92:	ee64 4a45 	vnmul.f32	s9, s8, s10
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 8012c96:	ee25 5a23 	vmul.f32	s10, s10, s7
        for (i = 0; i < M; i++) {
 8012c9a:	f1b9 0f00 	cmp.w	r9, #0
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 8012c9e:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 8012ca2:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (i = 0; i < M; i++) {
 8012ca6:	dd21      	ble.n	8012cec <cblas_cgeru+0x108>
 8012ca8:	1d31      	adds	r1, r6, #4
 8012caa:	4633      	mov	r3, r6
 8012cac:	4652      	mov	r2, sl
          const BASE X_real = CONST_REAL(X, ix);
          const BASE X_imag = CONST_IMAG(X, ix);
 8012cae:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE X_real = CONST_REAL(X, ix);
 8012cb2:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 8012cb6:	ed51 6a01 	vldr	s13, [r1, #-4]
 8012cba:	ee27 6a45 	vnmul.f32	s12, s14, s10
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 8012cbe:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 8012cc2:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8012cc6:	3308      	adds	r3, #8
 8012cc8:	442a      	add	r2, r5
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 8012cca:	eee4 7a87 	vfma.f32	s15, s9, s14
 8012cce:	3108      	adds	r1, #8
 8012cd0:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 8012cd4:	ee76 7a86 	vadd.f32	s15, s13, s12
 8012cd8:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 8012cdc:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012ce0:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012ce4:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (i = 0; i < M; i++) {
 8012ce8:	4298      	cmp	r0, r3
 8012cea:	d1e0      	bne.n	8012cae <cblas_cgeru+0xca>
      for (j = 0; j < N; j++) {
 8012cec:	f10e 0e01 	add.w	lr, lr, #1
 8012cf0:	45f0      	cmp	r8, lr
 8012cf2:	44a4      	add	ip, r4
 8012cf4:	443e      	add	r6, r7
 8012cf6:	4438      	add	r0, r7
 8012cf8:	d1c7      	bne.n	8012c8a <cblas_cgeru+0xa6>
#define BASE float
#include "source_geru.h"
#undef BASE
}
 8012cfa:	b003      	add	sp, #12
 8012cfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012d00:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8012d04:	f000 80b0 	beq.w	8012e68 <cblas_cgeru+0x284>
 8012d08:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012d0c:	f040 80c7 	bne.w	8012e9e <cblas_cgeru+0x2ba>
 8012d10:	464a      	mov	r2, r9
 8012d12:	2a01      	cmp	r2, #1
 8012d14:	bfb8      	it	lt
 8012d16:	2201      	movlt	r2, #1
 8012d18:	4297      	cmp	r7, r2
 8012d1a:	f280 80c2 	bge.w	8012ea2 <cblas_cgeru+0x2be>
 8012d1e:	4a68      	ldr	r2, [pc, #416]	; (8012ec0 <cblas_cgeru+0x2dc>)
 8012d20:	4968      	ldr	r1, [pc, #416]	; (8012ec4 <cblas_cgeru+0x2e0>)
 8012d22:	9301      	str	r3, [sp, #4]
 8012d24:	200a      	movs	r0, #10
 8012d26:	f014 fe8f 	bl	8027a48 <cblas_xerbla>
      INDEX jy = OFFSET(N, incY);
 8012d2a:	2c00      	cmp	r4, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 8012d2c:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012d30:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012d34:	9b01      	ldr	r3, [sp, #4]
      INDEX jy = OFFSET(N, incY);
 8012d36:	dc8f      	bgt.n	8012c58 <cblas_cgeru+0x74>
 8012d38:	f1c8 0c01 	rsb	ip, r8, #1
 8012d3c:	fb0c fc04 	mul.w	ip, ip, r4
 8012d40:	e78c      	b.n	8012c5c <cblas_cgeru+0x78>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012d42:	2c00      	cmp	r4, #0
 8012d44:	f43f af6d 	beq.w	8012c22 <cblas_cgeru+0x3e>
 8012d48:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 8012d4c:	f000 8095 	beq.w	8012e7a <cblas_cgeru+0x296>
 8012d50:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012d54:	f000 80a9 	beq.w	8012eaa <cblas_cgeru+0x2c6>
 8012d58:	2800      	cmp	r0, #0
 8012d5a:	d17a      	bne.n	8012e52 <cblas_cgeru+0x26e>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012d5c:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012d60:	ed9b 4a01 	vldr	s8, [fp, #4]
    } else if (order == CblasColMajor) {
 8012d64:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8012d68:	f43f af74 	beq.w	8012c54 <cblas_cgeru+0x70>
          ix += incX;
        }
        jy += incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 8012d6c:	4a56      	ldr	r2, [pc, #344]	; (8012ec8 <cblas_cgeru+0x2e4>)
 8012d6e:	4955      	ldr	r1, [pc, #340]	; (8012ec4 <cblas_cgeru+0x2e0>)
 8012d70:	2000      	movs	r0, #0
 8012d72:	b003      	add	sp, #12
 8012d74:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012d78:	f014 be66 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012d7c:	2002      	movs	r0, #2
 8012d7e:	e747      	b.n	8012c10 <cblas_cgeru+0x2c>
 8012d80:	4640      	mov	r0, r8
 8012d82:	2801      	cmp	r0, #1
 8012d84:	bfb8      	it	lt
 8012d86:	2001      	movlt	r0, #1
 8012d88:	4287      	cmp	r7, r0
 8012d8a:	bfac      	ite	ge
 8012d8c:	2008      	movge	r0, #8
 8012d8e:	200a      	movlt	r0, #10
 8012d90:	4a4b      	ldr	r2, [pc, #300]	; (8012ec0 <cblas_cgeru+0x2dc>)
 8012d92:	494c      	ldr	r1, [pc, #304]	; (8012ec4 <cblas_cgeru+0x2e0>)
 8012d94:	9301      	str	r3, [sp, #4]
 8012d96:	f014 fe57 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012d9a:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012d9e:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012da2:	9b01      	ldr	r3, [sp, #4]
      INDEX ix = OFFSET(M, incX);
 8012da4:	2d00      	cmp	r5, #0
 8012da6:	dd75      	ble.n	8012e94 <cblas_cgeru+0x2b0>
 8012da8:	f04f 0c00 	mov.w	ip, #0
      for (i = 0; i < M; i++) {
 8012dac:	f1b9 0f00 	cmp.w	r9, #0
 8012db0:	dda3      	ble.n	8012cfa <cblas_cgeru+0x116>
 8012db2:	2c00      	cmp	r4, #0
 8012db4:	9a00      	ldr	r2, [sp, #0]
 8012db6:	f1c8 0a01 	rsb	sl, r8, #1
 8012dba:	fb0a fa04 	mul.w	sl, sl, r4
 8012dbe:	bfc8      	it	gt
 8012dc0:	f04f 0a00 	movgt.w	sl, #0
 8012dc4:	00ed      	lsls	r5, r5, #3
 8012dc6:	eb02 0ccc 	add.w	ip, r2, ip, lsl #3
 8012dca:	00ff      	lsls	r7, r7, #3
 8012dcc:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8012dd0:	00e4      	lsls	r4, r4, #3
 8012dd2:	eb06 00c8 	add.w	r0, r6, r8, lsl #3
        INDEX jy = OFFSET(N, incY);
 8012dd6:	f04f 0e00 	mov.w	lr, #0
        const BASE X_imag = CONST_IMAG(X, ix);
 8012dda:	ed9c 5a01 	vldr	s10, [ip, #4]
        const BASE X_real = CONST_REAL(X, ix);
 8012dde:	eddc 7a00 	vldr	s15, [ip]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 8012de2:	ee64 4a45 	vnmul.f32	s9, s8, s10
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 8012de6:	ee25 5a23 	vmul.f32	s10, s10, s7
        for (j = 0; j < N; j++) {
 8012dea:	f1b8 0f00 	cmp.w	r8, #0
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 8012dee:	eee7 4aa3 	vfma.f32	s9, s15, s7
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 8012df2:	eea7 5a84 	vfma.f32	s10, s15, s8
        for (j = 0; j < N; j++) {
 8012df6:	dd21      	ble.n	8012e3c <cblas_cgeru+0x258>
 8012df8:	1d31      	adds	r1, r6, #4
 8012dfa:	4633      	mov	r3, r6
 8012dfc:	4652      	mov	r2, sl
          const BASE Y_imag = CONST_IMAG(Y, jy);
 8012dfe:	ed92 7a01 	vldr	s14, [r2, #4]
          const BASE Y_real = CONST_REAL(Y, jy);
 8012e02:	edd2 5a00 	vldr	s11, [r2]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8012e06:	ed51 6a01 	vldr	s13, [r1, #-4]
 8012e0a:	ee27 6a45 	vnmul.f32	s12, s14, s10
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8012e0e:	ee65 7a25 	vmul.f32	s15, s10, s11
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8012e12:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8012e16:	3308      	adds	r3, #8
 8012e18:	4422      	add	r2, r4
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8012e1a:	eee4 7a87 	vfma.f32	s15, s9, s14
 8012e1e:	3108      	adds	r1, #8
 8012e20:	eeb0 7a67 	vmov.f32	s14, s15
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 8012e24:	ee76 7a86 	vadd.f32	s15, s13, s12
 8012e28:	ed41 7a03 	vstr	s15, [r1, #-12]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 8012e2c:	ed53 7a01 	vldr	s15, [r3, #-4]
 8012e30:	ee77 7a87 	vadd.f32	s15, s15, s14
 8012e34:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < N; j++) {
 8012e38:	4298      	cmp	r0, r3
 8012e3a:	d1e0      	bne.n	8012dfe <cblas_cgeru+0x21a>
      for (i = 0; i < M; i++) {
 8012e3c:	f10e 0e01 	add.w	lr, lr, #1
 8012e40:	45f1      	cmp	r9, lr
 8012e42:	44ac      	add	ip, r5
 8012e44:	443e      	add	r6, r7
 8012e46:	4438      	add	r0, r7
 8012e48:	d1c7      	bne.n	8012dda <cblas_cgeru+0x1f6>
 8012e4a:	b003      	add	sp, #12
 8012e4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012e50:	2008      	movs	r0, #8
 8012e52:	4a1b      	ldr	r2, [pc, #108]	; (8012ec0 <cblas_cgeru+0x2dc>)
 8012e54:	491b      	ldr	r1, [pc, #108]	; (8012ec4 <cblas_cgeru+0x2e0>)
 8012e56:	9301      	str	r3, [sp, #4]
 8012e58:	f014 fdf6 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012e5c:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012e60:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012e64:	9b01      	ldr	r3, [sp, #4]
 8012e66:	e77d      	b.n	8012d64 <cblas_cgeru+0x180>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012e68:	4640      	mov	r0, r8
 8012e6a:	2801      	cmp	r0, #1
 8012e6c:	bfb8      	it	lt
 8012e6e:	2001      	movlt	r0, #1
 8012e70:	42b8      	cmp	r0, r7
 8012e72:	bfcc      	ite	gt
 8012e74:	200a      	movgt	r0, #10
 8012e76:	2006      	movle	r0, #6
 8012e78:	e78a      	b.n	8012d90 <cblas_cgeru+0x1ac>
 8012e7a:	4642      	mov	r2, r8
 8012e7c:	2a01      	cmp	r2, #1
 8012e7e:	bfb8      	it	lt
 8012e80:	2201      	movlt	r2, #1
 8012e82:	42ba      	cmp	r2, r7
 8012e84:	dc0f      	bgt.n	8012ea6 <cblas_cgeru+0x2c2>
 8012e86:	2800      	cmp	r0, #0
 8012e88:	d182      	bne.n	8012d90 <cblas_cgeru+0x1ac>
    const BASE alpha_real = CONST_REAL0(alpha);
 8012e8a:	eddb 3a00 	vldr	s7, [fp]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012e8e:	ed9b 4a01 	vldr	s8, [fp, #4]
    if (order == CblasRowMajor) {
 8012e92:	e787      	b.n	8012da4 <cblas_cgeru+0x1c0>
      INDEX ix = OFFSET(M, incX);
 8012e94:	f1c9 0c01 	rsb	ip, r9, #1
 8012e98:	fb0c fc05 	mul.w	ip, ip, r5
 8012e9c:	e786      	b.n	8012dac <cblas_cgeru+0x1c8>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 8012e9e:	2006      	movs	r0, #6
 8012ea0:	e7d7      	b.n	8012e52 <cblas_cgeru+0x26e>
 8012ea2:	2006      	movs	r0, #6
 8012ea4:	e6cc      	b.n	8012c40 <cblas_cgeru+0x5c>
 8012ea6:	200a      	movs	r0, #10
 8012ea8:	e772      	b.n	8012d90 <cblas_cgeru+0x1ac>
 8012eaa:	464a      	mov	r2, r9
 8012eac:	2a01      	cmp	r2, #1
 8012eae:	bfb8      	it	lt
 8012eb0:	2201      	movlt	r2, #1
 8012eb2:	42ba      	cmp	r2, r7
 8012eb4:	f73f af33 	bgt.w	8012d1e <cblas_cgeru+0x13a>
 8012eb8:	2800      	cmp	r0, #0
 8012eba:	f43f af4f 	beq.w	8012d5c <cblas_cgeru+0x178>
 8012ebe:	e6bf      	b.n	8012c40 <cblas_cgeru+0x5c>
 8012ec0:	08030378 	.word	0x08030378
 8012ec4:	080306e0 	.word	0x080306e0
 8012ec8:	080305a8 	.word	0x080305a8

08012ecc <cblas_chemm>:
void
cblas_chemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 8012ecc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012ed0:	b08d      	sub	sp, #52	; 0x34
 8012ed2:	4698      	mov	r8, r3
 8012ed4:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8012ed6:	9300      	str	r3, [sp, #0]
 8012ed8:	e9dd 7317 	ldrd	r7, r3, [sp, #92]	; 0x5c
 8012edc:	9302      	str	r3, [sp, #8]
 8012ede:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8012ee0:	9301      	str	r3, [sp, #4]
 8012ee2:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8012ee4:	9303      	str	r3, [sp, #12]
 8012ee6:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8012ee8:	9305      	str	r3, [sp, #20]
{
  INDEX i, j, k;
  INDEX n1, n2;
  int uplo, side;

  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8012eea:	298d      	cmp	r1, #141	; 0x8d
 8012eec:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8012eee:	9304      	str	r3, [sp, #16]
 8012ef0:	e9dd 9b1c 	ldrd	r9, fp, [sp, #112]	; 0x70
 8012ef4:	460c      	mov	r4, r1
 8012ef6:	4606      	mov	r6, r0
 8012ef8:	4615      	mov	r5, r2
 8012efa:	f000 80da 	beq.w	80130b2 <cblas_chemm+0x1e6>
 8012efe:	298e      	cmp	r1, #142	; 0x8e
 8012f00:	f000 8419 	beq.w	8013736 <cblas_chemm+0x86a>
 8012f04:	9b00      	ldr	r3, [sp, #0]
 8012f06:	2002      	movs	r0, #2
 8012f08:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 8012f0c:	2a01      	cmp	r2, #1
 8012f0e:	bf88      	it	hi
 8012f10:	2003      	movhi	r0, #3
 8012f12:	9a00      	ldr	r2, [sp, #0]
 8012f14:	f1b8 0f00 	cmp.w	r8, #0
 8012f18:	bfb8      	it	lt
 8012f1a:	2004      	movlt	r0, #4
 8012f1c:	2b01      	cmp	r3, #1
 8012f1e:	bfb8      	it	lt
 8012f20:	2301      	movlt	r3, #1
 8012f22:	2a00      	cmp	r2, #0
 8012f24:	9a01      	ldr	r2, [sp, #4]
 8012f26:	f2c0 80b9 	blt.w	801309c <cblas_chemm+0x1d0>
 8012f2a:	4293      	cmp	r3, r2
 8012f2c:	dd6a      	ble.n	8013004 <cblas_chemm+0x138>
 8012f2e:	2e65      	cmp	r6, #101	; 0x65
 8012f30:	f000 8232 	beq.w	8013398 <cblas_chemm+0x4cc>
 8012f34:	2e66      	cmp	r6, #102	; 0x66
 8012f36:	f000 83f1 	beq.w	801371c <cblas_chemm+0x850>
 8012f3a:	2008      	movs	r0, #8
 8012f3c:	4abd      	ldr	r2, [pc, #756]	; (8013234 <cblas_chemm+0x368>)
 8012f3e:	49be      	ldr	r1, [pc, #760]	; (8013238 <cblas_chemm+0x36c>)
 8012f40:	f014 fd82 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8012f44:	edd7 4a00 	vldr	s9, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8012f48:	ed97 4a01 	vldr	s8, [r7, #4]

    const BASE beta_real = CONST_REAL0(beta);
 8012f4c:	edd9 5a00 	vldr	s11, [r9]
    const BASE beta_imag = CONST_IMAG0(beta);
 8012f50:	ed99 5a01 	vldr	s10, [r9, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8012f54:	eef5 4a40 	vcmp.f32	s9, #0.0
 8012f58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f5c:	d10b      	bne.n	8012f76 <cblas_chemm+0xaa>
 8012f5e:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8012f62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f66:	d106      	bne.n	8012f76 <cblas_chemm+0xaa>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8012f68:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8012f6c:	eef4 5a67 	vcmp.f32	s11, s15
 8012f70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f74:	d04f      	beq.n	8013016 <cblas_chemm+0x14a>
      return;

    if (Order == CblasRowMajor) {
 8012f76:	2e65      	cmp	r6, #101	; 0x65
 8012f78:	f000 80a2 	beq.w	80130c0 <cblas_chemm+0x1f4>
      uplo = Uplo;
      side = Side;
    } else {
      n1 = N;
      n2 = M;
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8012f7c:	2d79      	cmp	r5, #121	; 0x79
 8012f7e:	bf0c      	ite	eq
 8012f80:	257a      	moveq	r5, #122	; 0x7a
 8012f82:	2579      	movne	r5, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8012f84:	2c8d      	cmp	r4, #141	; 0x8d
 8012f86:	bf0c      	ite	eq
 8012f88:	248e      	moveq	r4, #142	; 0x8e
 8012f8a:	248d      	movne	r4, #141	; 0x8d
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8012f8c:	eef5 5a40 	vcmp.f32	s11, #0.0
 8012f90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f94:	d147      	bne.n	8013026 <cblas_chemm+0x15a>
 8012f96:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8012f9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012f9e:	d14e      	bne.n	801303e <cblas_chemm+0x172>
      for (i = 0; i < n1; i++) {
 8012fa0:	9b00      	ldr	r3, [sp, #0]
 8012fa2:	2b00      	cmp	r3, #0
 8012fa4:	dd17      	ble.n	8012fd6 <cblas_chemm+0x10a>
 8012fa6:	9a04      	ldr	r2, [sp, #16]
 8012fa8:	ebc8 7048 	rsb	r0, r8, r8, lsl #29
 8012fac:	00d6      	lsls	r6, r2, #3
 8012fae:	00c0      	lsls	r0, r0, #3
 8012fb0:	eb0b 02c8 	add.w	r2, fp, r8, lsl #3
 8012fb4:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8012fb6:	2700      	movs	r7, #0
 8012fb8:	469c      	mov	ip, r3
        for (j = 0; j < n2; j++) {
 8012fba:	f1b8 0f00 	cmp.w	r8, #0
 8012fbe:	bfc8      	it	gt
 8012fc0:	1883      	addgt	r3, r0, r2
 8012fc2:	dd04      	ble.n	8012fce <cblas_chemm+0x102>
          REAL(C, ldc * i + j) = 0.0;
 8012fc4:	601f      	str	r7, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8012fc6:	605f      	str	r7, [r3, #4]
        for (j = 0; j < n2; j++) {
 8012fc8:	3308      	adds	r3, #8
 8012fca:	429a      	cmp	r2, r3
 8012fcc:	d1fa      	bne.n	8012fc4 <cblas_chemm+0xf8>
      for (i = 0; i < n1; i++) {
 8012fce:	3101      	adds	r1, #1
 8012fd0:	458c      	cmp	ip, r1
 8012fd2:	4432      	add	r2, r6
 8012fd4:	d1f1      	bne.n	8012fba <cblas_chemm+0xee>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8012fd6:	eef5 4a40 	vcmp.f32	s9, #0.0
 8012fda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012fde:	d104      	bne.n	8012fea <cblas_chemm+0x11e>
 8012fe0:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8012fe4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012fe8:	d01a      	beq.n	8013020 <cblas_chemm+0x154>
      return;

    if (side == CblasLeft && uplo == CblasUpper) {
 8012fea:	2c8d      	cmp	r4, #141	; 0x8d
 8012fec:	d06d      	beq.n	80130ca <cblas_chemm+0x1fe>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper) {
 8012fee:	2c8e      	cmp	r4, #142	; 0x8e
 8012ff0:	f000 8128 	beq.w	8013244 <cblas_chemm+0x378>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 8012ff4:	4a91      	ldr	r2, [pc, #580]	; (801323c <cblas_chemm+0x370>)
 8012ff6:	4990      	ldr	r1, [pc, #576]	; (8013238 <cblas_chemm+0x36c>)
 8012ff8:	2000      	movs	r0, #0
#define BASE float
#include "source_hemm.h"
#undef BASE
}
 8012ffa:	b00d      	add	sp, #52	; 0x34
 8012ffc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013000:	f014 bd22 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8013004:	2e65      	cmp	r6, #101	; 0x65
 8013006:	f000 81d5 	beq.w	80133b4 <cblas_chemm+0x4e8>
 801300a:	2e66      	cmp	r6, #102	; 0x66
 801300c:	f000 8355 	beq.w	80136ba <cblas_chemm+0x7ee>
 8013010:	2800      	cmp	r0, #0
 8013012:	d097      	beq.n	8012f44 <cblas_chemm+0x78>
 8013014:	e792      	b.n	8012f3c <cblas_chemm+0x70>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8013016:	eeb5 5a40 	vcmp.f32	s10, #0.0
 801301a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801301e:	d1aa      	bne.n	8012f76 <cblas_chemm+0xaa>
 8013020:	b00d      	add	sp, #52	; 0x34
 8013022:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8013026:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801302a:	eef4 5a67 	vcmp.f32	s11, s15
 801302e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013032:	d104      	bne.n	801303e <cblas_chemm+0x172>
 8013034:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8013038:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801303c:	d0cb      	beq.n	8012fd6 <cblas_chemm+0x10a>
      for (i = 0; i < n1; i++) {
 801303e:	9900      	ldr	r1, [sp, #0]
 8013040:	2900      	cmp	r1, #0
 8013042:	ddc8      	ble.n	8012fd6 <cblas_chemm+0x10a>
 8013044:	9b04      	ldr	r3, [sp, #16]
 8013046:	ebc8 7c48 	rsb	ip, r8, r8, lsl #29
 801304a:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801304e:	f10c 0904 	add.w	r9, ip, #4
 8013052:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
 8013056:	eb0b 06c8 	add.w	r6, fp, r8, lsl #3
 801305a:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 801305c:	f1b8 0f00 	cmp.w	r8, #0
 8013060:	dd17      	ble.n	8013092 <cblas_chemm+0x1c6>
 8013062:	eb0c 0306 	add.w	r3, ip, r6
 8013066:	eb09 0206 	add.w	r2, r9, r6
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 801306a:	edd3 6a01 	vldr	s13, [r3, #4]
          const BASE Cij_real = REAL(C, ldc * i + j);
 801306e:	ed12 6a01 	vldr	s12, [r2, #-4]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8013072:	ee26 7ac5 	vnmul.f32	s14, s13, s10
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8013076:	ee65 7a06 	vmul.f32	s15, s10, s12
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801307a:	eea5 7a86 	vfma.f32	s14, s11, s12
 801307e:	3308      	adds	r3, #8
 8013080:	3208      	adds	r2, #8
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8013082:	eee5 7aa6 	vfma.f32	s15, s11, s13
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8013086:	ed02 7a03 	vstr	s14, [r2, #-12]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801308a:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < n2; j++) {
 801308e:	42b3      	cmp	r3, r6
 8013090:	d1eb      	bne.n	801306a <cblas_chemm+0x19e>
      for (i = 0; i < n1; i++) {
 8013092:	3701      	adds	r7, #1
 8013094:	42b9      	cmp	r1, r7
 8013096:	4476      	add	r6, lr
 8013098:	d1e0      	bne.n	801305c <cblas_chemm+0x190>
 801309a:	e79c      	b.n	8012fd6 <cblas_chemm+0x10a>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801309c:	429a      	cmp	r2, r3
 801309e:	f6ff af46 	blt.w	8012f2e <cblas_chemm+0x62>
 80130a2:	2e65      	cmp	r6, #101	; 0x65
 80130a4:	f000 82ff 	beq.w	80136a6 <cblas_chemm+0x7da>
 80130a8:	2e66      	cmp	r6, #102	; 0x66
 80130aa:	f000 8353 	beq.w	8013754 <cblas_chemm+0x888>
 80130ae:	2005      	movs	r0, #5
 80130b0:	e744      	b.n	8012f3c <cblas_chemm+0x70>
 80130b2:	3865      	subs	r0, #101	; 0x65
 80130b4:	2801      	cmp	r0, #1
 80130b6:	bf94      	ite	ls
 80130b8:	2000      	movls	r0, #0
 80130ba:	2001      	movhi	r0, #1
 80130bc:	4643      	mov	r3, r8
 80130be:	e723      	b.n	8012f08 <cblas_chemm+0x3c>
      uplo = Uplo;
 80130c0:	9b00      	ldr	r3, [sp, #0]
      side = Side;
 80130c2:	f8cd 8000 	str.w	r8, [sp]
 80130c6:	4698      	mov	r8, r3
 80130c8:	e760      	b.n	8012f8c <cblas_chemm+0xc0>
    if (side == CblasLeft && uplo == CblasUpper) {
 80130ca:	2d79      	cmp	r5, #121	; 0x79
 80130cc:	f000 8180 	beq.w	80133d0 <cblas_chemm+0x504>
    } else if (side == CblasLeft && uplo == CblasLower) {
 80130d0:	2d7a      	cmp	r5, #122	; 0x7a
 80130d2:	d18f      	bne.n	8012ff4 <cblas_chemm+0x128>
      for (i = 0; i < n1; i++) {
 80130d4:	9b00      	ldr	r3, [sp, #0]
 80130d6:	2b00      	cmp	r3, #0
 80130d8:	dda2      	ble.n	8013020 <cblas_chemm+0x154>
 80130da:	9b01      	ldr	r3, [sp, #4]
 80130dc:	9d02      	ldr	r5, [sp, #8]
 80130de:	9501      	str	r5, [sp, #4]
 80130e0:	3301      	adds	r3, #1
 80130e2:	00da      	lsls	r2, r3, #3
 80130e4:	2300      	movs	r3, #0
 80130e6:	9302      	str	r3, [sp, #8]
 80130e8:	9306      	str	r3, [sp, #24]
 80130ea:	469a      	mov	sl, r3
 80130ec:	9b04      	ldr	r3, [sp, #16]
 80130ee:	9208      	str	r2, [sp, #32]
 80130f0:	00dc      	lsls	r4, r3, #3
 80130f2:	9b05      	ldr	r3, [sp, #20]
 80130f4:	00de      	lsls	r6, r3, #3
 80130f6:	9b03      	ldr	r3, [sp, #12]
 80130f8:	3304      	adds	r3, #4
 80130fa:	3a08      	subs	r2, #8
 80130fc:	9309      	str	r3, [sp, #36]	; 0x24
 80130fe:	f10b 0304 	add.w	r3, fp, #4
 8013102:	9207      	str	r2, [sp, #28]
 8013104:	930a      	str	r3, [sp, #40]	; 0x28
        for (j = 0; j < n2; j++) {
 8013106:	f1b8 0f00 	cmp.w	r8, #0
 801310a:	dd7d      	ble.n	8013208 <cblas_chemm+0x33c>
 801310c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801310e:	9a02      	ldr	r2, [sp, #8]
 8013110:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 8013114:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8013116:	9a06      	ldr	r2, [sp, #24]
 8013118:	f04f 0904 	mov.w	r9, #4
 801311c:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 8013120:	f04f 0e00 	mov.w	lr, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8013124:	ed5c 7a01 	vldr	s15, [ip, #-4]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8013128:	ed9c 7a00 	vldr	s14, [ip]
          BASE temp2_imag = 0.0;
 801312c:	eddf 2a44 	vldr	s5, [pc, #272]	; 8013240 <cblas_chemm+0x374>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013130:	ee24 3a27 	vmul.f32	s6, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013134:	ee27 2a44 	vnmul.f32	s4, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013138:	eea4 3a87 	vfma.f32	s6, s9, s14
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801313c:	eea4 2aa7 	vfma.f32	s4, s9, s15
          BASE temp2_real = 0.0;
 8013140:	eef0 1a62 	vmov.f32	s3, s5
          for (k = 0; k < i; k++) {
 8013144:	f1ba 0f00 	cmp.w	sl, #0
 8013148:	d035      	beq.n	80131b6 <cblas_chemm+0x2ea>
 801314a:	9b03      	ldr	r3, [sp, #12]
 801314c:	eb03 0109 	add.w	r1, r3, r9
 8013150:	9b01      	ldr	r3, [sp, #4]
 8013152:	eb0b 00ce 	add.w	r0, fp, lr, lsl #3
 8013156:	eb0b 0209 	add.w	r2, fp, r9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801315a:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801315e:	ed93 7a00 	vldr	s14, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013162:	ed12 6a01 	vldr	s12, [r2, #-4]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8013166:	ed51 3a01 	vldr	s7, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 801316a:	ed91 5a00 	vldr	s10, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801316e:	ee63 6a27 	vmul.f32	s13, s6, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013172:	ee67 5ac2 	vnmul.f32	s11, s15, s4
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013176:	eee2 6a07 	vfma.f32	s13, s4, s14
 801317a:	3308      	adds	r3, #8
          for (k = 0; k < i; k++) {
 801317c:	429d      	cmp	r5, r3
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801317e:	eee3 5a07 	vfma.f32	s11, s6, s14
 8013182:	4431      	add	r1, r6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013184:	ee76 6a26 	vadd.f32	s13, s12, s13
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8013188:	ee25 6a67 	vnmul.f32	s12, s10, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801318c:	ee67 7aa3 	vmul.f32	s15, s15, s7
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 8013190:	ed42 6a01 	vstr	s13, [r2, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 8013194:	edd0 6a01 	vldr	s13, [r0, #4]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8013198:	eea7 6a23 	vfma.f32	s12, s14, s7
 801319c:	4422      	add	r2, r4
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801319e:	eee7 7a05 	vfma.f32	s15, s14, s10
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80131a2:	ee36 7aa5 	vadd.f32	s14, s13, s11
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80131a6:	ee71 1a86 	vadd.f32	s3, s3, s12
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80131aa:	ed80 7a01 	vstr	s14, [r0, #4]
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80131ae:	ee72 2aa7 	vadd.f32	s5, s5, s15
          for (k = 0; k < i; k++) {
 80131b2:	4420      	add	r0, r4
 80131b4:	d1d1      	bne.n	801315a <cblas_chemm+0x28e>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 80131b6:	ed95 5a00 	vldr	s10, [r5]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 80131ba:	ed17 7a01 	vldr	s14, [r7, #-4]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 80131be:	edd7 7a00 	vldr	s15, [r7]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 80131c2:	eea2 7a05 	vfma.f32	s14, s4, s10
        for (j = 0; j < n2; j++) {
 80131c6:	f10e 0e01 	add.w	lr, lr, #1
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80131ca:	463b      	mov	r3, r7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80131cc:	ee62 5ac4 	vnmul.f32	s11, s5, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80131d0:	ee24 6a21 	vmul.f32	s12, s8, s3
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 80131d4:	eef0 6a47 	vmov.f32	s13, s14
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80131d8:	eeb0 7a65 	vmov.f32	s14, s11
 80131dc:	eea4 7aa1 	vfma.f32	s14, s9, s3
        for (j = 0; j < n2; j++) {
 80131e0:	45f0      	cmp	r8, lr
 80131e2:	f10c 0c08 	add.w	ip, ip, #8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80131e6:	eea4 6aa2 	vfma.f32	s12, s9, s5
 80131ea:	f109 0908 	add.w	r9, r9, #8
 80131ee:	f107 0708 	add.w	r7, r7, #8
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 80131f2:	eee3 7a05 	vfma.f32	s15, s6, s10
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80131f6:	ee36 7a87 	vadd.f32	s14, s13, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80131fa:	ee77 7a86 	vadd.f32	s15, s15, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80131fe:	ed07 7a03 	vstr	s14, [r7, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013202:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < n2; j++) {
 8013206:	d18d      	bne.n	8013124 <cblas_chemm+0x258>
      for (i = 0; i < n1; i++) {
 8013208:	9b08      	ldr	r3, [sp, #32]
 801320a:	9a04      	ldr	r2, [sp, #16]
 801320c:	441d      	add	r5, r3
 801320e:	9b06      	ldr	r3, [sp, #24]
 8013210:	4413      	add	r3, r2
 8013212:	9306      	str	r3, [sp, #24]
 8013214:	9a05      	ldr	r2, [sp, #20]
 8013216:	9b02      	ldr	r3, [sp, #8]
 8013218:	4413      	add	r3, r2
 801321a:	9302      	str	r3, [sp, #8]
 801321c:	9a07      	ldr	r2, [sp, #28]
 801321e:	9b01      	ldr	r3, [sp, #4]
 8013220:	4413      	add	r3, r2
 8013222:	9301      	str	r3, [sp, #4]
 8013224:	9b00      	ldr	r3, [sp, #0]
 8013226:	f10a 0a01 	add.w	sl, sl, #1
 801322a:	4553      	cmp	r3, sl
 801322c:	f47f af6b 	bne.w	8013106 <cblas_chemm+0x23a>
 8013230:	e6f6      	b.n	8013020 <cblas_chemm+0x154>
 8013232:	bf00      	nop
 8013234:	08030378 	.word	0x08030378
 8013238:	080306f0 	.word	0x080306f0
 801323c:	080305a8 	.word	0x080305a8
 8013240:	00000000 	.word	0x00000000
    } else if (side == CblasRight && uplo == CblasUpper) {
 8013244:	2d79      	cmp	r5, #121	; 0x79
 8013246:	f000 818e 	beq.w	8013566 <cblas_chemm+0x69a>
    } else if (side == CblasRight && uplo == CblasLower) {
 801324a:	2d7a      	cmp	r5, #122	; 0x7a
 801324c:	f47f aed2 	bne.w	8012ff4 <cblas_chemm+0x128>
      for (i = 0; i < n1; i++) {
 8013250:	9b00      	ldr	r3, [sp, #0]
 8013252:	2b00      	cmp	r3, #0
 8013254:	f77f aee4 	ble.w	8013020 <cblas_chemm+0x154>
 8013258:	9a04      	ldr	r2, [sp, #16]
 801325a:	9b01      	ldr	r3, [sp, #4]
 801325c:	00d2      	lsls	r2, r2, #3
 801325e:	9206      	str	r2, [sp, #24]
 8013260:	9a05      	ldr	r2, [sp, #20]
 8013262:	00d2      	lsls	r2, r2, #3
 8013264:	9204      	str	r2, [sp, #16]
 8013266:	9a02      	ldr	r2, [sp, #8]
 8013268:	3301      	adds	r3, #1
 801326a:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801326e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8013272:	9305      	str	r3, [sp, #20]
 8013274:	2300      	movs	r3, #0
 8013276:	46d9      	mov	r9, fp
 8013278:	f8dd b00c 	ldr.w	fp, [sp, #12]
 801327c:	9303      	str	r3, [sp, #12]
        for (j = 0; j < n2; j++) {
 801327e:	f1b8 0f00 	cmp.w	r8, #0
 8013282:	f340 821c 	ble.w	80136be <cblas_chemm+0x7f2>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8013286:	eddb 7a00 	vldr	s15, [fp]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801328a:	ed9b 7a01 	vldr	s14, [fp, #4]
          BASE temp2_imag = 0.0;
 801328e:	ed1f 3a14 	vldr	s6, [pc, #-80]	; 8013240 <cblas_chemm+0x374>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013292:	9c05      	ldr	r4, [sp, #20]
 8013294:	f8dd e004 	ldr.w	lr, [sp, #4]
 8013298:	f8dd c008 	ldr.w	ip, [sp, #8]
 801329c:	ee27 2a84 	vmul.f32	s4, s15, s8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80132a0:	ee64 2a47 	vnmul.f32	s5, s8, s14
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80132a4:	eea7 2a24 	vfma.f32	s4, s14, s9
 80132a8:	465e      	mov	r6, fp
 80132aa:	464d      	mov	r5, r9
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80132ac:	eee7 2aa4 	vfma.f32	s5, s15, s9
        for (j = 0; j < n2; j++) {
 80132b0:	2700      	movs	r7, #0
          BASE temp2_real = 0.0;
 80132b2:	eef0 1a43 	vmov.f32	s3, s6
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 80132b6:	ed9c 5a00 	vldr	s10, [ip]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80132ba:	ed95 7a00 	vldr	s14, [r5]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80132be:	edd5 7a01 	vldr	s15, [r5, #4]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80132c2:	eea5 7a22 	vfma.f32	s14, s10, s5
        for (j = 0; j < n2; j++) {
 80132c6:	3701      	adds	r7, #1
 80132c8:	45b8      	cmp	r8, r7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80132ca:	ee63 5a44 	vnmul.f32	s11, s6, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80132ce:	ee24 6a21 	vmul.f32	s12, s8, s3
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80132d2:	eef0 6a47 	vmov.f32	s13, s14
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80132d6:	eeb0 7a65 	vmov.f32	s14, s11
 80132da:	eea4 7aa1 	vfma.f32	s14, s9, s3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80132de:	eea4 6a83 	vfma.f32	s12, s9, s6
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80132e2:	eee5 7a02 	vfma.f32	s15, s10, s4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80132e6:	ee36 7a87 	vadd.f32	s14, s13, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80132ea:	ee77 7a86 	vadd.f32	s15, s15, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80132ee:	ed85 7a00 	vstr	s14, [r5]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80132f2:	edc5 7a01 	vstr	s15, [r5, #4]
        for (j = 0; j < n2; j++) {
 80132f6:	f000 81e2 	beq.w	80136be <cblas_chemm+0x7f2>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80132fa:	edd6 7a02 	vldr	s15, [r6, #8]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80132fe:	ed96 7a03 	vldr	s14, [r6, #12]
          BASE temp2_imag = 0.0;
 8013302:	ed1f 3a31 	vldr	s6, [pc, #-196]	; 8013240 <cblas_chemm+0x374>
 8013306:	9b02      	ldr	r3, [sp, #8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013308:	ee24 2a27 	vmul.f32	s4, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801330c:	ee67 2a44 	vnmul.f32	s5, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013310:	eea4 2a87 	vfma.f32	s4, s9, s14
 8013314:	eb03 03ce 	add.w	r3, r3, lr, lsl #3
 8013318:	f109 0004 	add.w	r0, r9, #4
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801331c:	eee4 2aa7 	vfma.f32	s5, s9, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013320:	4649      	mov	r1, r9
 8013322:	465a      	mov	r2, fp
          BASE temp2_real = 0.0;
 8013324:	eef0 1a43 	vmov.f32	s3, s6
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8013328:	ed93 7a01 	vldr	s14, [r3, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801332c:	edd3 6a00 	vldr	s13, [r3]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013330:	ed50 5a01 	vldr	s11, [r0, #-4]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 8013334:	edd2 7a01 	vldr	s15, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8013338:	edd2 3a00 	vldr	s7, [r2]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801333c:	ee27 6a42 	vnmul.f32	s12, s14, s4
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013340:	ee22 5a26 	vmul.f32	s10, s4, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013344:	eea2 6aa6 	vfma.f32	s12, s5, s13
 8013348:	3308      	adds	r3, #8
          for (k = 0; k < j; k++) {
 801334a:	429c      	cmp	r4, r3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801334c:	eea2 5a87 	vfma.f32	s10, s5, s14
 8013350:	f102 0208 	add.w	r2, r2, #8
 8013354:	f100 0008 	add.w	r0, r0, #8
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013358:	ee35 6a86 	vadd.f32	s12, s11, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801335c:	ee67 5a27 	vmul.f32	s11, s14, s15
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8013360:	ee66 7aa7 	vmul.f32	s15, s13, s15
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013364:	ed00 6a03 	vstr	s12, [r0, #-12]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013368:	ed91 6a01 	vldr	s12, [r1, #4]
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801336c:	eee7 7a63 	vfms.f32	s15, s14, s7
 8013370:	f101 0108 	add.w	r1, r1, #8
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 8013374:	eee6 5aa3 	vfma.f32	s11, s13, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013378:	ee36 7a05 	vadd.f32	s14, s12, s10
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801337c:	ee71 1aa5 	vadd.f32	s3, s3, s11
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013380:	ed01 7a01 	vstr	s14, [r1, #-4]
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8013384:	ee33 3a27 	vadd.f32	s6, s6, s15
          for (k = 0; k < j; k++) {
 8013388:	d1ce      	bne.n	8013328 <cblas_chemm+0x45c>
 801338a:	9b01      	ldr	r3, [sp, #4]
 801338c:	44d4      	add	ip, sl
 801338e:	3508      	adds	r5, #8
 8013390:	3608      	adds	r6, #8
 8013392:	449e      	add	lr, r3
 8013394:	4454      	add	r4, sl
 8013396:	e78e      	b.n	80132b6 <cblas_chemm+0x3ea>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8013398:	9b00      	ldr	r3, [sp, #0]
 801339a:	9a05      	ldr	r2, [sp, #20]
 801339c:	2b01      	cmp	r3, #1
 801339e:	bfb8      	it	lt
 80133a0:	2301      	movlt	r3, #1
 80133a2:	4293      	cmp	r3, r2
 80133a4:	f300 8183 	bgt.w	80136ae <cblas_chemm+0x7e2>
 80133a8:	9a04      	ldr	r2, [sp, #16]
 80133aa:	4293      	cmp	r3, r2
 80133ac:	bfcc      	ite	gt
 80133ae:	200d      	movgt	r0, #13
 80133b0:	2008      	movle	r0, #8
 80133b2:	e5c3      	b.n	8012f3c <cblas_chemm+0x70>
 80133b4:	9b00      	ldr	r3, [sp, #0]
 80133b6:	9a05      	ldr	r2, [sp, #20]
 80133b8:	2b01      	cmp	r3, #1
 80133ba:	bfb8      	it	lt
 80133bc:	2301      	movlt	r3, #1
 80133be:	4293      	cmp	r3, r2
 80133c0:	f300 8175 	bgt.w	80136ae <cblas_chemm+0x7e2>
 80133c4:	9a04      	ldr	r2, [sp, #16]
 80133c6:	4293      	cmp	r3, r2
 80133c8:	f77f ae22 	ble.w	8013010 <cblas_chemm+0x144>
 80133cc:	200d      	movs	r0, #13
 80133ce:	e5b5      	b.n	8012f3c <cblas_chemm+0x70>
      for (i = 0; i < n1; i++) {
 80133d0:	9a00      	ldr	r2, [sp, #0]
 80133d2:	2a00      	cmp	r2, #0
 80133d4:	f77f ae24 	ble.w	8013020 <cblas_chemm+0x154>
 80133d8:	9b01      	ldr	r3, [sp, #4]
 80133da:	f8dd e008 	ldr.w	lr, [sp, #8]
 80133de:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 80133e2:	3301      	adds	r3, #1
 80133e4:	00db      	lsls	r3, r3, #3
 80133e6:	930a      	str	r3, [sp, #40]	; 0x28
 80133e8:	f1ae 0508 	sub.w	r5, lr, #8
 80133ec:	3b08      	subs	r3, #8
 80133ee:	9309      	str	r3, [sp, #36]	; 0x24
 80133f0:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
 80133f4:	9b05      	ldr	r3, [sp, #20]
 80133f6:	9a04      	ldr	r2, [sp, #16]
 80133f8:	2100      	movs	r1, #0
 80133fa:	e9cd 2301 	strd	r2, r3, [sp, #4]
 80133fe:	00df      	lsls	r7, r3, #3
 8013400:	2301      	movs	r3, #1
 8013402:	9106      	str	r1, [sp, #24]
 8013404:	9107      	str	r1, [sp, #28]
 8013406:	00d6      	lsls	r6, r2, #3
 8013408:	469b      	mov	fp, r3
        for (j = 0; j < n2; j++) {
 801340a:	f1b8 0f00 	cmp.w	r8, #0
 801340e:	bfd8      	it	le
 8013410:	f8cd b020 	strle.w	fp, [sp, #32]
 8013414:	f340 808b 	ble.w	801352e <cblas_chemm+0x662>
 8013418:	9b02      	ldr	r3, [sp, #8]
 801341a:	9a01      	ldr	r2, [sp, #4]
 801341c:	f8cd b020 	str.w	fp, [sp, #32]
 8013420:	4619      	mov	r1, r3
 8013422:	9b07      	ldr	r3, [sp, #28]
 8013424:	4610      	mov	r0, r2
 8013426:	eba1 0a03 	sub.w	sl, r1, r3
 801342a:	9a06      	ldr	r2, [sp, #24]
 801342c:	9903      	ldr	r1, [sp, #12]
 801342e:	eba0 0902 	sub.w	r9, r0, r2
 8013432:	eb01 04c3 	add.w	r4, r1, r3, lsl #3
 8013436:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8013438:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 801343c:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8013440:	f10a 0a04 	add.w	sl, sl, #4
 8013444:	f109 0904 	add.w	r9, r9, #4
 8013448:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 801344c:	f04f 0c00 	mov.w	ip, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8013450:	ed94 6a00 	vldr	s12, [r4]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8013454:	edd4 5a01 	vldr	s11, [r4, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8013458:	edde 6a00 	vldr	s13, [lr]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801345c:	ed90 7a00 	vldr	s14, [r0]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 8013460:	edd0 7a01 	vldr	s15, [r0, #4]
          for (k = i + 1; k < n1; k++) {
 8013464:	9b00      	ldr	r3, [sp, #0]
          BASE temp2_imag = 0.0;
 8013466:	ed1f 2a8a 	vldr	s4, [pc, #-552]	; 8013240 <cblas_chemm+0x374>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801346a:	ee24 1a06 	vmul.f32	s2, s8, s12
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801346e:	ee65 1ac4 	vnmul.f32	s3, s11, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8013472:	eea4 1aa5 	vfma.f32	s2, s9, s11
          for (k = i + 1; k < n1; k++) {
 8013476:	455b      	cmp	r3, fp
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8013478:	eee4 1a86 	vfma.f32	s3, s9, s12
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801347c:	eee1 7a26 	vfma.f32	s15, s2, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8013480:	eea1 7aa6 	vfma.f32	s14, s3, s13
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 8013484:	edc0 7a01 	vstr	s15, [r0, #4]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 8013488:	ed80 7a00 	vstr	s14, [r0]
          BASE temp2_real = 0.0;
 801348c:	eef0 0a42 	vmov.f32	s1, s4
          for (k = i + 1; k < n1; k++) {
 8013490:	dd35      	ble.n	80134fe <cblas_chemm+0x632>
 8013492:	eb0a 0104 	add.w	r1, sl, r4
 8013496:	eb09 0300 	add.w	r3, r9, r0
 801349a:	4672      	mov	r2, lr
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801349c:	edd2 7a03 	vldr	s15, [r2, #12]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80134a0:	ed92 7a02 	vldr	s14, [r2, #8]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 80134a4:	ed51 2a01 	vldr	s5, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 80134a8:	ed91 3a00 	vldr	s6, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 80134ac:	ed13 5a01 	vldr	s10, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80134b0:	ed93 6a00 	vldr	s12, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 80134b4:	ee61 5a27 	vmul.f32	s11, s2, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80134b8:	ee67 3ae1 	vnmul.f32	s7, s15, s3
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 80134bc:	eee1 5a87 	vfma.f32	s11, s3, s14
 80134c0:	3208      	adds	r2, #8
          for (k = i + 1; k < n1; k++) {
 80134c2:	4295      	cmp	r5, r2
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80134c4:	ee63 6a67 	vnmul.f32	s13, s6, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80134c8:	eee1 3a07 	vfma.f32	s7, s2, s14
 80134cc:	4439      	add	r1, r7
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80134ce:	ee67 7aa2 	vmul.f32	s15, s15, s5
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80134d2:	eee7 6a22 	vfma.f32	s13, s14, s5
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80134d6:	eee7 7a03 	vfma.f32	s15, s14, s6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 80134da:	ee75 5a25 	vadd.f32	s11, s10, s11
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80134de:	ee36 7a23 	vadd.f32	s14, s12, s7
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 80134e2:	ed43 5a01 	vstr	s11, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 80134e6:	ed83 7a00 	vstr	s14, [r3]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80134ea:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80134ee:	ee32 2a27 	vadd.f32	s4, s4, s15
          for (k = i + 1; k < n1; k++) {
 80134f2:	4433      	add	r3, r6
 80134f4:	d1d2      	bne.n	801349c <cblas_chemm+0x5d0>
 80134f6:	ed90 7a00 	vldr	s14, [r0]
 80134fa:	edd0 7a01 	vldr	s15, [r0, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80134fe:	ee22 6a44 	vnmul.f32	s12, s4, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013502:	ee64 6a20 	vmul.f32	s13, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013506:	eea4 6aa0 	vfma.f32	s12, s9, s1
        for (j = 0; j < n2; j++) {
 801350a:	f10c 0c01 	add.w	ip, ip, #1
 801350e:	45e0      	cmp	r8, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013510:	eee4 6a82 	vfma.f32	s13, s9, s4
 8013514:	f104 0408 	add.w	r4, r4, #8
 8013518:	f100 0008 	add.w	r0, r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801351c:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013520:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013524:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013528:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 801352c:	d190      	bne.n	8013450 <cblas_chemm+0x584>
      for (i = 0; i < n1; i++) {
 801352e:	9a07      	ldr	r2, [sp, #28]
 8013530:	9b05      	ldr	r3, [sp, #20]
 8013532:	4611      	mov	r1, r2
 8013534:	4419      	add	r1, r3
 8013536:	9107      	str	r1, [sp, #28]
 8013538:	9906      	ldr	r1, [sp, #24]
 801353a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801353c:	4608      	mov	r0, r1
 801353e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8013540:	440d      	add	r5, r1
 8013542:	9902      	ldr	r1, [sp, #8]
 8013544:	4496      	add	lr, r2
 8013546:	4419      	add	r1, r3
 8013548:	9a04      	ldr	r2, [sp, #16]
 801354a:	9b01      	ldr	r3, [sp, #4]
 801354c:	9102      	str	r1, [sp, #8]
 801354e:	4413      	add	r3, r2
 8013550:	4410      	add	r0, r2
 8013552:	9301      	str	r3, [sp, #4]
 8013554:	9a08      	ldr	r2, [sp, #32]
 8013556:	9b00      	ldr	r3, [sp, #0]
 8013558:	9006      	str	r0, [sp, #24]
 801355a:	4293      	cmp	r3, r2
 801355c:	f10b 0b01 	add.w	fp, fp, #1
 8013560:	f73f af53 	bgt.w	801340a <cblas_chemm+0x53e>
 8013564:	e55c      	b.n	8013020 <cblas_chemm+0x154>
      for (i = 0; i < n1; i++) {
 8013566:	9b00      	ldr	r3, [sp, #0]
 8013568:	2b00      	cmp	r3, #0
 801356a:	f77f ad59 	ble.w	8013020 <cblas_chemm+0x154>
 801356e:	9b02      	ldr	r3, [sp, #8]
 8013570:	9a01      	ldr	r2, [sp, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013572:	ed1f 0acd 	vldr	s0, [pc, #-820]	; 8013240 <cblas_chemm+0x374>
 8013576:	f8cd b020 	str.w	fp, [sp, #32]
 801357a:	3b08      	subs	r3, #8
 801357c:	eb03 03c8 	add.w	r3, r3, r8, lsl #3
 8013580:	9307      	str	r3, [sp, #28]
 8013582:	9b04      	ldr	r3, [sp, #16]
      for (i = 0; i < n1; i++) {
 8013584:	f04f 0a00 	mov.w	sl, #0
 8013588:	f102 0c01 	add.w	ip, r2, #1
 801358c:	00db      	lsls	r3, r3, #3
 801358e:	eb0b 0ec8 	add.w	lr, fp, r8, lsl #3
 8013592:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8013596:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 801359a:	f8cd a004 	str.w	sl, [sp, #4]
 801359e:	9306      	str	r3, [sp, #24]
 80135a0:	46d3      	mov	fp, sl
        for (j = 0; j < n2; j++) {
 80135a2:	f1b8 0f00 	cmp.w	r8, #0
 80135a6:	f340 80aa 	ble.w	80136fe <cblas_chemm+0x832>
 80135aa:	9b03      	ldr	r3, [sp, #12]
 80135ac:	9a01      	ldr	r2, [sp, #4]
 80135ae:	9c07      	ldr	r4, [sp, #28]
 80135b0:	9e02      	ldr	r6, [sp, #8]
 80135b2:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 80135b6:	9b08      	ldr	r3, [sp, #32]
 80135b8:	2700      	movs	r7, #0
 80135ba:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80135be:	ed95 6a00 	vldr	s12, [r5]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80135c2:	edd5 5a01 	vldr	s11, [r5, #4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 80135c6:	edd6 6a00 	vldr	s13, [r6]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80135ca:	edd0 7a00 	vldr	s15, [r0]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80135ce:	ed90 7a01 	vldr	s14, [r0, #4]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80135d2:	ee64 1a06 	vmul.f32	s3, s8, s12
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80135d6:	ee25 2ac4 	vnmul.f32	s4, s11, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80135da:	eee4 1aa5 	vfma.f32	s3, s9, s11
          for (k = j + 1; k < n2; k++) {
 80135de:	3701      	adds	r7, #1
 80135e0:	45b8      	cmp	r8, r7
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80135e2:	eea4 2a86 	vfma.f32	s4, s9, s12
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80135e6:	eea1 7aa6 	vfma.f32	s14, s3, s13
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80135ea:	eee2 7a26 	vfma.f32	s15, s4, s13
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 80135ee:	ed80 7a01 	vstr	s14, [r0, #4]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 80135f2:	edc0 7a00 	vstr	s15, [r0]
          for (k = j + 1; k < n2; k++) {
 80135f6:	d06e      	beq.n	80136d6 <cblas_chemm+0x80a>
          BASE temp2_imag = 0.0;
 80135f8:	ed9f 1a5d 	vldr	s2, [pc, #372]	; 8013770 <cblas_chemm+0x8a4>
          for (k = j + 1; k < n2; k++) {
 80135fc:	4603      	mov	r3, r0
          BASE temp2_real = 0.0;
 80135fe:	eef0 0a41 	vmov.f32	s1, s2
          for (k = j + 1; k < n2; k++) {
 8013602:	4629      	mov	r1, r5
 8013604:	4632      	mov	r2, r6
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8013606:	edd2 6a02 	vldr	s13, [r2, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801360a:	ed92 7a03 	vldr	s14, [r2, #12]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 801360e:	edd1 7a03 	vldr	s15, [r1, #12]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8013612:	edd1 2a02 	vldr	s5, [r1, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013616:	ed93 5a03 	vldr	s10, [r3, #12]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801361a:	edd3 5a02 	vldr	s11, [r3, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801361e:	ee21 6aa6 	vmul.f32	s12, s3, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013622:	ee67 3a61 	vnmul.f32	s7, s14, s3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013626:	eea2 6a07 	vfma.f32	s12, s4, s14
 801362a:	3208      	adds	r2, #8
          for (k = j + 1; k < n2; k++) {
 801362c:	4294      	cmp	r4, r2
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801362e:	eee2 3a26 	vfma.f32	s7, s4, s13
 8013632:	f101 0108 	add.w	r1, r1, #8
 8013636:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801363a:	eeb0 3a46 	vmov.f32	s6, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801363e:	ee27 6a27 	vmul.f32	s12, s14, s15
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8013642:	ee66 7aa7 	vmul.f32	s15, s13, s15
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 8013646:	eea6 6aa2 	vfma.f32	s12, s13, s5
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801364a:	eee7 7a62 	vfms.f32	s15, s14, s5
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801364e:	eef0 6a46 	vmov.f32	s13, s12
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8013652:	ee35 7aa3 	vadd.f32	s14, s11, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8013656:	ee35 6a03 	vadd.f32	s12, s10, s6
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801365a:	ed83 7a00 	vstr	s14, [r3]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801365e:	ed83 6a01 	vstr	s12, [r3, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 8013662:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 8013666:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = j + 1; k < n2; k++) {
 801366a:	d1cc      	bne.n	8013606 <cblas_chemm+0x73a>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801366c:	ee21 7a44 	vnmul.f32	s14, s2, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013670:	ee64 7a20 	vmul.f32	s15, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013674:	eea4 7aa0 	vfma.f32	s14, s9, s1
 8013678:	3508      	adds	r5, #8
 801367a:	4466      	add	r6, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801367c:	eee4 7a81 	vfma.f32	s15, s9, s2
 8013680:	444c      	add	r4, r9
 8013682:	3008      	adds	r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013684:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013688:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801368c:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013690:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013694:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013698:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801369c:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80136a0:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 80136a4:	e78b      	b.n	80135be <cblas_chemm+0x6f2>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80136a6:	9b05      	ldr	r3, [sp, #20]
 80136a8:	2b00      	cmp	r3, #0
 80136aa:	dc4c      	bgt.n	8013746 <cblas_chemm+0x87a>
 80136ac:	2301      	movs	r3, #1
 80136ae:	9a04      	ldr	r2, [sp, #16]
 80136b0:	429a      	cmp	r2, r3
 80136b2:	bfb4      	ite	lt
 80136b4:	200d      	movlt	r0, #13
 80136b6:	200a      	movge	r0, #10
 80136b8:	e440      	b.n	8012f3c <cblas_chemm+0x70>
 80136ba:	4643      	mov	r3, r8
 80136bc:	e67b      	b.n	80133b6 <cblas_chemm+0x4ea>
      for (i = 0; i < n1; i++) {
 80136be:	9a06      	ldr	r2, [sp, #24]
 80136c0:	9b03      	ldr	r3, [sp, #12]
 80136c2:	4491      	add	r9, r2
 80136c4:	9a04      	ldr	r2, [sp, #16]
 80136c6:	4493      	add	fp, r2
 80136c8:	9a00      	ldr	r2, [sp, #0]
 80136ca:	3301      	adds	r3, #1
 80136cc:	429a      	cmp	r2, r3
 80136ce:	9303      	str	r3, [sp, #12]
 80136d0:	f47f add5 	bne.w	801327e <cblas_chemm+0x3b2>
 80136d4:	e4a4      	b.n	8013020 <cblas_chemm+0x154>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80136d6:	ee64 7a00 	vmul.f32	s15, s8, s0
 80136da:	ed5e 6a02 	vldr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80136de:	ed1e 7a01 	vldr	s14, [lr, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80136e2:	eeb0 6a67 	vmov.f32	s12, s15
 80136e6:	ee94 6a80 	vfnms.f32	s12, s9, s0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80136ea:	eee4 7a80 	vfma.f32	s15, s9, s0
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80136ee:	ee76 6a86 	vadd.f32	s13, s13, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80136f2:	ee77 7a27 	vadd.f32	s15, s14, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80136f6:	ed4e 6a02 	vstr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80136fa:	ed4e 7a01 	vstr	s15, [lr, #-4]
      for (i = 0; i < n1; i++) {
 80136fe:	9b06      	ldr	r3, [sp, #24]
 8013700:	9a05      	ldr	r2, [sp, #20]
 8013702:	449e      	add	lr, r3
 8013704:	9b01      	ldr	r3, [sp, #4]
 8013706:	4413      	add	r3, r2
 8013708:	9301      	str	r3, [sp, #4]
 801370a:	9b04      	ldr	r3, [sp, #16]
 801370c:	449a      	add	sl, r3
 801370e:	9b00      	ldr	r3, [sp, #0]
 8013710:	f10b 0b01 	add.w	fp, fp, #1
 8013714:	455b      	cmp	r3, fp
 8013716:	f47f af44 	bne.w	80135a2 <cblas_chemm+0x6d6>
 801371a:	e481      	b.n	8013020 <cblas_chemm+0x154>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801371c:	4643      	mov	r3, r8
 801371e:	2b01      	cmp	r3, #1
 8013720:	9a05      	ldr	r2, [sp, #20]
 8013722:	bfb8      	it	lt
 8013724:	2301      	movlt	r3, #1
 8013726:	429a      	cmp	r2, r3
 8013728:	dbc1      	blt.n	80136ae <cblas_chemm+0x7e2>
 801372a:	9a04      	ldr	r2, [sp, #16]
 801372c:	429a      	cmp	r2, r3
 801372e:	bfac      	ite	ge
 8013730:	2008      	movge	r0, #8
 8013732:	200d      	movlt	r0, #13
 8013734:	e402      	b.n	8012f3c <cblas_chemm+0x70>
 8013736:	3865      	subs	r0, #101	; 0x65
 8013738:	2801      	cmp	r0, #1
 801373a:	9b00      	ldr	r3, [sp, #0]
 801373c:	bf94      	ite	ls
 801373e:	2000      	movls	r0, #0
 8013740:	2001      	movhi	r0, #1
 8013742:	f7ff bbe1 	b.w	8012f08 <cblas_chemm+0x3c>
 8013746:	9b04      	ldr	r3, [sp, #16]
 8013748:	2b00      	cmp	r3, #0
 801374a:	bfcc      	ite	gt
 801374c:	2005      	movgt	r0, #5
 801374e:	200d      	movle	r0, #13
 8013750:	f7ff bbf4 	b.w	8012f3c <cblas_chemm+0x70>
 8013754:	4643      	mov	r3, r8
 8013756:	2b01      	cmp	r3, #1
 8013758:	9a05      	ldr	r2, [sp, #20]
 801375a:	bfb8      	it	lt
 801375c:	2301      	movlt	r3, #1
 801375e:	429a      	cmp	r2, r3
 8013760:	dba5      	blt.n	80136ae <cblas_chemm+0x7e2>
 8013762:	9a04      	ldr	r2, [sp, #16]
 8013764:	429a      	cmp	r2, r3
 8013766:	bfac      	ite	ge
 8013768:	2005      	movge	r0, #5
 801376a:	200d      	movlt	r0, #13
 801376c:	f7ff bbe6 	b.w	8012f3c <cblas_chemm+0x70>
 8013770:	00000000 	.word	0x00000000

08013774 <cblas_chemv>:
void
cblas_chemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *A, const int lda,
             const void *X, const int incX, const void *beta, void *Y,
             const int incY)
{
 8013774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013778:	ed2d 8b02 	vpush	{d8}
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801377c:	2866      	cmp	r0, #102	; 0x66
 801377e:	b089      	sub	sp, #36	; 0x24
 8013780:	461f      	mov	r7, r3
 8013782:	bf0c      	ite	eq
 8013784:	f04f 33ff 	moveq.w	r3, #4294967295
 8013788:	2301      	movne	r3, #1
 801378a:	ee08 3a10 	vmov	s16, r3
 801378e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8013790:	9301      	str	r3, [sp, #4]
 8013792:	4689      	mov	r9, r1
 8013794:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8013796:	9302      	str	r3, [sp, #8]
  INDEX i, j;

  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8013798:	3979      	subs	r1, #121	; 0x79
 801379a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801379c:	9300      	str	r3, [sp, #0]
 801379e:	2901      	cmp	r1, #1
 80137a0:	e9dd 4a14 	ldrd	r4, sl, [sp, #80]	; 0x50
 80137a4:	e9dd 6b17 	ldrd	r6, fp, [sp, #92]	; 0x5c
 80137a8:	4605      	mov	r5, r0
 80137aa:	4690      	mov	r8, r2
 80137ac:	f240 80e5 	bls.w	801397a <cblas_chemv+0x206>
 80137b0:	2002      	movs	r0, #2
 80137b2:	f1b8 0f00 	cmp.w	r8, #0
 80137b6:	f2c0 80d3 	blt.w	8013960 <cblas_chemv+0x1ec>
 80137ba:	4643      	mov	r3, r8
 80137bc:	2b01      	cmp	r3, #1
 80137be:	bfb8      	it	lt
 80137c0:	2301      	movlt	r3, #1
 80137c2:	4553      	cmp	r3, sl
 80137c4:	f340 8099 	ble.w	80138fa <cblas_chemv+0x186>
 80137c8:	2e00      	cmp	r6, #0
 80137ca:	f040 80a1 	bne.w	8013910 <cblas_chemv+0x19c>
 80137ce:	9b00      	ldr	r3, [sp, #0]
 80137d0:	2b00      	cmp	r3, #0
 80137d2:	bf0c      	ite	eq
 80137d4:	200b      	moveq	r0, #11
 80137d6:	2008      	movne	r0, #8
 80137d8:	4a6b      	ldr	r2, [pc, #428]	; (8013988 <cblas_chemv+0x214>)
 80137da:	496c      	ldr	r1, [pc, #432]	; (801398c <cblas_chemv+0x218>)
 80137dc:	f014 f934 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 80137e0:	ed97 4a00 	vldr	s8, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80137e4:	edd7 4a01 	vldr	s9, [r7, #4]

    const BASE beta_real = CONST_REAL0(beta);
 80137e8:	ed9b 6a00 	vldr	s12, [fp]
    const BASE beta_imag = CONST_IMAG0(beta);
 80137ec:	eddb 5a01 	vldr	s11, [fp, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 80137f0:	eeb5 4a40 	vcmp.f32	s8, #0.0
 80137f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80137f8:	d152      	bne.n	80138a0 <cblas_chemv+0x12c>
 80137fa:	eef5 4a40 	vcmp.f32	s9, #0.0
 80137fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013802:	d14d      	bne.n	80138a0 <cblas_chemv+0x12c>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8013804:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8013808:	eeb4 6a67 	vcmp.f32	s12, s15
 801380c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013810:	f040 81a6 	bne.w	8013b60 <cblas_chemv+0x3ec>
 8013814:	eef5 5a40 	vcmp.f32	s11, #0.0
 8013818:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801381c:	f000 809b 	beq.w	8013956 <cblas_chemv+0x1e2>
        REAL(Y, iy) = 0.0;
        IMAG(Y, iy) = 0.0;
        iy += incY;
      }
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
      INDEX iy = OFFSET(N, incY);
 8013820:	9a00      	ldr	r2, [sp, #0]
 8013822:	2a00      	cmp	r2, #0
 8013824:	f340 8197 	ble.w	8013b56 <cblas_chemv+0x3e2>
 8013828:	2300      	movs	r3, #0
      for (i = 0; i < N; i++) {
 801382a:	f1b8 0f00 	cmp.w	r8, #0
 801382e:	dd1d      	ble.n	801386c <cblas_chemv+0xf8>
 8013830:	9902      	ldr	r1, [sp, #8]
 8013832:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
 8013836:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 801383a:	9900      	ldr	r1, [sp, #0]
 801383c:	3204      	adds	r2, #4
 801383e:	00c8      	lsls	r0, r1, #3
 8013840:	2100      	movs	r1, #0
        const BASE y_real = REAL(Y, iy);
        const BASE y_imag = IMAG(Y, iy);
 8013842:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE y_real = REAL(Y, iy);
 8013846:	ed52 6a01 	vldr	s13, [r2, #-4]
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801384a:	ee27 7ae5 	vnmul.f32	s14, s15, s11
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801384e:	ee66 7a27 	vmul.f32	s15, s12, s15
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 8013852:	eea6 7a26 	vfma.f32	s14, s12, s13
      for (i = 0; i < N; i++) {
 8013856:	3101      	adds	r1, #1
 8013858:	4588      	cmp	r8, r1
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801385a:	eee5 7aa6 	vfma.f32	s15, s11, s13
        REAL(Y, iy) = tmpR;
 801385e:	ed02 7a01 	vstr	s14, [r2, #-4]
        IMAG(Y, iy) = tmpI;
 8013862:	edc3 7a01 	vstr	s15, [r3, #4]
      for (i = 0; i < N; i++) {
 8013866:	4402      	add	r2, r0
 8013868:	4403      	add	r3, r0
 801386a:	d1ea      	bne.n	8013842 <cblas_chemv+0xce>
        iy += incY;
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801386c:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8013870:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013874:	d104      	bne.n	8013880 <cblas_chemv+0x10c>
 8013876:	eef5 4a40 	vcmp.f32	s9, #0.0
 801387a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801387e:	d06a      	beq.n	8013956 <cblas_chemv+0x1e2>
      return;

    /* form  y := alpha*A*x + y */

    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8013880:	2d65      	cmp	r5, #101	; 0x65
 8013882:	f000 8089 	beq.w	8013998 <cblas_chemv+0x224>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8013886:	2d66      	cmp	r5, #102	; 0x66
 8013888:	f000 815d 	beq.w	8013b46 <cblas_chemv+0x3d2>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        ix -= incX;
        iy -= incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 801388c:	4a40      	ldr	r2, [pc, #256]	; (8013990 <cblas_chemv+0x21c>)
 801388e:	493f      	ldr	r1, [pc, #252]	; (801398c <cblas_chemv+0x218>)
 8013890:	2000      	movs	r0, #0
#define BASE float
#include "source_hemv.h"
#undef BASE
}
 8013892:	b009      	add	sp, #36	; 0x24
 8013894:	ecbd 8b02 	vpop	{d8}
 8013898:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801389c:	f014 b8d4 	b.w	8027a48 <cblas_xerbla>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 80138a0:	eeb5 6a40 	vcmp.f32	s12, #0.0
 80138a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80138a8:	d11a      	bne.n	80138e0 <cblas_chemv+0x16c>
 80138aa:	eef5 5a40 	vcmp.f32	s11, #0.0
 80138ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80138b2:	d1b5      	bne.n	8013820 <cblas_chemv+0xac>
      INDEX iy = OFFSET(N, incY);
 80138b4:	9a00      	ldr	r2, [sp, #0]
 80138b6:	2a00      	cmp	r2, #0
 80138b8:	f340 8159 	ble.w	8013b6e <cblas_chemv+0x3fa>
 80138bc:	2300      	movs	r3, #0
      for (i = 0; i < N; i++) {
 80138be:	f1b8 0f00 	cmp.w	r8, #0
 80138c2:	ddd3      	ble.n	801386c <cblas_chemv+0xf8>
 80138c4:	9a02      	ldr	r2, [sp, #8]
 80138c6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80138ca:	9a00      	ldr	r2, [sp, #0]
        REAL(Y, iy) = 0.0;
 80138cc:	2100      	movs	r1, #0
 80138ce:	00d0      	lsls	r0, r2, #3
      for (i = 0; i < N; i++) {
 80138d0:	2200      	movs	r2, #0
 80138d2:	3201      	adds	r2, #1
 80138d4:	4590      	cmp	r8, r2
        REAL(Y, iy) = 0.0;
 80138d6:	6019      	str	r1, [r3, #0]
        IMAG(Y, iy) = 0.0;
 80138d8:	6059      	str	r1, [r3, #4]
      for (i = 0; i < N; i++) {
 80138da:	4403      	add	r3, r0
 80138dc:	d1f9      	bne.n	80138d2 <cblas_chemv+0x15e>
 80138de:	e7c5      	b.n	801386c <cblas_chemv+0xf8>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 80138e0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80138e4:	eeb4 6a67 	vcmp.f32	s12, s15
 80138e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80138ec:	d198      	bne.n	8013820 <cblas_chemv+0xac>
 80138ee:	eef5 5a40 	vcmp.f32	s11, #0.0
 80138f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80138f6:	d0b9      	beq.n	801386c <cblas_chemv+0xf8>
 80138f8:	e792      	b.n	8013820 <cblas_chemv+0xac>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 80138fa:	2e00      	cmp	r6, #0
 80138fc:	f43f af67 	beq.w	80137ce <cblas_chemv+0x5a>
 8013900:	9b00      	ldr	r3, [sp, #0]
 8013902:	2b00      	cmp	r3, #0
 8013904:	f000 81f8 	beq.w	8013cf8 <cblas_chemv+0x584>
 8013908:	2800      	cmp	r0, #0
 801390a:	f43f af69 	beq.w	80137e0 <cblas_chemv+0x6c>
 801390e:	e763      	b.n	80137d8 <cblas_chemv+0x64>
 8013910:	9b00      	ldr	r3, [sp, #0]
 8013912:	2b00      	cmp	r3, #0
 8013914:	bf0c      	ite	eq
 8013916:	200b      	moveq	r0, #11
 8013918:	2006      	movne	r0, #6
 801391a:	e75d      	b.n	80137d8 <cblas_chemv+0x64>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801391c:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8013994 <cblas_chemv+0x220>
 8013920:	9a00      	ldr	r2, [sp, #0]
 8013922:	9906      	ldr	r1, [sp, #24]
 8013924:	ee64 4a87 	vmul.f32	s9, s9, s14
 8013928:	fb02 1303 	mla	r3, r2, r3, r1
 801392c:	9902      	ldr	r1, [sp, #8]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801392e:	eef0 6a64 	vmov.f32	s13, s9
 8013932:	eed4 6a07 	vfnms.f32	s13, s8, s14
 8013936:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
 801393a:	edd2 7a00 	vldr	s15, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801393e:	eee4 4a07 	vfma.f32	s9, s8, s14
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013942:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8013946:	edc2 7a00 	vstr	s15, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801394a:	edd2 7a01 	vldr	s15, [r2, #4]
 801394e:	ee77 4aa4 	vadd.f32	s9, s15, s9
 8013952:	edc2 4a01 	vstr	s9, [r2, #4]
 8013956:	b009      	add	sp, #36	; 0x24
 8013958:	ecbd 8b02 	vpop	{d8}
 801395c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8013960:	f1ba 0f00 	cmp.w	sl, #0
 8013964:	f77f af30 	ble.w	80137c8 <cblas_chemv+0x54>
 8013968:	2e00      	cmp	r6, #0
 801396a:	f43f af30 	beq.w	80137ce <cblas_chemv+0x5a>
 801396e:	9b00      	ldr	r3, [sp, #0]
 8013970:	2b00      	cmp	r3, #0
 8013972:	bf0c      	ite	eq
 8013974:	200b      	moveq	r0, #11
 8013976:	2003      	movne	r0, #3
 8013978:	e72e      	b.n	80137d8 <cblas_chemv+0x64>
 801397a:	3865      	subs	r0, #101	; 0x65
 801397c:	2801      	cmp	r0, #1
 801397e:	bf94      	ite	ls
 8013980:	2000      	movls	r0, #0
 8013982:	2001      	movhi	r0, #1
 8013984:	e715      	b.n	80137b2 <cblas_chemv+0x3e>
 8013986:	bf00      	nop
 8013988:	08030378 	.word	0x08030378
 801398c:	08030700 	.word	0x08030700
 8013990:	080305a8 	.word	0x080305a8
 8013994:	00000000 	.word	0x00000000
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8013998:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 801399c:	f000 80ec 	beq.w	8013b78 <cblas_chemv+0x404>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 80139a0:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 80139a4:	f47f af72 	bne.w	801388c <cblas_chemv+0x118>
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 80139a8:	9b00      	ldr	r3, [sp, #0]
      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80139aa:	2e00      	cmp	r6, #0
 80139ac:	f108 31ff 	add.w	r1, r8, #4294967295
 80139b0:	bfd6      	itet	le
 80139b2:	4277      	negle	r7, r6
 80139b4:	2700      	movgt	r7, #0
 80139b6:	434f      	mulle	r7, r1
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 80139b8:	2b00      	cmp	r3, #0
 80139ba:	bfda      	itte	le
 80139bc:	425d      	negle	r5, r3
 80139be:	fb01 f305 	mulle.w	r3, r1, r5
 80139c2:	2300      	movgt	r3, #0
 80139c4:	9306      	str	r3, [sp, #24]
 80139c6:	9d06      	ldr	r5, [sp, #24]
 80139c8:	9b00      	ldr	r3, [sp, #0]
      for (i = N; i > 0 && i--;) {
 80139ca:	f1b8 0f00 	cmp.w	r8, #0
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 80139ce:	fb01 5503 	mla	r5, r1, r3, r5
      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80139d2:	fb01 7206 	mla	r2, r1, r6, r7
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 80139d6:	9507      	str	r5, [sp, #28]
      for (i = N; i > 0 && i--;) {
 80139d8:	ddbd      	ble.n	8013956 <cblas_chemv+0x1e2>
 80139da:	9801      	ldr	r0, [sp, #4]
 80139dc:	9d07      	ldr	r5, [sp, #28]
 80139de:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
 80139e2:	9800      	ldr	r0, [sp, #0]
 80139e4:	ebc0 7c40 	rsb	ip, r0, r0, lsl #29
 80139e8:	9802      	ldr	r0, [sp, #8]
 80139ea:	fb01 f30a 	mul.w	r3, r1, sl
 80139ee:	eb00 09c5 	add.w	r9, r0, r5, lsl #3
 80139f2:	4605      	mov	r5, r0
 80139f4:	9806      	ldr	r0, [sp, #24]
 80139f6:	9303      	str	r3, [sp, #12]
 80139f8:	eb05 0bc0 	add.w	fp, r5, r0, lsl #3
 80139fc:	9801      	ldr	r0, [sp, #4]
 80139fe:	9d03      	ldr	r5, [sp, #12]
 8013a00:	18cb      	adds	r3, r1, r3
 8013a02:	ea6f 080a 	mvn.w	r8, sl
 8013a06:	eb00 07c7 	add.w	r7, r0, r7, lsl #3
 8013a0a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8013a0e:	eb04 00c5 	add.w	r0, r4, r5, lsl #3
 8013a12:	9c06      	ldr	r4, [sp, #24]
 8013a14:	9d02      	ldr	r5, [sp, #8]
 8013a16:	9701      	str	r7, [sp, #4]
 8013a18:	ebc6 7e46 	rsb	lr, r6, r6, lsl #29
 8013a1c:	ea4f 07c8 	mov.w	r7, r8, lsl #3
 8013a20:	9703      	str	r7, [sp, #12]
 8013a22:	ea4f 07ce 	mov.w	r7, lr, lsl #3
 8013a26:	f109 0e04 	add.w	lr, r9, #4
 8013a2a:	eb05 09c4 	add.w	r9, r5, r4, lsl #3
 8013a2e:	9c00      	ldr	r4, [sp, #0]
 8013a30:	9704      	str	r7, [sp, #16]
 8013a32:	ebca 7a4a 	rsb	sl, sl, sl, lsl #29
 8013a36:	ea4f 07cc 	mov.w	r7, ip, lsl #3
 8013a3a:	3204      	adds	r2, #4
 8013a3c:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8013a40:	00f6      	lsls	r6, r6, #3
 8013a42:	9705      	str	r7, [sp, #20]
 8013a44:	f10b 0b04 	add.w	fp, fp, #4
 8013a48:	9106      	str	r1, [sp, #24]
 8013a4a:	ea4f 08c4 	mov.w	r8, r4, lsl #3
        BASE x_real = CONST_REAL(X, ix);
 8013a4e:	ed12 6a01 	vldr	s12, [r2, #-4]
        BASE x_imag = CONST_IMAG(X, ix);
 8013a52:	edd2 5a00 	vldr	s11, [r2]
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 8013a56:	edd3 6a00 	vldr	s13, [r3]
        REAL(Y, iy) += temp1_real * Aii_real;
 8013a5a:	ed5e 7a01 	vldr	s15, [lr, #-4]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8013a5e:	ed9e 7a00 	vldr	s14, [lr]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 8013a62:	ee24 3a86 	vmul.f32	s6, s9, s12
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 8013a66:	ee65 3ae4 	vnmul.f32	s7, s11, s9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 8013a6a:	eea4 3a25 	vfma.f32	s6, s8, s11
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 8013a6e:	eee4 3a06 	vfma.f32	s7, s8, s12
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8013a72:	eea3 7a26 	vfma.f32	s14, s6, s13
        REAL(Y, iy) += temp1_real * Aii_real;
 8013a76:	eee3 7aa6 	vfma.f32	s15, s7, s13
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8013a7a:	ed8e 7a00 	vstr	s14, [lr]
        REAL(Y, iy) += temp1_real * Aii_real;
 8013a7e:	ed4e 7a01 	vstr	s15, [lr, #-4]
        for (j = j_min; j < j_max; j++) {
 8013a82:	2900      	cmp	r1, #0
 8013a84:	f000 812e 	beq.w	8013ce4 <cblas_chemv+0x570>
        BASE temp2_imag = 0.0;
 8013a88:	ed5f 2a3e 	vldr	s5, [pc, #-248]	; 8013994 <cblas_chemv+0x220>
        for (j = j_min; j < j_max; j++) {
 8013a8c:	9f01      	ldr	r7, [sp, #4]
 8013a8e:	eef8 1ac8 	vcvt.f32.s32	s3, s16
        BASE temp2_real = 0.0;
 8013a92:	eeb0 2a62 	vmov.f32	s4, s5
        for (j = j_min; j < j_max; j++) {
 8013a96:	46dc      	mov	ip, fp
 8013a98:	464d      	mov	r5, r9
 8013a9a:	4604      	mov	r4, r0
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 8013a9c:	edd4 6a00 	vldr	s13, [r4]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8013aa0:	ed94 7a01 	vldr	s14, [r4, #4]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8013aa4:	ed5c 5a01 	vldr	s11, [ip, #-4]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8013aa8:	ee21 7a87 	vmul.f32	s14, s3, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013aac:	ee63 7a26 	vmul.f32	s15, s6, s13
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8013ab0:	ee23 5a07 	vmul.f32	s10, s6, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013ab4:	eee7 7a63 	vfms.f32	s15, s14, s7
 8013ab8:	3408      	adds	r4, #8
        for (j = j_min; j < j_max; j++) {
 8013aba:	42a3      	cmp	r3, r4
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013abc:	eeb0 6a67 	vmov.f32	s12, s15
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8013ac0:	eef0 7a45 	vmov.f32	s15, s10
 8013ac4:	eee3 7aa6 	vfma.f32	s15, s7, s13
 8013ac8:	ee75 7aa7 	vadd.f32	s15, s11, s15
 8013acc:	ed4c 7a01 	vstr	s15, [ip, #-4]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013ad0:	edd5 7a01 	vldr	s15, [r5, #4]
 8013ad4:	ee77 7a86 	vadd.f32	s15, s15, s12
 8013ad8:	44c4      	add	ip, r8
 8013ada:	edc5 7a01 	vstr	s15, [r5, #4]
          x_imag = CONST_IMAG(X, jx);
 8013ade:	edd7 7a01 	vldr	s15, [r7, #4]
          x_real = CONST_REAL(X, jx);
 8013ae2:	edd7 5a00 	vldr	s11, [r7]
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8013ae6:	ee27 6ac7 	vnmul.f32	s12, s15, s14
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8013aea:	ee66 7aa7 	vmul.f32	s15, s13, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8013aee:	eea6 6aa5 	vfma.f32	s12, s13, s11
 8013af2:	4445      	add	r5, r8
 8013af4:	4437      	add	r7, r6
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8013af6:	eee7 7a25 	vfma.f32	s15, s14, s11
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8013afa:	ee32 2a06 	vadd.f32	s4, s4, s12
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8013afe:	ee72 2aa7 	vadd.f32	s5, s5, s15
        for (j = j_min; j < j_max; j++) {
 8013b02:	d1cb      	bne.n	8013a9c <cblas_chemv+0x328>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013b04:	ee22 7ae4 	vnmul.f32	s14, s5, s9
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013b08:	ee64 7a82 	vmul.f32	s15, s9, s4
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013b0c:	eea4 7a02 	vfma.f32	s14, s8, s4
 8013b10:	9c03      	ldr	r4, [sp, #12]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013b12:	eee4 7a22 	vfma.f32	s15, s8, s5
 8013b16:	4423      	add	r3, r4
 8013b18:	9c04      	ldr	r4, [sp, #16]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013b1a:	eeb0 6a47 	vmov.f32	s12, s14
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013b1e:	eef0 6a67 	vmov.f32	s13, s15
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013b22:	ed1e 7a01 	vldr	s14, [lr, #-4]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013b26:	edde 7a00 	vldr	s15, [lr]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013b2a:	ee37 7a06 	vadd.f32	s14, s14, s12
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013b2e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8013b32:	4422      	add	r2, r4
 8013b34:	9c05      	ldr	r4, [sp, #20]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013b36:	ed0e 7a01 	vstr	s14, [lr, #-4]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013b3a:	edce 7a00 	vstr	s15, [lr]
      for (i = N; i > 0 && i--;) {
 8013b3e:	4450      	add	r0, sl
 8013b40:	3901      	subs	r1, #1
 8013b42:	44a6      	add	lr, r4
 8013b44:	e783      	b.n	8013a4e <cblas_chemv+0x2da>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8013b46:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8013b4a:	d015      	beq.n	8013b78 <cblas_chemv+0x404>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 8013b4c:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8013b50:	f47f ae9c 	bne.w	801388c <cblas_chemv+0x118>
 8013b54:	e728      	b.n	80139a8 <cblas_chemv+0x234>
      INDEX iy = OFFSET(N, incY);
 8013b56:	f1c8 0301 	rsb	r3, r8, #1
 8013b5a:	fb03 f302 	mul.w	r3, r3, r2
 8013b5e:	e664      	b.n	801382a <cblas_chemv+0xb6>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8013b60:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8013b64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013b68:	f43f ae9f 	beq.w	80138aa <cblas_chemv+0x136>
 8013b6c:	e658      	b.n	8013820 <cblas_chemv+0xac>
      INDEX iy = OFFSET(N, incY);
 8013b6e:	f1c8 0301 	rsb	r3, r8, #1
 8013b72:	fb03 f302 	mul.w	r3, r3, r2
 8013b76:	e6a2      	b.n	80138be <cblas_chemv+0x14a>
      INDEX ix = OFFSET(N, incX);
 8013b78:	2e00      	cmp	r6, #0
      INDEX iy = OFFSET(N, incY);
 8013b7a:	9a00      	ldr	r2, [sp, #0]
      INDEX ix = OFFSET(N, incX);
 8013b7c:	bfda      	itte	le
 8013b7e:	f1c8 0901 	rsble	r9, r8, #1
 8013b82:	fb09 f906 	mulle.w	r9, r9, r6
 8013b86:	f04f 0900 	movgt.w	r9, #0
      INDEX iy = OFFSET(N, incY);
 8013b8a:	2a00      	cmp	r2, #0
 8013b8c:	bfda      	itte	le
 8013b8e:	f1c8 0301 	rsble	r3, r8, #1
 8013b92:	4353      	mulle	r3, r2
 8013b94:	2300      	movgt	r3, #0
      for (i = 0; i < N; i++) {
 8013b96:	f1b8 0f00 	cmp.w	r8, #0
      INDEX iy = OFFSET(N, incY);
 8013b9a:	9306      	str	r3, [sp, #24]
      for (i = 0; i < N; i++) {
 8013b9c:	f77f aedb 	ble.w	8013956 <cblas_chemv+0x1e2>
 8013ba0:	f10a 0a01 	add.w	sl, sl, #1
 8013ba4:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 8013ba8:	9a06      	ldr	r2, [sp, #24]
 8013baa:	9800      	ldr	r0, [sp, #0]
 8013bac:	9304      	str	r3, [sp, #16]
 8013bae:	3b08      	subs	r3, #8
 8013bb0:	f1a4 0708 	sub.w	r7, r4, #8
 8013bb4:	46a6      	mov	lr, r4
 8013bb6:	9303      	str	r3, [sp, #12]
 8013bb8:	9c01      	ldr	r4, [sp, #4]
 8013bba:	9b02      	ldr	r3, [sp, #8]
 8013bbc:	9605      	str	r6, [sp, #20]
 8013bbe:	eb02 0a00 	add.w	sl, r2, r0
 8013bc2:	eb09 0106 	add.w	r1, r9, r6
 8013bc6:	eb03 0aca 	add.w	sl, r3, sl, lsl #3
 8013bca:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8013bce:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
 8013bd2:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
 8013bd6:	ea4f 0cc6 	mov.w	ip, r6, lsl #3
 8013bda:	00c5      	lsls	r5, r0, #3
 8013bdc:	2300      	movs	r3, #0
 8013bde:	468b      	mov	fp, r1
        BASE x_real = CONST_REAL(X, ix);
 8013be0:	ed99 6a00 	vldr	s12, [r9]
        BASE x_imag = CONST_IMAG(X, ix);
 8013be4:	edd9 5a01 	vldr	s11, [r9, #4]
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 8013be8:	edde 6a00 	vldr	s13, [lr]
        REAL(Y, iy) += temp1_real * Aii_real;
 8013bec:	edd2 7a00 	vldr	s15, [r2]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8013bf0:	ed92 7a01 	vldr	s14, [r2, #4]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 8013bf4:	ee24 3a86 	vmul.f32	s6, s9, s12
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 8013bf8:	ee65 3ae4 	vnmul.f32	s7, s11, s9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 8013bfc:	eea4 3a25 	vfma.f32	s6, s8, s11
        const INDEX j_min = i + 1;
 8013c00:	1c5e      	adds	r6, r3, #1
        for (j = j_min; j < j_max; j++) {
 8013c02:	45b0      	cmp	r8, r6
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 8013c04:	eee4 3a06 	vfma.f32	s7, s8, s12
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8013c08:	eea3 7a26 	vfma.f32	s14, s6, s13
        REAL(Y, iy) += temp1_real * Aii_real;
 8013c0c:	eee3 7aa6 	vfma.f32	s15, s7, s13
        IMAG(Y, iy) += temp1_imag * Aii_real;
 8013c10:	ed82 7a01 	vstr	s14, [r2, #4]
        REAL(Y, iy) += temp1_real * Aii_real;
 8013c14:	edc2 7a00 	vstr	s15, [r2]
        for (j = j_min; j < j_max; j++) {
 8013c18:	f43f ae80 	beq.w	801391c <cblas_chemv+0x1a8>
 8013c1c:	9b01      	ldr	r3, [sp, #4]
        BASE temp2_imag = 0.0;
 8013c1e:	ed5f 2aa3 	vldr	s5, [pc, #-652]	; 8013994 <cblas_chemv+0x220>
 8013c22:	eef8 1ac8 	vcvt.f32.s32	s3, s16
 8013c26:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
        BASE temp2_real = 0.0;
 8013c2a:	eeb0 2a62 	vmov.f32	s4, s5
 8013c2e:	f10a 0004 	add.w	r0, sl, #4
        for (j = j_min; j < j_max; j++) {
 8013c32:	4651      	mov	r1, sl
 8013c34:	4673      	mov	r3, lr
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 8013c36:	edd3 6a02 	vldr	s13, [r3, #8]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8013c3a:	ed93 7a03 	vldr	s14, [r3, #12]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8013c3e:	ed50 5a01 	vldr	s11, [r0, #-4]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8013c42:	ee21 7a87 	vmul.f32	s14, s3, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013c46:	ee63 7a26 	vmul.f32	s15, s6, s13
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8013c4a:	ee23 5a07 	vmul.f32	s10, s6, s14
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013c4e:	eee7 7a63 	vfms.f32	s15, s14, s7
 8013c52:	3308      	adds	r3, #8
        for (j = j_min; j < j_max; j++) {
 8013c54:	429f      	cmp	r7, r3
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013c56:	eeb0 6a67 	vmov.f32	s12, s15
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 8013c5a:	eef0 7a45 	vmov.f32	s15, s10
 8013c5e:	eee3 7aa6 	vfma.f32	s15, s7, s13
 8013c62:	ee75 7aa7 	vadd.f32	s15, s11, s15
 8013c66:	ed40 7a01 	vstr	s15, [r0, #-4]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 8013c6a:	edd1 7a01 	vldr	s15, [r1, #4]
 8013c6e:	ee77 7a86 	vadd.f32	s15, s15, s12
 8013c72:	4428      	add	r0, r5
 8013c74:	edc1 7a01 	vstr	s15, [r1, #4]
          x_imag = CONST_IMAG(X, jx);
 8013c78:	edd4 7a01 	vldr	s15, [r4, #4]
          x_real = CONST_REAL(X, jx);
 8013c7c:	edd4 5a00 	vldr	s11, [r4]
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8013c80:	ee27 6ac7 	vnmul.f32	s12, s15, s14
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8013c84:	ee66 7aa7 	vmul.f32	s15, s13, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8013c88:	eea6 6aa5 	vfma.f32	s12, s13, s11
 8013c8c:	4429      	add	r1, r5
 8013c8e:	4464      	add	r4, ip
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8013c90:	eee7 7a25 	vfma.f32	s15, s14, s11
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 8013c94:	ee32 2a06 	vadd.f32	s4, s4, s12
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 8013c98:	ee72 2aa7 	vadd.f32	s5, s5, s15
        for (j = j_min; j < j_max; j++) {
 8013c9c:	d1cb      	bne.n	8013c36 <cblas_chemv+0x4c2>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013c9e:	ee22 7ae4 	vnmul.f32	s14, s5, s9
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013ca2:	ee64 7a82 	vmul.f32	s15, s9, s4
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013ca6:	eea4 7a02 	vfma.f32	s14, s8, s4
 8013caa:	9b05      	ldr	r3, [sp, #20]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013cac:	eee4 7a22 	vfma.f32	s15, s8, s5
 8013cb0:	449b      	add	fp, r3
 8013cb2:	9b04      	ldr	r3, [sp, #16]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013cb4:	eeb0 6a47 	vmov.f32	s12, s14
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013cb8:	eef0 6a67 	vmov.f32	s13, s15
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013cbc:	ed92 7a00 	vldr	s14, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013cc0:	edd2 7a01 	vldr	s15, [r2, #4]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013cc4:	ee37 7a06 	vadd.f32	s14, s14, s12
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013cc8:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8013ccc:	449e      	add	lr, r3
 8013cce:	9b03      	ldr	r3, [sp, #12]
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013cd0:	ed82 7a00 	vstr	s14, [r2]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013cd4:	441f      	add	r7, r3
 8013cd6:	edc2 7a01 	vstr	s15, [r2, #4]
      for (i = 0; i < N; i++) {
 8013cda:	44e1      	add	r9, ip
 8013cdc:	44aa      	add	sl, r5
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8013cde:	4633      	mov	r3, r6
 8013ce0:	442a      	add	r2, r5
 8013ce2:	e77d      	b.n	8013be0 <cblas_chemv+0x46c>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8013ce4:	ed1f 7ad5 	vldr	s14, [pc, #-852]	; 8013994 <cblas_chemv+0x220>
 8013ce8:	9b06      	ldr	r3, [sp, #24]
 8013cea:	9a00      	ldr	r2, [sp, #0]
 8013cec:	9907      	ldr	r1, [sp, #28]
 8013cee:	ee64 4a87 	vmul.f32	s9, s9, s14
 8013cf2:	fb02 1313 	mls	r3, r2, r3, r1
 8013cf6:	e619      	b.n	801392c <cblas_chemv+0x1b8>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 8013cf8:	200b      	movs	r0, #11
 8013cfa:	e56d      	b.n	80137d8 <cblas_chemv+0x64>

08013cfc <cblas_cher>:

void
cblas_cher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const float alpha, const void *X, const int incX,
            void *A, const int lda)
{
 8013cfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013d00:	ed2d 8b02 	vpush	{d8}
 8013d04:	b085      	sub	sp, #20
 8013d06:	4698      	mov	r8, r3
 8013d08:	e9dd 9310 	ldrd	r9, r3, [sp, #64]	; 0x40
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i, j;
  const int conj = (order == CblasColMajor) ? -1 : 1;
 8013d0c:	2866      	cmp	r0, #102	; 0x66
 8013d0e:	460e      	mov	r6, r1

  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8013d10:	f1a1 0179 	sub.w	r1, r1, #121	; 0x79
  const int conj = (order == CblasColMajor) ? -1 : 1;
 8013d14:	bf0c      	ite	eq
 8013d16:	f04f 34ff 	moveq.w	r4, #4294967295
 8013d1a:	2401      	movne	r4, #1
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8013d1c:	2901      	cmp	r1, #1
 8013d1e:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 8013d22:	9300      	str	r3, [sp, #0]
 8013d24:	4605      	mov	r5, r0
 8013d26:	4617      	mov	r7, r2
 8013d28:	eeb0 8a40 	vmov.f32	s16, s0
 8013d2c:	d933      	bls.n	8013d96 <cblas_cher+0x9a>
 8013d2e:	2a00      	cmp	r2, #0
 8013d30:	db0c      	blt.n	8013d4c <cblas_cher+0x50>
 8013d32:	f1b9 0f00 	cmp.w	r9, #0
 8013d36:	f040 80ca 	bne.w	8013ece <cblas_cher+0x1d2>
 8013d3a:	2f01      	cmp	r7, #1
 8013d3c:	4638      	mov	r0, r7
 8013d3e:	bfb8      	it	lt
 8013d40:	2001      	movlt	r0, #1
 8013d42:	4582      	cmp	sl, r0
 8013d44:	bfb4      	ite	lt
 8013d46:	2008      	movlt	r0, #8
 8013d48:	2006      	movge	r0, #6
 8013d4a:	e007      	b.n	8013d5c <cblas_cher+0x60>
 8013d4c:	f1b9 0f00 	cmp.w	r9, #0
 8013d50:	d0f3      	beq.n	8013d3a <cblas_cher+0x3e>
 8013d52:	f1ba 0f00 	cmp.w	sl, #0
 8013d56:	bfd4      	ite	le
 8013d58:	2008      	movle	r0, #8
 8013d5a:	2003      	movgt	r0, #3
 8013d5c:	4a9b      	ldr	r2, [pc, #620]	; (8013fcc <cblas_cher+0x2d0>)
 8013d5e:	499c      	ldr	r1, [pc, #624]	; (8013fd0 <cblas_cher+0x2d4>)
 8013d60:	f013 fe72 	bl	8027a48 <cblas_xerbla>

  if (alpha == 0.0)
 8013d64:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8013d68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013d6c:	d00e      	beq.n	8013d8c <cblas_cher+0x90>
    return;

  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8013d6e:	2d65      	cmp	r5, #101	; 0x65
 8013d70:	d024      	beq.n	8013dbc <cblas_cher+0xc0>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8013d72:	2d66      	cmp	r5, #102	; 0x66
 8013d74:	f000 811c 	beq.w	8013fb0 <cblas_cher+0x2b4>
      }

      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8013d78:	4a96      	ldr	r2, [pc, #600]	; (8013fd4 <cblas_cher+0x2d8>)
 8013d7a:	4995      	ldr	r1, [pc, #596]	; (8013fd0 <cblas_cher+0x2d4>)
 8013d7c:	2000      	movs	r0, #0
#define BASE float
#include "source_her.h"
#undef BASE
}
 8013d7e:	b005      	add	sp, #20
 8013d80:	ecbd 8b02 	vpop	{d8}
 8013d84:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013d88:	f013 be5e 	b.w	8027a48 <cblas_xerbla>
 8013d8c:	b005      	add	sp, #20
 8013d8e:	ecbd 8b02 	vpop	{d8}
 8013d92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8013d96:	2a00      	cmp	r2, #0
 8013d98:	dbd8      	blt.n	8013d4c <cblas_cher+0x50>
 8013d9a:	f1b9 0f00 	cmp.w	r9, #0
 8013d9e:	d0cc      	beq.n	8013d3a <cblas_cher+0x3e>
 8013da0:	2a01      	cmp	r2, #1
 8013da2:	4613      	mov	r3, r2
 8013da4:	bfb8      	it	lt
 8013da6:	2301      	movlt	r3, #1
 8013da8:	4553      	cmp	r3, sl
 8013daa:	f300 810c 	bgt.w	8013fc6 <cblas_cher+0x2ca>
 8013dae:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8013db2:	2b01      	cmp	r3, #1
 8013db4:	bf88      	it	hi
 8013db6:	2001      	movhi	r0, #1
 8013db8:	d9d4      	bls.n	8013d64 <cblas_cher+0x68>
 8013dba:	e7cf      	b.n	8013d5c <cblas_cher+0x60>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 8013dbc:	2e79      	cmp	r6, #121	; 0x79
 8013dbe:	f000 808f 	beq.w	8013ee0 <cblas_cher+0x1e4>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8013dc2:	2e7a      	cmp	r6, #122	; 0x7a
 8013dc4:	d1d8      	bne.n	8013d78 <cblas_cher+0x7c>
    INDEX ix = OFFSET(N, incX);
 8013dc6:	f1b9 0f00 	cmp.w	r9, #0
 8013dca:	bfda      	itte	le
 8013dcc:	f1c7 0c01 	rsble	ip, r7, #1
 8013dd0:	fb0c fc09 	mulle.w	ip, ip, r9
 8013dd4:	f04f 0c00 	movgt.w	ip, #0
    for (i = 0; i < N; i++) {
 8013dd8:	2f00      	cmp	r7, #0
 8013dda:	ddd7      	ble.n	8013d8c <cblas_cher+0x90>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013ddc:	ee07 4a90 	vmov	s15, r4
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013de0:	eb08 03cc 	add.w	r3, r8, ip, lsl #3
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013de4:	eef8 3ae7 	vcvt.f32.s32	s7, s15
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013de8:	edd3 6a00 	vldr	s13, [r3]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013dec:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013df0:	9301      	str	r3, [sp, #4]
 8013df2:	4263      	negs	r3, r4
 8013df4:	ee04 3a10 	vmov	s8, r3
 8013df8:	9a00      	ldr	r2, [sp, #0]
        IMAG(A, lda * i + i) = 0;
 8013dfa:	ed9f 3a77 	vldr	s6, [pc, #476]	; 8013fd8 <cblas_cher+0x2dc>
 8013dfe:	f8cd a00c 	str.w	sl, [sp, #12]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013e02:	ee63 3a88 	vmul.f32	s7, s7, s16
 8013e06:	f10a 0501 	add.w	r5, sl, #1
 8013e0a:	00e9      	lsls	r1, r5, #3
 8013e0c:	1d13      	adds	r3, r2, #4
 8013e0e:	ee27 5aa3 	vmul.f32	s10, s15, s7
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013e12:	ee66 4a88 	vmul.f32	s9, s13, s16
      for (j = 0; j < i; j++) {
 8013e16:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013e1a:	46d6      	mov	lr, sl
 8013e1c:	9302      	str	r3, [sp, #8]
 8013e1e:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
 8013e22:	ea4f 06c9 	mov.w	r6, r9, lsl #3
    for (i = 0; i < N; i++) {
 8013e26:	f04f 0b00 	mov.w	fp, #0
 8013e2a:	468a      	mov	sl, r1
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8013e2c:	ee64 7a27 	vmul.f32	s15, s8, s15
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013e30:	ed13 7a01 	vldr	s14, [r3, #-4]
        IMAG(A, lda * i + i) = 0;
 8013e34:	ed83 3a00 	vstr	s6, [r3]
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013e38:	ee25 5a67 	vnmul.f32	s10, s10, s15
    for (i = 0; i < N; i++) {
 8013e3c:	f10b 0b01 	add.w	fp, fp, #1
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013e40:	eea4 5aa6 	vfma.f32	s10, s9, s13
    for (i = 0; i < N; i++) {
 8013e44:	455f      	cmp	r7, fp
      ix += incX;
 8013e46:	44cc      	add	ip, r9
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013e48:	ee37 5a05 	vadd.f32	s10, s14, s10
 8013e4c:	ed03 5a01 	vstr	s10, [r3, #-4]
    for (i = 0; i < N; i++) {
 8013e50:	d09c      	beq.n	8013d8c <cblas_cher+0x90>
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013e52:	eb08 02cc 	add.w	r2, r8, ip, lsl #3
 8013e56:	edd2 4a00 	vldr	s9, [r2]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013e5a:	ed92 5a01 	vldr	s10, [r2, #4]
 8013e5e:	9902      	ldr	r1, [sp, #8]
 8013e60:	9a00      	ldr	r2, [sp, #0]
 8013e62:	eb01 00ce 	add.w	r0, r1, lr, lsl #3
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013e66:	ee68 4a24 	vmul.f32	s9, s16, s9
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013e6a:	ee23 5a85 	vmul.f32	s10, s7, s10
 8013e6e:	9901      	ldr	r1, [sp, #4]
 8013e70:	ea4f 04cc 	mov.w	r4, ip, lsl #3
 8013e74:	eb02 02ce 	add.w	r2, r2, lr, lsl #3
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8013e78:	edd1 7a01 	vldr	s15, [r1, #4]
        const BASE X_real = CONST_REAL(X, jx);
 8013e7c:	edd1 5a00 	vldr	s11, [r1]
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013e80:	ed50 6a01 	vldr	s13, [r0, #-4]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8013e84:	ee64 7a27 	vmul.f32	s15, s8, s15
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013e88:	ee25 7a25 	vmul.f32	s14, s10, s11
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013e8c:	ee27 6ac5 	vnmul.f32	s12, s15, s10
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013e90:	eea4 7aa7 	vfma.f32	s14, s9, s15
 8013e94:	3208      	adds	r2, #8
 8013e96:	4431      	add	r1, r6
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013e98:	eef0 7a46 	vmov.f32	s15, s12
 8013e9c:	eee4 7aa5 	vfma.f32	s15, s9, s11
 8013ea0:	3008      	adds	r0, #8
 8013ea2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8013ea6:	ed40 7a03 	vstr	s15, [r0, #-12]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013eaa:	ed52 7a01 	vldr	s15, [r2, #-4]
 8013eae:	ee77 7a87 	vadd.f32	s15, s15, s14
 8013eb2:	ed42 7a01 	vstr	s15, [r2, #-4]
      for (j = 0; j < i; j++) {
 8013eb6:	4295      	cmp	r5, r2
 8013eb8:	d1de      	bne.n	8013e78 <cblas_cher+0x17c>
 8013eba:	9a03      	ldr	r2, [sp, #12]
 8013ebc:	4444      	add	r4, r8
 8013ebe:	edd4 7a01 	vldr	s15, [r4, #4]
 8013ec2:	edd4 6a00 	vldr	s13, [r4]
 8013ec6:	4496      	add	lr, r2
 8013ec8:	4455      	add	r5, sl
 8013eca:	4453      	add	r3, sl
 8013ecc:	e7ae      	b.n	8013e2c <cblas_cher+0x130>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8013ece:	2a01      	cmp	r2, #1
 8013ed0:	4610      	mov	r0, r2
 8013ed2:	bfb8      	it	lt
 8013ed4:	2001      	movlt	r0, #1
 8013ed6:	4582      	cmp	sl, r0
 8013ed8:	bfb4      	ite	lt
 8013eda:	2008      	movlt	r0, #8
 8013edc:	2002      	movge	r0, #2
 8013ede:	e73d      	b.n	8013d5c <cblas_cher+0x60>
    INDEX ix = OFFSET(N, incX);
 8013ee0:	f1b9 0f00 	cmp.w	r9, #0
 8013ee4:	dd6a      	ble.n	8013fbc <cblas_cher+0x2c0>
 8013ee6:	2600      	movs	r6, #0
    for (i = 0; i < N; i++) {
 8013ee8:	2f00      	cmp	r7, #0
 8013eea:	f77f af4f 	ble.w	8013d8c <cblas_cher+0x90>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013eee:	ee07 4a90 	vmov	s15, r4
 8013ef2:	4264      	negs	r4, r4
 8013ef4:	eeb8 3ae7 	vcvt.f32.s32	s6, s15
 8013ef8:	9b00      	ldr	r3, [sp, #0]
 8013efa:	ee07 4a90 	vmov	s15, r4
 8013efe:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8013f02:	f1a3 0108 	sub.w	r1, r3, #8
 8013f06:	eb08 05c6 	add.w	r5, r8, r6, lsl #3
 8013f0a:	ee23 3a08 	vmul.f32	s6, s6, s16
 8013f0e:	eef8 3ae7 	vcvt.f32.s32	s7, s15
        IMAG(A, lda * i + i) = 0;
 8013f12:	f04f 0b00 	mov.w	fp, #0
 8013f16:	f10a 0c08 	add.w	ip, sl, #8
 8013f1a:	eb01 01c7 	add.w	r1, r1, r7, lsl #3
 8013f1e:	1d1c      	adds	r4, r3, #4
 8013f20:	3504      	adds	r5, #4
 8013f22:	ea4f 00c9 	mov.w	r0, r9, lsl #3
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013f26:	f04f 0e00 	mov.w	lr, #0
 8013f2a:	edd5 7a00 	vldr	s15, [r5]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013f2e:	ed55 6a01 	vldr	s13, [r5, #-4]
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013f32:	ed14 7a01 	vldr	s14, [r4, #-4]
        IMAG(A, lda * i + i) = 0;
 8013f36:	f8c4 b000 	str.w	fp, [r4]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 8013f3a:	ee23 4a27 	vmul.f32	s8, s6, s15
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8013f3e:	ee67 7aa3 	vmul.f32	s15, s15, s7
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 8013f42:	ee66 4a88 	vmul.f32	s9, s13, s16
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013f46:	ee64 7a67 	vnmul.f32	s15, s8, s15
      for (j = i + 1; j < N; j++) {
 8013f4a:	f10e 0e01 	add.w	lr, lr, #1
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013f4e:	eee6 7aa4 	vfma.f32	s15, s13, s9
      for (j = i + 1; j < N; j++) {
 8013f52:	4577      	cmp	r7, lr
        jx += incX;
 8013f54:	444e      	add	r6, r9
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 8013f56:	ee77 7a27 	vadd.f32	s15, s14, s15
 8013f5a:	ed44 7a01 	vstr	s15, [r4, #-4]
      for (j = i + 1; j < N; j++) {
 8013f5e:	f43f af15 	beq.w	8013d8c <cblas_cher+0x90>
 8013f62:	eb08 02c6 	add.w	r2, r8, r6, lsl #3
 8013f66:	1f23      	subs	r3, r4, #4
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8013f68:	edd2 7a01 	vldr	s15, [r2, #4]
        const BASE X_real = CONST_REAL(X, jx);
 8013f6c:	ed92 5a00 	vldr	s10, [r2]
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013f70:	ed93 7a02 	vldr	s14, [r3, #8]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013f74:	ed93 6a03 	vldr	s12, [r3, #12]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 8013f78:	ee63 7aa7 	vmul.f32	s15, s7, s15
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013f7c:	ee64 6a05 	vmul.f32	s13, s8, s10
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013f80:	ee67 5ac4 	vnmul.f32	s11, s15, s8
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013f84:	eee4 6aa7 	vfma.f32	s13, s9, s15
 8013f88:	3308      	adds	r3, #8
 8013f8a:	4402      	add	r2, r0
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013f8c:	eef0 7a65 	vmov.f32	s15, s11
 8013f90:	eee4 7a85 	vfma.f32	s15, s9, s10
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013f94:	ee76 6a26 	vadd.f32	s13, s12, s13
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013f98:	ee77 7a27 	vadd.f32	s15, s14, s15
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 8013f9c:	edc3 6a01 	vstr	s13, [r3, #4]
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 8013fa0:	edc3 7a00 	vstr	s15, [r3]
      for (j = i + 1; j < N; j++) {
 8013fa4:	4299      	cmp	r1, r3
 8013fa6:	d1df      	bne.n	8013f68 <cblas_cher+0x26c>
 8013fa8:	4451      	add	r1, sl
 8013faa:	4405      	add	r5, r0
 8013fac:	4464      	add	r4, ip
 8013fae:	e7bc      	b.n	8013f2a <cblas_cher+0x22e>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 8013fb0:	2e7a      	cmp	r6, #122	; 0x7a
 8013fb2:	d095      	beq.n	8013ee0 <cblas_cher+0x1e4>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 8013fb4:	2e79      	cmp	r6, #121	; 0x79
 8013fb6:	f47f aedf 	bne.w	8013d78 <cblas_cher+0x7c>
 8013fba:	e704      	b.n	8013dc6 <cblas_cher+0xca>
    INDEX ix = OFFSET(N, incX);
 8013fbc:	f1c7 0601 	rsb	r6, r7, #1
 8013fc0:	fb06 f609 	mul.w	r6, r6, r9
 8013fc4:	e790      	b.n	8013ee8 <cblas_cher+0x1ec>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 8013fc6:	2008      	movs	r0, #8
 8013fc8:	e6c8      	b.n	8013d5c <cblas_cher+0x60>
 8013fca:	bf00      	nop
 8013fcc:	08030378 	.word	0x08030378
 8013fd0:	08030710 	.word	0x08030710
 8013fd4:	080305a8 	.word	0x080305a8
 8013fd8:	00000000 	.word	0x00000000

08013fdc <cblas_cher2>:

void
cblas_cher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *X, const int incX,
             const void *Y, const int incY, void *A, const int lda)
{
 8013fdc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8013fe0:	ed2d 8b04 	vpush	{d8-d9}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i, j;
  const int conj = (order == CblasColMajor) ? -1 : 1;
 8013fe4:	2866      	cmp	r0, #102	; 0x66
 8013fe6:	b087      	sub	sp, #28
 8013fe8:	469a      	mov	sl, r3
 8013fea:	bf0c      	ite	eq
 8013fec:	f04f 33ff 	moveq.w	r3, #4294967295
 8013ff0:	2301      	movne	r3, #1
 8013ff2:	ee08 3a10 	vmov	s16, r3
 8013ff6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8013ff8:	9305      	str	r3, [sp, #20]
 8013ffa:	e9dd 5315 	ldrd	r5, r3, [sp, #84]	; 0x54
 8013ffe:	9302      	str	r3, [sp, #8]
 8014000:	e9dd 4317 	ldrd	r4, r3, [sp, #92]	; 0x5c
 8014004:	4689      	mov	r9, r1

  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 8014006:	3979      	subs	r1, #121	; 0x79
 8014008:	2901      	cmp	r1, #1
 801400a:	9f19      	ldr	r7, [sp, #100]	; 0x64
 801400c:	9200      	str	r2, [sp, #0]
 801400e:	4606      	mov	r6, r0
 8014010:	9301      	str	r3, [sp, #4]
 8014012:	f240 80f8 	bls.w	8014206 <cblas_cher2+0x22a>
 8014016:	2002      	movs	r0, #2
 8014018:	9b00      	ldr	r3, [sp, #0]
 801401a:	2b00      	cmp	r3, #0
 801401c:	f2c0 80e8 	blt.w	80141f0 <cblas_cher2+0x214>
 8014020:	2d00      	cmp	r5, #0
 8014022:	f040 80ce 	bne.w	80141c2 <cblas_cher2+0x1e6>
 8014026:	2c00      	cmp	r4, #0
 8014028:	f040 80d9 	bne.w	80141de <cblas_cher2+0x202>
 801402c:	9800      	ldr	r0, [sp, #0]
 801402e:	2801      	cmp	r0, #1
 8014030:	bfb8      	it	lt
 8014032:	2001      	movlt	r0, #1
 8014034:	4287      	cmp	r7, r0
 8014036:	bfb4      	ite	lt
 8014038:	200a      	movlt	r0, #10
 801403a:	2008      	movge	r0, #8
 801403c:	4acc      	ldr	r2, [pc, #816]	; (8014370 <cblas_cher2+0x394>)
 801403e:	49cd      	ldr	r1, [pc, #820]	; (8014374 <cblas_cher2+0x398>)
 8014040:	f013 fd02 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8014044:	edda 4a00 	vldr	s9, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8014048:	ed9a 4a01 	vldr	s8, [sl, #4]

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801404c:	eef5 4a40 	vcmp.f32	s9, #0.0
 8014050:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014054:	d105      	bne.n	8014062 <cblas_cher2+0x86>
 8014056:	eeb5 4a40 	vcmp.f32	s8, #0.0
 801405a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801405e:	f000 80ab 	beq.w	80141b8 <cblas_cher2+0x1dc>
      return;

    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014062:	2e65      	cmp	r6, #101	; 0x65
 8014064:	f000 80d5 	beq.w	8014212 <cblas_cher2+0x236>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8014068:	2e66      	cmp	r6, #102	; 0x66
 801406a:	d009      	beq.n	8014080 <cblas_cher2+0xa4>

        ix += incX;
        iy += incY;
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 801406c:	4ac2      	ldr	r2, [pc, #776]	; (8014378 <cblas_cher2+0x39c>)
 801406e:	49c1      	ldr	r1, [pc, #772]	; (8014374 <cblas_cher2+0x398>)
 8014070:	2000      	movs	r0, #0
#define BASE float
#include "source_her2.h"
#undef BASE
}
 8014072:	b007      	add	sp, #28
 8014074:	ecbd 8b04 	vpop	{d8-d9}
 8014078:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801407c:	f013 bce4 	b.w	8027a48 <cblas_xerbla>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 8014080:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8014084:	f000 80cd 	beq.w	8014222 <cblas_cher2+0x246>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 8014088:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 801408c:	d1ee      	bne.n	801406c <cblas_cher2+0x90>
      INDEX ix = OFFSET(N, incX);
 801408e:	2d00      	cmp	r5, #0
 8014090:	bfdd      	ittte	le
 8014092:	9b00      	ldrle	r3, [sp, #0]
 8014094:	f1c3 0101 	rsble	r1, r3, #1
 8014098:	4369      	mulle	r1, r5
 801409a:	2100      	movgt	r1, #0
      INDEX iy = OFFSET(N, incY);
 801409c:	2c00      	cmp	r4, #0
 801409e:	bfdc      	itt	le
 80140a0:	9b00      	ldrle	r3, [sp, #0]
 80140a2:	f1c3 0201 	rsble	r2, r3, #1
      for (i = 0; i < N; i++) {
 80140a6:	9b00      	ldr	r3, [sp, #0]
      INDEX iy = OFFSET(N, incY);
 80140a8:	bfd4      	ite	le
 80140aa:	4362      	mulle	r2, r4
 80140ac:	2200      	movgt	r2, #0
      for (i = 0; i < N; i++) {
 80140ae:	2b00      	cmp	r3, #0
 80140b0:	f340 8082 	ble.w	80141b8 <cblas_cher2+0x1dc>
 80140b4:	9b05      	ldr	r3, [sp, #20]
        IMAG(A, lda * i + i) = 0;
 80140b6:	ed9f 0ab1 	vldr	s0, [pc, #708]	; 801437c <cblas_cher2+0x3a0>
 80140ba:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 80140be:	9902      	ldr	r1, [sp, #8]
 80140c0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 80140c4:	9202      	str	r2, [sp, #8]
      for (i = 0; i < N; i++) {
 80140c6:	4692      	mov	sl, r2
 80140c8:	9a01      	ldr	r2, [sp, #4]
 80140ca:	4699      	mov	r9, r3
 80140cc:	f107 0b01 	add.w	fp, r7, #1
 80140d0:	f04f 0800 	mov.w	r8, #0
 80140d4:	4694      	mov	ip, r2
 80140d6:	3204      	adds	r2, #4
 80140d8:	00ed      	lsls	r5, r5, #3
 80140da:	00e4      	lsls	r4, r4, #3
 80140dc:	ea4f 0bcb 	mov.w	fp, fp, lsl #3
 80140e0:	eef1 0a44 	vneg.f32	s1, s8
 80140e4:	9203      	str	r2, [sp, #12]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 80140e6:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
 80140ea:	4643      	mov	r3, r8
 80140ec:	46ce      	mov	lr, r9
        const BASE Xi_imag = CONST_IMAG(X, ix);
 80140ee:	ed99 5a01 	vldr	s10, [r9, #4]
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 80140f2:	ed9a 9a01 	vldr	s18, [sl, #4]
        const BASE Xi_real = CONST_REAL(X, ix);
 80140f6:	edd9 7a00 	vldr	s15, [r9]
        const BASE Yi_real = CONST_REAL(Y, iy);
 80140fa:	edda 8a00 	vldr	s17, [sl]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 80140fe:	ee65 2a44 	vnmul.f32	s5, s10, s8
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 8014102:	ee24 2a09 	vmul.f32	s4, s8, s18
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014106:	ee24 5a85 	vmul.f32	s10, s9, s10
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801410a:	ee64 1a89 	vmul.f32	s3, s9, s18
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801410e:	eee4 2aa7 	vfma.f32	s5, s9, s15
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014112:	eea4 5a27 	vfma.f32	s10, s8, s15
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 8014116:	eea4 2aa8 	vfma.f32	s4, s9, s17
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801411a:	eee8 1aa0 	vfma.f32	s3, s17, s1
        for (j = 0; j < i; j++) {
 801411e:	b3bb      	cbz	r3, 8014190 <cblas_cher2+0x1b4>
 8014120:	9903      	ldr	r1, [sp, #12]
 8014122:	9a01      	ldr	r2, [sp, #4]
 8014124:	9802      	ldr	r0, [sp, #8]
 8014126:	eef8 9ac8 	vcvt.f32.s32	s19, s16
 801412a:	eb01 06c8 	add.w	r6, r1, r8, lsl #3
 801412e:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 8014132:	4671      	mov	r1, lr
          const BASE Xj_imag = CONST_IMAG(X, jx);
 8014134:	ed91 7a01 	vldr	s14, [r1, #4]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 8014138:	edd0 7a01 	vldr	s15, [r0, #4]
          const BASE Xj_real = CONST_REAL(X, jx);
 801413c:	ed91 3a00 	vldr	s6, [r1]
          const BASE Yj_real = CONST_REAL(Y, jy);
 8014140:	edd0 3a00 	vldr	s7, [r0]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014144:	ed16 6a01 	vldr	s12, [r6, #-4]
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014148:	ee61 5a87 	vmul.f32	s11, s3, s14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801414c:	ee65 6a27 	vmul.f32	s13, s10, s15
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014150:	eee2 5a03 	vfma.f32	s11, s4, s6
 8014154:	3208      	adds	r2, #8
 8014156:	4429      	add	r1, r5
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014158:	eee2 6aa3 	vfma.f32	s13, s5, s7
 801415c:	4420      	add	r0, r4
 801415e:	3608      	adds	r6, #8
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014160:	ee27 7a42 	vnmul.f32	s14, s14, s4
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014164:	ee67 7ae2 	vnmul.f32	s15, s15, s5
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014168:	ee76 6aa5 	vadd.f32	s13, s13, s11
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801416c:	eea1 7a83 	vfma.f32	s14, s3, s6
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014170:	eee5 7a23 	vfma.f32	s15, s10, s7
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014174:	ee76 6a26 	vadd.f32	s13, s12, s13
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014178:	ee77 7a87 	vadd.f32	s15, s15, s14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801417c:	ed46 6a03 	vstr	s13, [r6, #-12]
          IMAG(A, lda * i + j) +=
 8014180:	ed12 7a01 	vldr	s14, [r2, #-4]
 8014184:	eea7 7aa9 	vfma.f32	s14, s15, s19
 8014188:	ed02 7a01 	vstr	s14, [r2, #-4]
        for (j = 0; j < i; j++) {
 801418c:	4594      	cmp	ip, r2
 801418e:	d1d1      	bne.n	8014134 <cblas_cher2+0x158>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014190:	ee25 5a09 	vmul.f32	s10, s10, s18
 8014194:	eddc 7a00 	vldr	s15, [ip]
      for (i = 0; i < N; i++) {
 8014198:	9a00      	ldr	r2, [sp, #0]
        IMAG(A, lda * i + i) = 0;
 801419a:	ed8c 0a01 	vstr	s0, [ip, #4]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801419e:	eea2 5aa8 	vfma.f32	s10, s5, s17
      for (i = 0; i < N; i++) {
 80141a2:	3301      	adds	r3, #1
 80141a4:	429a      	cmp	r2, r3
 80141a6:	44a9      	add	r9, r5
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 80141a8:	eee5 7a01 	vfma.f32	s15, s10, s2
 80141ac:	44a2      	add	sl, r4
 80141ae:	44b8      	add	r8, r7
 80141b0:	edcc 7a00 	vstr	s15, [ip]
      for (i = 0; i < N; i++) {
 80141b4:	44dc      	add	ip, fp
 80141b6:	d19a      	bne.n	80140ee <cblas_cher2+0x112>
 80141b8:	b007      	add	sp, #28
 80141ba:	ecbd 8b04 	vpop	{d8-d9}
 80141be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 80141c2:	2c00      	cmp	r4, #0
 80141c4:	f43f af32 	beq.w	801402c <cblas_cher2+0x50>
 80141c8:	9a00      	ldr	r2, [sp, #0]
 80141ca:	2a01      	cmp	r2, #1
 80141cc:	bfb8      	it	lt
 80141ce:	2201      	movlt	r2, #1
 80141d0:	42ba      	cmp	r2, r7
 80141d2:	f300 80cb 	bgt.w	801436c <cblas_cher2+0x390>
 80141d6:	2800      	cmp	r0, #0
 80141d8:	f43f af34 	beq.w	8014044 <cblas_cher2+0x68>
 80141dc:	e72e      	b.n	801403c <cblas_cher2+0x60>
 80141de:	9800      	ldr	r0, [sp, #0]
 80141e0:	2801      	cmp	r0, #1
 80141e2:	bfb8      	it	lt
 80141e4:	2001      	movlt	r0, #1
 80141e6:	4287      	cmp	r7, r0
 80141e8:	bfb4      	ite	lt
 80141ea:	200a      	movlt	r0, #10
 80141ec:	2006      	movge	r0, #6
 80141ee:	e725      	b.n	801403c <cblas_cher2+0x60>
 80141f0:	2d00      	cmp	r5, #0
 80141f2:	f43f af18 	beq.w	8014026 <cblas_cher2+0x4a>
 80141f6:	2c00      	cmp	r4, #0
 80141f8:	f43f af18 	beq.w	801402c <cblas_cher2+0x50>
 80141fc:	2f00      	cmp	r7, #0
 80141fe:	bfd4      	ite	le
 8014200:	200a      	movle	r0, #10
 8014202:	2003      	movgt	r0, #3
 8014204:	e71a      	b.n	801403c <cblas_cher2+0x60>
 8014206:	3865      	subs	r0, #101	; 0x65
 8014208:	2801      	cmp	r0, #1
 801420a:	bf94      	ite	ls
 801420c:	2000      	movls	r0, #0
 801420e:	2001      	movhi	r0, #1
 8014210:	e702      	b.n	8014018 <cblas_cher2+0x3c>
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 8014212:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8014216:	d004      	beq.n	8014222 <cblas_cher2+0x246>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 8014218:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 801421c:	f47f af26 	bne.w	801406c <cblas_cher2+0x90>
 8014220:	e735      	b.n	801408e <cblas_cher2+0xb2>
      INDEX ix = OFFSET(N, incX);
 8014222:	2d00      	cmp	r5, #0
 8014224:	bfdd      	ittte	le
 8014226:	9b00      	ldrle	r3, [sp, #0]
 8014228:	f1c3 0a01 	rsble	sl, r3, #1
 801422c:	fb0a fa05 	mulle.w	sl, sl, r5
 8014230:	f04f 0a00 	movgt.w	sl, #0
      INDEX iy = OFFSET(N, incY);
 8014234:	2c00      	cmp	r4, #0
 8014236:	f340 8093 	ble.w	8014360 <cblas_cher2+0x384>
 801423a:	f04f 0b00 	mov.w	fp, #0
      for (i = 0; i < N; i++) {
 801423e:	9b00      	ldr	r3, [sp, #0]
 8014240:	2b00      	cmp	r3, #0
 8014242:	ddb9      	ble.n	80141b8 <cblas_cher2+0x1dc>
 8014244:	00fb      	lsls	r3, r7, #3
 8014246:	9a01      	ldr	r2, [sp, #4]
 8014248:	9304      	str	r3, [sp, #16]
 801424a:	3308      	adds	r3, #8
 801424c:	9303      	str	r3, [sp, #12]
 801424e:	9b00      	ldr	r3, [sp, #0]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014250:	9501      	str	r5, [sp, #4]
 8014252:	f1a2 0008 	sub.w	r0, r2, #8
 8014256:	00ef      	lsls	r7, r5, #3
 8014258:	00e6      	lsls	r6, r4, #3
 801425a:	9d02      	ldr	r5, [sp, #8]
        IMAG(A, lda * i + i) = 0;
 801425c:	eddf 8a47 	vldr	s17, [pc, #284]	; 801437c <cblas_cher2+0x3a0>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 8014260:	9402      	str	r4, [sp, #8]
 8014262:	9c05      	ldr	r4, [sp, #20]
 8014264:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 8014268:	f102 0c04 	add.w	ip, r2, #4
 801426c:	eeb1 0a44 	vneg.f32	s0, s8
      for (i = 0; i < N; i++) {
 8014270:	f04f 0800 	mov.w	r8, #0
 8014274:	ea4f 09ca 	mov.w	r9, sl, lsl #3
 8014278:	ea4f 0ecb 	mov.w	lr, fp, lsl #3
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801427c:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
        const BASE Xi_real = CONST_REAL(X, ix);
 8014280:	44a1      	add	r9, r4
        const BASE Xi_imag = CONST_IMAG(X, ix);
 8014282:	edd9 2a01 	vldr	s5, [r9, #4]
        const BASE Xi_real = CONST_REAL(X, ix);
 8014286:	edd9 7a00 	vldr	s15, [r9]
        INDEX jx = ix + incX;
 801428a:	9b01      	ldr	r3, [sp, #4]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801428c:	ed1c 7a01 	vldr	s14, [ip, #-4]
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014290:	ee24 9aa2 	vmul.f32	s18, s9, s5
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 8014294:	ee62 2ac4 	vnmul.f32	s5, s5, s8
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 8014298:	eea4 9a27 	vfma.f32	s18, s8, s15
 801429c:	44ae      	add	lr, r5
        INDEX jx = ix + incX;
 801429e:	449a      	add	sl, r3
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 80142a0:	ed9e 2a01 	vldr	s4, [lr, #4]
        INDEX jy = iy + incY;
 80142a4:	9b02      	ldr	r3, [sp, #8]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 80142a6:	eee4 2aa7 	vfma.f32	s5, s9, s15
        INDEX jy = iy + incY;
 80142aa:	449b      	add	fp, r3
        for (j = i + 1; j < N; j++) {
 80142ac:	9b00      	ldr	r3, [sp, #0]
        const BASE Yi_real = CONST_REAL(Y, iy);
 80142ae:	edde 7a00 	vldr	s15, [lr]
        IMAG(A, lda * i + i) = 0;
 80142b2:	edcc 8a00 	vstr	s17, [ip]
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 80142b6:	ee69 6a02 	vmul.f32	s13, s18, s4
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 80142ba:	ee64 1a02 	vmul.f32	s3, s8, s4
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 80142be:	eee2 6aa7 	vfma.f32	s13, s5, s15
        for (j = i + 1; j < N; j++) {
 80142c2:	f108 0801 	add.w	r8, r8, #1
 80142c6:	4543      	cmp	r3, r8
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 80142c8:	ee24 2a82 	vmul.f32	s4, s9, s4
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 80142cc:	eea6 7aa0 	vfma.f32	s14, s13, s1
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 80142d0:	eee4 1aa7 	vfma.f32	s3, s9, s15
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 80142d4:	eea7 2a80 	vfma.f32	s4, s15, s0
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 80142d8:	ed0c 7a01 	vstr	s14, [ip, #-4]
        for (j = i + 1; j < N; j++) {
 80142dc:	f43f af6c 	beq.w	80141b8 <cblas_cher2+0x1dc>
 80142e0:	eeb8 1ac8 	vcvt.f32.s32	s2, s16
 80142e4:	ea4f 09ca 	mov.w	r9, sl, lsl #3
 80142e8:	eb04 01ca 	add.w	r1, r4, sl, lsl #3
 80142ec:	ea4f 0ecb 	mov.w	lr, fp, lsl #3
 80142f0:	eb05 02cb 	add.w	r2, r5, fp, lsl #3
 80142f4:	f1ac 0304 	sub.w	r3, ip, #4
          const BASE Xj_imag = CONST_IMAG(X, jx);
 80142f8:	ed91 7a01 	vldr	s14, [r1, #4]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 80142fc:	edd2 7a01 	vldr	s15, [r2, #4]
          const BASE Xj_real = CONST_REAL(X, jx);
 8014300:	ed91 3a00 	vldr	s6, [r1]
          const BASE Yj_real = CONST_REAL(Y, jy);
 8014304:	edd2 3a00 	vldr	s7, [r2]
          IMAG(A, lda * i + j) +=
 8014308:	edd3 5a03 	vldr	s11, [r3, #12]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801430c:	ed93 6a02 	vldr	s12, [r3, #8]
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014310:	ee27 5a61 	vnmul.f32	s10, s14, s3
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014314:	ee67 6ae2 	vnmul.f32	s13, s15, s5
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 8014318:	ee22 7a07 	vmul.f32	s14, s4, s14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801431c:	ee69 7a27 	vmul.f32	s15, s18, s15
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 8014320:	eea2 5a03 	vfma.f32	s10, s4, s6
 8014324:	3308      	adds	r3, #8
 8014326:	4439      	add	r1, r7
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014328:	eee9 6a23 	vfma.f32	s13, s18, s7
 801432c:	4432      	add	r2, r6
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801432e:	eea1 7a83 	vfma.f32	s14, s3, s6
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014332:	eee2 7aa3 	vfma.f32	s15, s5, s7
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 8014336:	ee76 6a85 	vadd.f32	s13, s13, s10
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801433a:	ee77 7a87 	vadd.f32	s15, s15, s14
          IMAG(A, lda * i + j) +=
 801433e:	eeb0 7a65 	vmov.f32	s14, s11
 8014342:	eea6 7a81 	vfma.f32	s14, s13, s2
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 8014346:	ee76 7a27 	vadd.f32	s15, s12, s15
          IMAG(A, lda * i + j) +=
 801434a:	ed83 7a01 	vstr	s14, [r3, #4]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801434e:	edc3 7a00 	vstr	s15, [r3]
        for (j = i + 1; j < N; j++) {
 8014352:	4298      	cmp	r0, r3
 8014354:	d1d0      	bne.n	80142f8 <cblas_cher2+0x31c>
 8014356:	9b04      	ldr	r3, [sp, #16]
 8014358:	4418      	add	r0, r3
 801435a:	9b03      	ldr	r3, [sp, #12]
 801435c:	449c      	add	ip, r3
 801435e:	e78f      	b.n	8014280 <cblas_cher2+0x2a4>
      INDEX iy = OFFSET(N, incY);
 8014360:	9b00      	ldr	r3, [sp, #0]
 8014362:	f1c3 0b01 	rsb	fp, r3, #1
 8014366:	fb0b fb04 	mul.w	fp, fp, r4
 801436a:	e768      	b.n	801423e <cblas_cher2+0x262>
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801436c:	200a      	movs	r0, #10
 801436e:	e665      	b.n	801403c <cblas_cher2+0x60>
 8014370:	08030378 	.word	0x08030378
 8014374:	08030720 	.word	0x08030720
 8014378:	080305a8 	.word	0x080305a8
 801437c:	00000000 	.word	0x00000000

08014380 <cblas_cher2k>:
void
cblas_cher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const float beta, void *C, const int ldc)
{
 8014380:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014384:	ed2d 8b02 	vpush	{d8}
 8014388:	b08f      	sub	sp, #60	; 0x3c
 801438a:	461e      	mov	r6, r3
 801438c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801438e:	9303      	str	r3, [sp, #12]
 8014390:	e9dd 831b 	ldrd	r8, r3, [sp, #108]	; 0x6c
 8014394:	9301      	str	r3, [sp, #4]
 8014396:	e9dd b31d 	ldrd	fp, r3, [sp, #116]	; 0x74
 801439a:	9300      	str	r3, [sp, #0]
 801439c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801439e:	9304      	str	r3, [sp, #16]

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80143a0:	2865      	cmp	r0, #101	; 0x65
 80143a2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80143a4:	f8dd a084 	ldr.w	sl, [sp, #132]	; 0x84
 80143a8:	9302      	str	r3, [sp, #8]
 80143aa:	4607      	mov	r7, r0
 80143ac:	460d      	mov	r5, r1
 80143ae:	4614      	mov	r4, r2
 80143b0:	eeb0 8a40 	vmov.f32	s16, s0
 80143b4:	f000 824c 	beq.w	8014850 <cblas_cher2k+0x4d0>
 80143b8:	2a6f      	cmp	r2, #111	; 0x6f
 80143ba:	f000 8090 	beq.w	80144de <cblas_cher2k+0x15e>
 80143be:	9b03      	ldr	r3, [sp, #12]
 80143c0:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 80143c4:	2a01      	cmp	r2, #1
 80143c6:	f240 81fa 	bls.w	80147be <cblas_cher2k+0x43e>
 80143ca:	2002      	movs	r0, #2
 80143cc:	f1a4 026f 	sub.w	r2, r4, #111	; 0x6f
 80143d0:	2a02      	cmp	r2, #2
 80143d2:	bf88      	it	hi
 80143d4:	2003      	movhi	r0, #3
 80143d6:	9a03      	ldr	r2, [sp, #12]
 80143d8:	2e00      	cmp	r6, #0
 80143da:	bfb8      	it	lt
 80143dc:	2004      	movlt	r0, #4
 80143de:	2a00      	cmp	r2, #0
 80143e0:	bfb8      	it	lt
 80143e2:	2005      	movlt	r0, #5
 80143e4:	2b01      	cmp	r3, #1
 80143e6:	bfb8      	it	lt
 80143e8:	2301      	movlt	r3, #1
 80143ea:	455b      	cmp	r3, fp
 80143ec:	9a04      	ldr	r2, [sp, #16]
 80143ee:	f340 81d1 	ble.w	8014794 <cblas_cher2k+0x414>
 80143f2:	4293      	cmp	r3, r2
 80143f4:	f300 81da 	bgt.w	80147ac <cblas_cher2k+0x42c>
 80143f8:	2e01      	cmp	r6, #1
 80143fa:	4630      	mov	r0, r6
 80143fc:	bfb8      	it	lt
 80143fe:	2001      	movlt	r0, #1
 8014400:	4550      	cmp	r0, sl
 8014402:	bfcc      	ite	gt
 8014404:	200e      	movgt	r0, #14
 8014406:	2008      	movle	r0, #8
 8014408:	4ade      	ldr	r2, [pc, #888]	; (8014784 <cblas_cher2k+0x404>)
 801440a:	49df      	ldr	r1, [pc, #892]	; (8014788 <cblas_cher2k+0x408>)
 801440c:	f013 fb1c 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
    BASE alpha_imag = CONST_IMAG0(alpha);

    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 8014410:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014414:	eeb4 8a67 	vcmp.f32	s16, s15
 8014418:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    const BASE alpha_real = CONST_REAL0(alpha);
 801441c:	edd8 6a00 	vldr	s13, [r8]
    BASE alpha_imag = CONST_IMAG0(alpha);
 8014420:	ed98 7a01 	vldr	s14, [r8, #4]
    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 8014424:	d10e      	bne.n	8014444 <cblas_cher2k+0xc4>
 8014426:	eef5 6a40 	vcmp.f32	s13, #0.0
 801442a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801442e:	d105      	bne.n	801443c <cblas_cher2k+0xbc>
 8014430:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8014434:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014438:	f000 819f 	beq.w	801477a <cblas_cher2k+0x3fa>
 801443c:	9b03      	ldr	r3, [sp, #12]
 801443e:	2b00      	cmp	r3, #0
 8014440:	f000 819b 	beq.w	801477a <cblas_cher2k+0x3fa>
      return;

    if (Order == CblasRowMajor) {
 8014444:	2f65      	cmp	r7, #101	; 0x65
 8014446:	f000 8208 	beq.w	801485a <cblas_cher2k+0x4da>
      uplo = Uplo;
      trans = Trans;
    } else {
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801444a:	2d79      	cmp	r5, #121	; 0x79
 801444c:	bf0c      	ite	eq
 801444e:	f04f 0e7a 	moveq.w	lr, #122	; 0x7a
 8014452:	f04f 0e79 	movne.w	lr, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8014456:	2c6f      	cmp	r4, #111	; 0x6f
      alpha_imag *= -1;           /* conjugate alpha */
 8014458:	eeb1 7a47 	vneg.f32	s14, s14
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801445c:	bf0c      	ite	eq
 801445e:	f04f 0871 	moveq.w	r8, #113	; 0x71
 8014462:	f04f 086f 	movne.w	r8, #111	; 0x6f
    }

    /* form  C := beta*C */

    if (beta == 0.0) {
 8014466:	eeb5 8a40 	vcmp.f32	s16, #0.0
 801446a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801446e:	f040 81ad 	bne.w	80147cc <cblas_cher2k+0x44c>
      if (uplo == CblasUpper) {
 8014472:	f1be 0f79 	cmp.w	lr, #121	; 0x79
 8014476:	d03a      	beq.n	80144ee <cblas_cher2k+0x16e>
            REAL(C, ldc * i + j) = 0.0;
            IMAG(C, ldc * i + j) = 0.0;
          }
        }
      } else {
        for (i = 0; i < N; i++) {
 8014478:	2e00      	cmp	r6, #0
 801447a:	dd14      	ble.n	80144a6 <cblas_cher2k+0x126>
 801447c:	9f02      	ldr	r7, [sp, #8]
 801447e:	f10a 0401 	add.w	r4, sl, #1
 8014482:	2100      	movs	r1, #0
          for (j = 0; j <= i; j++) {
            REAL(C, ldc * i + j) = 0.0;
 8014484:	2500      	movs	r5, #0
 8014486:	00e4      	lsls	r4, r4, #3
        for (i = 0; i < N; i++) {
 8014488:	4608      	mov	r0, r1
 801448a:	f107 0208 	add.w	r2, r7, #8
 801448e:	eb07 03c1 	add.w	r3, r7, r1, lsl #3
            REAL(C, ldc * i + j) = 0.0;
 8014492:	601d      	str	r5, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 8014494:	605d      	str	r5, [r3, #4]
          for (j = 0; j <= i; j++) {
 8014496:	3308      	adds	r3, #8
 8014498:	429a      	cmp	r2, r3
 801449a:	d1fa      	bne.n	8014492 <cblas_cher2k+0x112>
        for (i = 0; i < N; i++) {
 801449c:	3001      	adds	r0, #1
 801449e:	4286      	cmp	r6, r0
 80144a0:	4451      	add	r1, sl
 80144a2:	4422      	add	r2, r4
 80144a4:	d1f3      	bne.n	801448e <cblas_cher2k+0x10e>
      for (i = 0; i < N; i++) {
        IMAG(C, ldc * i + i) = 0.0;
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80144a6:	eef5 6a40 	vcmp.f32	s13, #0.0
 80144aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144ae:	d108      	bne.n	80144c2 <cblas_cher2k+0x142>
 80144b0:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80144b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80144b8:	f000 815f 	beq.w	801477a <cblas_cher2k+0x3fa>
      return;

    if (uplo == CblasUpper && trans == CblasNoTrans) {
 80144bc:	f1be 0f79 	cmp.w	lr, #121	; 0x79
 80144c0:	d02f      	beq.n	8014522 <cblas_cher2k+0x1a2>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
          }
        }
      }

    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80144c2:	f1be 0f7a 	cmp.w	lr, #122	; 0x7a
 80144c6:	f000 80b9 	beq.w	801463c <cblas_cher2k+0x2bc>
            IMAG(C, i * lda + i) = 0.0;
          }
        }
      }
    } else {
      BLAS_ERROR("unrecognized operation");
 80144ca:	4ab0      	ldr	r2, [pc, #704]	; (801478c <cblas_cher2k+0x40c>)
 80144cc:	49ae      	ldr	r1, [pc, #696]	; (8014788 <cblas_cher2k+0x408>)
 80144ce:	2000      	movs	r0, #0
#define BASE float
#include "source_her2k.h"
#undef BASE
}
 80144d0:	b00f      	add	sp, #60	; 0x3c
 80144d2:	ecbd 8b02 	vpop	{d8}
 80144d6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80144da:	f013 bab5 	b.w	8027a48 <cblas_xerbla>
 80144de:	4633      	mov	r3, r6
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 80144e0:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 80144e4:	2a01      	cmp	r2, #1
 80144e6:	f240 816a 	bls.w	80147be <cblas_cher2k+0x43e>
 80144ea:	2002      	movs	r0, #2
 80144ec:	e773      	b.n	80143d6 <cblas_cher2k+0x56>
        for (i = 0; i < N; i++) {
 80144ee:	2e00      	cmp	r6, #0
 80144f0:	dd12      	ble.n	8014518 <cblas_cher2k+0x198>
 80144f2:	f10a 0401 	add.w	r4, sl, #1
 80144f6:	9802      	ldr	r0, [sp, #8]
            REAL(C, ldc * i + j) = 0.0;
 80144f8:	2500      	movs	r5, #0
 80144fa:	00e4      	lsls	r4, r4, #3
        for (i = 0; i < N; i++) {
 80144fc:	2100      	movs	r1, #0
 80144fe:	4603      	mov	r3, r0
 8014500:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 8014502:	3201      	adds	r2, #1
 8014504:	4296      	cmp	r6, r2
            REAL(C, ldc * i + j) = 0.0;
 8014506:	601d      	str	r5, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 8014508:	605d      	str	r5, [r3, #4]
          for (j = i; j < N; j++) {
 801450a:	f103 0308 	add.w	r3, r3, #8
 801450e:	dcf8      	bgt.n	8014502 <cblas_cher2k+0x182>
        for (i = 0; i < N; i++) {
 8014510:	3101      	adds	r1, #1
 8014512:	428e      	cmp	r6, r1
 8014514:	4420      	add	r0, r4
 8014516:	d1f2      	bne.n	80144fe <cblas_cher2k+0x17e>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8014518:	eef5 6a40 	vcmp.f32	s13, #0.0
 801451c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014520:	d0c6      	beq.n	80144b0 <cblas_cher2k+0x130>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8014522:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8014526:	f000 81b1 	beq.w	801488c <cblas_cher2k+0x50c>
    } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 801452a:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 801452e:	d1cc      	bne.n	80144ca <cblas_cher2k+0x14a>
      for (k = 0; k < K; k++) {
 8014530:	9b03      	ldr	r3, [sp, #12]
 8014532:	2b00      	cmp	r3, #0
 8014534:	f340 8121 	ble.w	801477a <cblas_cher2k+0x3fa>
 8014538:	9b01      	ldr	r3, [sp, #4]
            IMAG(C, i * lda + i) = 0.0;
 801453a:	ed9f 8a95 	vldr	s16, [pc, #596]	; 8014790 <cblas_cher2k+0x410>
 801453e:	f1a3 0008 	sub.w	r0, r3, #8
      for (k = 0; k < K; k++) {
 8014542:	f04f 0800 	mov.w	r8, #0
 8014546:	f10b 0e01 	add.w	lr, fp, #1
 801454a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801454e:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
 8014552:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 8014556:	46c2      	mov	sl, r8
 8014558:	46c1      	mov	r9, r8
 801455a:	9305      	str	r3, [sp, #20]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801455c:	eef0 8a00 	vmov.f32	s17, #0	; 0x40000000  2.0
        for (i = 0; i < N; i++) {
 8014560:	2e00      	cmp	r6, #0
 8014562:	f340 8268 	ble.w	8014a36 <cblas_cher2k+0x6b6>
 8014566:	9b01      	ldr	r3, [sp, #4]
 8014568:	eb03 07ca 	add.w	r7, r3, sl, lsl #3
 801456c:	9b00      	ldr	r3, [sp, #0]
 801456e:	eb03 05c8 	add.w	r5, r3, r8, lsl #3
 8014572:	9b02      	ldr	r3, [sp, #8]
 8014574:	f04f 0c00 	mov.w	ip, #0
 8014578:	1d1c      	adds	r4, r3, #4
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801457a:	edd7 5a00 	vldr	s11, [r7]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801457e:	ed97 5a01 	vldr	s10, [r7, #4]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8014582:	edd5 1a01 	vldr	s3, [r5, #4]
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8014586:	edd5 7a00 	vldr	s15, [r5]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801458a:	ed14 6a01 	vldr	s12, [r4, #-4]
            IMAG(C, i * lda + i) = 0.0;
 801458e:	ed84 8a00 	vstr	s16, [r4]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 8014592:	ee27 0a25 	vmul.f32	s0, s14, s11
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 8014596:	ee67 0a05 	vmul.f32	s1, s14, s10
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801459a:	eea5 0a66 	vfms.f32	s0, s10, s13
          for (j = i + 1; j < N; j++) {
 801459e:	f10c 0c01 	add.w	ip, ip, #1
 80145a2:	4566      	cmp	r6, ip
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 80145a4:	eee6 0aa5 	vfma.f32	s1, s13, s11
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 80145a8:	ee60 5a61 	vnmul.f32	s11, s0, s3
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 80145ac:	ee27 1a27 	vmul.f32	s2, s14, s15
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 80145b0:	eee7 5aa0 	vfma.f32	s11, s15, s1
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 80145b4:	eea6 1aa1 	vfma.f32	s2, s13, s3
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 80145b8:	eea5 6aa8 	vfma.f32	s12, s11, s17
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80145bc:	ee61 1ac7 	vnmul.f32	s3, s3, s14
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 80145c0:	ed04 6a01 	vstr	s12, [r4, #-4]
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80145c4:	eee6 1aa7 	vfma.f32	s3, s13, s15
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 80145c8:	eeb1 1a41 	vneg.f32	s2, s2
          for (j = i + 1; j < N; j++) {
 80145cc:	f000 8233 	beq.w	8014a36 <cblas_cher2k+0x6b6>
 80145d0:	1f23      	subs	r3, r4, #4
 80145d2:	4629      	mov	r1, r5
 80145d4:	463a      	mov	r2, r7
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 80145d6:	edd2 2a02 	vldr	s5, [r2, #8]
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80145da:	ed92 2a03 	vldr	s4, [r2, #12]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 80145de:	ed91 3a02 	vldr	s6, [r1, #8]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80145e2:	edd1 3a03 	vldr	s7, [r1, #12]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80145e6:	ed93 5a02 	vldr	s10, [r3, #8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80145ea:	edd3 5a03 	vldr	s11, [r3, #12]
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80145ee:	ee61 4a22 	vmul.f32	s9, s2, s5
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80145f2:	ee22 4a41 	vnmul.f32	s8, s4, s2
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80145f6:	ee23 6ac0 	vnmul.f32	s12, s7, s0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80145fa:	ee60 7a03 	vmul.f32	s15, s0, s6
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80145fe:	eee1 4a82 	vfma.f32	s9, s3, s4
 8014602:	3208      	adds	r2, #8
          for (j = i + 1; j < N; j++) {
 8014604:	4290      	cmp	r0, r2
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8014606:	eea1 4aa2 	vfma.f32	s8, s3, s5
 801460a:	f101 0108 	add.w	r1, r1, #8
 801460e:	f103 0308 	add.w	r3, r3, #8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8014612:	eea0 6a83 	vfma.f32	s12, s1, s6
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8014616:	eee0 7aa3 	vfma.f32	s15, s1, s7
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801461a:	ee36 6a04 	vadd.f32	s12, s12, s8
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801461e:	ee77 7aa4 	vadd.f32	s15, s15, s9
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8014622:	ee35 6a06 	vadd.f32	s12, s10, s12
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8014626:	ee75 7aa7 	vadd.f32	s15, s11, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801462a:	ed83 6a00 	vstr	s12, [r3]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801462e:	edc3 7a01 	vstr	s15, [r3, #4]
          for (j = i + 1; j < N; j++) {
 8014632:	d1d0      	bne.n	80145d6 <cblas_cher2k+0x256>
 8014634:	3708      	adds	r7, #8
 8014636:	3508      	adds	r5, #8
 8014638:	4474      	add	r4, lr
 801463a:	e79e      	b.n	801457a <cblas_cher2k+0x1fa>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801463c:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8014640:	f000 823d 	beq.w	8014abe <cblas_cher2k+0x73e>
    } else if (uplo == CblasLower && trans == CblasConjTrans) {
 8014644:	f1b8 0f71 	cmp.w	r8, #113	; 0x71
 8014648:	f47f af3f 	bne.w	80144ca <cblas_cher2k+0x14a>
      for (k = 0; k < K; k++) {
 801464c:	9b03      	ldr	r3, [sp, #12]
 801464e:	2b00      	cmp	r3, #0
 8014650:	f340 8093 	ble.w	801477a <cblas_cher2k+0x3fa>
 8014654:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8014658:	9307      	str	r3, [sp, #28]
 801465a:	f103 0a08 	add.w	sl, r3, #8
 801465e:	9b02      	ldr	r3, [sp, #8]
            IMAG(C, i * lda + i) = 0.0;
 8014660:	ed9f 1a4b 	vldr	s2, [pc, #300]	; 8014790 <cblas_cher2k+0x410>
 8014664:	f8dd 8004 	ldr.w	r8, [sp, #4]
      for (k = 0; k < K; k++) {
 8014668:	2200      	movs	r2, #0
 801466a:	3304      	adds	r3, #4
 801466c:	9205      	str	r2, [sp, #20]
 801466e:	9206      	str	r2, [sp, #24]
 8014670:	9301      	str	r3, [sp, #4]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8014672:	eef0 0a00 	vmov.f32	s1, #0	; 0x40000000  2.0
        for (i = 0; i < N; i++) {
 8014676:	2e00      	cmp	r6, #0
 8014678:	dd72      	ble.n	8014760 <cblas_cher2k+0x3e0>
 801467a:	9b00      	ldr	r3, [sp, #0]
 801467c:	9a05      	ldr	r2, [sp, #20]
 801467e:	9d01      	ldr	r5, [sp, #4]
 8014680:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
 8014684:	f04f 0e00 	mov.w	lr, #0
 8014688:	46cc      	mov	ip, r9
 801468a:	4677      	mov	r7, lr
 801468c:	4644      	mov	r4, r8
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801468e:	ed9c 0a00 	vldr	s0, [ip]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8014692:	ed9c 8a01 	vldr	s16, [ip, #4]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8014696:	edd4 7a00 	vldr	s15, [r4]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801469a:	ed94 6a01 	vldr	s12, [r4, #4]
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801469e:	ee67 2a00 	vmul.f32	s5, s14, s0
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80146a2:	ee68 1a47 	vnmul.f32	s3, s16, s14
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 80146a6:	eee6 2a88 	vfma.f32	s5, s13, s16
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 80146aa:	ee27 3a27 	vmul.f32	s6, s14, s15
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 80146ae:	ee27 2a06 	vmul.f32	s4, s14, s12
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80146b2:	eee6 1a80 	vfma.f32	s3, s13, s0
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 80146b6:	eea6 3a66 	vfms.f32	s6, s12, s13
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 80146ba:	eea6 2aa7 	vfma.f32	s4, s13, s15
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 80146be:	eef1 2a62 	vneg.f32	s5, s5
          for (j = 0; j < i; j++) {
 80146c2:	b3c7      	cbz	r7, 8014736 <cblas_cher2k+0x3b6>
 80146c4:	9b02      	ldr	r3, [sp, #8]
 80146c6:	eb03 00ce 	add.w	r0, r3, lr, lsl #3
 80146ca:	9b01      	ldr	r3, [sp, #4]
 80146cc:	464a      	mov	r2, r9
 80146ce:	eb03 01ce 	add.w	r1, r3, lr, lsl #3
 80146d2:	4643      	mov	r3, r8
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80146d4:	edd3 3a01 	vldr	s7, [r3, #4]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80146d8:	ed92 4a01 	vldr	s8, [r2, #4]
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 80146dc:	ed93 6a00 	vldr	s12, [r3]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 80146e0:	edd2 7a00 	vldr	s15, [r2]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80146e4:	ed11 5a01 	vldr	s10, [r1, #-4]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80146e8:	ee63 4ae2 	vnmul.f32	s9, s7, s5
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80146ec:	ee64 5a43 	vnmul.f32	s11, s8, s6
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80146f0:	eee1 4a86 	vfma.f32	s9, s3, s12
 80146f4:	3308      	adds	r3, #8
          for (j = 0; j < i; j++) {
 80146f6:	429c      	cmp	r4, r3
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80146f8:	eee2 5a27 	vfma.f32	s11, s4, s15
 80146fc:	f102 0208 	add.w	r2, r2, #8
 8014700:	f101 0108 	add.w	r1, r1, #8
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8014704:	ee22 6a86 	vmul.f32	s12, s5, s12
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8014708:	ee63 7a27 	vmul.f32	s15, s6, s15
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801470c:	ee75 5aa4 	vadd.f32	s11, s11, s9
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8014710:	eea1 6aa3 	vfma.f32	s12, s3, s7
 8014714:	f100 0008 	add.w	r0, r0, #8
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8014718:	eee2 7a04 	vfma.f32	s15, s4, s8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801471c:	ee75 5a25 	vadd.f32	s11, s10, s11
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8014720:	ee77 7a86 	vadd.f32	s15, s15, s12
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8014724:	ed41 5a03 	vstr	s11, [r1, #-12]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8014728:	ed10 6a01 	vldr	s12, [r0, #-4]
 801472c:	ee76 7a27 	vadd.f32	s15, s12, s15
 8014730:	ed40 7a01 	vstr	s15, [r0, #-4]
          for (j = 0; j < i; j++) {
 8014734:	d1ce      	bne.n	80146d4 <cblas_cher2k+0x354>
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8014736:	ee23 3a48 	vnmul.f32	s6, s6, s16
 801473a:	ed55 7a01 	vldr	s15, [r5, #-4]
            IMAG(C, i * lda + i) = 0.0;
 801473e:	ed85 1a00 	vstr	s2, [r5]
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 8014742:	eea0 3a02 	vfma.f32	s6, s0, s4
        for (i = 0; i < N; i++) {
 8014746:	3701      	adds	r7, #1
 8014748:	42be      	cmp	r6, r7
 801474a:	f104 0408 	add.w	r4, r4, #8
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801474e:	eee3 7a20 	vfma.f32	s15, s6, s1
 8014752:	f10c 0c08 	add.w	ip, ip, #8
 8014756:	44de      	add	lr, fp
 8014758:	ed45 7a01 	vstr	s15, [r5, #-4]
        for (i = 0; i < N; i++) {
 801475c:	4455      	add	r5, sl
 801475e:	d196      	bne.n	801468e <cblas_cher2k+0x30e>
      for (k = 0; k < K; k++) {
 8014760:	9a07      	ldr	r2, [sp, #28]
 8014762:	9b06      	ldr	r3, [sp, #24]
 8014764:	4490      	add	r8, r2
 8014766:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 801476a:	440a      	add	r2, r1
 801476c:	9205      	str	r2, [sp, #20]
 801476e:	9a03      	ldr	r2, [sp, #12]
 8014770:	3301      	adds	r3, #1
 8014772:	429a      	cmp	r2, r3
 8014774:	9306      	str	r3, [sp, #24]
 8014776:	f47f af7e 	bne.w	8014676 <cblas_cher2k+0x2f6>
 801477a:	b00f      	add	sp, #60	; 0x3c
 801477c:	ecbd 8b02 	vpop	{d8}
 8014780:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014784:	08030378 	.word	0x08030378
 8014788:	08030730 	.word	0x08030730
 801478c:	080305a8 	.word	0x080305a8
 8014790:	00000000 	.word	0x00000000
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8014794:	4293      	cmp	r3, r2
 8014796:	dc09      	bgt.n	80147ac <cblas_cher2k+0x42c>
 8014798:	2e01      	cmp	r6, #1
 801479a:	4633      	mov	r3, r6
 801479c:	bfb8      	it	lt
 801479e:	2301      	movlt	r3, #1
 80147a0:	4553      	cmp	r3, sl
 80147a2:	dc71      	bgt.n	8014888 <cblas_cher2k+0x508>
 80147a4:	2800      	cmp	r0, #0
 80147a6:	f43f ae33 	beq.w	8014410 <cblas_cher2k+0x90>
 80147aa:	e62d      	b.n	8014408 <cblas_cher2k+0x88>
 80147ac:	2e01      	cmp	r6, #1
 80147ae:	4630      	mov	r0, r6
 80147b0:	bfb8      	it	lt
 80147b2:	2001      	movlt	r0, #1
 80147b4:	4582      	cmp	sl, r0
 80147b6:	bfb4      	ite	lt
 80147b8:	200e      	movlt	r0, #14
 80147ba:	200b      	movge	r0, #11
 80147bc:	e624      	b.n	8014408 <cblas_cher2k+0x88>
 80147be:	f1a7 0065 	sub.w	r0, r7, #101	; 0x65
 80147c2:	2801      	cmp	r0, #1
 80147c4:	bf94      	ite	ls
 80147c6:	2000      	movls	r0, #0
 80147c8:	2001      	movhi	r0, #1
 80147ca:	e5ff      	b.n	80143cc <cblas_cher2k+0x4c>
    } else if (beta != 1.0) {
 80147cc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80147d0:	eeb4 8a67 	vcmp.f32	s16, s15
 80147d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80147d8:	d042      	beq.n	8014860 <cblas_cher2k+0x4e0>
      if (uplo == CblasUpper) {
 80147da:	f1be 0f79 	cmp.w	lr, #121	; 0x79
 80147de:	f000 8141 	beq.w	8014a64 <cblas_cher2k+0x6e4>
        for (i = 0; i < N; i++) {
 80147e2:	2e00      	cmp	r6, #0
 80147e4:	f77f ae5f 	ble.w	80144a6 <cblas_cher2k+0x126>
 80147e8:	9b02      	ldr	r3, [sp, #8]
 80147ea:	f8cd e014 	str.w	lr, [sp, #20]
 80147ee:	f10a 0101 	add.w	r1, sl, #1
 80147f2:	f103 0c04 	add.w	ip, r3, #4
 80147f6:	00cf      	lsls	r7, r1, #3
 80147f8:	4660      	mov	r0, ip
 80147fa:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80147fe:	4654      	mov	r4, sl
 8014800:	2500      	movs	r5, #0
          IMAG(C, ldc * i + i) = 0.0;
 8014802:	f04f 0900 	mov.w	r9, #0
 8014806:	469e      	mov	lr, r3
          REAL(C, ldc * i + i) *= beta;
 8014808:	ed50 7a01 	vldr	s15, [r0, #-4]
          IMAG(C, ldc * i + i) = 0.0;
 801480c:	f8c0 9000 	str.w	r9, [r0]
          REAL(C, ldc * i + i) *= beta;
 8014810:	ee67 7a88 	vmul.f32	s15, s15, s16
        for (i = 0; i < N; i++) {
 8014814:	3501      	adds	r5, #1
 8014816:	42ae      	cmp	r6, r5
          REAL(C, ldc * i + i) *= beta;
 8014818:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (i = 0; i < N; i++) {
 801481c:	f000 8119 	beq.w	8014a52 <cblas_cher2k+0x6d2>
          for (j = 0; j < i; j++) {
 8014820:	eb0e 03c4 	add.w	r3, lr, r4, lsl #3
 8014824:	eb0c 02c4 	add.w	r2, ip, r4, lsl #3
            REAL(C, ldc * i + j) *= beta;
 8014828:	ed52 7a01 	vldr	s15, [r2, #-4]
 801482c:	ee67 7a88 	vmul.f32	s15, s15, s16
 8014830:	3308      	adds	r3, #8
 8014832:	ed42 7a01 	vstr	s15, [r2, #-4]
            IMAG(C, ldc * i + j) *= beta;
 8014836:	ed53 7a01 	vldr	s15, [r3, #-4]
 801483a:	ee67 7a88 	vmul.f32	s15, s15, s16
 801483e:	3208      	adds	r2, #8
 8014840:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < i; j++) {
 8014844:	4299      	cmp	r1, r3
 8014846:	d1ef      	bne.n	8014828 <cblas_cher2k+0x4a8>
 8014848:	4454      	add	r4, sl
 801484a:	4439      	add	r1, r7
 801484c:	4438      	add	r0, r7
 801484e:	e7db      	b.n	8014808 <cblas_cher2k+0x488>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8014850:	2a6f      	cmp	r2, #111	; 0x6f
 8014852:	f000 80fc 	beq.w	8014a4e <cblas_cher2k+0x6ce>
 8014856:	4633      	mov	r3, r6
 8014858:	e5b2      	b.n	80143c0 <cblas_cher2k+0x40>
      uplo = Uplo;
 801485a:	46ae      	mov	lr, r5
      trans = Trans;
 801485c:	46a0      	mov	r8, r4
 801485e:	e602      	b.n	8014466 <cblas_cher2k+0xe6>
      for (i = 0; i < N; i++) {
 8014860:	2e00      	cmp	r6, #0
 8014862:	dd0a      	ble.n	801487a <cblas_cher2k+0x4fa>
 8014864:	f10a 0101 	add.w	r1, sl, #1
 8014868:	9a02      	ldr	r2, [sp, #8]
        IMAG(C, ldc * i + i) = 0.0;
 801486a:	2000      	movs	r0, #0
 801486c:	00c9      	lsls	r1, r1, #3
      for (i = 0; i < N; i++) {
 801486e:	2300      	movs	r3, #0
 8014870:	3301      	adds	r3, #1
 8014872:	429e      	cmp	r6, r3
        IMAG(C, ldc * i + i) = 0.0;
 8014874:	6050      	str	r0, [r2, #4]
      for (i = 0; i < N; i++) {
 8014876:	440a      	add	r2, r1
 8014878:	d1fa      	bne.n	8014870 <cblas_cher2k+0x4f0>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801487a:	eef5 6a40 	vcmp.f32	s13, #0.0
 801487e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014882:	f47f ae1b 	bne.w	80144bc <cblas_cher2k+0x13c>
 8014886:	e613      	b.n	80144b0 <cblas_cher2k+0x130>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8014888:	200e      	movs	r0, #14
 801488a:	e5bd      	b.n	8014408 <cblas_cher2k+0x88>
      for (i = 0; i < N; i++) {
 801488c:	2e00      	cmp	r6, #0
 801488e:	f77f af74 	ble.w	801477a <cblas_cher2k+0x3fa>
 8014892:	2300      	movs	r3, #0
 8014894:	9306      	str	r3, [sp, #24]
 8014896:	9307      	str	r3, [sp, #28]
 8014898:	9305      	str	r3, [sp, #20]
 801489a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801489e:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 80148a2:	9309      	str	r3, [sp, #36]	; 0x24
 80148a4:	9b04      	ldr	r3, [sp, #16]
 80148a6:	920a      	str	r2, [sp, #40]	; 0x28
 80148a8:	3208      	adds	r2, #8
 80148aa:	9902      	ldr	r1, [sp, #8]
 80148ac:	9208      	str	r2, [sp, #32]
 80148ae:	00da      	lsls	r2, r3, #3
 80148b0:	9803      	ldr	r0, [sp, #12]
 80148b2:	9204      	str	r2, [sp, #16]
 80148b4:	9a01      	ldr	r2, [sp, #4]
          for (k = 0; k < K; k++) {
 80148b6:	ed1f 1a4a 	vldr	s2, [pc, #-296]	; 8014790 <cblas_cher2k+0x410>
      for (i = 0; i < N; i++) {
 80148ba:	f8dd 9000 	ldr.w	r9, [sp]
 80148be:	f101 0a04 	add.w	sl, r1, #4
 80148c2:	f1a1 0e08 	sub.w	lr, r1, #8
 80148c6:	e9cd a602 	strd	sl, r6, [sp, #8]
 80148ca:	eb0e 0ec6 	add.w	lr, lr, r6, lsl #3
 80148ce:	eb02 04c0 	add.w	r4, r2, r0, lsl #3
 80148d2:	4690      	mov	r8, r2
 80148d4:	4684      	mov	ip, r0
 80148d6:	469a      	mov	sl, r3
          for (k = 0; k < K; k++) {
 80148d8:	f1bc 0f00 	cmp.w	ip, #0
 80148dc:	bfd8      	it	le
 80148de:	eef0 4a41 	vmovle.f32	s9, s2
 80148e2:	dd21      	ble.n	8014928 <cblas_cher2k+0x5a8>
          BASE temp_real = 0.0;
 80148e4:	ed5f 4a56 	vldr	s9, [pc, #-344]	; 8014790 <cblas_cher2k+0x410>
          for (k = 0; k < K; k++) {
 80148e8:	464a      	mov	r2, r9
 80148ea:	4643      	mov	r3, r8
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80148ec:	edd3 5a00 	vldr	s11, [r3]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80148f0:	ed93 5a01 	vldr	s10, [r3, #4]
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 80148f4:	edd2 3a01 	vldr	s7, [r2, #4]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 80148f8:	ee67 7a25 	vmul.f32	s15, s14, s11
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80148fc:	ee25 6a47 	vnmul.f32	s12, s10, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8014900:	eee6 7a85 	vfma.f32	s15, s13, s10
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 8014904:	4611      	mov	r1, r2
 8014906:	3308      	adds	r3, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8014908:	eea6 6aa5 	vfma.f32	s12, s13, s11
          for (k = 0; k < K; k++) {
 801490c:	429c      	cmp	r4, r3
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801490e:	f102 0208 	add.w	r2, r2, #8
 8014912:	ed91 4a00 	vldr	s8, [r1]
 8014916:	ee67 7aa3 	vmul.f32	s15, s15, s7
 801491a:	eee6 7a04 	vfma.f32	s15, s12, s8
 801491e:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 8014922:	d1e3      	bne.n	80148ec <cblas_cher2k+0x56c>
 8014924:	ee74 4aa4 	vadd.f32	s9, s9, s9
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014928:	9b02      	ldr	r3, [sp, #8]
        for (j = i + 1; j < N; j++) {
 801492a:	9905      	ldr	r1, [sp, #20]
          REAL(C, i * ldc + i) += 2 * temp_real;
 801492c:	ed53 7a01 	vldr	s15, [r3, #-4]
        for (j = i + 1; j < N; j++) {
 8014930:	9a03      	ldr	r2, [sp, #12]
          IMAG(C, i * ldc + i) = 0.0;
 8014932:	ed83 1a00 	vstr	s2, [r3]
        for (j = i + 1; j < N; j++) {
 8014936:	3101      	adds	r1, #1
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014938:	ee77 4aa4 	vadd.f32	s9, s15, s9
        for (j = i + 1; j < N; j++) {
 801493c:	428a      	cmp	r2, r1
 801493e:	9105      	str	r1, [sp, #20]
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014940:	ed43 4a01 	vstr	s9, [r3, #-4]
        for (j = i + 1; j < N; j++) {
 8014944:	f43f af19 	beq.w	801477a <cblas_cher2k+0x3fa>
 8014948:	9e07      	ldr	r6, [sp, #28]
 801494a:	9a06      	ldr	r2, [sp, #24]
 801494c:	445e      	add	r6, fp
 801494e:	4452      	add	r2, sl
 8014950:	9607      	str	r6, [sp, #28]
 8014952:	9206      	str	r2, [sp, #24]
 8014954:	4617      	mov	r7, r2
 8014956:	1f1d      	subs	r5, r3, #4
          BASE temp_imag = 0.0;
 8014958:	ed5f 0a73 	vldr	s1, [pc, #-460]	; 8014790 <cblas_cher2k+0x410>
          for (k = 0; k < K; k++) {
 801495c:	f1bc 0f00 	cmp.w	ip, #0
          BASE temp_real = 0.0;
 8014960:	eeb0 0a60 	vmov.f32	s0, s1
          for (k = 0; k < K; k++) {
 8014964:	dd4a      	ble.n	80149fc <cblas_cher2k+0x67c>
 8014966:	9b01      	ldr	r3, [sp, #4]
 8014968:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 801496c:	9b00      	ldr	r3, [sp, #0]
 801496e:	464a      	mov	r2, r9
 8014970:	eb03 01c7 	add.w	r1, r3, r7, lsl #3
 8014974:	4643      	mov	r3, r8
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8014976:	ed93 5a00 	vldr	s10, [r3]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801497a:	edd0 3a00 	vldr	s7, [r0]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801497e:	edd0 1a01 	vldr	s3, [r0, #4]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8014982:	ed93 6a01 	vldr	s12, [r3, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8014986:	ed91 2a01 	vldr	s4, [r1, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801498a:	edd1 2a00 	vldr	s5, [r1]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801498e:	edd2 5a01 	vldr	s11, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8014992:	ed92 3a00 	vldr	s6, [r2]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8014996:	ee67 7a05 	vmul.f32	s15, s14, s10
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801499a:	ee67 4a23 	vmul.f32	s9, s14, s7
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801499e:	ee21 4ac7 	vnmul.f32	s8, s3, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 80149a2:	eee6 7a86 	vfma.f32	s15, s13, s12
 80149a6:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 80149a8:	429c      	cmp	r4, r3
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 80149aa:	eee6 4aa1 	vfma.f32	s9, s13, s3
 80149ae:	f101 0108 	add.w	r1, r1, #8
 80149b2:	f100 0008 	add.w	r0, r0, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80149b6:	ee26 6a47 	vnmul.f32	s12, s12, s14
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 80149ba:	eea6 4aa3 	vfma.f32	s8, s13, s7
 80149be:	f102 0208 	add.w	r2, r2, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 80149c2:	eea6 6a85 	vfma.f32	s12, s13, s10
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80149c6:	ee65 3aa4 	vmul.f32	s7, s11, s9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 80149ca:	ee27 5a82 	vmul.f32	s10, s15, s4
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 80149ce:	ee67 7aa2 	vmul.f32	s15, s15, s5
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80149d2:	ee65 5a84 	vmul.f32	s11, s11, s8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 80149d6:	eee2 7a46 	vfms.f32	s15, s4, s12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 80149da:	eea6 5a22 	vfma.f32	s10, s12, s5
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80149de:	eeb0 6a63 	vmov.f32	s12, s7
 80149e2:	eea3 6a04 	vfma.f32	s12, s6, s8
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80149e6:	eee4 5ac3 	vfms.f32	s11, s9, s6
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 80149ea:	ee35 6a06 	vadd.f32	s12, s10, s12
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 80149ee:	ee77 7aa5 	vadd.f32	s15, s15, s11
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 80149f2:	ee30 0a06 	vadd.f32	s0, s0, s12
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 80149f6:	ee70 0aa7 	vadd.f32	s1, s1, s15
          for (k = 0; k < K; k++) {
 80149fa:	d1bc      	bne.n	8014976 <cblas_cher2k+0x5f6>
          REAL(C, i * ldc + j) += temp_real;
 80149fc:	ed95 6a02 	vldr	s12, [r5, #8]
          IMAG(C, i * ldc + j) += temp_imag;
 8014a00:	edd5 7a03 	vldr	s15, [r5, #12]
          REAL(C, i * ldc + j) += temp_real;
 8014a04:	ee36 0a00 	vadd.f32	s0, s12, s0
          IMAG(C, i * ldc + j) += temp_imag;
 8014a08:	ee77 0aa0 	vadd.f32	s1, s15, s1
          REAL(C, i * ldc + j) += temp_real;
 8014a0c:	ed85 0a02 	vstr	s0, [r5, #8]
          IMAG(C, i * ldc + j) += temp_imag;
 8014a10:	edc5 0a03 	vstr	s1, [r5, #12]
        for (j = i + 1; j < N; j++) {
 8014a14:	3508      	adds	r5, #8
 8014a16:	45ae      	cmp	lr, r5
 8014a18:	445e      	add	r6, fp
 8014a1a:	4457      	add	r7, sl
 8014a1c:	d19c      	bne.n	8014958 <cblas_cher2k+0x5d8>
 8014a1e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014a20:	9a04      	ldr	r2, [sp, #16]
 8014a22:	449e      	add	lr, r3
 8014a24:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014a26:	4491      	add	r9, r2
 8014a28:	4498      	add	r8, r3
 8014a2a:	9a08      	ldr	r2, [sp, #32]
 8014a2c:	441c      	add	r4, r3
 8014a2e:	9b02      	ldr	r3, [sp, #8]
 8014a30:	4413      	add	r3, r2
 8014a32:	9302      	str	r3, [sp, #8]
 8014a34:	e750      	b.n	80148d8 <cblas_cher2k+0x558>
      for (k = 0; k < K; k++) {
 8014a36:	9b04      	ldr	r3, [sp, #16]
 8014a38:	4498      	add	r8, r3
 8014a3a:	9b05      	ldr	r3, [sp, #20]
 8014a3c:	4418      	add	r0, r3
 8014a3e:	9b03      	ldr	r3, [sp, #12]
 8014a40:	f109 0901 	add.w	r9, r9, #1
 8014a44:	454b      	cmp	r3, r9
 8014a46:	44da      	add	sl, fp
 8014a48:	f47f ad8a 	bne.w	8014560 <cblas_cher2k+0x1e0>
 8014a4c:	e695      	b.n	801477a <cblas_cher2k+0x3fa>
 8014a4e:	9b03      	ldr	r3, [sp, #12]
 8014a50:	e546      	b.n	80144e0 <cblas_cher2k+0x160>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8014a52:	eef5 6a40 	vcmp.f32	s13, #0.0
 8014a56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014a5a:	f8dd e014 	ldr.w	lr, [sp, #20]
 8014a5e:	f43f ad27 	beq.w	80144b0 <cblas_cher2k+0x130>
 8014a62:	e52e      	b.n	80144c2 <cblas_cher2k+0x142>
        for (i = 0; i < N; i++) {
 8014a64:	2e00      	cmp	r6, #0
 8014a66:	f77f ad57 	ble.w	8014518 <cblas_cher2k+0x198>
 8014a6a:	9b02      	ldr	r3, [sp, #8]
 8014a6c:	ea4f 04ca 	mov.w	r4, sl, lsl #3
 8014a70:	f1a3 0208 	sub.w	r2, r3, #8
          IMAG(C, ldc * i + i) = 0.0;
 8014a74:	2700      	movs	r7, #0
 8014a76:	f104 0508 	add.w	r5, r4, #8
 8014a7a:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8014a7e:	1d19      	adds	r1, r3, #4
        for (i = 0; i < N; i++) {
 8014a80:	2000      	movs	r0, #0
          REAL(C, ldc * i + i) *= beta;
 8014a82:	ed51 7a01 	vldr	s15, [r1, #-4]
          IMAG(C, ldc * i + i) = 0.0;
 8014a86:	600f      	str	r7, [r1, #0]
          REAL(C, ldc * i + i) *= beta;
 8014a88:	ee67 7a88 	vmul.f32	s15, s15, s16
          for (j = i + 1; j < N; j++) {
 8014a8c:	3001      	adds	r0, #1
 8014a8e:	4286      	cmp	r6, r0
          REAL(C, ldc * i + i) *= beta;
 8014a90:	ed41 7a01 	vstr	s15, [r1, #-4]
          for (j = i + 1; j < N; j++) {
 8014a94:	f43f ad40 	beq.w	8014518 <cblas_cher2k+0x198>
 8014a98:	1f0b      	subs	r3, r1, #4
            REAL(C, ldc * i + j) *= beta;
 8014a9a:	ed93 6a02 	vldr	s12, [r3, #8]
            IMAG(C, ldc * i + j) *= beta;
 8014a9e:	edd3 7a03 	vldr	s15, [r3, #12]
            REAL(C, ldc * i + j) *= beta;
 8014aa2:	ee26 6a08 	vmul.f32	s12, s12, s16
            IMAG(C, ldc * i + j) *= beta;
 8014aa6:	ee67 7a88 	vmul.f32	s15, s15, s16
            REAL(C, ldc * i + j) *= beta;
 8014aaa:	ed83 6a02 	vstr	s12, [r3, #8]
            IMAG(C, ldc * i + j) *= beta;
 8014aae:	edc3 7a03 	vstr	s15, [r3, #12]
          for (j = i + 1; j < N; j++) {
 8014ab2:	3308      	adds	r3, #8
 8014ab4:	429a      	cmp	r2, r3
 8014ab6:	d1f0      	bne.n	8014a9a <cblas_cher2k+0x71a>
 8014ab8:	4422      	add	r2, r4
 8014aba:	4429      	add	r1, r5
 8014abc:	e7e1      	b.n	8014a82 <cblas_cher2k+0x702>
      for (i = 0; i < N; i++) {
 8014abe:	2e00      	cmp	r6, #0
 8014ac0:	f77f ae5b 	ble.w	801477a <cblas_cher2k+0x3fa>
 8014ac4:	9b03      	ldr	r3, [sp, #12]
 8014ac6:	9f01      	ldr	r7, [sp, #4]
 8014ac8:	9d02      	ldr	r5, [sp, #8]
          for (k = 0; k < K; k++) {
 8014aca:	ed1f 0acf 	vldr	s0, [pc, #-828]	; 8014790 <cblas_cher2k+0x410>
 8014ace:	f8cd a034 	str.w	sl, [sp, #52]	; 0x34
 8014ad2:	f10a 0801 	add.w	r8, sl, #1
 8014ad6:	eb03 020b 	add.w	r2, r3, fp
 8014ada:	ea4f 04c8 	mov.w	r4, r8, lsl #3
 8014ade:	4619      	mov	r1, r3
 8014ae0:	940c      	str	r4, [sp, #48]	; 0x30
 8014ae2:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
 8014ae6:	eb07 04c2 	add.w	r4, r7, r2, lsl #3
 8014aea:	9a04      	ldr	r2, [sp, #16]
 8014aec:	9609      	str	r6, [sp, #36]	; 0x24
      for (i = 0; i < N; i++) {
 8014aee:	2000      	movs	r0, #0
 8014af0:	00db      	lsls	r3, r3, #3
 8014af2:	e9cd 0306 	strd	r0, r3, [sp, #24]
 8014af6:	00d3      	lsls	r3, r2, #3
 8014af8:	930b      	str	r3, [sp, #44]	; 0x2c
 8014afa:	9b00      	ldr	r3, [sp, #0]
 8014afc:	9005      	str	r0, [sp, #20]
 8014afe:	eb03 09c2 	add.w	r9, r3, r2, lsl #3
 8014b02:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8014b06:	930a      	str	r3, [sp, #40]	; 0x28
 8014b08:	eb07 0ec1 	add.w	lr, r7, r1, lsl #3
 8014b0c:	460b      	mov	r3, r1
 8014b0e:	1d29      	adds	r1, r5, #4
 8014b10:	e9cd 1a03 	strd	r1, sl, [sp, #12]
 8014b14:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
 8014b18:	469c      	mov	ip, r3
 8014b1a:	4692      	mov	sl, r2
          for (k = 0; k < K; k++) {
 8014b1c:	f1bc 0f00 	cmp.w	ip, #0
 8014b20:	f340 80b8 	ble.w	8014c94 <cblas_cher2k+0x914>
 8014b24:	9b07      	ldr	r3, [sp, #28]
 8014b26:	9a00      	ldr	r2, [sp, #0]
 8014b28:	9905      	ldr	r1, [sp, #20]
          BASE temp_real = 0.0;
 8014b2a:	eddf 4a5c 	vldr	s9, [pc, #368]	; 8014c9c <cblas_cher2k+0x91c>
 8014b2e:	4473      	add	r3, lr
 8014b30:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8014b34:	edd3 5a00 	vldr	s11, [r3]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8014b38:	ed93 5a01 	vldr	s10, [r3, #4]
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 8014b3c:	edd2 3a01 	vldr	s7, [r2, #4]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8014b40:	ee67 7a25 	vmul.f32	s15, s14, s11
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8014b44:	ee25 6a47 	vnmul.f32	s12, s10, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8014b48:	eee6 7a85 	vfma.f32	s15, s13, s10
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 8014b4c:	4611      	mov	r1, r2
 8014b4e:	3308      	adds	r3, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8014b50:	eea6 6aa5 	vfma.f32	s12, s13, s11
          for (k = 0; k < K; k++) {
 8014b54:	459e      	cmp	lr, r3
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 8014b56:	f102 0208 	add.w	r2, r2, #8
 8014b5a:	ed91 4a00 	vldr	s8, [r1]
 8014b5e:	ee67 7aa3 	vmul.f32	s15, s15, s7
 8014b62:	eee6 7a04 	vfma.f32	s15, s12, s8
 8014b66:	ee74 4aa7 	vadd.f32	s9, s9, s15
          for (k = 0; k < K; k++) {
 8014b6a:	d1e3      	bne.n	8014b34 <cblas_cher2k+0x7b4>
 8014b6c:	ee74 4aa4 	vadd.f32	s9, s9, s9
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014b70:	9b03      	ldr	r3, [sp, #12]
      for (i = 0; i < N; i++) {
 8014b72:	9a06      	ldr	r2, [sp, #24]
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014b74:	ed53 7a01 	vldr	s15, [r3, #-4]
          IMAG(C, i * ldc + i) = 0.0;
 8014b78:	ed83 0a00 	vstr	s0, [r3]
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014b7c:	ee77 4aa4 	vadd.f32	s9, s15, s9
      for (i = 0; i < N; i++) {
 8014b80:	3201      	adds	r2, #1
          REAL(C, i * ldc + i) += 2 * temp_real;
 8014b82:	ed43 4a01 	vstr	s9, [r3, #-4]
      for (i = 0; i < N; i++) {
 8014b86:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8014b88:	9206      	str	r2, [sp, #24]
 8014b8a:	4293      	cmp	r3, r2
 8014b8c:	f43f adf5 	beq.w	801477a <cblas_cher2k+0x3fa>
        for (j = 0; j < i; j++) {
 8014b90:	9b02      	ldr	r3, [sp, #8]
 8014b92:	9a04      	ldr	r2, [sp, #16]
 8014b94:	f8cd e020 	str.w	lr, [sp, #32]
 8014b98:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 8014b9c:	9b07      	ldr	r3, [sp, #28]
      for (i = 0; i < N; i++) {
 8014b9e:	2600      	movs	r6, #0
 8014ba0:	4423      	add	r3, r4
 8014ba2:	4637      	mov	r7, r6
 8014ba4:	469e      	mov	lr, r3
          BASE temp_imag = 0.0;
 8014ba6:	ed9f 1a3d 	vldr	s2, [pc, #244]	; 8014c9c <cblas_cher2k+0x91c>
          for (k = 0; k < K; k++) {
 8014baa:	f1bc 0f00 	cmp.w	ip, #0
          BASE temp_real = 0.0;
 8014bae:	eef0 0a41 	vmov.f32	s1, s2
          for (k = 0; k < K; k++) {
 8014bb2:	dd4a      	ble.n	8014c4a <cblas_cher2k+0x8ca>
 8014bb4:	9b01      	ldr	r3, [sp, #4]
 8014bb6:	eb03 00c7 	add.w	r0, r3, r7, lsl #3
 8014bba:	9b00      	ldr	r3, [sp, #0]
 8014bbc:	464a      	mov	r2, r9
 8014bbe:	eb03 01c6 	add.w	r1, r3, r6, lsl #3
 8014bc2:	4673      	mov	r3, lr
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8014bc4:	ed93 5a00 	vldr	s10, [r3]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8014bc8:	edd0 3a00 	vldr	s7, [r0]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8014bcc:	edd0 1a01 	vldr	s3, [r0, #4]
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8014bd0:	ed93 6a01 	vldr	s12, [r3, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8014bd4:	ed91 2a01 	vldr	s4, [r1, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8014bd8:	edd1 2a00 	vldr	s5, [r1]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 8014bdc:	edd2 5a01 	vldr	s11, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8014be0:	ed92 3a00 	vldr	s6, [r2]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8014be4:	ee67 7a05 	vmul.f32	s15, s14, s10
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 8014be8:	ee67 4a23 	vmul.f32	s9, s14, s7
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 8014bec:	ee21 4ac7 	vnmul.f32	s8, s3, s14
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 8014bf0:	eee6 7a86 	vfma.f32	s15, s13, s12
 8014bf4:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8014bf6:	429c      	cmp	r4, r3
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 8014bf8:	eee6 4aa1 	vfma.f32	s9, s13, s3
 8014bfc:	f101 0108 	add.w	r1, r1, #8
 8014c00:	f100 0008 	add.w	r0, r0, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8014c04:	ee26 6a47 	vnmul.f32	s12, s12, s14
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 8014c08:	eea6 4aa3 	vfma.f32	s8, s13, s7
 8014c0c:	f102 0208 	add.w	r2, r2, #8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 8014c10:	eea6 6a85 	vfma.f32	s12, s13, s10
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 8014c14:	ee65 3aa4 	vmul.f32	s7, s11, s9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 8014c18:	ee27 5a82 	vmul.f32	s10, s15, s4
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 8014c1c:	ee67 7aa2 	vmul.f32	s15, s15, s5
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 8014c20:	ee65 5a84 	vmul.f32	s11, s11, s8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 8014c24:	eee2 7a46 	vfms.f32	s15, s4, s12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 8014c28:	eea6 5a22 	vfma.f32	s10, s12, s5
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 8014c2c:	eeb0 6a63 	vmov.f32	s12, s7
 8014c30:	eea3 6a04 	vfma.f32	s12, s6, s8
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 8014c34:	eee4 5ac3 	vfms.f32	s11, s9, s6
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 8014c38:	ee35 6a06 	vadd.f32	s12, s10, s12
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 8014c3c:	ee77 7aa5 	vadd.f32	s15, s15, s11
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 8014c40:	ee70 0a86 	vadd.f32	s1, s1, s12
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 8014c44:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = 0; k < K; k++) {
 8014c48:	d1bc      	bne.n	8014bc4 <cblas_cher2k+0x844>
          REAL(C, i * ldc + j) += temp_real;
 8014c4a:	ed95 6a00 	vldr	s12, [r5]
          IMAG(C, i * ldc + j) += temp_imag;
 8014c4e:	edd5 7a01 	vldr	s15, [r5, #4]
          REAL(C, i * ldc + j) += temp_real;
 8014c52:	ee76 0a20 	vadd.f32	s1, s12, s1
          IMAG(C, i * ldc + j) += temp_imag;
 8014c56:	ee37 1a81 	vadd.f32	s2, s15, s2
          REAL(C, i * ldc + j) += temp_real;
 8014c5a:	edc5 0a00 	vstr	s1, [r5]
          IMAG(C, i * ldc + j) += temp_imag;
 8014c5e:	ed85 1a01 	vstr	s2, [r5, #4]
        for (j = 0; j < i; j++) {
 8014c62:	3508      	adds	r5, #8
 8014c64:	45a8      	cmp	r8, r5
 8014c66:	445f      	add	r7, fp
 8014c68:	4456      	add	r6, sl
 8014c6a:	d19c      	bne.n	8014ba6 <cblas_cher2k+0x826>
 8014c6c:	9b04      	ldr	r3, [sp, #16]
 8014c6e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8014c70:	f8dd e020 	ldr.w	lr, [sp, #32]
 8014c74:	9905      	ldr	r1, [sp, #20]
 8014c76:	4413      	add	r3, r2
 8014c78:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8014c7a:	9304      	str	r3, [sp, #16]
 8014c7c:	4491      	add	r9, r2
 8014c7e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8014c80:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8014c82:	4414      	add	r4, r2
 8014c84:	4496      	add	lr, r2
 8014c86:	9a03      	ldr	r2, [sp, #12]
 8014c88:	4451      	add	r1, sl
 8014c8a:	441a      	add	r2, r3
 8014c8c:	4498      	add	r8, r3
 8014c8e:	9105      	str	r1, [sp, #20]
 8014c90:	9203      	str	r2, [sp, #12]
 8014c92:	e743      	b.n	8014b1c <cblas_cher2k+0x79c>
          for (k = 0; k < K; k++) {
 8014c94:	eef0 4a40 	vmov.f32	s9, s0
 8014c98:	e76a      	b.n	8014b70 <cblas_cher2k+0x7f0>
 8014c9a:	bf00      	nop
 8014c9c:	00000000 	.word	0x00000000

08014ca0 <cblas_cherk>:
void
cblas_cherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const float alpha, const void *A, const int lda,
             const float beta, void *C, const int ldc)
{
 8014ca0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014ca4:	ed2d 8b02 	vpush	{d8}
 8014ca8:	b087      	sub	sp, #28
 8014caa:	461e      	mov	r6, r3
 8014cac:	e9dd 4314 	ldrd	r4, r3, [sp, #80]	; 0x50

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8014cb0:	2865      	cmp	r0, #101	; 0x65
 8014cb2:	e9dd 5712 	ldrd	r5, r7, [sp, #72]	; 0x48
 8014cb6:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
 8014cba:	9301      	str	r3, [sp, #4]
 8014cbc:	4681      	mov	r9, r0
 8014cbe:	468a      	mov	sl, r1
 8014cc0:	4693      	mov	fp, r2
 8014cc2:	eeb0 8a40 	vmov.f32	s16, s0
 8014cc6:	eef0 8a60 	vmov.f32	s17, s1
 8014cca:	f000 80ff 	beq.w	8014ecc <cblas_cherk+0x22c>
 8014cce:	2a6f      	cmp	r2, #111	; 0x6f
 8014cd0:	f000 80b3 	beq.w	8014e3a <cblas_cherk+0x19a>
 8014cd4:	462b      	mov	r3, r5
 8014cd6:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 8014cda:	2a01      	cmp	r2, #1
 8014cdc:	f240 80ef 	bls.w	8014ebe <cblas_cherk+0x21e>
 8014ce0:	2002      	movs	r0, #2
 8014ce2:	f1ab 026f 	sub.w	r2, fp, #111	; 0x6f
 8014ce6:	2a02      	cmp	r2, #2
 8014ce8:	bf88      	it	hi
 8014cea:	2003      	movhi	r0, #3
 8014cec:	2e00      	cmp	r6, #0
 8014cee:	bfb8      	it	lt
 8014cf0:	2004      	movlt	r0, #4
 8014cf2:	2b01      	cmp	r3, #1
 8014cf4:	bfb8      	it	lt
 8014cf6:	2301      	movlt	r3, #1
 8014cf8:	2d00      	cmp	r5, #0
 8014cfa:	f2c0 80d5 	blt.w	8014ea8 <cblas_cherk+0x208>
 8014cfe:	42a3      	cmp	r3, r4
 8014d00:	f300 80a2 	bgt.w	8014e48 <cblas_cherk+0x1a8>
 8014d04:	2e01      	cmp	r6, #1
 8014d06:	4633      	mov	r3, r6
 8014d08:	bfb8      	it	lt
 8014d0a:	2301      	movlt	r3, #1
 8014d0c:	4543      	cmp	r3, r8
 8014d0e:	f300 812a 	bgt.w	8014f66 <cblas_cherk+0x2c6>
 8014d12:	2800      	cmp	r0, #0
 8014d14:	f040 80a0 	bne.w	8014e58 <cblas_cherk+0x1b8>

  if (beta == 1.0 && (alpha == 0.0 || K == 0))
 8014d18:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014d1c:	eef4 8a67 	vcmp.f32	s17, s15
 8014d20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d24:	f000 80a4 	beq.w	8014e70 <cblas_cherk+0x1d0>
    return;

  if (Order == CblasRowMajor) {
 8014d28:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8014d2c:	f000 80d3 	beq.w	8014ed6 <cblas_cherk+0x236>
    uplo = Uplo;
    trans = Trans;
  } else {
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8014d30:	f1ba 0f79 	cmp.w	sl, #121	; 0x79
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
  }

  /* form  y := beta*y */
  if (beta == 0.0) {
 8014d34:	eef5 8a40 	vcmp.f32	s17, #0.0
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8014d38:	f000 8117 	beq.w	8014f6a <cblas_cherk+0x2ca>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8014d3c:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8014d40:	f000 8189 	beq.w	8015056 <cblas_cherk+0x3b6>
  if (beta == 0.0) {
 8014d44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d48:	f040 80fe 	bne.w	8014f48 <cblas_cherk+0x2a8>
    if (uplo == CblasUpper) {
      for (i = 0; i < N; i++) {
 8014d4c:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8014d4e:	bfc8      	it	gt
 8014d50:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8014d54:	dd6c      	ble.n	8014e30 <cblas_cherk+0x190>
 8014d56:	f108 0e01 	add.w	lr, r8, #1
 8014d5a:	f8dd c004 	ldr.w	ip, [sp, #4]
        for (j = i; j < N; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8014d5e:	2100      	movs	r1, #0
 8014d60:	ea4f 0ece 	mov.w	lr, lr, lsl #3
      for (i = 0; i < N; i++) {
 8014d64:	2000      	movs	r0, #0
 8014d66:	4663      	mov	r3, ip
 8014d68:	4602      	mov	r2, r0
        for (j = i; j < N; j++) {
 8014d6a:	3201      	adds	r2, #1
 8014d6c:	4296      	cmp	r6, r2
          REAL(C, ldc * i + j) = 0.0;
 8014d6e:	6019      	str	r1, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8014d70:	6059      	str	r1, [r3, #4]
        for (j = i; j < N; j++) {
 8014d72:	f103 0308 	add.w	r3, r3, #8
 8014d76:	dcf8      	bgt.n	8014d6a <cblas_cherk+0xca>
      for (i = 0; i < N; i++) {
 8014d78:	3001      	adds	r0, #1
 8014d7a:	4286      	cmp	r6, r0
 8014d7c:	44f4      	add	ip, lr
 8014d7e:	dcf2      	bgt.n	8014d66 <cblas_cherk+0xc6>
    for (i = 0; i < N; i++) {
      IMAG(C, ldc * i + i) = 0.0;
    }
  }

  if (alpha == 0.0)
 8014d80:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8014d84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d88:	d052      	beq.n	8014e30 <cblas_cherk+0x190>
    return;

  if (uplo == CblasUpper && trans == CblasNoTrans) {
 8014d8a:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8014d8e:	f000 8175 	beq.w	801507c <cblas_cherk+0x3dc>
        REAL(C, i * ldc + j) += alpha * temp_real;
        IMAG(C, i * ldc + j) += alpha * temp_imag;
      }
    }

  } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 8014d92:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8014d96:	f040 80cd 	bne.w	8014f34 <cblas_cherk+0x294>

    for (i = 0; i < N; i++) {
 8014d9a:	2e00      	cmp	r6, #0
 8014d9c:	dd48      	ble.n	8014e30 <cblas_cherk+0x190>
 8014d9e:	f108 0801 	add.w	r8, r8, #1
 8014da2:	f8dd a004 	ldr.w	sl, [sp, #4]
 8014da6:	ea4f 09c8 	mov.w	r9, r8, lsl #3
 8014daa:	00e0      	lsls	r0, r4, #3
 8014dac:	f107 0e04 	add.w	lr, r7, #4
 8014db0:	f04f 0800 	mov.w	r8, #0
      for (j = i; j < N; j++) {
        BASE temp_real = 0.0;
 8014db4:	4654      	mov	r4, sl
 8014db6:	46c4      	mov	ip, r8
        BASE temp_imag = 0.0;
 8014db8:	ed9f 5adb 	vldr	s10, [pc, #876]	; 8015128 <cblas_cherk+0x488>
        for (k = 0; k < K; k++) {
 8014dbc:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 8014dbe:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 8014dc2:	dd1c      	ble.n	8014dfe <cblas_cherk+0x15e>
 8014dc4:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 8014dc8:	4673      	mov	r3, lr
 8014dca:	2100      	movs	r1, #0
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 8014dcc:	edd3 7a00 	vldr	s15, [r3]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8014dd0:	edd2 6a01 	vldr	s13, [r2, #4]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8014dd4:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8014dd8:	ed13 6a01 	vldr	s12, [r3, #-4]
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8014ddc:	ee27 7aa6 	vmul.f32	s14, s15, s13
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8014de0:	ee67 7ae5 	vnmul.f32	s15, s15, s11
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8014de4:	eea6 7a25 	vfma.f32	s14, s12, s11
        for (k = 0; k < K; k++) {
 8014de8:	3101      	adds	r1, #1
 8014dea:	428d      	cmp	r5, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8014dec:	eee6 7a26 	vfma.f32	s15, s12, s13
 8014df0:	4402      	add	r2, r0
 8014df2:	4403      	add	r3, r0
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8014df4:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8014df8:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 8014dfc:	d1e6      	bne.n	8014dcc <cblas_cherk+0x12c>
        }
        REAL(C, i * ldc + j) += alpha * temp_real;
 8014dfe:	ed94 7a00 	vldr	s14, [r4]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8014e02:	edd4 7a01 	vldr	s15, [r4, #4]
        REAL(C, i * ldc + j) += alpha * temp_real;
 8014e06:	eea8 7a24 	vfma.f32	s14, s16, s9
      for (j = i; j < N; j++) {
 8014e0a:	f10c 0c01 	add.w	ip, ip, #1
 8014e0e:	4566      	cmp	r6, ip
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8014e10:	eee8 7a05 	vfma.f32	s15, s16, s10
 8014e14:	f104 0408 	add.w	r4, r4, #8
        REAL(C, i * ldc + j) += alpha * temp_real;
 8014e18:	ed04 7a02 	vstr	s14, [r4, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8014e1c:	ed44 7a01 	vstr	s15, [r4, #-4]
      for (j = i; j < N; j++) {
 8014e20:	dcca      	bgt.n	8014db8 <cblas_cherk+0x118>
    for (i = 0; i < N; i++) {
 8014e22:	f108 0801 	add.w	r8, r8, #1
 8014e26:	4546      	cmp	r6, r8
 8014e28:	44ca      	add	sl, r9
 8014e2a:	f10e 0e08 	add.w	lr, lr, #8
 8014e2e:	d1c1      	bne.n	8014db4 <cblas_cherk+0x114>
#define BASE float
#include "source_herk.h"
#undef BASE
}
 8014e30:	b007      	add	sp, #28
 8014e32:	ecbd 8b02 	vpop	{d8}
 8014e36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014e3a:	4633      	mov	r3, r6
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8014e3c:	f1aa 0279 	sub.w	r2, sl, #121	; 0x79
 8014e40:	2a01      	cmp	r2, #1
 8014e42:	d93c      	bls.n	8014ebe <cblas_cherk+0x21e>
 8014e44:	2002      	movs	r0, #2
 8014e46:	e751      	b.n	8014cec <cblas_cherk+0x4c>
 8014e48:	2e01      	cmp	r6, #1
 8014e4a:	4630      	mov	r0, r6
 8014e4c:	bfb8      	it	lt
 8014e4e:	2001      	movlt	r0, #1
 8014e50:	4580      	cmp	r8, r0
 8014e52:	bfb4      	ite	lt
 8014e54:	200b      	movlt	r0, #11
 8014e56:	2008      	movge	r0, #8
 8014e58:	4ab4      	ldr	r2, [pc, #720]	; (801512c <cblas_cherk+0x48c>)
 8014e5a:	49b5      	ldr	r1, [pc, #724]	; (8015130 <cblas_cherk+0x490>)
 8014e5c:	f012 fdf4 	bl	8027a48 <cblas_xerbla>
  if (beta == 1.0 && (alpha == 0.0 || K == 0))
 8014e60:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014e64:	eef4 8a67 	vcmp.f32	s17, s15
 8014e68:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014e6c:	f47f af5c 	bne.w	8014d28 <cblas_cherk+0x88>
 8014e70:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8014e74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014e78:	d0da      	beq.n	8014e30 <cblas_cherk+0x190>
 8014e7a:	2d00      	cmp	r5, #0
 8014e7c:	d0d8      	beq.n	8014e30 <cblas_cherk+0x190>
  if (Order == CblasRowMajor) {
 8014e7e:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8014e82:	f47f af55 	bne.w	8014d30 <cblas_cherk+0x90>
    for (i = 0; i < N; i++) {
 8014e86:	2e00      	cmp	r6, #0
    uplo = Uplo;
 8014e88:	4650      	mov	r0, sl
    for (i = 0; i < N; i++) {
 8014e8a:	dd49      	ble.n	8014f20 <cblas_cherk+0x280>
 8014e8c:	f108 0101 	add.w	r1, r8, #1
 8014e90:	9a01      	ldr	r2, [sp, #4]
      IMAG(C, ldc * i + i) = 0.0;
 8014e92:	f04f 0c00 	mov.w	ip, #0
 8014e96:	00c9      	lsls	r1, r1, #3
    for (i = 0; i < N; i++) {
 8014e98:	2300      	movs	r3, #0
 8014e9a:	3301      	adds	r3, #1
 8014e9c:	429e      	cmp	r6, r3
      IMAG(C, ldc * i + i) = 0.0;
 8014e9e:	f8c2 c004 	str.w	ip, [r2, #4]
    for (i = 0; i < N; i++) {
 8014ea2:	440a      	add	r2, r1
 8014ea4:	dcf9      	bgt.n	8014e9a <cblas_cherk+0x1fa>
 8014ea6:	e03b      	b.n	8014f20 <cblas_cherk+0x280>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8014ea8:	42a3      	cmp	r3, r4
 8014eaa:	dccd      	bgt.n	8014e48 <cblas_cherk+0x1a8>
 8014eac:	2e01      	cmp	r6, #1
 8014eae:	4630      	mov	r0, r6
 8014eb0:	bfb8      	it	lt
 8014eb2:	2001      	movlt	r0, #1
 8014eb4:	4580      	cmp	r8, r0
 8014eb6:	bfb4      	ite	lt
 8014eb8:	200b      	movlt	r0, #11
 8014eba:	2005      	movge	r0, #5
 8014ebc:	e7cc      	b.n	8014e58 <cblas_cherk+0x1b8>
 8014ebe:	f1a9 0065 	sub.w	r0, r9, #101	; 0x65
 8014ec2:	2801      	cmp	r0, #1
 8014ec4:	bf94      	ite	ls
 8014ec6:	2000      	movls	r0, #0
 8014ec8:	2001      	movhi	r0, #1
 8014eca:	e70a      	b.n	8014ce2 <cblas_cherk+0x42>
 8014ecc:	2a6f      	cmp	r2, #111	; 0x6f
 8014ece:	f000 80c0 	beq.w	8015052 <cblas_cherk+0x3b2>
 8014ed2:	4633      	mov	r3, r6
 8014ed4:	e6ff      	b.n	8014cd6 <cblas_cherk+0x36>
  if (beta == 0.0) {
 8014ed6:	eef5 8a40 	vcmp.f32	s17, #0.0
 8014eda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    uplo = Uplo;
 8014ede:	4650      	mov	r0, sl
  if (beta == 0.0) {
 8014ee0:	f040 8179 	bne.w	80151d6 <cblas_cherk+0x536>
    if (uplo == CblasUpper) {
 8014ee4:	2879      	cmp	r0, #121	; 0x79
 8014ee6:	f000 823d 	beq.w	8015364 <cblas_cherk+0x6c4>
      for (i = 0; i < N; i++) {
 8014eea:	2e00      	cmp	r6, #0
 8014eec:	dd4e      	ble.n	8014f8c <cblas_cherk+0x2ec>
 8014eee:	9b01      	ldr	r3, [sp, #4]
 8014ef0:	f108 0901 	add.w	r9, r8, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8014ef4:	f04f 0c00 	mov.w	ip, #0
 8014ef8:	4619      	mov	r1, r3
          REAL(C, ldc * i + j) = 0.0;
 8014efa:	2200      	movs	r2, #0
 8014efc:	ea4f 09c9 	mov.w	r9, r9, lsl #3
      for (i = 0; i < N; i++) {
 8014f00:	46e6      	mov	lr, ip
 8014f02:	3108      	adds	r1, #8
 8014f04:	469a      	mov	sl, r3
 8014f06:	eb0a 03cc 	add.w	r3, sl, ip, lsl #3
          REAL(C, ldc * i + j) = 0.0;
 8014f0a:	601a      	str	r2, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8014f0c:	605a      	str	r2, [r3, #4]
        for (j = 0; j <= i; j++) {
 8014f0e:	3308      	adds	r3, #8
 8014f10:	4299      	cmp	r1, r3
 8014f12:	d1fa      	bne.n	8014f0a <cblas_cherk+0x26a>
      for (i = 0; i < N; i++) {
 8014f14:	f10e 0e01 	add.w	lr, lr, #1
 8014f18:	4576      	cmp	r6, lr
 8014f1a:	44c4      	add	ip, r8
 8014f1c:	4449      	add	r1, r9
 8014f1e:	dcf2      	bgt.n	8014f06 <cblas_cherk+0x266>
  if (alpha == 0.0)
 8014f20:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8014f24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014f28:	d082      	beq.n	8014e30 <cblas_cherk+0x190>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 8014f2a:	2879      	cmp	r0, #121	; 0x79
 8014f2c:	f43f af2d 	beq.w	8014d8a <cblas_cherk+0xea>
      }
    }

  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8014f30:	287a      	cmp	r0, #122	; 0x7a
 8014f32:	d031      	beq.n	8014f98 <cblas_cherk+0x2f8>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
      }
    }

  } else {
    BLAS_ERROR("unrecognized operation");
 8014f34:	4a7f      	ldr	r2, [pc, #508]	; (8015134 <cblas_cherk+0x494>)
 8014f36:	497e      	ldr	r1, [pc, #504]	; (8015130 <cblas_cherk+0x490>)
 8014f38:	2000      	movs	r0, #0
 8014f3a:	b007      	add	sp, #28
 8014f3c:	ecbd 8b02 	vpop	{d8}
 8014f40:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014f44:	f012 bd80 	b.w	8027a48 <cblas_xerbla>
  } else if (beta != 1.0) {
 8014f48:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8014f4c:	eef4 8a67 	vcmp.f32	s17, s15
 8014f50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014f54:	f040 810b 	bne.w	801516e <cblas_cherk+0x4ce>
    for (i = 0; i < N; i++) {
 8014f58:	2e00      	cmp	r6, #0
 8014f5a:	f77f af69 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8014f5e:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8014f62:	2079      	movs	r0, #121	; 0x79
 8014f64:	e792      	b.n	8014e8c <cblas_cherk+0x1ec>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8014f66:	200b      	movs	r0, #11
 8014f68:	e776      	b.n	8014e58 <cblas_cherk+0x1b8>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8014f6a:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8014f6e:	f000 80f4 	beq.w	801515a <cblas_cherk+0x4ba>
  if (beta == 0.0) {
 8014f72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014f76:	f040 80e1 	bne.w	801513c <cblas_cherk+0x49c>
      for (i = 0; i < N; i++) {
 8014f7a:	2e00      	cmp	r6, #0
 8014f7c:	f77f af58 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8014f80:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8014f84:	207a      	movs	r0, #122	; 0x7a
 8014f86:	e7b2      	b.n	8014eee <cblas_cherk+0x24e>
 8014f88:	e9dd 0b02 	ldrd	r0, fp, [sp, #8]
  if (alpha == 0.0)
 8014f8c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8014f90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014f94:	d1cc      	bne.n	8014f30 <cblas_cherk+0x290>
 8014f96:	e74b      	b.n	8014e30 <cblas_cherk+0x190>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8014f98:	f1bb 0f6f 	cmp.w	fp, #111	; 0x6f
 8014f9c:	f000 8178 	beq.w	8015290 <cblas_cherk+0x5f0>
  } else if (uplo == CblasLower && trans == CblasConjTrans) {
 8014fa0:	f1bb 0f71 	cmp.w	fp, #113	; 0x71
 8014fa4:	d1c6      	bne.n	8014f34 <cblas_cherk+0x294>
    for (i = 0; i < N; i++) {
 8014fa6:	2e00      	cmp	r6, #0
 8014fa8:	f77f af42 	ble.w	8014e30 <cblas_cherk+0x190>
 8014fac:	9b01      	ldr	r3, [sp, #4]
 8014fae:	3304      	adds	r3, #4
 8014fb0:	00e0      	lsls	r0, r4, #3
 8014fb2:	f107 0a04 	add.w	sl, r7, #4
 8014fb6:	f04f 0b00 	mov.w	fp, #0
 8014fba:	f04f 0901 	mov.w	r9, #1
 8014fbe:	9302      	str	r3, [sp, #8]
 8014fc0:	9b01      	ldr	r3, [sp, #4]
 8014fc2:	eb03 0ccb 	add.w	ip, r3, fp, lsl #3
 8014fc6:	9b02      	ldr	r3, [sp, #8]
      for (j = 0; j <= i; j++) {
 8014fc8:	f04f 0e00 	mov.w	lr, #0
 8014fcc:	eb03 04cb 	add.w	r4, r3, fp, lsl #3
        BASE temp_imag = 0.0;
 8014fd0:	ed9f 5a55 	vldr	s10, [pc, #340]	; 8015128 <cblas_cherk+0x488>
        for (k = 0; k < K; k++) {
 8014fd4:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 8014fd6:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 8014fda:	dd1c      	ble.n	8015016 <cblas_cherk+0x376>
 8014fdc:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 8014fe0:	4653      	mov	r3, sl
 8014fe2:	2100      	movs	r1, #0
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 8014fe4:	edd3 7a00 	vldr	s15, [r3]
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8014fe8:	edd2 6a01 	vldr	s13, [r2, #4]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8014fec:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8014ff0:	ed13 6a01 	vldr	s12, [r3, #-4]
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8014ff4:	ee27 7aa6 	vmul.f32	s14, s15, s13
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8014ff8:	ee67 7ae5 	vnmul.f32	s15, s15, s11
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8014ffc:	eea6 7a25 	vfma.f32	s14, s12, s11
        for (k = 0; k < K; k++) {
 8015000:	3101      	adds	r1, #1
 8015002:	428d      	cmp	r5, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015004:	eee6 7a26 	vfma.f32	s15, s12, s13
 8015008:	4402      	add	r2, r0
 801500a:	4403      	add	r3, r0
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801500c:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8015010:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 8015014:	d1e6      	bne.n	8014fe4 <cblas_cherk+0x344>
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015016:	ed54 7a01 	vldr	s15, [r4, #-4]
 801501a:	eee8 7a24 	vfma.f32	s15, s16, s9
      for (j = 0; j <= i; j++) {
 801501e:	f10e 0e01 	add.w	lr, lr, #1
 8015022:	45ce      	cmp	lr, r9
 8015024:	f104 0408 	add.w	r4, r4, #8
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015028:	ed44 7a03 	vstr	s15, [r4, #-12]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801502c:	eddc 7a01 	vldr	s15, [ip, #4]
 8015030:	eee8 7a05 	vfma.f32	s15, s16, s10
 8015034:	f10c 0c08 	add.w	ip, ip, #8
 8015038:	ed4c 7a01 	vstr	s15, [ip, #-4]
      for (j = 0; j <= i; j++) {
 801503c:	d1c8      	bne.n	8014fd0 <cblas_cherk+0x330>
    for (i = 0; i < N; i++) {
 801503e:	454e      	cmp	r6, r9
 8015040:	44c3      	add	fp, r8
 8015042:	f10a 0a08 	add.w	sl, sl, #8
 8015046:	f109 0301 	add.w	r3, r9, #1
 801504a:	f43f aef1 	beq.w	8014e30 <cblas_cherk+0x190>
 801504e:	4699      	mov	r9, r3
 8015050:	e7b6      	b.n	8014fc0 <cblas_cherk+0x320>
 8015052:	462b      	mov	r3, r5
 8015054:	e6f2      	b.n	8014e3c <cblas_cherk+0x19c>
  if (beta == 0.0) {
 8015056:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801505a:	f000 8176 	beq.w	801534a <cblas_cherk+0x6aa>
  } else if (beta != 1.0) {
 801505e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015062:	eef4 8a67 	vcmp.f32	s17, s15
 8015066:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801506a:	f040 80f2 	bne.w	8015252 <cblas_cherk+0x5b2>
    for (i = 0; i < N; i++) {
 801506e:	2e00      	cmp	r6, #0
 8015070:	f77f aede 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015074:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015078:	2079      	movs	r0, #121	; 0x79
 801507a:	e707      	b.n	8014e8c <cblas_cherk+0x1ec>
    for (i = 0; i < N; i++) {
 801507c:	2e00      	cmp	r6, #0
 801507e:	f77f aed7 	ble.w	8014e30 <cblas_cherk+0x190>
 8015082:	f108 0801 	add.w	r8, r8, #1
 8015086:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 801508a:	f04f 0a00 	mov.w	sl, #0
 801508e:	9302      	str	r3, [sp, #8]
 8015090:	00e3      	lsls	r3, r4, #3
 8015092:	f8dd b004 	ldr.w	fp, [sp, #4]
 8015096:	9301      	str	r3, [sp, #4]
 8015098:	46d1      	mov	r9, sl
 801509a:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
 801509e:	46b8      	mov	r8, r7
        BASE temp_real = 0.0;
 80150a0:	46d6      	mov	lr, sl
 80150a2:	4658      	mov	r0, fp
 80150a4:	46cc      	mov	ip, r9
        BASE temp_imag = 0.0;
 80150a6:	ed9f 5a20 	vldr	s10, [pc, #128]	; 8015128 <cblas_cherk+0x488>
        for (k = 0; k < K; k++) {
 80150aa:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 80150ac:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 80150b0:	dd1b      	ble.n	80150ea <cblas_cherk+0x44a>
 80150b2:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 80150b6:	4643      	mov	r3, r8
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80150b8:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 80150bc:	ed92 6a01 	vldr	s12, [r2, #4]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80150c0:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80150c4:	edd3 6a00 	vldr	s13, [r3]
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80150c8:	ee26 7a27 	vmul.f32	s14, s12, s15
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80150cc:	ee67 7aa5 	vmul.f32	s15, s15, s11
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80150d0:	eea6 7aa5 	vfma.f32	s14, s13, s11
 80150d4:	3308      	adds	r3, #8
        for (k = 0; k < K; k++) {
 80150d6:	4299      	cmp	r1, r3
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80150d8:	eee6 7a66 	vfms.f32	s15, s12, s13
 80150dc:	f102 0208 	add.w	r2, r2, #8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80150e0:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80150e4:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 80150e8:	d1e6      	bne.n	80150b8 <cblas_cherk+0x418>
        REAL(C, i * ldc + j) += alpha * temp_real;
 80150ea:	ed90 7a00 	vldr	s14, [r0]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 80150ee:	edd0 7a01 	vldr	s15, [r0, #4]
        REAL(C, i * ldc + j) += alpha * temp_real;
 80150f2:	eea4 7a88 	vfma.f32	s14, s9, s16
      for (j = i; j < N; j++) {
 80150f6:	f10c 0c01 	add.w	ip, ip, #1
 80150fa:	4566      	cmp	r6, ip
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 80150fc:	eee8 7a05 	vfma.f32	s15, s16, s10
 8015100:	44a6      	add	lr, r4
 8015102:	f100 0008 	add.w	r0, r0, #8
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015106:	ed00 7a02 	vstr	s14, [r0, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801510a:	ed40 7a01 	vstr	s15, [r0, #-4]
      for (j = i; j < N; j++) {
 801510e:	dcca      	bgt.n	80150a6 <cblas_cherk+0x406>
    for (i = 0; i < N; i++) {
 8015110:	9b02      	ldr	r3, [sp, #8]
 8015112:	f109 0901 	add.w	r9, r9, #1
 8015116:	449b      	add	fp, r3
 8015118:	9b01      	ldr	r3, [sp, #4]
 801511a:	454e      	cmp	r6, r9
 801511c:	44a2      	add	sl, r4
 801511e:	4498      	add	r8, r3
 8015120:	4419      	add	r1, r3
 8015122:	d1bd      	bne.n	80150a0 <cblas_cherk+0x400>
 8015124:	e684      	b.n	8014e30 <cblas_cherk+0x190>
 8015126:	bf00      	nop
 8015128:	00000000 	.word	0x00000000
 801512c:	08030378 	.word	0x08030378
 8015130:	08030740 	.word	0x08030740
 8015134:	080305a8 	.word	0x080305a8
 8015138:	00000000 	.word	0x00000000
  } else if (beta != 1.0) {
 801513c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015140:	eef4 8a67 	vcmp.f32	s17, s15
 8015144:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015148:	f000 8097 	beq.w	801527a <cblas_cherk+0x5da>
      for (i = 0; i < N; i++) {
 801514c:	2e00      	cmp	r6, #0
 801514e:	f77f ae6f 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015152:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015156:	207a      	movs	r0, #122	; 0x7a
 8015158:	e042      	b.n	80151e0 <cblas_cherk+0x540>
  if (beta == 0.0) {
 801515a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801515e:	d17e      	bne.n	801525e <cblas_cherk+0x5be>
      for (i = 0; i < N; i++) {
 8015160:	2e00      	cmp	r6, #0
 8015162:	f77f ae65 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015166:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801516a:	207a      	movs	r0, #122	; 0x7a
 801516c:	e6bf      	b.n	8014eee <cblas_cherk+0x24e>
      for (i = 0; i < N; i++) {
 801516e:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015170:	bfc8      	it	gt
 8015172:	f04f 0b6f 	movgt.w	fp, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8015176:	f77f ae5b 	ble.w	8014e30 <cblas_cherk+0x190>
 801517a:	9b01      	ldr	r3, [sp, #4]
 801517c:	ea4f 00c8 	mov.w	r0, r8, lsl #3
 8015180:	f1a3 0208 	sub.w	r2, r3, #8
        IMAG(C, ldc * i + i) = 0;
 8015184:	f04f 0900 	mov.w	r9, #0
 8015188:	f100 0c08 	add.w	ip, r0, #8
 801518c:	eb02 02c6 	add.w	r2, r2, r6, lsl #3
 8015190:	1d19      	adds	r1, r3, #4
      for (i = 0; i < N; i++) {
 8015192:	f04f 0e00 	mov.w	lr, #0
        REAL(C, ldc * i + i) *= beta;
 8015196:	ed51 7a01 	vldr	s15, [r1, #-4]
        IMAG(C, ldc * i + i) = 0;
 801519a:	f8c1 9000 	str.w	r9, [r1]
        REAL(C, ldc * i + i) *= beta;
 801519e:	ee67 7aa8 	vmul.f32	s15, s15, s17
        for (j = i + 1; j < N; j++) {
 80151a2:	f10e 0e01 	add.w	lr, lr, #1
 80151a6:	4576      	cmp	r6, lr
        REAL(C, ldc * i + i) *= beta;
 80151a8:	ed41 7a01 	vstr	s15, [r1, #-4]
        for (j = i + 1; j < N; j++) {
 80151ac:	f77f ade8 	ble.w	8014d80 <cblas_cherk+0xe0>
 80151b0:	1f0b      	subs	r3, r1, #4
          REAL(C, ldc * i + j) *= beta;
 80151b2:	ed93 7a02 	vldr	s14, [r3, #8]
          IMAG(C, ldc * i + j) *= beta;
 80151b6:	edd3 7a03 	vldr	s15, [r3, #12]
          REAL(C, ldc * i + j) *= beta;
 80151ba:	ee27 7a28 	vmul.f32	s14, s14, s17
          IMAG(C, ldc * i + j) *= beta;
 80151be:	ee67 7aa8 	vmul.f32	s15, s15, s17
          REAL(C, ldc * i + j) *= beta;
 80151c2:	ed83 7a02 	vstr	s14, [r3, #8]
          IMAG(C, ldc * i + j) *= beta;
 80151c6:	edc3 7a03 	vstr	s15, [r3, #12]
        for (j = i + 1; j < N; j++) {
 80151ca:	3308      	adds	r3, #8
 80151cc:	429a      	cmp	r2, r3
 80151ce:	d1f0      	bne.n	80151b2 <cblas_cherk+0x512>
 80151d0:	4402      	add	r2, r0
 80151d2:	4461      	add	r1, ip
 80151d4:	e7df      	b.n	8015196 <cblas_cherk+0x4f6>
    if (uplo == CblasUpper) {
 80151d6:	2879      	cmp	r0, #121	; 0x79
 80151d8:	d056      	beq.n	8015288 <cblas_cherk+0x5e8>
      for (i = 0; i < N; i++) {
 80151da:	2e00      	cmp	r6, #0
 80151dc:	f77f aed6 	ble.w	8014f8c <cblas_cherk+0x2ec>
        for (j = 0; j < i; j++) {
 80151e0:	9b01      	ldr	r3, [sp, #4]
        IMAG(C, ldc * i + i) = 0;
 80151e2:	ed1f 7a2b 	vldr	s14, [pc, #-172]	; 8015138 <cblas_cherk+0x498>
 80151e6:	1d1a      	adds	r2, r3, #4
 80151e8:	9202      	str	r2, [sp, #8]
 80151ea:	9a02      	ldr	r2, [sp, #8]
 80151ec:	f108 0101 	add.w	r1, r8, #1
 80151f0:	e9cd 0b02 	strd	r0, fp, [sp, #8]
 80151f4:	ea4f 0ac1 	mov.w	sl, r1, lsl #3
 80151f8:	4694      	mov	ip, r2
 80151fa:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
      for (i = 0; i < N; i++) {
 80151fe:	46c6      	mov	lr, r8
      for (i = 0; i < N; i++) {
 8015200:	f04f 0900 	mov.w	r9, #0
 8015204:	4618      	mov	r0, r3
 8015206:	4693      	mov	fp, r2
        REAL(C, ldc * i + i) *= beta;
 8015208:	ed5c 7a01 	vldr	s15, [ip, #-4]
        IMAG(C, ldc * i + i) = 0;
 801520c:	ed8c 7a00 	vstr	s14, [ip]
        REAL(C, ldc * i + i) *= beta;
 8015210:	ee67 7aa8 	vmul.f32	s15, s15, s17
      for (i = 0; i < N; i++) {
 8015214:	f109 0901 	add.w	r9, r9, #1
 8015218:	454e      	cmp	r6, r9
        REAL(C, ldc * i + i) *= beta;
 801521a:	ed4c 7a01 	vstr	s15, [ip, #-4]
      for (i = 0; i < N; i++) {
 801521e:	f77f aeb3 	ble.w	8014f88 <cblas_cherk+0x2e8>
        for (j = 0; j < i; j++) {
 8015222:	eb00 03ce 	add.w	r3, r0, lr, lsl #3
 8015226:	eb0b 02ce 	add.w	r2, fp, lr, lsl #3
          REAL(C, ldc * i + j) *= beta;
 801522a:	ed52 7a01 	vldr	s15, [r2, #-4]
 801522e:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8015232:	3308      	adds	r3, #8
 8015234:	ed42 7a01 	vstr	s15, [r2, #-4]
          IMAG(C, ldc * i + j) *= beta;
 8015238:	ed53 7a01 	vldr	s15, [r3, #-4]
 801523c:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8015240:	3208      	adds	r2, #8
 8015242:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < i; j++) {
 8015246:	4299      	cmp	r1, r3
 8015248:	d1ef      	bne.n	801522a <cblas_cherk+0x58a>
 801524a:	44c6      	add	lr, r8
 801524c:	4451      	add	r1, sl
 801524e:	44d4      	add	ip, sl
 8015250:	e7da      	b.n	8015208 <cblas_cherk+0x568>
      for (i = 0; i < N; i++) {
 8015252:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015254:	bfc8      	it	gt
 8015256:	f04f 0b71 	movgt.w	fp, #113	; 0x71
      for (i = 0; i < N; i++) {
 801525a:	dc8e      	bgt.n	801517a <cblas_cherk+0x4da>
 801525c:	e5e8      	b.n	8014e30 <cblas_cherk+0x190>
  } else if (beta != 1.0) {
 801525e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015262:	eef4 8a67 	vcmp.f32	s17, s15
 8015266:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801526a:	d075      	beq.n	8015358 <cblas_cherk+0x6b8>
      for (i = 0; i < N; i++) {
 801526c:	2e00      	cmp	r6, #0
 801526e:	f77f addf 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015272:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015276:	207a      	movs	r0, #122	; 0x7a
 8015278:	e7b2      	b.n	80151e0 <cblas_cherk+0x540>
    for (i = 0; i < N; i++) {
 801527a:	2e00      	cmp	r6, #0
 801527c:	f77f add8 	ble.w	8014e30 <cblas_cherk+0x190>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 8015280:	f04f 0b6f 	mov.w	fp, #111	; 0x6f
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015284:	207a      	movs	r0, #122	; 0x7a
 8015286:	e601      	b.n	8014e8c <cblas_cherk+0x1ec>
      for (i = 0; i < N; i++) {
 8015288:	2e00      	cmp	r6, #0
 801528a:	f73f af76 	bgt.w	801517a <cblas_cherk+0x4da>
 801528e:	e577      	b.n	8014d80 <cblas_cherk+0xe0>
    for (i = 0; i < N; i++) {
 8015290:	2e00      	cmp	r6, #0
 8015292:	f77f adcd 	ble.w	8014e30 <cblas_cherk+0x190>
 8015296:	f108 0301 	add.w	r3, r8, #1
 801529a:	00db      	lsls	r3, r3, #3
 801529c:	9303      	str	r3, [sp, #12]
 801529e:	9b01      	ldr	r3, [sp, #4]
 80152a0:	f04f 0b00 	mov.w	fp, #0
 80152a4:	f103 0908 	add.w	r9, r3, #8
 80152a8:	00e2      	lsls	r2, r4, #3
 80152aa:	3304      	adds	r3, #4
 80152ac:	e9cd 6804 	strd	r6, r8, [sp, #16]
 80152b0:	46de      	mov	lr, fp
 80152b2:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
 80152b6:	46ba      	mov	sl, r7
 80152b8:	9302      	str	r3, [sp, #8]
 80152ba:	4690      	mov	r8, r2
 80152bc:	9b01      	ldr	r3, [sp, #4]
 80152be:	eb03 00cb 	add.w	r0, r3, fp, lsl #3
 80152c2:	9b02      	ldr	r3, [sp, #8]
        BASE temp_real = 0.0;
 80152c4:	f04f 0c00 	mov.w	ip, #0
 80152c8:	eb03 06cb 	add.w	r6, r3, fp, lsl #3
        BASE temp_imag = 0.0;
 80152cc:	ed1f 5a66 	vldr	s10, [pc, #-408]	; 8015138 <cblas_cherk+0x498>
        for (k = 0; k < K; k++) {
 80152d0:	2d00      	cmp	r5, #0
        BASE temp_real = 0.0;
 80152d2:	eef0 4a45 	vmov.f32	s9, s10
        for (k = 0; k < K; k++) {
 80152d6:	dd1b      	ble.n	8015310 <cblas_cherk+0x670>
 80152d8:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 80152dc:	4653      	mov	r3, sl
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80152de:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 80152e2:	ed92 6a01 	vldr	s12, [r2, #4]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80152e6:	edd2 5a00 	vldr	s11, [r2]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80152ea:	edd3 6a00 	vldr	s13, [r3]
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80152ee:	ee26 7a27 	vmul.f32	s14, s12, s15
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80152f2:	ee67 7aa5 	vmul.f32	s15, s15, s11
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80152f6:	eea6 7aa5 	vfma.f32	s14, s13, s11
 80152fa:	3308      	adds	r3, #8
        for (k = 0; k < K; k++) {
 80152fc:	4299      	cmp	r1, r3
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80152fe:	eee6 7a66 	vfms.f32	s15, s12, s13
 8015302:	f102 0208 	add.w	r2, r2, #8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8015306:	ee74 4a87 	vadd.f32	s9, s9, s14
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801530a:	ee35 5a27 	vadd.f32	s10, s10, s15
        for (k = 0; k < K; k++) {
 801530e:	d1e6      	bne.n	80152de <cblas_cherk+0x63e>
        REAL(C, i * ldc + j) += alpha * temp_real;
 8015310:	ed56 7a01 	vldr	s15, [r6, #-4]
 8015314:	eee8 7a24 	vfma.f32	s15, s16, s9
 8015318:	3008      	adds	r0, #8
 801531a:	44a4      	add	ip, r4
 801531c:	3608      	adds	r6, #8
 801531e:	ed46 7a03 	vstr	s15, [r6, #-12]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 8015322:	ed50 7a01 	vldr	s15, [r0, #-4]
 8015326:	eee8 7a05 	vfma.f32	s15, s16, s10
 801532a:	ed40 7a01 	vstr	s15, [r0, #-4]
      for (j = 0; j <= i; j++) {
 801532e:	4581      	cmp	r9, r0
 8015330:	d1cc      	bne.n	80152cc <cblas_cherk+0x62c>
    for (i = 0; i < N; i++) {
 8015332:	9b05      	ldr	r3, [sp, #20]
 8015334:	449b      	add	fp, r3
 8015336:	9b03      	ldr	r3, [sp, #12]
 8015338:	4499      	add	r9, r3
 801533a:	9b04      	ldr	r3, [sp, #16]
 801533c:	f10e 0e01 	add.w	lr, lr, #1
 8015340:	4573      	cmp	r3, lr
 8015342:	44c2      	add	sl, r8
 8015344:	4441      	add	r1, r8
 8015346:	d1b9      	bne.n	80152bc <cblas_cherk+0x61c>
 8015348:	e572      	b.n	8014e30 <cblas_cherk+0x190>
      for (i = 0; i < N; i++) {
 801534a:	2e00      	cmp	r6, #0
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801534c:	bfc8      	it	gt
 801534e:	f04f 0b71 	movgt.w	fp, #113	; 0x71
      for (i = 0; i < N; i++) {
 8015352:	f73f ad00 	bgt.w	8014d56 <cblas_cherk+0xb6>
 8015356:	e56b      	b.n	8014e30 <cblas_cherk+0x190>
    for (i = 0; i < N; i++) {
 8015358:	2e00      	cmp	r6, #0
 801535a:	dd07      	ble.n	801536c <cblas_cherk+0x6cc>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801535c:	f04f 0b71 	mov.w	fp, #113	; 0x71
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015360:	207a      	movs	r0, #122	; 0x7a
 8015362:	e593      	b.n	8014e8c <cblas_cherk+0x1ec>
      for (i = 0; i < N; i++) {
 8015364:	2e00      	cmp	r6, #0
 8015366:	f73f acf6 	bgt.w	8014d56 <cblas_cherk+0xb6>
 801536a:	e509      	b.n	8014d80 <cblas_cherk+0xe0>
  if (alpha == 0.0)
 801536c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 8015370:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015374:	f47f ae17 	bne.w	8014fa6 <cblas_cherk+0x306>
 8015378:	e55a      	b.n	8014e30 <cblas_cherk+0x190>
 801537a:	bf00      	nop

0801537c <cblas_cscal>:
  INDEX i;
  INDEX ix = 0;
  const BASE alpha_real = CONST_REAL0(alpha);
  const BASE alpha_imag = CONST_IMAG0(alpha);

  if (incX <= 0) {
 801537c:	2b00      	cmp	r3, #0
 801537e:	dd21      	ble.n	80153c4 <cblas_cscal+0x48>
    return;
  }

  for (i = 0; i < N; i++) {
 8015380:	2800      	cmp	r0, #0
 8015382:	dd1f      	ble.n	80153c4 <cblas_cscal+0x48>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_cscal (const int N, const void *alpha, void *X, const int incX)
{
 8015384:	b410      	push	{r4}
  const BASE alpha_real = CONST_REAL0(alpha);
 8015386:	edd1 5a00 	vldr	s11, [r1]
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801538a:	ed91 6a01 	vldr	s12, [r1, #4]
 801538e:	00dc      	lsls	r4, r3, #3
  for (i = 0; i < N; i++) {
 8015390:	2100      	movs	r1, #0
 8015392:	1d13      	adds	r3, r2, #4
    const BASE x_real = REAL(X, ix);
    const BASE x_imag = IMAG(X, ix);
 8015394:	edd2 7a01 	vldr	s15, [r2, #4]
    const BASE x_real = REAL(X, ix);
 8015398:	ed53 6a01 	vldr	s13, [r3, #-4]
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 801539c:	ee27 7ac6 	vnmul.f32	s14, s15, s12
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 80153a0:	ee65 7aa7 	vmul.f32	s15, s11, s15
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 80153a4:	eea5 7aa6 	vfma.f32	s14, s11, s13
  for (i = 0; i < N; i++) {
 80153a8:	3101      	adds	r1, #1
 80153aa:	4288      	cmp	r0, r1
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 80153ac:	eee6 7a26 	vfma.f32	s15, s12, s13
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 80153b0:	ed03 7a01 	vstr	s14, [r3, #-4]
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 80153b4:	edc2 7a01 	vstr	s15, [r2, #4]
  for (i = 0; i < N; i++) {
 80153b8:	4423      	add	r3, r4
 80153ba:	4422      	add	r2, r4
 80153bc:	d1ea      	bne.n	8015394 <cblas_cscal+0x18>
#define BASE float
#include "source_scal_c.h"
#undef BASE
}
 80153be:	f85d 4b04 	ldr.w	r4, [sp], #4
 80153c2:	4770      	bx	lr
 80153c4:	4770      	bx	lr
 80153c6:	bf00      	nop

080153c8 <cblas_csscal>:

{
  INDEX i;
  INDEX ix = 0;

  if (incX <= 0) {
 80153c8:	2a00      	cmp	r2, #0
 80153ca:	dd19      	ble.n	8015400 <cblas_csscal+0x38>
    return;
  }

  for (i = 0; i < N; i++) {
 80153cc:	2800      	cmp	r0, #0
 80153ce:	dd17      	ble.n	8015400 <cblas_csscal+0x38>
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_csscal (const int N, const float alpha, void *X, const int incX)
{
 80153d0:	b410      	push	{r4}
 80153d2:	1d0b      	adds	r3, r1, #4
 80153d4:	00d4      	lsls	r4, r2, #3
 80153d6:	2200      	movs	r2, #0
    REAL(X, ix) *= alpha;
 80153d8:	ed53 7a01 	vldr	s15, [r3, #-4]
 80153dc:	ee67 7a80 	vmul.f32	s15, s15, s0
  for (i = 0; i < N; i++) {
 80153e0:	3201      	adds	r2, #1
    REAL(X, ix) *= alpha;
 80153e2:	ed43 7a01 	vstr	s15, [r3, #-4]
    IMAG(X, ix) *= alpha;
 80153e6:	edd1 7a01 	vldr	s15, [r1, #4]
 80153ea:	ee67 7a80 	vmul.f32	s15, s15, s0
  for (i = 0; i < N; i++) {
 80153ee:	4290      	cmp	r0, r2
    IMAG(X, ix) *= alpha;
 80153f0:	edc1 7a01 	vstr	s15, [r1, #4]
  for (i = 0; i < N; i++) {
 80153f4:	4423      	add	r3, r4
 80153f6:	4421      	add	r1, r4
 80153f8:	d1ee      	bne.n	80153d8 <cblas_csscal+0x10>
#define BASE float
#include "source_scal_c_s.h"
#undef BASE
}
 80153fa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80153fe:	4770      	bx	lr
 8015400:	4770      	bx	lr
 8015402:	bf00      	nop

08015404 <cblas_cswap>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_cswap (const int N, void *X, const int incX, void *Y, const int incY)
{
 8015404:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  INDEX i;
  INDEX ix = OFFSET(N, incX);
 8015408:	2a00      	cmp	r2, #0
 801540a:	9f06      	ldr	r7, [sp, #24]
 801540c:	bfda      	itte	le
 801540e:	f1c0 0e01 	rsble	lr, r0, #1
 8015412:	fb0e fe02 	mulle.w	lr, lr, r2
 8015416:	f04f 0e00 	movgt.w	lr, #0
  INDEX iy = OFFSET(N, incY);
 801541a:	2f00      	cmp	r7, #0
 801541c:	bfda      	itte	le
 801541e:	f1c0 0c01 	rsble	ip, r0, #1
 8015422:	fb0c fc07 	mulle.w	ip, ip, r7
 8015426:	f04f 0c00 	movgt.w	ip, #0

  for (i = 0; i < N; i++) {
 801542a:	2800      	cmp	r0, #0
 801542c:	dd22      	ble.n	8015474 <cblas_cswap+0x70>
 801542e:	eb03 04cc 	add.w	r4, r3, ip, lsl #3
 8015432:	eb01 05ce 	add.w	r5, r1, lr, lsl #3
 8015436:	00d6      	lsls	r6, r2, #3
 8015438:	4623      	mov	r3, r4
 801543a:	1d22      	adds	r2, r4, #4
 801543c:	00ff      	lsls	r7, r7, #3
 801543e:	3504      	adds	r5, #4
 8015440:	eb01 01ce 	add.w	r1, r1, lr, lsl #3
 8015444:	2400      	movs	r4, #0
    const BASE tmp_real = REAL(X, ix);
    const BASE tmp_imag = IMAG(X, ix);
    REAL(X, ix) = REAL(Y, iy);
 8015446:	f852 8c04 	ldr.w	r8, [r2, #-4]
    const BASE tmp_real = REAL(X, ix);
 801544a:	f855 ec04 	ldr.w	lr, [r5, #-4]
    const BASE tmp_imag = IMAG(X, ix);
 801544e:	f8d1 c004 	ldr.w	ip, [r1, #4]
    REAL(X, ix) = REAL(Y, iy);
 8015452:	f845 8c04 	str.w	r8, [r5, #-4]
  for (i = 0; i < N; i++) {
 8015456:	3401      	adds	r4, #1
    IMAG(X, ix) = IMAG(Y, iy);
 8015458:	f8d3 8004 	ldr.w	r8, [r3, #4]
 801545c:	f8c1 8004 	str.w	r8, [r1, #4]
  for (i = 0; i < N; i++) {
 8015460:	42a0      	cmp	r0, r4
    REAL(Y, iy) = tmp_real;
 8015462:	f842 ec04 	str.w	lr, [r2, #-4]
    IMAG(Y, iy) = tmp_imag;
 8015466:	4435      	add	r5, r6
 8015468:	f8c3 c004 	str.w	ip, [r3, #4]
  for (i = 0; i < N; i++) {
 801546c:	4431      	add	r1, r6
 801546e:	443a      	add	r2, r7
 8015470:	443b      	add	r3, r7
 8015472:	d1e8      	bne.n	8015446 <cblas_cswap+0x42>
#define BASE float
#include "source_swap_c.h"
#undef BASE
}
 8015474:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08015478 <cblas_csymm>:
void
cblas_csymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 8015478:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801547c:	b08f      	sub	sp, #60	; 0x3c
 801547e:	469b      	mov	fp, r3
 8015480:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8015482:	9301      	str	r3, [sp, #4]
 8015484:	e9dd 7319 	ldrd	r7, r3, [sp, #100]	; 0x64
 8015488:	9303      	str	r3, [sp, #12]
 801548a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801548c:	9302      	str	r3, [sp, #8]
 801548e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8015490:	9304      	str	r3, [sp, #16]
 8015492:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 8015494:	9306      	str	r3, [sp, #24]
 8015496:	e9dd 831e 	ldrd	r8, r3, [sp, #120]	; 0x78
{
  INDEX i, j, k;
  INDEX n1, n2;
  int uplo, side;

  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801549a:	298d      	cmp	r1, #141	; 0x8d
 801549c:	9307      	str	r3, [sp, #28]
 801549e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 80154a0:	9305      	str	r3, [sp, #20]
 80154a2:	460c      	mov	r4, r1
 80154a4:	4606      	mov	r6, r0
 80154a6:	4615      	mov	r5, r2
 80154a8:	f000 80dc 	beq.w	8015664 <cblas_csymm+0x1ec>
 80154ac:	298e      	cmp	r1, #142	; 0x8e
 80154ae:	f000 8451 	beq.w	8015d54 <cblas_csymm+0x8dc>
 80154b2:	9b01      	ldr	r3, [sp, #4]
 80154b4:	2002      	movs	r0, #2
 80154b6:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 80154ba:	2a01      	cmp	r2, #1
 80154bc:	bf88      	it	hi
 80154be:	2003      	movhi	r0, #3
 80154c0:	9a01      	ldr	r2, [sp, #4]
 80154c2:	f1bb 0f00 	cmp.w	fp, #0
 80154c6:	bfb8      	it	lt
 80154c8:	2004      	movlt	r0, #4
 80154ca:	2b01      	cmp	r3, #1
 80154cc:	bfb8      	it	lt
 80154ce:	2301      	movlt	r3, #1
 80154d0:	2a00      	cmp	r2, #0
 80154d2:	9a02      	ldr	r2, [sp, #8]
 80154d4:	f2c0 80bb 	blt.w	801564e <cblas_csymm+0x1d6>
 80154d8:	4293      	cmp	r3, r2
 80154da:	dd6b      	ble.n	80155b4 <cblas_csymm+0x13c>
 80154dc:	2e65      	cmp	r6, #101	; 0x65
 80154de:	f000 8259 	beq.w	8015994 <cblas_csymm+0x51c>
 80154e2:	2e66      	cmp	r6, #102	; 0x66
 80154e4:	f000 8428 	beq.w	8015d38 <cblas_csymm+0x8c0>
 80154e8:	2008      	movs	r0, #8
 80154ea:	4ac9      	ldr	r2, [pc, #804]	; (8015810 <cblas_csymm+0x398>)
 80154ec:	49c9      	ldr	r1, [pc, #804]	; (8015814 <cblas_csymm+0x39c>)
 80154ee:	f012 faab 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 80154f2:	edd7 4a00 	vldr	s9, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80154f6:	ed97 4a01 	vldr	s8, [r7, #4]
    const BASE beta_real = CONST_REAL0(beta);
 80154fa:	edd8 5a00 	vldr	s11, [r8]
    const BASE beta_imag = CONST_IMAG0(beta);
 80154fe:	ed98 5a01 	vldr	s10, [r8, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8015502:	eef5 4a40 	vcmp.f32	s9, #0.0
 8015506:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801550a:	d10b      	bne.n	8015524 <cblas_csymm+0xac>
 801550c:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8015510:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015514:	d106      	bne.n	8015524 <cblas_csymm+0xac>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8015516:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801551a:	eef4 5a67 	vcmp.f32	s11, s15
 801551e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015522:	d050      	beq.n	80155c6 <cblas_csymm+0x14e>
      return;

    if (Order == CblasRowMajor) {
 8015524:	2e65      	cmp	r6, #101	; 0x65
 8015526:	f000 80a4 	beq.w	8015672 <cblas_csymm+0x1fa>
      uplo = Uplo;
      side = Side;
    } else {
      n1 = N;
      n2 = M;
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801552a:	2d79      	cmp	r5, #121	; 0x79
 801552c:	bf0c      	ite	eq
 801552e:	257a      	moveq	r5, #122	; 0x7a
 8015530:	2579      	movne	r5, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8015532:	2c8d      	cmp	r4, #141	; 0x8d
 8015534:	bf0c      	ite	eq
 8015536:	248e      	moveq	r4, #142	; 0x8e
 8015538:	248d      	movne	r4, #141	; 0x8d
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801553a:	eef5 5a40 	vcmp.f32	s11, #0.0
 801553e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015542:	d148      	bne.n	80155d6 <cblas_csymm+0x15e>
 8015544:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8015548:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801554c:	d14f      	bne.n	80155ee <cblas_csymm+0x176>
      for (i = 0; i < n1; i++) {
 801554e:	9b01      	ldr	r3, [sp, #4]
 8015550:	2b00      	cmp	r3, #0
 8015552:	dd18      	ble.n	8015586 <cblas_csymm+0x10e>
 8015554:	9a05      	ldr	r2, [sp, #20]
 8015556:	00d6      	lsls	r6, r2, #3
 8015558:	9a07      	ldr	r2, [sp, #28]
 801555a:	ebcb 704b 	rsb	r0, fp, fp, lsl #29
 801555e:	00c0      	lsls	r0, r0, #3
 8015560:	eb02 02cb 	add.w	r2, r2, fp, lsl #3
 8015564:	2100      	movs	r1, #0
        for (j = 0; j < n2; j++) {
          REAL(C, ldc * i + j) = 0.0;
 8015566:	2700      	movs	r7, #0
 8015568:	469c      	mov	ip, r3
        for (j = 0; j < n2; j++) {
 801556a:	f1bb 0f00 	cmp.w	fp, #0
 801556e:	bfc8      	it	gt
 8015570:	1883      	addgt	r3, r0, r2
 8015572:	dd04      	ble.n	801557e <cblas_csymm+0x106>
          REAL(C, ldc * i + j) = 0.0;
 8015574:	601f      	str	r7, [r3, #0]
          IMAG(C, ldc * i + j) = 0.0;
 8015576:	605f      	str	r7, [r3, #4]
        for (j = 0; j < n2; j++) {
 8015578:	3308      	adds	r3, #8
 801557a:	429a      	cmp	r2, r3
 801557c:	d1fa      	bne.n	8015574 <cblas_csymm+0xfc>
      for (i = 0; i < n1; i++) {
 801557e:	3101      	adds	r1, #1
 8015580:	458c      	cmp	ip, r1
 8015582:	4432      	add	r2, r6
 8015584:	d1f1      	bne.n	801556a <cblas_csymm+0xf2>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8015586:	eef5 4a40 	vcmp.f32	s9, #0.0
 801558a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801558e:	d104      	bne.n	801559a <cblas_csymm+0x122>
 8015590:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8015594:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015598:	d01a      	beq.n	80155d0 <cblas_csymm+0x158>
      return;

    if (side == CblasLeft && uplo == CblasUpper) {
 801559a:	2c8d      	cmp	r4, #141	; 0x8d
 801559c:	d06e      	beq.n	801567c <cblas_csymm+0x204>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper) {
 801559e:	2c8e      	cmp	r4, #142	; 0x8e
 80155a0:	f000 813e 	beq.w	8015820 <cblas_csymm+0x3a8>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 80155a4:	4a9c      	ldr	r2, [pc, #624]	; (8015818 <cblas_csymm+0x3a0>)
 80155a6:	499b      	ldr	r1, [pc, #620]	; (8015814 <cblas_csymm+0x39c>)
 80155a8:	2000      	movs	r0, #0
#define BASE float
#include "source_symm_c.h"
#undef BASE
}
 80155aa:	b00f      	add	sp, #60	; 0x3c
 80155ac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80155b0:	f012 ba4a 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80155b4:	2e65      	cmp	r6, #101	; 0x65
 80155b6:	f000 81fb 	beq.w	80159b0 <cblas_csymm+0x538>
 80155ba:	2e66      	cmp	r6, #102	; 0x66
 80155bc:	f000 838b 	beq.w	8015cd6 <cblas_csymm+0x85e>
 80155c0:	2800      	cmp	r0, #0
 80155c2:	d096      	beq.n	80154f2 <cblas_csymm+0x7a>
 80155c4:	e791      	b.n	80154ea <cblas_csymm+0x72>
        && (beta_real == 1.0 && beta_imag == 0.0))
 80155c6:	eeb5 5a40 	vcmp.f32	s10, #0.0
 80155ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80155ce:	d1a9      	bne.n	8015524 <cblas_csymm+0xac>
 80155d0:	b00f      	add	sp, #60	; 0x3c
 80155d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 80155d6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80155da:	eef4 5a67 	vcmp.f32	s11, s15
 80155de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80155e2:	d104      	bne.n	80155ee <cblas_csymm+0x176>
 80155e4:	eeb5 5a40 	vcmp.f32	s10, #0.0
 80155e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80155ec:	d0cb      	beq.n	8015586 <cblas_csymm+0x10e>
      for (i = 0; i < n1; i++) {
 80155ee:	9901      	ldr	r1, [sp, #4]
 80155f0:	2900      	cmp	r1, #0
 80155f2:	ddc8      	ble.n	8015586 <cblas_csymm+0x10e>
 80155f4:	9b05      	ldr	r3, [sp, #20]
 80155f6:	ebcb 7c4b 	rsb	ip, fp, fp, lsl #29
 80155fa:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
 80155fe:	9b07      	ldr	r3, [sp, #28]
 8015600:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8015604:	f10c 0804 	add.w	r8, ip, #4
 8015608:	eb03 06cb 	add.w	r6, r3, fp, lsl #3
 801560c:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 801560e:	f1bb 0f00 	cmp.w	fp, #0
 8015612:	dd17      	ble.n	8015644 <cblas_csymm+0x1cc>
 8015614:	eb0c 0306 	add.w	r3, ip, r6
 8015618:	eb08 0206 	add.w	r2, r8, r6
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 801561c:	edd3 6a01 	vldr	s13, [r3, #4]
          const BASE Cij_real = REAL(C, ldc * i + j);
 8015620:	ed12 6a01 	vldr	s12, [r2, #-4]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8015624:	ee26 7ac5 	vnmul.f32	s14, s13, s10
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8015628:	ee65 7a06 	vmul.f32	s15, s10, s12
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801562c:	eea5 7a86 	vfma.f32	s14, s11, s12
 8015630:	3308      	adds	r3, #8
 8015632:	3208      	adds	r2, #8
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8015634:	eee5 7aa6 	vfma.f32	s15, s11, s13
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8015638:	ed02 7a03 	vstr	s14, [r2, #-12]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801563c:	ed43 7a01 	vstr	s15, [r3, #-4]
        for (j = 0; j < n2; j++) {
 8015640:	429e      	cmp	r6, r3
 8015642:	d1eb      	bne.n	801561c <cblas_csymm+0x1a4>
      for (i = 0; i < n1; i++) {
 8015644:	3701      	adds	r7, #1
 8015646:	42b9      	cmp	r1, r7
 8015648:	4476      	add	r6, lr
 801564a:	d1e0      	bne.n	801560e <cblas_csymm+0x196>
 801564c:	e79b      	b.n	8015586 <cblas_csymm+0x10e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801564e:	429a      	cmp	r2, r3
 8015650:	f6ff af44 	blt.w	80154dc <cblas_csymm+0x64>
 8015654:	2e65      	cmp	r6, #101	; 0x65
 8015656:	f000 8334 	beq.w	8015cc2 <cblas_csymm+0x84a>
 801565a:	2e66      	cmp	r6, #102	; 0x66
 801565c:	f000 8389 	beq.w	8015d72 <cblas_csymm+0x8fa>
 8015660:	2005      	movs	r0, #5
 8015662:	e742      	b.n	80154ea <cblas_csymm+0x72>
 8015664:	3865      	subs	r0, #101	; 0x65
 8015666:	2801      	cmp	r0, #1
 8015668:	bf94      	ite	ls
 801566a:	2000      	movls	r0, #0
 801566c:	2001      	movhi	r0, #1
 801566e:	465b      	mov	r3, fp
 8015670:	e721      	b.n	80154b6 <cblas_csymm+0x3e>
      uplo = Uplo;
 8015672:	9b01      	ldr	r3, [sp, #4]
      side = Side;
 8015674:	f8cd b004 	str.w	fp, [sp, #4]
 8015678:	469b      	mov	fp, r3
 801567a:	e75e      	b.n	801553a <cblas_csymm+0xc2>
    if (side == CblasLeft && uplo == CblasUpper) {
 801567c:	2d79      	cmp	r5, #121	; 0x79
 801567e:	f000 81a5 	beq.w	80159cc <cblas_csymm+0x554>
    } else if (side == CblasLeft && uplo == CblasLower) {
 8015682:	2d7a      	cmp	r5, #122	; 0x7a
 8015684:	d18e      	bne.n	80155a4 <cblas_csymm+0x12c>
      for (i = 0; i < n1; i++) {
 8015686:	9b01      	ldr	r3, [sp, #4]
 8015688:	2b00      	cmp	r3, #0
 801568a:	dda1      	ble.n	80155d0 <cblas_csymm+0x158>
 801568c:	9b02      	ldr	r3, [sp, #8]
 801568e:	9d03      	ldr	r5, [sp, #12]
 8015690:	9502      	str	r5, [sp, #8]
 8015692:	3301      	adds	r3, #1
 8015694:	00da      	lsls	r2, r3, #3
 8015696:	2300      	movs	r3, #0
 8015698:	9308      	str	r3, [sp, #32]
 801569a:	9309      	str	r3, [sp, #36]	; 0x24
 801569c:	4699      	mov	r9, r3
 801569e:	9b05      	ldr	r3, [sp, #20]
 80156a0:	920b      	str	r2, [sp, #44]	; 0x2c
 80156a2:	00dc      	lsls	r4, r3, #3
 80156a4:	9b06      	ldr	r3, [sp, #24]
 80156a6:	f8cd b00c 	str.w	fp, [sp, #12]
 80156aa:	00de      	lsls	r6, r3, #3
 80156ac:	9b04      	ldr	r3, [sp, #16]
 80156ae:	3304      	adds	r3, #4
 80156b0:	930c      	str	r3, [sp, #48]	; 0x30
 80156b2:	9b07      	ldr	r3, [sp, #28]
 80156b4:	3a08      	subs	r2, #8
 80156b6:	920a      	str	r2, [sp, #40]	; 0x28
 80156b8:	1d1a      	adds	r2, r3, #4
 80156ba:	f105 0a04 	add.w	sl, r5, #4
 80156be:	9207      	str	r2, [sp, #28]
 80156c0:	469b      	mov	fp, r3
        for (j = 0; j < n2; j++) {
 80156c2:	9b03      	ldr	r3, [sp, #12]
 80156c4:	2b00      	cmp	r3, #0
 80156c6:	f340 808d 	ble.w	80157e4 <cblas_csymm+0x36c>
 80156ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80156cc:	9a08      	ldr	r2, [sp, #32]
 80156ce:	eb03 0cc2 	add.w	ip, r3, r2, lsl #3
 80156d2:	9b07      	ldr	r3, [sp, #28]
 80156d4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80156d6:	f04f 0804 	mov.w	r8, #4
 80156da:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 80156de:	f04f 0e00 	mov.w	lr, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80156e2:	ed5c 7a01 	vldr	s15, [ip, #-4]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80156e6:	ed9c 7a00 	vldr	s14, [ip]
          BASE temp2_imag = 0.0;
 80156ea:	ed9f 2a4c 	vldr	s4, [pc, #304]	; 801581c <cblas_csymm+0x3a4>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80156ee:	ee24 5a27 	vmul.f32	s10, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80156f2:	ee67 2a44 	vnmul.f32	s5, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80156f6:	eea4 5a87 	vfma.f32	s10, s9, s14
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80156fa:	eee4 2aa7 	vfma.f32	s5, s9, s15
          BASE temp2_real = 0.0;
 80156fe:	eef0 1a42 	vmov.f32	s3, s4
          for (k = 0; k < i; k++) {
 8015702:	f1b9 0f00 	cmp.w	r9, #0
 8015706:	d035      	beq.n	8015774 <cblas_csymm+0x2fc>
 8015708:	9b04      	ldr	r3, [sp, #16]
 801570a:	eb03 0108 	add.w	r1, r3, r8
 801570e:	9b02      	ldr	r3, [sp, #8]
 8015710:	eb0b 00ce 	add.w	r0, fp, lr, lsl #3
 8015714:	eb0b 0208 	add.w	r2, fp, r8
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8015718:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801571c:	ed93 7a00 	vldr	s14, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015720:	ed12 6a01 	vldr	s12, [r2, #-4]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8015724:	ed11 3a01 	vldr	s6, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8015728:	edd1 3a00 	vldr	s7, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 801572c:	ee67 6ac5 	vnmul.f32	s13, s15, s10
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015730:	ee62 5aa7 	vmul.f32	s11, s5, s15
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015734:	eee2 6a87 	vfma.f32	s13, s5, s14
 8015738:	3308      	adds	r3, #8
          for (k = 0; k < i; k++) {
 801573a:	429d      	cmp	r5, r3
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 801573c:	eee5 5a07 	vfma.f32	s11, s10, s14
 8015740:	4431      	add	r1, r6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015742:	ee76 6a26 	vadd.f32	s13, s12, s13
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8015746:	ee23 6ae7 	vnmul.f32	s12, s7, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801574a:	ee67 7a83 	vmul.f32	s15, s15, s6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 801574e:	ed42 6a01 	vstr	s13, [r2, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015752:	edd0 6a01 	vldr	s13, [r0, #4]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8015756:	eea7 6a03 	vfma.f32	s12, s14, s6
 801575a:	4422      	add	r2, r4
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801575c:	eee7 7a23 	vfma.f32	s15, s14, s7
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015760:	ee36 7aa5 	vadd.f32	s14, s13, s11
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8015764:	ee71 1a86 	vadd.f32	s3, s3, s12
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015768:	ed80 7a01 	vstr	s14, [r0, #4]
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801576c:	ee32 2a27 	vadd.f32	s4, s4, s15
          for (k = 0; k < i; k++) {
 8015770:	4420      	add	r0, r4
 8015772:	d1d1      	bne.n	8015718 <cblas_csymm+0x2a0>
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8015774:	ed95 6a01 	vldr	s12, [r5, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8015778:	ed5a 6a01 	vldr	s13, [sl, #-4]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 801577c:	ed17 3a01 	vldr	s6, [r7, #-4]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015780:	edd7 3a00 	vldr	s7, [r7]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8015784:	ee26 7a45 	vnmul.f32	s14, s12, s10
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015788:	ee65 7a26 	vmul.f32	s15, s10, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 801578c:	eea2 7aa6 	vfma.f32	s14, s5, s13
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015790:	463b      	mov	r3, r7
        for (j = 0; j < n2; j++) {
 8015792:	f10e 0e01 	add.w	lr, lr, #1
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015796:	eee2 7a86 	vfma.f32	s15, s5, s12
 801579a:	f10c 0c08 	add.w	ip, ip, #8
 801579e:	f108 0808 	add.w	r8, r8, #8
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 80157a2:	eef0 6a47 	vmov.f32	s13, s14
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 80157a6:	eeb0 5a67 	vmov.f32	s10, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80157aa:	ee22 7a44 	vnmul.f32	s14, s4, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80157ae:	ee64 7a21 	vmul.f32	s15, s8, s3
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80157b2:	eea4 7aa1 	vfma.f32	s14, s9, s3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80157b6:	3708      	adds	r7, #8
 80157b8:	eee4 7a82 	vfma.f32	s15, s9, s4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80157bc:	eef0 5a47 	vmov.f32	s11, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80157c0:	eeb0 6a67 	vmov.f32	s12, s15
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 80157c4:	ee36 7a83 	vadd.f32	s14, s13, s6
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 80157c8:	ee75 7a23 	vadd.f32	s15, s10, s7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80157cc:	ee37 7a25 	vadd.f32	s14, s14, s11
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80157d0:	ee77 7a86 	vadd.f32	s15, s15, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80157d4:	ed07 7a03 	vstr	s14, [r7, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80157d8:	edc3 7a00 	vstr	s15, [r3]
        for (j = 0; j < n2; j++) {
 80157dc:	9b03      	ldr	r3, [sp, #12]
 80157de:	4573      	cmp	r3, lr
 80157e0:	f47f af7f 	bne.w	80156e2 <cblas_csymm+0x26a>
      for (i = 0; i < n1; i++) {
 80157e4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80157e6:	9905      	ldr	r1, [sp, #20]
 80157e8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80157ea:	440a      	add	r2, r1
 80157ec:	9209      	str	r2, [sp, #36]	; 0x24
 80157ee:	9906      	ldr	r1, [sp, #24]
 80157f0:	9a08      	ldr	r2, [sp, #32]
 80157f2:	440a      	add	r2, r1
 80157f4:	441d      	add	r5, r3
 80157f6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80157f8:	9208      	str	r2, [sp, #32]
 80157fa:	449a      	add	sl, r3
 80157fc:	9a02      	ldr	r2, [sp, #8]
 80157fe:	9b01      	ldr	r3, [sp, #4]
 8015800:	f109 0901 	add.w	r9, r9, #1
 8015804:	440a      	add	r2, r1
 8015806:	454b      	cmp	r3, r9
 8015808:	9202      	str	r2, [sp, #8]
 801580a:	f47f af5a 	bne.w	80156c2 <cblas_csymm+0x24a>
 801580e:	e6df      	b.n	80155d0 <cblas_csymm+0x158>
 8015810:	08030378 	.word	0x08030378
 8015814:	08030750 	.word	0x08030750
 8015818:	080305a8 	.word	0x080305a8
 801581c:	00000000 	.word	0x00000000
    } else if (side == CblasRight && uplo == CblasUpper) {
 8015820:	2d79      	cmp	r5, #121	; 0x79
 8015822:	f000 81a5 	beq.w	8015b70 <cblas_csymm+0x6f8>
    } else if (side == CblasRight && uplo == CblasLower) {
 8015826:	2d7a      	cmp	r5, #122	; 0x7a
 8015828:	f47f aebc 	bne.w	80155a4 <cblas_csymm+0x12c>
      for (i = 0; i < n1; i++) {
 801582c:	9b01      	ldr	r3, [sp, #4]
 801582e:	2b00      	cmp	r3, #0
 8015830:	f77f aece 	ble.w	80155d0 <cblas_csymm+0x158>
 8015834:	9a05      	ldr	r2, [sp, #20]
 8015836:	9b02      	ldr	r3, [sp, #8]
 8015838:	f8dd a010 	ldr.w	sl, [sp, #16]
 801583c:	00d2      	lsls	r2, r2, #3
 801583e:	9208      	str	r2, [sp, #32]
 8015840:	e9dd 2806 	ldrd	r2, r8, [sp, #24]
 8015844:	00d2      	lsls	r2, r2, #3
 8015846:	9205      	str	r2, [sp, #20]
 8015848:	9a03      	ldr	r2, [sp, #12]
 801584a:	3301      	adds	r3, #1
 801584c:	ea4f 09c3 	mov.w	r9, r3, lsl #3
 8015850:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8015854:	9306      	str	r3, [sp, #24]
 8015856:	2300      	movs	r3, #0
 8015858:	9304      	str	r3, [sp, #16]
        for (j = 0; j < n2; j++) {
 801585a:	f1bb 0f00 	cmp.w	fp, #0
 801585e:	f340 823c 	ble.w	8015cda <cblas_csymm+0x862>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8015862:	edda 7a00 	vldr	s15, [sl]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8015866:	ed9a 7a01 	vldr	s14, [sl, #4]
          BASE temp2_imag = 0.0;
 801586a:	ed1f 2a14 	vldr	s4, [pc, #-80]	; 801581c <cblas_csymm+0x3a4>
 801586e:	9b03      	ldr	r3, [sp, #12]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8015870:	9c06      	ldr	r4, [sp, #24]
 8015872:	f8dd e008 	ldr.w	lr, [sp, #8]
 8015876:	ee67 3a84 	vmul.f32	s7, s15, s8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801587a:	ee64 2a47 	vnmul.f32	s5, s8, s14
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801587e:	eee7 3a24 	vfma.f32	s7, s14, s9
 8015882:	1d1e      	adds	r6, r3, #4
 8015884:	4657      	mov	r7, sl
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015886:	eee7 2aa4 	vfma.f32	s5, s15, s9
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801588a:	4645      	mov	r5, r8
        for (j = 0; j < n2; j++) {
 801588c:	f04f 0c00 	mov.w	ip, #0
          BASE temp2_real = 0.0;
 8015890:	eef0 1a42 	vmov.f32	s3, s4
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8015894:	ed16 6a01 	vldr	s12, [r6, #-4]
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8015898:	edd6 6a00 	vldr	s13, [r6]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 801589c:	ed95 3a00 	vldr	s6, [r5]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80158a0:	ed95 5a01 	vldr	s10, [r5, #4]
 80158a4:	ee26 7a23 	vmul.f32	s14, s12, s7
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80158a8:	ee63 7ae6 	vnmul.f32	s15, s7, s13
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80158ac:	eea6 7aa2 	vfma.f32	s14, s13, s5
        for (j = 0; j < n2; j++) {
 80158b0:	f10c 0c01 	add.w	ip, ip, #1
 80158b4:	45e3      	cmp	fp, ip
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80158b6:	eee6 7a22 	vfma.f32	s15, s12, s5
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80158ba:	eef0 6a47 	vmov.f32	s13, s14
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80158be:	eef0 3a67 	vmov.f32	s7, s15
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80158c2:	ee24 7a21 	vmul.f32	s14, s8, s3
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80158c6:	ee62 7a44 	vnmul.f32	s15, s4, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80158ca:	eea4 7a82 	vfma.f32	s14, s9, s4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80158ce:	eee4 7aa1 	vfma.f32	s15, s9, s3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80158d2:	eeb0 6a47 	vmov.f32	s12, s14
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80158d6:	eef0 5a67 	vmov.f32	s11, s15
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80158da:	ee36 7a85 	vadd.f32	s14, s13, s10
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80158de:	ee73 7a83 	vadd.f32	s15, s7, s6
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80158e2:	ee37 7a06 	vadd.f32	s14, s14, s12
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80158e6:	ee77 7aa5 	vadd.f32	s15, s15, s11
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80158ea:	ed85 7a01 	vstr	s14, [r5, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80158ee:	edc5 7a00 	vstr	s15, [r5]
        for (j = 0; j < n2; j++) {
 80158f2:	f000 81f2 	beq.w	8015cda <cblas_csymm+0x862>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80158f6:	edd7 7a02 	vldr	s15, [r7, #8]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80158fa:	ed97 7a03 	vldr	s14, [r7, #12]
          BASE temp2_imag = 0.0;
 80158fe:	ed1f 2a39 	vldr	s4, [pc, #-228]	; 801581c <cblas_csymm+0x3a4>
 8015902:	9b03      	ldr	r3, [sp, #12]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8015904:	ee64 3a27 	vmul.f32	s7, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015908:	ee67 2a44 	vnmul.f32	s5, s14, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801590c:	eee4 3a87 	vfma.f32	s7, s9, s14
 8015910:	eb03 03ce 	add.w	r3, r3, lr, lsl #3
 8015914:	f108 0004 	add.w	r0, r8, #4
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015918:	eee4 2aa7 	vfma.f32	s5, s9, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801591c:	4641      	mov	r1, r8
 801591e:	4652      	mov	r2, sl
          BASE temp2_real = 0.0;
 8015920:	eef0 1a42 	vmov.f32	s3, s4
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8015924:	ed93 7a01 	vldr	s14, [r3, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8015928:	edd3 6a00 	vldr	s13, [r3]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801592c:	ed50 5a01 	vldr	s11, [r0, #-4]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 8015930:	edd2 7a01 	vldr	s15, [r2, #4]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8015934:	ed92 3a00 	vldr	s6, [r2]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015938:	ee27 6a63 	vnmul.f32	s12, s14, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801593c:	ee23 5aa6 	vmul.f32	s10, s7, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015940:	eea2 6aa6 	vfma.f32	s12, s5, s13
 8015944:	3308      	adds	r3, #8
          for (k = 0; k < j; k++) {
 8015946:	429c      	cmp	r4, r3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015948:	eea2 5a87 	vfma.f32	s10, s5, s14
 801594c:	f102 0208 	add.w	r2, r2, #8
 8015950:	f100 0008 	add.w	r0, r0, #8
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015954:	ee35 6a86 	vadd.f32	s12, s11, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015958:	ee67 5ac7 	vnmul.f32	s11, s15, s14
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 801595c:	ee66 7aa7 	vmul.f32	s15, s13, s15
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015960:	ed00 6a03 	vstr	s12, [r0, #-12]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015964:	ed91 6a01 	vldr	s12, [r1, #4]
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8015968:	eee7 7a03 	vfma.f32	s15, s14, s6
 801596c:	f101 0108 	add.w	r1, r1, #8
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015970:	eee6 5a83 	vfma.f32	s11, s13, s6
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015974:	ee36 7a05 	vadd.f32	s14, s12, s10
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015978:	ee71 1aa5 	vadd.f32	s3, s3, s11
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801597c:	ed01 7a01 	vstr	s14, [r1, #-4]
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8015980:	ee32 2a27 	vadd.f32	s4, s4, s15
          for (k = 0; k < j; k++) {
 8015984:	d1ce      	bne.n	8015924 <cblas_csymm+0x4ac>
 8015986:	9b02      	ldr	r3, [sp, #8]
 8015988:	3508      	adds	r5, #8
 801598a:	3708      	adds	r7, #8
 801598c:	449e      	add	lr, r3
 801598e:	444c      	add	r4, r9
 8015990:	444e      	add	r6, r9
 8015992:	e77f      	b.n	8015894 <cblas_csymm+0x41c>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8015994:	9b01      	ldr	r3, [sp, #4]
 8015996:	9a06      	ldr	r2, [sp, #24]
 8015998:	2b01      	cmp	r3, #1
 801599a:	bfb8      	it	lt
 801599c:	2301      	movlt	r3, #1
 801599e:	4293      	cmp	r3, r2
 80159a0:	f300 8193 	bgt.w	8015cca <cblas_csymm+0x852>
 80159a4:	9a05      	ldr	r2, [sp, #20]
 80159a6:	4293      	cmp	r3, r2
 80159a8:	bfcc      	ite	gt
 80159aa:	200d      	movgt	r0, #13
 80159ac:	2008      	movle	r0, #8
 80159ae:	e59c      	b.n	80154ea <cblas_csymm+0x72>
 80159b0:	9b01      	ldr	r3, [sp, #4]
 80159b2:	9a06      	ldr	r2, [sp, #24]
 80159b4:	2b01      	cmp	r3, #1
 80159b6:	bfb8      	it	lt
 80159b8:	2301      	movlt	r3, #1
 80159ba:	4293      	cmp	r3, r2
 80159bc:	f300 8185 	bgt.w	8015cca <cblas_csymm+0x852>
 80159c0:	9a05      	ldr	r2, [sp, #20]
 80159c2:	4293      	cmp	r3, r2
 80159c4:	f77f adfc 	ble.w	80155c0 <cblas_csymm+0x148>
 80159c8:	200d      	movs	r0, #13
 80159ca:	e58e      	b.n	80154ea <cblas_csymm+0x72>
      for (i = 0; i < n1; i++) {
 80159cc:	9a01      	ldr	r2, [sp, #4]
 80159ce:	2a00      	cmp	r2, #0
 80159d0:	f77f adfe 	ble.w	80155d0 <cblas_csymm+0x158>
 80159d4:	9b02      	ldr	r3, [sp, #8]
 80159d6:	f8dd e00c 	ldr.w	lr, [sp, #12]
 80159da:	3301      	adds	r3, #1
 80159dc:	00db      	lsls	r3, r3, #3
 80159de:	930d      	str	r3, [sp, #52]	; 0x34
 80159e0:	3b08      	subs	r3, #8
 80159e2:	f1ae 0408 	sub.w	r4, lr, #8
 80159e6:	930c      	str	r3, [sp, #48]	; 0x30
 80159e8:	9b06      	ldr	r3, [sp, #24]
 80159ea:	9308      	str	r3, [sp, #32]
 80159ec:	eb04 04c2 	add.w	r4, r4, r2, lsl #3
 80159f0:	9a05      	ldr	r2, [sp, #20]
 80159f2:	9203      	str	r2, [sp, #12]
 80159f4:	2100      	movs	r1, #0
 80159f6:	00de      	lsls	r6, r3, #3
 80159f8:	2301      	movs	r3, #1
 80159fa:	9109      	str	r1, [sp, #36]	; 0x24
 80159fc:	f10e 0a04 	add.w	sl, lr, #4
 8015a00:	910a      	str	r1, [sp, #40]	; 0x28
 8015a02:	00d5      	lsls	r5, r2, #3
 8015a04:	4699      	mov	r9, r3
        for (j = 0; j < n2; j++) {
 8015a06:	f1bb 0f00 	cmp.w	fp, #0
 8015a0a:	bfd8      	it	le
 8015a0c:	f8cd 902c 	strle.w	r9, [sp, #44]	; 0x2c
 8015a10:	f340 8091 	ble.w	8015b36 <cblas_csymm+0x6be>
 8015a14:	9b08      	ldr	r3, [sp, #32]
 8015a16:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8015a18:	9909      	ldr	r1, [sp, #36]	; 0x24
 8015a1a:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 8015a1e:	eba3 0802 	sub.w	r8, r3, r2
 8015a22:	9b03      	ldr	r3, [sp, #12]
 8015a24:	1a5b      	subs	r3, r3, r1
 8015a26:	00db      	lsls	r3, r3, #3
 8015a28:	3304      	adds	r3, #4
 8015a2a:	9302      	str	r3, [sp, #8]
 8015a2c:	9b04      	ldr	r3, [sp, #16]
 8015a2e:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 8015a32:	9b07      	ldr	r3, [sp, #28]
 8015a34:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8015a38:	f108 0804 	add.w	r8, r8, #4
 8015a3c:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
 8015a40:	f04f 0c00 	mov.w	ip, #0
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8015a44:	edd7 6a00 	vldr	s13, [r7]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8015a48:	ed97 6a01 	vldr	s12, [r7, #4]
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8015a4c:	edde 5a01 	vldr	s11, [lr, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8015a50:	ed1a 5a01 	vldr	s10, [sl, #-4]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8015a54:	ed90 7a00 	vldr	s14, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015a58:	edd0 7a01 	vldr	s15, [r0, #4]
          for (k = i + 1; k < n1; k++) {
 8015a5c:	9b01      	ldr	r3, [sp, #4]
          BASE temp2_imag = 0.0;
 8015a5e:	ed1f 1a91 	vldr	s2, [pc, #-580]	; 801581c <cblas_csymm+0x3a4>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8015a62:	ee64 1a26 	vmul.f32	s3, s8, s13
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015a66:	ee26 2a44 	vnmul.f32	s4, s12, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8015a6a:	eee4 1a86 	vfma.f32	s3, s9, s12
          for (k = i + 1; k < n1; k++) {
 8015a6e:	454b      	cmp	r3, r9
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015a70:	eea4 2aa6 	vfma.f32	s4, s9, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8015a74:	ee25 6ae1 	vnmul.f32	s12, s11, s3
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015a78:	ee61 6a85 	vmul.f32	s13, s3, s10
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8015a7c:	eea2 6a05 	vfma.f32	s12, s4, s10
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015a80:	eee2 6a25 	vfma.f32	s13, s4, s11
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8015a84:	ee37 7a06 	vadd.f32	s14, s14, s12
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015a88:	ee77 7aa6 	vadd.f32	s15, s15, s13
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8015a8c:	ed80 7a00 	vstr	s14, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8015a90:	edc0 7a01 	vstr	s15, [r0, #4]
          BASE temp2_real = 0.0;
 8015a94:	eef0 0a41 	vmov.f32	s1, s2
          for (k = i + 1; k < n1; k++) {
 8015a98:	dd35      	ble.n	8015b06 <cblas_csymm+0x68e>
 8015a9a:	9b02      	ldr	r3, [sp, #8]
 8015a9c:	eb08 0107 	add.w	r1, r8, r7
 8015aa0:	4403      	add	r3, r0
 8015aa2:	4672      	mov	r2, lr
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8015aa4:	edd2 7a03 	vldr	s15, [r2, #12]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8015aa8:	ed92 7a02 	vldr	s14, [r2, #8]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8015aac:	ed51 2a01 	vldr	s5, [r1, #-4]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8015ab0:	ed91 3a00 	vldr	s6, [r1]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015ab4:	ed13 5a01 	vldr	s10, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015ab8:	ed93 6a00 	vldr	s12, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015abc:	ee67 5ae1 	vnmul.f32	s11, s15, s3
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015ac0:	ee62 3a27 	vmul.f32	s7, s4, s15
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015ac4:	eee2 5a07 	vfma.f32	s11, s4, s14
 8015ac8:	3208      	adds	r2, #8
          for (k = i + 1; k < n1; k++) {
 8015aca:	4294      	cmp	r4, r2
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8015acc:	ee63 6a67 	vnmul.f32	s13, s6, s15
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015ad0:	eee1 3a87 	vfma.f32	s7, s3, s14
 8015ad4:	4431      	add	r1, r6
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8015ad6:	ee67 7aa2 	vmul.f32	s15, s15, s5
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8015ada:	eee7 6a22 	vfma.f32	s13, s14, s5
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8015ade:	eee7 7a03 	vfma.f32	s15, s14, s6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015ae2:	ee75 5a25 	vadd.f32	s11, s10, s11
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015ae6:	ee36 7a23 	vadd.f32	s14, s12, s7
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8015aea:	ed43 5a01 	vstr	s11, [r3, #-4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8015aee:	ed83 7a00 	vstr	s14, [r3]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8015af2:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8015af6:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = i + 1; k < n1; k++) {
 8015afa:	442b      	add	r3, r5
 8015afc:	d1d2      	bne.n	8015aa4 <cblas_csymm+0x62c>
 8015afe:	ed90 7a00 	vldr	s14, [r0]
 8015b02:	edd0 7a01 	vldr	s15, [r0, #4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015b06:	ee21 6a44 	vnmul.f32	s12, s2, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015b0a:	ee64 6a20 	vmul.f32	s13, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015b0e:	eea4 6aa0 	vfma.f32	s12, s9, s1
        for (j = 0; j < n2; j++) {
 8015b12:	f10c 0c01 	add.w	ip, ip, #1
 8015b16:	45e3      	cmp	fp, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015b18:	eee4 6a81 	vfma.f32	s13, s9, s2
 8015b1c:	f107 0708 	add.w	r7, r7, #8
 8015b20:	f100 0008 	add.w	r0, r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015b24:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015b28:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015b2c:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015b30:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 8015b34:	d186      	bne.n	8015a44 <cblas_csymm+0x5cc>
      for (i = 0; i < n1; i++) {
 8015b36:	9809      	ldr	r0, [sp, #36]	; 0x24
 8015b38:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8015b3a:	9b06      	ldr	r3, [sp, #24]
 8015b3c:	4607      	mov	r7, r0
 8015b3e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8015b40:	4611      	mov	r1, r2
 8015b42:	4404      	add	r4, r0
 8015b44:	9808      	ldr	r0, [sp, #32]
 8015b46:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8015b48:	4419      	add	r1, r3
 8015b4a:	4418      	add	r0, r3
 8015b4c:	910a      	str	r1, [sp, #40]	; 0x28
 8015b4e:	9b03      	ldr	r3, [sp, #12]
 8015b50:	9905      	ldr	r1, [sp, #20]
 8015b52:	9008      	str	r0, [sp, #32]
 8015b54:	440b      	add	r3, r1
 8015b56:	4496      	add	lr, r2
 8015b58:	9303      	str	r3, [sp, #12]
 8015b5a:	4492      	add	sl, r2
 8015b5c:	9b01      	ldr	r3, [sp, #4]
 8015b5e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8015b60:	440f      	add	r7, r1
 8015b62:	4293      	cmp	r3, r2
 8015b64:	f109 0901 	add.w	r9, r9, #1
 8015b68:	9709      	str	r7, [sp, #36]	; 0x24
 8015b6a:	f73f af4c 	bgt.w	8015a06 <cblas_csymm+0x58e>
 8015b6e:	e52f      	b.n	80155d0 <cblas_csymm+0x158>
      for (i = 0; i < n1; i++) {
 8015b70:	9b01      	ldr	r3, [sp, #4]
 8015b72:	2b00      	cmp	r3, #0
 8015b74:	f77f ad2c 	ble.w	80155d0 <cblas_csymm+0x158>
 8015b78:	9b03      	ldr	r3, [sp, #12]
 8015b7a:	9a02      	ldr	r2, [sp, #8]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015b7c:	ed1f 0ad9 	vldr	s0, [pc, #-868]	; 801581c <cblas_csymm+0x3a4>
 8015b80:	3b08      	subs	r3, #8
 8015b82:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8015b86:	9309      	str	r3, [sp, #36]	; 0x24
 8015b88:	9b05      	ldr	r3, [sp, #20]
 8015b8a:	00db      	lsls	r3, r3, #3
 8015b8c:	9308      	str	r3, [sp, #32]
 8015b8e:	9b07      	ldr	r3, [sp, #28]
      for (i = 0; i < n1; i++) {
 8015b90:	f04f 0800 	mov.w	r8, #0
 8015b94:	f102 0c01 	add.w	ip, r2, #1
 8015b98:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8015b9c:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
 8015ba0:	f8cd 8008 	str.w	r8, [sp, #8]
 8015ba4:	46c1      	mov	r9, r8
 8015ba6:	eb03 0ecb 	add.w	lr, r3, fp, lsl #3
        for (j = 0; j < n2; j++) {
 8015baa:	f1bb 0f00 	cmp.w	fp, #0
 8015bae:	f340 80b4 	ble.w	8015d1a <cblas_csymm+0x8a2>
 8015bb2:	9b04      	ldr	r3, [sp, #16]
 8015bb4:	9a02      	ldr	r2, [sp, #8]
 8015bb6:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8015bb8:	9d03      	ldr	r5, [sp, #12]
 8015bba:	eb03 06c2 	add.w	r6, r3, r2, lsl #3
 8015bbe:	9b07      	ldr	r3, [sp, #28]
 8015bc0:	2700      	movs	r7, #0
 8015bc2:	eb03 00c8 	add.w	r0, r3, r8, lsl #3
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8015bc6:	edd6 7a00 	vldr	s15, [r6]
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8015bca:	edd6 6a01 	vldr	s13, [r6, #4]
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8015bce:	edd5 5a01 	vldr	s11, [r5, #4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8015bd2:	ed95 5a00 	vldr	s10, [r5]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8015bd6:	ed90 6a00 	vldr	s12, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8015bda:	ed90 7a01 	vldr	s14, [r0, #4]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8015bde:	ee64 1a27 	vmul.f32	s3, s8, s15
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015be2:	ee26 2ac4 	vnmul.f32	s4, s13, s8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8015be6:	eee4 1aa6 	vfma.f32	s3, s9, s13
          for (k = j + 1; k < n2; k++) {
 8015bea:	3701      	adds	r7, #1
 8015bec:	45bb      	cmp	fp, r7
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8015bee:	eea4 2aa7 	vfma.f32	s4, s9, s15
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8015bf2:	ee65 6ae1 	vnmul.f32	s13, s11, s3
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8015bf6:	ee61 7a85 	vmul.f32	s15, s3, s10
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8015bfa:	eee2 6a05 	vfma.f32	s13, s4, s10
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8015bfe:	eee2 7a25 	vfma.f32	s15, s4, s11
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8015c02:	ee76 6a26 	vadd.f32	s13, s12, s13
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8015c06:	ee77 7a27 	vadd.f32	s15, s14, s15
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8015c0a:	edc0 6a00 	vstr	s13, [r0]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8015c0e:	edc0 7a01 	vstr	s15, [r0, #4]
          for (k = j + 1; k < n2; k++) {
 8015c12:	d06e      	beq.n	8015cf2 <cblas_csymm+0x87a>
          BASE temp2_imag = 0.0;
 8015c14:	ed9f 1a5e 	vldr	s2, [pc, #376]	; 8015d90 <cblas_csymm+0x918>
          for (k = j + 1; k < n2; k++) {
 8015c18:	4603      	mov	r3, r0
          BASE temp2_real = 0.0;
 8015c1a:	eef0 0a41 	vmov.f32	s1, s2
          for (k = j + 1; k < n2; k++) {
 8015c1e:	4631      	mov	r1, r6
 8015c20:	462a      	mov	r2, r5
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8015c22:	edd2 6a02 	vldr	s13, [r2, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8015c26:	ed92 7a03 	vldr	s14, [r2, #12]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 8015c2a:	edd1 7a03 	vldr	s15, [r1, #12]
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8015c2e:	edd1 2a02 	vldr	s5, [r1, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015c32:	ed93 5a03 	vldr	s10, [r3, #12]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015c36:	edd3 5a02 	vldr	s11, [r3, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015c3a:	ee21 6aa6 	vmul.f32	s12, s3, s13
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015c3e:	ee67 3a61 	vnmul.f32	s7, s14, s3
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015c42:	eea2 6a07 	vfma.f32	s12, s4, s14
 8015c46:	3208      	adds	r2, #8
          for (k = j + 1; k < n2; k++) {
 8015c48:	4294      	cmp	r4, r2
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015c4a:	eee2 3a26 	vfma.f32	s7, s4, s13
 8015c4e:	f101 0108 	add.w	r1, r1, #8
 8015c52:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015c56:	eeb0 3a46 	vmov.f32	s6, s12
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015c5a:	ee27 6ac7 	vnmul.f32	s12, s15, s14
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8015c5e:	ee66 7aa7 	vmul.f32	s15, s13, s15
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015c62:	eea6 6aa2 	vfma.f32	s12, s13, s5
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8015c66:	eee7 7a22 	vfma.f32	s15, s14, s5
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015c6a:	eef0 6a46 	vmov.f32	s13, s12
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015c6e:	ee35 7aa3 	vadd.f32	s14, s11, s7
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015c72:	ee35 6a03 	vadd.f32	s12, s10, s6
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8015c76:	ed83 7a00 	vstr	s14, [r3]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8015c7a:	ed83 6a01 	vstr	s12, [r3, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8015c7e:	ee70 0aa6 	vadd.f32	s1, s1, s13
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8015c82:	ee31 1a27 	vadd.f32	s2, s2, s15
          for (k = j + 1; k < n2; k++) {
 8015c86:	d1cc      	bne.n	8015c22 <cblas_csymm+0x7aa>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015c88:	ee21 7a44 	vnmul.f32	s14, s2, s8
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015c8c:	ee64 7a20 	vmul.f32	s15, s8, s1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015c90:	eea4 7aa0 	vfma.f32	s14, s9, s1
 8015c94:	3608      	adds	r6, #8
 8015c96:	4465      	add	r5, ip
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015c98:	eee4 7a81 	vfma.f32	s15, s9, s2
 8015c9c:	4454      	add	r4, sl
 8015c9e:	3008      	adds	r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015ca0:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015ca4:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015ca8:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015cac:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015cb0:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015cb4:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015cb8:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015cbc:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = 0; j < n2; j++) {
 8015cc0:	e781      	b.n	8015bc6 <cblas_csymm+0x74e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8015cc2:	9b06      	ldr	r3, [sp, #24]
 8015cc4:	2b00      	cmp	r3, #0
 8015cc6:	dc4d      	bgt.n	8015d64 <cblas_csymm+0x8ec>
 8015cc8:	2301      	movs	r3, #1
 8015cca:	9a05      	ldr	r2, [sp, #20]
 8015ccc:	429a      	cmp	r2, r3
 8015cce:	bfb4      	ite	lt
 8015cd0:	200d      	movlt	r0, #13
 8015cd2:	200a      	movge	r0, #10
 8015cd4:	e409      	b.n	80154ea <cblas_csymm+0x72>
 8015cd6:	465b      	mov	r3, fp
 8015cd8:	e66b      	b.n	80159b2 <cblas_csymm+0x53a>
      for (i = 0; i < n1; i++) {
 8015cda:	9a08      	ldr	r2, [sp, #32]
 8015cdc:	9b04      	ldr	r3, [sp, #16]
 8015cde:	4490      	add	r8, r2
 8015ce0:	9a05      	ldr	r2, [sp, #20]
 8015ce2:	4492      	add	sl, r2
 8015ce4:	9a01      	ldr	r2, [sp, #4]
 8015ce6:	3301      	adds	r3, #1
 8015ce8:	429a      	cmp	r2, r3
 8015cea:	9304      	str	r3, [sp, #16]
 8015cec:	f47f adb5 	bne.w	801585a <cblas_csymm+0x3e2>
 8015cf0:	e46e      	b.n	80155d0 <cblas_csymm+0x158>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015cf2:	ee64 7a00 	vmul.f32	s15, s8, s0
 8015cf6:	ed5e 6a02 	vldr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015cfa:	ed1e 7a01 	vldr	s14, [lr, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015cfe:	eeb0 6a67 	vmov.f32	s12, s15
 8015d02:	ee94 6a80 	vfnms.f32	s12, s9, s0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015d06:	eee4 7a80 	vfma.f32	s15, s9, s0
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015d0a:	ee76 6a86 	vadd.f32	s13, s13, s12
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015d0e:	ee77 7a27 	vadd.f32	s15, s14, s15
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8015d12:	ed4e 6a02 	vstr	s13, [lr, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8015d16:	ed4e 7a01 	vstr	s15, [lr, #-4]
      for (i = 0; i < n1; i++) {
 8015d1a:	9b08      	ldr	r3, [sp, #32]
 8015d1c:	9a06      	ldr	r2, [sp, #24]
 8015d1e:	449e      	add	lr, r3
 8015d20:	9b02      	ldr	r3, [sp, #8]
 8015d22:	4413      	add	r3, r2
 8015d24:	9302      	str	r3, [sp, #8]
 8015d26:	9b05      	ldr	r3, [sp, #20]
 8015d28:	4498      	add	r8, r3
 8015d2a:	9b01      	ldr	r3, [sp, #4]
 8015d2c:	f109 0901 	add.w	r9, r9, #1
 8015d30:	454b      	cmp	r3, r9
 8015d32:	f47f af3a 	bne.w	8015baa <cblas_csymm+0x732>
 8015d36:	e44b      	b.n	80155d0 <cblas_csymm+0x158>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8015d38:	465b      	mov	r3, fp
 8015d3a:	2b01      	cmp	r3, #1
 8015d3c:	9a06      	ldr	r2, [sp, #24]
 8015d3e:	bfb8      	it	lt
 8015d40:	2301      	movlt	r3, #1
 8015d42:	4293      	cmp	r3, r2
 8015d44:	dcc1      	bgt.n	8015cca <cblas_csymm+0x852>
 8015d46:	9a05      	ldr	r2, [sp, #20]
 8015d48:	4293      	cmp	r3, r2
 8015d4a:	bfd4      	ite	le
 8015d4c:	2008      	movle	r0, #8
 8015d4e:	200d      	movgt	r0, #13
 8015d50:	f7ff bbcb 	b.w	80154ea <cblas_csymm+0x72>
 8015d54:	3865      	subs	r0, #101	; 0x65
 8015d56:	2801      	cmp	r0, #1
 8015d58:	9b01      	ldr	r3, [sp, #4]
 8015d5a:	bf94      	ite	ls
 8015d5c:	2000      	movls	r0, #0
 8015d5e:	2001      	movhi	r0, #1
 8015d60:	f7ff bba9 	b.w	80154b6 <cblas_csymm+0x3e>
 8015d64:	9b05      	ldr	r3, [sp, #20]
 8015d66:	2b00      	cmp	r3, #0
 8015d68:	bfcc      	ite	gt
 8015d6a:	2005      	movgt	r0, #5
 8015d6c:	200d      	movle	r0, #13
 8015d6e:	f7ff bbbc 	b.w	80154ea <cblas_csymm+0x72>
 8015d72:	465b      	mov	r3, fp
 8015d74:	2b01      	cmp	r3, #1
 8015d76:	9a06      	ldr	r2, [sp, #24]
 8015d78:	bfb8      	it	lt
 8015d7a:	2301      	movlt	r3, #1
 8015d7c:	429a      	cmp	r2, r3
 8015d7e:	dba4      	blt.n	8015cca <cblas_csymm+0x852>
 8015d80:	9a05      	ldr	r2, [sp, #20]
 8015d82:	429a      	cmp	r2, r3
 8015d84:	bfac      	ite	ge
 8015d86:	2005      	movge	r0, #5
 8015d88:	200d      	movlt	r0, #13
 8015d8a:	f7ff bbae 	b.w	80154ea <cblas_csymm+0x72>
 8015d8e:	bf00      	nop
 8015d90:	00000000 	.word	0x00000000

08015d94 <cblas_csyr2k>:
void
cblas_csyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const void *beta, void *C, const int ldc)
{
 8015d94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015d98:	b08b      	sub	sp, #44	; 0x2c
 8015d9a:	461d      	mov	r5, r3
 8015d9c:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8015d9e:	9300      	str	r3, [sp, #0]
 8015da0:	e9dd 6317 	ldrd	r6, r3, [sp, #92]	; 0x5c
 8015da4:	9301      	str	r3, [sp, #4]
 8015da6:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8015da8:	9304      	str	r3, [sp, #16]
 8015daa:	e9dd b31a 	ldrd	fp, r3, [sp, #104]	; 0x68

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015dae:	2865      	cmp	r0, #101	; 0x65
 8015db0:	9302      	str	r3, [sp, #8]
 8015db2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8015db4:	9303      	str	r3, [sp, #12]
 8015db6:	e9dd 7a14 	ldrd	r7, sl, [sp, #80]	; 0x50
 8015dba:	4681      	mov	r9, r0
 8015dbc:	460c      	mov	r4, r1
 8015dbe:	4690      	mov	r8, r2
 8015dc0:	f000 8102 	beq.w	8015fc8 <cblas_csyr2k+0x234>
 8015dc4:	2a6f      	cmp	r2, #111	; 0x6f
 8015dc6:	f000 8095 	beq.w	8015ef4 <cblas_csyr2k+0x160>
 8015dca:	463b      	mov	r3, r7
 8015dcc:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8015dd0:	2a01      	cmp	r2, #1
 8015dd2:	f240 80e9 	bls.w	8015fa8 <cblas_csyr2k+0x214>
 8015dd6:	2002      	movs	r0, #2
 8015dd8:	f1a8 026f 	sub.w	r2, r8, #111	; 0x6f
 8015ddc:	2a02      	cmp	r2, #2
 8015dde:	bf88      	it	hi
 8015de0:	2003      	movhi	r0, #3
 8015de2:	2d00      	cmp	r5, #0
 8015de4:	bfb8      	it	lt
 8015de6:	2004      	movlt	r0, #4
 8015de8:	2f00      	cmp	r7, #0
 8015dea:	bfb8      	it	lt
 8015dec:	2005      	movlt	r0, #5
 8015dee:	2b01      	cmp	r3, #1
 8015df0:	bfb8      	it	lt
 8015df2:	2301      	movlt	r3, #1
 8015df4:	42b3      	cmp	r3, r6
 8015df6:	9a04      	ldr	r2, [sp, #16]
 8015df8:	f340 80c8 	ble.w	8015f8c <cblas_csyr2k+0x1f8>
 8015dfc:	4293      	cmp	r3, r2
 8015dfe:	f300 80bb 	bgt.w	8015f78 <cblas_csyr2k+0x1e4>
 8015e02:	2d01      	cmp	r5, #1
 8015e04:	9b03      	ldr	r3, [sp, #12]
 8015e06:	4628      	mov	r0, r5
 8015e08:	bfb8      	it	lt
 8015e0a:	2001      	movlt	r0, #1
 8015e0c:	4298      	cmp	r0, r3
 8015e0e:	bfcc      	ite	gt
 8015e10:	200e      	movgt	r0, #14
 8015e12:	2008      	movle	r0, #8
 8015e14:	4abe      	ldr	r2, [pc, #760]	; (8016110 <cblas_csyr2k+0x37c>)
 8015e16:	49bf      	ldr	r1, [pc, #764]	; (8016114 <cblas_csyr2k+0x380>)
 8015e18:	f011 fe16 	bl	8027a48 <cblas_xerbla>

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 8015e1c:	edda 5a00 	vldr	s11, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8015e20:	ed9a 5a01 	vldr	s10, [sl, #4]
    const BASE beta_real = CONST_REAL0(beta);
 8015e24:	eddb 6a00 	vldr	s13, [fp]
    const BASE beta_imag = CONST_IMAG0(beta);
 8015e28:	ed9b 6a01 	vldr	s12, [fp, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8015e2c:	eef5 5a40 	vcmp.f32	s11, #0.0
 8015e30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e34:	d10c      	bne.n	8015e50 <cblas_csyr2k+0xbc>
 8015e36:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8015e3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e3e:	d107      	bne.n	8015e50 <cblas_csyr2k+0xbc>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8015e40:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015e44:	eef4 6a67 	vcmp.f32	s13, s15
 8015e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e4c:	f000 80b3 	beq.w	8015fb6 <cblas_csyr2k+0x222>
      return;

    if (Order == CblasRowMajor) {
 8015e50:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8015e54:	f000 80bd 	beq.w	8015fd2 <cblas_csyr2k+0x23e>
      uplo = Uplo;
      trans = Trans;
    } else {
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8015e58:	2c79      	cmp	r4, #121	; 0x79
 8015e5a:	bf0c      	ite	eq
 8015e5c:	247a      	moveq	r4, #122	; 0x7a
 8015e5e:	2479      	movne	r4, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8015e60:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8015e64:	bf0c      	ite	eq
 8015e66:	f04f 0970 	moveq.w	r9, #112	; 0x70
 8015e6a:	f04f 096f 	movne.w	r9, #111	; 0x6f
    }

    /* form  C := beta*C */

    if (beta_real == 0.0 && beta_imag == 0.0) {
 8015e6e:	eef5 6a40 	vcmp.f32	s13, #0.0
 8015e72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e76:	d144      	bne.n	8015f02 <cblas_csyr2k+0x16e>
 8015e78:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8015e7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e80:	d14c      	bne.n	8015f1c <cblas_csyr2k+0x188>
      if (uplo == CblasUpper) {
 8015e82:	2c79      	cmp	r4, #121	; 0x79
 8015e84:	f000 80a7 	beq.w	8015fd6 <cblas_csyr2k+0x242>
            REAL(C, ldc * i + j) = 0.0;
            IMAG(C, ldc * i + j) = 0.0;
          }
        }
      } else {
        for (i = 0; i < N; i++) {
 8015e88:	2d00      	cmp	r5, #0
 8015e8a:	dd1b      	ble.n	8015ec4 <cblas_csyr2k+0x130>
 8015e8c:	9b03      	ldr	r3, [sp, #12]
 8015e8e:	9a02      	ldr	r2, [sp, #8]
 8015e90:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8015e94:	f103 0c01 	add.w	ip, r3, #1
 8015e98:	2100      	movs	r1, #0
          for (j = 0; j <= i; j++) {
            REAL(C, ldc * i + j) = 0.0;
 8015e9a:	f04f 0e00 	mov.w	lr, #0
 8015e9e:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
        for (i = 0; i < N; i++) {
 8015ea2:	4608      	mov	r0, r1
 8015ea4:	3208      	adds	r2, #8
 8015ea6:	469a      	mov	sl, r3
 8015ea8:	eb08 03c1 	add.w	r3, r8, r1, lsl #3
            REAL(C, ldc * i + j) = 0.0;
 8015eac:	f8c3 e000 	str.w	lr, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8015eb0:	f8c3 e004 	str.w	lr, [r3, #4]
          for (j = 0; j <= i; j++) {
 8015eb4:	3308      	adds	r3, #8
 8015eb6:	429a      	cmp	r2, r3
 8015eb8:	d1f8      	bne.n	8015eac <cblas_csyr2k+0x118>
        for (i = 0; i < N; i++) {
 8015eba:	3001      	adds	r0, #1
 8015ebc:	4285      	cmp	r5, r0
 8015ebe:	4451      	add	r1, sl
 8015ec0:	4462      	add	r2, ip
 8015ec2:	d1f1      	bne.n	8015ea8 <cblas_csyr2k+0x114>
        }
      }
    }


    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8015ec4:	eef5 5a40 	vcmp.f32	s11, #0.0
 8015ec8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015ecc:	d107      	bne.n	8015ede <cblas_csyr2k+0x14a>
 8015ece:	eeb5 5a40 	vcmp.f32	s10, #0.0
 8015ed2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015ed6:	d074      	beq.n	8015fc2 <cblas_csyr2k+0x22e>
      return;

    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8015ed8:	2c79      	cmp	r4, #121	; 0x79
 8015eda:	f000 809c 	beq.w	8016016 <cblas_csyr2k+0x282>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
          }
        }
      }

    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8015ede:	2c7a      	cmp	r4, #122	; 0x7a
 8015ee0:	f000 811e 	beq.w	8016120 <cblas_csyr2k+0x38c>
        }
      }


    } else {
      BLAS_ERROR("unrecognized operation");
 8015ee4:	4a8c      	ldr	r2, [pc, #560]	; (8016118 <cblas_csyr2k+0x384>)
 8015ee6:	498b      	ldr	r1, [pc, #556]	; (8016114 <cblas_csyr2k+0x380>)
 8015ee8:	2000      	movs	r0, #0
#define BASE float
#include "source_syr2k_c.h"
#undef BASE
}
 8015eea:	b00b      	add	sp, #44	; 0x2c
 8015eec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015ef0:	f011 bdaa 	b.w	8027a48 <cblas_xerbla>
 8015ef4:	462b      	mov	r3, r5
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015ef6:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8015efa:	2a01      	cmp	r2, #1
 8015efc:	d954      	bls.n	8015fa8 <cblas_csyr2k+0x214>
 8015efe:	2002      	movs	r0, #2
 8015f00:	e76f      	b.n	8015de2 <cblas_csyr2k+0x4e>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8015f02:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8015f06:	eef4 6a67 	vcmp.f32	s13, s15
 8015f0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f0e:	d105      	bne.n	8015f1c <cblas_csyr2k+0x188>
 8015f10:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8015f14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f18:	f000 817f 	beq.w	801621a <cblas_csyr2k+0x486>
      if (uplo == CblasUpper) {
 8015f1c:	2c79      	cmp	r4, #121	; 0x79
 8015f1e:	f000 82a8 	beq.w	8016472 <cblas_csyr2k+0x6de>
        for (i = 0; i < N; i++) {
 8015f22:	2d00      	cmp	r5, #0
 8015f24:	ddce      	ble.n	8015ec4 <cblas_csyr2k+0x130>
 8015f26:	9b03      	ldr	r3, [sp, #12]
 8015f28:	ea4f 08c3 	mov.w	r8, r3, lsl #3
 8015f2c:	9b02      	ldr	r3, [sp, #8]
 8015f2e:	f108 0108 	add.w	r1, r8, #8
 8015f32:	469c      	mov	ip, r3
 8015f34:	f103 0008 	add.w	r0, r3, #8
 8015f38:	f04f 0e00 	mov.w	lr, #0
 8015f3c:	f10c 0204 	add.w	r2, ip, #4
 8015f40:	4663      	mov	r3, ip
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8015f42:	edd3 4a01 	vldr	s9, [r3, #4]
            const BASE Cij_real = REAL(C, ldc * i + j);
 8015f46:	ed12 4a01 	vldr	s8, [r2, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8015f4a:	ee24 7ac6 	vnmul.f32	s14, s9, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8015f4e:	ee66 7a04 	vmul.f32	s15, s12, s8
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8015f52:	eea6 7a84 	vfma.f32	s14, s13, s8
 8015f56:	3308      	adds	r3, #8
 8015f58:	3208      	adds	r2, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8015f5a:	eee6 7aa4 	vfma.f32	s15, s13, s9
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8015f5e:	ed02 7a03 	vstr	s14, [r2, #-12]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8015f62:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j <= i; j++) {
 8015f66:	4298      	cmp	r0, r3
 8015f68:	d1eb      	bne.n	8015f42 <cblas_csyr2k+0x1ae>
        for (i = 0; i < N; i++) {
 8015f6a:	f10e 0e01 	add.w	lr, lr, #1
 8015f6e:	4575      	cmp	r5, lr
 8015f70:	44c4      	add	ip, r8
 8015f72:	4408      	add	r0, r1
 8015f74:	d1e2      	bne.n	8015f3c <cblas_csyr2k+0x1a8>
 8015f76:	e7a5      	b.n	8015ec4 <cblas_csyr2k+0x130>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015f78:	2d01      	cmp	r5, #1
 8015f7a:	9b03      	ldr	r3, [sp, #12]
 8015f7c:	4628      	mov	r0, r5
 8015f7e:	bfb8      	it	lt
 8015f80:	2001      	movlt	r0, #1
 8015f82:	4283      	cmp	r3, r0
 8015f84:	bfb4      	ite	lt
 8015f86:	200e      	movlt	r0, #14
 8015f88:	200b      	movge	r0, #11
 8015f8a:	e743      	b.n	8015e14 <cblas_csyr2k+0x80>
 8015f8c:	4293      	cmp	r3, r2
 8015f8e:	dcf3      	bgt.n	8015f78 <cblas_csyr2k+0x1e4>
 8015f90:	2d01      	cmp	r5, #1
 8015f92:	9a03      	ldr	r2, [sp, #12]
 8015f94:	462b      	mov	r3, r5
 8015f96:	bfb8      	it	lt
 8015f98:	2301      	movlt	r3, #1
 8015f9a:	4293      	cmp	r3, r2
 8015f9c:	f300 81d8 	bgt.w	8016350 <cblas_csyr2k+0x5bc>
 8015fa0:	2800      	cmp	r0, #0
 8015fa2:	f43f af3b 	beq.w	8015e1c <cblas_csyr2k+0x88>
 8015fa6:	e735      	b.n	8015e14 <cblas_csyr2k+0x80>
 8015fa8:	f1a9 0065 	sub.w	r0, r9, #101	; 0x65
 8015fac:	2801      	cmp	r0, #1
 8015fae:	bf94      	ite	ls
 8015fb0:	2000      	movls	r0, #0
 8015fb2:	2001      	movhi	r0, #1
 8015fb4:	e710      	b.n	8015dd8 <cblas_csyr2k+0x44>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8015fb6:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8015fba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015fbe:	f47f af47 	bne.w	8015e50 <cblas_csyr2k+0xbc>
 8015fc2:	b00b      	add	sp, #44	; 0x2c
 8015fc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8015fc8:	2a6f      	cmp	r2, #111	; 0x6f
 8015fca:	f000 8278 	beq.w	80164be <cblas_csyr2k+0x72a>
 8015fce:	462b      	mov	r3, r5
 8015fd0:	e6fc      	b.n	8015dcc <cblas_csyr2k+0x38>
      trans = Trans;
 8015fd2:	46c1      	mov	r9, r8
 8015fd4:	e74b      	b.n	8015e6e <cblas_csyr2k+0xda>
        for (i = 0; i < N; i++) {
 8015fd6:	2d00      	cmp	r5, #0
 8015fd8:	dd17      	ble.n	801600a <cblas_csyr2k+0x276>
 8015fda:	9b03      	ldr	r3, [sp, #12]
 8015fdc:	9802      	ldr	r0, [sp, #8]
 8015fde:	f103 0c01 	add.w	ip, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 8015fe2:	f04f 0e00 	mov.w	lr, #0
 8015fe6:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
        for (i = 0; i < N; i++) {
 8015fea:	2100      	movs	r1, #0
 8015fec:	4603      	mov	r3, r0
 8015fee:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 8015ff0:	3201      	adds	r2, #1
 8015ff2:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 8015ff4:	f8c3 e000 	str.w	lr, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 8015ff8:	f8c3 e004 	str.w	lr, [r3, #4]
          for (j = i; j < N; j++) {
 8015ffc:	f103 0308 	add.w	r3, r3, #8
 8016000:	dcf6      	bgt.n	8015ff0 <cblas_csyr2k+0x25c>
        for (i = 0; i < N; i++) {
 8016002:	3101      	adds	r1, #1
 8016004:	428d      	cmp	r5, r1
 8016006:	4460      	add	r0, ip
 8016008:	d1f0      	bne.n	8015fec <cblas_csyr2k+0x258>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801600a:	eef5 5a40 	vcmp.f32	s11, #0.0
 801600e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016012:	f43f af5c 	beq.w	8015ece <cblas_csyr2k+0x13a>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8016016:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 801601a:	f000 8105 	beq.w	8016228 <cblas_csyr2k+0x494>
    } else if (uplo == CblasUpper && trans == CblasTrans) {
 801601e:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 8016022:	f47f af5f 	bne.w	8015ee4 <cblas_csyr2k+0x150>
      for (k = 0; k < K; k++) {
 8016026:	2f00      	cmp	r7, #0
 8016028:	ddcb      	ble.n	8015fc2 <cblas_csyr2k+0x22e>
 801602a:	f04f 0a00 	mov.w	sl, #0
 801602e:	f106 0901 	add.w	r9, r6, #1
 8016032:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8016036:	46d0      	mov	r8, sl
 8016038:	46d3      	mov	fp, sl
 801603a:	9703      	str	r7, [sp, #12]
        for (i = 0; i < N; i++) {
 801603c:	2d00      	cmp	r5, #0
 801603e:	dd5e      	ble.n	80160fe <cblas_csyr2k+0x36a>
 8016040:	9b00      	ldr	r3, [sp, #0]
 8016042:	f8dd e008 	ldr.w	lr, [sp, #8]
 8016046:	eb03 07c8 	add.w	r7, r3, r8, lsl #3
 801604a:	9b01      	ldr	r3, [sp, #4]
 801604c:	f04f 0c00 	mov.w	ip, #0
 8016050:	eb03 04ca 	add.w	r4, r3, sl, lsl #3
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016054:	edd7 3a00 	vldr	s7, [r7]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8016058:	ed97 3a01 	vldr	s6, [r7, #4]
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801605c:	edd4 4a00 	vldr	s9, [r4]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 8016060:	ed94 4a01 	vldr	s8, [r4, #4]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016064:	ee25 1a23 	vmul.f32	s2, s10, s7
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8016068:	ee63 1a45 	vnmul.f32	s3, s6, s10
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 801606c:	ee25 2a24 	vmul.f32	s4, s10, s9
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016070:	ee64 2a45 	vnmul.f32	s5, s8, s10
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016074:	eea5 1a83 	vfma.f32	s2, s11, s6
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016078:	4621      	mov	r1, r4
 801607a:	463a      	mov	r2, r7
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 801607c:	eee5 1aa3 	vfma.f32	s3, s11, s7
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016080:	4673      	mov	r3, lr
 8016082:	4660      	mov	r0, ip
 8016084:	eea5 2a84 	vfma.f32	s4, s11, s8
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016088:	eee5 2aa4 	vfma.f32	s5, s11, s9
          for (j = i; j < N; j++) {
 801608c:	e009      	b.n	80160a2 <cblas_csyr2k+0x30e>
 801608e:	edd2 3a02 	vldr	s7, [r2, #8]
 8016092:	ed92 3a03 	vldr	s6, [r2, #12]
 8016096:	edd1 4a02 	vldr	s9, [r1, #8]
 801609a:	ed91 4a03 	vldr	s8, [r1, #12]
 801609e:	3208      	adds	r2, #8
 80160a0:	3108      	adds	r1, #8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80160a2:	ee24 6a41 	vnmul.f32	s12, s8, s2
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80160a6:	ee21 7a24 	vmul.f32	s14, s2, s9
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80160aa:	ee63 6a42 	vnmul.f32	s13, s6, s4
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80160ae:	ee62 7a23 	vmul.f32	s15, s4, s7
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80160b2:	eea1 6aa4 	vfma.f32	s12, s3, s9
          for (j = i; j < N; j++) {
 80160b6:	3001      	adds	r0, #1
 80160b8:	4285      	cmp	r5, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80160ba:	eea1 7a84 	vfma.f32	s14, s3, s8
 80160be:	f103 0308 	add.w	r3, r3, #8
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80160c2:	eee2 6aa3 	vfma.f32	s13, s5, s7
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80160c6:	eee2 7a83 	vfma.f32	s15, s5, s6
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80160ca:	ee76 6a26 	vadd.f32	s13, s12, s13
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80160ce:	ee77 7a27 	vadd.f32	s15, s14, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80160d2:	ed13 6a02 	vldr	s12, [r3, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80160d6:	ed13 7a01 	vldr	s14, [r3, #-4]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80160da:	ee76 6a26 	vadd.f32	s13, s12, s13
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80160de:	ee77 7a27 	vadd.f32	s15, s14, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80160e2:	ed43 6a02 	vstr	s13, [r3, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80160e6:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = i; j < N; j++) {
 80160ea:	dcd0      	bgt.n	801608e <cblas_csyr2k+0x2fa>
        for (i = 0; i < N; i++) {
 80160ec:	f10c 0c01 	add.w	ip, ip, #1
 80160f0:	4565      	cmp	r5, ip
 80160f2:	f107 0708 	add.w	r7, r7, #8
 80160f6:	f104 0408 	add.w	r4, r4, #8
 80160fa:	44ce      	add	lr, r9
 80160fc:	d1aa      	bne.n	8016054 <cblas_csyr2k+0x2c0>
      for (k = 0; k < K; k++) {
 80160fe:	9b04      	ldr	r3, [sp, #16]
 8016100:	449a      	add	sl, r3
 8016102:	9b03      	ldr	r3, [sp, #12]
 8016104:	f10b 0b01 	add.w	fp, fp, #1
 8016108:	455b      	cmp	r3, fp
 801610a:	44b0      	add	r8, r6
 801610c:	d196      	bne.n	801603c <cblas_csyr2k+0x2a8>
 801610e:	e758      	b.n	8015fc2 <cblas_csyr2k+0x22e>
 8016110:	08030378 	.word	0x08030378
 8016114:	08030760 	.word	0x08030760
 8016118:	080305a8 	.word	0x080305a8
 801611c:	00000000 	.word	0x00000000
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8016120:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 8016124:	f000 8116 	beq.w	8016354 <cblas_csyr2k+0x5c0>
    } else if (uplo == CblasLower && trans == CblasTrans) {
 8016128:	f1b9 0f70 	cmp.w	r9, #112	; 0x70
 801612c:	f47f aeda 	bne.w	8015ee4 <cblas_csyr2k+0x150>
      for (k = 0; k < K; k++) {
 8016130:	2f00      	cmp	r7, #0
 8016132:	f77f af46 	ble.w	8015fc2 <cblas_csyr2k+0x22e>
 8016136:	f8dd 8000 	ldr.w	r8, [sp]
 801613a:	9b04      	ldr	r3, [sp, #16]
 801613c:	f8dd 9004 	ldr.w	r9, [sp, #4]
 8016140:	f108 0a08 	add.w	sl, r8, #8
 8016144:	00db      	lsls	r3, r3, #3
 8016146:	00f6      	lsls	r6, r6, #3
 8016148:	9300      	str	r3, [sp, #0]
 801614a:	eb0a 0ac5 	add.w	sl, sl, r5, lsl #3
 801614e:	f04f 0b00 	mov.w	fp, #0
        for (i = 0; i < N; i++) {
 8016152:	2d00      	cmp	r5, #0
 8016154:	dd58      	ble.n	8016208 <cblas_csyr2k+0x474>
 8016156:	9b02      	ldr	r3, [sp, #8]
 8016158:	f108 0408 	add.w	r4, r8, #8
 801615c:	f103 0e04 	add.w	lr, r3, #4
 8016160:	46cc      	mov	ip, r9
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016162:	ed54 6a02 	vldr	s13, [r4, #-8]
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8016166:	ed14 6a01 	vldr	s12, [r4, #-4]
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801616a:	eddc 7a00 	vldr	s15, [ip]
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801616e:	ed9c 7a01 	vldr	s14, [ip, #4]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016172:	ee65 1a26 	vmul.f32	s3, s10, s13
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8016176:	ee26 2a45 	vnmul.f32	s4, s12, s10
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 801617a:	ee65 2a27 	vmul.f32	s5, s10, s15
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801617e:	ee27 3a45 	vnmul.f32	s6, s14, s10
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8016182:	eee5 1a86 	vfma.f32	s3, s11, s12
 8016186:	f1ae 0004 	sub.w	r0, lr, #4
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 801618a:	4671      	mov	r1, lr
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 801618c:	eea5 2aa6 	vfma.f32	s4, s11, s13
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8016190:	464a      	mov	r2, r9
 8016192:	4643      	mov	r3, r8
 8016194:	eee5 2a87 	vfma.f32	s5, s11, s14
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8016198:	eea5 3aa7 	vfma.f32	s6, s11, s15
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 801619c:	3308      	adds	r3, #8
 801619e:	3208      	adds	r2, #8
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80161a0:	ed53 3a01 	vldr	s7, [r3, #-4]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80161a4:	ed12 4a01 	vldr	s8, [r2, #-4]
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 80161a8:	ed13 7a02 	vldr	s14, [r3, #-8]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 80161ac:	ed52 7a02 	vldr	s15, [r2, #-8]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80161b0:	ed11 6a01 	vldr	s12, [r1, #-4]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80161b4:	ee63 4ae2 	vnmul.f32	s9, s7, s5
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80161b8:	ee64 6a61 	vnmul.f32	s13, s8, s3
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80161bc:	eee3 4a07 	vfma.f32	s9, s6, s14
          for (j = 0; j <= i; j++) {
 80161c0:	429c      	cmp	r4, r3
 80161c2:	f101 0108 	add.w	r1, r1, #8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80161c6:	eee2 6a27 	vfma.f32	s13, s4, s15
 80161ca:	f100 0008 	add.w	r0, r0, #8
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80161ce:	ee22 7a87 	vmul.f32	s14, s5, s14
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80161d2:	ee61 7aa7 	vmul.f32	s15, s3, s15
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 80161d6:	ee76 6aa4 	vadd.f32	s13, s13, s9
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80161da:	eea3 7a23 	vfma.f32	s14, s6, s7
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80161de:	eee2 7a04 	vfma.f32	s15, s4, s8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80161e2:	ee76 6a26 	vadd.f32	s13, s12, s13
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80161e6:	ee77 7a87 	vadd.f32	s15, s15, s14
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80161ea:	ed41 6a03 	vstr	s13, [r1, #-12]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80161ee:	ed10 7a01 	vldr	s14, [r0, #-4]
 80161f2:	ee77 7a27 	vadd.f32	s15, s14, s15
 80161f6:	ed40 7a01 	vstr	s15, [r0, #-4]
          for (j = 0; j <= i; j++) {
 80161fa:	d1cf      	bne.n	801619c <cblas_csyr2k+0x408>
        for (i = 0; i < N; i++) {
 80161fc:	3408      	adds	r4, #8
 80161fe:	45a2      	cmp	sl, r4
 8016200:	f10c 0c08 	add.w	ip, ip, #8
 8016204:	44b6      	add	lr, r6
 8016206:	d1ac      	bne.n	8016162 <cblas_csyr2k+0x3ce>
      for (k = 0; k < K; k++) {
 8016208:	9b00      	ldr	r3, [sp, #0]
 801620a:	f10b 0b01 	add.w	fp, fp, #1
 801620e:	455f      	cmp	r7, fp
 8016210:	44b2      	add	sl, r6
 8016212:	44b0      	add	r8, r6
 8016214:	4499      	add	r9, r3
 8016216:	d19c      	bne.n	8016152 <cblas_csyr2k+0x3be>
 8016218:	e6d3      	b.n	8015fc2 <cblas_csyr2k+0x22e>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801621a:	eef5 5a40 	vcmp.f32	s11, #0.0
 801621e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016222:	f47f ae59 	bne.w	8015ed8 <cblas_csyr2k+0x144>
 8016226:	e652      	b.n	8015ece <cblas_csyr2k+0x13a>
      for (i = 0; i < N; i++) {
 8016228:	2d00      	cmp	r5, #0
 801622a:	f77f aeca 	ble.w	8015fc2 <cblas_csyr2k+0x22e>
 801622e:	9b03      	ldr	r3, [sp, #12]
 8016230:	9900      	ldr	r1, [sp, #0]
 8016232:	f8dd b004 	ldr.w	fp, [sp, #4]
 8016236:	3301      	adds	r3, #1
 8016238:	00db      	lsls	r3, r3, #3
 801623a:	9309      	str	r3, [sp, #36]	; 0x24
 801623c:	9b02      	ldr	r3, [sp, #8]
 801623e:	9702      	str	r7, [sp, #8]
 8016240:	2200      	movs	r2, #0
 8016242:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8016246:	9205      	str	r2, [sp, #20]
 8016248:	9203      	str	r2, [sp, #12]
 801624a:	9a04      	ldr	r2, [sp, #16]
 801624c:	00f3      	lsls	r3, r6, #3
 801624e:	9308      	str	r3, [sp, #32]
 8016250:	00d3      	lsls	r3, r2, #3
 8016252:	9304      	str	r3, [sp, #16]
 8016254:	468a      	mov	sl, r1
 8016256:	eb01 03c7 	add.w	r3, r1, r7, lsl #3
 801625a:	4691      	mov	r9, r2
          BASE temp_real = 0.0;
 801625c:	e9dd 8e05 	ldrd	r8, lr, [sp, #20]
 8016260:	9f07      	ldr	r7, [sp, #28]
 8016262:	f8dd c00c 	ldr.w	ip, [sp, #12]
          for (k = 0; k < K; k++) {
 8016266:	9a02      	ldr	r2, [sp, #8]
          BASE temp_imag = 0.0;
 8016268:	ed5f 1a54 	vldr	s3, [pc, #-336]	; 801611c <cblas_csyr2k+0x388>
          for (k = 0; k < K; k++) {
 801626c:	2a00      	cmp	r2, #0
          BASE temp_real = 0.0;
 801626e:	eeb0 1a61 	vmov.f32	s2, s3
          for (k = 0; k < K; k++) {
 8016272:	dd38      	ble.n	80162e6 <cblas_csyr2k+0x552>
 8016274:	9a00      	ldr	r2, [sp, #0]
 8016276:	eb02 04ce 	add.w	r4, r2, lr, lsl #3
 801627a:	9a01      	ldr	r2, [sp, #4]
 801627c:	4659      	mov	r1, fp
 801627e:	eb02 00c8 	add.w	r0, r2, r8, lsl #3
 8016282:	4652      	mov	r2, sl
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8016284:	edd2 7a01 	vldr	s15, [r2, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8016288:	ed90 2a01 	vldr	s4, [r0, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801628c:	ed90 3a00 	vldr	s6, [r0]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 8016290:	ed91 7a01 	vldr	s14, [r1, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8016294:	edd4 4a01 	vldr	s9, [r4, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8016298:	edd4 3a00 	vldr	s7, [r4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801629c:	edd2 2a00 	vldr	s5, [r2]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 80162a0:	ed91 4a00 	vldr	s8, [r1]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80162a4:	ee22 6a67 	vnmul.f32	s12, s4, s15
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80162a8:	ee64 6ac7 	vnmul.f32	s13, s9, s14
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80162ac:	ee67 7a83 	vmul.f32	s15, s15, s6
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80162b0:	ee27 7a23 	vmul.f32	s14, s14, s7
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80162b4:	eee2 7a82 	vfma.f32	s15, s5, s4
 80162b8:	3208      	adds	r2, #8
          for (k = 0; k < K; k++) {
 80162ba:	429a      	cmp	r2, r3
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80162bc:	eea2 6a83 	vfma.f32	s12, s5, s6
 80162c0:	f100 0008 	add.w	r0, r0, #8
 80162c4:	f104 0408 	add.w	r4, r4, #8
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80162c8:	eee4 6a23 	vfma.f32	s13, s8, s7
 80162cc:	f101 0108 	add.w	r1, r1, #8
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80162d0:	eea4 7a24 	vfma.f32	s14, s8, s9
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80162d4:	ee76 6a26 	vadd.f32	s13, s12, s13
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80162d8:	ee77 7a87 	vadd.f32	s15, s15, s14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80162dc:	ee31 1a26 	vadd.f32	s2, s2, s13
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80162e0:	ee71 1aa7 	vadd.f32	s3, s3, s15
          for (k = 0; k < K; k++) {
 80162e4:	d1ce      	bne.n	8016284 <cblas_csyr2k+0x4f0>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80162e6:	ee21 7ac5 	vnmul.f32	s14, s3, s10
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80162ea:	ee65 7a01 	vmul.f32	s15, s10, s2
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80162ee:	eea5 7a81 	vfma.f32	s14, s11, s2
        for (j = i; j < N; j++) {
 80162f2:	f10c 0c01 	add.w	ip, ip, #1
 80162f6:	4565      	cmp	r5, ip
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80162f8:	eee5 7aa1 	vfma.f32	s15, s11, s3
 80162fc:	44b6      	add	lr, r6
 80162fe:	44c8      	add	r8, r9
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016300:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016304:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016308:	ed97 7a00 	vldr	s14, [r7]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801630c:	edd7 7a01 	vldr	s15, [r7, #4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016310:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016314:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016318:	ed87 7a00 	vstr	s14, [r7]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801631c:	edc7 7a01 	vstr	s15, [r7, #4]
        for (j = i; j < N; j++) {
 8016320:	f107 0708 	add.w	r7, r7, #8
 8016324:	dc9f      	bgt.n	8016266 <cblas_csyr2k+0x4d2>
      for (i = 0; i < N; i++) {
 8016326:	9907      	ldr	r1, [sp, #28]
 8016328:	9809      	ldr	r0, [sp, #36]	; 0x24
 801632a:	9a03      	ldr	r2, [sp, #12]
 801632c:	4401      	add	r1, r0
 801632e:	9107      	str	r1, [sp, #28]
 8016330:	9906      	ldr	r1, [sp, #24]
 8016332:	9804      	ldr	r0, [sp, #16]
 8016334:	4431      	add	r1, r6
 8016336:	9106      	str	r1, [sp, #24]
 8016338:	9905      	ldr	r1, [sp, #20]
 801633a:	4449      	add	r1, r9
 801633c:	3201      	adds	r2, #1
 801633e:	9105      	str	r1, [sp, #20]
 8016340:	9908      	ldr	r1, [sp, #32]
 8016342:	9203      	str	r2, [sp, #12]
 8016344:	4295      	cmp	r5, r2
 8016346:	448a      	add	sl, r1
 8016348:	4483      	add	fp, r0
 801634a:	440b      	add	r3, r1
 801634c:	d186      	bne.n	801625c <cblas_csyr2k+0x4c8>
 801634e:	e638      	b.n	8015fc2 <cblas_csyr2k+0x22e>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8016350:	200e      	movs	r0, #14
 8016352:	e55f      	b.n	8015e14 <cblas_csyr2k+0x80>
      for (i = 0; i < N; i++) {
 8016354:	2d00      	cmp	r5, #0
 8016356:	f77f ae34 	ble.w	8015fc2 <cblas_csyr2k+0x22e>
 801635a:	9b03      	ldr	r3, [sp, #12]
 801635c:	f8dd b004 	ldr.w	fp, [sp, #4]
 8016360:	9509      	str	r5, [sp, #36]	; 0x24
 8016362:	3301      	adds	r3, #1
 8016364:	00db      	lsls	r3, r3, #3
 8016366:	9308      	str	r3, [sp, #32]
 8016368:	9b02      	ldr	r3, [sp, #8]
 801636a:	f103 0908 	add.w	r9, r3, #8
 801636e:	00f3      	lsls	r3, r6, #3
 8016370:	9307      	str	r3, [sp, #28]
 8016372:	9b04      	ldr	r3, [sp, #16]
 8016374:	2200      	movs	r2, #0
 8016376:	9205      	str	r2, [sp, #20]
 8016378:	9206      	str	r2, [sp, #24]
 801637a:	00da      	lsls	r2, r3, #3
 801637c:	9204      	str	r2, [sp, #16]
 801637e:	9a00      	ldr	r2, [sp, #0]
 8016380:	4698      	mov	r8, r3
 8016382:	eb02 04c7 	add.w	r4, r2, r7, lsl #3
 8016386:	4692      	mov	sl, r2
 8016388:	9b02      	ldr	r3, [sp, #8]
 801638a:	9a05      	ldr	r2, [sp, #20]
          BASE temp_real = 0.0;
 801638c:	f04f 0c00 	mov.w	ip, #0
 8016390:	46e6      	mov	lr, ip
 8016392:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
          BASE temp_imag = 0.0;
 8016396:	ed5f 1a9f 	vldr	s3, [pc, #-636]	; 801611c <cblas_csyr2k+0x388>
          for (k = 0; k < K; k++) {
 801639a:	2f00      	cmp	r7, #0
          BASE temp_real = 0.0;
 801639c:	eeb0 1a61 	vmov.f32	s2, s3
          for (k = 0; k < K; k++) {
 80163a0:	dd38      	ble.n	8016414 <cblas_csyr2k+0x680>
 80163a2:	9b00      	ldr	r3, [sp, #0]
 80163a4:	eb03 00ce 	add.w	r0, r3, lr, lsl #3
 80163a8:	9b01      	ldr	r3, [sp, #4]
 80163aa:	465a      	mov	r2, fp
 80163ac:	eb03 01cc 	add.w	r1, r3, ip, lsl #3
 80163b0:	4653      	mov	r3, sl
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80163b2:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 80163b6:	ed91 2a01 	vldr	s4, [r1, #4]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 80163ba:	ed91 3a00 	vldr	s6, [r1]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 80163be:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80163c2:	edd0 4a01 	vldr	s9, [r0, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80163c6:	edd0 3a00 	vldr	s7, [r0]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80163ca:	edd3 2a00 	vldr	s5, [r3]
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 80163ce:	ed92 4a00 	vldr	s8, [r2]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80163d2:	ee22 6a67 	vnmul.f32	s12, s4, s15
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80163d6:	ee64 6ac7 	vnmul.f32	s13, s9, s14
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80163da:	ee67 7a83 	vmul.f32	s15, s15, s6
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80163de:	ee27 7a23 	vmul.f32	s14, s14, s7
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 80163e2:	eee2 7a82 	vfma.f32	s15, s5, s4
 80163e6:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 80163e8:	429c      	cmp	r4, r3
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 80163ea:	eea2 6a83 	vfma.f32	s12, s5, s6
 80163ee:	f101 0108 	add.w	r1, r1, #8
 80163f2:	f100 0008 	add.w	r0, r0, #8
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 80163f6:	eee4 6a23 	vfma.f32	s13, s8, s7
 80163fa:	f102 0208 	add.w	r2, r2, #8
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 80163fe:	eea4 7a24 	vfma.f32	s14, s8, s9
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8016402:	ee76 6a26 	vadd.f32	s13, s12, s13
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8016406:	ee77 7a87 	vadd.f32	s15, s15, s14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 801640a:	ee31 1a26 	vadd.f32	s2, s2, s13
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 801640e:	ee71 1aa7 	vadd.f32	s3, s3, s15
          for (k = 0; k < K; k++) {
 8016412:	d1ce      	bne.n	80163b2 <cblas_csyr2k+0x61e>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016414:	ee21 7ac5 	vnmul.f32	s14, s3, s10
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016418:	ee65 7a01 	vmul.f32	s15, s10, s2
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801641c:	eea5 7a81 	vfma.f32	s14, s11, s2
 8016420:	3508      	adds	r5, #8
 8016422:	44b6      	add	lr, r6
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016424:	eee5 7aa1 	vfma.f32	s15, s11, s3
 8016428:	44c4      	add	ip, r8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801642a:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801642e:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016432:	ed15 7a02 	vldr	s14, [r5, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016436:	ed55 7a01 	vldr	s15, [r5, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801643a:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801643e:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016442:	ed05 7a02 	vstr	s14, [r5, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016446:	ed45 7a01 	vstr	s15, [r5, #-4]
        for (j = 0; j <= i; j++) {
 801644a:	45a9      	cmp	r9, r5
 801644c:	d1a3      	bne.n	8016396 <cblas_csyr2k+0x602>
      for (i = 0; i < N; i++) {
 801644e:	9a05      	ldr	r2, [sp, #20]
 8016450:	9903      	ldr	r1, [sp, #12]
 8016452:	9b06      	ldr	r3, [sp, #24]
 8016454:	440a      	add	r2, r1
 8016456:	9205      	str	r2, [sp, #20]
 8016458:	9a08      	ldr	r2, [sp, #32]
 801645a:	9904      	ldr	r1, [sp, #16]
 801645c:	4491      	add	r9, r2
 801645e:	9a07      	ldr	r2, [sp, #28]
 8016460:	4492      	add	sl, r2
 8016462:	4414      	add	r4, r2
 8016464:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8016466:	3301      	adds	r3, #1
 8016468:	429a      	cmp	r2, r3
 801646a:	9306      	str	r3, [sp, #24]
 801646c:	448b      	add	fp, r1
 801646e:	d18b      	bne.n	8016388 <cblas_csyr2k+0x5f4>
 8016470:	e5a7      	b.n	8015fc2 <cblas_csyr2k+0x22e>
        for (i = 0; i < N; i++) {
 8016472:	2d00      	cmp	r5, #0
 8016474:	f77f adc9 	ble.w	801600a <cblas_csyr2k+0x276>
 8016478:	9b03      	ldr	r3, [sp, #12]
 801647a:	9802      	ldr	r0, [sp, #8]
 801647c:	f103 0c01 	add.w	ip, r3, #1
 8016480:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8016484:	2100      	movs	r1, #0
 8016486:	4603      	mov	r3, r0
 8016488:	460a      	mov	r2, r1
            const BASE Cij_real = REAL(C, ldc * i + j);
 801648a:	edd3 4a00 	vldr	s9, [r3]
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 801648e:	ed93 4a01 	vldr	s8, [r3, #4]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016492:	ee26 7a24 	vmul.f32	s14, s12, s9
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016496:	ee64 7a46 	vnmul.f32	s15, s8, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801649a:	eea6 7a84 	vfma.f32	s14, s13, s8
          for (j = i; j < N; j++) {
 801649e:	3201      	adds	r2, #1
 80164a0:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80164a2:	eee6 7aa4 	vfma.f32	s15, s13, s9
 80164a6:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80164aa:	ed03 7a01 	vstr	s14, [r3, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80164ae:	ed43 7a02 	vstr	s15, [r3, #-8]
          for (j = i; j < N; j++) {
 80164b2:	dcea      	bgt.n	801648a <cblas_csyr2k+0x6f6>
        for (i = 0; i < N; i++) {
 80164b4:	3101      	adds	r1, #1
 80164b6:	428d      	cmp	r5, r1
 80164b8:	4460      	add	r0, ip
 80164ba:	d1e4      	bne.n	8016486 <cblas_csyr2k+0x6f2>
 80164bc:	e5a5      	b.n	801600a <cblas_csyr2k+0x276>
 80164be:	463b      	mov	r3, r7
 80164c0:	e519      	b.n	8015ef6 <cblas_csyr2k+0x162>
 80164c2:	bf00      	nop

080164c4 <cblas_csyrk>:
void
cblas_csyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const void *alpha, const void *A, const int lda,
             const void *beta, void *C, const int ldc)
{
 80164c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80164c8:	b087      	sub	sp, #28
 80164ca:	461e      	mov	r6, r3
 80164cc:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 80164d0:	4691      	mov	r9, r2
 80164d2:	9302      	str	r3, [sp, #8]
 80164d4:	e9dd 3214 	ldrd	r3, r2, [sp, #80]	; 0x50

{
  INDEX i, j, k;
  int uplo, trans;

  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 80164d8:	2865      	cmp	r0, #101	; 0x65
 80164da:	e9dd 7412 	ldrd	r7, r4, [sp, #72]	; 0x48
 80164de:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
 80164e2:	9201      	str	r2, [sp, #4]
 80164e4:	4682      	mov	sl, r0
 80164e6:	4688      	mov	r8, r1
 80164e8:	f000 80ff 	beq.w	80166ea <cblas_csyrk+0x226>
 80164ec:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80164f0:	d01f      	beq.n	8016532 <cblas_csyrk+0x6e>
 80164f2:	462a      	mov	r2, r5
 80164f4:	f1a8 0179 	sub.w	r1, r8, #121	; 0x79
 80164f8:	2901      	cmp	r1, #1
 80164fa:	f240 80ef 	bls.w	80166dc <cblas_csyrk+0x218>
 80164fe:	2002      	movs	r0, #2
 8016500:	f1a9 016f 	sub.w	r1, r9, #111	; 0x6f
 8016504:	2902      	cmp	r1, #2
 8016506:	bf88      	it	hi
 8016508:	2003      	movhi	r0, #3
 801650a:	2e00      	cmp	r6, #0
 801650c:	bfb8      	it	lt
 801650e:	2004      	movlt	r0, #4
 8016510:	2a01      	cmp	r2, #1
 8016512:	bfb8      	it	lt
 8016514:	2201      	movlt	r2, #1
 8016516:	2d00      	cmp	r5, #0
 8016518:	f2c0 80d4 	blt.w	80166c4 <cblas_csyrk+0x200>
 801651c:	42a2      	cmp	r2, r4
 801651e:	dc10      	bgt.n	8016542 <cblas_csyrk+0x7e>
 8016520:	2e01      	cmp	r6, #1
 8016522:	4632      	mov	r2, r6
 8016524:	bfb8      	it	lt
 8016526:	2201      	movlt	r2, #1
 8016528:	455a      	cmp	r2, fp
 801652a:	f300 81d5 	bgt.w	80168d8 <cblas_csyrk+0x414>
 801652e:	b1b0      	cbz	r0, 801655e <cblas_csyrk+0x9a>
 8016530:	e00f      	b.n	8016552 <cblas_csyrk+0x8e>
 8016532:	4632      	mov	r2, r6
 8016534:	f1a8 0179 	sub.w	r1, r8, #121	; 0x79
 8016538:	2901      	cmp	r1, #1
 801653a:	f240 80cf 	bls.w	80166dc <cblas_csyrk+0x218>
 801653e:	2002      	movs	r0, #2
 8016540:	e7e3      	b.n	801650a <cblas_csyrk+0x46>
 8016542:	2e01      	cmp	r6, #1
 8016544:	4630      	mov	r0, r6
 8016546:	bfb8      	it	lt
 8016548:	2001      	movlt	r0, #1
 801654a:	4558      	cmp	r0, fp
 801654c:	bfcc      	ite	gt
 801654e:	200b      	movgt	r0, #11
 8016550:	2008      	movle	r0, #8
 8016552:	4add      	ldr	r2, [pc, #884]	; (80168c8 <cblas_csyrk+0x404>)
 8016554:	49dd      	ldr	r1, [pc, #884]	; (80168cc <cblas_csyrk+0x408>)
 8016556:	9303      	str	r3, [sp, #12]
 8016558:	f011 fa76 	bl	8027a48 <cblas_xerbla>
 801655c:	9b03      	ldr	r3, [sp, #12]

  {
    const BASE alpha_real = CONST_REAL0(alpha);
 801655e:	9a02      	ldr	r2, [sp, #8]
    const BASE alpha_imag = CONST_IMAG0(alpha);

    const BASE beta_real = CONST_REAL0(beta);
 8016560:	edd3 6a00 	vldr	s13, [r3]
    const BASE alpha_real = CONST_REAL0(alpha);
 8016564:	edd2 4a00 	vldr	s9, [r2]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8016568:	ed92 4a01 	vldr	s8, [r2, #4]
    const BASE beta_imag = CONST_IMAG0(beta);
 801656c:	ed93 6a01 	vldr	s12, [r3, #4]

    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8016570:	eef5 4a40 	vcmp.f32	s9, #0.0
 8016574:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    const BASE alpha_real = CONST_REAL0(alpha);
 8016578:	4611      	mov	r1, r2
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801657a:	d10c      	bne.n	8016596 <cblas_csyrk+0xd2>
 801657c:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8016580:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016584:	d107      	bne.n	8016596 <cblas_csyrk+0xd2>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8016586:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801658a:	eef4 6a67 	vcmp.f32	s13, s15
 801658e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016592:	f000 808e 	beq.w	80166b2 <cblas_csyrk+0x1ee>
      return;

    if (Order == CblasRowMajor) {
 8016596:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801659a:	f000 80ac 	beq.w	80166f6 <cblas_csyrk+0x232>
      uplo = Uplo;
      /* FIXME: original blas does not make distinction between Trans and ConjTrans?? */
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
    } else {
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801659e:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80165a2:	bf0c      	ite	eq
 80165a4:	f04f 087a 	moveq.w	r8, #122	; 0x7a
 80165a8:	f04f 0879 	movne.w	r8, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 80165ac:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80165b0:	bf0c      	ite	eq
 80165b2:	2170      	moveq	r1, #112	; 0x70
 80165b4:	216f      	movne	r1, #111	; 0x6f
    }

    /* form  y := beta*y */
    if (beta_real == 0.0 && beta_imag == 0.0) {
 80165b6:	eef5 6a40 	vcmp.f32	s13, #0.0
 80165ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80165be:	d13d      	bne.n	801663c <cblas_csyrk+0x178>
 80165c0:	eeb5 6a40 	vcmp.f32	s12, #0.0
 80165c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80165c8:	d145      	bne.n	8016656 <cblas_csyrk+0x192>
      if (uplo == CblasUpper) {
 80165ca:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80165ce:	f000 8098 	beq.w	8016702 <cblas_csyrk+0x23e>
            REAL(C, ldc * i + j) = 0.0;
            IMAG(C, ldc * i + j) = 0.0;
          }
        }
      } else {
        for (i = 0; i < N; i++) {
 80165d2:	2e00      	cmp	r6, #0
 80165d4:	dd18      	ble.n	8016608 <cblas_csyrk+0x144>
 80165d6:	9b01      	ldr	r3, [sp, #4]
 80165d8:	f10b 0901 	add.w	r9, fp, #1
 80165dc:	f04f 0c00 	mov.w	ip, #0
 80165e0:	4618      	mov	r0, r3
          for (j = 0; j <= i; j++) {
            REAL(C, ldc * i + j) = 0.0;
 80165e2:	2200      	movs	r2, #0
 80165e4:	ea4f 09c9 	mov.w	r9, r9, lsl #3
        for (i = 0; i < N; i++) {
 80165e8:	46e6      	mov	lr, ip
 80165ea:	3008      	adds	r0, #8
 80165ec:	469a      	mov	sl, r3
 80165ee:	eb0a 03cc 	add.w	r3, sl, ip, lsl #3
            REAL(C, ldc * i + j) = 0.0;
 80165f2:	601a      	str	r2, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 80165f4:	605a      	str	r2, [r3, #4]
          for (j = 0; j <= i; j++) {
 80165f6:	3308      	adds	r3, #8
 80165f8:	4298      	cmp	r0, r3
 80165fa:	d1fa      	bne.n	80165f2 <cblas_csyrk+0x12e>
        for (i = 0; i < N; i++) {
 80165fc:	f10e 0e01 	add.w	lr, lr, #1
 8016600:	4576      	cmp	r6, lr
 8016602:	44dc      	add	ip, fp
 8016604:	4448      	add	r0, r9
 8016606:	d1f2      	bne.n	80165ee <cblas_csyrk+0x12a>
          }
        }
      }
    }

    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8016608:	eef5 4a40 	vcmp.f32	s9, #0.0
 801660c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016610:	d108      	bne.n	8016624 <cblas_csyrk+0x160>
 8016612:	eeb5 4a40 	vcmp.f32	s8, #0.0
 8016616:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801661a:	d050      	beq.n	80166be <cblas_csyrk+0x1fa>
      return;

    if (uplo == CblasUpper && trans == CblasNoTrans) {
 801661c:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8016620:	f000 808e 	beq.w	8016740 <cblas_csyrk+0x27c>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8016624:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8016628:	f000 80e5 	beq.w	80167f6 <cblas_csyrk+0x332>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 801662c:	4aa8      	ldr	r2, [pc, #672]	; (80168d0 <cblas_csyrk+0x40c>)
 801662e:	49a7      	ldr	r1, [pc, #668]	; (80168cc <cblas_csyrk+0x408>)
 8016630:	2000      	movs	r0, #0
#define BASE float
#include "source_syrk_c.h"
#undef BASE
}
 8016632:	b007      	add	sp, #28
 8016634:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016638:	f011 ba06 	b.w	8027a48 <cblas_xerbla>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801663c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8016640:	eef4 6a67 	vcmp.f32	s13, s15
 8016644:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016648:	d105      	bne.n	8016656 <cblas_csyrk+0x192>
 801664a:	eeb5 6a40 	vcmp.f32	s12, #0.0
 801664e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016652:	f000 8131 	beq.w	80168b8 <cblas_csyrk+0x3f4>
      if (uplo == CblasUpper) {
 8016656:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801665a:	f000 8204 	beq.w	8016a66 <cblas_csyrk+0x5a2>
        for (i = 0; i < N; i++) {
 801665e:	2e00      	cmp	r6, #0
 8016660:	ddd2      	ble.n	8016608 <cblas_csyrk+0x144>
 8016662:	9b01      	ldr	r3, [sp, #4]
 8016664:	ea4f 09cb 	mov.w	r9, fp, lsl #3
 8016668:	f109 0a08 	add.w	sl, r9, #8
 801666c:	469c      	mov	ip, r3
 801666e:	f103 0008 	add.w	r0, r3, #8
 8016672:	f04f 0e00 	mov.w	lr, #0
 8016676:	f10c 0204 	add.w	r2, ip, #4
 801667a:	4663      	mov	r3, ip
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 801667c:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Cij_real = REAL(C, ldc * i + j);
 8016680:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016684:	ee25 7ac6 	vnmul.f32	s14, s11, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016688:	ee66 7a05 	vmul.f32	s15, s12, s10
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801668c:	eea6 7a85 	vfma.f32	s14, s13, s10
 8016690:	3308      	adds	r3, #8
 8016692:	3208      	adds	r2, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016694:	eee6 7aa5 	vfma.f32	s15, s13, s11
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016698:	ed02 7a03 	vstr	s14, [r2, #-12]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801669c:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j <= i; j++) {
 80166a0:	4298      	cmp	r0, r3
 80166a2:	d1eb      	bne.n	801667c <cblas_csyrk+0x1b8>
        for (i = 0; i < N; i++) {
 80166a4:	f10e 0e01 	add.w	lr, lr, #1
 80166a8:	4576      	cmp	r6, lr
 80166aa:	44cc      	add	ip, r9
 80166ac:	4450      	add	r0, sl
 80166ae:	d1e2      	bne.n	8016676 <cblas_csyrk+0x1b2>
 80166b0:	e7aa      	b.n	8016608 <cblas_csyrk+0x144>
        && (beta_real == 1.0 && beta_imag == 0.0))
 80166b2:	eeb5 6a40 	vcmp.f32	s12, #0.0
 80166b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80166ba:	f47f af6c 	bne.w	8016596 <cblas_csyrk+0xd2>
 80166be:	b007      	add	sp, #28
 80166c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 80166c4:	42a2      	cmp	r2, r4
 80166c6:	f73f af3c 	bgt.w	8016542 <cblas_csyrk+0x7e>
 80166ca:	2e01      	cmp	r6, #1
 80166cc:	4630      	mov	r0, r6
 80166ce:	bfb8      	it	lt
 80166d0:	2001      	movlt	r0, #1
 80166d2:	4583      	cmp	fp, r0
 80166d4:	bfb4      	ite	lt
 80166d6:	200b      	movlt	r0, #11
 80166d8:	2005      	movge	r0, #5
 80166da:	e73a      	b.n	8016552 <cblas_csyrk+0x8e>
 80166dc:	f1aa 0065 	sub.w	r0, sl, #101	; 0x65
 80166e0:	2801      	cmp	r0, #1
 80166e2:	bf94      	ite	ls
 80166e4:	2000      	movls	r0, #0
 80166e6:	2001      	movhi	r0, #1
 80166e8:	e70a      	b.n	8016500 <cblas_csyrk+0x3c>
 80166ea:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80166ee:	f000 81e0 	beq.w	8016ab2 <cblas_csyrk+0x5ee>
 80166f2:	4632      	mov	r2, r6
 80166f4:	e6fe      	b.n	80164f4 <cblas_csyrk+0x30>
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80166f6:	f1b9 0f6f 	cmp.w	r9, #111	; 0x6f
 80166fa:	bf0c      	ite	eq
 80166fc:	216f      	moveq	r1, #111	; 0x6f
 80166fe:	2170      	movne	r1, #112	; 0x70
 8016700:	e759      	b.n	80165b6 <cblas_csyrk+0xf2>
        for (i = 0; i < N; i++) {
 8016702:	2e00      	cmp	r6, #0
 8016704:	dd16      	ble.n	8016734 <cblas_csyrk+0x270>
 8016706:	f10b 0901 	add.w	r9, fp, #1
 801670a:	f8dd e004 	ldr.w	lr, [sp, #4]
            REAL(C, ldc * i + j) = 0.0;
 801670e:	2000      	movs	r0, #0
 8016710:	ea4f 09c9 	mov.w	r9, r9, lsl #3
        for (i = 0; i < N; i++) {
 8016714:	f04f 0c00 	mov.w	ip, #0
 8016718:	4673      	mov	r3, lr
 801671a:	4662      	mov	r2, ip
          for (j = i; j < N; j++) {
 801671c:	3201      	adds	r2, #1
 801671e:	4296      	cmp	r6, r2
            REAL(C, ldc * i + j) = 0.0;
 8016720:	6018      	str	r0, [r3, #0]
            IMAG(C, ldc * i + j) = 0.0;
 8016722:	6058      	str	r0, [r3, #4]
          for (j = i; j < N; j++) {
 8016724:	f103 0308 	add.w	r3, r3, #8
 8016728:	dcf8      	bgt.n	801671c <cblas_csyrk+0x258>
        for (i = 0; i < N; i++) {
 801672a:	f10c 0c01 	add.w	ip, ip, #1
 801672e:	4566      	cmp	r6, ip
 8016730:	44ce      	add	lr, r9
 8016732:	d1f1      	bne.n	8016718 <cblas_csyrk+0x254>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8016734:	eef5 4a40 	vcmp.f32	s9, #0.0
 8016738:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801673c:	f43f af69 	beq.w	8016612 <cblas_csyrk+0x14e>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8016740:	296f      	cmp	r1, #111	; 0x6f
 8016742:	f000 80cb 	beq.w	80168dc <cblas_csyrk+0x418>
      for (i = 0; i < N; i++) {
 8016746:	2e00      	cmp	r6, #0
 8016748:	ddb9      	ble.n	80166be <cblas_csyrk+0x1fa>
 801674a:	f10b 0901 	add.w	r9, fp, #1
 801674e:	f8dd b004 	ldr.w	fp, [sp, #4]
 8016752:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8016756:	00e4      	lsls	r4, r4, #3
 8016758:	f107 0e04 	add.w	lr, r7, #4
 801675c:	f04f 0800 	mov.w	r8, #0
          BASE temp_real = 0.0;
 8016760:	4658      	mov	r0, fp
 8016762:	46c4      	mov	ip, r8
          BASE temp_imag = 0.0;
 8016764:	ed9f 5a5b 	vldr	s10, [pc, #364]	; 80168d4 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 8016768:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 801676a:	eef0 3a45 	vmov.f32	s7, s10
          for (k = 0; k < K; k++) {
 801676e:	dd1c      	ble.n	80167aa <cblas_csyrk+0x2e6>
 8016770:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 8016774:	4673      	mov	r3, lr
 8016776:	2100      	movs	r1, #0
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8016778:	edd3 7a00 	vldr	s15, [r3]
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801677c:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8016780:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016784:	ed13 6a01 	vldr	s12, [r3, #-4]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8016788:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801678c:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8016790:	eea6 7a25 	vfma.f32	s14, s12, s11
          for (k = 0; k < K; k++) {
 8016794:	3101      	adds	r1, #1
 8016796:	428d      	cmp	r5, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8016798:	eee6 7a26 	vfma.f32	s15, s12, s13
 801679c:	4422      	add	r2, r4
 801679e:	4423      	add	r3, r4
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80167a0:	ee73 3a87 	vadd.f32	s7, s7, s14
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80167a4:	ee35 5a27 	vadd.f32	s10, s10, s15
          for (k = 0; k < K; k++) {
 80167a8:	d1e6      	bne.n	8016778 <cblas_csyrk+0x2b4>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80167aa:	ee25 7a44 	vnmul.f32	s14, s10, s8
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80167ae:	ee64 7a23 	vmul.f32	s15, s8, s7
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80167b2:	eea4 7aa3 	vfma.f32	s14, s9, s7
        for (j = i; j < N; j++) {
 80167b6:	f10c 0c01 	add.w	ip, ip, #1
 80167ba:	4566      	cmp	r6, ip
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80167bc:	eee4 7a85 	vfma.f32	s15, s9, s10
 80167c0:	f100 0008 	add.w	r0, r0, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80167c4:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80167c8:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80167cc:	ed10 7a02 	vldr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80167d0:	ed50 7a01 	vldr	s15, [r0, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80167d4:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80167d8:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80167dc:	ed00 7a02 	vstr	s14, [r0, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80167e0:	ed40 7a01 	vstr	s15, [r0, #-4]
        for (j = i; j < N; j++) {
 80167e4:	dcbe      	bgt.n	8016764 <cblas_csyrk+0x2a0>
      for (i = 0; i < N; i++) {
 80167e6:	f108 0801 	add.w	r8, r8, #1
 80167ea:	4546      	cmp	r6, r8
 80167ec:	44cb      	add	fp, r9
 80167ee:	f10e 0e08 	add.w	lr, lr, #8
 80167f2:	d1b5      	bne.n	8016760 <cblas_csyrk+0x29c>
 80167f4:	e763      	b.n	80166be <cblas_csyrk+0x1fa>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80167f6:	296f      	cmp	r1, #111	; 0x6f
 80167f8:	f000 80d0 	beq.w	801699c <cblas_csyrk+0x4d8>
      for (i = 0; i < N; i++) {
 80167fc:	2e00      	cmp	r6, #0
 80167fe:	f77f af5e 	ble.w	80166be <cblas_csyrk+0x1fa>
 8016802:	9b01      	ldr	r3, [sp, #4]
 8016804:	3304      	adds	r3, #4
 8016806:	00e4      	lsls	r4, r4, #3
 8016808:	f107 0904 	add.w	r9, r7, #4
 801680c:	f04f 0a00 	mov.w	sl, #0
 8016810:	f04f 0801 	mov.w	r8, #1
 8016814:	9302      	str	r3, [sp, #8]
 8016816:	9b01      	ldr	r3, [sp, #4]
 8016818:	eb03 0cca 	add.w	ip, r3, sl, lsl #3
 801681c:	9b02      	ldr	r3, [sp, #8]
        for (j = 0; j <= i; j++) {
 801681e:	f04f 0e00 	mov.w	lr, #0
 8016822:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
          BASE temp_imag = 0.0;
 8016826:	eddf 3a2b 	vldr	s7, [pc, #172]	; 80168d4 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 801682a:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 801682c:	eeb0 5a63 	vmov.f32	s10, s7
          for (k = 0; k < K; k++) {
 8016830:	dd1c      	ble.n	801686c <cblas_csyrk+0x3a8>
 8016832:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 8016836:	464b      	mov	r3, r9
 8016838:	2100      	movs	r1, #0
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801683a:	edd3 7a00 	vldr	s15, [r3]
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801683e:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8016842:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016846:	ed13 6a01 	vldr	s12, [r3, #-4]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801684a:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801684e:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8016852:	eea6 7a25 	vfma.f32	s14, s12, s11
          for (k = 0; k < K; k++) {
 8016856:	3101      	adds	r1, #1
 8016858:	428d      	cmp	r5, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801685a:	eee6 7a26 	vfma.f32	s15, s12, s13
 801685e:	4422      	add	r2, r4
 8016860:	4423      	add	r3, r4
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8016862:	ee35 5a07 	vadd.f32	s10, s10, s14
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8016866:	ee73 3aa7 	vadd.f32	s7, s7, s15
          for (k = 0; k < K; k++) {
 801686a:	d1e6      	bne.n	801683a <cblas_csyrk+0x376>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801686c:	ee63 7ac4 	vnmul.f32	s15, s7, s8
 8016870:	ed10 7a01 	vldr	s14, [r0, #-4]
 8016874:	eee4 7a85 	vfma.f32	s15, s9, s10
        for (j = 0; j <= i; j++) {
 8016878:	f10e 0e01 	add.w	lr, lr, #1
 801687c:	45c6      	cmp	lr, r8
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801687e:	ee24 5a05 	vmul.f32	s10, s8, s10
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016882:	ee77 7a27 	vadd.f32	s15, s14, s15
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016886:	eea4 5aa3 	vfma.f32	s10, s9, s7
 801688a:	f100 0008 	add.w	r0, r0, #8
 801688e:	f10c 0c08 	add.w	ip, ip, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016892:	ed40 7a03 	vstr	s15, [r0, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016896:	ed5c 7a01 	vldr	s15, [ip, #-4]
 801689a:	ee37 5a85 	vadd.f32	s10, s15, s10
 801689e:	ed0c 5a01 	vstr	s10, [ip, #-4]
        for (j = 0; j <= i; j++) {
 80168a2:	d1c0      	bne.n	8016826 <cblas_csyrk+0x362>
      for (i = 0; i < N; i++) {
 80168a4:	4546      	cmp	r6, r8
 80168a6:	44da      	add	sl, fp
 80168a8:	f109 0908 	add.w	r9, r9, #8
 80168ac:	f108 0301 	add.w	r3, r8, #1
 80168b0:	f43f af05 	beq.w	80166be <cblas_csyrk+0x1fa>
 80168b4:	4698      	mov	r8, r3
 80168b6:	e7ae      	b.n	8016816 <cblas_csyrk+0x352>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80168b8:	eef5 4a40 	vcmp.f32	s9, #0.0
 80168bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80168c0:	f47f aeac 	bne.w	801661c <cblas_csyrk+0x158>
 80168c4:	e6a5      	b.n	8016612 <cblas_csyrk+0x14e>
 80168c6:	bf00      	nop
 80168c8:	08030378 	.word	0x08030378
 80168cc:	08030774 	.word	0x08030774
 80168d0:	080305a8 	.word	0x080305a8
 80168d4:	00000000 	.word	0x00000000
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 80168d8:	200b      	movs	r0, #11
 80168da:	e63a      	b.n	8016552 <cblas_csyrk+0x8e>
      for (i = 0; i < N; i++) {
 80168dc:	2e00      	cmp	r6, #0
 80168de:	f77f aeee 	ble.w	80166be <cblas_csyrk+0x1fa>
 80168e2:	f10b 0301 	add.w	r3, fp, #1
 80168e6:	00db      	lsls	r3, r3, #3
 80168e8:	f04f 0a00 	mov.w	sl, #0
 80168ec:	9302      	str	r3, [sp, #8]
 80168ee:	00e3      	lsls	r3, r4, #3
 80168f0:	f8dd b004 	ldr.w	fp, [sp, #4]
 80168f4:	9301      	str	r3, [sp, #4]
 80168f6:	46d1      	mov	r9, sl
 80168f8:	eb07 00c5 	add.w	r0, r7, r5, lsl #3
 80168fc:	46b8      	mov	r8, r7
          BASE temp_real = 0.0;
 80168fe:	46d6      	mov	lr, sl
 8016900:	4659      	mov	r1, fp
 8016902:	46cc      	mov	ip, r9
          BASE temp_imag = 0.0;
 8016904:	ed1f 5a0d 	vldr	s10, [pc, #-52]	; 80168d4 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 8016908:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 801690a:	eef0 3a45 	vmov.f32	s7, s10
          for (k = 0; k < K; k++) {
 801690e:	dd1b      	ble.n	8016948 <cblas_csyrk+0x484>
 8016910:	eb07 02ce 	add.w	r2, r7, lr, lsl #3
 8016914:	4643      	mov	r3, r8
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8016916:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801691a:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801691e:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8016922:	ed93 6a00 	vldr	s12, [r3]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8016926:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801692a:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801692e:	eea6 7a25 	vfma.f32	s14, s12, s11
 8016932:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8016934:	4298      	cmp	r0, r3
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8016936:	eee6 7a26 	vfma.f32	s15, s12, s13
 801693a:	f102 0208 	add.w	r2, r2, #8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801693e:	ee73 3a87 	vadd.f32	s7, s7, s14
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8016942:	ee35 5a27 	vadd.f32	s10, s10, s15
          for (k = 0; k < K; k++) {
 8016946:	d1e6      	bne.n	8016916 <cblas_csyrk+0x452>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016948:	ee25 7a44 	vnmul.f32	s14, s10, s8
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801694c:	ee63 7a84 	vmul.f32	s15, s7, s8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016950:	eea3 7aa4 	vfma.f32	s14, s7, s9
        for (j = i; j < N; j++) {
 8016954:	f10c 0c01 	add.w	ip, ip, #1
 8016958:	4566      	cmp	r6, ip
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 801695a:	eee4 7a85 	vfma.f32	s15, s9, s10
 801695e:	44a6      	add	lr, r4
 8016960:	f101 0108 	add.w	r1, r1, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016964:	eeb0 6a47 	vmov.f32	s12, s14
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016968:	eef0 6a67 	vmov.f32	s13, s15
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801696c:	ed11 7a02 	vldr	s14, [r1, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016970:	ed51 7a01 	vldr	s15, [r1, #-4]
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016974:	ee37 7a06 	vadd.f32	s14, s14, s12
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016978:	ee77 7aa6 	vadd.f32	s15, s15, s13
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 801697c:	ed01 7a02 	vstr	s14, [r1, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016980:	ed41 7a01 	vstr	s15, [r1, #-4]
        for (j = i; j < N; j++) {
 8016984:	dcbe      	bgt.n	8016904 <cblas_csyrk+0x440>
      for (i = 0; i < N; i++) {
 8016986:	9b02      	ldr	r3, [sp, #8]
 8016988:	f109 0901 	add.w	r9, r9, #1
 801698c:	449b      	add	fp, r3
 801698e:	9b01      	ldr	r3, [sp, #4]
 8016990:	454e      	cmp	r6, r9
 8016992:	44a2      	add	sl, r4
 8016994:	4498      	add	r8, r3
 8016996:	4418      	add	r0, r3
 8016998:	d1b1      	bne.n	80168fe <cblas_csyrk+0x43a>
 801699a:	e690      	b.n	80166be <cblas_csyrk+0x1fa>
      for (i = 0; i < N; i++) {
 801699c:	2e00      	cmp	r6, #0
 801699e:	f77f ae8e 	ble.w	80166be <cblas_csyrk+0x1fa>
 80169a2:	f10b 0301 	add.w	r3, fp, #1
 80169a6:	00db      	lsls	r3, r3, #3
 80169a8:	9303      	str	r3, [sp, #12]
 80169aa:	9b01      	ldr	r3, [sp, #4]
 80169ac:	f04f 0a00 	mov.w	sl, #0
 80169b0:	f103 0808 	add.w	r8, r3, #8
 80169b4:	00e2      	lsls	r2, r4, #3
 80169b6:	3304      	adds	r3, #4
 80169b8:	e9cd 6b04 	strd	r6, fp, [sp, #16]
 80169bc:	46d6      	mov	lr, sl
 80169be:	eb07 01c5 	add.w	r1, r7, r5, lsl #3
 80169c2:	46b9      	mov	r9, r7
 80169c4:	9302      	str	r3, [sp, #8]
 80169c6:	4693      	mov	fp, r2
 80169c8:	9b01      	ldr	r3, [sp, #4]
 80169ca:	eb03 00ca 	add.w	r0, r3, sl, lsl #3
 80169ce:	9b02      	ldr	r3, [sp, #8]
          BASE temp_real = 0.0;
 80169d0:	f04f 0c00 	mov.w	ip, #0
 80169d4:	eb03 06ca 	add.w	r6, r3, sl, lsl #3
          BASE temp_imag = 0.0;
 80169d8:	ed5f 3a42 	vldr	s7, [pc, #-264]	; 80168d4 <cblas_csyrk+0x410>
          for (k = 0; k < K; k++) {
 80169dc:	2d00      	cmp	r5, #0
          BASE temp_real = 0.0;
 80169de:	eeb0 5a63 	vmov.f32	s10, s7
          for (k = 0; k < K; k++) {
 80169e2:	dd1b      	ble.n	8016a1c <cblas_csyrk+0x558>
 80169e4:	eb07 02cc 	add.w	r2, r7, ip, lsl #3
 80169e8:	464b      	mov	r3, r9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 80169ea:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 80169ee:	edd2 6a01 	vldr	s13, [r2, #4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80169f2:	edd2 5a00 	vldr	s11, [r2]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80169f6:	ed93 6a00 	vldr	s12, [r3]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80169fa:	ee26 7ae7 	vnmul.f32	s14, s13, s15
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80169fe:	ee67 7aa5 	vmul.f32	s15, s15, s11
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8016a02:	eea6 7a25 	vfma.f32	s14, s12, s11
 8016a06:	3308      	adds	r3, #8
          for (k = 0; k < K; k++) {
 8016a08:	4299      	cmp	r1, r3
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8016a0a:	eee6 7a26 	vfma.f32	s15, s12, s13
 8016a0e:	f102 0208 	add.w	r2, r2, #8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 8016a12:	ee35 5a07 	vadd.f32	s10, s10, s14
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8016a16:	ee73 3aa7 	vadd.f32	s7, s7, s15
          for (k = 0; k < K; k++) {
 8016a1a:	d1e6      	bne.n	80169ea <cblas_csyrk+0x526>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016a1c:	ee63 7ac4 	vnmul.f32	s15, s7, s8
 8016a20:	ed16 7a01 	vldr	s14, [r6, #-4]
 8016a24:	eee4 7a85 	vfma.f32	s15, s9, s10
 8016a28:	3008      	adds	r0, #8
 8016a2a:	44a4      	add	ip, r4
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016a2c:	ee24 5a05 	vmul.f32	s10, s8, s10
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016a30:	ee77 7a27 	vadd.f32	s15, s14, s15
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016a34:	eea4 5aa3 	vfma.f32	s10, s9, s7
 8016a38:	3608      	adds	r6, #8
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8016a3a:	ed46 7a03 	vstr	s15, [r6, #-12]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8016a3e:	ed50 7a01 	vldr	s15, [r0, #-4]
 8016a42:	ee37 5a85 	vadd.f32	s10, s15, s10
 8016a46:	ed00 5a01 	vstr	s10, [r0, #-4]
        for (j = 0; j <= i; j++) {
 8016a4a:	4580      	cmp	r8, r0
 8016a4c:	d1c4      	bne.n	80169d8 <cblas_csyrk+0x514>
      for (i = 0; i < N; i++) {
 8016a4e:	9b05      	ldr	r3, [sp, #20]
 8016a50:	449a      	add	sl, r3
 8016a52:	9b03      	ldr	r3, [sp, #12]
 8016a54:	4498      	add	r8, r3
 8016a56:	9b04      	ldr	r3, [sp, #16]
 8016a58:	f10e 0e01 	add.w	lr, lr, #1
 8016a5c:	4573      	cmp	r3, lr
 8016a5e:	44d9      	add	r9, fp
 8016a60:	4459      	add	r1, fp
 8016a62:	d1b1      	bne.n	80169c8 <cblas_csyrk+0x504>
 8016a64:	e62b      	b.n	80166be <cblas_csyrk+0x1fa>
        for (i = 0; i < N; i++) {
 8016a66:	2e00      	cmp	r6, #0
 8016a68:	f77f ae64 	ble.w	8016734 <cblas_csyrk+0x270>
 8016a6c:	f10b 0e01 	add.w	lr, fp, #1
 8016a70:	f8dd c004 	ldr.w	ip, [sp, #4]
 8016a74:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 8016a78:	2000      	movs	r0, #0
 8016a7a:	4663      	mov	r3, ip
 8016a7c:	4602      	mov	r2, r0
            const BASE Cij_real = REAL(C, ldc * i + j);
 8016a7e:	edd3 5a00 	vldr	s11, [r3]
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8016a82:	ed93 5a01 	vldr	s10, [r3, #4]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016a86:	ee26 7a25 	vmul.f32	s14, s12, s11
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016a8a:	ee65 7a46 	vnmul.f32	s15, s10, s12
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016a8e:	eea6 7a85 	vfma.f32	s14, s13, s10
          for (j = i; j < N; j++) {
 8016a92:	3201      	adds	r2, #1
 8016a94:	4296      	cmp	r6, r2
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016a96:	eee6 7aa5 	vfma.f32	s15, s13, s11
 8016a9a:	f103 0308 	add.w	r3, r3, #8
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8016a9e:	ed03 7a01 	vstr	s14, [r3, #-4]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8016aa2:	ed43 7a02 	vstr	s15, [r3, #-8]
          for (j = i; j < N; j++) {
 8016aa6:	dcea      	bgt.n	8016a7e <cblas_csyrk+0x5ba>
        for (i = 0; i < N; i++) {
 8016aa8:	3001      	adds	r0, #1
 8016aaa:	4286      	cmp	r6, r0
 8016aac:	44f4      	add	ip, lr
 8016aae:	d1e4      	bne.n	8016a7a <cblas_csyrk+0x5b6>
 8016ab0:	e640      	b.n	8016734 <cblas_csyrk+0x270>
 8016ab2:	462a      	mov	r2, r5
 8016ab4:	e53e      	b.n	8016534 <cblas_csyrk+0x70>
 8016ab6:	bf00      	nop

08016ab8 <cblas_ctrmm>:
cblas_ctrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8016ab8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016abc:	ed2d 8b02 	vpush	{d8}
{
  INDEX i, j, k;
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8016ac0:	2b71      	cmp	r3, #113	; 0x71
 8016ac2:	b089      	sub	sp, #36	; 0x24
 8016ac4:	4698      	mov	r8, r3
 8016ac6:	bf0c      	ite	eq
 8016ac8:	f04f 33ff 	moveq.w	r3, #4294967295
 8016acc:	2301      	movne	r3, #1
 8016ace:	ee08 3a10 	vmov	s16, r3
 8016ad2:	e9dd a317 	ldrd	sl, r3, [sp, #92]	; 0x5c
 8016ad6:	9302      	str	r3, [sp, #8]
 8016ad8:	e9dd 6319 	ldrd	r6, r3, [sp, #100]	; 0x64
  int side, uplo, trans;

  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8016adc:	298d      	cmp	r1, #141	; 0x8d
 8016ade:	9303      	str	r3, [sp, #12]
 8016ae0:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8016ae2:	f89d 5050 	ldrb.w	r5, [sp, #80]	; 0x50
 8016ae6:	9301      	str	r3, [sp, #4]
 8016ae8:	e9dd b415 	ldrd	fp, r4, [sp, #84]	; 0x54
 8016aec:	460f      	mov	r7, r1
 8016aee:	4691      	mov	r9, r2
 8016af0:	d06c      	beq.n	8016bcc <cblas_ctrmm+0x114>
 8016af2:	298e      	cmp	r1, #142	; 0x8e
 8016af4:	f000 82c4 	beq.w	8017080 <cblas_ctrmm+0x5c8>
 8016af8:	46a4      	mov	ip, r4
 8016afa:	2302      	movs	r3, #2
 8016afc:	f1a9 0279 	sub.w	r2, r9, #121	; 0x79
 8016b00:	2a01      	cmp	r2, #1
 8016b02:	f1a8 016f 	sub.w	r1, r8, #111	; 0x6f
 8016b06:	f105 027d 	add.w	r2, r5, #125	; 0x7d
 8016b0a:	bf88      	it	hi
 8016b0c:	2303      	movhi	r3, #3
 8016b0e:	b2d2      	uxtb	r2, r2
 8016b10:	2902      	cmp	r1, #2
 8016b12:	bf88      	it	hi
 8016b14:	2304      	movhi	r3, #4
 8016b16:	2a02      	cmp	r2, #2
 8016b18:	bf28      	it	cs
 8016b1a:	2305      	movcs	r3, #5
 8016b1c:	f1bb 0f00 	cmp.w	fp, #0
 8016b20:	bfb8      	it	lt
 8016b22:	2306      	movlt	r3, #6
 8016b24:	2c00      	cmp	r4, #0
 8016b26:	bfb8      	it	lt
 8016b28:	2307      	movlt	r3, #7
 8016b2a:	f1bc 0f01 	cmp.w	ip, #1
 8016b2e:	bfb8      	it	lt
 8016b30:	f04f 0c01 	movlt.w	ip, #1
 8016b34:	45b4      	cmp	ip, r6
 8016b36:	dd3c      	ble.n	8016bb2 <cblas_ctrmm+0xfa>
 8016b38:	2865      	cmp	r0, #101	; 0x65
 8016b3a:	f000 80d3 	beq.w	8016ce4 <cblas_ctrmm+0x22c>
 8016b3e:	465b      	mov	r3, fp
 8016b40:	2b01      	cmp	r3, #1
 8016b42:	9a01      	ldr	r2, [sp, #4]
 8016b44:	bfb8      	it	lt
 8016b46:	2301      	movlt	r3, #1
 8016b48:	4293      	cmp	r3, r2
 8016b4a:	bfcc      	ite	gt
 8016b4c:	230c      	movgt	r3, #12
 8016b4e:	230a      	movle	r3, #10
 8016b50:	4abe      	ldr	r2, [pc, #760]	; (8016e4c <cblas_ctrmm+0x394>)
 8016b52:	49bf      	ldr	r1, [pc, #764]	; (8016e50 <cblas_ctrmm+0x398>)
 8016b54:	4618      	mov	r0, r3
 8016b56:	f010 ff77 	bl	8027a48 <cblas_xerbla>
      uplo = Uplo;
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
    } else {
      n1 = N;
      n2 = M;
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8016b5a:	2f8d      	cmp	r7, #141	; 0x8d
 8016b5c:	bf0c      	ite	eq
 8016b5e:	278e      	moveq	r7, #142	; 0x8e
 8016b60:	278d      	movne	r7, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8016b62:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8016b66:	bf0c      	ite	eq
 8016b68:	f04f 097a 	moveq.w	r9, #122	; 0x7a
 8016b6c:	f04f 0979 	movne.w	r9, #121	; 0x79
    const BASE alpha_real = CONST_REAL0(alpha);
 8016b70:	edda 6a00 	vldr	s13, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8016b74:	ed9a 7a01 	vldr	s14, [sl, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 8016b78:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8016b7c:	bf0c      	ite	eq
 8016b7e:	f04f 086f 	moveq.w	r8, #111	; 0x6f
 8016b82:	f04f 0870 	movne.w	r8, #112	; 0x70
    }

    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8016b86:	2f8d      	cmp	r7, #141	; 0x8d
 8016b88:	d028      	beq.n	8016bdc <cblas_ctrmm+0x124>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8016b8a:	2f8e      	cmp	r7, #142	; 0x8e
 8016b8c:	d107      	bne.n	8016b9e <cblas_ctrmm+0xe6>
 8016b8e:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8016b92:	f000 80c7 	beq.w	8016d24 <cblas_ctrmm+0x26c>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8016b96:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8016b9a:	f000 815f 	beq.w	8016e5c <cblas_ctrmm+0x3a4>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
        }
      }

    } else {
      BLAS_ERROR("unrecognized operation");
 8016b9e:	4aad      	ldr	r2, [pc, #692]	; (8016e54 <cblas_ctrmm+0x39c>)
 8016ba0:	49ab      	ldr	r1, [pc, #684]	; (8016e50 <cblas_ctrmm+0x398>)
 8016ba2:	2000      	movs	r0, #0
#define BASE float
#include "source_trmm_c.h"
#undef BASE
}
 8016ba4:	b009      	add	sp, #36	; 0x24
 8016ba6:	ecbd 8b02 	vpop	{d8}
 8016baa:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016bae:	f010 bf4b 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8016bb2:	2865      	cmp	r0, #101	; 0x65
 8016bb4:	f000 81da 	beq.w	8016f6c <cblas_ctrmm+0x4b4>
 8016bb8:	465a      	mov	r2, fp
 8016bba:	2a01      	cmp	r2, #1
 8016bbc:	9901      	ldr	r1, [sp, #4]
 8016bbe:	bfb8      	it	lt
 8016bc0:	2201      	movlt	r2, #1
 8016bc2:	428a      	cmp	r2, r1
 8016bc4:	f340 80aa 	ble.w	8016d1c <cblas_ctrmm+0x264>
 8016bc8:	230c      	movs	r3, #12
 8016bca:	e7c1      	b.n	8016b50 <cblas_ctrmm+0x98>
 8016bcc:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8016bd0:	2b01      	cmp	r3, #1
 8016bd2:	bf94      	ite	ls
 8016bd4:	2300      	movls	r3, #0
 8016bd6:	2301      	movhi	r3, #1
 8016bd8:	46dc      	mov	ip, fp
 8016bda:	e78f      	b.n	8016afc <cblas_ctrmm+0x44>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8016bdc:	f1b9 0f79 	cmp.w	r9, #121	; 0x79
 8016be0:	f000 81cd 	beq.w	8016f7e <cblas_ctrmm+0x4c6>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8016be4:	f1b9 0f7a 	cmp.w	r9, #122	; 0x7a
 8016be8:	d1d9      	bne.n	8016b9e <cblas_ctrmm+0xe6>
 8016bea:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8016bee:	f000 8325 	beq.w	801723c <cblas_ctrmm+0x784>
      for (i = 0; i < n1; i++) {
 8016bf2:	2c00      	cmp	r4, #0
 8016bf4:	dd71      	ble.n	8016cda <cblas_ctrmm+0x222>
 8016bf6:	3601      	adds	r6, #1
 8016bf8:	00f2      	lsls	r2, r6, #3
 8016bfa:	9902      	ldr	r1, [sp, #8]
 8016bfc:	9207      	str	r2, [sp, #28]
 8016bfe:	1f13      	subs	r3, r2, #4
 8016c00:	18cf      	adds	r7, r1, r3
 8016c02:	9b01      	ldr	r3, [sp, #4]
 8016c04:	9305      	str	r3, [sp, #20]
 8016c06:	00d8      	lsls	r0, r3, #3
 8016c08:	2300      	movs	r3, #0
 8016c0a:	468a      	mov	sl, r1
 8016c0c:	f1a2 0608 	sub.w	r6, r2, #8
 8016c10:	9304      	str	r3, [sp, #16]
 8016c12:	f04f 0801 	mov.w	r8, #1
 8016c16:	46b9      	mov	r9, r7
        for (j = 0; j < n2; j++) {
 8016c18:	f1bb 0f00 	cmp.w	fp, #0
 8016c1c:	bfd8      	it	le
 8016c1e:	f8cd 8018 	strle.w	r8, [sp, #24]
 8016c22:	dd4a      	ble.n	8016cba <cblas_ctrmm+0x202>
 8016c24:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8016c28:	1a9b      	subs	r3, r3, r2
 8016c2a:	00db      	lsls	r3, r3, #3
 8016c2c:	3304      	adds	r3, #4
 8016c2e:	9302      	str	r3, [sp, #8]
 8016c30:	9b03      	ldr	r3, [sp, #12]
 8016c32:	f8cd 8018 	str.w	r8, [sp, #24]
 8016c36:	eb03 07c2 	add.w	r7, r3, r2, lsl #3
 8016c3a:	f04f 0e00 	mov.w	lr, #0
          if (nonunit) {
 8016c3e:	2d83      	cmp	r5, #131	; 0x83
 8016c40:	f000 825c 	beq.w	80170fc <cblas_ctrmm+0x644>
            temp_real = REAL(B, i * ldb + j);
 8016c44:	46bc      	mov	ip, r7
 8016c46:	ecfc 3a01 	vldmia	ip!, {s7}
            temp_imag = IMAG(B, i * ldb + j);
 8016c4a:	ed97 4a01 	vldr	s8, [r7, #4]
          for (k = i + 1; k < n1; k++) {
 8016c4e:	4544      	cmp	r4, r8
 8016c50:	dd20      	ble.n	8016c94 <cblas_ctrmm+0x1dc>
 8016c52:	9b02      	ldr	r3, [sp, #8]
 8016c54:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 8016c58:	19da      	adds	r2, r3, r7
 8016c5a:	4641      	mov	r1, r8
 8016c5c:	464b      	mov	r3, r9
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8016c5e:	edd3 7a00 	vldr	s15, [r3]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8016c62:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8016c66:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016c6a:	ed13 5a01 	vldr	s10, [r3, #-4]
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8016c6e:	ee63 7a27 	vmul.f32	s15, s6, s15
          for (k = i + 1; k < n1; k++) {
 8016c72:	3101      	adds	r1, #1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8016c74:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8016c78:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8016c7c:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = i + 1; k < n1; k++) {
 8016c80:	428c      	cmp	r4, r1
 8016c82:	4402      	add	r2, r0
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8016c84:	eee5 7a25 	vfma.f32	s15, s10, s11
 8016c88:	4433      	add	r3, r6
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8016c8a:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8016c8e:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = i + 1; k < n1; k++) {
 8016c92:	d1e4      	bne.n	8016c5e <cblas_ctrmm+0x1a6>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016c94:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016c98:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016c9c:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8016ca0:	f10e 0e01 	add.w	lr, lr, #1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016ca4:	463b      	mov	r3, r7
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016ca6:	eee4 7a26 	vfma.f32	s15, s8, s13
        for (j = 0; j < n2; j++) {
 8016caa:	45f3      	cmp	fp, lr
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016cac:	f107 0708 	add.w	r7, r7, #8
 8016cb0:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016cb4:	edcc 7a00 	vstr	s15, [ip]
        for (j = 0; j < n2; j++) {
 8016cb8:	d1c1      	bne.n	8016c3e <cblas_ctrmm+0x186>
      for (i = 0; i < n1; i++) {
 8016cba:	9b07      	ldr	r3, [sp, #28]
 8016cbc:	9905      	ldr	r1, [sp, #20]
 8016cbe:	9a01      	ldr	r2, [sp, #4]
 8016cc0:	460f      	mov	r7, r1
 8016cc2:	4499      	add	r9, r3
 8016cc4:	9904      	ldr	r1, [sp, #16]
 8016cc6:	449a      	add	sl, r3
 8016cc8:	9b06      	ldr	r3, [sp, #24]
 8016cca:	4417      	add	r7, r2
 8016ccc:	4411      	add	r1, r2
 8016cce:	429c      	cmp	r4, r3
 8016cd0:	f108 0801 	add.w	r8, r8, #1
 8016cd4:	9705      	str	r7, [sp, #20]
 8016cd6:	9104      	str	r1, [sp, #16]
 8016cd8:	dc9e      	bgt.n	8016c18 <cblas_ctrmm+0x160>
 8016cda:	b009      	add	sp, #36	; 0x24
 8016cdc:	ecbd 8b02 	vpop	{d8}
 8016ce0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8016ce4:	2c01      	cmp	r4, #1
 8016ce6:	9a01      	ldr	r2, [sp, #4]
 8016ce8:	4623      	mov	r3, r4
 8016cea:	bfb8      	it	lt
 8016cec:	2301      	movlt	r3, #1
 8016cee:	4293      	cmp	r3, r2
 8016cf0:	bfcc      	ite	gt
 8016cf2:	230c      	movgt	r3, #12
 8016cf4:	230a      	movle	r3, #10
 8016cf6:	4a55      	ldr	r2, [pc, #340]	; (8016e4c <cblas_ctrmm+0x394>)
 8016cf8:	4955      	ldr	r1, [pc, #340]	; (8016e50 <cblas_ctrmm+0x398>)
 8016cfa:	4618      	mov	r0, r3
 8016cfc:	f010 fea4 	bl	8027a48 <cblas_xerbla>
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8016d00:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
    const BASE alpha_real = CONST_REAL0(alpha);
 8016d04:	edda 6a00 	vldr	s13, [sl]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8016d08:	ed9a 7a01 	vldr	s14, [sl, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8016d0c:	4623      	mov	r3, r4
 8016d0e:	f000 81b0 	beq.w	8017072 <cblas_ctrmm+0x5ba>
 8016d12:	465c      	mov	r4, fp
 8016d14:	f04f 0870 	mov.w	r8, #112	; 0x70
 8016d18:	469b      	mov	fp, r3
 8016d1a:	e734      	b.n	8016b86 <cblas_ctrmm+0xce>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8016d1c:	2b00      	cmp	r3, #0
 8016d1e:	f43f af1c 	beq.w	8016b5a <cblas_ctrmm+0xa2>
 8016d22:	e715      	b.n	8016b50 <cblas_ctrmm+0x98>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8016d24:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8016d28:	f000 8324 	beq.w	8017374 <cblas_ctrmm+0x8bc>
      for (i = 0; i < n1; i++) {
 8016d2c:	2c00      	cmp	r4, #0
 8016d2e:	ddd4      	ble.n	8016cda <cblas_ctrmm+0x222>
 8016d30:	9b02      	ldr	r3, [sp, #8]
 8016d32:	9406      	str	r4, [sp, #24]
 8016d34:	3b08      	subs	r3, #8
 8016d36:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8016d3a:	9307      	str	r3, [sp, #28]
 8016d3c:	9b01      	ldr	r3, [sp, #4]
 8016d3e:	00db      	lsls	r3, r3, #3
 8016d40:	9305      	str	r3, [sp, #20]
 8016d42:	9b03      	ldr	r3, [sp, #12]
 8016d44:	f106 0801 	add.w	r8, r6, #1
 8016d48:	2200      	movs	r2, #0
 8016d4a:	00f6      	lsls	r6, r6, #3
 8016d4c:	9204      	str	r2, [sp, #16]
 8016d4e:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8016d52:	f106 0908 	add.w	r9, r6, #8
 8016d56:	eb03 0acb 	add.w	sl, r3, fp, lsl #3
 8016d5a:	4696      	mov	lr, r2
        for (j = 0; j < n2; j++) {
 8016d5c:	f1bb 0f00 	cmp.w	fp, #0
 8016d60:	dd67      	ble.n	8016e32 <cblas_ctrmm+0x37a>
 8016d62:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 8016d66:	9f02      	ldr	r7, [sp, #8]
 8016d68:	9907      	ldr	r1, [sp, #28]
          if (nonunit) {
 8016d6a:	2d83      	cmp	r5, #131	; 0x83
 8016d6c:	eb03 00c2 	add.w	r0, r3, r2, lsl #3
 8016d70:	f107 0c04 	add.w	ip, r7, #4
        for (j = 0; j < n2; j++) {
 8016d74:	f04f 0400 	mov.w	r4, #0
          if (nonunit) {
 8016d78:	d038      	beq.n	8016dec <cblas_ctrmm+0x334>
          for (k = j + 1; k < n2; k++) {
 8016d7a:	3401      	adds	r4, #1
 8016d7c:	45a3      	cmp	fp, r4
            temp_real = REAL(B, i * ldb + j);
 8016d7e:	edd0 3a00 	vldr	s7, [r0]
            temp_imag = IMAG(B, i * ldb + j);
 8016d82:	ed90 4a01 	vldr	s8, [r0, #4]
          for (k = j + 1; k < n2; k++) {
 8016d86:	d048      	beq.n	8016e1a <cblas_ctrmm+0x362>
 8016d88:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 8016d8c:	4602      	mov	r2, r0
 8016d8e:	463b      	mov	r3, r7
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8016d90:	edd3 7a03 	vldr	s15, [r3, #12]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8016d94:	edd2 5a03 	vldr	s11, [r2, #12]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8016d98:	edd2 4a02 	vldr	s9, [r2, #8]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8016d9c:	ed93 5a02 	vldr	s10, [r3, #8]
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8016da0:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8016da4:	3308      	adds	r3, #8
 8016da6:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8016daa:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8016dae:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = j + 1; k < n2; k++) {
 8016db2:	4299      	cmp	r1, r3
 8016db4:	f102 0208 	add.w	r2, r2, #8
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8016db8:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8016dbc:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8016dc0:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = j + 1; k < n2; k++) {
 8016dc4:	d1e4      	bne.n	8016d90 <cblas_ctrmm+0x2d8>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016dc6:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016dca:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016dce:	eea3 6aa6 	vfma.f32	s12, s7, s13
          if (nonunit) {
 8016dd2:	2d83      	cmp	r5, #131	; 0x83
 8016dd4:	4447      	add	r7, r8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016dd6:	eee4 7a26 	vfma.f32	s15, s8, s13
 8016dda:	4431      	add	r1, r6
 8016ddc:	44cc      	add	ip, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016dde:	ed80 6a00 	vstr	s12, [r0]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016de2:	edc0 7a01 	vstr	s15, [r0, #4]
        for (j = 0; j < n2; j++) {
 8016de6:	f100 0008 	add.w	r0, r0, #8
          if (nonunit) {
 8016dea:	d1c6      	bne.n	8016d7a <cblas_ctrmm+0x2c2>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8016dec:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8016df0:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8016df4:	edd0 7a01 	vldr	s15, [r0, #4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8016df8:	edd0 5a00 	vldr	s11, [r0]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8016dfc:	ed1c 6a01 	vldr	s12, [ip, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8016e00:	ee24 4a05 	vmul.f32	s8, s8, s10
          for (k = j + 1; k < n2; k++) {
 8016e04:	3401      	adds	r4, #1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8016e06:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8016e0a:	ee24 4a25 	vmul.f32	s8, s8, s11
          for (k = j + 1; k < n2; k++) {
 8016e0e:	45a3      	cmp	fp, r4
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8016e10:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8016e14:	eea6 4a27 	vfma.f32	s8, s12, s15
          for (k = j + 1; k < n2; k++) {
 8016e18:	d1b6      	bne.n	8016d88 <cblas_ctrmm+0x2d0>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016e1a:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016e1e:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016e22:	eea3 6aa6 	vfma.f32	s12, s7, s13
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016e26:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016e2a:	ed0a 6a02 	vstr	s12, [sl, #-8]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016e2e:	ed4a 7a01 	vstr	s15, [sl, #-4]
      for (i = 0; i < n1; i++) {
 8016e32:	9b05      	ldr	r3, [sp, #20]
 8016e34:	9a01      	ldr	r2, [sp, #4]
 8016e36:	449a      	add	sl, r3
 8016e38:	9b04      	ldr	r3, [sp, #16]
 8016e3a:	4413      	add	r3, r2
 8016e3c:	9304      	str	r3, [sp, #16]
 8016e3e:	9b06      	ldr	r3, [sp, #24]
 8016e40:	f10e 0e01 	add.w	lr, lr, #1
 8016e44:	4573      	cmp	r3, lr
 8016e46:	d189      	bne.n	8016d5c <cblas_ctrmm+0x2a4>
 8016e48:	e747      	b.n	8016cda <cblas_ctrmm+0x222>
 8016e4a:	bf00      	nop
 8016e4c:	08030378 	.word	0x08030378
 8016e50:	08030784 	.word	0x08030784
 8016e54:	080305a8 	.word	0x080305a8
 8016e58:	00000000 	.word	0x00000000
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8016e5c:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8016e60:	f000 8312 	beq.w	8017488 <cblas_ctrmm+0x9d0>
      for (i = 0; i < n1; i++) {
 8016e64:	2c00      	cmp	r4, #0
 8016e66:	f77f af38 	ble.w	8016cda <cblas_ctrmm+0x222>
 8016e6a:	9b02      	ldr	r3, [sp, #8]
 8016e6c:	f10b 32ff 	add.w	r2, fp, #4294967295
 8016e70:	fb02 b706 	mla	r7, r2, r6, fp
 8016e74:	1c71      	adds	r1, r6, #1
 8016e76:	f1a3 0008 	sub.w	r0, r3, #8
 8016e7a:	ebc6 7946 	rsb	r9, r6, r6, lsl #29
 8016e7e:	43f3      	mvns	r3, r6
 8016e80:	9e01      	ldr	r6, [sp, #4]
 8016e82:	00f6      	lsls	r6, r6, #3
 8016e84:	9601      	str	r6, [sp, #4]
 8016e86:	e9dd 6802 	ldrd	r6, r8, [sp, #8]
 8016e8a:	00c9      	lsls	r1, r1, #3
 8016e8c:	f1a1 0c08 	sub.w	ip, r1, #8
 8016e90:	fb02 6c0c 	mla	ip, r2, ip, r6
 8016e94:	9e02      	ldr	r6, [sp, #8]
 8016e96:	f8cd c014 	str.w	ip, [sp, #20]
 8016e9a:	fb02 6201 	mla	r2, r2, r1, r6
 8016e9e:	9203      	str	r2, [sp, #12]
 8016ea0:	ea4f 0ec3 	mov.w	lr, r3, lsl #3
 8016ea4:	eb00 02c7 	add.w	r2, r0, r7, lsl #3
 8016ea8:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8016eac:	9204      	str	r2, [sp, #16]
 8016eae:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8016eb2:	9302      	str	r3, [sp, #8]
 8016eb4:	f04f 0a00 	mov.w	sl, #0
        for (j = n2; j > 0 && j--;) {
 8016eb8:	f1bb 0f00 	cmp.w	fp, #0
 8016ebc:	dd4f      	ble.n	8016f5e <cblas_ctrmm+0x4a6>
 8016ebe:	9b02      	ldr	r3, [sp, #8]
 8016ec0:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8016ec4:	e9dd 1704 	ldrd	r1, r7, [sp, #16]
 8016ec8:	eb08 0003 	add.w	r0, r8, r3
 8016ecc:	465e      	mov	r6, fp
          BASE temp_imag = 0.0;
 8016ece:	ed1f 4a1e 	vldr	s8, [pc, #-120]	; 8016e58 <cblas_ctrmm+0x3a0>
          for (k = 0; k < j; k++) {
 8016ed2:	3e01      	subs	r6, #1
          BASE temp_real = 0.0;
 8016ed4:	bf08      	it	eq
 8016ed6:	eef0 3a44 	vmoveq.f32	s7, s8
          for (k = 0; k < j; k++) {
 8016eda:	d020      	beq.n	8016f1e <cblas_ctrmm+0x466>
 8016edc:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 8016ee0:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < j; k++) {
 8016ee4:	4642      	mov	r2, r8
 8016ee6:	463b      	mov	r3, r7
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8016ee8:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8016eec:	edd2 5a01 	vldr	s11, [r2, #4]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8016ef0:	edd2 4a00 	vldr	s9, [r2]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8016ef4:	ed93 5a00 	vldr	s10, [r3]
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8016ef8:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8016efc:	3308      	adds	r3, #8
 8016efe:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8016f02:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8016f06:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < j; k++) {
 8016f0a:	4299      	cmp	r1, r3
 8016f0c:	f102 0208 	add.w	r2, r2, #8
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8016f10:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8016f14:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8016f18:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < j; k++) {
 8016f1c:	d1e4      	bne.n	8016ee8 <cblas_ctrmm+0x430>
          if (nonunit) {
 8016f1e:	2d83      	cmp	r5, #131	; 0x83
 8016f20:	f000 80b6 	beq.w	8017090 <cblas_ctrmm+0x5d8>
            temp_real += REAL(B, i * ldb + j);
 8016f24:	ed10 6a02 	vldr	s12, [r0, #-8]
            temp_imag += IMAG(B, i * ldb + j);
 8016f28:	ed50 7a01 	vldr	s15, [r0, #-4]
            temp_real += REAL(B, i * ldb + j);
 8016f2c:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 8016f30:	ee34 4a27 	vadd.f32	s8, s8, s15
 8016f34:	f1a0 0308 	sub.w	r3, r0, #8
 8016f38:	1f02      	subs	r2, r0, #4
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016f3a:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016f3e:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016f42:	eea3 6aa6 	vfma.f32	s12, s7, s13
 8016f46:	44f4      	add	ip, lr
 8016f48:	444f      	add	r7, r9
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016f4a:	eee4 7a26 	vfma.f32	s15, s8, s13
 8016f4e:	4471      	add	r1, lr
 8016f50:	4618      	mov	r0, r3
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8016f52:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8016f56:	edc2 7a00 	vstr	s15, [r2]
        for (j = n2; j > 0 && j--;) {
 8016f5a:	2e00      	cmp	r6, #0
 8016f5c:	d1b7      	bne.n	8016ece <cblas_ctrmm+0x416>
      for (i = 0; i < n1; i++) {
 8016f5e:	9b01      	ldr	r3, [sp, #4]
 8016f60:	f10a 0a01 	add.w	sl, sl, #1
 8016f64:	4554      	cmp	r4, sl
 8016f66:	4498      	add	r8, r3
 8016f68:	d1a6      	bne.n	8016eb8 <cblas_ctrmm+0x400>
 8016f6a:	e6b6      	b.n	8016cda <cblas_ctrmm+0x222>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8016f6c:	2c01      	cmp	r4, #1
 8016f6e:	9901      	ldr	r1, [sp, #4]
 8016f70:	4622      	mov	r2, r4
 8016f72:	bfb8      	it	lt
 8016f74:	2201      	movlt	r2, #1
 8016f76:	428a      	cmp	r2, r1
 8016f78:	dd7e      	ble.n	8017078 <cblas_ctrmm+0x5c0>
 8016f7a:	230c      	movs	r3, #12
 8016f7c:	e6bb      	b.n	8016cf6 <cblas_ctrmm+0x23e>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8016f7e:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8016f82:	f000 80d1 	beq.w	8017128 <cblas_ctrmm+0x670>
      for (i = n1; i > 0 && i--;) {
 8016f86:	2c00      	cmp	r4, #0
 8016f88:	f77f aea7 	ble.w	8016cda <cblas_ctrmm+0x222>
 8016f8c:	9b01      	ldr	r3, [sp, #4]
 8016f8e:	9a03      	ldr	r2, [sp, #12]
 8016f90:	1e60      	subs	r0, r4, #1
 8016f92:	00df      	lsls	r7, r3, #3
 8016f94:	ebc3 7343 	rsb	r3, r3, r3, lsl #29
 8016f98:	fb00 2807 	mla	r8, r0, r7, r2
 8016f9c:	00db      	lsls	r3, r3, #3
 8016f9e:	9a02      	ldr	r2, [sp, #8]
 8016fa0:	9303      	str	r3, [sp, #12]
 8016fa2:	f106 0c01 	add.w	ip, r6, #1
 8016fa6:	43f6      	mvns	r6, r6
 8016fa8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8016fac:	f108 0904 	add.w	r9, r8, #4
 8016fb0:	fb00 f803 	mul.w	r8, r0, r3
 8016fb4:	00f3      	lsls	r3, r6, #3
 8016fb6:	fb00 2a0c 	mla	sl, r0, ip, r2
 8016fba:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
 8016fbe:	f1ac 0c08 	sub.w	ip, ip, #8
 8016fc2:	9301      	str	r3, [sp, #4]
        for (j = 0; j < n2; j++) {
 8016fc4:	f1bb 0f00 	cmp.w	fp, #0
 8016fc8:	dd48      	ble.n	801705c <cblas_ctrmm+0x5a4>
 8016fca:	464e      	mov	r6, r9
 8016fcc:	f04f 0e00 	mov.w	lr, #0
          BASE temp_imag = 0.0;
 8016fd0:	ed1f 4a5f 	vldr	s8, [pc, #-380]	; 8016e58 <cblas_ctrmm+0x3a0>
          BASE temp_real = 0.0;
 8016fd4:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < i; k++) {
 8016fd8:	b310      	cbz	r0, 8017020 <cblas_ctrmm+0x568>
 8016fda:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 8016fde:	eef0 3a44 	vmov.f32	s7, s8
 8016fe2:	eb08 0206 	add.w	r2, r8, r6
          for (k = 0; k < i; k++) {
 8016fe6:	4623      	mov	r3, r4
 8016fe8:	2100      	movs	r1, #0
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8016fea:	ed53 7a01 	vldr	s15, [r3, #-4]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8016fee:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8016ff2:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8016ff6:	ed13 5a02 	vldr	s10, [r3, #-8]
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8016ffa:	ee63 7a27 	vmul.f32	s15, s6, s15
          for (k = 0; k < i; k++) {
 8016ffe:	3101      	adds	r1, #1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017000:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017004:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017008:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < i; k++) {
 801700c:	4288      	cmp	r0, r1
 801700e:	443a      	add	r2, r7
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8017010:	eee5 7a25 	vfma.f32	s15, s10, s11
 8017014:	4463      	add	r3, ip
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8017016:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 801701a:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < i; k++) {
 801701e:	d1e4      	bne.n	8016fea <cblas_ctrmm+0x532>
          if (nonunit) {
 8017020:	2d83      	cmp	r5, #131	; 0x83
 8017022:	d051      	beq.n	80170c8 <cblas_ctrmm+0x610>
            temp_real += REAL(B, i * ldb + j);
 8017024:	ed16 6a01 	vldr	s12, [r6, #-4]
            temp_imag += IMAG(B, i * ldb + j);
 8017028:	edd6 7a00 	vldr	s15, [r6]
            temp_real += REAL(B, i * ldb + j);
 801702c:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 8017030:	ee34 4a27 	vadd.f32	s8, s8, s15
 8017034:	1f33      	subs	r3, r6, #4
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017036:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 801703a:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801703e:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8017042:	f10e 0e01 	add.w	lr, lr, #1
 8017046:	45f3      	cmp	fp, lr
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017048:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801704c:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017050:	4633      	mov	r3, r6
 8017052:	edc3 7a00 	vstr	s15, [r3]
 8017056:	f106 0608 	add.w	r6, r6, #8
        for (j = 0; j < n2; j++) {
 801705a:	d1b9      	bne.n	8016fd0 <cblas_ctrmm+0x518>
      for (i = n1; i > 0 && i--;) {
 801705c:	9b01      	ldr	r3, [sp, #4]
 801705e:	449a      	add	sl, r3
 8017060:	9b03      	ldr	r3, [sp, #12]
 8017062:	3c08      	subs	r4, #8
 8017064:	4499      	add	r9, r3
 8017066:	44b8      	add	r8, r7
 8017068:	2800      	cmp	r0, #0
 801706a:	f43f ae36 	beq.w	8016cda <cblas_ctrmm+0x222>
 801706e:	3801      	subs	r0, #1
 8017070:	e7a8      	b.n	8016fc4 <cblas_ctrmm+0x50c>
 8017072:	465c      	mov	r4, fp
 8017074:	469b      	mov	fp, r3
 8017076:	e586      	b.n	8016b86 <cblas_ctrmm+0xce>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017078:	2b00      	cmp	r3, #0
 801707a:	f43f ae41 	beq.w	8016d00 <cblas_ctrmm+0x248>
 801707e:	e63a      	b.n	8016cf6 <cblas_ctrmm+0x23e>
 8017080:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8017084:	2b01      	cmp	r3, #1
 8017086:	bf94      	ite	ls
 8017088:	2300      	movls	r3, #0
 801708a:	2301      	movhi	r3, #1
 801708c:	46a4      	mov	ip, r4
 801708e:	e535      	b.n	8016afc <cblas_ctrmm+0x44>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017090:	ed9c 6a01 	vldr	s12, [ip, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017094:	ed50 5a01 	vldr	s11, [r0, #-4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017098:	ed50 4a02 	vldr	s9, [r0, #-8]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801709c:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80170a0:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 80170a4:	f1a0 0308 	sub.w	r3, r0, #8
 80170a8:	ee67 7a86 	vmul.f32	s15, s15, s12
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80170ac:	1f02      	subs	r2, r0, #4
 80170ae:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80170b2:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80170b6:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80170ba:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80170be:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80170c2:	ee37 4a84 	vadd.f32	s8, s15, s8
 80170c6:	e738      	b.n	8016f3a <cblas_ctrmm+0x482>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80170c8:	ed9a 6a01 	vldr	s12, [sl, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 80170cc:	edd6 5a00 	vldr	s11, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 80170d0:	ed56 4a01 	vldr	s9, [r6, #-4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 80170d4:	ed9a 5a00 	vldr	s10, [sl]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80170d8:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 80170dc:	1f33      	subs	r3, r6, #4
 80170de:	ee67 7a86 	vmul.f32	s15, s15, s12
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80170e2:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80170e6:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80170ea:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80170ee:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80170f2:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80170f6:	ee37 4a84 	vadd.f32	s8, s15, s8
 80170fa:	e79c      	b.n	8017036 <cblas_ctrmm+0x57e>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80170fc:	edda 5a01 	vldr	s11, [sl, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017100:	edd7 7a01 	vldr	s15, [r7, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8017104:	ed9a 6a00 	vldr	s12, [sl]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017108:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
            const BASE Bij_real = REAL(B, i * ldb + j);
 801710c:	46bc      	mov	ip, r7
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 801710e:	ee24 4a25 	vmul.f32	s8, s8, s11
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017112:	ecfc 5a01 	vldmia	ip!, {s11}
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017116:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 801711a:	ee24 4a25 	vmul.f32	s8, s8, s11
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 801711e:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017122:	eea6 4a27 	vfma.f32	s8, s12, s15
 8017126:	e592      	b.n	8016c4e <cblas_ctrmm+0x196>
      for (i = 0; i < n1; i++) {
 8017128:	2c00      	cmp	r4, #0
 801712a:	f77f add6 	ble.w	8016cda <cblas_ctrmm+0x222>
 801712e:	3601      	adds	r6, #1
 8017130:	00f3      	lsls	r3, r6, #3
 8017132:	f8dd e008 	ldr.w	lr, [sp, #8]
 8017136:	9306      	str	r3, [sp, #24]
 8017138:	3b08      	subs	r3, #8
 801713a:	9305      	str	r3, [sp, #20]
 801713c:	9b01      	ldr	r3, [sp, #4]
 801713e:	9302      	str	r3, [sp, #8]
 8017140:	f1ae 0108 	sub.w	r1, lr, #8
 8017144:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 8017148:	00d8      	lsls	r0, r3, #3
 801714a:	f04f 0a00 	mov.w	sl, #0
 801714e:	f04f 0901 	mov.w	r9, #1
        for (j = 0; j < n2; j++) {
 8017152:	f1bb 0f00 	cmp.w	fp, #0
 8017156:	bfd8      	it	le
 8017158:	f8cd 9010 	strle.w	r9, [sp, #16]
 801715c:	dd48      	ble.n	80171f0 <cblas_ctrmm+0x738>
 801715e:	9b02      	ldr	r3, [sp, #8]
 8017160:	f8cd 9010 	str.w	r9, [sp, #16]
 8017164:	eba3 080a 	sub.w	r8, r3, sl
 8017168:	9b03      	ldr	r3, [sp, #12]
 801716a:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 801716e:	f108 0804 	add.w	r8, r8, #4
 8017172:	eb03 06ca 	add.w	r6, r3, sl, lsl #3
 8017176:	f04f 0c00 	mov.w	ip, #0
          if (nonunit) {
 801717a:	2d83      	cmp	r5, #131	; 0x83
 801717c:	d048      	beq.n	8017210 <cblas_ctrmm+0x758>
            temp_real = REAL(B, i * ldb + j);
 801717e:	4637      	mov	r7, r6
 8017180:	ecf7 3a01 	vldmia	r7!, {s7}
            temp_imag = IMAG(B, i * ldb + j);
 8017184:	ed96 4a01 	vldr	s8, [r6, #4]
          for (k = i + 1; k < n1; k++) {
 8017188:	454c      	cmp	r4, r9
 801718a:	dd1e      	ble.n	80171ca <cblas_ctrmm+0x712>
 801718c:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 8017190:	eb08 0206 	add.w	r2, r8, r6
 8017194:	4673      	mov	r3, lr
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017196:	edd3 7a03 	vldr	s15, [r3, #12]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 801719a:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 801719e:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80171a2:	ed93 5a02 	vldr	s10, [r3, #8]
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80171a6:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80171aa:	3308      	adds	r3, #8
 80171ac:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80171b0:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80171b4:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = i + 1; k < n1; k++) {
 80171b8:	4299      	cmp	r1, r3
 80171ba:	4402      	add	r2, r0
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80171bc:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80171c0:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80171c4:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = i + 1; k < n1; k++) {
 80171c8:	d1e5      	bne.n	8017196 <cblas_ctrmm+0x6de>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80171ca:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80171ce:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80171d2:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 80171d6:	f10c 0c01 	add.w	ip, ip, #1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80171da:	4633      	mov	r3, r6
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80171dc:	eee4 7a26 	vfma.f32	s15, s8, s13
        for (j = 0; j < n2; j++) {
 80171e0:	45e3      	cmp	fp, ip
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80171e2:	f106 0608 	add.w	r6, r6, #8
 80171e6:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80171ea:	edc7 7a00 	vstr	s15, [r7]
        for (j = 0; j < n2; j++) {
 80171ee:	d1c4      	bne.n	801717a <cblas_ctrmm+0x6c2>
      for (i = 0; i < n1; i++) {
 80171f0:	9b06      	ldr	r3, [sp, #24]
 80171f2:	9a02      	ldr	r2, [sp, #8]
 80171f4:	449e      	add	lr, r3
 80171f6:	9b05      	ldr	r3, [sp, #20]
 80171f8:	4419      	add	r1, r3
 80171fa:	9b01      	ldr	r3, [sp, #4]
 80171fc:	4616      	mov	r6, r2
 80171fe:	441e      	add	r6, r3
 8017200:	449a      	add	sl, r3
 8017202:	9b04      	ldr	r3, [sp, #16]
 8017204:	9602      	str	r6, [sp, #8]
 8017206:	429c      	cmp	r4, r3
 8017208:	f109 0901 	add.w	r9, r9, #1
 801720c:	dca1      	bgt.n	8017152 <cblas_ctrmm+0x69a>
 801720e:	e564      	b.n	8016cda <cblas_ctrmm+0x222>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017210:	edde 5a01 	vldr	s11, [lr, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017214:	edd6 7a01 	vldr	s15, [r6, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8017218:	ed9e 6a00 	vldr	s12, [lr]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 801721c:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017220:	4637      	mov	r7, r6
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017222:	ee24 4a25 	vmul.f32	s8, s8, s11
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017226:	ecf7 5a01 	vldmia	r7!, {s11}
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 801722a:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 801722e:	ee24 4a25 	vmul.f32	s8, s8, s11
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017232:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017236:	eea6 4a27 	vfma.f32	s8, s12, s15
 801723a:	e7a5      	b.n	8017188 <cblas_ctrmm+0x6d0>
      for (i = n1; i > 0 && i--;) {
 801723c:	2c00      	cmp	r4, #0
 801723e:	f77f ad4c 	ble.w	8016cda <cblas_ctrmm+0x222>
 8017242:	9b01      	ldr	r3, [sp, #4]
 8017244:	00da      	lsls	r2, r3, #3
 8017246:	9204      	str	r2, [sp, #16]
 8017248:	ebc3 7e43 	rsb	lr, r3, r3, lsl #29
 801724c:	e9dd 7303 	ldrd	r7, r3, [sp, #12]
 8017250:	1e60      	subs	r0, r4, #1
 8017252:	9a02      	ldr	r2, [sp, #8]
 8017254:	f106 0a01 	add.w	sl, r6, #1
 8017258:	fb00 7803 	mla	r8, r0, r3, r7
 801725c:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 8017260:	ea4f 03ce 	mov.w	r3, lr, lsl #3
 8017264:	fb06 4400 	mla	r4, r6, r0, r4
 8017268:	ea6f 0906 	mvn.w	r9, r6
 801726c:	ebc6 7646 	rsb	r6, r6, r6, lsl #29
 8017270:	f1aa 0c08 	sub.w	ip, sl, #8
 8017274:	f1a2 0108 	sub.w	r1, r2, #8
 8017278:	9301      	str	r3, [sp, #4]
 801727a:	fb00 fe03 	mul.w	lr, r0, r3
 801727e:	9f04      	ldr	r7, [sp, #16]
 8017280:	00f3      	lsls	r3, r6, #3
 8017282:	fb00 2c0c 	mla	ip, r0, ip, r2
 8017286:	fb00 2a0a 	mla	sl, r0, sl, r2
 801728a:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 801728e:	f108 0804 	add.w	r8, r8, #4
 8017292:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8017296:	9302      	str	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 8017298:	f1bb 0f00 	cmp.w	fp, #0
 801729c:	dd44      	ble.n	8017328 <cblas_ctrmm+0x870>
 801729e:	4644      	mov	r4, r8
 80172a0:	2600      	movs	r6, #0
          BASE temp_imag = 0.0;
 80172a2:	ed9f 4abf 	vldr	s8, [pc, #764]	; 80175a0 <cblas_ctrmm+0xae8>
          BASE temp_real = 0.0;
 80172a6:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < i; k++) {
 80172aa:	b300      	cbz	r0, 80172ee <cblas_ctrmm+0x836>
 80172ac:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 80172b0:	eef0 3a44 	vmov.f32	s7, s8
 80172b4:	eb0e 0204 	add.w	r2, lr, r4
          for (k = 0; k < i; k++) {
 80172b8:	4663      	mov	r3, ip
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80172ba:	edd3 7a01 	vldr	s15, [r3, #4]
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 80172be:	edd2 5a00 	vldr	s11, [r2]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 80172c2:	ed52 4a01 	vldr	s9, [r2, #-4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80172c6:	ed93 5a00 	vldr	s10, [r3]
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80172ca:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80172ce:	3308      	adds	r3, #8
 80172d0:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80172d4:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80172d8:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < i; k++) {
 80172dc:	4299      	cmp	r1, r3
 80172de:	443a      	add	r2, r7
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80172e0:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80172e4:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80172e8:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < i; k++) {
 80172ec:	d1e5      	bne.n	80172ba <cblas_ctrmm+0x802>
          if (nonunit) {
 80172ee:	2d83      	cmp	r5, #131	; 0x83
 80172f0:	d026      	beq.n	8017340 <cblas_ctrmm+0x888>
            temp_real += REAL(B, i * ldb + j);
 80172f2:	ed14 6a01 	vldr	s12, [r4, #-4]
            temp_imag += IMAG(B, i * ldb + j);
 80172f6:	edd4 7a00 	vldr	s15, [r4]
            temp_real += REAL(B, i * ldb + j);
 80172fa:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 80172fe:	ee34 4a27 	vadd.f32	s8, s8, s15
 8017302:	1f23      	subs	r3, r4, #4
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017304:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017308:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801730c:	eea3 6aa6 	vfma.f32	s12, s7, s13
        for (j = 0; j < n2; j++) {
 8017310:	3601      	adds	r6, #1
 8017312:	45b3      	cmp	fp, r6
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017314:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017318:	ed83 6a00 	vstr	s12, [r3]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 801731c:	4623      	mov	r3, r4
 801731e:	edc3 7a00 	vstr	s15, [r3]
 8017322:	f104 0408 	add.w	r4, r4, #8
        for (j = 0; j < n2; j++) {
 8017326:	d1bc      	bne.n	80172a2 <cblas_ctrmm+0x7ea>
      for (i = n1; i > 0 && i--;) {
 8017328:	9b01      	ldr	r3, [sp, #4]
 801732a:	4498      	add	r8, r3
 801732c:	9b02      	ldr	r3, [sp, #8]
 801732e:	44ca      	add	sl, r9
 8017330:	449c      	add	ip, r3
 8017332:	4449      	add	r1, r9
 8017334:	44be      	add	lr, r7
 8017336:	2800      	cmp	r0, #0
 8017338:	f43f accf 	beq.w	8016cda <cblas_ctrmm+0x222>
 801733c:	3801      	subs	r0, #1
 801733e:	e7ab      	b.n	8017298 <cblas_ctrmm+0x7e0>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017340:	ed9a 6a01 	vldr	s12, [sl, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017344:	edd4 5a00 	vldr	s11, [r4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017348:	ed54 4a01 	vldr	s9, [r4, #-4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 801734c:	ed9a 5a00 	vldr	s10, [sl]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8017350:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8017354:	1f23      	subs	r3, r4, #4
 8017356:	ee67 7a86 	vmul.f32	s15, s15, s12
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 801735a:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 801735e:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8017362:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8017366:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 801736a:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 801736e:	ee37 4a84 	vadd.f32	s8, s15, s8
 8017372:	e7c7      	b.n	8017304 <cblas_ctrmm+0x84c>
      for (i = 0; i < n1; i++) {
 8017374:	2c00      	cmp	r4, #0
 8017376:	f77f acb0 	ble.w	8016cda <cblas_ctrmm+0x222>
 801737a:	9901      	ldr	r1, [sp, #4]
 801737c:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8017380:	1c70      	adds	r0, r6, #1
 8017382:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
 8017386:	9902      	ldr	r1, [sp, #8]
 8017388:	00c0      	lsls	r0, r0, #3
 801738a:	f10b 32ff 	add.w	r2, fp, #4294967295
 801738e:	fb00 1202 	mla	r2, r0, r2, r1
 8017392:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8017396:	43f6      	mvns	r6, r6
 8017398:	9202      	str	r2, [sp, #8]
 801739a:	3b08      	subs	r3, #8
 801739c:	eb01 02cb 	add.w	r2, r1, fp, lsl #3
 80173a0:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 80173a4:	3808      	subs	r0, #8
 80173a6:	9201      	str	r2, [sp, #4]
 80173a8:	9303      	str	r3, [sp, #12]
 80173aa:	f04f 0a00 	mov.w	sl, #0
        for (j = n2; j > 0 && j--;) {
 80173ae:	f1bb 0f00 	cmp.w	fp, #0
 80173b2:	dd49      	ble.n	8017448 <cblas_ctrmm+0x990>
 80173b4:	9b03      	ldr	r3, [sp, #12]
 80173b6:	e9dd 7c01 	ldrd	r7, ip, [sp, #4]
 80173ba:	eb03 0108 	add.w	r1, r3, r8
 80173be:	465e      	mov	r6, fp
          BASE temp_imag = 0.0;
 80173c0:	ed9f 4a77 	vldr	s8, [pc, #476]	; 80175a0 <cblas_ctrmm+0xae8>
          for (k = 0; k < j; k++) {
 80173c4:	3e01      	subs	r6, #1
          BASE temp_real = 0.0;
 80173c6:	bf08      	it	eq
 80173c8:	eef0 3a44 	vmoveq.f32	s7, s8
          for (k = 0; k < j; k++) {
 80173cc:	d01f      	beq.n	801740e <cblas_ctrmm+0x956>
 80173ce:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
          BASE temp_real = 0.0;
 80173d2:	eef0 3a44 	vmov.f32	s7, s8
          for (k = 0; k < j; k++) {
 80173d6:	4643      	mov	r3, r8
 80173d8:	463a      	mov	r2, r7
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80173da:	ed52 7a01 	vldr	s15, [r2, #-4]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 80173de:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bik_real = REAL(B, i * ldb + k);
 80173e2:	edd3 4a00 	vldr	s9, [r3]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80173e6:	ed12 5a02 	vldr	s10, [r2, #-8]
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80173ea:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80173ee:	3308      	adds	r3, #8
 80173f0:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80173f4:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80173f8:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = 0; k < j; k++) {
 80173fc:	4299      	cmp	r1, r3
 80173fe:	4402      	add	r2, r0
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8017400:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8017404:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8017408:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = 0; k < j; k++) {
 801740c:	d1e5      	bne.n	80173da <cblas_ctrmm+0x922>
          if (nonunit) {
 801740e:	2d83      	cmp	r5, #131	; 0x83
 8017410:	d020      	beq.n	8017454 <cblas_ctrmm+0x99c>
            temp_real += REAL(B, i * ldb + j);
 8017412:	460b      	mov	r3, r1
 8017414:	ecb3 6a01 	vldmia	r3!, {s12}
            temp_imag += IMAG(B, i * ldb + j);
 8017418:	edd1 7a01 	vldr	s15, [r1, #4]
            temp_real += REAL(B, i * ldb + j);
 801741c:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += IMAG(B, i * ldb + j);
 8017420:	ee34 4a27 	vadd.f32	s8, s8, s15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017424:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017428:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801742c:	eea3 6aa6 	vfma.f32	s12, s7, s13
 8017430:	460a      	mov	r2, r1
 8017432:	44cc      	add	ip, r9
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017434:	eee4 7a26 	vfma.f32	s15, s8, s13
 8017438:	3f08      	subs	r7, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801743a:	3908      	subs	r1, #8
 801743c:	ed82 6a00 	vstr	s12, [r2]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017440:	edc3 7a00 	vstr	s15, [r3]
        for (j = n2; j > 0 && j--;) {
 8017444:	2e00      	cmp	r6, #0
 8017446:	d1bb      	bne.n	80173c0 <cblas_ctrmm+0x908>
      for (i = 0; i < n1; i++) {
 8017448:	f10a 0a01 	add.w	sl, sl, #1
 801744c:	4554      	cmp	r4, sl
 801744e:	44f0      	add	r8, lr
 8017450:	d1ad      	bne.n	80173ae <cblas_ctrmm+0x8f6>
 8017452:	e442      	b.n	8016cda <cblas_ctrmm+0x222>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017454:	ed9c 6a01 	vldr	s12, [ip, #4]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8017458:	edd1 5a01 	vldr	s11, [r1, #4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801745c:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017460:	eef8 7ac8 	vcvt.f32.s32	s15, s16
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017464:	460b      	mov	r3, r1
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017466:	ee67 7a86 	vmul.f32	s15, s15, s12
            const BASE Bij_real = REAL(B, i * ldb + j);
 801746a:	ecf3 4a01 	vldmia	r3!, {s9}
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 801746e:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017472:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017476:	eea5 6a24 	vfma.f32	s12, s10, s9
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 801747a:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 801747e:	ee76 3a23 	vadd.f32	s7, s12, s7
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017482:	ee37 4a84 	vadd.f32	s8, s15, s8
 8017486:	e7cd      	b.n	8017424 <cblas_ctrmm+0x96c>
      for (i = 0; i < n1; i++) {
 8017488:	2c00      	cmp	r4, #0
 801748a:	f77f ac26 	ble.w	8016cda <cblas_ctrmm+0x222>
 801748e:	00f0      	lsls	r0, r6, #3
 8017490:	9a02      	ldr	r2, [sp, #8]
 8017492:	1d03      	adds	r3, r0, #4
 8017494:	18d3      	adds	r3, r2, r3
 8017496:	9306      	str	r3, [sp, #24]
 8017498:	9b03      	ldr	r3, [sp, #12]
 801749a:	f10b 31ff 	add.w	r1, fp, #4294967295
 801749e:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 80174a2:	9b01      	ldr	r3, [sp, #4]
 80174a4:	00db      	lsls	r3, r3, #3
 80174a6:	e9cd 3404 	strd	r3, r4, [sp, #16]
 80174aa:	3601      	adds	r6, #1
 80174ac:	f04f 0a00 	mov.w	sl, #0
 80174b0:	ea4f 08c6 	mov.w	r8, r6, lsl #3
 80174b4:	f100 0908 	add.w	r9, r0, #8
 80174b8:	46d6      	mov	lr, sl
        for (j = 0; j < n2; j++) {
 80174ba:	f1bb 0f00 	cmp.w	fp, #0
 80174be:	dd64      	ble.n	801758a <cblas_ctrmm+0xad2>
 80174c0:	9b03      	ldr	r3, [sp, #12]
 80174c2:	9f06      	ldr	r7, [sp, #24]
 80174c4:	eb03 04ca 	add.w	r4, r3, sl, lsl #3
 80174c8:	9b02      	ldr	r3, [sp, #8]
          if (nonunit) {
 80174ca:	2d83      	cmp	r5, #131	; 0x83
 80174cc:	f103 0c04 	add.w	ip, r3, #4
        for (j = 0; j < n2; j++) {
 80174d0:	f04f 0600 	mov.w	r6, #0
          if (nonunit) {
 80174d4:	d036      	beq.n	8017544 <cblas_ctrmm+0xa8c>
          for (k = j + 1; k < n2; k++) {
 80174d6:	3601      	adds	r6, #1
 80174d8:	45b3      	cmp	fp, r6
            temp_real = REAL(B, i * ldb + j);
 80174da:	edd4 3a00 	vldr	s7, [r4]
            temp_imag = IMAG(B, i * ldb + j);
 80174de:	ed94 4a01 	vldr	s8, [r4, #4]
          for (k = j + 1; k < n2; k++) {
 80174e2:	d046      	beq.n	8017572 <cblas_ctrmm+0xaba>
 80174e4:	eeb8 3ac8 	vcvt.f32.s32	s6, s16
 80174e8:	463a      	mov	r2, r7
 80174ea:	4623      	mov	r3, r4
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80174ec:	edd2 7a00 	vldr	s15, [r2]
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 80174f0:	edd3 5a03 	vldr	s11, [r3, #12]
            const BASE Bik_real = REAL(B, i * ldb + k);
 80174f4:	edd3 4a02 	vldr	s9, [r3, #8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80174f8:	ed12 5a01 	vldr	s10, [r2, #-4]
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80174fc:	ee63 7a27 	vmul.f32	s15, s6, s15
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8017500:	3308      	adds	r3, #8
 8017502:	ee25 6ae7 	vnmul.f32	s12, s11, s15
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8017506:	ee67 7aa4 	vmul.f32	s15, s15, s9
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 801750a:	eea5 6a24 	vfma.f32	s12, s10, s9
          for (k = j + 1; k < n2; k++) {
 801750e:	428b      	cmp	r3, r1
 8017510:	4402      	add	r2, r0
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8017512:	eee5 7a25 	vfma.f32	s15, s10, s11
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8017516:	ee73 3a86 	vadd.f32	s7, s7, s12
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 801751a:	ee34 4a27 	vadd.f32	s8, s8, s15
          for (k = j + 1; k < n2; k++) {
 801751e:	d1e5      	bne.n	80174ec <cblas_ctrmm+0xa34>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017520:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017524:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017528:	eea3 6aa6 	vfma.f32	s12, s7, s13
          if (nonunit) {
 801752c:	2d83      	cmp	r5, #131	; 0x83
 801752e:	4447      	add	r7, r8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017530:	eee4 7a26 	vfma.f32	s15, s8, s13
 8017534:	44cc      	add	ip, r9
 8017536:	f104 0408 	add.w	r4, r4, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801753a:	ed04 6a02 	vstr	s12, [r4, #-8]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 801753e:	ed44 7a01 	vstr	s15, [r4, #-4]
          if (nonunit) {
 8017542:	d1c8      	bne.n	80174d6 <cblas_ctrmm+0xa1e>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017544:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8017548:	ed9c 5a00 	vldr	s10, [ip]
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 801754c:	edd4 7a01 	vldr	s15, [r4, #4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8017550:	edd4 5a00 	vldr	s11, [r4]
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8017554:	ed1c 6a01 	vldr	s12, [ip, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8017558:	ee24 4a05 	vmul.f32	s8, s8, s10
          for (k = j + 1; k < n2; k++) {
 801755c:	3601      	adds	r6, #1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 801755e:	ee67 3ac4 	vnmul.f32	s7, s15, s8
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8017562:	ee24 4a25 	vmul.f32	s8, s8, s11
          for (k = j + 1; k < n2; k++) {
 8017566:	45b3      	cmp	fp, r6
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8017568:	eee6 3a25 	vfma.f32	s7, s12, s11
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 801756c:	eea6 4a27 	vfma.f32	s8, s12, s15
          for (k = j + 1; k < n2; k++) {
 8017570:	d1b8      	bne.n	80174e4 <cblas_ctrmm+0xa2c>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017572:	ee27 6a44 	vnmul.f32	s12, s14, s8
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017576:	ee63 7a87 	vmul.f32	s15, s7, s14
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 801757a:	eea3 6aa6 	vfma.f32	s12, s7, s13
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 801757e:	eee4 7a26 	vfma.f32	s15, s8, s13
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8017582:	ed81 6a00 	vstr	s12, [r1]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8017586:	edc1 7a01 	vstr	s15, [r1, #4]
      for (i = 0; i < n1; i++) {
 801758a:	9b04      	ldr	r3, [sp, #16]
 801758c:	4419      	add	r1, r3
 801758e:	9b01      	ldr	r3, [sp, #4]
 8017590:	449a      	add	sl, r3
 8017592:	9b05      	ldr	r3, [sp, #20]
 8017594:	f10e 0e01 	add.w	lr, lr, #1
 8017598:	4573      	cmp	r3, lr
 801759a:	d18e      	bne.n	80174ba <cblas_ctrmm+0xa02>
 801759c:	f7ff bb9d 	b.w	8016cda <cblas_ctrmm+0x222>
 80175a0:	00000000 	.word	0x00000000

080175a4 <cblas_ctrmv>:
void
cblas_ctrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 80175a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80175a8:	ed2d 8b02 	vpush	{d8}
 80175ac:	b083      	sub	sp, #12
 80175ae:	461c      	mov	r4, r3
 80175b0:	e9dd 630e 	ldrd	r6, r3, [sp, #56]	; 0x38
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 80175b4:	2a71      	cmp	r2, #113	; 0x71
 80175b6:	e9dd 9710 	ldrd	r9, r7, [sp, #64]	; 0x40
 80175ba:	9d12      	ldr	r5, [sp, #72]	; 0x48
 80175bc:	9301      	str	r3, [sp, #4]
 80175be:	4682      	mov	sl, r0
 80175c0:	468b      	mov	fp, r1
 80175c2:	f000 80c1 	beq.w	8017748 <cblas_ctrmv+0x1a4>
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
  const int nonunit = (Diag == CblasNonUnit);

  INDEX i, j;

  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80175c6:	3979      	subs	r1, #121	; 0x79
 80175c8:	2901      	cmp	r1, #1
 80175ca:	4690      	mov	r8, r2
 80175cc:	d934      	bls.n	8017638 <cblas_ctrmv+0x94>
 80175ce:	2002      	movs	r0, #2
 80175d0:	3a6f      	subs	r2, #111	; 0x6f
 80175d2:	2a02      	cmp	r2, #2
 80175d4:	ed9f 8ac9 	vldr	s16, [pc, #804]	; 80178fc <cblas_ctrmv+0x358>
 80175d8:	bf88      	it	hi
 80175da:	2003      	movhi	r0, #3
 80175dc:	f104 027d 	add.w	r2, r4, #125	; 0x7d
 80175e0:	b2d2      	uxtb	r2, r2
 80175e2:	2a01      	cmp	r2, #1
 80175e4:	d936      	bls.n	8017654 <cblas_ctrmv+0xb0>
 80175e6:	2e00      	cmp	r6, #0
 80175e8:	db2c      	blt.n	8017644 <cblas_ctrmv+0xa0>
 80175ea:	2e01      	cmp	r6, #1
 80175ec:	4632      	mov	r2, r6
 80175ee:	bfb8      	it	lt
 80175f0:	2201      	movlt	r2, #1
 80175f2:	454a      	cmp	r2, r9
 80175f4:	f340 80b2 	ble.w	801775c <cblas_ctrmv+0x1b8>
 80175f8:	2d00      	cmp	r5, #0
 80175fa:	bf0c      	ite	eq
 80175fc:	2009      	moveq	r0, #9
 80175fe:	2007      	movne	r0, #7
 8017600:	4abf      	ldr	r2, [pc, #764]	; (8017900 <cblas_ctrmv+0x35c>)
 8017602:	49c0      	ldr	r1, [pc, #768]	; (8017904 <cblas_ctrmv+0x360>)
 8017604:	f010 fa20 	bl	8027a48 <cblas_xerbla>

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8017608:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801760c:	d030      	beq.n	8017670 <cblas_ctrmv+0xcc>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 801760e:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 8017612:	d107      	bne.n	8017624 <cblas_ctrmv+0x80>
 8017614:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8017618:	f000 8168 	beq.w	80178ec <cblas_ctrmv+0x348>
        IMAG(X, ix) += temp_i;
      }
      ix -= incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 801761c:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8017620:	f000 80a1 	beq.w	8017766 <cblas_ctrmv+0x1c2>
        IMAG(X, ix) += temp_i;
      }
      ix += incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8017624:	4ab8      	ldr	r2, [pc, #736]	; (8017908 <cblas_ctrmv+0x364>)
 8017626:	49b7      	ldr	r1, [pc, #732]	; (8017904 <cblas_ctrmv+0x360>)
 8017628:	2000      	movs	r0, #0
#define BASE float
#include "source_trmv_c.h"
#undef BASE
}
 801762a:	b003      	add	sp, #12
 801762c:	ecbd 8b02 	vpop	{d8}
 8017630:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017634:	f010 ba08 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8017638:	3865      	subs	r0, #101	; 0x65
 801763a:	2801      	cmp	r0, #1
 801763c:	bf94      	ite	ls
 801763e:	2000      	movls	r0, #0
 8017640:	2001      	movhi	r0, #1
 8017642:	e7c5      	b.n	80175d0 <cblas_ctrmv+0x2c>
 8017644:	f1b9 0f00 	cmp.w	r9, #0
 8017648:	ddd6      	ble.n	80175f8 <cblas_ctrmv+0x54>
 801764a:	2d00      	cmp	r5, #0
 801764c:	bf0c      	ite	eq
 801764e:	2009      	moveq	r0, #9
 8017650:	2005      	movne	r0, #5
 8017652:	e7d5      	b.n	8017600 <cblas_ctrmv+0x5c>
 8017654:	2e00      	cmp	r6, #0
 8017656:	dbf5      	blt.n	8017644 <cblas_ctrmv+0xa0>
 8017658:	2e01      	cmp	r6, #1
 801765a:	4632      	mov	r2, r6
 801765c:	bfb8      	it	lt
 801765e:	2201      	movlt	r2, #1
 8017660:	454a      	cmp	r2, r9
 8017662:	dcc9      	bgt.n	80175f8 <cblas_ctrmv+0x54>
 8017664:	2d00      	cmp	r5, #0
 8017666:	f000 8255 	beq.w	8017b14 <cblas_ctrmv+0x570>
 801766a:	2800      	cmp	r0, #0
 801766c:	d0cc      	beq.n	8017608 <cblas_ctrmv+0x64>
 801766e:	e7c7      	b.n	8017600 <cblas_ctrmv+0x5c>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8017670:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8017674:	f000 80a7 	beq.w	80177c6 <cblas_ctrmv+0x222>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8017678:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 801767c:	d1d2      	bne.n	8017624 <cblas_ctrmv+0x80>
 801767e:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 8017682:	f000 81c4 	beq.w	8017a0e <cblas_ctrmv+0x46a>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8017686:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 801768a:	d1cb      	bne.n	8017624 <cblas_ctrmv+0x80>
    INDEX ix = OFFSET(N, incX);
 801768c:	2d00      	cmp	r5, #0
 801768e:	bfda      	itte	le
 8017690:	f1c6 0b01 	rsble	fp, r6, #1
 8017694:	fb0b fb05 	mulle.w	fp, fp, r5
 8017698:	f04f 0b00 	movgt.w	fp, #0
    for (i = 0; i < N; i++) {
 801769c:	2e00      	cmp	r6, #0
 801769e:	dd4e      	ble.n	801773e <cblas_ctrmv+0x19a>
 80176a0:	f109 0901 	add.w	r9, r9, #1
 80176a4:	9b01      	ldr	r3, [sp, #4]
 80176a6:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 80176aa:	eb07 0ecb 	add.w	lr, r7, fp, lsl #3
 80176ae:	f103 0804 	add.w	r8, r3, #4
 80176b2:	f1aa 0c08 	sub.w	ip, sl, #8
 80176b6:	f10e 0e04 	add.w	lr, lr, #4
 80176ba:	44ab      	add	fp, r5
 80176bc:	00e8      	lsls	r0, r5, #3
 80176be:	f04f 0900 	mov.w	r9, #0
      const INDEX j_min = i + 1;
 80176c2:	f109 0901 	add.w	r9, r9, #1
      for (j = j_min; j < N; j++) {
 80176c6:	454e      	cmp	r6, r9
      BASE temp_i = 0.0;
 80176c8:	ed9f 5a91 	vldr	s10, [pc, #580]	; 8017910 <cblas_ctrmv+0x36c>
      for (j = j_min; j < N; j++) {
 80176cc:	f340 819c 	ble.w	8017a08 <cblas_ctrmv+0x464>
 80176d0:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
      BASE temp_r = 0.0;
 80176d4:	eef0 4a45 	vmov.f32	s9, s10
 80176d8:	eb07 01cb 	add.w	r1, r7, fp, lsl #3
 80176dc:	eb0c 0208 	add.w	r2, ip, r8
      for (j = j_min; j < N; j++) {
 80176e0:	464b      	mov	r3, r9
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80176e2:	edd2 7a00 	vldr	s15, [r2]
        const BASE x_imag = IMAG(X, jx);
 80176e6:	ed91 6a01 	vldr	s12, [r1, #4]
        const BASE x_real = REAL(X, jx);
 80176ea:	edd1 5a00 	vldr	s11, [r1]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80176ee:	ed52 6a01 	vldr	s13, [r2, #-4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80176f2:	ee64 7a27 	vmul.f32	s15, s8, s15
      for (j = j_min; j < N; j++) {
 80176f6:	3301      	adds	r3, #1
        temp_r += A_real * x_real - A_imag * x_imag;
 80176f8:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 80176fc:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8017700:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = j_min; j < N; j++) {
 8017704:	429e      	cmp	r6, r3
 8017706:	4401      	add	r1, r0
        temp_i += A_real * x_imag + A_imag * x_real;
 8017708:	eee6 7a26 	vfma.f32	s15, s12, s13
 801770c:	4462      	add	r2, ip
        temp_r += A_real * x_real - A_imag * x_imag;
 801770e:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 8017712:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = j_min; j < N; j++) {
 8017716:	d1e4      	bne.n	80176e2 <cblas_ctrmv+0x13e>
      if (nonunit) {
 8017718:	2c83      	cmp	r4, #131	; 0x83
 801771a:	d02d      	beq.n	8017778 <cblas_ctrmv+0x1d4>
        REAL(X, ix) += temp_r;
 801771c:	ed1e 7a01 	vldr	s14, [lr, #-4]
        IMAG(X, ix) += temp_i;
 8017720:	edde 7a00 	vldr	s15, [lr]
        REAL(X, ix) += temp_r;
 8017724:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 8017728:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 801772c:	ed4e 4a01 	vstr	s9, [lr, #-4]
        IMAG(X, ix) += temp_i;
 8017730:	ed8e 5a00 	vstr	s10, [lr]
    for (i = 0; i < N; i++) {
 8017734:	454e      	cmp	r6, r9
 8017736:	44ab      	add	fp, r5
 8017738:	4486      	add	lr, r0
 801773a:	44d0      	add	r8, sl
 801773c:	d1c1      	bne.n	80176c2 <cblas_ctrmv+0x11e>
 801773e:	b003      	add	sp, #12
 8017740:	ecbd 8b02 	vpop	{d8}
 8017744:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8017748:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
 801774c:	2b01      	cmp	r3, #1
 801774e:	d930      	bls.n	80177b2 <cblas_ctrmv+0x20e>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8017750:	ed9f 8a6e 	vldr	s16, [pc, #440]	; 801790c <cblas_ctrmv+0x368>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8017754:	f04f 0870 	mov.w	r8, #112	; 0x70
 8017758:	2002      	movs	r0, #2
 801775a:	e73f      	b.n	80175dc <cblas_ctrmv+0x38>
 801775c:	2d00      	cmp	r5, #0
 801775e:	bf0c      	ite	eq
 8017760:	2009      	moveq	r0, #9
 8017762:	2004      	movne	r0, #4
 8017764:	e74c      	b.n	8017600 <cblas_ctrmv+0x5c>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8017766:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 801776a:	f000 8150 	beq.w	8017a0e <cblas_ctrmv+0x46a>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 801776e:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 8017772:	f47f af57 	bne.w	8017624 <cblas_ctrmv+0x80>
 8017776:	e789      	b.n	801768c <cblas_ctrmv+0xe8>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8017778:	ed98 7a00 	vldr	s14, [r8]
        const BASE x_imag = IMAG(X, ix);
 801777c:	ed9e 6a00 	vldr	s12, [lr]
        const BASE x_real = REAL(X, ix);
 8017780:	ed5e 5a01 	vldr	s11, [lr, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8017784:	ed58 6a01 	vldr	s13, [r8, #-4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8017788:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 801778c:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8017790:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8017794:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8017798:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 801779c:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80177a0:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80177a4:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80177a8:	ed4e 4a01 	vstr	s9, [lr, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80177ac:	ed8e 5a00 	vstr	s10, [lr]
 80177b0:	e7c0      	b.n	8017734 <cblas_ctrmv+0x190>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80177b2:	3865      	subs	r0, #101	; 0x65
 80177b4:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 80177b6:	ed9f 8a55 	vldr	s16, [pc, #340]	; 801790c <cblas_ctrmv+0x368>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80177ba:	bf94      	ite	ls
 80177bc:	2000      	movls	r0, #0
 80177be:	2001      	movhi	r0, #1
 80177c0:	f04f 0870 	mov.w	r8, #112	; 0x70
 80177c4:	e70a      	b.n	80175dc <cblas_ctrmv+0x38>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80177c6:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 80177ca:	f000 80a3 	beq.w	8017914 <cblas_ctrmv+0x370>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 80177ce:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 80177d2:	f47f af27 	bne.w	8017624 <cblas_ctrmv+0x80>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80177d6:	2d00      	cmp	r5, #0
 80177d8:	bfd8      	it	le
 80177da:	f1c5 0e00 	rsble	lr, r5, #0
 80177de:	f106 30ff 	add.w	r0, r6, #4294967295
 80177e2:	bfcc      	ite	gt
 80177e4:	f04f 0e00 	movgt.w	lr, #0
 80177e8:	fb00 fe0e 	mulle.w	lr, r0, lr
    for (i = N; i > 0 && i--;) {
 80177ec:	2e00      	cmp	r6, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80177ee:	fb00 e305 	mla	r3, r0, r5, lr
    for (i = N; i > 0 && i--;) {
 80177f2:	dda4      	ble.n	801773e <cblas_ctrmv+0x19a>
 80177f4:	f109 0101 	add.w	r1, r9, #1
 80177f8:	ea4f 08c1 	mov.w	r8, r1, lsl #3
 80177fc:	9901      	ldr	r1, [sp, #4]
 80177fe:	fb09 6200 	mla	r2, r9, r0, r6
 8017802:	eb07 0cc3 	add.w	ip, r7, r3, lsl #3
 8017806:	f1a1 0308 	sub.w	r3, r1, #8
 801780a:	f1a8 0608 	sub.w	r6, r8, #8
 801780e:	eb07 0ece 	add.w	lr, r7, lr, lsl #3
 8017812:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8017816:	ea6f 0709 	mvn.w	r7, r9
 801781a:	ebc5 7245 	rsb	r2, r5, r5, lsl #29
 801781e:	ebc9 7949 	rsb	r9, r9, r9, lsl #29
 8017822:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 8017826:	f10c 0c04 	add.w	ip, ip, #4
 801782a:	fb00 1606 	mla	r6, r0, r6, r1
 801782e:	fb08 1800 	mla	r8, r8, r0, r1
 8017832:	00ff      	lsls	r7, r7, #3
 8017834:	ea4f 09c2 	mov.w	r9, r2, lsl #3
 8017838:	00ed      	lsls	r5, r5, #3
      for (j = 0; j < j_max; j++) {
 801783a:	ed9f 5a35 	vldr	s10, [pc, #212]	; 8017910 <cblas_ctrmv+0x36c>
 801783e:	eef0 4a45 	vmov.f32	s9, s10
 8017842:	b1f8      	cbz	r0, 8017884 <cblas_ctrmv+0x2e0>
 8017844:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8017848:	eef0 4a45 	vmov.f32	s9, s10
 801784c:	4632      	mov	r2, r6
 801784e:	4671      	mov	r1, lr
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8017850:	edd2 7a01 	vldr	s15, [r2, #4]
        const BASE x_imag = IMAG(X, jx);
 8017854:	ed91 6a01 	vldr	s12, [r1, #4]
        const BASE x_real = REAL(X, jx);
 8017858:	edd1 5a00 	vldr	s11, [r1]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801785c:	edd2 6a00 	vldr	s13, [r2]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8017860:	ee64 7a27 	vmul.f32	s15, s8, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8017864:	3208      	adds	r2, #8
 8017866:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 801786a:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 801786e:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = 0; j < j_max; j++) {
 8017872:	4293      	cmp	r3, r2
 8017874:	4429      	add	r1, r5
        temp_i += A_real * x_imag + A_imag * x_real;
 8017876:	eee6 7a26 	vfma.f32	s15, s12, s13
        temp_r += A_real * x_real - A_imag * x_imag;
 801787a:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 801787e:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = 0; j < j_max; j++) {
 8017882:	d1e5      	bne.n	8017850 <cblas_ctrmv+0x2ac>
      if (nonunit) {
 8017884:	2c83      	cmp	r4, #131	; 0x83
 8017886:	d014      	beq.n	80178b2 <cblas_ctrmv+0x30e>
        REAL(X, ix) += temp_r;
 8017888:	ed1c 7a01 	vldr	s14, [ip, #-4]
        IMAG(X, ix) += temp_i;
 801788c:	eddc 7a00 	vldr	s15, [ip]
        REAL(X, ix) += temp_r;
 8017890:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 8017894:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 8017898:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) += temp_i;
 801789c:	ed8c 5a00 	vstr	s10, [ip]
    for (i = N; i > 0 && i--;) {
 80178a0:	44b8      	add	r8, r7
 80178a2:	4456      	add	r6, sl
 80178a4:	443b      	add	r3, r7
 80178a6:	44cc      	add	ip, r9
 80178a8:	2800      	cmp	r0, #0
 80178aa:	f43f af48 	beq.w	801773e <cblas_ctrmv+0x19a>
 80178ae:	3801      	subs	r0, #1
 80178b0:	e7c3      	b.n	801783a <cblas_ctrmv+0x296>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80178b2:	ed98 7a01 	vldr	s14, [r8, #4]
        const BASE x_imag = IMAG(X, ix);
 80178b6:	ed9c 6a00 	vldr	s12, [ip]
        const BASE x_real = REAL(X, ix);
 80178ba:	ed5c 5a01 	vldr	s11, [ip, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80178be:	edd8 6a00 	vldr	s13, [r8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80178c2:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 80178c6:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80178ca:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80178ce:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80178d2:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80178d6:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80178da:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80178de:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80178e2:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80178e6:	ed8c 5a00 	vstr	s10, [ip]
 80178ea:	e7d9      	b.n	80178a0 <cblas_ctrmv+0x2fc>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80178ec:	f1bb 0f7a 	cmp.w	fp, #122	; 0x7a
 80178f0:	d010      	beq.n	8017914 <cblas_ctrmv+0x370>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 80178f2:	f1bb 0f79 	cmp.w	fp, #121	; 0x79
 80178f6:	f47f ae95 	bne.w	8017624 <cblas_ctrmv+0x80>
 80178fa:	e76c      	b.n	80177d6 <cblas_ctrmv+0x232>
 80178fc:	00000001 	.word	0x00000001
 8017900:	08030378 	.word	0x08030378
 8017904:	08030794 	.word	0x08030794
 8017908:	080305a8 	.word	0x080305a8
 801790c:	ffffffff 	.word	0xffffffff
 8017910:	00000000 	.word	0x00000000
    INDEX ix = OFFSET(N, incX);
 8017914:	2d00      	cmp	r5, #0
 8017916:	bfda      	itte	le
 8017918:	f1c6 0201 	rsble	r2, r6, #1
 801791c:	436a      	mulle	r2, r5
 801791e:	2200      	movgt	r2, #0
    for (i = 0; i < N; i++) {
 8017920:	2e00      	cmp	r6, #0
 8017922:	f77f af0c 	ble.w	801773e <cblas_ctrmv+0x19a>
 8017926:	f8dd 8004 	ldr.w	r8, [sp, #4]
 801792a:	f109 0901 	add.w	r9, r9, #1
 801792e:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 8017932:	f1a8 0308 	sub.w	r3, r8, #8
 8017936:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
 801793a:	f1aa 0b08 	sub.w	fp, sl, #8
 801793e:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8017942:	f10c 0c04 	add.w	ip, ip, #4
 8017946:	eb02 0905 	add.w	r9, r2, r5
 801794a:	00e8      	lsls	r0, r5, #3
 801794c:	f04f 0e00 	mov.w	lr, #0
      const INDEX j_min = i + 1;
 8017950:	f10e 0e01 	add.w	lr, lr, #1
      for (j = j_min; j < N; j++) {
 8017954:	4576      	cmp	r6, lr
      BASE temp_i = 0.0;
 8017956:	ed1f 5a12 	vldr	s10, [pc, #-72]	; 8017910 <cblas_ctrmv+0x36c>
      for (j = j_min; j < N; j++) {
 801795a:	dd52      	ble.n	8017a02 <cblas_ctrmv+0x45e>
 801795c:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
      BASE temp_r = 0.0;
 8017960:	eef0 4a45 	vmov.f32	s9, s10
 8017964:	eb07 01c9 	add.w	r1, r7, r9, lsl #3
      for (j = j_min; j < N; j++) {
 8017968:	4642      	mov	r2, r8
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 801796a:	edd2 7a03 	vldr	s15, [r2, #12]
        const BASE x_imag = IMAG(X, jx);
 801796e:	ed91 6a01 	vldr	s12, [r1, #4]
        const BASE x_real = REAL(X, jx);
 8017972:	edd1 5a00 	vldr	s11, [r1]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 8017976:	edd2 6a02 	vldr	s13, [r2, #8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 801797a:	ee64 7a27 	vmul.f32	s15, s8, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 801797e:	3208      	adds	r2, #8
 8017980:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 8017984:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8017988:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = j_min; j < N; j++) {
 801798c:	4293      	cmp	r3, r2
 801798e:	4401      	add	r1, r0
        temp_i += A_real * x_imag + A_imag * x_real;
 8017990:	eee6 7a26 	vfma.f32	s15, s12, s13
        temp_r += A_real * x_real - A_imag * x_imag;
 8017994:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 8017998:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = j_min; j < N; j++) {
 801799c:	d1e5      	bne.n	801796a <cblas_ctrmv+0x3c6>
      if (nonunit) {
 801799e:	2c83      	cmp	r4, #131	; 0x83
 80179a0:	d012      	beq.n	80179c8 <cblas_ctrmv+0x424>
        REAL(X, ix) += temp_r;
 80179a2:	ed1c 7a01 	vldr	s14, [ip, #-4]
        IMAG(X, ix) += temp_i;
 80179a6:	eddc 7a00 	vldr	s15, [ip]
        REAL(X, ix) += temp_r;
 80179aa:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 80179ae:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 80179b2:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) += temp_i;
 80179b6:	ed8c 5a00 	vstr	s10, [ip]
    for (i = 0; i < N; i++) {
 80179ba:	4576      	cmp	r6, lr
 80179bc:	44a9      	add	r9, r5
 80179be:	44d0      	add	r8, sl
 80179c0:	445b      	add	r3, fp
 80179c2:	4484      	add	ip, r0
 80179c4:	d1c4      	bne.n	8017950 <cblas_ctrmv+0x3ac>
 80179c6:	e6ba      	b.n	801773e <cblas_ctrmv+0x19a>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80179c8:	ed98 7a01 	vldr	s14, [r8, #4]
        const BASE x_imag = IMAG(X, ix);
 80179cc:	ed9c 6a00 	vldr	s12, [ip]
        const BASE x_real = REAL(X, ix);
 80179d0:	ed5c 5a01 	vldr	s11, [ip, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 80179d4:	edd8 6a00 	vldr	s13, [r8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80179d8:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 80179dc:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80179e0:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80179e4:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80179e8:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80179ec:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80179f0:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80179f4:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80179f8:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80179fc:	ed8c 5a00 	vstr	s10, [ip]
 8017a00:	e7db      	b.n	80179ba <cblas_ctrmv+0x416>
      BASE temp_r = 0.0;
 8017a02:	eef0 4a45 	vmov.f32	s9, s10
 8017a06:	e7ca      	b.n	801799e <cblas_ctrmv+0x3fa>
      BASE temp_r = 0.0;
 8017a08:	eef0 4a45 	vmov.f32	s9, s10
 8017a0c:	e684      	b.n	8017718 <cblas_ctrmv+0x174>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8017a0e:	2d00      	cmp	r5, #0
 8017a10:	bfd8      	it	le
 8017a12:	f1c5 0e00 	rsble	lr, r5, #0
 8017a16:	f106 30ff 	add.w	r0, r6, #4294967295
 8017a1a:	bfcc      	ite	gt
 8017a1c:	f04f 0e00 	movgt.w	lr, #0
 8017a20:	fb00 fe0e 	mulle.w	lr, r0, lr
    for (i = N; i > 0 && i--;) {
 8017a24:	2e00      	cmp	r6, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8017a26:	fb00 e305 	mla	r3, r0, r5, lr
    for (i = N; i > 0 && i--;) {
 8017a2a:	f77f ae88 	ble.w	801773e <cblas_ctrmv+0x19a>
 8017a2e:	9901      	ldr	r1, [sp, #4]
 8017a30:	f109 0201 	add.w	r2, r9, #1
 8017a34:	eb07 0cc3 	add.w	ip, r7, r3, lsl #3
 8017a38:	00d2      	lsls	r2, r2, #3
 8017a3a:	ea6f 0909 	mvn.w	r9, r9
 8017a3e:	ebc5 7b45 	rsb	fp, r5, r5, lsl #29
 8017a42:	eb07 0ece 	add.w	lr, r7, lr, lsl #3
 8017a46:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
 8017a4a:	f10c 0c04 	add.w	ip, ip, #4
 8017a4e:	eb01 06c6 	add.w	r6, r1, r6, lsl #3
 8017a52:	fb02 1800 	mla	r8, r2, r0, r1
 8017a56:	f1a2 0708 	sub.w	r7, r2, #8
 8017a5a:	ea4f 09cb 	mov.w	r9, fp, lsl #3
 8017a5e:	00ed      	lsls	r5, r5, #3
      for (j = 0; j < j_max; j++) {
 8017a60:	ed1f 5a55 	vldr	s10, [pc, #-340]	; 8017910 <cblas_ctrmv+0x36c>
 8017a64:	eef0 4a45 	vmov.f32	s9, s10
 8017a68:	b308      	cbz	r0, 8017aae <cblas_ctrmv+0x50a>
 8017a6a:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8017a6e:	eef0 4a45 	vmov.f32	s9, s10
 8017a72:	4631      	mov	r1, r6
 8017a74:	4672      	mov	r2, lr
 8017a76:	2300      	movs	r3, #0
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8017a78:	ed51 7a01 	vldr	s15, [r1, #-4]
        const BASE x_imag = IMAG(X, jx);
 8017a7c:	ed92 6a01 	vldr	s12, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8017a80:	edd2 5a00 	vldr	s11, [r2]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8017a84:	ed51 6a02 	vldr	s13, [r1, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8017a88:	ee64 7a27 	vmul.f32	s15, s8, s15
      for (j = 0; j < j_max; j++) {
 8017a8c:	3301      	adds	r3, #1
        temp_r += A_real * x_real - A_imag * x_imag;
 8017a8e:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        temp_i += A_real * x_imag + A_imag * x_real;
 8017a92:	ee65 7aa7 	vmul.f32	s15, s11, s15
        temp_r += A_real * x_real - A_imag * x_imag;
 8017a96:	eea5 7aa6 	vfma.f32	s14, s11, s13
      for (j = 0; j < j_max; j++) {
 8017a9a:	4298      	cmp	r0, r3
 8017a9c:	442a      	add	r2, r5
        temp_i += A_real * x_imag + A_imag * x_real;
 8017a9e:	eee6 7a26 	vfma.f32	s15, s12, s13
 8017aa2:	4439      	add	r1, r7
        temp_r += A_real * x_real - A_imag * x_imag;
 8017aa4:	ee74 4a87 	vadd.f32	s9, s9, s14
        temp_i += A_real * x_imag + A_imag * x_real;
 8017aa8:	ee35 5a27 	vadd.f32	s10, s10, s15
      for (j = 0; j < j_max; j++) {
 8017aac:	d1e4      	bne.n	8017a78 <cblas_ctrmv+0x4d4>
      if (nonunit) {
 8017aae:	2c83      	cmp	r4, #131	; 0x83
 8017ab0:	d013      	beq.n	8017ada <cblas_ctrmv+0x536>
        REAL(X, ix) += temp_r;
 8017ab2:	ed1c 7a01 	vldr	s14, [ip, #-4]
        IMAG(X, ix) += temp_i;
 8017ab6:	eddc 7a00 	vldr	s15, [ip]
        REAL(X, ix) += temp_r;
 8017aba:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) += temp_i;
 8017abe:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) += temp_r;
 8017ac2:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) += temp_i;
 8017ac6:	ed8c 5a00 	vstr	s10, [ip]
    for (i = N; i > 0 && i--;) {
 8017aca:	44d0      	add	r8, sl
 8017acc:	3e08      	subs	r6, #8
 8017ace:	44cc      	add	ip, r9
 8017ad0:	2800      	cmp	r0, #0
 8017ad2:	f43f ae34 	beq.w	801773e <cblas_ctrmv+0x19a>
 8017ad6:	3801      	subs	r0, #1
 8017ad8:	e7c2      	b.n	8017a60 <cblas_ctrmv+0x4bc>
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8017ada:	ed98 7a01 	vldr	s14, [r8, #4]
        const BASE x_imag = IMAG(X, ix);
 8017ade:	ed9c 6a00 	vldr	s12, [ip]
        const BASE x_real = REAL(X, ix);
 8017ae2:	ed5c 5a01 	vldr	s11, [ip, #-4]
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8017ae6:	edd8 6a00 	vldr	s13, [r8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8017aea:	eef8 7ac8 	vcvt.f32.s32	s15, s16
 8017aee:	ee67 7a87 	vmul.f32	s15, s15, s14
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8017af2:	ee27 7ac6 	vnmul.f32	s14, s15, s12
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8017af6:	ee65 7aa7 	vmul.f32	s15, s11, s15
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8017afa:	eea5 7aa6 	vfma.f32	s14, s11, s13
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8017afe:	eee6 7a26 	vfma.f32	s15, s12, s13
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8017b02:	ee77 4a24 	vadd.f32	s9, s14, s9
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8017b06:	ee37 5a85 	vadd.f32	s10, s15, s10
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8017b0a:	ed4c 4a01 	vstr	s9, [ip, #-4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8017b0e:	ed8c 5a00 	vstr	s10, [ip]
 8017b12:	e7da      	b.n	8017aca <cblas_ctrmv+0x526>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8017b14:	2009      	movs	r0, #9
 8017b16:	e573      	b.n	8017600 <cblas_ctrmv+0x5c>

08017b18 <xhypot>:
#include <math.h>

static double xhypot (const double x, const double y);

static double xhypot (const double x, const double y)
{
 8017b18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 8017b1a:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 8017b1e:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  double min, max;

  if (xabs < yabs) {
 8017b22:	4639      	mov	r1, r7
 8017b24:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 8017b26:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 8017b28:	4614      	mov	r4, r2
  if (xabs < yabs) {
 8017b2a:	f010 fc2f 	bl	802838c <__aeabi_dcmplt>
 8017b2e:	b928      	cbnz	r0, 8017b3c <xhypot+0x24>
 8017b30:	4632      	mov	r2, r6
 8017b32:	463b      	mov	r3, r7
    min = xabs ;
    max = yabs ;
  } else {
    min = yabs ;
 8017b34:	4626      	mov	r6, r4
 8017b36:	462f      	mov	r7, r5
    max = xabs ;
 8017b38:	4614      	mov	r4, r2
 8017b3a:	461d      	mov	r5, r3
  }

  if (min == 0) 
 8017b3c:	2200      	movs	r2, #0
 8017b3e:	2300      	movs	r3, #0
 8017b40:	4630      	mov	r0, r6
 8017b42:	4639      	mov	r1, r7
 8017b44:	f010 fc18 	bl	8028378 <__aeabi_dcmpeq>
 8017b48:	b9c8      	cbnz	r0, 8017b7e <xhypot+0x66>
    {
      return max ;
    }

  {
    double u = min / max ;
 8017b4a:	4622      	mov	r2, r4
 8017b4c:	462b      	mov	r3, r5
 8017b4e:	4630      	mov	r0, r6
 8017b50:	4639      	mov	r1, r7
 8017b52:	f010 fad3 	bl	80280fc <__aeabi_ddiv>
 8017b56:	4602      	mov	r2, r0
 8017b58:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 8017b5a:	f010 f9a5 	bl	8027ea8 <__aeabi_dmul>
 8017b5e:	4b09      	ldr	r3, [pc, #36]	; (8017b84 <xhypot+0x6c>)
 8017b60:	2200      	movs	r2, #0
 8017b62:	f00f ffeb 	bl	8027b3c <__adddf3>
 8017b66:	ec41 0b10 	vmov	d0, r0, r1
 8017b6a:	f018 f995 	bl	802fe98 <sqrt>
 8017b6e:	4620      	mov	r0, r4
 8017b70:	4629      	mov	r1, r5
 8017b72:	ec53 2b10 	vmov	r2, r3, d0
 8017b76:	f010 f997 	bl	8027ea8 <__aeabi_dmul>
 8017b7a:	4604      	mov	r4, r0
 8017b7c:	460d      	mov	r5, r1
  }
}
 8017b7e:	4620      	mov	r0, r4
 8017b80:	4629      	mov	r1, r5
 8017b82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017b84:	3ff00000 	.word	0x3ff00000

08017b88 <cblas_ctrsm>:
cblas_ctrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8017b88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017b8c:	ed2d 8b04 	vpush	{d8-d9}
{
  INDEX i, j, k;
  INDEX n1, n2;

  const int nonunit = (Diag == CblasNonUnit);
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8017b90:	2b71      	cmp	r3, #113	; 0x71
 8017b92:	b091      	sub	sp, #68	; 0x44
 8017b94:	461d      	mov	r5, r3
 8017b96:	bf0c      	ite	eq
 8017b98:	f04f 33ff 	moveq.w	r3, #4294967295
 8017b9c:	2301      	movne	r3, #1
 8017b9e:	ee08 3a10 	vmov	s16, r3
 8017ba2:	f89d 3078 	ldrb.w	r3, [sp, #120]	; 0x78
 8017ba6:	9304      	str	r3, [sp, #16]
 8017ba8:	e9dd b31f 	ldrd	fp, r3, [sp, #124]	; 0x7c
 8017bac:	9300      	str	r3, [sp, #0]
 8017bae:	e9dd 8321 	ldrd	r8, r3, [sp, #132]	; 0x84
 8017bb2:	930a      	str	r3, [sp, #40]	; 0x28
 8017bb4:	e9dd 6323 	ldrd	r6, r3, [sp, #140]	; 0x8c
  int side, uplo, trans;

  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017bb8:	298d      	cmp	r1, #141	; 0x8d
 8017bba:	9306      	str	r3, [sp, #24]
 8017bbc:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8017bbe:	9302      	str	r3, [sp, #8]
 8017bc0:	460c      	mov	r4, r1
 8017bc2:	4617      	mov	r7, r2
 8017bc4:	d067      	beq.n	8017c96 <cblas_ctrsm+0x10e>
 8017bc6:	298e      	cmp	r1, #142	; 0x8e
 8017bc8:	f000 83a0 	beq.w	801830c <cblas_ctrsm+0x784>
 8017bcc:	f8dd c000 	ldr.w	ip, [sp]
 8017bd0:	2302      	movs	r3, #2
 8017bd2:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 8017bd6:	2a01      	cmp	r2, #1
 8017bd8:	9a04      	ldr	r2, [sp, #16]
 8017bda:	f1a5 016f 	sub.w	r1, r5, #111	; 0x6f
 8017bde:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8017be2:	bf88      	it	hi
 8017be4:	2303      	movhi	r3, #3
 8017be6:	b2d2      	uxtb	r2, r2
 8017be8:	2902      	cmp	r1, #2
 8017bea:	bf88      	it	hi
 8017bec:	2304      	movhi	r3, #4
 8017bee:	2a02      	cmp	r2, #2
 8017bf0:	9a00      	ldr	r2, [sp, #0]
 8017bf2:	bf28      	it	cs
 8017bf4:	2305      	movcs	r3, #5
 8017bf6:	f1bb 0f00 	cmp.w	fp, #0
 8017bfa:	bfb8      	it	lt
 8017bfc:	2306      	movlt	r3, #6
 8017bfe:	2a00      	cmp	r2, #0
 8017c00:	bfb8      	it	lt
 8017c02:	2307      	movlt	r3, #7
 8017c04:	f1bc 0f01 	cmp.w	ip, #1
 8017c08:	bfb8      	it	lt
 8017c0a:	f04f 0c01 	movlt.w	ip, #1
 8017c0e:	45b4      	cmp	ip, r6
 8017c10:	dd34      	ble.n	8017c7c <cblas_ctrsm+0xf4>
 8017c12:	2865      	cmp	r0, #101	; 0x65
 8017c14:	f000 80f0 	beq.w	8017df8 <cblas_ctrsm+0x270>
 8017c18:	465b      	mov	r3, fp
 8017c1a:	2b01      	cmp	r3, #1
 8017c1c:	9a02      	ldr	r2, [sp, #8]
 8017c1e:	bfb8      	it	lt
 8017c20:	2301      	movlt	r3, #1
 8017c22:	4293      	cmp	r3, r2
 8017c24:	bfcc      	ite	gt
 8017c26:	230c      	movgt	r3, #12
 8017c28:	230a      	movle	r3, #10
 8017c2a:	4a83      	ldr	r2, [pc, #524]	; (8017e38 <cblas_ctrsm+0x2b0>)
 8017c2c:	4983      	ldr	r1, [pc, #524]	; (8017e3c <cblas_ctrsm+0x2b4>)
 8017c2e:	4618      	mov	r0, r3
 8017c30:	f00f ff0a 	bl	8027a48 <cblas_xerbla>
      trans = TransA;
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
    } else {
      n1 = N;
      n2 = M;
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8017c34:	2c8d      	cmp	r4, #141	; 0x8d
 8017c36:	bf0c      	ite	eq
 8017c38:	248e      	moveq	r4, #142	; 0x8e
 8017c3a:	248d      	movne	r4, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8017c3c:	2f79      	cmp	r7, #121	; 0x79
 8017c3e:	bf0c      	ite	eq
 8017c40:	277a      	moveq	r7, #122	; 0x7a
 8017c42:	2779      	movne	r7, #121	; 0x79
    const BASE alpha_real = CONST_REAL0(alpha);
 8017c44:	ed98 7a00 	vldr	s14, [r8]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8017c48:	edd8 7a01 	vldr	s15, [r8, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 8017c4c:	2d6f      	cmp	r5, #111	; 0x6f
 8017c4e:	bf0c      	ite	eq
 8017c50:	256f      	moveq	r5, #111	; 0x6f
 8017c52:	2570      	movne	r5, #112	; 0x70
    }

    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8017c54:	2c8d      	cmp	r4, #141	; 0x8d
 8017c56:	d026      	beq.n	8017ca6 <cblas_ctrsm+0x11e>
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
          }
        }
      }

    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8017c58:	2c8e      	cmp	r4, #142	; 0x8e
 8017c5a:	d105      	bne.n	8017c68 <cblas_ctrsm+0xe0>
 8017c5c:	2f79      	cmp	r7, #121	; 0x79
 8017c5e:	f000 80f1 	beq.w	8017e44 <cblas_ctrsm+0x2bc>
          }
        }
      }


    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8017c62:	2f7a      	cmp	r7, #122	; 0x7a
 8017c64:	f000 81c0 	beq.w	8017fe8 <cblas_ctrsm+0x460>
        }
      }


    } else {
      BLAS_ERROR("unrecognized operation");
 8017c68:	4a75      	ldr	r2, [pc, #468]	; (8017e40 <cblas_ctrsm+0x2b8>)
 8017c6a:	4974      	ldr	r1, [pc, #464]	; (8017e3c <cblas_ctrsm+0x2b4>)
 8017c6c:	2000      	movs	r0, #0
#define BASE float
#include "source_trsm_c.h"
#undef BASE
}
 8017c6e:	b011      	add	sp, #68	; 0x44
 8017c70:	ecbd 8b04 	vpop	{d8-d9}
 8017c74:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017c78:	f00f bee6 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017c7c:	2865      	cmp	r0, #101	; 0x65
 8017c7e:	f000 8292 	beq.w	80181a6 <cblas_ctrsm+0x61e>
 8017c82:	465a      	mov	r2, fp
 8017c84:	2a01      	cmp	r2, #1
 8017c86:	9902      	ldr	r1, [sp, #8]
 8017c88:	bfb8      	it	lt
 8017c8a:	2201      	movlt	r2, #1
 8017c8c:	428a      	cmp	r2, r1
 8017c8e:	f340 80ce 	ble.w	8017e2e <cblas_ctrsm+0x2a6>
 8017c92:	230c      	movs	r3, #12
 8017c94:	e7c9      	b.n	8017c2a <cblas_ctrsm+0xa2>
 8017c96:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8017c9a:	2b01      	cmp	r3, #1
 8017c9c:	bf94      	ite	ls
 8017c9e:	2300      	movls	r3, #0
 8017ca0:	2301      	movhi	r3, #1
 8017ca2:	46dc      	mov	ip, fp
 8017ca4:	e795      	b.n	8017bd2 <cblas_ctrsm+0x4a>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8017ca6:	2f79      	cmp	r7, #121	; 0x79
 8017ca8:	f000 8287 	beq.w	80181ba <cblas_ctrsm+0x632>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8017cac:	2f7a      	cmp	r7, #122	; 0x7a
 8017cae:	d1db      	bne.n	8017c68 <cblas_ctrsm+0xe0>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017cb0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8017cb4:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017cb6:	eeb4 7a66 	vcmp.f32	s14, s13
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8017cba:	f000 8469 	beq.w	8018590 <cblas_ctrsm+0xa08>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017cbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017cc2:	f000 837e 	beq.w	80183c2 <cblas_ctrsm+0x83a>
        for (i = 0; i < n1; i++) {
 8017cc6:	9f00      	ldr	r7, [sp, #0]
 8017cc8:	2f00      	cmp	r7, #0
 8017cca:	f340 8267 	ble.w	801819c <cblas_ctrsm+0x614>
 8017cce:	9b02      	ldr	r3, [sp, #8]
 8017cd0:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8017cd4:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8017cd8:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8017cdc:	930e      	str	r3, [sp, #56]	; 0x38
 8017cde:	9b06      	ldr	r3, [sp, #24]
 8017ce0:	00e4      	lsls	r4, r4, #3
 8017ce2:	1d25      	adds	r5, r4, #4
 8017ce4:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8017ce8:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8017cea:	f1bb 0f00 	cmp.w	fp, #0
 8017cee:	dd15      	ble.n	8017d1c <cblas_ctrsm+0x194>
 8017cf0:	1863      	adds	r3, r4, r1
 8017cf2:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8017cf4:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8017cf8:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8017cfc:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8017d00:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8017d04:	eea5 6a07 	vfma.f32	s12, s10, s14
 8017d08:	3308      	adds	r3, #8
 8017d0a:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8017d0c:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8017d10:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8017d14:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8017d18:	4299      	cmp	r1, r3
 8017d1a:	d1eb      	bne.n	8017cf4 <cblas_ctrsm+0x16c>
        for (i = 0; i < n1; i++) {
 8017d1c:	3001      	adds	r0, #1
 8017d1e:	4287      	cmp	r7, r0
 8017d20:	4451      	add	r1, sl
 8017d22:	d1e2      	bne.n	8017cea <cblas_ctrsm+0x162>
 8017d24:	9b00      	ldr	r3, [sp, #0]
 8017d26:	9a02      	ldr	r2, [sp, #8]
 8017d28:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8017d2a:	1e5c      	subs	r4, r3, #1
 8017d2c:	fb06 f804 	mul.w	r8, r6, r4
 8017d30:	eb03 0108 	add.w	r1, r3, r8
 8017d34:	ebc6 7c46 	rsb	ip, r6, r6, lsl #29
 8017d38:	43f3      	mvns	r3, r6
 8017d3a:	ebc2 7042 	rsb	r0, r2, r2, lsl #29
 8017d3e:	fb06 4204 	mla	r2, r6, r4, r4
 8017d42:	00de      	lsls	r6, r3, #3
 8017d44:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8017d48:	eb07 09c2 	add.w	r9, r7, r2, lsl #3
 8017d4c:	9307      	str	r3, [sp, #28]
 8017d4e:	9a06      	ldr	r2, [sp, #24]
 8017d50:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8017d52:	f1a7 0508 	sub.w	r5, r7, #8
 8017d56:	00c0      	lsls	r0, r0, #3
 8017d58:	18d3      	adds	r3, r2, r3
 8017d5a:	eb07 08c8 	add.w	r8, r7, r8, lsl #3
 8017d5e:	9002      	str	r0, [sp, #8]
 8017d60:	eb05 05c1 	add.w	r5, r5, r1, lsl #3
 8017d64:	fb0a 2704 	mla	r7, sl, r4, r2
 8017d68:	9300      	str	r3, [sp, #0]
        if (nonunit) {
 8017d6a:	9b04      	ldr	r3, [sp, #16]
 8017d6c:	2b83      	cmp	r3, #131	; 0x83
 8017d6e:	f000 82e7 	beq.w	8018340 <cblas_ctrsm+0x7b8>
        for (k = 0; k < i; k++) {
 8017d72:	2c00      	cmp	r4, #0
 8017d74:	f000 8212 	beq.w	801819c <cblas_ctrsm+0x614>
 8017d78:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8017d7c:	9800      	ldr	r0, [sp, #0]
 8017d7e:	f8dd e018 	ldr.w	lr, [sp, #24]
 8017d82:	46c4      	mov	ip, r8
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017d84:	ed9c 5a01 	vldr	s10, [ip, #4]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8017d88:	eddc 4a00 	vldr	s9, [ip]
          for (j = 0; j < n2; j++) {
 8017d8c:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8017d90:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 8017d94:	dd22      	ble.n	8017ddc <cblas_ctrsm+0x254>
 8017d96:	f10e 0104 	add.w	r1, lr, #4
 8017d9a:	4673      	mov	r3, lr
 8017d9c:	463a      	mov	r2, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8017d9e:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8017da2:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8017da6:	ed51 6a01 	vldr	s13, [r1, #-4]
 8017daa:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8017dae:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8017db2:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8017db6:	3308      	adds	r3, #8
 8017db8:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8017dba:	eee4 7a87 	vfma.f32	s15, s9, s14
 8017dbe:	3108      	adds	r1, #8
 8017dc0:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8017dc4:	ee76 7ac6 	vsub.f32	s15, s13, s12
 8017dc8:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8017dcc:	ed53 7a01 	vldr	s15, [r3, #-4]
 8017dd0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8017dd4:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8017dd8:	4298      	cmp	r0, r3
 8017dda:	d1e0      	bne.n	8017d9e <cblas_ctrsm+0x216>
        for (k = 0; k < i; k++) {
 8017ddc:	f10c 0c08 	add.w	ip, ip, #8
 8017de0:	4565      	cmp	r5, ip
 8017de2:	44d6      	add	lr, sl
 8017de4:	4450      	add	r0, sl
 8017de6:	d1cd      	bne.n	8017d84 <cblas_ctrsm+0x1fc>
 8017de8:	9b02      	ldr	r3, [sp, #8]
 8017dea:	441f      	add	r7, r3
 8017dec:	9b07      	ldr	r3, [sp, #28]
 8017dee:	4435      	add	r5, r6
 8017df0:	4498      	add	r8, r3
 8017df2:	44b1      	add	r9, r6
 8017df4:	3c01      	subs	r4, #1
 8017df6:	e7b8      	b.n	8017d6a <cblas_ctrsm+0x1e2>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017df8:	4613      	mov	r3, r2
 8017dfa:	2a01      	cmp	r2, #1
 8017dfc:	9a02      	ldr	r2, [sp, #8]
 8017dfe:	bfb8      	it	lt
 8017e00:	2301      	movlt	r3, #1
 8017e02:	4293      	cmp	r3, r2
 8017e04:	bfcc      	ite	gt
 8017e06:	230c      	movgt	r3, #12
 8017e08:	230a      	movle	r3, #10
 8017e0a:	4a0b      	ldr	r2, [pc, #44]	; (8017e38 <cblas_ctrsm+0x2b0>)
 8017e0c:	490b      	ldr	r1, [pc, #44]	; (8017e3c <cblas_ctrsm+0x2b4>)
 8017e0e:	4618      	mov	r0, r3
 8017e10:	f00f fe1a 	bl	8027a48 <cblas_xerbla>
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8017e14:	2d6f      	cmp	r5, #111	; 0x6f
    const BASE alpha_real = CONST_REAL0(alpha);
 8017e16:	ed98 7a00 	vldr	s14, [r8]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8017e1a:	edd8 7a01 	vldr	s15, [r8, #4]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8017e1e:	9b00      	ldr	r3, [sp, #0]
 8017e20:	f000 826c 	beq.w	80182fc <cblas_ctrsm+0x774>
 8017e24:	f8cd b000 	str.w	fp, [sp]
 8017e28:	2570      	movs	r5, #112	; 0x70
 8017e2a:	469b      	mov	fp, r3
 8017e2c:	e712      	b.n	8017c54 <cblas_ctrsm+0xcc>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8017e2e:	2b00      	cmp	r3, #0
 8017e30:	f43f af00 	beq.w	8017c34 <cblas_ctrsm+0xac>
 8017e34:	e6f9      	b.n	8017c2a <cblas_ctrsm+0xa2>
 8017e36:	bf00      	nop
 8017e38:	08030378 	.word	0x08030378
 8017e3c:	080307a4 	.word	0x080307a4
 8017e40:	080305a8 	.word	0x080305a8
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017e44:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8017e48:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017e4a:	eeb4 7a66 	vcmp.f32	s14, s13
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8017e4e:	f000 8422 	beq.w	8018696 <cblas_ctrsm+0xb0e>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017e52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017e56:	f000 82d6 	beq.w	8018406 <cblas_ctrsm+0x87e>
        for (i = 0; i < n1; i++) {
 8017e5a:	9f00      	ldr	r7, [sp, #0]
 8017e5c:	2f00      	cmp	r7, #0
 8017e5e:	f340 819d 	ble.w	801819c <cblas_ctrsm+0x614>
 8017e62:	9b02      	ldr	r3, [sp, #8]
 8017e64:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8017e68:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8017e6c:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8017e70:	930e      	str	r3, [sp, #56]	; 0x38
 8017e72:	9b06      	ldr	r3, [sp, #24]
 8017e74:	00e4      	lsls	r4, r4, #3
 8017e76:	1d25      	adds	r5, r4, #4
 8017e78:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8017e7c:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8017e7e:	f1bb 0f00 	cmp.w	fp, #0
 8017e82:	dd15      	ble.n	8017eb0 <cblas_ctrsm+0x328>
 8017e84:	190b      	adds	r3, r1, r4
 8017e86:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8017e88:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8017e8c:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8017e90:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8017e94:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8017e98:	eea5 6a07 	vfma.f32	s12, s10, s14
 8017e9c:	3308      	adds	r3, #8
 8017e9e:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8017ea0:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8017ea4:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8017ea8:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8017eac:	428b      	cmp	r3, r1
 8017eae:	d1eb      	bne.n	8017e88 <cblas_ctrsm+0x300>
        for (i = 0; i < n1; i++) {
 8017eb0:	3001      	adds	r0, #1
 8017eb2:	4287      	cmp	r7, r0
 8017eb4:	4451      	add	r1, sl
 8017eb6:	d1e2      	bne.n	8017e7e <cblas_ctrsm+0x2f6>
 8017eb8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8017eba:	f8cd a020 	str.w	sl, [sp, #32]
 8017ebe:	3a08      	subs	r2, #8
 8017ec0:	1c75      	adds	r5, r6, #1
 8017ec2:	920b      	str	r2, [sp, #44]	; 0x2c
 8017ec4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8017ec6:	f8dd a010 	ldr.w	sl, [sp, #16]
 8017eca:	f8dd 9018 	ldr.w	r9, [sp, #24]
 8017ece:	00ed      	lsls	r5, r5, #3
 8017ed0:	f10b 33ff 	add.w	r3, fp, #4294967295
 8017ed4:	fb05 2303 	mla	r3, r5, r3, r2
 8017ed8:	43f6      	mvns	r6, r6
 8017eda:	930a      	str	r3, [sp, #40]	; 0x28
        for (j = n2; j > 0 && j--;) {
 8017edc:	2300      	movs	r3, #0
 8017ede:	e9cd 3b06 	strd	r3, fp, [sp, #24]
 8017ee2:	00f6      	lsls	r6, r6, #3
 8017ee4:	3d08      	subs	r5, #8
 8017ee6:	4693      	mov	fp, r2
 8017ee8:	9f07      	ldr	r7, [sp, #28]
 8017eea:	2f00      	cmp	r7, #0
 8017eec:	dd73      	ble.n	8017fd6 <cblas_ctrsm+0x44e>
 8017eee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8017ef0:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
          if (nonunit) {
 8017ef4:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8017ef8:	eb03 0409 	add.w	r4, r3, r9
 8017efc:	d033      	beq.n	8017f66 <cblas_ctrsm+0x3de>
            for (k = 0; k < j; k++) {
 8017efe:	2f01      	cmp	r7, #1
 8017f00:	edd4 5a01 	vldr	s11, [r4, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8017f04:	ed94 5a00 	vldr	s10, [r4]
            for (k = 0; k < j; k++) {
 8017f08:	d065      	beq.n	8017fd6 <cblas_ctrsm+0x44e>
 8017f0a:	eef8 4ac8 	vcvt.f32.s32	s9, s16
 8017f0e:	eb0b 01c7 	add.w	r1, fp, r7, lsl #3
 8017f12:	f109 0204 	add.w	r2, r9, #4
 8017f16:	464b      	mov	r3, r9
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8017f18:	ed51 7a01 	vldr	s15, [r1, #-4]
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8017f1c:	ed11 6a02 	vldr	s12, [r1, #-8]
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8017f20:	ed52 6a01 	vldr	s13, [r2, #-4]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8017f24:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8017f28:	3308      	adds	r3, #8
 8017f2a:	ee25 7ae7 	vnmul.f32	s14, s11, s15
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8017f2e:	ee65 7a27 	vmul.f32	s15, s10, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8017f32:	eea5 7a06 	vfma.f32	s14, s10, s12
 8017f36:	4429      	add	r1, r5
 8017f38:	3208      	adds	r2, #8
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8017f3a:	eee6 7a25 	vfma.f32	s15, s12, s11
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8017f3e:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8017f42:	ed02 7a03 	vstr	s14, [r2, #-12]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8017f46:	ed13 7a01 	vldr	s14, [r3, #-4]
 8017f4a:	ee77 7a67 	vsub.f32	s15, s14, s15
 8017f4e:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (k = 0; k < j; k++) {
 8017f52:	42a3      	cmp	r3, r4
 8017f54:	d1e0      	bne.n	8017f18 <cblas_ctrsm+0x390>
          if (nonunit) {
 8017f56:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8017f5a:	f107 37ff 	add.w	r7, r7, #4294967295
 8017f5e:	f1a4 0408 	sub.w	r4, r4, #8
 8017f62:	44b0      	add	r8, r6
 8017f64:	d1cb      	bne.n	8017efe <cblas_ctrsm+0x376>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8017f66:	edd8 7a01 	vldr	s15, [r8, #4]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8017f6a:	ed98 9a00 	vldr	s18, [r8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8017f6e:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 8017f72:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8017f76:	ee18 0a90 	vmov	r0, s17
 8017f7a:	f00f ff3d 	bl	8027df8 <__aeabi_f2d>
 8017f7e:	4602      	mov	r2, r0
 8017f80:	460b      	mov	r3, r1
 8017f82:	ee19 0a10 	vmov	r0, s18
 8017f86:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8017f8a:	f00f ff35 	bl	8027df8 <__aeabi_f2d>
 8017f8e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8017f92:	f7ff fdc1 	bl	8017b18 <xhypot>
 8017f96:	f010 fa37 	bl	8028408 <__aeabi_d2f>
 8017f9a:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 8017f9e:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            for (k = 0; k < j; k++) {
 8017fa2:	2f01      	cmp	r7, #1
            const BASE a_real = Ajj_real / s;
 8017fa4:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8017fa8:	ed94 6a01 	vldr	s12, [r4, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8017fac:	ed94 5a00 	vldr	s10, [r4]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8017fb0:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8017fb4:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8017fb8:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8017fbc:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8017fc0:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8017fc4:	eec7 5a27 	vdiv.f32	s11, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8017fc8:	ed84 6a00 	vstr	s12, [r4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8017fcc:	ed94 5a00 	vldr	s10, [r4]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8017fd0:	edc4 5a01 	vstr	s11, [r4, #4]
            for (k = 0; k < j; k++) {
 8017fd4:	d199      	bne.n	8017f0a <cblas_ctrsm+0x382>
      for (i = 0; i < n1; i++) {
 8017fd6:	9a08      	ldr	r2, [sp, #32]
 8017fd8:	9b06      	ldr	r3, [sp, #24]
 8017fda:	4491      	add	r9, r2
 8017fdc:	9a00      	ldr	r2, [sp, #0]
 8017fde:	3301      	adds	r3, #1
 8017fe0:	429a      	cmp	r2, r3
 8017fe2:	9306      	str	r3, [sp, #24]
 8017fe4:	dc80      	bgt.n	8017ee8 <cblas_ctrsm+0x360>
 8017fe6:	e0d9      	b.n	801819c <cblas_ctrsm+0x614>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017fe8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8017fec:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017fee:	eeb4 7a66 	vcmp.f32	s14, s13
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8017ff2:	f000 83f9 	beq.w	80187e8 <cblas_ctrsm+0xc60>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8017ff6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017ffa:	f000 8190 	beq.w	801831e <cblas_ctrsm+0x796>
        for (i = 0; i < n1; i++) {
 8017ffe:	9f00      	ldr	r7, [sp, #0]
 8018000:	2f00      	cmp	r7, #0
 8018002:	f340 80cb 	ble.w	801819c <cblas_ctrsm+0x614>
 8018006:	9b02      	ldr	r3, [sp, #8]
 8018008:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801800c:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018010:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018014:	930e      	str	r3, [sp, #56]	; 0x38
 8018016:	9b06      	ldr	r3, [sp, #24]
 8018018:	00e4      	lsls	r4, r4, #3
 801801a:	1d25      	adds	r5, r4, #4
 801801c:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018020:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018022:	f1bb 0f00 	cmp.w	fp, #0
 8018026:	dd15      	ble.n	8018054 <cblas_ctrsm+0x4cc>
 8018028:	190b      	adds	r3, r1, r4
 801802a:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801802c:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018030:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018034:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018038:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801803c:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018040:	3308      	adds	r3, #8
 8018042:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018044:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018048:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801804c:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018050:	428b      	cmp	r3, r1
 8018052:	d1eb      	bne.n	801802c <cblas_ctrsm+0x4a4>
        for (i = 0; i < n1; i++) {
 8018054:	3001      	adds	r0, #1
 8018056:	4287      	cmp	r7, r0
 8018058:	4451      	add	r1, sl
 801805a:	d1e2      	bne.n	8018022 <cblas_ctrsm+0x49a>
 801805c:	00f5      	lsls	r5, r6, #3
 801805e:	3601      	adds	r6, #1
 8018060:	00f1      	lsls	r1, r6, #3
 8018062:	9107      	str	r1, [sp, #28]
 8018064:	990a      	ldr	r1, [sp, #40]	; 0x28
 8018066:	9a06      	ldr	r2, [sp, #24]
 8018068:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 801806c:	1d2b      	adds	r3, r5, #4
 801806e:	18cb      	adds	r3, r1, r3
 8018070:	930f      	str	r3, [sp, #60]	; 0x3c
 8018072:	f105 0308 	add.w	r3, r5, #8
 8018076:	9308      	str	r3, [sp, #32]
 8018078:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801807a:	f8dd a010 	ldr.w	sl, [sp, #16]
 801807e:	f1a2 0408 	sub.w	r4, r2, #8
            for (k = j + 1; k < n2; k++) {
 8018082:	2200      	movs	r2, #0
 8018084:	920b      	str	r2, [sp, #44]	; 0x2c
 8018086:	441c      	add	r4, r3
 8018088:	920e      	str	r2, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 801808a:	f1bb 0f00 	cmp.w	fp, #0
 801808e:	dd78      	ble.n	8018182 <cblas_ctrsm+0x5fa>
 8018090:	9b06      	ldr	r3, [sp, #24]
 8018092:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8018094:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
 8018098:	eb03 06c2 	add.w	r6, r3, r2, lsl #3
 801809c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
          if (nonunit) {
 801809e:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 80180a2:	f103 0904 	add.w	r9, r3, #4
        for (j = 0; j < n2; j++) {
 80180a6:	f04f 0700 	mov.w	r7, #0
          if (nonunit) {
 80180aa:	d031      	beq.n	8018110 <cblas_ctrsm+0x588>
            for (k = j + 1; k < n2; k++) {
 80180ac:	3701      	adds	r7, #1
 80180ae:	45bb      	cmp	fp, r7
 80180b0:	ed96 5a01 	vldr	s10, [r6, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80180b4:	edd6 4a00 	vldr	s9, [r6]
            for (k = j + 1; k < n2; k++) {
 80180b8:	d063      	beq.n	8018182 <cblas_ctrsm+0x5fa>
 80180ba:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 80180be:	4642      	mov	r2, r8
 80180c0:	4633      	mov	r3, r6
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80180c2:	edd2 7a00 	vldr	s15, [r2]
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80180c6:	ed52 5a01 	vldr	s11, [r2, #-4]
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80180ca:	ed93 6a02 	vldr	s12, [r3, #8]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80180ce:	ed93 7a03 	vldr	s14, [r3, #12]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 80180d2:	ee64 7a27 	vmul.f32	s15, s8, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80180d6:	3308      	adds	r3, #8
 80180d8:	ee65 6a67 	vnmul.f32	s13, s10, s15
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80180dc:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80180e0:	eee4 6aa5 	vfma.f32	s13, s9, s11
 80180e4:	442a      	add	r2, r5
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80180e6:	eee5 7a85 	vfma.f32	s15, s11, s10
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80180ea:	ee76 6a66 	vsub.f32	s13, s12, s13
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80180ee:	ee77 7a67 	vsub.f32	s15, s14, s15
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80180f2:	edc3 6a00 	vstr	s13, [r3]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80180f6:	edc3 7a01 	vstr	s15, [r3, #4]
            for (k = j + 1; k < n2; k++) {
 80180fa:	42a3      	cmp	r3, r4
 80180fc:	d1e1      	bne.n	80180c2 <cblas_ctrsm+0x53a>
 80180fe:	9b07      	ldr	r3, [sp, #28]
 8018100:	4498      	add	r8, r3
 8018102:	9b08      	ldr	r3, [sp, #32]
          if (nonunit) {
 8018104:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8018108:	f106 0608 	add.w	r6, r6, #8
 801810c:	4499      	add	r9, r3
 801810e:	d1cd      	bne.n	80180ac <cblas_ctrsm+0x524>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018110:	edd9 7a00 	vldr	s15, [r9]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 8018114:	ed19 9a01 	vldr	s18, [r9, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018118:	eef8 8ac8 	vcvt.f32.s32	s17, s16
            for (k = j + 1; k < n2; k++) {
 801811c:	3701      	adds	r7, #1
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 801811e:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8018122:	ee18 0a90 	vmov	r0, s17
 8018126:	f00f fe67 	bl	8027df8 <__aeabi_f2d>
 801812a:	4602      	mov	r2, r0
 801812c:	460b      	mov	r3, r1
 801812e:	ee19 0a10 	vmov	r0, s18
 8018132:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8018136:	f00f fe5f 	bl	8027df8 <__aeabi_f2d>
 801813a:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801813e:	f7ff fceb 	bl	8017b18 <xhypot>
 8018142:	f010 f961 	bl	8028408 <__aeabi_d2f>
 8018146:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 801814a:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            for (k = j + 1; k < n2; k++) {
 801814e:	45bb      	cmp	fp, r7
            const BASE a_real = Ajj_real / s;
 8018150:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018154:	ed96 6a01 	vldr	s12, [r6, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018158:	ed96 5a00 	vldr	s10, [r6]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801815c:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018160:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018164:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018168:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801816c:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018170:	ee87 5a27 	vdiv.f32	s10, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018174:	ed86 6a00 	vstr	s12, [r6]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018178:	edd6 4a00 	vldr	s9, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801817c:	ed86 5a01 	vstr	s10, [r6, #4]
            for (k = j + 1; k < n2; k++) {
 8018180:	d19b      	bne.n	80180ba <cblas_ctrsm+0x532>
      for (i = 0; i < n1; i++) {
 8018182:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8018184:	9902      	ldr	r1, [sp, #8]
 8018186:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018188:	440a      	add	r2, r1
 801818a:	920b      	str	r2, [sp, #44]	; 0x2c
 801818c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801818e:	4414      	add	r4, r2
 8018190:	9a00      	ldr	r2, [sp, #0]
 8018192:	3301      	adds	r3, #1
 8018194:	429a      	cmp	r2, r3
 8018196:	930e      	str	r3, [sp, #56]	; 0x38
 8018198:	f73f af77 	bgt.w	801808a <cblas_ctrsm+0x502>
 801819c:	b011      	add	sp, #68	; 0x44
 801819e:	ecbd 8b04 	vpop	{d8-d9}
 80181a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80181a6:	9a00      	ldr	r2, [sp, #0]
 80181a8:	9902      	ldr	r1, [sp, #8]
 80181aa:	2a01      	cmp	r2, #1
 80181ac:	bfb8      	it	lt
 80181ae:	2201      	movlt	r2, #1
 80181b0:	428a      	cmp	r2, r1
 80181b2:	f340 80a7 	ble.w	8018304 <cblas_ctrsm+0x77c>
 80181b6:	230c      	movs	r3, #12
 80181b8:	e627      	b.n	8017e0a <cblas_ctrsm+0x282>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80181ba:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80181be:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80181c0:	eeb4 7a66 	vcmp.f32	s14, s13
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80181c4:	f000 8130 	beq.w	8018428 <cblas_ctrsm+0x8a0>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80181c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80181cc:	f000 810a 	beq.w	80183e4 <cblas_ctrsm+0x85c>
        for (i = 0; i < n1; i++) {
 80181d0:	9f00      	ldr	r7, [sp, #0]
 80181d2:	2f00      	cmp	r7, #0
 80181d4:	dde2      	ble.n	801819c <cblas_ctrsm+0x614>
 80181d6:	9b02      	ldr	r3, [sp, #8]
 80181d8:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80181dc:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80181e0:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 80181e4:	930e      	str	r3, [sp, #56]	; 0x38
 80181e6:	9b06      	ldr	r3, [sp, #24]
 80181e8:	00e4      	lsls	r4, r4, #3
 80181ea:	1d25      	adds	r5, r4, #4
 80181ec:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 80181f0:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 80181f2:	f1bb 0f00 	cmp.w	fp, #0
 80181f6:	dd15      	ble.n	8018224 <cblas_ctrsm+0x69c>
 80181f8:	1863      	adds	r3, r4, r1
 80181fa:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80181fc:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018200:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018204:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018208:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801820c:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018210:	3308      	adds	r3, #8
 8018212:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018214:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018218:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801821c:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018220:	4299      	cmp	r1, r3
 8018222:	d1eb      	bne.n	80181fc <cblas_ctrsm+0x674>
        for (i = 0; i < n1; i++) {
 8018224:	3001      	adds	r0, #1
 8018226:	4287      	cmp	r7, r0
 8018228:	4451      	add	r1, sl
 801822a:	d1e2      	bne.n	80181f2 <cblas_ctrsm+0x66a>
 801822c:	990e      	ldr	r1, [sp, #56]	; 0x38
 801822e:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 8018232:	9a06      	ldr	r2, [sp, #24]
 8018234:	f8cd 801c 	str.w	r8, [sp, #28]
 8018238:	00f3      	lsls	r3, r6, #3
 801823a:	4608      	mov	r0, r1
 801823c:	930b      	str	r3, [sp, #44]	; 0x2c
 801823e:	9900      	ldr	r1, [sp, #0]
 8018240:	9e02      	ldr	r6, [sp, #8]
 8018242:	3308      	adds	r3, #8
 8018244:	f1a8 0408 	sub.w	r4, r8, #8
 8018248:	f04f 0900 	mov.w	r9, #0
 801824c:	4410      	add	r0, r2
 801824e:	930a      	str	r3, [sp, #40]	; 0x28
 8018250:	1d13      	adds	r3, r2, #4
 8018252:	9008      	str	r0, [sp, #32]
 8018254:	eb04 04c1 	add.w	r4, r4, r1, lsl #3
 8018258:	464f      	mov	r7, r9
 801825a:	4615      	mov	r5, r2
 801825c:	930e      	str	r3, [sp, #56]	; 0x38
        if (nonunit) {
 801825e:	9b04      	ldr	r3, [sp, #16]
 8018260:	2b83      	cmp	r3, #131	; 0x83
 8018262:	f000 83a8 	beq.w	80189b6 <cblas_ctrsm+0xe2e>
        for (k = i + 1; k < n1; k++) {
 8018266:	9b00      	ldr	r3, [sp, #0]
 8018268:	3701      	adds	r7, #1
 801826a:	42bb      	cmp	r3, r7
 801826c:	dd96      	ble.n	801819c <cblas_ctrsm+0x614>
 801826e:	9b06      	ldr	r3, [sp, #24]
 8018270:	eb03 0ec6 	add.w	lr, r3, r6, lsl #3
 8018274:	9b08      	ldr	r3, [sp, #32]
 8018276:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 801827a:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 801827e:	46c4      	mov	ip, r8
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8018280:	ed9c 5a03 	vldr	s10, [ip, #12]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8018284:	eddc 4a02 	vldr	s9, [ip, #8]
          for (j = 0; j < n2; j++) {
 8018288:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 801828c:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 8018290:	dd22      	ble.n	80182d8 <cblas_ctrsm+0x750>
 8018292:	f10e 0104 	add.w	r1, lr, #4
 8018296:	4673      	mov	r3, lr
 8018298:	462a      	mov	r2, r5
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801829a:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 801829e:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 80182a2:	ed51 6a01 	vldr	s13, [r1, #-4]
 80182a6:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 80182aa:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 80182ae:	eea4 6aa5 	vfma.f32	s12, s9, s11
 80182b2:	3308      	adds	r3, #8
 80182b4:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 80182b6:	eee4 7a87 	vfma.f32	s15, s9, s14
 80182ba:	3108      	adds	r1, #8
 80182bc:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 80182c0:	ee76 7ac6 	vsub.f32	s15, s13, s12
 80182c4:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 80182c8:	ed53 7a01 	vldr	s15, [r3, #-4]
 80182cc:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80182d0:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80182d4:	4298      	cmp	r0, r3
 80182d6:	d1e0      	bne.n	801829a <cblas_ctrsm+0x712>
        for (k = i + 1; k < n1; k++) {
 80182d8:	f10c 0c08 	add.w	ip, ip, #8
 80182dc:	4564      	cmp	r4, ip
 80182de:	44d6      	add	lr, sl
 80182e0:	4450      	add	r0, sl
 80182e2:	d1cd      	bne.n	8018280 <cblas_ctrsm+0x6f8>
 80182e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80182e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80182e8:	441c      	add	r4, r3
 80182ea:	9b02      	ldr	r3, [sp, #8]
 80182ec:	4499      	add	r9, r3
 80182ee:	441e      	add	r6, r3
 80182f0:	9b07      	ldr	r3, [sp, #28]
 80182f2:	4413      	add	r3, r2
 80182f4:	4455      	add	r5, sl
 80182f6:	4490      	add	r8, r2
 80182f8:	9307      	str	r3, [sp, #28]
 80182fa:	e7b0      	b.n	801825e <cblas_ctrsm+0x6d6>
 80182fc:	f8cd b000 	str.w	fp, [sp]
 8018300:	469b      	mov	fp, r3
 8018302:	e4a7      	b.n	8017c54 <cblas_ctrsm+0xcc>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8018304:	2b00      	cmp	r3, #0
 8018306:	f43f ad85 	beq.w	8017e14 <cblas_ctrsm+0x28c>
 801830a:	e57e      	b.n	8017e0a <cblas_ctrsm+0x282>
 801830c:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8018310:	2b01      	cmp	r3, #1
 8018312:	f8dd c000 	ldr.w	ip, [sp]
 8018316:	bf94      	ite	ls
 8018318:	2300      	movls	r3, #0
 801831a:	2301      	movhi	r3, #1
 801831c:	e459      	b.n	8017bd2 <cblas_ctrsm+0x4a>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 801831e:	eef5 7a40 	vcmp.f32	s15, #0.0
 8018322:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018326:	f47f ae6a 	bne.w	8017ffe <cblas_ctrsm+0x476>
      for (i = 0; i < n1; i++) {
 801832a:	9b00      	ldr	r3, [sp, #0]
 801832c:	2b00      	cmp	r3, #0
 801832e:	f77f af35 	ble.w	801819c <cblas_ctrsm+0x614>
 8018332:	9b02      	ldr	r3, [sp, #8]
 8018334:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018338:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801833c:	930e      	str	r3, [sp, #56]	; 0x38
 801833e:	e68d      	b.n	801805c <cblas_ctrsm+0x4d4>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8018340:	edd9 7a01 	vldr	s15, [r9, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8018344:	ed99 9a00 	vldr	s18, [r9]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8018348:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 801834c:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 8018350:	ee18 0a90 	vmov	r0, s17
 8018354:	f00f fd50 	bl	8027df8 <__aeabi_f2d>
 8018358:	4602      	mov	r2, r0
 801835a:	460b      	mov	r3, r1
 801835c:	ee19 0a10 	vmov	r0, s18
 8018360:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8018364:	f00f fd48 	bl	8027df8 <__aeabi_f2d>
 8018368:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801836c:	f7ff fbd4 	bl	8017b18 <xhypot>
 8018370:	f010 f84a 	bl	8028408 <__aeabi_d2f>
 8018374:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 8018378:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 801837c:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 8018380:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 8018384:	f77f acf5 	ble.w	8017d72 <cblas_ctrsm+0x1ea>
 8018388:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801838a:	1d3a      	adds	r2, r7, #4
 801838c:	18f9      	adds	r1, r7, r3
 801838e:	463b      	mov	r3, r7
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018390:	3308      	adds	r3, #8
 8018392:	3208      	adds	r2, #8
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018394:	ed53 6a01 	vldr	s13, [r3, #-4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018398:	ed12 6a03 	vldr	s12, [r2, #-12]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801839c:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80183a0:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80183a4:	eea5 7a06 	vfma.f32	s14, s10, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80183a8:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80183ac:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80183b0:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80183b4:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80183b8:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80183bc:	428b      	cmp	r3, r1
 80183be:	d1e7      	bne.n	8018390 <cblas_ctrsm+0x808>
 80183c0:	e4d7      	b.n	8017d72 <cblas_ctrsm+0x1ea>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80183c2:	eef5 7a40 	vcmp.f32	s15, #0.0
 80183c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80183ca:	f47f ac7c 	bne.w	8017cc6 <cblas_ctrsm+0x13e>
      for (i = n1; i > 0 && i--;) {
 80183ce:	9b00      	ldr	r3, [sp, #0]
 80183d0:	2b00      	cmp	r3, #0
 80183d2:	f77f aee3 	ble.w	801819c <cblas_ctrsm+0x614>
 80183d6:	9b02      	ldr	r3, [sp, #8]
 80183d8:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80183dc:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80183e0:	930e      	str	r3, [sp, #56]	; 0x38
 80183e2:	e49f      	b.n	8017d24 <cblas_ctrsm+0x19c>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80183e4:	eef5 7a40 	vcmp.f32	s15, #0.0
 80183e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80183ec:	f47f aef0 	bne.w	80181d0 <cblas_ctrsm+0x648>
      for (i = 0; i < n1; i++) {
 80183f0:	9b00      	ldr	r3, [sp, #0]
 80183f2:	2b00      	cmp	r3, #0
 80183f4:	f77f aed2 	ble.w	801819c <cblas_ctrsm+0x614>
 80183f8:	9b02      	ldr	r3, [sp, #8]
 80183fa:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80183fe:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018402:	930e      	str	r3, [sp, #56]	; 0x38
 8018404:	e712      	b.n	801822c <cblas_ctrsm+0x6a4>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018406:	eef5 7a40 	vcmp.f32	s15, #0.0
 801840a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801840e:	f47f ad24 	bne.w	8017e5a <cblas_ctrsm+0x2d2>
      for (i = 0; i < n1; i++) {
 8018412:	9b00      	ldr	r3, [sp, #0]
 8018414:	2b00      	cmp	r3, #0
 8018416:	f77f aec1 	ble.w	801819c <cblas_ctrsm+0x614>
 801841a:	9b02      	ldr	r3, [sp, #8]
 801841c:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018420:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018424:	930e      	str	r3, [sp, #56]	; 0x38
 8018426:	e547      	b.n	8017eb8 <cblas_ctrsm+0x330>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018428:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801842c:	f040 8293 	bne.w	8018956 <cblas_ctrsm+0xdce>
 8018430:	eef5 7a40 	vcmp.f32	s15, #0.0
 8018434:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018438:	f040 828d 	bne.w	8018956 <cblas_ctrsm+0xdce>
      for (i = n1; i > 0 && i--;) {
 801843c:	9b00      	ldr	r3, [sp, #0]
 801843e:	2b00      	cmp	r3, #0
 8018440:	f77f aeac 	ble.w	801819c <cblas_ctrsm+0x614>
 8018444:	9b02      	ldr	r3, [sp, #8]
 8018446:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801844a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801844e:	930e      	str	r3, [sp, #56]	; 0x38
 8018450:	9b02      	ldr	r3, [sp, #8]
 8018452:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8018454:	ebc3 7943 	rsb	r9, r3, r3, lsl #29
 8018458:	9b00      	ldr	r3, [sp, #0]
 801845a:	1c75      	adds	r5, r6, #1
 801845c:	43f6      	mvns	r6, r6
 801845e:	1e5c      	subs	r4, r3, #1
 8018460:	00f3      	lsls	r3, r6, #3
 8018462:	9300      	str	r3, [sp, #0]
 8018464:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8018466:	00ed      	lsls	r5, r5, #3
 8018468:	fb05 3804 	mla	r8, r5, r4, r3
 801846c:	3308      	adds	r3, #8
 801846e:	9307      	str	r3, [sp, #28]
 8018470:	9b06      	ldr	r3, [sp, #24]
 8018472:	fb0a 3604 	mla	r6, sl, r4, r3
 8018476:	4413      	add	r3, r2
 8018478:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 801847c:	3d08      	subs	r5, #8
 801847e:	9302      	str	r3, [sp, #8]
        if (nonunit) {
 8018480:	9b04      	ldr	r3, [sp, #16]
 8018482:	2b83      	cmp	r3, #131	; 0x83
 8018484:	d044      	beq.n	8018510 <cblas_ctrsm+0x988>
        for (k = 0; k < i; k++) {
 8018486:	2c00      	cmp	r4, #0
 8018488:	f43f ae88 	beq.w	801819c <cblas_ctrsm+0x614>
 801848c:	9b07      	ldr	r3, [sp, #28]
 801848e:	9802      	ldr	r0, [sp, #8]
 8018490:	f8dd c018 	ldr.w	ip, [sp, #24]
 8018494:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 8018498:	eb03 07c4 	add.w	r7, r3, r4, lsl #3
 801849c:	f04f 0e00 	mov.w	lr, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 80184a0:	ed17 5a01 	vldr	s10, [r7, #-4]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 80184a4:	ed57 4a02 	vldr	s9, [r7, #-8]
          for (j = 0; j < n2; j++) {
 80184a8:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 80184ac:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 80184b0:	dd22      	ble.n	80184f8 <cblas_ctrsm+0x970>
 80184b2:	f10c 0104 	add.w	r1, ip, #4
 80184b6:	4663      	mov	r3, ip
 80184b8:	4632      	mov	r2, r6
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80184ba:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80184be:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 80184c2:	ed51 6a01 	vldr	s13, [r1, #-4]
 80184c6:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 80184ca:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 80184ce:	eea4 6aa5 	vfma.f32	s12, s9, s11
 80184d2:	3308      	adds	r3, #8
 80184d4:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 80184d6:	eee4 7a87 	vfma.f32	s15, s9, s14
 80184da:	3108      	adds	r1, #8
 80184dc:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 80184e0:	ee76 7ac6 	vsub.f32	s15, s13, s12
 80184e4:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 80184e8:	ed53 7a01 	vldr	s15, [r3, #-4]
 80184ec:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80184f0:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80184f4:	4283      	cmp	r3, r0
 80184f6:	d1e0      	bne.n	80184ba <cblas_ctrsm+0x932>
        for (k = 0; k < i; k++) {
 80184f8:	f10e 0e01 	add.w	lr, lr, #1
 80184fc:	4574      	cmp	r4, lr
 80184fe:	442f      	add	r7, r5
 8018500:	44d4      	add	ip, sl
 8018502:	4450      	add	r0, sl
 8018504:	d1cc      	bne.n	80184a0 <cblas_ctrsm+0x918>
 8018506:	9b00      	ldr	r3, [sp, #0]
 8018508:	444e      	add	r6, r9
 801850a:	4498      	add	r8, r3
 801850c:	3c01      	subs	r4, #1
 801850e:	e7b7      	b.n	8018480 <cblas_ctrsm+0x8f8>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8018510:	edd8 7a01 	vldr	s15, [r8, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8018514:	ed98 9a00 	vldr	s18, [r8]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8018518:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 801851c:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 8018520:	ee18 0a90 	vmov	r0, s17
 8018524:	f00f fc68 	bl	8027df8 <__aeabi_f2d>
 8018528:	4602      	mov	r2, r0
 801852a:	460b      	mov	r3, r1
 801852c:	ee19 0a10 	vmov	r0, s18
 8018530:	e9cd 2308 	strd	r2, r3, [sp, #32]
 8018534:	f00f fc60 	bl	8027df8 <__aeabi_f2d>
 8018538:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801853c:	f7ff faec 	bl	8017b18 <xhypot>
 8018540:	f00f ff62 	bl	8028408 <__aeabi_d2f>
 8018544:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 8018548:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 801854c:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 8018550:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 8018554:	dd97      	ble.n	8018486 <cblas_ctrsm+0x8fe>
 8018556:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018558:	1d32      	adds	r2, r6, #4
 801855a:	1999      	adds	r1, r3, r6
 801855c:	4633      	mov	r3, r6
            const BASE Bij_real = REAL(B, ldb * i + j);
 801855e:	3308      	adds	r3, #8
 8018560:	3208      	adds	r2, #8
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018562:	ed53 6a01 	vldr	s13, [r3, #-4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018566:	ed12 6a03 	vldr	s12, [r2, #-12]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801856a:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801856e:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018572:	eea5 7a06 	vfma.f32	s14, s10, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018576:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801857a:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801857e:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018582:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018586:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 801858a:	4299      	cmp	r1, r3
 801858c:	d1e7      	bne.n	801855e <cblas_ctrsm+0x9d6>
 801858e:	e77a      	b.n	8018486 <cblas_ctrsm+0x8fe>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018590:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018594:	f040 8257 	bne.w	8018a46 <cblas_ctrsm+0xebe>
 8018598:	eef5 7a40 	vcmp.f32	s15, #0.0
 801859c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80185a0:	f040 8251 	bne.w	8018a46 <cblas_ctrsm+0xebe>
      for (i = 0; i < n1; i++) {
 80185a4:	9b00      	ldr	r3, [sp, #0]
 80185a6:	2b00      	cmp	r3, #0
 80185a8:	f77f adf8 	ble.w	801819c <cblas_ctrsm+0x614>
 80185ac:	9b02      	ldr	r3, [sp, #8]
 80185ae:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80185b2:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80185b6:	930e      	str	r3, [sp, #56]	; 0x38
 80185b8:	990e      	ldr	r1, [sp, #56]	; 0x38
 80185ba:	9a06      	ldr	r2, [sp, #24]
        for (i = 0; i < n1; i++) {
 80185bc:	f8dd 8008 	ldr.w	r8, [sp, #8]
 80185c0:	9f00      	ldr	r7, [sp, #0]
 80185c2:	3601      	adds	r6, #1
 80185c4:	00f3      	lsls	r3, r6, #3
 80185c6:	4608      	mov	r0, r1
 80185c8:	990a      	ldr	r1, [sp, #40]	; 0x28
 80185ca:	930c      	str	r3, [sp, #48]	; 0x30
 80185cc:	f1a3 0904 	sub.w	r9, r3, #4
 80185d0:	2600      	movs	r6, #0
 80185d2:	4410      	add	r0, r2
 80185d4:	4489      	add	r9, r1
 80185d6:	f1a3 0508 	sub.w	r5, r3, #8
 80185da:	1d13      	adds	r3, r2, #4
 80185dc:	960b      	str	r6, [sp, #44]	; 0x2c
 80185de:	900e      	str	r0, [sp, #56]	; 0x38
 80185e0:	9108      	str	r1, [sp, #32]
 80185e2:	4614      	mov	r4, r2
 80185e4:	930a      	str	r3, [sp, #40]	; 0x28
 80185e6:	f8cd 901c 	str.w	r9, [sp, #28]
        if (nonunit) {
 80185ea:	9b04      	ldr	r3, [sp, #16]
 80185ec:	2b83      	cmp	r3, #131	; 0x83
 80185ee:	f000 825a 	beq.w	8018aa6 <cblas_ctrsm+0xf1e>
        for (k = i + 1; k < n1; k++) {
 80185f2:	3601      	adds	r6, #1
 80185f4:	42b7      	cmp	r7, r6
 80185f6:	f77f add1 	ble.w	801819c <cblas_ctrsm+0x614>
 80185fa:	9b06      	ldr	r3, [sp, #24]
 80185fc:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8018600:	eb03 0ec8 	add.w	lr, r3, r8, lsl #3
 8018604:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8018606:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 801860a:	eb03 00c8 	add.w	r0, r3, r8, lsl #3
 801860e:	46b1      	mov	r9, r6
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8018610:	ed9c 5a00 	vldr	s10, [ip]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8018614:	ed5c 4a01 	vldr	s9, [ip, #-4]
          for (j = 0; j < n2; j++) {
 8018618:	f1bb 0f00 	cmp.w	fp, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 801861c:	ee24 5a05 	vmul.f32	s10, s8, s10
          for (j = 0; j < n2; j++) {
 8018620:	dd22      	ble.n	8018668 <cblas_ctrsm+0xae0>
 8018622:	f10e 0104 	add.w	r1, lr, #4
 8018626:	4673      	mov	r3, lr
 8018628:	4622      	mov	r2, r4
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801862a:	ed92 7a01 	vldr	s14, [r2, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 801862e:	edd2 5a00 	vldr	s11, [r2]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8018632:	ed51 6a01 	vldr	s13, [r1, #-4]
 8018636:	ee27 6a45 	vnmul.f32	s12, s14, s10
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 801863a:	ee65 7a25 	vmul.f32	s15, s10, s11
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 801863e:	eea4 6aa5 	vfma.f32	s12, s9, s11
 8018642:	3308      	adds	r3, #8
 8018644:	3208      	adds	r2, #8
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8018646:	eee4 7a87 	vfma.f32	s15, s9, s14
 801864a:	3108      	adds	r1, #8
 801864c:	eeb0 7a67 	vmov.f32	s14, s15
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8018650:	ee76 7ac6 	vsub.f32	s15, s13, s12
 8018654:	ed41 7a03 	vstr	s15, [r1, #-12]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8018658:	ed53 7a01 	vldr	s15, [r3, #-4]
 801865c:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8018660:	ed43 7a01 	vstr	s15, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018664:	4298      	cmp	r0, r3
 8018666:	d1e0      	bne.n	801862a <cblas_ctrsm+0xaa2>
        for (k = i + 1; k < n1; k++) {
 8018668:	f109 0901 	add.w	r9, r9, #1
 801866c:	454f      	cmp	r7, r9
 801866e:	44d6      	add	lr, sl
 8018670:	4450      	add	r0, sl
 8018672:	44ac      	add	ip, r5
 8018674:	d1cc      	bne.n	8018610 <cblas_ctrsm+0xa88>
 8018676:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8018678:	9b02      	ldr	r3, [sp, #8]
 801867a:	4611      	mov	r1, r2
 801867c:	9a07      	ldr	r2, [sp, #28]
 801867e:	4419      	add	r1, r3
 8018680:	910b      	str	r1, [sp, #44]	; 0x2c
 8018682:	4498      	add	r8, r3
 8018684:	4611      	mov	r1, r2
 8018686:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8018688:	9a08      	ldr	r2, [sp, #32]
 801868a:	4419      	add	r1, r3
 801868c:	441a      	add	r2, r3
 801868e:	4454      	add	r4, sl
 8018690:	9107      	str	r1, [sp, #28]
 8018692:	9208      	str	r2, [sp, #32]
 8018694:	e7a9      	b.n	80185ea <cblas_ctrsm+0xa62>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8018696:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801869a:	f040 827f 	bne.w	8018b9c <cblas_ctrsm+0x1014>
 801869e:	eef5 7a40 	vcmp.f32	s15, #0.0
 80186a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80186a6:	f040 8279 	bne.w	8018b9c <cblas_ctrsm+0x1014>
      for (i = 0; i < n1; i++) {
 80186aa:	9b00      	ldr	r3, [sp, #0]
 80186ac:	2b00      	cmp	r3, #0
 80186ae:	f77f ad75 	ble.w	801819c <cblas_ctrsm+0x614>
 80186b2:	9b02      	ldr	r3, [sp, #8]
 80186b4:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 80186b8:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 80186bc:	930e      	str	r3, [sp, #56]	; 0x38
 80186be:	9b06      	ldr	r3, [sp, #24]
 80186c0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80186c2:	f8cd a02c 	str.w	sl, [sp, #44]	; 0x2c
 80186c6:	f1a3 0408 	sub.w	r4, r3, #8
 80186ca:	3601      	adds	r6, #1
            for (k = j + 1; k < n2; k++) {
 80186cc:	2300      	movs	r3, #0
 80186ce:	f8dd a010 	ldr.w	sl, [sp, #16]
 80186d2:	9307      	str	r3, [sp, #28]
 80186d4:	00f7      	lsls	r7, r6, #3
 80186d6:	4414      	add	r4, r2
 80186d8:	9308      	str	r3, [sp, #32]
        for (j = 0; j < n2; j++) {
 80186da:	f1bb 0f00 	cmp.w	fp, #0
 80186de:	dd75      	ble.n	80187cc <cblas_ctrsm+0xc44>
 80186e0:	e9dd 3206 	ldrd	r3, r2, [sp, #24]
 80186e4:	990a      	ldr	r1, [sp, #40]	; 0x28
          if (nonunit) {
 80186e6:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 80186ea:	4688      	mov	r8, r1
 80186ec:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 80186f0:	f101 0904 	add.w	r9, r1, #4
        for (j = 0; j < n2; j++) {
 80186f4:	f04f 0600 	mov.w	r6, #0
          if (nonunit) {
 80186f8:	d02f      	beq.n	801875a <cblas_ctrsm+0xbd2>
            for (k = j + 1; k < n2; k++) {
 80186fa:	3601      	adds	r6, #1
 80186fc:	45b3      	cmp	fp, r6
 80186fe:	ed95 5a01 	vldr	s10, [r5, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018702:	edd5 4a00 	vldr	s9, [r5]
            for (k = j + 1; k < n2; k++) {
 8018706:	d061      	beq.n	80187cc <cblas_ctrsm+0xc44>
 8018708:	eeb8 4ac8 	vcvt.f32.s32	s8, s16
 801870c:	462b      	mov	r3, r5
 801870e:	4642      	mov	r2, r8
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8018710:	edd2 7a03 	vldr	s15, [r2, #12]
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8018714:	edd2 5a02 	vldr	s11, [r2, #8]
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8018718:	ed93 6a02 	vldr	s12, [r3, #8]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 801871c:	ed93 7a03 	vldr	s14, [r3, #12]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8018720:	ee64 7a27 	vmul.f32	s15, s8, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8018724:	3308      	adds	r3, #8
 8018726:	ee65 6a67 	vnmul.f32	s13, s10, s15
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 801872a:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 801872e:	eee4 6aa5 	vfma.f32	s13, s9, s11
 8018732:	3208      	adds	r2, #8
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8018734:	eee5 7a85 	vfma.f32	s15, s11, s10
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8018738:	ee76 6a66 	vsub.f32	s13, s12, s13
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 801873c:	ee77 7a67 	vsub.f32	s15, s14, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8018740:	edc3 6a00 	vstr	s13, [r3]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8018744:	edc3 7a01 	vstr	s15, [r3, #4]
            for (k = j + 1; k < n2; k++) {
 8018748:	429c      	cmp	r4, r3
 801874a:	d1e1      	bne.n	8018710 <cblas_ctrsm+0xb88>
          if (nonunit) {
 801874c:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 8018750:	44b8      	add	r8, r7
 8018752:	f105 0508 	add.w	r5, r5, #8
 8018756:	44b9      	add	r9, r7
 8018758:	d1cf      	bne.n	80186fa <cblas_ctrsm+0xb72>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 801875a:	edd9 7a00 	vldr	s15, [r9]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 801875e:	ed19 9a01 	vldr	s18, [r9, #-4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018762:	eef8 8ac8 	vcvt.f32.s32	s17, s16
            for (k = j + 1; k < n2; k++) {
 8018766:	3601      	adds	r6, #1
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8018768:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 801876c:	ee18 0a90 	vmov	r0, s17
 8018770:	f00f fb42 	bl	8027df8 <__aeabi_f2d>
 8018774:	4602      	mov	r2, r0
 8018776:	460b      	mov	r3, r1
 8018778:	ee19 0a10 	vmov	r0, s18
 801877c:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8018780:	f00f fb3a 	bl	8027df8 <__aeabi_f2d>
 8018784:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8018788:	f7ff f9c6 	bl	8017b18 <xhypot>
 801878c:	f00f fe3c 	bl	8028408 <__aeabi_d2f>
 8018790:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 8018794:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            for (k = j + 1; k < n2; k++) {
 8018798:	45b3      	cmp	fp, r6
            const BASE a_real = Ajj_real / s;
 801879a:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 801879e:	ed95 6a01 	vldr	s12, [r5, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80187a2:	ed95 5a00 	vldr	s10, [r5]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80187a6:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80187aa:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80187ae:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80187b2:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80187b6:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80187ba:	ee87 5a27 	vdiv.f32	s10, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80187be:	ed85 6a00 	vstr	s12, [r5]
            const BASE Bij_real = REAL(B, ldb * i + j);
 80187c2:	edd5 4a00 	vldr	s9, [r5]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80187c6:	ed85 5a01 	vstr	s10, [r5, #4]
            for (k = j + 1; k < n2; k++) {
 80187ca:	d19d      	bne.n	8018708 <cblas_ctrsm+0xb80>
      for (i = 0; i < n1; i++) {
 80187cc:	9a07      	ldr	r2, [sp, #28]
 80187ce:	9902      	ldr	r1, [sp, #8]
 80187d0:	9b08      	ldr	r3, [sp, #32]
 80187d2:	440a      	add	r2, r1
 80187d4:	9207      	str	r2, [sp, #28]
 80187d6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80187d8:	4414      	add	r4, r2
 80187da:	9a00      	ldr	r2, [sp, #0]
 80187dc:	3301      	adds	r3, #1
 80187de:	429a      	cmp	r2, r3
 80187e0:	9308      	str	r3, [sp, #32]
 80187e2:	f73f af7a 	bgt.w	80186da <cblas_ctrsm+0xb52>
 80187e6:	e4d9      	b.n	801819c <cblas_ctrsm+0x614>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80187e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80187ec:	f040 81a6 	bne.w	8018b3c <cblas_ctrsm+0xfb4>
 80187f0:	eef5 7a40 	vcmp.f32	s15, #0.0
 80187f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80187f8:	f040 81a0 	bne.w	8018b3c <cblas_ctrsm+0xfb4>
      for (i = 0; i < n1; i++) {
 80187fc:	9b00      	ldr	r3, [sp, #0]
 80187fe:	2b00      	cmp	r3, #0
 8018800:	f77f accc 	ble.w	801819c <cblas_ctrsm+0x614>
 8018804:	9b02      	ldr	r3, [sp, #8]
 8018806:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 801880a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 801880e:	930e      	str	r3, [sp, #56]	; 0x38
 8018810:	990e      	ldr	r1, [sp, #56]	; 0x38
 8018812:	f8cd a020 	str.w	sl, [sp, #32]
 8018816:	3908      	subs	r1, #8
 8018818:	f10b 33ff 	add.w	r3, fp, #4294967295
 801881c:	910e      	str	r1, [sp, #56]	; 0x38
 801881e:	990a      	ldr	r1, [sp, #40]	; 0x28
 8018820:	f8dd a010 	ldr.w	sl, [sp, #16]
 8018824:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8018828:	fb06 f203 	mul.w	r2, r6, r3
 801882c:	fb06 3303 	mla	r3, r6, r3, r3
 8018830:	ebc6 7946 	rsb	r9, r6, r6, lsl #29
 8018834:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 8018838:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 801883c:	43f6      	mvns	r6, r6
 801883e:	920a      	str	r2, [sp, #40]	; 0x28
 8018840:	930b      	str	r3, [sp, #44]	; 0x2c
        for (j = n2; j > 0 && j--;) {
 8018842:	2200      	movs	r2, #0
 8018844:	00f3      	lsls	r3, r6, #3
 8018846:	e9cd 2b06 	strd	r2, fp, [sp, #24]
 801884a:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 801884e:	469b      	mov	fp, r3
 8018850:	9d07      	ldr	r5, [sp, #28]
 8018852:	2d00      	cmp	r5, #0
 8018854:	dd75      	ble.n	8018942 <cblas_ctrsm+0xdba>
 8018856:	9b0e      	ldr	r3, [sp, #56]	; 0x38
          if (nonunit) {
 8018858:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
        for (j = n2; j > 0 && j--;) {
 801885c:	e9dd 670a 	ldrd	r6, r7, [sp, #40]	; 0x28
 8018860:	eb03 0408 	add.w	r4, r3, r8
 8018864:	f105 35ff 	add.w	r5, r5, #4294967295
          if (nonunit) {
 8018868:	d033      	beq.n	80188d2 <cblas_ctrsm+0xd4a>
            const BASE Bij_real = REAL(B, ldb * i + j);
 801886a:	edd4 5a01 	vldr	s11, [r4, #4]
 801886e:	ed94 5a00 	vldr	s10, [r4]
            for (k = 0; k < j; k++) {
 8018872:	2d00      	cmp	r5, #0
 8018874:	d065      	beq.n	8018942 <cblas_ctrsm+0xdba>
 8018876:	eef8 4ac8 	vcvt.f32.s32	s9, s16
 801887a:	f108 0104 	add.w	r1, r8, #4
 801887e:	4643      	mov	r3, r8
 8018880:	4632      	mov	r2, r6
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8018882:	edd2 7a01 	vldr	s15, [r2, #4]
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8018886:	ed92 6a00 	vldr	s12, [r2]
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 801888a:	ed51 6a01 	vldr	s13, [r1, #-4]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 801888e:	ee64 7aa7 	vmul.f32	s15, s9, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8018892:	3308      	adds	r3, #8
 8018894:	ee25 7ae7 	vnmul.f32	s14, s11, s15
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8018898:	ee65 7a27 	vmul.f32	s15, s10, s15
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 801889c:	eea5 7a06 	vfma.f32	s14, s10, s12
 80188a0:	3208      	adds	r2, #8
 80188a2:	3108      	adds	r1, #8
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 80188a4:	eee6 7a25 	vfma.f32	s15, s12, s11
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80188a8:	ee36 7ac7 	vsub.f32	s14, s13, s14
 80188ac:	ed01 7a03 	vstr	s14, [r1, #-12]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 80188b0:	ed13 7a01 	vldr	s14, [r3, #-4]
 80188b4:	ee77 7a67 	vsub.f32	s15, s14, s15
 80188b8:	ed43 7a01 	vstr	s15, [r3, #-4]
            for (k = 0; k < j; k++) {
 80188bc:	42a3      	cmp	r3, r4
 80188be:	d1e0      	bne.n	8018882 <cblas_ctrsm+0xcfa>
          if (nonunit) {
 80188c0:	f1ba 0f83 	cmp.w	sl, #131	; 0x83
 80188c4:	444e      	add	r6, r9
 80188c6:	f1a4 0408 	sub.w	r4, r4, #8
 80188ca:	445f      	add	r7, fp
        for (j = n2; j > 0 && j--;) {
 80188cc:	f105 35ff 	add.w	r5, r5, #4294967295
          if (nonunit) {
 80188d0:	d1cb      	bne.n	801886a <cblas_ctrsm+0xce2>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 80188d2:	edd7 7a01 	vldr	s15, [r7, #4]
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 80188d6:	ed97 9a00 	vldr	s18, [r7]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 80188da:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 80188de:	ee68 8aa7 	vmul.f32	s17, s17, s15
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 80188e2:	ee18 0a90 	vmov	r0, s17
 80188e6:	f00f fa87 	bl	8027df8 <__aeabi_f2d>
 80188ea:	4602      	mov	r2, r0
 80188ec:	460b      	mov	r3, r1
 80188ee:	ee19 0a10 	vmov	r0, s18
 80188f2:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80188f6:	f00f fa7f 	bl	8027df8 <__aeabi_f2d>
 80188fa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80188fe:	f7ff f90b 	bl	8017b18 <xhypot>
 8018902:	f00f fd81 	bl	8028408 <__aeabi_d2f>
 8018906:	ee07 0a90 	vmov	s15, r0
            const BASE a_imag = Ajj_imag / s;
 801890a:	ee88 7aa7 	vdiv.f32	s14, s17, s15
            const BASE a_real = Ajj_real / s;
 801890e:	eec9 5a27 	vdiv.f32	s11, s18, s15
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018912:	ed94 6a01 	vldr	s12, [r4, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018916:	ed94 5a00 	vldr	s10, [r4]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801891a:	ee67 6a06 	vmul.f32	s13, s14, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801891e:	ee25 7a47 	vnmul.f32	s14, s10, s14
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018922:	eee5 6a85 	vfma.f32	s13, s11, s10
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018926:	eea5 7a86 	vfma.f32	s14, s11, s12
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 801892a:	ee86 6aa7 	vdiv.f32	s12, s13, s15
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801892e:	eec7 5a27 	vdiv.f32	s11, s14, s15
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018932:	ed84 6a00 	vstr	s12, [r4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018936:	ed94 5a00 	vldr	s10, [r4]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 801893a:	edc4 5a01 	vstr	s11, [r4, #4]
            for (k = 0; k < j; k++) {
 801893e:	2d00      	cmp	r5, #0
 8018940:	d199      	bne.n	8018876 <cblas_ctrsm+0xcee>
      for (i = 0; i < n1; i++) {
 8018942:	9a08      	ldr	r2, [sp, #32]
 8018944:	9b06      	ldr	r3, [sp, #24]
 8018946:	4490      	add	r8, r2
 8018948:	9a00      	ldr	r2, [sp, #0]
 801894a:	3301      	adds	r3, #1
 801894c:	429a      	cmp	r2, r3
 801894e:	9306      	str	r3, [sp, #24]
 8018950:	f73f af7e 	bgt.w	8018850 <cblas_ctrsm+0xcc8>
 8018954:	e422      	b.n	801819c <cblas_ctrsm+0x614>
        for (i = 0; i < n1; i++) {
 8018956:	9f00      	ldr	r7, [sp, #0]
 8018958:	2f00      	cmp	r7, #0
 801895a:	f77f ac1f 	ble.w	801819c <cblas_ctrsm+0x614>
 801895e:	9b02      	ldr	r3, [sp, #8]
 8018960:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018964:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018968:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 801896c:	930e      	str	r3, [sp, #56]	; 0x38
 801896e:	9b06      	ldr	r3, [sp, #24]
 8018970:	00e4      	lsls	r4, r4, #3
 8018972:	1d25      	adds	r5, r4, #4
 8018974:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018978:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 801897a:	f1bb 0f00 	cmp.w	fp, #0
 801897e:	dd15      	ble.n	80189ac <cblas_ctrsm+0xe24>
 8018980:	1863      	adds	r3, r4, r1
 8018982:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018984:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018988:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801898c:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018990:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018994:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018998:	3308      	adds	r3, #8
 801899a:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801899c:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80189a0:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80189a4:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 80189a8:	4299      	cmp	r1, r3
 80189aa:	d1eb      	bne.n	8018984 <cblas_ctrsm+0xdfc>
        for (i = 0; i < n1; i++) {
 80189ac:	3001      	adds	r0, #1
 80189ae:	4287      	cmp	r7, r0
 80189b0:	4451      	add	r1, sl
 80189b2:	d1e2      	bne.n	801897a <cblas_ctrsm+0xdf2>
 80189b4:	e54c      	b.n	8018450 <cblas_ctrsm+0x8c8>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80189b6:	9b07      	ldr	r3, [sp, #28]
 80189b8:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 80189bc:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 80189c0:	ed93 9a00 	vldr	s18, [r3]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80189c4:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 80189c8:	ee18 0a90 	vmov	r0, s17
 80189cc:	f00f fa14 	bl	8027df8 <__aeabi_f2d>
 80189d0:	4602      	mov	r2, r0
 80189d2:	460b      	mov	r3, r1
 80189d4:	ee19 0a10 	vmov	r0, s18
 80189d8:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
 80189dc:	f00f fa0c 	bl	8027df8 <__aeabi_f2d>
 80189e0:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 80189e4:	f7ff f898 	bl	8017b18 <xhypot>
 80189e8:	f00f fd0e 	bl	8028408 <__aeabi_d2f>
 80189ec:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 80189f0:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 80189f4:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 80189f8:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 80189fc:	f77f ac33 	ble.w	8018266 <cblas_ctrsm+0x6de>
 8018a00:	9b06      	ldr	r3, [sp, #24]
 8018a02:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8018a04:	eb0b 0109 	add.w	r1, fp, r9
 8018a08:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8018a0c:	eb02 02c9 	add.w	r2, r2, r9, lsl #3
 8018a10:	eb03 03c9 	add.w	r3, r3, r9, lsl #3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018a14:	3308      	adds	r3, #8
 8018a16:	3208      	adds	r2, #8
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018a18:	ed53 6a01 	vldr	s13, [r3, #-4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018a1c:	ed12 6a03 	vldr	s12, [r2, #-12]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018a20:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018a24:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018a28:	eea5 7a06 	vfma.f32	s14, s10, s12
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018a2c:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018a30:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018a34:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018a38:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018a3c:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018a40:	4299      	cmp	r1, r3
 8018a42:	d1e7      	bne.n	8018a14 <cblas_ctrsm+0xe8c>
 8018a44:	e40f      	b.n	8018266 <cblas_ctrsm+0x6de>
        for (i = 0; i < n1; i++) {
 8018a46:	9f00      	ldr	r7, [sp, #0]
 8018a48:	2f00      	cmp	r7, #0
 8018a4a:	f77f aba7 	ble.w	801819c <cblas_ctrsm+0x614>
 8018a4e:	9b02      	ldr	r3, [sp, #8]
 8018a50:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018a54:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018a58:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018a5c:	930e      	str	r3, [sp, #56]	; 0x38
 8018a5e:	9b06      	ldr	r3, [sp, #24]
 8018a60:	00e4      	lsls	r4, r4, #3
 8018a62:	1d25      	adds	r5, r4, #4
 8018a64:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018a68:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018a6a:	f1bb 0f00 	cmp.w	fp, #0
 8018a6e:	dd15      	ble.n	8018a9c <cblas_ctrsm+0xf14>
 8018a70:	1863      	adds	r3, r4, r1
 8018a72:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018a74:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018a78:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018a7c:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018a80:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018a84:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018a88:	3308      	adds	r3, #8
 8018a8a:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018a8c:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018a90:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018a94:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018a98:	4299      	cmp	r1, r3
 8018a9a:	d1eb      	bne.n	8018a74 <cblas_ctrsm+0xeec>
        for (i = 0; i < n1; i++) {
 8018a9c:	3001      	adds	r0, #1
 8018a9e:	4287      	cmp	r7, r0
 8018aa0:	4451      	add	r1, sl
 8018aa2:	d1e2      	bne.n	8018a6a <cblas_ctrsm+0xee2>
 8018aa4:	e588      	b.n	80185b8 <cblas_ctrsm+0xa30>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8018aa6:	9b08      	ldr	r3, [sp, #32]
 8018aa8:	eef8 8ac8 	vcvt.f32.s32	s17, s16
 8018aac:	edd3 7a01 	vldr	s15, [r3, #4]
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8018ab0:	ed93 9a00 	vldr	s18, [r3]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8018ab4:	ee68 8aa7 	vmul.f32	s17, s17, s15
          const BASE s = xhypot(Aii_real, Aii_imag);
 8018ab8:	ee18 0a90 	vmov	r0, s17
 8018abc:	f00f f99c 	bl	8027df8 <__aeabi_f2d>
 8018ac0:	4602      	mov	r2, r0
 8018ac2:	460b      	mov	r3, r1
 8018ac4:	ee19 0a10 	vmov	r0, s18
 8018ac8:	e9cd 2300 	strd	r2, r3, [sp]
 8018acc:	f00f f994 	bl	8027df8 <__aeabi_f2d>
 8018ad0:	e9dd 2300 	ldrd	r2, r3, [sp]
 8018ad4:	f7ff f820 	bl	8017b18 <xhypot>
 8018ad8:	f00f fc96 	bl	8028408 <__aeabi_d2f>
 8018adc:	ee05 0a90 	vmov	s11, r0
          for (j = 0; j < n2; j++) {
 8018ae0:	f1bb 0f00 	cmp.w	fp, #0
          const BASE a_imag = Aii_imag / s;
 8018ae4:	eec8 4aa5 	vdiv.f32	s9, s17, s11
          const BASE a_real = Aii_real / s;
 8018ae8:	ee89 5a25 	vdiv.f32	s10, s18, s11
          for (j = 0; j < n2; j++) {
 8018aec:	f77f ad81 	ble.w	80185f2 <cblas_ctrsm+0xa6a>
 8018af0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8018af2:	9a06      	ldr	r2, [sp, #24]
 8018af4:	eb0b 0103 	add.w	r1, fp, r3
 8018af8:	4610      	mov	r0, r2
 8018afa:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
 8018afe:	461a      	mov	r2, r3
 8018b00:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8018b04:	980a      	ldr	r0, [sp, #40]	; 0x28
 8018b06:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018b0a:	edd3 6a01 	vldr	s13, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018b0e:	ed12 6a01 	vldr	s12, [r2, #-4]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018b12:	ee24 7aa6 	vmul.f32	s14, s9, s13
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018b16:	ee66 7a64 	vnmul.f32	s15, s12, s9
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018b1a:	eea5 7a06 	vfma.f32	s14, s10, s12
 8018b1e:	3308      	adds	r3, #8
 8018b20:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018b22:	eee5 7a26 	vfma.f32	s15, s10, s13
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018b26:	eec7 6a25 	vdiv.f32	s13, s14, s11
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018b2a:	ee87 7aa5 	vdiv.f32	s14, s15, s11
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8018b2e:	ed42 6a03 	vstr	s13, [r2, #-12]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8018b32:	ed03 7a01 	vstr	s14, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018b36:	4299      	cmp	r1, r3
 8018b38:	d1e7      	bne.n	8018b0a <cblas_ctrsm+0xf82>
 8018b3a:	e55a      	b.n	80185f2 <cblas_ctrsm+0xa6a>
        for (i = 0; i < n1; i++) {
 8018b3c:	9f00      	ldr	r7, [sp, #0]
 8018b3e:	2f00      	cmp	r7, #0
 8018b40:	f77f ab2c 	ble.w	801819c <cblas_ctrsm+0x614>
 8018b44:	9b02      	ldr	r3, [sp, #8]
 8018b46:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018b4a:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018b4e:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018b52:	930e      	str	r3, [sp, #56]	; 0x38
 8018b54:	9b06      	ldr	r3, [sp, #24]
 8018b56:	00e4      	lsls	r4, r4, #3
 8018b58:	1d25      	adds	r5, r4, #4
 8018b5a:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018b5e:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018b60:	f1bb 0f00 	cmp.w	fp, #0
 8018b64:	dd15      	ble.n	8018b92 <cblas_ctrsm+0x100a>
 8018b66:	190b      	adds	r3, r1, r4
 8018b68:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018b6a:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018b6e:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018b72:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018b76:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018b7a:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018b7e:	3308      	adds	r3, #8
 8018b80:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018b82:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018b86:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018b8a:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018b8e:	428b      	cmp	r3, r1
 8018b90:	d1eb      	bne.n	8018b6a <cblas_ctrsm+0xfe2>
        for (i = 0; i < n1; i++) {
 8018b92:	3001      	adds	r0, #1
 8018b94:	4287      	cmp	r7, r0
 8018b96:	4451      	add	r1, sl
 8018b98:	d1e2      	bne.n	8018b60 <cblas_ctrsm+0xfd8>
 8018b9a:	e639      	b.n	8018810 <cblas_ctrsm+0xc88>
        for (i = 0; i < n1; i++) {
 8018b9c:	9f00      	ldr	r7, [sp, #0]
 8018b9e:	2f00      	cmp	r7, #0
 8018ba0:	f77f aafc 	ble.w	801819c <cblas_ctrsm+0x614>
 8018ba4:	9b02      	ldr	r3, [sp, #8]
 8018ba6:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
 8018baa:	ea4f 03cb 	mov.w	r3, fp, lsl #3
 8018bae:	ebcb 744b 	rsb	r4, fp, fp, lsl #29
 8018bb2:	930e      	str	r3, [sp, #56]	; 0x38
 8018bb4:	9b06      	ldr	r3, [sp, #24]
 8018bb6:	00e4      	lsls	r4, r4, #3
 8018bb8:	1d25      	adds	r5, r4, #4
 8018bba:	eb03 01cb 	add.w	r1, r3, fp, lsl #3
 8018bbe:	2000      	movs	r0, #0
          for (j = 0; j < n2; j++) {
 8018bc0:	f1bb 0f00 	cmp.w	fp, #0
 8018bc4:	dd15      	ble.n	8018bf2 <cblas_ctrsm+0x106a>
 8018bc6:	190b      	adds	r3, r1, r4
 8018bc8:	186a      	adds	r2, r5, r1
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8018bca:	edd3 5a01 	vldr	s11, [r3, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8018bce:	ed12 5a01 	vldr	s10, [r2, #-4]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018bd2:	ee27 6ae5 	vnmul.f32	s12, s15, s11
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018bd6:	ee65 6a27 	vmul.f32	s13, s10, s15
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018bda:	eea5 6a07 	vfma.f32	s12, s10, s14
 8018bde:	3308      	adds	r3, #8
 8018be0:	3208      	adds	r2, #8
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018be2:	eee5 6a87 	vfma.f32	s13, s11, s14
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8018be6:	ed02 6a03 	vstr	s12, [r2, #-12]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8018bea:	ed43 6a01 	vstr	s13, [r3, #-4]
          for (j = 0; j < n2; j++) {
 8018bee:	428b      	cmp	r3, r1
 8018bf0:	d1eb      	bne.n	8018bca <cblas_ctrsm+0x1042>
        for (i = 0; i < n1; i++) {
 8018bf2:	3001      	adds	r0, #1
 8018bf4:	4287      	cmp	r7, r0
 8018bf6:	4451      	add	r1, sl
 8018bf8:	d1e2      	bne.n	8018bc0 <cblas_ctrsm+0x1038>
 8018bfa:	e560      	b.n	80186be <cblas_ctrsm+0xb36>

08018bfc <xhypot>:
{
 8018bfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 8018bfe:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 8018c02:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  if (xabs < yabs) {
 8018c06:	4639      	mov	r1, r7
 8018c08:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 8018c0a:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 8018c0c:	4614      	mov	r4, r2
  if (xabs < yabs) {
 8018c0e:	f00f fbbd 	bl	802838c <__aeabi_dcmplt>
 8018c12:	b928      	cbnz	r0, 8018c20 <xhypot+0x24>
 8018c14:	4632      	mov	r2, r6
 8018c16:	463b      	mov	r3, r7
    min = yabs ;
 8018c18:	4626      	mov	r6, r4
 8018c1a:	462f      	mov	r7, r5
    max = xabs ;
 8018c1c:	4614      	mov	r4, r2
 8018c1e:	461d      	mov	r5, r3
  if (min == 0) 
 8018c20:	2200      	movs	r2, #0
 8018c22:	2300      	movs	r3, #0
 8018c24:	4630      	mov	r0, r6
 8018c26:	4639      	mov	r1, r7
 8018c28:	f00f fba6 	bl	8028378 <__aeabi_dcmpeq>
 8018c2c:	b9c8      	cbnz	r0, 8018c62 <xhypot+0x66>
    double u = min / max ;
 8018c2e:	4622      	mov	r2, r4
 8018c30:	462b      	mov	r3, r5
 8018c32:	4630      	mov	r0, r6
 8018c34:	4639      	mov	r1, r7
 8018c36:	f00f fa61 	bl	80280fc <__aeabi_ddiv>
 8018c3a:	4602      	mov	r2, r0
 8018c3c:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 8018c3e:	f00f f933 	bl	8027ea8 <__aeabi_dmul>
 8018c42:	4b09      	ldr	r3, [pc, #36]	; (8018c68 <xhypot+0x6c>)
 8018c44:	2200      	movs	r2, #0
 8018c46:	f00e ff79 	bl	8027b3c <__adddf3>
 8018c4a:	ec41 0b10 	vmov	d0, r0, r1
 8018c4e:	f017 f923 	bl	802fe98 <sqrt>
 8018c52:	4620      	mov	r0, r4
 8018c54:	4629      	mov	r1, r5
 8018c56:	ec53 2b10 	vmov	r2, r3, d0
 8018c5a:	f00f f925 	bl	8027ea8 <__aeabi_dmul>
 8018c5e:	4604      	mov	r4, r0
 8018c60:	460d      	mov	r5, r1
}
 8018c62:	4620      	mov	r0, r4
 8018c64:	4629      	mov	r1, r5
 8018c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8018c68:	3ff00000 	.word	0x3ff00000

08018c6c <cblas_ctrsv>:
void
cblas_ctrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 8018c6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018c70:	ed2d 8b06 	vpush	{d8-d10}
 8018c74:	b089      	sub	sp, #36	; 0x24
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

{
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018c76:	2a71      	cmp	r2, #113	; 0x71
 8018c78:	9302      	str	r3, [sp, #8]
 8018c7a:	e9dd b318 	ldrd	fp, r3, [sp, #96]	; 0x60
 8018c7e:	9300      	str	r3, [sp, #0]
 8018c80:	e9dd 731a 	ldrd	r7, r3, [sp, #104]	; 0x68
 8018c84:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 8018c86:	9303      	str	r3, [sp, #12]
 8018c88:	4681      	mov	r9, r0
 8018c8a:	4688      	mov	r8, r1
  const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
  const int nonunit = (Diag == CblasNonUnit);
  INDEX i, j;
  INDEX ix, jx;

  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018c8c:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018c90:	f000 8120 	beq.w	8018ed4 <cblas_ctrsv+0x268>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018c94:	2b01      	cmp	r3, #1
 8018c96:	4692      	mov	sl, r2
 8018c98:	d942      	bls.n	8018d20 <cblas_ctrsv+0xb4>
 8018c9a:	2002      	movs	r0, #2
 8018c9c:	3a6f      	subs	r2, #111	; 0x6f
 8018c9e:	2a02      	cmp	r2, #2
 8018ca0:	ed9f 8ad4 	vldr	s16, [pc, #848]	; 8018ff4 <cblas_ctrsv+0x388>
 8018ca4:	bf88      	it	hi
 8018ca6:	2003      	movhi	r0, #3
 8018ca8:	9b02      	ldr	r3, [sp, #8]
 8018caa:	337d      	adds	r3, #125	; 0x7d
 8018cac:	b2db      	uxtb	r3, r3
 8018cae:	2b01      	cmp	r3, #1
 8018cb0:	f240 80ff 	bls.w	8018eb2 <cblas_ctrsv+0x246>
 8018cb4:	f1bb 0f00 	cmp.w	fp, #0
 8018cb8:	f2c0 80f3 	blt.w	8018ea2 <cblas_ctrsv+0x236>
 8018cbc:	465b      	mov	r3, fp
 8018cbe:	2b01      	cmp	r3, #1
 8018cc0:	bfb8      	it	lt
 8018cc2:	2301      	movlt	r3, #1
 8018cc4:	42bb      	cmp	r3, r7
 8018cc6:	f340 818f 	ble.w	8018fe8 <cblas_ctrsv+0x37c>
 8018cca:	2c00      	cmp	r4, #0
 8018ccc:	bf0c      	ite	eq
 8018cce:	2009      	moveq	r0, #9
 8018cd0:	2007      	movne	r0, #7
 8018cd2:	4ac9      	ldr	r2, [pc, #804]	; (8018ff8 <cblas_ctrsv+0x38c>)
 8018cd4:	49c9      	ldr	r1, [pc, #804]	; (8018ffc <cblas_ctrsv+0x390>)
 8018cd6:	f00e feb7 	bl	8027a48 <cblas_xerbla>

  if (N == 0)
 8018cda:	f1bb 0f00 	cmp.w	fp, #0
 8018cde:	f000 80db 	beq.w	8018e98 <cblas_ctrsv+0x22c>
    return;

  /* form  x := inv( A )*x */

  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8018ce2:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 8018ce6:	f000 80fe 	beq.w	8018ee6 <cblas_ctrsv+0x27a>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8018cea:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 8018cee:	d10d      	bne.n	8018d0c <cblas_ctrsv+0xa0>
 8018cf0:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 8018cf4:	d01a      	beq.n	8018d2c <cblas_ctrsv+0xc0>
        IMAG(X, ix) = tmp_imag;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8018cf6:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8018cfa:	d107      	bne.n	8018d0c <cblas_ctrsv+0xa0>
 8018cfc:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8018d00:	f000 81ec 	beq.w	80190dc <cblas_ctrsv+0x470>
        IMAG(X, ix) = tmp_imag;
      }
      ix += incX;
    }
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 8018d04:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8018d08:	f000 80fd 	beq.w	8018f06 <cblas_ctrsv+0x29a>
        IMAG(X, ix) = tmp_imag;
      }
      ix -= incX;
    }
  } else {
    BLAS_ERROR("unrecognized operation");
 8018d0c:	4abc      	ldr	r2, [pc, #752]	; (8019000 <cblas_ctrsv+0x394>)
 8018d0e:	49bb      	ldr	r1, [pc, #748]	; (8018ffc <cblas_ctrsv+0x390>)
 8018d10:	2000      	movs	r0, #0
#define BASE float
#include "source_trsv_c.h"
#undef BASE
}
 8018d12:	b009      	add	sp, #36	; 0x24
 8018d14:	ecbd 8b06 	vpop	{d8-d10}
 8018d18:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018d1c:	f00e be94 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018d20:	3865      	subs	r0, #101	; 0x65
 8018d22:	2801      	cmp	r0, #1
 8018d24:	bf94      	ite	ls
 8018d26:	2000      	movls	r0, #0
 8018d28:	2001      	movhi	r0, #1
 8018d2a:	e7b7      	b.n	8018c9c <cblas_ctrsv+0x30>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8018d2c:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8018d30:	f040 81c5 	bne.w	80190be <cblas_ctrsv+0x452>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8018d34:	2c00      	cmp	r4, #0
    if (nonunit) {
 8018d36:	9b02      	ldr	r3, [sp, #8]
    ix = OFFSET(N, incX) + incX * (N - 1);
 8018d38:	bfd8      	it	le
 8018d3a:	f1c4 0800 	rsble	r8, r4, #0
 8018d3e:	f10b 39ff 	add.w	r9, fp, #4294967295
 8018d42:	bfcc      	ite	gt
 8018d44:	f04f 0800 	movgt.w	r8, #0
 8018d48:	fb09 f808 	mulle.w	r8, r9, r8
    if (nonunit) {
 8018d4c:	2b83      	cmp	r3, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 8018d4e:	fb09 8804 	mla	r8, r9, r4, r8
    if (nonunit) {
 8018d52:	d13f      	bne.n	8018dd4 <cblas_ctrsv+0x168>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8018d54:	9a00      	ldr	r2, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8018d56:	9e03      	ldr	r6, [sp, #12]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8018d58:	fb09 9307 	mla	r3, r9, r7, r9
 8018d5c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8018d60:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8018d64:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8018d68:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 8018d6c:	eb06 03c8 	add.w	r3, r6, r8, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8018d70:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 8018d74:	3304      	adds	r3, #4
      const BASE s = xhypot(a_real, a_imag);
 8018d76:	ee18 0a90 	vmov	r0, s17
      const BASE x_imag = IMAG(X, ix);
 8018d7a:	461d      	mov	r5, r3
      const BASE s = xhypot(a_real, a_imag);
 8018d7c:	f00f f83c 	bl	8027df8 <__aeabi_f2d>
 8018d80:	4602      	mov	r2, r0
 8018d82:	460b      	mov	r3, r1
 8018d84:	ee1a 0a10 	vmov	r0, s20
 8018d88:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 8018d8c:	eb06 0ac8 	add.w	sl, r6, r8, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 8018d90:	f00f f832 	bl	8027df8 <__aeabi_f2d>
 8018d94:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 8018d98:	ed95 9a00 	vldr	s18, [r5]
      const BASE x_real = REAL(X, ix);
 8018d9c:	edda 9a00 	vldr	s19, [sl]
      const BASE s = xhypot(a_real, a_imag);
 8018da0:	f7ff ff2c 	bl	8018bfc <xhypot>
 8018da4:	f00f fb30 	bl	8028408 <__aeabi_d2f>
 8018da8:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 8018dac:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 8018db0:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8018db4:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8018db8:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8018dbc:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8018dc0:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8018dc4:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8018dc8:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8018dcc:	ed8a 6a00 	vstr	s12, [sl]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8018dd0:	edc5 6a00 	vstr	s13, [r5]
    for (i = N - 1; i > 0 && i--;) {
 8018dd4:	f1b9 0f00 	cmp.w	r9, #0
    ix -= incX;
 8018dd8:	eba8 0804 	sub.w	r8, r8, r4
    for (i = N - 1; i > 0 && i--;) {
 8018ddc:	dd5c      	ble.n	8018e98 <cblas_ctrsv+0x22c>
 8018dde:	f109 33ff 	add.w	r3, r9, #4294967295
 8018de2:	fb07 f103 	mul.w	r1, r7, r3
 8018de6:	fb07 3303 	mla	r3, r7, r3, r3
 8018dea:	00db      	lsls	r3, r3, #3
 8018dec:	eb01 0209 	add.w	r2, r1, r9
 8018df0:	9306      	str	r3, [sp, #24]
 8018df2:	9b00      	ldr	r3, [sp, #0]
 8018df4:	9803      	ldr	r0, [sp, #12]
 8018df6:	eb0b 0601 	add.w	r6, fp, r1
 8018dfa:	ebc2 7c42 	rsb	ip, r2, r2, lsl #29
 8018dfe:	ebc4 7144 	rsb	r1, r4, r4, lsl #29
 8018e02:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
 8018e06:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 8018e0a:	ea4f 03cc 	mov.w	r3, ip, lsl #3
 8018e0e:	00e4      	lsls	r4, r4, #3
 8018e10:	9307      	str	r3, [sp, #28]
 8018e12:	00cb      	lsls	r3, r1, #3
 8018e14:	eb00 08c8 	add.w	r8, r0, r8, lsl #3
 8018e18:	9300      	str	r3, [sp, #0]
 8018e1a:	43f8      	mvns	r0, r7
 8018e1c:	1f23      	subs	r3, r4, #4
 8018e1e:	ebc7 7747 	rsb	r7, r7, r7, lsl #29
 8018e22:	f108 0804 	add.w	r8, r8, #4
 8018e26:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
 8018e2a:	00ff      	lsls	r7, r7, #3
 8018e2c:	9303      	str	r3, [sp, #12]
      for (j = i + 1; j < N; j++) {
 8018e2e:	45cb      	cmp	fp, r9
      BASE tmp_real = REAL(X, ix);
 8018e30:	ed58 8a01 	vldr	s17, [r8, #-4]
      BASE tmp_imag = IMAG(X, ix);
 8018e34:	ed98 9a00 	vldr	s18, [r8]
      for (j = i + 1; j < N; j++) {
 8018e38:	dd1f      	ble.n	8018e7a <cblas_ctrsv+0x20e>
 8018e3a:	9b03      	ldr	r3, [sp, #12]
 8018e3c:	eeb8 5ac8 	vcvt.f32.s32	s10, s16
 8018e40:	eb03 0208 	add.w	r2, r3, r8
 8018e44:	462b      	mov	r3, r5
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8018e46:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_imag = IMAG(X, jx);
 8018e4a:	edd2 6a01 	vldr	s13, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8018e4e:	edd2 5a00 	vldr	s11, [r2]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8018e52:	ed93 6a00 	vldr	s12, [r3]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8018e56:	ee65 7a27 	vmul.f32	s15, s10, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8018e5a:	3308      	adds	r3, #8
 8018e5c:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8018e60:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8018e64:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = i + 1; j < N; j++) {
 8018e68:	429e      	cmp	r6, r3
 8018e6a:	4422      	add	r2, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8018e6c:	eee6 7a26 	vfma.f32	s15, s12, s13
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8018e70:	ee78 8ac7 	vsub.f32	s17, s17, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8018e74:	ee39 9a67 	vsub.f32	s18, s18, s15
      for (j = i + 1; j < N; j++) {
 8018e78:	d1e5      	bne.n	8018e46 <cblas_ctrsv+0x1da>
      if (nonunit) {
 8018e7a:	9b02      	ldr	r3, [sp, #8]
 8018e7c:	2b83      	cmp	r3, #131	; 0x83
 8018e7e:	f000 8180 	beq.w	8019182 <cblas_ctrsv+0x516>
        REAL(X, ix) = tmp_real;
 8018e82:	ed48 8a01 	vstr	s17, [r8, #-4]
        IMAG(X, ix) = tmp_imag;
 8018e86:	ed88 9a00 	vstr	s18, [r8]
    for (i = N - 1; i > 0 && i--;) {
 8018e8a:	9b00      	ldr	r3, [sp, #0]
 8018e8c:	f1b9 0901 	subs.w	r9, r9, #1
 8018e90:	4455      	add	r5, sl
 8018e92:	443e      	add	r6, r7
 8018e94:	4498      	add	r8, r3
 8018e96:	d1ca      	bne.n	8018e2e <cblas_ctrsv+0x1c2>
 8018e98:	b009      	add	sp, #36	; 0x24
 8018e9a:	ecbd 8b06 	vpop	{d8-d10}
 8018e9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018ea2:	2f00      	cmp	r7, #0
 8018ea4:	f77f af11 	ble.w	8018cca <cblas_ctrsv+0x5e>
 8018ea8:	2c00      	cmp	r4, #0
 8018eaa:	bf0c      	ite	eq
 8018eac:	2009      	moveq	r0, #9
 8018eae:	2005      	movne	r0, #5
 8018eb0:	e70f      	b.n	8018cd2 <cblas_ctrsv+0x66>
 8018eb2:	f1bb 0f00 	cmp.w	fp, #0
 8018eb6:	dbf4      	blt.n	8018ea2 <cblas_ctrsv+0x236>
 8018eb8:	465b      	mov	r3, fp
 8018eba:	2b01      	cmp	r3, #1
 8018ebc:	bfb8      	it	lt
 8018ebe:	2301      	movlt	r3, #1
 8018ec0:	42bb      	cmp	r3, r7
 8018ec2:	f73f af02 	bgt.w	8018cca <cblas_ctrsv+0x5e>
 8018ec6:	2c00      	cmp	r4, #0
 8018ec8:	f000 8223 	beq.w	8019312 <cblas_ctrsv+0x6a6>
 8018ecc:	2800      	cmp	r0, #0
 8018ece:	f43f af04 	beq.w	8018cda <cblas_ctrsv+0x6e>
 8018ed2:	e6fe      	b.n	8018cd2 <cblas_ctrsv+0x66>
 8018ed4:	2b01      	cmp	r3, #1
 8018ed6:	f240 80f7 	bls.w	80190c8 <cblas_ctrsv+0x45c>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8018eda:	ed9f 8a4a 	vldr	s16, [pc, #296]	; 8019004 <cblas_ctrsv+0x398>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018ede:	f04f 0a70 	mov.w	sl, #112	; 0x70
 8018ee2:	2002      	movs	r0, #2
 8018ee4:	e6e0      	b.n	8018ca8 <cblas_ctrsv+0x3c>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8018ee6:	f1ba 0f6f 	cmp.w	sl, #111	; 0x6f
 8018eea:	f000 808d 	beq.w	8019008 <cblas_ctrsv+0x39c>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8018eee:	f1ba 0f70 	cmp.w	sl, #112	; 0x70
 8018ef2:	f47f af0b 	bne.w	8018d0c <cblas_ctrsv+0xa0>
 8018ef6:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 8018efa:	f000 80ef 	beq.w	80190dc <cblas_ctrsv+0x470>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8018efe:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8018f02:	f47f af03 	bne.w	8018d0c <cblas_ctrsv+0xa0>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8018f06:	2c00      	cmp	r4, #0
    if (nonunit) {
 8018f08:	9b02      	ldr	r3, [sp, #8]
    ix = OFFSET(N, incX) + incX * (N - 1);
 8018f0a:	bfd8      	it	le
 8018f0c:	f1c4 0800 	rsble	r8, r4, #0
 8018f10:	f10b 3aff 	add.w	sl, fp, #4294967295
 8018f14:	bfcc      	ite	gt
 8018f16:	f04f 0800 	movgt.w	r8, #0
 8018f1a:	fb0a f808 	mulle.w	r8, sl, r8
    if (nonunit) {
 8018f1e:	2b83      	cmp	r3, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 8018f20:	fb0a 8804 	mla	r8, sl, r4, r8
    if (nonunit) {
 8018f24:	f000 8205 	beq.w	8019332 <cblas_ctrsv+0x6c6>
    for (i = N - 1; i > 0 && i--;) {
 8018f28:	f1ba 0f00 	cmp.w	sl, #0
    ix -= incX;
 8018f2c:	eba8 0804 	sub.w	r8, r8, r4
    for (i = N - 1; i > 0 && i--;) {
 8018f30:	ddb2      	ble.n	8018e98 <cblas_ctrsv+0x22c>
 8018f32:	1c7b      	adds	r3, r7, #1
 8018f34:	fb03 f20a 	mul.w	r2, r3, sl
 8018f38:	ebc2 7242 	rsb	r2, r2, r2, lsl #29
 8018f3c:	00d2      	lsls	r2, r2, #3
 8018f3e:	9903      	ldr	r1, [sp, #12]
 8018f40:	9207      	str	r2, [sp, #28]
 8018f42:	9a00      	ldr	r2, [sp, #0]
 8018f44:	00db      	lsls	r3, r3, #3
 8018f46:	ea6f 0907 	mvn.w	r9, r7
 8018f4a:	f10a 37ff 	add.w	r7, sl, #4294967295
 8018f4e:	eb01 08c8 	add.w	r8, r1, r8, lsl #3
 8018f52:	fb0a 2503 	mla	r5, sl, r3, r2
 8018f56:	ebc4 7144 	rsb	r1, r4, r4, lsl #29
 8018f5a:	f1a3 0608 	sub.w	r6, r3, #8
 8018f5e:	fb03 f307 	mul.w	r3, r3, r7
 8018f62:	00e4      	lsls	r4, r4, #3
 8018f64:	9306      	str	r3, [sp, #24]
 8018f66:	00cb      	lsls	r3, r1, #3
 8018f68:	9300      	str	r3, [sp, #0]
 8018f6a:	1f23      	subs	r3, r4, #4
 8018f6c:	f108 0804 	add.w	r8, r8, #4
 8018f70:	ea4f 09c9 	mov.w	r9, r9, lsl #3
 8018f74:	9303      	str	r3, [sp, #12]
 8018f76:	4651      	mov	r1, sl
      for (j = i + 1; j < N; j++) {
 8018f78:	458b      	cmp	fp, r1
      BASE tmp_real = REAL(X, ix);
 8018f7a:	ed58 8a01 	vldr	s17, [r8, #-4]
      BASE tmp_imag = IMAG(X, ix);
 8018f7e:	ed98 9a00 	vldr	s18, [r8]
    for (i = N - 1; i > 0 && i--;) {
 8018f82:	46ba      	mov	sl, r7
      for (j = i + 1; j < N; j++) {
 8018f84:	dd20      	ble.n	8018fc8 <cblas_ctrsv+0x35c>
 8018f86:	9b03      	ldr	r3, [sp, #12]
 8018f88:	eeb8 5ac8 	vcvt.f32.s32	s10, s16
 8018f8c:	eb03 0208 	add.w	r2, r3, r8
 8018f90:	462b      	mov	r3, r5
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8018f92:	ed53 7a01 	vldr	s15, [r3, #-4]
        const BASE x_imag = IMAG(X, jx);
 8018f96:	edd2 6a01 	vldr	s13, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8018f9a:	edd2 5a00 	vldr	s11, [r2]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8018f9e:	ed13 6a02 	vldr	s12, [r3, #-8]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8018fa2:	ee65 7a27 	vmul.f32	s15, s10, s15
      for (j = i + 1; j < N; j++) {
 8018fa6:	3101      	adds	r1, #1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8018fa8:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8018fac:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8018fb0:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = i + 1; j < N; j++) {
 8018fb4:	458b      	cmp	fp, r1
 8018fb6:	4422      	add	r2, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8018fb8:	eee6 7a26 	vfma.f32	s15, s12, s13
 8018fbc:	4433      	add	r3, r6
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8018fbe:	ee78 8ac7 	vsub.f32	s17, s17, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8018fc2:	ee39 9a67 	vsub.f32	s18, s18, s15
      for (j = i + 1; j < N; j++) {
 8018fc6:	d1e4      	bne.n	8018f92 <cblas_ctrsv+0x326>
      if (nonunit) {
 8018fc8:	9b02      	ldr	r3, [sp, #8]
 8018fca:	2b83      	cmp	r3, #131	; 0x83
 8018fcc:	f000 810e 	beq.w	80191ec <cblas_ctrsv+0x580>
        REAL(X, ix) = tmp_real;
 8018fd0:	ed48 8a01 	vstr	s17, [r8, #-4]
        IMAG(X, ix) = tmp_imag;
 8018fd4:	ed88 9a00 	vstr	s18, [r8]
    for (i = N - 1; i > 0 && i--;) {
 8018fd8:	9b00      	ldr	r3, [sp, #0]
 8018fda:	444d      	add	r5, r9
 8018fdc:	4498      	add	r8, r3
 8018fde:	2f00      	cmp	r7, #0
 8018fe0:	f43f af5a 	beq.w	8018e98 <cblas_ctrsv+0x22c>
 8018fe4:	3f01      	subs	r7, #1
 8018fe6:	e7c6      	b.n	8018f76 <cblas_ctrsv+0x30a>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8018fe8:	2c00      	cmp	r4, #0
 8018fea:	bf0c      	ite	eq
 8018fec:	2009      	moveq	r0, #9
 8018fee:	2004      	movne	r0, #4
 8018ff0:	e66f      	b.n	8018cd2 <cblas_ctrsv+0x66>
 8018ff2:	bf00      	nop
 8018ff4:	00000001 	.word	0x00000001
 8018ff8:	08030378 	.word	0x08030378
 8018ffc:	080307b4 	.word	0x080307b4
 8019000:	080305a8 	.word	0x080305a8
 8019004:	ffffffff 	.word	0xffffffff
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8019008:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801900c:	f43f ae92 	beq.w	8018d34 <cblas_ctrsv+0xc8>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 8019010:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
 8019014:	f47f ae7a 	bne.w	8018d0c <cblas_ctrsv+0xa0>
    ix = OFFSET(N, incX);
 8019018:	2c00      	cmp	r4, #0
 801901a:	f340 817c 	ble.w	8019316 <cblas_ctrsv+0x6aa>
 801901e:	46a1      	mov	r9, r4
 8019020:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 8019024:	9b02      	ldr	r3, [sp, #8]
 8019026:	2b83      	cmp	r3, #131	; 0x83
 8019028:	f000 81c3 	beq.w	80193b2 <cblas_ctrsv+0x746>
    for (i = 1; i < N; i++) {
 801902c:	f1bb 0f01 	cmp.w	fp, #1
 8019030:	f77f af32 	ble.w	8018e98 <cblas_ctrsv+0x22c>
 8019034:	9a03      	ldr	r2, [sp, #12]
 8019036:	9d00      	ldr	r5, [sp, #0]
 8019038:	1c7b      	adds	r3, r7, #1
 801903a:	eb02 08c9 	add.w	r8, r2, r9, lsl #3
 801903e:	461e      	mov	r6, r3
 8019040:	eb02 02ca 	add.w	r2, r2, sl, lsl #3
 8019044:	00db      	lsls	r3, r3, #3
 8019046:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 801904a:	00e4      	lsls	r4, r4, #3
 801904c:	9204      	str	r2, [sp, #16]
 801904e:	9303      	str	r3, [sp, #12]
 8019050:	eb05 06c6 	add.w	r6, r5, r6, lsl #3
 8019054:	46ba      	mov	sl, r7
 8019056:	f04f 0901 	mov.w	r9, #1
      BASE tmp_real = REAL(X, ix);
 801905a:	ed98 9a00 	vldr	s18, [r8]
      BASE tmp_imag = IMAG(X, ix);
 801905e:	edd8 8a01 	vldr	s17, [r8, #4]
 8019062:	9a04      	ldr	r2, [sp, #16]
 8019064:	eb05 03ca 	add.w	r3, r5, sl, lsl #3
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8019068:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE x_imag = IMAG(X, jx);
 801906c:	edd2 6a01 	vldr	s13, [r2, #4]
        const BASE x_real = REAL(X, jx);
 8019070:	edd2 5a00 	vldr	s11, [r2]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8019074:	ed93 6a00 	vldr	s12, [r3]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8019078:	ee68 7a27 	vmul.f32	s15, s16, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 801907c:	3308      	adds	r3, #8
 801907e:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019082:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019086:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = 0; j < i; j++) {
 801908a:	429e      	cmp	r6, r3
 801908c:	4422      	add	r2, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 801908e:	eee6 7a26 	vfma.f32	s15, s12, s13
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019092:	ee39 9a47 	vsub.f32	s18, s18, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019096:	ee78 8ae7 	vsub.f32	s17, s17, s15
      for (j = 0; j < i; j++) {
 801909a:	d1e5      	bne.n	8019068 <cblas_ctrsv+0x3fc>
      if (nonunit) {
 801909c:	9b02      	ldr	r3, [sp, #8]
 801909e:	2b83      	cmp	r3, #131	; 0x83
 80190a0:	f000 80d9 	beq.w	8019256 <cblas_ctrsv+0x5ea>
        REAL(X, ix) = tmp_real;
 80190a4:	ed88 9a00 	vstr	s18, [r8]
        IMAG(X, ix) = tmp_imag;
 80190a8:	edc8 8a01 	vstr	s17, [r8, #4]
    for (i = 1; i < N; i++) {
 80190ac:	9b03      	ldr	r3, [sp, #12]
 80190ae:	f109 0901 	add.w	r9, r9, #1
 80190b2:	45cb      	cmp	fp, r9
 80190b4:	44a0      	add	r8, r4
 80190b6:	441e      	add	r6, r3
 80190b8:	44ba      	add	sl, r7
 80190ba:	d1ce      	bne.n	801905a <cblas_ctrsv+0x3ee>
 80190bc:	e6ec      	b.n	8018e98 <cblas_ctrsv+0x22c>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 80190be:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 80190c2:	f47f ae23 	bne.w	8018d0c <cblas_ctrsv+0xa0>
 80190c6:	e7a7      	b.n	8019018 <cblas_ctrsv+0x3ac>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80190c8:	3865      	subs	r0, #101	; 0x65
 80190ca:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 80190cc:	ed1f 8a33 	vldr	s16, [pc, #-204]	; 8019004 <cblas_ctrsv+0x398>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80190d0:	bf94      	ite	ls
 80190d2:	2000      	movls	r0, #0
 80190d4:	2001      	movhi	r0, #1
 80190d6:	f04f 0a70 	mov.w	sl, #112	; 0x70
 80190da:	e5e5      	b.n	8018ca8 <cblas_ctrsv+0x3c>
    ix = OFFSET(N, incX);
 80190dc:	2c00      	cmp	r4, #0
 80190de:	f340 8121 	ble.w	8019324 <cblas_ctrsv+0x6b8>
 80190e2:	46a1      	mov	r9, r4
 80190e4:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 80190e8:	9b02      	ldr	r3, [sp, #8]
 80190ea:	2b83      	cmp	r3, #131	; 0x83
 80190ec:	f000 819d 	beq.w	801942a <cblas_ctrsv+0x7be>
    for (i = 1; i < N; i++) {
 80190f0:	f1bb 0f01 	cmp.w	fp, #1
 80190f4:	f77f aed0 	ble.w	8018e98 <cblas_ctrsv+0x22c>
 80190f8:	9b03      	ldr	r3, [sp, #12]
 80190fa:	3701      	adds	r7, #1
 80190fc:	eb03 09c9 	add.w	r9, r3, r9, lsl #3
 8019100:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8019104:	00ff      	lsls	r7, r7, #3
 8019106:	9303      	str	r3, [sp, #12]
 8019108:	9b00      	ldr	r3, [sp, #0]
 801910a:	f1a7 0808 	sub.w	r8, r7, #8
 801910e:	eb03 0a08 	add.w	sl, r3, r8
 8019112:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 8019116:	330c      	adds	r3, #12
 8019118:	00e4      	lsls	r4, r4, #3
 801911a:	461d      	mov	r5, r3
 801911c:	2601      	movs	r6, #1
      BASE tmp_real = REAL(X, ix);
 801911e:	ed99 9a00 	vldr	s18, [r9]
      BASE tmp_imag = IMAG(X, ix);
 8019122:	edd9 8a01 	vldr	s17, [r9, #4]
 8019126:	9b03      	ldr	r3, [sp, #12]
 8019128:	462a      	mov	r2, r5
 801912a:	2100      	movs	r1, #0
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 801912c:	edd2 7a00 	vldr	s15, [r2]
        const BASE x_imag = IMAG(X, jx);
 8019130:	edd3 6a01 	vldr	s13, [r3, #4]
        const BASE x_real = REAL(X, jx);
 8019134:	edd3 5a00 	vldr	s11, [r3]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8019138:	ed12 6a01 	vldr	s12, [r2, #-4]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 801913c:	ee68 7a27 	vmul.f32	s15, s16, s15
      for (j = 0; j < i; j++) {
 8019140:	3101      	adds	r1, #1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019142:	ee26 7ae7 	vnmul.f32	s14, s13, s15
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019146:	ee67 7aa5 	vmul.f32	s15, s15, s11
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 801914a:	eea6 7a25 	vfma.f32	s14, s12, s11
      for (j = 0; j < i; j++) {
 801914e:	42b1      	cmp	r1, r6
 8019150:	4423      	add	r3, r4
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8019152:	eee6 7a26 	vfma.f32	s15, s12, s13
 8019156:	4442      	add	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8019158:	ee39 9a47 	vsub.f32	s18, s18, s14
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 801915c:	ee78 8ae7 	vsub.f32	s17, s17, s15
      for (j = 0; j < i; j++) {
 8019160:	d1e4      	bne.n	801912c <cblas_ctrsv+0x4c0>
      if (nonunit) {
 8019162:	9b02      	ldr	r3, [sp, #8]
 8019164:	2b83      	cmp	r3, #131	; 0x83
 8019166:	f000 80a5 	beq.w	80192b4 <cblas_ctrsv+0x648>
        REAL(X, ix) = tmp_real;
 801916a:	ed89 9a00 	vstr	s18, [r9]
        IMAG(X, ix) = tmp_imag;
 801916e:	edc9 8a01 	vstr	s17, [r9, #4]
    for (i = 1; i < N; i++) {
 8019172:	3601      	adds	r6, #1
 8019174:	45b3      	cmp	fp, r6
 8019176:	44a1      	add	r9, r4
 8019178:	44ba      	add	sl, r7
 801917a:	f105 0508 	add.w	r5, r5, #8
 801917e:	d1ce      	bne.n	801911e <cblas_ctrsv+0x4b2>
 8019180:	e68a      	b.n	8018e98 <cblas_ctrsv+0x22c>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8019182:	9b07      	ldr	r3, [sp, #28]
 8019184:	9a06      	ldr	r2, [sp, #24]
 8019186:	442b      	add	r3, r5
 8019188:	4413      	add	r3, r2
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 801918a:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 801918e:	ed93 aa00 	vldr	s20, [r3]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019192:	eef8 9ac8 	vcvt.f32.s32	s19, s16
 8019196:	ee69 9aa7 	vmul.f32	s19, s19, s15
        const BASE s = xhypot(a_real, a_imag);
 801919a:	ee19 0a90 	vmov	r0, s19
 801919e:	f00e fe2b 	bl	8027df8 <__aeabi_f2d>
 80191a2:	4602      	mov	r2, r0
 80191a4:	460b      	mov	r3, r1
 80191a6:	ee1a 0a10 	vmov	r0, s20
 80191aa:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80191ae:	f00e fe23 	bl	8027df8 <__aeabi_f2d>
 80191b2:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 80191b6:	f7ff fd21 	bl	8018bfc <xhypot>
 80191ba:	f00f f925 	bl	8028408 <__aeabi_d2f>
 80191be:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 80191c2:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 80191c6:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80191ca:	ee67 6a09 	vmul.f32	s13, s14, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80191ce:	ee28 7ac7 	vnmul.f32	s14, s17, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80191d2:	eee6 6a28 	vfma.f32	s13, s12, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80191d6:	eea6 7a09 	vfma.f32	s14, s12, s18
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80191da:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80191de:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80191e2:	ed08 6a01 	vstr	s12, [r8, #-4]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80191e6:	edc8 6a00 	vstr	s13, [r8]
 80191ea:	e64e      	b.n	8018e8a <cblas_ctrsv+0x21e>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 80191ec:	9b07      	ldr	r3, [sp, #28]
 80191ee:	9a06      	ldr	r2, [sp, #24]
 80191f0:	18eb      	adds	r3, r5, r3
 80191f2:	4413      	add	r3, r2
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80191f4:	edd3 7a01 	vldr	s15, [r3, #4]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 80191f8:	ed93 aa00 	vldr	s20, [r3]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80191fc:	eef8 9ac8 	vcvt.f32.s32	s19, s16
 8019200:	ee69 9aa7 	vmul.f32	s19, s19, s15
        const BASE s = xhypot(a_real, a_imag);
 8019204:	ee19 0a90 	vmov	r0, s19
 8019208:	f00e fdf6 	bl	8027df8 <__aeabi_f2d>
 801920c:	4602      	mov	r2, r0
 801920e:	460b      	mov	r3, r1
 8019210:	ee1a 0a10 	vmov	r0, s20
 8019214:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8019218:	f00e fdee 	bl	8027df8 <__aeabi_f2d>
 801921c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8019220:	f7ff fcec 	bl	8018bfc <xhypot>
 8019224:	f00f f8f0 	bl	8028408 <__aeabi_d2f>
 8019228:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 801922c:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 8019230:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019234:	ee67 6a09 	vmul.f32	s13, s14, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019238:	ee28 7ac7 	vnmul.f32	s14, s17, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 801923c:	eee6 6a28 	vfma.f32	s13, s12, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019240:	eea6 7a09 	vfma.f32	s14, s12, s18
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019244:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019248:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 801924c:	ed08 6a01 	vstr	s12, [r8, #-4]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019250:	edc8 6a00 	vstr	s13, [r8]
 8019254:	e6c0      	b.n	8018fd8 <cblas_ctrsv+0x36c>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8019256:	edd6 9a01 	vldr	s19, [r6, #4]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 801925a:	ed96 aa00 	vldr	s20, [r6]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 801925e:	ee68 9a29 	vmul.f32	s19, s16, s19
        const BASE s = xhypot(a_real, a_imag);
 8019262:	ee19 0a90 	vmov	r0, s19
 8019266:	f00e fdc7 	bl	8027df8 <__aeabi_f2d>
 801926a:	4602      	mov	r2, r0
 801926c:	460b      	mov	r3, r1
 801926e:	ee1a 0a10 	vmov	r0, s20
 8019272:	e9cd 2300 	strd	r2, r3, [sp]
 8019276:	f00e fdbf 	bl	8027df8 <__aeabi_f2d>
 801927a:	e9dd 2300 	ldrd	r2, r3, [sp]
 801927e:	f7ff fcbd 	bl	8018bfc <xhypot>
 8019282:	f00f f8c1 	bl	8028408 <__aeabi_d2f>
 8019286:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 801928a:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 801928e:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019292:	ee67 6a28 	vmul.f32	s13, s14, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019296:	ee29 7a47 	vnmul.f32	s14, s18, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 801929a:	eee6 6a09 	vfma.f32	s13, s12, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 801929e:	eea6 7a28 	vfma.f32	s14, s12, s17
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80192a2:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80192a6:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80192aa:	ed88 6a00 	vstr	s12, [r8]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80192ae:	edc8 6a01 	vstr	s13, [r8, #4]
 80192b2:	e6fb      	b.n	80190ac <cblas_ctrsv+0x440>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80192b4:	edda 9a03 	vldr	s19, [sl, #12]
        const BASE a_real = CONST_REAL(A, lda * i + i);
 80192b8:	ed9a aa02 	vldr	s20, [sl, #8]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80192bc:	ee68 9a29 	vmul.f32	s19, s16, s19
        const BASE s = xhypot(a_real, a_imag);
 80192c0:	ee19 0a90 	vmov	r0, s19
 80192c4:	f00e fd98 	bl	8027df8 <__aeabi_f2d>
 80192c8:	4602      	mov	r2, r0
 80192ca:	460b      	mov	r3, r1
 80192cc:	ee1a 0a10 	vmov	r0, s20
 80192d0:	e9cd 2300 	strd	r2, r3, [sp]
 80192d4:	f00e fd90 	bl	8027df8 <__aeabi_f2d>
 80192d8:	e9dd 2300 	ldrd	r2, r3, [sp]
 80192dc:	f7ff fc8e 	bl	8018bfc <xhypot>
 80192e0:	f00f f892 	bl	8028408 <__aeabi_d2f>
 80192e4:	ee07 0a90 	vmov	s15, r0
        const BASE b_imag = a_imag / s;
 80192e8:	ee89 7aa7 	vdiv.f32	s14, s19, s15
        const BASE b_real = a_real / s;
 80192ec:	ee8a 6a27 	vdiv.f32	s12, s20, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80192f0:	ee67 6a28 	vmul.f32	s13, s14, s17
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80192f4:	ee29 7a47 	vnmul.f32	s14, s18, s14
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80192f8:	eee6 6a09 	vfma.f32	s13, s12, s18
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80192fc:	eea6 7a28 	vfma.f32	s14, s12, s17
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019300:	ee86 6aa7 	vdiv.f32	s12, s13, s15
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8019304:	eec7 6a27 	vdiv.f32	s13, s14, s15
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8019308:	ed89 6a00 	vstr	s12, [r9]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 801930c:	edc9 6a01 	vstr	s13, [r9, #4]
 8019310:	e72f      	b.n	8019172 <cblas_ctrsv+0x506>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8019312:	2009      	movs	r0, #9
 8019314:	e4dd      	b.n	8018cd2 <cblas_ctrsv+0x66>
    ix = OFFSET(N, incX);
 8019316:	f1cb 0301 	rsb	r3, fp, #1
 801931a:	fb03 fa04 	mul.w	sl, r3, r4
 801931e:	eb04 090a 	add.w	r9, r4, sl
 8019322:	e67f      	b.n	8019024 <cblas_ctrsv+0x3b8>
    ix = OFFSET(N, incX);
 8019324:	f1cb 0a01 	rsb	sl, fp, #1
 8019328:	fb0a fa04 	mul.w	sl, sl, r4
 801932c:	eb04 090a 	add.w	r9, r4, sl
 8019330:	e6da      	b.n	80190e8 <cblas_ctrsv+0x47c>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019332:	9a00      	ldr	r2, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8019334:	9e03      	ldr	r6, [sp, #12]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019336:	fb0a a307 	mla	r3, sl, r7, sl
 801933a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 801933e:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8019342:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8019346:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 801934a:	eb06 03c8 	add.w	r3, r6, r8, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 801934e:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 8019352:	1d1d      	adds	r5, r3, #4
      const BASE s = xhypot(a_real, a_imag);
 8019354:	ee18 0a90 	vmov	r0, s17
 8019358:	f00e fd4e 	bl	8027df8 <__aeabi_f2d>
 801935c:	4602      	mov	r2, r0
 801935e:	460b      	mov	r3, r1
 8019360:	ee1a 0a10 	vmov	r0, s20
 8019364:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 8019368:	eb06 09c8 	add.w	r9, r6, r8, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 801936c:	f00e fd44 	bl	8027df8 <__aeabi_f2d>
 8019370:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 8019374:	ed95 9a00 	vldr	s18, [r5]
      const BASE x_real = REAL(X, ix);
 8019378:	edd9 9a00 	vldr	s19, [r9]
      const BASE s = xhypot(a_real, a_imag);
 801937c:	f7ff fc3e 	bl	8018bfc <xhypot>
 8019380:	f00f f842 	bl	8028408 <__aeabi_d2f>
 8019384:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 8019388:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 801938c:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019390:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019394:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019398:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801939c:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80193a0:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80193a4:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80193a8:	ed89 6a00 	vstr	s12, [r9]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80193ac:	edc5 6a00 	vstr	s13, [r5]
 80193b0:	e5ba      	b.n	8018f28 <cblas_ctrsv+0x2bc>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80193b2:	9b00      	ldr	r3, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 80193b4:	9d03      	ldr	r5, [sp, #12]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80193b6:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 80193ba:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80193be:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 80193c2:	eb05 03ca 	add.w	r3, r5, sl, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80193c6:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 80193ca:	1d1e      	adds	r6, r3, #4
      const BASE s = xhypot(a_real, a_imag);
 80193cc:	ee18 0a90 	vmov	r0, s17
 80193d0:	f00e fd12 	bl	8027df8 <__aeabi_f2d>
 80193d4:	4602      	mov	r2, r0
 80193d6:	460b      	mov	r3, r1
 80193d8:	ee1a 0a10 	vmov	r0, s20
 80193dc:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 80193e0:	eb05 08ca 	add.w	r8, r5, sl, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 80193e4:	f00e fd08 	bl	8027df8 <__aeabi_f2d>
 80193e8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 80193ec:	ed96 9a00 	vldr	s18, [r6]
      const BASE x_real = REAL(X, ix);
 80193f0:	edd8 9a00 	vldr	s19, [r8]
      const BASE s = xhypot(a_real, a_imag);
 80193f4:	f7ff fc02 	bl	8018bfc <xhypot>
 80193f8:	f00f f806 	bl	8028408 <__aeabi_d2f>
 80193fc:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 8019400:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 8019404:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019408:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801940c:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019410:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019414:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019418:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801941c:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019420:	ed88 6a00 	vstr	s12, [r8]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019424:	edc6 6a00 	vstr	s13, [r6]
 8019428:	e600      	b.n	801902c <cblas_ctrsv+0x3c0>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801942a:	9b00      	ldr	r3, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 801942c:	9e03      	ldr	r6, [sp, #12]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801942e:	edd3 7a01 	vldr	s15, [r3, #4]
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 8019432:	ed93 aa00 	vldr	s20, [r3]
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 8019436:	eef8 8ac8 	vcvt.f32.s32	s17, s16
      const BASE x_imag = IMAG(X, ix);
 801943a:	eb06 03ca 	add.w	r3, r6, sl, lsl #3
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 801943e:	ee68 8aa7 	vmul.f32	s17, s17, s15
      const BASE x_imag = IMAG(X, ix);
 8019442:	1d1d      	adds	r5, r3, #4
      const BASE s = xhypot(a_real, a_imag);
 8019444:	ee18 0a90 	vmov	r0, s17
 8019448:	f00e fcd6 	bl	8027df8 <__aeabi_f2d>
 801944c:	4602      	mov	r2, r0
 801944e:	460b      	mov	r3, r1
 8019450:	ee1a 0a10 	vmov	r0, s20
 8019454:	e9cd 2304 	strd	r2, r3, [sp, #16]
      const BASE x_real = REAL(X, ix);
 8019458:	eb06 08ca 	add.w	r8, r6, sl, lsl #3
      const BASE s = xhypot(a_real, a_imag);
 801945c:	f00e fccc 	bl	8027df8 <__aeabi_f2d>
 8019460:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
      const BASE x_imag = IMAG(X, ix);
 8019464:	ed95 9a00 	vldr	s18, [r5]
      const BASE x_real = REAL(X, ix);
 8019468:	edd8 9a00 	vldr	s19, [r8]
      const BASE s = xhypot(a_real, a_imag);
 801946c:	f7ff fbc6 	bl	8018bfc <xhypot>
 8019470:	f00e ffca 	bl	8028408 <__aeabi_d2f>
 8019474:	ee07 0a90 	vmov	s15, r0
      const BASE b_imag = a_imag / s;
 8019478:	ee88 7aa7 	vdiv.f32	s14, s17, s15
      const BASE b_real = a_real / s;
 801947c:	ee8a 6a27 	vdiv.f32	s12, s20, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019480:	ee69 6a07 	vmul.f32	s13, s18, s14
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019484:	ee27 7a69 	vnmul.f32	s14, s14, s19
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019488:	eee9 6a86 	vfma.f32	s13, s19, s12
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801948c:	eea9 7a06 	vfma.f32	s14, s18, s12
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019490:	ee86 6aa7 	vdiv.f32	s12, s13, s15
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8019494:	eec7 6a27 	vdiv.f32	s13, s14, s15
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8019498:	ed88 6a00 	vstr	s12, [r8]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 801949c:	edc5 6a00 	vstr	s13, [r5]
 80194a0:	e626      	b.n	80190f0 <cblas_ctrsv+0x484>
 80194a2:	bf00      	nop

080194a4 <cblas_zaxpy>:
#include "cblas.h"

void
cblas_zaxpy (const int N, const void *alpha, const void *X, const int incX,
             void *Y, const int incY)
{
 80194a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80194a8:	ed2d 8b06 	vpush	{d8-d10}
 80194ac:	b085      	sub	sp, #20
  INDEX ix = OFFSET(N, incX);
 80194ae:	1e1e      	subs	r6, r3, #0
 80194b0:	e9dd 7414 	ldrd	r7, r4, [sp, #80]	; 0x50
 80194b4:	bfd8      	it	le
 80194b6:	4603      	movle	r3, r0
  const BASE alpha_real = CONST_REAL0(alpha);
 80194b8:	ed91 7b00 	vldr	d7, [r1]
  INDEX ix = OFFSET(N, incX);
 80194bc:	bfd8      	it	le
 80194be:	f1c3 0501 	rsble	r5, r3, #1
 80194c2:	9001      	str	r0, [sp, #4]
 80194c4:	468c      	mov	ip, r1
 80194c6:	bfd4      	ite	le
 80194c8:	4375      	mulle	r5, r6
 80194ca:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 80194cc:	2c00      	cmp	r4, #0
 80194ce:	bfd8      	it	le
 80194d0:	9b01      	ldrle	r3, [sp, #4]
  const BASE alpha_real = CONST_REAL0(alpha);
 80194d2:	eeb0 9a47 	vmov.f32	s18, s14
 80194d6:	eef0 9a67 	vmov.f32	s19, s15
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 80194da:	ec51 0b17 	vmov	r0, r1, d7
  const BASE alpha_imag = CONST_IMAG0(alpha);
 80194de:	ed9c 7b02 	vldr	d7, [ip, #8]
  INDEX iy = OFFSET(N, incY);
 80194e2:	bfd8      	it	le
 80194e4:	f1c3 0b01 	rsble	fp, r3, #1
 80194e8:	4692      	mov	sl, r2
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 80194ea:	f04f 0300 	mov.w	r3, #0
 80194ee:	f04f 0200 	mov.w	r2, #0
  INDEX iy = OFFSET(N, incY);
 80194f2:	bfd4      	ite	le
 80194f4:	fb0b fb04 	mulle.w	fp, fp, r4
 80194f8:	f04f 0b00 	movgt.w	fp, #0
  const BASE alpha_imag = CONST_IMAG0(alpha);
 80194fc:	eeb0 8a47 	vmov.f32	s16, s14
 8019500:	eef0 8a67 	vmov.f32	s17, s15
  if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
 8019504:	f00e ff38 	bl	8028378 <__aeabi_dcmpeq>
 8019508:	b138      	cbz	r0, 801951a <cblas_zaxpy+0x76>
 801950a:	ec51 0b18 	vmov	r0, r1, d8
 801950e:	2200      	movs	r2, #0
 8019510:	2300      	movs	r3, #0
 8019512:	f00e ff31 	bl	8028378 <__aeabi_dcmpeq>
 8019516:	2800      	cmp	r0, #0
 8019518:	d153      	bne.n	80195c2 <cblas_zaxpy+0x11e>
  for (i = 0; i < N; i++) {
 801951a:	9b01      	ldr	r3, [sp, #4]
 801951c:	2b00      	cmp	r3, #0
 801951e:	dd50      	ble.n	80195c2 <cblas_zaxpy+0x11e>
 8019520:	0132      	lsls	r2, r6, #4
 8019522:	eb07 130b 	add.w	r3, r7, fp, lsl #4
 8019526:	9203      	str	r2, [sp, #12]
 8019528:	0122      	lsls	r2, r4, #4
 801952a:	eb0a 1a05 	add.w	sl, sl, r5, lsl #4
 801952e:	9202      	str	r2, [sp, #8]
 8019530:	f103 0408 	add.w	r4, r3, #8
 8019534:	469b      	mov	fp, r3
 8019536:	2500      	movs	r5, #0
    const BASE x_real = CONST_REAL(X, ix);
 8019538:	e9da 6700 	ldrd	r6, r7, [sl]
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 801953c:	ec51 0b19 	vmov	r0, r1, d9
 8019540:	4632      	mov	r2, r6
 8019542:	463b      	mov	r3, r7
 8019544:	f00e fcb0 	bl	8027ea8 <__aeabi_dmul>
    const BASE x_imag = CONST_IMAG(X, ix);
 8019548:	e9da 8902 	ldrd	r8, r9, [sl, #8]
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 801954c:	ec41 0b1a 	vmov	d10, r0, r1
 8019550:	4642      	mov	r2, r8
 8019552:	464b      	mov	r3, r9
 8019554:	ec51 0b18 	vmov	r0, r1, d8
 8019558:	f00e fca6 	bl	8027ea8 <__aeabi_dmul>
 801955c:	4602      	mov	r2, r0
 801955e:	460b      	mov	r3, r1
 8019560:	ec51 0b1a 	vmov	r0, r1, d10
 8019564:	f00e fae8 	bl	8027b38 <__aeabi_dsub>
 8019568:	4602      	mov	r2, r0
 801956a:	460b      	mov	r3, r1
 801956c:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8019570:	f00e fae4 	bl	8027b3c <__adddf3>
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 8019574:	4642      	mov	r2, r8
    REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
 8019576:	e944 0102 	strd	r0, r1, [r4, #-8]
    IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
 801957a:	464b      	mov	r3, r9
 801957c:	ec51 0b19 	vmov	r0, r1, d9
 8019580:	f00e fc92 	bl	8027ea8 <__aeabi_dmul>
 8019584:	4632      	mov	r2, r6
 8019586:	463b      	mov	r3, r7
 8019588:	4606      	mov	r6, r0
 801958a:	460f      	mov	r7, r1
 801958c:	ec51 0b18 	vmov	r0, r1, d8
 8019590:	f00e fc8a 	bl	8027ea8 <__aeabi_dmul>
 8019594:	4602      	mov	r2, r0
 8019596:	460b      	mov	r3, r1
 8019598:	4630      	mov	r0, r6
 801959a:	4639      	mov	r1, r7
 801959c:	f00e face 	bl	8027b3c <__adddf3>
 80195a0:	460b      	mov	r3, r1
 80195a2:	4602      	mov	r2, r0
 80195a4:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 80195a8:	f00e fac8 	bl	8027b3c <__adddf3>
 80195ac:	9b03      	ldr	r3, [sp, #12]
 80195ae:	449a      	add	sl, r3
 80195b0:	9b02      	ldr	r3, [sp, #8]
 80195b2:	e9cb 0102 	strd	r0, r1, [fp, #8]
  for (i = 0; i < N; i++) {
 80195b6:	441c      	add	r4, r3
 80195b8:	449b      	add	fp, r3
 80195ba:	9b01      	ldr	r3, [sp, #4]
 80195bc:	3501      	adds	r5, #1
 80195be:	42ab      	cmp	r3, r5
 80195c0:	d1ba      	bne.n	8019538 <cblas_zaxpy+0x94>
#define BASE double
#include "source_axpy_c.h"
#undef BASE
}
 80195c2:	b005      	add	sp, #20
 80195c4:	ecbd 8b06 	vpop	{d8-d10}
 80195c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080195cc <cblas_zcopy>:
#include "cblas.h"

void
cblas_zcopy (const int N, const void *X, const int incX, void *Y,
             const int incY)
{
 80195cc:	b4f0      	push	{r4, r5, r6, r7}
  INDEX ix = OFFSET(N, incX);
 80195ce:	2a00      	cmp	r2, #0
 80195d0:	9f04      	ldr	r7, [sp, #16]
 80195d2:	bfda      	itte	le
 80195d4:	f1c0 0501 	rsble	r5, r0, #1
 80195d8:	4355      	mulle	r5, r2
 80195da:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 80195dc:	2f00      	cmp	r7, #0
 80195de:	bfda      	itte	le
 80195e0:	f1c0 0401 	rsble	r4, r0, #1
 80195e4:	437c      	mulle	r4, r7
 80195e6:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 80195e8:	2800      	cmp	r0, #0
 80195ea:	dd13      	ble.n	8019614 <cblas_zcopy+0x48>
 80195ec:	0116      	lsls	r6, r2, #4
 80195ee:	eb01 1105 	add.w	r1, r1, r5, lsl #4
 80195f2:	013f      	lsls	r7, r7, #4
 80195f4:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 80195f8:	2200      	movs	r2, #0
    REAL(Y, iy) = CONST_REAL(X, ix);
 80195fa:	e9d1 4500 	ldrd	r4, r5, [r1]
 80195fe:	e9c3 4500 	strd	r4, r5, [r3]
    IMAG(Y, iy) = CONST_IMAG(X, ix);
 8019602:	e9d1 4502 	ldrd	r4, r5, [r1, #8]
  for (i = 0; i < N; i++) {
 8019606:	3201      	adds	r2, #1
 8019608:	4290      	cmp	r0, r2
    IMAG(Y, iy) = CONST_IMAG(X, ix);
 801960a:	e9c3 4502 	strd	r4, r5, [r3, #8]
  for (i = 0; i < N; i++) {
 801960e:	4431      	add	r1, r6
 8019610:	443b      	add	r3, r7
 8019612:	d1f2      	bne.n	80195fa <cblas_zcopy+0x2e>
#define BASE double
#include "source_copy_c.h"
#undef BASE
}
 8019614:	bcf0      	pop	{r4, r5, r6, r7}
 8019616:	4770      	bx	lr

08019618 <cblas_zdotc_sub>:
#include "cblas.h"

void
cblas_zdotc_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 8019618:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801961c:	ed2d 8b04 	vpush	{d8-d9}
 8019620:	b08b      	sub	sp, #44	; 0x2c
 8019622:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 8019624:	2a00      	cmp	r2, #0
 8019626:	9007      	str	r0, [sp, #28]
 8019628:	9818      	ldr	r0, [sp, #96]	; 0x60
  for (i = 0; i < N; i++) {
 801962a:	9e07      	ldr	r6, [sp, #28]
  INDEX ix = OFFSET(N, incX);
 801962c:	bfda      	itte	le
 801962e:	f1c4 0501 	rsble	r5, r4, #1
 8019632:	4355      	mulle	r5, r2
 8019634:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 8019636:	2800      	cmp	r0, #0
 8019638:	bfd8      	it	le
 801963a:	9c07      	ldrle	r4, [sp, #28]
  for (i = 0; i < N; i++) {
 801963c:	ed9f 7b3c 	vldr	d7, [pc, #240]	; 8019730 <cblas_zdotc_sub+0x118>
  INDEX iy = OFFSET(N, incY);
 8019640:	bfda      	itte	le
 8019642:	f1c4 0401 	rsble	r4, r4, #1
 8019646:	4344      	mulle	r4, r0
 8019648:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 801964a:	2e00      	cmp	r6, #0
 801964c:	ed8d 7b02 	vstr	d7, [sp, #8]
 8019650:	ed8d 7b04 	vstr	d7, [sp, #16]
 8019654:	dd5d      	ble.n	8019712 <cblas_zdotc_sub+0xfa>
 8019656:	0112      	lsls	r2, r2, #4
 8019658:	9209      	str	r2, [sp, #36]	; 0x24
 801965a:	eb03 1704 	add.w	r7, r3, r4, lsl #4
 801965e:	0102      	lsls	r2, r0, #4
 8019660:	2300      	movs	r3, #0
 8019662:	eb01 1605 	add.w	r6, r1, r5, lsl #4
 8019666:	9208      	str	r2, [sp, #32]
 8019668:	9306      	str	r3, [sp, #24]
    const BASE x_real = CONST_REAL(X, ix);
 801966a:	ed96 7b00 	vldr	d7, [r6]
    const BASE y_real = CONST_REAL(Y, iy);
 801966e:	e9d7 8900 	ldrd	r8, r9, [r7]
    const BASE x_real = CONST_REAL(X, ix);
 8019672:	eeb0 8a47 	vmov.f32	s16, s14
 8019676:	eef0 8a67 	vmov.f32	s17, s15
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801967a:	ec51 0b17 	vmov	r0, r1, d7
 801967e:	4642      	mov	r2, r8
 8019680:	464b      	mov	r3, r9
 8019682:	f00e fc11 	bl	8027ea8 <__aeabi_dmul>
    const BASE x_imag = CONST_IMAG(X, ix);
 8019686:	e9d6 4502 	ldrd	r4, r5, [r6, #8]
    const BASE y_imag = CONST_IMAG(Y, iy);
 801968a:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801968e:	ec41 0b19 	vmov	d9, r0, r1
 8019692:	4652      	mov	r2, sl
 8019694:	465b      	mov	r3, fp
 8019696:	4620      	mov	r0, r4
 8019698:	4629      	mov	r1, r5
 801969a:	f00e fc05 	bl	8027ea8 <__aeabi_dmul>
 801969e:	4602      	mov	r2, r0
 80196a0:	460b      	mov	r3, r1
 80196a2:	ec51 0b19 	vmov	r0, r1, d9
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80196a6:	9400      	str	r4, [sp, #0]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80196a8:	f00e fa48 	bl	8027b3c <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80196ac:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80196b0:	4602      	mov	r2, r0
 80196b2:	460b      	mov	r3, r1
 80196b4:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80196b8:	9401      	str	r4, [sp, #4]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80196ba:	f00e fa3f 	bl	8027b3c <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80196be:	4642      	mov	r2, r8
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80196c0:	4604      	mov	r4, r0
 80196c2:	460d      	mov	r5, r1
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80196c4:	464b      	mov	r3, r9
 80196c6:	e9dd 0100 	ldrd	r0, r1, [sp]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80196ca:	e9cd 4504 	strd	r4, r5, [sp, #16]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80196ce:	f00e fbeb 	bl	8027ea8 <__aeabi_dmul>
 80196d2:	4652      	mov	r2, sl
 80196d4:	465b      	mov	r3, fp
 80196d6:	4604      	mov	r4, r0
 80196d8:	460d      	mov	r5, r1
 80196da:	ec51 0b18 	vmov	r0, r1, d8
 80196de:	f00e fbe3 	bl	8027ea8 <__aeabi_dmul>
 80196e2:	4602      	mov	r2, r0
 80196e4:	460b      	mov	r3, r1
 80196e6:	4620      	mov	r0, r4
 80196e8:	4629      	mov	r1, r5
 80196ea:	f00e fa27 	bl	8027b3c <__adddf3>
 80196ee:	4602      	mov	r2, r0
 80196f0:	460b      	mov	r3, r1
 80196f2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80196f6:	f00e fa21 	bl	8027b3c <__adddf3>
 80196fa:	9a09      	ldr	r2, [sp, #36]	; 0x24
  for (i = 0; i < N; i++) {
 80196fc:	9b06      	ldr	r3, [sp, #24]
 80196fe:	4416      	add	r6, r2
 8019700:	9a08      	ldr	r2, [sp, #32]
 8019702:	4417      	add	r7, r2
 8019704:	9a07      	ldr	r2, [sp, #28]
 8019706:	3301      	adds	r3, #1
 8019708:	429a      	cmp	r2, r3
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 801970a:	e9cd 0102 	strd	r0, r1, [sp, #8]
  for (i = 0; i < N; i++) {
 801970e:	9306      	str	r3, [sp, #24]
 8019710:	d1ab      	bne.n	801966a <cblas_zdotc_sub+0x52>
  REAL0(result) = r_real;
 8019712:	ed9d 7b04 	vldr	d7, [sp, #16]
 8019716:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8019718:	ed83 7b00 	vstr	d7, [r3]
  IMAG0(result) = r_imag;
 801971c:	ed9d 7b02 	vldr	d7, [sp, #8]
 8019720:	ed83 7b02 	vstr	d7, [r3, #8]
#define BASE double
#define CONJ_SIGN (-1.0)
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 8019724:	b00b      	add	sp, #44	; 0x2c
 8019726:	ecbd 8b04 	vpop	{d8-d9}
 801972a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801972e:	bf00      	nop
	...

08019738 <cblas_zdotu_sub>:
#include "cblas.h"

void
cblas_zdotu_sub (const int N, const void *X, const int incX, const void *Y,
             const int incY, void *result)
{
 8019738:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801973c:	ed2d 8b04 	vpush	{d8-d9}
 8019740:	b089      	sub	sp, #36	; 0x24
 8019742:	4604      	mov	r4, r0
  INDEX ix = OFFSET(N, incX);
 8019744:	2a00      	cmp	r2, #0
 8019746:	9005      	str	r0, [sp, #20]
 8019748:	9816      	ldr	r0, [sp, #88]	; 0x58
  for (i = 0; i < N; i++) {
 801974a:	9e05      	ldr	r6, [sp, #20]
  INDEX ix = OFFSET(N, incX);
 801974c:	bfda      	itte	le
 801974e:	f1c4 0501 	rsble	r5, r4, #1
 8019752:	4355      	mulle	r5, r2
 8019754:	2500      	movgt	r5, #0
  INDEX iy = OFFSET(N, incY);
 8019756:	2800      	cmp	r0, #0
 8019758:	bfd8      	it	le
 801975a:	9c05      	ldrle	r4, [sp, #20]
  for (i = 0; i < N; i++) {
 801975c:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 8019848 <cblas_zdotu_sub+0x110>
  INDEX iy = OFFSET(N, incY);
 8019760:	bfda      	itte	le
 8019762:	f1c4 0401 	rsble	r4, r4, #1
 8019766:	4344      	mulle	r4, r0
 8019768:	2400      	movgt	r4, #0
  for (i = 0; i < N; i++) {
 801976a:	2e00      	cmp	r6, #0
 801976c:	ed8d 7b00 	vstr	d7, [sp]
 8019770:	ed8d 7b02 	vstr	d7, [sp, #8]
 8019774:	dd59      	ble.n	801982a <cblas_zdotu_sub+0xf2>
 8019776:	0112      	lsls	r2, r2, #4
 8019778:	9207      	str	r2, [sp, #28]
 801977a:	eb03 1404 	add.w	r4, r3, r4, lsl #4
 801977e:	0102      	lsls	r2, r0, #4
 8019780:	2300      	movs	r3, #0
 8019782:	eb01 1505 	add.w	r5, r1, r5, lsl #4
 8019786:	9206      	str	r2, [sp, #24]
 8019788:	9304      	str	r3, [sp, #16]
    const BASE y_real = CONST_REAL(Y, iy);
 801978a:	ed94 7b00 	vldr	d7, [r4]
    const BASE x_real = CONST_REAL(X, ix);
 801978e:	e9d5 ab00 	ldrd	sl, fp, [r5]
    const BASE y_real = CONST_REAL(Y, iy);
 8019792:	eeb0 9a47 	vmov.f32	s18, s14
 8019796:	eef0 9a67 	vmov.f32	s19, s15
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 801979a:	ec53 2b17 	vmov	r2, r3, d7
 801979e:	4650      	mov	r0, sl
 80197a0:	4659      	mov	r1, fp
 80197a2:	f00e fb81 	bl	8027ea8 <__aeabi_dmul>
    const BASE y_imag = CONST_IMAG(Y, iy);
 80197a6:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
    const BASE x_imag = CONST_IMAG(X, ix);
 80197aa:	ed95 8b02 	vldr	d8, [r5, #8]
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80197ae:	4606      	mov	r6, r0
 80197b0:	460f      	mov	r7, r1
 80197b2:	4642      	mov	r2, r8
 80197b4:	464b      	mov	r3, r9
 80197b6:	ec51 0b18 	vmov	r0, r1, d8
 80197ba:	f00e fb75 	bl	8027ea8 <__aeabi_dmul>
 80197be:	4602      	mov	r2, r0
 80197c0:	460b      	mov	r3, r1
 80197c2:	4630      	mov	r0, r6
 80197c4:	4639      	mov	r1, r7
 80197c6:	f00e f9b7 	bl	8027b38 <__aeabi_dsub>
 80197ca:	4602      	mov	r2, r0
 80197cc:	460b      	mov	r3, r1
 80197ce:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80197d2:	f00e f9b3 	bl	8027b3c <__adddf3>
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80197d6:	4642      	mov	r2, r8
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80197d8:	4606      	mov	r6, r0
 80197da:	460f      	mov	r7, r1
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80197dc:	464b      	mov	r3, r9
 80197de:	4650      	mov	r0, sl
 80197e0:	4659      	mov	r1, fp
    r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
 80197e2:	e9cd 6702 	strd	r6, r7, [sp, #8]
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 80197e6:	f00e fb5f 	bl	8027ea8 <__aeabi_dmul>
 80197ea:	ec53 2b19 	vmov	r2, r3, d9
 80197ee:	4606      	mov	r6, r0
 80197f0:	460f      	mov	r7, r1
 80197f2:	ec51 0b18 	vmov	r0, r1, d8
 80197f6:	f00e fb57 	bl	8027ea8 <__aeabi_dmul>
 80197fa:	4602      	mov	r2, r0
 80197fc:	460b      	mov	r3, r1
 80197fe:	4630      	mov	r0, r6
 8019800:	4639      	mov	r1, r7
 8019802:	f00e f99b 	bl	8027b3c <__adddf3>
 8019806:	4602      	mov	r2, r0
 8019808:	460b      	mov	r3, r1
 801980a:	e9dd 0100 	ldrd	r0, r1, [sp]
 801980e:	f00e f995 	bl	8027b3c <__adddf3>
 8019812:	9a07      	ldr	r2, [sp, #28]
  for (i = 0; i < N; i++) {
 8019814:	9b04      	ldr	r3, [sp, #16]
 8019816:	4415      	add	r5, r2
 8019818:	9a06      	ldr	r2, [sp, #24]
 801981a:	4414      	add	r4, r2
 801981c:	9a05      	ldr	r2, [sp, #20]
 801981e:	3301      	adds	r3, #1
 8019820:	429a      	cmp	r2, r3
    r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
 8019822:	e9cd 0100 	strd	r0, r1, [sp]
  for (i = 0; i < N; i++) {
 8019826:	9304      	str	r3, [sp, #16]
 8019828:	d1af      	bne.n	801978a <cblas_zdotu_sub+0x52>
  REAL0(result) = r_real;
 801982a:	ed9d 7b02 	vldr	d7, [sp, #8]
 801982e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8019830:	ed83 7b00 	vstr	d7, [r3]
  IMAG0(result) = r_imag;
 8019834:	ed9d 7b00 	vldr	d7, [sp]
 8019838:	ed83 7b02 	vstr	d7, [r3, #8]
#define BASE double
#define CONJ_SIGN 1.0
#include "source_dot_c.h"
#undef CONJ_SIGN
#undef BASE
}
 801983c:	b009      	add	sp, #36	; 0x24
 801983e:	ecbd 8b04 	vpop	{d8-d9}
 8019842:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019846:	bf00      	nop
	...

08019850 <cblas_zdscal>:
  if (incX <= 0) {
 8019850:	2a00      	cmp	r2, #0
 8019852:	dd22      	ble.n	801989a <cblas_zdscal+0x4a>
  for (i = 0; i < N; i++) {
 8019854:	2800      	cmp	r0, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_zdscal (const int N, const double alpha, void *X, const int incX)
{
 8019856:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801985a:	4682      	mov	sl, r0
 801985c:	dd1b      	ble.n	8019896 <cblas_zdscal+0x46>
 801985e:	ec59 8b10 	vmov	r8, r9, d0
 8019862:	460c      	mov	r4, r1
 8019864:	0117      	lsls	r7, r2, #4
 8019866:	f101 0508 	add.w	r5, r1, #8
 801986a:	2600      	movs	r6, #0
    REAL(X, ix) *= alpha;
 801986c:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 8019870:	4642      	mov	r2, r8
 8019872:	464b      	mov	r3, r9
 8019874:	f00e fb18 	bl	8027ea8 <__aeabi_dmul>
 8019878:	e945 0102 	strd	r0, r1, [r5, #-8]
    IMAG(X, ix) *= alpha;
 801987c:	4642      	mov	r2, r8
 801987e:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8019882:	464b      	mov	r3, r9
 8019884:	f00e fb10 	bl	8027ea8 <__aeabi_dmul>
  for (i = 0; i < N; i++) {
 8019888:	3601      	adds	r6, #1
 801988a:	45b2      	cmp	sl, r6
    IMAG(X, ix) *= alpha;
 801988c:	e9c4 0102 	strd	r0, r1, [r4, #8]
  for (i = 0; i < N; i++) {
 8019890:	443d      	add	r5, r7
 8019892:	443c      	add	r4, r7
 8019894:	d1ea      	bne.n	801986c <cblas_zdscal+0x1c>
#define BASE double
#include "source_scal_c_s.h"
#undef BASE
}
 8019896:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801989a:	4770      	bx	lr
 801989c:	0000      	movs	r0, r0
	...

080198a0 <cblas_zgemm>:
cblas_zgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
             const int K, const void *alpha, const void *A, const int lda,
             const void *B, const int ldb, const void *beta, void *C,
             const int ldc)
{
 80198a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80198a4:	ed2d 8b10 	vpush	{d8-d15}
 80198a8:	b091      	sub	sp, #68	; 0x44
 80198aa:	2865      	cmp	r0, #101	; 0x65
 80198ac:	f8dd 80b0 	ldr.w	r8, [sp, #176]	; 0xb0
 80198b0:	9f31      	ldr	r7, [sp, #196]	; 0xc4
 80198b2:	9304      	str	r3, [sp, #16]
 80198b4:	4605      	mov	r5, r0
 80198b6:	460e      	mov	r6, r1
 80198b8:	4614      	mov	r4, r2
 80198ba:	f000 828e 	beq.w	8019dda <cblas_zgemm+0x53a>
 80198be:	2a71      	cmp	r2, #113	; 0x71
 80198c0:	bf08      	it	eq
 80198c2:	2270      	moveq	r2, #112	; 0x70
 80198c4:	2971      	cmp	r1, #113	; 0x71
 80198c6:	f000 81b1 	beq.w	8019c2c <cblas_zgemm+0x38c>
 80198ca:	f1a6 036f 	sub.w	r3, r6, #111	; 0x6f
 80198ce:	2b02      	cmp	r3, #2
 80198d0:	f240 83c6 	bls.w	801a060 <cblas_zgemm+0x7c0>
 80198d4:	2002      	movs	r0, #2
 80198d6:	f1a4 036f 	sub.w	r3, r4, #111	; 0x6f
 80198da:	2b02      	cmp	r3, #2
 80198dc:	bf88      	it	hi
 80198de:	2003      	movhi	r0, #3
 80198e0:	9b04      	ldr	r3, [sp, #16]
 80198e2:	2b00      	cmp	r3, #0
 80198e4:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 80198e6:	bfb8      	it	lt
 80198e8:	2004      	movlt	r0, #4
 80198ea:	2b00      	cmp	r3, #0
 80198ec:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 80198ee:	f2c0 8248 	blt.w	8019d82 <cblas_zgemm+0x4e2>
 80198f2:	2b00      	cmp	r3, #0
 80198f4:	f2c0 81aa 	blt.w	8019c4c <cblas_zgemm+0x3ac>
 80198f8:	2d65      	cmp	r5, #101	; 0x65
 80198fa:	f000 824a 	beq.w	8019d92 <cblas_zgemm+0x4f2>
 80198fe:	2d66      	cmp	r5, #102	; 0x66
 8019900:	f000 81ab 	beq.w	8019c5a <cblas_zgemm+0x3ba>
 8019904:	2800      	cmp	r0, #0
 8019906:	f040 81c7 	bne.w	8019c98 <cblas_zgemm+0x3f8>
    const BASE alpha_real = CONST_REAL0(alpha);
 801990a:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801990e:	2200      	movs	r2, #0
 8019910:	ec51 0b17 	vmov	r0, r1, d7
    const BASE alpha_real = CONST_REAL0(alpha);
 8019914:	eeb0 ea47 	vmov.f32	s28, s14
 8019918:	eef0 ea67 	vmov.f32	s29, s15
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801991c:	2300      	movs	r3, #0
 801991e:	f00e fd2b 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8019922:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8019926:	e9d7 ab00 	ldrd	sl, fp, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801992a:	eeb0 fa47 	vmov.f32	s30, s14
 801992e:	eef0 fa67 	vmov.f32	s31, s15
    const BASE beta_imag = CONST_IMAG0(beta);
 8019932:	ed97 8b02 	vldr	d8, [r7, #8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8019936:	b178      	cbz	r0, 8019958 <cblas_zgemm+0xb8>
 8019938:	ec51 0b17 	vmov	r0, r1, d7
 801993c:	2200      	movs	r2, #0
 801993e:	2300      	movs	r3, #0
 8019940:	f00e fd1a 	bl	8028378 <__aeabi_dcmpeq>
 8019944:	b140      	cbz	r0, 8019958 <cblas_zgemm+0xb8>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8019946:	4bc0      	ldr	r3, [pc, #768]	; (8019c48 <cblas_zgemm+0x3a8>)
 8019948:	2200      	movs	r2, #0
 801994a:	4650      	mov	r0, sl
 801994c:	4659      	mov	r1, fp
 801994e:	f00e fd13 	bl	8028378 <__aeabi_dcmpeq>
 8019952:	2800      	cmp	r0, #0
 8019954:	f040 838b 	bne.w	801a06e <cblas_zgemm+0x7ce>
    if (Order == CblasRowMajor) {
 8019958:	2d65      	cmp	r5, #101	; 0x65
 801995a:	f000 824c 	beq.w	8019df6 <cblas_zgemm+0x556>
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 801995e:	2c71      	cmp	r4, #113	; 0x71
 8019960:	f000 836f 	beq.w	801a042 <cblas_zgemm+0x7a2>
 8019964:	2c6f      	cmp	r4, #111	; 0x6f
 8019966:	bf0c      	ite	eq
 8019968:	236f      	moveq	r3, #111	; 0x6f
 801996a:	2370      	movne	r3, #112	; 0x70
 801996c:	9309      	str	r3, [sp, #36]	; 0x24
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801996e:	2e71      	cmp	r6, #113	; 0x71
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 8019970:	f04f 0301 	mov.w	r3, #1
 8019974:	9307      	str	r3, [sp, #28]
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 8019976:	f000 836d 	beq.w	801a054 <cblas_zgemm+0x7b4>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801997a:	2e6f      	cmp	r6, #111	; 0x6f
 801997c:	bf0c      	ite	eq
 801997e:	236f      	moveq	r3, #111	; 0x6f
 8019980:	2370      	movne	r3, #112	; 0x70
 8019982:	930a      	str	r3, [sp, #40]	; 0x28
 8019984:	2301      	movs	r3, #1
 8019986:	9305      	str	r3, [sp, #20]
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8019988:	2200      	movs	r2, #0
 801998a:	2300      	movs	r3, #0
 801998c:	4650      	mov	r0, sl
 801998e:	4659      	mov	r1, fp
 8019990:	f00e fcf2 	bl	8028378 <__aeabi_dcmpeq>
 8019994:	2200      	movs	r2, #0
 8019996:	2800      	cmp	r0, #0
 8019998:	f000 8183 	beq.w	8019ca2 <cblas_zgemm+0x402>
 801999c:	ec51 0b18 	vmov	r0, r1, d8
 80199a0:	2300      	movs	r3, #0
 80199a2:	f00e fce9 	bl	8028378 <__aeabi_dcmpeq>
 80199a6:	2800      	cmp	r0, #0
 80199a8:	f000 818a 	beq.w	8019cc0 <cblas_zgemm+0x420>
      for (i = 0; i < n1; i++) {
 80199ac:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 80199ae:	2b00      	cmp	r3, #0
 80199b0:	dd1e      	ble.n	80199f0 <cblas_zgemm+0x150>
 80199b2:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 80199b4:	9d04      	ldr	r5, [sp, #16]
 80199b6:	f8dd c0a8 	ldr.w	ip, [sp, #168]	; 0xa8
 80199ba:	011c      	lsls	r4, r3, #4
 80199bc:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 80199be:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 80199c2:	461a      	mov	r2, r3
 80199c4:	0100      	lsls	r0, r0, #4
 80199c6:	462b      	mov	r3, r5
 80199c8:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 80199cc:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 80199ce:	2600      	movs	r6, #0
 80199d0:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 80199d2:	2d00      	cmp	r5, #0
 80199d4:	bfc8      	it	gt
 80199d6:	1813      	addgt	r3, r2, r0
 80199d8:	dd06      	ble.n	80199e8 <cblas_zgemm+0x148>
          REAL(C, ldc * i + j) = 0.0;
 80199da:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 80199de:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 80199e2:	3310      	adds	r3, #16
 80199e4:	429a      	cmp	r2, r3
 80199e6:	d1f8      	bne.n	80199da <cblas_zgemm+0x13a>
      for (i = 0; i < n1; i++) {
 80199e8:	3101      	adds	r1, #1
 80199ea:	458c      	cmp	ip, r1
 80199ec:	4422      	add	r2, r4
 80199ee:	d1f0      	bne.n	80199d2 <cblas_zgemm+0x132>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80199f0:	ec51 0b1e 	vmov	r0, r1, d14
 80199f4:	2200      	movs	r2, #0
 80199f6:	2300      	movs	r3, #0
 80199f8:	f00e fcbe 	bl	8028378 <__aeabi_dcmpeq>
 80199fc:	b140      	cbz	r0, 8019a10 <cblas_zgemm+0x170>
 80199fe:	ec51 0b1f 	vmov	r0, r1, d15
 8019a02:	2200      	movs	r2, #0
 8019a04:	2300      	movs	r3, #0
 8019a06:	f00e fcb7 	bl	8028378 <__aeabi_dcmpeq>
 8019a0a:	2800      	cmp	r0, #0
 8019a0c:	f040 8109 	bne.w	8019c22 <cblas_zgemm+0x382>
    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 8019a10:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8019a12:	2b6f      	cmp	r3, #111	; 0x6f
 8019a14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8019a16:	f000 8215 	beq.w	8019e44 <cblas_zgemm+0x5a4>
    } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
 8019a1a:	2b6f      	cmp	r3, #111	; 0x6f
 8019a1c:	f000 842b 	beq.w	801a276 <cblas_zgemm+0x9d6>
      for (i = 0; i < n1; i++) {
 8019a20:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8019a22:	2b00      	cmp	r3, #0
 8019a24:	f340 80fd 	ble.w	8019c22 <cblas_zgemm+0x382>
 8019a28:	2300      	movs	r3, #0
 8019a2a:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8019a2c:	930b      	str	r3, [sp, #44]	; 0x2c
 8019a2e:	930c      	str	r3, [sp, #48]	; 0x30
 8019a30:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 8019a32:	0112      	lsls	r2, r2, #4
 8019a34:	011b      	lsls	r3, r3, #4
 8019a36:	9202      	str	r2, [sp, #8]
 8019a38:	930d      	str	r3, [sp, #52]	; 0x34
 8019a3a:	9a04      	ldr	r2, [sp, #16]
 8019a3c:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8019a3e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8019a42:	9308      	str	r3, [sp, #32]
 8019a44:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8019a46:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 8019a48:	3308      	adds	r3, #8
 8019a4a:	9309      	str	r3, [sp, #36]	; 0x24
 8019a4c:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8019a4e:	011b      	lsls	r3, r3, #4
 8019a50:	930a      	str	r3, [sp, #40]	; 0x28
 8019a52:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8019a54:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8019a58:	930e      	str	r3, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 8019a5a:	9b04      	ldr	r3, [sp, #16]
 8019a5c:	2b00      	cmp	r3, #0
 8019a5e:	f340 80ce 	ble.w	8019bfe <cblas_zgemm+0x35e>
 8019a62:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8019a64:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8019a66:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8019a6a:	9306      	str	r3, [sp, #24]
 8019a6c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8019a6e:	9301      	str	r3, [sp, #4]
 8019a70:	2300      	movs	r3, #0
 8019a72:	9303      	str	r3, [sp, #12]
          for (k = 0; k < K; k++) {
 8019a74:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8019a76:	2b00      	cmp	r3, #0
 8019a78:	f340 8510 	ble.w	801a49c <cblas_zgemm+0xbfc>
 8019a7c:	9807      	ldr	r0, [sp, #28]
 8019a7e:	f00e f9a9 	bl	8027dd4 <__aeabi_i2d>
 8019a82:	4602      	mov	r2, r0
 8019a84:	460b      	mov	r3, r1
 8019a86:	9805      	ldr	r0, [sp, #20]
 8019a88:	ec43 2b1c 	vmov	d12, r2, r3
 8019a8c:	f00e f9a2 	bl	8027dd4 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 8019a90:	ed9f 7b6b 	vldr	d7, [pc, #428]	; 8019c40 <cblas_zgemm+0x3a0>
 8019a94:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8019a96:	9a03      	ldr	r2, [sp, #12]
          for (k = 0; k < K; k++) {
 8019a98:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
          BASE temp_imag = 0.0;
 8019a9c:	eeb0 ba47 	vmov.f32	s22, s14
 8019aa0:	eef0 ba67 	vmov.f32	s23, s15
 8019aa4:	ec41 0b1d 	vmov	d13, r0, r1
          BASE temp_real = 0.0;
 8019aa8:	eeb0 aa47 	vmov.f32	s20, s14
 8019aac:	eef0 aa67 	vmov.f32	s21, s15
 8019ab0:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8019ab4:	e9db 2300 	ldrd	r2, r3, [fp]
 8019ab8:	ec51 0b1c 	vmov	r0, r1, d12
 8019abc:	f00e f9f4 	bl	8027ea8 <__aeabi_dmul>
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019ac0:	e9da 2302 	ldrd	r2, r3, [sl, #8]
            const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 8019ac4:	4606      	mov	r6, r0
 8019ac6:	460f      	mov	r7, r1
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019ac8:	ec51 0b1d 	vmov	r0, r1, d13
 8019acc:	f00e f9ec 	bl	8027ea8 <__aeabi_dmul>
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 8019ad0:	ed9a 9b00 	vldr	d9, [sl]
            const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 8019ad4:	ed1b 8b02 	vldr	d8, [fp, #-8]
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8019ad8:	ec53 2b19 	vmov	r2, r3, d9
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019adc:	4680      	mov	r8, r0
 8019ade:	4689      	mov	r9, r1
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8019ae0:	ec51 0b18 	vmov	r0, r1, d8
 8019ae4:	f00e f9e0 	bl	8027ea8 <__aeabi_dmul>
 8019ae8:	4642      	mov	r2, r8
 8019aea:	4604      	mov	r4, r0
 8019aec:	460d      	mov	r5, r1
 8019aee:	464b      	mov	r3, r9
 8019af0:	4630      	mov	r0, r6
 8019af2:	4639      	mov	r1, r7
 8019af4:	f00e f9d8 	bl	8027ea8 <__aeabi_dmul>
 8019af8:	4602      	mov	r2, r0
 8019afa:	460b      	mov	r3, r1
 8019afc:	4620      	mov	r0, r4
 8019afe:	4629      	mov	r1, r5
 8019b00:	f00e f81a 	bl	8027b38 <__aeabi_dsub>
 8019b04:	4602      	mov	r2, r0
 8019b06:	460b      	mov	r3, r1
 8019b08:	ec51 0b1a 	vmov	r0, r1, d10
 8019b0c:	f00e f816 	bl	8027b3c <__adddf3>
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8019b10:	4642      	mov	r2, r8
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8019b12:	4604      	mov	r4, r0
 8019b14:	460d      	mov	r5, r1
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8019b16:	464b      	mov	r3, r9
 8019b18:	ec51 0b18 	vmov	r0, r1, d8
 8019b1c:	f00e f9c4 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
 8019b20:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8019b24:	ec53 2b19 	vmov	r2, r3, d9
 8019b28:	4604      	mov	r4, r0
 8019b2a:	460d      	mov	r5, r1
 8019b2c:	4630      	mov	r0, r6
 8019b2e:	4639      	mov	r1, r7
 8019b30:	f00e f9ba 	bl	8027ea8 <__aeabi_dmul>
 8019b34:	4602      	mov	r2, r0
 8019b36:	460b      	mov	r3, r1
 8019b38:	4620      	mov	r0, r4
 8019b3a:	4629      	mov	r1, r5
 8019b3c:	f00d fffe 	bl	8027b3c <__adddf3>
 8019b40:	460b      	mov	r3, r1
 8019b42:	4602      	mov	r2, r0
 8019b44:	ec51 0b1b 	vmov	r0, r1, d11
 8019b48:	f00d fff8 	bl	8027b3c <__adddf3>
 8019b4c:	9b02      	ldr	r3, [sp, #8]
 8019b4e:	449b      	add	fp, r3
          for (k = 0; k < K; k++) {
 8019b50:	9b01      	ldr	r3, [sp, #4]
 8019b52:	f10a 0a10 	add.w	sl, sl, #16
 8019b56:	4553      	cmp	r3, sl
            temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
 8019b58:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < K; k++) {
 8019b5c:	d1aa      	bne.n	8019ab4 <cblas_zgemm+0x214>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8019b5e:	ec53 2b1a 	vmov	r2, r3, d10
 8019b62:	ec51 0b1e 	vmov	r0, r1, d14
 8019b66:	f00e f99f 	bl	8027ea8 <__aeabi_dmul>
 8019b6a:	ec5a 9b1b 	vmov	r9, sl, d11
 8019b6e:	ec58 7b1f 	vmov	r7, r8, d15
 8019b72:	4604      	mov	r4, r0
 8019b74:	460d      	mov	r5, r1
 8019b76:	ee1b 2a10 	vmov	r2, s22
 8019b7a:	4653      	mov	r3, sl
 8019b7c:	ee1f 0a10 	vmov	r0, s30
 8019b80:	4641      	mov	r1, r8
 8019b82:	f00e f991 	bl	8027ea8 <__aeabi_dmul>
 8019b86:	4602      	mov	r2, r0
 8019b88:	460b      	mov	r3, r1
 8019b8a:	4620      	mov	r0, r4
 8019b8c:	4629      	mov	r1, r5
 8019b8e:	f00d ffd3 	bl	8027b38 <__aeabi_dsub>
 8019b92:	9e06      	ldr	r6, [sp, #24]
 8019b94:	4602      	mov	r2, r0
 8019b96:	460b      	mov	r3, r1
 8019b98:	e9d6 0100 	ldrd	r0, r1, [r6]
 8019b9c:	f00d ffce 	bl	8027b3c <__adddf3>
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8019ba0:	ee1b 2a10 	vmov	r2, s22
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8019ba4:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8019ba8:	4653      	mov	r3, sl
 8019baa:	ec51 0b1e 	vmov	r0, r1, d14
 8019bae:	f00e f97b 	bl	8027ea8 <__aeabi_dmul>
 8019bb2:	ec53 2b1a 	vmov	r2, r3, d10
 8019bb6:	4604      	mov	r4, r0
 8019bb8:	460d      	mov	r5, r1
 8019bba:	ee1f 0a10 	vmov	r0, s30
 8019bbe:	4641      	mov	r1, r8
 8019bc0:	f00e f972 	bl	8027ea8 <__aeabi_dmul>
 8019bc4:	4602      	mov	r2, r0
 8019bc6:	460b      	mov	r3, r1
 8019bc8:	4620      	mov	r0, r4
 8019bca:	4629      	mov	r1, r5
 8019bcc:	f00d ffb6 	bl	8027b3c <__adddf3>
 8019bd0:	4602      	mov	r2, r0
 8019bd2:	460b      	mov	r3, r1
 8019bd4:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8019bd8:	f00d ffb0 	bl	8027b3c <__adddf3>
 8019bdc:	9a03      	ldr	r2, [sp, #12]
 8019bde:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8019be2:	992e      	ldr	r1, [sp, #184]	; 0xb8
 8019be4:	440a      	add	r2, r1
 8019be6:	9203      	str	r2, [sp, #12]
 8019be8:	990a      	ldr	r1, [sp, #40]	; 0x28
 8019bea:	9a01      	ldr	r2, [sp, #4]
 8019bec:	440a      	add	r2, r1
 8019bee:	9201      	str	r2, [sp, #4]
 8019bf0:	9a08      	ldr	r2, [sp, #32]
 8019bf2:	f106 0310 	add.w	r3, r6, #16
 8019bf6:	429a      	cmp	r2, r3
 8019bf8:	9306      	str	r3, [sp, #24]
 8019bfa:	f47f af3b 	bne.w	8019a74 <cblas_zgemm+0x1d4>
      for (i = 0; i < n1; i++) {
 8019bfe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8019c00:	9933      	ldr	r1, [sp, #204]	; 0xcc
 8019c02:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8019c04:	440a      	add	r2, r1
 8019c06:	920b      	str	r2, [sp, #44]	; 0x2c
 8019c08:	990d      	ldr	r1, [sp, #52]	; 0x34
 8019c0a:	9a08      	ldr	r2, [sp, #32]
 8019c0c:	440a      	add	r2, r1
 8019c0e:	9208      	str	r2, [sp, #32]
 8019c10:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8019c12:	3210      	adds	r2, #16
 8019c14:	9209      	str	r2, [sp, #36]	; 0x24
 8019c16:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8019c18:	3301      	adds	r3, #1
 8019c1a:	429a      	cmp	r2, r3
 8019c1c:	930c      	str	r3, [sp, #48]	; 0x30
 8019c1e:	f47f af1c 	bne.w	8019a5a <cblas_zgemm+0x1ba>
#define BASE double
#include "source_gemm_c.h"
#undef BASE
}
 8019c22:	b011      	add	sp, #68	; 0x44
 8019c24:	ecbd 8b10 	vpop	{d8-d15}
 8019c28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8019c2c:	3865      	subs	r0, #101	; 0x65
 8019c2e:	2801      	cmp	r0, #1
 8019c30:	bf94      	ite	ls
 8019c32:	2000      	movls	r0, #0
 8019c34:	2001      	movhi	r0, #1
 8019c36:	2170      	movs	r1, #112	; 0x70
 8019c38:	e64d      	b.n	80198d6 <cblas_zgemm+0x36>
 8019c3a:	bf00      	nop
 8019c3c:	f3af 8000 	nop.w
	...
 8019c48:	3ff00000 	.word	0x3ff00000
 8019c4c:	2d65      	cmp	r5, #101	; 0x65
 8019c4e:	f04f 0006 	mov.w	r0, #6
 8019c52:	f000 809e 	beq.w	8019d92 <cblas_zgemm+0x4f2>
 8019c56:	2d66      	cmp	r5, #102	; 0x66
 8019c58:	d11e      	bne.n	8019c98 <cblas_zgemm+0x3f8>
 8019c5a:	2a6f      	cmp	r2, #111	; 0x6f
 8019c5c:	bf0c      	ite	eq
 8019c5e:	9b2b      	ldreq	r3, [sp, #172]	; 0xac
 8019c60:	9b2a      	ldrne	r3, [sp, #168]	; 0xa8
 8019c62:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8019c64:	2b01      	cmp	r3, #1
 8019c66:	bfb8      	it	lt
 8019c68:	2301      	movlt	r3, #1
 8019c6a:	4293      	cmp	r3, r2
 8019c6c:	bfc8      	it	gt
 8019c6e:	200b      	movgt	r0, #11
 8019c70:	296f      	cmp	r1, #111	; 0x6f
 8019c72:	f000 83ec 	beq.w	801a44e <cblas_zgemm+0xbae>
 8019c76:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8019c78:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8019c7a:	2b01      	cmp	r3, #1
 8019c7c:	bfb8      	it	lt
 8019c7e:	2301      	movlt	r3, #1
 8019c80:	4293      	cmp	r3, r2
 8019c82:	f300 845d 	bgt.w	801a540 <cblas_zgemm+0xca0>
 8019c86:	9b04      	ldr	r3, [sp, #16]
 8019c88:	2b01      	cmp	r3, #1
 8019c8a:	bfb8      	it	lt
 8019c8c:	2301      	movlt	r3, #1
 8019c8e:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 8019c90:	429a      	cmp	r2, r3
 8019c92:	f6bf ae37 	bge.w	8019904 <cblas_zgemm+0x64>
 8019c96:	200e      	movs	r0, #14
 8019c98:	4a67      	ldr	r2, [pc, #412]	; (8019e38 <cblas_zgemm+0x598>)
 8019c9a:	4968      	ldr	r1, [pc, #416]	; (8019e3c <cblas_zgemm+0x59c>)
 8019c9c:	f00d fed4 	bl	8027a48 <cblas_xerbla>
 8019ca0:	e633      	b.n	801990a <cblas_zgemm+0x6a>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8019ca2:	4b67      	ldr	r3, [pc, #412]	; (8019e40 <cblas_zgemm+0x5a0>)
 8019ca4:	4650      	mov	r0, sl
 8019ca6:	4659      	mov	r1, fp
 8019ca8:	f00e fb66 	bl	8028378 <__aeabi_dcmpeq>
 8019cac:	b140      	cbz	r0, 8019cc0 <cblas_zgemm+0x420>
 8019cae:	ec51 0b18 	vmov	r0, r1, d8
 8019cb2:	2200      	movs	r2, #0
 8019cb4:	2300      	movs	r3, #0
 8019cb6:	f00e fb5f 	bl	8028378 <__aeabi_dcmpeq>
 8019cba:	2800      	cmp	r0, #0
 8019cbc:	f47f ae98 	bne.w	80199f0 <cblas_zgemm+0x150>
      for (i = 0; i < n1; i++) {
 8019cc0:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8019cc2:	2b00      	cmp	r3, #0
 8019cc4:	f77f ae94 	ble.w	80199f0 <cblas_zgemm+0x150>
 8019cc8:	9a04      	ldr	r2, [sp, #16]
 8019cca:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8019cce:	011b      	lsls	r3, r3, #4
 8019cd0:	9306      	str	r3, [sp, #24]
 8019cd2:	3308      	adds	r3, #8
 8019cd4:	9308      	str	r3, [sp, #32]
 8019cd6:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 8019cd8:	011b      	lsls	r3, r3, #4
 8019cda:	9303      	str	r3, [sp, #12]
 8019cdc:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8019cde:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8019ce2:	9301      	str	r3, [sp, #4]
 8019ce4:	2300      	movs	r3, #0
 8019ce6:	9302      	str	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 8019ce8:	9b04      	ldr	r3, [sp, #16]
 8019cea:	2b00      	cmp	r3, #0
 8019cec:	dd3e      	ble.n	8019d6c <cblas_zgemm+0x4cc>
 8019cee:	9b06      	ldr	r3, [sp, #24]
 8019cf0:	9a08      	ldr	r2, [sp, #32]
 8019cf2:	4619      	mov	r1, r3
 8019cf4:	9b01      	ldr	r3, [sp, #4]
 8019cf6:	eb01 0803 	add.w	r8, r1, r3
 8019cfa:	eb02 0903 	add.w	r9, r2, r3
          const BASE Cij_real = REAL(C, ldc * i + j);
 8019cfe:	e959 4502 	ldrd	r4, r5, [r9, #-8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8019d02:	4650      	mov	r0, sl
 8019d04:	4622      	mov	r2, r4
 8019d06:	462b      	mov	r3, r5
 8019d08:	4659      	mov	r1, fp
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 8019d0a:	e9d8 6702 	ldrd	r6, r7, [r8, #8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8019d0e:	f00e f8cb 	bl	8027ea8 <__aeabi_dmul>
 8019d12:	4632      	mov	r2, r6
 8019d14:	ec41 0b19 	vmov	d9, r0, r1
 8019d18:	463b      	mov	r3, r7
 8019d1a:	ec51 0b18 	vmov	r0, r1, d8
 8019d1e:	f00e f8c3 	bl	8027ea8 <__aeabi_dmul>
 8019d22:	4602      	mov	r2, r0
 8019d24:	460b      	mov	r3, r1
 8019d26:	ec51 0b19 	vmov	r0, r1, d9
 8019d2a:	f00d ff05 	bl	8027b38 <__aeabi_dsub>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8019d2e:	4632      	mov	r2, r6
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8019d30:	e949 0102 	strd	r0, r1, [r9, #-8]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8019d34:	463b      	mov	r3, r7
 8019d36:	4650      	mov	r0, sl
 8019d38:	4659      	mov	r1, fp
 8019d3a:	f00e f8b5 	bl	8027ea8 <__aeabi_dmul>
 8019d3e:	4622      	mov	r2, r4
 8019d40:	462b      	mov	r3, r5
 8019d42:	4604      	mov	r4, r0
 8019d44:	460d      	mov	r5, r1
 8019d46:	ec51 0b18 	vmov	r0, r1, d8
 8019d4a:	f00e f8ad 	bl	8027ea8 <__aeabi_dmul>
 8019d4e:	460b      	mov	r3, r1
 8019d50:	4602      	mov	r2, r0
 8019d52:	4629      	mov	r1, r5
 8019d54:	4620      	mov	r0, r4
 8019d56:	f00d fef1 	bl	8027b3c <__adddf3>
        for (j = 0; j < n2; j++) {
 8019d5a:	9b01      	ldr	r3, [sp, #4]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8019d5c:	e9c8 0102 	strd	r0, r1, [r8, #8]
        for (j = 0; j < n2; j++) {
 8019d60:	f108 0810 	add.w	r8, r8, #16
 8019d64:	4543      	cmp	r3, r8
 8019d66:	f109 0910 	add.w	r9, r9, #16
 8019d6a:	d1c8      	bne.n	8019cfe <cblas_zgemm+0x45e>
      for (i = 0; i < n1; i++) {
 8019d6c:	9a01      	ldr	r2, [sp, #4]
 8019d6e:	9903      	ldr	r1, [sp, #12]
 8019d70:	9b02      	ldr	r3, [sp, #8]
 8019d72:	440a      	add	r2, r1
 8019d74:	9201      	str	r2, [sp, #4]
 8019d76:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8019d78:	3301      	adds	r3, #1
 8019d7a:	429a      	cmp	r2, r3
 8019d7c:	9302      	str	r3, [sp, #8]
 8019d7e:	d1b3      	bne.n	8019ce8 <cblas_zgemm+0x448>
 8019d80:	e636      	b.n	80199f0 <cblas_zgemm+0x150>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8019d82:	2b00      	cmp	r3, #0
 8019d84:	f6ff af62 	blt.w	8019c4c <cblas_zgemm+0x3ac>
 8019d88:	2d65      	cmp	r5, #101	; 0x65
 8019d8a:	f04f 0005 	mov.w	r0, #5
 8019d8e:	f47f af62 	bne.w	8019c56 <cblas_zgemm+0x3b6>
 8019d92:	2a6f      	cmp	r2, #111	; 0x6f
 8019d94:	bf0c      	ite	eq
 8019d96:	9b2b      	ldreq	r3, [sp, #172]	; 0xac
 8019d98:	9b04      	ldrne	r3, [sp, #16]
 8019d9a:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 8019d9c:	2b01      	cmp	r3, #1
 8019d9e:	bfb8      	it	lt
 8019da0:	2301      	movlt	r3, #1
 8019da2:	4293      	cmp	r3, r2
 8019da4:	bfc8      	it	gt
 8019da6:	2009      	movgt	r0, #9
 8019da8:	296f      	cmp	r1, #111	; 0x6f
 8019daa:	f000 83a3 	beq.w	801a4f4 <cblas_zgemm+0xc54>
 8019dae:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8019db0:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 8019db2:	2b01      	cmp	r3, #1
 8019db4:	bfb8      	it	lt
 8019db6:	2301      	movlt	r3, #1
 8019db8:	4293      	cmp	r3, r2
 8019dba:	f340 8162 	ble.w	801a082 <cblas_zgemm+0x7e2>
 8019dbe:	982a      	ldr	r0, [sp, #168]	; 0xa8
 8019dc0:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 8019dc2:	4a1d      	ldr	r2, [pc, #116]	; (8019e38 <cblas_zgemm+0x598>)
 8019dc4:	491d      	ldr	r1, [pc, #116]	; (8019e3c <cblas_zgemm+0x59c>)
 8019dc6:	2801      	cmp	r0, #1
 8019dc8:	bfb8      	it	lt
 8019dca:	2001      	movlt	r0, #1
 8019dcc:	4283      	cmp	r3, r0
 8019dce:	bfb4      	ite	lt
 8019dd0:	200e      	movlt	r0, #14
 8019dd2:	200b      	movge	r0, #11
 8019dd4:	f00d fe38 	bl	8027a48 <cblas_xerbla>
 8019dd8:	e597      	b.n	801990a <cblas_zgemm+0x6a>
 8019dda:	2971      	cmp	r1, #113	; 0x71
 8019ddc:	f000 8399 	beq.w	801a512 <cblas_zgemm+0xc72>
 8019de0:	2a71      	cmp	r2, #113	; 0x71
 8019de2:	f000 8342 	beq.w	801a46a <cblas_zgemm+0xbca>
 8019de6:	f1a6 036f 	sub.w	r3, r6, #111	; 0x6f
 8019dea:	2b02      	cmp	r3, #2
 8019dec:	4611      	mov	r1, r2
 8019dee:	4632      	mov	r2, r6
 8019df0:	f63f ad70 	bhi.w	80198d4 <cblas_zgemm+0x34>
 8019df4:	e134      	b.n	801a060 <cblas_zgemm+0x7c0>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 8019df6:	2e71      	cmp	r6, #113	; 0x71
 8019df8:	f000 839c 	beq.w	801a534 <cblas_zgemm+0xc94>
 8019dfc:	2e6f      	cmp	r6, #111	; 0x6f
 8019dfe:	bf0c      	ite	eq
 8019e00:	236f      	moveq	r3, #111	; 0x6f
 8019e02:	2370      	movne	r3, #112	; 0x70
 8019e04:	9309      	str	r3, [sp, #36]	; 0x24
 8019e06:	2301      	movs	r3, #1
 8019e08:	9307      	str	r3, [sp, #28]
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8019e0a:	e9dd 032e 	ldrd	r0, r3, [sp, #184]	; 0xb8
 8019e0e:	9930      	ldr	r1, [sp, #192]	; 0xc0
 8019e10:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 8019e12:	9030      	str	r0, [sp, #192]	; 0xc0
 8019e14:	2c71      	cmp	r4, #113	; 0x71
 8019e16:	9804      	ldr	r0, [sp, #16]
 8019e18:	902a      	str	r0, [sp, #168]	; 0xa8
 8019e1a:	912e      	str	r1, [sp, #184]	; 0xb8
 8019e1c:	9204      	str	r2, [sp, #16]
 8019e1e:	f000 837f 	beq.w	801a520 <cblas_zgemm+0xc80>
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8019e22:	2c6f      	cmp	r4, #111	; 0x6f
 8019e24:	f040 8132 	bne.w	801a08c <cblas_zgemm+0x7ec>
      F = (const BASE *)A;
 8019e28:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 8019e2a:	922f      	str	r2, [sp, #188]	; 0xbc
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8019e2c:	2201      	movs	r2, #1
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8019e2e:	940a      	str	r4, [sp, #40]	; 0x28
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 8019e30:	9205      	str	r2, [sp, #20]
      G = (const BASE *)B;
 8019e32:	932d      	str	r3, [sp, #180]	; 0xb4
 8019e34:	e5a8      	b.n	8019988 <cblas_zgemm+0xe8>
 8019e36:	bf00      	nop
 8019e38:	08030378 	.word	0x08030378
 8019e3c:	080306b0 	.word	0x080306b0
 8019e40:	3ff00000 	.word	0x3ff00000
    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
 8019e44:	2b6f      	cmp	r3, #111	; 0x6f
 8019e46:	f000 8129 	beq.w	801a09c <cblas_zgemm+0x7fc>
      for (i = 0; i < n1; i++) {
 8019e4a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8019e4c:	2b00      	cmp	r3, #0
 8019e4e:	f77f aee8 	ble.w	8019c22 <cblas_zgemm+0x382>
 8019e52:	9930      	ldr	r1, [sp, #192]	; 0xc0
 8019e54:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8019e56:	9308      	str	r3, [sp, #32]
 8019e58:	0109      	lsls	r1, r1, #4
 8019e5a:	910b      	str	r1, [sp, #44]	; 0x2c
 8019e5c:	992b      	ldr	r1, [sp, #172]	; 0xac
 8019e5e:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 8019e62:	9301      	str	r3, [sp, #4]
 8019e64:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 8019e66:	2200      	movs	r2, #0
 8019e68:	011b      	lsls	r3, r3, #4
 8019e6a:	9209      	str	r2, [sp, #36]	; 0x24
 8019e6c:	920a      	str	r2, [sp, #40]	; 0x28
 8019e6e:	930c      	str	r3, [sp, #48]	; 0x30
 8019e70:	9a04      	ldr	r2, [sp, #16]
 8019e72:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8019e74:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8019e78:	9306      	str	r3, [sp, #24]
        for (j = 0; j < n2; j++) {
 8019e7a:	9b04      	ldr	r3, [sp, #16]
 8019e7c:	2b00      	cmp	r3, #0
 8019e7e:	f340 80c8 	ble.w	801a012 <cblas_zgemm+0x772>
 8019e82:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8019e84:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8019e86:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8019e8a:	9303      	str	r3, [sp, #12]
 8019e8c:	2300      	movs	r3, #0
 8019e8e:	9302      	str	r3, [sp, #8]
          for (k = 0; k < K; k++) {
 8019e90:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8019e92:	2b00      	cmp	r3, #0
 8019e94:	f340 830e 	ble.w	801a4b4 <cblas_zgemm+0xc14>
 8019e98:	9807      	ldr	r0, [sp, #28]
 8019e9a:	f00d ff9b 	bl	8027dd4 <__aeabi_i2d>
 8019e9e:	4602      	mov	r2, r0
 8019ea0:	460b      	mov	r3, r1
 8019ea2:	9805      	ldr	r0, [sp, #20]
 8019ea4:	ec43 2b1c 	vmov	d12, r2, r3
 8019ea8:	f00d ff94 	bl	8027dd4 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 8019eac:	ed9f 7b8e 	vldr	d7, [pc, #568]	; 801a0e8 <cblas_zgemm+0x848>
 8019eb0:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8019eb2:	9a02      	ldr	r2, [sp, #8]
          for (k = 0; k < K; k++) {
 8019eb4:	f8dd b020 	ldr.w	fp, [sp, #32]
          BASE temp_imag = 0.0;
 8019eb8:	eeb0 ba47 	vmov.f32	s22, s14
 8019ebc:	eef0 ba67 	vmov.f32	s23, s15
 8019ec0:	ec41 0b1d 	vmov	d13, r0, r1
          BASE temp_real = 0.0;
 8019ec4:	eeb0 aa47 	vmov.f32	s20, s14
 8019ec8:	eef0 aa67 	vmov.f32	s21, s15
 8019ecc:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8019ed0:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 8019ed4:	ec51 0b1c 	vmov	r0, r1, d12
 8019ed8:	f00d ffe6 	bl	8027ea8 <__aeabi_dmul>
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019edc:	e9da 2302 	ldrd	r2, r3, [sl, #8]
            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 8019ee0:	4606      	mov	r6, r0
 8019ee2:	460f      	mov	r7, r1
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019ee4:	ec51 0b1d 	vmov	r0, r1, d13
 8019ee8:	f00d ffde 	bl	8027ea8 <__aeabi_dmul>
            const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 8019eec:	ed9b 8b00 	vldr	d8, [fp]
            const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
 8019ef0:	ed9a 9b00 	vldr	d9, [sl]
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019ef4:	4680      	mov	r8, r0
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8019ef6:	ec53 2b19 	vmov	r2, r3, d9
            const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
 8019efa:	4689      	mov	r9, r1
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8019efc:	ec51 0b18 	vmov	r0, r1, d8
 8019f00:	f00d ffd2 	bl	8027ea8 <__aeabi_dmul>
 8019f04:	4642      	mov	r2, r8
 8019f06:	4604      	mov	r4, r0
 8019f08:	460d      	mov	r5, r1
 8019f0a:	464b      	mov	r3, r9
 8019f0c:	4630      	mov	r0, r6
 8019f0e:	4639      	mov	r1, r7
 8019f10:	f00d ffca 	bl	8027ea8 <__aeabi_dmul>
 8019f14:	4602      	mov	r2, r0
 8019f16:	460b      	mov	r3, r1
 8019f18:	4620      	mov	r0, r4
 8019f1a:	4629      	mov	r1, r5
 8019f1c:	f00d fe0c 	bl	8027b38 <__aeabi_dsub>
 8019f20:	4602      	mov	r2, r0
 8019f22:	460b      	mov	r3, r1
 8019f24:	ec51 0b1a 	vmov	r0, r1, d10
 8019f28:	f00d fe08 	bl	8027b3c <__adddf3>
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8019f2c:	4642      	mov	r2, r8
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8019f2e:	4604      	mov	r4, r0
 8019f30:	460d      	mov	r5, r1
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8019f32:	464b      	mov	r3, r9
 8019f34:	ec51 0b18 	vmov	r0, r1, d8
 8019f38:	f00d ffb6 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
 8019f3c:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8019f40:	ec53 2b19 	vmov	r2, r3, d9
 8019f44:	4604      	mov	r4, r0
 8019f46:	460d      	mov	r5, r1
 8019f48:	4630      	mov	r0, r6
 8019f4a:	4639      	mov	r1, r7
 8019f4c:	f00d ffac 	bl	8027ea8 <__aeabi_dmul>
 8019f50:	4602      	mov	r2, r0
 8019f52:	460b      	mov	r3, r1
 8019f54:	4620      	mov	r0, r4
 8019f56:	4629      	mov	r1, r5
 8019f58:	f00d fdf0 	bl	8027b3c <__adddf3>
 8019f5c:	460b      	mov	r3, r1
 8019f5e:	4602      	mov	r2, r0
 8019f60:	ec51 0b1b 	vmov	r0, r1, d11
 8019f64:	f00d fdea 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 8019f68:	9b01      	ldr	r3, [sp, #4]
 8019f6a:	f10b 0b10 	add.w	fp, fp, #16
 8019f6e:	455b      	cmp	r3, fp
            temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
 8019f70:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < K; k++) {
 8019f74:	f10a 0a10 	add.w	sl, sl, #16
 8019f78:	d1aa      	bne.n	8019ed0 <cblas_zgemm+0x630>
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8019f7a:	ec53 2b1a 	vmov	r2, r3, d10
 8019f7e:	ec51 0b1e 	vmov	r0, r1, d14
 8019f82:	f00d ff91 	bl	8027ea8 <__aeabi_dmul>
 8019f86:	ec5a 9b1b 	vmov	r9, sl, d11
 8019f8a:	ec58 7b1f 	vmov	r7, r8, d15
 8019f8e:	4604      	mov	r4, r0
 8019f90:	460d      	mov	r5, r1
 8019f92:	ee1b 2a10 	vmov	r2, s22
 8019f96:	4653      	mov	r3, sl
 8019f98:	ee1f 0a10 	vmov	r0, s30
 8019f9c:	4641      	mov	r1, r8
 8019f9e:	f00d ff83 	bl	8027ea8 <__aeabi_dmul>
 8019fa2:	4602      	mov	r2, r0
 8019fa4:	460b      	mov	r3, r1
 8019fa6:	4620      	mov	r0, r4
 8019fa8:	4629      	mov	r1, r5
 8019faa:	f00d fdc5 	bl	8027b38 <__aeabi_dsub>
 8019fae:	9e03      	ldr	r6, [sp, #12]
 8019fb0:	4602      	mov	r2, r0
 8019fb2:	460b      	mov	r3, r1
 8019fb4:	e9d6 0100 	ldrd	r0, r1, [r6]
 8019fb8:	f00d fdc0 	bl	8027b3c <__adddf3>
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8019fbc:	ee1b 2a10 	vmov	r2, s22
          REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8019fc0:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8019fc4:	4653      	mov	r3, sl
 8019fc6:	ec51 0b1e 	vmov	r0, r1, d14
 8019fca:	f00d ff6d 	bl	8027ea8 <__aeabi_dmul>
 8019fce:	ec53 2b1a 	vmov	r2, r3, d10
 8019fd2:	4604      	mov	r4, r0
 8019fd4:	460d      	mov	r5, r1
 8019fd6:	ee1f 0a10 	vmov	r0, s30
 8019fda:	4641      	mov	r1, r8
 8019fdc:	f00d ff64 	bl	8027ea8 <__aeabi_dmul>
 8019fe0:	4602      	mov	r2, r0
 8019fe2:	460b      	mov	r3, r1
 8019fe4:	4620      	mov	r0, r4
 8019fe6:	4629      	mov	r1, r5
 8019fe8:	f00d fda8 	bl	8027b3c <__adddf3>
 8019fec:	4602      	mov	r2, r0
 8019fee:	460b      	mov	r3, r1
 8019ff0:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8019ff4:	f00d fda2 	bl	8027b3c <__adddf3>
 8019ff8:	9a02      	ldr	r2, [sp, #8]
 8019ffa:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8019ffe:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801a000:	440a      	add	r2, r1
 801a002:	9202      	str	r2, [sp, #8]
 801a004:	9a06      	ldr	r2, [sp, #24]
 801a006:	f106 0310 	add.w	r3, r6, #16
 801a00a:	429a      	cmp	r2, r3
 801a00c:	9303      	str	r3, [sp, #12]
 801a00e:	f47f af3f 	bne.w	8019e90 <cblas_zgemm+0x5f0>
      for (i = 0; i < n1; i++) {
 801a012:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801a014:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801a016:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801a018:	440a      	add	r2, r1
 801a01a:	9209      	str	r2, [sp, #36]	; 0x24
 801a01c:	990c      	ldr	r1, [sp, #48]	; 0x30
 801a01e:	9a06      	ldr	r2, [sp, #24]
 801a020:	440a      	add	r2, r1
 801a022:	9908      	ldr	r1, [sp, #32]
 801a024:	9206      	str	r2, [sp, #24]
 801a026:	4608      	mov	r0, r1
 801a028:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801a02a:	9901      	ldr	r1, [sp, #4]
 801a02c:	4410      	add	r0, r2
 801a02e:	4411      	add	r1, r2
 801a030:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801a032:	9008      	str	r0, [sp, #32]
 801a034:	3301      	adds	r3, #1
 801a036:	429a      	cmp	r2, r3
 801a038:	930a      	str	r3, [sp, #40]	; 0x28
 801a03a:	9101      	str	r1, [sp, #4]
 801a03c:	f47f af1d 	bne.w	8019e7a <cblas_zgemm+0x5da>
 801a040:	e5ef      	b.n	8019c22 <cblas_zgemm+0x382>
      conjF = (TransB == CblasConjTrans) ? -1 : 1;
 801a042:	f04f 33ff 	mov.w	r3, #4294967295
 801a046:	9307      	str	r3, [sp, #28]
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801a048:	2e71      	cmp	r6, #113	; 0x71
      TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a04a:	f04f 0370 	mov.w	r3, #112	; 0x70
 801a04e:	9309      	str	r3, [sp, #36]	; 0x24
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801a050:	f47f ac93 	bne.w	801997a <cblas_zgemm+0xda>
      TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a054:	2370      	movs	r3, #112	; 0x70
 801a056:	930a      	str	r3, [sp, #40]	; 0x28
      conjG = (TransA == CblasConjTrans) ? -1 : 1;
 801a058:	f04f 33ff 	mov.w	r3, #4294967295
 801a05c:	9305      	str	r3, [sp, #20]
 801a05e:	e493      	b.n	8019988 <cblas_zgemm+0xe8>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801a060:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 801a064:	2801      	cmp	r0, #1
 801a066:	bf94      	ite	ls
 801a068:	2000      	movls	r0, #0
 801a06a:	2001      	movhi	r0, #1
 801a06c:	e433      	b.n	80198d6 <cblas_zgemm+0x36>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801a06e:	ec51 0b18 	vmov	r0, r1, d8
 801a072:	2200      	movs	r2, #0
 801a074:	2300      	movs	r3, #0
 801a076:	f00e f97f 	bl	8028378 <__aeabi_dcmpeq>
 801a07a:	2800      	cmp	r0, #0
 801a07c:	f43f ac6c 	beq.w	8019958 <cblas_zgemm+0xb8>
 801a080:	e5cf      	b.n	8019c22 <cblas_zgemm+0x382>
 801a082:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a084:	2b01      	cmp	r3, #1
 801a086:	bfb8      	it	lt
 801a088:	2301      	movlt	r3, #1
 801a08a:	e600      	b.n	8019c8e <cblas_zgemm+0x3ee>
      F = (const BASE *)A;
 801a08c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 801a08e:	922f      	str	r2, [sp, #188]	; 0xbc
      G = (const BASE *)B;
 801a090:	932d      	str	r3, [sp, #180]	; 0xb4
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a092:	2270      	movs	r2, #112	; 0x70
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801a094:	2301      	movs	r3, #1
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a096:	920a      	str	r2, [sp, #40]	; 0x28
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801a098:	9305      	str	r3, [sp, #20]
 801a09a:	e475      	b.n	8019988 <cblas_zgemm+0xe8>
      for (k = 0; k < K; k++) {
 801a09c:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801a09e:	2b00      	cmp	r3, #0
 801a0a0:	f77f adbf 	ble.w	8019c22 <cblas_zgemm+0x382>
 801a0a4:	2300      	movs	r3, #0
 801a0a6:	930a      	str	r3, [sp, #40]	; 0x28
 801a0a8:	930c      	str	r3, [sp, #48]	; 0x30
 801a0aa:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801a0ac:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801a0ae:	3308      	adds	r3, #8
 801a0b0:	930b      	str	r3, [sp, #44]	; 0x2c
 801a0b2:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a0b4:	0112      	lsls	r2, r2, #4
 801a0b6:	3308      	adds	r3, #8
 801a0b8:	9206      	str	r2, [sp, #24]
 801a0ba:	9309      	str	r3, [sp, #36]	; 0x24
        for (i = 0; i < n1; i++) {
 801a0bc:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a0be:	2b00      	cmp	r3, #0
 801a0c0:	f340 81dc 	ble.w	801a47c <cblas_zgemm+0xbdc>
 801a0c4:	9807      	ldr	r0, [sp, #28]
 801a0c6:	f00d fe85 	bl	8027dd4 <__aeabi_i2d>
 801a0ca:	2300      	movs	r3, #0
 801a0cc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801a0ce:	9302      	str	r3, [sp, #8]
 801a0d0:	9303      	str	r3, [sp, #12]
 801a0d2:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801a0d4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a0d8:	9308      	str	r3, [sp, #32]
 801a0da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801a0dc:	9301      	str	r3, [sp, #4]
 801a0de:	ec41 0b1c 	vmov	d12, r0, r1
 801a0e2:	e01c      	b.n	801a11e <cblas_zgemm+0x87e>
 801a0e4:	f3af 8000 	nop.w
	...
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a0f0:	2200      	movs	r2, #0
 801a0f2:	2300      	movs	r3, #0
 801a0f4:	4620      	mov	r0, r4
 801a0f6:	4629      	mov	r1, r5
 801a0f8:	f00e f93e 	bl	8028378 <__aeabi_dcmpeq>
 801a0fc:	2800      	cmp	r0, #0
 801a0fe:	d055      	beq.n	801a1ac <cblas_zgemm+0x90c>
        for (i = 0; i < n1; i++) {
 801a100:	9a02      	ldr	r2, [sp, #8]
 801a102:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801a104:	9b03      	ldr	r3, [sp, #12]
 801a106:	440a      	add	r2, r1
 801a108:	9202      	str	r2, [sp, #8]
 801a10a:	9906      	ldr	r1, [sp, #24]
 801a10c:	9a01      	ldr	r2, [sp, #4]
 801a10e:	440a      	add	r2, r1
 801a110:	9201      	str	r2, [sp, #4]
 801a112:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801a114:	3301      	adds	r3, #1
 801a116:	429a      	cmp	r2, r3
 801a118:	9303      	str	r3, [sp, #12]
 801a11a:	f000 81af 	beq.w	801a47c <cblas_zgemm+0xbdc>
          const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 801a11e:	9b01      	ldr	r3, [sp, #4]
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801a120:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Fik_real = CONST_REAL(F, ldf * i + k);
 801a124:	e953 6702 	ldrd	r6, r7, [r3, #-8]
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801a128:	e9d3 2300 	ldrd	r2, r3, [r3]
 801a12c:	f00d febc 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801a130:	4632      	mov	r2, r6
          const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
 801a132:	4604      	mov	r4, r0
 801a134:	460d      	mov	r5, r1
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801a136:	463b      	mov	r3, r7
 801a138:	ec51 0b1e 	vmov	r0, r1, d14
 801a13c:	f00d feb4 	bl	8027ea8 <__aeabi_dmul>
 801a140:	ec5b ab1f 	vmov	sl, fp, d15
 801a144:	4622      	mov	r2, r4
 801a146:	462b      	mov	r3, r5
 801a148:	4680      	mov	r8, r0
 801a14a:	4689      	mov	r9, r1
 801a14c:	ee1f 0a10 	vmov	r0, s30
 801a150:	4659      	mov	r1, fp
 801a152:	f00d fea9 	bl	8027ea8 <__aeabi_dmul>
 801a156:	4602      	mov	r2, r0
 801a158:	460b      	mov	r3, r1
 801a15a:	4640      	mov	r0, r8
 801a15c:	4649      	mov	r1, r9
 801a15e:	f00d fceb 	bl	8027b38 <__aeabi_dsub>
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801a162:	4622      	mov	r2, r4
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801a164:	4680      	mov	r8, r0
 801a166:	4689      	mov	r9, r1
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801a168:	462b      	mov	r3, r5
 801a16a:	ec51 0b1e 	vmov	r0, r1, d14
 801a16e:	f00d fe9b 	bl	8027ea8 <__aeabi_dmul>
 801a172:	4632      	mov	r2, r6
 801a174:	4604      	mov	r4, r0
 801a176:	460d      	mov	r5, r1
 801a178:	463b      	mov	r3, r7
 801a17a:	ee1f 0a10 	vmov	r0, s30
 801a17e:	4659      	mov	r1, fp
 801a180:	f00d fe92 	bl	8027ea8 <__aeabi_dmul>
 801a184:	4602      	mov	r2, r0
 801a186:	460b      	mov	r3, r1
 801a188:	4620      	mov	r0, r4
 801a18a:	4629      	mov	r1, r5
 801a18c:	f00d fcd6 	bl	8027b3c <__adddf3>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a190:	2200      	movs	r2, #0
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801a192:	4604      	mov	r4, r0
 801a194:	460d      	mov	r5, r1
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a196:	2300      	movs	r3, #0
 801a198:	4640      	mov	r0, r8
 801a19a:	4649      	mov	r1, r9
          const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
 801a19c:	ec49 8b1a 	vmov	d10, r8, r9
          const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
 801a1a0:	ec45 4b19 	vmov	d9, r4, r5
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a1a4:	f00e f8e8 	bl	8028378 <__aeabi_dcmpeq>
 801a1a8:	2800      	cmp	r0, #0
 801a1aa:	d1a1      	bne.n	801a0f0 <cblas_zgemm+0x850>
            for (j = 0; j < n2; j++) {
 801a1ac:	9b04      	ldr	r3, [sp, #16]
 801a1ae:	2b00      	cmp	r3, #0
 801a1b0:	dda6      	ble.n	801a100 <cblas_zgemm+0x860>
 801a1b2:	9805      	ldr	r0, [sp, #20]
 801a1b4:	f00d fe0e 	bl	8027dd4 <__aeabi_i2d>
 801a1b8:	9b04      	ldr	r3, [sp, #16]
 801a1ba:	9a32      	ldr	r2, [sp, #200]	; 0xc8
 801a1bc:	f8dd b020 	ldr.w	fp, [sp, #32]
 801a1c0:	461c      	mov	r4, r3
 801a1c2:	9b02      	ldr	r3, [sp, #8]
 801a1c4:	eb04 0a03 	add.w	sl, r4, r3
 801a1c8:	eb02 1a0a 	add.w	sl, r2, sl, lsl #4
 801a1cc:	eb02 1403 	add.w	r4, r2, r3, lsl #4
 801a1d0:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801a1d2:	ec41 0b1b 	vmov	d11, r0, r1
 801a1d6:	eb02 1503 	add.w	r5, r2, r3, lsl #4
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801a1da:	ed9b 7b00 	vldr	d7, [fp]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801a1de:	e9db 2302 	ldrd	r2, r3, [fp, #8]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801a1e2:	eeb0 8a47 	vmov.f32	s16, s14
 801a1e6:	eef0 8a67 	vmov.f32	s17, s15
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801a1ea:	ec51 0b1b 	vmov	r0, r1, d11
 801a1ee:	f00d fe5b 	bl	8027ea8 <__aeabi_dmul>
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801a1f2:	ec53 2b18 	vmov	r2, r3, d8
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801a1f6:	4680      	mov	r8, r0
 801a1f8:	4689      	mov	r9, r1
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801a1fa:	ec51 0b1a 	vmov	r0, r1, d10
 801a1fe:	f00d fe53 	bl	8027ea8 <__aeabi_dmul>
 801a202:	4642      	mov	r2, r8
 801a204:	4606      	mov	r6, r0
 801a206:	460f      	mov	r7, r1
 801a208:	464b      	mov	r3, r9
 801a20a:	ec51 0b19 	vmov	r0, r1, d9
 801a20e:	f00d fe4b 	bl	8027ea8 <__aeabi_dmul>
 801a212:	4602      	mov	r2, r0
 801a214:	460b      	mov	r3, r1
 801a216:	4630      	mov	r0, r6
 801a218:	4639      	mov	r1, r7
 801a21a:	f00d fc8d 	bl	8027b38 <__aeabi_dsub>
 801a21e:	4602      	mov	r2, r0
 801a220:	460b      	mov	r3, r1
 801a222:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 801a226:	f00d fc89 	bl	8027b3c <__adddf3>
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801a22a:	4642      	mov	r2, r8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801a22c:	e945 0102 	strd	r0, r1, [r5, #-8]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801a230:	464b      	mov	r3, r9
 801a232:	ec51 0b1a 	vmov	r0, r1, d10
 801a236:	f00d fe37 	bl	8027ea8 <__aeabi_dmul>
 801a23a:	ec53 2b18 	vmov	r2, r3, d8
 801a23e:	4606      	mov	r6, r0
 801a240:	460f      	mov	r7, r1
 801a242:	ec51 0b19 	vmov	r0, r1, d9
 801a246:	f00d fe2f 	bl	8027ea8 <__aeabi_dmul>
 801a24a:	4602      	mov	r2, r0
 801a24c:	460b      	mov	r3, r1
 801a24e:	4630      	mov	r0, r6
 801a250:	4639      	mov	r1, r7
 801a252:	f00d fc73 	bl	8027b3c <__adddf3>
 801a256:	4602      	mov	r2, r0
 801a258:	460b      	mov	r3, r1
 801a25a:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801a25e:	f00d fc6d 	bl	8027b3c <__adddf3>
 801a262:	3410      	adds	r4, #16
 801a264:	e944 0102 	strd	r0, r1, [r4, #-8]
            for (j = 0; j < n2; j++) {
 801a268:	45a2      	cmp	sl, r4
 801a26a:	f10b 0b10 	add.w	fp, fp, #16
 801a26e:	f105 0510 	add.w	r5, r5, #16
 801a272:	d1b2      	bne.n	801a1da <cblas_zgemm+0x93a>
 801a274:	e744      	b.n	801a100 <cblas_zgemm+0x860>
      for (k = 0; k < K; k++) {
 801a276:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801a278:	2b00      	cmp	r3, #0
 801a27a:	f77f acd2 	ble.w	8019c22 <cblas_zgemm+0x382>
 801a27e:	2300      	movs	r3, #0
 801a280:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 801a284:	930d      	str	r3, [sp, #52]	; 0x34
 801a286:	9b30      	ldr	r3, [sp, #192]	; 0xc0
 801a288:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 801a28a:	011b      	lsls	r3, r3, #4
 801a28c:	930e      	str	r3, [sp, #56]	; 0x38
 801a28e:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801a290:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a294:	9306      	str	r3, [sp, #24]
 801a296:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801a298:	9a04      	ldr	r2, [sp, #16]
 801a29a:	011b      	lsls	r3, r3, #4
 801a29c:	9308      	str	r3, [sp, #32]
 801a29e:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a2a0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a2a4:	930f      	str	r3, [sp, #60]	; 0x3c
 801a2a6:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a2a8:	3308      	adds	r3, #8
 801a2aa:	930a      	str	r3, [sp, #40]	; 0x28
        for (i = 0; i < n1; i++) {
 801a2ac:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a2ae:	2b00      	cmp	r3, #0
 801a2b0:	f340 810b 	ble.w	801a4ca <cblas_zgemm+0xc2a>
 801a2b4:	9807      	ldr	r0, [sp, #28]
 801a2b6:	f00d fd8d 	bl	8027dd4 <__aeabi_i2d>
 801a2ba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801a2bc:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 801a2be:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a2c2:	9301      	str	r3, [sp, #4]
 801a2c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801a2c6:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 801a2c8:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801a2cc:	9309      	str	r3, [sp, #36]	; 0x24
 801a2ce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801a2d0:	9302      	str	r3, [sp, #8]
 801a2d2:	2300      	movs	r3, #0
 801a2d4:	ec41 0b1c 	vmov	d12, r0, r1
 801a2d8:	9303      	str	r3, [sp, #12]
 801a2da:	e016      	b.n	801a30a <cblas_zgemm+0xa6a>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a2dc:	2200      	movs	r2, #0
 801a2de:	2300      	movs	r3, #0
 801a2e0:	4620      	mov	r0, r4
 801a2e2:	4629      	mov	r1, r5
 801a2e4:	f00e f848 	bl	8028378 <__aeabi_dcmpeq>
 801a2e8:	2800      	cmp	r0, #0
 801a2ea:	d04f      	beq.n	801a38c <cblas_zgemm+0xaec>
        for (i = 0; i < n1; i++) {
 801a2ec:	9a03      	ldr	r2, [sp, #12]
 801a2ee:	9933      	ldr	r1, [sp, #204]	; 0xcc
 801a2f0:	9b01      	ldr	r3, [sp, #4]
 801a2f2:	440a      	add	r2, r1
 801a2f4:	9203      	str	r2, [sp, #12]
 801a2f6:	9908      	ldr	r1, [sp, #32]
 801a2f8:	9a02      	ldr	r2, [sp, #8]
 801a2fa:	440a      	add	r2, r1
 801a2fc:	9202      	str	r2, [sp, #8]
 801a2fe:	9a06      	ldr	r2, [sp, #24]
 801a300:	3310      	adds	r3, #16
 801a302:	429a      	cmp	r2, r3
 801a304:	9301      	str	r3, [sp, #4]
 801a306:	f000 80e0 	beq.w	801a4ca <cblas_zgemm+0xc2a>
          const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 801a30a:	9b01      	ldr	r3, [sp, #4]
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801a30c:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Fki_real = CONST_REAL(F, ldf * k + i);
 801a310:	e9d3 ab00 	ldrd	sl, fp, [r3]
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801a314:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 801a318:	f00d fdc6 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 801a31c:	4652      	mov	r2, sl
          const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
 801a31e:	4604      	mov	r4, r0
 801a320:	460d      	mov	r5, r1
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 801a322:	465b      	mov	r3, fp
 801a324:	ec51 0b1e 	vmov	r0, r1, d14
 801a328:	f00d fdbe 	bl	8027ea8 <__aeabi_dmul>
 801a32c:	4622      	mov	r2, r4
 801a32e:	462b      	mov	r3, r5
 801a330:	4680      	mov	r8, r0
 801a332:	4689      	mov	r9, r1
 801a334:	ec51 0b1f 	vmov	r0, r1, d15
 801a338:	f00d fdb6 	bl	8027ea8 <__aeabi_dmul>
 801a33c:	4602      	mov	r2, r0
 801a33e:	460b      	mov	r3, r1
 801a340:	4640      	mov	r0, r8
 801a342:	4649      	mov	r1, r9
 801a344:	f00d fbf8 	bl	8027b38 <__aeabi_dsub>
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801a348:	4622      	mov	r2, r4
 801a34a:	462b      	mov	r3, r5
          const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
 801a34c:	4606      	mov	r6, r0
 801a34e:	460f      	mov	r7, r1
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801a350:	ec51 0b1e 	vmov	r0, r1, d14
 801a354:	f00d fda8 	bl	8027ea8 <__aeabi_dmul>
 801a358:	4652      	mov	r2, sl
 801a35a:	4604      	mov	r4, r0
 801a35c:	460d      	mov	r5, r1
 801a35e:	465b      	mov	r3, fp
 801a360:	ec51 0b1f 	vmov	r0, r1, d15
 801a364:	f00d fda0 	bl	8027ea8 <__aeabi_dmul>
 801a368:	4602      	mov	r2, r0
 801a36a:	460b      	mov	r3, r1
 801a36c:	4620      	mov	r0, r4
 801a36e:	4629      	mov	r1, r5
 801a370:	f00d fbe4 	bl	8027b3c <__adddf3>
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a374:	2200      	movs	r2, #0
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801a376:	4604      	mov	r4, r0
 801a378:	460d      	mov	r5, r1
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a37a:	2300      	movs	r3, #0
 801a37c:	4630      	mov	r0, r6
 801a37e:	4639      	mov	r1, r7
          const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
 801a380:	ec45 4b19 	vmov	d9, r4, r5
          if (!(temp_real == 0.0 && temp_imag == 0.0)) {
 801a384:	f00d fff8 	bl	8028378 <__aeabi_dcmpeq>
 801a388:	2800      	cmp	r0, #0
 801a38a:	d1a7      	bne.n	801a2dc <cblas_zgemm+0xa3c>
            for (j = 0; j < n2; j++) {
 801a38c:	9b04      	ldr	r3, [sp, #16]
 801a38e:	2b00      	cmp	r3, #0
 801a390:	ddac      	ble.n	801a2ec <cblas_zgemm+0xa4c>
 801a392:	9805      	ldr	r0, [sp, #20]
 801a394:	f00d fd1e 	bl	8027dd4 <__aeabi_i2d>
 801a398:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 801a39a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801a39c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801a39e:	9d02      	ldr	r5, [sp, #8]
 801a3a0:	ec41 0b1b 	vmov	d11, r0, r1
 801a3a4:	4619      	mov	r1, r3
 801a3a6:	9b03      	ldr	r3, [sp, #12]
 801a3a8:	eb01 1a03 	add.w	sl, r1, r3, lsl #4
 801a3ac:	eb02 1b03 	add.w	fp, r2, r3, lsl #4
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801a3b0:	ed94 7b00 	vldr	d7, [r4]
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801a3b4:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
              const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
 801a3b8:	eeb0 8a47 	vmov.f32	s16, s14
 801a3bc:	eef0 8a67 	vmov.f32	s17, s15
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801a3c0:	ec51 0b1b 	vmov	r0, r1, d11
 801a3c4:	f00d fd70 	bl	8027ea8 <__aeabi_dmul>
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801a3c8:	ec53 2b18 	vmov	r2, r3, d8
              const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
 801a3cc:	4680      	mov	r8, r0
 801a3ce:	4689      	mov	r9, r1
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801a3d0:	4630      	mov	r0, r6
 801a3d2:	4639      	mov	r1, r7
 801a3d4:	f00d fd68 	bl	8027ea8 <__aeabi_dmul>
 801a3d8:	4642      	mov	r2, r8
 801a3da:	464b      	mov	r3, r9
 801a3dc:	ec41 0b1a 	vmov	d10, r0, r1
 801a3e0:	ec51 0b19 	vmov	r0, r1, d9
 801a3e4:	f00d fd60 	bl	8027ea8 <__aeabi_dmul>
 801a3e8:	4602      	mov	r2, r0
 801a3ea:	460b      	mov	r3, r1
 801a3ec:	ec51 0b1a 	vmov	r0, r1, d10
 801a3f0:	f00d fba2 	bl	8027b38 <__aeabi_dsub>
 801a3f4:	4602      	mov	r2, r0
 801a3f6:	460b      	mov	r3, r1
 801a3f8:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801a3fc:	f00d fb9e 	bl	8027b3c <__adddf3>
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801a400:	4642      	mov	r2, r8
              REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
 801a402:	e94b 0102 	strd	r0, r1, [fp, #-8]
              IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
 801a406:	464b      	mov	r3, r9
 801a408:	4630      	mov	r0, r6
 801a40a:	4639      	mov	r1, r7
 801a40c:	f00d fd4c 	bl	8027ea8 <__aeabi_dmul>
 801a410:	ec53 2b18 	vmov	r2, r3, d8
 801a414:	4680      	mov	r8, r0
 801a416:	4689      	mov	r9, r1
 801a418:	ec51 0b19 	vmov	r0, r1, d9
 801a41c:	f00d fd44 	bl	8027ea8 <__aeabi_dmul>
 801a420:	4602      	mov	r2, r0
 801a422:	460b      	mov	r3, r1
 801a424:	4640      	mov	r0, r8
 801a426:	4649      	mov	r1, r9
 801a428:	f00d fb88 	bl	8027b3c <__adddf3>
 801a42c:	4602      	mov	r2, r0
 801a42e:	460b      	mov	r3, r1
 801a430:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801a434:	f00d fb82 	bl	8027b3c <__adddf3>
 801a438:	f10a 0a10 	add.w	sl, sl, #16
 801a43c:	e94a 0102 	strd	r0, r1, [sl, #-8]
            for (j = 0; j < n2; j++) {
 801a440:	4555      	cmp	r5, sl
 801a442:	f104 0410 	add.w	r4, r4, #16
 801a446:	f10b 0b10 	add.w	fp, fp, #16
 801a44a:	d1b1      	bne.n	801a3b0 <cblas_zgemm+0xb10>
 801a44c:	e74e      	b.n	801a2ec <cblas_zgemm+0xa4c>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801a44e:	9b04      	ldr	r3, [sp, #16]
 801a450:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 801a452:	2b01      	cmp	r3, #1
 801a454:	bfb8      	it	lt
 801a456:	2301      	movlt	r3, #1
 801a458:	4293      	cmp	r3, r2
 801a45a:	f77f ac18 	ble.w	8019c8e <cblas_zgemm+0x3ee>
 801a45e:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 801a460:	4293      	cmp	r3, r2
 801a462:	bfcc      	ite	gt
 801a464:	200e      	movgt	r0, #14
 801a466:	2009      	movle	r0, #9
 801a468:	e416      	b.n	8019c98 <cblas_zgemm+0x3f8>
 801a46a:	f1a1 036f 	sub.w	r3, r1, #111	; 0x6f
 801a46e:	2b02      	cmp	r3, #2
 801a470:	460a      	mov	r2, r1
 801a472:	d971      	bls.n	801a558 <cblas_zgemm+0xcb8>
 801a474:	2170      	movs	r1, #112	; 0x70
 801a476:	2002      	movs	r0, #2
 801a478:	f7ff ba32 	b.w	80198e0 <cblas_zgemm+0x40>
      for (k = 0; k < K; k++) {
 801a47c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801a47e:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801a480:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801a482:	3210      	adds	r2, #16
 801a484:	920b      	str	r2, [sp, #44]	; 0x2c
 801a486:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801a488:	440a      	add	r2, r1
 801a48a:	920a      	str	r2, [sp, #40]	; 0x28
 801a48c:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 801a48e:	3301      	adds	r3, #1
 801a490:	429a      	cmp	r2, r3
 801a492:	930c      	str	r3, [sp, #48]	; 0x30
 801a494:	f47f ae12 	bne.w	801a0bc <cblas_zgemm+0x81c>
 801a498:	f7ff bbc3 	b.w	8019c22 <cblas_zgemm+0x382>
          BASE temp_imag = 0.0;
 801a49c:	ed9f 7b30 	vldr	d7, [pc, #192]	; 801a560 <cblas_zgemm+0xcc0>
 801a4a0:	eeb0 ba47 	vmov.f32	s22, s14
 801a4a4:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 801a4a8:	eeb0 aa47 	vmov.f32	s20, s14
 801a4ac:	eef0 aa67 	vmov.f32	s21, s15
 801a4b0:	f7ff bb55 	b.w	8019b5e <cblas_zgemm+0x2be>
          BASE temp_imag = 0.0;
 801a4b4:	ed9f 7b2a 	vldr	d7, [pc, #168]	; 801a560 <cblas_zgemm+0xcc0>
 801a4b8:	eeb0 ba47 	vmov.f32	s22, s14
 801a4bc:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 801a4c0:	eeb0 aa47 	vmov.f32	s20, s14
 801a4c4:	eef0 aa67 	vmov.f32	s21, s15
 801a4c8:	e557      	b.n	8019f7a <cblas_zgemm+0x6da>
      for (k = 0; k < K; k++) {
 801a4ca:	9a06      	ldr	r2, [sp, #24]
 801a4cc:	990e      	ldr	r1, [sp, #56]	; 0x38
 801a4ce:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801a4d0:	440a      	add	r2, r1
 801a4d2:	9206      	str	r2, [sp, #24]
 801a4d4:	9930      	ldr	r1, [sp, #192]	; 0xc0
 801a4d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801a4d8:	440a      	add	r2, r1
 801a4da:	920c      	str	r2, [sp, #48]	; 0x30
 801a4dc:	992e      	ldr	r1, [sp, #184]	; 0xb8
 801a4de:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801a4e0:	440a      	add	r2, r1
 801a4e2:	920b      	str	r2, [sp, #44]	; 0x2c
 801a4e4:	9a2b      	ldr	r2, [sp, #172]	; 0xac
 801a4e6:	3301      	adds	r3, #1
 801a4e8:	429a      	cmp	r2, r3
 801a4ea:	930d      	str	r3, [sp, #52]	; 0x34
 801a4ec:	f47f aede 	bne.w	801a2ac <cblas_zgemm+0xa0c>
 801a4f0:	f7ff bb97 	b.w	8019c22 <cblas_zgemm+0x382>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801a4f4:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801a4f6:	9a30      	ldr	r2, [sp, #192]	; 0xc0
 801a4f8:	2b01      	cmp	r3, #1
 801a4fa:	bfb8      	it	lt
 801a4fc:	2301      	movlt	r3, #1
 801a4fe:	4293      	cmp	r3, r2
 801a500:	f77f abc5 	ble.w	8019c8e <cblas_zgemm+0x3ee>
 801a504:	9a33      	ldr	r2, [sp, #204]	; 0xcc
 801a506:	4293      	cmp	r3, r2
 801a508:	bfcc      	ite	gt
 801a50a:	200e      	movgt	r0, #14
 801a50c:	200b      	movle	r0, #11
 801a50e:	f7ff bbc3 	b.w	8019c98 <cblas_zgemm+0x3f8>
 801a512:	2a71      	cmp	r2, #113	; 0x71
 801a514:	d01f      	beq.n	801a556 <cblas_zgemm+0xcb6>
 801a516:	4621      	mov	r1, r4
 801a518:	2270      	movs	r2, #112	; 0x70
 801a51a:	2000      	movs	r0, #0
 801a51c:	f7ff b9db 	b.w	80198d6 <cblas_zgemm+0x36>
      F = (const BASE *)A;
 801a520:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 801a522:	922f      	str	r2, [sp, #188]	; 0xbc
      G = (const BASE *)B;
 801a524:	932d      	str	r3, [sp, #180]	; 0xb4
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a526:	2270      	movs	r2, #112	; 0x70
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801a528:	f04f 33ff 	mov.w	r3, #4294967295
      TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a52c:	920a      	str	r2, [sp, #40]	; 0x28
      conjG = (TransB == CblasConjTrans) ? -1 : 1;
 801a52e:	9305      	str	r3, [sp, #20]
 801a530:	f7ff ba2a 	b.w	8019988 <cblas_zgemm+0xe8>
      conjF = (TransA == CblasConjTrans) ? -1 : 1;
 801a534:	f04f 33ff 	mov.w	r3, #4294967295
 801a538:	9307      	str	r3, [sp, #28]
      TransF = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 801a53a:	2370      	movs	r3, #112	; 0x70
 801a53c:	9309      	str	r3, [sp, #36]	; 0x24
 801a53e:	e464      	b.n	8019e0a <cblas_zgemm+0x56a>
  CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801a540:	9804      	ldr	r0, [sp, #16]
 801a542:	9b33      	ldr	r3, [sp, #204]	; 0xcc
 801a544:	2801      	cmp	r0, #1
 801a546:	bfb8      	it	lt
 801a548:	2001      	movlt	r0, #1
 801a54a:	4283      	cmp	r3, r0
 801a54c:	bfb4      	ite	lt
 801a54e:	200e      	movlt	r0, #14
 801a550:	2009      	movge	r0, #9
 801a552:	f7ff bba1 	b.w	8019c98 <cblas_zgemm+0x3f8>
 801a556:	2270      	movs	r2, #112	; 0x70
 801a558:	2000      	movs	r0, #0
 801a55a:	2170      	movs	r1, #112	; 0x70
 801a55c:	f7ff b9bb 	b.w	80198d6 <cblas_zgemm+0x36>
	...

0801a568 <cblas_zgemv>:
void
cblas_zgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
             const int M, const int N, const void *alpha, const void *A,
             const int lda, const void *X, const int incX, const void *beta,
             void *Y, const int incY)
{
 801a568:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a56c:	ed2d 8b0c 	vpush	{d8-d13}
 801a570:	b091      	sub	sp, #68	; 0x44
 801a572:	460e      	mov	r6, r1
 801a574:	9c26      	ldr	r4, [sp, #152]	; 0x98
 801a576:	9d27      	ldr	r5, [sp, #156]	; 0x9c
 801a578:	9509      	str	r5, [sp, #36]	; 0x24
  const BASE alpha_real = CONST_REAL0(alpha);
 801a57a:	ed94 7b00 	vldr	d7, [r4]
 801a57e:	9d28      	ldr	r5, [sp, #160]	; 0xa0
 801a580:	9506      	str	r5, [sp, #24]
 801a582:	eeb0 ca47 	vmov.f32	s24, s14
 801a586:	eef0 ca67 	vmov.f32	s25, s15
 801a58a:	9d29      	ldr	r5, [sp, #164]	; 0xa4
 801a58c:	910b      	str	r1, [sp, #44]	; 0x2c
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801a58e:	ed94 7b02 	vldr	d7, [r4, #8]
 801a592:	992b      	ldr	r1, [sp, #172]	; 0xac
 801a594:	950d      	str	r5, [sp, #52]	; 0x34
 801a596:	9d2a      	ldr	r5, [sp, #168]	; 0xa8
 801a598:	950a      	str	r5, [sp, #40]	; 0x28
 801a59a:	9d2c      	ldr	r5, [sp, #176]	; 0xb0
 801a59c:	950c      	str	r5, [sp, #48]	; 0x30
 801a59e:	eeb0 da47 	vmov.f32	s26, s14
 801a5a2:	eef0 da67 	vmov.f32	s27, s15
 801a5a6:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
 801a5a8:	9508      	str	r5, [sp, #32]
  const BASE beta_imag = CONST_IMAG0(beta);
 801a5aa:	ed91 7b02 	vldr	d7, [r1, #8]
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801a5ae:	f1a6 056f 	sub.w	r5, r6, #111	; 0x6f
 801a5b2:	2d02      	cmp	r5, #2
 801a5b4:	e9cd 2302 	strd	r2, r3, [sp, #8]
  const BASE beta_imag = CONST_IMAG0(beta);
 801a5b8:	eeb0 8a47 	vmov.f32	s16, s14
 801a5bc:	eef0 8a67 	vmov.f32	s17, s15
  const BASE beta_real = CONST_REAL0(beta);
 801a5c0:	e9d1 6700 	ldrd	r6, r7, [r1]
 801a5c4:	9007      	str	r0, [sp, #28]
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801a5c6:	f200 81b4 	bhi.w	801a932 <cblas_zgemv+0x3ca>
 801a5ca:	3865      	subs	r0, #101	; 0x65
 801a5cc:	2801      	cmp	r0, #1
 801a5ce:	bf94      	ite	ls
 801a5d0:	2000      	movls	r0, #0
 801a5d2:	2001      	movhi	r0, #1
 801a5d4:	9b02      	ldr	r3, [sp, #8]
 801a5d6:	2b00      	cmp	r3, #0
 801a5d8:	9b03      	ldr	r3, [sp, #12]
 801a5da:	bfb8      	it	lt
 801a5dc:	2003      	movlt	r0, #3
 801a5de:	2b00      	cmp	r3, #0
 801a5e0:	9b07      	ldr	r3, [sp, #28]
 801a5e2:	bfb8      	it	lt
 801a5e4:	2004      	movlt	r0, #4
 801a5e6:	2b65      	cmp	r3, #101	; 0x65
 801a5e8:	f000 81fe 	beq.w	801a9e8 <cblas_zgemv+0x480>
 801a5ec:	9b07      	ldr	r3, [sp, #28]
 801a5ee:	2b66      	cmp	r3, #102	; 0x66
 801a5f0:	f000 81b5 	beq.w	801a95e <cblas_zgemv+0x3f6>
 801a5f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801a5f6:	2b00      	cmp	r3, #0
 801a5f8:	f040 81aa 	bne.w	801a950 <cblas_zgemv+0x3e8>
 801a5fc:	9b08      	ldr	r3, [sp, #32]
 801a5fe:	2b00      	cmp	r3, #0
 801a600:	bf14      	ite	ne
 801a602:	2009      	movne	r0, #9
 801a604:	200c      	moveq	r0, #12
 801a606:	4ace      	ldr	r2, [pc, #824]	; (801a940 <cblas_zgemv+0x3d8>)
 801a608:	49ce      	ldr	r1, [pc, #824]	; (801a944 <cblas_zgemv+0x3dc>)
 801a60a:	f00d fa1d 	bl	8027a48 <cblas_xerbla>
  if (M == 0 || N == 0)
 801a60e:	9b02      	ldr	r3, [sp, #8]
 801a610:	2b00      	cmp	r3, #0
 801a612:	f000 8189 	beq.w	801a928 <cblas_zgemv+0x3c0>
 801a616:	9b03      	ldr	r3, [sp, #12]
 801a618:	2b00      	cmp	r3, #0
 801a61a:	f000 8185 	beq.w	801a928 <cblas_zgemv+0x3c0>
  if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801a61e:	ec51 0b1c 	vmov	r0, r1, d12
 801a622:	2200      	movs	r2, #0
 801a624:	2300      	movs	r3, #0
 801a626:	f00d fea7 	bl	8028378 <__aeabi_dcmpeq>
 801a62a:	2800      	cmp	r0, #0
 801a62c:	f000 81a9 	beq.w	801a982 <cblas_zgemv+0x41a>
 801a630:	ec51 0b1d 	vmov	r0, r1, d13
 801a634:	2200      	movs	r2, #0
 801a636:	2300      	movs	r3, #0
 801a638:	f00d fe9e 	bl	8028378 <__aeabi_dcmpeq>
 801a63c:	2800      	cmp	r0, #0
 801a63e:	f000 81a0 	beq.w	801a982 <cblas_zgemv+0x41a>
      && (beta_real == 1.0 && beta_imag == 0.0))
 801a642:	4bc1      	ldr	r3, [pc, #772]	; (801a948 <cblas_zgemv+0x3e0>)
 801a644:	2200      	movs	r2, #0
 801a646:	4630      	mov	r0, r6
 801a648:	4639      	mov	r1, r7
 801a64a:	f00d fe95 	bl	8028378 <__aeabi_dcmpeq>
 801a64e:	2800      	cmp	r0, #0
 801a650:	f000 8197 	beq.w	801a982 <cblas_zgemv+0x41a>
 801a654:	ec51 0b18 	vmov	r0, r1, d8
 801a658:	2200      	movs	r2, #0
 801a65a:	2300      	movs	r3, #0
 801a65c:	f00d fe8c 	bl	8028378 <__aeabi_dcmpeq>
 801a660:	2800      	cmp	r0, #0
 801a662:	f040 8161 	bne.w	801a928 <cblas_zgemv+0x3c0>
  if (TransA == CblasNoTrans) {
 801a666:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801a668:	2b6f      	cmp	r3, #111	; 0x6f
 801a66a:	d003      	beq.n	801a674 <cblas_zgemv+0x10c>
 801a66c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 801a670:	e9cd 3202 	strd	r3, r2, [sp, #8]
    INDEX iy = OFFSET(lenY, incY);
 801a674:	9b08      	ldr	r3, [sp, #32]
 801a676:	2b00      	cmp	r3, #0
 801a678:	f340 81b8 	ble.w	801a9ec <cblas_zgemv+0x484>
 801a67c:	f04f 0a00 	mov.w	sl, #0
    for (i = 0; i < lenY; i++) {
 801a680:	9b02      	ldr	r3, [sp, #8]
 801a682:	2b00      	cmp	r3, #0
 801a684:	dd42      	ble.n	801a70c <cblas_zgemv+0x1a4>
 801a686:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801a688:	eb02 130a 	add.w	r3, r2, sl, lsl #4
 801a68c:	f103 0b08 	add.w	fp, r3, #8
 801a690:	469a      	mov	sl, r3
 801a692:	9b08      	ldr	r3, [sp, #32]
 801a694:	2400      	movs	r4, #0
 801a696:	011d      	lsls	r5, r3, #4
      const BASE y_real = REAL(Y, iy);
 801a698:	ed1b 7b02 	vldr	d7, [fp, #-8]
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801a69c:	4630      	mov	r0, r6
 801a69e:	ec53 2b17 	vmov	r2, r3, d7
      const BASE y_real = REAL(Y, iy);
 801a6a2:	eeb0 9a47 	vmov.f32	s18, s14
 801a6a6:	eef0 9a67 	vmov.f32	s19, s15
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801a6aa:	4639      	mov	r1, r7
      const BASE y_imag = IMAG(Y, iy);
 801a6ac:	e9da 8902 	ldrd	r8, r9, [sl, #8]
      const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801a6b0:	f00d fbfa 	bl	8027ea8 <__aeabi_dmul>
 801a6b4:	4642      	mov	r2, r8
 801a6b6:	464b      	mov	r3, r9
 801a6b8:	ec41 0b1a 	vmov	d10, r0, r1
 801a6bc:	ec51 0b18 	vmov	r0, r1, d8
 801a6c0:	f00d fbf2 	bl	8027ea8 <__aeabi_dmul>
 801a6c4:	4602      	mov	r2, r0
 801a6c6:	460b      	mov	r3, r1
 801a6c8:	ec51 0b1a 	vmov	r0, r1, d10
 801a6cc:	f00d fa34 	bl	8027b38 <__aeabi_dsub>
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801a6d0:	ec53 2b19 	vmov	r2, r3, d9
      REAL(Y, iy) = tmpR;
 801a6d4:	e94b 0102 	strd	r0, r1, [fp, #-8]
      const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801a6d8:	ec51 0b18 	vmov	r0, r1, d8
 801a6dc:	f00d fbe4 	bl	8027ea8 <__aeabi_dmul>
 801a6e0:	4642      	mov	r2, r8
 801a6e2:	464b      	mov	r3, r9
 801a6e4:	4680      	mov	r8, r0
 801a6e6:	4689      	mov	r9, r1
 801a6e8:	4630      	mov	r0, r6
 801a6ea:	4639      	mov	r1, r7
 801a6ec:	f00d fbdc 	bl	8027ea8 <__aeabi_dmul>
 801a6f0:	460b      	mov	r3, r1
 801a6f2:	4602      	mov	r2, r0
 801a6f4:	4649      	mov	r1, r9
 801a6f6:	4640      	mov	r0, r8
 801a6f8:	f00d fa20 	bl	8027b3c <__adddf3>
    for (i = 0; i < lenY; i++) {
 801a6fc:	9b02      	ldr	r3, [sp, #8]
 801a6fe:	3401      	adds	r4, #1
 801a700:	42a3      	cmp	r3, r4
      IMAG(Y, iy) = tmpI;
 801a702:	e9ca 0102 	strd	r0, r1, [sl, #8]
    for (i = 0; i < lenY; i++) {
 801a706:	44ab      	add	fp, r5
 801a708:	44aa      	add	sl, r5
 801a70a:	d1c5      	bne.n	801a698 <cblas_zgemv+0x130>
  if (alpha_real == 0.0 && alpha_imag == 0.0)
 801a70c:	ec51 0b1c 	vmov	r0, r1, d12
 801a710:	2200      	movs	r2, #0
 801a712:	2300      	movs	r3, #0
 801a714:	f00d fe30 	bl	8028378 <__aeabi_dcmpeq>
 801a718:	b140      	cbz	r0, 801a72c <cblas_zgemv+0x1c4>
 801a71a:	ec51 0b1d 	vmov	r0, r1, d13
 801a71e:	2200      	movs	r2, #0
 801a720:	2300      	movs	r3, #0
 801a722:	f00d fe29 	bl	8028378 <__aeabi_dcmpeq>
 801a726:	2800      	cmp	r0, #0
 801a728:	f040 80fe 	bne.w	801a928 <cblas_zgemv+0x3c0>
  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 801a72c:	9b07      	ldr	r3, [sp, #28]
 801a72e:	2b65      	cmp	r3, #101	; 0x65
 801a730:	f000 8176 	beq.w	801aa20 <cblas_zgemv+0x4b8>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801a734:	9b07      	ldr	r3, [sp, #28]
 801a736:	2b66      	cmp	r3, #102	; 0x66
 801a738:	d009      	beq.n	801a74e <cblas_zgemv+0x1e6>
    BLAS_ERROR("unrecognized operation");
 801a73a:	4a84      	ldr	r2, [pc, #528]	; (801a94c <cblas_zgemv+0x3e4>)
 801a73c:	4981      	ldr	r1, [pc, #516]	; (801a944 <cblas_zgemv+0x3dc>)
 801a73e:	2000      	movs	r0, #0
#define BASE double
#include "source_gemv_c.h"
#undef BASE
}
 801a740:	b011      	add	sp, #68	; 0x44
 801a742:	ecbd 8b0c 	vpop	{d8-d13}
 801a746:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a74a:	f00d b97d 	b.w	8027a48 <cblas_xerbla>
      || (order == CblasColMajor && TransA == CblasTrans)) {
 801a74e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801a750:	2b70      	cmp	r3, #112	; 0x70
 801a752:	f000 823b 	beq.w	801abcc <cblas_zgemv+0x664>
             || (order == CblasColMajor && TransA == CblasNoTrans)) {
 801a756:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801a758:	2b6f      	cmp	r3, #111	; 0x6f
 801a75a:	f000 8318 	beq.w	801ad8e <cblas_zgemv+0x826>
  } else if (order == CblasColMajor && TransA == CblasConjTrans) {
 801a75e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801a760:	2b71      	cmp	r3, #113	; 0x71
 801a762:	d1ea      	bne.n	801a73a <cblas_zgemv+0x1d2>
    INDEX iy = OFFSET(lenY, incY);
 801a764:	9a08      	ldr	r2, [sp, #32]
 801a766:	2a00      	cmp	r2, #0
 801a768:	f340 83e8 	ble.w	801af3c <cblas_zgemv+0x9d4>
 801a76c:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 801a76e:	9a02      	ldr	r2, [sp, #8]
 801a770:	2a00      	cmp	r2, #0
 801a772:	f340 80d9 	ble.w	801a928 <cblas_zgemv+0x3c0>
 801a776:	9d08      	ldr	r5, [sp, #32]
 801a778:	990a      	ldr	r1, [sp, #40]	; 0x28
 801a77a:	9803      	ldr	r0, [sp, #12]
 801a77c:	012d      	lsls	r5, r5, #4
 801a77e:	950e      	str	r5, [sp, #56]	; 0x38
 801a780:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801a782:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 801a786:	f1c0 0201 	rsb	r2, r0, #1
 801a78a:	2900      	cmp	r1, #0
 801a78c:	930b      	str	r3, [sp, #44]	; 0x2c
 801a78e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801a790:	fb02 f201 	mul.w	r2, r2, r1
 801a794:	bfc8      	it	gt
 801a796:	2200      	movgt	r2, #0
 801a798:	eb03 1302 	add.w	r3, r3, r2, lsl #4
      INDEX ix = OFFSET(lenX, incX);
 801a79c:	2400      	movs	r4, #0
 801a79e:	930d      	str	r3, [sp, #52]	; 0x34
 801a7a0:	010b      	lsls	r3, r1, #4
 801a7a2:	e9cd 3407 	strd	r3, r4, [sp, #28]
 801a7a6:	9b06      	ldr	r3, [sp, #24]
 801a7a8:	940a      	str	r4, [sp, #40]	; 0x28
 801a7aa:	011b      	lsls	r3, r3, #4
 801a7ac:	930c      	str	r3, [sp, #48]	; 0x30
 801a7ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801a7b0:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801a7b4:	9304      	str	r3, [sp, #16]
      for (j = 0; j < lenX; j++) {
 801a7b6:	ed9f 7b60 	vldr	d7, [pc, #384]	; 801a938 <cblas_zgemv+0x3d0>
 801a7ba:	9b03      	ldr	r3, [sp, #12]
 801a7bc:	eeb0 ba47 	vmov.f32	s22, s14
 801a7c0:	eef0 ba67 	vmov.f32	s23, s15
 801a7c4:	2b00      	cmp	r3, #0
 801a7c6:	eeb0 aa47 	vmov.f32	s20, s14
 801a7ca:	eef0 aa67 	vmov.f32	s21, s15
 801a7ce:	dd58      	ble.n	801a882 <cblas_zgemv+0x31a>
 801a7d0:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 801a7d4:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
 801a7d8:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE x_real = CONST_REAL(X, ix);
 801a7dc:	ed9b 7b00 	vldr	d7, [fp]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801a7e0:	e9da 6700 	ldrd	r6, r7, [sl]
        const BASE x_real = CONST_REAL(X, ix);
 801a7e4:	eeb0 8a47 	vmov.f32	s16, s14
 801a7e8:	eef0 8a67 	vmov.f32	s17, s15
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a7ec:	ec51 0b17 	vmov	r0, r1, d7
 801a7f0:	4632      	mov	r2, r6
 801a7f2:	463b      	mov	r3, r7
 801a7f4:	f00d fb58 	bl	8027ea8 <__aeabi_dmul>
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801a7f8:	e9da 4502 	ldrd	r4, r5, [sl, #8]
        const BASE x_imag = CONST_IMAG(X, ix);
 801a7fc:	e9db 8902 	ldrd	r8, r9, [fp, #8]
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a800:	4602      	mov	r2, r0
 801a802:	460b      	mov	r3, r1
 801a804:	ec43 2b19 	vmov	d9, r2, r3
 801a808:	4640      	mov	r0, r8
 801a80a:	4622      	mov	r2, r4
 801a80c:	462b      	mov	r3, r5
 801a80e:	4649      	mov	r1, r9
 801a810:	f00d fb4a 	bl	8027ea8 <__aeabi_dmul>
 801a814:	4602      	mov	r2, r0
 801a816:	460b      	mov	r3, r1
 801a818:	ec51 0b19 	vmov	r0, r1, d9
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a81c:	9400      	str	r4, [sp, #0]
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a81e:	f00d f98d 	bl	8027b3c <__adddf3>
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a822:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a826:	4602      	mov	r2, r0
 801a828:	460b      	mov	r3, r1
 801a82a:	ec51 0b1a 	vmov	r0, r1, d10
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a82e:	9401      	str	r4, [sp, #4]
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a830:	f00d f984 	bl	8027b3c <__adddf3>
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a834:	ec53 2b18 	vmov	r2, r3, d8
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a838:	4604      	mov	r4, r0
 801a83a:	460d      	mov	r5, r1
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a83c:	e9dd 0100 	ldrd	r0, r1, [sp]
 801a840:	f00d fb32 	bl	8027ea8 <__aeabi_dmul>
        dotR += A_real * x_real - (-A_imag) * x_imag;
 801a844:	ec45 4b1a 	vmov	d10, r4, r5
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a848:	4632      	mov	r2, r6
 801a84a:	463b      	mov	r3, r7
 801a84c:	4604      	mov	r4, r0
 801a84e:	460d      	mov	r5, r1
 801a850:	4640      	mov	r0, r8
 801a852:	4649      	mov	r1, r9
 801a854:	f00d fb28 	bl	8027ea8 <__aeabi_dmul>
 801a858:	4602      	mov	r2, r0
 801a85a:	460b      	mov	r3, r1
 801a85c:	4620      	mov	r0, r4
 801a85e:	4629      	mov	r1, r5
 801a860:	f00d f96c 	bl	8027b3c <__adddf3>
 801a864:	460b      	mov	r3, r1
 801a866:	4602      	mov	r2, r0
 801a868:	ec51 0b1b 	vmov	r0, r1, d11
 801a86c:	f00d f966 	bl	8027b3c <__adddf3>
 801a870:	9b07      	ldr	r3, [sp, #28]
 801a872:	449b      	add	fp, r3
      for (j = 0; j < lenX; j++) {
 801a874:	9b04      	ldr	r3, [sp, #16]
 801a876:	f10a 0a10 	add.w	sl, sl, #16
 801a87a:	4553      	cmp	r3, sl
        dotI += A_real * x_imag + (-A_imag) * x_real;
 801a87c:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = 0; j < lenX; j++) {
 801a880:	d1ac      	bne.n	801a7dc <cblas_zgemv+0x274>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801a882:	ec53 2b1a 	vmov	r2, r3, d10
 801a886:	ec51 0b1c 	vmov	r0, r1, d12
 801a88a:	f00d fb0d 	bl	8027ea8 <__aeabi_dmul>
 801a88e:	ec5a 9b1b 	vmov	r9, sl, d11
 801a892:	ec58 7b1d 	vmov	r7, r8, d13
 801a896:	4604      	mov	r4, r0
 801a898:	460d      	mov	r5, r1
 801a89a:	ee1b 2a10 	vmov	r2, s22
 801a89e:	4653      	mov	r3, sl
 801a8a0:	ee1d 0a10 	vmov	r0, s26
 801a8a4:	4641      	mov	r1, r8
 801a8a6:	f00d faff 	bl	8027ea8 <__aeabi_dmul>
 801a8aa:	4602      	mov	r2, r0
 801a8ac:	460b      	mov	r3, r1
 801a8ae:	4620      	mov	r0, r4
 801a8b0:	4629      	mov	r1, r5
 801a8b2:	f00d f941 	bl	8027b38 <__aeabi_dsub>
 801a8b6:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801a8b8:	4602      	mov	r2, r0
 801a8ba:	460b      	mov	r3, r1
 801a8bc:	e9d6 0100 	ldrd	r0, r1, [r6]
 801a8c0:	f00d f93c 	bl	8027b3c <__adddf3>
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801a8c4:	ee1b 2a10 	vmov	r2, s22
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801a8c8:	e9c6 0100 	strd	r0, r1, [r6]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801a8cc:	4653      	mov	r3, sl
 801a8ce:	ec51 0b1c 	vmov	r0, r1, d12
 801a8d2:	f00d fae9 	bl	8027ea8 <__aeabi_dmul>
 801a8d6:	ec53 2b1a 	vmov	r2, r3, d10
 801a8da:	460d      	mov	r5, r1
 801a8dc:	4604      	mov	r4, r0
 801a8de:	4641      	mov	r1, r8
 801a8e0:	ee1d 0a10 	vmov	r0, s26
 801a8e4:	f00d fae0 	bl	8027ea8 <__aeabi_dmul>
 801a8e8:	4602      	mov	r2, r0
 801a8ea:	460b      	mov	r3, r1
 801a8ec:	4620      	mov	r0, r4
 801a8ee:	4629      	mov	r1, r5
 801a8f0:	f00d f924 	bl	8027b3c <__adddf3>
 801a8f4:	4602      	mov	r2, r0
 801a8f6:	460b      	mov	r3, r1
 801a8f8:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801a8fc:	f00d f91e 	bl	8027b3c <__adddf3>
 801a900:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801a902:	9d06      	ldr	r5, [sp, #24]
    for (i = 0; i < lenY; i++) {
 801a904:	9a08      	ldr	r2, [sp, #32]
 801a906:	442b      	add	r3, r5
 801a908:	930a      	str	r3, [sp, #40]	; 0x28
 801a90a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801a90c:	9b04      	ldr	r3, [sp, #16]
 801a90e:	442b      	add	r3, r5
 801a910:	9304      	str	r3, [sp, #16]
 801a912:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801a914:	18f3      	adds	r3, r6, r3
 801a916:	930b      	str	r3, [sp, #44]	; 0x2c
 801a918:	9b02      	ldr	r3, [sp, #8]
 801a91a:	3201      	adds	r2, #1
 801a91c:	4293      	cmp	r3, r2
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801a91e:	e9c6 0102 	strd	r0, r1, [r6, #8]
    for (i = 0; i < lenY; i++) {
 801a922:	9208      	str	r2, [sp, #32]
 801a924:	f47f af47 	bne.w	801a7b6 <cblas_zgemv+0x24e>
 801a928:	b011      	add	sp, #68	; 0x44
 801a92a:	ecbd 8b0c 	vpop	{d8-d13}
 801a92e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801a932:	2002      	movs	r0, #2
 801a934:	e64e      	b.n	801a5d4 <cblas_zgemv+0x6c>
 801a936:	bf00      	nop
	...
 801a940:	08030378 	.word	0x08030378
 801a944:	080306c0 	.word	0x080306c0
 801a948:	3ff00000 	.word	0x3ff00000
 801a94c:	080305a8 	.word	0x080305a8
 801a950:	9b08      	ldr	r3, [sp, #32]
 801a952:	2b00      	cmp	r3, #0
 801a954:	d062      	beq.n	801aa1c <cblas_zgemv+0x4b4>
 801a956:	2800      	cmp	r0, #0
 801a958:	f43f ae59 	beq.w	801a60e <cblas_zgemv+0xa6>
 801a95c:	e653      	b.n	801a606 <cblas_zgemv+0x9e>
 801a95e:	9b02      	ldr	r3, [sp, #8]
 801a960:	9a06      	ldr	r2, [sp, #24]
 801a962:	2b01      	cmp	r3, #1
 801a964:	bfb8      	it	lt
 801a966:	2301      	movlt	r3, #1
 801a968:	4293      	cmp	r3, r2
 801a96a:	f77f ae43 	ble.w	801a5f4 <cblas_zgemv+0x8c>
 801a96e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801a970:	2b00      	cmp	r3, #0
 801a972:	f43f ae43 	beq.w	801a5fc <cblas_zgemv+0x94>
 801a976:	9b08      	ldr	r3, [sp, #32]
 801a978:	2b00      	cmp	r3, #0
 801a97a:	bf14      	ite	ne
 801a97c:	2007      	movne	r0, #7
 801a97e:	200c      	moveq	r0, #12
 801a980:	e641      	b.n	801a606 <cblas_zgemv+0x9e>
  if (TransA == CblasNoTrans) {
 801a982:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801a984:	2b6f      	cmp	r3, #111	; 0x6f
 801a986:	bf18      	it	ne
 801a988:	e9dd 2302 	ldrdne	r2, r3, [sp, #8]
  if (beta_real == 0.0 && beta_imag == 0.0) {
 801a98c:	4630      	mov	r0, r6
  if (TransA == CblasNoTrans) {
 801a98e:	bf18      	it	ne
 801a990:	e9cd 3202 	strdne	r3, r2, [sp, #8]
  if (beta_real == 0.0 && beta_imag == 0.0) {
 801a994:	4639      	mov	r1, r7
 801a996:	2200      	movs	r2, #0
 801a998:	2300      	movs	r3, #0
 801a99a:	f00d fced 	bl	8028378 <__aeabi_dcmpeq>
 801a99e:	2200      	movs	r2, #0
 801a9a0:	b350      	cbz	r0, 801a9f8 <cblas_zgemv+0x490>
 801a9a2:	ec51 0b18 	vmov	r0, r1, d8
 801a9a6:	2300      	movs	r3, #0
 801a9a8:	f00d fce6 	bl	8028378 <__aeabi_dcmpeq>
 801a9ac:	2800      	cmp	r0, #0
 801a9ae:	f43f ae61 	beq.w	801a674 <cblas_zgemv+0x10c>
    INDEX iy = OFFSET(lenY, incY);
 801a9b2:	9a08      	ldr	r2, [sp, #32]
 801a9b4:	2a00      	cmp	r2, #0
 801a9b6:	f340 82bb 	ble.w	801af30 <cblas_zgemv+0x9c8>
 801a9ba:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 801a9bc:	9a02      	ldr	r2, [sp, #8]
 801a9be:	2a00      	cmp	r2, #0
 801a9c0:	f77f aea4 	ble.w	801a70c <cblas_zgemv+0x1a4>
 801a9c4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801a9c6:	9d02      	ldr	r5, [sp, #8]
 801a9c8:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801a9cc:	9a08      	ldr	r2, [sp, #32]
      REAL(Y, iy) = 0.0;
 801a9ce:	2000      	movs	r0, #0
 801a9d0:	0114      	lsls	r4, r2, #4
 801a9d2:	2100      	movs	r1, #0
    for (i = 0; i < lenY; i++) {
 801a9d4:	2200      	movs	r2, #0
 801a9d6:	3201      	adds	r2, #1
 801a9d8:	4295      	cmp	r5, r2
      REAL(Y, iy) = 0.0;
 801a9da:	e9c3 0100 	strd	r0, r1, [r3]
      IMAG(Y, iy) = 0.0;
 801a9de:	e9c3 0102 	strd	r0, r1, [r3, #8]
    for (i = 0; i < lenY; i++) {
 801a9e2:	4423      	add	r3, r4
 801a9e4:	d1f7      	bne.n	801a9d6 <cblas_zgemv+0x46e>
 801a9e6:	e691      	b.n	801a70c <cblas_zgemv+0x1a4>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801a9e8:	9b03      	ldr	r3, [sp, #12]
 801a9ea:	e7b9      	b.n	801a960 <cblas_zgemv+0x3f8>
    INDEX iy = OFFSET(lenY, incY);
 801a9ec:	9a02      	ldr	r2, [sp, #8]
 801a9ee:	f1c2 0a01 	rsb	sl, r2, #1
 801a9f2:	fb0a fa03 	mul.w	sl, sl, r3
 801a9f6:	e643      	b.n	801a680 <cblas_zgemv+0x118>
  } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801a9f8:	4b73      	ldr	r3, [pc, #460]	; (801abc8 <cblas_zgemv+0x660>)
 801a9fa:	4630      	mov	r0, r6
 801a9fc:	4639      	mov	r1, r7
 801a9fe:	f00d fcbb 	bl	8028378 <__aeabi_dcmpeq>
 801aa02:	2800      	cmp	r0, #0
 801aa04:	f43f ae36 	beq.w	801a674 <cblas_zgemv+0x10c>
 801aa08:	ec51 0b18 	vmov	r0, r1, d8
 801aa0c:	2200      	movs	r2, #0
 801aa0e:	2300      	movs	r3, #0
 801aa10:	f00d fcb2 	bl	8028378 <__aeabi_dcmpeq>
 801aa14:	2800      	cmp	r0, #0
 801aa16:	f47f ae79 	bne.w	801a70c <cblas_zgemv+0x1a4>
 801aa1a:	e62b      	b.n	801a674 <cblas_zgemv+0x10c>
  CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
 801aa1c:	200c      	movs	r0, #12
 801aa1e:	e5f2      	b.n	801a606 <cblas_zgemv+0x9e>
  if ((order == CblasRowMajor && TransA == CblasNoTrans)
 801aa20:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801aa22:	2b6f      	cmp	r3, #111	; 0x6f
 801aa24:	f000 80d2 	beq.w	801abcc <cblas_zgemv+0x664>
  } else if ((order == CblasRowMajor && TransA == CblasTrans)
 801aa28:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801aa2a:	2b70      	cmp	r3, #112	; 0x70
 801aa2c:	f000 81af 	beq.w	801ad8e <cblas_zgemv+0x826>
  } else if (order == CblasRowMajor && TransA == CblasConjTrans) {
 801aa30:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801aa32:	2b71      	cmp	r3, #113	; 0x71
 801aa34:	f47f ae81 	bne.w	801a73a <cblas_zgemv+0x1d2>
    INDEX ix = OFFSET(lenX, incX);
 801aa38:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801aa3a:	2a00      	cmp	r2, #0
 801aa3c:	f340 8284 	ble.w	801af48 <cblas_zgemv+0x9e0>
 801aa40:	2300      	movs	r3, #0
    for (j = 0; j < lenX; j++) {
 801aa42:	9a03      	ldr	r2, [sp, #12]
 801aa44:	2a00      	cmp	r2, #0
 801aa46:	f77f af6f 	ble.w	801a928 <cblas_zgemv+0x3c0>
 801aa4a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 801aa4c:	9808      	ldr	r0, [sp, #32]
 801aa4e:	9c02      	ldr	r4, [sp, #8]
 801aa50:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801aa52:	013f      	lsls	r7, r7, #4
 801aa54:	970c      	str	r7, [sp, #48]	; 0x30
 801aa56:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801aa58:	f1c4 0201 	rsb	r2, r4, #1
 801aa5c:	2800      	cmp	r0, #0
 801aa5e:	fb02 f200 	mul.w	r2, r2, r0
 801aa62:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801aa66:	bfc8      	it	gt
 801aa68:	2200      	movgt	r2, #0
 801aa6a:	eb05 1102 	add.w	r1, r5, r2, lsl #4
 801aa6e:	9307      	str	r3, [sp, #28]
 801aa70:	0103      	lsls	r3, r0, #4
 801aa72:	930f      	str	r3, [sp, #60]	; 0x3c
 801aa74:	f101 0308 	add.w	r3, r1, #8
 801aa78:	930d      	str	r3, [sp, #52]	; 0x34
 801aa7a:	9b06      	ldr	r3, [sp, #24]
 801aa7c:	910e      	str	r1, [sp, #56]	; 0x38
 801aa7e:	011b      	lsls	r3, r3, #4
 801aa80:	930b      	str	r3, [sp, #44]	; 0x2c
 801aa82:	9b09      	ldr	r3, [sp, #36]	; 0x24
      INDEX iy = OFFSET(lenY, incY);
 801aa84:	2600      	movs	r6, #0
 801aa86:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801aa8a:	9608      	str	r6, [sp, #32]
 801aa8c:	960a      	str	r6, [sp, #40]	; 0x28
 801aa8e:	9300      	str	r3, [sp, #0]
      BASE x_real = CONST_REAL(X, ix);
 801aa90:	9c07      	ldr	r4, [sp, #28]
 801aa92:	e9d4 8900 	ldrd	r8, r9, [r4]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801aa96:	ec51 0b1c 	vmov	r0, r1, d12
 801aa9a:	4642      	mov	r2, r8
 801aa9c:	464b      	mov	r3, r9
 801aa9e:	f00d fa03 	bl	8027ea8 <__aeabi_dmul>
      BASE x_imag = CONST_IMAG(X, ix);
 801aaa2:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801aaa6:	ec5b ab1d 	vmov	sl, fp, d13
 801aaaa:	4604      	mov	r4, r0
 801aaac:	460d      	mov	r5, r1
 801aaae:	4632      	mov	r2, r6
 801aab0:	463b      	mov	r3, r7
 801aab2:	ee1d 0a10 	vmov	r0, s26
 801aab6:	4659      	mov	r1, fp
 801aab8:	f00d f9f6 	bl	8027ea8 <__aeabi_dmul>
 801aabc:	4602      	mov	r2, r0
 801aabe:	460b      	mov	r3, r1
 801aac0:	4620      	mov	r0, r4
 801aac2:	4629      	mov	r1, r5
 801aac4:	f00d f838 	bl	8027b38 <__aeabi_dsub>
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801aac8:	4632      	mov	r2, r6
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801aaca:	4604      	mov	r4, r0
 801aacc:	460d      	mov	r5, r1
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801aace:	463b      	mov	r3, r7
 801aad0:	ec51 0b1c 	vmov	r0, r1, d12
 801aad4:	f00d f9e8 	bl	8027ea8 <__aeabi_dmul>
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801aad8:	ec45 4b19 	vmov	d9, r4, r5
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801aadc:	4642      	mov	r2, r8
 801aade:	464b      	mov	r3, r9
 801aae0:	4604      	mov	r4, r0
 801aae2:	460d      	mov	r5, r1
 801aae4:	ee1d 0a10 	vmov	r0, s26
 801aae8:	4659      	mov	r1, fp
 801aaea:	f00d f9dd 	bl	8027ea8 <__aeabi_dmul>
 801aaee:	460b      	mov	r3, r1
 801aaf0:	4602      	mov	r2, r0
 801aaf2:	4629      	mov	r1, r5
 801aaf4:	4620      	mov	r0, r4
 801aaf6:	f00d f821 	bl	8027b3c <__adddf3>
      for (i = 0; i < lenY; i++) {
 801aafa:	9b02      	ldr	r3, [sp, #8]
 801aafc:	2b00      	cmp	r3, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801aafe:	ec41 0b18 	vmov	d8, r0, r1
      for (i = 0; i < lenY; i++) {
 801ab02:	dd4d      	ble.n	801aba0 <cblas_zgemv+0x638>
 801ab04:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 801ab08:	e9dd 6b0d 	ldrd	r6, fp, [sp, #52]	; 0x34
 801ab0c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 801ab0e:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE A_real = CONST_REAL(A, lda * j + i);
 801ab12:	e9da 8900 	ldrd	r8, r9, [sl]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801ab16:	ec51 0b19 	vmov	r0, r1, d9
 801ab1a:	4642      	mov	r2, r8
 801ab1c:	464b      	mov	r3, r9
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 801ab1e:	e9da 4502 	ldrd	r4, r5, [sl, #8]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801ab22:	f00d f9c1 	bl	8027ea8 <__aeabi_dmul>
 801ab26:	4622      	mov	r2, r4
 801ab28:	462b      	mov	r3, r5
 801ab2a:	ec41 0b1a 	vmov	d10, r0, r1
 801ab2e:	ec51 0b18 	vmov	r0, r1, d8
 801ab32:	f00d f9b9 	bl	8027ea8 <__aeabi_dmul>
 801ab36:	4602      	mov	r2, r0
 801ab38:	460b      	mov	r3, r1
 801ab3a:	ec51 0b1a 	vmov	r0, r1, d10
 801ab3e:	f00c fffd 	bl	8027b3c <__adddf3>
 801ab42:	4602      	mov	r2, r0
 801ab44:	460b      	mov	r3, r1
 801ab46:	e956 0102 	ldrd	r0, r1, [r6, #-8]
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801ab4a:	9404      	str	r4, [sp, #16]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801ab4c:	f00c fff6 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801ab50:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 801ab54:	9305      	str	r3, [sp, #20]
        REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
 801ab56:	e946 0102 	strd	r0, r1, [r6, #-8]
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801ab5a:	ec53 2b19 	vmov	r2, r3, d9
 801ab5e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 801ab62:	f00d f9a1 	bl	8027ea8 <__aeabi_dmul>
 801ab66:	4642      	mov	r2, r8
 801ab68:	464b      	mov	r3, r9
 801ab6a:	4604      	mov	r4, r0
 801ab6c:	460d      	mov	r5, r1
 801ab6e:	ec51 0b18 	vmov	r0, r1, d8
 801ab72:	f00d f999 	bl	8027ea8 <__aeabi_dmul>
 801ab76:	4602      	mov	r2, r0
 801ab78:	460b      	mov	r3, r1
 801ab7a:	4620      	mov	r0, r4
 801ab7c:	4629      	mov	r1, r5
 801ab7e:	f00c ffdd 	bl	8027b3c <__adddf3>
 801ab82:	460b      	mov	r3, r1
 801ab84:	4602      	mov	r2, r0
 801ab86:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801ab8a:	f00c ffd7 	bl	8027b3c <__adddf3>
      for (i = 0; i < lenY; i++) {
 801ab8e:	9b00      	ldr	r3, [sp, #0]
 801ab90:	f10a 0a10 	add.w	sl, sl, #16
 801ab94:	4553      	cmp	r3, sl
        IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
 801ab96:	e9cb 0102 	strd	r0, r1, [fp, #8]
      for (i = 0; i < lenY; i++) {
 801ab9a:	443e      	add	r6, r7
 801ab9c:	44bb      	add	fp, r7
 801ab9e:	d1b8      	bne.n	801ab12 <cblas_zgemv+0x5aa>
    for (j = 0; j < lenX; j++) {
 801aba0:	9a07      	ldr	r2, [sp, #28]
 801aba2:	990c      	ldr	r1, [sp, #48]	; 0x30
 801aba4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801aba6:	440a      	add	r2, r1
 801aba8:	9207      	str	r2, [sp, #28]
 801abaa:	9906      	ldr	r1, [sp, #24]
 801abac:	9a08      	ldr	r2, [sp, #32]
 801abae:	440a      	add	r2, r1
 801abb0:	9208      	str	r2, [sp, #32]
 801abb2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801abb4:	9a00      	ldr	r2, [sp, #0]
 801abb6:	440a      	add	r2, r1
 801abb8:	9200      	str	r2, [sp, #0]
 801abba:	9a03      	ldr	r2, [sp, #12]
 801abbc:	3301      	adds	r3, #1
 801abbe:	429a      	cmp	r2, r3
 801abc0:	930a      	str	r3, [sp, #40]	; 0x28
 801abc2:	f47f af65 	bne.w	801aa90 <cblas_zgemv+0x528>
 801abc6:	e6af      	b.n	801a928 <cblas_zgemv+0x3c0>
 801abc8:	3ff00000 	.word	0x3ff00000
    INDEX iy = OFFSET(lenY, incY);
 801abcc:	9a08      	ldr	r2, [sp, #32]
 801abce:	2a00      	cmp	r2, #0
 801abd0:	f340 81a2 	ble.w	801af18 <cblas_zgemv+0x9b0>
 801abd4:	2300      	movs	r3, #0
    for (i = 0; i < lenY; i++) {
 801abd6:	9a02      	ldr	r2, [sp, #8]
 801abd8:	2a00      	cmp	r2, #0
 801abda:	f77f aea5 	ble.w	801a928 <cblas_zgemv+0x3c0>
 801abde:	9d08      	ldr	r5, [sp, #32]
 801abe0:	990a      	ldr	r1, [sp, #40]	; 0x28
 801abe2:	9803      	ldr	r0, [sp, #12]
 801abe4:	012d      	lsls	r5, r5, #4
 801abe6:	950e      	str	r5, [sp, #56]	; 0x38
 801abe8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801abea:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 801abee:	f1c0 0201 	rsb	r2, r0, #1
 801abf2:	2900      	cmp	r1, #0
 801abf4:	930a      	str	r3, [sp, #40]	; 0x28
 801abf6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801abf8:	fb02 f201 	mul.w	r2, r2, r1
 801abfc:	bfc8      	it	gt
 801abfe:	2200      	movgt	r2, #0
 801ac00:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ac04:	930c      	str	r3, [sp, #48]	; 0x30
 801ac06:	010b      	lsls	r3, r1, #4
 801ac08:	9304      	str	r3, [sp, #16]
 801ac0a:	9b06      	ldr	r3, [sp, #24]
 801ac0c:	011b      	lsls	r3, r3, #4
 801ac0e:	930b      	str	r3, [sp, #44]	; 0x2c
 801ac10:	9b09      	ldr	r3, [sp, #36]	; 0x24
      INDEX ix = OFFSET(lenX, incX);
 801ac12:	2400      	movs	r4, #0
 801ac14:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801ac18:	9407      	str	r4, [sp, #28]
 801ac1a:	9408      	str	r4, [sp, #32]
 801ac1c:	9300      	str	r3, [sp, #0]
      for (j = 0; j < lenX; j++) {
 801ac1e:	ed9f 7bce 	vldr	d7, [pc, #824]	; 801af58 <cblas_zgemv+0x9f0>
 801ac22:	9b03      	ldr	r3, [sp, #12]
 801ac24:	eeb0 ba47 	vmov.f32	s22, s14
 801ac28:	eef0 ba67 	vmov.f32	s23, s15
 801ac2c:	2b00      	cmp	r3, #0
 801ac2e:	eeb0 aa47 	vmov.f32	s20, s14
 801ac32:	eef0 aa67 	vmov.f32	s21, s15
 801ac36:	dd56      	ble.n	801ace6 <cblas_zgemv+0x77e>
 801ac38:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ac3a:	9a07      	ldr	r2, [sp, #28]
 801ac3c:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 801ac40:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801ac44:	ed9a 7b00 	vldr	d7, [sl]
        const BASE x_real = CONST_REAL(X, ix);
 801ac48:	e9db 6700 	ldrd	r6, r7, [fp]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 801ac4c:	eeb0 9a47 	vmov.f32	s18, s14
 801ac50:	eef0 9a67 	vmov.f32	s19, s15
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801ac54:	ed9a 6b02 	vldr	d6, [sl, #8]
        dotR += A_real * x_real - A_imag * x_imag;
 801ac58:	ec53 2b17 	vmov	r2, r3, d7
        const BASE A_imag = CONST_IMAG(A, lda * i + j);
 801ac5c:	eeb0 8a46 	vmov.f32	s16, s12
 801ac60:	eef0 8a66 	vmov.f32	s17, s13
        dotR += A_real * x_real - A_imag * x_imag;
 801ac64:	4630      	mov	r0, r6
 801ac66:	4639      	mov	r1, r7
 801ac68:	f00d f91e 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = CONST_IMAG(X, ix);
 801ac6c:	e9db 8902 	ldrd	r8, r9, [fp, #8]
        dotR += A_real * x_real - A_imag * x_imag;
 801ac70:	ec53 2b18 	vmov	r2, r3, d8
 801ac74:	4604      	mov	r4, r0
 801ac76:	460d      	mov	r5, r1
 801ac78:	4640      	mov	r0, r8
 801ac7a:	4649      	mov	r1, r9
 801ac7c:	f00d f914 	bl	8027ea8 <__aeabi_dmul>
 801ac80:	4602      	mov	r2, r0
 801ac82:	460b      	mov	r3, r1
 801ac84:	4620      	mov	r0, r4
 801ac86:	4629      	mov	r1, r5
 801ac88:	f00c ff56 	bl	8027b38 <__aeabi_dsub>
 801ac8c:	4602      	mov	r2, r0
 801ac8e:	460b      	mov	r3, r1
 801ac90:	ec51 0b1a 	vmov	r0, r1, d10
 801ac94:	f00c ff52 	bl	8027b3c <__adddf3>
        dotI += A_real * x_imag + A_imag * x_real;
 801ac98:	ec53 2b19 	vmov	r2, r3, d9
        dotR += A_real * x_real - A_imag * x_imag;
 801ac9c:	4604      	mov	r4, r0
 801ac9e:	460d      	mov	r5, r1
        dotI += A_real * x_imag + A_imag * x_real;
 801aca0:	4640      	mov	r0, r8
 801aca2:	4649      	mov	r1, r9
 801aca4:	f00d f900 	bl	8027ea8 <__aeabi_dmul>
        dotR += A_real * x_real - A_imag * x_imag;
 801aca8:	ec45 4b1a 	vmov	d10, r4, r5
        dotI += A_real * x_imag + A_imag * x_real;
 801acac:	ec53 2b18 	vmov	r2, r3, d8
 801acb0:	4604      	mov	r4, r0
 801acb2:	460d      	mov	r5, r1
 801acb4:	4630      	mov	r0, r6
 801acb6:	4639      	mov	r1, r7
 801acb8:	f00d f8f6 	bl	8027ea8 <__aeabi_dmul>
 801acbc:	4602      	mov	r2, r0
 801acbe:	460b      	mov	r3, r1
 801acc0:	4620      	mov	r0, r4
 801acc2:	4629      	mov	r1, r5
 801acc4:	f00c ff3a 	bl	8027b3c <__adddf3>
 801acc8:	460b      	mov	r3, r1
 801acca:	4602      	mov	r2, r0
 801accc:	ec51 0b1b 	vmov	r0, r1, d11
 801acd0:	f00c ff34 	bl	8027b3c <__adddf3>
 801acd4:	9b04      	ldr	r3, [sp, #16]
 801acd6:	449b      	add	fp, r3
      for (j = 0; j < lenX; j++) {
 801acd8:	9b00      	ldr	r3, [sp, #0]
 801acda:	f10a 0a10 	add.w	sl, sl, #16
 801acde:	459a      	cmp	sl, r3
        dotI += A_real * x_imag + A_imag * x_real;
 801ace0:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = 0; j < lenX; j++) {
 801ace4:	d1ae      	bne.n	801ac44 <cblas_zgemv+0x6dc>
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801ace6:	ec53 2b1a 	vmov	r2, r3, d10
 801acea:	ec51 0b1c 	vmov	r0, r1, d12
 801acee:	f00d f8db 	bl	8027ea8 <__aeabi_dmul>
 801acf2:	ec5a 9b1b 	vmov	r9, sl, d11
 801acf6:	ec58 7b1d 	vmov	r7, r8, d13
 801acfa:	4604      	mov	r4, r0
 801acfc:	460d      	mov	r5, r1
 801acfe:	ee1b 2a10 	vmov	r2, s22
 801ad02:	4653      	mov	r3, sl
 801ad04:	ee1d 0a10 	vmov	r0, s26
 801ad08:	4641      	mov	r1, r8
 801ad0a:	f00d f8cd 	bl	8027ea8 <__aeabi_dmul>
 801ad0e:	4602      	mov	r2, r0
 801ad10:	460b      	mov	r3, r1
 801ad12:	4620      	mov	r0, r4
 801ad14:	4629      	mov	r1, r5
 801ad16:	f00c ff0f 	bl	8027b38 <__aeabi_dsub>
 801ad1a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 801ad1c:	4602      	mov	r2, r0
 801ad1e:	460b      	mov	r3, r1
 801ad20:	e9d6 0100 	ldrd	r0, r1, [r6]
 801ad24:	f00c ff0a 	bl	8027b3c <__adddf3>
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801ad28:	ee1b 2a10 	vmov	r2, s22
      REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
 801ad2c:	e9c6 0100 	strd	r0, r1, [r6]
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801ad30:	4653      	mov	r3, sl
 801ad32:	ec51 0b1c 	vmov	r0, r1, d12
 801ad36:	f00d f8b7 	bl	8027ea8 <__aeabi_dmul>
 801ad3a:	ec53 2b1a 	vmov	r2, r3, d10
 801ad3e:	460d      	mov	r5, r1
 801ad40:	4604      	mov	r4, r0
 801ad42:	4641      	mov	r1, r8
 801ad44:	ee1d 0a10 	vmov	r0, s26
 801ad48:	f00d f8ae 	bl	8027ea8 <__aeabi_dmul>
 801ad4c:	4602      	mov	r2, r0
 801ad4e:	460b      	mov	r3, r1
 801ad50:	4620      	mov	r0, r4
 801ad52:	4629      	mov	r1, r5
 801ad54:	f00c fef2 	bl	8027b3c <__adddf3>
 801ad58:	4602      	mov	r2, r0
 801ad5a:	460b      	mov	r3, r1
 801ad5c:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801ad60:	f00c feec 	bl	8027b3c <__adddf3>
 801ad64:	e9dd 5306 	ldrd	r5, r3, [sp, #24]
 801ad68:	442b      	add	r3, r5
 801ad6a:	9307      	str	r3, [sp, #28]
 801ad6c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 801ad6e:	9b00      	ldr	r3, [sp, #0]
    for (i = 0; i < lenY; i++) {
 801ad70:	9a08      	ldr	r2, [sp, #32]
 801ad72:	442b      	add	r3, r5
 801ad74:	9300      	str	r3, [sp, #0]
 801ad76:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801ad78:	18f3      	adds	r3, r6, r3
 801ad7a:	930a      	str	r3, [sp, #40]	; 0x28
 801ad7c:	9b02      	ldr	r3, [sp, #8]
 801ad7e:	3201      	adds	r2, #1
 801ad80:	4293      	cmp	r3, r2
      IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
 801ad82:	e9c6 0102 	strd	r0, r1, [r6, #8]
    for (i = 0; i < lenY; i++) {
 801ad86:	9208      	str	r2, [sp, #32]
 801ad88:	f47f af49 	bne.w	801ac1e <cblas_zgemv+0x6b6>
 801ad8c:	e5cc      	b.n	801a928 <cblas_zgemv+0x3c0>
    INDEX ix = OFFSET(lenX, incX);
 801ad8e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ad90:	2a00      	cmp	r2, #0
 801ad92:	f340 80c7 	ble.w	801af24 <cblas_zgemv+0x9bc>
 801ad96:	2300      	movs	r3, #0
    for (j = 0; j < lenX; j++) {
 801ad98:	9a03      	ldr	r2, [sp, #12]
 801ad9a:	2a00      	cmp	r2, #0
 801ad9c:	f77f adc4 	ble.w	801a928 <cblas_zgemv+0x3c0>
 801ada0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 801ada2:	9808      	ldr	r0, [sp, #32]
 801ada4:	9c02      	ldr	r4, [sp, #8]
 801ada6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801ada8:	013f      	lsls	r7, r7, #4
 801adaa:	970b      	str	r7, [sp, #44]	; 0x2c
 801adac:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801adae:	f1c4 0201 	rsb	r2, r4, #1
 801adb2:	2800      	cmp	r0, #0
 801adb4:	fb02 f200 	mul.w	r2, r2, r0
 801adb8:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801adbc:	bfc8      	it	gt
 801adbe:	2200      	movgt	r2, #0
 801adc0:	eb05 1102 	add.w	r1, r5, r2, lsl #4
 801adc4:	9304      	str	r3, [sp, #16]
 801adc6:	0103      	lsls	r3, r0, #4
 801adc8:	930e      	str	r3, [sp, #56]	; 0x38
 801adca:	f101 0308 	add.w	r3, r1, #8
 801adce:	930c      	str	r3, [sp, #48]	; 0x30
 801add0:	9b06      	ldr	r3, [sp, #24]
 801add2:	910d      	str	r1, [sp, #52]	; 0x34
 801add4:	011b      	lsls	r3, r3, #4
 801add6:	930a      	str	r3, [sp, #40]	; 0x28
 801add8:	9b09      	ldr	r3, [sp, #36]	; 0x24
      INDEX iy = OFFSET(lenY, incY);
 801adda:	2600      	movs	r6, #0
 801addc:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801ade0:	9607      	str	r6, [sp, #28]
 801ade2:	9608      	str	r6, [sp, #32]
 801ade4:	9300      	str	r3, [sp, #0]
      BASE x_real = CONST_REAL(X, ix);
 801ade6:	9c04      	ldr	r4, [sp, #16]
 801ade8:	e9d4 8900 	ldrd	r8, r9, [r4]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801adec:	ec51 0b1c 	vmov	r0, r1, d12
 801adf0:	4642      	mov	r2, r8
 801adf2:	464b      	mov	r3, r9
 801adf4:	f00d f858 	bl	8027ea8 <__aeabi_dmul>
      BASE x_imag = CONST_IMAG(X, ix);
 801adf8:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801adfc:	ec5b ab1d 	vmov	sl, fp, d13
 801ae00:	4604      	mov	r4, r0
 801ae02:	460d      	mov	r5, r1
 801ae04:	4632      	mov	r2, r6
 801ae06:	463b      	mov	r3, r7
 801ae08:	ee1d 0a10 	vmov	r0, s26
 801ae0c:	4659      	mov	r1, fp
 801ae0e:	f00d f84b 	bl	8027ea8 <__aeabi_dmul>
 801ae12:	4602      	mov	r2, r0
 801ae14:	460b      	mov	r3, r1
 801ae16:	4620      	mov	r0, r4
 801ae18:	4629      	mov	r1, r5
 801ae1a:	f00c fe8d 	bl	8027b38 <__aeabi_dsub>
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801ae1e:	4632      	mov	r2, r6
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801ae20:	4604      	mov	r4, r0
 801ae22:	460d      	mov	r5, r1
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801ae24:	463b      	mov	r3, r7
 801ae26:	ec51 0b1c 	vmov	r0, r1, d12
 801ae2a:	f00d f83d 	bl	8027ea8 <__aeabi_dmul>
      BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
 801ae2e:	ec45 4b19 	vmov	d9, r4, r5
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801ae32:	4642      	mov	r2, r8
 801ae34:	464b      	mov	r3, r9
 801ae36:	4604      	mov	r4, r0
 801ae38:	460d      	mov	r5, r1
 801ae3a:	ee1d 0a10 	vmov	r0, s26
 801ae3e:	4659      	mov	r1, fp
 801ae40:	f00d f832 	bl	8027ea8 <__aeabi_dmul>
 801ae44:	460b      	mov	r3, r1
 801ae46:	4602      	mov	r2, r0
 801ae48:	4629      	mov	r1, r5
 801ae4a:	4620      	mov	r0, r4
 801ae4c:	f00c fe76 	bl	8027b3c <__adddf3>
      for (i = 0; i < lenY; i++) {
 801ae50:	9b02      	ldr	r3, [sp, #8]
 801ae52:	2b00      	cmp	r3, #0
      BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
 801ae54:	ec41 0b18 	vmov	d8, r0, r1
      for (i = 0; i < lenY; i++) {
 801ae58:	dd4a      	ble.n	801aef0 <cblas_zgemv+0x988>
 801ae5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ae5c:	9a07      	ldr	r2, [sp, #28]
 801ae5e:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 801ae60:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 801ae64:	e9dd 3b0c 	ldrd	r3, fp, [sp, #48]	; 0x30
 801ae68:	461c      	mov	r4, r3
        const BASE A_real = CONST_REAL(A, lda * j + i);
 801ae6a:	e9da 8900 	ldrd	r8, r9, [sl]
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801ae6e:	ec51 0b19 	vmov	r0, r1, d9
 801ae72:	4642      	mov	r2, r8
 801ae74:	464b      	mov	r3, r9
        const BASE A_imag = CONST_IMAG(A, lda * j + i);
 801ae76:	e9da 6702 	ldrd	r6, r7, [sl, #8]
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801ae7a:	f00d f815 	bl	8027ea8 <__aeabi_dmul>
 801ae7e:	4632      	mov	r2, r6
 801ae80:	463b      	mov	r3, r7
 801ae82:	ec41 0b1a 	vmov	d10, r0, r1
 801ae86:	ec51 0b18 	vmov	r0, r1, d8
 801ae8a:	f00d f80d 	bl	8027ea8 <__aeabi_dmul>
 801ae8e:	4602      	mov	r2, r0
 801ae90:	460b      	mov	r3, r1
 801ae92:	ec51 0b1a 	vmov	r0, r1, d10
 801ae96:	f00c fe4f 	bl	8027b38 <__aeabi_dsub>
 801ae9a:	4602      	mov	r2, r0
 801ae9c:	460b      	mov	r3, r1
 801ae9e:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801aea2:	f00c fe4b 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801aea6:	4642      	mov	r2, r8
        REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
 801aea8:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801aeac:	464b      	mov	r3, r9
 801aeae:	ec51 0b18 	vmov	r0, r1, d8
 801aeb2:	f00c fff9 	bl	8027ea8 <__aeabi_dmul>
 801aeb6:	4632      	mov	r2, r6
 801aeb8:	463b      	mov	r3, r7
 801aeba:	4606      	mov	r6, r0
 801aebc:	460f      	mov	r7, r1
 801aebe:	ec51 0b19 	vmov	r0, r1, d9
 801aec2:	f00c fff1 	bl	8027ea8 <__aeabi_dmul>
 801aec6:	4602      	mov	r2, r0
 801aec8:	460b      	mov	r3, r1
 801aeca:	4630      	mov	r0, r6
 801aecc:	4639      	mov	r1, r7
 801aece:	f00c fe35 	bl	8027b3c <__adddf3>
 801aed2:	460b      	mov	r3, r1
 801aed4:	4602      	mov	r2, r0
 801aed6:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801aeda:	f00c fe2f 	bl	8027b3c <__adddf3>
      for (i = 0; i < lenY; i++) {
 801aede:	9b00      	ldr	r3, [sp, #0]
 801aee0:	f10a 0a10 	add.w	sl, sl, #16
 801aee4:	4553      	cmp	r3, sl
        IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
 801aee6:	e9cb 0102 	strd	r0, r1, [fp, #8]
      for (i = 0; i < lenY; i++) {
 801aeea:	442c      	add	r4, r5
 801aeec:	44ab      	add	fp, r5
 801aeee:	d1bc      	bne.n	801ae6a <cblas_zgemv+0x902>
    for (j = 0; j < lenX; j++) {
 801aef0:	9a04      	ldr	r2, [sp, #16]
 801aef2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801aef4:	9b08      	ldr	r3, [sp, #32]
 801aef6:	440a      	add	r2, r1
 801aef8:	9204      	str	r2, [sp, #16]
 801aefa:	e9dd 1206 	ldrd	r1, r2, [sp, #24]
 801aefe:	440a      	add	r2, r1
 801af00:	9207      	str	r2, [sp, #28]
 801af02:	990a      	ldr	r1, [sp, #40]	; 0x28
 801af04:	9a00      	ldr	r2, [sp, #0]
 801af06:	440a      	add	r2, r1
 801af08:	9200      	str	r2, [sp, #0]
 801af0a:	9a03      	ldr	r2, [sp, #12]
 801af0c:	3301      	adds	r3, #1
 801af0e:	429a      	cmp	r2, r3
 801af10:	9308      	str	r3, [sp, #32]
 801af12:	f47f af68 	bne.w	801ade6 <cblas_zgemv+0x87e>
 801af16:	e507      	b.n	801a928 <cblas_zgemv+0x3c0>
    INDEX iy = OFFSET(lenY, incY);
 801af18:	9b02      	ldr	r3, [sp, #8]
 801af1a:	f1c3 0301 	rsb	r3, r3, #1
 801af1e:	fb03 f302 	mul.w	r3, r3, r2
 801af22:	e658      	b.n	801abd6 <cblas_zgemv+0x66e>
    INDEX ix = OFFSET(lenX, incX);
 801af24:	9b03      	ldr	r3, [sp, #12]
 801af26:	f1c3 0301 	rsb	r3, r3, #1
 801af2a:	fb03 f302 	mul.w	r3, r3, r2
 801af2e:	e733      	b.n	801ad98 <cblas_zgemv+0x830>
    INDEX iy = OFFSET(lenY, incY);
 801af30:	9b02      	ldr	r3, [sp, #8]
 801af32:	f1c3 0301 	rsb	r3, r3, #1
 801af36:	fb03 f302 	mul.w	r3, r3, r2
 801af3a:	e53f      	b.n	801a9bc <cblas_zgemv+0x454>
    INDEX iy = OFFSET(lenY, incY);
 801af3c:	9b02      	ldr	r3, [sp, #8]
 801af3e:	f1c3 0301 	rsb	r3, r3, #1
 801af42:	fb03 f302 	mul.w	r3, r3, r2
 801af46:	e412      	b.n	801a76e <cblas_zgemv+0x206>
    INDEX ix = OFFSET(lenX, incX);
 801af48:	9b03      	ldr	r3, [sp, #12]
 801af4a:	f1c3 0301 	rsb	r3, r3, #1
 801af4e:	fb03 f302 	mul.w	r3, r3, r2
 801af52:	e576      	b.n	801aa42 <cblas_zgemv+0x4da>
 801af54:	f3af 8000 	nop.w
	...

0801af60 <cblas_zgerc>:

void
cblas_zgerc (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 801af60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801af64:	ed2d 8b0c 	vpush	{d8-d13}
 801af68:	b08b      	sub	sp, #44	; 0x2c
 801af6a:	4699      	mov	r9, r3
 801af6c:	1e0b      	subs	r3, r1, #0
 801af6e:	e9dd b520 	ldrd	fp, r5, [sp, #128]	; 0x80
 801af72:	e9dd a422 	ldrd	sl, r4, [sp, #136]	; 0x88
 801af76:	e9dd 7624 	ldrd	r7, r6, [sp, #144]	; 0x90
 801af7a:	4680      	mov	r8, r0
 801af7c:	9203      	str	r2, [sp, #12]
 801af7e:	9305      	str	r3, [sp, #20]
 801af80:	f2c0 8130 	blt.w	801b1e4 <cblas_zgerc+0x284>
 801af84:	3865      	subs	r0, #101	; 0x65
 801af86:	2801      	cmp	r0, #1
 801af88:	bf94      	ite	ls
 801af8a:	2000      	movls	r0, #0
 801af8c:	2001      	movhi	r0, #1
 801af8e:	9b03      	ldr	r3, [sp, #12]
 801af90:	2b00      	cmp	r3, #0
 801af92:	bfb8      	it	lt
 801af94:	2003      	movlt	r0, #3
 801af96:	2d00      	cmp	r5, #0
 801af98:	f040 80fc 	bne.w	801b194 <cblas_zgerc+0x234>
 801af9c:	2c00      	cmp	r4, #0
 801af9e:	f040 80e6 	bne.w	801b16e <cblas_zgerc+0x20e>
 801afa2:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 801afa6:	f000 8125 	beq.w	801b1f4 <cblas_zgerc+0x294>
 801afaa:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 801afae:	f040 81f4 	bne.w	801b39a <cblas_zgerc+0x43a>
 801afb2:	9b05      	ldr	r3, [sp, #20]
 801afb4:	2b01      	cmp	r3, #1
 801afb6:	bfb8      	it	lt
 801afb8:	2301      	movlt	r3, #1
 801afba:	429e      	cmp	r6, r3
 801afbc:	f2c0 80e6 	blt.w	801b18c <cblas_zgerc+0x22c>
 801afc0:	2008      	movs	r0, #8
 801afc2:	4a89      	ldr	r2, [pc, #548]	; (801b1e8 <cblas_zgerc+0x288>)
 801afc4:	4989      	ldr	r1, [pc, #548]	; (801b1ec <cblas_zgerc+0x28c>)
 801afc6:	f00c fd3f 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801afca:	ed99 7b00 	vldr	d7, [r9]
 801afce:	eeb0 ca47 	vmov.f32	s24, s14
 801afd2:	eef0 ca67 	vmov.f32	s25, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801afd6:	ed99 7b02 	vldr	d7, [r9, #8]
 801afda:	eeb0 da47 	vmov.f32	s26, s14
 801afde:	eef0 da67 	vmov.f32	s27, s15
      INDEX jy = OFFSET(N, incY);
 801afe2:	2c00      	cmp	r4, #0
 801afe4:	f340 81f6 	ble.w	801b3d4 <cblas_zgerc+0x474>
 801afe8:	2200      	movs	r2, #0
      for (j = 0; j < N; j++) {
 801afea:	9b03      	ldr	r3, [sp, #12]
 801afec:	2b00      	cmp	r3, #0
 801afee:	f340 80b9 	ble.w	801b164 <cblas_zgerc+0x204>
 801aff2:	9905      	ldr	r1, [sp, #20]
 801aff4:	9704      	str	r7, [sp, #16]
 801aff6:	f1c1 0301 	rsb	r3, r1, #1
 801affa:	2d00      	cmp	r5, #0
 801affc:	fb03 f305 	mul.w	r3, r3, r5
 801b000:	bfc8      	it	gt
 801b002:	2300      	movgt	r3, #0
 801b004:	eb0b 1303 	add.w	r3, fp, r3, lsl #4
 801b008:	9309      	str	r3, [sp, #36]	; 0x24
 801b00a:	012b      	lsls	r3, r5, #4
 801b00c:	eb0a 1202 	add.w	r2, sl, r2, lsl #4
 801b010:	9300      	str	r3, [sp, #0]
 801b012:	eb07 1301 	add.w	r3, r7, r1, lsl #4
 801b016:	0120      	lsls	r0, r4, #4
 801b018:	9201      	str	r2, [sp, #4]
 801b01a:	9302      	str	r3, [sp, #8]
 801b01c:	0132      	lsls	r2, r6, #4
        INDEX ix = OFFSET(M, incX);
 801b01e:	2300      	movs	r3, #0
 801b020:	9008      	str	r0, [sp, #32]
 801b022:	9207      	str	r2, [sp, #28]
 801b024:	9306      	str	r3, [sp, #24]
        const BASE Y_real = CONST_REAL(Y, jy);
 801b026:	9b01      	ldr	r3, [sp, #4]
 801b028:	e9d3 6700 	ldrd	r6, r7, [r3]
        const BASE Y_imag = -CONST_IMAG(Y, jy);
 801b02c:	68dc      	ldr	r4, [r3, #12]
 801b02e:	689a      	ldr	r2, [r3, #8]
 801b030:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
 801b034:	ee0b 2a10 	vmov	s22, r2
 801b038:	ee0b 4a90 	vmov	s23, r4
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b03c:	ec53 2b1c 	vmov	r2, r3, d12
 801b040:	4630      	mov	r0, r6
 801b042:	4639      	mov	r1, r7
 801b044:	f00c ff30 	bl	8027ea8 <__aeabi_dmul>
 801b048:	ec59 8b1b 	vmov	r8, r9, d11
 801b04c:	ec5b ab1d 	vmov	sl, fp, d13
 801b050:	4604      	mov	r4, r0
 801b052:	460d      	mov	r5, r1
 801b054:	ee1d 2a10 	vmov	r2, s26
 801b058:	465b      	mov	r3, fp
 801b05a:	4640      	mov	r0, r8
 801b05c:	4649      	mov	r1, r9
 801b05e:	f00c ff23 	bl	8027ea8 <__aeabi_dmul>
 801b062:	4602      	mov	r2, r0
 801b064:	460b      	mov	r3, r1
 801b066:	4620      	mov	r0, r4
 801b068:	4629      	mov	r1, r5
 801b06a:	f00c fd65 	bl	8027b38 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b06e:	ee1d 2a10 	vmov	r2, s26
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b072:	4604      	mov	r4, r0
 801b074:	460d      	mov	r5, r1
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b076:	465b      	mov	r3, fp
 801b078:	4630      	mov	r0, r6
 801b07a:	4639      	mov	r1, r7
 801b07c:	f00c ff14 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b080:	ec45 4b19 	vmov	d9, r4, r5
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b084:	ec53 2b1c 	vmov	r2, r3, d12
 801b088:	4604      	mov	r4, r0
 801b08a:	460d      	mov	r5, r1
 801b08c:	4640      	mov	r0, r8
 801b08e:	4649      	mov	r1, r9
 801b090:	f00c ff0a 	bl	8027ea8 <__aeabi_dmul>
 801b094:	460b      	mov	r3, r1
 801b096:	4602      	mov	r2, r0
 801b098:	4629      	mov	r1, r5
 801b09a:	4620      	mov	r0, r4
 801b09c:	f00c fd4e 	bl	8027b3c <__adddf3>
        for (i = 0; i < M; i++) {
 801b0a0:	9b05      	ldr	r3, [sp, #20]
 801b0a2:	2b00      	cmp	r3, #0
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b0a4:	ec41 0b18 	vmov	d8, r0, r1
        for (i = 0; i < M; i++) {
 801b0a8:	dd49      	ble.n	801b13e <cblas_zgerc+0x1de>
 801b0aa:	9b04      	ldr	r3, [sp, #16]
 801b0ac:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801b0ae:	9d02      	ldr	r5, [sp, #8]
 801b0b0:	f103 0b08 	add.w	fp, r3, #8
 801b0b4:	469a      	mov	sl, r3
          const BASE X_real = CONST_REAL(X, ix);
 801b0b6:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801b0ba:	ec51 0b19 	vmov	r0, r1, d9
 801b0be:	4632      	mov	r2, r6
 801b0c0:	463b      	mov	r3, r7
 801b0c2:	f00c fef1 	bl	8027ea8 <__aeabi_dmul>
          const BASE X_imag = CONST_IMAG(X, ix);
 801b0c6:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801b0ca:	ec41 0b1a 	vmov	d10, r0, r1
 801b0ce:	4642      	mov	r2, r8
 801b0d0:	464b      	mov	r3, r9
 801b0d2:	ec51 0b18 	vmov	r0, r1, d8
 801b0d6:	f00c fee7 	bl	8027ea8 <__aeabi_dmul>
 801b0da:	4602      	mov	r2, r0
 801b0dc:	460b      	mov	r3, r1
 801b0de:	ec51 0b1a 	vmov	r0, r1, d10
 801b0e2:	f00c fd29 	bl	8027b38 <__aeabi_dsub>
 801b0e6:	4602      	mov	r2, r0
 801b0e8:	460b      	mov	r3, r1
 801b0ea:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801b0ee:	f00c fd25 	bl	8027b3c <__adddf3>
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801b0f2:	4642      	mov	r2, r8
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801b0f4:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801b0f8:	464b      	mov	r3, r9
 801b0fa:	ec51 0b19 	vmov	r0, r1, d9
 801b0fe:	f00c fed3 	bl	8027ea8 <__aeabi_dmul>
 801b102:	4632      	mov	r2, r6
 801b104:	463b      	mov	r3, r7
 801b106:	4606      	mov	r6, r0
 801b108:	460f      	mov	r7, r1
 801b10a:	ec51 0b18 	vmov	r0, r1, d8
 801b10e:	f00c fecb 	bl	8027ea8 <__aeabi_dmul>
 801b112:	4602      	mov	r2, r0
 801b114:	460b      	mov	r3, r1
 801b116:	4630      	mov	r0, r6
 801b118:	4639      	mov	r1, r7
 801b11a:	f00c fd0f 	bl	8027b3c <__adddf3>
 801b11e:	460b      	mov	r3, r1
 801b120:	4602      	mov	r2, r0
 801b122:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801b126:	f00c fd09 	bl	8027b3c <__adddf3>
 801b12a:	f10a 0a10 	add.w	sl, sl, #16
 801b12e:	9b00      	ldr	r3, [sp, #0]
 801b130:	e94a 0102 	strd	r0, r1, [sl, #-8]
        for (i = 0; i < M; i++) {
 801b134:	4555      	cmp	r5, sl
 801b136:	441c      	add	r4, r3
 801b138:	f10b 0b10 	add.w	fp, fp, #16
 801b13c:	d1bb      	bne.n	801b0b6 <cblas_zgerc+0x156>
      for (j = 0; j < N; j++) {
 801b13e:	9a01      	ldr	r2, [sp, #4]
 801b140:	9908      	ldr	r1, [sp, #32]
 801b142:	9b06      	ldr	r3, [sp, #24]
 801b144:	440a      	add	r2, r1
 801b146:	9904      	ldr	r1, [sp, #16]
 801b148:	9201      	str	r2, [sp, #4]
 801b14a:	4608      	mov	r0, r1
 801b14c:	9a07      	ldr	r2, [sp, #28]
 801b14e:	9902      	ldr	r1, [sp, #8]
 801b150:	4410      	add	r0, r2
 801b152:	4411      	add	r1, r2
 801b154:	9a03      	ldr	r2, [sp, #12]
 801b156:	9004      	str	r0, [sp, #16]
 801b158:	3301      	adds	r3, #1
 801b15a:	429a      	cmp	r2, r3
 801b15c:	9306      	str	r3, [sp, #24]
 801b15e:	9102      	str	r1, [sp, #8]
 801b160:	f47f af61 	bne.w	801b026 <cblas_zgerc+0xc6>
#define BASE double
#include "source_gerc.h"
#undef BASE
}
 801b164:	b00b      	add	sp, #44	; 0x2c
 801b166:	ecbd 8b0c 	vpop	{d8-d13}
 801b16a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b16e:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 801b172:	f000 8118 	beq.w	801b3a6 <cblas_zgerc+0x446>
 801b176:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 801b17a:	f040 8131 	bne.w	801b3e0 <cblas_zgerc+0x480>
 801b17e:	9b05      	ldr	r3, [sp, #20]
 801b180:	2b01      	cmp	r3, #1
 801b182:	bfb8      	it	lt
 801b184:	2301      	movlt	r3, #1
 801b186:	429e      	cmp	r6, r3
 801b188:	f280 812c 	bge.w	801b3e4 <cblas_zgerc+0x484>
 801b18c:	4a16      	ldr	r2, [pc, #88]	; (801b1e8 <cblas_zgerc+0x288>)
 801b18e:	4917      	ldr	r1, [pc, #92]	; (801b1ec <cblas_zgerc+0x28c>)
 801b190:	200a      	movs	r0, #10
 801b192:	e718      	b.n	801afc6 <cblas_zgerc+0x66>
 801b194:	2c00      	cmp	r4, #0
 801b196:	f43f af04 	beq.w	801afa2 <cblas_zgerc+0x42>
 801b19a:	f1b8 0f65 	cmp.w	r8, #101	; 0x65
 801b19e:	f000 810b 	beq.w	801b3b8 <cblas_zgerc+0x458>
 801b1a2:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
 801b1a6:	f000 8123 	beq.w	801b3f0 <cblas_zgerc+0x490>
 801b1aa:	2800      	cmp	r0, #0
 801b1ac:	f040 80f6 	bne.w	801b39c <cblas_zgerc+0x43c>
    const BASE alpha_real = CONST_REAL0(alpha);
 801b1b0:	ed99 7b00 	vldr	d7, [r9]
 801b1b4:	eeb0 ca47 	vmov.f32	s24, s14
 801b1b8:	eef0 ca67 	vmov.f32	s25, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b1bc:	ed99 7b02 	vldr	d7, [r9, #8]
    } else if (order == CblasColMajor) {
 801b1c0:	f1b8 0f66 	cmp.w	r8, #102	; 0x66
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b1c4:	eeb0 da47 	vmov.f32	s26, s14
 801b1c8:	eef0 da67 	vmov.f32	s27, s15
    } else if (order == CblasColMajor) {
 801b1cc:	f43f af09 	beq.w	801afe2 <cblas_zgerc+0x82>
      BLAS_ERROR("unrecognized operation");
 801b1d0:	4a07      	ldr	r2, [pc, #28]	; (801b1f0 <cblas_zgerc+0x290>)
 801b1d2:	4906      	ldr	r1, [pc, #24]	; (801b1ec <cblas_zgerc+0x28c>)
 801b1d4:	2000      	movs	r0, #0
 801b1d6:	b00b      	add	sp, #44	; 0x2c
 801b1d8:	ecbd 8b0c 	vpop	{d8-d13}
 801b1dc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b1e0:	f00c bc32 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b1e4:	2002      	movs	r0, #2
 801b1e6:	e6d2      	b.n	801af8e <cblas_zgerc+0x2e>
 801b1e8:	08030378 	.word	0x08030378
 801b1ec:	080306d0 	.word	0x080306d0
 801b1f0:	080305a8 	.word	0x080305a8
 801b1f4:	9803      	ldr	r0, [sp, #12]
 801b1f6:	2801      	cmp	r0, #1
 801b1f8:	bfb8      	it	lt
 801b1fa:	2001      	movlt	r0, #1
 801b1fc:	4286      	cmp	r6, r0
 801b1fe:	bfac      	ite	ge
 801b200:	2008      	movge	r0, #8
 801b202:	200a      	movlt	r0, #10
 801b204:	4a80      	ldr	r2, [pc, #512]	; (801b408 <cblas_zgerc+0x4a8>)
 801b206:	4981      	ldr	r1, [pc, #516]	; (801b40c <cblas_zgerc+0x4ac>)
 801b208:	f00c fc1e 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801b20c:	ed99 7b00 	vldr	d7, [r9]
 801b210:	eeb0 da47 	vmov.f32	s26, s14
 801b214:	eef0 da67 	vmov.f32	s27, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b218:	ed99 7b02 	vldr	d7, [r9, #8]
      INDEX ix = OFFSET(M, incX);
 801b21c:	2d00      	cmp	r5, #0
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b21e:	eeb0 ca47 	vmov.f32	s24, s14
 801b222:	eef0 ca67 	vmov.f32	s25, s15
      INDEX ix = OFFSET(M, incX);
 801b226:	f340 80cf 	ble.w	801b3c8 <cblas_zgerc+0x468>
 801b22a:	2200      	movs	r2, #0
      for (i = 0; i < M; i++) {
 801b22c:	9b05      	ldr	r3, [sp, #20]
 801b22e:	2b00      	cmp	r3, #0
 801b230:	dd98      	ble.n	801b164 <cblas_zgerc+0x204>
 801b232:	9903      	ldr	r1, [sp, #12]
 801b234:	9704      	str	r7, [sp, #16]
 801b236:	f1c1 0301 	rsb	r3, r1, #1
 801b23a:	2c00      	cmp	r4, #0
 801b23c:	fb03 f304 	mul.w	r3, r3, r4
 801b240:	bfc8      	it	gt
 801b242:	2300      	movgt	r3, #0
 801b244:	eb0a 1303 	add.w	r3, sl, r3, lsl #4
 801b248:	eb0b 1202 	add.w	r2, fp, r2, lsl #4
 801b24c:	9309      	str	r3, [sp, #36]	; 0x24
 801b24e:	0123      	lsls	r3, r4, #4
 801b250:	0128      	lsls	r0, r5, #4
 801b252:	9202      	str	r2, [sp, #8]
 801b254:	9301      	str	r3, [sp, #4]
 801b256:	0132      	lsls	r2, r6, #4
        INDEX jy = OFFSET(N, incY);
 801b258:	2300      	movs	r3, #0
 801b25a:	9008      	str	r0, [sp, #32]
 801b25c:	9207      	str	r2, [sp, #28]
 801b25e:	eb07 1501 	add.w	r5, r7, r1, lsl #4
 801b262:	9306      	str	r3, [sp, #24]
        const BASE X_real = CONST_REAL(X, ix);
 801b264:	9c02      	ldr	r4, [sp, #8]
 801b266:	e9d4 8900 	ldrd	r8, r9, [r4]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b26a:	ec53 2b1d 	vmov	r2, r3, d13
 801b26e:	4640      	mov	r0, r8
 801b270:	4649      	mov	r1, r9
 801b272:	f00c fe19 	bl	8027ea8 <__aeabi_dmul>
        const BASE X_imag = CONST_IMAG(X, ix);
 801b276:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b27a:	ec53 2b1c 	vmov	r2, r3, d12
 801b27e:	4682      	mov	sl, r0
 801b280:	468b      	mov	fp, r1
 801b282:	4630      	mov	r0, r6
 801b284:	4639      	mov	r1, r7
 801b286:	f00c fe0f 	bl	8027ea8 <__aeabi_dmul>
 801b28a:	4602      	mov	r2, r0
 801b28c:	460b      	mov	r3, r1
 801b28e:	4650      	mov	r0, sl
 801b290:	4659      	mov	r1, fp
 801b292:	f00c fc51 	bl	8027b38 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b296:	ec53 2b1c 	vmov	r2, r3, d12
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b29a:	4682      	mov	sl, r0
 801b29c:	468b      	mov	fp, r1
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b29e:	4640      	mov	r0, r8
 801b2a0:	4649      	mov	r1, r9
 801b2a2:	f00c fe01 	bl	8027ea8 <__aeabi_dmul>
 801b2a6:	ec53 2b1d 	vmov	r2, r3, d13
 801b2aa:	4680      	mov	r8, r0
 801b2ac:	4689      	mov	r9, r1
 801b2ae:	4630      	mov	r0, r6
 801b2b0:	4639      	mov	r1, r7
 801b2b2:	f00c fdf9 	bl	8027ea8 <__aeabi_dmul>
 801b2b6:	460b      	mov	r3, r1
 801b2b8:	4602      	mov	r2, r0
 801b2ba:	4649      	mov	r1, r9
 801b2bc:	4640      	mov	r0, r8
 801b2be:	f00c fc3d 	bl	8027b3c <__adddf3>
        for (j = 0; j < N; j++) {
 801b2c2:	9b03      	ldr	r3, [sp, #12]
 801b2c4:	2b00      	cmp	r3, #0
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b2c6:	ec4b ab1b 	vmov	d11, sl, fp
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b2ca:	ec41 0b18 	vmov	d8, r0, r1
        for (j = 0; j < N; j++) {
 801b2ce:	dd4e      	ble.n	801b36e <cblas_zgerc+0x40e>
 801b2d0:	9b04      	ldr	r3, [sp, #16]
 801b2d2:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801b2d4:	9500      	str	r5, [sp, #0]
 801b2d6:	f103 0b08 	add.w	fp, r3, #8
 801b2da:	469a      	mov	sl, r3
          const BASE Y_real = CONST_REAL(Y, jy);
 801b2dc:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801b2e0:	ec51 0b1b 	vmov	r0, r1, d11
 801b2e4:	4632      	mov	r2, r6
 801b2e6:	463b      	mov	r3, r7
 801b2e8:	f00c fdde 	bl	8027ea8 <__aeabi_dmul>
          const BASE Y_imag = -CONST_IMAG(Y, jy);
 801b2ec:	68e5      	ldr	r5, [r4, #12]
 801b2ee:	f8d4 8008 	ldr.w	r8, [r4, #8]
 801b2f2:	f105 4900 	add.w	r9, r5, #2147483648	; 0x80000000
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801b2f6:	ec41 0b1a 	vmov	d10, r0, r1
 801b2fa:	4642      	mov	r2, r8
 801b2fc:	464b      	mov	r3, r9
 801b2fe:	ec51 0b18 	vmov	r0, r1, d8
 801b302:	f00c fdd1 	bl	8027ea8 <__aeabi_dmul>
 801b306:	4602      	mov	r2, r0
 801b308:	460b      	mov	r3, r1
 801b30a:	ec51 0b1a 	vmov	r0, r1, d10
 801b30e:	f00c fc13 	bl	8027b38 <__aeabi_dsub>
 801b312:	4602      	mov	r2, r0
 801b314:	460b      	mov	r3, r1
 801b316:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801b31a:	f00c fc0f 	bl	8027b3c <__adddf3>
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801b31e:	4642      	mov	r2, r8
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801b320:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801b324:	464b      	mov	r3, r9
 801b326:	ec51 0b1b 	vmov	r0, r1, d11
 801b32a:	f00c fdbd 	bl	8027ea8 <__aeabi_dmul>
 801b32e:	4632      	mov	r2, r6
 801b330:	463b      	mov	r3, r7
 801b332:	4606      	mov	r6, r0
 801b334:	460f      	mov	r7, r1
 801b336:	ec51 0b18 	vmov	r0, r1, d8
 801b33a:	f00c fdb5 	bl	8027ea8 <__aeabi_dmul>
 801b33e:	4602      	mov	r2, r0
 801b340:	460b      	mov	r3, r1
 801b342:	4630      	mov	r0, r6
 801b344:	4639      	mov	r1, r7
 801b346:	f00c fbf9 	bl	8027b3c <__adddf3>
 801b34a:	460b      	mov	r3, r1
 801b34c:	4602      	mov	r2, r0
 801b34e:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801b352:	f00c fbf3 	bl	8027b3c <__adddf3>
 801b356:	9b01      	ldr	r3, [sp, #4]
 801b358:	441c      	add	r4, r3
        for (j = 0; j < N; j++) {
 801b35a:	9b00      	ldr	r3, [sp, #0]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801b35c:	e9ca 0102 	strd	r0, r1, [sl, #8]
        for (j = 0; j < N; j++) {
 801b360:	f10a 0a10 	add.w	sl, sl, #16
 801b364:	4553      	cmp	r3, sl
 801b366:	f10b 0b10 	add.w	fp, fp, #16
 801b36a:	d1b7      	bne.n	801b2dc <cblas_zgerc+0x37c>
 801b36c:	461d      	mov	r5, r3
      for (i = 0; i < M; i++) {
 801b36e:	9a02      	ldr	r2, [sp, #8]
 801b370:	9908      	ldr	r1, [sp, #32]
 801b372:	9b06      	ldr	r3, [sp, #24]
 801b374:	440a      	add	r2, r1
 801b376:	9904      	ldr	r1, [sp, #16]
 801b378:	9202      	str	r2, [sp, #8]
 801b37a:	9a07      	ldr	r2, [sp, #28]
 801b37c:	4608      	mov	r0, r1
 801b37e:	4410      	add	r0, r2
 801b380:	4415      	add	r5, r2
 801b382:	9a05      	ldr	r2, [sp, #20]
 801b384:	9004      	str	r0, [sp, #16]
 801b386:	3301      	adds	r3, #1
 801b388:	429a      	cmp	r2, r3
 801b38a:	9306      	str	r3, [sp, #24]
 801b38c:	f47f af6a 	bne.w	801b264 <cblas_zgerc+0x304>
 801b390:	b00b      	add	sp, #44	; 0x2c
 801b392:	ecbd 8b0c 	vpop	{d8-d13}
 801b396:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b39a:	2008      	movs	r0, #8
 801b39c:	4a1a      	ldr	r2, [pc, #104]	; (801b408 <cblas_zgerc+0x4a8>)
 801b39e:	491b      	ldr	r1, [pc, #108]	; (801b40c <cblas_zgerc+0x4ac>)
 801b3a0:	f00c fb52 	bl	8027a48 <cblas_xerbla>
 801b3a4:	e704      	b.n	801b1b0 <cblas_zgerc+0x250>
 801b3a6:	2b01      	cmp	r3, #1
 801b3a8:	4618      	mov	r0, r3
 801b3aa:	bfb8      	it	lt
 801b3ac:	2001      	movlt	r0, #1
 801b3ae:	42b0      	cmp	r0, r6
 801b3b0:	bfcc      	ite	gt
 801b3b2:	200a      	movgt	r0, #10
 801b3b4:	2006      	movle	r0, #6
 801b3b6:	e725      	b.n	801b204 <cblas_zgerc+0x2a4>
 801b3b8:	9b03      	ldr	r3, [sp, #12]
 801b3ba:	2b01      	cmp	r3, #1
 801b3bc:	bfb8      	it	lt
 801b3be:	2301      	movlt	r3, #1
 801b3c0:	42b3      	cmp	r3, r6
 801b3c2:	dd11      	ble.n	801b3e8 <cblas_zgerc+0x488>
 801b3c4:	200a      	movs	r0, #10
 801b3c6:	e71d      	b.n	801b204 <cblas_zgerc+0x2a4>
      INDEX ix = OFFSET(M, incX);
 801b3c8:	9b05      	ldr	r3, [sp, #20]
 801b3ca:	f1c3 0201 	rsb	r2, r3, #1
 801b3ce:	fb02 f205 	mul.w	r2, r2, r5
 801b3d2:	e72b      	b.n	801b22c <cblas_zgerc+0x2cc>
      INDEX jy = OFFSET(N, incY);
 801b3d4:	9b03      	ldr	r3, [sp, #12]
 801b3d6:	f1c3 0201 	rsb	r2, r3, #1
 801b3da:	fb02 f204 	mul.w	r2, r2, r4
 801b3de:	e604      	b.n	801afea <cblas_zgerc+0x8a>
  CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b3e0:	2006      	movs	r0, #6
 801b3e2:	e7db      	b.n	801b39c <cblas_zgerc+0x43c>
 801b3e4:	2006      	movs	r0, #6
 801b3e6:	e5ec      	b.n	801afc2 <cblas_zgerc+0x62>
 801b3e8:	2800      	cmp	r0, #0
 801b3ea:	f43f af0f 	beq.w	801b20c <cblas_zgerc+0x2ac>
 801b3ee:	e709      	b.n	801b204 <cblas_zgerc+0x2a4>
 801b3f0:	9b05      	ldr	r3, [sp, #20]
 801b3f2:	2b01      	cmp	r3, #1
 801b3f4:	bfb8      	it	lt
 801b3f6:	2301      	movlt	r3, #1
 801b3f8:	42b3      	cmp	r3, r6
 801b3fa:	f73f aec7 	bgt.w	801b18c <cblas_zgerc+0x22c>
 801b3fe:	2800      	cmp	r0, #0
 801b400:	f43f aed6 	beq.w	801b1b0 <cblas_zgerc+0x250>
 801b404:	e5dd      	b.n	801afc2 <cblas_zgerc+0x62>
 801b406:	bf00      	nop
 801b408:	08030378 	.word	0x08030378
 801b40c:	080306d0 	.word	0x080306d0

0801b410 <cblas_zgeru>:

void
cblas_zgeru (const enum CBLAS_ORDER order, const int M, const int N,
             const void *alpha, const void *X, const int incX, const void *Y,
             const int incY, void *A, const int lda)
{
 801b410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b414:	ed2d 8b0a 	vpush	{d8-d12}
 801b418:	b08b      	sub	sp, #44	; 0x2c
 801b41a:	469b      	mov	fp, r3
 801b41c:	1e0b      	subs	r3, r1, #0
 801b41e:	e9dd 751e 	ldrd	r7, r5, [sp, #120]	; 0x78
 801b422:	e9dd 8420 	ldrd	r8, r4, [sp, #128]	; 0x80
 801b426:	e9dd 9622 	ldrd	r9, r6, [sp, #136]	; 0x88
 801b42a:	4682      	mov	sl, r0
 801b42c:	9202      	str	r2, [sp, #8]
 801b42e:	9305      	str	r3, [sp, #20]
 801b430:	f2c0 8129 	blt.w	801b686 <cblas_zgeru+0x276>
 801b434:	3865      	subs	r0, #101	; 0x65
 801b436:	2801      	cmp	r0, #1
 801b438:	bf94      	ite	ls
 801b43a:	2000      	movls	r0, #0
 801b43c:	2001      	movhi	r0, #1
 801b43e:	9b02      	ldr	r3, [sp, #8]
 801b440:	2b00      	cmp	r3, #0
 801b442:	bfb8      	it	lt
 801b444:	2003      	movlt	r0, #3
 801b446:	2d00      	cmp	r5, #0
 801b448:	f040 80f5 	bne.w	801b636 <cblas_zgeru+0x226>
 801b44c:	2c00      	cmp	r4, #0
 801b44e:	f040 80df 	bne.w	801b610 <cblas_zgeru+0x200>
 801b452:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801b456:	f000 811f 	beq.w	801b698 <cblas_zgeru+0x288>
 801b45a:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801b45e:	f040 81f2 	bne.w	801b846 <cblas_zgeru+0x436>
 801b462:	9b05      	ldr	r3, [sp, #20]
 801b464:	2b01      	cmp	r3, #1
 801b466:	bfb8      	it	lt
 801b468:	2301      	movlt	r3, #1
 801b46a:	429e      	cmp	r6, r3
 801b46c:	f2c0 80df 	blt.w	801b62e <cblas_zgeru+0x21e>
 801b470:	2008      	movs	r0, #8
 801b472:	4a86      	ldr	r2, [pc, #536]	; (801b68c <cblas_zgeru+0x27c>)
 801b474:	4986      	ldr	r1, [pc, #536]	; (801b690 <cblas_zgeru+0x280>)
 801b476:	f00c fae7 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801b47a:	ed9b 7b00 	vldr	d7, [fp]
 801b47e:	eeb0 ba47 	vmov.f32	s22, s14
 801b482:	eef0 ba67 	vmov.f32	s23, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b486:	ed9b 7b02 	vldr	d7, [fp, #8]
 801b48a:	eeb0 ca47 	vmov.f32	s24, s14
 801b48e:	eef0 ca67 	vmov.f32	s25, s15
      INDEX jy = OFFSET(N, incY);
 801b492:	2c00      	cmp	r4, #0
 801b494:	f340 81f4 	ble.w	801b880 <cblas_zgeru+0x470>
 801b498:	2200      	movs	r2, #0
      for (j = 0; j < N; j++) {
 801b49a:	9b02      	ldr	r3, [sp, #8]
 801b49c:	2b00      	cmp	r3, #0
 801b49e:	f340 80b2 	ble.w	801b606 <cblas_zgeru+0x1f6>
 801b4a2:	9905      	ldr	r1, [sp, #20]
 801b4a4:	f8cd 9010 	str.w	r9, [sp, #16]
 801b4a8:	f1c1 0301 	rsb	r3, r1, #1
 801b4ac:	2d00      	cmp	r5, #0
 801b4ae:	fb03 f305 	mul.w	r3, r3, r5
 801b4b2:	bfc8      	it	gt
 801b4b4:	2300      	movgt	r3, #0
 801b4b6:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801b4ba:	9309      	str	r3, [sp, #36]	; 0x24
 801b4bc:	012b      	lsls	r3, r5, #4
 801b4be:	eb08 1202 	add.w	r2, r8, r2, lsl #4
 801b4c2:	9300      	str	r3, [sp, #0]
 801b4c4:	eb09 1301 	add.w	r3, r9, r1, lsl #4
 801b4c8:	0120      	lsls	r0, r4, #4
 801b4ca:	9201      	str	r2, [sp, #4]
 801b4cc:	9303      	str	r3, [sp, #12]
 801b4ce:	0132      	lsls	r2, r6, #4
        INDEX ix = OFFSET(M, incX);
 801b4d0:	2300      	movs	r3, #0
 801b4d2:	9008      	str	r0, [sp, #32]
 801b4d4:	9207      	str	r2, [sp, #28]
 801b4d6:	9306      	str	r3, [sp, #24]
        const BASE Y_real = CONST_REAL(Y, jy);
 801b4d8:	9c01      	ldr	r4, [sp, #4]
 801b4da:	e9d4 6700 	ldrd	r6, r7, [r4]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b4de:	ec53 2b1b 	vmov	r2, r3, d11
 801b4e2:	4630      	mov	r0, r6
 801b4e4:	4639      	mov	r1, r7
 801b4e6:	f00c fcdf 	bl	8027ea8 <__aeabi_dmul>
        const BASE Y_imag = CONST_IMAG(Y, jy);
 801b4ea:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b4ee:	ec5b ab1c 	vmov	sl, fp, d12
 801b4f2:	4604      	mov	r4, r0
 801b4f4:	460d      	mov	r5, r1
 801b4f6:	ee1c 2a10 	vmov	r2, s24
 801b4fa:	465b      	mov	r3, fp
 801b4fc:	4640      	mov	r0, r8
 801b4fe:	4649      	mov	r1, r9
 801b500:	f00c fcd2 	bl	8027ea8 <__aeabi_dmul>
 801b504:	4602      	mov	r2, r0
 801b506:	460b      	mov	r3, r1
 801b508:	4620      	mov	r0, r4
 801b50a:	4629      	mov	r1, r5
 801b50c:	f00c fb14 	bl	8027b38 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b510:	ee1c 2a10 	vmov	r2, s24
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b514:	4604      	mov	r4, r0
 801b516:	460d      	mov	r5, r1
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b518:	465b      	mov	r3, fp
 801b51a:	4630      	mov	r0, r6
 801b51c:	4639      	mov	r1, r7
 801b51e:	f00c fcc3 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
 801b522:	ec45 4b19 	vmov	d9, r4, r5
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b526:	ec53 2b1b 	vmov	r2, r3, d11
 801b52a:	4604      	mov	r4, r0
 801b52c:	460d      	mov	r5, r1
 801b52e:	4640      	mov	r0, r8
 801b530:	4649      	mov	r1, r9
 801b532:	f00c fcb9 	bl	8027ea8 <__aeabi_dmul>
 801b536:	460b      	mov	r3, r1
 801b538:	4602      	mov	r2, r0
 801b53a:	4629      	mov	r1, r5
 801b53c:	4620      	mov	r0, r4
 801b53e:	f00c fafd 	bl	8027b3c <__adddf3>
        for (i = 0; i < M; i++) {
 801b542:	9b05      	ldr	r3, [sp, #20]
 801b544:	2b00      	cmp	r3, #0
        const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
 801b546:	ec41 0b18 	vmov	d8, r0, r1
        for (i = 0; i < M; i++) {
 801b54a:	dd49      	ble.n	801b5e0 <cblas_zgeru+0x1d0>
 801b54c:	9b04      	ldr	r3, [sp, #16]
 801b54e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 801b550:	9d03      	ldr	r5, [sp, #12]
 801b552:	f103 0b08 	add.w	fp, r3, #8
 801b556:	469a      	mov	sl, r3
          const BASE X_real = CONST_REAL(X, ix);
 801b558:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801b55c:	ec51 0b19 	vmov	r0, r1, d9
 801b560:	4632      	mov	r2, r6
 801b562:	463b      	mov	r3, r7
 801b564:	f00c fca0 	bl	8027ea8 <__aeabi_dmul>
          const BASE X_imag = CONST_IMAG(X, ix);
 801b568:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801b56c:	ec41 0b1a 	vmov	d10, r0, r1
 801b570:	4642      	mov	r2, r8
 801b572:	464b      	mov	r3, r9
 801b574:	ec51 0b18 	vmov	r0, r1, d8
 801b578:	f00c fc96 	bl	8027ea8 <__aeabi_dmul>
 801b57c:	4602      	mov	r2, r0
 801b57e:	460b      	mov	r3, r1
 801b580:	ec51 0b1a 	vmov	r0, r1, d10
 801b584:	f00c fad8 	bl	8027b38 <__aeabi_dsub>
 801b588:	4602      	mov	r2, r0
 801b58a:	460b      	mov	r3, r1
 801b58c:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801b590:	f00c fad4 	bl	8027b3c <__adddf3>
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801b594:	4642      	mov	r2, r8
          REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
 801b596:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
 801b59a:	464b      	mov	r3, r9
 801b59c:	ec51 0b19 	vmov	r0, r1, d9
 801b5a0:	f00c fc82 	bl	8027ea8 <__aeabi_dmul>
 801b5a4:	4632      	mov	r2, r6
 801b5a6:	463b      	mov	r3, r7
 801b5a8:	4606      	mov	r6, r0
 801b5aa:	460f      	mov	r7, r1
 801b5ac:	ec51 0b18 	vmov	r0, r1, d8
 801b5b0:	f00c fc7a 	bl	8027ea8 <__aeabi_dmul>
 801b5b4:	4602      	mov	r2, r0
 801b5b6:	460b      	mov	r3, r1
 801b5b8:	4630      	mov	r0, r6
 801b5ba:	4639      	mov	r1, r7
 801b5bc:	f00c fabe 	bl	8027b3c <__adddf3>
 801b5c0:	460b      	mov	r3, r1
 801b5c2:	4602      	mov	r2, r0
 801b5c4:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801b5c8:	f00c fab8 	bl	8027b3c <__adddf3>
 801b5cc:	f10a 0a10 	add.w	sl, sl, #16
 801b5d0:	9b00      	ldr	r3, [sp, #0]
 801b5d2:	e94a 0102 	strd	r0, r1, [sl, #-8]
        for (i = 0; i < M; i++) {
 801b5d6:	4555      	cmp	r5, sl
 801b5d8:	441c      	add	r4, r3
 801b5da:	f10b 0b10 	add.w	fp, fp, #16
 801b5de:	d1bb      	bne.n	801b558 <cblas_zgeru+0x148>
      for (j = 0; j < N; j++) {
 801b5e0:	9a01      	ldr	r2, [sp, #4]
 801b5e2:	9908      	ldr	r1, [sp, #32]
 801b5e4:	9b06      	ldr	r3, [sp, #24]
 801b5e6:	440a      	add	r2, r1
 801b5e8:	9904      	ldr	r1, [sp, #16]
 801b5ea:	9201      	str	r2, [sp, #4]
 801b5ec:	4608      	mov	r0, r1
 801b5ee:	9a07      	ldr	r2, [sp, #28]
 801b5f0:	9903      	ldr	r1, [sp, #12]
 801b5f2:	4410      	add	r0, r2
 801b5f4:	4411      	add	r1, r2
 801b5f6:	9a02      	ldr	r2, [sp, #8]
 801b5f8:	9004      	str	r0, [sp, #16]
 801b5fa:	3301      	adds	r3, #1
 801b5fc:	429a      	cmp	r2, r3
 801b5fe:	9306      	str	r3, [sp, #24]
 801b600:	9103      	str	r1, [sp, #12]
 801b602:	f47f af69 	bne.w	801b4d8 <cblas_zgeru+0xc8>
#define BASE double
#include "source_geru.h"
#undef BASE
}
 801b606:	b00b      	add	sp, #44	; 0x2c
 801b608:	ecbd 8b0a 	vpop	{d8-d12}
 801b60c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b610:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801b614:	f000 811d 	beq.w	801b852 <cblas_zgeru+0x442>
 801b618:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801b61c:	f040 8136 	bne.w	801b88c <cblas_zgeru+0x47c>
 801b620:	9b05      	ldr	r3, [sp, #20]
 801b622:	2b01      	cmp	r3, #1
 801b624:	bfb8      	it	lt
 801b626:	2301      	movlt	r3, #1
 801b628:	429e      	cmp	r6, r3
 801b62a:	f280 8131 	bge.w	801b890 <cblas_zgeru+0x480>
 801b62e:	4a17      	ldr	r2, [pc, #92]	; (801b68c <cblas_zgeru+0x27c>)
 801b630:	4917      	ldr	r1, [pc, #92]	; (801b690 <cblas_zgeru+0x280>)
 801b632:	200a      	movs	r0, #10
 801b634:	e71f      	b.n	801b476 <cblas_zgeru+0x66>
 801b636:	2c00      	cmp	r4, #0
 801b638:	f43f af0b 	beq.w	801b452 <cblas_zgeru+0x42>
 801b63c:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
 801b640:	f000 8110 	beq.w	801b864 <cblas_zgeru+0x454>
 801b644:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
 801b648:	f000 8128 	beq.w	801b89c <cblas_zgeru+0x48c>
 801b64c:	2800      	cmp	r0, #0
 801b64e:	f040 80fb 	bne.w	801b848 <cblas_zgeru+0x438>
    const BASE alpha_real = CONST_REAL0(alpha);
 801b652:	ed9b 7b00 	vldr	d7, [fp]
 801b656:	eeb0 ba47 	vmov.f32	s22, s14
 801b65a:	eef0 ba67 	vmov.f32	s23, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b65e:	ed9b 7b02 	vldr	d7, [fp, #8]
    } else if (order == CblasColMajor) {
 801b662:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b666:	eeb0 ca47 	vmov.f32	s24, s14
 801b66a:	eef0 ca67 	vmov.f32	s25, s15
    } else if (order == CblasColMajor) {
 801b66e:	f43f af10 	beq.w	801b492 <cblas_zgeru+0x82>
      BLAS_ERROR("unrecognized operation");
 801b672:	4a08      	ldr	r2, [pc, #32]	; (801b694 <cblas_zgeru+0x284>)
 801b674:	4906      	ldr	r1, [pc, #24]	; (801b690 <cblas_zgeru+0x280>)
 801b676:	2000      	movs	r0, #0
 801b678:	b00b      	add	sp, #44	; 0x2c
 801b67a:	ecbd 8b0a 	vpop	{d8-d12}
 801b67e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b682:	f00c b9e1 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b686:	2002      	movs	r0, #2
 801b688:	e6d9      	b.n	801b43e <cblas_zgeru+0x2e>
 801b68a:	bf00      	nop
 801b68c:	08030378 	.word	0x08030378
 801b690:	080306e0 	.word	0x080306e0
 801b694:	080305a8 	.word	0x080305a8
 801b698:	9802      	ldr	r0, [sp, #8]
 801b69a:	2801      	cmp	r0, #1
 801b69c:	bfb8      	it	lt
 801b69e:	2001      	movlt	r0, #1
 801b6a0:	4286      	cmp	r6, r0
 801b6a2:	bfac      	ite	ge
 801b6a4:	2008      	movge	r0, #8
 801b6a6:	200a      	movlt	r0, #10
 801b6a8:	4a82      	ldr	r2, [pc, #520]	; (801b8b4 <cblas_zgeru+0x4a4>)
 801b6aa:	4983      	ldr	r1, [pc, #524]	; (801b8b8 <cblas_zgeru+0x4a8>)
 801b6ac:	f00c f9cc 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801b6b0:	ed9b 7b00 	vldr	d7, [fp]
 801b6b4:	eeb0 ca47 	vmov.f32	s24, s14
 801b6b8:	eef0 ca67 	vmov.f32	s25, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b6bc:	ed9b 7b02 	vldr	d7, [fp, #8]
      INDEX ix = OFFSET(M, incX);
 801b6c0:	2d00      	cmp	r5, #0
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b6c2:	eeb0 ba47 	vmov.f32	s22, s14
 801b6c6:	eef0 ba67 	vmov.f32	s23, s15
      INDEX ix = OFFSET(M, incX);
 801b6ca:	f340 80d3 	ble.w	801b874 <cblas_zgeru+0x464>
 801b6ce:	2200      	movs	r2, #0
      for (i = 0; i < M; i++) {
 801b6d0:	9b05      	ldr	r3, [sp, #20]
 801b6d2:	2b00      	cmp	r3, #0
 801b6d4:	dd97      	ble.n	801b606 <cblas_zgeru+0x1f6>
 801b6d6:	9902      	ldr	r1, [sp, #8]
 801b6d8:	f8cd 900c 	str.w	r9, [sp, #12]
 801b6dc:	f1c1 0301 	rsb	r3, r1, #1
 801b6e0:	2c00      	cmp	r4, #0
 801b6e2:	fb03 f304 	mul.w	r3, r3, r4
 801b6e6:	bfc8      	it	gt
 801b6e8:	2300      	movgt	r3, #0
 801b6ea:	eb08 1303 	add.w	r3, r8, r3, lsl #4
 801b6ee:	9309      	str	r3, [sp, #36]	; 0x24
 801b6f0:	0123      	lsls	r3, r4, #4
 801b6f2:	eb07 1202 	add.w	r2, r7, r2, lsl #4
 801b6f6:	9308      	str	r3, [sp, #32]
 801b6f8:	eb09 1301 	add.w	r3, r9, r1, lsl #4
 801b6fc:	0128      	lsls	r0, r5, #4
 801b6fe:	9201      	str	r2, [sp, #4]
 801b700:	9300      	str	r3, [sp, #0]
 801b702:	0132      	lsls	r2, r6, #4
        INDEX jy = OFFSET(N, incY);
 801b704:	2300      	movs	r3, #0
 801b706:	9007      	str	r0, [sp, #28]
 801b708:	9206      	str	r2, [sp, #24]
 801b70a:	9304      	str	r3, [sp, #16]
        const BASE X_real = CONST_REAL(X, ix);
 801b70c:	9c01      	ldr	r4, [sp, #4]
 801b70e:	e9d4 6700 	ldrd	r6, r7, [r4]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b712:	ec53 2b1c 	vmov	r2, r3, d12
 801b716:	4630      	mov	r0, r6
 801b718:	4639      	mov	r1, r7
 801b71a:	f00c fbc5 	bl	8027ea8 <__aeabi_dmul>
        const BASE X_imag = CONST_IMAG(X, ix);
 801b71e:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b722:	ec5b ab1b 	vmov	sl, fp, d11
 801b726:	4604      	mov	r4, r0
 801b728:	460d      	mov	r5, r1
 801b72a:	ee1b 2a10 	vmov	r2, s22
 801b72e:	465b      	mov	r3, fp
 801b730:	4640      	mov	r0, r8
 801b732:	4649      	mov	r1, r9
 801b734:	f00c fbb8 	bl	8027ea8 <__aeabi_dmul>
 801b738:	4602      	mov	r2, r0
 801b73a:	460b      	mov	r3, r1
 801b73c:	4620      	mov	r0, r4
 801b73e:	4629      	mov	r1, r5
 801b740:	f00c f9fa 	bl	8027b38 <__aeabi_dsub>
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b744:	ee1b 2a10 	vmov	r2, s22
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b748:	4604      	mov	r4, r0
 801b74a:	460d      	mov	r5, r1
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b74c:	465b      	mov	r3, fp
 801b74e:	4630      	mov	r0, r6
 801b750:	4639      	mov	r1, r7
 801b752:	f00c fba9 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
 801b756:	ec45 4b19 	vmov	d9, r4, r5
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b75a:	ec53 2b1c 	vmov	r2, r3, d12
 801b75e:	4604      	mov	r4, r0
 801b760:	460d      	mov	r5, r1
 801b762:	4640      	mov	r0, r8
 801b764:	4649      	mov	r1, r9
 801b766:	f00c fb9f 	bl	8027ea8 <__aeabi_dmul>
 801b76a:	460b      	mov	r3, r1
 801b76c:	4602      	mov	r2, r0
 801b76e:	4629      	mov	r1, r5
 801b770:	4620      	mov	r0, r4
 801b772:	f00c f9e3 	bl	8027b3c <__adddf3>
        for (j = 0; j < N; j++) {
 801b776:	9b02      	ldr	r3, [sp, #8]
 801b778:	2b00      	cmp	r3, #0
        const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
 801b77a:	ec41 0b18 	vmov	d8, r0, r1
        for (j = 0; j < N; j++) {
 801b77e:	dd4a      	ble.n	801b816 <cblas_zgeru+0x406>
 801b780:	9b03      	ldr	r3, [sp, #12]
 801b782:	f103 0b08 	add.w	fp, r3, #8
 801b786:	469a      	mov	sl, r3
 801b788:	e9dd 5308 	ldrd	r5, r3, [sp, #32]
 801b78c:	461c      	mov	r4, r3
          const BASE Y_real = CONST_REAL(Y, jy);
 801b78e:	e9d4 6700 	ldrd	r6, r7, [r4]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801b792:	ec51 0b19 	vmov	r0, r1, d9
 801b796:	4632      	mov	r2, r6
 801b798:	463b      	mov	r3, r7
 801b79a:	f00c fb85 	bl	8027ea8 <__aeabi_dmul>
          const BASE Y_imag = CONST_IMAG(Y, jy);
 801b79e:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801b7a2:	ec41 0b1a 	vmov	d10, r0, r1
 801b7a6:	4642      	mov	r2, r8
 801b7a8:	464b      	mov	r3, r9
 801b7aa:	ec51 0b18 	vmov	r0, r1, d8
 801b7ae:	f00c fb7b 	bl	8027ea8 <__aeabi_dmul>
 801b7b2:	4602      	mov	r2, r0
 801b7b4:	460b      	mov	r3, r1
 801b7b6:	ec51 0b1a 	vmov	r0, r1, d10
 801b7ba:	f00c f9bd 	bl	8027b38 <__aeabi_dsub>
 801b7be:	4602      	mov	r2, r0
 801b7c0:	460b      	mov	r3, r1
 801b7c2:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801b7c6:	f00c f9b9 	bl	8027b3c <__adddf3>
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801b7ca:	4642      	mov	r2, r8
          REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
 801b7cc:	e94b 0102 	strd	r0, r1, [fp, #-8]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801b7d0:	464b      	mov	r3, r9
 801b7d2:	ec51 0b19 	vmov	r0, r1, d9
 801b7d6:	f00c fb67 	bl	8027ea8 <__aeabi_dmul>
 801b7da:	4632      	mov	r2, r6
 801b7dc:	463b      	mov	r3, r7
 801b7de:	4606      	mov	r6, r0
 801b7e0:	460f      	mov	r7, r1
 801b7e2:	ec51 0b18 	vmov	r0, r1, d8
 801b7e6:	f00c fb5f 	bl	8027ea8 <__aeabi_dmul>
 801b7ea:	4602      	mov	r2, r0
 801b7ec:	460b      	mov	r3, r1
 801b7ee:	4630      	mov	r0, r6
 801b7f0:	4639      	mov	r1, r7
 801b7f2:	f00c f9a3 	bl	8027b3c <__adddf3>
 801b7f6:	460b      	mov	r3, r1
 801b7f8:	4602      	mov	r2, r0
 801b7fa:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801b7fe:	f00c f99d 	bl	8027b3c <__adddf3>
        for (j = 0; j < N; j++) {
 801b802:	9b00      	ldr	r3, [sp, #0]
          IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
 801b804:	e9ca 0102 	strd	r0, r1, [sl, #8]
        for (j = 0; j < N; j++) {
 801b808:	f10a 0a10 	add.w	sl, sl, #16
 801b80c:	4553      	cmp	r3, sl
 801b80e:	442c      	add	r4, r5
 801b810:	f10b 0b10 	add.w	fp, fp, #16
 801b814:	d1bb      	bne.n	801b78e <cblas_zgeru+0x37e>
      for (i = 0; i < M; i++) {
 801b816:	9a01      	ldr	r2, [sp, #4]
 801b818:	9907      	ldr	r1, [sp, #28]
 801b81a:	9b04      	ldr	r3, [sp, #16]
 801b81c:	440a      	add	r2, r1
 801b81e:	9903      	ldr	r1, [sp, #12]
 801b820:	9201      	str	r2, [sp, #4]
 801b822:	4608      	mov	r0, r1
 801b824:	9a06      	ldr	r2, [sp, #24]
 801b826:	9900      	ldr	r1, [sp, #0]
 801b828:	4410      	add	r0, r2
 801b82a:	4411      	add	r1, r2
 801b82c:	9a05      	ldr	r2, [sp, #20]
 801b82e:	9003      	str	r0, [sp, #12]
 801b830:	3301      	adds	r3, #1
 801b832:	429a      	cmp	r2, r3
 801b834:	9304      	str	r3, [sp, #16]
 801b836:	9100      	str	r1, [sp, #0]
 801b838:	f47f af68 	bne.w	801b70c <cblas_zgeru+0x2fc>
 801b83c:	b00b      	add	sp, #44	; 0x2c
 801b83e:	ecbd 8b0a 	vpop	{d8-d12}
 801b842:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b846:	2008      	movs	r0, #8
 801b848:	4a1a      	ldr	r2, [pc, #104]	; (801b8b4 <cblas_zgeru+0x4a4>)
 801b84a:	491b      	ldr	r1, [pc, #108]	; (801b8b8 <cblas_zgeru+0x4a8>)
 801b84c:	f00c f8fc 	bl	8027a48 <cblas_xerbla>
 801b850:	e6ff      	b.n	801b652 <cblas_zgeru+0x242>
 801b852:	2b01      	cmp	r3, #1
 801b854:	4618      	mov	r0, r3
 801b856:	bfb8      	it	lt
 801b858:	2001      	movlt	r0, #1
 801b85a:	42b0      	cmp	r0, r6
 801b85c:	bfcc      	ite	gt
 801b85e:	200a      	movgt	r0, #10
 801b860:	2006      	movle	r0, #6
 801b862:	e721      	b.n	801b6a8 <cblas_zgeru+0x298>
 801b864:	9b02      	ldr	r3, [sp, #8]
 801b866:	2b01      	cmp	r3, #1
 801b868:	bfb8      	it	lt
 801b86a:	2301      	movlt	r3, #1
 801b86c:	42b3      	cmp	r3, r6
 801b86e:	dd11      	ble.n	801b894 <cblas_zgeru+0x484>
 801b870:	200a      	movs	r0, #10
 801b872:	e719      	b.n	801b6a8 <cblas_zgeru+0x298>
      INDEX ix = OFFSET(M, incX);
 801b874:	9b05      	ldr	r3, [sp, #20]
 801b876:	f1c3 0201 	rsb	r2, r3, #1
 801b87a:	fb02 f205 	mul.w	r2, r2, r5
 801b87e:	e727      	b.n	801b6d0 <cblas_zgeru+0x2c0>
      INDEX jy = OFFSET(N, incY);
 801b880:	9b02      	ldr	r3, [sp, #8]
 801b882:	f1c3 0201 	rsb	r2, r3, #1
 801b886:	fb02 f204 	mul.w	r2, r2, r4
 801b88a:	e606      	b.n	801b49a <cblas_zgeru+0x8a>
  CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
 801b88c:	2006      	movs	r0, #6
 801b88e:	e7db      	b.n	801b848 <cblas_zgeru+0x438>
 801b890:	2006      	movs	r0, #6
 801b892:	e5ee      	b.n	801b472 <cblas_zgeru+0x62>
 801b894:	2800      	cmp	r0, #0
 801b896:	f43f af0b 	beq.w	801b6b0 <cblas_zgeru+0x2a0>
 801b89a:	e705      	b.n	801b6a8 <cblas_zgeru+0x298>
 801b89c:	9b05      	ldr	r3, [sp, #20]
 801b89e:	2b01      	cmp	r3, #1
 801b8a0:	bfb8      	it	lt
 801b8a2:	2301      	movlt	r3, #1
 801b8a4:	42b3      	cmp	r3, r6
 801b8a6:	f73f aec2 	bgt.w	801b62e <cblas_zgeru+0x21e>
 801b8aa:	2800      	cmp	r0, #0
 801b8ac:	f43f aed1 	beq.w	801b652 <cblas_zgeru+0x242>
 801b8b0:	e5df      	b.n	801b472 <cblas_zgeru+0x62>
 801b8b2:	bf00      	nop
 801b8b4:	08030378 	.word	0x08030378
 801b8b8:	080306e0 	.word	0x080306e0
 801b8bc:	00000000 	.word	0x00000000

0801b8c0 <cblas_zhemm>:
void
cblas_zhemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 801b8c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b8c4:	ed2d 8b10 	vpush	{d8-d15}
 801b8c8:	b0a1      	sub	sp, #132	; 0x84
 801b8ca:	298d      	cmp	r1, #141	; 0x8d
 801b8cc:	930d      	str	r3, [sp, #52]	; 0x34
 801b8ce:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801b8d0:	930e      	str	r3, [sp, #56]	; 0x38
 801b8d2:	e9dd 733b 	ldrd	r7, r3, [sp, #236]	; 0xec
 801b8d6:	9313      	str	r3, [sp, #76]	; 0x4c
 801b8d8:	9b3d      	ldr	r3, [sp, #244]	; 0xf4
 801b8da:	9312      	str	r3, [sp, #72]	; 0x48
 801b8dc:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 801b8de:	9315      	str	r3, [sp, #84]	; 0x54
 801b8e0:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
 801b8e2:	9318      	str	r3, [sp, #96]	; 0x60
 801b8e4:	e9dd 6340 	ldrd	r6, r3, [sp, #256]	; 0x100
 801b8e8:	9314      	str	r3, [sp, #80]	; 0x50
 801b8ea:	9b42      	ldr	r3, [sp, #264]	; 0x108
 801b8ec:	9317      	str	r3, [sp, #92]	; 0x5c
 801b8ee:	460d      	mov	r5, r1
 801b8f0:	4604      	mov	r4, r0
 801b8f2:	4690      	mov	r8, r2
 801b8f4:	f000 8134 	beq.w	801bb60 <cblas_zhemm+0x2a0>
 801b8f8:	298e      	cmp	r1, #142	; 0x8e
 801b8fa:	f001 8056 	beq.w	801c9aa <cblas_zhemm+0x10ea>
 801b8fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801b900:	2002      	movs	r0, #2
 801b902:	f1a8 0279 	sub.w	r2, r8, #121	; 0x79
 801b906:	2a01      	cmp	r2, #1
 801b908:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801b90a:	bf88      	it	hi
 801b90c:	2003      	movhi	r0, #3
 801b90e:	2a00      	cmp	r2, #0
 801b910:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801b912:	bfb8      	it	lt
 801b914:	2004      	movlt	r0, #4
 801b916:	2b01      	cmp	r3, #1
 801b918:	bfb8      	it	lt
 801b91a:	2301      	movlt	r3, #1
 801b91c:	2a00      	cmp	r2, #0
 801b91e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801b920:	f2c0 8113 	blt.w	801bb4a <cblas_zhemm+0x28a>
 801b924:	4293      	cmp	r3, r2
 801b926:	f340 808b 	ble.w	801ba40 <cblas_zhemm+0x180>
 801b92a:	2c65      	cmp	r4, #101	; 0x65
 801b92c:	f000 847e 	beq.w	801c22c <cblas_zhemm+0x96c>
 801b930:	2c66      	cmp	r4, #102	; 0x66
 801b932:	f001 8029 	beq.w	801c988 <cblas_zhemm+0x10c8>
 801b936:	2008      	movs	r0, #8
 801b938:	4a91      	ldr	r2, [pc, #580]	; (801bb80 <cblas_zhemm+0x2c0>)
 801b93a:	4992      	ldr	r1, [pc, #584]	; (801bb84 <cblas_zhemm+0x2c4>)
 801b93c:	f00c f884 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801b940:	ed97 7b00 	vldr	d7, [r7]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801b944:	2200      	movs	r2, #0
 801b946:	ec51 0b17 	vmov	r0, r1, d7
 801b94a:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 801b94c:	ed8d 7b08 	vstr	d7, [sp, #32]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801b950:	f00c fd12 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b954:	ed97 7b02 	vldr	d7, [r7, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801b958:	e9d6 ab00 	ldrd	sl, fp, [r6]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801b95c:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
    const BASE beta_imag = CONST_IMAG0(beta);
 801b960:	ed96 8b02 	vldr	d8, [r6, #8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801b964:	b170      	cbz	r0, 801b984 <cblas_zhemm+0xc4>
 801b966:	ec51 0b17 	vmov	r0, r1, d7
 801b96a:	2200      	movs	r2, #0
 801b96c:	2300      	movs	r3, #0
 801b96e:	f00c fd03 	bl	8028378 <__aeabi_dcmpeq>
 801b972:	b138      	cbz	r0, 801b984 <cblas_zhemm+0xc4>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801b974:	4b84      	ldr	r3, [pc, #528]	; (801bb88 <cblas_zhemm+0x2c8>)
 801b976:	2200      	movs	r2, #0
 801b978:	4650      	mov	r0, sl
 801b97a:	4659      	mov	r1, fp
 801b97c:	f00c fcfc 	bl	8028378 <__aeabi_dcmpeq>
 801b980:	2800      	cmp	r0, #0
 801b982:	d167      	bne.n	801ba54 <cblas_zhemm+0x194>
    if (Order == CblasRowMajor) {
 801b984:	2c65      	cmp	r4, #101	; 0x65
 801b986:	f000 80f2 	beq.w	801bb6e <cblas_zhemm+0x2ae>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801b98a:	f1b8 0f79 	cmp.w	r8, #121	; 0x79
 801b98e:	bf0c      	ite	eq
 801b990:	237a      	moveq	r3, #122	; 0x7a
 801b992:	2379      	movne	r3, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 801b994:	2d8d      	cmp	r5, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801b996:	931a      	str	r3, [sp, #104]	; 0x68
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 801b998:	bf0c      	ite	eq
 801b99a:	238e      	moveq	r3, #142	; 0x8e
 801b99c:	238d      	movne	r3, #141	; 0x8d
 801b99e:	9319      	str	r3, [sp, #100]	; 0x64
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801b9a0:	2200      	movs	r2, #0
 801b9a2:	2300      	movs	r3, #0
 801b9a4:	4650      	mov	r0, sl
 801b9a6:	4659      	mov	r1, fp
 801b9a8:	f00c fce6 	bl	8028378 <__aeabi_dcmpeq>
 801b9ac:	2200      	movs	r2, #0
 801b9ae:	2800      	cmp	r0, #0
 801b9b0:	d05d      	beq.n	801ba6e <cblas_zhemm+0x1ae>
 801b9b2:	ec51 0b18 	vmov	r0, r1, d8
 801b9b6:	2300      	movs	r3, #0
 801b9b8:	f00c fcde 	bl	8028378 <__aeabi_dcmpeq>
 801b9bc:	2800      	cmp	r0, #0
 801b9be:	d064      	beq.n	801ba8a <cblas_zhemm+0x1ca>
      for (i = 0; i < n1; i++) {
 801b9c0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801b9c2:	2b00      	cmp	r3, #0
 801b9c4:	dd1c      	ble.n	801ba00 <cblas_zhemm+0x140>
 801b9c6:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801b9c8:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 801b9ca:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
 801b9ce:	0114      	lsls	r4, r2, #4
 801b9d0:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801b9d2:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 801b9d6:	0100      	lsls	r0, r0, #4
 801b9d8:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 801b9dc:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 801b9de:	2600      	movs	r6, #0
 801b9e0:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 801b9e2:	2d00      	cmp	r5, #0
 801b9e4:	bfc8      	it	gt
 801b9e6:	1883      	addgt	r3, r0, r2
 801b9e8:	dd06      	ble.n	801b9f8 <cblas_zhemm+0x138>
          REAL(C, ldc * i + j) = 0.0;
 801b9ea:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 801b9ee:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 801b9f2:	3310      	adds	r3, #16
 801b9f4:	429a      	cmp	r2, r3
 801b9f6:	d1f8      	bne.n	801b9ea <cblas_zhemm+0x12a>
      for (i = 0; i < n1; i++) {
 801b9f8:	3101      	adds	r1, #1
 801b9fa:	458c      	cmp	ip, r1
 801b9fc:	4422      	add	r2, r4
 801b9fe:	d1f0      	bne.n	801b9e2 <cblas_zhemm+0x122>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801ba00:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801ba04:	2200      	movs	r2, #0
 801ba06:	2300      	movs	r3, #0
 801ba08:	f00c fcb6 	bl	8028378 <__aeabi_dcmpeq>
 801ba0c:	b130      	cbz	r0, 801ba1c <cblas_zhemm+0x15c>
 801ba0e:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801ba12:	2200      	movs	r2, #0
 801ba14:	2300      	movs	r3, #0
 801ba16:	f00c fcaf 	bl	8028378 <__aeabi_dcmpeq>
 801ba1a:	bb18      	cbnz	r0, 801ba64 <cblas_zhemm+0x1a4>
    if (side == CblasLeft && uplo == CblasUpper) {
 801ba1c:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801ba1e:	2b8d      	cmp	r3, #141	; 0x8d
 801ba20:	f000 80b6 	beq.w	801bb90 <cblas_zhemm+0x2d0>
    } else if (side == CblasRight && uplo == CblasUpper) {
 801ba24:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801ba26:	2b8e      	cmp	r3, #142	; 0x8e
 801ba28:	f000 824a 	beq.w	801bec0 <cblas_zhemm+0x600>
      BLAS_ERROR("unrecognized operation");
 801ba2c:	4a57      	ldr	r2, [pc, #348]	; (801bb8c <cblas_zhemm+0x2cc>)
 801ba2e:	4955      	ldr	r1, [pc, #340]	; (801bb84 <cblas_zhemm+0x2c4>)
 801ba30:	2000      	movs	r0, #0
#define BASE double
#include "source_hemm.h"
#undef BASE
}
 801ba32:	b021      	add	sp, #132	; 0x84
 801ba34:	ecbd 8b10 	vpop	{d8-d15}
 801ba38:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ba3c:	f00c b804 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801ba40:	2c65      	cmp	r4, #101	; 0x65
 801ba42:	f000 8402 	beq.w	801c24a <cblas_zhemm+0x98a>
 801ba46:	2c66      	cmp	r4, #102	; 0x66
 801ba48:	f000 8746 	beq.w	801c8d8 <cblas_zhemm+0x1018>
 801ba4c:	2800      	cmp	r0, #0
 801ba4e:	f43f af77 	beq.w	801b940 <cblas_zhemm+0x80>
 801ba52:	e771      	b.n	801b938 <cblas_zhemm+0x78>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801ba54:	ec51 0b18 	vmov	r0, r1, d8
 801ba58:	2200      	movs	r2, #0
 801ba5a:	2300      	movs	r3, #0
 801ba5c:	f00c fc8c 	bl	8028378 <__aeabi_dcmpeq>
 801ba60:	2800      	cmp	r0, #0
 801ba62:	d08f      	beq.n	801b984 <cblas_zhemm+0xc4>
 801ba64:	b021      	add	sp, #132	; 0x84
 801ba66:	ecbd 8b10 	vpop	{d8-d15}
 801ba6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801ba6e:	4b46      	ldr	r3, [pc, #280]	; (801bb88 <cblas_zhemm+0x2c8>)
 801ba70:	4650      	mov	r0, sl
 801ba72:	4659      	mov	r1, fp
 801ba74:	f00c fc80 	bl	8028378 <__aeabi_dcmpeq>
 801ba78:	b138      	cbz	r0, 801ba8a <cblas_zhemm+0x1ca>
 801ba7a:	ec51 0b18 	vmov	r0, r1, d8
 801ba7e:	2200      	movs	r2, #0
 801ba80:	2300      	movs	r3, #0
 801ba82:	f00c fc79 	bl	8028378 <__aeabi_dcmpeq>
 801ba86:	2800      	cmp	r0, #0
 801ba88:	d1ba      	bne.n	801ba00 <cblas_zhemm+0x140>
      for (i = 0; i < n1; i++) {
 801ba8a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801ba8c:	2b00      	cmp	r3, #0
 801ba8e:	ddb7      	ble.n	801ba00 <cblas_zhemm+0x140>
 801ba90:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801ba92:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 801ba96:	011b      	lsls	r3, r3, #4
 801ba98:	9311      	str	r3, [sp, #68]	; 0x44
 801ba9a:	3308      	adds	r3, #8
 801ba9c:	9316      	str	r3, [sp, #88]	; 0x58
 801ba9e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801baa0:	011b      	lsls	r3, r3, #4
 801baa2:	9310      	str	r3, [sp, #64]	; 0x40
 801baa4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801baa6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801baaa:	930c      	str	r3, [sp, #48]	; 0x30
 801baac:	2300      	movs	r3, #0
 801baae:	930f      	str	r3, [sp, #60]	; 0x3c
        for (j = 0; j < n2; j++) {
 801bab0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801bab2:	2b00      	cmp	r3, #0
 801bab4:	dd3e      	ble.n	801bb34 <cblas_zhemm+0x274>
 801bab6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801bab8:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801baba:	4619      	mov	r1, r3
 801babc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801babe:	eb01 0803 	add.w	r8, r1, r3
 801bac2:	eb02 0903 	add.w	r9, r2, r3
          const BASE Cij_real = REAL(C, ldc * i + j);
 801bac6:	e959 4502 	ldrd	r4, r5, [r9, #-8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801baca:	4650      	mov	r0, sl
 801bacc:	4622      	mov	r2, r4
 801bace:	462b      	mov	r3, r5
 801bad0:	4659      	mov	r1, fp
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 801bad2:	e9d8 6702 	ldrd	r6, r7, [r8, #8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801bad6:	f00c f9e7 	bl	8027ea8 <__aeabi_dmul>
 801bada:	4632      	mov	r2, r6
 801badc:	ec41 0b19 	vmov	d9, r0, r1
 801bae0:	463b      	mov	r3, r7
 801bae2:	ec51 0b18 	vmov	r0, r1, d8
 801bae6:	f00c f9df 	bl	8027ea8 <__aeabi_dmul>
 801baea:	4602      	mov	r2, r0
 801baec:	460b      	mov	r3, r1
 801baee:	ec51 0b19 	vmov	r0, r1, d9
 801baf2:	f00c f821 	bl	8027b38 <__aeabi_dsub>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801baf6:	4632      	mov	r2, r6
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 801baf8:	e949 0102 	strd	r0, r1, [r9, #-8]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801bafc:	463b      	mov	r3, r7
 801bafe:	4650      	mov	r0, sl
 801bb00:	4659      	mov	r1, fp
 801bb02:	f00c f9d1 	bl	8027ea8 <__aeabi_dmul>
 801bb06:	4622      	mov	r2, r4
 801bb08:	462b      	mov	r3, r5
 801bb0a:	4604      	mov	r4, r0
 801bb0c:	460d      	mov	r5, r1
 801bb0e:	ec51 0b18 	vmov	r0, r1, d8
 801bb12:	f00c f9c9 	bl	8027ea8 <__aeabi_dmul>
 801bb16:	460b      	mov	r3, r1
 801bb18:	4602      	mov	r2, r0
 801bb1a:	4629      	mov	r1, r5
 801bb1c:	4620      	mov	r0, r4
 801bb1e:	f00c f80d 	bl	8027b3c <__adddf3>
        for (j = 0; j < n2; j++) {
 801bb22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 801bb24:	e9c8 0102 	strd	r0, r1, [r8, #8]
        for (j = 0; j < n2; j++) {
 801bb28:	f108 0810 	add.w	r8, r8, #16
 801bb2c:	4598      	cmp	r8, r3
 801bb2e:	f109 0910 	add.w	r9, r9, #16
 801bb32:	d1c8      	bne.n	801bac6 <cblas_zhemm+0x206>
      for (i = 0; i < n1; i++) {
 801bb34:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801bb36:	9910      	ldr	r1, [sp, #64]	; 0x40
 801bb38:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801bb3a:	440a      	add	r2, r1
 801bb3c:	920c      	str	r2, [sp, #48]	; 0x30
 801bb3e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801bb40:	3301      	adds	r3, #1
 801bb42:	429a      	cmp	r2, r3
 801bb44:	930f      	str	r3, [sp, #60]	; 0x3c
 801bb46:	d1b3      	bne.n	801bab0 <cblas_zhemm+0x1f0>
 801bb48:	e75a      	b.n	801ba00 <cblas_zhemm+0x140>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801bb4a:	429a      	cmp	r2, r3
 801bb4c:	f6ff aeed 	blt.w	801b92a <cblas_zhemm+0x6a>
 801bb50:	2c65      	cmp	r4, #101	; 0x65
 801bb52:	f000 86b6 	beq.w	801c8c2 <cblas_zhemm+0x1002>
 801bb56:	2c66      	cmp	r4, #102	; 0x66
 801bb58:	f000 8736 	beq.w	801c9c8 <cblas_zhemm+0x1108>
 801bb5c:	2005      	movs	r0, #5
 801bb5e:	e6eb      	b.n	801b938 <cblas_zhemm+0x78>
 801bb60:	3865      	subs	r0, #101	; 0x65
 801bb62:	2801      	cmp	r0, #1
 801bb64:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801bb66:	bf94      	ite	ls
 801bb68:	2000      	movls	r0, #0
 801bb6a:	2001      	movhi	r0, #1
 801bb6c:	e6c9      	b.n	801b902 <cblas_zhemm+0x42>
      uplo = Uplo;
 801bb6e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801bb70:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801bb72:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
      side = Side;
 801bb76:	920e      	str	r2, [sp, #56]	; 0x38
 801bb78:	9519      	str	r5, [sp, #100]	; 0x64
 801bb7a:	930d      	str	r3, [sp, #52]	; 0x34
 801bb7c:	e710      	b.n	801b9a0 <cblas_zhemm+0xe0>
 801bb7e:	bf00      	nop
 801bb80:	08030378 	.word	0x08030378
 801bb84:	080306f0 	.word	0x080306f0
 801bb88:	3ff00000 	.word	0x3ff00000
 801bb8c:	080305a8 	.word	0x080305a8
    if (side == CblasLeft && uplo == CblasUpper) {
 801bb90:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801bb92:	2b79      	cmp	r3, #121	; 0x79
 801bb94:	f000 8368 	beq.w	801c268 <cblas_zhemm+0x9a8>
    } else if (side == CblasLeft && uplo == CblasLower) {
 801bb98:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801bb9a:	2b7a      	cmp	r3, #122	; 0x7a
 801bb9c:	f47f af46 	bne.w	801ba2c <cblas_zhemm+0x16c>
      for (i = 0; i < n1; i++) {
 801bba0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801bba2:	2b00      	cmp	r3, #0
 801bba4:	f77f af5e 	ble.w	801ba64 <cblas_zhemm+0x1a4>
 801bba8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801bbaa:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801bbac:	9100      	str	r1, [sp, #0]
 801bbae:	3301      	adds	r3, #1
 801bbb0:	011a      	lsls	r2, r3, #4
 801bbb2:	921b      	str	r2, [sp, #108]	; 0x6c
 801bbb4:	2300      	movs	r3, #0
 801bbb6:	3a10      	subs	r2, #16
 801bbb8:	e9cd 3219 	strd	r3, r2, [sp, #100]	; 0x64
 801bbbc:	9316      	str	r3, [sp, #88]	; 0x58
 801bbbe:	9312      	str	r3, [sp, #72]	; 0x48
 801bbc0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801bbc2:	011b      	lsls	r3, r3, #4
 801bbc4:	9306      	str	r3, [sp, #24]
 801bbc6:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801bbc8:	011b      	lsls	r3, r3, #4
 801bbca:	9302      	str	r3, [sp, #8]
 801bbcc:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801bbce:	3308      	adds	r3, #8
 801bbd0:	931c      	str	r3, [sp, #112]	; 0x70
 801bbd2:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801bbd4:	3308      	adds	r3, #8
 801bbd6:	931d      	str	r3, [sp, #116]	; 0x74
        for (j = 0; j < n2; j++) {
 801bbd8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801bbda:	2b00      	cmp	r3, #0
 801bbdc:	f340 8153 	ble.w	801be86 <cblas_zhemm+0x5c6>
 801bbe0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801bbe2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801bbe4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801bbe8:	930f      	str	r3, [sp, #60]	; 0x3c
 801bbea:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801bbec:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801bbee:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801bbf2:	930c      	str	r3, [sp, #48]	; 0x30
 801bbf4:	2208      	movs	r2, #8
 801bbf6:	2300      	movs	r3, #0
 801bbf8:	e9cd 3210 	strd	r3, r2, [sp, #64]	; 0x40
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801bbfc:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bbfe:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801bc02:	e954 6702 	ldrd	r6, r7, [r4, #-8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bc06:	ec51 0b18 	vmov	r0, r1, d8
 801bc0a:	4632      	mov	r2, r6
 801bc0c:	463b      	mov	r3, r7
 801bc0e:	f00c f94b 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801bc12:	e9d4 8900 	ldrd	r8, r9, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bc16:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801bc1a:	4604      	mov	r4, r0
 801bc1c:	460d      	mov	r5, r1
 801bc1e:	4642      	mov	r2, r8
 801bc20:	464b      	mov	r3, r9
 801bc22:	4650      	mov	r0, sl
 801bc24:	4659      	mov	r1, fp
 801bc26:	f00c f93f 	bl	8027ea8 <__aeabi_dmul>
 801bc2a:	4602      	mov	r2, r0
 801bc2c:	460b      	mov	r3, r1
 801bc2e:	4620      	mov	r0, r4
 801bc30:	4629      	mov	r1, r5
 801bc32:	f00b ff81 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bc36:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bc38:	4604      	mov	r4, r0
 801bc3a:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bc3c:	464b      	mov	r3, r9
 801bc3e:	ec51 0b18 	vmov	r0, r1, d8
 801bc42:	f00c f931 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bc46:	ec45 4b1e 	vmov	d14, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bc4a:	4632      	mov	r2, r6
 801bc4c:	463b      	mov	r3, r7
 801bc4e:	4604      	mov	r4, r0
 801bc50:	460d      	mov	r5, r1
 801bc52:	4650      	mov	r0, sl
 801bc54:	4659      	mov	r1, fp
 801bc56:	f00c f927 	bl	8027ea8 <__aeabi_dmul>
 801bc5a:	460b      	mov	r3, r1
 801bc5c:	4602      	mov	r2, r0
 801bc5e:	4629      	mov	r1, r5
 801bc60:	4620      	mov	r0, r4
 801bc62:	f00b ff6b 	bl	8027b3c <__adddf3>
          BASE temp2_imag = 0.0;
 801bc66:	ed9f 7b94 	vldr	d7, [pc, #592]	; 801beb8 <cblas_zhemm+0x5f8>
          for (k = 0; k < i; k++) {
 801bc6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
          BASE temp2_imag = 0.0;
 801bc6c:	eeb0 da47 	vmov.f32	s26, s14
 801bc70:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bc74:	ec41 0b1f 	vmov	d15, r0, r1
          BASE temp2_real = 0.0;
 801bc78:	eeb0 ca47 	vmov.f32	s24, s14
 801bc7c:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < i; k++) {
 801bc80:	2b00      	cmp	r3, #0
 801bc82:	f000 809a 	beq.w	801bdba <cblas_zhemm+0x4fa>
 801bc86:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801bc88:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801bc8a:	9910      	ldr	r1, [sp, #64]	; 0x40
 801bc8c:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
 801bc90:	4610      	mov	r0, r2
 801bc92:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801bc94:	eb03 1a01 	add.w	sl, r3, r1, lsl #4
 801bc98:	eb00 0902 	add.w	r9, r0, r2
 801bc9c:	eb03 0802 	add.w	r8, r3, r2
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801bca0:	e9db 4500 	ldrd	r4, r5, [fp]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801bca4:	ec51 0b1e 	vmov	r0, r1, d14
 801bca8:	4622      	mov	r2, r4
 801bcaa:	462b      	mov	r3, r5
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801bcac:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801bcb0:	f00c f8fa 	bl	8027ea8 <__aeabi_dmul>
 801bcb4:	4632      	mov	r2, r6
 801bcb6:	ec41 0b18 	vmov	d8, r0, r1
 801bcba:	463b      	mov	r3, r7
 801bcbc:	ec51 0b1f 	vmov	r0, r1, d15
 801bcc0:	f00c f8f2 	bl	8027ea8 <__aeabi_dmul>
 801bcc4:	4602      	mov	r2, r0
 801bcc6:	460b      	mov	r3, r1
 801bcc8:	ec51 0b18 	vmov	r0, r1, d8
 801bccc:	f00b ff36 	bl	8027b3c <__adddf3>
 801bcd0:	4602      	mov	r2, r0
 801bcd2:	460b      	mov	r3, r1
 801bcd4:	e958 0102 	ldrd	r0, r1, [r8, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801bcd8:	9604      	str	r6, [sp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801bcda:	f00b ff2f 	bl	8027b3c <__adddf3>
 801bcde:	460b      	mov	r3, r1
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801bce0:	f107 4100 	add.w	r1, r7, #2147483648	; 0x80000000
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801bce4:	4602      	mov	r2, r0
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801bce6:	9105      	str	r1, [sp, #20]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 801bce8:	ed19 8b02 	vldr	d8, [r9, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 801bcec:	ed99 9b00 	vldr	d9, [r9]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801bcf0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801bcf4:	e948 2302 	strd	r2, r3, [r8, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801bcf8:	ec53 2b1e 	vmov	r2, r3, d14
 801bcfc:	f00c f8d4 	bl	8027ea8 <__aeabi_dmul>
 801bd00:	4622      	mov	r2, r4
 801bd02:	462b      	mov	r3, r5
 801bd04:	ec41 0b1b 	vmov	d11, r0, r1
 801bd08:	ec51 0b1f 	vmov	r0, r1, d15
 801bd0c:	f00c f8cc 	bl	8027ea8 <__aeabi_dmul>
 801bd10:	4602      	mov	r2, r0
 801bd12:	460b      	mov	r3, r1
 801bd14:	ec51 0b1b 	vmov	r0, r1, d11
 801bd18:	f00b ff10 	bl	8027b3c <__adddf3>
 801bd1c:	4602      	mov	r2, r0
 801bd1e:	460b      	mov	r3, r1
 801bd20:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801bd24:	f00b ff0a 	bl	8027b3c <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801bd28:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801bd2c:	e9ca 0102 	strd	r0, r1, [sl, #8]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801bd30:	4620      	mov	r0, r4
 801bd32:	4629      	mov	r1, r5
 801bd34:	f00c f8b8 	bl	8027ea8 <__aeabi_dmul>
 801bd38:	ec53 2b19 	vmov	r2, r3, d9
 801bd3c:	ec41 0b1a 	vmov	d10, r0, r1
 801bd40:	4630      	mov	r0, r6
 801bd42:	4639      	mov	r1, r7
 801bd44:	f00c f8b0 	bl	8027ea8 <__aeabi_dmul>
 801bd48:	4602      	mov	r2, r0
 801bd4a:	460b      	mov	r3, r1
 801bd4c:	ec51 0b1a 	vmov	r0, r1, d10
 801bd50:	f00b fef2 	bl	8027b38 <__aeabi_dsub>
 801bd54:	4602      	mov	r2, r0
 801bd56:	460b      	mov	r3, r1
 801bd58:	ec51 0b1c 	vmov	r0, r1, d12
 801bd5c:	f00b feee 	bl	8027b3c <__adddf3>
 801bd60:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801bd64:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801bd68:	eeb0 ca47 	vmov.f32	s24, s14
 801bd6c:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801bd70:	4620      	mov	r0, r4
 801bd72:	4629      	mov	r1, r5
 801bd74:	f00c f898 	bl	8027ea8 <__aeabi_dmul>
 801bd78:	ec53 2b18 	vmov	r2, r3, d8
 801bd7c:	4604      	mov	r4, r0
 801bd7e:	460d      	mov	r5, r1
 801bd80:	4630      	mov	r0, r6
 801bd82:	4639      	mov	r1, r7
 801bd84:	f00c f890 	bl	8027ea8 <__aeabi_dmul>
 801bd88:	4602      	mov	r2, r0
 801bd8a:	460b      	mov	r3, r1
 801bd8c:	4620      	mov	r0, r4
 801bd8e:	4629      	mov	r1, r5
 801bd90:	f00b fed4 	bl	8027b3c <__adddf3>
 801bd94:	460b      	mov	r3, r1
 801bd96:	4602      	mov	r2, r0
 801bd98:	ec51 0b1d 	vmov	r0, r1, d13
 801bd9c:	f00b fece 	bl	8027b3c <__adddf3>
 801bda0:	9b02      	ldr	r3, [sp, #8]
 801bda2:	4499      	add	r9, r3
 801bda4:	9b06      	ldr	r3, [sp, #24]
 801bda6:	4498      	add	r8, r3
 801bda8:	449a      	add	sl, r3
          for (k = 0; k < i; k++) {
 801bdaa:	9b00      	ldr	r3, [sp, #0]
 801bdac:	f10b 0b10 	add.w	fp, fp, #16
 801bdb0:	455b      	cmp	r3, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801bdb2:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < i; k++) {
 801bdb6:	f47f af73 	bne.w	801bca0 <cblas_zhemm+0x3e0>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 801bdba:	9b00      	ldr	r3, [sp, #0]
 801bdbc:	e9d3 4500 	ldrd	r4, r5, [r3]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801bdc0:	ec51 0b1f 	vmov	r0, r1, d15
 801bdc4:	4622      	mov	r2, r4
 801bdc6:	462b      	mov	r3, r5
 801bdc8:	f00c f86e 	bl	8027ea8 <__aeabi_dmul>
 801bdcc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801bdce:	e9d6 2300 	ldrd	r2, r3, [r6]
 801bdd2:	f00b feb3 	bl	8027b3c <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801bdd6:	4622      	mov	r2, r4
 801bdd8:	462b      	mov	r3, r5
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801bdda:	4680      	mov	r8, r0
 801bddc:	4689      	mov	r9, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801bdde:	ec51 0b1e 	vmov	r0, r1, d14
 801bde2:	f00c f861 	bl	8027ea8 <__aeabi_dmul>
 801bde6:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 801bdea:	960c      	str	r6, [sp, #48]	; 0x30
 801bdec:	f00b fea6 	bl	8027b3c <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801bdf0:	ed9d 9b08 	vldr	d9, [sp, #32]
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801bdf4:	4604      	mov	r4, r0
 801bdf6:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801bdf8:	ec53 2b1c 	vmov	r2, r3, d12
 801bdfc:	ec51 0b19 	vmov	r0, r1, d9
 801be00:	f00c f852 	bl	8027ea8 <__aeabi_dmul>
 801be04:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801be08:	ec53 2b1d 	vmov	r2, r3, d13
 801be0c:	4606      	mov	r6, r0
 801be0e:	460f      	mov	r7, r1
 801be10:	4650      	mov	r0, sl
 801be12:	4659      	mov	r1, fp
 801be14:	f00c f848 	bl	8027ea8 <__aeabi_dmul>
 801be18:	4602      	mov	r2, r0
 801be1a:	460b      	mov	r3, r1
 801be1c:	4630      	mov	r0, r6
 801be1e:	4639      	mov	r1, r7
 801be20:	f00b fe8a 	bl	8027b38 <__aeabi_dsub>
 801be24:	4602      	mov	r2, r0
 801be26:	460b      	mov	r3, r1
 801be28:	4620      	mov	r0, r4
 801be2a:	4629      	mov	r1, r5
 801be2c:	f00b fe86 	bl	8027b3c <__adddf3>
 801be30:	9e0c      	ldr	r6, [sp, #48]	; 0x30
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801be32:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801be36:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801be3a:	ec51 0b19 	vmov	r0, r1, d9
 801be3e:	f00c f833 	bl	8027ea8 <__aeabi_dmul>
 801be42:	ec53 2b1c 	vmov	r2, r3, d12
 801be46:	4604      	mov	r4, r0
 801be48:	460d      	mov	r5, r1
 801be4a:	4650      	mov	r0, sl
 801be4c:	4659      	mov	r1, fp
 801be4e:	f00c f82b 	bl	8027ea8 <__aeabi_dmul>
 801be52:	4602      	mov	r2, r0
 801be54:	460b      	mov	r3, r1
 801be56:	4620      	mov	r0, r4
 801be58:	4629      	mov	r1, r5
 801be5a:	f00b fe6f 	bl	8027b3c <__adddf3>
 801be5e:	4642      	mov	r2, r8
 801be60:	464b      	mov	r3, r9
 801be62:	f00b fe6b 	bl	8027b3c <__adddf3>
 801be66:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
        for (j = 0; j < n2; j++) {
 801be68:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801be6a:	3210      	adds	r2, #16
 801be6c:	920f      	str	r2, [sp, #60]	; 0x3c
 801be6e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801be70:	3210      	adds	r2, #16
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801be72:	e8e6 0104 	strd	r0, r1, [r6], #16
 801be76:	9211      	str	r2, [sp, #68]	; 0x44
        for (j = 0; j < n2; j++) {
 801be78:	9a0d      	ldr	r2, [sp, #52]	; 0x34
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801be7a:	960c      	str	r6, [sp, #48]	; 0x30
        for (j = 0; j < n2; j++) {
 801be7c:	3301      	adds	r3, #1
 801be7e:	429a      	cmp	r2, r3
 801be80:	9310      	str	r3, [sp, #64]	; 0x40
 801be82:	f47f aebb 	bne.w	801bbfc <cblas_zhemm+0x33c>
      for (i = 0; i < n1; i++) {
 801be86:	9a00      	ldr	r2, [sp, #0]
 801be88:	991b      	ldr	r1, [sp, #108]	; 0x6c
 801be8a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801be8c:	440a      	add	r2, r1
 801be8e:	9200      	str	r2, [sp, #0]
 801be90:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801be92:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801be94:	440a      	add	r2, r1
 801be96:	9219      	str	r2, [sp, #100]	; 0x64
 801be98:	9918      	ldr	r1, [sp, #96]	; 0x60
 801be9a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801be9c:	440a      	add	r2, r1
 801be9e:	9216      	str	r2, [sp, #88]	; 0x58
 801bea0:	991a      	ldr	r1, [sp, #104]	; 0x68
 801bea2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801bea4:	440a      	add	r2, r1
 801bea6:	9213      	str	r2, [sp, #76]	; 0x4c
 801bea8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801beaa:	3301      	adds	r3, #1
 801beac:	429a      	cmp	r2, r3
 801beae:	9312      	str	r3, [sp, #72]	; 0x48
 801beb0:	f47f ae92 	bne.w	801bbd8 <cblas_zhemm+0x318>
 801beb4:	e5d6      	b.n	801ba64 <cblas_zhemm+0x1a4>
 801beb6:	bf00      	nop
	...
    } else if (side == CblasRight && uplo == CblasUpper) {
 801bec0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801bec2:	2b79      	cmp	r3, #121	; 0x79
 801bec4:	f000 8380 	beq.w	801c5c8 <cblas_zhemm+0xd08>
    } else if (side == CblasRight && uplo == CblasLower) {
 801bec8:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801beca:	2b7a      	cmp	r3, #122	; 0x7a
 801becc:	f47f adae 	bne.w	801ba2c <cblas_zhemm+0x16c>
      for (i = 0; i < n1; i++) {
 801bed0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801bed2:	2b00      	cmp	r3, #0
 801bed4:	f77f adc6 	ble.w	801ba64 <cblas_zhemm+0x1a4>
 801bed8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801beda:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801bedc:	0112      	lsls	r2, r2, #4
 801bede:	9219      	str	r2, [sp, #100]	; 0x64
 801bee0:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801bee2:	0112      	lsls	r2, r2, #4
 801bee4:	3301      	adds	r3, #1
 801bee6:	9217      	str	r2, [sp, #92]	; 0x5c
 801bee8:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801beea:	9211      	str	r2, [sp, #68]	; 0x44
 801beec:	011a      	lsls	r2, r3, #4
 801beee:	9215      	str	r2, [sp, #84]	; 0x54
 801bef0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801bef2:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801bef6:	9318      	str	r3, [sp, #96]	; 0x60
 801bef8:	2300      	movs	r3, #0
 801befa:	9316      	str	r3, [sp, #88]	; 0x58
        for (j = 0; j < n2; j++) {
 801befc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801befe:	2b00      	cmp	r3, #0
 801bf00:	f340 84ec 	ble.w	801c8dc <cblas_zhemm+0x101c>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801bf04:	9c11      	ldr	r4, [sp, #68]	; 0x44
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bf06:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801bf0a:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bf0e:	ec53 2b18 	vmov	r2, r3, d8
 801bf12:	4630      	mov	r0, r6
 801bf14:	4639      	mov	r1, r7
 801bf16:	f00b ffc7 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801bf1a:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bf1e:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801bf22:	4604      	mov	r4, r0
 801bf24:	460d      	mov	r5, r1
 801bf26:	4652      	mov	r2, sl
 801bf28:	465b      	mov	r3, fp
 801bf2a:	4640      	mov	r0, r8
 801bf2c:	4649      	mov	r1, r9
 801bf2e:	f00b ffbb 	bl	8027ea8 <__aeabi_dmul>
 801bf32:	4602      	mov	r2, r0
 801bf34:	460b      	mov	r3, r1
 801bf36:	4620      	mov	r0, r4
 801bf38:	4629      	mov	r1, r5
 801bf3a:	f00b fdfd 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bf3e:	4652      	mov	r2, sl
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bf40:	4604      	mov	r4, r0
 801bf42:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bf44:	465b      	mov	r3, fp
 801bf46:	4630      	mov	r0, r6
 801bf48:	4639      	mov	r1, r7
 801bf4a:	f00b ffad 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801bf4e:	ec45 4b1e 	vmov	d14, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bf52:	ec53 2b18 	vmov	r2, r3, d8
 801bf56:	4604      	mov	r4, r0
 801bf58:	460d      	mov	r5, r1
 801bf5a:	4640      	mov	r0, r8
 801bf5c:	4649      	mov	r1, r9
 801bf5e:	f00b ffa3 	bl	8027ea8 <__aeabi_dmul>
 801bf62:	460b      	mov	r3, r1
 801bf64:	4602      	mov	r2, r0
 801bf66:	4629      	mov	r1, r5
 801bf68:	4620      	mov	r0, r4
 801bf6a:	f00b fde7 	bl	8027b3c <__adddf3>
 801bf6e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801bf70:	9302      	str	r3, [sp, #8]
 801bf72:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801bf74:	930c      	str	r3, [sp, #48]	; 0x30
 801bf76:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801bf78:	9304      	str	r3, [sp, #16]
          BASE temp2_imag = 0.0;
 801bf7a:	ed1f 7b31 	vldr	d7, [pc, #-196]	; 801beb8 <cblas_zhemm+0x5f8>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bf7e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801bf80:	9c11      	ldr	r4, [sp, #68]	; 0x44
 801bf82:	9306      	str	r3, [sp, #24]
 801bf84:	ec41 0b1f 	vmov	d15, r0, r1
          BASE temp2_imag = 0.0;
 801bf88:	eeb0 da47 	vmov.f32	s26, s14
 801bf8c:	eef0 da67 	vmov.f32	s27, s15
        for (j = 0; j < n2; j++) {
 801bf90:	2300      	movs	r3, #0
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801bf92:	940f      	str	r4, [sp, #60]	; 0x3c
        for (j = 0; j < n2; j++) {
 801bf94:	9310      	str	r3, [sp, #64]	; 0x40
          BASE temp2_real = 0.0;
 801bf96:	eeb0 ca47 	vmov.f32	s24, s14
 801bf9a:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801bf9e:	9b06      	ldr	r3, [sp, #24]
 801bfa0:	e9d3 4500 	ldrd	r4, r5, [r3]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801bfa4:	ec53 2b1f 	vmov	r2, r3, d15
 801bfa8:	4620      	mov	r0, r4
 801bfaa:	4629      	mov	r1, r5
 801bfac:	f00b ff7c 	bl	8027ea8 <__aeabi_dmul>
 801bfb0:	9e04      	ldr	r6, [sp, #16]
 801bfb2:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 801bfb6:	f00b fdc1 	bl	8027b3c <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801bfba:	ec53 2b1e 	vmov	r2, r3, d14
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801bfbe:	4680      	mov	r8, r0
 801bfc0:	4689      	mov	r9, r1
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801bfc2:	4620      	mov	r0, r4
 801bfc4:	4629      	mov	r1, r5
 801bfc6:	f00b ff6f 	bl	8027ea8 <__aeabi_dmul>
 801bfca:	e9d6 2300 	ldrd	r2, r3, [r6]
 801bfce:	9604      	str	r6, [sp, #16]
 801bfd0:	f00b fdb4 	bl	8027b3c <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801bfd4:	ed9d 9b08 	vldr	d9, [sp, #32]
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801bfd8:	4604      	mov	r4, r0
 801bfda:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801bfdc:	ec53 2b1c 	vmov	r2, r3, d12
 801bfe0:	ec51 0b19 	vmov	r0, r1, d9
 801bfe4:	f00b ff60 	bl	8027ea8 <__aeabi_dmul>
 801bfe8:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801bfec:	ec53 2b1d 	vmov	r2, r3, d13
 801bff0:	4606      	mov	r6, r0
 801bff2:	460f      	mov	r7, r1
 801bff4:	4650      	mov	r0, sl
 801bff6:	4659      	mov	r1, fp
 801bff8:	f00b ff56 	bl	8027ea8 <__aeabi_dmul>
 801bffc:	4602      	mov	r2, r0
 801bffe:	460b      	mov	r3, r1
 801c000:	4630      	mov	r0, r6
 801c002:	4639      	mov	r1, r7
 801c004:	f00b fd98 	bl	8027b38 <__aeabi_dsub>
 801c008:	4602      	mov	r2, r0
 801c00a:	460b      	mov	r3, r1
 801c00c:	4620      	mov	r0, r4
 801c00e:	4629      	mov	r1, r5
 801c010:	f00b fd94 	bl	8027b3c <__adddf3>
 801c014:	9e04      	ldr	r6, [sp, #16]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c016:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c01a:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c01e:	ec51 0b19 	vmov	r0, r1, d9
 801c022:	f00b ff41 	bl	8027ea8 <__aeabi_dmul>
 801c026:	ec53 2b1c 	vmov	r2, r3, d12
 801c02a:	4604      	mov	r4, r0
 801c02c:	460d      	mov	r5, r1
 801c02e:	4650      	mov	r0, sl
 801c030:	4659      	mov	r1, fp
 801c032:	f00b ff39 	bl	8027ea8 <__aeabi_dmul>
 801c036:	4602      	mov	r2, r0
 801c038:	460b      	mov	r3, r1
 801c03a:	4620      	mov	r0, r4
 801c03c:	4629      	mov	r1, r5
 801c03e:	f00b fd7d 	bl	8027b3c <__adddf3>
 801c042:	4642      	mov	r2, r8
 801c044:	464b      	mov	r3, r9
 801c046:	f00b fd79 	bl	8027b3c <__adddf3>
        for (j = 0; j < n2; j++) {
 801c04a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801c04c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801c04e:	3301      	adds	r3, #1
 801c050:	429a      	cmp	r2, r3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c052:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801c056:	9310      	str	r3, [sp, #64]	; 0x40
 801c058:	f000 8440 	beq.w	801c8dc <cblas_zhemm+0x101c>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c05c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c05e:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c062:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c066:	ec51 0b18 	vmov	r0, r1, d8
 801c06a:	4632      	mov	r2, r6
 801c06c:	463b      	mov	r3, r7
 801c06e:	f00b ff1b 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801c072:	e9d4 8906 	ldrd	r8, r9, [r4, #24]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c076:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801c07a:	4604      	mov	r4, r0
 801c07c:	460d      	mov	r5, r1
 801c07e:	4642      	mov	r2, r8
 801c080:	464b      	mov	r3, r9
 801c082:	4650      	mov	r0, sl
 801c084:	4659      	mov	r1, fp
 801c086:	f00b ff0f 	bl	8027ea8 <__aeabi_dmul>
 801c08a:	4602      	mov	r2, r0
 801c08c:	460b      	mov	r3, r1
 801c08e:	4620      	mov	r0, r4
 801c090:	4629      	mov	r1, r5
 801c092:	f00b fd51 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c096:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c098:	4604      	mov	r4, r0
 801c09a:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c09c:	464b      	mov	r3, r9
 801c09e:	ec51 0b18 	vmov	r0, r1, d8
 801c0a2:	f00b ff01 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c0a6:	ec45 4b1e 	vmov	d14, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c0aa:	4632      	mov	r2, r6
 801c0ac:	4604      	mov	r4, r0
 801c0ae:	460d      	mov	r5, r1
 801c0b0:	463b      	mov	r3, r7
 801c0b2:	4650      	mov	r0, sl
 801c0b4:	4659      	mov	r1, fp
 801c0b6:	f00b fef7 	bl	8027ea8 <__aeabi_dmul>
 801c0ba:	4602      	mov	r2, r0
 801c0bc:	460b      	mov	r3, r1
 801c0be:	4620      	mov	r0, r4
 801c0c0:	4629      	mov	r1, r5
 801c0c2:	f00b fd3b 	bl	8027b3c <__adddf3>
          BASE temp2_imag = 0.0;
 801c0c6:	ed1f 7b84 	vldr	d7, [pc, #-528]	; 801beb8 <cblas_zhemm+0x5f8>
 801c0ca:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801c0cc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801c0ce:	9c14      	ldr	r4, [sp, #80]	; 0x50
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c0d0:	9d11      	ldr	r5, [sp, #68]	; 0x44
          BASE temp2_imag = 0.0;
 801c0d2:	eeb0 da47 	vmov.f32	s26, s14
 801c0d6:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c0da:	ec41 0b1f 	vmov	d15, r0, r1
          BASE temp2_real = 0.0;
 801c0de:	eeb0 ca47 	vmov.f32	s24, s14
 801c0e2:	eef0 ca67 	vmov.f32	s25, s15
 801c0e6:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 801c0ea:	f104 0b08 	add.w	fp, r4, #8
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801c0ee:	e9da 8900 	ldrd	r8, r9, [sl]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801c0f2:	ec51 0b1e 	vmov	r0, r1, d14
 801c0f6:	4642      	mov	r2, r8
 801c0f8:	464b      	mov	r3, r9
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801c0fa:	e9da 6702 	ldrd	r6, r7, [sl, #8]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801c0fe:	f00b fed3 	bl	8027ea8 <__aeabi_dmul>
 801c102:	4632      	mov	r2, r6
 801c104:	ec41 0b18 	vmov	d8, r0, r1
 801c108:	463b      	mov	r3, r7
 801c10a:	ec51 0b1f 	vmov	r0, r1, d15
 801c10e:	f00b fecb 	bl	8027ea8 <__aeabi_dmul>
 801c112:	4602      	mov	r2, r0
 801c114:	460b      	mov	r3, r1
 801c116:	ec51 0b18 	vmov	r0, r1, d8
 801c11a:	f00b fd0d 	bl	8027b38 <__aeabi_dsub>
 801c11e:	4602      	mov	r2, r0
 801c120:	460b      	mov	r3, r1
 801c122:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801c126:	f00b fd09 	bl	8027b3c <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 801c12a:	ed95 8b00 	vldr	d8, [r5]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 801c12e:	ed95 9b02 	vldr	d9, [r5, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801c132:	4632      	mov	r2, r6
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801c134:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801c138:	463b      	mov	r3, r7
 801c13a:	ec51 0b1e 	vmov	r0, r1, d14
 801c13e:	f00b feb3 	bl	8027ea8 <__aeabi_dmul>
 801c142:	4642      	mov	r2, r8
 801c144:	ec41 0b1b 	vmov	d11, r0, r1
 801c148:	464b      	mov	r3, r9
 801c14a:	ec51 0b1f 	vmov	r0, r1, d15
 801c14e:	f00b feab 	bl	8027ea8 <__aeabi_dmul>
 801c152:	4602      	mov	r2, r0
 801c154:	460b      	mov	r3, r1
 801c156:	ec51 0b1b 	vmov	r0, r1, d11
 801c15a:	f00b fcef 	bl	8027b3c <__adddf3>
 801c15e:	4602      	mov	r2, r0
 801c160:	460b      	mov	r3, r1
 801c162:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801c166:	f00b fce9 	bl	8027b3c <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c16a:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801c16e:	e9c4 0102 	strd	r0, r1, [r4, #8]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c172:	4640      	mov	r0, r8
 801c174:	4649      	mov	r1, r9
 801c176:	f00b fe97 	bl	8027ea8 <__aeabi_dmul>
 801c17a:	ec53 2b19 	vmov	r2, r3, d9
 801c17e:	ec41 0b1a 	vmov	d10, r0, r1
 801c182:	4630      	mov	r0, r6
 801c184:	4639      	mov	r1, r7
 801c186:	f00b fe8f 	bl	8027ea8 <__aeabi_dmul>
 801c18a:	4602      	mov	r2, r0
 801c18c:	460b      	mov	r3, r1
 801c18e:	ec51 0b1a 	vmov	r0, r1, d10
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c192:	9600      	str	r6, [sp, #0]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c194:	f00b fcd2 	bl	8027b3c <__adddf3>
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c198:	f107 4600 	add.w	r6, r7, #2147483648	; 0x80000000
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c19c:	4602      	mov	r2, r0
 801c19e:	460b      	mov	r3, r1
 801c1a0:	ec51 0b1c 	vmov	r0, r1, d12
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c1a4:	9601      	str	r6, [sp, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c1a6:	f00b fcc9 	bl	8027b3c <__adddf3>
 801c1aa:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c1ae:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c1b2:	eeb0 ca47 	vmov.f32	s24, s14
 801c1b6:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c1ba:	e9dd 0100 	ldrd	r0, r1, [sp]
 801c1be:	f00b fe73 	bl	8027ea8 <__aeabi_dmul>
 801c1c2:	ec53 2b19 	vmov	r2, r3, d9
 801c1c6:	4606      	mov	r6, r0
 801c1c8:	460f      	mov	r7, r1
 801c1ca:	4640      	mov	r0, r8
 801c1cc:	4649      	mov	r1, r9
 801c1ce:	f00b fe6b 	bl	8027ea8 <__aeabi_dmul>
 801c1d2:	4602      	mov	r2, r0
 801c1d4:	460b      	mov	r3, r1
 801c1d6:	4630      	mov	r0, r6
 801c1d8:	4639      	mov	r1, r7
 801c1da:	f00b fcaf 	bl	8027b3c <__adddf3>
 801c1de:	460b      	mov	r3, r1
 801c1e0:	4602      	mov	r2, r0
 801c1e2:	ec51 0b1d 	vmov	r0, r1, d13
 801c1e6:	f00b fca9 	bl	8027b3c <__adddf3>
          for (k = 0; k < j; k++) {
 801c1ea:	9b02      	ldr	r3, [sp, #8]
 801c1ec:	f10a 0a10 	add.w	sl, sl, #16
 801c1f0:	4553      	cmp	r3, sl
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c1f2:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < j; k++) {
 801c1f6:	f105 0510 	add.w	r5, r5, #16
 801c1fa:	f10b 0b10 	add.w	fp, fp, #16
 801c1fe:	f104 0410 	add.w	r4, r4, #16
 801c202:	f47f af74 	bne.w	801c0ee <cblas_zhemm+0x82e>
 801c206:	9a06      	ldr	r2, [sp, #24]
 801c208:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801c20a:	4611      	mov	r1, r2
 801c20c:	9a04      	ldr	r2, [sp, #16]
 801c20e:	3210      	adds	r2, #16
 801c210:	9204      	str	r2, [sp, #16]
 801c212:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801c214:	4419      	add	r1, r3
 801c216:	3210      	adds	r2, #16
 801c218:	9106      	str	r1, [sp, #24]
 801c21a:	920f      	str	r2, [sp, #60]	; 0x3c
 801c21c:	9912      	ldr	r1, [sp, #72]	; 0x48
 801c21e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801c220:	440a      	add	r2, r1
 801c222:	920c      	str	r2, [sp, #48]	; 0x30
 801c224:	9a02      	ldr	r2, [sp, #8]
 801c226:	441a      	add	r2, r3
 801c228:	9202      	str	r2, [sp, #8]
 801c22a:	e6b8      	b.n	801bf9e <cblas_zhemm+0x6de>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801c22c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c22e:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801c230:	2b01      	cmp	r3, #1
 801c232:	bfb8      	it	lt
 801c234:	2301      	movlt	r3, #1
 801c236:	4293      	cmp	r3, r2
 801c238:	f300 8347 	bgt.w	801c8ca <cblas_zhemm+0x100a>
 801c23c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c23e:	4293      	cmp	r3, r2
 801c240:	bfcc      	ite	gt
 801c242:	200d      	movgt	r0, #13
 801c244:	2008      	movle	r0, #8
 801c246:	f7ff bb77 	b.w	801b938 <cblas_zhemm+0x78>
 801c24a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c24c:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801c24e:	2b01      	cmp	r3, #1
 801c250:	bfb8      	it	lt
 801c252:	2301      	movlt	r3, #1
 801c254:	4293      	cmp	r3, r2
 801c256:	f300 8338 	bgt.w	801c8ca <cblas_zhemm+0x100a>
 801c25a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c25c:	4293      	cmp	r3, r2
 801c25e:	f77f abf5 	ble.w	801ba4c <cblas_zhemm+0x18c>
 801c262:	200d      	movs	r0, #13
 801c264:	f7ff bb68 	b.w	801b938 <cblas_zhemm+0x78>
      for (i = 0; i < n1; i++) {
 801c268:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801c26a:	2a00      	cmp	r2, #0
 801c26c:	f77f abfa 	ble.w	801ba64 <cblas_zhemm+0x1a4>
 801c270:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801c272:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801c274:	910f      	str	r1, [sp, #60]	; 0x3c
 801c276:	3301      	adds	r3, #1
 801c278:	0118      	lsls	r0, r3, #4
 801c27a:	f1a1 0310 	sub.w	r3, r1, #16
 801c27e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c282:	9312      	str	r3, [sp, #72]	; 0x48
 801c284:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801c286:	901f      	str	r0, [sp, #124]	; 0x7c
 801c288:	011a      	lsls	r2, r3, #4
 801c28a:	9204      	str	r2, [sp, #16]
 801c28c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c28e:	2100      	movs	r1, #0
 801c290:	e9cd 2319 	strd	r2, r3, [sp, #100]	; 0x64
 801c294:	911b      	str	r1, [sp, #108]	; 0x6c
 801c296:	3810      	subs	r0, #16
 801c298:	911c      	str	r1, [sp, #112]	; 0x70
 801c29a:	2301      	movs	r3, #1
 801c29c:	0111      	lsls	r1, r2, #4
 801c29e:	901e      	str	r0, [sp, #120]	; 0x78
 801c2a0:	9100      	str	r1, [sp, #0]
 801c2a2:	9311      	str	r3, [sp, #68]	; 0x44
        for (j = 0; j < n2; j++) {
 801c2a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c2a6:	2b00      	cmp	r3, #0
 801c2a8:	f340 837c 	ble.w	801c9a4 <cblas_zhemm+0x10e4>
 801c2ac:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801c2ae:	991c      	ldr	r1, [sp, #112]	; 0x70
 801c2b0:	981b      	ldr	r0, [sp, #108]	; 0x6c
 801c2b2:	1a5a      	subs	r2, r3, r1
 801c2b4:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801c2b6:	1a1b      	subs	r3, r3, r0
 801c2b8:	011b      	lsls	r3, r3, #4
 801c2ba:	3308      	adds	r3, #8
 801c2bc:	9316      	str	r3, [sp, #88]	; 0x58
 801c2be:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801c2c0:	931d      	str	r3, [sp, #116]	; 0x74
 801c2c2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801c2c4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 801c2c8:	9306      	str	r3, [sp, #24]
 801c2ca:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801c2cc:	0112      	lsls	r2, r2, #4
 801c2ce:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801c2d2:	3208      	adds	r2, #8
 801c2d4:	930c      	str	r3, [sp, #48]	; 0x30
 801c2d6:	2300      	movs	r3, #0
 801c2d8:	9213      	str	r2, [sp, #76]	; 0x4c
 801c2da:	9310      	str	r3, [sp, #64]	; 0x40
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c2dc:	9c06      	ldr	r4, [sp, #24]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c2de:	ed9d 8b08 	vldr	d8, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c2e2:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c2e6:	ec51 0b18 	vmov	r0, r1, d8
 801c2ea:	4632      	mov	r2, r6
 801c2ec:	463b      	mov	r3, r7
 801c2ee:	f00b fddb 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801c2f2:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c2f6:	e9dd ab0a 	ldrd	sl, fp, [sp, #40]	; 0x28
 801c2fa:	4642      	mov	r2, r8
 801c2fc:	464b      	mov	r3, r9
 801c2fe:	4604      	mov	r4, r0
 801c300:	460d      	mov	r5, r1
 801c302:	4650      	mov	r0, sl
 801c304:	4659      	mov	r1, fp
 801c306:	f00b fdcf 	bl	8027ea8 <__aeabi_dmul>
 801c30a:	4602      	mov	r2, r0
 801c30c:	460b      	mov	r3, r1
 801c30e:	4620      	mov	r0, r4
 801c310:	4629      	mov	r1, r5
 801c312:	f00b fc11 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c316:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c318:	4604      	mov	r4, r0
 801c31a:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c31c:	464b      	mov	r3, r9
 801c31e:	ec51 0b18 	vmov	r0, r1, d8
 801c322:	f00b fdc1 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c326:	46a0      	mov	r8, r4
 801c328:	46a9      	mov	r9, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c32a:	4632      	mov	r2, r6
 801c32c:	463b      	mov	r3, r7
 801c32e:	4604      	mov	r4, r0
 801c330:	460d      	mov	r5, r1
 801c332:	4650      	mov	r0, sl
 801c334:	4659      	mov	r1, fp
 801c336:	f00b fdb7 	bl	8027ea8 <__aeabi_dmul>
 801c33a:	4602      	mov	r2, r0
 801c33c:	460b      	mov	r3, r1
 801c33e:	4620      	mov	r0, r4
 801c340:	4629      	mov	r1, r5
 801c342:	f00b fbfb 	bl	8027b3c <__adddf3>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 801c346:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801c348:	e9d3 4500 	ldrd	r4, r5, [r3]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c34c:	4606      	mov	r6, r0
 801c34e:	460f      	mov	r7, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801c350:	4640      	mov	r0, r8
 801c352:	4649      	mov	r1, r9
 801c354:	4622      	mov	r2, r4
 801c356:	462b      	mov	r3, r5
 801c358:	f00b fda6 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c35c:	ec49 8b1e 	vmov	d14, r8, r9
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c360:	46b9      	mov	r9, r7
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801c362:	9f0c      	ldr	r7, [sp, #48]	; 0x30
 801c364:	4602      	mov	r2, r0
 801c366:	460b      	mov	r3, r1
 801c368:	e9d7 0100 	ldrd	r0, r1, [r7]
 801c36c:	f00b fbe6 	bl	8027b3c <__adddf3>
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801c370:	4622      	mov	r2, r4
            REAL(C, i * ldc + j) += temp1_real * Aii_real;
 801c372:	e9c7 0100 	strd	r0, r1, [r7]
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801c376:	462b      	mov	r3, r5
 801c378:	4630      	mov	r0, r6
 801c37a:	4649      	mov	r1, r9
 801c37c:	f00b fd94 	bl	8027ea8 <__aeabi_dmul>
 801c380:	4602      	mov	r2, r0
 801c382:	460b      	mov	r3, r1
 801c384:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801c388:	f00b fbd8 	bl	8027b3c <__adddf3>
          BASE temp2_imag = 0.0;
 801c38c:	ed9f 7b8c 	vldr	d7, [pc, #560]	; 801c5c0 <cblas_zhemm+0xd00>
            IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
 801c390:	e9c7 0102 	strd	r0, r1, [r7, #8]
          BASE temp2_imag = 0.0;
 801c394:	eeb0 da47 	vmov.f32	s26, s14
 801c398:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 801c39c:	eeb0 ca47 	vmov.f32	s24, s14
 801c3a0:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 801c3a4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801c3a6:	9911      	ldr	r1, [sp, #68]	; 0x44
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c3a8:	46b0      	mov	r8, r6
          for (k = i + 1; k < n1; k++) {
 801c3aa:	428a      	cmp	r2, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c3ac:	ec49 8b1f 	vmov	d15, r8, r9
          for (k = i + 1; k < n1; k++) {
 801c3b0:	f340 8095 	ble.w	801c4de <cblas_zhemm+0xc1e>
 801c3b4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801c3b6:	9c06      	ldr	r4, [sp, #24]
 801c3b8:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
 801c3bc:	9d12      	ldr	r5, [sp, #72]	; 0x48
 801c3be:	1914      	adds	r4, r2, r4
 801c3c0:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801c3c2:	eb02 0a07 	add.w	sl, r2, r7
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801c3c6:	e9db 6704 	ldrd	r6, r7, [fp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c3ca:	ec51 0b1e 	vmov	r0, r1, d14
 801c3ce:	4632      	mov	r2, r6
 801c3d0:	463b      	mov	r3, r7
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801c3d2:	e9db 8906 	ldrd	r8, r9, [fp, #24]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c3d6:	f00b fd67 	bl	8027ea8 <__aeabi_dmul>
 801c3da:	4642      	mov	r2, r8
 801c3dc:	ec41 0b18 	vmov	d8, r0, r1
 801c3e0:	464b      	mov	r3, r9
 801c3e2:	ec51 0b1f 	vmov	r0, r1, d15
 801c3e6:	f00b fd5f 	bl	8027ea8 <__aeabi_dmul>
 801c3ea:	4602      	mov	r2, r0
 801c3ec:	460b      	mov	r3, r1
 801c3ee:	ec51 0b18 	vmov	r0, r1, d8
 801c3f2:	f00b fba3 	bl	8027b3c <__adddf3>
 801c3f6:	4602      	mov	r2, r0
 801c3f8:	460b      	mov	r3, r1
 801c3fa:	e95a 0102 	ldrd	r0, r1, [sl, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c3fe:	f8cd 8008 	str.w	r8, [sp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c402:	f00b fb9b 	bl	8027b3c <__adddf3>
 801c406:	460b      	mov	r3, r1
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c408:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c40c:	4602      	mov	r2, r0
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c40e:	9103      	str	r1, [sp, #12]
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 801c410:	ed14 8b02 	vldr	d8, [r4, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 801c414:	ed94 9b00 	vldr	d9, [r4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c418:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
 801c41c:	e94a 2302 	strd	r2, r3, [sl, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c420:	ec53 2b1e 	vmov	r2, r3, d14
 801c424:	f00b fd40 	bl	8027ea8 <__aeabi_dmul>
 801c428:	4632      	mov	r2, r6
 801c42a:	463b      	mov	r3, r7
 801c42c:	ec41 0b1b 	vmov	d11, r0, r1
 801c430:	ec51 0b1f 	vmov	r0, r1, d15
 801c434:	f00b fd38 	bl	8027ea8 <__aeabi_dmul>
 801c438:	4602      	mov	r2, r0
 801c43a:	460b      	mov	r3, r1
 801c43c:	ec51 0b1b 	vmov	r0, r1, d11
 801c440:	f00b fb7c 	bl	8027b3c <__adddf3>
 801c444:	4602      	mov	r2, r0
 801c446:	460b      	mov	r3, r1
 801c448:	e9da 0100 	ldrd	r0, r1, [sl]
 801c44c:	f00b fb76 	bl	8027b3c <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801c450:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
 801c454:	e9ca 0100 	strd	r0, r1, [sl]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801c458:	4630      	mov	r0, r6
 801c45a:	4639      	mov	r1, r7
 801c45c:	f00b fd24 	bl	8027ea8 <__aeabi_dmul>
 801c460:	ec53 2b19 	vmov	r2, r3, d9
 801c464:	ec41 0b1a 	vmov	d10, r0, r1
 801c468:	4640      	mov	r0, r8
 801c46a:	4649      	mov	r1, r9
 801c46c:	f00b fd1c 	bl	8027ea8 <__aeabi_dmul>
 801c470:	4602      	mov	r2, r0
 801c472:	460b      	mov	r3, r1
 801c474:	ec51 0b1a 	vmov	r0, r1, d10
 801c478:	f00b fb5e 	bl	8027b38 <__aeabi_dsub>
 801c47c:	4602      	mov	r2, r0
 801c47e:	460b      	mov	r3, r1
 801c480:	ec51 0b1c 	vmov	r0, r1, d12
 801c484:	f00b fb5a 	bl	8027b3c <__adddf3>
 801c488:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801c48c:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 801c490:	eeb0 ca47 	vmov.f32	s24, s14
 801c494:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801c498:	4630      	mov	r0, r6
 801c49a:	4639      	mov	r1, r7
 801c49c:	f00b fd04 	bl	8027ea8 <__aeabi_dmul>
 801c4a0:	ec53 2b18 	vmov	r2, r3, d8
 801c4a4:	4606      	mov	r6, r0
 801c4a6:	460f      	mov	r7, r1
 801c4a8:	4640      	mov	r0, r8
 801c4aa:	4649      	mov	r1, r9
 801c4ac:	f00b fcfc 	bl	8027ea8 <__aeabi_dmul>
 801c4b0:	4602      	mov	r2, r0
 801c4b2:	460b      	mov	r3, r1
 801c4b4:	4630      	mov	r0, r6
 801c4b6:	4639      	mov	r1, r7
 801c4b8:	f00b fb40 	bl	8027b3c <__adddf3>
 801c4bc:	460b      	mov	r3, r1
 801c4be:	4602      	mov	r2, r0
 801c4c0:	ec51 0b1d 	vmov	r0, r1, d13
 801c4c4:	f00b fb3a 	bl	8027b3c <__adddf3>
 801c4c8:	9b04      	ldr	r3, [sp, #16]
 801c4ca:	f10b 0b10 	add.w	fp, fp, #16
 801c4ce:	441c      	add	r4, r3
 801c4d0:	9b00      	ldr	r3, [sp, #0]
          for (k = i + 1; k < n1; k++) {
 801c4d2:	455d      	cmp	r5, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 801c4d4:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = i + 1; k < n1; k++) {
 801c4d8:	449a      	add	sl, r3
 801c4da:	f47f af74 	bne.w	801c3c6 <cblas_zhemm+0xb06>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c4de:	ed9d 8b08 	vldr	d8, [sp, #32]
 801c4e2:	ec53 2b1c 	vmov	r2, r3, d12
 801c4e6:	ec51 0b18 	vmov	r0, r1, d8
 801c4ea:	f00b fcdd 	bl	8027ea8 <__aeabi_dmul>
 801c4ee:	e9dd 780a 	ldrd	r7, r8, [sp, #40]	; 0x28
 801c4f2:	ec5a 9b1d 	vmov	r9, sl, d13
 801c4f6:	4604      	mov	r4, r0
 801c4f8:	460d      	mov	r5, r1
 801c4fa:	ee1d 2a10 	vmov	r2, s26
 801c4fe:	4653      	mov	r3, sl
 801c500:	4638      	mov	r0, r7
 801c502:	4641      	mov	r1, r8
 801c504:	f00b fcd0 	bl	8027ea8 <__aeabi_dmul>
 801c508:	4602      	mov	r2, r0
 801c50a:	460b      	mov	r3, r1
 801c50c:	4620      	mov	r0, r4
 801c50e:	4629      	mov	r1, r5
 801c510:	f00b fb12 	bl	8027b38 <__aeabi_dsub>
 801c514:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801c516:	4602      	mov	r2, r0
 801c518:	460b      	mov	r3, r1
 801c51a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801c51e:	f00b fb0d 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c522:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c526:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c52a:	4653      	mov	r3, sl
 801c52c:	ec51 0b18 	vmov	r0, r1, d8
 801c530:	f00b fcba 	bl	8027ea8 <__aeabi_dmul>
 801c534:	ec53 2b1c 	vmov	r2, r3, d12
 801c538:	4604      	mov	r4, r0
 801c53a:	460d      	mov	r5, r1
 801c53c:	4638      	mov	r0, r7
 801c53e:	4641      	mov	r1, r8
 801c540:	f00b fcb2 	bl	8027ea8 <__aeabi_dmul>
 801c544:	4602      	mov	r2, r0
 801c546:	460b      	mov	r3, r1
 801c548:	4620      	mov	r0, r4
 801c54a:	4629      	mov	r1, r5
 801c54c:	f00b faf6 	bl	8027b3c <__adddf3>
 801c550:	4602      	mov	r2, r0
 801c552:	460b      	mov	r3, r1
 801c554:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801c558:	f00b faf0 	bl	8027b3c <__adddf3>
 801c55c:	9b06      	ldr	r3, [sp, #24]
        for (j = 0; j < n2; j++) {
 801c55e:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801c560:	3310      	adds	r3, #16
 801c562:	9306      	str	r3, [sp, #24]
 801c564:	f106 0310 	add.w	r3, r6, #16
 801c568:	930c      	str	r3, [sp, #48]	; 0x30
 801c56a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c56c:	3201      	adds	r2, #1
 801c56e:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c570:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801c574:	9210      	str	r2, [sp, #64]	; 0x40
 801c576:	f47f aeb1 	bne.w	801c2dc <cblas_zhemm+0xa1c>
      for (i = 0; i < n1; i++) {
 801c57a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801c57c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801c57e:	3301      	adds	r3, #1
 801c580:	9311      	str	r3, [sp, #68]	; 0x44
 801c582:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801c584:	4611      	mov	r1, r2
 801c586:	4419      	add	r1, r3
 801c588:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801c58a:	911c      	str	r1, [sp, #112]	; 0x70
 801c58c:	991f      	ldr	r1, [sp, #124]	; 0x7c
 801c58e:	440a      	add	r2, r1
 801c590:	991b      	ldr	r1, [sp, #108]	; 0x6c
 801c592:	920f      	str	r2, [sp, #60]	; 0x3c
 801c594:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c596:	4608      	mov	r0, r1
 801c598:	4410      	add	r0, r2
 801c59a:	9912      	ldr	r1, [sp, #72]	; 0x48
 801c59c:	901b      	str	r0, [sp, #108]	; 0x6c
 801c59e:	981e      	ldr	r0, [sp, #120]	; 0x78
 801c5a0:	4401      	add	r1, r0
 801c5a2:	9112      	str	r1, [sp, #72]	; 0x48
 801c5a4:	991a      	ldr	r1, [sp, #104]	; 0x68
 801c5a6:	4419      	add	r1, r3
 801c5a8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801c5aa:	911a      	str	r1, [sp, #104]	; 0x68
 801c5ac:	4413      	add	r3, r2
 801c5ae:	9319      	str	r3, [sp, #100]	; 0x64
 801c5b0:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801c5b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c5b4:	4293      	cmp	r3, r2
 801c5b6:	f73f ae75 	bgt.w	801c2a4 <cblas_zhemm+0x9e4>
 801c5ba:	f7ff ba53 	b.w	801ba64 <cblas_zhemm+0x1a4>
 801c5be:	bf00      	nop
	...
      for (i = 0; i < n1; i++) {
 801c5c8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c5ca:	2b00      	cmp	r3, #0
 801c5cc:	f77f aa4a 	ble.w	801ba64 <cblas_zhemm+0x1a4>
 801c5d0:	9812      	ldr	r0, [sp, #72]	; 0x48
 801c5d2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801c5d4:	1c42      	adds	r2, r0, #1
 801c5d6:	0112      	lsls	r2, r2, #4
 801c5d8:	9212      	str	r2, [sp, #72]	; 0x48
 801c5da:	0102      	lsls	r2, r0, #4
 801c5dc:	9211      	str	r2, [sp, #68]	; 0x44
 801c5de:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801c5e0:	3b10      	subs	r3, #16
 801c5e2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c5e6:	931d      	str	r3, [sp, #116]	; 0x74
 801c5e8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801c5ea:	011b      	lsls	r3, r3, #4
 801c5ec:	2100      	movs	r1, #0
 801c5ee:	931c      	str	r3, [sp, #112]	; 0x70
 801c5f0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801c5f2:	9119      	str	r1, [sp, #100]	; 0x64
 801c5f4:	e9cd 111a 	strd	r1, r1, [sp, #104]	; 0x68
 801c5f8:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c5fc:	9316      	str	r3, [sp, #88]	; 0x58
        for (j = 0; j < n2; j++) {
 801c5fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c600:	2b00      	cmp	r3, #0
 801c602:	f340 81ac 	ble.w	801c95e <cblas_zhemm+0x109e>
 801c606:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801c608:	9b15      	ldr	r3, [sp, #84]	; 0x54
 801c60a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c60e:	9304      	str	r3, [sp, #16]
 801c610:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801c612:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801c614:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801c618:	930f      	str	r3, [sp, #60]	; 0x3c
 801c61a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801c61c:	9302      	str	r3, [sp, #8]
 801c61e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801c620:	930c      	str	r3, [sp, #48]	; 0x30
 801c622:	2300      	movs	r3, #0
 801c624:	9310      	str	r3, [sp, #64]	; 0x40
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c626:	9c04      	ldr	r4, [sp, #16]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c628:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 801c62c:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c630:	4650      	mov	r0, sl
 801c632:	4632      	mov	r2, r6
 801c634:	463b      	mov	r3, r7
 801c636:	4659      	mov	r1, fp
 801c638:	f00b fc36 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 801c63c:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c640:	ed9d 8b0a 	vldr	d8, [sp, #40]	; 0x28
 801c644:	464b      	mov	r3, r9
 801c646:	4604      	mov	r4, r0
 801c648:	460d      	mov	r5, r1
 801c64a:	4642      	mov	r2, r8
 801c64c:	ec51 0b18 	vmov	r0, r1, d8
 801c650:	f00b fc2a 	bl	8027ea8 <__aeabi_dmul>
 801c654:	4602      	mov	r2, r0
 801c656:	460b      	mov	r3, r1
 801c658:	4620      	mov	r0, r4
 801c65a:	4629      	mov	r1, r5
 801c65c:	f00b fa6c 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c660:	464b      	mov	r3, r9
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c662:	4604      	mov	r4, r0
 801c664:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c666:	4642      	mov	r2, r8
 801c668:	4650      	mov	r0, sl
 801c66a:	4659      	mov	r1, fp
 801c66c:	f00b fc1c 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c670:	46a1      	mov	r9, r4
 801c672:	46aa      	mov	sl, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c674:	4632      	mov	r2, r6
 801c676:	463b      	mov	r3, r7
 801c678:	4604      	mov	r4, r0
 801c67a:	460d      	mov	r5, r1
 801c67c:	ec51 0b18 	vmov	r0, r1, d8
 801c680:	f00b fc12 	bl	8027ea8 <__aeabi_dmul>
 801c684:	4602      	mov	r2, r0
 801c686:	460b      	mov	r3, r1
 801c688:	4620      	mov	r0, r4
 801c68a:	4629      	mov	r1, r5
 801c68c:	f00b fa56 	bl	8027b3c <__adddf3>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 801c690:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801c692:	e9d3 4500 	ldrd	r4, r5, [r3]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c696:	4606      	mov	r6, r0
 801c698:	460f      	mov	r7, r1
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801c69a:	462b      	mov	r3, r5
 801c69c:	4648      	mov	r0, r9
 801c69e:	4651      	mov	r1, sl
 801c6a0:	4622      	mov	r2, r4
 801c6a2:	f00b fc01 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 801c6a6:	ec4a 9b1b 	vmov	d11, r9, sl
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c6aa:	46ba      	mov	sl, r7
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801c6ac:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 801c6ae:	4602      	mov	r2, r0
 801c6b0:	460b      	mov	r3, r1
 801c6b2:	e9d7 0100 	ldrd	r0, r1, [r7]
 801c6b6:	f00b fa41 	bl	8027b3c <__adddf3>
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801c6ba:	462b      	mov	r3, r5
            REAL(C, i * ldc + j) += temp1_real * Ajj_real;
 801c6bc:	e9c7 0100 	strd	r0, r1, [r7]
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801c6c0:	4622      	mov	r2, r4
 801c6c2:	4630      	mov	r0, r6
 801c6c4:	4651      	mov	r1, sl
 801c6c6:	f00b fbef 	bl	8027ea8 <__aeabi_dmul>
 801c6ca:	4602      	mov	r2, r0
 801c6cc:	460b      	mov	r3, r1
 801c6ce:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801c6d2:	f00b fa33 	bl	8027b3c <__adddf3>
          for (k = j + 1; k < n2; k++) {
 801c6d6:	9d10      	ldr	r5, [sp, #64]	; 0x40
 801c6d8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801c6da:	3501      	adds	r5, #1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c6dc:	46b1      	mov	r9, r6
          for (k = j + 1; k < n2; k++) {
 801c6de:	42aa      	cmp	r2, r5
            IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
 801c6e0:	e9c7 0102 	strd	r0, r1, [r7, #8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 801c6e4:	ec4a 9b1a 	vmov	d10, r9, sl
          for (k = j + 1; k < n2; k++) {
 801c6e8:	9510      	str	r5, [sp, #64]	; 0x40
 801c6ea:	f000 8108 	beq.w	801c8fe <cblas_zhemm+0x103e>
          BASE temp2_imag = 0.0;
 801c6ee:	ed1f 7b4c 	vldr	d7, [pc, #-304]	; 801c5c0 <cblas_zhemm+0xd00>
          for (k = j + 1; k < n2; k++) {
 801c6f2:	9c04      	ldr	r4, [sp, #16]
 801c6f4:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 801c6f8:	9400      	str	r4, [sp, #0]
 801c6fa:	46b9      	mov	r9, r7
          BASE temp2_imag = 0.0;
 801c6fc:	eeb0 da47 	vmov.f32	s26, s14
 801c700:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 801c704:	eeb0 ca47 	vmov.f32	s24, s14
 801c708:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801c70c:	e9d8 4504 	ldrd	r4, r5, [r8, #16]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801c710:	ec51 0b1b 	vmov	r0, r1, d11
 801c714:	4622      	mov	r2, r4
 801c716:	462b      	mov	r3, r5
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801c718:	e9d8 ab06 	ldrd	sl, fp, [r8, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801c71c:	f00b fbc4 	bl	8027ea8 <__aeabi_dmul>
 801c720:	4652      	mov	r2, sl
 801c722:	4606      	mov	r6, r0
 801c724:	460f      	mov	r7, r1
 801c726:	465b      	mov	r3, fp
 801c728:	ec51 0b1a 	vmov	r0, r1, d10
 801c72c:	f00b fbbc 	bl	8027ea8 <__aeabi_dmul>
 801c730:	4602      	mov	r2, r0
 801c732:	460b      	mov	r3, r1
 801c734:	4630      	mov	r0, r6
 801c736:	4639      	mov	r1, r7
 801c738:	f00b f9fe 	bl	8027b38 <__aeabi_dsub>
 801c73c:	4602      	mov	r2, r0
 801c73e:	460b      	mov	r3, r1
 801c740:	e9d9 0104 	ldrd	r0, r1, [r9, #16]
 801c744:	f00b f9fa 	bl	8027b3c <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 801c748:	9b00      	ldr	r3, [sp, #0]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801c74a:	4652      	mov	r2, sl
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 801c74c:	ed93 8b04 	vldr	d8, [r3, #16]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 801c750:	ed93 9b06 	vldr	d9, [r3, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 801c754:	e9c9 0104 	strd	r0, r1, [r9, #16]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801c758:	465b      	mov	r3, fp
 801c75a:	ec51 0b1b 	vmov	r0, r1, d11
 801c75e:	f00b fba3 	bl	8027ea8 <__aeabi_dmul>
 801c762:	4622      	mov	r2, r4
 801c764:	4606      	mov	r6, r0
 801c766:	460f      	mov	r7, r1
 801c768:	462b      	mov	r3, r5
 801c76a:	ec51 0b1a 	vmov	r0, r1, d10
 801c76e:	f00b fb9b 	bl	8027ea8 <__aeabi_dmul>
 801c772:	4602      	mov	r2, r0
 801c774:	460b      	mov	r3, r1
 801c776:	4630      	mov	r0, r6
 801c778:	4639      	mov	r1, r7
 801c77a:	f00b f9df 	bl	8027b3c <__adddf3>
 801c77e:	4602      	mov	r2, r0
 801c780:	460b      	mov	r3, r1
 801c782:	e9d9 0106 	ldrd	r0, r1, [r9, #24]
 801c786:	f00b f9d9 	bl	8027b3c <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c78a:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 801c78e:	e9c9 0106 	strd	r0, r1, [r9, #24]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c792:	4620      	mov	r0, r4
 801c794:	4629      	mov	r1, r5
 801c796:	f00b fb87 	bl	8027ea8 <__aeabi_dmul>
 801c79a:	ec53 2b19 	vmov	r2, r3, d9
 801c79e:	4606      	mov	r6, r0
 801c7a0:	460f      	mov	r7, r1
 801c7a2:	4650      	mov	r0, sl
 801c7a4:	4659      	mov	r1, fp
 801c7a6:	f00b fb7f 	bl	8027ea8 <__aeabi_dmul>
 801c7aa:	4602      	mov	r2, r0
 801c7ac:	460b      	mov	r3, r1
 801c7ae:	4630      	mov	r0, r6
 801c7b0:	4639      	mov	r1, r7
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c7b2:	f8cd a018 	str.w	sl, [sp, #24]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c7b6:	f00b f9c1 	bl	8027b3c <__adddf3>
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c7ba:	f10b 4600 	add.w	r6, fp, #2147483648	; 0x80000000
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c7be:	4602      	mov	r2, r0
 801c7c0:	460b      	mov	r3, r1
 801c7c2:	ec51 0b1c 	vmov	r0, r1, d12
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c7c6:	9607      	str	r6, [sp, #28]
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c7c8:	f00b f9b8 	bl	8027b3c <__adddf3>
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c7cc:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c7d0:	4606      	mov	r6, r0
 801c7d2:	460f      	mov	r7, r1
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c7d4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801c7d8:	f00b fb66 	bl	8027ea8 <__aeabi_dmul>
            temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
 801c7dc:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c7e0:	ec53 2b19 	vmov	r2, r3, d9
 801c7e4:	4606      	mov	r6, r0
 801c7e6:	460f      	mov	r7, r1
 801c7e8:	4620      	mov	r0, r4
 801c7ea:	4629      	mov	r1, r5
 801c7ec:	f00b fb5c 	bl	8027ea8 <__aeabi_dmul>
 801c7f0:	4602      	mov	r2, r0
 801c7f2:	460b      	mov	r3, r1
 801c7f4:	4630      	mov	r0, r6
 801c7f6:	4639      	mov	r1, r7
 801c7f8:	f00b f9a0 	bl	8027b3c <__adddf3>
 801c7fc:	460b      	mov	r3, r1
 801c7fe:	4602      	mov	r2, r0
 801c800:	ec51 0b1d 	vmov	r0, r1, d13
 801c804:	f00b f99a 	bl	8027b3c <__adddf3>
 801c808:	9b00      	ldr	r3, [sp, #0]
 801c80a:	3310      	adds	r3, #16
 801c80c:	9300      	str	r3, [sp, #0]
          for (k = j + 1; k < n2; k++) {
 801c80e:	9b02      	ldr	r3, [sp, #8]
 801c810:	f108 0810 	add.w	r8, r8, #16
 801c814:	4543      	cmp	r3, r8
            temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
 801c816:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = j + 1; k < n2; k++) {
 801c81a:	f109 0910 	add.w	r9, r9, #16
 801c81e:	f47f af75 	bne.w	801c70c <cblas_zhemm+0xe4c>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c822:	ed9d 8b08 	vldr	d8, [sp, #32]
 801c826:	ec53 2b1c 	vmov	r2, r3, d12
 801c82a:	ec51 0b18 	vmov	r0, r1, d8
 801c82e:	f00b fb3b 	bl	8027ea8 <__aeabi_dmul>
 801c832:	e9dd 780a 	ldrd	r7, r8, [sp, #40]	; 0x28
 801c836:	ec5a 9b1d 	vmov	r9, sl, d13
 801c83a:	4604      	mov	r4, r0
 801c83c:	460d      	mov	r5, r1
 801c83e:	ee1d 2a10 	vmov	r2, s26
 801c842:	4653      	mov	r3, sl
 801c844:	4638      	mov	r0, r7
 801c846:	4641      	mov	r1, r8
 801c848:	f00b fb2e 	bl	8027ea8 <__aeabi_dmul>
 801c84c:	4602      	mov	r2, r0
 801c84e:	460b      	mov	r3, r1
 801c850:	4620      	mov	r0, r4
 801c852:	4629      	mov	r1, r5
 801c854:	f00b f970 	bl	8027b38 <__aeabi_dsub>
 801c858:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 801c85a:	4602      	mov	r2, r0
 801c85c:	460b      	mov	r3, r1
 801c85e:	e9d6 0100 	ldrd	r0, r1, [r6]
 801c862:	f00b f96b 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c866:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c86a:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c86e:	4653      	mov	r3, sl
 801c870:	ec51 0b18 	vmov	r0, r1, d8
 801c874:	f00b fb18 	bl	8027ea8 <__aeabi_dmul>
 801c878:	ec53 2b1c 	vmov	r2, r3, d12
 801c87c:	4604      	mov	r4, r0
 801c87e:	460d      	mov	r5, r1
 801c880:	4638      	mov	r0, r7
 801c882:	4641      	mov	r1, r8
 801c884:	f00b fb10 	bl	8027ea8 <__aeabi_dmul>
 801c888:	4602      	mov	r2, r0
 801c88a:	460b      	mov	r3, r1
 801c88c:	4620      	mov	r0, r4
 801c88e:	4629      	mov	r1, r5
 801c890:	f00b f954 	bl	8027b3c <__adddf3>
 801c894:	4602      	mov	r2, r0
 801c896:	460b      	mov	r3, r1
 801c898:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801c89c:	f00b f94e 	bl	8027b3c <__adddf3>
 801c8a0:	9b04      	ldr	r3, [sp, #16]
 801c8a2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801c8a4:	3310      	adds	r3, #16
 801c8a6:	9304      	str	r3, [sp, #16]
 801c8a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801c8aa:	4413      	add	r3, r2
 801c8ac:	930c      	str	r3, [sp, #48]	; 0x30
 801c8ae:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801c8b0:	9b02      	ldr	r3, [sp, #8]
 801c8b2:	4413      	add	r3, r2
 801c8b4:	9302      	str	r3, [sp, #8]
 801c8b6:	f106 0310 	add.w	r3, r6, #16
 801c8ba:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 801c8be:	930f      	str	r3, [sp, #60]	; 0x3c
 801c8c0:	e6b1      	b.n	801c626 <cblas_zhemm+0xd66>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801c8c2:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801c8c4:	2b00      	cmp	r3, #0
 801c8c6:	dc78      	bgt.n	801c9ba <cblas_zhemm+0x10fa>
 801c8c8:	2301      	movs	r3, #1
 801c8ca:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c8cc:	429a      	cmp	r2, r3
 801c8ce:	bfb4      	ite	lt
 801c8d0:	200d      	movlt	r0, #13
 801c8d2:	200a      	movge	r0, #10
 801c8d4:	f7ff b830 	b.w	801b938 <cblas_zhemm+0x78>
 801c8d8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c8da:	e4b7      	b.n	801c24c <cblas_zhemm+0x98c>
      for (i = 0; i < n1; i++) {
 801c8dc:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801c8de:	9919      	ldr	r1, [sp, #100]	; 0x64
 801c8e0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801c8e2:	440a      	add	r2, r1
 801c8e4:	9214      	str	r2, [sp, #80]	; 0x50
 801c8e6:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801c8e8:	9a11      	ldr	r2, [sp, #68]	; 0x44
 801c8ea:	440a      	add	r2, r1
 801c8ec:	9211      	str	r2, [sp, #68]	; 0x44
 801c8ee:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801c8f0:	3301      	adds	r3, #1
 801c8f2:	429a      	cmp	r2, r3
 801c8f4:	9316      	str	r3, [sp, #88]	; 0x58
 801c8f6:	f47f ab01 	bne.w	801befc <cblas_zhemm+0x63c>
 801c8fa:	f7ff b8b3 	b.w	801ba64 <cblas_zhemm+0x1a4>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c8fe:	2200      	movs	r2, #0
 801c900:	2300      	movs	r3, #0
 801c902:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801c906:	f00b facf 	bl	8027ea8 <__aeabi_dmul>
 801c90a:	2200      	movs	r2, #0
 801c90c:	4680      	mov	r8, r0
 801c90e:	4689      	mov	r9, r1
 801c910:	2300      	movs	r3, #0
 801c912:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801c916:	f00b fac7 	bl	8027ea8 <__aeabi_dmul>
 801c91a:	4604      	mov	r4, r0
 801c91c:	460d      	mov	r5, r1
 801c91e:	4622      	mov	r2, r4
 801c920:	462b      	mov	r3, r5
 801c922:	4640      	mov	r0, r8
 801c924:	4649      	mov	r1, r9
 801c926:	f00b f907 	bl	8027b38 <__aeabi_dsub>
 801c92a:	460b      	mov	r3, r1
 801c92c:	9916      	ldr	r1, [sp, #88]	; 0x58
 801c92e:	4602      	mov	r2, r0
 801c930:	e951 0104 	ldrd	r0, r1, [r1, #-16]
 801c934:	f00b f902 	bl	8027b3c <__adddf3>
 801c938:	4606      	mov	r6, r0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c93a:	4620      	mov	r0, r4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c93c:	9c16      	ldr	r4, [sp, #88]	; 0x58
 801c93e:	460f      	mov	r7, r1
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c940:	4642      	mov	r2, r8
 801c942:	464b      	mov	r3, r9
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801c944:	e944 6704 	strd	r6, r7, [r4, #-16]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801c948:	4629      	mov	r1, r5
 801c94a:	f00b f8f7 	bl	8027b3c <__adddf3>
 801c94e:	4602      	mov	r2, r0
 801c950:	460b      	mov	r3, r1
 801c952:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801c956:	f00b f8f1 	bl	8027b3c <__adddf3>
 801c95a:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (i = 0; i < n1; i++) {
 801c95e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801c960:	991c      	ldr	r1, [sp, #112]	; 0x70
 801c962:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801c964:	440a      	add	r2, r1
 801c966:	9216      	str	r2, [sp, #88]	; 0x58
 801c968:	9918      	ldr	r1, [sp, #96]	; 0x60
 801c96a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801c96c:	440a      	add	r2, r1
 801c96e:	921a      	str	r2, [sp, #104]	; 0x68
 801c970:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801c972:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801c974:	440a      	add	r2, r1
 801c976:	9219      	str	r2, [sp, #100]	; 0x64
 801c978:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801c97a:	3301      	adds	r3, #1
 801c97c:	429a      	cmp	r2, r3
 801c97e:	931b      	str	r3, [sp, #108]	; 0x6c
 801c980:	f47f ae3d 	bne.w	801c5fe <cblas_zhemm+0xd3e>
 801c984:	f7ff b86e 	b.w	801ba64 <cblas_zhemm+0x1a4>
  CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 801c988:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c98a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801c98c:	2b01      	cmp	r3, #1
 801c98e:	bfb8      	it	lt
 801c990:	2301      	movlt	r3, #1
 801c992:	429a      	cmp	r2, r3
 801c994:	db99      	blt.n	801c8ca <cblas_zhemm+0x100a>
 801c996:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c998:	429a      	cmp	r2, r3
 801c99a:	bfac      	ite	ge
 801c99c:	2008      	movge	r0, #8
 801c99e:	200d      	movlt	r0, #13
 801c9a0:	f7fe bfca 	b.w	801b938 <cblas_zhemm+0x78>
 801c9a4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801c9a6:	931d      	str	r3, [sp, #116]	; 0x74
 801c9a8:	e5e7      	b.n	801c57a <cblas_zhemm+0xcba>
 801c9aa:	3865      	subs	r0, #101	; 0x65
 801c9ac:	2801      	cmp	r0, #1
 801c9ae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801c9b0:	bf94      	ite	ls
 801c9b2:	2000      	movls	r0, #0
 801c9b4:	2001      	movhi	r0, #1
 801c9b6:	f7fe bfa4 	b.w	801b902 <cblas_zhemm+0x42>
 801c9ba:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801c9bc:	2b00      	cmp	r3, #0
 801c9be:	bfcc      	ite	gt
 801c9c0:	2005      	movgt	r0, #5
 801c9c2:	200d      	movle	r0, #13
 801c9c4:	f7fe bfb8 	b.w	801b938 <cblas_zhemm+0x78>
 801c9c8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801c9ca:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801c9cc:	2b01      	cmp	r3, #1
 801c9ce:	bfb8      	it	lt
 801c9d0:	2301      	movlt	r3, #1
 801c9d2:	429a      	cmp	r2, r3
 801c9d4:	f6ff af79 	blt.w	801c8ca <cblas_zhemm+0x100a>
 801c9d8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801c9da:	429a      	cmp	r2, r3
 801c9dc:	bfac      	ite	ge
 801c9de:	2005      	movge	r0, #5
 801c9e0:	200d      	movlt	r0, #13
 801c9e2:	f7fe bfa9 	b.w	801b938 <cblas_zhemm+0x78>
 801c9e6:	bf00      	nop

0801c9e8 <cblas_zhemv>:
void
cblas_zhemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *A, const int lda,
             const void *X, const int incX, const void *beta, void *Y,
             const int incY)
{
 801c9e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c9ec:	ed2d 8b10 	vpush	{d8-d15}
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801c9f0:	2866      	cmp	r0, #102	; 0x66
 801c9f2:	b09b      	sub	sp, #108	; 0x6c
 801c9f4:	461d      	mov	r5, r3
 801c9f6:	bf0c      	ite	eq
 801c9f8:	f04f 33ff 	moveq.w	r3, #4294967295
 801c9fc:	2301      	movne	r3, #1
 801c9fe:	9312      	str	r3, [sp, #72]	; 0x48
 801ca00:	9b34      	ldr	r3, [sp, #208]	; 0xd0
 801ca02:	930e      	str	r3, [sp, #56]	; 0x38
 801ca04:	9b35      	ldr	r3, [sp, #212]	; 0xd4
 801ca06:	9305      	str	r3, [sp, #20]
 801ca08:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 801ca0a:	9313      	str	r3, [sp, #76]	; 0x4c
 801ca0c:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 801ca0e:	930d      	str	r3, [sp, #52]	; 0x34
 801ca10:	e9dd 4338 	ldrd	r4, r3, [sp, #224]	; 0xe0
 801ca14:	910b      	str	r1, [sp, #44]	; 0x2c
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801ca16:	3979      	subs	r1, #121	; 0x79
 801ca18:	9315      	str	r3, [sp, #84]	; 0x54
 801ca1a:	2901      	cmp	r1, #1
 801ca1c:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801ca1e:	9004      	str	r0, [sp, #16]
 801ca20:	920a      	str	r2, [sp, #40]	; 0x28
 801ca22:	930c      	str	r3, [sp, #48]	; 0x30
 801ca24:	f240 8150 	bls.w	801ccc8 <cblas_zhemv+0x2e0>
 801ca28:	2002      	movs	r0, #2
 801ca2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ca2c:	2b00      	cmp	r3, #0
 801ca2e:	f2c0 813d 	blt.w	801ccac <cblas_zhemv+0x2c4>
 801ca32:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ca34:	9a05      	ldr	r2, [sp, #20]
 801ca36:	2b01      	cmp	r3, #1
 801ca38:	bfb8      	it	lt
 801ca3a:	2301      	movlt	r3, #1
 801ca3c:	4293      	cmp	r3, r2
 801ca3e:	f340 80ea 	ble.w	801cc16 <cblas_zhemv+0x22e>
 801ca42:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801ca44:	2b00      	cmp	r3, #0
 801ca46:	f040 80f2 	bne.w	801cc2e <cblas_zhemv+0x246>
 801ca4a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801ca4c:	2b00      	cmp	r3, #0
 801ca4e:	bf0c      	ite	eq
 801ca50:	200b      	moveq	r0, #11
 801ca52:	2008      	movne	r0, #8
 801ca54:	4a9f      	ldr	r2, [pc, #636]	; (801ccd4 <cblas_zhemv+0x2ec>)
 801ca56:	49a0      	ldr	r1, [pc, #640]	; (801ccd8 <cblas_zhemv+0x2f0>)
 801ca58:	f00a fff6 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801ca5c:	ed95 7b00 	vldr	d7, [r5]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801ca60:	2200      	movs	r2, #0
 801ca62:	ec51 0b17 	vmov	r0, r1, d7
 801ca66:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 801ca68:	ed8d 7b06 	vstr	d7, [sp, #24]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801ca6c:	f00b fc84 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801ca70:	ed95 7b02 	vldr	d7, [r5, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801ca74:	ed94 8b00 	vldr	d8, [r4]
    const BASE beta_imag = CONST_IMAG0(beta);
 801ca78:	ed94 9b02 	vldr	d9, [r4, #8]
    const BASE beta_real = CONST_REAL0(beta);
 801ca7c:	eeb0 ba48 	vmov.f32	s22, s16
 801ca80:	eef0 ba68 	vmov.f32	s23, s17
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801ca84:	ed8d 7b08 	vstr	d7, [sp, #32]
    const BASE beta_imag = CONST_IMAG0(beta);
 801ca88:	eeb0 ca49 	vmov.f32	s24, s18
 801ca8c:	eef0 ca69 	vmov.f32	s25, s19
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801ca90:	2800      	cmp	r0, #0
 801ca92:	f000 8085 	beq.w	801cba0 <cblas_zhemv+0x1b8>
 801ca96:	ec51 0b17 	vmov	r0, r1, d7
 801ca9a:	2200      	movs	r2, #0
 801ca9c:	2300      	movs	r3, #0
 801ca9e:	f00b fc6b 	bl	8028378 <__aeabi_dcmpeq>
 801caa2:	2800      	cmp	r0, #0
 801caa4:	d07c      	beq.n	801cba0 <cblas_zhemv+0x1b8>
        && (beta_real == 1.0 && beta_imag == 0.0))
 801caa6:	4b8d      	ldr	r3, [pc, #564]	; (801ccdc <cblas_zhemv+0x2f4>)
 801caa8:	2200      	movs	r2, #0
 801caaa:	ec51 0b18 	vmov	r0, r1, d8
 801caae:	f00b fc63 	bl	8028378 <__aeabi_dcmpeq>
 801cab2:	2200      	movs	r2, #0
 801cab4:	2300      	movs	r3, #0
 801cab6:	2800      	cmp	r0, #0
 801cab8:	f000 82ee 	beq.w	801d098 <cblas_zhemv+0x6b0>
 801cabc:	ec51 0b19 	vmov	r0, r1, d9
 801cac0:	f00b fc5a 	bl	8028378 <__aeabi_dcmpeq>
 801cac4:	2800      	cmp	r0, #0
 801cac6:	f040 80ec 	bne.w	801cca2 <cblas_zhemv+0x2ba>
      INDEX iy = OFFSET(N, incY);
 801caca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801cacc:	2b00      	cmp	r3, #0
 801cace:	f340 82dd 	ble.w	801d08c <cblas_zhemv+0x6a4>
 801cad2:	f04f 0a00 	mov.w	sl, #0
      for (i = 0; i < N; i++) {
 801cad6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801cad8:	2b00      	cmp	r3, #0
 801cada:	dd3f      	ble.n	801cb5c <cblas_zhemv+0x174>
 801cadc:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801cade:	eb02 130a 	add.w	r3, r2, sl, lsl #4
 801cae2:	f103 0b08 	add.w	fp, r3, #8
 801cae6:	469a      	mov	sl, r3
 801cae8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801caea:	011f      	lsls	r7, r3, #4
 801caec:	2300      	movs	r3, #0
 801caee:	461e      	mov	r6, r3
        const BASE y_real = REAL(Y, iy);
 801caf0:	e95b 8902 	ldrd	r8, r9, [fp, #-8]
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801caf4:	ec51 0b1b 	vmov	r0, r1, d11
 801caf8:	4642      	mov	r2, r8
 801cafa:	464b      	mov	r3, r9
        const BASE y_imag = IMAG(Y, iy);
 801cafc:	e9da 4502 	ldrd	r4, r5, [sl, #8]
        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
 801cb00:	f00b f9d2 	bl	8027ea8 <__aeabi_dmul>
 801cb04:	4622      	mov	r2, r4
 801cb06:	462b      	mov	r3, r5
 801cb08:	ec41 0b1a 	vmov	d10, r0, r1
 801cb0c:	ec51 0b1c 	vmov	r0, r1, d12
 801cb10:	f00b f9ca 	bl	8027ea8 <__aeabi_dmul>
 801cb14:	4602      	mov	r2, r0
 801cb16:	460b      	mov	r3, r1
 801cb18:	ec51 0b1a 	vmov	r0, r1, d10
 801cb1c:	f00b f80c 	bl	8027b38 <__aeabi_dsub>
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801cb20:	4642      	mov	r2, r8
        REAL(Y, iy) = tmpR;
 801cb22:	e94b 0102 	strd	r0, r1, [fp, #-8]
        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
 801cb26:	464b      	mov	r3, r9
 801cb28:	ec51 0b1c 	vmov	r0, r1, d12
 801cb2c:	f00b f9bc 	bl	8027ea8 <__aeabi_dmul>
 801cb30:	4622      	mov	r2, r4
 801cb32:	462b      	mov	r3, r5
 801cb34:	4604      	mov	r4, r0
 801cb36:	460d      	mov	r5, r1
 801cb38:	ec51 0b1b 	vmov	r0, r1, d11
 801cb3c:	f00b f9b4 	bl	8027ea8 <__aeabi_dmul>
 801cb40:	460b      	mov	r3, r1
 801cb42:	4602      	mov	r2, r0
 801cb44:	4629      	mov	r1, r5
 801cb46:	4620      	mov	r0, r4
 801cb48:	f00a fff8 	bl	8027b3c <__adddf3>
      for (i = 0; i < N; i++) {
 801cb4c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801cb4e:	3601      	adds	r6, #1
 801cb50:	42b3      	cmp	r3, r6
        IMAG(Y, iy) = tmpI;
 801cb52:	e9ca 0102 	strd	r0, r1, [sl, #8]
      for (i = 0; i < N; i++) {
 801cb56:	44bb      	add	fp, r7
 801cb58:	44ba      	add	sl, r7
 801cb5a:	d1c9      	bne.n	801caf0 <cblas_zhemv+0x108>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801cb5c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801cb60:	2200      	movs	r2, #0
 801cb62:	2300      	movs	r3, #0
 801cb64:	f00b fc08 	bl	8028378 <__aeabi_dcmpeq>
 801cb68:	b140      	cbz	r0, 801cb7c <cblas_zhemv+0x194>
 801cb6a:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801cb6e:	2200      	movs	r2, #0
 801cb70:	2300      	movs	r3, #0
 801cb72:	f00b fc01 	bl	8028378 <__aeabi_dcmpeq>
 801cb76:	2800      	cmp	r0, #0
 801cb78:	f040 8093 	bne.w	801cca2 <cblas_zhemv+0x2ba>
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801cb7c:	9b04      	ldr	r3, [sp, #16]
 801cb7e:	2b65      	cmp	r3, #101	; 0x65
 801cb80:	f000 80b0 	beq.w	801cce4 <cblas_zhemv+0x2fc>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801cb84:	9b04      	ldr	r3, [sp, #16]
 801cb86:	2b66      	cmp	r3, #102	; 0x66
 801cb88:	f000 8278 	beq.w	801d07c <cblas_zhemv+0x694>
      BLAS_ERROR("unrecognized operation");
 801cb8c:	4a54      	ldr	r2, [pc, #336]	; (801cce0 <cblas_zhemv+0x2f8>)
 801cb8e:	4952      	ldr	r1, [pc, #328]	; (801ccd8 <cblas_zhemv+0x2f0>)
 801cb90:	2000      	movs	r0, #0
#define BASE double
#include "source_hemv.h"
#undef BASE
}
 801cb92:	b01b      	add	sp, #108	; 0x6c
 801cb94:	ecbd 8b10 	vpop	{d8-d15}
 801cb98:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801cb9c:	f00a bf54 	b.w	8027a48 <cblas_xerbla>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801cba0:	ec51 0b1b 	vmov	r0, r1, d11
 801cba4:	2200      	movs	r2, #0
 801cba6:	2300      	movs	r3, #0
 801cba8:	f00b fbe6 	bl	8028378 <__aeabi_dcmpeq>
 801cbac:	b308      	cbz	r0, 801cbf2 <cblas_zhemv+0x20a>
 801cbae:	ec51 0b1c 	vmov	r0, r1, d12
 801cbb2:	2200      	movs	r2, #0
 801cbb4:	2300      	movs	r3, #0
 801cbb6:	f00b fbdf 	bl	8028378 <__aeabi_dcmpeq>
 801cbba:	2800      	cmp	r0, #0
 801cbbc:	d085      	beq.n	801caca <cblas_zhemv+0xe2>
      INDEX iy = OFFSET(N, incY);
 801cbbe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801cbc0:	2a00      	cmp	r2, #0
 801cbc2:	f340 8271 	ble.w	801d0a8 <cblas_zhemv+0x6c0>
 801cbc6:	2300      	movs	r3, #0
      for (i = 0; i < N; i++) {
 801cbc8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801cbca:	2a00      	cmp	r2, #0
 801cbcc:	ddc6      	ble.n	801cb5c <cblas_zhemv+0x174>
 801cbce:	9a15      	ldr	r2, [sp, #84]	; 0x54
 801cbd0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801cbd2:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801cbd6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
        REAL(Y, iy) = 0.0;
 801cbd8:	2000      	movs	r0, #0
 801cbda:	0114      	lsls	r4, r2, #4
 801cbdc:	2100      	movs	r1, #0
      for (i = 0; i < N; i++) {
 801cbde:	2200      	movs	r2, #0
 801cbe0:	3201      	adds	r2, #1
 801cbe2:	4295      	cmp	r5, r2
        REAL(Y, iy) = 0.0;
 801cbe4:	e9c3 0100 	strd	r0, r1, [r3]
        IMAG(Y, iy) = 0.0;
 801cbe8:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (i = 0; i < N; i++) {
 801cbec:	4423      	add	r3, r4
 801cbee:	d1f7      	bne.n	801cbe0 <cblas_zhemv+0x1f8>
 801cbf0:	e7b4      	b.n	801cb5c <cblas_zhemv+0x174>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 801cbf2:	4b3a      	ldr	r3, [pc, #232]	; (801ccdc <cblas_zhemv+0x2f4>)
 801cbf4:	ec51 0b1b 	vmov	r0, r1, d11
 801cbf8:	2200      	movs	r2, #0
 801cbfa:	f00b fbbd 	bl	8028378 <__aeabi_dcmpeq>
 801cbfe:	2800      	cmp	r0, #0
 801cc00:	f43f af63 	beq.w	801caca <cblas_zhemv+0xe2>
 801cc04:	ec51 0b1c 	vmov	r0, r1, d12
 801cc08:	2200      	movs	r2, #0
 801cc0a:	2300      	movs	r3, #0
 801cc0c:	f00b fbb4 	bl	8028378 <__aeabi_dcmpeq>
 801cc10:	2800      	cmp	r0, #0
 801cc12:	d1a3      	bne.n	801cb5c <cblas_zhemv+0x174>
 801cc14:	e759      	b.n	801caca <cblas_zhemv+0xe2>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801cc16:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801cc18:	2b00      	cmp	r3, #0
 801cc1a:	f43f af16 	beq.w	801ca4a <cblas_zhemv+0x62>
 801cc1e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801cc20:	2b00      	cmp	r3, #0
 801cc22:	f000 8415 	beq.w	801d450 <cblas_zhemv+0xa68>
 801cc26:	2800      	cmp	r0, #0
 801cc28:	f43f af18 	beq.w	801ca5c <cblas_zhemv+0x74>
 801cc2c:	e712      	b.n	801ca54 <cblas_zhemv+0x6c>
 801cc2e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801cc30:	2b00      	cmp	r3, #0
 801cc32:	bf0c      	ite	eq
 801cc34:	200b      	moveq	r0, #11
 801cc36:	2006      	movne	r0, #6
 801cc38:	e70c      	b.n	801ca54 <cblas_zhemv+0x6c>
 801cc3a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801cc3c:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801cc3e:	9e15      	ldr	r6, [sp, #84]	; 0x54
 801cc40:	fb03 250a 	mla	r5, r3, sl, r2
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cc44:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801cc48:	2200      	movs	r2, #0
 801cc4a:	2300      	movs	r3, #0
 801cc4c:	f00b f92c 	bl	8027ea8 <__aeabi_dmul>
 801cc50:	2200      	movs	r2, #0
 801cc52:	4680      	mov	r8, r0
 801cc54:	4689      	mov	r9, r1
 801cc56:	2300      	movs	r3, #0
 801cc58:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801cc5c:	f00b f924 	bl	8027ea8 <__aeabi_dmul>
 801cc60:	eb06 1405 	add.w	r4, r6, r5, lsl #4
 801cc64:	460f      	mov	r7, r1
 801cc66:	4606      	mov	r6, r0
 801cc68:	4625      	mov	r5, r4
 801cc6a:	4640      	mov	r0, r8
 801cc6c:	4649      	mov	r1, r9
 801cc6e:	4632      	mov	r2, r6
 801cc70:	463b      	mov	r3, r7
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cc72:	f00a ff61 	bl	8027b38 <__aeabi_dsub>
 801cc76:	4602      	mov	r2, r0
 801cc78:	460b      	mov	r3, r1
 801cc7a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801cc7e:	f00a ff5d 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801cc82:	4642      	mov	r2, r8
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cc84:	e9c5 0100 	strd	r0, r1, [r5]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801cc88:	464b      	mov	r3, r9
 801cc8a:	4630      	mov	r0, r6
 801cc8c:	4639      	mov	r1, r7
 801cc8e:	f00a ff55 	bl	8027b3c <__adddf3>
 801cc92:	4602      	mov	r2, r0
 801cc94:	460b      	mov	r3, r1
 801cc96:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801cc9a:	f00a ff4f 	bl	8027b3c <__adddf3>
 801cc9e:	e9c4 0102 	strd	r0, r1, [r4, #8]
 801cca2:	b01b      	add	sp, #108	; 0x6c
 801cca4:	ecbd 8b10 	vpop	{d8-d15}
 801cca8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801ccac:	9b05      	ldr	r3, [sp, #20]
 801ccae:	2b00      	cmp	r3, #0
 801ccb0:	f77f aec7 	ble.w	801ca42 <cblas_zhemv+0x5a>
 801ccb4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801ccb6:	2b00      	cmp	r3, #0
 801ccb8:	f43f aec7 	beq.w	801ca4a <cblas_zhemv+0x62>
 801ccbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801ccbe:	2b00      	cmp	r3, #0
 801ccc0:	bf0c      	ite	eq
 801ccc2:	200b      	moveq	r0, #11
 801ccc4:	2003      	movne	r0, #3
 801ccc6:	e6c5      	b.n	801ca54 <cblas_zhemv+0x6c>
 801ccc8:	3865      	subs	r0, #101	; 0x65
 801ccca:	2801      	cmp	r0, #1
 801cccc:	bf94      	ite	ls
 801ccce:	2000      	movls	r0, #0
 801ccd0:	2001      	movhi	r0, #1
 801ccd2:	e6aa      	b.n	801ca2a <cblas_zhemv+0x42>
 801ccd4:	08030378 	.word	0x08030378
 801ccd8:	08030700 	.word	0x08030700
 801ccdc:	3ff00000 	.word	0x3ff00000
 801cce0:	080305a8 	.word	0x080305a8
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801cce4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801cce6:	2b79      	cmp	r3, #121	; 0x79
 801cce8:	f000 81ea 	beq.w	801d0c0 <cblas_zhemv+0x6d8>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 801ccec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ccee:	2b7a      	cmp	r3, #122	; 0x7a
 801ccf0:	f47f af4c 	bne.w	801cb8c <cblas_zhemv+0x1a4>
      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 801ccf4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801ccf6:	2b00      	cmp	r3, #0
 801ccf8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ccfa:	bfd8      	it	le
 801ccfc:	9a0d      	ldrle	r2, [sp, #52]	; 0x34
 801ccfe:	f103 33ff 	add.w	r3, r3, #4294967295
 801cd02:	930b      	str	r3, [sp, #44]	; 0x2c
 801cd04:	bfd8      	it	le
 801cd06:	4252      	negle	r2, r2
 801cd08:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801cd0a:	bfd8      	it	le
 801cd0c:	435a      	mulle	r2, r3
 801cd0e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801cd10:	bfc8      	it	gt
 801cd12:	2200      	movgt	r2, #0
 801cd14:	fb01 2803 	mla	r8, r1, r3, r2
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801cd18:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801cd1a:	2b00      	cmp	r3, #0
 801cd1c:	bfdc      	itt	le
 801cd1e:	425b      	negle	r3, r3
 801cd20:	fb01 fb03 	mulle.w	fp, r1, r3
 801cd24:	e9dd 150b 	ldrd	r1, r5, [sp, #44]	; 0x2c
      for (i = N; i > 0 && i--;) {
 801cd28:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801cd2a:	bfc8      	it	gt
 801cd2c:	f04f 0b00 	movgt.w	fp, #0
 801cd30:	fb01 b005 	mla	r0, r1, r5, fp
      for (i = N; i > 0 && i--;) {
 801cd34:	2b00      	cmp	r3, #0
      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
 801cd36:	9018      	str	r0, [sp, #96]	; 0x60
      for (i = N; i > 0 && i--;) {
 801cd38:	ddb3      	ble.n	801cca2 <cblas_zhemv+0x2ba>
 801cd3a:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 801cd3c:	9e05      	ldr	r6, [sp, #20]
 801cd3e:	eb07 1808 	add.w	r8, r7, r8, lsl #4
 801cd42:	f108 0308 	add.w	r3, r8, #8
 801cd46:	930a      	str	r3, [sp, #40]	; 0x28
 801cd48:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801cd4a:	4634      	mov	r4, r6
 801cd4c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801cd50:	fb01 f404 	mul.w	r4, r1, r4
 801cd54:	9310      	str	r3, [sp, #64]	; 0x40
 801cd56:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801cd58:	eb01 0e04 	add.w	lr, r1, r4
 801cd5c:	ea6f 0c06 	mvn.w	ip, r6
 801cd60:	ebc6 7706 	rsb	r7, r6, r6, lsl #28
 801cd64:	eb03 120e 	add.w	r2, r3, lr, lsl #4
 801cd68:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801cd6a:	9918      	ldr	r1, [sp, #96]	; 0x60
 801cd6c:	9200      	str	r2, [sp, #0]
 801cd6e:	eb03 1304 	add.w	r3, r3, r4, lsl #4
 801cd72:	930e      	str	r3, [sp, #56]	; 0x38
 801cd74:	ea4f 130c 	mov.w	r3, ip, lsl #4
 801cd78:	ebc6 7606 	rsb	r6, r6, r6, lsl #28
 801cd7c:	9313      	str	r3, [sp, #76]	; 0x4c
 801cd7e:	013b      	lsls	r3, r7, #4
 801cd80:	9314      	str	r3, [sp, #80]	; 0x50
 801cd82:	0133      	lsls	r3, r6, #4
 801cd84:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801cd86:	9316      	str	r3, [sp, #88]	; 0x58
 801cd88:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 801cd8c:	9d15      	ldr	r5, [sp, #84]	; 0x54
 801cd8e:	0133      	lsls	r3, r6, #4
 801cd90:	eb05 1101 	add.w	r1, r5, r1, lsl #4
 801cd94:	9304      	str	r3, [sp, #16]
 801cd96:	0103      	lsls	r3, r0, #4
 801cd98:	eb05 150b 	add.w	r5, r5, fp, lsl #4
 801cd9c:	9317      	str	r3, [sp, #92]	; 0x5c
 801cd9e:	f101 0308 	add.w	r3, r1, #8
 801cda2:	930d      	str	r3, [sp, #52]	; 0x34
 801cda4:	9511      	str	r5, [sp, #68]	; 0x44
 801cda6:	f105 0308 	add.w	r3, r5, #8
 801cdaa:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801cdac:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801cdae:	930f      	str	r3, [sp, #60]	; 0x3c
 801cdb0:	012b      	lsls	r3, r5, #4
 801cdb2:	9119      	str	r1, [sp, #100]	; 0x64
 801cdb4:	9305      	str	r3, [sp, #20]
        BASE x_real = CONST_REAL(X, ix);
 801cdb6:	9c0a      	ldr	r4, [sp, #40]	; 0x28
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801cdb8:	ed9d 8b06 	vldr	d8, [sp, #24]
        BASE x_real = CONST_REAL(X, ix);
 801cdbc:	e954 6702 	ldrd	r6, r7, [r4, #-8]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801cdc0:	ec51 0b18 	vmov	r0, r1, d8
 801cdc4:	4632      	mov	r2, r6
 801cdc6:	463b      	mov	r3, r7
 801cdc8:	f00b f86e 	bl	8027ea8 <__aeabi_dmul>
        BASE x_imag = CONST_IMAG(X, ix);
 801cdcc:	e9d4 8900 	ldrd	r8, r9, [r4]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801cdd0:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 801cdd4:	4642      	mov	r2, r8
 801cdd6:	464b      	mov	r3, r9
 801cdd8:	4604      	mov	r4, r0
 801cdda:	460d      	mov	r5, r1
 801cddc:	4650      	mov	r0, sl
 801cdde:	4659      	mov	r1, fp
 801cde0:	f00b f862 	bl	8027ea8 <__aeabi_dmul>
 801cde4:	4602      	mov	r2, r0
 801cde6:	460b      	mov	r3, r1
 801cde8:	4620      	mov	r0, r4
 801cdea:	4629      	mov	r1, r5
 801cdec:	f00a fea4 	bl	8027b38 <__aeabi_dsub>
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801cdf0:	4642      	mov	r2, r8
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801cdf2:	4604      	mov	r4, r0
 801cdf4:	460d      	mov	r5, r1
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801cdf6:	464b      	mov	r3, r9
 801cdf8:	ec51 0b18 	vmov	r0, r1, d8
 801cdfc:	f00b f854 	bl	8027ea8 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801ce00:	46a0      	mov	r8, r4
 801ce02:	46a9      	mov	r9, r5
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801ce04:	4632      	mov	r2, r6
 801ce06:	463b      	mov	r3, r7
 801ce08:	4604      	mov	r4, r0
 801ce0a:	460d      	mov	r5, r1
 801ce0c:	4650      	mov	r0, sl
 801ce0e:	4659      	mov	r1, fp
 801ce10:	f00b f84a 	bl	8027ea8 <__aeabi_dmul>
 801ce14:	4602      	mov	r2, r0
 801ce16:	460b      	mov	r3, r1
 801ce18:	4620      	mov	r0, r4
 801ce1a:	4629      	mov	r1, r5
 801ce1c:	f00a fe8e 	bl	8027b3c <__adddf3>
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 801ce20:	9b00      	ldr	r3, [sp, #0]
 801ce22:	e9d3 4500 	ldrd	r4, r5, [r3]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801ce26:	4606      	mov	r6, r0
 801ce28:	460f      	mov	r7, r1
        REAL(Y, iy) += temp1_real * Aii_real;
 801ce2a:	4640      	mov	r0, r8
 801ce2c:	4649      	mov	r1, r9
 801ce2e:	4622      	mov	r2, r4
 801ce30:	462b      	mov	r3, r5
 801ce32:	f00b f839 	bl	8027ea8 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801ce36:	ec49 8b1d 	vmov	d13, r8, r9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801ce3a:	46b9      	mov	r9, r7
        REAL(Y, iy) += temp1_real * Aii_real;
 801ce3c:	9f0d      	ldr	r7, [sp, #52]	; 0x34
 801ce3e:	4602      	mov	r2, r0
 801ce40:	460b      	mov	r3, r1
 801ce42:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 801ce46:	f00a fe79 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801ce4a:	4622      	mov	r2, r4
        REAL(Y, iy) += temp1_real * Aii_real;
 801ce4c:	e947 0102 	strd	r0, r1, [r7, #-8]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801ce50:	462b      	mov	r3, r5
 801ce52:	4630      	mov	r0, r6
 801ce54:	4649      	mov	r1, r9
 801ce56:	f00b f827 	bl	8027ea8 <__aeabi_dmul>
 801ce5a:	460b      	mov	r3, r1
 801ce5c:	4602      	mov	r2, r0
 801ce5e:	e9d7 0100 	ldrd	r0, r1, [r7]
 801ce62:	f00a fe6b 	bl	8027b3c <__adddf3>
        for (j = j_min; j < j_max; j++) {
 801ce66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801ce68:	46b0      	mov	r8, r6
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801ce6a:	e9c7 0100 	strd	r0, r1, [r7]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801ce6e:	ec49 8b1e 	vmov	d14, r8, r9
        for (j = j_min; j < j_max; j++) {
 801ce72:	2b00      	cmp	r3, #0
 801ce74:	f000 82ce 	beq.w	801d414 <cblas_zhemv+0xa2c>
 801ce78:	9812      	ldr	r0, [sp, #72]	; 0x48
 801ce7a:	f00a ffab 	bl	8027dd4 <__aeabi_i2d>
        BASE temp2_imag = 0.0;
 801ce7e:	ed9f 7b8e 	vldr	d7, [pc, #568]	; 801d0b8 <cblas_zhemv+0x6d0>
        for (j = j_min; j < j_max; j++) {
 801ce82:	e9dd 450f 	ldrd	r4, r5, [sp, #60]	; 0x3c
        BASE temp2_imag = 0.0;
 801ce86:	eeb0 ca47 	vmov.f32	s24, s14
 801ce8a:	eef0 ca67 	vmov.f32	s25, s15
        BASE temp2_real = 0.0;
 801ce8e:	eeb0 ba47 	vmov.f32	s22, s14
 801ce92:	eef0 ba67 	vmov.f32	s23, s15
 801ce96:	ec41 0b1f 	vmov	d15, r0, r1
        for (j = j_min; j < j_max; j++) {
 801ce9a:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
 801ce9e:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801cea2:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 801cea6:	ec51 0b1f 	vmov	r0, r1, d15
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 801ceaa:	e9da 8900 	ldrd	r8, r9, [sl]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801ceae:	f00a fffb 	bl	8027ea8 <__aeabi_dmul>
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801ceb2:	4642      	mov	r2, r8
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801ceb4:	4606      	mov	r6, r0
 801ceb6:	460f      	mov	r7, r1
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801ceb8:	464b      	mov	r3, r9
 801ceba:	ec51 0b1d 	vmov	r0, r1, d13
 801cebe:	f00a fff3 	bl	8027ea8 <__aeabi_dmul>
 801cec2:	4632      	mov	r2, r6
 801cec4:	ec41 0b1a 	vmov	d10, r0, r1
 801cec8:	463b      	mov	r3, r7
 801ceca:	ec51 0b1e 	vmov	r0, r1, d14
 801cece:	f00a ffeb 	bl	8027ea8 <__aeabi_dmul>
 801ced2:	4602      	mov	r2, r0
 801ced4:	460b      	mov	r3, r1
 801ced6:	ec51 0b1a 	vmov	r0, r1, d10
 801ceda:	f00a fe2f 	bl	8027b3c <__adddf3>
 801cede:	4602      	mov	r2, r0
 801cee0:	460b      	mov	r3, r1
 801cee2:	e954 0102 	ldrd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801cee6:	9602      	str	r6, [sp, #8]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801cee8:	f00a fe28 	bl	8027b3c <__adddf3>
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801ceec:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 801cef0:	9303      	str	r3, [sp, #12]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801cef2:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801cef6:	ec53 2b1d 	vmov	r2, r3, d13
 801cefa:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 801cefe:	f00a ffd3 	bl	8027ea8 <__aeabi_dmul>
 801cf02:	4642      	mov	r2, r8
 801cf04:	ec41 0b19 	vmov	d9, r0, r1
 801cf08:	464b      	mov	r3, r9
 801cf0a:	ec51 0b1e 	vmov	r0, r1, d14
 801cf0e:	f00a ffcb 	bl	8027ea8 <__aeabi_dmul>
 801cf12:	4602      	mov	r2, r0
 801cf14:	460b      	mov	r3, r1
 801cf16:	ec51 0b19 	vmov	r0, r1, d9
 801cf1a:	f00a fe0f 	bl	8027b3c <__adddf3>
 801cf1e:	4602      	mov	r2, r0
 801cf20:	460b      	mov	r3, r1
 801cf22:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801cf26:	f00a fe09 	bl	8027b3c <__adddf3>
 801cf2a:	e9cb 0102 	strd	r0, r1, [fp, #8]
          x_real = CONST_REAL(X, jx);
 801cf2e:	ed95 7b00 	vldr	d7, [r5]
          x_imag = CONST_IMAG(X, jx);
 801cf32:	ed95 6b02 	vldr	d6, [r5, #8]
          x_real = CONST_REAL(X, jx);
 801cf36:	eeb0 9a47 	vmov.f32	s18, s14
 801cf3a:	eef0 9a67 	vmov.f32	s19, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801cf3e:	ec53 2b17 	vmov	r2, r3, d7
          x_imag = CONST_IMAG(X, jx);
 801cf42:	eeb0 8a46 	vmov.f32	s16, s12
 801cf46:	eef0 8a66 	vmov.f32	s17, s13
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801cf4a:	4640      	mov	r0, r8
 801cf4c:	4649      	mov	r1, r9
 801cf4e:	f00a ffab 	bl	8027ea8 <__aeabi_dmul>
 801cf52:	ec53 2b18 	vmov	r2, r3, d8
 801cf56:	ec41 0b1a 	vmov	d10, r0, r1
 801cf5a:	4630      	mov	r0, r6
 801cf5c:	4639      	mov	r1, r7
 801cf5e:	f00a ffa3 	bl	8027ea8 <__aeabi_dmul>
 801cf62:	4602      	mov	r2, r0
 801cf64:	460b      	mov	r3, r1
 801cf66:	ec51 0b1a 	vmov	r0, r1, d10
 801cf6a:	f00a fde5 	bl	8027b38 <__aeabi_dsub>
 801cf6e:	4602      	mov	r2, r0
 801cf70:	460b      	mov	r3, r1
 801cf72:	ec51 0b1b 	vmov	r0, r1, d11
 801cf76:	f00a fde1 	bl	8027b3c <__adddf3>
 801cf7a:	ec41 0b17 	vmov	d7, r0, r1
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801cf7e:	ec53 2b19 	vmov	r2, r3, d9
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801cf82:	eeb0 ba47 	vmov.f32	s22, s14
 801cf86:	eef0 ba67 	vmov.f32	s23, s15
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801cf8a:	4630      	mov	r0, r6
 801cf8c:	4639      	mov	r1, r7
 801cf8e:	f00a ff8b 	bl	8027ea8 <__aeabi_dmul>
 801cf92:	ec53 2b18 	vmov	r2, r3, d8
 801cf96:	4606      	mov	r6, r0
 801cf98:	460f      	mov	r7, r1
 801cf9a:	4640      	mov	r0, r8
 801cf9c:	4649      	mov	r1, r9
 801cf9e:	f00a ff83 	bl	8027ea8 <__aeabi_dmul>
 801cfa2:	4602      	mov	r2, r0
 801cfa4:	460b      	mov	r3, r1
 801cfa6:	4630      	mov	r0, r6
 801cfa8:	4639      	mov	r1, r7
 801cfaa:	f00a fdc7 	bl	8027b3c <__adddf3>
 801cfae:	460b      	mov	r3, r1
 801cfb0:	4602      	mov	r2, r0
 801cfb2:	ec51 0b1c 	vmov	r0, r1, d12
 801cfb6:	f00a fdc1 	bl	8027b3c <__adddf3>
 801cfba:	9b05      	ldr	r3, [sp, #20]
 801cfbc:	441c      	add	r4, r3
 801cfbe:	449b      	add	fp, r3
 801cfc0:	9b04      	ldr	r3, [sp, #16]
 801cfc2:	441d      	add	r5, r3
        for (j = j_min; j < j_max; j++) {
 801cfc4:	9b00      	ldr	r3, [sp, #0]
 801cfc6:	f10a 0a10 	add.w	sl, sl, #16
 801cfca:	4553      	cmp	r3, sl
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801cfcc:	ec41 0b1c 	vmov	d12, r0, r1
        for (j = j_min; j < j_max; j++) {
 801cfd0:	f47f af67 	bne.w	801cea2 <cblas_zhemv+0x4ba>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801cfd4:	ed9d 8b06 	vldr	d8, [sp, #24]
 801cfd8:	ec53 2b1b 	vmov	r2, r3, d11
 801cfdc:	ec51 0b18 	vmov	r0, r1, d8
 801cfe0:	f00a ff62 	bl	8027ea8 <__aeabi_dmul>
 801cfe4:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 801cfe8:	ec5a 9b1c 	vmov	r9, sl, d12
 801cfec:	4604      	mov	r4, r0
 801cfee:	460d      	mov	r5, r1
 801cff0:	ee1c 2a10 	vmov	r2, s24
 801cff4:	4653      	mov	r3, sl
 801cff6:	4638      	mov	r0, r7
 801cff8:	4641      	mov	r1, r8
 801cffa:	f00a ff55 	bl	8027ea8 <__aeabi_dmul>
 801cffe:	4602      	mov	r2, r0
 801d000:	460b      	mov	r3, r1
 801d002:	4620      	mov	r0, r4
 801d004:	4629      	mov	r1, r5
 801d006:	f00a fd97 	bl	8027b38 <__aeabi_dsub>
 801d00a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801d00c:	4602      	mov	r2, r0
 801d00e:	460b      	mov	r3, r1
 801d010:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 801d014:	f00a fd92 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d018:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d01c:	e946 0102 	strd	r0, r1, [r6, #-8]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d020:	4638      	mov	r0, r7
 801d022:	4641      	mov	r1, r8
 801d024:	f00a ff40 	bl	8027ea8 <__aeabi_dmul>
 801d028:	ee1c 2a10 	vmov	r2, s24
 801d02c:	4653      	mov	r3, sl
 801d02e:	4604      	mov	r4, r0
 801d030:	460d      	mov	r5, r1
 801d032:	ec51 0b18 	vmov	r0, r1, d8
 801d036:	f00a ff37 	bl	8027ea8 <__aeabi_dmul>
 801d03a:	4602      	mov	r2, r0
 801d03c:	460b      	mov	r3, r1
 801d03e:	4620      	mov	r0, r4
 801d040:	4629      	mov	r1, r5
 801d042:	f00a fd7b 	bl	8027b3c <__adddf3>
 801d046:	4602      	mov	r2, r0
 801d048:	460b      	mov	r3, r1
 801d04a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801d04e:	f00a fd75 	bl	8027b3c <__adddf3>
 801d052:	9b00      	ldr	r3, [sp, #0]
 801d054:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801d056:	4413      	add	r3, r2
 801d058:	9300      	str	r3, [sp, #0]
 801d05a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801d05c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801d05e:	4413      	add	r3, r2
 801d060:	930e      	str	r3, [sp, #56]	; 0x38
 801d062:	9a16      	ldr	r2, [sp, #88]	; 0x58
 801d064:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d066:	4413      	add	r3, r2
 801d068:	930a      	str	r3, [sp, #40]	; 0x28
 801d06a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d06c:	3b01      	subs	r3, #1
 801d06e:	930b      	str	r3, [sp, #44]	; 0x2c
 801d070:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801d072:	18f3      	adds	r3, r6, r3
 801d074:	e9c6 0100 	strd	r0, r1, [r6]
      for (i = N; i > 0 && i--;) {
 801d078:	930d      	str	r3, [sp, #52]	; 0x34
 801d07a:	e69c      	b.n	801cdb6 <cblas_zhemv+0x3ce>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801d07c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d07e:	2b7a      	cmp	r3, #122	; 0x7a
 801d080:	d01e      	beq.n	801d0c0 <cblas_zhemv+0x6d8>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 801d082:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d084:	2b79      	cmp	r3, #121	; 0x79
 801d086:	f47f ad81 	bne.w	801cb8c <cblas_zhemv+0x1a4>
 801d08a:	e633      	b.n	801ccf4 <cblas_zhemv+0x30c>
      INDEX iy = OFFSET(N, incY);
 801d08c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801d08e:	f1c2 0a01 	rsb	sl, r2, #1
 801d092:	fb0a fa03 	mul.w	sl, sl, r3
 801d096:	e51e      	b.n	801cad6 <cblas_zhemv+0xee>
    if (beta_real == 0.0 && beta_imag == 0.0) {
 801d098:	ec51 0b18 	vmov	r0, r1, d8
 801d09c:	f00b f96c 	bl	8028378 <__aeabi_dcmpeq>
 801d0a0:	2800      	cmp	r0, #0
 801d0a2:	f47f ad84 	bne.w	801cbae <cblas_zhemv+0x1c6>
 801d0a6:	e510      	b.n	801caca <cblas_zhemv+0xe2>
      INDEX iy = OFFSET(N, incY);
 801d0a8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d0aa:	f1c3 0301 	rsb	r3, r3, #1
 801d0ae:	fb03 f302 	mul.w	r3, r3, r2
 801d0b2:	e589      	b.n	801cbc8 <cblas_zhemv+0x1e0>
 801d0b4:	f3af 8000 	nop.w
	...
      INDEX ix = OFFSET(N, incX);
 801d0c0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
      INDEX iy = OFFSET(N, incY);
 801d0c2:	990c      	ldr	r1, [sp, #48]	; 0x30
      for (i = 0; i < N; i++) {
 801d0c4:	980a      	ldr	r0, [sp, #40]	; 0x28
      INDEX ix = OFFSET(N, incX);
 801d0c6:	2b00      	cmp	r3, #0
 801d0c8:	bfdd      	ittte	le
 801d0ca:	9a0a      	ldrle	r2, [sp, #40]	; 0x28
 801d0cc:	f1c2 0201 	rsble	r2, r2, #1
 801d0d0:	435a      	mulle	r2, r3
 801d0d2:	2200      	movgt	r2, #0
      INDEX iy = OFFSET(N, incY);
 801d0d4:	2900      	cmp	r1, #0
 801d0d6:	bfdd      	ittte	le
 801d0d8:	9b0a      	ldrle	r3, [sp, #40]	; 0x28
 801d0da:	f1c3 0301 	rsble	r3, r3, #1
 801d0de:	434b      	mulle	r3, r1
 801d0e0:	2300      	movgt	r3, #0
      for (i = 0; i < N; i++) {
 801d0e2:	2800      	cmp	r0, #0
      INDEX iy = OFFSET(N, incY);
 801d0e4:	9318      	str	r3, [sp, #96]	; 0x60
      for (i = 0; i < N; i++) {
 801d0e6:	f77f addc 	ble.w	801cca2 <cblas_zhemv+0x2ba>
 801d0ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801d0ec:	9d18      	ldr	r5, [sp, #96]	; 0x60
 801d0ee:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 801d0f0:	930b      	str	r3, [sp, #44]	; 0x2c
 801d0f2:	f1a3 0110 	sub.w	r1, r3, #16
 801d0f6:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 801d0fa:	9102      	str	r1, [sp, #8]
 801d0fc:	9915      	ldr	r1, [sp, #84]	; 0x54
 801d0fe:	9f05      	ldr	r7, [sp, #20]
 801d100:	19ab      	adds	r3, r5, r6
 801d102:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 801d106:	9310      	str	r3, [sp, #64]	; 0x40
 801d108:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801d10a:	18d0      	adds	r0, r2, r3
 801d10c:	3701      	adds	r7, #1
 801d10e:	011b      	lsls	r3, r3, #4
 801d110:	9011      	str	r0, [sp, #68]	; 0x44
 801d112:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801d114:	9305      	str	r3, [sp, #20]
 801d116:	013c      	lsls	r4, r7, #4
 801d118:	0133      	lsls	r3, r6, #4
 801d11a:	9417      	str	r4, [sp, #92]	; 0x5c
 801d11c:	eb00 1202 	add.w	r2, r0, r2, lsl #4
 801d120:	3c10      	subs	r4, #16
 801d122:	9304      	str	r3, [sp, #16]
 801d124:	eb01 1305 	add.w	r3, r1, r5, lsl #4
 801d128:	9416      	str	r4, [sp, #88]	; 0x58
 801d12a:	920f      	str	r2, [sp, #60]	; 0x3c
 801d12c:	930e      	str	r3, [sp, #56]	; 0x38
 801d12e:	f04f 0a00 	mov.w	sl, #0
        BASE x_real = CONST_REAL(X, ix);
 801d132:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801d134:	ed9d 9b06 	vldr	d9, [sp, #24]
        BASE x_real = CONST_REAL(X, ix);
 801d138:	e9d4 6700 	ldrd	r6, r7, [r4]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801d13c:	ec51 0b19 	vmov	r0, r1, d9
 801d140:	4632      	mov	r2, r6
 801d142:	463b      	mov	r3, r7
 801d144:	f00a feb0 	bl	8027ea8 <__aeabi_dmul>
        BASE x_imag = CONST_IMAG(X, ix);
 801d148:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801d14c:	ed9d 8b08 	vldr	d8, [sp, #32]
 801d150:	4642      	mov	r2, r8
 801d152:	464b      	mov	r3, r9
 801d154:	4604      	mov	r4, r0
 801d156:	460d      	mov	r5, r1
 801d158:	ec51 0b18 	vmov	r0, r1, d8
 801d15c:	f00a fea4 	bl	8027ea8 <__aeabi_dmul>
 801d160:	4602      	mov	r2, r0
 801d162:	460b      	mov	r3, r1
 801d164:	4620      	mov	r0, r4
 801d166:	4629      	mov	r1, r5
 801d168:	f00a fce6 	bl	8027b38 <__aeabi_dsub>
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d16c:	4642      	mov	r2, r8
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801d16e:	4604      	mov	r4, r0
 801d170:	460d      	mov	r5, r1
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d172:	464b      	mov	r3, r9
 801d174:	ec51 0b19 	vmov	r0, r1, d9
 801d178:	f00a fe96 	bl	8027ea8 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801d17c:	46a0      	mov	r8, r4
 801d17e:	46a9      	mov	r9, r5
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d180:	4632      	mov	r2, r6
 801d182:	463b      	mov	r3, r7
 801d184:	4604      	mov	r4, r0
 801d186:	460d      	mov	r5, r1
 801d188:	ec51 0b18 	vmov	r0, r1, d8
 801d18c:	f00a fe8c 	bl	8027ea8 <__aeabi_dmul>
 801d190:	4602      	mov	r2, r0
 801d192:	460b      	mov	r3, r1
 801d194:	4620      	mov	r0, r4
 801d196:	4629      	mov	r1, r5
 801d198:	f00a fcd0 	bl	8027b3c <__adddf3>
        BASE Aii_real = CONST_REAL(A, lda * i + i);
 801d19c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d19e:	e9d3 4500 	ldrd	r4, r5, [r3]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d1a2:	4606      	mov	r6, r0
 801d1a4:	460f      	mov	r7, r1
        REAL(Y, iy) += temp1_real * Aii_real;
 801d1a6:	4640      	mov	r0, r8
 801d1a8:	4649      	mov	r1, r9
 801d1aa:	4622      	mov	r2, r4
 801d1ac:	462b      	mov	r3, r5
 801d1ae:	f00a fe7b 	bl	8027ea8 <__aeabi_dmul>
        BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
 801d1b2:	ec49 8b1d 	vmov	d13, r8, r9
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d1b6:	46b9      	mov	r9, r7
        REAL(Y, iy) += temp1_real * Aii_real;
 801d1b8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 801d1ba:	4602      	mov	r2, r0
 801d1bc:	460b      	mov	r3, r1
 801d1be:	e9d7 0100 	ldrd	r0, r1, [r7]
 801d1c2:	f00a fcbb 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801d1c6:	4622      	mov	r2, r4
        REAL(Y, iy) += temp1_real * Aii_real;
 801d1c8:	e9c7 0100 	strd	r0, r1, [r7]
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801d1cc:	462b      	mov	r3, r5
 801d1ce:	4630      	mov	r0, r6
 801d1d0:	4649      	mov	r1, r9
 801d1d2:	f00a fe69 	bl	8027ea8 <__aeabi_dmul>
 801d1d6:	4602      	mov	r2, r0
 801d1d8:	460b      	mov	r3, r1
 801d1da:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 801d1de:	f00a fcad 	bl	8027b3c <__adddf3>
        for (j = j_min; j < j_max; j++) {
 801d1e2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        const INDEX j_min = i + 1;
 801d1e4:	f10a 0301 	add.w	r3, sl, #1
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d1e8:	46b0      	mov	r8, r6
        for (j = j_min; j < j_max; j++) {
 801d1ea:	429a      	cmp	r2, r3
        IMAG(Y, iy) += temp1_imag * Aii_real;
 801d1ec:	e9c7 0102 	strd	r0, r1, [r7, #8]
        BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
 801d1f0:	ec49 8b1e 	vmov	d14, r8, r9
        const INDEX j_min = i + 1;
 801d1f4:	9314      	str	r3, [sp, #80]	; 0x50
        for (j = j_min; j < j_max; j++) {
 801d1f6:	f43f ad20 	beq.w	801cc3a <cblas_zhemv+0x252>
 801d1fa:	9812      	ldr	r0, [sp, #72]	; 0x48
 801d1fc:	f00a fdea 	bl	8027dd4 <__aeabi_i2d>
 801d200:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801d202:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 801d206:	ec41 0b1f 	vmov	d15, r0, r1
 801d20a:	9911      	ldr	r1, [sp, #68]	; 0x44
        BASE temp2_imag = 0.0;
 801d20c:	ed1f 7b56 	vldr	d7, [pc, #-344]	; 801d0b8 <cblas_zhemv+0x6d0>
 801d210:	eb02 1b01 	add.w	fp, r2, r1, lsl #4
 801d214:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801d216:	eeb0 ca47 	vmov.f32	s24, s14
 801d21a:	eef0 ca67 	vmov.f32	s25, s15
 801d21e:	f102 0408 	add.w	r4, r2, #8
        for (j = j_min; j < j_max; j++) {
 801d222:	4615      	mov	r5, r2
        BASE temp2_real = 0.0;
 801d224:	eeb0 ba47 	vmov.f32	s22, s14
 801d228:	eef0 ba67 	vmov.f32	s23, s15
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801d22c:	e9da 2306 	ldrd	r2, r3, [sl, #24]
 801d230:	ec51 0b1f 	vmov	r0, r1, d15
          BASE Aij_real = CONST_REAL(A, lda * i + j);
 801d234:	e9da 8904 	ldrd	r8, r9, [sl, #16]
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801d238:	f00a fe36 	bl	8027ea8 <__aeabi_dmul>
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801d23c:	4642      	mov	r2, r8
          BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 801d23e:	4606      	mov	r6, r0
 801d240:	460f      	mov	r7, r1
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801d242:	464b      	mov	r3, r9
 801d244:	ec51 0b1d 	vmov	r0, r1, d13
 801d248:	f00a fe2e 	bl	8027ea8 <__aeabi_dmul>
 801d24c:	4632      	mov	r2, r6
 801d24e:	ec41 0b1a 	vmov	d10, r0, r1
 801d252:	463b      	mov	r3, r7
 801d254:	ec51 0b1e 	vmov	r0, r1, d14
 801d258:	f00a fe26 	bl	8027ea8 <__aeabi_dmul>
 801d25c:	4602      	mov	r2, r0
 801d25e:	460b      	mov	r3, r1
 801d260:	ec51 0b1a 	vmov	r0, r1, d10
 801d264:	f00a fc6a 	bl	8027b3c <__adddf3>
 801d268:	4602      	mov	r2, r0
 801d26a:	460b      	mov	r3, r1
 801d26c:	e954 0102 	ldrd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801d270:	9600      	str	r6, [sp, #0]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801d272:	f00a fc63 	bl	8027b3c <__adddf3>
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801d276:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
 801d27a:	9301      	str	r3, [sp, #4]
          REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
 801d27c:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
 801d280:	ec53 2b1d 	vmov	r2, r3, d13
 801d284:	e9dd 0100 	ldrd	r0, r1, [sp]
 801d288:	f00a fe0e 	bl	8027ea8 <__aeabi_dmul>
 801d28c:	4642      	mov	r2, r8
 801d28e:	ec41 0b19 	vmov	d9, r0, r1
 801d292:	464b      	mov	r3, r9
 801d294:	ec51 0b1e 	vmov	r0, r1, d14
 801d298:	f00a fe06 	bl	8027ea8 <__aeabi_dmul>
 801d29c:	4602      	mov	r2, r0
 801d29e:	460b      	mov	r3, r1
 801d2a0:	ec51 0b19 	vmov	r0, r1, d9
 801d2a4:	f00a fc4a 	bl	8027b3c <__adddf3>
 801d2a8:	4602      	mov	r2, r0
 801d2aa:	460b      	mov	r3, r1
 801d2ac:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 801d2b0:	f00a fc44 	bl	8027b3c <__adddf3>
 801d2b4:	e9c5 0102 	strd	r0, r1, [r5, #8]
          x_real = CONST_REAL(X, jx);
 801d2b8:	ed9b 7b00 	vldr	d7, [fp]
          x_imag = CONST_IMAG(X, jx);
 801d2bc:	ed9b 6b02 	vldr	d6, [fp, #8]
          x_real = CONST_REAL(X, jx);
 801d2c0:	eeb0 9a47 	vmov.f32	s18, s14
 801d2c4:	eef0 9a67 	vmov.f32	s19, s15
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801d2c8:	ec53 2b17 	vmov	r2, r3, d7
          x_imag = CONST_IMAG(X, jx);
 801d2cc:	eeb0 8a46 	vmov.f32	s16, s12
 801d2d0:	eef0 8a66 	vmov.f32	s17, s13
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801d2d4:	4640      	mov	r0, r8
 801d2d6:	4649      	mov	r1, r9
 801d2d8:	f00a fde6 	bl	8027ea8 <__aeabi_dmul>
 801d2dc:	ec53 2b18 	vmov	r2, r3, d8
 801d2e0:	ec41 0b1a 	vmov	d10, r0, r1
 801d2e4:	4630      	mov	r0, r6
 801d2e6:	4639      	mov	r1, r7
 801d2e8:	f00a fdde 	bl	8027ea8 <__aeabi_dmul>
 801d2ec:	4602      	mov	r2, r0
 801d2ee:	460b      	mov	r3, r1
 801d2f0:	ec51 0b1a 	vmov	r0, r1, d10
 801d2f4:	f00a fc20 	bl	8027b38 <__aeabi_dsub>
 801d2f8:	4602      	mov	r2, r0
 801d2fa:	460b      	mov	r3, r1
 801d2fc:	ec51 0b1b 	vmov	r0, r1, d11
 801d300:	f00a fc1c 	bl	8027b3c <__adddf3>
 801d304:	ec41 0b17 	vmov	d7, r0, r1
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801d308:	ec53 2b19 	vmov	r2, r3, d9
          temp2_real += x_real * Aij_real - x_imag * Aij_imag;
 801d30c:	eeb0 ba47 	vmov.f32	s22, s14
 801d310:	eef0 ba67 	vmov.f32	s23, s15
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801d314:	4630      	mov	r0, r6
 801d316:	4639      	mov	r1, r7
 801d318:	f00a fdc6 	bl	8027ea8 <__aeabi_dmul>
 801d31c:	ec53 2b18 	vmov	r2, r3, d8
 801d320:	4606      	mov	r6, r0
 801d322:	460f      	mov	r7, r1
 801d324:	4640      	mov	r0, r8
 801d326:	4649      	mov	r1, r9
 801d328:	f00a fdbe 	bl	8027ea8 <__aeabi_dmul>
 801d32c:	4602      	mov	r2, r0
 801d32e:	460b      	mov	r3, r1
 801d330:	4630      	mov	r0, r6
 801d332:	4639      	mov	r1, r7
 801d334:	f00a fc02 	bl	8027b3c <__adddf3>
 801d338:	460b      	mov	r3, r1
 801d33a:	4602      	mov	r2, r0
 801d33c:	ec51 0b1c 	vmov	r0, r1, d12
 801d340:	f00a fbfc 	bl	8027b3c <__adddf3>
 801d344:	9b04      	ldr	r3, [sp, #16]
 801d346:	441c      	add	r4, r3
 801d348:	441d      	add	r5, r3
 801d34a:	9b05      	ldr	r3, [sp, #20]
 801d34c:	449b      	add	fp, r3
        for (j = j_min; j < j_max; j++) {
 801d34e:	9b02      	ldr	r3, [sp, #8]
 801d350:	f10a 0a10 	add.w	sl, sl, #16
 801d354:	4553      	cmp	r3, sl
          temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
 801d356:	ec41 0b1c 	vmov	d12, r0, r1
        for (j = j_min; j < j_max; j++) {
 801d35a:	f47f af67 	bne.w	801d22c <cblas_zhemv+0x844>
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d35e:	ed9d 8b06 	vldr	d8, [sp, #24]
 801d362:	ec53 2b1b 	vmov	r2, r3, d11
 801d366:	ec51 0b18 	vmov	r0, r1, d8
 801d36a:	f00a fd9d 	bl	8027ea8 <__aeabi_dmul>
 801d36e:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 801d372:	ec5a 9b1c 	vmov	r9, sl, d12
 801d376:	4604      	mov	r4, r0
 801d378:	4653      	mov	r3, sl
 801d37a:	460d      	mov	r5, r1
 801d37c:	ee1c 2a10 	vmov	r2, s24
 801d380:	4638      	mov	r0, r7
 801d382:	4641      	mov	r1, r8
 801d384:	f00a fd90 	bl	8027ea8 <__aeabi_dmul>
 801d388:	4602      	mov	r2, r0
 801d38a:	460b      	mov	r3, r1
 801d38c:	4620      	mov	r0, r4
 801d38e:	4629      	mov	r1, r5
 801d390:	f00a fbd2 	bl	8027b38 <__aeabi_dsub>
 801d394:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 801d396:	4602      	mov	r2, r0
 801d398:	460b      	mov	r3, r1
 801d39a:	e9d6 0100 	ldrd	r0, r1, [r6]
 801d39e:	f00a fbcd 	bl	8027b3c <__adddf3>
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d3a2:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d3a6:	e9c6 0100 	strd	r0, r1, [r6]
        IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 801d3aa:	4638      	mov	r0, r7
 801d3ac:	4641      	mov	r1, r8
 801d3ae:	f00a fd7b 	bl	8027ea8 <__aeabi_dmul>
 801d3b2:	4653      	mov	r3, sl
 801d3b4:	460d      	mov	r5, r1
 801d3b6:	ee1c 2a10 	vmov	r2, s24
 801d3ba:	4604      	mov	r4, r0
 801d3bc:	ec51 0b18 	vmov	r0, r1, d8
 801d3c0:	f00a fd72 	bl	8027ea8 <__aeabi_dmul>
 801d3c4:	4602      	mov	r2, r0
 801d3c6:	460b      	mov	r3, r1
 801d3c8:	4620      	mov	r0, r4
 801d3ca:	4629      	mov	r1, r5
 801d3cc:	f00a fbb6 	bl	8027b3c <__adddf3>
 801d3d0:	4602      	mov	r2, r0
 801d3d2:	460b      	mov	r3, r1
 801d3d4:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 801d3d8:	f00a fbb0 	bl	8027b3c <__adddf3>
 801d3dc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801d3de:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801d3e0:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
 801d3e4:	4413      	add	r3, r2
 801d3e6:	9311      	str	r3, [sp, #68]	; 0x44
 801d3e8:	9a05      	ldr	r2, [sp, #20]
 801d3ea:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801d3ec:	4413      	add	r3, r2
 801d3ee:	930f      	str	r3, [sp, #60]	; 0x3c
 801d3f0:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801d3f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d3f4:	4413      	add	r3, r2
 801d3f6:	930b      	str	r3, [sp, #44]	; 0x2c
 801d3f8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801d3fa:	9a04      	ldr	r2, [sp, #16]
 801d3fc:	461d      	mov	r5, r3
 801d3fe:	4415      	add	r5, r2
 801d400:	9b02      	ldr	r3, [sp, #8]
 801d402:	9510      	str	r5, [sp, #64]	; 0x40
 801d404:	9d16      	ldr	r5, [sp, #88]	; 0x58
 801d406:	442b      	add	r3, r5
 801d408:	9302      	str	r3, [sp, #8]
 801d40a:	18b3      	adds	r3, r6, r2
 801d40c:	e9c6 0102 	strd	r0, r1, [r6, #8]
      for (i = 0; i < N; i++) {
 801d410:	930e      	str	r3, [sp, #56]	; 0x38
 801d412:	e68e      	b.n	801d132 <cblas_zhemv+0x74a>
 801d414:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801d416:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801d418:	9918      	ldr	r1, [sp, #96]	; 0x60
 801d41a:	9e15      	ldr	r6, [sp, #84]	; 0x54
 801d41c:	fb02 1513 	mls	r5, r2, r3, r1
        REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 801d420:	2200      	movs	r2, #0
 801d422:	2300      	movs	r3, #0
 801d424:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801d428:	f00a fd3e 	bl	8027ea8 <__aeabi_dmul>
 801d42c:	eb06 1405 	add.w	r4, r6, r5, lsl #4
 801d430:	460f      	mov	r7, r1
 801d432:	4606      	mov	r6, r0
 801d434:	2200      	movs	r2, #0
 801d436:	2300      	movs	r3, #0
 801d438:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801d43c:	f00a fd34 	bl	8027ea8 <__aeabi_dmul>
 801d440:	4680      	mov	r8, r0
 801d442:	4689      	mov	r9, r1
 801d444:	4625      	mov	r5, r4
 801d446:	4630      	mov	r0, r6
 801d448:	4639      	mov	r1, r7
 801d44a:	4642      	mov	r2, r8
 801d44c:	464b      	mov	r3, r9
 801d44e:	e410      	b.n	801cc72 <cblas_zhemv+0x28a>
  CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
 801d450:	200b      	movs	r0, #11
 801d452:	f7ff baff 	b.w	801ca54 <cblas_zhemv+0x6c>
 801d456:	bf00      	nop

0801d458 <cblas_zher>:

void
cblas_zher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
            const int N, const double alpha, const void *X, const int incX,
            void *A, const int lda)
{
 801d458:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d45c:	ed2d 8b0e 	vpush	{d8-d14}
 801d460:	eeb0 da40 	vmov.f32	s26, s0
 801d464:	eef0 da60 	vmov.f32	s27, s1
 801d468:	b091      	sub	sp, #68	; 0x44
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801d46a:	2866      	cmp	r0, #102	; 0x66
 801d46c:	460d      	mov	r5, r1
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801d46e:	f1a1 0179 	sub.w	r1, r1, #121	; 0x79
 801d472:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
 801d474:	9305      	str	r3, [sp, #20]
 801d476:	4604      	mov	r4, r0
 801d478:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 801d47a:	9829      	ldr	r0, [sp, #164]	; 0xa4
 801d47c:	9203      	str	r2, [sp, #12]
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801d47e:	bf0c      	ite	eq
 801d480:	f04f 38ff 	moveq.w	r8, #4294967295
 801d484:	f04f 0801 	movne.w	r8, #1
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801d488:	2901      	cmp	r1, #1
 801d48a:	9304      	str	r3, [sp, #16]
 801d48c:	900b      	str	r0, [sp, #44]	; 0x2c
 801d48e:	9609      	str	r6, [sp, #36]	; 0x24
 801d490:	d935      	bls.n	801d4fe <cblas_zher+0xa6>
 801d492:	2a00      	cmp	r2, #0
 801d494:	db0c      	blt.n	801d4b0 <cblas_zher+0x58>
 801d496:	2b00      	cmp	r3, #0
 801d498:	f040 8149 	bne.w	801d72e <cblas_zher+0x2d6>
 801d49c:	9803      	ldr	r0, [sp, #12]
 801d49e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d4a0:	2801      	cmp	r0, #1
 801d4a2:	bfb8      	it	lt
 801d4a4:	2001      	movlt	r0, #1
 801d4a6:	4283      	cmp	r3, r0
 801d4a8:	bfb4      	ite	lt
 801d4aa:	2008      	movlt	r0, #8
 801d4ac:	2006      	movge	r0, #6
 801d4ae:	e007      	b.n	801d4c0 <cblas_zher+0x68>
 801d4b0:	9b04      	ldr	r3, [sp, #16]
 801d4b2:	2b00      	cmp	r3, #0
 801d4b4:	d0f2      	beq.n	801d49c <cblas_zher+0x44>
 801d4b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d4b8:	2b00      	cmp	r3, #0
 801d4ba:	bfd4      	ite	le
 801d4bc:	2008      	movle	r0, #8
 801d4be:	2003      	movgt	r0, #3
 801d4c0:	4aa1      	ldr	r2, [pc, #644]	; (801d748 <cblas_zher+0x2f0>)
 801d4c2:	49a2      	ldr	r1, [pc, #648]	; (801d74c <cblas_zher+0x2f4>)
 801d4c4:	f00a fac0 	bl	8027a48 <cblas_xerbla>
  if (alpha == 0.0)
 801d4c8:	ec51 0b1d 	vmov	r0, r1, d13
 801d4cc:	2200      	movs	r2, #0
 801d4ce:	2300      	movs	r3, #0
 801d4d0:	f00a ff52 	bl	8028378 <__aeabi_dcmpeq>
 801d4d4:	b970      	cbnz	r0, 801d4f4 <cblas_zher+0x9c>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 801d4d6:	2c65      	cmp	r4, #101	; 0x65
 801d4d8:	d026      	beq.n	801d528 <cblas_zher+0xd0>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 801d4da:	2c66      	cmp	r4, #102	; 0x66
 801d4dc:	f000 8212 	beq.w	801d904 <cblas_zher+0x4ac>
    BLAS_ERROR("unrecognized operation");
 801d4e0:	4a9b      	ldr	r2, [pc, #620]	; (801d750 <cblas_zher+0x2f8>)
 801d4e2:	499a      	ldr	r1, [pc, #616]	; (801d74c <cblas_zher+0x2f4>)
 801d4e4:	2000      	movs	r0, #0
#define BASE double
#include "source_her.h"
#undef BASE
}
 801d4e6:	b011      	add	sp, #68	; 0x44
 801d4e8:	ecbd 8b0e 	vpop	{d8-d14}
 801d4ec:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d4f0:	f00a baaa 	b.w	8027a48 <cblas_xerbla>
 801d4f4:	b011      	add	sp, #68	; 0x44
 801d4f6:	ecbd 8b0e 	vpop	{d8-d14}
 801d4fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801d4fe:	9b03      	ldr	r3, [sp, #12]
 801d500:	2b00      	cmp	r3, #0
 801d502:	dbd5      	blt.n	801d4b0 <cblas_zher+0x58>
 801d504:	9b04      	ldr	r3, [sp, #16]
 801d506:	2b00      	cmp	r3, #0
 801d508:	d0c8      	beq.n	801d49c <cblas_zher+0x44>
 801d50a:	9b03      	ldr	r3, [sp, #12]
 801d50c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801d50e:	2b01      	cmp	r3, #1
 801d510:	bfb8      	it	lt
 801d512:	2301      	movlt	r3, #1
 801d514:	4293      	cmp	r3, r2
 801d516:	f300 8203 	bgt.w	801d920 <cblas_zher+0x4c8>
 801d51a:	f1a4 0365 	sub.w	r3, r4, #101	; 0x65
 801d51e:	2b01      	cmp	r3, #1
 801d520:	bf88      	it	hi
 801d522:	2001      	movhi	r0, #1
 801d524:	d9d0      	bls.n	801d4c8 <cblas_zher+0x70>
 801d526:	e7cb      	b.n	801d4c0 <cblas_zher+0x68>
  if ((order == CblasRowMajor && Uplo == CblasUpper)
 801d528:	2d79      	cmp	r5, #121	; 0x79
 801d52a:	f000 8113 	beq.w	801d754 <cblas_zher+0x2fc>
  } else if ((order == CblasRowMajor && Uplo == CblasLower)
 801d52e:	2d7a      	cmp	r5, #122	; 0x7a
 801d530:	d1d6      	bne.n	801d4e0 <cblas_zher+0x88>
    INDEX ix = OFFSET(N, incX);
 801d532:	9a04      	ldr	r2, [sp, #16]
 801d534:	2a00      	cmp	r2, #0
 801d536:	bfdd      	ittte	le
 801d538:	9b03      	ldrle	r3, [sp, #12]
 801d53a:	f1c3 0301 	rsble	r3, r3, #1
 801d53e:	4353      	mulle	r3, r2
 801d540:	2300      	movgt	r3, #0
 801d542:	9302      	str	r3, [sp, #8]
    for (i = 0; i < N; i++) {
 801d544:	9b03      	ldr	r3, [sp, #12]
 801d546:	2b00      	cmp	r3, #0
 801d548:	ddd4      	ble.n	801d4f4 <cblas_zher+0x9c>
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d54a:	9b05      	ldr	r3, [sp, #20]
 801d54c:	9a02      	ldr	r2, [sp, #8]
 801d54e:	eb03 1602 	add.w	r6, r3, r2, lsl #4
 801d552:	e9d6 4500 	ldrd	r4, r5, [r6]
 801d556:	ec5a 9b1d 	vmov	r9, sl, d13
 801d55a:	ee1d 2a10 	vmov	r2, s26
 801d55e:	4653      	mov	r3, sl
 801d560:	4620      	mov	r0, r4
 801d562:	4629      	mov	r1, r5
 801d564:	960d      	str	r6, [sp, #52]	; 0x34
 801d566:	f00a fc9f 	bl	8027ea8 <__aeabi_dmul>
 801d56a:	4602      	mov	r2, r0
 801d56c:	460b      	mov	r3, r1
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d56e:	4640      	mov	r0, r8
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d570:	ec43 2b1a 	vmov	d10, r2, r3
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d574:	f00a fc2e 	bl	8027dd4 <__aeabi_i2d>
 801d578:	4653      	mov	r3, sl
 801d57a:	ee1d 2a10 	vmov	r2, s26
 801d57e:	f00a fc93 	bl	8027ea8 <__aeabi_dmul>
 801d582:	e9d6 ab02 	ldrd	sl, fp, [r6, #8]
 801d586:	4602      	mov	r2, r0
 801d588:	460b      	mov	r3, r1
 801d58a:	4650      	mov	r0, sl
 801d58c:	4659      	mov	r1, fp
 801d58e:	ec43 2b1e 	vmov	d14, r2, r3
 801d592:	f00a fc89 	bl	8027ea8 <__aeabi_dmul>
 801d596:	4606      	mov	r6, r0
 801d598:	460f      	mov	r7, r1
 801d59a:	f1c8 0000 	rsb	r0, r8, #0
 801d59e:	f00a fc19 	bl	8027dd4 <__aeabi_i2d>
 801d5a2:	ec47 6b19 	vmov	d9, r6, r7
      for (j = 0; j < i; j++) {
 801d5a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801d5a8:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d5aa:	9208      	str	r2, [sp, #32]
 801d5ac:	1c53      	adds	r3, r2, #1
 801d5ae:	463e      	mov	r6, r7
 801d5b0:	3608      	adds	r6, #8
 801d5b2:	ec41 0b1c 	vmov	d12, r0, r1
 801d5b6:	0119      	lsls	r1, r3, #4
 801d5b8:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801d5bc:	e9cd 6306 	strd	r6, r3, [sp, #24]
 801d5c0:	9b04      	ldr	r3, [sp, #16]
 801d5c2:	960f      	str	r6, [sp, #60]	; 0x3c
 801d5c4:	011b      	lsls	r3, r3, #4
        IMAG(A, lda * i + i) = 0;
 801d5c6:	ed9f 8b5e 	vldr	d8, [pc, #376]	; 801d740 <cblas_zher+0x2e8>
 801d5ca:	9301      	str	r3, [sp, #4]
    for (i = 0; i < N; i++) {
 801d5cc:	2300      	movs	r3, #0
 801d5ce:	910e      	str	r1, [sp, #56]	; 0x38
 801d5d0:	930a      	str	r3, [sp, #40]	; 0x28
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d5d2:	4622      	mov	r2, r4
 801d5d4:	462b      	mov	r3, r5
 801d5d6:	ec51 0b1a 	vmov	r0, r1, d10
 801d5da:	f00a fc65 	bl	8027ea8 <__aeabi_dmul>
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d5de:	4652      	mov	r2, sl
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d5e0:	4604      	mov	r4, r0
 801d5e2:	460d      	mov	r5, r1
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d5e4:	465b      	mov	r3, fp
 801d5e6:	ec51 0b1c 	vmov	r0, r1, d12
 801d5ea:	f00a fc5d 	bl	8027ea8 <__aeabi_dmul>
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d5ee:	ec53 2b19 	vmov	r2, r3, d9
 801d5f2:	f00a fc59 	bl	8027ea8 <__aeabi_dmul>
 801d5f6:	4602      	mov	r2, r0
 801d5f8:	460b      	mov	r3, r1
 801d5fa:	4620      	mov	r0, r4
 801d5fc:	4629      	mov	r1, r5
 801d5fe:	f00a fa9b 	bl	8027b38 <__aeabi_dsub>
 801d602:	9c06      	ldr	r4, [sp, #24]
 801d604:	4602      	mov	r2, r0
 801d606:	460b      	mov	r3, r1
 801d608:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801d60c:	f00a fa96 	bl	8027b3c <__adddf3>
      ix += incX;
 801d610:	9b02      	ldr	r3, [sp, #8]
 801d612:	9d04      	ldr	r5, [sp, #16]
    for (i = 0; i < N; i++) {
 801d614:	9a0a      	ldr	r2, [sp, #40]	; 0x28
      ix += incX;
 801d616:	442b      	add	r3, r5
 801d618:	9302      	str	r3, [sp, #8]
    for (i = 0; i < N; i++) {
 801d61a:	9b03      	ldr	r3, [sp, #12]
 801d61c:	3201      	adds	r2, #1
 801d61e:	4293      	cmp	r3, r2
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d620:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(A, lda * i + i) = 0;
 801d624:	ed84 8b00 	vstr	d8, [r4]
    for (i = 0; i < N; i++) {
 801d628:	920a      	str	r2, [sp, #40]	; 0x28
 801d62a:	f43f af63 	beq.w	801d4f4 <cblas_zher+0x9c>
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d62e:	9f02      	ldr	r7, [sp, #8]
 801d630:	9b05      	ldr	r3, [sp, #20]
 801d632:	eb03 1607 	add.w	r6, r3, r7, lsl #4
 801d636:	e9d6 2300 	ldrd	r2, r3, [r6]
 801d63a:	ec51 0b1d 	vmov	r0, r1, d13
 801d63e:	f00a fc33 	bl	8027ea8 <__aeabi_dmul>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d642:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d646:	4604      	mov	r4, r0
 801d648:	460d      	mov	r5, r1
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d64a:	ec51 0b1e 	vmov	r0, r1, d14
 801d64e:	f00a fc2b 	bl	8027ea8 <__aeabi_dmul>
 801d652:	013b      	lsls	r3, r7, #4
 801d654:	930c      	str	r3, [sp, #48]	; 0x30
 801d656:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d658:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 801d65a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 801d65c:	9f07      	ldr	r7, [sp, #28]
 801d65e:	ec41 0b19 	vmov	d9, r0, r1
 801d662:	4619      	mov	r1, r3
 801d664:	9b08      	ldr	r3, [sp, #32]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d666:	ec45 4b1a 	vmov	d10, r4, r5
      for (j = 0; j < i; j++) {
 801d66a:	eb01 1a03 	add.w	sl, r1, r3, lsl #4
 801d66e:	eb02 1b03 	add.w	fp, r2, r3, lsl #4
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d672:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 801d676:	ec51 0b1c 	vmov	r0, r1, d12
 801d67a:	f00a fc15 	bl	8027ea8 <__aeabi_dmul>
        const BASE X_real = CONST_REAL(X, jx);
 801d67e:	e9d6 8900 	ldrd	r8, r9, [r6]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d682:	4604      	mov	r4, r0
 801d684:	460d      	mov	r5, r1
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801d686:	4642      	mov	r2, r8
 801d688:	464b      	mov	r3, r9
 801d68a:	ec51 0b1a 	vmov	r0, r1, d10
 801d68e:	f00a fc0b 	bl	8027ea8 <__aeabi_dmul>
 801d692:	4622      	mov	r2, r4
 801d694:	462b      	mov	r3, r5
 801d696:	ec41 0b1b 	vmov	d11, r0, r1
 801d69a:	ec51 0b19 	vmov	r0, r1, d9
 801d69e:	f00a fc03 	bl	8027ea8 <__aeabi_dmul>
 801d6a2:	4602      	mov	r2, r0
 801d6a4:	460b      	mov	r3, r1
 801d6a6:	ec51 0b1b 	vmov	r0, r1, d11
 801d6aa:	f00a fa45 	bl	8027b38 <__aeabi_dsub>
 801d6ae:	4602      	mov	r2, r0
 801d6b0:	460b      	mov	r3, r1
 801d6b2:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801d6b6:	f00a fa41 	bl	8027b3c <__adddf3>
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801d6ba:	4622      	mov	r2, r4
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801d6bc:	e94b 0102 	strd	r0, r1, [fp, #-8]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801d6c0:	462b      	mov	r3, r5
 801d6c2:	ec51 0b1a 	vmov	r0, r1, d10
 801d6c6:	f00a fbef 	bl	8027ea8 <__aeabi_dmul>
 801d6ca:	4642      	mov	r2, r8
 801d6cc:	464b      	mov	r3, r9
 801d6ce:	4604      	mov	r4, r0
 801d6d0:	460d      	mov	r5, r1
 801d6d2:	ec51 0b19 	vmov	r0, r1, d9
 801d6d6:	f00a fbe7 	bl	8027ea8 <__aeabi_dmul>
 801d6da:	4602      	mov	r2, r0
 801d6dc:	460b      	mov	r3, r1
 801d6de:	4620      	mov	r0, r4
 801d6e0:	4629      	mov	r1, r5
 801d6e2:	f00a fa2b 	bl	8027b3c <__adddf3>
 801d6e6:	460b      	mov	r3, r1
 801d6e8:	4602      	mov	r2, r0
 801d6ea:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801d6ee:	f00a fa25 	bl	8027b3c <__adddf3>
 801d6f2:	f10a 0a10 	add.w	sl, sl, #16
 801d6f6:	9b01      	ldr	r3, [sp, #4]
 801d6f8:	e94a 0102 	strd	r0, r1, [sl, #-8]
      for (j = 0; j < i; j++) {
 801d6fc:	4557      	cmp	r7, sl
 801d6fe:	441e      	add	r6, r3
 801d700:	f10b 0b10 	add.w	fp, fp, #16
 801d704:	d1b5      	bne.n	801d672 <cblas_zher+0x21a>
 801d706:	9a05      	ldr	r2, [sp, #20]
 801d708:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801d70a:	4413      	add	r3, r2
 801d70c:	e9d3 ab02 	ldrd	sl, fp, [r3, #8]
 801d710:	e9d3 4500 	ldrd	r4, r5, [r3]
 801d714:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
 801d718:	4413      	add	r3, r2
 801d71a:	9a07      	ldr	r2, [sp, #28]
 801d71c:	9308      	str	r3, [sp, #32]
 801d71e:	4611      	mov	r1, r2
 801d720:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801d722:	9a06      	ldr	r2, [sp, #24]
 801d724:	4419      	add	r1, r3
 801d726:	441a      	add	r2, r3
 801d728:	9107      	str	r1, [sp, #28]
 801d72a:	9206      	str	r2, [sp, #24]
 801d72c:	e751      	b.n	801d5d2 <cblas_zher+0x17a>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801d72e:	2a01      	cmp	r2, #1
 801d730:	bfb8      	it	lt
 801d732:	2201      	movlt	r2, #1
 801d734:	4296      	cmp	r6, r2
 801d736:	bfb4      	ite	lt
 801d738:	2008      	movlt	r0, #8
 801d73a:	2002      	movge	r0, #2
 801d73c:	e6c0      	b.n	801d4c0 <cblas_zher+0x68>
 801d73e:	bf00      	nop
	...
 801d748:	08030378 	.word	0x08030378
 801d74c:	08030710 	.word	0x08030710
 801d750:	080305a8 	.word	0x080305a8
    INDEX ix = OFFSET(N, incX);
 801d754:	9a04      	ldr	r2, [sp, #16]
 801d756:	2a00      	cmp	r2, #0
 801d758:	f340 80db 	ble.w	801d912 <cblas_zher+0x4ba>
 801d75c:	2300      	movs	r3, #0
 801d75e:	9306      	str	r3, [sp, #24]
    for (i = 0; i < N; i++) {
 801d760:	9b03      	ldr	r3, [sp, #12]
 801d762:	2b00      	cmp	r3, #0
 801d764:	f77f aec6 	ble.w	801d4f4 <cblas_zher+0x9c>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d768:	4640      	mov	r0, r8
 801d76a:	f00a fb33 	bl	8027dd4 <__aeabi_i2d>
 801d76e:	ec53 2b1d 	vmov	r2, r3, d13
 801d772:	f00a fb99 	bl	8027ea8 <__aeabi_dmul>
 801d776:	4602      	mov	r2, r0
 801d778:	460b      	mov	r3, r1
 801d77a:	f1c8 0000 	rsb	r0, r8, #0
 801d77e:	ec43 2b1c 	vmov	d12, r2, r3
 801d782:	f00a fb27 	bl	8027dd4 <__aeabi_i2d>
 801d786:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d788:	ec41 0b1b 	vmov	d11, r0, r1
 801d78c:	011c      	lsls	r4, r3, #4
 801d78e:	e9dd 3005 	ldrd	r3, r0, [sp, #20]
 801d792:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 801d796:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801d798:	940c      	str	r4, [sp, #48]	; 0x30
 801d79a:	f104 0010 	add.w	r0, r4, #16
 801d79e:	3308      	adds	r3, #8
 801d7a0:	900a      	str	r0, [sp, #40]	; 0x28
 801d7a2:	9308      	str	r3, [sp, #32]
 801d7a4:	9803      	ldr	r0, [sp, #12]
 801d7a6:	9b04      	ldr	r3, [sp, #16]
 801d7a8:	f1a1 0210 	sub.w	r2, r1, #16
 801d7ac:	eb02 1200 	add.w	r2, r2, r0, lsl #4
 801d7b0:	011b      	lsls	r3, r3, #4
        IMAG(A, lda * i + i) = 0;
 801d7b2:	ed9f 8b5d 	vldr	d8, [pc, #372]	; 801d928 <cblas_zher+0x4d0>
 801d7b6:	9201      	str	r2, [sp, #4]
 801d7b8:	9302      	str	r3, [sp, #8]
 801d7ba:	f101 0208 	add.w	r2, r1, #8
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d7be:	2300      	movs	r3, #0
 801d7c0:	9207      	str	r2, [sp, #28]
 801d7c2:	9309      	str	r3, [sp, #36]	; 0x24
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d7c4:	9e08      	ldr	r6, [sp, #32]
 801d7c6:	e956 4502 	ldrd	r4, r5, [r6, #-8]
 801d7ca:	ec53 2b1d 	vmov	r2, r3, d13
 801d7ce:	4620      	mov	r0, r4
 801d7d0:	4629      	mov	r1, r5
 801d7d2:	f00a fb69 	bl	8027ea8 <__aeabi_dmul>
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d7d6:	e9d6 ab00 	ldrd	sl, fp, [r6]
      const BASE tmp_real = alpha * CONST_REAL(X, ix);
 801d7da:	460f      	mov	r7, r1
 801d7dc:	4606      	mov	r6, r0
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d7de:	4652      	mov	r2, sl
 801d7e0:	465b      	mov	r3, fp
 801d7e2:	ec51 0b1c 	vmov	r0, r1, d12
 801d7e6:	f00a fb5f 	bl	8027ea8 <__aeabi_dmul>
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d7ea:	4632      	mov	r2, r6
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d7ec:	4680      	mov	r8, r0
 801d7ee:	4689      	mov	r9, r1
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d7f0:	463b      	mov	r3, r7
 801d7f2:	4620      	mov	r0, r4
 801d7f4:	4629      	mov	r1, r5
 801d7f6:	f00a fb57 	bl	8027ea8 <__aeabi_dmul>
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d7fa:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d7fe:	4604      	mov	r4, r0
 801d800:	460d      	mov	r5, r1
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d802:	4650      	mov	r0, sl
 801d804:	4659      	mov	r1, fp
 801d806:	f00a fb4f 	bl	8027ea8 <__aeabi_dmul>
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d80a:	4642      	mov	r2, r8
 801d80c:	464b      	mov	r3, r9
 801d80e:	f00a fb4b 	bl	8027ea8 <__aeabi_dmul>
 801d812:	4602      	mov	r2, r0
 801d814:	460b      	mov	r3, r1
 801d816:	4620      	mov	r0, r4
 801d818:	4629      	mov	r1, r5
 801d81a:	f00a f98d 	bl	8027b38 <__aeabi_dsub>
 801d81e:	9c07      	ldr	r4, [sp, #28]
 801d820:	4602      	mov	r2, r0
 801d822:	460b      	mov	r3, r1
 801d824:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801d828:	f00a f988 	bl	8027b3c <__adddf3>
      for (j = i + 1; j < N; j++) {
 801d82c:	9d09      	ldr	r5, [sp, #36]	; 0x24
        jx += incX;
 801d82e:	9b06      	ldr	r3, [sp, #24]
 801d830:	9a04      	ldr	r2, [sp, #16]
        REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
 801d832:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (j = i + 1; j < N; j++) {
 801d836:	9903      	ldr	r1, [sp, #12]
 801d838:	3501      	adds	r5, #1
        jx += incX;
 801d83a:	4413      	add	r3, r2
      for (j = i + 1; j < N; j++) {
 801d83c:	42a9      	cmp	r1, r5
        IMAG(A, lda * i + i) = 0;
 801d83e:	ed84 8b00 	vstr	d8, [r4]
      const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
 801d842:	ec49 8b19 	vmov	d9, r8, r9
      for (j = i + 1; j < N; j++) {
 801d846:	9509      	str	r5, [sp, #36]	; 0x24
        jx += incX;
 801d848:	9306      	str	r3, [sp, #24]
      for (j = i + 1; j < N; j++) {
 801d84a:	f43f ae53 	beq.w	801d4f4 <cblas_zher+0x9c>
 801d84e:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 801d852:	f1a4 0a08 	sub.w	sl, r4, #8
 801d856:	eb01 1b02 	add.w	fp, r1, r2, lsl #4
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d85a:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801d85e:	ec51 0b1b 	vmov	r0, r1, d11
 801d862:	f00a fb21 	bl	8027ea8 <__aeabi_dmul>
        const BASE X_real = CONST_REAL(X, jx);
 801d866:	e9db 4500 	ldrd	r4, r5, [fp]
        const BASE X_imag = -conj * CONST_IMAG(X, jx);
 801d86a:	4680      	mov	r8, r0
 801d86c:	4689      	mov	r9, r1
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801d86e:	4622      	mov	r2, r4
 801d870:	462b      	mov	r3, r5
 801d872:	4630      	mov	r0, r6
 801d874:	4639      	mov	r1, r7
 801d876:	f00a fb17 	bl	8027ea8 <__aeabi_dmul>
 801d87a:	4642      	mov	r2, r8
 801d87c:	464b      	mov	r3, r9
 801d87e:	ec41 0b1a 	vmov	d10, r0, r1
 801d882:	ec51 0b19 	vmov	r0, r1, d9
 801d886:	f00a fb0f 	bl	8027ea8 <__aeabi_dmul>
 801d88a:	4602      	mov	r2, r0
 801d88c:	460b      	mov	r3, r1
 801d88e:	ec51 0b1a 	vmov	r0, r1, d10
 801d892:	f00a f951 	bl	8027b38 <__aeabi_dsub>
 801d896:	4602      	mov	r2, r0
 801d898:	460b      	mov	r3, r1
 801d89a:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 801d89e:	f00a f94d 	bl	8027b3c <__adddf3>
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801d8a2:	4642      	mov	r2, r8
        REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
 801d8a4:	e9ca 0104 	strd	r0, r1, [sl, #16]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801d8a8:	464b      	mov	r3, r9
 801d8aa:	4630      	mov	r0, r6
 801d8ac:	4639      	mov	r1, r7
 801d8ae:	f00a fafb 	bl	8027ea8 <__aeabi_dmul>
 801d8b2:	4622      	mov	r2, r4
 801d8b4:	462b      	mov	r3, r5
 801d8b6:	4680      	mov	r8, r0
 801d8b8:	4689      	mov	r9, r1
 801d8ba:	ec51 0b19 	vmov	r0, r1, d9
 801d8be:	f00a faf3 	bl	8027ea8 <__aeabi_dmul>
 801d8c2:	4602      	mov	r2, r0
 801d8c4:	460b      	mov	r3, r1
 801d8c6:	4640      	mov	r0, r8
 801d8c8:	4649      	mov	r1, r9
 801d8ca:	f00a f937 	bl	8027b3c <__adddf3>
 801d8ce:	460b      	mov	r3, r1
 801d8d0:	4602      	mov	r2, r0
 801d8d2:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 801d8d6:	f00a f931 	bl	8027b3c <__adddf3>
 801d8da:	9b02      	ldr	r3, [sp, #8]
 801d8dc:	449b      	add	fp, r3
      for (j = i + 1; j < N; j++) {
 801d8de:	9b01      	ldr	r3, [sp, #4]
        IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
 801d8e0:	e9ca 0106 	strd	r0, r1, [sl, #24]
      for (j = i + 1; j < N; j++) {
 801d8e4:	f10a 0a10 	add.w	sl, sl, #16
 801d8e8:	4553      	cmp	r3, sl
 801d8ea:	d1b6      	bne.n	801d85a <cblas_zher+0x402>
 801d8ec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801d8ee:	4413      	add	r3, r2
 801d8f0:	9301      	str	r3, [sp, #4]
 801d8f2:	9a02      	ldr	r2, [sp, #8]
 801d8f4:	9b08      	ldr	r3, [sp, #32]
 801d8f6:	4413      	add	r3, r2
 801d8f8:	9308      	str	r3, [sp, #32]
 801d8fa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801d8fc:	9b07      	ldr	r3, [sp, #28]
 801d8fe:	4413      	add	r3, r2
 801d900:	9307      	str	r3, [sp, #28]
 801d902:	e75f      	b.n	801d7c4 <cblas_zher+0x36c>
      || (order == CblasColMajor && Uplo == CblasLower)) {
 801d904:	2d7a      	cmp	r5, #122	; 0x7a
 801d906:	f43f af25 	beq.w	801d754 <cblas_zher+0x2fc>
             || (order == CblasColMajor && Uplo == CblasUpper)) {
 801d90a:	2d79      	cmp	r5, #121	; 0x79
 801d90c:	f47f ade8 	bne.w	801d4e0 <cblas_zher+0x88>
 801d910:	e60f      	b.n	801d532 <cblas_zher+0xda>
    INDEX ix = OFFSET(N, incX);
 801d912:	9b03      	ldr	r3, [sp, #12]
 801d914:	f1c3 0301 	rsb	r3, r3, #1
 801d918:	fb03 f302 	mul.w	r3, r3, r2
 801d91c:	9306      	str	r3, [sp, #24]
 801d91e:	e71f      	b.n	801d760 <cblas_zher+0x308>
  CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
 801d920:	2008      	movs	r0, #8
 801d922:	e5cd      	b.n	801d4c0 <cblas_zher+0x68>
 801d924:	f3af 8000 	nop.w
	...

0801d930 <cblas_zher2>:

void
cblas_zher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const int N, const void *alpha, const void *X, const int incX,
             const void *Y, const int incY, void *A, const int lda)
{
 801d930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d934:	ed2d 8b10 	vpush	{d8-d15}
  const int conj = (order == CblasColMajor) ? -1 : 1;
 801d938:	2866      	cmp	r0, #102	; 0x66
 801d93a:	b0a1      	sub	sp, #132	; 0x84
 801d93c:	461e      	mov	r6, r3
 801d93e:	bf0c      	ite	eq
 801d940:	f04f 33ff 	moveq.w	r3, #4294967295
 801d944:	2301      	movne	r3, #1
 801d946:	9313      	str	r3, [sp, #76]	; 0x4c
 801d948:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801d94a:	930c      	str	r3, [sp, #48]	; 0x30
 801d94c:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 801d94e:	930a      	str	r3, [sp, #40]	; 0x28
 801d950:	9b3c      	ldr	r3, [sp, #240]	; 0xf0
 801d952:	930d      	str	r3, [sp, #52]	; 0x34
 801d954:	9b3d      	ldr	r3, [sp, #244]	; 0xf4
 801d956:	930b      	str	r3, [sp, #44]	; 0x2c
 801d958:	460d      	mov	r5, r1
 801d95a:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 801d95c:	931c      	str	r3, [sp, #112]	; 0x70
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801d95e:	3979      	subs	r1, #121	; 0x79
 801d960:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
 801d962:	9209      	str	r2, [sp, #36]	; 0x24
 801d964:	2901      	cmp	r1, #1
 801d966:	4604      	mov	r4, r0
 801d968:	9312      	str	r3, [sp, #72]	; 0x48
 801d96a:	f240 8204 	bls.w	801dd76 <cblas_zher2+0x446>
 801d96e:	2002      	movs	r0, #2
 801d970:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801d972:	2b00      	cmp	r3, #0
 801d974:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801d976:	f2c0 81f1 	blt.w	801dd5c <cblas_zher2+0x42c>
 801d97a:	2b00      	cmp	r3, #0
 801d97c:	f040 81d4 	bne.w	801dd28 <cblas_zher2+0x3f8>
 801d980:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801d982:	2b00      	cmp	r3, #0
 801d984:	f040 81e0 	bne.w	801dd48 <cblas_zher2+0x418>
 801d988:	9809      	ldr	r0, [sp, #36]	; 0x24
 801d98a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801d98c:	2801      	cmp	r0, #1
 801d98e:	bfb8      	it	lt
 801d990:	2001      	movlt	r0, #1
 801d992:	4283      	cmp	r3, r0
 801d994:	bfb4      	ite	lt
 801d996:	200a      	movlt	r0, #10
 801d998:	2008      	movge	r0, #8
 801d99a:	4a15      	ldr	r2, [pc, #84]	; (801d9f0 <cblas_zher2+0xc0>)
 801d99c:	4915      	ldr	r1, [pc, #84]	; (801d9f4 <cblas_zher2+0xc4>)
 801d99e:	f00a f853 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801d9a2:	ed96 7b00 	vldr	d7, [r6]
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801d9a6:	2200      	movs	r2, #0
 801d9a8:	ec51 0b17 	vmov	r0, r1, d7
 801d9ac:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 801d9ae:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801d9b2:	f00a fce1 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 801d9b6:	ed96 7b02 	vldr	d7, [r6, #8]
 801d9ba:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801d9be:	b140      	cbz	r0, 801d9d2 <cblas_zher2+0xa2>
 801d9c0:	ec51 0b17 	vmov	r0, r1, d7
 801d9c4:	2200      	movs	r2, #0
 801d9c6:	2300      	movs	r3, #0
 801d9c8:	f00a fcd6 	bl	8028378 <__aeabi_dcmpeq>
 801d9cc:	2800      	cmp	r0, #0
 801d9ce:	f040 81a6 	bne.w	801dd1e <cblas_zher2+0x3ee>
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801d9d2:	2c65      	cmp	r4, #101	; 0x65
 801d9d4:	f000 81dc 	beq.w	801dd90 <cblas_zher2+0x460>
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801d9d8:	2c66      	cmp	r4, #102	; 0x66
 801d9da:	d00f      	beq.n	801d9fc <cblas_zher2+0xcc>
      BLAS_ERROR("unrecognized operation");
 801d9dc:	4a06      	ldr	r2, [pc, #24]	; (801d9f8 <cblas_zher2+0xc8>)
 801d9de:	4905      	ldr	r1, [pc, #20]	; (801d9f4 <cblas_zher2+0xc4>)
 801d9e0:	2000      	movs	r0, #0
#define BASE double
#include "source_her2.h"
#undef BASE
}
 801d9e2:	b021      	add	sp, #132	; 0x84
 801d9e4:	ecbd 8b10 	vpop	{d8-d15}
 801d9e8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d9ec:	f00a b82c 	b.w	8027a48 <cblas_xerbla>
 801d9f0:	08030378 	.word	0x08030378
 801d9f4:	08030720 	.word	0x08030720
 801d9f8:	080305a8 	.word	0x080305a8
        || (order == CblasColMajor && Uplo == CblasLower)) {
 801d9fc:	2d7a      	cmp	r5, #122	; 0x7a
 801d9fe:	f000 81cd 	beq.w	801dd9c <cblas_zher2+0x46c>
               || (order == CblasColMajor && Uplo == CblasUpper)) {
 801da02:	2d79      	cmp	r5, #121	; 0x79
 801da04:	d1ea      	bne.n	801d9dc <cblas_zher2+0xac>
      INDEX ix = OFFSET(N, incX);
 801da06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      INDEX iy = OFFSET(N, incY);
 801da08:	990b      	ldr	r1, [sp, #44]	; 0x2c
      INDEX ix = OFFSET(N, incX);
 801da0a:	2b00      	cmp	r3, #0
 801da0c:	bfdd      	ittte	le
 801da0e:	9a09      	ldrle	r2, [sp, #36]	; 0x24
 801da10:	f1c2 0201 	rsble	r2, r2, #1
 801da14:	435a      	mulle	r2, r3
 801da16:	2200      	movgt	r2, #0
      INDEX iy = OFFSET(N, incY);
 801da18:	2900      	cmp	r1, #0
 801da1a:	bfde      	ittt	le
 801da1c:	9b09      	ldrle	r3, [sp, #36]	; 0x24
 801da1e:	f1c3 0301 	rsble	r3, r3, #1
 801da22:	434b      	mulle	r3, r1
      for (i = 0; i < N; i++) {
 801da24:	9909      	ldr	r1, [sp, #36]	; 0x24
      INDEX iy = OFFSET(N, incY);
 801da26:	bfc8      	it	gt
 801da28:	2300      	movgt	r3, #0
      for (i = 0; i < N; i++) {
 801da2a:	2900      	cmp	r1, #0
 801da2c:	f340 8177 	ble.w	801dd1e <cblas_zher2+0x3ee>
 801da30:	990c      	ldr	r1, [sp, #48]	; 0x30
 801da32:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801da34:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 801da38:	990d      	ldr	r1, [sp, #52]	; 0x34
 801da3a:	921e      	str	r2, [sp, #120]	; 0x78
 801da3c:	eb01 1103 	add.w	r1, r1, r3, lsl #4
 801da40:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801da42:	911d      	str	r1, [sp, #116]	; 0x74
 801da44:	0124      	lsls	r4, r4, #4
 801da46:	3301      	adds	r3, #1
 801da48:	e9dd 560e 	ldrd	r5, r6, [sp, #56]	; 0x38
 801da4c:	011b      	lsls	r3, r3, #4
 801da4e:	9408      	str	r4, [sp, #32]
 801da50:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 801da52:	931a      	str	r3, [sp, #104]	; 0x68
 801da54:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801da56:	9303      	str	r3, [sp, #12]
 801da58:	0124      	lsls	r4, r4, #4
 801da5a:	ed9f 7bcb 	vldr	d7, [pc, #812]	; 801dd88 <cblas_zher2+0x458>
 801da5e:	e9cd 120b 	strd	r1, r2, [sp, #44]	; 0x2c
        IMAG(A, lda * i + i) = 0;
 801da62:	eeb0 8a47 	vmov.f32	s16, s14
 801da66:	eef0 8a67 	vmov.f32	s17, s15
      for (i = 0; i < N; i++) {
 801da6a:	2000      	movs	r0, #0
 801da6c:	9404      	str	r4, [sp, #16]
 801da6e:	3308      	adds	r3, #8
 801da70:	f106 4400 	add.w	r4, r6, #2147483648	; 0x80000000
 801da74:	9518      	str	r5, [sp, #96]	; 0x60
 801da76:	900d      	str	r0, [sp, #52]	; 0x34
 801da78:	9419      	str	r4, [sp, #100]	; 0x64
 801da7a:	900a      	str	r0, [sp, #40]	; 0x28
 801da7c:	931f      	str	r3, [sp, #124]	; 0x7c
        const BASE Xi_real = CONST_REAL(X, ix);
 801da7e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801da80:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
        const BASE Xi_real = CONST_REAL(X, ix);
 801da84:	e9d4 8900 	ldrd	r8, r9, [r4]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801da88:	4650      	mov	r0, sl
 801da8a:	464b      	mov	r3, r9
 801da8c:	4642      	mov	r2, r8
 801da8e:	4659      	mov	r1, fp
 801da90:	f00a fa0a 	bl	8027ea8 <__aeabi_dmul>
        const BASE Xi_imag = CONST_IMAG(X, ix);
 801da94:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801da98:	ed9d ab0e 	vldr	d10, [sp, #56]	; 0x38
 801da9c:	4632      	mov	r2, r6
 801da9e:	463b      	mov	r3, r7
 801daa0:	4604      	mov	r4, r0
 801daa2:	460d      	mov	r5, r1
 801daa4:	ec51 0b1a 	vmov	r0, r1, d10
 801daa8:	f00a f9fe 	bl	8027ea8 <__aeabi_dmul>
 801daac:	4602      	mov	r2, r0
 801daae:	460b      	mov	r3, r1
 801dab0:	4620      	mov	r0, r4
 801dab2:	4629      	mov	r1, r5
 801dab4:	f00a f840 	bl	8027b38 <__aeabi_dsub>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801dab8:	464b      	mov	r3, r9
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801daba:	4604      	mov	r4, r0
 801dabc:	460d      	mov	r5, r1
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801dabe:	4642      	mov	r2, r8
 801dac0:	ec51 0b1a 	vmov	r0, r1, d10
 801dac4:	f00a f9f0 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801dac8:	ec45 4b1f 	vmov	d15, r4, r5
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801dacc:	4632      	mov	r2, r6
 801dace:	463b      	mov	r3, r7
 801dad0:	4604      	mov	r4, r0
 801dad2:	460d      	mov	r5, r1
 801dad4:	4650      	mov	r0, sl
 801dad6:	4659      	mov	r1, fp
 801dad8:	f00a f9e6 	bl	8027ea8 <__aeabi_dmul>
 801dadc:	4602      	mov	r2, r0
 801dade:	460b      	mov	r3, r1
 801dae0:	4620      	mov	r0, r4
 801dae2:	4629      	mov	r1, r5
 801dae4:	f00a f82a 	bl	8027b3c <__adddf3>
        const BASE Yi_real = CONST_REAL(Y, iy);
 801dae8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 801daea:	ed96 7b00 	vldr	d7, [r6]
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 801daee:	ed96 9b02 	vldr	d9, [r6, #8]
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801daf2:	4604      	mov	r4, r0
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801daf4:	4657      	mov	r7, sl
 801daf6:	4650      	mov	r0, sl
 801daf8:	ec5a 9b17 	vmov	r9, sl, d7
 801dafc:	ee17 2a10 	vmov	r2, s14
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801db00:	460d      	mov	r5, r1
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801db02:	4653      	mov	r3, sl
 801db04:	4659      	mov	r1, fp
        const BASE Yi_real = CONST_REAL(Y, iy);
 801db06:	ed8d 7b14 	vstr	d7, [sp, #80]	; 0x50
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 801db0a:	ed8d 9b16 	vstr	d9, [sp, #88]	; 0x58
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801db0e:	f00a f9cb 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801db12:	ec45 4b1d 	vmov	d13, r4, r5
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801db16:	ec53 2b19 	vmov	r2, r3, d9
 801db1a:	4604      	mov	r4, r0
 801db1c:	460d      	mov	r5, r1
 801db1e:	ec51 0b1a 	vmov	r0, r1, d10
 801db22:	f00a f9c1 	bl	8027ea8 <__aeabi_dmul>
 801db26:	4602      	mov	r2, r0
 801db28:	460b      	mov	r3, r1
 801db2a:	4620      	mov	r0, r4
 801db2c:	4629      	mov	r1, r5
 801db2e:	f00a f805 	bl	8027b3c <__adddf3>
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801db32:	e9dd 2318 	ldrd	r2, r3, [sp, #96]	; 0x60
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801db36:	4604      	mov	r4, r0
 801db38:	460d      	mov	r5, r1
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801db3a:	4648      	mov	r0, r9
 801db3c:	4651      	mov	r1, sl
 801db3e:	f00a f9b3 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801db42:	ec45 4b1c 	vmov	d12, r4, r5
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801db46:	ec53 2b19 	vmov	r2, r3, d9
 801db4a:	4604      	mov	r4, r0
 801db4c:	460d      	mov	r5, r1
 801db4e:	4638      	mov	r0, r7
 801db50:	4659      	mov	r1, fp
 801db52:	f00a f9a9 	bl	8027ea8 <__aeabi_dmul>
 801db56:	460b      	mov	r3, r1
 801db58:	4602      	mov	r2, r0
 801db5a:	4629      	mov	r1, r5
 801db5c:	4620      	mov	r0, r4
 801db5e:	f009 ffed 	bl	8027b3c <__adddf3>
        for (j = 0; j < i; j++) {
 801db62:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801db64:	ec41 0b1b 	vmov	d11, r0, r1
        for (j = 0; j < i; j++) {
 801db68:	2b00      	cmp	r3, #0
 801db6a:	f000 809f 	beq.w	801dcac <cblas_zher2+0x37c>
 801db6e:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801db70:	f00a f930 	bl	8027dd4 <__aeabi_i2d>
 801db74:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801db76:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801db78:	e9cd 0106 	strd	r0, r1, [sp, #24]
 801db7c:	e9dd 451d 	ldrd	r4, r5, [sp, #116]	; 0x74
 801db80:	4619      	mov	r1, r3
 801db82:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801db84:	eb01 1a03 	add.w	sl, r1, r3, lsl #4
 801db88:	eb02 1b03 	add.w	fp, r2, r3, lsl #4
          const BASE Yj_real = CONST_REAL(Y, jy);
 801db8c:	ed94 7b00 	vldr	d7, [r4]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801db90:	ed94 6b02 	vldr	d6, [r4, #8]
          const BASE Yj_real = CONST_REAL(Y, jy);
 801db94:	eeb0 ea47 	vmov.f32	s28, s14
 801db98:	eef0 ea67 	vmov.f32	s29, s15
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801db9c:	ec53 2b17 	vmov	r2, r3, d7
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801dba0:	eeb0 9a46 	vmov.f32	s18, s12
 801dba4:	eef0 9a66 	vmov.f32	s19, s13
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dba8:	ec51 0b1f 	vmov	r0, r1, d15
 801dbac:	f00a f97c 	bl	8027ea8 <__aeabi_dmul>
 801dbb0:	ec53 2b19 	vmov	r2, r3, d9
 801dbb4:	4606      	mov	r6, r0
 801dbb6:	460f      	mov	r7, r1
 801dbb8:	ec51 0b1d 	vmov	r0, r1, d13
 801dbbc:	f00a f974 	bl	8027ea8 <__aeabi_dmul>
 801dbc0:	4602      	mov	r2, r0
 801dbc2:	460b      	mov	r3, r1
 801dbc4:	4630      	mov	r0, r6
 801dbc6:	4639      	mov	r1, r7
 801dbc8:	f009 ffb8 	bl	8027b3c <__adddf3>
          const BASE Xj_real = CONST_REAL(X, jx);
 801dbcc:	e9d5 8900 	ldrd	r8, r9, [r5]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dbd0:	ec41 0b1a 	vmov	d10, r0, r1
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801dbd4:	4642      	mov	r2, r8
 801dbd6:	464b      	mov	r3, r9
 801dbd8:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Xj_imag = CONST_IMAG(X, jx);
 801dbdc:	e9d5 6702 	ldrd	r6, r7, [r5, #8]
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801dbe0:	f00a f962 	bl	8027ea8 <__aeabi_dmul>
 801dbe4:	4632      	mov	r2, r6
 801dbe6:	463b      	mov	r3, r7
 801dbe8:	e9cd 0100 	strd	r0, r1, [sp]
 801dbec:	ec51 0b1b 	vmov	r0, r1, d11
 801dbf0:	f00a f95a 	bl	8027ea8 <__aeabi_dmul>
 801dbf4:	4602      	mov	r2, r0
 801dbf6:	460b      	mov	r3, r1
 801dbf8:	e9dd 0100 	ldrd	r0, r1, [sp]
 801dbfc:	f009 ff9e 	bl	8027b3c <__adddf3>
 801dc00:	4602      	mov	r2, r0
 801dc02:	460b      	mov	r3, r1
 801dc04:	ec51 0b1a 	vmov	r0, r1, d10
 801dc08:	f009 ff98 	bl	8027b3c <__adddf3>
 801dc0c:	4602      	mov	r2, r0
 801dc0e:	460b      	mov	r3, r1
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dc10:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 801dc14:	f009 ff92 	bl	8027b3c <__adddf3>
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801dc18:	ec53 2b1e 	vmov	r2, r3, d14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dc1c:	e94b 0102 	strd	r0, r1, [fp, #-8]
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801dc20:	ec51 0b1d 	vmov	r0, r1, d13
 801dc24:	f00a f940 	bl	8027ea8 <__aeabi_dmul>
 801dc28:	ec53 2b19 	vmov	r2, r3, d9
 801dc2c:	ec41 0b19 	vmov	d9, r0, r1
 801dc30:	ec51 0b1f 	vmov	r0, r1, d15
 801dc34:	f00a f938 	bl	8027ea8 <__aeabi_dmul>
 801dc38:	4602      	mov	r2, r0
 801dc3a:	460b      	mov	r3, r1
 801dc3c:	ec51 0b19 	vmov	r0, r1, d9
 801dc40:	f009 ff7a 	bl	8027b38 <__aeabi_dsub>
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801dc44:	4642      	mov	r2, r8
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801dc46:	ec41 0b19 	vmov	d9, r0, r1
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801dc4a:	464b      	mov	r3, r9
 801dc4c:	ec51 0b1b 	vmov	r0, r1, d11
 801dc50:	f00a f92a 	bl	8027ea8 <__aeabi_dmul>
 801dc54:	4632      	mov	r2, r6
 801dc56:	463b      	mov	r3, r7
 801dc58:	4606      	mov	r6, r0
 801dc5a:	460f      	mov	r7, r1
 801dc5c:	ec51 0b1c 	vmov	r0, r1, d12
 801dc60:	f00a f922 	bl	8027ea8 <__aeabi_dmul>
 801dc64:	4602      	mov	r2, r0
 801dc66:	460b      	mov	r3, r1
 801dc68:	4630      	mov	r0, r6
 801dc6a:	4639      	mov	r1, r7
 801dc6c:	f009 ff64 	bl	8027b38 <__aeabi_dsub>
 801dc70:	4602      	mov	r2, r0
 801dc72:	460b      	mov	r3, r1
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801dc74:	ec51 0b19 	vmov	r0, r1, d9
 801dc78:	f009 ff60 	bl	8027b3c <__adddf3>
 801dc7c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 801dc80:	f00a f912 	bl	8027ea8 <__aeabi_dmul>
 801dc84:	460b      	mov	r3, r1
 801dc86:	4602      	mov	r2, r0
          IMAG(A, lda * i + j) +=
 801dc88:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 801dc8c:	f009 ff56 	bl	8027b3c <__adddf3>
 801dc90:	9b04      	ldr	r3, [sp, #16]
 801dc92:	441c      	add	r4, r3
 801dc94:	9b08      	ldr	r3, [sp, #32]
 801dc96:	441d      	add	r5, r3
        for (j = 0; j < i; j++) {
 801dc98:	9b03      	ldr	r3, [sp, #12]
          IMAG(A, lda * i + j) +=
 801dc9a:	e9ca 0102 	strd	r0, r1, [sl, #8]
        for (j = 0; j < i; j++) {
 801dc9e:	f10a 0a10 	add.w	sl, sl, #16
 801dca2:	4553      	cmp	r3, sl
 801dca4:	f10b 0b10 	add.w	fp, fp, #16
 801dca8:	f47f af70 	bne.w	801db8c <cblas_zher2+0x25c>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801dcac:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
 801dcb0:	ec51 0b1f 	vmov	r0, r1, d15
 801dcb4:	f00a f8f8 	bl	8027ea8 <__aeabi_dmul>
 801dcb8:	e9dd 2316 	ldrd	r2, r3, [sp, #88]	; 0x58
 801dcbc:	4604      	mov	r4, r0
 801dcbe:	460d      	mov	r5, r1
 801dcc0:	ec51 0b1d 	vmov	r0, r1, d13
 801dcc4:	f00a f8f0 	bl	8027ea8 <__aeabi_dmul>
 801dcc8:	4602      	mov	r2, r0
 801dcca:	460b      	mov	r3, r1
 801dccc:	4620      	mov	r0, r4
 801dcce:	4629      	mov	r1, r5
 801dcd0:	f009 ff34 	bl	8027b3c <__adddf3>
 801dcd4:	4602      	mov	r2, r0
 801dcd6:	460b      	mov	r3, r1
 801dcd8:	f009 ff30 	bl	8027b3c <__adddf3>
 801dcdc:	9c03      	ldr	r4, [sp, #12]
 801dcde:	4602      	mov	r2, r0
 801dce0:	460b      	mov	r3, r1
 801dce2:	e9d4 0100 	ldrd	r0, r1, [r4]
 801dce6:	f009 ff29 	bl	8027b3c <__adddf3>
 801dcea:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801dcec:	9d08      	ldr	r5, [sp, #32]
      for (i = 0; i < N; i++) {
 801dcee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801dcf0:	442b      	add	r3, r5
 801dcf2:	930c      	str	r3, [sp, #48]	; 0x30
 801dcf4:	9d04      	ldr	r5, [sp, #16]
 801dcf6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dcf8:	442b      	add	r3, r5
 801dcfa:	930b      	str	r3, [sp, #44]	; 0x2c
 801dcfc:	9d12      	ldr	r5, [sp, #72]	; 0x48
 801dcfe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801dd00:	442b      	add	r3, r5
 801dd02:	930d      	str	r3, [sp, #52]	; 0x34
 801dd04:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801dd06:	18e3      	adds	r3, r4, r3
 801dd08:	9303      	str	r3, [sp, #12]
 801dd0a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801dd0c:	3201      	adds	r2, #1
 801dd0e:	4293      	cmp	r3, r2
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801dd10:	e9c4 0100 	strd	r0, r1, [r4]
        IMAG(A, lda * i + i) = 0;
 801dd14:	ed84 8b02 	vstr	d8, [r4, #8]
      for (i = 0; i < N; i++) {
 801dd18:	920a      	str	r2, [sp, #40]	; 0x28
 801dd1a:	f47f aeb0 	bne.w	801da7e <cblas_zher2+0x14e>
 801dd1e:	b021      	add	sp, #132	; 0x84
 801dd20:	ecbd 8b10 	vpop	{d8-d15}
 801dd24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801dd28:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dd2a:	2b00      	cmp	r3, #0
 801dd2c:	f43f ae2c 	beq.w	801d988 <cblas_zher2+0x58>
 801dd30:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801dd32:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801dd34:	2b01      	cmp	r3, #1
 801dd36:	bfb8      	it	lt
 801dd38:	2301      	movlt	r3, #1
 801dd3a:	4293      	cmp	r3, r2
 801dd3c:	f300 81c3 	bgt.w	801e0c6 <cblas_zher2+0x796>
 801dd40:	2800      	cmp	r0, #0
 801dd42:	f43f ae2e 	beq.w	801d9a2 <cblas_zher2+0x72>
 801dd46:	e628      	b.n	801d99a <cblas_zher2+0x6a>
 801dd48:	9809      	ldr	r0, [sp, #36]	; 0x24
 801dd4a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801dd4c:	2801      	cmp	r0, #1
 801dd4e:	bfb8      	it	lt
 801dd50:	2001      	movlt	r0, #1
 801dd52:	4283      	cmp	r3, r0
 801dd54:	bfb4      	ite	lt
 801dd56:	200a      	movlt	r0, #10
 801dd58:	2006      	movge	r0, #6
 801dd5a:	e61e      	b.n	801d99a <cblas_zher2+0x6a>
 801dd5c:	2b00      	cmp	r3, #0
 801dd5e:	f43f ae0f 	beq.w	801d980 <cblas_zher2+0x50>
 801dd62:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dd64:	2b00      	cmp	r3, #0
 801dd66:	f43f ae0f 	beq.w	801d988 <cblas_zher2+0x58>
 801dd6a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801dd6c:	2b00      	cmp	r3, #0
 801dd6e:	bfd4      	ite	le
 801dd70:	200a      	movle	r0, #10
 801dd72:	2003      	movgt	r0, #3
 801dd74:	e611      	b.n	801d99a <cblas_zher2+0x6a>
 801dd76:	3865      	subs	r0, #101	; 0x65
 801dd78:	2801      	cmp	r0, #1
 801dd7a:	bf94      	ite	ls
 801dd7c:	2000      	movls	r0, #0
 801dd7e:	2001      	movhi	r0, #1
 801dd80:	e5f6      	b.n	801d970 <cblas_zher2+0x40>
 801dd82:	bf00      	nop
 801dd84:	f3af 8000 	nop.w
	...
    if ((order == CblasRowMajor && Uplo == CblasUpper)
 801dd90:	2d79      	cmp	r5, #121	; 0x79
 801dd92:	d003      	beq.n	801dd9c <cblas_zher2+0x46c>
    } else if ((order == CblasRowMajor && Uplo == CblasLower)
 801dd94:	2d7a      	cmp	r5, #122	; 0x7a
 801dd96:	f47f ae21 	bne.w	801d9dc <cblas_zher2+0xac>
 801dd9a:	e634      	b.n	801da06 <cblas_zher2+0xd6>
      INDEX ix = OFFSET(N, incX);
 801dd9c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801dd9e:	2a00      	cmp	r2, #0
 801dda0:	bfde      	ittt	le
 801dda2:	9b09      	ldrle	r3, [sp, #36]	; 0x24
 801dda4:	f1c3 0301 	rsble	r3, r3, #1
 801dda8:	4353      	mulle	r3, r2
      INDEX iy = OFFSET(N, incY);
 801ddaa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
      INDEX ix = OFFSET(N, incX);
 801ddac:	bfc8      	it	gt
 801ddae:	2300      	movgt	r3, #0
      INDEX iy = OFFSET(N, incY);
 801ddb0:	2a00      	cmp	r2, #0
      INDEX ix = OFFSET(N, incX);
 801ddb2:	9314      	str	r3, [sp, #80]	; 0x50
      INDEX iy = OFFSET(N, incY);
 801ddb4:	f340 8180 	ble.w	801e0b8 <cblas_zher2+0x788>
 801ddb8:	2300      	movs	r3, #0
 801ddba:	9316      	str	r3, [sp, #88]	; 0x58
      for (i = 0; i < N; i++) {
 801ddbc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801ddbe:	2b00      	cmp	r3, #0
 801ddc0:	ddad      	ble.n	801dd1e <cblas_zher2+0x3ee>
 801ddc2:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801ddc4:	991c      	ldr	r1, [sp, #112]	; 0x70
 801ddc6:	011a      	lsls	r2, r3, #4
 801ddc8:	921e      	str	r2, [sp, #120]	; 0x78
 801ddca:	3210      	adds	r2, #16
 801ddcc:	921d      	str	r2, [sp, #116]	; 0x74
 801ddce:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801ddd0:	f1a1 0310 	sub.w	r3, r1, #16
 801ddd4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801ddd8:	9303      	str	r3, [sp, #12]
 801ddda:	f101 0308 	add.w	r3, r1, #8
 801ddde:	9306      	str	r3, [sp, #24]
 801dde0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801dde2:	011b      	lsls	r3, r3, #4
 801dde4:	931f      	str	r3, [sp, #124]	; 0x7c
 801dde6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801dde8:	011b      	lsls	r3, r3, #4
 801ddea:	9308      	str	r3, [sp, #32]
 801ddec:	2300      	movs	r3, #0
 801ddee:	9312      	str	r3, [sp, #72]	; 0x48
 801ddf0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 801ddf2:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
 801ddf6:	011b      	lsls	r3, r3, #4
 801ddf8:	931c      	str	r3, [sp, #112]	; 0x70
 801ddfa:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801ddfc:	941a      	str	r4, [sp, #104]	; 0x68
 801ddfe:	ed1f 7b1e 	vldr	d7, [pc, #-120]	; 801dd88 <cblas_zher2+0x458>
 801de02:	f105 4000 	add.w	r0, r5, #2147483648	; 0x80000000
 801de06:	011b      	lsls	r3, r3, #4
 801de08:	901b      	str	r0, [sp, #108]	; 0x6c
 801de0a:	9318      	str	r3, [sp, #96]	; 0x60
        IMAG(A, lda * i + i) = 0;
 801de0c:	eeb0 8a47 	vmov.f32	s16, s14
 801de10:	eef0 8a67 	vmov.f32	s17, s15
        const BASE Xi_real = CONST_REAL(X, ix);
 801de14:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801de16:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801de18:	4413      	add	r3, r2
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801de1a:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
        const BASE Xi_real = CONST_REAL(X, ix);
 801de1e:	e9d3 8900 	ldrd	r8, r9, [r3]
        const BASE Xi_imag = CONST_IMAG(X, ix);
 801de22:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801de26:	4642      	mov	r2, r8
 801de28:	464b      	mov	r3, r9
 801de2a:	4650      	mov	r0, sl
 801de2c:	4659      	mov	r1, fp
 801de2e:	f00a f83b 	bl	8027ea8 <__aeabi_dmul>
 801de32:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
 801de36:	4632      	mov	r2, r6
 801de38:	463b      	mov	r3, r7
 801de3a:	4604      	mov	r4, r0
 801de3c:	460d      	mov	r5, r1
 801de3e:	ec51 0b19 	vmov	r0, r1, d9
 801de42:	f00a f831 	bl	8027ea8 <__aeabi_dmul>
 801de46:	4602      	mov	r2, r0
 801de48:	460b      	mov	r3, r1
 801de4a:	4620      	mov	r0, r4
 801de4c:	4629      	mov	r1, r5
 801de4e:	f009 fe73 	bl	8027b38 <__aeabi_dsub>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801de52:	4642      	mov	r2, r8
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801de54:	4604      	mov	r4, r0
 801de56:	460d      	mov	r5, r1
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801de58:	464b      	mov	r3, r9
 801de5a:	ec51 0b19 	vmov	r0, r1, d9
 801de5e:	f00a f823 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801de62:	ec45 4b1b 	vmov	d11, r4, r5
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801de66:	4632      	mov	r2, r6
 801de68:	463b      	mov	r3, r7
 801de6a:	4604      	mov	r4, r0
 801de6c:	460d      	mov	r5, r1
 801de6e:	4650      	mov	r0, sl
 801de70:	4659      	mov	r1, fp
 801de72:	f00a f819 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
 801de76:	eeb0 fa4b 	vmov.f32	s30, s22
 801de7a:	eef0 fa6b 	vmov.f32	s31, s23
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801de7e:	4602      	mov	r2, r0
 801de80:	460b      	mov	r3, r1
 801de82:	4620      	mov	r0, r4
 801de84:	4629      	mov	r1, r5
 801de86:	f009 fe59 	bl	8027b3c <__adddf3>
 801de8a:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801de8c:	4689      	mov	r9, r1
 801de8e:	990d      	ldr	r1, [sp, #52]	; 0x34
 801de90:	440b      	add	r3, r1
        const BASE Yi_real = CONST_REAL(Y, iy);
 801de92:	e9d3 6700 	ldrd	r6, r7, [r3]
        const BASE Yi_imag = CONST_IMAG(Y, iy);
 801de96:	e9d3 4502 	ldrd	r4, r5, [r3, #8]
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801de9a:	4680      	mov	r8, r0
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801de9c:	4632      	mov	r2, r6
 801de9e:	463b      	mov	r3, r7
 801dea0:	4650      	mov	r0, sl
 801dea2:	4659      	mov	r1, fp
 801dea4:	f00a f800 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801dea8:	ec49 8b1a 	vmov	d10, r8, r9
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801deac:	4622      	mov	r2, r4
 801deae:	462b      	mov	r3, r5
 801deb0:	4680      	mov	r8, r0
 801deb2:	4689      	mov	r9, r1
 801deb4:	ec51 0b19 	vmov	r0, r1, d9
        const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
 801deb8:	eeb0 da4a 	vmov.f32	s26, s20
 801debc:	eef0 da6a 	vmov.f32	s27, s21
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801dec0:	f009 fff2 	bl	8027ea8 <__aeabi_dmul>
 801dec4:	4602      	mov	r2, r0
 801dec6:	460b      	mov	r3, r1
 801dec8:	4640      	mov	r0, r8
 801deca:	4649      	mov	r1, r9
 801decc:	f009 fe36 	bl	8027b3c <__adddf3>
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801ded0:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	; 0x68
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801ded4:	4680      	mov	r8, r0
 801ded6:	4689      	mov	r9, r1
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801ded8:	4630      	mov	r0, r6
 801deda:	4639      	mov	r1, r7
 801dedc:	f009 ffe4 	bl	8027ea8 <__aeabi_dmul>
        const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
 801dee0:	ec49 8b1c 	vmov	d12, r8, r9
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801dee4:	4622      	mov	r2, r4
 801dee6:	462b      	mov	r3, r5
 801dee8:	4680      	mov	r8, r0
 801deea:	4689      	mov	r9, r1
 801deec:	4650      	mov	r0, sl
 801deee:	4659      	mov	r1, fp
 801def0:	f009 ffda 	bl	8027ea8 <__aeabi_dmul>
 801def4:	4602      	mov	r2, r0
 801def6:	460b      	mov	r3, r1
 801def8:	4640      	mov	r0, r8
 801defa:	4649      	mov	r1, r9
 801defc:	f009 fe1e 	bl	8027b3c <__adddf3>
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801df00:	4632      	mov	r2, r6
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801df02:	4680      	mov	r8, r0
 801df04:	4689      	mov	r9, r1
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801df06:	463b      	mov	r3, r7
 801df08:	ec51 0b1b 	vmov	r0, r1, d11
 801df0c:	f009 ffcc 	bl	8027ea8 <__aeabi_dmul>
 801df10:	4622      	mov	r2, r4
 801df12:	462b      	mov	r3, r5
 801df14:	4604      	mov	r4, r0
 801df16:	460d      	mov	r5, r1
 801df18:	ec51 0b1a 	vmov	r0, r1, d10
 801df1c:	f009 ffc4 	bl	8027ea8 <__aeabi_dmul>
 801df20:	4602      	mov	r2, r0
 801df22:	460b      	mov	r3, r1
 801df24:	4620      	mov	r0, r4
 801df26:	4629      	mov	r1, r5
 801df28:	f009 fe08 	bl	8027b3c <__adddf3>
 801df2c:	4602      	mov	r2, r0
 801df2e:	460b      	mov	r3, r1
 801df30:	f009 fe04 	bl	8027b3c <__adddf3>
 801df34:	9c06      	ldr	r4, [sp, #24]
 801df36:	4602      	mov	r2, r0
 801df38:	460b      	mov	r3, r1
 801df3a:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801df3e:	f009 fdfd 	bl	8027b3c <__adddf3>
        for (j = i + 1; j < N; j++) {
 801df42:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801df44:	3201      	adds	r2, #1
 801df46:	9212      	str	r2, [sp, #72]	; 0x48
        INDEX jx = ix + incX;
 801df48:	9d14      	ldr	r5, [sp, #80]	; 0x50
 801df4a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        INDEX jy = iy + incY;
 801df4c:	9e16      	ldr	r6, [sp, #88]	; 0x58
        INDEX jx = ix + incX;
 801df4e:	441d      	add	r5, r3
        INDEX jy = iy + incY;
 801df50:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        INDEX jx = ix + incX;
 801df52:	9514      	str	r5, [sp, #80]	; 0x50
        INDEX jy = iy + incY;
 801df54:	441e      	add	r6, r3
        for (j = i + 1; j < N; j++) {
 801df56:	9b09      	ldr	r3, [sp, #36]	; 0x24
        INDEX jy = iy + incY;
 801df58:	9616      	str	r6, [sp, #88]	; 0x58
        for (j = i + 1; j < N; j++) {
 801df5a:	4293      	cmp	r3, r2
        REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
 801df5c:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(A, lda * i + i) = 0;
 801df60:	ed84 8b00 	vstr	d8, [r4]
        const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
 801df64:	ec49 8b1b 	vmov	d11, r8, r9
        for (j = i + 1; j < N; j++) {
 801df68:	f43f aed9 	beq.w	801dd1e <cblas_zher2+0x3ee>
 801df6c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801df6e:	f009 ff31 	bl	8027dd4 <__aeabi_i2d>
 801df72:	012b      	lsls	r3, r5, #4
 801df74:	e9cd 0104 	strd	r0, r1, [sp, #16]
 801df78:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801df7a:	990d      	ldr	r1, [sp, #52]	; 0x34
 801df7c:	931c      	str	r3, [sp, #112]	; 0x70
 801df7e:	f8dd b07c 	ldr.w	fp, [sp, #124]	; 0x7c
 801df82:	0133      	lsls	r3, r6, #4
 801df84:	eb02 1a05 	add.w	sl, r2, r5, lsl #4
 801df88:	9318      	str	r3, [sp, #96]	; 0x60
 801df8a:	eb01 1506 	add.w	r5, r1, r6, lsl #4
 801df8e:	3c08      	subs	r4, #8
          const BASE Yj_real = CONST_REAL(Y, jy);
 801df90:	ed95 7b00 	vldr	d7, [r5]
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801df94:	ed95 6b02 	vldr	d6, [r5, #8]
          const BASE Yj_real = CONST_REAL(Y, jy);
 801df98:	eeb0 ea47 	vmov.f32	s28, s14
 801df9c:	eef0 ea67 	vmov.f32	s29, s15
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dfa0:	ec53 2b17 	vmov	r2, r3, d7
          const BASE Yj_imag = CONST_IMAG(Y, jy);
 801dfa4:	eeb0 9a46 	vmov.f32	s18, s12
 801dfa8:	eef0 9a66 	vmov.f32	s19, s13
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dfac:	ec51 0b1f 	vmov	r0, r1, d15
 801dfb0:	f009 ff7a 	bl	8027ea8 <__aeabi_dmul>
 801dfb4:	ec53 2b19 	vmov	r2, r3, d9
 801dfb8:	4606      	mov	r6, r0
 801dfba:	460f      	mov	r7, r1
 801dfbc:	ec51 0b1d 	vmov	r0, r1, d13
 801dfc0:	f009 ff72 	bl	8027ea8 <__aeabi_dmul>
 801dfc4:	4602      	mov	r2, r0
 801dfc6:	460b      	mov	r3, r1
 801dfc8:	4630      	mov	r0, r6
 801dfca:	4639      	mov	r1, r7
 801dfcc:	f009 fdb6 	bl	8027b3c <__adddf3>
          const BASE Xj_real = CONST_REAL(X, jx);
 801dfd0:	ed9a ab00 	vldr	d10, [sl]
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dfd4:	4606      	mov	r6, r0
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801dfd6:	ec53 2b1a 	vmov	r2, r3, d10
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801dfda:	460f      	mov	r7, r1
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801dfdc:	ec51 0b1c 	vmov	r0, r1, d12
          const BASE Xj_imag = CONST_IMAG(X, jx);
 801dfe0:	e9da 8902 	ldrd	r8, r9, [sl, #8]
                                   + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
 801dfe4:	f009 ff60 	bl	8027ea8 <__aeabi_dmul>
 801dfe8:	4642      	mov	r2, r8
 801dfea:	464b      	mov	r3, r9
 801dfec:	e9cd 0100 	strd	r0, r1, [sp]
 801dff0:	ec51 0b1b 	vmov	r0, r1, d11
 801dff4:	f009 ff58 	bl	8027ea8 <__aeabi_dmul>
 801dff8:	4602      	mov	r2, r0
 801dffa:	460b      	mov	r3, r1
 801dffc:	e9dd 0100 	ldrd	r0, r1, [sp]
 801e000:	f009 fd9c 	bl	8027b3c <__adddf3>
 801e004:	4602      	mov	r2, r0
 801e006:	460b      	mov	r3, r1
 801e008:	4630      	mov	r0, r6
 801e00a:	4639      	mov	r1, r7
 801e00c:	f009 fd96 	bl	8027b3c <__adddf3>
 801e010:	4602      	mov	r2, r0
 801e012:	460b      	mov	r3, r1
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e014:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801e018:	f009 fd90 	bl	8027b3c <__adddf3>
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e01c:	ec53 2b1e 	vmov	r2, r3, d14
          REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
 801e020:	e9c4 0104 	strd	r0, r1, [r4, #16]
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e024:	ec51 0b1d 	vmov	r0, r1, d13
 801e028:	f009 ff3e 	bl	8027ea8 <__aeabi_dmul>
 801e02c:	ec53 2b19 	vmov	r2, r3, d9
 801e030:	4606      	mov	r6, r0
 801e032:	460f      	mov	r7, r1
 801e034:	ec51 0b1f 	vmov	r0, r1, d15
 801e038:	f009 ff36 	bl	8027ea8 <__aeabi_dmul>
 801e03c:	4602      	mov	r2, r0
 801e03e:	460b      	mov	r3, r1
 801e040:	4630      	mov	r0, r6
 801e042:	4639      	mov	r1, r7
 801e044:	f009 fd78 	bl	8027b38 <__aeabi_dsub>
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801e048:	ec53 2b1a 	vmov	r2, r3, d10
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e04c:	4606      	mov	r6, r0
 801e04e:	460f      	mov	r7, r1
                    (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
 801e050:	ec51 0b1b 	vmov	r0, r1, d11
 801e054:	f009 ff28 	bl	8027ea8 <__aeabi_dmul>
 801e058:	4642      	mov	r2, r8
 801e05a:	464b      	mov	r3, r9
 801e05c:	4680      	mov	r8, r0
 801e05e:	4689      	mov	r9, r1
 801e060:	ec51 0b1c 	vmov	r0, r1, d12
 801e064:	f009 ff20 	bl	8027ea8 <__aeabi_dmul>
 801e068:	4602      	mov	r2, r0
 801e06a:	460b      	mov	r3, r1
 801e06c:	4640      	mov	r0, r8
 801e06e:	4649      	mov	r1, r9
 801e070:	f009 fd62 	bl	8027b38 <__aeabi_dsub>
 801e074:	4602      	mov	r2, r0
 801e076:	460b      	mov	r3, r1
            conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
 801e078:	4630      	mov	r0, r6
 801e07a:	4639      	mov	r1, r7
 801e07c:	f009 fd5e 	bl	8027b3c <__adddf3>
 801e080:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 801e084:	f009 ff10 	bl	8027ea8 <__aeabi_dmul>
 801e088:	460b      	mov	r3, r1
 801e08a:	4602      	mov	r2, r0
          IMAG(A, lda * i + j) +=
 801e08c:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801e090:	f009 fd54 	bl	8027b3c <__adddf3>
 801e094:	9b08      	ldr	r3, [sp, #32]
 801e096:	441d      	add	r5, r3
        for (j = i + 1; j < N; j++) {
 801e098:	9b03      	ldr	r3, [sp, #12]
          IMAG(A, lda * i + j) +=
 801e09a:	e9c4 0106 	strd	r0, r1, [r4, #24]
        for (j = i + 1; j < N; j++) {
 801e09e:	3410      	adds	r4, #16
 801e0a0:	42a3      	cmp	r3, r4
 801e0a2:	44da      	add	sl, fp
 801e0a4:	f47f af74 	bne.w	801df90 <cblas_zher2+0x660>
 801e0a8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801e0aa:	4413      	add	r3, r2
 801e0ac:	9303      	str	r3, [sp, #12]
 801e0ae:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801e0b0:	9b06      	ldr	r3, [sp, #24]
 801e0b2:	4413      	add	r3, r2
 801e0b4:	9306      	str	r3, [sp, #24]
 801e0b6:	e6ad      	b.n	801de14 <cblas_zher2+0x4e4>
      INDEX iy = OFFSET(N, incY);
 801e0b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e0ba:	f1c3 0301 	rsb	r3, r3, #1
 801e0be:	fb03 f302 	mul.w	r3, r3, r2
 801e0c2:	9316      	str	r3, [sp, #88]	; 0x58
 801e0c4:	e67a      	b.n	801ddbc <cblas_zher2+0x48c>
  CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
 801e0c6:	200a      	movs	r0, #10
 801e0c8:	e467      	b.n	801d99a <cblas_zher2+0x6a>
 801e0ca:	bf00      	nop
 801e0cc:	0000      	movs	r0, r0
	...

0801e0d0 <cblas_zher2k>:
void
cblas_zher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const double beta, void *C, const int ldc)
{
 801e0d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e0d4:	ed2d 8b10 	vpush	{d8-d15}
 801e0d8:	b0ab      	sub	sp, #172	; 0xac
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801e0da:	2865      	cmp	r0, #101	; 0x65
 801e0dc:	9313      	str	r3, [sp, #76]	; 0x4c
 801e0de:	9b44      	ldr	r3, [sp, #272]	; 0x110
 801e0e0:	9317      	str	r3, [sp, #92]	; 0x5c
 801e0e2:	e9dd 6345 	ldrd	r6, r3, [sp, #276]	; 0x114
 801e0e6:	931b      	str	r3, [sp, #108]	; 0x6c
 801e0e8:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 801e0ea:	9316      	str	r3, [sp, #88]	; 0x58
 801e0ec:	9b48      	ldr	r3, [sp, #288]	; 0x120
 801e0ee:	931a      	str	r3, [sp, #104]	; 0x68
 801e0f0:	9b49      	ldr	r3, [sp, #292]	; 0x124
 801e0f2:	9318      	str	r3, [sp, #96]	; 0x60
 801e0f4:	9b4a      	ldr	r3, [sp, #296]	; 0x128
 801e0f6:	9319      	str	r3, [sp, #100]	; 0x64
 801e0f8:	9b4b      	ldr	r3, [sp, #300]	; 0x12c
 801e0fa:	9320      	str	r3, [sp, #128]	; 0x80
 801e0fc:	ec5b ab10 	vmov	sl, fp, d0
 801e100:	4605      	mov	r5, r0
 801e102:	460f      	mov	r7, r1
 801e104:	4614      	mov	r4, r2
 801e106:	f000 8453 	beq.w	801e9b0 <cblas_zher2k+0x8e0>
 801e10a:	2a6f      	cmp	r2, #111	; 0x6f
 801e10c:	f000 80ae 	beq.w	801e26c <cblas_zher2k+0x19c>
 801e110:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801e112:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 801e116:	2a01      	cmp	r2, #1
 801e118:	f240 83f4 	bls.w	801e904 <cblas_zher2k+0x834>
 801e11c:	2002      	movs	r0, #2
 801e11e:	f1a4 026f 	sub.w	r2, r4, #111	; 0x6f
 801e122:	2a02      	cmp	r2, #2
 801e124:	bf88      	it	hi
 801e126:	2003      	movhi	r0, #3
 801e128:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801e12a:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801e12c:	2a00      	cmp	r2, #0
 801e12e:	bfb8      	it	lt
 801e130:	2004      	movlt	r0, #4
 801e132:	2900      	cmp	r1, #0
 801e134:	bfb8      	it	lt
 801e136:	2005      	movlt	r0, #5
 801e138:	9916      	ldr	r1, [sp, #88]	; 0x58
 801e13a:	2b01      	cmp	r3, #1
 801e13c:	bfb8      	it	lt
 801e13e:	2301      	movlt	r3, #1
 801e140:	428b      	cmp	r3, r1
 801e142:	f340 83c6 	ble.w	801e8d2 <cblas_zher2k+0x802>
 801e146:	9918      	ldr	r1, [sp, #96]	; 0x60
 801e148:	428b      	cmp	r3, r1
 801e14a:	f300 83d1 	bgt.w	801e8f0 <cblas_zher2k+0x820>
 801e14e:	2a01      	cmp	r2, #1
 801e150:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e152:	bfb8      	it	lt
 801e154:	2201      	movlt	r2, #1
 801e156:	429a      	cmp	r2, r3
 801e158:	bfcc      	ite	gt
 801e15a:	200e      	movgt	r0, #14
 801e15c:	2008      	movle	r0, #8
 801e15e:	4a47      	ldr	r2, [pc, #284]	; (801e27c <cblas_zher2k+0x1ac>)
 801e160:	4947      	ldr	r1, [pc, #284]	; (801e280 <cblas_zher2k+0x1b0>)
 801e162:	f009 fc71 	bl	8027a48 <cblas_xerbla>
    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 801e166:	4b47      	ldr	r3, [pc, #284]	; (801e284 <cblas_zher2k+0x1b4>)
 801e168:	2200      	movs	r2, #0
 801e16a:	4650      	mov	r0, sl
 801e16c:	4659      	mov	r1, fp
 801e16e:	f00a f903 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_real = CONST_REAL0(alpha);
 801e172:	ed96 7b00 	vldr	d7, [r6]
    BASE alpha_imag = CONST_IMAG0(alpha);
 801e176:	ed96 8b02 	vldr	d8, [r6, #8]
    const BASE alpha_real = CONST_REAL0(alpha);
 801e17a:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
    BASE alpha_imag = CONST_IMAG0(alpha);
 801e17e:	ed8d 8b10 	vstr	d8, [sp, #64]	; 0x40
    if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
 801e182:	b198      	cbz	r0, 801e1ac <cblas_zher2k+0xdc>
 801e184:	ec51 0b17 	vmov	r0, r1, d7
 801e188:	2200      	movs	r2, #0
 801e18a:	2300      	movs	r3, #0
 801e18c:	f00a f8f4 	bl	8028378 <__aeabi_dcmpeq>
 801e190:	b140      	cbz	r0, 801e1a4 <cblas_zher2k+0xd4>
 801e192:	ec51 0b18 	vmov	r0, r1, d8
 801e196:	2200      	movs	r2, #0
 801e198:	2300      	movs	r3, #0
 801e19a:	f00a f8ed 	bl	8028378 <__aeabi_dcmpeq>
 801e19e:	2800      	cmp	r0, #0
 801e1a0:	f040 8392 	bne.w	801e8c8 <cblas_zher2k+0x7f8>
 801e1a4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801e1a6:	2b00      	cmp	r3, #0
 801e1a8:	f000 838e 	beq.w	801e8c8 <cblas_zher2k+0x7f8>
    if (Order == CblasRowMajor) {
 801e1ac:	2d65      	cmp	r5, #101	; 0x65
 801e1ae:	f000 8405 	beq.w	801e9bc <cblas_zher2k+0x8ec>
      alpha_imag *= -1;           /* conjugate alpha */
 801e1b2:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801e1b6:	2f79      	cmp	r7, #121	; 0x79
      alpha_imag *= -1;           /* conjugate alpha */
 801e1b8:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 801e1bc:	4602      	mov	r2, r0
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801e1be:	bf0c      	ite	eq
 801e1c0:	217a      	moveq	r1, #122	; 0x7a
 801e1c2:	2179      	movne	r1, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801e1c4:	2c6f      	cmp	r4, #111	; 0x6f
      alpha_imag *= -1;           /* conjugate alpha */
 801e1c6:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801e1ca:	bf0c      	ite	eq
 801e1cc:	2371      	moveq	r3, #113	; 0x71
 801e1ce:	236f      	movne	r3, #111	; 0x6f
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801e1d0:	9100      	str	r1, [sp, #0]
      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801e1d2:	9303      	str	r3, [sp, #12]
    if (beta == 0.0) {
 801e1d4:	2200      	movs	r2, #0
 801e1d6:	2300      	movs	r3, #0
 801e1d8:	4650      	mov	r0, sl
 801e1da:	4659      	mov	r1, fp
 801e1dc:	f00a f8cc 	bl	8028378 <__aeabi_dcmpeq>
 801e1e0:	4604      	mov	r4, r0
 801e1e2:	2800      	cmp	r0, #0
 801e1e4:	f000 8395 	beq.w	801e912 <cblas_zher2k+0x842>
      if (uplo == CblasUpper) {
 801e1e8:	9b00      	ldr	r3, [sp, #0]
 801e1ea:	2b79      	cmp	r3, #121	; 0x79
 801e1ec:	d04e      	beq.n	801e28c <cblas_zher2k+0x1bc>
        for (i = 0; i < N; i++) {
 801e1ee:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e1f0:	2b00      	cmp	r3, #0
 801e1f2:	dd1a      	ble.n	801e22a <cblas_zher2k+0x15a>
 801e1f4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e1f6:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801e1f8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 801e1fa:	f8dd c064 	ldr.w	ip, [sp, #100]	; 0x64
 801e1fe:	1c5c      	adds	r4, r3, #1
 801e200:	2100      	movs	r1, #0
            REAL(C, ldc * i + j) = 0.0;
 801e202:	2600      	movs	r6, #0
 801e204:	2700      	movs	r7, #0
 801e206:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 801e208:	4608      	mov	r0, r1
 801e20a:	3210      	adds	r2, #16
 801e20c:	469e      	mov	lr, r3
 801e20e:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
            REAL(C, ldc * i + j) = 0.0;
 801e212:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 801e216:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = 0; j <= i; j++) {
 801e21a:	3310      	adds	r3, #16
 801e21c:	429a      	cmp	r2, r3
 801e21e:	d1f8      	bne.n	801e212 <cblas_zher2k+0x142>
        for (i = 0; i < N; i++) {
 801e220:	3001      	adds	r0, #1
 801e222:	4285      	cmp	r5, r0
 801e224:	4471      	add	r1, lr
 801e226:	4422      	add	r2, r4
 801e228:	d1f1      	bne.n	801e20e <cblas_zher2k+0x13e>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801e22a:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 801e22e:	2200      	movs	r2, #0
 801e230:	2300      	movs	r3, #0
 801e232:	f00a f8a1 	bl	8028378 <__aeabi_dcmpeq>
 801e236:	b158      	cbz	r0, 801e250 <cblas_zher2k+0x180>
 801e238:	e9dd 0110 	ldrd	r0, r1, [sp, #64]	; 0x40
 801e23c:	2200      	movs	r2, #0
 801e23e:	2300      	movs	r3, #0
 801e240:	f00a f89a 	bl	8028378 <__aeabi_dcmpeq>
 801e244:	2800      	cmp	r0, #0
 801e246:	f040 833f 	bne.w	801e8c8 <cblas_zher2k+0x7f8>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 801e24a:	9b00      	ldr	r3, [sp, #0]
 801e24c:	2b79      	cmp	r3, #121	; 0x79
 801e24e:	d03e      	beq.n	801e2ce <cblas_zher2k+0x1fe>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801e250:	9b00      	ldr	r3, [sp, #0]
 801e252:	2b7a      	cmp	r3, #122	; 0x7a
 801e254:	f000 81b0 	beq.w	801e5b8 <cblas_zher2k+0x4e8>
      BLAS_ERROR("unrecognized operation");
 801e258:	4a0b      	ldr	r2, [pc, #44]	; (801e288 <cblas_zher2k+0x1b8>)
 801e25a:	4909      	ldr	r1, [pc, #36]	; (801e280 <cblas_zher2k+0x1b0>)
 801e25c:	2000      	movs	r0, #0
#define BASE double
#include "source_her2k.h"
#undef BASE
}
 801e25e:	b02b      	add	sp, #172	; 0xac
 801e260:	ecbd 8b10 	vpop	{d8-d15}
 801e264:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e268:	f009 bbee 	b.w	8027a48 <cblas_xerbla>
 801e26c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801e26e:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 801e272:	2a01      	cmp	r2, #1
 801e274:	f240 8346 	bls.w	801e904 <cblas_zher2k+0x834>
 801e278:	2002      	movs	r0, #2
 801e27a:	e755      	b.n	801e128 <cblas_zher2k+0x58>
 801e27c:	08030378 	.word	0x08030378
 801e280:	08030730 	.word	0x08030730
 801e284:	3ff00000 	.word	0x3ff00000
 801e288:	080305a8 	.word	0x080305a8
        for (i = 0; i < N; i++) {
 801e28c:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 801e28e:	2d00      	cmp	r5, #0
 801e290:	dd15      	ble.n	801e2be <cblas_zher2k+0x1ee>
 801e292:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e294:	9819      	ldr	r0, [sp, #100]	; 0x64
 801e296:	1c5c      	adds	r4, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 801e298:	2600      	movs	r6, #0
 801e29a:	2700      	movs	r7, #0
 801e29c:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 801e29e:	2100      	movs	r1, #0
 801e2a0:	4603      	mov	r3, r0
 801e2a2:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 801e2a4:	3201      	adds	r2, #1
 801e2a6:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 801e2a8:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 801e2ac:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = i; j < N; j++) {
 801e2b0:	f103 0310 	add.w	r3, r3, #16
 801e2b4:	dcf6      	bgt.n	801e2a4 <cblas_zher2k+0x1d4>
        for (i = 0; i < N; i++) {
 801e2b6:	3101      	adds	r1, #1
 801e2b8:	428d      	cmp	r5, r1
 801e2ba:	4420      	add	r0, r4
 801e2bc:	d1f0      	bne.n	801e2a0 <cblas_zher2k+0x1d0>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801e2be:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 801e2c2:	2200      	movs	r2, #0
 801e2c4:	2300      	movs	r3, #0
 801e2c6:	f00a f857 	bl	8028378 <__aeabi_dcmpeq>
 801e2ca:	2800      	cmp	r0, #0
 801e2cc:	d1b4      	bne.n	801e238 <cblas_zher2k+0x168>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 801e2ce:	9b03      	ldr	r3, [sp, #12]
 801e2d0:	2b6f      	cmp	r3, #111	; 0x6f
 801e2d2:	f000 839b 	beq.w	801ea0c <cblas_zher2k+0x93c>
    } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 801e2d6:	9b03      	ldr	r3, [sp, #12]
 801e2d8:	2b71      	cmp	r3, #113	; 0x71
 801e2da:	d1bd      	bne.n	801e258 <cblas_zher2k+0x188>
      for (k = 0; k < K; k++) {
 801e2dc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801e2de:	2b00      	cmp	r3, #0
 801e2e0:	f340 82f2 	ble.w	801e8c8 <cblas_zher2k+0x7f8>
 801e2e4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801e2e6:	9816      	ldr	r0, [sp, #88]	; 0x58
 801e2e8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
 801e2ea:	f1a3 0210 	sub.w	r2, r3, #16
 801e2ee:	2100      	movs	r1, #0
 801e2f0:	1c43      	adds	r3, r0, #1
 801e2f2:	011b      	lsls	r3, r3, #4
 801e2f4:	e9cd 111c 	strd	r1, r1, [sp, #112]	; 0x70
            IMAG(C, i * lda + i) = 0.0;
 801e2f8:	ed9f 8bad 	vldr	d8, [pc, #692]	; 801e5b0 <cblas_zher2k+0x4e0>
 801e2fc:	eb02 1204 	add.w	r2, r2, r4, lsl #4
 801e300:	930c      	str	r3, [sp, #48]	; 0x30
 801e302:	0103      	lsls	r3, r0, #4
      for (k = 0; k < K; k++) {
 801e304:	9114      	str	r1, [sp, #80]	; 0x50
 801e306:	920a      	str	r2, [sp, #40]	; 0x28
 801e308:	931e      	str	r3, [sp, #120]	; 0x78
        for (i = 0; i < N; i++) {
 801e30a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e30c:	2b00      	cmp	r3, #0
 801e30e:	f340 8588 	ble.w	801ee22 <cblas_zher2k+0xd52>
 801e312:	e9dd 321b 	ldrd	r3, r2, [sp, #108]	; 0x6c
 801e316:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e31a:	9312      	str	r3, [sp, #72]	; 0x48
 801e31c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801e31e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801e320:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e324:	9303      	str	r3, [sp, #12]
 801e326:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801e328:	3308      	adds	r3, #8
 801e32a:	9306      	str	r3, [sp, #24]
 801e32c:	2300      	movs	r3, #0
 801e32e:	9308      	str	r3, [sp, #32]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801e330:	9c12      	ldr	r4, [sp, #72]	; 0x48
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e332:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801e336:	e9d4 6700 	ldrd	r6, r7, [r4]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e33a:	ec51 0b19 	vmov	r0, r1, d9
 801e33e:	4632      	mov	r2, r6
 801e340:	463b      	mov	r3, r7
 801e342:	f009 fdb1 	bl	8027ea8 <__aeabi_dmul>
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801e346:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e34a:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801e34e:	4622      	mov	r2, r4
 801e350:	462b      	mov	r3, r5
 801e352:	4680      	mov	r8, r0
 801e354:	4689      	mov	r9, r1
 801e356:	4650      	mov	r0, sl
 801e358:	4659      	mov	r1, fp
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e35a:	9404      	str	r4, [sp, #16]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e35c:	f009 fda4 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e360:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e364:	4602      	mov	r2, r0
 801e366:	460b      	mov	r3, r1
 801e368:	4640      	mov	r0, r8
 801e36a:	4649      	mov	r1, r9
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e36c:	9405      	str	r4, [sp, #20]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e36e:	f009 fbe5 	bl	8027b3c <__adddf3>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e372:	ec53 2b19 	vmov	r2, r3, d9
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e376:	4604      	mov	r4, r0
 801e378:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e37a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 801e37e:	f009 fd93 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e382:	ec45 4b1b 	vmov	d11, r4, r5
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e386:	4632      	mov	r2, r6
 801e388:	463b      	mov	r3, r7
 801e38a:	4604      	mov	r4, r0
 801e38c:	460d      	mov	r5, r1
 801e38e:	4650      	mov	r0, sl
 801e390:	4659      	mov	r1, fp
 801e392:	f009 fd89 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e396:	eeb0 fa4b 	vmov.f32	s30, s22
 801e39a:	eef0 fa6b 	vmov.f32	s31, s23
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801e39e:	9e03      	ldr	r6, [sp, #12]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e3a0:	4602      	mov	r2, r0
 801e3a2:	460b      	mov	r3, r1
 801e3a4:	4620      	mov	r0, r4
 801e3a6:	4629      	mov	r1, r5
 801e3a8:	f009 fbc8 	bl	8027b3c <__adddf3>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801e3ac:	e9d6 8900 	ldrd	r8, r9, [r6]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e3b0:	4604      	mov	r4, r0
 801e3b2:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e3b4:	4642      	mov	r2, r8
 801e3b6:	464b      	mov	r3, r9
 801e3b8:	ec51 0b19 	vmov	r0, r1, d9
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801e3bc:	9603      	str	r6, [sp, #12]
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e3be:	f009 fd73 	bl	8027ea8 <__aeabi_dmul>
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801e3c2:	e9d6 6702 	ldrd	r6, r7, [r6, #8]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e3c6:	ec45 4b1a 	vmov	d10, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e3ca:	4632      	mov	r2, r6
 801e3cc:	4604      	mov	r4, r0
 801e3ce:	460d      	mov	r5, r1
 801e3d0:	463b      	mov	r3, r7
 801e3d2:	4650      	mov	r0, sl
 801e3d4:	4659      	mov	r1, fp
 801e3d6:	f009 fd67 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e3da:	eeb0 ea4a 	vmov.f32	s28, s20
 801e3de:	eef0 ea6a 	vmov.f32	s29, s21
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e3e2:	4602      	mov	r2, r0
 801e3e4:	460b      	mov	r3, r1
 801e3e6:	4620      	mov	r0, r4
 801e3e8:	4629      	mov	r1, r5
 801e3ea:	f009 fba5 	bl	8027b38 <__aeabi_dsub>
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e3ee:	4632      	mov	r2, r6
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e3f0:	4604      	mov	r4, r0
 801e3f2:	460d      	mov	r5, r1
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e3f4:	463b      	mov	r3, r7
 801e3f6:	ec51 0b19 	vmov	r0, r1, d9
 801e3fa:	f009 fd55 	bl	8027ea8 <__aeabi_dmul>
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e3fe:	ec45 4b1d 	vmov	d13, r4, r5
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e402:	4642      	mov	r2, r8
 801e404:	4604      	mov	r4, r0
 801e406:	460d      	mov	r5, r1
 801e408:	464b      	mov	r3, r9
 801e40a:	4650      	mov	r0, sl
 801e40c:	4659      	mov	r1, fp
 801e40e:	f009 fd4b 	bl	8027ea8 <__aeabi_dmul>
 801e412:	4602      	mov	r2, r0
 801e414:	460b      	mov	r3, r1
 801e416:	4620      	mov	r0, r4
 801e418:	4629      	mov	r1, r5
 801e41a:	f009 fb8f 	bl	8027b3c <__adddf3>
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e41e:	ec53 2b1b 	vmov	r2, r3, d11
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e422:	4604      	mov	r4, r0
 801e424:	460d      	mov	r5, r1
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e426:	4640      	mov	r0, r8
 801e428:	4649      	mov	r1, r9
 801e42a:	f009 fd3d 	bl	8027ea8 <__aeabi_dmul>
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e42e:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e432:	ec53 2b1a 	vmov	r2, r3, d10
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e436:	ee0c 4a10 	vmov	s24, r4
 801e43a:	ee0c 5a90 	vmov	s25, r5
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e43e:	4604      	mov	r4, r0
 801e440:	460d      	mov	r5, r1
 801e442:	4630      	mov	r0, r6
 801e444:	4639      	mov	r1, r7
 801e446:	f009 fd2f 	bl	8027ea8 <__aeabi_dmul>
 801e44a:	4602      	mov	r2, r0
 801e44c:	460b      	mov	r3, r1
 801e44e:	4620      	mov	r0, r4
 801e450:	4629      	mov	r1, r5
 801e452:	f009 fb71 	bl	8027b38 <__aeabi_dsub>
 801e456:	4602      	mov	r2, r0
 801e458:	460b      	mov	r3, r1
 801e45a:	f009 fb6f 	bl	8027b3c <__adddf3>
 801e45e:	9c06      	ldr	r4, [sp, #24]
 801e460:	4602      	mov	r2, r0
 801e462:	460b      	mov	r3, r1
 801e464:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801e468:	f009 fb68 	bl	8027b3c <__adddf3>
          for (j = i + 1; j < N; j++) {
 801e46c:	9d08      	ldr	r5, [sp, #32]
 801e46e:	3501      	adds	r5, #1
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e470:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + i) = 0.0;
 801e474:	ed84 8b00 	vstr	d8, [r4]
          for (j = i + 1; j < N; j++) {
 801e478:	9508      	str	r5, [sp, #32]
 801e47a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 801e47c:	42aa      	cmp	r2, r5
 801e47e:	f000 84d0 	beq.w	801ee22 <cblas_zher2k+0xd52>
 801e482:	9e03      	ldr	r6, [sp, #12]
 801e484:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
 801e488:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 801e48a:	f1a4 0a08 	sub.w	sl, r4, #8
 801e48e:	4634      	mov	r4, r6
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801e490:	e9d4 8904 	ldrd	r8, r9, [r4, #16]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801e494:	ed94 7b06 	vldr	d7, [r4, #24]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e498:	4642      	mov	r2, r8
 801e49a:	464b      	mov	r3, r9
 801e49c:	ec51 0b1f 	vmov	r0, r1, d15
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801e4a0:	eeb0 9a47 	vmov.f32	s18, s14
 801e4a4:	eef0 9a67 	vmov.f32	s19, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e4a8:	f009 fcfe 	bl	8027ea8 <__aeabi_dmul>
 801e4ac:	ec53 2b19 	vmov	r2, r3, d9
 801e4b0:	4606      	mov	r6, r0
 801e4b2:	460f      	mov	r7, r1
 801e4b4:	ec51 0b1e 	vmov	r0, r1, d14
 801e4b8:	f009 fcf6 	bl	8027ea8 <__aeabi_dmul>
 801e4bc:	4602      	mov	r2, r0
 801e4be:	460b      	mov	r3, r1
 801e4c0:	4630      	mov	r0, r6
 801e4c2:	4639      	mov	r1, r7
 801e4c4:	f009 fb38 	bl	8027b38 <__aeabi_dsub>
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 801e4c8:	ed9b ab04 	vldr	d10, [fp, #16]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e4cc:	4606      	mov	r6, r0
 801e4ce:	460f      	mov	r7, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801e4d0:	ec53 2b1a 	vmov	r2, r3, d10
 801e4d4:	ec51 0b1d 	vmov	r0, r1, d13
 801e4d8:	f009 fce6 	bl	8027ea8 <__aeabi_dmul>
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801e4dc:	ed9b bb06 	vldr	d11, [fp, #24]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801e4e0:	e9cd 0100 	strd	r0, r1, [sp]
 801e4e4:	ec53 2b1b 	vmov	r2, r3, d11
 801e4e8:	ec51 0b1c 	vmov	r0, r1, d12
 801e4ec:	f009 fcdc 	bl	8027ea8 <__aeabi_dmul>
 801e4f0:	4602      	mov	r2, r0
 801e4f2:	460b      	mov	r3, r1
 801e4f4:	e9dd 0100 	ldrd	r0, r1, [sp]
 801e4f8:	f009 fb1e 	bl	8027b38 <__aeabi_dsub>
 801e4fc:	4602      	mov	r2, r0
 801e4fe:	460b      	mov	r3, r1
 801e500:	4630      	mov	r0, r6
 801e502:	4639      	mov	r1, r7
 801e504:	f009 fb1a 	bl	8027b3c <__adddf3>
 801e508:	4602      	mov	r2, r0
 801e50a:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e50c:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 801e510:	f009 fb14 	bl	8027b3c <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e514:	ec53 2b19 	vmov	r2, r3, d9
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e518:	e9ca 0104 	strd	r0, r1, [sl, #16]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e51c:	ec51 0b1f 	vmov	r0, r1, d15
 801e520:	f009 fcc2 	bl	8027ea8 <__aeabi_dmul>
 801e524:	4642      	mov	r2, r8
 801e526:	464b      	mov	r3, r9
 801e528:	4606      	mov	r6, r0
 801e52a:	460f      	mov	r7, r1
 801e52c:	ec51 0b1e 	vmov	r0, r1, d14
 801e530:	f009 fcba 	bl	8027ea8 <__aeabi_dmul>
 801e534:	4602      	mov	r2, r0
 801e536:	460b      	mov	r3, r1
 801e538:	4630      	mov	r0, r6
 801e53a:	4639      	mov	r1, r7
 801e53c:	f009 fafe 	bl	8027b3c <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801e540:	ec53 2b1b 	vmov	r2, r3, d11
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e544:	4680      	mov	r8, r0
 801e546:	4689      	mov	r9, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801e548:	ec51 0b1d 	vmov	r0, r1, d13
 801e54c:	f009 fcac 	bl	8027ea8 <__aeabi_dmul>
 801e550:	ec53 2b1a 	vmov	r2, r3, d10
 801e554:	4606      	mov	r6, r0
 801e556:	460f      	mov	r7, r1
 801e558:	ec51 0b1c 	vmov	r0, r1, d12
 801e55c:	f009 fca4 	bl	8027ea8 <__aeabi_dmul>
 801e560:	4602      	mov	r2, r0
 801e562:	460b      	mov	r3, r1
 801e564:	4630      	mov	r0, r6
 801e566:	4639      	mov	r1, r7
 801e568:	f009 fae8 	bl	8027b3c <__adddf3>
 801e56c:	4602      	mov	r2, r0
 801e56e:	460b      	mov	r3, r1
 801e570:	4640      	mov	r0, r8
 801e572:	4649      	mov	r1, r9
 801e574:	f009 fae2 	bl	8027b3c <__adddf3>
 801e578:	4602      	mov	r2, r0
 801e57a:	460b      	mov	r3, r1
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e57c:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 801e580:	f009 fadc 	bl	8027b3c <__adddf3>
 801e584:	f10b 0b10 	add.w	fp, fp, #16
          for (j = i + 1; j < N; j++) {
 801e588:	455d      	cmp	r5, fp
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e58a:	e9ca 0106 	strd	r0, r1, [sl, #24]
          for (j = i + 1; j < N; j++) {
 801e58e:	f104 0410 	add.w	r4, r4, #16
 801e592:	f10a 0a10 	add.w	sl, sl, #16
 801e596:	f47f af7b 	bne.w	801e490 <cblas_zher2k+0x3c0>
 801e59a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801e59c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801e59e:	3310      	adds	r3, #16
 801e5a0:	9312      	str	r3, [sp, #72]	; 0x48
 801e5a2:	9b03      	ldr	r3, [sp, #12]
 801e5a4:	3310      	adds	r3, #16
 801e5a6:	9303      	str	r3, [sp, #12]
 801e5a8:	9b06      	ldr	r3, [sp, #24]
 801e5aa:	4413      	add	r3, r2
 801e5ac:	9306      	str	r3, [sp, #24]
 801e5ae:	e6bf      	b.n	801e330 <cblas_zher2k+0x260>
	...
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801e5b8:	9b03      	ldr	r3, [sp, #12]
 801e5ba:	2b6f      	cmp	r3, #111	; 0x6f
 801e5bc:	f000 8484 	beq.w	801eec8 <cblas_zher2k+0xdf8>
    } else if (uplo == CblasLower && trans == CblasConjTrans) {
 801e5c0:	9b03      	ldr	r3, [sp, #12]
 801e5c2:	2b71      	cmp	r3, #113	; 0x71
 801e5c4:	f47f ae48 	bne.w	801e258 <cblas_zher2k+0x188>
      for (k = 0; k < K; k++) {
 801e5c8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801e5ca:	2b00      	cmp	r3, #0
 801e5cc:	f340 817c 	ble.w	801e8c8 <cblas_zher2k+0x7f8>
 801e5d0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801e5d2:	011b      	lsls	r3, r3, #4
 801e5d4:	9321      	str	r3, [sp, #132]	; 0x84
 801e5d6:	3310      	adds	r3, #16
 801e5d8:	931c      	str	r3, [sp, #112]	; 0x70
 801e5da:	9b19      	ldr	r3, [sp, #100]	; 0x64
            IMAG(C, i * lda + i) = 0.0;
 801e5dc:	ed1f 8b0c 	vldr	d8, [pc, #-48]	; 801e5b0 <cblas_zher2k+0x4e0>
      for (k = 0; k < K; k++) {
 801e5e0:	2200      	movs	r2, #0
 801e5e2:	3308      	adds	r3, #8
 801e5e4:	921f      	str	r2, [sp, #124]	; 0x7c
 801e5e6:	9220      	str	r2, [sp, #128]	; 0x80
 801e5e8:	931d      	str	r3, [sp, #116]	; 0x74
        for (i = 0; i < N; i++) {
 801e5ea:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e5ec:	2b00      	cmp	r3, #0
 801e5ee:	f340 815c 	ble.w	801e8aa <cblas_zher2k+0x7da>
 801e5f2:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801e5f4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801e5f6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801e5fa:	931e      	str	r3, [sp, #120]	; 0x78
 801e5fc:	9304      	str	r3, [sp, #16]
 801e5fe:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801e600:	9308      	str	r3, [sp, #32]
 801e602:	2200      	movs	r2, #0
 801e604:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801e606:	9206      	str	r2, [sp, #24]
 801e608:	9212      	str	r2, [sp, #72]	; 0x48
 801e60a:	9303      	str	r3, [sp, #12]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801e60c:	9c03      	ldr	r4, [sp, #12]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e60e:	ed9d ab0e 	vldr	d10, [sp, #56]	; 0x38
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 801e612:	e9d4 6700 	ldrd	r6, r7, [r4]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e616:	ec51 0b1a 	vmov	r0, r1, d10
 801e61a:	4632      	mov	r2, r6
 801e61c:	463b      	mov	r3, r7
 801e61e:	f009 fc43 	bl	8027ea8 <__aeabi_dmul>
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 801e622:	e9d4 4502 	ldrd	r4, r5, [r4, #8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e626:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801e62a:	4622      	mov	r2, r4
 801e62c:	462b      	mov	r3, r5
 801e62e:	4680      	mov	r8, r0
 801e630:	4689      	mov	r9, r1
 801e632:	4650      	mov	r0, sl
 801e634:	4659      	mov	r1, fp
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e636:	9414      	str	r4, [sp, #80]	; 0x50
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e638:	f009 fc36 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e63c:	f105 4400 	add.w	r4, r5, #2147483648	; 0x80000000
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e640:	4602      	mov	r2, r0
 801e642:	460b      	mov	r3, r1
 801e644:	4640      	mov	r0, r8
 801e646:	4649      	mov	r1, r9
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e648:	9415      	str	r4, [sp, #84]	; 0x54
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e64a:	f009 fa77 	bl	8027b3c <__adddf3>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e64e:	ec53 2b1a 	vmov	r2, r3, d10
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e652:	4604      	mov	r4, r0
 801e654:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e656:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
 801e65a:	f009 fc25 	bl	8027ea8 <__aeabi_dmul>
 801e65e:	4632      	mov	r2, r6
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801e660:	9e04      	ldr	r6, [sp, #16]
 801e662:	ed96 9b00 	vldr	d9, [r6]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
 801e666:	ec45 4b1f 	vmov	d15, r4, r5
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e66a:	463b      	mov	r3, r7
 801e66c:	4604      	mov	r4, r0
 801e66e:	460d      	mov	r5, r1
 801e670:	4650      	mov	r0, sl
 801e672:	4659      	mov	r1, fp
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 801e674:	ed8d 9b0a 	vstr	d9, [sp, #40]	; 0x28
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e678:	f009 fc16 	bl	8027ea8 <__aeabi_dmul>
 801e67c:	4602      	mov	r2, r0
 801e67e:	460b      	mov	r3, r1
 801e680:	4620      	mov	r0, r4
 801e682:	4629      	mov	r1, r5
 801e684:	f009 fa5a 	bl	8027b3c <__adddf3>
 801e688:	46d0      	mov	r8, sl
 801e68a:	46d9      	mov	r9, fp
 801e68c:	4604      	mov	r4, r0
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e68e:	ec5b ab1a 	vmov	sl, fp, d10
 801e692:	ee1a 0a10 	vmov	r0, s20
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801e696:	ed96 ab02 	vldr	d10, [r6, #8]
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e69a:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e69c:	ec53 2b19 	vmov	r2, r3, d9
 801e6a0:	4659      	mov	r1, fp
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 801e6a2:	ed8d ab0c 	vstr	d10, [sp, #48]	; 0x30
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e6a6:	f009 fbff 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
 801e6aa:	ec45 4b1d 	vmov	d13, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e6ae:	ec53 2b1a 	vmov	r2, r3, d10
 801e6b2:	4604      	mov	r4, r0
 801e6b4:	460d      	mov	r5, r1
 801e6b6:	4640      	mov	r0, r8
 801e6b8:	4649      	mov	r1, r9
 801e6ba:	f009 fbf5 	bl	8027ea8 <__aeabi_dmul>
 801e6be:	4602      	mov	r2, r0
 801e6c0:	460b      	mov	r3, r1
 801e6c2:	4620      	mov	r0, r4
 801e6c4:	4629      	mov	r1, r5
 801e6c6:	f009 fa37 	bl	8027b38 <__aeabi_dsub>
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e6ca:	ec53 2b1a 	vmov	r2, r3, d10
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e6ce:	4604      	mov	r4, r0
 801e6d0:	460d      	mov	r5, r1
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e6d2:	4650      	mov	r0, sl
 801e6d4:	4659      	mov	r1, fp
 801e6d6:	f009 fbe7 	bl	8027ea8 <__aeabi_dmul>
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 801e6da:	ec45 4b1c 	vmov	d12, r4, r5
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e6de:	ec53 2b19 	vmov	r2, r3, d9
 801e6e2:	4604      	mov	r4, r0
 801e6e4:	460d      	mov	r5, r1
 801e6e6:	4640      	mov	r0, r8
 801e6e8:	4649      	mov	r1, r9
 801e6ea:	f009 fbdd 	bl	8027ea8 <__aeabi_dmul>
 801e6ee:	460b      	mov	r3, r1
 801e6f0:	4602      	mov	r2, r0
 801e6f2:	4629      	mov	r1, r5
 801e6f4:	4620      	mov	r0, r4
 801e6f6:	f009 fa21 	bl	8027b3c <__adddf3>
 801e6fa:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 801e6fe:	ee0b 3a90 	vmov	s23, r3
          for (j = 0; j < i; j++) {
 801e702:	9b12      	ldr	r3, [sp, #72]	; 0x48
          BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
 801e704:	ee0b 0a10 	vmov	s22, r0
          for (j = 0; j < i; j++) {
 801e708:	2b00      	cmp	r3, #0
 801e70a:	f000 8097 	beq.w	801e83c <cblas_zher2k+0x76c>
 801e70e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801e710:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801e712:	9d1e      	ldr	r5, [sp, #120]	; 0x78
 801e714:	f8dd a06c 	ldr.w	sl, [sp, #108]	; 0x6c
 801e718:	4619      	mov	r1, r3
 801e71a:	9b06      	ldr	r3, [sp, #24]
 801e71c:	eb01 1b03 	add.w	fp, r1, r3, lsl #4
 801e720:	eb02 1403 	add.w	r4, r2, r3, lsl #4
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801e724:	ed95 7b00 	vldr	d7, [r5]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801e728:	ed95 6b02 	vldr	d6, [r5, #8]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 801e72c:	eeb0 ea47 	vmov.f32	s28, s14
 801e730:	eef0 ea67 	vmov.f32	s29, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e734:	ec53 2b17 	vmov	r2, r3, d7
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 801e738:	eeb0 9a46 	vmov.f32	s18, s12
 801e73c:	eef0 9a66 	vmov.f32	s19, s13
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e740:	ec51 0b1f 	vmov	r0, r1, d15
 801e744:	f009 fbb0 	bl	8027ea8 <__aeabi_dmul>
 801e748:	ec53 2b19 	vmov	r2, r3, d9
 801e74c:	4606      	mov	r6, r0
 801e74e:	460f      	mov	r7, r1
 801e750:	ec51 0b1d 	vmov	r0, r1, d13
 801e754:	f009 fba8 	bl	8027ea8 <__aeabi_dmul>
 801e758:	4602      	mov	r2, r0
 801e75a:	460b      	mov	r3, r1
 801e75c:	4630      	mov	r0, r6
 801e75e:	4639      	mov	r1, r7
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 801e760:	e9da 8900 	ldrd	r8, r9, [sl]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e764:	f009 f9e8 	bl	8027b38 <__aeabi_dsub>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801e768:	4642      	mov	r2, r8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e76a:	4606      	mov	r6, r0
 801e76c:	460f      	mov	r7, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801e76e:	464b      	mov	r3, r9
 801e770:	ec51 0b1c 	vmov	r0, r1, d12
 801e774:	f009 fb98 	bl	8027ea8 <__aeabi_dmul>
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801e778:	ed9a ab02 	vldr	d10, [sl, #8]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 801e77c:	e9cd 0100 	strd	r0, r1, [sp]
 801e780:	ec53 2b1a 	vmov	r2, r3, d10
 801e784:	ec51 0b1b 	vmov	r0, r1, d11
 801e788:	f009 fb8e 	bl	8027ea8 <__aeabi_dmul>
 801e78c:	4602      	mov	r2, r0
 801e78e:	460b      	mov	r3, r1
 801e790:	e9dd 0100 	ldrd	r0, r1, [sp]
 801e794:	f009 f9d0 	bl	8027b38 <__aeabi_dsub>
 801e798:	4602      	mov	r2, r0
 801e79a:	460b      	mov	r3, r1
 801e79c:	4630      	mov	r0, r6
 801e79e:	4639      	mov	r1, r7
 801e7a0:	f009 f9cc 	bl	8027b3c <__adddf3>
 801e7a4:	4602      	mov	r2, r0
 801e7a6:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e7a8:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801e7ac:	f009 f9c6 	bl	8027b3c <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e7b0:	ec53 2b19 	vmov	r2, r3, d9
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 801e7b4:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e7b8:	ec51 0b1f 	vmov	r0, r1, d15
 801e7bc:	f009 fb74 	bl	8027ea8 <__aeabi_dmul>
 801e7c0:	ec53 2b1e 	vmov	r2, r3, d14
 801e7c4:	4606      	mov	r6, r0
 801e7c6:	460f      	mov	r7, r1
 801e7c8:	ec51 0b1d 	vmov	r0, r1, d13
 801e7cc:	f009 fb6c 	bl	8027ea8 <__aeabi_dmul>
 801e7d0:	4602      	mov	r2, r0
 801e7d2:	460b      	mov	r3, r1
 801e7d4:	4630      	mov	r0, r6
 801e7d6:	4639      	mov	r1, r7
 801e7d8:	f009 f9b0 	bl	8027b3c <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801e7dc:	ec53 2b1a 	vmov	r2, r3, d10
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e7e0:	4606      	mov	r6, r0
 801e7e2:	460f      	mov	r7, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 801e7e4:	ec51 0b1c 	vmov	r0, r1, d12
 801e7e8:	f009 fb5e 	bl	8027ea8 <__aeabi_dmul>
 801e7ec:	4642      	mov	r2, r8
 801e7ee:	464b      	mov	r3, r9
 801e7f0:	4680      	mov	r8, r0
 801e7f2:	4689      	mov	r9, r1
 801e7f4:	ec51 0b1b 	vmov	r0, r1, d11
 801e7f8:	f009 fb56 	bl	8027ea8 <__aeabi_dmul>
 801e7fc:	4602      	mov	r2, r0
 801e7fe:	460b      	mov	r3, r1
 801e800:	4640      	mov	r0, r8
 801e802:	4649      	mov	r1, r9
 801e804:	f009 f99a 	bl	8027b3c <__adddf3>
 801e808:	4602      	mov	r2, r0
 801e80a:	460b      	mov	r3, r1
 801e80c:	4630      	mov	r0, r6
 801e80e:	4639      	mov	r1, r7
 801e810:	f009 f994 	bl	8027b3c <__adddf3>
 801e814:	460b      	mov	r3, r1
 801e816:	4602      	mov	r2, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e818:	e9db 0102 	ldrd	r0, r1, [fp, #8]
 801e81c:	f009 f98e 	bl	8027b3c <__adddf3>
          for (j = 0; j < i; j++) {
 801e820:	9b03      	ldr	r3, [sp, #12]
 801e822:	f10a 0a10 	add.w	sl, sl, #16
 801e826:	4553      	cmp	r3, sl
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 801e828:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j < i; j++) {
 801e82c:	f105 0510 	add.w	r5, r5, #16
 801e830:	f104 0410 	add.w	r4, r4, #16
 801e834:	f10b 0b10 	add.w	fp, fp, #16
 801e838:	f47f af74 	bne.w	801e724 <cblas_zher2k+0x654>
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e83c:	ec53 2b1f 	vmov	r2, r3, d15
 801e840:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801e844:	f009 fb30 	bl	8027ea8 <__aeabi_dmul>
 801e848:	ec53 2b1d 	vmov	r2, r3, d13
 801e84c:	4604      	mov	r4, r0
 801e84e:	460d      	mov	r5, r1
 801e850:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801e854:	f009 fb28 	bl	8027ea8 <__aeabi_dmul>
 801e858:	4602      	mov	r2, r0
 801e85a:	460b      	mov	r3, r1
 801e85c:	4620      	mov	r0, r4
 801e85e:	4629      	mov	r1, r5
 801e860:	f009 f96a 	bl	8027b38 <__aeabi_dsub>
 801e864:	4602      	mov	r2, r0
 801e866:	460b      	mov	r3, r1
 801e868:	f009 f968 	bl	8027b3c <__adddf3>
 801e86c:	9c08      	ldr	r4, [sp, #32]
 801e86e:	4602      	mov	r2, r0
 801e870:	460b      	mov	r3, r1
 801e872:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801e876:	f009 f961 	bl	8027b3c <__adddf3>
 801e87a:	9b03      	ldr	r3, [sp, #12]
 801e87c:	9d16      	ldr	r5, [sp, #88]	; 0x58
        for (i = 0; i < N; i++) {
 801e87e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801e880:	3310      	adds	r3, #16
 801e882:	9303      	str	r3, [sp, #12]
 801e884:	9b04      	ldr	r3, [sp, #16]
 801e886:	3310      	adds	r3, #16
 801e888:	9304      	str	r3, [sp, #16]
 801e88a:	9b06      	ldr	r3, [sp, #24]
 801e88c:	442b      	add	r3, r5
 801e88e:	9306      	str	r3, [sp, #24]
 801e890:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801e892:	18e3      	adds	r3, r4, r3
 801e894:	9308      	str	r3, [sp, #32]
 801e896:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e898:	3201      	adds	r2, #1
 801e89a:	4293      	cmp	r3, r2
            REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
 801e89c:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + i) = 0.0;
 801e8a0:	ed84 8b00 	vstr	d8, [r4]
        for (i = 0; i < N; i++) {
 801e8a4:	9212      	str	r2, [sp, #72]	; 0x48
 801e8a6:	f47f aeb1 	bne.w	801e60c <cblas_zher2k+0x53c>
      for (k = 0; k < K; k++) {
 801e8aa:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 801e8ac:	9921      	ldr	r1, [sp, #132]	; 0x84
 801e8ae:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e8b0:	440a      	add	r2, r1
 801e8b2:	921b      	str	r2, [sp, #108]	; 0x6c
 801e8b4:	9918      	ldr	r1, [sp, #96]	; 0x60
 801e8b6:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801e8b8:	440a      	add	r2, r1
 801e8ba:	921f      	str	r2, [sp, #124]	; 0x7c
 801e8bc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801e8be:	3301      	adds	r3, #1
 801e8c0:	429a      	cmp	r2, r3
 801e8c2:	9320      	str	r3, [sp, #128]	; 0x80
 801e8c4:	f47f ae91 	bne.w	801e5ea <cblas_zher2k+0x51a>
 801e8c8:	b02b      	add	sp, #172	; 0xac
 801e8ca:	ecbd 8b10 	vpop	{d8-d15}
 801e8ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801e8d2:	9a18      	ldr	r2, [sp, #96]	; 0x60
 801e8d4:	4293      	cmp	r3, r2
 801e8d6:	dc0b      	bgt.n	801e8f0 <cblas_zher2k+0x820>
 801e8d8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e8da:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801e8dc:	2b01      	cmp	r3, #1
 801e8de:	bfb8      	it	lt
 801e8e0:	2301      	movlt	r3, #1
 801e8e2:	4293      	cmp	r3, r2
 801e8e4:	f300 8087 	bgt.w	801e9f6 <cblas_zher2k+0x926>
 801e8e8:	2800      	cmp	r0, #0
 801e8ea:	f43f ac3c 	beq.w	801e166 <cblas_zher2k+0x96>
 801e8ee:	e436      	b.n	801e15e <cblas_zher2k+0x8e>
 801e8f0:	9813      	ldr	r0, [sp, #76]	; 0x4c
 801e8f2:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e8f4:	2801      	cmp	r0, #1
 801e8f6:	bfb8      	it	lt
 801e8f8:	2001      	movlt	r0, #1
 801e8fa:	4283      	cmp	r3, r0
 801e8fc:	bfb4      	ite	lt
 801e8fe:	200e      	movlt	r0, #14
 801e900:	200b      	movge	r0, #11
 801e902:	e42c      	b.n	801e15e <cblas_zher2k+0x8e>
 801e904:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 801e908:	2801      	cmp	r0, #1
 801e90a:	bf94      	ite	ls
 801e90c:	2000      	movls	r0, #0
 801e90e:	2001      	movhi	r0, #1
 801e910:	e405      	b.n	801e11e <cblas_zher2k+0x4e>
    } else if (beta != 1.0) {
 801e912:	4b3d      	ldr	r3, [pc, #244]	; (801ea08 <cblas_zher2k+0x938>)
 801e914:	2200      	movs	r2, #0
 801e916:	4650      	mov	r0, sl
 801e918:	4659      	mov	r1, fp
 801e91a:	f009 fd2d 	bl	8028378 <__aeabi_dcmpeq>
 801e91e:	2800      	cmp	r0, #0
 801e920:	d14f      	bne.n	801e9c2 <cblas_zher2k+0x8f2>
      if (uplo == CblasUpper) {
 801e922:	9b00      	ldr	r3, [sp, #0]
 801e924:	2b79      	cmp	r3, #121	; 0x79
        for (i = 0; i < N; i++) {
 801e926:	9b13      	ldr	r3, [sp, #76]	; 0x4c
      if (uplo == CblasUpper) {
 801e928:	f000 8292 	beq.w	801ee50 <cblas_zher2k+0xd80>
        for (i = 0; i < N; i++) {
 801e92c:	2b00      	cmp	r3, #0
 801e92e:	f77f ac7c 	ble.w	801e22a <cblas_zher2k+0x15a>
 801e932:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e934:	9a19      	ldr	r2, [sp, #100]	; 0x64
 801e936:	1c5e      	adds	r6, r3, #1
          IMAG(C, ldc * i + i) = 0.0;
 801e938:	ed9f 8b31 	vldr	d8, [pc, #196]	; 801ea00 <cblas_zher2k+0x930>
 801e93c:	0131      	lsls	r1, r6, #4
 801e93e:	f102 0708 	add.w	r7, r2, #8
 801e942:	971c      	str	r7, [sp, #112]	; 0x70
        for (i = 0; i < N; i++) {
 801e944:	4681      	mov	r9, r0
 801e946:	9112      	str	r1, [sp, #72]	; 0x48
 801e948:	eb02 1606 	add.w	r6, r2, r6, lsl #4
 801e94c:	4698      	mov	r8, r3
          REAL(C, ldc * i + i) *= beta;
 801e94e:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 801e952:	465b      	mov	r3, fp
 801e954:	4652      	mov	r2, sl
 801e956:	f009 faa7 	bl	8027ea8 <__aeabi_dmul>
        for (i = 0; i < N; i++) {
 801e95a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e95c:	f109 0901 	add.w	r9, r9, #1
 801e960:	454b      	cmp	r3, r9
          REAL(C, ldc * i + i) *= beta;
 801e962:	e947 0102 	strd	r0, r1, [r7, #-8]
          IMAG(C, ldc * i + i) = 0.0;
 801e966:	ed87 8b00 	vstr	d8, [r7]
        for (i = 0; i < N; i++) {
 801e96a:	f43f ac5e 	beq.w	801e22a <cblas_zher2k+0x15a>
          for (j = 0; j < i; j++) {
 801e96e:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801e970:	eb03 1408 	add.w	r4, r3, r8, lsl #4
 801e974:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801e976:	eb03 1508 	add.w	r5, r3, r8, lsl #4
            REAL(C, ldc * i + j) *= beta;
 801e97a:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 801e97e:	4652      	mov	r2, sl
 801e980:	465b      	mov	r3, fp
 801e982:	f009 fa91 	bl	8027ea8 <__aeabi_dmul>
 801e986:	e945 0102 	strd	r0, r1, [r5, #-8]
            IMAG(C, ldc * i + j) *= beta;
 801e98a:	4652      	mov	r2, sl
 801e98c:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801e990:	465b      	mov	r3, fp
 801e992:	f009 fa89 	bl	8027ea8 <__aeabi_dmul>
 801e996:	3410      	adds	r4, #16
 801e998:	e944 0102 	strd	r0, r1, [r4, #-8]
          for (j = 0; j < i; j++) {
 801e99c:	42a6      	cmp	r6, r4
 801e99e:	f105 0510 	add.w	r5, r5, #16
 801e9a2:	d1ea      	bne.n	801e97a <cblas_zher2k+0x8aa>
 801e9a4:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e9a6:	4498      	add	r8, r3
 801e9a8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801e9aa:	441e      	add	r6, r3
 801e9ac:	441f      	add	r7, r3
 801e9ae:	e7ce      	b.n	801e94e <cblas_zher2k+0x87e>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801e9b0:	2a6f      	cmp	r2, #111	; 0x6f
 801e9b2:	f000 824a 	beq.w	801ee4a <cblas_zher2k+0xd7a>
 801e9b6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e9b8:	f7ff bbab 	b.w	801e112 <cblas_zher2k+0x42>
      uplo = Uplo;
 801e9bc:	9700      	str	r7, [sp, #0]
      trans = Trans;
 801e9be:	9403      	str	r4, [sp, #12]
 801e9c0:	e408      	b.n	801e1d4 <cblas_zher2k+0x104>
      for (i = 0; i < N; i++) {
 801e9c2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801e9c4:	2b00      	cmp	r3, #0
 801e9c6:	dd0c      	ble.n	801e9e2 <cblas_zher2k+0x912>
 801e9c8:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801e9ca:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 801e9cc:	1c5a      	adds	r2, r3, #1
 801e9ce:	9b19      	ldr	r3, [sp, #100]	; 0x64
        IMAG(C, ldc * i + i) = 0.0;
 801e9d0:	2000      	movs	r0, #0
 801e9d2:	2100      	movs	r1, #0
 801e9d4:	0112      	lsls	r2, r2, #4
      for (i = 0; i < N; i++) {
 801e9d6:	3401      	adds	r4, #1
 801e9d8:	42a5      	cmp	r5, r4
        IMAG(C, ldc * i + i) = 0.0;
 801e9da:	e9c3 0102 	strd	r0, r1, [r3, #8]
      for (i = 0; i < N; i++) {
 801e9de:	4413      	add	r3, r2
 801e9e0:	d1f9      	bne.n	801e9d6 <cblas_zher2k+0x906>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 801e9e2:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 801e9e6:	2200      	movs	r2, #0
 801e9e8:	2300      	movs	r3, #0
 801e9ea:	f009 fcc5 	bl	8028378 <__aeabi_dcmpeq>
 801e9ee:	2800      	cmp	r0, #0
 801e9f0:	f43f ac2b 	beq.w	801e24a <cblas_zher2k+0x17a>
 801e9f4:	e420      	b.n	801e238 <cblas_zher2k+0x168>
  CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 801e9f6:	200e      	movs	r0, #14
 801e9f8:	f7ff bbb1 	b.w	801e15e <cblas_zher2k+0x8e>
 801e9fc:	f3af 8000 	nop.w
	...
 801ea08:	3ff00000 	.word	0x3ff00000
      for (i = 0; i < N; i++) {
 801ea0c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801ea0e:	2b00      	cmp	r3, #0
 801ea10:	f77f af5a 	ble.w	801e8c8 <cblas_zher2k+0x7f8>
 801ea14:	9b20      	ldr	r3, [sp, #128]	; 0x80
 801ea16:	9819      	ldr	r0, [sp, #100]	; 0x64
 801ea18:	0119      	lsls	r1, r3, #4
 801ea1a:	9126      	str	r1, [sp, #152]	; 0x98
 801ea1c:	3110      	adds	r1, #16
 801ea1e:	9123      	str	r1, [sp, #140]	; 0x8c
 801ea20:	9913      	ldr	r1, [sp, #76]	; 0x4c
 801ea22:	f1a0 0310 	sub.w	r3, r0, #16
 801ea26:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 801ea2a:	931e      	str	r3, [sp, #120]	; 0x78
 801ea2c:	f100 0308 	add.w	r3, r0, #8
 801ea30:	931f      	str	r3, [sp, #124]	; 0x7c
 801ea32:	9b16      	ldr	r3, [sp, #88]	; 0x58
 801ea34:	9917      	ldr	r1, [sp, #92]	; 0x5c
 801ea36:	011b      	lsls	r3, r3, #4
 801ea38:	9325      	str	r3, [sp, #148]	; 0x94
 801ea3a:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801ea3c:	011b      	lsls	r3, r3, #4
 801ea3e:	9324      	str	r3, [sp, #144]	; 0x90
 801ea40:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801ea42:	2200      	movs	r2, #0
 801ea44:	9221      	str	r2, [sp, #132]	; 0x84
 801ea46:	9222      	str	r2, [sp, #136]	; 0x88
 801ea48:	9220      	str	r2, [sp, #128]	; 0x80
 801ea4a:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 801ea4e:	920a      	str	r2, [sp, #40]	; 0x28
 801ea50:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 801ea52:	e9cd 231c 	strd	r2, r3, [sp, #112]	; 0x70
          for (k = 0; k < K; k++) {
 801ea56:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801ea58:	2b00      	cmp	r3, #0
 801ea5a:	f340 8232 	ble.w	801eec2 <cblas_zher2k+0xdf2>
          BASE temp_real = 0.0;
 801ea5e:	ed9f 7bd4 	vldr	d7, [pc, #848]	; 801edb0 <cblas_zher2k+0xce0>
          for (k = 0; k < K; k++) {
 801ea62:	e9dd ba1c 	ldrd	fp, sl, [sp, #112]	; 0x70
          BASE temp_real = 0.0;
 801ea66:	eeb0 aa47 	vmov.f32	s20, s14
 801ea6a:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801ea6e:	e9da 6700 	ldrd	r6, r7, [sl]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ea72:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
 801ea76:	4632      	mov	r2, r6
 801ea78:	463b      	mov	r3, r7
 801ea7a:	ec51 0b19 	vmov	r0, r1, d9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801ea7e:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ea82:	f009 fa11 	bl	8027ea8 <__aeabi_dmul>
 801ea86:	ed9d 8b10 	vldr	d8, [sp, #64]	; 0x40
 801ea8a:	4642      	mov	r2, r8
 801ea8c:	464b      	mov	r3, r9
 801ea8e:	4604      	mov	r4, r0
 801ea90:	460d      	mov	r5, r1
 801ea92:	ec51 0b18 	vmov	r0, r1, d8
 801ea96:	f009 fa07 	bl	8027ea8 <__aeabi_dmul>
 801ea9a:	4602      	mov	r2, r0
 801ea9c:	460b      	mov	r3, r1
 801ea9e:	4620      	mov	r0, r4
 801eaa0:	4629      	mov	r1, r5
 801eaa2:	f009 f849 	bl	8027b38 <__aeabi_dsub>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801eaa6:	e9db 2300 	ldrd	r2, r3, [fp]
 801eaaa:	f009 f9fd 	bl	8027ea8 <__aeabi_dmul>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801eaae:	4642      	mov	r2, r8
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801eab0:	4604      	mov	r4, r0
 801eab2:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801eab4:	464b      	mov	r3, r9
 801eab6:	ec51 0b19 	vmov	r0, r1, d9
 801eaba:	f009 f9f5 	bl	8027ea8 <__aeabi_dmul>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801eabe:	46a0      	mov	r8, r4
 801eac0:	46a9      	mov	r9, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801eac2:	4632      	mov	r2, r6
 801eac4:	463b      	mov	r3, r7
 801eac6:	4604      	mov	r4, r0
 801eac8:	460d      	mov	r5, r1
 801eaca:	ec51 0b18 	vmov	r0, r1, d8
 801eace:	f009 f9eb 	bl	8027ea8 <__aeabi_dmul>
 801ead2:	4602      	mov	r2, r0
 801ead4:	460b      	mov	r3, r1
 801ead6:	4620      	mov	r0, r4
 801ead8:	4629      	mov	r1, r5
 801eada:	f009 f82f 	bl	8027b3c <__adddf3>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801eade:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801eae2:	f009 f9e1 	bl	8027ea8 <__aeabi_dmul>
 801eae6:	4602      	mov	r2, r0
 801eae8:	460b      	mov	r3, r1
 801eaea:	4640      	mov	r0, r8
 801eaec:	4649      	mov	r1, r9
 801eaee:	f009 f825 	bl	8027b3c <__adddf3>
 801eaf2:	4602      	mov	r2, r0
 801eaf4:	460b      	mov	r3, r1
 801eaf6:	ec51 0b1a 	vmov	r0, r1, d10
 801eafa:	f009 f81f 	bl	8027b3c <__adddf3>
 801eafe:	460b      	mov	r3, r1
 801eb00:	4602      	mov	r2, r0
 801eb02:	ec43 2b1a 	vmov	d10, r2, r3
          for (k = 0; k < K; k++) {
 801eb06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801eb08:	f10a 0a10 	add.w	sl, sl, #16
 801eb0c:	4553      	cmp	r3, sl
 801eb0e:	f10b 0b10 	add.w	fp, fp, #16
 801eb12:	d1ac      	bne.n	801ea6e <cblas_zher2k+0x99e>
 801eb14:	ec53 2b1a 	vmov	r2, r3, d10
 801eb18:	f009 f810 	bl	8027b3c <__adddf3>
 801eb1c:	4602      	mov	r2, r0
 801eb1e:	460b      	mov	r3, r1
          REAL(C, i * ldc + i) += 2 * temp_real;
 801eb20:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 801eb22:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801eb26:	f009 f809 	bl	8027b3c <__adddf3>
        for (j = i + 1; j < N; j++) {
 801eb2a:	9d20      	ldr	r5, [sp, #128]	; 0x80
 801eb2c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
          IMAG(C, i * ldc + i) = 0.0;
 801eb2e:	ed9f 7ba0 	vldr	d7, [pc, #640]	; 801edb0 <cblas_zher2k+0xce0>
        for (j = i + 1; j < N; j++) {
 801eb32:	3501      	adds	r5, #1
 801eb34:	42aa      	cmp	r2, r5
          REAL(C, i * ldc + i) += 2 * temp_real;
 801eb36:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(C, i * ldc + i) = 0.0;
 801eb3a:	ed84 7b00 	vstr	d7, [r4]
        for (j = i + 1; j < N; j++) {
 801eb3e:	9520      	str	r5, [sp, #128]	; 0x80
 801eb40:	f43f aec2 	beq.w	801e8c8 <cblas_zher2k+0x7f8>
 801eb44:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801eb46:	9916      	ldr	r1, [sp, #88]	; 0x58
 801eb48:	9818      	ldr	r0, [sp, #96]	; 0x60
 801eb4a:	440a      	add	r2, r1
 801eb4c:	9921      	ldr	r1, [sp, #132]	; 0x84
 801eb4e:	9222      	str	r2, [sp, #136]	; 0x88
 801eb50:	4401      	add	r1, r0
 801eb52:	f1a4 0308 	sub.w	r3, r4, #8
 801eb56:	9121      	str	r1, [sp, #132]	; 0x84
 801eb58:	910c      	str	r1, [sp, #48]	; 0x30
 801eb5a:	9214      	str	r2, [sp, #80]	; 0x50
 801eb5c:	9319      	str	r3, [sp, #100]	; 0x64
          BASE temp_imag = 0.0;
 801eb5e:	ed9f 7b94 	vldr	d7, [pc, #592]	; 801edb0 <cblas_zher2k+0xce0>
          for (k = 0; k < K; k++) {
 801eb62:	9b17      	ldr	r3, [sp, #92]	; 0x5c
          BASE temp_imag = 0.0;
 801eb64:	eeb0 fa47 	vmov.f32	s30, s14
 801eb68:	eef0 fa67 	vmov.f32	s31, s15
          for (k = 0; k < K; k++) {
 801eb6c:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 801eb6e:	eeb0 ea47 	vmov.f32	s28, s14
 801eb72:	eef0 ea67 	vmov.f32	s29, s15
          for (k = 0; k < K; k++) {
 801eb76:	f340 811f 	ble.w	801edb8 <cblas_zher2k+0xce8>
 801eb7a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801eb7c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801eb7e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801eb82:	9312      	str	r3, [sp, #72]	; 0x48
 801eb84:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801eb86:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801eb88:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801eb8c:	9304      	str	r3, [sp, #16]
 801eb8e:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801eb92:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 801eb94:	9300      	str	r3, [sp, #0]
 801eb96:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801eb98:	9303      	str	r3, [sp, #12]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801eb9a:	9c03      	ldr	r4, [sp, #12]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801eb9c:	ed9d 8b0e 	vldr	d8, [sp, #56]	; 0x38
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801eba0:	e9d4 6700 	ldrd	r6, r7, [r4]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801eba4:	ec51 0b18 	vmov	r0, r1, d8
 801eba8:	4632      	mov	r2, r6
 801ebaa:	463b      	mov	r3, r7
 801ebac:	f009 f97c 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801ebb0:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ebb4:	460d      	mov	r5, r1
 801ebb6:	4642      	mov	r2, r8
 801ebb8:	464b      	mov	r3, r9
 801ebba:	4604      	mov	r4, r0
 801ebbc:	4659      	mov	r1, fp
 801ebbe:	4650      	mov	r0, sl
 801ebc0:	f009 f972 	bl	8027ea8 <__aeabi_dmul>
 801ebc4:	4602      	mov	r2, r0
 801ebc6:	460b      	mov	r3, r1
 801ebc8:	4620      	mov	r0, r4
 801ebca:	4629      	mov	r1, r5
 801ebcc:	f008 ffb4 	bl	8027b38 <__aeabi_dsub>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ebd0:	4642      	mov	r2, r8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ebd2:	4604      	mov	r4, r0
 801ebd4:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ebd6:	464b      	mov	r3, r9
 801ebd8:	ec51 0b18 	vmov	r0, r1, d8
 801ebdc:	f009 f964 	bl	8027ea8 <__aeabi_dmul>
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ebe0:	ec45 4b1c 	vmov	d12, r4, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ebe4:	4632      	mov	r2, r6
 801ebe6:	463b      	mov	r3, r7
 801ebe8:	4604      	mov	r4, r0
 801ebea:	460d      	mov	r5, r1
 801ebec:	4650      	mov	r0, sl
 801ebee:	4659      	mov	r1, fp
 801ebf0:	f009 f95a 	bl	8027ea8 <__aeabi_dmul>
 801ebf4:	4602      	mov	r2, r0
 801ebf6:	460b      	mov	r3, r1
 801ebf8:	4620      	mov	r0, r4
 801ebfa:	4629      	mov	r1, r5
 801ebfc:	f008 ff9e 	bl	8027b3c <__adddf3>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801ec00:	9e12      	ldr	r6, [sp, #72]	; 0x48
 801ec02:	ed96 bb00 	vldr	d11, [r6]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ec06:	4604      	mov	r4, r0
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801ec08:	ec53 2b1b 	vmov	r2, r3, d11
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ec0c:	460d      	mov	r5, r1
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801ec0e:	ec51 0b18 	vmov	r0, r1, d8
 801ec12:	f009 f949 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801ec16:	e9d6 8902 	ldrd	r8, r9, [r6, #8]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ec1a:	ec45 4b1a 	vmov	d10, r4, r5
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801ec1e:	4642      	mov	r2, r8
 801ec20:	464b      	mov	r3, r9
 801ec22:	4604      	mov	r4, r0
 801ec24:	460d      	mov	r5, r1
 801ec26:	4650      	mov	r0, sl
 801ec28:	4659      	mov	r1, fp
 801ec2a:	f009 f93d 	bl	8027ea8 <__aeabi_dmul>
 801ec2e:	4602      	mov	r2, r0
 801ec30:	460b      	mov	r3, r1
 801ec32:	4620      	mov	r0, r4
 801ec34:	4629      	mov	r1, r5
 801ec36:	f008 ff7f 	bl	8027b38 <__aeabi_dsub>
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801ec3a:	4642      	mov	r2, r8
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801ec3c:	4604      	mov	r4, r0
 801ec3e:	460d      	mov	r5, r1
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801ec40:	464b      	mov	r3, r9
 801ec42:	ec51 0b18 	vmov	r0, r1, d8
 801ec46:	f009 f92f 	bl	8027ea8 <__aeabi_dmul>
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801ec4a:	ec45 4b19 	vmov	d9, r4, r5
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801ec4e:	ec53 2b1b 	vmov	r2, r3, d11
 801ec52:	4604      	mov	r4, r0
 801ec54:	460d      	mov	r5, r1
 801ec56:	4650      	mov	r0, sl
 801ec58:	4659      	mov	r1, fp
 801ec5a:	f009 f925 	bl	8027ea8 <__aeabi_dmul>
 801ec5e:	4602      	mov	r2, r0
 801ec60:	460b      	mov	r3, r1
 801ec62:	4620      	mov	r0, r4
 801ec64:	4629      	mov	r1, r5
 801ec66:	f008 ff69 	bl	8027b3c <__adddf3>
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801ec6a:	9f04      	ldr	r7, [sp, #16]
 801ec6c:	ed97 7b00 	vldr	d7, [r7]
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801ec70:	4604      	mov	r4, r0
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ec72:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801ec76:	eeb0 ba47 	vmov.f32	s22, s14
 801ec7a:	eef0 ba67 	vmov.f32	s23, s15
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801ec7e:	460d      	mov	r5, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ec80:	ec51 0b1c 	vmov	r0, r1, d12
 801ec84:	f009 f910 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 801ec88:	e9d7 8902 	ldrd	r8, r9, [r7, #8]
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ec8c:	ec41 0b1d 	vmov	d13, r0, r1
 801ec90:	4642      	mov	r2, r8
 801ec92:	464b      	mov	r3, r9
 801ec94:	ec51 0b1a 	vmov	r0, r1, d10
 801ec98:	f009 f906 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801ec9c:	9e00      	ldr	r6, [sp, #0]
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ec9e:	4602      	mov	r2, r0
 801eca0:	460b      	mov	r3, r1
 801eca2:	ec51 0b1d 	vmov	r0, r1, d13
 801eca6:	f008 ff49 	bl	8027b3c <__adddf3>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801ecaa:	ed96 8b00 	vldr	d8, [r6]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801ecae:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ecb2:	4606      	mov	r6, r0
 801ecb4:	460f      	mov	r7, r1
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801ecb6:	ec51 0b18 	vmov	r0, r1, d8
 801ecba:	f009 f8f5 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801ecbe:	9b00      	ldr	r3, [sp, #0]
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ecc0:	f8cd 8018 	str.w	r8, [sp, #24]
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801ecc4:	ed93 6b02 	vldr	d6, [r3, #8]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801ecc8:	ec41 0b1d 	vmov	d13, r0, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801eccc:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801ecd0:	ec59 8b16 	vmov	r8, r9, d6
 801ecd4:	ee16 0a10 	vmov	r0, s12
 801ecd8:	4622      	mov	r2, r4
 801ecda:	462b      	mov	r3, r5
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ecdc:	9107      	str	r1, [sp, #28]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801ecde:	4649      	mov	r1, r9
 801ece0:	f009 f8e2 	bl	8027ea8 <__aeabi_dmul>
 801ece4:	4602      	mov	r2, r0
 801ece6:	460b      	mov	r3, r1
 801ece8:	ec51 0b1d 	vmov	r0, r1, d13
 801ecec:	f008 ff26 	bl	8027b3c <__adddf3>
 801ecf0:	4602      	mov	r2, r0
 801ecf2:	460b      	mov	r3, r1
 801ecf4:	4630      	mov	r0, r6
 801ecf6:	4639      	mov	r1, r7
 801ecf8:	f008 ff20 	bl	8027b3c <__adddf3>
 801ecfc:	4602      	mov	r2, r0
 801ecfe:	460b      	mov	r3, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ed00:	ec51 0b1e 	vmov	r0, r1, d14
 801ed04:	f008 ff1a 	bl	8027b3c <__adddf3>
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed08:	ec53 2b1c 	vmov	r2, r3, d12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ed0c:	4606      	mov	r6, r0
 801ed0e:	460f      	mov	r7, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed10:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 801ed14:	f009 f8c8 	bl	8027ea8 <__aeabi_dmul>
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801ed18:	ec47 6b1e 	vmov	d14, r6, r7
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed1c:	ec53 2b1b 	vmov	r2, r3, d11
 801ed20:	4606      	mov	r6, r0
 801ed22:	460f      	mov	r7, r1
 801ed24:	ec51 0b1a 	vmov	r0, r1, d10
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801ed28:	9408      	str	r4, [sp, #32]
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed2a:	f009 f8bd 	bl	8027ea8 <__aeabi_dmul>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801ed2e:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed32:	4602      	mov	r2, r0
 801ed34:	460b      	mov	r3, r1
 801ed36:	4630      	mov	r0, r6
 801ed38:	4639      	mov	r1, r7
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801ed3a:	9509      	str	r5, [sp, #36]	; 0x24
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed3c:	f008 fefe 	bl	8027b3c <__adddf3>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801ed40:	ec53 2b18 	vmov	r2, r3, d8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed44:	4604      	mov	r4, r0
 801ed46:	460d      	mov	r5, r1
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801ed48:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 801ed4c:	f009 f8ac 	bl	8027ea8 <__aeabi_dmul>
 801ed50:	ec53 2b19 	vmov	r2, r3, d9
 801ed54:	4606      	mov	r6, r0
 801ed56:	460f      	mov	r7, r1
 801ed58:	4640      	mov	r0, r8
 801ed5a:	4649      	mov	r1, r9
 801ed5c:	f009 f8a4 	bl	8027ea8 <__aeabi_dmul>
 801ed60:	4602      	mov	r2, r0
 801ed62:	460b      	mov	r3, r1
 801ed64:	4630      	mov	r0, r6
 801ed66:	4639      	mov	r1, r7
 801ed68:	f008 fee8 	bl	8027b3c <__adddf3>
 801ed6c:	4602      	mov	r2, r0
 801ed6e:	460b      	mov	r3, r1
 801ed70:	4620      	mov	r0, r4
 801ed72:	4629      	mov	r1, r5
 801ed74:	f008 fee2 	bl	8027b3c <__adddf3>
 801ed78:	4602      	mov	r2, r0
 801ed7a:	460b      	mov	r3, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801ed7c:	ec51 0b1f 	vmov	r0, r1, d15
 801ed80:	f008 fedc 	bl	8027b3c <__adddf3>
 801ed84:	9b00      	ldr	r3, [sp, #0]
 801ed86:	9c03      	ldr	r4, [sp, #12]
 801ed88:	9e12      	ldr	r6, [sp, #72]	; 0x48
 801ed8a:	9f04      	ldr	r7, [sp, #16]
 801ed8c:	3310      	adds	r3, #16
 801ed8e:	9300      	str	r3, [sp, #0]
          for (k = 0; k < K; k++) {
 801ed90:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ed92:	f104 0210 	add.w	r2, r4, #16
 801ed96:	f106 0410 	add.w	r4, r6, #16
 801ed9a:	9412      	str	r4, [sp, #72]	; 0x48
 801ed9c:	4293      	cmp	r3, r2
 801ed9e:	f107 0410 	add.w	r4, r7, #16
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801eda2:	ec41 0b1f 	vmov	d15, r0, r1
          for (k = 0; k < K; k++) {
 801eda6:	9203      	str	r2, [sp, #12]
 801eda8:	9404      	str	r4, [sp, #16]
 801edaa:	f47f aef6 	bne.w	801eb9a <cblas_zher2k+0xaca>
 801edae:	e003      	b.n	801edb8 <cblas_zher2k+0xce8>
	...
          REAL(C, i * ldc + j) += temp_real;
 801edb8:	9c19      	ldr	r4, [sp, #100]	; 0x64
 801edba:	ec53 2b1e 	vmov	r2, r3, d14
 801edbe:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801edc2:	f008 febb 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += temp_imag;
 801edc6:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(C, i * ldc + j) += temp_real;
 801edca:	e9c4 0104 	strd	r0, r1, [r4, #16]
          IMAG(C, i * ldc + j) += temp_imag;
 801edce:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801edd2:	f008 feb3 	bl	8027b3c <__adddf3>
 801edd6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801edd8:	e9c4 0106 	strd	r0, r1, [r4, #24]
        for (j = i + 1; j < N; j++) {
 801eddc:	9916      	ldr	r1, [sp, #88]	; 0x58
 801edde:	440a      	add	r2, r1
 801ede0:	9214      	str	r2, [sp, #80]	; 0x50
 801ede2:	9918      	ldr	r1, [sp, #96]	; 0x60
 801ede4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801ede6:	440a      	add	r2, r1
 801ede8:	920c      	str	r2, [sp, #48]	; 0x30
 801edea:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801edec:	f104 0310 	add.w	r3, r4, #16
 801edf0:	429a      	cmp	r2, r3
 801edf2:	9319      	str	r3, [sp, #100]	; 0x64
 801edf4:	f47f aeb3 	bne.w	801eb5e <cblas_zher2k+0xa8e>
 801edf8:	4613      	mov	r3, r2
 801edfa:	9a26      	ldr	r2, [sp, #152]	; 0x98
 801edfc:	4413      	add	r3, r2
 801edfe:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 801ee00:	931e      	str	r3, [sp, #120]	; 0x78
 801ee02:	9b25      	ldr	r3, [sp, #148]	; 0x94
 801ee04:	4611      	mov	r1, r2
 801ee06:	4419      	add	r1, r3
 801ee08:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801ee0a:	911d      	str	r1, [sp, #116]	; 0x74
 801ee0c:	9924      	ldr	r1, [sp, #144]	; 0x90
 801ee0e:	440a      	add	r2, r1
 801ee10:	921c      	str	r2, [sp, #112]	; 0x70
 801ee12:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ee14:	441a      	add	r2, r3
 801ee16:	920a      	str	r2, [sp, #40]	; 0x28
 801ee18:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801ee1a:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801ee1c:	4413      	add	r3, r2
 801ee1e:	931f      	str	r3, [sp, #124]	; 0x7c
 801ee20:	e619      	b.n	801ea56 <cblas_zher2k+0x986>
      for (k = 0; k < K; k++) {
 801ee22:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 801ee24:	9916      	ldr	r1, [sp, #88]	; 0x58
 801ee26:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801ee28:	440a      	add	r2, r1
 801ee2a:	921c      	str	r2, [sp, #112]	; 0x70
 801ee2c:	9918      	ldr	r1, [sp, #96]	; 0x60
 801ee2e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801ee30:	440a      	add	r2, r1
 801ee32:	9214      	str	r2, [sp, #80]	; 0x50
 801ee34:	991e      	ldr	r1, [sp, #120]	; 0x78
 801ee36:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ee38:	440a      	add	r2, r1
 801ee3a:	920a      	str	r2, [sp, #40]	; 0x28
 801ee3c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 801ee3e:	3301      	adds	r3, #1
 801ee40:	429a      	cmp	r2, r3
 801ee42:	931d      	str	r3, [sp, #116]	; 0x74
 801ee44:	f47f aa61 	bne.w	801e30a <cblas_zher2k+0x23a>
 801ee48:	e53e      	b.n	801e8c8 <cblas_zher2k+0x7f8>
 801ee4a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801ee4c:	f7ff ba0f 	b.w	801e26e <cblas_zher2k+0x19e>
        for (i = 0; i < N; i++) {
 801ee50:	2b00      	cmp	r3, #0
 801ee52:	f77f aa34 	ble.w	801e2be <cblas_zher2k+0x1ee>
 801ee56:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801ee58:	ea4f 1802 	mov.w	r8, r2, lsl #4
 801ee5c:	9a19      	ldr	r2, [sp, #100]	; 0x64
          IMAG(C, ldc * i + i) = 0.0;
 801ee5e:	ed1f 8b2c 	vldr	d8, [pc, #-176]	; 801edb0 <cblas_zher2k+0xce0>
 801ee62:	f1a2 0510 	sub.w	r5, r2, #16
        for (i = 0; i < N; i++) {
 801ee66:	4607      	mov	r7, r0
 801ee68:	f108 0910 	add.w	r9, r8, #16
 801ee6c:	eb05 1503 	add.w	r5, r5, r3, lsl #4
 801ee70:	f102 0608 	add.w	r6, r2, #8
          REAL(C, ldc * i + i) *= beta;
 801ee74:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 801ee78:	465b      	mov	r3, fp
 801ee7a:	4652      	mov	r2, sl
 801ee7c:	f009 f814 	bl	8027ea8 <__aeabi_dmul>
          for (j = i + 1; j < N; j++) {
 801ee80:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801ee82:	3701      	adds	r7, #1
 801ee84:	42bb      	cmp	r3, r7
          REAL(C, ldc * i + i) *= beta;
 801ee86:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, ldc * i + i) = 0.0;
 801ee8a:	ed86 8b00 	vstr	d8, [r6]
          for (j = i + 1; j < N; j++) {
 801ee8e:	f43f aa16 	beq.w	801e2be <cblas_zher2k+0x1ee>
 801ee92:	f1a6 0408 	sub.w	r4, r6, #8
            REAL(C, ldc * i + j) *= beta;
 801ee96:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801ee9a:	4652      	mov	r2, sl
 801ee9c:	465b      	mov	r3, fp
 801ee9e:	f009 f803 	bl	8027ea8 <__aeabi_dmul>
            IMAG(C, ldc * i + j) *= beta;
 801eea2:	4652      	mov	r2, sl
            REAL(C, ldc * i + j) *= beta;
 801eea4:	e9c4 0104 	strd	r0, r1, [r4, #16]
            IMAG(C, ldc * i + j) *= beta;
 801eea8:	465b      	mov	r3, fp
 801eeaa:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801eeae:	f008 fffb 	bl	8027ea8 <__aeabi_dmul>
 801eeb2:	3410      	adds	r4, #16
 801eeb4:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = i + 1; j < N; j++) {
 801eeb8:	42a5      	cmp	r5, r4
 801eeba:	d1ec      	bne.n	801ee96 <cblas_zher2k+0xdc6>
 801eebc:	4445      	add	r5, r8
 801eebe:	444e      	add	r6, r9
 801eec0:	e7d8      	b.n	801ee74 <cblas_zher2k+0xda4>
          for (k = 0; k < K; k++) {
 801eec2:	2200      	movs	r2, #0
 801eec4:	2300      	movs	r3, #0
 801eec6:	e62b      	b.n	801eb20 <cblas_zher2k+0xa50>
      for (i = 0; i < N; i++) {
 801eec8:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 801eeca:	2b00      	cmp	r3, #0
 801eecc:	f77f acfc 	ble.w	801e8c8 <cblas_zher2k+0x7f8>
 801eed0:	9c20      	ldr	r4, [sp, #128]	; 0x80
 801eed2:	9f19      	ldr	r7, [sp, #100]	; 0x64
 801eed4:	9424      	str	r4, [sp, #144]	; 0x90
 801eed6:	e9dd 5016 	ldrd	r5, r0, [sp, #88]	; 0x58
 801eeda:	1c63      	adds	r3, r4, #1
 801eedc:	011a      	lsls	r2, r3, #4
 801eede:	9229      	str	r2, [sp, #164]	; 0xa4
 801eee0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 801eee2:	1941      	adds	r1, r0, r5
 801eee4:	eb07 1303 	add.w	r3, r7, r3, lsl #4
 801eee8:	ebc0 7c00 	rsb	ip, r0, r0, lsl #28
 801eeec:	931e      	str	r3, [sp, #120]	; 0x78
 801eeee:	eb02 1301 	add.w	r3, r2, r1, lsl #4
 801eef2:	9306      	str	r3, [sp, #24]
 801eef4:	4663      	mov	r3, ip
 801eef6:	2600      	movs	r6, #0
 801eef8:	011b      	lsls	r3, r3, #4
 801eefa:	e9cd 6325 	strd	r6, r3, [sp, #148]	; 0x94
 801eefe:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801ef00:	9623      	str	r6, [sp, #140]	; 0x8c
 801ef02:	0119      	lsls	r1, r3, #4
 801ef04:	9128      	str	r1, [sp, #160]	; 0xa0
 801ef06:	991a      	ldr	r1, [sp, #104]	; 0x68
 801ef08:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 801ef0c:	931f      	str	r3, [sp, #124]	; 0x7c
 801ef0e:	012b      	lsls	r3, r5, #4
 801ef10:	9327      	str	r3, [sp, #156]	; 0x9c
 801ef12:	eb02 1300 	add.w	r3, r2, r0, lsl #4
 801ef16:	931d      	str	r3, [sp, #116]	; 0x74
 801ef18:	f107 0308 	add.w	r3, r7, #8
 801ef1c:	9322      	str	r3, [sp, #136]	; 0x88
          for (k = 0; k < K; k++) {
 801ef1e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 801ef20:	2b00      	cmp	r3, #0
 801ef22:	f340 81ea 	ble.w	801f2fa <cblas_zher2k+0x122a>
 801ef26:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801ef28:	9a1d      	ldr	r2, [sp, #116]	; 0x74
          BASE temp_real = 0.0;
 801ef2a:	ed1f 7b5f 	vldr	d7, [pc, #-380]	; 801edb0 <cblas_zher2k+0xce0>
 801ef2e:	eb03 0a02 	add.w	sl, r3, r2
 801ef32:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801ef34:	9a23      	ldr	r2, [sp, #140]	; 0x8c
 801ef36:	eeb0 aa47 	vmov.f32	s20, s14
 801ef3a:	eef0 aa67 	vmov.f32	s21, s15
 801ef3e:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801ef42:	e9da 6700 	ldrd	r6, r7, [sl]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ef46:	ed9d 9b0e 	vldr	d9, [sp, #56]	; 0x38
 801ef4a:	4632      	mov	r2, r6
 801ef4c:	463b      	mov	r3, r7
 801ef4e:	ec51 0b19 	vmov	r0, r1, d9
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801ef52:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801ef56:	f008 ffa7 	bl	8027ea8 <__aeabi_dmul>
 801ef5a:	ed9d 8b10 	vldr	d8, [sp, #64]	; 0x40
 801ef5e:	4642      	mov	r2, r8
 801ef60:	464b      	mov	r3, r9
 801ef62:	4604      	mov	r4, r0
 801ef64:	460d      	mov	r5, r1
 801ef66:	ec51 0b18 	vmov	r0, r1, d8
 801ef6a:	f008 ff9d 	bl	8027ea8 <__aeabi_dmul>
 801ef6e:	4602      	mov	r2, r0
 801ef70:	460b      	mov	r3, r1
 801ef72:	4620      	mov	r0, r4
 801ef74:	4629      	mov	r1, r5
 801ef76:	f008 fddf 	bl	8027b38 <__aeabi_dsub>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801ef7a:	e9db 2300 	ldrd	r2, r3, [fp]
 801ef7e:	f008 ff93 	bl	8027ea8 <__aeabi_dmul>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ef82:	4642      	mov	r2, r8
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801ef84:	4604      	mov	r4, r0
 801ef86:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ef88:	464b      	mov	r3, r9
 801ef8a:	ec51 0b19 	vmov	r0, r1, d9
 801ef8e:	f008 ff8b 	bl	8027ea8 <__aeabi_dmul>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801ef92:	46a0      	mov	r8, r4
 801ef94:	46a9      	mov	r9, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801ef96:	4632      	mov	r2, r6
 801ef98:	463b      	mov	r3, r7
 801ef9a:	4604      	mov	r4, r0
 801ef9c:	460d      	mov	r5, r1
 801ef9e:	ec51 0b18 	vmov	r0, r1, d8
 801efa2:	f008 ff81 	bl	8027ea8 <__aeabi_dmul>
 801efa6:	4602      	mov	r2, r0
 801efa8:	460b      	mov	r3, r1
 801efaa:	4620      	mov	r0, r4
 801efac:	4629      	mov	r1, r5
 801efae:	f008 fdc5 	bl	8027b3c <__adddf3>
            temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
 801efb2:	e9db 2302 	ldrd	r2, r3, [fp, #8]
 801efb6:	f008 ff77 	bl	8027ea8 <__aeabi_dmul>
 801efba:	4602      	mov	r2, r0
 801efbc:	460b      	mov	r3, r1
 801efbe:	4640      	mov	r0, r8
 801efc0:	4649      	mov	r1, r9
 801efc2:	f008 fdbb 	bl	8027b3c <__adddf3>
 801efc6:	4602      	mov	r2, r0
 801efc8:	460b      	mov	r3, r1
 801efca:	ec51 0b1a 	vmov	r0, r1, d10
 801efce:	f008 fdb5 	bl	8027b3c <__adddf3>
 801efd2:	460b      	mov	r3, r1
 801efd4:	4602      	mov	r2, r0
 801efd6:	ec43 2b1a 	vmov	d10, r2, r3
          for (k = 0; k < K; k++) {
 801efda:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 801efdc:	f10a 0a10 	add.w	sl, sl, #16
 801efe0:	4553      	cmp	r3, sl
 801efe2:	f10b 0b10 	add.w	fp, fp, #16
 801efe6:	d1ac      	bne.n	801ef42 <cblas_zher2k+0xe72>
 801efe8:	ec53 2b1a 	vmov	r2, r3, d10
 801efec:	f008 fda6 	bl	8027b3c <__adddf3>
 801eff0:	4602      	mov	r2, r0
 801eff2:	460b      	mov	r3, r1
          REAL(C, i * ldc + i) += 2 * temp_real;
 801eff4:	9c22      	ldr	r4, [sp, #136]	; 0x88
 801eff6:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801effa:	f008 fd9f 	bl	8027b3c <__adddf3>
      for (i = 0; i < N; i++) {
 801effe:	9a25      	ldr	r2, [sp, #148]	; 0x94
 801f000:	9b13      	ldr	r3, [sp, #76]	; 0x4c
          IMAG(C, i * ldc + i) = 0.0;
 801f002:	ed1f 7b95 	vldr	d7, [pc, #-596]	; 801edb0 <cblas_zher2k+0xce0>
      for (i = 0; i < N; i++) {
 801f006:	3201      	adds	r2, #1
 801f008:	4293      	cmp	r3, r2
          REAL(C, i * ldc + i) += 2 * temp_real;
 801f00a:	e944 0102 	strd	r0, r1, [r4, #-8]
          IMAG(C, i * ldc + i) = 0.0;
 801f00e:	ed84 7b00 	vstr	d7, [r4]
      for (i = 0; i < N; i++) {
 801f012:	9225      	str	r2, [sp, #148]	; 0x94
 801f014:	f43f ac58 	beq.w	801e8c8 <cblas_zher2k+0x7f8>
 801f018:	2300      	movs	r3, #0
 801f01a:	9a24      	ldr	r2, [sp, #144]	; 0x90
 801f01c:	9308      	str	r3, [sp, #32]
 801f01e:	9314      	str	r3, [sp, #80]	; 0x50
 801f020:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801f022:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801f026:	931c      	str	r3, [sp, #112]	; 0x70
 801f028:	9a06      	ldr	r2, [sp, #24]
 801f02a:	9b26      	ldr	r3, [sp, #152]	; 0x98
 801f02c:	4413      	add	r3, r2
 801f02e:	9321      	str	r3, [sp, #132]	; 0x84
          BASE temp_imag = 0.0;
 801f030:	ed1f 7ba1 	vldr	d7, [pc, #-644]	; 801edb0 <cblas_zher2k+0xce0>
          for (k = 0; k < K; k++) {
 801f034:	9b17      	ldr	r3, [sp, #92]	; 0x5c
          BASE temp_imag = 0.0;
 801f036:	eeb0 fa47 	vmov.f32	s30, s14
 801f03a:	eef0 fa67 	vmov.f32	s31, s15
          for (k = 0; k < K; k++) {
 801f03e:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 801f040:	eeb0 ea47 	vmov.f32	s28, s14
 801f044:	eef0 ea67 	vmov.f32	s29, s15
          for (k = 0; k < K; k++) {
 801f048:	f340 811a 	ble.w	801f280 <cblas_zher2k+0x11b0>
 801f04c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801f04e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 801f050:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801f054:	9303      	str	r3, [sp, #12]
 801f056:	9a08      	ldr	r2, [sp, #32]
 801f058:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 801f05a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 801f05e:	9300      	str	r3, [sp, #0]
 801f060:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
 801f064:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 801f066:	9312      	str	r3, [sp, #72]	; 0x48
 801f068:	9b21      	ldr	r3, [sp, #132]	; 0x84
 801f06a:	9304      	str	r3, [sp, #16]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f06c:	9c04      	ldr	r4, [sp, #16]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f06e:	ed9d 8b0e 	vldr	d8, [sp, #56]	; 0x38
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f072:	e9d4 6700 	ldrd	r6, r7, [r4]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f076:	ec51 0b18 	vmov	r0, r1, d8
 801f07a:	4632      	mov	r2, r6
 801f07c:	463b      	mov	r3, r7
 801f07e:	f008 ff13 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801f082:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f086:	460d      	mov	r5, r1
 801f088:	4642      	mov	r2, r8
 801f08a:	464b      	mov	r3, r9
 801f08c:	4604      	mov	r4, r0
 801f08e:	4659      	mov	r1, fp
 801f090:	4650      	mov	r0, sl
 801f092:	f008 ff09 	bl	8027ea8 <__aeabi_dmul>
 801f096:	4602      	mov	r2, r0
 801f098:	460b      	mov	r3, r1
 801f09a:	4620      	mov	r0, r4
 801f09c:	4629      	mov	r1, r5
 801f09e:	f008 fd4b 	bl	8027b38 <__aeabi_dsub>
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f0a2:	4642      	mov	r2, r8
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f0a4:	4604      	mov	r4, r0
 801f0a6:	460d      	mov	r5, r1
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f0a8:	464b      	mov	r3, r9
 801f0aa:	ec51 0b18 	vmov	r0, r1, d8
 801f0ae:	f008 fefb 	bl	8027ea8 <__aeabi_dmul>
            const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
 801f0b2:	ec45 4b1c 	vmov	d12, r4, r5
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f0b6:	4632      	mov	r2, r6
 801f0b8:	463b      	mov	r3, r7
 801f0ba:	4604      	mov	r4, r0
 801f0bc:	460d      	mov	r5, r1
 801f0be:	4650      	mov	r0, sl
 801f0c0:	4659      	mov	r1, fp
 801f0c2:	f008 fef1 	bl	8027ea8 <__aeabi_dmul>
 801f0c6:	4602      	mov	r2, r0
 801f0c8:	460b      	mov	r3, r1
 801f0ca:	4620      	mov	r0, r4
 801f0cc:	4629      	mov	r1, r5
 801f0ce:	f008 fd35 	bl	8027b3c <__adddf3>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801f0d2:	9e03      	ldr	r6, [sp, #12]
 801f0d4:	ed96 bb00 	vldr	d11, [r6]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f0d8:	4604      	mov	r4, r0
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f0da:	ec53 2b1b 	vmov	r2, r3, d11
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f0de:	460d      	mov	r5, r1
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f0e0:	ec51 0b18 	vmov	r0, r1, d8
 801f0e4:	f008 fee0 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 801f0e8:	e9d6 8902 	ldrd	r8, r9, [r6, #8]
            const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
 801f0ec:	ec45 4b1a 	vmov	d10, r4, r5
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f0f0:	4642      	mov	r2, r8
 801f0f2:	464b      	mov	r3, r9
 801f0f4:	4604      	mov	r4, r0
 801f0f6:	460d      	mov	r5, r1
 801f0f8:	4650      	mov	r0, sl
 801f0fa:	4659      	mov	r1, fp
 801f0fc:	f008 fed4 	bl	8027ea8 <__aeabi_dmul>
 801f100:	4602      	mov	r2, r0
 801f102:	460b      	mov	r3, r1
 801f104:	4620      	mov	r0, r4
 801f106:	4629      	mov	r1, r5
 801f108:	f008 fd16 	bl	8027b38 <__aeabi_dsub>
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f10c:	4642      	mov	r2, r8
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f10e:	4604      	mov	r4, r0
 801f110:	460d      	mov	r5, r1
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f112:	464b      	mov	r3, r9
 801f114:	ec51 0b18 	vmov	r0, r1, d8
 801f118:	f008 fec6 	bl	8027ea8 <__aeabi_dmul>
            const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
 801f11c:	ec45 4b19 	vmov	d9, r4, r5
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f120:	ec53 2b1b 	vmov	r2, r3, d11
 801f124:	4604      	mov	r4, r0
 801f126:	460d      	mov	r5, r1
 801f128:	4650      	mov	r0, sl
 801f12a:	4659      	mov	r1, fp
 801f12c:	f008 febc 	bl	8027ea8 <__aeabi_dmul>
 801f130:	4602      	mov	r2, r0
 801f132:	460b      	mov	r3, r1
 801f134:	4620      	mov	r0, r4
 801f136:	4629      	mov	r1, r5
 801f138:	f008 fd00 	bl	8027b3c <__adddf3>
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801f13c:	9f00      	ldr	r7, [sp, #0]
 801f13e:	ed97 7b00 	vldr	d7, [r7]
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f142:	4604      	mov	r4, r0
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f144:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 801f148:	eeb0 ba47 	vmov.f32	s22, s14
 801f14c:	eef0 ba67 	vmov.f32	s23, s15
            const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
 801f150:	460d      	mov	r5, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f152:	ec51 0b1c 	vmov	r0, r1, d12
 801f156:	f008 fea7 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 801f15a:	e9d7 8902 	ldrd	r8, r9, [r7, #8]
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f15e:	ec41 0b1d 	vmov	d13, r0, r1
 801f162:	4642      	mov	r2, r8
 801f164:	464b      	mov	r3, r9
 801f166:	ec51 0b1a 	vmov	r0, r1, d10
 801f16a:	f008 fe9d 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801f16e:	9e12      	ldr	r6, [sp, #72]	; 0x48
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f170:	4602      	mov	r2, r0
 801f172:	460b      	mov	r3, r1
 801f174:	ec51 0b1d 	vmov	r0, r1, d13
 801f178:	f008 fce0 	bl	8027b3c <__adddf3>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 801f17c:	ed96 8b00 	vldr	d8, [r6]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f180:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f184:	4606      	mov	r6, r0
 801f186:	460f      	mov	r7, r1
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f188:	ec51 0b18 	vmov	r0, r1, d8
 801f18c:	f008 fe8c 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801f190:	9b12      	ldr	r3, [sp, #72]	; 0x48
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f192:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 801f196:	ed93 6b02 	vldr	d6, [r3, #8]
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f19a:	ec41 0b1d 	vmov	d13, r0, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f19e:	f109 4100 	add.w	r1, r9, #2147483648	; 0x80000000
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f1a2:	ec59 8b16 	vmov	r8, r9, d6
 801f1a6:	ee16 0a10 	vmov	r0, s12
 801f1aa:	4622      	mov	r2, r4
 801f1ac:	462b      	mov	r3, r5
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f1ae:	910b      	str	r1, [sp, #44]	; 0x2c
                          + (Bik_real * temp2_real + Bik_imag * temp2_imag));
 801f1b0:	4649      	mov	r1, r9
 801f1b2:	f008 fe79 	bl	8027ea8 <__aeabi_dmul>
 801f1b6:	4602      	mov	r2, r0
 801f1b8:	460b      	mov	r3, r1
 801f1ba:	ec51 0b1d 	vmov	r0, r1, d13
 801f1be:	f008 fcbd 	bl	8027b3c <__adddf3>
 801f1c2:	4602      	mov	r2, r0
 801f1c4:	460b      	mov	r3, r1
 801f1c6:	4630      	mov	r0, r6
 801f1c8:	4639      	mov	r1, r7
 801f1ca:	f008 fcb7 	bl	8027b3c <__adddf3>
 801f1ce:	4602      	mov	r2, r0
 801f1d0:	460b      	mov	r3, r1
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f1d2:	ec51 0b1e 	vmov	r0, r1, d14
 801f1d6:	f008 fcb1 	bl	8027b3c <__adddf3>
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f1da:	ec53 2b1c 	vmov	r2, r3, d12
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f1de:	4606      	mov	r6, r0
 801f1e0:	460f      	mov	r7, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f1e2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 801f1e6:	f008 fe5f 	bl	8027ea8 <__aeabi_dmul>
            temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
 801f1ea:	ec47 6b1e 	vmov	d14, r6, r7
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f1ee:	ec53 2b1b 	vmov	r2, r3, d11
 801f1f2:	4606      	mov	r6, r0
 801f1f4:	460f      	mov	r7, r1
 801f1f6:	ec51 0b1a 	vmov	r0, r1, d10
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f1fa:	940c      	str	r4, [sp, #48]	; 0x30
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f1fc:	f008 fe54 	bl	8027ea8 <__aeabi_dmul>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f200:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f204:	4602      	mov	r2, r0
 801f206:	460b      	mov	r3, r1
 801f208:	4630      	mov	r0, r6
 801f20a:	4639      	mov	r1, r7
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f20c:	950d      	str	r5, [sp, #52]	; 0x34
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f20e:	f008 fc95 	bl	8027b3c <__adddf3>
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f212:	ec53 2b18 	vmov	r2, r3, d8
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f216:	4604      	mov	r4, r0
 801f218:	460d      	mov	r5, r1
                          + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
 801f21a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 801f21e:	f008 fe43 	bl	8027ea8 <__aeabi_dmul>
 801f222:	ec53 2b19 	vmov	r2, r3, d9
 801f226:	4606      	mov	r6, r0
 801f228:	460f      	mov	r7, r1
 801f22a:	4640      	mov	r0, r8
 801f22c:	4649      	mov	r1, r9
 801f22e:	f008 fe3b 	bl	8027ea8 <__aeabi_dmul>
 801f232:	4602      	mov	r2, r0
 801f234:	460b      	mov	r3, r1
 801f236:	4630      	mov	r0, r6
 801f238:	4639      	mov	r1, r7
 801f23a:	f008 fc7f 	bl	8027b3c <__adddf3>
 801f23e:	4602      	mov	r2, r0
 801f240:	460b      	mov	r3, r1
 801f242:	4620      	mov	r0, r4
 801f244:	4629      	mov	r1, r5
 801f246:	f008 fc79 	bl	8027b3c <__adddf3>
 801f24a:	4602      	mov	r2, r0
 801f24c:	460b      	mov	r3, r1
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f24e:	ec51 0b1f 	vmov	r0, r1, d15
 801f252:	f008 fc73 	bl	8027b3c <__adddf3>
 801f256:	9b12      	ldr	r3, [sp, #72]	; 0x48
 801f258:	9c04      	ldr	r4, [sp, #16]
 801f25a:	9e03      	ldr	r6, [sp, #12]
 801f25c:	9f00      	ldr	r7, [sp, #0]
 801f25e:	3310      	adds	r3, #16
 801f260:	9312      	str	r3, [sp, #72]	; 0x48
          for (k = 0; k < K; k++) {
 801f262:	9b06      	ldr	r3, [sp, #24]
 801f264:	f104 0210 	add.w	r2, r4, #16
 801f268:	f106 0410 	add.w	r4, r6, #16
 801f26c:	9403      	str	r4, [sp, #12]
 801f26e:	4293      	cmp	r3, r2
 801f270:	f107 0410 	add.w	r4, r7, #16
            temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
 801f274:	ec41 0b1f 	vmov	d15, r0, r1
          for (k = 0; k < K; k++) {
 801f278:	9204      	str	r2, [sp, #16]
 801f27a:	9400      	str	r4, [sp, #0]
 801f27c:	f47f aef6 	bne.w	801f06c <cblas_zher2k+0xf9c>
          REAL(C, i * ldc + j) += temp_real;
 801f280:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 801f282:	ec53 2b1e 	vmov	r2, r3, d14
 801f286:	e9d4 0100 	ldrd	r0, r1, [r4]
 801f28a:	f008 fc57 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += temp_imag;
 801f28e:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(C, i * ldc + j) += temp_real;
 801f292:	e9c4 0100 	strd	r0, r1, [r4]
          IMAG(C, i * ldc + j) += temp_imag;
 801f296:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801f29a:	f008 fc4f 	bl	8027b3c <__adddf3>
 801f29e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801f2a0:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = 0; j < i; j++) {
 801f2a4:	9916      	ldr	r1, [sp, #88]	; 0x58
 801f2a6:	440a      	add	r2, r1
 801f2a8:	9214      	str	r2, [sp, #80]	; 0x50
 801f2aa:	9918      	ldr	r1, [sp, #96]	; 0x60
 801f2ac:	9a08      	ldr	r2, [sp, #32]
 801f2ae:	440a      	add	r2, r1
 801f2b0:	9208      	str	r2, [sp, #32]
 801f2b2:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801f2b4:	f104 0310 	add.w	r3, r4, #16
 801f2b8:	429a      	cmp	r2, r3
 801f2ba:	931c      	str	r3, [sp, #112]	; 0x70
 801f2bc:	f47f aeb8 	bne.w	801f030 <cblas_zher2k+0xf60>
 801f2c0:	9b24      	ldr	r3, [sp, #144]	; 0x90
 801f2c2:	9a20      	ldr	r2, [sp, #128]	; 0x80
 801f2c4:	4413      	add	r3, r2
 801f2c6:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 801f2c8:	9324      	str	r3, [sp, #144]	; 0x90
 801f2ca:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 801f2cc:	4611      	mov	r1, r2
 801f2ce:	4419      	add	r1, r3
 801f2d0:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 801f2d2:	911e      	str	r1, [sp, #120]	; 0x78
 801f2d4:	9928      	ldr	r1, [sp, #160]	; 0xa0
 801f2d6:	440a      	add	r2, r1
 801f2d8:	9906      	ldr	r1, [sp, #24]
 801f2da:	921f      	str	r2, [sp, #124]	; 0x7c
 801f2dc:	9a27      	ldr	r2, [sp, #156]	; 0x9c
 801f2de:	4608      	mov	r0, r1
 801f2e0:	4410      	add	r0, r2
 801f2e2:	9923      	ldr	r1, [sp, #140]	; 0x8c
 801f2e4:	9006      	str	r0, [sp, #24]
 801f2e6:	9818      	ldr	r0, [sp, #96]	; 0x60
 801f2e8:	4401      	add	r1, r0
 801f2ea:	9123      	str	r1, [sp, #140]	; 0x8c
 801f2ec:	991d      	ldr	r1, [sp, #116]	; 0x74
 801f2ee:	4411      	add	r1, r2
 801f2f0:	9a22      	ldr	r2, [sp, #136]	; 0x88
 801f2f2:	911d      	str	r1, [sp, #116]	; 0x74
 801f2f4:	441a      	add	r2, r3
 801f2f6:	9222      	str	r2, [sp, #136]	; 0x88
 801f2f8:	e611      	b.n	801ef1e <cblas_zher2k+0xe4e>
          for (k = 0; k < K; k++) {
 801f2fa:	2200      	movs	r2, #0
 801f2fc:	2300      	movs	r3, #0
 801f2fe:	e679      	b.n	801eff4 <cblas_zher2k+0xf24>

0801f300 <cblas_zherk>:
void
cblas_zherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const double alpha, const void *A, const int lda,
             const double beta, void *C, const int ldc)
{
 801f300:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f304:	ed2d 8b0c 	vpush	{d8-d13}
 801f308:	eeb0 da40 	vmov.f32	s26, s0
 801f30c:	eef0 da60 	vmov.f32	s27, s1
 801f310:	b093      	sub	sp, #76	; 0x4c
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 801f312:	2865      	cmp	r0, #101	; 0x65
 801f314:	9303      	str	r3, [sp, #12]
 801f316:	9b28      	ldr	r3, [sp, #160]	; 0xa0
 801f318:	9301      	str	r3, [sp, #4]
 801f31a:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 801f31c:	9304      	str	r3, [sp, #16]
 801f31e:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 801f320:	9306      	str	r3, [sp, #24]
 801f322:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 801f324:	930b      	str	r3, [sp, #44]	; 0x2c
 801f326:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 801f328:	9309      	str	r3, [sp, #36]	; 0x24
 801f32a:	ec5b ab11 	vmov	sl, fp, d1
 801f32e:	4604      	mov	r4, r0
 801f330:	460e      	mov	r6, r1
 801f332:	4615      	mov	r5, r2
 801f334:	f000 81af 	beq.w	801f696 <cblas_zherk+0x396>
 801f338:	2a6f      	cmp	r2, #111	; 0x6f
 801f33a:	d023      	beq.n	801f384 <cblas_zherk+0x84>
 801f33c:	9b01      	ldr	r3, [sp, #4]
 801f33e:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 801f342:	2a01      	cmp	r2, #1
 801f344:	f240 81a0 	bls.w	801f688 <cblas_zherk+0x388>
 801f348:	2002      	movs	r0, #2
 801f34a:	f1a5 026f 	sub.w	r2, r5, #111	; 0x6f
 801f34e:	2a02      	cmp	r2, #2
 801f350:	bf88      	it	hi
 801f352:	2003      	movhi	r0, #3
 801f354:	9a03      	ldr	r2, [sp, #12]
 801f356:	9901      	ldr	r1, [sp, #4]
 801f358:	2a00      	cmp	r2, #0
 801f35a:	bfb8      	it	lt
 801f35c:	2004      	movlt	r0, #4
 801f35e:	2b01      	cmp	r3, #1
 801f360:	bfb8      	it	lt
 801f362:	2301      	movlt	r3, #1
 801f364:	2900      	cmp	r1, #0
 801f366:	f2c0 8182 	blt.w	801f66e <cblas_zherk+0x36e>
 801f36a:	9a06      	ldr	r2, [sp, #24]
 801f36c:	4293      	cmp	r3, r2
 801f36e:	dc11      	bgt.n	801f394 <cblas_zherk+0x94>
 801f370:	9b03      	ldr	r3, [sp, #12]
 801f372:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f374:	2b01      	cmp	r3, #1
 801f376:	bfb8      	it	lt
 801f378:	2301      	movlt	r3, #1
 801f37a:	4293      	cmp	r3, r2
 801f37c:	f300 81ae 	bgt.w	801f6dc <cblas_zherk+0x3dc>
 801f380:	b1a8      	cbz	r0, 801f3ae <cblas_zherk+0xae>
 801f382:	e010      	b.n	801f3a6 <cblas_zherk+0xa6>
 801f384:	9b03      	ldr	r3, [sp, #12]
 801f386:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 801f38a:	2a01      	cmp	r2, #1
 801f38c:	f240 817c 	bls.w	801f688 <cblas_zherk+0x388>
 801f390:	2002      	movs	r0, #2
 801f392:	e7df      	b.n	801f354 <cblas_zherk+0x54>
 801f394:	9803      	ldr	r0, [sp, #12]
 801f396:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f398:	2801      	cmp	r0, #1
 801f39a:	bfb8      	it	lt
 801f39c:	2001      	movlt	r0, #1
 801f39e:	4283      	cmp	r3, r0
 801f3a0:	bfb4      	ite	lt
 801f3a2:	200b      	movlt	r0, #11
 801f3a4:	2008      	movge	r0, #8
 801f3a6:	4ac0      	ldr	r2, [pc, #768]	; (801f6a8 <cblas_zherk+0x3a8>)
 801f3a8:	49c0      	ldr	r1, [pc, #768]	; (801f6ac <cblas_zherk+0x3ac>)
 801f3aa:	f008 fb4d 	bl	8027a48 <cblas_xerbla>
  if (beta == 1.0 && (alpha == 0.0 || K == 0))
 801f3ae:	4bc0      	ldr	r3, [pc, #768]	; (801f6b0 <cblas_zherk+0x3b0>)
 801f3b0:	2200      	movs	r2, #0
 801f3b2:	4650      	mov	r0, sl
 801f3b4:	4659      	mov	r1, fp
 801f3b6:	f008 ffdf 	bl	8028378 <__aeabi_dcmpeq>
 801f3ba:	2800      	cmp	r0, #0
 801f3bc:	f000 810d 	beq.w	801f5da <cblas_zherk+0x2da>
 801f3c0:	ec51 0b1d 	vmov	r0, r1, d13
 801f3c4:	2200      	movs	r2, #0
 801f3c6:	2300      	movs	r3, #0
 801f3c8:	f008 ffd6 	bl	8028378 <__aeabi_dcmpeq>
 801f3cc:	2800      	cmp	r0, #0
 801f3ce:	f040 80ff 	bne.w	801f5d0 <cblas_zherk+0x2d0>
 801f3d2:	9b01      	ldr	r3, [sp, #4]
 801f3d4:	2b00      	cmp	r3, #0
 801f3d6:	f000 80fb 	beq.w	801f5d0 <cblas_zherk+0x2d0>
  if (Order == CblasRowMajor) {
 801f3da:	2c65      	cmp	r4, #101	; 0x65
 801f3dc:	f000 8180 	beq.w	801f6e0 <cblas_zherk+0x3e0>
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801f3e0:	2e79      	cmp	r6, #121	; 0x79
  if (beta == 0.0) {
 801f3e2:	f04f 0200 	mov.w	r2, #0
 801f3e6:	f04f 0300 	mov.w	r3, #0
 801f3ea:	4650      	mov	r0, sl
 801f3ec:	4659      	mov	r1, fp
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801f3ee:	f000 818b 	beq.w	801f708 <cblas_zherk+0x408>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801f3f2:	2d6f      	cmp	r5, #111	; 0x6f
 801f3f4:	f000 8272 	beq.w	801f8dc <cblas_zherk+0x5dc>
  if (beta == 0.0) {
 801f3f8:	f008 ffbe 	bl	8028378 <__aeabi_dcmpeq>
 801f3fc:	2800      	cmp	r0, #0
 801f3fe:	f000 815b 	beq.w	801f6b8 <cblas_zherk+0x3b8>
      for (i = 0; i < N; i++) {
 801f402:	9b03      	ldr	r3, [sp, #12]
 801f404:	2b00      	cmp	r3, #0
 801f406:	f340 80e3 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801f40a:	236f      	movs	r3, #111	; 0x6f
 801f40c:	9305      	str	r3, [sp, #20]
 801f40e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f410:	980b      	ldr	r0, [sp, #44]	; 0x2c
      for (i = 0; i < N; i++) {
 801f412:	9d03      	ldr	r5, [sp, #12]
 801f414:	1c5c      	adds	r4, r3, #1
          REAL(C, ldc * i + j) = 0.0;
 801f416:	2600      	movs	r6, #0
 801f418:	2700      	movs	r7, #0
 801f41a:	0124      	lsls	r4, r4, #4
      for (i = 0; i < N; i++) {
 801f41c:	2100      	movs	r1, #0
 801f41e:	4603      	mov	r3, r0
 801f420:	460a      	mov	r2, r1
        for (j = i; j < N; j++) {
 801f422:	3201      	adds	r2, #1
 801f424:	4295      	cmp	r5, r2
          REAL(C, ldc * i + j) = 0.0;
 801f426:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 801f42a:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = i; j < N; j++) {
 801f42e:	f103 0310 	add.w	r3, r3, #16
 801f432:	dcf6      	bgt.n	801f422 <cblas_zherk+0x122>
      for (i = 0; i < N; i++) {
 801f434:	3101      	adds	r1, #1
 801f436:	428d      	cmp	r5, r1
 801f438:	4420      	add	r0, r4
 801f43a:	dcf0      	bgt.n	801f41e <cblas_zherk+0x11e>
  if (alpha == 0.0)
 801f43c:	ec51 0b1d 	vmov	r0, r1, d13
 801f440:	2200      	movs	r2, #0
 801f442:	2300      	movs	r3, #0
 801f444:	f008 ff98 	bl	8028378 <__aeabi_dcmpeq>
 801f448:	2800      	cmp	r0, #0
 801f44a:	f040 80c1 	bne.w	801f5d0 <cblas_zherk+0x2d0>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 801f44e:	9b05      	ldr	r3, [sp, #20]
 801f450:	2b6f      	cmp	r3, #111	; 0x6f
 801f452:	f000 8263 	beq.w	801f91c <cblas_zherk+0x61c>
  } else if (uplo == CblasUpper && trans == CblasConjTrans) {
 801f456:	9b05      	ldr	r3, [sp, #20]
 801f458:	2b71      	cmp	r3, #113	; 0x71
 801f45a:	f040 80fe 	bne.w	801f65a <cblas_zherk+0x35a>
    for (i = 0; i < N; i++) {
 801f45e:	9b03      	ldr	r3, [sp, #12]
 801f460:	2b00      	cmp	r3, #0
 801f462:	f340 80b5 	ble.w	801f5d0 <cblas_zherk+0x2d0>
 801f466:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f468:	3301      	adds	r3, #1
 801f46a:	011b      	lsls	r3, r3, #4
 801f46c:	930c      	str	r3, [sp, #48]	; 0x30
 801f46e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f470:	930a      	str	r3, [sp, #40]	; 0x28
 801f472:	9b06      	ldr	r3, [sp, #24]
 801f474:	011b      	lsls	r3, r3, #4
 801f476:	9308      	str	r3, [sp, #32]
 801f478:	9b04      	ldr	r3, [sp, #16]
 801f47a:	3308      	adds	r3, #8
 801f47c:	9307      	str	r3, [sp, #28]
 801f47e:	2300      	movs	r3, #0
 801f480:	9309      	str	r3, [sp, #36]	; 0x24
        BASE temp_real = 0.0;
 801f482:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f484:	9306      	str	r3, [sp, #24]
 801f486:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f488:	9305      	str	r3, [sp, #20]
        BASE temp_imag = 0.0;
 801f48a:	ed9f 7b85 	vldr	d7, [pc, #532]	; 801f6a0 <cblas_zherk+0x3a0>
        for (k = 0; k < K; k++) {
 801f48e:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 801f490:	eeb0 ca47 	vmov.f32	s24, s14
 801f494:	eef0 ca67 	vmov.f32	s25, s15
        for (k = 0; k < K; k++) {
 801f498:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 801f49a:	eeb0 ba47 	vmov.f32	s22, s14
 801f49e:	eef0 ba67 	vmov.f32	s23, s15
        for (k = 0; k < K; k++) {
 801f4a2:	dd5c      	ble.n	801f55e <cblas_zherk+0x25e>
 801f4a4:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 801f4a8:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 801f4ac:	2300      	movs	r3, #0
 801f4ae:	461d      	mov	r5, r3
 801f4b0:	f8dd b01c 	ldr.w	fp, [sp, #28]
 801f4b4:	9b08      	ldr	r3, [sp, #32]
 801f4b6:	9302      	str	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 801f4b8:	ed1b 7b02 	vldr	d7, [fp, #-8]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 801f4bc:	e9da 8900 	ldrd	r8, r9, [sl]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 801f4c0:	eeb0 9a47 	vmov.f32	s18, s14
 801f4c4:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801f4c8:	ec51 0b17 	vmov	r0, r1, d7
 801f4cc:	4642      	mov	r2, r8
 801f4ce:	464b      	mov	r3, r9
 801f4d0:	f008 fcea 	bl	8027ea8 <__aeabi_dmul>
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801f4d4:	ed9a 8b02 	vldr	d8, [sl, #8]
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 801f4d8:	f8db 4004 	ldr.w	r4, [fp, #4]
 801f4dc:	f8db 6000 	ldr.w	r6, [fp]
 801f4e0:	f104 4700 	add.w	r7, r4, #2147483648	; 0x80000000
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801f4e4:	ec53 2b18 	vmov	r2, r3, d8
 801f4e8:	ec41 0b1a 	vmov	d10, r0, r1
 801f4ec:	4630      	mov	r0, r6
 801f4ee:	4639      	mov	r1, r7
 801f4f0:	f008 fcda 	bl	8027ea8 <__aeabi_dmul>
 801f4f4:	4602      	mov	r2, r0
 801f4f6:	460b      	mov	r3, r1
 801f4f8:	ec51 0b1a 	vmov	r0, r1, d10
 801f4fc:	f008 fb1c 	bl	8027b38 <__aeabi_dsub>
 801f500:	4602      	mov	r2, r0
 801f502:	460b      	mov	r3, r1
 801f504:	ec51 0b1b 	vmov	r0, r1, d11
 801f508:	f008 fb18 	bl	8027b3c <__adddf3>
 801f50c:	ec41 0b17 	vmov	d7, r0, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801f510:	ec53 2b18 	vmov	r2, r3, d8
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801f514:	eeb0 ba47 	vmov.f32	s22, s14
 801f518:	eef0 ba67 	vmov.f32	s23, s15
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801f51c:	ec51 0b19 	vmov	r0, r1, d9
 801f520:	f008 fcc2 	bl	8027ea8 <__aeabi_dmul>
 801f524:	4642      	mov	r2, r8
 801f526:	464b      	mov	r3, r9
 801f528:	4680      	mov	r8, r0
 801f52a:	4689      	mov	r9, r1
 801f52c:	4630      	mov	r0, r6
 801f52e:	4639      	mov	r1, r7
 801f530:	f008 fcba 	bl	8027ea8 <__aeabi_dmul>
 801f534:	4602      	mov	r2, r0
 801f536:	460b      	mov	r3, r1
 801f538:	4640      	mov	r0, r8
 801f53a:	4649      	mov	r1, r9
 801f53c:	f008 fafe 	bl	8027b3c <__adddf3>
 801f540:	460b      	mov	r3, r1
 801f542:	4602      	mov	r2, r0
 801f544:	ec51 0b1c 	vmov	r0, r1, d12
 801f548:	f008 faf8 	bl	8027b3c <__adddf3>
 801f54c:	9b02      	ldr	r3, [sp, #8]
 801f54e:	449b      	add	fp, r3
 801f550:	449a      	add	sl, r3
        for (k = 0; k < K; k++) {
 801f552:	9b01      	ldr	r3, [sp, #4]
 801f554:	3501      	adds	r5, #1
 801f556:	42ab      	cmp	r3, r5
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801f558:	ec41 0b1c 	vmov	d12, r0, r1
        for (k = 0; k < K; k++) {
 801f55c:	d1ac      	bne.n	801f4b8 <cblas_zherk+0x1b8>
        REAL(C, i * ldc + j) += alpha * temp_real;
 801f55e:	ec59 8b1d 	vmov	r8, r9, d13
 801f562:	ec53 2b1b 	vmov	r2, r3, d11
 801f566:	ee1d 0a10 	vmov	r0, s26
 801f56a:	4649      	mov	r1, r9
 801f56c:	f008 fc9c 	bl	8027ea8 <__aeabi_dmul>
 801f570:	9c06      	ldr	r4, [sp, #24]
 801f572:	4602      	mov	r2, r0
 801f574:	460b      	mov	r3, r1
 801f576:	e9d4 0100 	ldrd	r0, r1, [r4]
 801f57a:	f008 fadf 	bl	8027b3c <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801f57e:	ec53 2b1c 	vmov	r2, r3, d12
        REAL(C, i * ldc + j) += alpha * temp_real;
 801f582:	e9c4 0100 	strd	r0, r1, [r4]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801f586:	ee1d 0a10 	vmov	r0, s26
 801f58a:	4649      	mov	r1, r9
 801f58c:	f008 fc8c 	bl	8027ea8 <__aeabi_dmul>
 801f590:	4602      	mov	r2, r0
 801f592:	460b      	mov	r3, r1
 801f594:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801f598:	f008 fad0 	bl	8027b3c <__adddf3>
      for (j = i; j < N; j++) {
 801f59c:	9a05      	ldr	r2, [sp, #20]
 801f59e:	f104 0310 	add.w	r3, r4, #16
 801f5a2:	9306      	str	r3, [sp, #24]
 801f5a4:	9b03      	ldr	r3, [sp, #12]
 801f5a6:	3201      	adds	r2, #1
 801f5a8:	4293      	cmp	r3, r2
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801f5aa:	e9c4 0102 	strd	r0, r1, [r4, #8]
      for (j = i; j < N; j++) {
 801f5ae:	9205      	str	r2, [sp, #20]
 801f5b0:	f73f af6b 	bgt.w	801f48a <cblas_zherk+0x18a>
    for (i = 0; i < N; i++) {
 801f5b4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801f5b6:	990c      	ldr	r1, [sp, #48]	; 0x30
 801f5b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f5ba:	440a      	add	r2, r1
 801f5bc:	920a      	str	r2, [sp, #40]	; 0x28
 801f5be:	9a07      	ldr	r2, [sp, #28]
 801f5c0:	3210      	adds	r2, #16
 801f5c2:	9207      	str	r2, [sp, #28]
 801f5c4:	9a03      	ldr	r2, [sp, #12]
 801f5c6:	3301      	adds	r3, #1
 801f5c8:	429a      	cmp	r2, r3
 801f5ca:	9309      	str	r3, [sp, #36]	; 0x24
 801f5cc:	f47f af59 	bne.w	801f482 <cblas_zherk+0x182>
#define BASE double
#include "source_herk.h"
#undef BASE
}
 801f5d0:	b013      	add	sp, #76	; 0x4c
 801f5d2:	ecbd 8b0c 	vpop	{d8-d13}
 801f5d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (Order == CblasRowMajor) {
 801f5da:	2c65      	cmp	r4, #101	; 0x65
 801f5dc:	f47f af00 	bne.w	801f3e0 <cblas_zherk+0xe0>
  if (beta == 0.0) {
 801f5e0:	2200      	movs	r2, #0
 801f5e2:	2300      	movs	r3, #0
 801f5e4:	4650      	mov	r0, sl
 801f5e6:	4659      	mov	r1, fp
 801f5e8:	f008 fec6 	bl	8028378 <__aeabi_dcmpeq>
    uplo = Uplo;
 801f5ec:	9602      	str	r6, [sp, #8]
    trans = Trans;
 801f5ee:	9505      	str	r5, [sp, #20]
  if (beta == 0.0) {
 801f5f0:	2800      	cmp	r0, #0
 801f5f2:	f000 82bd 	beq.w	801fb70 <cblas_zherk+0x870>
    if (uplo == CblasUpper) {
 801f5f6:	9b02      	ldr	r3, [sp, #8]
 801f5f8:	2b79      	cmp	r3, #121	; 0x79
      for (i = 0; i < N; i++) {
 801f5fa:	9b03      	ldr	r3, [sp, #12]
    if (uplo == CblasUpper) {
 801f5fc:	f000 8412 	beq.w	801fe24 <cblas_zherk+0xb24>
      for (i = 0; i < N; i++) {
 801f600:	2b00      	cmp	r3, #0
 801f602:	f340 8092 	ble.w	801f72a <cblas_zherk+0x42a>
 801f606:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f608:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f60a:	9d03      	ldr	r5, [sp, #12]
 801f60c:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 801f610:	1c5c      	adds	r4, r3, #1
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801f612:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 801f614:	2600      	movs	r6, #0
 801f616:	2700      	movs	r7, #0
 801f618:	0124      	lsls	r4, r4, #4
      for (i = 0; i < N; i++) {
 801f61a:	4608      	mov	r0, r1
 801f61c:	3210      	adds	r2, #16
 801f61e:	469e      	mov	lr, r3
 801f620:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
          REAL(C, ldc * i + j) = 0.0;
 801f624:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 801f628:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j <= i; j++) {
 801f62c:	3310      	adds	r3, #16
 801f62e:	429a      	cmp	r2, r3
 801f630:	d1f8      	bne.n	801f624 <cblas_zherk+0x324>
      for (i = 0; i < N; i++) {
 801f632:	3001      	adds	r0, #1
 801f634:	4285      	cmp	r5, r0
 801f636:	4471      	add	r1, lr
 801f638:	4422      	add	r2, r4
 801f63a:	dcf1      	bgt.n	801f620 <cblas_zherk+0x320>
  if (alpha == 0.0)
 801f63c:	ec51 0b1d 	vmov	r0, r1, d13
 801f640:	2200      	movs	r2, #0
 801f642:	2300      	movs	r3, #0
 801f644:	f008 fe98 	bl	8028378 <__aeabi_dcmpeq>
 801f648:	2800      	cmp	r0, #0
 801f64a:	d1c1      	bne.n	801f5d0 <cblas_zherk+0x2d0>
  if (uplo == CblasUpper && trans == CblasNoTrans) {
 801f64c:	9b02      	ldr	r3, [sp, #8]
 801f64e:	2b79      	cmp	r3, #121	; 0x79
 801f650:	f43f aefd 	beq.w	801f44e <cblas_zherk+0x14e>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801f654:	9b02      	ldr	r3, [sp, #8]
 801f656:	2b7a      	cmp	r3, #122	; 0x7a
 801f658:	d070      	beq.n	801f73c <cblas_zherk+0x43c>
    BLAS_ERROR("unrecognized operation");
 801f65a:	4a16      	ldr	r2, [pc, #88]	; (801f6b4 <cblas_zherk+0x3b4>)
 801f65c:	4913      	ldr	r1, [pc, #76]	; (801f6ac <cblas_zherk+0x3ac>)
 801f65e:	2000      	movs	r0, #0
 801f660:	b013      	add	sp, #76	; 0x4c
 801f662:	ecbd 8b0c 	vpop	{d8-d13}
 801f666:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f66a:	f008 b9ed 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 801f66e:	9906      	ldr	r1, [sp, #24]
 801f670:	428b      	cmp	r3, r1
 801f672:	f73f ae8f 	bgt.w	801f394 <cblas_zherk+0x94>
 801f676:	2a01      	cmp	r2, #1
 801f678:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f67a:	bfb8      	it	lt
 801f67c:	2201      	movlt	r2, #1
 801f67e:	4293      	cmp	r3, r2
 801f680:	bfb4      	ite	lt
 801f682:	200b      	movlt	r0, #11
 801f684:	2005      	movge	r0, #5
 801f686:	e68e      	b.n	801f3a6 <cblas_zherk+0xa6>
 801f688:	f1a4 0065 	sub.w	r0, r4, #101	; 0x65
 801f68c:	2801      	cmp	r0, #1
 801f68e:	bf94      	ite	ls
 801f690:	2000      	movls	r0, #0
 801f692:	2001      	movhi	r0, #1
 801f694:	e659      	b.n	801f34a <cblas_zherk+0x4a>
 801f696:	2a6f      	cmp	r2, #111	; 0x6f
 801f698:	f000 811e 	beq.w	801f8d8 <cblas_zherk+0x5d8>
 801f69c:	9b03      	ldr	r3, [sp, #12]
 801f69e:	e64e      	b.n	801f33e <cblas_zherk+0x3e>
	...
 801f6a8:	08030378 	.word	0x08030378
 801f6ac:	08030740 	.word	0x08030740
 801f6b0:	3ff00000 	.word	0x3ff00000
 801f6b4:	080305a8 	.word	0x080305a8
  } else if (beta != 1.0) {
 801f6b8:	4b97      	ldr	r3, [pc, #604]	; (801f918 <cblas_zherk+0x618>)
 801f6ba:	2200      	movs	r2, #0
 801f6bc:	4650      	mov	r0, sl
 801f6be:	4659      	mov	r1, fp
 801f6c0:	f008 fe5a 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 801f6c4:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 801f6c6:	2800      	cmp	r0, #0
 801f6c8:	f000 8213 	beq.w	801faf2 <cblas_zherk+0x7f2>
    for (i = 0; i < N; i++) {
 801f6cc:	2b00      	cmp	r3, #0
 801f6ce:	f77f af7f 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801f6d2:	236f      	movs	r3, #111	; 0x6f
 801f6d4:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801f6d6:	2379      	movs	r3, #121	; 0x79
 801f6d8:	9302      	str	r3, [sp, #8]
 801f6da:	e006      	b.n	801f6ea <cblas_zherk+0x3ea>
  CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 801f6dc:	200b      	movs	r0, #11
 801f6de:	e662      	b.n	801f3a6 <cblas_zherk+0xa6>
    for (i = 0; i < N; i++) {
 801f6e0:	9b03      	ldr	r3, [sp, #12]
    uplo = Uplo;
 801f6e2:	9602      	str	r6, [sp, #8]
    for (i = 0; i < N; i++) {
 801f6e4:	2b00      	cmp	r3, #0
    trans = Trans;
 801f6e6:	9505      	str	r5, [sp, #20]
    for (i = 0; i < N; i++) {
 801f6e8:	dda8      	ble.n	801f63c <cblas_zherk+0x33c>
 801f6ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f6ec:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801f6ee:	9803      	ldr	r0, [sp, #12]
 801f6f0:	1c59      	adds	r1, r3, #1
      IMAG(C, ldc * i + i) = 0.0;
 801f6f2:	2400      	movs	r4, #0
 801f6f4:	2500      	movs	r5, #0
 801f6f6:	0109      	lsls	r1, r1, #4
    for (i = 0; i < N; i++) {
 801f6f8:	2300      	movs	r3, #0
 801f6fa:	3301      	adds	r3, #1
 801f6fc:	4298      	cmp	r0, r3
      IMAG(C, ldc * i + i) = 0.0;
 801f6fe:	e9c2 4502 	strd	r4, r5, [r2, #8]
    for (i = 0; i < N; i++) {
 801f702:	440a      	add	r2, r1
 801f704:	dcf9      	bgt.n	801f6fa <cblas_zherk+0x3fa>
 801f706:	e799      	b.n	801f63c <cblas_zherk+0x33c>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801f708:	2d6f      	cmp	r5, #111	; 0x6f
 801f70a:	f000 81e4 	beq.w	801fad6 <cblas_zherk+0x7d6>
  if (beta == 0.0) {
 801f70e:	f008 fe33 	bl	8028378 <__aeabi_dcmpeq>
 801f712:	2800      	cmp	r0, #0
 801f714:	f000 81cd 	beq.w	801fab2 <cblas_zherk+0x7b2>
      for (i = 0; i < N; i++) {
 801f718:	9b03      	ldr	r3, [sp, #12]
 801f71a:	2b00      	cmp	r3, #0
 801f71c:	f77f af58 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801f720:	236f      	movs	r3, #111	; 0x6f
 801f722:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801f724:	237a      	movs	r3, #122	; 0x7a
 801f726:	9302      	str	r3, [sp, #8]
 801f728:	e76d      	b.n	801f606 <cblas_zherk+0x306>
  if (alpha == 0.0)
 801f72a:	ec51 0b1d 	vmov	r0, r1, d13
 801f72e:	2200      	movs	r2, #0
 801f730:	2300      	movs	r3, #0
 801f732:	f008 fe21 	bl	8028378 <__aeabi_dcmpeq>
 801f736:	2800      	cmp	r0, #0
 801f738:	d08c      	beq.n	801f654 <cblas_zherk+0x354>
 801f73a:	e749      	b.n	801f5d0 <cblas_zherk+0x2d0>
  } else if (uplo == CblasLower && trans == CblasNoTrans) {
 801f73c:	9b05      	ldr	r3, [sp, #20]
 801f73e:	2b6f      	cmp	r3, #111	; 0x6f
 801f740:	f000 8288 	beq.w	801fc54 <cblas_zherk+0x954>
  } else if (uplo == CblasLower && trans == CblasConjTrans) {
 801f744:	9b05      	ldr	r3, [sp, #20]
 801f746:	2b71      	cmp	r3, #113	; 0x71
 801f748:	d187      	bne.n	801f65a <cblas_zherk+0x35a>
    for (i = 0; i < N; i++) {
 801f74a:	9b03      	ldr	r3, [sp, #12]
 801f74c:	2b00      	cmp	r3, #0
 801f74e:	f77f af3f 	ble.w	801f5d0 <cblas_zherk+0x2d0>
 801f752:	9b06      	ldr	r3, [sp, #24]
 801f754:	011b      	lsls	r3, r3, #4
 801f756:	930c      	str	r3, [sp, #48]	; 0x30
 801f758:	9b04      	ldr	r3, [sp, #16]
 801f75a:	3308      	adds	r3, #8
 801f75c:	930a      	str	r3, [sp, #40]	; 0x28
 801f75e:	2300      	movs	r3, #0
 801f760:	930e      	str	r3, [sp, #56]	; 0x38
 801f762:	2301      	movs	r3, #1
 801f764:	9308      	str	r3, [sp, #32]
 801f766:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f768:	3308      	adds	r3, #8
 801f76a:	930d      	str	r3, [sp, #52]	; 0x34
 801f76c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f76e:	4619      	mov	r1, r3
 801f770:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801f772:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 801f776:	9207      	str	r2, [sp, #28]
 801f778:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801f77a:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801f77e:	9306      	str	r3, [sp, #24]
      for (j = 0; j <= i; j++) {
 801f780:	2300      	movs	r3, #0
 801f782:	9305      	str	r3, [sp, #20]
        BASE temp_imag = 0.0;
 801f784:	ed9f 7b62 	vldr	d7, [pc, #392]	; 801f910 <cblas_zherk+0x610>
        for (k = 0; k < K; k++) {
 801f788:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 801f78a:	eeb0 ca47 	vmov.f32	s24, s14
 801f78e:	eef0 ca67 	vmov.f32	s25, s15
        for (k = 0; k < K; k++) {
 801f792:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 801f794:	eeb0 ba47 	vmov.f32	s22, s14
 801f798:	eef0 ba67 	vmov.f32	s23, s15
        for (k = 0; k < K; k++) {
 801f79c:	dd5c      	ble.n	801f858 <cblas_zherk+0x558>
 801f79e:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 801f7a2:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 801f7a6:	2300      	movs	r3, #0
 801f7a8:	461d      	mov	r5, r3
 801f7aa:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 801f7ae:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f7b0:	9302      	str	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 801f7b2:	ed1b 7b02 	vldr	d7, [fp, #-8]
          const BASE Akj_real = CONST_REAL(A, k * lda + j);
 801f7b6:	e9da 8900 	ldrd	r8, r9, [sl]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 801f7ba:	eeb0 9a47 	vmov.f32	s18, s14
 801f7be:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801f7c2:	ec51 0b17 	vmov	r0, r1, d7
 801f7c6:	4642      	mov	r2, r8
 801f7c8:	464b      	mov	r3, r9
 801f7ca:	f008 fb6d 	bl	8027ea8 <__aeabi_dmul>
          const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 801f7ce:	ed9a 8b02 	vldr	d8, [sl, #8]
          const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
 801f7d2:	f8db 4004 	ldr.w	r4, [fp, #4]
 801f7d6:	f8db 6000 	ldr.w	r6, [fp]
 801f7da:	f104 4700 	add.w	r7, r4, #2147483648	; 0x80000000
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801f7de:	ec53 2b18 	vmov	r2, r3, d8
 801f7e2:	ec41 0b1a 	vmov	d10, r0, r1
 801f7e6:	4630      	mov	r0, r6
 801f7e8:	4639      	mov	r1, r7
 801f7ea:	f008 fb5d 	bl	8027ea8 <__aeabi_dmul>
 801f7ee:	4602      	mov	r2, r0
 801f7f0:	460b      	mov	r3, r1
 801f7f2:	ec51 0b1a 	vmov	r0, r1, d10
 801f7f6:	f008 f99f 	bl	8027b38 <__aeabi_dsub>
 801f7fa:	4602      	mov	r2, r0
 801f7fc:	460b      	mov	r3, r1
 801f7fe:	ec51 0b1b 	vmov	r0, r1, d11
 801f802:	f008 f99b 	bl	8027b3c <__adddf3>
 801f806:	ec41 0b17 	vmov	d7, r0, r1
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801f80a:	ec53 2b18 	vmov	r2, r3, d8
          temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 801f80e:	eeb0 ba47 	vmov.f32	s22, s14
 801f812:	eef0 ba67 	vmov.f32	s23, s15
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801f816:	ec51 0b19 	vmov	r0, r1, d9
 801f81a:	f008 fb45 	bl	8027ea8 <__aeabi_dmul>
 801f81e:	4642      	mov	r2, r8
 801f820:	464b      	mov	r3, r9
 801f822:	4680      	mov	r8, r0
 801f824:	4689      	mov	r9, r1
 801f826:	4630      	mov	r0, r6
 801f828:	4639      	mov	r1, r7
 801f82a:	f008 fb3d 	bl	8027ea8 <__aeabi_dmul>
 801f82e:	4602      	mov	r2, r0
 801f830:	460b      	mov	r3, r1
 801f832:	4640      	mov	r0, r8
 801f834:	4649      	mov	r1, r9
 801f836:	f008 f981 	bl	8027b3c <__adddf3>
 801f83a:	460b      	mov	r3, r1
 801f83c:	4602      	mov	r2, r0
 801f83e:	ec51 0b1c 	vmov	r0, r1, d12
 801f842:	f008 f97b 	bl	8027b3c <__adddf3>
 801f846:	9b02      	ldr	r3, [sp, #8]
 801f848:	449b      	add	fp, r3
 801f84a:	449a      	add	sl, r3
        for (k = 0; k < K; k++) {
 801f84c:	9b01      	ldr	r3, [sp, #4]
 801f84e:	3501      	adds	r5, #1
 801f850:	42ab      	cmp	r3, r5
          temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 801f852:	ec41 0b1c 	vmov	d12, r0, r1
        for (k = 0; k < K; k++) {
 801f856:	d1ac      	bne.n	801f7b2 <cblas_zherk+0x4b2>
        REAL(C, i * ldc + j) += alpha * temp_real;
 801f858:	ec59 8b1d 	vmov	r8, r9, d13
 801f85c:	ec53 2b1b 	vmov	r2, r3, d11
 801f860:	ee1d 0a10 	vmov	r0, s26
 801f864:	4649      	mov	r1, r9
 801f866:	f008 fb1f 	bl	8027ea8 <__aeabi_dmul>
 801f86a:	9c06      	ldr	r4, [sp, #24]
 801f86c:	4602      	mov	r2, r0
 801f86e:	460b      	mov	r3, r1
 801f870:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801f874:	f008 f962 	bl	8027b3c <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801f878:	ec53 2b1c 	vmov	r2, r3, d12
        REAL(C, i * ldc + j) += alpha * temp_real;
 801f87c:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801f880:	ee1d 0a10 	vmov	r0, s26
 801f884:	4649      	mov	r1, r9
 801f886:	f008 fb0f 	bl	8027ea8 <__aeabi_dmul>
 801f88a:	9d07      	ldr	r5, [sp, #28]
 801f88c:	4602      	mov	r2, r0
 801f88e:	460b      	mov	r3, r1
 801f890:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 801f894:	f008 f952 	bl	8027b3c <__adddf3>
 801f898:	f104 0310 	add.w	r3, r4, #16
      for (j = 0; j <= i; j++) {
 801f89c:	9a05      	ldr	r2, [sp, #20]
 801f89e:	9306      	str	r3, [sp, #24]
 801f8a0:	f105 0310 	add.w	r3, r5, #16
 801f8a4:	9307      	str	r3, [sp, #28]
 801f8a6:	9b08      	ldr	r3, [sp, #32]
 801f8a8:	3201      	adds	r2, #1
 801f8aa:	429a      	cmp	r2, r3
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801f8ac:	e9c5 0102 	strd	r0, r1, [r5, #8]
      for (j = 0; j <= i; j++) {
 801f8b0:	9205      	str	r2, [sp, #20]
 801f8b2:	f47f af67 	bne.w	801f784 <cblas_zherk+0x484>
    for (i = 0; i < N; i++) {
 801f8b6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801f8b8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801f8ba:	9903      	ldr	r1, [sp, #12]
 801f8bc:	4413      	add	r3, r2
 801f8be:	930e      	str	r3, [sp, #56]	; 0x38
 801f8c0:	9a08      	ldr	r2, [sp, #32]
 801f8c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f8c4:	4291      	cmp	r1, r2
 801f8c6:	f103 0310 	add.w	r3, r3, #16
 801f8ca:	930a      	str	r3, [sp, #40]	; 0x28
 801f8cc:	f102 0301 	add.w	r3, r2, #1
 801f8d0:	f43f ae7e 	beq.w	801f5d0 <cblas_zherk+0x2d0>
 801f8d4:	9308      	str	r3, [sp, #32]
 801f8d6:	e749      	b.n	801f76c <cblas_zherk+0x46c>
 801f8d8:	9b01      	ldr	r3, [sp, #4]
 801f8da:	e554      	b.n	801f386 <cblas_zherk+0x86>
  if (beta == 0.0) {
 801f8dc:	f008 fd4c 	bl	8028378 <__aeabi_dcmpeq>
 801f8e0:	2800      	cmp	r0, #0
 801f8e2:	f040 8290 	bne.w	801fe06 <cblas_zherk+0xb06>
  } else if (beta != 1.0) {
 801f8e6:	4b0c      	ldr	r3, [pc, #48]	; (801f918 <cblas_zherk+0x618>)
 801f8e8:	2200      	movs	r2, #0
 801f8ea:	4650      	mov	r0, sl
 801f8ec:	4659      	mov	r1, fp
 801f8ee:	f008 fd43 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 801f8f2:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 801f8f4:	2800      	cmp	r0, #0
 801f8f6:	f000 8180 	beq.w	801fbfa <cblas_zherk+0x8fa>
    for (i = 0; i < N; i++) {
 801f8fa:	2b00      	cmp	r3, #0
 801f8fc:	f77f ae68 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801f900:	2371      	movs	r3, #113	; 0x71
 801f902:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801f904:	2379      	movs	r3, #121	; 0x79
 801f906:	9302      	str	r3, [sp, #8]
 801f908:	e6ef      	b.n	801f6ea <cblas_zherk+0x3ea>
 801f90a:	bf00      	nop
 801f90c:	f3af 8000 	nop.w
	...
 801f918:	3ff00000 	.word	0x3ff00000
    for (i = 0; i < N; i++) {
 801f91c:	9b03      	ldr	r3, [sp, #12]
 801f91e:	2b00      	cmp	r3, #0
 801f920:	f77f ae56 	ble.w	801f5d0 <cblas_zherk+0x2d0>
 801f924:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801f926:	9901      	ldr	r1, [sp, #4]
 801f928:	3301      	adds	r3, #1
 801f92a:	011b      	lsls	r3, r3, #4
 801f92c:	930e      	str	r3, [sp, #56]	; 0x38
 801f92e:	9b06      	ldr	r3, [sp, #24]
 801f930:	011b      	lsls	r3, r3, #4
 801f932:	930d      	str	r3, [sp, #52]	; 0x34
 801f934:	9b04      	ldr	r3, [sp, #16]
 801f936:	9309      	str	r3, [sp, #36]	; 0x24
 801f938:	2200      	movs	r2, #0
 801f93a:	920c      	str	r2, [sp, #48]	; 0x30
 801f93c:	920a      	str	r2, [sp, #40]	; 0x28
 801f93e:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 801f942:	9202      	str	r2, [sp, #8]
        BASE temp_real = 0.0;
 801f944:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801f946:	9305      	str	r3, [sp, #20]
 801f948:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801f94a:	9308      	str	r3, [sp, #32]
 801f94c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801f94e:	9307      	str	r3, [sp, #28]
        BASE temp_imag = 0.0;
 801f950:	ed9f 7bbd 	vldr	d7, [pc, #756]	; 801fc48 <cblas_zherk+0x948>
        for (k = 0; k < K; k++) {
 801f954:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 801f956:	eeb0 aa47 	vmov.f32	s20, s14
 801f95a:	eef0 aa67 	vmov.f32	s21, s15
        for (k = 0; k < K; k++) {
 801f95e:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 801f960:	ec57 6b17 	vmov	r6, r7, d7
        for (k = 0; k < K; k++) {
 801f964:	dd5e      	ble.n	801fa24 <cblas_zherk+0x724>
 801f966:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 801f96a:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 801f96e:	ec47 6b1b 	vmov	d11, r6, r7
 801f972:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f976:	ed9a 7b00 	vldr	d7, [sl]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801f97a:	ed9b 6b00 	vldr	d6, [fp]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801f97e:	eeb0 9a47 	vmov.f32	s18, s14
 801f982:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801f986:	ec53 2b16 	vmov	r2, r3, d6
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801f98a:	eeb0 8a46 	vmov.f32	s16, s12
 801f98e:	eef0 8a66 	vmov.f32	s17, s13
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801f992:	ec51 0b17 	vmov	r0, r1, d7
 801f996:	f008 fa87 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801f99a:	e9da 4502 	ldrd	r4, r5, [sl, #8]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 801f99e:	f8db 600c 	ldr.w	r6, [fp, #12]
 801f9a2:	f8db 8008 	ldr.w	r8, [fp, #8]
 801f9a6:	f106 4900 	add.w	r9, r6, #2147483648	; 0x80000000
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801f9aa:	460f      	mov	r7, r1
 801f9ac:	4606      	mov	r6, r0
 801f9ae:	4642      	mov	r2, r8
 801f9b0:	464b      	mov	r3, r9
 801f9b2:	4620      	mov	r0, r4
 801f9b4:	4629      	mov	r1, r5
 801f9b6:	f008 fa77 	bl	8027ea8 <__aeabi_dmul>
 801f9ba:	4602      	mov	r2, r0
 801f9bc:	460b      	mov	r3, r1
 801f9be:	4630      	mov	r0, r6
 801f9c0:	4639      	mov	r1, r7
 801f9c2:	f008 f8b9 	bl	8027b38 <__aeabi_dsub>
 801f9c6:	4602      	mov	r2, r0
 801f9c8:	460b      	mov	r3, r1
 801f9ca:	ec51 0b1b 	vmov	r0, r1, d11
 801f9ce:	f008 f8b5 	bl	8027b3c <__adddf3>
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801f9d2:	4642      	mov	r2, r8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801f9d4:	4606      	mov	r6, r0
 801f9d6:	460f      	mov	r7, r1
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801f9d8:	464b      	mov	r3, r9
 801f9da:	ec51 0b19 	vmov	r0, r1, d9
 801f9de:	f008 fa63 	bl	8027ea8 <__aeabi_dmul>
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801f9e2:	ec47 6b1b 	vmov	d11, r6, r7
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801f9e6:	ec53 2b18 	vmov	r2, r3, d8
 801f9ea:	4606      	mov	r6, r0
 801f9ec:	460f      	mov	r7, r1
 801f9ee:	4620      	mov	r0, r4
 801f9f0:	4629      	mov	r1, r5
 801f9f2:	f008 fa59 	bl	8027ea8 <__aeabi_dmul>
 801f9f6:	4602      	mov	r2, r0
 801f9f8:	460b      	mov	r3, r1
 801f9fa:	4630      	mov	r0, r6
 801f9fc:	4639      	mov	r1, r7
 801f9fe:	f008 f89d 	bl	8027b3c <__adddf3>
 801fa02:	460b      	mov	r3, r1
 801fa04:	4602      	mov	r2, r0
 801fa06:	ec51 0b1a 	vmov	r0, r1, d10
 801fa0a:	f008 f897 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 801fa0e:	9b02      	ldr	r3, [sp, #8]
 801fa10:	f10a 0a10 	add.w	sl, sl, #16
 801fa14:	4553      	cmp	r3, sl
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801fa16:	ec41 0b1a 	vmov	d10, r0, r1
        for (k = 0; k < K; k++) {
 801fa1a:	f10b 0b10 	add.w	fp, fp, #16
 801fa1e:	d1aa      	bne.n	801f976 <cblas_zherk+0x676>
 801fa20:	ec57 6b1b 	vmov	r6, r7, d11
        REAL(C, i * ldc + j) += alpha * temp_real;
 801fa24:	4630      	mov	r0, r6
 801fa26:	4639      	mov	r1, r7
 801fa28:	ec57 6b1d 	vmov	r6, r7, d13
 801fa2c:	ee1d 2a10 	vmov	r2, s26
 801fa30:	463b      	mov	r3, r7
 801fa32:	f008 fa39 	bl	8027ea8 <__aeabi_dmul>
 801fa36:	9c08      	ldr	r4, [sp, #32]
 801fa38:	4602      	mov	r2, r0
 801fa3a:	460b      	mov	r3, r1
 801fa3c:	e9d4 0100 	ldrd	r0, r1, [r4]
 801fa40:	f008 f87c 	bl	8027b3c <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801fa44:	ec53 2b1a 	vmov	r2, r3, d10
        REAL(C, i * ldc + j) += alpha * temp_real;
 801fa48:	e9c4 0100 	strd	r0, r1, [r4]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801fa4c:	ee1d 0a10 	vmov	r0, s26
 801fa50:	4639      	mov	r1, r7
 801fa52:	f008 fa29 	bl	8027ea8 <__aeabi_dmul>
 801fa56:	4602      	mov	r2, r0
 801fa58:	460b      	mov	r3, r1
 801fa5a:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801fa5e:	f008 f86d 	bl	8027b3c <__adddf3>
 801fa62:	e9dd 3505 	ldrd	r3, r5, [sp, #20]
 801fa66:	442b      	add	r3, r5
      for (j = i; j < N; j++) {
 801fa68:	9a07      	ldr	r2, [sp, #28]
 801fa6a:	9305      	str	r3, [sp, #20]
 801fa6c:	f104 0310 	add.w	r3, r4, #16
 801fa70:	9308      	str	r3, [sp, #32]
 801fa72:	9b03      	ldr	r3, [sp, #12]
 801fa74:	3201      	adds	r2, #1
 801fa76:	4293      	cmp	r3, r2
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801fa78:	e9c4 0102 	strd	r0, r1, [r4, #8]
      for (j = i; j < N; j++) {
 801fa7c:	9207      	str	r2, [sp, #28]
 801fa7e:	f73f af67 	bgt.w	801f950 <cblas_zherk+0x650>
    for (i = 0; i < N; i++) {
 801fa82:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801fa84:	990e      	ldr	r1, [sp, #56]	; 0x38
 801fa86:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801fa88:	440a      	add	r2, r1
 801fa8a:	920b      	str	r2, [sp, #44]	; 0x2c
 801fa8c:	9906      	ldr	r1, [sp, #24]
 801fa8e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801fa90:	440a      	add	r2, r1
 801fa92:	9909      	ldr	r1, [sp, #36]	; 0x24
 801fa94:	920c      	str	r2, [sp, #48]	; 0x30
 801fa96:	4608      	mov	r0, r1
 801fa98:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801fa9a:	9902      	ldr	r1, [sp, #8]
 801fa9c:	4410      	add	r0, r2
 801fa9e:	4411      	add	r1, r2
 801faa0:	9a03      	ldr	r2, [sp, #12]
 801faa2:	9009      	str	r0, [sp, #36]	; 0x24
 801faa4:	3301      	adds	r3, #1
 801faa6:	429a      	cmp	r2, r3
 801faa8:	930a      	str	r3, [sp, #40]	; 0x28
 801faaa:	9102      	str	r1, [sp, #8]
 801faac:	f47f af4a 	bne.w	801f944 <cblas_zherk+0x644>
 801fab0:	e58e      	b.n	801f5d0 <cblas_zherk+0x2d0>
  } else if (beta != 1.0) {
 801fab2:	4b67      	ldr	r3, [pc, #412]	; (801fc50 <cblas_zherk+0x950>)
 801fab4:	2200      	movs	r2, #0
 801fab6:	4650      	mov	r0, sl
 801fab8:	4659      	mov	r1, fp
 801faba:	f008 fc5d 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 801fabe:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 801fac0:	2800      	cmp	r0, #0
 801fac2:	f040 80b2 	bne.w	801fc2a <cblas_zherk+0x92a>
      for (i = 0; i < N; i++) {
 801fac6:	2b00      	cmp	r3, #0
 801fac8:	f77f ad82 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801facc:	236f      	movs	r3, #111	; 0x6f
 801face:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801fad0:	237a      	movs	r3, #122	; 0x7a
 801fad2:	9302      	str	r3, [sp, #8]
 801fad4:	e053      	b.n	801fb7e <cblas_zherk+0x87e>
  if (beta == 0.0) {
 801fad6:	f008 fc4f 	bl	8028378 <__aeabi_dcmpeq>
 801fada:	2800      	cmp	r0, #0
 801fadc:	f000 8093 	beq.w	801fc06 <cblas_zherk+0x906>
      for (i = 0; i < N; i++) {
 801fae0:	9b03      	ldr	r3, [sp, #12]
 801fae2:	2b00      	cmp	r3, #0
 801fae4:	f77f ad74 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801fae8:	2371      	movs	r3, #113	; 0x71
 801faea:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801faec:	237a      	movs	r3, #122	; 0x7a
 801faee:	9302      	str	r3, [sp, #8]
 801faf0:	e589      	b.n	801f606 <cblas_zherk+0x306>
      for (i = 0; i < N; i++) {
 801faf2:	2b00      	cmp	r3, #0
 801faf4:	f77f ad6c 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801faf8:	236f      	movs	r3, #111	; 0x6f
 801fafa:	9305      	str	r3, [sp, #20]
 801fafc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801fafe:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 801fb00:	011b      	lsls	r3, r3, #4
 801fb02:	f103 0610 	add.w	r6, r3, #16
 801fb06:	9302      	str	r3, [sp, #8]
 801fb08:	9b03      	ldr	r3, [sp, #12]
 801fb0a:	f1a2 0510 	sub.w	r5, r2, #16
        IMAG(C, ldc * i + i) = 0;
 801fb0e:	ed9f 8b4e 	vldr	d8, [pc, #312]	; 801fc48 <cblas_zherk+0x948>
 801fb12:	eb05 1503 	add.w	r5, r5, r3, lsl #4
      for (i = 0; i < N; i++) {
 801fb16:	2300      	movs	r3, #0
 801fb18:	46b1      	mov	r9, r6
 801fb1a:	f102 0708 	add.w	r7, r2, #8
 801fb1e:	461e      	mov	r6, r3
        REAL(C, ldc * i + i) *= beta;
 801fb20:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 801fb24:	465b      	mov	r3, fp
 801fb26:	4652      	mov	r2, sl
 801fb28:	f008 f9be 	bl	8027ea8 <__aeabi_dmul>
        for (j = i + 1; j < N; j++) {
 801fb2c:	9b03      	ldr	r3, [sp, #12]
 801fb2e:	3601      	adds	r6, #1
 801fb30:	42b3      	cmp	r3, r6
        REAL(C, ldc * i + i) *= beta;
 801fb32:	e947 0102 	strd	r0, r1, [r7, #-8]
        IMAG(C, ldc * i + i) = 0;
 801fb36:	ed87 8b00 	vstr	d8, [r7]
        for (j = i + 1; j < N; j++) {
 801fb3a:	f77f ac7f 	ble.w	801f43c <cblas_zherk+0x13c>
 801fb3e:	f1a7 0408 	sub.w	r4, r7, #8
          REAL(C, ldc * i + j) *= beta;
 801fb42:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
 801fb46:	4652      	mov	r2, sl
 801fb48:	465b      	mov	r3, fp
 801fb4a:	f008 f9ad 	bl	8027ea8 <__aeabi_dmul>
          IMAG(C, ldc * i + j) *= beta;
 801fb4e:	4652      	mov	r2, sl
          REAL(C, ldc * i + j) *= beta;
 801fb50:	e9c4 0104 	strd	r0, r1, [r4, #16]
          IMAG(C, ldc * i + j) *= beta;
 801fb54:	465b      	mov	r3, fp
 801fb56:	e9d4 0106 	ldrd	r0, r1, [r4, #24]
 801fb5a:	f008 f9a5 	bl	8027ea8 <__aeabi_dmul>
 801fb5e:	3410      	adds	r4, #16
 801fb60:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = i + 1; j < N; j++) {
 801fb64:	42a5      	cmp	r5, r4
 801fb66:	d1ec      	bne.n	801fb42 <cblas_zherk+0x842>
 801fb68:	9b02      	ldr	r3, [sp, #8]
 801fb6a:	444f      	add	r7, r9
 801fb6c:	441d      	add	r5, r3
 801fb6e:	e7d7      	b.n	801fb20 <cblas_zherk+0x820>
    if (uplo == CblasUpper) {
 801fb70:	9b02      	ldr	r3, [sp, #8]
 801fb72:	2b79      	cmp	r3, #121	; 0x79
 801fb74:	d061      	beq.n	801fc3a <cblas_zherk+0x93a>
      for (i = 0; i < N; i++) {
 801fb76:	9b03      	ldr	r3, [sp, #12]
 801fb78:	2b00      	cmp	r3, #0
 801fb7a:	f77f add6 	ble.w	801f72a <cblas_zherk+0x42a>
        for (j = 0; j < i; j++) {
 801fb7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 801fb80:	990b      	ldr	r1, [sp, #44]	; 0x2c
 801fb82:	1c53      	adds	r3, r2, #1
        IMAG(C, ldc * i + i) = 0;
 801fb84:	ed9f 8b30 	vldr	d8, [pc, #192]	; 801fc48 <cblas_zherk+0x948>
 801fb88:	f101 0708 	add.w	r7, r1, #8
 801fb8c:	0118      	lsls	r0, r3, #4
 801fb8e:	970d      	str	r7, [sp, #52]	; 0x34
 801fb90:	9007      	str	r0, [sp, #28]
 801fb92:	eb01 1903 	add.w	r9, r1, r3, lsl #4
      for (i = 0; i < N; i++) {
 801fb96:	4690      	mov	r8, r2
      for (i = 0; i < N; i++) {
 801fb98:	2600      	movs	r6, #0
        REAL(C, ldc * i + i) *= beta;
 801fb9a:	e957 0102 	ldrd	r0, r1, [r7, #-8]
 801fb9e:	465b      	mov	r3, fp
 801fba0:	4652      	mov	r2, sl
 801fba2:	f008 f981 	bl	8027ea8 <__aeabi_dmul>
      for (i = 0; i < N; i++) {
 801fba6:	9b03      	ldr	r3, [sp, #12]
 801fba8:	3601      	adds	r6, #1
 801fbaa:	42b3      	cmp	r3, r6
        REAL(C, ldc * i + i) *= beta;
 801fbac:	e947 0102 	strd	r0, r1, [r7, #-8]
        IMAG(C, ldc * i + i) = 0;
 801fbb0:	ed87 8b00 	vstr	d8, [r7]
      for (i = 0; i < N; i++) {
 801fbb4:	f77f adb9 	ble.w	801f72a <cblas_zherk+0x42a>
        for (j = 0; j < i; j++) {
 801fbb8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801fbba:	eb03 1408 	add.w	r4, r3, r8, lsl #4
 801fbbe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 801fbc0:	eb03 1508 	add.w	r5, r3, r8, lsl #4
          REAL(C, ldc * i + j) *= beta;
 801fbc4:	e955 0102 	ldrd	r0, r1, [r5, #-8]
 801fbc8:	4652      	mov	r2, sl
 801fbca:	465b      	mov	r3, fp
 801fbcc:	f008 f96c 	bl	8027ea8 <__aeabi_dmul>
 801fbd0:	e945 0102 	strd	r0, r1, [r5, #-8]
          IMAG(C, ldc * i + j) *= beta;
 801fbd4:	4652      	mov	r2, sl
 801fbd6:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 801fbda:	465b      	mov	r3, fp
 801fbdc:	f008 f964 	bl	8027ea8 <__aeabi_dmul>
 801fbe0:	3410      	adds	r4, #16
 801fbe2:	e944 0102 	strd	r0, r1, [r4, #-8]
        for (j = 0; j < i; j++) {
 801fbe6:	45a1      	cmp	r9, r4
 801fbe8:	f105 0510 	add.w	r5, r5, #16
 801fbec:	d1ea      	bne.n	801fbc4 <cblas_zherk+0x8c4>
 801fbee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801fbf0:	4498      	add	r8, r3
 801fbf2:	9b07      	ldr	r3, [sp, #28]
 801fbf4:	4499      	add	r9, r3
 801fbf6:	441f      	add	r7, r3
 801fbf8:	e7cf      	b.n	801fb9a <cblas_zherk+0x89a>
      for (i = 0; i < N; i++) {
 801fbfa:	2b00      	cmp	r3, #0
 801fbfc:	f77f ace8 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801fc00:	2371      	movs	r3, #113	; 0x71
 801fc02:	9305      	str	r3, [sp, #20]
 801fc04:	e77a      	b.n	801fafc <cblas_zherk+0x7fc>
  } else if (beta != 1.0) {
 801fc06:	4b12      	ldr	r3, [pc, #72]	; (801fc50 <cblas_zherk+0x950>)
 801fc08:	2200      	movs	r2, #0
 801fc0a:	4650      	mov	r0, sl
 801fc0c:	4659      	mov	r1, fp
 801fc0e:	f008 fbb3 	bl	8028378 <__aeabi_dcmpeq>
      for (i = 0; i < N; i++) {
 801fc12:	9b03      	ldr	r3, [sp, #12]
  } else if (beta != 1.0) {
 801fc14:	2800      	cmp	r0, #0
 801fc16:	f040 80fe 	bne.w	801fe16 <cblas_zherk+0xb16>
      for (i = 0; i < N; i++) {
 801fc1a:	2b00      	cmp	r3, #0
 801fc1c:	f77f acd8 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801fc20:	2371      	movs	r3, #113	; 0x71
 801fc22:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801fc24:	237a      	movs	r3, #122	; 0x7a
 801fc26:	9302      	str	r3, [sp, #8]
 801fc28:	e7a9      	b.n	801fb7e <cblas_zherk+0x87e>
    for (i = 0; i < N; i++) {
 801fc2a:	2b00      	cmp	r3, #0
 801fc2c:	f77f acd0 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801fc30:	236f      	movs	r3, #111	; 0x6f
 801fc32:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801fc34:	237a      	movs	r3, #122	; 0x7a
 801fc36:	9302      	str	r3, [sp, #8]
 801fc38:	e557      	b.n	801f6ea <cblas_zherk+0x3ea>
      for (i = 0; i < N; i++) {
 801fc3a:	9b03      	ldr	r3, [sp, #12]
 801fc3c:	2b00      	cmp	r3, #0
 801fc3e:	f73f af5d 	bgt.w	801fafc <cblas_zherk+0x7fc>
 801fc42:	f7ff bbfb 	b.w	801f43c <cblas_zherk+0x13c>
 801fc46:	bf00      	nop
	...
 801fc50:	3ff00000 	.word	0x3ff00000
    for (i = 0; i < N; i++) {
 801fc54:	9b03      	ldr	r3, [sp, #12]
 801fc56:	2b00      	cmp	r3, #0
 801fc58:	f77f acba 	ble.w	801f5d0 <cblas_zherk+0x2d0>
 801fc5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801fc5e:	9801      	ldr	r0, [sp, #4]
 801fc60:	3301      	adds	r3, #1
 801fc62:	011b      	lsls	r3, r3, #4
 801fc64:	9311      	str	r3, [sp, #68]	; 0x44
 801fc66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801fc68:	2200      	movs	r2, #0
 801fc6a:	920e      	str	r2, [sp, #56]	; 0x38
 801fc6c:	920f      	str	r2, [sp, #60]	; 0x3c
 801fc6e:	f103 0210 	add.w	r2, r3, #16
 801fc72:	920a      	str	r2, [sp, #40]	; 0x28
 801fc74:	9a06      	ldr	r2, [sp, #24]
 801fc76:	0112      	lsls	r2, r2, #4
 801fc78:	9210      	str	r2, [sp, #64]	; 0x40
 801fc7a:	9a04      	ldr	r2, [sp, #16]
 801fc7c:	920c      	str	r2, [sp, #48]	; 0x30
 801fc7e:	eb02 1100 	add.w	r1, r2, r0, lsl #4
 801fc82:	3308      	adds	r3, #8
 801fc84:	9102      	str	r1, [sp, #8]
 801fc86:	930d      	str	r3, [sp, #52]	; 0x34
 801fc88:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801fc8a:	4619      	mov	r1, r3
 801fc8c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801fc8e:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 801fc92:	9208      	str	r2, [sp, #32]
 801fc94:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 801fc96:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 801fc9a:	9307      	str	r3, [sp, #28]
        BASE temp_real = 0.0;
 801fc9c:	2300      	movs	r3, #0
 801fc9e:	9305      	str	r3, [sp, #20]
        BASE temp_imag = 0.0;
 801fca0:	ed9f 7b69 	vldr	d7, [pc, #420]	; 801fe48 <cblas_zherk+0xb48>
        for (k = 0; k < K; k++) {
 801fca4:	9b01      	ldr	r3, [sp, #4]
        BASE temp_imag = 0.0;
 801fca6:	eeb0 aa47 	vmov.f32	s20, s14
 801fcaa:	eef0 aa67 	vmov.f32	s21, s15
        for (k = 0; k < K; k++) {
 801fcae:	2b00      	cmp	r3, #0
        BASE temp_real = 0.0;
 801fcb0:	ec57 6b17 	vmov	r6, r7, d7
        for (k = 0; k < K; k++) {
 801fcb4:	dd5e      	ble.n	801fd74 <cblas_zherk+0xa74>
 801fcb6:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 801fcba:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
 801fcbe:	ec47 6b1b 	vmov	d11, r6, r7
 801fcc2:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801fcc6:	ed9a 7b00 	vldr	d7, [sl]
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801fcca:	ed9b 6b00 	vldr	d6, [fp]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 801fcce:	eeb0 9a47 	vmov.f32	s18, s14
 801fcd2:	eef0 9a67 	vmov.f32	s19, s15
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801fcd6:	ec53 2b16 	vmov	r2, r3, d6
          const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 801fcda:	eeb0 8a46 	vmov.f32	s16, s12
 801fcde:	eef0 8a66 	vmov.f32	s17, s13
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801fce2:	ec51 0b17 	vmov	r0, r1, d7
 801fce6:	f008 f8df 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 801fcea:	e9da 4502 	ldrd	r4, r5, [sl, #8]
          const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
 801fcee:	f8db 600c 	ldr.w	r6, [fp, #12]
 801fcf2:	f8db 8008 	ldr.w	r8, [fp, #8]
 801fcf6:	f106 4900 	add.w	r9, r6, #2147483648	; 0x80000000
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801fcfa:	460f      	mov	r7, r1
 801fcfc:	4606      	mov	r6, r0
 801fcfe:	4642      	mov	r2, r8
 801fd00:	464b      	mov	r3, r9
 801fd02:	4620      	mov	r0, r4
 801fd04:	4629      	mov	r1, r5
 801fd06:	f008 f8cf 	bl	8027ea8 <__aeabi_dmul>
 801fd0a:	4602      	mov	r2, r0
 801fd0c:	460b      	mov	r3, r1
 801fd0e:	4630      	mov	r0, r6
 801fd10:	4639      	mov	r1, r7
 801fd12:	f007 ff11 	bl	8027b38 <__aeabi_dsub>
 801fd16:	4602      	mov	r2, r0
 801fd18:	460b      	mov	r3, r1
 801fd1a:	ec51 0b1b 	vmov	r0, r1, d11
 801fd1e:	f007 ff0d 	bl	8027b3c <__adddf3>
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801fd22:	4642      	mov	r2, r8
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801fd24:	4606      	mov	r6, r0
 801fd26:	460f      	mov	r7, r1
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801fd28:	464b      	mov	r3, r9
 801fd2a:	ec51 0b19 	vmov	r0, r1, d9
 801fd2e:	f008 f8bb 	bl	8027ea8 <__aeabi_dmul>
          temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 801fd32:	ec47 6b1b 	vmov	d11, r6, r7
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801fd36:	ec53 2b18 	vmov	r2, r3, d8
 801fd3a:	4606      	mov	r6, r0
 801fd3c:	460f      	mov	r7, r1
 801fd3e:	4620      	mov	r0, r4
 801fd40:	4629      	mov	r1, r5
 801fd42:	f008 f8b1 	bl	8027ea8 <__aeabi_dmul>
 801fd46:	4602      	mov	r2, r0
 801fd48:	460b      	mov	r3, r1
 801fd4a:	4630      	mov	r0, r6
 801fd4c:	4639      	mov	r1, r7
 801fd4e:	f007 fef5 	bl	8027b3c <__adddf3>
 801fd52:	460b      	mov	r3, r1
 801fd54:	4602      	mov	r2, r0
 801fd56:	ec51 0b1a 	vmov	r0, r1, d10
 801fd5a:	f007 feef 	bl	8027b3c <__adddf3>
        for (k = 0; k < K; k++) {
 801fd5e:	9b02      	ldr	r3, [sp, #8]
 801fd60:	f10a 0a10 	add.w	sl, sl, #16
 801fd64:	4553      	cmp	r3, sl
          temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 801fd66:	ec41 0b1a 	vmov	d10, r0, r1
        for (k = 0; k < K; k++) {
 801fd6a:	f10b 0b10 	add.w	fp, fp, #16
 801fd6e:	d1aa      	bne.n	801fcc6 <cblas_zherk+0x9c6>
 801fd70:	ec57 6b1b 	vmov	r6, r7, d11
        REAL(C, i * ldc + j) += alpha * temp_real;
 801fd74:	4632      	mov	r2, r6
 801fd76:	463b      	mov	r3, r7
 801fd78:	ec57 6b1d 	vmov	r6, r7, d13
 801fd7c:	ee1d 0a10 	vmov	r0, s26
 801fd80:	4639      	mov	r1, r7
 801fd82:	f008 f891 	bl	8027ea8 <__aeabi_dmul>
 801fd86:	9c07      	ldr	r4, [sp, #28]
 801fd88:	4602      	mov	r2, r0
 801fd8a:	460b      	mov	r3, r1
 801fd8c:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 801fd90:	f007 fed4 	bl	8027b3c <__adddf3>
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801fd94:	ec53 2b1a 	vmov	r2, r3, d10
        REAL(C, i * ldc + j) += alpha * temp_real;
 801fd98:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(C, i * ldc + j) += alpha * temp_imag;
 801fd9c:	ee1d 0a10 	vmov	r0, s26
 801fda0:	4639      	mov	r1, r7
 801fda2:	f008 f881 	bl	8027ea8 <__aeabi_dmul>
 801fda6:	9d08      	ldr	r5, [sp, #32]
 801fda8:	4602      	mov	r2, r0
 801fdaa:	460b      	mov	r3, r1
 801fdac:	e9d5 0102 	ldrd	r0, r1, [r5, #8]
 801fdb0:	f007 fec4 	bl	8027b3c <__adddf3>
 801fdb4:	e9c5 0102 	strd	r0, r1, [r5, #8]
      for (j = 0; j <= i; j++) {
 801fdb8:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 801fdbc:	440a      	add	r2, r1
 801fdbe:	9205      	str	r2, [sp, #20]
 801fdc0:	f104 0210 	add.w	r2, r4, #16
 801fdc4:	9207      	str	r2, [sp, #28]
 801fdc6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801fdc8:	f105 0310 	add.w	r3, r5, #16
 801fdcc:	429a      	cmp	r2, r3
 801fdce:	9308      	str	r3, [sp, #32]
 801fdd0:	f47f af66 	bne.w	801fca0 <cblas_zherk+0x9a0>
    for (i = 0; i < N; i++) {
 801fdd4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801fdd6:	9909      	ldr	r1, [sp, #36]	; 0x24
 801fdd8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801fdda:	440a      	add	r2, r1
 801fddc:	920e      	str	r2, [sp, #56]	; 0x38
 801fdde:	9911      	ldr	r1, [sp, #68]	; 0x44
 801fde0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801fde2:	440a      	add	r2, r1
 801fde4:	990c      	ldr	r1, [sp, #48]	; 0x30
 801fde6:	920a      	str	r2, [sp, #40]	; 0x28
 801fde8:	4608      	mov	r0, r1
 801fdea:	9a10      	ldr	r2, [sp, #64]	; 0x40
 801fdec:	9902      	ldr	r1, [sp, #8]
 801fdee:	4410      	add	r0, r2
 801fdf0:	4411      	add	r1, r2
 801fdf2:	9a03      	ldr	r2, [sp, #12]
 801fdf4:	900c      	str	r0, [sp, #48]	; 0x30
 801fdf6:	3301      	adds	r3, #1
 801fdf8:	429a      	cmp	r2, r3
 801fdfa:	930f      	str	r3, [sp, #60]	; 0x3c
 801fdfc:	9102      	str	r1, [sp, #8]
 801fdfe:	f47f af43 	bne.w	801fc88 <cblas_zherk+0x988>
 801fe02:	f7ff bbe5 	b.w	801f5d0 <cblas_zherk+0x2d0>
      for (i = 0; i < N; i++) {
 801fe06:	9b03      	ldr	r3, [sp, #12]
 801fe08:	2b00      	cmp	r3, #0
 801fe0a:	f77f abe1 	ble.w	801f5d0 <cblas_zherk+0x2d0>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801fe0e:	2371      	movs	r3, #113	; 0x71
 801fe10:	9305      	str	r3, [sp, #20]
 801fe12:	f7ff bafc 	b.w	801f40e <cblas_zherk+0x10e>
    for (i = 0; i < N; i++) {
 801fe16:	2b00      	cmp	r3, #0
 801fe18:	dd09      	ble.n	801fe2e <cblas_zherk+0xb2e>
    trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
 801fe1a:	2371      	movs	r3, #113	; 0x71
 801fe1c:	9305      	str	r3, [sp, #20]
    uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 801fe1e:	237a      	movs	r3, #122	; 0x7a
 801fe20:	9302      	str	r3, [sp, #8]
 801fe22:	e462      	b.n	801f6ea <cblas_zherk+0x3ea>
      for (i = 0; i < N; i++) {
 801fe24:	2b00      	cmp	r3, #0
 801fe26:	f73f aaf2 	bgt.w	801f40e <cblas_zherk+0x10e>
 801fe2a:	f7ff bb07 	b.w	801f43c <cblas_zherk+0x13c>
  if (alpha == 0.0)
 801fe2e:	ec51 0b1d 	vmov	r0, r1, d13
 801fe32:	2200      	movs	r2, #0
 801fe34:	2300      	movs	r3, #0
 801fe36:	f008 fa9f 	bl	8028378 <__aeabi_dcmpeq>
 801fe3a:	2800      	cmp	r0, #0
 801fe3c:	f43f ac85 	beq.w	801f74a <cblas_zherk+0x44a>
 801fe40:	f7ff bbc6 	b.w	801f5d0 <cblas_zherk+0x2d0>
 801fe44:	f3af 8000 	nop.w
	...

0801fe50 <cblas_zscal>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_zscal (const int N, const void *alpha, void *X, const int incX)
{
 801fe50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fe54:	ed2d 8b06 	vpush	{d8-d10}
 801fe58:	b083      	sub	sp, #12
  if (incX <= 0) {
 801fe5a:	2b00      	cmp	r3, #0
 801fe5c:	9001      	str	r0, [sp, #4]
 801fe5e:	dd48      	ble.n	801fef2 <cblas_zscal+0xa2>
  for (i = 0; i < N; i++) {
 801fe60:	2800      	cmp	r0, #0
 801fe62:	dd46      	ble.n	801fef2 <cblas_zscal+0xa2>
  const BASE alpha_real = CONST_REAL0(alpha);
 801fe64:	ed91 7b00 	vldr	d7, [r1]
 801fe68:	eeb0 9a47 	vmov.f32	s18, s14
 801fe6c:	eef0 9a67 	vmov.f32	s19, s15
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801fe70:	ed91 7b02 	vldr	d7, [r1, #8]
 801fe74:	4693      	mov	fp, r2
 801fe76:	011f      	lsls	r7, r3, #4
 801fe78:	f102 0a08 	add.w	sl, r2, #8
  for (i = 0; i < N; i++) {
 801fe7c:	2600      	movs	r6, #0
  const BASE alpha_imag = CONST_IMAG0(alpha);
 801fe7e:	eeb0 8a47 	vmov.f32	s16, s14
 801fe82:	eef0 8a67 	vmov.f32	s17, s15
    const BASE x_real = REAL(X, ix);
 801fe86:	e95a 8902 	ldrd	r8, r9, [sl, #-8]
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 801fe8a:	ec51 0b19 	vmov	r0, r1, d9
 801fe8e:	4642      	mov	r2, r8
 801fe90:	464b      	mov	r3, r9
    const BASE x_imag = IMAG(X, ix);
 801fe92:	e9db 4502 	ldrd	r4, r5, [fp, #8]
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 801fe96:	f008 f807 	bl	8027ea8 <__aeabi_dmul>
 801fe9a:	4622      	mov	r2, r4
 801fe9c:	462b      	mov	r3, r5
 801fe9e:	ec41 0b1a 	vmov	d10, r0, r1
 801fea2:	ec51 0b18 	vmov	r0, r1, d8
 801fea6:	f007 ffff 	bl	8027ea8 <__aeabi_dmul>
 801feaa:	4602      	mov	r2, r0
 801feac:	460b      	mov	r3, r1
 801feae:	ec51 0b1a 	vmov	r0, r1, d10
 801feb2:	f007 fe41 	bl	8027b38 <__aeabi_dsub>
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 801feb6:	4642      	mov	r2, r8
    REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
 801feb8:	e94a 0102 	strd	r0, r1, [sl, #-8]
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 801febc:	464b      	mov	r3, r9
 801febe:	ec51 0b18 	vmov	r0, r1, d8
 801fec2:	f007 fff1 	bl	8027ea8 <__aeabi_dmul>
 801fec6:	4622      	mov	r2, r4
 801fec8:	462b      	mov	r3, r5
 801feca:	4604      	mov	r4, r0
 801fecc:	460d      	mov	r5, r1
 801fece:	ec51 0b19 	vmov	r0, r1, d9
 801fed2:	f007 ffe9 	bl	8027ea8 <__aeabi_dmul>
 801fed6:	460b      	mov	r3, r1
 801fed8:	4602      	mov	r2, r0
 801feda:	4629      	mov	r1, r5
 801fedc:	4620      	mov	r0, r4
 801fede:	f007 fe2d 	bl	8027b3c <__adddf3>
  for (i = 0; i < N; i++) {
 801fee2:	9b01      	ldr	r3, [sp, #4]
 801fee4:	3601      	adds	r6, #1
 801fee6:	42b3      	cmp	r3, r6
    IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
 801fee8:	e9cb 0102 	strd	r0, r1, [fp, #8]
  for (i = 0; i < N; i++) {
 801feec:	44ba      	add	sl, r7
 801feee:	44bb      	add	fp, r7
 801fef0:	d1c9      	bne.n	801fe86 <cblas_zscal+0x36>
#define BASE double
#include "source_scal_c.h"
#undef BASE
}
 801fef2:	b003      	add	sp, #12
 801fef4:	ecbd 8b06 	vpop	{d8-d10}
 801fef8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801fefc <cblas_zswap>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_zswap (const int N, void *X, const int incX, void *Y, const int incY)
{
 801fefc:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801ff00:	9f08      	ldr	r7, [sp, #32]
  INDEX ix = OFFSET(N, incX);
 801ff02:	1e16      	subs	r6, r2, #0
 801ff04:	bfda      	itte	le
 801ff06:	f1c0 0c01 	rsble	ip, r0, #1
 801ff0a:	fb0c fc06 	mulle.w	ip, ip, r6
 801ff0e:	f04f 0c00 	movgt.w	ip, #0
  INDEX iy = OFFSET(N, incY);
 801ff12:	2f00      	cmp	r7, #0
 801ff14:	bfda      	itte	le
 801ff16:	f1c0 0501 	rsble	r5, r0, #1
 801ff1a:	437d      	mulle	r5, r7
 801ff1c:	2500      	movgt	r5, #0
  for (i = 0; i < N; i++) {
 801ff1e:	2800      	cmp	r0, #0
 801ff20:	dd23      	ble.n	801ff6a <cblas_zswap+0x6e>
 801ff22:	eb03 1205 	add.w	r2, r3, r5, lsl #4
 801ff26:	eb01 140c 	add.w	r4, r1, ip, lsl #4
 801ff2a:	eb03 1305 	add.w	r3, r3, r5, lsl #4
 801ff2e:	0136      	lsls	r6, r6, #4
 801ff30:	013f      	lsls	r7, r7, #4
 801ff32:	3408      	adds	r4, #8
 801ff34:	eb01 110c 	add.w	r1, r1, ip, lsl #4
 801ff38:	3208      	adds	r2, #8
 801ff3a:	2500      	movs	r5, #0
    REAL(X, ix) = REAL(Y, iy);
 801ff3c:	ed12 7b02 	vldr	d7, [r2, #-8]
    const BASE tmp_real = REAL(X, ix);
 801ff40:	e954 ab02 	ldrd	sl, fp, [r4, #-8]
    const BASE tmp_imag = IMAG(X, ix);
 801ff44:	e9d1 8902 	ldrd	r8, r9, [r1, #8]
    REAL(X, ix) = REAL(Y, iy);
 801ff48:	ed04 7b02 	vstr	d7, [r4, #-8]
    IMAG(X, ix) = IMAG(Y, iy);
 801ff4c:	ed93 7b02 	vldr	d7, [r3, #8]
  for (i = 0; i < N; i++) {
 801ff50:	3501      	adds	r5, #1
 801ff52:	42a8      	cmp	r0, r5
    IMAG(X, ix) = IMAG(Y, iy);
 801ff54:	ed81 7b02 	vstr	d7, [r1, #8]
    REAL(Y, iy) = tmp_real;
 801ff58:	4434      	add	r4, r6
 801ff5a:	e942 ab02 	strd	sl, fp, [r2, #-8]
    IMAG(Y, iy) = tmp_imag;
 801ff5e:	4431      	add	r1, r6
 801ff60:	e9c3 8902 	strd	r8, r9, [r3, #8]
  for (i = 0; i < N; i++) {
 801ff64:	443a      	add	r2, r7
 801ff66:	443b      	add	r3, r7
 801ff68:	d1e8      	bne.n	801ff3c <cblas_zswap+0x40>
#define BASE double
#include "source_swap_c.h"
#undef BASE
}
 801ff6a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 801ff6e:	4770      	bx	lr

0801ff70 <cblas_zsymm>:
void
cblas_zsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const int M, const int N,
             const void *alpha, const void *A, const int lda, const void *B,
             const int ldb, const void *beta, void *C, const int ldc)
{
 801ff70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ff74:	ed2d 8b10 	vpush	{d8-d15}
 801ff78:	b09d      	sub	sp, #116	; 0x74
 801ff7a:	298d      	cmp	r1, #141	; 0x8d
 801ff7c:	9307      	str	r3, [sp, #28]
 801ff7e:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 801ff80:	930a      	str	r3, [sp, #40]	; 0x28
 801ff82:	e9dd 8337 	ldrd	r8, r3, [sp, #220]	; 0xdc
 801ff86:	930f      	str	r3, [sp, #60]	; 0x3c
 801ff88:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 801ff8a:	930e      	str	r3, [sp, #56]	; 0x38
 801ff8c:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 801ff8e:	9311      	str	r3, [sp, #68]	; 0x44
 801ff90:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 801ff92:	9314      	str	r3, [sp, #80]	; 0x50
 801ff94:	e9dd 733c 	ldrd	r7, r3, [sp, #240]	; 0xf0
 801ff98:	9310      	str	r3, [sp, #64]	; 0x40
 801ff9a:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 801ff9c:	9313      	str	r3, [sp, #76]	; 0x4c
 801ff9e:	460c      	mov	r4, r1
 801ffa0:	4606      	mov	r6, r0
 801ffa2:	4615      	mov	r5, r2
 801ffa4:	f000 8135 	beq.w	8020212 <cblas_zsymm+0x2a2>
 801ffa8:	298e      	cmp	r1, #142	; 0x8e
 801ffaa:	f001 80cd 	beq.w	8021148 <cblas_zsymm+0x11d8>
 801ffae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801ffb0:	2002      	movs	r0, #2
 801ffb2:	f1a5 0279 	sub.w	r2, r5, #121	; 0x79
 801ffb6:	2a01      	cmp	r2, #1
 801ffb8:	9a07      	ldr	r2, [sp, #28]
 801ffba:	bf88      	it	hi
 801ffbc:	2003      	movhi	r0, #3
 801ffbe:	2a00      	cmp	r2, #0
 801ffc0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801ffc2:	bfb8      	it	lt
 801ffc4:	2004      	movlt	r0, #4
 801ffc6:	2b01      	cmp	r3, #1
 801ffc8:	bfb8      	it	lt
 801ffca:	2301      	movlt	r3, #1
 801ffcc:	2a00      	cmp	r2, #0
 801ffce:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 801ffd0:	f2c0 8114 	blt.w	80201fc <cblas_zsymm+0x28c>
 801ffd4:	4293      	cmp	r3, r2
 801ffd6:	f340 808c 	ble.w	80200f2 <cblas_zsymm+0x182>
 801ffda:	2e65      	cmp	r6, #101	; 0x65
 801ffdc:	f000 84bb 	beq.w	8020956 <cblas_zsymm+0x9e6>
 801ffe0:	2e66      	cmp	r6, #102	; 0x66
 801ffe2:	f001 80a0 	beq.w	8021126 <cblas_zsymm+0x11b6>
 801ffe6:	2008      	movs	r0, #8
 801ffe8:	4a91      	ldr	r2, [pc, #580]	; (8020230 <cblas_zsymm+0x2c0>)
 801ffea:	4992      	ldr	r1, [pc, #584]	; (8020234 <cblas_zsymm+0x2c4>)
 801ffec:	f007 fd2c 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 801fff0:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 801fff4:	2200      	movs	r2, #0
 801fff6:	ec51 0b17 	vmov	r0, r1, d7
    const BASE alpha_real = CONST_REAL0(alpha);
 801fffa:	eeb0 fa47 	vmov.f32	s30, s14
 801fffe:	eef0 fa67 	vmov.f32	s31, s15
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8020002:	2300      	movs	r3, #0
 8020004:	f008 f9b8 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8020008:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 802000c:	e9d7 ab00 	ldrd	sl, fp, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8020010:	ed8d 7b04 	vstr	d7, [sp, #16]
    const BASE beta_imag = CONST_IMAG0(beta);
 8020014:	ed97 8b02 	vldr	d8, [r7, #8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8020018:	b170      	cbz	r0, 8020038 <cblas_zsymm+0xc8>
 802001a:	ec51 0b17 	vmov	r0, r1, d7
 802001e:	2200      	movs	r2, #0
 8020020:	2300      	movs	r3, #0
 8020022:	f008 f9a9 	bl	8028378 <__aeabi_dcmpeq>
 8020026:	b138      	cbz	r0, 8020038 <cblas_zsymm+0xc8>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8020028:	4b83      	ldr	r3, [pc, #524]	; (8020238 <cblas_zsymm+0x2c8>)
 802002a:	2200      	movs	r2, #0
 802002c:	4650      	mov	r0, sl
 802002e:	4659      	mov	r1, fp
 8020030:	f008 f9a2 	bl	8028378 <__aeabi_dcmpeq>
 8020034:	2800      	cmp	r0, #0
 8020036:	d166      	bne.n	8020106 <cblas_zsymm+0x196>
    if (Order == CblasRowMajor) {
 8020038:	2e65      	cmp	r6, #101	; 0x65
 802003a:	f000 80f1 	beq.w	8020220 <cblas_zsymm+0x2b0>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 802003e:	2d79      	cmp	r5, #121	; 0x79
 8020040:	bf0c      	ite	eq
 8020042:	237a      	moveq	r3, #122	; 0x7a
 8020044:	2379      	movne	r3, #121	; 0x79
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 8020046:	2c8d      	cmp	r4, #141	; 0x8d
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8020048:	930b      	str	r3, [sp, #44]	; 0x2c
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
 802004a:	bf0c      	ite	eq
 802004c:	238e      	moveq	r3, #142	; 0x8e
 802004e:	238d      	movne	r3, #141	; 0x8d
 8020050:	9309      	str	r3, [sp, #36]	; 0x24
    if (beta_real == 0.0 && beta_imag == 0.0) {
 8020052:	2200      	movs	r2, #0
 8020054:	2300      	movs	r3, #0
 8020056:	4650      	mov	r0, sl
 8020058:	4659      	mov	r1, fp
 802005a:	f008 f98d 	bl	8028378 <__aeabi_dcmpeq>
 802005e:	2200      	movs	r2, #0
 8020060:	2800      	cmp	r0, #0
 8020062:	d05d      	beq.n	8020120 <cblas_zsymm+0x1b0>
 8020064:	ec51 0b18 	vmov	r0, r1, d8
 8020068:	2300      	movs	r3, #0
 802006a:	f008 f985 	bl	8028378 <__aeabi_dcmpeq>
 802006e:	2800      	cmp	r0, #0
 8020070:	d064      	beq.n	802013c <cblas_zsymm+0x1cc>
      for (i = 0; i < n1; i++) {
 8020072:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020074:	2b00      	cmp	r3, #0
 8020076:	dd1c      	ble.n	80200b2 <cblas_zsymm+0x142>
 8020078:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802007a:	9d07      	ldr	r5, [sp, #28]
 802007c:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 8020080:	0114      	lsls	r4, r2, #4
 8020082:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8020084:	ebc5 7005 	rsb	r0, r5, r5, lsl #28
 8020088:	0100      	lsls	r0, r0, #4
 802008a:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 802008e:	2100      	movs	r1, #0
          REAL(C, ldc * i + j) = 0.0;
 8020090:	2600      	movs	r6, #0
 8020092:	2700      	movs	r7, #0
        for (j = 0; j < n2; j++) {
 8020094:	2d00      	cmp	r5, #0
 8020096:	bfc8      	it	gt
 8020098:	1883      	addgt	r3, r0, r2
 802009a:	dd06      	ble.n	80200aa <cblas_zsymm+0x13a>
          REAL(C, ldc * i + j) = 0.0;
 802009c:	e9c3 6700 	strd	r6, r7, [r3]
          IMAG(C, ldc * i + j) = 0.0;
 80200a0:	e9c3 6702 	strd	r6, r7, [r3, #8]
        for (j = 0; j < n2; j++) {
 80200a4:	3310      	adds	r3, #16
 80200a6:	429a      	cmp	r2, r3
 80200a8:	d1f8      	bne.n	802009c <cblas_zsymm+0x12c>
      for (i = 0; i < n1; i++) {
 80200aa:	3101      	adds	r1, #1
 80200ac:	458c      	cmp	ip, r1
 80200ae:	4422      	add	r2, r4
 80200b0:	d1f0      	bne.n	8020094 <cblas_zsymm+0x124>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80200b2:	ec51 0b1f 	vmov	r0, r1, d15
 80200b6:	2200      	movs	r2, #0
 80200b8:	2300      	movs	r3, #0
 80200ba:	f008 f95d 	bl	8028378 <__aeabi_dcmpeq>
 80200be:	b130      	cbz	r0, 80200ce <cblas_zsymm+0x15e>
 80200c0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80200c4:	2200      	movs	r2, #0
 80200c6:	2300      	movs	r3, #0
 80200c8:	f008 f956 	bl	8028378 <__aeabi_dcmpeq>
 80200cc:	bb18      	cbnz	r0, 8020116 <cblas_zsymm+0x1a6>
    if (side == CblasLeft && uplo == CblasUpper) {
 80200ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80200d0:	2b8d      	cmp	r3, #141	; 0x8d
 80200d2:	f000 80b5 	beq.w	8020240 <cblas_zsymm+0x2d0>
    } else if (side == CblasRight && uplo == CblasUpper) {
 80200d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80200d8:	2b8e      	cmp	r3, #142	; 0x8e
 80200da:	f000 8265 	beq.w	80205a8 <cblas_zsymm+0x638>
      BLAS_ERROR("unrecognized operation");
 80200de:	4a57      	ldr	r2, [pc, #348]	; (802023c <cblas_zsymm+0x2cc>)
 80200e0:	4954      	ldr	r1, [pc, #336]	; (8020234 <cblas_zsymm+0x2c4>)
 80200e2:	2000      	movs	r0, #0
#define BASE double
#include "source_symm_c.h"
#undef BASE
}
 80200e4:	b01d      	add	sp, #116	; 0x74
 80200e6:	ecbd 8b10 	vpop	{d8-d15}
 80200ea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80200ee:	f007 bcab 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80200f2:	2e65      	cmp	r6, #101	; 0x65
 80200f4:	f000 843e 	beq.w	8020974 <cblas_zsymm+0xa04>
 80200f8:	2e66      	cmp	r6, #102	; 0x66
 80200fa:	f000 87bc 	beq.w	8021076 <cblas_zsymm+0x1106>
 80200fe:	2800      	cmp	r0, #0
 8020100:	f43f af76 	beq.w	801fff0 <cblas_zsymm+0x80>
 8020104:	e770      	b.n	801ffe8 <cblas_zsymm+0x78>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8020106:	ec51 0b18 	vmov	r0, r1, d8
 802010a:	2200      	movs	r2, #0
 802010c:	2300      	movs	r3, #0
 802010e:	f008 f933 	bl	8028378 <__aeabi_dcmpeq>
 8020112:	2800      	cmp	r0, #0
 8020114:	d090      	beq.n	8020038 <cblas_zsymm+0xc8>
 8020116:	b01d      	add	sp, #116	; 0x74
 8020118:	ecbd 8b10 	vpop	{d8-d15}
 802011c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8020120:	4b45      	ldr	r3, [pc, #276]	; (8020238 <cblas_zsymm+0x2c8>)
 8020122:	4650      	mov	r0, sl
 8020124:	4659      	mov	r1, fp
 8020126:	f008 f927 	bl	8028378 <__aeabi_dcmpeq>
 802012a:	b138      	cbz	r0, 802013c <cblas_zsymm+0x1cc>
 802012c:	ec51 0b18 	vmov	r0, r1, d8
 8020130:	2200      	movs	r2, #0
 8020132:	2300      	movs	r3, #0
 8020134:	f008 f920 	bl	8028378 <__aeabi_dcmpeq>
 8020138:	2800      	cmp	r0, #0
 802013a:	d1ba      	bne.n	80200b2 <cblas_zsymm+0x142>
      for (i = 0; i < n1; i++) {
 802013c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802013e:	2b00      	cmp	r3, #0
 8020140:	ddb7      	ble.n	80200b2 <cblas_zsymm+0x142>
 8020142:	9a07      	ldr	r2, [sp, #28]
 8020144:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8020148:	011b      	lsls	r3, r3, #4
 802014a:	9306      	str	r3, [sp, #24]
 802014c:	3308      	adds	r3, #8
 802014e:	9308      	str	r3, [sp, #32]
 8020150:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8020152:	011b      	lsls	r3, r3, #4
 8020154:	9303      	str	r3, [sp, #12]
 8020156:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020158:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802015c:	9301      	str	r3, [sp, #4]
 802015e:	2300      	movs	r3, #0
 8020160:	9302      	str	r3, [sp, #8]
        for (j = 0; j < n2; j++) {
 8020162:	9b07      	ldr	r3, [sp, #28]
 8020164:	2b00      	cmp	r3, #0
 8020166:	dd3e      	ble.n	80201e6 <cblas_zsymm+0x276>
 8020168:	9b06      	ldr	r3, [sp, #24]
 802016a:	9a08      	ldr	r2, [sp, #32]
 802016c:	4619      	mov	r1, r3
 802016e:	9b01      	ldr	r3, [sp, #4]
 8020170:	eb01 0803 	add.w	r8, r1, r3
 8020174:	eb02 0903 	add.w	r9, r2, r3
          const BASE Cij_real = REAL(C, ldc * i + j);
 8020178:	e959 4502 	ldrd	r4, r5, [r9, #-8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 802017c:	4650      	mov	r0, sl
 802017e:	4622      	mov	r2, r4
 8020180:	462b      	mov	r3, r5
 8020182:	4659      	mov	r1, fp
          const BASE Cij_imag = IMAG(C, ldc * i + j);
 8020184:	e9d8 6702 	ldrd	r6, r7, [r8, #8]
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8020188:	f007 fe8e 	bl	8027ea8 <__aeabi_dmul>
 802018c:	4632      	mov	r2, r6
 802018e:	ec41 0b19 	vmov	d9, r0, r1
 8020192:	463b      	mov	r3, r7
 8020194:	ec51 0b18 	vmov	r0, r1, d8
 8020198:	f007 fe86 	bl	8027ea8 <__aeabi_dmul>
 802019c:	4602      	mov	r2, r0
 802019e:	460b      	mov	r3, r1
 80201a0:	ec51 0b19 	vmov	r0, r1, d9
 80201a4:	f007 fcc8 	bl	8027b38 <__aeabi_dsub>
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80201a8:	4632      	mov	r2, r6
          REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80201aa:	e949 0102 	strd	r0, r1, [r9, #-8]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80201ae:	463b      	mov	r3, r7
 80201b0:	4650      	mov	r0, sl
 80201b2:	4659      	mov	r1, fp
 80201b4:	f007 fe78 	bl	8027ea8 <__aeabi_dmul>
 80201b8:	4622      	mov	r2, r4
 80201ba:	462b      	mov	r3, r5
 80201bc:	4604      	mov	r4, r0
 80201be:	460d      	mov	r5, r1
 80201c0:	ec51 0b18 	vmov	r0, r1, d8
 80201c4:	f007 fe70 	bl	8027ea8 <__aeabi_dmul>
 80201c8:	460b      	mov	r3, r1
 80201ca:	4602      	mov	r2, r0
 80201cc:	4629      	mov	r1, r5
 80201ce:	4620      	mov	r0, r4
 80201d0:	f007 fcb4 	bl	8027b3c <__adddf3>
        for (j = 0; j < n2; j++) {
 80201d4:	9b01      	ldr	r3, [sp, #4]
          IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80201d6:	e9c8 0102 	strd	r0, r1, [r8, #8]
        for (j = 0; j < n2; j++) {
 80201da:	f108 0810 	add.w	r8, r8, #16
 80201de:	4543      	cmp	r3, r8
 80201e0:	f109 0910 	add.w	r9, r9, #16
 80201e4:	d1c8      	bne.n	8020178 <cblas_zsymm+0x208>
      for (i = 0; i < n1; i++) {
 80201e6:	9a01      	ldr	r2, [sp, #4]
 80201e8:	9903      	ldr	r1, [sp, #12]
 80201ea:	9b02      	ldr	r3, [sp, #8]
 80201ec:	440a      	add	r2, r1
 80201ee:	9201      	str	r2, [sp, #4]
 80201f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80201f2:	3301      	adds	r3, #1
 80201f4:	429a      	cmp	r2, r3
 80201f6:	9302      	str	r3, [sp, #8]
 80201f8:	d1b3      	bne.n	8020162 <cblas_zsymm+0x1f2>
 80201fa:	e75a      	b.n	80200b2 <cblas_zsymm+0x142>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 80201fc:	429a      	cmp	r2, r3
 80201fe:	f6ff aeec 	blt.w	801ffda <cblas_zsymm+0x6a>
 8020202:	2e65      	cmp	r6, #101	; 0x65
 8020204:	f000 872c 	beq.w	8021060 <cblas_zsymm+0x10f0>
 8020208:	2e66      	cmp	r6, #102	; 0x66
 802020a:	f000 87ac 	beq.w	8021166 <cblas_zsymm+0x11f6>
 802020e:	2005      	movs	r0, #5
 8020210:	e6ea      	b.n	801ffe8 <cblas_zsymm+0x78>
 8020212:	3865      	subs	r0, #101	; 0x65
 8020214:	2801      	cmp	r0, #1
 8020216:	9b07      	ldr	r3, [sp, #28]
 8020218:	bf94      	ite	ls
 802021a:	2000      	movls	r0, #0
 802021c:	2001      	movhi	r0, #1
 802021e:	e6c8      	b.n	801ffb2 <cblas_zsymm+0x42>
      uplo = Uplo;
 8020220:	9a07      	ldr	r2, [sp, #28]
 8020222:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020224:	950b      	str	r5, [sp, #44]	; 0x2c
      side = Side;
 8020226:	e9cd 4209 	strd	r4, r2, [sp, #36]	; 0x24
 802022a:	9307      	str	r3, [sp, #28]
 802022c:	e711      	b.n	8020052 <cblas_zsymm+0xe2>
 802022e:	bf00      	nop
 8020230:	08030378 	.word	0x08030378
 8020234:	08030750 	.word	0x08030750
 8020238:	3ff00000 	.word	0x3ff00000
 802023c:	080305a8 	.word	0x080305a8
    if (side == CblasLeft && uplo == CblasUpper) {
 8020240:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8020242:	2b79      	cmp	r3, #121	; 0x79
 8020244:	f000 83a5 	beq.w	8020992 <cblas_zsymm+0xa22>
    } else if (side == CblasLeft && uplo == CblasLower) {
 8020248:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802024a:	2b7a      	cmp	r3, #122	; 0x7a
 802024c:	f47f af47 	bne.w	80200de <cblas_zsymm+0x16e>
      for (i = 0; i < n1; i++) {
 8020250:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020252:	2b00      	cmp	r3, #0
 8020254:	f77f af5f 	ble.w	8020116 <cblas_zsymm+0x1a6>
 8020258:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802025a:	3301      	adds	r3, #1
 802025c:	011a      	lsls	r2, r3, #4
 802025e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020260:	9216      	str	r2, [sp, #88]	; 0x58
 8020262:	3a10      	subs	r2, #16
 8020264:	9215      	str	r2, [sp, #84]	; 0x54
 8020266:	f103 0208 	add.w	r2, r3, #8
 802026a:	e9cd 230d 	strd	r2, r3, [sp, #52]	; 0x34
 802026e:	9301      	str	r3, [sp, #4]
 8020270:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8020272:	011b      	lsls	r3, r3, #4
 8020274:	9303      	str	r3, [sp, #12]
 8020276:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8020278:	011b      	lsls	r3, r3, #4
 802027a:	9302      	str	r3, [sp, #8]
 802027c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802027e:	3308      	adds	r3, #8
 8020280:	9317      	str	r3, [sp, #92]	; 0x5c
 8020282:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020284:	2100      	movs	r1, #0
 8020286:	3308      	adds	r3, #8
 8020288:	910f      	str	r1, [sp, #60]	; 0x3c
 802028a:	9112      	str	r1, [sp, #72]	; 0x48
 802028c:	910c      	str	r1, [sp, #48]	; 0x30
 802028e:	9318      	str	r3, [sp, #96]	; 0x60
        for (j = 0; j < n2; j++) {
 8020290:	9b07      	ldr	r3, [sp, #28]
 8020292:	2b00      	cmp	r3, #0
 8020294:	f340 8168 	ble.w	8020568 <cblas_zsymm+0x5f8>
 8020298:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802029a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802029c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80202a0:	9308      	str	r3, [sp, #32]
 80202a2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80202a4:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80202a6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80202aa:	9306      	str	r3, [sp, #24]
 80202ac:	2308      	movs	r3, #8
 80202ae:	930b      	str	r3, [sp, #44]	; 0x2c
 80202b0:	2300      	movs	r3, #0
 80202b2:	9309      	str	r3, [sp, #36]	; 0x24
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80202b4:	9c08      	ldr	r4, [sp, #32]
 80202b6:	e954 6702 	ldrd	r6, r7, [r4, #-8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80202ba:	ec51 0b1f 	vmov	r0, r1, d15
 80202be:	4632      	mov	r2, r6
 80202c0:	463b      	mov	r3, r7
 80202c2:	f007 fdf1 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80202c6:	e9d4 8900 	ldrd	r8, r9, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80202ca:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80202ce:	4604      	mov	r4, r0
 80202d0:	460d      	mov	r5, r1
 80202d2:	4642      	mov	r2, r8
 80202d4:	464b      	mov	r3, r9
 80202d6:	4650      	mov	r0, sl
 80202d8:	4659      	mov	r1, fp
 80202da:	f007 fde5 	bl	8027ea8 <__aeabi_dmul>
 80202de:	4602      	mov	r2, r0
 80202e0:	460b      	mov	r3, r1
 80202e2:	4620      	mov	r0, r4
 80202e4:	4629      	mov	r1, r5
 80202e6:	f007 fc27 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80202ea:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80202ec:	4604      	mov	r4, r0
 80202ee:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80202f0:	464b      	mov	r3, r9
 80202f2:	ec51 0b1f 	vmov	r0, r1, d15
 80202f6:	f007 fdd7 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80202fa:	ec45 4b1b 	vmov	d11, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80202fe:	4632      	mov	r2, r6
 8020300:	463b      	mov	r3, r7
 8020302:	4604      	mov	r4, r0
 8020304:	460d      	mov	r5, r1
 8020306:	4650      	mov	r0, sl
 8020308:	4659      	mov	r1, fp
 802030a:	f007 fdcd 	bl	8027ea8 <__aeabi_dmul>
 802030e:	460b      	mov	r3, r1
 8020310:	4602      	mov	r2, r0
 8020312:	4629      	mov	r1, r5
 8020314:	4620      	mov	r0, r4
 8020316:	f007 fc11 	bl	8027b3c <__adddf3>
          BASE temp2_imag = 0.0;
 802031a:	ed9f 7ba1 	vldr	d7, [pc, #644]	; 80205a0 <cblas_zsymm+0x630>
          for (k = 0; k < i; k++) {
 802031e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
          BASE temp2_imag = 0.0;
 8020320:	eeb0 da47 	vmov.f32	s26, s14
 8020324:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020328:	ec41 0b1e 	vmov	d14, r0, r1
          BASE temp2_real = 0.0;
 802032c:	eeb0 ca47 	vmov.f32	s24, s14
 8020330:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < i; k++) {
 8020334:	2b00      	cmp	r3, #0
 8020336:	f000 8094 	beq.w	8020462 <cblas_zsymm+0x4f2>
 802033a:	9a11      	ldr	r2, [sp, #68]	; 0x44
 802033c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802033e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8020340:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 8020344:	4610      	mov	r0, r2
 8020346:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020348:	eb03 1a01 	add.w	sl, r3, r1, lsl #4
 802034c:	eb00 0902 	add.w	r9, r0, r2
 8020350:	eb03 0802 	add.w	r8, r3, r2
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8020354:	e9db 6700 	ldrd	r6, r7, [fp]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8020358:	ec51 0b1b 	vmov	r0, r1, d11
 802035c:	4632      	mov	r2, r6
 802035e:	463b      	mov	r3, r7
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8020360:	e9db 4502 	ldrd	r4, r5, [fp, #8]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8020364:	f007 fda0 	bl	8027ea8 <__aeabi_dmul>
 8020368:	4622      	mov	r2, r4
 802036a:	ec41 0b18 	vmov	d8, r0, r1
 802036e:	462b      	mov	r3, r5
 8020370:	ec51 0b1e 	vmov	r0, r1, d14
 8020374:	f007 fd98 	bl	8027ea8 <__aeabi_dmul>
 8020378:	4602      	mov	r2, r0
 802037a:	460b      	mov	r3, r1
 802037c:	ec51 0b18 	vmov	r0, r1, d8
 8020380:	f007 fbda 	bl	8027b38 <__aeabi_dsub>
 8020384:	4602      	mov	r2, r0
 8020386:	460b      	mov	r3, r1
 8020388:	e958 0102 	ldrd	r0, r1, [r8, #-8]
 802038c:	f007 fbd6 	bl	8027b3c <__adddf3>
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8020390:	ed19 8b02 	vldr	d8, [r9, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8020394:	ed99 9b00 	vldr	d9, [r9]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8020398:	4632      	mov	r2, r6
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 802039a:	e948 0102 	strd	r0, r1, [r8, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 802039e:	463b      	mov	r3, r7
 80203a0:	ec51 0b1e 	vmov	r0, r1, d14
 80203a4:	f007 fd80 	bl	8027ea8 <__aeabi_dmul>
 80203a8:	4622      	mov	r2, r4
 80203aa:	ec41 0b1a 	vmov	d10, r0, r1
 80203ae:	462b      	mov	r3, r5
 80203b0:	ec51 0b1b 	vmov	r0, r1, d11
 80203b4:	f007 fd78 	bl	8027ea8 <__aeabi_dmul>
 80203b8:	4602      	mov	r2, r0
 80203ba:	460b      	mov	r3, r1
 80203bc:	ec51 0b1a 	vmov	r0, r1, d10
 80203c0:	f007 fbbc 	bl	8027b3c <__adddf3>
 80203c4:	4602      	mov	r2, r0
 80203c6:	460b      	mov	r3, r1
 80203c8:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 80203cc:	f007 fbb6 	bl	8027b3c <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80203d0:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 80203d4:	e9ca 0102 	strd	r0, r1, [sl, #8]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 80203d8:	4630      	mov	r0, r6
 80203da:	4639      	mov	r1, r7
 80203dc:	f007 fd64 	bl	8027ea8 <__aeabi_dmul>
 80203e0:	ec53 2b19 	vmov	r2, r3, d9
 80203e4:	ec41 0b1a 	vmov	d10, r0, r1
 80203e8:	4620      	mov	r0, r4
 80203ea:	4629      	mov	r1, r5
 80203ec:	f007 fd5c 	bl	8027ea8 <__aeabi_dmul>
 80203f0:	4602      	mov	r2, r0
 80203f2:	460b      	mov	r3, r1
 80203f4:	ec51 0b1a 	vmov	r0, r1, d10
 80203f8:	f007 fb9e 	bl	8027b38 <__aeabi_dsub>
 80203fc:	4602      	mov	r2, r0
 80203fe:	460b      	mov	r3, r1
 8020400:	ec51 0b1c 	vmov	r0, r1, d12
 8020404:	f007 fb9a 	bl	8027b3c <__adddf3>
 8020408:	ec41 0b17 	vmov	d7, r0, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 802040c:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8020410:	eeb0 ca47 	vmov.f32	s24, s14
 8020414:	eef0 ca67 	vmov.f32	s25, s15
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8020418:	4630      	mov	r0, r6
 802041a:	4639      	mov	r1, r7
 802041c:	f007 fd44 	bl	8027ea8 <__aeabi_dmul>
 8020420:	ec53 2b18 	vmov	r2, r3, d8
 8020424:	4606      	mov	r6, r0
 8020426:	460f      	mov	r7, r1
 8020428:	4620      	mov	r0, r4
 802042a:	4629      	mov	r1, r5
 802042c:	f007 fd3c 	bl	8027ea8 <__aeabi_dmul>
 8020430:	4602      	mov	r2, r0
 8020432:	460b      	mov	r3, r1
 8020434:	4630      	mov	r0, r6
 8020436:	4639      	mov	r1, r7
 8020438:	f007 fb80 	bl	8027b3c <__adddf3>
 802043c:	460b      	mov	r3, r1
 802043e:	4602      	mov	r2, r0
 8020440:	ec51 0b1d 	vmov	r0, r1, d13
 8020444:	f007 fb7a 	bl	8027b3c <__adddf3>
 8020448:	9b02      	ldr	r3, [sp, #8]
 802044a:	4499      	add	r9, r3
 802044c:	9b03      	ldr	r3, [sp, #12]
 802044e:	4498      	add	r8, r3
 8020450:	449a      	add	sl, r3
          for (k = 0; k < i; k++) {
 8020452:	9b01      	ldr	r3, [sp, #4]
 8020454:	f10b 0b10 	add.w	fp, fp, #16
 8020458:	455b      	cmp	r3, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 802045a:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < i; k++) {
 802045e:	f47f af79 	bne.w	8020354 <cblas_zsymm+0x3e4>
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8020462:	9b01      	ldr	r3, [sp, #4]
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8020464:	9c0d      	ldr	r4, [sp, #52]	; 0x34
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8020466:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 802046a:	ec51 0b1b 	vmov	r0, r1, d11
 802046e:	4642      	mov	r2, r8
 8020470:	464b      	mov	r3, r9
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8020472:	e954 6702 	ldrd	r6, r7, [r4, #-8]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8020476:	f007 fd17 	bl	8027ea8 <__aeabi_dmul>
 802047a:	4632      	mov	r2, r6
 802047c:	463b      	mov	r3, r7
 802047e:	4604      	mov	r4, r0
 8020480:	460d      	mov	r5, r1
 8020482:	ec51 0b1e 	vmov	r0, r1, d14
 8020486:	f007 fd0f 	bl	8027ea8 <__aeabi_dmul>
 802048a:	4602      	mov	r2, r0
 802048c:	460b      	mov	r3, r1
 802048e:	4620      	mov	r0, r4
 8020490:	4629      	mov	r1, r5
 8020492:	f007 fb53 	bl	8027b3c <__adddf3>
 8020496:	9b06      	ldr	r3, [sp, #24]
 8020498:	e9d3 2300 	ldrd	r2, r3, [r3]
 802049c:	f007 fb4e 	bl	8027b3c <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 80204a0:	4632      	mov	r2, r6
 80204a2:	463b      	mov	r3, r7
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 80204a4:	4682      	mov	sl, r0
 80204a6:	468b      	mov	fp, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 80204a8:	ec51 0b1b 	vmov	r0, r1, d11
 80204ac:	f007 fcfc 	bl	8027ea8 <__aeabi_dmul>
 80204b0:	4642      	mov	r2, r8
 80204b2:	464b      	mov	r3, r9
 80204b4:	4604      	mov	r4, r0
 80204b6:	460d      	mov	r5, r1
 80204b8:	ec51 0b1e 	vmov	r0, r1, d14
 80204bc:	f007 fcf4 	bl	8027ea8 <__aeabi_dmul>
 80204c0:	4602      	mov	r2, r0
 80204c2:	460b      	mov	r3, r1
 80204c4:	4620      	mov	r0, r4
 80204c6:	4629      	mov	r1, r5
 80204c8:	f007 fb36 	bl	8027b38 <__aeabi_dsub>
 80204cc:	9a06      	ldr	r2, [sp, #24]
 80204ce:	e952 2302 	ldrd	r2, r3, [r2, #-8]
 80204d2:	f007 fb33 	bl	8027b3c <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80204d6:	ec53 2b1c 	vmov	r2, r3, d12
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 80204da:	4604      	mov	r4, r0
 80204dc:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80204de:	ec51 0b1f 	vmov	r0, r1, d15
 80204e2:	f007 fce1 	bl	8027ea8 <__aeabi_dmul>
 80204e6:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 80204ea:	ec53 2b1d 	vmov	r2, r3, d13
 80204ee:	4606      	mov	r6, r0
 80204f0:	460f      	mov	r7, r1
 80204f2:	4640      	mov	r0, r8
 80204f4:	4649      	mov	r1, r9
 80204f6:	f007 fcd7 	bl	8027ea8 <__aeabi_dmul>
 80204fa:	4602      	mov	r2, r0
 80204fc:	460b      	mov	r3, r1
 80204fe:	4630      	mov	r0, r6
 8020500:	4639      	mov	r1, r7
 8020502:	f007 fb19 	bl	8027b38 <__aeabi_dsub>
 8020506:	4602      	mov	r2, r0
 8020508:	460b      	mov	r3, r1
 802050a:	4620      	mov	r0, r4
 802050c:	4629      	mov	r1, r5
 802050e:	f007 fb15 	bl	8027b3c <__adddf3>
 8020512:	9e06      	ldr	r6, [sp, #24]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020514:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8020518:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802051c:	ec51 0b1f 	vmov	r0, r1, d15
 8020520:	f007 fcc2 	bl	8027ea8 <__aeabi_dmul>
 8020524:	ec53 2b1c 	vmov	r2, r3, d12
 8020528:	4604      	mov	r4, r0
 802052a:	460d      	mov	r5, r1
 802052c:	4640      	mov	r0, r8
 802052e:	4649      	mov	r1, r9
 8020530:	f007 fcba 	bl	8027ea8 <__aeabi_dmul>
 8020534:	4602      	mov	r2, r0
 8020536:	460b      	mov	r3, r1
 8020538:	4620      	mov	r0, r4
 802053a:	4629      	mov	r1, r5
 802053c:	f007 fafe 	bl	8027b3c <__adddf3>
 8020540:	4652      	mov	r2, sl
 8020542:	465b      	mov	r3, fp
 8020544:	f007 fafa 	bl	8027b3c <__adddf3>
 8020548:	9a08      	ldr	r2, [sp, #32]
        for (j = 0; j < n2; j++) {
 802054a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802054c:	3210      	adds	r2, #16
 802054e:	9208      	str	r2, [sp, #32]
 8020550:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8020552:	3301      	adds	r3, #1
 8020554:	3210      	adds	r2, #16
 8020556:	920b      	str	r2, [sp, #44]	; 0x2c
 8020558:	9309      	str	r3, [sp, #36]	; 0x24
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802055a:	e8e6 0104 	strd	r0, r1, [r6], #16
        for (j = 0; j < n2; j++) {
 802055e:	9a07      	ldr	r2, [sp, #28]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020560:	9606      	str	r6, [sp, #24]
        for (j = 0; j < n2; j++) {
 8020562:	429a      	cmp	r2, r3
 8020564:	f47f aea6 	bne.w	80202b4 <cblas_zsymm+0x344>
      for (i = 0; i < n1; i++) {
 8020568:	9901      	ldr	r1, [sp, #4]
 802056a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802056c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802056e:	4608      	mov	r0, r1
 8020570:	4410      	add	r0, r2
 8020572:	9001      	str	r0, [sp, #4]
 8020574:	e9dd 1012 	ldrd	r1, r0, [sp, #72]	; 0x48
 8020578:	4401      	add	r1, r0
 802057a:	9112      	str	r1, [sp, #72]	; 0x48
 802057c:	9814      	ldr	r0, [sp, #80]	; 0x50
 802057e:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8020580:	4401      	add	r1, r0
 8020582:	910f      	str	r1, [sp, #60]	; 0x3c
 8020584:	9815      	ldr	r0, [sp, #84]	; 0x54
 8020586:	990e      	ldr	r1, [sp, #56]	; 0x38
 8020588:	4401      	add	r1, r0
 802058a:	910e      	str	r1, [sp, #56]	; 0x38
 802058c:	990d      	ldr	r1, [sp, #52]	; 0x34
 802058e:	4411      	add	r1, r2
 8020590:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020592:	910d      	str	r1, [sp, #52]	; 0x34
 8020594:	3301      	adds	r3, #1
 8020596:	429a      	cmp	r2, r3
 8020598:	930c      	str	r3, [sp, #48]	; 0x30
 802059a:	f47f ae79 	bne.w	8020290 <cblas_zsymm+0x320>
 802059e:	e5ba      	b.n	8020116 <cblas_zsymm+0x1a6>
	...
    } else if (side == CblasRight && uplo == CblasUpper) {
 80205a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80205aa:	2b79      	cmp	r3, #121	; 0x79
 80205ac:	f000 83c0 	beq.w	8020d30 <cblas_zsymm+0xdc0>
    } else if (side == CblasRight && uplo == CblasLower) {
 80205b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80205b2:	2b7a      	cmp	r3, #122	; 0x7a
 80205b4:	f47f ad93 	bne.w	80200de <cblas_zsymm+0x16e>
      for (i = 0; i < n1; i++) {
 80205b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80205ba:	2b00      	cmp	r3, #0
 80205bc:	f77f adab 	ble.w	8020116 <cblas_zsymm+0x1a6>
 80205c0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80205c2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80205c4:	0112      	lsls	r2, r2, #4
 80205c6:	9215      	str	r2, [sp, #84]	; 0x54
 80205c8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80205ca:	0112      	lsls	r2, r2, #4
 80205cc:	3301      	adds	r3, #1
 80205ce:	9213      	str	r2, [sp, #76]	; 0x4c
 80205d0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80205d2:	920d      	str	r2, [sp, #52]	; 0x34
 80205d4:	011a      	lsls	r2, r3, #4
 80205d6:	9211      	str	r2, [sp, #68]	; 0x44
 80205d8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80205da:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 80205de:	9314      	str	r3, [sp, #80]	; 0x50
 80205e0:	2300      	movs	r3, #0
 80205e2:	9312      	str	r3, [sp, #72]	; 0x48
        for (j = 0; j < n2; j++) {
 80205e4:	9b07      	ldr	r3, [sp, #28]
 80205e6:	2b00      	cmp	r3, #0
 80205e8:	f340 8547 	ble.w	802107a <cblas_zsymm+0x110a>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 80205ec:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 80205ee:	e9d4 8900 	ldrd	r8, r9, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80205f2:	ec53 2b1f 	vmov	r2, r3, d15
 80205f6:	4640      	mov	r0, r8
 80205f8:	4649      	mov	r1, r9
 80205fa:	f007 fc55 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 80205fe:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020602:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8020606:	4604      	mov	r4, r0
 8020608:	460d      	mov	r5, r1
 802060a:	4652      	mov	r2, sl
 802060c:	465b      	mov	r3, fp
 802060e:	4630      	mov	r0, r6
 8020610:	4639      	mov	r1, r7
 8020612:	f007 fc49 	bl	8027ea8 <__aeabi_dmul>
 8020616:	4602      	mov	r2, r0
 8020618:	460b      	mov	r3, r1
 802061a:	4620      	mov	r0, r4
 802061c:	4629      	mov	r1, r5
 802061e:	f007 fa8b 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020622:	4652      	mov	r2, sl
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020624:	4604      	mov	r4, r0
 8020626:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020628:	465b      	mov	r3, fp
 802062a:	4640      	mov	r0, r8
 802062c:	4649      	mov	r1, r9
 802062e:	f007 fc3b 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020632:	ec45 4b1b 	vmov	d11, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020636:	ec53 2b1f 	vmov	r2, r3, d15
 802063a:	4604      	mov	r4, r0
 802063c:	460d      	mov	r5, r1
 802063e:	4630      	mov	r0, r6
 8020640:	4639      	mov	r1, r7
 8020642:	f007 fc31 	bl	8027ea8 <__aeabi_dmul>
 8020646:	460b      	mov	r3, r1
 8020648:	4602      	mov	r2, r0
 802064a:	4629      	mov	r1, r5
 802064c:	4620      	mov	r0, r4
 802064e:	f007 fa75 	bl	8027b3c <__adddf3>
 8020652:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020654:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8020656:	940b      	str	r4, [sp, #44]	; 0x2c
 8020658:	3308      	adds	r3, #8
 802065a:	9308      	str	r3, [sp, #32]
 802065c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802065e:	9303      	str	r3, [sp, #12]
 8020660:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020662:	9309      	str	r3, [sp, #36]	; 0x24
          BASE temp2_imag = 0.0;
 8020664:	ed1f 7b32 	vldr	d7, [pc, #-200]	; 80205a0 <cblas_zsymm+0x630>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020668:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802066a:	9306      	str	r3, [sp, #24]
 802066c:	ec41 0b1a 	vmov	d10, r0, r1
          BASE temp2_imag = 0.0;
 8020670:	eeb0 da47 	vmov.f32	s26, s14
 8020674:	eef0 da67 	vmov.f32	s27, s15
        for (j = 0; j < n2; j++) {
 8020678:	2300      	movs	r3, #0
 802067a:	930c      	str	r3, [sp, #48]	; 0x30
          BASE temp2_real = 0.0;
 802067c:	eeb0 ca47 	vmov.f32	s24, s14
 8020680:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8020684:	9c08      	ldr	r4, [sp, #32]
 8020686:	e9d4 6700 	ldrd	r6, r7, [r4]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 802068a:	ec53 2b1b 	vmov	r2, r3, d11
 802068e:	4630      	mov	r0, r6
 8020690:	4639      	mov	r1, r7
 8020692:	f007 fc09 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8020696:	e954 8902 	ldrd	r8, r9, [r4, #-8]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 802069a:	ec5b ab1a 	vmov	sl, fp, d10
 802069e:	4604      	mov	r4, r0
 80206a0:	465b      	mov	r3, fp
 80206a2:	460d      	mov	r5, r1
 80206a4:	ee1a 2a10 	vmov	r2, s20
 80206a8:	4640      	mov	r0, r8
 80206aa:	4649      	mov	r1, r9
 80206ac:	f007 fbfc 	bl	8027ea8 <__aeabi_dmul>
 80206b0:	4602      	mov	r2, r0
 80206b2:	460b      	mov	r3, r1
 80206b4:	4620      	mov	r0, r4
 80206b6:	4629      	mov	r1, r5
 80206b8:	f007 fa40 	bl	8027b3c <__adddf3>
 80206bc:	9b06      	ldr	r3, [sp, #24]
 80206be:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
 80206c2:	f007 fa3b 	bl	8027b3c <__adddf3>
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80206c6:	ec53 2b1b 	vmov	r2, r3, d11
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80206ca:	4604      	mov	r4, r0
 80206cc:	460d      	mov	r5, r1
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80206ce:	4640      	mov	r0, r8
 80206d0:	4649      	mov	r1, r9
 80206d2:	f007 fbe9 	bl	8027ea8 <__aeabi_dmul>
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80206d6:	46a0      	mov	r8, r4
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80206d8:	465b      	mov	r3, fp
 80206da:	4604      	mov	r4, r0
 80206dc:	ee1a 2a10 	vmov	r2, s20
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 80206e0:	46a9      	mov	r9, r5
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 80206e2:	4630      	mov	r0, r6
 80206e4:	460d      	mov	r5, r1
 80206e6:	4639      	mov	r1, r7
 80206e8:	f007 fbde 	bl	8027ea8 <__aeabi_dmul>
 80206ec:	4602      	mov	r2, r0
 80206ee:	460b      	mov	r3, r1
 80206f0:	4620      	mov	r0, r4
 80206f2:	4629      	mov	r1, r5
 80206f4:	f007 fa20 	bl	8027b38 <__aeabi_dsub>
 80206f8:	9a06      	ldr	r2, [sp, #24]
 80206fa:	e9d2 2300 	ldrd	r2, r3, [r2]
 80206fe:	f007 fa1d 	bl	8027b3c <__adddf3>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8020702:	ec53 2b1c 	vmov	r2, r3, d12
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8020706:	4604      	mov	r4, r0
 8020708:	460d      	mov	r5, r1
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 802070a:	ec51 0b1f 	vmov	r0, r1, d15
 802070e:	f007 fbcb 	bl	8027ea8 <__aeabi_dmul>
 8020712:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8020716:	ec53 2b1d 	vmov	r2, r3, d13
 802071a:	4606      	mov	r6, r0
 802071c:	460f      	mov	r7, r1
 802071e:	4650      	mov	r0, sl
 8020720:	4659      	mov	r1, fp
 8020722:	f007 fbc1 	bl	8027ea8 <__aeabi_dmul>
 8020726:	4602      	mov	r2, r0
 8020728:	460b      	mov	r3, r1
 802072a:	4630      	mov	r0, r6
 802072c:	4639      	mov	r1, r7
 802072e:	f007 fa03 	bl	8027b38 <__aeabi_dsub>
 8020732:	4602      	mov	r2, r0
 8020734:	460b      	mov	r3, r1
 8020736:	4620      	mov	r0, r4
 8020738:	4629      	mov	r1, r5
 802073a:	f007 f9ff 	bl	8027b3c <__adddf3>
 802073e:	9e06      	ldr	r6, [sp, #24]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020740:	ec53 2b1d 	vmov	r2, r3, d13
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8020744:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020748:	ec51 0b1f 	vmov	r0, r1, d15
 802074c:	f007 fbac 	bl	8027ea8 <__aeabi_dmul>
 8020750:	ec53 2b1c 	vmov	r2, r3, d12
 8020754:	4604      	mov	r4, r0
 8020756:	460d      	mov	r5, r1
 8020758:	4650      	mov	r0, sl
 802075a:	4659      	mov	r1, fp
 802075c:	f007 fba4 	bl	8027ea8 <__aeabi_dmul>
 8020760:	4602      	mov	r2, r0
 8020762:	460b      	mov	r3, r1
 8020764:	4620      	mov	r0, r4
 8020766:	4629      	mov	r1, r5
 8020768:	f007 f9e8 	bl	8027b3c <__adddf3>
 802076c:	4642      	mov	r2, r8
 802076e:	464b      	mov	r3, r9
 8020770:	f007 f9e4 	bl	8027b3c <__adddf3>
        for (j = 0; j < n2; j++) {
 8020774:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8020776:	9a07      	ldr	r2, [sp, #28]
 8020778:	3301      	adds	r3, #1
 802077a:	429a      	cmp	r2, r3
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802077c:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8020780:	930c      	str	r3, [sp, #48]	; 0x30
 8020782:	f000 847a 	beq.w	802107a <cblas_zsymm+0x110a>
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8020786:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8020788:	e9d4 6704 	ldrd	r6, r7, [r4, #16]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802078c:	ec51 0b1f 	vmov	r0, r1, d15
 8020790:	4632      	mov	r2, r6
 8020792:	463b      	mov	r3, r7
 8020794:	f007 fb88 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8020798:	e9d4 8906 	ldrd	r8, r9, [r4, #24]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802079c:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 80207a0:	4604      	mov	r4, r0
 80207a2:	460d      	mov	r5, r1
 80207a4:	4642      	mov	r2, r8
 80207a6:	464b      	mov	r3, r9
 80207a8:	4650      	mov	r0, sl
 80207aa:	4659      	mov	r1, fp
 80207ac:	f007 fb7c 	bl	8027ea8 <__aeabi_dmul>
 80207b0:	4602      	mov	r2, r0
 80207b2:	460b      	mov	r3, r1
 80207b4:	4620      	mov	r0, r4
 80207b6:	4629      	mov	r1, r5
 80207b8:	f007 f9be 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80207bc:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80207be:	4604      	mov	r4, r0
 80207c0:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80207c2:	464b      	mov	r3, r9
 80207c4:	ec51 0b1f 	vmov	r0, r1, d15
 80207c8:	f007 fb6e 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80207cc:	ec45 4b1b 	vmov	d11, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80207d0:	4632      	mov	r2, r6
 80207d2:	463b      	mov	r3, r7
 80207d4:	4604      	mov	r4, r0
 80207d6:	460d      	mov	r5, r1
 80207d8:	4650      	mov	r0, sl
 80207da:	4659      	mov	r1, fp
 80207dc:	f007 fb64 	bl	8027ea8 <__aeabi_dmul>
 80207e0:	4602      	mov	r2, r0
 80207e2:	460b      	mov	r3, r1
 80207e4:	4620      	mov	r0, r4
 80207e6:	4629      	mov	r1, r5
 80207e8:	f007 f9a8 	bl	8027b3c <__adddf3>
 80207ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80207ee:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80207f0:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 80207f4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80207f6:	9301      	str	r3, [sp, #4]
          BASE temp2_imag = 0.0;
 80207f8:	ed1f 7b97 	vldr	d7, [pc, #-604]	; 80205a0 <cblas_zsymm+0x630>
 80207fc:	f103 0b08 	add.w	fp, r3, #8
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020800:	ec41 0b1a 	vmov	d10, r0, r1
          BASE temp2_imag = 0.0;
 8020804:	eeb0 da47 	vmov.f32	s26, s14
 8020808:	eef0 da67 	vmov.f32	s27, s15
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802080c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802080e:	9302      	str	r3, [sp, #8]
          BASE temp2_real = 0.0;
 8020810:	eeb0 ca47 	vmov.f32	s24, s14
 8020814:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8020818:	e9da 8900 	ldrd	r8, r9, [sl]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 802081c:	ec51 0b1b 	vmov	r0, r1, d11
 8020820:	4642      	mov	r2, r8
 8020822:	464b      	mov	r3, r9
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8020824:	e9da 4502 	ldrd	r4, r5, [sl, #8]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8020828:	f007 fb3e 	bl	8027ea8 <__aeabi_dmul>
 802082c:	4622      	mov	r2, r4
 802082e:	4606      	mov	r6, r0
 8020830:	460f      	mov	r7, r1
 8020832:	462b      	mov	r3, r5
 8020834:	ec51 0b1a 	vmov	r0, r1, d10
 8020838:	f007 fb36 	bl	8027ea8 <__aeabi_dmul>
 802083c:	4602      	mov	r2, r0
 802083e:	460b      	mov	r3, r1
 8020840:	4630      	mov	r0, r6
 8020842:	4639      	mov	r1, r7
 8020844:	f007 f978 	bl	8027b38 <__aeabi_dsub>
 8020848:	4602      	mov	r2, r0
 802084a:	460b      	mov	r3, r1
 802084c:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8020850:	f007 f974 	bl	8027b3c <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8020854:	9b02      	ldr	r3, [sp, #8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8020856:	4622      	mov	r2, r4
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8020858:	ed93 8b00 	vldr	d8, [r3]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 802085c:	ed93 9b02 	vldr	d9, [r3, #8]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8020860:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8020864:	462b      	mov	r3, r5
 8020866:	ec51 0b1b 	vmov	r0, r1, d11
 802086a:	f007 fb1d 	bl	8027ea8 <__aeabi_dmul>
 802086e:	4642      	mov	r2, r8
 8020870:	4606      	mov	r6, r0
 8020872:	460f      	mov	r7, r1
 8020874:	464b      	mov	r3, r9
 8020876:	ec51 0b1a 	vmov	r0, r1, d10
 802087a:	f007 fb15 	bl	8027ea8 <__aeabi_dmul>
 802087e:	4602      	mov	r2, r0
 8020880:	460b      	mov	r3, r1
 8020882:	4630      	mov	r0, r6
 8020884:	4639      	mov	r1, r7
 8020886:	f007 f959 	bl	8027b3c <__adddf3>
 802088a:	9e01      	ldr	r6, [sp, #4]
 802088c:	4602      	mov	r2, r0
 802088e:	460b      	mov	r3, r1
 8020890:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8020894:	f007 f952 	bl	8027b3c <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8020898:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 802089c:	e9c6 0102 	strd	r0, r1, [r6, #8]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 80208a0:	4640      	mov	r0, r8
 80208a2:	4649      	mov	r1, r9
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 80208a4:	9601      	str	r6, [sp, #4]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 80208a6:	f007 faff 	bl	8027ea8 <__aeabi_dmul>
 80208aa:	ec53 2b19 	vmov	r2, r3, d9
 80208ae:	4606      	mov	r6, r0
 80208b0:	460f      	mov	r7, r1
 80208b2:	4620      	mov	r0, r4
 80208b4:	4629      	mov	r1, r5
 80208b6:	f007 faf7 	bl	8027ea8 <__aeabi_dmul>
 80208ba:	4602      	mov	r2, r0
 80208bc:	460b      	mov	r3, r1
 80208be:	4630      	mov	r0, r6
 80208c0:	4639      	mov	r1, r7
 80208c2:	f007 f939 	bl	8027b38 <__aeabi_dsub>
 80208c6:	4602      	mov	r2, r0
 80208c8:	460b      	mov	r3, r1
 80208ca:	ec51 0b1c 	vmov	r0, r1, d12
 80208ce:	f007 f935 	bl	8027b3c <__adddf3>
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 80208d2:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 80208d6:	4606      	mov	r6, r0
 80208d8:	460f      	mov	r7, r1
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 80208da:	4620      	mov	r0, r4
 80208dc:	4629      	mov	r1, r5
 80208de:	f007 fae3 	bl	8027ea8 <__aeabi_dmul>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 80208e2:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 80208e6:	ec53 2b19 	vmov	r2, r3, d9
 80208ea:	4606      	mov	r6, r0
 80208ec:	460f      	mov	r7, r1
 80208ee:	4640      	mov	r0, r8
 80208f0:	4649      	mov	r1, r9
 80208f2:	f007 fad9 	bl	8027ea8 <__aeabi_dmul>
 80208f6:	4602      	mov	r2, r0
 80208f8:	460b      	mov	r3, r1
 80208fa:	4630      	mov	r0, r6
 80208fc:	4639      	mov	r1, r7
 80208fe:	f007 f91d 	bl	8027b3c <__adddf3>
 8020902:	460b      	mov	r3, r1
 8020904:	4602      	mov	r2, r0
 8020906:	ec51 0b1d 	vmov	r0, r1, d13
 802090a:	f007 f917 	bl	8027b3c <__adddf3>
 802090e:	9b02      	ldr	r3, [sp, #8]
 8020910:	9e01      	ldr	r6, [sp, #4]
 8020912:	3310      	adds	r3, #16
 8020914:	9302      	str	r3, [sp, #8]
 8020916:	f106 0310 	add.w	r3, r6, #16
 802091a:	9301      	str	r3, [sp, #4]
          for (k = 0; k < j; k++) {
 802091c:	9b03      	ldr	r3, [sp, #12]
 802091e:	f10a 0a10 	add.w	sl, sl, #16
 8020922:	4553      	cmp	r3, sl
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8020924:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = 0; k < j; k++) {
 8020928:	f10b 0b10 	add.w	fp, fp, #16
 802092c:	f47f af74 	bne.w	8020818 <cblas_zsymm+0x8a8>
 8020930:	9b06      	ldr	r3, [sp, #24]
 8020932:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8020934:	3310      	adds	r3, #16
 8020936:	9306      	str	r3, [sp, #24]
 8020938:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802093a:	3310      	adds	r3, #16
 802093c:	930b      	str	r3, [sp, #44]	; 0x2c
 802093e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020940:	4413      	add	r3, r2
 8020942:	9a03      	ldr	r2, [sp, #12]
 8020944:	9309      	str	r3, [sp, #36]	; 0x24
 8020946:	4611      	mov	r1, r2
 8020948:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802094a:	9a08      	ldr	r2, [sp, #32]
 802094c:	4419      	add	r1, r3
 802094e:	441a      	add	r2, r3
 8020950:	9103      	str	r1, [sp, #12]
 8020952:	9208      	str	r2, [sp, #32]
 8020954:	e696      	b.n	8020684 <cblas_zsymm+0x714>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8020956:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020958:	9a14      	ldr	r2, [sp, #80]	; 0x50
 802095a:	2b01      	cmp	r3, #1
 802095c:	bfb8      	it	lt
 802095e:	2301      	movlt	r3, #1
 8020960:	4293      	cmp	r3, r2
 8020962:	f300 8381 	bgt.w	8021068 <cblas_zsymm+0x10f8>
 8020966:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8020968:	4293      	cmp	r3, r2
 802096a:	bfcc      	ite	gt
 802096c:	200d      	movgt	r0, #13
 802096e:	2008      	movle	r0, #8
 8020970:	f7ff bb3a 	b.w	801ffe8 <cblas_zsymm+0x78>
 8020974:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020976:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8020978:	2b01      	cmp	r3, #1
 802097a:	bfb8      	it	lt
 802097c:	2301      	movlt	r3, #1
 802097e:	4293      	cmp	r3, r2
 8020980:	f300 8372 	bgt.w	8021068 <cblas_zsymm+0x10f8>
 8020984:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8020986:	4293      	cmp	r3, r2
 8020988:	f77f abb9 	ble.w	80200fe <cblas_zsymm+0x18e>
 802098c:	200d      	movs	r0, #13
 802098e:	f7ff bb2b 	b.w	801ffe8 <cblas_zsymm+0x78>
      for (i = 0; i < n1; i++) {
 8020992:	990a      	ldr	r1, [sp, #40]	; 0x28
 8020994:	2900      	cmp	r1, #0
 8020996:	f77f abbe 	ble.w	8020116 <cblas_zsymm+0x1a6>
 802099a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802099c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 802099e:	920b      	str	r2, [sp, #44]	; 0x2c
 80209a0:	3301      	adds	r3, #1
 80209a2:	0118      	lsls	r0, r3, #4
 80209a4:	f1a2 0310 	sub.w	r3, r2, #16
 80209a8:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 80209ac:	9302      	str	r3, [sp, #8]
 80209ae:	f102 0308 	add.w	r3, r2, #8
 80209b2:	930e      	str	r3, [sp, #56]	; 0x38
 80209b4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80209b6:	901b      	str	r0, [sp, #108]	; 0x6c
 80209b8:	011a      	lsls	r2, r3, #4
 80209ba:	9206      	str	r2, [sp, #24]
 80209bc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80209be:	2400      	movs	r4, #0
 80209c0:	e9cd 2315 	strd	r2, r3, [sp, #84]	; 0x54
 80209c4:	3810      	subs	r0, #16
 80209c6:	0111      	lsls	r1, r2, #4
 80209c8:	2301      	movs	r3, #1
 80209ca:	9417      	str	r4, [sp, #92]	; 0x5c
 80209cc:	901a      	str	r0, [sp, #104]	; 0x68
 80209ce:	9418      	str	r4, [sp, #96]	; 0x60
 80209d0:	9103      	str	r1, [sp, #12]
 80209d2:	930d      	str	r3, [sp, #52]	; 0x34
        for (j = 0; j < n2; j++) {
 80209d4:	9b07      	ldr	r3, [sp, #28]
 80209d6:	2b00      	cmp	r3, #0
 80209d8:	f340 83b3 	ble.w	8021142 <cblas_zsymm+0x11d2>
 80209dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80209de:	9918      	ldr	r1, [sp, #96]	; 0x60
 80209e0:	9817      	ldr	r0, [sp, #92]	; 0x5c
 80209e2:	1a5a      	subs	r2, r3, r1
 80209e4:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80209e6:	1a1b      	subs	r3, r3, r0
 80209e8:	011b      	lsls	r3, r3, #4
 80209ea:	3308      	adds	r3, #8
 80209ec:	9312      	str	r3, [sp, #72]	; 0x48
 80209ee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80209f0:	9319      	str	r3, [sp, #100]	; 0x64
 80209f2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80209f4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
 80209f8:	9309      	str	r3, [sp, #36]	; 0x24
 80209fa:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80209fc:	0112      	lsls	r2, r2, #4
 80209fe:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 8020a02:	3208      	adds	r2, #8
 8020a04:	9308      	str	r3, [sp, #32]
 8020a06:	2300      	movs	r3, #0
 8020a08:	920f      	str	r2, [sp, #60]	; 0x3c
 8020a0a:	930c      	str	r3, [sp, #48]	; 0x30
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8020a0c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8020a0e:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020a12:	ec51 0b1f 	vmov	r0, r1, d15
 8020a16:	4632      	mov	r2, r6
 8020a18:	463b      	mov	r3, r7
 8020a1a:	f007 fa45 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8020a1e:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020a22:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8020a26:	4642      	mov	r2, r8
 8020a28:	464b      	mov	r3, r9
 8020a2a:	4604      	mov	r4, r0
 8020a2c:	460d      	mov	r5, r1
 8020a2e:	4650      	mov	r0, sl
 8020a30:	4659      	mov	r1, fp
 8020a32:	f007 fa39 	bl	8027ea8 <__aeabi_dmul>
 8020a36:	4602      	mov	r2, r0
 8020a38:	460b      	mov	r3, r1
 8020a3a:	4620      	mov	r0, r4
 8020a3c:	4629      	mov	r1, r5
 8020a3e:	f007 f87b 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020a42:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020a44:	4604      	mov	r4, r0
 8020a46:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020a48:	464b      	mov	r3, r9
 8020a4a:	ec51 0b1f 	vmov	r0, r1, d15
 8020a4e:	f007 fa2b 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020a52:	ec45 4b18 	vmov	d8, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020a56:	4632      	mov	r2, r6
 8020a58:	463b      	mov	r3, r7
 8020a5a:	4604      	mov	r4, r0
 8020a5c:	460d      	mov	r5, r1
 8020a5e:	4650      	mov	r0, sl
 8020a60:	4659      	mov	r1, fp
 8020a62:	f007 fa21 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020a66:	eeb0 ba48 	vmov.f32	s22, s16
 8020a6a:	eef0 ba68 	vmov.f32	s23, s17
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020a6e:	4602      	mov	r2, r0
 8020a70:	460b      	mov	r3, r1
 8020a72:	4620      	mov	r0, r4
 8020a74:	4629      	mov	r1, r5
 8020a76:	f007 f861 	bl	8027b3c <__adddf3>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8020a7a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8020a7c:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8020a7e:	e953 6702 	ldrd	r6, r7, [r3, #-8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020a82:	4682      	mov	sl, r0
 8020a84:	468b      	mov	fp, r1
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8020a86:	4632      	mov	r2, r6
 8020a88:	463b      	mov	r3, r7
 8020a8a:	ec51 0b18 	vmov	r0, r1, d8
 8020a8e:	f007 fa0b 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
 8020a92:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8020a96:	4604      	mov	r4, r0
 8020a98:	460d      	mov	r5, r1
 8020a9a:	4642      	mov	r2, r8
 8020a9c:	464b      	mov	r3, r9
 8020a9e:	4650      	mov	r0, sl
 8020aa0:	4659      	mov	r1, fp
 8020aa2:	f007 fa01 	bl	8027ea8 <__aeabi_dmul>
 8020aa6:	4602      	mov	r2, r0
 8020aa8:	460b      	mov	r3, r1
 8020aaa:	4620      	mov	r0, r4
 8020aac:	4629      	mov	r1, r5
 8020aae:	f007 f843 	bl	8027b38 <__aeabi_dsub>
 8020ab2:	9c08      	ldr	r4, [sp, #32]
 8020ab4:	4602      	mov	r2, r0
 8020ab6:	460b      	mov	r3, r1
 8020ab8:	e9d4 0100 	ldrd	r0, r1, [r4]
 8020abc:	f007 f83e 	bl	8027b3c <__adddf3>
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8020ac0:	4642      	mov	r2, r8
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8020ac2:	e9c4 0100 	strd	r0, r1, [r4]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8020ac6:	464b      	mov	r3, r9
 8020ac8:	ec51 0b18 	vmov	r0, r1, d8
            REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
 8020acc:	9408      	str	r4, [sp, #32]
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8020ace:	f007 f9eb 	bl	8027ea8 <__aeabi_dmul>
 8020ad2:	4632      	mov	r2, r6
 8020ad4:	4604      	mov	r4, r0
 8020ad6:	463b      	mov	r3, r7
 8020ad8:	460d      	mov	r5, r1
 8020ada:	4650      	mov	r0, sl
 8020adc:	4659      	mov	r1, fp
 8020ade:	f007 f9e3 	bl	8027ea8 <__aeabi_dmul>
 8020ae2:	4602      	mov	r2, r0
 8020ae4:	460b      	mov	r3, r1
 8020ae6:	4620      	mov	r0, r4
 8020ae8:	4629      	mov	r1, r5
 8020aea:	f007 f827 	bl	8027b3c <__adddf3>
 8020aee:	9c08      	ldr	r4, [sp, #32]
 8020af0:	4602      	mov	r2, r0
 8020af2:	460b      	mov	r3, r1
 8020af4:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8020af8:	f007 f820 	bl	8027b3c <__adddf3>
          BASE temp2_imag = 0.0;
 8020afc:	ed9f 7b8a 	vldr	d7, [pc, #552]	; 8020d28 <cblas_zsymm+0xdb8>
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8020b00:	e9c4 0102 	strd	r0, r1, [r4, #8]
          BASE temp2_imag = 0.0;
 8020b04:	eeb0 da47 	vmov.f32	s26, s14
 8020b08:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 8020b0c:	eeb0 ca47 	vmov.f32	s24, s14
 8020b10:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 8020b14:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8020b16:	990d      	ldr	r1, [sp, #52]	; 0x34
 8020b18:	428a      	cmp	r2, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020b1a:	ec4b ab1a 	vmov	d10, sl, fp
            IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
 8020b1e:	4623      	mov	r3, r4
          for (k = i + 1; k < n1; k++) {
 8020b20:	f340 8090 	ble.w	8020c44 <cblas_zsymm+0xcd4>
 8020b24:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8020b26:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8020b28:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
 8020b2c:	4422      	add	r2, r4
 8020b2e:	9201      	str	r2, [sp, #4]
 8020b30:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8020b32:	eb02 0a03 	add.w	sl, r2, r3
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8020b36:	e9db 4504 	ldrd	r4, r5, [fp, #16]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8020b3a:	ec51 0b1b 	vmov	r0, r1, d11
 8020b3e:	4622      	mov	r2, r4
 8020b40:	462b      	mov	r3, r5
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8020b42:	e9db 8906 	ldrd	r8, r9, [fp, #24]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8020b46:	f007 f9af 	bl	8027ea8 <__aeabi_dmul>
 8020b4a:	4642      	mov	r2, r8
 8020b4c:	4606      	mov	r6, r0
 8020b4e:	460f      	mov	r7, r1
 8020b50:	464b      	mov	r3, r9
 8020b52:	ec51 0b1a 	vmov	r0, r1, d10
 8020b56:	f007 f9a7 	bl	8027ea8 <__aeabi_dmul>
 8020b5a:	4602      	mov	r2, r0
 8020b5c:	460b      	mov	r3, r1
 8020b5e:	4630      	mov	r0, r6
 8020b60:	4639      	mov	r1, r7
 8020b62:	f006 ffe9 	bl	8027b38 <__aeabi_dsub>
 8020b66:	4602      	mov	r2, r0
 8020b68:	460b      	mov	r3, r1
 8020b6a:	e95a 0102 	ldrd	r0, r1, [sl, #-8]
 8020b6e:	f006 ffe5 	bl	8027b3c <__adddf3>
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8020b72:	9b01      	ldr	r3, [sp, #4]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8020b74:	4622      	mov	r2, r4
            const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
 8020b76:	ed13 8b02 	vldr	d8, [r3, #-8]
            const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
 8020b7a:	ed93 9b00 	vldr	d9, [r3]
            REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
 8020b7e:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8020b82:	462b      	mov	r3, r5
 8020b84:	ec51 0b1a 	vmov	r0, r1, d10
 8020b88:	f007 f98e 	bl	8027ea8 <__aeabi_dmul>
 8020b8c:	4642      	mov	r2, r8
 8020b8e:	4606      	mov	r6, r0
 8020b90:	460f      	mov	r7, r1
 8020b92:	464b      	mov	r3, r9
 8020b94:	ec51 0b1b 	vmov	r0, r1, d11
 8020b98:	f007 f986 	bl	8027ea8 <__aeabi_dmul>
 8020b9c:	4602      	mov	r2, r0
 8020b9e:	460b      	mov	r3, r1
 8020ba0:	4630      	mov	r0, r6
 8020ba2:	4639      	mov	r1, r7
 8020ba4:	f006 ffca 	bl	8027b3c <__adddf3>
 8020ba8:	4602      	mov	r2, r0
 8020baa:	460b      	mov	r3, r1
 8020bac:	e9da 0100 	ldrd	r0, r1, [sl]
 8020bb0:	f006 ffc4 	bl	8027b3c <__adddf3>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8020bb4:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
 8020bb8:	e9ca 0100 	strd	r0, r1, [sl]
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8020bbc:	4620      	mov	r0, r4
 8020bbe:	4629      	mov	r1, r5
 8020bc0:	f007 f972 	bl	8027ea8 <__aeabi_dmul>
 8020bc4:	ec53 2b19 	vmov	r2, r3, d9
 8020bc8:	4606      	mov	r6, r0
 8020bca:	460f      	mov	r7, r1
 8020bcc:	4640      	mov	r0, r8
 8020bce:	4649      	mov	r1, r9
 8020bd0:	f007 f96a 	bl	8027ea8 <__aeabi_dmul>
 8020bd4:	4602      	mov	r2, r0
 8020bd6:	460b      	mov	r3, r1
 8020bd8:	4630      	mov	r0, r6
 8020bda:	4639      	mov	r1, r7
 8020bdc:	f006 ffac 	bl	8027b38 <__aeabi_dsub>
 8020be0:	4602      	mov	r2, r0
 8020be2:	460b      	mov	r3, r1
 8020be4:	ec51 0b1c 	vmov	r0, r1, d12
 8020be8:	f006 ffa8 	bl	8027b3c <__adddf3>
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8020bec:	ec53 2b19 	vmov	r2, r3, d9
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8020bf0:	4606      	mov	r6, r0
 8020bf2:	460f      	mov	r7, r1
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8020bf4:	4620      	mov	r0, r4
 8020bf6:	4629      	mov	r1, r5
 8020bf8:	f007 f956 	bl	8027ea8 <__aeabi_dmul>
            temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8020bfc:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8020c00:	ec53 2b18 	vmov	r2, r3, d8
 8020c04:	4606      	mov	r6, r0
 8020c06:	460f      	mov	r7, r1
 8020c08:	4640      	mov	r0, r8
 8020c0a:	4649      	mov	r1, r9
 8020c0c:	f007 f94c 	bl	8027ea8 <__aeabi_dmul>
 8020c10:	4602      	mov	r2, r0
 8020c12:	460b      	mov	r3, r1
 8020c14:	4630      	mov	r0, r6
 8020c16:	4639      	mov	r1, r7
 8020c18:	f006 ff90 	bl	8027b3c <__adddf3>
 8020c1c:	4602      	mov	r2, r0
 8020c1e:	460b      	mov	r3, r1
 8020c20:	ec51 0b1d 	vmov	r0, r1, d13
 8020c24:	f006 ff8a 	bl	8027b3c <__adddf3>
 8020c28:	9b01      	ldr	r3, [sp, #4]
 8020c2a:	9a06      	ldr	r2, [sp, #24]
 8020c2c:	4413      	add	r3, r2
 8020c2e:	9301      	str	r3, [sp, #4]
 8020c30:	9b03      	ldr	r3, [sp, #12]
 8020c32:	449a      	add	sl, r3
          for (k = i + 1; k < n1; k++) {
 8020c34:	9b02      	ldr	r3, [sp, #8]
 8020c36:	f10b 0b10 	add.w	fp, fp, #16
 8020c3a:	455b      	cmp	r3, fp
            temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8020c3c:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = i + 1; k < n1; k++) {
 8020c40:	f47f af79 	bne.w	8020b36 <cblas_zsymm+0xbc6>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8020c44:	ec53 2b1c 	vmov	r2, r3, d12
 8020c48:	ec51 0b1f 	vmov	r0, r1, d15
 8020c4c:	f007 f92c 	bl	8027ea8 <__aeabi_dmul>
 8020c50:	e9dd 7804 	ldrd	r7, r8, [sp, #16]
 8020c54:	ec5a 9b1d 	vmov	r9, sl, d13
 8020c58:	4604      	mov	r4, r0
 8020c5a:	460d      	mov	r5, r1
 8020c5c:	ee1d 2a10 	vmov	r2, s26
 8020c60:	4653      	mov	r3, sl
 8020c62:	4638      	mov	r0, r7
 8020c64:	4641      	mov	r1, r8
 8020c66:	f007 f91f 	bl	8027ea8 <__aeabi_dmul>
 8020c6a:	4602      	mov	r2, r0
 8020c6c:	460b      	mov	r3, r1
 8020c6e:	4620      	mov	r0, r4
 8020c70:	4629      	mov	r1, r5
 8020c72:	f006 ff61 	bl	8027b38 <__aeabi_dsub>
 8020c76:	9e08      	ldr	r6, [sp, #32]
 8020c78:	4602      	mov	r2, r0
 8020c7a:	460b      	mov	r3, r1
 8020c7c:	e9d6 0100 	ldrd	r0, r1, [r6]
 8020c80:	f006 ff5c 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020c84:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8020c88:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020c8c:	4653      	mov	r3, sl
 8020c8e:	ec51 0b1f 	vmov	r0, r1, d15
 8020c92:	f007 f909 	bl	8027ea8 <__aeabi_dmul>
 8020c96:	ec53 2b1c 	vmov	r2, r3, d12
 8020c9a:	4604      	mov	r4, r0
 8020c9c:	460d      	mov	r5, r1
 8020c9e:	4638      	mov	r0, r7
 8020ca0:	4641      	mov	r1, r8
 8020ca2:	f007 f901 	bl	8027ea8 <__aeabi_dmul>
 8020ca6:	4602      	mov	r2, r0
 8020ca8:	460b      	mov	r3, r1
 8020caa:	4620      	mov	r0, r4
 8020cac:	4629      	mov	r1, r5
 8020cae:	f006 ff45 	bl	8027b3c <__adddf3>
 8020cb2:	4602      	mov	r2, r0
 8020cb4:	460b      	mov	r3, r1
 8020cb6:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8020cba:	f006 ff3f 	bl	8027b3c <__adddf3>
 8020cbe:	9b09      	ldr	r3, [sp, #36]	; 0x24
        for (j = 0; j < n2; j++) {
 8020cc0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8020cc2:	3310      	adds	r3, #16
 8020cc4:	9309      	str	r3, [sp, #36]	; 0x24
 8020cc6:	f106 0310 	add.w	r3, r6, #16
 8020cca:	9308      	str	r3, [sp, #32]
 8020ccc:	9b07      	ldr	r3, [sp, #28]
 8020cce:	3201      	adds	r2, #1
 8020cd0:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8020cd2:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 8020cd6:	920c      	str	r2, [sp, #48]	; 0x30
 8020cd8:	f47f ae98 	bne.w	8020a0c <cblas_zsymm+0xa9c>
      for (i = 0; i < n1; i++) {
 8020cdc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8020cde:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8020ce0:	3301      	adds	r3, #1
 8020ce2:	930d      	str	r3, [sp, #52]	; 0x34
 8020ce4:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8020ce6:	4611      	mov	r1, r2
 8020ce8:	4419      	add	r1, r3
 8020cea:	9118      	str	r1, [sp, #96]	; 0x60
 8020cec:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8020cee:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 8020cf0:	4608      	mov	r0, r1
 8020cf2:	4410      	add	r0, r2
 8020cf4:	900b      	str	r0, [sp, #44]	; 0x2c
 8020cf6:	9817      	ldr	r0, [sp, #92]	; 0x5c
 8020cf8:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8020cfa:	4604      	mov	r4, r0
 8020cfc:	440c      	add	r4, r1
 8020cfe:	9802      	ldr	r0, [sp, #8]
 8020d00:	9417      	str	r4, [sp, #92]	; 0x5c
 8020d02:	9c1a      	ldr	r4, [sp, #104]	; 0x68
 8020d04:	4420      	add	r0, r4
 8020d06:	9002      	str	r0, [sp, #8]
 8020d08:	9816      	ldr	r0, [sp, #88]	; 0x58
 8020d0a:	4418      	add	r0, r3
 8020d0c:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8020d0e:	9016      	str	r0, [sp, #88]	; 0x58
 8020d10:	440b      	add	r3, r1
 8020d12:	9315      	str	r3, [sp, #84]	; 0x54
 8020d14:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8020d16:	4413      	add	r3, r2
 8020d18:	930e      	str	r3, [sp, #56]	; 0x38
 8020d1a:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8020d1c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020d1e:	4293      	cmp	r3, r2
 8020d20:	f73f ae58 	bgt.w	80209d4 <cblas_zsymm+0xa64>
 8020d24:	f7ff b9f7 	b.w	8020116 <cblas_zsymm+0x1a6>
	...
      for (i = 0; i < n1; i++) {
 8020d30:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8020d32:	2b00      	cmp	r3, #0
 8020d34:	f77f a9ef 	ble.w	8020116 <cblas_zsymm+0x1a6>
 8020d38:	980e      	ldr	r0, [sp, #56]	; 0x38
 8020d3a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020d3c:	1c42      	adds	r2, r0, #1
 8020d3e:	0112      	lsls	r2, r2, #4
 8020d40:	920c      	str	r2, [sp, #48]	; 0x30
 8020d42:	0102      	lsls	r2, r0, #4
 8020d44:	920b      	str	r2, [sp, #44]	; 0x2c
 8020d46:	9a07      	ldr	r2, [sp, #28]
 8020d48:	3b10      	subs	r3, #16
 8020d4a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020d4e:	9317      	str	r3, [sp, #92]	; 0x5c
 8020d50:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8020d52:	011b      	lsls	r3, r3, #4
 8020d54:	9316      	str	r3, [sp, #88]	; 0x58
 8020d56:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020d58:	2100      	movs	r1, #0
 8020d5a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020d5e:	910e      	str	r1, [sp, #56]	; 0x38
 8020d60:	9112      	str	r1, [sp, #72]	; 0x48
 8020d62:	9115      	str	r1, [sp, #84]	; 0x54
 8020d64:	930d      	str	r3, [sp, #52]	; 0x34
        for (j = 0; j < n2; j++) {
 8020d66:	9b07      	ldr	r3, [sp, #28]
 8020d68:	2b00      	cmp	r3, #0
 8020d6a:	f340 81c7 	ble.w	80210fc <cblas_zsymm+0x118c>
 8020d6e:	e9dd 3211 	ldrd	r3, r2, [sp, #68]	; 0x44
 8020d72:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020d76:	9308      	str	r3, [sp, #32]
 8020d78:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8020d7a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8020d7c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8020d80:	9303      	str	r3, [sp, #12]
 8020d82:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8020d84:	9302      	str	r3, [sp, #8]
 8020d86:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8020d88:	9306      	str	r3, [sp, #24]
 8020d8a:	2300      	movs	r3, #0
 8020d8c:	9309      	str	r3, [sp, #36]	; 0x24
          const BASE Bij_real = CONST_REAL(B, ldb * i + j);
 8020d8e:	9c08      	ldr	r4, [sp, #32]
 8020d90:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020d94:	ec51 0b1f 	vmov	r0, r1, d15
 8020d98:	4632      	mov	r2, r6
 8020d9a:	463b      	mov	r3, r7
 8020d9c:	f007 f884 	bl	8027ea8 <__aeabi_dmul>
          const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
 8020da0:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020da4:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
 8020da8:	4642      	mov	r2, r8
 8020daa:	464b      	mov	r3, r9
 8020dac:	4604      	mov	r4, r0
 8020dae:	460d      	mov	r5, r1
 8020db0:	4650      	mov	r0, sl
 8020db2:	4659      	mov	r1, fp
 8020db4:	f007 f878 	bl	8027ea8 <__aeabi_dmul>
 8020db8:	4602      	mov	r2, r0
 8020dba:	460b      	mov	r3, r1
 8020dbc:	4620      	mov	r0, r4
 8020dbe:	4629      	mov	r1, r5
 8020dc0:	f006 feba 	bl	8027b38 <__aeabi_dsub>
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020dc4:	4642      	mov	r2, r8
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020dc6:	4604      	mov	r4, r0
 8020dc8:	460d      	mov	r5, r1
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020dca:	464b      	mov	r3, r9
 8020dcc:	ec51 0b1f 	vmov	r0, r1, d15
 8020dd0:	f007 f86a 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020dd4:	ec45 4b19 	vmov	d9, r4, r5
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020dd8:	4632      	mov	r2, r6
 8020dda:	463b      	mov	r3, r7
 8020ddc:	4604      	mov	r4, r0
 8020dde:	460d      	mov	r5, r1
 8020de0:	4650      	mov	r0, sl
 8020de2:	4659      	mov	r1, fp
 8020de4:	f007 f860 	bl	8027ea8 <__aeabi_dmul>
          const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8020de8:	eeb0 ba49 	vmov.f32	s22, s18
 8020dec:	eef0 ba69 	vmov.f32	s23, s19
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020df0:	4602      	mov	r2, r0
 8020df2:	460b      	mov	r3, r1
 8020df4:	4620      	mov	r0, r4
 8020df6:	4629      	mov	r1, r5
 8020df8:	f006 fea0 	bl	8027b3c <__adddf3>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8020dfc:	9c06      	ldr	r4, [sp, #24]
 8020dfe:	e9d4 6700 	ldrd	r6, r7, [r4]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020e02:	468c      	mov	ip, r1
 8020e04:	4683      	mov	fp, r0
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8020e06:	4632      	mov	r2, r6
 8020e08:	463b      	mov	r3, r7
 8020e0a:	ec51 0b19 	vmov	r0, r1, d9
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020e0e:	ec4c bb18 	vmov	d8, fp, ip
            const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
 8020e12:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
          const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8020e16:	eeb0 aa48 	vmov.f32	s20, s16
 8020e1a:	eef0 aa68 	vmov.f32	s21, s17
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8020e1e:	f007 f843 	bl	8027ea8 <__aeabi_dmul>
 8020e22:	4642      	mov	r2, r8
 8020e24:	4604      	mov	r4, r0
 8020e26:	460d      	mov	r5, r1
 8020e28:	464b      	mov	r3, r9
 8020e2a:	ec51 0b18 	vmov	r0, r1, d8
 8020e2e:	f007 f83b 	bl	8027ea8 <__aeabi_dmul>
 8020e32:	4602      	mov	r2, r0
 8020e34:	460b      	mov	r3, r1
 8020e36:	4620      	mov	r0, r4
 8020e38:	4629      	mov	r1, r5
 8020e3a:	f006 fe7d 	bl	8027b38 <__aeabi_dsub>
 8020e3e:	9c03      	ldr	r4, [sp, #12]
 8020e40:	4602      	mov	r2, r0
 8020e42:	460b      	mov	r3, r1
 8020e44:	e9d4 0100 	ldrd	r0, r1, [r4]
 8020e48:	f006 fe78 	bl	8027b3c <__adddf3>
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8020e4c:	4642      	mov	r2, r8
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8020e4e:	e9c4 0100 	strd	r0, r1, [r4]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8020e52:	464b      	mov	r3, r9
 8020e54:	ec51 0b19 	vmov	r0, r1, d9
            REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
 8020e58:	9403      	str	r4, [sp, #12]
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8020e5a:	f007 f825 	bl	8027ea8 <__aeabi_dmul>
 8020e5e:	4632      	mov	r2, r6
 8020e60:	4604      	mov	r4, r0
 8020e62:	460d      	mov	r5, r1
 8020e64:	463b      	mov	r3, r7
 8020e66:	ec51 0b18 	vmov	r0, r1, d8
 8020e6a:	f007 f81d 	bl	8027ea8 <__aeabi_dmul>
 8020e6e:	4602      	mov	r2, r0
 8020e70:	460b      	mov	r3, r1
 8020e72:	4620      	mov	r0, r4
 8020e74:	4629      	mov	r1, r5
 8020e76:	f006 fe61 	bl	8027b3c <__adddf3>
 8020e7a:	9c03      	ldr	r4, [sp, #12]
 8020e7c:	4602      	mov	r2, r0
 8020e7e:	460b      	mov	r3, r1
 8020e80:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8020e84:	f006 fe5a 	bl	8027b3c <__adddf3>
          for (k = j + 1; k < n2; k++) {
 8020e88:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8020e8a:	9a07      	ldr	r2, [sp, #28]
 8020e8c:	3501      	adds	r5, #1
 8020e8e:	42aa      	cmp	r2, r5
            IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
 8020e90:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (k = j + 1; k < n2; k++) {
 8020e94:	9509      	str	r5, [sp, #36]	; 0x24
 8020e96:	f000 8101 	beq.w	802109c <cblas_zsymm+0x112c>
          BASE temp2_imag = 0.0;
 8020e9a:	ed1f 7b5d 	vldr	d7, [pc, #-372]	; 8020d28 <cblas_zsymm+0xdb8>
          for (k = j + 1; k < n2; k++) {
 8020e9e:	9d08      	ldr	r5, [sp, #32]
 8020ea0:	f8dd a018 	ldr.w	sl, [sp, #24]
 8020ea4:	9501      	str	r5, [sp, #4]
 8020ea6:	46a3      	mov	fp, r4
          BASE temp2_imag = 0.0;
 8020ea8:	eeb0 da47 	vmov.f32	s26, s14
 8020eac:	eef0 da67 	vmov.f32	s27, s15
          BASE temp2_real = 0.0;
 8020eb0:	eeb0 ca47 	vmov.f32	s24, s14
 8020eb4:	eef0 ca67 	vmov.f32	s25, s15
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8020eb8:	e9da 8904 	ldrd	r8, r9, [sl, #16]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8020ebc:	ec51 0b1b 	vmov	r0, r1, d11
 8020ec0:	4642      	mov	r2, r8
 8020ec2:	464b      	mov	r3, r9
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8020ec4:	e9da 4506 	ldrd	r4, r5, [sl, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8020ec8:	f006 ffee 	bl	8027ea8 <__aeabi_dmul>
 8020ecc:	4622      	mov	r2, r4
 8020ece:	4606      	mov	r6, r0
 8020ed0:	460f      	mov	r7, r1
 8020ed2:	462b      	mov	r3, r5
 8020ed4:	ec51 0b1a 	vmov	r0, r1, d10
 8020ed8:	f006 ffe6 	bl	8027ea8 <__aeabi_dmul>
 8020edc:	4602      	mov	r2, r0
 8020ede:	460b      	mov	r3, r1
 8020ee0:	4630      	mov	r0, r6
 8020ee2:	4639      	mov	r1, r7
 8020ee4:	f006 fe28 	bl	8027b38 <__aeabi_dsub>
 8020ee8:	4602      	mov	r2, r0
 8020eea:	460b      	mov	r3, r1
 8020eec:	e9db 0104 	ldrd	r0, r1, [fp, #16]
 8020ef0:	f006 fe24 	bl	8027b3c <__adddf3>
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8020ef4:	9b01      	ldr	r3, [sp, #4]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8020ef6:	4622      	mov	r2, r4
            const BASE Bik_real = CONST_REAL(B, ldb * i + k);
 8020ef8:	ed93 8b04 	vldr	d8, [r3, #16]
            const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
 8020efc:	ed93 9b06 	vldr	d9, [r3, #24]
            REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
 8020f00:	e9cb 0104 	strd	r0, r1, [fp, #16]
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8020f04:	462b      	mov	r3, r5
 8020f06:	ec51 0b1b 	vmov	r0, r1, d11
 8020f0a:	f006 ffcd 	bl	8027ea8 <__aeabi_dmul>
 8020f0e:	4642      	mov	r2, r8
 8020f10:	4606      	mov	r6, r0
 8020f12:	460f      	mov	r7, r1
 8020f14:	464b      	mov	r3, r9
 8020f16:	ec51 0b1a 	vmov	r0, r1, d10
 8020f1a:	f006 ffc5 	bl	8027ea8 <__aeabi_dmul>
 8020f1e:	4602      	mov	r2, r0
 8020f20:	460b      	mov	r3, r1
 8020f22:	4630      	mov	r0, r6
 8020f24:	4639      	mov	r1, r7
 8020f26:	f006 fe09 	bl	8027b3c <__adddf3>
 8020f2a:	4602      	mov	r2, r0
 8020f2c:	460b      	mov	r3, r1
 8020f2e:	e9db 0106 	ldrd	r0, r1, [fp, #24]
 8020f32:	f006 fe03 	bl	8027b3c <__adddf3>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8020f36:	ec53 2b18 	vmov	r2, r3, d8
            IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
 8020f3a:	e9cb 0106 	strd	r0, r1, [fp, #24]
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8020f3e:	4640      	mov	r0, r8
 8020f40:	4649      	mov	r1, r9
 8020f42:	f006 ffb1 	bl	8027ea8 <__aeabi_dmul>
 8020f46:	ec53 2b19 	vmov	r2, r3, d9
 8020f4a:	4606      	mov	r6, r0
 8020f4c:	460f      	mov	r7, r1
 8020f4e:	4620      	mov	r0, r4
 8020f50:	4629      	mov	r1, r5
 8020f52:	f006 ffa9 	bl	8027ea8 <__aeabi_dmul>
 8020f56:	4602      	mov	r2, r0
 8020f58:	460b      	mov	r3, r1
 8020f5a:	4630      	mov	r0, r6
 8020f5c:	4639      	mov	r1, r7
 8020f5e:	f006 fdeb 	bl	8027b38 <__aeabi_dsub>
 8020f62:	4602      	mov	r2, r0
 8020f64:	460b      	mov	r3, r1
 8020f66:	ec51 0b1c 	vmov	r0, r1, d12
 8020f6a:	f006 fde7 	bl	8027b3c <__adddf3>
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8020f6e:	ec53 2b18 	vmov	r2, r3, d8
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8020f72:	4606      	mov	r6, r0
 8020f74:	460f      	mov	r7, r1
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8020f76:	4620      	mov	r0, r4
 8020f78:	4629      	mov	r1, r5
 8020f7a:	f006 ff95 	bl	8027ea8 <__aeabi_dmul>
            temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
 8020f7e:	ec47 6b1c 	vmov	d12, r6, r7
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8020f82:	ec53 2b19 	vmov	r2, r3, d9
 8020f86:	4606      	mov	r6, r0
 8020f88:	460f      	mov	r7, r1
 8020f8a:	4640      	mov	r0, r8
 8020f8c:	4649      	mov	r1, r9
 8020f8e:	f006 ff8b 	bl	8027ea8 <__aeabi_dmul>
 8020f92:	4602      	mov	r2, r0
 8020f94:	460b      	mov	r3, r1
 8020f96:	4630      	mov	r0, r6
 8020f98:	4639      	mov	r1, r7
 8020f9a:	f006 fdcf 	bl	8027b3c <__adddf3>
 8020f9e:	460b      	mov	r3, r1
 8020fa0:	4602      	mov	r2, r0
 8020fa2:	ec51 0b1d 	vmov	r0, r1, d13
 8020fa6:	f006 fdc9 	bl	8027b3c <__adddf3>
 8020faa:	9b01      	ldr	r3, [sp, #4]
 8020fac:	3310      	adds	r3, #16
 8020fae:	9301      	str	r3, [sp, #4]
          for (k = j + 1; k < n2; k++) {
 8020fb0:	9b02      	ldr	r3, [sp, #8]
 8020fb2:	f10a 0a10 	add.w	sl, sl, #16
 8020fb6:	4553      	cmp	r3, sl
            temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
 8020fb8:	ec41 0b1d 	vmov	d13, r0, r1
          for (k = j + 1; k < n2; k++) {
 8020fbc:	f10b 0b10 	add.w	fp, fp, #16
 8020fc0:	f47f af7a 	bne.w	8020eb8 <cblas_zsymm+0xf48>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8020fc4:	ec53 2b1c 	vmov	r2, r3, d12
 8020fc8:	ec51 0b1f 	vmov	r0, r1, d15
 8020fcc:	f006 ff6c 	bl	8027ea8 <__aeabi_dmul>
 8020fd0:	e9dd 7804 	ldrd	r7, r8, [sp, #16]
 8020fd4:	ec5a 9b1d 	vmov	r9, sl, d13
 8020fd8:	4604      	mov	r4, r0
 8020fda:	460d      	mov	r5, r1
 8020fdc:	ee1d 2a10 	vmov	r2, s26
 8020fe0:	4653      	mov	r3, sl
 8020fe2:	4638      	mov	r0, r7
 8020fe4:	4641      	mov	r1, r8
 8020fe6:	f006 ff5f 	bl	8027ea8 <__aeabi_dmul>
 8020fea:	4602      	mov	r2, r0
 8020fec:	460b      	mov	r3, r1
 8020fee:	4620      	mov	r0, r4
 8020ff0:	4629      	mov	r1, r5
 8020ff2:	f006 fda1 	bl	8027b38 <__aeabi_dsub>
 8020ff6:	9e03      	ldr	r6, [sp, #12]
 8020ff8:	4602      	mov	r2, r0
 8020ffa:	460b      	mov	r3, r1
 8020ffc:	e9d6 0100 	ldrd	r0, r1, [r6]
 8021000:	f006 fd9c 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 8021004:	ee1d 2a10 	vmov	r2, s26
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 8021008:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 802100c:	4653      	mov	r3, sl
 802100e:	ec51 0b1f 	vmov	r0, r1, d15
 8021012:	f006 ff49 	bl	8027ea8 <__aeabi_dmul>
 8021016:	ec53 2b1c 	vmov	r2, r3, d12
 802101a:	4604      	mov	r4, r0
 802101c:	460d      	mov	r5, r1
 802101e:	4638      	mov	r0, r7
 8021020:	4641      	mov	r1, r8
 8021022:	f006 ff41 	bl	8027ea8 <__aeabi_dmul>
 8021026:	4602      	mov	r2, r0
 8021028:	460b      	mov	r3, r1
 802102a:	4620      	mov	r0, r4
 802102c:	4629      	mov	r1, r5
 802102e:	f006 fd85 	bl	8027b3c <__adddf3>
 8021032:	4602      	mov	r2, r0
 8021034:	460b      	mov	r3, r1
 8021036:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 802103a:	f006 fd7f 	bl	8027b3c <__adddf3>
 802103e:	9b08      	ldr	r3, [sp, #32]
 8021040:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8021042:	3310      	adds	r3, #16
 8021044:	9308      	str	r3, [sp, #32]
 8021046:	9b06      	ldr	r3, [sp, #24]
 8021048:	4413      	add	r3, r2
 802104a:	9306      	str	r3, [sp, #24]
 802104c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802104e:	9b02      	ldr	r3, [sp, #8]
 8021050:	4413      	add	r3, r2
 8021052:	9302      	str	r3, [sp, #8]
 8021054:	f106 0310 	add.w	r3, r6, #16
 8021058:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j < n2; j++) {
 802105c:	9303      	str	r3, [sp, #12]
 802105e:	e696      	b.n	8020d8e <cblas_zsymm+0xe1e>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8021060:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8021062:	2b00      	cmp	r3, #0
 8021064:	dc78      	bgt.n	8021158 <cblas_zsymm+0x11e8>
 8021066:	2301      	movs	r3, #1
 8021068:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802106a:	429a      	cmp	r2, r3
 802106c:	bfb4      	ite	lt
 802106e:	200d      	movlt	r0, #13
 8021070:	200a      	movge	r0, #10
 8021072:	f7fe bfb9 	b.w	801ffe8 <cblas_zsymm+0x78>
 8021076:	9b07      	ldr	r3, [sp, #28]
 8021078:	e47d      	b.n	8020976 <cblas_zsymm+0xa06>
      for (i = 0; i < n1; i++) {
 802107a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802107c:	9915      	ldr	r1, [sp, #84]	; 0x54
 802107e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8021080:	440a      	add	r2, r1
 8021082:	9210      	str	r2, [sp, #64]	; 0x40
 8021084:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8021086:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8021088:	440a      	add	r2, r1
 802108a:	920d      	str	r2, [sp, #52]	; 0x34
 802108c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802108e:	3301      	adds	r3, #1
 8021090:	429a      	cmp	r2, r3
 8021092:	9312      	str	r3, [sp, #72]	; 0x48
 8021094:	f47f aaa6 	bne.w	80205e4 <cblas_zsymm+0x674>
 8021098:	f7ff b83d 	b.w	8020116 <cblas_zsymm+0x1a6>
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 802109c:	2200      	movs	r2, #0
 802109e:	2300      	movs	r3, #0
 80210a0:	ec51 0b1f 	vmov	r0, r1, d15
 80210a4:	f006 ff00 	bl	8027ea8 <__aeabi_dmul>
 80210a8:	2200      	movs	r2, #0
 80210aa:	4606      	mov	r6, r0
 80210ac:	460f      	mov	r7, r1
 80210ae:	2300      	movs	r3, #0
 80210b0:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80210b4:	f006 fef8 	bl	8027ea8 <__aeabi_dmul>
 80210b8:	4604      	mov	r4, r0
 80210ba:	460d      	mov	r5, r1
 80210bc:	4622      	mov	r2, r4
 80210be:	462b      	mov	r3, r5
 80210c0:	4630      	mov	r0, r6
 80210c2:	4639      	mov	r1, r7
 80210c4:	f006 fd38 	bl	8027b38 <__aeabi_dsub>
 80210c8:	460b      	mov	r3, r1
 80210ca:	990d      	ldr	r1, [sp, #52]	; 0x34
 80210cc:	4602      	mov	r2, r0
 80210ce:	e951 0104 	ldrd	r0, r1, [r1, #-16]
 80210d2:	f006 fd33 	bl	8027b3c <__adddf3>
 80210d6:	4680      	mov	r8, r0
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80210d8:	4620      	mov	r0, r4
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80210da:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 80210dc:	4689      	mov	r9, r1
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80210de:	4632      	mov	r2, r6
 80210e0:	463b      	mov	r3, r7
          REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
 80210e2:	e944 8904 	strd	r8, r9, [r4, #-16]
          IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
 80210e6:	4629      	mov	r1, r5
 80210e8:	f006 fd28 	bl	8027b3c <__adddf3>
 80210ec:	4602      	mov	r2, r0
 80210ee:	460b      	mov	r3, r1
 80210f0:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 80210f4:	f006 fd22 	bl	8027b3c <__adddf3>
 80210f8:	e944 0102 	strd	r0, r1, [r4, #-8]
      for (i = 0; i < n1; i++) {
 80210fc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80210fe:	9916      	ldr	r1, [sp, #88]	; 0x58
 8021100:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021102:	440a      	add	r2, r1
 8021104:	920d      	str	r2, [sp, #52]	; 0x34
 8021106:	9914      	ldr	r1, [sp, #80]	; 0x50
 8021108:	9a12      	ldr	r2, [sp, #72]	; 0x48
 802110a:	440a      	add	r2, r1
 802110c:	9212      	str	r2, [sp, #72]	; 0x48
 802110e:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8021110:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8021112:	440a      	add	r2, r1
 8021114:	920e      	str	r2, [sp, #56]	; 0x38
 8021116:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021118:	3301      	adds	r3, #1
 802111a:	429a      	cmp	r2, r3
 802111c:	9315      	str	r3, [sp, #84]	; 0x54
 802111e:	f47f ae22 	bne.w	8020d66 <cblas_zsymm+0xdf6>
 8021122:	f7fe bff8 	b.w	8020116 <cblas_zsymm+0x1a6>
  CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
 8021126:	9b07      	ldr	r3, [sp, #28]
 8021128:	9a14      	ldr	r2, [sp, #80]	; 0x50
 802112a:	2b01      	cmp	r3, #1
 802112c:	bfb8      	it	lt
 802112e:	2301      	movlt	r3, #1
 8021130:	4293      	cmp	r3, r2
 8021132:	dc99      	bgt.n	8021068 <cblas_zsymm+0x10f8>
 8021134:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021136:	4293      	cmp	r3, r2
 8021138:	bfd4      	ite	le
 802113a:	2008      	movle	r0, #8
 802113c:	200d      	movgt	r0, #13
 802113e:	f7fe bf53 	b.w	801ffe8 <cblas_zsymm+0x78>
 8021142:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021144:	9319      	str	r3, [sp, #100]	; 0x64
 8021146:	e5c9      	b.n	8020cdc <cblas_zsymm+0xd6c>
 8021148:	3865      	subs	r0, #101	; 0x65
 802114a:	2801      	cmp	r0, #1
 802114c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802114e:	bf94      	ite	ls
 8021150:	2000      	movls	r0, #0
 8021152:	2001      	movhi	r0, #1
 8021154:	f7fe bf2d 	b.w	801ffb2 <cblas_zsymm+0x42>
 8021158:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802115a:	2b00      	cmp	r3, #0
 802115c:	bfcc      	ite	gt
 802115e:	2005      	movgt	r0, #5
 8021160:	200d      	movle	r0, #13
 8021162:	f7fe bf41 	b.w	801ffe8 <cblas_zsymm+0x78>
 8021166:	9b07      	ldr	r3, [sp, #28]
 8021168:	9a14      	ldr	r2, [sp, #80]	; 0x50
 802116a:	2b01      	cmp	r3, #1
 802116c:	bfb8      	it	lt
 802116e:	2301      	movlt	r3, #1
 8021170:	429a      	cmp	r2, r3
 8021172:	f6ff af79 	blt.w	8021068 <cblas_zsymm+0x10f8>
 8021176:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021178:	429a      	cmp	r2, r3
 802117a:	bfac      	ite	ge
 802117c:	2005      	movge	r0, #5
 802117e:	200d      	movlt	r0, #13
 8021180:	f7fe bf32 	b.w	801ffe8 <cblas_zsymm+0x78>
 8021184:	0000      	movs	r0, r0
	...

08021188 <cblas_zsyr2k>:
void
cblas_zsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
              const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
              const void *alpha, const void *A, const int lda, const void *B,
              const int ldb, const void *beta, void *C, const int ldc)
{
 8021188:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802118c:	ed2d 8b10 	vpush	{d8-d15}
 8021190:	b09d      	sub	sp, #116	; 0x74
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8021192:	2865      	cmp	r0, #101	; 0x65
 8021194:	9304      	str	r3, [sp, #16]
 8021196:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8021198:	930c      	str	r3, [sp, #48]	; 0x30
 802119a:	e9dd 8337 	ldrd	r8, r3, [sp, #220]	; 0xdc
 802119e:	9311      	str	r3, [sp, #68]	; 0x44
 80211a0:	9b39      	ldr	r3, [sp, #228]	; 0xe4
 80211a2:	930d      	str	r3, [sp, #52]	; 0x34
 80211a4:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
 80211a6:	9312      	str	r3, [sp, #72]	; 0x48
 80211a8:	9b3b      	ldr	r3, [sp, #236]	; 0xec
 80211aa:	930e      	str	r3, [sp, #56]	; 0x38
 80211ac:	e9dd 733c 	ldrd	r7, r3, [sp, #240]	; 0xf0
 80211b0:	9315      	str	r3, [sp, #84]	; 0x54
 80211b2:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
 80211b4:	9316      	str	r3, [sp, #88]	; 0x58
 80211b6:	4605      	mov	r5, r0
 80211b8:	460e      	mov	r6, r1
 80211ba:	4614      	mov	r4, r2
 80211bc:	f000 815d 	beq.w	802147a <cblas_zsyr2k+0x2f2>
 80211c0:	2a6f      	cmp	r2, #111	; 0x6f
 80211c2:	f000 80b7 	beq.w	8021334 <cblas_zsyr2k+0x1ac>
 80211c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80211c8:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 80211cc:	2a01      	cmp	r2, #1
 80211ce:	f240 813f 	bls.w	8021450 <cblas_zsyr2k+0x2c8>
 80211d2:	2002      	movs	r0, #2
 80211d4:	f1a4 026f 	sub.w	r2, r4, #111	; 0x6f
 80211d8:	2a02      	cmp	r2, #2
 80211da:	bf88      	it	hi
 80211dc:	2003      	movhi	r0, #3
 80211de:	9a04      	ldr	r2, [sp, #16]
 80211e0:	990c      	ldr	r1, [sp, #48]	; 0x30
 80211e2:	2a00      	cmp	r2, #0
 80211e4:	bfb8      	it	lt
 80211e6:	2004      	movlt	r0, #4
 80211e8:	2900      	cmp	r1, #0
 80211ea:	bfb8      	it	lt
 80211ec:	2005      	movlt	r0, #5
 80211ee:	990d      	ldr	r1, [sp, #52]	; 0x34
 80211f0:	2b01      	cmp	r3, #1
 80211f2:	bfb8      	it	lt
 80211f4:	2301      	movlt	r3, #1
 80211f6:	428b      	cmp	r3, r1
 80211f8:	f340 811b 	ble.w	8021432 <cblas_zsyr2k+0x2aa>
 80211fc:	990e      	ldr	r1, [sp, #56]	; 0x38
 80211fe:	428b      	cmp	r3, r1
 8021200:	f300 810d 	bgt.w	802141e <cblas_zsyr2k+0x296>
 8021204:	2a01      	cmp	r2, #1
 8021206:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021208:	bfb8      	it	lt
 802120a:	2201      	movlt	r2, #1
 802120c:	429a      	cmp	r2, r3
 802120e:	bfcc      	ite	gt
 8021210:	200e      	movgt	r0, #14
 8021212:	2008      	movle	r0, #8
 8021214:	4a9d      	ldr	r2, [pc, #628]	; (802148c <cblas_zsyr2k+0x304>)
 8021216:	499e      	ldr	r1, [pc, #632]	; (8021490 <cblas_zsyr2k+0x308>)
 8021218:	f006 fc16 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 802121c:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8021220:	2200      	movs	r2, #0
 8021222:	ec51 0b17 	vmov	r0, r1, d7
 8021226:	2300      	movs	r3, #0
    const BASE alpha_real = CONST_REAL0(alpha);
 8021228:	ed8d 7b06 	vstr	d7, [sp, #24]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 802122c:	f007 f8a4 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8021230:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 8021234:	ed97 8b00 	vldr	d8, [r7]
    const BASE beta_imag = CONST_IMAG0(beta);
 8021238:	ed97 9b02 	vldr	d9, [r7, #8]
    const BASE beta_real = CONST_REAL0(beta);
 802123c:	eeb0 ba48 	vmov.f32	s22, s16
 8021240:	eef0 ba68 	vmov.f32	s23, s17
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8021244:	ed8d 7b08 	vstr	d7, [sp, #32]
    const BASE beta_imag = CONST_IMAG0(beta);
 8021248:	eeb0 aa49 	vmov.f32	s20, s18
 802124c:	eef0 aa69 	vmov.f32	s21, s19
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 8021250:	b178      	cbz	r0, 8021272 <cblas_zsyr2k+0xea>
 8021252:	ec51 0b17 	vmov	r0, r1, d7
 8021256:	2200      	movs	r2, #0
 8021258:	2300      	movs	r3, #0
 802125a:	f007 f88d 	bl	8028378 <__aeabi_dcmpeq>
 802125e:	b140      	cbz	r0, 8021272 <cblas_zsyr2k+0xea>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8021260:	4b8c      	ldr	r3, [pc, #560]	; (8021494 <cblas_zsyr2k+0x30c>)
 8021262:	ec51 0b18 	vmov	r0, r1, d8
 8021266:	2200      	movs	r2, #0
 8021268:	f007 f886 	bl	8028378 <__aeabi_dcmpeq>
 802126c:	2800      	cmp	r0, #0
 802126e:	f040 80f6 	bne.w	802145e <cblas_zsyr2k+0x2d6>
    if (Order == CblasRowMajor) {
 8021272:	2d65      	cmp	r5, #101	; 0x65
 8021274:	f000 8106 	beq.w	8021484 <cblas_zsyr2k+0x2fc>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8021278:	2e79      	cmp	r6, #121	; 0x79
 802127a:	bf0c      	ite	eq
 802127c:	237a      	moveq	r3, #122	; 0x7a
 802127e:	2379      	movne	r3, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8021280:	2c6f      	cmp	r4, #111	; 0x6f
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8021282:	930f      	str	r3, [sp, #60]	; 0x3c
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8021284:	bf0c      	ite	eq
 8021286:	2370      	moveq	r3, #112	; 0x70
 8021288:	236f      	movne	r3, #111	; 0x6f
 802128a:	9310      	str	r3, [sp, #64]	; 0x40
    if (beta_real == 0.0 && beta_imag == 0.0) {
 802128c:	2200      	movs	r2, #0
 802128e:	ec51 0b1b 	vmov	r0, r1, d11
 8021292:	2300      	movs	r3, #0
 8021294:	f007 f870 	bl	8028378 <__aeabi_dcmpeq>
 8021298:	2200      	movs	r2, #0
 802129a:	2800      	cmp	r0, #0
 802129c:	d052      	beq.n	8021344 <cblas_zsyr2k+0x1bc>
 802129e:	ec51 0b1a 	vmov	r0, r1, d10
 80212a2:	2300      	movs	r3, #0
 80212a4:	f007 f868 	bl	8028378 <__aeabi_dcmpeq>
 80212a8:	2800      	cmp	r0, #0
 80212aa:	d05a      	beq.n	8021362 <cblas_zsyr2k+0x1da>
      if (uplo == CblasUpper) {
 80212ac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80212ae:	2b79      	cmp	r3, #121	; 0x79
 80212b0:	f000 80f4 	beq.w	802149c <cblas_zsyr2k+0x314>
        for (i = 0; i < N; i++) {
 80212b4:	9b04      	ldr	r3, [sp, #16]
 80212b6:	2b00      	cmp	r3, #0
 80212b8:	dd1a      	ble.n	80212f0 <cblas_zsyr2k+0x168>
 80212ba:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80212bc:	9a15      	ldr	r2, [sp, #84]	; 0x54
 80212be:	9d04      	ldr	r5, [sp, #16]
 80212c0:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
 80212c4:	1c5c      	adds	r4, r3, #1
 80212c6:	2100      	movs	r1, #0
            REAL(C, ldc * i + j) = 0.0;
 80212c8:	2600      	movs	r6, #0
 80212ca:	2700      	movs	r7, #0
 80212cc:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 80212ce:	4608      	mov	r0, r1
 80212d0:	3210      	adds	r2, #16
 80212d2:	469e      	mov	lr, r3
 80212d4:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
            REAL(C, ldc * i + j) = 0.0;
 80212d8:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 80212dc:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = 0; j <= i; j++) {
 80212e0:	3310      	adds	r3, #16
 80212e2:	429a      	cmp	r2, r3
 80212e4:	d1f8      	bne.n	80212d8 <cblas_zsyr2k+0x150>
        for (i = 0; i < N; i++) {
 80212e6:	3001      	adds	r0, #1
 80212e8:	4285      	cmp	r5, r0
 80212ea:	4471      	add	r1, lr
 80212ec:	4422      	add	r2, r4
 80212ee:	d1f1      	bne.n	80212d4 <cblas_zsyr2k+0x14c>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80212f0:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80212f4:	2200      	movs	r2, #0
 80212f6:	2300      	movs	r3, #0
 80212f8:	f007 f83e 	bl	8028378 <__aeabi_dcmpeq>
 80212fc:	b160      	cbz	r0, 8021318 <cblas_zsyr2k+0x190>
 80212fe:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8021302:	2200      	movs	r2, #0
 8021304:	2300      	movs	r3, #0
 8021306:	f007 f837 	bl	8028378 <__aeabi_dcmpeq>
 802130a:	2800      	cmp	r0, #0
 802130c:	f040 80b0 	bne.w	8021470 <cblas_zsyr2k+0x2e8>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8021310:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021312:	2b79      	cmp	r3, #121	; 0x79
 8021314:	f000 80e4 	beq.w	80214e0 <cblas_zsyr2k+0x358>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8021318:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802131a:	2b7a      	cmp	r3, #122	; 0x7a
 802131c:	f000 823c 	beq.w	8021798 <cblas_zsyr2k+0x610>
      BLAS_ERROR("unrecognized operation");
 8021320:	4a5d      	ldr	r2, [pc, #372]	; (8021498 <cblas_zsyr2k+0x310>)
 8021322:	495b      	ldr	r1, [pc, #364]	; (8021490 <cblas_zsyr2k+0x308>)
 8021324:	2000      	movs	r0, #0
#define BASE double
#include "source_syr2k_c.h"
#undef BASE
}
 8021326:	b01d      	add	sp, #116	; 0x74
 8021328:	ecbd 8b10 	vpop	{d8-d15}
 802132c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021330:	f006 bb8a 	b.w	8027a48 <cblas_xerbla>
 8021334:	9b04      	ldr	r3, [sp, #16]
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8021336:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 802133a:	2a01      	cmp	r2, #1
 802133c:	f240 8088 	bls.w	8021450 <cblas_zsyr2k+0x2c8>
 8021340:	2002      	movs	r0, #2
 8021342:	e74c      	b.n	80211de <cblas_zsyr2k+0x56>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 8021344:	4b53      	ldr	r3, [pc, #332]	; (8021494 <cblas_zsyr2k+0x30c>)
 8021346:	ec51 0b1b 	vmov	r0, r1, d11
 802134a:	f007 f815 	bl	8028378 <__aeabi_dcmpeq>
 802134e:	b140      	cbz	r0, 8021362 <cblas_zsyr2k+0x1da>
 8021350:	ec51 0b1a 	vmov	r0, r1, d10
 8021354:	2200      	movs	r2, #0
 8021356:	2300      	movs	r3, #0
 8021358:	f007 f80e 	bl	8028378 <__aeabi_dcmpeq>
 802135c:	2800      	cmp	r0, #0
 802135e:	f040 8363 	bne.w	8021a28 <cblas_zsyr2k+0x8a0>
      if (uplo == CblasUpper) {
 8021362:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8021364:	2b79      	cmp	r3, #121	; 0x79
        for (i = 0; i < N; i++) {
 8021366:	9b04      	ldr	r3, [sp, #16]
      if (uplo == CblasUpper) {
 8021368:	f000 85fb 	beq.w	8021f62 <cblas_zsyr2k+0xdda>
        for (i = 0; i < N; i++) {
 802136c:	2b00      	cmp	r3, #0
 802136e:	ddbf      	ble.n	80212f0 <cblas_zsyr2k+0x168>
 8021370:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021372:	011b      	lsls	r3, r3, #4
 8021374:	930b      	str	r3, [sp, #44]	; 0x2c
 8021376:	3310      	adds	r3, #16
 8021378:	930a      	str	r3, [sp, #40]	; 0x28
 802137a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 802137c:	9302      	str	r3, [sp, #8]
 802137e:	3310      	adds	r3, #16
 8021380:	9300      	str	r3, [sp, #0]
 8021382:	2300      	movs	r3, #0
 8021384:	9305      	str	r3, [sp, #20]
 8021386:	9b02      	ldr	r3, [sp, #8]
 8021388:	ec59 8b1b 	vmov	r8, r9, d11
 802138c:	f103 0a08 	add.w	sl, r3, #8
 8021390:	469b      	mov	fp, r3
            const BASE Cij_real = REAL(C, ldc * i + j);
 8021392:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8021396:	4640      	mov	r0, r8
 8021398:	4622      	mov	r2, r4
 802139a:	462b      	mov	r3, r5
 802139c:	4649      	mov	r1, r9
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 802139e:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80213a2:	f006 fd81 	bl	8027ea8 <__aeabi_dmul>
 80213a6:	4632      	mov	r2, r6
 80213a8:	ec41 0b19 	vmov	d9, r0, r1
 80213ac:	463b      	mov	r3, r7
 80213ae:	ec51 0b1a 	vmov	r0, r1, d10
 80213b2:	f006 fd79 	bl	8027ea8 <__aeabi_dmul>
 80213b6:	4602      	mov	r2, r0
 80213b8:	460b      	mov	r3, r1
 80213ba:	ec51 0b19 	vmov	r0, r1, d9
 80213be:	f006 fbbb 	bl	8027b38 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80213c2:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 80213c4:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80213c8:	463b      	mov	r3, r7
 80213ca:	4640      	mov	r0, r8
 80213cc:	4649      	mov	r1, r9
 80213ce:	f006 fd6b 	bl	8027ea8 <__aeabi_dmul>
 80213d2:	4622      	mov	r2, r4
 80213d4:	462b      	mov	r3, r5
 80213d6:	4604      	mov	r4, r0
 80213d8:	460d      	mov	r5, r1
 80213da:	ec51 0b1a 	vmov	r0, r1, d10
 80213de:	f006 fd63 	bl	8027ea8 <__aeabi_dmul>
 80213e2:	460b      	mov	r3, r1
 80213e4:	4602      	mov	r2, r0
 80213e6:	4629      	mov	r1, r5
 80213e8:	4620      	mov	r0, r4
 80213ea:	f006 fba7 	bl	8027b3c <__adddf3>
          for (j = 0; j <= i; j++) {
 80213ee:	9b00      	ldr	r3, [sp, #0]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 80213f0:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j <= i; j++) {
 80213f4:	f10b 0b10 	add.w	fp, fp, #16
 80213f8:	455b      	cmp	r3, fp
 80213fa:	f10a 0a10 	add.w	sl, sl, #16
 80213fe:	d1c8      	bne.n	8021392 <cblas_zsyr2k+0x20a>
        for (i = 0; i < N; i++) {
 8021400:	9a02      	ldr	r2, [sp, #8]
 8021402:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8021404:	9b05      	ldr	r3, [sp, #20]
 8021406:	440a      	add	r2, r1
 8021408:	9202      	str	r2, [sp, #8]
 802140a:	990a      	ldr	r1, [sp, #40]	; 0x28
 802140c:	9a00      	ldr	r2, [sp, #0]
 802140e:	440a      	add	r2, r1
 8021410:	9200      	str	r2, [sp, #0]
 8021412:	9a04      	ldr	r2, [sp, #16]
 8021414:	3301      	adds	r3, #1
 8021416:	429a      	cmp	r2, r3
 8021418:	9305      	str	r3, [sp, #20]
 802141a:	d1b4      	bne.n	8021386 <cblas_zsyr2k+0x1fe>
 802141c:	e768      	b.n	80212f0 <cblas_zsyr2k+0x168>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 802141e:	9804      	ldr	r0, [sp, #16]
 8021420:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021422:	2801      	cmp	r0, #1
 8021424:	bfb8      	it	lt
 8021426:	2001      	movlt	r0, #1
 8021428:	4283      	cmp	r3, r0
 802142a:	bfb4      	ite	lt
 802142c:	200e      	movlt	r0, #14
 802142e:	200b      	movge	r0, #11
 8021430:	e6f0      	b.n	8021214 <cblas_zsyr2k+0x8c>
 8021432:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8021434:	4293      	cmp	r3, r2
 8021436:	dcf2      	bgt.n	802141e <cblas_zsyr2k+0x296>
 8021438:	9b04      	ldr	r3, [sp, #16]
 802143a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 802143c:	2b01      	cmp	r3, #1
 802143e:	bfb8      	it	lt
 8021440:	2301      	movlt	r3, #1
 8021442:	4293      	cmp	r3, r2
 8021444:	f300 8442 	bgt.w	8021ccc <cblas_zsyr2k+0xb44>
 8021448:	2800      	cmp	r0, #0
 802144a:	f43f aee7 	beq.w	802121c <cblas_zsyr2k+0x94>
 802144e:	e6e1      	b.n	8021214 <cblas_zsyr2k+0x8c>
 8021450:	f1a5 0065 	sub.w	r0, r5, #101	; 0x65
 8021454:	2801      	cmp	r0, #1
 8021456:	bf94      	ite	ls
 8021458:	2000      	movls	r0, #0
 802145a:	2001      	movhi	r0, #1
 802145c:	e6ba      	b.n	80211d4 <cblas_zsyr2k+0x4c>
        && (beta_real == 1.0 && beta_imag == 0.0))
 802145e:	ec51 0b19 	vmov	r0, r1, d9
 8021462:	2200      	movs	r2, #0
 8021464:	2300      	movs	r3, #0
 8021466:	f006 ff87 	bl	8028378 <__aeabi_dcmpeq>
 802146a:	2800      	cmp	r0, #0
 802146c:	f43f af01 	beq.w	8021272 <cblas_zsyr2k+0xea>
 8021470:	b01d      	add	sp, #116	; 0x74
 8021472:	ecbd 8b10 	vpop	{d8-d15}
 8021476:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 802147a:	2a6f      	cmp	r2, #111	; 0x6f
 802147c:	f000 85c5 	beq.w	802200a <cblas_zsyr2k+0xe82>
 8021480:	9b04      	ldr	r3, [sp, #16]
 8021482:	e6a1      	b.n	80211c8 <cblas_zsyr2k+0x40>
      trans = Trans;
 8021484:	e9cd 640f 	strd	r6, r4, [sp, #60]	; 0x3c
 8021488:	e700      	b.n	802128c <cblas_zsyr2k+0x104>
 802148a:	bf00      	nop
 802148c:	08030378 	.word	0x08030378
 8021490:	08030760 	.word	0x08030760
 8021494:	3ff00000 	.word	0x3ff00000
 8021498:	080305a8 	.word	0x080305a8
        for (i = 0; i < N; i++) {
 802149c:	9d04      	ldr	r5, [sp, #16]
 802149e:	2d00      	cmp	r5, #0
 80214a0:	dd15      	ble.n	80214ce <cblas_zsyr2k+0x346>
 80214a2:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80214a4:	9815      	ldr	r0, [sp, #84]	; 0x54
 80214a6:	1c5c      	adds	r4, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 80214a8:	2600      	movs	r6, #0
 80214aa:	2700      	movs	r7, #0
 80214ac:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 80214ae:	2100      	movs	r1, #0
 80214b0:	4603      	mov	r3, r0
 80214b2:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 80214b4:	3201      	adds	r2, #1
 80214b6:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 80214b8:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 80214bc:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = i; j < N; j++) {
 80214c0:	f103 0310 	add.w	r3, r3, #16
 80214c4:	dcf6      	bgt.n	80214b4 <cblas_zsyr2k+0x32c>
        for (i = 0; i < N; i++) {
 80214c6:	3101      	adds	r1, #1
 80214c8:	428d      	cmp	r5, r1
 80214ca:	4420      	add	r0, r4
 80214cc:	d1f0      	bne.n	80214b0 <cblas_zsyr2k+0x328>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80214ce:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80214d2:	2200      	movs	r2, #0
 80214d4:	2300      	movs	r3, #0
 80214d6:	f006 ff4f 	bl	8028378 <__aeabi_dcmpeq>
 80214da:	2800      	cmp	r0, #0
 80214dc:	f47f af0f 	bne.w	80212fe <cblas_zsyr2k+0x176>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 80214e0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80214e2:	2b6f      	cmp	r3, #111	; 0x6f
 80214e4:	f000 82aa 	beq.w	8021a3c <cblas_zsyr2k+0x8b4>
    } else if (uplo == CblasUpper && trans == CblasTrans) {
 80214e8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80214ea:	2b70      	cmp	r3, #112	; 0x70
 80214ec:	f47f af18 	bne.w	8021320 <cblas_zsyr2k+0x198>
      for (k = 0; k < K; k++) {
 80214f0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80214f2:	2b00      	cmp	r3, #0
 80214f4:	ddbc      	ble.n	8021470 <cblas_zsyr2k+0x2e8>
 80214f6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80214f8:	2200      	movs	r2, #0
 80214fa:	3301      	adds	r3, #1
 80214fc:	e9cd 2213 	strd	r2, r2, [sp, #76]	; 0x4c
 8021500:	011b      	lsls	r3, r3, #4
 8021502:	9210      	str	r2, [sp, #64]	; 0x40
 8021504:	930f      	str	r3, [sp, #60]	; 0x3c
        for (i = 0; i < N; i++) {
 8021506:	9b04      	ldr	r3, [sp, #16]
 8021508:	2b00      	cmp	r3, #0
 802150a:	f340 8135 	ble.w	8021778 <cblas_zsyr2k+0x5f0>
 802150e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8021510:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8021512:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021516:	9302      	str	r3, [sp, #8]
 8021518:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802151a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802151c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021520:	930b      	str	r3, [sp, #44]	; 0x2c
 8021522:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021524:	930a      	str	r3, [sp, #40]	; 0x28
 8021526:	2300      	movs	r3, #0
 8021528:	9305      	str	r3, [sp, #20]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 802152a:	9f02      	ldr	r7, [sp, #8]
 802152c:	ed97 7b00 	vldr	d7, [r7]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021530:	ed9d ab06 	vldr	d10, [sp, #24]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 8021534:	eeb0 ba47 	vmov.f32	s22, s14
 8021538:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 802153c:	ec53 2b17 	vmov	r2, r3, d7
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8021540:	ed97 7b02 	vldr	d7, [r7, #8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021544:	ec51 0b1a 	vmov	r0, r1, d10
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8021548:	eeb0 8a47 	vmov.f32	s16, s14
 802154c:	eef0 8a67 	vmov.f32	s17, s15
 8021550:	eeb0 fa47 	vmov.f32	s30, s14
 8021554:	eef0 fa67 	vmov.f32	s31, s15
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021558:	f006 fca6 	bl	8027ea8 <__aeabi_dmul>
 802155c:	ed9d 9b08 	vldr	d9, [sp, #32]
 8021560:	ec53 2b18 	vmov	r2, r3, d8
 8021564:	4604      	mov	r4, r0
 8021566:	460d      	mov	r5, r1
 8021568:	ec51 0b19 	vmov	r0, r1, d9
 802156c:	f006 fc9c 	bl	8027ea8 <__aeabi_dmul>
 8021570:	4602      	mov	r2, r0
 8021572:	460b      	mov	r3, r1
 8021574:	4620      	mov	r0, r4
 8021576:	4629      	mov	r1, r5
 8021578:	f006 fade 	bl	8027b38 <__aeabi_dsub>
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802157c:	ec53 2b18 	vmov	r2, r3, d8
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021580:	4604      	mov	r4, r0
 8021582:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8021584:	ec51 0b1a 	vmov	r0, r1, d10
 8021588:	f006 fc8e 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 802158c:	ec45 4b1e 	vmov	d14, r4, r5
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8021590:	ec53 2b1b 	vmov	r2, r3, d11
 8021594:	4604      	mov	r4, r0
 8021596:	460d      	mov	r5, r1
 8021598:	ec51 0b19 	vmov	r0, r1, d9
 802159c:	f006 fc84 	bl	8027ea8 <__aeabi_dmul>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 80215a0:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 80215a2:	4602      	mov	r2, r0
 80215a4:	460b      	mov	r3, r1
 80215a6:	4620      	mov	r0, r4
 80215a8:	4629      	mov	r1, r5
 80215aa:	f006 fac7 	bl	8027b3c <__adddf3>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 80215ae:	e9d6 8900 	ldrd	r8, r9, [r6]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 80215b2:	4604      	mov	r4, r0
 80215b4:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80215b6:	4642      	mov	r2, r8
 80215b8:	464b      	mov	r3, r9
 80215ba:	ec51 0b1a 	vmov	r0, r1, d10
 80215be:	f006 fc73 	bl	8027ea8 <__aeabi_dmul>
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 80215c2:	ed96 8b02 	vldr	d8, [r6, #8]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 80215c6:	ec45 4b1c 	vmov	d12, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80215ca:	ec53 2b18 	vmov	r2, r3, d8
 80215ce:	4604      	mov	r4, r0
 80215d0:	460d      	mov	r5, r1
 80215d2:	ec51 0b19 	vmov	r0, r1, d9
 80215d6:	f006 fc67 	bl	8027ea8 <__aeabi_dmul>
 80215da:	4602      	mov	r2, r0
 80215dc:	460b      	mov	r3, r1
 80215de:	4620      	mov	r0, r4
 80215e0:	4629      	mov	r1, r5
 80215e2:	f006 faa9 	bl	8027b38 <__aeabi_dsub>
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80215e6:	ec53 2b18 	vmov	r2, r3, d8
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80215ea:	4604      	mov	r4, r0
 80215ec:	460d      	mov	r5, r1
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80215ee:	ec51 0b1a 	vmov	r0, r1, d10
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 80215f2:	e9cd 4500 	strd	r4, r5, [sp]
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80215f6:	f006 fc57 	bl	8027ea8 <__aeabi_dmul>
 80215fa:	4642      	mov	r2, r8
 80215fc:	4604      	mov	r4, r0
 80215fe:	460d      	mov	r5, r1
 8021600:	464b      	mov	r3, r9
 8021602:	ec51 0b19 	vmov	r0, r1, d9
 8021606:	f006 fc4f 	bl	8027ea8 <__aeabi_dmul>
 802160a:	4602      	mov	r2, r0
 802160c:	460b      	mov	r3, r1
 802160e:	4620      	mov	r0, r4
 8021610:	4629      	mov	r1, r5
 8021612:	f006 fa93 	bl	8027b3c <__adddf3>
 8021616:	4635      	mov	r5, r6
 8021618:	ec41 0b19 	vmov	d9, r0, r1
 802161c:	f8dd a008 	ldr.w	sl, [sp, #8]
 8021620:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8021622:	f8dd b014 	ldr.w	fp, [sp, #20]
 8021626:	ec57 6b1b 	vmov	r6, r7, d11
 802162a:	e012      	b.n	8021652 <cblas_zsyr2k+0x4ca>
 802162c:	ed9a 7b06 	vldr	d7, [sl, #24]
 8021630:	eeb0 fa47 	vmov.f32	s30, s14
 8021634:	eef0 fa67 	vmov.f32	s31, s15
 8021638:	ed95 7b06 	vldr	d7, [r5, #24]
 802163c:	e9da 6704 	ldrd	r6, r7, [sl, #16]
 8021640:	eeb0 8a47 	vmov.f32	s16, s14
 8021644:	eef0 8a67 	vmov.f32	s17, s15
 8021648:	e9d5 8904 	ldrd	r8, r9, [r5, #16]
 802164c:	f10a 0a10 	add.w	sl, sl, #16
 8021650:	3510      	adds	r5, #16
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8021652:	4642      	mov	r2, r8
 8021654:	464b      	mov	r3, r9
 8021656:	ec51 0b1e 	vmov	r0, r1, d14
 802165a:	eeb0 da48 	vmov.f32	s26, s16
 802165e:	eef0 da68 	vmov.f32	s27, s17
 8021662:	f006 fc21 	bl	8027ea8 <__aeabi_dmul>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8021666:	eeb0 aa4f 	vmov.f32	s20, s30
 802166a:	eef0 aa6f 	vmov.f32	s21, s31
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802166e:	ec53 2b18 	vmov	r2, r3, d8
 8021672:	ec41 0b18 	vmov	d8, r0, r1
 8021676:	ec51 0b1c 	vmov	r0, r1, d12
 802167a:	f006 fc15 	bl	8027ea8 <__aeabi_dmul>
 802167e:	4602      	mov	r2, r0
 8021680:	460b      	mov	r3, r1
 8021682:	ec51 0b18 	vmov	r0, r1, d8
 8021686:	f006 fa57 	bl	8027b38 <__aeabi_dsub>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 802168a:	ed9d bb00 	vldr	d11, [sp]
 802168e:	4632      	mov	r2, r6
 8021690:	463b      	mov	r3, r7
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8021692:	ec41 0b18 	vmov	d8, r0, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8021696:	ec51 0b1b 	vmov	r0, r1, d11
 802169a:	f006 fc05 	bl	8027ea8 <__aeabi_dmul>
 802169e:	ec53 2b1f 	vmov	r2, r3, d15
 80216a2:	ec41 0b1f 	vmov	d15, r0, r1
 80216a6:	ec51 0b19 	vmov	r0, r1, d9
 80216aa:	f006 fbfd 	bl	8027ea8 <__aeabi_dmul>
 80216ae:	4602      	mov	r2, r0
 80216b0:	460b      	mov	r3, r1
 80216b2:	ec51 0b1f 	vmov	r0, r1, d15
 80216b6:	f006 fa3f 	bl	8027b38 <__aeabi_dsub>
 80216ba:	4602      	mov	r2, r0
 80216bc:	460b      	mov	r3, r1
 80216be:	ec51 0b18 	vmov	r0, r1, d8
 80216c2:	f006 fa3b 	bl	8027b3c <__adddf3>
 80216c6:	4602      	mov	r2, r0
 80216c8:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80216ca:	e9d4 0100 	ldrd	r0, r1, [r4]
 80216ce:	f006 fa35 	bl	8027b3c <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80216d2:	ec53 2b1d 	vmov	r2, r3, d13
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80216d6:	e9c4 0100 	strd	r0, r1, [r4]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80216da:	ec51 0b1e 	vmov	r0, r1, d14
 80216de:	f006 fbe3 	bl	8027ea8 <__aeabi_dmul>
 80216e2:	4642      	mov	r2, r8
 80216e4:	464b      	mov	r3, r9
 80216e6:	4680      	mov	r8, r0
 80216e8:	4689      	mov	r9, r1
 80216ea:	ec51 0b1c 	vmov	r0, r1, d12
 80216ee:	f006 fbdb 	bl	8027ea8 <__aeabi_dmul>
 80216f2:	4602      	mov	r2, r0
 80216f4:	460b      	mov	r3, r1
 80216f6:	4640      	mov	r0, r8
 80216f8:	4649      	mov	r1, r9
 80216fa:	f006 fa1f 	bl	8027b3c <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 80216fe:	ec53 2b1a 	vmov	r2, r3, d10
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8021702:	4680      	mov	r8, r0
 8021704:	4689      	mov	r9, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8021706:	ec51 0b1b 	vmov	r0, r1, d11
 802170a:	f006 fbcd 	bl	8027ea8 <__aeabi_dmul>
 802170e:	4632      	mov	r2, r6
 8021710:	463b      	mov	r3, r7
 8021712:	4606      	mov	r6, r0
 8021714:	460f      	mov	r7, r1
 8021716:	ec51 0b19 	vmov	r0, r1, d9
 802171a:	f006 fbc5 	bl	8027ea8 <__aeabi_dmul>
 802171e:	4602      	mov	r2, r0
 8021720:	460b      	mov	r3, r1
 8021722:	4630      	mov	r0, r6
 8021724:	4639      	mov	r1, r7
 8021726:	f006 fa09 	bl	8027b3c <__adddf3>
 802172a:	4602      	mov	r2, r0
 802172c:	460b      	mov	r3, r1
 802172e:	4640      	mov	r0, r8
 8021730:	4649      	mov	r1, r9
 8021732:	f006 fa03 	bl	8027b3c <__adddf3>
 8021736:	460b      	mov	r3, r1
 8021738:	4602      	mov	r2, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802173a:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 802173e:	f006 f9fd 	bl	8027b3c <__adddf3>
          for (j = i; j < N; j++) {
 8021742:	9b04      	ldr	r3, [sp, #16]
 8021744:	f10b 0b01 	add.w	fp, fp, #1
 8021748:	455b      	cmp	r3, fp
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802174a:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = i; j < N; j++) {
 802174e:	f104 0410 	add.w	r4, r4, #16
 8021752:	f73f af6b 	bgt.w	802162c <cblas_zsyr2k+0x4a4>
        for (i = 0; i < N; i++) {
 8021756:	9a02      	ldr	r2, [sp, #8]
 8021758:	990f      	ldr	r1, [sp, #60]	; 0x3c
 802175a:	9b05      	ldr	r3, [sp, #20]
 802175c:	3210      	adds	r2, #16
 802175e:	9202      	str	r2, [sp, #8]
 8021760:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021762:	3210      	adds	r2, #16
 8021764:	920b      	str	r2, [sp, #44]	; 0x2c
 8021766:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021768:	440a      	add	r2, r1
 802176a:	920a      	str	r2, [sp, #40]	; 0x28
 802176c:	9a04      	ldr	r2, [sp, #16]
 802176e:	3301      	adds	r3, #1
 8021770:	429a      	cmp	r2, r3
 8021772:	9305      	str	r3, [sp, #20]
 8021774:	f47f aed9 	bne.w	802152a <cblas_zsyr2k+0x3a2>
      for (k = 0; k < K; k++) {
 8021778:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 802177a:	990d      	ldr	r1, [sp, #52]	; 0x34
 802177c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802177e:	440a      	add	r2, r1
 8021780:	9213      	str	r2, [sp, #76]	; 0x4c
 8021782:	990e      	ldr	r1, [sp, #56]	; 0x38
 8021784:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021786:	440a      	add	r2, r1
 8021788:	9210      	str	r2, [sp, #64]	; 0x40
 802178a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802178c:	3301      	adds	r3, #1
 802178e:	429a      	cmp	r2, r3
 8021790:	9314      	str	r3, [sp, #80]	; 0x50
 8021792:	f47f aeb8 	bne.w	8021506 <cblas_zsyr2k+0x37e>
 8021796:	e66b      	b.n	8021470 <cblas_zsyr2k+0x2e8>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8021798:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802179a:	2b6f      	cmp	r3, #111	; 0x6f
 802179c:	f000 82a0 	beq.w	8021ce0 <cblas_zsyr2k+0xb58>
    } else if (uplo == CblasLower && trans == CblasTrans) {
 80217a0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80217a2:	2b70      	cmp	r3, #112	; 0x70
 80217a4:	f47f adbc 	bne.w	8021320 <cblas_zsyr2k+0x198>
      for (k = 0; k < K; k++) {
 80217a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80217aa:	2b00      	cmp	r3, #0
 80217ac:	f77f ae60 	ble.w	8021470 <cblas_zsyr2k+0x2e8>
 80217b0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80217b2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80217b4:	930b      	str	r3, [sp, #44]	; 0x2c
 80217b6:	0112      	lsls	r2, r2, #4
 80217b8:	920f      	str	r2, [sp, #60]	; 0x3c
 80217ba:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80217bc:	0112      	lsls	r2, r2, #4
 80217be:	9210      	str	r2, [sp, #64]	; 0x40
 80217c0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80217c2:	920a      	str	r2, [sp, #40]	; 0x28
 80217c4:	9a04      	ldr	r2, [sp, #16]
 80217c6:	3310      	adds	r3, #16
 80217c8:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80217cc:	930d      	str	r3, [sp, #52]	; 0x34
 80217ce:	2300      	movs	r3, #0
 80217d0:	930e      	str	r3, [sp, #56]	; 0x38
        for (i = 0; i < N; i++) {
 80217d2:	9b04      	ldr	r3, [sp, #16]
 80217d4:	2b00      	cmp	r3, #0
 80217d6:	f340 8113 	ble.w	8021a00 <cblas_zsyr2k+0x878>
 80217da:	9b15      	ldr	r3, [sp, #84]	; 0x54
 80217dc:	3308      	adds	r3, #8
 80217de:	9302      	str	r3, [sp, #8]
 80217e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80217e2:	3310      	adds	r3, #16
 80217e4:	9300      	str	r3, [sp, #0]
 80217e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80217e8:	9305      	str	r3, [sp, #20]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 80217ea:	9c00      	ldr	r4, [sp, #0]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80217ec:	ed9d 8b06 	vldr	d8, [sp, #24]
          BASE Aki_real = CONST_REAL(A, k * lda + i);
 80217f0:	e954 6704 	ldrd	r6, r7, [r4, #-16]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 80217f4:	ec51 0b18 	vmov	r0, r1, d8
 80217f8:	463b      	mov	r3, r7
 80217fa:	4632      	mov	r2, r6
 80217fc:	f006 fb54 	bl	8027ea8 <__aeabi_dmul>
          BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 8021800:	e954 8902 	ldrd	r8, r9, [r4, #-8]
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021804:	e9dd ab08 	ldrd	sl, fp, [sp, #32]
 8021808:	4642      	mov	r2, r8
 802180a:	464b      	mov	r3, r9
 802180c:	4604      	mov	r4, r0
 802180e:	460d      	mov	r5, r1
 8021810:	4650      	mov	r0, sl
 8021812:	4659      	mov	r1, fp
 8021814:	f006 fb48 	bl	8027ea8 <__aeabi_dmul>
 8021818:	4602      	mov	r2, r0
 802181a:	460b      	mov	r3, r1
 802181c:	4620      	mov	r0, r4
 802181e:	4629      	mov	r1, r5
 8021820:	f006 f98a 	bl	8027b38 <__aeabi_dsub>
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8021824:	4642      	mov	r2, r8
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021826:	4604      	mov	r4, r0
 8021828:	460d      	mov	r5, r1
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802182a:	464b      	mov	r3, r9
 802182c:	ec51 0b18 	vmov	r0, r1, d8
 8021830:	f006 fb3a 	bl	8027ea8 <__aeabi_dmul>
          BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
 8021834:	ec45 4b1e 	vmov	d14, r4, r5
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8021838:	463b      	mov	r3, r7
 802183a:	4604      	mov	r4, r0
 802183c:	460d      	mov	r5, r1
 802183e:	4632      	mov	r2, r6
 8021840:	4650      	mov	r0, sl
 8021842:	4659      	mov	r1, fp
 8021844:	f006 fb30 	bl	8027ea8 <__aeabi_dmul>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8021848:	9f05      	ldr	r7, [sp, #20]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802184a:	4602      	mov	r2, r0
 802184c:	460b      	mov	r3, r1
 802184e:	4620      	mov	r0, r4
 8021850:	4629      	mov	r1, r5
 8021852:	f006 f973 	bl	8027b3c <__adddf3>
          BASE Bki_real = CONST_REAL(B, k * ldb + i);
 8021856:	ed97 9b00 	vldr	d9, [r7]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802185a:	4604      	mov	r4, r0
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 802185c:	ec53 2b19 	vmov	r2, r3, d9
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 8021860:	460d      	mov	r5, r1
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8021862:	ec51 0b18 	vmov	r0, r1, d8
 8021866:	f006 fb1f 	bl	8027ea8 <__aeabi_dmul>
          BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
 802186a:	e9d7 8902 	ldrd	r8, r9, [r7, #8]
          BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
 802186e:	ec45 4b1c 	vmov	d12, r4, r5
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8021872:	4642      	mov	r2, r8
 8021874:	4604      	mov	r4, r0
 8021876:	460d      	mov	r5, r1
 8021878:	464b      	mov	r3, r9
 802187a:	4650      	mov	r0, sl
 802187c:	4659      	mov	r1, fp
 802187e:	f006 fb13 	bl	8027ea8 <__aeabi_dmul>
 8021882:	4602      	mov	r2, r0
 8021884:	460b      	mov	r3, r1
 8021886:	4620      	mov	r0, r4
 8021888:	4629      	mov	r1, r5
 802188a:	f006 f955 	bl	8027b38 <__aeabi_dsub>
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 802188e:	4642      	mov	r2, r8
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 8021890:	4604      	mov	r4, r0
 8021892:	460d      	mov	r5, r1
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 8021894:	464b      	mov	r3, r9
 8021896:	ec51 0b18 	vmov	r0, r1, d8
 802189a:	f006 fb05 	bl	8027ea8 <__aeabi_dmul>
          BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
 802189e:	ec45 4b1b 	vmov	d11, r4, r5
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80218a2:	ec53 2b19 	vmov	r2, r3, d9
 80218a6:	4604      	mov	r4, r0
 80218a8:	460d      	mov	r5, r1
 80218aa:	4650      	mov	r0, sl
 80218ac:	4659      	mov	r1, fp
 80218ae:	f006 fafb 	bl	8027ea8 <__aeabi_dmul>
 80218b2:	460b      	mov	r3, r1
 80218b4:	4602      	mov	r2, r0
 80218b6:	4629      	mov	r1, r5
 80218b8:	4620      	mov	r0, r4
 80218ba:	f006 f93f 	bl	8027b3c <__adddf3>
 80218be:	9b02      	ldr	r3, [sp, #8]
 80218c0:	e9dd 5b0a 	ldrd	r5, fp, [sp, #40]	; 0x28
 80218c4:	ec41 0b1a 	vmov	d10, r0, r1
          for (j = 0; j <= i; j++) {
 80218c8:	f1a3 0a08 	sub.w	sl, r3, #8
          BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
 80218cc:	461c      	mov	r4, r3
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 80218ce:	ed95 7b00 	vldr	d7, [r5]
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80218d2:	ed95 6b02 	vldr	d6, [r5, #8]
            BASE Bkj_real = CONST_REAL(B, k * ldb + j);
 80218d6:	eeb0 da47 	vmov.f32	s26, s14
 80218da:	eef0 da67 	vmov.f32	s27, s15
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80218de:	ec53 2b17 	vmov	r2, r3, d7
            BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
 80218e2:	eeb0 8a46 	vmov.f32	s16, s12
 80218e6:	eef0 8a66 	vmov.f32	s17, s13
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 80218ea:	ec51 0b1e 	vmov	r0, r1, d14
 80218ee:	f006 fadb 	bl	8027ea8 <__aeabi_dmul>
 80218f2:	ec53 2b18 	vmov	r2, r3, d8
 80218f6:	4606      	mov	r6, r0
 80218f8:	460f      	mov	r7, r1
 80218fa:	ec51 0b1c 	vmov	r0, r1, d12
 80218fe:	f006 fad3 	bl	8027ea8 <__aeabi_dmul>
 8021902:	4602      	mov	r2, r0
 8021904:	460b      	mov	r3, r1
 8021906:	4630      	mov	r0, r6
 8021908:	4639      	mov	r1, r7
            BASE Akj_real = CONST_REAL(A, k * lda + j);
 802190a:	e9db 8900 	ldrd	r8, r9, [fp]
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802190e:	f006 f913 	bl	8027b38 <__aeabi_dsub>
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8021912:	4642      	mov	r2, r8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8021914:	4606      	mov	r6, r0
 8021916:	460f      	mov	r7, r1
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8021918:	464b      	mov	r3, r9
 802191a:	ec51 0b1b 	vmov	r0, r1, d11
 802191e:	f006 fac3 	bl	8027ea8 <__aeabi_dmul>
            BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 8021922:	ed9b 9b02 	vldr	d9, [fp, #8]
              + (temp2_real * Akj_real - temp2_imag * Akj_imag);
 8021926:	ec41 0b1f 	vmov	d15, r0, r1
 802192a:	ec53 2b19 	vmov	r2, r3, d9
 802192e:	ec51 0b1a 	vmov	r0, r1, d10
 8021932:	f006 fab9 	bl	8027ea8 <__aeabi_dmul>
 8021936:	4602      	mov	r2, r0
 8021938:	460b      	mov	r3, r1
 802193a:	ec51 0b1f 	vmov	r0, r1, d15
 802193e:	f006 f8fb 	bl	8027b38 <__aeabi_dsub>
 8021942:	4602      	mov	r2, r0
 8021944:	460b      	mov	r3, r1
 8021946:	4630      	mov	r0, r6
 8021948:	4639      	mov	r1, r7
 802194a:	f006 f8f7 	bl	8027b3c <__adddf3>
 802194e:	4602      	mov	r2, r0
 8021950:	460b      	mov	r3, r1
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 8021952:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8021956:	f006 f8f1 	bl	8027b3c <__adddf3>
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802195a:	ec53 2b18 	vmov	r2, r3, d8
            REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
 802195e:	e944 0102 	strd	r0, r1, [r4, #-8]
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 8021962:	ec51 0b1e 	vmov	r0, r1, d14
 8021966:	f006 fa9f 	bl	8027ea8 <__aeabi_dmul>
 802196a:	ec53 2b1d 	vmov	r2, r3, d13
 802196e:	4606      	mov	r6, r0
 8021970:	460f      	mov	r7, r1
 8021972:	ec51 0b1c 	vmov	r0, r1, d12
 8021976:	f006 fa97 	bl	8027ea8 <__aeabi_dmul>
 802197a:	4602      	mov	r2, r0
 802197c:	460b      	mov	r3, r1
 802197e:	4630      	mov	r0, r6
 8021980:	4639      	mov	r1, r7
 8021982:	f006 f8db 	bl	8027b3c <__adddf3>
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 8021986:	ec53 2b19 	vmov	r2, r3, d9
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 802198a:	4606      	mov	r6, r0
 802198c:	460f      	mov	r7, r1
              + (temp2_real * Akj_imag + temp2_imag * Akj_real);
 802198e:	ec51 0b1b 	vmov	r0, r1, d11
 8021992:	f006 fa89 	bl	8027ea8 <__aeabi_dmul>
 8021996:	4642      	mov	r2, r8
 8021998:	464b      	mov	r3, r9
 802199a:	4680      	mov	r8, r0
 802199c:	4689      	mov	r9, r1
 802199e:	ec51 0b1a 	vmov	r0, r1, d10
 80219a2:	f006 fa81 	bl	8027ea8 <__aeabi_dmul>
 80219a6:	4602      	mov	r2, r0
 80219a8:	460b      	mov	r3, r1
 80219aa:	4640      	mov	r0, r8
 80219ac:	4649      	mov	r1, r9
 80219ae:	f006 f8c5 	bl	8027b3c <__adddf3>
 80219b2:	4602      	mov	r2, r0
 80219b4:	460b      	mov	r3, r1
 80219b6:	4630      	mov	r0, r6
 80219b8:	4639      	mov	r1, r7
 80219ba:	f006 f8bf 	bl	8027b3c <__adddf3>
 80219be:	460b      	mov	r3, r1
 80219c0:	4602      	mov	r2, r0
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80219c2:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 80219c6:	f006 f8b9 	bl	8027b3c <__adddf3>
          for (j = 0; j <= i; j++) {
 80219ca:	9b00      	ldr	r3, [sp, #0]
 80219cc:	f10b 0b10 	add.w	fp, fp, #16
 80219d0:	455b      	cmp	r3, fp
            IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
 80219d2:	e9ca 0102 	strd	r0, r1, [sl, #8]
          for (j = 0; j <= i; j++) {
 80219d6:	f105 0510 	add.w	r5, r5, #16
 80219da:	f104 0410 	add.w	r4, r4, #16
 80219de:	f10a 0a10 	add.w	sl, sl, #16
 80219e2:	f47f af74 	bne.w	80218ce <cblas_zsyr2k+0x746>
        for (i = 0; i < N; i++) {
 80219e6:	9a05      	ldr	r2, [sp, #20]
 80219e8:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80219ea:	3210      	adds	r2, #16
 80219ec:	9205      	str	r2, [sp, #20]
 80219ee:	9a02      	ldr	r2, [sp, #8]
 80219f0:	440a      	add	r2, r1
 80219f2:	9202      	str	r2, [sp, #8]
 80219f4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80219f6:	3310      	adds	r3, #16
 80219f8:	429a      	cmp	r2, r3
 80219fa:	9300      	str	r3, [sp, #0]
 80219fc:	f47f aef5 	bne.w	80217ea <cblas_zsyr2k+0x662>
      for (k = 0; k < K; k++) {
 8021a00:	990d      	ldr	r1, [sp, #52]	; 0x34
 8021a02:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8021a04:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8021a06:	4608      	mov	r0, r1
 8021a08:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8021a0a:	4411      	add	r1, r2
 8021a0c:	4410      	add	r0, r2
 8021a0e:	910b      	str	r1, [sp, #44]	; 0x2c
 8021a10:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021a12:	9910      	ldr	r1, [sp, #64]	; 0x40
 8021a14:	900d      	str	r0, [sp, #52]	; 0x34
 8021a16:	440a      	add	r2, r1
 8021a18:	920a      	str	r2, [sp, #40]	; 0x28
 8021a1a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8021a1c:	3301      	adds	r3, #1
 8021a1e:	429a      	cmp	r2, r3
 8021a20:	930e      	str	r3, [sp, #56]	; 0x38
 8021a22:	f47f aed6 	bne.w	80217d2 <cblas_zsyr2k+0x64a>
 8021a26:	e523      	b.n	8021470 <cblas_zsyr2k+0x2e8>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8021a28:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8021a2c:	2200      	movs	r2, #0
 8021a2e:	2300      	movs	r3, #0
 8021a30:	f006 fca2 	bl	8028378 <__aeabi_dcmpeq>
 8021a34:	2800      	cmp	r0, #0
 8021a36:	f43f ac6b 	beq.w	8021310 <cblas_zsyr2k+0x188>
 8021a3a:	e460      	b.n	80212fe <cblas_zsyr2k+0x176>
      for (i = 0; i < N; i++) {
 8021a3c:	9b04      	ldr	r3, [sp, #16]
 8021a3e:	2b00      	cmp	r3, #0
 8021a40:	f77f ad16 	ble.w	8021470 <cblas_zsyr2k+0x2e8>
 8021a44:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021a46:	990c      	ldr	r1, [sp, #48]	; 0x30
 8021a48:	3301      	adds	r3, #1
 8021a4a:	011b      	lsls	r3, r3, #4
 8021a4c:	931b      	str	r3, [sp, #108]	; 0x6c
 8021a4e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021a50:	2200      	movs	r2, #0
 8021a52:	e9cd 2317 	strd	r2, r3, [sp, #92]	; 0x5c
 8021a56:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021a58:	9216      	str	r2, [sp, #88]	; 0x58
 8021a5a:	011b      	lsls	r3, r3, #4
 8021a5c:	931a      	str	r3, [sp, #104]	; 0x68
 8021a5e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8021a60:	9215      	str	r2, [sp, #84]	; 0x54
 8021a62:	011b      	lsls	r3, r3, #4
 8021a64:	9319      	str	r3, [sp, #100]	; 0x64
 8021a66:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8021a68:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 8021a6c:	9205      	str	r2, [sp, #20]
 8021a6e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8021a70:	e9cd 2313 	strd	r2, r3, [sp, #76]	; 0x4c
          BASE temp_real = 0.0;
 8021a74:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021a76:	930a      	str	r3, [sp, #40]	; 0x28
 8021a78:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8021a7a:	930b      	str	r3, [sp, #44]	; 0x2c
 8021a7c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8021a7e:	9310      	str	r3, [sp, #64]	; 0x40
 8021a80:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021a82:	930f      	str	r3, [sp, #60]	; 0x3c
          BASE temp_imag = 0.0;
 8021a84:	ed9f 7b94 	vldr	d7, [pc, #592]	; 8021cd8 <cblas_zsyr2k+0xb50>
          for (k = 0; k < K; k++) {
 8021a88:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8021a8a:	2b00      	cmp	r3, #0
          BASE temp_imag = 0.0;
 8021a8c:	ed8d 7b02 	vstr	d7, [sp, #8]
          BASE temp_real = 0.0;
 8021a90:	ed8d 7b00 	vstr	d7, [sp]
          for (k = 0; k < K; k++) {
 8021a94:	f340 80a6 	ble.w	8021be4 <cblas_zsyr2k+0xa5c>
 8021a98:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8021a9a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021a9c:	e9dd 4a13 	ldrd	r4, sl, [sp, #76]	; 0x4c
 8021aa0:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
 8021aa4:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8021aa6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021aa8:	eb03 1502 	add.w	r5, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8021aac:	ed9a 7b00 	vldr	d7, [sl]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8021ab0:	ed95 6b00 	vldr	d6, [r5]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8021ab4:	eeb0 ea47 	vmov.f32	s28, s14
 8021ab8:	eef0 ea67 	vmov.f32	s29, s15
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8021abc:	ed95 5b02 	vldr	d5, [r5, #8]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8021ac0:	eeb0 da46 	vmov.f32	s26, s12
 8021ac4:	eef0 da66 	vmov.f32	s27, s13
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021ac8:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8021acc:	eeb0 9a45 	vmov.f32	s18, s10
 8021ad0:	eef0 9a65 	vmov.f32	s19, s11
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021ad4:	ec51 0b17 	vmov	r0, r1, d7
 8021ad8:	f006 f9e6 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8021adc:	ed9a 8b02 	vldr	d8, [sl, #8]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021ae0:	ec53 2b19 	vmov	r2, r3, d9
 8021ae4:	4606      	mov	r6, r0
 8021ae6:	460f      	mov	r7, r1
 8021ae8:	ec51 0b18 	vmov	r0, r1, d8
 8021aec:	f006 f9dc 	bl	8027ea8 <__aeabi_dmul>
 8021af0:	4602      	mov	r2, r0
 8021af2:	460b      	mov	r3, r1
 8021af4:	4630      	mov	r0, r6
 8021af6:	4639      	mov	r1, r7
 8021af8:	f006 f81e 	bl	8027b38 <__aeabi_dsub>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8021afc:	ed94 ab00 	vldr	d10, [r4]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8021b00:	ed9b bb00 	vldr	d11, [fp]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021b04:	4606      	mov	r6, r0
 8021b06:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8021b08:	ec53 2b1b 	vmov	r2, r3, d11
 8021b0c:	ec51 0b1a 	vmov	r0, r1, d10
 8021b10:	f006 f9ca 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 8021b14:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8021b18:	ed9b cb02 	vldr	d12, [fp, #8]
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8021b1c:	ec41 0b1f 	vmov	d15, r0, r1
 8021b20:	ec53 2b1c 	vmov	r2, r3, d12
 8021b24:	4640      	mov	r0, r8
 8021b26:	4649      	mov	r1, r9
 8021b28:	f006 f9be 	bl	8027ea8 <__aeabi_dmul>
 8021b2c:	4602      	mov	r2, r0
 8021b2e:	460b      	mov	r3, r1
 8021b30:	ec51 0b1f 	vmov	r0, r1, d15
 8021b34:	f006 f800 	bl	8027b38 <__aeabi_dsub>
 8021b38:	4602      	mov	r2, r0
 8021b3a:	460b      	mov	r3, r1
 8021b3c:	4630      	mov	r0, r6
 8021b3e:	4639      	mov	r1, r7
 8021b40:	f005 fffc 	bl	8027b3c <__adddf3>
 8021b44:	4602      	mov	r2, r0
 8021b46:	460b      	mov	r3, r1
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021b48:	e9dd 0100 	ldrd	r0, r1, [sp]
 8021b4c:	f005 fff6 	bl	8027b3c <__adddf3>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021b50:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021b54:	4606      	mov	r6, r0
 8021b56:	460f      	mov	r7, r1
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021b58:	ec51 0b1e 	vmov	r0, r1, d14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021b5c:	e9cd 6700 	strd	r6, r7, [sp]
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021b60:	f006 f9a2 	bl	8027ea8 <__aeabi_dmul>
 8021b64:	ec53 2b1d 	vmov	r2, r3, d13
 8021b68:	4606      	mov	r6, r0
 8021b6a:	460f      	mov	r7, r1
 8021b6c:	ec51 0b18 	vmov	r0, r1, d8
 8021b70:	f006 f99a 	bl	8027ea8 <__aeabi_dmul>
 8021b74:	4602      	mov	r2, r0
 8021b76:	460b      	mov	r3, r1
 8021b78:	4630      	mov	r0, r6
 8021b7a:	4639      	mov	r1, r7
 8021b7c:	f005 ffde 	bl	8027b3c <__adddf3>
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8021b80:	ec53 2b1c 	vmov	r2, r3, d12
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021b84:	4606      	mov	r6, r0
 8021b86:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8021b88:	ec51 0b1a 	vmov	r0, r1, d10
 8021b8c:	f006 f98c 	bl	8027ea8 <__aeabi_dmul>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021b90:	ec47 6b18 	vmov	d8, r6, r7
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8021b94:	ec53 2b1b 	vmov	r2, r3, d11
 8021b98:	4606      	mov	r6, r0
 8021b9a:	460f      	mov	r7, r1
 8021b9c:	4640      	mov	r0, r8
 8021b9e:	4649      	mov	r1, r9
 8021ba0:	f006 f982 	bl	8027ea8 <__aeabi_dmul>
 8021ba4:	4602      	mov	r2, r0
 8021ba6:	460b      	mov	r3, r1
 8021ba8:	4630      	mov	r0, r6
 8021baa:	4639      	mov	r1, r7
 8021bac:	f005 ffc6 	bl	8027b3c <__adddf3>
 8021bb0:	4602      	mov	r2, r0
 8021bb2:	460b      	mov	r3, r1
 8021bb4:	ec51 0b18 	vmov	r0, r1, d8
 8021bb8:	f005 ffc0 	bl	8027b3c <__adddf3>
 8021bbc:	460b      	mov	r3, r1
 8021bbe:	4602      	mov	r2, r0
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021bc0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021bc4:	f005 ffba 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 8021bc8:	9b05      	ldr	r3, [sp, #20]
 8021bca:	f10a 0a10 	add.w	sl, sl, #16
 8021bce:	459a      	cmp	sl, r3
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021bd0:	e9cd 0102 	strd	r0, r1, [sp, #8]
          for (k = 0; k < K; k++) {
 8021bd4:	f105 0510 	add.w	r5, r5, #16
 8021bd8:	f104 0410 	add.w	r4, r4, #16
 8021bdc:	f10b 0b10 	add.w	fp, fp, #16
 8021be0:	f47f af64 	bne.w	8021aac <cblas_zsyr2k+0x924>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8021be4:	ed9d 9b00 	vldr	d9, [sp]
 8021be8:	ed9d 8b06 	vldr	d8, [sp, #24]
 8021bec:	ec53 2b19 	vmov	r2, r3, d9
 8021bf0:	ec51 0b18 	vmov	r0, r1, d8
 8021bf4:	f006 f958 	bl	8027ea8 <__aeabi_dmul>
 8021bf8:	e9dd 9a02 	ldrd	r9, sl, [sp, #8]
 8021bfc:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 8021c00:	4604      	mov	r4, r0
 8021c02:	460d      	mov	r5, r1
 8021c04:	464a      	mov	r2, r9
 8021c06:	4653      	mov	r3, sl
 8021c08:	4638      	mov	r0, r7
 8021c0a:	4641      	mov	r1, r8
 8021c0c:	f006 f94c 	bl	8027ea8 <__aeabi_dmul>
 8021c10:	4602      	mov	r2, r0
 8021c12:	460b      	mov	r3, r1
 8021c14:	4620      	mov	r0, r4
 8021c16:	4629      	mov	r1, r5
 8021c18:	f005 ff8e 	bl	8027b38 <__aeabi_dsub>
 8021c1c:	9e10      	ldr	r6, [sp, #64]	; 0x40
 8021c1e:	4602      	mov	r2, r0
 8021c20:	460b      	mov	r3, r1
 8021c22:	e9d6 0100 	ldrd	r0, r1, [r6]
 8021c26:	f005 ff89 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8021c2a:	464a      	mov	r2, r9
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8021c2c:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8021c30:	4653      	mov	r3, sl
 8021c32:	ec51 0b18 	vmov	r0, r1, d8
 8021c36:	f006 f937 	bl	8027ea8 <__aeabi_dmul>
 8021c3a:	ec53 2b19 	vmov	r2, r3, d9
 8021c3e:	460d      	mov	r5, r1
 8021c40:	4604      	mov	r4, r0
 8021c42:	4641      	mov	r1, r8
 8021c44:	4638      	mov	r0, r7
 8021c46:	f006 f92f 	bl	8027ea8 <__aeabi_dmul>
 8021c4a:	4602      	mov	r2, r0
 8021c4c:	460b      	mov	r3, r1
 8021c4e:	4620      	mov	r0, r4
 8021c50:	4629      	mov	r1, r5
 8021c52:	f005 ff73 	bl	8027b3c <__adddf3>
 8021c56:	4602      	mov	r2, r0
 8021c58:	460b      	mov	r3, r1
 8021c5a:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8021c5e:	f005 ff6d 	bl	8027b3c <__adddf3>
 8021c62:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8021c64:	9d0d      	ldr	r5, [sp, #52]	; 0x34
        for (j = i; j < N; j++) {
 8021c66:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8021c68:	442b      	add	r3, r5
 8021c6a:	930b      	str	r3, [sp, #44]	; 0x2c
 8021c6c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 8021c6e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8021c70:	442b      	add	r3, r5
 8021c72:	930a      	str	r3, [sp, #40]	; 0x28
 8021c74:	f106 0310 	add.w	r3, r6, #16
 8021c78:	9310      	str	r3, [sp, #64]	; 0x40
 8021c7a:	9b04      	ldr	r3, [sp, #16]
 8021c7c:	3201      	adds	r2, #1
 8021c7e:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8021c80:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = i; j < N; j++) {
 8021c84:	920f      	str	r2, [sp, #60]	; 0x3c
 8021c86:	f73f aefd 	bgt.w	8021a84 <cblas_zsyr2k+0x8fc>
      for (i = 0; i < N; i++) {
 8021c8a:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8021c8c:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8021c8e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021c90:	440a      	add	r2, r1
 8021c92:	9218      	str	r2, [sp, #96]	; 0x60
 8021c94:	990d      	ldr	r1, [sp, #52]	; 0x34
 8021c96:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8021c98:	440a      	add	r2, r1
 8021c9a:	9217      	str	r2, [sp, #92]	; 0x5c
 8021c9c:	990e      	ldr	r1, [sp, #56]	; 0x38
 8021c9e:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8021ca0:	440a      	add	r2, r1
 8021ca2:	9914      	ldr	r1, [sp, #80]	; 0x50
 8021ca4:	9216      	str	r2, [sp, #88]	; 0x58
 8021ca6:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8021ca8:	4608      	mov	r0, r1
 8021caa:	4410      	add	r0, r2
 8021cac:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8021cae:	9014      	str	r0, [sp, #80]	; 0x50
 8021cb0:	9819      	ldr	r0, [sp, #100]	; 0x64
 8021cb2:	4401      	add	r1, r0
 8021cb4:	9113      	str	r1, [sp, #76]	; 0x4c
 8021cb6:	9905      	ldr	r1, [sp, #20]
 8021cb8:	4411      	add	r1, r2
 8021cba:	9a04      	ldr	r2, [sp, #16]
 8021cbc:	9105      	str	r1, [sp, #20]
 8021cbe:	3301      	adds	r3, #1
 8021cc0:	429a      	cmp	r2, r3
 8021cc2:	9315      	str	r3, [sp, #84]	; 0x54
 8021cc4:	f47f aed6 	bne.w	8021a74 <cblas_zsyr2k+0x8ec>
 8021cc8:	f7ff bbd2 	b.w	8021470 <cblas_zsyr2k+0x2e8>
  CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
 8021ccc:	200e      	movs	r0, #14
 8021cce:	f7ff baa1 	b.w	8021214 <cblas_zsyr2k+0x8c>
 8021cd2:	bf00      	nop
 8021cd4:	f3af 8000 	nop.w
	...
      for (i = 0; i < N; i++) {
 8021ce0:	9b04      	ldr	r3, [sp, #16]
 8021ce2:	2b00      	cmp	r3, #0
 8021ce4:	f77f abc4 	ble.w	8021470 <cblas_zsyr2k+0x2e8>
 8021ce8:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021cea:	990c      	ldr	r1, [sp, #48]	; 0x30
 8021cec:	3301      	adds	r3, #1
 8021cee:	011b      	lsls	r3, r3, #4
 8021cf0:	931b      	str	r3, [sp, #108]	; 0x6c
 8021cf2:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021cf4:	3310      	adds	r3, #16
 8021cf6:	9310      	str	r3, [sp, #64]	; 0x40
 8021cf8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8021cfa:	011b      	lsls	r3, r3, #4
 8021cfc:	931a      	str	r3, [sp, #104]	; 0x68
 8021cfe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8021d00:	011b      	lsls	r3, r3, #4
 8021d02:	9319      	str	r3, [sp, #100]	; 0x64
 8021d04:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8021d06:	2200      	movs	r2, #0
 8021d08:	9217      	str	r2, [sp, #92]	; 0x5c
 8021d0a:	9218      	str	r2, [sp, #96]	; 0x60
 8021d0c:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 8021d10:	9205      	str	r2, [sp, #20]
 8021d12:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8021d14:	e9cd 2313 	strd	r2, r3, [sp, #76]	; 0x4c
          BASE temp_real = 0.0;
 8021d18:	2300      	movs	r3, #0
 8021d1a:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
 8021d1e:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8021d20:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021d22:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8021d26:	930f      	str	r3, [sp, #60]	; 0x3c
          BASE temp_imag = 0.0;
 8021d28:	ed1f 7b15 	vldr	d7, [pc, #-84]	; 8021cd8 <cblas_zsyr2k+0xb50>
          for (k = 0; k < K; k++) {
 8021d2c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8021d2e:	2b00      	cmp	r3, #0
          BASE temp_imag = 0.0;
 8021d30:	ed8d 7b02 	vstr	d7, [sp, #8]
          BASE temp_real = 0.0;
 8021d34:	ed8d 7b00 	vstr	d7, [sp]
          for (k = 0; k < K; k++) {
 8021d38:	f340 80a6 	ble.w	8021e88 <cblas_zsyr2k+0xd00>
 8021d3c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8021d3e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021d40:	e9dd 5a13 	ldrd	r5, sl, [sp, #76]	; 0x4c
 8021d44:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
 8021d48:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8021d4a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021d4c:	eb03 1402 	add.w	r4, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8021d50:	ed9a 7b00 	vldr	d7, [sl]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8021d54:	ed94 6b00 	vldr	d6, [r4]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8021d58:	eeb0 ea47 	vmov.f32	s28, s14
 8021d5c:	eef0 ea67 	vmov.f32	s29, s15
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8021d60:	ed94 5b02 	vldr	d5, [r4, #8]
            const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
 8021d64:	eeb0 da46 	vmov.f32	s26, s12
 8021d68:	eef0 da66 	vmov.f32	s27, s13
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021d6c:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
 8021d70:	eeb0 9a45 	vmov.f32	s18, s10
 8021d74:	eef0 9a65 	vmov.f32	s19, s11
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021d78:	ec51 0b17 	vmov	r0, r1, d7
 8021d7c:	f006 f894 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8021d80:	ed9a 8b02 	vldr	d8, [sl, #8]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021d84:	ec53 2b19 	vmov	r2, r3, d9
 8021d88:	4606      	mov	r6, r0
 8021d8a:	460f      	mov	r7, r1
 8021d8c:	ec51 0b18 	vmov	r0, r1, d8
 8021d90:	f006 f88a 	bl	8027ea8 <__aeabi_dmul>
 8021d94:	4602      	mov	r2, r0
 8021d96:	460b      	mov	r3, r1
 8021d98:	4630      	mov	r0, r6
 8021d9a:	4639      	mov	r1, r7
 8021d9c:	f005 fecc 	bl	8027b38 <__aeabi_dsub>
            const BASE Bik_real = CONST_REAL(B, i * ldb + k);
 8021da0:	ed95 ab00 	vldr	d10, [r5]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8021da4:	ed9b bb00 	vldr	d11, [fp]
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021da8:	4606      	mov	r6, r0
 8021daa:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8021dac:	ec53 2b1b 	vmov	r2, r3, d11
 8021db0:	ec51 0b1a 	vmov	r0, r1, d10
 8021db4:	f006 f878 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
 8021db8:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8021dbc:	ed9b cb02 	vldr	d12, [fp, #8]
                          + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
 8021dc0:	ec41 0b1f 	vmov	d15, r0, r1
 8021dc4:	ec53 2b1c 	vmov	r2, r3, d12
 8021dc8:	4640      	mov	r0, r8
 8021dca:	4649      	mov	r1, r9
 8021dcc:	f006 f86c 	bl	8027ea8 <__aeabi_dmul>
 8021dd0:	4602      	mov	r2, r0
 8021dd2:	460b      	mov	r3, r1
 8021dd4:	ec51 0b1f 	vmov	r0, r1, d15
 8021dd8:	f005 feae 	bl	8027b38 <__aeabi_dsub>
 8021ddc:	4602      	mov	r2, r0
 8021dde:	460b      	mov	r3, r1
 8021de0:	4630      	mov	r0, r6
 8021de2:	4639      	mov	r1, r7
 8021de4:	f005 feaa 	bl	8027b3c <__adddf3>
 8021de8:	4602      	mov	r2, r0
 8021dea:	460b      	mov	r3, r1
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021dec:	e9dd 0100 	ldrd	r0, r1, [sp]
 8021df0:	f005 fea4 	bl	8027b3c <__adddf3>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021df4:	ec53 2b19 	vmov	r2, r3, d9
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021df8:	4606      	mov	r6, r0
 8021dfa:	460f      	mov	r7, r1
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021dfc:	ec51 0b1e 	vmov	r0, r1, d14
            temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
 8021e00:	e9cd 6700 	strd	r6, r7, [sp]
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021e04:	f006 f850 	bl	8027ea8 <__aeabi_dmul>
 8021e08:	ec53 2b1d 	vmov	r2, r3, d13
 8021e0c:	4606      	mov	r6, r0
 8021e0e:	460f      	mov	r7, r1
 8021e10:	ec51 0b18 	vmov	r0, r1, d8
 8021e14:	f006 f848 	bl	8027ea8 <__aeabi_dmul>
 8021e18:	4602      	mov	r2, r0
 8021e1a:	460b      	mov	r3, r1
 8021e1c:	4630      	mov	r0, r6
 8021e1e:	4639      	mov	r1, r7
 8021e20:	f005 fe8c 	bl	8027b3c <__adddf3>
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8021e24:	ec53 2b1c 	vmov	r2, r3, d12
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021e28:	4606      	mov	r6, r0
 8021e2a:	460f      	mov	r7, r1
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8021e2c:	ec51 0b1a 	vmov	r0, r1, d10
 8021e30:	f006 f83a 	bl	8027ea8 <__aeabi_dmul>
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021e34:	ec47 6b18 	vmov	d8, r6, r7
                          + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
 8021e38:	ec53 2b1b 	vmov	r2, r3, d11
 8021e3c:	4606      	mov	r6, r0
 8021e3e:	460f      	mov	r7, r1
 8021e40:	4640      	mov	r0, r8
 8021e42:	4649      	mov	r1, r9
 8021e44:	f006 f830 	bl	8027ea8 <__aeabi_dmul>
 8021e48:	4602      	mov	r2, r0
 8021e4a:	460b      	mov	r3, r1
 8021e4c:	4630      	mov	r0, r6
 8021e4e:	4639      	mov	r1, r7
 8021e50:	f005 fe74 	bl	8027b3c <__adddf3>
 8021e54:	4602      	mov	r2, r0
 8021e56:	460b      	mov	r3, r1
 8021e58:	ec51 0b18 	vmov	r0, r1, d8
 8021e5c:	f005 fe6e 	bl	8027b3c <__adddf3>
 8021e60:	460b      	mov	r3, r1
 8021e62:	4602      	mov	r2, r0
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021e64:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8021e68:	f005 fe68 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 8021e6c:	9b05      	ldr	r3, [sp, #20]
 8021e6e:	f10a 0a10 	add.w	sl, sl, #16
 8021e72:	4553      	cmp	r3, sl
            temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
 8021e74:	e9cd 0102 	strd	r0, r1, [sp, #8]
          for (k = 0; k < K; k++) {
 8021e78:	f104 0410 	add.w	r4, r4, #16
 8021e7c:	f105 0510 	add.w	r5, r5, #16
 8021e80:	f10b 0b10 	add.w	fp, fp, #16
 8021e84:	f47f af64 	bne.w	8021d50 <cblas_zsyr2k+0xbc8>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8021e88:	ed9d 9b00 	vldr	d9, [sp]
 8021e8c:	ed9d 8b06 	vldr	d8, [sp, #24]
 8021e90:	ec53 2b19 	vmov	r2, r3, d9
 8021e94:	ec51 0b18 	vmov	r0, r1, d8
 8021e98:	f006 f806 	bl	8027ea8 <__aeabi_dmul>
 8021e9c:	e9dd 9a02 	ldrd	r9, sl, [sp, #8]
 8021ea0:	e9dd 7808 	ldrd	r7, r8, [sp, #32]
 8021ea4:	4604      	mov	r4, r0
 8021ea6:	460d      	mov	r5, r1
 8021ea8:	464a      	mov	r2, r9
 8021eaa:	4653      	mov	r3, sl
 8021eac:	4638      	mov	r0, r7
 8021eae:	4641      	mov	r1, r8
 8021eb0:	f005 fffa 	bl	8027ea8 <__aeabi_dmul>
 8021eb4:	4602      	mov	r2, r0
 8021eb6:	460b      	mov	r3, r1
 8021eb8:	4620      	mov	r0, r4
 8021eba:	4629      	mov	r1, r5
 8021ebc:	f005 fe3c 	bl	8027b38 <__aeabi_dsub>
 8021ec0:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8021ec2:	4602      	mov	r2, r0
 8021ec4:	460b      	mov	r3, r1
 8021ec6:	e9d6 0100 	ldrd	r0, r1, [r6]
 8021eca:	f005 fe37 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8021ece:	464a      	mov	r2, r9
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8021ed0:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8021ed4:	4653      	mov	r3, sl
 8021ed6:	ec51 0b18 	vmov	r0, r1, d8
 8021eda:	f005 ffe5 	bl	8027ea8 <__aeabi_dmul>
 8021ede:	ec53 2b19 	vmov	r2, r3, d9
 8021ee2:	4604      	mov	r4, r0
 8021ee4:	460d      	mov	r5, r1
 8021ee6:	4638      	mov	r0, r7
 8021ee8:	4641      	mov	r1, r8
 8021eea:	f005 ffdd 	bl	8027ea8 <__aeabi_dmul>
 8021eee:	4602      	mov	r2, r0
 8021ef0:	460b      	mov	r3, r1
 8021ef2:	4620      	mov	r0, r4
 8021ef4:	4629      	mov	r1, r5
 8021ef6:	f005 fe21 	bl	8027b3c <__adddf3>
 8021efa:	4602      	mov	r2, r0
 8021efc:	460b      	mov	r3, r1
 8021efe:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 8021f02:	f005 fe1b 	bl	8027b3c <__adddf3>
 8021f06:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8021f08:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = 0; j <= i; j++) {
 8021f0c:	990d      	ldr	r1, [sp, #52]	; 0x34
 8021f0e:	440a      	add	r2, r1
 8021f10:	920b      	str	r2, [sp, #44]	; 0x2c
 8021f12:	990e      	ldr	r1, [sp, #56]	; 0x38
 8021f14:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021f16:	440a      	add	r2, r1
 8021f18:	920a      	str	r2, [sp, #40]	; 0x28
 8021f1a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021f1c:	f106 0310 	add.w	r3, r6, #16
 8021f20:	429a      	cmp	r2, r3
 8021f22:	930f      	str	r3, [sp, #60]	; 0x3c
 8021f24:	f47f af00 	bne.w	8021d28 <cblas_zsyr2k+0xba0>
      for (i = 0; i < N; i++) {
 8021f28:	e9dd 1216 	ldrd	r1, r2, [sp, #88]	; 0x58
 8021f2c:	440a      	add	r2, r1
 8021f2e:	9217      	str	r2, [sp, #92]	; 0x5c
 8021f30:	991b      	ldr	r1, [sp, #108]	; 0x6c
 8021f32:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8021f34:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8021f36:	440a      	add	r2, r1
 8021f38:	9914      	ldr	r1, [sp, #80]	; 0x50
 8021f3a:	9210      	str	r2, [sp, #64]	; 0x40
 8021f3c:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8021f3e:	4608      	mov	r0, r1
 8021f40:	4410      	add	r0, r2
 8021f42:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8021f44:	9014      	str	r0, [sp, #80]	; 0x50
 8021f46:	9819      	ldr	r0, [sp, #100]	; 0x64
 8021f48:	4401      	add	r1, r0
 8021f4a:	9113      	str	r1, [sp, #76]	; 0x4c
 8021f4c:	9905      	ldr	r1, [sp, #20]
 8021f4e:	4411      	add	r1, r2
 8021f50:	9a04      	ldr	r2, [sp, #16]
 8021f52:	9105      	str	r1, [sp, #20]
 8021f54:	3301      	adds	r3, #1
 8021f56:	429a      	cmp	r2, r3
 8021f58:	9318      	str	r3, [sp, #96]	; 0x60
 8021f5a:	f47f aedd 	bne.w	8021d18 <cblas_zsyr2k+0xb90>
 8021f5e:	f7ff ba87 	b.w	8021470 <cblas_zsyr2k+0x2e8>
        for (i = 0; i < N; i++) {
 8021f62:	2b00      	cmp	r3, #0
 8021f64:	f77f aab3 	ble.w	80214ce <cblas_zsyr2k+0x346>
 8021f68:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8021f6a:	3301      	adds	r3, #1
 8021f6c:	011b      	lsls	r3, r3, #4
 8021f6e:	9305      	str	r3, [sp, #20]
 8021f70:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8021f72:	9302      	str	r3, [sp, #8]
 8021f74:	2300      	movs	r3, #0
 8021f76:	9300      	str	r3, [sp, #0]
 8021f78:	f8dd a008 	ldr.w	sl, [sp, #8]
 8021f7c:	f8dd b000 	ldr.w	fp, [sp]
 8021f80:	ec59 8b1b 	vmov	r8, r9, d11
            const BASE Cij_real = REAL(C, ldc * i + j);
 8021f84:	e9da 4500 	ldrd	r4, r5, [sl]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8021f88:	4640      	mov	r0, r8
 8021f8a:	4622      	mov	r2, r4
 8021f8c:	462b      	mov	r3, r5
 8021f8e:	4649      	mov	r1, r9
 8021f90:	f005 ff8a 	bl	8027ea8 <__aeabi_dmul>
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8021f94:	e9da 6702 	ldrd	r6, r7, [sl, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8021f98:	ec41 0b19 	vmov	d9, r0, r1
 8021f9c:	4632      	mov	r2, r6
 8021f9e:	463b      	mov	r3, r7
 8021fa0:	ec51 0b1a 	vmov	r0, r1, d10
 8021fa4:	f005 ff80 	bl	8027ea8 <__aeabi_dmul>
 8021fa8:	4602      	mov	r2, r0
 8021faa:	460b      	mov	r3, r1
 8021fac:	ec51 0b19 	vmov	r0, r1, d9
 8021fb0:	f005 fdc2 	bl	8027b38 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8021fb4:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8021fb6:	e9ca 0100 	strd	r0, r1, [sl]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8021fba:	463b      	mov	r3, r7
 8021fbc:	4640      	mov	r0, r8
 8021fbe:	4649      	mov	r1, r9
 8021fc0:	f005 ff72 	bl	8027ea8 <__aeabi_dmul>
 8021fc4:	4622      	mov	r2, r4
 8021fc6:	462b      	mov	r3, r5
 8021fc8:	4604      	mov	r4, r0
 8021fca:	460d      	mov	r5, r1
 8021fcc:	ec51 0b1a 	vmov	r0, r1, d10
 8021fd0:	f005 ff6a 	bl	8027ea8 <__aeabi_dmul>
 8021fd4:	460b      	mov	r3, r1
 8021fd6:	4602      	mov	r2, r0
 8021fd8:	4629      	mov	r1, r5
 8021fda:	4620      	mov	r0, r4
 8021fdc:	f005 fdae 	bl	8027b3c <__adddf3>
          for (j = i; j < N; j++) {
 8021fe0:	9b04      	ldr	r3, [sp, #16]
 8021fe2:	f10b 0b01 	add.w	fp, fp, #1
 8021fe6:	455b      	cmp	r3, fp
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8021fe8:	e9ca 0102 	strd	r0, r1, [sl, #8]
          for (j = i; j < N; j++) {
 8021fec:	f10a 0a10 	add.w	sl, sl, #16
 8021ff0:	dcc8      	bgt.n	8021f84 <cblas_zsyr2k+0xdfc>
        for (i = 0; i < N; i++) {
 8021ff2:	9a02      	ldr	r2, [sp, #8]
 8021ff4:	9905      	ldr	r1, [sp, #20]
 8021ff6:	9b00      	ldr	r3, [sp, #0]
 8021ff8:	440a      	add	r2, r1
 8021ffa:	9202      	str	r2, [sp, #8]
 8021ffc:	9a04      	ldr	r2, [sp, #16]
 8021ffe:	3301      	adds	r3, #1
 8022000:	429a      	cmp	r2, r3
 8022002:	9300      	str	r3, [sp, #0]
 8022004:	d1b8      	bne.n	8021f78 <cblas_zsyr2k+0xdf0>
 8022006:	f7ff ba62 	b.w	80214ce <cblas_zsyr2k+0x346>
 802200a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802200c:	f7ff b993 	b.w	8021336 <cblas_zsyr2k+0x1ae>

08022010 <cblas_zsyrk>:
void
cblas_zsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
             const void *alpha, const void *A, const int lda,
             const void *beta, void *C, const int ldc)
{
 8022010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022014:	ed2d 8b0e 	vpush	{d8-d14}
 8022018:	b093      	sub	sp, #76	; 0x4c
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 802201a:	2865      	cmp	r0, #101	; 0x65
 802201c:	9303      	str	r3, [sp, #12]
 802201e:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8022020:	9301      	str	r3, [sp, #4]
 8022022:	e9dd 832b 	ldrd	r8, r3, [sp, #172]	; 0xac
 8022026:	9304      	str	r3, [sp, #16]
 8022028:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 802202a:	9306      	str	r3, [sp, #24]
 802202c:	e9dd 732e 	ldrd	r7, r3, [sp, #184]	; 0xb8
 8022030:	930c      	str	r3, [sp, #48]	; 0x30
 8022032:	9b30      	ldr	r3, [sp, #192]	; 0xc0
 8022034:	930b      	str	r3, [sp, #44]	; 0x2c
 8022036:	4606      	mov	r6, r0
 8022038:	460c      	mov	r4, r1
 802203a:	4615      	mov	r5, r2
 802203c:	f000 815a 	beq.w	80222f4 <cblas_zsyrk+0x2e4>
 8022040:	2a6f      	cmp	r2, #111	; 0x6f
 8022042:	d023      	beq.n	802208c <cblas_zsyrk+0x7c>
 8022044:	9b01      	ldr	r3, [sp, #4]
 8022046:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 802204a:	2a01      	cmp	r2, #1
 802204c:	f240 814b 	bls.w	80222e6 <cblas_zsyrk+0x2d6>
 8022050:	2002      	movs	r0, #2
 8022052:	f1a5 026f 	sub.w	r2, r5, #111	; 0x6f
 8022056:	2a02      	cmp	r2, #2
 8022058:	bf88      	it	hi
 802205a:	2003      	movhi	r0, #3
 802205c:	9a03      	ldr	r2, [sp, #12]
 802205e:	9901      	ldr	r1, [sp, #4]
 8022060:	2a00      	cmp	r2, #0
 8022062:	bfb8      	it	lt
 8022064:	2004      	movlt	r0, #4
 8022066:	2b01      	cmp	r3, #1
 8022068:	bfb8      	it	lt
 802206a:	2301      	movlt	r3, #1
 802206c:	2900      	cmp	r1, #0
 802206e:	f2c0 812d 	blt.w	80222cc <cblas_zsyrk+0x2bc>
 8022072:	9a06      	ldr	r2, [sp, #24]
 8022074:	4293      	cmp	r3, r2
 8022076:	dc11      	bgt.n	802209c <cblas_zsyrk+0x8c>
 8022078:	9b03      	ldr	r3, [sp, #12]
 802207a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 802207c:	2b01      	cmp	r3, #1
 802207e:	bfb8      	it	lt
 8022080:	2301      	movlt	r3, #1
 8022082:	4293      	cmp	r3, r2
 8022084:	f300 8345 	bgt.w	8022712 <cblas_zsyrk+0x702>
 8022088:	b1a8      	cbz	r0, 80220b6 <cblas_zsyrk+0xa6>
 802208a:	e010      	b.n	80220ae <cblas_zsyrk+0x9e>
 802208c:	9b03      	ldr	r3, [sp, #12]
 802208e:	f1a4 0279 	sub.w	r2, r4, #121	; 0x79
 8022092:	2a01      	cmp	r2, #1
 8022094:	f240 8127 	bls.w	80222e6 <cblas_zsyrk+0x2d6>
 8022098:	2002      	movs	r0, #2
 802209a:	e7df      	b.n	802205c <cblas_zsyrk+0x4c>
 802209c:	9803      	ldr	r0, [sp, #12]
 802209e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80220a0:	2801      	cmp	r0, #1
 80220a2:	bfb8      	it	lt
 80220a4:	2001      	movlt	r0, #1
 80220a6:	4298      	cmp	r0, r3
 80220a8:	bfcc      	ite	gt
 80220aa:	200b      	movgt	r0, #11
 80220ac:	2008      	movle	r0, #8
 80220ae:	4a97      	ldr	r2, [pc, #604]	; (802230c <cblas_zsyrk+0x2fc>)
 80220b0:	4997      	ldr	r1, [pc, #604]	; (8022310 <cblas_zsyrk+0x300>)
 80220b2:	f005 fcc9 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 80220b6:	ed98 7b00 	vldr	d7, [r8]
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 80220ba:	2200      	movs	r2, #0
 80220bc:	ec51 0b17 	vmov	r0, r1, d7
    const BASE alpha_real = CONST_REAL0(alpha);
 80220c0:	eeb0 da47 	vmov.f32	s26, s14
 80220c4:	eef0 da67 	vmov.f32	s27, s15
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 80220c8:	2300      	movs	r3, #0
 80220ca:	f006 f955 	bl	8028378 <__aeabi_dcmpeq>
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80220ce:	ed98 7b02 	vldr	d7, [r8, #8]
    const BASE beta_real = CONST_REAL0(beta);
 80220d2:	ed97 8b00 	vldr	d8, [r7]
    const BASE alpha_imag = CONST_IMAG0(alpha);
 80220d6:	eeb0 ea47 	vmov.f32	s28, s14
 80220da:	eef0 ea67 	vmov.f32	s29, s15
    const BASE beta_imag = CONST_IMAG0(beta);
 80220de:	ed97 9b02 	vldr	d9, [r7, #8]
    const BASE beta_real = CONST_REAL0(beta);
 80220e2:	eeb0 ba48 	vmov.f32	s22, s16
 80220e6:	eef0 ba68 	vmov.f32	s23, s17
    const BASE beta_imag = CONST_IMAG0(beta);
 80220ea:	eeb0 aa49 	vmov.f32	s20, s18
 80220ee:	eef0 aa69 	vmov.f32	s21, s19
    if ((alpha_real == 0.0 && alpha_imag == 0.0)
 80220f2:	b178      	cbz	r0, 8022114 <cblas_zsyrk+0x104>
 80220f4:	ec51 0b17 	vmov	r0, r1, d7
 80220f8:	2200      	movs	r2, #0
 80220fa:	2300      	movs	r3, #0
 80220fc:	f006 f93c 	bl	8028378 <__aeabi_dcmpeq>
 8022100:	b140      	cbz	r0, 8022114 <cblas_zsyrk+0x104>
        && (beta_real == 1.0 && beta_imag == 0.0))
 8022102:	4b84      	ldr	r3, [pc, #528]	; (8022314 <cblas_zsyrk+0x304>)
 8022104:	ec51 0b18 	vmov	r0, r1, d8
 8022108:	2200      	movs	r2, #0
 802210a:	f006 f935 	bl	8028378 <__aeabi_dcmpeq>
 802210e:	2800      	cmp	r0, #0
 8022110:	f040 80ce 	bne.w	80222b0 <cblas_zsyrk+0x2a0>
    if (Order == CblasRowMajor) {
 8022114:	2e65      	cmp	r6, #101	; 0x65
 8022116:	f000 80f2 	beq.w	80222fe <cblas_zsyrk+0x2ee>
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 802211a:	2c79      	cmp	r4, #121	; 0x79
 802211c:	bf0c      	ite	eq
 802211e:	237a      	moveq	r3, #122	; 0x7a
 8022120:	2379      	movne	r3, #121	; 0x79
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8022122:	2d6f      	cmp	r5, #111	; 0x6f
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
 8022124:	930a      	str	r3, [sp, #40]	; 0x28
      trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
 8022126:	bf0c      	ite	eq
 8022128:	2370      	moveq	r3, #112	; 0x70
 802212a:	236f      	movne	r3, #111	; 0x6f
 802212c:	930d      	str	r3, [sp, #52]	; 0x34
    if (beta_real == 0.0 && beta_imag == 0.0) {
 802212e:	2200      	movs	r2, #0
 8022130:	ec51 0b1b 	vmov	r0, r1, d11
 8022134:	2300      	movs	r3, #0
 8022136:	f006 f91f 	bl	8028378 <__aeabi_dcmpeq>
 802213a:	2200      	movs	r2, #0
 802213c:	2800      	cmp	r0, #0
 802213e:	d04a      	beq.n	80221d6 <cblas_zsyrk+0x1c6>
 8022140:	ec51 0b1a 	vmov	r0, r1, d10
 8022144:	2300      	movs	r3, #0
 8022146:	f006 f917 	bl	8028378 <__aeabi_dcmpeq>
 802214a:	2800      	cmp	r0, #0
 802214c:	d052      	beq.n	80221f4 <cblas_zsyrk+0x1e4>
      if (uplo == CblasUpper) {
 802214e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022150:	2b79      	cmp	r3, #121	; 0x79
 8022152:	f000 80e3 	beq.w	802231c <cblas_zsyrk+0x30c>
        for (i = 0; i < N; i++) {
 8022156:	9b03      	ldr	r3, [sp, #12]
 8022158:	2b00      	cmp	r3, #0
 802215a:	dd1a      	ble.n	8022192 <cblas_zsyrk+0x182>
 802215c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802215e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022160:	9d03      	ldr	r5, [sp, #12]
 8022162:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
 8022166:	1c5c      	adds	r4, r3, #1
 8022168:	2100      	movs	r1, #0
            REAL(C, ldc * i + j) = 0.0;
 802216a:	2600      	movs	r6, #0
 802216c:	2700      	movs	r7, #0
 802216e:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 8022170:	4608      	mov	r0, r1
 8022172:	3210      	adds	r2, #16
 8022174:	469e      	mov	lr, r3
 8022176:	eb0c 1301 	add.w	r3, ip, r1, lsl #4
            REAL(C, ldc * i + j) = 0.0;
 802217a:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 802217e:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = 0; j <= i; j++) {
 8022182:	3310      	adds	r3, #16
 8022184:	429a      	cmp	r2, r3
 8022186:	d1f8      	bne.n	802217a <cblas_zsyrk+0x16a>
        for (i = 0; i < N; i++) {
 8022188:	3001      	adds	r0, #1
 802218a:	4285      	cmp	r5, r0
 802218c:	4471      	add	r1, lr
 802218e:	4422      	add	r2, r4
 8022190:	d1f1      	bne.n	8022176 <cblas_zsyrk+0x166>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 8022192:	ec51 0b1d 	vmov	r0, r1, d13
 8022196:	2200      	movs	r2, #0
 8022198:	2300      	movs	r3, #0
 802219a:	f006 f8ed 	bl	8028378 <__aeabi_dcmpeq>
 802219e:	b160      	cbz	r0, 80221ba <cblas_zsyrk+0x1aa>
 80221a0:	ec51 0b1e 	vmov	r0, r1, d14
 80221a4:	2200      	movs	r2, #0
 80221a6:	2300      	movs	r3, #0
 80221a8:	f006 f8e6 	bl	8028378 <__aeabi_dcmpeq>
 80221ac:	2800      	cmp	r0, #0
 80221ae:	f040 8088 	bne.w	80222c2 <cblas_zsyrk+0x2b2>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 80221b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80221b4:	2b79      	cmp	r3, #121	; 0x79
 80221b6:	f000 80d3 	beq.w	8022360 <cblas_zsyrk+0x350>
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 80221ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80221bc:	2b7a      	cmp	r3, #122	; 0x7a
 80221be:	f000 81b3 	beq.w	8022528 <cblas_zsyrk+0x518>
      BLAS_ERROR("unrecognized operation");
 80221c2:	4a55      	ldr	r2, [pc, #340]	; (8022318 <cblas_zsyrk+0x308>)
 80221c4:	4952      	ldr	r1, [pc, #328]	; (8022310 <cblas_zsyrk+0x300>)
 80221c6:	2000      	movs	r0, #0
#define BASE double
#include "source_syrk_c.h"
#undef BASE
}
 80221c8:	b013      	add	sp, #76	; 0x4c
 80221ca:	ecbd 8b0e 	vpop	{d8-d14}
 80221ce:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80221d2:	f005 bc39 	b.w	8027a48 <cblas_xerbla>
    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
 80221d6:	4b4f      	ldr	r3, [pc, #316]	; (8022314 <cblas_zsyrk+0x304>)
 80221d8:	ec51 0b1b 	vmov	r0, r1, d11
 80221dc:	f006 f8cc 	bl	8028378 <__aeabi_dcmpeq>
 80221e0:	b140      	cbz	r0, 80221f4 <cblas_zsyrk+0x1e4>
 80221e2:	ec51 0b1a 	vmov	r0, r1, d10
 80221e6:	2200      	movs	r2, #0
 80221e8:	2300      	movs	r3, #0
 80221ea:	f006 f8c5 	bl	8028378 <__aeabi_dcmpeq>
 80221ee:	2800      	cmp	r0, #0
 80221f0:	f040 8285 	bne.w	80226fe <cblas_zsyrk+0x6ee>
      if (uplo == CblasUpper) {
 80221f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80221f6:	2b79      	cmp	r3, #121	; 0x79
        for (i = 0; i < N; i++) {
 80221f8:	9b03      	ldr	r3, [sp, #12]
      if (uplo == CblasUpper) {
 80221fa:	f000 8461 	beq.w	8022ac0 <cblas_zsyrk+0xab0>
        for (i = 0; i < N; i++) {
 80221fe:	2b00      	cmp	r3, #0
 8022200:	ddc7      	ble.n	8022192 <cblas_zsyrk+0x182>
 8022202:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022204:	011b      	lsls	r3, r3, #4
 8022206:	9309      	str	r3, [sp, #36]	; 0x24
 8022208:	3310      	adds	r3, #16
 802220a:	9308      	str	r3, [sp, #32]
 802220c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802220e:	9305      	str	r3, [sp, #20]
 8022210:	3310      	adds	r3, #16
 8022212:	9302      	str	r3, [sp, #8]
 8022214:	2300      	movs	r3, #0
 8022216:	9307      	str	r3, [sp, #28]
 8022218:	9b05      	ldr	r3, [sp, #20]
 802221a:	ec59 8b1b 	vmov	r8, r9, d11
 802221e:	f103 0a08 	add.w	sl, r3, #8
 8022222:	469b      	mov	fp, r3
            const BASE Cij_real = REAL(C, ldc * i + j);
 8022224:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022228:	4640      	mov	r0, r8
 802222a:	4622      	mov	r2, r4
 802222c:	462b      	mov	r3, r5
 802222e:	4649      	mov	r1, r9
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8022230:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022234:	f005 fe38 	bl	8027ea8 <__aeabi_dmul>
 8022238:	4632      	mov	r2, r6
 802223a:	ec41 0b19 	vmov	d9, r0, r1
 802223e:	463b      	mov	r3, r7
 8022240:	ec51 0b1a 	vmov	r0, r1, d10
 8022244:	f005 fe30 	bl	8027ea8 <__aeabi_dmul>
 8022248:	4602      	mov	r2, r0
 802224a:	460b      	mov	r3, r1
 802224c:	ec51 0b19 	vmov	r0, r1, d9
 8022250:	f005 fc72 	bl	8027b38 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022254:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022256:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 802225a:	463b      	mov	r3, r7
 802225c:	4640      	mov	r0, r8
 802225e:	4649      	mov	r1, r9
 8022260:	f005 fe22 	bl	8027ea8 <__aeabi_dmul>
 8022264:	4622      	mov	r2, r4
 8022266:	462b      	mov	r3, r5
 8022268:	4604      	mov	r4, r0
 802226a:	460d      	mov	r5, r1
 802226c:	ec51 0b1a 	vmov	r0, r1, d10
 8022270:	f005 fe1a 	bl	8027ea8 <__aeabi_dmul>
 8022274:	460b      	mov	r3, r1
 8022276:	4602      	mov	r2, r0
 8022278:	4629      	mov	r1, r5
 802227a:	4620      	mov	r0, r4
 802227c:	f005 fc5e 	bl	8027b3c <__adddf3>
          for (j = 0; j <= i; j++) {
 8022280:	9b02      	ldr	r3, [sp, #8]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022282:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j <= i; j++) {
 8022286:	f10b 0b10 	add.w	fp, fp, #16
 802228a:	455b      	cmp	r3, fp
 802228c:	f10a 0a10 	add.w	sl, sl, #16
 8022290:	d1c8      	bne.n	8022224 <cblas_zsyrk+0x214>
        for (i = 0; i < N; i++) {
 8022292:	9a05      	ldr	r2, [sp, #20]
 8022294:	9909      	ldr	r1, [sp, #36]	; 0x24
 8022296:	9b07      	ldr	r3, [sp, #28]
 8022298:	440a      	add	r2, r1
 802229a:	9205      	str	r2, [sp, #20]
 802229c:	9908      	ldr	r1, [sp, #32]
 802229e:	9a02      	ldr	r2, [sp, #8]
 80222a0:	440a      	add	r2, r1
 80222a2:	9202      	str	r2, [sp, #8]
 80222a4:	9a03      	ldr	r2, [sp, #12]
 80222a6:	3301      	adds	r3, #1
 80222a8:	429a      	cmp	r2, r3
 80222aa:	9307      	str	r3, [sp, #28]
 80222ac:	d1b4      	bne.n	8022218 <cblas_zsyrk+0x208>
 80222ae:	e770      	b.n	8022192 <cblas_zsyrk+0x182>
        && (beta_real == 1.0 && beta_imag == 0.0))
 80222b0:	ec51 0b19 	vmov	r0, r1, d9
 80222b4:	2200      	movs	r2, #0
 80222b6:	2300      	movs	r3, #0
 80222b8:	f006 f85e 	bl	8028378 <__aeabi_dcmpeq>
 80222bc:	2800      	cmp	r0, #0
 80222be:	f43f af29 	beq.w	8022114 <cblas_zsyrk+0x104>
 80222c2:	b013      	add	sp, #76	; 0x4c
 80222c4:	ecbd 8b0e 	vpop	{d8-d14}
 80222c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 80222cc:	9906      	ldr	r1, [sp, #24]
 80222ce:	428b      	cmp	r3, r1
 80222d0:	f73f aee4 	bgt.w	802209c <cblas_zsyrk+0x8c>
 80222d4:	2a01      	cmp	r2, #1
 80222d6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80222d8:	bfb8      	it	lt
 80222da:	2201      	movlt	r2, #1
 80222dc:	4293      	cmp	r3, r2
 80222de:	bfb4      	ite	lt
 80222e0:	200b      	movlt	r0, #11
 80222e2:	2005      	movge	r0, #5
 80222e4:	e6e3      	b.n	80220ae <cblas_zsyrk+0x9e>
 80222e6:	f1a6 0065 	sub.w	r0, r6, #101	; 0x65
 80222ea:	2801      	cmp	r0, #1
 80222ec:	bf94      	ite	ls
 80222ee:	2000      	movls	r0, #0
 80222f0:	2001      	movhi	r0, #1
 80222f2:	e6ae      	b.n	8022052 <cblas_zsyrk+0x42>
 80222f4:	2a6f      	cmp	r2, #111	; 0x6f
 80222f6:	f000 8437 	beq.w	8022b68 <cblas_zsyrk+0xb58>
 80222fa:	9b03      	ldr	r3, [sp, #12]
 80222fc:	e6a3      	b.n	8022046 <cblas_zsyrk+0x36>
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 80222fe:	2d6f      	cmp	r5, #111	; 0x6f
 8022300:	bf0c      	ite	eq
 8022302:	236f      	moveq	r3, #111	; 0x6f
 8022304:	2370      	movne	r3, #112	; 0x70
      uplo = Uplo;
 8022306:	940a      	str	r4, [sp, #40]	; 0x28
      trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8022308:	930d      	str	r3, [sp, #52]	; 0x34
 802230a:	e710      	b.n	802212e <cblas_zsyrk+0x11e>
 802230c:	08030378 	.word	0x08030378
 8022310:	08030774 	.word	0x08030774
 8022314:	3ff00000 	.word	0x3ff00000
 8022318:	080305a8 	.word	0x080305a8
        for (i = 0; i < N; i++) {
 802231c:	9d03      	ldr	r5, [sp, #12]
 802231e:	2d00      	cmp	r5, #0
 8022320:	dd15      	ble.n	802234e <cblas_zsyrk+0x33e>
 8022322:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022324:	980c      	ldr	r0, [sp, #48]	; 0x30
 8022326:	1c5c      	adds	r4, r3, #1
            REAL(C, ldc * i + j) = 0.0;
 8022328:	2600      	movs	r6, #0
 802232a:	2700      	movs	r7, #0
 802232c:	0124      	lsls	r4, r4, #4
        for (i = 0; i < N; i++) {
 802232e:	2100      	movs	r1, #0
 8022330:	4603      	mov	r3, r0
 8022332:	460a      	mov	r2, r1
          for (j = i; j < N; j++) {
 8022334:	3201      	adds	r2, #1
 8022336:	4295      	cmp	r5, r2
            REAL(C, ldc * i + j) = 0.0;
 8022338:	e9c3 6700 	strd	r6, r7, [r3]
            IMAG(C, ldc * i + j) = 0.0;
 802233c:	e9c3 6702 	strd	r6, r7, [r3, #8]
          for (j = i; j < N; j++) {
 8022340:	f103 0310 	add.w	r3, r3, #16
 8022344:	dcf6      	bgt.n	8022334 <cblas_zsyrk+0x324>
        for (i = 0; i < N; i++) {
 8022346:	3101      	adds	r1, #1
 8022348:	428d      	cmp	r5, r1
 802234a:	4420      	add	r0, r4
 802234c:	d1f0      	bne.n	8022330 <cblas_zsyrk+0x320>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 802234e:	ec51 0b1d 	vmov	r0, r1, d13
 8022352:	2200      	movs	r2, #0
 8022354:	2300      	movs	r3, #0
 8022356:	f006 f80f 	bl	8028378 <__aeabi_dcmpeq>
 802235a:	2800      	cmp	r0, #0
 802235c:	f47f af20 	bne.w	80221a0 <cblas_zsyrk+0x190>
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8022360:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8022362:	2b6f      	cmp	r3, #111	; 0x6f
      for (i = 0; i < N; i++) {
 8022364:	9b03      	ldr	r3, [sp, #12]
    if (uplo == CblasUpper && trans == CblasNoTrans) {
 8022366:	f000 81d6 	beq.w	8022716 <cblas_zsyrk+0x706>
      for (i = 0; i < N; i++) {
 802236a:	2b00      	cmp	r3, #0
 802236c:	dda9      	ble.n	80222c2 <cblas_zsyrk+0x2b2>
 802236e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022370:	3301      	adds	r3, #1
 8022372:	011b      	lsls	r3, r3, #4
 8022374:	930a      	str	r3, [sp, #40]	; 0x28
 8022376:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022378:	9309      	str	r3, [sp, #36]	; 0x24
 802237a:	9b06      	ldr	r3, [sp, #24]
 802237c:	011b      	lsls	r3, r3, #4
 802237e:	9307      	str	r3, [sp, #28]
 8022380:	9b04      	ldr	r3, [sp, #16]
 8022382:	3308      	adds	r3, #8
 8022384:	9306      	str	r3, [sp, #24]
 8022386:	2300      	movs	r3, #0
 8022388:	9308      	str	r3, [sp, #32]
          BASE temp_real = 0.0;
 802238a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802238c:	9305      	str	r3, [sp, #20]
 802238e:	9b08      	ldr	r3, [sp, #32]
 8022390:	9302      	str	r3, [sp, #8]
          BASE temp_imag = 0.0;
 8022392:	ed9f 7b63 	vldr	d7, [pc, #396]	; 8022520 <cblas_zsyrk+0x510>
          for (k = 0; k < K; k++) {
 8022396:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 8022398:	eeb0 ca47 	vmov.f32	s24, s14
 802239c:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < K; k++) {
 80223a0:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 80223a2:	eeb0 ba47 	vmov.f32	s22, s14
 80223a6:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 80223aa:	dd5c      	ble.n	8022466 <cblas_zsyrk+0x456>
 80223ac:	9b04      	ldr	r3, [sp, #16]
 80223ae:	9a02      	ldr	r2, [sp, #8]
 80223b0:	f8dd b018 	ldr.w	fp, [sp, #24]
 80223b4:	9d07      	ldr	r5, [sp, #28]
 80223b6:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 80223ba:	2300      	movs	r3, #0
 80223bc:	461c      	mov	r4, r3
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 80223be:	ed1b 7b02 	vldr	d7, [fp, #-8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80223c2:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 80223c6:	eeb0 aa47 	vmov.f32	s20, s14
 80223ca:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80223ce:	ed9a 5b02 	vldr	d5, [sl, #8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80223d2:	eeb0 9a46 	vmov.f32	s18, s12
 80223d6:	eef0 9a66 	vmov.f32	s19, s13
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80223da:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80223de:	eeb0 8a45 	vmov.f32	s16, s10
 80223e2:	eef0 8a65 	vmov.f32	s17, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80223e6:	ec51 0b17 	vmov	r0, r1, d7
 80223ea:	f005 fd5d 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 80223ee:	e9db 8900 	ldrd	r8, r9, [fp]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80223f2:	ec53 2b18 	vmov	r2, r3, d8
 80223f6:	4606      	mov	r6, r0
 80223f8:	460f      	mov	r7, r1
 80223fa:	4640      	mov	r0, r8
 80223fc:	4649      	mov	r1, r9
 80223fe:	f005 fd53 	bl	8027ea8 <__aeabi_dmul>
 8022402:	4602      	mov	r2, r0
 8022404:	460b      	mov	r3, r1
 8022406:	4630      	mov	r0, r6
 8022408:	4639      	mov	r1, r7
 802240a:	f005 fb95 	bl	8027b38 <__aeabi_dsub>
 802240e:	4602      	mov	r2, r0
 8022410:	460b      	mov	r3, r1
 8022412:	ec51 0b1b 	vmov	r0, r1, d11
 8022416:	f005 fb91 	bl	8027b3c <__adddf3>
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 802241a:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 802241e:	4606      	mov	r6, r0
 8022420:	460f      	mov	r7, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8022422:	ec51 0b1a 	vmov	r0, r1, d10
 8022426:	f005 fd3f 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 802242a:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 802242e:	ec53 2b19 	vmov	r2, r3, d9
 8022432:	4606      	mov	r6, r0
 8022434:	460f      	mov	r7, r1
 8022436:	4640      	mov	r0, r8
 8022438:	4649      	mov	r1, r9
 802243a:	f005 fd35 	bl	8027ea8 <__aeabi_dmul>
 802243e:	4602      	mov	r2, r0
 8022440:	460b      	mov	r3, r1
 8022442:	4630      	mov	r0, r6
 8022444:	4639      	mov	r1, r7
 8022446:	f005 fb79 	bl	8027b3c <__adddf3>
 802244a:	460b      	mov	r3, r1
 802244c:	4602      	mov	r2, r0
 802244e:	ec51 0b1c 	vmov	r0, r1, d12
 8022452:	f005 fb73 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 8022456:	9b01      	ldr	r3, [sp, #4]
 8022458:	3401      	adds	r4, #1
 802245a:	42a3      	cmp	r3, r4
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 802245c:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < K; k++) {
 8022460:	44ab      	add	fp, r5
 8022462:	44aa      	add	sl, r5
 8022464:	d1ab      	bne.n	80223be <cblas_zsyrk+0x3ae>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022466:	ec53 2b1b 	vmov	r2, r3, d11
 802246a:	ec51 0b1d 	vmov	r0, r1, d13
 802246e:	f005 fd1b 	bl	8027ea8 <__aeabi_dmul>
 8022472:	ec5a 9b1c 	vmov	r9, sl, d12
 8022476:	ec58 7b1e 	vmov	r7, r8, d14
 802247a:	4604      	mov	r4, r0
 802247c:	460d      	mov	r5, r1
 802247e:	ee1c 2a10 	vmov	r2, s24
 8022482:	4653      	mov	r3, sl
 8022484:	ee1e 0a10 	vmov	r0, s28
 8022488:	4641      	mov	r1, r8
 802248a:	f005 fd0d 	bl	8027ea8 <__aeabi_dmul>
 802248e:	4602      	mov	r2, r0
 8022490:	460b      	mov	r3, r1
 8022492:	4620      	mov	r0, r4
 8022494:	4629      	mov	r1, r5
 8022496:	f005 fb4f 	bl	8027b38 <__aeabi_dsub>
 802249a:	9e05      	ldr	r6, [sp, #20]
 802249c:	4602      	mov	r2, r0
 802249e:	460b      	mov	r3, r1
 80224a0:	e9d6 0100 	ldrd	r0, r1, [r6]
 80224a4:	f005 fb4a 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80224a8:	ee1c 2a10 	vmov	r2, s24
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80224ac:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80224b0:	4653      	mov	r3, sl
 80224b2:	ec51 0b1d 	vmov	r0, r1, d13
 80224b6:	f005 fcf7 	bl	8027ea8 <__aeabi_dmul>
 80224ba:	ec53 2b1b 	vmov	r2, r3, d11
 80224be:	4604      	mov	r4, r0
 80224c0:	460d      	mov	r5, r1
 80224c2:	ee1e 0a10 	vmov	r0, s28
 80224c6:	4641      	mov	r1, r8
 80224c8:	f005 fcee 	bl	8027ea8 <__aeabi_dmul>
 80224cc:	4602      	mov	r2, r0
 80224ce:	460b      	mov	r3, r1
 80224d0:	4620      	mov	r0, r4
 80224d2:	4629      	mov	r1, r5
 80224d4:	f005 fb32 	bl	8027b3c <__adddf3>
 80224d8:	4602      	mov	r2, r0
 80224da:	460b      	mov	r3, r1
 80224dc:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 80224e0:	f005 fb2c 	bl	8027b3c <__adddf3>
        for (j = i; j < N; j++) {
 80224e4:	9a02      	ldr	r2, [sp, #8]
 80224e6:	f106 0310 	add.w	r3, r6, #16
 80224ea:	9305      	str	r3, [sp, #20]
 80224ec:	9b03      	ldr	r3, [sp, #12]
 80224ee:	3201      	adds	r2, #1
 80224f0:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80224f2:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = i; j < N; j++) {
 80224f6:	9202      	str	r2, [sp, #8]
 80224f8:	f73f af4b 	bgt.w	8022392 <cblas_zsyrk+0x382>
      for (i = 0; i < N; i++) {
 80224fc:	e9dd 2109 	ldrd	r2, r1, [sp, #36]	; 0x24
 8022500:	440a      	add	r2, r1
 8022502:	9209      	str	r2, [sp, #36]	; 0x24
 8022504:	9a06      	ldr	r2, [sp, #24]
 8022506:	9b08      	ldr	r3, [sp, #32]
 8022508:	3210      	adds	r2, #16
 802250a:	9206      	str	r2, [sp, #24]
 802250c:	9a03      	ldr	r2, [sp, #12]
 802250e:	3301      	adds	r3, #1
 8022510:	429a      	cmp	r2, r3
 8022512:	9308      	str	r3, [sp, #32]
 8022514:	f47f af39 	bne.w	802238a <cblas_zsyrk+0x37a>
 8022518:	e6d3      	b.n	80222c2 <cblas_zsyrk+0x2b2>
 802251a:	bf00      	nop
 802251c:	f3af 8000 	nop.w
	...
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 8022528:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802252a:	2b6f      	cmp	r3, #111	; 0x6f
      for (i = 0; i < N; i++) {
 802252c:	9b03      	ldr	r3, [sp, #12]
    } else if (uplo == CblasLower && trans == CblasNoTrans) {
 802252e:	f000 81d6 	beq.w	80228de <cblas_zsyrk+0x8ce>
      for (i = 0; i < N; i++) {
 8022532:	2b00      	cmp	r3, #0
 8022534:	f77f aec5 	ble.w	80222c2 <cblas_zsyrk+0x2b2>
 8022538:	9b06      	ldr	r3, [sp, #24]
 802253a:	011b      	lsls	r3, r3, #4
 802253c:	9309      	str	r3, [sp, #36]	; 0x24
 802253e:	9b04      	ldr	r3, [sp, #16]
 8022540:	3308      	adds	r3, #8
 8022542:	9308      	str	r3, [sp, #32]
 8022544:	2300      	movs	r3, #0
 8022546:	930a      	str	r3, [sp, #40]	; 0x28
 8022548:	2301      	movs	r3, #1
 802254a:	9307      	str	r3, [sp, #28]
 802254c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802254e:	3308      	adds	r3, #8
 8022550:	930e      	str	r3, [sp, #56]	; 0x38
 8022552:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022554:	4619      	mov	r1, r3
 8022556:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022558:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 802255c:	9206      	str	r2, [sp, #24]
 802255e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8022560:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8022564:	9305      	str	r3, [sp, #20]
        for (j = 0; j <= i; j++) {
 8022566:	2300      	movs	r3, #0
 8022568:	9302      	str	r3, [sp, #8]
          BASE temp_imag = 0.0;
 802256a:	ed1f 7b13 	vldr	d7, [pc, #-76]	; 8022520 <cblas_zsyrk+0x510>
          for (k = 0; k < K; k++) {
 802256e:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 8022570:	eeb0 ca47 	vmov.f32	s24, s14
 8022574:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < K; k++) {
 8022578:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 802257a:	eeb0 ba47 	vmov.f32	s22, s14
 802257e:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 8022582:	dd5c      	ble.n	802263e <cblas_zsyrk+0x62e>
 8022584:	9b04      	ldr	r3, [sp, #16]
 8022586:	9a02      	ldr	r2, [sp, #8]
 8022588:	f8dd b020 	ldr.w	fp, [sp, #32]
 802258c:	9d09      	ldr	r5, [sp, #36]	; 0x24
 802258e:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
 8022592:	2300      	movs	r3, #0
 8022594:	461c      	mov	r4, r3
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8022596:	ed1b 7b02 	vldr	d7, [fp, #-8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802259a:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 802259e:	eeb0 aa47 	vmov.f32	s20, s14
 80225a2:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80225a6:	ed9a 5b02 	vldr	d5, [sl, #8]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 80225aa:	eeb0 9a46 	vmov.f32	s18, s12
 80225ae:	eef0 9a66 	vmov.f32	s19, s13
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80225b2:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
 80225b6:	eeb0 8a45 	vmov.f32	s16, s10
 80225ba:	eef0 8a65 	vmov.f32	s17, s11
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80225be:	ec51 0b17 	vmov	r0, r1, d7
 80225c2:	f005 fc71 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
 80225c6:	e9db 8900 	ldrd	r8, r9, [fp]
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80225ca:	ec53 2b18 	vmov	r2, r3, d8
 80225ce:	4606      	mov	r6, r0
 80225d0:	460f      	mov	r7, r1
 80225d2:	4640      	mov	r0, r8
 80225d4:	4649      	mov	r1, r9
 80225d6:	f005 fc67 	bl	8027ea8 <__aeabi_dmul>
 80225da:	4602      	mov	r2, r0
 80225dc:	460b      	mov	r3, r1
 80225de:	4630      	mov	r0, r6
 80225e0:	4639      	mov	r1, r7
 80225e2:	f005 faa9 	bl	8027b38 <__aeabi_dsub>
 80225e6:	4602      	mov	r2, r0
 80225e8:	460b      	mov	r3, r1
 80225ea:	ec51 0b1b 	vmov	r0, r1, d11
 80225ee:	f005 faa5 	bl	8027b3c <__adddf3>
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80225f2:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 80225f6:	4606      	mov	r6, r0
 80225f8:	460f      	mov	r7, r1
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 80225fa:	ec51 0b1a 	vmov	r0, r1, d10
 80225fe:	f005 fc53 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
 8022602:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8022606:	ec53 2b19 	vmov	r2, r3, d9
 802260a:	4606      	mov	r6, r0
 802260c:	460f      	mov	r7, r1
 802260e:	4640      	mov	r0, r8
 8022610:	4649      	mov	r1, r9
 8022612:	f005 fc49 	bl	8027ea8 <__aeabi_dmul>
 8022616:	4602      	mov	r2, r0
 8022618:	460b      	mov	r3, r1
 802261a:	4630      	mov	r0, r6
 802261c:	4639      	mov	r1, r7
 802261e:	f005 fa8d 	bl	8027b3c <__adddf3>
 8022622:	460b      	mov	r3, r1
 8022624:	4602      	mov	r2, r0
 8022626:	ec51 0b1c 	vmov	r0, r1, d12
 802262a:	f005 fa87 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 802262e:	9b01      	ldr	r3, [sp, #4]
 8022630:	3401      	adds	r4, #1
 8022632:	42a3      	cmp	r3, r4
            temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
 8022634:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < K; k++) {
 8022638:	44ab      	add	fp, r5
 802263a:	44aa      	add	sl, r5
 802263c:	d1ab      	bne.n	8022596 <cblas_zsyrk+0x586>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 802263e:	ec53 2b1b 	vmov	r2, r3, d11
 8022642:	ec51 0b1d 	vmov	r0, r1, d13
 8022646:	f005 fc2f 	bl	8027ea8 <__aeabi_dmul>
 802264a:	ec5a 9b1c 	vmov	r9, sl, d12
 802264e:	ec58 7b1e 	vmov	r7, r8, d14
 8022652:	4604      	mov	r4, r0
 8022654:	460d      	mov	r5, r1
 8022656:	ee1c 2a10 	vmov	r2, s24
 802265a:	4653      	mov	r3, sl
 802265c:	ee1e 0a10 	vmov	r0, s28
 8022660:	4641      	mov	r1, r8
 8022662:	f005 fc21 	bl	8027ea8 <__aeabi_dmul>
 8022666:	4602      	mov	r2, r0
 8022668:	460b      	mov	r3, r1
 802266a:	4620      	mov	r0, r4
 802266c:	4629      	mov	r1, r5
 802266e:	f005 fa63 	bl	8027b38 <__aeabi_dsub>
 8022672:	9e05      	ldr	r6, [sp, #20]
 8022674:	4602      	mov	r2, r0
 8022676:	460b      	mov	r3, r1
 8022678:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 802267c:	f005 fa5e 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022680:	ee1c 2a10 	vmov	r2, s24
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022684:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022688:	4653      	mov	r3, sl
 802268a:	ec51 0b1d 	vmov	r0, r1, d13
 802268e:	f005 fc0b 	bl	8027ea8 <__aeabi_dmul>
 8022692:	ec53 2b1b 	vmov	r2, r3, d11
 8022696:	4604      	mov	r4, r0
 8022698:	460d      	mov	r5, r1
 802269a:	ee1e 0a10 	vmov	r0, s28
 802269e:	4641      	mov	r1, r8
 80226a0:	f005 fc02 	bl	8027ea8 <__aeabi_dmul>
 80226a4:	4602      	mov	r2, r0
 80226a6:	460b      	mov	r3, r1
 80226a8:	4620      	mov	r0, r4
 80226aa:	4629      	mov	r1, r5
 80226ac:	f005 fa46 	bl	8027b3c <__adddf3>
 80226b0:	9c06      	ldr	r4, [sp, #24]
 80226b2:	4602      	mov	r2, r0
 80226b4:	460b      	mov	r3, r1
 80226b6:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 80226ba:	f005 fa3f 	bl	8027b3c <__adddf3>
 80226be:	f106 0310 	add.w	r3, r6, #16
        for (j = 0; j <= i; j++) {
 80226c2:	9a02      	ldr	r2, [sp, #8]
 80226c4:	9305      	str	r3, [sp, #20]
 80226c6:	f104 0310 	add.w	r3, r4, #16
 80226ca:	9306      	str	r3, [sp, #24]
 80226cc:	9b07      	ldr	r3, [sp, #28]
 80226ce:	3201      	adds	r2, #1
 80226d0:	429a      	cmp	r2, r3
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80226d2:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = 0; j <= i; j++) {
 80226d6:	9202      	str	r2, [sp, #8]
 80226d8:	f47f af47 	bne.w	802256a <cblas_zsyrk+0x55a>
      for (i = 0; i < N; i++) {
 80226dc:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
 80226e0:	4413      	add	r3, r2
 80226e2:	9903      	ldr	r1, [sp, #12]
 80226e4:	9a07      	ldr	r2, [sp, #28]
 80226e6:	930a      	str	r3, [sp, #40]	; 0x28
 80226e8:	9b08      	ldr	r3, [sp, #32]
 80226ea:	4291      	cmp	r1, r2
 80226ec:	f103 0310 	add.w	r3, r3, #16
 80226f0:	9308      	str	r3, [sp, #32]
 80226f2:	f102 0301 	add.w	r3, r2, #1
 80226f6:	f43f ade4 	beq.w	80222c2 <cblas_zsyrk+0x2b2>
 80226fa:	9307      	str	r3, [sp, #28]
 80226fc:	e729      	b.n	8022552 <cblas_zsyrk+0x542>
    if (alpha_real == 0.0 && alpha_imag == 0.0)
 80226fe:	ec51 0b1d 	vmov	r0, r1, d13
 8022702:	2200      	movs	r2, #0
 8022704:	2300      	movs	r3, #0
 8022706:	f005 fe37 	bl	8028378 <__aeabi_dcmpeq>
 802270a:	2800      	cmp	r0, #0
 802270c:	f43f ad51 	beq.w	80221b2 <cblas_zsyrk+0x1a2>
 8022710:	e546      	b.n	80221a0 <cblas_zsyrk+0x190>
  CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
 8022712:	200b      	movs	r0, #11
 8022714:	e4cb      	b.n	80220ae <cblas_zsyrk+0x9e>
      for (i = 0; i < N; i++) {
 8022716:	2b00      	cmp	r3, #0
 8022718:	f77f add3 	ble.w	80222c2 <cblas_zsyrk+0x2b2>
 802271c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802271e:	9901      	ldr	r1, [sp, #4]
 8022720:	3301      	adds	r3, #1
 8022722:	011b      	lsls	r3, r3, #4
 8022724:	930e      	str	r3, [sp, #56]	; 0x38
 8022726:	9b06      	ldr	r3, [sp, #24]
 8022728:	011b      	lsls	r3, r3, #4
 802272a:	930d      	str	r3, [sp, #52]	; 0x34
 802272c:	9b04      	ldr	r3, [sp, #16]
 802272e:	9309      	str	r3, [sp, #36]	; 0x24
 8022730:	2200      	movs	r2, #0
 8022732:	920b      	str	r2, [sp, #44]	; 0x2c
 8022734:	920a      	str	r2, [sp, #40]	; 0x28
 8022736:	eb03 1201 	add.w	r2, r3, r1, lsl #4
 802273a:	9202      	str	r2, [sp, #8]
          BASE temp_real = 0.0;
 802273c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802273e:	9305      	str	r3, [sp, #20]
 8022740:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022742:	9308      	str	r3, [sp, #32]
 8022744:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022746:	9307      	str	r3, [sp, #28]
          BASE temp_imag = 0.0;
 8022748:	ed1f 7b8b 	vldr	d7, [pc, #-556]	; 8022520 <cblas_zsyrk+0x510>
          for (k = 0; k < K; k++) {
 802274c:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 802274e:	eeb0 aa47 	vmov.f32	s20, s14
 8022752:	eef0 aa67 	vmov.f32	s21, s15
          for (k = 0; k < K; k++) {
 8022756:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 8022758:	eeb0 ba47 	vmov.f32	s22, s14
 802275c:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 8022760:	dd56      	ble.n	8022810 <cblas_zsyrk+0x800>
 8022762:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 8022766:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
 802276a:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802276e:	ed9b 7b00 	vldr	d7, [fp]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022772:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8022776:	eeb0 9a47 	vmov.f32	s18, s14
 802277a:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802277e:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022782:	eeb0 8a46 	vmov.f32	s16, s12
 8022786:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802278a:	ec51 0b17 	vmov	r0, r1, d7
 802278e:	f005 fb8b 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8022792:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8022796:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802279a:	4604      	mov	r4, r0
 802279c:	460d      	mov	r5, r1
 802279e:	4642      	mov	r2, r8
 80227a0:	464b      	mov	r3, r9
 80227a2:	4630      	mov	r0, r6
 80227a4:	4639      	mov	r1, r7
 80227a6:	f005 fb7f 	bl	8027ea8 <__aeabi_dmul>
 80227aa:	4602      	mov	r2, r0
 80227ac:	460b      	mov	r3, r1
 80227ae:	4620      	mov	r0, r4
 80227b0:	4629      	mov	r1, r5
 80227b2:	f005 f9c1 	bl	8027b38 <__aeabi_dsub>
 80227b6:	4602      	mov	r2, r0
 80227b8:	460b      	mov	r3, r1
 80227ba:	ec51 0b1b 	vmov	r0, r1, d11
 80227be:	f005 f9bd 	bl	8027b3c <__adddf3>
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80227c2:	4642      	mov	r2, r8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80227c4:	4604      	mov	r4, r0
 80227c6:	460d      	mov	r5, r1
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80227c8:	464b      	mov	r3, r9
 80227ca:	ec51 0b19 	vmov	r0, r1, d9
 80227ce:	f005 fb6b 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80227d2:	ec45 4b1b 	vmov	d11, r4, r5
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80227d6:	ec53 2b18 	vmov	r2, r3, d8
 80227da:	4604      	mov	r4, r0
 80227dc:	460d      	mov	r5, r1
 80227de:	4630      	mov	r0, r6
 80227e0:	4639      	mov	r1, r7
 80227e2:	f005 fb61 	bl	8027ea8 <__aeabi_dmul>
 80227e6:	4602      	mov	r2, r0
 80227e8:	460b      	mov	r3, r1
 80227ea:	4620      	mov	r0, r4
 80227ec:	4629      	mov	r1, r5
 80227ee:	f005 f9a5 	bl	8027b3c <__adddf3>
 80227f2:	460b      	mov	r3, r1
 80227f4:	4602      	mov	r2, r0
 80227f6:	ec51 0b1a 	vmov	r0, r1, d10
 80227fa:	f005 f99f 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 80227fe:	9b02      	ldr	r3, [sp, #8]
 8022800:	f10b 0b10 	add.w	fp, fp, #16
 8022804:	455b      	cmp	r3, fp
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 8022806:	ec41 0b1a 	vmov	d10, r0, r1
          for (k = 0; k < K; k++) {
 802280a:	f10a 0a10 	add.w	sl, sl, #16
 802280e:	d1ae      	bne.n	802276e <cblas_zsyrk+0x75e>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022810:	ec53 2b1d 	vmov	r2, r3, d13
 8022814:	ec51 0b1b 	vmov	r0, r1, d11
 8022818:	f005 fb46 	bl	8027ea8 <__aeabi_dmul>
 802281c:	ec5a 9b1a 	vmov	r9, sl, d10
 8022820:	ec58 7b1e 	vmov	r7, r8, d14
 8022824:	4604      	mov	r4, r0
 8022826:	460d      	mov	r5, r1
 8022828:	ee1a 2a10 	vmov	r2, s20
 802282c:	4653      	mov	r3, sl
 802282e:	ee1e 0a10 	vmov	r0, s28
 8022832:	4641      	mov	r1, r8
 8022834:	f005 fb38 	bl	8027ea8 <__aeabi_dmul>
 8022838:	4602      	mov	r2, r0
 802283a:	460b      	mov	r3, r1
 802283c:	4620      	mov	r0, r4
 802283e:	4629      	mov	r1, r5
 8022840:	f005 f97a 	bl	8027b38 <__aeabi_dsub>
 8022844:	9e08      	ldr	r6, [sp, #32]
 8022846:	4602      	mov	r2, r0
 8022848:	460b      	mov	r3, r1
 802284a:	e9d6 0100 	ldrd	r0, r1, [r6]
 802284e:	f005 f975 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022852:	ee1a 2a10 	vmov	r2, s20
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022856:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 802285a:	4653      	mov	r3, sl
 802285c:	ec51 0b1d 	vmov	r0, r1, d13
 8022860:	f005 fb22 	bl	8027ea8 <__aeabi_dmul>
 8022864:	ee1e 2a10 	vmov	r2, s28
 8022868:	460d      	mov	r5, r1
 802286a:	4643      	mov	r3, r8
 802286c:	4604      	mov	r4, r0
 802286e:	ec51 0b1b 	vmov	r0, r1, d11
 8022872:	f005 fb19 	bl	8027ea8 <__aeabi_dmul>
 8022876:	4602      	mov	r2, r0
 8022878:	460b      	mov	r3, r1
 802287a:	4620      	mov	r0, r4
 802287c:	4629      	mov	r1, r5
 802287e:	f005 f95d 	bl	8027b3c <__adddf3>
 8022882:	4602      	mov	r2, r0
 8022884:	460b      	mov	r3, r1
 8022886:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 802288a:	f005 f957 	bl	8027b3c <__adddf3>
 802288e:	e9dd 3505 	ldrd	r3, r5, [sp, #20]
 8022892:	442b      	add	r3, r5
        for (j = i; j < N; j++) {
 8022894:	9a07      	ldr	r2, [sp, #28]
 8022896:	9305      	str	r3, [sp, #20]
 8022898:	f106 0310 	add.w	r3, r6, #16
 802289c:	9308      	str	r3, [sp, #32]
 802289e:	9b03      	ldr	r3, [sp, #12]
 80228a0:	3201      	adds	r2, #1
 80228a2:	4293      	cmp	r3, r2
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 80228a4:	e9c6 0102 	strd	r0, r1, [r6, #8]
        for (j = i; j < N; j++) {
 80228a8:	9207      	str	r2, [sp, #28]
 80228aa:	f73f af4d 	bgt.w	8022748 <cblas_zsyrk+0x738>
      for (i = 0; i < N; i++) {
 80228ae:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80228b0:	990e      	ldr	r1, [sp, #56]	; 0x38
 80228b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80228b4:	440a      	add	r2, r1
 80228b6:	920c      	str	r2, [sp, #48]	; 0x30
 80228b8:	9906      	ldr	r1, [sp, #24]
 80228ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80228bc:	440a      	add	r2, r1
 80228be:	9909      	ldr	r1, [sp, #36]	; 0x24
 80228c0:	920b      	str	r2, [sp, #44]	; 0x2c
 80228c2:	4608      	mov	r0, r1
 80228c4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80228c6:	9902      	ldr	r1, [sp, #8]
 80228c8:	4410      	add	r0, r2
 80228ca:	4411      	add	r1, r2
 80228cc:	9a03      	ldr	r2, [sp, #12]
 80228ce:	9009      	str	r0, [sp, #36]	; 0x24
 80228d0:	3301      	adds	r3, #1
 80228d2:	429a      	cmp	r2, r3
 80228d4:	930a      	str	r3, [sp, #40]	; 0x28
 80228d6:	9102      	str	r1, [sp, #8]
 80228d8:	f47f af30 	bne.w	802273c <cblas_zsyrk+0x72c>
 80228dc:	e4f1      	b.n	80222c2 <cblas_zsyrk+0x2b2>
      for (i = 0; i < N; i++) {
 80228de:	2b00      	cmp	r3, #0
 80228e0:	f77f acef 	ble.w	80222c2 <cblas_zsyrk+0x2b2>
 80228e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80228e6:	9801      	ldr	r0, [sp, #4]
 80228e8:	3301      	adds	r3, #1
 80228ea:	011b      	lsls	r3, r3, #4
 80228ec:	9311      	str	r3, [sp, #68]	; 0x44
 80228ee:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80228f0:	2200      	movs	r2, #0
 80228f2:	920d      	str	r2, [sp, #52]	; 0x34
 80228f4:	920f      	str	r2, [sp, #60]	; 0x3c
 80228f6:	f103 0210 	add.w	r2, r3, #16
 80228fa:	9209      	str	r2, [sp, #36]	; 0x24
 80228fc:	9a06      	ldr	r2, [sp, #24]
 80228fe:	0112      	lsls	r2, r2, #4
 8022900:	9210      	str	r2, [sp, #64]	; 0x40
 8022902:	9a04      	ldr	r2, [sp, #16]
 8022904:	920a      	str	r2, [sp, #40]	; 0x28
 8022906:	eb02 1100 	add.w	r1, r2, r0, lsl #4
 802290a:	3308      	adds	r3, #8
 802290c:	9102      	str	r1, [sp, #8]
 802290e:	930e      	str	r3, [sp, #56]	; 0x38
 8022910:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022912:	4619      	mov	r1, r3
 8022914:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8022916:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 802291a:	9208      	str	r2, [sp, #32]
 802291c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802291e:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8022922:	9307      	str	r3, [sp, #28]
          BASE temp_real = 0.0;
 8022924:	2300      	movs	r3, #0
 8022926:	9305      	str	r3, [sp, #20]
          BASE temp_imag = 0.0;
 8022928:	ed9f 7b91 	vldr	d7, [pc, #580]	; 8022b70 <cblas_zsyrk+0xb60>
          for (k = 0; k < K; k++) {
 802292c:	9b01      	ldr	r3, [sp, #4]
          BASE temp_imag = 0.0;
 802292e:	eeb0 ba47 	vmov.f32	s22, s14
 8022932:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < K; k++) {
 8022936:	2b00      	cmp	r3, #0
          BASE temp_real = 0.0;
 8022938:	eeb0 aa47 	vmov.f32	s20, s14
 802293c:	eef0 aa67 	vmov.f32	s21, s15
          for (k = 0; k < K; k++) {
 8022940:	dd56      	ble.n	80229f0 <cblas_zsyrk+0x9e0>
 8022942:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
 8022946:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 802294a:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802294e:	ed9b 7b00 	vldr	d7, [fp]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022952:	ed9a 6b00 	vldr	d6, [sl]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8022956:	eeb0 9a47 	vmov.f32	s18, s14
 802295a:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802295e:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022962:	eeb0 8a46 	vmov.f32	s16, s12
 8022966:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802296a:	ec51 0b17 	vmov	r0, r1, d7
 802296e:	f005 fa9b 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
 8022972:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
 8022976:	e9da 8902 	ldrd	r8, r9, [sl, #8]
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 802297a:	4604      	mov	r4, r0
 802297c:	460d      	mov	r5, r1
 802297e:	4642      	mov	r2, r8
 8022980:	464b      	mov	r3, r9
 8022982:	4630      	mov	r0, r6
 8022984:	4639      	mov	r1, r7
 8022986:	f005 fa8f 	bl	8027ea8 <__aeabi_dmul>
 802298a:	4602      	mov	r2, r0
 802298c:	460b      	mov	r3, r1
 802298e:	4620      	mov	r0, r4
 8022990:	4629      	mov	r1, r5
 8022992:	f005 f8d1 	bl	8027b38 <__aeabi_dsub>
 8022996:	4602      	mov	r2, r0
 8022998:	460b      	mov	r3, r1
 802299a:	ec51 0b1a 	vmov	r0, r1, d10
 802299e:	f005 f8cd 	bl	8027b3c <__adddf3>
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80229a2:	4642      	mov	r2, r8
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80229a4:	4604      	mov	r4, r0
 80229a6:	460d      	mov	r5, r1
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80229a8:	464b      	mov	r3, r9
 80229aa:	ec51 0b19 	vmov	r0, r1, d9
 80229ae:	f005 fa7b 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
 80229b2:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80229b6:	ec53 2b18 	vmov	r2, r3, d8
 80229ba:	4604      	mov	r4, r0
 80229bc:	460d      	mov	r5, r1
 80229be:	4630      	mov	r0, r6
 80229c0:	4639      	mov	r1, r7
 80229c2:	f005 fa71 	bl	8027ea8 <__aeabi_dmul>
 80229c6:	4602      	mov	r2, r0
 80229c8:	460b      	mov	r3, r1
 80229ca:	4620      	mov	r0, r4
 80229cc:	4629      	mov	r1, r5
 80229ce:	f005 f8b5 	bl	8027b3c <__adddf3>
 80229d2:	460b      	mov	r3, r1
 80229d4:	4602      	mov	r2, r0
 80229d6:	ec51 0b1b 	vmov	r0, r1, d11
 80229da:	f005 f8af 	bl	8027b3c <__adddf3>
          for (k = 0; k < K; k++) {
 80229de:	9b02      	ldr	r3, [sp, #8]
 80229e0:	f10b 0b10 	add.w	fp, fp, #16
 80229e4:	455b      	cmp	r3, fp
            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
 80229e6:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < K; k++) {
 80229ea:	f10a 0a10 	add.w	sl, sl, #16
 80229ee:	d1ae      	bne.n	802294e <cblas_zsyrk+0x93e>
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 80229f0:	ec53 2b1a 	vmov	r2, r3, d10
 80229f4:	ec51 0b1d 	vmov	r0, r1, d13
 80229f8:	f005 fa56 	bl	8027ea8 <__aeabi_dmul>
 80229fc:	ec5a 9b1b 	vmov	r9, sl, d11
 8022a00:	ec58 7b1e 	vmov	r7, r8, d14
 8022a04:	4604      	mov	r4, r0
 8022a06:	460d      	mov	r5, r1
 8022a08:	ee1b 2a10 	vmov	r2, s22
 8022a0c:	4653      	mov	r3, sl
 8022a0e:	ee1e 0a10 	vmov	r0, s28
 8022a12:	4641      	mov	r1, r8
 8022a14:	f005 fa48 	bl	8027ea8 <__aeabi_dmul>
 8022a18:	4602      	mov	r2, r0
 8022a1a:	460b      	mov	r3, r1
 8022a1c:	4620      	mov	r0, r4
 8022a1e:	4629      	mov	r1, r5
 8022a20:	f005 f88a 	bl	8027b38 <__aeabi_dsub>
 8022a24:	9e07      	ldr	r6, [sp, #28]
 8022a26:	4602      	mov	r2, r0
 8022a28:	460b      	mov	r3, r1
 8022a2a:	e956 0102 	ldrd	r0, r1, [r6, #-8]
 8022a2e:	f005 f885 	bl	8027b3c <__adddf3>
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022a32:	ee1b 2a10 	vmov	r2, s22
          REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
 8022a36:	e946 0102 	strd	r0, r1, [r6, #-8]
          IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
 8022a3a:	4653      	mov	r3, sl
 8022a3c:	ec51 0b1d 	vmov	r0, r1, d13
 8022a40:	f005 fa32 	bl	8027ea8 <__aeabi_dmul>
 8022a44:	ec53 2b1a 	vmov	r2, r3, d10
 8022a48:	4604      	mov	r4, r0
 8022a4a:	460d      	mov	r5, r1
 8022a4c:	ee1e 0a10 	vmov	r0, s28
 8022a50:	4641      	mov	r1, r8
 8022a52:	f005 fa29 	bl	8027ea8 <__aeabi_dmul>
 8022a56:	4602      	mov	r2, r0
 8022a58:	460b      	mov	r3, r1
 8022a5a:	4620      	mov	r0, r4
 8022a5c:	4629      	mov	r1, r5
 8022a5e:	f005 f86d 	bl	8027b3c <__adddf3>
 8022a62:	9c08      	ldr	r4, [sp, #32]
 8022a64:	4602      	mov	r2, r0
 8022a66:	460b      	mov	r3, r1
 8022a68:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
 8022a6c:	f005 f866 	bl	8027b3c <__adddf3>
 8022a70:	e9c4 0102 	strd	r0, r1, [r4, #8]
        for (j = 0; j <= i; j++) {
 8022a74:	e9dd 2105 	ldrd	r2, r1, [sp, #20]
 8022a78:	440a      	add	r2, r1
 8022a7a:	9205      	str	r2, [sp, #20]
 8022a7c:	f106 0210 	add.w	r2, r6, #16
 8022a80:	9207      	str	r2, [sp, #28]
 8022a82:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8022a84:	f104 0310 	add.w	r3, r4, #16
 8022a88:	429a      	cmp	r2, r3
 8022a8a:	9308      	str	r3, [sp, #32]
 8022a8c:	f47f af4c 	bne.w	8022928 <cblas_zsyrk+0x918>
      for (i = 0; i < N; i++) {
 8022a90:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022a92:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8022a94:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8022a96:	440a      	add	r2, r1
 8022a98:	920d      	str	r2, [sp, #52]	; 0x34
 8022a9a:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022a9c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8022a9e:	440a      	add	r2, r1
 8022aa0:	990a      	ldr	r1, [sp, #40]	; 0x28
 8022aa2:	9209      	str	r2, [sp, #36]	; 0x24
 8022aa4:	4608      	mov	r0, r1
 8022aa6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022aa8:	9902      	ldr	r1, [sp, #8]
 8022aaa:	4410      	add	r0, r2
 8022aac:	4411      	add	r1, r2
 8022aae:	9a03      	ldr	r2, [sp, #12]
 8022ab0:	900a      	str	r0, [sp, #40]	; 0x28
 8022ab2:	3301      	adds	r3, #1
 8022ab4:	429a      	cmp	r2, r3
 8022ab6:	930f      	str	r3, [sp, #60]	; 0x3c
 8022ab8:	9102      	str	r1, [sp, #8]
 8022aba:	f47f af29 	bne.w	8022910 <cblas_zsyrk+0x900>
 8022abe:	e400      	b.n	80222c2 <cblas_zsyrk+0x2b2>
        for (i = 0; i < N; i++) {
 8022ac0:	2b00      	cmp	r3, #0
 8022ac2:	f77f ac44 	ble.w	802234e <cblas_zsyrk+0x33e>
 8022ac6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022ac8:	3301      	adds	r3, #1
 8022aca:	011b      	lsls	r3, r3, #4
 8022acc:	9307      	str	r3, [sp, #28]
 8022ace:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022ad0:	9305      	str	r3, [sp, #20]
 8022ad2:	2300      	movs	r3, #0
 8022ad4:	9302      	str	r3, [sp, #8]
 8022ad6:	f8dd a014 	ldr.w	sl, [sp, #20]
 8022ada:	f8dd b008 	ldr.w	fp, [sp, #8]
 8022ade:	ec59 8b1b 	vmov	r8, r9, d11
            const BASE Cij_real = REAL(C, ldc * i + j);
 8022ae2:	e9da 4500 	ldrd	r4, r5, [sl]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022ae6:	4640      	mov	r0, r8
 8022ae8:	4622      	mov	r2, r4
 8022aea:	462b      	mov	r3, r5
 8022aec:	4649      	mov	r1, r9
 8022aee:	f005 f9db 	bl	8027ea8 <__aeabi_dmul>
            const BASE Cij_imag = IMAG(C, ldc * i + j);
 8022af2:	e9da 6702 	ldrd	r6, r7, [sl, #8]
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022af6:	ec41 0b19 	vmov	d9, r0, r1
 8022afa:	4632      	mov	r2, r6
 8022afc:	463b      	mov	r3, r7
 8022afe:	ec51 0b1a 	vmov	r0, r1, d10
 8022b02:	f005 f9d1 	bl	8027ea8 <__aeabi_dmul>
 8022b06:	4602      	mov	r2, r0
 8022b08:	460b      	mov	r3, r1
 8022b0a:	ec51 0b19 	vmov	r0, r1, d9
 8022b0e:	f005 f813 	bl	8027b38 <__aeabi_dsub>
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022b12:	4632      	mov	r2, r6
            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
 8022b14:	e9ca 0100 	strd	r0, r1, [sl]
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022b18:	463b      	mov	r3, r7
 8022b1a:	4640      	mov	r0, r8
 8022b1c:	4649      	mov	r1, r9
 8022b1e:	f005 f9c3 	bl	8027ea8 <__aeabi_dmul>
 8022b22:	4622      	mov	r2, r4
 8022b24:	462b      	mov	r3, r5
 8022b26:	4604      	mov	r4, r0
 8022b28:	460d      	mov	r5, r1
 8022b2a:	ec51 0b1a 	vmov	r0, r1, d10
 8022b2e:	f005 f9bb 	bl	8027ea8 <__aeabi_dmul>
 8022b32:	460b      	mov	r3, r1
 8022b34:	4602      	mov	r2, r0
 8022b36:	4629      	mov	r1, r5
 8022b38:	4620      	mov	r0, r4
 8022b3a:	f004 ffff 	bl	8027b3c <__adddf3>
          for (j = i; j < N; j++) {
 8022b3e:	9b03      	ldr	r3, [sp, #12]
 8022b40:	f10b 0b01 	add.w	fp, fp, #1
 8022b44:	455b      	cmp	r3, fp
            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
 8022b46:	e9ca 0102 	strd	r0, r1, [sl, #8]
          for (j = i; j < N; j++) {
 8022b4a:	f10a 0a10 	add.w	sl, sl, #16
 8022b4e:	dcc8      	bgt.n	8022ae2 <cblas_zsyrk+0xad2>
        for (i = 0; i < N; i++) {
 8022b50:	9a05      	ldr	r2, [sp, #20]
 8022b52:	9907      	ldr	r1, [sp, #28]
 8022b54:	9b02      	ldr	r3, [sp, #8]
 8022b56:	440a      	add	r2, r1
 8022b58:	9205      	str	r2, [sp, #20]
 8022b5a:	9a03      	ldr	r2, [sp, #12]
 8022b5c:	3301      	adds	r3, #1
 8022b5e:	429a      	cmp	r2, r3
 8022b60:	9302      	str	r3, [sp, #8]
 8022b62:	d1b8      	bne.n	8022ad6 <cblas_zsyrk+0xac6>
 8022b64:	f7ff bbf3 	b.w	802234e <cblas_zsyrk+0x33e>
 8022b68:	9b01      	ldr	r3, [sp, #4]
 8022b6a:	f7ff ba90 	b.w	802208e <cblas_zsyrk+0x7e>
 8022b6e:	bf00      	nop
	...

08022b78 <cblas_ztrmm>:
cblas_ztrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8022b78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022b7c:	ed2d 8b10 	vpush	{d8-d15}
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8022b80:	2b71      	cmp	r3, #113	; 0x71
 8022b82:	b097      	sub	sp, #92	; 0x5c
 8022b84:	461e      	mov	r6, r3
 8022b86:	bf0c      	ite	eq
 8022b88:	f04f 33ff 	moveq.w	r3, #4294967295
 8022b8c:	2301      	movne	r3, #1
 8022b8e:	ee0d 3a10 	vmov	s26, r3
 8022b92:	f89d 30c0 	ldrb.w	r3, [sp, #192]	; 0xc0
 8022b96:	9302      	str	r3, [sp, #8]
 8022b98:	9b31      	ldr	r3, [sp, #196]	; 0xc4
 8022b9a:	9306      	str	r3, [sp, #24]
 8022b9c:	9b32      	ldr	r3, [sp, #200]	; 0xc8
 8022b9e:	9307      	str	r3, [sp, #28]
 8022ba0:	e9dd 8333 	ldrd	r8, r3, [sp, #204]	; 0xcc
 8022ba4:	9310      	str	r3, [sp, #64]	; 0x40
 8022ba6:	e9dd 4335 	ldrd	r4, r3, [sp, #212]	; 0xd4
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8022baa:	298d      	cmp	r1, #141	; 0x8d
 8022bac:	930f      	str	r3, [sp, #60]	; 0x3c
 8022bae:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8022bb0:	930c      	str	r3, [sp, #48]	; 0x30
 8022bb2:	460d      	mov	r5, r1
 8022bb4:	4617      	mov	r7, r2
 8022bb6:	d06d      	beq.n	8022c94 <cblas_ztrmm+0x11c>
 8022bb8:	298e      	cmp	r1, #142	; 0x8e
 8022bba:	f000 8505 	beq.w	80235c8 <cblas_ztrmm+0xa50>
 8022bbe:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8022bc2:	2302      	movs	r3, #2
 8022bc4:	f1a7 0279 	sub.w	r2, r7, #121	; 0x79
 8022bc8:	2a01      	cmp	r2, #1
 8022bca:	9a02      	ldr	r2, [sp, #8]
 8022bcc:	f1a6 016f 	sub.w	r1, r6, #111	; 0x6f
 8022bd0:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8022bd4:	bf88      	it	hi
 8022bd6:	2303      	movhi	r3, #3
 8022bd8:	b2d2      	uxtb	r2, r2
 8022bda:	2902      	cmp	r1, #2
 8022bdc:	bf88      	it	hi
 8022bde:	2304      	movhi	r3, #4
 8022be0:	2a02      	cmp	r2, #2
 8022be2:	9a06      	ldr	r2, [sp, #24]
 8022be4:	bf28      	it	cs
 8022be6:	2305      	movcs	r3, #5
 8022be8:	2a00      	cmp	r2, #0
 8022bea:	9a07      	ldr	r2, [sp, #28]
 8022bec:	bfb8      	it	lt
 8022bee:	2306      	movlt	r3, #6
 8022bf0:	2a00      	cmp	r2, #0
 8022bf2:	bfb8      	it	lt
 8022bf4:	2307      	movlt	r3, #7
 8022bf6:	f1bc 0f01 	cmp.w	ip, #1
 8022bfa:	bfb8      	it	lt
 8022bfc:	f04f 0c01 	movlt.w	ip, #1
 8022c00:	45a4      	cmp	ip, r4
 8022c02:	dd3a      	ble.n	8022c7a <cblas_ztrmm+0x102>
 8022c04:	2865      	cmp	r0, #101	; 0x65
 8022c06:	f000 8156 	beq.w	8022eb6 <cblas_ztrmm+0x33e>
 8022c0a:	9b06      	ldr	r3, [sp, #24]
 8022c0c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022c0e:	2b01      	cmp	r3, #1
 8022c10:	bfb8      	it	lt
 8022c12:	2301      	movlt	r3, #1
 8022c14:	4293      	cmp	r3, r2
 8022c16:	bfcc      	ite	gt
 8022c18:	230c      	movgt	r3, #12
 8022c1a:	230a      	movle	r3, #10
 8022c1c:	4ab8      	ldr	r2, [pc, #736]	; (8022f00 <cblas_ztrmm+0x388>)
 8022c1e:	49b9      	ldr	r1, [pc, #740]	; (8022f04 <cblas_ztrmm+0x38c>)
 8022c20:	4618      	mov	r0, r3
 8022c22:	f004 ff11 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8022c26:	ed98 7b00 	vldr	d7, [r8]
 8022c2a:	eeb0 fa47 	vmov.f32	s30, s14
 8022c2e:	eef0 fa67 	vmov.f32	s31, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8022c32:	ed98 7b02 	vldr	d7, [r8, #8]
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8022c36:	2d8d      	cmp	r5, #141	; 0x8d
 8022c38:	bf0c      	ite	eq
 8022c3a:	258e      	moveq	r5, #142	; 0x8e
 8022c3c:	258d      	movne	r5, #141	; 0x8d
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8022c3e:	ed8d 7b04 	vstr	d7, [sp, #16]
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8022c42:	2f79      	cmp	r7, #121	; 0x79
 8022c44:	bf0c      	ite	eq
 8022c46:	277a      	moveq	r7, #122	; 0x7a
 8022c48:	2779      	movne	r7, #121	; 0x79
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 8022c4a:	2e6f      	cmp	r6, #111	; 0x6f
 8022c4c:	bf0c      	ite	eq
 8022c4e:	266f      	moveq	r6, #111	; 0x6f
 8022c50:	2670      	movne	r6, #112	; 0x70
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8022c52:	2d8d      	cmp	r5, #141	; 0x8d
 8022c54:	d027      	beq.n	8022ca6 <cblas_ztrmm+0x12e>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8022c56:	2d8e      	cmp	r5, #142	; 0x8e
 8022c58:	d105      	bne.n	8022c66 <cblas_ztrmm+0xee>
 8022c5a:	2f79      	cmp	r7, #121	; 0x79
 8022c5c:	f000 8156 	beq.w	8022f0c <cblas_ztrmm+0x394>
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8022c60:	2f7a      	cmp	r7, #122	; 0x7a
 8022c62:	f000 8284 	beq.w	802316e <cblas_ztrmm+0x5f6>
      BLAS_ERROR("unrecognized operation");
 8022c66:	4aa8      	ldr	r2, [pc, #672]	; (8022f08 <cblas_ztrmm+0x390>)
 8022c68:	49a6      	ldr	r1, [pc, #664]	; (8022f04 <cblas_ztrmm+0x38c>)
 8022c6a:	2000      	movs	r0, #0
#define BASE double
#include "source_trmm_c.h"
#undef BASE
}
 8022c6c:	b017      	add	sp, #92	; 0x5c
 8022c6e:	ecbd 8b10 	vpop	{d8-d15}
 8022c72:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022c76:	f004 bee7 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8022c7a:	2865      	cmp	r0, #101	; 0x65
 8022c7c:	f000 8385 	beq.w	802338a <cblas_ztrmm+0x812>
 8022c80:	9a06      	ldr	r2, [sp, #24]
 8022c82:	990c      	ldr	r1, [sp, #48]	; 0x30
 8022c84:	2a01      	cmp	r2, #1
 8022c86:	bfb8      	it	lt
 8022c88:	2201      	movlt	r2, #1
 8022c8a:	428a      	cmp	r2, r1
 8022c8c:	f340 8134 	ble.w	8022ef8 <cblas_ztrmm+0x380>
 8022c90:	230c      	movs	r3, #12
 8022c92:	e7c3      	b.n	8022c1c <cblas_ztrmm+0xa4>
 8022c94:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8022c98:	2b01      	cmp	r3, #1
 8022c9a:	f8dd c018 	ldr.w	ip, [sp, #24]
 8022c9e:	bf94      	ite	ls
 8022ca0:	2300      	movls	r3, #0
 8022ca2:	2301      	movhi	r3, #1
 8022ca4:	e78e      	b.n	8022bc4 <cblas_ztrmm+0x4c>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8022ca6:	2f79      	cmp	r7, #121	; 0x79
 8022ca8:	f000 837e 	beq.w	80233a8 <cblas_ztrmm+0x830>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8022cac:	2f7a      	cmp	r7, #122	; 0x7a
 8022cae:	d1da      	bne.n	8022c66 <cblas_ztrmm+0xee>
 8022cb0:	2e6f      	cmp	r6, #111	; 0x6f
 8022cb2:	f000 8721 	beq.w	8023af8 <cblas_ztrmm+0xf80>
      for (i = 0; i < n1; i++) {
 8022cb6:	9b07      	ldr	r3, [sp, #28]
 8022cb8:	2b00      	cmp	r3, #0
 8022cba:	f340 80f7 	ble.w	8022eac <cblas_ztrmm+0x334>
 8022cbe:	3401      	adds	r4, #1
 8022cc0:	0122      	lsls	r2, r4, #4
 8022cc2:	9910      	ldr	r1, [sp, #64]	; 0x40
 8022cc4:	9214      	str	r2, [sp, #80]	; 0x50
 8022cc6:	f1a2 0308 	sub.w	r3, r2, #8
 8022cca:	18cb      	adds	r3, r1, r3
 8022ccc:	930d      	str	r3, [sp, #52]	; 0x34
 8022cce:	f1a2 0310 	sub.w	r3, r2, #16
 8022cd2:	9303      	str	r3, [sp, #12]
 8022cd4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022cd6:	9312      	str	r3, [sp, #72]	; 0x48
 8022cd8:	011a      	lsls	r2, r3, #4
 8022cda:	2300      	movs	r3, #0
 8022cdc:	9311      	str	r3, [sp, #68]	; 0x44
 8022cde:	2301      	movs	r3, #1
 8022ce0:	9201      	str	r2, [sp, #4]
 8022ce2:	930b      	str	r3, [sp, #44]	; 0x2c
        for (j = 0; j < n2; j++) {
 8022ce4:	9b06      	ldr	r3, [sp, #24]
 8022ce6:	2b00      	cmp	r3, #0
 8022ce8:	f341 81cb 	ble.w	8024082 <cblas_ztrmm+0x150a>
 8022cec:	e9dd 2311 	ldrd	r2, r3, [sp, #68]	; 0x44
 8022cf0:	1a9b      	subs	r3, r3, r2
 8022cf2:	011b      	lsls	r3, r3, #4
 8022cf4:	3308      	adds	r3, #8
 8022cf6:	930e      	str	r3, [sp, #56]	; 0x38
 8022cf8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022cfa:	9313      	str	r3, [sp, #76]	; 0x4c
 8022cfc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8022cfe:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8022d02:	9308      	str	r3, [sp, #32]
 8022d04:	2300      	movs	r3, #0
 8022d06:	9309      	str	r3, [sp, #36]	; 0x24
          if (nonunit) {
 8022d08:	9b02      	ldr	r3, [sp, #8]
 8022d0a:	2b83      	cmp	r3, #131	; 0x83
 8022d0c:	f000 8508 	beq.w	8023720 <cblas_ztrmm+0xba8>
            temp_real = REAL(B, i * ldb + j);
 8022d10:	9b08      	ldr	r3, [sp, #32]
 8022d12:	461a      	mov	r2, r3
 8022d14:	ecb2 7b02 	vldmia	r2!, {d7}
 8022d18:	eeb0 ba47 	vmov.f32	s22, s14
 8022d1c:	eef0 ba67 	vmov.f32	s23, s15
            temp_imag = IMAG(B, i * ldb + j);
 8022d20:	ed93 7b02 	vldr	d7, [r3, #8]
            temp_real = REAL(B, i * ldb + j);
 8022d24:	920a      	str	r2, [sp, #40]	; 0x28
            temp_imag = IMAG(B, i * ldb + j);
 8022d26:	eeb0 ca47 	vmov.f32	s24, s14
 8022d2a:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 8022d2e:	9e07      	ldr	r6, [sp, #28]
 8022d30:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 8022d32:	42ae      	cmp	r6, r5
 8022d34:	dd62      	ble.n	8022dfc <cblas_ztrmm+0x284>
 8022d36:	ee1d 0a10 	vmov	r0, s26
 8022d3a:	f005 f84b 	bl	8027dd4 <__aeabi_i2d>
 8022d3e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8022d40:	9a08      	ldr	r2, [sp, #32]
 8022d42:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8022d44:	ec41 0b1e 	vmov	d14, r0, r1
 8022d48:	eb03 0a02 	add.w	sl, r3, r2
 8022d4c:	46b3      	mov	fp, r6
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8022d4e:	e9d4 2300 	ldrd	r2, r3, [r4]
 8022d52:	ec51 0b1e 	vmov	r0, r1, d14
 8022d56:	f005 f8a7 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8022d5a:	ed14 7b02 	vldr	d7, [r4, #-8]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8022d5e:	ed1a 6b02 	vldr	d6, [sl, #-8]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8022d62:	eeb0 aa47 	vmov.f32	s20, s14
 8022d66:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8022d6a:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8022d6e:	eeb0 9a46 	vmov.f32	s18, s12
 8022d72:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8022d76:	4680      	mov	r8, r0
 8022d78:	4689      	mov	r9, r1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8022d7a:	ec51 0b17 	vmov	r0, r1, d7
 8022d7e:	f005 f893 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8022d82:	ed9a 8b00 	vldr	d8, [sl]
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8022d86:	4606      	mov	r6, r0
 8022d88:	ec53 2b18 	vmov	r2, r3, d8
 8022d8c:	460f      	mov	r7, r1
 8022d8e:	4640      	mov	r0, r8
 8022d90:	4649      	mov	r1, r9
 8022d92:	f005 f889 	bl	8027ea8 <__aeabi_dmul>
 8022d96:	4602      	mov	r2, r0
 8022d98:	460b      	mov	r3, r1
 8022d9a:	4630      	mov	r0, r6
 8022d9c:	4639      	mov	r1, r7
 8022d9e:	f004 fecb 	bl	8027b38 <__aeabi_dsub>
 8022da2:	4602      	mov	r2, r0
 8022da4:	460b      	mov	r3, r1
 8022da6:	ec51 0b1b 	vmov	r0, r1, d11
 8022daa:	f004 fec7 	bl	8027b3c <__adddf3>
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8022dae:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8022db2:	4606      	mov	r6, r0
 8022db4:	460f      	mov	r7, r1
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8022db6:	ec51 0b1a 	vmov	r0, r1, d10
 8022dba:	f005 f875 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8022dbe:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8022dc2:	ec53 2b19 	vmov	r2, r3, d9
 8022dc6:	4606      	mov	r6, r0
 8022dc8:	460f      	mov	r7, r1
 8022dca:	4640      	mov	r0, r8
 8022dcc:	4649      	mov	r1, r9
 8022dce:	f005 f86b 	bl	8027ea8 <__aeabi_dmul>
 8022dd2:	4602      	mov	r2, r0
 8022dd4:	460b      	mov	r3, r1
 8022dd6:	4630      	mov	r0, r6
 8022dd8:	4639      	mov	r1, r7
 8022dda:	f004 feaf 	bl	8027b3c <__adddf3>
 8022dde:	460b      	mov	r3, r1
 8022de0:	4602      	mov	r2, r0
 8022de2:	ec51 0b1c 	vmov	r0, r1, d12
 8022de6:	f004 fea9 	bl	8027b3c <__adddf3>
 8022dea:	9b03      	ldr	r3, [sp, #12]
          for (k = i + 1; k < n1; k++) {
 8022dec:	3501      	adds	r5, #1
 8022dee:	441c      	add	r4, r3
 8022df0:	9b01      	ldr	r3, [sp, #4]
 8022df2:	45ab      	cmp	fp, r5
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 8022df4:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = i + 1; k < n1; k++) {
 8022df8:	449a      	add	sl, r3
 8022dfa:	d1a8      	bne.n	8022d4e <cblas_ztrmm+0x1d6>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8022dfc:	ec5b ab1b 	vmov	sl, fp, d11
 8022e00:	ec53 2b1f 	vmov	r2, r3, d15
 8022e04:	ee1b 0a10 	vmov	r0, s22
 8022e08:	4659      	mov	r1, fp
 8022e0a:	f005 f84d 	bl	8027ea8 <__aeabi_dmul>
 8022e0e:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 8022e12:	ec57 6b1c 	vmov	r6, r7, d12
 8022e16:	4604      	mov	r4, r0
 8022e18:	460d      	mov	r5, r1
 8022e1a:	4642      	mov	r2, r8
 8022e1c:	464b      	mov	r3, r9
 8022e1e:	ee1c 0a10 	vmov	r0, s24
 8022e22:	4639      	mov	r1, r7
 8022e24:	f005 f840 	bl	8027ea8 <__aeabi_dmul>
 8022e28:	4602      	mov	r2, r0
 8022e2a:	460b      	mov	r3, r1
 8022e2c:	4620      	mov	r0, r4
 8022e2e:	4629      	mov	r1, r5
 8022e30:	f004 fe82 	bl	8027b38 <__aeabi_dsub>
 8022e34:	9c08      	ldr	r4, [sp, #32]
 8022e36:	e8e4 0104 	strd	r0, r1, [r4], #16
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8022e3a:	ec53 2b1f 	vmov	r2, r3, d15
 8022e3e:	ee1c 0a10 	vmov	r0, s24
 8022e42:	4639      	mov	r1, r7
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8022e44:	9408      	str	r4, [sp, #32]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8022e46:	f005 f82f 	bl	8027ea8 <__aeabi_dmul>
 8022e4a:	4642      	mov	r2, r8
 8022e4c:	464b      	mov	r3, r9
 8022e4e:	4604      	mov	r4, r0
 8022e50:	460d      	mov	r5, r1
 8022e52:	ee1b 0a10 	vmov	r0, s22
 8022e56:	4659      	mov	r1, fp
 8022e58:	f005 f826 	bl	8027ea8 <__aeabi_dmul>
 8022e5c:	4602      	mov	r2, r0
 8022e5e:	460b      	mov	r3, r1
 8022e60:	4620      	mov	r0, r4
 8022e62:	4629      	mov	r1, r5
 8022e64:	f004 fe6a 	bl	8027b3c <__adddf3>
 8022e68:	9a0a      	ldr	r2, [sp, #40]	; 0x28
        for (j = 0; j < n2; j++) {
 8022e6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8022e6c:	e9c2 0100 	strd	r0, r1, [r2]
        for (j = 0; j < n2; j++) {
 8022e70:	9a06      	ldr	r2, [sp, #24]
 8022e72:	3301      	adds	r3, #1
 8022e74:	429a      	cmp	r2, r3
 8022e76:	9309      	str	r3, [sp, #36]	; 0x24
 8022e78:	f47f af46 	bne.w	8022d08 <cblas_ztrmm+0x190>
      for (i = 0; i < n1; i++) {
 8022e7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8022e7e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8022e80:	3301      	adds	r3, #1
 8022e82:	930b      	str	r3, [sp, #44]	; 0x2c
 8022e84:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8022e86:	4611      	mov	r1, r2
 8022e88:	4419      	add	r1, r3
 8022e8a:	910d      	str	r1, [sp, #52]	; 0x34
 8022e8c:	9912      	ldr	r1, [sp, #72]	; 0x48
 8022e8e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022e90:	4608      	mov	r0, r1
 8022e92:	9911      	ldr	r1, [sp, #68]	; 0x44
 8022e94:	4410      	add	r0, r2
 8022e96:	4411      	add	r1, r2
 8022e98:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8022e9a:	9012      	str	r0, [sp, #72]	; 0x48
 8022e9c:	441a      	add	r2, r3
 8022e9e:	9210      	str	r2, [sp, #64]	; 0x40
 8022ea0:	9b07      	ldr	r3, [sp, #28]
 8022ea2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8022ea4:	9111      	str	r1, [sp, #68]	; 0x44
 8022ea6:	4293      	cmp	r3, r2
 8022ea8:	f73f af1c 	bgt.w	8022ce4 <cblas_ztrmm+0x16c>
 8022eac:	b017      	add	sp, #92	; 0x5c
 8022eae:	ecbd 8b10 	vpop	{d8-d15}
 8022eb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8022eb6:	4613      	mov	r3, r2
 8022eb8:	2a01      	cmp	r2, #1
 8022eba:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8022ebc:	bfb8      	it	lt
 8022ebe:	2301      	movlt	r3, #1
 8022ec0:	4293      	cmp	r3, r2
 8022ec2:	bfcc      	ite	gt
 8022ec4:	230c      	movgt	r3, #12
 8022ec6:	230a      	movle	r3, #10
 8022ec8:	4a0d      	ldr	r2, [pc, #52]	; (8022f00 <cblas_ztrmm+0x388>)
 8022eca:	490e      	ldr	r1, [pc, #56]	; (8022f04 <cblas_ztrmm+0x38c>)
 8022ecc:	4618      	mov	r0, r3
 8022ece:	f004 fdbb 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8022ed2:	ed98 7b00 	vldr	d7, [r8]
 8022ed6:	eeb0 fa47 	vmov.f32	s30, s14
 8022eda:	eef0 fa67 	vmov.f32	s31, s15
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8022ede:	ed98 7b02 	vldr	d7, [r8, #8]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8022ee2:	2e6f      	cmp	r6, #111	; 0x6f
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8022ee4:	ed8d 7b04 	vstr	d7, [sp, #16]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8022ee8:	9b07      	ldr	r3, [sp, #28]
 8022eea:	f000 8364 	beq.w	80235b6 <cblas_ztrmm+0xa3e>
 8022eee:	9a06      	ldr	r2, [sp, #24]
 8022ef0:	2670      	movs	r6, #112	; 0x70
 8022ef2:	e9cd 3206 	strd	r3, r2, [sp, #24]
 8022ef6:	e6ac      	b.n	8022c52 <cblas_ztrmm+0xda>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8022ef8:	2b00      	cmp	r3, #0
 8022efa:	f43f ae94 	beq.w	8022c26 <cblas_ztrmm+0xae>
 8022efe:	e68d      	b.n	8022c1c <cblas_ztrmm+0xa4>
 8022f00:	08030378 	.word	0x08030378
 8022f04:	08030784 	.word	0x08030784
 8022f08:	080305a8 	.word	0x080305a8
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8022f0c:	2e6f      	cmp	r6, #111	; 0x6f
      for (i = 0; i < n1; i++) {
 8022f0e:	9b07      	ldr	r3, [sp, #28]
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8022f10:	f000 8765 	beq.w	8023dde <cblas_ztrmm+0x1266>
      for (i = 0; i < n1; i++) {
 8022f14:	2b00      	cmp	r3, #0
 8022f16:	ddc9      	ble.n	8022eac <cblas_ztrmm+0x334>
 8022f18:	1c62      	adds	r2, r4, #1
 8022f1a:	0121      	lsls	r1, r4, #4
 8022f1c:	0112      	lsls	r2, r2, #4
 8022f1e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022f20:	920e      	str	r2, [sp, #56]	; 0x38
 8022f22:	f101 0210 	add.w	r2, r1, #16
 8022f26:	920b      	str	r2, [sp, #44]	; 0x2c
 8022f28:	9a06      	ldr	r2, [sp, #24]
 8022f2a:	910d      	str	r1, [sp, #52]	; 0x34
 8022f2c:	3b10      	subs	r3, #16
 8022f2e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8022f32:	9315      	str	r3, [sp, #84]	; 0x54
 8022f34:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8022f36:	011b      	lsls	r3, r3, #4
 8022f38:	9314      	str	r3, [sp, #80]	; 0x50
 8022f3a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8022f3c:	2000      	movs	r0, #0
 8022f3e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8022f42:	9011      	str	r0, [sp, #68]	; 0x44
 8022f44:	9013      	str	r0, [sp, #76]	; 0x4c
 8022f46:	9312      	str	r3, [sp, #72]	; 0x48
        for (j = 0; j < n2; j++) {
 8022f48:	9b06      	ldr	r3, [sp, #24]
 8022f4a:	2b00      	cmp	r3, #0
 8022f4c:	f340 8479 	ble.w	8023842 <cblas_ztrmm+0xcca>
 8022f50:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8022f52:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8022f54:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8022f58:	9303      	str	r3, [sp, #12]
 8022f5a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8022f5c:	9308      	str	r3, [sp, #32]
 8022f5e:	461a      	mov	r2, r3
 8022f60:	2300      	movs	r3, #0
 8022f62:	930a      	str	r3, [sp, #40]	; 0x28
          if (nonunit) {
 8022f64:	9b02      	ldr	r3, [sp, #8]
 8022f66:	3208      	adds	r2, #8
 8022f68:	9209      	str	r2, [sp, #36]	; 0x24
 8022f6a:	2b83      	cmp	r3, #131	; 0x83
        for (j = 0; j < n2; j++) {
 8022f6c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8022f6e:	9201      	str	r2, [sp, #4]
          if (nonunit) {
 8022f70:	f000 80b8 	beq.w	80230e4 <cblas_ztrmm+0x56c>
            temp_real = REAL(B, i * ldb + j);
 8022f74:	9b03      	ldr	r3, [sp, #12]
 8022f76:	ed93 7b00 	vldr	d7, [r3]
 8022f7a:	eeb0 aa47 	vmov.f32	s20, s14
 8022f7e:	eef0 aa67 	vmov.f32	s21, s15
            temp_imag = IMAG(B, i * ldb + j);
 8022f82:	ed93 7b02 	vldr	d7, [r3, #8]
 8022f86:	eeb0 ba47 	vmov.f32	s22, s14
 8022f8a:	eef0 ba67 	vmov.f32	s23, s15
          for (k = j + 1; k < n2; k++) {
 8022f8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8022f90:	9a06      	ldr	r2, [sp, #24]
 8022f92:	3301      	adds	r3, #1
 8022f94:	429a      	cmp	r2, r3
 8022f96:	930a      	str	r3, [sp, #40]	; 0x28
 8022f98:	f000 8420 	beq.w	80237dc <cblas_ztrmm+0xc64>
 8022f9c:	ee1d 0a10 	vmov	r0, s26
 8022fa0:	f004 ff18 	bl	8027dd4 <__aeabi_i2d>
 8022fa4:	9d03      	ldr	r5, [sp, #12]
 8022fa6:	9c08      	ldr	r4, [sp, #32]
 8022fa8:	ec41 0b1c 	vmov	d12, r0, r1
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8022fac:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 8022fb0:	ec51 0b1c 	vmov	r0, r1, d12
 8022fb4:	f004 ff78 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022fb8:	ed94 7b04 	vldr	d7, [r4, #16]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8022fbc:	ed95 6b04 	vldr	d6, [r5, #16]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8022fc0:	eeb0 9a47 	vmov.f32	s18, s14
 8022fc4:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8022fc8:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bik_real = REAL(B, i * ldb + k);
 8022fcc:	eeb0 8a46 	vmov.f32	s16, s12
 8022fd0:	eef0 8a66 	vmov.f32	s17, s13
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8022fd4:	4680      	mov	r8, r0
 8022fd6:	4689      	mov	r9, r1
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8022fd8:	ec51 0b17 	vmov	r0, r1, d7
 8022fdc:	f004 ff64 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8022fe0:	e9d5 ab06 	ldrd	sl, fp, [r5, #24]
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8022fe4:	4606      	mov	r6, r0
 8022fe6:	460f      	mov	r7, r1
 8022fe8:	4652      	mov	r2, sl
 8022fea:	465b      	mov	r3, fp
 8022fec:	4640      	mov	r0, r8
 8022fee:	4649      	mov	r1, r9
 8022ff0:	f004 ff5a 	bl	8027ea8 <__aeabi_dmul>
 8022ff4:	4602      	mov	r2, r0
 8022ff6:	460b      	mov	r3, r1
 8022ff8:	4630      	mov	r0, r6
 8022ffa:	4639      	mov	r1, r7
 8022ffc:	f004 fd9c 	bl	8027b38 <__aeabi_dsub>
 8023000:	4602      	mov	r2, r0
 8023002:	460b      	mov	r3, r1
 8023004:	ec51 0b1a 	vmov	r0, r1, d10
 8023008:	f004 fd98 	bl	8027b3c <__adddf3>
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 802300c:	4652      	mov	r2, sl
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 802300e:	4606      	mov	r6, r0
 8023010:	460f      	mov	r7, r1
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023012:	465b      	mov	r3, fp
 8023014:	ec51 0b19 	vmov	r0, r1, d9
 8023018:	f004 ff46 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 802301c:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023020:	ec53 2b18 	vmov	r2, r3, d8
 8023024:	4606      	mov	r6, r0
 8023026:	460f      	mov	r7, r1
 8023028:	4640      	mov	r0, r8
 802302a:	4649      	mov	r1, r9
 802302c:	f004 ff3c 	bl	8027ea8 <__aeabi_dmul>
 8023030:	4602      	mov	r2, r0
 8023032:	460b      	mov	r3, r1
 8023034:	4630      	mov	r0, r6
 8023036:	4639      	mov	r1, r7
 8023038:	f004 fd80 	bl	8027b3c <__adddf3>
 802303c:	460b      	mov	r3, r1
 802303e:	4602      	mov	r2, r0
 8023040:	ec51 0b1b 	vmov	r0, r1, d11
 8023044:	f004 fd7a 	bl	8027b3c <__adddf3>
          for (k = j + 1; k < n2; k++) {
 8023048:	9b01      	ldr	r3, [sp, #4]
 802304a:	3410      	adds	r4, #16
 802304c:	42a3      	cmp	r3, r4
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 802304e:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = j + 1; k < n2; k++) {
 8023052:	f105 0510 	add.w	r5, r5, #16
 8023056:	d1a9      	bne.n	8022fac <cblas_ztrmm+0x434>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023058:	ec53 2b1f 	vmov	r2, r3, d15
 802305c:	ec51 0b1a 	vmov	r0, r1, d10
 8023060:	f004 ff22 	bl	8027ea8 <__aeabi_dmul>
 8023064:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 8023068:	ec58 7b1b 	vmov	r7, r8, d11
 802306c:	4604      	mov	r4, r0
 802306e:	460d      	mov	r5, r1
 8023070:	464a      	mov	r2, r9
 8023072:	4653      	mov	r3, sl
 8023074:	ee1b 0a10 	vmov	r0, s22
 8023078:	4641      	mov	r1, r8
 802307a:	f004 ff15 	bl	8027ea8 <__aeabi_dmul>
 802307e:	4602      	mov	r2, r0
 8023080:	460b      	mov	r3, r1
 8023082:	4620      	mov	r0, r4
 8023084:	4629      	mov	r1, r5
 8023086:	f004 fd57 	bl	8027b38 <__aeabi_dsub>
 802308a:	9e03      	ldr	r6, [sp, #12]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 802308c:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 802308e:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023092:	4653      	mov	r3, sl
 8023094:	ec51 0b1a 	vmov	r0, r1, d10
 8023098:	f004 ff06 	bl	8027ea8 <__aeabi_dmul>
 802309c:	ec53 2b1f 	vmov	r2, r3, d15
 80230a0:	4604      	mov	r4, r0
 80230a2:	460d      	mov	r5, r1
 80230a4:	ee1b 0a10 	vmov	r0, s22
 80230a8:	4641      	mov	r1, r8
 80230aa:	f004 fefd 	bl	8027ea8 <__aeabi_dmul>
 80230ae:	4602      	mov	r2, r0
 80230b0:	460b      	mov	r3, r1
 80230b2:	4620      	mov	r0, r4
 80230b4:	4629      	mov	r1, r5
 80230b6:	f004 fd41 	bl	8027b3c <__adddf3>
 80230ba:	9b08      	ldr	r3, [sp, #32]
 80230bc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80230be:	4413      	add	r3, r2
 80230c0:	9308      	str	r3, [sp, #32]
 80230c2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80230c4:	9b01      	ldr	r3, [sp, #4]
 80230c6:	4413      	add	r3, r2
 80230c8:	9301      	str	r3, [sp, #4]
 80230ca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80230cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80230ce:	4413      	add	r3, r2
 80230d0:	9309      	str	r3, [sp, #36]	; 0x24
 80230d2:	f106 0310 	add.w	r3, r6, #16
 80230d6:	9303      	str	r3, [sp, #12]
          if (nonunit) {
 80230d8:	9b02      	ldr	r3, [sp, #8]
 80230da:	2b83      	cmp	r3, #131	; 0x83
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80230dc:	e9c6 0102 	strd	r0, r1, [r6, #8]
          if (nonunit) {
 80230e0:	f47f af48 	bne.w	8022f74 <cblas_ztrmm+0x3fc>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80230e4:	ee1d 0a10 	vmov	r0, s26
 80230e8:	f004 fe74 	bl	8027dd4 <__aeabi_i2d>
 80230ec:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80230ee:	e9d4 2300 	ldrd	r2, r3, [r4]
 80230f2:	f004 fed9 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 80230f6:	e954 8902 	ldrd	r8, r9, [r4, #-8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 80230fa:	9c03      	ldr	r4, [sp, #12]
 80230fc:	ed94 7b00 	vldr	d7, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023100:	4682      	mov	sl, r0
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023102:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023106:	eeb0 8a47 	vmov.f32	s16, s14
 802310a:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 802310e:	468b      	mov	fp, r1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023110:	4640      	mov	r0, r8
 8023112:	4649      	mov	r1, r9
 8023114:	f004 fec8 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8023118:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 802311c:	460d      	mov	r5, r1
 802311e:	4604      	mov	r4, r0
 8023120:	4632      	mov	r2, r6
 8023122:	463b      	mov	r3, r7
 8023124:	4650      	mov	r0, sl
 8023126:	4659      	mov	r1, fp
 8023128:	f004 febe 	bl	8027ea8 <__aeabi_dmul>
 802312c:	4602      	mov	r2, r0
 802312e:	460b      	mov	r3, r1
 8023130:	4620      	mov	r0, r4
 8023132:	4629      	mov	r1, r5
 8023134:	f004 fd00 	bl	8027b38 <__aeabi_dsub>
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8023138:	4632      	mov	r2, r6
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 802313a:	4604      	mov	r4, r0
 802313c:	460d      	mov	r5, r1
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 802313e:	463b      	mov	r3, r7
 8023140:	4640      	mov	r0, r8
 8023142:	4649      	mov	r1, r9
 8023144:	f004 feb0 	bl	8027ea8 <__aeabi_dmul>
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023148:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 802314c:	ec53 2b18 	vmov	r2, r3, d8
 8023150:	4604      	mov	r4, r0
 8023152:	460d      	mov	r5, r1
 8023154:	4650      	mov	r0, sl
 8023156:	4659      	mov	r1, fp
 8023158:	f004 fea6 	bl	8027ea8 <__aeabi_dmul>
 802315c:	4602      	mov	r2, r0
 802315e:	460b      	mov	r3, r1
 8023160:	4620      	mov	r0, r4
 8023162:	4629      	mov	r1, r5
 8023164:	f004 fcea 	bl	8027b3c <__adddf3>
 8023168:	ec41 0b1b 	vmov	d11, r0, r1
 802316c:	e70f      	b.n	8022f8e <cblas_ztrmm+0x416>
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 802316e:	2e6f      	cmp	r6, #111	; 0x6f
      for (i = 0; i < n1; i++) {
 8023170:	9b07      	ldr	r3, [sp, #28]
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8023172:	f000 8791 	beq.w	8024098 <cblas_ztrmm+0x1520>
      for (i = 0; i < n1; i++) {
 8023176:	2b00      	cmp	r3, #0
 8023178:	f77f ae98 	ble.w	8022eac <cblas_ztrmm+0x334>
 802317c:	9906      	ldr	r1, [sp, #24]
 802317e:	1e4b      	subs	r3, r1, #1
 8023180:	fb03 1004 	mla	r0, r3, r4, r1
 8023184:	1c62      	adds	r2, r4, #1
 8023186:	43e6      	mvns	r6, r4
 8023188:	ebc4 7c04 	rsb	ip, r4, r4, lsl #28
 802318c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 802318e:	0124      	lsls	r4, r4, #4
 8023190:	9411      	str	r4, [sp, #68]	; 0x44
 8023192:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8023194:	940b      	str	r4, [sp, #44]	; 0x2c
 8023196:	0112      	lsls	r2, r2, #4
 8023198:	9c10      	ldr	r4, [sp, #64]	; 0x40
 802319a:	460f      	mov	r7, r1
 802319c:	9910      	ldr	r1, [sp, #64]	; 0x40
 802319e:	f1a2 0510 	sub.w	r5, r2, #16
 80231a2:	fb03 4505 	mla	r5, r3, r5, r4
 80231a6:	3910      	subs	r1, #16
 80231a8:	fb03 4302 	mla	r3, r3, r2, r4
 80231ac:	9310      	str	r3, [sp, #64]	; 0x40
 80231ae:	eb01 1300 	add.w	r3, r1, r0, lsl #4
 80231b2:	9312      	str	r3, [sp, #72]	; 0x48
 80231b4:	0133      	lsls	r3, r6, #4
 80231b6:	930c      	str	r3, [sp, #48]	; 0x30
 80231b8:	ea4f 130c 	mov.w	r3, ip, lsl #4
 80231bc:	930d      	str	r3, [sp, #52]	; 0x34
 80231be:	013b      	lsls	r3, r7, #4
 80231c0:	930f      	str	r3, [sp, #60]	; 0x3c
 80231c2:	2300      	movs	r3, #0
 80231c4:	9513      	str	r5, [sp, #76]	; 0x4c
 80231c6:	930e      	str	r3, [sp, #56]	; 0x38
        for (j = n2; j > 0 && j--;) {
 80231c8:	9b06      	ldr	r3, [sp, #24]
 80231ca:	2b00      	cmp	r3, #0
 80231cc:	f340 80d1 	ble.w	8023372 <cblas_ztrmm+0x7fa>
 80231d0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80231d2:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80231d4:	9303      	str	r3, [sp, #12]
 80231d6:	440a      	add	r2, r1
 80231d8:	9209      	str	r2, [sp, #36]	; 0x24
 80231da:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80231dc:	9201      	str	r2, [sp, #4]
 80231de:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80231e0:	9208      	str	r2, [sp, #32]
 80231e2:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80231e4:	920a      	str	r2, [sp, #40]	; 0x28
          for (k = 0; k < j; k++) {
 80231e6:	9b03      	ldr	r3, [sp, #12]
 80231e8:	3b01      	subs	r3, #1
 80231ea:	9303      	str	r3, [sp, #12]
 80231ec:	f000 82e0 	beq.w	80237b0 <cblas_ztrmm+0xc38>
 80231f0:	ee1d 0a10 	vmov	r0, s26
 80231f4:	f004 fdee 	bl	8027dd4 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 80231f8:	ed9f 7b69 	vldr	d7, [pc, #420]	; 80233a0 <cblas_ztrmm+0x828>
 80231fc:	ec41 0b1c 	vmov	d12, r0, r1
 8023200:	eeb0 ba47 	vmov.f32	s22, s14
 8023204:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < j; k++) {
 8023208:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 802320a:	9c08      	ldr	r4, [sp, #32]
          BASE temp_real = 0.0;
 802320c:	eeb0 aa47 	vmov.f32	s20, s14
 8023210:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8023214:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8023218:	ec51 0b1c 	vmov	r0, r1, d12
 802321c:	f004 fe44 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023220:	ed94 7b00 	vldr	d7, [r4]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023224:	ed95 6b00 	vldr	d6, [r5]
            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8023228:	eeb0 9a47 	vmov.f32	s18, s14
 802322c:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023230:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023234:	eeb0 8a46 	vmov.f32	s16, s12
 8023238:	eef0 8a66 	vmov.f32	s17, s13
            const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 802323c:	4680      	mov	r8, r0
 802323e:	4689      	mov	r9, r1
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023240:	ec51 0b17 	vmov	r0, r1, d7
 8023244:	f004 fe30 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8023248:	e9d5 ab02 	ldrd	sl, fp, [r5, #8]
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 802324c:	4606      	mov	r6, r0
 802324e:	460f      	mov	r7, r1
 8023250:	4652      	mov	r2, sl
 8023252:	465b      	mov	r3, fp
 8023254:	4640      	mov	r0, r8
 8023256:	4649      	mov	r1, r9
 8023258:	f004 fe26 	bl	8027ea8 <__aeabi_dmul>
 802325c:	4602      	mov	r2, r0
 802325e:	460b      	mov	r3, r1
 8023260:	4630      	mov	r0, r6
 8023262:	4639      	mov	r1, r7
 8023264:	f004 fc68 	bl	8027b38 <__aeabi_dsub>
 8023268:	4602      	mov	r2, r0
 802326a:	460b      	mov	r3, r1
 802326c:	ec51 0b1a 	vmov	r0, r1, d10
 8023270:	f004 fc64 	bl	8027b3c <__adddf3>
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023274:	4652      	mov	r2, sl
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023276:	4606      	mov	r6, r0
 8023278:	460f      	mov	r7, r1
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 802327a:	465b      	mov	r3, fp
 802327c:	ec51 0b19 	vmov	r0, r1, d9
 8023280:	f004 fe12 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
 8023284:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 8023288:	ec53 2b18 	vmov	r2, r3, d8
 802328c:	4606      	mov	r6, r0
 802328e:	460f      	mov	r7, r1
 8023290:	4640      	mov	r0, r8
 8023292:	4649      	mov	r1, r9
 8023294:	f004 fe08 	bl	8027ea8 <__aeabi_dmul>
 8023298:	4602      	mov	r2, r0
 802329a:	460b      	mov	r3, r1
 802329c:	4630      	mov	r0, r6
 802329e:	4639      	mov	r1, r7
 80232a0:	f004 fc4c 	bl	8027b3c <__adddf3>
 80232a4:	460b      	mov	r3, r1
 80232a6:	4602      	mov	r2, r0
 80232a8:	ec51 0b1b 	vmov	r0, r1, d11
 80232ac:	f004 fc46 	bl	8027b3c <__adddf3>
          for (k = 0; k < j; k++) {
 80232b0:	9b01      	ldr	r3, [sp, #4]
 80232b2:	3410      	adds	r4, #16
 80232b4:	42a3      	cmp	r3, r4
            temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
 80232b6:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < j; k++) {
 80232ba:	f105 0510 	add.w	r5, r5, #16
 80232be:	d1a9      	bne.n	8023214 <cblas_ztrmm+0x69c>
          if (nonunit) {
 80232c0:	9b02      	ldr	r3, [sp, #8]
 80232c2:	2b83      	cmp	r3, #131	; 0x83
 80232c4:	f000 818a 	beq.w	80235dc <cblas_ztrmm+0xa64>
            temp_real += REAL(B, i * ldb + j);
 80232c8:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80232ca:	ec51 0b1a 	vmov	r0, r1, d10
 80232ce:	e956 2304 	ldrd	r2, r3, [r6, #-16]
 80232d2:	f004 fc33 	bl	8027b3c <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 80232d6:	e956 2302 	ldrd	r2, r3, [r6, #-8]
            temp_real += REAL(B, i * ldb + j);
 80232da:	4682      	mov	sl, r0
 80232dc:	468b      	mov	fp, r1
            temp_imag += IMAG(B, i * ldb + j);
 80232de:	ec51 0b1b 	vmov	r0, r1, d11
 80232e2:	f004 fc2b 	bl	8027b3c <__adddf3>
 80232e6:	f1a6 0810 	sub.w	r8, r6, #16
 80232ea:	4604      	mov	r4, r0
 80232ec:	460d      	mov	r5, r1
 80232ee:	f1a6 0908 	sub.w	r9, r6, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80232f2:	ec53 2b1f 	vmov	r2, r3, d15
 80232f6:	4650      	mov	r0, sl
 80232f8:	4659      	mov	r1, fp
 80232fa:	f004 fdd5 	bl	8027ea8 <__aeabi_dmul>
 80232fe:	ed9d 8b04 	vldr	d8, [sp, #16]
 8023302:	4606      	mov	r6, r0
 8023304:	ec53 2b18 	vmov	r2, r3, d8
 8023308:	460f      	mov	r7, r1
 802330a:	4620      	mov	r0, r4
 802330c:	4629      	mov	r1, r5
 802330e:	f004 fdcb 	bl	8027ea8 <__aeabi_dmul>
 8023312:	4602      	mov	r2, r0
 8023314:	460b      	mov	r3, r1
 8023316:	4630      	mov	r0, r6
 8023318:	4639      	mov	r1, r7
 802331a:	f004 fc0d 	bl	8027b38 <__aeabi_dsub>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 802331e:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023322:	e9c8 0100 	strd	r0, r1, [r8]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023326:	4620      	mov	r0, r4
 8023328:	4629      	mov	r1, r5
 802332a:	f004 fdbd 	bl	8027ea8 <__aeabi_dmul>
 802332e:	ec53 2b18 	vmov	r2, r3, d8
 8023332:	4604      	mov	r4, r0
 8023334:	460d      	mov	r5, r1
 8023336:	4650      	mov	r0, sl
 8023338:	4659      	mov	r1, fp
 802333a:	f004 fdb5 	bl	8027ea8 <__aeabi_dmul>
 802333e:	4602      	mov	r2, r0
 8023340:	460b      	mov	r3, r1
 8023342:	4620      	mov	r0, r4
 8023344:	4629      	mov	r1, r5
 8023346:	f004 fbf9 	bl	8027b3c <__adddf3>
 802334a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802334c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802334e:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
 8023352:	4614      	mov	r4, r2
 8023354:	441c      	add	r4, r3
 8023356:	9a08      	ldr	r2, [sp, #32]
 8023358:	940a      	str	r4, [sp, #40]	; 0x28
 802335a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 802335c:	4422      	add	r2, r4
 802335e:	9208      	str	r2, [sp, #32]
 8023360:	9a01      	ldr	r2, [sp, #4]
 8023362:	441a      	add	r2, r3
        for (j = n2; j > 0 && j--;) {
 8023364:	9b03      	ldr	r3, [sp, #12]
 8023366:	9201      	str	r2, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023368:	e9c9 0100 	strd	r0, r1, [r9]
        for (j = n2; j > 0 && j--;) {
 802336c:	2b00      	cmp	r3, #0
 802336e:	f47f af3a 	bne.w	80231e6 <cblas_ztrmm+0x66e>
      for (i = 0; i < n1; i++) {
 8023372:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023374:	9911      	ldr	r1, [sp, #68]	; 0x44
 8023376:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8023378:	440a      	add	r2, r1
 802337a:	920b      	str	r2, [sp, #44]	; 0x2c
 802337c:	9a07      	ldr	r2, [sp, #28]
 802337e:	3301      	adds	r3, #1
 8023380:	429a      	cmp	r2, r3
 8023382:	930e      	str	r3, [sp, #56]	; 0x38
 8023384:	f47f af20 	bne.w	80231c8 <cblas_ztrmm+0x650>
 8023388:	e590      	b.n	8022eac <cblas_ztrmm+0x334>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 802338a:	9a07      	ldr	r2, [sp, #28]
 802338c:	990c      	ldr	r1, [sp, #48]	; 0x30
 802338e:	2a01      	cmp	r2, #1
 8023390:	bfb8      	it	lt
 8023392:	2201      	movlt	r2, #1
 8023394:	428a      	cmp	r2, r1
 8023396:	f340 8113 	ble.w	80235c0 <cblas_ztrmm+0xa48>
 802339a:	230c      	movs	r3, #12
 802339c:	e594      	b.n	8022ec8 <cblas_ztrmm+0x350>
 802339e:	bf00      	nop
	...
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 80233a8:	2e6f      	cmp	r6, #111	; 0x6f
 80233aa:	f000 825b 	beq.w	8023864 <cblas_ztrmm+0xcec>
      for (i = n1; i > 0 && i--;) {
 80233ae:	9807      	ldr	r0, [sp, #28]
 80233b0:	2800      	cmp	r0, #0
 80233b2:	f77f ad7b 	ble.w	8022eac <cblas_ztrmm+0x334>
 80233b6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80233b8:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80233ba:	9f10      	ldr	r7, [sp, #64]	; 0x40
 80233bc:	1e42      	subs	r2, r0, #1
 80233be:	0119      	lsls	r1, r3, #4
 80233c0:	fb02 6601 	mla	r6, r2, r1, r6
 80233c4:	ebc3 7503 	rsb	r5, r3, r3, lsl #28
 80233c8:	9101      	str	r1, [sp, #4]
 80233ca:	1c63      	adds	r3, r4, #1
 80233cc:	eb07 1100 	add.w	r1, r7, r0, lsl #4
 80233d0:	012d      	lsls	r5, r5, #4
 80233d2:	011b      	lsls	r3, r3, #4
 80233d4:	910b      	str	r1, [sp, #44]	; 0x2c
 80233d6:	f106 0108 	add.w	r1, r6, #8
 80233da:	9208      	str	r2, [sp, #32]
 80233dc:	43e4      	mvns	r4, r4
 80233de:	910d      	str	r1, [sp, #52]	; 0x34
 80233e0:	fb02 f105 	mul.w	r1, r2, r5
 80233e4:	fb02 7203 	mla	r2, r2, r3, r7
 80233e8:	3b10      	subs	r3, #16
 80233ea:	9303      	str	r3, [sp, #12]
 80233ec:	0123      	lsls	r3, r4, #4
 80233ee:	950f      	str	r5, [sp, #60]	; 0x3c
 80233f0:	910a      	str	r1, [sp, #40]	; 0x28
 80233f2:	920c      	str	r2, [sp, #48]	; 0x30
 80233f4:	930e      	str	r3, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 80233f6:	9b06      	ldr	r3, [sp, #24]
 80233f8:	2b00      	cmp	r3, #0
 80233fa:	f340 80c6 	ble.w	802358a <cblas_ztrmm+0xa12>
 80233fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023400:	9307      	str	r3, [sp, #28]
 8023402:	2300      	movs	r3, #0
 8023404:	9309      	str	r3, [sp, #36]	; 0x24
          for (k = 0; k < i; k++) {
 8023406:	9b08      	ldr	r3, [sp, #32]
 8023408:	2b00      	cmp	r3, #0
 802340a:	f000 81dc 	beq.w	80237c6 <cblas_ztrmm+0xc4e>
 802340e:	ee1d 0a10 	vmov	r0, s26
 8023412:	f004 fcdf 	bl	8027dd4 <__aeabi_i2d>
 8023416:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023418:	9a07      	ldr	r2, [sp, #28]
 802341a:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 802341c:	f8dd b020 	ldr.w	fp, [sp, #32]
          BASE temp_imag = 0.0;
 8023420:	ed1f 7b21 	vldr	d7, [pc, #-132]	; 80233a0 <cblas_ztrmm+0x828>
 8023424:	eb03 0a02 	add.w	sl, r3, r2
 8023428:	ec41 0b1e 	vmov	d14, r0, r1
 802342c:	eeb0 ca47 	vmov.f32	s24, s14
 8023430:	eef0 ca67 	vmov.f32	s25, s15
          for (k = 0; k < i; k++) {
 8023434:	2300      	movs	r3, #0
 8023436:	461d      	mov	r5, r3
          BASE temp_real = 0.0;
 8023438:	eeb0 ba47 	vmov.f32	s22, s14
 802343c:	eef0 ba67 	vmov.f32	s23, s15
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8023440:	e954 2302 	ldrd	r2, r3, [r4, #-8]
 8023444:	ec51 0b1e 	vmov	r0, r1, d14
 8023448:	f004 fd2e 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 802344c:	ed14 7b04 	vldr	d7, [r4, #-16]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023450:	ed1a 6b02 	vldr	d6, [sl, #-8]
            const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8023454:	eeb0 aa47 	vmov.f32	s20, s14
 8023458:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 802345c:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023460:	eeb0 9a46 	vmov.f32	s18, s12
 8023464:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8023468:	4680      	mov	r8, r0
 802346a:	4689      	mov	r9, r1
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 802346c:	ec51 0b17 	vmov	r0, r1, d7
 8023470:	f004 fd1a 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8023474:	ed9a 8b00 	vldr	d8, [sl]
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 8023478:	4606      	mov	r6, r0
 802347a:	ec53 2b18 	vmov	r2, r3, d8
 802347e:	460f      	mov	r7, r1
 8023480:	4640      	mov	r0, r8
 8023482:	4649      	mov	r1, r9
 8023484:	f004 fd10 	bl	8027ea8 <__aeabi_dmul>
 8023488:	4602      	mov	r2, r0
 802348a:	460b      	mov	r3, r1
 802348c:	4630      	mov	r0, r6
 802348e:	4639      	mov	r1, r7
 8023490:	f004 fb52 	bl	8027b38 <__aeabi_dsub>
 8023494:	4602      	mov	r2, r0
 8023496:	460b      	mov	r3, r1
 8023498:	ec51 0b1b 	vmov	r0, r1, d11
 802349c:	f004 fb4e 	bl	8027b3c <__adddf3>
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 80234a0:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 80234a4:	4606      	mov	r6, r0
 80234a6:	460f      	mov	r7, r1
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 80234a8:	ec51 0b1a 	vmov	r0, r1, d10
 80234ac:	f004 fcfc 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
 80234b0:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 80234b4:	ec53 2b19 	vmov	r2, r3, d9
 80234b8:	4606      	mov	r6, r0
 80234ba:	460f      	mov	r7, r1
 80234bc:	4640      	mov	r0, r8
 80234be:	4649      	mov	r1, r9
 80234c0:	f004 fcf2 	bl	8027ea8 <__aeabi_dmul>
 80234c4:	4602      	mov	r2, r0
 80234c6:	460b      	mov	r3, r1
 80234c8:	4630      	mov	r0, r6
 80234ca:	4639      	mov	r1, r7
 80234cc:	f004 fb36 	bl	8027b3c <__adddf3>
 80234d0:	460b      	mov	r3, r1
 80234d2:	4602      	mov	r2, r0
 80234d4:	ec51 0b1c 	vmov	r0, r1, d12
 80234d8:	f004 fb30 	bl	8027b3c <__adddf3>
 80234dc:	9b03      	ldr	r3, [sp, #12]
          for (k = 0; k < i; k++) {
 80234de:	3501      	adds	r5, #1
 80234e0:	441c      	add	r4, r3
 80234e2:	9b01      	ldr	r3, [sp, #4]
 80234e4:	45ab      	cmp	fp, r5
            temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
 80234e6:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < i; k++) {
 80234ea:	449a      	add	sl, r3
 80234ec:	d1a8      	bne.n	8023440 <cblas_ztrmm+0x8c8>
          if (nonunit) {
 80234ee:	9b02      	ldr	r3, [sp, #8]
 80234f0:	2b83      	cmp	r3, #131	; 0x83
 80234f2:	f000 80c5 	beq.w	8023680 <cblas_ztrmm+0xb08>
            temp_real += REAL(B, i * ldb + j);
 80234f6:	9e07      	ldr	r6, [sp, #28]
 80234f8:	ec51 0b1b 	vmov	r0, r1, d11
 80234fc:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 8023500:	f004 fb1c 	bl	8027b3c <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 8023504:	e9d6 2300 	ldrd	r2, r3, [r6]
            temp_real += REAL(B, i * ldb + j);
 8023508:	4680      	mov	r8, r0
 802350a:	4689      	mov	r9, r1
            temp_imag += IMAG(B, i * ldb + j);
 802350c:	ec51 0b1c 	vmov	r0, r1, d12
 8023510:	f004 fb14 	bl	8027b3c <__adddf3>
 8023514:	f1a6 0a08 	sub.w	sl, r6, #8
 8023518:	4604      	mov	r4, r0
 802351a:	460d      	mov	r5, r1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 802351c:	ec53 2b1f 	vmov	r2, r3, d15
 8023520:	4640      	mov	r0, r8
 8023522:	4649      	mov	r1, r9
 8023524:	f004 fcc0 	bl	8027ea8 <__aeabi_dmul>
 8023528:	ed9d 8b04 	vldr	d8, [sp, #16]
 802352c:	4606      	mov	r6, r0
 802352e:	ec53 2b18 	vmov	r2, r3, d8
 8023532:	460f      	mov	r7, r1
 8023534:	4620      	mov	r0, r4
 8023536:	4629      	mov	r1, r5
 8023538:	f004 fcb6 	bl	8027ea8 <__aeabi_dmul>
 802353c:	4602      	mov	r2, r0
 802353e:	460b      	mov	r3, r1
 8023540:	4630      	mov	r0, r6
 8023542:	4639      	mov	r1, r7
 8023544:	f004 faf8 	bl	8027b38 <__aeabi_dsub>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023548:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 802354c:	e9ca 0100 	strd	r0, r1, [sl]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023550:	4620      	mov	r0, r4
 8023552:	4629      	mov	r1, r5
 8023554:	f004 fca8 	bl	8027ea8 <__aeabi_dmul>
 8023558:	ec53 2b18 	vmov	r2, r3, d8
 802355c:	4604      	mov	r4, r0
 802355e:	460d      	mov	r5, r1
 8023560:	4640      	mov	r0, r8
 8023562:	4649      	mov	r1, r9
 8023564:	f004 fca0 	bl	8027ea8 <__aeabi_dmul>
 8023568:	4602      	mov	r2, r0
 802356a:	460b      	mov	r3, r1
 802356c:	4620      	mov	r0, r4
 802356e:	4629      	mov	r1, r5
 8023570:	f004 fae4 	bl	8027b3c <__adddf3>
 8023574:	9a07      	ldr	r2, [sp, #28]
        for (j = 0; j < n2; j++) {
 8023576:	9b09      	ldr	r3, [sp, #36]	; 0x24
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023578:	e8e2 0104 	strd	r0, r1, [r2], #16
 802357c:	9207      	str	r2, [sp, #28]
        for (j = 0; j < n2; j++) {
 802357e:	9a06      	ldr	r2, [sp, #24]
 8023580:	3301      	adds	r3, #1
 8023582:	429a      	cmp	r2, r3
 8023584:	9309      	str	r3, [sp, #36]	; 0x24
 8023586:	f47f af3e 	bne.w	8023406 <cblas_ztrmm+0x88e>
      for (i = n1; i > 0 && i--;) {
 802358a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802358c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802358e:	4413      	add	r3, r2
 8023590:	930c      	str	r3, [sp, #48]	; 0x30
 8023592:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8023594:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023596:	4413      	add	r3, r2
 8023598:	930d      	str	r3, [sp, #52]	; 0x34
 802359a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802359c:	9a01      	ldr	r2, [sp, #4]
 802359e:	3b10      	subs	r3, #16
 80235a0:	930b      	str	r3, [sp, #44]	; 0x2c
 80235a2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80235a4:	4413      	add	r3, r2
 80235a6:	930a      	str	r3, [sp, #40]	; 0x28
 80235a8:	9b08      	ldr	r3, [sp, #32]
 80235aa:	2b00      	cmp	r3, #0
 80235ac:	f43f ac7e 	beq.w	8022eac <cblas_ztrmm+0x334>
 80235b0:	3b01      	subs	r3, #1
 80235b2:	9308      	str	r3, [sp, #32]
 80235b4:	e71f      	b.n	80233f6 <cblas_ztrmm+0x87e>
 80235b6:	9a06      	ldr	r2, [sp, #24]
 80235b8:	e9cd 3206 	strd	r3, r2, [sp, #24]
 80235bc:	f7ff bb49 	b.w	8022c52 <cblas_ztrmm+0xda>
  CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80235c0:	2b00      	cmp	r3, #0
 80235c2:	f43f ac86 	beq.w	8022ed2 <cblas_ztrmm+0x35a>
 80235c6:	e47f      	b.n	8022ec8 <cblas_ztrmm+0x350>
 80235c8:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 80235cc:	2b01      	cmp	r3, #1
 80235ce:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80235d2:	bf94      	ite	ls
 80235d4:	2300      	movls	r3, #0
 80235d6:	2301      	movhi	r3, #1
 80235d8:	f7ff baf4 	b.w	8022bc4 <cblas_ztrmm+0x4c>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80235dc:	ee1d 0a10 	vmov	r0, s26
 80235e0:	f004 fbf8 	bl	8027dd4 <__aeabi_i2d>
 80235e4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80235e6:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80235ea:	f004 fc5d 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 80235ee:	e9d6 8900 	ldrd	r8, r9, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 80235f2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80235f4:	ed16 7b04 	vldr	d7, [r6, #-16]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 80235f8:	4604      	mov	r4, r0
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80235fa:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 80235fe:	eeb0 9a47 	vmov.f32	s18, s14
 8023602:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023606:	460d      	mov	r5, r1
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023608:	4640      	mov	r0, r8
 802360a:	4649      	mov	r1, r9
 802360c:	f004 fc4c 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8023610:	e956 6702 	ldrd	r6, r7, [r6, #-8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023614:	ec45 4b18 	vmov	d8, r4, r5
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023618:	4632      	mov	r2, r6
 802361a:	4604      	mov	r4, r0
 802361c:	460d      	mov	r5, r1
 802361e:	463b      	mov	r3, r7
 8023620:	ec51 0b18 	vmov	r0, r1, d8
 8023624:	f004 fc40 	bl	8027ea8 <__aeabi_dmul>
 8023628:	4602      	mov	r2, r0
 802362a:	460b      	mov	r3, r1
 802362c:	4620      	mov	r0, r4
 802362e:	4629      	mov	r1, r5
 8023630:	f004 fa82 	bl	8027b38 <__aeabi_dsub>
 8023634:	ec53 2b1a 	vmov	r2, r3, d10
 8023638:	f004 fa80 	bl	8027b3c <__adddf3>
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 802363c:	4632      	mov	r2, r6
 802363e:	463b      	mov	r3, r7
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023640:	4682      	mov	sl, r0
 8023642:	468b      	mov	fp, r1
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8023644:	4640      	mov	r0, r8
 8023646:	4649      	mov	r1, r9
 8023648:	f004 fc2e 	bl	8027ea8 <__aeabi_dmul>
 802364c:	ec53 2b19 	vmov	r2, r3, d9
 8023650:	4604      	mov	r4, r0
 8023652:	460d      	mov	r5, r1
 8023654:	ec51 0b18 	vmov	r0, r1, d8
 8023658:	f004 fc26 	bl	8027ea8 <__aeabi_dmul>
 802365c:	4602      	mov	r2, r0
 802365e:	460b      	mov	r3, r1
 8023660:	4620      	mov	r0, r4
 8023662:	4629      	mov	r1, r5
 8023664:	f004 fa6a 	bl	8027b3c <__adddf3>
 8023668:	ec53 2b1b 	vmov	r2, r3, d11
 802366c:	f004 fa66 	bl	8027b3c <__adddf3>
 8023670:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8023672:	4604      	mov	r4, r0
 8023674:	f1a6 0810 	sub.w	r8, r6, #16
 8023678:	460d      	mov	r5, r1
 802367a:	f1a6 0908 	sub.w	r9, r6, #8
 802367e:	e638      	b.n	80232f2 <cblas_ztrmm+0x77a>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023680:	ee1d 0a10 	vmov	r0, s26
 8023684:	f004 fba6 	bl	8027dd4 <__aeabi_i2d>
 8023688:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 802368a:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 802368e:	f004 fc0b 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8023692:	e9d6 ab00 	ldrd	sl, fp, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023696:	9e07      	ldr	r6, [sp, #28]
 8023698:	ed16 7b02 	vldr	d7, [r6, #-8]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802369c:	4604      	mov	r4, r0
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 802369e:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 80236a2:	eeb0 9a47 	vmov.f32	s18, s14
 80236a6:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80236aa:	460d      	mov	r5, r1
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80236ac:	4650      	mov	r0, sl
 80236ae:	4659      	mov	r1, fp
 80236b0:	f004 fbfa 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 80236b4:	e9d6 6700 	ldrd	r6, r7, [r6]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 80236b8:	ec45 4b18 	vmov	d8, r4, r5
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80236bc:	4632      	mov	r2, r6
 80236be:	4604      	mov	r4, r0
 80236c0:	460d      	mov	r5, r1
 80236c2:	463b      	mov	r3, r7
 80236c4:	ec51 0b18 	vmov	r0, r1, d8
 80236c8:	f004 fbee 	bl	8027ea8 <__aeabi_dmul>
 80236cc:	4602      	mov	r2, r0
 80236ce:	460b      	mov	r3, r1
 80236d0:	4620      	mov	r0, r4
 80236d2:	4629      	mov	r1, r5
 80236d4:	f004 fa30 	bl	8027b38 <__aeabi_dsub>
 80236d8:	ec53 2b1b 	vmov	r2, r3, d11
 80236dc:	f004 fa2e 	bl	8027b3c <__adddf3>
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80236e0:	4632      	mov	r2, r6
 80236e2:	463b      	mov	r3, r7
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 80236e4:	4680      	mov	r8, r0
 80236e6:	4689      	mov	r9, r1
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 80236e8:	4650      	mov	r0, sl
 80236ea:	4659      	mov	r1, fp
 80236ec:	f004 fbdc 	bl	8027ea8 <__aeabi_dmul>
 80236f0:	ec53 2b19 	vmov	r2, r3, d9
 80236f4:	4604      	mov	r4, r0
 80236f6:	460d      	mov	r5, r1
 80236f8:	ec51 0b18 	vmov	r0, r1, d8
 80236fc:	f004 fbd4 	bl	8027ea8 <__aeabi_dmul>
 8023700:	4602      	mov	r2, r0
 8023702:	460b      	mov	r3, r1
 8023704:	4620      	mov	r0, r4
 8023706:	4629      	mov	r1, r5
 8023708:	f004 fa18 	bl	8027b3c <__adddf3>
 802370c:	ec53 2b1c 	vmov	r2, r3, d12
 8023710:	f004 fa14 	bl	8027b3c <__adddf3>
 8023714:	9e07      	ldr	r6, [sp, #28]
 8023716:	4604      	mov	r4, r0
 8023718:	f1a6 0a08 	sub.w	sl, r6, #8
 802371c:	460d      	mov	r5, r1
 802371e:	e6fd      	b.n	802351c <cblas_ztrmm+0x9a4>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023720:	ee1d 0a10 	vmov	r0, s26
 8023724:	f004 fb56 	bl	8027dd4 <__aeabi_i2d>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023728:	9c08      	ldr	r4, [sp, #32]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802372a:	9e10      	ldr	r6, [sp, #64]	; 0x40
            const BASE Bij_real = REAL(B, i * ldb + j);
 802372c:	4625      	mov	r5, r4
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802372e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8023732:	f004 fbb9 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023736:	ecb5 7b02 	vldmia	r5!, {d7}
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 802373a:	e9d6 8900 	ldrd	r8, r9, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 802373e:	eeb0 8a47 	vmov.f32	s16, s14
 8023742:	eef0 8a67 	vmov.f32	s17, s15
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023746:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 802374a:	4682      	mov	sl, r0
 802374c:	468b      	mov	fp, r1
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 802374e:	4640      	mov	r0, r8
 8023750:	4649      	mov	r1, r9
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8023752:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023756:	950a      	str	r5, [sp, #40]	; 0x28
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023758:	f004 fba6 	bl	8027ea8 <__aeabi_dmul>
 802375c:	4632      	mov	r2, r6
 802375e:	4604      	mov	r4, r0
 8023760:	460d      	mov	r5, r1
 8023762:	463b      	mov	r3, r7
 8023764:	4650      	mov	r0, sl
 8023766:	4659      	mov	r1, fp
 8023768:	f004 fb9e 	bl	8027ea8 <__aeabi_dmul>
 802376c:	4602      	mov	r2, r0
 802376e:	460b      	mov	r3, r1
 8023770:	4620      	mov	r0, r4
 8023772:	4629      	mov	r1, r5
 8023774:	f004 f9e0 	bl	8027b38 <__aeabi_dsub>
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8023778:	4632      	mov	r2, r6
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 802377a:	4604      	mov	r4, r0
 802377c:	460d      	mov	r5, r1
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 802377e:	463b      	mov	r3, r7
 8023780:	4640      	mov	r0, r8
 8023782:	4649      	mov	r1, r9
 8023784:	f004 fb90 	bl	8027ea8 <__aeabi_dmul>
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023788:	ec45 4b1b 	vmov	d11, r4, r5
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 802378c:	ec53 2b18 	vmov	r2, r3, d8
 8023790:	4604      	mov	r4, r0
 8023792:	460d      	mov	r5, r1
 8023794:	4650      	mov	r0, sl
 8023796:	4659      	mov	r1, fp
 8023798:	f004 fb86 	bl	8027ea8 <__aeabi_dmul>
 802379c:	4602      	mov	r2, r0
 802379e:	460b      	mov	r3, r1
 80237a0:	4620      	mov	r0, r4
 80237a2:	4629      	mov	r1, r5
 80237a4:	f004 f9ca 	bl	8027b3c <__adddf3>
 80237a8:	ec41 0b1c 	vmov	d12, r0, r1
 80237ac:	f7ff babf 	b.w	8022d2e <cblas_ztrmm+0x1b6>
          BASE temp_imag = 0.0;
 80237b0:	ed9f 7bcf 	vldr	d7, [pc, #828]	; 8023af0 <cblas_ztrmm+0xf78>
 80237b4:	eeb0 ba47 	vmov.f32	s22, s14
 80237b8:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 80237bc:	eeb0 aa47 	vmov.f32	s20, s14
 80237c0:	eef0 aa67 	vmov.f32	s21, s15
 80237c4:	e57c      	b.n	80232c0 <cblas_ztrmm+0x748>
          BASE temp_imag = 0.0;
 80237c6:	ed9f 7bca 	vldr	d7, [pc, #808]	; 8023af0 <cblas_ztrmm+0xf78>
 80237ca:	eeb0 ca47 	vmov.f32	s24, s14
 80237ce:	eef0 ca67 	vmov.f32	s25, s15
          BASE temp_real = 0.0;
 80237d2:	eeb0 ba47 	vmov.f32	s22, s14
 80237d6:	eef0 ba67 	vmov.f32	s23, s15
 80237da:	e688      	b.n	80234ee <cblas_ztrmm+0x976>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80237dc:	ec53 2b1f 	vmov	r2, r3, d15
 80237e0:	ec51 0b1a 	vmov	r0, r1, d10
 80237e4:	f004 fb60 	bl	8027ea8 <__aeabi_dmul>
 80237e8:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 80237ec:	ec58 7b1b 	vmov	r7, r8, d11
 80237f0:	4604      	mov	r4, r0
 80237f2:	460d      	mov	r5, r1
 80237f4:	464a      	mov	r2, r9
 80237f6:	4653      	mov	r3, sl
 80237f8:	ee1b 0a10 	vmov	r0, s22
 80237fc:	4641      	mov	r1, r8
 80237fe:	f004 fb53 	bl	8027ea8 <__aeabi_dmul>
 8023802:	4602      	mov	r2, r0
 8023804:	460b      	mov	r3, r1
 8023806:	4620      	mov	r0, r4
 8023808:	4629      	mov	r1, r5
 802380a:	f004 f995 	bl	8027b38 <__aeabi_dsub>
 802380e:	9e12      	ldr	r6, [sp, #72]	; 0x48
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023810:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023812:	e946 0104 	strd	r0, r1, [r6, #-16]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023816:	4653      	mov	r3, sl
 8023818:	ec51 0b1a 	vmov	r0, r1, d10
 802381c:	f004 fb44 	bl	8027ea8 <__aeabi_dmul>
 8023820:	ec53 2b1f 	vmov	r2, r3, d15
 8023824:	4604      	mov	r4, r0
 8023826:	460d      	mov	r5, r1
 8023828:	ee1b 0a10 	vmov	r0, s22
 802382c:	4641      	mov	r1, r8
 802382e:	f004 fb3b 	bl	8027ea8 <__aeabi_dmul>
 8023832:	4602      	mov	r2, r0
 8023834:	460b      	mov	r3, r1
 8023836:	4620      	mov	r0, r4
 8023838:	4629      	mov	r1, r5
 802383a:	f004 f97f 	bl	8027b3c <__adddf3>
 802383e:	e946 0102 	strd	r0, r1, [r6, #-8]
      for (i = 0; i < n1; i++) {
 8023842:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8023844:	9914      	ldr	r1, [sp, #80]	; 0x50
 8023846:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8023848:	440a      	add	r2, r1
 802384a:	9212      	str	r2, [sp, #72]	; 0x48
 802384c:	990c      	ldr	r1, [sp, #48]	; 0x30
 802384e:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8023850:	440a      	add	r2, r1
 8023852:	9211      	str	r2, [sp, #68]	; 0x44
 8023854:	9a07      	ldr	r2, [sp, #28]
 8023856:	3301      	adds	r3, #1
 8023858:	429a      	cmp	r2, r3
 802385a:	9313      	str	r3, [sp, #76]	; 0x4c
 802385c:	f47f ab74 	bne.w	8022f48 <cblas_ztrmm+0x3d0>
 8023860:	f7ff bb24 	b.w	8022eac <cblas_ztrmm+0x334>
      for (i = 0; i < n1; i++) {
 8023864:	9a07      	ldr	r2, [sp, #28]
 8023866:	2a00      	cmp	r2, #0
 8023868:	f77f ab20 	ble.w	8022eac <cblas_ztrmm+0x334>
 802386c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802386e:	9309      	str	r3, [sp, #36]	; 0x24
 8023870:	3b10      	subs	r3, #16
 8023872:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8023876:	930b      	str	r3, [sp, #44]	; 0x2c
 8023878:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802387a:	9311      	str	r3, [sp, #68]	; 0x44
 802387c:	3401      	adds	r4, #1
 802387e:	0121      	lsls	r1, r4, #4
 8023880:	011a      	lsls	r2, r3, #4
 8023882:	2300      	movs	r3, #0
 8023884:	9114      	str	r1, [sp, #80]	; 0x50
 8023886:	9310      	str	r3, [sp, #64]	; 0x40
 8023888:	3910      	subs	r1, #16
 802388a:	2301      	movs	r3, #1
 802388c:	9113      	str	r1, [sp, #76]	; 0x4c
 802388e:	920e      	str	r2, [sp, #56]	; 0x38
 8023890:	930a      	str	r3, [sp, #40]	; 0x28
        for (j = 0; j < n2; j++) {
 8023892:	9b06      	ldr	r3, [sp, #24]
 8023894:	2b00      	cmp	r3, #0
 8023896:	f340 829f 	ble.w	8023dd8 <cblas_ztrmm+0x1260>
 802389a:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
 802389e:	1a9b      	subs	r3, r3, r2
 80238a0:	011b      	lsls	r3, r3, #4
 80238a2:	3308      	adds	r3, #8
 80238a4:	930d      	str	r3, [sp, #52]	; 0x34
 80238a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80238a8:	9312      	str	r3, [sp, #72]	; 0x48
 80238aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80238ac:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80238b0:	9301      	str	r3, [sp, #4]
 80238b2:	2300      	movs	r3, #0
 80238b4:	9303      	str	r3, [sp, #12]
          if (nonunit) {
 80238b6:	9b02      	ldr	r3, [sp, #8]
 80238b8:	2b83      	cmp	r3, #131	; 0x83
 80238ba:	f000 80d1 	beq.w	8023a60 <cblas_ztrmm+0xee8>
            temp_real = REAL(B, i * ldb + j);
 80238be:	9b01      	ldr	r3, [sp, #4]
 80238c0:	461a      	mov	r2, r3
 80238c2:	ecb2 7b02 	vldmia	r2!, {d7}
 80238c6:	eeb0 ba47 	vmov.f32	s22, s14
 80238ca:	eef0 ba67 	vmov.f32	s23, s15
            temp_imag = IMAG(B, i * ldb + j);
 80238ce:	ed93 7b02 	vldr	d7, [r3, #8]
            temp_real = REAL(B, i * ldb + j);
 80238d2:	9208      	str	r2, [sp, #32]
            temp_imag = IMAG(B, i * ldb + j);
 80238d4:	eeb0 ca47 	vmov.f32	s24, s14
 80238d8:	eef0 ca67 	vmov.f32	s25, s15
          for (k = i + 1; k < n1; k++) {
 80238dc:	9b07      	ldr	r3, [sp, #28]
 80238de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80238e0:	4293      	cmp	r3, r2
 80238e2:	dd63      	ble.n	80239ac <cblas_ztrmm+0xe34>
 80238e4:	ee1d 0a10 	vmov	r0, s26
 80238e8:	f004 fa74 	bl	8027dd4 <__aeabi_i2d>
 80238ec:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80238ee:	9a01      	ldr	r2, [sp, #4]
 80238f0:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 80238f4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80238f6:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
 80238fa:	4413      	add	r3, r2
 80238fc:	ec41 0b1e 	vmov	d14, r0, r1
 8023900:	461c      	mov	r4, r3
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8023902:	e9da 2306 	ldrd	r2, r3, [sl, #24]
 8023906:	ec51 0b1e 	vmov	r0, r1, d14
 802390a:	f004 facd 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802390e:	ed9a 7b04 	vldr	d7, [sl, #16]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023912:	ed14 6b02 	vldr	d6, [r4, #-8]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8023916:	eeb0 aa47 	vmov.f32	s20, s14
 802391a:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 802391e:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023922:	eeb0 9a46 	vmov.f32	s18, s12
 8023926:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 802392a:	4680      	mov	r8, r0
 802392c:	4689      	mov	r9, r1
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 802392e:	ec51 0b17 	vmov	r0, r1, d7
 8023932:	f004 fab9 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8023936:	ed94 8b00 	vldr	d8, [r4]
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 802393a:	4606      	mov	r6, r0
 802393c:	ec53 2b18 	vmov	r2, r3, d8
 8023940:	460f      	mov	r7, r1
 8023942:	4640      	mov	r0, r8
 8023944:	4649      	mov	r1, r9
 8023946:	f004 faaf 	bl	8027ea8 <__aeabi_dmul>
 802394a:	4602      	mov	r2, r0
 802394c:	460b      	mov	r3, r1
 802394e:	4630      	mov	r0, r6
 8023950:	4639      	mov	r1, r7
 8023952:	f004 f8f1 	bl	8027b38 <__aeabi_dsub>
 8023956:	4602      	mov	r2, r0
 8023958:	460b      	mov	r3, r1
 802395a:	ec51 0b1b 	vmov	r0, r1, d11
 802395e:	f004 f8ed 	bl	8027b3c <__adddf3>
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8023962:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023966:	4606      	mov	r6, r0
 8023968:	460f      	mov	r7, r1
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 802396a:	ec51 0b1a 	vmov	r0, r1, d10
 802396e:	f004 fa9b 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023972:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8023976:	ec53 2b19 	vmov	r2, r3, d9
 802397a:	4606      	mov	r6, r0
 802397c:	460f      	mov	r7, r1
 802397e:	4640      	mov	r0, r8
 8023980:	4649      	mov	r1, r9
 8023982:	f004 fa91 	bl	8027ea8 <__aeabi_dmul>
 8023986:	4602      	mov	r2, r0
 8023988:	460b      	mov	r3, r1
 802398a:	4630      	mov	r0, r6
 802398c:	4639      	mov	r1, r7
 802398e:	f004 f8d5 	bl	8027b3c <__adddf3>
 8023992:	4602      	mov	r2, r0
 8023994:	460b      	mov	r3, r1
 8023996:	ec51 0b1c 	vmov	r0, r1, d12
 802399a:	f004 f8cf 	bl	8027b3c <__adddf3>
 802399e:	f10a 0a10 	add.w	sl, sl, #16
          for (k = i + 1; k < n1; k++) {
 80239a2:	4555      	cmp	r5, sl
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 80239a4:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = i + 1; k < n1; k++) {
 80239a8:	445c      	add	r4, fp
 80239aa:	d1aa      	bne.n	8023902 <cblas_ztrmm+0xd8a>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80239ac:	ec5b ab1b 	vmov	sl, fp, d11
 80239b0:	ec53 2b1f 	vmov	r2, r3, d15
 80239b4:	ee1b 0a10 	vmov	r0, s22
 80239b8:	4659      	mov	r1, fp
 80239ba:	f004 fa75 	bl	8027ea8 <__aeabi_dmul>
 80239be:	e9dd 8904 	ldrd	r8, r9, [sp, #16]
 80239c2:	ec57 6b1c 	vmov	r6, r7, d12
 80239c6:	4604      	mov	r4, r0
 80239c8:	460d      	mov	r5, r1
 80239ca:	4642      	mov	r2, r8
 80239cc:	464b      	mov	r3, r9
 80239ce:	ee1c 0a10 	vmov	r0, s24
 80239d2:	4639      	mov	r1, r7
 80239d4:	f004 fa68 	bl	8027ea8 <__aeabi_dmul>
 80239d8:	4602      	mov	r2, r0
 80239da:	460b      	mov	r3, r1
 80239dc:	4620      	mov	r0, r4
 80239de:	4629      	mov	r1, r5
 80239e0:	f004 f8aa 	bl	8027b38 <__aeabi_dsub>
 80239e4:	9c01      	ldr	r4, [sp, #4]
 80239e6:	e8e4 0104 	strd	r0, r1, [r4], #16
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80239ea:	ec53 2b1f 	vmov	r2, r3, d15
 80239ee:	ee1c 0a10 	vmov	r0, s24
 80239f2:	4639      	mov	r1, r7
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80239f4:	9401      	str	r4, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 80239f6:	f004 fa57 	bl	8027ea8 <__aeabi_dmul>
 80239fa:	4642      	mov	r2, r8
 80239fc:	464b      	mov	r3, r9
 80239fe:	4604      	mov	r4, r0
 8023a00:	460d      	mov	r5, r1
 8023a02:	ee1b 0a10 	vmov	r0, s22
 8023a06:	4659      	mov	r1, fp
 8023a08:	f004 fa4e 	bl	8027ea8 <__aeabi_dmul>
 8023a0c:	4602      	mov	r2, r0
 8023a0e:	460b      	mov	r3, r1
 8023a10:	4620      	mov	r0, r4
 8023a12:	4629      	mov	r1, r5
 8023a14:	f004 f892 	bl	8027b3c <__adddf3>
 8023a18:	9a08      	ldr	r2, [sp, #32]
        for (j = 0; j < n2; j++) {
 8023a1a:	9b03      	ldr	r3, [sp, #12]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023a1c:	e9c2 0100 	strd	r0, r1, [r2]
        for (j = 0; j < n2; j++) {
 8023a20:	9a06      	ldr	r2, [sp, #24]
 8023a22:	3301      	adds	r3, #1
 8023a24:	429a      	cmp	r2, r3
 8023a26:	9303      	str	r3, [sp, #12]
 8023a28:	f47f af45 	bne.w	80238b6 <cblas_ztrmm+0xd3e>
      for (i = 0; i < n1; i++) {
 8023a2c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023a2e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8023a30:	3301      	adds	r3, #1
 8023a32:	930a      	str	r3, [sp, #40]	; 0x28
 8023a34:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8023a36:	4413      	add	r3, r2
 8023a38:	9309      	str	r3, [sp, #36]	; 0x24
 8023a3a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8023a3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8023a3e:	4413      	add	r3, r2
 8023a40:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8023a42:	930b      	str	r3, [sp, #44]	; 0x2c
 8023a44:	4611      	mov	r1, r2
 8023a46:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8023a48:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023a4a:	441a      	add	r2, r3
 8023a4c:	4419      	add	r1, r3
 8023a4e:	9210      	str	r2, [sp, #64]	; 0x40
 8023a50:	9b07      	ldr	r3, [sp, #28]
 8023a52:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8023a54:	9111      	str	r1, [sp, #68]	; 0x44
 8023a56:	4293      	cmp	r3, r2
 8023a58:	f73f af1b 	bgt.w	8023892 <cblas_ztrmm+0xd1a>
 8023a5c:	f7ff ba26 	b.w	8022eac <cblas_ztrmm+0x334>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023a60:	ee1d 0a10 	vmov	r0, s26
 8023a64:	f004 f9b6 	bl	8027dd4 <__aeabi_i2d>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023a68:	9c01      	ldr	r4, [sp, #4]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023a6a:	9e09      	ldr	r6, [sp, #36]	; 0x24
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023a6c:	4625      	mov	r5, r4
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023a6e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8023a72:	f004 fa19 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023a76:	ecb5 7b02 	vldmia	r5!, {d7}
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8023a7a:	e9d6 8900 	ldrd	r8, r9, [r6]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023a7e:	eeb0 8a47 	vmov.f32	s16, s14
 8023a82:	eef0 8a67 	vmov.f32	s17, s15
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023a86:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023a8a:	4682      	mov	sl, r0
 8023a8c:	468b      	mov	fp, r1
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023a8e:	4640      	mov	r0, r8
 8023a90:	4649      	mov	r1, r9
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8023a92:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023a96:	9508      	str	r5, [sp, #32]
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023a98:	f004 fa06 	bl	8027ea8 <__aeabi_dmul>
 8023a9c:	4632      	mov	r2, r6
 8023a9e:	4604      	mov	r4, r0
 8023aa0:	460d      	mov	r5, r1
 8023aa2:	463b      	mov	r3, r7
 8023aa4:	4650      	mov	r0, sl
 8023aa6:	4659      	mov	r1, fp
 8023aa8:	f004 f9fe 	bl	8027ea8 <__aeabi_dmul>
 8023aac:	4602      	mov	r2, r0
 8023aae:	460b      	mov	r3, r1
 8023ab0:	4620      	mov	r0, r4
 8023ab2:	4629      	mov	r1, r5
 8023ab4:	f004 f840 	bl	8027b38 <__aeabi_dsub>
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8023ab8:	4632      	mov	r2, r6
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023aba:	4604      	mov	r4, r0
 8023abc:	460d      	mov	r5, r1
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8023abe:	463b      	mov	r3, r7
 8023ac0:	4640      	mov	r0, r8
 8023ac2:	4649      	mov	r1, r9
 8023ac4:	f004 f9f0 	bl	8027ea8 <__aeabi_dmul>
            temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023ac8:	ec45 4b1b 	vmov	d11, r4, r5
            temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
 8023acc:	ec53 2b18 	vmov	r2, r3, d8
 8023ad0:	4604      	mov	r4, r0
 8023ad2:	460d      	mov	r5, r1
 8023ad4:	4650      	mov	r0, sl
 8023ad6:	4659      	mov	r1, fp
 8023ad8:	f004 f9e6 	bl	8027ea8 <__aeabi_dmul>
 8023adc:	4602      	mov	r2, r0
 8023ade:	460b      	mov	r3, r1
 8023ae0:	4620      	mov	r0, r4
 8023ae2:	4629      	mov	r1, r5
 8023ae4:	f004 f82a 	bl	8027b3c <__adddf3>
 8023ae8:	ec41 0b1c 	vmov	d12, r0, r1
 8023aec:	e6f6      	b.n	80238dc <cblas_ztrmm+0xd64>
 8023aee:	bf00      	nop
	...
      for (i = n1; i > 0 && i--;) {
 8023af8:	9907      	ldr	r1, [sp, #28]
 8023afa:	2900      	cmp	r1, #0
 8023afc:	f77f a9d6 	ble.w	8022eac <cblas_ztrmm+0x334>
 8023b00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023b02:	0117      	lsls	r7, r2, #4
 8023b04:	ebc2 7502 	rsb	r5, r2, r2, lsl #28
 8023b08:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023b0a:	970b      	str	r7, [sp, #44]	; 0x2c
 8023b0c:	1c63      	adds	r3, r4, #1
 8023b0e:	1e4e      	subs	r6, r1, #1
 8023b10:	011b      	lsls	r3, r3, #4
 8023b12:	f1a2 0e10 	sub.w	lr, r2, #16
 8023b16:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023b18:	9608      	str	r6, [sp, #32]
 8023b1a:	f1a3 0010 	sub.w	r0, r3, #16
 8023b1e:	46bc      	mov	ip, r7
 8023b20:	4637      	mov	r7, r6
 8023b22:	012d      	lsls	r5, r5, #4
 8023b24:	fb07 2000 	mla	r0, r7, r0, r2
 8023b28:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023b2a:	950e      	str	r5, [sp, #56]	; 0x38
 8023b2c:	fb07 2203 	mla	r2, r7, r3, r2
 8023b30:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8023b32:	920c      	str	r2, [sp, #48]	; 0x30
 8023b34:	fb04 1106 	mla	r1, r4, r6, r1
 8023b38:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8023b3a:	900a      	str	r0, [sp, #40]	; 0x28
 8023b3c:	43e5      	mvns	r5, r4
 8023b3e:	fb07 f303 	mul.w	r3, r7, r3
 8023b42:	eb0e 1201 	add.w	r2, lr, r1, lsl #4
 8023b46:	fb07 660c 	mla	r6, r7, ip, r6
 8023b4a:	ebc4 7404 	rsb	r4, r4, r4, lsl #28
 8023b4e:	9307      	str	r3, [sp, #28]
 8023b50:	012b      	lsls	r3, r5, #4
 8023b52:	9209      	str	r2, [sp, #36]	; 0x24
 8023b54:	930f      	str	r3, [sp, #60]	; 0x3c
 8023b56:	f106 0208 	add.w	r2, r6, #8
 8023b5a:	0123      	lsls	r3, r4, #4
 8023b5c:	920d      	str	r2, [sp, #52]	; 0x34
 8023b5e:	9310      	str	r3, [sp, #64]	; 0x40
        for (j = 0; j < n2; j++) {
 8023b60:	9b06      	ldr	r3, [sp, #24]
 8023b62:	2b00      	cmp	r3, #0
 8023b64:	f340 80c4 	ble.w	8023cf0 <cblas_ztrmm+0x1178>
 8023b68:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023b6a:	9301      	str	r3, [sp, #4]
 8023b6c:	2300      	movs	r3, #0
 8023b6e:	9303      	str	r3, [sp, #12]
          for (k = 0; k < i; k++) {
 8023b70:	9b08      	ldr	r3, [sp, #32]
 8023b72:	2b00      	cmp	r3, #0
 8023b74:	f000 8125 	beq.w	8023dc2 <cblas_ztrmm+0x124a>
 8023b78:	ee1d 0a10 	vmov	r0, s26
 8023b7c:	f004 f92a 	bl	8027dd4 <__aeabi_i2d>
 8023b80:	9b07      	ldr	r3, [sp, #28]
 8023b82:	9a01      	ldr	r2, [sp, #4]
 8023b84:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
          BASE temp_imag = 0.0;
 8023b88:	ed1f 7b27 	vldr	d7, [pc, #-156]	; 8023af0 <cblas_ztrmm+0xf78>
          for (k = 0; k < i; k++) {
 8023b8c:	e9dd a50a 	ldrd	sl, r5, [sp, #40]	; 0x28
          BASE temp_imag = 0.0;
 8023b90:	eeb0 ca47 	vmov.f32	s24, s14
 8023b94:	eef0 ca67 	vmov.f32	s25, s15
          BASE temp_real = 0.0;
 8023b98:	eeb0 ba47 	vmov.f32	s22, s14
 8023b9c:	eef0 ba67 	vmov.f32	s23, s15
 8023ba0:	4413      	add	r3, r2
 8023ba2:	ec41 0b1e 	vmov	d14, r0, r1
          for (k = 0; k < i; k++) {
 8023ba6:	461c      	mov	r4, r3
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8023ba8:	e9da 2302 	ldrd	r2, r3, [sl, #8]
 8023bac:	ec51 0b1e 	vmov	r0, r1, d14
 8023bb0:	f004 f97a 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8023bb4:	ed9a 7b00 	vldr	d7, [sl]
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023bb8:	ed14 6b02 	vldr	d6, [r4, #-8]
            const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8023bbc:	eeb0 aa47 	vmov.f32	s20, s14
 8023bc0:	eef0 aa67 	vmov.f32	s21, s15
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023bc4:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Bkj_real = REAL(B, k * ldb + j);
 8023bc8:	eeb0 9a46 	vmov.f32	s18, s12
 8023bcc:	eef0 9a66 	vmov.f32	s19, s13
            const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 8023bd0:	4680      	mov	r8, r0
 8023bd2:	4689      	mov	r9, r1
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023bd4:	ec51 0b17 	vmov	r0, r1, d7
 8023bd8:	f004 f966 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bkj_imag = IMAG(B, k * ldb + j);
 8023bdc:	ed94 8b00 	vldr	d8, [r4]
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023be0:	4606      	mov	r6, r0
 8023be2:	ec53 2b18 	vmov	r2, r3, d8
 8023be6:	460f      	mov	r7, r1
 8023be8:	4640      	mov	r0, r8
 8023bea:	4649      	mov	r1, r9
 8023bec:	f004 f95c 	bl	8027ea8 <__aeabi_dmul>
 8023bf0:	4602      	mov	r2, r0
 8023bf2:	460b      	mov	r3, r1
 8023bf4:	4630      	mov	r0, r6
 8023bf6:	4639      	mov	r1, r7
 8023bf8:	f003 ff9e 	bl	8027b38 <__aeabi_dsub>
 8023bfc:	4602      	mov	r2, r0
 8023bfe:	460b      	mov	r3, r1
 8023c00:	ec51 0b1b 	vmov	r0, r1, d11
 8023c04:	f003 ff9a 	bl	8027b3c <__adddf3>
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8023c08:	ec53 2b18 	vmov	r2, r3, d8
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023c0c:	4606      	mov	r6, r0
 8023c0e:	460f      	mov	r7, r1
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8023c10:	ec51 0b1a 	vmov	r0, r1, d10
 8023c14:	f004 f948 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
 8023c18:	ec47 6b1b 	vmov	d11, r6, r7
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8023c1c:	ec53 2b19 	vmov	r2, r3, d9
 8023c20:	4606      	mov	r6, r0
 8023c22:	460f      	mov	r7, r1
 8023c24:	4640      	mov	r0, r8
 8023c26:	4649      	mov	r1, r9
 8023c28:	f004 f93e 	bl	8027ea8 <__aeabi_dmul>
 8023c2c:	4602      	mov	r2, r0
 8023c2e:	460b      	mov	r3, r1
 8023c30:	4630      	mov	r0, r6
 8023c32:	4639      	mov	r1, r7
 8023c34:	f003 ff82 	bl	8027b3c <__adddf3>
 8023c38:	4602      	mov	r2, r0
 8023c3a:	460b      	mov	r3, r1
 8023c3c:	ec51 0b1c 	vmov	r0, r1, d12
 8023c40:	f003 ff7c 	bl	8027b3c <__adddf3>
 8023c44:	f10a 0a10 	add.w	sl, sl, #16
          for (k = 0; k < i; k++) {
 8023c48:	45d3      	cmp	fp, sl
            temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
 8023c4a:	ec41 0b1c 	vmov	d12, r0, r1
          for (k = 0; k < i; k++) {
 8023c4e:	442c      	add	r4, r5
 8023c50:	d1aa      	bne.n	8023ba8 <cblas_ztrmm+0x1030>
          if (nonunit) {
 8023c52:	9b02      	ldr	r3, [sp, #8]
 8023c54:	2b83      	cmp	r3, #131	; 0x83
 8023c56:	d066      	beq.n	8023d26 <cblas_ztrmm+0x11ae>
            temp_real += REAL(B, i * ldb + j);
 8023c58:	9e01      	ldr	r6, [sp, #4]
 8023c5a:	ec51 0b1b 	vmov	r0, r1, d11
 8023c5e:	e956 2302 	ldrd	r2, r3, [r6, #-8]
 8023c62:	f003 ff6b 	bl	8027b3c <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 8023c66:	e9d6 2300 	ldrd	r2, r3, [r6]
            temp_real += REAL(B, i * ldb + j);
 8023c6a:	4604      	mov	r4, r0
 8023c6c:	460d      	mov	r5, r1
            temp_imag += IMAG(B, i * ldb + j);
 8023c6e:	ec51 0b1c 	vmov	r0, r1, d12
 8023c72:	9601      	str	r6, [sp, #4]
 8023c74:	f003 ff62 	bl	8027b3c <__adddf3>
 8023c78:	9b01      	ldr	r3, [sp, #4]
 8023c7a:	4606      	mov	r6, r0
 8023c7c:	460f      	mov	r7, r1
 8023c7e:	f1a3 0a08 	sub.w	sl, r3, #8
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023c82:	ec53 2b1f 	vmov	r2, r3, d15
 8023c86:	4620      	mov	r0, r4
 8023c88:	4629      	mov	r1, r5
 8023c8a:	f004 f90d 	bl	8027ea8 <__aeabi_dmul>
 8023c8e:	ed9d 8b04 	vldr	d8, [sp, #16]
 8023c92:	4680      	mov	r8, r0
 8023c94:	ec53 2b18 	vmov	r2, r3, d8
 8023c98:	4689      	mov	r9, r1
 8023c9a:	4630      	mov	r0, r6
 8023c9c:	4639      	mov	r1, r7
 8023c9e:	f004 f903 	bl	8027ea8 <__aeabi_dmul>
 8023ca2:	4602      	mov	r2, r0
 8023ca4:	460b      	mov	r3, r1
 8023ca6:	4640      	mov	r0, r8
 8023ca8:	4649      	mov	r1, r9
 8023caa:	f003 ff45 	bl	8027b38 <__aeabi_dsub>
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023cae:	ec53 2b1f 	vmov	r2, r3, d15
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023cb2:	e9ca 0100 	strd	r0, r1, [sl]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023cb6:	4630      	mov	r0, r6
 8023cb8:	4639      	mov	r1, r7
 8023cba:	f004 f8f5 	bl	8027ea8 <__aeabi_dmul>
 8023cbe:	ec53 2b18 	vmov	r2, r3, d8
 8023cc2:	4606      	mov	r6, r0
 8023cc4:	460f      	mov	r7, r1
 8023cc6:	4620      	mov	r0, r4
 8023cc8:	4629      	mov	r1, r5
 8023cca:	f004 f8ed 	bl	8027ea8 <__aeabi_dmul>
 8023cce:	4602      	mov	r2, r0
 8023cd0:	460b      	mov	r3, r1
 8023cd2:	4630      	mov	r0, r6
 8023cd4:	4639      	mov	r1, r7
 8023cd6:	f003 ff31 	bl	8027b3c <__adddf3>
 8023cda:	9a01      	ldr	r2, [sp, #4]
        for (j = 0; j < n2; j++) {
 8023cdc:	9b03      	ldr	r3, [sp, #12]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023cde:	e8e2 0104 	strd	r0, r1, [r2], #16
 8023ce2:	9201      	str	r2, [sp, #4]
        for (j = 0; j < n2; j++) {
 8023ce4:	9a06      	ldr	r2, [sp, #24]
 8023ce6:	3301      	adds	r3, #1
 8023ce8:	429a      	cmp	r2, r3
 8023cea:	9303      	str	r3, [sp, #12]
 8023cec:	f47f af40 	bne.w	8023b70 <cblas_ztrmm+0xff8>
      for (i = n1; i > 0 && i--;) {
 8023cf0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023cf2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8023cf4:	4611      	mov	r1, r2
 8023cf6:	4419      	add	r1, r3
 8023cf8:	910c      	str	r1, [sp, #48]	; 0x30
 8023cfa:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
 8023cfe:	440a      	add	r2, r1
 8023d00:	920d      	str	r2, [sp, #52]	; 0x34
 8023d02:	9910      	ldr	r1, [sp, #64]	; 0x40
 8023d04:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8023d06:	440a      	add	r2, r1
 8023d08:	920a      	str	r2, [sp, #40]	; 0x28
 8023d0a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8023d0c:	441a      	add	r2, r3
 8023d0e:	9209      	str	r2, [sp, #36]	; 0x24
 8023d10:	9b07      	ldr	r3, [sp, #28]
 8023d12:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023d14:	4413      	add	r3, r2
 8023d16:	9307      	str	r3, [sp, #28]
 8023d18:	9b08      	ldr	r3, [sp, #32]
 8023d1a:	2b00      	cmp	r3, #0
 8023d1c:	f43f a8c6 	beq.w	8022eac <cblas_ztrmm+0x334>
 8023d20:	3b01      	subs	r3, #1
 8023d22:	9308      	str	r3, [sp, #32]
 8023d24:	e71c      	b.n	8023b60 <cblas_ztrmm+0xfe8>
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023d26:	ee1d 0a10 	vmov	r0, s26
 8023d2a:	f004 f853 	bl	8027dd4 <__aeabi_i2d>
 8023d2e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8023d30:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8023d34:	f004 f8b8 	bl	8027ea8 <__aeabi_dmul>
            const BASE Aii_real = CONST_REAL(A, i * lda + i);
 8023d38:	e9d4 8900 	ldrd	r8, r9, [r4]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023d3c:	9c01      	ldr	r4, [sp, #4]
 8023d3e:	ed14 7b02 	vldr	d7, [r4, #-8]
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023d42:	4682      	mov	sl, r0
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023d44:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023d48:	eeb0 8a47 	vmov.f32	s16, s14
 8023d4c:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
 8023d50:	468b      	mov	fp, r1
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023d52:	4640      	mov	r0, r8
 8023d54:	4649      	mov	r1, r9
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8023d56:	e9d4 6700 	ldrd	r6, r7, [r4]
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023d5a:	f004 f8a5 	bl	8027ea8 <__aeabi_dmul>
 8023d5e:	4632      	mov	r2, r6
 8023d60:	463b      	mov	r3, r7
 8023d62:	4604      	mov	r4, r0
 8023d64:	460d      	mov	r5, r1
 8023d66:	4650      	mov	r0, sl
 8023d68:	4659      	mov	r1, fp
 8023d6a:	f004 f89d 	bl	8027ea8 <__aeabi_dmul>
 8023d6e:	4602      	mov	r2, r0
 8023d70:	460b      	mov	r3, r1
 8023d72:	4620      	mov	r0, r4
 8023d74:	4629      	mov	r1, r5
 8023d76:	f003 fedf 	bl	8027b38 <__aeabi_dsub>
 8023d7a:	ec53 2b1b 	vmov	r2, r3, d11
 8023d7e:	f003 fedd 	bl	8027b3c <__adddf3>
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8023d82:	4632      	mov	r2, r6
 8023d84:	463b      	mov	r3, r7
            temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
 8023d86:	4604      	mov	r4, r0
 8023d88:	460d      	mov	r5, r1
            temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
 8023d8a:	4640      	mov	r0, r8
 8023d8c:	4649      	mov	r1, r9
 8023d8e:	f004 f88b 	bl	8027ea8 <__aeabi_dmul>
 8023d92:	ec53 2b18 	vmov	r2, r3, d8
 8023d96:	4606      	mov	r6, r0
 8023d98:	460f      	mov	r7, r1
 8023d9a:	4650      	mov	r0, sl
 8023d9c:	4659      	mov	r1, fp
 8023d9e:	f004 f883 	bl	8027ea8 <__aeabi_dmul>
 8023da2:	4602      	mov	r2, r0
 8023da4:	460b      	mov	r3, r1
 8023da6:	4630      	mov	r0, r6
 8023da8:	4639      	mov	r1, r7
 8023daa:	f003 fec7 	bl	8027b3c <__adddf3>
 8023dae:	ec53 2b1c 	vmov	r2, r3, d12
 8023db2:	f003 fec3 	bl	8027b3c <__adddf3>
 8023db6:	9b01      	ldr	r3, [sp, #4]
 8023db8:	4606      	mov	r6, r0
 8023dba:	f1a3 0a08 	sub.w	sl, r3, #8
 8023dbe:	460f      	mov	r7, r1
 8023dc0:	e75f      	b.n	8023c82 <cblas_ztrmm+0x110a>
          BASE temp_imag = 0.0;
 8023dc2:	ed1f 7bb5 	vldr	d7, [pc, #-724]	; 8023af0 <cblas_ztrmm+0xf78>
 8023dc6:	eeb0 ca47 	vmov.f32	s24, s14
 8023dca:	eef0 ca67 	vmov.f32	s25, s15
          BASE temp_real = 0.0;
 8023dce:	eeb0 ba47 	vmov.f32	s22, s14
 8023dd2:	eef0 ba67 	vmov.f32	s23, s15
 8023dd6:	e73c      	b.n	8023c52 <cblas_ztrmm+0x10da>
 8023dd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023dda:	9312      	str	r3, [sp, #72]	; 0x48
 8023ddc:	e626      	b.n	8023a2c <cblas_ztrmm+0xeb4>
      for (i = 0; i < n1; i++) {
 8023dde:	2b00      	cmp	r3, #0
 8023de0:	f77f a864 	ble.w	8022eac <cblas_ztrmm+0x334>
 8023de4:	1c63      	adds	r3, r4, #1
 8023de6:	43e4      	mvns	r4, r4
 8023de8:	9a06      	ldr	r2, [sp, #24]
 8023dea:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8023dec:	0124      	lsls	r4, r4, #4
 8023dee:	940c      	str	r4, [sp, #48]	; 0x30
 8023df0:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8023df2:	011b      	lsls	r3, r3, #4
 8023df4:	1e51      	subs	r1, r2, #1
 8023df6:	4610      	mov	r0, r2
 8023df8:	fb03 4101 	mla	r1, r3, r1, r4
 8023dfc:	3b10      	subs	r3, #16
 8023dfe:	012d      	lsls	r5, r5, #4
 8023e00:	0112      	lsls	r2, r2, #4
 8023e02:	9303      	str	r3, [sp, #12]
 8023e04:	eb04 1300 	add.w	r3, r4, r0, lsl #4
 8023e08:	950e      	str	r5, [sp, #56]	; 0x38
 8023e0a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8023e0c:	930f      	str	r3, [sp, #60]	; 0x3c
 8023e0e:	f1a2 0310 	sub.w	r3, r2, #16
 8023e12:	9311      	str	r3, [sp, #68]	; 0x44
 8023e14:	2300      	movs	r3, #0
 8023e16:	950b      	str	r5, [sp, #44]	; 0x2c
 8023e18:	9110      	str	r1, [sp, #64]	; 0x40
 8023e1a:	930d      	str	r3, [sp, #52]	; 0x34
        for (j = n2; j > 0 && j--;) {
 8023e1c:	9b06      	ldr	r3, [sp, #24]
 8023e1e:	2b00      	cmp	r3, #0
 8023e20:	f340 80c6 	ble.w	8023fb0 <cblas_ztrmm+0x1438>
 8023e24:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8023e26:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8023e28:	9308      	str	r3, [sp, #32]
 8023e2a:	440a      	add	r2, r1
 8023e2c:	9201      	str	r2, [sp, #4]
 8023e2e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8023e30:	9209      	str	r2, [sp, #36]	; 0x24
 8023e32:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8023e34:	920a      	str	r2, [sp, #40]	; 0x28
          for (k = 0; k < j; k++) {
 8023e36:	9b08      	ldr	r3, [sp, #32]
 8023e38:	3b01      	subs	r3, #1
 8023e3a:	9308      	str	r3, [sp, #32]
 8023e3c:	f000 8116 	beq.w	802406c <cblas_ztrmm+0x14f4>
 8023e40:	ee1d 0a10 	vmov	r0, s26
 8023e44:	f003 ffc6 	bl	8027dd4 <__aeabi_i2d>
          BASE temp_imag = 0.0;
 8023e48:	ed9f 7b91 	vldr	d7, [pc, #580]	; 8024090 <cblas_ztrmm+0x1518>
 8023e4c:	ec41 0b1c 	vmov	d12, r0, r1
 8023e50:	eeb0 ba47 	vmov.f32	s22, s14
 8023e54:	eef0 ba67 	vmov.f32	s23, s15
          for (k = 0; k < j; k++) {
 8023e58:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 8023e5a:	9d09      	ldr	r5, [sp, #36]	; 0x24
          BASE temp_real = 0.0;
 8023e5c:	eeb0 aa47 	vmov.f32	s20, s14
 8023e60:	eef0 aa67 	vmov.f32	s21, s15
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8023e64:	e955 2302 	ldrd	r2, r3, [r5, #-8]
 8023e68:	ec51 0b1c 	vmov	r0, r1, d12
 8023e6c:	f004 f81c 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023e70:	ed94 6b00 	vldr	d6, [r4]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8023e74:	ed15 7b04 	vldr	d7, [r5, #-16]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8023e78:	eeb0 8a46 	vmov.f32	s16, s12
 8023e7c:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8023e80:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8023e84:	eeb0 9a47 	vmov.f32	s18, s14
 8023e88:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8023e8c:	4680      	mov	r8, r0
 8023e8e:	4689      	mov	r9, r1
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8023e90:	ec51 0b17 	vmov	r0, r1, d7
 8023e94:	f004 f808 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8023e98:	e9d4 ab02 	ldrd	sl, fp, [r4, #8]
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8023e9c:	4606      	mov	r6, r0
 8023e9e:	460f      	mov	r7, r1
 8023ea0:	4652      	mov	r2, sl
 8023ea2:	465b      	mov	r3, fp
 8023ea4:	4640      	mov	r0, r8
 8023ea6:	4649      	mov	r1, r9
 8023ea8:	f003 fffe 	bl	8027ea8 <__aeabi_dmul>
 8023eac:	4602      	mov	r2, r0
 8023eae:	460b      	mov	r3, r1
 8023eb0:	4630      	mov	r0, r6
 8023eb2:	4639      	mov	r1, r7
 8023eb4:	f003 fe40 	bl	8027b38 <__aeabi_dsub>
 8023eb8:	4602      	mov	r2, r0
 8023eba:	460b      	mov	r3, r1
 8023ebc:	ec51 0b1a 	vmov	r0, r1, d10
 8023ec0:	f003 fe3c 	bl	8027b3c <__adddf3>
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8023ec4:	4652      	mov	r2, sl
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8023ec6:	4606      	mov	r6, r0
 8023ec8:	460f      	mov	r7, r1
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8023eca:	465b      	mov	r3, fp
 8023ecc:	ec51 0b19 	vmov	r0, r1, d9
 8023ed0:	f003 ffea 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8023ed4:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8023ed8:	ec53 2b18 	vmov	r2, r3, d8
 8023edc:	4606      	mov	r6, r0
 8023ede:	460f      	mov	r7, r1
 8023ee0:	4640      	mov	r0, r8
 8023ee2:	4649      	mov	r1, r9
 8023ee4:	f003 ffe0 	bl	8027ea8 <__aeabi_dmul>
 8023ee8:	4602      	mov	r2, r0
 8023eea:	460b      	mov	r3, r1
 8023eec:	4630      	mov	r0, r6
 8023eee:	4639      	mov	r1, r7
 8023ef0:	f003 fe24 	bl	8027b3c <__adddf3>
 8023ef4:	460b      	mov	r3, r1
 8023ef6:	4602      	mov	r2, r0
 8023ef8:	ec51 0b1b 	vmov	r0, r1, d11
 8023efc:	f003 fe1e 	bl	8027b3c <__adddf3>
 8023f00:	9b03      	ldr	r3, [sp, #12]
 8023f02:	441d      	add	r5, r3
          for (k = 0; k < j; k++) {
 8023f04:	9b01      	ldr	r3, [sp, #4]
 8023f06:	3410      	adds	r4, #16
 8023f08:	42a3      	cmp	r3, r4
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8023f0a:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = 0; k < j; k++) {
 8023f0e:	d1a9      	bne.n	8023e64 <cblas_ztrmm+0x12ec>
          if (nonunit) {
 8023f10:	9b02      	ldr	r3, [sp, #8]
 8023f12:	2b83      	cmp	r3, #131	; 0x83
 8023f14:	d059      	beq.n	8023fca <cblas_ztrmm+0x1452>
            temp_real += REAL(B, i * ldb + j);
 8023f16:	9c01      	ldr	r4, [sp, #4]
 8023f18:	4626      	mov	r6, r4
 8023f1a:	e8f6 2302 	ldrd	r2, r3, [r6], #8
 8023f1e:	ec51 0b1a 	vmov	r0, r1, d10
 8023f22:	f003 fe0b 	bl	8027b3c <__adddf3>
            temp_imag += IMAG(B, i * ldb + j);
 8023f26:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
            temp_real += REAL(B, i * ldb + j);
 8023f2a:	4682      	mov	sl, r0
 8023f2c:	468b      	mov	fp, r1
            temp_imag += IMAG(B, i * ldb + j);
 8023f2e:	ec51 0b1b 	vmov	r0, r1, d11
 8023f32:	f003 fe03 	bl	8027b3c <__adddf3>
 8023f36:	4604      	mov	r4, r0
 8023f38:	460d      	mov	r5, r1
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023f3a:	ec53 2b1f 	vmov	r2, r3, d15
 8023f3e:	4650      	mov	r0, sl
 8023f40:	4659      	mov	r1, fp
 8023f42:	f003 ffb1 	bl	8027ea8 <__aeabi_dmul>
 8023f46:	ed9d 8b04 	vldr	d8, [sp, #16]
 8023f4a:	4680      	mov	r8, r0
 8023f4c:	ec53 2b18 	vmov	r2, r3, d8
 8023f50:	4689      	mov	r9, r1
 8023f52:	4620      	mov	r0, r4
 8023f54:	4629      	mov	r1, r5
 8023f56:	f003 ffa7 	bl	8027ea8 <__aeabi_dmul>
 8023f5a:	4602      	mov	r2, r0
 8023f5c:	460b      	mov	r3, r1
 8023f5e:	4640      	mov	r0, r8
 8023f60:	4649      	mov	r1, r9
 8023f62:	f003 fde9 	bl	8027b38 <__aeabi_dsub>
 8023f66:	9f01      	ldr	r7, [sp, #4]
 8023f68:	e867 0104 	strd	r0, r1, [r7], #-16
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023f6c:	ec53 2b1f 	vmov	r2, r3, d15
 8023f70:	4620      	mov	r0, r4
 8023f72:	4629      	mov	r1, r5
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8023f74:	9701      	str	r7, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023f76:	f003 ff97 	bl	8027ea8 <__aeabi_dmul>
 8023f7a:	ec53 2b18 	vmov	r2, r3, d8
 8023f7e:	4604      	mov	r4, r0
 8023f80:	460d      	mov	r5, r1
 8023f82:	4650      	mov	r0, sl
 8023f84:	4659      	mov	r1, fp
 8023f86:	f003 ff8f 	bl	8027ea8 <__aeabi_dmul>
 8023f8a:	4602      	mov	r2, r0
 8023f8c:	460b      	mov	r3, r1
 8023f8e:	4620      	mov	r0, r4
 8023f90:	4629      	mov	r1, r5
 8023f92:	f003 fdd3 	bl	8027b3c <__adddf3>
 8023f96:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8023f98:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8023f9a:	4413      	add	r3, r2
 8023f9c:	930a      	str	r3, [sp, #40]	; 0x28
 8023f9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8023fa0:	3b10      	subs	r3, #16
 8023fa2:	9309      	str	r3, [sp, #36]	; 0x24
        for (j = n2; j > 0 && j--;) {
 8023fa4:	9b08      	ldr	r3, [sp, #32]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8023fa6:	e9c6 0100 	strd	r0, r1, [r6]
        for (j = n2; j > 0 && j--;) {
 8023faa:	2b00      	cmp	r3, #0
 8023fac:	f47f af43 	bne.w	8023e36 <cblas_ztrmm+0x12be>
      for (i = 0; i < n1; i++) {
 8023fb0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8023fb2:	990e      	ldr	r1, [sp, #56]	; 0x38
 8023fb4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023fb6:	440a      	add	r2, r1
 8023fb8:	920b      	str	r2, [sp, #44]	; 0x2c
 8023fba:	9a07      	ldr	r2, [sp, #28]
 8023fbc:	3301      	adds	r3, #1
 8023fbe:	429a      	cmp	r2, r3
 8023fc0:	930d      	str	r3, [sp, #52]	; 0x34
 8023fc2:	f47f af2b 	bne.w	8023e1c <cblas_ztrmm+0x12a4>
 8023fc6:	f7fe bf71 	b.w	8022eac <cblas_ztrmm+0x334>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023fca:	ee1d 0a10 	vmov	r0, s26
 8023fce:	f003 ff01 	bl	8027dd4 <__aeabi_i2d>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023fd2:	f8dd 8004 	ldr.w	r8, [sp, #4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023fd6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023fd8:	4646      	mov	r6, r8
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023fda:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8023fde:	f003 ff63 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023fe2:	ecb6 7b02 	vldmia	r6!, {d7}
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8023fe6:	e9d7 ab00 	ldrd	sl, fp, [r7]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8023fea:	eeb0 9a47 	vmov.f32	s18, s14
 8023fee:	eef0 9a67 	vmov.f32	s19, s15
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023ff2:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8023ff6:	4604      	mov	r4, r0
 8023ff8:	460d      	mov	r5, r1
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8023ffa:	4650      	mov	r0, sl
 8023ffc:	4659      	mov	r1, fp
 8023ffe:	f003 ff53 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024002:	e9d8 8902 	ldrd	r8, r9, [r8, #8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024006:	ec45 4b18 	vmov	d8, r4, r5
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 802400a:	4642      	mov	r2, r8
 802400c:	4604      	mov	r4, r0
 802400e:	460d      	mov	r5, r1
 8024010:	464b      	mov	r3, r9
 8024012:	ec51 0b18 	vmov	r0, r1, d8
 8024016:	f003 ff47 	bl	8027ea8 <__aeabi_dmul>
 802401a:	4602      	mov	r2, r0
 802401c:	460b      	mov	r3, r1
 802401e:	4620      	mov	r0, r4
 8024020:	4629      	mov	r1, r5
 8024022:	f003 fd89 	bl	8027b38 <__aeabi_dsub>
 8024026:	ec53 2b1a 	vmov	r2, r3, d10
 802402a:	f003 fd87 	bl	8027b3c <__adddf3>
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 802402e:	4642      	mov	r2, r8
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024030:	4604      	mov	r4, r0
 8024032:	460d      	mov	r5, r1
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024034:	464b      	mov	r3, r9
 8024036:	4650      	mov	r0, sl
 8024038:	4659      	mov	r1, fp
 802403a:	f003 ff35 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 802403e:	46a2      	mov	sl, r4
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024040:	ec53 2b19 	vmov	r2, r3, d9
 8024044:	4604      	mov	r4, r0
            temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024046:	46ab      	mov	fp, r5
            temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 8024048:	460d      	mov	r5, r1
 802404a:	ec51 0b18 	vmov	r0, r1, d8
 802404e:	f003 ff2b 	bl	8027ea8 <__aeabi_dmul>
 8024052:	4602      	mov	r2, r0
 8024054:	460b      	mov	r3, r1
 8024056:	4620      	mov	r0, r4
 8024058:	4629      	mov	r1, r5
 802405a:	f003 fd6f 	bl	8027b3c <__adddf3>
 802405e:	ec53 2b1b 	vmov	r2, r3, d11
 8024062:	f003 fd6b 	bl	8027b3c <__adddf3>
 8024066:	4604      	mov	r4, r0
 8024068:	460d      	mov	r5, r1
 802406a:	e766      	b.n	8023f3a <cblas_ztrmm+0x13c2>
          BASE temp_imag = 0.0;
 802406c:	ed9f 7b08 	vldr	d7, [pc, #32]	; 8024090 <cblas_ztrmm+0x1518>
 8024070:	eeb0 ba47 	vmov.f32	s22, s14
 8024074:	eef0 ba67 	vmov.f32	s23, s15
          BASE temp_real = 0.0;
 8024078:	eeb0 aa47 	vmov.f32	s20, s14
 802407c:	eef0 aa67 	vmov.f32	s21, s15
 8024080:	e746      	b.n	8023f10 <cblas_ztrmm+0x1398>
 8024082:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024084:	9313      	str	r3, [sp, #76]	; 0x4c
 8024086:	f7fe bef9 	b.w	8022e7c <cblas_ztrmm+0x304>
 802408a:	bf00      	nop
 802408c:	f3af 8000 	nop.w
	...
      for (i = 0; i < n1; i++) {
 8024098:	2b00      	cmp	r3, #0
 802409a:	f77e af07 	ble.w	8022eac <cblas_ztrmm+0x334>
 802409e:	0121      	lsls	r1, r4, #4
 80240a0:	3401      	adds	r4, #1
 80240a2:	0124      	lsls	r4, r4, #4
 80240a4:	940e      	str	r4, [sp, #56]	; 0x38
 80240a6:	9c10      	ldr	r4, [sp, #64]	; 0x40
 80240a8:	9b06      	ldr	r3, [sp, #24]
 80240aa:	9103      	str	r1, [sp, #12]
 80240ac:	f101 0208 	add.w	r2, r1, #8
 80240b0:	18a2      	adds	r2, r4, r2
 80240b2:	9214      	str	r2, [sp, #80]	; 0x50
 80240b4:	f101 0210 	add.w	r2, r1, #16
 80240b8:	920d      	str	r2, [sp, #52]	; 0x34
 80240ba:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80240bc:	3b01      	subs	r3, #1
 80240be:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 80240c2:	9301      	str	r3, [sp, #4]
 80240c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80240c6:	2000      	movs	r0, #0
 80240c8:	011b      	lsls	r3, r3, #4
 80240ca:	9011      	str	r0, [sp, #68]	; 0x44
 80240cc:	9012      	str	r0, [sp, #72]	; 0x48
 80240ce:	9313      	str	r3, [sp, #76]	; 0x4c
        for (j = 0; j < n2; j++) {
 80240d0:	9b06      	ldr	r3, [sp, #24]
 80240d2:	2b00      	cmp	r3, #0
 80240d4:	f340 813c 	ble.w	8024350 <cblas_ztrmm+0x17d8>
 80240d8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80240da:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80240dc:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80240e0:	9308      	str	r3, [sp, #32]
 80240e2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80240e4:	3308      	adds	r3, #8
 80240e6:	930a      	str	r3, [sp, #40]	; 0x28
 80240e8:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80240ea:	9309      	str	r3, [sp, #36]	; 0x24
 80240ec:	2300      	movs	r3, #0
 80240ee:	930b      	str	r3, [sp, #44]	; 0x2c
          if (nonunit) {
 80240f0:	9b02      	ldr	r3, [sp, #8]
 80240f2:	2b83      	cmp	r3, #131	; 0x83
 80240f4:	f000 80b4 	beq.w	8024260 <cblas_ztrmm+0x16e8>
            temp_real = REAL(B, i * ldb + j);
 80240f8:	9b08      	ldr	r3, [sp, #32]
 80240fa:	ed93 7b00 	vldr	d7, [r3]
 80240fe:	eeb0 aa47 	vmov.f32	s20, s14
 8024102:	eef0 aa67 	vmov.f32	s21, s15
            temp_imag = IMAG(B, i * ldb + j);
 8024106:	ed93 7b02 	vldr	d7, [r3, #8]
 802410a:	eeb0 ba47 	vmov.f32	s22, s14
 802410e:	eef0 ba67 	vmov.f32	s23, s15
          for (k = j + 1; k < n2; k++) {
 8024112:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024114:	9a06      	ldr	r2, [sp, #24]
 8024116:	3301      	adds	r3, #1
 8024118:	429a      	cmp	r2, r3
 802411a:	930b      	str	r3, [sp, #44]	; 0x2c
 802411c:	f000 80e5 	beq.w	80242ea <cblas_ztrmm+0x1772>
 8024120:	ee1d 0a10 	vmov	r0, s26
 8024124:	f003 fe56 	bl	8027dd4 <__aeabi_i2d>
 8024128:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
 802412c:	ec41 0b1c 	vmov	d12, r0, r1
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8024130:	e9d5 2300 	ldrd	r2, r3, [r5]
 8024134:	ec51 0b1c 	vmov	r0, r1, d12
 8024138:	f003 feb6 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_real = REAL(B, i * ldb + k);
 802413c:	ed94 6b04 	vldr	d6, [r4, #16]
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8024140:	ed15 7b02 	vldr	d7, [r5, #-8]
            const BASE Bik_real = REAL(B, i * ldb + k);
 8024144:	eeb0 8a46 	vmov.f32	s16, s12
 8024148:	eef0 8a66 	vmov.f32	s17, s13
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 802414c:	ec53 2b16 	vmov	r2, r3, d6
            const BASE Akj_real = CONST_REAL(A, k * lda + j);
 8024150:	eeb0 9a47 	vmov.f32	s18, s14
 8024154:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 8024158:	4680      	mov	r8, r0
 802415a:	4689      	mov	r9, r1
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 802415c:	ec51 0b17 	vmov	r0, r1, d7
 8024160:	f003 fea2 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bik_imag = IMAG(B, i * ldb + k);
 8024164:	e9d4 ab06 	ldrd	sl, fp, [r4, #24]
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024168:	4606      	mov	r6, r0
 802416a:	460f      	mov	r7, r1
 802416c:	4652      	mov	r2, sl
 802416e:	465b      	mov	r3, fp
 8024170:	4640      	mov	r0, r8
 8024172:	4649      	mov	r1, r9
 8024174:	f003 fe98 	bl	8027ea8 <__aeabi_dmul>
 8024178:	4602      	mov	r2, r0
 802417a:	460b      	mov	r3, r1
 802417c:	4630      	mov	r0, r6
 802417e:	4639      	mov	r1, r7
 8024180:	f003 fcda 	bl	8027b38 <__aeabi_dsub>
 8024184:	4602      	mov	r2, r0
 8024186:	460b      	mov	r3, r1
 8024188:	ec51 0b1a 	vmov	r0, r1, d10
 802418c:	f003 fcd6 	bl	8027b3c <__adddf3>
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024190:	4652      	mov	r2, sl
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 8024192:	4606      	mov	r6, r0
 8024194:	460f      	mov	r7, r1
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 8024196:	465b      	mov	r3, fp
 8024198:	ec51 0b19 	vmov	r0, r1, d9
 802419c:	f003 fe84 	bl	8027ea8 <__aeabi_dmul>
            temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
 80241a0:	ec47 6b1a 	vmov	d10, r6, r7
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80241a4:	ec53 2b18 	vmov	r2, r3, d8
 80241a8:	4606      	mov	r6, r0
 80241aa:	460f      	mov	r7, r1
 80241ac:	4640      	mov	r0, r8
 80241ae:	4649      	mov	r1, r9
 80241b0:	f003 fe7a 	bl	8027ea8 <__aeabi_dmul>
 80241b4:	4602      	mov	r2, r0
 80241b6:	460b      	mov	r3, r1
 80241b8:	4630      	mov	r0, r6
 80241ba:	4639      	mov	r1, r7
 80241bc:	f003 fcbe 	bl	8027b3c <__adddf3>
 80241c0:	460b      	mov	r3, r1
 80241c2:	4602      	mov	r2, r0
 80241c4:	ec51 0b1b 	vmov	r0, r1, d11
 80241c8:	f003 fcb8 	bl	8027b3c <__adddf3>
 80241cc:	9b03      	ldr	r3, [sp, #12]
 80241ce:	441d      	add	r5, r3
          for (k = j + 1; k < n2; k++) {
 80241d0:	9b01      	ldr	r3, [sp, #4]
 80241d2:	3410      	adds	r4, #16
 80241d4:	429c      	cmp	r4, r3
            temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
 80241d6:	ec41 0b1b 	vmov	d11, r0, r1
          for (k = j + 1; k < n2; k++) {
 80241da:	d1a9      	bne.n	8024130 <cblas_ztrmm+0x15b8>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80241dc:	ec53 2b1f 	vmov	r2, r3, d15
 80241e0:	ec51 0b1a 	vmov	r0, r1, d10
 80241e4:	f003 fe60 	bl	8027ea8 <__aeabi_dmul>
 80241e8:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 80241ec:	ec58 7b1b 	vmov	r7, r8, d11
 80241f0:	4604      	mov	r4, r0
 80241f2:	460d      	mov	r5, r1
 80241f4:	464a      	mov	r2, r9
 80241f6:	4653      	mov	r3, sl
 80241f8:	ee1b 0a10 	vmov	r0, s22
 80241fc:	4641      	mov	r1, r8
 80241fe:	f003 fe53 	bl	8027ea8 <__aeabi_dmul>
 8024202:	4602      	mov	r2, r0
 8024204:	460b      	mov	r3, r1
 8024206:	4620      	mov	r0, r4
 8024208:	4629      	mov	r1, r5
 802420a:	f003 fc95 	bl	8027b38 <__aeabi_dsub>
 802420e:	9e08      	ldr	r6, [sp, #32]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024210:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024212:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024216:	4653      	mov	r3, sl
 8024218:	ec51 0b1a 	vmov	r0, r1, d10
 802421c:	f003 fe44 	bl	8027ea8 <__aeabi_dmul>
 8024220:	ec53 2b1f 	vmov	r2, r3, d15
 8024224:	4604      	mov	r4, r0
 8024226:	460d      	mov	r5, r1
 8024228:	ee1b 0a10 	vmov	r0, s22
 802422c:	4641      	mov	r1, r8
 802422e:	f003 fe3b 	bl	8027ea8 <__aeabi_dmul>
 8024232:	4602      	mov	r2, r0
 8024234:	460b      	mov	r3, r1
 8024236:	4620      	mov	r0, r4
 8024238:	4629      	mov	r1, r5
 802423a:	f003 fc7f 	bl	8027b3c <__adddf3>
 802423e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024240:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8024242:	4413      	add	r3, r2
 8024244:	9309      	str	r3, [sp, #36]	; 0x24
 8024246:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8024248:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802424a:	4413      	add	r3, r2
 802424c:	930a      	str	r3, [sp, #40]	; 0x28
 802424e:	f106 0310 	add.w	r3, r6, #16
 8024252:	9308      	str	r3, [sp, #32]
          if (nonunit) {
 8024254:	9b02      	ldr	r3, [sp, #8]
 8024256:	2b83      	cmp	r3, #131	; 0x83
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024258:	e9c6 0102 	strd	r0, r1, [r6, #8]
          if (nonunit) {
 802425c:	f47f af4c 	bne.w	80240f8 <cblas_ztrmm+0x1580>
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 8024260:	ee1d 0a10 	vmov	r0, s26
 8024264:	f003 fdb6 	bl	8027dd4 <__aeabi_i2d>
 8024268:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 802426a:	e9d4 2300 	ldrd	r2, r3, [r4]
 802426e:	f003 fe1b 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, j * lda + j);
 8024272:	e954 8902 	ldrd	r8, r9, [r4, #-8]
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024276:	9c08      	ldr	r4, [sp, #32]
 8024278:	ed94 7b00 	vldr	d7, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 802427c:	4682      	mov	sl, r0
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 802427e:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, i * ldb + j);
 8024282:	eeb0 8a47 	vmov.f32	s16, s14
 8024286:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
 802428a:	468b      	mov	fp, r1
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 802428c:	4640      	mov	r0, r8
 802428e:	4649      	mov	r1, r9
 8024290:	f003 fe0a 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, i * ldb + j);
 8024294:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 8024298:	460d      	mov	r5, r1
 802429a:	4604      	mov	r4, r0
 802429c:	4632      	mov	r2, r6
 802429e:	463b      	mov	r3, r7
 80242a0:	4650      	mov	r0, sl
 80242a2:	4659      	mov	r1, fp
 80242a4:	f003 fe00 	bl	8027ea8 <__aeabi_dmul>
 80242a8:	4602      	mov	r2, r0
 80242aa:	460b      	mov	r3, r1
 80242ac:	4620      	mov	r0, r4
 80242ae:	4629      	mov	r1, r5
 80242b0:	f003 fc42 	bl	8027b38 <__aeabi_dsub>
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80242b4:	4632      	mov	r2, r6
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80242b6:	4604      	mov	r4, r0
 80242b8:	460d      	mov	r5, r1
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80242ba:	463b      	mov	r3, r7
 80242bc:	4640      	mov	r0, r8
 80242be:	4649      	mov	r1, r9
 80242c0:	f003 fdf2 	bl	8027ea8 <__aeabi_dmul>
            temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
 80242c4:	ec45 4b1a 	vmov	d10, r4, r5
            temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
 80242c8:	ec53 2b18 	vmov	r2, r3, d8
 80242cc:	4604      	mov	r4, r0
 80242ce:	460d      	mov	r5, r1
 80242d0:	4650      	mov	r0, sl
 80242d2:	4659      	mov	r1, fp
 80242d4:	f003 fde8 	bl	8027ea8 <__aeabi_dmul>
 80242d8:	4602      	mov	r2, r0
 80242da:	460b      	mov	r3, r1
 80242dc:	4620      	mov	r0, r4
 80242de:	4629      	mov	r1, r5
 80242e0:	f003 fc2c 	bl	8027b3c <__adddf3>
 80242e4:	ec41 0b1b 	vmov	d11, r0, r1
 80242e8:	e713      	b.n	8024112 <cblas_ztrmm+0x159a>
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 80242ea:	ec53 2b1f 	vmov	r2, r3, d15
 80242ee:	ec51 0b1a 	vmov	r0, r1, d10
 80242f2:	f003 fdd9 	bl	8027ea8 <__aeabi_dmul>
 80242f6:	e9dd 9a04 	ldrd	r9, sl, [sp, #16]
 80242fa:	ec58 7b1b 	vmov	r7, r8, d11
 80242fe:	4604      	mov	r4, r0
 8024300:	460d      	mov	r5, r1
 8024302:	464a      	mov	r2, r9
 8024304:	4653      	mov	r3, sl
 8024306:	ee1b 0a10 	vmov	r0, s22
 802430a:	4641      	mov	r1, r8
 802430c:	f003 fdcc 	bl	8027ea8 <__aeabi_dmul>
 8024310:	4602      	mov	r2, r0
 8024312:	460b      	mov	r3, r1
 8024314:	4620      	mov	r0, r4
 8024316:	4629      	mov	r1, r5
 8024318:	f003 fc0e 	bl	8027b38 <__aeabi_dsub>
 802431c:	9e01      	ldr	r6, [sp, #4]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 802431e:	464a      	mov	r2, r9
          REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
 8024320:	e9c6 0100 	strd	r0, r1, [r6]
          IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
 8024324:	4653      	mov	r3, sl
 8024326:	ec51 0b1a 	vmov	r0, r1, d10
 802432a:	f003 fdbd 	bl	8027ea8 <__aeabi_dmul>
 802432e:	ec53 2b1f 	vmov	r2, r3, d15
 8024332:	4604      	mov	r4, r0
 8024334:	460d      	mov	r5, r1
 8024336:	ee1b 0a10 	vmov	r0, s22
 802433a:	4641      	mov	r1, r8
 802433c:	f003 fdb4 	bl	8027ea8 <__aeabi_dmul>
 8024340:	4602      	mov	r2, r0
 8024342:	460b      	mov	r3, r1
 8024344:	4620      	mov	r0, r4
 8024346:	4629      	mov	r1, r5
 8024348:	f003 fbf8 	bl	8027b3c <__adddf3>
 802434c:	e9c6 0102 	strd	r0, r1, [r6, #8]
      for (i = 0; i < n1; i++) {
 8024350:	9a01      	ldr	r2, [sp, #4]
 8024352:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8024354:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8024356:	440a      	add	r2, r1
 8024358:	9201      	str	r2, [sp, #4]
 802435a:	990c      	ldr	r1, [sp, #48]	; 0x30
 802435c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 802435e:	440a      	add	r2, r1
 8024360:	9211      	str	r2, [sp, #68]	; 0x44
 8024362:	9a07      	ldr	r2, [sp, #28]
 8024364:	3301      	adds	r3, #1
 8024366:	429a      	cmp	r2, r3
 8024368:	9312      	str	r3, [sp, #72]	; 0x48
 802436a:	f47f aeb1 	bne.w	80240d0 <cblas_ztrmm+0x1558>
 802436e:	f7fe bd9d 	b.w	8022eac <cblas_ztrmm+0x334>
 8024372:	bf00      	nop
 8024374:	0000      	movs	r0, r0
	...

08024378 <cblas_ztrmv>:
void
cblas_ztrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 8024378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802437c:	ed2d 8b0e 	vpush	{d8-d14}
 8024380:	b093      	sub	sp, #76	; 0x4c
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8024382:	2a71      	cmp	r2, #113	; 0x71
 8024384:	930b      	str	r3, [sp, #44]	; 0x2c
 8024386:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8024388:	9306      	str	r3, [sp, #24]
 802438a:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 802438c:	9309      	str	r3, [sp, #36]	; 0x24
 802438e:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8024390:	9307      	str	r3, [sp, #28]
 8024392:	e9dd 452b 	ldrd	r4, r5, [sp, #172]	; 0xac
 8024396:	4606      	mov	r6, r0
 8024398:	460f      	mov	r7, r1
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 802439a:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 802439e:	f000 8122 	beq.w	80245e6 <cblas_ztrmv+0x26e>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80243a2:	2b01      	cmp	r3, #1
 80243a4:	4690      	mov	r8, r2
 80243a6:	d934      	bls.n	8024412 <cblas_ztrmv+0x9a>
 80243a8:	2002      	movs	r0, #2
 80243aa:	3a6f      	subs	r2, #111	; 0x6f
 80243ac:	2301      	movs	r3, #1
 80243ae:	2a02      	cmp	r2, #2
 80243b0:	ee0e 3a10 	vmov	s28, r3
 80243b4:	bf88      	it	hi
 80243b6:	2003      	movhi	r0, #3
 80243b8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80243ba:	337d      	adds	r3, #125	; 0x7d
 80243bc:	b2db      	uxtb	r3, r3
 80243be:	2b01      	cmp	r3, #1
 80243c0:	9b06      	ldr	r3, [sp, #24]
 80243c2:	d934      	bls.n	802442e <cblas_ztrmv+0xb6>
 80243c4:	2b00      	cmp	r3, #0
 80243c6:	db2a      	blt.n	802441e <cblas_ztrmv+0xa6>
 80243c8:	2b01      	cmp	r3, #1
 80243ca:	bfb8      	it	lt
 80243cc:	2301      	movlt	r3, #1
 80243ce:	42ab      	cmp	r3, r5
 80243d0:	f340 8113 	ble.w	80245fa <cblas_ztrmv+0x282>
 80243d4:	9b07      	ldr	r3, [sp, #28]
 80243d6:	2b00      	cmp	r3, #0
 80243d8:	bf0c      	ite	eq
 80243da:	2009      	moveq	r0, #9
 80243dc:	2007      	movne	r0, #7
 80243de:	4aba      	ldr	r2, [pc, #744]	; (80246c8 <cblas_ztrmv+0x350>)
 80243e0:	49ba      	ldr	r1, [pc, #744]	; (80246cc <cblas_ztrmv+0x354>)
 80243e2:	f003 fb31 	bl	8027a48 <cblas_xerbla>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80243e6:	2e65      	cmp	r6, #101	; 0x65
 80243e8:	d030      	beq.n	802444c <cblas_ztrmv+0xd4>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 80243ea:	2e66      	cmp	r6, #102	; 0x66
 80243ec:	d107      	bne.n	80243fe <cblas_ztrmv+0x86>
 80243ee:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 80243f2:	f000 8293 	beq.w	802491c <cblas_ztrmv+0x5a4>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 80243f6:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 80243fa:	f000 8104 	beq.w	8024606 <cblas_ztrmv+0x28e>
    BLAS_ERROR("unrecognized operation");
 80243fe:	4ab4      	ldr	r2, [pc, #720]	; (80246d0 <cblas_ztrmv+0x358>)
 8024400:	49b2      	ldr	r1, [pc, #712]	; (80246cc <cblas_ztrmv+0x354>)
 8024402:	2000      	movs	r0, #0
#define BASE double
#include "source_trmv_c.h"
#undef BASE
}
 8024404:	b013      	add	sp, #76	; 0x4c
 8024406:	ecbd 8b0e 	vpop	{d8-d14}
 802440a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802440e:	f003 bb1b 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8024412:	3865      	subs	r0, #101	; 0x65
 8024414:	2801      	cmp	r0, #1
 8024416:	bf94      	ite	ls
 8024418:	2000      	movls	r0, #0
 802441a:	2001      	movhi	r0, #1
 802441c:	e7c5      	b.n	80243aa <cblas_ztrmv+0x32>
 802441e:	2d00      	cmp	r5, #0
 8024420:	ddd8      	ble.n	80243d4 <cblas_ztrmv+0x5c>
 8024422:	9b07      	ldr	r3, [sp, #28]
 8024424:	2b00      	cmp	r3, #0
 8024426:	bf0c      	ite	eq
 8024428:	2009      	moveq	r0, #9
 802442a:	2005      	movne	r0, #5
 802442c:	e7d7      	b.n	80243de <cblas_ztrmv+0x66>
 802442e:	2b00      	cmp	r3, #0
 8024430:	dbf5      	blt.n	802441e <cblas_ztrmv+0xa6>
 8024432:	9b06      	ldr	r3, [sp, #24]
 8024434:	2b01      	cmp	r3, #1
 8024436:	bfb8      	it	lt
 8024438:	2301      	movlt	r3, #1
 802443a:	42ab      	cmp	r3, r5
 802443c:	dcca      	bgt.n	80243d4 <cblas_ztrmv+0x5c>
 802443e:	9b07      	ldr	r3, [sp, #28]
 8024440:	2b00      	cmp	r3, #0
 8024442:	f000 84bb 	beq.w	8024dbc <cblas_ztrmv+0xa44>
 8024446:	2800      	cmp	r0, #0
 8024448:	d0cd      	beq.n	80243e6 <cblas_ztrmv+0x6e>
 802444a:	e7c8      	b.n	80243de <cblas_ztrmv+0x66>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 802444c:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8024450:	f000 8140 	beq.w	80246d4 <cblas_ztrmv+0x35c>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8024454:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8024458:	d1d1      	bne.n	80243fe <cblas_ztrmv+0x86>
 802445a:	2f79      	cmp	r7, #121	; 0x79
 802445c:	f000 8388 	beq.w	8024b70 <cblas_ztrmv+0x7f8>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8024460:	2f7a      	cmp	r7, #122	; 0x7a
 8024462:	d1cc      	bne.n	80243fe <cblas_ztrmv+0x86>
    INDEX ix = OFFSET(N, incX);
 8024464:	9a07      	ldr	r2, [sp, #28]
 8024466:	2a00      	cmp	r2, #0
 8024468:	bfde      	ittt	le
 802446a:	9b06      	ldrle	r3, [sp, #24]
 802446c:	f1c3 0301 	rsble	r3, r3, #1
 8024470:	4353      	mulle	r3, r2
    for (i = 0; i < N; i++) {
 8024472:	9a06      	ldr	r2, [sp, #24]
    INDEX ix = OFFSET(N, incX);
 8024474:	bfc8      	it	gt
 8024476:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8024478:	2a00      	cmp	r2, #0
 802447a:	f340 80af 	ble.w	80245dc <cblas_ztrmv+0x264>
 802447e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8024480:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8024484:	3208      	adds	r2, #8
 8024486:	9208      	str	r2, [sp, #32]
 8024488:	9a07      	ldr	r2, [sp, #28]
 802448a:	3501      	adds	r5, #1
 802448c:	4413      	add	r3, r2
 802448e:	0129      	lsls	r1, r5, #4
 8024490:	930d      	str	r3, [sp, #52]	; 0x34
 8024492:	0113      	lsls	r3, r2, #4
 8024494:	910e      	str	r1, [sp, #56]	; 0x38
 8024496:	f104 0008 	add.w	r0, r4, #8
 802449a:	3910      	subs	r1, #16
 802449c:	9302      	str	r3, [sp, #8]
 802449e:	2300      	movs	r3, #0
 80244a0:	900a      	str	r0, [sp, #40]	; 0x28
 80244a2:	9104      	str	r1, [sp, #16]
 80244a4:	930c      	str	r3, [sp, #48]	; 0x30
      const INDEX j_min = i + 1;
 80244a6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
      for (j = j_min; j < N; j++) {
 80244a8:	9b06      	ldr	r3, [sp, #24]
      const INDEX j_min = i + 1;
 80244aa:	3401      	adds	r4, #1
      for (j = j_min; j < N; j++) {
 80244ac:	42a3      	cmp	r3, r4
      const INDEX j_min = i + 1;
 80244ae:	940c      	str	r4, [sp, #48]	; 0x30
      for (j = j_min; j < N; j++) {
 80244b0:	f340 8353 	ble.w	8024b5a <cblas_ztrmv+0x7e2>
 80244b4:	ee1e 0a10 	vmov	r0, s28
 80244b8:	f003 fc8c 	bl	8027dd4 <__aeabi_i2d>
 80244bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80244be:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80244c0:	9401      	str	r4, [sp, #4]
      BASE temp_i = 0.0;
 80244c2:	ed9f 7b7f 	vldr	d7, [pc, #508]	; 80246c0 <cblas_ztrmv+0x348>
 80244c6:	eb03 1b02 	add.w	fp, r3, r2, lsl #4
 80244ca:	9b04      	ldr	r3, [sp, #16]
 80244cc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80244ce:	eeb0 ba47 	vmov.f32	s22, s14
 80244d2:	eef0 ba67 	vmov.f32	s23, s15
 80244d6:	ec41 0b1c 	vmov	d12, r0, r1
      BASE temp_r = 0.0;
 80244da:	eeb0 aa47 	vmov.f32	s20, s14
 80244de:	eef0 aa67 	vmov.f32	s21, s15
 80244e2:	eb03 0a02 	add.w	sl, r3, r2
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80244e6:	ed1a 7b02 	vldr	d7, [sl, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80244ea:	e9da 2300 	ldrd	r2, r3, [sl]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 80244ee:	eeb0 8a47 	vmov.f32	s16, s14
 80244f2:	eef0 8a67 	vmov.f32	s17, s15
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 80244f6:	ec51 0b1c 	vmov	r0, r1, d12
 80244fa:	f003 fcd5 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 80244fe:	e9db 8900 	ldrd	r8, r9, [fp]
        temp_r += A_real * x_real - A_imag * x_imag;
 8024502:	ec53 2b18 	vmov	r2, r3, d8
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8024506:	4604      	mov	r4, r0
 8024508:	460d      	mov	r5, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 802450a:	4640      	mov	r0, r8
 802450c:	4649      	mov	r1, r9
 802450e:	f003 fccb 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8024512:	ed9b 9b02 	vldr	d9, [fp, #8]
        temp_r += A_real * x_real - A_imag * x_imag;
 8024516:	4606      	mov	r6, r0
 8024518:	460f      	mov	r7, r1
 802451a:	4622      	mov	r2, r4
 802451c:	462b      	mov	r3, r5
 802451e:	ec51 0b19 	vmov	r0, r1, d9
 8024522:	f003 fcc1 	bl	8027ea8 <__aeabi_dmul>
 8024526:	4602      	mov	r2, r0
 8024528:	460b      	mov	r3, r1
 802452a:	4630      	mov	r0, r6
 802452c:	4639      	mov	r1, r7
 802452e:	f003 fb03 	bl	8027b38 <__aeabi_dsub>
 8024532:	4602      	mov	r2, r0
 8024534:	460b      	mov	r3, r1
 8024536:	ec51 0b1a 	vmov	r0, r1, d10
 802453a:	f003 faff 	bl	8027b3c <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 802453e:	ec53 2b18 	vmov	r2, r3, d8
        temp_r += A_real * x_real - A_imag * x_imag;
 8024542:	4606      	mov	r6, r0
 8024544:	460f      	mov	r7, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 8024546:	ec51 0b19 	vmov	r0, r1, d9
 802454a:	f003 fcad 	bl	8027ea8 <__aeabi_dmul>
        temp_r += A_real * x_real - A_imag * x_imag;
 802454e:	ec47 6b1a 	vmov	d10, r6, r7
        temp_i += A_real * x_imag + A_imag * x_real;
 8024552:	4622      	mov	r2, r4
 8024554:	462b      	mov	r3, r5
 8024556:	4606      	mov	r6, r0
 8024558:	460f      	mov	r7, r1
 802455a:	4640      	mov	r0, r8
 802455c:	4649      	mov	r1, r9
 802455e:	f003 fca3 	bl	8027ea8 <__aeabi_dmul>
 8024562:	4602      	mov	r2, r0
 8024564:	460b      	mov	r3, r1
 8024566:	4630      	mov	r0, r6
 8024568:	4639      	mov	r1, r7
 802456a:	f003 fae7 	bl	8027b3c <__adddf3>
 802456e:	4602      	mov	r2, r0
 8024570:	460b      	mov	r3, r1
 8024572:	ec51 0b1b 	vmov	r0, r1, d11
 8024576:	f003 fae1 	bl	8027b3c <__adddf3>
 802457a:	9a04      	ldr	r2, [sp, #16]
      for (j = j_min; j < N; j++) {
 802457c:	9b01      	ldr	r3, [sp, #4]
 802457e:	4492      	add	sl, r2
 8024580:	9a02      	ldr	r2, [sp, #8]
 8024582:	4493      	add	fp, r2
 8024584:	9a06      	ldr	r2, [sp, #24]
 8024586:	3301      	adds	r3, #1
 8024588:	429a      	cmp	r2, r3
        temp_i += A_real * x_imag + A_imag * x_real;
 802458a:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = j_min; j < N; j++) {
 802458e:	9301      	str	r3, [sp, #4]
 8024590:	d1a9      	bne.n	80244e6 <cblas_ztrmv+0x16e>
      if (nonunit) {
 8024592:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024594:	2b83      	cmp	r3, #131	; 0x83
 8024596:	d03d      	beq.n	8024614 <cblas_ztrmv+0x29c>
        REAL(X, ix) += temp_r;
 8024598:	9c08      	ldr	r4, [sp, #32]
 802459a:	ec53 2b1a 	vmov	r2, r3, d10
 802459e:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 80245a2:	f003 facb 	bl	8027b3c <__adddf3>
        IMAG(X, ix) += temp_i;
 80245a6:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(X, ix) += temp_r;
 80245aa:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 80245ae:	e9d4 0100 	ldrd	r0, r1, [r4]
 80245b2:	f003 fac3 	bl	8027b3c <__adddf3>
 80245b6:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 80245ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80245bc:	9a07      	ldr	r2, [sp, #28]
 80245be:	4413      	add	r3, r2
 80245c0:	930d      	str	r3, [sp, #52]	; 0x34
 80245c2:	9a02      	ldr	r2, [sp, #8]
 80245c4:	9b08      	ldr	r3, [sp, #32]
 80245c6:	4413      	add	r3, r2
 80245c8:	9308      	str	r3, [sp, #32]
 80245ca:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80245cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80245ce:	4413      	add	r3, r2
 80245d0:	930a      	str	r3, [sp, #40]	; 0x28
 80245d2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80245d4:	9b06      	ldr	r3, [sp, #24]
 80245d6:	4293      	cmp	r3, r2
 80245d8:	f47f af65 	bne.w	80244a6 <cblas_ztrmv+0x12e>
 80245dc:	b013      	add	sp, #76	; 0x4c
 80245de:	ecbd 8b0e 	vpop	{d8-d14}
 80245e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80245e6:	2b01      	cmp	r3, #1
 80245e8:	d95e      	bls.n	80246a8 <cblas_ztrmv+0x330>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 80245ea:	f04f 33ff 	mov.w	r3, #4294967295
 80245ee:	ee0e 3a10 	vmov	s28, r3
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80245f2:	f04f 0870 	mov.w	r8, #112	; 0x70
 80245f6:	2002      	movs	r0, #2
 80245f8:	e6de      	b.n	80243b8 <cblas_ztrmv+0x40>
 80245fa:	9b07      	ldr	r3, [sp, #28]
 80245fc:	2b00      	cmp	r3, #0
 80245fe:	bf0c      	ite	eq
 8024600:	2009      	moveq	r0, #9
 8024602:	2004      	movne	r0, #4
 8024604:	e6eb      	b.n	80243de <cblas_ztrmv+0x66>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8024606:	2f7a      	cmp	r7, #122	; 0x7a
 8024608:	f000 82b2 	beq.w	8024b70 <cblas_ztrmv+0x7f8>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 802460c:	2f79      	cmp	r7, #121	; 0x79
 802460e:	f47f aef6 	bne.w	80243fe <cblas_ztrmv+0x86>
 8024612:	e727      	b.n	8024464 <cblas_ztrmv+0xec>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024614:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        const BASE x_real = REAL(X, ix);
 8024616:	9c08      	ldr	r4, [sp, #32]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8024618:	ee1e 0a10 	vmov	r0, s28
 802461c:	f003 fbda 	bl	8027dd4 <__aeabi_i2d>
 8024620:	e9d5 2300 	ldrd	r2, r3, [r5]
 8024624:	f003 fc40 	bl	8027ea8 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024628:	e955 ab02 	ldrd	sl, fp, [r5, #-8]
        const BASE x_real = REAL(X, ix);
 802462c:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8024630:	4680      	mov	r8, r0
 8024632:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024634:	4652      	mov	r2, sl
 8024636:	465b      	mov	r3, fp
 8024638:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 802463c:	e9d4 6700 	ldrd	r6, r7, [r4]
 8024640:	9408      	str	r4, [sp, #32]
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024642:	f003 fc31 	bl	8027ea8 <__aeabi_dmul>
 8024646:	4642      	mov	r2, r8
 8024648:	4604      	mov	r4, r0
 802464a:	460d      	mov	r5, r1
 802464c:	464b      	mov	r3, r9
 802464e:	4630      	mov	r0, r6
 8024650:	4639      	mov	r1, r7
 8024652:	f003 fc29 	bl	8027ea8 <__aeabi_dmul>
 8024656:	4602      	mov	r2, r0
 8024658:	460b      	mov	r3, r1
 802465a:	4620      	mov	r0, r4
 802465c:	4629      	mov	r1, r5
 802465e:	f003 fa6b 	bl	8027b38 <__aeabi_dsub>
 8024662:	ec53 2b1a 	vmov	r2, r3, d10
 8024666:	f003 fa69 	bl	8027b3c <__adddf3>
 802466a:	9c08      	ldr	r4, [sp, #32]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 802466c:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 802466e:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8024672:	465b      	mov	r3, fp
 8024674:	4630      	mov	r0, r6
 8024676:	4639      	mov	r1, r7
 8024678:	f003 fc16 	bl	8027ea8 <__aeabi_dmul>
 802467c:	4642      	mov	r2, r8
 802467e:	4604      	mov	r4, r0
 8024680:	464b      	mov	r3, r9
 8024682:	460d      	mov	r5, r1
 8024684:	ec51 0b18 	vmov	r0, r1, d8
 8024688:	f003 fc0e 	bl	8027ea8 <__aeabi_dmul>
 802468c:	4602      	mov	r2, r0
 802468e:	460b      	mov	r3, r1
 8024690:	4620      	mov	r0, r4
 8024692:	4629      	mov	r1, r5
 8024694:	f003 fa52 	bl	8027b3c <__adddf3>
 8024698:	ec53 2b1b 	vmov	r2, r3, d11
 802469c:	f003 fa4e 	bl	8027b3c <__adddf3>
 80246a0:	9c08      	ldr	r4, [sp, #32]
 80246a2:	e9c4 0100 	strd	r0, r1, [r4]
 80246a6:	e788      	b.n	80245ba <cblas_ztrmv+0x242>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80246a8:	3865      	subs	r0, #101	; 0x65
 80246aa:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 80246ac:	f04f 33ff 	mov.w	r3, #4294967295
 80246b0:	ee0e 3a10 	vmov	s28, r3
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 80246b4:	bf94      	ite	ls
 80246b6:	2000      	movls	r0, #0
 80246b8:	2001      	movhi	r0, #1
 80246ba:	f04f 0870 	mov.w	r8, #112	; 0x70
 80246be:	e67b      	b.n	80243b8 <cblas_ztrmv+0x40>
	...
 80246c8:	08030378 	.word	0x08030378
 80246cc:	08030794 	.word	0x08030794
 80246d0:	080305a8 	.word	0x080305a8
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 80246d4:	2f79      	cmp	r7, #121	; 0x79
 80246d6:	f000 812b 	beq.w	8024930 <cblas_ztrmv+0x5b8>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 80246da:	2f7a      	cmp	r7, #122	; 0x7a
 80246dc:	f47f ae8f 	bne.w	80243fe <cblas_ztrmv+0x86>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80246e0:	9b07      	ldr	r3, [sp, #28]
    for (i = N; i > 0 && i--;) {
 80246e2:	9e06      	ldr	r6, [sp, #24]
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 80246e4:	9f07      	ldr	r7, [sp, #28]
 80246e6:	2b00      	cmp	r3, #0
 80246e8:	9b06      	ldr	r3, [sp, #24]
 80246ea:	bfd8      	it	le
 80246ec:	9a07      	ldrle	r2, [sp, #28]
 80246ee:	f103 33ff 	add.w	r3, r3, #4294967295
 80246f2:	9308      	str	r3, [sp, #32]
 80246f4:	bfd8      	it	le
 80246f6:	4252      	negle	r2, r2
 80246f8:	9908      	ldr	r1, [sp, #32]
 80246fa:	bfcc      	ite	gt
 80246fc:	2200      	movgt	r2, #0
 80246fe:	435a      	mulle	r2, r3
    for (i = N; i > 0 && i--;) {
 8024700:	2e00      	cmp	r6, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8024702:	fb01 2e07 	mla	lr, r1, r7, r2
    for (i = N; i > 0 && i--;) {
 8024706:	f77f af69 	ble.w	80245dc <cblas_ztrmv+0x264>
 802470a:	9809      	ldr	r0, [sp, #36]	; 0x24
 802470c:	eb00 1e0e 	add.w	lr, r0, lr, lsl #4
 8024710:	fb05 6c01 	mla	ip, r5, r1, r6
 8024714:	ebc7 7107 	rsb	r1, r7, r7, lsl #28
 8024718:	f10e 0708 	add.w	r7, lr, #8
 802471c:	9701      	str	r7, [sp, #4]
 802471e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8024720:	1c6b      	adds	r3, r5, #1
 8024722:	011b      	lsls	r3, r3, #4
 8024724:	eb07 1702 	add.w	r7, r7, r2, lsl #4
 8024728:	9a08      	ldr	r2, [sp, #32]
 802472a:	970d      	str	r7, [sp, #52]	; 0x34
 802472c:	f1a3 0610 	sub.w	r6, r3, #16
 8024730:	43e8      	mvns	r0, r5
 8024732:	fb02 4606 	mla	r6, r2, r6, r4
 8024736:	fb03 4202 	mla	r2, r3, r2, r4
 802473a:	ebc5 7505 	rsb	r5, r5, r5, lsl #28
 802473e:	9204      	str	r2, [sp, #16]
 8024740:	0102      	lsls	r2, r0, #4
 8024742:	9209      	str	r2, [sp, #36]	; 0x24
 8024744:	012a      	lsls	r2, r5, #4
 8024746:	920a      	str	r2, [sp, #40]	; 0x28
 8024748:	010a      	lsls	r2, r1, #4
 802474a:	9907      	ldr	r1, [sp, #28]
 802474c:	9602      	str	r6, [sp, #8]
 802474e:	f1a4 0810 	sub.w	r8, r4, #16
 8024752:	eb08 170c 	add.w	r7, r8, ip, lsl #4
 8024756:	010b      	lsls	r3, r1, #4
 8024758:	9706      	str	r7, [sp, #24]
 802475a:	920c      	str	r2, [sp, #48]	; 0x30
 802475c:	9307      	str	r3, [sp, #28]
      for (j = 0; j < j_max; j++) {
 802475e:	9b08      	ldr	r3, [sp, #32]
 8024760:	2b00      	cmp	r3, #0
 8024762:	f000 8319 	beq.w	8024d98 <cblas_ztrmv+0xa20>
 8024766:	ee1e 0a10 	vmov	r0, s28
 802476a:	f003 fb33 	bl	8027dd4 <__aeabi_i2d>
 802476e:	ed9f 7b6e 	vldr	d7, [pc, #440]	; 8024928 <cblas_ztrmv+0x5b0>
 8024772:	e9dd 5706 	ldrd	r5, r7, [sp, #24]
 8024776:	eeb0 ca47 	vmov.f32	s24, s14
 802477a:	eef0 ca67 	vmov.f32	s25, s15
 802477e:	eeb0 ba47 	vmov.f32	s22, s14
 8024782:	eef0 ba67 	vmov.f32	s23, s15
 8024786:	ec41 0b1d 	vmov	d13, r0, r1
 802478a:	9e02      	ldr	r6, [sp, #8]
 802478c:	9c0d      	ldr	r4, [sp, #52]	; 0x34
        const BASE A_real = CONST_REAL(A, lda * i + j);
 802478e:	ed96 7b00 	vldr	d7, [r6]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 8024792:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 8024796:	eeb0 9a47 	vmov.f32	s18, s14
 802479a:	eef0 9a67 	vmov.f32	s19, s15
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 802479e:	ec51 0b1d 	vmov	r0, r1, d13
 80247a2:	f003 fb81 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 80247a6:	ed94 8b00 	vldr	d8, [r4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80247aa:	4680      	mov	r8, r0
 80247ac:	4689      	mov	r9, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 80247ae:	ec53 2b19 	vmov	r2, r3, d9
 80247b2:	ec51 0b18 	vmov	r0, r1, d8
 80247b6:	f003 fb77 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 80247ba:	e9d4 ab02 	ldrd	sl, fp, [r4, #8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80247be:	ec49 8b1a 	vmov	d10, r8, r9
        temp_r += A_real * x_real - A_imag * x_imag;
 80247c2:	4680      	mov	r8, r0
 80247c4:	ec53 2b1a 	vmov	r2, r3, d10
 80247c8:	4689      	mov	r9, r1
 80247ca:	4650      	mov	r0, sl
 80247cc:	4659      	mov	r1, fp
 80247ce:	f003 fb6b 	bl	8027ea8 <__aeabi_dmul>
 80247d2:	4602      	mov	r2, r0
 80247d4:	460b      	mov	r3, r1
 80247d6:	4640      	mov	r0, r8
 80247d8:	4649      	mov	r1, r9
 80247da:	f003 f9ad 	bl	8027b38 <__aeabi_dsub>
 80247de:	4602      	mov	r2, r0
 80247e0:	460b      	mov	r3, r1
 80247e2:	ec51 0b1b 	vmov	r0, r1, d11
 80247e6:	f003 f9a9 	bl	8027b3c <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 80247ea:	ec53 2b19 	vmov	r2, r3, d9
        temp_r += A_real * x_real - A_imag * x_imag;
 80247ee:	4680      	mov	r8, r0
 80247f0:	4689      	mov	r9, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 80247f2:	4650      	mov	r0, sl
 80247f4:	4659      	mov	r1, fp
 80247f6:	f003 fb57 	bl	8027ea8 <__aeabi_dmul>
        temp_r += A_real * x_real - A_imag * x_imag;
 80247fa:	ec49 8b1b 	vmov	d11, r8, r9
        temp_i += A_real * x_imag + A_imag * x_real;
 80247fe:	ec53 2b1a 	vmov	r2, r3, d10
 8024802:	4680      	mov	r8, r0
 8024804:	4689      	mov	r9, r1
 8024806:	ec51 0b18 	vmov	r0, r1, d8
 802480a:	f003 fb4d 	bl	8027ea8 <__aeabi_dmul>
 802480e:	4602      	mov	r2, r0
 8024810:	460b      	mov	r3, r1
 8024812:	4640      	mov	r0, r8
 8024814:	4649      	mov	r1, r9
 8024816:	f003 f991 	bl	8027b3c <__adddf3>
 802481a:	4602      	mov	r2, r0
 802481c:	460b      	mov	r3, r1
 802481e:	ec51 0b1c 	vmov	r0, r1, d12
 8024822:	f003 f98b 	bl	8027b3c <__adddf3>
 8024826:	3610      	adds	r6, #16
      for (j = 0; j < j_max; j++) {
 8024828:	42b5      	cmp	r5, r6
        temp_i += A_real * x_imag + A_imag * x_real;
 802482a:	ec41 0b1c 	vmov	d12, r0, r1
      for (j = 0; j < j_max; j++) {
 802482e:	443c      	add	r4, r7
 8024830:	d1ad      	bne.n	802478e <cblas_ztrmv+0x416>
      if (nonunit) {
 8024832:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024834:	2b83      	cmp	r3, #131	; 0x83
 8024836:	d027      	beq.n	8024888 <cblas_ztrmv+0x510>
        REAL(X, ix) += temp_r;
 8024838:	9c01      	ldr	r4, [sp, #4]
 802483a:	ec53 2b1b 	vmov	r2, r3, d11
 802483e:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8024842:	f003 f97b 	bl	8027b3c <__adddf3>
        IMAG(X, ix) += temp_i;
 8024846:	ec53 2b1c 	vmov	r2, r3, d12
        REAL(X, ix) += temp_r;
 802484a:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 802484e:	e9d4 0100 	ldrd	r0, r1, [r4]
 8024852:	f003 f973 	bl	8027b3c <__adddf3>
 8024856:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 802485a:	9a04      	ldr	r2, [sp, #16]
 802485c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802485e:	4611      	mov	r1, r2
 8024860:	4419      	add	r1, r3
 8024862:	9a02      	ldr	r2, [sp, #8]
 8024864:	9104      	str	r1, [sp, #16]
 8024866:	990a      	ldr	r1, [sp, #40]	; 0x28
 8024868:	440a      	add	r2, r1
 802486a:	9202      	str	r2, [sp, #8]
 802486c:	9a06      	ldr	r2, [sp, #24]
 802486e:	441a      	add	r2, r3
 8024870:	9206      	str	r2, [sp, #24]
 8024872:	9b01      	ldr	r3, [sp, #4]
 8024874:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8024876:	4413      	add	r3, r2
 8024878:	9301      	str	r3, [sp, #4]
 802487a:	9b08      	ldr	r3, [sp, #32]
 802487c:	2b00      	cmp	r3, #0
 802487e:	f43f aead 	beq.w	80245dc <cblas_ztrmv+0x264>
 8024882:	3b01      	subs	r3, #1
 8024884:	9308      	str	r3, [sp, #32]
 8024886:	e76a      	b.n	802475e <cblas_ztrmv+0x3e6>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024888:	9d04      	ldr	r5, [sp, #16]
        const BASE x_real = REAL(X, ix);
 802488a:	9c01      	ldr	r4, [sp, #4]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 802488c:	ee1e 0a10 	vmov	r0, s28
 8024890:	f003 faa0 	bl	8027dd4 <__aeabi_i2d>
 8024894:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8024898:	f003 fb06 	bl	8027ea8 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 802489c:	e9d5 ab00 	ldrd	sl, fp, [r5]
        const BASE x_real = REAL(X, ix);
 80248a0:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 80248a4:	4680      	mov	r8, r0
 80248a6:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80248a8:	4652      	mov	r2, sl
 80248aa:	465b      	mov	r3, fp
 80248ac:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 80248b0:	e9d4 6700 	ldrd	r6, r7, [r4]
 80248b4:	9401      	str	r4, [sp, #4]
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80248b6:	f003 faf7 	bl	8027ea8 <__aeabi_dmul>
 80248ba:	4642      	mov	r2, r8
 80248bc:	4604      	mov	r4, r0
 80248be:	460d      	mov	r5, r1
 80248c0:	464b      	mov	r3, r9
 80248c2:	4630      	mov	r0, r6
 80248c4:	4639      	mov	r1, r7
 80248c6:	f003 faef 	bl	8027ea8 <__aeabi_dmul>
 80248ca:	4602      	mov	r2, r0
 80248cc:	460b      	mov	r3, r1
 80248ce:	4620      	mov	r0, r4
 80248d0:	4629      	mov	r1, r5
 80248d2:	f003 f931 	bl	8027b38 <__aeabi_dsub>
 80248d6:	ec53 2b1b 	vmov	r2, r3, d11
 80248da:	f003 f92f 	bl	8027b3c <__adddf3>
 80248de:	9c01      	ldr	r4, [sp, #4]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80248e0:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 80248e2:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 80248e6:	465b      	mov	r3, fp
 80248e8:	4630      	mov	r0, r6
 80248ea:	4639      	mov	r1, r7
 80248ec:	f003 fadc 	bl	8027ea8 <__aeabi_dmul>
 80248f0:	4642      	mov	r2, r8
 80248f2:	4604      	mov	r4, r0
 80248f4:	464b      	mov	r3, r9
 80248f6:	460d      	mov	r5, r1
 80248f8:	ec51 0b18 	vmov	r0, r1, d8
 80248fc:	f003 fad4 	bl	8027ea8 <__aeabi_dmul>
 8024900:	4602      	mov	r2, r0
 8024902:	460b      	mov	r3, r1
 8024904:	4620      	mov	r0, r4
 8024906:	4629      	mov	r1, r5
 8024908:	f003 f918 	bl	8027b3c <__adddf3>
 802490c:	ec53 2b1c 	vmov	r2, r3, d12
 8024910:	f003 f914 	bl	8027b3c <__adddf3>
 8024914:	9c01      	ldr	r4, [sp, #4]
 8024916:	e9c4 0100 	strd	r0, r1, [r4]
 802491a:	e79e      	b.n	802485a <cblas_ztrmv+0x4e2>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 802491c:	2f7a      	cmp	r7, #122	; 0x7a
 802491e:	d007      	beq.n	8024930 <cblas_ztrmv+0x5b8>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 8024920:	2f79      	cmp	r7, #121	; 0x79
 8024922:	f47f ad6c 	bne.w	80243fe <cblas_ztrmv+0x86>
 8024926:	e6db      	b.n	80246e0 <cblas_ztrmv+0x368>
	...
    INDEX ix = OFFSET(N, incX);
 8024930:	9a07      	ldr	r2, [sp, #28]
    for (i = 0; i < N; i++) {
 8024932:	9806      	ldr	r0, [sp, #24]
    INDEX ix = OFFSET(N, incX);
 8024934:	2a00      	cmp	r2, #0
 8024936:	bfdd      	ittte	le
 8024938:	9b06      	ldrle	r3, [sp, #24]
 802493a:	f1c3 0301 	rsble	r3, r3, #1
 802493e:	4353      	mulle	r3, r2
 8024940:	2300      	movgt	r3, #0
    for (i = 0; i < N; i++) {
 8024942:	2800      	cmp	r0, #0
 8024944:	f77f ae4a 	ble.w	80245dc <cblas_ztrmv+0x264>
 8024948:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802494a:	9408      	str	r4, [sp, #32]
 802494c:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 8024950:	3208      	adds	r2, #8
 8024952:	9204      	str	r2, [sp, #16]
 8024954:	9a07      	ldr	r2, [sp, #28]
 8024956:	3501      	adds	r5, #1
 8024958:	4413      	add	r3, r2
 802495a:	012d      	lsls	r5, r5, #4
 802495c:	f1a4 0110 	sub.w	r1, r4, #16
 8024960:	930c      	str	r3, [sp, #48]	; 0x30
 8024962:	0113      	lsls	r3, r2, #4
 8024964:	f1a5 0410 	sub.w	r4, r5, #16
 8024968:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 802496c:	9302      	str	r3, [sp, #8]
 802496e:	2300      	movs	r3, #0
 8024970:	950e      	str	r5, [sp, #56]	; 0x38
 8024972:	940d      	str	r4, [sp, #52]	; 0x34
 8024974:	9101      	str	r1, [sp, #4]
 8024976:	930a      	str	r3, [sp, #40]	; 0x28
      const INDEX j_min = i + 1;
 8024978:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      for (j = j_min; j < N; j++) {
 802497a:	9a06      	ldr	r2, [sp, #24]
      const INDEX j_min = i + 1;
 802497c:	3301      	adds	r3, #1
      for (j = j_min; j < N; j++) {
 802497e:	429a      	cmp	r2, r3
      const INDEX j_min = i + 1;
 8024980:	930a      	str	r3, [sp, #40]	; 0x28
      for (j = j_min; j < N; j++) {
 8024982:	f340 80df 	ble.w	8024b44 <cblas_ztrmv+0x7cc>
 8024986:	ee1e 0a10 	vmov	r0, s28
 802498a:	f003 fa23 	bl	8027dd4 <__aeabi_i2d>
      BASE temp_i = 0.0;
 802498e:	ed1f 7b1a 	vldr	d7, [pc, #-104]	; 8024928 <cblas_ztrmv+0x5b0>
 8024992:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8024994:	9a0c      	ldr	r2, [sp, #48]	; 0x30
      for (j = j_min; j < N; j++) {
 8024996:	f8dd b020 	ldr.w	fp, [sp, #32]
      BASE temp_i = 0.0;
 802499a:	eeb0 ba47 	vmov.f32	s22, s14
 802499e:	eef0 ba67 	vmov.f32	s23, s15
 80249a2:	ec41 0b1c 	vmov	d12, r0, r1
      BASE temp_r = 0.0;
 80249a6:	eeb0 aa47 	vmov.f32	s20, s14
 80249aa:	eef0 aa67 	vmov.f32	s21, s15
 80249ae:	eb03 1a02 	add.w	sl, r3, r2, lsl #4
        const BASE A_real = CONST_REAL(A, lda * i + j);
 80249b2:	ed9b 7b04 	vldr	d7, [fp, #16]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80249b6:	e9db 2306 	ldrd	r2, r3, [fp, #24]
        const BASE A_real = CONST_REAL(A, lda * i + j);
 80249ba:	eeb0 8a47 	vmov.f32	s16, s14
 80249be:	eef0 8a67 	vmov.f32	s17, s15
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80249c2:	ec51 0b1c 	vmov	r0, r1, d12
 80249c6:	f003 fa6f 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 80249ca:	e9da 6700 	ldrd	r6, r7, [sl]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80249ce:	4604      	mov	r4, r0
 80249d0:	460d      	mov	r5, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 80249d2:	ec53 2b18 	vmov	r2, r3, d8
 80249d6:	4630      	mov	r0, r6
 80249d8:	4639      	mov	r1, r7
 80249da:	f003 fa65 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 80249de:	e9da 8902 	ldrd	r8, r9, [sl, #8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
 80249e2:	ec45 4b19 	vmov	d9, r4, r5
        temp_r += A_real * x_real - A_imag * x_imag;
 80249e6:	4604      	mov	r4, r0
 80249e8:	ec53 2b19 	vmov	r2, r3, d9
 80249ec:	460d      	mov	r5, r1
 80249ee:	4640      	mov	r0, r8
 80249f0:	4649      	mov	r1, r9
 80249f2:	f003 fa59 	bl	8027ea8 <__aeabi_dmul>
 80249f6:	4602      	mov	r2, r0
 80249f8:	460b      	mov	r3, r1
 80249fa:	4620      	mov	r0, r4
 80249fc:	4629      	mov	r1, r5
 80249fe:	f003 f89b 	bl	8027b38 <__aeabi_dsub>
 8024a02:	4602      	mov	r2, r0
 8024a04:	460b      	mov	r3, r1
 8024a06:	ec51 0b1a 	vmov	r0, r1, d10
 8024a0a:	f003 f897 	bl	8027b3c <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 8024a0e:	ec53 2b18 	vmov	r2, r3, d8
        temp_r += A_real * x_real - A_imag * x_imag;
 8024a12:	4604      	mov	r4, r0
 8024a14:	460d      	mov	r5, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 8024a16:	4640      	mov	r0, r8
 8024a18:	4649      	mov	r1, r9
 8024a1a:	f003 fa45 	bl	8027ea8 <__aeabi_dmul>
        temp_r += A_real * x_real - A_imag * x_imag;
 8024a1e:	ec45 4b1a 	vmov	d10, r4, r5
        temp_i += A_real * x_imag + A_imag * x_real;
 8024a22:	ec53 2b19 	vmov	r2, r3, d9
 8024a26:	4604      	mov	r4, r0
 8024a28:	460d      	mov	r5, r1
 8024a2a:	4630      	mov	r0, r6
 8024a2c:	4639      	mov	r1, r7
 8024a2e:	f003 fa3b 	bl	8027ea8 <__aeabi_dmul>
 8024a32:	4602      	mov	r2, r0
 8024a34:	460b      	mov	r3, r1
 8024a36:	4620      	mov	r0, r4
 8024a38:	4629      	mov	r1, r5
 8024a3a:	f003 f87f 	bl	8027b3c <__adddf3>
 8024a3e:	460b      	mov	r3, r1
 8024a40:	4602      	mov	r2, r0
 8024a42:	ec51 0b1b 	vmov	r0, r1, d11
 8024a46:	f003 f879 	bl	8027b3c <__adddf3>
 8024a4a:	9b02      	ldr	r3, [sp, #8]
 8024a4c:	449a      	add	sl, r3
      for (j = j_min; j < N; j++) {
 8024a4e:	9b01      	ldr	r3, [sp, #4]
 8024a50:	f10b 0b10 	add.w	fp, fp, #16
 8024a54:	455b      	cmp	r3, fp
        temp_i += A_real * x_imag + A_imag * x_real;
 8024a56:	ec41 0b1b 	vmov	d11, r0, r1
      for (j = j_min; j < N; j++) {
 8024a5a:	d1aa      	bne.n	80249b2 <cblas_ztrmv+0x63a>
      if (nonunit) {
 8024a5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024a5e:	2b83      	cmp	r3, #131	; 0x83
 8024a60:	d026      	beq.n	8024ab0 <cblas_ztrmv+0x738>
        REAL(X, ix) += temp_r;
 8024a62:	9c04      	ldr	r4, [sp, #16]
 8024a64:	ec53 2b1a 	vmov	r2, r3, d10
 8024a68:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8024a6c:	f003 f866 	bl	8027b3c <__adddf3>
        IMAG(X, ix) += temp_i;
 8024a70:	ec53 2b1b 	vmov	r2, r3, d11
        REAL(X, ix) += temp_r;
 8024a74:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 8024a78:	e9d4 0100 	ldrd	r0, r1, [r4]
 8024a7c:	f003 f85e 	bl	8027b3c <__adddf3>
 8024a80:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = 0; i < N; i++) {
 8024a84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024a86:	9a07      	ldr	r2, [sp, #28]
 8024a88:	4413      	add	r3, r2
 8024a8a:	930c      	str	r3, [sp, #48]	; 0x30
 8024a8c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8024a8e:	9b08      	ldr	r3, [sp, #32]
 8024a90:	4413      	add	r3, r2
 8024a92:	9308      	str	r3, [sp, #32]
 8024a94:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8024a96:	9b01      	ldr	r3, [sp, #4]
 8024a98:	4413      	add	r3, r2
 8024a9a:	9301      	str	r3, [sp, #4]
 8024a9c:	9a02      	ldr	r2, [sp, #8]
 8024a9e:	9b04      	ldr	r3, [sp, #16]
 8024aa0:	4413      	add	r3, r2
 8024aa2:	9304      	str	r3, [sp, #16]
 8024aa4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8024aa6:	9b06      	ldr	r3, [sp, #24]
 8024aa8:	4293      	cmp	r3, r2
 8024aaa:	f47f af65 	bne.w	8024978 <cblas_ztrmv+0x600>
 8024aae:	e595      	b.n	80245dc <cblas_ztrmv+0x264>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024ab0:	9d08      	ldr	r5, [sp, #32]
        const BASE x_real = REAL(X, ix);
 8024ab2:	9c04      	ldr	r4, [sp, #16]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8024ab4:	ee1e 0a10 	vmov	r0, s28
 8024ab8:	f003 f98c 	bl	8027dd4 <__aeabi_i2d>
 8024abc:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8024ac0:	f003 f9f2 	bl	8027ea8 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024ac4:	e9d5 ab00 	ldrd	sl, fp, [r5]
        const BASE x_real = REAL(X, ix);
 8024ac8:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8024acc:	4680      	mov	r8, r0
 8024ace:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024ad0:	4652      	mov	r2, sl
 8024ad2:	465b      	mov	r3, fp
 8024ad4:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 8024ad8:	e9d4 6700 	ldrd	r6, r7, [r4]
 8024adc:	9404      	str	r4, [sp, #16]
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024ade:	f003 f9e3 	bl	8027ea8 <__aeabi_dmul>
 8024ae2:	4642      	mov	r2, r8
 8024ae4:	4604      	mov	r4, r0
 8024ae6:	460d      	mov	r5, r1
 8024ae8:	464b      	mov	r3, r9
 8024aea:	4630      	mov	r0, r6
 8024aec:	4639      	mov	r1, r7
 8024aee:	f003 f9db 	bl	8027ea8 <__aeabi_dmul>
 8024af2:	4602      	mov	r2, r0
 8024af4:	460b      	mov	r3, r1
 8024af6:	4620      	mov	r0, r4
 8024af8:	4629      	mov	r1, r5
 8024afa:	f003 f81d 	bl	8027b38 <__aeabi_dsub>
 8024afe:	ec53 2b1a 	vmov	r2, r3, d10
 8024b02:	f003 f81b 	bl	8027b3c <__adddf3>
 8024b06:	9c04      	ldr	r4, [sp, #16]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8024b08:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024b0a:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8024b0e:	465b      	mov	r3, fp
 8024b10:	4630      	mov	r0, r6
 8024b12:	4639      	mov	r1, r7
 8024b14:	f003 f9c8 	bl	8027ea8 <__aeabi_dmul>
 8024b18:	4642      	mov	r2, r8
 8024b1a:	4604      	mov	r4, r0
 8024b1c:	464b      	mov	r3, r9
 8024b1e:	460d      	mov	r5, r1
 8024b20:	ec51 0b18 	vmov	r0, r1, d8
 8024b24:	f003 f9c0 	bl	8027ea8 <__aeabi_dmul>
 8024b28:	4602      	mov	r2, r0
 8024b2a:	460b      	mov	r3, r1
 8024b2c:	4620      	mov	r0, r4
 8024b2e:	4629      	mov	r1, r5
 8024b30:	f003 f804 	bl	8027b3c <__adddf3>
 8024b34:	ec53 2b1b 	vmov	r2, r3, d11
 8024b38:	f003 f800 	bl	8027b3c <__adddf3>
 8024b3c:	9c04      	ldr	r4, [sp, #16]
 8024b3e:	e9c4 0100 	strd	r0, r1, [r4]
 8024b42:	e79f      	b.n	8024a84 <cblas_ztrmv+0x70c>
      BASE temp_i = 0.0;
 8024b44:	ed1f 7b88 	vldr	d7, [pc, #-544]	; 8024928 <cblas_ztrmv+0x5b0>
 8024b48:	eeb0 ba47 	vmov.f32	s22, s14
 8024b4c:	eef0 ba67 	vmov.f32	s23, s15
      BASE temp_r = 0.0;
 8024b50:	eeb0 aa47 	vmov.f32	s20, s14
 8024b54:	eef0 aa67 	vmov.f32	s21, s15
 8024b58:	e780      	b.n	8024a5c <cblas_ztrmv+0x6e4>
      BASE temp_i = 0.0;
 8024b5a:	ed1f 7b8d 	vldr	d7, [pc, #-564]	; 8024928 <cblas_ztrmv+0x5b0>
 8024b5e:	eeb0 ba47 	vmov.f32	s22, s14
 8024b62:	eef0 ba67 	vmov.f32	s23, s15
      BASE temp_r = 0.0;
 8024b66:	eeb0 aa47 	vmov.f32	s20, s14
 8024b6a:	eef0 aa67 	vmov.f32	s21, s15
 8024b6e:	e510      	b.n	8024592 <cblas_ztrmv+0x21a>
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8024b70:	9b07      	ldr	r3, [sp, #28]
 8024b72:	9e07      	ldr	r6, [sp, #28]
 8024b74:	2b00      	cmp	r3, #0
 8024b76:	bfd8      	it	le
 8024b78:	9a07      	ldrle	r2, [sp, #28]
 8024b7a:	9b06      	ldr	r3, [sp, #24]
 8024b7c:	bfd8      	it	le
 8024b7e:	4251      	negle	r1, r2
 8024b80:	f103 33ff 	add.w	r3, r3, #4294967295
 8024b84:	bfd8      	it	le
 8024b86:	4359      	mulle	r1, r3
 8024b88:	9308      	str	r3, [sp, #32]
    for (i = N; i > 0 && i--;) {
 8024b8a:	9b06      	ldr	r3, [sp, #24]
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8024b8c:	9f08      	ldr	r7, [sp, #32]
 8024b8e:	bfc8      	it	gt
 8024b90:	2100      	movgt	r1, #0
    for (i = N; i > 0 && i--;) {
 8024b92:	2b00      	cmp	r3, #0
    INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
 8024b94:	fb07 1206 	mla	r2, r7, r6, r1
    for (i = N; i > 0 && i--;) {
 8024b98:	f77f ad20 	ble.w	80245dc <cblas_ztrmv+0x264>
 8024b9c:	9809      	ldr	r0, [sp, #36]	; 0x24
 8024b9e:	eb00 1202 	add.w	r2, r0, r2, lsl #4
 8024ba2:	f102 0c08 	add.w	ip, r2, #8
 8024ba6:	9a06      	ldr	r2, [sp, #24]
 8024ba8:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
 8024bac:	eb04 1202 	add.w	r2, r4, r2, lsl #4
 8024bb0:	920d      	str	r2, [sp, #52]	; 0x34
 8024bb2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8024bb4:	1c6b      	adds	r3, r5, #1
 8024bb6:	011b      	lsls	r3, r3, #4
 8024bb8:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8024bbc:	43ed      	mvns	r5, r5
 8024bbe:	9211      	str	r2, [sp, #68]	; 0x44
 8024bc0:	fb03 4207 	mla	r2, r3, r7, r4
 8024bc4:	3b10      	subs	r3, #16
 8024bc6:	ebc6 7006 	rsb	r0, r6, r6, lsl #28
 8024bca:	9309      	str	r3, [sp, #36]	; 0x24
 8024bcc:	012b      	lsls	r3, r5, #4
 8024bce:	930f      	str	r3, [sp, #60]	; 0x3c
 8024bd0:	0103      	lsls	r3, r0, #4
 8024bd2:	9310      	str	r3, [sp, #64]	; 0x40
 8024bd4:	0133      	lsls	r3, r6, #4
 8024bd6:	920e      	str	r2, [sp, #56]	; 0x38
 8024bd8:	930a      	str	r3, [sp, #40]	; 0x28
      for (j = 0; j < j_max; j++) {
 8024bda:	9b08      	ldr	r3, [sp, #32]
 8024bdc:	2b00      	cmp	r3, #0
 8024bde:	f000 80e6 	beq.w	8024dae <cblas_ztrmv+0xa36>
 8024be2:	ee1e 0a10 	vmov	r0, s28
 8024be6:	f003 f8f5 	bl	8027dd4 <__aeabi_i2d>
 8024bea:	ed1f 7bb1 	vldr	d7, [pc, #-708]	; 8024928 <cblas_ztrmv+0x5b0>
 8024bee:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8024bf0:	9301      	str	r3, [sp, #4]
 8024bf2:	ed8d 7b04 	vstr	d7, [sp, #16]
 8024bf6:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8024bf8:	9306      	str	r3, [sp, #24]
 8024bfa:	ed8d 7b02 	vstr	d7, [sp, #8]
 8024bfe:	2300      	movs	r3, #0
 8024c00:	ec41 0b19 	vmov	d9, r0, r1
 8024c04:	9307      	str	r3, [sp, #28]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8024c06:	9b01      	ldr	r3, [sp, #4]
        const BASE x_real = REAL(X, jx);
 8024c08:	9e06      	ldr	r6, [sp, #24]
        const BASE A_real = CONST_REAL(A, lda * j + i);
 8024c0a:	e953 ab04 	ldrd	sl, fp, [r3, #-16]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8024c0e:	ec51 0b19 	vmov	r0, r1, d9
 8024c12:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8024c16:	f003 f947 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 8024c1a:	ed96 8b00 	vldr	d8, [r6]
        const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
 8024c1e:	4604      	mov	r4, r0
 8024c20:	460d      	mov	r5, r1
        temp_r += A_real * x_real - A_imag * x_imag;
 8024c22:	4652      	mov	r2, sl
 8024c24:	465b      	mov	r3, fp
 8024c26:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, jx);
 8024c2a:	e9d6 8902 	ldrd	r8, r9, [r6, #8]
 8024c2e:	9606      	str	r6, [sp, #24]
        temp_r += A_real * x_real - A_imag * x_imag;
 8024c30:	f003 f93a 	bl	8027ea8 <__aeabi_dmul>
 8024c34:	4622      	mov	r2, r4
 8024c36:	462b      	mov	r3, r5
 8024c38:	4606      	mov	r6, r0
 8024c3a:	460f      	mov	r7, r1
 8024c3c:	4640      	mov	r0, r8
 8024c3e:	4649      	mov	r1, r9
 8024c40:	f003 f932 	bl	8027ea8 <__aeabi_dmul>
 8024c44:	4602      	mov	r2, r0
 8024c46:	460b      	mov	r3, r1
 8024c48:	4630      	mov	r0, r6
 8024c4a:	4639      	mov	r1, r7
 8024c4c:	f002 ff74 	bl	8027b38 <__aeabi_dsub>
 8024c50:	4602      	mov	r2, r0
 8024c52:	460b      	mov	r3, r1
 8024c54:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8024c58:	f002 ff70 	bl	8027b3c <__adddf3>
        temp_i += A_real * x_imag + A_imag * x_real;
 8024c5c:	4652      	mov	r2, sl
        temp_r += A_real * x_real - A_imag * x_imag;
 8024c5e:	4606      	mov	r6, r0
 8024c60:	460f      	mov	r7, r1
        temp_i += A_real * x_imag + A_imag * x_real;
 8024c62:	465b      	mov	r3, fp
 8024c64:	4640      	mov	r0, r8
 8024c66:	4649      	mov	r1, r9
        temp_r += A_real * x_real - A_imag * x_imag;
 8024c68:	e9cd 6702 	strd	r6, r7, [sp, #8]
        temp_i += A_real * x_imag + A_imag * x_real;
 8024c6c:	f003 f91c 	bl	8027ea8 <__aeabi_dmul>
 8024c70:	4622      	mov	r2, r4
 8024c72:	462b      	mov	r3, r5
 8024c74:	4604      	mov	r4, r0
 8024c76:	460d      	mov	r5, r1
 8024c78:	ec51 0b18 	vmov	r0, r1, d8
 8024c7c:	f003 f914 	bl	8027ea8 <__aeabi_dmul>
 8024c80:	4602      	mov	r2, r0
 8024c82:	460b      	mov	r3, r1
 8024c84:	4620      	mov	r0, r4
 8024c86:	4629      	mov	r1, r5
 8024c88:	f002 ff58 	bl	8027b3c <__adddf3>
 8024c8c:	4602      	mov	r2, r0
 8024c8e:	460b      	mov	r3, r1
 8024c90:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8024c94:	f002 ff52 	bl	8027b3c <__adddf3>
 8024c98:	9b01      	ldr	r3, [sp, #4]
 8024c9a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8024c9c:	9e06      	ldr	r6, [sp, #24]
      for (j = 0; j < j_max; j++) {
 8024c9e:	9c07      	ldr	r4, [sp, #28]
 8024ca0:	4413      	add	r3, r2
 8024ca2:	9301      	str	r3, [sp, #4]
 8024ca4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8024ca6:	18f3      	adds	r3, r6, r3
 8024ca8:	9306      	str	r3, [sp, #24]
 8024caa:	9b08      	ldr	r3, [sp, #32]
 8024cac:	3401      	adds	r4, #1
 8024cae:	42a3      	cmp	r3, r4
        temp_i += A_real * x_imag + A_imag * x_real;
 8024cb0:	e9cd 0104 	strd	r0, r1, [sp, #16]
      for (j = 0; j < j_max; j++) {
 8024cb4:	9407      	str	r4, [sp, #28]
 8024cb6:	d1a6      	bne.n	8024c06 <cblas_ztrmv+0x88e>
      if (nonunit) {
 8024cb8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024cba:	2b83      	cmp	r3, #131	; 0x83
 8024cbc:	d022      	beq.n	8024d04 <cblas_ztrmv+0x98c>
        REAL(X, ix) += temp_r;
 8024cbe:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8024cc0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8024cc4:	e954 0102 	ldrd	r0, r1, [r4, #-8]
 8024cc8:	f002 ff38 	bl	8027b3c <__adddf3>
        IMAG(X, ix) += temp_i;
 8024ccc:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
        REAL(X, ix) += temp_r;
 8024cd0:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) += temp_i;
 8024cd4:	e9d4 0100 	ldrd	r0, r1, [r4]
 8024cd8:	f002 ff30 	bl	8027b3c <__adddf3>
 8024cdc:	e9c4 0100 	strd	r0, r1, [r4]
    for (i = N; i > 0 && i--;) {
 8024ce0:	e9dd 320e 	ldrd	r3, r2, [sp, #56]	; 0x38
 8024ce4:	4413      	add	r3, r2
 8024ce6:	930e      	str	r3, [sp, #56]	; 0x38
 8024ce8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8024cea:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8024cec:	3b10      	subs	r3, #16
 8024cee:	930d      	str	r3, [sp, #52]	; 0x34
 8024cf0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024cf2:	4413      	add	r3, r2
 8024cf4:	930c      	str	r3, [sp, #48]	; 0x30
 8024cf6:	9b08      	ldr	r3, [sp, #32]
 8024cf8:	2b00      	cmp	r3, #0
 8024cfa:	f43f ac6f 	beq.w	80245dc <cblas_ztrmv+0x264>
 8024cfe:	3b01      	subs	r3, #1
 8024d00:	9308      	str	r3, [sp, #32]
 8024d02:	e76a      	b.n	8024bda <cblas_ztrmv+0x862>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024d04:	9d0e      	ldr	r5, [sp, #56]	; 0x38
        const BASE x_real = REAL(X, ix);
 8024d06:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8024d08:	ee1e 0a10 	vmov	r0, s28
 8024d0c:	f003 f862 	bl	8027dd4 <__aeabi_i2d>
 8024d10:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8024d14:	f003 f8c8 	bl	8027ea8 <__aeabi_dmul>
        const BASE A_real = CONST_REAL(A, lda * i + i);
 8024d18:	e9d5 ab00 	ldrd	sl, fp, [r5]
        const BASE x_real = REAL(X, ix);
 8024d1c:	ed14 8b02 	vldr	d8, [r4, #-8]
        const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
 8024d20:	4680      	mov	r8, r0
 8024d22:	4689      	mov	r9, r1
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024d24:	4652      	mov	r2, sl
 8024d26:	465b      	mov	r3, fp
 8024d28:	ec51 0b18 	vmov	r0, r1, d8
        const BASE x_imag = IMAG(X, ix);
 8024d2c:	e9d4 6700 	ldrd	r6, r7, [r4]
 8024d30:	940c      	str	r4, [sp, #48]	; 0x30
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024d32:	f003 f8b9 	bl	8027ea8 <__aeabi_dmul>
 8024d36:	4642      	mov	r2, r8
 8024d38:	4604      	mov	r4, r0
 8024d3a:	460d      	mov	r5, r1
 8024d3c:	464b      	mov	r3, r9
 8024d3e:	4630      	mov	r0, r6
 8024d40:	4639      	mov	r1, r7
 8024d42:	f003 f8b1 	bl	8027ea8 <__aeabi_dmul>
 8024d46:	4602      	mov	r2, r0
 8024d48:	460b      	mov	r3, r1
 8024d4a:	4620      	mov	r0, r4
 8024d4c:	4629      	mov	r1, r5
 8024d4e:	f002 fef3 	bl	8027b38 <__aeabi_dsub>
 8024d52:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8024d56:	f002 fef1 	bl	8027b3c <__adddf3>
 8024d5a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8024d5c:	4652      	mov	r2, sl
        REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
 8024d5e:	e944 0102 	strd	r0, r1, [r4, #-8]
        IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
 8024d62:	465b      	mov	r3, fp
 8024d64:	4630      	mov	r0, r6
 8024d66:	4639      	mov	r1, r7
 8024d68:	f003 f89e 	bl	8027ea8 <__aeabi_dmul>
 8024d6c:	4642      	mov	r2, r8
 8024d6e:	4604      	mov	r4, r0
 8024d70:	464b      	mov	r3, r9
 8024d72:	460d      	mov	r5, r1
 8024d74:	ec51 0b18 	vmov	r0, r1, d8
 8024d78:	f003 f896 	bl	8027ea8 <__aeabi_dmul>
 8024d7c:	4602      	mov	r2, r0
 8024d7e:	460b      	mov	r3, r1
 8024d80:	4620      	mov	r0, r4
 8024d82:	4629      	mov	r1, r5
 8024d84:	f002 feda 	bl	8027b3c <__adddf3>
 8024d88:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8024d8c:	f002 fed6 	bl	8027b3c <__adddf3>
 8024d90:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8024d92:	e9c4 0100 	strd	r0, r1, [r4]
 8024d96:	e7a3      	b.n	8024ce0 <cblas_ztrmv+0x968>
      for (j = 0; j < j_max; j++) {
 8024d98:	ed9f 7b0b 	vldr	d7, [pc, #44]	; 8024dc8 <cblas_ztrmv+0xa50>
 8024d9c:	eeb0 ca47 	vmov.f32	s24, s14
 8024da0:	eef0 ca67 	vmov.f32	s25, s15
 8024da4:	eeb0 ba47 	vmov.f32	s22, s14
 8024da8:	eef0 ba67 	vmov.f32	s23, s15
 8024dac:	e541      	b.n	8024832 <cblas_ztrmv+0x4ba>
      for (j = 0; j < j_max; j++) {
 8024dae:	ed9f 7b06 	vldr	d7, [pc, #24]	; 8024dc8 <cblas_ztrmv+0xa50>
 8024db2:	ed8d 7b04 	vstr	d7, [sp, #16]
 8024db6:	ed8d 7b02 	vstr	d7, [sp, #8]
 8024dba:	e77d      	b.n	8024cb8 <cblas_ztrmv+0x940>
  CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8024dbc:	2009      	movs	r0, #9
 8024dbe:	f7ff bb0e 	b.w	80243de <cblas_ztrmv+0x66>
 8024dc2:	bf00      	nop
 8024dc4:	f3af 8000 	nop.w
	...

08024dd0 <xhypot>:
{
 8024dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 8024dd2:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 8024dd6:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  if (xabs < yabs) {
 8024dda:	4639      	mov	r1, r7
 8024ddc:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 8024dde:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 8024de0:	4614      	mov	r4, r2
  if (xabs < yabs) {
 8024de2:	f003 fad3 	bl	802838c <__aeabi_dcmplt>
 8024de6:	b928      	cbnz	r0, 8024df4 <xhypot+0x24>
 8024de8:	4632      	mov	r2, r6
 8024dea:	463b      	mov	r3, r7
    min = yabs ;
 8024dec:	4626      	mov	r6, r4
 8024dee:	462f      	mov	r7, r5
    max = xabs ;
 8024df0:	4614      	mov	r4, r2
 8024df2:	461d      	mov	r5, r3
  if (min == 0) 
 8024df4:	2200      	movs	r2, #0
 8024df6:	2300      	movs	r3, #0
 8024df8:	4630      	mov	r0, r6
 8024dfa:	4639      	mov	r1, r7
 8024dfc:	f003 fabc 	bl	8028378 <__aeabi_dcmpeq>
 8024e00:	b9c8      	cbnz	r0, 8024e36 <xhypot+0x66>
    double u = min / max ;
 8024e02:	4622      	mov	r2, r4
 8024e04:	462b      	mov	r3, r5
 8024e06:	4630      	mov	r0, r6
 8024e08:	4639      	mov	r1, r7
 8024e0a:	f003 f977 	bl	80280fc <__aeabi_ddiv>
 8024e0e:	4602      	mov	r2, r0
 8024e10:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 8024e12:	f003 f849 	bl	8027ea8 <__aeabi_dmul>
 8024e16:	4b09      	ldr	r3, [pc, #36]	; (8024e3c <xhypot+0x6c>)
 8024e18:	2200      	movs	r2, #0
 8024e1a:	f002 fe8f 	bl	8027b3c <__adddf3>
 8024e1e:	ec41 0b10 	vmov	d0, r0, r1
 8024e22:	f00b f839 	bl	802fe98 <sqrt>
 8024e26:	4620      	mov	r0, r4
 8024e28:	4629      	mov	r1, r5
 8024e2a:	ec53 2b10 	vmov	r2, r3, d0
 8024e2e:	f003 f83b 	bl	8027ea8 <__aeabi_dmul>
 8024e32:	4604      	mov	r4, r0
 8024e34:	460d      	mov	r5, r1
}
 8024e36:	4620      	mov	r0, r4
 8024e38:	4629      	mov	r1, r5
 8024e3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024e3c:	3ff00000 	.word	0x3ff00000

08024e40 <cblas_ztrsm>:
cblas_ztrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
             const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
             const enum CBLAS_DIAG Diag, const int M, const int N,
             const void *alpha, const void *A, const int lda, void *B,
             const int ldb)
{
 8024e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024e44:	ed2d 8b0a 	vpush	{d8-d12}
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8024e48:	2b71      	cmp	r3, #113	; 0x71
 8024e4a:	b095      	sub	sp, #84	; 0x54
 8024e4c:	461d      	mov	r5, r3
 8024e4e:	bf0c      	ite	eq
 8024e50:	f04f 33ff 	moveq.w	r3, #4294967295
 8024e54:	2301      	movne	r3, #1
 8024e56:	ee0c 3a10 	vmov	s24, r3
 8024e5a:	f89d 30a0 	ldrb.w	r3, [sp, #160]	; 0xa0
 8024e5e:	9305      	str	r3, [sp, #20]
 8024e60:	9b29      	ldr	r3, [sp, #164]	; 0xa4
 8024e62:	9302      	str	r3, [sp, #8]
 8024e64:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8024e66:	9306      	str	r3, [sp, #24]
 8024e68:	e9dd 732b 	ldrd	r7, r3, [sp, #172]	; 0xac
 8024e6c:	930a      	str	r3, [sp, #40]	; 0x28
 8024e6e:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 8024e70:	9301      	str	r3, [sp, #4]
 8024e72:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 8024e74:	930c      	str	r3, [sp, #48]	; 0x30
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8024e76:	298d      	cmp	r1, #141	; 0x8d
 8024e78:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 8024e7a:	930b      	str	r3, [sp, #44]	; 0x2c
 8024e7c:	460c      	mov	r4, r1
 8024e7e:	4616      	mov	r6, r2
 8024e80:	d06c      	beq.n	8024f5c <cblas_ztrsm+0x11c>
 8024e82:	298e      	cmp	r1, #142	; 0x8e
 8024e84:	f000 85ff 	beq.w	8025a86 <cblas_ztrsm+0xc46>
 8024e88:	f8dd c018 	ldr.w	ip, [sp, #24]
 8024e8c:	2302      	movs	r3, #2
 8024e8e:	f1a6 0279 	sub.w	r2, r6, #121	; 0x79
 8024e92:	2a01      	cmp	r2, #1
 8024e94:	9a05      	ldr	r2, [sp, #20]
 8024e96:	f1a5 016f 	sub.w	r1, r5, #111	; 0x6f
 8024e9a:	f102 027d 	add.w	r2, r2, #125	; 0x7d
 8024e9e:	bf88      	it	hi
 8024ea0:	2303      	movhi	r3, #3
 8024ea2:	b2d2      	uxtb	r2, r2
 8024ea4:	2902      	cmp	r1, #2
 8024ea6:	bf88      	it	hi
 8024ea8:	2304      	movhi	r3, #4
 8024eaa:	2a02      	cmp	r2, #2
 8024eac:	9a02      	ldr	r2, [sp, #8]
 8024eae:	bf28      	it	cs
 8024eb0:	2305      	movcs	r3, #5
 8024eb2:	2a00      	cmp	r2, #0
 8024eb4:	9a06      	ldr	r2, [sp, #24]
 8024eb6:	bfb8      	it	lt
 8024eb8:	2306      	movlt	r3, #6
 8024eba:	2a00      	cmp	r2, #0
 8024ebc:	bfb8      	it	lt
 8024ebe:	2307      	movlt	r3, #7
 8024ec0:	9a01      	ldr	r2, [sp, #4]
 8024ec2:	f1bc 0f01 	cmp.w	ip, #1
 8024ec6:	bfb8      	it	lt
 8024ec8:	f04f 0c01 	movlt.w	ip, #1
 8024ecc:	4594      	cmp	ip, r2
 8024ece:	dd38      	ble.n	8024f42 <cblas_ztrsm+0x102>
 8024ed0:	2865      	cmp	r0, #101	; 0x65
 8024ed2:	f000 8189 	beq.w	80251e8 <cblas_ztrsm+0x3a8>
 8024ed6:	9b02      	ldr	r3, [sp, #8]
 8024ed8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8024eda:	2b01      	cmp	r3, #1
 8024edc:	bfb8      	it	lt
 8024ede:	2301      	movlt	r3, #1
 8024ee0:	4293      	cmp	r3, r2
 8024ee2:	bfcc      	ite	gt
 8024ee4:	230c      	movgt	r3, #12
 8024ee6:	230a      	movle	r3, #10
 8024ee8:	4abb      	ldr	r2, [pc, #748]	; (80251d8 <cblas_ztrsm+0x398>)
 8024eea:	49bc      	ldr	r1, [pc, #752]	; (80251dc <cblas_ztrsm+0x39c>)
 8024eec:	4618      	mov	r0, r3
 8024eee:	f002 fdab 	bl	8027a48 <cblas_xerbla>
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8024ef2:	2c8d      	cmp	r4, #141	; 0x8d
    const BASE alpha_real = CONST_REAL0(alpha);
 8024ef4:	ed97 7b00 	vldr	d7, [r7]
      side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
 8024ef8:	bf0c      	ite	eq
 8024efa:	248e      	moveq	r4, #142	; 0x8e
 8024efc:	248d      	movne	r4, #141	; 0x8d
    const BASE alpha_imag = CONST_IMAG0(alpha);
 8024efe:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
    const BASE alpha_real = CONST_REAL0(alpha);
 8024f02:	eeb0 8a47 	vmov.f32	s16, s14
 8024f06:	eef0 8a67 	vmov.f32	s17, s15
      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
 8024f0a:	2e79      	cmp	r6, #121	; 0x79
 8024f0c:	bf0c      	ite	eq
 8024f0e:	267a      	moveq	r6, #122	; 0x7a
 8024f10:	2679      	movne	r6, #121	; 0x79
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
 8024f12:	2d6f      	cmp	r5, #111	; 0x6f
 8024f14:	bf0c      	ite	eq
 8024f16:	256f      	moveq	r5, #111	; 0x6f
 8024f18:	2570      	movne	r5, #112	; 0x70
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8024f1a:	2c8d      	cmp	r4, #141	; 0x8d
 8024f1c:	d027      	beq.n	8024f6e <cblas_ztrsm+0x12e>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 8024f1e:	2c8e      	cmp	r4, #142	; 0x8e
 8024f20:	d105      	bne.n	8024f2e <cblas_ztrsm+0xee>
 8024f22:	2e79      	cmp	r6, #121	; 0x79
 8024f24:	f000 8183 	beq.w	802522e <cblas_ztrsm+0x3ee>
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8024f28:	2e7a      	cmp	r6, #122	; 0x7a
 8024f2a:	f000 82f7 	beq.w	802551c <cblas_ztrsm+0x6dc>
      BLAS_ERROR("unrecognized operation");
 8024f2e:	4aac      	ldr	r2, [pc, #688]	; (80251e0 <cblas_ztrsm+0x3a0>)
 8024f30:	49aa      	ldr	r1, [pc, #680]	; (80251dc <cblas_ztrsm+0x39c>)
 8024f32:	2000      	movs	r0, #0
#define BASE double
#include "source_trsm_c.h"
#undef BASE
}
 8024f34:	b015      	add	sp, #84	; 0x54
 8024f36:	ecbd 8b0a 	vpop	{d8-d12}
 8024f3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024f3e:	f002 bd83 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8024f42:	2865      	cmp	r0, #101	; 0x65
 8024f44:	f000 845d 	beq.w	8025802 <cblas_ztrsm+0x9c2>
 8024f48:	9a02      	ldr	r2, [sp, #8]
 8024f4a:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8024f4c:	2a01      	cmp	r2, #1
 8024f4e:	bfb8      	it	lt
 8024f50:	2201      	movlt	r2, #1
 8024f52:	428a      	cmp	r2, r1
 8024f54:	f340 8167 	ble.w	8025226 <cblas_ztrsm+0x3e6>
 8024f58:	230c      	movs	r3, #12
 8024f5a:	e7c5      	b.n	8024ee8 <cblas_ztrsm+0xa8>
 8024f5c:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8024f60:	2b01      	cmp	r3, #1
 8024f62:	f8dd c008 	ldr.w	ip, [sp, #8]
 8024f66:	bf94      	ite	ls
 8024f68:	2300      	movls	r3, #0
 8024f6a:	2301      	movhi	r3, #1
 8024f6c:	e78f      	b.n	8024e8e <cblas_ztrsm+0x4e>
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8024f6e:	2e79      	cmp	r6, #121	; 0x79
 8024f70:	f000 8454 	beq.w	802581c <cblas_ztrsm+0x9dc>
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8024f74:	2e7a      	cmp	r6, #122	; 0x7a
 8024f76:	d1da      	bne.n	8024f2e <cblas_ztrsm+0xee>
 8024f78:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8024f7a:	4b9a      	ldr	r3, [pc, #616]	; (80251e4 <cblas_ztrsm+0x3a4>)
 8024f7c:	ec51 0b18 	vmov	r0, r1, d8
 8024f80:	f04f 0200 	mov.w	r2, #0
    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
 8024f84:	f000 86c4 	beq.w	8025d10 <cblas_ztrsm+0xed0>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8024f88:	f003 f9f6 	bl	8028378 <__aeabi_dcmpeq>
 8024f8c:	2800      	cmp	r0, #0
 8024f8e:	f040 8597 	bne.w	8025ac0 <cblas_ztrsm+0xc80>
        for (i = 0; i < n1; i++) {
 8024f92:	9b06      	ldr	r3, [sp, #24]
 8024f94:	2b00      	cmp	r3, #0
 8024f96:	f340 85df 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8024f9a:	9a02      	ldr	r2, [sp, #8]
 8024f9c:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8024fa0:	011b      	lsls	r3, r3, #4
 8024fa2:	9307      	str	r3, [sp, #28]
 8024fa4:	3308      	adds	r3, #8
 8024fa6:	9308      	str	r3, [sp, #32]
 8024fa8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8024faa:	011b      	lsls	r3, r3, #4
 8024fac:	9303      	str	r3, [sp, #12]
 8024fae:	0113      	lsls	r3, r2, #4
 8024fb0:	9310      	str	r3, [sp, #64]	; 0x40
 8024fb2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8024fb4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8024fb8:	9300      	str	r3, [sp, #0]
 8024fba:	2300      	movs	r3, #0
 8024fbc:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8024fbe:	9b02      	ldr	r3, [sp, #8]
 8024fc0:	2b00      	cmp	r3, #0
 8024fc2:	dd3e      	ble.n	8025042 <cblas_ztrsm+0x202>
 8024fc4:	9b07      	ldr	r3, [sp, #28]
 8024fc6:	9a08      	ldr	r2, [sp, #32]
 8024fc8:	4619      	mov	r1, r3
 8024fca:	9b00      	ldr	r3, [sp, #0]
 8024fcc:	eb01 0803 	add.w	r8, r1, r3
 8024fd0:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8024fd4:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8024fd8:	ec53 2b18 	vmov	r2, r3, d8
 8024fdc:	4630      	mov	r0, r6
 8024fde:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8024fe0:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8024fe4:	f002 ff60 	bl	8027ea8 <__aeabi_dmul>
 8024fe8:	4652      	mov	r2, sl
 8024fea:	ec41 0b19 	vmov	d9, r0, r1
 8024fee:	465b      	mov	r3, fp
 8024ff0:	4620      	mov	r0, r4
 8024ff2:	4629      	mov	r1, r5
 8024ff4:	f002 ff58 	bl	8027ea8 <__aeabi_dmul>
 8024ff8:	4602      	mov	r2, r0
 8024ffa:	460b      	mov	r3, r1
 8024ffc:	ec51 0b19 	vmov	r0, r1, d9
 8025000:	f002 fd9a 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025004:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025008:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802500c:	4620      	mov	r0, r4
 802500e:	4629      	mov	r1, r5
 8025010:	f002 ff4a 	bl	8027ea8 <__aeabi_dmul>
 8025014:	4652      	mov	r2, sl
 8025016:	465b      	mov	r3, fp
 8025018:	4604      	mov	r4, r0
 802501a:	460d      	mov	r5, r1
 802501c:	4630      	mov	r0, r6
 802501e:	4639      	mov	r1, r7
 8025020:	f002 ff42 	bl	8027ea8 <__aeabi_dmul>
 8025024:	460b      	mov	r3, r1
 8025026:	4602      	mov	r2, r0
 8025028:	4629      	mov	r1, r5
 802502a:	4620      	mov	r0, r4
 802502c:	f002 fd86 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 8025030:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8025032:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8025036:	f108 0810 	add.w	r8, r8, #16
 802503a:	4543      	cmp	r3, r8
 802503c:	f109 0910 	add.w	r9, r9, #16
 8025040:	d1c8      	bne.n	8024fd4 <cblas_ztrsm+0x194>
        for (i = 0; i < n1; i++) {
 8025042:	9a00      	ldr	r2, [sp, #0]
 8025044:	9903      	ldr	r1, [sp, #12]
 8025046:	9b04      	ldr	r3, [sp, #16]
 8025048:	440a      	add	r2, r1
 802504a:	9200      	str	r2, [sp, #0]
 802504c:	9a06      	ldr	r2, [sp, #24]
 802504e:	3301      	adds	r3, #1
 8025050:	429a      	cmp	r2, r3
 8025052:	9304      	str	r3, [sp, #16]
 8025054:	d1b3      	bne.n	8024fbe <cblas_ztrsm+0x17e>
 8025056:	9806      	ldr	r0, [sp, #24]
 8025058:	9901      	ldr	r1, [sp, #4]
 802505a:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 802505c:	1e42      	subs	r2, r0, #1
 802505e:	460b      	mov	r3, r1
 8025060:	fb03 f302 	mul.w	r3, r3, r2
 8025064:	ebc4 7504 	rsb	r5, r4, r4, lsl #28
 8025068:	18c6      	adds	r6, r0, r3
 802506a:	012c      	lsls	r4, r5, #4
 802506c:	980a      	ldr	r0, [sp, #40]	; 0x28
 802506e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8025070:	9207      	str	r2, [sp, #28]
 8025072:	f1a0 0c10 	sub.w	ip, r0, #16
 8025076:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 802507a:	fb01 2002 	mla	r0, r1, r2, r2
 802507e:	9309      	str	r3, [sp, #36]	; 0x24
 8025080:	eb0c 1306 	add.w	r3, ip, r6, lsl #4
 8025084:	4617      	mov	r7, r2
 8025086:	9306      	str	r3, [sp, #24]
 8025088:	460a      	mov	r2, r1
 802508a:	eb05 1300 	add.w	r3, r5, r0, lsl #4
 802508e:	ebc2 7202 	rsb	r2, r2, r2, lsl #28
 8025092:	930a      	str	r3, [sp, #40]	; 0x28
 8025094:	9b03      	ldr	r3, [sp, #12]
 8025096:	940e      	str	r4, [sp, #56]	; 0x38
 8025098:	0112      	lsls	r2, r2, #4
 802509a:	461c      	mov	r4, r3
 802509c:	920f      	str	r2, [sp, #60]	; 0x3c
 802509e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80250a0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80250a2:	43c9      	mvns	r1, r1
 80250a4:	fb04 3007 	mla	r0, r4, r7, r3
 80250a8:	0109      	lsls	r1, r1, #4
 80250aa:	4413      	add	r3, r2
 80250ac:	9008      	str	r0, [sp, #32]
 80250ae:	910b      	str	r1, [sp, #44]	; 0x2c
 80250b0:	930d      	str	r3, [sp, #52]	; 0x34
        if (nonunit) {
 80250b2:	9b05      	ldr	r3, [sp, #20]
 80250b4:	2b83      	cmp	r3, #131	; 0x83
 80250b6:	f001 8442 	beq.w	802693e <cblas_ztrsm+0x1afe>
        for (k = 0; k < i; k++) {
 80250ba:	9b07      	ldr	r3, [sp, #28]
 80250bc:	2b00      	cmp	r3, #0
 80250be:	f000 854b 	beq.w	8025b58 <cblas_ztrsm+0xd18>
 80250c2:	ee1c 0a10 	vmov	r0, s24
 80250c6:	f002 fe85 	bl	8027dd4 <__aeabi_i2d>
 80250ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80250cc:	9301      	str	r3, [sp, #4]
 80250ce:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80250d0:	9304      	str	r3, [sp, #16]
 80250d2:	ec41 0b1b 	vmov	d11, r0, r1
 80250d6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80250d8:	9300      	str	r3, [sp, #0]
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80250da:	9c00      	ldr	r4, [sp, #0]
 80250dc:	ec51 0b1b 	vmov	r0, r1, d11
 80250e0:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80250e4:	f002 fee0 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80250e8:	ed94 7b00 	vldr	d7, [r4]
          for (j = 0; j < n2; j++) {
 80250ec:	9b02      	ldr	r3, [sp, #8]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 80250ee:	eeb0 9a47 	vmov.f32	s18, s14
 80250f2:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 80250f6:	2b00      	cmp	r3, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 80250f8:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 80250fc:	dd49      	ble.n	8025192 <cblas_ztrsm+0x352>
 80250fe:	9b04      	ldr	r3, [sp, #16]
 8025100:	9c08      	ldr	r4, [sp, #32]
 8025102:	9d01      	ldr	r5, [sp, #4]
 8025104:	f103 0b08 	add.w	fp, r3, #8
 8025108:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 802510a:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 802510e:	ec51 0b19 	vmov	r0, r1, d9
 8025112:	4632      	mov	r2, r6
 8025114:	463b      	mov	r3, r7
 8025116:	f002 fec7 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802511a:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 802511e:	ec41 0b1a 	vmov	d10, r0, r1
 8025122:	4642      	mov	r2, r8
 8025124:	464b      	mov	r3, r9
 8025126:	ec51 0b18 	vmov	r0, r1, d8
 802512a:	f002 febd 	bl	8027ea8 <__aeabi_dmul>
 802512e:	4602      	mov	r2, r0
 8025130:	460b      	mov	r3, r1
 8025132:	ec51 0b1a 	vmov	r0, r1, d10
 8025136:	f002 fcff 	bl	8027b38 <__aeabi_dsub>
 802513a:	4602      	mov	r2, r0
 802513c:	460b      	mov	r3, r1
 802513e:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8025142:	f002 fcf9 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 8025146:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 8025148:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 802514c:	464b      	mov	r3, r9
 802514e:	ec51 0b19 	vmov	r0, r1, d9
 8025152:	f002 fea9 	bl	8027ea8 <__aeabi_dmul>
 8025156:	4632      	mov	r2, r6
 8025158:	463b      	mov	r3, r7
 802515a:	4606      	mov	r6, r0
 802515c:	460f      	mov	r7, r1
 802515e:	ec51 0b18 	vmov	r0, r1, d8
 8025162:	f002 fea1 	bl	8027ea8 <__aeabi_dmul>
 8025166:	4602      	mov	r2, r0
 8025168:	460b      	mov	r3, r1
 802516a:	4630      	mov	r0, r6
 802516c:	4639      	mov	r1, r7
 802516e:	f002 fce5 	bl	8027b3c <__adddf3>
 8025172:	4602      	mov	r2, r0
 8025174:	460b      	mov	r3, r1
 8025176:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 802517a:	f002 fcdd 	bl	8027b38 <__aeabi_dsub>
 802517e:	f10a 0a10 	add.w	sl, sl, #16
 8025182:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8025186:	4555      	cmp	r5, sl
 8025188:	f104 0410 	add.w	r4, r4, #16
 802518c:	f10b 0b10 	add.w	fp, fp, #16
 8025190:	d1bb      	bne.n	802510a <cblas_ztrsm+0x2ca>
        for (k = 0; k < i; k++) {
 8025192:	9904      	ldr	r1, [sp, #16]
 8025194:	9a03      	ldr	r2, [sp, #12]
 8025196:	9b00      	ldr	r3, [sp, #0]
 8025198:	4608      	mov	r0, r1
 802519a:	9901      	ldr	r1, [sp, #4]
 802519c:	4410      	add	r0, r2
 802519e:	4411      	add	r1, r2
 80251a0:	9a06      	ldr	r2, [sp, #24]
 80251a2:	9004      	str	r0, [sp, #16]
 80251a4:	3310      	adds	r3, #16
 80251a6:	429a      	cmp	r2, r3
 80251a8:	9300      	str	r3, [sp, #0]
 80251aa:	9101      	str	r1, [sp, #4]
 80251ac:	d195      	bne.n	80250da <cblas_ztrsm+0x29a>
 80251ae:	9a06      	ldr	r2, [sp, #24]
 80251b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80251b2:	4611      	mov	r1, r2
 80251b4:	4419      	add	r1, r3
 80251b6:	9a08      	ldr	r2, [sp, #32]
 80251b8:	9106      	str	r1, [sp, #24]
 80251ba:	990e      	ldr	r1, [sp, #56]	; 0x38
 80251bc:	440a      	add	r2, r1
 80251be:	9208      	str	r2, [sp, #32]
 80251c0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80251c2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80251c4:	440a      	add	r2, r1
 80251c6:	9209      	str	r2, [sp, #36]	; 0x24
 80251c8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80251ca:	441a      	add	r2, r3
 80251cc:	9b07      	ldr	r3, [sp, #28]
 80251ce:	920a      	str	r2, [sp, #40]	; 0x28
 80251d0:	3b01      	subs	r3, #1
 80251d2:	9307      	str	r3, [sp, #28]
 80251d4:	e76d      	b.n	80250b2 <cblas_ztrsm+0x272>
 80251d6:	bf00      	nop
 80251d8:	08030378 	.word	0x08030378
 80251dc:	080307a4 	.word	0x080307a4
 80251e0:	080305a8 	.word	0x080305a8
 80251e4:	3ff00000 	.word	0x3ff00000
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 80251e8:	9b06      	ldr	r3, [sp, #24]
 80251ea:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80251ec:	2b01      	cmp	r3, #1
 80251ee:	bfb8      	it	lt
 80251f0:	2301      	movlt	r3, #1
 80251f2:	4293      	cmp	r3, r2
 80251f4:	bfcc      	ite	gt
 80251f6:	230c      	movgt	r3, #12
 80251f8:	230a      	movle	r3, #10
 80251fa:	4ac5      	ldr	r2, [pc, #788]	; (8025510 <cblas_ztrsm+0x6d0>)
 80251fc:	49c5      	ldr	r1, [pc, #788]	; (8025514 <cblas_ztrsm+0x6d4>)
 80251fe:	4618      	mov	r0, r3
 8025200:	f002 fc22 	bl	8027a48 <cblas_xerbla>
    const BASE alpha_real = CONST_REAL0(alpha);
 8025204:	ed97 7b00 	vldr	d7, [r7]
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8025208:	2d6f      	cmp	r5, #111	; 0x6f
    const BASE alpha_imag = CONST_IMAG0(alpha);
 802520a:	e9d7 ab02 	ldrd	sl, fp, [r7, #8]
    const BASE alpha_real = CONST_REAL0(alpha);
 802520e:	eeb0 8a47 	vmov.f32	s16, s14
 8025212:	eef0 8a67 	vmov.f32	s17, s15
      trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
 8025216:	9b06      	ldr	r3, [sp, #24]
 8025218:	f000 842b 	beq.w	8025a72 <cblas_ztrsm+0xc32>
 802521c:	9a02      	ldr	r2, [sp, #8]
 802521e:	9206      	str	r2, [sp, #24]
 8025220:	2570      	movs	r5, #112	; 0x70
 8025222:	9302      	str	r3, [sp, #8]
 8025224:	e679      	b.n	8024f1a <cblas_ztrsm+0xda>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025226:	2b00      	cmp	r3, #0
 8025228:	f43f ae63 	beq.w	8024ef2 <cblas_ztrsm+0xb2>
 802522c:	e65c      	b.n	8024ee8 <cblas_ztrsm+0xa8>
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 802522e:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025230:	4bb9      	ldr	r3, [pc, #740]	; (8025518 <cblas_ztrsm+0x6d8>)
 8025232:	ec51 0b18 	vmov	r0, r1, d8
 8025236:	f04f 0200 	mov.w	r2, #0
    } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
 802523a:	f000 863e 	beq.w	8025eba <cblas_ztrsm+0x107a>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802523e:	f003 f89b 	bl	8028378 <__aeabi_dcmpeq>
 8025242:	2800      	cmp	r0, #0
 8025244:	f040 8465 	bne.w	8025b12 <cblas_ztrsm+0xcd2>
        for (i = 0; i < n1; i++) {
 8025248:	9b06      	ldr	r3, [sp, #24]
 802524a:	2b00      	cmp	r3, #0
 802524c:	f340 8484 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8025250:	9a02      	ldr	r2, [sp, #8]
 8025252:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8025254:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8025258:	011b      	lsls	r3, r3, #4
 802525a:	9307      	str	r3, [sp, #28]
 802525c:	3308      	adds	r3, #8
 802525e:	9308      	str	r3, [sp, #32]
 8025260:	0113      	lsls	r3, r2, #4
 8025262:	9310      	str	r3, [sp, #64]	; 0x40
 8025264:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025266:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802526a:	0109      	lsls	r1, r1, #4
 802526c:	9300      	str	r3, [sp, #0]
 802526e:	2300      	movs	r3, #0
 8025270:	9103      	str	r1, [sp, #12]
 8025272:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8025274:	9b02      	ldr	r3, [sp, #8]
 8025276:	2b00      	cmp	r3, #0
 8025278:	dd3d      	ble.n	80252f6 <cblas_ztrsm+0x4b6>
 802527a:	9b00      	ldr	r3, [sp, #0]
 802527c:	9907      	ldr	r1, [sp, #28]
 802527e:	9a08      	ldr	r2, [sp, #32]
 8025280:	eb03 0801 	add.w	r8, r3, r1
 8025284:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025288:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802528c:	ec53 2b18 	vmov	r2, r3, d8
 8025290:	4630      	mov	r0, r6
 8025292:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025294:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025298:	f002 fe06 	bl	8027ea8 <__aeabi_dmul>
 802529c:	4652      	mov	r2, sl
 802529e:	ec41 0b19 	vmov	d9, r0, r1
 80252a2:	465b      	mov	r3, fp
 80252a4:	4620      	mov	r0, r4
 80252a6:	4629      	mov	r1, r5
 80252a8:	f002 fdfe 	bl	8027ea8 <__aeabi_dmul>
 80252ac:	4602      	mov	r2, r0
 80252ae:	460b      	mov	r3, r1
 80252b0:	ec51 0b19 	vmov	r0, r1, d9
 80252b4:	f002 fc40 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80252b8:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80252bc:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80252c0:	4620      	mov	r0, r4
 80252c2:	4629      	mov	r1, r5
 80252c4:	f002 fdf0 	bl	8027ea8 <__aeabi_dmul>
 80252c8:	4652      	mov	r2, sl
 80252ca:	465b      	mov	r3, fp
 80252cc:	4604      	mov	r4, r0
 80252ce:	460d      	mov	r5, r1
 80252d0:	4630      	mov	r0, r6
 80252d2:	4639      	mov	r1, r7
 80252d4:	f002 fde8 	bl	8027ea8 <__aeabi_dmul>
 80252d8:	460b      	mov	r3, r1
 80252da:	4602      	mov	r2, r0
 80252dc:	4629      	mov	r1, r5
 80252de:	4620      	mov	r0, r4
 80252e0:	f002 fc2c 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 80252e4:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80252e6:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 80252ea:	f108 0810 	add.w	r8, r8, #16
 80252ee:	4598      	cmp	r8, r3
 80252f0:	f109 0910 	add.w	r9, r9, #16
 80252f4:	d1c8      	bne.n	8025288 <cblas_ztrsm+0x448>
        for (i = 0; i < n1; i++) {
 80252f6:	9a00      	ldr	r2, [sp, #0]
 80252f8:	9903      	ldr	r1, [sp, #12]
 80252fa:	9b04      	ldr	r3, [sp, #16]
 80252fc:	440a      	add	r2, r1
 80252fe:	9200      	str	r2, [sp, #0]
 8025300:	9a06      	ldr	r2, [sp, #24]
 8025302:	3301      	adds	r3, #1
 8025304:	429a      	cmp	r2, r3
 8025306:	9304      	str	r3, [sp, #16]
 8025308:	d1b4      	bne.n	8025274 <cblas_ztrsm+0x434>
 802530a:	9a01      	ldr	r2, [sp, #4]
 802530c:	980c      	ldr	r0, [sp, #48]	; 0x30
 802530e:	9007      	str	r0, [sp, #28]
 8025310:	43d1      	mvns	r1, r2
 8025312:	1c53      	adds	r3, r2, #1
 8025314:	0109      	lsls	r1, r1, #4
 8025316:	9a02      	ldr	r2, [sp, #8]
 8025318:	9109      	str	r1, [sp, #36]	; 0x24
 802531a:	990a      	ldr	r1, [sp, #40]	; 0x28
 802531c:	9810      	ldr	r0, [sp, #64]	; 0x40
 802531e:	011b      	lsls	r3, r3, #4
 8025320:	3a01      	subs	r2, #1
 8025322:	fb03 1202 	mla	r2, r3, r2, r1
 8025326:	3b10      	subs	r3, #16
 8025328:	3810      	subs	r0, #16
 802532a:	9308      	str	r3, [sp, #32]
        for (j = n2; j > 0 && j--;) {
 802532c:	2300      	movs	r3, #0
 802532e:	900d      	str	r0, [sp, #52]	; 0x34
 8025330:	920c      	str	r2, [sp, #48]	; 0x30
 8025332:	930b      	str	r3, [sp, #44]	; 0x2c
 8025334:	9b02      	ldr	r3, [sp, #8]
 8025336:	2b00      	cmp	r3, #0
 8025338:	f340 8413 	ble.w	8025b62 <cblas_ztrsm+0xd22>
 802533c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802533e:	9907      	ldr	r1, [sp, #28]
 8025340:	9301      	str	r3, [sp, #4]
          if (nonunit) {
 8025342:	9b05      	ldr	r3, [sp, #20]
 8025344:	440a      	add	r2, r1
 8025346:	9200      	str	r2, [sp, #0]
 8025348:	2b83      	cmp	r3, #131	; 0x83
        for (j = n2; j > 0 && j--;) {
 802534a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802534c:	9204      	str	r2, [sp, #16]
          if (nonunit) {
 802534e:	d074      	beq.n	802543a <cblas_ztrsm+0x5fa>
 8025350:	9b00      	ldr	r3, [sp, #0]
 8025352:	ed93 7b02 	vldr	d7, [r3, #8]
 8025356:	eeb0 8a47 	vmov.f32	s16, s14
 802535a:	eef0 8a67 	vmov.f32	s17, s15
            const BASE Bij_real = REAL(B, ldb * i + j);
 802535e:	9b00      	ldr	r3, [sp, #0]
            for (k = 0; k < j; k++) {
 8025360:	9c01      	ldr	r4, [sp, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025362:	ed93 7b00 	vldr	d7, [r3]
            for (k = 0; k < j; k++) {
 8025366:	2c01      	cmp	r4, #1
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025368:	eeb0 9a47 	vmov.f32	s18, s14
 802536c:	eef0 9a67 	vmov.f32	s19, s15
            for (k = 0; k < j; k++) {
 8025370:	f000 83f7 	beq.w	8025b62 <cblas_ztrsm+0xd22>
 8025374:	ee1c 0a10 	vmov	r0, s24
 8025378:	f002 fd2c 	bl	8027dd4 <__aeabi_i2d>
 802537c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802537e:	9e07      	ldr	r6, [sp, #28]
 8025380:	9f08      	ldr	r7, [sp, #32]
 8025382:	ec41 0b1b 	vmov	d11, r0, r1
 8025386:	eb03 1b04 	add.w	fp, r3, r4, lsl #4
 802538a:	f106 0a08 	add.w	sl, r6, #8
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802538e:	e95b 2302 	ldrd	r2, r3, [fp, #-8]
 8025392:	ec51 0b1b 	vmov	r0, r1, d11
 8025396:	f002 fd87 	bl	8027ea8 <__aeabi_dmul>
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802539a:	e95b 8904 	ldrd	r8, r9, [fp, #-16]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802539e:	4604      	mov	r4, r0
 80253a0:	460d      	mov	r5, r1
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80253a2:	4642      	mov	r2, r8
 80253a4:	464b      	mov	r3, r9
 80253a6:	ec51 0b19 	vmov	r0, r1, d9
 80253aa:	f002 fd7d 	bl	8027ea8 <__aeabi_dmul>
 80253ae:	ec53 2b18 	vmov	r2, r3, d8
 80253b2:	ec41 0b1a 	vmov	d10, r0, r1
 80253b6:	4620      	mov	r0, r4
 80253b8:	4629      	mov	r1, r5
 80253ba:	f002 fd75 	bl	8027ea8 <__aeabi_dmul>
 80253be:	4602      	mov	r2, r0
 80253c0:	460b      	mov	r3, r1
 80253c2:	ec51 0b1a 	vmov	r0, r1, d10
 80253c6:	f002 fbb7 	bl	8027b38 <__aeabi_dsub>
 80253ca:	4602      	mov	r2, r0
 80253cc:	460b      	mov	r3, r1
 80253ce:	e95a 0102 	ldrd	r0, r1, [sl, #-8]
 80253d2:	f002 fbb1 	bl	8027b38 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80253d6:	ec53 2b18 	vmov	r2, r3, d8
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80253da:	e94a 0102 	strd	r0, r1, [sl, #-8]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80253de:	4640      	mov	r0, r8
 80253e0:	4649      	mov	r1, r9
 80253e2:	f002 fd61 	bl	8027ea8 <__aeabi_dmul>
 80253e6:	4622      	mov	r2, r4
 80253e8:	462b      	mov	r3, r5
 80253ea:	4604      	mov	r4, r0
 80253ec:	460d      	mov	r5, r1
 80253ee:	ec51 0b19 	vmov	r0, r1, d9
 80253f2:	f002 fd59 	bl	8027ea8 <__aeabi_dmul>
 80253f6:	4602      	mov	r2, r0
 80253f8:	460b      	mov	r3, r1
 80253fa:	4620      	mov	r0, r4
 80253fc:	4629      	mov	r1, r5
 80253fe:	f002 fb9d 	bl	8027b3c <__adddf3>
 8025402:	460b      	mov	r3, r1
 8025404:	4602      	mov	r2, r0
 8025406:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
 802540a:	f002 fb95 	bl	8027b38 <__aeabi_dsub>
            for (k = 0; k < j; k++) {
 802540e:	9b00      	ldr	r3, [sp, #0]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8025410:	e9c6 0102 	strd	r0, r1, [r6, #8]
            for (k = 0; k < j; k++) {
 8025414:	3610      	adds	r6, #16
 8025416:	429e      	cmp	r6, r3
 8025418:	44bb      	add	fp, r7
 802541a:	f10a 0a10 	add.w	sl, sl, #16
 802541e:	d1b6      	bne.n	802538e <cblas_ztrsm+0x54e>
 8025420:	9b01      	ldr	r3, [sp, #4]
 8025422:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8025424:	3b01      	subs	r3, #1
 8025426:	9301      	str	r3, [sp, #4]
 8025428:	9b00      	ldr	r3, [sp, #0]
 802542a:	3b10      	subs	r3, #16
 802542c:	9300      	str	r3, [sp, #0]
 802542e:	9b04      	ldr	r3, [sp, #16]
 8025430:	4413      	add	r3, r2
 8025432:	9304      	str	r3, [sp, #16]
          if (nonunit) {
 8025434:	9b05      	ldr	r3, [sp, #20]
 8025436:	2b83      	cmp	r3, #131	; 0x83
 8025438:	d18a      	bne.n	8025350 <cblas_ztrsm+0x510>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 802543a:	ee1c 0a10 	vmov	r0, s24
 802543e:	f002 fcc9 	bl	8027dd4 <__aeabi_i2d>
 8025442:	9c04      	ldr	r4, [sp, #16]
 8025444:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8025448:	f002 fd2e 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 802544c:	e9d4 4500 	ldrd	r4, r5, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8025450:	4606      	mov	r6, r0
 8025452:	460f      	mov	r7, r1
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8025454:	4632      	mov	r2, r6
 8025456:	463b      	mov	r3, r7
 8025458:	4620      	mov	r0, r4
 802545a:	4629      	mov	r1, r5
 802545c:	f7ff fcb8 	bl	8024dd0 <xhypot>
 8025460:	4680      	mov	r8, r0
 8025462:	4689      	mov	r9, r1
            const BASE a_real = Ajj_real / s;
 8025464:	4620      	mov	r0, r4
 8025466:	4629      	mov	r1, r5
 8025468:	4642      	mov	r2, r8
 802546a:	464b      	mov	r3, r9
 802546c:	f002 fe46 	bl	80280fc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 8025470:	4642      	mov	r2, r8
            const BASE a_real = Ajj_real / s;
 8025472:	4682      	mov	sl, r0
 8025474:	468b      	mov	fp, r1
            const BASE a_imag = Ajj_imag / s;
 8025476:	464b      	mov	r3, r9
 8025478:	4630      	mov	r0, r6
 802547a:	4639      	mov	r1, r7
 802547c:	f002 fe3e 	bl	80280fc <__aeabi_ddiv>
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025480:	9e00      	ldr	r6, [sp, #0]
 8025482:	ed96 7b00 	vldr	d7, [r6]
            const BASE a_imag = Ajj_imag / s;
 8025486:	4604      	mov	r4, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8025488:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 802548c:	eeb0 9a47 	vmov.f32	s18, s14
 8025490:	eef0 9a67 	vmov.f32	s19, s15
            const BASE a_imag = Ajj_imag / s;
 8025494:	460d      	mov	r5, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8025496:	4650      	mov	r0, sl
 8025498:	4659      	mov	r1, fp
 802549a:	f002 fd05 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802549e:	e9d6 6702 	ldrd	r6, r7, [r6, #8]
            const BASE a_imag = Ajj_imag / s;
 80254a2:	ec45 4b18 	vmov	d8, r4, r5
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80254a6:	4632      	mov	r2, r6
 80254a8:	4604      	mov	r4, r0
 80254aa:	460d      	mov	r5, r1
 80254ac:	463b      	mov	r3, r7
 80254ae:	ec51 0b18 	vmov	r0, r1, d8
 80254b2:	f002 fcf9 	bl	8027ea8 <__aeabi_dmul>
 80254b6:	4602      	mov	r2, r0
 80254b8:	460b      	mov	r3, r1
 80254ba:	4620      	mov	r0, r4
 80254bc:	4629      	mov	r1, r5
 80254be:	f002 fb3d 	bl	8027b3c <__adddf3>
 80254c2:	4642      	mov	r2, r8
 80254c4:	464b      	mov	r3, r9
 80254c6:	f002 fe19 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80254ca:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80254cc:	9e00      	ldr	r6, [sp, #0]
 80254ce:	4604      	mov	r4, r0
 80254d0:	460d      	mov	r5, r1
 80254d2:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80254d6:	463b      	mov	r3, r7
 80254d8:	4650      	mov	r0, sl
 80254da:	4659      	mov	r1, fp
 80254dc:	f002 fce4 	bl	8027ea8 <__aeabi_dmul>
 80254e0:	ec53 2b19 	vmov	r2, r3, d9
 80254e4:	4604      	mov	r4, r0
 80254e6:	460d      	mov	r5, r1
 80254e8:	ec51 0b18 	vmov	r0, r1, d8
 80254ec:	f002 fcdc 	bl	8027ea8 <__aeabi_dmul>
 80254f0:	4602      	mov	r2, r0
 80254f2:	460b      	mov	r3, r1
 80254f4:	4620      	mov	r0, r4
 80254f6:	4629      	mov	r1, r5
 80254f8:	f002 fb1e 	bl	8027b38 <__aeabi_dsub>
 80254fc:	4642      	mov	r2, r8
 80254fe:	464b      	mov	r3, r9
 8025500:	f002 fdfc 	bl	80280fc <__aeabi_ddiv>
 8025504:	e9c6 0102 	strd	r0, r1, [r6, #8]
 8025508:	ec41 0b18 	vmov	d8, r0, r1
 802550c:	e727      	b.n	802535e <cblas_ztrsm+0x51e>
 802550e:	bf00      	nop
 8025510:	08030378 	.word	0x08030378
 8025514:	080307a4 	.word	0x080307a4
 8025518:	3ff00000 	.word	0x3ff00000
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 802551c:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802551e:	4bbe      	ldr	r3, [pc, #760]	; (8025818 <cblas_ztrsm+0x9d8>)
 8025520:	ec51 0b18 	vmov	r0, r1, d8
 8025524:	f04f 0200 	mov.w	r2, #0
    } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
 8025528:	f000 85e9 	beq.w	80260fe <cblas_ztrsm+0x12be>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802552c:	f002 ff24 	bl	8028378 <__aeabi_dcmpeq>
 8025530:	2800      	cmp	r0, #0
 8025532:	f040 82b2 	bne.w	8025a9a <cblas_ztrsm+0xc5a>
        for (i = 0; i < n1; i++) {
 8025536:	9b06      	ldr	r3, [sp, #24]
 8025538:	2b00      	cmp	r3, #0
 802553a:	f340 830d 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 802553e:	9a02      	ldr	r2, [sp, #8]
 8025540:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8025544:	011b      	lsls	r3, r3, #4
 8025546:	9307      	str	r3, [sp, #28]
 8025548:	3308      	adds	r3, #8
 802554a:	9308      	str	r3, [sp, #32]
 802554c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802554e:	011b      	lsls	r3, r3, #4
 8025550:	9303      	str	r3, [sp, #12]
 8025552:	0113      	lsls	r3, r2, #4
 8025554:	9310      	str	r3, [sp, #64]	; 0x40
 8025556:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025558:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802555c:	9300      	str	r3, [sp, #0]
 802555e:	2300      	movs	r3, #0
 8025560:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8025562:	9b02      	ldr	r3, [sp, #8]
 8025564:	2b00      	cmp	r3, #0
 8025566:	dd3d      	ble.n	80255e4 <cblas_ztrsm+0x7a4>
 8025568:	9b00      	ldr	r3, [sp, #0]
 802556a:	9907      	ldr	r1, [sp, #28]
 802556c:	9a08      	ldr	r2, [sp, #32]
 802556e:	eb03 0801 	add.w	r8, r3, r1
 8025572:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025576:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802557a:	ec53 2b18 	vmov	r2, r3, d8
 802557e:	4630      	mov	r0, r6
 8025580:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025582:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025586:	f002 fc8f 	bl	8027ea8 <__aeabi_dmul>
 802558a:	4652      	mov	r2, sl
 802558c:	ec41 0b19 	vmov	d9, r0, r1
 8025590:	465b      	mov	r3, fp
 8025592:	4620      	mov	r0, r4
 8025594:	4629      	mov	r1, r5
 8025596:	f002 fc87 	bl	8027ea8 <__aeabi_dmul>
 802559a:	4602      	mov	r2, r0
 802559c:	460b      	mov	r3, r1
 802559e:	ec51 0b19 	vmov	r0, r1, d9
 80255a2:	f002 fac9 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80255a6:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80255aa:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80255ae:	4620      	mov	r0, r4
 80255b0:	4629      	mov	r1, r5
 80255b2:	f002 fc79 	bl	8027ea8 <__aeabi_dmul>
 80255b6:	4652      	mov	r2, sl
 80255b8:	465b      	mov	r3, fp
 80255ba:	4604      	mov	r4, r0
 80255bc:	460d      	mov	r5, r1
 80255be:	4630      	mov	r0, r6
 80255c0:	4639      	mov	r1, r7
 80255c2:	f002 fc71 	bl	8027ea8 <__aeabi_dmul>
 80255c6:	460b      	mov	r3, r1
 80255c8:	4602      	mov	r2, r0
 80255ca:	4629      	mov	r1, r5
 80255cc:	4620      	mov	r0, r4
 80255ce:	f002 fab5 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 80255d2:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80255d4:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 80255d8:	f108 0810 	add.w	r8, r8, #16
 80255dc:	4598      	cmp	r8, r3
 80255de:	f109 0910 	add.w	r9, r9, #16
 80255e2:	d1c8      	bne.n	8025576 <cblas_ztrsm+0x736>
        for (i = 0; i < n1; i++) {
 80255e4:	9a00      	ldr	r2, [sp, #0]
 80255e6:	9903      	ldr	r1, [sp, #12]
 80255e8:	9b04      	ldr	r3, [sp, #16]
 80255ea:	440a      	add	r2, r1
 80255ec:	9200      	str	r2, [sp, #0]
 80255ee:	9a06      	ldr	r2, [sp, #24]
 80255f0:	3301      	adds	r3, #1
 80255f2:	429a      	cmp	r2, r3
 80255f4:	9304      	str	r3, [sp, #16]
 80255f6:	d1b4      	bne.n	8025562 <cblas_ztrsm+0x722>
 80255f8:	9b01      	ldr	r3, [sp, #4]
 80255fa:	1c59      	adds	r1, r3, #1
 80255fc:	0109      	lsls	r1, r1, #4
 80255fe:	0118      	lsls	r0, r3, #4
 8025600:	910d      	str	r1, [sp, #52]	; 0x34
 8025602:	990a      	ldr	r1, [sp, #40]	; 0x28
 8025604:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025606:	9001      	str	r0, [sp, #4]
 8025608:	f100 0208 	add.w	r2, r0, #8
 802560c:	188a      	adds	r2, r1, r2
 802560e:	9211      	str	r2, [sp, #68]	; 0x44
 8025610:	f100 0210 	add.w	r2, r0, #16
 8025614:	920e      	str	r2, [sp, #56]	; 0x38
 8025616:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8025618:	3b10      	subs	r3, #16
            for (k = j + 1; k < n2; k++) {
 802561a:	2400      	movs	r4, #0
 802561c:	441a      	add	r2, r3
 802561e:	940f      	str	r4, [sp, #60]	; 0x3c
 8025620:	9200      	str	r2, [sp, #0]
 8025622:	9410      	str	r4, [sp, #64]	; 0x40
        for (j = 0; j < n2; j++) {
 8025624:	9b02      	ldr	r3, [sp, #8]
 8025626:	2b00      	cmp	r3, #0
 8025628:	f340 8287 	ble.w	8025b3a <cblas_ztrsm+0xcfa>
 802562c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802562e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8025630:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8025634:	9304      	str	r3, [sp, #16]
 8025636:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8025638:	3308      	adds	r3, #8
 802563a:	9309      	str	r3, [sp, #36]	; 0x24
 802563c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802563e:	9307      	str	r3, [sp, #28]
 8025640:	2300      	movs	r3, #0
 8025642:	9308      	str	r3, [sp, #32]
          if (nonunit) {
 8025644:	9b05      	ldr	r3, [sp, #20]
 8025646:	2b83      	cmp	r3, #131	; 0x83
 8025648:	d070      	beq.n	802572c <cblas_ztrsm+0x8ec>
 802564a:	9b04      	ldr	r3, [sp, #16]
 802564c:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025650:	9c04      	ldr	r4, [sp, #16]
            for (k = j + 1; k < n2; k++) {
 8025652:	9b08      	ldr	r3, [sp, #32]
 8025654:	9a02      	ldr	r2, [sp, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025656:	ed94 7b00 	vldr	d7, [r4]
            for (k = j + 1; k < n2; k++) {
 802565a:	3301      	adds	r3, #1
 802565c:	429a      	cmp	r2, r3
 802565e:	9308      	str	r3, [sp, #32]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025660:	eeb0 8a47 	vmov.f32	s16, s14
 8025664:	eef0 8a67 	vmov.f32	s17, s15
            for (k = j + 1; k < n2; k++) {
 8025668:	f000 8267 	beq.w	8025b3a <cblas_ztrsm+0xcfa>
 802566c:	ee1c 0a10 	vmov	r0, s24
 8025670:	f002 fbb0 	bl	8027dd4 <__aeabi_i2d>
 8025674:	f8dd b01c 	ldr.w	fp, [sp, #28]
 8025678:	ec41 0b1a 	vmov	d10, r0, r1
 802567c:	46a2      	mov	sl, r4
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802567e:	e9db 2300 	ldrd	r2, r3, [fp]
 8025682:	ec51 0b1a 	vmov	r0, r1, d10
 8025686:	f002 fc0f 	bl	8027ea8 <__aeabi_dmul>
              const BASE Akj_real = CONST_REAL(A, k * lda + j);
 802568a:	e95b 4502 	ldrd	r4, r5, [fp, #-8]
              const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
 802568e:	4680      	mov	r8, r0
 8025690:	4689      	mov	r9, r1
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 8025692:	4622      	mov	r2, r4
 8025694:	462b      	mov	r3, r5
 8025696:	ec51 0b18 	vmov	r0, r1, d8
 802569a:	f002 fc05 	bl	8027ea8 <__aeabi_dmul>
 802569e:	4632      	mov	r2, r6
 80256a0:	ec41 0b19 	vmov	d9, r0, r1
 80256a4:	463b      	mov	r3, r7
 80256a6:	4640      	mov	r0, r8
 80256a8:	4649      	mov	r1, r9
 80256aa:	f002 fbfd 	bl	8027ea8 <__aeabi_dmul>
 80256ae:	4602      	mov	r2, r0
 80256b0:	460b      	mov	r3, r1
 80256b2:	ec51 0b19 	vmov	r0, r1, d9
 80256b6:	f002 fa3f 	bl	8027b38 <__aeabi_dsub>
 80256ba:	4602      	mov	r2, r0
 80256bc:	460b      	mov	r3, r1
 80256be:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 80256c2:	f002 fa39 	bl	8027b38 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80256c6:	4632      	mov	r2, r6
              REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
 80256c8:	e9ca 0104 	strd	r0, r1, [sl, #16]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 80256cc:	463b      	mov	r3, r7
 80256ce:	4620      	mov	r0, r4
 80256d0:	4629      	mov	r1, r5
 80256d2:	f002 fbe9 	bl	8027ea8 <__aeabi_dmul>
 80256d6:	4642      	mov	r2, r8
 80256d8:	464b      	mov	r3, r9
 80256da:	4680      	mov	r8, r0
 80256dc:	4689      	mov	r9, r1
 80256de:	ec51 0b18 	vmov	r0, r1, d8
 80256e2:	f002 fbe1 	bl	8027ea8 <__aeabi_dmul>
 80256e6:	4602      	mov	r2, r0
 80256e8:	460b      	mov	r3, r1
 80256ea:	4640      	mov	r0, r8
 80256ec:	4649      	mov	r1, r9
 80256ee:	f002 fa25 	bl	8027b3c <__adddf3>
 80256f2:	460b      	mov	r3, r1
 80256f4:	4602      	mov	r2, r0
 80256f6:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 80256fa:	f002 fa1d 	bl	8027b38 <__aeabi_dsub>
 80256fe:	9b01      	ldr	r3, [sp, #4]
 8025700:	449b      	add	fp, r3
            for (k = j + 1; k < n2; k++) {
 8025702:	9b00      	ldr	r3, [sp, #0]
              IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
 8025704:	e9ca 0106 	strd	r0, r1, [sl, #24]
            for (k = j + 1; k < n2; k++) {
 8025708:	f10a 0a10 	add.w	sl, sl, #16
 802570c:	459a      	cmp	sl, r3
 802570e:	d1b6      	bne.n	802567e <cblas_ztrsm+0x83e>
 8025710:	9b04      	ldr	r3, [sp, #16]
 8025712:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8025714:	3310      	adds	r3, #16
 8025716:	9304      	str	r3, [sp, #16]
 8025718:	9b07      	ldr	r3, [sp, #28]
 802571a:	4413      	add	r3, r2
 802571c:	9307      	str	r3, [sp, #28]
 802571e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8025720:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8025722:	4413      	add	r3, r2
 8025724:	9309      	str	r3, [sp, #36]	; 0x24
          if (nonunit) {
 8025726:	9b05      	ldr	r3, [sp, #20]
 8025728:	2b83      	cmp	r3, #131	; 0x83
 802572a:	d18e      	bne.n	802564a <cblas_ztrsm+0x80a>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 802572c:	ee1c 0a10 	vmov	r0, s24
 8025730:	f002 fb50 	bl	8027dd4 <__aeabi_i2d>
 8025734:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8025736:	e9d4 2300 	ldrd	r2, r3, [r4]
 802573a:	f002 fbb5 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 802573e:	e954 4502 	ldrd	r4, r5, [r4, #-8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8025742:	4606      	mov	r6, r0
 8025744:	460f      	mov	r7, r1
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8025746:	4632      	mov	r2, r6
 8025748:	463b      	mov	r3, r7
 802574a:	4620      	mov	r0, r4
 802574c:	4629      	mov	r1, r5
 802574e:	f7ff fb3f 	bl	8024dd0 <xhypot>
 8025752:	4680      	mov	r8, r0
 8025754:	4689      	mov	r9, r1
            const BASE a_real = Ajj_real / s;
 8025756:	4620      	mov	r0, r4
 8025758:	4629      	mov	r1, r5
 802575a:	4642      	mov	r2, r8
 802575c:	464b      	mov	r3, r9
 802575e:	f002 fccd 	bl	80280fc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 8025762:	4642      	mov	r2, r8
            const BASE a_real = Ajj_real / s;
 8025764:	4682      	mov	sl, r0
 8025766:	468b      	mov	fp, r1
            const BASE a_imag = Ajj_imag / s;
 8025768:	464b      	mov	r3, r9
 802576a:	4630      	mov	r0, r6
 802576c:	4639      	mov	r1, r7
 802576e:	f002 fcc5 	bl	80280fc <__aeabi_ddiv>
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025772:	9e04      	ldr	r6, [sp, #16]
 8025774:	ed96 7b00 	vldr	d7, [r6]
            const BASE a_imag = Ajj_imag / s;
 8025778:	4604      	mov	r4, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802577a:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 802577e:	eeb0 9a47 	vmov.f32	s18, s14
 8025782:	eef0 9a67 	vmov.f32	s19, s15
            const BASE a_imag = Ajj_imag / s;
 8025786:	460d      	mov	r5, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8025788:	4650      	mov	r0, sl
 802578a:	4659      	mov	r1, fp
 802578c:	f002 fb8c 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025790:	e9d6 6702 	ldrd	r6, r7, [r6, #8]
            const BASE a_imag = Ajj_imag / s;
 8025794:	ec45 4b18 	vmov	d8, r4, r5
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8025798:	4632      	mov	r2, r6
 802579a:	463b      	mov	r3, r7
 802579c:	4604      	mov	r4, r0
 802579e:	460d      	mov	r5, r1
 80257a0:	ec51 0b18 	vmov	r0, r1, d8
 80257a4:	f002 fb80 	bl	8027ea8 <__aeabi_dmul>
 80257a8:	4602      	mov	r2, r0
 80257aa:	460b      	mov	r3, r1
 80257ac:	4620      	mov	r0, r4
 80257ae:	4629      	mov	r1, r5
 80257b0:	f002 f9c4 	bl	8027b3c <__adddf3>
 80257b4:	4642      	mov	r2, r8
 80257b6:	464b      	mov	r3, r9
 80257b8:	f002 fca0 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80257bc:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80257be:	9e04      	ldr	r6, [sp, #16]
 80257c0:	4604      	mov	r4, r0
 80257c2:	460d      	mov	r5, r1
 80257c4:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80257c8:	463b      	mov	r3, r7
 80257ca:	4650      	mov	r0, sl
 80257cc:	4659      	mov	r1, fp
 80257ce:	f002 fb6b 	bl	8027ea8 <__aeabi_dmul>
 80257d2:	ec53 2b19 	vmov	r2, r3, d9
 80257d6:	4604      	mov	r4, r0
 80257d8:	460d      	mov	r5, r1
 80257da:	ec51 0b18 	vmov	r0, r1, d8
 80257de:	f002 fb63 	bl	8027ea8 <__aeabi_dmul>
 80257e2:	4602      	mov	r2, r0
 80257e4:	460b      	mov	r3, r1
 80257e6:	4620      	mov	r0, r4
 80257e8:	4629      	mov	r1, r5
 80257ea:	f002 f9a5 	bl	8027b38 <__aeabi_dsub>
 80257ee:	464b      	mov	r3, r9
 80257f0:	4642      	mov	r2, r8
 80257f2:	f002 fc83 	bl	80280fc <__aeabi_ddiv>
 80257f6:	9b04      	ldr	r3, [sp, #16]
 80257f8:	4606      	mov	r6, r0
 80257fa:	460f      	mov	r7, r1
 80257fc:	e9c3 6702 	strd	r6, r7, [r3, #8]
 8025800:	e726      	b.n	8025650 <cblas_ztrsm+0x810>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025802:	9a06      	ldr	r2, [sp, #24]
 8025804:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8025806:	2a01      	cmp	r2, #1
 8025808:	bfb8      	it	lt
 802580a:	2201      	movlt	r2, #1
 802580c:	428a      	cmp	r2, r1
 802580e:	f340 8135 	ble.w	8025a7c <cblas_ztrsm+0xc3c>
 8025812:	230c      	movs	r3, #12
 8025814:	e4f1      	b.n	80251fa <cblas_ztrsm+0x3ba>
 8025816:	bf00      	nop
 8025818:	3ff00000 	.word	0x3ff00000
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 802581c:	2d6f      	cmp	r5, #111	; 0x6f
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802581e:	4bb2      	ldr	r3, [pc, #712]	; (8025ae8 <cblas_ztrsm+0xca8>)
 8025820:	ec51 0b18 	vmov	r0, r1, d8
 8025824:	f04f 0200 	mov.w	r2, #0
    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
 8025828:	f000 81a7 	beq.w	8025b7a <cblas_ztrsm+0xd3a>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 802582c:	f002 fda4 	bl	8028378 <__aeabi_dcmpeq>
 8025830:	2800      	cmp	r0, #0
 8025832:	f040 815b 	bne.w	8025aec <cblas_ztrsm+0xcac>
        for (i = 0; i < n1; i++) {
 8025836:	9b06      	ldr	r3, [sp, #24]
 8025838:	2b00      	cmp	r3, #0
 802583a:	f340 818d 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 802583e:	9a02      	ldr	r2, [sp, #8]
 8025840:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8025844:	011b      	lsls	r3, r3, #4
 8025846:	9307      	str	r3, [sp, #28]
 8025848:	3308      	adds	r3, #8
 802584a:	9308      	str	r3, [sp, #32]
 802584c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802584e:	011b      	lsls	r3, r3, #4
 8025850:	9303      	str	r3, [sp, #12]
 8025852:	0113      	lsls	r3, r2, #4
 8025854:	9310      	str	r3, [sp, #64]	; 0x40
 8025856:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025858:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802585c:	9300      	str	r3, [sp, #0]
 802585e:	2300      	movs	r3, #0
 8025860:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8025862:	9b02      	ldr	r3, [sp, #8]
 8025864:	2b00      	cmp	r3, #0
 8025866:	dd3e      	ble.n	80258e6 <cblas_ztrsm+0xaa6>
 8025868:	9b07      	ldr	r3, [sp, #28]
 802586a:	9a08      	ldr	r2, [sp, #32]
 802586c:	4619      	mov	r1, r3
 802586e:	9b00      	ldr	r3, [sp, #0]
 8025870:	eb01 0803 	add.w	r8, r1, r3
 8025874:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025878:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802587c:	ec53 2b18 	vmov	r2, r3, d8
 8025880:	4630      	mov	r0, r6
 8025882:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025884:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8025888:	f002 fb0e 	bl	8027ea8 <__aeabi_dmul>
 802588c:	4652      	mov	r2, sl
 802588e:	ec41 0b19 	vmov	d9, r0, r1
 8025892:	465b      	mov	r3, fp
 8025894:	4620      	mov	r0, r4
 8025896:	4629      	mov	r1, r5
 8025898:	f002 fb06 	bl	8027ea8 <__aeabi_dmul>
 802589c:	4602      	mov	r2, r0
 802589e:	460b      	mov	r3, r1
 80258a0:	ec51 0b19 	vmov	r0, r1, d9
 80258a4:	f002 f948 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80258a8:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80258ac:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80258b0:	4620      	mov	r0, r4
 80258b2:	4629      	mov	r1, r5
 80258b4:	f002 faf8 	bl	8027ea8 <__aeabi_dmul>
 80258b8:	4652      	mov	r2, sl
 80258ba:	465b      	mov	r3, fp
 80258bc:	4604      	mov	r4, r0
 80258be:	460d      	mov	r5, r1
 80258c0:	4630      	mov	r0, r6
 80258c2:	4639      	mov	r1, r7
 80258c4:	f002 faf0 	bl	8027ea8 <__aeabi_dmul>
 80258c8:	460b      	mov	r3, r1
 80258ca:	4602      	mov	r2, r0
 80258cc:	4629      	mov	r1, r5
 80258ce:	4620      	mov	r0, r4
 80258d0:	f002 f934 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 80258d4:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80258d6:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 80258da:	f108 0810 	add.w	r8, r8, #16
 80258de:	4543      	cmp	r3, r8
 80258e0:	f109 0910 	add.w	r9, r9, #16
 80258e4:	d1c8      	bne.n	8025878 <cblas_ztrsm+0xa38>
        for (i = 0; i < n1; i++) {
 80258e6:	9a00      	ldr	r2, [sp, #0]
 80258e8:	9903      	ldr	r1, [sp, #12]
 80258ea:	9b04      	ldr	r3, [sp, #16]
 80258ec:	440a      	add	r2, r1
 80258ee:	9200      	str	r2, [sp, #0]
 80258f0:	9a06      	ldr	r2, [sp, #24]
 80258f2:	3301      	adds	r3, #1
 80258f4:	429a      	cmp	r2, r3
 80258f6:	9304      	str	r3, [sp, #16]
 80258f8:	d1b3      	bne.n	8025862 <cblas_ztrsm+0xa22>
 80258fa:	9810      	ldr	r0, [sp, #64]	; 0x40
 80258fc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80258fe:	9b01      	ldr	r3, [sp, #4]
 8025900:	990c      	ldr	r1, [sp, #48]	; 0x30
 8025902:	4606      	mov	r6, r0
 8025904:	9806      	ldr	r0, [sp, #24]
 8025906:	011c      	lsls	r4, r3, #4
 8025908:	f1a2 0310 	sub.w	r3, r2, #16
 802590c:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 8025910:	9307      	str	r3, [sp, #28]
 8025912:	f104 0310 	add.w	r3, r4, #16
 8025916:	2500      	movs	r5, #0
 8025918:	9311      	str	r3, [sp, #68]	; 0x44
 802591a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802591c:	9412      	str	r4, [sp, #72]	; 0x48
 802591e:	e9cd 520d 	strd	r5, r2, [sp, #52]	; 0x34
 8025922:	e9cd 1308 	strd	r1, r3, [sp, #32]
 8025926:	440e      	add	r6, r1
 8025928:	f101 0308 	add.w	r3, r1, #8
 802592c:	950f      	str	r5, [sp, #60]	; 0x3c
 802592e:	9610      	str	r6, [sp, #64]	; 0x40
 8025930:	9313      	str	r3, [sp, #76]	; 0x4c
        if (nonunit) {
 8025932:	9b05      	ldr	r3, [sp, #20]
 8025934:	2b83      	cmp	r3, #131	; 0x83
 8025936:	f000 864f 	beq.w	80265d8 <cblas_ztrsm+0x1798>
        for (k = i + 1; k < n1; k++) {
 802593a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802593c:	9a06      	ldr	r2, [sp, #24]
 802593e:	3301      	adds	r3, #1
 8025940:	429a      	cmp	r2, r3
 8025942:	930d      	str	r3, [sp, #52]	; 0x34
 8025944:	f340 8108 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8025948:	ee1c 0a10 	vmov	r0, s24
 802594c:	f002 fa42 	bl	8027dd4 <__aeabi_i2d>
 8025950:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025952:	ec41 0b1b 	vmov	d11, r0, r1
 8025956:	4619      	mov	r1, r3
 8025958:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802595a:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 802595e:	9204      	str	r2, [sp, #16]
 8025960:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8025962:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8025966:	9301      	str	r3, [sp, #4]
 8025968:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802596a:	9300      	str	r3, [sp, #0]
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 802596c:	9c00      	ldr	r4, [sp, #0]
 802596e:	ec51 0b1b 	vmov	r0, r1, d11
 8025972:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 8025976:	f002 fa97 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 802597a:	ed94 7b04 	vldr	d7, [r4, #16]
          for (j = 0; j < n2; j++) {
 802597e:	9b02      	ldr	r3, [sp, #8]
          const BASE Aik_real = CONST_REAL(A, i * lda + k);
 8025980:	eeb0 9a47 	vmov.f32	s18, s14
 8025984:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 8025988:	2b00      	cmp	r3, #0
          const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
 802598a:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 802598e:	dd49      	ble.n	8025a24 <cblas_ztrsm+0xbe4>
 8025990:	9b04      	ldr	r3, [sp, #16]
 8025992:	9c08      	ldr	r4, [sp, #32]
 8025994:	9d01      	ldr	r5, [sp, #4]
 8025996:	f103 0b08 	add.w	fp, r3, #8
 802599a:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 802599c:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 80259a0:	ec51 0b19 	vmov	r0, r1, d9
 80259a4:	4632      	mov	r2, r6
 80259a6:	463b      	mov	r3, r7
 80259a8:	f002 fa7e 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80259ac:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 80259b0:	ec41 0b1a 	vmov	d10, r0, r1
 80259b4:	4642      	mov	r2, r8
 80259b6:	464b      	mov	r3, r9
 80259b8:	ec51 0b18 	vmov	r0, r1, d8
 80259bc:	f002 fa74 	bl	8027ea8 <__aeabi_dmul>
 80259c0:	4602      	mov	r2, r0
 80259c2:	460b      	mov	r3, r1
 80259c4:	ec51 0b1a 	vmov	r0, r1, d10
 80259c8:	f002 f8b6 	bl	8027b38 <__aeabi_dsub>
 80259cc:	4602      	mov	r2, r0
 80259ce:	460b      	mov	r3, r1
 80259d0:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 80259d4:	f002 f8b0 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 80259d8:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
 80259da:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
 80259de:	464b      	mov	r3, r9
 80259e0:	ec51 0b19 	vmov	r0, r1, d9
 80259e4:	f002 fa60 	bl	8027ea8 <__aeabi_dmul>
 80259e8:	4632      	mov	r2, r6
 80259ea:	463b      	mov	r3, r7
 80259ec:	4606      	mov	r6, r0
 80259ee:	460f      	mov	r7, r1
 80259f0:	ec51 0b18 	vmov	r0, r1, d8
 80259f4:	f002 fa58 	bl	8027ea8 <__aeabi_dmul>
 80259f8:	4602      	mov	r2, r0
 80259fa:	460b      	mov	r3, r1
 80259fc:	4630      	mov	r0, r6
 80259fe:	4639      	mov	r1, r7
 8025a00:	f002 f89c 	bl	8027b3c <__adddf3>
 8025a04:	4602      	mov	r2, r0
 8025a06:	460b      	mov	r3, r1
 8025a08:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8025a0c:	f002 f894 	bl	8027b38 <__aeabi_dsub>
 8025a10:	f10a 0a10 	add.w	sl, sl, #16
 8025a14:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8025a18:	4555      	cmp	r5, sl
 8025a1a:	f104 0410 	add.w	r4, r4, #16
 8025a1e:	f10b 0b10 	add.w	fp, fp, #16
 8025a22:	d1bb      	bne.n	802599c <cblas_ztrsm+0xb5c>
        for (k = i + 1; k < n1; k++) {
 8025a24:	9904      	ldr	r1, [sp, #16]
 8025a26:	9a03      	ldr	r2, [sp, #12]
 8025a28:	9b00      	ldr	r3, [sp, #0]
 8025a2a:	4608      	mov	r0, r1
 8025a2c:	9901      	ldr	r1, [sp, #4]
 8025a2e:	4410      	add	r0, r2
 8025a30:	4411      	add	r1, r2
 8025a32:	9a07      	ldr	r2, [sp, #28]
 8025a34:	9004      	str	r0, [sp, #16]
 8025a36:	3310      	adds	r3, #16
 8025a38:	429a      	cmp	r2, r3
 8025a3a:	9300      	str	r3, [sp, #0]
 8025a3c:	9101      	str	r1, [sp, #4]
 8025a3e:	d195      	bne.n	802596c <cblas_ztrsm+0xb2c>
 8025a40:	4613      	mov	r3, r2
 8025a42:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8025a44:	4413      	add	r3, r2
 8025a46:	9307      	str	r3, [sp, #28]
 8025a48:	9a03      	ldr	r2, [sp, #12]
 8025a4a:	9b08      	ldr	r3, [sp, #32]
 8025a4c:	4413      	add	r3, r2
 8025a4e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8025a50:	9308      	str	r3, [sp, #32]
 8025a52:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025a54:	4611      	mov	r1, r2
 8025a56:	4419      	add	r1, r3
 8025a58:	910f      	str	r1, [sp, #60]	; 0x3c
 8025a5a:	990a      	ldr	r1, [sp, #40]	; 0x28
 8025a5c:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8025a5e:	4608      	mov	r0, r1
 8025a60:	9909      	ldr	r1, [sp, #36]	; 0x24
 8025a62:	4419      	add	r1, r3
 8025a64:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8025a66:	9109      	str	r1, [sp, #36]	; 0x24
 8025a68:	4410      	add	r0, r2
 8025a6a:	4413      	add	r3, r2
 8025a6c:	900a      	str	r0, [sp, #40]	; 0x28
 8025a6e:	930e      	str	r3, [sp, #56]	; 0x38
 8025a70:	e75f      	b.n	8025932 <cblas_ztrsm+0xaf2>
 8025a72:	9a02      	ldr	r2, [sp, #8]
 8025a74:	9206      	str	r2, [sp, #24]
 8025a76:	9302      	str	r3, [sp, #8]
 8025a78:	f7ff ba4f 	b.w	8024f1a <cblas_ztrsm+0xda>
  CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
 8025a7c:	2b00      	cmp	r3, #0
 8025a7e:	f43f abc1 	beq.w	8025204 <cblas_ztrsm+0x3c4>
 8025a82:	f7ff bbba 	b.w	80251fa <cblas_ztrsm+0x3ba>
 8025a86:	f1a0 0365 	sub.w	r3, r0, #101	; 0x65
 8025a8a:	2b01      	cmp	r3, #1
 8025a8c:	f8dd c018 	ldr.w	ip, [sp, #24]
 8025a90:	bf94      	ite	ls
 8025a92:	2300      	movls	r3, #0
 8025a94:	2301      	movhi	r3, #1
 8025a96:	f7ff b9fa 	b.w	8024e8e <cblas_ztrsm+0x4e>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025a9a:	2200      	movs	r2, #0
 8025a9c:	2300      	movs	r3, #0
 8025a9e:	4650      	mov	r0, sl
 8025aa0:	4659      	mov	r1, fp
 8025aa2:	f002 fc69 	bl	8028378 <__aeabi_dcmpeq>
 8025aa6:	2800      	cmp	r0, #0
 8025aa8:	f43f ad45 	beq.w	8025536 <cblas_ztrsm+0x6f6>
      for (i = 0; i < n1; i++) {
 8025aac:	9b06      	ldr	r3, [sp, #24]
 8025aae:	2b00      	cmp	r3, #0
 8025ab0:	dd52      	ble.n	8025b58 <cblas_ztrsm+0xd18>
 8025ab2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025ab4:	011b      	lsls	r3, r3, #4
 8025ab6:	9303      	str	r3, [sp, #12]
 8025ab8:	9b02      	ldr	r3, [sp, #8]
 8025aba:	011b      	lsls	r3, r3, #4
 8025abc:	9310      	str	r3, [sp, #64]	; 0x40
 8025abe:	e59b      	b.n	80255f8 <cblas_ztrsm+0x7b8>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025ac0:	2200      	movs	r2, #0
 8025ac2:	2300      	movs	r3, #0
 8025ac4:	4650      	mov	r0, sl
 8025ac6:	4659      	mov	r1, fp
 8025ac8:	f002 fc56 	bl	8028378 <__aeabi_dcmpeq>
 8025acc:	2800      	cmp	r0, #0
 8025ace:	f43f aa60 	beq.w	8024f92 <cblas_ztrsm+0x152>
      for (i = n1; i > 0 && i--;) {
 8025ad2:	9b06      	ldr	r3, [sp, #24]
 8025ad4:	2b00      	cmp	r3, #0
 8025ad6:	dd3f      	ble.n	8025b58 <cblas_ztrsm+0xd18>
 8025ad8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025ada:	011b      	lsls	r3, r3, #4
 8025adc:	9303      	str	r3, [sp, #12]
 8025ade:	9b02      	ldr	r3, [sp, #8]
 8025ae0:	011b      	lsls	r3, r3, #4
 8025ae2:	9310      	str	r3, [sp, #64]	; 0x40
 8025ae4:	f7ff bab7 	b.w	8025056 <cblas_ztrsm+0x216>
 8025ae8:	3ff00000 	.word	0x3ff00000
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025aec:	2200      	movs	r2, #0
 8025aee:	2300      	movs	r3, #0
 8025af0:	4650      	mov	r0, sl
 8025af2:	4659      	mov	r1, fp
 8025af4:	f002 fc40 	bl	8028378 <__aeabi_dcmpeq>
 8025af8:	2800      	cmp	r0, #0
 8025afa:	f43f ae9c 	beq.w	8025836 <cblas_ztrsm+0x9f6>
      for (i = 0; i < n1; i++) {
 8025afe:	9b06      	ldr	r3, [sp, #24]
 8025b00:	2b00      	cmp	r3, #0
 8025b02:	dd29      	ble.n	8025b58 <cblas_ztrsm+0xd18>
 8025b04:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025b06:	011b      	lsls	r3, r3, #4
 8025b08:	9303      	str	r3, [sp, #12]
 8025b0a:	9b02      	ldr	r3, [sp, #8]
 8025b0c:	011b      	lsls	r3, r3, #4
 8025b0e:	9310      	str	r3, [sp, #64]	; 0x40
 8025b10:	e6f3      	b.n	80258fa <cblas_ztrsm+0xaba>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025b12:	2200      	movs	r2, #0
 8025b14:	2300      	movs	r3, #0
 8025b16:	4650      	mov	r0, sl
 8025b18:	4659      	mov	r1, fp
 8025b1a:	f002 fc2d 	bl	8028378 <__aeabi_dcmpeq>
 8025b1e:	2800      	cmp	r0, #0
 8025b20:	f43f ab92 	beq.w	8025248 <cblas_ztrsm+0x408>
      for (i = 0; i < n1; i++) {
 8025b24:	9b06      	ldr	r3, [sp, #24]
 8025b26:	2b00      	cmp	r3, #0
 8025b28:	dd16      	ble.n	8025b58 <cblas_ztrsm+0xd18>
 8025b2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025b2c:	011b      	lsls	r3, r3, #4
 8025b2e:	9303      	str	r3, [sp, #12]
 8025b30:	9b02      	ldr	r3, [sp, #8]
 8025b32:	011b      	lsls	r3, r3, #4
 8025b34:	9310      	str	r3, [sp, #64]	; 0x40
 8025b36:	f7ff bbe8 	b.w	802530a <cblas_ztrsm+0x4ca>
      for (i = 0; i < n1; i++) {
 8025b3a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8025b3c:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8025b3e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8025b40:	440a      	add	r2, r1
 8025b42:	920f      	str	r2, [sp, #60]	; 0x3c
 8025b44:	9903      	ldr	r1, [sp, #12]
 8025b46:	9a00      	ldr	r2, [sp, #0]
 8025b48:	440a      	add	r2, r1
 8025b4a:	9200      	str	r2, [sp, #0]
 8025b4c:	9a06      	ldr	r2, [sp, #24]
 8025b4e:	3301      	adds	r3, #1
 8025b50:	429a      	cmp	r2, r3
 8025b52:	9310      	str	r3, [sp, #64]	; 0x40
 8025b54:	f73f ad66 	bgt.w	8025624 <cblas_ztrsm+0x7e4>
 8025b58:	b015      	add	sp, #84	; 0x54
 8025b5a:	ecbd 8b0a 	vpop	{d8-d12}
 8025b5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      for (i = 0; i < n1; i++) {
 8025b62:	9a07      	ldr	r2, [sp, #28]
 8025b64:	9903      	ldr	r1, [sp, #12]
 8025b66:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025b68:	440a      	add	r2, r1
 8025b6a:	9207      	str	r2, [sp, #28]
 8025b6c:	9a06      	ldr	r2, [sp, #24]
 8025b6e:	3301      	adds	r3, #1
 8025b70:	429a      	cmp	r2, r3
 8025b72:	930b      	str	r3, [sp, #44]	; 0x2c
 8025b74:	f73f abde 	bgt.w	8025334 <cblas_ztrsm+0x4f4>
 8025b78:	e7ee      	b.n	8025b58 <cblas_ztrsm+0xd18>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025b7a:	f002 fbfd 	bl	8028378 <__aeabi_dcmpeq>
 8025b7e:	2800      	cmp	r0, #0
 8025b80:	f000 83f0 	beq.w	8026364 <cblas_ztrsm+0x1524>
 8025b84:	2200      	movs	r2, #0
 8025b86:	2300      	movs	r3, #0
 8025b88:	4650      	mov	r0, sl
 8025b8a:	4659      	mov	r1, fp
 8025b8c:	f002 fbf4 	bl	8028378 <__aeabi_dcmpeq>
 8025b90:	2800      	cmp	r0, #0
 8025b92:	f000 83e7 	beq.w	8026364 <cblas_ztrsm+0x1524>
      for (i = n1; i > 0 && i--;) {
 8025b96:	9b06      	ldr	r3, [sp, #24]
 8025b98:	2b00      	cmp	r3, #0
 8025b9a:	dddd      	ble.n	8025b58 <cblas_ztrsm+0xd18>
 8025b9c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025b9e:	011b      	lsls	r3, r3, #4
 8025ba0:	9303      	str	r3, [sp, #12]
 8025ba2:	9b02      	ldr	r3, [sp, #8]
 8025ba4:	011b      	lsls	r3, r3, #4
 8025ba6:	9310      	str	r3, [sp, #64]	; 0x40
 8025ba8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8025baa:	9c01      	ldr	r4, [sp, #4]
 8025bac:	ebc2 7102 	rsb	r1, r2, r2, lsl #28
 8025bb0:	9a06      	ldr	r2, [sp, #24]
 8025bb2:	3a01      	subs	r2, #1
 8025bb4:	4610      	mov	r0, r2
 8025bb6:	9207      	str	r2, [sp, #28]
 8025bb8:	43e2      	mvns	r2, r4
 8025bba:	0112      	lsls	r2, r2, #4
 8025bbc:	1c63      	adds	r3, r4, #1
 8025bbe:	920b      	str	r2, [sp, #44]	; 0x2c
 8025bc0:	4602      	mov	r2, r0
 8025bc2:	980a      	ldr	r0, [sp, #40]	; 0x28
 8025bc4:	011b      	lsls	r3, r3, #4
 8025bc6:	0109      	lsls	r1, r1, #4
 8025bc8:	910e      	str	r1, [sp, #56]	; 0x38
 8025bca:	fb03 0102 	mla	r1, r3, r2, r0
 8025bce:	3b10      	subs	r3, #16
 8025bd0:	9309      	str	r3, [sp, #36]	; 0x24
 8025bd2:	f100 0310 	add.w	r3, r0, #16
 8025bd6:	930f      	str	r3, [sp, #60]	; 0x3c
 8025bd8:	9b03      	ldr	r3, [sp, #12]
 8025bda:	910a      	str	r1, [sp, #40]	; 0x28
 8025bdc:	4618      	mov	r0, r3
 8025bde:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025be0:	fb00 3202 	mla	r2, r0, r2, r3
 8025be4:	9208      	str	r2, [sp, #32]
 8025be6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8025be8:	4413      	add	r3, r2
 8025bea:	930d      	str	r3, [sp, #52]	; 0x34
        if (nonunit) {
 8025bec:	9b05      	ldr	r3, [sp, #20]
 8025bee:	2b83      	cmp	r3, #131	; 0x83
 8025bf0:	f000 847f 	beq.w	80264f2 <cblas_ztrsm+0x16b2>
        for (k = 0; k < i; k++) {
 8025bf4:	9b07      	ldr	r3, [sp, #28]
 8025bf6:	2b00      	cmp	r3, #0
 8025bf8:	d0ae      	beq.n	8025b58 <cblas_ztrsm+0xd18>
 8025bfa:	ee1c 0a10 	vmov	r0, s24
 8025bfe:	f002 f8e9 	bl	8027dd4 <__aeabi_i2d>
 8025c02:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8025c04:	9a07      	ldr	r2, [sp, #28]
 8025c06:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8025c0a:	9300      	str	r3, [sp, #0]
 8025c0c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8025c0e:	9301      	str	r3, [sp, #4]
 8025c10:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025c12:	9304      	str	r3, [sp, #16]
 8025c14:	ec41 0b1b 	vmov	d11, r0, r1
 8025c18:	2300      	movs	r3, #0
 8025c1a:	9306      	str	r3, [sp, #24]
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8025c1c:	9c00      	ldr	r4, [sp, #0]
 8025c1e:	ec51 0b1b 	vmov	r0, r1, d11
 8025c22:	e954 2302 	ldrd	r2, r3, [r4, #-8]
 8025c26:	f002 f93f 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8025c2a:	ed14 7b04 	vldr	d7, [r4, #-16]
          for (j = 0; j < n2; j++) {
 8025c2e:	9b02      	ldr	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8025c30:	eeb0 9a47 	vmov.f32	s18, s14
 8025c34:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 8025c38:	2b00      	cmp	r3, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8025c3a:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8025c3e:	dd49      	ble.n	8025cd4 <cblas_ztrsm+0xe94>
 8025c40:	9b04      	ldr	r3, [sp, #16]
 8025c42:	9c08      	ldr	r4, [sp, #32]
 8025c44:	9d01      	ldr	r5, [sp, #4]
 8025c46:	f103 0b08 	add.w	fp, r3, #8
 8025c4a:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025c4c:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8025c50:	ec51 0b19 	vmov	r0, r1, d9
 8025c54:	4632      	mov	r2, r6
 8025c56:	463b      	mov	r3, r7
 8025c58:	f002 f926 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025c5c:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8025c60:	ec41 0b1a 	vmov	d10, r0, r1
 8025c64:	4642      	mov	r2, r8
 8025c66:	464b      	mov	r3, r9
 8025c68:	ec51 0b18 	vmov	r0, r1, d8
 8025c6c:	f002 f91c 	bl	8027ea8 <__aeabi_dmul>
 8025c70:	4602      	mov	r2, r0
 8025c72:	460b      	mov	r3, r1
 8025c74:	ec51 0b1a 	vmov	r0, r1, d10
 8025c78:	f001 ff5e 	bl	8027b38 <__aeabi_dsub>
 8025c7c:	4602      	mov	r2, r0
 8025c7e:	460b      	mov	r3, r1
 8025c80:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8025c84:	f001 ff58 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8025c88:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8025c8a:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8025c8e:	464b      	mov	r3, r9
 8025c90:	ec51 0b19 	vmov	r0, r1, d9
 8025c94:	f002 f908 	bl	8027ea8 <__aeabi_dmul>
 8025c98:	4632      	mov	r2, r6
 8025c9a:	463b      	mov	r3, r7
 8025c9c:	4606      	mov	r6, r0
 8025c9e:	460f      	mov	r7, r1
 8025ca0:	ec51 0b18 	vmov	r0, r1, d8
 8025ca4:	f002 f900 	bl	8027ea8 <__aeabi_dmul>
 8025ca8:	4602      	mov	r2, r0
 8025caa:	460b      	mov	r3, r1
 8025cac:	4630      	mov	r0, r6
 8025cae:	4639      	mov	r1, r7
 8025cb0:	f001 ff44 	bl	8027b3c <__adddf3>
 8025cb4:	4602      	mov	r2, r0
 8025cb6:	460b      	mov	r3, r1
 8025cb8:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8025cbc:	f001 ff3c 	bl	8027b38 <__aeabi_dsub>
 8025cc0:	f10a 0a10 	add.w	sl, sl, #16
 8025cc4:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8025cc8:	45aa      	cmp	sl, r5
 8025cca:	f104 0410 	add.w	r4, r4, #16
 8025cce:	f10b 0b10 	add.w	fp, fp, #16
 8025cd2:	d1bb      	bne.n	8025c4c <cblas_ztrsm+0xe0c>
        for (k = 0; k < i; k++) {
 8025cd4:	9a00      	ldr	r2, [sp, #0]
 8025cd6:	9909      	ldr	r1, [sp, #36]	; 0x24
 8025cd8:	9b06      	ldr	r3, [sp, #24]
 8025cda:	440a      	add	r2, r1
 8025cdc:	9904      	ldr	r1, [sp, #16]
 8025cde:	9200      	str	r2, [sp, #0]
 8025ce0:	4608      	mov	r0, r1
 8025ce2:	9a03      	ldr	r2, [sp, #12]
 8025ce4:	9901      	ldr	r1, [sp, #4]
 8025ce6:	4410      	add	r0, r2
 8025ce8:	4411      	add	r1, r2
 8025cea:	9a07      	ldr	r2, [sp, #28]
 8025cec:	9004      	str	r0, [sp, #16]
 8025cee:	3301      	adds	r3, #1
 8025cf0:	429a      	cmp	r2, r3
 8025cf2:	9306      	str	r3, [sp, #24]
 8025cf4:	9101      	str	r1, [sp, #4]
 8025cf6:	d191      	bne.n	8025c1c <cblas_ztrsm+0xddc>
 8025cf8:	9b08      	ldr	r3, [sp, #32]
 8025cfa:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8025cfc:	4413      	add	r3, r2
 8025cfe:	9308      	str	r3, [sp, #32]
 8025d00:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
 8025d04:	4413      	add	r3, r2
 8025d06:	930a      	str	r3, [sp, #40]	; 0x28
 8025d08:	9b07      	ldr	r3, [sp, #28]
 8025d0a:	3b01      	subs	r3, #1
 8025d0c:	9307      	str	r3, [sp, #28]
 8025d0e:	e76d      	b.n	8025bec <cblas_ztrsm+0xdac>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025d10:	f002 fb32 	bl	8028378 <__aeabi_dcmpeq>
 8025d14:	2800      	cmp	r0, #0
 8025d16:	f000 8389 	beq.w	802642c <cblas_ztrsm+0x15ec>
 8025d1a:	2200      	movs	r2, #0
 8025d1c:	2300      	movs	r3, #0
 8025d1e:	4650      	mov	r0, sl
 8025d20:	4659      	mov	r1, fp
 8025d22:	f002 fb29 	bl	8028378 <__aeabi_dcmpeq>
 8025d26:	2800      	cmp	r0, #0
 8025d28:	f000 8380 	beq.w	802642c <cblas_ztrsm+0x15ec>
      for (i = 0; i < n1; i++) {
 8025d2c:	9b06      	ldr	r3, [sp, #24]
 8025d2e:	2b00      	cmp	r3, #0
 8025d30:	f77f af12 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8025d34:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025d36:	011b      	lsls	r3, r3, #4
 8025d38:	9303      	str	r3, [sp, #12]
 8025d3a:	9b02      	ldr	r3, [sp, #8]
 8025d3c:	011b      	lsls	r3, r3, #4
 8025d3e:	9310      	str	r3, [sp, #64]	; 0x40
 8025d40:	9a01      	ldr	r2, [sp, #4]
 8025d42:	9810      	ldr	r0, [sp, #64]	; 0x40
 8025d44:	990c      	ldr	r1, [sp, #48]	; 0x30
        for (i = 0; i < n1; i++) {
 8025d46:	9108      	str	r1, [sp, #32]
 8025d48:	3201      	adds	r2, #1
 8025d4a:	0112      	lsls	r2, r2, #4
 8025d4c:	4605      	mov	r5, r0
 8025d4e:	980a      	ldr	r0, [sp, #40]	; 0x28
 8025d50:	9212      	str	r2, [sp, #72]	; 0x48
 8025d52:	f1a2 0308 	sub.w	r3, r2, #8
 8025d56:	18c3      	adds	r3, r0, r3
 8025d58:	2400      	movs	r4, #0
 8025d5a:	930d      	str	r3, [sp, #52]	; 0x34
 8025d5c:	f1a2 0310 	sub.w	r3, r2, #16
 8025d60:	e9cd 3409 	strd	r3, r4, [sp, #36]	; 0x24
 8025d64:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025d66:	930e      	str	r3, [sp, #56]	; 0x38
 8025d68:	440d      	add	r5, r1
 8025d6a:	f101 0308 	add.w	r3, r1, #8
 8025d6e:	9411      	str	r4, [sp, #68]	; 0x44
 8025d70:	9510      	str	r5, [sp, #64]	; 0x40
 8025d72:	900f      	str	r0, [sp, #60]	; 0x3c
 8025d74:	9313      	str	r3, [sp, #76]	; 0x4c
        if (nonunit) {
 8025d76:	9b05      	ldr	r3, [sp, #20]
 8025d78:	2b83      	cmp	r3, #131	; 0x83
 8025d7a:	f000 8506 	beq.w	802678a <cblas_ztrsm+0x194a>
        for (k = i + 1; k < n1; k++) {
 8025d7e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8025d80:	9a06      	ldr	r2, [sp, #24]
 8025d82:	3301      	adds	r3, #1
 8025d84:	429a      	cmp	r2, r3
 8025d86:	930a      	str	r3, [sp, #40]	; 0x28
 8025d88:	f77f aee6 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8025d8c:	ee1c 0a10 	vmov	r0, s24
 8025d90:	f002 f820 	bl	8027dd4 <__aeabi_i2d>
 8025d94:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025d96:	ec41 0b1b 	vmov	d11, r0, r1
 8025d9a:	4619      	mov	r1, r3
 8025d9c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8025d9e:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 8025da2:	9204      	str	r2, [sp, #16]
 8025da4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8025da6:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 8025daa:	9301      	str	r3, [sp, #4]
 8025dac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8025dae:	9300      	str	r3, [sp, #0]
 8025db0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8025db2:	9307      	str	r3, [sp, #28]
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8025db4:	9c00      	ldr	r4, [sp, #0]
 8025db6:	ec51 0b1b 	vmov	r0, r1, d11
 8025dba:	e9d4 2300 	ldrd	r2, r3, [r4]
 8025dbe:	f002 f873 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8025dc2:	ed14 7b02 	vldr	d7, [r4, #-8]
          for (j = 0; j < n2; j++) {
 8025dc6:	9b02      	ldr	r3, [sp, #8]
          const BASE Aki_real = CONST_REAL(A, k * lda + i);
 8025dc8:	eeb0 9a47 	vmov.f32	s18, s14
 8025dcc:	eef0 9a67 	vmov.f32	s19, s15
          for (j = 0; j < n2; j++) {
 8025dd0:	2b00      	cmp	r3, #0
          const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
 8025dd2:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8025dd6:	dd49      	ble.n	8025e6c <cblas_ztrsm+0x102c>
 8025dd8:	9b04      	ldr	r3, [sp, #16]
 8025dda:	9c08      	ldr	r4, [sp, #32]
 8025ddc:	9d01      	ldr	r5, [sp, #4]
 8025dde:	f103 0b08 	add.w	fp, r3, #8
 8025de2:	469a      	mov	sl, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025de4:	e9d4 6700 	ldrd	r6, r7, [r4]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8025de8:	ec51 0b19 	vmov	r0, r1, d9
 8025dec:	4632      	mov	r2, r6
 8025dee:	463b      	mov	r3, r7
 8025df0:	f002 f85a 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8025df4:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8025df8:	ec41 0b1a 	vmov	d10, r0, r1
 8025dfc:	4642      	mov	r2, r8
 8025dfe:	464b      	mov	r3, r9
 8025e00:	ec51 0b18 	vmov	r0, r1, d8
 8025e04:	f002 f850 	bl	8027ea8 <__aeabi_dmul>
 8025e08:	4602      	mov	r2, r0
 8025e0a:	460b      	mov	r3, r1
 8025e0c:	ec51 0b1a 	vmov	r0, r1, d10
 8025e10:	f001 fe92 	bl	8027b38 <__aeabi_dsub>
 8025e14:	4602      	mov	r2, r0
 8025e16:	460b      	mov	r3, r1
 8025e18:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8025e1c:	f001 fe8c 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8025e20:	4642      	mov	r2, r8
            REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
 8025e22:	e94b 0102 	strd	r0, r1, [fp, #-8]
            IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
 8025e26:	464b      	mov	r3, r9
 8025e28:	ec51 0b19 	vmov	r0, r1, d9
 8025e2c:	f002 f83c 	bl	8027ea8 <__aeabi_dmul>
 8025e30:	4632      	mov	r2, r6
 8025e32:	463b      	mov	r3, r7
 8025e34:	4606      	mov	r6, r0
 8025e36:	460f      	mov	r7, r1
 8025e38:	ec51 0b18 	vmov	r0, r1, d8
 8025e3c:	f002 f834 	bl	8027ea8 <__aeabi_dmul>
 8025e40:	4602      	mov	r2, r0
 8025e42:	460b      	mov	r3, r1
 8025e44:	4630      	mov	r0, r6
 8025e46:	4639      	mov	r1, r7
 8025e48:	f001 fe78 	bl	8027b3c <__adddf3>
 8025e4c:	4602      	mov	r2, r0
 8025e4e:	460b      	mov	r3, r1
 8025e50:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 8025e54:	f001 fe70 	bl	8027b38 <__aeabi_dsub>
 8025e58:	f10a 0a10 	add.w	sl, sl, #16
 8025e5c:	e94a 0102 	strd	r0, r1, [sl, #-8]
          for (j = 0; j < n2; j++) {
 8025e60:	4555      	cmp	r5, sl
 8025e62:	f104 0410 	add.w	r4, r4, #16
 8025e66:	f10b 0b10 	add.w	fp, fp, #16
 8025e6a:	d1bb      	bne.n	8025de4 <cblas_ztrsm+0xfa4>
        for (k = i + 1; k < n1; k++) {
 8025e6c:	9904      	ldr	r1, [sp, #16]
 8025e6e:	9a03      	ldr	r2, [sp, #12]
 8025e70:	9b07      	ldr	r3, [sp, #28]
 8025e72:	4608      	mov	r0, r1
 8025e74:	9901      	ldr	r1, [sp, #4]
 8025e76:	4411      	add	r1, r2
 8025e78:	4410      	add	r0, r2
 8025e7a:	9101      	str	r1, [sp, #4]
 8025e7c:	9a00      	ldr	r2, [sp, #0]
 8025e7e:	9909      	ldr	r1, [sp, #36]	; 0x24
 8025e80:	9004      	str	r0, [sp, #16]
 8025e82:	440a      	add	r2, r1
 8025e84:	9200      	str	r2, [sp, #0]
 8025e86:	9a06      	ldr	r2, [sp, #24]
 8025e88:	3301      	adds	r3, #1
 8025e8a:	429a      	cmp	r2, r3
 8025e8c:	9307      	str	r3, [sp, #28]
 8025e8e:	d191      	bne.n	8025db4 <cblas_ztrsm+0xf74>
 8025e90:	9b08      	ldr	r3, [sp, #32]
 8025e92:	9a03      	ldr	r2, [sp, #12]
 8025e94:	4413      	add	r3, r2
 8025e96:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8025e98:	9308      	str	r3, [sp, #32]
 8025e9a:	4611      	mov	r1, r2
 8025e9c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025e9e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8025ea0:	441a      	add	r2, r3
 8025ea2:	920e      	str	r2, [sp, #56]	; 0x38
 8025ea4:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8025ea6:	4419      	add	r1, r3
 8025ea8:	9111      	str	r1, [sp, #68]	; 0x44
 8025eaa:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8025eac:	4611      	mov	r1, r2
 8025eae:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8025eb0:	4419      	add	r1, r3
 8025eb2:	441a      	add	r2, r3
 8025eb4:	910d      	str	r1, [sp, #52]	; 0x34
 8025eb6:	920f      	str	r2, [sp, #60]	; 0x3c
 8025eb8:	e75d      	b.n	8025d76 <cblas_ztrsm+0xf36>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 8025eba:	f002 fa5d 	bl	8028378 <__aeabi_dcmpeq>
 8025ebe:	2800      	cmp	r0, #0
 8025ec0:	f000 84da 	beq.w	8026878 <cblas_ztrsm+0x1a38>
 8025ec4:	2200      	movs	r2, #0
 8025ec6:	2300      	movs	r3, #0
 8025ec8:	4650      	mov	r0, sl
 8025eca:	4659      	mov	r1, fp
 8025ecc:	f002 fa54 	bl	8028378 <__aeabi_dcmpeq>
 8025ed0:	2800      	cmp	r0, #0
 8025ed2:	f000 84d1 	beq.w	8026878 <cblas_ztrsm+0x1a38>
      for (i = 0; i < n1; i++) {
 8025ed6:	9b06      	ldr	r3, [sp, #24]
 8025ed8:	2b00      	cmp	r3, #0
 8025eda:	f77f ae3d 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8025ede:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8025ee0:	011b      	lsls	r3, r3, #4
 8025ee2:	9303      	str	r3, [sp, #12]
 8025ee4:	9b02      	ldr	r3, [sp, #8]
 8025ee6:	011b      	lsls	r3, r3, #4
 8025ee8:	9310      	str	r3, [sp, #64]	; 0x40
 8025eea:	9a01      	ldr	r2, [sp, #4]
 8025eec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8025eee:	3201      	adds	r2, #1
 8025ef0:	0112      	lsls	r2, r2, #4
 8025ef2:	9209      	str	r2, [sp, #36]	; 0x24
 8025ef4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8025ef6:	3b10      	subs	r3, #16
            for (k = j + 1; k < n2; k++) {
 8025ef8:	2100      	movs	r1, #0
 8025efa:	441a      	add	r2, r3
 8025efc:	910d      	str	r1, [sp, #52]	; 0x34
 8025efe:	9200      	str	r2, [sp, #0]
 8025f00:	910e      	str	r1, [sp, #56]	; 0x38
        for (j = 0; j < n2; j++) {
 8025f02:	9b02      	ldr	r3, [sp, #8]
 8025f04:	2b00      	cmp	r3, #0
 8025f06:	f340 80ea 	ble.w	80260de <cblas_ztrsm+0x129e>
 8025f0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8025f0c:	9304      	str	r3, [sp, #16]
 8025f0e:	3308      	adds	r3, #8
 8025f10:	e9dd 210c 	ldrd	r2, r1, [sp, #48]	; 0x30
 8025f14:	9308      	str	r3, [sp, #32]
 8025f16:	2300      	movs	r3, #0
 8025f18:	9307      	str	r3, [sp, #28]
          if (nonunit) {
 8025f1a:	9b05      	ldr	r3, [sp, #20]
 8025f1c:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 8025f20:	2b83      	cmp	r3, #131	; 0x83
 8025f22:	9201      	str	r2, [sp, #4]
 8025f24:	d070      	beq.n	8026008 <cblas_ztrsm+0x11c8>
 8025f26:	9b01      	ldr	r3, [sp, #4]
 8025f28:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025f2c:	9c01      	ldr	r4, [sp, #4]
            for (k = j + 1; k < n2; k++) {
 8025f2e:	9b07      	ldr	r3, [sp, #28]
 8025f30:	9a02      	ldr	r2, [sp, #8]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025f32:	ed94 7b00 	vldr	d7, [r4]
            for (k = j + 1; k < n2; k++) {
 8025f36:	3301      	adds	r3, #1
 8025f38:	429a      	cmp	r2, r3
 8025f3a:	9307      	str	r3, [sp, #28]
            const BASE Bij_real = REAL(B, ldb * i + j);
 8025f3c:	eeb0 8a47 	vmov.f32	s16, s14
 8025f40:	eef0 8a67 	vmov.f32	s17, s15
            for (k = j + 1; k < n2; k++) {
 8025f44:	f000 80cb 	beq.w	80260de <cblas_ztrsm+0x129e>
 8025f48:	ee1c 0a10 	vmov	r0, s24
 8025f4c:	f001 ff42 	bl	8027dd4 <__aeabi_i2d>
 8025f50:	f8dd b010 	ldr.w	fp, [sp, #16]
 8025f54:	ec41 0b1a 	vmov	d10, r0, r1
 8025f58:	46a2      	mov	sl, r4
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8025f5a:	e9db 2306 	ldrd	r2, r3, [fp, #24]
 8025f5e:	ec51 0b1a 	vmov	r0, r1, d10
 8025f62:	f001 ffa1 	bl	8027ea8 <__aeabi_dmul>
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 8025f66:	e9db 8904 	ldrd	r8, r9, [fp, #16]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 8025f6a:	4604      	mov	r4, r0
 8025f6c:	460d      	mov	r5, r1
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8025f6e:	4642      	mov	r2, r8
 8025f70:	464b      	mov	r3, r9
 8025f72:	ec51 0b18 	vmov	r0, r1, d8
 8025f76:	f001 ff97 	bl	8027ea8 <__aeabi_dmul>
 8025f7a:	4632      	mov	r2, r6
 8025f7c:	ec41 0b19 	vmov	d9, r0, r1
 8025f80:	463b      	mov	r3, r7
 8025f82:	4620      	mov	r0, r4
 8025f84:	4629      	mov	r1, r5
 8025f86:	f001 ff8f 	bl	8027ea8 <__aeabi_dmul>
 8025f8a:	4602      	mov	r2, r0
 8025f8c:	460b      	mov	r3, r1
 8025f8e:	ec51 0b19 	vmov	r0, r1, d9
 8025f92:	f001 fdd1 	bl	8027b38 <__aeabi_dsub>
 8025f96:	4602      	mov	r2, r0
 8025f98:	460b      	mov	r3, r1
 8025f9a:	e9da 0104 	ldrd	r0, r1, [sl, #16]
 8025f9e:	f001 fdcb 	bl	8027b38 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8025fa2:	4632      	mov	r2, r6
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 8025fa4:	e9ca 0104 	strd	r0, r1, [sl, #16]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8025fa8:	463b      	mov	r3, r7
 8025faa:	4640      	mov	r0, r8
 8025fac:	4649      	mov	r1, r9
 8025fae:	f001 ff7b 	bl	8027ea8 <__aeabi_dmul>
 8025fb2:	4622      	mov	r2, r4
 8025fb4:	462b      	mov	r3, r5
 8025fb6:	4604      	mov	r4, r0
 8025fb8:	460d      	mov	r5, r1
 8025fba:	ec51 0b18 	vmov	r0, r1, d8
 8025fbe:	f001 ff73 	bl	8027ea8 <__aeabi_dmul>
 8025fc2:	4602      	mov	r2, r0
 8025fc4:	460b      	mov	r3, r1
 8025fc6:	4620      	mov	r0, r4
 8025fc8:	4629      	mov	r1, r5
 8025fca:	f001 fdb7 	bl	8027b3c <__adddf3>
 8025fce:	460b      	mov	r3, r1
 8025fd0:	4602      	mov	r2, r0
 8025fd2:	e9da 0106 	ldrd	r0, r1, [sl, #24]
 8025fd6:	f001 fdaf 	bl	8027b38 <__aeabi_dsub>
            for (k = j + 1; k < n2; k++) {
 8025fda:	9b00      	ldr	r3, [sp, #0]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8025fdc:	e9ca 0106 	strd	r0, r1, [sl, #24]
            for (k = j + 1; k < n2; k++) {
 8025fe0:	f10a 0a10 	add.w	sl, sl, #16
 8025fe4:	4553      	cmp	r3, sl
 8025fe6:	f10b 0b10 	add.w	fp, fp, #16
 8025fea:	d1b6      	bne.n	8025f5a <cblas_ztrsm+0x111a>
 8025fec:	9a04      	ldr	r2, [sp, #16]
 8025fee:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8025ff0:	4611      	mov	r1, r2
 8025ff2:	9a01      	ldr	r2, [sp, #4]
 8025ff4:	3210      	adds	r2, #16
 8025ff6:	9201      	str	r2, [sp, #4]
 8025ff8:	9a08      	ldr	r2, [sp, #32]
 8025ffa:	4419      	add	r1, r3
 8025ffc:	441a      	add	r2, r3
          if (nonunit) {
 8025ffe:	9b05      	ldr	r3, [sp, #20]
 8026000:	9104      	str	r1, [sp, #16]
 8026002:	2b83      	cmp	r3, #131	; 0x83
 8026004:	9208      	str	r2, [sp, #32]
 8026006:	d18e      	bne.n	8025f26 <cblas_ztrsm+0x10e6>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026008:	ee1c 0a10 	vmov	r0, s24
 802600c:	f001 fee2 	bl	8027dd4 <__aeabi_i2d>
 8026010:	9c08      	ldr	r4, [sp, #32]
 8026012:	e9d4 2300 	ldrd	r2, r3, [r4]
 8026016:	f001 ff47 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 802601a:	e954 4502 	ldrd	r4, r5, [r4, #-8]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 802601e:	4606      	mov	r6, r0
 8026020:	460f      	mov	r7, r1
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8026022:	4632      	mov	r2, r6
 8026024:	463b      	mov	r3, r7
 8026026:	4620      	mov	r0, r4
 8026028:	4629      	mov	r1, r5
 802602a:	f7fe fed1 	bl	8024dd0 <xhypot>
 802602e:	4682      	mov	sl, r0
 8026030:	468b      	mov	fp, r1
            const BASE a_real = Ajj_real / s;
 8026032:	4620      	mov	r0, r4
 8026034:	4629      	mov	r1, r5
 8026036:	4652      	mov	r2, sl
 8026038:	465b      	mov	r3, fp
 802603a:	f002 f85f 	bl	80280fc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 802603e:	4652      	mov	r2, sl
            const BASE a_real = Ajj_real / s;
 8026040:	4604      	mov	r4, r0
 8026042:	460d      	mov	r5, r1
            const BASE a_imag = Ajj_imag / s;
 8026044:	465b      	mov	r3, fp
 8026046:	4630      	mov	r0, r6
 8026048:	4639      	mov	r1, r7
 802604a:	f002 f857 	bl	80280fc <__aeabi_ddiv>
            const BASE a_real = Ajj_real / s;
 802604e:	ec45 4b19 	vmov	d9, r4, r5
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026052:	9d01      	ldr	r5, [sp, #4]
 8026054:	ed95 7b00 	vldr	d7, [r5]
            const BASE a_imag = Ajj_imag / s;
 8026058:	4680      	mov	r8, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802605a:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 802605e:	eeb0 8a47 	vmov.f32	s16, s14
 8026062:	eef0 8a67 	vmov.f32	s17, s15
            const BASE a_imag = Ajj_imag / s;
 8026066:	4689      	mov	r9, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026068:	ec51 0b19 	vmov	r0, r1, d9
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802606c:	e9d5 6702 	ldrd	r6, r7, [r5, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026070:	f001 ff1a 	bl	8027ea8 <__aeabi_dmul>
 8026074:	4632      	mov	r2, r6
 8026076:	463b      	mov	r3, r7
 8026078:	4604      	mov	r4, r0
 802607a:	460d      	mov	r5, r1
 802607c:	4640      	mov	r0, r8
 802607e:	4649      	mov	r1, r9
 8026080:	f001 ff12 	bl	8027ea8 <__aeabi_dmul>
 8026084:	4602      	mov	r2, r0
 8026086:	460b      	mov	r3, r1
 8026088:	4620      	mov	r0, r4
 802608a:	4629      	mov	r1, r5
 802608c:	f001 fd56 	bl	8027b3c <__adddf3>
 8026090:	4652      	mov	r2, sl
 8026092:	465b      	mov	r3, fp
 8026094:	f002 f832 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026098:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802609a:	9e01      	ldr	r6, [sp, #4]
 802609c:	4604      	mov	r4, r0
 802609e:	460d      	mov	r5, r1
 80260a0:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80260a4:	463b      	mov	r3, r7
 80260a6:	ec51 0b19 	vmov	r0, r1, d9
 80260aa:	f001 fefd 	bl	8027ea8 <__aeabi_dmul>
 80260ae:	ec53 2b18 	vmov	r2, r3, d8
 80260b2:	460d      	mov	r5, r1
 80260b4:	4604      	mov	r4, r0
 80260b6:	4649      	mov	r1, r9
 80260b8:	4640      	mov	r0, r8
 80260ba:	f001 fef5 	bl	8027ea8 <__aeabi_dmul>
 80260be:	4602      	mov	r2, r0
 80260c0:	460b      	mov	r3, r1
 80260c2:	4620      	mov	r0, r4
 80260c4:	4629      	mov	r1, r5
 80260c6:	f001 fd37 	bl	8027b38 <__aeabi_dsub>
 80260ca:	4652      	mov	r2, sl
 80260cc:	465b      	mov	r3, fp
 80260ce:	f002 f815 	bl	80280fc <__aeabi_ddiv>
 80260d2:	9d01      	ldr	r5, [sp, #4]
 80260d4:	4606      	mov	r6, r0
 80260d6:	460f      	mov	r7, r1
 80260d8:	e9c5 6702 	strd	r6, r7, [r5, #8]
 80260dc:	e726      	b.n	8025f2c <cblas_ztrsm+0x10ec>
      for (i = 0; i < n1; i++) {
 80260de:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80260e0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80260e2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80260e4:	440a      	add	r2, r1
 80260e6:	920d      	str	r2, [sp, #52]	; 0x34
 80260e8:	9903      	ldr	r1, [sp, #12]
 80260ea:	9a00      	ldr	r2, [sp, #0]
 80260ec:	440a      	add	r2, r1
 80260ee:	9200      	str	r2, [sp, #0]
 80260f0:	9a06      	ldr	r2, [sp, #24]
 80260f2:	3301      	adds	r3, #1
 80260f4:	429a      	cmp	r2, r3
 80260f6:	930e      	str	r3, [sp, #56]	; 0x38
 80260f8:	f73f af03 	bgt.w	8025f02 <cblas_ztrsm+0x10c2>
 80260fc:	e52c      	b.n	8025b58 <cblas_ztrsm+0xd18>
      if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
 80260fe:	f002 f93b 	bl	8028378 <__aeabi_dcmpeq>
 8026102:	2800      	cmp	r0, #0
 8026104:	f000 82df 	beq.w	80266c6 <cblas_ztrsm+0x1886>
 8026108:	2200      	movs	r2, #0
 802610a:	2300      	movs	r3, #0
 802610c:	4650      	mov	r0, sl
 802610e:	4659      	mov	r1, fp
 8026110:	f002 f932 	bl	8028378 <__aeabi_dcmpeq>
 8026114:	2800      	cmp	r0, #0
 8026116:	f000 82d6 	beq.w	80266c6 <cblas_ztrsm+0x1886>
      for (i = 0; i < n1; i++) {
 802611a:	9b06      	ldr	r3, [sp, #24]
 802611c:	2b00      	cmp	r3, #0
 802611e:	f77f ad1b 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8026122:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026124:	011b      	lsls	r3, r3, #4
 8026126:	9303      	str	r3, [sp, #12]
 8026128:	9b02      	ldr	r3, [sp, #8]
 802612a:	011b      	lsls	r3, r3, #4
 802612c:	9310      	str	r3, [sp, #64]	; 0x40
 802612e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8026130:	9408      	str	r4, [sp, #32]
 8026132:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8026134:	9b02      	ldr	r3, [sp, #8]
 8026136:	9a01      	ldr	r2, [sp, #4]
 8026138:	3c10      	subs	r4, #16
 802613a:	3b01      	subs	r3, #1
 802613c:	940e      	str	r4, [sp, #56]	; 0x38
 802613e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8026140:	fb02 f003 	mul.w	r0, r2, r3
 8026144:	fb02 3303 	mla	r3, r2, r3, r3
 8026148:	ebc2 7102 	rsb	r1, r2, r2, lsl #28
 802614c:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8026150:	43d2      	mvns	r2, r2
 8026152:	930d      	str	r3, [sp, #52]	; 0x34
 8026154:	010b      	lsls	r3, r1, #4
 8026156:	930a      	str	r3, [sp, #40]	; 0x28
 8026158:	0113      	lsls	r3, r2, #4
 802615a:	eb04 1000 	add.w	r0, r4, r0, lsl #4
 802615e:	9309      	str	r3, [sp, #36]	; 0x24
        for (j = n2; j > 0 && j--;) {
 8026160:	2300      	movs	r3, #0
 8026162:	900c      	str	r0, [sp, #48]	; 0x30
 8026164:	930b      	str	r3, [sp, #44]	; 0x2c
 8026166:	9b02      	ldr	r3, [sp, #8]
 8026168:	2b00      	cmp	r3, #0
 802616a:	f340 80ee 	ble.w	802634a <cblas_ztrsm+0x150a>
 802616e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026170:	9908      	ldr	r1, [sp, #32]
 8026172:	9301      	str	r3, [sp, #4]
 8026174:	440a      	add	r2, r1
 8026176:	9200      	str	r2, [sp, #0]
 8026178:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802617a:	9207      	str	r2, [sp, #28]
 802617c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802617e:	9204      	str	r2, [sp, #16]
 8026180:	9b01      	ldr	r3, [sp, #4]
 8026182:	3b01      	subs	r3, #1
 8026184:	9301      	str	r3, [sp, #4]
          if (nonunit) {
 8026186:	9b05      	ldr	r3, [sp, #20]
 8026188:	2b83      	cmp	r3, #131	; 0x83
 802618a:	d076      	beq.n	802627a <cblas_ztrsm+0x143a>
 802618c:	9b00      	ldr	r3, [sp, #0]
 802618e:	ed93 7b02 	vldr	d7, [r3, #8]
 8026192:	eeb0 9a47 	vmov.f32	s18, s14
 8026196:	eef0 9a67 	vmov.f32	s19, s15
            const BASE Bij_real = REAL(B, ldb * i + j);
 802619a:	9f00      	ldr	r7, [sp, #0]
            for (k = 0; k < j; k++) {
 802619c:	9b01      	ldr	r3, [sp, #4]
            const BASE Bij_real = REAL(B, ldb * i + j);
 802619e:	ed97 7b00 	vldr	d7, [r7]
 80261a2:	eeb0 aa47 	vmov.f32	s20, s14
 80261a6:	eef0 aa67 	vmov.f32	s21, s15
            for (k = 0; k < j; k++) {
 80261aa:	2b00      	cmp	r3, #0
 80261ac:	f000 80cd 	beq.w	802634a <cblas_ztrsm+0x150a>
 80261b0:	ee1c 0a10 	vmov	r0, s24
 80261b4:	f001 fe0e 	bl	8027dd4 <__aeabi_i2d>
 80261b8:	9b08      	ldr	r3, [sp, #32]
 80261ba:	9e04      	ldr	r6, [sp, #16]
 80261bc:	ec41 0b1b 	vmov	d11, r0, r1
 80261c0:	f103 0b08 	add.w	fp, r3, #8
 80261c4:	469a      	mov	sl, r3
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80261c6:	ed96 7b00 	vldr	d7, [r6]
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 80261ca:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
 80261ce:	eeb0 8a47 	vmov.f32	s16, s14
 80261d2:	eef0 8a67 	vmov.f32	s17, s15
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 80261d6:	ec51 0b1b 	vmov	r0, r1, d11
 80261da:	f001 fe65 	bl	8027ea8 <__aeabi_dmul>
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80261de:	ec53 2b18 	vmov	r2, r3, d8
              const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
 80261e2:	4680      	mov	r8, r0
 80261e4:	4689      	mov	r9, r1
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 80261e6:	ec51 0b1a 	vmov	r0, r1, d10
 80261ea:	f001 fe5d 	bl	8027ea8 <__aeabi_dmul>
 80261ee:	ec53 2b19 	vmov	r2, r3, d9
 80261f2:	4604      	mov	r4, r0
 80261f4:	460d      	mov	r5, r1
 80261f6:	4640      	mov	r0, r8
 80261f8:	4649      	mov	r1, r9
 80261fa:	f001 fe55 	bl	8027ea8 <__aeabi_dmul>
 80261fe:	4602      	mov	r2, r0
 8026200:	460b      	mov	r3, r1
 8026202:	4620      	mov	r0, r4
 8026204:	4629      	mov	r1, r5
 8026206:	f001 fc97 	bl	8027b38 <__aeabi_dsub>
 802620a:	4602      	mov	r2, r0
 802620c:	460b      	mov	r3, r1
 802620e:	e95b 0102 	ldrd	r0, r1, [fp, #-8]
 8026212:	f001 fc91 	bl	8027b38 <__aeabi_dsub>
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 8026216:	ec53 2b19 	vmov	r2, r3, d9
              REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
 802621a:	e94b 0102 	strd	r0, r1, [fp, #-8]
              IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
 802621e:	ec51 0b18 	vmov	r0, r1, d8
 8026222:	f001 fe41 	bl	8027ea8 <__aeabi_dmul>
 8026226:	4642      	mov	r2, r8
 8026228:	464b      	mov	r3, r9
 802622a:	4604      	mov	r4, r0
 802622c:	460d      	mov	r5, r1
 802622e:	ec51 0b1a 	vmov	r0, r1, d10
 8026232:	f001 fe39 	bl	8027ea8 <__aeabi_dmul>
 8026236:	4602      	mov	r2, r0
 8026238:	460b      	mov	r3, r1
 802623a:	4620      	mov	r0, r4
 802623c:	4629      	mov	r1, r5
 802623e:	f001 fc7d 	bl	8027b3c <__adddf3>
 8026242:	4602      	mov	r2, r0
 8026244:	460b      	mov	r3, r1
 8026246:	e9da 0102 	ldrd	r0, r1, [sl, #8]
 802624a:	f001 fc75 	bl	8027b38 <__aeabi_dsub>
 802624e:	f10a 0a10 	add.w	sl, sl, #16
 8026252:	e94a 0102 	strd	r0, r1, [sl, #-8]
            for (k = 0; k < j; k++) {
 8026256:	45ba      	cmp	sl, r7
 8026258:	f106 0610 	add.w	r6, r6, #16
 802625c:	f10b 0b10 	add.w	fp, fp, #16
 8026260:	d1b1      	bne.n	80261c6 <cblas_ztrsm+0x1386>
 8026262:	9b04      	ldr	r3, [sp, #16]
 8026264:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026266:	4413      	add	r3, r2
 8026268:	9304      	str	r3, [sp, #16]
 802626a:	9b00      	ldr	r3, [sp, #0]
 802626c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802626e:	3b10      	subs	r3, #16
 8026270:	9300      	str	r3, [sp, #0]
 8026272:	9b07      	ldr	r3, [sp, #28]
 8026274:	4413      	add	r3, r2
 8026276:	9307      	str	r3, [sp, #28]
 8026278:	e782      	b.n	8026180 <cblas_ztrsm+0x1340>
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 802627a:	ee1c 0a10 	vmov	r0, s24
 802627e:	f001 fda9 	bl	8027dd4 <__aeabi_i2d>
 8026282:	9c07      	ldr	r4, [sp, #28]
 8026284:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8026288:	f001 fe0e 	bl	8027ea8 <__aeabi_dmul>
            const BASE Ajj_real = CONST_REAL(A, lda * j + j);
 802628c:	e9d4 6700 	ldrd	r6, r7, [r4]
            const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
 8026290:	460d      	mov	r5, r1
 8026292:	4604      	mov	r4, r0
            const BASE s = xhypot(Ajj_real, Ajj_imag);
 8026294:	4622      	mov	r2, r4
 8026296:	462b      	mov	r3, r5
 8026298:	4630      	mov	r0, r6
 802629a:	4639      	mov	r1, r7
 802629c:	f7fe fd98 	bl	8024dd0 <xhypot>
 80262a0:	4682      	mov	sl, r0
 80262a2:	468b      	mov	fp, r1
            const BASE a_real = Ajj_real / s;
 80262a4:	4630      	mov	r0, r6
 80262a6:	4639      	mov	r1, r7
 80262a8:	4652      	mov	r2, sl
 80262aa:	465b      	mov	r3, fp
 80262ac:	f001 ff26 	bl	80280fc <__aeabi_ddiv>
            const BASE a_imag = Ajj_imag / s;
 80262b0:	4652      	mov	r2, sl
            const BASE a_real = Ajj_real / s;
 80262b2:	4606      	mov	r6, r0
 80262b4:	460f      	mov	r7, r1
            const BASE a_imag = Ajj_imag / s;
 80262b6:	465b      	mov	r3, fp
 80262b8:	4620      	mov	r0, r4
 80262ba:	4629      	mov	r1, r5
 80262bc:	f001 ff1e 	bl	80280fc <__aeabi_ddiv>
            const BASE Bij_real = REAL(B, ldb * i + j);
 80262c0:	9c00      	ldr	r4, [sp, #0]
 80262c2:	ed94 7b00 	vldr	d7, [r4]
            const BASE a_imag = Ajj_imag / s;
 80262c6:	4680      	mov	r8, r0
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80262c8:	ec53 2b17 	vmov	r2, r3, d7
            const BASE Bij_real = REAL(B, ldb * i + j);
 80262cc:	eeb0 9a47 	vmov.f32	s18, s14
 80262d0:	eef0 9a67 	vmov.f32	s19, s15
            const BASE a_imag = Ajj_imag / s;
 80262d4:	4689      	mov	r9, r1
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80262d6:	4630      	mov	r0, r6
 80262d8:	4639      	mov	r1, r7
 80262da:	f001 fde5 	bl	8027ea8 <__aeabi_dmul>
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80262de:	ed94 8b02 	vldr	d8, [r4, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80262e2:	460d      	mov	r5, r1
 80262e4:	ec53 2b18 	vmov	r2, r3, d8
 80262e8:	4604      	mov	r4, r0
 80262ea:	4649      	mov	r1, r9
 80262ec:	4640      	mov	r0, r8
 80262ee:	f001 fddb 	bl	8027ea8 <__aeabi_dmul>
 80262f2:	4602      	mov	r2, r0
 80262f4:	460b      	mov	r3, r1
 80262f6:	4620      	mov	r0, r4
 80262f8:	4629      	mov	r1, r5
 80262fa:	f001 fc1f 	bl	8027b3c <__adddf3>
 80262fe:	4652      	mov	r2, sl
 8026300:	465b      	mov	r3, fp
 8026302:	f001 fefb 	bl	80280fc <__aeabi_ddiv>
 8026306:	4604      	mov	r4, r0
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026308:	4630      	mov	r0, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802630a:	9e00      	ldr	r6, [sp, #0]
 802630c:	460d      	mov	r5, r1
 802630e:	e9c6 4500 	strd	r4, r5, [r6]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026312:	ec53 2b18 	vmov	r2, r3, d8
 8026316:	4639      	mov	r1, r7
 8026318:	f001 fdc6 	bl	8027ea8 <__aeabi_dmul>
 802631c:	ec53 2b19 	vmov	r2, r3, d9
 8026320:	4604      	mov	r4, r0
 8026322:	460d      	mov	r5, r1
 8026324:	4640      	mov	r0, r8
 8026326:	4649      	mov	r1, r9
 8026328:	f001 fdbe 	bl	8027ea8 <__aeabi_dmul>
 802632c:	4602      	mov	r2, r0
 802632e:	460b      	mov	r3, r1
 8026330:	4620      	mov	r0, r4
 8026332:	4629      	mov	r1, r5
 8026334:	f001 fc00 	bl	8027b38 <__aeabi_dsub>
 8026338:	4652      	mov	r2, sl
 802633a:	465b      	mov	r3, fp
 802633c:	f001 fede 	bl	80280fc <__aeabi_ddiv>
 8026340:	e9c6 0102 	strd	r0, r1, [r6, #8]
 8026344:	ec41 0b19 	vmov	d9, r0, r1
 8026348:	e727      	b.n	802619a <cblas_ztrsm+0x135a>
      for (i = 0; i < n1; i++) {
 802634a:	9a08      	ldr	r2, [sp, #32]
 802634c:	9903      	ldr	r1, [sp, #12]
 802634e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026350:	440a      	add	r2, r1
 8026352:	9208      	str	r2, [sp, #32]
 8026354:	9a06      	ldr	r2, [sp, #24]
 8026356:	3301      	adds	r3, #1
 8026358:	429a      	cmp	r2, r3
 802635a:	930b      	str	r3, [sp, #44]	; 0x2c
 802635c:	f73f af03 	bgt.w	8026166 <cblas_ztrsm+0x1326>
 8026360:	f7ff bbfa 	b.w	8025b58 <cblas_ztrsm+0xd18>
        for (i = 0; i < n1; i++) {
 8026364:	9b06      	ldr	r3, [sp, #24]
 8026366:	2b00      	cmp	r3, #0
 8026368:	f77f abf6 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 802636c:	9a02      	ldr	r2, [sp, #8]
 802636e:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8026372:	011b      	lsls	r3, r3, #4
 8026374:	9307      	str	r3, [sp, #28]
 8026376:	3308      	adds	r3, #8
 8026378:	9308      	str	r3, [sp, #32]
 802637a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802637c:	011b      	lsls	r3, r3, #4
 802637e:	9303      	str	r3, [sp, #12]
 8026380:	0113      	lsls	r3, r2, #4
 8026382:	9310      	str	r3, [sp, #64]	; 0x40
 8026384:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026386:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802638a:	9300      	str	r3, [sp, #0]
 802638c:	2300      	movs	r3, #0
 802638e:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8026390:	9b02      	ldr	r3, [sp, #8]
 8026392:	2b00      	cmp	r3, #0
 8026394:	dd3e      	ble.n	8026414 <cblas_ztrsm+0x15d4>
 8026396:	9b07      	ldr	r3, [sp, #28]
 8026398:	9a08      	ldr	r2, [sp, #32]
 802639a:	4619      	mov	r1, r3
 802639c:	9b00      	ldr	r3, [sp, #0]
 802639e:	eb01 0803 	add.w	r8, r1, r3
 80263a2:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 80263a6:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80263aa:	ec53 2b18 	vmov	r2, r3, d8
 80263ae:	4630      	mov	r0, r6
 80263b0:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80263b2:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80263b6:	f001 fd77 	bl	8027ea8 <__aeabi_dmul>
 80263ba:	4652      	mov	r2, sl
 80263bc:	ec41 0b19 	vmov	d9, r0, r1
 80263c0:	465b      	mov	r3, fp
 80263c2:	4620      	mov	r0, r4
 80263c4:	4629      	mov	r1, r5
 80263c6:	f001 fd6f 	bl	8027ea8 <__aeabi_dmul>
 80263ca:	4602      	mov	r2, r0
 80263cc:	460b      	mov	r3, r1
 80263ce:	ec51 0b19 	vmov	r0, r1, d9
 80263d2:	f001 fbb1 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80263d6:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80263da:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80263de:	4620      	mov	r0, r4
 80263e0:	4629      	mov	r1, r5
 80263e2:	f001 fd61 	bl	8027ea8 <__aeabi_dmul>
 80263e6:	4652      	mov	r2, sl
 80263e8:	465b      	mov	r3, fp
 80263ea:	4604      	mov	r4, r0
 80263ec:	460d      	mov	r5, r1
 80263ee:	4630      	mov	r0, r6
 80263f0:	4639      	mov	r1, r7
 80263f2:	f001 fd59 	bl	8027ea8 <__aeabi_dmul>
 80263f6:	460b      	mov	r3, r1
 80263f8:	4602      	mov	r2, r0
 80263fa:	4629      	mov	r1, r5
 80263fc:	4620      	mov	r0, r4
 80263fe:	f001 fb9d 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 8026402:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026404:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8026408:	f108 0810 	add.w	r8, r8, #16
 802640c:	4543      	cmp	r3, r8
 802640e:	f109 0910 	add.w	r9, r9, #16
 8026412:	d1c8      	bne.n	80263a6 <cblas_ztrsm+0x1566>
        for (i = 0; i < n1; i++) {
 8026414:	9a00      	ldr	r2, [sp, #0]
 8026416:	9903      	ldr	r1, [sp, #12]
 8026418:	9b04      	ldr	r3, [sp, #16]
 802641a:	440a      	add	r2, r1
 802641c:	9200      	str	r2, [sp, #0]
 802641e:	9a06      	ldr	r2, [sp, #24]
 8026420:	3301      	adds	r3, #1
 8026422:	429a      	cmp	r2, r3
 8026424:	9304      	str	r3, [sp, #16]
 8026426:	d1b3      	bne.n	8026390 <cblas_ztrsm+0x1550>
 8026428:	f7ff bbbe 	b.w	8025ba8 <cblas_ztrsm+0xd68>
        for (i = 0; i < n1; i++) {
 802642c:	9b06      	ldr	r3, [sp, #24]
 802642e:	2b00      	cmp	r3, #0
 8026430:	f77f ab92 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8026434:	9a02      	ldr	r2, [sp, #8]
 8026436:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 802643a:	011b      	lsls	r3, r3, #4
 802643c:	9307      	str	r3, [sp, #28]
 802643e:	3308      	adds	r3, #8
 8026440:	9308      	str	r3, [sp, #32]
 8026442:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026444:	011b      	lsls	r3, r3, #4
 8026446:	9303      	str	r3, [sp, #12]
 8026448:	0113      	lsls	r3, r2, #4
 802644a:	9310      	str	r3, [sp, #64]	; 0x40
 802644c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802644e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8026452:	9300      	str	r3, [sp, #0]
 8026454:	2300      	movs	r3, #0
 8026456:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 8026458:	9b02      	ldr	r3, [sp, #8]
 802645a:	2b00      	cmp	r3, #0
 802645c:	dd3e      	ble.n	80264dc <cblas_ztrsm+0x169c>
 802645e:	9b07      	ldr	r3, [sp, #28]
 8026460:	9a08      	ldr	r2, [sp, #32]
 8026462:	4619      	mov	r1, r3
 8026464:	9b00      	ldr	r3, [sp, #0]
 8026466:	eb01 0803 	add.w	r8, r1, r3
 802646a:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 802646e:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8026472:	ec53 2b18 	vmov	r2, r3, d8
 8026476:	4630      	mov	r0, r6
 8026478:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 802647a:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802647e:	f001 fd13 	bl	8027ea8 <__aeabi_dmul>
 8026482:	4652      	mov	r2, sl
 8026484:	ec41 0b19 	vmov	d9, r0, r1
 8026488:	465b      	mov	r3, fp
 802648a:	4620      	mov	r0, r4
 802648c:	4629      	mov	r1, r5
 802648e:	f001 fd0b 	bl	8027ea8 <__aeabi_dmul>
 8026492:	4602      	mov	r2, r0
 8026494:	460b      	mov	r3, r1
 8026496:	ec51 0b19 	vmov	r0, r1, d9
 802649a:	f001 fb4d 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802649e:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80264a2:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80264a6:	4620      	mov	r0, r4
 80264a8:	4629      	mov	r1, r5
 80264aa:	f001 fcfd 	bl	8027ea8 <__aeabi_dmul>
 80264ae:	4652      	mov	r2, sl
 80264b0:	465b      	mov	r3, fp
 80264b2:	4604      	mov	r4, r0
 80264b4:	460d      	mov	r5, r1
 80264b6:	4630      	mov	r0, r6
 80264b8:	4639      	mov	r1, r7
 80264ba:	f001 fcf5 	bl	8027ea8 <__aeabi_dmul>
 80264be:	460b      	mov	r3, r1
 80264c0:	4602      	mov	r2, r0
 80264c2:	4629      	mov	r1, r5
 80264c4:	4620      	mov	r0, r4
 80264c6:	f001 fb39 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 80264ca:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80264cc:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 80264d0:	f108 0810 	add.w	r8, r8, #16
 80264d4:	4543      	cmp	r3, r8
 80264d6:	f109 0910 	add.w	r9, r9, #16
 80264da:	d1c8      	bne.n	802646e <cblas_ztrsm+0x162e>
        for (i = 0; i < n1; i++) {
 80264dc:	9a00      	ldr	r2, [sp, #0]
 80264de:	9903      	ldr	r1, [sp, #12]
 80264e0:	9b04      	ldr	r3, [sp, #16]
 80264e2:	440a      	add	r2, r1
 80264e4:	9200      	str	r2, [sp, #0]
 80264e6:	9a06      	ldr	r2, [sp, #24]
 80264e8:	3301      	adds	r3, #1
 80264ea:	429a      	cmp	r2, r3
 80264ec:	9304      	str	r3, [sp, #16]
 80264ee:	d1b3      	bne.n	8026458 <cblas_ztrsm+0x1618>
 80264f0:	e426      	b.n	8025d40 <cblas_ztrsm+0xf00>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80264f2:	ee1c 0a10 	vmov	r0, s24
 80264f6:	f001 fc6d 	bl	8027dd4 <__aeabi_i2d>
 80264fa:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80264fc:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8026500:	f001 fcd2 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8026504:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8026508:	4606      	mov	r6, r0
 802650a:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 802650c:	4620      	mov	r0, r4
 802650e:	4629      	mov	r1, r5
 8026510:	4632      	mov	r2, r6
 8026512:	463b      	mov	r3, r7
 8026514:	f7fe fc5c 	bl	8024dd0 <xhypot>
 8026518:	4680      	mov	r8, r0
 802651a:	4689      	mov	r9, r1
          const BASE a_real = Aii_real / s;
 802651c:	4620      	mov	r0, r4
 802651e:	4629      	mov	r1, r5
 8026520:	4642      	mov	r2, r8
 8026522:	464b      	mov	r3, r9
 8026524:	f001 fdea 	bl	80280fc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 8026528:	464b      	mov	r3, r9
          const BASE a_real = Aii_real / s;
 802652a:	4604      	mov	r4, r0
 802652c:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 802652e:	4642      	mov	r2, r8
 8026530:	4630      	mov	r0, r6
 8026532:	4639      	mov	r1, r7
 8026534:	f001 fde2 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8026538:	9b02      	ldr	r3, [sp, #8]
 802653a:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 802653c:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 8026540:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8026544:	f77f ab56 	ble.w	8025bf4 <cblas_ztrsm+0xdb4>
 8026548:	9b08      	ldr	r3, [sp, #32]
 802654a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 802654c:	441a      	add	r2, r3
 802654e:	f103 0a08 	add.w	sl, r3, #8
 8026552:	9200      	str	r2, [sp, #0]
 8026554:	469b      	mov	fp, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026556:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802655a:	ec51 0b19 	vmov	r0, r1, d9
 802655e:	4622      	mov	r2, r4
 8026560:	462b      	mov	r3, r5
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026562:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026566:	f001 fc9f 	bl	8027ea8 <__aeabi_dmul>
 802656a:	4632      	mov	r2, r6
 802656c:	ec41 0b1a 	vmov	d10, r0, r1
 8026570:	463b      	mov	r3, r7
 8026572:	ec51 0b18 	vmov	r0, r1, d8
 8026576:	f001 fc97 	bl	8027ea8 <__aeabi_dmul>
 802657a:	4602      	mov	r2, r0
 802657c:	460b      	mov	r3, r1
 802657e:	ec51 0b1a 	vmov	r0, r1, d10
 8026582:	f001 fadb 	bl	8027b3c <__adddf3>
 8026586:	4642      	mov	r2, r8
 8026588:	464b      	mov	r3, r9
 802658a:	f001 fdb7 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802658e:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026590:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026594:	463b      	mov	r3, r7
 8026596:	ec51 0b19 	vmov	r0, r1, d9
 802659a:	f001 fc85 	bl	8027ea8 <__aeabi_dmul>
 802659e:	4622      	mov	r2, r4
 80265a0:	462b      	mov	r3, r5
 80265a2:	4604      	mov	r4, r0
 80265a4:	460d      	mov	r5, r1
 80265a6:	ec51 0b18 	vmov	r0, r1, d8
 80265aa:	f001 fc7d 	bl	8027ea8 <__aeabi_dmul>
 80265ae:	4602      	mov	r2, r0
 80265b0:	460b      	mov	r3, r1
 80265b2:	4620      	mov	r0, r4
 80265b4:	4629      	mov	r1, r5
 80265b6:	f001 fabf 	bl	8027b38 <__aeabi_dsub>
 80265ba:	464b      	mov	r3, r9
 80265bc:	4642      	mov	r2, r8
 80265be:	f001 fd9d 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 80265c2:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80265c4:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j < n2; j++) {
 80265c8:	f10b 0b10 	add.w	fp, fp, #16
 80265cc:	455b      	cmp	r3, fp
 80265ce:	f10a 0a10 	add.w	sl, sl, #16
 80265d2:	d1c0      	bne.n	8026556 <cblas_ztrsm+0x1716>
 80265d4:	f7ff bb0e 	b.w	8025bf4 <cblas_ztrsm+0xdb4>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80265d8:	ee1c 0a10 	vmov	r0, s24
 80265dc:	f001 fbfa 	bl	8027dd4 <__aeabi_i2d>
 80265e0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 80265e2:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80265e6:	f001 fc5f 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 80265ea:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80265ee:	4606      	mov	r6, r0
 80265f0:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 80265f2:	4620      	mov	r0, r4
 80265f4:	4629      	mov	r1, r5
 80265f6:	4632      	mov	r2, r6
 80265f8:	463b      	mov	r3, r7
 80265fa:	f7fe fbe9 	bl	8024dd0 <xhypot>
 80265fe:	4682      	mov	sl, r0
 8026600:	468b      	mov	fp, r1
          const BASE a_real = Aii_real / s;
 8026602:	4620      	mov	r0, r4
 8026604:	4629      	mov	r1, r5
 8026606:	4652      	mov	r2, sl
 8026608:	465b      	mov	r3, fp
 802660a:	f001 fd77 	bl	80280fc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 802660e:	465b      	mov	r3, fp
          const BASE a_real = Aii_real / s;
 8026610:	4604      	mov	r4, r0
 8026612:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 8026614:	4652      	mov	r2, sl
 8026616:	4630      	mov	r0, r6
 8026618:	4639      	mov	r1, r7
 802661a:	f001 fd6f 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 802661e:	9b02      	ldr	r3, [sp, #8]
 8026620:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 8026622:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 8026626:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 802662a:	f77f a986 	ble.w	802593a <cblas_ztrsm+0xafa>
 802662e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8026630:	990c      	ldr	r1, [sp, #48]	; 0x30
 8026632:	4413      	add	r3, r2
 8026634:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 8026638:	9300      	str	r3, [sp, #0]
 802663a:	eb01 1402 	add.w	r4, r1, r2, lsl #4
 802663e:	4613      	mov	r3, r2
 8026640:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8026642:	eb02 1503 	add.w	r5, r2, r3, lsl #4
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026646:	e955 6702 	ldrd	r6, r7, [r5, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 802664a:	ec51 0b19 	vmov	r0, r1, d9
 802664e:	4632      	mov	r2, r6
 8026650:	463b      	mov	r3, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026652:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026656:	f001 fc27 	bl	8027ea8 <__aeabi_dmul>
 802665a:	4642      	mov	r2, r8
 802665c:	ec41 0b1a 	vmov	d10, r0, r1
 8026660:	464b      	mov	r3, r9
 8026662:	ec51 0b18 	vmov	r0, r1, d8
 8026666:	f001 fc1f 	bl	8027ea8 <__aeabi_dmul>
 802666a:	4602      	mov	r2, r0
 802666c:	460b      	mov	r3, r1
 802666e:	ec51 0b1a 	vmov	r0, r1, d10
 8026672:	f001 fa63 	bl	8027b3c <__adddf3>
 8026676:	4652      	mov	r2, sl
 8026678:	465b      	mov	r3, fp
 802667a:	f001 fd3f 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 802667e:	4642      	mov	r2, r8
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026680:	e945 0102 	strd	r0, r1, [r5, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026684:	464b      	mov	r3, r9
 8026686:	ec51 0b19 	vmov	r0, r1, d9
 802668a:	f001 fc0d 	bl	8027ea8 <__aeabi_dmul>
 802668e:	4632      	mov	r2, r6
 8026690:	463b      	mov	r3, r7
 8026692:	4606      	mov	r6, r0
 8026694:	460f      	mov	r7, r1
 8026696:	ec51 0b18 	vmov	r0, r1, d8
 802669a:	f001 fc05 	bl	8027ea8 <__aeabi_dmul>
 802669e:	4602      	mov	r2, r0
 80266a0:	460b      	mov	r3, r1
 80266a2:	4630      	mov	r0, r6
 80266a4:	4639      	mov	r1, r7
 80266a6:	f001 fa47 	bl	8027b38 <__aeabi_dsub>
 80266aa:	465b      	mov	r3, fp
 80266ac:	4652      	mov	r2, sl
 80266ae:	f001 fd25 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 80266b2:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80266b4:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = 0; j < n2; j++) {
 80266b8:	3410      	adds	r4, #16
 80266ba:	42a3      	cmp	r3, r4
 80266bc:	f105 0510 	add.w	r5, r5, #16
 80266c0:	d1c1      	bne.n	8026646 <cblas_ztrsm+0x1806>
 80266c2:	f7ff b93a 	b.w	802593a <cblas_ztrsm+0xafa>
        for (i = 0; i < n1; i++) {
 80266c6:	9b06      	ldr	r3, [sp, #24]
 80266c8:	2b00      	cmp	r3, #0
 80266ca:	f77f aa45 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 80266ce:	9a02      	ldr	r2, [sp, #8]
 80266d0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80266d2:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 80266d6:	011b      	lsls	r3, r3, #4
 80266d8:	9307      	str	r3, [sp, #28]
 80266da:	3308      	adds	r3, #8
 80266dc:	9308      	str	r3, [sp, #32]
 80266de:	0113      	lsls	r3, r2, #4
 80266e0:	9310      	str	r3, [sp, #64]	; 0x40
 80266e2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80266e4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 80266e8:	0109      	lsls	r1, r1, #4
 80266ea:	9300      	str	r3, [sp, #0]
 80266ec:	2300      	movs	r3, #0
 80266ee:	9103      	str	r1, [sp, #12]
 80266f0:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 80266f2:	9b02      	ldr	r3, [sp, #8]
 80266f4:	2b00      	cmp	r3, #0
 80266f6:	dd3d      	ble.n	8026774 <cblas_ztrsm+0x1934>
 80266f8:	9b00      	ldr	r3, [sp, #0]
 80266fa:	9907      	ldr	r1, [sp, #28]
 80266fc:	9a08      	ldr	r2, [sp, #32]
 80266fe:	eb03 0801 	add.w	r8, r3, r1
 8026702:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 8026706:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802670a:	ec53 2b18 	vmov	r2, r3, d8
 802670e:	4630      	mov	r0, r6
 8026710:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026712:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 8026716:	f001 fbc7 	bl	8027ea8 <__aeabi_dmul>
 802671a:	4652      	mov	r2, sl
 802671c:	ec41 0b19 	vmov	d9, r0, r1
 8026720:	465b      	mov	r3, fp
 8026722:	4620      	mov	r0, r4
 8026724:	4629      	mov	r1, r5
 8026726:	f001 fbbf 	bl	8027ea8 <__aeabi_dmul>
 802672a:	4602      	mov	r2, r0
 802672c:	460b      	mov	r3, r1
 802672e:	ec51 0b19 	vmov	r0, r1, d9
 8026732:	f001 fa01 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026736:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 802673a:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 802673e:	4620      	mov	r0, r4
 8026740:	4629      	mov	r1, r5
 8026742:	f001 fbb1 	bl	8027ea8 <__aeabi_dmul>
 8026746:	4652      	mov	r2, sl
 8026748:	465b      	mov	r3, fp
 802674a:	4604      	mov	r4, r0
 802674c:	460d      	mov	r5, r1
 802674e:	4630      	mov	r0, r6
 8026750:	4639      	mov	r1, r7
 8026752:	f001 fba9 	bl	8027ea8 <__aeabi_dmul>
 8026756:	460b      	mov	r3, r1
 8026758:	4602      	mov	r2, r0
 802675a:	4629      	mov	r1, r5
 802675c:	4620      	mov	r0, r4
 802675e:	f001 f9ed 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 8026762:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026764:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 8026768:	f108 0810 	add.w	r8, r8, #16
 802676c:	4598      	cmp	r8, r3
 802676e:	f109 0910 	add.w	r9, r9, #16
 8026772:	d1c8      	bne.n	8026706 <cblas_ztrsm+0x18c6>
        for (i = 0; i < n1; i++) {
 8026774:	9a00      	ldr	r2, [sp, #0]
 8026776:	9903      	ldr	r1, [sp, #12]
 8026778:	9b04      	ldr	r3, [sp, #16]
 802677a:	440a      	add	r2, r1
 802677c:	9200      	str	r2, [sp, #0]
 802677e:	9a06      	ldr	r2, [sp, #24]
 8026780:	3301      	adds	r3, #1
 8026782:	429a      	cmp	r2, r3
 8026784:	9304      	str	r3, [sp, #16]
 8026786:	d1b4      	bne.n	80266f2 <cblas_ztrsm+0x18b2>
 8026788:	e4d1      	b.n	802612e <cblas_ztrsm+0x12ee>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 802678a:	ee1c 0a10 	vmov	r0, s24
 802678e:	f001 fb21 	bl	8027dd4 <__aeabi_i2d>
 8026792:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8026794:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 8026798:	f001 fb86 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 802679c:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 80267a0:	4606      	mov	r6, r0
 80267a2:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 80267a4:	4620      	mov	r0, r4
 80267a6:	4629      	mov	r1, r5
 80267a8:	4632      	mov	r2, r6
 80267aa:	463b      	mov	r3, r7
 80267ac:	f7fe fb10 	bl	8024dd0 <xhypot>
 80267b0:	4682      	mov	sl, r0
 80267b2:	468b      	mov	fp, r1
          const BASE a_real = Aii_real / s;
 80267b4:	4620      	mov	r0, r4
 80267b6:	4629      	mov	r1, r5
 80267b8:	4652      	mov	r2, sl
 80267ba:	465b      	mov	r3, fp
 80267bc:	f001 fc9e 	bl	80280fc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 80267c0:	465b      	mov	r3, fp
          const BASE a_real = Aii_real / s;
 80267c2:	4604      	mov	r4, r0
 80267c4:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 80267c6:	4652      	mov	r2, sl
 80267c8:	4630      	mov	r0, r6
 80267ca:	4639      	mov	r1, r7
 80267cc:	f001 fc96 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 80267d0:	9b02      	ldr	r3, [sp, #8]
 80267d2:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 80267d4:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 80267d8:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 80267dc:	f77f aacf 	ble.w	8025d7e <cblas_ztrsm+0xf3e>
 80267e0:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80267e2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80267e4:	4413      	add	r3, r2
 80267e6:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 80267ea:	9300      	str	r3, [sp, #0]
 80267ec:	eb01 1402 	add.w	r4, r1, r2, lsl #4
 80267f0:	4613      	mov	r3, r2
 80267f2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 80267f4:	eb02 1503 	add.w	r5, r2, r3, lsl #4
            const BASE Bij_real = REAL(B, ldb * i + j);
 80267f8:	e955 6702 	ldrd	r6, r7, [r5, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80267fc:	ec51 0b19 	vmov	r0, r1, d9
 8026800:	4632      	mov	r2, r6
 8026802:	463b      	mov	r3, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 8026804:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026808:	f001 fb4e 	bl	8027ea8 <__aeabi_dmul>
 802680c:	4642      	mov	r2, r8
 802680e:	ec41 0b1a 	vmov	d10, r0, r1
 8026812:	464b      	mov	r3, r9
 8026814:	ec51 0b18 	vmov	r0, r1, d8
 8026818:	f001 fb46 	bl	8027ea8 <__aeabi_dmul>
 802681c:	4602      	mov	r2, r0
 802681e:	460b      	mov	r3, r1
 8026820:	ec51 0b1a 	vmov	r0, r1, d10
 8026824:	f001 f98a 	bl	8027b3c <__adddf3>
 8026828:	4652      	mov	r2, sl
 802682a:	465b      	mov	r3, fp
 802682c:	f001 fc66 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026830:	4642      	mov	r2, r8
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 8026832:	e945 0102 	strd	r0, r1, [r5, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026836:	464b      	mov	r3, r9
 8026838:	ec51 0b19 	vmov	r0, r1, d9
 802683c:	f001 fb34 	bl	8027ea8 <__aeabi_dmul>
 8026840:	4632      	mov	r2, r6
 8026842:	463b      	mov	r3, r7
 8026844:	4606      	mov	r6, r0
 8026846:	460f      	mov	r7, r1
 8026848:	ec51 0b18 	vmov	r0, r1, d8
 802684c:	f001 fb2c 	bl	8027ea8 <__aeabi_dmul>
 8026850:	4602      	mov	r2, r0
 8026852:	460b      	mov	r3, r1
 8026854:	4630      	mov	r0, r6
 8026856:	4639      	mov	r1, r7
 8026858:	f001 f96e 	bl	8027b38 <__aeabi_dsub>
 802685c:	465b      	mov	r3, fp
 802685e:	4652      	mov	r2, sl
 8026860:	f001 fc4c 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8026864:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026866:	e9c4 0102 	strd	r0, r1, [r4, #8]
          for (j = 0; j < n2; j++) {
 802686a:	3410      	adds	r4, #16
 802686c:	42a3      	cmp	r3, r4
 802686e:	f105 0510 	add.w	r5, r5, #16
 8026872:	d1c1      	bne.n	80267f8 <cblas_ztrsm+0x19b8>
 8026874:	f7ff ba83 	b.w	8025d7e <cblas_ztrsm+0xf3e>
        for (i = 0; i < n1; i++) {
 8026878:	9b06      	ldr	r3, [sp, #24]
 802687a:	2b00      	cmp	r3, #0
 802687c:	f77f a96c 	ble.w	8025b58 <cblas_ztrsm+0xd18>
 8026880:	9a02      	ldr	r2, [sp, #8]
 8026882:	ebc2 7302 	rsb	r3, r2, r2, lsl #28
 8026886:	011b      	lsls	r3, r3, #4
 8026888:	9307      	str	r3, [sp, #28]
 802688a:	3308      	adds	r3, #8
 802688c:	9308      	str	r3, [sp, #32]
 802688e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026890:	011b      	lsls	r3, r3, #4
 8026892:	9303      	str	r3, [sp, #12]
 8026894:	0113      	lsls	r3, r2, #4
 8026896:	9310      	str	r3, [sp, #64]	; 0x40
 8026898:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802689a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 802689e:	9300      	str	r3, [sp, #0]
 80268a0:	2300      	movs	r3, #0
 80268a2:	9304      	str	r3, [sp, #16]
          for (j = 0; j < n2; j++) {
 80268a4:	9b02      	ldr	r3, [sp, #8]
 80268a6:	2b00      	cmp	r3, #0
 80268a8:	dd3d      	ble.n	8026926 <cblas_ztrsm+0x1ae6>
 80268aa:	9b00      	ldr	r3, [sp, #0]
 80268ac:	9907      	ldr	r1, [sp, #28]
 80268ae:	9a08      	ldr	r2, [sp, #32]
 80268b0:	eb03 0801 	add.w	r8, r3, r1
 80268b4:	eb02 0903 	add.w	r9, r2, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 80268b8:	e959 6702 	ldrd	r6, r7, [r9, #-8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80268bc:	ec53 2b18 	vmov	r2, r3, d8
 80268c0:	4630      	mov	r0, r6
 80268c2:	4639      	mov	r1, r7
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80268c4:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80268c8:	f001 faee 	bl	8027ea8 <__aeabi_dmul>
 80268cc:	4652      	mov	r2, sl
 80268ce:	ec41 0b19 	vmov	d9, r0, r1
 80268d2:	465b      	mov	r3, fp
 80268d4:	4620      	mov	r0, r4
 80268d6:	4629      	mov	r1, r5
 80268d8:	f001 fae6 	bl	8027ea8 <__aeabi_dmul>
 80268dc:	4602      	mov	r2, r0
 80268de:	460b      	mov	r3, r1
 80268e0:	ec51 0b19 	vmov	r0, r1, d9
 80268e4:	f001 f928 	bl	8027b38 <__aeabi_dsub>
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80268e8:	ec53 2b18 	vmov	r2, r3, d8
            REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
 80268ec:	e949 0102 	strd	r0, r1, [r9, #-8]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 80268f0:	4620      	mov	r0, r4
 80268f2:	4629      	mov	r1, r5
 80268f4:	f001 fad8 	bl	8027ea8 <__aeabi_dmul>
 80268f8:	4652      	mov	r2, sl
 80268fa:	465b      	mov	r3, fp
 80268fc:	4604      	mov	r4, r0
 80268fe:	460d      	mov	r5, r1
 8026900:	4630      	mov	r0, r6
 8026902:	4639      	mov	r1, r7
 8026904:	f001 fad0 	bl	8027ea8 <__aeabi_dmul>
 8026908:	460b      	mov	r3, r1
 802690a:	4602      	mov	r2, r0
 802690c:	4629      	mov	r1, r5
 802690e:	4620      	mov	r0, r4
 8026910:	f001 f914 	bl	8027b3c <__adddf3>
          for (j = 0; j < n2; j++) {
 8026914:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
 8026916:	e9c8 0102 	strd	r0, r1, [r8, #8]
          for (j = 0; j < n2; j++) {
 802691a:	f108 0810 	add.w	r8, r8, #16
 802691e:	4598      	cmp	r8, r3
 8026920:	f109 0910 	add.w	r9, r9, #16
 8026924:	d1c8      	bne.n	80268b8 <cblas_ztrsm+0x1a78>
        for (i = 0; i < n1; i++) {
 8026926:	9a00      	ldr	r2, [sp, #0]
 8026928:	9903      	ldr	r1, [sp, #12]
 802692a:	9b04      	ldr	r3, [sp, #16]
 802692c:	440a      	add	r2, r1
 802692e:	9200      	str	r2, [sp, #0]
 8026930:	9a06      	ldr	r2, [sp, #24]
 8026932:	3301      	adds	r3, #1
 8026934:	429a      	cmp	r2, r3
 8026936:	9304      	str	r3, [sp, #16]
 8026938:	d1b4      	bne.n	80268a4 <cblas_ztrsm+0x1a64>
 802693a:	f7ff bad6 	b.w	8025eea <cblas_ztrsm+0x10aa>
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 802693e:	ee1c 0a10 	vmov	r0, s24
 8026942:	f001 fa47 	bl	8027dd4 <__aeabi_i2d>
 8026946:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8026948:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802694c:	f001 faac 	bl	8027ea8 <__aeabi_dmul>
          const BASE Aii_real = CONST_REAL(A, lda * i + i);
 8026950:	e9d4 4500 	ldrd	r4, r5, [r4]
          const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
 8026954:	4606      	mov	r6, r0
 8026956:	460f      	mov	r7, r1
          const BASE s = xhypot(Aii_real, Aii_imag);
 8026958:	4620      	mov	r0, r4
 802695a:	4629      	mov	r1, r5
 802695c:	4632      	mov	r2, r6
 802695e:	463b      	mov	r3, r7
 8026960:	f7fe fa36 	bl	8024dd0 <xhypot>
 8026964:	4680      	mov	r8, r0
 8026966:	4689      	mov	r9, r1
          const BASE a_real = Aii_real / s;
 8026968:	4620      	mov	r0, r4
 802696a:	4629      	mov	r1, r5
 802696c:	4642      	mov	r2, r8
 802696e:	464b      	mov	r3, r9
 8026970:	f001 fbc4 	bl	80280fc <__aeabi_ddiv>
          const BASE a_imag = Aii_imag / s;
 8026974:	464b      	mov	r3, r9
          const BASE a_real = Aii_real / s;
 8026976:	4604      	mov	r4, r0
 8026978:	460d      	mov	r5, r1
          const BASE a_imag = Aii_imag / s;
 802697a:	4642      	mov	r2, r8
 802697c:	4630      	mov	r0, r6
 802697e:	4639      	mov	r1, r7
 8026980:	f001 fbbc 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8026984:	9b02      	ldr	r3, [sp, #8]
 8026986:	2b00      	cmp	r3, #0
          const BASE a_real = Aii_real / s;
 8026988:	ec45 4b19 	vmov	d9, r4, r5
          const BASE a_imag = Aii_imag / s;
 802698c:	ec41 0b18 	vmov	d8, r0, r1
          for (j = 0; j < n2; j++) {
 8026990:	f77e ab93 	ble.w	80250ba <cblas_ztrsm+0x27a>
 8026994:	9b08      	ldr	r3, [sp, #32]
 8026996:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026998:	189a      	adds	r2, r3, r2
 802699a:	f103 0a08 	add.w	sl, r3, #8
 802699e:	9200      	str	r2, [sp, #0]
 80269a0:	469b      	mov	fp, r3
            const BASE Bij_real = REAL(B, ldb * i + j);
 80269a2:	e95a 4502 	ldrd	r4, r5, [sl, #-8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80269a6:	ec51 0b19 	vmov	r0, r1, d9
 80269aa:	4622      	mov	r2, r4
 80269ac:	462b      	mov	r3, r5
            const BASE Bij_imag = IMAG(B, ldb * i + j);
 80269ae:	e9db 6702 	ldrd	r6, r7, [fp, #8]
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80269b2:	f001 fa79 	bl	8027ea8 <__aeabi_dmul>
 80269b6:	4632      	mov	r2, r6
 80269b8:	ec41 0b1a 	vmov	d10, r0, r1
 80269bc:	463b      	mov	r3, r7
 80269be:	ec51 0b18 	vmov	r0, r1, d8
 80269c2:	f001 fa71 	bl	8027ea8 <__aeabi_dmul>
 80269c6:	4602      	mov	r2, r0
 80269c8:	460b      	mov	r3, r1
 80269ca:	ec51 0b1a 	vmov	r0, r1, d10
 80269ce:	f001 f8b5 	bl	8027b3c <__adddf3>
 80269d2:	4642      	mov	r2, r8
 80269d4:	464b      	mov	r3, r9
 80269d6:	f001 fb91 	bl	80280fc <__aeabi_ddiv>
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80269da:	4632      	mov	r2, r6
            REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
 80269dc:	e94a 0102 	strd	r0, r1, [sl, #-8]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 80269e0:	463b      	mov	r3, r7
 80269e2:	ec51 0b19 	vmov	r0, r1, d9
 80269e6:	f001 fa5f 	bl	8027ea8 <__aeabi_dmul>
 80269ea:	4622      	mov	r2, r4
 80269ec:	462b      	mov	r3, r5
 80269ee:	4604      	mov	r4, r0
 80269f0:	460d      	mov	r5, r1
 80269f2:	ec51 0b18 	vmov	r0, r1, d8
 80269f6:	f001 fa57 	bl	8027ea8 <__aeabi_dmul>
 80269fa:	4602      	mov	r2, r0
 80269fc:	460b      	mov	r3, r1
 80269fe:	4620      	mov	r0, r4
 8026a00:	4629      	mov	r1, r5
 8026a02:	f001 f899 	bl	8027b38 <__aeabi_dsub>
 8026a06:	464b      	mov	r3, r9
 8026a08:	4642      	mov	r2, r8
 8026a0a:	f001 fb77 	bl	80280fc <__aeabi_ddiv>
          for (j = 0; j < n2; j++) {
 8026a0e:	9b00      	ldr	r3, [sp, #0]
            IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
 8026a10:	e9cb 0102 	strd	r0, r1, [fp, #8]
          for (j = 0; j < n2; j++) {
 8026a14:	f10b 0b10 	add.w	fp, fp, #16
 8026a18:	459b      	cmp	fp, r3
 8026a1a:	f10a 0a10 	add.w	sl, sl, #16
 8026a1e:	d1c0      	bne.n	80269a2 <cblas_ztrsm+0x1b62>
 8026a20:	f7fe bb4b 	b.w	80250ba <cblas_ztrsm+0x27a>

08026a24 <xhypot>:
{
 8026a24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  double xabs = fabs(x) ;
 8026a26:	f021 4700 	bic.w	r7, r1, #2147483648	; 0x80000000
  double yabs = fabs(y) ;
 8026a2a:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
  if (xabs < yabs) {
 8026a2e:	4639      	mov	r1, r7
 8026a30:	462b      	mov	r3, r5
  double xabs = fabs(x) ;
 8026a32:	4606      	mov	r6, r0
  double yabs = fabs(y) ;
 8026a34:	4614      	mov	r4, r2
  if (xabs < yabs) {
 8026a36:	f001 fca9 	bl	802838c <__aeabi_dcmplt>
 8026a3a:	b928      	cbnz	r0, 8026a48 <xhypot+0x24>
 8026a3c:	4632      	mov	r2, r6
 8026a3e:	463b      	mov	r3, r7
    min = yabs ;
 8026a40:	4626      	mov	r6, r4
 8026a42:	462f      	mov	r7, r5
    max = xabs ;
 8026a44:	4614      	mov	r4, r2
 8026a46:	461d      	mov	r5, r3
  if (min == 0) 
 8026a48:	2200      	movs	r2, #0
 8026a4a:	2300      	movs	r3, #0
 8026a4c:	4630      	mov	r0, r6
 8026a4e:	4639      	mov	r1, r7
 8026a50:	f001 fc92 	bl	8028378 <__aeabi_dcmpeq>
 8026a54:	b9c8      	cbnz	r0, 8026a8a <xhypot+0x66>
    double u = min / max ;
 8026a56:	4622      	mov	r2, r4
 8026a58:	462b      	mov	r3, r5
 8026a5a:	4630      	mov	r0, r6
 8026a5c:	4639      	mov	r1, r7
 8026a5e:	f001 fb4d 	bl	80280fc <__aeabi_ddiv>
 8026a62:	4602      	mov	r2, r0
 8026a64:	460b      	mov	r3, r1
    return max * sqrt (1 + u * u) ;
 8026a66:	f001 fa1f 	bl	8027ea8 <__aeabi_dmul>
 8026a6a:	4b09      	ldr	r3, [pc, #36]	; (8026a90 <xhypot+0x6c>)
 8026a6c:	2200      	movs	r2, #0
 8026a6e:	f001 f865 	bl	8027b3c <__adddf3>
 8026a72:	ec41 0b10 	vmov	d0, r0, r1
 8026a76:	f009 fa0f 	bl	802fe98 <sqrt>
 8026a7a:	4620      	mov	r0, r4
 8026a7c:	4629      	mov	r1, r5
 8026a7e:	ec53 2b10 	vmov	r2, r3, d0
 8026a82:	f001 fa11 	bl	8027ea8 <__aeabi_dmul>
 8026a86:	4604      	mov	r4, r0
 8026a88:	460d      	mov	r5, r1
}
 8026a8a:	4620      	mov	r0, r4
 8026a8c:	4629      	mov	r1, r5
 8026a8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8026a90:	3ff00000 	.word	0x3ff00000

08026a94 <cblas_ztrsv>:
void
cblas_ztrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
             const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
             const int N, const void *A, const int lda, void *X,
             const int incX)
{
 8026a94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026a98:	ed2d 8b08 	vpush	{d8-d11}
 8026a9c:	b099      	sub	sp, #100	; 0x64
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8026a9e:	2a71      	cmp	r2, #113	; 0x71
 8026aa0:	930b      	str	r3, [sp, #44]	; 0x2c
 8026aa2:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 8026aa4:	9305      	str	r3, [sp, #20]
 8026aa6:	9b2b      	ldr	r3, [sp, #172]	; 0xac
 8026aa8:	9310      	str	r3, [sp, #64]	; 0x40
 8026aaa:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 8026aac:	930a      	str	r3, [sp, #40]	; 0x28
 8026aae:	e9dd 542d 	ldrd	r5, r4, [sp, #180]	; 0xb4
 8026ab2:	4607      	mov	r7, r0
 8026ab4:	460e      	mov	r6, r1
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8026ab6:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8026aba:	f000 81b9 	beq.w	8026e30 <cblas_ztrsv+0x39c>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8026abe:	2b01      	cmp	r3, #1
 8026ac0:	4690      	mov	r8, r2
 8026ac2:	d93f      	bls.n	8026b44 <cblas_ztrsv+0xb0>
 8026ac4:	2002      	movs	r0, #2
 8026ac6:	3a6f      	subs	r2, #111	; 0x6f
 8026ac8:	2a02      	cmp	r2, #2
 8026aca:	f04f 0301 	mov.w	r3, #1
 8026ace:	bf88      	it	hi
 8026ad0:	2003      	movhi	r0, #3
 8026ad2:	930f      	str	r3, [sp, #60]	; 0x3c
 8026ad4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026ad6:	337d      	adds	r3, #125	; 0x7d
 8026ad8:	b2db      	uxtb	r3, r3
 8026ada:	2b01      	cmp	r3, #1
 8026adc:	9b05      	ldr	r3, [sp, #20]
 8026ade:	f240 8190 	bls.w	8026e02 <cblas_ztrsv+0x36e>
 8026ae2:	2b00      	cmp	r3, #0
 8026ae4:	f2c0 8184 	blt.w	8026df0 <cblas_ztrsv+0x35c>
 8026ae8:	2b01      	cmp	r3, #1
 8026aea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026aec:	bfb8      	it	lt
 8026aee:	2301      	movlt	r3, #1
 8026af0:	4293      	cmp	r3, r2
 8026af2:	f340 828b 	ble.w	802700c <cblas_ztrsv+0x578>
 8026af6:	2c00      	cmp	r4, #0
 8026af8:	bf0c      	ite	eq
 8026afa:	2009      	moveq	r0, #9
 8026afc:	2007      	movne	r0, #7
 8026afe:	4ac9      	ldr	r2, [pc, #804]	; (8026e24 <cblas_ztrsv+0x390>)
 8026b00:	49c9      	ldr	r1, [pc, #804]	; (8026e28 <cblas_ztrsv+0x394>)
 8026b02:	f000 ffa1 	bl	8027a48 <cblas_xerbla>
  if (N == 0)
 8026b06:	9b05      	ldr	r3, [sp, #20]
 8026b08:	2b00      	cmp	r3, #0
 8026b0a:	f000 816c 	beq.w	8026de6 <cblas_ztrsv+0x352>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8026b0e:	2f65      	cmp	r7, #101	; 0x65
 8026b10:	f000 8198 	beq.w	8026e44 <cblas_ztrsv+0x3b0>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8026b14:	2f66      	cmp	r7, #102	; 0x66
 8026b16:	d10b      	bne.n	8026b30 <cblas_ztrsv+0x9c>
 8026b18:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8026b1c:	d018      	beq.n	8026b50 <cblas_ztrsv+0xbc>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
 8026b1e:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8026b22:	d105      	bne.n	8026b30 <cblas_ztrsv+0x9c>
 8026b24:	2e7a      	cmp	r6, #122	; 0x7a
 8026b26:	f000 833a 	beq.w	802719e <cblas_ztrsv+0x70a>
             || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
 8026b2a:	2e79      	cmp	r6, #121	; 0x79
 8026b2c:	f000 8198 	beq.w	8026e60 <cblas_ztrsv+0x3cc>
    BLAS_ERROR("unrecognized operation");
 8026b30:	4abe      	ldr	r2, [pc, #760]	; (8026e2c <cblas_ztrsv+0x398>)
 8026b32:	49bd      	ldr	r1, [pc, #756]	; (8026e28 <cblas_ztrsv+0x394>)
 8026b34:	2000      	movs	r0, #0
#define BASE double
#include "source_trsv_c.h"
#undef BASE
}
 8026b36:	b019      	add	sp, #100	; 0x64
 8026b38:	ecbd 8b08 	vpop	{d8-d11}
 8026b3c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026b40:	f000 bf82 	b.w	8027a48 <cblas_xerbla>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8026b44:	3865      	subs	r0, #101	; 0x65
 8026b46:	2801      	cmp	r0, #1
 8026b48:	bf94      	ite	ls
 8026b4a:	2000      	movls	r0, #0
 8026b4c:	2001      	movhi	r0, #1
 8026b4e:	e7ba      	b.n	8026ac6 <cblas_ztrsv+0x32>
      || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
 8026b50:	2e7a      	cmp	r6, #122	; 0x7a
 8026b52:	f040 8315 	bne.w	8027180 <cblas_ztrsv+0x6ec>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8026b56:	9b05      	ldr	r3, [sp, #20]
 8026b58:	2c00      	cmp	r4, #0
 8026b5a:	f103 38ff 	add.w	r8, r3, #4294967295
    if (nonunit) {
 8026b5e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    ix = OFFSET(N, incX) + incX * (N - 1);
 8026b60:	bfd6      	itet	le
 8026b62:	f1c4 0900 	rsble	r9, r4, #0
 8026b66:	f04f 0900 	movgt.w	r9, #0
 8026b6a:	fb08 f909 	mulle.w	r9, r8, r9
    if (nonunit) {
 8026b6e:	2b83      	cmp	r3, #131	; 0x83
    ix = OFFSET(N, incX) + incX * (N - 1);
 8026b70:	fb08 9904 	mla	r9, r8, r4, r9
    if (nonunit) {
 8026b74:	d174      	bne.n	8026c60 <cblas_ztrsv+0x1cc>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8026b76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8026b78:	980f      	ldr	r0, [sp, #60]	; 0x3c
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8026b7a:	fb08 8603 	mla	r6, r8, r3, r8
 8026b7e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8026b80:	eb03 1606 	add.w	r6, r3, r6, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8026b84:	f001 f926 	bl	8027dd4 <__aeabi_i2d>
 8026b88:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8026b8c:	f001 f98c 	bl	8027ea8 <__aeabi_dmul>
      const BASE x_real = REAL(X, ix);
 8026b90:	eb05 1709 	add.w	r7, r5, r9, lsl #4
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8026b94:	e9d6 ab00 	ldrd	sl, fp, [r6]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 8026b98:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE x_real = REAL(X, ix);
 8026b9c:	9700      	str	r7, [sp, #0]
 8026b9e:	9f00      	ldr	r7, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8026ba0:	eb05 1609 	add.w	r6, r5, r9, lsl #4
      const BASE s = xhypot(a_real, a_imag);
 8026ba4:	ec53 2b1a 	vmov	r2, r3, d10
      const BASE x_imag = IMAG(X, ix);
 8026ba8:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 8026baa:	4650      	mov	r0, sl
 8026bac:	4659      	mov	r1, fp
      const BASE x_real = REAL(X, ix);
 8026bae:	ed97 9b00 	vldr	d9, [r7]
      const BASE x_imag = IMAG(X, ix);
 8026bb2:	ed96 8b00 	vldr	d8, [r6]
 8026bb6:	9602      	str	r6, [sp, #8]
      const BASE s = xhypot(a_real, a_imag);
 8026bb8:	f7ff ff34 	bl	8026a24 <xhypot>
 8026bbc:	ec41 0b1b 	vmov	d11, r0, r1
      const BASE b_real = a_real / s;
 8026bc0:	4650      	mov	r0, sl
 8026bc2:	ec53 2b1b 	vmov	r2, r3, d11
 8026bc6:	4659      	mov	r1, fp
 8026bc8:	f001 fa98 	bl	80280fc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 8026bcc:	ec53 2b1b 	vmov	r2, r3, d11
      const BASE b_real = a_real / s;
 8026bd0:	4682      	mov	sl, r0
 8026bd2:	468b      	mov	fp, r1
      const BASE b_imag = a_imag / s;
 8026bd4:	ec51 0b1a 	vmov	r0, r1, d10
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8026bd8:	eeb0 aa49 	vmov.f32	s20, s18
 8026bdc:	eef0 aa69 	vmov.f32	s21, s19
      const BASE b_imag = a_imag / s;
 8026be0:	f001 fa8c 	bl	80280fc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 8026be4:	4656      	mov	r6, sl
 8026be6:	465f      	mov	r7, fp
      const BASE b_imag = a_imag / s;
 8026be8:	4682      	mov	sl, r0
 8026bea:	468b      	mov	fp, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8026bec:	4632      	mov	r2, r6
 8026bee:	463b      	mov	r3, r7
 8026bf0:	ec51 0b19 	vmov	r0, r1, d9
 8026bf4:	f001 f958 	bl	8027ea8 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 8026bf8:	ec4b ab19 	vmov	d9, sl, fp
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8026bfc:	4682      	mov	sl, r0
 8026bfe:	ec53 2b19 	vmov	r2, r3, d9
 8026c02:	468b      	mov	fp, r1
 8026c04:	ec51 0b18 	vmov	r0, r1, d8
 8026c08:	f001 f94e 	bl	8027ea8 <__aeabi_dmul>
 8026c0c:	4602      	mov	r2, r0
 8026c0e:	460b      	mov	r3, r1
 8026c10:	4650      	mov	r0, sl
 8026c12:	4659      	mov	r1, fp
 8026c14:	f000 ff92 	bl	8027b3c <__adddf3>
 8026c18:	ec53 2b1b 	vmov	r2, r3, d11
 8026c1c:	f001 fa6e 	bl	80280fc <__aeabi_ddiv>
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8026c20:	463b      	mov	r3, r7
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8026c22:	9f00      	ldr	r7, [sp, #0]
 8026c24:	4682      	mov	sl, r0
 8026c26:	468b      	mov	fp, r1
 8026c28:	e9c7 ab00 	strd	sl, fp, [r7]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 8026c2c:	4632      	mov	r2, r6
 8026c2e:	ec51 0b18 	vmov	r0, r1, d8
 8026c32:	f001 f939 	bl	8027ea8 <__aeabi_dmul>
 8026c36:	ec53 2b19 	vmov	r2, r3, d9
 8026c3a:	4682      	mov	sl, r0
 8026c3c:	468b      	mov	fp, r1
 8026c3e:	ec51 0b1a 	vmov	r0, r1, d10
 8026c42:	f001 f931 	bl	8027ea8 <__aeabi_dmul>
 8026c46:	4602      	mov	r2, r0
 8026c48:	460b      	mov	r3, r1
 8026c4a:	4650      	mov	r0, sl
 8026c4c:	4659      	mov	r1, fp
 8026c4e:	f000 ff73 	bl	8027b38 <__aeabi_dsub>
 8026c52:	ec53 2b1b 	vmov	r2, r3, d11
 8026c56:	f001 fa51 	bl	80280fc <__aeabi_ddiv>
 8026c5a:	9e02      	ldr	r6, [sp, #8]
 8026c5c:	e9c6 0100 	strd	r0, r1, [r6]
    for (i = N - 1; i > 0 && i--;) {
 8026c60:	f1b8 0f00 	cmp.w	r8, #0
    ix -= incX;
 8026c64:	eba9 0c04 	sub.w	ip, r9, r4
    for (i = N - 1; i > 0 && i--;) {
 8026c68:	f340 80bd 	ble.w	8026de6 <cblas_ztrsv+0x352>
 8026c6c:	990a      	ldr	r1, [sp, #40]	; 0x28
 8026c6e:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
 8026c72:	f108 33ff 	add.w	r3, r8, #4294967295
 8026c76:	fb01 f703 	mul.w	r7, r1, r3
 8026c7a:	4640      	mov	r0, r8
 8026c7c:	fb01 3303 	mla	r3, r1, r3, r3
 8026c80:	183a      	adds	r2, r7, r0
 8026c82:	011b      	lsls	r3, r3, #4
 8026c84:	9805      	ldr	r0, [sp, #20]
 8026c86:	9313      	str	r3, [sp, #76]	; 0x4c
 8026c88:	eb05 1c0c 	add.w	ip, r5, ip, lsl #4
 8026c8c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8026c8e:	4407      	add	r7, r0
 8026c90:	43cd      	mvns	r5, r1
 8026c92:	ebc1 7001 	rsb	r0, r1, r1, lsl #28
 8026c96:	f10c 0108 	add.w	r1, ip, #8
 8026c9a:	ebc2 7602 	rsb	r6, r2, r2, lsl #28
 8026c9e:	910a      	str	r1, [sp, #40]	; 0x28
 8026ca0:	eb03 1107 	add.w	r1, r3, r7, lsl #4
 8026ca4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8026ca8:	930c      	str	r3, [sp, #48]	; 0x30
 8026caa:	0133      	lsls	r3, r6, #4
 8026cac:	9314      	str	r3, [sp, #80]	; 0x50
 8026cae:	012b      	lsls	r3, r5, #4
 8026cb0:	ebc4 7e04 	rsb	lr, r4, r4, lsl #28
 8026cb4:	930e      	str	r3, [sp, #56]	; 0x38
 8026cb6:	0103      	lsls	r3, r0, #4
 8026cb8:	0124      	lsls	r4, r4, #4
 8026cba:	9310      	str	r3, [sp, #64]	; 0x40
 8026cbc:	ea4f 130e 	mov.w	r3, lr, lsl #4
 8026cc0:	9311      	str	r3, [sp, #68]	; 0x44
 8026cc2:	f1a4 0308 	sub.w	r3, r4, #8
 8026cc6:	9408      	str	r4, [sp, #32]
 8026cc8:	9106      	str	r1, [sp, #24]
 8026cca:	9312      	str	r3, [sp, #72]	; 0x48
      BASE tmp_real = REAL(X, ix);
 8026ccc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      for (j = i + 1; j < N; j++) {
 8026cce:	9a0d      	ldr	r2, [sp, #52]	; 0x34
      BASE tmp_real = REAL(X, ix);
 8026cd0:	ed13 7b02 	vldr	d7, [r3, #-8]
 8026cd4:	ed8d 7b00 	vstr	d7, [sp]
      BASE tmp_imag = IMAG(X, ix);
 8026cd8:	ed93 7b00 	vldr	d7, [r3]
      for (j = i + 1; j < N; j++) {
 8026cdc:	9b05      	ldr	r3, [sp, #20]
 8026cde:	4293      	cmp	r3, r2
      BASE tmp_imag = IMAG(X, ix);
 8026ce0:	ed8d 7b02 	vstr	d7, [sp, #8]
      for (j = i + 1; j < N; j++) {
 8026ce4:	dd61      	ble.n	8026daa <cblas_ztrsv+0x316>
 8026ce6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8026ce8:	f001 f874 	bl	8027dd4 <__aeabi_i2d>
 8026cec:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8026cee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026cf0:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8026cf2:	ec41 0b1a 	vmov	d10, r0, r1
 8026cf6:	189d      	adds	r5, r3, r2
 8026cf8:	4626      	mov	r6, r4
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8026cfa:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8026cfe:	ec51 0b1a 	vmov	r0, r1, d10
 8026d02:	f001 f8d1 	bl	8027ea8 <__aeabi_dmul>
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8026d06:	ed96 7b00 	vldr	d7, [r6]
        const BASE x_real = REAL(X, jx);
 8026d0a:	ed95 6b00 	vldr	d6, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 8026d0e:	eeb0 9a47 	vmov.f32	s18, s14
 8026d12:	eef0 9a67 	vmov.f32	s19, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026d16:	ec53 2b16 	vmov	r2, r3, d6
        const BASE x_real = REAL(X, jx);
 8026d1a:	eeb0 8a46 	vmov.f32	s16, s12
 8026d1e:	eef0 8a66 	vmov.f32	s17, s13
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 8026d22:	4682      	mov	sl, r0
 8026d24:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026d26:	ec51 0b17 	vmov	r0, r1, d7
 8026d2a:	f001 f8bd 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8026d2e:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026d32:	4604      	mov	r4, r0
        const BASE x_real = REAL(X, jx);
 8026d34:	462f      	mov	r7, r5
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026d36:	4642      	mov	r2, r8
 8026d38:	460d      	mov	r5, r1
 8026d3a:	464b      	mov	r3, r9
 8026d3c:	4650      	mov	r0, sl
 8026d3e:	4659      	mov	r1, fp
 8026d40:	f001 f8b2 	bl	8027ea8 <__aeabi_dmul>
 8026d44:	4602      	mov	r2, r0
 8026d46:	460b      	mov	r3, r1
 8026d48:	4620      	mov	r0, r4
 8026d4a:	4629      	mov	r1, r5
 8026d4c:	f000 fef4 	bl	8027b38 <__aeabi_dsub>
 8026d50:	4602      	mov	r2, r0
 8026d52:	460b      	mov	r3, r1
 8026d54:	e9dd 0100 	ldrd	r0, r1, [sp]
 8026d58:	f000 feee 	bl	8027b38 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026d5c:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026d5e:	4604      	mov	r4, r0
 8026d60:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026d62:	464b      	mov	r3, r9
 8026d64:	ec51 0b19 	vmov	r0, r1, d9
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026d68:	e9cd 4500 	strd	r4, r5, [sp]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026d6c:	f001 f89c 	bl	8027ea8 <__aeabi_dmul>
 8026d70:	ec53 2b18 	vmov	r2, r3, d8
 8026d74:	460d      	mov	r5, r1
 8026d76:	4604      	mov	r4, r0
 8026d78:	4659      	mov	r1, fp
 8026d7a:	4650      	mov	r0, sl
 8026d7c:	f001 f894 	bl	8027ea8 <__aeabi_dmul>
 8026d80:	4602      	mov	r2, r0
 8026d82:	460b      	mov	r3, r1
 8026d84:	4620      	mov	r0, r4
 8026d86:	4629      	mov	r1, r5
 8026d88:	f000 fed8 	bl	8027b3c <__adddf3>
 8026d8c:	460b      	mov	r3, r1
 8026d8e:	4602      	mov	r2, r0
 8026d90:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8026d94:	f000 fed0 	bl	8027b38 <__aeabi_dsub>
 8026d98:	9b08      	ldr	r3, [sp, #32]
 8026d9a:	18fb      	adds	r3, r7, r3
 8026d9c:	461d      	mov	r5, r3
      for (j = i + 1; j < N; j++) {
 8026d9e:	9b06      	ldr	r3, [sp, #24]
 8026da0:	3610      	adds	r6, #16
 8026da2:	42b3      	cmp	r3, r6
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026da4:	e9cd 0102 	strd	r0, r1, [sp, #8]
      for (j = i + 1; j < N; j++) {
 8026da8:	d1a7      	bne.n	8026cfa <cblas_ztrsv+0x266>
      if (nonunit) {
 8026daa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026dac:	2b83      	cmp	r3, #131	; 0x83
 8026dae:	f000 82ab 	beq.w	8027308 <cblas_ztrsv+0x874>
        REAL(X, ix) = tmp_real;
 8026db2:	ed9d 7b00 	vldr	d7, [sp]
 8026db6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026db8:	ed03 7b02 	vstr	d7, [r3, #-8]
        IMAG(X, ix) = tmp_imag;
 8026dbc:	ed9d 7b02 	vldr	d7, [sp, #8]
 8026dc0:	ed83 7b00 	vstr	d7, [r3]
    for (i = N - 1; i > 0 && i--;) {
 8026dc4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026dc6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026dc8:	4413      	add	r3, r2
 8026dca:	930c      	str	r3, [sp, #48]	; 0x30
 8026dcc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026dce:	9b06      	ldr	r3, [sp, #24]
 8026dd0:	4413      	add	r3, r2
 8026dd2:	9306      	str	r3, [sp, #24]
 8026dd4:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8026dd6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026dd8:	4413      	add	r3, r2
 8026dda:	930a      	str	r3, [sp, #40]	; 0x28
 8026ddc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8026dde:	3b01      	subs	r3, #1
 8026de0:	930d      	str	r3, [sp, #52]	; 0x34
 8026de2:	f47f af73 	bne.w	8026ccc <cblas_ztrsv+0x238>
 8026de6:	b019      	add	sp, #100	; 0x64
 8026de8:	ecbd 8b08 	vpop	{d8-d11}
 8026dec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8026df0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8026df2:	2b00      	cmp	r3, #0
 8026df4:	f77f ae7f 	ble.w	8026af6 <cblas_ztrsv+0x62>
 8026df8:	2c00      	cmp	r4, #0
 8026dfa:	bf0c      	ite	eq
 8026dfc:	2009      	moveq	r0, #9
 8026dfe:	2005      	movne	r0, #5
 8026e00:	e67d      	b.n	8026afe <cblas_ztrsv+0x6a>
 8026e02:	2b00      	cmp	r3, #0
 8026e04:	dbf4      	blt.n	8026df0 <cblas_ztrsv+0x35c>
 8026e06:	9b05      	ldr	r3, [sp, #20]
 8026e08:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026e0a:	2b01      	cmp	r3, #1
 8026e0c:	bfb8      	it	lt
 8026e0e:	2301      	movlt	r3, #1
 8026e10:	4293      	cmp	r3, r2
 8026e12:	f73f ae70 	bgt.w	8026af6 <cblas_ztrsv+0x62>
 8026e16:	2c00      	cmp	r4, #0
 8026e18:	f000 83f4 	beq.w	8027604 <cblas_ztrsv+0xb70>
 8026e1c:	2800      	cmp	r0, #0
 8026e1e:	f43f ae72 	beq.w	8026b06 <cblas_ztrsv+0x72>
 8026e22:	e66c      	b.n	8026afe <cblas_ztrsv+0x6a>
 8026e24:	08030378 	.word	0x08030378
 8026e28:	080307b4 	.word	0x080307b4
 8026e2c:	080305a8 	.word	0x080305a8
 8026e30:	2b01      	cmp	r3, #1
 8026e32:	f240 81a9 	bls.w	8027188 <cblas_ztrsv+0x6f4>
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8026e36:	f04f 33ff 	mov.w	r3, #4294967295
 8026e3a:	930f      	str	r3, [sp, #60]	; 0x3c
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8026e3c:	f04f 0870 	mov.w	r8, #112	; 0x70
 8026e40:	2002      	movs	r0, #2
 8026e42:	e647      	b.n	8026ad4 <cblas_ztrsv+0x40>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8026e44:	f1b8 0f6f 	cmp.w	r8, #111	; 0x6f
 8026e48:	f000 80e5 	beq.w	8027016 <cblas_ztrsv+0x582>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
 8026e4c:	f1b8 0f70 	cmp.w	r8, #112	; 0x70
 8026e50:	f47f ae6e 	bne.w	8026b30 <cblas_ztrsv+0x9c>
 8026e54:	2e79      	cmp	r6, #121	; 0x79
 8026e56:	f000 81a2 	beq.w	802719e <cblas_ztrsv+0x70a>
  } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
 8026e5a:	2e7a      	cmp	r6, #122	; 0x7a
 8026e5c:	f47f ae68 	bne.w	8026b30 <cblas_ztrsv+0x9c>
    ix = OFFSET(N, incX) + incX * (N - 1);
 8026e60:	9b05      	ldr	r3, [sp, #20]
 8026e62:	2c00      	cmp	r4, #0
 8026e64:	f103 33ff 	add.w	r3, r3, #4294967295
 8026e68:	bfd8      	it	le
 8026e6a:	f1c4 0a00 	rsble	sl, r4, #0
 8026e6e:	9312      	str	r3, [sp, #72]	; 0x48
 8026e70:	bfd8      	it	le
 8026e72:	fb03 fa0a 	mulle.w	sl, r3, sl
 8026e76:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8026e78:	bfc8      	it	gt
 8026e7a:	f04f 0a00 	movgt.w	sl, #0
 8026e7e:	fb03 aa04 	mla	sl, r3, r4, sl
    if (nonunit) {
 8026e82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026e84:	2b83      	cmp	r3, #131	; 0x83
 8026e86:	f000 83d0 	beq.w	802762a <cblas_ztrsv+0xb96>
    for (i = N - 1; i > 0 && i--;) {
 8026e8a:	9812      	ldr	r0, [sp, #72]	; 0x48
 8026e8c:	2800      	cmp	r0, #0
    ix -= incX;
 8026e8e:	ebaa 0a04 	sub.w	sl, sl, r4
    for (i = N - 1; i > 0 && i--;) {
 8026e92:	dda8      	ble.n	8026de6 <cblas_ztrsv+0x352>
 8026e94:	990a      	ldr	r1, [sp, #40]	; 0x28
 8026e96:	4602      	mov	r2, r0
 8026e98:	1c4b      	adds	r3, r1, #1
 8026e9a:	fb03 f202 	mul.w	r2, r3, r2
 8026e9e:	ebc2 7202 	rsb	r2, r2, r2, lsl #28
 8026ea2:	0112      	lsls	r2, r2, #4
 8026ea4:	9217      	str	r2, [sp, #92]	; 0x5c
 8026ea6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8026ea8:	011b      	lsls	r3, r3, #4
 8026eaa:	eb05 1a0a 	add.w	sl, r5, sl, lsl #4
 8026eae:	4605      	mov	r5, r0
 8026eb0:	1e46      	subs	r6, r0, #1
 8026eb2:	fb05 2203 	mla	r2, r5, r3, r2
 8026eb6:	ebc4 7004 	rsb	r0, r4, r4, lsl #28
 8026eba:	9210      	str	r2, [sp, #64]	; 0x40
 8026ebc:	f1a3 0210 	sub.w	r2, r3, #16
 8026ec0:	fb03 f306 	mul.w	r3, r3, r6
 8026ec4:	0124      	lsls	r4, r4, #4
 8026ec6:	43c9      	mvns	r1, r1
 8026ec8:	9316      	str	r3, [sp, #88]	; 0x58
 8026eca:	0103      	lsls	r3, r0, #4
 8026ecc:	f10a 0708 	add.w	r7, sl, #8
 8026ed0:	0109      	lsls	r1, r1, #4
 8026ed2:	9314      	str	r3, [sp, #80]	; 0x50
 8026ed4:	f1a4 0308 	sub.w	r3, r4, #8
 8026ed8:	9611      	str	r6, [sp, #68]	; 0x44
 8026eda:	940c      	str	r4, [sp, #48]	; 0x30
 8026edc:	970e      	str	r7, [sp, #56]	; 0x38
 8026ede:	9113      	str	r1, [sp, #76]	; 0x4c
 8026ee0:	920d      	str	r2, [sp, #52]	; 0x34
 8026ee2:	9315      	str	r3, [sp, #84]	; 0x54
      BASE tmp_real = REAL(X, ix);
 8026ee4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026ee6:	9b12      	ldr	r3, [sp, #72]	; 0x48
    for (i = N - 1; i > 0 && i--;) {
 8026ee8:	9911      	ldr	r1, [sp, #68]	; 0x44
 8026eea:	930a      	str	r3, [sp, #40]	; 0x28
      BASE tmp_real = REAL(X, ix);
 8026eec:	ed12 7b02 	vldr	d7, [r2, #-8]
 8026ef0:	ed8d 7b06 	vstr	d7, [sp, #24]
      BASE tmp_imag = IMAG(X, ix);
 8026ef4:	ed92 7b00 	vldr	d7, [r2]
      for (j = i + 1; j < N; j++) {
 8026ef8:	9a05      	ldr	r2, [sp, #20]
    for (i = N - 1; i > 0 && i--;) {
 8026efa:	9112      	str	r1, [sp, #72]	; 0x48
      for (j = i + 1; j < N; j++) {
 8026efc:	429a      	cmp	r2, r3
      BASE tmp_imag = IMAG(X, ix);
 8026efe:	ed8d 7b08 	vstr	d7, [sp, #32]
      for (j = i + 1; j < N; j++) {
 8026f02:	dd67      	ble.n	8026fd4 <cblas_ztrsv+0x540>
 8026f04:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8026f06:	f000 ff65 	bl	8027dd4 <__aeabi_i2d>
 8026f0a:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8026f0c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8026f0e:	4413      	add	r3, r2
 8026f10:	9300      	str	r3, [sp, #0]
 8026f12:	ec41 0b19 	vmov	d9, r0, r1
 8026f16:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8026f18:	9302      	str	r3, [sp, #8]
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8026f1a:	9c02      	ldr	r4, [sp, #8]
 8026f1c:	ec51 0b19 	vmov	r0, r1, d9
 8026f20:	e954 2302 	ldrd	r2, r3, [r4, #-8]
 8026f24:	f000 ffc0 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 8026f28:	9d00      	ldr	r5, [sp, #0]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8026f2a:	9402      	str	r4, [sp, #8]
        const BASE x_real = REAL(X, jx);
 8026f2c:	ed95 7b00 	vldr	d7, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8026f30:	e954 6704 	ldrd	r6, r7, [r4, #-16]
        const BASE x_real = REAL(X, jx);
 8026f34:	eeb0 8a47 	vmov.f32	s16, s14
 8026f38:	eef0 8a67 	vmov.f32	s17, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026f3c:	ec53 2b17 	vmov	r2, r3, d7
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8026f40:	4682      	mov	sl, r0
 8026f42:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026f44:	4630      	mov	r0, r6
 8026f46:	4639      	mov	r1, r7
 8026f48:	f000 ffae 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8026f4c:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026f50:	4604      	mov	r4, r0
 8026f52:	460d      	mov	r5, r1
 8026f54:	4642      	mov	r2, r8
 8026f56:	464b      	mov	r3, r9
 8026f58:	4650      	mov	r0, sl
 8026f5a:	4659      	mov	r1, fp
 8026f5c:	f000 ffa4 	bl	8027ea8 <__aeabi_dmul>
 8026f60:	4602      	mov	r2, r0
 8026f62:	460b      	mov	r3, r1
 8026f64:	4620      	mov	r0, r4
 8026f66:	4629      	mov	r1, r5
 8026f68:	f000 fde6 	bl	8027b38 <__aeabi_dsub>
 8026f6c:	4602      	mov	r2, r0
 8026f6e:	460b      	mov	r3, r1
 8026f70:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8026f74:	f000 fde0 	bl	8027b38 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026f78:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026f7a:	4604      	mov	r4, r0
 8026f7c:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026f7e:	464b      	mov	r3, r9
 8026f80:	4630      	mov	r0, r6
 8026f82:	4639      	mov	r1, r7
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8026f84:	e9cd 4506 	strd	r4, r5, [sp, #24]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026f88:	f000 ff8e 	bl	8027ea8 <__aeabi_dmul>
 8026f8c:	ec53 2b18 	vmov	r2, r3, d8
 8026f90:	4604      	mov	r4, r0
 8026f92:	460d      	mov	r5, r1
 8026f94:	4650      	mov	r0, sl
 8026f96:	4659      	mov	r1, fp
 8026f98:	f000 ff86 	bl	8027ea8 <__aeabi_dmul>
 8026f9c:	4602      	mov	r2, r0
 8026f9e:	460b      	mov	r3, r1
 8026fa0:	4620      	mov	r0, r4
 8026fa2:	4629      	mov	r1, r5
 8026fa4:	f000 fdca 	bl	8027b3c <__adddf3>
 8026fa8:	4602      	mov	r2, r0
 8026faa:	460b      	mov	r3, r1
 8026fac:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 8026fb0:	f000 fdc2 	bl	8027b38 <__aeabi_dsub>
 8026fb4:	9b02      	ldr	r3, [sp, #8]
 8026fb6:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8026fb8:	9d00      	ldr	r5, [sp, #0]
      for (j = i + 1; j < N; j++) {
 8026fba:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8026fbc:	4423      	add	r3, r4
 8026fbe:	9302      	str	r3, [sp, #8]
 8026fc0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8026fc2:	18eb      	adds	r3, r5, r3
 8026fc4:	9300      	str	r3, [sp, #0]
 8026fc6:	9b05      	ldr	r3, [sp, #20]
 8026fc8:	3201      	adds	r2, #1
 8026fca:	4293      	cmp	r3, r2
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8026fcc:	e9cd 0108 	strd	r0, r1, [sp, #32]
      for (j = i + 1; j < N; j++) {
 8026fd0:	920a      	str	r2, [sp, #40]	; 0x28
 8026fd2:	d1a2      	bne.n	8026f1a <cblas_ztrsv+0x486>
      if (nonunit) {
 8026fd4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8026fd6:	2b83      	cmp	r3, #131	; 0x83
 8026fd8:	f000 81f8 	beq.w	80273cc <cblas_ztrsv+0x938>
        REAL(X, ix) = tmp_real;
 8026fdc:	ed9d 7b06 	vldr	d7, [sp, #24]
 8026fe0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026fe2:	ed03 7b02 	vstr	d7, [r3, #-8]
        IMAG(X, ix) = tmp_imag;
 8026fe6:	ed9d 7b08 	vldr	d7, [sp, #32]
 8026fea:	ed83 7b00 	vstr	d7, [r3]
    for (i = N - 1; i > 0 && i--;) {
 8026fee:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8026ff0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8026ff2:	4413      	add	r3, r2
 8026ff4:	9310      	str	r3, [sp, #64]	; 0x40
 8026ff6:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8026ff8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8026ffa:	4413      	add	r3, r2
 8026ffc:	930e      	str	r3, [sp, #56]	; 0x38
 8026ffe:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8027000:	2b00      	cmp	r3, #0
 8027002:	f43f aef0 	beq.w	8026de6 <cblas_ztrsv+0x352>
 8027006:	3b01      	subs	r3, #1
 8027008:	9311      	str	r3, [sp, #68]	; 0x44
 802700a:	e76b      	b.n	8026ee4 <cblas_ztrsv+0x450>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 802700c:	2c00      	cmp	r4, #0
 802700e:	bf0c      	ite	eq
 8027010:	2009      	moveq	r0, #9
 8027012:	2004      	movne	r0, #4
 8027014:	e573      	b.n	8026afe <cblas_ztrsv+0x6a>
  if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
 8027016:	2e79      	cmp	r6, #121	; 0x79
 8027018:	f43f ad9d 	beq.w	8026b56 <cblas_ztrsv+0xc2>
  } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
 802701c:	2e7a      	cmp	r6, #122	; 0x7a
 802701e:	f47f ad87 	bne.w	8026b30 <cblas_ztrsv+0x9c>
    ix = OFFSET(N, incX);
 8027022:	2c00      	cmp	r4, #0
 8027024:	f340 82f1 	ble.w	802760a <cblas_ztrsv+0xb76>
 8027028:	46a3      	mov	fp, r4
 802702a:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 802702e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027030:	2b83      	cmp	r3, #131	; 0x83
 8027032:	f000 836b 	beq.w	802770c <cblas_ztrsv+0xc78>
    for (i = 1; i < N; i++) {
 8027036:	9b05      	ldr	r3, [sp, #20]
 8027038:	2b01      	cmp	r3, #1
 802703a:	f77f aed4 	ble.w	8026de6 <cblas_ztrsv+0x352>
 802703e:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8027040:	f000 fec8 	bl	8027dd4 <__aeabi_i2d>
 8027044:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8027046:	920d      	str	r2, [sp, #52]	; 0x34
 8027048:	ec41 0b1a 	vmov	d10, r0, r1
 802704c:	0121      	lsls	r1, r4, #4
 802704e:	9108      	str	r1, [sp, #32]
 8027050:	eb05 110b 	add.w	r1, r5, fp, lsl #4
 8027054:	1c53      	adds	r3, r2, #1
 8027056:	910c      	str	r1, [sp, #48]	; 0x30
 8027058:	eb05 110a 	add.w	r1, r5, sl, lsl #4
 802705c:	9111      	str	r1, [sp, #68]	; 0x44
 802705e:	0119      	lsls	r1, r3, #4
 8027060:	910f      	str	r1, [sp, #60]	; 0x3c
 8027062:	9910      	ldr	r1, [sp, #64]	; 0x40
 8027064:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 8027068:	9306      	str	r3, [sp, #24]
 802706a:	2301      	movs	r3, #1
 802706c:	930e      	str	r3, [sp, #56]	; 0x38
      BASE tmp_real = REAL(X, ix);
 802706e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027070:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8027072:	ed93 7b00 	vldr	d7, [r3]
 8027076:	ed8d 7b00 	vstr	d7, [sp]
      BASE tmp_imag = IMAG(X, ix);
 802707a:	ed93 7b02 	vldr	d7, [r3, #8]
 802707e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027080:	ed8d 7b02 	vstr	d7, [sp, #8]
      for (j = 0; j < i; j++) {
 8027084:	eb03 1402 	add.w	r4, r3, r2, lsl #4
      BASE tmp_imag = IMAG(X, ix);
 8027088:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802708a:	4626      	mov	r6, r4
 802708c:	461d      	mov	r5, r3
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 802708e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8027092:	ec51 0b1a 	vmov	r0, r1, d10
 8027096:	f000 ff07 	bl	8027ea8 <__aeabi_dmul>
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 802709a:	ed96 7b00 	vldr	d7, [r6]
        const BASE x_real = REAL(X, jx);
 802709e:	ed95 6b00 	vldr	d6, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * i + j);
 80270a2:	eeb0 9a47 	vmov.f32	s18, s14
 80270a6:	eef0 9a67 	vmov.f32	s19, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80270aa:	ec53 2b16 	vmov	r2, r3, d6
        const BASE x_real = REAL(X, jx);
 80270ae:	eeb0 8a46 	vmov.f32	s16, s12
 80270b2:	eef0 8a66 	vmov.f32	s17, s13
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
 80270b6:	4682      	mov	sl, r0
 80270b8:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80270ba:	ec51 0b17 	vmov	r0, r1, d7
 80270be:	f000 fef3 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 80270c2:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80270c6:	4604      	mov	r4, r0
        const BASE x_real = REAL(X, jx);
 80270c8:	462f      	mov	r7, r5
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80270ca:	4642      	mov	r2, r8
 80270cc:	460d      	mov	r5, r1
 80270ce:	464b      	mov	r3, r9
 80270d0:	4650      	mov	r0, sl
 80270d2:	4659      	mov	r1, fp
 80270d4:	f000 fee8 	bl	8027ea8 <__aeabi_dmul>
 80270d8:	4602      	mov	r2, r0
 80270da:	460b      	mov	r3, r1
 80270dc:	4620      	mov	r0, r4
 80270de:	4629      	mov	r1, r5
 80270e0:	f000 fd2a 	bl	8027b38 <__aeabi_dsub>
 80270e4:	4602      	mov	r2, r0
 80270e6:	460b      	mov	r3, r1
 80270e8:	e9dd 0100 	ldrd	r0, r1, [sp]
 80270ec:	f000 fd24 	bl	8027b38 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 80270f0:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80270f2:	4604      	mov	r4, r0
 80270f4:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 80270f6:	464b      	mov	r3, r9
 80270f8:	ec51 0b19 	vmov	r0, r1, d9
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 80270fc:	e9cd 4500 	strd	r4, r5, [sp]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027100:	f000 fed2 	bl	8027ea8 <__aeabi_dmul>
 8027104:	ec53 2b18 	vmov	r2, r3, d8
 8027108:	460d      	mov	r5, r1
 802710a:	4604      	mov	r4, r0
 802710c:	4659      	mov	r1, fp
 802710e:	4650      	mov	r0, sl
 8027110:	f000 feca 	bl	8027ea8 <__aeabi_dmul>
 8027114:	4602      	mov	r2, r0
 8027116:	460b      	mov	r3, r1
 8027118:	4620      	mov	r0, r4
 802711a:	4629      	mov	r1, r5
 802711c:	f000 fd0e 	bl	8027b3c <__adddf3>
 8027120:	460b      	mov	r3, r1
 8027122:	4602      	mov	r2, r0
 8027124:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8027128:	f000 fd06 	bl	8027b38 <__aeabi_dsub>
 802712c:	9b08      	ldr	r3, [sp, #32]
 802712e:	18fb      	adds	r3, r7, r3
 8027130:	461d      	mov	r5, r3
      for (j = 0; j < i; j++) {
 8027132:	9b06      	ldr	r3, [sp, #24]
 8027134:	3610      	adds	r6, #16
 8027136:	42b3      	cmp	r3, r6
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027138:	e9cd 0102 	strd	r0, r1, [sp, #8]
      for (j = 0; j < i; j++) {
 802713c:	d1a7      	bne.n	802708e <cblas_ztrsv+0x5fa>
      if (nonunit) {
 802713e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027140:	2b83      	cmp	r3, #131	; 0x83
 8027142:	f000 81a5 	beq.w	8027490 <cblas_ztrsv+0x9fc>
        REAL(X, ix) = tmp_real;
 8027146:	ed9d 7b00 	vldr	d7, [sp]
 802714a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802714c:	ed83 7b00 	vstr	d7, [r3]
        IMAG(X, ix) = tmp_imag;
 8027150:	ed9d 7b02 	vldr	d7, [sp, #8]
 8027154:	ed83 7b02 	vstr	d7, [r3, #8]
    for (i = 1; i < N; i++) {
 8027158:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802715a:	9908      	ldr	r1, [sp, #32]
 802715c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802715e:	440a      	add	r2, r1
 8027160:	920c      	str	r2, [sp, #48]	; 0x30
 8027162:	990f      	ldr	r1, [sp, #60]	; 0x3c
 8027164:	9a06      	ldr	r2, [sp, #24]
 8027166:	440a      	add	r2, r1
 8027168:	9206      	str	r2, [sp, #24]
 802716a:	990a      	ldr	r1, [sp, #40]	; 0x28
 802716c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802716e:	440a      	add	r2, r1
 8027170:	920d      	str	r2, [sp, #52]	; 0x34
 8027172:	9a05      	ldr	r2, [sp, #20]
 8027174:	3301      	adds	r3, #1
 8027176:	429a      	cmp	r2, r3
 8027178:	930e      	str	r3, [sp, #56]	; 0x38
 802717a:	f47f af78 	bne.w	802706e <cblas_ztrsv+0x5da>
 802717e:	e632      	b.n	8026de6 <cblas_ztrsv+0x352>
             || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
 8027180:	2e79      	cmp	r6, #121	; 0x79
 8027182:	f47f acd5 	bne.w	8026b30 <cblas_ztrsv+0x9c>
 8027186:	e74c      	b.n	8027022 <cblas_ztrsv+0x58e>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027188:	3865      	subs	r0, #101	; 0x65
 802718a:	2801      	cmp	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 802718c:	f04f 33ff 	mov.w	r3, #4294967295
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027190:	bf94      	ite	ls
 8027192:	2000      	movls	r0, #0
 8027194:	2001      	movhi	r0, #1
  const int conj = (TransA == CblasConjTrans) ? -1 : 1;
 8027196:	930f      	str	r3, [sp, #60]	; 0x3c
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027198:	f04f 0870 	mov.w	r8, #112	; 0x70
 802719c:	e49a      	b.n	8026ad4 <cblas_ztrsv+0x40>
    ix = OFFSET(N, incX);
 802719e:	2c00      	cmp	r4, #0
 80271a0:	f340 823b 	ble.w	802761a <cblas_ztrsv+0xb86>
 80271a4:	46a3      	mov	fp, r4
 80271a6:	f04f 0a00 	mov.w	sl, #0
    if (nonunit) {
 80271aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80271ac:	2b83      	cmp	r3, #131	; 0x83
 80271ae:	f000 831a 	beq.w	80277e6 <cblas_ztrsv+0xd52>
    for (i = 1; i < N; i++) {
 80271b2:	9b05      	ldr	r3, [sp, #20]
 80271b4:	2b01      	cmp	r3, #1
 80271b6:	f77f ae16 	ble.w	8026de6 <cblas_ztrsv+0x352>
 80271ba:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80271bc:	f000 fe0a 	bl	8027dd4 <__aeabi_i2d>
 80271c0:	0122      	lsls	r2, r4, #4
 80271c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80271c4:	920d      	str	r2, [sp, #52]	; 0x34
 80271c6:	eb05 120b 	add.w	r2, r5, fp, lsl #4
 80271ca:	3301      	adds	r3, #1
 80271cc:	920f      	str	r2, [sp, #60]	; 0x3c
 80271ce:	eb05 120a 	add.w	r2, r5, sl, lsl #4
 80271d2:	011b      	lsls	r3, r3, #4
 80271d4:	9213      	str	r2, [sp, #76]	; 0x4c
 80271d6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80271d8:	9312      	str	r3, [sp, #72]	; 0x48
 80271da:	3b10      	subs	r3, #16
 80271dc:	930e      	str	r3, [sp, #56]	; 0x38
 80271de:	18d3      	adds	r3, r2, r3
 80271e0:	9311      	str	r3, [sp, #68]	; 0x44
 80271e2:	f102 0318 	add.w	r3, r2, #24
 80271e6:	9310      	str	r3, [sp, #64]	; 0x40
 80271e8:	ec41 0b19 	vmov	d9, r0, r1
 80271ec:	2301      	movs	r3, #1
 80271ee:	930c      	str	r3, [sp, #48]	; 0x30
      BASE tmp_real = REAL(X, ix);
 80271f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80271f2:	ed93 7b00 	vldr	d7, [r3]
 80271f6:	ed8d 7b06 	vstr	d7, [sp, #24]
      BASE tmp_imag = IMAG(X, ix);
 80271fa:	ed93 7b02 	vldr	d7, [r3, #8]
 80271fe:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027200:	9300      	str	r3, [sp, #0]
 8027202:	ed8d 7b08 	vstr	d7, [sp, #32]
 8027206:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027208:	9302      	str	r3, [sp, #8]
 802720a:	2300      	movs	r3, #0
 802720c:	930a      	str	r3, [sp, #40]	; 0x28
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 802720e:	9c00      	ldr	r4, [sp, #0]
 8027210:	ec51 0b19 	vmov	r0, r1, d9
 8027214:	e9d4 2300 	ldrd	r2, r3, [r4]
 8027218:	f000 fe46 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_real = REAL(X, jx);
 802721c:	9d02      	ldr	r5, [sp, #8]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 802721e:	9400      	str	r4, [sp, #0]
        const BASE x_real = REAL(X, jx);
 8027220:	ed95 7b00 	vldr	d7, [r5]
        const BASE Aij_real = CONST_REAL(A, lda * j + i);
 8027224:	e954 6702 	ldrd	r6, r7, [r4, #-8]
        const BASE x_real = REAL(X, jx);
 8027228:	eeb0 8a47 	vmov.f32	s16, s14
 802722c:	eef0 8a67 	vmov.f32	s17, s15
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027230:	ec53 2b17 	vmov	r2, r3, d7
        const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
 8027234:	4682      	mov	sl, r0
 8027236:	468b      	mov	fp, r1
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027238:	4630      	mov	r0, r6
 802723a:	4639      	mov	r1, r7
 802723c:	f000 fe34 	bl	8027ea8 <__aeabi_dmul>
        const BASE x_imag = IMAG(X, jx);
 8027240:	e9d5 8902 	ldrd	r8, r9, [r5, #8]
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027244:	4604      	mov	r4, r0
 8027246:	460d      	mov	r5, r1
 8027248:	4642      	mov	r2, r8
 802724a:	464b      	mov	r3, r9
 802724c:	4650      	mov	r0, sl
 802724e:	4659      	mov	r1, fp
 8027250:	f000 fe2a 	bl	8027ea8 <__aeabi_dmul>
 8027254:	4602      	mov	r2, r0
 8027256:	460b      	mov	r3, r1
 8027258:	4620      	mov	r0, r4
 802725a:	4629      	mov	r1, r5
 802725c:	f000 fc6c 	bl	8027b38 <__aeabi_dsub>
 8027260:	4602      	mov	r2, r0
 8027262:	460b      	mov	r3, r1
 8027264:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8027268:	f000 fc66 	bl	8027b38 <__aeabi_dsub>
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 802726c:	4642      	mov	r2, r8
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 802726e:	4604      	mov	r4, r0
 8027270:	460d      	mov	r5, r1
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 8027272:	464b      	mov	r3, r9
 8027274:	4630      	mov	r0, r6
 8027276:	4639      	mov	r1, r7
        tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
 8027278:	e9cd 4506 	strd	r4, r5, [sp, #24]
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 802727c:	f000 fe14 	bl	8027ea8 <__aeabi_dmul>
 8027280:	ec53 2b18 	vmov	r2, r3, d8
 8027284:	4604      	mov	r4, r0
 8027286:	460d      	mov	r5, r1
 8027288:	4650      	mov	r0, sl
 802728a:	4659      	mov	r1, fp
 802728c:	f000 fe0c 	bl	8027ea8 <__aeabi_dmul>
 8027290:	4602      	mov	r2, r0
 8027292:	460b      	mov	r3, r1
 8027294:	4620      	mov	r0, r4
 8027296:	4629      	mov	r1, r5
 8027298:	f000 fc50 	bl	8027b3c <__adddf3>
 802729c:	4602      	mov	r2, r0
 802729e:	460b      	mov	r3, r1
 80272a0:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
 80272a4:	f000 fc48 	bl	8027b38 <__aeabi_dsub>
 80272a8:	9b00      	ldr	r3, [sp, #0]
 80272aa:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 80272ac:	9d02      	ldr	r5, [sp, #8]
      for (j = 0; j < i; j++) {
 80272ae:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80272b0:	4423      	add	r3, r4
 80272b2:	9300      	str	r3, [sp, #0]
 80272b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80272b6:	18eb      	adds	r3, r5, r3
 80272b8:	9302      	str	r3, [sp, #8]
 80272ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80272bc:	3201      	adds	r2, #1
 80272be:	429a      	cmp	r2, r3
        tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
 80272c0:	e9cd 0108 	strd	r0, r1, [sp, #32]
      for (j = 0; j < i; j++) {
 80272c4:	920a      	str	r2, [sp, #40]	; 0x28
 80272c6:	d1a2      	bne.n	802720e <cblas_ztrsv+0x77a>
      if (nonunit) {
 80272c8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80272ca:	2b83      	cmp	r3, #131	; 0x83
 80272cc:	f000 813d 	beq.w	802754a <cblas_ztrsv+0xab6>
        REAL(X, ix) = tmp_real;
 80272d0:	ed9d 7b06 	vldr	d7, [sp, #24]
 80272d4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80272d6:	ed83 7b00 	vstr	d7, [r3]
        IMAG(X, ix) = tmp_imag;
 80272da:	ed9d 7b08 	vldr	d7, [sp, #32]
 80272de:	ed83 7b02 	vstr	d7, [r3, #8]
    for (i = 1; i < N; i++) {
 80272e2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80272e4:	990d      	ldr	r1, [sp, #52]	; 0x34
 80272e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80272e8:	440a      	add	r2, r1
 80272ea:	920f      	str	r2, [sp, #60]	; 0x3c
 80272ec:	e9dd 2111 	ldrd	r2, r1, [sp, #68]	; 0x44
 80272f0:	440a      	add	r2, r1
 80272f2:	9211      	str	r2, [sp, #68]	; 0x44
 80272f4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80272f6:	3210      	adds	r2, #16
 80272f8:	9210      	str	r2, [sp, #64]	; 0x40
 80272fa:	9a05      	ldr	r2, [sp, #20]
 80272fc:	3301      	adds	r3, #1
 80272fe:	429a      	cmp	r2, r3
 8027300:	930c      	str	r3, [sp, #48]	; 0x30
 8027302:	f47f af75 	bne.w	80271f0 <cblas_ztrsv+0x75c>
 8027306:	e56e      	b.n	8026de6 <cblas_ztrsv+0x352>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8027308:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802730a:	9b14      	ldr	r3, [sp, #80]	; 0x50
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 802730c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 802730e:	189c      	adds	r4, r3, r2
 8027310:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027312:	441c      	add	r4, r3
 8027314:	f000 fd5e 	bl	8027dd4 <__aeabi_i2d>
 8027318:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802731c:	f000 fdc4 	bl	8027ea8 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8027320:	e9d4 4500 	ldrd	r4, r5, [r4]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8027324:	4606      	mov	r6, r0
 8027326:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 8027328:	4632      	mov	r2, r6
 802732a:	463b      	mov	r3, r7
 802732c:	4620      	mov	r0, r4
 802732e:	4629      	mov	r1, r5
 8027330:	f7ff fb78 	bl	8026a24 <xhypot>
 8027334:	4682      	mov	sl, r0
 8027336:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 8027338:	4620      	mov	r0, r4
 802733a:	4629      	mov	r1, r5
 802733c:	4652      	mov	r2, sl
 802733e:	465b      	mov	r3, fp
 8027340:	f000 fedc 	bl	80280fc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 8027344:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 8027346:	4604      	mov	r4, r0
 8027348:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 802734a:	465b      	mov	r3, fp
 802734c:	4630      	mov	r0, r6
 802734e:	4639      	mov	r1, r7
 8027350:	f000 fed4 	bl	80280fc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027354:	e9dd 2300 	ldrd	r2, r3, [sp]
        const BASE b_imag = a_imag / s;
 8027358:	4680      	mov	r8, r0
 802735a:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802735c:	4620      	mov	r0, r4
 802735e:	4629      	mov	r1, r5
 8027360:	f000 fda2 	bl	8027ea8 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 8027364:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027366:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802736a:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 802736c:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802736e:	4640      	mov	r0, r8
 8027370:	460d      	mov	r5, r1
 8027372:	4649      	mov	r1, r9
 8027374:	f000 fd98 	bl	8027ea8 <__aeabi_dmul>
 8027378:	4602      	mov	r2, r0
 802737a:	460b      	mov	r3, r1
 802737c:	4620      	mov	r0, r4
 802737e:	4629      	mov	r1, r5
 8027380:	f000 fbdc 	bl	8027b3c <__adddf3>
 8027384:	4652      	mov	r2, sl
 8027386:	465b      	mov	r3, fp
 8027388:	f000 feb8 	bl	80280fc <__aeabi_ddiv>
 802738c:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 802738e:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027390:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8027392:	460d      	mov	r5, r1
 8027394:	e946 4502 	strd	r4, r5, [r6, #-8]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8027398:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802739c:	4639      	mov	r1, r7
 802739e:	f000 fd83 	bl	8027ea8 <__aeabi_dmul>
 80273a2:	e9dd 2300 	ldrd	r2, r3, [sp]
 80273a6:	4604      	mov	r4, r0
 80273a8:	460d      	mov	r5, r1
 80273aa:	4640      	mov	r0, r8
 80273ac:	4649      	mov	r1, r9
 80273ae:	f000 fd7b 	bl	8027ea8 <__aeabi_dmul>
 80273b2:	4602      	mov	r2, r0
 80273b4:	460b      	mov	r3, r1
 80273b6:	4620      	mov	r0, r4
 80273b8:	4629      	mov	r1, r5
 80273ba:	f000 fbbd 	bl	8027b38 <__aeabi_dsub>
 80273be:	4652      	mov	r2, sl
 80273c0:	465b      	mov	r3, fp
 80273c2:	f000 fe9b 	bl	80280fc <__aeabi_ddiv>
 80273c6:	e9c6 0100 	strd	r0, r1, [r6]
 80273ca:	e4fb      	b.n	8026dc4 <cblas_ztrsv+0x330>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 80273cc:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80273ce:	9b10      	ldr	r3, [sp, #64]	; 0x40
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80273d0:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80273d2:	189c      	adds	r4, r3, r2
 80273d4:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80273d6:	441c      	add	r4, r3
 80273d8:	f000 fcfc 	bl	8027dd4 <__aeabi_i2d>
 80273dc:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 80273e0:	f000 fd62 	bl	8027ea8 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 80273e4:	e9d4 4500 	ldrd	r4, r5, [r4]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80273e8:	4606      	mov	r6, r0
 80273ea:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 80273ec:	4632      	mov	r2, r6
 80273ee:	463b      	mov	r3, r7
 80273f0:	4620      	mov	r0, r4
 80273f2:	4629      	mov	r1, r5
 80273f4:	f7ff fb16 	bl	8026a24 <xhypot>
 80273f8:	4682      	mov	sl, r0
 80273fa:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 80273fc:	4620      	mov	r0, r4
 80273fe:	4629      	mov	r1, r5
 8027400:	4652      	mov	r2, sl
 8027402:	465b      	mov	r3, fp
 8027404:	f000 fe7a 	bl	80280fc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 8027408:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 802740a:	4604      	mov	r4, r0
 802740c:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 802740e:	465b      	mov	r3, fp
 8027410:	4630      	mov	r0, r6
 8027412:	4639      	mov	r1, r7
 8027414:	f000 fe72 	bl	80280fc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027418:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
        const BASE b_imag = a_imag / s;
 802741c:	4680      	mov	r8, r0
 802741e:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027420:	4620      	mov	r0, r4
 8027422:	4629      	mov	r1, r5
 8027424:	f000 fd40 	bl	8027ea8 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 8027428:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802742a:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 802742e:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 8027430:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027432:	4640      	mov	r0, r8
 8027434:	460d      	mov	r5, r1
 8027436:	4649      	mov	r1, r9
 8027438:	f000 fd36 	bl	8027ea8 <__aeabi_dmul>
 802743c:	4602      	mov	r2, r0
 802743e:	460b      	mov	r3, r1
 8027440:	4620      	mov	r0, r4
 8027442:	4629      	mov	r1, r5
 8027444:	f000 fb7a 	bl	8027b3c <__adddf3>
 8027448:	4652      	mov	r2, sl
 802744a:	465b      	mov	r3, fp
 802744c:	f000 fe56 	bl	80280fc <__aeabi_ddiv>
 8027450:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8027452:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027454:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 8027456:	460d      	mov	r5, r1
 8027458:	e946 4502 	strd	r4, r5, [r6, #-8]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 802745c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 8027460:	4639      	mov	r1, r7
 8027462:	f000 fd21 	bl	8027ea8 <__aeabi_dmul>
 8027466:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 802746a:	4604      	mov	r4, r0
 802746c:	460d      	mov	r5, r1
 802746e:	4640      	mov	r0, r8
 8027470:	4649      	mov	r1, r9
 8027472:	f000 fd19 	bl	8027ea8 <__aeabi_dmul>
 8027476:	4602      	mov	r2, r0
 8027478:	460b      	mov	r3, r1
 802747a:	4620      	mov	r0, r4
 802747c:	4629      	mov	r1, r5
 802747e:	f000 fb5b 	bl	8027b38 <__aeabi_dsub>
 8027482:	4652      	mov	r2, sl
 8027484:	465b      	mov	r3, fp
 8027486:	f000 fe39 	bl	80280fc <__aeabi_ddiv>
 802748a:	e9c6 0100 	strd	r0, r1, [r6]
 802748e:	e5ae      	b.n	8026fee <cblas_ztrsv+0x55a>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 8027490:	9c06      	ldr	r4, [sp, #24]
 8027492:	ec51 0b1a 	vmov	r0, r1, d10
 8027496:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 802749a:	f000 fd05 	bl	8027ea8 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 802749e:	e9d4 4500 	ldrd	r4, r5, [r4]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 80274a2:	4606      	mov	r6, r0
 80274a4:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 80274a6:	4632      	mov	r2, r6
 80274a8:	463b      	mov	r3, r7
 80274aa:	4620      	mov	r0, r4
 80274ac:	4629      	mov	r1, r5
 80274ae:	f7ff fab9 	bl	8026a24 <xhypot>
 80274b2:	4682      	mov	sl, r0
 80274b4:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 80274b6:	4620      	mov	r0, r4
 80274b8:	4629      	mov	r1, r5
 80274ba:	4652      	mov	r2, sl
 80274bc:	465b      	mov	r3, fp
 80274be:	f000 fe1d 	bl	80280fc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 80274c2:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 80274c4:	4604      	mov	r4, r0
 80274c6:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 80274c8:	465b      	mov	r3, fp
 80274ca:	4630      	mov	r0, r6
 80274cc:	4639      	mov	r1, r7
 80274ce:	f000 fe15 	bl	80280fc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80274d2:	e9dd 2300 	ldrd	r2, r3, [sp]
        const BASE b_imag = a_imag / s;
 80274d6:	4680      	mov	r8, r0
 80274d8:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80274da:	4620      	mov	r0, r4
 80274dc:	4629      	mov	r1, r5
 80274de:	f000 fce3 	bl	8027ea8 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 80274e2:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80274e4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80274e8:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 80274ea:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80274ec:	4640      	mov	r0, r8
 80274ee:	460d      	mov	r5, r1
 80274f0:	4649      	mov	r1, r9
 80274f2:	f000 fcd9 	bl	8027ea8 <__aeabi_dmul>
 80274f6:	4602      	mov	r2, r0
 80274f8:	460b      	mov	r3, r1
 80274fa:	4620      	mov	r0, r4
 80274fc:	4629      	mov	r1, r5
 80274fe:	f000 fb1d 	bl	8027b3c <__adddf3>
 8027502:	4652      	mov	r2, sl
 8027504:	465b      	mov	r3, fp
 8027506:	f000 fdf9 	bl	80280fc <__aeabi_ddiv>
 802750a:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 802750c:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802750e:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8027510:	460d      	mov	r5, r1
 8027512:	e9c6 4500 	strd	r4, r5, [r6]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 8027516:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 802751a:	4639      	mov	r1, r7
 802751c:	f000 fcc4 	bl	8027ea8 <__aeabi_dmul>
 8027520:	e9dd 2300 	ldrd	r2, r3, [sp]
 8027524:	4604      	mov	r4, r0
 8027526:	460d      	mov	r5, r1
 8027528:	4640      	mov	r0, r8
 802752a:	4649      	mov	r1, r9
 802752c:	f000 fcbc 	bl	8027ea8 <__aeabi_dmul>
 8027530:	4602      	mov	r2, r0
 8027532:	460b      	mov	r3, r1
 8027534:	4620      	mov	r0, r4
 8027536:	4629      	mov	r1, r5
 8027538:	f000 fafe 	bl	8027b38 <__aeabi_dsub>
 802753c:	4652      	mov	r2, sl
 802753e:	465b      	mov	r3, fp
 8027540:	f000 fddc 	bl	80280fc <__aeabi_ddiv>
 8027544:	e9c6 0102 	strd	r0, r1, [r6, #8]
 8027548:	e606      	b.n	8027158 <cblas_ztrsv+0x6c4>
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 802754a:	9c11      	ldr	r4, [sp, #68]	; 0x44
 802754c:	ec51 0b19 	vmov	r0, r1, d9
 8027550:	e9d4 2306 	ldrd	r2, r3, [r4, #24]
 8027554:	f000 fca8 	bl	8027ea8 <__aeabi_dmul>
        const BASE a_real = CONST_REAL(A, lda * i + i);
 8027558:	e9d4 4504 	ldrd	r4, r5, [r4, #16]
        const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
 802755c:	4606      	mov	r6, r0
 802755e:	460f      	mov	r7, r1
        const BASE s = xhypot(a_real, a_imag);
 8027560:	4632      	mov	r2, r6
 8027562:	463b      	mov	r3, r7
 8027564:	4620      	mov	r0, r4
 8027566:	4629      	mov	r1, r5
 8027568:	f7ff fa5c 	bl	8026a24 <xhypot>
 802756c:	4682      	mov	sl, r0
 802756e:	468b      	mov	fp, r1
        const BASE b_real = a_real / s;
 8027570:	4620      	mov	r0, r4
 8027572:	4629      	mov	r1, r5
 8027574:	4652      	mov	r2, sl
 8027576:	465b      	mov	r3, fp
 8027578:	f000 fdc0 	bl	80280fc <__aeabi_ddiv>
        const BASE b_imag = a_imag / s;
 802757c:	4652      	mov	r2, sl
        const BASE b_real = a_real / s;
 802757e:	4604      	mov	r4, r0
 8027580:	460d      	mov	r5, r1
        const BASE b_imag = a_imag / s;
 8027582:	465b      	mov	r3, fp
 8027584:	4630      	mov	r0, r6
 8027586:	4639      	mov	r1, r7
 8027588:	f000 fdb8 	bl	80280fc <__aeabi_ddiv>
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802758c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
        const BASE b_imag = a_imag / s;
 8027590:	4680      	mov	r8, r0
 8027592:	4689      	mov	r9, r1
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 8027594:	4620      	mov	r0, r4
 8027596:	4629      	mov	r1, r5
 8027598:	f000 fc86 	bl	8027ea8 <__aeabi_dmul>
        const BASE b_real = a_real / s;
 802759c:	4626      	mov	r6, r4
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 802759e:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80275a2:	4604      	mov	r4, r0
        const BASE b_real = a_real / s;
 80275a4:	462f      	mov	r7, r5
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80275a6:	4640      	mov	r0, r8
 80275a8:	460d      	mov	r5, r1
 80275aa:	4649      	mov	r1, r9
 80275ac:	f000 fc7c 	bl	8027ea8 <__aeabi_dmul>
 80275b0:	4602      	mov	r2, r0
 80275b2:	460b      	mov	r3, r1
 80275b4:	4620      	mov	r0, r4
 80275b6:	4629      	mov	r1, r5
 80275b8:	f000 fac0 	bl	8027b3c <__adddf3>
 80275bc:	4652      	mov	r2, sl
 80275be:	465b      	mov	r3, fp
 80275c0:	f000 fd9c 	bl	80280fc <__aeabi_ddiv>
 80275c4:	4604      	mov	r4, r0
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80275c6:	4630      	mov	r0, r6
        REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
 80275c8:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 80275ca:	460d      	mov	r5, r1
 80275cc:	e9c6 4500 	strd	r4, r5, [r6]
        IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
 80275d0:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 80275d4:	4639      	mov	r1, r7
 80275d6:	f000 fc67 	bl	8027ea8 <__aeabi_dmul>
 80275da:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80275de:	4604      	mov	r4, r0
 80275e0:	460d      	mov	r5, r1
 80275e2:	4640      	mov	r0, r8
 80275e4:	4649      	mov	r1, r9
 80275e6:	f000 fc5f 	bl	8027ea8 <__aeabi_dmul>
 80275ea:	4602      	mov	r2, r0
 80275ec:	460b      	mov	r3, r1
 80275ee:	4620      	mov	r0, r4
 80275f0:	4629      	mov	r1, r5
 80275f2:	f000 faa1 	bl	8027b38 <__aeabi_dsub>
 80275f6:	4652      	mov	r2, sl
 80275f8:	465b      	mov	r3, fp
 80275fa:	f000 fd7f 	bl	80280fc <__aeabi_ddiv>
 80275fe:	e9c6 0102 	strd	r0, r1, [r6, #8]
 8027602:	e66e      	b.n	80272e2 <cblas_ztrsv+0x84e>
  CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
 8027604:	2009      	movs	r0, #9
 8027606:	f7ff ba7a 	b.w	8026afe <cblas_ztrsv+0x6a>
    ix = OFFSET(N, incX);
 802760a:	9b05      	ldr	r3, [sp, #20]
 802760c:	f1c3 0a01 	rsb	sl, r3, #1
 8027610:	fb0a fa04 	mul.w	sl, sl, r4
 8027614:	eb04 0b0a 	add.w	fp, r4, sl
 8027618:	e509      	b.n	802702e <cblas_ztrsv+0x59a>
    ix = OFFSET(N, incX);
 802761a:	9b05      	ldr	r3, [sp, #20]
 802761c:	f1c3 0a01 	rsb	sl, r3, #1
 8027620:	fb0a fa04 	mul.w	sl, sl, r4
 8027624:	eb04 0b0a 	add.w	fp, r4, sl
 8027628:	e5bf      	b.n	80271aa <cblas_ztrsv+0x716>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 802762a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 802762c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 802762e:	980f      	ldr	r0, [sp, #60]	; 0x3c
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8027630:	fb02 2603 	mla	r6, r2, r3, r2
 8027634:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027636:	eb03 1606 	add.w	r6, r3, r6, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 802763a:	f000 fbcb 	bl	8027dd4 <__aeabi_i2d>
 802763e:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8027642:	f000 fc31 	bl	8027ea8 <__aeabi_dmul>
      const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
 8027646:	e9d6 8900 	ldrd	r8, r9, [r6]
      const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
 802764a:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE x_imag = IMAG(X, ix);
 802764e:	eb05 160a 	add.w	r6, r5, sl, lsl #4
      const BASE s = xhypot(a_real, a_imag);
 8027652:	ec53 2b1a 	vmov	r2, r3, d10
      const BASE x_imag = IMAG(X, ix);
 8027656:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 8027658:	4640      	mov	r0, r8
 802765a:	4649      	mov	r1, r9
      const BASE x_real = REAL(X, ix);
 802765c:	eb05 1b0a 	add.w	fp, r5, sl, lsl #4
      const BASE x_imag = IMAG(X, ix);
 8027660:	ed96 8b00 	vldr	d8, [r6]
      const BASE x_real = REAL(X, ix);
 8027664:	ed9b 9b00 	vldr	d9, [fp]
      const BASE x_imag = IMAG(X, ix);
 8027668:	9600      	str	r6, [sp, #0]
      const BASE s = xhypot(a_real, a_imag);
 802766a:	f7ff f9db 	bl	8026a24 <xhypot>
 802766e:	4606      	mov	r6, r0
 8027670:	460f      	mov	r7, r1
      const BASE b_real = a_real / s;
 8027672:	4632      	mov	r2, r6
 8027674:	4640      	mov	r0, r8
 8027676:	4649      	mov	r1, r9
 8027678:	463b      	mov	r3, r7
 802767a:	f000 fd3f 	bl	80280fc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 802767e:	4632      	mov	r2, r6
      const BASE b_real = a_real / s;
 8027680:	4680      	mov	r8, r0
 8027682:	4689      	mov	r9, r1
      const BASE b_imag = a_imag / s;
 8027684:	463b      	mov	r3, r7
 8027686:	ec51 0b1a 	vmov	r0, r1, d10
 802768a:	f000 fd37 	bl	80280fc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 802768e:	ec49 8b1b 	vmov	d11, r8, r9
      const BASE b_imag = a_imag / s;
 8027692:	4680      	mov	r8, r0
 8027694:	4689      	mov	r9, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8027696:	ec53 2b1b 	vmov	r2, r3, d11
 802769a:	ec51 0b19 	vmov	r0, r1, d9
 802769e:	f000 fc03 	bl	8027ea8 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 80276a2:	ec49 8b1a 	vmov	d10, r8, r9
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80276a6:	4680      	mov	r8, r0
 80276a8:	ec53 2b1a 	vmov	r2, r3, d10
 80276ac:	4689      	mov	r9, r1
 80276ae:	ec51 0b18 	vmov	r0, r1, d8
 80276b2:	f000 fbf9 	bl	8027ea8 <__aeabi_dmul>
 80276b6:	4602      	mov	r2, r0
 80276b8:	460b      	mov	r3, r1
 80276ba:	4640      	mov	r0, r8
 80276bc:	4649      	mov	r1, r9
 80276be:	f000 fa3d 	bl	8027b3c <__adddf3>
 80276c2:	4632      	mov	r2, r6
 80276c4:	463b      	mov	r3, r7
 80276c6:	f000 fd19 	bl	80280fc <__aeabi_ddiv>
 80276ca:	4680      	mov	r8, r0
 80276cc:	4689      	mov	r9, r1
 80276ce:	e9cb 8900 	strd	r8, r9, [fp]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80276d2:	ec53 2b1b 	vmov	r2, r3, d11
 80276d6:	ec51 0b18 	vmov	r0, r1, d8
 80276da:	f000 fbe5 	bl	8027ea8 <__aeabi_dmul>
 80276de:	ec53 2b1a 	vmov	r2, r3, d10
 80276e2:	4680      	mov	r8, r0
 80276e4:	4689      	mov	r9, r1
 80276e6:	ec51 0b19 	vmov	r0, r1, d9
 80276ea:	f000 fbdd 	bl	8027ea8 <__aeabi_dmul>
 80276ee:	4602      	mov	r2, r0
 80276f0:	460b      	mov	r3, r1
 80276f2:	4640      	mov	r0, r8
 80276f4:	4649      	mov	r1, r9
 80276f6:	f000 fa1f 	bl	8027b38 <__aeabi_dsub>
 80276fa:	4632      	mov	r2, r6
 80276fc:	463b      	mov	r3, r7
 80276fe:	f000 fcfd 	bl	80280fc <__aeabi_ddiv>
 8027702:	9e00      	ldr	r6, [sp, #0]
 8027704:	e9c6 0100 	strd	r0, r1, [r6]
 8027708:	f7ff bbbf 	b.w	8026e8a <cblas_ztrsv+0x3f6>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 802770c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 802770e:	f000 fb61 	bl	8027dd4 <__aeabi_i2d>
 8027712:	9e10      	ldr	r6, [sp, #64]	; 0x40
 8027714:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 8027718:	f000 fbc6 	bl	8027ea8 <__aeabi_dmul>
      const BASE x_real = REAL(X, ix);
 802771c:	eb05 170a 	add.w	r7, r5, sl, lsl #4
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 8027720:	e9d6 8900 	ldrd	r8, r9, [r6]
      const BASE x_real = REAL(X, ix);
 8027724:	9700      	str	r7, [sp, #0]
 8027726:	9f00      	ldr	r7, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8027728:	eb05 160a 	add.w	r6, r5, sl, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 802772c:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE s = xhypot(a_real, a_imag);
 8027730:	4602      	mov	r2, r0
 8027732:	460b      	mov	r3, r1
      const BASE x_imag = IMAG(X, ix);
 8027734:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 8027736:	4640      	mov	r0, r8
 8027738:	4649      	mov	r1, r9
      const BASE x_real = REAL(X, ix);
 802773a:	ed97 9b00 	vldr	d9, [r7]
      const BASE x_imag = IMAG(X, ix);
 802773e:	ed96 8b00 	vldr	d8, [r6]
 8027742:	9602      	str	r6, [sp, #8]
      const BASE s = xhypot(a_real, a_imag);
 8027744:	f7ff f96e 	bl	8026a24 <xhypot>
 8027748:	ec41 0b1b 	vmov	d11, r0, r1
      const BASE b_real = a_real / s;
 802774c:	4640      	mov	r0, r8
 802774e:	ec53 2b1b 	vmov	r2, r3, d11
 8027752:	4649      	mov	r1, r9
 8027754:	f000 fcd2 	bl	80280fc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 8027758:	ec53 2b1b 	vmov	r2, r3, d11
      const BASE b_real = a_real / s;
 802775c:	4680      	mov	r8, r0
 802775e:	4689      	mov	r9, r1
      const BASE b_imag = a_imag / s;
 8027760:	ec51 0b1a 	vmov	r0, r1, d10
 8027764:	f000 fcca 	bl	80280fc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 8027768:	4646      	mov	r6, r8
 802776a:	464f      	mov	r7, r9
      const BASE b_imag = a_imag / s;
 802776c:	4680      	mov	r8, r0
 802776e:	4689      	mov	r9, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8027770:	4632      	mov	r2, r6
 8027772:	463b      	mov	r3, r7
 8027774:	ec51 0b19 	vmov	r0, r1, d9
 8027778:	f000 fb96 	bl	8027ea8 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 802777c:	ec49 8b1a 	vmov	d10, r8, r9
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8027780:	4680      	mov	r8, r0
 8027782:	ec53 2b1a 	vmov	r2, r3, d10
 8027786:	4689      	mov	r9, r1
 8027788:	ec51 0b18 	vmov	r0, r1, d8
 802778c:	f000 fb8c 	bl	8027ea8 <__aeabi_dmul>
 8027790:	4602      	mov	r2, r0
 8027792:	460b      	mov	r3, r1
 8027794:	4640      	mov	r0, r8
 8027796:	4649      	mov	r1, r9
 8027798:	f000 f9d0 	bl	8027b3c <__adddf3>
 802779c:	ec53 2b1b 	vmov	r2, r3, d11
 80277a0:	f000 fcac 	bl	80280fc <__aeabi_ddiv>
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80277a4:	463b      	mov	r3, r7
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 80277a6:	9f00      	ldr	r7, [sp, #0]
 80277a8:	4680      	mov	r8, r0
 80277aa:	4689      	mov	r9, r1
 80277ac:	e9c7 8900 	strd	r8, r9, [r7]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 80277b0:	4632      	mov	r2, r6
 80277b2:	ec51 0b18 	vmov	r0, r1, d8
 80277b6:	f000 fb77 	bl	8027ea8 <__aeabi_dmul>
 80277ba:	ec53 2b1a 	vmov	r2, r3, d10
 80277be:	4680      	mov	r8, r0
 80277c0:	4689      	mov	r9, r1
 80277c2:	ec51 0b19 	vmov	r0, r1, d9
 80277c6:	f000 fb6f 	bl	8027ea8 <__aeabi_dmul>
 80277ca:	4602      	mov	r2, r0
 80277cc:	460b      	mov	r3, r1
 80277ce:	4640      	mov	r0, r8
 80277d0:	4649      	mov	r1, r9
 80277d2:	f000 f9b1 	bl	8027b38 <__aeabi_dsub>
 80277d6:	ec53 2b1b 	vmov	r2, r3, d11
 80277da:	f000 fc8f 	bl	80280fc <__aeabi_ddiv>
 80277de:	9e02      	ldr	r6, [sp, #8]
 80277e0:	e9c6 0100 	strd	r0, r1, [r6]
 80277e4:	e427      	b.n	8027036 <cblas_ztrsv+0x5a2>
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 80277e6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80277e8:	f000 faf4 	bl	8027dd4 <__aeabi_i2d>
 80277ec:	9e10      	ldr	r6, [sp, #64]	; 0x40
 80277ee:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
 80277f2:	f000 fb59 	bl	8027ea8 <__aeabi_dmul>
      const BASE x_real = REAL(X, ix);
 80277f6:	eb05 170a 	add.w	r7, r5, sl, lsl #4
      const BASE a_real = CONST_REAL(A, lda * 0 + 0);
 80277fa:	e9d6 8900 	ldrd	r8, r9, [r6]
      const BASE x_real = REAL(X, ix);
 80277fe:	9700      	str	r7, [sp, #0]
 8027800:	9f00      	ldr	r7, [sp, #0]
      const BASE x_imag = IMAG(X, ix);
 8027802:	eb05 160a 	add.w	r6, r5, sl, lsl #4
      const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
 8027806:	ec41 0b1a 	vmov	d10, r0, r1
      const BASE s = xhypot(a_real, a_imag);
 802780a:	4602      	mov	r2, r0
 802780c:	460b      	mov	r3, r1
      const BASE x_imag = IMAG(X, ix);
 802780e:	3608      	adds	r6, #8
      const BASE s = xhypot(a_real, a_imag);
 8027810:	4640      	mov	r0, r8
 8027812:	4649      	mov	r1, r9
      const BASE x_real = REAL(X, ix);
 8027814:	ed97 9b00 	vldr	d9, [r7]
      const BASE x_imag = IMAG(X, ix);
 8027818:	ed96 8b00 	vldr	d8, [r6]
 802781c:	9602      	str	r6, [sp, #8]
      const BASE s = xhypot(a_real, a_imag);
 802781e:	f7ff f901 	bl	8026a24 <xhypot>
 8027822:	ec41 0b1b 	vmov	d11, r0, r1
      const BASE b_real = a_real / s;
 8027826:	4640      	mov	r0, r8
 8027828:	ec53 2b1b 	vmov	r2, r3, d11
 802782c:	4649      	mov	r1, r9
 802782e:	f000 fc65 	bl	80280fc <__aeabi_ddiv>
      const BASE b_imag = a_imag / s;
 8027832:	ec53 2b1b 	vmov	r2, r3, d11
      const BASE b_real = a_real / s;
 8027836:	4680      	mov	r8, r0
 8027838:	4689      	mov	r9, r1
      const BASE b_imag = a_imag / s;
 802783a:	ec51 0b1a 	vmov	r0, r1, d10
 802783e:	f000 fc5d 	bl	80280fc <__aeabi_ddiv>
      const BASE b_real = a_real / s;
 8027842:	4646      	mov	r6, r8
 8027844:	464f      	mov	r7, r9
      const BASE b_imag = a_imag / s;
 8027846:	4680      	mov	r8, r0
 8027848:	4689      	mov	r9, r1
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 802784a:	4632      	mov	r2, r6
 802784c:	463b      	mov	r3, r7
 802784e:	ec51 0b19 	vmov	r0, r1, d9
 8027852:	f000 fb29 	bl	8027ea8 <__aeabi_dmul>
      const BASE b_imag = a_imag / s;
 8027856:	ec49 8b1a 	vmov	d10, r8, r9
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 802785a:	4680      	mov	r8, r0
 802785c:	ec53 2b1a 	vmov	r2, r3, d10
 8027860:	4689      	mov	r9, r1
 8027862:	ec51 0b18 	vmov	r0, r1, d8
 8027866:	f000 fb1f 	bl	8027ea8 <__aeabi_dmul>
 802786a:	4602      	mov	r2, r0
 802786c:	460b      	mov	r3, r1
 802786e:	4640      	mov	r0, r8
 8027870:	4649      	mov	r1, r9
 8027872:	f000 f963 	bl	8027b3c <__adddf3>
 8027876:	ec53 2b1b 	vmov	r2, r3, d11
 802787a:	f000 fc3f 	bl	80280fc <__aeabi_ddiv>
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 802787e:	463b      	mov	r3, r7
      REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
 8027880:	9f00      	ldr	r7, [sp, #0]
 8027882:	4680      	mov	r8, r0
 8027884:	4689      	mov	r9, r1
 8027886:	e9c7 8900 	strd	r8, r9, [r7]
      IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
 802788a:	4632      	mov	r2, r6
 802788c:	ec51 0b18 	vmov	r0, r1, d8
 8027890:	f000 fb0a 	bl	8027ea8 <__aeabi_dmul>
 8027894:	ec53 2b1a 	vmov	r2, r3, d10
 8027898:	4680      	mov	r8, r0
 802789a:	4689      	mov	r9, r1
 802789c:	ec51 0b19 	vmov	r0, r1, d9
 80278a0:	f000 fb02 	bl	8027ea8 <__aeabi_dmul>
 80278a4:	4602      	mov	r2, r0
 80278a6:	460b      	mov	r3, r1
 80278a8:	4640      	mov	r0, r8
 80278aa:	4649      	mov	r1, r9
 80278ac:	f000 f944 	bl	8027b38 <__aeabi_dsub>
 80278b0:	ec53 2b1b 	vmov	r2, r3, d11
 80278b4:	f000 fc22 	bl	80280fc <__aeabi_ddiv>
 80278b8:	9e02      	ldr	r6, [sp, #8]
 80278ba:	e9c6 0100 	strd	r0, r1, [r6]
 80278be:	e478      	b.n	80271b2 <cblas_ztrsv+0x71e>

080278c0 <cblas_icamax>:
  BASE max = 0.0;
  INDEX ix = 0;
  INDEX i;
  CBLAS_INDEX result = 0;

  if (incX <= 0) {
 80278c0:	2a00      	cmp	r2, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_icamax (const int N, const void *X, const int incX)
{
 80278c2:	b410      	push	{r4}
    return 0;
 80278c4:	f04f 0400 	mov.w	r4, #0
  if (incX <= 0) {
 80278c8:	dd1d      	ble.n	8027906 <cblas_icamax+0x46>
  }

  for (i = 0; i < N; i++) {
 80278ca:	2800      	cmp	r0, #0
 80278cc:	dd1b      	ble.n	8027906 <cblas_icamax+0x46>
  BASE max = 0.0;
 80278ce:	eddf 6a10 	vldr	s13, [pc, #64]	; 8027910 <cblas_icamax+0x50>
 80278d2:	00d2      	lsls	r2, r2, #3
  for (i = 0; i < N; i++) {
 80278d4:	4623      	mov	r3, r4
    const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 80278d6:	edd1 7a00 	vldr	s15, [r1]
 80278da:	ed91 7a01 	vldr	s14, [r1, #4]
 80278de:	eef0 7ae7 	vabs.f32	s15, s15
 80278e2:	eeb0 7ac7 	vabs.f32	s14, s14
 80278e6:	ee77 7a87 	vadd.f32	s15, s15, s14

    if (a > max) {
      max = a;
      result = i;
 80278ea:	4411      	add	r1, r2
    if (a > max) {
 80278ec:	eef4 7ae6 	vcmpe.f32	s15, s13
 80278f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      result = i;
 80278f4:	bfc8      	it	gt
 80278f6:	461c      	movgt	r4, r3
  for (i = 0; i < N; i++) {
 80278f8:	f103 0301 	add.w	r3, r3, #1
      max = a;
 80278fc:	bfc8      	it	gt
 80278fe:	eef0 6a67 	vmovgt.f32	s13, s15
  for (i = 0; i < N; i++) {
 8027902:	4298      	cmp	r0, r3
 8027904:	d1e7      	bne.n	80278d6 <cblas_icamax+0x16>
#define BASE float
#include "source_iamax_c.h"
#undef BASE
}
 8027906:	4620      	mov	r0, r4
 8027908:	f85d 4b04 	ldr.w	r4, [sp], #4
 802790c:	4770      	bx	lr
 802790e:	bf00      	nop
 8027910:	00000000 	.word	0x00000000

08027914 <cblas_idamax>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_idamax (const int N, const double *X, const int incX)
{
 8027914:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  BASE max = 0.0;
  INDEX ix = 0;
  INDEX i;
  CBLAS_INDEX result = 0;

  if (incX <= 0) {
 8027918:	2a00      	cmp	r2, #0
 802791a:	b083      	sub	sp, #12
 802791c:	dd21      	ble.n	8027962 <cblas_idamax+0x4e>
    return 0;
  }

  for (i = 0; i < N; i++) {
 802791e:	2800      	cmp	r0, #0
 8027920:	4681      	mov	r9, r0
 8027922:	dd1e      	ble.n	8027962 <cblas_idamax+0x4e>
  CBLAS_INDEX result = 0;
 8027924:	2500      	movs	r5, #0
  BASE max = 0.0;
 8027926:	f04f 0a00 	mov.w	sl, #0
 802792a:	f04f 0b00 	mov.w	fp, #0
  CBLAS_INDEX result = 0;
 802792e:	9501      	str	r5, [sp, #4]
 8027930:	ea4f 08c2 	mov.w	r8, r2, lsl #3
 8027934:	460c      	mov	r4, r1
    if (fabs(X[ix]) > max) {
 8027936:	e9d4 6300 	ldrd	r6, r3, [r4]
 802793a:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
 802793e:	4630      	mov	r0, r6
 8027940:	4639      	mov	r1, r7
 8027942:	4652      	mov	r2, sl
 8027944:	465b      	mov	r3, fp
 8027946:	f000 fd3f 	bl	80283c8 <__aeabi_dcmpgt>
      max = fabs(X[ix]);
      result = i;
 802794a:	4444      	add	r4, r8
    if (fabs(X[ix]) > max) {
 802794c:	b110      	cbz	r0, 8027954 <cblas_idamax+0x40>
      max = fabs(X[ix]);
 802794e:	46b2      	mov	sl, r6
 8027950:	46bb      	mov	fp, r7
      result = i;
 8027952:	9501      	str	r5, [sp, #4]
  for (i = 0; i < N; i++) {
 8027954:	3501      	adds	r5, #1
 8027956:	45a9      	cmp	r9, r5
 8027958:	d1ed      	bne.n	8027936 <cblas_idamax+0x22>
#define BASE double
#include "source_iamax_r.h"
#undef BASE
}
 802795a:	9801      	ldr	r0, [sp, #4]
 802795c:	b003      	add	sp, #12
 802795e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 8027962:	2300      	movs	r3, #0
 8027964:	9301      	str	r3, [sp, #4]
 8027966:	9801      	ldr	r0, [sp, #4]
 8027968:	b003      	add	sp, #12
 802796a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802796e:	bf00      	nop

08027970 <cblas_isamax>:
  if (incX <= 0) {
 8027970:	2a00      	cmp	r2, #0
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_isamax (const int N, const float *X, const int incX)
{
 8027972:	b410      	push	{r4}
    return 0;
 8027974:	f04f 0400 	mov.w	r4, #0
  if (incX <= 0) {
 8027978:	dd17      	ble.n	80279aa <cblas_isamax+0x3a>
  for (i = 0; i < N; i++) {
 802797a:	2800      	cmp	r0, #0
 802797c:	dd15      	ble.n	80279aa <cblas_isamax+0x3a>
  BASE max = 0.0;
 802797e:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 80279b4 <cblas_isamax+0x44>
 8027982:	0092      	lsls	r2, r2, #2
  for (i = 0; i < N; i++) {
 8027984:	4623      	mov	r3, r4
    if (fabs(X[ix]) > max) {
 8027986:	edd1 7a00 	vldr	s15, [r1]
 802798a:	eef0 7ae7 	vabs.f32	s15, s15
 802798e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8027992:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
      result = i;
 8027996:	bfc8      	it	gt
 8027998:	461c      	movgt	r4, r3
  for (i = 0; i < N; i++) {
 802799a:	f103 0301 	add.w	r3, r3, #1
      max = fabs(X[ix]);
 802799e:	bfc8      	it	gt
 80279a0:	eeb0 7a67 	vmovgt.f32	s14, s15
  for (i = 0; i < N; i++) {
 80279a4:	4298      	cmp	r0, r3
 80279a6:	4411      	add	r1, r2
 80279a8:	d1ed      	bne.n	8027986 <cblas_isamax+0x16>
#define BASE float
#include "source_iamax_r.h"
#undef BASE
}
 80279aa:	4620      	mov	r0, r4
 80279ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80279b0:	4770      	bx	lr
 80279b2:	bf00      	nop
 80279b4:	00000000 	.word	0x00000000

080279b8 <cblas_izamax>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

CBLAS_INDEX
cblas_izamax (const int N, const void *X, const int incX)
{
 80279b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80279bc:	ed2d 8b02 	vpush	{d8}
 80279c0:	b085      	sub	sp, #20
  if (incX <= 0) {
 80279c2:	2a00      	cmp	r2, #0
 80279c4:	9001      	str	r0, [sp, #4]
 80279c6:	dd31      	ble.n	8027a2c <cblas_izamax+0x74>
  for (i = 0; i < N; i++) {
 80279c8:	2800      	cmp	r0, #0
 80279ca:	dd2f      	ble.n	8027a2c <cblas_izamax+0x74>
  BASE max = 0.0;
 80279cc:	ed9f 7b1c 	vldr	d7, [pc, #112]	; 8027a40 <cblas_izamax+0x88>
  CBLAS_INDEX result = 0;
 80279d0:	2500      	movs	r5, #0
 80279d2:	0113      	lsls	r3, r2, #4
 80279d4:	9503      	str	r5, [sp, #12]
 80279d6:	9302      	str	r3, [sp, #8]
 80279d8:	460c      	mov	r4, r1
  BASE max = 0.0;
 80279da:	eeb0 8a47 	vmov.f32	s16, s14
 80279de:	eef0 8a67 	vmov.f32	s17, s15
    const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 80279e2:	e9d4 2a01 	ldrd	r2, sl, [r4, #4]
 80279e6:	68e3      	ldr	r3, [r4, #12]
 80279e8:	f8d4 8000 	ldr.w	r8, [r4]
 80279ec:	f022 4900 	bic.w	r9, r2, #2147483648	; 0x80000000
 80279f0:	f023 4b00 	bic.w	fp, r3, #2147483648	; 0x80000000
 80279f4:	4652      	mov	r2, sl
 80279f6:	465b      	mov	r3, fp
 80279f8:	4640      	mov	r0, r8
 80279fa:	4649      	mov	r1, r9
 80279fc:	f000 f89e 	bl	8027b3c <__adddf3>
    if (a > max) {
 8027a00:	ec53 2b18 	vmov	r2, r3, d8
    const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
 8027a04:	4606      	mov	r6, r0
 8027a06:	460f      	mov	r7, r1
    if (a > max) {
 8027a08:	f000 fcde 	bl	80283c8 <__aeabi_dcmpgt>
      result = i;
 8027a0c:	9b02      	ldr	r3, [sp, #8]
 8027a0e:	441c      	add	r4, r3
    if (a > max) {
 8027a10:	b110      	cbz	r0, 8027a18 <cblas_izamax+0x60>
      max = a;
 8027a12:	ec47 6b18 	vmov	d8, r6, r7
      result = i;
 8027a16:	9503      	str	r5, [sp, #12]
  for (i = 0; i < N; i++) {
 8027a18:	9b01      	ldr	r3, [sp, #4]
 8027a1a:	3501      	adds	r5, #1
 8027a1c:	42ab      	cmp	r3, r5
 8027a1e:	d1e0      	bne.n	80279e2 <cblas_izamax+0x2a>
#define BASE double
#include "source_iamax_c.h"
#undef BASE
}
 8027a20:	9803      	ldr	r0, [sp, #12]
 8027a22:	b005      	add	sp, #20
 8027a24:	ecbd 8b02 	vpop	{d8}
 8027a28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 8027a2c:	2300      	movs	r3, #0
 8027a2e:	9303      	str	r3, [sp, #12]
 8027a30:	9803      	ldr	r0, [sp, #12]
 8027a32:	b005      	add	sp, #20
 8027a34:	ecbd 8b02 	vpop	{d8}
 8027a38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027a3c:	f3af 8000 	nop.w
	...

08027a48 <cblas_xerbla>:
#include <gsl/gsl_cblas.h>
#include "cblas.h"

void
cblas_xerbla (int p, const char *rout, const char *form, ...)
{
 8027a48:	b40c      	push	{r2, r3}
 8027a4a:	b500      	push	{lr}
 8027a4c:	b083      	sub	sp, #12
 8027a4e:	aa04      	add	r2, sp, #16
 8027a50:	f852 5b04 	ldr.w	r5, [r2], #4
  va_list ap;

  va_start (ap, form);
 8027a54:	9201      	str	r2, [sp, #4]

  if (p)
 8027a56:	b940      	cbnz	r0, 8027a6a <cblas_xerbla+0x22>
 8027a58:	4c08      	ldr	r4, [pc, #32]	; (8027a7c <cblas_xerbla+0x34>)
    {
      fprintf (stderr, "Parameter %d to routine %s was incorrect\n", p, rout);
    }

  vfprintf (stderr, form, ap);
 8027a5a:	6823      	ldr	r3, [r4, #0]
 8027a5c:	9a01      	ldr	r2, [sp, #4]
 8027a5e:	68d8      	ldr	r0, [r3, #12]
 8027a60:	4629      	mov	r1, r5
 8027a62:	f007 fe61 	bl	802f728 <vfiprintf>
  va_end (ap);

  abort ();
 8027a66:	f007 fa33 	bl	802eed0 <abort>
      fprintf (stderr, "Parameter %d to routine %s was incorrect\n", p, rout);
 8027a6a:	4c04      	ldr	r4, [pc, #16]	; (8027a7c <cblas_xerbla+0x34>)
 8027a6c:	6826      	ldr	r6, [r4, #0]
 8027a6e:	460b      	mov	r3, r1
 8027a70:	4602      	mov	r2, r0
 8027a72:	4903      	ldr	r1, [pc, #12]	; (8027a80 <cblas_xerbla+0x38>)
 8027a74:	68f0      	ldr	r0, [r6, #12]
 8027a76:	f007 fba7 	bl	802f1c8 <fiprintf>
 8027a7a:	e7ee      	b.n	8027a5a <cblas_xerbla+0x12>
 8027a7c:	200000a4 	.word	0x200000a4
 8027a80:	080307c4 	.word	0x080307c4
	...

08027a90 <memchr>:
 8027a90:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8027a94:	2a10      	cmp	r2, #16
 8027a96:	db2b      	blt.n	8027af0 <memchr+0x60>
 8027a98:	f010 0f07 	tst.w	r0, #7
 8027a9c:	d008      	beq.n	8027ab0 <memchr+0x20>
 8027a9e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8027aa2:	3a01      	subs	r2, #1
 8027aa4:	428b      	cmp	r3, r1
 8027aa6:	d02d      	beq.n	8027b04 <memchr+0x74>
 8027aa8:	f010 0f07 	tst.w	r0, #7
 8027aac:	b342      	cbz	r2, 8027b00 <memchr+0x70>
 8027aae:	d1f6      	bne.n	8027a9e <memchr+0xe>
 8027ab0:	b4f0      	push	{r4, r5, r6, r7}
 8027ab2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8027ab6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 8027aba:	f022 0407 	bic.w	r4, r2, #7
 8027abe:	f07f 0700 	mvns.w	r7, #0
 8027ac2:	2300      	movs	r3, #0
 8027ac4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8027ac8:	3c08      	subs	r4, #8
 8027aca:	ea85 0501 	eor.w	r5, r5, r1
 8027ace:	ea86 0601 	eor.w	r6, r6, r1
 8027ad2:	fa85 f547 	uadd8	r5, r5, r7
 8027ad6:	faa3 f587 	sel	r5, r3, r7
 8027ada:	fa86 f647 	uadd8	r6, r6, r7
 8027ade:	faa5 f687 	sel	r6, r5, r7
 8027ae2:	b98e      	cbnz	r6, 8027b08 <memchr+0x78>
 8027ae4:	d1ee      	bne.n	8027ac4 <memchr+0x34>
 8027ae6:	bcf0      	pop	{r4, r5, r6, r7}
 8027ae8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8027aec:	f002 0207 	and.w	r2, r2, #7
 8027af0:	b132      	cbz	r2, 8027b00 <memchr+0x70>
 8027af2:	f810 3b01 	ldrb.w	r3, [r0], #1
 8027af6:	3a01      	subs	r2, #1
 8027af8:	ea83 0301 	eor.w	r3, r3, r1
 8027afc:	b113      	cbz	r3, 8027b04 <memchr+0x74>
 8027afe:	d1f8      	bne.n	8027af2 <memchr+0x62>
 8027b00:	2000      	movs	r0, #0
 8027b02:	4770      	bx	lr
 8027b04:	3801      	subs	r0, #1
 8027b06:	4770      	bx	lr
 8027b08:	2d00      	cmp	r5, #0
 8027b0a:	bf06      	itte	eq
 8027b0c:	4635      	moveq	r5, r6
 8027b0e:	3803      	subeq	r0, #3
 8027b10:	3807      	subne	r0, #7
 8027b12:	f015 0f01 	tst.w	r5, #1
 8027b16:	d107      	bne.n	8027b28 <memchr+0x98>
 8027b18:	3001      	adds	r0, #1
 8027b1a:	f415 7f80 	tst.w	r5, #256	; 0x100
 8027b1e:	bf02      	ittt	eq
 8027b20:	3001      	addeq	r0, #1
 8027b22:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8027b26:	3001      	addeq	r0, #1
 8027b28:	bcf0      	pop	{r4, r5, r6, r7}
 8027b2a:	3801      	subs	r0, #1
 8027b2c:	4770      	bx	lr
 8027b2e:	bf00      	nop

08027b30 <__aeabi_drsub>:
 8027b30:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8027b34:	e002      	b.n	8027b3c <__adddf3>
 8027b36:	bf00      	nop

08027b38 <__aeabi_dsub>:
 8027b38:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08027b3c <__adddf3>:
 8027b3c:	b530      	push	{r4, r5, lr}
 8027b3e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8027b42:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8027b46:	ea94 0f05 	teq	r4, r5
 8027b4a:	bf08      	it	eq
 8027b4c:	ea90 0f02 	teqeq	r0, r2
 8027b50:	bf1f      	itttt	ne
 8027b52:	ea54 0c00 	orrsne.w	ip, r4, r0
 8027b56:	ea55 0c02 	orrsne.w	ip, r5, r2
 8027b5a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8027b5e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8027b62:	f000 80e2 	beq.w	8027d2a <__adddf3+0x1ee>
 8027b66:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8027b6a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8027b6e:	bfb8      	it	lt
 8027b70:	426d      	neglt	r5, r5
 8027b72:	dd0c      	ble.n	8027b8e <__adddf3+0x52>
 8027b74:	442c      	add	r4, r5
 8027b76:	ea80 0202 	eor.w	r2, r0, r2
 8027b7a:	ea81 0303 	eor.w	r3, r1, r3
 8027b7e:	ea82 0000 	eor.w	r0, r2, r0
 8027b82:	ea83 0101 	eor.w	r1, r3, r1
 8027b86:	ea80 0202 	eor.w	r2, r0, r2
 8027b8a:	ea81 0303 	eor.w	r3, r1, r3
 8027b8e:	2d36      	cmp	r5, #54	; 0x36
 8027b90:	bf88      	it	hi
 8027b92:	bd30      	pophi	{r4, r5, pc}
 8027b94:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8027b98:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8027b9c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8027ba0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8027ba4:	d002      	beq.n	8027bac <__adddf3+0x70>
 8027ba6:	4240      	negs	r0, r0
 8027ba8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8027bac:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8027bb0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8027bb4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8027bb8:	d002      	beq.n	8027bc0 <__adddf3+0x84>
 8027bba:	4252      	negs	r2, r2
 8027bbc:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8027bc0:	ea94 0f05 	teq	r4, r5
 8027bc4:	f000 80a7 	beq.w	8027d16 <__adddf3+0x1da>
 8027bc8:	f1a4 0401 	sub.w	r4, r4, #1
 8027bcc:	f1d5 0e20 	rsbs	lr, r5, #32
 8027bd0:	db0d      	blt.n	8027bee <__adddf3+0xb2>
 8027bd2:	fa02 fc0e 	lsl.w	ip, r2, lr
 8027bd6:	fa22 f205 	lsr.w	r2, r2, r5
 8027bda:	1880      	adds	r0, r0, r2
 8027bdc:	f141 0100 	adc.w	r1, r1, #0
 8027be0:	fa03 f20e 	lsl.w	r2, r3, lr
 8027be4:	1880      	adds	r0, r0, r2
 8027be6:	fa43 f305 	asr.w	r3, r3, r5
 8027bea:	4159      	adcs	r1, r3
 8027bec:	e00e      	b.n	8027c0c <__adddf3+0xd0>
 8027bee:	f1a5 0520 	sub.w	r5, r5, #32
 8027bf2:	f10e 0e20 	add.w	lr, lr, #32
 8027bf6:	2a01      	cmp	r2, #1
 8027bf8:	fa03 fc0e 	lsl.w	ip, r3, lr
 8027bfc:	bf28      	it	cs
 8027bfe:	f04c 0c02 	orrcs.w	ip, ip, #2
 8027c02:	fa43 f305 	asr.w	r3, r3, r5
 8027c06:	18c0      	adds	r0, r0, r3
 8027c08:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8027c0c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8027c10:	d507      	bpl.n	8027c22 <__adddf3+0xe6>
 8027c12:	f04f 0e00 	mov.w	lr, #0
 8027c16:	f1dc 0c00 	rsbs	ip, ip, #0
 8027c1a:	eb7e 0000 	sbcs.w	r0, lr, r0
 8027c1e:	eb6e 0101 	sbc.w	r1, lr, r1
 8027c22:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8027c26:	d31b      	bcc.n	8027c60 <__adddf3+0x124>
 8027c28:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8027c2c:	d30c      	bcc.n	8027c48 <__adddf3+0x10c>
 8027c2e:	0849      	lsrs	r1, r1, #1
 8027c30:	ea5f 0030 	movs.w	r0, r0, rrx
 8027c34:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8027c38:	f104 0401 	add.w	r4, r4, #1
 8027c3c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8027c40:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8027c44:	f080 809a 	bcs.w	8027d7c <__adddf3+0x240>
 8027c48:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8027c4c:	bf08      	it	eq
 8027c4e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8027c52:	f150 0000 	adcs.w	r0, r0, #0
 8027c56:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8027c5a:	ea41 0105 	orr.w	r1, r1, r5
 8027c5e:	bd30      	pop	{r4, r5, pc}
 8027c60:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8027c64:	4140      	adcs	r0, r0
 8027c66:	eb41 0101 	adc.w	r1, r1, r1
 8027c6a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8027c6e:	f1a4 0401 	sub.w	r4, r4, #1
 8027c72:	d1e9      	bne.n	8027c48 <__adddf3+0x10c>
 8027c74:	f091 0f00 	teq	r1, #0
 8027c78:	bf04      	itt	eq
 8027c7a:	4601      	moveq	r1, r0
 8027c7c:	2000      	moveq	r0, #0
 8027c7e:	fab1 f381 	clz	r3, r1
 8027c82:	bf08      	it	eq
 8027c84:	3320      	addeq	r3, #32
 8027c86:	f1a3 030b 	sub.w	r3, r3, #11
 8027c8a:	f1b3 0220 	subs.w	r2, r3, #32
 8027c8e:	da0c      	bge.n	8027caa <__adddf3+0x16e>
 8027c90:	320c      	adds	r2, #12
 8027c92:	dd08      	ble.n	8027ca6 <__adddf3+0x16a>
 8027c94:	f102 0c14 	add.w	ip, r2, #20
 8027c98:	f1c2 020c 	rsb	r2, r2, #12
 8027c9c:	fa01 f00c 	lsl.w	r0, r1, ip
 8027ca0:	fa21 f102 	lsr.w	r1, r1, r2
 8027ca4:	e00c      	b.n	8027cc0 <__adddf3+0x184>
 8027ca6:	f102 0214 	add.w	r2, r2, #20
 8027caa:	bfd8      	it	le
 8027cac:	f1c2 0c20 	rsble	ip, r2, #32
 8027cb0:	fa01 f102 	lsl.w	r1, r1, r2
 8027cb4:	fa20 fc0c 	lsr.w	ip, r0, ip
 8027cb8:	bfdc      	itt	le
 8027cba:	ea41 010c 	orrle.w	r1, r1, ip
 8027cbe:	4090      	lslle	r0, r2
 8027cc0:	1ae4      	subs	r4, r4, r3
 8027cc2:	bfa2      	ittt	ge
 8027cc4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8027cc8:	4329      	orrge	r1, r5
 8027cca:	bd30      	popge	{r4, r5, pc}
 8027ccc:	ea6f 0404 	mvn.w	r4, r4
 8027cd0:	3c1f      	subs	r4, #31
 8027cd2:	da1c      	bge.n	8027d0e <__adddf3+0x1d2>
 8027cd4:	340c      	adds	r4, #12
 8027cd6:	dc0e      	bgt.n	8027cf6 <__adddf3+0x1ba>
 8027cd8:	f104 0414 	add.w	r4, r4, #20
 8027cdc:	f1c4 0220 	rsb	r2, r4, #32
 8027ce0:	fa20 f004 	lsr.w	r0, r0, r4
 8027ce4:	fa01 f302 	lsl.w	r3, r1, r2
 8027ce8:	ea40 0003 	orr.w	r0, r0, r3
 8027cec:	fa21 f304 	lsr.w	r3, r1, r4
 8027cf0:	ea45 0103 	orr.w	r1, r5, r3
 8027cf4:	bd30      	pop	{r4, r5, pc}
 8027cf6:	f1c4 040c 	rsb	r4, r4, #12
 8027cfa:	f1c4 0220 	rsb	r2, r4, #32
 8027cfe:	fa20 f002 	lsr.w	r0, r0, r2
 8027d02:	fa01 f304 	lsl.w	r3, r1, r4
 8027d06:	ea40 0003 	orr.w	r0, r0, r3
 8027d0a:	4629      	mov	r1, r5
 8027d0c:	bd30      	pop	{r4, r5, pc}
 8027d0e:	fa21 f004 	lsr.w	r0, r1, r4
 8027d12:	4629      	mov	r1, r5
 8027d14:	bd30      	pop	{r4, r5, pc}
 8027d16:	f094 0f00 	teq	r4, #0
 8027d1a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8027d1e:	bf06      	itte	eq
 8027d20:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8027d24:	3401      	addeq	r4, #1
 8027d26:	3d01      	subne	r5, #1
 8027d28:	e74e      	b.n	8027bc8 <__adddf3+0x8c>
 8027d2a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8027d2e:	bf18      	it	ne
 8027d30:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8027d34:	d029      	beq.n	8027d8a <__adddf3+0x24e>
 8027d36:	ea94 0f05 	teq	r4, r5
 8027d3a:	bf08      	it	eq
 8027d3c:	ea90 0f02 	teqeq	r0, r2
 8027d40:	d005      	beq.n	8027d4e <__adddf3+0x212>
 8027d42:	ea54 0c00 	orrs.w	ip, r4, r0
 8027d46:	bf04      	itt	eq
 8027d48:	4619      	moveq	r1, r3
 8027d4a:	4610      	moveq	r0, r2
 8027d4c:	bd30      	pop	{r4, r5, pc}
 8027d4e:	ea91 0f03 	teq	r1, r3
 8027d52:	bf1e      	ittt	ne
 8027d54:	2100      	movne	r1, #0
 8027d56:	2000      	movne	r0, #0
 8027d58:	bd30      	popne	{r4, r5, pc}
 8027d5a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8027d5e:	d105      	bne.n	8027d6c <__adddf3+0x230>
 8027d60:	0040      	lsls	r0, r0, #1
 8027d62:	4149      	adcs	r1, r1
 8027d64:	bf28      	it	cs
 8027d66:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8027d6a:	bd30      	pop	{r4, r5, pc}
 8027d6c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8027d70:	bf3c      	itt	cc
 8027d72:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8027d76:	bd30      	popcc	{r4, r5, pc}
 8027d78:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8027d7c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8027d80:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8027d84:	f04f 0000 	mov.w	r0, #0
 8027d88:	bd30      	pop	{r4, r5, pc}
 8027d8a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8027d8e:	bf1a      	itte	ne
 8027d90:	4619      	movne	r1, r3
 8027d92:	4610      	movne	r0, r2
 8027d94:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8027d98:	bf1c      	itt	ne
 8027d9a:	460b      	movne	r3, r1
 8027d9c:	4602      	movne	r2, r0
 8027d9e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8027da2:	bf06      	itte	eq
 8027da4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8027da8:	ea91 0f03 	teqeq	r1, r3
 8027dac:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8027db0:	bd30      	pop	{r4, r5, pc}
 8027db2:	bf00      	nop

08027db4 <__aeabi_ui2d>:
 8027db4:	f090 0f00 	teq	r0, #0
 8027db8:	bf04      	itt	eq
 8027dba:	2100      	moveq	r1, #0
 8027dbc:	4770      	bxeq	lr
 8027dbe:	b530      	push	{r4, r5, lr}
 8027dc0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8027dc4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8027dc8:	f04f 0500 	mov.w	r5, #0
 8027dcc:	f04f 0100 	mov.w	r1, #0
 8027dd0:	e750      	b.n	8027c74 <__adddf3+0x138>
 8027dd2:	bf00      	nop

08027dd4 <__aeabi_i2d>:
 8027dd4:	f090 0f00 	teq	r0, #0
 8027dd8:	bf04      	itt	eq
 8027dda:	2100      	moveq	r1, #0
 8027ddc:	4770      	bxeq	lr
 8027dde:	b530      	push	{r4, r5, lr}
 8027de0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8027de4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8027de8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 8027dec:	bf48      	it	mi
 8027dee:	4240      	negmi	r0, r0
 8027df0:	f04f 0100 	mov.w	r1, #0
 8027df4:	e73e      	b.n	8027c74 <__adddf3+0x138>
 8027df6:	bf00      	nop

08027df8 <__aeabi_f2d>:
 8027df8:	0042      	lsls	r2, r0, #1
 8027dfa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8027dfe:	ea4f 0131 	mov.w	r1, r1, rrx
 8027e02:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8027e06:	bf1f      	itttt	ne
 8027e08:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8027e0c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8027e10:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8027e14:	4770      	bxne	lr
 8027e16:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8027e1a:	bf08      	it	eq
 8027e1c:	4770      	bxeq	lr
 8027e1e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8027e22:	bf04      	itt	eq
 8027e24:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8027e28:	4770      	bxeq	lr
 8027e2a:	b530      	push	{r4, r5, lr}
 8027e2c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8027e30:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8027e34:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8027e38:	e71c      	b.n	8027c74 <__adddf3+0x138>
 8027e3a:	bf00      	nop

08027e3c <__aeabi_ul2d>:
 8027e3c:	ea50 0201 	orrs.w	r2, r0, r1
 8027e40:	bf08      	it	eq
 8027e42:	4770      	bxeq	lr
 8027e44:	b530      	push	{r4, r5, lr}
 8027e46:	f04f 0500 	mov.w	r5, #0
 8027e4a:	e00a      	b.n	8027e62 <__aeabi_l2d+0x16>

08027e4c <__aeabi_l2d>:
 8027e4c:	ea50 0201 	orrs.w	r2, r0, r1
 8027e50:	bf08      	it	eq
 8027e52:	4770      	bxeq	lr
 8027e54:	b530      	push	{r4, r5, lr}
 8027e56:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8027e5a:	d502      	bpl.n	8027e62 <__aeabi_l2d+0x16>
 8027e5c:	4240      	negs	r0, r0
 8027e5e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8027e62:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8027e66:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8027e6a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8027e6e:	f43f aed8 	beq.w	8027c22 <__adddf3+0xe6>
 8027e72:	f04f 0203 	mov.w	r2, #3
 8027e76:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8027e7a:	bf18      	it	ne
 8027e7c:	3203      	addne	r2, #3
 8027e7e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8027e82:	bf18      	it	ne
 8027e84:	3203      	addne	r2, #3
 8027e86:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8027e8a:	f1c2 0320 	rsb	r3, r2, #32
 8027e8e:	fa00 fc03 	lsl.w	ip, r0, r3
 8027e92:	fa20 f002 	lsr.w	r0, r0, r2
 8027e96:	fa01 fe03 	lsl.w	lr, r1, r3
 8027e9a:	ea40 000e 	orr.w	r0, r0, lr
 8027e9e:	fa21 f102 	lsr.w	r1, r1, r2
 8027ea2:	4414      	add	r4, r2
 8027ea4:	e6bd      	b.n	8027c22 <__adddf3+0xe6>
 8027ea6:	bf00      	nop

08027ea8 <__aeabi_dmul>:
 8027ea8:	b570      	push	{r4, r5, r6, lr}
 8027eaa:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8027eae:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8027eb2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8027eb6:	bf1d      	ittte	ne
 8027eb8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8027ebc:	ea94 0f0c 	teqne	r4, ip
 8027ec0:	ea95 0f0c 	teqne	r5, ip
 8027ec4:	f000 f8de 	bleq	8028084 <__aeabi_dmul+0x1dc>
 8027ec8:	442c      	add	r4, r5
 8027eca:	ea81 0603 	eor.w	r6, r1, r3
 8027ece:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8027ed2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8027ed6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8027eda:	bf18      	it	ne
 8027edc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8027ee0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8027ee4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8027ee8:	d038      	beq.n	8027f5c <__aeabi_dmul+0xb4>
 8027eea:	fba0 ce02 	umull	ip, lr, r0, r2
 8027eee:	f04f 0500 	mov.w	r5, #0
 8027ef2:	fbe1 e502 	umlal	lr, r5, r1, r2
 8027ef6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8027efa:	fbe0 e503 	umlal	lr, r5, r0, r3
 8027efe:	f04f 0600 	mov.w	r6, #0
 8027f02:	fbe1 5603 	umlal	r5, r6, r1, r3
 8027f06:	f09c 0f00 	teq	ip, #0
 8027f0a:	bf18      	it	ne
 8027f0c:	f04e 0e01 	orrne.w	lr, lr, #1
 8027f10:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8027f14:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8027f18:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8027f1c:	d204      	bcs.n	8027f28 <__aeabi_dmul+0x80>
 8027f1e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8027f22:	416d      	adcs	r5, r5
 8027f24:	eb46 0606 	adc.w	r6, r6, r6
 8027f28:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8027f2c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8027f30:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8027f34:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8027f38:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8027f3c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8027f40:	bf88      	it	hi
 8027f42:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8027f46:	d81e      	bhi.n	8027f86 <__aeabi_dmul+0xde>
 8027f48:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8027f4c:	bf08      	it	eq
 8027f4e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8027f52:	f150 0000 	adcs.w	r0, r0, #0
 8027f56:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8027f5a:	bd70      	pop	{r4, r5, r6, pc}
 8027f5c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8027f60:	ea46 0101 	orr.w	r1, r6, r1
 8027f64:	ea40 0002 	orr.w	r0, r0, r2
 8027f68:	ea81 0103 	eor.w	r1, r1, r3
 8027f6c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8027f70:	bfc2      	ittt	gt
 8027f72:	ebd4 050c 	rsbsgt	r5, r4, ip
 8027f76:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8027f7a:	bd70      	popgt	{r4, r5, r6, pc}
 8027f7c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8027f80:	f04f 0e00 	mov.w	lr, #0
 8027f84:	3c01      	subs	r4, #1
 8027f86:	f300 80ab 	bgt.w	80280e0 <__aeabi_dmul+0x238>
 8027f8a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8027f8e:	bfde      	ittt	le
 8027f90:	2000      	movle	r0, #0
 8027f92:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8027f96:	bd70      	pople	{r4, r5, r6, pc}
 8027f98:	f1c4 0400 	rsb	r4, r4, #0
 8027f9c:	3c20      	subs	r4, #32
 8027f9e:	da35      	bge.n	802800c <__aeabi_dmul+0x164>
 8027fa0:	340c      	adds	r4, #12
 8027fa2:	dc1b      	bgt.n	8027fdc <__aeabi_dmul+0x134>
 8027fa4:	f104 0414 	add.w	r4, r4, #20
 8027fa8:	f1c4 0520 	rsb	r5, r4, #32
 8027fac:	fa00 f305 	lsl.w	r3, r0, r5
 8027fb0:	fa20 f004 	lsr.w	r0, r0, r4
 8027fb4:	fa01 f205 	lsl.w	r2, r1, r5
 8027fb8:	ea40 0002 	orr.w	r0, r0, r2
 8027fbc:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8027fc0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8027fc4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8027fc8:	fa21 f604 	lsr.w	r6, r1, r4
 8027fcc:	eb42 0106 	adc.w	r1, r2, r6
 8027fd0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8027fd4:	bf08      	it	eq
 8027fd6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8027fda:	bd70      	pop	{r4, r5, r6, pc}
 8027fdc:	f1c4 040c 	rsb	r4, r4, #12
 8027fe0:	f1c4 0520 	rsb	r5, r4, #32
 8027fe4:	fa00 f304 	lsl.w	r3, r0, r4
 8027fe8:	fa20 f005 	lsr.w	r0, r0, r5
 8027fec:	fa01 f204 	lsl.w	r2, r1, r4
 8027ff0:	ea40 0002 	orr.w	r0, r0, r2
 8027ff4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8027ff8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8027ffc:	f141 0100 	adc.w	r1, r1, #0
 8028000:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8028004:	bf08      	it	eq
 8028006:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 802800a:	bd70      	pop	{r4, r5, r6, pc}
 802800c:	f1c4 0520 	rsb	r5, r4, #32
 8028010:	fa00 f205 	lsl.w	r2, r0, r5
 8028014:	ea4e 0e02 	orr.w	lr, lr, r2
 8028018:	fa20 f304 	lsr.w	r3, r0, r4
 802801c:	fa01 f205 	lsl.w	r2, r1, r5
 8028020:	ea43 0302 	orr.w	r3, r3, r2
 8028024:	fa21 f004 	lsr.w	r0, r1, r4
 8028028:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 802802c:	fa21 f204 	lsr.w	r2, r1, r4
 8028030:	ea20 0002 	bic.w	r0, r0, r2
 8028034:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8028038:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 802803c:	bf08      	it	eq
 802803e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8028042:	bd70      	pop	{r4, r5, r6, pc}
 8028044:	f094 0f00 	teq	r4, #0
 8028048:	d10f      	bne.n	802806a <__aeabi_dmul+0x1c2>
 802804a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 802804e:	0040      	lsls	r0, r0, #1
 8028050:	eb41 0101 	adc.w	r1, r1, r1
 8028054:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8028058:	bf08      	it	eq
 802805a:	3c01      	subeq	r4, #1
 802805c:	d0f7      	beq.n	802804e <__aeabi_dmul+0x1a6>
 802805e:	ea41 0106 	orr.w	r1, r1, r6
 8028062:	f095 0f00 	teq	r5, #0
 8028066:	bf18      	it	ne
 8028068:	4770      	bxne	lr
 802806a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 802806e:	0052      	lsls	r2, r2, #1
 8028070:	eb43 0303 	adc.w	r3, r3, r3
 8028074:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8028078:	bf08      	it	eq
 802807a:	3d01      	subeq	r5, #1
 802807c:	d0f7      	beq.n	802806e <__aeabi_dmul+0x1c6>
 802807e:	ea43 0306 	orr.w	r3, r3, r6
 8028082:	4770      	bx	lr
 8028084:	ea94 0f0c 	teq	r4, ip
 8028088:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802808c:	bf18      	it	ne
 802808e:	ea95 0f0c 	teqne	r5, ip
 8028092:	d00c      	beq.n	80280ae <__aeabi_dmul+0x206>
 8028094:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8028098:	bf18      	it	ne
 802809a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 802809e:	d1d1      	bne.n	8028044 <__aeabi_dmul+0x19c>
 80280a0:	ea81 0103 	eor.w	r1, r1, r3
 80280a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80280a8:	f04f 0000 	mov.w	r0, #0
 80280ac:	bd70      	pop	{r4, r5, r6, pc}
 80280ae:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80280b2:	bf06      	itte	eq
 80280b4:	4610      	moveq	r0, r2
 80280b6:	4619      	moveq	r1, r3
 80280b8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80280bc:	d019      	beq.n	80280f2 <__aeabi_dmul+0x24a>
 80280be:	ea94 0f0c 	teq	r4, ip
 80280c2:	d102      	bne.n	80280ca <__aeabi_dmul+0x222>
 80280c4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80280c8:	d113      	bne.n	80280f2 <__aeabi_dmul+0x24a>
 80280ca:	ea95 0f0c 	teq	r5, ip
 80280ce:	d105      	bne.n	80280dc <__aeabi_dmul+0x234>
 80280d0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80280d4:	bf1c      	itt	ne
 80280d6:	4610      	movne	r0, r2
 80280d8:	4619      	movne	r1, r3
 80280da:	d10a      	bne.n	80280f2 <__aeabi_dmul+0x24a>
 80280dc:	ea81 0103 	eor.w	r1, r1, r3
 80280e0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80280e4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80280e8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80280ec:	f04f 0000 	mov.w	r0, #0
 80280f0:	bd70      	pop	{r4, r5, r6, pc}
 80280f2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80280f6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80280fa:	bd70      	pop	{r4, r5, r6, pc}

080280fc <__aeabi_ddiv>:
 80280fc:	b570      	push	{r4, r5, r6, lr}
 80280fe:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8028102:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8028106:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 802810a:	bf1d      	ittte	ne
 802810c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8028110:	ea94 0f0c 	teqne	r4, ip
 8028114:	ea95 0f0c 	teqne	r5, ip
 8028118:	f000 f8a7 	bleq	802826a <__aeabi_ddiv+0x16e>
 802811c:	eba4 0405 	sub.w	r4, r4, r5
 8028120:	ea81 0e03 	eor.w	lr, r1, r3
 8028124:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8028128:	ea4f 3101 	mov.w	r1, r1, lsl #12
 802812c:	f000 8088 	beq.w	8028240 <__aeabi_ddiv+0x144>
 8028130:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8028134:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8028138:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 802813c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8028140:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8028144:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8028148:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 802814c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8028150:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8028154:	429d      	cmp	r5, r3
 8028156:	bf08      	it	eq
 8028158:	4296      	cmpeq	r6, r2
 802815a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 802815e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8028162:	d202      	bcs.n	802816a <__aeabi_ddiv+0x6e>
 8028164:	085b      	lsrs	r3, r3, #1
 8028166:	ea4f 0232 	mov.w	r2, r2, rrx
 802816a:	1ab6      	subs	r6, r6, r2
 802816c:	eb65 0503 	sbc.w	r5, r5, r3
 8028170:	085b      	lsrs	r3, r3, #1
 8028172:	ea4f 0232 	mov.w	r2, r2, rrx
 8028176:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 802817a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 802817e:	ebb6 0e02 	subs.w	lr, r6, r2
 8028182:	eb75 0e03 	sbcs.w	lr, r5, r3
 8028186:	bf22      	ittt	cs
 8028188:	1ab6      	subcs	r6, r6, r2
 802818a:	4675      	movcs	r5, lr
 802818c:	ea40 000c 	orrcs.w	r0, r0, ip
 8028190:	085b      	lsrs	r3, r3, #1
 8028192:	ea4f 0232 	mov.w	r2, r2, rrx
 8028196:	ebb6 0e02 	subs.w	lr, r6, r2
 802819a:	eb75 0e03 	sbcs.w	lr, r5, r3
 802819e:	bf22      	ittt	cs
 80281a0:	1ab6      	subcs	r6, r6, r2
 80281a2:	4675      	movcs	r5, lr
 80281a4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80281a8:	085b      	lsrs	r3, r3, #1
 80281aa:	ea4f 0232 	mov.w	r2, r2, rrx
 80281ae:	ebb6 0e02 	subs.w	lr, r6, r2
 80281b2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80281b6:	bf22      	ittt	cs
 80281b8:	1ab6      	subcs	r6, r6, r2
 80281ba:	4675      	movcs	r5, lr
 80281bc:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80281c0:	085b      	lsrs	r3, r3, #1
 80281c2:	ea4f 0232 	mov.w	r2, r2, rrx
 80281c6:	ebb6 0e02 	subs.w	lr, r6, r2
 80281ca:	eb75 0e03 	sbcs.w	lr, r5, r3
 80281ce:	bf22      	ittt	cs
 80281d0:	1ab6      	subcs	r6, r6, r2
 80281d2:	4675      	movcs	r5, lr
 80281d4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80281d8:	ea55 0e06 	orrs.w	lr, r5, r6
 80281dc:	d018      	beq.n	8028210 <__aeabi_ddiv+0x114>
 80281de:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80281e2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80281e6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80281ea:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80281ee:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80281f2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80281f6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80281fa:	d1c0      	bne.n	802817e <__aeabi_ddiv+0x82>
 80281fc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8028200:	d10b      	bne.n	802821a <__aeabi_ddiv+0x11e>
 8028202:	ea41 0100 	orr.w	r1, r1, r0
 8028206:	f04f 0000 	mov.w	r0, #0
 802820a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 802820e:	e7b6      	b.n	802817e <__aeabi_ddiv+0x82>
 8028210:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8028214:	bf04      	itt	eq
 8028216:	4301      	orreq	r1, r0
 8028218:	2000      	moveq	r0, #0
 802821a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 802821e:	bf88      	it	hi
 8028220:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8028224:	f63f aeaf 	bhi.w	8027f86 <__aeabi_dmul+0xde>
 8028228:	ebb5 0c03 	subs.w	ip, r5, r3
 802822c:	bf04      	itt	eq
 802822e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8028232:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8028236:	f150 0000 	adcs.w	r0, r0, #0
 802823a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 802823e:	bd70      	pop	{r4, r5, r6, pc}
 8028240:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8028244:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8028248:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 802824c:	bfc2      	ittt	gt
 802824e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8028252:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8028256:	bd70      	popgt	{r4, r5, r6, pc}
 8028258:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802825c:	f04f 0e00 	mov.w	lr, #0
 8028260:	3c01      	subs	r4, #1
 8028262:	e690      	b.n	8027f86 <__aeabi_dmul+0xde>
 8028264:	ea45 0e06 	orr.w	lr, r5, r6
 8028268:	e68d      	b.n	8027f86 <__aeabi_dmul+0xde>
 802826a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 802826e:	ea94 0f0c 	teq	r4, ip
 8028272:	bf08      	it	eq
 8028274:	ea95 0f0c 	teqeq	r5, ip
 8028278:	f43f af3b 	beq.w	80280f2 <__aeabi_dmul+0x24a>
 802827c:	ea94 0f0c 	teq	r4, ip
 8028280:	d10a      	bne.n	8028298 <__aeabi_ddiv+0x19c>
 8028282:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8028286:	f47f af34 	bne.w	80280f2 <__aeabi_dmul+0x24a>
 802828a:	ea95 0f0c 	teq	r5, ip
 802828e:	f47f af25 	bne.w	80280dc <__aeabi_dmul+0x234>
 8028292:	4610      	mov	r0, r2
 8028294:	4619      	mov	r1, r3
 8028296:	e72c      	b.n	80280f2 <__aeabi_dmul+0x24a>
 8028298:	ea95 0f0c 	teq	r5, ip
 802829c:	d106      	bne.n	80282ac <__aeabi_ddiv+0x1b0>
 802829e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80282a2:	f43f aefd 	beq.w	80280a0 <__aeabi_dmul+0x1f8>
 80282a6:	4610      	mov	r0, r2
 80282a8:	4619      	mov	r1, r3
 80282aa:	e722      	b.n	80280f2 <__aeabi_dmul+0x24a>
 80282ac:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80282b0:	bf18      	it	ne
 80282b2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80282b6:	f47f aec5 	bne.w	8028044 <__aeabi_dmul+0x19c>
 80282ba:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80282be:	f47f af0d 	bne.w	80280dc <__aeabi_dmul+0x234>
 80282c2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80282c6:	f47f aeeb 	bne.w	80280a0 <__aeabi_dmul+0x1f8>
 80282ca:	e712      	b.n	80280f2 <__aeabi_dmul+0x24a>

080282cc <__gedf2>:
 80282cc:	f04f 3cff 	mov.w	ip, #4294967295
 80282d0:	e006      	b.n	80282e0 <__cmpdf2+0x4>
 80282d2:	bf00      	nop

080282d4 <__ledf2>:
 80282d4:	f04f 0c01 	mov.w	ip, #1
 80282d8:	e002      	b.n	80282e0 <__cmpdf2+0x4>
 80282da:	bf00      	nop

080282dc <__cmpdf2>:
 80282dc:	f04f 0c01 	mov.w	ip, #1
 80282e0:	f84d cd04 	str.w	ip, [sp, #-4]!
 80282e4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80282e8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80282ec:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80282f0:	bf18      	it	ne
 80282f2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80282f6:	d01b      	beq.n	8028330 <__cmpdf2+0x54>
 80282f8:	b001      	add	sp, #4
 80282fa:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80282fe:	bf0c      	ite	eq
 8028300:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8028304:	ea91 0f03 	teqne	r1, r3
 8028308:	bf02      	ittt	eq
 802830a:	ea90 0f02 	teqeq	r0, r2
 802830e:	2000      	moveq	r0, #0
 8028310:	4770      	bxeq	lr
 8028312:	f110 0f00 	cmn.w	r0, #0
 8028316:	ea91 0f03 	teq	r1, r3
 802831a:	bf58      	it	pl
 802831c:	4299      	cmppl	r1, r3
 802831e:	bf08      	it	eq
 8028320:	4290      	cmpeq	r0, r2
 8028322:	bf2c      	ite	cs
 8028324:	17d8      	asrcs	r0, r3, #31
 8028326:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 802832a:	f040 0001 	orr.w	r0, r0, #1
 802832e:	4770      	bx	lr
 8028330:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8028334:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8028338:	d102      	bne.n	8028340 <__cmpdf2+0x64>
 802833a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 802833e:	d107      	bne.n	8028350 <__cmpdf2+0x74>
 8028340:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8028344:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8028348:	d1d6      	bne.n	80282f8 <__cmpdf2+0x1c>
 802834a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 802834e:	d0d3      	beq.n	80282f8 <__cmpdf2+0x1c>
 8028350:	f85d 0b04 	ldr.w	r0, [sp], #4
 8028354:	4770      	bx	lr
 8028356:	bf00      	nop

08028358 <__aeabi_cdrcmple>:
 8028358:	4684      	mov	ip, r0
 802835a:	4610      	mov	r0, r2
 802835c:	4662      	mov	r2, ip
 802835e:	468c      	mov	ip, r1
 8028360:	4619      	mov	r1, r3
 8028362:	4663      	mov	r3, ip
 8028364:	e000      	b.n	8028368 <__aeabi_cdcmpeq>
 8028366:	bf00      	nop

08028368 <__aeabi_cdcmpeq>:
 8028368:	b501      	push	{r0, lr}
 802836a:	f7ff ffb7 	bl	80282dc <__cmpdf2>
 802836e:	2800      	cmp	r0, #0
 8028370:	bf48      	it	mi
 8028372:	f110 0f00 	cmnmi.w	r0, #0
 8028376:	bd01      	pop	{r0, pc}

08028378 <__aeabi_dcmpeq>:
 8028378:	f84d ed08 	str.w	lr, [sp, #-8]!
 802837c:	f7ff fff4 	bl	8028368 <__aeabi_cdcmpeq>
 8028380:	bf0c      	ite	eq
 8028382:	2001      	moveq	r0, #1
 8028384:	2000      	movne	r0, #0
 8028386:	f85d fb08 	ldr.w	pc, [sp], #8
 802838a:	bf00      	nop

0802838c <__aeabi_dcmplt>:
 802838c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8028390:	f7ff ffea 	bl	8028368 <__aeabi_cdcmpeq>
 8028394:	bf34      	ite	cc
 8028396:	2001      	movcc	r0, #1
 8028398:	2000      	movcs	r0, #0
 802839a:	f85d fb08 	ldr.w	pc, [sp], #8
 802839e:	bf00      	nop

080283a0 <__aeabi_dcmple>:
 80283a0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80283a4:	f7ff ffe0 	bl	8028368 <__aeabi_cdcmpeq>
 80283a8:	bf94      	ite	ls
 80283aa:	2001      	movls	r0, #1
 80283ac:	2000      	movhi	r0, #0
 80283ae:	f85d fb08 	ldr.w	pc, [sp], #8
 80283b2:	bf00      	nop

080283b4 <__aeabi_dcmpge>:
 80283b4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80283b8:	f7ff ffce 	bl	8028358 <__aeabi_cdrcmple>
 80283bc:	bf94      	ite	ls
 80283be:	2001      	movls	r0, #1
 80283c0:	2000      	movhi	r0, #0
 80283c2:	f85d fb08 	ldr.w	pc, [sp], #8
 80283c6:	bf00      	nop

080283c8 <__aeabi_dcmpgt>:
 80283c8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80283cc:	f7ff ffc4 	bl	8028358 <__aeabi_cdrcmple>
 80283d0:	bf34      	ite	cc
 80283d2:	2001      	movcc	r0, #1
 80283d4:	2000      	movcs	r0, #0
 80283d6:	f85d fb08 	ldr.w	pc, [sp], #8
 80283da:	bf00      	nop

080283dc <__aeabi_dcmpun>:
 80283dc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80283e0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80283e4:	d102      	bne.n	80283ec <__aeabi_dcmpun+0x10>
 80283e6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80283ea:	d10a      	bne.n	8028402 <__aeabi_dcmpun+0x26>
 80283ec:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80283f0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80283f4:	d102      	bne.n	80283fc <__aeabi_dcmpun+0x20>
 80283f6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80283fa:	d102      	bne.n	8028402 <__aeabi_dcmpun+0x26>
 80283fc:	f04f 0000 	mov.w	r0, #0
 8028400:	4770      	bx	lr
 8028402:	f04f 0001 	mov.w	r0, #1
 8028406:	4770      	bx	lr

08028408 <__aeabi_d2f>:
 8028408:	ea4f 0241 	mov.w	r2, r1, lsl #1
 802840c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8028410:	bf24      	itt	cs
 8028412:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8028416:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 802841a:	d90d      	bls.n	8028438 <__aeabi_d2f+0x30>
 802841c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8028420:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8028424:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8028428:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 802842c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8028430:	bf08      	it	eq
 8028432:	f020 0001 	biceq.w	r0, r0, #1
 8028436:	4770      	bx	lr
 8028438:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 802843c:	d121      	bne.n	8028482 <__aeabi_d2f+0x7a>
 802843e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8028442:	bfbc      	itt	lt
 8028444:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8028448:	4770      	bxlt	lr
 802844a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 802844e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8028452:	f1c2 0218 	rsb	r2, r2, #24
 8028456:	f1c2 0c20 	rsb	ip, r2, #32
 802845a:	fa10 f30c 	lsls.w	r3, r0, ip
 802845e:	fa20 f002 	lsr.w	r0, r0, r2
 8028462:	bf18      	it	ne
 8028464:	f040 0001 	orrne.w	r0, r0, #1
 8028468:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 802846c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8028470:	fa03 fc0c 	lsl.w	ip, r3, ip
 8028474:	ea40 000c 	orr.w	r0, r0, ip
 8028478:	fa23 f302 	lsr.w	r3, r3, r2
 802847c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8028480:	e7cc      	b.n	802841c <__aeabi_d2f+0x14>
 8028482:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8028486:	d107      	bne.n	8028498 <__aeabi_d2f+0x90>
 8028488:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 802848c:	bf1e      	ittt	ne
 802848e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8028492:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8028496:	4770      	bxne	lr
 8028498:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 802849c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80284a0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80284a4:	4770      	bx	lr
 80284a6:	bf00      	nop

080284a8 <__aeabi_uldivmod>:
 80284a8:	b953      	cbnz	r3, 80284c0 <__aeabi_uldivmod+0x18>
 80284aa:	b94a      	cbnz	r2, 80284c0 <__aeabi_uldivmod+0x18>
 80284ac:	2900      	cmp	r1, #0
 80284ae:	bf08      	it	eq
 80284b0:	2800      	cmpeq	r0, #0
 80284b2:	bf1c      	itt	ne
 80284b4:	f04f 31ff 	movne.w	r1, #4294967295
 80284b8:	f04f 30ff 	movne.w	r0, #4294967295
 80284bc:	f000 b972 	b.w	80287a4 <__aeabi_idiv0>
 80284c0:	f1ad 0c08 	sub.w	ip, sp, #8
 80284c4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80284c8:	f000 f806 	bl	80284d8 <__udivmoddi4>
 80284cc:	f8dd e004 	ldr.w	lr, [sp, #4]
 80284d0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80284d4:	b004      	add	sp, #16
 80284d6:	4770      	bx	lr

080284d8 <__udivmoddi4>:
 80284d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80284dc:	9e08      	ldr	r6, [sp, #32]
 80284de:	4604      	mov	r4, r0
 80284e0:	4688      	mov	r8, r1
 80284e2:	2b00      	cmp	r3, #0
 80284e4:	d14b      	bne.n	802857e <__udivmoddi4+0xa6>
 80284e6:	428a      	cmp	r2, r1
 80284e8:	4615      	mov	r5, r2
 80284ea:	d967      	bls.n	80285bc <__udivmoddi4+0xe4>
 80284ec:	fab2 f282 	clz	r2, r2
 80284f0:	b14a      	cbz	r2, 8028506 <__udivmoddi4+0x2e>
 80284f2:	f1c2 0720 	rsb	r7, r2, #32
 80284f6:	fa01 f302 	lsl.w	r3, r1, r2
 80284fa:	fa20 f707 	lsr.w	r7, r0, r7
 80284fe:	4095      	lsls	r5, r2
 8028500:	ea47 0803 	orr.w	r8, r7, r3
 8028504:	4094      	lsls	r4, r2
 8028506:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 802850a:	0c23      	lsrs	r3, r4, #16
 802850c:	fbb8 f7fe 	udiv	r7, r8, lr
 8028510:	fa1f fc85 	uxth.w	ip, r5
 8028514:	fb0e 8817 	mls	r8, lr, r7, r8
 8028518:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 802851c:	fb07 f10c 	mul.w	r1, r7, ip
 8028520:	4299      	cmp	r1, r3
 8028522:	d909      	bls.n	8028538 <__udivmoddi4+0x60>
 8028524:	18eb      	adds	r3, r5, r3
 8028526:	f107 30ff 	add.w	r0, r7, #4294967295
 802852a:	f080 811b 	bcs.w	8028764 <__udivmoddi4+0x28c>
 802852e:	4299      	cmp	r1, r3
 8028530:	f240 8118 	bls.w	8028764 <__udivmoddi4+0x28c>
 8028534:	3f02      	subs	r7, #2
 8028536:	442b      	add	r3, r5
 8028538:	1a5b      	subs	r3, r3, r1
 802853a:	b2a4      	uxth	r4, r4
 802853c:	fbb3 f0fe 	udiv	r0, r3, lr
 8028540:	fb0e 3310 	mls	r3, lr, r0, r3
 8028544:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8028548:	fb00 fc0c 	mul.w	ip, r0, ip
 802854c:	45a4      	cmp	ip, r4
 802854e:	d909      	bls.n	8028564 <__udivmoddi4+0x8c>
 8028550:	192c      	adds	r4, r5, r4
 8028552:	f100 33ff 	add.w	r3, r0, #4294967295
 8028556:	f080 8107 	bcs.w	8028768 <__udivmoddi4+0x290>
 802855a:	45a4      	cmp	ip, r4
 802855c:	f240 8104 	bls.w	8028768 <__udivmoddi4+0x290>
 8028560:	3802      	subs	r0, #2
 8028562:	442c      	add	r4, r5
 8028564:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8028568:	eba4 040c 	sub.w	r4, r4, ip
 802856c:	2700      	movs	r7, #0
 802856e:	b11e      	cbz	r6, 8028578 <__udivmoddi4+0xa0>
 8028570:	40d4      	lsrs	r4, r2
 8028572:	2300      	movs	r3, #0
 8028574:	e9c6 4300 	strd	r4, r3, [r6]
 8028578:	4639      	mov	r1, r7
 802857a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802857e:	428b      	cmp	r3, r1
 8028580:	d909      	bls.n	8028596 <__udivmoddi4+0xbe>
 8028582:	2e00      	cmp	r6, #0
 8028584:	f000 80eb 	beq.w	802875e <__udivmoddi4+0x286>
 8028588:	2700      	movs	r7, #0
 802858a:	e9c6 0100 	strd	r0, r1, [r6]
 802858e:	4638      	mov	r0, r7
 8028590:	4639      	mov	r1, r7
 8028592:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8028596:	fab3 f783 	clz	r7, r3
 802859a:	2f00      	cmp	r7, #0
 802859c:	d147      	bne.n	802862e <__udivmoddi4+0x156>
 802859e:	428b      	cmp	r3, r1
 80285a0:	d302      	bcc.n	80285a8 <__udivmoddi4+0xd0>
 80285a2:	4282      	cmp	r2, r0
 80285a4:	f200 80fa 	bhi.w	802879c <__udivmoddi4+0x2c4>
 80285a8:	1a84      	subs	r4, r0, r2
 80285aa:	eb61 0303 	sbc.w	r3, r1, r3
 80285ae:	2001      	movs	r0, #1
 80285b0:	4698      	mov	r8, r3
 80285b2:	2e00      	cmp	r6, #0
 80285b4:	d0e0      	beq.n	8028578 <__udivmoddi4+0xa0>
 80285b6:	e9c6 4800 	strd	r4, r8, [r6]
 80285ba:	e7dd      	b.n	8028578 <__udivmoddi4+0xa0>
 80285bc:	b902      	cbnz	r2, 80285c0 <__udivmoddi4+0xe8>
 80285be:	deff      	udf	#255	; 0xff
 80285c0:	fab2 f282 	clz	r2, r2
 80285c4:	2a00      	cmp	r2, #0
 80285c6:	f040 808f 	bne.w	80286e8 <__udivmoddi4+0x210>
 80285ca:	1b49      	subs	r1, r1, r5
 80285cc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80285d0:	fa1f f885 	uxth.w	r8, r5
 80285d4:	2701      	movs	r7, #1
 80285d6:	fbb1 fcfe 	udiv	ip, r1, lr
 80285da:	0c23      	lsrs	r3, r4, #16
 80285dc:	fb0e 111c 	mls	r1, lr, ip, r1
 80285e0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80285e4:	fb08 f10c 	mul.w	r1, r8, ip
 80285e8:	4299      	cmp	r1, r3
 80285ea:	d907      	bls.n	80285fc <__udivmoddi4+0x124>
 80285ec:	18eb      	adds	r3, r5, r3
 80285ee:	f10c 30ff 	add.w	r0, ip, #4294967295
 80285f2:	d202      	bcs.n	80285fa <__udivmoddi4+0x122>
 80285f4:	4299      	cmp	r1, r3
 80285f6:	f200 80cd 	bhi.w	8028794 <__udivmoddi4+0x2bc>
 80285fa:	4684      	mov	ip, r0
 80285fc:	1a59      	subs	r1, r3, r1
 80285fe:	b2a3      	uxth	r3, r4
 8028600:	fbb1 f0fe 	udiv	r0, r1, lr
 8028604:	fb0e 1410 	mls	r4, lr, r0, r1
 8028608:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 802860c:	fb08 f800 	mul.w	r8, r8, r0
 8028610:	45a0      	cmp	r8, r4
 8028612:	d907      	bls.n	8028624 <__udivmoddi4+0x14c>
 8028614:	192c      	adds	r4, r5, r4
 8028616:	f100 33ff 	add.w	r3, r0, #4294967295
 802861a:	d202      	bcs.n	8028622 <__udivmoddi4+0x14a>
 802861c:	45a0      	cmp	r8, r4
 802861e:	f200 80b6 	bhi.w	802878e <__udivmoddi4+0x2b6>
 8028622:	4618      	mov	r0, r3
 8028624:	eba4 0408 	sub.w	r4, r4, r8
 8028628:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 802862c:	e79f      	b.n	802856e <__udivmoddi4+0x96>
 802862e:	f1c7 0c20 	rsb	ip, r7, #32
 8028632:	40bb      	lsls	r3, r7
 8028634:	fa22 fe0c 	lsr.w	lr, r2, ip
 8028638:	ea4e 0e03 	orr.w	lr, lr, r3
 802863c:	fa01 f407 	lsl.w	r4, r1, r7
 8028640:	fa20 f50c 	lsr.w	r5, r0, ip
 8028644:	fa21 f30c 	lsr.w	r3, r1, ip
 8028648:	ea4f 481e 	mov.w	r8, lr, lsr #16
 802864c:	4325      	orrs	r5, r4
 802864e:	fbb3 f9f8 	udiv	r9, r3, r8
 8028652:	0c2c      	lsrs	r4, r5, #16
 8028654:	fb08 3319 	mls	r3, r8, r9, r3
 8028658:	fa1f fa8e 	uxth.w	sl, lr
 802865c:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8028660:	fb09 f40a 	mul.w	r4, r9, sl
 8028664:	429c      	cmp	r4, r3
 8028666:	fa02 f207 	lsl.w	r2, r2, r7
 802866a:	fa00 f107 	lsl.w	r1, r0, r7
 802866e:	d90b      	bls.n	8028688 <__udivmoddi4+0x1b0>
 8028670:	eb1e 0303 	adds.w	r3, lr, r3
 8028674:	f109 30ff 	add.w	r0, r9, #4294967295
 8028678:	f080 8087 	bcs.w	802878a <__udivmoddi4+0x2b2>
 802867c:	429c      	cmp	r4, r3
 802867e:	f240 8084 	bls.w	802878a <__udivmoddi4+0x2b2>
 8028682:	f1a9 0902 	sub.w	r9, r9, #2
 8028686:	4473      	add	r3, lr
 8028688:	1b1b      	subs	r3, r3, r4
 802868a:	b2ad      	uxth	r5, r5
 802868c:	fbb3 f0f8 	udiv	r0, r3, r8
 8028690:	fb08 3310 	mls	r3, r8, r0, r3
 8028694:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8028698:	fb00 fa0a 	mul.w	sl, r0, sl
 802869c:	45a2      	cmp	sl, r4
 802869e:	d908      	bls.n	80286b2 <__udivmoddi4+0x1da>
 80286a0:	eb1e 0404 	adds.w	r4, lr, r4
 80286a4:	f100 33ff 	add.w	r3, r0, #4294967295
 80286a8:	d26b      	bcs.n	8028782 <__udivmoddi4+0x2aa>
 80286aa:	45a2      	cmp	sl, r4
 80286ac:	d969      	bls.n	8028782 <__udivmoddi4+0x2aa>
 80286ae:	3802      	subs	r0, #2
 80286b0:	4474      	add	r4, lr
 80286b2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80286b6:	fba0 8902 	umull	r8, r9, r0, r2
 80286ba:	eba4 040a 	sub.w	r4, r4, sl
 80286be:	454c      	cmp	r4, r9
 80286c0:	46c2      	mov	sl, r8
 80286c2:	464b      	mov	r3, r9
 80286c4:	d354      	bcc.n	8028770 <__udivmoddi4+0x298>
 80286c6:	d051      	beq.n	802876c <__udivmoddi4+0x294>
 80286c8:	2e00      	cmp	r6, #0
 80286ca:	d069      	beq.n	80287a0 <__udivmoddi4+0x2c8>
 80286cc:	ebb1 050a 	subs.w	r5, r1, sl
 80286d0:	eb64 0403 	sbc.w	r4, r4, r3
 80286d4:	fa04 fc0c 	lsl.w	ip, r4, ip
 80286d8:	40fd      	lsrs	r5, r7
 80286da:	40fc      	lsrs	r4, r7
 80286dc:	ea4c 0505 	orr.w	r5, ip, r5
 80286e0:	e9c6 5400 	strd	r5, r4, [r6]
 80286e4:	2700      	movs	r7, #0
 80286e6:	e747      	b.n	8028578 <__udivmoddi4+0xa0>
 80286e8:	f1c2 0320 	rsb	r3, r2, #32
 80286ec:	fa20 f703 	lsr.w	r7, r0, r3
 80286f0:	4095      	lsls	r5, r2
 80286f2:	fa01 f002 	lsl.w	r0, r1, r2
 80286f6:	fa21 f303 	lsr.w	r3, r1, r3
 80286fa:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80286fe:	4338      	orrs	r0, r7
 8028700:	0c01      	lsrs	r1, r0, #16
 8028702:	fbb3 f7fe 	udiv	r7, r3, lr
 8028706:	fa1f f885 	uxth.w	r8, r5
 802870a:	fb0e 3317 	mls	r3, lr, r7, r3
 802870e:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8028712:	fb07 f308 	mul.w	r3, r7, r8
 8028716:	428b      	cmp	r3, r1
 8028718:	fa04 f402 	lsl.w	r4, r4, r2
 802871c:	d907      	bls.n	802872e <__udivmoddi4+0x256>
 802871e:	1869      	adds	r1, r5, r1
 8028720:	f107 3cff 	add.w	ip, r7, #4294967295
 8028724:	d22f      	bcs.n	8028786 <__udivmoddi4+0x2ae>
 8028726:	428b      	cmp	r3, r1
 8028728:	d92d      	bls.n	8028786 <__udivmoddi4+0x2ae>
 802872a:	3f02      	subs	r7, #2
 802872c:	4429      	add	r1, r5
 802872e:	1acb      	subs	r3, r1, r3
 8028730:	b281      	uxth	r1, r0
 8028732:	fbb3 f0fe 	udiv	r0, r3, lr
 8028736:	fb0e 3310 	mls	r3, lr, r0, r3
 802873a:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 802873e:	fb00 f308 	mul.w	r3, r0, r8
 8028742:	428b      	cmp	r3, r1
 8028744:	d907      	bls.n	8028756 <__udivmoddi4+0x27e>
 8028746:	1869      	adds	r1, r5, r1
 8028748:	f100 3cff 	add.w	ip, r0, #4294967295
 802874c:	d217      	bcs.n	802877e <__udivmoddi4+0x2a6>
 802874e:	428b      	cmp	r3, r1
 8028750:	d915      	bls.n	802877e <__udivmoddi4+0x2a6>
 8028752:	3802      	subs	r0, #2
 8028754:	4429      	add	r1, r5
 8028756:	1ac9      	subs	r1, r1, r3
 8028758:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 802875c:	e73b      	b.n	80285d6 <__udivmoddi4+0xfe>
 802875e:	4637      	mov	r7, r6
 8028760:	4630      	mov	r0, r6
 8028762:	e709      	b.n	8028578 <__udivmoddi4+0xa0>
 8028764:	4607      	mov	r7, r0
 8028766:	e6e7      	b.n	8028538 <__udivmoddi4+0x60>
 8028768:	4618      	mov	r0, r3
 802876a:	e6fb      	b.n	8028564 <__udivmoddi4+0x8c>
 802876c:	4541      	cmp	r1, r8
 802876e:	d2ab      	bcs.n	80286c8 <__udivmoddi4+0x1f0>
 8028770:	ebb8 0a02 	subs.w	sl, r8, r2
 8028774:	eb69 020e 	sbc.w	r2, r9, lr
 8028778:	3801      	subs	r0, #1
 802877a:	4613      	mov	r3, r2
 802877c:	e7a4      	b.n	80286c8 <__udivmoddi4+0x1f0>
 802877e:	4660      	mov	r0, ip
 8028780:	e7e9      	b.n	8028756 <__udivmoddi4+0x27e>
 8028782:	4618      	mov	r0, r3
 8028784:	e795      	b.n	80286b2 <__udivmoddi4+0x1da>
 8028786:	4667      	mov	r7, ip
 8028788:	e7d1      	b.n	802872e <__udivmoddi4+0x256>
 802878a:	4681      	mov	r9, r0
 802878c:	e77c      	b.n	8028688 <__udivmoddi4+0x1b0>
 802878e:	3802      	subs	r0, #2
 8028790:	442c      	add	r4, r5
 8028792:	e747      	b.n	8028624 <__udivmoddi4+0x14c>
 8028794:	f1ac 0c02 	sub.w	ip, ip, #2
 8028798:	442b      	add	r3, r5
 802879a:	e72f      	b.n	80285fc <__udivmoddi4+0x124>
 802879c:	4638      	mov	r0, r7
 802879e:	e708      	b.n	80285b2 <__udivmoddi4+0xda>
 80287a0:	4637      	mov	r7, r6
 80287a2:	e6e9      	b.n	8028578 <__udivmoddi4+0xa0>

080287a4 <__aeabi_idiv0>:
 80287a4:	4770      	bx	lr
 80287a6:	bf00      	nop

080287a8 <Init_3by3_Matrix>:
#include "gsl/gsl_blas.h"

gsl_matrix *TKom;	// Gyro nonorthogonality*scale factor matrix

void Init_3by3_Matrix(gsl_matrix *A, float init_values[3][3])
{
 80287a8:	b5b0      	push	{r4, r5, r7, lr}
 80287aa:	b084      	sub	sp, #16
 80287ac:	af00      	add	r7, sp, #0
 80287ae:	6078      	str	r0, [r7, #4]
 80287b0:	6039      	str	r1, [r7, #0]
	int i, j;

	for (i = 0; i < 3; i++)
 80287b2:	2300      	movs	r3, #0
 80287b4:	60fb      	str	r3, [r7, #12]
 80287b6:	e025      	b.n	8028804 <Init_3by3_Matrix+0x5c>
	{
		for (j = 0; j < 3; j++)
 80287b8:	2300      	movs	r3, #0
 80287ba:	60bb      	str	r3, [r7, #8]
 80287bc:	e01c      	b.n	80287f8 <Init_3by3_Matrix+0x50>
		{
			gsl_matrix_set(A, i, j, init_values[i][j]);
 80287be:	68fc      	ldr	r4, [r7, #12]
 80287c0:	68bd      	ldr	r5, [r7, #8]
 80287c2:	68fa      	ldr	r2, [r7, #12]
 80287c4:	4613      	mov	r3, r2
 80287c6:	005b      	lsls	r3, r3, #1
 80287c8:	4413      	add	r3, r2
 80287ca:	009b      	lsls	r3, r3, #2
 80287cc:	461a      	mov	r2, r3
 80287ce:	683b      	ldr	r3, [r7, #0]
 80287d0:	441a      	add	r2, r3
 80287d2:	68bb      	ldr	r3, [r7, #8]
 80287d4:	009b      	lsls	r3, r3, #2
 80287d6:	4413      	add	r3, r2
 80287d8:	681b      	ldr	r3, [r3, #0]
 80287da:	4618      	mov	r0, r3
 80287dc:	f7ff fb0c 	bl	8027df8 <__aeabi_f2d>
 80287e0:	4602      	mov	r2, r0
 80287e2:	460b      	mov	r3, r1
 80287e4:	ec43 2b10 	vmov	d0, r2, r3
 80287e8:	462a      	mov	r2, r5
 80287ea:	4621      	mov	r1, r4
 80287ec:	6878      	ldr	r0, [r7, #4]
 80287ee:	f7dc fdbf 	bl	8005370 <gsl_matrix_set>
		for (j = 0; j < 3; j++)
 80287f2:	68bb      	ldr	r3, [r7, #8]
 80287f4:	3301      	adds	r3, #1
 80287f6:	60bb      	str	r3, [r7, #8]
 80287f8:	68bb      	ldr	r3, [r7, #8]
 80287fa:	2b02      	cmp	r3, #2
 80287fc:	dddf      	ble.n	80287be <Init_3by3_Matrix+0x16>
	for (i = 0; i < 3; i++)
 80287fe:	68fb      	ldr	r3, [r7, #12]
 8028800:	3301      	adds	r3, #1
 8028802:	60fb      	str	r3, [r7, #12]
 8028804:	68fb      	ldr	r3, [r7, #12]
 8028806:	2b02      	cmp	r3, #2
 8028808:	ddd6      	ble.n	80287b8 <Init_3by3_Matrix+0x10>
		}
	}
}
 802880a:	bf00      	nop
 802880c:	3710      	adds	r7, #16
 802880e:	46bd      	mov	sp, r7
 8028810:	bdb0      	pop	{r4, r5, r7, pc}
 8028812:	0000      	movs	r0, r0
 8028814:	0000      	movs	r0, r0
	...

08028818 <CalibrationSetup>:

void CalibrationSetup()		// Set up calibration parameter matrices
{
 8028818:	b580      	push	{r7, lr}
 802881a:	b084      	sub	sp, #16
 802881c:	af02      	add	r7, sp, #8
	gsl_matrix *Kom = gsl_matrix_alloc(3, 3);	// Gyro scale factor matrix
 802881e:	2103      	movs	r1, #3
 8028820:	2003      	movs	r0, #3
 8028822:	f7da fdf7 	bl	8003414 <gsl_matrix_alloc>
 8028826:	6078      	str	r0, [r7, #4]
	gsl_matrix *Tom = gsl_matrix_alloc(3, 3);	// Gyro nonorthogonality matrix
 8028828:	2103      	movs	r1, #3
 802882a:	2003      	movs	r0, #3
 802882c:	f7da fdf2 	bl	8003414 <gsl_matrix_alloc>
 8028830:	6038      	str	r0, [r7, #0]
	TKom = gsl_matrix_alloc(3, 3);				// Product of scale factor and nonorthogonality matrices
 8028832:	2103      	movs	r1, #3
 8028834:	2003      	movs	r0, #3
 8028836:	f7da fded 	bl	8003414 <gsl_matrix_alloc>
 802883a:	4602      	mov	r2, r0
 802883c:	4b12      	ldr	r3, [pc, #72]	; (8028888 <CalibrationSetup+0x70>)
 802883e:	601a      	str	r2, [r3, #0]

	Init_3by3_Matrix(Kom, Kom_init);			// Populate scale factor and nonorthogonality matrices
 8028840:	4912      	ldr	r1, [pc, #72]	; (802888c <CalibrationSetup+0x74>)
 8028842:	6878      	ldr	r0, [r7, #4]
 8028844:	f7ff ffb0 	bl	80287a8 <Init_3by3_Matrix>
	Init_3by3_Matrix(Tom, Tom_init);
 8028848:	4911      	ldr	r1, [pc, #68]	; (8028890 <CalibrationSetup+0x78>)
 802884a:	6838      	ldr	r0, [r7, #0]
 802884c:	f7ff ffac 	bl	80287a8 <Init_3by3_Matrix>
	gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, Tom, Kom, 0.0, TKom);			// Compute product of T and K
 8028850:	4b0d      	ldr	r3, [pc, #52]	; (8028888 <CalibrationSetup+0x70>)
 8028852:	681b      	ldr	r3, [r3, #0]
 8028854:	9300      	str	r3, [sp, #0]
 8028856:	ed9f 1b08 	vldr	d1, [pc, #32]	; 8028878 <CalibrationSetup+0x60>
 802885a:	687b      	ldr	r3, [r7, #4]
 802885c:	683a      	ldr	r2, [r7, #0]
 802885e:	ed9f 0b08 	vldr	d0, [pc, #32]	; 8028880 <CalibrationSetup+0x68>
 8028862:	216f      	movs	r1, #111	; 0x6f
 8028864:	206f      	movs	r0, #111	; 0x6f
 8028866:	f7d8 ff55 	bl	8001714 <gsl_blas_dgemm>

	return;
 802886a:	bf00      	nop
}
 802886c:	3708      	adds	r7, #8
 802886e:	46bd      	mov	sp, r7
 8028870:	bd80      	pop	{r7, pc}
 8028872:	bf00      	nop
 8028874:	f3af 8000 	nop.w
	...
 8028884:	3ff00000 	.word	0x3ff00000
 8028888:	20001514 	.word	0x20001514
 802888c:	20000034 	.word	0x20000034
 8028890:	20000058 	.word	0x20000058

08028894 <PolyVal>:

float PolyVal(float x, float poly[4])		// Evaluate polynomial using Horner's Method
{
 8028894:	b480      	push	{r7}
 8028896:	b083      	sub	sp, #12
 8028898:	af00      	add	r7, sp, #0
 802889a:	ed87 0a01 	vstr	s0, [r7, #4]
 802889e:	6038      	str	r0, [r7, #0]
	return poly[0] + x*(poly[1] + x*(poly[2] + x*poly[3]));
 80288a0:	683b      	ldr	r3, [r7, #0]
 80288a2:	ed93 7a00 	vldr	s14, [r3]
 80288a6:	683b      	ldr	r3, [r7, #0]
 80288a8:	3304      	adds	r3, #4
 80288aa:	edd3 6a00 	vldr	s13, [r3]
 80288ae:	683b      	ldr	r3, [r7, #0]
 80288b0:	3308      	adds	r3, #8
 80288b2:	ed93 6a00 	vldr	s12, [r3]
 80288b6:	683b      	ldr	r3, [r7, #0]
 80288b8:	330c      	adds	r3, #12
 80288ba:	edd3 5a00 	vldr	s11, [r3]
 80288be:	edd7 7a01 	vldr	s15, [r7, #4]
 80288c2:	ee65 7aa7 	vmul.f32	s15, s11, s15
 80288c6:	ee36 6a27 	vadd.f32	s12, s12, s15
 80288ca:	edd7 7a01 	vldr	s15, [r7, #4]
 80288ce:	ee66 7a27 	vmul.f32	s15, s12, s15
 80288d2:	ee76 6aa7 	vadd.f32	s13, s13, s15
 80288d6:	edd7 7a01 	vldr	s15, [r7, #4]
 80288da:	ee66 7aa7 	vmul.f32	s15, s13, s15
 80288de:	ee77 7a27 	vadd.f32	s15, s14, s15
}
 80288e2:	eeb0 0a67 	vmov.f32	s0, s15
 80288e6:	370c      	adds	r7, #12
 80288e8:	46bd      	mov	sp, r7
 80288ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80288ee:	4770      	bx	lr

080288f0 <Calibrate>:

void Calibrate(struct RxBuffer *rawData, struct CalibBuffer *calibData, int I[nIMUs], int csCount)
{
 80288f0:	b5b0      	push	{r4, r5, r7, lr}
 80288f2:	b09c      	sub	sp, #112	; 0x70
 80288f4:	af00      	add	r7, sp, #0
 80288f6:	60f8      	str	r0, [r7, #12]
 80288f8:	60b9      	str	r1, [r7, #8]
 80288fa:	607a      	str	r2, [r7, #4]
 80288fc:	603b      	str	r3, [r7, #0]
	double omLin[3];
	double omCalib[3] = {0.0};
 80288fe:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8028902:	2200      	movs	r2, #0
 8028904:	601a      	str	r2, [r3, #0]
 8028906:	605a      	str	r2, [r3, #4]
 8028908:	609a      	str	r2, [r3, #8]
 802890a:	60da      	str	r2, [r3, #12]
 802890c:	611a      	str	r2, [r3, #16]
 802890e:	615a      	str	r2, [r3, #20]
	int buffIndex = I[csCount] == 0 ? RX_BUFFER_SIZE - 1 : I[csCount] - 1; // Check if buffer index has rolled over. If yes, use BUFFER_SIZE - 1 as the index.
 8028910:	683b      	ldr	r3, [r7, #0]
 8028912:	009b      	lsls	r3, r3, #2
 8028914:	687a      	ldr	r2, [r7, #4]
 8028916:	4413      	add	r3, r2
 8028918:	681b      	ldr	r3, [r3, #0]
 802891a:	2b00      	cmp	r3, #0
 802891c:	d006      	beq.n	802892c <Calibrate+0x3c>
 802891e:	683b      	ldr	r3, [r7, #0]
 8028920:	009b      	lsls	r3, r3, #2
 8028922:	687a      	ldr	r2, [r7, #4]
 8028924:	4413      	add	r3, r2
 8028926:	681b      	ldr	r3, [r3, #0]
 8028928:	3b01      	subs	r3, #1
 802892a:	e000      	b.n	802892e <Calibrate+0x3e>
 802892c:	2363      	movs	r3, #99	; 0x63
 802892e:	66fb      	str	r3, [r7, #108]	; 0x6c

	if (csCount == 5)
 8028930:	683b      	ldr	r3, [r7, #0]
 8028932:	2b05      	cmp	r3, #5
 8028934:	d100      	bne.n	8028938 <Calibrate+0x48>
		__NOP();
 8028936:	bf00      	nop

	// Apply nonlinearity correction to gyro measurements
	omLin[0] = (double)PolyVal((float)rawData[csCount].RxBuffer_OMX[buffIndex], &pnlom[0][0]);
 8028938:	683b      	ldr	r3, [r7, #0]
 802893a:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802893e:	fb02 f303 	mul.w	r3, r2, r3
 8028942:	68fa      	ldr	r2, [r7, #12]
 8028944:	4413      	add	r3, r2
 8028946:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8028948:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 802894c:	ee07 3a90 	vmov	s15, r3
 8028950:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028954:	4882      	ldr	r0, [pc, #520]	; (8028b60 <Calibrate+0x270>)
 8028956:	eeb0 0a67 	vmov.f32	s0, s15
 802895a:	f7ff ff9b 	bl	8028894 <PolyVal>
 802895e:	ee10 3a10 	vmov	r3, s0
 8028962:	4618      	mov	r0, r3
 8028964:	f7ff fa48 	bl	8027df8 <__aeabi_f2d>
 8028968:	4603      	mov	r3, r0
 802896a:	460c      	mov	r4, r1
 802896c:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
	omLin[1] = (double)PolyVal((float)rawData[csCount].RxBuffer_OMY[buffIndex], &pnlom[1][0]);
 8028970:	683b      	ldr	r3, [r7, #0]
 8028972:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8028976:	fb02 f303 	mul.w	r3, r2, r3
 802897a:	68fa      	ldr	r2, [r7, #12]
 802897c:	4413      	add	r3, r2
 802897e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8028980:	3264      	adds	r2, #100	; 0x64
 8028982:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 8028986:	ee07 3a90 	vmov	s15, r3
 802898a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802898e:	4875      	ldr	r0, [pc, #468]	; (8028b64 <Calibrate+0x274>)
 8028990:	eeb0 0a67 	vmov.f32	s0, s15
 8028994:	f7ff ff7e 	bl	8028894 <PolyVal>
 8028998:	ee10 3a10 	vmov	r3, s0
 802899c:	4618      	mov	r0, r3
 802899e:	f7ff fa2b 	bl	8027df8 <__aeabi_f2d>
 80289a2:	4603      	mov	r3, r0
 80289a4:	460c      	mov	r4, r1
 80289a6:	e9c7 3416 	strd	r3, r4, [r7, #88]	; 0x58
	omLin[2] = (double)PolyVal((float)rawData[csCount].RxBuffer_OMZ[buffIndex], &pnlom[2][0]);
 80289aa:	683b      	ldr	r3, [r7, #0]
 80289ac:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80289b0:	fb02 f303 	mul.w	r3, r2, r3
 80289b4:	68fa      	ldr	r2, [r7, #12]
 80289b6:	4413      	add	r3, r2
 80289b8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80289ba:	32c8      	adds	r2, #200	; 0xc8
 80289bc:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 80289c0:	ee07 3a90 	vmov	s15, r3
 80289c4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80289c8:	4867      	ldr	r0, [pc, #412]	; (8028b68 <Calibrate+0x278>)
 80289ca:	eeb0 0a67 	vmov.f32	s0, s15
 80289ce:	f7ff ff61 	bl	8028894 <PolyVal>
 80289d2:	ee10 3a10 	vmov	r3, s0
 80289d6:	4618      	mov	r0, r3
 80289d8:	f7ff fa0e 	bl	8027df8 <__aeabi_f2d>
 80289dc:	4603      	mov	r3, r0
 80289de:	460c      	mov	r4, r1
 80289e0:	e9c7 3418 	strd	r3, r4, [r7, #96]	; 0x60
	gsl_vector_view omLinVec = gsl_vector_view_array(omLin, 3);
 80289e4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80289e8:	f107 0150 	add.w	r1, r7, #80	; 0x50
 80289ec:	2203      	movs	r2, #3
 80289ee:	4618      	mov	r0, r3
 80289f0:	f7dd fc18 	bl	8006224 <gsl_vector_view_array>
	gsl_vector_view omCalibVec = gsl_vector_view_array(omCalib, 3);
 80289f4:	f107 0310 	add.w	r3, r7, #16
 80289f8:	f107 0138 	add.w	r1, r7, #56	; 0x38
 80289fc:	2203      	movs	r2, #3
 80289fe:	4618      	mov	r0, r3
 8028a00:	f7dd fc10 	bl	8006224 <gsl_vector_view_array>

	// Apply nonorthogonality and scale factor corrections to gyro measurements
	gsl_blas_dgemv(CblasNoTrans, 1.0, TKom, &omLinVec.vector, 0.0, &omCalibVec.vector);
 8028a04:	4b59      	ldr	r3, [pc, #356]	; (8028b6c <Calibrate+0x27c>)
 8028a06:	6819      	ldr	r1, [r3, #0]
 8028a08:	f107 0310 	add.w	r3, r7, #16
 8028a0c:	f107 0224 	add.w	r2, r7, #36	; 0x24
 8028a10:	ed9f 1b4f 	vldr	d1, [pc, #316]	; 8028b50 <Calibrate+0x260>
 8028a14:	ed9f 0b50 	vldr	d0, [pc, #320]	; 8028b58 <Calibrate+0x268>
 8028a18:	206f      	movs	r0, #111	; 0x6f
 8028a1a:	f7d7 ffc5 	bl	80009a8 <gsl_blas_dgemv>

	// Write calibrated gyro measurements to calibData
	calibData[csCount].RxBuffer_OMX[buffIndex] = (float)omCalib[0];
 8028a1e:	e9d7 340e 	ldrd	r3, r4, [r7, #56]	; 0x38
 8028a22:	683a      	ldr	r2, [r7, #0]
 8028a24:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028a28:	fb01 f202 	mul.w	r2, r1, r2
 8028a2c:	68b9      	ldr	r1, [r7, #8]
 8028a2e:	188d      	adds	r5, r1, r2
 8028a30:	4618      	mov	r0, r3
 8028a32:	4621      	mov	r1, r4
 8028a34:	f7ff fce8 	bl	8028408 <__aeabi_d2f>
 8028a38:	4602      	mov	r2, r0
 8028a3a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8028a3c:	009b      	lsls	r3, r3, #2
 8028a3e:	442b      	add	r3, r5
 8028a40:	601a      	str	r2, [r3, #0]
	calibData[csCount].RxBuffer_OMY[buffIndex] = (float)omCalib[1];
 8028a42:	e9d7 3410 	ldrd	r3, r4, [r7, #64]	; 0x40
 8028a46:	683a      	ldr	r2, [r7, #0]
 8028a48:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028a4c:	fb01 f202 	mul.w	r2, r1, r2
 8028a50:	68b9      	ldr	r1, [r7, #8]
 8028a52:	188d      	adds	r5, r1, r2
 8028a54:	4618      	mov	r0, r3
 8028a56:	4621      	mov	r1, r4
 8028a58:	f7ff fcd6 	bl	8028408 <__aeabi_d2f>
 8028a5c:	4602      	mov	r2, r0
 8028a5e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8028a60:	3364      	adds	r3, #100	; 0x64
 8028a62:	009b      	lsls	r3, r3, #2
 8028a64:	442b      	add	r3, r5
 8028a66:	601a      	str	r2, [r3, #0]
	calibData[csCount].RxBuffer_OMZ[buffIndex] = (float)omCalib[2];
 8028a68:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
 8028a6c:	683a      	ldr	r2, [r7, #0]
 8028a6e:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028a72:	fb01 f202 	mul.w	r2, r1, r2
 8028a76:	68b9      	ldr	r1, [r7, #8]
 8028a78:	188d      	adds	r5, r1, r2
 8028a7a:	4618      	mov	r0, r3
 8028a7c:	4621      	mov	r1, r4
 8028a7e:	f7ff fcc3 	bl	8028408 <__aeabi_d2f>
 8028a82:	4602      	mov	r2, r0
 8028a84:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8028a86:	33c8      	adds	r3, #200	; 0xc8
 8028a88:	009b      	lsls	r3, r3, #2
 8028a8a:	442b      	add	r3, r5
 8028a8c:	601a      	str	r2, [r3, #0]

	// Pass uncalibrated accelerometer measurements directly to calibData (to be calibrated offline)
	calibData[csCount].RxBuffer_AX[buffIndex] = rawData[csCount].RxBuffer_AX[buffIndex];
 8028a8e:	683b      	ldr	r3, [r7, #0]
 8028a90:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8028a94:	fb02 f303 	mul.w	r3, r2, r3
 8028a98:	68fa      	ldr	r2, [r7, #12]
 8028a9a:	4413      	add	r3, r2
 8028a9c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8028a9e:	f502 7296 	add.w	r2, r2, #300	; 0x12c
 8028aa2:	f933 1012 	ldrsh.w	r1, [r3, r2, lsl #1]
 8028aa6:	683b      	ldr	r3, [r7, #0]
 8028aa8:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8028aac:	fb02 f303 	mul.w	r3, r2, r3
 8028ab0:	68ba      	ldr	r2, [r7, #8]
 8028ab2:	441a      	add	r2, r3
 8028ab4:	ee07 1a90 	vmov	s15, r1
 8028ab8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028abc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8028abe:	f503 7396 	add.w	r3, r3, #300	; 0x12c
 8028ac2:	009b      	lsls	r3, r3, #2
 8028ac4:	4413      	add	r3, r2
 8028ac6:	edc3 7a00 	vstr	s15, [r3]
	calibData[csCount].RxBuffer_AY[buffIndex] = rawData[csCount].RxBuffer_AY[buffIndex];
 8028aca:	683b      	ldr	r3, [r7, #0]
 8028acc:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8028ad0:	fb02 f303 	mul.w	r3, r2, r3
 8028ad4:	68fa      	ldr	r2, [r7, #12]
 8028ad6:	4413      	add	r3, r2
 8028ad8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8028ada:	f502 72c8 	add.w	r2, r2, #400	; 0x190
 8028ade:	f933 1012 	ldrsh.w	r1, [r3, r2, lsl #1]
 8028ae2:	683b      	ldr	r3, [r7, #0]
 8028ae4:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8028ae8:	fb02 f303 	mul.w	r3, r2, r3
 8028aec:	68ba      	ldr	r2, [r7, #8]
 8028aee:	441a      	add	r2, r3
 8028af0:	ee07 1a90 	vmov	s15, r1
 8028af4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028af8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8028afa:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8028afe:	009b      	lsls	r3, r3, #2
 8028b00:	4413      	add	r3, r2
 8028b02:	edc3 7a00 	vstr	s15, [r3]
	calibData[csCount].RxBuffer_AZ[buffIndex] = rawData[csCount].RxBuffer_AZ[buffIndex];
 8028b06:	683b      	ldr	r3, [r7, #0]
 8028b08:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8028b0c:	fb02 f303 	mul.w	r3, r2, r3
 8028b10:	68fa      	ldr	r2, [r7, #12]
 8028b12:	4413      	add	r3, r2
 8028b14:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8028b16:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
 8028b1a:	f933 1012 	ldrsh.w	r1, [r3, r2, lsl #1]
 8028b1e:	683b      	ldr	r3, [r7, #0]
 8028b20:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8028b24:	fb02 f303 	mul.w	r3, r2, r3
 8028b28:	68ba      	ldr	r2, [r7, #8]
 8028b2a:	441a      	add	r2, r3
 8028b2c:	ee07 1a90 	vmov	s15, r1
 8028b30:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028b34:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8028b36:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8028b3a:	009b      	lsls	r3, r3, #2
 8028b3c:	4413      	add	r3, r2
 8028b3e:	edc3 7a00 	vstr	s15, [r3]

	return;
 8028b42:	bf00      	nop
}
 8028b44:	3770      	adds	r7, #112	; 0x70
 8028b46:	46bd      	mov	sp, r7
 8028b48:	bdb0      	pop	{r4, r5, r7, pc}
 8028b4a:	bf00      	nop
 8028b4c:	f3af 8000 	nop.w
	...
 8028b5c:	3ff00000 	.word	0x3ff00000
 8028b60:	20000004 	.word	0x20000004
 8028b64:	20000014 	.word	0x20000014
 8028b68:	20000024 	.word	0x20000024
 8028b6c:	20001514 	.word	0x20001514

08028b70 <SystemClock_Config>:
 * PPL value can be generated from the .ioc file in the project
 * IMPORTANT:
 * When use external clock source HSEState must be set to RCC_HSE_ON (Flash chip purpose)
 */
void SystemClock_Config(void)
{
 8028b70:	b580      	push	{r7, lr}
 8028b72:	b094      	sub	sp, #80	; 0x50
 8028b74:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8028b76:	f107 0320 	add.w	r3, r7, #32
 8028b7a:	2230      	movs	r2, #48	; 0x30
 8028b7c:	2100      	movs	r1, #0
 8028b7e:	4618      	mov	r0, r3
 8028b80:	f006 fbe2 	bl	802f348 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8028b84:	f107 030c 	add.w	r3, r7, #12
 8028b88:	2200      	movs	r2, #0
 8028b8a:	601a      	str	r2, [r3, #0]
 8028b8c:	605a      	str	r2, [r3, #4]
 8028b8e:	609a      	str	r2, [r3, #8]
 8028b90:	60da      	str	r2, [r3, #12]
 8028b92:	611a      	str	r2, [r3, #16]

  // Configure the main internal regulator output voltage
  __HAL_RCC_PWR_CLK_ENABLE();
 8028b94:	2300      	movs	r3, #0
 8028b96:	60bb      	str	r3, [r7, #8]
 8028b98:	4b29      	ldr	r3, [pc, #164]	; (8028c40 <SystemClock_Config+0xd0>)
 8028b9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8028b9c:	4a28      	ldr	r2, [pc, #160]	; (8028c40 <SystemClock_Config+0xd0>)
 8028b9e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8028ba2:	6413      	str	r3, [r2, #64]	; 0x40
 8028ba4:	4b26      	ldr	r3, [pc, #152]	; (8028c40 <SystemClock_Config+0xd0>)
 8028ba6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8028ba8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8028bac:	60bb      	str	r3, [r7, #8]
 8028bae:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
 8028bb0:	2300      	movs	r3, #0
 8028bb2:	607b      	str	r3, [r7, #4]
 8028bb4:	4b23      	ldr	r3, [pc, #140]	; (8028c44 <SystemClock_Config+0xd4>)
 8028bb6:	681b      	ldr	r3, [r3, #0]
 8028bb8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8028bbc:	4a21      	ldr	r2, [pc, #132]	; (8028c44 <SystemClock_Config+0xd4>)
 8028bbe:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8028bc2:	6013      	str	r3, [r2, #0]
 8028bc4:	4b1f      	ldr	r3, [pc, #124]	; (8028c44 <SystemClock_Config+0xd4>)
 8028bc6:	681b      	ldr	r3, [r3, #0]
 8028bc8:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8028bcc:	607b      	str	r3, [r7, #4]
 8028bce:	687b      	ldr	r3, [r7, #4]
  // Initializes the CPU, AHB and APB busses clocks
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8028bd0:	2301      	movs	r3, #1
 8028bd2:	623b      	str	r3, [r7, #32]
   RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8028bd4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8028bd8:	627b      	str	r3, [r7, #36]	; 0x24
   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8028bda:	2302      	movs	r3, #2
 8028bdc:	63bb      	str	r3, [r7, #56]	; 0x38
   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8028bde:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8028be2:	63fb      	str	r3, [r7, #60]	; 0x3c
   RCC_OscInitStruct.PLL.PLLM = 8;
 8028be4:	2308      	movs	r3, #8
 8028be6:	643b      	str	r3, [r7, #64]	; 0x40
   RCC_OscInitStruct.PLL.PLLN = 336;
 8028be8:	f44f 73a8 	mov.w	r3, #336	; 0x150
 8028bec:	647b      	str	r3, [r7, #68]	; 0x44
   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
 8028bee:	2304      	movs	r3, #4
 8028bf0:	64bb      	str	r3, [r7, #72]	; 0x48
   RCC_OscInitStruct.PLL.PLLQ = 7;
 8028bf2:	2307      	movs	r3, #7
 8028bf4:	64fb      	str	r3, [r7, #76]	; 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8028bf6:	f107 0320 	add.w	r3, r7, #32
 8028bfa:	4618      	mov	r0, r3
 8028bfc:	f003 f92e 	bl	802be5c <HAL_RCC_OscConfig>
 8028c00:	4603      	mov	r3, r0
 8028c02:	2b00      	cmp	r3, #0
 8028c04:	d001      	beq.n	8028c0a <SystemClock_Config+0x9a>
  {
    Error_Handler();
 8028c06:	f000 feb5 	bl	8029974 <Error_Handler>
  }
  // Initializes the CPU, AHB and APB busses clocks
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8028c0a:	230f      	movs	r3, #15
 8028c0c:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8028c0e:	2302      	movs	r3, #2
 8028c10:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8028c12:	2300      	movs	r3, #0
 8028c14:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8028c16:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8028c1a:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8028c1c:	2300      	movs	r3, #0
 8028c1e:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8028c20:	f107 030c 	add.w	r3, r7, #12
 8028c24:	2102      	movs	r1, #2
 8028c26:	4618      	mov	r0, r3
 8028c28:	f003 fb88 	bl	802c33c <HAL_RCC_ClockConfig>
 8028c2c:	4603      	mov	r3, r0
 8028c2e:	2b00      	cmp	r3, #0
 8028c30:	d001      	beq.n	8028c36 <SystemClock_Config+0xc6>
  {
    Error_Handler();
 8028c32:	f000 fe9f 	bl	8029974 <Error_Handler>
  }
}
 8028c36:	bf00      	nop
 8028c38:	3750      	adds	r7, #80	; 0x50
 8028c3a:	46bd      	mov	sp, r7
 8028c3c:	bd80      	pop	{r7, pc}
 8028c3e:	bf00      	nop
 8028c40:	40023800 	.word	0x40023800
 8028c44:	40007000 	.word	0x40007000

08028c48 <HAL_SPI_TxRxCpltCallback>:
 *SPI DMA handler, being called after completed one transmit&receive
 *PULL up SPI CS pin after done with transmission, disable SPI DMA
 *Check if data in FIFO, Set flag accordingly for the FSM
 */
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
{
 8028c48:	b580      	push	{r7, lr}
 8028c4a:	b082      	sub	sp, #8
 8028c4c:	af00      	add	r7, sp, #0
 8028c4e:	6078      	str	r0, [r7, #4]
	while( hspi1.State == HAL_SPI_STATE_BUSY );
 8028c50:	bf00      	nop
 8028c52:	4b0c      	ldr	r3, [pc, #48]	; (8028c84 <HAL_SPI_TxRxCpltCallback+0x3c>)
 8028c54:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 8028c58:	b2db      	uxtb	r3, r3
 8028c5a:	2b02      	cmp	r3, #2
 8028c5c:	d0f9      	beq.n	8028c52 <HAL_SPI_TxRxCpltCallback+0xa>
	HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8028c5e:	4b0a      	ldr	r3, [pc, #40]	; (8028c88 <HAL_SPI_TxRxCpltCallback+0x40>)
 8028c60:	6818      	ldr	r0, [r3, #0]
 8028c62:	4b0a      	ldr	r3, [pc, #40]	; (8028c8c <HAL_SPI_TxRxCpltCallback+0x44>)
 8028c64:	881b      	ldrh	r3, [r3, #0]
 8028c66:	2201      	movs	r2, #1
 8028c68:	4619      	mov	r1, r3
 8028c6a:	f003 f8dd 	bl	802be28 <HAL_GPIO_WritePin>
	HAL_SPI_DMAPause(&hspi1);
 8028c6e:	4805      	ldr	r0, [pc, #20]	; (8028c84 <HAL_SPI_TxRxCpltCallback+0x3c>)
 8028c70:	f004 f992 	bl	802cf98 <HAL_SPI_DMAPause>
//	{
//		 state = 0;															// If empty,
//		 BUFFER_ORDER = 0;
//	}
//	else state = 1;
	FSM_CHECKED_FLAG = 0;													// Set flag to check FSM on next main program iteration
 8028c74:	4b06      	ldr	r3, [pc, #24]	; (8028c90 <HAL_SPI_TxRxCpltCallback+0x48>)
 8028c76:	2200      	movs	r2, #0
 8028c78:	601a      	str	r2, [r3, #0]

}
 8028c7a:	bf00      	nop
 8028c7c:	3708      	adds	r7, #8
 8028c7e:	46bd      	mov	sp, r7
 8028c80:	bd80      	pop	{r7, pc}
 8028c82:	bf00      	nop
 8028c84:	200016a0 	.word	0x200016a0
 8028c88:	20001518 	.word	0x20001518
 8028c8c:	2000151c 	.word	0x2000151c
 8028c90:	20000174 	.word	0x20000174

08028c94 <DMA_FSM_BURST6>:
 * state 1: read execution
 * 			BUFFER_ORDER：  6 read execution
 * 			BUFFER_ORDER: 0 data storage
 */
void DMA_FSM_BURST6(int *csCount, struct RxBuffer *My, int I[nIMUs])
{
 8028c94:	b590      	push	{r4, r7, lr}
 8028c96:	b087      	sub	sp, #28
 8028c98:	af02      	add	r7, sp, #8
 8028c9a:	60f8      	str	r0, [r7, #12]
 8028c9c:	60b9      	str	r1, [r7, #8]
 8028c9e:	607a      	str	r2, [r7, #4]
	FSM_CHECKED_FLAG = 1;
 8028ca0:	4b89      	ldr	r3, [pc, #548]	; (8028ec8 <DMA_FSM_BURST6+0x234>)
 8028ca2:	2201      	movs	r2, #1
 8028ca4:	601a      	str	r2, [r3, #0]
	if(((EDMA[2]&isEmptyDMA)==isEmptyDMA))													// Check if FIFO is empty (logical AND between FIFO_S2 register value and isEmpty bit)
 8028ca6:	4b89      	ldr	r3, [pc, #548]	; (8028ecc <DMA_FSM_BURST6+0x238>)
 8028ca8:	789b      	ldrb	r3, [r3, #2]
 8028caa:	f003 0310 	and.w	r3, r3, #16
 8028cae:	2b00      	cmp	r3, #0
 8028cb0:	d01e      	beq.n	8028cf0 <DMA_FSM_BURST6+0x5c>
	{																						// If empty, reset FIFO data available flag, change to next IMU in array, and read its FIFO status register
		fFIFO_DATA_AVAIL = 0;
 8028cb2:	4b87      	ldr	r3, [pc, #540]	; (8028ed0 <DMA_FSM_BURST6+0x23c>)
 8028cb4:	2200      	movs	r2, #0
 8028cb6:	601a      	str	r2, [r3, #0]
		*csCount = *csCount ==(nIMUs-1)? 0 : *csCount+1;
 8028cb8:	68fb      	ldr	r3, [r7, #12]
 8028cba:	681b      	ldr	r3, [r3, #0]
 8028cbc:	2b05      	cmp	r3, #5
 8028cbe:	d003      	beq.n	8028cc8 <DMA_FSM_BURST6+0x34>
 8028cc0:	68fb      	ldr	r3, [r7, #12]
 8028cc2:	681b      	ldr	r3, [r3, #0]
 8028cc4:	3301      	adds	r3, #1
 8028cc6:	e000      	b.n	8028cca <DMA_FSM_BURST6+0x36>
 8028cc8:	2300      	movs	r3, #0
 8028cca:	68fa      	ldr	r2, [r7, #12]
 8028ccc:	6013      	str	r3, [r2, #0]
		chipSelection(*csCount);
 8028cce:	68fb      	ldr	r3, [r7, #12]
 8028cd0:	681b      	ldr	r3, [r3, #0]
 8028cd2:	4618      	mov	r0, r3
 8028cd4:	f000 fa64 	bl	80291a0 <chipSelection>
		spi_DMA_RX(FIFO_S2, EDMA, Ports, Pins,2);
 8028cd8:	4b7e      	ldr	r3, [pc, #504]	; (8028ed4 <DMA_FSM_BURST6+0x240>)
 8028cda:	681a      	ldr	r2, [r3, #0]
 8028cdc:	4b7e      	ldr	r3, [pc, #504]	; (8028ed8 <DMA_FSM_BURST6+0x244>)
 8028cde:	8819      	ldrh	r1, [r3, #0]
 8028ce0:	2302      	movs	r3, #2
 8028ce2:	9300      	str	r3, [sp, #0]
 8028ce4:	460b      	mov	r3, r1
 8028ce6:	4979      	ldr	r1, [pc, #484]	; (8028ecc <DMA_FSM_BURST6+0x238>)
 8028ce8:	487c      	ldr	r0, [pc, #496]	; (8028edc <DMA_FSM_BURST6+0x248>)
 8028cea:	f001 fd17 	bl	802a71c <spi_DMA_RX>
				cSETs++;
				spi_DMA_RX(FIFO_S2, EDMA, Ports, Pins, 2);
				break;
		}
	}
}
 8028cee:	e0e7      	b.n	8028ec0 <DMA_FSM_BURST6+0x22c>
		switch (fFIFO_DATA_AVAIL)
 8028cf0:	4b77      	ldr	r3, [pc, #476]	; (8028ed0 <DMA_FSM_BURST6+0x23c>)
 8028cf2:	681b      	ldr	r3, [r3, #0]
 8028cf4:	2b00      	cmp	r3, #0
 8028cf6:	d002      	beq.n	8028cfe <DMA_FSM_BURST6+0x6a>
 8028cf8:	2b01      	cmp	r3, #1
 8028cfa:	d00f      	beq.n	8028d1c <DMA_FSM_BURST6+0x88>
}
 8028cfc:	e0e0      	b.n	8028ec0 <DMA_FSM_BURST6+0x22c>
				fFIFO_DATA_AVAIL = 1;														// Set FIFO data available flag to indicate read was initiated
 8028cfe:	4b74      	ldr	r3, [pc, #464]	; (8028ed0 <DMA_FSM_BURST6+0x23c>)
 8028d00:	2201      	movs	r2, #1
 8028d02:	601a      	str	r2, [r3, #0]
				spi_DMA_RX(&FIFO_ADD6[0], TEMP6, Ports, Pins, 13);								// Initiate read
 8028d04:	4b73      	ldr	r3, [pc, #460]	; (8028ed4 <DMA_FSM_BURST6+0x240>)
 8028d06:	681a      	ldr	r2, [r3, #0]
 8028d08:	4b73      	ldr	r3, [pc, #460]	; (8028ed8 <DMA_FSM_BURST6+0x244>)
 8028d0a:	8819      	ldrh	r1, [r3, #0]
 8028d0c:	230d      	movs	r3, #13
 8028d0e:	9300      	str	r3, [sp, #0]
 8028d10:	460b      	mov	r3, r1
 8028d12:	4973      	ldr	r1, [pc, #460]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d14:	4873      	ldr	r0, [pc, #460]	; (8028ee4 <DMA_FSM_BURST6+0x250>)
 8028d16:	f001 fd01 	bl	802a71c <spi_DMA_RX>
				break;
 8028d1a:	e0d1      	b.n	8028ec0 <DMA_FSM_BURST6+0x22c>
				My[*csCount].RxBuffer_OMX[I[*csCount]] = (int16_t)((TEMP6[4]<<8)|(TEMP6[2]));
 8028d1c:	4b70      	ldr	r3, [pc, #448]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d1e:	791b      	ldrb	r3, [r3, #4]
 8028d20:	021b      	lsls	r3, r3, #8
 8028d22:	b218      	sxth	r0, r3
 8028d24:	4b6e      	ldr	r3, [pc, #440]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d26:	789b      	ldrb	r3, [r3, #2]
 8028d28:	b219      	sxth	r1, r3
 8028d2a:	68fb      	ldr	r3, [r7, #12]
 8028d2c:	681b      	ldr	r3, [r3, #0]
 8028d2e:	461a      	mov	r2, r3
 8028d30:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8028d34:	fb03 f302 	mul.w	r3, r3, r2
 8028d38:	68ba      	ldr	r2, [r7, #8]
 8028d3a:	4413      	add	r3, r2
 8028d3c:	68fa      	ldr	r2, [r7, #12]
 8028d3e:	6812      	ldr	r2, [r2, #0]
 8028d40:	0092      	lsls	r2, r2, #2
 8028d42:	687c      	ldr	r4, [r7, #4]
 8028d44:	4422      	add	r2, r4
 8028d46:	6812      	ldr	r2, [r2, #0]
 8028d48:	4301      	orrs	r1, r0
 8028d4a:	b209      	sxth	r1, r1
 8028d4c:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_OMY[I[*csCount]] =  (int16_t)((TEMP6[8]<<8)|(TEMP6[6]));
 8028d50:	4b63      	ldr	r3, [pc, #396]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d52:	7a1b      	ldrb	r3, [r3, #8]
 8028d54:	021b      	lsls	r3, r3, #8
 8028d56:	b218      	sxth	r0, r3
 8028d58:	4b61      	ldr	r3, [pc, #388]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d5a:	799b      	ldrb	r3, [r3, #6]
 8028d5c:	b219      	sxth	r1, r3
 8028d5e:	68fb      	ldr	r3, [r7, #12]
 8028d60:	681b      	ldr	r3, [r3, #0]
 8028d62:	461a      	mov	r2, r3
 8028d64:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8028d68:	fb03 f302 	mul.w	r3, r3, r2
 8028d6c:	68ba      	ldr	r2, [r7, #8]
 8028d6e:	4413      	add	r3, r2
 8028d70:	68fa      	ldr	r2, [r7, #12]
 8028d72:	6812      	ldr	r2, [r2, #0]
 8028d74:	0092      	lsls	r2, r2, #2
 8028d76:	687c      	ldr	r4, [r7, #4]
 8028d78:	4422      	add	r2, r4
 8028d7a:	6812      	ldr	r2, [r2, #0]
 8028d7c:	4301      	orrs	r1, r0
 8028d7e:	b209      	sxth	r1, r1
 8028d80:	3264      	adds	r2, #100	; 0x64
 8028d82:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_OMZ[I[*csCount]] = (int16_t)((TEMP6[12]<<8)|(TEMP6[10]));
 8028d86:	4b56      	ldr	r3, [pc, #344]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d88:	7b1b      	ldrb	r3, [r3, #12]
 8028d8a:	021b      	lsls	r3, r3, #8
 8028d8c:	b218      	sxth	r0, r3
 8028d8e:	4b54      	ldr	r3, [pc, #336]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028d90:	7a9b      	ldrb	r3, [r3, #10]
 8028d92:	b219      	sxth	r1, r3
 8028d94:	68fb      	ldr	r3, [r7, #12]
 8028d96:	681b      	ldr	r3, [r3, #0]
 8028d98:	461a      	mov	r2, r3
 8028d9a:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8028d9e:	fb03 f302 	mul.w	r3, r3, r2
 8028da2:	68ba      	ldr	r2, [r7, #8]
 8028da4:	4413      	add	r3, r2
 8028da6:	68fa      	ldr	r2, [r7, #12]
 8028da8:	6812      	ldr	r2, [r2, #0]
 8028daa:	0092      	lsls	r2, r2, #2
 8028dac:	687c      	ldr	r4, [r7, #4]
 8028dae:	4422      	add	r2, r4
 8028db0:	6812      	ldr	r2, [r2, #0]
 8028db2:	4301      	orrs	r1, r0
 8028db4:	b209      	sxth	r1, r1
 8028db6:	32c8      	adds	r2, #200	; 0xc8
 8028db8:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_AX[I[*csCount]] =  (int16_t)((TEMP6[16]<<8)|(TEMP6[14]));
 8028dbc:	4b48      	ldr	r3, [pc, #288]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028dbe:	7c1b      	ldrb	r3, [r3, #16]
 8028dc0:	021b      	lsls	r3, r3, #8
 8028dc2:	b218      	sxth	r0, r3
 8028dc4:	4b46      	ldr	r3, [pc, #280]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028dc6:	7b9b      	ldrb	r3, [r3, #14]
 8028dc8:	b219      	sxth	r1, r3
 8028dca:	68fb      	ldr	r3, [r7, #12]
 8028dcc:	681b      	ldr	r3, [r3, #0]
 8028dce:	461a      	mov	r2, r3
 8028dd0:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8028dd4:	fb03 f302 	mul.w	r3, r3, r2
 8028dd8:	68ba      	ldr	r2, [r7, #8]
 8028dda:	4413      	add	r3, r2
 8028ddc:	68fa      	ldr	r2, [r7, #12]
 8028dde:	6812      	ldr	r2, [r2, #0]
 8028de0:	0092      	lsls	r2, r2, #2
 8028de2:	687c      	ldr	r4, [r7, #4]
 8028de4:	4422      	add	r2, r4
 8028de6:	6812      	ldr	r2, [r2, #0]
 8028de8:	4301      	orrs	r1, r0
 8028dea:	b209      	sxth	r1, r1
 8028dec:	f502 7296 	add.w	r2, r2, #300	; 0x12c
 8028df0:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_AY[I[*csCount]] = (int16_t)((TEMP6[20]<<8)|(TEMP6[18]));
 8028df4:	4b3a      	ldr	r3, [pc, #232]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028df6:	7d1b      	ldrb	r3, [r3, #20]
 8028df8:	021b      	lsls	r3, r3, #8
 8028dfa:	b218      	sxth	r0, r3
 8028dfc:	4b38      	ldr	r3, [pc, #224]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028dfe:	7c9b      	ldrb	r3, [r3, #18]
 8028e00:	b219      	sxth	r1, r3
 8028e02:	68fb      	ldr	r3, [r7, #12]
 8028e04:	681b      	ldr	r3, [r3, #0]
 8028e06:	461a      	mov	r2, r3
 8028e08:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8028e0c:	fb03 f302 	mul.w	r3, r3, r2
 8028e10:	68ba      	ldr	r2, [r7, #8]
 8028e12:	4413      	add	r3, r2
 8028e14:	68fa      	ldr	r2, [r7, #12]
 8028e16:	6812      	ldr	r2, [r2, #0]
 8028e18:	0092      	lsls	r2, r2, #2
 8028e1a:	687c      	ldr	r4, [r7, #4]
 8028e1c:	4422      	add	r2, r4
 8028e1e:	6812      	ldr	r2, [r2, #0]
 8028e20:	4301      	orrs	r1, r0
 8028e22:	b209      	sxth	r1, r1
 8028e24:	f502 72c8 	add.w	r2, r2, #400	; 0x190
 8028e28:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				My[*csCount].RxBuffer_AZ[I[*csCount]] = (int16_t)((TEMP6[24]<<8)|(TEMP6[22]));
 8028e2c:	4b2c      	ldr	r3, [pc, #176]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028e2e:	7e1b      	ldrb	r3, [r3, #24]
 8028e30:	021b      	lsls	r3, r3, #8
 8028e32:	b218      	sxth	r0, r3
 8028e34:	4b2a      	ldr	r3, [pc, #168]	; (8028ee0 <DMA_FSM_BURST6+0x24c>)
 8028e36:	7d9b      	ldrb	r3, [r3, #22]
 8028e38:	b219      	sxth	r1, r3
 8028e3a:	68fb      	ldr	r3, [r7, #12]
 8028e3c:	681b      	ldr	r3, [r3, #0]
 8028e3e:	461a      	mov	r2, r3
 8028e40:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
 8028e44:	fb03 f302 	mul.w	r3, r3, r2
 8028e48:	68ba      	ldr	r2, [r7, #8]
 8028e4a:	4413      	add	r3, r2
 8028e4c:	68fa      	ldr	r2, [r7, #12]
 8028e4e:	6812      	ldr	r2, [r2, #0]
 8028e50:	0092      	lsls	r2, r2, #2
 8028e52:	687c      	ldr	r4, [r7, #4]
 8028e54:	4422      	add	r2, r4
 8028e56:	6812      	ldr	r2, [r2, #0]
 8028e58:	4301      	orrs	r1, r0
 8028e5a:	b209      	sxth	r1, r1
 8028e5c:	f502 72fa 	add.w	r2, r2, #500	; 0x1f4
 8028e60:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
				I[*csCount] = I[*csCount] < RX_BUFFER_SIZE - 1? I[*csCount]+1 : 0;
 8028e64:	68fb      	ldr	r3, [r7, #12]
 8028e66:	681b      	ldr	r3, [r3, #0]
 8028e68:	009b      	lsls	r3, r3, #2
 8028e6a:	687a      	ldr	r2, [r7, #4]
 8028e6c:	4413      	add	r3, r2
 8028e6e:	681b      	ldr	r3, [r3, #0]
 8028e70:	2b62      	cmp	r3, #98	; 0x62
 8028e72:	dc07      	bgt.n	8028e84 <DMA_FSM_BURST6+0x1f0>
 8028e74:	68fb      	ldr	r3, [r7, #12]
 8028e76:	681b      	ldr	r3, [r3, #0]
 8028e78:	009b      	lsls	r3, r3, #2
 8028e7a:	687a      	ldr	r2, [r7, #4]
 8028e7c:	4413      	add	r3, r2
 8028e7e:	681b      	ldr	r3, [r3, #0]
 8028e80:	3301      	adds	r3, #1
 8028e82:	e000      	b.n	8028e86 <DMA_FSM_BURST6+0x1f2>
 8028e84:	2300      	movs	r3, #0
 8028e86:	68fa      	ldr	r2, [r7, #12]
 8028e88:	6812      	ldr	r2, [r2, #0]
 8028e8a:	0092      	lsls	r2, r2, #2
 8028e8c:	6879      	ldr	r1, [r7, #4]
 8028e8e:	440a      	add	r2, r1
 8028e90:	6013      	str	r3, [r2, #0]
				DP_FLAG = 1;
 8028e92:	4b15      	ldr	r3, [pc, #84]	; (8028ee8 <DMA_FSM_BURST6+0x254>)
 8028e94:	2201      	movs	r2, #1
 8028e96:	601a      	str	r2, [r3, #0]
				fFIFO_DATA_AVAIL = 0;
 8028e98:	4b0d      	ldr	r3, [pc, #52]	; (8028ed0 <DMA_FSM_BURST6+0x23c>)
 8028e9a:	2200      	movs	r2, #0
 8028e9c:	601a      	str	r2, [r3, #0]
				cSETs++;
 8028e9e:	4b13      	ldr	r3, [pc, #76]	; (8028eec <DMA_FSM_BURST6+0x258>)
 8028ea0:	681b      	ldr	r3, [r3, #0]
 8028ea2:	3301      	adds	r3, #1
 8028ea4:	4a11      	ldr	r2, [pc, #68]	; (8028eec <DMA_FSM_BURST6+0x258>)
 8028ea6:	6013      	str	r3, [r2, #0]
				spi_DMA_RX(FIFO_S2, EDMA, Ports, Pins, 2);
 8028ea8:	4b0a      	ldr	r3, [pc, #40]	; (8028ed4 <DMA_FSM_BURST6+0x240>)
 8028eaa:	681a      	ldr	r2, [r3, #0]
 8028eac:	4b0a      	ldr	r3, [pc, #40]	; (8028ed8 <DMA_FSM_BURST6+0x244>)
 8028eae:	8819      	ldrh	r1, [r3, #0]
 8028eb0:	2302      	movs	r3, #2
 8028eb2:	9300      	str	r3, [sp, #0]
 8028eb4:	460b      	mov	r3, r1
 8028eb6:	4905      	ldr	r1, [pc, #20]	; (8028ecc <DMA_FSM_BURST6+0x238>)
 8028eb8:	4808      	ldr	r0, [pc, #32]	; (8028edc <DMA_FSM_BURST6+0x248>)
 8028eba:	f001 fc2f 	bl	802a71c <spi_DMA_RX>
				break;
 8028ebe:	bf00      	nop
}
 8028ec0:	bf00      	nop
 8028ec2:	3714      	adds	r7, #20
 8028ec4:	46bd      	mov	sp, r7
 8028ec6:	bd90      	pop	{r4, r7, pc}
 8028ec8:	20000174 	.word	0x20000174
 8028ecc:	20000170 	.word	0x20000170
 8028ed0:	20000150 	.word	0x20000150
 8028ed4:	20001518 	.word	0x20001518
 8028ed8:	2000151c 	.word	0x2000151c
 8028edc:	2000008c 	.word	0x2000008c
 8028ee0:	20000134 	.word	0x20000134
 8028ee4:	2000007c 	.word	0x2000007c
 8028ee8:	20000178 	.word	0x20000178
 8028eec:	20000154 	.word	0x20000154

08028ef0 <MX_GPIO_Init>:
  * @param None
  * @retval None
  */
#include "main.h"
void MX_GPIO_Init(void)
{
 8028ef0:	b580      	push	{r7, lr}
 8028ef2:	b08a      	sub	sp, #40	; 0x28
 8028ef4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8028ef6:	f107 0314 	add.w	r3, r7, #20
 8028efa:	2200      	movs	r2, #0
 8028efc:	601a      	str	r2, [r3, #0]
 8028efe:	605a      	str	r2, [r3, #4]
 8028f00:	609a      	str	r2, [r3, #8]
 8028f02:	60da      	str	r2, [r3, #12]
 8028f04:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
 8028f06:	2300      	movs	r3, #0
 8028f08:	613b      	str	r3, [r7, #16]
 8028f0a:	4b3b      	ldr	r3, [pc, #236]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f0e:	4a3a      	ldr	r2, [pc, #232]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f10:	f043 0304 	orr.w	r3, r3, #4
 8028f14:	6313      	str	r3, [r2, #48]	; 0x30
 8028f16:	4b38      	ldr	r3, [pc, #224]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f1a:	f003 0304 	and.w	r3, r3, #4
 8028f1e:	613b      	str	r3, [r7, #16]
 8028f20:	693b      	ldr	r3, [r7, #16]
	__HAL_RCC_GPIOH_CLK_ENABLE();
 8028f22:	2300      	movs	r3, #0
 8028f24:	60fb      	str	r3, [r7, #12]
 8028f26:	4b34      	ldr	r3, [pc, #208]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f28:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f2a:	4a33      	ldr	r2, [pc, #204]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f2c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8028f30:	6313      	str	r3, [r2, #48]	; 0x30
 8028f32:	4b31      	ldr	r3, [pc, #196]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f36:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8028f3a:	60fb      	str	r3, [r7, #12]
 8028f3c:	68fb      	ldr	r3, [r7, #12]
	__HAL_RCC_GPIOA_CLK_ENABLE();
 8028f3e:	2300      	movs	r3, #0
 8028f40:	60bb      	str	r3, [r7, #8]
 8028f42:	4b2d      	ldr	r3, [pc, #180]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f46:	4a2c      	ldr	r2, [pc, #176]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f48:	f043 0301 	orr.w	r3, r3, #1
 8028f4c:	6313      	str	r3, [r2, #48]	; 0x30
 8028f4e:	4b2a      	ldr	r3, [pc, #168]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f52:	f003 0301 	and.w	r3, r3, #1
 8028f56:	60bb      	str	r3, [r7, #8]
 8028f58:	68bb      	ldr	r3, [r7, #8]
	__HAL_RCC_GPIOB_CLK_ENABLE();
 8028f5a:	2300      	movs	r3, #0
 8028f5c:	607b      	str	r3, [r7, #4]
 8028f5e:	4b26      	ldr	r3, [pc, #152]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f62:	4a25      	ldr	r2, [pc, #148]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f64:	f043 0302 	orr.w	r3, r3, #2
 8028f68:	6313      	str	r3, [r2, #48]	; 0x30
 8028f6a:	4b23      	ldr	r3, [pc, #140]	; (8028ff8 <MX_GPIO_Init+0x108>)
 8028f6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8028f6e:	f003 0302 	and.w	r3, r3, #2
 8028f72:	607b      	str	r3, [r7, #4]
 8028f74:	687b      	ldr	r3, [r7, #4]

	GPIO_InitStruct.Pin = GPIO_PIN_8;
 8028f76:	f44f 7380 	mov.w	r3, #256	; 0x100
 8028f7a:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8028f7c:	2301      	movs	r3, #1
 8028f7e:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028f80:	2300      	movs	r3, #0
 8028f82:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8028f84:	2300      	movs	r3, #0
 8028f86:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8028f88:	f107 0314 	add.w	r3, r7, #20
 8028f8c:	4619      	mov	r1, r3
 8028f8e:	481b      	ldr	r0, [pc, #108]	; (8028ffc <MX_GPIO_Init+0x10c>)
 8028f90:	f002 fdb0 	bl	802baf4 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_15;
 8028f94:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8028f98:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8028f9a:	2300      	movs	r3, #0
 8028f9c:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8028f9e:	2302      	movs	r3, #2
 8028fa0:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8028fa2:	2300      	movs	r3, #0
 8028fa4:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8028fa6:	f107 0314 	add.w	r3, r7, #20
 8028faa:	4619      	mov	r1, r3
 8028fac:	4813      	ldr	r0, [pc, #76]	; (8028ffc <MX_GPIO_Init+0x10c>)
 8028fae:	f002 fda1 	bl	802baf4 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_3|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_2;
 8028fb2:	f24e 033c 	movw	r3, #57404	; 0xe03c
 8028fb6:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8028fb8:	2301      	movs	r3, #1
 8028fba:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028fbc:	2300      	movs	r3, #0
 8028fbe:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8028fc0:	2300      	movs	r3, #0
 8028fc2:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8028fc4:	f107 0314 	add.w	r3, r7, #20
 8028fc8:	4619      	mov	r1, r3
 8028fca:	480d      	ldr	r0, [pc, #52]	; (8029000 <MX_GPIO_Init+0x110>)
 8028fcc:	f002 fd92 	bl	802baf4 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_0|GPIO_PIN_10|GPIO_PIN_7;
 8028fd0:	f640 4381 	movw	r3, #3201	; 0xc81
 8028fd4:	617b      	str	r3, [r7, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8028fd6:	2301      	movs	r3, #1
 8028fd8:	61bb      	str	r3, [r7, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8028fda:	2300      	movs	r3, #0
 8028fdc:	61fb      	str	r3, [r7, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8028fde:	2300      	movs	r3, #0
 8028fe0:	623b      	str	r3, [r7, #32]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8028fe2:	f107 0314 	add.w	r3, r7, #20
 8028fe6:	4619      	mov	r1, r3
 8028fe8:	4806      	ldr	r0, [pc, #24]	; (8029004 <MX_GPIO_Init+0x114>)
 8028fea:	f002 fd83 	bl	802baf4 <HAL_GPIO_Init>

}
 8028fee:	bf00      	nop
 8028ff0:	3728      	adds	r7, #40	; 0x28
 8028ff2:	46bd      	mov	sp, r7
 8028ff4:	bd80      	pop	{r7, pc}
 8028ff6:	bf00      	nop
 8028ff8:	40023800 	.word	0x40023800
 8028ffc:	40020000 	.word	0x40020000
 8029000:	40020400 	.word	0x40020400
 8029004:	40020800 	.word	0x40020800

08029008 <Buffer_Init>:

//Set struct My to zero after declaration
//Input My, pass by pointer
//Output NONE
void Buffer_Init(struct RxBuffer My[])
{
 8029008:	b580      	push	{r7, lr}
 802900a:	b084      	sub	sp, #16
 802900c:	af00      	add	r7, sp, #0
 802900e:	6078      	str	r0, [r7, #4]
	for(int i = 0; i<nIMUs; i++)
 8029010:	2300      	movs	r3, #0
 8029012:	60fb      	str	r3, [r7, #12]
 8029014:	e053      	b.n	80290be <Buffer_Init+0xb6>
	{
		memset (My[i].RxBuffer_OMX, 0, sizeof(My[i].RxBuffer_OMX));
 8029016:	68fb      	ldr	r3, [r7, #12]
 8029018:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802901c:	fb02 f303 	mul.w	r3, r2, r3
 8029020:	687a      	ldr	r2, [r7, #4]
 8029022:	4413      	add	r3, r2
 8029024:	22c8      	movs	r2, #200	; 0xc8
 8029026:	2100      	movs	r1, #0
 8029028:	4618      	mov	r0, r3
 802902a:	f006 f98d 	bl	802f348 <memset>
		memset (My[i].RxBuffer_OMY, 0, sizeof(My[i].RxBuffer_OMY));
 802902e:	68fb      	ldr	r3, [r7, #12]
 8029030:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029034:	fb02 f303 	mul.w	r3, r2, r3
 8029038:	687a      	ldr	r2, [r7, #4]
 802903a:	4413      	add	r3, r2
 802903c:	33c8      	adds	r3, #200	; 0xc8
 802903e:	22c8      	movs	r2, #200	; 0xc8
 8029040:	2100      	movs	r1, #0
 8029042:	4618      	mov	r0, r3
 8029044:	f006 f980 	bl	802f348 <memset>
		memset (My[i].RxBuffer_OMZ, 0, sizeof(My[i].RxBuffer_OMZ));
 8029048:	68fb      	ldr	r3, [r7, #12]
 802904a:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802904e:	fb02 f303 	mul.w	r3, r2, r3
 8029052:	687a      	ldr	r2, [r7, #4]
 8029054:	4413      	add	r3, r2
 8029056:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 802905a:	22c8      	movs	r2, #200	; 0xc8
 802905c:	2100      	movs	r1, #0
 802905e:	4618      	mov	r0, r3
 8029060:	f006 f972 	bl	802f348 <memset>
		memset (My[i].RxBuffer_AX,  0, sizeof(My[i].RxBuffer_AX));
 8029064:	68fb      	ldr	r3, [r7, #12]
 8029066:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 802906a:	fb02 f303 	mul.w	r3, r2, r3
 802906e:	687a      	ldr	r2, [r7, #4]
 8029070:	4413      	add	r3, r2
 8029072:	f503 7316 	add.w	r3, r3, #600	; 0x258
 8029076:	22c8      	movs	r2, #200	; 0xc8
 8029078:	2100      	movs	r1, #0
 802907a:	4618      	mov	r0, r3
 802907c:	f006 f964 	bl	802f348 <memset>
		memset (My[i].RxBuffer_AY,  0, sizeof(My[i].RxBuffer_AY));
 8029080:	68fb      	ldr	r3, [r7, #12]
 8029082:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 8029086:	fb02 f303 	mul.w	r3, r2, r3
 802908a:	687a      	ldr	r2, [r7, #4]
 802908c:	4413      	add	r3, r2
 802908e:	f503 7348 	add.w	r3, r3, #800	; 0x320
 8029092:	22c8      	movs	r2, #200	; 0xc8
 8029094:	2100      	movs	r1, #0
 8029096:	4618      	mov	r0, r3
 8029098:	f006 f956 	bl	802f348 <memset>
		memset (My[i].RxBuffer_AZ,  0, sizeof(My[i].RxBuffer_AZ));
 802909c:	68fb      	ldr	r3, [r7, #12]
 802909e:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
 80290a2:	fb02 f303 	mul.w	r3, r2, r3
 80290a6:	687a      	ldr	r2, [r7, #4]
 80290a8:	4413      	add	r3, r2
 80290aa:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80290ae:	22c8      	movs	r2, #200	; 0xc8
 80290b0:	2100      	movs	r1, #0
 80290b2:	4618      	mov	r0, r3
 80290b4:	f006 f948 	bl	802f348 <memset>
	for(int i = 0; i<nIMUs; i++)
 80290b8:	68fb      	ldr	r3, [r7, #12]
 80290ba:	3301      	adds	r3, #1
 80290bc:	60fb      	str	r3, [r7, #12]
 80290be:	68fb      	ldr	r3, [r7, #12]
 80290c0:	2b05      	cmp	r3, #5
 80290c2:	dda8      	ble.n	8029016 <Buffer_Init+0xe>
	}
}
 80290c4:	bf00      	nop
 80290c6:	3710      	adds	r7, #16
 80290c8:	46bd      	mov	sp, r7
 80290ca:	bd80      	pop	{r7, pc}

080290cc <Calib_Buffer_Init>:

void Calib_Buffer_Init(struct CalibBuffer My[])
{
 80290cc:	b580      	push	{r7, lr}
 80290ce:	b084      	sub	sp, #16
 80290d0:	af00      	add	r7, sp, #0
 80290d2:	6078      	str	r0, [r7, #4]
	for(int i = 0; i<nIMUs; i++)
 80290d4:	2300      	movs	r3, #0
 80290d6:	60fb      	str	r3, [r7, #12]
 80290d8:	e05a      	b.n	8029190 <Calib_Buffer_Init+0xc4>
	{
		memset (My[i].RxBuffer_OMX, 0, sizeof(My[i].RxBuffer_OMX));
 80290da:	68fb      	ldr	r3, [r7, #12]
 80290dc:	f44f 6216 	mov.w	r2, #2400	; 0x960
 80290e0:	fb02 f303 	mul.w	r3, r2, r3
 80290e4:	687a      	ldr	r2, [r7, #4]
 80290e6:	4413      	add	r3, r2
 80290e8:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80290ec:	2100      	movs	r1, #0
 80290ee:	4618      	mov	r0, r3
 80290f0:	f006 f92a 	bl	802f348 <memset>
		memset (My[i].RxBuffer_OMY, 0, sizeof(My[i].RxBuffer_OMY));
 80290f4:	68fb      	ldr	r3, [r7, #12]
 80290f6:	f44f 6216 	mov.w	r2, #2400	; 0x960
 80290fa:	fb02 f303 	mul.w	r3, r2, r3
 80290fe:	687a      	ldr	r2, [r7, #4]
 8029100:	4413      	add	r3, r2
 8029102:	f503 73c8 	add.w	r3, r3, #400	; 0x190
 8029106:	f44f 72c8 	mov.w	r2, #400	; 0x190
 802910a:	2100      	movs	r1, #0
 802910c:	4618      	mov	r0, r3
 802910e:	f006 f91b 	bl	802f348 <memset>
		memset (My[i].RxBuffer_OMZ, 0, sizeof(My[i].RxBuffer_OMZ));
 8029112:	68fb      	ldr	r3, [r7, #12]
 8029114:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029118:	fb02 f303 	mul.w	r3, r2, r3
 802911c:	687a      	ldr	r2, [r7, #4]
 802911e:	4413      	add	r3, r2
 8029120:	f503 7348 	add.w	r3, r3, #800	; 0x320
 8029124:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029128:	2100      	movs	r1, #0
 802912a:	4618      	mov	r0, r3
 802912c:	f006 f90c 	bl	802f348 <memset>
		memset (My[i].RxBuffer_AX,  0, sizeof(My[i].RxBuffer_AX));
 8029130:	68fb      	ldr	r3, [r7, #12]
 8029132:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029136:	fb02 f303 	mul.w	r3, r2, r3
 802913a:	687a      	ldr	r2, [r7, #4]
 802913c:	4413      	add	r3, r2
 802913e:	f503 6396 	add.w	r3, r3, #1200	; 0x4b0
 8029142:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029146:	2100      	movs	r1, #0
 8029148:	4618      	mov	r0, r3
 802914a:	f006 f8fd 	bl	802f348 <memset>
		memset (My[i].RxBuffer_AY,  0, sizeof(My[i].RxBuffer_AY));
 802914e:	68fb      	ldr	r3, [r7, #12]
 8029150:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029154:	fb02 f303 	mul.w	r3, r2, r3
 8029158:	687a      	ldr	r2, [r7, #4]
 802915a:	4413      	add	r3, r2
 802915c:	f503 63c8 	add.w	r3, r3, #1600	; 0x640
 8029160:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029164:	2100      	movs	r1, #0
 8029166:	4618      	mov	r0, r3
 8029168:	f006 f8ee 	bl	802f348 <memset>
		memset (My[i].RxBuffer_AZ,  0, sizeof(My[i].RxBuffer_AZ));
 802916c:	68fb      	ldr	r3, [r7, #12]
 802916e:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029172:	fb02 f303 	mul.w	r3, r2, r3
 8029176:	687a      	ldr	r2, [r7, #4]
 8029178:	4413      	add	r3, r2
 802917a:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 802917e:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8029182:	2100      	movs	r1, #0
 8029184:	4618      	mov	r0, r3
 8029186:	f006 f8df 	bl	802f348 <memset>
	for(int i = 0; i<nIMUs; i++)
 802918a:	68fb      	ldr	r3, [r7, #12]
 802918c:	3301      	adds	r3, #1
 802918e:	60fb      	str	r3, [r7, #12]
 8029190:	68fb      	ldr	r3, [r7, #12]
 8029192:	2b05      	cmp	r3, #5
 8029194:	dda1      	ble.n	80290da <Calib_Buffer_Init+0xe>
	}
}
 8029196:	bf00      	nop
 8029198:	3710      	adds	r7, #16
 802919a:	46bd      	mov	sp, r7
 802919c:	bd80      	pop	{r7, pc}
	...

080291a0 <chipSelection>:
}

//SPI chip selection
//Output: change CS GPIO globally
void chipSelection(int cs)
{
 80291a0:	b580      	push	{r7, lr}
 80291a2:	b082      	sub	sp, #8
 80291a4:	af00      	add	r7, sp, #0
 80291a6:	6078      	str	r0, [r7, #4]
	switch(cs)
 80291a8:	687b      	ldr	r3, [r7, #4]
 80291aa:	2b05      	cmp	r3, #5
 80291ac:	d86b      	bhi.n	8029286 <chipSelection+0xe6>
 80291ae:	a201      	add	r2, pc, #4	; (adr r2, 80291b4 <chipSelection+0x14>)
 80291b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80291b4:	080291cd 	.word	0x080291cd
 80291b8:	080291ed 	.word	0x080291ed
 80291bc:	0802920d 	.word	0x0802920d
 80291c0:	0802922d 	.word	0x0802922d
 80291c4:	0802924b 	.word	0x0802924b
 80291c8:	08029269 	.word	0x08029269
	{
	  case 0:
		  Ports = GPIOB;
 80291cc:	4b30      	ldr	r3, [pc, #192]	; (8029290 <chipSelection+0xf0>)
 80291ce:	4a31      	ldr	r2, [pc, #196]	; (8029294 <chipSelection+0xf4>)
 80291d0:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_15;
 80291d2:	4b31      	ldr	r3, [pc, #196]	; (8029298 <chipSelection+0xf8>)
 80291d4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80291d8:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 80291da:	4b2d      	ldr	r3, [pc, #180]	; (8029290 <chipSelection+0xf0>)
 80291dc:	6818      	ldr	r0, [r3, #0]
 80291de:	4b2e      	ldr	r3, [pc, #184]	; (8029298 <chipSelection+0xf8>)
 80291e0:	881b      	ldrh	r3, [r3, #0]
 80291e2:	2201      	movs	r2, #1
 80291e4:	4619      	mov	r1, r3
 80291e6:	f002 fe1f 	bl	802be28 <HAL_GPIO_WritePin>
		  break;
 80291ea:	e04c      	b.n	8029286 <chipSelection+0xe6>
	  case 1:
		  Ports = GPIOB;
 80291ec:	4b28      	ldr	r3, [pc, #160]	; (8029290 <chipSelection+0xf0>)
 80291ee:	4a29      	ldr	r2, [pc, #164]	; (8029294 <chipSelection+0xf4>)
 80291f0:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_14;
 80291f2:	4b29      	ldr	r3, [pc, #164]	; (8029298 <chipSelection+0xf8>)
 80291f4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80291f8:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 80291fa:	4b25      	ldr	r3, [pc, #148]	; (8029290 <chipSelection+0xf0>)
 80291fc:	6818      	ldr	r0, [r3, #0]
 80291fe:	4b26      	ldr	r3, [pc, #152]	; (8029298 <chipSelection+0xf8>)
 8029200:	881b      	ldrh	r3, [r3, #0]
 8029202:	2201      	movs	r2, #1
 8029204:	4619      	mov	r1, r3
 8029206:	f002 fe0f 	bl	802be28 <HAL_GPIO_WritePin>
		  break;
 802920a:	e03c      	b.n	8029286 <chipSelection+0xe6>
	  case 2:
		  Ports = GPIOB;
 802920c:	4b20      	ldr	r3, [pc, #128]	; (8029290 <chipSelection+0xf0>)
 802920e:	4a21      	ldr	r2, [pc, #132]	; (8029294 <chipSelection+0xf4>)
 8029210:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_13;
 8029212:	4b21      	ldr	r3, [pc, #132]	; (8029298 <chipSelection+0xf8>)
 8029214:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8029218:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 802921a:	4b1d      	ldr	r3, [pc, #116]	; (8029290 <chipSelection+0xf0>)
 802921c:	6818      	ldr	r0, [r3, #0]
 802921e:	4b1e      	ldr	r3, [pc, #120]	; (8029298 <chipSelection+0xf8>)
 8029220:	881b      	ldrh	r3, [r3, #0]
 8029222:	2201      	movs	r2, #1
 8029224:	4619      	mov	r1, r3
 8029226:	f002 fdff 	bl	802be28 <HAL_GPIO_WritePin>
		  break;
 802922a:	e02c      	b.n	8029286 <chipSelection+0xe6>
	  case 3:
		  Ports = GPIOB;
 802922c:	4b18      	ldr	r3, [pc, #96]	; (8029290 <chipSelection+0xf0>)
 802922e:	4a19      	ldr	r2, [pc, #100]	; (8029294 <chipSelection+0xf4>)
 8029230:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_3;
 8029232:	4b19      	ldr	r3, [pc, #100]	; (8029298 <chipSelection+0xf8>)
 8029234:	2208      	movs	r2, #8
 8029236:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029238:	4b15      	ldr	r3, [pc, #84]	; (8029290 <chipSelection+0xf0>)
 802923a:	6818      	ldr	r0, [r3, #0]
 802923c:	4b16      	ldr	r3, [pc, #88]	; (8029298 <chipSelection+0xf8>)
 802923e:	881b      	ldrh	r3, [r3, #0]
 8029240:	2201      	movs	r2, #1
 8029242:	4619      	mov	r1, r3
 8029244:	f002 fdf0 	bl	802be28 <HAL_GPIO_WritePin>
		  break;
 8029248:	e01d      	b.n	8029286 <chipSelection+0xe6>
	  case 4:
		  Ports = GPIOB;
 802924a:	4b11      	ldr	r3, [pc, #68]	; (8029290 <chipSelection+0xf0>)
 802924c:	4a11      	ldr	r2, [pc, #68]	; (8029294 <chipSelection+0xf4>)
 802924e:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_4;
 8029250:	4b11      	ldr	r3, [pc, #68]	; (8029298 <chipSelection+0xf8>)
 8029252:	2210      	movs	r2, #16
 8029254:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029256:	4b0e      	ldr	r3, [pc, #56]	; (8029290 <chipSelection+0xf0>)
 8029258:	6818      	ldr	r0, [r3, #0]
 802925a:	4b0f      	ldr	r3, [pc, #60]	; (8029298 <chipSelection+0xf8>)
 802925c:	881b      	ldrh	r3, [r3, #0]
 802925e:	2201      	movs	r2, #1
 8029260:	4619      	mov	r1, r3
 8029262:	f002 fde1 	bl	802be28 <HAL_GPIO_WritePin>
		  break;
 8029266:	e00e      	b.n	8029286 <chipSelection+0xe6>
	  case 5:
		  Ports = GPIOB;
 8029268:	4b09      	ldr	r3, [pc, #36]	; (8029290 <chipSelection+0xf0>)
 802926a:	4a0a      	ldr	r2, [pc, #40]	; (8029294 <chipSelection+0xf4>)
 802926c:	601a      	str	r2, [r3, #0]
		  Pins = GPIO_PIN_5;
 802926e:	4b0a      	ldr	r3, [pc, #40]	; (8029298 <chipSelection+0xf8>)
 8029270:	2220      	movs	r2, #32
 8029272:	801a      	strh	r2, [r3, #0]
		  HAL_GPIO_WritePin(Ports, Pins, GPIO_PIN_SET );
 8029274:	4b06      	ldr	r3, [pc, #24]	; (8029290 <chipSelection+0xf0>)
 8029276:	6818      	ldr	r0, [r3, #0]
 8029278:	4b07      	ldr	r3, [pc, #28]	; (8029298 <chipSelection+0xf8>)
 802927a:	881b      	ldrh	r3, [r3, #0]
 802927c:	2201      	movs	r2, #1
 802927e:	4619      	mov	r1, r3
 8029280:	f002 fdd2 	bl	802be28 <HAL_GPIO_WritePin>
		  break;
 8029284:	bf00      	nop
	}
}
 8029286:	bf00      	nop
 8029288:	3708      	adds	r7, #8
 802928a:	46bd      	mov	sp, r7
 802928c:	bd80      	pop	{r7, pc}
 802928e:	bf00      	nop
 8029290:	20001518 	.word	0x20001518
 8029294:	40020400 	.word	0x40020400
 8029298:	2000151c 	.word	0x2000151c

0802929c <resetAll>:
//Reset configuration for all IMUs on the board (not just ones in use)
//Wait 5ms for proper reset
void resetAll()
{
 802929c:	b580      	push	{r7, lr}
 802929e:	b082      	sub	sp, #8
 80292a0:	af00      	add	r7, sp, #0
	//for(int i =0; i<nIMUs;i++)
//	for(int i = nIMUs-1; i>=0; i--)
	for(int i = 5; i>=0; i--)
 80292a2:	2305      	movs	r3, #5
 80292a4:	607b      	str	r3, [r7, #4]
 80292a6:	e010      	b.n	80292ca <resetAll+0x2e>
	{
		chipSelection(i);
 80292a8:	6878      	ldr	r0, [r7, #4]
 80292aa:	f7ff ff79 	bl	80291a0 <chipSelection>
		IMU_reset(Ports, Pins);
 80292ae:	4b0a      	ldr	r3, [pc, #40]	; (80292d8 <resetAll+0x3c>)
 80292b0:	681a      	ldr	r2, [r3, #0]
 80292b2:	4b0a      	ldr	r3, [pc, #40]	; (80292dc <resetAll+0x40>)
 80292b4:	881b      	ldrh	r3, [r3, #0]
 80292b6:	4619      	mov	r1, r3
 80292b8:	4610      	mov	r0, r2
 80292ba:	f000 f919 	bl	80294f0 <IMU_reset>
		HAL_Delay(5);
 80292be:	2005      	movs	r0, #5
 80292c0:	f001 ff54 	bl	802b16c <HAL_Delay>
	for(int i = 5; i>=0; i--)
 80292c4:	687b      	ldr	r3, [r7, #4]
 80292c6:	3b01      	subs	r3, #1
 80292c8:	607b      	str	r3, [r7, #4]
 80292ca:	687b      	ldr	r3, [r7, #4]
 80292cc:	2b00      	cmp	r3, #0
 80292ce:	daeb      	bge.n	80292a8 <resetAll+0xc>
	}
}
 80292d0:	bf00      	nop
 80292d2:	3708      	adds	r7, #8
 80292d4:	46bd      	mov	sp, r7
 80292d6:	bd80      	pop	{r7, pc}
 80292d8:	20001518 	.word	0x20001518
 80292dc:	2000151c 	.word	0x2000151c

080292e0 <setupAll>:
//Configure all IMUs on the board (not just ones in use)
void setupAll()
{
 80292e0:	b580      	push	{r7, lr}
 80292e2:	b082      	sub	sp, #8
 80292e4:	af00      	add	r7, sp, #0
	//for (int i = 0; i<nIMUs; i++)
//	for(int i = nIMUs-1; i>=0; i--)
	for(int i = 5; i>=0; i--)
 80292e6:	2305      	movs	r3, #5
 80292e8:	607b      	str	r3, [r7, #4]
 80292ea:	e02d      	b.n	8029348 <setupAll+0x68>
	{
		chipSelection(i);
 80292ec:	6878      	ldr	r0, [r7, #4]
 80292ee:	f7ff ff57 	bl	80291a0 <chipSelection>
		IMU_config(Ports, Pins);
 80292f2:	4b19      	ldr	r3, [pc, #100]	; (8029358 <setupAll+0x78>)
 80292f4:	681a      	ldr	r2, [r3, #0]
 80292f6:	4b19      	ldr	r3, [pc, #100]	; (802935c <setupAll+0x7c>)
 80292f8:	881b      	ldrh	r3, [r3, #0]
 80292fa:	4619      	mov	r1, r3
 80292fc:	4610      	mov	r0, r2
 80292fe:	f000 f89f 	bl	8029440 <IMU_config>
		PEDO_config(Ports, Pins);
 8029302:	4b15      	ldr	r3, [pc, #84]	; (8029358 <setupAll+0x78>)
 8029304:	681a      	ldr	r2, [r3, #0]
 8029306:	4b15      	ldr	r3, [pc, #84]	; (802935c <setupAll+0x7c>)
 8029308:	881b      	ldrh	r3, [r3, #0]
 802930a:	4619      	mov	r1, r3
 802930c:	4610      	mov	r0, r2
 802930e:	f000 f827 	bl	8029360 <PEDO_config>
		TimeStamp_config(Ports, Pins);
 8029312:	4b11      	ldr	r3, [pc, #68]	; (8029358 <setupAll+0x78>)
 8029314:	681a      	ldr	r2, [r3, #0]
 8029316:	4b11      	ldr	r3, [pc, #68]	; (802935c <setupAll+0x7c>)
 8029318:	881b      	ldrh	r3, [r3, #0]
 802931a:	4619      	mov	r1, r3
 802931c:	4610      	mov	r0, r2
 802931e:	f000 f93f 	bl	80295a0 <TimeStamp_config>
		INTTrigger(Ports, Pins);											//Sync ODR with PWM
 8029322:	4b0d      	ldr	r3, [pc, #52]	; (8029358 <setupAll+0x78>)
 8029324:	681a      	ldr	r2, [r3, #0]
 8029326:	4b0d      	ldr	r3, [pc, #52]	; (802935c <setupAll+0x7c>)
 8029328:	881b      	ldrh	r3, [r3, #0]
 802932a:	4619      	mov	r1, r3
 802932c:	4610      	mov	r0, r2
 802932e:	f000 f985 	bl	802963c <INTTrigger>
		FIFO_config(Ports, Pins);
 8029332:	4b09      	ldr	r3, [pc, #36]	; (8029358 <setupAll+0x78>)
 8029334:	681a      	ldr	r2, [r3, #0]
 8029336:	4b09      	ldr	r3, [pc, #36]	; (802935c <setupAll+0x7c>)
 8029338:	881b      	ldrh	r3, [r3, #0]
 802933a:	4619      	mov	r1, r3
 802933c:	4610      	mov	r0, r2
 802933e:	f000 f9c3 	bl	80296c8 <FIFO_config>
	for(int i = 5; i>=0; i--)
 8029342:	687b      	ldr	r3, [r7, #4]
 8029344:	3b01      	subs	r3, #1
 8029346:	607b      	str	r3, [r7, #4]
 8029348:	687b      	ldr	r3, [r7, #4]
 802934a:	2b00      	cmp	r3, #0
 802934c:	dace      	bge.n	80292ec <setupAll+0xc>
	}
}
 802934e:	bf00      	nop
 8029350:	3708      	adds	r7, #8
 8029352:	46bd      	mov	sp, r7
 8029354:	bd80      	pop	{r7, pc}
 8029356:	bf00      	nop
 8029358:	20001518 	.word	0x20001518
 802935c:	2000151c 	.word	0x2000151c

08029360 <PEDO_config>:
	return (int16_t)((uint8_t)(temp[1])<<8 | (uint8_t)(temp[0]));
}


void PEDO_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 8029360:	b580      	push	{r7, lr}
 8029362:	b090      	sub	sp, #64	; 0x40
 8029364:	af00      	add	r7, sp, #0
 8029366:	6078      	str	r0, [r7, #4]
 8029368:	460b      	mov	r3, r1
 802936a:	807b      	strh	r3, [r7, #2]
	uint16_t add[2] = {(0x80|CTRL10_C<<8),(0x80|INT1_CTRL<<8)};
 802936c:	4b31      	ldr	r3, [pc, #196]	; (8029434 <PEDO_config+0xd4>)
 802936e:	681b      	ldr	r3, [r3, #0]
 8029370:	63bb      	str	r3, [r7, #56]	; 0x38
	uint8_t r1[1] = {0};
 8029372:	2300      	movs	r3, #0
 8029374:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
	spi_RX(&add[0],r1,Port,Pin);
 8029378:	887b      	ldrh	r3, [r7, #2]
 802937a:	f107 0134 	add.w	r1, r7, #52	; 0x34
 802937e:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8029382:	687a      	ldr	r2, [r7, #4]
 8029384:	f001 f9e8 	bl	802a758 <spi_RX>
	uint8_t r2[1] = {0};
 8029388:	2300      	movs	r3, #0
 802938a:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
	spi_RX(&add[1],r2,Port,Pin);
 802938e:	887a      	ldrh	r2, [r7, #2]
 8029390:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8029394:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8029398:	1c98      	adds	r0, r3, #2
 802939a:	4613      	mov	r3, r2
 802939c:	687a      	ldr	r2, [r7, #4]
 802939e:	f001 f9db 	bl	802a758 <spi_RX>
	uint16_t pedo_config[6]  	= {
 80293a2:	4a25      	ldr	r2, [pc, #148]	; (8029438 <PEDO_config+0xd8>)
 80293a4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80293a8:	ca07      	ldmia	r2, {r0, r1, r2}
 80293aa:	e883 0007 	stmia.w	r3, {r0, r1, r2}
									(FUNC_CFG_ACCESS<<8|0x00),
									(CTRL1_XL<<8|accelcfg16k),///changed
									(CTRL10_C<<8|0b00110100),
									(INT1_CTRL<<8|0b10111011)
									};
	uint16_t pedo_configcheck[6] = {
 80293ae:	4a23      	ldr	r2, [pc, #140]	; (802943c <PEDO_config+0xdc>)
 80293b0:	f107 0318 	add.w	r3, r7, #24
 80293b4:	ca07      	ldmia	r2, {r0, r1, r2}
 80293b6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
									((0x80|CTRL1_XL)<<8),
								    ((0x80|CTRL10_C)<<8),
									((0x80|INT1_CTRL)<<8)
									};

	uint8_t shouldbe[6] = {0};											//The actual configuration we write to register
 80293ba:	f107 0310 	add.w	r3, r7, #16
 80293be:	2200      	movs	r2, #0
 80293c0:	601a      	str	r2, [r3, #0]
 80293c2:	809a      	strh	r2, [r3, #4]
	uint8_t actual_16[6] = {0};											//The actual configuration we read from register
 80293c4:	f107 0308 	add.w	r3, r7, #8
 80293c8:	2200      	movs	r2, #0
 80293ca:	601a      	str	r2, [r3, #0]
 80293cc:	809a      	strh	r2, [r3, #4]

	for(int i = 0; i < 6; i ++)
 80293ce:	2300      	movs	r3, #0
 80293d0:	63fb      	str	r3, [r7, #60]	; 0x3c
 80293d2:	e027      	b.n	8029424 <PEDO_config+0xc4>
	{
		spi_write(&pedo_config[i],Port,Pin);
 80293d4:	f107 0224 	add.w	r2, r7, #36	; 0x24
 80293d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80293da:	005b      	lsls	r3, r3, #1
 80293dc:	4413      	add	r3, r2
 80293de:	887a      	ldrh	r2, [r7, #2]
 80293e0:	6879      	ldr	r1, [r7, #4]
 80293e2:	4618      	mov	r0, r3
 80293e4:	f001 f9e0 	bl	802a7a8 <spi_write>
		spi_RX(&pedo_configcheck[i], &actual_16[i],Port,Pin);
 80293e8:	f107 0218 	add.w	r2, r7, #24
 80293ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80293ee:	005b      	lsls	r3, r3, #1
 80293f0:	18d0      	adds	r0, r2, r3
 80293f2:	f107 0208 	add.w	r2, r7, #8
 80293f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80293f8:	18d1      	adds	r1, r2, r3
 80293fa:	887b      	ldrh	r3, [r7, #2]
 80293fc:	687a      	ldr	r2, [r7, #4]
 80293fe:	f001 f9ab 	bl	802a758 <spi_RX>
		shouldbe[i] = pedo_config[i];
 8029402:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8029404:	005b      	lsls	r3, r3, #1
 8029406:	f107 0240 	add.w	r2, r7, #64	; 0x40
 802940a:	4413      	add	r3, r2
 802940c:	f833 3c1c 	ldrh.w	r3, [r3, #-28]
 8029410:	b2d9      	uxtb	r1, r3
 8029412:	f107 0210 	add.w	r2, r7, #16
 8029416:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8029418:	4413      	add	r3, r2
 802941a:	460a      	mov	r2, r1
 802941c:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i < 6; i ++)
 802941e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8029420:	3301      	adds	r3, #1
 8029422:	63fb      	str	r3, [r7, #60]	; 0x3c
 8029424:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8029426:	2b05      	cmp	r3, #5
 8029428:	ddd4      	ble.n	80293d4 <PEDO_config+0x74>
	}
}
 802942a:	bf00      	nop
 802942c:	3740      	adds	r7, #64	; 0x40
 802942e:	46bd      	mov	sp, r7
 8029430:	bd80      	pop	{r7, pc}
 8029432:	bf00      	nop
 8029434:	080300cc 	.word	0x080300cc
 8029438:	080300d0 	.word	0x080300d0
 802943c:	080300dc 	.word	0x080300dc

08029440 <IMU_config>:



void IMU_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 8029440:	b5b0      	push	{r4, r5, r7, lr}
 8029442:	b094      	sub	sp, #80	; 0x50
 8029444:	af00      	add	r7, sp, #0
 8029446:	6078      	str	r0, [r7, #4]
 8029448:	460b      	mov	r3, r1
 802944a:	807b      	strh	r3, [r7, #2]
	uint16_t IMU_configbuffer[9] 	  = {(INT1_CTRL<<8|intctrl),
 802944c:	4b26      	ldr	r3, [pc, #152]	; (80294e8 <IMU_config+0xa8>)
 802944e:	f107 0438 	add.w	r4, r7, #56	; 0x38
 8029452:	461d      	mov	r5, r3
 8029454:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8029456:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8029458:	682b      	ldr	r3, [r5, #0]
 802945a:	8023      	strh	r3, [r4, #0]
											(CTRL6_C<<8|ctrl6),
											(CTRL3_C<<8|ctrl3),
											(CTRL5_C<<8|ctrl5),
											(CTRL8_XL<<8|ctrl8cfg),
											(MASTER_CONFIG<<8|MASTER_SENSOR)};
	uint16_t IMU_configbuffercheck[9] = {((0x80|INT1_CTRL)<<8),
 802945c:	4b23      	ldr	r3, [pc, #140]	; (80294ec <IMU_config+0xac>)
 802945e:	f107 0424 	add.w	r4, r7, #36	; 0x24
 8029462:	461d      	mov	r5, r3
 8029464:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8029466:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8029468:	682b      	ldr	r3, [r5, #0]
 802946a:	8023      	strh	r3, [r4, #0]
											((0x80|CTRL3_C)<<8),
											((0x80|CTRL5_C)<<8),
											((0x80|CTRL8_XL)<<8),
											((0x80|MASTER_CONFIG)<<8)};

	uint8_t shouldbe[9] = {0};											//The actual configuration we write to register
 802946c:	f107 0318 	add.w	r3, r7, #24
 8029470:	2200      	movs	r2, #0
 8029472:	601a      	str	r2, [r3, #0]
 8029474:	605a      	str	r2, [r3, #4]
 8029476:	721a      	strb	r2, [r3, #8]
	uint8_t actual_16[9] = {0};										    //The actual configuration we read from register
 8029478:	f107 030c 	add.w	r3, r7, #12
 802947c:	2200      	movs	r2, #0
 802947e:	601a      	str	r2, [r3, #0]
 8029480:	605a      	str	r2, [r3, #4]
 8029482:	721a      	strb	r2, [r3, #8]
	for (int i =0; i<9;i++)
 8029484:	2300      	movs	r3, #0
 8029486:	64fb      	str	r3, [r7, #76]	; 0x4c
 8029488:	e027      	b.n	80294da <IMU_config+0x9a>
	{
		spi_write(&IMU_configbuffer[i],Port,Pin);
 802948a:	f107 0238 	add.w	r2, r7, #56	; 0x38
 802948e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029490:	005b      	lsls	r3, r3, #1
 8029492:	4413      	add	r3, r2
 8029494:	887a      	ldrh	r2, [r7, #2]
 8029496:	6879      	ldr	r1, [r7, #4]
 8029498:	4618      	mov	r0, r3
 802949a:	f001 f985 	bl	802a7a8 <spi_write>
		spi_RX(&IMU_configbuffercheck[i], &actual_16[i],Port,Pin);
 802949e:	f107 0224 	add.w	r2, r7, #36	; 0x24
 80294a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294a4:	005b      	lsls	r3, r3, #1
 80294a6:	18d0      	adds	r0, r2, r3
 80294a8:	f107 020c 	add.w	r2, r7, #12
 80294ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294ae:	18d1      	adds	r1, r2, r3
 80294b0:	887b      	ldrh	r3, [r7, #2]
 80294b2:	687a      	ldr	r2, [r7, #4]
 80294b4:	f001 f950 	bl	802a758 <spi_RX>
		shouldbe[i] = IMU_configbuffer[i];
 80294b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294ba:	005b      	lsls	r3, r3, #1
 80294bc:	f107 0250 	add.w	r2, r7, #80	; 0x50
 80294c0:	4413      	add	r3, r2
 80294c2:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 80294c6:	b2d9      	uxtb	r1, r3
 80294c8:	f107 0218 	add.w	r2, r7, #24
 80294cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294ce:	4413      	add	r3, r2
 80294d0:	460a      	mov	r2, r1
 80294d2:	701a      	strb	r2, [r3, #0]
	for (int i =0; i<9;i++)
 80294d4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294d6:	3301      	adds	r3, #1
 80294d8:	64fb      	str	r3, [r7, #76]	; 0x4c
 80294da:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80294dc:	2b08      	cmp	r3, #8
 80294de:	ddd4      	ble.n	802948a <IMU_config+0x4a>
	}
}
 80294e0:	bf00      	nop
 80294e2:	3750      	adds	r7, #80	; 0x50
 80294e4:	46bd      	mov	sp, r7
 80294e6:	bdb0      	pop	{r4, r5, r7, pc}
 80294e8:	080300e8 	.word	0x080300e8
 80294ec:	080300fc 	.word	0x080300fc

080294f0 <IMU_reset>:


void IMU_reset(GPIO_TypeDef* Port, uint16_t Pin)
{
 80294f0:	b580      	push	{r7, lr}
 80294f2:	b08a      	sub	sp, #40	; 0x28
 80294f4:	af00      	add	r7, sp, #0
 80294f6:	6078      	str	r0, [r7, #4]
 80294f8:	460b      	mov	r3, r1
 80294fa:	807b      	strh	r3, [r7, #2]
	uint16_t reset_buffer[3] = {(CTRL3_C<<8|0b10000001),
 80294fc:	4a26      	ldr	r2, [pc, #152]	; (8029598 <IMU_reset+0xa8>)
 80294fe:	f107 031c 	add.w	r3, r7, #28
 8029502:	e892 0003 	ldmia.w	r2, {r0, r1}
 8029506:	6018      	str	r0, [r3, #0]
 8029508:	3304      	adds	r3, #4
 802950a:	8019      	strh	r1, [r3, #0]
								(CTRL10_C<<8|ctrl10_pedo_reset),
								(TIMESTAMP2_REG<<8|timerreset),

								};
	uint16_t reset_buffercheck[3] = {
 802950c:	4a23      	ldr	r2, [pc, #140]	; (802959c <IMU_reset+0xac>)
 802950e:	f107 0314 	add.w	r3, r7, #20
 8029512:	e892 0003 	ldmia.w	r2, {r0, r1}
 8029516:	6018      	str	r0, [r3, #0]
 8029518:	3304      	adds	r3, #4
 802951a:	8019      	strh	r1, [r3, #0]
									((0x80|CTRL3_C)<<8),
									((0x80|CTRL10_C)<<8),
									((0x80|TIMESTAMP2_REG)<<8),

									};
	uint8_t shouldbe[3] = {0,0,0};									//The actual configuration we write to register
 802951c:	2300      	movs	r3, #0
 802951e:	743b      	strb	r3, [r7, #16]
 8029520:	2300      	movs	r3, #0
 8029522:	747b      	strb	r3, [r7, #17]
 8029524:	2300      	movs	r3, #0
 8029526:	74bb      	strb	r3, [r7, #18]
	uint8_t actual_16[3] = {0,0,0};									//The actual configuration we read from register
 8029528:	2300      	movs	r3, #0
 802952a:	733b      	strb	r3, [r7, #12]
 802952c:	2300      	movs	r3, #0
 802952e:	737b      	strb	r3, [r7, #13]
 8029530:	2300      	movs	r3, #0
 8029532:	73bb      	strb	r3, [r7, #14]

	for (int i =0; i<3;i++)
 8029534:	2300      	movs	r3, #0
 8029536:	627b      	str	r3, [r7, #36]	; 0x24
 8029538:	e027      	b.n	802958a <IMU_reset+0x9a>
	{
		spi_write(&reset_buffer[i],Port,Pin);
 802953a:	f107 021c 	add.w	r2, r7, #28
 802953e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029540:	005b      	lsls	r3, r3, #1
 8029542:	4413      	add	r3, r2
 8029544:	887a      	ldrh	r2, [r7, #2]
 8029546:	6879      	ldr	r1, [r7, #4]
 8029548:	4618      	mov	r0, r3
 802954a:	f001 f92d 	bl	802a7a8 <spi_write>
		spi_RX(&reset_buffercheck[i], &actual_16[i],Port,Pin);
 802954e:	f107 0214 	add.w	r2, r7, #20
 8029552:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029554:	005b      	lsls	r3, r3, #1
 8029556:	18d0      	adds	r0, r2, r3
 8029558:	f107 020c 	add.w	r2, r7, #12
 802955c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802955e:	18d1      	adds	r1, r2, r3
 8029560:	887b      	ldrh	r3, [r7, #2]
 8029562:	687a      	ldr	r2, [r7, #4]
 8029564:	f001 f8f8 	bl	802a758 <spi_RX>
		shouldbe[i] = reset_buffer[i];
 8029568:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802956a:	005b      	lsls	r3, r3, #1
 802956c:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8029570:	4413      	add	r3, r2
 8029572:	f833 3c0c 	ldrh.w	r3, [r3, #-12]
 8029576:	b2d9      	uxtb	r1, r3
 8029578:	f107 0210 	add.w	r2, r7, #16
 802957c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802957e:	4413      	add	r3, r2
 8029580:	460a      	mov	r2, r1
 8029582:	701a      	strb	r2, [r3, #0]
	for (int i =0; i<3;i++)
 8029584:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029586:	3301      	adds	r3, #1
 8029588:	627b      	str	r3, [r7, #36]	; 0x24
 802958a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802958c:	2b02      	cmp	r3, #2
 802958e:	ddd4      	ble.n	802953a <IMU_reset+0x4a>
	}
}
 8029590:	bf00      	nop
 8029592:	3728      	adds	r7, #40	; 0x28
 8029594:	46bd      	mov	sp, r7
 8029596:	bd80      	pop	{r7, pc}
 8029598:	08030110 	.word	0x08030110
 802959c:	08030118 	.word	0x08030118

080295a0 <TimeStamp_config>:



void TimeStamp_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 80295a0:	b580      	push	{r7, lr}
 80295a2:	b08a      	sub	sp, #40	; 0x28
 80295a4:	af00      	add	r7, sp, #0
 80295a6:	6078      	str	r0, [r7, #4]
 80295a8:	460b      	mov	r3, r1
 80295aa:	807b      	strh	r3, [r7, #2]
	uint16_t timestamp_buffer[4] 	=  {(CTRL1_XL<<8|0b11111100),
 80295ac:	4a21      	ldr	r2, [pc, #132]	; (8029634 <TimeStamp_config+0x94>)
 80295ae:	f107 031c 	add.w	r3, r7, #28
 80295b2:	e892 0003 	ldmia.w	r2, {r0, r1}
 80295b6:	e883 0003 	stmia.w	r3, {r0, r1}
										(WAKE_UP_DUR<<8|wakeupcfg),
										(CTRL10_C<<8|0b110100),
										(MD1_CFG<<8|mdcfg)};

	uint16_t timestamp_buffercheck[4] = {((0x80|CTRL1_XL)<<8),
 80295ba:	4a1f      	ldr	r2, [pc, #124]	; (8029638 <TimeStamp_config+0x98>)
 80295bc:	f107 0314 	add.w	r3, r7, #20
 80295c0:	e892 0003 	ldmia.w	r2, {r0, r1}
 80295c4:	e883 0003 	stmia.w	r3, {r0, r1}
										((0x80|WAKE_UP_DUR)<<8),
										((0x80|CTRL10_C)<<8),
										((0x80|MD1_CFG)<<8)};
	uint8_t  shouldbe[4] = {0};											//The actual configuration we write to register
 80295c8:	2300      	movs	r3, #0
 80295ca:	613b      	str	r3, [r7, #16]
	uint8_t actual_16[4] = {0};											//The actual configuration we read from register
 80295cc:	2300      	movs	r3, #0
 80295ce:	60fb      	str	r3, [r7, #12]
	for(int i = 0; i < 4; i ++)
 80295d0:	2300      	movs	r3, #0
 80295d2:	627b      	str	r3, [r7, #36]	; 0x24
 80295d4:	e027      	b.n	8029626 <TimeStamp_config+0x86>
	{
		spi_write(&timestamp_buffer[i],Port,Pin);
 80295d6:	f107 021c 	add.w	r2, r7, #28
 80295da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80295dc:	005b      	lsls	r3, r3, #1
 80295de:	4413      	add	r3, r2
 80295e0:	887a      	ldrh	r2, [r7, #2]
 80295e2:	6879      	ldr	r1, [r7, #4]
 80295e4:	4618      	mov	r0, r3
 80295e6:	f001 f8df 	bl	802a7a8 <spi_write>
		spi_RX(&timestamp_buffercheck[i], &actual_16[i],Port,Pin);
 80295ea:	f107 0214 	add.w	r2, r7, #20
 80295ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80295f0:	005b      	lsls	r3, r3, #1
 80295f2:	18d0      	adds	r0, r2, r3
 80295f4:	f107 020c 	add.w	r2, r7, #12
 80295f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80295fa:	18d1      	adds	r1, r2, r3
 80295fc:	887b      	ldrh	r3, [r7, #2]
 80295fe:	687a      	ldr	r2, [r7, #4]
 8029600:	f001 f8aa 	bl	802a758 <spi_RX>
		shouldbe[i] = timestamp_buffer[i];
 8029604:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029606:	005b      	lsls	r3, r3, #1
 8029608:	f107 0228 	add.w	r2, r7, #40	; 0x28
 802960c:	4413      	add	r3, r2
 802960e:	f833 3c0c 	ldrh.w	r3, [r3, #-12]
 8029612:	b2d9      	uxtb	r1, r3
 8029614:	f107 0210 	add.w	r2, r7, #16
 8029618:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802961a:	4413      	add	r3, r2
 802961c:	460a      	mov	r2, r1
 802961e:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i < 4; i ++)
 8029620:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029622:	3301      	adds	r3, #1
 8029624:	627b      	str	r3, [r7, #36]	; 0x24
 8029626:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029628:	2b03      	cmp	r3, #3
 802962a:	ddd4      	ble.n	80295d6 <TimeStamp_config+0x36>
	}
}
 802962c:	bf00      	nop
 802962e:	3728      	adds	r7, #40	; 0x28
 8029630:	46bd      	mov	sp, r7
 8029632:	bd80      	pop	{r7, pc}
 8029634:	08030120 	.word	0x08030120
 8029638:	08030128 	.word	0x08030128

0802963c <INTTrigger>:
//Sync ODR with PWM
void INTTrigger(GPIO_TypeDef* Port, uint16_t Pin)
{
 802963c:	b580      	push	{r7, lr}
 802963e:	b088      	sub	sp, #32
 8029640:	af00      	add	r7, sp, #0
 8029642:	6078      	str	r0, [r7, #4]
 8029644:	460b      	mov	r3, r1
 8029646:	807b      	strh	r3, [r7, #2]
	uint16_t INTTrigger_buffer[2] = {
 8029648:	4b1d      	ldr	r3, [pc, #116]	; (80296c0 <INTTrigger+0x84>)
 802964a:	681b      	ldr	r3, [r3, #0]
 802964c:	61bb      	str	r3, [r7, #24]
			(CTRL6_C<<8|ctrl6edge),
			(CTRL4_C<<8|ctrl4)
				};
	uint16_t INTTrigger_checkbuffer[2] = {
 802964e:	4b1d      	ldr	r3, [pc, #116]	; (80296c4 <INTTrigger+0x88>)
 8029650:	681b      	ldr	r3, [r3, #0]
 8029652:	617b      	str	r3, [r7, #20]
				((READ|CTRL6_C)<<8),
				((READ|CTRL4_C)<<8)
					};
	uint8_t  shouldbe[2] = {0};											//The actual configuration we write to register
 8029654:	2300      	movs	r3, #0
 8029656:	823b      	strh	r3, [r7, #16]
	uint8_t actual_16[2] = {0};											//The actual configuration we read from register
 8029658:	2300      	movs	r3, #0
 802965a:	81bb      	strh	r3, [r7, #12]
	for(int i = 0; i <2;i++)
 802965c:	2300      	movs	r3, #0
 802965e:	61fb      	str	r3, [r7, #28]
 8029660:	e027      	b.n	80296b2 <INTTrigger+0x76>
	{
		spi_write(&INTTrigger_buffer[i],Port,Pin);
 8029662:	f107 0218 	add.w	r2, r7, #24
 8029666:	69fb      	ldr	r3, [r7, #28]
 8029668:	005b      	lsls	r3, r3, #1
 802966a:	4413      	add	r3, r2
 802966c:	887a      	ldrh	r2, [r7, #2]
 802966e:	6879      	ldr	r1, [r7, #4]
 8029670:	4618      	mov	r0, r3
 8029672:	f001 f899 	bl	802a7a8 <spi_write>
		spi_RX(&INTTrigger_checkbuffer[i], &actual_16[i],Port,Pin);
 8029676:	f107 0214 	add.w	r2, r7, #20
 802967a:	69fb      	ldr	r3, [r7, #28]
 802967c:	005b      	lsls	r3, r3, #1
 802967e:	18d0      	adds	r0, r2, r3
 8029680:	f107 020c 	add.w	r2, r7, #12
 8029684:	69fb      	ldr	r3, [r7, #28]
 8029686:	18d1      	adds	r1, r2, r3
 8029688:	887b      	ldrh	r3, [r7, #2]
 802968a:	687a      	ldr	r2, [r7, #4]
 802968c:	f001 f864 	bl	802a758 <spi_RX>
		shouldbe[i] = INTTrigger_buffer[i];
 8029690:	69fb      	ldr	r3, [r7, #28]
 8029692:	005b      	lsls	r3, r3, #1
 8029694:	f107 0220 	add.w	r2, r7, #32
 8029698:	4413      	add	r3, r2
 802969a:	f833 3c08 	ldrh.w	r3, [r3, #-8]
 802969e:	b2d9      	uxtb	r1, r3
 80296a0:	f107 0210 	add.w	r2, r7, #16
 80296a4:	69fb      	ldr	r3, [r7, #28]
 80296a6:	4413      	add	r3, r2
 80296a8:	460a      	mov	r2, r1
 80296aa:	701a      	strb	r2, [r3, #0]
	for(int i = 0; i <2;i++)
 80296ac:	69fb      	ldr	r3, [r7, #28]
 80296ae:	3301      	adds	r3, #1
 80296b0:	61fb      	str	r3, [r7, #28]
 80296b2:	69fb      	ldr	r3, [r7, #28]
 80296b4:	2b01      	cmp	r3, #1
 80296b6:	ddd4      	ble.n	8029662 <INTTrigger+0x26>
	}


}
 80296b8:	bf00      	nop
 80296ba:	3720      	adds	r7, #32
 80296bc:	46bd      	mov	sp, r7
 80296be:	bd80      	pop	{r7, pc}
 80296c0:	08030130 	.word	0x08030130
 80296c4:	08030134 	.word	0x08030134

080296c8 <FIFO_config>:



void FIFO_config(GPIO_TypeDef* Port, uint16_t Pin)
{
 80296c8:	b5b0      	push	{r4, r5, r7, lr}
 80296ca:	b094      	sub	sp, #80	; 0x50
 80296cc:	af00      	add	r7, sp, #0
 80296ce:	6078      	str	r0, [r7, #4]
 80296d0:	460b      	mov	r3, r1
 80296d2:	807b      	strh	r3, [r7, #2]
	uint16_t FIFO_config[9]      =  {(FIFO_CTRL5<<8|fiforeset),
 80296d4:	4b26      	ldr	r3, [pc, #152]	; (8029770 <FIFO_config+0xa8>)
 80296d6:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80296da:	461d      	mov	r5, r3
 80296dc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80296de:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80296e0:	682b      	ldr	r3, [r5, #0]
 80296e2:	8023      	strh	r3, [r4, #0]
									(FIFO_CTRL3<<8|deccfgno),//deccfg833
									(FIFO_CTRL4<<8|notimestamp),//fifo4cfg),////notimestamp
									(FIFO_CTRL1<<8|0b11111011),
									(FIFO_CTRL2<<8|fifo2cfgNOts),
									(FIFO_CTRL5<<8|fifo16k)};
	uint16_t FIFO_configcheck[9] = {((0x80|FIFO_CTRL5)<<8),
 80296e4:	4b23      	ldr	r3, [pc, #140]	; (8029774 <FIFO_config+0xac>)
 80296e6:	f107 0424 	add.w	r4, r7, #36	; 0x24
 80296ea:	461d      	mov	r5, r3
 80296ec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80296ee:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80296f0:	682b      	ldr	r3, [r5, #0]
 80296f2:	8023      	strh	r3, [r4, #0]
									((0x80|FIFO_CTRL3)<<8),
									((0x80|FIFO_CTRL4)<<8),
									((0x80|FIFO_CTRL1)<<8),
									((0x80|FIFO_CTRL2)<<8),
									((0x80|FIFO_CTRL5)<<8)};
	uint8_t  shouldbe[9] = {0}; 									//The actual configuration we write to register
 80296f4:	f107 0318 	add.w	r3, r7, #24
 80296f8:	2200      	movs	r2, #0
 80296fa:	601a      	str	r2, [r3, #0]
 80296fc:	605a      	str	r2, [r3, #4]
 80296fe:	721a      	strb	r2, [r3, #8]
	uint8_t actual_16[9] = {0};										//The actual configuration we read from register
 8029700:	f107 030c 	add.w	r3, r7, #12
 8029704:	2200      	movs	r2, #0
 8029706:	601a      	str	r2, [r3, #0]
 8029708:	605a      	str	r2, [r3, #4]
 802970a:	721a      	strb	r2, [r3, #8]
	for (int i =0; i<9;i++)
 802970c:	2300      	movs	r3, #0
 802970e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8029710:	e027      	b.n	8029762 <FIFO_config+0x9a>
	{
		spi_write(&FIFO_config[i],Port,Pin);
 8029712:	f107 0238 	add.w	r2, r7, #56	; 0x38
 8029716:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029718:	005b      	lsls	r3, r3, #1
 802971a:	4413      	add	r3, r2
 802971c:	887a      	ldrh	r2, [r7, #2]
 802971e:	6879      	ldr	r1, [r7, #4]
 8029720:	4618      	mov	r0, r3
 8029722:	f001 f841 	bl	802a7a8 <spi_write>
		spi_RX(&FIFO_configcheck[i], &actual_16[i],Port,Pin);
 8029726:	f107 0224 	add.w	r2, r7, #36	; 0x24
 802972a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802972c:	005b      	lsls	r3, r3, #1
 802972e:	18d0      	adds	r0, r2, r3
 8029730:	f107 020c 	add.w	r2, r7, #12
 8029734:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029736:	18d1      	adds	r1, r2, r3
 8029738:	887b      	ldrh	r3, [r7, #2]
 802973a:	687a      	ldr	r2, [r7, #4]
 802973c:	f001 f80c 	bl	802a758 <spi_RX>

		shouldbe[i] = FIFO_config[i];
 8029740:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029742:	005b      	lsls	r3, r3, #1
 8029744:	f107 0250 	add.w	r2, r7, #80	; 0x50
 8029748:	4413      	add	r3, r2
 802974a:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 802974e:	b2d9      	uxtb	r1, r3
 8029750:	f107 0218 	add.w	r2, r7, #24
 8029754:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029756:	4413      	add	r3, r2
 8029758:	460a      	mov	r2, r1
 802975a:	701a      	strb	r2, [r3, #0]
	for (int i =0; i<9;i++)
 802975c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802975e:	3301      	adds	r3, #1
 8029760:	64fb      	str	r3, [r7, #76]	; 0x4c
 8029762:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8029764:	2b08      	cmp	r3, #8
 8029766:	ddd4      	ble.n	8029712 <FIFO_config+0x4a>
	}
}
 8029768:	bf00      	nop
 802976a:	3750      	adds	r7, #80	; 0x50
 802976c:	46bd      	mov	sp, r7
 802976e:	bdb0      	pop	{r4, r5, r7, pc}
 8029770:	08030138 	.word	0x08030138
 8029774:	0803014c 	.word	0x0803014c

08029778 <main>:
volatile int FSM_CHECKED_FLAG = 0;											// Ensure FSM is checked only once per callback
int DP_FLAG = 0;															// Start Data Processing Flag
#endif

int main(void)
{
 8029778:	b580      	push	{r7, lr}
 802977a:	f5ad 4da9 	sub.w	sp, sp, #21632	; 0x5480
 802977e:	b08a      	sub	sp, #40	; 0x28
 8029780:	af02      	add	r7, sp, #8
	HAL_Init();    															// Reset of all peripherals, Initializes the Flash interface and the Systick.
 8029782:	f001 fc81 	bl	802b088 <HAL_Init>
	SystemClock_Config();    												// Configure the system clock
 8029786:	f7ff f9f3 	bl	8028b70 <SystemClock_Config>
	MX_GPIO_Init();   														// Initialize all configured peripherals
 802978a:	f7ff fbb1 	bl	8028ef0 <MX_GPIO_Init>
	MX_DMA_Init();															// Initialize DMA UART and SPI,placed before protocol configuration
 802978e:	f001 fc19 	bl	802afc4 <MX_DMA_Init>
	MX_USART1_UART_Init();
 8029792:	f001 fbc3 	bl	802af1c <MX_USART1_UART_Init>
	MX_USART2_UART_Init();
 8029796:	f001 fbeb 	bl	802af70 <MX_USART2_UART_Init>
	//MX_TIM3_Init();														// PWM timer initialization
	MX_TIM4_Init();															// PWM timer initialization
 802979a:	f000 fedb 	bl	802a554 <MX_TIM4_Init>
	HAL_TIM_PWM_Stop(&htim4,TIM_CHANNEL_1);									// Initialize PWM to be stopped
 802979e:	2100      	movs	r1, #0
 80297a0:	486a      	ldr	r0, [pc, #424]	; (802994c <main+0x1d4>)
 80297a2:	f003 fecf 	bl	802d544 <HAL_TIM_PWM_Stop>
	MX_SPI1_Init();
 80297a6:	f000 ff4b 	bl	802a640 <MX_SPI1_Init>
	struct RxBuffer rawData[nIMUs];											// Input buffer for raw data
	struct CalibBuffer calibData[nIMUs];										// Input buffer for calibrated data
	Buffer_Init(rawData);													// Initialize buffer contents to zeros
 80297aa:	f507 5362 	add.w	r3, r7, #14464	; 0x3880
 80297ae:	3b08      	subs	r3, #8
 80297b0:	4618      	mov	r0, r3
 80297b2:	f7ff fc29 	bl	8029008 <Buffer_Init>
	Calib_Buffer_Init(calibData);
 80297b6:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 80297ba:	3b68      	subs	r3, #104	; 0x68
 80297bc:	4618      	mov	r0, r3
 80297be:	f7ff fc85 	bl	80290cc <Calib_Buffer_Init>
	int I[nIMUs];																// Declaration of buffer indices for each IMU
//	Indices_Init(&I);
	int rpNumbers_[nIMUs] = {0};											// rpNumber is to keep track the number of data left in the buffer(Mismatch)
 80297c2:	f107 0320 	add.w	r3, r7, #32
 80297c6:	3b18      	subs	r3, #24
 80297c8:	461a      	mov	r2, r3
 80297ca:	2300      	movs	r3, #0
 80297cc:	6013      	str	r3, [r2, #0]
 80297ce:	6053      	str	r3, [r2, #4]
 80297d0:	6093      	str	r3, [r2, #8]
 80297d2:	60d3      	str	r3, [r2, #12]
 80297d4:	6113      	str	r3, [r2, #16]
 80297d6:	6153      	str	r3, [r2, #20]
	int csCount=0;															// csCount is the ID of each IMU
 80297d8:	f107 0320 	add.w	r3, r7, #32
 80297dc:	3b1c      	subs	r3, #28
 80297de:	2200      	movs	r2, #0
 80297e0:	601a      	str	r2, [r3, #0]
	int fPWMStarted = 0;
 80297e2:	2300      	movs	r3, #0
 80297e4:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 80297e8:	f102 021c 	add.w	r2, r2, #28
 80297ec:	6013      	str	r3, [r2, #0]

	resetAll();																// Reset all IMU
 80297ee:	f7ff fd55 	bl	802929c <resetAll>
	setupAll();																// IMU configuration
 80297f2:	f7ff fd75 	bl	80292e0 <setupAll>
	CalibrationSetup();														// Set up calibration parameters
 80297f6:	f7ff f80f 	bl	8028818 <CalibrationSetup>
	#ifdef SPIDMA
	MX_SPI1_Init_8BIT();													// Initialize SPI with 8 bit per transmission for burst read
 80297fa:	f000 ff59 	bl	802a6b0 <MX_SPI1_Init_8BIT>
	spi_DMA_RX(FIFO_S2, EDMA,Ports,Pins,2);									// Read FIFO_S2 into EDMA to initialize FSM
 80297fe:	4b54      	ldr	r3, [pc, #336]	; (8029950 <main+0x1d8>)
 8029800:	681a      	ldr	r2, [r3, #0]
 8029802:	4b54      	ldr	r3, [pc, #336]	; (8029954 <main+0x1dc>)
 8029804:	8819      	ldrh	r1, [r3, #0]
 8029806:	2302      	movs	r3, #2
 8029808:	9300      	str	r3, [sp, #0]
 802980a:	460b      	mov	r3, r1
 802980c:	4952      	ldr	r1, [pc, #328]	; (8029958 <main+0x1e0>)
 802980e:	4853      	ldr	r0, [pc, #332]	; (802995c <main+0x1e4>)
 8029810:	f000 ff84 	bl	802a71c <spi_DMA_RX>
	#endif

	#ifdef LOCAL_PROCESS_TIMEOUT
	uint32_t timeout = HAL_GetTick() + (uint32_t)LOCAL_PROCESS_TIMEOUT;		//Time out program, change LOCAL_PROCESS_TIMEOUT to change the program duration
 8029814:	f001 fc9e 	bl	802b154 <HAL_GetTick>
 8029818:	4603      	mov	r3, r0
 802981a:	f503 43ea 	add.w	r3, r3, #29952	; 0x7500
 802981e:	3330      	adds	r3, #48	; 0x30
 8029820:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 8029824:	f102 0218 	add.w	r2, r2, #24
 8029828:	6013      	str	r3, [r2, #0]
	#endif
	//HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);								//PWM(GPIO C6) start, use to synchronize IMUs FIFO rate
//	while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15));								//Check if the Board Synchronization pin is pull up(Active high)
	//HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1);								//PWM(GPIO B6) start, use to synchronize IMUs FIFO rate

	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_SET);									// Turn on red LED
 802982a:	2201      	movs	r2, #1
 802982c:	2104      	movs	r1, #4
 802982e:	484c      	ldr	r0, [pc, #304]	; (8029960 <main+0x1e8>)
 8029830:	f002 fafa 	bl	802be28 <HAL_GPIO_WritePin>
		//SPI burst6 FIFO Max speed 1200-1300 Hz with current code


		#ifdef SPIDMA
		#ifdef LOCAL_PROCESS_TIMEOUT
		if(HAL_GetTick()<=timeout)
 8029834:	f001 fc8e 	bl	802b154 <HAL_GetTick>
 8029838:	4602      	mov	r2, r0
 802983a:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 802983e:	f103 0318 	add.w	r3, r3, #24
 8029842:	681b      	ldr	r3, [r3, #0]
 8029844:	4293      	cmp	r3, r2
 8029846:	d37b      	bcc.n	8029940 <main+0x1c8>
		{
		#endif
			switch(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15))
 8029848:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 802984c:	4845      	ldr	r0, [pc, #276]	; (8029964 <main+0x1ec>)
 802984e:	f002 fad3 	bl	802bdf8 <HAL_GPIO_ReadPin>
 8029852:	4603      	mov	r3, r0
 8029854:	2b00      	cmp	r3, #0
 8029856:	d05b      	beq.n	8029910 <main+0x198>
 8029858:	2b01      	cmp	r3, #1
 802985a:	d176      	bne.n	802994a <main+0x1d2>
			{
				case 1:
					if (!fPWMStarted)
 802985c:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 8029860:	f103 031c 	add.w	r3, r3, #28
 8029864:	681b      	ldr	r3, [r3, #0]
 8029866:	2b00      	cmp	r3, #0
 8029868:	d10e      	bne.n	8029888 <main+0x110>
					{
						HAL_TIM_PWM_Start(&htim4,TIM_CHANNEL_1);						//PWM(GPIO B6) start, use to synchronize IMUs FIFO rate
 802986a:	2100      	movs	r1, #0
 802986c:	4837      	ldr	r0, [pc, #220]	; (802994c <main+0x1d4>)
 802986e:	f003 fe37 	bl	802d4e0 <HAL_TIM_PWM_Start>
						fPWMStarted = 1;
 8029872:	2301      	movs	r3, #1
 8029874:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 8029878:	f102 021c 	add.w	r2, r2, #28
 802987c:	6013      	str	r3, [r2, #0]
						HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);			//Turn on green LED
 802987e:	2201      	movs	r2, #1
 8029880:	2102      	movs	r1, #2
 8029882:	4837      	ldr	r0, [pc, #220]	; (8029960 <main+0x1e8>)
 8029884:	f002 fad0 	bl	802be28 <HAL_GPIO_WritePin>
					}

					if (!FSM_CHECKED_FLAG) DMA_FSM_BURST6(&csCount, rawData, I);			//Option:DMA_FSM_BURST6(&csCount,rawData,&I); DMA_FSM_BURST2(&csCount,rawData,&I)
 8029888:	4b37      	ldr	r3, [pc, #220]	; (8029968 <main+0x1f0>)
 802988a:	681b      	ldr	r3, [r3, #0]
 802988c:	2b00      	cmp	r3, #0
 802988e:	d10a      	bne.n	80298a6 <main+0x12e>
 8029890:	f107 0220 	add.w	r2, r7, #32
 8029894:	f507 5162 	add.w	r1, r7, #14464	; 0x3880
 8029898:	3908      	subs	r1, #8
 802989a:	f107 0320 	add.w	r3, r7, #32
 802989e:	3b1c      	subs	r3, #28
 80298a0:	4618      	mov	r0, r3
 80298a2:	f7ff f9f7 	bl	8028c94 <DMA_FSM_BURST6>
																					//Notice: Make sure to change PWM rate at a right speed when switch to BURST2
																					//Otherwise: program is likely to enter hard fault interrupt because of buffer overflow
					if(DP_FLAG)														//Data retrieval completed (one set)
 80298a6:	4b31      	ldr	r3, [pc, #196]	; (802996c <main+0x1f4>)
 80298a8:	681b      	ldr	r3, [r3, #0]
 80298aa:	2b00      	cmp	r3, #0
 80298ac:	d04a      	beq.n	8029944 <main+0x1cc>
					{																//Start to process data
						DP_FLAG = 0;
 80298ae:	4b2f      	ldr	r3, [pc, #188]	; (802996c <main+0x1f4>)
 80298b0:	2200      	movs	r2, #0
 80298b2:	601a      	str	r2, [r3, #0]
						Calibrate(rawData, calibData, I, csCount);
 80298b4:	f107 0320 	add.w	r3, r7, #32
 80298b8:	3b1c      	subs	r3, #28
 80298ba:	681b      	ldr	r3, [r3, #0]
 80298bc:	f107 0220 	add.w	r2, r7, #32
 80298c0:	f107 01a0 	add.w	r1, r7, #160	; 0xa0
 80298c4:	3968      	subs	r1, #104	; 0x68
 80298c6:	f507 5062 	add.w	r0, r7, #14464	; 0x3880
 80298ca:	3808      	subs	r0, #8
 80298cc:	f7ff f810 	bl	80288f0 <Calibrate>
						OMEmean(calibData, I, rpNumbers_, csCount);
 80298d0:	f107 0320 	add.w	r3, r7, #32
 80298d4:	3b1c      	subs	r3, #28
 80298d6:	681b      	ldr	r3, [r3, #0]
 80298d8:	f107 0220 	add.w	r2, r7, #32
 80298dc:	3a18      	subs	r2, #24
 80298de:	f107 0120 	add.w	r1, r7, #32
 80298e2:	f107 00a0 	add.w	r0, r7, #160	; 0xa0
 80298e6:	3868      	subs	r0, #104	; 0x68
 80298e8:	f000 f848 	bl	802997c <OMEmean>
						Nintegration(calibData);
 80298ec:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 80298f0:	3b68      	subs	r3, #104	; 0x68
 80298f2:	4618      	mov	r0, r3
 80298f4:	f000 f9fc 	bl	8029cf0 <Nintegration>
						c[csCount]++;												//Count number of IMU being read
 80298f8:	f107 0320 	add.w	r3, r7, #32
 80298fc:	3b1c      	subs	r3, #28
 80298fe:	681b      	ldr	r3, [r3, #0]
 8029900:	4a1b      	ldr	r2, [pc, #108]	; (8029970 <main+0x1f8>)
 8029902:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8029906:	3201      	adds	r2, #1
 8029908:	4919      	ldr	r1, [pc, #100]	; (8029970 <main+0x1f8>)
 802990a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
//						else
//						{
//							HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET );
//						}
//					}
					break;
 802990e:	e019      	b.n	8029944 <main+0x1cc>
				case 0:
					if (fPWMStarted)
 8029910:	f507 43a9 	add.w	r3, r7, #21632	; 0x5480
 8029914:	f103 031c 	add.w	r3, r3, #28
 8029918:	681b      	ldr	r3, [r3, #0]
 802991a:	2b00      	cmp	r3, #0
 802991c:	d014      	beq.n	8029948 <main+0x1d0>
					{
						HAL_TIM_PWM_Stop(&htim4,TIM_CHANNEL_1);
 802991e:	2100      	movs	r1, #0
 8029920:	480a      	ldr	r0, [pc, #40]	; (802994c <main+0x1d4>)
 8029922:	f003 fe0f 	bl	802d544 <HAL_TIM_PWM_Stop>
						fPWMStarted = 0;
 8029926:	2300      	movs	r3, #0
 8029928:	f507 42a9 	add.w	r2, r7, #21632	; 0x5480
 802992c:	f102 021c 	add.w	r2, r2, #28
 8029930:	6013      	str	r3, [r2, #0]
						HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET );		// Turn off green LED
 8029932:	2200      	movs	r2, #0
 8029934:	2102      	movs	r1, #2
 8029936:	480a      	ldr	r0, [pc, #40]	; (8029960 <main+0x1e8>)
 8029938:	f002 fa76 	bl	802be28 <HAL_GPIO_WritePin>
					}
					break;
 802993c:	bf00      	nop
 802993e:	e003      	b.n	8029948 <main+0x1d0>

			}
		#ifdef LOCAL_PROCESS_TIMEOUT
		}
		else __NOP();														//Set breakpoint for timeout if needed
 8029940:	bf00      	nop
 8029942:	e777      	b.n	8029834 <main+0xbc>
					break;
 8029944:	bf00      	nop
 8029946:	e775      	b.n	8029834 <main+0xbc>
					break;
 8029948:	bf00      	nop
		if(HAL_GetTick()<=timeout)
 802994a:	e773      	b.n	8029834 <main+0xbc>
 802994c:	20001520 	.word	0x20001520
 8029950:	20001518 	.word	0x20001518
 8029954:	2000151c 	.word	0x2000151c
 8029958:	20000170 	.word	0x20000170
 802995c:	2000008c 	.word	0x2000008c
 8029960:	40020400 	.word	0x40020400
 8029964:	40020000 	.word	0x40020000
 8029968:	20000174 	.word	0x20000174
 802996c:	20000178 	.word	0x20000178
 8029970:	20000158 	.word	0x20000158

08029974 <Error_Handler>:




void Error_Handler(void)
{
 8029974:	b480      	push	{r7}
 8029976:	af00      	add	r7, sp, #0
	while(1);
 8029978:	e7fe      	b.n	8029978 <Error_Handler+0x4>
	...

0802997c <OMEmean>:
 * 			 shows the number of data hasn't yet being processed
 * 			 Usually shows 0,1,2,3
 * 			 When rpNumebers shows hundreds, FIFO speed(PWM) is too fast
 */
void OMEmean(struct CalibBuffer *calibData, int I[nIMUs], int *rpNumbers, int csCount)
{
 802997c:	b480      	push	{r7}
 802997e:	b08b      	sub	sp, #44	; 0x2c
 8029980:	af00      	add	r7, sp, #0
 8029982:	60f8      	str	r0, [r7, #12]
 8029984:	60b9      	str	r1, [r7, #8]
 8029986:	607a      	str	r2, [r7, #4]
 8029988:	603b      	str	r3, [r7, #0]
	if (rpNumbers[csCount] >= RX_BUFFER_SIZE)
 802998a:	683b      	ldr	r3, [r7, #0]
 802998c:	009b      	lsls	r3, r3, #2
 802998e:	687a      	ldr	r2, [r7, #4]
 8029990:	4413      	add	r3, r2
 8029992:	681b      	ldr	r3, [r3, #0]
 8029994:	2b63      	cmp	r3, #99	; 0x63
 8029996:	dd00      	ble.n	802999a <OMEmean+0x1e>
		__NOP();
 8029998:	bf00      	nop

	int nFlag = 0;
 802999a:	2300      	movs	r3, #0
 802999c:	627b      	str	r3, [r7, #36]	; 0x24
	int buffIndex = I[csCount] == 0 ? RX_BUFFER_SIZE - 1 : I[csCount] - 1; // Check if buffer index has rolled over. If yes, use BUFFER_SIZE - 1 as the index.
 802999e:	683b      	ldr	r3, [r7, #0]
 80299a0:	009b      	lsls	r3, r3, #2
 80299a2:	68ba      	ldr	r2, [r7, #8]
 80299a4:	4413      	add	r3, r2
 80299a6:	681b      	ldr	r3, [r3, #0]
 80299a8:	2b00      	cmp	r3, #0
 80299aa:	d006      	beq.n	80299ba <OMEmean+0x3e>
 80299ac:	683b      	ldr	r3, [r7, #0]
 80299ae:	009b      	lsls	r3, r3, #2
 80299b0:	68ba      	ldr	r2, [r7, #8]
 80299b2:	4413      	add	r3, r2
 80299b4:	681b      	ldr	r3, [r3, #0]
 80299b6:	3b01      	subs	r3, #1
 80299b8:	e000      	b.n	80299bc <OMEmean+0x40>
 80299ba:	2363      	movs	r3, #99	; 0x63
 80299bc:	617b      	str	r3, [r7, #20]
	Sum_OMX[rpNumbers[csCount]] += calibData[csCount].RxBuffer_OMX[buffIndex];
 80299be:	683b      	ldr	r3, [r7, #0]
 80299c0:	009b      	lsls	r3, r3, #2
 80299c2:	687a      	ldr	r2, [r7, #4]
 80299c4:	4413      	add	r3, r2
 80299c6:	681b      	ldr	r3, [r3, #0]
 80299c8:	4a94      	ldr	r2, [pc, #592]	; (8029c1c <OMEmean+0x2a0>)
 80299ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80299ce:	ee07 3a90 	vmov	s15, r3
 80299d2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 80299d6:	683b      	ldr	r3, [r7, #0]
 80299d8:	f44f 6216 	mov.w	r2, #2400	; 0x960
 80299dc:	fb02 f303 	mul.w	r3, r2, r3
 80299e0:	68fa      	ldr	r2, [r7, #12]
 80299e2:	441a      	add	r2, r3
 80299e4:	697b      	ldr	r3, [r7, #20]
 80299e6:	009b      	lsls	r3, r3, #2
 80299e8:	4413      	add	r3, r2
 80299ea:	edd3 7a00 	vldr	s15, [r3]
 80299ee:	ee77 7a27 	vadd.f32	s15, s14, s15
 80299f2:	683b      	ldr	r3, [r7, #0]
 80299f4:	009b      	lsls	r3, r3, #2
 80299f6:	687a      	ldr	r2, [r7, #4]
 80299f8:	4413      	add	r3, r2
 80299fa:	681b      	ldr	r3, [r3, #0]
 80299fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8029a00:	ee17 1a90 	vmov	r1, s15
 8029a04:	4a85      	ldr	r2, [pc, #532]	; (8029c1c <OMEmean+0x2a0>)
 8029a06:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	Sum_OMY[rpNumbers[csCount]] += calibData[csCount].RxBuffer_OMY[buffIndex];
 8029a0a:	683b      	ldr	r3, [r7, #0]
 8029a0c:	009b      	lsls	r3, r3, #2
 8029a0e:	687a      	ldr	r2, [r7, #4]
 8029a10:	4413      	add	r3, r2
 8029a12:	681b      	ldr	r3, [r3, #0]
 8029a14:	4a82      	ldr	r2, [pc, #520]	; (8029c20 <OMEmean+0x2a4>)
 8029a16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8029a1a:	ee07 3a90 	vmov	s15, r3
 8029a1e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8029a22:	683b      	ldr	r3, [r7, #0]
 8029a24:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029a28:	fb02 f303 	mul.w	r3, r2, r3
 8029a2c:	68fa      	ldr	r2, [r7, #12]
 8029a2e:	441a      	add	r2, r3
 8029a30:	697b      	ldr	r3, [r7, #20]
 8029a32:	3364      	adds	r3, #100	; 0x64
 8029a34:	009b      	lsls	r3, r3, #2
 8029a36:	4413      	add	r3, r2
 8029a38:	edd3 7a00 	vldr	s15, [r3]
 8029a3c:	ee77 7a27 	vadd.f32	s15, s14, s15
 8029a40:	683b      	ldr	r3, [r7, #0]
 8029a42:	009b      	lsls	r3, r3, #2
 8029a44:	687a      	ldr	r2, [r7, #4]
 8029a46:	4413      	add	r3, r2
 8029a48:	681b      	ldr	r3, [r3, #0]
 8029a4a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8029a4e:	ee17 1a90 	vmov	r1, s15
 8029a52:	4a73      	ldr	r2, [pc, #460]	; (8029c20 <OMEmean+0x2a4>)
 8029a54:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	Sum_OMZ[rpNumbers[csCount]] += calibData[csCount].RxBuffer_OMZ[buffIndex];
 8029a58:	683b      	ldr	r3, [r7, #0]
 8029a5a:	009b      	lsls	r3, r3, #2
 8029a5c:	687a      	ldr	r2, [r7, #4]
 8029a5e:	4413      	add	r3, r2
 8029a60:	681b      	ldr	r3, [r3, #0]
 8029a62:	4a70      	ldr	r2, [pc, #448]	; (8029c24 <OMEmean+0x2a8>)
 8029a64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8029a68:	ee07 3a90 	vmov	s15, r3
 8029a6c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8029a70:	683b      	ldr	r3, [r7, #0]
 8029a72:	f44f 6216 	mov.w	r2, #2400	; 0x960
 8029a76:	fb02 f303 	mul.w	r3, r2, r3
 8029a7a:	68fa      	ldr	r2, [r7, #12]
 8029a7c:	441a      	add	r2, r3
 8029a7e:	697b      	ldr	r3, [r7, #20]
 8029a80:	33c8      	adds	r3, #200	; 0xc8
 8029a82:	009b      	lsls	r3, r3, #2
 8029a84:	4413      	add	r3, r2
 8029a86:	edd3 7a00 	vldr	s15, [r3]
 8029a8a:	ee77 7a27 	vadd.f32	s15, s14, s15
 8029a8e:	683b      	ldr	r3, [r7, #0]
 8029a90:	009b      	lsls	r3, r3, #2
 8029a92:	687a      	ldr	r2, [r7, #4]
 8029a94:	4413      	add	r3, r2
 8029a96:	681b      	ldr	r3, [r3, #0]
 8029a98:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8029a9c:	ee17 1a90 	vmov	r1, s15
 8029aa0:	4a60      	ldr	r2, [pc, #384]	; (8029c24 <OMEmean+0x2a8>)
 8029aa2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	sendIndex[csCount][rpNumbers[csCount]] = buffIndex;
 8029aa6:	683b      	ldr	r3, [r7, #0]
 8029aa8:	009b      	lsls	r3, r3, #2
 8029aaa:	687a      	ldr	r2, [r7, #4]
 8029aac:	4413      	add	r3, r2
 8029aae:	681b      	ldr	r3, [r3, #0]
 8029ab0:	495d      	ldr	r1, [pc, #372]	; (8029c28 <OMEmean+0x2ac>)
 8029ab2:	683a      	ldr	r2, [r7, #0]
 8029ab4:	2064      	movs	r0, #100	; 0x64
 8029ab6:	fb00 f202 	mul.w	r2, r0, r2
 8029aba:	4413      	add	r3, r2
 8029abc:	697a      	ldr	r2, [r7, #20]
 8029abe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	rpNumbers[csCount]++;
 8029ac2:	683b      	ldr	r3, [r7, #0]
 8029ac4:	009b      	lsls	r3, r3, #2
 8029ac6:	687a      	ldr	r2, [r7, #4]
 8029ac8:	4413      	add	r3, r2
 8029aca:	681a      	ldr	r2, [r3, #0]
 8029acc:	3201      	adds	r2, #1
 8029ace:	601a      	str	r2, [r3, #0]
	if(LenArr < rpNumbers[csCount])
 8029ad0:	683b      	ldr	r3, [r7, #0]
 8029ad2:	009b      	lsls	r3, r3, #2
 8029ad4:	687a      	ldr	r2, [r7, #4]
 8029ad6:	4413      	add	r3, r2
 8029ad8:	681a      	ldr	r2, [r3, #0]
 8029ada:	4b54      	ldr	r3, [pc, #336]	; (8029c2c <OMEmean+0x2b0>)
 8029adc:	681b      	ldr	r3, [r3, #0]
 8029ade:	429a      	cmp	r2, r3
 8029ae0:	dd06      	ble.n	8029af0 <OMEmean+0x174>
	{
		LenArr = rpNumbers[csCount];
 8029ae2:	683b      	ldr	r3, [r7, #0]
 8029ae4:	009b      	lsls	r3, r3, #2
 8029ae6:	687a      	ldr	r2, [r7, #4]
 8029ae8:	4413      	add	r3, r2
 8029aea:	681b      	ldr	r3, [r3, #0]
 8029aec:	4a4f      	ldr	r2, [pc, #316]	; (8029c2c <OMEmean+0x2b0>)
 8029aee:	6013      	str	r3, [r2, #0]
	}
	for(int i = 0; i < nIMUs; i++)
 8029af0:	2300      	movs	r3, #0
 8029af2:	623b      	str	r3, [r7, #32]
 8029af4:	e00c      	b.n	8029b10 <OMEmean+0x194>
	{
		if(rpNumbers[i]>0)
 8029af6:	6a3b      	ldr	r3, [r7, #32]
 8029af8:	009b      	lsls	r3, r3, #2
 8029afa:	687a      	ldr	r2, [r7, #4]
 8029afc:	4413      	add	r3, r2
 8029afe:	681b      	ldr	r3, [r3, #0]
 8029b00:	2b00      	cmp	r3, #0
 8029b02:	dd02      	ble.n	8029b0a <OMEmean+0x18e>
		{
			nFlag++;
 8029b04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029b06:	3301      	adds	r3, #1
 8029b08:	627b      	str	r3, [r7, #36]	; 0x24
	for(int i = 0; i < nIMUs; i++)
 8029b0a:	6a3b      	ldr	r3, [r7, #32]
 8029b0c:	3301      	adds	r3, #1
 8029b0e:	623b      	str	r3, [r7, #32]
 8029b10:	6a3b      	ldr	r3, [r7, #32]
 8029b12:	2b05      	cmp	r3, #5
 8029b14:	ddef      	ble.n	8029af6 <OMEmean+0x17a>
		}
	}
	if(nFlag == nIMUs)
 8029b16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8029b18:	2b06      	cmp	r3, #6
 8029b1a:	d179      	bne.n	8029c10 <OMEmean+0x294>
	{
		OMEbarOJ.OME[0][OMEIndex] =  (float) ((float)Sum_OMX[0]/(float)nIMUs);
 8029b1c:	4b3f      	ldr	r3, [pc, #252]	; (8029c1c <OMEmean+0x2a0>)
 8029b1e:	681b      	ldr	r3, [r3, #0]
 8029b20:	ee07 3a90 	vmov	s15, r3
 8029b24:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8029b28:	4b41      	ldr	r3, [pc, #260]	; (8029c30 <OMEmean+0x2b4>)
 8029b2a:	681b      	ldr	r3, [r3, #0]
 8029b2c:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 8029b30:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8029b34:	4a3f      	ldr	r2, [pc, #252]	; (8029c34 <OMEmean+0x2b8>)
 8029b36:	009b      	lsls	r3, r3, #2
 8029b38:	4413      	add	r3, r2
 8029b3a:	edc3 7a00 	vstr	s15, [r3]
		OMEbarOJ.OME[1][OMEIndex] =  (float) ((float)Sum_OMY[0]/(float)nIMUs);
 8029b3e:	4b38      	ldr	r3, [pc, #224]	; (8029c20 <OMEmean+0x2a4>)
 8029b40:	681b      	ldr	r3, [r3, #0]
 8029b42:	ee07 3a90 	vmov	s15, r3
 8029b46:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8029b4a:	4b39      	ldr	r3, [pc, #228]	; (8029c30 <OMEmean+0x2b4>)
 8029b4c:	681b      	ldr	r3, [r3, #0]
 8029b4e:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 8029b52:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8029b56:	4a37      	ldr	r2, [pc, #220]	; (8029c34 <OMEmean+0x2b8>)
 8029b58:	3364      	adds	r3, #100	; 0x64
 8029b5a:	009b      	lsls	r3, r3, #2
 8029b5c:	4413      	add	r3, r2
 8029b5e:	edc3 7a00 	vstr	s15, [r3]
		OMEbarOJ.OME[2][OMEIndex] =  (float) ((float)Sum_OMZ[0]/(float)nIMUs);
 8029b62:	4b30      	ldr	r3, [pc, #192]	; (8029c24 <OMEmean+0x2a8>)
 8029b64:	681b      	ldr	r3, [r3, #0]
 8029b66:	ee07 3a90 	vmov	s15, r3
 8029b6a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8029b6e:	4b30      	ldr	r3, [pc, #192]	; (8029c30 <OMEmean+0x2b4>)
 8029b70:	681b      	ldr	r3, [r3, #0]
 8029b72:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 8029b76:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8029b7a:	4a2e      	ldr	r2, [pc, #184]	; (8029c34 <OMEmean+0x2b8>)
 8029b7c:	33c8      	adds	r3, #200	; 0xc8
 8029b7e:	009b      	lsls	r3, r3, #2
 8029b80:	4413      	add	r3, r2
 8029b82:	edc3 7a00 	vstr	s15, [r3]
		OMEIndex = OMEIndex < RX_BUFFER_SIZE? OMEIndex+1 : 0;
 8029b86:	4b2a      	ldr	r3, [pc, #168]	; (8029c30 <OMEmean+0x2b4>)
 8029b88:	681b      	ldr	r3, [r3, #0]
 8029b8a:	2b63      	cmp	r3, #99	; 0x63
 8029b8c:	dc03      	bgt.n	8029b96 <OMEmean+0x21a>
 8029b8e:	4b28      	ldr	r3, [pc, #160]	; (8029c30 <OMEmean+0x2b4>)
 8029b90:	681b      	ldr	r3, [r3, #0]
 8029b92:	3301      	adds	r3, #1
 8029b94:	e000      	b.n	8029b98 <OMEmean+0x21c>
 8029b96:	2300      	movs	r3, #0
 8029b98:	4a25      	ldr	r2, [pc, #148]	; (8029c30 <OMEmean+0x2b4>)
 8029b9a:	6013      	str	r3, [r2, #0]
		for(int j = 1; j<(LenArr+1); j++)											// Shift sum arrays left by 1
 8029b9c:	2301      	movs	r3, #1
 8029b9e:	61fb      	str	r3, [r7, #28]
 8029ba0:	e01d      	b.n	8029bde <OMEmean+0x262>
		{
			Sum_OMX[j-1] = Sum_OMX[j];
 8029ba2:	69fb      	ldr	r3, [r7, #28]
 8029ba4:	3b01      	subs	r3, #1
 8029ba6:	491d      	ldr	r1, [pc, #116]	; (8029c1c <OMEmean+0x2a0>)
 8029ba8:	69fa      	ldr	r2, [r7, #28]
 8029baa:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8029bae:	491b      	ldr	r1, [pc, #108]	; (8029c1c <OMEmean+0x2a0>)
 8029bb0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			Sum_OMY[j-1] = Sum_OMY[j];
 8029bb4:	69fb      	ldr	r3, [r7, #28]
 8029bb6:	3b01      	subs	r3, #1
 8029bb8:	4919      	ldr	r1, [pc, #100]	; (8029c20 <OMEmean+0x2a4>)
 8029bba:	69fa      	ldr	r2, [r7, #28]
 8029bbc:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8029bc0:	4917      	ldr	r1, [pc, #92]	; (8029c20 <OMEmean+0x2a4>)
 8029bc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			Sum_OMZ[j-1] = Sum_OMZ[j];
 8029bc6:	69fb      	ldr	r3, [r7, #28]
 8029bc8:	3b01      	subs	r3, #1
 8029bca:	4916      	ldr	r1, [pc, #88]	; (8029c24 <OMEmean+0x2a8>)
 8029bcc:	69fa      	ldr	r2, [r7, #28]
 8029bce:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 8029bd2:	4914      	ldr	r1, [pc, #80]	; (8029c24 <OMEmean+0x2a8>)
 8029bd4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		for(int j = 1; j<(LenArr+1); j++)											// Shift sum arrays left by 1
 8029bd8:	69fb      	ldr	r3, [r7, #28]
 8029bda:	3301      	adds	r3, #1
 8029bdc:	61fb      	str	r3, [r7, #28]
 8029bde:	4b13      	ldr	r3, [pc, #76]	; (8029c2c <OMEmean+0x2b0>)
 8029be0:	681b      	ldr	r3, [r3, #0]
 8029be2:	3301      	adds	r3, #1
 8029be4:	69fa      	ldr	r2, [r7, #28]
 8029be6:	429a      	cmp	r2, r3
 8029be8:	dbdb      	blt.n	8029ba2 <OMEmean+0x226>
		}
		for (int z = 0; z < nIMUs; z++)
 8029bea:	2300      	movs	r3, #0
 8029bec:	61bb      	str	r3, [r7, #24]
 8029bee:	e00c      	b.n	8029c0a <OMEmean+0x28e>
		{
			if(z < nIMUs)
 8029bf0:	69bb      	ldr	r3, [r7, #24]
 8029bf2:	2b05      	cmp	r3, #5
 8029bf4:	dc06      	bgt.n	8029c04 <OMEmean+0x288>
			{
				rpNumbers[z]--;
 8029bf6:	69bb      	ldr	r3, [r7, #24]
 8029bf8:	009b      	lsls	r3, r3, #2
 8029bfa:	687a      	ldr	r2, [r7, #4]
 8029bfc:	4413      	add	r3, r2
 8029bfe:	681a      	ldr	r2, [r3, #0]
 8029c00:	3a01      	subs	r2, #1
 8029c02:	601a      	str	r2, [r3, #0]
		for (int z = 0; z < nIMUs; z++)
 8029c04:	69bb      	ldr	r3, [r7, #24]
 8029c06:	3301      	adds	r3, #1
 8029c08:	61bb      	str	r3, [r7, #24]
 8029c0a:	69bb      	ldr	r3, [r7, #24]
 8029c0c:	2b05      	cmp	r3, #5
 8029c0e:	ddef      	ble.n	8029bf0 <OMEmean+0x274>
			}
		}
	}
}
 8029c10:	bf00      	nop
 8029c12:	372c      	adds	r7, #44	; 0x2c
 8029c14:	46bd      	mov	sp, r7
 8029c16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029c1a:	4770      	bx	lr
 8029c1c:	2000017c 	.word	0x2000017c
 8029c20:	2000030c 	.word	0x2000030c
 8029c24:	2000049c 	.word	0x2000049c
 8029c28:	2000062c 	.word	0x2000062c
 8029c2c:	20001440 	.word	0x20001440
 8029c30:	2000143c 	.word	0x2000143c
 8029c34:	20000f8c 	.word	0x20000f8c

08029c38 <ArrShifter>:

void ArrShifter()
{
 8029c38:	b490      	push	{r4, r7}
 8029c3a:	b082      	sub	sp, #8
 8029c3c:	af00      	add	r7, sp, #0
	for(int j = 2; j < OMEIndex+2; j++)
 8029c3e:	2302      	movs	r3, #2
 8029c40:	607b      	str	r3, [r7, #4]
 8029c42:	e043      	b.n	8029ccc <ArrShifter+0x94>
	{
		OMEbarOJ.OME[0][j-2] = OMEbarOJ.OME[0][j];
 8029c44:	687b      	ldr	r3, [r7, #4]
 8029c46:	3b02      	subs	r3, #2
 8029c48:	4926      	ldr	r1, [pc, #152]	; (8029ce4 <ArrShifter+0xac>)
 8029c4a:	687a      	ldr	r2, [r7, #4]
 8029c4c:	0092      	lsls	r2, r2, #2
 8029c4e:	440a      	add	r2, r1
 8029c50:	6812      	ldr	r2, [r2, #0]
 8029c52:	4924      	ldr	r1, [pc, #144]	; (8029ce4 <ArrShifter+0xac>)
 8029c54:	009b      	lsls	r3, r3, #2
 8029c56:	440b      	add	r3, r1
 8029c58:	601a      	str	r2, [r3, #0]
		OMEbarOJ.OME[1][j-2] = OMEbarOJ.OME[1][j];
 8029c5a:	687b      	ldr	r3, [r7, #4]
 8029c5c:	3b02      	subs	r3, #2
 8029c5e:	4921      	ldr	r1, [pc, #132]	; (8029ce4 <ArrShifter+0xac>)
 8029c60:	687a      	ldr	r2, [r7, #4]
 8029c62:	3264      	adds	r2, #100	; 0x64
 8029c64:	0092      	lsls	r2, r2, #2
 8029c66:	440a      	add	r2, r1
 8029c68:	6812      	ldr	r2, [r2, #0]
 8029c6a:	491e      	ldr	r1, [pc, #120]	; (8029ce4 <ArrShifter+0xac>)
 8029c6c:	3364      	adds	r3, #100	; 0x64
 8029c6e:	009b      	lsls	r3, r3, #2
 8029c70:	440b      	add	r3, r1
 8029c72:	601a      	str	r2, [r3, #0]
		OMEbarOJ.OME[2][j-2] = OMEbarOJ.OME[2][j];
 8029c74:	687b      	ldr	r3, [r7, #4]
 8029c76:	3b02      	subs	r3, #2
 8029c78:	491a      	ldr	r1, [pc, #104]	; (8029ce4 <ArrShifter+0xac>)
 8029c7a:	687a      	ldr	r2, [r7, #4]
 8029c7c:	32c8      	adds	r2, #200	; 0xc8
 8029c7e:	0092      	lsls	r2, r2, #2
 8029c80:	440a      	add	r2, r1
 8029c82:	6812      	ldr	r2, [r2, #0]
 8029c84:	4917      	ldr	r1, [pc, #92]	; (8029ce4 <ArrShifter+0xac>)
 8029c86:	33c8      	adds	r3, #200	; 0xc8
 8029c88:	009b      	lsls	r3, r3, #2
 8029c8a:	440b      	add	r3, r1
 8029c8c:	601a      	str	r2, [r3, #0]
		for (int k = 0; k < nIMUs; k++)	sendIndex[k][j - 2] = sendIndex[k][j];
 8029c8e:	2300      	movs	r3, #0
 8029c90:	603b      	str	r3, [r7, #0]
 8029c92:	e015      	b.n	8029cc0 <ArrShifter+0x88>
 8029c94:	687b      	ldr	r3, [r7, #4]
 8029c96:	3b02      	subs	r3, #2
 8029c98:	4813      	ldr	r0, [pc, #76]	; (8029ce8 <ArrShifter+0xb0>)
 8029c9a:	683a      	ldr	r2, [r7, #0]
 8029c9c:	2164      	movs	r1, #100	; 0x64
 8029c9e:	fb01 f102 	mul.w	r1, r1, r2
 8029ca2:	687a      	ldr	r2, [r7, #4]
 8029ca4:	440a      	add	r2, r1
 8029ca6:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8029caa:	480f      	ldr	r0, [pc, #60]	; (8029ce8 <ArrShifter+0xb0>)
 8029cac:	6839      	ldr	r1, [r7, #0]
 8029cae:	2464      	movs	r4, #100	; 0x64
 8029cb0:	fb04 f101 	mul.w	r1, r4, r1
 8029cb4:	440b      	add	r3, r1
 8029cb6:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 8029cba:	683b      	ldr	r3, [r7, #0]
 8029cbc:	3301      	adds	r3, #1
 8029cbe:	603b      	str	r3, [r7, #0]
 8029cc0:	683b      	ldr	r3, [r7, #0]
 8029cc2:	2b05      	cmp	r3, #5
 8029cc4:	dde6      	ble.n	8029c94 <ArrShifter+0x5c>
	for(int j = 2; j < OMEIndex+2; j++)
 8029cc6:	687b      	ldr	r3, [r7, #4]
 8029cc8:	3301      	adds	r3, #1
 8029cca:	607b      	str	r3, [r7, #4]
 8029ccc:	4b07      	ldr	r3, [pc, #28]	; (8029cec <ArrShifter+0xb4>)
 8029cce:	681b      	ldr	r3, [r3, #0]
 8029cd0:	3302      	adds	r3, #2
 8029cd2:	687a      	ldr	r2, [r7, #4]
 8029cd4:	429a      	cmp	r2, r3
 8029cd6:	dbb5      	blt.n	8029c44 <ArrShifter+0xc>
	}
}
 8029cd8:	bf00      	nop
 8029cda:	3708      	adds	r7, #8
 8029cdc:	46bd      	mov	sp, r7
 8029cde:	bc90      	pop	{r4, r7}
 8029ce0:	4770      	bx	lr
 8029ce2:	bf00      	nop
 8029ce4:	20000f8c 	.word	0x20000f8c
 8029ce8:	2000062c 	.word	0x2000062c
 8029cec:	2000143c 	.word	0x2000143c

08029cf0 <Nintegration>:

//Purpose: numerical integration algorithm
//tx_bytes structure: phi (bytes 0-11), gamma (bytes 12-23), ombar, temp, accelerometer
//Input: None
void Nintegration(struct CalibBuffer *calibData)
{
 8029cf0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8029cf4:	b08c      	sub	sp, #48	; 0x30
 8029cf6:	af00      	add	r7, sp, #0
 8029cf8:	6078      	str	r0, [r7, #4]
	if(OMEIndex%3 == 0 && OMEIndex > 0)
 8029cfa:	4bc0      	ldr	r3, [pc, #768]	; (8029ffc <Nintegration+0x30c>)
 8029cfc:	6819      	ldr	r1, [r3, #0]
 8029cfe:	4bc0      	ldr	r3, [pc, #768]	; (802a000 <Nintegration+0x310>)
 8029d00:	fb83 3201 	smull	r3, r2, r3, r1
 8029d04:	17cb      	asrs	r3, r1, #31
 8029d06:	1ad2      	subs	r2, r2, r3
 8029d08:	4613      	mov	r3, r2
 8029d0a:	005b      	lsls	r3, r3, #1
 8029d0c:	4413      	add	r3, r2
 8029d0e:	1aca      	subs	r2, r1, r3
 8029d10:	2a00      	cmp	r2, #0
 8029d12:	f040 82b7 	bne.w	802a284 <Nintegration+0x594>
 8029d16:	4bb9      	ldr	r3, [pc, #740]	; (8029ffc <Nintegration+0x30c>)
 8029d18:	681b      	ldr	r3, [r3, #0]
 8029d1a:	2b00      	cmp	r3, #0
 8029d1c:	f340 82b2 	ble.w	802a284 <Nintegration+0x594>
	{
		sets++;
 8029d20:	4bb8      	ldr	r3, [pc, #736]	; (802a004 <Nintegration+0x314>)
 8029d22:	681b      	ldr	r3, [r3, #0]
 8029d24:	3301      	adds	r3, #1
 8029d26:	4ab7      	ldr	r2, [pc, #732]	; (802a004 <Nintegration+0x314>)
 8029d28:	6013      	str	r3, [r2, #0]
		for(int i = 0; i<3;i++)
 8029d2a:	2300      	movs	r3, #0
 8029d2c:	62fb      	str	r3, [r7, #44]	; 0x2c
 8029d2e:	e0be      	b.n	8029eae <Nintegration+0x1be>
		{
			if(alf == 1)
 8029d30:	4bb5      	ldr	r3, [pc, #724]	; (802a008 <Nintegration+0x318>)
 8029d32:	681b      	ldr	r3, [r3, #0]
 8029d34:	2b01      	cmp	r3, #1
 8029d36:	d109      	bne.n	8029d4c <Nintegration+0x5c>
			{
				al[0][i] = lastal[i];
 8029d38:	4ab4      	ldr	r2, [pc, #720]	; (802a00c <Nintegration+0x31c>)
 8029d3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029d3c:	009b      	lsls	r3, r3, #2
 8029d3e:	4413      	add	r3, r2
 8029d40:	681a      	ldr	r2, [r3, #0]
 8029d42:	49b3      	ldr	r1, [pc, #716]	; (802a010 <Nintegration+0x320>)
 8029d44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029d46:	009b      	lsls	r3, r3, #2
 8029d48:	440b      	add	r3, r1
 8029d4a:	601a      	str	r2, [r3, #0]
			}
			alf = 1;
 8029d4c:	4bae      	ldr	r3, [pc, #696]	; (802a008 <Nintegration+0x318>)
 8029d4e:	2201      	movs	r2, #1
 8029d50:	601a      	str	r2, [r3, #0]
			al[1][i] = al[0][i] + 0.25 * dt  * (OMEbarOJ.OME[i][0] + OMEbarOJ.OME[i][1]);					// Trapezoidal rule to calculate intermediate alpha
 8029d52:	4aaf      	ldr	r2, [pc, #700]	; (802a010 <Nintegration+0x320>)
 8029d54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029d56:	009b      	lsls	r3, r3, #2
 8029d58:	4413      	add	r3, r2
 8029d5a:	681b      	ldr	r3, [r3, #0]
 8029d5c:	4618      	mov	r0, r3
 8029d5e:	f7fe f84b 	bl	8027df8 <__aeabi_f2d>
 8029d62:	4604      	mov	r4, r0
 8029d64:	460d      	mov	r5, r1
 8029d66:	4bab      	ldr	r3, [pc, #684]	; (802a014 <Nintegration+0x324>)
 8029d68:	e9d3 0100 	ldrd	r0, r1, [r3]
 8029d6c:	f04f 0200 	mov.w	r2, #0
 8029d70:	4ba9      	ldr	r3, [pc, #676]	; (802a018 <Nintegration+0x328>)
 8029d72:	f7fe f899 	bl	8027ea8 <__aeabi_dmul>
 8029d76:	4602      	mov	r2, r0
 8029d78:	460b      	mov	r3, r1
 8029d7a:	4690      	mov	r8, r2
 8029d7c:	4699      	mov	r9, r3
 8029d7e:	4aa7      	ldr	r2, [pc, #668]	; (802a01c <Nintegration+0x32c>)
 8029d80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029d82:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8029d86:	fb01 f303 	mul.w	r3, r1, r3
 8029d8a:	4413      	add	r3, r2
 8029d8c:	ed93 7a00 	vldr	s14, [r3]
 8029d90:	4aa2      	ldr	r2, [pc, #648]	; (802a01c <Nintegration+0x32c>)
 8029d92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029d94:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8029d98:	fb01 f303 	mul.w	r3, r1, r3
 8029d9c:	4413      	add	r3, r2
 8029d9e:	3304      	adds	r3, #4
 8029da0:	edd3 7a00 	vldr	s15, [r3]
 8029da4:	ee77 7a27 	vadd.f32	s15, s14, s15
 8029da8:	ee17 0a90 	vmov	r0, s15
 8029dac:	f7fe f824 	bl	8027df8 <__aeabi_f2d>
 8029db0:	4602      	mov	r2, r0
 8029db2:	460b      	mov	r3, r1
 8029db4:	4640      	mov	r0, r8
 8029db6:	4649      	mov	r1, r9
 8029db8:	f7fe f876 	bl	8027ea8 <__aeabi_dmul>
 8029dbc:	4602      	mov	r2, r0
 8029dbe:	460b      	mov	r3, r1
 8029dc0:	4620      	mov	r0, r4
 8029dc2:	4629      	mov	r1, r5
 8029dc4:	f7fd feba 	bl	8027b3c <__adddf3>
 8029dc8:	4603      	mov	r3, r0
 8029dca:	460c      	mov	r4, r1
 8029dcc:	4618      	mov	r0, r3
 8029dce:	4621      	mov	r1, r4
 8029dd0:	f7fe fb1a 	bl	8028408 <__aeabi_d2f>
 8029dd4:	4601      	mov	r1, r0
 8029dd6:	4a8e      	ldr	r2, [pc, #568]	; (802a010 <Nintegration+0x320>)
 8029dd8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029dda:	3303      	adds	r3, #3
 8029ddc:	009b      	lsls	r3, r3, #2
 8029dde:	4413      	add	r3, r2
 8029de0:	6019      	str	r1, [r3, #0]
			al[2][i] = al[0][i] + dt/6 * (OMEbarOJ.OME[i][0] + 4*OMEbarOJ.OME[i][1] + OMEbarOJ.OME[i][2]);
 8029de2:	4a8b      	ldr	r2, [pc, #556]	; (802a010 <Nintegration+0x320>)
 8029de4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029de6:	009b      	lsls	r3, r3, #2
 8029de8:	4413      	add	r3, r2
 8029dea:	681b      	ldr	r3, [r3, #0]
 8029dec:	4618      	mov	r0, r3
 8029dee:	f7fe f803 	bl	8027df8 <__aeabi_f2d>
 8029df2:	4604      	mov	r4, r0
 8029df4:	460d      	mov	r5, r1
 8029df6:	4b87      	ldr	r3, [pc, #540]	; (802a014 <Nintegration+0x324>)
 8029df8:	e9d3 0100 	ldrd	r0, r1, [r3]
 8029dfc:	f04f 0200 	mov.w	r2, #0
 8029e00:	4b87      	ldr	r3, [pc, #540]	; (802a020 <Nintegration+0x330>)
 8029e02:	f7fe f97b 	bl	80280fc <__aeabi_ddiv>
 8029e06:	4602      	mov	r2, r0
 8029e08:	460b      	mov	r3, r1
 8029e0a:	4690      	mov	r8, r2
 8029e0c:	4699      	mov	r9, r3
 8029e0e:	4a83      	ldr	r2, [pc, #524]	; (802a01c <Nintegration+0x32c>)
 8029e10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029e12:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8029e16:	fb01 f303 	mul.w	r3, r1, r3
 8029e1a:	4413      	add	r3, r2
 8029e1c:	ed93 7a00 	vldr	s14, [r3]
 8029e20:	4a7e      	ldr	r2, [pc, #504]	; (802a01c <Nintegration+0x32c>)
 8029e22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029e24:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8029e28:	fb01 f303 	mul.w	r3, r1, r3
 8029e2c:	4413      	add	r3, r2
 8029e2e:	3304      	adds	r3, #4
 8029e30:	edd3 7a00 	vldr	s15, [r3]
 8029e34:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 8029e38:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8029e3c:	ee37 7a27 	vadd.f32	s14, s14, s15
 8029e40:	4a76      	ldr	r2, [pc, #472]	; (802a01c <Nintegration+0x32c>)
 8029e42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029e44:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8029e48:	fb01 f303 	mul.w	r3, r1, r3
 8029e4c:	4413      	add	r3, r2
 8029e4e:	3308      	adds	r3, #8
 8029e50:	edd3 7a00 	vldr	s15, [r3]
 8029e54:	ee77 7a27 	vadd.f32	s15, s14, s15
 8029e58:	ee17 0a90 	vmov	r0, s15
 8029e5c:	f7fd ffcc 	bl	8027df8 <__aeabi_f2d>
 8029e60:	4602      	mov	r2, r0
 8029e62:	460b      	mov	r3, r1
 8029e64:	4640      	mov	r0, r8
 8029e66:	4649      	mov	r1, r9
 8029e68:	f7fe f81e 	bl	8027ea8 <__aeabi_dmul>
 8029e6c:	4602      	mov	r2, r0
 8029e6e:	460b      	mov	r3, r1
 8029e70:	4620      	mov	r0, r4
 8029e72:	4629      	mov	r1, r5
 8029e74:	f7fd fe62 	bl	8027b3c <__adddf3>
 8029e78:	4603      	mov	r3, r0
 8029e7a:	460c      	mov	r4, r1
 8029e7c:	4618      	mov	r0, r3
 8029e7e:	4621      	mov	r1, r4
 8029e80:	f7fe fac2 	bl	8028408 <__aeabi_d2f>
 8029e84:	4601      	mov	r1, r0
 8029e86:	4a62      	ldr	r2, [pc, #392]	; (802a010 <Nintegration+0x320>)
 8029e88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029e8a:	3306      	adds	r3, #6
 8029e8c:	009b      	lsls	r3, r3, #2
 8029e8e:	4413      	add	r3, r2
 8029e90:	6019      	str	r1, [r3, #0]
			lastal[i] = al[2][i];
 8029e92:	4a5f      	ldr	r2, [pc, #380]	; (802a010 <Nintegration+0x320>)
 8029e94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029e96:	3306      	adds	r3, #6
 8029e98:	009b      	lsls	r3, r3, #2
 8029e9a:	4413      	add	r3, r2
 8029e9c:	681a      	ldr	r2, [r3, #0]
 8029e9e:	495b      	ldr	r1, [pc, #364]	; (802a00c <Nintegration+0x31c>)
 8029ea0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029ea2:	009b      	lsls	r3, r3, #2
 8029ea4:	440b      	add	r3, r1
 8029ea6:	601a      	str	r2, [r3, #0]
		for(int i = 0; i<3;i++)
 8029ea8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029eaa:	3301      	adds	r3, #1
 8029eac:	62fb      	str	r3, [r7, #44]	; 0x2c
 8029eae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8029eb0:	2b02      	cmp	r3, #2
 8029eb2:	f77f af3d 	ble.w	8029d30 <Nintegration+0x40>
		}

		for(int i = 0; i<3;i++)
 8029eb6:	2300      	movs	r3, #0
 8029eb8:	62bb      	str	r3, [r7, #40]	; 0x28
 8029eba:	e11d      	b.n	802a0f8 <Nintegration+0x408>
		{
			bd[i][0] = 0.5*((al[i][1]*OMEbarOJ.OME[2][i]) - (al[i][2]*OMEbarOJ.OME[1][i]));
 8029ebc:	4954      	ldr	r1, [pc, #336]	; (802a010 <Nintegration+0x320>)
 8029ebe:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029ec0:	4613      	mov	r3, r2
 8029ec2:	005b      	lsls	r3, r3, #1
 8029ec4:	4413      	add	r3, r2
 8029ec6:	009b      	lsls	r3, r3, #2
 8029ec8:	440b      	add	r3, r1
 8029eca:	3304      	adds	r3, #4
 8029ecc:	ed93 7a00 	vldr	s14, [r3]
 8029ed0:	4a52      	ldr	r2, [pc, #328]	; (802a01c <Nintegration+0x32c>)
 8029ed2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8029ed4:	33c8      	adds	r3, #200	; 0xc8
 8029ed6:	009b      	lsls	r3, r3, #2
 8029ed8:	4413      	add	r3, r2
 8029eda:	edd3 7a00 	vldr	s15, [r3]
 8029ede:	ee27 7a27 	vmul.f32	s14, s14, s15
 8029ee2:	494b      	ldr	r1, [pc, #300]	; (802a010 <Nintegration+0x320>)
 8029ee4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029ee6:	4613      	mov	r3, r2
 8029ee8:	005b      	lsls	r3, r3, #1
 8029eea:	4413      	add	r3, r2
 8029eec:	009b      	lsls	r3, r3, #2
 8029eee:	440b      	add	r3, r1
 8029ef0:	3308      	adds	r3, #8
 8029ef2:	edd3 6a00 	vldr	s13, [r3]
 8029ef6:	4a49      	ldr	r2, [pc, #292]	; (802a01c <Nintegration+0x32c>)
 8029ef8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8029efa:	3364      	adds	r3, #100	; 0x64
 8029efc:	009b      	lsls	r3, r3, #2
 8029efe:	4413      	add	r3, r2
 8029f00:	edd3 7a00 	vldr	s15, [r3]
 8029f04:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8029f08:	ee77 7a67 	vsub.f32	s15, s14, s15
 8029f0c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8029f10:	ee67 7a87 	vmul.f32	s15, s15, s14
 8029f14:	4943      	ldr	r1, [pc, #268]	; (802a024 <Nintegration+0x334>)
 8029f16:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029f18:	4613      	mov	r3, r2
 8029f1a:	005b      	lsls	r3, r3, #1
 8029f1c:	4413      	add	r3, r2
 8029f1e:	009b      	lsls	r3, r3, #2
 8029f20:	440b      	add	r3, r1
 8029f22:	edc3 7a00 	vstr	s15, [r3]
			bd[i][1] = 0.5*((al[i][2]*OMEbarOJ.OME[0][i]) - (al[i][0]*OMEbarOJ.OME[2][i]));
 8029f26:	493a      	ldr	r1, [pc, #232]	; (802a010 <Nintegration+0x320>)
 8029f28:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029f2a:	4613      	mov	r3, r2
 8029f2c:	005b      	lsls	r3, r3, #1
 8029f2e:	4413      	add	r3, r2
 8029f30:	009b      	lsls	r3, r3, #2
 8029f32:	440b      	add	r3, r1
 8029f34:	3308      	adds	r3, #8
 8029f36:	ed93 7a00 	vldr	s14, [r3]
 8029f3a:	4a38      	ldr	r2, [pc, #224]	; (802a01c <Nintegration+0x32c>)
 8029f3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8029f3e:	009b      	lsls	r3, r3, #2
 8029f40:	4413      	add	r3, r2
 8029f42:	edd3 7a00 	vldr	s15, [r3]
 8029f46:	ee27 7a27 	vmul.f32	s14, s14, s15
 8029f4a:	4931      	ldr	r1, [pc, #196]	; (802a010 <Nintegration+0x320>)
 8029f4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029f4e:	4613      	mov	r3, r2
 8029f50:	005b      	lsls	r3, r3, #1
 8029f52:	4413      	add	r3, r2
 8029f54:	009b      	lsls	r3, r3, #2
 8029f56:	440b      	add	r3, r1
 8029f58:	edd3 6a00 	vldr	s13, [r3]
 8029f5c:	4a2f      	ldr	r2, [pc, #188]	; (802a01c <Nintegration+0x32c>)
 8029f5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8029f60:	33c8      	adds	r3, #200	; 0xc8
 8029f62:	009b      	lsls	r3, r3, #2
 8029f64:	4413      	add	r3, r2
 8029f66:	edd3 7a00 	vldr	s15, [r3]
 8029f6a:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8029f6e:	ee77 7a67 	vsub.f32	s15, s14, s15
 8029f72:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8029f76:	ee67 7a87 	vmul.f32	s15, s15, s14
 8029f7a:	492a      	ldr	r1, [pc, #168]	; (802a024 <Nintegration+0x334>)
 8029f7c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029f7e:	4613      	mov	r3, r2
 8029f80:	005b      	lsls	r3, r3, #1
 8029f82:	4413      	add	r3, r2
 8029f84:	009b      	lsls	r3, r3, #2
 8029f86:	440b      	add	r3, r1
 8029f88:	3304      	adds	r3, #4
 8029f8a:	edc3 7a00 	vstr	s15, [r3]
			bd[i][2] = 0.5*((al[i][0]*OMEbarOJ.OME[1][i]) - (al[i][1]*OMEbarOJ.OME[0][i]));
 8029f8e:	4920      	ldr	r1, [pc, #128]	; (802a010 <Nintegration+0x320>)
 8029f90:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029f92:	4613      	mov	r3, r2
 8029f94:	005b      	lsls	r3, r3, #1
 8029f96:	4413      	add	r3, r2
 8029f98:	009b      	lsls	r3, r3, #2
 8029f9a:	440b      	add	r3, r1
 8029f9c:	ed93 7a00 	vldr	s14, [r3]
 8029fa0:	4a1e      	ldr	r2, [pc, #120]	; (802a01c <Nintegration+0x32c>)
 8029fa2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8029fa4:	3364      	adds	r3, #100	; 0x64
 8029fa6:	009b      	lsls	r3, r3, #2
 8029fa8:	4413      	add	r3, r2
 8029faa:	edd3 7a00 	vldr	s15, [r3]
 8029fae:	ee27 7a27 	vmul.f32	s14, s14, s15
 8029fb2:	4917      	ldr	r1, [pc, #92]	; (802a010 <Nintegration+0x320>)
 8029fb4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029fb6:	4613      	mov	r3, r2
 8029fb8:	005b      	lsls	r3, r3, #1
 8029fba:	4413      	add	r3, r2
 8029fbc:	009b      	lsls	r3, r3, #2
 8029fbe:	440b      	add	r3, r1
 8029fc0:	3304      	adds	r3, #4
 8029fc2:	edd3 6a00 	vldr	s13, [r3]
 8029fc6:	4a15      	ldr	r2, [pc, #84]	; (802a01c <Nintegration+0x32c>)
 8029fc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8029fca:	009b      	lsls	r3, r3, #2
 8029fcc:	4413      	add	r3, r2
 8029fce:	edd3 7a00 	vldr	s15, [r3]
 8029fd2:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8029fd6:	ee77 7a67 	vsub.f32	s15, s14, s15
 8029fda:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8029fde:	ee67 7a87 	vmul.f32	s15, s15, s14
 8029fe2:	4910      	ldr	r1, [pc, #64]	; (802a024 <Nintegration+0x334>)
 8029fe4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8029fe6:	4613      	mov	r3, r2
 8029fe8:	005b      	lsls	r3, r3, #1
 8029fea:	4413      	add	r3, r2
 8029fec:	009b      	lsls	r3, r3, #2
 8029fee:	440b      	add	r3, r1
 8029ff0:	3308      	adds	r3, #8
 8029ff2:	edc3 7a00 	vstr	s15, [r3]
			for(int j =0;j<3;j++)
 8029ff6:	2300      	movs	r3, #0
 8029ff8:	627b      	str	r3, [r7, #36]	; 0x24
 8029ffa:	e077      	b.n	802a0ec <Nintegration+0x3fc>
 8029ffc:	2000143c 	.word	0x2000143c
 802a000:	55555556 	.word	0x55555556
 802a004:	200014cc 	.word	0x200014cc
 802a008:	200014c8 	.word	0x200014c8
 802a00c:	2000148c 	.word	0x2000148c
 802a010:	20001444 	.word	0x20001444
 802a014:	20000090 	.word	0x20000090
 802a018:	3fd00000 	.word	0x3fd00000
 802a01c:	20000f8c 	.word	0x20000f8c
 802a020:	40180000 	.word	0x40180000
 802a024:	20001498 	.word	0x20001498
			{
				gd[i][j] = 0.5* (al[i][j] - (((sets-1)*2+i)*(dt/2) * OMEbarOJ.OME[j][i]));
 802a028:	49b0      	ldr	r1, [pc, #704]	; (802a2ec <Nintegration+0x5fc>)
 802a02a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802a02c:	4613      	mov	r3, r2
 802a02e:	005b      	lsls	r3, r3, #1
 802a030:	4413      	add	r3, r2
 802a032:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802a034:	4413      	add	r3, r2
 802a036:	009b      	lsls	r3, r3, #2
 802a038:	440b      	add	r3, r1
 802a03a:	681b      	ldr	r3, [r3, #0]
 802a03c:	4618      	mov	r0, r3
 802a03e:	f7fd fedb 	bl	8027df8 <__aeabi_f2d>
 802a042:	4604      	mov	r4, r0
 802a044:	460d      	mov	r5, r1
 802a046:	4baa      	ldr	r3, [pc, #680]	; (802a2f0 <Nintegration+0x600>)
 802a048:	681b      	ldr	r3, [r3, #0]
 802a04a:	3b01      	subs	r3, #1
 802a04c:	005a      	lsls	r2, r3, #1
 802a04e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802a050:	4413      	add	r3, r2
 802a052:	4618      	mov	r0, r3
 802a054:	f7fd febe 	bl	8027dd4 <__aeabi_i2d>
 802a058:	4680      	mov	r8, r0
 802a05a:	4689      	mov	r9, r1
 802a05c:	4ba5      	ldr	r3, [pc, #660]	; (802a2f4 <Nintegration+0x604>)
 802a05e:	e9d3 0100 	ldrd	r0, r1, [r3]
 802a062:	f04f 0200 	mov.w	r2, #0
 802a066:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 802a06a:	f7fe f847 	bl	80280fc <__aeabi_ddiv>
 802a06e:	4602      	mov	r2, r0
 802a070:	460b      	mov	r3, r1
 802a072:	4640      	mov	r0, r8
 802a074:	4649      	mov	r1, r9
 802a076:	f7fd ff17 	bl	8027ea8 <__aeabi_dmul>
 802a07a:	4602      	mov	r2, r0
 802a07c:	460b      	mov	r3, r1
 802a07e:	4690      	mov	r8, r2
 802a080:	4699      	mov	r9, r3
 802a082:	499d      	ldr	r1, [pc, #628]	; (802a2f8 <Nintegration+0x608>)
 802a084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a086:	2264      	movs	r2, #100	; 0x64
 802a088:	fb02 f203 	mul.w	r2, r2, r3
 802a08c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802a08e:	4413      	add	r3, r2
 802a090:	009b      	lsls	r3, r3, #2
 802a092:	440b      	add	r3, r1
 802a094:	681b      	ldr	r3, [r3, #0]
 802a096:	4618      	mov	r0, r3
 802a098:	f7fd feae 	bl	8027df8 <__aeabi_f2d>
 802a09c:	4602      	mov	r2, r0
 802a09e:	460b      	mov	r3, r1
 802a0a0:	4640      	mov	r0, r8
 802a0a2:	4649      	mov	r1, r9
 802a0a4:	f7fd ff00 	bl	8027ea8 <__aeabi_dmul>
 802a0a8:	4602      	mov	r2, r0
 802a0aa:	460b      	mov	r3, r1
 802a0ac:	4620      	mov	r0, r4
 802a0ae:	4629      	mov	r1, r5
 802a0b0:	f7fd fd42 	bl	8027b38 <__aeabi_dsub>
 802a0b4:	4603      	mov	r3, r0
 802a0b6:	460c      	mov	r4, r1
 802a0b8:	4618      	mov	r0, r3
 802a0ba:	4621      	mov	r1, r4
 802a0bc:	f04f 0200 	mov.w	r2, #0
 802a0c0:	4b8e      	ldr	r3, [pc, #568]	; (802a2fc <Nintegration+0x60c>)
 802a0c2:	f7fd fef1 	bl	8027ea8 <__aeabi_dmul>
 802a0c6:	4603      	mov	r3, r0
 802a0c8:	460c      	mov	r4, r1
 802a0ca:	4618      	mov	r0, r3
 802a0cc:	4621      	mov	r1, r4
 802a0ce:	f7fe f99b 	bl	8028408 <__aeabi_d2f>
 802a0d2:	498b      	ldr	r1, [pc, #556]	; (802a300 <Nintegration+0x610>)
 802a0d4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802a0d6:	4613      	mov	r3, r2
 802a0d8:	005b      	lsls	r3, r3, #1
 802a0da:	4413      	add	r3, r2
 802a0dc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802a0de:	4413      	add	r3, r2
 802a0e0:	009b      	lsls	r3, r3, #2
 802a0e2:	440b      	add	r3, r1
 802a0e4:	6018      	str	r0, [r3, #0]
			for(int j =0;j<3;j++)
 802a0e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a0e8:	3301      	adds	r3, #1
 802a0ea:	627b      	str	r3, [r7, #36]	; 0x24
 802a0ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a0ee:	2b02      	cmp	r3, #2
 802a0f0:	dd9a      	ble.n	802a028 <Nintegration+0x338>
		for(int i = 0; i<3;i++)
 802a0f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802a0f4:	3301      	adds	r3, #1
 802a0f6:	62bb      	str	r3, [r7, #40]	; 0x28
 802a0f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802a0fa:	2b02      	cmp	r3, #2
 802a0fc:	f77f aede 	ble.w	8029ebc <Nintegration+0x1cc>
			}
		}

		for(int i = 0; i<3; i++)
 802a100:	2300      	movs	r3, #0
 802a102:	623b      	str	r3, [r7, #32]
 802a104:	e0b3      	b.n	802a26e <Nintegration+0x57e>
		{
			be[i] += (dt/6)*((bd[0][i]) + 4*(bd[1][i]) + (bd[2][i]));
 802a106:	4a7f      	ldr	r2, [pc, #508]	; (802a304 <Nintegration+0x614>)
 802a108:	6a3b      	ldr	r3, [r7, #32]
 802a10a:	009b      	lsls	r3, r3, #2
 802a10c:	4413      	add	r3, r2
 802a10e:	681b      	ldr	r3, [r3, #0]
 802a110:	4618      	mov	r0, r3
 802a112:	f7fd fe71 	bl	8027df8 <__aeabi_f2d>
 802a116:	4604      	mov	r4, r0
 802a118:	460d      	mov	r5, r1
 802a11a:	4b76      	ldr	r3, [pc, #472]	; (802a2f4 <Nintegration+0x604>)
 802a11c:	e9d3 0100 	ldrd	r0, r1, [r3]
 802a120:	f04f 0200 	mov.w	r2, #0
 802a124:	4b78      	ldr	r3, [pc, #480]	; (802a308 <Nintegration+0x618>)
 802a126:	f7fd ffe9 	bl	80280fc <__aeabi_ddiv>
 802a12a:	4602      	mov	r2, r0
 802a12c:	460b      	mov	r3, r1
 802a12e:	4690      	mov	r8, r2
 802a130:	4699      	mov	r9, r3
 802a132:	4a76      	ldr	r2, [pc, #472]	; (802a30c <Nintegration+0x61c>)
 802a134:	6a3b      	ldr	r3, [r7, #32]
 802a136:	009b      	lsls	r3, r3, #2
 802a138:	4413      	add	r3, r2
 802a13a:	ed93 7a00 	vldr	s14, [r3]
 802a13e:	4a73      	ldr	r2, [pc, #460]	; (802a30c <Nintegration+0x61c>)
 802a140:	6a3b      	ldr	r3, [r7, #32]
 802a142:	3303      	adds	r3, #3
 802a144:	009b      	lsls	r3, r3, #2
 802a146:	4413      	add	r3, r2
 802a148:	edd3 7a00 	vldr	s15, [r3]
 802a14c:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 802a150:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802a154:	ee37 7a27 	vadd.f32	s14, s14, s15
 802a158:	4a6c      	ldr	r2, [pc, #432]	; (802a30c <Nintegration+0x61c>)
 802a15a:	6a3b      	ldr	r3, [r7, #32]
 802a15c:	3306      	adds	r3, #6
 802a15e:	009b      	lsls	r3, r3, #2
 802a160:	4413      	add	r3, r2
 802a162:	edd3 7a00 	vldr	s15, [r3]
 802a166:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a16a:	ee17 0a90 	vmov	r0, s15
 802a16e:	f7fd fe43 	bl	8027df8 <__aeabi_f2d>
 802a172:	4602      	mov	r2, r0
 802a174:	460b      	mov	r3, r1
 802a176:	4640      	mov	r0, r8
 802a178:	4649      	mov	r1, r9
 802a17a:	f7fd fe95 	bl	8027ea8 <__aeabi_dmul>
 802a17e:	4602      	mov	r2, r0
 802a180:	460b      	mov	r3, r1
 802a182:	4620      	mov	r0, r4
 802a184:	4629      	mov	r1, r5
 802a186:	f7fd fcd9 	bl	8027b3c <__adddf3>
 802a18a:	4603      	mov	r3, r0
 802a18c:	460c      	mov	r4, r1
 802a18e:	4618      	mov	r0, r3
 802a190:	4621      	mov	r1, r4
 802a192:	f7fe f939 	bl	8028408 <__aeabi_d2f>
 802a196:	4601      	mov	r1, r0
 802a198:	4a5a      	ldr	r2, [pc, #360]	; (802a304 <Nintegration+0x614>)
 802a19a:	6a3b      	ldr	r3, [r7, #32]
 802a19c:	009b      	lsls	r3, r3, #2
 802a19e:	4413      	add	r3, r2
 802a1a0:	6019      	str	r1, [r3, #0]
			gam[i].t += (dt/6)*(gd[0][i] + 4*gd[1][i] + gd[2][i]);
 802a1a2:	4a5b      	ldr	r2, [pc, #364]	; (802a310 <Nintegration+0x620>)
 802a1a4:	6a3b      	ldr	r3, [r7, #32]
 802a1a6:	009b      	lsls	r3, r3, #2
 802a1a8:	4413      	add	r3, r2
 802a1aa:	681b      	ldr	r3, [r3, #0]
 802a1ac:	4618      	mov	r0, r3
 802a1ae:	f7fd fe23 	bl	8027df8 <__aeabi_f2d>
 802a1b2:	4604      	mov	r4, r0
 802a1b4:	460d      	mov	r5, r1
 802a1b6:	4b4f      	ldr	r3, [pc, #316]	; (802a2f4 <Nintegration+0x604>)
 802a1b8:	e9d3 0100 	ldrd	r0, r1, [r3]
 802a1bc:	f04f 0200 	mov.w	r2, #0
 802a1c0:	4b51      	ldr	r3, [pc, #324]	; (802a308 <Nintegration+0x618>)
 802a1c2:	f7fd ff9b 	bl	80280fc <__aeabi_ddiv>
 802a1c6:	4602      	mov	r2, r0
 802a1c8:	460b      	mov	r3, r1
 802a1ca:	4690      	mov	r8, r2
 802a1cc:	4699      	mov	r9, r3
 802a1ce:	4a4c      	ldr	r2, [pc, #304]	; (802a300 <Nintegration+0x610>)
 802a1d0:	6a3b      	ldr	r3, [r7, #32]
 802a1d2:	009b      	lsls	r3, r3, #2
 802a1d4:	4413      	add	r3, r2
 802a1d6:	ed93 7a00 	vldr	s14, [r3]
 802a1da:	4a49      	ldr	r2, [pc, #292]	; (802a300 <Nintegration+0x610>)
 802a1dc:	6a3b      	ldr	r3, [r7, #32]
 802a1de:	3303      	adds	r3, #3
 802a1e0:	009b      	lsls	r3, r3, #2
 802a1e2:	4413      	add	r3, r2
 802a1e4:	edd3 7a00 	vldr	s15, [r3]
 802a1e8:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
 802a1ec:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802a1f0:	ee37 7a27 	vadd.f32	s14, s14, s15
 802a1f4:	4a42      	ldr	r2, [pc, #264]	; (802a300 <Nintegration+0x610>)
 802a1f6:	6a3b      	ldr	r3, [r7, #32]
 802a1f8:	3306      	adds	r3, #6
 802a1fa:	009b      	lsls	r3, r3, #2
 802a1fc:	4413      	add	r3, r2
 802a1fe:	edd3 7a00 	vldr	s15, [r3]
 802a202:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a206:	ee17 0a90 	vmov	r0, s15
 802a20a:	f7fd fdf5 	bl	8027df8 <__aeabi_f2d>
 802a20e:	4602      	mov	r2, r0
 802a210:	460b      	mov	r3, r1
 802a212:	4640      	mov	r0, r8
 802a214:	4649      	mov	r1, r9
 802a216:	f7fd fe47 	bl	8027ea8 <__aeabi_dmul>
 802a21a:	4602      	mov	r2, r0
 802a21c:	460b      	mov	r3, r1
 802a21e:	4620      	mov	r0, r4
 802a220:	4629      	mov	r1, r5
 802a222:	f7fd fc8b 	bl	8027b3c <__adddf3>
 802a226:	4603      	mov	r3, r0
 802a228:	460c      	mov	r4, r1
 802a22a:	4618      	mov	r0, r3
 802a22c:	4621      	mov	r1, r4
 802a22e:	f7fe f8eb 	bl	8028408 <__aeabi_d2f>
 802a232:	4601      	mov	r1, r0
 802a234:	4a36      	ldr	r2, [pc, #216]	; (802a310 <Nintegration+0x620>)
 802a236:	6a3b      	ldr	r3, [r7, #32]
 802a238:	009b      	lsls	r3, r3, #2
 802a23a:	4413      	add	r3, r2
 802a23c:	6019      	str	r1, [r3, #0]
			phi[i].t = al[2][i]+be[i];
 802a23e:	4a2b      	ldr	r2, [pc, #172]	; (802a2ec <Nintegration+0x5fc>)
 802a240:	6a3b      	ldr	r3, [r7, #32]
 802a242:	3306      	adds	r3, #6
 802a244:	009b      	lsls	r3, r3, #2
 802a246:	4413      	add	r3, r2
 802a248:	ed93 7a00 	vldr	s14, [r3]
 802a24c:	4a2d      	ldr	r2, [pc, #180]	; (802a304 <Nintegration+0x614>)
 802a24e:	6a3b      	ldr	r3, [r7, #32]
 802a250:	009b      	lsls	r3, r3, #2
 802a252:	4413      	add	r3, r2
 802a254:	edd3 7a00 	vldr	s15, [r3]
 802a258:	ee77 7a27 	vadd.f32	s15, s14, s15
 802a25c:	4a2d      	ldr	r2, [pc, #180]	; (802a314 <Nintegration+0x624>)
 802a25e:	6a3b      	ldr	r3, [r7, #32]
 802a260:	009b      	lsls	r3, r3, #2
 802a262:	4413      	add	r3, r2
 802a264:	edc3 7a00 	vstr	s15, [r3]
		for(int i = 0; i<3; i++)
 802a268:	6a3b      	ldr	r3, [r7, #32]
 802a26a:	3301      	adds	r3, #1
 802a26c:	623b      	str	r3, [r7, #32]
 802a26e:	6a3b      	ldr	r3, [r7, #32]
 802a270:	2b02      	cmp	r3, #2
 802a272:	f77f af48 	ble.w	802a106 <Nintegration+0x416>
		}
//		if (sets > 2)
//		{
//			__NOP();
//		}
		ArrShifter();
 802a276:	f7ff fcdf 	bl	8029c38 <ArrShifter>
		OMEIndex = OMEIndex - 2;
 802a27a:	4b27      	ldr	r3, [pc, #156]	; (802a318 <Nintegration+0x628>)
 802a27c:	681b      	ldr	r3, [r3, #0]
 802a27e:	3b02      	subs	r3, #2
 802a280:	4a25      	ldr	r2, [pc, #148]	; (802a318 <Nintegration+0x628>)
 802a282:	6013      	str	r3, [r2, #0]
	}
	if(sets == 4) //1,2,3,4
 802a284:	4b1a      	ldr	r3, [pc, #104]	; (802a2f0 <Nintegration+0x600>)
 802a286:	681b      	ldr	r3, [r3, #0]
 802a288:	2b04      	cmp	r3, #4
 802a28a:	f040 8133 	bne.w	802a4f4 <Nintegration+0x804>
	{
		for (int i = 0; i < 3; i++)
 802a28e:	2300      	movs	r3, #0
 802a290:	61fb      	str	r3, [r7, #28]
 802a292:	e025      	b.n	802a2e0 <Nintegration+0x5f0>
		{
			tx_bytes[i].t = phi[i].t;
 802a294:	4a1f      	ldr	r2, [pc, #124]	; (802a314 <Nintegration+0x624>)
 802a296:	69fb      	ldr	r3, [r7, #28]
 802a298:	009b      	lsls	r3, r3, #2
 802a29a:	4413      	add	r3, r2
 802a29c:	681a      	ldr	r2, [r3, #0]
 802a29e:	491f      	ldr	r1, [pc, #124]	; (802a31c <Nintegration+0x62c>)
 802a2a0:	69fb      	ldr	r3, [r7, #28]
 802a2a2:	009b      	lsls	r3, r3, #2
 802a2a4:	440b      	add	r3, r1
 802a2a6:	601a      	str	r2, [r3, #0]
			tx_bytes[i+3].t = gam[i].t;								//Combine ga & phi together
 802a2a8:	69fb      	ldr	r3, [r7, #28]
 802a2aa:	3303      	adds	r3, #3
 802a2ac:	4918      	ldr	r1, [pc, #96]	; (802a310 <Nintegration+0x620>)
 802a2ae:	69fa      	ldr	r2, [r7, #28]
 802a2b0:	0092      	lsls	r2, r2, #2
 802a2b2:	440a      	add	r2, r1
 802a2b4:	6812      	ldr	r2, [r2, #0]
 802a2b6:	4919      	ldr	r1, [pc, #100]	; (802a31c <Nintegration+0x62c>)
 802a2b8:	009b      	lsls	r3, r3, #2
 802a2ba:	440b      	add	r3, r1
 802a2bc:	601a      	str	r2, [r3, #0]
			tx_bytes[i+6].t = OMEbarOJ.OME[i][0];
 802a2be:	69fb      	ldr	r3, [r7, #28]
 802a2c0:	3306      	adds	r3, #6
 802a2c2:	490d      	ldr	r1, [pc, #52]	; (802a2f8 <Nintegration+0x608>)
 802a2c4:	69fa      	ldr	r2, [r7, #28]
 802a2c6:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802a2ca:	fb00 f202 	mul.w	r2, r0, r2
 802a2ce:	440a      	add	r2, r1
 802a2d0:	6812      	ldr	r2, [r2, #0]
 802a2d2:	4912      	ldr	r1, [pc, #72]	; (802a31c <Nintegration+0x62c>)
 802a2d4:	009b      	lsls	r3, r3, #2
 802a2d6:	440b      	add	r3, r1
 802a2d8:	601a      	str	r2, [r3, #0]
		for (int i = 0; i < 3; i++)
 802a2da:	69fb      	ldr	r3, [r7, #28]
 802a2dc:	3301      	adds	r3, #1
 802a2de:	61fb      	str	r3, [r7, #28]
 802a2e0:	69fb      	ldr	r3, [r7, #28]
 802a2e2:	2b02      	cmp	r3, #2
 802a2e4:	ddd6      	ble.n	802a294 <Nintegration+0x5a4>
		}
//		tx_bytes[9].t = 0.0;										//Placeholder for temperature
		for (int k = 0; k < nIMUs; k++)
 802a2e6:	2300      	movs	r3, #0
 802a2e8:	61bb      	str	r3, [r7, #24]
 802a2ea:	e073      	b.n	802a3d4 <Nintegration+0x6e4>
 802a2ec:	20001444 	.word	0x20001444
 802a2f0:	200014cc 	.word	0x200014cc
 802a2f4:	20000090 	.word	0x20000090
 802a2f8:	20000f8c 	.word	0x20000f8c
 802a2fc:	3fe00000 	.word	0x3fe00000
 802a300:	20001468 	.word	0x20001468
 802a304:	200014bc 	.word	0x200014bc
 802a308:	40180000 	.word	0x40180000
 802a30c:	20001498 	.word	0x20001498
 802a310:	200018c4 	.word	0x200018c4
 802a314:	20001840 	.word	0x20001840
 802a318:	2000143c 	.word	0x2000143c
 802a31c:	2000184c 	.word	0x2000184c
		{
			tx_bytes[k*3 + 9].t = calibData[k].RxBuffer_AX[sendIndex[k][0]];
 802a320:	69bb      	ldr	r3, [r7, #24]
 802a322:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802a326:	fb02 f303 	mul.w	r3, r2, r3
 802a32a:	687a      	ldr	r2, [r7, #4]
 802a32c:	18d1      	adds	r1, r2, r3
 802a32e:	4a74      	ldr	r2, [pc, #464]	; (802a500 <Nintegration+0x810>)
 802a330:	69bb      	ldr	r3, [r7, #24]
 802a332:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802a336:	fb00 f303 	mul.w	r3, r0, r3
 802a33a:	4413      	add	r3, r2
 802a33c:	6818      	ldr	r0, [r3, #0]
 802a33e:	69ba      	ldr	r2, [r7, #24]
 802a340:	4613      	mov	r3, r2
 802a342:	005b      	lsls	r3, r3, #1
 802a344:	4413      	add	r3, r2
 802a346:	3309      	adds	r3, #9
 802a348:	f500 7296 	add.w	r2, r0, #300	; 0x12c
 802a34c:	0092      	lsls	r2, r2, #2
 802a34e:	440a      	add	r2, r1
 802a350:	6812      	ldr	r2, [r2, #0]
 802a352:	496c      	ldr	r1, [pc, #432]	; (802a504 <Nintegration+0x814>)
 802a354:	009b      	lsls	r3, r3, #2
 802a356:	440b      	add	r3, r1
 802a358:	601a      	str	r2, [r3, #0]
			tx_bytes[k*3 + 10].t = calibData[k].RxBuffer_AY[sendIndex[k][0]];
 802a35a:	69bb      	ldr	r3, [r7, #24]
 802a35c:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802a360:	fb02 f303 	mul.w	r3, r2, r3
 802a364:	687a      	ldr	r2, [r7, #4]
 802a366:	18d1      	adds	r1, r2, r3
 802a368:	4a65      	ldr	r2, [pc, #404]	; (802a500 <Nintegration+0x810>)
 802a36a:	69bb      	ldr	r3, [r7, #24]
 802a36c:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802a370:	fb00 f303 	mul.w	r3, r0, r3
 802a374:	4413      	add	r3, r2
 802a376:	6818      	ldr	r0, [r3, #0]
 802a378:	69ba      	ldr	r2, [r7, #24]
 802a37a:	4613      	mov	r3, r2
 802a37c:	005b      	lsls	r3, r3, #1
 802a37e:	4413      	add	r3, r2
 802a380:	330a      	adds	r3, #10
 802a382:	f500 72c8 	add.w	r2, r0, #400	; 0x190
 802a386:	0092      	lsls	r2, r2, #2
 802a388:	440a      	add	r2, r1
 802a38a:	6812      	ldr	r2, [r2, #0]
 802a38c:	495d      	ldr	r1, [pc, #372]	; (802a504 <Nintegration+0x814>)
 802a38e:	009b      	lsls	r3, r3, #2
 802a390:	440b      	add	r3, r1
 802a392:	601a      	str	r2, [r3, #0]
			tx_bytes[k*3 + 11].t = calibData[k].RxBuffer_AZ[sendIndex[k][0]];
 802a394:	69bb      	ldr	r3, [r7, #24]
 802a396:	f44f 6216 	mov.w	r2, #2400	; 0x960
 802a39a:	fb02 f303 	mul.w	r3, r2, r3
 802a39e:	687a      	ldr	r2, [r7, #4]
 802a3a0:	18d1      	adds	r1, r2, r3
 802a3a2:	4a57      	ldr	r2, [pc, #348]	; (802a500 <Nintegration+0x810>)
 802a3a4:	69bb      	ldr	r3, [r7, #24]
 802a3a6:	f44f 70c8 	mov.w	r0, #400	; 0x190
 802a3aa:	fb00 f303 	mul.w	r3, r0, r3
 802a3ae:	4413      	add	r3, r2
 802a3b0:	6818      	ldr	r0, [r3, #0]
 802a3b2:	69ba      	ldr	r2, [r7, #24]
 802a3b4:	4613      	mov	r3, r2
 802a3b6:	005b      	lsls	r3, r3, #1
 802a3b8:	4413      	add	r3, r2
 802a3ba:	330b      	adds	r3, #11
 802a3bc:	f500 72fa 	add.w	r2, r0, #500	; 0x1f4
 802a3c0:	0092      	lsls	r2, r2, #2
 802a3c2:	440a      	add	r2, r1
 802a3c4:	6812      	ldr	r2, [r2, #0]
 802a3c6:	494f      	ldr	r1, [pc, #316]	; (802a504 <Nintegration+0x814>)
 802a3c8:	009b      	lsls	r3, r3, #2
 802a3ca:	440b      	add	r3, r1
 802a3cc:	601a      	str	r2, [r3, #0]
		for (int k = 0; k < nIMUs; k++)
 802a3ce:	69bb      	ldr	r3, [r7, #24]
 802a3d0:	3301      	adds	r3, #1
 802a3d2:	61bb      	str	r3, [r7, #24]
 802a3d4:	69bb      	ldr	r3, [r7, #24]
 802a3d6:	2b05      	cmp	r3, #5
 802a3d8:	dda2      	ble.n	802a320 <Nintegration+0x630>
		}
		//UART
		HAL_UART_DMAResume(&huart1);								//Start UART
 802a3da:	484b      	ldr	r0, [pc, #300]	; (802a508 <Nintegration+0x818>)
 802a3dc:	f003 fed4 	bl	802e188 <HAL_UART_DMAResume>
		HAL_UART_Transmit_DMA(&huart1, tx_bytes[0].tbytes, NBYTES);			//Transmit bytes with DMA
 802a3e0:	226c      	movs	r2, #108	; 0x6c
 802a3e2:	4948      	ldr	r1, [pc, #288]	; (802a504 <Nintegration+0x814>)
 802a3e4:	4848      	ldr	r0, [pc, #288]	; (802a508 <Nintegration+0x818>)
 802a3e6:	f003 fdff 	bl	802dfe8 <HAL_UART_Transmit_DMA>
		for (int i = 0; i < NWORDS; i++)
 802a3ea:	2300      	movs	r3, #0
 802a3ec:	617b      	str	r3, [r7, #20]
 802a3ee:	e012      	b.n	802a416 <Nintegration+0x726>
		{
			tx_bytesBuffer[iTx_bytesBuffer][i] = tx_bytes[i];
 802a3f0:	4b46      	ldr	r3, [pc, #280]	; (802a50c <Nintegration+0x81c>)
 802a3f2:	681a      	ldr	r2, [r3, #0]
 802a3f4:	4946      	ldr	r1, [pc, #280]	; (802a510 <Nintegration+0x820>)
 802a3f6:	4613      	mov	r3, r2
 802a3f8:	005b      	lsls	r3, r3, #1
 802a3fa:	4413      	add	r3, r2
 802a3fc:	00da      	lsls	r2, r3, #3
 802a3fe:	4413      	add	r3, r2
 802a400:	697a      	ldr	r2, [r7, #20]
 802a402:	4413      	add	r3, r2
 802a404:	483f      	ldr	r0, [pc, #252]	; (802a504 <Nintegration+0x814>)
 802a406:	697a      	ldr	r2, [r7, #20]
 802a408:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 802a40c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		for (int i = 0; i < NWORDS; i++)
 802a410:	697b      	ldr	r3, [r7, #20]
 802a412:	3301      	adds	r3, #1
 802a414:	617b      	str	r3, [r7, #20]
 802a416:	697b      	ldr	r3, [r7, #20]
 802a418:	2b1a      	cmp	r3, #26
 802a41a:	dde9      	ble.n	802a3f0 <Nintegration+0x700>
		}
		if (iTx_bytesBuffer >= 99)
 802a41c:	4b3b      	ldr	r3, [pc, #236]	; (802a50c <Nintegration+0x81c>)
 802a41e:	681b      	ldr	r3, [r3, #0]
 802a420:	2b62      	cmp	r3, #98	; 0x62
 802a422:	dd08      	ble.n	802a436 <Nintegration+0x746>
		{
			iTx_bytesBuffer = 0;
 802a424:	4b39      	ldr	r3, [pc, #228]	; (802a50c <Nintegration+0x81c>)
 802a426:	2200      	movs	r2, #0
 802a428:	601a      	str	r2, [r3, #0]
			iTx_bytesBufferRollover++;
 802a42a:	4b3a      	ldr	r3, [pc, #232]	; (802a514 <Nintegration+0x824>)
 802a42c:	681b      	ldr	r3, [r3, #0]
 802a42e:	3301      	adds	r3, #1
 802a430:	4a38      	ldr	r2, [pc, #224]	; (802a514 <Nintegration+0x824>)
 802a432:	6013      	str	r3, [r2, #0]
 802a434:	e004      	b.n	802a440 <Nintegration+0x750>
		}
		else
		{
			iTx_bytesBuffer++;
 802a436:	4b35      	ldr	r3, [pc, #212]	; (802a50c <Nintegration+0x81c>)
 802a438:	681b      	ldr	r3, [r3, #0]
 802a43a:	3301      	adds	r3, #1
 802a43c:	4a33      	ldr	r2, [pc, #204]	; (802a50c <Nintegration+0x81c>)
 802a43e:	6013      	str	r3, [r2, #0]
		}
//		if (iTx_bytesBufferRollover > 0)
		if (iTx_bytesBuffer > 4)
 802a440:	4b32      	ldr	r3, [pc, #200]	; (802a50c <Nintegration+0x81c>)
 802a442:	681b      	ldr	r3, [r3, #0]
 802a444:	2b04      	cmp	r3, #4
 802a446:	dd00      	ble.n	802a44a <Nintegration+0x75a>
		{
			__NOP();
 802a448:	bf00      	nop
		}
		for(int i = 0; i < 3; i++)
 802a44a:	2300      	movs	r3, #0
 802a44c:	613b      	str	r3, [r7, #16]
 802a44e:	e04b      	b.n	802a4e8 <Nintegration+0x7f8>
		{
			lastal[i] = 0;
 802a450:	4a31      	ldr	r2, [pc, #196]	; (802a518 <Nintegration+0x828>)
 802a452:	693b      	ldr	r3, [r7, #16]
 802a454:	009b      	lsls	r3, r3, #2
 802a456:	4413      	add	r3, r2
 802a458:	f04f 0200 	mov.w	r2, #0
 802a45c:	601a      	str	r2, [r3, #0]
			be[i] = 0;
 802a45e:	4a2f      	ldr	r2, [pc, #188]	; (802a51c <Nintegration+0x82c>)
 802a460:	693b      	ldr	r3, [r7, #16]
 802a462:	009b      	lsls	r3, r3, #2
 802a464:	4413      	add	r3, r2
 802a466:	f04f 0200 	mov.w	r2, #0
 802a46a:	601a      	str	r2, [r3, #0]
			gam[i].t = 0;
 802a46c:	4a2c      	ldr	r2, [pc, #176]	; (802a520 <Nintegration+0x830>)
 802a46e:	693b      	ldr	r3, [r7, #16]
 802a470:	009b      	lsls	r3, r3, #2
 802a472:	4413      	add	r3, r2
 802a474:	f04f 0200 	mov.w	r2, #0
 802a478:	601a      	str	r2, [r3, #0]
			phi[i].t = 0;
 802a47a:	4a2a      	ldr	r2, [pc, #168]	; (802a524 <Nintegration+0x834>)
 802a47c:	693b      	ldr	r3, [r7, #16]
 802a47e:	009b      	lsls	r3, r3, #2
 802a480:	4413      	add	r3, r2
 802a482:	f04f 0200 	mov.w	r2, #0
 802a486:	601a      	str	r2, [r3, #0]
			for(int j = 0; j < 3; j++)
 802a488:	2300      	movs	r3, #0
 802a48a:	60fb      	str	r3, [r7, #12]
 802a48c:	e026      	b.n	802a4dc <Nintegration+0x7ec>
			{
				al[j][i] = 0;
 802a48e:	4926      	ldr	r1, [pc, #152]	; (802a528 <Nintegration+0x838>)
 802a490:	68fa      	ldr	r2, [r7, #12]
 802a492:	4613      	mov	r3, r2
 802a494:	005b      	lsls	r3, r3, #1
 802a496:	4413      	add	r3, r2
 802a498:	693a      	ldr	r2, [r7, #16]
 802a49a:	4413      	add	r3, r2
 802a49c:	009b      	lsls	r3, r3, #2
 802a49e:	440b      	add	r3, r1
 802a4a0:	f04f 0200 	mov.w	r2, #0
 802a4a4:	601a      	str	r2, [r3, #0]
				bd[j][i] = 0;
 802a4a6:	4921      	ldr	r1, [pc, #132]	; (802a52c <Nintegration+0x83c>)
 802a4a8:	68fa      	ldr	r2, [r7, #12]
 802a4aa:	4613      	mov	r3, r2
 802a4ac:	005b      	lsls	r3, r3, #1
 802a4ae:	4413      	add	r3, r2
 802a4b0:	693a      	ldr	r2, [r7, #16]
 802a4b2:	4413      	add	r3, r2
 802a4b4:	009b      	lsls	r3, r3, #2
 802a4b6:	440b      	add	r3, r1
 802a4b8:	f04f 0200 	mov.w	r2, #0
 802a4bc:	601a      	str	r2, [r3, #0]
				gd[j][i] = 0;
 802a4be:	491c      	ldr	r1, [pc, #112]	; (802a530 <Nintegration+0x840>)
 802a4c0:	68fa      	ldr	r2, [r7, #12]
 802a4c2:	4613      	mov	r3, r2
 802a4c4:	005b      	lsls	r3, r3, #1
 802a4c6:	4413      	add	r3, r2
 802a4c8:	693a      	ldr	r2, [r7, #16]
 802a4ca:	4413      	add	r3, r2
 802a4cc:	009b      	lsls	r3, r3, #2
 802a4ce:	440b      	add	r3, r1
 802a4d0:	f04f 0200 	mov.w	r2, #0
 802a4d4:	601a      	str	r2, [r3, #0]
			for(int j = 0; j < 3; j++)
 802a4d6:	68fb      	ldr	r3, [r7, #12]
 802a4d8:	3301      	adds	r3, #1
 802a4da:	60fb      	str	r3, [r7, #12]
 802a4dc:	68fb      	ldr	r3, [r7, #12]
 802a4de:	2b02      	cmp	r3, #2
 802a4e0:	ddd5      	ble.n	802a48e <Nintegration+0x79e>
		for(int i = 0; i < 3; i++)
 802a4e2:	693b      	ldr	r3, [r7, #16]
 802a4e4:	3301      	adds	r3, #1
 802a4e6:	613b      	str	r3, [r7, #16]
 802a4e8:	693b      	ldr	r3, [r7, #16]
 802a4ea:	2b02      	cmp	r3, #2
 802a4ec:	ddb0      	ble.n	802a450 <Nintegration+0x760>
			}
		}
		sets=0;
 802a4ee:	4b11      	ldr	r3, [pc, #68]	; (802a534 <Nintegration+0x844>)
 802a4f0:	2200      	movs	r2, #0
 802a4f2:	601a      	str	r2, [r3, #0]
	}
}
 802a4f4:	bf00      	nop
 802a4f6:	3730      	adds	r7, #48	; 0x30
 802a4f8:	46bd      	mov	sp, r7
 802a4fa:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 802a4fe:	bf00      	nop
 802a500:	2000062c 	.word	0x2000062c
 802a504:	2000184c 	.word	0x2000184c
 802a508:	20001660 	.word	0x20001660
 802a50c:	200014d0 	.word	0x200014d0
 802a510:	200018d0 	.word	0x200018d0
 802a514:	200014d4 	.word	0x200014d4
 802a518:	2000148c 	.word	0x2000148c
 802a51c:	200014bc 	.word	0x200014bc
 802a520:	200018c4 	.word	0x200018c4
 802a524:	20001840 	.word	0x20001840
 802a528:	20001444 	.word	0x20001444
 802a52c:	20001498 	.word	0x20001498
 802a530:	20001468 	.word	0x20001468
 802a534:	200014cc 	.word	0x200014cc

0802a538 <HAL_UART_TxCpltCallback>:
// UART DMA handler
// Being call after done with the transmission
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 802a538:	b580      	push	{r7, lr}
 802a53a:	b082      	sub	sp, #8
 802a53c:	af00      	add	r7, sp, #0
 802a53e:	6078      	str	r0, [r7, #4]
	HAL_UART_DMAPause(&huart1);									  //Pause UART
 802a540:	4803      	ldr	r0, [pc, #12]	; (802a550 <HAL_UART_TxCpltCallback+0x18>)
 802a542:	f003 fdbd 	bl	802e0c0 <HAL_UART_DMAPause>
}
 802a546:	bf00      	nop
 802a548:	3708      	adds	r7, #8
 802a54a:	46bd      	mov	sp, r7
 802a54c:	bd80      	pop	{r7, pc}
 802a54e:	bf00      	nop
 802a550:	20001660 	.word	0x20001660

0802a554 <MX_TIM4_Init>:
//PWM configuration (stm32f4xx_hal_msp.c defines Port and Pin)
//Variable for changing PWM frequency
//GPIO B6
//1.Prescaler 2.Period 3.Pulse
void MX_TIM4_Init(void)
{
 802a554:	b580      	push	{r7, lr}
 802a556:	b08e      	sub	sp, #56	; 0x38
 802a558:	af00      	add	r7, sp, #0
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 802a55a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 802a55e:	2200      	movs	r2, #0
 802a560:	601a      	str	r2, [r3, #0]
 802a562:	605a      	str	r2, [r3, #4]
 802a564:	609a      	str	r2, [r3, #8]
 802a566:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 802a568:	f107 0320 	add.w	r3, r7, #32
 802a56c:	2200      	movs	r2, #0
 802a56e:	601a      	str	r2, [r3, #0]
 802a570:	605a      	str	r2, [r3, #4]
  TIM_OC_InitTypeDef sConfigOC = {0};
 802a572:	1d3b      	adds	r3, r7, #4
 802a574:	2200      	movs	r2, #0
 802a576:	601a      	str	r2, [r3, #0]
 802a578:	605a      	str	r2, [r3, #4]
 802a57a:	609a      	str	r2, [r3, #8]
 802a57c:	60da      	str	r2, [r3, #12]
 802a57e:	611a      	str	r2, [r3, #16]
 802a580:	615a      	str	r2, [r3, #20]
 802a582:	619a      	str	r2, [r3, #24]
  htim4.Instance = TIM4;
 802a584:	4b2c      	ldr	r3, [pc, #176]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a586:	4a2d      	ldr	r2, [pc, #180]	; (802a63c <MX_TIM4_Init+0xe8>)
 802a588:	601a      	str	r2, [r3, #0]
  htim4.Init.Prescaler = 52499;
 802a58a:	4b2b      	ldr	r3, [pc, #172]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a58c:	f64c 5213 	movw	r2, #52499	; 0xcd13
 802a590:	605a      	str	r2, [r3, #4]
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 802a592:	4b29      	ldr	r3, [pc, #164]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a594:	2200      	movs	r2, #0
 802a596:	609a      	str	r2, [r3, #8]
  htim4.Init.Period = 1;
 802a598:	4b27      	ldr	r3, [pc, #156]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a59a:	2201      	movs	r2, #1
 802a59c:	60da      	str	r2, [r3, #12]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 802a59e:	4b26      	ldr	r3, [pc, #152]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a5a0:	2200      	movs	r2, #0
 802a5a2:	611a      	str	r2, [r3, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 802a5a4:	4b24      	ldr	r3, [pc, #144]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a5a6:	2200      	movs	r2, #0
 802a5a8:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 802a5aa:	4823      	ldr	r0, [pc, #140]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a5ac:	f002 ff38 	bl	802d420 <HAL_TIM_Base_Init>
 802a5b0:	4603      	mov	r3, r0
 802a5b2:	2b00      	cmp	r3, #0
 802a5b4:	d001      	beq.n	802a5ba <MX_TIM4_Init+0x66>
  {
    Error_Handler();
 802a5b6:	f7ff f9dd 	bl	8029974 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 802a5ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 802a5be:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 802a5c0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 802a5c4:	4619      	mov	r1, r3
 802a5c6:	481c      	ldr	r0, [pc, #112]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a5c8:	f003 f8ce 	bl	802d768 <HAL_TIM_ConfigClockSource>
 802a5cc:	4603      	mov	r3, r0
 802a5ce:	2b00      	cmp	r3, #0
 802a5d0:	d001      	beq.n	802a5d6 <MX_TIM4_Init+0x82>
  {
    Error_Handler();
 802a5d2:	f7ff f9cf 	bl	8029974 <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 802a5d6:	4818      	ldr	r0, [pc, #96]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a5d8:	f002 ff4d 	bl	802d476 <HAL_TIM_PWM_Init>
 802a5dc:	4603      	mov	r3, r0
 802a5de:	2b00      	cmp	r3, #0
 802a5e0:	d001      	beq.n	802a5e6 <MX_TIM4_Init+0x92>
  {
    Error_Handler();
 802a5e2:	f7ff f9c7 	bl	8029974 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 802a5e6:	2300      	movs	r3, #0
 802a5e8:	623b      	str	r3, [r7, #32]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 802a5ea:	2300      	movs	r3, #0
 802a5ec:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 802a5ee:	f107 0320 	add.w	r3, r7, #32
 802a5f2:	4619      	mov	r1, r3
 802a5f4:	4810      	ldr	r0, [pc, #64]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a5f6:	f003 fc3b 	bl	802de70 <HAL_TIMEx_MasterConfigSynchronization>
 802a5fa:	4603      	mov	r3, r0
 802a5fc:	2b00      	cmp	r3, #0
 802a5fe:	d001      	beq.n	802a604 <MX_TIM4_Init+0xb0>
  {
    Error_Handler();
 802a600:	f7ff f9b8 	bl	8029974 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 802a604:	2360      	movs	r3, #96	; 0x60
 802a606:	607b      	str	r3, [r7, #4]
  sConfigOC.Pulse = 1;
 802a608:	2301      	movs	r3, #1
 802a60a:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 802a60c:	2300      	movs	r3, #0
 802a60e:	60fb      	str	r3, [r7, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 802a610:	2304      	movs	r3, #4
 802a612:	617b      	str	r3, [r7, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 802a614:	1d3b      	adds	r3, r7, #4
 802a616:	2200      	movs	r2, #0
 802a618:	4619      	mov	r1, r3
 802a61a:	4807      	ldr	r0, [pc, #28]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a61c:	f002 ffde 	bl	802d5dc <HAL_TIM_PWM_ConfigChannel>
 802a620:	4603      	mov	r3, r0
 802a622:	2b00      	cmp	r3, #0
 802a624:	d001      	beq.n	802a62a <MX_TIM4_Init+0xd6>
  {
    Error_Handler();
 802a626:	f7ff f9a5 	bl	8029974 <Error_Handler>
  }
  HAL_TIM_MspPostInit(&htim4);
 802a62a:	4803      	ldr	r0, [pc, #12]	; (802a638 <MX_TIM4_Init+0xe4>)
 802a62c:	f000 f942 	bl	802a8b4 <HAL_TIM_MspPostInit>

}
 802a630:	bf00      	nop
 802a632:	3738      	adds	r7, #56	; 0x38
 802a634:	46bd      	mov	sp, r7
 802a636:	bd80      	pop	{r7, pc}
 802a638:	20001520 	.word	0x20001520
 802a63c:	40000800 	.word	0x40000800

0802a640 <MX_SPI1_Init>:
   *PA5     ------> SPI1_SCK
   *PA6     ------> SPI1_MISO
   *PA7     ------> SPI1_MOSI
   */
void MX_SPI1_Init(void)
{
 802a640:	b580      	push	{r7, lr}
 802a642:	af00      	add	r7, sp, #0
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 802a644:	4b18      	ldr	r3, [pc, #96]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a646:	4a19      	ldr	r2, [pc, #100]	; (802a6ac <MX_SPI1_Init+0x6c>)
 802a648:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 802a64a:	4b17      	ldr	r3, [pc, #92]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a64c:	f44f 7282 	mov.w	r2, #260	; 0x104
 802a650:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 802a652:	4b15      	ldr	r3, [pc, #84]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a654:	2200      	movs	r2, #0
 802a656:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_16BIT;							//SPI Mode 3 configuration
 802a658:	4b13      	ldr	r3, [pc, #76]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a65a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802a65e:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;						//SPI Mode 3 configuration
 802a660:	4b11      	ldr	r3, [pc, #68]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a662:	2202      	movs	r2, #2
 802a664:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;							//SPI Mode 3 configuration
 802a666:	4b10      	ldr	r3, [pc, #64]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a668:	2201      	movs	r2, #1
 802a66a:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 802a66c:	4b0e      	ldr	r3, [pc, #56]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a66e:	f44f 7200 	mov.w	r2, #512	; 0x200
 802a672:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;			//SPI clock rate: system clock/pre-scaler
 802a674:	4b0c      	ldr	r3, [pc, #48]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a676:	2218      	movs	r2, #24
 802a678:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 802a67a:	4b0b      	ldr	r3, [pc, #44]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a67c:	2200      	movs	r2, #0
 802a67e:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 802a680:	4b09      	ldr	r3, [pc, #36]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a682:	2200      	movs	r2, #0
 802a684:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802a686:	4b08      	ldr	r3, [pc, #32]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a688:	2200      	movs	r2, #0
 802a68a:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 802a68c:	4b06      	ldr	r3, [pc, #24]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a68e:	220a      	movs	r2, #10
 802a690:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 802a692:	4805      	ldr	r0, [pc, #20]	; (802a6a8 <MX_SPI1_Init+0x68>)
 802a694:	f002 f844 	bl	802c720 <HAL_SPI_Init>
 802a698:	4603      	mov	r3, r0
 802a69a:	2b00      	cmp	r3, #0
 802a69c:	d001      	beq.n	802a6a2 <MX_SPI1_Init+0x62>
  {
    Error_Handler();
 802a69e:	f7ff f969 	bl	8029974 <Error_Handler>
  }
}
 802a6a2:	bf00      	nop
 802a6a4:	bd80      	pop	{r7, pc}
 802a6a6:	bf00      	nop
 802a6a8:	200016a0 	.word	0x200016a0
 802a6ac:	40013000 	.word	0x40013000

0802a6b0 <MX_SPI1_Init_8BIT>:

void MX_SPI1_Init_8BIT(void)
{
 802a6b0:	b580      	push	{r7, lr}
 802a6b2:	af00      	add	r7, sp, #0
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
 802a6b4:	4b17      	ldr	r3, [pc, #92]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6b6:	4a18      	ldr	r2, [pc, #96]	; (802a718 <MX_SPI1_Init_8BIT+0x68>)
 802a6b8:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 802a6ba:	4b16      	ldr	r3, [pc, #88]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6bc:	f44f 7282 	mov.w	r2, #260	; 0x104
 802a6c0:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 802a6c2:	4b14      	ldr	r3, [pc, #80]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6c4:	2200      	movs	r2, #0
 802a6c6:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 802a6c8:	4b12      	ldr	r3, [pc, #72]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6ca:	2200      	movs	r2, #0
 802a6cc:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;						//SPI Mode 3 configuration for LSM6DSL SPI requirement
 802a6ce:	4b11      	ldr	r3, [pc, #68]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6d0:	2202      	movs	r2, #2
 802a6d2:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;							//SPI Mode 3 configuration for LSM6DSL SPI requirement
 802a6d4:	4b0f      	ldr	r3, [pc, #60]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6d6:	2201      	movs	r2, #1
 802a6d8:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 802a6da:	4b0e      	ldr	r3, [pc, #56]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6dc:	f44f 7200 	mov.w	r2, #512	; 0x200
 802a6e0:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;			//SPI clock rate: system clock/pre-scaler
 802a6e2:	4b0c      	ldr	r3, [pc, #48]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6e4:	2218      	movs	r2, #24
 802a6e6:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 802a6e8:	4b0a      	ldr	r3, [pc, #40]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6ea:	2200      	movs	r2, #0
 802a6ec:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 802a6ee:	4b09      	ldr	r3, [pc, #36]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6f0:	2200      	movs	r2, #0
 802a6f2:	625a      	str	r2, [r3, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802a6f4:	4b07      	ldr	r3, [pc, #28]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6f6:	2200      	movs	r2, #0
 802a6f8:	629a      	str	r2, [r3, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 10;
 802a6fa:	4b06      	ldr	r3, [pc, #24]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a6fc:	220a      	movs	r2, #10
 802a6fe:	62da      	str	r2, [r3, #44]	; 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 802a700:	4804      	ldr	r0, [pc, #16]	; (802a714 <MX_SPI1_Init_8BIT+0x64>)
 802a702:	f002 f80d 	bl	802c720 <HAL_SPI_Init>
 802a706:	4603      	mov	r3, r0
 802a708:	2b00      	cmp	r3, #0
 802a70a:	d001      	beq.n	802a710 <MX_SPI1_Init_8BIT+0x60>
  {
    Error_Handler();
 802a70c:	f7ff f932 	bl	8029974 <Error_Handler>
  }
}
 802a710:	bf00      	nop
 802a712:	bd80      	pop	{r7, pc}
 802a714:	200016a0 	.word	0x200016a0
 802a718:	40013000 	.word	0x40013000

0802a71c <spi_DMA_RX>:

//SPI DMA function
//Input : tx/rx data address, Port and Pin for CS and byte to transmit and receive
//Output: None
void spi_DMA_RX(uint8_t *txdata, uint8_t *rxdata,GPIO_TypeDef* Port, uint16_t Pin, int byteNumber)
{
 802a71c:	b580      	push	{r7, lr}
 802a71e:	b084      	sub	sp, #16
 802a720:	af00      	add	r7, sp, #0
 802a722:	60f8      	str	r0, [r7, #12]
 802a724:	60b9      	str	r1, [r7, #8]
 802a726:	607a      	str	r2, [r7, #4]
 802a728:	807b      	strh	r3, [r7, #2]
	 HAL_SPI_DMAResume(&hspi1);
 802a72a:	480a      	ldr	r0, [pc, #40]	; (802a754 <spi_DMA_RX+0x38>)
 802a72c:	f002 fc56 	bl	802cfdc <HAL_SPI_DMAResume>
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET );
 802a730:	887b      	ldrh	r3, [r7, #2]
 802a732:	2200      	movs	r2, #0
 802a734:	4619      	mov	r1, r3
 802a736:	6878      	ldr	r0, [r7, #4]
 802a738:	f001 fb76 	bl	802be28 <HAL_GPIO_WritePin>
	 HAL_SPI_TransmitReceive_DMA( &hspi1, txdata, (uint8_t*)rxdata, byteNumber);
 802a73c:	69bb      	ldr	r3, [r7, #24]
 802a73e:	b29b      	uxth	r3, r3
 802a740:	68ba      	ldr	r2, [r7, #8]
 802a742:	68f9      	ldr	r1, [r7, #12]
 802a744:	4803      	ldr	r0, [pc, #12]	; (802a754 <spi_DMA_RX+0x38>)
 802a746:	f002 fb25 	bl	802cd94 <HAL_SPI_TransmitReceive_DMA>
}
 802a74a:	bf00      	nop
 802a74c:	3710      	adds	r7, #16
 802a74e:	46bd      	mov	sp, r7
 802a750:	bd80      	pop	{r7, pc}
 802a752:	bf00      	nop
 802a754:	200016a0 	.word	0x200016a0

0802a758 <spi_RX>:

//SPI polling code, one byte per transmission
//Better use with 16 bits clock cycle confirguation
void spi_RX(uint16_t *txdata, uint8_t *rxdata,GPIO_TypeDef* Port, uint16_t Pin)
{
 802a758:	b580      	push	{r7, lr}
 802a75a:	b086      	sub	sp, #24
 802a75c:	af02      	add	r7, sp, #8
 802a75e:	60f8      	str	r0, [r7, #12]
 802a760:	60b9      	str	r1, [r7, #8]
 802a762:	607a      	str	r2, [r7, #4]
 802a764:	807b      	strh	r3, [r7, #2]
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET );
 802a766:	887b      	ldrh	r3, [r7, #2]
 802a768:	2200      	movs	r2, #0
 802a76a:	4619      	mov	r1, r3
 802a76c:	6878      	ldr	r0, [r7, #4]
 802a76e:	f001 fb5b 	bl	802be28 <HAL_GPIO_WritePin>
	 HAL_SPI_TransmitReceive( &hspi1, (uint8_t*)txdata, rxdata, 1, 100);
 802a772:	2364      	movs	r3, #100	; 0x64
 802a774:	9300      	str	r3, [sp, #0]
 802a776:	2301      	movs	r3, #1
 802a778:	68ba      	ldr	r2, [r7, #8]
 802a77a:	68f9      	ldr	r1, [r7, #12]
 802a77c:	4809      	ldr	r0, [pc, #36]	; (802a7a4 <spi_RX+0x4c>)
 802a77e:	f002 f967 	bl	802ca50 <HAL_SPI_TransmitReceive>
	 while( hspi1.State == HAL_SPI_STATE_BUSY );
 802a782:	bf00      	nop
 802a784:	4b07      	ldr	r3, [pc, #28]	; (802a7a4 <spi_RX+0x4c>)
 802a786:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802a78a:	b2db      	uxtb	r3, r3
 802a78c:	2b02      	cmp	r3, #2
 802a78e:	d0f9      	beq.n	802a784 <spi_RX+0x2c>
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_SET );
 802a790:	887b      	ldrh	r3, [r7, #2]
 802a792:	2201      	movs	r2, #1
 802a794:	4619      	mov	r1, r3
 802a796:	6878      	ldr	r0, [r7, #4]
 802a798:	f001 fb46 	bl	802be28 <HAL_GPIO_WritePin>
}
 802a79c:	bf00      	nop
 802a79e:	3710      	adds	r7, #16
 802a7a0:	46bd      	mov	sp, r7
 802a7a2:	bd80      	pop	{r7, pc}
 802a7a4:	200016a0 	.word	0x200016a0

0802a7a8 <spi_write>:

//SPI write without reading it back
//Use in configuration
void spi_write(uint16_t *txadddata, GPIO_TypeDef* Port, uint16_t Pin)
{
 802a7a8:	b580      	push	{r7, lr}
 802a7aa:	b084      	sub	sp, #16
 802a7ac:	af00      	add	r7, sp, #0
 802a7ae:	60f8      	str	r0, [r7, #12]
 802a7b0:	60b9      	str	r1, [r7, #8]
 802a7b2:	4613      	mov	r3, r2
 802a7b4:	80fb      	strh	r3, [r7, #6]
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_RESET );
 802a7b6:	88fb      	ldrh	r3, [r7, #6]
 802a7b8:	2200      	movs	r2, #0
 802a7ba:	4619      	mov	r1, r3
 802a7bc:	68b8      	ldr	r0, [r7, #8]
 802a7be:	f001 fb33 	bl	802be28 <HAL_GPIO_WritePin>
	 HAL_SPI_Transmit( &hspi1, (uint8_t*)txadddata, 1, 100);
 802a7c2:	2364      	movs	r3, #100	; 0x64
 802a7c4:	2201      	movs	r2, #1
 802a7c6:	68f9      	ldr	r1, [r7, #12]
 802a7c8:	4809      	ldr	r0, [pc, #36]	; (802a7f0 <spi_write+0x48>)
 802a7ca:	f002 f80d 	bl	802c7e8 <HAL_SPI_Transmit>
	 while( hspi1.State == HAL_SPI_STATE_BUSY );
 802a7ce:	bf00      	nop
 802a7d0:	4b07      	ldr	r3, [pc, #28]	; (802a7f0 <spi_write+0x48>)
 802a7d2:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802a7d6:	b2db      	uxtb	r3, r3
 802a7d8:	2b02      	cmp	r3, #2
 802a7da:	d0f9      	beq.n	802a7d0 <spi_write+0x28>
	 HAL_GPIO_WritePin(Port, Pin, GPIO_PIN_SET );
 802a7dc:	88fb      	ldrh	r3, [r7, #6]
 802a7de:	2201      	movs	r2, #1
 802a7e0:	4619      	mov	r1, r3
 802a7e2:	68b8      	ldr	r0, [r7, #8]
 802a7e4:	f001 fb20 	bl	802be28 <HAL_GPIO_WritePin>
}
 802a7e8:	bf00      	nop
 802a7ea:	3710      	adds	r7, #16
 802a7ec:	46bd      	mov	sp, r7
 802a7ee:	bd80      	pop	{r7, pc}
 802a7f0:	200016a0 	.word	0x200016a0

0802a7f4 <HAL_MspInit>:
extern DMA_HandleTypeDef hdma_usart1_rx;
extern DMA_HandleTypeDef hdma_spi1_rx;
extern DMA_HandleTypeDef hdma_spi1_tx;

void HAL_MspInit(void)
{
 802a7f4:	b580      	push	{r7, lr}
 802a7f6:	b082      	sub	sp, #8
 802a7f8:	af00      	add	r7, sp, #0
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 802a7fa:	2300      	movs	r3, #0
 802a7fc:	607b      	str	r3, [r7, #4]
 802a7fe:	4b10      	ldr	r3, [pc, #64]	; (802a840 <HAL_MspInit+0x4c>)
 802a800:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802a802:	4a0f      	ldr	r2, [pc, #60]	; (802a840 <HAL_MspInit+0x4c>)
 802a804:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802a808:	6453      	str	r3, [r2, #68]	; 0x44
 802a80a:	4b0d      	ldr	r3, [pc, #52]	; (802a840 <HAL_MspInit+0x4c>)
 802a80c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802a80e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 802a812:	607b      	str	r3, [r7, #4]
 802a814:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 802a816:	2300      	movs	r3, #0
 802a818:	603b      	str	r3, [r7, #0]
 802a81a:	4b09      	ldr	r3, [pc, #36]	; (802a840 <HAL_MspInit+0x4c>)
 802a81c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802a81e:	4a08      	ldr	r2, [pc, #32]	; (802a840 <HAL_MspInit+0x4c>)
 802a820:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802a824:	6413      	str	r3, [r2, #64]	; 0x40
 802a826:	4b06      	ldr	r3, [pc, #24]	; (802a840 <HAL_MspInit+0x4c>)
 802a828:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802a82a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802a82e:	603b      	str	r3, [r7, #0]
 802a830:	683b      	ldr	r3, [r7, #0]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_0);
 802a832:	2007      	movs	r0, #7
 802a834:	f000 fd8c 	bl	802b350 <HAL_NVIC_SetPriorityGrouping>
}
 802a838:	bf00      	nop
 802a83a:	3708      	adds	r7, #8
 802a83c:	46bd      	mov	sp, r7
 802a83e:	bd80      	pop	{r7, pc}
 802a840:	40023800 	.word	0x40023800

0802a844 <HAL_TIM_Base_MspInit>:


void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 802a844:	b480      	push	{r7}
 802a846:	b085      	sub	sp, #20
 802a848:	af00      	add	r7, sp, #0
 802a84a:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM3)
 802a84c:	687b      	ldr	r3, [r7, #4]
 802a84e:	681b      	ldr	r3, [r3, #0]
 802a850:	4a15      	ldr	r2, [pc, #84]	; (802a8a8 <HAL_TIM_Base_MspInit+0x64>)
 802a852:	4293      	cmp	r3, r2
 802a854:	d10e      	bne.n	802a874 <HAL_TIM_Base_MspInit+0x30>
  {
    __HAL_RCC_TIM3_CLK_ENABLE();
 802a856:	2300      	movs	r3, #0
 802a858:	60fb      	str	r3, [r7, #12]
 802a85a:	4b14      	ldr	r3, [pc, #80]	; (802a8ac <HAL_TIM_Base_MspInit+0x68>)
 802a85c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802a85e:	4a13      	ldr	r2, [pc, #76]	; (802a8ac <HAL_TIM_Base_MspInit+0x68>)
 802a860:	f043 0302 	orr.w	r3, r3, #2
 802a864:	6413      	str	r3, [r2, #64]	; 0x40
 802a866:	4b11      	ldr	r3, [pc, #68]	; (802a8ac <HAL_TIM_Base_MspInit+0x68>)
 802a868:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802a86a:	f003 0302 	and.w	r3, r3, #2
 802a86e:	60fb      	str	r3, [r7, #12]
 802a870:	68fb      	ldr	r3, [r7, #12]
  else if(htim_base->Instance==TIM4)
  {
    __HAL_RCC_TIM4_CLK_ENABLE();
  }

}
 802a872:	e012      	b.n	802a89a <HAL_TIM_Base_MspInit+0x56>
  else if(htim_base->Instance==TIM4)
 802a874:	687b      	ldr	r3, [r7, #4]
 802a876:	681b      	ldr	r3, [r3, #0]
 802a878:	4a0d      	ldr	r2, [pc, #52]	; (802a8b0 <HAL_TIM_Base_MspInit+0x6c>)
 802a87a:	4293      	cmp	r3, r2
 802a87c:	d10d      	bne.n	802a89a <HAL_TIM_Base_MspInit+0x56>
    __HAL_RCC_TIM4_CLK_ENABLE();
 802a87e:	2300      	movs	r3, #0
 802a880:	60bb      	str	r3, [r7, #8]
 802a882:	4b0a      	ldr	r3, [pc, #40]	; (802a8ac <HAL_TIM_Base_MspInit+0x68>)
 802a884:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802a886:	4a09      	ldr	r2, [pc, #36]	; (802a8ac <HAL_TIM_Base_MspInit+0x68>)
 802a888:	f043 0304 	orr.w	r3, r3, #4
 802a88c:	6413      	str	r3, [r2, #64]	; 0x40
 802a88e:	4b07      	ldr	r3, [pc, #28]	; (802a8ac <HAL_TIM_Base_MspInit+0x68>)
 802a890:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802a892:	f003 0304 	and.w	r3, r3, #4
 802a896:	60bb      	str	r3, [r7, #8]
 802a898:	68bb      	ldr	r3, [r7, #8]
}
 802a89a:	bf00      	nop
 802a89c:	3714      	adds	r7, #20
 802a89e:	46bd      	mov	sp, r7
 802a8a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802a8a4:	4770      	bx	lr
 802a8a6:	bf00      	nop
 802a8a8:	40000400 	.word	0x40000400
 802a8ac:	40023800 	.word	0x40023800
 802a8b0:	40000800 	.word	0x40000800

0802a8b4 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 802a8b4:	b580      	push	{r7, lr}
 802a8b6:	b08a      	sub	sp, #40	; 0x28
 802a8b8:	af00      	add	r7, sp, #0
 802a8ba:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802a8bc:	f107 0314 	add.w	r3, r7, #20
 802a8c0:	2200      	movs	r2, #0
 802a8c2:	601a      	str	r2, [r3, #0]
 802a8c4:	605a      	str	r2, [r3, #4]
 802a8c6:	609a      	str	r2, [r3, #8]
 802a8c8:	60da      	str	r2, [r3, #12]
 802a8ca:	611a      	str	r2, [r3, #16]
  if(htim->Instance==TIM3)
 802a8cc:	687b      	ldr	r3, [r7, #4]
 802a8ce:	681b      	ldr	r3, [r3, #0]
 802a8d0:	4a24      	ldr	r2, [pc, #144]	; (802a964 <HAL_TIM_MspPostInit+0xb0>)
 802a8d2:	4293      	cmp	r3, r2
 802a8d4:	d11e      	bne.n	802a914 <HAL_TIM_MspPostInit+0x60>
  {
    __HAL_RCC_GPIOC_CLK_ENABLE();
 802a8d6:	2300      	movs	r3, #0
 802a8d8:	613b      	str	r3, [r7, #16]
 802a8da:	4b23      	ldr	r3, [pc, #140]	; (802a968 <HAL_TIM_MspPostInit+0xb4>)
 802a8dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a8de:	4a22      	ldr	r2, [pc, #136]	; (802a968 <HAL_TIM_MspPostInit+0xb4>)
 802a8e0:	f043 0304 	orr.w	r3, r3, #4
 802a8e4:	6313      	str	r3, [r2, #48]	; 0x30
 802a8e6:	4b20      	ldr	r3, [pc, #128]	; (802a968 <HAL_TIM_MspPostInit+0xb4>)
 802a8e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a8ea:	f003 0304 	and.w	r3, r3, #4
 802a8ee:	613b      	str	r3, [r7, #16]
 802a8f0:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 802a8f2:	2340      	movs	r3, #64	; 0x40
 802a8f4:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802a8f6:	2302      	movs	r3, #2
 802a8f8:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802a8fa:	2300      	movs	r3, #0
 802a8fc:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802a8fe:	2300      	movs	r3, #0
 802a900:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 802a902:	2302      	movs	r3, #2
 802a904:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 802a906:	f107 0314 	add.w	r3, r7, #20
 802a90a:	4619      	mov	r1, r3
 802a90c:	4817      	ldr	r0, [pc, #92]	; (802a96c <HAL_TIM_MspPostInit+0xb8>)
 802a90e:	f001 f8f1 	bl	802baf4 <HAL_GPIO_Init>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  }

}
 802a912:	e022      	b.n	802a95a <HAL_TIM_MspPostInit+0xa6>
  else if(htim->Instance==TIM4)
 802a914:	687b      	ldr	r3, [r7, #4]
 802a916:	681b      	ldr	r3, [r3, #0]
 802a918:	4a15      	ldr	r2, [pc, #84]	; (802a970 <HAL_TIM_MspPostInit+0xbc>)
 802a91a:	4293      	cmp	r3, r2
 802a91c:	d11d      	bne.n	802a95a <HAL_TIM_MspPostInit+0xa6>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 802a91e:	2300      	movs	r3, #0
 802a920:	60fb      	str	r3, [r7, #12]
 802a922:	4b11      	ldr	r3, [pc, #68]	; (802a968 <HAL_TIM_MspPostInit+0xb4>)
 802a924:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a926:	4a10      	ldr	r2, [pc, #64]	; (802a968 <HAL_TIM_MspPostInit+0xb4>)
 802a928:	f043 0302 	orr.w	r3, r3, #2
 802a92c:	6313      	str	r3, [r2, #48]	; 0x30
 802a92e:	4b0e      	ldr	r3, [pc, #56]	; (802a968 <HAL_TIM_MspPostInit+0xb4>)
 802a930:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a932:	f003 0302 	and.w	r3, r3, #2
 802a936:	60fb      	str	r3, [r7, #12]
 802a938:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_6;
 802a93a:	2340      	movs	r3, #64	; 0x40
 802a93c:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802a93e:	2302      	movs	r3, #2
 802a940:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802a942:	2300      	movs	r3, #0
 802a944:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802a946:	2300      	movs	r3, #0
 802a948:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 802a94a:	2302      	movs	r3, #2
 802a94c:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 802a94e:	f107 0314 	add.w	r3, r7, #20
 802a952:	4619      	mov	r1, r3
 802a954:	4807      	ldr	r0, [pc, #28]	; (802a974 <HAL_TIM_MspPostInit+0xc0>)
 802a956:	f001 f8cd 	bl	802baf4 <HAL_GPIO_Init>
}
 802a95a:	bf00      	nop
 802a95c:	3728      	adds	r7, #40	; 0x28
 802a95e:	46bd      	mov	sp, r7
 802a960:	bd80      	pop	{r7, pc}
 802a962:	bf00      	nop
 802a964:	40000400 	.word	0x40000400
 802a968:	40023800 	.word	0x40023800
 802a96c:	40020800 	.word	0x40020800
 802a970:	40000800 	.word	0x40000800
 802a974:	40020400 	.word	0x40020400

0802a978 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 802a978:	b580      	push	{r7, lr}
 802a97a:	b08c      	sub	sp, #48	; 0x30
 802a97c:	af00      	add	r7, sp, #0
 802a97e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802a980:	f107 031c 	add.w	r3, r7, #28
 802a984:	2200      	movs	r2, #0
 802a986:	601a      	str	r2, [r3, #0]
 802a988:	605a      	str	r2, [r3, #4]
 802a98a:	609a      	str	r2, [r3, #8]
 802a98c:	60da      	str	r2, [r3, #12]
 802a98e:	611a      	str	r2, [r3, #16]
  if(huart->Instance==USART1)
 802a990:	687b      	ldr	r3, [r7, #4]
 802a992:	681b      	ldr	r3, [r3, #0]
 802a994:	4a66      	ldr	r2, [pc, #408]	; (802ab30 <HAL_UART_MspInit+0x1b8>)
 802a996:	4293      	cmp	r3, r2
 802a998:	f040 8094 	bne.w	802aac4 <HAL_UART_MspInit+0x14c>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 802a99c:	2300      	movs	r3, #0
 802a99e:	61bb      	str	r3, [r7, #24]
 802a9a0:	4b64      	ldr	r3, [pc, #400]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802a9a2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802a9a4:	4a63      	ldr	r2, [pc, #396]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802a9a6:	f043 0310 	orr.w	r3, r3, #16
 802a9aa:	6453      	str	r3, [r2, #68]	; 0x44
 802a9ac:	4b61      	ldr	r3, [pc, #388]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802a9ae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802a9b0:	f003 0310 	and.w	r3, r3, #16
 802a9b4:	61bb      	str	r3, [r7, #24]
 802a9b6:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 802a9b8:	2300      	movs	r3, #0
 802a9ba:	617b      	str	r3, [r7, #20]
 802a9bc:	4b5d      	ldr	r3, [pc, #372]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802a9be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a9c0:	4a5c      	ldr	r2, [pc, #368]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802a9c2:	f043 0301 	orr.w	r3, r3, #1
 802a9c6:	6313      	str	r3, [r2, #48]	; 0x30
 802a9c8:	4b5a      	ldr	r3, [pc, #360]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802a9ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a9cc:	f003 0301 	and.w	r3, r3, #1
 802a9d0:	617b      	str	r3, [r7, #20]
 802a9d2:	697b      	ldr	r3, [r7, #20]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 802a9d4:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 802a9d8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802a9da:	2302      	movs	r3, #2
 802a9dc:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802a9de:	2300      	movs	r3, #0
 802a9e0:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802a9e2:	2303      	movs	r3, #3
 802a9e4:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 802a9e6:	2307      	movs	r3, #7
 802a9e8:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802a9ea:	f107 031c 	add.w	r3, r7, #28
 802a9ee:	4619      	mov	r1, r3
 802a9f0:	4851      	ldr	r0, [pc, #324]	; (802ab38 <HAL_UART_MspInit+0x1c0>)
 802a9f2:	f001 f87f 	bl	802baf4 <HAL_GPIO_Init>

    /* USART1 DMA Init */
    /* USART1_TX Init */
    hdma_usart1_tx.Instance = DMA2_Stream7;
 802a9f6:	4b51      	ldr	r3, [pc, #324]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802a9f8:	4a51      	ldr	r2, [pc, #324]	; (802ab40 <HAL_UART_MspInit+0x1c8>)
 802a9fa:	601a      	str	r2, [r3, #0]
    hdma_usart1_tx.Init.Channel = DMA_CHANNEL_4;
 802a9fc:	4b4f      	ldr	r3, [pc, #316]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802a9fe:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802aa02:	605a      	str	r2, [r3, #4]
    hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802aa04:	4b4d      	ldr	r3, [pc, #308]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa06:	2240      	movs	r2, #64	; 0x40
 802aa08:	609a      	str	r2, [r3, #8]
    hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802aa0a:	4b4c      	ldr	r3, [pc, #304]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa0c:	2200      	movs	r2, #0
 802aa0e:	60da      	str	r2, [r3, #12]
    hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
 802aa10:	4b4a      	ldr	r3, [pc, #296]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa12:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802aa16:	611a      	str	r2, [r3, #16]
    hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802aa18:	4b48      	ldr	r3, [pc, #288]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa1a:	2200      	movs	r2, #0
 802aa1c:	615a      	str	r2, [r3, #20]
    hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 802aa1e:	4b47      	ldr	r3, [pc, #284]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa20:	2200      	movs	r2, #0
 802aa22:	619a      	str	r2, [r3, #24]
    hdma_usart1_tx.Init.Mode = DMA_CIRCULAR;
 802aa24:	4b45      	ldr	r3, [pc, #276]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa26:	f44f 7280 	mov.w	r2, #256	; 0x100
 802aa2a:	61da      	str	r2, [r3, #28]
    hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
 802aa2c:	4b43      	ldr	r3, [pc, #268]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa2e:	2200      	movs	r2, #0
 802aa30:	621a      	str	r2, [r3, #32]
    hdma_usart1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802aa32:	4b42      	ldr	r3, [pc, #264]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa34:	2200      	movs	r2, #0
 802aa36:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
 802aa38:	4840      	ldr	r0, [pc, #256]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa3a:	f000 fccb 	bl	802b3d4 <HAL_DMA_Init>
 802aa3e:	4603      	mov	r3, r0
 802aa40:	2b00      	cmp	r3, #0
 802aa42:	d001      	beq.n	802aa48 <HAL_UART_MspInit+0xd0>
    {
      Error_Handler();
 802aa44:	f7fe ff96 	bl	8029974 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx);
 802aa48:	687b      	ldr	r3, [r7, #4]
 802aa4a:	4a3c      	ldr	r2, [pc, #240]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa4c:	631a      	str	r2, [r3, #48]	; 0x30
 802aa4e:	4a3b      	ldr	r2, [pc, #236]	; (802ab3c <HAL_UART_MspInit+0x1c4>)
 802aa50:	687b      	ldr	r3, [r7, #4]
 802aa52:	6393      	str	r3, [r2, #56]	; 0x38

    /* USART1_RX Init */
    hdma_usart1_rx.Instance = DMA2_Stream2;
 802aa54:	4b3b      	ldr	r3, [pc, #236]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa56:	4a3c      	ldr	r2, [pc, #240]	; (802ab48 <HAL_UART_MspInit+0x1d0>)
 802aa58:	601a      	str	r2, [r3, #0]
    hdma_usart1_rx.Init.Channel = DMA_CHANNEL_4;
 802aa5a:	4b3a      	ldr	r3, [pc, #232]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa5c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802aa60:	605a      	str	r2, [r3, #4]
    hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 802aa62:	4b38      	ldr	r3, [pc, #224]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa64:	2200      	movs	r2, #0
 802aa66:	609a      	str	r2, [r3, #8]
    hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 802aa68:	4b36      	ldr	r3, [pc, #216]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa6a:	2200      	movs	r2, #0
 802aa6c:	60da      	str	r2, [r3, #12]
    hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
 802aa6e:	4b35      	ldr	r3, [pc, #212]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa70:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802aa74:	611a      	str	r2, [r3, #16]
    hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 802aa76:	4b33      	ldr	r3, [pc, #204]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa78:	2200      	movs	r2, #0
 802aa7a:	615a      	str	r2, [r3, #20]
    hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 802aa7c:	4b31      	ldr	r3, [pc, #196]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa7e:	2200      	movs	r2, #0
 802aa80:	619a      	str	r2, [r3, #24]
    hdma_usart1_rx.Init.Mode = DMA_CIRCULAR; ///
 802aa82:	4b30      	ldr	r3, [pc, #192]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa84:	f44f 7280 	mov.w	r2, #256	; 0x100
 802aa88:	61da      	str	r2, [r3, #28]
    hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
 802aa8a:	4b2e      	ldr	r3, [pc, #184]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa8c:	2200      	movs	r2, #0
 802aa8e:	621a      	str	r2, [r3, #32]
    hdma_usart1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802aa90:	4b2c      	ldr	r3, [pc, #176]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa92:	2200      	movs	r2, #0
 802aa94:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
 802aa96:	482b      	ldr	r0, [pc, #172]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aa98:	f000 fc9c 	bl	802b3d4 <HAL_DMA_Init>
 802aa9c:	4603      	mov	r3, r0
 802aa9e:	2b00      	cmp	r3, #0
 802aaa0:	d001      	beq.n	802aaa6 <HAL_UART_MspInit+0x12e>
    {
      Error_Handler();
 802aaa2:	f7fe ff67 	bl	8029974 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmarx,hdma_usart1_rx);
 802aaa6:	687b      	ldr	r3, [r7, #4]
 802aaa8:	4a26      	ldr	r2, [pc, #152]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aaaa:	635a      	str	r2, [r3, #52]	; 0x34
 802aaac:	4a25      	ldr	r2, [pc, #148]	; (802ab44 <HAL_UART_MspInit+0x1cc>)
 802aaae:	687b      	ldr	r3, [r7, #4]
 802aab0:	6393      	str	r3, [r2, #56]	; 0x38

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 802aab2:	2200      	movs	r2, #0
 802aab4:	2100      	movs	r1, #0
 802aab6:	2025      	movs	r0, #37	; 0x25
 802aab8:	f000 fc55 	bl	802b366 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 802aabc:	2025      	movs	r0, #37	; 0x25
 802aabe:	f000 fc6e 	bl	802b39e <HAL_NVIC_EnableIRQ>
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  }

}
 802aac2:	e030      	b.n	802ab26 <HAL_UART_MspInit+0x1ae>
  else if(huart->Instance==USART2)
 802aac4:	687b      	ldr	r3, [r7, #4]
 802aac6:	681b      	ldr	r3, [r3, #0]
 802aac8:	4a20      	ldr	r2, [pc, #128]	; (802ab4c <HAL_UART_MspInit+0x1d4>)
 802aaca:	4293      	cmp	r3, r2
 802aacc:	d12b      	bne.n	802ab26 <HAL_UART_MspInit+0x1ae>
    __HAL_RCC_USART2_CLK_ENABLE();
 802aace:	2300      	movs	r3, #0
 802aad0:	613b      	str	r3, [r7, #16]
 802aad2:	4b18      	ldr	r3, [pc, #96]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802aad4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802aad6:	4a17      	ldr	r2, [pc, #92]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802aad8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802aadc:	6413      	str	r3, [r2, #64]	; 0x40
 802aade:	4b15      	ldr	r3, [pc, #84]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802aae0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802aae2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802aae6:	613b      	str	r3, [r7, #16]
 802aae8:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 802aaea:	2300      	movs	r3, #0
 802aaec:	60fb      	str	r3, [r7, #12]
 802aaee:	4b11      	ldr	r3, [pc, #68]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802aaf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802aaf2:	4a10      	ldr	r2, [pc, #64]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802aaf4:	f043 0301 	orr.w	r3, r3, #1
 802aaf8:	6313      	str	r3, [r2, #48]	; 0x30
 802aafa:	4b0e      	ldr	r3, [pc, #56]	; (802ab34 <HAL_UART_MspInit+0x1bc>)
 802aafc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802aafe:	f003 0301 	and.w	r3, r3, #1
 802ab02:	60fb      	str	r3, [r7, #12]
 802ab04:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
 802ab06:	230c      	movs	r3, #12
 802ab08:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802ab0a:	2302      	movs	r3, #2
 802ab0c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802ab0e:	2300      	movs	r3, #0
 802ab10:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 802ab12:	2300      	movs	r3, #0
 802ab14:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 802ab16:	2307      	movs	r3, #7
 802ab18:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802ab1a:	f107 031c 	add.w	r3, r7, #28
 802ab1e:	4619      	mov	r1, r3
 802ab20:	4805      	ldr	r0, [pc, #20]	; (802ab38 <HAL_UART_MspInit+0x1c0>)
 802ab22:	f000 ffe7 	bl	802baf4 <HAL_GPIO_Init>
}
 802ab26:	bf00      	nop
 802ab28:	3730      	adds	r7, #48	; 0x30
 802ab2a:	46bd      	mov	sp, r7
 802ab2c:	bd80      	pop	{r7, pc}
 802ab2e:	bf00      	nop
 802ab30:	40011000 	.word	0x40011000
 802ab34:	40023800 	.word	0x40023800
 802ab38:	40020000 	.word	0x40020000
 802ab3c:	200015a0 	.word	0x200015a0
 802ab40:	400264b8 	.word	0x400264b8
 802ab44:	20001600 	.word	0x20001600
 802ab48:	40026440 	.word	0x40026440
 802ab4c:	40004400 	.word	0x40004400

0802ab50 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 802ab50:	b580      	push	{r7, lr}
 802ab52:	b08a      	sub	sp, #40	; 0x28
 802ab54:	af00      	add	r7, sp, #0
 802ab56:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 802ab58:	f107 0314 	add.w	r3, r7, #20
 802ab5c:	2200      	movs	r2, #0
 802ab5e:	601a      	str	r2, [r3, #0]
 802ab60:	605a      	str	r2, [r3, #4]
 802ab62:	609a      	str	r2, [r3, #8]
 802ab64:	60da      	str	r2, [r3, #12]
 802ab66:	611a      	str	r2, [r3, #16]
  if(hspi->Instance==SPI1)
 802ab68:	687b      	ldr	r3, [r7, #4]
 802ab6a:	681b      	ldr	r3, [r3, #0]
 802ab6c:	4a4a      	ldr	r2, [pc, #296]	; (802ac98 <HAL_SPI_MspInit+0x148>)
 802ab6e:	4293      	cmp	r3, r2
 802ab70:	f040 808e 	bne.w	802ac90 <HAL_SPI_MspInit+0x140>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 802ab74:	2300      	movs	r3, #0
 802ab76:	613b      	str	r3, [r7, #16]
 802ab78:	4b48      	ldr	r3, [pc, #288]	; (802ac9c <HAL_SPI_MspInit+0x14c>)
 802ab7a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802ab7c:	4a47      	ldr	r2, [pc, #284]	; (802ac9c <HAL_SPI_MspInit+0x14c>)
 802ab7e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 802ab82:	6453      	str	r3, [r2, #68]	; 0x44
 802ab84:	4b45      	ldr	r3, [pc, #276]	; (802ac9c <HAL_SPI_MspInit+0x14c>)
 802ab86:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802ab88:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 802ab8c:	613b      	str	r3, [r7, #16]
 802ab8e:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 802ab90:	2300      	movs	r3, #0
 802ab92:	60fb      	str	r3, [r7, #12]
 802ab94:	4b41      	ldr	r3, [pc, #260]	; (802ac9c <HAL_SPI_MspInit+0x14c>)
 802ab96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802ab98:	4a40      	ldr	r2, [pc, #256]	; (802ac9c <HAL_SPI_MspInit+0x14c>)
 802ab9a:	f043 0301 	orr.w	r3, r3, #1
 802ab9e:	6313      	str	r3, [r2, #48]	; 0x30
 802aba0:	4b3e      	ldr	r3, [pc, #248]	; (802ac9c <HAL_SPI_MspInit+0x14c>)
 802aba2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802aba4:	f003 0301 	and.w	r3, r3, #1
 802aba8:	60fb      	str	r3, [r7, #12]
 802abaa:	68fb      	ldr	r3, [r7, #12]
    PA4     ------> SPI1_NSS
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 802abac:	23f0      	movs	r3, #240	; 0xf0
 802abae:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 802abb0:	2302      	movs	r3, #2
 802abb2:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 802abb4:	2300      	movs	r3, #0
 802abb6:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802abb8:	2303      	movs	r3, #3
 802abba:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 802abbc:	2305      	movs	r3, #5
 802abbe:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802abc0:	f107 0314 	add.w	r3, r7, #20
 802abc4:	4619      	mov	r1, r3
 802abc6:	4836      	ldr	r0, [pc, #216]	; (802aca0 <HAL_SPI_MspInit+0x150>)
 802abc8:	f000 ff94 	bl	802baf4 <HAL_GPIO_Init>

    /* SPI1 DMA Init */
    /* SPI1_RX Init */
    hdma_spi1_rx.Instance = DMA2_Stream0;
 802abcc:	4b35      	ldr	r3, [pc, #212]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abce:	4a36      	ldr	r2, [pc, #216]	; (802aca8 <HAL_SPI_MspInit+0x158>)
 802abd0:	601a      	str	r2, [r3, #0]
    hdma_spi1_rx.Init.Channel = DMA_CHANNEL_3;
 802abd2:	4b34      	ldr	r3, [pc, #208]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abd4:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
 802abd8:	605a      	str	r2, [r3, #4]
    hdma_spi1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 802abda:	4b32      	ldr	r3, [pc, #200]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abdc:	2200      	movs	r2, #0
 802abde:	609a      	str	r2, [r3, #8]
    hdma_spi1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 802abe0:	4b30      	ldr	r3, [pc, #192]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abe2:	2200      	movs	r2, #0
 802abe4:	60da      	str	r2, [r3, #12]
    hdma_spi1_rx.Init.MemInc = DMA_MINC_ENABLE;
 802abe6:	4b2f      	ldr	r3, [pc, #188]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abe8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802abec:	611a      	str	r2, [r3, #16]
    hdma_spi1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 802abee:	4b2d      	ldr	r3, [pc, #180]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abf0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802abf4:	615a      	str	r2, [r3, #20]
    hdma_spi1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 802abf6:	4b2b      	ldr	r3, [pc, #172]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802abf8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 802abfc:	619a      	str	r2, [r3, #24]
    hdma_spi1_rx.Init.Mode = DMA_NORMAL;
 802abfe:	4b29      	ldr	r3, [pc, #164]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802ac00:	2200      	movs	r2, #0
 802ac02:	61da      	str	r2, [r3, #28]
    hdma_spi1_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 802ac04:	4b27      	ldr	r3, [pc, #156]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802ac06:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802ac0a:	621a      	str	r2, [r3, #32]
    hdma_spi1_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802ac0c:	4b25      	ldr	r3, [pc, #148]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802ac0e:	2200      	movs	r2, #0
 802ac10:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi1_rx) != HAL_OK)
 802ac12:	4824      	ldr	r0, [pc, #144]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802ac14:	f000 fbde 	bl	802b3d4 <HAL_DMA_Init>
 802ac18:	4603      	mov	r3, r0
 802ac1a:	2b00      	cmp	r3, #0
 802ac1c:	d001      	beq.n	802ac22 <HAL_SPI_MspInit+0xd2>
    {
      Error_Handler();
 802ac1e:	f7fe fea9 	bl	8029974 <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi1_rx);
 802ac22:	687b      	ldr	r3, [r7, #4]
 802ac24:	4a1f      	ldr	r2, [pc, #124]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802ac26:	64da      	str	r2, [r3, #76]	; 0x4c
 802ac28:	4a1e      	ldr	r2, [pc, #120]	; (802aca4 <HAL_SPI_MspInit+0x154>)
 802ac2a:	687b      	ldr	r3, [r7, #4]
 802ac2c:	6393      	str	r3, [r2, #56]	; 0x38

    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA2_Stream3;
 802ac2e:	4b1f      	ldr	r3, [pc, #124]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac30:	4a1f      	ldr	r2, [pc, #124]	; (802acb0 <HAL_SPI_MspInit+0x160>)
 802ac32:	601a      	str	r2, [r3, #0]
    hdma_spi1_tx.Init.Channel = DMA_CHANNEL_3;
 802ac34:	4b1d      	ldr	r3, [pc, #116]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac36:	f04f 62c0 	mov.w	r2, #100663296	; 0x6000000
 802ac3a:	605a      	str	r2, [r3, #4]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 802ac3c:	4b1b      	ldr	r3, [pc, #108]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac3e:	2240      	movs	r2, #64	; 0x40
 802ac40:	609a      	str	r2, [r3, #8]
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 802ac42:	4b1a      	ldr	r3, [pc, #104]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac44:	2200      	movs	r2, #0
 802ac46:	60da      	str	r2, [r3, #12]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 802ac48:	4b18      	ldr	r3, [pc, #96]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac4a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 802ac4e:	611a      	str	r2, [r3, #16]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 802ac50:	4b16      	ldr	r3, [pc, #88]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac52:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802ac56:	615a      	str	r2, [r3, #20]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 802ac58:	4b14      	ldr	r3, [pc, #80]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac5a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 802ac5e:	619a      	str	r2, [r3, #24]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 802ac60:	4b12      	ldr	r3, [pc, #72]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac62:	2200      	movs	r2, #0
 802ac64:	61da      	str	r2, [r3, #28]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_MEDIUM;
 802ac66:	4b11      	ldr	r3, [pc, #68]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac68:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 802ac6c:	621a      	str	r2, [r3, #32]
    hdma_spi1_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 802ac6e:	4b0f      	ldr	r3, [pc, #60]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac70:	2200      	movs	r2, #0
 802ac72:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 802ac74:	480d      	ldr	r0, [pc, #52]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac76:	f000 fbad 	bl	802b3d4 <HAL_DMA_Init>
 802ac7a:	4603      	mov	r3, r0
 802ac7c:	2b00      	cmp	r3, #0
 802ac7e:	d001      	beq.n	802ac84 <HAL_SPI_MspInit+0x134>
    {
      Error_Handler();
 802ac80:	f7fe fe78 	bl	8029974 <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 802ac84:	687b      	ldr	r3, [r7, #4]
 802ac86:	4a09      	ldr	r2, [pc, #36]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac88:	649a      	str	r2, [r3, #72]	; 0x48
 802ac8a:	4a08      	ldr	r2, [pc, #32]	; (802acac <HAL_SPI_MspInit+0x15c>)
 802ac8c:	687b      	ldr	r3, [r7, #4]
 802ac8e:	6393      	str	r3, [r2, #56]	; 0x38

  }

}
 802ac90:	bf00      	nop
 802ac92:	3728      	adds	r7, #40	; 0x28
 802ac94:	46bd      	mov	sp, r7
 802ac96:	bd80      	pop	{r7, pc}
 802ac98:	40013000 	.word	0x40013000
 802ac9c:	40023800 	.word	0x40023800
 802aca0:	40020000 	.word	0x40020000
 802aca4:	20001738 	.word	0x20001738
 802aca8:	40026410 	.word	0x40026410
 802acac:	20001798 	.word	0x20001798
 802acb0:	40026458 	.word	0x40026458

0802acb4 <NMI_Handler>:
extern DMA_HandleTypeDef hdma_spi1_rx;
extern DMA_HandleTypeDef hdma_spi1_tx;
extern UART_HandleTypeDef huart1;

void NMI_Handler(void)
{
 802acb4:	b480      	push	{r7}
 802acb6:	af00      	add	r7, sp, #0
	__NOP();
 802acb8:	bf00      	nop
}
 802acba:	bf00      	nop
 802acbc:	46bd      	mov	sp, r7
 802acbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 802acc2:	4770      	bx	lr

0802acc4 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 802acc4:	b480      	push	{r7}
 802acc6:	af00      	add	r7, sp, #0
  while (1)
 802acc8:	e7fe      	b.n	802acc8 <HardFault_Handler+0x4>

0802acca <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 802acca:	b480      	push	{r7}
 802accc:	af00      	add	r7, sp, #0
  while (1)
 802acce:	e7fe      	b.n	802acce <MemManage_Handler+0x4>

0802acd0 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 802acd0:	b480      	push	{r7}
 802acd2:	af00      	add	r7, sp, #0
  while (1)
 802acd4:	e7fe      	b.n	802acd4 <BusFault_Handler+0x4>

0802acd6 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 802acd6:	b480      	push	{r7}
 802acd8:	af00      	add	r7, sp, #0
  while (1)
 802acda:	e7fe      	b.n	802acda <UsageFault_Handler+0x4>

0802acdc <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 802acdc:	b480      	push	{r7}
 802acde:	af00      	add	r7, sp, #0
}
 802ace0:	bf00      	nop
 802ace2:	46bd      	mov	sp, r7
 802ace4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ace8:	4770      	bx	lr

0802acea <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 802acea:	b480      	push	{r7}
 802acec:	af00      	add	r7, sp, #0
}
 802acee:	bf00      	nop
 802acf0:	46bd      	mov	sp, r7
 802acf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802acf6:	4770      	bx	lr

0802acf8 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 802acf8:	b480      	push	{r7}
 802acfa:	af00      	add	r7, sp, #0
}
 802acfc:	bf00      	nop
 802acfe:	46bd      	mov	sp, r7
 802ad00:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ad04:	4770      	bx	lr

0802ad06 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 802ad06:	b580      	push	{r7, lr}
 802ad08:	af00      	add	r7, sp, #0
  HAL_IncTick();
 802ad0a:	f000 fa0f 	bl	802b12c <HAL_IncTick>
}
 802ad0e:	bf00      	nop
 802ad10:	bd80      	pop	{r7, pc}
	...

0802ad14 <USART1_IRQHandler>:


void USART1_IRQHandler(void)
{
 802ad14:	b580      	push	{r7, lr}
 802ad16:	af00      	add	r7, sp, #0
  HAL_UART_IRQHandler(&huart1);
 802ad18:	4802      	ldr	r0, [pc, #8]	; (802ad24 <USART1_IRQHandler+0x10>)
 802ad1a:	f003 fa87 	bl	802e22c <HAL_UART_IRQHandler>
}
 802ad1e:	bf00      	nop
 802ad20:	bd80      	pop	{r7, pc}
 802ad22:	bf00      	nop
 802ad24:	20001660 	.word	0x20001660

0802ad28 <DMA2_Stream2_IRQHandler>:

/**
  * @brief This function handles DMA2 stream2 global interrupt.
  */
void DMA2_Stream2_IRQHandler(void)
{
 802ad28:	b580      	push	{r7, lr}
 802ad2a:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_usart1_rx);
 802ad2c:	4802      	ldr	r0, [pc, #8]	; (802ad38 <DMA2_Stream2_IRQHandler+0x10>)
 802ad2e:	f000 fc79 	bl	802b624 <HAL_DMA_IRQHandler>
}
 802ad32:	bf00      	nop
 802ad34:	bd80      	pop	{r7, pc}
 802ad36:	bf00      	nop
 802ad38:	20001600 	.word	0x20001600

0802ad3c <DMA2_Stream7_IRQHandler>:

/**
  * @brief This function handles DMA2 stream7 global interrupt.
  */
void DMA2_Stream7_IRQHandler(void)
{
 802ad3c:	b580      	push	{r7, lr}
 802ad3e:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_usart1_tx);
 802ad40:	4802      	ldr	r0, [pc, #8]	; (802ad4c <DMA2_Stream7_IRQHandler+0x10>)
 802ad42:	f000 fc6f 	bl	802b624 <HAL_DMA_IRQHandler>
}
 802ad46:	bf00      	nop
 802ad48:	bd80      	pop	{r7, pc}
 802ad4a:	bf00      	nop
 802ad4c:	200015a0 	.word	0x200015a0

0802ad50 <DMA2_Stream0_IRQHandler>:


void DMA2_Stream0_IRQHandler(void)
{
 802ad50:	b580      	push	{r7, lr}
 802ad52:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_spi1_rx);
 802ad54:	4802      	ldr	r0, [pc, #8]	; (802ad60 <DMA2_Stream0_IRQHandler+0x10>)
 802ad56:	f000 fc65 	bl	802b624 <HAL_DMA_IRQHandler>
}
 802ad5a:	bf00      	nop
 802ad5c:	bd80      	pop	{r7, pc}
 802ad5e:	bf00      	nop
 802ad60:	20001738 	.word	0x20001738

0802ad64 <DMA2_Stream3_IRQHandler>:

/**
  * @brief This function handles DMA2 stream3 global interrupt.
  */
void DMA2_Stream3_IRQHandler(void)
{
 802ad64:	b580      	push	{r7, lr}
 802ad66:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 802ad68:	4802      	ldr	r0, [pc, #8]	; (802ad74 <DMA2_Stream3_IRQHandler+0x10>)
 802ad6a:	f000 fc5b 	bl	802b624 <HAL_DMA_IRQHandler>
}
 802ad6e:	bf00      	nop
 802ad70:	bd80      	pop	{r7, pc}
 802ad72:	bf00      	nop
 802ad74:	20001798 	.word	0x20001798

0802ad78 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 802ad78:	b480      	push	{r7}
 802ad7a:	af00      	add	r7, sp, #0
	return 1;
 802ad7c:	2301      	movs	r3, #1
}
 802ad7e:	4618      	mov	r0, r3
 802ad80:	46bd      	mov	sp, r7
 802ad82:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ad86:	4770      	bx	lr

0802ad88 <_kill>:

int _kill(int pid, int sig)
{
 802ad88:	b580      	push	{r7, lr}
 802ad8a:	b082      	sub	sp, #8
 802ad8c:	af00      	add	r7, sp, #0
 802ad8e:	6078      	str	r0, [r7, #4]
 802ad90:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
 802ad92:	f004 f8a5 	bl	802eee0 <__errno>
 802ad96:	4602      	mov	r2, r0
 802ad98:	2316      	movs	r3, #22
 802ad9a:	6013      	str	r3, [r2, #0]
	return -1;
 802ad9c:	f04f 33ff 	mov.w	r3, #4294967295
}
 802ada0:	4618      	mov	r0, r3
 802ada2:	3708      	adds	r7, #8
 802ada4:	46bd      	mov	sp, r7
 802ada6:	bd80      	pop	{r7, pc}

0802ada8 <_exit>:

void _exit (int status)
{
 802ada8:	b580      	push	{r7, lr}
 802adaa:	b082      	sub	sp, #8
 802adac:	af00      	add	r7, sp, #0
 802adae:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
 802adb0:	f04f 31ff 	mov.w	r1, #4294967295
 802adb4:	6878      	ldr	r0, [r7, #4]
 802adb6:	f7ff ffe7 	bl	802ad88 <_kill>
	while (1) {}		/* Make sure we hang here */
 802adba:	e7fe      	b.n	802adba <_exit+0x12>

0802adbc <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 802adbc:	b580      	push	{r7, lr}
 802adbe:	b086      	sub	sp, #24
 802adc0:	af00      	add	r7, sp, #0
 802adc2:	60f8      	str	r0, [r7, #12]
 802adc4:	60b9      	str	r1, [r7, #8]
 802adc6:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802adc8:	2300      	movs	r3, #0
 802adca:	617b      	str	r3, [r7, #20]
 802adcc:	e00a      	b.n	802ade4 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 802adce:	f3af 8000 	nop.w
 802add2:	4601      	mov	r1, r0
 802add4:	68bb      	ldr	r3, [r7, #8]
 802add6:	1c5a      	adds	r2, r3, #1
 802add8:	60ba      	str	r2, [r7, #8]
 802adda:	b2ca      	uxtb	r2, r1
 802addc:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802adde:	697b      	ldr	r3, [r7, #20]
 802ade0:	3301      	adds	r3, #1
 802ade2:	617b      	str	r3, [r7, #20]
 802ade4:	697a      	ldr	r2, [r7, #20]
 802ade6:	687b      	ldr	r3, [r7, #4]
 802ade8:	429a      	cmp	r2, r3
 802adea:	dbf0      	blt.n	802adce <_read+0x12>
	}

return len;
 802adec:	687b      	ldr	r3, [r7, #4]
}
 802adee:	4618      	mov	r0, r3
 802adf0:	3718      	adds	r7, #24
 802adf2:	46bd      	mov	sp, r7
 802adf4:	bd80      	pop	{r7, pc}

0802adf6 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 802adf6:	b580      	push	{r7, lr}
 802adf8:	b086      	sub	sp, #24
 802adfa:	af00      	add	r7, sp, #0
 802adfc:	60f8      	str	r0, [r7, #12]
 802adfe:	60b9      	str	r1, [r7, #8]
 802ae00:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802ae02:	2300      	movs	r3, #0
 802ae04:	617b      	str	r3, [r7, #20]
 802ae06:	e009      	b.n	802ae1c <_write+0x26>
	{
		__io_putchar(*ptr++);
 802ae08:	68bb      	ldr	r3, [r7, #8]
 802ae0a:	1c5a      	adds	r2, r3, #1
 802ae0c:	60ba      	str	r2, [r7, #8]
 802ae0e:	781b      	ldrb	r3, [r3, #0]
 802ae10:	4618      	mov	r0, r3
 802ae12:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 802ae16:	697b      	ldr	r3, [r7, #20]
 802ae18:	3301      	adds	r3, #1
 802ae1a:	617b      	str	r3, [r7, #20]
 802ae1c:	697a      	ldr	r2, [r7, #20]
 802ae1e:	687b      	ldr	r3, [r7, #4]
 802ae20:	429a      	cmp	r2, r3
 802ae22:	dbf1      	blt.n	802ae08 <_write+0x12>
	}
	return len;
 802ae24:	687b      	ldr	r3, [r7, #4]
}
 802ae26:	4618      	mov	r0, r3
 802ae28:	3718      	adds	r7, #24
 802ae2a:	46bd      	mov	sp, r7
 802ae2c:	bd80      	pop	{r7, pc}

0802ae2e <_close>:

int _close(int file)
{
 802ae2e:	b480      	push	{r7}
 802ae30:	b083      	sub	sp, #12
 802ae32:	af00      	add	r7, sp, #0
 802ae34:	6078      	str	r0, [r7, #4]
	return -1;
 802ae36:	f04f 33ff 	mov.w	r3, #4294967295
}
 802ae3a:	4618      	mov	r0, r3
 802ae3c:	370c      	adds	r7, #12
 802ae3e:	46bd      	mov	sp, r7
 802ae40:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ae44:	4770      	bx	lr

0802ae46 <_fstat>:


int _fstat(int file, struct stat *st)
{
 802ae46:	b480      	push	{r7}
 802ae48:	b083      	sub	sp, #12
 802ae4a:	af00      	add	r7, sp, #0
 802ae4c:	6078      	str	r0, [r7, #4]
 802ae4e:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 802ae50:	683b      	ldr	r3, [r7, #0]
 802ae52:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 802ae56:	605a      	str	r2, [r3, #4]
	return 0;
 802ae58:	2300      	movs	r3, #0
}
 802ae5a:	4618      	mov	r0, r3
 802ae5c:	370c      	adds	r7, #12
 802ae5e:	46bd      	mov	sp, r7
 802ae60:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ae64:	4770      	bx	lr

0802ae66 <_isatty>:

int _isatty(int file)
{
 802ae66:	b480      	push	{r7}
 802ae68:	b083      	sub	sp, #12
 802ae6a:	af00      	add	r7, sp, #0
 802ae6c:	6078      	str	r0, [r7, #4]
	return 1;
 802ae6e:	2301      	movs	r3, #1
}
 802ae70:	4618      	mov	r0, r3
 802ae72:	370c      	adds	r7, #12
 802ae74:	46bd      	mov	sp, r7
 802ae76:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ae7a:	4770      	bx	lr

0802ae7c <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 802ae7c:	b480      	push	{r7}
 802ae7e:	b085      	sub	sp, #20
 802ae80:	af00      	add	r7, sp, #0
 802ae82:	60f8      	str	r0, [r7, #12]
 802ae84:	60b9      	str	r1, [r7, #8]
 802ae86:	607a      	str	r2, [r7, #4]
	return 0;
 802ae88:	2300      	movs	r3, #0
}
 802ae8a:	4618      	mov	r0, r3
 802ae8c:	3714      	adds	r7, #20
 802ae8e:	46bd      	mov	sp, r7
 802ae90:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ae94:	4770      	bx	lr
	...

0802ae98 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 802ae98:	b580      	push	{r7, lr}
 802ae9a:	b084      	sub	sp, #16
 802ae9c:	af00      	add	r7, sp, #0
 802ae9e:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 802aea0:	4b11      	ldr	r3, [pc, #68]	; (802aee8 <_sbrk+0x50>)
 802aea2:	681b      	ldr	r3, [r3, #0]
 802aea4:	2b00      	cmp	r3, #0
 802aea6:	d102      	bne.n	802aeae <_sbrk+0x16>
		heap_end = &end;
 802aea8:	4b0f      	ldr	r3, [pc, #60]	; (802aee8 <_sbrk+0x50>)
 802aeaa:	4a10      	ldr	r2, [pc, #64]	; (802aeec <_sbrk+0x54>)
 802aeac:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 802aeae:	4b0e      	ldr	r3, [pc, #56]	; (802aee8 <_sbrk+0x50>)
 802aeb0:	681b      	ldr	r3, [r3, #0]
 802aeb2:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
 802aeb4:	4b0c      	ldr	r3, [pc, #48]	; (802aee8 <_sbrk+0x50>)
 802aeb6:	681a      	ldr	r2, [r3, #0]
 802aeb8:	687b      	ldr	r3, [r7, #4]
 802aeba:	4413      	add	r3, r2
 802aebc:	466a      	mov	r2, sp
 802aebe:	4293      	cmp	r3, r2
 802aec0:	d907      	bls.n	802aed2 <_sbrk+0x3a>
	{
		errno = ENOMEM;
 802aec2:	f004 f80d 	bl	802eee0 <__errno>
 802aec6:	4602      	mov	r2, r0
 802aec8:	230c      	movs	r3, #12
 802aeca:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
 802aecc:	f04f 33ff 	mov.w	r3, #4294967295
 802aed0:	e006      	b.n	802aee0 <_sbrk+0x48>
	}

	heap_end += incr;
 802aed2:	4b05      	ldr	r3, [pc, #20]	; (802aee8 <_sbrk+0x50>)
 802aed4:	681a      	ldr	r2, [r3, #0]
 802aed6:	687b      	ldr	r3, [r7, #4]
 802aed8:	4413      	add	r3, r2
 802aeda:	4a03      	ldr	r2, [pc, #12]	; (802aee8 <_sbrk+0x50>)
 802aedc:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
 802aede:	68fb      	ldr	r3, [r7, #12]
}
 802aee0:	4618      	mov	r0, r3
 802aee2:	3710      	adds	r7, #16
 802aee4:	46bd      	mov	sp, r7
 802aee6:	bd80      	pop	{r7, pc}
 802aee8:	200014d8 	.word	0x200014d8
 802aeec:	20004310 	.word	0x20004310

0802aef0 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 802aef0:	b480      	push	{r7}
 802aef2:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 802aef4:	4b08      	ldr	r3, [pc, #32]	; (802af18 <SystemInit+0x28>)
 802aef6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 802aefa:	4a07      	ldr	r2, [pc, #28]	; (802af18 <SystemInit+0x28>)
 802aefc:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 802af00:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 802af04:	4b04      	ldr	r3, [pc, #16]	; (802af18 <SystemInit+0x28>)
 802af06:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 802af0a:	609a      	str	r2, [r3, #8]
#endif
}
 802af0c:	bf00      	nop
 802af0e:	46bd      	mov	sp, r7
 802af10:	f85d 7b04 	ldr.w	r7, [sp], #4
 802af14:	4770      	bx	lr
 802af16:	bf00      	nop
 802af18:	e000ed00 	.word	0xe000ed00

0802af1c <MX_USART1_UART_Init>:
 *PA10    ------> USART1_RX
 *UART1 is connected to the Hirose Connector in PCB
*/

void MX_USART1_UART_Init(void)
{
 802af1c:	b580      	push	{r7, lr}
 802af1e:	af00      	add	r7, sp, #0
  huart1.Instance = USART1;
 802af20:	4b11      	ldr	r3, [pc, #68]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af22:	4a12      	ldr	r2, [pc, #72]	; (802af6c <MX_USART1_UART_Init+0x50>)
 802af24:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 802af26:	4b10      	ldr	r3, [pc, #64]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af28:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 802af2c:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 802af2e:	4b0e      	ldr	r3, [pc, #56]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af30:	2200      	movs	r2, #0
 802af32:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 802af34:	4b0c      	ldr	r3, [pc, #48]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af36:	2200      	movs	r2, #0
 802af38:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 802af3a:	4b0b      	ldr	r3, [pc, #44]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af3c:	2200      	movs	r2, #0
 802af3e:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 802af40:	4b09      	ldr	r3, [pc, #36]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af42:	220c      	movs	r2, #12
 802af44:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802af46:	4b08      	ldr	r3, [pc, #32]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af48:	2200      	movs	r2, #0
 802af4a:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 802af4c:	4b06      	ldr	r3, [pc, #24]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af4e:	2200      	movs	r2, #0
 802af50:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 802af52:	4805      	ldr	r0, [pc, #20]	; (802af68 <MX_USART1_UART_Init+0x4c>)
 802af54:	f002 fffa 	bl	802df4c <HAL_UART_Init>
 802af58:	4603      	mov	r3, r0
 802af5a:	2b00      	cmp	r3, #0
 802af5c:	d001      	beq.n	802af62 <MX_USART1_UART_Init+0x46>
  {
    Error_Handler();
 802af5e:	f7fe fd09 	bl	8029974 <Error_Handler>
  }
}
 802af62:	bf00      	nop
 802af64:	bd80      	pop	{r7, pc}
 802af66:	bf00      	nop
 802af68:	20001660 	.word	0x20001660
 802af6c:	40011000 	.word	0x40011000

0802af70 <MX_USART2_UART_Init>:
 *PA2     ------> USART2_TX
 *PA3     ------> USART2_RX
 *UART2 is connected to USB in STM32
*/
void MX_USART2_UART_Init(void)
{
 802af70:	b580      	push	{r7, lr}
 802af72:	af00      	add	r7, sp, #0
  huart2.Instance = USART2;
 802af74:	4b11      	ldr	r3, [pc, #68]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af76:	4a12      	ldr	r2, [pc, #72]	; (802afc0 <MX_USART2_UART_Init+0x50>)
 802af78:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 115200;
 802af7a:	4b10      	ldr	r3, [pc, #64]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af7c:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 802af80:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 802af82:	4b0e      	ldr	r3, [pc, #56]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af84:	2200      	movs	r2, #0
 802af86:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 802af88:	4b0c      	ldr	r3, [pc, #48]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af8a:	2200      	movs	r2, #0
 802af8c:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 802af8e:	4b0b      	ldr	r3, [pc, #44]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af90:	2200      	movs	r2, #0
 802af92:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 802af94:	4b09      	ldr	r3, [pc, #36]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af96:	220c      	movs	r2, #12
 802af98:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 802af9a:	4b08      	ldr	r3, [pc, #32]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802af9c:	2200      	movs	r2, #0
 802af9e:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 802afa0:	4b06      	ldr	r3, [pc, #24]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802afa2:	2200      	movs	r2, #0
 802afa4:	61da      	str	r2, [r3, #28]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 802afa6:	4805      	ldr	r0, [pc, #20]	; (802afbc <MX_USART2_UART_Init+0x4c>)
 802afa8:	f002 ffd0 	bl	802df4c <HAL_UART_Init>
 802afac:	4603      	mov	r3, r0
 802afae:	2b00      	cmp	r3, #0
 802afb0:	d001      	beq.n	802afb6 <MX_USART2_UART_Init+0x46>
  {
    Error_Handler();
 802afb2:	f7fe fcdf 	bl	8029974 <Error_Handler>
  }
}
 802afb6:	bf00      	nop
 802afb8:	bd80      	pop	{r7, pc}
 802afba:	bf00      	nop
 802afbc:	200016f8 	.word	0x200016f8
 802afc0:	40004400 	.word	0x40004400

0802afc4 <MX_DMA_Init>:

/*
 * Enable DMA controller clock
 */
void MX_DMA_Init(void)
{
 802afc4:	b580      	push	{r7, lr}
 802afc6:	b082      	sub	sp, #8
 802afc8:	af00      	add	r7, sp, #0

  // DMA controller clock enable
  __HAL_RCC_DMA2_CLK_ENABLE();
 802afca:	2300      	movs	r3, #0
 802afcc:	607b      	str	r3, [r7, #4]
 802afce:	4b18      	ldr	r3, [pc, #96]	; (802b030 <MX_DMA_Init+0x6c>)
 802afd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802afd2:	4a17      	ldr	r2, [pc, #92]	; (802b030 <MX_DMA_Init+0x6c>)
 802afd4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 802afd8:	6313      	str	r3, [r2, #48]	; 0x30
 802afda:	4b15      	ldr	r3, [pc, #84]	; (802b030 <MX_DMA_Init+0x6c>)
 802afdc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802afde:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802afe2:	607b      	str	r3, [r7, #4]
 802afe4:	687b      	ldr	r3, [r7, #4]
  /* UART DMA
     DMA interrupt init
     DMA2_Stream2_IRQn interrupt configuration
     DMA2_Stream7_IRQn interrupt configuration
   */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
 802afe6:	2200      	movs	r2, #0
 802afe8:	2100      	movs	r1, #0
 802afea:	203a      	movs	r0, #58	; 0x3a
 802afec:	f000 f9bb 	bl	802b366 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
 802aff0:	203a      	movs	r0, #58	; 0x3a
 802aff2:	f000 f9d4 	bl	802b39e <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0);
 802aff6:	2200      	movs	r2, #0
 802aff8:	2100      	movs	r1, #0
 802affa:	2046      	movs	r0, #70	; 0x46
 802affc:	f000 f9b3 	bl	802b366 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);
 802b000:	2046      	movs	r0, #70	; 0x46
 802b002:	f000 f9cc 	bl	802b39e <HAL_NVIC_EnableIRQ>
  /*SPI DMA
    DMA interrupt init
    DMA2_Stream0_IRQn interrupt configuration
    DMA2_Stream3_IRQn interrupt configuration
   */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
 802b006:	2200      	movs	r2, #0
 802b008:	2100      	movs	r1, #0
 802b00a:	2038      	movs	r0, #56	; 0x38
 802b00c:	f000 f9ab 	bl	802b366 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 802b010:	2038      	movs	r0, #56	; 0x38
 802b012:	f000 f9c4 	bl	802b39e <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
 802b016:	2200      	movs	r2, #0
 802b018:	2100      	movs	r1, #0
 802b01a:	203b      	movs	r0, #59	; 0x3b
 802b01c:	f000 f9a3 	bl	802b366 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 802b020:	203b      	movs	r0, #59	; 0x3b
 802b022:	f000 f9bc 	bl	802b39e <HAL_NVIC_EnableIRQ>

}
 802b026:	bf00      	nop
 802b028:	3708      	adds	r7, #8
 802b02a:	46bd      	mov	sp, r7
 802b02c:	bd80      	pop	{r7, pc}
 802b02e:	bf00      	nop
 802b030:	40023800 	.word	0x40023800

0802b034 <Reset_Handler>:
*/

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:    ldr   sp, =_estack    		 /* set stack pointer */
 802b034:	f8df d034 	ldr.w	sp, [pc, #52]	; 802b06c <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 802b038:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 802b03a:	e003      	b.n	802b044 <LoopCopyDataInit>

0802b03c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 802b03c:	4b0c      	ldr	r3, [pc, #48]	; (802b070 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 802b03e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 802b040:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 802b042:	3104      	adds	r1, #4

0802b044 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 802b044:	480b      	ldr	r0, [pc, #44]	; (802b074 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 802b046:	4b0c      	ldr	r3, [pc, #48]	; (802b078 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 802b048:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 802b04a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 802b04c:	d3f6      	bcc.n	802b03c <CopyDataInit>
  ldr  r2, =_sbss
 802b04e:	4a0b      	ldr	r2, [pc, #44]	; (802b07c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 802b050:	e002      	b.n	802b058 <LoopFillZerobss>

0802b052 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 802b052:	2300      	movs	r3, #0
  str  r3, [r2], #4
 802b054:	f842 3b04 	str.w	r3, [r2], #4

0802b058 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 802b058:	4b09      	ldr	r3, [pc, #36]	; (802b080 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 802b05a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 802b05c:	d3f9      	bcc.n	802b052 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 802b05e:	f7ff ff47 	bl	802aef0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 802b062:	f004 f93d 	bl	802f2e0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 802b066:	f7fe fb87 	bl	8029778 <main>
  bx  lr    
 802b06a:	4770      	bx	lr
Reset_Handler:    ldr   sp, =_estack    		 /* set stack pointer */
 802b06c:	20018000 	.word	0x20018000
  ldr  r3, =_sidata
 802b070:	0803089c 	.word	0x0803089c
  ldr  r0, =_sdata
 802b074:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 802b078:	2000010c 	.word	0x2000010c
  ldr  r2, =_sbss
 802b07c:	2000010c 	.word	0x2000010c
  ldr  r3, = _ebss
 802b080:	2000430c 	.word	0x2000430c

0802b084 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 802b084:	e7fe      	b.n	802b084 <ADC_IRQHandler>
	...

0802b088 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802b088:	b580      	push	{r7, lr}
 802b08a:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 802b08c:	4b0e      	ldr	r3, [pc, #56]	; (802b0c8 <HAL_Init+0x40>)
 802b08e:	681b      	ldr	r3, [r3, #0]
 802b090:	4a0d      	ldr	r2, [pc, #52]	; (802b0c8 <HAL_Init+0x40>)
 802b092:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 802b096:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 802b098:	4b0b      	ldr	r3, [pc, #44]	; (802b0c8 <HAL_Init+0x40>)
 802b09a:	681b      	ldr	r3, [r3, #0]
 802b09c:	4a0a      	ldr	r2, [pc, #40]	; (802b0c8 <HAL_Init+0x40>)
 802b09e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 802b0a2:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 802b0a4:	4b08      	ldr	r3, [pc, #32]	; (802b0c8 <HAL_Init+0x40>)
 802b0a6:	681b      	ldr	r3, [r3, #0]
 802b0a8:	4a07      	ldr	r2, [pc, #28]	; (802b0c8 <HAL_Init+0x40>)
 802b0aa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802b0ae:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 802b0b0:	2003      	movs	r0, #3
 802b0b2:	f000 f94d 	bl	802b350 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 802b0b6:	2000      	movs	r0, #0
 802b0b8:	f000 f808 	bl	802b0cc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 802b0bc:	f7ff fb9a 	bl	802a7f4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 802b0c0:	2300      	movs	r3, #0
}
 802b0c2:	4618      	mov	r0, r3
 802b0c4:	bd80      	pop	{r7, pc}
 802b0c6:	bf00      	nop
 802b0c8:	40023c00 	.word	0x40023c00

0802b0cc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 802b0cc:	b580      	push	{r7, lr}
 802b0ce:	b082      	sub	sp, #8
 802b0d0:	af00      	add	r7, sp, #0
 802b0d2:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 802b0d4:	4b12      	ldr	r3, [pc, #72]	; (802b120 <HAL_InitTick+0x54>)
 802b0d6:	681a      	ldr	r2, [r3, #0]
 802b0d8:	4b12      	ldr	r3, [pc, #72]	; (802b124 <HAL_InitTick+0x58>)
 802b0da:	781b      	ldrb	r3, [r3, #0]
 802b0dc:	4619      	mov	r1, r3
 802b0de:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 802b0e2:	fbb3 f3f1 	udiv	r3, r3, r1
 802b0e6:	fbb2 f3f3 	udiv	r3, r2, r3
 802b0ea:	4618      	mov	r0, r3
 802b0ec:	f000 f965 	bl	802b3ba <HAL_SYSTICK_Config>
 802b0f0:	4603      	mov	r3, r0
 802b0f2:	2b00      	cmp	r3, #0
 802b0f4:	d001      	beq.n	802b0fa <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 802b0f6:	2301      	movs	r3, #1
 802b0f8:	e00e      	b.n	802b118 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 802b0fa:	687b      	ldr	r3, [r7, #4]
 802b0fc:	2b0f      	cmp	r3, #15
 802b0fe:	d80a      	bhi.n	802b116 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 802b100:	2200      	movs	r2, #0
 802b102:	6879      	ldr	r1, [r7, #4]
 802b104:	f04f 30ff 	mov.w	r0, #4294967295
 802b108:	f000 f92d 	bl	802b366 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 802b10c:	4a06      	ldr	r2, [pc, #24]	; (802b128 <HAL_InitTick+0x5c>)
 802b10e:	687b      	ldr	r3, [r7, #4]
 802b110:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 802b112:	2300      	movs	r3, #0
 802b114:	e000      	b.n	802b118 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 802b116:	2301      	movs	r3, #1
}
 802b118:	4618      	mov	r0, r3
 802b11a:	3708      	adds	r7, #8
 802b11c:	46bd      	mov	sp, r7
 802b11e:	bd80      	pop	{r7, pc}
 802b120:	20000098 	.word	0x20000098
 802b124:	200000a0 	.word	0x200000a0
 802b128:	2000009c 	.word	0x2000009c

0802b12c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 802b12c:	b480      	push	{r7}
 802b12e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 802b130:	4b06      	ldr	r3, [pc, #24]	; (802b14c <HAL_IncTick+0x20>)
 802b132:	781b      	ldrb	r3, [r3, #0]
 802b134:	461a      	mov	r2, r3
 802b136:	4b06      	ldr	r3, [pc, #24]	; (802b150 <HAL_IncTick+0x24>)
 802b138:	681b      	ldr	r3, [r3, #0]
 802b13a:	4413      	add	r3, r2
 802b13c:	4a04      	ldr	r2, [pc, #16]	; (802b150 <HAL_IncTick+0x24>)
 802b13e:	6013      	str	r3, [r2, #0]
}
 802b140:	bf00      	nop
 802b142:	46bd      	mov	sp, r7
 802b144:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b148:	4770      	bx	lr
 802b14a:	bf00      	nop
 802b14c:	200000a0 	.word	0x200000a0
 802b150:	20004304 	.word	0x20004304

0802b154 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 802b154:	b480      	push	{r7}
 802b156:	af00      	add	r7, sp, #0
  return uwTick;
 802b158:	4b03      	ldr	r3, [pc, #12]	; (802b168 <HAL_GetTick+0x14>)
 802b15a:	681b      	ldr	r3, [r3, #0]
}
 802b15c:	4618      	mov	r0, r3
 802b15e:	46bd      	mov	sp, r7
 802b160:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b164:	4770      	bx	lr
 802b166:	bf00      	nop
 802b168:	20004304 	.word	0x20004304

0802b16c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 802b16c:	b580      	push	{r7, lr}
 802b16e:	b084      	sub	sp, #16
 802b170:	af00      	add	r7, sp, #0
 802b172:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 802b174:	f7ff ffee 	bl	802b154 <HAL_GetTick>
 802b178:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 802b17a:	687b      	ldr	r3, [r7, #4]
 802b17c:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 802b17e:	68fb      	ldr	r3, [r7, #12]
 802b180:	f1b3 3fff 	cmp.w	r3, #4294967295
 802b184:	d005      	beq.n	802b192 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 802b186:	4b09      	ldr	r3, [pc, #36]	; (802b1ac <HAL_Delay+0x40>)
 802b188:	781b      	ldrb	r3, [r3, #0]
 802b18a:	461a      	mov	r2, r3
 802b18c:	68fb      	ldr	r3, [r7, #12]
 802b18e:	4413      	add	r3, r2
 802b190:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 802b192:	bf00      	nop
 802b194:	f7ff ffde 	bl	802b154 <HAL_GetTick>
 802b198:	4602      	mov	r2, r0
 802b19a:	68bb      	ldr	r3, [r7, #8]
 802b19c:	1ad3      	subs	r3, r2, r3
 802b19e:	68fa      	ldr	r2, [r7, #12]
 802b1a0:	429a      	cmp	r2, r3
 802b1a2:	d8f7      	bhi.n	802b194 <HAL_Delay+0x28>
  {
  }
}
 802b1a4:	bf00      	nop
 802b1a6:	3710      	adds	r7, #16
 802b1a8:	46bd      	mov	sp, r7
 802b1aa:	bd80      	pop	{r7, pc}
 802b1ac:	200000a0 	.word	0x200000a0

0802b1b0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 802b1b0:	b480      	push	{r7}
 802b1b2:	b085      	sub	sp, #20
 802b1b4:	af00      	add	r7, sp, #0
 802b1b6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 802b1b8:	687b      	ldr	r3, [r7, #4]
 802b1ba:	f003 0307 	and.w	r3, r3, #7
 802b1be:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 802b1c0:	4b0c      	ldr	r3, [pc, #48]	; (802b1f4 <__NVIC_SetPriorityGrouping+0x44>)
 802b1c2:	68db      	ldr	r3, [r3, #12]
 802b1c4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 802b1c6:	68ba      	ldr	r2, [r7, #8]
 802b1c8:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 802b1cc:	4013      	ands	r3, r2
 802b1ce:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 802b1d0:	68fb      	ldr	r3, [r7, #12]
 802b1d2:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 802b1d4:	68bb      	ldr	r3, [r7, #8]
 802b1d6:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 802b1d8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 802b1dc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 802b1e0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 802b1e2:	4a04      	ldr	r2, [pc, #16]	; (802b1f4 <__NVIC_SetPriorityGrouping+0x44>)
 802b1e4:	68bb      	ldr	r3, [r7, #8]
 802b1e6:	60d3      	str	r3, [r2, #12]
}
 802b1e8:	bf00      	nop
 802b1ea:	3714      	adds	r7, #20
 802b1ec:	46bd      	mov	sp, r7
 802b1ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b1f2:	4770      	bx	lr
 802b1f4:	e000ed00 	.word	0xe000ed00

0802b1f8 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 802b1f8:	b480      	push	{r7}
 802b1fa:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802b1fc:	4b04      	ldr	r3, [pc, #16]	; (802b210 <__NVIC_GetPriorityGrouping+0x18>)
 802b1fe:	68db      	ldr	r3, [r3, #12]
 802b200:	0a1b      	lsrs	r3, r3, #8
 802b202:	f003 0307 	and.w	r3, r3, #7
}
 802b206:	4618      	mov	r0, r3
 802b208:	46bd      	mov	sp, r7
 802b20a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b20e:	4770      	bx	lr
 802b210:	e000ed00 	.word	0xe000ed00

0802b214 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 802b214:	b480      	push	{r7}
 802b216:	b083      	sub	sp, #12
 802b218:	af00      	add	r7, sp, #0
 802b21a:	4603      	mov	r3, r0
 802b21c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802b21e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802b222:	2b00      	cmp	r3, #0
 802b224:	db0b      	blt.n	802b23e <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 802b226:	79fb      	ldrb	r3, [r7, #7]
 802b228:	f003 021f 	and.w	r2, r3, #31
 802b22c:	4907      	ldr	r1, [pc, #28]	; (802b24c <__NVIC_EnableIRQ+0x38>)
 802b22e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802b232:	095b      	lsrs	r3, r3, #5
 802b234:	2001      	movs	r0, #1
 802b236:	fa00 f202 	lsl.w	r2, r0, r2
 802b23a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 802b23e:	bf00      	nop
 802b240:	370c      	adds	r7, #12
 802b242:	46bd      	mov	sp, r7
 802b244:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b248:	4770      	bx	lr
 802b24a:	bf00      	nop
 802b24c:	e000e100 	.word	0xe000e100

0802b250 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 802b250:	b480      	push	{r7}
 802b252:	b083      	sub	sp, #12
 802b254:	af00      	add	r7, sp, #0
 802b256:	4603      	mov	r3, r0
 802b258:	6039      	str	r1, [r7, #0]
 802b25a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802b25c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802b260:	2b00      	cmp	r3, #0
 802b262:	db0a      	blt.n	802b27a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802b264:	683b      	ldr	r3, [r7, #0]
 802b266:	b2da      	uxtb	r2, r3
 802b268:	490c      	ldr	r1, [pc, #48]	; (802b29c <__NVIC_SetPriority+0x4c>)
 802b26a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802b26e:	0112      	lsls	r2, r2, #4
 802b270:	b2d2      	uxtb	r2, r2
 802b272:	440b      	add	r3, r1
 802b274:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 802b278:	e00a      	b.n	802b290 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802b27a:	683b      	ldr	r3, [r7, #0]
 802b27c:	b2da      	uxtb	r2, r3
 802b27e:	4908      	ldr	r1, [pc, #32]	; (802b2a0 <__NVIC_SetPriority+0x50>)
 802b280:	79fb      	ldrb	r3, [r7, #7]
 802b282:	f003 030f 	and.w	r3, r3, #15
 802b286:	3b04      	subs	r3, #4
 802b288:	0112      	lsls	r2, r2, #4
 802b28a:	b2d2      	uxtb	r2, r2
 802b28c:	440b      	add	r3, r1
 802b28e:	761a      	strb	r2, [r3, #24]
}
 802b290:	bf00      	nop
 802b292:	370c      	adds	r7, #12
 802b294:	46bd      	mov	sp, r7
 802b296:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b29a:	4770      	bx	lr
 802b29c:	e000e100 	.word	0xe000e100
 802b2a0:	e000ed00 	.word	0xe000ed00

0802b2a4 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 802b2a4:	b480      	push	{r7}
 802b2a6:	b089      	sub	sp, #36	; 0x24
 802b2a8:	af00      	add	r7, sp, #0
 802b2aa:	60f8      	str	r0, [r7, #12]
 802b2ac:	60b9      	str	r1, [r7, #8]
 802b2ae:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 802b2b0:	68fb      	ldr	r3, [r7, #12]
 802b2b2:	f003 0307 	and.w	r3, r3, #7
 802b2b6:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 802b2b8:	69fb      	ldr	r3, [r7, #28]
 802b2ba:	f1c3 0307 	rsb	r3, r3, #7
 802b2be:	2b04      	cmp	r3, #4
 802b2c0:	bf28      	it	cs
 802b2c2:	2304      	movcs	r3, #4
 802b2c4:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 802b2c6:	69fb      	ldr	r3, [r7, #28]
 802b2c8:	3304      	adds	r3, #4
 802b2ca:	2b06      	cmp	r3, #6
 802b2cc:	d902      	bls.n	802b2d4 <NVIC_EncodePriority+0x30>
 802b2ce:	69fb      	ldr	r3, [r7, #28]
 802b2d0:	3b03      	subs	r3, #3
 802b2d2:	e000      	b.n	802b2d6 <NVIC_EncodePriority+0x32>
 802b2d4:	2300      	movs	r3, #0
 802b2d6:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802b2d8:	f04f 32ff 	mov.w	r2, #4294967295
 802b2dc:	69bb      	ldr	r3, [r7, #24]
 802b2de:	fa02 f303 	lsl.w	r3, r2, r3
 802b2e2:	43da      	mvns	r2, r3
 802b2e4:	68bb      	ldr	r3, [r7, #8]
 802b2e6:	401a      	ands	r2, r3
 802b2e8:	697b      	ldr	r3, [r7, #20]
 802b2ea:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 802b2ec:	f04f 31ff 	mov.w	r1, #4294967295
 802b2f0:	697b      	ldr	r3, [r7, #20]
 802b2f2:	fa01 f303 	lsl.w	r3, r1, r3
 802b2f6:	43d9      	mvns	r1, r3
 802b2f8:	687b      	ldr	r3, [r7, #4]
 802b2fa:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 802b2fc:	4313      	orrs	r3, r2
         );
}
 802b2fe:	4618      	mov	r0, r3
 802b300:	3724      	adds	r7, #36	; 0x24
 802b302:	46bd      	mov	sp, r7
 802b304:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b308:	4770      	bx	lr
	...

0802b30c <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 802b30c:	b580      	push	{r7, lr}
 802b30e:	b082      	sub	sp, #8
 802b310:	af00      	add	r7, sp, #0
 802b312:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 802b314:	687b      	ldr	r3, [r7, #4]
 802b316:	3b01      	subs	r3, #1
 802b318:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 802b31c:	d301      	bcc.n	802b322 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 802b31e:	2301      	movs	r3, #1
 802b320:	e00f      	b.n	802b342 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 802b322:	4a0a      	ldr	r2, [pc, #40]	; (802b34c <SysTick_Config+0x40>)
 802b324:	687b      	ldr	r3, [r7, #4]
 802b326:	3b01      	subs	r3, #1
 802b328:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 802b32a:	210f      	movs	r1, #15
 802b32c:	f04f 30ff 	mov.w	r0, #4294967295
 802b330:	f7ff ff8e 	bl	802b250 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 802b334:	4b05      	ldr	r3, [pc, #20]	; (802b34c <SysTick_Config+0x40>)
 802b336:	2200      	movs	r2, #0
 802b338:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 802b33a:	4b04      	ldr	r3, [pc, #16]	; (802b34c <SysTick_Config+0x40>)
 802b33c:	2207      	movs	r2, #7
 802b33e:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 802b340:	2300      	movs	r3, #0
}
 802b342:	4618      	mov	r0, r3
 802b344:	3708      	adds	r7, #8
 802b346:	46bd      	mov	sp, r7
 802b348:	bd80      	pop	{r7, pc}
 802b34a:	bf00      	nop
 802b34c:	e000e010 	.word	0xe000e010

0802b350 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 802b350:	b580      	push	{r7, lr}
 802b352:	b082      	sub	sp, #8
 802b354:	af00      	add	r7, sp, #0
 802b356:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 802b358:	6878      	ldr	r0, [r7, #4]
 802b35a:	f7ff ff29 	bl	802b1b0 <__NVIC_SetPriorityGrouping>
}
 802b35e:	bf00      	nop
 802b360:	3708      	adds	r7, #8
 802b362:	46bd      	mov	sp, r7
 802b364:	bd80      	pop	{r7, pc}

0802b366 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 802b366:	b580      	push	{r7, lr}
 802b368:	b086      	sub	sp, #24
 802b36a:	af00      	add	r7, sp, #0
 802b36c:	4603      	mov	r3, r0
 802b36e:	60b9      	str	r1, [r7, #8]
 802b370:	607a      	str	r2, [r7, #4]
 802b372:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 802b374:	2300      	movs	r3, #0
 802b376:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 802b378:	f7ff ff3e 	bl	802b1f8 <__NVIC_GetPriorityGrouping>
 802b37c:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 802b37e:	687a      	ldr	r2, [r7, #4]
 802b380:	68b9      	ldr	r1, [r7, #8]
 802b382:	6978      	ldr	r0, [r7, #20]
 802b384:	f7ff ff8e 	bl	802b2a4 <NVIC_EncodePriority>
 802b388:	4602      	mov	r2, r0
 802b38a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 802b38e:	4611      	mov	r1, r2
 802b390:	4618      	mov	r0, r3
 802b392:	f7ff ff5d 	bl	802b250 <__NVIC_SetPriority>
}
 802b396:	bf00      	nop
 802b398:	3718      	adds	r7, #24
 802b39a:	46bd      	mov	sp, r7
 802b39c:	bd80      	pop	{r7, pc}

0802b39e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 802b39e:	b580      	push	{r7, lr}
 802b3a0:	b082      	sub	sp, #8
 802b3a2:	af00      	add	r7, sp, #0
 802b3a4:	4603      	mov	r3, r0
 802b3a6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 802b3a8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802b3ac:	4618      	mov	r0, r3
 802b3ae:	f7ff ff31 	bl	802b214 <__NVIC_EnableIRQ>
}
 802b3b2:	bf00      	nop
 802b3b4:	3708      	adds	r7, #8
 802b3b6:	46bd      	mov	sp, r7
 802b3b8:	bd80      	pop	{r7, pc}

0802b3ba <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 802b3ba:	b580      	push	{r7, lr}
 802b3bc:	b082      	sub	sp, #8
 802b3be:	af00      	add	r7, sp, #0
 802b3c0:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 802b3c2:	6878      	ldr	r0, [r7, #4]
 802b3c4:	f7ff ffa2 	bl	802b30c <SysTick_Config>
 802b3c8:	4603      	mov	r3, r0
}
 802b3ca:	4618      	mov	r0, r3
 802b3cc:	3708      	adds	r7, #8
 802b3ce:	46bd      	mov	sp, r7
 802b3d0:	bd80      	pop	{r7, pc}
	...

0802b3d4 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 802b3d4:	b580      	push	{r7, lr}
 802b3d6:	b086      	sub	sp, #24
 802b3d8:	af00      	add	r7, sp, #0
 802b3da:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 802b3dc:	2300      	movs	r3, #0
 802b3de:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 802b3e0:	f7ff feb8 	bl	802b154 <HAL_GetTick>
 802b3e4:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 802b3e6:	687b      	ldr	r3, [r7, #4]
 802b3e8:	2b00      	cmp	r3, #0
 802b3ea:	d101      	bne.n	802b3f0 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 802b3ec:	2301      	movs	r3, #1
 802b3ee:	e099      	b.n	802b524 <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 802b3f0:	687b      	ldr	r3, [r7, #4]
 802b3f2:	2200      	movs	r2, #0
 802b3f4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 802b3f8:	687b      	ldr	r3, [r7, #4]
 802b3fa:	2202      	movs	r2, #2
 802b3fc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 802b400:	687b      	ldr	r3, [r7, #4]
 802b402:	681b      	ldr	r3, [r3, #0]
 802b404:	681a      	ldr	r2, [r3, #0]
 802b406:	687b      	ldr	r3, [r7, #4]
 802b408:	681b      	ldr	r3, [r3, #0]
 802b40a:	f022 0201 	bic.w	r2, r2, #1
 802b40e:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 802b410:	e00f      	b.n	802b432 <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 802b412:	f7ff fe9f 	bl	802b154 <HAL_GetTick>
 802b416:	4602      	mov	r2, r0
 802b418:	693b      	ldr	r3, [r7, #16]
 802b41a:	1ad3      	subs	r3, r2, r3
 802b41c:	2b05      	cmp	r3, #5
 802b41e:	d908      	bls.n	802b432 <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 802b420:	687b      	ldr	r3, [r7, #4]
 802b422:	2220      	movs	r2, #32
 802b424:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 802b426:	687b      	ldr	r3, [r7, #4]
 802b428:	2203      	movs	r2, #3
 802b42a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 802b42e:	2303      	movs	r3, #3
 802b430:	e078      	b.n	802b524 <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 802b432:	687b      	ldr	r3, [r7, #4]
 802b434:	681b      	ldr	r3, [r3, #0]
 802b436:	681b      	ldr	r3, [r3, #0]
 802b438:	f003 0301 	and.w	r3, r3, #1
 802b43c:	2b00      	cmp	r3, #0
 802b43e:	d1e8      	bne.n	802b412 <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 802b440:	687b      	ldr	r3, [r7, #4]
 802b442:	681b      	ldr	r3, [r3, #0]
 802b444:	681b      	ldr	r3, [r3, #0]
 802b446:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 802b448:	697a      	ldr	r2, [r7, #20]
 802b44a:	4b38      	ldr	r3, [pc, #224]	; (802b52c <HAL_DMA_Init+0x158>)
 802b44c:	4013      	ands	r3, r2
 802b44e:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802b450:	687b      	ldr	r3, [r7, #4]
 802b452:	685a      	ldr	r2, [r3, #4]
 802b454:	687b      	ldr	r3, [r7, #4]
 802b456:	689b      	ldr	r3, [r3, #8]
 802b458:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 802b45a:	687b      	ldr	r3, [r7, #4]
 802b45c:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802b45e:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 802b460:	687b      	ldr	r3, [r7, #4]
 802b462:	691b      	ldr	r3, [r3, #16]
 802b464:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802b466:	687b      	ldr	r3, [r7, #4]
 802b468:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 802b46a:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802b46c:	687b      	ldr	r3, [r7, #4]
 802b46e:	699b      	ldr	r3, [r3, #24]
 802b470:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 802b472:	687b      	ldr	r3, [r7, #4]
 802b474:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 802b476:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 802b478:	687b      	ldr	r3, [r7, #4]
 802b47a:	6a1b      	ldr	r3, [r3, #32]
 802b47c:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 802b47e:	697a      	ldr	r2, [r7, #20]
 802b480:	4313      	orrs	r3, r2
 802b482:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 802b484:	687b      	ldr	r3, [r7, #4]
 802b486:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802b488:	2b04      	cmp	r3, #4
 802b48a:	d107      	bne.n	802b49c <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 802b48c:	687b      	ldr	r3, [r7, #4]
 802b48e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 802b490:	687b      	ldr	r3, [r7, #4]
 802b492:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802b494:	4313      	orrs	r3, r2
 802b496:	697a      	ldr	r2, [r7, #20]
 802b498:	4313      	orrs	r3, r2
 802b49a:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 802b49c:	687b      	ldr	r3, [r7, #4]
 802b49e:	681b      	ldr	r3, [r3, #0]
 802b4a0:	697a      	ldr	r2, [r7, #20]
 802b4a2:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 802b4a4:	687b      	ldr	r3, [r7, #4]
 802b4a6:	681b      	ldr	r3, [r3, #0]
 802b4a8:	695b      	ldr	r3, [r3, #20]
 802b4aa:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 802b4ac:	697b      	ldr	r3, [r7, #20]
 802b4ae:	f023 0307 	bic.w	r3, r3, #7
 802b4b2:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 802b4b4:	687b      	ldr	r3, [r7, #4]
 802b4b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802b4b8:	697a      	ldr	r2, [r7, #20]
 802b4ba:	4313      	orrs	r3, r2
 802b4bc:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 802b4be:	687b      	ldr	r3, [r7, #4]
 802b4c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802b4c2:	2b04      	cmp	r3, #4
 802b4c4:	d117      	bne.n	802b4f6 <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 802b4c6:	687b      	ldr	r3, [r7, #4]
 802b4c8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802b4ca:	697a      	ldr	r2, [r7, #20]
 802b4cc:	4313      	orrs	r3, r2
 802b4ce:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 802b4d0:	687b      	ldr	r3, [r7, #4]
 802b4d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802b4d4:	2b00      	cmp	r3, #0
 802b4d6:	d00e      	beq.n	802b4f6 <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 802b4d8:	6878      	ldr	r0, [r7, #4]
 802b4da:	f000 fa91 	bl	802ba00 <DMA_CheckFifoParam>
 802b4de:	4603      	mov	r3, r0
 802b4e0:	2b00      	cmp	r3, #0
 802b4e2:	d008      	beq.n	802b4f6 <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 802b4e4:	687b      	ldr	r3, [r7, #4]
 802b4e6:	2240      	movs	r2, #64	; 0x40
 802b4e8:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 802b4ea:	687b      	ldr	r3, [r7, #4]
 802b4ec:	2201      	movs	r2, #1
 802b4ee:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
 802b4f2:	2301      	movs	r3, #1
 802b4f4:	e016      	b.n	802b524 <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 802b4f6:	687b      	ldr	r3, [r7, #4]
 802b4f8:	681b      	ldr	r3, [r3, #0]
 802b4fa:	697a      	ldr	r2, [r7, #20]
 802b4fc:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 802b4fe:	6878      	ldr	r0, [r7, #4]
 802b500:	f000 fa48 	bl	802b994 <DMA_CalcBaseAndBitshift>
 802b504:	4603      	mov	r3, r0
 802b506:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 802b508:	687b      	ldr	r3, [r7, #4]
 802b50a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b50c:	223f      	movs	r2, #63	; 0x3f
 802b50e:	409a      	lsls	r2, r3
 802b510:	68fb      	ldr	r3, [r7, #12]
 802b512:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802b514:	687b      	ldr	r3, [r7, #4]
 802b516:	2200      	movs	r2, #0
 802b518:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 802b51a:	687b      	ldr	r3, [r7, #4]
 802b51c:	2201      	movs	r2, #1
 802b51e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 802b522:	2300      	movs	r3, #0
}
 802b524:	4618      	mov	r0, r3
 802b526:	3718      	adds	r7, #24
 802b528:	46bd      	mov	sp, r7
 802b52a:	bd80      	pop	{r7, pc}
 802b52c:	f010803f 	.word	0xf010803f

0802b530 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802b530:	b580      	push	{r7, lr}
 802b532:	b086      	sub	sp, #24
 802b534:	af00      	add	r7, sp, #0
 802b536:	60f8      	str	r0, [r7, #12]
 802b538:	60b9      	str	r1, [r7, #8]
 802b53a:	607a      	str	r2, [r7, #4]
 802b53c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 802b53e:	2300      	movs	r3, #0
 802b540:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 802b542:	68fb      	ldr	r3, [r7, #12]
 802b544:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802b546:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 802b548:	68fb      	ldr	r3, [r7, #12]
 802b54a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 802b54e:	2b01      	cmp	r3, #1
 802b550:	d101      	bne.n	802b556 <HAL_DMA_Start_IT+0x26>
 802b552:	2302      	movs	r3, #2
 802b554:	e040      	b.n	802b5d8 <HAL_DMA_Start_IT+0xa8>
 802b556:	68fb      	ldr	r3, [r7, #12]
 802b558:	2201      	movs	r2, #1
 802b55a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 802b55e:	68fb      	ldr	r3, [r7, #12]
 802b560:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 802b564:	b2db      	uxtb	r3, r3
 802b566:	2b01      	cmp	r3, #1
 802b568:	d12f      	bne.n	802b5ca <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 802b56a:	68fb      	ldr	r3, [r7, #12]
 802b56c:	2202      	movs	r2, #2
 802b56e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 802b572:	68fb      	ldr	r3, [r7, #12]
 802b574:	2200      	movs	r2, #0
 802b576:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 802b578:	683b      	ldr	r3, [r7, #0]
 802b57a:	687a      	ldr	r2, [r7, #4]
 802b57c:	68b9      	ldr	r1, [r7, #8]
 802b57e:	68f8      	ldr	r0, [r7, #12]
 802b580:	f000 f9da 	bl	802b938 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 802b584:	68fb      	ldr	r3, [r7, #12]
 802b586:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b588:	223f      	movs	r2, #63	; 0x3f
 802b58a:	409a      	lsls	r2, r3
 802b58c:	693b      	ldr	r3, [r7, #16]
 802b58e:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 802b590:	68fb      	ldr	r3, [r7, #12]
 802b592:	681b      	ldr	r3, [r3, #0]
 802b594:	681a      	ldr	r2, [r3, #0]
 802b596:	68fb      	ldr	r3, [r7, #12]
 802b598:	681b      	ldr	r3, [r3, #0]
 802b59a:	f042 0216 	orr.w	r2, r2, #22
 802b59e:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 802b5a0:	68fb      	ldr	r3, [r7, #12]
 802b5a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b5a4:	2b00      	cmp	r3, #0
 802b5a6:	d007      	beq.n	802b5b8 <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 802b5a8:	68fb      	ldr	r3, [r7, #12]
 802b5aa:	681b      	ldr	r3, [r3, #0]
 802b5ac:	681a      	ldr	r2, [r3, #0]
 802b5ae:	68fb      	ldr	r3, [r7, #12]
 802b5b0:	681b      	ldr	r3, [r3, #0]
 802b5b2:	f042 0208 	orr.w	r2, r2, #8
 802b5b6:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 802b5b8:	68fb      	ldr	r3, [r7, #12]
 802b5ba:	681b      	ldr	r3, [r3, #0]
 802b5bc:	681a      	ldr	r2, [r3, #0]
 802b5be:	68fb      	ldr	r3, [r7, #12]
 802b5c0:	681b      	ldr	r3, [r3, #0]
 802b5c2:	f042 0201 	orr.w	r2, r2, #1
 802b5c6:	601a      	str	r2, [r3, #0]
 802b5c8:	e005      	b.n	802b5d6 <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 802b5ca:	68fb      	ldr	r3, [r7, #12]
 802b5cc:	2200      	movs	r2, #0
 802b5ce:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 802b5d2:	2302      	movs	r3, #2
 802b5d4:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 802b5d6:	7dfb      	ldrb	r3, [r7, #23]
}
 802b5d8:	4618      	mov	r0, r3
 802b5da:	3718      	adds	r7, #24
 802b5dc:	46bd      	mov	sp, r7
 802b5de:	bd80      	pop	{r7, pc}

0802b5e0 <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 802b5e0:	b480      	push	{r7}
 802b5e2:	b083      	sub	sp, #12
 802b5e4:	af00      	add	r7, sp, #0
 802b5e6:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 802b5e8:	687b      	ldr	r3, [r7, #4]
 802b5ea:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 802b5ee:	b2db      	uxtb	r3, r3
 802b5f0:	2b02      	cmp	r3, #2
 802b5f2:	d004      	beq.n	802b5fe <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 802b5f4:	687b      	ldr	r3, [r7, #4]
 802b5f6:	2280      	movs	r2, #128	; 0x80
 802b5f8:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 802b5fa:	2301      	movs	r3, #1
 802b5fc:	e00c      	b.n	802b618 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 802b5fe:	687b      	ldr	r3, [r7, #4]
 802b600:	2205      	movs	r2, #5
 802b602:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 802b606:	687b      	ldr	r3, [r7, #4]
 802b608:	681b      	ldr	r3, [r3, #0]
 802b60a:	681a      	ldr	r2, [r3, #0]
 802b60c:	687b      	ldr	r3, [r7, #4]
 802b60e:	681b      	ldr	r3, [r3, #0]
 802b610:	f022 0201 	bic.w	r2, r2, #1
 802b614:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 802b616:	2300      	movs	r3, #0
}
 802b618:	4618      	mov	r0, r3
 802b61a:	370c      	adds	r7, #12
 802b61c:	46bd      	mov	sp, r7
 802b61e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b622:	4770      	bx	lr

0802b624 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 802b624:	b580      	push	{r7, lr}
 802b626:	b086      	sub	sp, #24
 802b628:	af00      	add	r7, sp, #0
 802b62a:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
 802b62c:	2300      	movs	r3, #0
 802b62e:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 802b630:	4b92      	ldr	r3, [pc, #584]	; (802b87c <HAL_DMA_IRQHandler+0x258>)
 802b632:	681b      	ldr	r3, [r3, #0]
 802b634:	4a92      	ldr	r2, [pc, #584]	; (802b880 <HAL_DMA_IRQHandler+0x25c>)
 802b636:	fba2 2303 	umull	r2, r3, r2, r3
 802b63a:	0a9b      	lsrs	r3, r3, #10
 802b63c:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 802b63e:	687b      	ldr	r3, [r7, #4]
 802b640:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802b642:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 802b644:	693b      	ldr	r3, [r7, #16]
 802b646:	681b      	ldr	r3, [r3, #0]
 802b648:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 802b64a:	687b      	ldr	r3, [r7, #4]
 802b64c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b64e:	2208      	movs	r2, #8
 802b650:	409a      	lsls	r2, r3
 802b652:	68fb      	ldr	r3, [r7, #12]
 802b654:	4013      	ands	r3, r2
 802b656:	2b00      	cmp	r3, #0
 802b658:	d01a      	beq.n	802b690 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 802b65a:	687b      	ldr	r3, [r7, #4]
 802b65c:	681b      	ldr	r3, [r3, #0]
 802b65e:	681b      	ldr	r3, [r3, #0]
 802b660:	f003 0304 	and.w	r3, r3, #4
 802b664:	2b00      	cmp	r3, #0
 802b666:	d013      	beq.n	802b690 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 802b668:	687b      	ldr	r3, [r7, #4]
 802b66a:	681b      	ldr	r3, [r3, #0]
 802b66c:	681a      	ldr	r2, [r3, #0]
 802b66e:	687b      	ldr	r3, [r7, #4]
 802b670:	681b      	ldr	r3, [r3, #0]
 802b672:	f022 0204 	bic.w	r2, r2, #4
 802b676:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 802b678:	687b      	ldr	r3, [r7, #4]
 802b67a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b67c:	2208      	movs	r2, #8
 802b67e:	409a      	lsls	r2, r3
 802b680:	693b      	ldr	r3, [r7, #16]
 802b682:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 802b684:	687b      	ldr	r3, [r7, #4]
 802b686:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802b688:	f043 0201 	orr.w	r2, r3, #1
 802b68c:	687b      	ldr	r3, [r7, #4]
 802b68e:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 802b690:	687b      	ldr	r3, [r7, #4]
 802b692:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b694:	2201      	movs	r2, #1
 802b696:	409a      	lsls	r2, r3
 802b698:	68fb      	ldr	r3, [r7, #12]
 802b69a:	4013      	ands	r3, r2
 802b69c:	2b00      	cmp	r3, #0
 802b69e:	d012      	beq.n	802b6c6 <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 802b6a0:	687b      	ldr	r3, [r7, #4]
 802b6a2:	681b      	ldr	r3, [r3, #0]
 802b6a4:	695b      	ldr	r3, [r3, #20]
 802b6a6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802b6aa:	2b00      	cmp	r3, #0
 802b6ac:	d00b      	beq.n	802b6c6 <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 802b6ae:	687b      	ldr	r3, [r7, #4]
 802b6b0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b6b2:	2201      	movs	r2, #1
 802b6b4:	409a      	lsls	r2, r3
 802b6b6:	693b      	ldr	r3, [r7, #16]
 802b6b8:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 802b6ba:	687b      	ldr	r3, [r7, #4]
 802b6bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802b6be:	f043 0202 	orr.w	r2, r3, #2
 802b6c2:	687b      	ldr	r3, [r7, #4]
 802b6c4:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 802b6c6:	687b      	ldr	r3, [r7, #4]
 802b6c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b6ca:	2204      	movs	r2, #4
 802b6cc:	409a      	lsls	r2, r3
 802b6ce:	68fb      	ldr	r3, [r7, #12]
 802b6d0:	4013      	ands	r3, r2
 802b6d2:	2b00      	cmp	r3, #0
 802b6d4:	d012      	beq.n	802b6fc <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 802b6d6:	687b      	ldr	r3, [r7, #4]
 802b6d8:	681b      	ldr	r3, [r3, #0]
 802b6da:	681b      	ldr	r3, [r3, #0]
 802b6dc:	f003 0302 	and.w	r3, r3, #2
 802b6e0:	2b00      	cmp	r3, #0
 802b6e2:	d00b      	beq.n	802b6fc <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 802b6e4:	687b      	ldr	r3, [r7, #4]
 802b6e6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b6e8:	2204      	movs	r2, #4
 802b6ea:	409a      	lsls	r2, r3
 802b6ec:	693b      	ldr	r3, [r7, #16]
 802b6ee:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 802b6f0:	687b      	ldr	r3, [r7, #4]
 802b6f2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802b6f4:	f043 0204 	orr.w	r2, r3, #4
 802b6f8:	687b      	ldr	r3, [r7, #4]
 802b6fa:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 802b6fc:	687b      	ldr	r3, [r7, #4]
 802b6fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b700:	2210      	movs	r2, #16
 802b702:	409a      	lsls	r2, r3
 802b704:	68fb      	ldr	r3, [r7, #12]
 802b706:	4013      	ands	r3, r2
 802b708:	2b00      	cmp	r3, #0
 802b70a:	d043      	beq.n	802b794 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 802b70c:	687b      	ldr	r3, [r7, #4]
 802b70e:	681b      	ldr	r3, [r3, #0]
 802b710:	681b      	ldr	r3, [r3, #0]
 802b712:	f003 0308 	and.w	r3, r3, #8
 802b716:	2b00      	cmp	r3, #0
 802b718:	d03c      	beq.n	802b794 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 802b71a:	687b      	ldr	r3, [r7, #4]
 802b71c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b71e:	2210      	movs	r2, #16
 802b720:	409a      	lsls	r2, r3
 802b722:	693b      	ldr	r3, [r7, #16]
 802b724:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 802b726:	687b      	ldr	r3, [r7, #4]
 802b728:	681b      	ldr	r3, [r3, #0]
 802b72a:	681b      	ldr	r3, [r3, #0]
 802b72c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 802b730:	2b00      	cmp	r3, #0
 802b732:	d018      	beq.n	802b766 <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 802b734:	687b      	ldr	r3, [r7, #4]
 802b736:	681b      	ldr	r3, [r3, #0]
 802b738:	681b      	ldr	r3, [r3, #0]
 802b73a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 802b73e:	2b00      	cmp	r3, #0
 802b740:	d108      	bne.n	802b754 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 802b742:	687b      	ldr	r3, [r7, #4]
 802b744:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b746:	2b00      	cmp	r3, #0
 802b748:	d024      	beq.n	802b794 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 802b74a:	687b      	ldr	r3, [r7, #4]
 802b74c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b74e:	6878      	ldr	r0, [r7, #4]
 802b750:	4798      	blx	r3
 802b752:	e01f      	b.n	802b794 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 802b754:	687b      	ldr	r3, [r7, #4]
 802b756:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802b758:	2b00      	cmp	r3, #0
 802b75a:	d01b      	beq.n	802b794 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 802b75c:	687b      	ldr	r3, [r7, #4]
 802b75e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802b760:	6878      	ldr	r0, [r7, #4]
 802b762:	4798      	blx	r3
 802b764:	e016      	b.n	802b794 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 802b766:	687b      	ldr	r3, [r7, #4]
 802b768:	681b      	ldr	r3, [r3, #0]
 802b76a:	681b      	ldr	r3, [r3, #0]
 802b76c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802b770:	2b00      	cmp	r3, #0
 802b772:	d107      	bne.n	802b784 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 802b774:	687b      	ldr	r3, [r7, #4]
 802b776:	681b      	ldr	r3, [r3, #0]
 802b778:	681a      	ldr	r2, [r3, #0]
 802b77a:	687b      	ldr	r3, [r7, #4]
 802b77c:	681b      	ldr	r3, [r3, #0]
 802b77e:	f022 0208 	bic.w	r2, r2, #8
 802b782:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 802b784:	687b      	ldr	r3, [r7, #4]
 802b786:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b788:	2b00      	cmp	r3, #0
 802b78a:	d003      	beq.n	802b794 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 802b78c:	687b      	ldr	r3, [r7, #4]
 802b78e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b790:	6878      	ldr	r0, [r7, #4]
 802b792:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 802b794:	687b      	ldr	r3, [r7, #4]
 802b796:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b798:	2220      	movs	r2, #32
 802b79a:	409a      	lsls	r2, r3
 802b79c:	68fb      	ldr	r3, [r7, #12]
 802b79e:	4013      	ands	r3, r2
 802b7a0:	2b00      	cmp	r3, #0
 802b7a2:	f000 808e 	beq.w	802b8c2 <HAL_DMA_IRQHandler+0x29e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 802b7a6:	687b      	ldr	r3, [r7, #4]
 802b7a8:	681b      	ldr	r3, [r3, #0]
 802b7aa:	681b      	ldr	r3, [r3, #0]
 802b7ac:	f003 0310 	and.w	r3, r3, #16
 802b7b0:	2b00      	cmp	r3, #0
 802b7b2:	f000 8086 	beq.w	802b8c2 <HAL_DMA_IRQHandler+0x29e>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 802b7b6:	687b      	ldr	r3, [r7, #4]
 802b7b8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b7ba:	2220      	movs	r2, #32
 802b7bc:	409a      	lsls	r2, r3
 802b7be:	693b      	ldr	r3, [r7, #16]
 802b7c0:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 802b7c2:	687b      	ldr	r3, [r7, #4]
 802b7c4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 802b7c8:	b2db      	uxtb	r3, r3
 802b7ca:	2b05      	cmp	r3, #5
 802b7cc:	d136      	bne.n	802b83c <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 802b7ce:	687b      	ldr	r3, [r7, #4]
 802b7d0:	681b      	ldr	r3, [r3, #0]
 802b7d2:	681a      	ldr	r2, [r3, #0]
 802b7d4:	687b      	ldr	r3, [r7, #4]
 802b7d6:	681b      	ldr	r3, [r3, #0]
 802b7d8:	f022 0216 	bic.w	r2, r2, #22
 802b7dc:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 802b7de:	687b      	ldr	r3, [r7, #4]
 802b7e0:	681b      	ldr	r3, [r3, #0]
 802b7e2:	695a      	ldr	r2, [r3, #20]
 802b7e4:	687b      	ldr	r3, [r7, #4]
 802b7e6:	681b      	ldr	r3, [r3, #0]
 802b7e8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802b7ec:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 802b7ee:	687b      	ldr	r3, [r7, #4]
 802b7f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802b7f2:	2b00      	cmp	r3, #0
 802b7f4:	d103      	bne.n	802b7fe <HAL_DMA_IRQHandler+0x1da>
 802b7f6:	687b      	ldr	r3, [r7, #4]
 802b7f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802b7fa:	2b00      	cmp	r3, #0
 802b7fc:	d007      	beq.n	802b80e <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 802b7fe:	687b      	ldr	r3, [r7, #4]
 802b800:	681b      	ldr	r3, [r3, #0]
 802b802:	681a      	ldr	r2, [r3, #0]
 802b804:	687b      	ldr	r3, [r7, #4]
 802b806:	681b      	ldr	r3, [r3, #0]
 802b808:	f022 0208 	bic.w	r2, r2, #8
 802b80c:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 802b80e:	687b      	ldr	r3, [r7, #4]
 802b810:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802b812:	223f      	movs	r2, #63	; 0x3f
 802b814:	409a      	lsls	r2, r3
 802b816:	693b      	ldr	r3, [r7, #16]
 802b818:	609a      	str	r2, [r3, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 802b81a:	687b      	ldr	r3, [r7, #4]
 802b81c:	2200      	movs	r2, #0
 802b81e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 802b822:	687b      	ldr	r3, [r7, #4]
 802b824:	2201      	movs	r2, #1
 802b826:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
 802b82a:	687b      	ldr	r3, [r7, #4]
 802b82c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802b82e:	2b00      	cmp	r3, #0
 802b830:	d07d      	beq.n	802b92e <HAL_DMA_IRQHandler+0x30a>
        {
          hdma->XferAbortCallback(hdma);
 802b832:	687b      	ldr	r3, [r7, #4]
 802b834:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802b836:	6878      	ldr	r0, [r7, #4]
 802b838:	4798      	blx	r3
        }
        return;
 802b83a:	e078      	b.n	802b92e <HAL_DMA_IRQHandler+0x30a>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 802b83c:	687b      	ldr	r3, [r7, #4]
 802b83e:	681b      	ldr	r3, [r3, #0]
 802b840:	681b      	ldr	r3, [r3, #0]
 802b842:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 802b846:	2b00      	cmp	r3, #0
 802b848:	d01c      	beq.n	802b884 <HAL_DMA_IRQHandler+0x260>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 802b84a:	687b      	ldr	r3, [r7, #4]
 802b84c:	681b      	ldr	r3, [r3, #0]
 802b84e:	681b      	ldr	r3, [r3, #0]
 802b850:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 802b854:	2b00      	cmp	r3, #0
 802b856:	d108      	bne.n	802b86a <HAL_DMA_IRQHandler+0x246>
        {
          if(hdma->XferM1CpltCallback != NULL)
 802b858:	687b      	ldr	r3, [r7, #4]
 802b85a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b85c:	2b00      	cmp	r3, #0
 802b85e:	d030      	beq.n	802b8c2 <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 802b860:	687b      	ldr	r3, [r7, #4]
 802b862:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802b864:	6878      	ldr	r0, [r7, #4]
 802b866:	4798      	blx	r3
 802b868:	e02b      	b.n	802b8c2 <HAL_DMA_IRQHandler+0x29e>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 802b86a:	687b      	ldr	r3, [r7, #4]
 802b86c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802b86e:	2b00      	cmp	r3, #0
 802b870:	d027      	beq.n	802b8c2 <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 802b872:	687b      	ldr	r3, [r7, #4]
 802b874:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802b876:	6878      	ldr	r0, [r7, #4]
 802b878:	4798      	blx	r3
 802b87a:	e022      	b.n	802b8c2 <HAL_DMA_IRQHandler+0x29e>
 802b87c:	20000098 	.word	0x20000098
 802b880:	1b4e81b5 	.word	0x1b4e81b5
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 802b884:	687b      	ldr	r3, [r7, #4]
 802b886:	681b      	ldr	r3, [r3, #0]
 802b888:	681b      	ldr	r3, [r3, #0]
 802b88a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802b88e:	2b00      	cmp	r3, #0
 802b890:	d10f      	bne.n	802b8b2 <HAL_DMA_IRQHandler+0x28e>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 802b892:	687b      	ldr	r3, [r7, #4]
 802b894:	681b      	ldr	r3, [r3, #0]
 802b896:	681a      	ldr	r2, [r3, #0]
 802b898:	687b      	ldr	r3, [r7, #4]
 802b89a:	681b      	ldr	r3, [r3, #0]
 802b89c:	f022 0210 	bic.w	r2, r2, #16
 802b8a0:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 802b8a2:	687b      	ldr	r3, [r7, #4]
 802b8a4:	2200      	movs	r2, #0
 802b8a6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 802b8aa:	687b      	ldr	r3, [r7, #4]
 802b8ac:	2201      	movs	r2, #1
 802b8ae:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
 802b8b2:	687b      	ldr	r3, [r7, #4]
 802b8b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802b8b6:	2b00      	cmp	r3, #0
 802b8b8:	d003      	beq.n	802b8c2 <HAL_DMA_IRQHandler+0x29e>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 802b8ba:	687b      	ldr	r3, [r7, #4]
 802b8bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802b8be:	6878      	ldr	r0, [r7, #4]
 802b8c0:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 802b8c2:	687b      	ldr	r3, [r7, #4]
 802b8c4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802b8c6:	2b00      	cmp	r3, #0
 802b8c8:	d032      	beq.n	802b930 <HAL_DMA_IRQHandler+0x30c>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 802b8ca:	687b      	ldr	r3, [r7, #4]
 802b8cc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802b8ce:	f003 0301 	and.w	r3, r3, #1
 802b8d2:	2b00      	cmp	r3, #0
 802b8d4:	d022      	beq.n	802b91c <HAL_DMA_IRQHandler+0x2f8>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 802b8d6:	687b      	ldr	r3, [r7, #4]
 802b8d8:	2205      	movs	r2, #5
 802b8da:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 802b8de:	687b      	ldr	r3, [r7, #4]
 802b8e0:	681b      	ldr	r3, [r3, #0]
 802b8e2:	681a      	ldr	r2, [r3, #0]
 802b8e4:	687b      	ldr	r3, [r7, #4]
 802b8e6:	681b      	ldr	r3, [r3, #0]
 802b8e8:	f022 0201 	bic.w	r2, r2, #1
 802b8ec:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 802b8ee:	68bb      	ldr	r3, [r7, #8]
 802b8f0:	3301      	adds	r3, #1
 802b8f2:	60bb      	str	r3, [r7, #8]
 802b8f4:	697a      	ldr	r2, [r7, #20]
 802b8f6:	429a      	cmp	r2, r3
 802b8f8:	d307      	bcc.n	802b90a <HAL_DMA_IRQHandler+0x2e6>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 802b8fa:	687b      	ldr	r3, [r7, #4]
 802b8fc:	681b      	ldr	r3, [r3, #0]
 802b8fe:	681b      	ldr	r3, [r3, #0]
 802b900:	f003 0301 	and.w	r3, r3, #1
 802b904:	2b00      	cmp	r3, #0
 802b906:	d1f2      	bne.n	802b8ee <HAL_DMA_IRQHandler+0x2ca>
 802b908:	e000      	b.n	802b90c <HAL_DMA_IRQHandler+0x2e8>
          break;
 802b90a:	bf00      	nop

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 802b90c:	687b      	ldr	r3, [r7, #4]
 802b90e:	2200      	movs	r2, #0
 802b910:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 802b914:	687b      	ldr	r3, [r7, #4]
 802b916:	2201      	movs	r2, #1
 802b918:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
 802b91c:	687b      	ldr	r3, [r7, #4]
 802b91e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802b920:	2b00      	cmp	r3, #0
 802b922:	d005      	beq.n	802b930 <HAL_DMA_IRQHandler+0x30c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 802b924:	687b      	ldr	r3, [r7, #4]
 802b926:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802b928:	6878      	ldr	r0, [r7, #4]
 802b92a:	4798      	blx	r3
 802b92c:	e000      	b.n	802b930 <HAL_DMA_IRQHandler+0x30c>
        return;
 802b92e:	bf00      	nop
    }
  }
}
 802b930:	3718      	adds	r7, #24
 802b932:	46bd      	mov	sp, r7
 802b934:	bd80      	pop	{r7, pc}
 802b936:	bf00      	nop

0802b938 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 802b938:	b480      	push	{r7}
 802b93a:	b085      	sub	sp, #20
 802b93c:	af00      	add	r7, sp, #0
 802b93e:	60f8      	str	r0, [r7, #12]
 802b940:	60b9      	str	r1, [r7, #8]
 802b942:	607a      	str	r2, [r7, #4]
 802b944:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 802b946:	68fb      	ldr	r3, [r7, #12]
 802b948:	681b      	ldr	r3, [r3, #0]
 802b94a:	681a      	ldr	r2, [r3, #0]
 802b94c:	68fb      	ldr	r3, [r7, #12]
 802b94e:	681b      	ldr	r3, [r3, #0]
 802b950:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 802b954:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 802b956:	68fb      	ldr	r3, [r7, #12]
 802b958:	681b      	ldr	r3, [r3, #0]
 802b95a:	683a      	ldr	r2, [r7, #0]
 802b95c:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 802b95e:	68fb      	ldr	r3, [r7, #12]
 802b960:	689b      	ldr	r3, [r3, #8]
 802b962:	2b40      	cmp	r3, #64	; 0x40
 802b964:	d108      	bne.n	802b978 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 802b966:	68fb      	ldr	r3, [r7, #12]
 802b968:	681b      	ldr	r3, [r3, #0]
 802b96a:	687a      	ldr	r2, [r7, #4]
 802b96c:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 802b96e:	68fb      	ldr	r3, [r7, #12]
 802b970:	681b      	ldr	r3, [r3, #0]
 802b972:	68ba      	ldr	r2, [r7, #8]
 802b974:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 802b976:	e007      	b.n	802b988 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 802b978:	68fb      	ldr	r3, [r7, #12]
 802b97a:	681b      	ldr	r3, [r3, #0]
 802b97c:	68ba      	ldr	r2, [r7, #8]
 802b97e:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 802b980:	68fb      	ldr	r3, [r7, #12]
 802b982:	681b      	ldr	r3, [r3, #0]
 802b984:	687a      	ldr	r2, [r7, #4]
 802b986:	60da      	str	r2, [r3, #12]
}
 802b988:	bf00      	nop
 802b98a:	3714      	adds	r7, #20
 802b98c:	46bd      	mov	sp, r7
 802b98e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b992:	4770      	bx	lr

0802b994 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 802b994:	b480      	push	{r7}
 802b996:	b085      	sub	sp, #20
 802b998:	af00      	add	r7, sp, #0
 802b99a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 802b99c:	687b      	ldr	r3, [r7, #4]
 802b99e:	681b      	ldr	r3, [r3, #0]
 802b9a0:	b2db      	uxtb	r3, r3
 802b9a2:	3b10      	subs	r3, #16
 802b9a4:	4a14      	ldr	r2, [pc, #80]	; (802b9f8 <DMA_CalcBaseAndBitshift+0x64>)
 802b9a6:	fba2 2303 	umull	r2, r3, r2, r3
 802b9aa:	091b      	lsrs	r3, r3, #4
 802b9ac:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 802b9ae:	4a13      	ldr	r2, [pc, #76]	; (802b9fc <DMA_CalcBaseAndBitshift+0x68>)
 802b9b0:	68fb      	ldr	r3, [r7, #12]
 802b9b2:	4413      	add	r3, r2
 802b9b4:	781b      	ldrb	r3, [r3, #0]
 802b9b6:	461a      	mov	r2, r3
 802b9b8:	687b      	ldr	r3, [r7, #4]
 802b9ba:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
 802b9bc:	68fb      	ldr	r3, [r7, #12]
 802b9be:	2b03      	cmp	r3, #3
 802b9c0:	d909      	bls.n	802b9d6 <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 802b9c2:	687b      	ldr	r3, [r7, #4]
 802b9c4:	681b      	ldr	r3, [r3, #0]
 802b9c6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 802b9ca:	f023 0303 	bic.w	r3, r3, #3
 802b9ce:	1d1a      	adds	r2, r3, #4
 802b9d0:	687b      	ldr	r3, [r7, #4]
 802b9d2:	659a      	str	r2, [r3, #88]	; 0x58
 802b9d4:	e007      	b.n	802b9e6 <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 802b9d6:	687b      	ldr	r3, [r7, #4]
 802b9d8:	681b      	ldr	r3, [r3, #0]
 802b9da:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 802b9de:	f023 0303 	bic.w	r3, r3, #3
 802b9e2:	687a      	ldr	r2, [r7, #4]
 802b9e4:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
 802b9e6:	687b      	ldr	r3, [r7, #4]
 802b9e8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
 802b9ea:	4618      	mov	r0, r3
 802b9ec:	3714      	adds	r7, #20
 802b9ee:	46bd      	mov	sp, r7
 802b9f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802b9f4:	4770      	bx	lr
 802b9f6:	bf00      	nop
 802b9f8:	aaaaaaab 	.word	0xaaaaaaab
 802b9fc:	08030178 	.word	0x08030178

0802ba00 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 802ba00:	b480      	push	{r7}
 802ba02:	b085      	sub	sp, #20
 802ba04:	af00      	add	r7, sp, #0
 802ba06:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 802ba08:	2300      	movs	r3, #0
 802ba0a:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 802ba0c:	687b      	ldr	r3, [r7, #4]
 802ba0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802ba10:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 802ba12:	687b      	ldr	r3, [r7, #4]
 802ba14:	699b      	ldr	r3, [r3, #24]
 802ba16:	2b00      	cmp	r3, #0
 802ba18:	d11f      	bne.n	802ba5a <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 802ba1a:	68bb      	ldr	r3, [r7, #8]
 802ba1c:	2b03      	cmp	r3, #3
 802ba1e:	d855      	bhi.n	802bacc <DMA_CheckFifoParam+0xcc>
 802ba20:	a201      	add	r2, pc, #4	; (adr r2, 802ba28 <DMA_CheckFifoParam+0x28>)
 802ba22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802ba26:	bf00      	nop
 802ba28:	0802ba39 	.word	0x0802ba39
 802ba2c:	0802ba4b 	.word	0x0802ba4b
 802ba30:	0802ba39 	.word	0x0802ba39
 802ba34:	0802bacd 	.word	0x0802bacd
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802ba38:	687b      	ldr	r3, [r7, #4]
 802ba3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802ba3c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 802ba40:	2b00      	cmp	r3, #0
 802ba42:	d045      	beq.n	802bad0 <DMA_CheckFifoParam+0xd0>
      {
        status = HAL_ERROR;
 802ba44:	2301      	movs	r3, #1
 802ba46:	73fb      	strb	r3, [r7, #15]
      }
      break;
 802ba48:	e042      	b.n	802bad0 <DMA_CheckFifoParam+0xd0>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 802ba4a:	687b      	ldr	r3, [r7, #4]
 802ba4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802ba4e:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 802ba52:	d13f      	bne.n	802bad4 <DMA_CheckFifoParam+0xd4>
      {
        status = HAL_ERROR;
 802ba54:	2301      	movs	r3, #1
 802ba56:	73fb      	strb	r3, [r7, #15]
      }
      break;
 802ba58:	e03c      	b.n	802bad4 <DMA_CheckFifoParam+0xd4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 802ba5a:	687b      	ldr	r3, [r7, #4]
 802ba5c:	699b      	ldr	r3, [r3, #24]
 802ba5e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 802ba62:	d121      	bne.n	802baa8 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 802ba64:	68bb      	ldr	r3, [r7, #8]
 802ba66:	2b03      	cmp	r3, #3
 802ba68:	d836      	bhi.n	802bad8 <DMA_CheckFifoParam+0xd8>
 802ba6a:	a201      	add	r2, pc, #4	; (adr r2, 802ba70 <DMA_CheckFifoParam+0x70>)
 802ba6c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802ba70:	0802ba81 	.word	0x0802ba81
 802ba74:	0802ba87 	.word	0x0802ba87
 802ba78:	0802ba81 	.word	0x0802ba81
 802ba7c:	0802ba99 	.word	0x0802ba99
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 802ba80:	2301      	movs	r3, #1
 802ba82:	73fb      	strb	r3, [r7, #15]
      break;
 802ba84:	e02f      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802ba86:	687b      	ldr	r3, [r7, #4]
 802ba88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802ba8a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 802ba8e:	2b00      	cmp	r3, #0
 802ba90:	d024      	beq.n	802badc <DMA_CheckFifoParam+0xdc>
      {
        status = HAL_ERROR;
 802ba92:	2301      	movs	r3, #1
 802ba94:	73fb      	strb	r3, [r7, #15]
      }
      break;
 802ba96:	e021      	b.n	802badc <DMA_CheckFifoParam+0xdc>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 802ba98:	687b      	ldr	r3, [r7, #4]
 802ba9a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802ba9c:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 802baa0:	d11e      	bne.n	802bae0 <DMA_CheckFifoParam+0xe0>
      {
        status = HAL_ERROR;
 802baa2:	2301      	movs	r3, #1
 802baa4:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 802baa6:	e01b      	b.n	802bae0 <DMA_CheckFifoParam+0xe0>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 802baa8:	68bb      	ldr	r3, [r7, #8]
 802baaa:	2b02      	cmp	r3, #2
 802baac:	d902      	bls.n	802bab4 <DMA_CheckFifoParam+0xb4>
 802baae:	2b03      	cmp	r3, #3
 802bab0:	d003      	beq.n	802baba <DMA_CheckFifoParam+0xba>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 802bab2:	e018      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      status = HAL_ERROR;
 802bab4:	2301      	movs	r3, #1
 802bab6:	73fb      	strb	r3, [r7, #15]
      break;
 802bab8:	e015      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 802baba:	687b      	ldr	r3, [r7, #4]
 802babc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802babe:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 802bac2:	2b00      	cmp	r3, #0
 802bac4:	d00e      	beq.n	802bae4 <DMA_CheckFifoParam+0xe4>
        status = HAL_ERROR;
 802bac6:	2301      	movs	r3, #1
 802bac8:	73fb      	strb	r3, [r7, #15]
      break;
 802baca:	e00b      	b.n	802bae4 <DMA_CheckFifoParam+0xe4>
      break;
 802bacc:	bf00      	nop
 802bace:	e00a      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      break;
 802bad0:	bf00      	nop
 802bad2:	e008      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      break;
 802bad4:	bf00      	nop
 802bad6:	e006      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      break;
 802bad8:	bf00      	nop
 802bada:	e004      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      break;
 802badc:	bf00      	nop
 802bade:	e002      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      break;   
 802bae0:	bf00      	nop
 802bae2:	e000      	b.n	802bae6 <DMA_CheckFifoParam+0xe6>
      break;
 802bae4:	bf00      	nop
    }
  } 
  
  return status; 
 802bae6:	7bfb      	ldrb	r3, [r7, #15]
}
 802bae8:	4618      	mov	r0, r3
 802baea:	3714      	adds	r7, #20
 802baec:	46bd      	mov	sp, r7
 802baee:	f85d 7b04 	ldr.w	r7, [sp], #4
 802baf2:	4770      	bx	lr

0802baf4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 802baf4:	b480      	push	{r7}
 802baf6:	b089      	sub	sp, #36	; 0x24
 802baf8:	af00      	add	r7, sp, #0
 802bafa:	6078      	str	r0, [r7, #4]
 802bafc:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 802bafe:	2300      	movs	r3, #0
 802bb00:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 802bb02:	2300      	movs	r3, #0
 802bb04:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 802bb06:	2300      	movs	r3, #0
 802bb08:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 802bb0a:	2300      	movs	r3, #0
 802bb0c:	61fb      	str	r3, [r7, #28]
 802bb0e:	e159      	b.n	802bdc4 <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 802bb10:	2201      	movs	r2, #1
 802bb12:	69fb      	ldr	r3, [r7, #28]
 802bb14:	fa02 f303 	lsl.w	r3, r2, r3
 802bb18:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 802bb1a:	683b      	ldr	r3, [r7, #0]
 802bb1c:	681b      	ldr	r3, [r3, #0]
 802bb1e:	697a      	ldr	r2, [r7, #20]
 802bb20:	4013      	ands	r3, r2
 802bb22:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 802bb24:	693a      	ldr	r2, [r7, #16]
 802bb26:	697b      	ldr	r3, [r7, #20]
 802bb28:	429a      	cmp	r2, r3
 802bb2a:	f040 8148 	bne.w	802bdbe <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 802bb2e:	683b      	ldr	r3, [r7, #0]
 802bb30:	685b      	ldr	r3, [r3, #4]
 802bb32:	2b01      	cmp	r3, #1
 802bb34:	d00b      	beq.n	802bb4e <HAL_GPIO_Init+0x5a>
 802bb36:	683b      	ldr	r3, [r7, #0]
 802bb38:	685b      	ldr	r3, [r3, #4]
 802bb3a:	2b02      	cmp	r3, #2
 802bb3c:	d007      	beq.n	802bb4e <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 802bb3e:	683b      	ldr	r3, [r7, #0]
 802bb40:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 802bb42:	2b11      	cmp	r3, #17
 802bb44:	d003      	beq.n	802bb4e <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 802bb46:	683b      	ldr	r3, [r7, #0]
 802bb48:	685b      	ldr	r3, [r3, #4]
 802bb4a:	2b12      	cmp	r3, #18
 802bb4c:	d130      	bne.n	802bbb0 <HAL_GPIO_Init+0xbc>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 802bb4e:	687b      	ldr	r3, [r7, #4]
 802bb50:	689b      	ldr	r3, [r3, #8]
 802bb52:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 802bb54:	69fb      	ldr	r3, [r7, #28]
 802bb56:	005b      	lsls	r3, r3, #1
 802bb58:	2203      	movs	r2, #3
 802bb5a:	fa02 f303 	lsl.w	r3, r2, r3
 802bb5e:	43db      	mvns	r3, r3
 802bb60:	69ba      	ldr	r2, [r7, #24]
 802bb62:	4013      	ands	r3, r2
 802bb64:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 802bb66:	683b      	ldr	r3, [r7, #0]
 802bb68:	68da      	ldr	r2, [r3, #12]
 802bb6a:	69fb      	ldr	r3, [r7, #28]
 802bb6c:	005b      	lsls	r3, r3, #1
 802bb6e:	fa02 f303 	lsl.w	r3, r2, r3
 802bb72:	69ba      	ldr	r2, [r7, #24]
 802bb74:	4313      	orrs	r3, r2
 802bb76:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 802bb78:	687b      	ldr	r3, [r7, #4]
 802bb7a:	69ba      	ldr	r2, [r7, #24]
 802bb7c:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 802bb7e:	687b      	ldr	r3, [r7, #4]
 802bb80:	685b      	ldr	r3, [r3, #4]
 802bb82:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 802bb84:	2201      	movs	r2, #1
 802bb86:	69fb      	ldr	r3, [r7, #28]
 802bb88:	fa02 f303 	lsl.w	r3, r2, r3
 802bb8c:	43db      	mvns	r3, r3
 802bb8e:	69ba      	ldr	r2, [r7, #24]
 802bb90:	4013      	ands	r3, r2
 802bb92:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 802bb94:	683b      	ldr	r3, [r7, #0]
 802bb96:	685b      	ldr	r3, [r3, #4]
 802bb98:	091b      	lsrs	r3, r3, #4
 802bb9a:	f003 0201 	and.w	r2, r3, #1
 802bb9e:	69fb      	ldr	r3, [r7, #28]
 802bba0:	fa02 f303 	lsl.w	r3, r2, r3
 802bba4:	69ba      	ldr	r2, [r7, #24]
 802bba6:	4313      	orrs	r3, r2
 802bba8:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 802bbaa:	687b      	ldr	r3, [r7, #4]
 802bbac:	69ba      	ldr	r2, [r7, #24]
 802bbae:	605a      	str	r2, [r3, #4]
       }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 802bbb0:	687b      	ldr	r3, [r7, #4]
 802bbb2:	68db      	ldr	r3, [r3, #12]
 802bbb4:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 802bbb6:	69fb      	ldr	r3, [r7, #28]
 802bbb8:	005b      	lsls	r3, r3, #1
 802bbba:	2203      	movs	r2, #3
 802bbbc:	fa02 f303 	lsl.w	r3, r2, r3
 802bbc0:	43db      	mvns	r3, r3
 802bbc2:	69ba      	ldr	r2, [r7, #24]
 802bbc4:	4013      	ands	r3, r2
 802bbc6:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 802bbc8:	683b      	ldr	r3, [r7, #0]
 802bbca:	689a      	ldr	r2, [r3, #8]
 802bbcc:	69fb      	ldr	r3, [r7, #28]
 802bbce:	005b      	lsls	r3, r3, #1
 802bbd0:	fa02 f303 	lsl.w	r3, r2, r3
 802bbd4:	69ba      	ldr	r2, [r7, #24]
 802bbd6:	4313      	orrs	r3, r2
 802bbd8:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 802bbda:	687b      	ldr	r3, [r7, #4]
 802bbdc:	69ba      	ldr	r2, [r7, #24]
 802bbde:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 802bbe0:	683b      	ldr	r3, [r7, #0]
 802bbe2:	685b      	ldr	r3, [r3, #4]
 802bbe4:	2b02      	cmp	r3, #2
 802bbe6:	d003      	beq.n	802bbf0 <HAL_GPIO_Init+0xfc>
 802bbe8:	683b      	ldr	r3, [r7, #0]
 802bbea:	685b      	ldr	r3, [r3, #4]
 802bbec:	2b12      	cmp	r3, #18
 802bbee:	d123      	bne.n	802bc38 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 802bbf0:	69fb      	ldr	r3, [r7, #28]
 802bbf2:	08da      	lsrs	r2, r3, #3
 802bbf4:	687b      	ldr	r3, [r7, #4]
 802bbf6:	3208      	adds	r2, #8
 802bbf8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802bbfc:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 802bbfe:	69fb      	ldr	r3, [r7, #28]
 802bc00:	f003 0307 	and.w	r3, r3, #7
 802bc04:	009b      	lsls	r3, r3, #2
 802bc06:	220f      	movs	r2, #15
 802bc08:	fa02 f303 	lsl.w	r3, r2, r3
 802bc0c:	43db      	mvns	r3, r3
 802bc0e:	69ba      	ldr	r2, [r7, #24]
 802bc10:	4013      	ands	r3, r2
 802bc12:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 802bc14:	683b      	ldr	r3, [r7, #0]
 802bc16:	691a      	ldr	r2, [r3, #16]
 802bc18:	69fb      	ldr	r3, [r7, #28]
 802bc1a:	f003 0307 	and.w	r3, r3, #7
 802bc1e:	009b      	lsls	r3, r3, #2
 802bc20:	fa02 f303 	lsl.w	r3, r2, r3
 802bc24:	69ba      	ldr	r2, [r7, #24]
 802bc26:	4313      	orrs	r3, r2
 802bc28:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 802bc2a:	69fb      	ldr	r3, [r7, #28]
 802bc2c:	08da      	lsrs	r2, r3, #3
 802bc2e:	687b      	ldr	r3, [r7, #4]
 802bc30:	3208      	adds	r2, #8
 802bc32:	69b9      	ldr	r1, [r7, #24]
 802bc34:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 802bc38:	687b      	ldr	r3, [r7, #4]
 802bc3a:	681b      	ldr	r3, [r3, #0]
 802bc3c:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 802bc3e:	69fb      	ldr	r3, [r7, #28]
 802bc40:	005b      	lsls	r3, r3, #1
 802bc42:	2203      	movs	r2, #3
 802bc44:	fa02 f303 	lsl.w	r3, r2, r3
 802bc48:	43db      	mvns	r3, r3
 802bc4a:	69ba      	ldr	r2, [r7, #24]
 802bc4c:	4013      	ands	r3, r2
 802bc4e:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 802bc50:	683b      	ldr	r3, [r7, #0]
 802bc52:	685b      	ldr	r3, [r3, #4]
 802bc54:	f003 0203 	and.w	r2, r3, #3
 802bc58:	69fb      	ldr	r3, [r7, #28]
 802bc5a:	005b      	lsls	r3, r3, #1
 802bc5c:	fa02 f303 	lsl.w	r3, r2, r3
 802bc60:	69ba      	ldr	r2, [r7, #24]
 802bc62:	4313      	orrs	r3, r2
 802bc64:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 802bc66:	687b      	ldr	r3, [r7, #4]
 802bc68:	69ba      	ldr	r2, [r7, #24]
 802bc6a:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 802bc6c:	683b      	ldr	r3, [r7, #0]
 802bc6e:	685b      	ldr	r3, [r3, #4]
 802bc70:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802bc74:	2b00      	cmp	r3, #0
 802bc76:	f000 80a2 	beq.w	802bdbe <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 802bc7a:	2300      	movs	r3, #0
 802bc7c:	60fb      	str	r3, [r7, #12]
 802bc7e:	4b56      	ldr	r3, [pc, #344]	; (802bdd8 <HAL_GPIO_Init+0x2e4>)
 802bc80:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802bc82:	4a55      	ldr	r2, [pc, #340]	; (802bdd8 <HAL_GPIO_Init+0x2e4>)
 802bc84:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 802bc88:	6453      	str	r3, [r2, #68]	; 0x44
 802bc8a:	4b53      	ldr	r3, [pc, #332]	; (802bdd8 <HAL_GPIO_Init+0x2e4>)
 802bc8c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 802bc8e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 802bc92:	60fb      	str	r3, [r7, #12]
 802bc94:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 802bc96:	4a51      	ldr	r2, [pc, #324]	; (802bddc <HAL_GPIO_Init+0x2e8>)
 802bc98:	69fb      	ldr	r3, [r7, #28]
 802bc9a:	089b      	lsrs	r3, r3, #2
 802bc9c:	3302      	adds	r3, #2
 802bc9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 802bca2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 802bca4:	69fb      	ldr	r3, [r7, #28]
 802bca6:	f003 0303 	and.w	r3, r3, #3
 802bcaa:	009b      	lsls	r3, r3, #2
 802bcac:	220f      	movs	r2, #15
 802bcae:	fa02 f303 	lsl.w	r3, r2, r3
 802bcb2:	43db      	mvns	r3, r3
 802bcb4:	69ba      	ldr	r2, [r7, #24]
 802bcb6:	4013      	ands	r3, r2
 802bcb8:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 802bcba:	687b      	ldr	r3, [r7, #4]
 802bcbc:	4a48      	ldr	r2, [pc, #288]	; (802bde0 <HAL_GPIO_Init+0x2ec>)
 802bcbe:	4293      	cmp	r3, r2
 802bcc0:	d019      	beq.n	802bcf6 <HAL_GPIO_Init+0x202>
 802bcc2:	687b      	ldr	r3, [r7, #4]
 802bcc4:	4a47      	ldr	r2, [pc, #284]	; (802bde4 <HAL_GPIO_Init+0x2f0>)
 802bcc6:	4293      	cmp	r3, r2
 802bcc8:	d013      	beq.n	802bcf2 <HAL_GPIO_Init+0x1fe>
 802bcca:	687b      	ldr	r3, [r7, #4]
 802bccc:	4a46      	ldr	r2, [pc, #280]	; (802bde8 <HAL_GPIO_Init+0x2f4>)
 802bcce:	4293      	cmp	r3, r2
 802bcd0:	d00d      	beq.n	802bcee <HAL_GPIO_Init+0x1fa>
 802bcd2:	687b      	ldr	r3, [r7, #4]
 802bcd4:	4a45      	ldr	r2, [pc, #276]	; (802bdec <HAL_GPIO_Init+0x2f8>)
 802bcd6:	4293      	cmp	r3, r2
 802bcd8:	d007      	beq.n	802bcea <HAL_GPIO_Init+0x1f6>
 802bcda:	687b      	ldr	r3, [r7, #4]
 802bcdc:	4a44      	ldr	r2, [pc, #272]	; (802bdf0 <HAL_GPIO_Init+0x2fc>)
 802bcde:	4293      	cmp	r3, r2
 802bce0:	d101      	bne.n	802bce6 <HAL_GPIO_Init+0x1f2>
 802bce2:	2304      	movs	r3, #4
 802bce4:	e008      	b.n	802bcf8 <HAL_GPIO_Init+0x204>
 802bce6:	2307      	movs	r3, #7
 802bce8:	e006      	b.n	802bcf8 <HAL_GPIO_Init+0x204>
 802bcea:	2303      	movs	r3, #3
 802bcec:	e004      	b.n	802bcf8 <HAL_GPIO_Init+0x204>
 802bcee:	2302      	movs	r3, #2
 802bcf0:	e002      	b.n	802bcf8 <HAL_GPIO_Init+0x204>
 802bcf2:	2301      	movs	r3, #1
 802bcf4:	e000      	b.n	802bcf8 <HAL_GPIO_Init+0x204>
 802bcf6:	2300      	movs	r3, #0
 802bcf8:	69fa      	ldr	r2, [r7, #28]
 802bcfa:	f002 0203 	and.w	r2, r2, #3
 802bcfe:	0092      	lsls	r2, r2, #2
 802bd00:	4093      	lsls	r3, r2
 802bd02:	69ba      	ldr	r2, [r7, #24]
 802bd04:	4313      	orrs	r3, r2
 802bd06:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 802bd08:	4934      	ldr	r1, [pc, #208]	; (802bddc <HAL_GPIO_Init+0x2e8>)
 802bd0a:	69fb      	ldr	r3, [r7, #28]
 802bd0c:	089b      	lsrs	r3, r3, #2
 802bd0e:	3302      	adds	r3, #2
 802bd10:	69ba      	ldr	r2, [r7, #24]
 802bd12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 802bd16:	4b37      	ldr	r3, [pc, #220]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd18:	681b      	ldr	r3, [r3, #0]
 802bd1a:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802bd1c:	693b      	ldr	r3, [r7, #16]
 802bd1e:	43db      	mvns	r3, r3
 802bd20:	69ba      	ldr	r2, [r7, #24]
 802bd22:	4013      	ands	r3, r2
 802bd24:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 802bd26:	683b      	ldr	r3, [r7, #0]
 802bd28:	685b      	ldr	r3, [r3, #4]
 802bd2a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 802bd2e:	2b00      	cmp	r3, #0
 802bd30:	d003      	beq.n	802bd3a <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 802bd32:	69ba      	ldr	r2, [r7, #24]
 802bd34:	693b      	ldr	r3, [r7, #16]
 802bd36:	4313      	orrs	r3, r2
 802bd38:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 802bd3a:	4a2e      	ldr	r2, [pc, #184]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd3c:	69bb      	ldr	r3, [r7, #24]
 802bd3e:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 802bd40:	4b2c      	ldr	r3, [pc, #176]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd42:	685b      	ldr	r3, [r3, #4]
 802bd44:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802bd46:	693b      	ldr	r3, [r7, #16]
 802bd48:	43db      	mvns	r3, r3
 802bd4a:	69ba      	ldr	r2, [r7, #24]
 802bd4c:	4013      	ands	r3, r2
 802bd4e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 802bd50:	683b      	ldr	r3, [r7, #0]
 802bd52:	685b      	ldr	r3, [r3, #4]
 802bd54:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802bd58:	2b00      	cmp	r3, #0
 802bd5a:	d003      	beq.n	802bd64 <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 802bd5c:	69ba      	ldr	r2, [r7, #24]
 802bd5e:	693b      	ldr	r3, [r7, #16]
 802bd60:	4313      	orrs	r3, r2
 802bd62:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 802bd64:	4a23      	ldr	r2, [pc, #140]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd66:	69bb      	ldr	r3, [r7, #24]
 802bd68:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 802bd6a:	4b22      	ldr	r3, [pc, #136]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd6c:	689b      	ldr	r3, [r3, #8]
 802bd6e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802bd70:	693b      	ldr	r3, [r7, #16]
 802bd72:	43db      	mvns	r3, r3
 802bd74:	69ba      	ldr	r2, [r7, #24]
 802bd76:	4013      	ands	r3, r2
 802bd78:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 802bd7a:	683b      	ldr	r3, [r7, #0]
 802bd7c:	685b      	ldr	r3, [r3, #4]
 802bd7e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 802bd82:	2b00      	cmp	r3, #0
 802bd84:	d003      	beq.n	802bd8e <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 802bd86:	69ba      	ldr	r2, [r7, #24]
 802bd88:	693b      	ldr	r3, [r7, #16]
 802bd8a:	4313      	orrs	r3, r2
 802bd8c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 802bd8e:	4a19      	ldr	r2, [pc, #100]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd90:	69bb      	ldr	r3, [r7, #24]
 802bd92:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 802bd94:	4b17      	ldr	r3, [pc, #92]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bd96:	68db      	ldr	r3, [r3, #12]
 802bd98:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 802bd9a:	693b      	ldr	r3, [r7, #16]
 802bd9c:	43db      	mvns	r3, r3
 802bd9e:	69ba      	ldr	r2, [r7, #24]
 802bda0:	4013      	ands	r3, r2
 802bda2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 802bda4:	683b      	ldr	r3, [r7, #0]
 802bda6:	685b      	ldr	r3, [r3, #4]
 802bda8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 802bdac:	2b00      	cmp	r3, #0
 802bdae:	d003      	beq.n	802bdb8 <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 802bdb0:	69ba      	ldr	r2, [r7, #24]
 802bdb2:	693b      	ldr	r3, [r7, #16]
 802bdb4:	4313      	orrs	r3, r2
 802bdb6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 802bdb8:	4a0e      	ldr	r2, [pc, #56]	; (802bdf4 <HAL_GPIO_Init+0x300>)
 802bdba:	69bb      	ldr	r3, [r7, #24]
 802bdbc:	60d3      	str	r3, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 802bdbe:	69fb      	ldr	r3, [r7, #28]
 802bdc0:	3301      	adds	r3, #1
 802bdc2:	61fb      	str	r3, [r7, #28]
 802bdc4:	69fb      	ldr	r3, [r7, #28]
 802bdc6:	2b0f      	cmp	r3, #15
 802bdc8:	f67f aea2 	bls.w	802bb10 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 802bdcc:	bf00      	nop
 802bdce:	3724      	adds	r7, #36	; 0x24
 802bdd0:	46bd      	mov	sp, r7
 802bdd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802bdd6:	4770      	bx	lr
 802bdd8:	40023800 	.word	0x40023800
 802bddc:	40013800 	.word	0x40013800
 802bde0:	40020000 	.word	0x40020000
 802bde4:	40020400 	.word	0x40020400
 802bde8:	40020800 	.word	0x40020800
 802bdec:	40020c00 	.word	0x40020c00
 802bdf0:	40021000 	.word	0x40021000
 802bdf4:	40013c00 	.word	0x40013c00

0802bdf8 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 802bdf8:	b480      	push	{r7}
 802bdfa:	b085      	sub	sp, #20
 802bdfc:	af00      	add	r7, sp, #0
 802bdfe:	6078      	str	r0, [r7, #4]
 802be00:	460b      	mov	r3, r1
 802be02:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 802be04:	687b      	ldr	r3, [r7, #4]
 802be06:	691a      	ldr	r2, [r3, #16]
 802be08:	887b      	ldrh	r3, [r7, #2]
 802be0a:	4013      	ands	r3, r2
 802be0c:	2b00      	cmp	r3, #0
 802be0e:	d002      	beq.n	802be16 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 802be10:	2301      	movs	r3, #1
 802be12:	73fb      	strb	r3, [r7, #15]
 802be14:	e001      	b.n	802be1a <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 802be16:	2300      	movs	r3, #0
 802be18:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 802be1a:	7bfb      	ldrb	r3, [r7, #15]
}
 802be1c:	4618      	mov	r0, r3
 802be1e:	3714      	adds	r7, #20
 802be20:	46bd      	mov	sp, r7
 802be22:	f85d 7b04 	ldr.w	r7, [sp], #4
 802be26:	4770      	bx	lr

0802be28 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 802be28:	b480      	push	{r7}
 802be2a:	b083      	sub	sp, #12
 802be2c:	af00      	add	r7, sp, #0
 802be2e:	6078      	str	r0, [r7, #4]
 802be30:	460b      	mov	r3, r1
 802be32:	807b      	strh	r3, [r7, #2]
 802be34:	4613      	mov	r3, r2
 802be36:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 802be38:	787b      	ldrb	r3, [r7, #1]
 802be3a:	2b00      	cmp	r3, #0
 802be3c:	d003      	beq.n	802be46 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 802be3e:	887a      	ldrh	r2, [r7, #2]
 802be40:	687b      	ldr	r3, [r7, #4]
 802be42:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 802be44:	e003      	b.n	802be4e <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 802be46:	887b      	ldrh	r3, [r7, #2]
 802be48:	041a      	lsls	r2, r3, #16
 802be4a:	687b      	ldr	r3, [r7, #4]
 802be4c:	619a      	str	r2, [r3, #24]
}
 802be4e:	bf00      	nop
 802be50:	370c      	adds	r7, #12
 802be52:	46bd      	mov	sp, r7
 802be54:	f85d 7b04 	ldr.w	r7, [sp], #4
 802be58:	4770      	bx	lr
	...

0802be5c <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 802be5c:	b580      	push	{r7, lr}
 802be5e:	b086      	sub	sp, #24
 802be60:	af00      	add	r7, sp, #0
 802be62:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 802be64:	687b      	ldr	r3, [r7, #4]
 802be66:	2b00      	cmp	r3, #0
 802be68:	d101      	bne.n	802be6e <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 802be6a:	2301      	movs	r3, #1
 802be6c:	e25b      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 802be6e:	687b      	ldr	r3, [r7, #4]
 802be70:	681b      	ldr	r3, [r3, #0]
 802be72:	f003 0301 	and.w	r3, r3, #1
 802be76:	2b00      	cmp	r3, #0
 802be78:	d075      	beq.n	802bf66 <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 802be7a:	4ba3      	ldr	r3, [pc, #652]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802be7c:	689b      	ldr	r3, [r3, #8]
 802be7e:	f003 030c 	and.w	r3, r3, #12
 802be82:	2b04      	cmp	r3, #4
 802be84:	d00c      	beq.n	802bea0 <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 802be86:	4ba0      	ldr	r3, [pc, #640]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802be88:	689b      	ldr	r3, [r3, #8]
 802be8a:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 802be8e:	2b08      	cmp	r3, #8
 802be90:	d112      	bne.n	802beb8 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 802be92:	4b9d      	ldr	r3, [pc, #628]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802be94:	685b      	ldr	r3, [r3, #4]
 802be96:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802be9a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 802be9e:	d10b      	bne.n	802beb8 <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802bea0:	4b99      	ldr	r3, [pc, #612]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bea2:	681b      	ldr	r3, [r3, #0]
 802bea4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802bea8:	2b00      	cmp	r3, #0
 802beaa:	d05b      	beq.n	802bf64 <HAL_RCC_OscConfig+0x108>
 802beac:	687b      	ldr	r3, [r7, #4]
 802beae:	685b      	ldr	r3, [r3, #4]
 802beb0:	2b00      	cmp	r3, #0
 802beb2:	d157      	bne.n	802bf64 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 802beb4:	2301      	movs	r3, #1
 802beb6:	e236      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 802beb8:	687b      	ldr	r3, [r7, #4]
 802beba:	685b      	ldr	r3, [r3, #4]
 802bebc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 802bec0:	d106      	bne.n	802bed0 <HAL_RCC_OscConfig+0x74>
 802bec2:	4b91      	ldr	r3, [pc, #580]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bec4:	681b      	ldr	r3, [r3, #0]
 802bec6:	4a90      	ldr	r2, [pc, #576]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bec8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802becc:	6013      	str	r3, [r2, #0]
 802bece:	e01d      	b.n	802bf0c <HAL_RCC_OscConfig+0xb0>
 802bed0:	687b      	ldr	r3, [r7, #4]
 802bed2:	685b      	ldr	r3, [r3, #4]
 802bed4:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 802bed8:	d10c      	bne.n	802bef4 <HAL_RCC_OscConfig+0x98>
 802beda:	4b8b      	ldr	r3, [pc, #556]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bedc:	681b      	ldr	r3, [r3, #0]
 802bede:	4a8a      	ldr	r2, [pc, #552]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bee0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 802bee4:	6013      	str	r3, [r2, #0]
 802bee6:	4b88      	ldr	r3, [pc, #544]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bee8:	681b      	ldr	r3, [r3, #0]
 802beea:	4a87      	ldr	r2, [pc, #540]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802beec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 802bef0:	6013      	str	r3, [r2, #0]
 802bef2:	e00b      	b.n	802bf0c <HAL_RCC_OscConfig+0xb0>
 802bef4:	4b84      	ldr	r3, [pc, #528]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bef6:	681b      	ldr	r3, [r3, #0]
 802bef8:	4a83      	ldr	r2, [pc, #524]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802befa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 802befe:	6013      	str	r3, [r2, #0]
 802bf00:	4b81      	ldr	r3, [pc, #516]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf02:	681b      	ldr	r3, [r3, #0]
 802bf04:	4a80      	ldr	r2, [pc, #512]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf06:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 802bf0a:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 802bf0c:	687b      	ldr	r3, [r7, #4]
 802bf0e:	685b      	ldr	r3, [r3, #4]
 802bf10:	2b00      	cmp	r3, #0
 802bf12:	d013      	beq.n	802bf3c <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802bf14:	f7ff f91e 	bl	802b154 <HAL_GetTick>
 802bf18:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802bf1a:	e008      	b.n	802bf2e <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 802bf1c:	f7ff f91a 	bl	802b154 <HAL_GetTick>
 802bf20:	4602      	mov	r2, r0
 802bf22:	693b      	ldr	r3, [r7, #16]
 802bf24:	1ad3      	subs	r3, r2, r3
 802bf26:	2b64      	cmp	r3, #100	; 0x64
 802bf28:	d901      	bls.n	802bf2e <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 802bf2a:	2303      	movs	r3, #3
 802bf2c:	e1fb      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802bf2e:	4b76      	ldr	r3, [pc, #472]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf30:	681b      	ldr	r3, [r3, #0]
 802bf32:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802bf36:	2b00      	cmp	r3, #0
 802bf38:	d0f0      	beq.n	802bf1c <HAL_RCC_OscConfig+0xc0>
 802bf3a:	e014      	b.n	802bf66 <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802bf3c:	f7ff f90a 	bl	802b154 <HAL_GetTick>
 802bf40:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 802bf42:	e008      	b.n	802bf56 <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 802bf44:	f7ff f906 	bl	802b154 <HAL_GetTick>
 802bf48:	4602      	mov	r2, r0
 802bf4a:	693b      	ldr	r3, [r7, #16]
 802bf4c:	1ad3      	subs	r3, r2, r3
 802bf4e:	2b64      	cmp	r3, #100	; 0x64
 802bf50:	d901      	bls.n	802bf56 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 802bf52:	2303      	movs	r3, #3
 802bf54:	e1e7      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 802bf56:	4b6c      	ldr	r3, [pc, #432]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf58:	681b      	ldr	r3, [r3, #0]
 802bf5a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802bf5e:	2b00      	cmp	r3, #0
 802bf60:	d1f0      	bne.n	802bf44 <HAL_RCC_OscConfig+0xe8>
 802bf62:	e000      	b.n	802bf66 <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 802bf64:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 802bf66:	687b      	ldr	r3, [r7, #4]
 802bf68:	681b      	ldr	r3, [r3, #0]
 802bf6a:	f003 0302 	and.w	r3, r3, #2
 802bf6e:	2b00      	cmp	r3, #0
 802bf70:	d063      	beq.n	802c03a <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 802bf72:	4b65      	ldr	r3, [pc, #404]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf74:	689b      	ldr	r3, [r3, #8]
 802bf76:	f003 030c 	and.w	r3, r3, #12
 802bf7a:	2b00      	cmp	r3, #0
 802bf7c:	d00b      	beq.n	802bf96 <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 802bf7e:	4b62      	ldr	r3, [pc, #392]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf80:	689b      	ldr	r3, [r3, #8]
 802bf82:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 802bf86:	2b08      	cmp	r3, #8
 802bf88:	d11c      	bne.n	802bfc4 <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 802bf8a:	4b5f      	ldr	r3, [pc, #380]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf8c:	685b      	ldr	r3, [r3, #4]
 802bf8e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802bf92:	2b00      	cmp	r3, #0
 802bf94:	d116      	bne.n	802bfc4 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 802bf96:	4b5c      	ldr	r3, [pc, #368]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bf98:	681b      	ldr	r3, [r3, #0]
 802bf9a:	f003 0302 	and.w	r3, r3, #2
 802bf9e:	2b00      	cmp	r3, #0
 802bfa0:	d005      	beq.n	802bfae <HAL_RCC_OscConfig+0x152>
 802bfa2:	687b      	ldr	r3, [r7, #4]
 802bfa4:	68db      	ldr	r3, [r3, #12]
 802bfa6:	2b01      	cmp	r3, #1
 802bfa8:	d001      	beq.n	802bfae <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 802bfaa:	2301      	movs	r3, #1
 802bfac:	e1bb      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 802bfae:	4b56      	ldr	r3, [pc, #344]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bfb0:	681b      	ldr	r3, [r3, #0]
 802bfb2:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 802bfb6:	687b      	ldr	r3, [r7, #4]
 802bfb8:	691b      	ldr	r3, [r3, #16]
 802bfba:	00db      	lsls	r3, r3, #3
 802bfbc:	4952      	ldr	r1, [pc, #328]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bfbe:	4313      	orrs	r3, r2
 802bfc0:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 802bfc2:	e03a      	b.n	802c03a <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 802bfc4:	687b      	ldr	r3, [r7, #4]
 802bfc6:	68db      	ldr	r3, [r3, #12]
 802bfc8:	2b00      	cmp	r3, #0
 802bfca:	d020      	beq.n	802c00e <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 802bfcc:	4b4f      	ldr	r3, [pc, #316]	; (802c10c <HAL_RCC_OscConfig+0x2b0>)
 802bfce:	2201      	movs	r2, #1
 802bfd0:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 802bfd2:	f7ff f8bf 	bl	802b154 <HAL_GetTick>
 802bfd6:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802bfd8:	e008      	b.n	802bfec <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 802bfda:	f7ff f8bb 	bl	802b154 <HAL_GetTick>
 802bfde:	4602      	mov	r2, r0
 802bfe0:	693b      	ldr	r3, [r7, #16]
 802bfe2:	1ad3      	subs	r3, r2, r3
 802bfe4:	2b02      	cmp	r3, #2
 802bfe6:	d901      	bls.n	802bfec <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 802bfe8:	2303      	movs	r3, #3
 802bfea:	e19c      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802bfec:	4b46      	ldr	r3, [pc, #280]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bfee:	681b      	ldr	r3, [r3, #0]
 802bff0:	f003 0302 	and.w	r3, r3, #2
 802bff4:	2b00      	cmp	r3, #0
 802bff6:	d0f0      	beq.n	802bfda <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 802bff8:	4b43      	ldr	r3, [pc, #268]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802bffa:	681b      	ldr	r3, [r3, #0]
 802bffc:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 802c000:	687b      	ldr	r3, [r7, #4]
 802c002:	691b      	ldr	r3, [r3, #16]
 802c004:	00db      	lsls	r3, r3, #3
 802c006:	4940      	ldr	r1, [pc, #256]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c008:	4313      	orrs	r3, r2
 802c00a:	600b      	str	r3, [r1, #0]
 802c00c:	e015      	b.n	802c03a <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 802c00e:	4b3f      	ldr	r3, [pc, #252]	; (802c10c <HAL_RCC_OscConfig+0x2b0>)
 802c010:	2200      	movs	r2, #0
 802c012:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 802c014:	f7ff f89e 	bl	802b154 <HAL_GetTick>
 802c018:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 802c01a:	e008      	b.n	802c02e <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 802c01c:	f7ff f89a 	bl	802b154 <HAL_GetTick>
 802c020:	4602      	mov	r2, r0
 802c022:	693b      	ldr	r3, [r7, #16]
 802c024:	1ad3      	subs	r3, r2, r3
 802c026:	2b02      	cmp	r3, #2
 802c028:	d901      	bls.n	802c02e <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 802c02a:	2303      	movs	r3, #3
 802c02c:	e17b      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 802c02e:	4b36      	ldr	r3, [pc, #216]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c030:	681b      	ldr	r3, [r3, #0]
 802c032:	f003 0302 	and.w	r3, r3, #2
 802c036:	2b00      	cmp	r3, #0
 802c038:	d1f0      	bne.n	802c01c <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 802c03a:	687b      	ldr	r3, [r7, #4]
 802c03c:	681b      	ldr	r3, [r3, #0]
 802c03e:	f003 0308 	and.w	r3, r3, #8
 802c042:	2b00      	cmp	r3, #0
 802c044:	d030      	beq.n	802c0a8 <HAL_RCC_OscConfig+0x24c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 802c046:	687b      	ldr	r3, [r7, #4]
 802c048:	695b      	ldr	r3, [r3, #20]
 802c04a:	2b00      	cmp	r3, #0
 802c04c:	d016      	beq.n	802c07c <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 802c04e:	4b30      	ldr	r3, [pc, #192]	; (802c110 <HAL_RCC_OscConfig+0x2b4>)
 802c050:	2201      	movs	r2, #1
 802c052:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 802c054:	f7ff f87e 	bl	802b154 <HAL_GetTick>
 802c058:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802c05a:	e008      	b.n	802c06e <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 802c05c:	f7ff f87a 	bl	802b154 <HAL_GetTick>
 802c060:	4602      	mov	r2, r0
 802c062:	693b      	ldr	r3, [r7, #16]
 802c064:	1ad3      	subs	r3, r2, r3
 802c066:	2b02      	cmp	r3, #2
 802c068:	d901      	bls.n	802c06e <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 802c06a:	2303      	movs	r3, #3
 802c06c:	e15b      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 802c06e:	4b26      	ldr	r3, [pc, #152]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c070:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 802c072:	f003 0302 	and.w	r3, r3, #2
 802c076:	2b00      	cmp	r3, #0
 802c078:	d0f0      	beq.n	802c05c <HAL_RCC_OscConfig+0x200>
 802c07a:	e015      	b.n	802c0a8 <HAL_RCC_OscConfig+0x24c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 802c07c:	4b24      	ldr	r3, [pc, #144]	; (802c110 <HAL_RCC_OscConfig+0x2b4>)
 802c07e:	2200      	movs	r2, #0
 802c080:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 802c082:	f7ff f867 	bl	802b154 <HAL_GetTick>
 802c086:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 802c088:	e008      	b.n	802c09c <HAL_RCC_OscConfig+0x240>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 802c08a:	f7ff f863 	bl	802b154 <HAL_GetTick>
 802c08e:	4602      	mov	r2, r0
 802c090:	693b      	ldr	r3, [r7, #16]
 802c092:	1ad3      	subs	r3, r2, r3
 802c094:	2b02      	cmp	r3, #2
 802c096:	d901      	bls.n	802c09c <HAL_RCC_OscConfig+0x240>
        {
          return HAL_TIMEOUT;
 802c098:	2303      	movs	r3, #3
 802c09a:	e144      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 802c09c:	4b1a      	ldr	r3, [pc, #104]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c09e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 802c0a0:	f003 0302 	and.w	r3, r3, #2
 802c0a4:	2b00      	cmp	r3, #0
 802c0a6:	d1f0      	bne.n	802c08a <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 802c0a8:	687b      	ldr	r3, [r7, #4]
 802c0aa:	681b      	ldr	r3, [r3, #0]
 802c0ac:	f003 0304 	and.w	r3, r3, #4
 802c0b0:	2b00      	cmp	r3, #0
 802c0b2:	f000 80a0 	beq.w	802c1f6 <HAL_RCC_OscConfig+0x39a>
  {
    FlagStatus       pwrclkchanged = RESET;
 802c0b6:	2300      	movs	r3, #0
 802c0b8:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 802c0ba:	4b13      	ldr	r3, [pc, #76]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c0bc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c0be:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802c0c2:	2b00      	cmp	r3, #0
 802c0c4:	d10f      	bne.n	802c0e6 <HAL_RCC_OscConfig+0x28a>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 802c0c6:	2300      	movs	r3, #0
 802c0c8:	60bb      	str	r3, [r7, #8]
 802c0ca:	4b0f      	ldr	r3, [pc, #60]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c0cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c0ce:	4a0e      	ldr	r2, [pc, #56]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c0d0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 802c0d4:	6413      	str	r3, [r2, #64]	; 0x40
 802c0d6:	4b0c      	ldr	r3, [pc, #48]	; (802c108 <HAL_RCC_OscConfig+0x2ac>)
 802c0d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c0da:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 802c0de:	60bb      	str	r3, [r7, #8]
 802c0e0:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 802c0e2:	2301      	movs	r3, #1
 802c0e4:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 802c0e6:	4b0b      	ldr	r3, [pc, #44]	; (802c114 <HAL_RCC_OscConfig+0x2b8>)
 802c0e8:	681b      	ldr	r3, [r3, #0]
 802c0ea:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802c0ee:	2b00      	cmp	r3, #0
 802c0f0:	d121      	bne.n	802c136 <HAL_RCC_OscConfig+0x2da>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 802c0f2:	4b08      	ldr	r3, [pc, #32]	; (802c114 <HAL_RCC_OscConfig+0x2b8>)
 802c0f4:	681b      	ldr	r3, [r3, #0]
 802c0f6:	4a07      	ldr	r2, [pc, #28]	; (802c114 <HAL_RCC_OscConfig+0x2b8>)
 802c0f8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802c0fc:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 802c0fe:	f7ff f829 	bl	802b154 <HAL_GetTick>
 802c102:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 802c104:	e011      	b.n	802c12a <HAL_RCC_OscConfig+0x2ce>
 802c106:	bf00      	nop
 802c108:	40023800 	.word	0x40023800
 802c10c:	42470000 	.word	0x42470000
 802c110:	42470e80 	.word	0x42470e80
 802c114:	40007000 	.word	0x40007000
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 802c118:	f7ff f81c 	bl	802b154 <HAL_GetTick>
 802c11c:	4602      	mov	r2, r0
 802c11e:	693b      	ldr	r3, [r7, #16]
 802c120:	1ad3      	subs	r3, r2, r3
 802c122:	2b02      	cmp	r3, #2
 802c124:	d901      	bls.n	802c12a <HAL_RCC_OscConfig+0x2ce>
        {
          return HAL_TIMEOUT;
 802c126:	2303      	movs	r3, #3
 802c128:	e0fd      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 802c12a:	4b81      	ldr	r3, [pc, #516]	; (802c330 <HAL_RCC_OscConfig+0x4d4>)
 802c12c:	681b      	ldr	r3, [r3, #0]
 802c12e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802c132:	2b00      	cmp	r3, #0
 802c134:	d0f0      	beq.n	802c118 <HAL_RCC_OscConfig+0x2bc>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 802c136:	687b      	ldr	r3, [r7, #4]
 802c138:	689b      	ldr	r3, [r3, #8]
 802c13a:	2b01      	cmp	r3, #1
 802c13c:	d106      	bne.n	802c14c <HAL_RCC_OscConfig+0x2f0>
 802c13e:	4b7d      	ldr	r3, [pc, #500]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c140:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c142:	4a7c      	ldr	r2, [pc, #496]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c144:	f043 0301 	orr.w	r3, r3, #1
 802c148:	6713      	str	r3, [r2, #112]	; 0x70
 802c14a:	e01c      	b.n	802c186 <HAL_RCC_OscConfig+0x32a>
 802c14c:	687b      	ldr	r3, [r7, #4]
 802c14e:	689b      	ldr	r3, [r3, #8]
 802c150:	2b05      	cmp	r3, #5
 802c152:	d10c      	bne.n	802c16e <HAL_RCC_OscConfig+0x312>
 802c154:	4b77      	ldr	r3, [pc, #476]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c156:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c158:	4a76      	ldr	r2, [pc, #472]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c15a:	f043 0304 	orr.w	r3, r3, #4
 802c15e:	6713      	str	r3, [r2, #112]	; 0x70
 802c160:	4b74      	ldr	r3, [pc, #464]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c162:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c164:	4a73      	ldr	r2, [pc, #460]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c166:	f043 0301 	orr.w	r3, r3, #1
 802c16a:	6713      	str	r3, [r2, #112]	; 0x70
 802c16c:	e00b      	b.n	802c186 <HAL_RCC_OscConfig+0x32a>
 802c16e:	4b71      	ldr	r3, [pc, #452]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c170:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c172:	4a70      	ldr	r2, [pc, #448]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c174:	f023 0301 	bic.w	r3, r3, #1
 802c178:	6713      	str	r3, [r2, #112]	; 0x70
 802c17a:	4b6e      	ldr	r3, [pc, #440]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c17c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c17e:	4a6d      	ldr	r2, [pc, #436]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c180:	f023 0304 	bic.w	r3, r3, #4
 802c184:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 802c186:	687b      	ldr	r3, [r7, #4]
 802c188:	689b      	ldr	r3, [r3, #8]
 802c18a:	2b00      	cmp	r3, #0
 802c18c:	d015      	beq.n	802c1ba <HAL_RCC_OscConfig+0x35e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 802c18e:	f7fe ffe1 	bl	802b154 <HAL_GetTick>
 802c192:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 802c194:	e00a      	b.n	802c1ac <HAL_RCC_OscConfig+0x350>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 802c196:	f7fe ffdd 	bl	802b154 <HAL_GetTick>
 802c19a:	4602      	mov	r2, r0
 802c19c:	693b      	ldr	r3, [r7, #16]
 802c19e:	1ad3      	subs	r3, r2, r3
 802c1a0:	f241 3288 	movw	r2, #5000	; 0x1388
 802c1a4:	4293      	cmp	r3, r2
 802c1a6:	d901      	bls.n	802c1ac <HAL_RCC_OscConfig+0x350>
        {
          return HAL_TIMEOUT;
 802c1a8:	2303      	movs	r3, #3
 802c1aa:	e0bc      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 802c1ac:	4b61      	ldr	r3, [pc, #388]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c1ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c1b0:	f003 0302 	and.w	r3, r3, #2
 802c1b4:	2b00      	cmp	r3, #0
 802c1b6:	d0ee      	beq.n	802c196 <HAL_RCC_OscConfig+0x33a>
 802c1b8:	e014      	b.n	802c1e4 <HAL_RCC_OscConfig+0x388>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 802c1ba:	f7fe ffcb 	bl	802b154 <HAL_GetTick>
 802c1be:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 802c1c0:	e00a      	b.n	802c1d8 <HAL_RCC_OscConfig+0x37c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 802c1c2:	f7fe ffc7 	bl	802b154 <HAL_GetTick>
 802c1c6:	4602      	mov	r2, r0
 802c1c8:	693b      	ldr	r3, [r7, #16]
 802c1ca:	1ad3      	subs	r3, r2, r3
 802c1cc:	f241 3288 	movw	r2, #5000	; 0x1388
 802c1d0:	4293      	cmp	r3, r2
 802c1d2:	d901      	bls.n	802c1d8 <HAL_RCC_OscConfig+0x37c>
        {
          return HAL_TIMEOUT;
 802c1d4:	2303      	movs	r3, #3
 802c1d6:	e0a6      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 802c1d8:	4b56      	ldr	r3, [pc, #344]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c1da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802c1dc:	f003 0302 	and.w	r3, r3, #2
 802c1e0:	2b00      	cmp	r3, #0
 802c1e2:	d1ee      	bne.n	802c1c2 <HAL_RCC_OscConfig+0x366>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 802c1e4:	7dfb      	ldrb	r3, [r7, #23]
 802c1e6:	2b01      	cmp	r3, #1
 802c1e8:	d105      	bne.n	802c1f6 <HAL_RCC_OscConfig+0x39a>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 802c1ea:	4b52      	ldr	r3, [pc, #328]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c1ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802c1ee:	4a51      	ldr	r2, [pc, #324]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c1f0:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 802c1f4:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 802c1f6:	687b      	ldr	r3, [r7, #4]
 802c1f8:	699b      	ldr	r3, [r3, #24]
 802c1fa:	2b00      	cmp	r3, #0
 802c1fc:	f000 8092 	beq.w	802c324 <HAL_RCC_OscConfig+0x4c8>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 802c200:	4b4c      	ldr	r3, [pc, #304]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c202:	689b      	ldr	r3, [r3, #8]
 802c204:	f003 030c 	and.w	r3, r3, #12
 802c208:	2b08      	cmp	r3, #8
 802c20a:	d05c      	beq.n	802c2c6 <HAL_RCC_OscConfig+0x46a>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 802c20c:	687b      	ldr	r3, [r7, #4]
 802c20e:	699b      	ldr	r3, [r3, #24]
 802c210:	2b02      	cmp	r3, #2
 802c212:	d141      	bne.n	802c298 <HAL_RCC_OscConfig+0x43c>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 802c214:	4b48      	ldr	r3, [pc, #288]	; (802c338 <HAL_RCC_OscConfig+0x4dc>)
 802c216:	2200      	movs	r2, #0
 802c218:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802c21a:	f7fe ff9b 	bl	802b154 <HAL_GetTick>
 802c21e:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802c220:	e008      	b.n	802c234 <HAL_RCC_OscConfig+0x3d8>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802c222:	f7fe ff97 	bl	802b154 <HAL_GetTick>
 802c226:	4602      	mov	r2, r0
 802c228:	693b      	ldr	r3, [r7, #16]
 802c22a:	1ad3      	subs	r3, r2, r3
 802c22c:	2b02      	cmp	r3, #2
 802c22e:	d901      	bls.n	802c234 <HAL_RCC_OscConfig+0x3d8>
          {
            return HAL_TIMEOUT;
 802c230:	2303      	movs	r3, #3
 802c232:	e078      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802c234:	4b3f      	ldr	r3, [pc, #252]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c236:	681b      	ldr	r3, [r3, #0]
 802c238:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802c23c:	2b00      	cmp	r3, #0
 802c23e:	d1f0      	bne.n	802c222 <HAL_RCC_OscConfig+0x3c6>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 802c240:	687b      	ldr	r3, [r7, #4]
 802c242:	69da      	ldr	r2, [r3, #28]
 802c244:	687b      	ldr	r3, [r7, #4]
 802c246:	6a1b      	ldr	r3, [r3, #32]
 802c248:	431a      	orrs	r2, r3
 802c24a:	687b      	ldr	r3, [r7, #4]
 802c24c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802c24e:	019b      	lsls	r3, r3, #6
 802c250:	431a      	orrs	r2, r3
 802c252:	687b      	ldr	r3, [r7, #4]
 802c254:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802c256:	085b      	lsrs	r3, r3, #1
 802c258:	3b01      	subs	r3, #1
 802c25a:	041b      	lsls	r3, r3, #16
 802c25c:	431a      	orrs	r2, r3
 802c25e:	687b      	ldr	r3, [r7, #4]
 802c260:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c262:	061b      	lsls	r3, r3, #24
 802c264:	4933      	ldr	r1, [pc, #204]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c266:	4313      	orrs	r3, r2
 802c268:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 802c26a:	4b33      	ldr	r3, [pc, #204]	; (802c338 <HAL_RCC_OscConfig+0x4dc>)
 802c26c:	2201      	movs	r2, #1
 802c26e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802c270:	f7fe ff70 	bl	802b154 <HAL_GetTick>
 802c274:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 802c276:	e008      	b.n	802c28a <HAL_RCC_OscConfig+0x42e>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802c278:	f7fe ff6c 	bl	802b154 <HAL_GetTick>
 802c27c:	4602      	mov	r2, r0
 802c27e:	693b      	ldr	r3, [r7, #16]
 802c280:	1ad3      	subs	r3, r2, r3
 802c282:	2b02      	cmp	r3, #2
 802c284:	d901      	bls.n	802c28a <HAL_RCC_OscConfig+0x42e>
          {
            return HAL_TIMEOUT;
 802c286:	2303      	movs	r3, #3
 802c288:	e04d      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 802c28a:	4b2a      	ldr	r3, [pc, #168]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c28c:	681b      	ldr	r3, [r3, #0]
 802c28e:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802c292:	2b00      	cmp	r3, #0
 802c294:	d0f0      	beq.n	802c278 <HAL_RCC_OscConfig+0x41c>
 802c296:	e045      	b.n	802c324 <HAL_RCC_OscConfig+0x4c8>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 802c298:	4b27      	ldr	r3, [pc, #156]	; (802c338 <HAL_RCC_OscConfig+0x4dc>)
 802c29a:	2200      	movs	r2, #0
 802c29c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 802c29e:	f7fe ff59 	bl	802b154 <HAL_GetTick>
 802c2a2:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802c2a4:	e008      	b.n	802c2b8 <HAL_RCC_OscConfig+0x45c>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 802c2a6:	f7fe ff55 	bl	802b154 <HAL_GetTick>
 802c2aa:	4602      	mov	r2, r0
 802c2ac:	693b      	ldr	r3, [r7, #16]
 802c2ae:	1ad3      	subs	r3, r2, r3
 802c2b0:	2b02      	cmp	r3, #2
 802c2b2:	d901      	bls.n	802c2b8 <HAL_RCC_OscConfig+0x45c>
          {
            return HAL_TIMEOUT;
 802c2b4:	2303      	movs	r3, #3
 802c2b6:	e036      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 802c2b8:	4b1e      	ldr	r3, [pc, #120]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c2ba:	681b      	ldr	r3, [r3, #0]
 802c2bc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802c2c0:	2b00      	cmp	r3, #0
 802c2c2:	d1f0      	bne.n	802c2a6 <HAL_RCC_OscConfig+0x44a>
 802c2c4:	e02e      	b.n	802c324 <HAL_RCC_OscConfig+0x4c8>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 802c2c6:	687b      	ldr	r3, [r7, #4]
 802c2c8:	699b      	ldr	r3, [r3, #24]
 802c2ca:	2b01      	cmp	r3, #1
 802c2cc:	d101      	bne.n	802c2d2 <HAL_RCC_OscConfig+0x476>
      {
        return HAL_ERROR;
 802c2ce:	2301      	movs	r3, #1
 802c2d0:	e029      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->CFGR;
 802c2d2:	4b18      	ldr	r3, [pc, #96]	; (802c334 <HAL_RCC_OscConfig+0x4d8>)
 802c2d4:	689b      	ldr	r3, [r3, #8]
 802c2d6:	60fb      	str	r3, [r7, #12]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 802c2d8:	68fb      	ldr	r3, [r7, #12]
 802c2da:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 802c2de:	687b      	ldr	r3, [r7, #4]
 802c2e0:	69db      	ldr	r3, [r3, #28]
 802c2e2:	429a      	cmp	r2, r3
 802c2e4:	d11c      	bne.n	802c320 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 802c2e6:	68fb      	ldr	r3, [r7, #12]
 802c2e8:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 802c2ec:	687b      	ldr	r3, [r7, #4]
 802c2ee:	6a1b      	ldr	r3, [r3, #32]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 802c2f0:	429a      	cmp	r2, r3
 802c2f2:	d115      	bne.n	802c320 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 802c2f4:	68fa      	ldr	r2, [r7, #12]
 802c2f6:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 802c2fa:	4013      	ands	r3, r2
 802c2fc:	687a      	ldr	r2, [r7, #4]
 802c2fe:	6a52      	ldr	r2, [r2, #36]	; 0x24
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 802c300:	4293      	cmp	r3, r2
 802c302:	d10d      	bne.n	802c320 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 802c304:	68fb      	ldr	r3, [r7, #12]
 802c306:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 802c30a:	687b      	ldr	r3, [r7, #4]
 802c30c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 802c30e:	429a      	cmp	r2, r3
 802c310:	d106      	bne.n	802c320 <HAL_RCC_OscConfig+0x4c4>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 802c312:	68fb      	ldr	r3, [r7, #12]
 802c314:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 802c318:	687b      	ldr	r3, [r7, #4]
 802c31a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 802c31c:	429a      	cmp	r2, r3
 802c31e:	d001      	beq.n	802c324 <HAL_RCC_OscConfig+0x4c8>
        {
          return HAL_ERROR;
 802c320:	2301      	movs	r3, #1
 802c322:	e000      	b.n	802c326 <HAL_RCC_OscConfig+0x4ca>
        }
      }
    }
  }
  return HAL_OK;
 802c324:	2300      	movs	r3, #0
}
 802c326:	4618      	mov	r0, r3
 802c328:	3718      	adds	r7, #24
 802c32a:	46bd      	mov	sp, r7
 802c32c:	bd80      	pop	{r7, pc}
 802c32e:	bf00      	nop
 802c330:	40007000 	.word	0x40007000
 802c334:	40023800 	.word	0x40023800
 802c338:	42470060 	.word	0x42470060

0802c33c <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 802c33c:	b580      	push	{r7, lr}
 802c33e:	b084      	sub	sp, #16
 802c340:	af00      	add	r7, sp, #0
 802c342:	6078      	str	r0, [r7, #4]
 802c344:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 802c346:	687b      	ldr	r3, [r7, #4]
 802c348:	2b00      	cmp	r3, #0
 802c34a:	d101      	bne.n	802c350 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 802c34c:	2301      	movs	r3, #1
 802c34e:	e0cc      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 802c350:	4b68      	ldr	r3, [pc, #416]	; (802c4f4 <HAL_RCC_ClockConfig+0x1b8>)
 802c352:	681b      	ldr	r3, [r3, #0]
 802c354:	f003 030f 	and.w	r3, r3, #15
 802c358:	683a      	ldr	r2, [r7, #0]
 802c35a:	429a      	cmp	r2, r3
 802c35c:	d90c      	bls.n	802c378 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 802c35e:	4b65      	ldr	r3, [pc, #404]	; (802c4f4 <HAL_RCC_ClockConfig+0x1b8>)
 802c360:	683a      	ldr	r2, [r7, #0]
 802c362:	b2d2      	uxtb	r2, r2
 802c364:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 802c366:	4b63      	ldr	r3, [pc, #396]	; (802c4f4 <HAL_RCC_ClockConfig+0x1b8>)
 802c368:	681b      	ldr	r3, [r3, #0]
 802c36a:	f003 030f 	and.w	r3, r3, #15
 802c36e:	683a      	ldr	r2, [r7, #0]
 802c370:	429a      	cmp	r2, r3
 802c372:	d001      	beq.n	802c378 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 802c374:	2301      	movs	r3, #1
 802c376:	e0b8      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 802c378:	687b      	ldr	r3, [r7, #4]
 802c37a:	681b      	ldr	r3, [r3, #0]
 802c37c:	f003 0302 	and.w	r3, r3, #2
 802c380:	2b00      	cmp	r3, #0
 802c382:	d020      	beq.n	802c3c6 <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802c384:	687b      	ldr	r3, [r7, #4]
 802c386:	681b      	ldr	r3, [r3, #0]
 802c388:	f003 0304 	and.w	r3, r3, #4
 802c38c:	2b00      	cmp	r3, #0
 802c38e:	d005      	beq.n	802c39c <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 802c390:	4b59      	ldr	r3, [pc, #356]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c392:	689b      	ldr	r3, [r3, #8]
 802c394:	4a58      	ldr	r2, [pc, #352]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c396:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 802c39a:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802c39c:	687b      	ldr	r3, [r7, #4]
 802c39e:	681b      	ldr	r3, [r3, #0]
 802c3a0:	f003 0308 	and.w	r3, r3, #8
 802c3a4:	2b00      	cmp	r3, #0
 802c3a6:	d005      	beq.n	802c3b4 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 802c3a8:	4b53      	ldr	r3, [pc, #332]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c3aa:	689b      	ldr	r3, [r3, #8]
 802c3ac:	4a52      	ldr	r2, [pc, #328]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c3ae:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 802c3b2:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 802c3b4:	4b50      	ldr	r3, [pc, #320]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c3b6:	689b      	ldr	r3, [r3, #8]
 802c3b8:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 802c3bc:	687b      	ldr	r3, [r7, #4]
 802c3be:	689b      	ldr	r3, [r3, #8]
 802c3c0:	494d      	ldr	r1, [pc, #308]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c3c2:	4313      	orrs	r3, r2
 802c3c4:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 802c3c6:	687b      	ldr	r3, [r7, #4]
 802c3c8:	681b      	ldr	r3, [r3, #0]
 802c3ca:	f003 0301 	and.w	r3, r3, #1
 802c3ce:	2b00      	cmp	r3, #0
 802c3d0:	d044      	beq.n	802c45c <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 802c3d2:	687b      	ldr	r3, [r7, #4]
 802c3d4:	685b      	ldr	r3, [r3, #4]
 802c3d6:	2b01      	cmp	r3, #1
 802c3d8:	d107      	bne.n	802c3ea <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 802c3da:	4b47      	ldr	r3, [pc, #284]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c3dc:	681b      	ldr	r3, [r3, #0]
 802c3de:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 802c3e2:	2b00      	cmp	r3, #0
 802c3e4:	d119      	bne.n	802c41a <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 802c3e6:	2301      	movs	r3, #1
 802c3e8:	e07f      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 802c3ea:	687b      	ldr	r3, [r7, #4]
 802c3ec:	685b      	ldr	r3, [r3, #4]
 802c3ee:	2b02      	cmp	r3, #2
 802c3f0:	d003      	beq.n	802c3fa <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 802c3f2:	687b      	ldr	r3, [r7, #4]
 802c3f4:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 802c3f6:	2b03      	cmp	r3, #3
 802c3f8:	d107      	bne.n	802c40a <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 802c3fa:	4b3f      	ldr	r3, [pc, #252]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c3fc:	681b      	ldr	r3, [r3, #0]
 802c3fe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 802c402:	2b00      	cmp	r3, #0
 802c404:	d109      	bne.n	802c41a <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 802c406:	2301      	movs	r3, #1
 802c408:	e06f      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 802c40a:	4b3b      	ldr	r3, [pc, #236]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c40c:	681b      	ldr	r3, [r3, #0]
 802c40e:	f003 0302 	and.w	r3, r3, #2
 802c412:	2b00      	cmp	r3, #0
 802c414:	d101      	bne.n	802c41a <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 802c416:	2301      	movs	r3, #1
 802c418:	e067      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 802c41a:	4b37      	ldr	r3, [pc, #220]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c41c:	689b      	ldr	r3, [r3, #8]
 802c41e:	f023 0203 	bic.w	r2, r3, #3
 802c422:	687b      	ldr	r3, [r7, #4]
 802c424:	685b      	ldr	r3, [r3, #4]
 802c426:	4934      	ldr	r1, [pc, #208]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c428:	4313      	orrs	r3, r2
 802c42a:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 802c42c:	f7fe fe92 	bl	802b154 <HAL_GetTick>
 802c430:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802c432:	e00a      	b.n	802c44a <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 802c434:	f7fe fe8e 	bl	802b154 <HAL_GetTick>
 802c438:	4602      	mov	r2, r0
 802c43a:	68fb      	ldr	r3, [r7, #12]
 802c43c:	1ad3      	subs	r3, r2, r3
 802c43e:	f241 3288 	movw	r2, #5000	; 0x1388
 802c442:	4293      	cmp	r3, r2
 802c444:	d901      	bls.n	802c44a <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 802c446:	2303      	movs	r3, #3
 802c448:	e04f      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 802c44a:	4b2b      	ldr	r3, [pc, #172]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c44c:	689b      	ldr	r3, [r3, #8]
 802c44e:	f003 020c 	and.w	r2, r3, #12
 802c452:	687b      	ldr	r3, [r7, #4]
 802c454:	685b      	ldr	r3, [r3, #4]
 802c456:	009b      	lsls	r3, r3, #2
 802c458:	429a      	cmp	r2, r3
 802c45a:	d1eb      	bne.n	802c434 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 802c45c:	4b25      	ldr	r3, [pc, #148]	; (802c4f4 <HAL_RCC_ClockConfig+0x1b8>)
 802c45e:	681b      	ldr	r3, [r3, #0]
 802c460:	f003 030f 	and.w	r3, r3, #15
 802c464:	683a      	ldr	r2, [r7, #0]
 802c466:	429a      	cmp	r2, r3
 802c468:	d20c      	bcs.n	802c484 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 802c46a:	4b22      	ldr	r3, [pc, #136]	; (802c4f4 <HAL_RCC_ClockConfig+0x1b8>)
 802c46c:	683a      	ldr	r2, [r7, #0]
 802c46e:	b2d2      	uxtb	r2, r2
 802c470:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 802c472:	4b20      	ldr	r3, [pc, #128]	; (802c4f4 <HAL_RCC_ClockConfig+0x1b8>)
 802c474:	681b      	ldr	r3, [r3, #0]
 802c476:	f003 030f 	and.w	r3, r3, #15
 802c47a:	683a      	ldr	r2, [r7, #0]
 802c47c:	429a      	cmp	r2, r3
 802c47e:	d001      	beq.n	802c484 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 802c480:	2301      	movs	r3, #1
 802c482:	e032      	b.n	802c4ea <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 802c484:	687b      	ldr	r3, [r7, #4]
 802c486:	681b      	ldr	r3, [r3, #0]
 802c488:	f003 0304 	and.w	r3, r3, #4
 802c48c:	2b00      	cmp	r3, #0
 802c48e:	d008      	beq.n	802c4a2 <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 802c490:	4b19      	ldr	r3, [pc, #100]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c492:	689b      	ldr	r3, [r3, #8]
 802c494:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 802c498:	687b      	ldr	r3, [r7, #4]
 802c49a:	68db      	ldr	r3, [r3, #12]
 802c49c:	4916      	ldr	r1, [pc, #88]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c49e:	4313      	orrs	r3, r2
 802c4a0:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 802c4a2:	687b      	ldr	r3, [r7, #4]
 802c4a4:	681b      	ldr	r3, [r3, #0]
 802c4a6:	f003 0308 	and.w	r3, r3, #8
 802c4aa:	2b00      	cmp	r3, #0
 802c4ac:	d009      	beq.n	802c4c2 <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 802c4ae:	4b12      	ldr	r3, [pc, #72]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c4b0:	689b      	ldr	r3, [r3, #8]
 802c4b2:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 802c4b6:	687b      	ldr	r3, [r7, #4]
 802c4b8:	691b      	ldr	r3, [r3, #16]
 802c4ba:	00db      	lsls	r3, r3, #3
 802c4bc:	490e      	ldr	r1, [pc, #56]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c4be:	4313      	orrs	r3, r2
 802c4c0:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 802c4c2:	f000 f821 	bl	802c508 <HAL_RCC_GetSysClockFreq>
 802c4c6:	4601      	mov	r1, r0
 802c4c8:	4b0b      	ldr	r3, [pc, #44]	; (802c4f8 <HAL_RCC_ClockConfig+0x1bc>)
 802c4ca:	689b      	ldr	r3, [r3, #8]
 802c4cc:	091b      	lsrs	r3, r3, #4
 802c4ce:	f003 030f 	and.w	r3, r3, #15
 802c4d2:	4a0a      	ldr	r2, [pc, #40]	; (802c4fc <HAL_RCC_ClockConfig+0x1c0>)
 802c4d4:	5cd3      	ldrb	r3, [r2, r3]
 802c4d6:	fa21 f303 	lsr.w	r3, r1, r3
 802c4da:	4a09      	ldr	r2, [pc, #36]	; (802c500 <HAL_RCC_ClockConfig+0x1c4>)
 802c4dc:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 802c4de:	4b09      	ldr	r3, [pc, #36]	; (802c504 <HAL_RCC_ClockConfig+0x1c8>)
 802c4e0:	681b      	ldr	r3, [r3, #0]
 802c4e2:	4618      	mov	r0, r3
 802c4e4:	f7fe fdf2 	bl	802b0cc <HAL_InitTick>

  return HAL_OK;
 802c4e8:	2300      	movs	r3, #0
}
 802c4ea:	4618      	mov	r0, r3
 802c4ec:	3710      	adds	r7, #16
 802c4ee:	46bd      	mov	sp, r7
 802c4f0:	bd80      	pop	{r7, pc}
 802c4f2:	bf00      	nop
 802c4f4:	40023c00 	.word	0x40023c00
 802c4f8:	40023800 	.word	0x40023800
 802c4fc:	08030160 	.word	0x08030160
 802c500:	20000098 	.word	0x20000098
 802c504:	2000009c 	.word	0x2000009c

0802c508 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 802c508:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c50a:	b085      	sub	sp, #20
 802c50c:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 802c50e:	2300      	movs	r3, #0
 802c510:	607b      	str	r3, [r7, #4]
 802c512:	2300      	movs	r3, #0
 802c514:	60fb      	str	r3, [r7, #12]
 802c516:	2300      	movs	r3, #0
 802c518:	603b      	str	r3, [r7, #0]
  uint32_t sysclockfreq = 0U;
 802c51a:	2300      	movs	r3, #0
 802c51c:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 802c51e:	4b63      	ldr	r3, [pc, #396]	; (802c6ac <HAL_RCC_GetSysClockFreq+0x1a4>)
 802c520:	689b      	ldr	r3, [r3, #8]
 802c522:	f003 030c 	and.w	r3, r3, #12
 802c526:	2b04      	cmp	r3, #4
 802c528:	d007      	beq.n	802c53a <HAL_RCC_GetSysClockFreq+0x32>
 802c52a:	2b08      	cmp	r3, #8
 802c52c:	d008      	beq.n	802c540 <HAL_RCC_GetSysClockFreq+0x38>
 802c52e:	2b00      	cmp	r3, #0
 802c530:	f040 80b4 	bne.w	802c69c <HAL_RCC_GetSysClockFreq+0x194>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 802c534:	4b5e      	ldr	r3, [pc, #376]	; (802c6b0 <HAL_RCC_GetSysClockFreq+0x1a8>)
 802c536:	60bb      	str	r3, [r7, #8]
       break;
 802c538:	e0b3      	b.n	802c6a2 <HAL_RCC_GetSysClockFreq+0x19a>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 802c53a:	4b5e      	ldr	r3, [pc, #376]	; (802c6b4 <HAL_RCC_GetSysClockFreq+0x1ac>)
 802c53c:	60bb      	str	r3, [r7, #8]
      break;
 802c53e:	e0b0      	b.n	802c6a2 <HAL_RCC_GetSysClockFreq+0x19a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 802c540:	4b5a      	ldr	r3, [pc, #360]	; (802c6ac <HAL_RCC_GetSysClockFreq+0x1a4>)
 802c542:	685b      	ldr	r3, [r3, #4]
 802c544:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 802c548:	607b      	str	r3, [r7, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 802c54a:	4b58      	ldr	r3, [pc, #352]	; (802c6ac <HAL_RCC_GetSysClockFreq+0x1a4>)
 802c54c:	685b      	ldr	r3, [r3, #4]
 802c54e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 802c552:	2b00      	cmp	r3, #0
 802c554:	d04a      	beq.n	802c5ec <HAL_RCC_GetSysClockFreq+0xe4>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 802c556:	4b55      	ldr	r3, [pc, #340]	; (802c6ac <HAL_RCC_GetSysClockFreq+0x1a4>)
 802c558:	685b      	ldr	r3, [r3, #4]
 802c55a:	099b      	lsrs	r3, r3, #6
 802c55c:	f04f 0400 	mov.w	r4, #0
 802c560:	f240 11ff 	movw	r1, #511	; 0x1ff
 802c564:	f04f 0200 	mov.w	r2, #0
 802c568:	ea03 0501 	and.w	r5, r3, r1
 802c56c:	ea04 0602 	and.w	r6, r4, r2
 802c570:	4629      	mov	r1, r5
 802c572:	4632      	mov	r2, r6
 802c574:	f04f 0300 	mov.w	r3, #0
 802c578:	f04f 0400 	mov.w	r4, #0
 802c57c:	0154      	lsls	r4, r2, #5
 802c57e:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 802c582:	014b      	lsls	r3, r1, #5
 802c584:	4619      	mov	r1, r3
 802c586:	4622      	mov	r2, r4
 802c588:	1b49      	subs	r1, r1, r5
 802c58a:	eb62 0206 	sbc.w	r2, r2, r6
 802c58e:	f04f 0300 	mov.w	r3, #0
 802c592:	f04f 0400 	mov.w	r4, #0
 802c596:	0194      	lsls	r4, r2, #6
 802c598:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 802c59c:	018b      	lsls	r3, r1, #6
 802c59e:	1a5b      	subs	r3, r3, r1
 802c5a0:	eb64 0402 	sbc.w	r4, r4, r2
 802c5a4:	f04f 0100 	mov.w	r1, #0
 802c5a8:	f04f 0200 	mov.w	r2, #0
 802c5ac:	00e2      	lsls	r2, r4, #3
 802c5ae:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 802c5b2:	00d9      	lsls	r1, r3, #3
 802c5b4:	460b      	mov	r3, r1
 802c5b6:	4614      	mov	r4, r2
 802c5b8:	195b      	adds	r3, r3, r5
 802c5ba:	eb44 0406 	adc.w	r4, r4, r6
 802c5be:	f04f 0100 	mov.w	r1, #0
 802c5c2:	f04f 0200 	mov.w	r2, #0
 802c5c6:	0262      	lsls	r2, r4, #9
 802c5c8:	ea42 52d3 	orr.w	r2, r2, r3, lsr #23
 802c5cc:	0259      	lsls	r1, r3, #9
 802c5ce:	460b      	mov	r3, r1
 802c5d0:	4614      	mov	r4, r2
 802c5d2:	4618      	mov	r0, r3
 802c5d4:	4621      	mov	r1, r4
 802c5d6:	687b      	ldr	r3, [r7, #4]
 802c5d8:	f04f 0400 	mov.w	r4, #0
 802c5dc:	461a      	mov	r2, r3
 802c5de:	4623      	mov	r3, r4
 802c5e0:	f7fb ff62 	bl	80284a8 <__aeabi_uldivmod>
 802c5e4:	4603      	mov	r3, r0
 802c5e6:	460c      	mov	r4, r1
 802c5e8:	60fb      	str	r3, [r7, #12]
 802c5ea:	e049      	b.n	802c680 <HAL_RCC_GetSysClockFreq+0x178>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 802c5ec:	4b2f      	ldr	r3, [pc, #188]	; (802c6ac <HAL_RCC_GetSysClockFreq+0x1a4>)
 802c5ee:	685b      	ldr	r3, [r3, #4]
 802c5f0:	099b      	lsrs	r3, r3, #6
 802c5f2:	f04f 0400 	mov.w	r4, #0
 802c5f6:	f240 11ff 	movw	r1, #511	; 0x1ff
 802c5fa:	f04f 0200 	mov.w	r2, #0
 802c5fe:	ea03 0501 	and.w	r5, r3, r1
 802c602:	ea04 0602 	and.w	r6, r4, r2
 802c606:	4629      	mov	r1, r5
 802c608:	4632      	mov	r2, r6
 802c60a:	f04f 0300 	mov.w	r3, #0
 802c60e:	f04f 0400 	mov.w	r4, #0
 802c612:	0154      	lsls	r4, r2, #5
 802c614:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 802c618:	014b      	lsls	r3, r1, #5
 802c61a:	4619      	mov	r1, r3
 802c61c:	4622      	mov	r2, r4
 802c61e:	1b49      	subs	r1, r1, r5
 802c620:	eb62 0206 	sbc.w	r2, r2, r6
 802c624:	f04f 0300 	mov.w	r3, #0
 802c628:	f04f 0400 	mov.w	r4, #0
 802c62c:	0194      	lsls	r4, r2, #6
 802c62e:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 802c632:	018b      	lsls	r3, r1, #6
 802c634:	1a5b      	subs	r3, r3, r1
 802c636:	eb64 0402 	sbc.w	r4, r4, r2
 802c63a:	f04f 0100 	mov.w	r1, #0
 802c63e:	f04f 0200 	mov.w	r2, #0
 802c642:	00e2      	lsls	r2, r4, #3
 802c644:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 802c648:	00d9      	lsls	r1, r3, #3
 802c64a:	460b      	mov	r3, r1
 802c64c:	4614      	mov	r4, r2
 802c64e:	195b      	adds	r3, r3, r5
 802c650:	eb44 0406 	adc.w	r4, r4, r6
 802c654:	f04f 0100 	mov.w	r1, #0
 802c658:	f04f 0200 	mov.w	r2, #0
 802c65c:	02a2      	lsls	r2, r4, #10
 802c65e:	ea42 5293 	orr.w	r2, r2, r3, lsr #22
 802c662:	0299      	lsls	r1, r3, #10
 802c664:	460b      	mov	r3, r1
 802c666:	4614      	mov	r4, r2
 802c668:	4618      	mov	r0, r3
 802c66a:	4621      	mov	r1, r4
 802c66c:	687b      	ldr	r3, [r7, #4]
 802c66e:	f04f 0400 	mov.w	r4, #0
 802c672:	461a      	mov	r2, r3
 802c674:	4623      	mov	r3, r4
 802c676:	f7fb ff17 	bl	80284a8 <__aeabi_uldivmod>
 802c67a:	4603      	mov	r3, r0
 802c67c:	460c      	mov	r4, r1
 802c67e:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 802c680:	4b0a      	ldr	r3, [pc, #40]	; (802c6ac <HAL_RCC_GetSysClockFreq+0x1a4>)
 802c682:	685b      	ldr	r3, [r3, #4]
 802c684:	0c1b      	lsrs	r3, r3, #16
 802c686:	f003 0303 	and.w	r3, r3, #3
 802c68a:	3301      	adds	r3, #1
 802c68c:	005b      	lsls	r3, r3, #1
 802c68e:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco/pllp;
 802c690:	68fa      	ldr	r2, [r7, #12]
 802c692:	683b      	ldr	r3, [r7, #0]
 802c694:	fbb2 f3f3 	udiv	r3, r2, r3
 802c698:	60bb      	str	r3, [r7, #8]
      break;
 802c69a:	e002      	b.n	802c6a2 <HAL_RCC_GetSysClockFreq+0x19a>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 802c69c:	4b04      	ldr	r3, [pc, #16]	; (802c6b0 <HAL_RCC_GetSysClockFreq+0x1a8>)
 802c69e:	60bb      	str	r3, [r7, #8]
      break;
 802c6a0:	bf00      	nop
    }
  }
  return sysclockfreq;
 802c6a2:	68bb      	ldr	r3, [r7, #8]
}
 802c6a4:	4618      	mov	r0, r3
 802c6a6:	3714      	adds	r7, #20
 802c6a8:	46bd      	mov	sp, r7
 802c6aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c6ac:	40023800 	.word	0x40023800
 802c6b0:	00f42400 	.word	0x00f42400
 802c6b4:	007a1200 	.word	0x007a1200

0802c6b8 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 802c6b8:	b480      	push	{r7}
 802c6ba:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 802c6bc:	4b03      	ldr	r3, [pc, #12]	; (802c6cc <HAL_RCC_GetHCLKFreq+0x14>)
 802c6be:	681b      	ldr	r3, [r3, #0]
}
 802c6c0:	4618      	mov	r0, r3
 802c6c2:	46bd      	mov	sp, r7
 802c6c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c6c8:	4770      	bx	lr
 802c6ca:	bf00      	nop
 802c6cc:	20000098 	.word	0x20000098

0802c6d0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 802c6d0:	b580      	push	{r7, lr}
 802c6d2:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 802c6d4:	f7ff fff0 	bl	802c6b8 <HAL_RCC_GetHCLKFreq>
 802c6d8:	4601      	mov	r1, r0
 802c6da:	4b05      	ldr	r3, [pc, #20]	; (802c6f0 <HAL_RCC_GetPCLK1Freq+0x20>)
 802c6dc:	689b      	ldr	r3, [r3, #8]
 802c6de:	0a9b      	lsrs	r3, r3, #10
 802c6e0:	f003 0307 	and.w	r3, r3, #7
 802c6e4:	4a03      	ldr	r2, [pc, #12]	; (802c6f4 <HAL_RCC_GetPCLK1Freq+0x24>)
 802c6e6:	5cd3      	ldrb	r3, [r2, r3]
 802c6e8:	fa21 f303 	lsr.w	r3, r1, r3
}
 802c6ec:	4618      	mov	r0, r3
 802c6ee:	bd80      	pop	{r7, pc}
 802c6f0:	40023800 	.word	0x40023800
 802c6f4:	08030170 	.word	0x08030170

0802c6f8 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 802c6f8:	b580      	push	{r7, lr}
 802c6fa:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 802c6fc:	f7ff ffdc 	bl	802c6b8 <HAL_RCC_GetHCLKFreq>
 802c700:	4601      	mov	r1, r0
 802c702:	4b05      	ldr	r3, [pc, #20]	; (802c718 <HAL_RCC_GetPCLK2Freq+0x20>)
 802c704:	689b      	ldr	r3, [r3, #8]
 802c706:	0b5b      	lsrs	r3, r3, #13
 802c708:	f003 0307 	and.w	r3, r3, #7
 802c70c:	4a03      	ldr	r2, [pc, #12]	; (802c71c <HAL_RCC_GetPCLK2Freq+0x24>)
 802c70e:	5cd3      	ldrb	r3, [r2, r3]
 802c710:	fa21 f303 	lsr.w	r3, r1, r3
}
 802c714:	4618      	mov	r0, r3
 802c716:	bd80      	pop	{r7, pc}
 802c718:	40023800 	.word	0x40023800
 802c71c:	08030170 	.word	0x08030170

0802c720 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 802c720:	b580      	push	{r7, lr}
 802c722:	b082      	sub	sp, #8
 802c724:	af00      	add	r7, sp, #0
 802c726:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 802c728:	687b      	ldr	r3, [r7, #4]
 802c72a:	2b00      	cmp	r3, #0
 802c72c:	d101      	bne.n	802c732 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 802c72e:	2301      	movs	r3, #1
 802c730:	e056      	b.n	802c7e0 <HAL_SPI_Init+0xc0>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 802c732:	687b      	ldr	r3, [r7, #4]
 802c734:	2200      	movs	r2, #0
 802c736:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 802c738:	687b      	ldr	r3, [r7, #4]
 802c73a:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802c73e:	b2db      	uxtb	r3, r3
 802c740:	2b00      	cmp	r3, #0
 802c742:	d106      	bne.n	802c752 <HAL_SPI_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 802c744:	687b      	ldr	r3, [r7, #4]
 802c746:	2200      	movs	r2, #0
 802c748:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 802c74c:	6878      	ldr	r0, [r7, #4]
 802c74e:	f7fe f9ff 	bl	802ab50 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 802c752:	687b      	ldr	r3, [r7, #4]
 802c754:	2202      	movs	r2, #2
 802c756:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 802c75a:	687b      	ldr	r3, [r7, #4]
 802c75c:	681b      	ldr	r3, [r3, #0]
 802c75e:	681a      	ldr	r2, [r3, #0]
 802c760:	687b      	ldr	r3, [r7, #4]
 802c762:	681b      	ldr	r3, [r3, #0]
 802c764:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802c768:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 802c76a:	687b      	ldr	r3, [r7, #4]
 802c76c:	685a      	ldr	r2, [r3, #4]
 802c76e:	687b      	ldr	r3, [r7, #4]
 802c770:	689b      	ldr	r3, [r3, #8]
 802c772:	431a      	orrs	r2, r3
 802c774:	687b      	ldr	r3, [r7, #4]
 802c776:	68db      	ldr	r3, [r3, #12]
 802c778:	431a      	orrs	r2, r3
 802c77a:	687b      	ldr	r3, [r7, #4]
 802c77c:	691b      	ldr	r3, [r3, #16]
 802c77e:	431a      	orrs	r2, r3
 802c780:	687b      	ldr	r3, [r7, #4]
 802c782:	695b      	ldr	r3, [r3, #20]
 802c784:	431a      	orrs	r2, r3
 802c786:	687b      	ldr	r3, [r7, #4]
 802c788:	699b      	ldr	r3, [r3, #24]
 802c78a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 802c78e:	431a      	orrs	r2, r3
 802c790:	687b      	ldr	r3, [r7, #4]
 802c792:	69db      	ldr	r3, [r3, #28]
 802c794:	431a      	orrs	r2, r3
 802c796:	687b      	ldr	r3, [r7, #4]
 802c798:	6a1b      	ldr	r3, [r3, #32]
 802c79a:	ea42 0103 	orr.w	r1, r2, r3
 802c79e:	687b      	ldr	r3, [r7, #4]
 802c7a0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802c7a2:	687b      	ldr	r3, [r7, #4]
 802c7a4:	681b      	ldr	r3, [r3, #0]
 802c7a6:	430a      	orrs	r2, r1
 802c7a8:	601a      	str	r2, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 802c7aa:	687b      	ldr	r3, [r7, #4]
 802c7ac:	699b      	ldr	r3, [r3, #24]
 802c7ae:	0c1b      	lsrs	r3, r3, #16
 802c7b0:	f003 0104 	and.w	r1, r3, #4
 802c7b4:	687b      	ldr	r3, [r7, #4]
 802c7b6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 802c7b8:	687b      	ldr	r3, [r7, #4]
 802c7ba:	681b      	ldr	r3, [r3, #0]
 802c7bc:	430a      	orrs	r2, r1
 802c7be:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 802c7c0:	687b      	ldr	r3, [r7, #4]
 802c7c2:	681b      	ldr	r3, [r3, #0]
 802c7c4:	69da      	ldr	r2, [r3, #28]
 802c7c6:	687b      	ldr	r3, [r7, #4]
 802c7c8:	681b      	ldr	r3, [r3, #0]
 802c7ca:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 802c7ce:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 802c7d0:	687b      	ldr	r3, [r7, #4]
 802c7d2:	2200      	movs	r2, #0
 802c7d4:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 802c7d6:	687b      	ldr	r3, [r7, #4]
 802c7d8:	2201      	movs	r2, #1
 802c7da:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
 802c7de:	2300      	movs	r3, #0
}
 802c7e0:	4618      	mov	r0, r3
 802c7e2:	3708      	adds	r7, #8
 802c7e4:	46bd      	mov	sp, r7
 802c7e6:	bd80      	pop	{r7, pc}

0802c7e8 <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 802c7e8:	b580      	push	{r7, lr}
 802c7ea:	b088      	sub	sp, #32
 802c7ec:	af00      	add	r7, sp, #0
 802c7ee:	60f8      	str	r0, [r7, #12]
 802c7f0:	60b9      	str	r1, [r7, #8]
 802c7f2:	603b      	str	r3, [r7, #0]
 802c7f4:	4613      	mov	r3, r2
 802c7f6:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 802c7f8:	2300      	movs	r3, #0
 802c7fa:	77fb      	strb	r3, [r7, #31]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 802c7fc:	68fb      	ldr	r3, [r7, #12]
 802c7fe:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802c802:	2b01      	cmp	r3, #1
 802c804:	d101      	bne.n	802c80a <HAL_SPI_Transmit+0x22>
 802c806:	2302      	movs	r3, #2
 802c808:	e11e      	b.n	802ca48 <HAL_SPI_Transmit+0x260>
 802c80a:	68fb      	ldr	r3, [r7, #12]
 802c80c:	2201      	movs	r2, #1
 802c80e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802c812:	f7fe fc9f 	bl	802b154 <HAL_GetTick>
 802c816:	61b8      	str	r0, [r7, #24]
  initial_TxXferCount = Size;
 802c818:	88fb      	ldrh	r3, [r7, #6]
 802c81a:	82fb      	strh	r3, [r7, #22]

  if (hspi->State != HAL_SPI_STATE_READY)
 802c81c:	68fb      	ldr	r3, [r7, #12]
 802c81e:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802c822:	b2db      	uxtb	r3, r3
 802c824:	2b01      	cmp	r3, #1
 802c826:	d002      	beq.n	802c82e <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 802c828:	2302      	movs	r3, #2
 802c82a:	77fb      	strb	r3, [r7, #31]
    goto error;
 802c82c:	e103      	b.n	802ca36 <HAL_SPI_Transmit+0x24e>
  }

  if ((pData == NULL) || (Size == 0U))
 802c82e:	68bb      	ldr	r3, [r7, #8]
 802c830:	2b00      	cmp	r3, #0
 802c832:	d002      	beq.n	802c83a <HAL_SPI_Transmit+0x52>
 802c834:	88fb      	ldrh	r3, [r7, #6]
 802c836:	2b00      	cmp	r3, #0
 802c838:	d102      	bne.n	802c840 <HAL_SPI_Transmit+0x58>
  {
    errorcode = HAL_ERROR;
 802c83a:	2301      	movs	r3, #1
 802c83c:	77fb      	strb	r3, [r7, #31]
    goto error;
 802c83e:	e0fa      	b.n	802ca36 <HAL_SPI_Transmit+0x24e>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 802c840:	68fb      	ldr	r3, [r7, #12]
 802c842:	2203      	movs	r2, #3
 802c844:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802c848:	68fb      	ldr	r3, [r7, #12]
 802c84a:	2200      	movs	r2, #0
 802c84c:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 802c84e:	68fb      	ldr	r3, [r7, #12]
 802c850:	68ba      	ldr	r2, [r7, #8]
 802c852:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferSize  = Size;
 802c854:	68fb      	ldr	r3, [r7, #12]
 802c856:	88fa      	ldrh	r2, [r7, #6]
 802c858:	869a      	strh	r2, [r3, #52]	; 0x34
  hspi->TxXferCount = Size;
 802c85a:	68fb      	ldr	r3, [r7, #12]
 802c85c:	88fa      	ldrh	r2, [r7, #6]
 802c85e:	86da      	strh	r2, [r3, #54]	; 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 802c860:	68fb      	ldr	r3, [r7, #12]
 802c862:	2200      	movs	r2, #0
 802c864:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferSize  = 0U;
 802c866:	68fb      	ldr	r3, [r7, #12]
 802c868:	2200      	movs	r2, #0
 802c86a:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 802c86c:	68fb      	ldr	r3, [r7, #12]
 802c86e:	2200      	movs	r2, #0
 802c870:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->TxISR       = NULL;
 802c872:	68fb      	ldr	r3, [r7, #12]
 802c874:	2200      	movs	r2, #0
 802c876:	645a      	str	r2, [r3, #68]	; 0x44
  hspi->RxISR       = NULL;
 802c878:	68fb      	ldr	r3, [r7, #12]
 802c87a:	2200      	movs	r2, #0
 802c87c:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802c87e:	68fb      	ldr	r3, [r7, #12]
 802c880:	689b      	ldr	r3, [r3, #8]
 802c882:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802c886:	d107      	bne.n	802c898 <HAL_SPI_Transmit+0xb0>
  {
    SPI_1LINE_TX(hspi);
 802c888:	68fb      	ldr	r3, [r7, #12]
 802c88a:	681b      	ldr	r3, [r3, #0]
 802c88c:	681a      	ldr	r2, [r3, #0]
 802c88e:	68fb      	ldr	r3, [r7, #12]
 802c890:	681b      	ldr	r3, [r3, #0]
 802c892:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 802c896:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802c898:	68fb      	ldr	r3, [r7, #12]
 802c89a:	681b      	ldr	r3, [r3, #0]
 802c89c:	681b      	ldr	r3, [r3, #0]
 802c89e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802c8a2:	2b40      	cmp	r3, #64	; 0x40
 802c8a4:	d007      	beq.n	802c8b6 <HAL_SPI_Transmit+0xce>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 802c8a6:	68fb      	ldr	r3, [r7, #12]
 802c8a8:	681b      	ldr	r3, [r3, #0]
 802c8aa:	681a      	ldr	r2, [r3, #0]
 802c8ac:	68fb      	ldr	r3, [r7, #12]
 802c8ae:	681b      	ldr	r3, [r3, #0]
 802c8b0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802c8b4:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 802c8b6:	68fb      	ldr	r3, [r7, #12]
 802c8b8:	68db      	ldr	r3, [r3, #12]
 802c8ba:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 802c8be:	d14b      	bne.n	802c958 <HAL_SPI_Transmit+0x170>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802c8c0:	68fb      	ldr	r3, [r7, #12]
 802c8c2:	685b      	ldr	r3, [r3, #4]
 802c8c4:	2b00      	cmp	r3, #0
 802c8c6:	d002      	beq.n	802c8ce <HAL_SPI_Transmit+0xe6>
 802c8c8:	8afb      	ldrh	r3, [r7, #22]
 802c8ca:	2b01      	cmp	r3, #1
 802c8cc:	d13e      	bne.n	802c94c <HAL_SPI_Transmit+0x164>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802c8ce:	68fb      	ldr	r3, [r7, #12]
 802c8d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c8d2:	881a      	ldrh	r2, [r3, #0]
 802c8d4:	68fb      	ldr	r3, [r7, #12]
 802c8d6:	681b      	ldr	r3, [r3, #0]
 802c8d8:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 802c8da:	68fb      	ldr	r3, [r7, #12]
 802c8dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c8de:	1c9a      	adds	r2, r3, #2
 802c8e0:	68fb      	ldr	r3, [r7, #12]
 802c8e2:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802c8e4:	68fb      	ldr	r3, [r7, #12]
 802c8e6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802c8e8:	b29b      	uxth	r3, r3
 802c8ea:	3b01      	subs	r3, #1
 802c8ec:	b29a      	uxth	r2, r3
 802c8ee:	68fb      	ldr	r3, [r7, #12]
 802c8f0:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 802c8f2:	e02b      	b.n	802c94c <HAL_SPI_Transmit+0x164>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 802c8f4:	68fb      	ldr	r3, [r7, #12]
 802c8f6:	681b      	ldr	r3, [r3, #0]
 802c8f8:	689b      	ldr	r3, [r3, #8]
 802c8fa:	f003 0302 	and.w	r3, r3, #2
 802c8fe:	2b02      	cmp	r3, #2
 802c900:	d112      	bne.n	802c928 <HAL_SPI_Transmit+0x140>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802c902:	68fb      	ldr	r3, [r7, #12]
 802c904:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c906:	881a      	ldrh	r2, [r3, #0]
 802c908:	68fb      	ldr	r3, [r7, #12]
 802c90a:	681b      	ldr	r3, [r3, #0]
 802c90c:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 802c90e:	68fb      	ldr	r3, [r7, #12]
 802c910:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c912:	1c9a      	adds	r2, r3, #2
 802c914:	68fb      	ldr	r3, [r7, #12]
 802c916:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802c918:	68fb      	ldr	r3, [r7, #12]
 802c91a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802c91c:	b29b      	uxth	r3, r3
 802c91e:	3b01      	subs	r3, #1
 802c920:	b29a      	uxth	r2, r3
 802c922:	68fb      	ldr	r3, [r7, #12]
 802c924:	86da      	strh	r2, [r3, #54]	; 0x36
 802c926:	e011      	b.n	802c94c <HAL_SPI_Transmit+0x164>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 802c928:	f7fe fc14 	bl	802b154 <HAL_GetTick>
 802c92c:	4602      	mov	r2, r0
 802c92e:	69bb      	ldr	r3, [r7, #24]
 802c930:	1ad3      	subs	r3, r2, r3
 802c932:	683a      	ldr	r2, [r7, #0]
 802c934:	429a      	cmp	r2, r3
 802c936:	d803      	bhi.n	802c940 <HAL_SPI_Transmit+0x158>
 802c938:	683b      	ldr	r3, [r7, #0]
 802c93a:	f1b3 3fff 	cmp.w	r3, #4294967295
 802c93e:	d102      	bne.n	802c946 <HAL_SPI_Transmit+0x15e>
 802c940:	683b      	ldr	r3, [r7, #0]
 802c942:	2b00      	cmp	r3, #0
 802c944:	d102      	bne.n	802c94c <HAL_SPI_Transmit+0x164>
        {
          errorcode = HAL_TIMEOUT;
 802c946:	2303      	movs	r3, #3
 802c948:	77fb      	strb	r3, [r7, #31]
          goto error;
 802c94a:	e074      	b.n	802ca36 <HAL_SPI_Transmit+0x24e>
    while (hspi->TxXferCount > 0U)
 802c94c:	68fb      	ldr	r3, [r7, #12]
 802c94e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802c950:	b29b      	uxth	r3, r3
 802c952:	2b00      	cmp	r3, #0
 802c954:	d1ce      	bne.n	802c8f4 <HAL_SPI_Transmit+0x10c>
 802c956:	e04c      	b.n	802c9f2 <HAL_SPI_Transmit+0x20a>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802c958:	68fb      	ldr	r3, [r7, #12]
 802c95a:	685b      	ldr	r3, [r3, #4]
 802c95c:	2b00      	cmp	r3, #0
 802c95e:	d002      	beq.n	802c966 <HAL_SPI_Transmit+0x17e>
 802c960:	8afb      	ldrh	r3, [r7, #22]
 802c962:	2b01      	cmp	r3, #1
 802c964:	d140      	bne.n	802c9e8 <HAL_SPI_Transmit+0x200>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 802c966:	68fb      	ldr	r3, [r7, #12]
 802c968:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802c96a:	68fb      	ldr	r3, [r7, #12]
 802c96c:	681b      	ldr	r3, [r3, #0]
 802c96e:	330c      	adds	r3, #12
 802c970:	7812      	ldrb	r2, [r2, #0]
 802c972:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 802c974:	68fb      	ldr	r3, [r7, #12]
 802c976:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c978:	1c5a      	adds	r2, r3, #1
 802c97a:	68fb      	ldr	r3, [r7, #12]
 802c97c:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802c97e:	68fb      	ldr	r3, [r7, #12]
 802c980:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802c982:	b29b      	uxth	r3, r3
 802c984:	3b01      	subs	r3, #1
 802c986:	b29a      	uxth	r2, r3
 802c988:	68fb      	ldr	r3, [r7, #12]
 802c98a:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while (hspi->TxXferCount > 0U)
 802c98c:	e02c      	b.n	802c9e8 <HAL_SPI_Transmit+0x200>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 802c98e:	68fb      	ldr	r3, [r7, #12]
 802c990:	681b      	ldr	r3, [r3, #0]
 802c992:	689b      	ldr	r3, [r3, #8]
 802c994:	f003 0302 	and.w	r3, r3, #2
 802c998:	2b02      	cmp	r3, #2
 802c99a:	d113      	bne.n	802c9c4 <HAL_SPI_Transmit+0x1dc>
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 802c99c:	68fb      	ldr	r3, [r7, #12]
 802c99e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802c9a0:	68fb      	ldr	r3, [r7, #12]
 802c9a2:	681b      	ldr	r3, [r3, #0]
 802c9a4:	330c      	adds	r3, #12
 802c9a6:	7812      	ldrb	r2, [r2, #0]
 802c9a8:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 802c9aa:	68fb      	ldr	r3, [r7, #12]
 802c9ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c9ae:	1c5a      	adds	r2, r3, #1
 802c9b0:	68fb      	ldr	r3, [r7, #12]
 802c9b2:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802c9b4:	68fb      	ldr	r3, [r7, #12]
 802c9b6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802c9b8:	b29b      	uxth	r3, r3
 802c9ba:	3b01      	subs	r3, #1
 802c9bc:	b29a      	uxth	r2, r3
 802c9be:	68fb      	ldr	r3, [r7, #12]
 802c9c0:	86da      	strh	r2, [r3, #54]	; 0x36
 802c9c2:	e011      	b.n	802c9e8 <HAL_SPI_Transmit+0x200>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 802c9c4:	f7fe fbc6 	bl	802b154 <HAL_GetTick>
 802c9c8:	4602      	mov	r2, r0
 802c9ca:	69bb      	ldr	r3, [r7, #24]
 802c9cc:	1ad3      	subs	r3, r2, r3
 802c9ce:	683a      	ldr	r2, [r7, #0]
 802c9d0:	429a      	cmp	r2, r3
 802c9d2:	d803      	bhi.n	802c9dc <HAL_SPI_Transmit+0x1f4>
 802c9d4:	683b      	ldr	r3, [r7, #0]
 802c9d6:	f1b3 3fff 	cmp.w	r3, #4294967295
 802c9da:	d102      	bne.n	802c9e2 <HAL_SPI_Transmit+0x1fa>
 802c9dc:	683b      	ldr	r3, [r7, #0]
 802c9de:	2b00      	cmp	r3, #0
 802c9e0:	d102      	bne.n	802c9e8 <HAL_SPI_Transmit+0x200>
        {
          errorcode = HAL_TIMEOUT;
 802c9e2:	2303      	movs	r3, #3
 802c9e4:	77fb      	strb	r3, [r7, #31]
          goto error;
 802c9e6:	e026      	b.n	802ca36 <HAL_SPI_Transmit+0x24e>
    while (hspi->TxXferCount > 0U)
 802c9e8:	68fb      	ldr	r3, [r7, #12]
 802c9ea:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802c9ec:	b29b      	uxth	r3, r3
 802c9ee:	2b00      	cmp	r3, #0
 802c9f0:	d1cd      	bne.n	802c98e <HAL_SPI_Transmit+0x1a6>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 802c9f2:	69ba      	ldr	r2, [r7, #24]
 802c9f4:	6839      	ldr	r1, [r7, #0]
 802c9f6:	68f8      	ldr	r0, [r7, #12]
 802c9f8:	f000 fcd0 	bl	802d39c <SPI_EndRxTxTransaction>
 802c9fc:	4603      	mov	r3, r0
 802c9fe:	2b00      	cmp	r3, #0
 802ca00:	d002      	beq.n	802ca08 <HAL_SPI_Transmit+0x220>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 802ca02:	68fb      	ldr	r3, [r7, #12]
 802ca04:	2220      	movs	r2, #32
 802ca06:	655a      	str	r2, [r3, #84]	; 0x54
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 802ca08:	68fb      	ldr	r3, [r7, #12]
 802ca0a:	689b      	ldr	r3, [r3, #8]
 802ca0c:	2b00      	cmp	r3, #0
 802ca0e:	d10a      	bne.n	802ca26 <HAL_SPI_Transmit+0x23e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 802ca10:	2300      	movs	r3, #0
 802ca12:	613b      	str	r3, [r7, #16]
 802ca14:	68fb      	ldr	r3, [r7, #12]
 802ca16:	681b      	ldr	r3, [r3, #0]
 802ca18:	68db      	ldr	r3, [r3, #12]
 802ca1a:	613b      	str	r3, [r7, #16]
 802ca1c:	68fb      	ldr	r3, [r7, #12]
 802ca1e:	681b      	ldr	r3, [r3, #0]
 802ca20:	689b      	ldr	r3, [r3, #8]
 802ca22:	613b      	str	r3, [r7, #16]
 802ca24:	693b      	ldr	r3, [r7, #16]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 802ca26:	68fb      	ldr	r3, [r7, #12]
 802ca28:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802ca2a:	2b00      	cmp	r3, #0
 802ca2c:	d002      	beq.n	802ca34 <HAL_SPI_Transmit+0x24c>
  {
    errorcode = HAL_ERROR;
 802ca2e:	2301      	movs	r3, #1
 802ca30:	77fb      	strb	r3, [r7, #31]
 802ca32:	e000      	b.n	802ca36 <HAL_SPI_Transmit+0x24e>
  }

error:
 802ca34:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 802ca36:	68fb      	ldr	r3, [r7, #12]
 802ca38:	2201      	movs	r2, #1
 802ca3a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802ca3e:	68fb      	ldr	r3, [r7, #12]
 802ca40:	2200      	movs	r2, #0
 802ca42:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  return errorcode;
 802ca46:	7ffb      	ldrb	r3, [r7, #31]
}
 802ca48:	4618      	mov	r0, r3
 802ca4a:	3720      	adds	r7, #32
 802ca4c:	46bd      	mov	sp, r7
 802ca4e:	bd80      	pop	{r7, pc}

0802ca50 <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 802ca50:	b580      	push	{r7, lr}
 802ca52:	b08c      	sub	sp, #48	; 0x30
 802ca54:	af00      	add	r7, sp, #0
 802ca56:	60f8      	str	r0, [r7, #12]
 802ca58:	60b9      	str	r1, [r7, #8]
 802ca5a:	607a      	str	r2, [r7, #4]
 802ca5c:	807b      	strh	r3, [r7, #2]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  uint32_t             tickstart;

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 802ca5e:	2301      	movs	r3, #1
 802ca60:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_StatusTypeDef    errorcode = HAL_OK;
 802ca62:	2300      	movs	r3, #0
 802ca64:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 802ca68:	68fb      	ldr	r3, [r7, #12]
 802ca6a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802ca6e:	2b01      	cmp	r3, #1
 802ca70:	d101      	bne.n	802ca76 <HAL_SPI_TransmitReceive+0x26>
 802ca72:	2302      	movs	r3, #2
 802ca74:	e18a      	b.n	802cd8c <HAL_SPI_TransmitReceive+0x33c>
 802ca76:	68fb      	ldr	r3, [r7, #12]
 802ca78:	2201      	movs	r2, #1
 802ca7a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802ca7e:	f7fe fb69 	bl	802b154 <HAL_GetTick>
 802ca82:	6278      	str	r0, [r7, #36]	; 0x24

  /* Init temporary variables */
  tmp_state           = hspi->State;
 802ca84:	68fb      	ldr	r3, [r7, #12]
 802ca86:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802ca8a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  tmp_mode            = hspi->Init.Mode;
 802ca8e:	68fb      	ldr	r3, [r7, #12]
 802ca90:	685b      	ldr	r3, [r3, #4]
 802ca92:	61fb      	str	r3, [r7, #28]
  initial_TxXferCount = Size;
 802ca94:	887b      	ldrh	r3, [r7, #2]
 802ca96:	837b      	strh	r3, [r7, #26]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 802ca98:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802ca9c:	2b01      	cmp	r3, #1
 802ca9e:	d00f      	beq.n	802cac0 <HAL_SPI_TransmitReceive+0x70>
 802caa0:	69fb      	ldr	r3, [r7, #28]
 802caa2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802caa6:	d107      	bne.n	802cab8 <HAL_SPI_TransmitReceive+0x68>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 802caa8:	68fb      	ldr	r3, [r7, #12]
 802caaa:	689b      	ldr	r3, [r3, #8]
 802caac:	2b00      	cmp	r3, #0
 802caae:	d103      	bne.n	802cab8 <HAL_SPI_TransmitReceive+0x68>
 802cab0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802cab4:	2b04      	cmp	r3, #4
 802cab6:	d003      	beq.n	802cac0 <HAL_SPI_TransmitReceive+0x70>
  {
    errorcode = HAL_BUSY;
 802cab8:	2302      	movs	r3, #2
 802caba:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    goto error;
 802cabe:	e15b      	b.n	802cd78 <HAL_SPI_TransmitReceive+0x328>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 802cac0:	68bb      	ldr	r3, [r7, #8]
 802cac2:	2b00      	cmp	r3, #0
 802cac4:	d005      	beq.n	802cad2 <HAL_SPI_TransmitReceive+0x82>
 802cac6:	687b      	ldr	r3, [r7, #4]
 802cac8:	2b00      	cmp	r3, #0
 802caca:	d002      	beq.n	802cad2 <HAL_SPI_TransmitReceive+0x82>
 802cacc:	887b      	ldrh	r3, [r7, #2]
 802cace:	2b00      	cmp	r3, #0
 802cad0:	d103      	bne.n	802cada <HAL_SPI_TransmitReceive+0x8a>
  {
    errorcode = HAL_ERROR;
 802cad2:	2301      	movs	r3, #1
 802cad4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    goto error;
 802cad8:	e14e      	b.n	802cd78 <HAL_SPI_TransmitReceive+0x328>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 802cada:	68fb      	ldr	r3, [r7, #12]
 802cadc:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802cae0:	b2db      	uxtb	r3, r3
 802cae2:	2b04      	cmp	r3, #4
 802cae4:	d003      	beq.n	802caee <HAL_SPI_TransmitReceive+0x9e>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 802cae6:	68fb      	ldr	r3, [r7, #12]
 802cae8:	2205      	movs	r2, #5
 802caea:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802caee:	68fb      	ldr	r3, [r7, #12]
 802caf0:	2200      	movs	r2, #0
 802caf2:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 802caf4:	68fb      	ldr	r3, [r7, #12]
 802caf6:	687a      	ldr	r2, [r7, #4]
 802caf8:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferCount = Size;
 802cafa:	68fb      	ldr	r3, [r7, #12]
 802cafc:	887a      	ldrh	r2, [r7, #2]
 802cafe:	87da      	strh	r2, [r3, #62]	; 0x3e
  hspi->RxXferSize  = Size;
 802cb00:	68fb      	ldr	r3, [r7, #12]
 802cb02:	887a      	ldrh	r2, [r7, #2]
 802cb04:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 802cb06:	68fb      	ldr	r3, [r7, #12]
 802cb08:	68ba      	ldr	r2, [r7, #8]
 802cb0a:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferCount = Size;
 802cb0c:	68fb      	ldr	r3, [r7, #12]
 802cb0e:	887a      	ldrh	r2, [r7, #2]
 802cb10:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->TxXferSize  = Size;
 802cb12:	68fb      	ldr	r3, [r7, #12]
 802cb14:	887a      	ldrh	r2, [r7, #2]
 802cb16:	869a      	strh	r2, [r3, #52]	; 0x34

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 802cb18:	68fb      	ldr	r3, [r7, #12]
 802cb1a:	2200      	movs	r2, #0
 802cb1c:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 802cb1e:	68fb      	ldr	r3, [r7, #12]
 802cb20:	2200      	movs	r2, #0
 802cb22:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802cb24:	68fb      	ldr	r3, [r7, #12]
 802cb26:	681b      	ldr	r3, [r3, #0]
 802cb28:	681b      	ldr	r3, [r3, #0]
 802cb2a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802cb2e:	2b40      	cmp	r3, #64	; 0x40
 802cb30:	d007      	beq.n	802cb42 <HAL_SPI_TransmitReceive+0xf2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 802cb32:	68fb      	ldr	r3, [r7, #12]
 802cb34:	681b      	ldr	r3, [r3, #0]
 802cb36:	681a      	ldr	r2, [r3, #0]
 802cb38:	68fb      	ldr	r3, [r7, #12]
 802cb3a:	681b      	ldr	r3, [r3, #0]
 802cb3c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802cb40:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 802cb42:	68fb      	ldr	r3, [r7, #12]
 802cb44:	68db      	ldr	r3, [r3, #12]
 802cb46:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 802cb4a:	d178      	bne.n	802cc3e <HAL_SPI_TransmitReceive+0x1ee>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802cb4c:	68fb      	ldr	r3, [r7, #12]
 802cb4e:	685b      	ldr	r3, [r3, #4]
 802cb50:	2b00      	cmp	r3, #0
 802cb52:	d002      	beq.n	802cb5a <HAL_SPI_TransmitReceive+0x10a>
 802cb54:	8b7b      	ldrh	r3, [r7, #26]
 802cb56:	2b01      	cmp	r3, #1
 802cb58:	d166      	bne.n	802cc28 <HAL_SPI_TransmitReceive+0x1d8>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802cb5a:	68fb      	ldr	r3, [r7, #12]
 802cb5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cb5e:	881a      	ldrh	r2, [r3, #0]
 802cb60:	68fb      	ldr	r3, [r7, #12]
 802cb62:	681b      	ldr	r3, [r3, #0]
 802cb64:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 802cb66:	68fb      	ldr	r3, [r7, #12]
 802cb68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cb6a:	1c9a      	adds	r2, r3, #2
 802cb6c:	68fb      	ldr	r3, [r7, #12]
 802cb6e:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802cb70:	68fb      	ldr	r3, [r7, #12]
 802cb72:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cb74:	b29b      	uxth	r3, r3
 802cb76:	3b01      	subs	r3, #1
 802cb78:	b29a      	uxth	r2, r3
 802cb7a:	68fb      	ldr	r3, [r7, #12]
 802cb7c:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802cb7e:	e053      	b.n	802cc28 <HAL_SPI_TransmitReceive+0x1d8>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 802cb80:	68fb      	ldr	r3, [r7, #12]
 802cb82:	681b      	ldr	r3, [r3, #0]
 802cb84:	689b      	ldr	r3, [r3, #8]
 802cb86:	f003 0302 	and.w	r3, r3, #2
 802cb8a:	2b02      	cmp	r3, #2
 802cb8c:	d11b      	bne.n	802cbc6 <HAL_SPI_TransmitReceive+0x176>
 802cb8e:	68fb      	ldr	r3, [r7, #12]
 802cb90:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cb92:	b29b      	uxth	r3, r3
 802cb94:	2b00      	cmp	r3, #0
 802cb96:	d016      	beq.n	802cbc6 <HAL_SPI_TransmitReceive+0x176>
 802cb98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802cb9a:	2b01      	cmp	r3, #1
 802cb9c:	d113      	bne.n	802cbc6 <HAL_SPI_TransmitReceive+0x176>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 802cb9e:	68fb      	ldr	r3, [r7, #12]
 802cba0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cba2:	881a      	ldrh	r2, [r3, #0]
 802cba4:	68fb      	ldr	r3, [r7, #12]
 802cba6:	681b      	ldr	r3, [r3, #0]
 802cba8:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 802cbaa:	68fb      	ldr	r3, [r7, #12]
 802cbac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cbae:	1c9a      	adds	r2, r3, #2
 802cbb0:	68fb      	ldr	r3, [r7, #12]
 802cbb2:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802cbb4:	68fb      	ldr	r3, [r7, #12]
 802cbb6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cbb8:	b29b      	uxth	r3, r3
 802cbba:	3b01      	subs	r3, #1
 802cbbc:	b29a      	uxth	r2, r3
 802cbbe:	68fb      	ldr	r3, [r7, #12]
 802cbc0:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 802cbc2:	2300      	movs	r3, #0
 802cbc4:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 802cbc6:	68fb      	ldr	r3, [r7, #12]
 802cbc8:	681b      	ldr	r3, [r3, #0]
 802cbca:	689b      	ldr	r3, [r3, #8]
 802cbcc:	f003 0301 	and.w	r3, r3, #1
 802cbd0:	2b01      	cmp	r3, #1
 802cbd2:	d119      	bne.n	802cc08 <HAL_SPI_TransmitReceive+0x1b8>
 802cbd4:	68fb      	ldr	r3, [r7, #12]
 802cbd6:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802cbd8:	b29b      	uxth	r3, r3
 802cbda:	2b00      	cmp	r3, #0
 802cbdc:	d014      	beq.n	802cc08 <HAL_SPI_TransmitReceive+0x1b8>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 802cbde:	68fb      	ldr	r3, [r7, #12]
 802cbe0:	681b      	ldr	r3, [r3, #0]
 802cbe2:	68da      	ldr	r2, [r3, #12]
 802cbe4:	68fb      	ldr	r3, [r7, #12]
 802cbe6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802cbe8:	b292      	uxth	r2, r2
 802cbea:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 802cbec:	68fb      	ldr	r3, [r7, #12]
 802cbee:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802cbf0:	1c9a      	adds	r2, r3, #2
 802cbf2:	68fb      	ldr	r3, [r7, #12]
 802cbf4:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 802cbf6:	68fb      	ldr	r3, [r7, #12]
 802cbf8:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802cbfa:	b29b      	uxth	r3, r3
 802cbfc:	3b01      	subs	r3, #1
 802cbfe:	b29a      	uxth	r2, r3
 802cc00:	68fb      	ldr	r3, [r7, #12]
 802cc02:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 802cc04:	2301      	movs	r3, #1
 802cc06:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 802cc08:	f7fe faa4 	bl	802b154 <HAL_GetTick>
 802cc0c:	4602      	mov	r2, r0
 802cc0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802cc10:	1ad3      	subs	r3, r2, r3
 802cc12:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802cc14:	429a      	cmp	r2, r3
 802cc16:	d807      	bhi.n	802cc28 <HAL_SPI_TransmitReceive+0x1d8>
 802cc18:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802cc1a:	f1b3 3fff 	cmp.w	r3, #4294967295
 802cc1e:	d003      	beq.n	802cc28 <HAL_SPI_TransmitReceive+0x1d8>
      {
        errorcode = HAL_TIMEOUT;
 802cc20:	2303      	movs	r3, #3
 802cc22:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        goto error;
 802cc26:	e0a7      	b.n	802cd78 <HAL_SPI_TransmitReceive+0x328>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802cc28:	68fb      	ldr	r3, [r7, #12]
 802cc2a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cc2c:	b29b      	uxth	r3, r3
 802cc2e:	2b00      	cmp	r3, #0
 802cc30:	d1a6      	bne.n	802cb80 <HAL_SPI_TransmitReceive+0x130>
 802cc32:	68fb      	ldr	r3, [r7, #12]
 802cc34:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802cc36:	b29b      	uxth	r3, r3
 802cc38:	2b00      	cmp	r3, #0
 802cc3a:	d1a1      	bne.n	802cb80 <HAL_SPI_TransmitReceive+0x130>
 802cc3c:	e07c      	b.n	802cd38 <HAL_SPI_TransmitReceive+0x2e8>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 802cc3e:	68fb      	ldr	r3, [r7, #12]
 802cc40:	685b      	ldr	r3, [r3, #4]
 802cc42:	2b00      	cmp	r3, #0
 802cc44:	d002      	beq.n	802cc4c <HAL_SPI_TransmitReceive+0x1fc>
 802cc46:	8b7b      	ldrh	r3, [r7, #26]
 802cc48:	2b01      	cmp	r3, #1
 802cc4a:	d16b      	bne.n	802cd24 <HAL_SPI_TransmitReceive+0x2d4>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 802cc4c:	68fb      	ldr	r3, [r7, #12]
 802cc4e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802cc50:	68fb      	ldr	r3, [r7, #12]
 802cc52:	681b      	ldr	r3, [r3, #0]
 802cc54:	330c      	adds	r3, #12
 802cc56:	7812      	ldrb	r2, [r2, #0]
 802cc58:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 802cc5a:	68fb      	ldr	r3, [r7, #12]
 802cc5c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cc5e:	1c5a      	adds	r2, r3, #1
 802cc60:	68fb      	ldr	r3, [r7, #12]
 802cc62:	631a      	str	r2, [r3, #48]	; 0x30
      hspi->TxXferCount--;
 802cc64:	68fb      	ldr	r3, [r7, #12]
 802cc66:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cc68:	b29b      	uxth	r3, r3
 802cc6a:	3b01      	subs	r3, #1
 802cc6c:	b29a      	uxth	r2, r3
 802cc6e:	68fb      	ldr	r3, [r7, #12]
 802cc70:	86da      	strh	r2, [r3, #54]	; 0x36
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802cc72:	e057      	b.n	802cd24 <HAL_SPI_TransmitReceive+0x2d4>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 802cc74:	68fb      	ldr	r3, [r7, #12]
 802cc76:	681b      	ldr	r3, [r3, #0]
 802cc78:	689b      	ldr	r3, [r3, #8]
 802cc7a:	f003 0302 	and.w	r3, r3, #2
 802cc7e:	2b02      	cmp	r3, #2
 802cc80:	d11c      	bne.n	802ccbc <HAL_SPI_TransmitReceive+0x26c>
 802cc82:	68fb      	ldr	r3, [r7, #12]
 802cc84:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cc86:	b29b      	uxth	r3, r3
 802cc88:	2b00      	cmp	r3, #0
 802cc8a:	d017      	beq.n	802ccbc <HAL_SPI_TransmitReceive+0x26c>
 802cc8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802cc8e:	2b01      	cmp	r3, #1
 802cc90:	d114      	bne.n	802ccbc <HAL_SPI_TransmitReceive+0x26c>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 802cc92:	68fb      	ldr	r3, [r7, #12]
 802cc94:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 802cc96:	68fb      	ldr	r3, [r7, #12]
 802cc98:	681b      	ldr	r3, [r3, #0]
 802cc9a:	330c      	adds	r3, #12
 802cc9c:	7812      	ldrb	r2, [r2, #0]
 802cc9e:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 802cca0:	68fb      	ldr	r3, [r7, #12]
 802cca2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cca4:	1c5a      	adds	r2, r3, #1
 802cca6:	68fb      	ldr	r3, [r7, #12]
 802cca8:	631a      	str	r2, [r3, #48]	; 0x30
        hspi->TxXferCount--;
 802ccaa:	68fb      	ldr	r3, [r7, #12]
 802ccac:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802ccae:	b29b      	uxth	r3, r3
 802ccb0:	3b01      	subs	r3, #1
 802ccb2:	b29a      	uxth	r2, r3
 802ccb4:	68fb      	ldr	r3, [r7, #12]
 802ccb6:	86da      	strh	r2, [r3, #54]	; 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 802ccb8:	2300      	movs	r3, #0
 802ccba:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 802ccbc:	68fb      	ldr	r3, [r7, #12]
 802ccbe:	681b      	ldr	r3, [r3, #0]
 802ccc0:	689b      	ldr	r3, [r3, #8]
 802ccc2:	f003 0301 	and.w	r3, r3, #1
 802ccc6:	2b01      	cmp	r3, #1
 802ccc8:	d119      	bne.n	802ccfe <HAL_SPI_TransmitReceive+0x2ae>
 802ccca:	68fb      	ldr	r3, [r7, #12]
 802cccc:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802ccce:	b29b      	uxth	r3, r3
 802ccd0:	2b00      	cmp	r3, #0
 802ccd2:	d014      	beq.n	802ccfe <HAL_SPI_TransmitReceive+0x2ae>
      {
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 802ccd4:	68fb      	ldr	r3, [r7, #12]
 802ccd6:	681b      	ldr	r3, [r3, #0]
 802ccd8:	68da      	ldr	r2, [r3, #12]
 802ccda:	68fb      	ldr	r3, [r7, #12]
 802ccdc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802ccde:	b2d2      	uxtb	r2, r2
 802cce0:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 802cce2:	68fb      	ldr	r3, [r7, #12]
 802cce4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802cce6:	1c5a      	adds	r2, r3, #1
 802cce8:	68fb      	ldr	r3, [r7, #12]
 802ccea:	639a      	str	r2, [r3, #56]	; 0x38
        hspi->RxXferCount--;
 802ccec:	68fb      	ldr	r3, [r7, #12]
 802ccee:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802ccf0:	b29b      	uxth	r3, r3
 802ccf2:	3b01      	subs	r3, #1
 802ccf4:	b29a      	uxth	r2, r3
 802ccf6:	68fb      	ldr	r3, [r7, #12]
 802ccf8:	87da      	strh	r2, [r3, #62]	; 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 802ccfa:	2301      	movs	r3, #1
 802ccfc:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 802ccfe:	f7fe fa29 	bl	802b154 <HAL_GetTick>
 802cd02:	4602      	mov	r2, r0
 802cd04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802cd06:	1ad3      	subs	r3, r2, r3
 802cd08:	6bba      	ldr	r2, [r7, #56]	; 0x38
 802cd0a:	429a      	cmp	r2, r3
 802cd0c:	d803      	bhi.n	802cd16 <HAL_SPI_TransmitReceive+0x2c6>
 802cd0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802cd10:	f1b3 3fff 	cmp.w	r3, #4294967295
 802cd14:	d102      	bne.n	802cd1c <HAL_SPI_TransmitReceive+0x2cc>
 802cd16:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802cd18:	2b00      	cmp	r3, #0
 802cd1a:	d103      	bne.n	802cd24 <HAL_SPI_TransmitReceive+0x2d4>
      {
        errorcode = HAL_TIMEOUT;
 802cd1c:	2303      	movs	r3, #3
 802cd1e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        goto error;
 802cd22:	e029      	b.n	802cd78 <HAL_SPI_TransmitReceive+0x328>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 802cd24:	68fb      	ldr	r3, [r7, #12]
 802cd26:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cd28:	b29b      	uxth	r3, r3
 802cd2a:	2b00      	cmp	r3, #0
 802cd2c:	d1a2      	bne.n	802cc74 <HAL_SPI_TransmitReceive+0x224>
 802cd2e:	68fb      	ldr	r3, [r7, #12]
 802cd30:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802cd32:	b29b      	uxth	r3, r3
 802cd34:	2b00      	cmp	r3, #0
 802cd36:	d19d      	bne.n	802cc74 <HAL_SPI_TransmitReceive+0x224>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 802cd38:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 802cd3a:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 802cd3c:	68f8      	ldr	r0, [r7, #12]
 802cd3e:	f000 fb2d 	bl	802d39c <SPI_EndRxTxTransaction>
 802cd42:	4603      	mov	r3, r0
 802cd44:	2b00      	cmp	r3, #0
 802cd46:	d006      	beq.n	802cd56 <HAL_SPI_TransmitReceive+0x306>
  {
    errorcode = HAL_ERROR;
 802cd48:	2301      	movs	r3, #1
 802cd4a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 802cd4e:	68fb      	ldr	r3, [r7, #12]
 802cd50:	2220      	movs	r2, #32
 802cd52:	655a      	str	r2, [r3, #84]	; 0x54
    goto error;
 802cd54:	e010      	b.n	802cd78 <HAL_SPI_TransmitReceive+0x328>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 802cd56:	68fb      	ldr	r3, [r7, #12]
 802cd58:	689b      	ldr	r3, [r3, #8]
 802cd5a:	2b00      	cmp	r3, #0
 802cd5c:	d10b      	bne.n	802cd76 <HAL_SPI_TransmitReceive+0x326>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 802cd5e:	2300      	movs	r3, #0
 802cd60:	617b      	str	r3, [r7, #20]
 802cd62:	68fb      	ldr	r3, [r7, #12]
 802cd64:	681b      	ldr	r3, [r3, #0]
 802cd66:	68db      	ldr	r3, [r3, #12]
 802cd68:	617b      	str	r3, [r7, #20]
 802cd6a:	68fb      	ldr	r3, [r7, #12]
 802cd6c:	681b      	ldr	r3, [r3, #0]
 802cd6e:	689b      	ldr	r3, [r3, #8]
 802cd70:	617b      	str	r3, [r7, #20]
 802cd72:	697b      	ldr	r3, [r7, #20]
 802cd74:	e000      	b.n	802cd78 <HAL_SPI_TransmitReceive+0x328>
  }

error :
 802cd76:	bf00      	nop
  hspi->State = HAL_SPI_STATE_READY;
 802cd78:	68fb      	ldr	r3, [r7, #12]
 802cd7a:	2201      	movs	r2, #1
 802cd7c:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  __HAL_UNLOCK(hspi);
 802cd80:	68fb      	ldr	r3, [r7, #12]
 802cd82:	2200      	movs	r2, #0
 802cd84:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  return errorcode;
 802cd88:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
}
 802cd8c:	4618      	mov	r0, r3
 802cd8e:	3730      	adds	r7, #48	; 0x30
 802cd90:	46bd      	mov	sp, r7
 802cd92:	bd80      	pop	{r7, pc}

0802cd94 <HAL_SPI_TransmitReceive_DMA>:
  * @param  Size amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
                                              uint16_t Size)
{
 802cd94:	b580      	push	{r7, lr}
 802cd96:	b086      	sub	sp, #24
 802cd98:	af00      	add	r7, sp, #0
 802cd9a:	60f8      	str	r0, [r7, #12]
 802cd9c:	60b9      	str	r1, [r7, #8]
 802cd9e:	607a      	str	r2, [r7, #4]
 802cda0:	807b      	strh	r3, [r7, #2]
  uint32_t             tmp_mode;
  HAL_SPI_StateTypeDef tmp_state;
  HAL_StatusTypeDef errorcode = HAL_OK;
 802cda2:	2300      	movs	r3, #0
 802cda4:	75fb      	strb	r3, [r7, #23]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process locked */
  __HAL_LOCK(hspi);
 802cda6:	68fb      	ldr	r3, [r7, #12]
 802cda8:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802cdac:	2b01      	cmp	r3, #1
 802cdae:	d101      	bne.n	802cdb4 <HAL_SPI_TransmitReceive_DMA+0x20>
 802cdb0:	2302      	movs	r3, #2
 802cdb2:	e0e3      	b.n	802cf7c <HAL_SPI_TransmitReceive_DMA+0x1e8>
 802cdb4:	68fb      	ldr	r3, [r7, #12]
 802cdb6:	2201      	movs	r2, #1
 802cdb8:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Init temporary variables */
  tmp_state           = hspi->State;
 802cdbc:	68fb      	ldr	r3, [r7, #12]
 802cdbe:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802cdc2:	75bb      	strb	r3, [r7, #22]
  tmp_mode            = hspi->Init.Mode;
 802cdc4:	68fb      	ldr	r3, [r7, #12]
 802cdc6:	685b      	ldr	r3, [r3, #4]
 802cdc8:	613b      	str	r3, [r7, #16]

  if (!((tmp_state == HAL_SPI_STATE_READY) ||
 802cdca:	7dbb      	ldrb	r3, [r7, #22]
 802cdcc:	2b01      	cmp	r3, #1
 802cdce:	d00d      	beq.n	802cdec <HAL_SPI_TransmitReceive_DMA+0x58>
 802cdd0:	693b      	ldr	r3, [r7, #16]
 802cdd2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802cdd6:	d106      	bne.n	802cde6 <HAL_SPI_TransmitReceive_DMA+0x52>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 802cdd8:	68fb      	ldr	r3, [r7, #12]
 802cdda:	689b      	ldr	r3, [r3, #8]
 802cddc:	2b00      	cmp	r3, #0
 802cdde:	d102      	bne.n	802cde6 <HAL_SPI_TransmitReceive_DMA+0x52>
 802cde0:	7dbb      	ldrb	r3, [r7, #22]
 802cde2:	2b04      	cmp	r3, #4
 802cde4:	d002      	beq.n	802cdec <HAL_SPI_TransmitReceive_DMA+0x58>
  {
    errorcode = HAL_BUSY;
 802cde6:	2302      	movs	r3, #2
 802cde8:	75fb      	strb	r3, [r7, #23]
    goto error;
 802cdea:	e0c2      	b.n	802cf72 <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 802cdec:	68bb      	ldr	r3, [r7, #8]
 802cdee:	2b00      	cmp	r3, #0
 802cdf0:	d005      	beq.n	802cdfe <HAL_SPI_TransmitReceive_DMA+0x6a>
 802cdf2:	687b      	ldr	r3, [r7, #4]
 802cdf4:	2b00      	cmp	r3, #0
 802cdf6:	d002      	beq.n	802cdfe <HAL_SPI_TransmitReceive_DMA+0x6a>
 802cdf8:	887b      	ldrh	r3, [r7, #2]
 802cdfa:	2b00      	cmp	r3, #0
 802cdfc:	d102      	bne.n	802ce04 <HAL_SPI_TransmitReceive_DMA+0x70>
  {
    errorcode = HAL_ERROR;
 802cdfe:	2301      	movs	r3, #1
 802ce00:	75fb      	strb	r3, [r7, #23]
    goto error;
 802ce02:	e0b6      	b.n	802cf72 <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 802ce04:	68fb      	ldr	r3, [r7, #12]
 802ce06:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802ce0a:	b2db      	uxtb	r3, r3
 802ce0c:	2b04      	cmp	r3, #4
 802ce0e:	d003      	beq.n	802ce18 <HAL_SPI_TransmitReceive_DMA+0x84>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 802ce10:	68fb      	ldr	r3, [r7, #12]
 802ce12:	2205      	movs	r2, #5
 802ce14:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 802ce18:	68fb      	ldr	r3, [r7, #12]
 802ce1a:	2200      	movs	r2, #0
 802ce1c:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 802ce1e:	68fb      	ldr	r3, [r7, #12]
 802ce20:	68ba      	ldr	r2, [r7, #8]
 802ce22:	631a      	str	r2, [r3, #48]	; 0x30
  hspi->TxXferSize  = Size;
 802ce24:	68fb      	ldr	r3, [r7, #12]
 802ce26:	887a      	ldrh	r2, [r7, #2]
 802ce28:	869a      	strh	r2, [r3, #52]	; 0x34
  hspi->TxXferCount = Size;
 802ce2a:	68fb      	ldr	r3, [r7, #12]
 802ce2c:	887a      	ldrh	r2, [r7, #2]
 802ce2e:	86da      	strh	r2, [r3, #54]	; 0x36
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 802ce30:	68fb      	ldr	r3, [r7, #12]
 802ce32:	687a      	ldr	r2, [r7, #4]
 802ce34:	639a      	str	r2, [r3, #56]	; 0x38
  hspi->RxXferSize  = Size;
 802ce36:	68fb      	ldr	r3, [r7, #12]
 802ce38:	887a      	ldrh	r2, [r7, #2]
 802ce3a:	879a      	strh	r2, [r3, #60]	; 0x3c
  hspi->RxXferCount = Size;
 802ce3c:	68fb      	ldr	r3, [r7, #12]
 802ce3e:	887a      	ldrh	r2, [r7, #2]
 802ce40:	87da      	strh	r2, [r3, #62]	; 0x3e

  /* Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 802ce42:	68fb      	ldr	r3, [r7, #12]
 802ce44:	2200      	movs	r2, #0
 802ce46:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->TxISR       = NULL;
 802ce48:	68fb      	ldr	r3, [r7, #12]
 802ce4a:	2200      	movs	r2, #0
 802ce4c:	645a      	str	r2, [r3, #68]	; 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
  if (hspi->State == HAL_SPI_STATE_BUSY_RX)
 802ce4e:	68fb      	ldr	r3, [r7, #12]
 802ce50:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
 802ce54:	b2db      	uxtb	r3, r3
 802ce56:	2b04      	cmp	r3, #4
 802ce58:	d108      	bne.n	802ce6c <HAL_SPI_TransmitReceive_DMA+0xd8>
  {
    /* Set the SPI Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
 802ce5a:	68fb      	ldr	r3, [r7, #12]
 802ce5c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802ce5e:	4a49      	ldr	r2, [pc, #292]	; (802cf84 <HAL_SPI_TransmitReceive_DMA+0x1f0>)
 802ce60:	641a      	str	r2, [r3, #64]	; 0x40
    hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
 802ce62:	68fb      	ldr	r3, [r7, #12]
 802ce64:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802ce66:	4a48      	ldr	r2, [pc, #288]	; (802cf88 <HAL_SPI_TransmitReceive_DMA+0x1f4>)
 802ce68:	63da      	str	r2, [r3, #60]	; 0x3c
 802ce6a:	e007      	b.n	802ce7c <HAL_SPI_TransmitReceive_DMA+0xe8>
  }
  else
  {
    /* Set the SPI Tx/Rx DMA Half transfer complete callback */
    hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
 802ce6c:	68fb      	ldr	r3, [r7, #12]
 802ce6e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802ce70:	4a46      	ldr	r2, [pc, #280]	; (802cf8c <HAL_SPI_TransmitReceive_DMA+0x1f8>)
 802ce72:	641a      	str	r2, [r3, #64]	; 0x40
    hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
 802ce74:	68fb      	ldr	r3, [r7, #12]
 802ce76:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802ce78:	4a45      	ldr	r2, [pc, #276]	; (802cf90 <HAL_SPI_TransmitReceive_DMA+0x1fc>)
 802ce7a:	63da      	str	r2, [r3, #60]	; 0x3c
  }

  /* Set the DMA error callback */
  hspi->hdmarx->XferErrorCallback = SPI_DMAError;
 802ce7c:	68fb      	ldr	r3, [r7, #12]
 802ce7e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802ce80:	4a44      	ldr	r2, [pc, #272]	; (802cf94 <HAL_SPI_TransmitReceive_DMA+0x200>)
 802ce82:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set the DMA AbortCpltCallback */
  hspi->hdmarx->XferAbortCallback = NULL;
 802ce84:	68fb      	ldr	r3, [r7, #12]
 802ce86:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802ce88:	2200      	movs	r2, #0
 802ce8a:	651a      	str	r2, [r3, #80]	; 0x50

  /* Enable the Rx DMA Stream/Channel  */
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 802ce8c:	68fb      	ldr	r3, [r7, #12]
 802ce8e:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 802ce90:	68fb      	ldr	r3, [r7, #12]
 802ce92:	681b      	ldr	r3, [r3, #0]
 802ce94:	330c      	adds	r3, #12
 802ce96:	4619      	mov	r1, r3
 802ce98:	68fb      	ldr	r3, [r7, #12]
 802ce9a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802ce9c:	461a      	mov	r2, r3
                                 hspi->RxXferCount))
 802ce9e:	68fb      	ldr	r3, [r7, #12]
 802cea0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 802cea2:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
 802cea4:	f7fe fb44 	bl	802b530 <HAL_DMA_Start_IT>
 802cea8:	4603      	mov	r3, r0
 802ceaa:	2b00      	cmp	r3, #0
 802ceac:	d00c      	beq.n	802cec8 <HAL_SPI_TransmitReceive_DMA+0x134>
  {
    /* Update SPI error code */
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 802ceae:	68fb      	ldr	r3, [r7, #12]
 802ceb0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802ceb2:	f043 0210 	orr.w	r2, r3, #16
 802ceb6:	68fb      	ldr	r3, [r7, #12]
 802ceb8:	655a      	str	r2, [r3, #84]	; 0x54
    errorcode = HAL_ERROR;
 802ceba:	2301      	movs	r3, #1
 802cebc:	75fb      	strb	r3, [r7, #23]

    hspi->State = HAL_SPI_STATE_READY;
 802cebe:	68fb      	ldr	r3, [r7, #12]
 802cec0:	2201      	movs	r2, #1
 802cec2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    goto error;
 802cec6:	e054      	b.n	802cf72 <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  /* Enable Rx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
 802cec8:	68fb      	ldr	r3, [r7, #12]
 802ceca:	681b      	ldr	r3, [r3, #0]
 802cecc:	685a      	ldr	r2, [r3, #4]
 802cece:	68fb      	ldr	r3, [r7, #12]
 802ced0:	681b      	ldr	r3, [r3, #0]
 802ced2:	f042 0201 	orr.w	r2, r2, #1
 802ced6:	605a      	str	r2, [r3, #4]

  /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
  is performed in DMA reception complete callback  */
  hspi->hdmatx->XferHalfCpltCallback = NULL;
 802ced8:	68fb      	ldr	r3, [r7, #12]
 802ceda:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802cedc:	2200      	movs	r2, #0
 802cede:	641a      	str	r2, [r3, #64]	; 0x40
  hspi->hdmatx->XferCpltCallback     = NULL;
 802cee0:	68fb      	ldr	r3, [r7, #12]
 802cee2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802cee4:	2200      	movs	r2, #0
 802cee6:	63da      	str	r2, [r3, #60]	; 0x3c
  hspi->hdmatx->XferErrorCallback    = NULL;
 802cee8:	68fb      	ldr	r3, [r7, #12]
 802ceea:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802ceec:	2200      	movs	r2, #0
 802ceee:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi->hdmatx->XferAbortCallback    = NULL;
 802cef0:	68fb      	ldr	r3, [r7, #12]
 802cef2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 802cef4:	2200      	movs	r2, #0
 802cef6:	651a      	str	r2, [r3, #80]	; 0x50

  /* Enable the Tx DMA Stream/Channel  */
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 802cef8:	68fb      	ldr	r3, [r7, #12]
 802cefa:	6c98      	ldr	r0, [r3, #72]	; 0x48
 802cefc:	68fb      	ldr	r3, [r7, #12]
 802cefe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802cf00:	4619      	mov	r1, r3
 802cf02:	68fb      	ldr	r3, [r7, #12]
 802cf04:	681b      	ldr	r3, [r3, #0]
 802cf06:	330c      	adds	r3, #12
 802cf08:	461a      	mov	r2, r3
                                 hspi->TxXferCount))
 802cf0a:	68fb      	ldr	r3, [r7, #12]
 802cf0c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 802cf0e:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 802cf10:	f7fe fb0e 	bl	802b530 <HAL_DMA_Start_IT>
 802cf14:	4603      	mov	r3, r0
 802cf16:	2b00      	cmp	r3, #0
 802cf18:	d00c      	beq.n	802cf34 <HAL_SPI_TransmitReceive_DMA+0x1a0>
  {
    /* Update SPI error code */
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 802cf1a:	68fb      	ldr	r3, [r7, #12]
 802cf1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802cf1e:	f043 0210 	orr.w	r2, r3, #16
 802cf22:	68fb      	ldr	r3, [r7, #12]
 802cf24:	655a      	str	r2, [r3, #84]	; 0x54
    errorcode = HAL_ERROR;
 802cf26:	2301      	movs	r3, #1
 802cf28:	75fb      	strb	r3, [r7, #23]

    hspi->State = HAL_SPI_STATE_READY;
 802cf2a:	68fb      	ldr	r3, [r7, #12]
 802cf2c:	2201      	movs	r2, #1
 802cf2e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
    goto error;
 802cf32:	e01e      	b.n	802cf72 <HAL_SPI_TransmitReceive_DMA+0x1de>
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 802cf34:	68fb      	ldr	r3, [r7, #12]
 802cf36:	681b      	ldr	r3, [r3, #0]
 802cf38:	681b      	ldr	r3, [r3, #0]
 802cf3a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802cf3e:	2b40      	cmp	r3, #64	; 0x40
 802cf40:	d007      	beq.n	802cf52 <HAL_SPI_TransmitReceive_DMA+0x1be>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 802cf42:	68fb      	ldr	r3, [r7, #12]
 802cf44:	681b      	ldr	r3, [r3, #0]
 802cf46:	681a      	ldr	r2, [r3, #0]
 802cf48:	68fb      	ldr	r3, [r7, #12]
 802cf4a:	681b      	ldr	r3, [r3, #0]
 802cf4c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802cf50:	601a      	str	r2, [r3, #0]
  }
  /* Enable the SPI Error Interrupt Bit */
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 802cf52:	68fb      	ldr	r3, [r7, #12]
 802cf54:	681b      	ldr	r3, [r3, #0]
 802cf56:	685a      	ldr	r2, [r3, #4]
 802cf58:	68fb      	ldr	r3, [r7, #12]
 802cf5a:	681b      	ldr	r3, [r3, #0]
 802cf5c:	f042 0220 	orr.w	r2, r2, #32
 802cf60:	605a      	str	r2, [r3, #4]

  /* Enable Tx DMA Request */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 802cf62:	68fb      	ldr	r3, [r7, #12]
 802cf64:	681b      	ldr	r3, [r3, #0]
 802cf66:	685a      	ldr	r2, [r3, #4]
 802cf68:	68fb      	ldr	r3, [r7, #12]
 802cf6a:	681b      	ldr	r3, [r3, #0]
 802cf6c:	f042 0202 	orr.w	r2, r2, #2
 802cf70:	605a      	str	r2, [r3, #4]

error :
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802cf72:	68fb      	ldr	r3, [r7, #12]
 802cf74:	2200      	movs	r2, #0
 802cf76:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
  return errorcode;
 802cf7a:	7dfb      	ldrb	r3, [r7, #23]
}
 802cf7c:	4618      	mov	r0, r3
 802cf7e:	3718      	adds	r7, #24
 802cf80:	46bd      	mov	sp, r7
 802cf82:	bd80      	pop	{r7, pc}
 802cf84:	0802d185 	.word	0x0802d185
 802cf88:	0802d071 	.word	0x0802d071
 802cf8c:	0802d1a1 	.word	0x0802d1a1
 802cf90:	0802d0f5 	.word	0x0802d0f5
 802cf94:	0802d1bd 	.word	0x0802d1bd

0802cf98 <HAL_SPI_DMAPause>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
{
 802cf98:	b480      	push	{r7}
 802cf9a:	b083      	sub	sp, #12
 802cf9c:	af00      	add	r7, sp, #0
 802cf9e:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hspi);
 802cfa0:	687b      	ldr	r3, [r7, #4]
 802cfa2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802cfa6:	2b01      	cmp	r3, #1
 802cfa8:	d101      	bne.n	802cfae <HAL_SPI_DMAPause+0x16>
 802cfaa:	2302      	movs	r3, #2
 802cfac:	e010      	b.n	802cfd0 <HAL_SPI_DMAPause+0x38>
 802cfae:	687b      	ldr	r3, [r7, #4]
 802cfb0:	2201      	movs	r2, #1
 802cfb2:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Disable the SPI DMA Tx & Rx requests */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802cfb6:	687b      	ldr	r3, [r7, #4]
 802cfb8:	681b      	ldr	r3, [r3, #0]
 802cfba:	685a      	ldr	r2, [r3, #4]
 802cfbc:	687b      	ldr	r3, [r7, #4]
 802cfbe:	681b      	ldr	r3, [r3, #0]
 802cfc0:	f022 0203 	bic.w	r2, r2, #3
 802cfc4:	605a      	str	r2, [r3, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802cfc6:	687b      	ldr	r3, [r7, #4]
 802cfc8:	2200      	movs	r2, #0
 802cfca:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 802cfce:	2300      	movs	r3, #0
}
 802cfd0:	4618      	mov	r0, r3
 802cfd2:	370c      	adds	r7, #12
 802cfd4:	46bd      	mov	sp, r7
 802cfd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802cfda:	4770      	bx	lr

0802cfdc <HAL_SPI_DMAResume>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
{
 802cfdc:	b480      	push	{r7}
 802cfde:	b083      	sub	sp, #12
 802cfe0:	af00      	add	r7, sp, #0
 802cfe2:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hspi);
 802cfe4:	687b      	ldr	r3, [r7, #4]
 802cfe6:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 802cfea:	2b01      	cmp	r3, #1
 802cfec:	d101      	bne.n	802cff2 <HAL_SPI_DMAResume+0x16>
 802cfee:	2302      	movs	r3, #2
 802cff0:	e010      	b.n	802d014 <HAL_SPI_DMAResume+0x38>
 802cff2:	687b      	ldr	r3, [r7, #4]
 802cff4:	2201      	movs	r2, #1
 802cff6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Enable the SPI DMA Tx & Rx requests */
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802cffa:	687b      	ldr	r3, [r7, #4]
 802cffc:	681b      	ldr	r3, [r3, #0]
 802cffe:	685a      	ldr	r2, [r3, #4]
 802d000:	687b      	ldr	r3, [r7, #4]
 802d002:	681b      	ldr	r3, [r3, #0]
 802d004:	f042 0203 	orr.w	r2, r2, #3
 802d008:	605a      	str	r2, [r3, #4]

  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 802d00a:	687b      	ldr	r3, [r7, #4]
 802d00c:	2200      	movs	r2, #0
 802d00e:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
 802d012:	2300      	movs	r3, #0
}
 802d014:	4618      	mov	r0, r3
 802d016:	370c      	adds	r7, #12
 802d018:	46bd      	mov	sp, r7
 802d01a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d01e:	4770      	bx	lr

0802d020 <HAL_SPI_RxCpltCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
 802d020:	b480      	push	{r7}
 802d022:	b083      	sub	sp, #12
 802d024:	af00      	add	r7, sp, #0
 802d026:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback should be implemented in the user file
   */
}
 802d028:	bf00      	nop
 802d02a:	370c      	adds	r7, #12
 802d02c:	46bd      	mov	sp, r7
 802d02e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d032:	4770      	bx	lr

0802d034 <HAL_SPI_RxHalfCpltCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 802d034:	b480      	push	{r7}
 802d036:	b083      	sub	sp, #12
 802d038:	af00      	add	r7, sp, #0
 802d03a:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   */
}
 802d03c:	bf00      	nop
 802d03e:	370c      	adds	r7, #12
 802d040:	46bd      	mov	sp, r7
 802d042:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d046:	4770      	bx	lr

0802d048 <HAL_SPI_TxRxHalfCpltCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
{
 802d048:	b480      	push	{r7}
 802d04a:	b083      	sub	sp, #12
 802d04c:	af00      	add	r7, sp, #0
 802d04e:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   */
}
 802d050:	bf00      	nop
 802d052:	370c      	adds	r7, #12
 802d054:	46bd      	mov	sp, r7
 802d056:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d05a:	4770      	bx	lr

0802d05c <HAL_SPI_ErrorCallback>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 802d05c:	b480      	push	{r7}
 802d05e:	b083      	sub	sp, #12
 802d060:	af00      	add	r7, sp, #0
 802d062:	6078      	str	r0, [r7, #4]
            the HAL_SPI_ErrorCallback should be implemented in the user file
   */
  /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
            and user can use HAL_SPI_GetError() API to check the latest error occurred
   */
}
 802d064:	bf00      	nop
 802d066:	370c      	adds	r7, #12
 802d068:	46bd      	mov	sp, r7
 802d06a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d06e:	4770      	bx	lr

0802d070 <SPI_DMAReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802d070:	b580      	push	{r7, lr}
 802d072:	b084      	sub	sp, #16
 802d074:	af00      	add	r7, sp, #0
 802d076:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802d078:	687b      	ldr	r3, [r7, #4]
 802d07a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d07c:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802d07e:	f7fe f869 	bl	802b154 <HAL_GetTick>
 802d082:	60b8      	str	r0, [r7, #8]

  /* DMA Normal Mode */
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
 802d084:	687b      	ldr	r3, [r7, #4]
 802d086:	681b      	ldr	r3, [r3, #0]
 802d088:	681b      	ldr	r3, [r3, #0]
 802d08a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802d08e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802d092:	d029      	beq.n	802d0e8 <SPI_DMAReceiveCplt+0x78>
  {
    /* Disable ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 802d094:	68fb      	ldr	r3, [r7, #12]
 802d096:	681b      	ldr	r3, [r3, #0]
 802d098:	685a      	ldr	r2, [r3, #4]
 802d09a:	68fb      	ldr	r3, [r7, #12]
 802d09c:	681b      	ldr	r3, [r3, #0]
 802d09e:	f022 0220 	bic.w	r2, r2, #32
 802d0a2:	605a      	str	r2, [r3, #4]
      READ_REG(hspi->Instance->DR);
    }
#endif /* USE_SPI_CRC */

    /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802d0a4:	68fb      	ldr	r3, [r7, #12]
 802d0a6:	681b      	ldr	r3, [r3, #0]
 802d0a8:	685a      	ldr	r2, [r3, #4]
 802d0aa:	68fb      	ldr	r3, [r7, #12]
 802d0ac:	681b      	ldr	r3, [r3, #0]
 802d0ae:	f022 0203 	bic.w	r2, r2, #3
 802d0b2:	605a      	str	r2, [r3, #4]

    /* Check the end of the transaction */
    if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 802d0b4:	68ba      	ldr	r2, [r7, #8]
 802d0b6:	2164      	movs	r1, #100	; 0x64
 802d0b8:	68f8      	ldr	r0, [r7, #12]
 802d0ba:	f000 f909 	bl	802d2d0 <SPI_EndRxTransaction>
 802d0be:	4603      	mov	r3, r0
 802d0c0:	2b00      	cmp	r3, #0
 802d0c2:	d002      	beq.n	802d0ca <SPI_DMAReceiveCplt+0x5a>
    {
      hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 802d0c4:	68fb      	ldr	r3, [r7, #12]
 802d0c6:	2220      	movs	r2, #32
 802d0c8:	655a      	str	r2, [r3, #84]	; 0x54
    }

    hspi->RxXferCount = 0U;
 802d0ca:	68fb      	ldr	r3, [r7, #12]
 802d0cc:	2200      	movs	r2, #0
 802d0ce:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 802d0d0:	68fb      	ldr	r3, [r7, #12]
 802d0d2:	2201      	movs	r2, #1
 802d0d4:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    }
#endif /* USE_SPI_CRC */

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 802d0d8:	68fb      	ldr	r3, [r7, #12]
 802d0da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d0dc:	2b00      	cmp	r3, #0
 802d0de:	d003      	beq.n	802d0e8 <SPI_DMAReceiveCplt+0x78>
    {
      /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
 802d0e0:	68f8      	ldr	r0, [r7, #12]
 802d0e2:	f7ff ffbb 	bl	802d05c <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      return;
 802d0e6:	e002      	b.n	802d0ee <SPI_DMAReceiveCplt+0x7e>
  }
  /* Call user Rx complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->RxCpltCallback(hspi);
#else
  HAL_SPI_RxCpltCallback(hspi);
 802d0e8:	68f8      	ldr	r0, [r7, #12]
 802d0ea:	f7ff ff99 	bl	802d020 <HAL_SPI_RxCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802d0ee:	3710      	adds	r7, #16
 802d0f0:	46bd      	mov	sp, r7
 802d0f2:	bd80      	pop	{r7, pc}

0802d0f4 <SPI_DMATransmitReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802d0f4:	b580      	push	{r7, lr}
 802d0f6:	b084      	sub	sp, #16
 802d0f8:	af00      	add	r7, sp, #0
 802d0fa:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802d0fc:	687b      	ldr	r3, [r7, #4]
 802d0fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d100:	60fb      	str	r3, [r7, #12]
  uint32_t tickstart;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 802d102:	f7fe f827 	bl	802b154 <HAL_GetTick>
 802d106:	60b8      	str	r0, [r7, #8]

  /* DMA Normal Mode */
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
 802d108:	687b      	ldr	r3, [r7, #4]
 802d10a:	681b      	ldr	r3, [r3, #0]
 802d10c:	681b      	ldr	r3, [r3, #0]
 802d10e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802d112:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802d116:	d02f      	beq.n	802d178 <SPI_DMATransmitReceiveCplt+0x84>
  {
    /* Disable ERR interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 802d118:	68fb      	ldr	r3, [r7, #12]
 802d11a:	681b      	ldr	r3, [r3, #0]
 802d11c:	685a      	ldr	r2, [r3, #4]
 802d11e:	68fb      	ldr	r3, [r7, #12]
 802d120:	681b      	ldr	r3, [r3, #0]
 802d122:	f022 0220 	bic.w	r2, r2, #32
 802d126:	605a      	str	r2, [r3, #4]
      READ_REG(hspi->Instance->DR);
    }
#endif /* USE_SPI_CRC */

    /* Check the end of the transaction */
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 802d128:	68ba      	ldr	r2, [r7, #8]
 802d12a:	2164      	movs	r1, #100	; 0x64
 802d12c:	68f8      	ldr	r0, [r7, #12]
 802d12e:	f000 f935 	bl	802d39c <SPI_EndRxTxTransaction>
 802d132:	4603      	mov	r3, r0
 802d134:	2b00      	cmp	r3, #0
 802d136:	d005      	beq.n	802d144 <SPI_DMATransmitReceiveCplt+0x50>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802d138:	68fb      	ldr	r3, [r7, #12]
 802d13a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d13c:	f043 0220 	orr.w	r2, r3, #32
 802d140:	68fb      	ldr	r3, [r7, #12]
 802d142:	655a      	str	r2, [r3, #84]	; 0x54
    }

    /* Disable Rx/Tx DMA Request */
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802d144:	68fb      	ldr	r3, [r7, #12]
 802d146:	681b      	ldr	r3, [r3, #0]
 802d148:	685a      	ldr	r2, [r3, #4]
 802d14a:	68fb      	ldr	r3, [r7, #12]
 802d14c:	681b      	ldr	r3, [r3, #0]
 802d14e:	f022 0203 	bic.w	r2, r2, #3
 802d152:	605a      	str	r2, [r3, #4]

    hspi->TxXferCount = 0U;
 802d154:	68fb      	ldr	r3, [r7, #12]
 802d156:	2200      	movs	r2, #0
 802d158:	86da      	strh	r2, [r3, #54]	; 0x36
    hspi->RxXferCount = 0U;
 802d15a:	68fb      	ldr	r3, [r7, #12]
 802d15c:	2200      	movs	r2, #0
 802d15e:	87da      	strh	r2, [r3, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 802d160:	68fb      	ldr	r3, [r7, #12]
 802d162:	2201      	movs	r2, #1
 802d164:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
      __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
    }
#endif /* USE_SPI_CRC */

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 802d168:	68fb      	ldr	r3, [r7, #12]
 802d16a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d16c:	2b00      	cmp	r3, #0
 802d16e:	d003      	beq.n	802d178 <SPI_DMATransmitReceiveCplt+0x84>
    {
      /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
      hspi->ErrorCallback(hspi);
#else
      HAL_SPI_ErrorCallback(hspi);
 802d170:	68f8      	ldr	r0, [r7, #12]
 802d172:	f7ff ff73 	bl	802d05c <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      return;
 802d176:	e002      	b.n	802d17e <SPI_DMATransmitReceiveCplt+0x8a>
  }
  /* Call user TxRx complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->TxRxCpltCallback(hspi);
#else
  HAL_SPI_TxRxCpltCallback(hspi);
 802d178:	68f8      	ldr	r0, [r7, #12]
 802d17a:	f7fb fd65 	bl	8028c48 <HAL_SPI_TxRxCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802d17e:	3710      	adds	r7, #16
 802d180:	46bd      	mov	sp, r7
 802d182:	bd80      	pop	{r7, pc}

0802d184 <SPI_DMAHalfReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802d184:	b580      	push	{r7, lr}
 802d186:	b084      	sub	sp, #16
 802d188:	af00      	add	r7, sp, #0
 802d18a:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802d18c:	687b      	ldr	r3, [r7, #4]
 802d18e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d190:	60fb      	str	r3, [r7, #12]

  /* Call user Rx half complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->RxHalfCpltCallback(hspi);
#else
  HAL_SPI_RxHalfCpltCallback(hspi);
 802d192:	68f8      	ldr	r0, [r7, #12]
 802d194:	f7ff ff4e 	bl	802d034 <HAL_SPI_RxHalfCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802d198:	bf00      	nop
 802d19a:	3710      	adds	r7, #16
 802d19c:	46bd      	mov	sp, r7
 802d19e:	bd80      	pop	{r7, pc}

0802d1a0 <SPI_DMAHalfTransmitReceiveCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
{
 802d1a0:	b580      	push	{r7, lr}
 802d1a2:	b084      	sub	sp, #16
 802d1a4:	af00      	add	r7, sp, #0
 802d1a6:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802d1a8:	687b      	ldr	r3, [r7, #4]
 802d1aa:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d1ac:	60fb      	str	r3, [r7, #12]

  /* Call user TxRx half complete callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->TxRxHalfCpltCallback(hspi);
#else
  HAL_SPI_TxRxHalfCpltCallback(hspi);
 802d1ae:	68f8      	ldr	r0, [r7, #12]
 802d1b0:	f7ff ff4a 	bl	802d048 <HAL_SPI_TxRxHalfCpltCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802d1b4:	bf00      	nop
 802d1b6:	3710      	adds	r7, #16
 802d1b8:	46bd      	mov	sp, r7
 802d1ba:	bd80      	pop	{r7, pc}

0802d1bc <SPI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void SPI_DMAError(DMA_HandleTypeDef *hdma)
{
 802d1bc:	b580      	push	{r7, lr}
 802d1be:	b084      	sub	sp, #16
 802d1c0:	af00      	add	r7, sp, #0
 802d1c2:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 802d1c4:	687b      	ldr	r3, [r7, #4]
 802d1c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802d1c8:	60fb      	str	r3, [r7, #12]

  /* Stop the disable DMA transfer on SPI side */
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 802d1ca:	68fb      	ldr	r3, [r7, #12]
 802d1cc:	681b      	ldr	r3, [r3, #0]
 802d1ce:	685a      	ldr	r2, [r3, #4]
 802d1d0:	68fb      	ldr	r3, [r7, #12]
 802d1d2:	681b      	ldr	r3, [r3, #0]
 802d1d4:	f022 0203 	bic.w	r2, r2, #3
 802d1d8:	605a      	str	r2, [r3, #4]

  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 802d1da:	68fb      	ldr	r3, [r7, #12]
 802d1dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d1de:	f043 0210 	orr.w	r2, r3, #16
 802d1e2:	68fb      	ldr	r3, [r7, #12]
 802d1e4:	655a      	str	r2, [r3, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_READY;
 802d1e6:	68fb      	ldr	r3, [r7, #12]
 802d1e8:	2201      	movs	r2, #1
 802d1ea:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
  /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 802d1ee:	68f8      	ldr	r0, [r7, #12]
 802d1f0:	f7ff ff34 	bl	802d05c <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 802d1f4:	bf00      	nop
 802d1f6:	3710      	adds	r7, #16
 802d1f8:	46bd      	mov	sp, r7
 802d1fa:	bd80      	pop	{r7, pc}

0802d1fc <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 802d1fc:	b580      	push	{r7, lr}
 802d1fe:	b084      	sub	sp, #16
 802d200:	af00      	add	r7, sp, #0
 802d202:	60f8      	str	r0, [r7, #12]
 802d204:	60b9      	str	r1, [r7, #8]
 802d206:	603b      	str	r3, [r7, #0]
 802d208:	4613      	mov	r3, r2
 802d20a:	71fb      	strb	r3, [r7, #7]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 802d20c:	e04c      	b.n	802d2a8 <SPI_WaitFlagStateUntilTimeout+0xac>
  {
    if (Timeout != HAL_MAX_DELAY)
 802d20e:	683b      	ldr	r3, [r7, #0]
 802d210:	f1b3 3fff 	cmp.w	r3, #4294967295
 802d214:	d048      	beq.n	802d2a8 <SPI_WaitFlagStateUntilTimeout+0xac>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 802d216:	f7fd ff9d 	bl	802b154 <HAL_GetTick>
 802d21a:	4602      	mov	r2, r0
 802d21c:	69bb      	ldr	r3, [r7, #24]
 802d21e:	1ad3      	subs	r3, r2, r3
 802d220:	683a      	ldr	r2, [r7, #0]
 802d222:	429a      	cmp	r2, r3
 802d224:	d902      	bls.n	802d22c <SPI_WaitFlagStateUntilTimeout+0x30>
 802d226:	683b      	ldr	r3, [r7, #0]
 802d228:	2b00      	cmp	r3, #0
 802d22a:	d13d      	bne.n	802d2a8 <SPI_WaitFlagStateUntilTimeout+0xac>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 802d22c:	68fb      	ldr	r3, [r7, #12]
 802d22e:	681b      	ldr	r3, [r3, #0]
 802d230:	685a      	ldr	r2, [r3, #4]
 802d232:	68fb      	ldr	r3, [r7, #12]
 802d234:	681b      	ldr	r3, [r3, #0]
 802d236:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 802d23a:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802d23c:	68fb      	ldr	r3, [r7, #12]
 802d23e:	685b      	ldr	r3, [r3, #4]
 802d240:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802d244:	d111      	bne.n	802d26a <SPI_WaitFlagStateUntilTimeout+0x6e>
 802d246:	68fb      	ldr	r3, [r7, #12]
 802d248:	689b      	ldr	r3, [r3, #8]
 802d24a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802d24e:	d004      	beq.n	802d25a <SPI_WaitFlagStateUntilTimeout+0x5e>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 802d250:	68fb      	ldr	r3, [r7, #12]
 802d252:	689b      	ldr	r3, [r3, #8]
 802d254:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802d258:	d107      	bne.n	802d26a <SPI_WaitFlagStateUntilTimeout+0x6e>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 802d25a:	68fb      	ldr	r3, [r7, #12]
 802d25c:	681b      	ldr	r3, [r3, #0]
 802d25e:	681a      	ldr	r2, [r3, #0]
 802d260:	68fb      	ldr	r3, [r7, #12]
 802d262:	681b      	ldr	r3, [r3, #0]
 802d264:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802d268:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 802d26a:	68fb      	ldr	r3, [r7, #12]
 802d26c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802d26e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 802d272:	d10f      	bne.n	802d294 <SPI_WaitFlagStateUntilTimeout+0x98>
        {
          SPI_RESET_CRC(hspi);
 802d274:	68fb      	ldr	r3, [r7, #12]
 802d276:	681b      	ldr	r3, [r3, #0]
 802d278:	681a      	ldr	r2, [r3, #0]
 802d27a:	68fb      	ldr	r3, [r7, #12]
 802d27c:	681b      	ldr	r3, [r3, #0]
 802d27e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 802d282:	601a      	str	r2, [r3, #0]
 802d284:	68fb      	ldr	r3, [r7, #12]
 802d286:	681b      	ldr	r3, [r3, #0]
 802d288:	681a      	ldr	r2, [r3, #0]
 802d28a:	68fb      	ldr	r3, [r7, #12]
 802d28c:	681b      	ldr	r3, [r3, #0]
 802d28e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 802d292:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 802d294:	68fb      	ldr	r3, [r7, #12]
 802d296:	2201      	movs	r2, #1
 802d298:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 802d29c:	68fb      	ldr	r3, [r7, #12]
 802d29e:	2200      	movs	r2, #0
 802d2a0:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

        return HAL_TIMEOUT;
 802d2a4:	2303      	movs	r3, #3
 802d2a6:	e00f      	b.n	802d2c8 <SPI_WaitFlagStateUntilTimeout+0xcc>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 802d2a8:	68fb      	ldr	r3, [r7, #12]
 802d2aa:	681b      	ldr	r3, [r3, #0]
 802d2ac:	689a      	ldr	r2, [r3, #8]
 802d2ae:	68bb      	ldr	r3, [r7, #8]
 802d2b0:	4013      	ands	r3, r2
 802d2b2:	68ba      	ldr	r2, [r7, #8]
 802d2b4:	429a      	cmp	r2, r3
 802d2b6:	bf0c      	ite	eq
 802d2b8:	2301      	moveq	r3, #1
 802d2ba:	2300      	movne	r3, #0
 802d2bc:	b2db      	uxtb	r3, r3
 802d2be:	461a      	mov	r2, r3
 802d2c0:	79fb      	ldrb	r3, [r7, #7]
 802d2c2:	429a      	cmp	r2, r3
 802d2c4:	d1a3      	bne.n	802d20e <SPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }

  return HAL_OK;
 802d2c6:	2300      	movs	r3, #0
}
 802d2c8:	4618      	mov	r0, r3
 802d2ca:	3710      	adds	r7, #16
 802d2cc:	46bd      	mov	sp, r7
 802d2ce:	bd80      	pop	{r7, pc}

0802d2d0 <SPI_EndRxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
 802d2d0:	b580      	push	{r7, lr}
 802d2d2:	b086      	sub	sp, #24
 802d2d4:	af02      	add	r7, sp, #8
 802d2d6:	60f8      	str	r0, [r7, #12]
 802d2d8:	60b9      	str	r1, [r7, #8]
 802d2da:	607a      	str	r2, [r7, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 802d2dc:	68fb      	ldr	r3, [r7, #12]
 802d2de:	685b      	ldr	r3, [r3, #4]
 802d2e0:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802d2e4:	d111      	bne.n	802d30a <SPI_EndRxTransaction+0x3a>
 802d2e6:	68fb      	ldr	r3, [r7, #12]
 802d2e8:	689b      	ldr	r3, [r3, #8]
 802d2ea:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802d2ee:	d004      	beq.n	802d2fa <SPI_EndRxTransaction+0x2a>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 802d2f0:	68fb      	ldr	r3, [r7, #12]
 802d2f2:	689b      	ldr	r3, [r3, #8]
 802d2f4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802d2f8:	d107      	bne.n	802d30a <SPI_EndRxTransaction+0x3a>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 802d2fa:	68fb      	ldr	r3, [r7, #12]
 802d2fc:	681b      	ldr	r3, [r3, #0]
 802d2fe:	681a      	ldr	r2, [r3, #0]
 802d300:	68fb      	ldr	r3, [r7, #12]
 802d302:	681b      	ldr	r3, [r3, #0]
 802d304:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802d308:	601a      	str	r2, [r3, #0]
  }

  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 802d30a:	68fb      	ldr	r3, [r7, #12]
 802d30c:	685b      	ldr	r3, [r3, #4]
 802d30e:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802d312:	d12a      	bne.n	802d36a <SPI_EndRxTransaction+0x9a>
  {
    if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
 802d314:	68fb      	ldr	r3, [r7, #12]
 802d316:	689b      	ldr	r3, [r3, #8]
 802d318:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802d31c:	d012      	beq.n	802d344 <SPI_EndRxTransaction+0x74>
    {
      /* Control the BSY flag */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 802d31e:	687b      	ldr	r3, [r7, #4]
 802d320:	9300      	str	r3, [sp, #0]
 802d322:	68bb      	ldr	r3, [r7, #8]
 802d324:	2200      	movs	r2, #0
 802d326:	2180      	movs	r1, #128	; 0x80
 802d328:	68f8      	ldr	r0, [r7, #12]
 802d32a:	f7ff ff67 	bl	802d1fc <SPI_WaitFlagStateUntilTimeout>
 802d32e:	4603      	mov	r3, r0
 802d330:	2b00      	cmp	r3, #0
 802d332:	d02d      	beq.n	802d390 <SPI_EndRxTransaction+0xc0>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802d334:	68fb      	ldr	r3, [r7, #12]
 802d336:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d338:	f043 0220 	orr.w	r2, r3, #32
 802d33c:	68fb      	ldr	r3, [r7, #12]
 802d33e:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 802d340:	2303      	movs	r3, #3
 802d342:	e026      	b.n	802d392 <SPI_EndRxTransaction+0xc2>
      }
    }
    else
    {
      /* Wait the RXNE reset */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 802d344:	687b      	ldr	r3, [r7, #4]
 802d346:	9300      	str	r3, [sp, #0]
 802d348:	68bb      	ldr	r3, [r7, #8]
 802d34a:	2200      	movs	r2, #0
 802d34c:	2101      	movs	r1, #1
 802d34e:	68f8      	ldr	r0, [r7, #12]
 802d350:	f7ff ff54 	bl	802d1fc <SPI_WaitFlagStateUntilTimeout>
 802d354:	4603      	mov	r3, r0
 802d356:	2b00      	cmp	r3, #0
 802d358:	d01a      	beq.n	802d390 <SPI_EndRxTransaction+0xc0>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802d35a:	68fb      	ldr	r3, [r7, #12]
 802d35c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d35e:	f043 0220 	orr.w	r2, r3, #32
 802d362:	68fb      	ldr	r3, [r7, #12]
 802d364:	655a      	str	r2, [r3, #84]	; 0x54
        return HAL_TIMEOUT;
 802d366:	2303      	movs	r3, #3
 802d368:	e013      	b.n	802d392 <SPI_EndRxTransaction+0xc2>
    }
  }
  else
  {
    /* Wait the RXNE reset */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 802d36a:	687b      	ldr	r3, [r7, #4]
 802d36c:	9300      	str	r3, [sp, #0]
 802d36e:	68bb      	ldr	r3, [r7, #8]
 802d370:	2200      	movs	r2, #0
 802d372:	2101      	movs	r1, #1
 802d374:	68f8      	ldr	r0, [r7, #12]
 802d376:	f7ff ff41 	bl	802d1fc <SPI_WaitFlagStateUntilTimeout>
 802d37a:	4603      	mov	r3, r0
 802d37c:	2b00      	cmp	r3, #0
 802d37e:	d007      	beq.n	802d390 <SPI_EndRxTransaction+0xc0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802d380:	68fb      	ldr	r3, [r7, #12]
 802d382:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d384:	f043 0220 	orr.w	r2, r3, #32
 802d388:	68fb      	ldr	r3, [r7, #12]
 802d38a:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 802d38c:	2303      	movs	r3, #3
 802d38e:	e000      	b.n	802d392 <SPI_EndRxTransaction+0xc2>
    }
  }
  return HAL_OK;
 802d390:	2300      	movs	r3, #0
}
 802d392:	4618      	mov	r0, r3
 802d394:	3710      	adds	r7, #16
 802d396:	46bd      	mov	sp, r7
 802d398:	bd80      	pop	{r7, pc}
	...

0802d39c <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 802d39c:	b580      	push	{r7, lr}
 802d39e:	b088      	sub	sp, #32
 802d3a0:	af02      	add	r7, sp, #8
 802d3a2:	60f8      	str	r0, [r7, #12]
 802d3a4:	60b9      	str	r1, [r7, #8]
 802d3a6:	607a      	str	r2, [r7, #4]
  /* Timeout in µs */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 802d3a8:	4b1b      	ldr	r3, [pc, #108]	; (802d418 <SPI_EndRxTxTransaction+0x7c>)
 802d3aa:	681b      	ldr	r3, [r3, #0]
 802d3ac:	4a1b      	ldr	r2, [pc, #108]	; (802d41c <SPI_EndRxTxTransaction+0x80>)
 802d3ae:	fba2 2303 	umull	r2, r3, r2, r3
 802d3b2:	0d5b      	lsrs	r3, r3, #21
 802d3b4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802d3b8:	fb02 f303 	mul.w	r3, r2, r3
 802d3bc:	617b      	str	r3, [r7, #20]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 802d3be:	68fb      	ldr	r3, [r7, #12]
 802d3c0:	685b      	ldr	r3, [r3, #4]
 802d3c2:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 802d3c6:	d112      	bne.n	802d3ee <SPI_EndRxTxTransaction+0x52>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 802d3c8:	687b      	ldr	r3, [r7, #4]
 802d3ca:	9300      	str	r3, [sp, #0]
 802d3cc:	68bb      	ldr	r3, [r7, #8]
 802d3ce:	2200      	movs	r2, #0
 802d3d0:	2180      	movs	r1, #128	; 0x80
 802d3d2:	68f8      	ldr	r0, [r7, #12]
 802d3d4:	f7ff ff12 	bl	802d1fc <SPI_WaitFlagStateUntilTimeout>
 802d3d8:	4603      	mov	r3, r0
 802d3da:	2b00      	cmp	r3, #0
 802d3dc:	d016      	beq.n	802d40c <SPI_EndRxTxTransaction+0x70>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 802d3de:	68fb      	ldr	r3, [r7, #12]
 802d3e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d3e2:	f043 0220 	orr.w	r2, r3, #32
 802d3e6:	68fb      	ldr	r3, [r7, #12]
 802d3e8:	655a      	str	r2, [r3, #84]	; 0x54
      return HAL_TIMEOUT;
 802d3ea:	2303      	movs	r3, #3
 802d3ec:	e00f      	b.n	802d40e <SPI_EndRxTxTransaction+0x72>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 802d3ee:	697b      	ldr	r3, [r7, #20]
 802d3f0:	2b00      	cmp	r3, #0
 802d3f2:	d00a      	beq.n	802d40a <SPI_EndRxTxTransaction+0x6e>
      {
        break;
      }
      count--;
 802d3f4:	697b      	ldr	r3, [r7, #20]
 802d3f6:	3b01      	subs	r3, #1
 802d3f8:	617b      	str	r3, [r7, #20]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 802d3fa:	68fb      	ldr	r3, [r7, #12]
 802d3fc:	681b      	ldr	r3, [r3, #0]
 802d3fe:	689b      	ldr	r3, [r3, #8]
 802d400:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802d404:	2b80      	cmp	r3, #128	; 0x80
 802d406:	d0f2      	beq.n	802d3ee <SPI_EndRxTxTransaction+0x52>
 802d408:	e000      	b.n	802d40c <SPI_EndRxTxTransaction+0x70>
        break;
 802d40a:	bf00      	nop
  }

  return HAL_OK;
 802d40c:	2300      	movs	r3, #0
}
 802d40e:	4618      	mov	r0, r3
 802d410:	3718      	adds	r7, #24
 802d412:	46bd      	mov	sp, r7
 802d414:	bd80      	pop	{r7, pc}
 802d416:	bf00      	nop
 802d418:	20000098 	.word	0x20000098
 802d41c:	165e9f81 	.word	0x165e9f81

0802d420 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 802d420:	b580      	push	{r7, lr}
 802d422:	b082      	sub	sp, #8
 802d424:	af00      	add	r7, sp, #0
 802d426:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 802d428:	687b      	ldr	r3, [r7, #4]
 802d42a:	2b00      	cmp	r3, #0
 802d42c:	d101      	bne.n	802d432 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 802d42e:	2301      	movs	r3, #1
 802d430:	e01d      	b.n	802d46e <HAL_TIM_Base_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 802d432:	687b      	ldr	r3, [r7, #4]
 802d434:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 802d438:	b2db      	uxtb	r3, r3
 802d43a:	2b00      	cmp	r3, #0
 802d43c:	d106      	bne.n	802d44c <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 802d43e:	687b      	ldr	r3, [r7, #4]
 802d440:	2200      	movs	r2, #0
 802d442:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 802d446:	6878      	ldr	r0, [r7, #4]
 802d448:	f7fd f9fc 	bl	802a844 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 802d44c:	687b      	ldr	r3, [r7, #4]
 802d44e:	2202      	movs	r2, #2
 802d450:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 802d454:	687b      	ldr	r3, [r7, #4]
 802d456:	681a      	ldr	r2, [r3, #0]
 802d458:	687b      	ldr	r3, [r7, #4]
 802d45a:	3304      	adds	r3, #4
 802d45c:	4619      	mov	r1, r3
 802d45e:	4610      	mov	r0, r2
 802d460:	f000 fa3a 	bl	802d8d8 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 802d464:	687b      	ldr	r3, [r7, #4]
 802d466:	2201      	movs	r2, #1
 802d468:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 802d46c:	2300      	movs	r3, #0
}
 802d46e:	4618      	mov	r0, r3
 802d470:	3708      	adds	r7, #8
 802d472:	46bd      	mov	sp, r7
 802d474:	bd80      	pop	{r7, pc}

0802d476 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 802d476:	b580      	push	{r7, lr}
 802d478:	b082      	sub	sp, #8
 802d47a:	af00      	add	r7, sp, #0
 802d47c:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 802d47e:	687b      	ldr	r3, [r7, #4]
 802d480:	2b00      	cmp	r3, #0
 802d482:	d101      	bne.n	802d488 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 802d484:	2301      	movs	r3, #1
 802d486:	e01d      	b.n	802d4c4 <HAL_TIM_PWM_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 802d488:	687b      	ldr	r3, [r7, #4]
 802d48a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 802d48e:	b2db      	uxtb	r3, r3
 802d490:	2b00      	cmp	r3, #0
 802d492:	d106      	bne.n	802d4a2 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 802d494:	687b      	ldr	r3, [r7, #4]
 802d496:	2200      	movs	r2, #0
 802d498:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 802d49c:	6878      	ldr	r0, [r7, #4]
 802d49e:	f000 f815 	bl	802d4cc <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 802d4a2:	687b      	ldr	r3, [r7, #4]
 802d4a4:	2202      	movs	r2, #2
 802d4a6:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 802d4aa:	687b      	ldr	r3, [r7, #4]
 802d4ac:	681a      	ldr	r2, [r3, #0]
 802d4ae:	687b      	ldr	r3, [r7, #4]
 802d4b0:	3304      	adds	r3, #4
 802d4b2:	4619      	mov	r1, r3
 802d4b4:	4610      	mov	r0, r2
 802d4b6:	f000 fa0f 	bl	802d8d8 <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 802d4ba:	687b      	ldr	r3, [r7, #4]
 802d4bc:	2201      	movs	r2, #1
 802d4be:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 802d4c2:	2300      	movs	r3, #0
}
 802d4c4:	4618      	mov	r0, r3
 802d4c6:	3708      	adds	r7, #8
 802d4c8:	46bd      	mov	sp, r7
 802d4ca:	bd80      	pop	{r7, pc}

0802d4cc <HAL_TIM_PWM_MspInit>:
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
 802d4cc:	b480      	push	{r7}
 802d4ce:	b083      	sub	sp, #12
 802d4d0:	af00      	add	r7, sp, #0
 802d4d2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */
}
 802d4d4:	bf00      	nop
 802d4d6:	370c      	adds	r7, #12
 802d4d8:	46bd      	mov	sp, r7
 802d4da:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d4de:	4770      	bx	lr

0802d4e0 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 802d4e0:	b580      	push	{r7, lr}
 802d4e2:	b084      	sub	sp, #16
 802d4e4:	af00      	add	r7, sp, #0
 802d4e6:	6078      	str	r0, [r7, #4]
 802d4e8:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 802d4ea:	687b      	ldr	r3, [r7, #4]
 802d4ec:	681b      	ldr	r3, [r3, #0]
 802d4ee:	2201      	movs	r2, #1
 802d4f0:	6839      	ldr	r1, [r7, #0]
 802d4f2:	4618      	mov	r0, r3
 802d4f4:	f000 fc96 	bl	802de24 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 802d4f8:	687b      	ldr	r3, [r7, #4]
 802d4fa:	681b      	ldr	r3, [r3, #0]
 802d4fc:	4a10      	ldr	r2, [pc, #64]	; (802d540 <HAL_TIM_PWM_Start+0x60>)
 802d4fe:	4293      	cmp	r3, r2
 802d500:	d107      	bne.n	802d512 <HAL_TIM_PWM_Start+0x32>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 802d502:	687b      	ldr	r3, [r7, #4]
 802d504:	681b      	ldr	r3, [r3, #0]
 802d506:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 802d508:	687b      	ldr	r3, [r7, #4]
 802d50a:	681b      	ldr	r3, [r3, #0]
 802d50c:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 802d510:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 802d512:	687b      	ldr	r3, [r7, #4]
 802d514:	681b      	ldr	r3, [r3, #0]
 802d516:	689b      	ldr	r3, [r3, #8]
 802d518:	f003 0307 	and.w	r3, r3, #7
 802d51c:	60fb      	str	r3, [r7, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 802d51e:	68fb      	ldr	r3, [r7, #12]
 802d520:	2b06      	cmp	r3, #6
 802d522:	d007      	beq.n	802d534 <HAL_TIM_PWM_Start+0x54>
  {
    __HAL_TIM_ENABLE(htim);
 802d524:	687b      	ldr	r3, [r7, #4]
 802d526:	681b      	ldr	r3, [r3, #0]
 802d528:	681a      	ldr	r2, [r3, #0]
 802d52a:	687b      	ldr	r3, [r7, #4]
 802d52c:	681b      	ldr	r3, [r3, #0]
 802d52e:	f042 0201 	orr.w	r2, r2, #1
 802d532:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 802d534:	2300      	movs	r3, #0
}
 802d536:	4618      	mov	r0, r3
 802d538:	3710      	adds	r7, #16
 802d53a:	46bd      	mov	sp, r7
 802d53c:	bd80      	pop	{r7, pc}
 802d53e:	bf00      	nop
 802d540:	40010000 	.word	0x40010000

0802d544 <HAL_TIM_PWM_Stop>:
  *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
  *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 802d544:	b580      	push	{r7, lr}
 802d546:	b082      	sub	sp, #8
 802d548:	af00      	add	r7, sp, #0
 802d54a:	6078      	str	r0, [r7, #4]
 802d54c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Disable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
 802d54e:	687b      	ldr	r3, [r7, #4]
 802d550:	681b      	ldr	r3, [r3, #0]
 802d552:	2200      	movs	r2, #0
 802d554:	6839      	ldr	r1, [r7, #0]
 802d556:	4618      	mov	r0, r3
 802d558:	f000 fc64 	bl	802de24 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 802d55c:	687b      	ldr	r3, [r7, #4]
 802d55e:	681b      	ldr	r3, [r3, #0]
 802d560:	4a1d      	ldr	r2, [pc, #116]	; (802d5d8 <HAL_TIM_PWM_Stop+0x94>)
 802d562:	4293      	cmp	r3, r2
 802d564:	d117      	bne.n	802d596 <HAL_TIM_PWM_Stop+0x52>
  {
    /* Disable the Main Output */
    __HAL_TIM_MOE_DISABLE(htim);
 802d566:	687b      	ldr	r3, [r7, #4]
 802d568:	681b      	ldr	r3, [r3, #0]
 802d56a:	6a1a      	ldr	r2, [r3, #32]
 802d56c:	f241 1311 	movw	r3, #4369	; 0x1111
 802d570:	4013      	ands	r3, r2
 802d572:	2b00      	cmp	r3, #0
 802d574:	d10f      	bne.n	802d596 <HAL_TIM_PWM_Stop+0x52>
 802d576:	687b      	ldr	r3, [r7, #4]
 802d578:	681b      	ldr	r3, [r3, #0]
 802d57a:	6a1a      	ldr	r2, [r3, #32]
 802d57c:	f240 4344 	movw	r3, #1092	; 0x444
 802d580:	4013      	ands	r3, r2
 802d582:	2b00      	cmp	r3, #0
 802d584:	d107      	bne.n	802d596 <HAL_TIM_PWM_Stop+0x52>
 802d586:	687b      	ldr	r3, [r7, #4]
 802d588:	681b      	ldr	r3, [r3, #0]
 802d58a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 802d58c:	687b      	ldr	r3, [r7, #4]
 802d58e:	681b      	ldr	r3, [r3, #0]
 802d590:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 802d594:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 802d596:	687b      	ldr	r3, [r7, #4]
 802d598:	681b      	ldr	r3, [r3, #0]
 802d59a:	6a1a      	ldr	r2, [r3, #32]
 802d59c:	f241 1311 	movw	r3, #4369	; 0x1111
 802d5a0:	4013      	ands	r3, r2
 802d5a2:	2b00      	cmp	r3, #0
 802d5a4:	d10f      	bne.n	802d5c6 <HAL_TIM_PWM_Stop+0x82>
 802d5a6:	687b      	ldr	r3, [r7, #4]
 802d5a8:	681b      	ldr	r3, [r3, #0]
 802d5aa:	6a1a      	ldr	r2, [r3, #32]
 802d5ac:	f240 4344 	movw	r3, #1092	; 0x444
 802d5b0:	4013      	ands	r3, r2
 802d5b2:	2b00      	cmp	r3, #0
 802d5b4:	d107      	bne.n	802d5c6 <HAL_TIM_PWM_Stop+0x82>
 802d5b6:	687b      	ldr	r3, [r7, #4]
 802d5b8:	681b      	ldr	r3, [r3, #0]
 802d5ba:	681a      	ldr	r2, [r3, #0]
 802d5bc:	687b      	ldr	r3, [r7, #4]
 802d5be:	681b      	ldr	r3, [r3, #0]
 802d5c0:	f022 0201 	bic.w	r2, r2, #1
 802d5c4:	601a      	str	r2, [r3, #0]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 802d5c6:	687b      	ldr	r3, [r7, #4]
 802d5c8:	2201      	movs	r2, #1
 802d5ca:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
 802d5ce:	2300      	movs	r3, #0
}
 802d5d0:	4618      	mov	r0, r3
 802d5d2:	3708      	adds	r7, #8
 802d5d4:	46bd      	mov	sp, r7
 802d5d6:	bd80      	pop	{r7, pc}
 802d5d8:	40010000 	.word	0x40010000

0802d5dc <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 802d5dc:	b580      	push	{r7, lr}
 802d5de:	b084      	sub	sp, #16
 802d5e0:	af00      	add	r7, sp, #0
 802d5e2:	60f8      	str	r0, [r7, #12]
 802d5e4:	60b9      	str	r1, [r7, #8]
 802d5e6:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 802d5e8:	68fb      	ldr	r3, [r7, #12]
 802d5ea:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 802d5ee:	2b01      	cmp	r3, #1
 802d5f0:	d101      	bne.n	802d5f6 <HAL_TIM_PWM_ConfigChannel+0x1a>
 802d5f2:	2302      	movs	r3, #2
 802d5f4:	e0b4      	b.n	802d760 <HAL_TIM_PWM_ConfigChannel+0x184>
 802d5f6:	68fb      	ldr	r3, [r7, #12]
 802d5f8:	2201      	movs	r2, #1
 802d5fa:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 802d5fe:	68fb      	ldr	r3, [r7, #12]
 802d600:	2202      	movs	r2, #2
 802d602:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  switch (Channel)
 802d606:	687b      	ldr	r3, [r7, #4]
 802d608:	2b0c      	cmp	r3, #12
 802d60a:	f200 809f 	bhi.w	802d74c <HAL_TIM_PWM_ConfigChannel+0x170>
 802d60e:	a201      	add	r2, pc, #4	; (adr r2, 802d614 <HAL_TIM_PWM_ConfigChannel+0x38>)
 802d610:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 802d614:	0802d649 	.word	0x0802d649
 802d618:	0802d74d 	.word	0x0802d74d
 802d61c:	0802d74d 	.word	0x0802d74d
 802d620:	0802d74d 	.word	0x0802d74d
 802d624:	0802d689 	.word	0x0802d689
 802d628:	0802d74d 	.word	0x0802d74d
 802d62c:	0802d74d 	.word	0x0802d74d
 802d630:	0802d74d 	.word	0x0802d74d
 802d634:	0802d6cb 	.word	0x0802d6cb
 802d638:	0802d74d 	.word	0x0802d74d
 802d63c:	0802d74d 	.word	0x0802d74d
 802d640:	0802d74d 	.word	0x0802d74d
 802d644:	0802d70b 	.word	0x0802d70b
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 802d648:	68fb      	ldr	r3, [r7, #12]
 802d64a:	681b      	ldr	r3, [r3, #0]
 802d64c:	68b9      	ldr	r1, [r7, #8]
 802d64e:	4618      	mov	r0, r3
 802d650:	f000 f9c2 	bl	802d9d8 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 802d654:	68fb      	ldr	r3, [r7, #12]
 802d656:	681b      	ldr	r3, [r3, #0]
 802d658:	699a      	ldr	r2, [r3, #24]
 802d65a:	68fb      	ldr	r3, [r7, #12]
 802d65c:	681b      	ldr	r3, [r3, #0]
 802d65e:	f042 0208 	orr.w	r2, r2, #8
 802d662:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 802d664:	68fb      	ldr	r3, [r7, #12]
 802d666:	681b      	ldr	r3, [r3, #0]
 802d668:	699a      	ldr	r2, [r3, #24]
 802d66a:	68fb      	ldr	r3, [r7, #12]
 802d66c:	681b      	ldr	r3, [r3, #0]
 802d66e:	f022 0204 	bic.w	r2, r2, #4
 802d672:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 802d674:	68fb      	ldr	r3, [r7, #12]
 802d676:	681b      	ldr	r3, [r3, #0]
 802d678:	6999      	ldr	r1, [r3, #24]
 802d67a:	68bb      	ldr	r3, [r7, #8]
 802d67c:	691a      	ldr	r2, [r3, #16]
 802d67e:	68fb      	ldr	r3, [r7, #12]
 802d680:	681b      	ldr	r3, [r3, #0]
 802d682:	430a      	orrs	r2, r1
 802d684:	619a      	str	r2, [r3, #24]
      break;
 802d686:	e062      	b.n	802d74e <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 802d688:	68fb      	ldr	r3, [r7, #12]
 802d68a:	681b      	ldr	r3, [r3, #0]
 802d68c:	68b9      	ldr	r1, [r7, #8]
 802d68e:	4618      	mov	r0, r3
 802d690:	f000 fa08 	bl	802daa4 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 802d694:	68fb      	ldr	r3, [r7, #12]
 802d696:	681b      	ldr	r3, [r3, #0]
 802d698:	699a      	ldr	r2, [r3, #24]
 802d69a:	68fb      	ldr	r3, [r7, #12]
 802d69c:	681b      	ldr	r3, [r3, #0]
 802d69e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802d6a2:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 802d6a4:	68fb      	ldr	r3, [r7, #12]
 802d6a6:	681b      	ldr	r3, [r3, #0]
 802d6a8:	699a      	ldr	r2, [r3, #24]
 802d6aa:	68fb      	ldr	r3, [r7, #12]
 802d6ac:	681b      	ldr	r3, [r3, #0]
 802d6ae:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 802d6b2:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 802d6b4:	68fb      	ldr	r3, [r7, #12]
 802d6b6:	681b      	ldr	r3, [r3, #0]
 802d6b8:	6999      	ldr	r1, [r3, #24]
 802d6ba:	68bb      	ldr	r3, [r7, #8]
 802d6bc:	691b      	ldr	r3, [r3, #16]
 802d6be:	021a      	lsls	r2, r3, #8
 802d6c0:	68fb      	ldr	r3, [r7, #12]
 802d6c2:	681b      	ldr	r3, [r3, #0]
 802d6c4:	430a      	orrs	r2, r1
 802d6c6:	619a      	str	r2, [r3, #24]
      break;
 802d6c8:	e041      	b.n	802d74e <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 802d6ca:	68fb      	ldr	r3, [r7, #12]
 802d6cc:	681b      	ldr	r3, [r3, #0]
 802d6ce:	68b9      	ldr	r1, [r7, #8]
 802d6d0:	4618      	mov	r0, r3
 802d6d2:	f000 fa53 	bl	802db7c <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 802d6d6:	68fb      	ldr	r3, [r7, #12]
 802d6d8:	681b      	ldr	r3, [r3, #0]
 802d6da:	69da      	ldr	r2, [r3, #28]
 802d6dc:	68fb      	ldr	r3, [r7, #12]
 802d6de:	681b      	ldr	r3, [r3, #0]
 802d6e0:	f042 0208 	orr.w	r2, r2, #8
 802d6e4:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 802d6e6:	68fb      	ldr	r3, [r7, #12]
 802d6e8:	681b      	ldr	r3, [r3, #0]
 802d6ea:	69da      	ldr	r2, [r3, #28]
 802d6ec:	68fb      	ldr	r3, [r7, #12]
 802d6ee:	681b      	ldr	r3, [r3, #0]
 802d6f0:	f022 0204 	bic.w	r2, r2, #4
 802d6f4:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 802d6f6:	68fb      	ldr	r3, [r7, #12]
 802d6f8:	681b      	ldr	r3, [r3, #0]
 802d6fa:	69d9      	ldr	r1, [r3, #28]
 802d6fc:	68bb      	ldr	r3, [r7, #8]
 802d6fe:	691a      	ldr	r2, [r3, #16]
 802d700:	68fb      	ldr	r3, [r7, #12]
 802d702:	681b      	ldr	r3, [r3, #0]
 802d704:	430a      	orrs	r2, r1
 802d706:	61da      	str	r2, [r3, #28]
      break;
 802d708:	e021      	b.n	802d74e <HAL_TIM_PWM_ConfigChannel+0x172>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 802d70a:	68fb      	ldr	r3, [r7, #12]
 802d70c:	681b      	ldr	r3, [r3, #0]
 802d70e:	68b9      	ldr	r1, [r7, #8]
 802d710:	4618      	mov	r0, r3
 802d712:	f000 fa9d 	bl	802dc50 <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 802d716:	68fb      	ldr	r3, [r7, #12]
 802d718:	681b      	ldr	r3, [r3, #0]
 802d71a:	69da      	ldr	r2, [r3, #28]
 802d71c:	68fb      	ldr	r3, [r7, #12]
 802d71e:	681b      	ldr	r3, [r3, #0]
 802d720:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802d724:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 802d726:	68fb      	ldr	r3, [r7, #12]
 802d728:	681b      	ldr	r3, [r3, #0]
 802d72a:	69da      	ldr	r2, [r3, #28]
 802d72c:	68fb      	ldr	r3, [r7, #12]
 802d72e:	681b      	ldr	r3, [r3, #0]
 802d730:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 802d734:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 802d736:	68fb      	ldr	r3, [r7, #12]
 802d738:	681b      	ldr	r3, [r3, #0]
 802d73a:	69d9      	ldr	r1, [r3, #28]
 802d73c:	68bb      	ldr	r3, [r7, #8]
 802d73e:	691b      	ldr	r3, [r3, #16]
 802d740:	021a      	lsls	r2, r3, #8
 802d742:	68fb      	ldr	r3, [r7, #12]
 802d744:	681b      	ldr	r3, [r3, #0]
 802d746:	430a      	orrs	r2, r1
 802d748:	61da      	str	r2, [r3, #28]
      break;
 802d74a:	e000      	b.n	802d74e <HAL_TIM_PWM_ConfigChannel+0x172>
    }

    default:
      break;
 802d74c:	bf00      	nop
  }

  htim->State = HAL_TIM_STATE_READY;
 802d74e:	68fb      	ldr	r3, [r7, #12]
 802d750:	2201      	movs	r2, #1
 802d752:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 802d756:	68fb      	ldr	r3, [r7, #12]
 802d758:	2200      	movs	r2, #0
 802d75a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 802d75e:	2300      	movs	r3, #0
}
 802d760:	4618      	mov	r0, r3
 802d762:	3710      	adds	r7, #16
 802d764:	46bd      	mov	sp, r7
 802d766:	bd80      	pop	{r7, pc}

0802d768 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 802d768:	b580      	push	{r7, lr}
 802d76a:	b084      	sub	sp, #16
 802d76c:	af00      	add	r7, sp, #0
 802d76e:	6078      	str	r0, [r7, #4]
 802d770:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 802d772:	687b      	ldr	r3, [r7, #4]
 802d774:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 802d778:	2b01      	cmp	r3, #1
 802d77a:	d101      	bne.n	802d780 <HAL_TIM_ConfigClockSource+0x18>
 802d77c:	2302      	movs	r3, #2
 802d77e:	e0a6      	b.n	802d8ce <HAL_TIM_ConfigClockSource+0x166>
 802d780:	687b      	ldr	r3, [r7, #4]
 802d782:	2201      	movs	r2, #1
 802d784:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 802d788:	687b      	ldr	r3, [r7, #4]
 802d78a:	2202      	movs	r2, #2
 802d78c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 802d790:	687b      	ldr	r3, [r7, #4]
 802d792:	681b      	ldr	r3, [r3, #0]
 802d794:	689b      	ldr	r3, [r3, #8]
 802d796:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 802d798:	68fb      	ldr	r3, [r7, #12]
 802d79a:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 802d79e:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 802d7a0:	68fb      	ldr	r3, [r7, #12]
 802d7a2:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802d7a6:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 802d7a8:	687b      	ldr	r3, [r7, #4]
 802d7aa:	681b      	ldr	r3, [r3, #0]
 802d7ac:	68fa      	ldr	r2, [r7, #12]
 802d7ae:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 802d7b0:	683b      	ldr	r3, [r7, #0]
 802d7b2:	681b      	ldr	r3, [r3, #0]
 802d7b4:	2b40      	cmp	r3, #64	; 0x40
 802d7b6:	d067      	beq.n	802d888 <HAL_TIM_ConfigClockSource+0x120>
 802d7b8:	2b40      	cmp	r3, #64	; 0x40
 802d7ba:	d80b      	bhi.n	802d7d4 <HAL_TIM_ConfigClockSource+0x6c>
 802d7bc:	2b10      	cmp	r3, #16
 802d7be:	d073      	beq.n	802d8a8 <HAL_TIM_ConfigClockSource+0x140>
 802d7c0:	2b10      	cmp	r3, #16
 802d7c2:	d802      	bhi.n	802d7ca <HAL_TIM_ConfigClockSource+0x62>
 802d7c4:	2b00      	cmp	r3, #0
 802d7c6:	d06f      	beq.n	802d8a8 <HAL_TIM_ConfigClockSource+0x140>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
      break;
    }

    default:
      break;
 802d7c8:	e078      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 802d7ca:	2b20      	cmp	r3, #32
 802d7cc:	d06c      	beq.n	802d8a8 <HAL_TIM_ConfigClockSource+0x140>
 802d7ce:	2b30      	cmp	r3, #48	; 0x30
 802d7d0:	d06a      	beq.n	802d8a8 <HAL_TIM_ConfigClockSource+0x140>
      break;
 802d7d2:	e073      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 802d7d4:	2b70      	cmp	r3, #112	; 0x70
 802d7d6:	d00d      	beq.n	802d7f4 <HAL_TIM_ConfigClockSource+0x8c>
 802d7d8:	2b70      	cmp	r3, #112	; 0x70
 802d7da:	d804      	bhi.n	802d7e6 <HAL_TIM_ConfigClockSource+0x7e>
 802d7dc:	2b50      	cmp	r3, #80	; 0x50
 802d7de:	d033      	beq.n	802d848 <HAL_TIM_ConfigClockSource+0xe0>
 802d7e0:	2b60      	cmp	r3, #96	; 0x60
 802d7e2:	d041      	beq.n	802d868 <HAL_TIM_ConfigClockSource+0x100>
      break;
 802d7e4:	e06a      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 802d7e6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 802d7ea:	d066      	beq.n	802d8ba <HAL_TIM_ConfigClockSource+0x152>
 802d7ec:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 802d7f0:	d017      	beq.n	802d822 <HAL_TIM_ConfigClockSource+0xba>
      break;
 802d7f2:	e063      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
 802d7f4:	687b      	ldr	r3, [r7, #4]
 802d7f6:	6818      	ldr	r0, [r3, #0]
 802d7f8:	683b      	ldr	r3, [r7, #0]
 802d7fa:	6899      	ldr	r1, [r3, #8]
 802d7fc:	683b      	ldr	r3, [r7, #0]
 802d7fe:	685a      	ldr	r2, [r3, #4]
 802d800:	683b      	ldr	r3, [r7, #0]
 802d802:	68db      	ldr	r3, [r3, #12]
 802d804:	f000 faee 	bl	802dde4 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 802d808:	687b      	ldr	r3, [r7, #4]
 802d80a:	681b      	ldr	r3, [r3, #0]
 802d80c:	689b      	ldr	r3, [r3, #8]
 802d80e:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 802d810:	68fb      	ldr	r3, [r7, #12]
 802d812:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 802d816:	60fb      	str	r3, [r7, #12]
      htim->Instance->SMCR = tmpsmcr;
 802d818:	687b      	ldr	r3, [r7, #4]
 802d81a:	681b      	ldr	r3, [r3, #0]
 802d81c:	68fa      	ldr	r2, [r7, #12]
 802d81e:	609a      	str	r2, [r3, #8]
      break;
 802d820:	e04c      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
 802d822:	687b      	ldr	r3, [r7, #4]
 802d824:	6818      	ldr	r0, [r3, #0]
 802d826:	683b      	ldr	r3, [r7, #0]
 802d828:	6899      	ldr	r1, [r3, #8]
 802d82a:	683b      	ldr	r3, [r7, #0]
 802d82c:	685a      	ldr	r2, [r3, #4]
 802d82e:	683b      	ldr	r3, [r7, #0]
 802d830:	68db      	ldr	r3, [r3, #12]
 802d832:	f000 fad7 	bl	802dde4 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 802d836:	687b      	ldr	r3, [r7, #4]
 802d838:	681b      	ldr	r3, [r3, #0]
 802d83a:	689a      	ldr	r2, [r3, #8]
 802d83c:	687b      	ldr	r3, [r7, #4]
 802d83e:	681b      	ldr	r3, [r3, #0]
 802d840:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 802d844:	609a      	str	r2, [r3, #8]
      break;
 802d846:	e039      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
 802d848:	687b      	ldr	r3, [r7, #4]
 802d84a:	6818      	ldr	r0, [r3, #0]
 802d84c:	683b      	ldr	r3, [r7, #0]
 802d84e:	6859      	ldr	r1, [r3, #4]
 802d850:	683b      	ldr	r3, [r7, #0]
 802d852:	68db      	ldr	r3, [r3, #12]
 802d854:	461a      	mov	r2, r3
 802d856:	f000 fa4b 	bl	802dcf0 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 802d85a:	687b      	ldr	r3, [r7, #4]
 802d85c:	681b      	ldr	r3, [r3, #0]
 802d85e:	2150      	movs	r1, #80	; 0x50
 802d860:	4618      	mov	r0, r3
 802d862:	f000 faa4 	bl	802ddae <TIM_ITRx_SetConfig>
      break;
 802d866:	e029      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI2_ConfigInputStage(htim->Instance,
 802d868:	687b      	ldr	r3, [r7, #4]
 802d86a:	6818      	ldr	r0, [r3, #0]
 802d86c:	683b      	ldr	r3, [r7, #0]
 802d86e:	6859      	ldr	r1, [r3, #4]
 802d870:	683b      	ldr	r3, [r7, #0]
 802d872:	68db      	ldr	r3, [r3, #12]
 802d874:	461a      	mov	r2, r3
 802d876:	f000 fa6a 	bl	802dd4e <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 802d87a:	687b      	ldr	r3, [r7, #4]
 802d87c:	681b      	ldr	r3, [r3, #0]
 802d87e:	2160      	movs	r1, #96	; 0x60
 802d880:	4618      	mov	r0, r3
 802d882:	f000 fa94 	bl	802ddae <TIM_ITRx_SetConfig>
      break;
 802d886:	e019      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
 802d888:	687b      	ldr	r3, [r7, #4]
 802d88a:	6818      	ldr	r0, [r3, #0]
 802d88c:	683b      	ldr	r3, [r7, #0]
 802d88e:	6859      	ldr	r1, [r3, #4]
 802d890:	683b      	ldr	r3, [r7, #0]
 802d892:	68db      	ldr	r3, [r3, #12]
 802d894:	461a      	mov	r2, r3
 802d896:	f000 fa2b 	bl	802dcf0 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 802d89a:	687b      	ldr	r3, [r7, #4]
 802d89c:	681b      	ldr	r3, [r3, #0]
 802d89e:	2140      	movs	r1, #64	; 0x40
 802d8a0:	4618      	mov	r0, r3
 802d8a2:	f000 fa84 	bl	802ddae <TIM_ITRx_SetConfig>
      break;
 802d8a6:	e009      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 802d8a8:	687b      	ldr	r3, [r7, #4]
 802d8aa:	681a      	ldr	r2, [r3, #0]
 802d8ac:	683b      	ldr	r3, [r7, #0]
 802d8ae:	681b      	ldr	r3, [r3, #0]
 802d8b0:	4619      	mov	r1, r3
 802d8b2:	4610      	mov	r0, r2
 802d8b4:	f000 fa7b 	bl	802ddae <TIM_ITRx_SetConfig>
      break;
 802d8b8:	e000      	b.n	802d8bc <HAL_TIM_ConfigClockSource+0x154>
      break;
 802d8ba:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 802d8bc:	687b      	ldr	r3, [r7, #4]
 802d8be:	2201      	movs	r2, #1
 802d8c0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 802d8c4:	687b      	ldr	r3, [r7, #4]
 802d8c6:	2200      	movs	r2, #0
 802d8c8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 802d8cc:	2300      	movs	r3, #0
}
 802d8ce:	4618      	mov	r0, r3
 802d8d0:	3710      	adds	r7, #16
 802d8d2:	46bd      	mov	sp, r7
 802d8d4:	bd80      	pop	{r7, pc}
	...

0802d8d8 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 802d8d8:	b480      	push	{r7}
 802d8da:	b085      	sub	sp, #20
 802d8dc:	af00      	add	r7, sp, #0
 802d8de:	6078      	str	r0, [r7, #4]
 802d8e0:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 802d8e2:	687b      	ldr	r3, [r7, #4]
 802d8e4:	681b      	ldr	r3, [r3, #0]
 802d8e6:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 802d8e8:	687b      	ldr	r3, [r7, #4]
 802d8ea:	4a34      	ldr	r2, [pc, #208]	; (802d9bc <TIM_Base_SetConfig+0xe4>)
 802d8ec:	4293      	cmp	r3, r2
 802d8ee:	d00f      	beq.n	802d910 <TIM_Base_SetConfig+0x38>
 802d8f0:	687b      	ldr	r3, [r7, #4]
 802d8f2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802d8f6:	d00b      	beq.n	802d910 <TIM_Base_SetConfig+0x38>
 802d8f8:	687b      	ldr	r3, [r7, #4]
 802d8fa:	4a31      	ldr	r2, [pc, #196]	; (802d9c0 <TIM_Base_SetConfig+0xe8>)
 802d8fc:	4293      	cmp	r3, r2
 802d8fe:	d007      	beq.n	802d910 <TIM_Base_SetConfig+0x38>
 802d900:	687b      	ldr	r3, [r7, #4]
 802d902:	4a30      	ldr	r2, [pc, #192]	; (802d9c4 <TIM_Base_SetConfig+0xec>)
 802d904:	4293      	cmp	r3, r2
 802d906:	d003      	beq.n	802d910 <TIM_Base_SetConfig+0x38>
 802d908:	687b      	ldr	r3, [r7, #4]
 802d90a:	4a2f      	ldr	r2, [pc, #188]	; (802d9c8 <TIM_Base_SetConfig+0xf0>)
 802d90c:	4293      	cmp	r3, r2
 802d90e:	d108      	bne.n	802d922 <TIM_Base_SetConfig+0x4a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 802d910:	68fb      	ldr	r3, [r7, #12]
 802d912:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802d916:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 802d918:	683b      	ldr	r3, [r7, #0]
 802d91a:	685b      	ldr	r3, [r3, #4]
 802d91c:	68fa      	ldr	r2, [r7, #12]
 802d91e:	4313      	orrs	r3, r2
 802d920:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 802d922:	687b      	ldr	r3, [r7, #4]
 802d924:	4a25      	ldr	r2, [pc, #148]	; (802d9bc <TIM_Base_SetConfig+0xe4>)
 802d926:	4293      	cmp	r3, r2
 802d928:	d01b      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d92a:	687b      	ldr	r3, [r7, #4]
 802d92c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802d930:	d017      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d932:	687b      	ldr	r3, [r7, #4]
 802d934:	4a22      	ldr	r2, [pc, #136]	; (802d9c0 <TIM_Base_SetConfig+0xe8>)
 802d936:	4293      	cmp	r3, r2
 802d938:	d013      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d93a:	687b      	ldr	r3, [r7, #4]
 802d93c:	4a21      	ldr	r2, [pc, #132]	; (802d9c4 <TIM_Base_SetConfig+0xec>)
 802d93e:	4293      	cmp	r3, r2
 802d940:	d00f      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d942:	687b      	ldr	r3, [r7, #4]
 802d944:	4a20      	ldr	r2, [pc, #128]	; (802d9c8 <TIM_Base_SetConfig+0xf0>)
 802d946:	4293      	cmp	r3, r2
 802d948:	d00b      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d94a:	687b      	ldr	r3, [r7, #4]
 802d94c:	4a1f      	ldr	r2, [pc, #124]	; (802d9cc <TIM_Base_SetConfig+0xf4>)
 802d94e:	4293      	cmp	r3, r2
 802d950:	d007      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d952:	687b      	ldr	r3, [r7, #4]
 802d954:	4a1e      	ldr	r2, [pc, #120]	; (802d9d0 <TIM_Base_SetConfig+0xf8>)
 802d956:	4293      	cmp	r3, r2
 802d958:	d003      	beq.n	802d962 <TIM_Base_SetConfig+0x8a>
 802d95a:	687b      	ldr	r3, [r7, #4]
 802d95c:	4a1d      	ldr	r2, [pc, #116]	; (802d9d4 <TIM_Base_SetConfig+0xfc>)
 802d95e:	4293      	cmp	r3, r2
 802d960:	d108      	bne.n	802d974 <TIM_Base_SetConfig+0x9c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 802d962:	68fb      	ldr	r3, [r7, #12]
 802d964:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802d968:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 802d96a:	683b      	ldr	r3, [r7, #0]
 802d96c:	68db      	ldr	r3, [r3, #12]
 802d96e:	68fa      	ldr	r2, [r7, #12]
 802d970:	4313      	orrs	r3, r2
 802d972:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 802d974:	68fb      	ldr	r3, [r7, #12]
 802d976:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 802d97a:	683b      	ldr	r3, [r7, #0]
 802d97c:	695b      	ldr	r3, [r3, #20]
 802d97e:	4313      	orrs	r3, r2
 802d980:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 802d982:	687b      	ldr	r3, [r7, #4]
 802d984:	68fa      	ldr	r2, [r7, #12]
 802d986:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 802d988:	683b      	ldr	r3, [r7, #0]
 802d98a:	689a      	ldr	r2, [r3, #8]
 802d98c:	687b      	ldr	r3, [r7, #4]
 802d98e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 802d990:	683b      	ldr	r3, [r7, #0]
 802d992:	681a      	ldr	r2, [r3, #0]
 802d994:	687b      	ldr	r3, [r7, #4]
 802d996:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 802d998:	687b      	ldr	r3, [r7, #4]
 802d99a:	4a08      	ldr	r2, [pc, #32]	; (802d9bc <TIM_Base_SetConfig+0xe4>)
 802d99c:	4293      	cmp	r3, r2
 802d99e:	d103      	bne.n	802d9a8 <TIM_Base_SetConfig+0xd0>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 802d9a0:	683b      	ldr	r3, [r7, #0]
 802d9a2:	691a      	ldr	r2, [r3, #16]
 802d9a4:	687b      	ldr	r3, [r7, #4]
 802d9a6:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 802d9a8:	687b      	ldr	r3, [r7, #4]
 802d9aa:	2201      	movs	r2, #1
 802d9ac:	615a      	str	r2, [r3, #20]
}
 802d9ae:	bf00      	nop
 802d9b0:	3714      	adds	r7, #20
 802d9b2:	46bd      	mov	sp, r7
 802d9b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d9b8:	4770      	bx	lr
 802d9ba:	bf00      	nop
 802d9bc:	40010000 	.word	0x40010000
 802d9c0:	40000400 	.word	0x40000400
 802d9c4:	40000800 	.word	0x40000800
 802d9c8:	40000c00 	.word	0x40000c00
 802d9cc:	40014000 	.word	0x40014000
 802d9d0:	40014400 	.word	0x40014400
 802d9d4:	40014800 	.word	0x40014800

0802d9d8 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802d9d8:	b480      	push	{r7}
 802d9da:	b087      	sub	sp, #28
 802d9dc:	af00      	add	r7, sp, #0
 802d9de:	6078      	str	r0, [r7, #4]
 802d9e0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 802d9e2:	687b      	ldr	r3, [r7, #4]
 802d9e4:	6a1b      	ldr	r3, [r3, #32]
 802d9e6:	f023 0201 	bic.w	r2, r3, #1
 802d9ea:	687b      	ldr	r3, [r7, #4]
 802d9ec:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802d9ee:	687b      	ldr	r3, [r7, #4]
 802d9f0:	6a1b      	ldr	r3, [r3, #32]
 802d9f2:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802d9f4:	687b      	ldr	r3, [r7, #4]
 802d9f6:	685b      	ldr	r3, [r3, #4]
 802d9f8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 802d9fa:	687b      	ldr	r3, [r7, #4]
 802d9fc:	699b      	ldr	r3, [r3, #24]
 802d9fe:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 802da00:	68fb      	ldr	r3, [r7, #12]
 802da02:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802da06:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 802da08:	68fb      	ldr	r3, [r7, #12]
 802da0a:	f023 0303 	bic.w	r3, r3, #3
 802da0e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 802da10:	683b      	ldr	r3, [r7, #0]
 802da12:	681b      	ldr	r3, [r3, #0]
 802da14:	68fa      	ldr	r2, [r7, #12]
 802da16:	4313      	orrs	r3, r2
 802da18:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 802da1a:	697b      	ldr	r3, [r7, #20]
 802da1c:	f023 0302 	bic.w	r3, r3, #2
 802da20:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 802da22:	683b      	ldr	r3, [r7, #0]
 802da24:	689b      	ldr	r3, [r3, #8]
 802da26:	697a      	ldr	r2, [r7, #20]
 802da28:	4313      	orrs	r3, r2
 802da2a:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 802da2c:	687b      	ldr	r3, [r7, #4]
 802da2e:	4a1c      	ldr	r2, [pc, #112]	; (802daa0 <TIM_OC1_SetConfig+0xc8>)
 802da30:	4293      	cmp	r3, r2
 802da32:	d10c      	bne.n	802da4e <TIM_OC1_SetConfig+0x76>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 802da34:	697b      	ldr	r3, [r7, #20]
 802da36:	f023 0308 	bic.w	r3, r3, #8
 802da3a:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 802da3c:	683b      	ldr	r3, [r7, #0]
 802da3e:	68db      	ldr	r3, [r3, #12]
 802da40:	697a      	ldr	r2, [r7, #20]
 802da42:	4313      	orrs	r3, r2
 802da44:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 802da46:	697b      	ldr	r3, [r7, #20]
 802da48:	f023 0304 	bic.w	r3, r3, #4
 802da4c:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802da4e:	687b      	ldr	r3, [r7, #4]
 802da50:	4a13      	ldr	r2, [pc, #76]	; (802daa0 <TIM_OC1_SetConfig+0xc8>)
 802da52:	4293      	cmp	r3, r2
 802da54:	d111      	bne.n	802da7a <TIM_OC1_SetConfig+0xa2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 802da56:	693b      	ldr	r3, [r7, #16]
 802da58:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 802da5c:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 802da5e:	693b      	ldr	r3, [r7, #16]
 802da60:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 802da64:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 802da66:	683b      	ldr	r3, [r7, #0]
 802da68:	695b      	ldr	r3, [r3, #20]
 802da6a:	693a      	ldr	r2, [r7, #16]
 802da6c:	4313      	orrs	r3, r2
 802da6e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 802da70:	683b      	ldr	r3, [r7, #0]
 802da72:	699b      	ldr	r3, [r3, #24]
 802da74:	693a      	ldr	r2, [r7, #16]
 802da76:	4313      	orrs	r3, r2
 802da78:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802da7a:	687b      	ldr	r3, [r7, #4]
 802da7c:	693a      	ldr	r2, [r7, #16]
 802da7e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 802da80:	687b      	ldr	r3, [r7, #4]
 802da82:	68fa      	ldr	r2, [r7, #12]
 802da84:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 802da86:	683b      	ldr	r3, [r7, #0]
 802da88:	685a      	ldr	r2, [r3, #4]
 802da8a:	687b      	ldr	r3, [r7, #4]
 802da8c:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802da8e:	687b      	ldr	r3, [r7, #4]
 802da90:	697a      	ldr	r2, [r7, #20]
 802da92:	621a      	str	r2, [r3, #32]
}
 802da94:	bf00      	nop
 802da96:	371c      	adds	r7, #28
 802da98:	46bd      	mov	sp, r7
 802da9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802da9e:	4770      	bx	lr
 802daa0:	40010000 	.word	0x40010000

0802daa4 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802daa4:	b480      	push	{r7}
 802daa6:	b087      	sub	sp, #28
 802daa8:	af00      	add	r7, sp, #0
 802daaa:	6078      	str	r0, [r7, #4]
 802daac:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 802daae:	687b      	ldr	r3, [r7, #4]
 802dab0:	6a1b      	ldr	r3, [r3, #32]
 802dab2:	f023 0210 	bic.w	r2, r3, #16
 802dab6:	687b      	ldr	r3, [r7, #4]
 802dab8:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802daba:	687b      	ldr	r3, [r7, #4]
 802dabc:	6a1b      	ldr	r3, [r3, #32]
 802dabe:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802dac0:	687b      	ldr	r3, [r7, #4]
 802dac2:	685b      	ldr	r3, [r3, #4]
 802dac4:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 802dac6:	687b      	ldr	r3, [r7, #4]
 802dac8:	699b      	ldr	r3, [r3, #24]
 802daca:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 802dacc:	68fb      	ldr	r3, [r7, #12]
 802dace:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 802dad2:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 802dad4:	68fb      	ldr	r3, [r7, #12]
 802dad6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802dada:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 802dadc:	683b      	ldr	r3, [r7, #0]
 802dade:	681b      	ldr	r3, [r3, #0]
 802dae0:	021b      	lsls	r3, r3, #8
 802dae2:	68fa      	ldr	r2, [r7, #12]
 802dae4:	4313      	orrs	r3, r2
 802dae6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 802dae8:	697b      	ldr	r3, [r7, #20]
 802daea:	f023 0320 	bic.w	r3, r3, #32
 802daee:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 802daf0:	683b      	ldr	r3, [r7, #0]
 802daf2:	689b      	ldr	r3, [r3, #8]
 802daf4:	011b      	lsls	r3, r3, #4
 802daf6:	697a      	ldr	r2, [r7, #20]
 802daf8:	4313      	orrs	r3, r2
 802dafa:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 802dafc:	687b      	ldr	r3, [r7, #4]
 802dafe:	4a1e      	ldr	r2, [pc, #120]	; (802db78 <TIM_OC2_SetConfig+0xd4>)
 802db00:	4293      	cmp	r3, r2
 802db02:	d10d      	bne.n	802db20 <TIM_OC2_SetConfig+0x7c>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 802db04:	697b      	ldr	r3, [r7, #20]
 802db06:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802db0a:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 802db0c:	683b      	ldr	r3, [r7, #0]
 802db0e:	68db      	ldr	r3, [r3, #12]
 802db10:	011b      	lsls	r3, r3, #4
 802db12:	697a      	ldr	r2, [r7, #20]
 802db14:	4313      	orrs	r3, r2
 802db16:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 802db18:	697b      	ldr	r3, [r7, #20]
 802db1a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 802db1e:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802db20:	687b      	ldr	r3, [r7, #4]
 802db22:	4a15      	ldr	r2, [pc, #84]	; (802db78 <TIM_OC2_SetConfig+0xd4>)
 802db24:	4293      	cmp	r3, r2
 802db26:	d113      	bne.n	802db50 <TIM_OC2_SetConfig+0xac>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 802db28:	693b      	ldr	r3, [r7, #16]
 802db2a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802db2e:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 802db30:	693b      	ldr	r3, [r7, #16]
 802db32:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 802db36:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 802db38:	683b      	ldr	r3, [r7, #0]
 802db3a:	695b      	ldr	r3, [r3, #20]
 802db3c:	009b      	lsls	r3, r3, #2
 802db3e:	693a      	ldr	r2, [r7, #16]
 802db40:	4313      	orrs	r3, r2
 802db42:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 802db44:	683b      	ldr	r3, [r7, #0]
 802db46:	699b      	ldr	r3, [r3, #24]
 802db48:	009b      	lsls	r3, r3, #2
 802db4a:	693a      	ldr	r2, [r7, #16]
 802db4c:	4313      	orrs	r3, r2
 802db4e:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802db50:	687b      	ldr	r3, [r7, #4]
 802db52:	693a      	ldr	r2, [r7, #16]
 802db54:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 802db56:	687b      	ldr	r3, [r7, #4]
 802db58:	68fa      	ldr	r2, [r7, #12]
 802db5a:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 802db5c:	683b      	ldr	r3, [r7, #0]
 802db5e:	685a      	ldr	r2, [r3, #4]
 802db60:	687b      	ldr	r3, [r7, #4]
 802db62:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802db64:	687b      	ldr	r3, [r7, #4]
 802db66:	697a      	ldr	r2, [r7, #20]
 802db68:	621a      	str	r2, [r3, #32]
}
 802db6a:	bf00      	nop
 802db6c:	371c      	adds	r7, #28
 802db6e:	46bd      	mov	sp, r7
 802db70:	f85d 7b04 	ldr.w	r7, [sp], #4
 802db74:	4770      	bx	lr
 802db76:	bf00      	nop
 802db78:	40010000 	.word	0x40010000

0802db7c <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802db7c:	b480      	push	{r7}
 802db7e:	b087      	sub	sp, #28
 802db80:	af00      	add	r7, sp, #0
 802db82:	6078      	str	r0, [r7, #4]
 802db84:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 802db86:	687b      	ldr	r3, [r7, #4]
 802db88:	6a1b      	ldr	r3, [r3, #32]
 802db8a:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 802db8e:	687b      	ldr	r3, [r7, #4]
 802db90:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802db92:	687b      	ldr	r3, [r7, #4]
 802db94:	6a1b      	ldr	r3, [r3, #32]
 802db96:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802db98:	687b      	ldr	r3, [r7, #4]
 802db9a:	685b      	ldr	r3, [r3, #4]
 802db9c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 802db9e:	687b      	ldr	r3, [r7, #4]
 802dba0:	69db      	ldr	r3, [r3, #28]
 802dba2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 802dba4:	68fb      	ldr	r3, [r7, #12]
 802dba6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802dbaa:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 802dbac:	68fb      	ldr	r3, [r7, #12]
 802dbae:	f023 0303 	bic.w	r3, r3, #3
 802dbb2:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 802dbb4:	683b      	ldr	r3, [r7, #0]
 802dbb6:	681b      	ldr	r3, [r3, #0]
 802dbb8:	68fa      	ldr	r2, [r7, #12]
 802dbba:	4313      	orrs	r3, r2
 802dbbc:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 802dbbe:	697b      	ldr	r3, [r7, #20]
 802dbc0:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 802dbc4:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 802dbc6:	683b      	ldr	r3, [r7, #0]
 802dbc8:	689b      	ldr	r3, [r3, #8]
 802dbca:	021b      	lsls	r3, r3, #8
 802dbcc:	697a      	ldr	r2, [r7, #20]
 802dbce:	4313      	orrs	r3, r2
 802dbd0:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 802dbd2:	687b      	ldr	r3, [r7, #4]
 802dbd4:	4a1d      	ldr	r2, [pc, #116]	; (802dc4c <TIM_OC3_SetConfig+0xd0>)
 802dbd6:	4293      	cmp	r3, r2
 802dbd8:	d10d      	bne.n	802dbf6 <TIM_OC3_SetConfig+0x7a>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 802dbda:	697b      	ldr	r3, [r7, #20]
 802dbdc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 802dbe0:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 802dbe2:	683b      	ldr	r3, [r7, #0]
 802dbe4:	68db      	ldr	r3, [r3, #12]
 802dbe6:	021b      	lsls	r3, r3, #8
 802dbe8:	697a      	ldr	r2, [r7, #20]
 802dbea:	4313      	orrs	r3, r2
 802dbec:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 802dbee:	697b      	ldr	r3, [r7, #20]
 802dbf0:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 802dbf4:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802dbf6:	687b      	ldr	r3, [r7, #4]
 802dbf8:	4a14      	ldr	r2, [pc, #80]	; (802dc4c <TIM_OC3_SetConfig+0xd0>)
 802dbfa:	4293      	cmp	r3, r2
 802dbfc:	d113      	bne.n	802dc26 <TIM_OC3_SetConfig+0xaa>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 802dbfe:	693b      	ldr	r3, [r7, #16]
 802dc00:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802dc04:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 802dc06:	693b      	ldr	r3, [r7, #16]
 802dc08:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802dc0c:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 802dc0e:	683b      	ldr	r3, [r7, #0]
 802dc10:	695b      	ldr	r3, [r3, #20]
 802dc12:	011b      	lsls	r3, r3, #4
 802dc14:	693a      	ldr	r2, [r7, #16]
 802dc16:	4313      	orrs	r3, r2
 802dc18:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 802dc1a:	683b      	ldr	r3, [r7, #0]
 802dc1c:	699b      	ldr	r3, [r3, #24]
 802dc1e:	011b      	lsls	r3, r3, #4
 802dc20:	693a      	ldr	r2, [r7, #16]
 802dc22:	4313      	orrs	r3, r2
 802dc24:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802dc26:	687b      	ldr	r3, [r7, #4]
 802dc28:	693a      	ldr	r2, [r7, #16]
 802dc2a:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 802dc2c:	687b      	ldr	r3, [r7, #4]
 802dc2e:	68fa      	ldr	r2, [r7, #12]
 802dc30:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 802dc32:	683b      	ldr	r3, [r7, #0]
 802dc34:	685a      	ldr	r2, [r3, #4]
 802dc36:	687b      	ldr	r3, [r7, #4]
 802dc38:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802dc3a:	687b      	ldr	r3, [r7, #4]
 802dc3c:	697a      	ldr	r2, [r7, #20]
 802dc3e:	621a      	str	r2, [r3, #32]
}
 802dc40:	bf00      	nop
 802dc42:	371c      	adds	r7, #28
 802dc44:	46bd      	mov	sp, r7
 802dc46:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dc4a:	4770      	bx	lr
 802dc4c:	40010000 	.word	0x40010000

0802dc50 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 802dc50:	b480      	push	{r7}
 802dc52:	b087      	sub	sp, #28
 802dc54:	af00      	add	r7, sp, #0
 802dc56:	6078      	str	r0, [r7, #4]
 802dc58:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 802dc5a:	687b      	ldr	r3, [r7, #4]
 802dc5c:	6a1b      	ldr	r3, [r3, #32]
 802dc5e:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 802dc62:	687b      	ldr	r3, [r7, #4]
 802dc64:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 802dc66:	687b      	ldr	r3, [r7, #4]
 802dc68:	6a1b      	ldr	r3, [r3, #32]
 802dc6a:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 802dc6c:	687b      	ldr	r3, [r7, #4]
 802dc6e:	685b      	ldr	r3, [r3, #4]
 802dc70:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 802dc72:	687b      	ldr	r3, [r7, #4]
 802dc74:	69db      	ldr	r3, [r3, #28]
 802dc76:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 802dc78:	68fb      	ldr	r3, [r7, #12]
 802dc7a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 802dc7e:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 802dc80:	68fb      	ldr	r3, [r7, #12]
 802dc82:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 802dc86:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 802dc88:	683b      	ldr	r3, [r7, #0]
 802dc8a:	681b      	ldr	r3, [r3, #0]
 802dc8c:	021b      	lsls	r3, r3, #8
 802dc8e:	68fa      	ldr	r2, [r7, #12]
 802dc90:	4313      	orrs	r3, r2
 802dc92:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 802dc94:	693b      	ldr	r3, [r7, #16]
 802dc96:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802dc9a:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 802dc9c:	683b      	ldr	r3, [r7, #0]
 802dc9e:	689b      	ldr	r3, [r3, #8]
 802dca0:	031b      	lsls	r3, r3, #12
 802dca2:	693a      	ldr	r2, [r7, #16]
 802dca4:	4313      	orrs	r3, r2
 802dca6:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 802dca8:	687b      	ldr	r3, [r7, #4]
 802dcaa:	4a10      	ldr	r2, [pc, #64]	; (802dcec <TIM_OC4_SetConfig+0x9c>)
 802dcac:	4293      	cmp	r3, r2
 802dcae:	d109      	bne.n	802dcc4 <TIM_OC4_SetConfig+0x74>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 802dcb0:	697b      	ldr	r3, [r7, #20]
 802dcb2:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 802dcb6:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 802dcb8:	683b      	ldr	r3, [r7, #0]
 802dcba:	695b      	ldr	r3, [r3, #20]
 802dcbc:	019b      	lsls	r3, r3, #6
 802dcbe:	697a      	ldr	r2, [r7, #20]
 802dcc0:	4313      	orrs	r3, r2
 802dcc2:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 802dcc4:	687b      	ldr	r3, [r7, #4]
 802dcc6:	697a      	ldr	r2, [r7, #20]
 802dcc8:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 802dcca:	687b      	ldr	r3, [r7, #4]
 802dccc:	68fa      	ldr	r2, [r7, #12]
 802dcce:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 802dcd0:	683b      	ldr	r3, [r7, #0]
 802dcd2:	685a      	ldr	r2, [r3, #4]
 802dcd4:	687b      	ldr	r3, [r7, #4]
 802dcd6:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 802dcd8:	687b      	ldr	r3, [r7, #4]
 802dcda:	693a      	ldr	r2, [r7, #16]
 802dcdc:	621a      	str	r2, [r3, #32]
}
 802dcde:	bf00      	nop
 802dce0:	371c      	adds	r7, #28
 802dce2:	46bd      	mov	sp, r7
 802dce4:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dce8:	4770      	bx	lr
 802dcea:	bf00      	nop
 802dcec:	40010000 	.word	0x40010000

0802dcf0 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 802dcf0:	b480      	push	{r7}
 802dcf2:	b087      	sub	sp, #28
 802dcf4:	af00      	add	r7, sp, #0
 802dcf6:	60f8      	str	r0, [r7, #12]
 802dcf8:	60b9      	str	r1, [r7, #8]
 802dcfa:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 802dcfc:	68fb      	ldr	r3, [r7, #12]
 802dcfe:	6a1b      	ldr	r3, [r3, #32]
 802dd00:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 802dd02:	68fb      	ldr	r3, [r7, #12]
 802dd04:	6a1b      	ldr	r3, [r3, #32]
 802dd06:	f023 0201 	bic.w	r2, r3, #1
 802dd0a:	68fb      	ldr	r3, [r7, #12]
 802dd0c:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 802dd0e:	68fb      	ldr	r3, [r7, #12]
 802dd10:	699b      	ldr	r3, [r3, #24]
 802dd12:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 802dd14:	693b      	ldr	r3, [r7, #16]
 802dd16:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 802dd1a:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 802dd1c:	687b      	ldr	r3, [r7, #4]
 802dd1e:	011b      	lsls	r3, r3, #4
 802dd20:	693a      	ldr	r2, [r7, #16]
 802dd22:	4313      	orrs	r3, r2
 802dd24:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 802dd26:	697b      	ldr	r3, [r7, #20]
 802dd28:	f023 030a 	bic.w	r3, r3, #10
 802dd2c:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 802dd2e:	697a      	ldr	r2, [r7, #20]
 802dd30:	68bb      	ldr	r3, [r7, #8]
 802dd32:	4313      	orrs	r3, r2
 802dd34:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 802dd36:	68fb      	ldr	r3, [r7, #12]
 802dd38:	693a      	ldr	r2, [r7, #16]
 802dd3a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 802dd3c:	68fb      	ldr	r3, [r7, #12]
 802dd3e:	697a      	ldr	r2, [r7, #20]
 802dd40:	621a      	str	r2, [r3, #32]
}
 802dd42:	bf00      	nop
 802dd44:	371c      	adds	r7, #28
 802dd46:	46bd      	mov	sp, r7
 802dd48:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dd4c:	4770      	bx	lr

0802dd4e <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 802dd4e:	b480      	push	{r7}
 802dd50:	b087      	sub	sp, #28
 802dd52:	af00      	add	r7, sp, #0
 802dd54:	60f8      	str	r0, [r7, #12]
 802dd56:	60b9      	str	r1, [r7, #8]
 802dd58:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 802dd5a:	68fb      	ldr	r3, [r7, #12]
 802dd5c:	6a1b      	ldr	r3, [r3, #32]
 802dd5e:	f023 0210 	bic.w	r2, r3, #16
 802dd62:	68fb      	ldr	r3, [r7, #12]
 802dd64:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 802dd66:	68fb      	ldr	r3, [r7, #12]
 802dd68:	699b      	ldr	r3, [r3, #24]
 802dd6a:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 802dd6c:	68fb      	ldr	r3, [r7, #12]
 802dd6e:	6a1b      	ldr	r3, [r3, #32]
 802dd70:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 802dd72:	697b      	ldr	r3, [r7, #20]
 802dd74:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 802dd78:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 802dd7a:	687b      	ldr	r3, [r7, #4]
 802dd7c:	031b      	lsls	r3, r3, #12
 802dd7e:	697a      	ldr	r2, [r7, #20]
 802dd80:	4313      	orrs	r3, r2
 802dd82:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 802dd84:	693b      	ldr	r3, [r7, #16]
 802dd86:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 802dd8a:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 802dd8c:	68bb      	ldr	r3, [r7, #8]
 802dd8e:	011b      	lsls	r3, r3, #4
 802dd90:	693a      	ldr	r2, [r7, #16]
 802dd92:	4313      	orrs	r3, r2
 802dd94:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 802dd96:	68fb      	ldr	r3, [r7, #12]
 802dd98:	697a      	ldr	r2, [r7, #20]
 802dd9a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 802dd9c:	68fb      	ldr	r3, [r7, #12]
 802dd9e:	693a      	ldr	r2, [r7, #16]
 802dda0:	621a      	str	r2, [r3, #32]
}
 802dda2:	bf00      	nop
 802dda4:	371c      	adds	r7, #28
 802dda6:	46bd      	mov	sp, r7
 802dda8:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ddac:	4770      	bx	lr

0802ddae <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 802ddae:	b480      	push	{r7}
 802ddb0:	b085      	sub	sp, #20
 802ddb2:	af00      	add	r7, sp, #0
 802ddb4:	6078      	str	r0, [r7, #4]
 802ddb6:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 802ddb8:	687b      	ldr	r3, [r7, #4]
 802ddba:	689b      	ldr	r3, [r3, #8]
 802ddbc:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 802ddbe:	68fb      	ldr	r3, [r7, #12]
 802ddc0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802ddc4:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 802ddc6:	683a      	ldr	r2, [r7, #0]
 802ddc8:	68fb      	ldr	r3, [r7, #12]
 802ddca:	4313      	orrs	r3, r2
 802ddcc:	f043 0307 	orr.w	r3, r3, #7
 802ddd0:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 802ddd2:	687b      	ldr	r3, [r7, #4]
 802ddd4:	68fa      	ldr	r2, [r7, #12]
 802ddd6:	609a      	str	r2, [r3, #8]
}
 802ddd8:	bf00      	nop
 802ddda:	3714      	adds	r7, #20
 802dddc:	46bd      	mov	sp, r7
 802ddde:	f85d 7b04 	ldr.w	r7, [sp], #4
 802dde2:	4770      	bx	lr

0802dde4 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 802dde4:	b480      	push	{r7}
 802dde6:	b087      	sub	sp, #28
 802dde8:	af00      	add	r7, sp, #0
 802ddea:	60f8      	str	r0, [r7, #12]
 802ddec:	60b9      	str	r1, [r7, #8]
 802ddee:	607a      	str	r2, [r7, #4]
 802ddf0:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 802ddf2:	68fb      	ldr	r3, [r7, #12]
 802ddf4:	689b      	ldr	r3, [r3, #8]
 802ddf6:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 802ddf8:	697b      	ldr	r3, [r7, #20]
 802ddfa:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 802ddfe:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 802de00:	683b      	ldr	r3, [r7, #0]
 802de02:	021a      	lsls	r2, r3, #8
 802de04:	687b      	ldr	r3, [r7, #4]
 802de06:	431a      	orrs	r2, r3
 802de08:	68bb      	ldr	r3, [r7, #8]
 802de0a:	4313      	orrs	r3, r2
 802de0c:	697a      	ldr	r2, [r7, #20]
 802de0e:	4313      	orrs	r3, r2
 802de10:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 802de12:	68fb      	ldr	r3, [r7, #12]
 802de14:	697a      	ldr	r2, [r7, #20]
 802de16:	609a      	str	r2, [r3, #8]
}
 802de18:	bf00      	nop
 802de1a:	371c      	adds	r7, #28
 802de1c:	46bd      	mov	sp, r7
 802de1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802de22:	4770      	bx	lr

0802de24 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 802de24:	b480      	push	{r7}
 802de26:	b087      	sub	sp, #28
 802de28:	af00      	add	r7, sp, #0
 802de2a:	60f8      	str	r0, [r7, #12]
 802de2c:	60b9      	str	r1, [r7, #8]
 802de2e:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 802de30:	68bb      	ldr	r3, [r7, #8]
 802de32:	f003 031f 	and.w	r3, r3, #31
 802de36:	2201      	movs	r2, #1
 802de38:	fa02 f303 	lsl.w	r3, r2, r3
 802de3c:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 802de3e:	68fb      	ldr	r3, [r7, #12]
 802de40:	6a1a      	ldr	r2, [r3, #32]
 802de42:	697b      	ldr	r3, [r7, #20]
 802de44:	43db      	mvns	r3, r3
 802de46:	401a      	ands	r2, r3
 802de48:	68fb      	ldr	r3, [r7, #12]
 802de4a:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 802de4c:	68fb      	ldr	r3, [r7, #12]
 802de4e:	6a1a      	ldr	r2, [r3, #32]
 802de50:	68bb      	ldr	r3, [r7, #8]
 802de52:	f003 031f 	and.w	r3, r3, #31
 802de56:	6879      	ldr	r1, [r7, #4]
 802de58:	fa01 f303 	lsl.w	r3, r1, r3
 802de5c:	431a      	orrs	r2, r3
 802de5e:	68fb      	ldr	r3, [r7, #12]
 802de60:	621a      	str	r2, [r3, #32]
}
 802de62:	bf00      	nop
 802de64:	371c      	adds	r7, #28
 802de66:	46bd      	mov	sp, r7
 802de68:	f85d 7b04 	ldr.w	r7, [sp], #4
 802de6c:	4770      	bx	lr
	...

0802de70 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 802de70:	b480      	push	{r7}
 802de72:	b085      	sub	sp, #20
 802de74:	af00      	add	r7, sp, #0
 802de76:	6078      	str	r0, [r7, #4]
 802de78:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 802de7a:	687b      	ldr	r3, [r7, #4]
 802de7c:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 802de80:	2b01      	cmp	r3, #1
 802de82:	d101      	bne.n	802de88 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 802de84:	2302      	movs	r3, #2
 802de86:	e050      	b.n	802df2a <HAL_TIMEx_MasterConfigSynchronization+0xba>
 802de88:	687b      	ldr	r3, [r7, #4]
 802de8a:	2201      	movs	r2, #1
 802de8c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 802de90:	687b      	ldr	r3, [r7, #4]
 802de92:	2202      	movs	r2, #2
 802de94:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 802de98:	687b      	ldr	r3, [r7, #4]
 802de9a:	681b      	ldr	r3, [r3, #0]
 802de9c:	685b      	ldr	r3, [r3, #4]
 802de9e:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 802dea0:	687b      	ldr	r3, [r7, #4]
 802dea2:	681b      	ldr	r3, [r3, #0]
 802dea4:	689b      	ldr	r3, [r3, #8]
 802dea6:	60bb      	str	r3, [r7, #8]

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 802dea8:	68fb      	ldr	r3, [r7, #12]
 802deaa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 802deae:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 802deb0:	683b      	ldr	r3, [r7, #0]
 802deb2:	681b      	ldr	r3, [r3, #0]
 802deb4:	68fa      	ldr	r2, [r7, #12]
 802deb6:	4313      	orrs	r3, r2
 802deb8:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 802deba:	687b      	ldr	r3, [r7, #4]
 802debc:	681b      	ldr	r3, [r3, #0]
 802debe:	68fa      	ldr	r2, [r7, #12]
 802dec0:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 802dec2:	687b      	ldr	r3, [r7, #4]
 802dec4:	681b      	ldr	r3, [r3, #0]
 802dec6:	4a1c      	ldr	r2, [pc, #112]	; (802df38 <HAL_TIMEx_MasterConfigSynchronization+0xc8>)
 802dec8:	4293      	cmp	r3, r2
 802deca:	d018      	beq.n	802defe <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802decc:	687b      	ldr	r3, [r7, #4]
 802dece:	681b      	ldr	r3, [r3, #0]
 802ded0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 802ded4:	d013      	beq.n	802defe <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802ded6:	687b      	ldr	r3, [r7, #4]
 802ded8:	681b      	ldr	r3, [r3, #0]
 802deda:	4a18      	ldr	r2, [pc, #96]	; (802df3c <HAL_TIMEx_MasterConfigSynchronization+0xcc>)
 802dedc:	4293      	cmp	r3, r2
 802dede:	d00e      	beq.n	802defe <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802dee0:	687b      	ldr	r3, [r7, #4]
 802dee2:	681b      	ldr	r3, [r3, #0]
 802dee4:	4a16      	ldr	r2, [pc, #88]	; (802df40 <HAL_TIMEx_MasterConfigSynchronization+0xd0>)
 802dee6:	4293      	cmp	r3, r2
 802dee8:	d009      	beq.n	802defe <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802deea:	687b      	ldr	r3, [r7, #4]
 802deec:	681b      	ldr	r3, [r3, #0]
 802deee:	4a15      	ldr	r2, [pc, #84]	; (802df44 <HAL_TIMEx_MasterConfigSynchronization+0xd4>)
 802def0:	4293      	cmp	r3, r2
 802def2:	d004      	beq.n	802defe <HAL_TIMEx_MasterConfigSynchronization+0x8e>
 802def4:	687b      	ldr	r3, [r7, #4]
 802def6:	681b      	ldr	r3, [r3, #0]
 802def8:	4a13      	ldr	r2, [pc, #76]	; (802df48 <HAL_TIMEx_MasterConfigSynchronization+0xd8>)
 802defa:	4293      	cmp	r3, r2
 802defc:	d10c      	bne.n	802df18 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 802defe:	68bb      	ldr	r3, [r7, #8]
 802df00:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802df04:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 802df06:	683b      	ldr	r3, [r7, #0]
 802df08:	685b      	ldr	r3, [r3, #4]
 802df0a:	68ba      	ldr	r2, [r7, #8]
 802df0c:	4313      	orrs	r3, r2
 802df0e:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 802df10:	687b      	ldr	r3, [r7, #4]
 802df12:	681b      	ldr	r3, [r3, #0]
 802df14:	68ba      	ldr	r2, [r7, #8]
 802df16:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 802df18:	687b      	ldr	r3, [r7, #4]
 802df1a:	2201      	movs	r2, #1
 802df1c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 802df20:	687b      	ldr	r3, [r7, #4]
 802df22:	2200      	movs	r2, #0
 802df24:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 802df28:	2300      	movs	r3, #0
}
 802df2a:	4618      	mov	r0, r3
 802df2c:	3714      	adds	r7, #20
 802df2e:	46bd      	mov	sp, r7
 802df30:	f85d 7b04 	ldr.w	r7, [sp], #4
 802df34:	4770      	bx	lr
 802df36:	bf00      	nop
 802df38:	40010000 	.word	0x40010000
 802df3c:	40000400 	.word	0x40000400
 802df40:	40000800 	.word	0x40000800
 802df44:	40000c00 	.word	0x40000c00
 802df48:	40014000 	.word	0x40014000

0802df4c <HAL_UART_Init>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 802df4c:	b580      	push	{r7, lr}
 802df4e:	b082      	sub	sp, #8
 802df50:	af00      	add	r7, sp, #0
 802df52:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 802df54:	687b      	ldr	r3, [r7, #4]
 802df56:	2b00      	cmp	r3, #0
 802df58:	d101      	bne.n	802df5e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 802df5a:	2301      	movs	r3, #1
 802df5c:	e03f      	b.n	802dfde <HAL_UART_Init+0x92>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if (huart->gState == HAL_UART_STATE_RESET)
 802df5e:	687b      	ldr	r3, [r7, #4]
 802df60:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802df64:	b2db      	uxtb	r3, r3
 802df66:	2b00      	cmp	r3, #0
 802df68:	d106      	bne.n	802df78 <HAL_UART_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 802df6a:	687b      	ldr	r3, [r7, #4]
 802df6c:	2200      	movs	r2, #0
 802df6e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 802df72:	6878      	ldr	r0, [r7, #4]
 802df74:	f7fc fd00 	bl	802a978 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 802df78:	687b      	ldr	r3, [r7, #4]
 802df7a:	2224      	movs	r2, #36	; 0x24
 802df7c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 802df80:	687b      	ldr	r3, [r7, #4]
 802df82:	681b      	ldr	r3, [r3, #0]
 802df84:	68da      	ldr	r2, [r3, #12]
 802df86:	687b      	ldr	r3, [r7, #4]
 802df88:	681b      	ldr	r3, [r3, #0]
 802df8a:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 802df8e:	60da      	str	r2, [r3, #12]

  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 802df90:	6878      	ldr	r0, [r7, #4]
 802df92:	f000 fc21 	bl	802e7d8 <UART_SetConfig>

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 802df96:	687b      	ldr	r3, [r7, #4]
 802df98:	681b      	ldr	r3, [r3, #0]
 802df9a:	691a      	ldr	r2, [r3, #16]
 802df9c:	687b      	ldr	r3, [r7, #4]
 802df9e:	681b      	ldr	r3, [r3, #0]
 802dfa0:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 802dfa4:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 802dfa6:	687b      	ldr	r3, [r7, #4]
 802dfa8:	681b      	ldr	r3, [r3, #0]
 802dfaa:	695a      	ldr	r2, [r3, #20]
 802dfac:	687b      	ldr	r3, [r7, #4]
 802dfae:	681b      	ldr	r3, [r3, #0]
 802dfb0:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 802dfb4:	615a      	str	r2, [r3, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 802dfb6:	687b      	ldr	r3, [r7, #4]
 802dfb8:	681b      	ldr	r3, [r3, #0]
 802dfba:	68da      	ldr	r2, [r3, #12]
 802dfbc:	687b      	ldr	r3, [r7, #4]
 802dfbe:	681b      	ldr	r3, [r3, #0]
 802dfc0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 802dfc4:	60da      	str	r2, [r3, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 802dfc6:	687b      	ldr	r3, [r7, #4]
 802dfc8:	2200      	movs	r2, #0
 802dfca:	63da      	str	r2, [r3, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 802dfcc:	687b      	ldr	r3, [r7, #4]
 802dfce:	2220      	movs	r2, #32
 802dfd0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 802dfd4:	687b      	ldr	r3, [r7, #4]
 802dfd6:	2220      	movs	r2, #32
 802dfd8:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a

  return HAL_OK;
 802dfdc:	2300      	movs	r3, #0
}
 802dfde:	4618      	mov	r0, r3
 802dfe0:	3708      	adds	r7, #8
 802dfe2:	46bd      	mov	sp, r7
 802dfe4:	bd80      	pop	{r7, pc}
	...

0802dfe8 <HAL_UART_Transmit_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 802dfe8:	b580      	push	{r7, lr}
 802dfea:	b086      	sub	sp, #24
 802dfec:	af00      	add	r7, sp, #0
 802dfee:	60f8      	str	r0, [r7, #12]
 802dff0:	60b9      	str	r1, [r7, #8]
 802dff2:	4613      	mov	r3, r2
 802dff4:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 802dff6:	68fb      	ldr	r3, [r7, #12]
 802dff8:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802dffc:	b2db      	uxtb	r3, r3
 802dffe:	2b20      	cmp	r3, #32
 802e000:	d153      	bne.n	802e0aa <HAL_UART_Transmit_DMA+0xc2>
  {
    if ((pData == NULL) || (Size == 0U))
 802e002:	68bb      	ldr	r3, [r7, #8]
 802e004:	2b00      	cmp	r3, #0
 802e006:	d002      	beq.n	802e00e <HAL_UART_Transmit_DMA+0x26>
 802e008:	88fb      	ldrh	r3, [r7, #6]
 802e00a:	2b00      	cmp	r3, #0
 802e00c:	d101      	bne.n	802e012 <HAL_UART_Transmit_DMA+0x2a>
    {
      return HAL_ERROR;
 802e00e:	2301      	movs	r3, #1
 802e010:	e04c      	b.n	802e0ac <HAL_UART_Transmit_DMA+0xc4>
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 802e012:	68fb      	ldr	r3, [r7, #12]
 802e014:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 802e018:	2b01      	cmp	r3, #1
 802e01a:	d101      	bne.n	802e020 <HAL_UART_Transmit_DMA+0x38>
 802e01c:	2302      	movs	r3, #2
 802e01e:	e045      	b.n	802e0ac <HAL_UART_Transmit_DMA+0xc4>
 802e020:	68fb      	ldr	r3, [r7, #12]
 802e022:	2201      	movs	r2, #1
 802e024:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    huart->pTxBuffPtr = pData;
 802e028:	68ba      	ldr	r2, [r7, #8]
 802e02a:	68fb      	ldr	r3, [r7, #12]
 802e02c:	621a      	str	r2, [r3, #32]
    huart->TxXferSize = Size;
 802e02e:	68fb      	ldr	r3, [r7, #12]
 802e030:	88fa      	ldrh	r2, [r7, #6]
 802e032:	849a      	strh	r2, [r3, #36]	; 0x24
    huart->TxXferCount = Size;
 802e034:	68fb      	ldr	r3, [r7, #12]
 802e036:	88fa      	ldrh	r2, [r7, #6]
 802e038:	84da      	strh	r2, [r3, #38]	; 0x26

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 802e03a:	68fb      	ldr	r3, [r7, #12]
 802e03c:	2200      	movs	r2, #0
 802e03e:	63da      	str	r2, [r3, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 802e040:	68fb      	ldr	r3, [r7, #12]
 802e042:	2221      	movs	r2, #33	; 0x21
 802e044:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

    /* Set the UART DMA transfer complete callback */
    huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 802e048:	68fb      	ldr	r3, [r7, #12]
 802e04a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802e04c:	4a19      	ldr	r2, [pc, #100]	; (802e0b4 <HAL_UART_Transmit_DMA+0xcc>)
 802e04e:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 802e050:	68fb      	ldr	r3, [r7, #12]
 802e052:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802e054:	4a18      	ldr	r2, [pc, #96]	; (802e0b8 <HAL_UART_Transmit_DMA+0xd0>)
 802e056:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmatx->XferErrorCallback = UART_DMAError;
 802e058:	68fb      	ldr	r3, [r7, #12]
 802e05a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802e05c:	4a17      	ldr	r2, [pc, #92]	; (802e0bc <HAL_UART_Transmit_DMA+0xd4>)
 802e05e:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA abort callback */
    huart->hdmatx->XferAbortCallback = NULL;
 802e060:	68fb      	ldr	r3, [r7, #12]
 802e062:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802e064:	2200      	movs	r2, #0
 802e066:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the UART transmit DMA stream */
    tmp = (uint32_t *)&pData;
 802e068:	f107 0308 	add.w	r3, r7, #8
 802e06c:	617b      	str	r3, [r7, #20]
    HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
 802e06e:	68fb      	ldr	r3, [r7, #12]
 802e070:	6b18      	ldr	r0, [r3, #48]	; 0x30
 802e072:	697b      	ldr	r3, [r7, #20]
 802e074:	6819      	ldr	r1, [r3, #0]
 802e076:	68fb      	ldr	r3, [r7, #12]
 802e078:	681b      	ldr	r3, [r3, #0]
 802e07a:	3304      	adds	r3, #4
 802e07c:	461a      	mov	r2, r3
 802e07e:	88fb      	ldrh	r3, [r7, #6]
 802e080:	f7fd fa56 	bl	802b530 <HAL_DMA_Start_IT>

    /* Clear the TC flag in the SR register by writing 0 to it */
    __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
 802e084:	68fb      	ldr	r3, [r7, #12]
 802e086:	681b      	ldr	r3, [r3, #0]
 802e088:	f06f 0240 	mvn.w	r2, #64	; 0x40
 802e08c:	601a      	str	r2, [r3, #0]

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 802e08e:	68fb      	ldr	r3, [r7, #12]
 802e090:	2200      	movs	r2, #0
 802e092:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802e096:	68fb      	ldr	r3, [r7, #12]
 802e098:	681b      	ldr	r3, [r3, #0]
 802e09a:	695a      	ldr	r2, [r3, #20]
 802e09c:	68fb      	ldr	r3, [r7, #12]
 802e09e:	681b      	ldr	r3, [r3, #0]
 802e0a0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802e0a4:	615a      	str	r2, [r3, #20]

    return HAL_OK;
 802e0a6:	2300      	movs	r3, #0
 802e0a8:	e000      	b.n	802e0ac <HAL_UART_Transmit_DMA+0xc4>
  }
  else
  {
    return HAL_BUSY;
 802e0aa:	2302      	movs	r3, #2
  }
}
 802e0ac:	4618      	mov	r0, r3
 802e0ae:	3718      	adds	r7, #24
 802e0b0:	46bd      	mov	sp, r7
 802e0b2:	bd80      	pop	{r7, pc}
 802e0b4:	0802e469 	.word	0x0802e469
 802e0b8:	0802e4bb 	.word	0x0802e4bb
 802e0bc:	0802e4d7 	.word	0x0802e4d7

0802e0c0 <HAL_UART_DMAPause>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
{
 802e0c0:	b480      	push	{r7}
 802e0c2:	b085      	sub	sp, #20
 802e0c4:	af00      	add	r7, sp, #0
 802e0c6:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 802e0c8:	2300      	movs	r3, #0
 802e0ca:	60fb      	str	r3, [r7, #12]

  /* Process Locked */
  __HAL_LOCK(huart);
 802e0cc:	687b      	ldr	r3, [r7, #4]
 802e0ce:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 802e0d2:	2b01      	cmp	r3, #1
 802e0d4:	d101      	bne.n	802e0da <HAL_UART_DMAPause+0x1a>
 802e0d6:	2302      	movs	r3, #2
 802e0d8:	e050      	b.n	802e17c <HAL_UART_DMAPause+0xbc>
 802e0da:	687b      	ldr	r3, [r7, #4]
 802e0dc:	2201      	movs	r2, #1
 802e0de:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 802e0e2:	687b      	ldr	r3, [r7, #4]
 802e0e4:	681b      	ldr	r3, [r3, #0]
 802e0e6:	695b      	ldr	r3, [r3, #20]
 802e0e8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802e0ec:	2b80      	cmp	r3, #128	; 0x80
 802e0ee:	bf0c      	ite	eq
 802e0f0:	2301      	moveq	r3, #1
 802e0f2:	2300      	movne	r3, #0
 802e0f4:	b2db      	uxtb	r3, r3
 802e0f6:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 802e0f8:	687b      	ldr	r3, [r7, #4]
 802e0fa:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802e0fe:	b2db      	uxtb	r3, r3
 802e100:	2b21      	cmp	r3, #33	; 0x21
 802e102:	d10a      	bne.n	802e11a <HAL_UART_DMAPause+0x5a>
 802e104:	68fb      	ldr	r3, [r7, #12]
 802e106:	2b00      	cmp	r3, #0
 802e108:	d007      	beq.n	802e11a <HAL_UART_DMAPause+0x5a>
  {
    /* Disable the UART DMA Tx request */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802e10a:	687b      	ldr	r3, [r7, #4]
 802e10c:	681b      	ldr	r3, [r3, #0]
 802e10e:	695a      	ldr	r2, [r3, #20]
 802e110:	687b      	ldr	r3, [r7, #4]
 802e112:	681b      	ldr	r3, [r3, #0]
 802e114:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802e118:	615a      	str	r2, [r3, #20]
  }

  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 802e11a:	687b      	ldr	r3, [r7, #4]
 802e11c:	681b      	ldr	r3, [r3, #0]
 802e11e:	695b      	ldr	r3, [r3, #20]
 802e120:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802e124:	2b40      	cmp	r3, #64	; 0x40
 802e126:	bf0c      	ite	eq
 802e128:	2301      	moveq	r3, #1
 802e12a:	2300      	movne	r3, #0
 802e12c:	b2db      	uxtb	r3, r3
 802e12e:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 802e130:	687b      	ldr	r3, [r7, #4]
 802e132:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802e136:	b2db      	uxtb	r3, r3
 802e138:	2b22      	cmp	r3, #34	; 0x22
 802e13a:	d11a      	bne.n	802e172 <HAL_UART_DMAPause+0xb2>
 802e13c:	68fb      	ldr	r3, [r7, #12]
 802e13e:	2b00      	cmp	r3, #0
 802e140:	d017      	beq.n	802e172 <HAL_UART_DMAPause+0xb2>
  {
    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 802e142:	687b      	ldr	r3, [r7, #4]
 802e144:	681b      	ldr	r3, [r3, #0]
 802e146:	68da      	ldr	r2, [r3, #12]
 802e148:	687b      	ldr	r3, [r7, #4]
 802e14a:	681b      	ldr	r3, [r3, #0]
 802e14c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e150:	60da      	str	r2, [r3, #12]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802e152:	687b      	ldr	r3, [r7, #4]
 802e154:	681b      	ldr	r3, [r3, #0]
 802e156:	695a      	ldr	r2, [r3, #20]
 802e158:	687b      	ldr	r3, [r7, #4]
 802e15a:	681b      	ldr	r3, [r3, #0]
 802e15c:	f022 0201 	bic.w	r2, r2, #1
 802e160:	615a      	str	r2, [r3, #20]

    /* Disable the UART DMA Rx request */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802e162:	687b      	ldr	r3, [r7, #4]
 802e164:	681b      	ldr	r3, [r3, #0]
 802e166:	695a      	ldr	r2, [r3, #20]
 802e168:	687b      	ldr	r3, [r7, #4]
 802e16a:	681b      	ldr	r3, [r3, #0]
 802e16c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802e170:	615a      	str	r2, [r3, #20]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 802e172:	687b      	ldr	r3, [r7, #4]
 802e174:	2200      	movs	r2, #0
 802e176:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 802e17a:	2300      	movs	r3, #0
}
 802e17c:	4618      	mov	r0, r3
 802e17e:	3714      	adds	r7, #20
 802e180:	46bd      	mov	sp, r7
 802e182:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e186:	4770      	bx	lr

0802e188 <HAL_UART_DMAResume>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
{
 802e188:	b480      	push	{r7}
 802e18a:	b085      	sub	sp, #20
 802e18c:	af00      	add	r7, sp, #0
 802e18e:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(huart);
 802e190:	687b      	ldr	r3, [r7, #4]
 802e192:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 802e196:	2b01      	cmp	r3, #1
 802e198:	d101      	bne.n	802e19e <HAL_UART_DMAResume+0x16>
 802e19a:	2302      	movs	r3, #2
 802e19c:	e03f      	b.n	802e21e <HAL_UART_DMAResume+0x96>
 802e19e:	687b      	ldr	r3, [r7, #4]
 802e1a0:	2201      	movs	r2, #1
 802e1a2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 802e1a6:	687b      	ldr	r3, [r7, #4]
 802e1a8:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802e1ac:	b2db      	uxtb	r3, r3
 802e1ae:	2b21      	cmp	r3, #33	; 0x21
 802e1b0:	d107      	bne.n	802e1c2 <HAL_UART_DMAResume+0x3a>
  {
    /* Enable the UART DMA Tx request */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802e1b2:	687b      	ldr	r3, [r7, #4]
 802e1b4:	681b      	ldr	r3, [r3, #0]
 802e1b6:	695a      	ldr	r2, [r3, #20]
 802e1b8:	687b      	ldr	r3, [r7, #4]
 802e1ba:	681b      	ldr	r3, [r3, #0]
 802e1bc:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802e1c0:	615a      	str	r2, [r3, #20]
  }

  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 802e1c2:	687b      	ldr	r3, [r7, #4]
 802e1c4:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802e1c8:	b2db      	uxtb	r3, r3
 802e1ca:	2b22      	cmp	r3, #34	; 0x22
 802e1cc:	d122      	bne.n	802e214 <HAL_UART_DMAResume+0x8c>
  {
    /* Clear the Overrun flag before resuming the Rx transfer*/
    __HAL_UART_CLEAR_OREFLAG(huart);
 802e1ce:	2300      	movs	r3, #0
 802e1d0:	60fb      	str	r3, [r7, #12]
 802e1d2:	687b      	ldr	r3, [r7, #4]
 802e1d4:	681b      	ldr	r3, [r3, #0]
 802e1d6:	681b      	ldr	r3, [r3, #0]
 802e1d8:	60fb      	str	r3, [r7, #12]
 802e1da:	687b      	ldr	r3, [r7, #4]
 802e1dc:	681b      	ldr	r3, [r3, #0]
 802e1de:	685b      	ldr	r3, [r3, #4]
 802e1e0:	60fb      	str	r3, [r7, #12]
 802e1e2:	68fb      	ldr	r3, [r7, #12]

    /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 802e1e4:	687b      	ldr	r3, [r7, #4]
 802e1e6:	681b      	ldr	r3, [r3, #0]
 802e1e8:	68da      	ldr	r2, [r3, #12]
 802e1ea:	687b      	ldr	r3, [r7, #4]
 802e1ec:	681b      	ldr	r3, [r3, #0]
 802e1ee:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 802e1f2:	60da      	str	r2, [r3, #12]
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802e1f4:	687b      	ldr	r3, [r7, #4]
 802e1f6:	681b      	ldr	r3, [r3, #0]
 802e1f8:	695a      	ldr	r2, [r3, #20]
 802e1fa:	687b      	ldr	r3, [r7, #4]
 802e1fc:	681b      	ldr	r3, [r3, #0]
 802e1fe:	f042 0201 	orr.w	r2, r2, #1
 802e202:	615a      	str	r2, [r3, #20]

    /* Enable the UART DMA Rx request */
    SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802e204:	687b      	ldr	r3, [r7, #4]
 802e206:	681b      	ldr	r3, [r3, #0]
 802e208:	695a      	ldr	r2, [r3, #20]
 802e20a:	687b      	ldr	r3, [r7, #4]
 802e20c:	681b      	ldr	r3, [r3, #0]
 802e20e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802e212:	615a      	str	r2, [r3, #20]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 802e214:	687b      	ldr	r3, [r7, #4]
 802e216:	2200      	movs	r2, #0
 802e218:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 802e21c:	2300      	movs	r3, #0
}
 802e21e:	4618      	mov	r0, r3
 802e220:	3714      	adds	r7, #20
 802e222:	46bd      	mov	sp, r7
 802e224:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e228:	4770      	bx	lr
	...

0802e22c <HAL_UART_IRQHandler>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 802e22c:	b580      	push	{r7, lr}
 802e22e:	b088      	sub	sp, #32
 802e230:	af00      	add	r7, sp, #0
 802e232:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 802e234:	687b      	ldr	r3, [r7, #4]
 802e236:	681b      	ldr	r3, [r3, #0]
 802e238:	681b      	ldr	r3, [r3, #0]
 802e23a:	61fb      	str	r3, [r7, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 802e23c:	687b      	ldr	r3, [r7, #4]
 802e23e:	681b      	ldr	r3, [r3, #0]
 802e240:	68db      	ldr	r3, [r3, #12]
 802e242:	61bb      	str	r3, [r7, #24]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 802e244:	687b      	ldr	r3, [r7, #4]
 802e246:	681b      	ldr	r3, [r3, #0]
 802e248:	695b      	ldr	r3, [r3, #20]
 802e24a:	617b      	str	r3, [r7, #20]
  uint32_t errorflags = 0x00U;
 802e24c:	2300      	movs	r3, #0
 802e24e:	613b      	str	r3, [r7, #16]
  uint32_t dmarequest = 0x00U;
 802e250:	2300      	movs	r3, #0
 802e252:	60fb      	str	r3, [r7, #12]

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
 802e254:	69fb      	ldr	r3, [r7, #28]
 802e256:	f003 030f 	and.w	r3, r3, #15
 802e25a:	613b      	str	r3, [r7, #16]
  if (errorflags == RESET)
 802e25c:	693b      	ldr	r3, [r7, #16]
 802e25e:	2b00      	cmp	r3, #0
 802e260:	d10d      	bne.n	802e27e <HAL_UART_IRQHandler+0x52>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 802e262:	69fb      	ldr	r3, [r7, #28]
 802e264:	f003 0320 	and.w	r3, r3, #32
 802e268:	2b00      	cmp	r3, #0
 802e26a:	d008      	beq.n	802e27e <HAL_UART_IRQHandler+0x52>
 802e26c:	69bb      	ldr	r3, [r7, #24]
 802e26e:	f003 0320 	and.w	r3, r3, #32
 802e272:	2b00      	cmp	r3, #0
 802e274:	d003      	beq.n	802e27e <HAL_UART_IRQHandler+0x52>
    {
      UART_Receive_IT(huart);
 802e276:	6878      	ldr	r0, [r7, #4]
 802e278:	f000 fa2d 	bl	802e6d6 <UART_Receive_IT>
      return;
 802e27c:	e0d1      	b.n	802e422 <HAL_UART_IRQHandler+0x1f6>
    }
  }

  /* If some errors occur */
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 802e27e:	693b      	ldr	r3, [r7, #16]
 802e280:	2b00      	cmp	r3, #0
 802e282:	f000 80b0 	beq.w	802e3e6 <HAL_UART_IRQHandler+0x1ba>
 802e286:	697b      	ldr	r3, [r7, #20]
 802e288:	f003 0301 	and.w	r3, r3, #1
 802e28c:	2b00      	cmp	r3, #0
 802e28e:	d105      	bne.n	802e29c <HAL_UART_IRQHandler+0x70>
 802e290:	69bb      	ldr	r3, [r7, #24]
 802e292:	f403 7390 	and.w	r3, r3, #288	; 0x120
 802e296:	2b00      	cmp	r3, #0
 802e298:	f000 80a5 	beq.w	802e3e6 <HAL_UART_IRQHandler+0x1ba>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 802e29c:	69fb      	ldr	r3, [r7, #28]
 802e29e:	f003 0301 	and.w	r3, r3, #1
 802e2a2:	2b00      	cmp	r3, #0
 802e2a4:	d00a      	beq.n	802e2bc <HAL_UART_IRQHandler+0x90>
 802e2a6:	69bb      	ldr	r3, [r7, #24]
 802e2a8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802e2ac:	2b00      	cmp	r3, #0
 802e2ae:	d005      	beq.n	802e2bc <HAL_UART_IRQHandler+0x90>
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 802e2b0:	687b      	ldr	r3, [r7, #4]
 802e2b2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e2b4:	f043 0201 	orr.w	r2, r3, #1
 802e2b8:	687b      	ldr	r3, [r7, #4]
 802e2ba:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART noise error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802e2bc:	69fb      	ldr	r3, [r7, #28]
 802e2be:	f003 0304 	and.w	r3, r3, #4
 802e2c2:	2b00      	cmp	r3, #0
 802e2c4:	d00a      	beq.n	802e2dc <HAL_UART_IRQHandler+0xb0>
 802e2c6:	697b      	ldr	r3, [r7, #20]
 802e2c8:	f003 0301 	and.w	r3, r3, #1
 802e2cc:	2b00      	cmp	r3, #0
 802e2ce:	d005      	beq.n	802e2dc <HAL_UART_IRQHandler+0xb0>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 802e2d0:	687b      	ldr	r3, [r7, #4]
 802e2d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e2d4:	f043 0202 	orr.w	r2, r3, #2
 802e2d8:	687b      	ldr	r3, [r7, #4]
 802e2da:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART frame error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 802e2dc:	69fb      	ldr	r3, [r7, #28]
 802e2de:	f003 0302 	and.w	r3, r3, #2
 802e2e2:	2b00      	cmp	r3, #0
 802e2e4:	d00a      	beq.n	802e2fc <HAL_UART_IRQHandler+0xd0>
 802e2e6:	697b      	ldr	r3, [r7, #20]
 802e2e8:	f003 0301 	and.w	r3, r3, #1
 802e2ec:	2b00      	cmp	r3, #0
 802e2ee:	d005      	beq.n	802e2fc <HAL_UART_IRQHandler+0xd0>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 802e2f0:	687b      	ldr	r3, [r7, #4]
 802e2f2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e2f4:	f043 0204 	orr.w	r2, r3, #4
 802e2f8:	687b      	ldr	r3, [r7, #4]
 802e2fa:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* UART Over-Run interrupt occurred --------------------------------------*/
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 802e2fc:	69fb      	ldr	r3, [r7, #28]
 802e2fe:	f003 0308 	and.w	r3, r3, #8
 802e302:	2b00      	cmp	r3, #0
 802e304:	d00f      	beq.n	802e326 <HAL_UART_IRQHandler+0xfa>
 802e306:	69bb      	ldr	r3, [r7, #24]
 802e308:	f003 0320 	and.w	r3, r3, #32
 802e30c:	2b00      	cmp	r3, #0
 802e30e:	d104      	bne.n	802e31a <HAL_UART_IRQHandler+0xee>
 802e310:	697b      	ldr	r3, [r7, #20]
 802e312:	f003 0301 	and.w	r3, r3, #1
 802e316:	2b00      	cmp	r3, #0
 802e318:	d005      	beq.n	802e326 <HAL_UART_IRQHandler+0xfa>
    {
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 802e31a:	687b      	ldr	r3, [r7, #4]
 802e31c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e31e:	f043 0208 	orr.w	r2, r3, #8
 802e322:	687b      	ldr	r3, [r7, #4]
 802e324:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 802e326:	687b      	ldr	r3, [r7, #4]
 802e328:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e32a:	2b00      	cmp	r3, #0
 802e32c:	d078      	beq.n	802e420 <HAL_UART_IRQHandler+0x1f4>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 802e32e:	69fb      	ldr	r3, [r7, #28]
 802e330:	f003 0320 	and.w	r3, r3, #32
 802e334:	2b00      	cmp	r3, #0
 802e336:	d007      	beq.n	802e348 <HAL_UART_IRQHandler+0x11c>
 802e338:	69bb      	ldr	r3, [r7, #24]
 802e33a:	f003 0320 	and.w	r3, r3, #32
 802e33e:	2b00      	cmp	r3, #0
 802e340:	d002      	beq.n	802e348 <HAL_UART_IRQHandler+0x11c>
      {
        UART_Receive_IT(huart);
 802e342:	6878      	ldr	r0, [r7, #4]
 802e344:	f000 f9c7 	bl	802e6d6 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 802e348:	687b      	ldr	r3, [r7, #4]
 802e34a:	681b      	ldr	r3, [r3, #0]
 802e34c:	695b      	ldr	r3, [r3, #20]
 802e34e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802e352:	2b40      	cmp	r3, #64	; 0x40
 802e354:	bf0c      	ite	eq
 802e356:	2301      	moveq	r3, #1
 802e358:	2300      	movne	r3, #0
 802e35a:	b2db      	uxtb	r3, r3
 802e35c:	60fb      	str	r3, [r7, #12]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 802e35e:	687b      	ldr	r3, [r7, #4]
 802e360:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e362:	f003 0308 	and.w	r3, r3, #8
 802e366:	2b00      	cmp	r3, #0
 802e368:	d102      	bne.n	802e370 <HAL_UART_IRQHandler+0x144>
 802e36a:	68fb      	ldr	r3, [r7, #12]
 802e36c:	2b00      	cmp	r3, #0
 802e36e:	d031      	beq.n	802e3d4 <HAL_UART_IRQHandler+0x1a8>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 802e370:	6878      	ldr	r0, [r7, #4]
 802e372:	f000 f910 	bl	802e596 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802e376:	687b      	ldr	r3, [r7, #4]
 802e378:	681b      	ldr	r3, [r3, #0]
 802e37a:	695b      	ldr	r3, [r3, #20]
 802e37c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802e380:	2b40      	cmp	r3, #64	; 0x40
 802e382:	d123      	bne.n	802e3cc <HAL_UART_IRQHandler+0x1a0>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 802e384:	687b      	ldr	r3, [r7, #4]
 802e386:	681b      	ldr	r3, [r3, #0]
 802e388:	695a      	ldr	r2, [r3, #20]
 802e38a:	687b      	ldr	r3, [r7, #4]
 802e38c:	681b      	ldr	r3, [r3, #0]
 802e38e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802e392:	615a      	str	r2, [r3, #20]

          /* Abort the UART DMA Rx stream */
          if (huart->hdmarx != NULL)
 802e394:	687b      	ldr	r3, [r7, #4]
 802e396:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802e398:	2b00      	cmp	r3, #0
 802e39a:	d013      	beq.n	802e3c4 <HAL_UART_IRQHandler+0x198>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 802e39c:	687b      	ldr	r3, [r7, #4]
 802e39e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802e3a0:	4a21      	ldr	r2, [pc, #132]	; (802e428 <HAL_UART_IRQHandler+0x1fc>)
 802e3a2:	651a      	str	r2, [r3, #80]	; 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 802e3a4:	687b      	ldr	r3, [r7, #4]
 802e3a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802e3a8:	4618      	mov	r0, r3
 802e3aa:	f7fd f919 	bl	802b5e0 <HAL_DMA_Abort_IT>
 802e3ae:	4603      	mov	r3, r0
 802e3b0:	2b00      	cmp	r3, #0
 802e3b2:	d016      	beq.n	802e3e2 <HAL_UART_IRQHandler+0x1b6>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 802e3b4:	687b      	ldr	r3, [r7, #4]
 802e3b6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802e3b8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 802e3ba:	687a      	ldr	r2, [r7, #4]
 802e3bc:	6b52      	ldr	r2, [r2, #52]	; 0x34
 802e3be:	4610      	mov	r0, r2
 802e3c0:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802e3c2:	e00e      	b.n	802e3e2 <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 802e3c4:	6878      	ldr	r0, [r7, #4]
 802e3c6:	f000 f845 	bl	802e454 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802e3ca:	e00a      	b.n	802e3e2 <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 802e3cc:	6878      	ldr	r0, [r7, #4]
 802e3ce:	f000 f841 	bl	802e454 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802e3d2:	e006      	b.n	802e3e2 <HAL_UART_IRQHandler+0x1b6>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 802e3d4:	6878      	ldr	r0, [r7, #4]
 802e3d6:	f000 f83d 	bl	802e454 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

        huart->ErrorCode = HAL_UART_ERROR_NONE;
 802e3da:	687b      	ldr	r3, [r7, #4]
 802e3dc:	2200      	movs	r2, #0
 802e3de:	63da      	str	r2, [r3, #60]	; 0x3c
      }
    }
    return;
 802e3e0:	e01e      	b.n	802e420 <HAL_UART_IRQHandler+0x1f4>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 802e3e2:	bf00      	nop
    return;
 802e3e4:	e01c      	b.n	802e420 <HAL_UART_IRQHandler+0x1f4>
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 802e3e6:	69fb      	ldr	r3, [r7, #28]
 802e3e8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802e3ec:	2b00      	cmp	r3, #0
 802e3ee:	d008      	beq.n	802e402 <HAL_UART_IRQHandler+0x1d6>
 802e3f0:	69bb      	ldr	r3, [r7, #24]
 802e3f2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802e3f6:	2b00      	cmp	r3, #0
 802e3f8:	d003      	beq.n	802e402 <HAL_UART_IRQHandler+0x1d6>
  {
    UART_Transmit_IT(huart);
 802e3fa:	6878      	ldr	r0, [r7, #4]
 802e3fc:	f000 f8fd 	bl	802e5fa <UART_Transmit_IT>
    return;
 802e400:	e00f      	b.n	802e422 <HAL_UART_IRQHandler+0x1f6>
  }

  /* UART in mode Transmitter end --------------------------------------------*/
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 802e402:	69fb      	ldr	r3, [r7, #28]
 802e404:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802e408:	2b00      	cmp	r3, #0
 802e40a:	d00a      	beq.n	802e422 <HAL_UART_IRQHandler+0x1f6>
 802e40c:	69bb      	ldr	r3, [r7, #24]
 802e40e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802e412:	2b00      	cmp	r3, #0
 802e414:	d005      	beq.n	802e422 <HAL_UART_IRQHandler+0x1f6>
  {
    UART_EndTransmit_IT(huart);
 802e416:	6878      	ldr	r0, [r7, #4]
 802e418:	f000 f945 	bl	802e6a6 <UART_EndTransmit_IT>
    return;
 802e41c:	bf00      	nop
 802e41e:	e000      	b.n	802e422 <HAL_UART_IRQHandler+0x1f6>
    return;
 802e420:	bf00      	nop
  }
}
 802e422:	3720      	adds	r7, #32
 802e424:	46bd      	mov	sp, r7
 802e426:	bd80      	pop	{r7, pc}
 802e428:	0802e5d3 	.word	0x0802e5d3

0802e42c <HAL_UART_TxHalfCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 802e42c:	b480      	push	{r7}
 802e42e:	b083      	sub	sp, #12
 802e430:	af00      	add	r7, sp, #0
 802e432:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback could be implemented in the user file
   */
}
 802e434:	bf00      	nop
 802e436:	370c      	adds	r7, #12
 802e438:	46bd      	mov	sp, r7
 802e43a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e43e:	4770      	bx	lr

0802e440 <HAL_UART_RxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 802e440:	b480      	push	{r7}
 802e442:	b083      	sub	sp, #12
 802e444:	af00      	add	r7, sp, #0
 802e446:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
 802e448:	bf00      	nop
 802e44a:	370c      	adds	r7, #12
 802e44c:	46bd      	mov	sp, r7
 802e44e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e452:	4770      	bx	lr

0802e454 <HAL_UART_ErrorCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 802e454:	b480      	push	{r7}
 802e456:	b083      	sub	sp, #12
 802e458:	af00      	add	r7, sp, #0
 802e45a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_ErrorCallback could be implemented in the user file
   */
}
 802e45c:	bf00      	nop
 802e45e:	370c      	adds	r7, #12
 802e460:	46bd      	mov	sp, r7
 802e462:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e466:	4770      	bx	lr

0802e468 <UART_DMATransmitCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 802e468:	b580      	push	{r7, lr}
 802e46a:	b084      	sub	sp, #16
 802e46c:	af00      	add	r7, sp, #0
 802e46e:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802e470:	687b      	ldr	r3, [r7, #4]
 802e472:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802e474:	60fb      	str	r3, [r7, #12]
  /* DMA Normal mode*/
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 802e476:	687b      	ldr	r3, [r7, #4]
 802e478:	681b      	ldr	r3, [r3, #0]
 802e47a:	681b      	ldr	r3, [r3, #0]
 802e47c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 802e480:	2b00      	cmp	r3, #0
 802e482:	d113      	bne.n	802e4ac <UART_DMATransmitCplt+0x44>
  {
    huart->TxXferCount = 0x00U;
 802e484:	68fb      	ldr	r3, [r7, #12]
 802e486:	2200      	movs	r2, #0
 802e488:	84da      	strh	r2, [r3, #38]	; 0x26

    /* Disable the DMA transfer for transmit request by setting the DMAT bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 802e48a:	68fb      	ldr	r3, [r7, #12]
 802e48c:	681b      	ldr	r3, [r3, #0]
 802e48e:	695a      	ldr	r2, [r3, #20]
 802e490:	68fb      	ldr	r3, [r7, #12]
 802e492:	681b      	ldr	r3, [r3, #0]
 802e494:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802e498:	615a      	str	r2, [r3, #20]

    /* Enable the UART Transmit Complete Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 802e49a:	68fb      	ldr	r3, [r7, #12]
 802e49c:	681b      	ldr	r3, [r3, #0]
 802e49e:	68da      	ldr	r2, [r3, #12]
 802e4a0:	68fb      	ldr	r3, [r7, #12]
 802e4a2:	681b      	ldr	r3, [r3, #0]
 802e4a4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802e4a8:	60da      	str	r2, [r3, #12]
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 802e4aa:	e002      	b.n	802e4b2 <UART_DMATransmitCplt+0x4a>
    HAL_UART_TxCpltCallback(huart);
 802e4ac:	68f8      	ldr	r0, [r7, #12]
 802e4ae:	f7fc f843 	bl	802a538 <HAL_UART_TxCpltCallback>
}
 802e4b2:	bf00      	nop
 802e4b4:	3710      	adds	r7, #16
 802e4b6:	46bd      	mov	sp, r7
 802e4b8:	bd80      	pop	{r7, pc}

0802e4ba <UART_DMATxHalfCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 802e4ba:	b580      	push	{r7, lr}
 802e4bc:	b084      	sub	sp, #16
 802e4be:	af00      	add	r7, sp, #0
 802e4c0:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802e4c2:	687b      	ldr	r3, [r7, #4]
 802e4c4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802e4c6:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 802e4c8:	68f8      	ldr	r0, [r7, #12]
 802e4ca:	f7ff ffaf 	bl	802e42c <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802e4ce:	bf00      	nop
 802e4d0:	3710      	adds	r7, #16
 802e4d2:	46bd      	mov	sp, r7
 802e4d4:	bd80      	pop	{r7, pc}

0802e4d6 <UART_DMAError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 802e4d6:	b580      	push	{r7, lr}
 802e4d8:	b084      	sub	sp, #16
 802e4da:	af00      	add	r7, sp, #0
 802e4dc:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 802e4de:	2300      	movs	r3, #0
 802e4e0:	60fb      	str	r3, [r7, #12]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802e4e2:	687b      	ldr	r3, [r7, #4]
 802e4e4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802e4e6:	60bb      	str	r3, [r7, #8]

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 802e4e8:	68bb      	ldr	r3, [r7, #8]
 802e4ea:	681b      	ldr	r3, [r3, #0]
 802e4ec:	695b      	ldr	r3, [r3, #20]
 802e4ee:	f003 0380 	and.w	r3, r3, #128	; 0x80
 802e4f2:	2b80      	cmp	r3, #128	; 0x80
 802e4f4:	bf0c      	ite	eq
 802e4f6:	2301      	moveq	r3, #1
 802e4f8:	2300      	movne	r3, #0
 802e4fa:	b2db      	uxtb	r3, r3
 802e4fc:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 802e4fe:	68bb      	ldr	r3, [r7, #8]
 802e500:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802e504:	b2db      	uxtb	r3, r3
 802e506:	2b21      	cmp	r3, #33	; 0x21
 802e508:	d108      	bne.n	802e51c <UART_DMAError+0x46>
 802e50a:	68fb      	ldr	r3, [r7, #12]
 802e50c:	2b00      	cmp	r3, #0
 802e50e:	d005      	beq.n	802e51c <UART_DMAError+0x46>
  {
    huart->TxXferCount = 0x00U;
 802e510:	68bb      	ldr	r3, [r7, #8]
 802e512:	2200      	movs	r2, #0
 802e514:	84da      	strh	r2, [r3, #38]	; 0x26
    UART_EndTxTransfer(huart);
 802e516:	68b8      	ldr	r0, [r7, #8]
 802e518:	f000 f827 	bl	802e56a <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 802e51c:	68bb      	ldr	r3, [r7, #8]
 802e51e:	681b      	ldr	r3, [r3, #0]
 802e520:	695b      	ldr	r3, [r3, #20]
 802e522:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802e526:	2b40      	cmp	r3, #64	; 0x40
 802e528:	bf0c      	ite	eq
 802e52a:	2301      	moveq	r3, #1
 802e52c:	2300      	movne	r3, #0
 802e52e:	b2db      	uxtb	r3, r3
 802e530:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 802e532:	68bb      	ldr	r3, [r7, #8]
 802e534:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802e538:	b2db      	uxtb	r3, r3
 802e53a:	2b22      	cmp	r3, #34	; 0x22
 802e53c:	d108      	bne.n	802e550 <UART_DMAError+0x7a>
 802e53e:	68fb      	ldr	r3, [r7, #12]
 802e540:	2b00      	cmp	r3, #0
 802e542:	d005      	beq.n	802e550 <UART_DMAError+0x7a>
  {
    huart->RxXferCount = 0x00U;
 802e544:	68bb      	ldr	r3, [r7, #8]
 802e546:	2200      	movs	r2, #0
 802e548:	85da      	strh	r2, [r3, #46]	; 0x2e
    UART_EndRxTransfer(huart);
 802e54a:	68b8      	ldr	r0, [r7, #8]
 802e54c:	f000 f823 	bl	802e596 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 802e550:	68bb      	ldr	r3, [r7, #8]
 802e552:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 802e554:	f043 0210 	orr.w	r2, r3, #16
 802e558:	68bb      	ldr	r3, [r7, #8]
 802e55a:	63da      	str	r2, [r3, #60]	; 0x3c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802e55c:	68b8      	ldr	r0, [r7, #8]
 802e55e:	f7ff ff79 	bl	802e454 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802e562:	bf00      	nop
 802e564:	3710      	adds	r7, #16
 802e566:	46bd      	mov	sp, r7
 802e568:	bd80      	pop	{r7, pc}

0802e56a <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 802e56a:	b480      	push	{r7}
 802e56c:	b083      	sub	sp, #12
 802e56e:	af00      	add	r7, sp, #0
 802e570:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 802e572:	687b      	ldr	r3, [r7, #4]
 802e574:	681b      	ldr	r3, [r3, #0]
 802e576:	68da      	ldr	r2, [r3, #12]
 802e578:	687b      	ldr	r3, [r7, #4]
 802e57a:	681b      	ldr	r3, [r3, #0]
 802e57c:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 802e580:	60da      	str	r2, [r3, #12]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802e582:	687b      	ldr	r3, [r7, #4]
 802e584:	2220      	movs	r2, #32
 802e586:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
}
 802e58a:	bf00      	nop
 802e58c:	370c      	adds	r7, #12
 802e58e:	46bd      	mov	sp, r7
 802e590:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e594:	4770      	bx	lr

0802e596 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 802e596:	b480      	push	{r7}
 802e598:	b083      	sub	sp, #12
 802e59a:	af00      	add	r7, sp, #0
 802e59c:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 802e59e:	687b      	ldr	r3, [r7, #4]
 802e5a0:	681b      	ldr	r3, [r3, #0]
 802e5a2:	68da      	ldr	r2, [r3, #12]
 802e5a4:	687b      	ldr	r3, [r7, #4]
 802e5a6:	681b      	ldr	r3, [r3, #0]
 802e5a8:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 802e5ac:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 802e5ae:	687b      	ldr	r3, [r7, #4]
 802e5b0:	681b      	ldr	r3, [r3, #0]
 802e5b2:	695a      	ldr	r2, [r3, #20]
 802e5b4:	687b      	ldr	r3, [r7, #4]
 802e5b6:	681b      	ldr	r3, [r3, #0]
 802e5b8:	f022 0201 	bic.w	r2, r2, #1
 802e5bc:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 802e5be:	687b      	ldr	r3, [r7, #4]
 802e5c0:	2220      	movs	r2, #32
 802e5c2:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
}
 802e5c6:	bf00      	nop
 802e5c8:	370c      	adds	r7, #12
 802e5ca:	46bd      	mov	sp, r7
 802e5cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e5d0:	4770      	bx	lr

0802e5d2 <UART_DMAAbortOnError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 802e5d2:	b580      	push	{r7, lr}
 802e5d4:	b084      	sub	sp, #16
 802e5d6:	af00      	add	r7, sp, #0
 802e5d8:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 802e5da:	687b      	ldr	r3, [r7, #4]
 802e5dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802e5de:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0x00U;
 802e5e0:	68fb      	ldr	r3, [r7, #12]
 802e5e2:	2200      	movs	r2, #0
 802e5e4:	85da      	strh	r2, [r3, #46]	; 0x2e
  huart->TxXferCount = 0x00U;
 802e5e6:	68fb      	ldr	r3, [r7, #12]
 802e5e8:	2200      	movs	r2, #0
 802e5ea:	84da      	strh	r2, [r3, #38]	; 0x26
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 802e5ec:	68f8      	ldr	r0, [r7, #12]
 802e5ee:	f7ff ff31 	bl	802e454 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 802e5f2:	bf00      	nop
 802e5f4:	3710      	adds	r7, #16
 802e5f6:	46bd      	mov	sp, r7
 802e5f8:	bd80      	pop	{r7, pc}

0802e5fa <UART_Transmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
 802e5fa:	b480      	push	{r7}
 802e5fc:	b085      	sub	sp, #20
 802e5fe:	af00      	add	r7, sp, #0
 802e600:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 802e602:	687b      	ldr	r3, [r7, #4]
 802e604:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 802e608:	b2db      	uxtb	r3, r3
 802e60a:	2b21      	cmp	r3, #33	; 0x21
 802e60c:	d144      	bne.n	802e698 <UART_Transmit_IT+0x9e>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 802e60e:	687b      	ldr	r3, [r7, #4]
 802e610:	689b      	ldr	r3, [r3, #8]
 802e612:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 802e616:	d11a      	bne.n	802e64e <UART_Transmit_IT+0x54>
    {
      tmp = (uint16_t *) huart->pTxBuffPtr;
 802e618:	687b      	ldr	r3, [r7, #4]
 802e61a:	6a1b      	ldr	r3, [r3, #32]
 802e61c:	60fb      	str	r3, [r7, #12]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 802e61e:	68fb      	ldr	r3, [r7, #12]
 802e620:	881b      	ldrh	r3, [r3, #0]
 802e622:	461a      	mov	r2, r3
 802e624:	687b      	ldr	r3, [r7, #4]
 802e626:	681b      	ldr	r3, [r3, #0]
 802e628:	f3c2 0208 	ubfx	r2, r2, #0, #9
 802e62c:	605a      	str	r2, [r3, #4]
      if (huart->Init.Parity == UART_PARITY_NONE)
 802e62e:	687b      	ldr	r3, [r7, #4]
 802e630:	691b      	ldr	r3, [r3, #16]
 802e632:	2b00      	cmp	r3, #0
 802e634:	d105      	bne.n	802e642 <UART_Transmit_IT+0x48>
      {
        huart->pTxBuffPtr += 2U;
 802e636:	687b      	ldr	r3, [r7, #4]
 802e638:	6a1b      	ldr	r3, [r3, #32]
 802e63a:	1c9a      	adds	r2, r3, #2
 802e63c:	687b      	ldr	r3, [r7, #4]
 802e63e:	621a      	str	r2, [r3, #32]
 802e640:	e00e      	b.n	802e660 <UART_Transmit_IT+0x66>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 802e642:	687b      	ldr	r3, [r7, #4]
 802e644:	6a1b      	ldr	r3, [r3, #32]
 802e646:	1c5a      	adds	r2, r3, #1
 802e648:	687b      	ldr	r3, [r7, #4]
 802e64a:	621a      	str	r2, [r3, #32]
 802e64c:	e008      	b.n	802e660 <UART_Transmit_IT+0x66>
      }
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 802e64e:	687b      	ldr	r3, [r7, #4]
 802e650:	6a1b      	ldr	r3, [r3, #32]
 802e652:	1c59      	adds	r1, r3, #1
 802e654:	687a      	ldr	r2, [r7, #4]
 802e656:	6211      	str	r1, [r2, #32]
 802e658:	781a      	ldrb	r2, [r3, #0]
 802e65a:	687b      	ldr	r3, [r7, #4]
 802e65c:	681b      	ldr	r3, [r3, #0]
 802e65e:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 802e660:	687b      	ldr	r3, [r7, #4]
 802e662:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 802e664:	b29b      	uxth	r3, r3
 802e666:	3b01      	subs	r3, #1
 802e668:	b29b      	uxth	r3, r3
 802e66a:	687a      	ldr	r2, [r7, #4]
 802e66c:	4619      	mov	r1, r3
 802e66e:	84d1      	strh	r1, [r2, #38]	; 0x26
 802e670:	2b00      	cmp	r3, #0
 802e672:	d10f      	bne.n	802e694 <UART_Transmit_IT+0x9a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 802e674:	687b      	ldr	r3, [r7, #4]
 802e676:	681b      	ldr	r3, [r3, #0]
 802e678:	68da      	ldr	r2, [r3, #12]
 802e67a:	687b      	ldr	r3, [r7, #4]
 802e67c:	681b      	ldr	r3, [r3, #0]
 802e67e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 802e682:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 802e684:	687b      	ldr	r3, [r7, #4]
 802e686:	681b      	ldr	r3, [r3, #0]
 802e688:	68da      	ldr	r2, [r3, #12]
 802e68a:	687b      	ldr	r3, [r7, #4]
 802e68c:	681b      	ldr	r3, [r3, #0]
 802e68e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 802e692:	60da      	str	r2, [r3, #12]
    }
    return HAL_OK;
 802e694:	2300      	movs	r3, #0
 802e696:	e000      	b.n	802e69a <UART_Transmit_IT+0xa0>
  }
  else
  {
    return HAL_BUSY;
 802e698:	2302      	movs	r3, #2
  }
}
 802e69a:	4618      	mov	r0, r3
 802e69c:	3714      	adds	r7, #20
 802e69e:	46bd      	mov	sp, r7
 802e6a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802e6a4:	4770      	bx	lr

0802e6a6 <UART_EndTransmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 802e6a6:	b580      	push	{r7, lr}
 802e6a8:	b082      	sub	sp, #8
 802e6aa:	af00      	add	r7, sp, #0
 802e6ac:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 802e6ae:	687b      	ldr	r3, [r7, #4]
 802e6b0:	681b      	ldr	r3, [r3, #0]
 802e6b2:	68da      	ldr	r2, [r3, #12]
 802e6b4:	687b      	ldr	r3, [r7, #4]
 802e6b6:	681b      	ldr	r3, [r3, #0]
 802e6b8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 802e6bc:	60da      	str	r2, [r3, #12]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 802e6be:	687b      	ldr	r3, [r7, #4]
 802e6c0:	2220      	movs	r2, #32
 802e6c2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 802e6c6:	6878      	ldr	r0, [r7, #4]
 802e6c8:	f7fb ff36 	bl	802a538 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

  return HAL_OK;
 802e6cc:	2300      	movs	r3, #0
}
 802e6ce:	4618      	mov	r0, r3
 802e6d0:	3708      	adds	r7, #8
 802e6d2:	46bd      	mov	sp, r7
 802e6d4:	bd80      	pop	{r7, pc}

0802e6d6 <UART_Receive_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 802e6d6:	b580      	push	{r7, lr}
 802e6d8:	b084      	sub	sp, #16
 802e6da:	af00      	add	r7, sp, #0
 802e6dc:	6078      	str	r0, [r7, #4]
  uint16_t *tmp;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 802e6de:	687b      	ldr	r3, [r7, #4]
 802e6e0:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 802e6e4:	b2db      	uxtb	r3, r3
 802e6e6:	2b22      	cmp	r3, #34	; 0x22
 802e6e8:	d171      	bne.n	802e7ce <UART_Receive_IT+0xf8>
  {
    if (huart->Init.WordLength == UART_WORDLENGTH_9B)
 802e6ea:	687b      	ldr	r3, [r7, #4]
 802e6ec:	689b      	ldr	r3, [r3, #8]
 802e6ee:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 802e6f2:	d123      	bne.n	802e73c <UART_Receive_IT+0x66>
    {
      tmp = (uint16_t *) huart->pRxBuffPtr;
 802e6f4:	687b      	ldr	r3, [r7, #4]
 802e6f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802e6f8:	60fb      	str	r3, [r7, #12]
      if (huart->Init.Parity == UART_PARITY_NONE)
 802e6fa:	687b      	ldr	r3, [r7, #4]
 802e6fc:	691b      	ldr	r3, [r3, #16]
 802e6fe:	2b00      	cmp	r3, #0
 802e700:	d10e      	bne.n	802e720 <UART_Receive_IT+0x4a>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 802e702:	687b      	ldr	r3, [r7, #4]
 802e704:	681b      	ldr	r3, [r3, #0]
 802e706:	685b      	ldr	r3, [r3, #4]
 802e708:	b29b      	uxth	r3, r3
 802e70a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 802e70e:	b29a      	uxth	r2, r3
 802e710:	68fb      	ldr	r3, [r7, #12]
 802e712:	801a      	strh	r2, [r3, #0]
        huart->pRxBuffPtr += 2U;
 802e714:	687b      	ldr	r3, [r7, #4]
 802e716:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802e718:	1c9a      	adds	r2, r3, #2
 802e71a:	687b      	ldr	r3, [r7, #4]
 802e71c:	629a      	str	r2, [r3, #40]	; 0x28
 802e71e:	e029      	b.n	802e774 <UART_Receive_IT+0x9e>
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 802e720:	687b      	ldr	r3, [r7, #4]
 802e722:	681b      	ldr	r3, [r3, #0]
 802e724:	685b      	ldr	r3, [r3, #4]
 802e726:	b29b      	uxth	r3, r3
 802e728:	b2db      	uxtb	r3, r3
 802e72a:	b29a      	uxth	r2, r3
 802e72c:	68fb      	ldr	r3, [r7, #12]
 802e72e:	801a      	strh	r2, [r3, #0]
        huart->pRxBuffPtr += 1U;
 802e730:	687b      	ldr	r3, [r7, #4]
 802e732:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802e734:	1c5a      	adds	r2, r3, #1
 802e736:	687b      	ldr	r3, [r7, #4]
 802e738:	629a      	str	r2, [r3, #40]	; 0x28
 802e73a:	e01b      	b.n	802e774 <UART_Receive_IT+0x9e>
      }
    }
    else
    {
      if (huart->Init.Parity == UART_PARITY_NONE)
 802e73c:	687b      	ldr	r3, [r7, #4]
 802e73e:	691b      	ldr	r3, [r3, #16]
 802e740:	2b00      	cmp	r3, #0
 802e742:	d10a      	bne.n	802e75a <UART_Receive_IT+0x84>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 802e744:	687b      	ldr	r3, [r7, #4]
 802e746:	681b      	ldr	r3, [r3, #0]
 802e748:	6858      	ldr	r0, [r3, #4]
 802e74a:	687b      	ldr	r3, [r7, #4]
 802e74c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802e74e:	1c59      	adds	r1, r3, #1
 802e750:	687a      	ldr	r2, [r7, #4]
 802e752:	6291      	str	r1, [r2, #40]	; 0x28
 802e754:	b2c2      	uxtb	r2, r0
 802e756:	701a      	strb	r2, [r3, #0]
 802e758:	e00c      	b.n	802e774 <UART_Receive_IT+0x9e>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 802e75a:	687b      	ldr	r3, [r7, #4]
 802e75c:	681b      	ldr	r3, [r3, #0]
 802e75e:	685b      	ldr	r3, [r3, #4]
 802e760:	b2da      	uxtb	r2, r3
 802e762:	687b      	ldr	r3, [r7, #4]
 802e764:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802e766:	1c58      	adds	r0, r3, #1
 802e768:	6879      	ldr	r1, [r7, #4]
 802e76a:	6288      	str	r0, [r1, #40]	; 0x28
 802e76c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 802e770:	b2d2      	uxtb	r2, r2
 802e772:	701a      	strb	r2, [r3, #0]
      }
    }

    if (--huart->RxXferCount == 0U)
 802e774:	687b      	ldr	r3, [r7, #4]
 802e776:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
 802e778:	b29b      	uxth	r3, r3
 802e77a:	3b01      	subs	r3, #1
 802e77c:	b29b      	uxth	r3, r3
 802e77e:	687a      	ldr	r2, [r7, #4]
 802e780:	4619      	mov	r1, r3
 802e782:	85d1      	strh	r1, [r2, #46]	; 0x2e
 802e784:	2b00      	cmp	r3, #0
 802e786:	d120      	bne.n	802e7ca <UART_Receive_IT+0xf4>
    {
      /* Disable the UART Data Register not empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 802e788:	687b      	ldr	r3, [r7, #4]
 802e78a:	681b      	ldr	r3, [r3, #0]
 802e78c:	68da      	ldr	r2, [r3, #12]
 802e78e:	687b      	ldr	r3, [r7, #4]
 802e790:	681b      	ldr	r3, [r3, #0]
 802e792:	f022 0220 	bic.w	r2, r2, #32
 802e796:	60da      	str	r2, [r3, #12]

      /* Disable the UART Parity Error Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 802e798:	687b      	ldr	r3, [r7, #4]
 802e79a:	681b      	ldr	r3, [r3, #0]
 802e79c:	68da      	ldr	r2, [r3, #12]
 802e79e:	687b      	ldr	r3, [r7, #4]
 802e7a0:	681b      	ldr	r3, [r3, #0]
 802e7a2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 802e7a6:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 802e7a8:	687b      	ldr	r3, [r7, #4]
 802e7aa:	681b      	ldr	r3, [r3, #0]
 802e7ac:	695a      	ldr	r2, [r3, #20]
 802e7ae:	687b      	ldr	r3, [r7, #4]
 802e7b0:	681b      	ldr	r3, [r3, #0]
 802e7b2:	f022 0201 	bic.w	r2, r2, #1
 802e7b6:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 802e7b8:	687b      	ldr	r3, [r7, #4]
 802e7ba:	2220      	movs	r2, #32
 802e7bc:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 802e7c0:	6878      	ldr	r0, [r7, #4]
 802e7c2:	f7ff fe3d 	bl	802e440 <HAL_UART_RxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

      return HAL_OK;
 802e7c6:	2300      	movs	r3, #0
 802e7c8:	e002      	b.n	802e7d0 <UART_Receive_IT+0xfa>
    }
    return HAL_OK;
 802e7ca:	2300      	movs	r3, #0
 802e7cc:	e000      	b.n	802e7d0 <UART_Receive_IT+0xfa>
  }
  else
  {
    return HAL_BUSY;
 802e7ce:	2302      	movs	r3, #2
  }
}
 802e7d0:	4618      	mov	r0, r3
 802e7d2:	3710      	adds	r7, #16
 802e7d4:	46bd      	mov	sp, r7
 802e7d6:	bd80      	pop	{r7, pc}

0802e7d8 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 802e7d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802e7dc:	b085      	sub	sp, #20
 802e7de:	af00      	add	r7, sp, #0
 802e7e0:	6078      	str	r0, [r7, #4]
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 802e7e2:	687b      	ldr	r3, [r7, #4]
 802e7e4:	681b      	ldr	r3, [r3, #0]
 802e7e6:	691b      	ldr	r3, [r3, #16]
 802e7e8:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 802e7ec:	687b      	ldr	r3, [r7, #4]
 802e7ee:	68da      	ldr	r2, [r3, #12]
 802e7f0:	687b      	ldr	r3, [r7, #4]
 802e7f2:	681b      	ldr	r3, [r3, #0]
 802e7f4:	430a      	orrs	r2, r1
 802e7f6:	611a      	str	r2, [r3, #16]
     Set the M bits according to huart->Init.WordLength value
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */

  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 802e7f8:	687b      	ldr	r3, [r7, #4]
 802e7fa:	689a      	ldr	r2, [r3, #8]
 802e7fc:	687b      	ldr	r3, [r7, #4]
 802e7fe:	691b      	ldr	r3, [r3, #16]
 802e800:	431a      	orrs	r2, r3
 802e802:	687b      	ldr	r3, [r7, #4]
 802e804:	695b      	ldr	r3, [r3, #20]
 802e806:	431a      	orrs	r2, r3
 802e808:	687b      	ldr	r3, [r7, #4]
 802e80a:	69db      	ldr	r3, [r3, #28]
 802e80c:	4313      	orrs	r3, r2
 802e80e:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(huart->Instance->CR1,
 802e810:	687b      	ldr	r3, [r7, #4]
 802e812:	681b      	ldr	r3, [r3, #0]
 802e814:	68db      	ldr	r3, [r3, #12]
 802e816:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
 802e81a:	f023 030c 	bic.w	r3, r3, #12
 802e81e:	687a      	ldr	r2, [r7, #4]
 802e820:	6812      	ldr	r2, [r2, #0]
 802e822:	68f9      	ldr	r1, [r7, #12]
 802e824:	430b      	orrs	r3, r1
 802e826:	60d3      	str	r3, [r2, #12]
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 802e828:	687b      	ldr	r3, [r7, #4]
 802e82a:	681b      	ldr	r3, [r3, #0]
 802e82c:	695b      	ldr	r3, [r3, #20]
 802e82e:	f423 7140 	bic.w	r1, r3, #768	; 0x300
 802e832:	687b      	ldr	r3, [r7, #4]
 802e834:	699a      	ldr	r2, [r3, #24]
 802e836:	687b      	ldr	r3, [r7, #4]
 802e838:	681b      	ldr	r3, [r3, #0]
 802e83a:	430a      	orrs	r2, r1
 802e83c:	615a      	str	r2, [r3, #20]

  /* Check the Over Sampling */
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 802e83e:	687b      	ldr	r3, [r7, #4]
 802e840:	69db      	ldr	r3, [r3, #28]
 802e842:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 802e846:	f040 818b 	bne.w	802eb60 <UART_SetConfig+0x388>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#elif defined(USART6)
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 802e84a:	687b      	ldr	r3, [r7, #4]
 802e84c:	681b      	ldr	r3, [r3, #0]
 802e84e:	4ac1      	ldr	r2, [pc, #772]	; (802eb54 <UART_SetConfig+0x37c>)
 802e850:	4293      	cmp	r3, r2
 802e852:	d005      	beq.n	802e860 <UART_SetConfig+0x88>
 802e854:	687b      	ldr	r3, [r7, #4]
 802e856:	681b      	ldr	r3, [r3, #0]
 802e858:	4abf      	ldr	r2, [pc, #764]	; (802eb58 <UART_SetConfig+0x380>)
 802e85a:	4293      	cmp	r3, r2
 802e85c:	f040 80bd 	bne.w	802e9da <UART_SetConfig+0x202>
    {
      pclk = HAL_RCC_GetPCLK2Freq();
 802e860:	f7fd ff4a 	bl	802c6f8 <HAL_RCC_GetPCLK2Freq>
 802e864:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 802e866:	68bb      	ldr	r3, [r7, #8]
 802e868:	461d      	mov	r5, r3
 802e86a:	f04f 0600 	mov.w	r6, #0
 802e86e:	46a8      	mov	r8, r5
 802e870:	46b1      	mov	r9, r6
 802e872:	eb18 0308 	adds.w	r3, r8, r8
 802e876:	eb49 0409 	adc.w	r4, r9, r9
 802e87a:	4698      	mov	r8, r3
 802e87c:	46a1      	mov	r9, r4
 802e87e:	eb18 0805 	adds.w	r8, r8, r5
 802e882:	eb49 0906 	adc.w	r9, r9, r6
 802e886:	f04f 0100 	mov.w	r1, #0
 802e88a:	f04f 0200 	mov.w	r2, #0
 802e88e:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802e892:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802e896:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802e89a:	4688      	mov	r8, r1
 802e89c:	4691      	mov	r9, r2
 802e89e:	eb18 0005 	adds.w	r0, r8, r5
 802e8a2:	eb49 0106 	adc.w	r1, r9, r6
 802e8a6:	687b      	ldr	r3, [r7, #4]
 802e8a8:	685b      	ldr	r3, [r3, #4]
 802e8aa:	461d      	mov	r5, r3
 802e8ac:	f04f 0600 	mov.w	r6, #0
 802e8b0:	196b      	adds	r3, r5, r5
 802e8b2:	eb46 0406 	adc.w	r4, r6, r6
 802e8b6:	461a      	mov	r2, r3
 802e8b8:	4623      	mov	r3, r4
 802e8ba:	f7f9 fdf5 	bl	80284a8 <__aeabi_uldivmod>
 802e8be:	4603      	mov	r3, r0
 802e8c0:	460c      	mov	r4, r1
 802e8c2:	461a      	mov	r2, r3
 802e8c4:	4ba5      	ldr	r3, [pc, #660]	; (802eb5c <UART_SetConfig+0x384>)
 802e8c6:	fba3 2302 	umull	r2, r3, r3, r2
 802e8ca:	095b      	lsrs	r3, r3, #5
 802e8cc:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802e8d0:	68bb      	ldr	r3, [r7, #8]
 802e8d2:	461d      	mov	r5, r3
 802e8d4:	f04f 0600 	mov.w	r6, #0
 802e8d8:	46a9      	mov	r9, r5
 802e8da:	46b2      	mov	sl, r6
 802e8dc:	eb19 0309 	adds.w	r3, r9, r9
 802e8e0:	eb4a 040a 	adc.w	r4, sl, sl
 802e8e4:	4699      	mov	r9, r3
 802e8e6:	46a2      	mov	sl, r4
 802e8e8:	eb19 0905 	adds.w	r9, r9, r5
 802e8ec:	eb4a 0a06 	adc.w	sl, sl, r6
 802e8f0:	f04f 0100 	mov.w	r1, #0
 802e8f4:	f04f 0200 	mov.w	r2, #0
 802e8f8:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802e8fc:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802e900:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802e904:	4689      	mov	r9, r1
 802e906:	4692      	mov	sl, r2
 802e908:	eb19 0005 	adds.w	r0, r9, r5
 802e90c:	eb4a 0106 	adc.w	r1, sl, r6
 802e910:	687b      	ldr	r3, [r7, #4]
 802e912:	685b      	ldr	r3, [r3, #4]
 802e914:	461d      	mov	r5, r3
 802e916:	f04f 0600 	mov.w	r6, #0
 802e91a:	196b      	adds	r3, r5, r5
 802e91c:	eb46 0406 	adc.w	r4, r6, r6
 802e920:	461a      	mov	r2, r3
 802e922:	4623      	mov	r3, r4
 802e924:	f7f9 fdc0 	bl	80284a8 <__aeabi_uldivmod>
 802e928:	4603      	mov	r3, r0
 802e92a:	460c      	mov	r4, r1
 802e92c:	461a      	mov	r2, r3
 802e92e:	4b8b      	ldr	r3, [pc, #556]	; (802eb5c <UART_SetConfig+0x384>)
 802e930:	fba3 1302 	umull	r1, r3, r3, r2
 802e934:	095b      	lsrs	r3, r3, #5
 802e936:	2164      	movs	r1, #100	; 0x64
 802e938:	fb01 f303 	mul.w	r3, r1, r3
 802e93c:	1ad3      	subs	r3, r2, r3
 802e93e:	00db      	lsls	r3, r3, #3
 802e940:	3332      	adds	r3, #50	; 0x32
 802e942:	4a86      	ldr	r2, [pc, #536]	; (802eb5c <UART_SetConfig+0x384>)
 802e944:	fba2 2303 	umull	r2, r3, r2, r3
 802e948:	095b      	lsrs	r3, r3, #5
 802e94a:	005b      	lsls	r3, r3, #1
 802e94c:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 802e950:	4498      	add	r8, r3
 802e952:	68bb      	ldr	r3, [r7, #8]
 802e954:	461d      	mov	r5, r3
 802e956:	f04f 0600 	mov.w	r6, #0
 802e95a:	46a9      	mov	r9, r5
 802e95c:	46b2      	mov	sl, r6
 802e95e:	eb19 0309 	adds.w	r3, r9, r9
 802e962:	eb4a 040a 	adc.w	r4, sl, sl
 802e966:	4699      	mov	r9, r3
 802e968:	46a2      	mov	sl, r4
 802e96a:	eb19 0905 	adds.w	r9, r9, r5
 802e96e:	eb4a 0a06 	adc.w	sl, sl, r6
 802e972:	f04f 0100 	mov.w	r1, #0
 802e976:	f04f 0200 	mov.w	r2, #0
 802e97a:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802e97e:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802e982:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802e986:	4689      	mov	r9, r1
 802e988:	4692      	mov	sl, r2
 802e98a:	eb19 0005 	adds.w	r0, r9, r5
 802e98e:	eb4a 0106 	adc.w	r1, sl, r6
 802e992:	687b      	ldr	r3, [r7, #4]
 802e994:	685b      	ldr	r3, [r3, #4]
 802e996:	461d      	mov	r5, r3
 802e998:	f04f 0600 	mov.w	r6, #0
 802e99c:	196b      	adds	r3, r5, r5
 802e99e:	eb46 0406 	adc.w	r4, r6, r6
 802e9a2:	461a      	mov	r2, r3
 802e9a4:	4623      	mov	r3, r4
 802e9a6:	f7f9 fd7f 	bl	80284a8 <__aeabi_uldivmod>
 802e9aa:	4603      	mov	r3, r0
 802e9ac:	460c      	mov	r4, r1
 802e9ae:	461a      	mov	r2, r3
 802e9b0:	4b6a      	ldr	r3, [pc, #424]	; (802eb5c <UART_SetConfig+0x384>)
 802e9b2:	fba3 1302 	umull	r1, r3, r3, r2
 802e9b6:	095b      	lsrs	r3, r3, #5
 802e9b8:	2164      	movs	r1, #100	; 0x64
 802e9ba:	fb01 f303 	mul.w	r3, r1, r3
 802e9be:	1ad3      	subs	r3, r2, r3
 802e9c0:	00db      	lsls	r3, r3, #3
 802e9c2:	3332      	adds	r3, #50	; 0x32
 802e9c4:	4a65      	ldr	r2, [pc, #404]	; (802eb5c <UART_SetConfig+0x384>)
 802e9c6:	fba2 2303 	umull	r2, r3, r2, r3
 802e9ca:	095b      	lsrs	r3, r3, #5
 802e9cc:	f003 0207 	and.w	r2, r3, #7
 802e9d0:	687b      	ldr	r3, [r7, #4]
 802e9d2:	681b      	ldr	r3, [r3, #0]
 802e9d4:	4442      	add	r2, r8
 802e9d6:	609a      	str	r2, [r3, #8]
 802e9d8:	e26f      	b.n	802eeba <UART_SetConfig+0x6e2>
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
    }
#endif /* USART6 */
    else
    {
      pclk = HAL_RCC_GetPCLK1Freq();
 802e9da:	f7fd fe79 	bl	802c6d0 <HAL_RCC_GetPCLK1Freq>
 802e9de:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
 802e9e0:	68bb      	ldr	r3, [r7, #8]
 802e9e2:	461d      	mov	r5, r3
 802e9e4:	f04f 0600 	mov.w	r6, #0
 802e9e8:	46a8      	mov	r8, r5
 802e9ea:	46b1      	mov	r9, r6
 802e9ec:	eb18 0308 	adds.w	r3, r8, r8
 802e9f0:	eb49 0409 	adc.w	r4, r9, r9
 802e9f4:	4698      	mov	r8, r3
 802e9f6:	46a1      	mov	r9, r4
 802e9f8:	eb18 0805 	adds.w	r8, r8, r5
 802e9fc:	eb49 0906 	adc.w	r9, r9, r6
 802ea00:	f04f 0100 	mov.w	r1, #0
 802ea04:	f04f 0200 	mov.w	r2, #0
 802ea08:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802ea0c:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802ea10:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802ea14:	4688      	mov	r8, r1
 802ea16:	4691      	mov	r9, r2
 802ea18:	eb18 0005 	adds.w	r0, r8, r5
 802ea1c:	eb49 0106 	adc.w	r1, r9, r6
 802ea20:	687b      	ldr	r3, [r7, #4]
 802ea22:	685b      	ldr	r3, [r3, #4]
 802ea24:	461d      	mov	r5, r3
 802ea26:	f04f 0600 	mov.w	r6, #0
 802ea2a:	196b      	adds	r3, r5, r5
 802ea2c:	eb46 0406 	adc.w	r4, r6, r6
 802ea30:	461a      	mov	r2, r3
 802ea32:	4623      	mov	r3, r4
 802ea34:	f7f9 fd38 	bl	80284a8 <__aeabi_uldivmod>
 802ea38:	4603      	mov	r3, r0
 802ea3a:	460c      	mov	r4, r1
 802ea3c:	461a      	mov	r2, r3
 802ea3e:	4b47      	ldr	r3, [pc, #284]	; (802eb5c <UART_SetConfig+0x384>)
 802ea40:	fba3 2302 	umull	r2, r3, r3, r2
 802ea44:	095b      	lsrs	r3, r3, #5
 802ea46:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802ea4a:	68bb      	ldr	r3, [r7, #8]
 802ea4c:	461d      	mov	r5, r3
 802ea4e:	f04f 0600 	mov.w	r6, #0
 802ea52:	46a9      	mov	r9, r5
 802ea54:	46b2      	mov	sl, r6
 802ea56:	eb19 0309 	adds.w	r3, r9, r9
 802ea5a:	eb4a 040a 	adc.w	r4, sl, sl
 802ea5e:	4699      	mov	r9, r3
 802ea60:	46a2      	mov	sl, r4
 802ea62:	eb19 0905 	adds.w	r9, r9, r5
 802ea66:	eb4a 0a06 	adc.w	sl, sl, r6
 802ea6a:	f04f 0100 	mov.w	r1, #0
 802ea6e:	f04f 0200 	mov.w	r2, #0
 802ea72:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802ea76:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802ea7a:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802ea7e:	4689      	mov	r9, r1
 802ea80:	4692      	mov	sl, r2
 802ea82:	eb19 0005 	adds.w	r0, r9, r5
 802ea86:	eb4a 0106 	adc.w	r1, sl, r6
 802ea8a:	687b      	ldr	r3, [r7, #4]
 802ea8c:	685b      	ldr	r3, [r3, #4]
 802ea8e:	461d      	mov	r5, r3
 802ea90:	f04f 0600 	mov.w	r6, #0
 802ea94:	196b      	adds	r3, r5, r5
 802ea96:	eb46 0406 	adc.w	r4, r6, r6
 802ea9a:	461a      	mov	r2, r3
 802ea9c:	4623      	mov	r3, r4
 802ea9e:	f7f9 fd03 	bl	80284a8 <__aeabi_uldivmod>
 802eaa2:	4603      	mov	r3, r0
 802eaa4:	460c      	mov	r4, r1
 802eaa6:	461a      	mov	r2, r3
 802eaa8:	4b2c      	ldr	r3, [pc, #176]	; (802eb5c <UART_SetConfig+0x384>)
 802eaaa:	fba3 1302 	umull	r1, r3, r3, r2
 802eaae:	095b      	lsrs	r3, r3, #5
 802eab0:	2164      	movs	r1, #100	; 0x64
 802eab2:	fb01 f303 	mul.w	r3, r1, r3
 802eab6:	1ad3      	subs	r3, r2, r3
 802eab8:	00db      	lsls	r3, r3, #3
 802eaba:	3332      	adds	r3, #50	; 0x32
 802eabc:	4a27      	ldr	r2, [pc, #156]	; (802eb5c <UART_SetConfig+0x384>)
 802eabe:	fba2 2303 	umull	r2, r3, r2, r3
 802eac2:	095b      	lsrs	r3, r3, #5
 802eac4:	005b      	lsls	r3, r3, #1
 802eac6:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 802eaca:	4498      	add	r8, r3
 802eacc:	68bb      	ldr	r3, [r7, #8]
 802eace:	461d      	mov	r5, r3
 802ead0:	f04f 0600 	mov.w	r6, #0
 802ead4:	46a9      	mov	r9, r5
 802ead6:	46b2      	mov	sl, r6
 802ead8:	eb19 0309 	adds.w	r3, r9, r9
 802eadc:	eb4a 040a 	adc.w	r4, sl, sl
 802eae0:	4699      	mov	r9, r3
 802eae2:	46a2      	mov	sl, r4
 802eae4:	eb19 0905 	adds.w	r9, r9, r5
 802eae8:	eb4a 0a06 	adc.w	sl, sl, r6
 802eaec:	f04f 0100 	mov.w	r1, #0
 802eaf0:	f04f 0200 	mov.w	r2, #0
 802eaf4:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802eaf8:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802eafc:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802eb00:	4689      	mov	r9, r1
 802eb02:	4692      	mov	sl, r2
 802eb04:	eb19 0005 	adds.w	r0, r9, r5
 802eb08:	eb4a 0106 	adc.w	r1, sl, r6
 802eb0c:	687b      	ldr	r3, [r7, #4]
 802eb0e:	685b      	ldr	r3, [r3, #4]
 802eb10:	461d      	mov	r5, r3
 802eb12:	f04f 0600 	mov.w	r6, #0
 802eb16:	196b      	adds	r3, r5, r5
 802eb18:	eb46 0406 	adc.w	r4, r6, r6
 802eb1c:	461a      	mov	r2, r3
 802eb1e:	4623      	mov	r3, r4
 802eb20:	f7f9 fcc2 	bl	80284a8 <__aeabi_uldivmod>
 802eb24:	4603      	mov	r3, r0
 802eb26:	460c      	mov	r4, r1
 802eb28:	461a      	mov	r2, r3
 802eb2a:	4b0c      	ldr	r3, [pc, #48]	; (802eb5c <UART_SetConfig+0x384>)
 802eb2c:	fba3 1302 	umull	r1, r3, r3, r2
 802eb30:	095b      	lsrs	r3, r3, #5
 802eb32:	2164      	movs	r1, #100	; 0x64
 802eb34:	fb01 f303 	mul.w	r3, r1, r3
 802eb38:	1ad3      	subs	r3, r2, r3
 802eb3a:	00db      	lsls	r3, r3, #3
 802eb3c:	3332      	adds	r3, #50	; 0x32
 802eb3e:	4a07      	ldr	r2, [pc, #28]	; (802eb5c <UART_SetConfig+0x384>)
 802eb40:	fba2 2303 	umull	r2, r3, r2, r3
 802eb44:	095b      	lsrs	r3, r3, #5
 802eb46:	f003 0207 	and.w	r2, r3, #7
 802eb4a:	687b      	ldr	r3, [r7, #4]
 802eb4c:	681b      	ldr	r3, [r3, #0]
 802eb4e:	4442      	add	r2, r8
 802eb50:	609a      	str	r2, [r3, #8]
    {
      pclk = HAL_RCC_GetPCLK1Freq();
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
    }
  }
}
 802eb52:	e1b2      	b.n	802eeba <UART_SetConfig+0x6e2>
 802eb54:	40011000 	.word	0x40011000
 802eb58:	40011400 	.word	0x40011400
 802eb5c:	51eb851f 	.word	0x51eb851f
    if ((huart->Instance == USART1) || (huart->Instance == USART6))
 802eb60:	687b      	ldr	r3, [r7, #4]
 802eb62:	681b      	ldr	r3, [r3, #0]
 802eb64:	4ad7      	ldr	r2, [pc, #860]	; (802eec4 <UART_SetConfig+0x6ec>)
 802eb66:	4293      	cmp	r3, r2
 802eb68:	d005      	beq.n	802eb76 <UART_SetConfig+0x39e>
 802eb6a:	687b      	ldr	r3, [r7, #4]
 802eb6c:	681b      	ldr	r3, [r3, #0]
 802eb6e:	4ad6      	ldr	r2, [pc, #856]	; (802eec8 <UART_SetConfig+0x6f0>)
 802eb70:	4293      	cmp	r3, r2
 802eb72:	f040 80d1 	bne.w	802ed18 <UART_SetConfig+0x540>
      pclk = HAL_RCC_GetPCLK2Freq();
 802eb76:	f7fd fdbf 	bl	802c6f8 <HAL_RCC_GetPCLK2Freq>
 802eb7a:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 802eb7c:	68bb      	ldr	r3, [r7, #8]
 802eb7e:	469a      	mov	sl, r3
 802eb80:	f04f 0b00 	mov.w	fp, #0
 802eb84:	46d0      	mov	r8, sl
 802eb86:	46d9      	mov	r9, fp
 802eb88:	eb18 0308 	adds.w	r3, r8, r8
 802eb8c:	eb49 0409 	adc.w	r4, r9, r9
 802eb90:	4698      	mov	r8, r3
 802eb92:	46a1      	mov	r9, r4
 802eb94:	eb18 080a 	adds.w	r8, r8, sl
 802eb98:	eb49 090b 	adc.w	r9, r9, fp
 802eb9c:	f04f 0100 	mov.w	r1, #0
 802eba0:	f04f 0200 	mov.w	r2, #0
 802eba4:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802eba8:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802ebac:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802ebb0:	4688      	mov	r8, r1
 802ebb2:	4691      	mov	r9, r2
 802ebb4:	eb1a 0508 	adds.w	r5, sl, r8
 802ebb8:	eb4b 0609 	adc.w	r6, fp, r9
 802ebbc:	687b      	ldr	r3, [r7, #4]
 802ebbe:	685b      	ldr	r3, [r3, #4]
 802ebc0:	4619      	mov	r1, r3
 802ebc2:	f04f 0200 	mov.w	r2, #0
 802ebc6:	f04f 0300 	mov.w	r3, #0
 802ebca:	f04f 0400 	mov.w	r4, #0
 802ebce:	0094      	lsls	r4, r2, #2
 802ebd0:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802ebd4:	008b      	lsls	r3, r1, #2
 802ebd6:	461a      	mov	r2, r3
 802ebd8:	4623      	mov	r3, r4
 802ebda:	4628      	mov	r0, r5
 802ebdc:	4631      	mov	r1, r6
 802ebde:	f7f9 fc63 	bl	80284a8 <__aeabi_uldivmod>
 802ebe2:	4603      	mov	r3, r0
 802ebe4:	460c      	mov	r4, r1
 802ebe6:	461a      	mov	r2, r3
 802ebe8:	4bb8      	ldr	r3, [pc, #736]	; (802eecc <UART_SetConfig+0x6f4>)
 802ebea:	fba3 2302 	umull	r2, r3, r3, r2
 802ebee:	095b      	lsrs	r3, r3, #5
 802ebf0:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802ebf4:	68bb      	ldr	r3, [r7, #8]
 802ebf6:	469b      	mov	fp, r3
 802ebf8:	f04f 0c00 	mov.w	ip, #0
 802ebfc:	46d9      	mov	r9, fp
 802ebfe:	46e2      	mov	sl, ip
 802ec00:	eb19 0309 	adds.w	r3, r9, r9
 802ec04:	eb4a 040a 	adc.w	r4, sl, sl
 802ec08:	4699      	mov	r9, r3
 802ec0a:	46a2      	mov	sl, r4
 802ec0c:	eb19 090b 	adds.w	r9, r9, fp
 802ec10:	eb4a 0a0c 	adc.w	sl, sl, ip
 802ec14:	f04f 0100 	mov.w	r1, #0
 802ec18:	f04f 0200 	mov.w	r2, #0
 802ec1c:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802ec20:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802ec24:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802ec28:	4689      	mov	r9, r1
 802ec2a:	4692      	mov	sl, r2
 802ec2c:	eb1b 0509 	adds.w	r5, fp, r9
 802ec30:	eb4c 060a 	adc.w	r6, ip, sl
 802ec34:	687b      	ldr	r3, [r7, #4]
 802ec36:	685b      	ldr	r3, [r3, #4]
 802ec38:	4619      	mov	r1, r3
 802ec3a:	f04f 0200 	mov.w	r2, #0
 802ec3e:	f04f 0300 	mov.w	r3, #0
 802ec42:	f04f 0400 	mov.w	r4, #0
 802ec46:	0094      	lsls	r4, r2, #2
 802ec48:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802ec4c:	008b      	lsls	r3, r1, #2
 802ec4e:	461a      	mov	r2, r3
 802ec50:	4623      	mov	r3, r4
 802ec52:	4628      	mov	r0, r5
 802ec54:	4631      	mov	r1, r6
 802ec56:	f7f9 fc27 	bl	80284a8 <__aeabi_uldivmod>
 802ec5a:	4603      	mov	r3, r0
 802ec5c:	460c      	mov	r4, r1
 802ec5e:	461a      	mov	r2, r3
 802ec60:	4b9a      	ldr	r3, [pc, #616]	; (802eecc <UART_SetConfig+0x6f4>)
 802ec62:	fba3 1302 	umull	r1, r3, r3, r2
 802ec66:	095b      	lsrs	r3, r3, #5
 802ec68:	2164      	movs	r1, #100	; 0x64
 802ec6a:	fb01 f303 	mul.w	r3, r1, r3
 802ec6e:	1ad3      	subs	r3, r2, r3
 802ec70:	011b      	lsls	r3, r3, #4
 802ec72:	3332      	adds	r3, #50	; 0x32
 802ec74:	4a95      	ldr	r2, [pc, #596]	; (802eecc <UART_SetConfig+0x6f4>)
 802ec76:	fba2 2303 	umull	r2, r3, r2, r3
 802ec7a:	095b      	lsrs	r3, r3, #5
 802ec7c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802ec80:	4498      	add	r8, r3
 802ec82:	68bb      	ldr	r3, [r7, #8]
 802ec84:	469b      	mov	fp, r3
 802ec86:	f04f 0c00 	mov.w	ip, #0
 802ec8a:	46d9      	mov	r9, fp
 802ec8c:	46e2      	mov	sl, ip
 802ec8e:	eb19 0309 	adds.w	r3, r9, r9
 802ec92:	eb4a 040a 	adc.w	r4, sl, sl
 802ec96:	4699      	mov	r9, r3
 802ec98:	46a2      	mov	sl, r4
 802ec9a:	eb19 090b 	adds.w	r9, r9, fp
 802ec9e:	eb4a 0a0c 	adc.w	sl, sl, ip
 802eca2:	f04f 0100 	mov.w	r1, #0
 802eca6:	f04f 0200 	mov.w	r2, #0
 802ecaa:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802ecae:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802ecb2:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802ecb6:	4689      	mov	r9, r1
 802ecb8:	4692      	mov	sl, r2
 802ecba:	eb1b 0509 	adds.w	r5, fp, r9
 802ecbe:	eb4c 060a 	adc.w	r6, ip, sl
 802ecc2:	687b      	ldr	r3, [r7, #4]
 802ecc4:	685b      	ldr	r3, [r3, #4]
 802ecc6:	4619      	mov	r1, r3
 802ecc8:	f04f 0200 	mov.w	r2, #0
 802eccc:	f04f 0300 	mov.w	r3, #0
 802ecd0:	f04f 0400 	mov.w	r4, #0
 802ecd4:	0094      	lsls	r4, r2, #2
 802ecd6:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802ecda:	008b      	lsls	r3, r1, #2
 802ecdc:	461a      	mov	r2, r3
 802ecde:	4623      	mov	r3, r4
 802ece0:	4628      	mov	r0, r5
 802ece2:	4631      	mov	r1, r6
 802ece4:	f7f9 fbe0 	bl	80284a8 <__aeabi_uldivmod>
 802ece8:	4603      	mov	r3, r0
 802ecea:	460c      	mov	r4, r1
 802ecec:	461a      	mov	r2, r3
 802ecee:	4b77      	ldr	r3, [pc, #476]	; (802eecc <UART_SetConfig+0x6f4>)
 802ecf0:	fba3 1302 	umull	r1, r3, r3, r2
 802ecf4:	095b      	lsrs	r3, r3, #5
 802ecf6:	2164      	movs	r1, #100	; 0x64
 802ecf8:	fb01 f303 	mul.w	r3, r1, r3
 802ecfc:	1ad3      	subs	r3, r2, r3
 802ecfe:	011b      	lsls	r3, r3, #4
 802ed00:	3332      	adds	r3, #50	; 0x32
 802ed02:	4a72      	ldr	r2, [pc, #456]	; (802eecc <UART_SetConfig+0x6f4>)
 802ed04:	fba2 2303 	umull	r2, r3, r2, r3
 802ed08:	095b      	lsrs	r3, r3, #5
 802ed0a:	f003 020f 	and.w	r2, r3, #15
 802ed0e:	687b      	ldr	r3, [r7, #4]
 802ed10:	681b      	ldr	r3, [r3, #0]
 802ed12:	4442      	add	r2, r8
 802ed14:	609a      	str	r2, [r3, #8]
 802ed16:	e0d0      	b.n	802eeba <UART_SetConfig+0x6e2>
      pclk = HAL_RCC_GetPCLK1Freq();
 802ed18:	f7fd fcda 	bl	802c6d0 <HAL_RCC_GetPCLK1Freq>
 802ed1c:	60b8      	str	r0, [r7, #8]
      huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 802ed1e:	68bb      	ldr	r3, [r7, #8]
 802ed20:	469a      	mov	sl, r3
 802ed22:	f04f 0b00 	mov.w	fp, #0
 802ed26:	46d0      	mov	r8, sl
 802ed28:	46d9      	mov	r9, fp
 802ed2a:	eb18 0308 	adds.w	r3, r8, r8
 802ed2e:	eb49 0409 	adc.w	r4, r9, r9
 802ed32:	4698      	mov	r8, r3
 802ed34:	46a1      	mov	r9, r4
 802ed36:	eb18 080a 	adds.w	r8, r8, sl
 802ed3a:	eb49 090b 	adc.w	r9, r9, fp
 802ed3e:	f04f 0100 	mov.w	r1, #0
 802ed42:	f04f 0200 	mov.w	r2, #0
 802ed46:	ea4f 02c9 	mov.w	r2, r9, lsl #3
 802ed4a:	ea42 7258 	orr.w	r2, r2, r8, lsr #29
 802ed4e:	ea4f 01c8 	mov.w	r1, r8, lsl #3
 802ed52:	4688      	mov	r8, r1
 802ed54:	4691      	mov	r9, r2
 802ed56:	eb1a 0508 	adds.w	r5, sl, r8
 802ed5a:	eb4b 0609 	adc.w	r6, fp, r9
 802ed5e:	687b      	ldr	r3, [r7, #4]
 802ed60:	685b      	ldr	r3, [r3, #4]
 802ed62:	4619      	mov	r1, r3
 802ed64:	f04f 0200 	mov.w	r2, #0
 802ed68:	f04f 0300 	mov.w	r3, #0
 802ed6c:	f04f 0400 	mov.w	r4, #0
 802ed70:	0094      	lsls	r4, r2, #2
 802ed72:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802ed76:	008b      	lsls	r3, r1, #2
 802ed78:	461a      	mov	r2, r3
 802ed7a:	4623      	mov	r3, r4
 802ed7c:	4628      	mov	r0, r5
 802ed7e:	4631      	mov	r1, r6
 802ed80:	f7f9 fb92 	bl	80284a8 <__aeabi_uldivmod>
 802ed84:	4603      	mov	r3, r0
 802ed86:	460c      	mov	r4, r1
 802ed88:	461a      	mov	r2, r3
 802ed8a:	4b50      	ldr	r3, [pc, #320]	; (802eecc <UART_SetConfig+0x6f4>)
 802ed8c:	fba3 2302 	umull	r2, r3, r3, r2
 802ed90:	095b      	lsrs	r3, r3, #5
 802ed92:	ea4f 1803 	mov.w	r8, r3, lsl #4
 802ed96:	68bb      	ldr	r3, [r7, #8]
 802ed98:	469b      	mov	fp, r3
 802ed9a:	f04f 0c00 	mov.w	ip, #0
 802ed9e:	46d9      	mov	r9, fp
 802eda0:	46e2      	mov	sl, ip
 802eda2:	eb19 0309 	adds.w	r3, r9, r9
 802eda6:	eb4a 040a 	adc.w	r4, sl, sl
 802edaa:	4699      	mov	r9, r3
 802edac:	46a2      	mov	sl, r4
 802edae:	eb19 090b 	adds.w	r9, r9, fp
 802edb2:	eb4a 0a0c 	adc.w	sl, sl, ip
 802edb6:	f04f 0100 	mov.w	r1, #0
 802edba:	f04f 0200 	mov.w	r2, #0
 802edbe:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802edc2:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802edc6:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802edca:	4689      	mov	r9, r1
 802edcc:	4692      	mov	sl, r2
 802edce:	eb1b 0509 	adds.w	r5, fp, r9
 802edd2:	eb4c 060a 	adc.w	r6, ip, sl
 802edd6:	687b      	ldr	r3, [r7, #4]
 802edd8:	685b      	ldr	r3, [r3, #4]
 802edda:	4619      	mov	r1, r3
 802eddc:	f04f 0200 	mov.w	r2, #0
 802ede0:	f04f 0300 	mov.w	r3, #0
 802ede4:	f04f 0400 	mov.w	r4, #0
 802ede8:	0094      	lsls	r4, r2, #2
 802edea:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802edee:	008b      	lsls	r3, r1, #2
 802edf0:	461a      	mov	r2, r3
 802edf2:	4623      	mov	r3, r4
 802edf4:	4628      	mov	r0, r5
 802edf6:	4631      	mov	r1, r6
 802edf8:	f7f9 fb56 	bl	80284a8 <__aeabi_uldivmod>
 802edfc:	4603      	mov	r3, r0
 802edfe:	460c      	mov	r4, r1
 802ee00:	461a      	mov	r2, r3
 802ee02:	4b32      	ldr	r3, [pc, #200]	; (802eecc <UART_SetConfig+0x6f4>)
 802ee04:	fba3 1302 	umull	r1, r3, r3, r2
 802ee08:	095b      	lsrs	r3, r3, #5
 802ee0a:	2164      	movs	r1, #100	; 0x64
 802ee0c:	fb01 f303 	mul.w	r3, r1, r3
 802ee10:	1ad3      	subs	r3, r2, r3
 802ee12:	011b      	lsls	r3, r3, #4
 802ee14:	3332      	adds	r3, #50	; 0x32
 802ee16:	4a2d      	ldr	r2, [pc, #180]	; (802eecc <UART_SetConfig+0x6f4>)
 802ee18:	fba2 2303 	umull	r2, r3, r2, r3
 802ee1c:	095b      	lsrs	r3, r3, #5
 802ee1e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 802ee22:	4498      	add	r8, r3
 802ee24:	68bb      	ldr	r3, [r7, #8]
 802ee26:	469b      	mov	fp, r3
 802ee28:	f04f 0c00 	mov.w	ip, #0
 802ee2c:	46d9      	mov	r9, fp
 802ee2e:	46e2      	mov	sl, ip
 802ee30:	eb19 0309 	adds.w	r3, r9, r9
 802ee34:	eb4a 040a 	adc.w	r4, sl, sl
 802ee38:	4699      	mov	r9, r3
 802ee3a:	46a2      	mov	sl, r4
 802ee3c:	eb19 090b 	adds.w	r9, r9, fp
 802ee40:	eb4a 0a0c 	adc.w	sl, sl, ip
 802ee44:	f04f 0100 	mov.w	r1, #0
 802ee48:	f04f 0200 	mov.w	r2, #0
 802ee4c:	ea4f 02ca 	mov.w	r2, sl, lsl #3
 802ee50:	ea42 7259 	orr.w	r2, r2, r9, lsr #29
 802ee54:	ea4f 01c9 	mov.w	r1, r9, lsl #3
 802ee58:	4689      	mov	r9, r1
 802ee5a:	4692      	mov	sl, r2
 802ee5c:	eb1b 0509 	adds.w	r5, fp, r9
 802ee60:	eb4c 060a 	adc.w	r6, ip, sl
 802ee64:	687b      	ldr	r3, [r7, #4]
 802ee66:	685b      	ldr	r3, [r3, #4]
 802ee68:	4619      	mov	r1, r3
 802ee6a:	f04f 0200 	mov.w	r2, #0
 802ee6e:	f04f 0300 	mov.w	r3, #0
 802ee72:	f04f 0400 	mov.w	r4, #0
 802ee76:	0094      	lsls	r4, r2, #2
 802ee78:	ea44 7491 	orr.w	r4, r4, r1, lsr #30
 802ee7c:	008b      	lsls	r3, r1, #2
 802ee7e:	461a      	mov	r2, r3
 802ee80:	4623      	mov	r3, r4
 802ee82:	4628      	mov	r0, r5
 802ee84:	4631      	mov	r1, r6
 802ee86:	f7f9 fb0f 	bl	80284a8 <__aeabi_uldivmod>
 802ee8a:	4603      	mov	r3, r0
 802ee8c:	460c      	mov	r4, r1
 802ee8e:	461a      	mov	r2, r3
 802ee90:	4b0e      	ldr	r3, [pc, #56]	; (802eecc <UART_SetConfig+0x6f4>)
 802ee92:	fba3 1302 	umull	r1, r3, r3, r2
 802ee96:	095b      	lsrs	r3, r3, #5
 802ee98:	2164      	movs	r1, #100	; 0x64
 802ee9a:	fb01 f303 	mul.w	r3, r1, r3
 802ee9e:	1ad3      	subs	r3, r2, r3
 802eea0:	011b      	lsls	r3, r3, #4
 802eea2:	3332      	adds	r3, #50	; 0x32
 802eea4:	4a09      	ldr	r2, [pc, #36]	; (802eecc <UART_SetConfig+0x6f4>)
 802eea6:	fba2 2303 	umull	r2, r3, r2, r3
 802eeaa:	095b      	lsrs	r3, r3, #5
 802eeac:	f003 020f 	and.w	r2, r3, #15
 802eeb0:	687b      	ldr	r3, [r7, #4]
 802eeb2:	681b      	ldr	r3, [r3, #0]
 802eeb4:	4442      	add	r2, r8
 802eeb6:	609a      	str	r2, [r3, #8]
}
 802eeb8:	e7ff      	b.n	802eeba <UART_SetConfig+0x6e2>
 802eeba:	bf00      	nop
 802eebc:	3714      	adds	r7, #20
 802eebe:	46bd      	mov	sp, r7
 802eec0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802eec4:	40011000 	.word	0x40011000
 802eec8:	40011400 	.word	0x40011400
 802eecc:	51eb851f 	.word	0x51eb851f

0802eed0 <abort>:
 802eed0:	b508      	push	{r3, lr}
 802eed2:	2006      	movs	r0, #6
 802eed4:	f000 fdf2 	bl	802fabc <raise>
 802eed8:	2001      	movs	r0, #1
 802eeda:	f7fb ff65 	bl	802ada8 <_exit>
	...

0802eee0 <__errno>:
 802eee0:	4b01      	ldr	r3, [pc, #4]	; (802eee8 <__errno+0x8>)
 802eee2:	6818      	ldr	r0, [r3, #0]
 802eee4:	4770      	bx	lr
 802eee6:	bf00      	nop
 802eee8:	200000a4 	.word	0x200000a4

0802eeec <__sflush_r>:
 802eeec:	898a      	ldrh	r2, [r1, #12]
 802eeee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802eef2:	4605      	mov	r5, r0
 802eef4:	0710      	lsls	r0, r2, #28
 802eef6:	460c      	mov	r4, r1
 802eef8:	d458      	bmi.n	802efac <__sflush_r+0xc0>
 802eefa:	684b      	ldr	r3, [r1, #4]
 802eefc:	2b00      	cmp	r3, #0
 802eefe:	dc05      	bgt.n	802ef0c <__sflush_r+0x20>
 802ef00:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 802ef02:	2b00      	cmp	r3, #0
 802ef04:	dc02      	bgt.n	802ef0c <__sflush_r+0x20>
 802ef06:	2000      	movs	r0, #0
 802ef08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ef0c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802ef0e:	2e00      	cmp	r6, #0
 802ef10:	d0f9      	beq.n	802ef06 <__sflush_r+0x1a>
 802ef12:	2300      	movs	r3, #0
 802ef14:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 802ef18:	682f      	ldr	r7, [r5, #0]
 802ef1a:	6a21      	ldr	r1, [r4, #32]
 802ef1c:	602b      	str	r3, [r5, #0]
 802ef1e:	d032      	beq.n	802ef86 <__sflush_r+0x9a>
 802ef20:	6d60      	ldr	r0, [r4, #84]	; 0x54
 802ef22:	89a3      	ldrh	r3, [r4, #12]
 802ef24:	075a      	lsls	r2, r3, #29
 802ef26:	d505      	bpl.n	802ef34 <__sflush_r+0x48>
 802ef28:	6863      	ldr	r3, [r4, #4]
 802ef2a:	1ac0      	subs	r0, r0, r3
 802ef2c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802ef2e:	b10b      	cbz	r3, 802ef34 <__sflush_r+0x48>
 802ef30:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802ef32:	1ac0      	subs	r0, r0, r3
 802ef34:	2300      	movs	r3, #0
 802ef36:	4602      	mov	r2, r0
 802ef38:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802ef3a:	6a21      	ldr	r1, [r4, #32]
 802ef3c:	4628      	mov	r0, r5
 802ef3e:	47b0      	blx	r6
 802ef40:	1c43      	adds	r3, r0, #1
 802ef42:	89a3      	ldrh	r3, [r4, #12]
 802ef44:	d106      	bne.n	802ef54 <__sflush_r+0x68>
 802ef46:	6829      	ldr	r1, [r5, #0]
 802ef48:	291d      	cmp	r1, #29
 802ef4a:	d848      	bhi.n	802efde <__sflush_r+0xf2>
 802ef4c:	4a29      	ldr	r2, [pc, #164]	; (802eff4 <__sflush_r+0x108>)
 802ef4e:	40ca      	lsrs	r2, r1
 802ef50:	07d6      	lsls	r6, r2, #31
 802ef52:	d544      	bpl.n	802efde <__sflush_r+0xf2>
 802ef54:	2200      	movs	r2, #0
 802ef56:	6062      	str	r2, [r4, #4]
 802ef58:	04d9      	lsls	r1, r3, #19
 802ef5a:	6922      	ldr	r2, [r4, #16]
 802ef5c:	6022      	str	r2, [r4, #0]
 802ef5e:	d504      	bpl.n	802ef6a <__sflush_r+0x7e>
 802ef60:	1c42      	adds	r2, r0, #1
 802ef62:	d101      	bne.n	802ef68 <__sflush_r+0x7c>
 802ef64:	682b      	ldr	r3, [r5, #0]
 802ef66:	b903      	cbnz	r3, 802ef6a <__sflush_r+0x7e>
 802ef68:	6560      	str	r0, [r4, #84]	; 0x54
 802ef6a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802ef6c:	602f      	str	r7, [r5, #0]
 802ef6e:	2900      	cmp	r1, #0
 802ef70:	d0c9      	beq.n	802ef06 <__sflush_r+0x1a>
 802ef72:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802ef76:	4299      	cmp	r1, r3
 802ef78:	d002      	beq.n	802ef80 <__sflush_r+0x94>
 802ef7a:	4628      	mov	r0, r5
 802ef7c:	f000 f9ec 	bl	802f358 <_free_r>
 802ef80:	2000      	movs	r0, #0
 802ef82:	6360      	str	r0, [r4, #52]	; 0x34
 802ef84:	e7c0      	b.n	802ef08 <__sflush_r+0x1c>
 802ef86:	2301      	movs	r3, #1
 802ef88:	4628      	mov	r0, r5
 802ef8a:	47b0      	blx	r6
 802ef8c:	1c41      	adds	r1, r0, #1
 802ef8e:	d1c8      	bne.n	802ef22 <__sflush_r+0x36>
 802ef90:	682b      	ldr	r3, [r5, #0]
 802ef92:	2b00      	cmp	r3, #0
 802ef94:	d0c5      	beq.n	802ef22 <__sflush_r+0x36>
 802ef96:	2b1d      	cmp	r3, #29
 802ef98:	d001      	beq.n	802ef9e <__sflush_r+0xb2>
 802ef9a:	2b16      	cmp	r3, #22
 802ef9c:	d101      	bne.n	802efa2 <__sflush_r+0xb6>
 802ef9e:	602f      	str	r7, [r5, #0]
 802efa0:	e7b1      	b.n	802ef06 <__sflush_r+0x1a>
 802efa2:	89a3      	ldrh	r3, [r4, #12]
 802efa4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802efa8:	81a3      	strh	r3, [r4, #12]
 802efaa:	e7ad      	b.n	802ef08 <__sflush_r+0x1c>
 802efac:	690f      	ldr	r7, [r1, #16]
 802efae:	2f00      	cmp	r7, #0
 802efb0:	d0a9      	beq.n	802ef06 <__sflush_r+0x1a>
 802efb2:	0793      	lsls	r3, r2, #30
 802efb4:	680e      	ldr	r6, [r1, #0]
 802efb6:	bf08      	it	eq
 802efb8:	694b      	ldreq	r3, [r1, #20]
 802efba:	600f      	str	r7, [r1, #0]
 802efbc:	bf18      	it	ne
 802efbe:	2300      	movne	r3, #0
 802efc0:	eba6 0807 	sub.w	r8, r6, r7
 802efc4:	608b      	str	r3, [r1, #8]
 802efc6:	f1b8 0f00 	cmp.w	r8, #0
 802efca:	dd9c      	ble.n	802ef06 <__sflush_r+0x1a>
 802efcc:	4643      	mov	r3, r8
 802efce:	463a      	mov	r2, r7
 802efd0:	6a21      	ldr	r1, [r4, #32]
 802efd2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 802efd4:	4628      	mov	r0, r5
 802efd6:	47b0      	blx	r6
 802efd8:	2800      	cmp	r0, #0
 802efda:	dc06      	bgt.n	802efea <__sflush_r+0xfe>
 802efdc:	89a3      	ldrh	r3, [r4, #12]
 802efde:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802efe2:	81a3      	strh	r3, [r4, #12]
 802efe4:	f04f 30ff 	mov.w	r0, #4294967295
 802efe8:	e78e      	b.n	802ef08 <__sflush_r+0x1c>
 802efea:	4407      	add	r7, r0
 802efec:	eba8 0800 	sub.w	r8, r8, r0
 802eff0:	e7e9      	b.n	802efc6 <__sflush_r+0xda>
 802eff2:	bf00      	nop
 802eff4:	20400001 	.word	0x20400001

0802eff8 <_fflush_r>:
 802eff8:	b538      	push	{r3, r4, r5, lr}
 802effa:	690b      	ldr	r3, [r1, #16]
 802effc:	4605      	mov	r5, r0
 802effe:	460c      	mov	r4, r1
 802f000:	b1db      	cbz	r3, 802f03a <_fflush_r+0x42>
 802f002:	b118      	cbz	r0, 802f00c <_fflush_r+0x14>
 802f004:	6983      	ldr	r3, [r0, #24]
 802f006:	b90b      	cbnz	r3, 802f00c <_fflush_r+0x14>
 802f008:	f000 f872 	bl	802f0f0 <__sinit>
 802f00c:	4b0c      	ldr	r3, [pc, #48]	; (802f040 <_fflush_r+0x48>)
 802f00e:	429c      	cmp	r4, r3
 802f010:	d109      	bne.n	802f026 <_fflush_r+0x2e>
 802f012:	686c      	ldr	r4, [r5, #4]
 802f014:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802f018:	b17b      	cbz	r3, 802f03a <_fflush_r+0x42>
 802f01a:	4621      	mov	r1, r4
 802f01c:	4628      	mov	r0, r5
 802f01e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802f022:	f7ff bf63 	b.w	802eeec <__sflush_r>
 802f026:	4b07      	ldr	r3, [pc, #28]	; (802f044 <_fflush_r+0x4c>)
 802f028:	429c      	cmp	r4, r3
 802f02a:	d101      	bne.n	802f030 <_fflush_r+0x38>
 802f02c:	68ac      	ldr	r4, [r5, #8]
 802f02e:	e7f1      	b.n	802f014 <_fflush_r+0x1c>
 802f030:	4b05      	ldr	r3, [pc, #20]	; (802f048 <_fflush_r+0x50>)
 802f032:	429c      	cmp	r4, r3
 802f034:	bf08      	it	eq
 802f036:	68ec      	ldreq	r4, [r5, #12]
 802f038:	e7ec      	b.n	802f014 <_fflush_r+0x1c>
 802f03a:	2000      	movs	r0, #0
 802f03c:	bd38      	pop	{r3, r4, r5, pc}
 802f03e:	bf00      	nop
 802f040:	08030810 	.word	0x08030810
 802f044:	08030830 	.word	0x08030830
 802f048:	080307f0 	.word	0x080307f0

0802f04c <fflush>:
 802f04c:	4601      	mov	r1, r0
 802f04e:	b920      	cbnz	r0, 802f05a <fflush+0xe>
 802f050:	4b04      	ldr	r3, [pc, #16]	; (802f064 <fflush+0x18>)
 802f052:	4905      	ldr	r1, [pc, #20]	; (802f068 <fflush+0x1c>)
 802f054:	6818      	ldr	r0, [r3, #0]
 802f056:	f000 b8c9 	b.w	802f1ec <_fwalk_reent>
 802f05a:	4b04      	ldr	r3, [pc, #16]	; (802f06c <fflush+0x20>)
 802f05c:	6818      	ldr	r0, [r3, #0]
 802f05e:	f7ff bfcb 	b.w	802eff8 <_fflush_r>
 802f062:	bf00      	nop
 802f064:	08030850 	.word	0x08030850
 802f068:	0802eff9 	.word	0x0802eff9
 802f06c:	200000a4 	.word	0x200000a4

0802f070 <std>:
 802f070:	2300      	movs	r3, #0
 802f072:	b510      	push	{r4, lr}
 802f074:	4604      	mov	r4, r0
 802f076:	e9c0 3300 	strd	r3, r3, [r0]
 802f07a:	6083      	str	r3, [r0, #8]
 802f07c:	8181      	strh	r1, [r0, #12]
 802f07e:	6643      	str	r3, [r0, #100]	; 0x64
 802f080:	81c2      	strh	r2, [r0, #14]
 802f082:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802f086:	6183      	str	r3, [r0, #24]
 802f088:	4619      	mov	r1, r3
 802f08a:	2208      	movs	r2, #8
 802f08c:	305c      	adds	r0, #92	; 0x5c
 802f08e:	f000 f95b 	bl	802f348 <memset>
 802f092:	4b05      	ldr	r3, [pc, #20]	; (802f0a8 <std+0x38>)
 802f094:	6263      	str	r3, [r4, #36]	; 0x24
 802f096:	4b05      	ldr	r3, [pc, #20]	; (802f0ac <std+0x3c>)
 802f098:	62a3      	str	r3, [r4, #40]	; 0x28
 802f09a:	4b05      	ldr	r3, [pc, #20]	; (802f0b0 <std+0x40>)
 802f09c:	62e3      	str	r3, [r4, #44]	; 0x2c
 802f09e:	4b05      	ldr	r3, [pc, #20]	; (802f0b4 <std+0x44>)
 802f0a0:	6224      	str	r4, [r4, #32]
 802f0a2:	6323      	str	r3, [r4, #48]	; 0x30
 802f0a4:	bd10      	pop	{r4, pc}
 802f0a6:	bf00      	nop
 802f0a8:	0802faf5 	.word	0x0802faf5
 802f0ac:	0802fb17 	.word	0x0802fb17
 802f0b0:	0802fb4f 	.word	0x0802fb4f
 802f0b4:	0802fb73 	.word	0x0802fb73

0802f0b8 <_cleanup_r>:
 802f0b8:	4901      	ldr	r1, [pc, #4]	; (802f0c0 <_cleanup_r+0x8>)
 802f0ba:	f000 b897 	b.w	802f1ec <_fwalk_reent>
 802f0be:	bf00      	nop
 802f0c0:	0802eff9 	.word	0x0802eff9

0802f0c4 <__sfmoreglue>:
 802f0c4:	b570      	push	{r4, r5, r6, lr}
 802f0c6:	1e4a      	subs	r2, r1, #1
 802f0c8:	2568      	movs	r5, #104	; 0x68
 802f0ca:	4355      	muls	r5, r2
 802f0cc:	460e      	mov	r6, r1
 802f0ce:	f105 0174 	add.w	r1, r5, #116	; 0x74
 802f0d2:	f000 f98f 	bl	802f3f4 <_malloc_r>
 802f0d6:	4604      	mov	r4, r0
 802f0d8:	b140      	cbz	r0, 802f0ec <__sfmoreglue+0x28>
 802f0da:	2100      	movs	r1, #0
 802f0dc:	e9c0 1600 	strd	r1, r6, [r0]
 802f0e0:	300c      	adds	r0, #12
 802f0e2:	60a0      	str	r0, [r4, #8]
 802f0e4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 802f0e8:	f000 f92e 	bl	802f348 <memset>
 802f0ec:	4620      	mov	r0, r4
 802f0ee:	bd70      	pop	{r4, r5, r6, pc}

0802f0f0 <__sinit>:
 802f0f0:	6983      	ldr	r3, [r0, #24]
 802f0f2:	b510      	push	{r4, lr}
 802f0f4:	4604      	mov	r4, r0
 802f0f6:	bb33      	cbnz	r3, 802f146 <__sinit+0x56>
 802f0f8:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 802f0fc:	6503      	str	r3, [r0, #80]	; 0x50
 802f0fe:	4b12      	ldr	r3, [pc, #72]	; (802f148 <__sinit+0x58>)
 802f100:	4a12      	ldr	r2, [pc, #72]	; (802f14c <__sinit+0x5c>)
 802f102:	681b      	ldr	r3, [r3, #0]
 802f104:	6282      	str	r2, [r0, #40]	; 0x28
 802f106:	4298      	cmp	r0, r3
 802f108:	bf04      	itt	eq
 802f10a:	2301      	moveq	r3, #1
 802f10c:	6183      	streq	r3, [r0, #24]
 802f10e:	f000 f81f 	bl	802f150 <__sfp>
 802f112:	6060      	str	r0, [r4, #4]
 802f114:	4620      	mov	r0, r4
 802f116:	f000 f81b 	bl	802f150 <__sfp>
 802f11a:	60a0      	str	r0, [r4, #8]
 802f11c:	4620      	mov	r0, r4
 802f11e:	f000 f817 	bl	802f150 <__sfp>
 802f122:	2200      	movs	r2, #0
 802f124:	60e0      	str	r0, [r4, #12]
 802f126:	2104      	movs	r1, #4
 802f128:	6860      	ldr	r0, [r4, #4]
 802f12a:	f7ff ffa1 	bl	802f070 <std>
 802f12e:	2201      	movs	r2, #1
 802f130:	2109      	movs	r1, #9
 802f132:	68a0      	ldr	r0, [r4, #8]
 802f134:	f7ff ff9c 	bl	802f070 <std>
 802f138:	2202      	movs	r2, #2
 802f13a:	2112      	movs	r1, #18
 802f13c:	68e0      	ldr	r0, [r4, #12]
 802f13e:	f7ff ff97 	bl	802f070 <std>
 802f142:	2301      	movs	r3, #1
 802f144:	61a3      	str	r3, [r4, #24]
 802f146:	bd10      	pop	{r4, pc}
 802f148:	08030850 	.word	0x08030850
 802f14c:	0802f0b9 	.word	0x0802f0b9

0802f150 <__sfp>:
 802f150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802f152:	4b1b      	ldr	r3, [pc, #108]	; (802f1c0 <__sfp+0x70>)
 802f154:	681e      	ldr	r6, [r3, #0]
 802f156:	69b3      	ldr	r3, [r6, #24]
 802f158:	4607      	mov	r7, r0
 802f15a:	b913      	cbnz	r3, 802f162 <__sfp+0x12>
 802f15c:	4630      	mov	r0, r6
 802f15e:	f7ff ffc7 	bl	802f0f0 <__sinit>
 802f162:	3648      	adds	r6, #72	; 0x48
 802f164:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 802f168:	3b01      	subs	r3, #1
 802f16a:	d503      	bpl.n	802f174 <__sfp+0x24>
 802f16c:	6833      	ldr	r3, [r6, #0]
 802f16e:	b133      	cbz	r3, 802f17e <__sfp+0x2e>
 802f170:	6836      	ldr	r6, [r6, #0]
 802f172:	e7f7      	b.n	802f164 <__sfp+0x14>
 802f174:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 802f178:	b16d      	cbz	r5, 802f196 <__sfp+0x46>
 802f17a:	3468      	adds	r4, #104	; 0x68
 802f17c:	e7f4      	b.n	802f168 <__sfp+0x18>
 802f17e:	2104      	movs	r1, #4
 802f180:	4638      	mov	r0, r7
 802f182:	f7ff ff9f 	bl	802f0c4 <__sfmoreglue>
 802f186:	6030      	str	r0, [r6, #0]
 802f188:	2800      	cmp	r0, #0
 802f18a:	d1f1      	bne.n	802f170 <__sfp+0x20>
 802f18c:	230c      	movs	r3, #12
 802f18e:	603b      	str	r3, [r7, #0]
 802f190:	4604      	mov	r4, r0
 802f192:	4620      	mov	r0, r4
 802f194:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802f196:	4b0b      	ldr	r3, [pc, #44]	; (802f1c4 <__sfp+0x74>)
 802f198:	6665      	str	r5, [r4, #100]	; 0x64
 802f19a:	e9c4 5500 	strd	r5, r5, [r4]
 802f19e:	60a5      	str	r5, [r4, #8]
 802f1a0:	e9c4 3503 	strd	r3, r5, [r4, #12]
 802f1a4:	e9c4 5505 	strd	r5, r5, [r4, #20]
 802f1a8:	2208      	movs	r2, #8
 802f1aa:	4629      	mov	r1, r5
 802f1ac:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 802f1b0:	f000 f8ca 	bl	802f348 <memset>
 802f1b4:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 802f1b8:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 802f1bc:	e7e9      	b.n	802f192 <__sfp+0x42>
 802f1be:	bf00      	nop
 802f1c0:	08030850 	.word	0x08030850
 802f1c4:	ffff0001 	.word	0xffff0001

0802f1c8 <fiprintf>:
 802f1c8:	b40e      	push	{r1, r2, r3}
 802f1ca:	b503      	push	{r0, r1, lr}
 802f1cc:	4601      	mov	r1, r0
 802f1ce:	ab03      	add	r3, sp, #12
 802f1d0:	4805      	ldr	r0, [pc, #20]	; (802f1e8 <fiprintf+0x20>)
 802f1d2:	f853 2b04 	ldr.w	r2, [r3], #4
 802f1d6:	6800      	ldr	r0, [r0, #0]
 802f1d8:	9301      	str	r3, [sp, #4]
 802f1da:	f000 f98f 	bl	802f4fc <_vfiprintf_r>
 802f1de:	b002      	add	sp, #8
 802f1e0:	f85d eb04 	ldr.w	lr, [sp], #4
 802f1e4:	b003      	add	sp, #12
 802f1e6:	4770      	bx	lr
 802f1e8:	200000a4 	.word	0x200000a4

0802f1ec <_fwalk_reent>:
 802f1ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802f1f0:	4680      	mov	r8, r0
 802f1f2:	4689      	mov	r9, r1
 802f1f4:	f100 0448 	add.w	r4, r0, #72	; 0x48
 802f1f8:	2600      	movs	r6, #0
 802f1fa:	b914      	cbnz	r4, 802f202 <_fwalk_reent+0x16>
 802f1fc:	4630      	mov	r0, r6
 802f1fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802f202:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 802f206:	3f01      	subs	r7, #1
 802f208:	d501      	bpl.n	802f20e <_fwalk_reent+0x22>
 802f20a:	6824      	ldr	r4, [r4, #0]
 802f20c:	e7f5      	b.n	802f1fa <_fwalk_reent+0xe>
 802f20e:	89ab      	ldrh	r3, [r5, #12]
 802f210:	2b01      	cmp	r3, #1
 802f212:	d907      	bls.n	802f224 <_fwalk_reent+0x38>
 802f214:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 802f218:	3301      	adds	r3, #1
 802f21a:	d003      	beq.n	802f224 <_fwalk_reent+0x38>
 802f21c:	4629      	mov	r1, r5
 802f21e:	4640      	mov	r0, r8
 802f220:	47c8      	blx	r9
 802f222:	4306      	orrs	r6, r0
 802f224:	3568      	adds	r5, #104	; 0x68
 802f226:	e7ee      	b.n	802f206 <_fwalk_reent+0x1a>

0802f228 <_fwrite_r>:
 802f228:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802f22c:	9c08      	ldr	r4, [sp, #32]
 802f22e:	4689      	mov	r9, r1
 802f230:	4617      	mov	r7, r2
 802f232:	fb02 f803 	mul.w	r8, r2, r3
 802f236:	4606      	mov	r6, r0
 802f238:	b118      	cbz	r0, 802f242 <_fwrite_r+0x1a>
 802f23a:	6983      	ldr	r3, [r0, #24]
 802f23c:	b90b      	cbnz	r3, 802f242 <_fwrite_r+0x1a>
 802f23e:	f7ff ff57 	bl	802f0f0 <__sinit>
 802f242:	4b1d      	ldr	r3, [pc, #116]	; (802f2b8 <_fwrite_r+0x90>)
 802f244:	429c      	cmp	r4, r3
 802f246:	d11a      	bne.n	802f27e <_fwrite_r+0x56>
 802f248:	6874      	ldr	r4, [r6, #4]
 802f24a:	89a3      	ldrh	r3, [r4, #12]
 802f24c:	071b      	lsls	r3, r3, #28
 802f24e:	d520      	bpl.n	802f292 <_fwrite_r+0x6a>
 802f250:	6923      	ldr	r3, [r4, #16]
 802f252:	b1f3      	cbz	r3, 802f292 <_fwrite_r+0x6a>
 802f254:	2500      	movs	r5, #0
 802f256:	4545      	cmp	r5, r8
 802f258:	d029      	beq.n	802f2ae <_fwrite_r+0x86>
 802f25a:	68a3      	ldr	r3, [r4, #8]
 802f25c:	f819 1005 	ldrb.w	r1, [r9, r5]
 802f260:	3b01      	subs	r3, #1
 802f262:	2b00      	cmp	r3, #0
 802f264:	60a3      	str	r3, [r4, #8]
 802f266:	da04      	bge.n	802f272 <_fwrite_r+0x4a>
 802f268:	69a2      	ldr	r2, [r4, #24]
 802f26a:	4293      	cmp	r3, r2
 802f26c:	db19      	blt.n	802f2a2 <_fwrite_r+0x7a>
 802f26e:	290a      	cmp	r1, #10
 802f270:	d017      	beq.n	802f2a2 <_fwrite_r+0x7a>
 802f272:	6823      	ldr	r3, [r4, #0]
 802f274:	1c5a      	adds	r2, r3, #1
 802f276:	6022      	str	r2, [r4, #0]
 802f278:	7019      	strb	r1, [r3, #0]
 802f27a:	3501      	adds	r5, #1
 802f27c:	e7eb      	b.n	802f256 <_fwrite_r+0x2e>
 802f27e:	4b0f      	ldr	r3, [pc, #60]	; (802f2bc <_fwrite_r+0x94>)
 802f280:	429c      	cmp	r4, r3
 802f282:	d101      	bne.n	802f288 <_fwrite_r+0x60>
 802f284:	68b4      	ldr	r4, [r6, #8]
 802f286:	e7e0      	b.n	802f24a <_fwrite_r+0x22>
 802f288:	4b0d      	ldr	r3, [pc, #52]	; (802f2c0 <_fwrite_r+0x98>)
 802f28a:	429c      	cmp	r4, r3
 802f28c:	bf08      	it	eq
 802f28e:	68f4      	ldreq	r4, [r6, #12]
 802f290:	e7db      	b.n	802f24a <_fwrite_r+0x22>
 802f292:	4621      	mov	r1, r4
 802f294:	4630      	mov	r0, r6
 802f296:	f000 fcd5 	bl	802fc44 <__swsetup_r>
 802f29a:	2800      	cmp	r0, #0
 802f29c:	d0da      	beq.n	802f254 <_fwrite_r+0x2c>
 802f29e:	2500      	movs	r5, #0
 802f2a0:	e005      	b.n	802f2ae <_fwrite_r+0x86>
 802f2a2:	4622      	mov	r2, r4
 802f2a4:	4630      	mov	r0, r6
 802f2a6:	f000 fc69 	bl	802fb7c <__swbuf_r>
 802f2aa:	3001      	adds	r0, #1
 802f2ac:	d1e5      	bne.n	802f27a <_fwrite_r+0x52>
 802f2ae:	fbb5 f0f7 	udiv	r0, r5, r7
 802f2b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802f2b6:	bf00      	nop
 802f2b8:	08030810 	.word	0x08030810
 802f2bc:	08030830 	.word	0x08030830
 802f2c0:	080307f0 	.word	0x080307f0

0802f2c4 <fwrite>:
 802f2c4:	b507      	push	{r0, r1, r2, lr}
 802f2c6:	9300      	str	r3, [sp, #0]
 802f2c8:	4613      	mov	r3, r2
 802f2ca:	460a      	mov	r2, r1
 802f2cc:	4601      	mov	r1, r0
 802f2ce:	4803      	ldr	r0, [pc, #12]	; (802f2dc <fwrite+0x18>)
 802f2d0:	6800      	ldr	r0, [r0, #0]
 802f2d2:	f7ff ffa9 	bl	802f228 <_fwrite_r>
 802f2d6:	b003      	add	sp, #12
 802f2d8:	f85d fb04 	ldr.w	pc, [sp], #4
 802f2dc:	200000a4 	.word	0x200000a4

0802f2e0 <__libc_init_array>:
 802f2e0:	b570      	push	{r4, r5, r6, lr}
 802f2e2:	4e0d      	ldr	r6, [pc, #52]	; (802f318 <__libc_init_array+0x38>)
 802f2e4:	4c0d      	ldr	r4, [pc, #52]	; (802f31c <__libc_init_array+0x3c>)
 802f2e6:	1ba4      	subs	r4, r4, r6
 802f2e8:	10a4      	asrs	r4, r4, #2
 802f2ea:	2500      	movs	r5, #0
 802f2ec:	42a5      	cmp	r5, r4
 802f2ee:	d109      	bne.n	802f304 <__libc_init_array+0x24>
 802f2f0:	4e0b      	ldr	r6, [pc, #44]	; (802f320 <__libc_init_array+0x40>)
 802f2f2:	4c0c      	ldr	r4, [pc, #48]	; (802f324 <__libc_init_array+0x44>)
 802f2f4:	f000 fedc 	bl	80300b0 <_init>
 802f2f8:	1ba4      	subs	r4, r4, r6
 802f2fa:	10a4      	asrs	r4, r4, #2
 802f2fc:	2500      	movs	r5, #0
 802f2fe:	42a5      	cmp	r5, r4
 802f300:	d105      	bne.n	802f30e <__libc_init_array+0x2e>
 802f302:	bd70      	pop	{r4, r5, r6, pc}
 802f304:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802f308:	4798      	blx	r3
 802f30a:	3501      	adds	r5, #1
 802f30c:	e7ee      	b.n	802f2ec <__libc_init_array+0xc>
 802f30e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802f312:	4798      	blx	r3
 802f314:	3501      	adds	r5, #1
 802f316:	e7f2      	b.n	802f2fe <__libc_init_array+0x1e>
 802f318:	08030894 	.word	0x08030894
 802f31c:	08030894 	.word	0x08030894
 802f320:	08030894 	.word	0x08030894
 802f324:	08030898 	.word	0x08030898

0802f328 <malloc>:
 802f328:	4b02      	ldr	r3, [pc, #8]	; (802f334 <malloc+0xc>)
 802f32a:	4601      	mov	r1, r0
 802f32c:	6818      	ldr	r0, [r3, #0]
 802f32e:	f000 b861 	b.w	802f3f4 <_malloc_r>
 802f332:	bf00      	nop
 802f334:	200000a4 	.word	0x200000a4

0802f338 <free>:
 802f338:	4b02      	ldr	r3, [pc, #8]	; (802f344 <free+0xc>)
 802f33a:	4601      	mov	r1, r0
 802f33c:	6818      	ldr	r0, [r3, #0]
 802f33e:	f000 b80b 	b.w	802f358 <_free_r>
 802f342:	bf00      	nop
 802f344:	200000a4 	.word	0x200000a4

0802f348 <memset>:
 802f348:	4402      	add	r2, r0
 802f34a:	4603      	mov	r3, r0
 802f34c:	4293      	cmp	r3, r2
 802f34e:	d100      	bne.n	802f352 <memset+0xa>
 802f350:	4770      	bx	lr
 802f352:	f803 1b01 	strb.w	r1, [r3], #1
 802f356:	e7f9      	b.n	802f34c <memset+0x4>

0802f358 <_free_r>:
 802f358:	b538      	push	{r3, r4, r5, lr}
 802f35a:	4605      	mov	r5, r0
 802f35c:	2900      	cmp	r1, #0
 802f35e:	d045      	beq.n	802f3ec <_free_r+0x94>
 802f360:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802f364:	1f0c      	subs	r4, r1, #4
 802f366:	2b00      	cmp	r3, #0
 802f368:	bfb8      	it	lt
 802f36a:	18e4      	addlt	r4, r4, r3
 802f36c:	f000 fd5e 	bl	802fe2c <__malloc_lock>
 802f370:	4a1f      	ldr	r2, [pc, #124]	; (802f3f0 <_free_r+0x98>)
 802f372:	6813      	ldr	r3, [r2, #0]
 802f374:	4610      	mov	r0, r2
 802f376:	b933      	cbnz	r3, 802f386 <_free_r+0x2e>
 802f378:	6063      	str	r3, [r4, #4]
 802f37a:	6014      	str	r4, [r2, #0]
 802f37c:	4628      	mov	r0, r5
 802f37e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802f382:	f000 bd54 	b.w	802fe2e <__malloc_unlock>
 802f386:	42a3      	cmp	r3, r4
 802f388:	d90c      	bls.n	802f3a4 <_free_r+0x4c>
 802f38a:	6821      	ldr	r1, [r4, #0]
 802f38c:	1862      	adds	r2, r4, r1
 802f38e:	4293      	cmp	r3, r2
 802f390:	bf04      	itt	eq
 802f392:	681a      	ldreq	r2, [r3, #0]
 802f394:	685b      	ldreq	r3, [r3, #4]
 802f396:	6063      	str	r3, [r4, #4]
 802f398:	bf04      	itt	eq
 802f39a:	1852      	addeq	r2, r2, r1
 802f39c:	6022      	streq	r2, [r4, #0]
 802f39e:	6004      	str	r4, [r0, #0]
 802f3a0:	e7ec      	b.n	802f37c <_free_r+0x24>
 802f3a2:	4613      	mov	r3, r2
 802f3a4:	685a      	ldr	r2, [r3, #4]
 802f3a6:	b10a      	cbz	r2, 802f3ac <_free_r+0x54>
 802f3a8:	42a2      	cmp	r2, r4
 802f3aa:	d9fa      	bls.n	802f3a2 <_free_r+0x4a>
 802f3ac:	6819      	ldr	r1, [r3, #0]
 802f3ae:	1858      	adds	r0, r3, r1
 802f3b0:	42a0      	cmp	r0, r4
 802f3b2:	d10b      	bne.n	802f3cc <_free_r+0x74>
 802f3b4:	6820      	ldr	r0, [r4, #0]
 802f3b6:	4401      	add	r1, r0
 802f3b8:	1858      	adds	r0, r3, r1
 802f3ba:	4282      	cmp	r2, r0
 802f3bc:	6019      	str	r1, [r3, #0]
 802f3be:	d1dd      	bne.n	802f37c <_free_r+0x24>
 802f3c0:	6810      	ldr	r0, [r2, #0]
 802f3c2:	6852      	ldr	r2, [r2, #4]
 802f3c4:	605a      	str	r2, [r3, #4]
 802f3c6:	4401      	add	r1, r0
 802f3c8:	6019      	str	r1, [r3, #0]
 802f3ca:	e7d7      	b.n	802f37c <_free_r+0x24>
 802f3cc:	d902      	bls.n	802f3d4 <_free_r+0x7c>
 802f3ce:	230c      	movs	r3, #12
 802f3d0:	602b      	str	r3, [r5, #0]
 802f3d2:	e7d3      	b.n	802f37c <_free_r+0x24>
 802f3d4:	6820      	ldr	r0, [r4, #0]
 802f3d6:	1821      	adds	r1, r4, r0
 802f3d8:	428a      	cmp	r2, r1
 802f3da:	bf04      	itt	eq
 802f3dc:	6811      	ldreq	r1, [r2, #0]
 802f3de:	6852      	ldreq	r2, [r2, #4]
 802f3e0:	6062      	str	r2, [r4, #4]
 802f3e2:	bf04      	itt	eq
 802f3e4:	1809      	addeq	r1, r1, r0
 802f3e6:	6021      	streq	r1, [r4, #0]
 802f3e8:	605c      	str	r4, [r3, #4]
 802f3ea:	e7c7      	b.n	802f37c <_free_r+0x24>
 802f3ec:	bd38      	pop	{r3, r4, r5, pc}
 802f3ee:	bf00      	nop
 802f3f0:	200014dc 	.word	0x200014dc

0802f3f4 <_malloc_r>:
 802f3f4:	b570      	push	{r4, r5, r6, lr}
 802f3f6:	1ccd      	adds	r5, r1, #3
 802f3f8:	f025 0503 	bic.w	r5, r5, #3
 802f3fc:	3508      	adds	r5, #8
 802f3fe:	2d0c      	cmp	r5, #12
 802f400:	bf38      	it	cc
 802f402:	250c      	movcc	r5, #12
 802f404:	2d00      	cmp	r5, #0
 802f406:	4606      	mov	r6, r0
 802f408:	db01      	blt.n	802f40e <_malloc_r+0x1a>
 802f40a:	42a9      	cmp	r1, r5
 802f40c:	d903      	bls.n	802f416 <_malloc_r+0x22>
 802f40e:	230c      	movs	r3, #12
 802f410:	6033      	str	r3, [r6, #0]
 802f412:	2000      	movs	r0, #0
 802f414:	bd70      	pop	{r4, r5, r6, pc}
 802f416:	f000 fd09 	bl	802fe2c <__malloc_lock>
 802f41a:	4a21      	ldr	r2, [pc, #132]	; (802f4a0 <_malloc_r+0xac>)
 802f41c:	6814      	ldr	r4, [r2, #0]
 802f41e:	4621      	mov	r1, r4
 802f420:	b991      	cbnz	r1, 802f448 <_malloc_r+0x54>
 802f422:	4c20      	ldr	r4, [pc, #128]	; (802f4a4 <_malloc_r+0xb0>)
 802f424:	6823      	ldr	r3, [r4, #0]
 802f426:	b91b      	cbnz	r3, 802f430 <_malloc_r+0x3c>
 802f428:	4630      	mov	r0, r6
 802f42a:	f000 fb0f 	bl	802fa4c <_sbrk_r>
 802f42e:	6020      	str	r0, [r4, #0]
 802f430:	4629      	mov	r1, r5
 802f432:	4630      	mov	r0, r6
 802f434:	f000 fb0a 	bl	802fa4c <_sbrk_r>
 802f438:	1c43      	adds	r3, r0, #1
 802f43a:	d124      	bne.n	802f486 <_malloc_r+0x92>
 802f43c:	230c      	movs	r3, #12
 802f43e:	6033      	str	r3, [r6, #0]
 802f440:	4630      	mov	r0, r6
 802f442:	f000 fcf4 	bl	802fe2e <__malloc_unlock>
 802f446:	e7e4      	b.n	802f412 <_malloc_r+0x1e>
 802f448:	680b      	ldr	r3, [r1, #0]
 802f44a:	1b5b      	subs	r3, r3, r5
 802f44c:	d418      	bmi.n	802f480 <_malloc_r+0x8c>
 802f44e:	2b0b      	cmp	r3, #11
 802f450:	d90f      	bls.n	802f472 <_malloc_r+0x7e>
 802f452:	600b      	str	r3, [r1, #0]
 802f454:	50cd      	str	r5, [r1, r3]
 802f456:	18cc      	adds	r4, r1, r3
 802f458:	4630      	mov	r0, r6
 802f45a:	f000 fce8 	bl	802fe2e <__malloc_unlock>
 802f45e:	f104 000b 	add.w	r0, r4, #11
 802f462:	1d23      	adds	r3, r4, #4
 802f464:	f020 0007 	bic.w	r0, r0, #7
 802f468:	1ac3      	subs	r3, r0, r3
 802f46a:	d0d3      	beq.n	802f414 <_malloc_r+0x20>
 802f46c:	425a      	negs	r2, r3
 802f46e:	50e2      	str	r2, [r4, r3]
 802f470:	e7d0      	b.n	802f414 <_malloc_r+0x20>
 802f472:	428c      	cmp	r4, r1
 802f474:	684b      	ldr	r3, [r1, #4]
 802f476:	bf16      	itet	ne
 802f478:	6063      	strne	r3, [r4, #4]
 802f47a:	6013      	streq	r3, [r2, #0]
 802f47c:	460c      	movne	r4, r1
 802f47e:	e7eb      	b.n	802f458 <_malloc_r+0x64>
 802f480:	460c      	mov	r4, r1
 802f482:	6849      	ldr	r1, [r1, #4]
 802f484:	e7cc      	b.n	802f420 <_malloc_r+0x2c>
 802f486:	1cc4      	adds	r4, r0, #3
 802f488:	f024 0403 	bic.w	r4, r4, #3
 802f48c:	42a0      	cmp	r0, r4
 802f48e:	d005      	beq.n	802f49c <_malloc_r+0xa8>
 802f490:	1a21      	subs	r1, r4, r0
 802f492:	4630      	mov	r0, r6
 802f494:	f000 fada 	bl	802fa4c <_sbrk_r>
 802f498:	3001      	adds	r0, #1
 802f49a:	d0cf      	beq.n	802f43c <_malloc_r+0x48>
 802f49c:	6025      	str	r5, [r4, #0]
 802f49e:	e7db      	b.n	802f458 <_malloc_r+0x64>
 802f4a0:	200014dc 	.word	0x200014dc
 802f4a4:	200014e0 	.word	0x200014e0

0802f4a8 <__sfputc_r>:
 802f4a8:	6893      	ldr	r3, [r2, #8]
 802f4aa:	3b01      	subs	r3, #1
 802f4ac:	2b00      	cmp	r3, #0
 802f4ae:	b410      	push	{r4}
 802f4b0:	6093      	str	r3, [r2, #8]
 802f4b2:	da08      	bge.n	802f4c6 <__sfputc_r+0x1e>
 802f4b4:	6994      	ldr	r4, [r2, #24]
 802f4b6:	42a3      	cmp	r3, r4
 802f4b8:	db01      	blt.n	802f4be <__sfputc_r+0x16>
 802f4ba:	290a      	cmp	r1, #10
 802f4bc:	d103      	bne.n	802f4c6 <__sfputc_r+0x1e>
 802f4be:	f85d 4b04 	ldr.w	r4, [sp], #4
 802f4c2:	f000 bb5b 	b.w	802fb7c <__swbuf_r>
 802f4c6:	6813      	ldr	r3, [r2, #0]
 802f4c8:	1c58      	adds	r0, r3, #1
 802f4ca:	6010      	str	r0, [r2, #0]
 802f4cc:	7019      	strb	r1, [r3, #0]
 802f4ce:	4608      	mov	r0, r1
 802f4d0:	f85d 4b04 	ldr.w	r4, [sp], #4
 802f4d4:	4770      	bx	lr

0802f4d6 <__sfputs_r>:
 802f4d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802f4d8:	4606      	mov	r6, r0
 802f4da:	460f      	mov	r7, r1
 802f4dc:	4614      	mov	r4, r2
 802f4de:	18d5      	adds	r5, r2, r3
 802f4e0:	42ac      	cmp	r4, r5
 802f4e2:	d101      	bne.n	802f4e8 <__sfputs_r+0x12>
 802f4e4:	2000      	movs	r0, #0
 802f4e6:	e007      	b.n	802f4f8 <__sfputs_r+0x22>
 802f4e8:	463a      	mov	r2, r7
 802f4ea:	f814 1b01 	ldrb.w	r1, [r4], #1
 802f4ee:	4630      	mov	r0, r6
 802f4f0:	f7ff ffda 	bl	802f4a8 <__sfputc_r>
 802f4f4:	1c43      	adds	r3, r0, #1
 802f4f6:	d1f3      	bne.n	802f4e0 <__sfputs_r+0xa>
 802f4f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0802f4fc <_vfiprintf_r>:
 802f4fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802f500:	460c      	mov	r4, r1
 802f502:	b09d      	sub	sp, #116	; 0x74
 802f504:	4617      	mov	r7, r2
 802f506:	461d      	mov	r5, r3
 802f508:	4606      	mov	r6, r0
 802f50a:	b118      	cbz	r0, 802f514 <_vfiprintf_r+0x18>
 802f50c:	6983      	ldr	r3, [r0, #24]
 802f50e:	b90b      	cbnz	r3, 802f514 <_vfiprintf_r+0x18>
 802f510:	f7ff fdee 	bl	802f0f0 <__sinit>
 802f514:	4b7c      	ldr	r3, [pc, #496]	; (802f708 <_vfiprintf_r+0x20c>)
 802f516:	429c      	cmp	r4, r3
 802f518:	d158      	bne.n	802f5cc <_vfiprintf_r+0xd0>
 802f51a:	6874      	ldr	r4, [r6, #4]
 802f51c:	89a3      	ldrh	r3, [r4, #12]
 802f51e:	0718      	lsls	r0, r3, #28
 802f520:	d55e      	bpl.n	802f5e0 <_vfiprintf_r+0xe4>
 802f522:	6923      	ldr	r3, [r4, #16]
 802f524:	2b00      	cmp	r3, #0
 802f526:	d05b      	beq.n	802f5e0 <_vfiprintf_r+0xe4>
 802f528:	2300      	movs	r3, #0
 802f52a:	9309      	str	r3, [sp, #36]	; 0x24
 802f52c:	2320      	movs	r3, #32
 802f52e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802f532:	2330      	movs	r3, #48	; 0x30
 802f534:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 802f538:	9503      	str	r5, [sp, #12]
 802f53a:	f04f 0b01 	mov.w	fp, #1
 802f53e:	46b8      	mov	r8, r7
 802f540:	4645      	mov	r5, r8
 802f542:	f815 3b01 	ldrb.w	r3, [r5], #1
 802f546:	b10b      	cbz	r3, 802f54c <_vfiprintf_r+0x50>
 802f548:	2b25      	cmp	r3, #37	; 0x25
 802f54a:	d154      	bne.n	802f5f6 <_vfiprintf_r+0xfa>
 802f54c:	ebb8 0a07 	subs.w	sl, r8, r7
 802f550:	d00b      	beq.n	802f56a <_vfiprintf_r+0x6e>
 802f552:	4653      	mov	r3, sl
 802f554:	463a      	mov	r2, r7
 802f556:	4621      	mov	r1, r4
 802f558:	4630      	mov	r0, r6
 802f55a:	f7ff ffbc 	bl	802f4d6 <__sfputs_r>
 802f55e:	3001      	adds	r0, #1
 802f560:	f000 80c2 	beq.w	802f6e8 <_vfiprintf_r+0x1ec>
 802f564:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f566:	4453      	add	r3, sl
 802f568:	9309      	str	r3, [sp, #36]	; 0x24
 802f56a:	f898 3000 	ldrb.w	r3, [r8]
 802f56e:	2b00      	cmp	r3, #0
 802f570:	f000 80ba 	beq.w	802f6e8 <_vfiprintf_r+0x1ec>
 802f574:	2300      	movs	r3, #0
 802f576:	f04f 32ff 	mov.w	r2, #4294967295
 802f57a:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802f57e:	9304      	str	r3, [sp, #16]
 802f580:	9307      	str	r3, [sp, #28]
 802f582:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 802f586:	931a      	str	r3, [sp, #104]	; 0x68
 802f588:	46a8      	mov	r8, r5
 802f58a:	2205      	movs	r2, #5
 802f58c:	f818 1b01 	ldrb.w	r1, [r8], #1
 802f590:	485e      	ldr	r0, [pc, #376]	; (802f70c <_vfiprintf_r+0x210>)
 802f592:	f7f8 fa7d 	bl	8027a90 <memchr>
 802f596:	9b04      	ldr	r3, [sp, #16]
 802f598:	bb78      	cbnz	r0, 802f5fa <_vfiprintf_r+0xfe>
 802f59a:	06d9      	lsls	r1, r3, #27
 802f59c:	bf44      	itt	mi
 802f59e:	2220      	movmi	r2, #32
 802f5a0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 802f5a4:	071a      	lsls	r2, r3, #28
 802f5a6:	bf44      	itt	mi
 802f5a8:	222b      	movmi	r2, #43	; 0x2b
 802f5aa:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 802f5ae:	782a      	ldrb	r2, [r5, #0]
 802f5b0:	2a2a      	cmp	r2, #42	; 0x2a
 802f5b2:	d02a      	beq.n	802f60a <_vfiprintf_r+0x10e>
 802f5b4:	9a07      	ldr	r2, [sp, #28]
 802f5b6:	46a8      	mov	r8, r5
 802f5b8:	2000      	movs	r0, #0
 802f5ba:	250a      	movs	r5, #10
 802f5bc:	4641      	mov	r1, r8
 802f5be:	f811 3b01 	ldrb.w	r3, [r1], #1
 802f5c2:	3b30      	subs	r3, #48	; 0x30
 802f5c4:	2b09      	cmp	r3, #9
 802f5c6:	d969      	bls.n	802f69c <_vfiprintf_r+0x1a0>
 802f5c8:	b360      	cbz	r0, 802f624 <_vfiprintf_r+0x128>
 802f5ca:	e024      	b.n	802f616 <_vfiprintf_r+0x11a>
 802f5cc:	4b50      	ldr	r3, [pc, #320]	; (802f710 <_vfiprintf_r+0x214>)
 802f5ce:	429c      	cmp	r4, r3
 802f5d0:	d101      	bne.n	802f5d6 <_vfiprintf_r+0xda>
 802f5d2:	68b4      	ldr	r4, [r6, #8]
 802f5d4:	e7a2      	b.n	802f51c <_vfiprintf_r+0x20>
 802f5d6:	4b4f      	ldr	r3, [pc, #316]	; (802f714 <_vfiprintf_r+0x218>)
 802f5d8:	429c      	cmp	r4, r3
 802f5da:	bf08      	it	eq
 802f5dc:	68f4      	ldreq	r4, [r6, #12]
 802f5de:	e79d      	b.n	802f51c <_vfiprintf_r+0x20>
 802f5e0:	4621      	mov	r1, r4
 802f5e2:	4630      	mov	r0, r6
 802f5e4:	f000 fb2e 	bl	802fc44 <__swsetup_r>
 802f5e8:	2800      	cmp	r0, #0
 802f5ea:	d09d      	beq.n	802f528 <_vfiprintf_r+0x2c>
 802f5ec:	f04f 30ff 	mov.w	r0, #4294967295
 802f5f0:	b01d      	add	sp, #116	; 0x74
 802f5f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802f5f6:	46a8      	mov	r8, r5
 802f5f8:	e7a2      	b.n	802f540 <_vfiprintf_r+0x44>
 802f5fa:	4a44      	ldr	r2, [pc, #272]	; (802f70c <_vfiprintf_r+0x210>)
 802f5fc:	1a80      	subs	r0, r0, r2
 802f5fe:	fa0b f000 	lsl.w	r0, fp, r0
 802f602:	4318      	orrs	r0, r3
 802f604:	9004      	str	r0, [sp, #16]
 802f606:	4645      	mov	r5, r8
 802f608:	e7be      	b.n	802f588 <_vfiprintf_r+0x8c>
 802f60a:	9a03      	ldr	r2, [sp, #12]
 802f60c:	1d11      	adds	r1, r2, #4
 802f60e:	6812      	ldr	r2, [r2, #0]
 802f610:	9103      	str	r1, [sp, #12]
 802f612:	2a00      	cmp	r2, #0
 802f614:	db01      	blt.n	802f61a <_vfiprintf_r+0x11e>
 802f616:	9207      	str	r2, [sp, #28]
 802f618:	e004      	b.n	802f624 <_vfiprintf_r+0x128>
 802f61a:	4252      	negs	r2, r2
 802f61c:	f043 0302 	orr.w	r3, r3, #2
 802f620:	9207      	str	r2, [sp, #28]
 802f622:	9304      	str	r3, [sp, #16]
 802f624:	f898 3000 	ldrb.w	r3, [r8]
 802f628:	2b2e      	cmp	r3, #46	; 0x2e
 802f62a:	d10e      	bne.n	802f64a <_vfiprintf_r+0x14e>
 802f62c:	f898 3001 	ldrb.w	r3, [r8, #1]
 802f630:	2b2a      	cmp	r3, #42	; 0x2a
 802f632:	d138      	bne.n	802f6a6 <_vfiprintf_r+0x1aa>
 802f634:	9b03      	ldr	r3, [sp, #12]
 802f636:	1d1a      	adds	r2, r3, #4
 802f638:	681b      	ldr	r3, [r3, #0]
 802f63a:	9203      	str	r2, [sp, #12]
 802f63c:	2b00      	cmp	r3, #0
 802f63e:	bfb8      	it	lt
 802f640:	f04f 33ff 	movlt.w	r3, #4294967295
 802f644:	f108 0802 	add.w	r8, r8, #2
 802f648:	9305      	str	r3, [sp, #20]
 802f64a:	4d33      	ldr	r5, [pc, #204]	; (802f718 <_vfiprintf_r+0x21c>)
 802f64c:	f898 1000 	ldrb.w	r1, [r8]
 802f650:	2203      	movs	r2, #3
 802f652:	4628      	mov	r0, r5
 802f654:	f7f8 fa1c 	bl	8027a90 <memchr>
 802f658:	b140      	cbz	r0, 802f66c <_vfiprintf_r+0x170>
 802f65a:	2340      	movs	r3, #64	; 0x40
 802f65c:	1b40      	subs	r0, r0, r5
 802f65e:	fa03 f000 	lsl.w	r0, r3, r0
 802f662:	9b04      	ldr	r3, [sp, #16]
 802f664:	4303      	orrs	r3, r0
 802f666:	f108 0801 	add.w	r8, r8, #1
 802f66a:	9304      	str	r3, [sp, #16]
 802f66c:	f898 1000 	ldrb.w	r1, [r8]
 802f670:	482a      	ldr	r0, [pc, #168]	; (802f71c <_vfiprintf_r+0x220>)
 802f672:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 802f676:	2206      	movs	r2, #6
 802f678:	f108 0701 	add.w	r7, r8, #1
 802f67c:	f7f8 fa08 	bl	8027a90 <memchr>
 802f680:	2800      	cmp	r0, #0
 802f682:	d037      	beq.n	802f6f4 <_vfiprintf_r+0x1f8>
 802f684:	4b26      	ldr	r3, [pc, #152]	; (802f720 <_vfiprintf_r+0x224>)
 802f686:	bb1b      	cbnz	r3, 802f6d0 <_vfiprintf_r+0x1d4>
 802f688:	9b03      	ldr	r3, [sp, #12]
 802f68a:	3307      	adds	r3, #7
 802f68c:	f023 0307 	bic.w	r3, r3, #7
 802f690:	3308      	adds	r3, #8
 802f692:	9303      	str	r3, [sp, #12]
 802f694:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f696:	444b      	add	r3, r9
 802f698:	9309      	str	r3, [sp, #36]	; 0x24
 802f69a:	e750      	b.n	802f53e <_vfiprintf_r+0x42>
 802f69c:	fb05 3202 	mla	r2, r5, r2, r3
 802f6a0:	2001      	movs	r0, #1
 802f6a2:	4688      	mov	r8, r1
 802f6a4:	e78a      	b.n	802f5bc <_vfiprintf_r+0xc0>
 802f6a6:	2300      	movs	r3, #0
 802f6a8:	f108 0801 	add.w	r8, r8, #1
 802f6ac:	9305      	str	r3, [sp, #20]
 802f6ae:	4619      	mov	r1, r3
 802f6b0:	250a      	movs	r5, #10
 802f6b2:	4640      	mov	r0, r8
 802f6b4:	f810 2b01 	ldrb.w	r2, [r0], #1
 802f6b8:	3a30      	subs	r2, #48	; 0x30
 802f6ba:	2a09      	cmp	r2, #9
 802f6bc:	d903      	bls.n	802f6c6 <_vfiprintf_r+0x1ca>
 802f6be:	2b00      	cmp	r3, #0
 802f6c0:	d0c3      	beq.n	802f64a <_vfiprintf_r+0x14e>
 802f6c2:	9105      	str	r1, [sp, #20]
 802f6c4:	e7c1      	b.n	802f64a <_vfiprintf_r+0x14e>
 802f6c6:	fb05 2101 	mla	r1, r5, r1, r2
 802f6ca:	2301      	movs	r3, #1
 802f6cc:	4680      	mov	r8, r0
 802f6ce:	e7f0      	b.n	802f6b2 <_vfiprintf_r+0x1b6>
 802f6d0:	ab03      	add	r3, sp, #12
 802f6d2:	9300      	str	r3, [sp, #0]
 802f6d4:	4622      	mov	r2, r4
 802f6d6:	4b13      	ldr	r3, [pc, #76]	; (802f724 <_vfiprintf_r+0x228>)
 802f6d8:	a904      	add	r1, sp, #16
 802f6da:	4630      	mov	r0, r6
 802f6dc:	f3af 8000 	nop.w
 802f6e0:	f1b0 3fff 	cmp.w	r0, #4294967295
 802f6e4:	4681      	mov	r9, r0
 802f6e6:	d1d5      	bne.n	802f694 <_vfiprintf_r+0x198>
 802f6e8:	89a3      	ldrh	r3, [r4, #12]
 802f6ea:	065b      	lsls	r3, r3, #25
 802f6ec:	f53f af7e 	bmi.w	802f5ec <_vfiprintf_r+0xf0>
 802f6f0:	9809      	ldr	r0, [sp, #36]	; 0x24
 802f6f2:	e77d      	b.n	802f5f0 <_vfiprintf_r+0xf4>
 802f6f4:	ab03      	add	r3, sp, #12
 802f6f6:	9300      	str	r3, [sp, #0]
 802f6f8:	4622      	mov	r2, r4
 802f6fa:	4b0a      	ldr	r3, [pc, #40]	; (802f724 <_vfiprintf_r+0x228>)
 802f6fc:	a904      	add	r1, sp, #16
 802f6fe:	4630      	mov	r0, r6
 802f700:	f000 f892 	bl	802f828 <_printf_i>
 802f704:	e7ec      	b.n	802f6e0 <_vfiprintf_r+0x1e4>
 802f706:	bf00      	nop
 802f708:	08030810 	.word	0x08030810
 802f70c:	08030854 	.word	0x08030854
 802f710:	08030830 	.word	0x08030830
 802f714:	080307f0 	.word	0x080307f0
 802f718:	0803085a 	.word	0x0803085a
 802f71c:	0803085e 	.word	0x0803085e
 802f720:	00000000 	.word	0x00000000
 802f724:	0802f4d7 	.word	0x0802f4d7

0802f728 <vfiprintf>:
 802f728:	4613      	mov	r3, r2
 802f72a:	460a      	mov	r2, r1
 802f72c:	4601      	mov	r1, r0
 802f72e:	4802      	ldr	r0, [pc, #8]	; (802f738 <vfiprintf+0x10>)
 802f730:	6800      	ldr	r0, [r0, #0]
 802f732:	f7ff bee3 	b.w	802f4fc <_vfiprintf_r>
 802f736:	bf00      	nop
 802f738:	200000a4 	.word	0x200000a4

0802f73c <_printf_common>:
 802f73c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802f740:	4691      	mov	r9, r2
 802f742:	461f      	mov	r7, r3
 802f744:	688a      	ldr	r2, [r1, #8]
 802f746:	690b      	ldr	r3, [r1, #16]
 802f748:	f8dd 8020 	ldr.w	r8, [sp, #32]
 802f74c:	4293      	cmp	r3, r2
 802f74e:	bfb8      	it	lt
 802f750:	4613      	movlt	r3, r2
 802f752:	f8c9 3000 	str.w	r3, [r9]
 802f756:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 802f75a:	4606      	mov	r6, r0
 802f75c:	460c      	mov	r4, r1
 802f75e:	b112      	cbz	r2, 802f766 <_printf_common+0x2a>
 802f760:	3301      	adds	r3, #1
 802f762:	f8c9 3000 	str.w	r3, [r9]
 802f766:	6823      	ldr	r3, [r4, #0]
 802f768:	0699      	lsls	r1, r3, #26
 802f76a:	bf42      	ittt	mi
 802f76c:	f8d9 3000 	ldrmi.w	r3, [r9]
 802f770:	3302      	addmi	r3, #2
 802f772:	f8c9 3000 	strmi.w	r3, [r9]
 802f776:	6825      	ldr	r5, [r4, #0]
 802f778:	f015 0506 	ands.w	r5, r5, #6
 802f77c:	d107      	bne.n	802f78e <_printf_common+0x52>
 802f77e:	f104 0a19 	add.w	sl, r4, #25
 802f782:	68e3      	ldr	r3, [r4, #12]
 802f784:	f8d9 2000 	ldr.w	r2, [r9]
 802f788:	1a9b      	subs	r3, r3, r2
 802f78a:	42ab      	cmp	r3, r5
 802f78c:	dc28      	bgt.n	802f7e0 <_printf_common+0xa4>
 802f78e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 802f792:	6822      	ldr	r2, [r4, #0]
 802f794:	3300      	adds	r3, #0
 802f796:	bf18      	it	ne
 802f798:	2301      	movne	r3, #1
 802f79a:	0692      	lsls	r2, r2, #26
 802f79c:	d42d      	bmi.n	802f7fa <_printf_common+0xbe>
 802f79e:	f104 0243 	add.w	r2, r4, #67	; 0x43
 802f7a2:	4639      	mov	r1, r7
 802f7a4:	4630      	mov	r0, r6
 802f7a6:	47c0      	blx	r8
 802f7a8:	3001      	adds	r0, #1
 802f7aa:	d020      	beq.n	802f7ee <_printf_common+0xb2>
 802f7ac:	6823      	ldr	r3, [r4, #0]
 802f7ae:	68e5      	ldr	r5, [r4, #12]
 802f7b0:	f8d9 2000 	ldr.w	r2, [r9]
 802f7b4:	f003 0306 	and.w	r3, r3, #6
 802f7b8:	2b04      	cmp	r3, #4
 802f7ba:	bf08      	it	eq
 802f7bc:	1aad      	subeq	r5, r5, r2
 802f7be:	68a3      	ldr	r3, [r4, #8]
 802f7c0:	6922      	ldr	r2, [r4, #16]
 802f7c2:	bf0c      	ite	eq
 802f7c4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802f7c8:	2500      	movne	r5, #0
 802f7ca:	4293      	cmp	r3, r2
 802f7cc:	bfc4      	itt	gt
 802f7ce:	1a9b      	subgt	r3, r3, r2
 802f7d0:	18ed      	addgt	r5, r5, r3
 802f7d2:	f04f 0900 	mov.w	r9, #0
 802f7d6:	341a      	adds	r4, #26
 802f7d8:	454d      	cmp	r5, r9
 802f7da:	d11a      	bne.n	802f812 <_printf_common+0xd6>
 802f7dc:	2000      	movs	r0, #0
 802f7de:	e008      	b.n	802f7f2 <_printf_common+0xb6>
 802f7e0:	2301      	movs	r3, #1
 802f7e2:	4652      	mov	r2, sl
 802f7e4:	4639      	mov	r1, r7
 802f7e6:	4630      	mov	r0, r6
 802f7e8:	47c0      	blx	r8
 802f7ea:	3001      	adds	r0, #1
 802f7ec:	d103      	bne.n	802f7f6 <_printf_common+0xba>
 802f7ee:	f04f 30ff 	mov.w	r0, #4294967295
 802f7f2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802f7f6:	3501      	adds	r5, #1
 802f7f8:	e7c3      	b.n	802f782 <_printf_common+0x46>
 802f7fa:	18e1      	adds	r1, r4, r3
 802f7fc:	1c5a      	adds	r2, r3, #1
 802f7fe:	2030      	movs	r0, #48	; 0x30
 802f800:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 802f804:	4422      	add	r2, r4
 802f806:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 802f80a:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 802f80e:	3302      	adds	r3, #2
 802f810:	e7c5      	b.n	802f79e <_printf_common+0x62>
 802f812:	2301      	movs	r3, #1
 802f814:	4622      	mov	r2, r4
 802f816:	4639      	mov	r1, r7
 802f818:	4630      	mov	r0, r6
 802f81a:	47c0      	blx	r8
 802f81c:	3001      	adds	r0, #1
 802f81e:	d0e6      	beq.n	802f7ee <_printf_common+0xb2>
 802f820:	f109 0901 	add.w	r9, r9, #1
 802f824:	e7d8      	b.n	802f7d8 <_printf_common+0x9c>
	...

0802f828 <_printf_i>:
 802f828:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802f82c:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 802f830:	460c      	mov	r4, r1
 802f832:	7e09      	ldrb	r1, [r1, #24]
 802f834:	b085      	sub	sp, #20
 802f836:	296e      	cmp	r1, #110	; 0x6e
 802f838:	4617      	mov	r7, r2
 802f83a:	4606      	mov	r6, r0
 802f83c:	4698      	mov	r8, r3
 802f83e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 802f840:	f000 80b3 	beq.w	802f9aa <_printf_i+0x182>
 802f844:	d822      	bhi.n	802f88c <_printf_i+0x64>
 802f846:	2963      	cmp	r1, #99	; 0x63
 802f848:	d036      	beq.n	802f8b8 <_printf_i+0x90>
 802f84a:	d80a      	bhi.n	802f862 <_printf_i+0x3a>
 802f84c:	2900      	cmp	r1, #0
 802f84e:	f000 80b9 	beq.w	802f9c4 <_printf_i+0x19c>
 802f852:	2958      	cmp	r1, #88	; 0x58
 802f854:	f000 8083 	beq.w	802f95e <_printf_i+0x136>
 802f858:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802f85c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 802f860:	e032      	b.n	802f8c8 <_printf_i+0xa0>
 802f862:	2964      	cmp	r1, #100	; 0x64
 802f864:	d001      	beq.n	802f86a <_printf_i+0x42>
 802f866:	2969      	cmp	r1, #105	; 0x69
 802f868:	d1f6      	bne.n	802f858 <_printf_i+0x30>
 802f86a:	6820      	ldr	r0, [r4, #0]
 802f86c:	6813      	ldr	r3, [r2, #0]
 802f86e:	0605      	lsls	r5, r0, #24
 802f870:	f103 0104 	add.w	r1, r3, #4
 802f874:	d52a      	bpl.n	802f8cc <_printf_i+0xa4>
 802f876:	681b      	ldr	r3, [r3, #0]
 802f878:	6011      	str	r1, [r2, #0]
 802f87a:	2b00      	cmp	r3, #0
 802f87c:	da03      	bge.n	802f886 <_printf_i+0x5e>
 802f87e:	222d      	movs	r2, #45	; 0x2d
 802f880:	425b      	negs	r3, r3
 802f882:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 802f886:	486f      	ldr	r0, [pc, #444]	; (802fa44 <_printf_i+0x21c>)
 802f888:	220a      	movs	r2, #10
 802f88a:	e039      	b.n	802f900 <_printf_i+0xd8>
 802f88c:	2973      	cmp	r1, #115	; 0x73
 802f88e:	f000 809d 	beq.w	802f9cc <_printf_i+0x1a4>
 802f892:	d808      	bhi.n	802f8a6 <_printf_i+0x7e>
 802f894:	296f      	cmp	r1, #111	; 0x6f
 802f896:	d020      	beq.n	802f8da <_printf_i+0xb2>
 802f898:	2970      	cmp	r1, #112	; 0x70
 802f89a:	d1dd      	bne.n	802f858 <_printf_i+0x30>
 802f89c:	6823      	ldr	r3, [r4, #0]
 802f89e:	f043 0320 	orr.w	r3, r3, #32
 802f8a2:	6023      	str	r3, [r4, #0]
 802f8a4:	e003      	b.n	802f8ae <_printf_i+0x86>
 802f8a6:	2975      	cmp	r1, #117	; 0x75
 802f8a8:	d017      	beq.n	802f8da <_printf_i+0xb2>
 802f8aa:	2978      	cmp	r1, #120	; 0x78
 802f8ac:	d1d4      	bne.n	802f858 <_printf_i+0x30>
 802f8ae:	2378      	movs	r3, #120	; 0x78
 802f8b0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 802f8b4:	4864      	ldr	r0, [pc, #400]	; (802fa48 <_printf_i+0x220>)
 802f8b6:	e055      	b.n	802f964 <_printf_i+0x13c>
 802f8b8:	6813      	ldr	r3, [r2, #0]
 802f8ba:	1d19      	adds	r1, r3, #4
 802f8bc:	681b      	ldr	r3, [r3, #0]
 802f8be:	6011      	str	r1, [r2, #0]
 802f8c0:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802f8c4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 802f8c8:	2301      	movs	r3, #1
 802f8ca:	e08c      	b.n	802f9e6 <_printf_i+0x1be>
 802f8cc:	681b      	ldr	r3, [r3, #0]
 802f8ce:	6011      	str	r1, [r2, #0]
 802f8d0:	f010 0f40 	tst.w	r0, #64	; 0x40
 802f8d4:	bf18      	it	ne
 802f8d6:	b21b      	sxthne	r3, r3
 802f8d8:	e7cf      	b.n	802f87a <_printf_i+0x52>
 802f8da:	6813      	ldr	r3, [r2, #0]
 802f8dc:	6825      	ldr	r5, [r4, #0]
 802f8de:	1d18      	adds	r0, r3, #4
 802f8e0:	6010      	str	r0, [r2, #0]
 802f8e2:	0628      	lsls	r0, r5, #24
 802f8e4:	d501      	bpl.n	802f8ea <_printf_i+0xc2>
 802f8e6:	681b      	ldr	r3, [r3, #0]
 802f8e8:	e002      	b.n	802f8f0 <_printf_i+0xc8>
 802f8ea:	0668      	lsls	r0, r5, #25
 802f8ec:	d5fb      	bpl.n	802f8e6 <_printf_i+0xbe>
 802f8ee:	881b      	ldrh	r3, [r3, #0]
 802f8f0:	4854      	ldr	r0, [pc, #336]	; (802fa44 <_printf_i+0x21c>)
 802f8f2:	296f      	cmp	r1, #111	; 0x6f
 802f8f4:	bf14      	ite	ne
 802f8f6:	220a      	movne	r2, #10
 802f8f8:	2208      	moveq	r2, #8
 802f8fa:	2100      	movs	r1, #0
 802f8fc:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 802f900:	6865      	ldr	r5, [r4, #4]
 802f902:	60a5      	str	r5, [r4, #8]
 802f904:	2d00      	cmp	r5, #0
 802f906:	f2c0 8095 	blt.w	802fa34 <_printf_i+0x20c>
 802f90a:	6821      	ldr	r1, [r4, #0]
 802f90c:	f021 0104 	bic.w	r1, r1, #4
 802f910:	6021      	str	r1, [r4, #0]
 802f912:	2b00      	cmp	r3, #0
 802f914:	d13d      	bne.n	802f992 <_printf_i+0x16a>
 802f916:	2d00      	cmp	r5, #0
 802f918:	f040 808e 	bne.w	802fa38 <_printf_i+0x210>
 802f91c:	4665      	mov	r5, ip
 802f91e:	2a08      	cmp	r2, #8
 802f920:	d10b      	bne.n	802f93a <_printf_i+0x112>
 802f922:	6823      	ldr	r3, [r4, #0]
 802f924:	07db      	lsls	r3, r3, #31
 802f926:	d508      	bpl.n	802f93a <_printf_i+0x112>
 802f928:	6923      	ldr	r3, [r4, #16]
 802f92a:	6862      	ldr	r2, [r4, #4]
 802f92c:	429a      	cmp	r2, r3
 802f92e:	bfde      	ittt	le
 802f930:	2330      	movle	r3, #48	; 0x30
 802f932:	f805 3c01 	strble.w	r3, [r5, #-1]
 802f936:	f105 35ff 	addle.w	r5, r5, #4294967295
 802f93a:	ebac 0305 	sub.w	r3, ip, r5
 802f93e:	6123      	str	r3, [r4, #16]
 802f940:	f8cd 8000 	str.w	r8, [sp]
 802f944:	463b      	mov	r3, r7
 802f946:	aa03      	add	r2, sp, #12
 802f948:	4621      	mov	r1, r4
 802f94a:	4630      	mov	r0, r6
 802f94c:	f7ff fef6 	bl	802f73c <_printf_common>
 802f950:	3001      	adds	r0, #1
 802f952:	d14d      	bne.n	802f9f0 <_printf_i+0x1c8>
 802f954:	f04f 30ff 	mov.w	r0, #4294967295
 802f958:	b005      	add	sp, #20
 802f95a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802f95e:	4839      	ldr	r0, [pc, #228]	; (802fa44 <_printf_i+0x21c>)
 802f960:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 802f964:	6813      	ldr	r3, [r2, #0]
 802f966:	6821      	ldr	r1, [r4, #0]
 802f968:	1d1d      	adds	r5, r3, #4
 802f96a:	681b      	ldr	r3, [r3, #0]
 802f96c:	6015      	str	r5, [r2, #0]
 802f96e:	060a      	lsls	r2, r1, #24
 802f970:	d50b      	bpl.n	802f98a <_printf_i+0x162>
 802f972:	07ca      	lsls	r2, r1, #31
 802f974:	bf44      	itt	mi
 802f976:	f041 0120 	orrmi.w	r1, r1, #32
 802f97a:	6021      	strmi	r1, [r4, #0]
 802f97c:	b91b      	cbnz	r3, 802f986 <_printf_i+0x15e>
 802f97e:	6822      	ldr	r2, [r4, #0]
 802f980:	f022 0220 	bic.w	r2, r2, #32
 802f984:	6022      	str	r2, [r4, #0]
 802f986:	2210      	movs	r2, #16
 802f988:	e7b7      	b.n	802f8fa <_printf_i+0xd2>
 802f98a:	064d      	lsls	r5, r1, #25
 802f98c:	bf48      	it	mi
 802f98e:	b29b      	uxthmi	r3, r3
 802f990:	e7ef      	b.n	802f972 <_printf_i+0x14a>
 802f992:	4665      	mov	r5, ip
 802f994:	fbb3 f1f2 	udiv	r1, r3, r2
 802f998:	fb02 3311 	mls	r3, r2, r1, r3
 802f99c:	5cc3      	ldrb	r3, [r0, r3]
 802f99e:	f805 3d01 	strb.w	r3, [r5, #-1]!
 802f9a2:	460b      	mov	r3, r1
 802f9a4:	2900      	cmp	r1, #0
 802f9a6:	d1f5      	bne.n	802f994 <_printf_i+0x16c>
 802f9a8:	e7b9      	b.n	802f91e <_printf_i+0xf6>
 802f9aa:	6813      	ldr	r3, [r2, #0]
 802f9ac:	6825      	ldr	r5, [r4, #0]
 802f9ae:	6961      	ldr	r1, [r4, #20]
 802f9b0:	1d18      	adds	r0, r3, #4
 802f9b2:	6010      	str	r0, [r2, #0]
 802f9b4:	0628      	lsls	r0, r5, #24
 802f9b6:	681b      	ldr	r3, [r3, #0]
 802f9b8:	d501      	bpl.n	802f9be <_printf_i+0x196>
 802f9ba:	6019      	str	r1, [r3, #0]
 802f9bc:	e002      	b.n	802f9c4 <_printf_i+0x19c>
 802f9be:	066a      	lsls	r2, r5, #25
 802f9c0:	d5fb      	bpl.n	802f9ba <_printf_i+0x192>
 802f9c2:	8019      	strh	r1, [r3, #0]
 802f9c4:	2300      	movs	r3, #0
 802f9c6:	6123      	str	r3, [r4, #16]
 802f9c8:	4665      	mov	r5, ip
 802f9ca:	e7b9      	b.n	802f940 <_printf_i+0x118>
 802f9cc:	6813      	ldr	r3, [r2, #0]
 802f9ce:	1d19      	adds	r1, r3, #4
 802f9d0:	6011      	str	r1, [r2, #0]
 802f9d2:	681d      	ldr	r5, [r3, #0]
 802f9d4:	6862      	ldr	r2, [r4, #4]
 802f9d6:	2100      	movs	r1, #0
 802f9d8:	4628      	mov	r0, r5
 802f9da:	f7f8 f859 	bl	8027a90 <memchr>
 802f9de:	b108      	cbz	r0, 802f9e4 <_printf_i+0x1bc>
 802f9e0:	1b40      	subs	r0, r0, r5
 802f9e2:	6060      	str	r0, [r4, #4]
 802f9e4:	6863      	ldr	r3, [r4, #4]
 802f9e6:	6123      	str	r3, [r4, #16]
 802f9e8:	2300      	movs	r3, #0
 802f9ea:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 802f9ee:	e7a7      	b.n	802f940 <_printf_i+0x118>
 802f9f0:	6923      	ldr	r3, [r4, #16]
 802f9f2:	462a      	mov	r2, r5
 802f9f4:	4639      	mov	r1, r7
 802f9f6:	4630      	mov	r0, r6
 802f9f8:	47c0      	blx	r8
 802f9fa:	3001      	adds	r0, #1
 802f9fc:	d0aa      	beq.n	802f954 <_printf_i+0x12c>
 802f9fe:	6823      	ldr	r3, [r4, #0]
 802fa00:	079b      	lsls	r3, r3, #30
 802fa02:	d413      	bmi.n	802fa2c <_printf_i+0x204>
 802fa04:	68e0      	ldr	r0, [r4, #12]
 802fa06:	9b03      	ldr	r3, [sp, #12]
 802fa08:	4298      	cmp	r0, r3
 802fa0a:	bfb8      	it	lt
 802fa0c:	4618      	movlt	r0, r3
 802fa0e:	e7a3      	b.n	802f958 <_printf_i+0x130>
 802fa10:	2301      	movs	r3, #1
 802fa12:	464a      	mov	r2, r9
 802fa14:	4639      	mov	r1, r7
 802fa16:	4630      	mov	r0, r6
 802fa18:	47c0      	blx	r8
 802fa1a:	3001      	adds	r0, #1
 802fa1c:	d09a      	beq.n	802f954 <_printf_i+0x12c>
 802fa1e:	3501      	adds	r5, #1
 802fa20:	68e3      	ldr	r3, [r4, #12]
 802fa22:	9a03      	ldr	r2, [sp, #12]
 802fa24:	1a9b      	subs	r3, r3, r2
 802fa26:	42ab      	cmp	r3, r5
 802fa28:	dcf2      	bgt.n	802fa10 <_printf_i+0x1e8>
 802fa2a:	e7eb      	b.n	802fa04 <_printf_i+0x1dc>
 802fa2c:	2500      	movs	r5, #0
 802fa2e:	f104 0919 	add.w	r9, r4, #25
 802fa32:	e7f5      	b.n	802fa20 <_printf_i+0x1f8>
 802fa34:	2b00      	cmp	r3, #0
 802fa36:	d1ac      	bne.n	802f992 <_printf_i+0x16a>
 802fa38:	7803      	ldrb	r3, [r0, #0]
 802fa3a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 802fa3e:	f104 0542 	add.w	r5, r4, #66	; 0x42
 802fa42:	e76c      	b.n	802f91e <_printf_i+0xf6>
 802fa44:	08030865 	.word	0x08030865
 802fa48:	08030876 	.word	0x08030876

0802fa4c <_sbrk_r>:
 802fa4c:	b538      	push	{r3, r4, r5, lr}
 802fa4e:	4c06      	ldr	r4, [pc, #24]	; (802fa68 <_sbrk_r+0x1c>)
 802fa50:	2300      	movs	r3, #0
 802fa52:	4605      	mov	r5, r0
 802fa54:	4608      	mov	r0, r1
 802fa56:	6023      	str	r3, [r4, #0]
 802fa58:	f7fb fa1e 	bl	802ae98 <_sbrk>
 802fa5c:	1c43      	adds	r3, r0, #1
 802fa5e:	d102      	bne.n	802fa66 <_sbrk_r+0x1a>
 802fa60:	6823      	ldr	r3, [r4, #0]
 802fa62:	b103      	cbz	r3, 802fa66 <_sbrk_r+0x1a>
 802fa64:	602b      	str	r3, [r5, #0]
 802fa66:	bd38      	pop	{r3, r4, r5, pc}
 802fa68:	20004308 	.word	0x20004308

0802fa6c <_raise_r>:
 802fa6c:	291f      	cmp	r1, #31
 802fa6e:	b538      	push	{r3, r4, r5, lr}
 802fa70:	4604      	mov	r4, r0
 802fa72:	460d      	mov	r5, r1
 802fa74:	d904      	bls.n	802fa80 <_raise_r+0x14>
 802fa76:	2316      	movs	r3, #22
 802fa78:	6003      	str	r3, [r0, #0]
 802fa7a:	f04f 30ff 	mov.w	r0, #4294967295
 802fa7e:	bd38      	pop	{r3, r4, r5, pc}
 802fa80:	6c42      	ldr	r2, [r0, #68]	; 0x44
 802fa82:	b112      	cbz	r2, 802fa8a <_raise_r+0x1e>
 802fa84:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802fa88:	b94b      	cbnz	r3, 802fa9e <_raise_r+0x32>
 802fa8a:	4620      	mov	r0, r4
 802fa8c:	f000 f830 	bl	802faf0 <_getpid_r>
 802fa90:	462a      	mov	r2, r5
 802fa92:	4601      	mov	r1, r0
 802fa94:	4620      	mov	r0, r4
 802fa96:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802fa9a:	f000 b817 	b.w	802facc <_kill_r>
 802fa9e:	2b01      	cmp	r3, #1
 802faa0:	d00a      	beq.n	802fab8 <_raise_r+0x4c>
 802faa2:	1c59      	adds	r1, r3, #1
 802faa4:	d103      	bne.n	802faae <_raise_r+0x42>
 802faa6:	2316      	movs	r3, #22
 802faa8:	6003      	str	r3, [r0, #0]
 802faaa:	2001      	movs	r0, #1
 802faac:	e7e7      	b.n	802fa7e <_raise_r+0x12>
 802faae:	2400      	movs	r4, #0
 802fab0:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 802fab4:	4628      	mov	r0, r5
 802fab6:	4798      	blx	r3
 802fab8:	2000      	movs	r0, #0
 802faba:	e7e0      	b.n	802fa7e <_raise_r+0x12>

0802fabc <raise>:
 802fabc:	4b02      	ldr	r3, [pc, #8]	; (802fac8 <raise+0xc>)
 802fabe:	4601      	mov	r1, r0
 802fac0:	6818      	ldr	r0, [r3, #0]
 802fac2:	f7ff bfd3 	b.w	802fa6c <_raise_r>
 802fac6:	bf00      	nop
 802fac8:	200000a4 	.word	0x200000a4

0802facc <_kill_r>:
 802facc:	b538      	push	{r3, r4, r5, lr}
 802face:	4c07      	ldr	r4, [pc, #28]	; (802faec <_kill_r+0x20>)
 802fad0:	2300      	movs	r3, #0
 802fad2:	4605      	mov	r5, r0
 802fad4:	4608      	mov	r0, r1
 802fad6:	4611      	mov	r1, r2
 802fad8:	6023      	str	r3, [r4, #0]
 802fada:	f7fb f955 	bl	802ad88 <_kill>
 802fade:	1c43      	adds	r3, r0, #1
 802fae0:	d102      	bne.n	802fae8 <_kill_r+0x1c>
 802fae2:	6823      	ldr	r3, [r4, #0]
 802fae4:	b103      	cbz	r3, 802fae8 <_kill_r+0x1c>
 802fae6:	602b      	str	r3, [r5, #0]
 802fae8:	bd38      	pop	{r3, r4, r5, pc}
 802faea:	bf00      	nop
 802faec:	20004308 	.word	0x20004308

0802faf0 <_getpid_r>:
 802faf0:	f7fb b942 	b.w	802ad78 <_getpid>

0802faf4 <__sread>:
 802faf4:	b510      	push	{r4, lr}
 802faf6:	460c      	mov	r4, r1
 802faf8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802fafc:	f000 f998 	bl	802fe30 <_read_r>
 802fb00:	2800      	cmp	r0, #0
 802fb02:	bfab      	itete	ge
 802fb04:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 802fb06:	89a3      	ldrhlt	r3, [r4, #12]
 802fb08:	181b      	addge	r3, r3, r0
 802fb0a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 802fb0e:	bfac      	ite	ge
 802fb10:	6563      	strge	r3, [r4, #84]	; 0x54
 802fb12:	81a3      	strhlt	r3, [r4, #12]
 802fb14:	bd10      	pop	{r4, pc}

0802fb16 <__swrite>:
 802fb16:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802fb1a:	461f      	mov	r7, r3
 802fb1c:	898b      	ldrh	r3, [r1, #12]
 802fb1e:	05db      	lsls	r3, r3, #23
 802fb20:	4605      	mov	r5, r0
 802fb22:	460c      	mov	r4, r1
 802fb24:	4616      	mov	r6, r2
 802fb26:	d505      	bpl.n	802fb34 <__swrite+0x1e>
 802fb28:	2302      	movs	r3, #2
 802fb2a:	2200      	movs	r2, #0
 802fb2c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802fb30:	f000 f906 	bl	802fd40 <_lseek_r>
 802fb34:	89a3      	ldrh	r3, [r4, #12]
 802fb36:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802fb3a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 802fb3e:	81a3      	strh	r3, [r4, #12]
 802fb40:	4632      	mov	r2, r6
 802fb42:	463b      	mov	r3, r7
 802fb44:	4628      	mov	r0, r5
 802fb46:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 802fb4a:	f000 b869 	b.w	802fc20 <_write_r>

0802fb4e <__sseek>:
 802fb4e:	b510      	push	{r4, lr}
 802fb50:	460c      	mov	r4, r1
 802fb52:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802fb56:	f000 f8f3 	bl	802fd40 <_lseek_r>
 802fb5a:	1c43      	adds	r3, r0, #1
 802fb5c:	89a3      	ldrh	r3, [r4, #12]
 802fb5e:	bf15      	itete	ne
 802fb60:	6560      	strne	r0, [r4, #84]	; 0x54
 802fb62:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 802fb66:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 802fb6a:	81a3      	strheq	r3, [r4, #12]
 802fb6c:	bf18      	it	ne
 802fb6e:	81a3      	strhne	r3, [r4, #12]
 802fb70:	bd10      	pop	{r4, pc}

0802fb72 <__sclose>:
 802fb72:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802fb76:	f000 b8d3 	b.w	802fd20 <_close_r>
	...

0802fb7c <__swbuf_r>:
 802fb7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802fb7e:	460e      	mov	r6, r1
 802fb80:	4614      	mov	r4, r2
 802fb82:	4605      	mov	r5, r0
 802fb84:	b118      	cbz	r0, 802fb8e <__swbuf_r+0x12>
 802fb86:	6983      	ldr	r3, [r0, #24]
 802fb88:	b90b      	cbnz	r3, 802fb8e <__swbuf_r+0x12>
 802fb8a:	f7ff fab1 	bl	802f0f0 <__sinit>
 802fb8e:	4b21      	ldr	r3, [pc, #132]	; (802fc14 <__swbuf_r+0x98>)
 802fb90:	429c      	cmp	r4, r3
 802fb92:	d12a      	bne.n	802fbea <__swbuf_r+0x6e>
 802fb94:	686c      	ldr	r4, [r5, #4]
 802fb96:	69a3      	ldr	r3, [r4, #24]
 802fb98:	60a3      	str	r3, [r4, #8]
 802fb9a:	89a3      	ldrh	r3, [r4, #12]
 802fb9c:	071a      	lsls	r2, r3, #28
 802fb9e:	d52e      	bpl.n	802fbfe <__swbuf_r+0x82>
 802fba0:	6923      	ldr	r3, [r4, #16]
 802fba2:	b363      	cbz	r3, 802fbfe <__swbuf_r+0x82>
 802fba4:	6923      	ldr	r3, [r4, #16]
 802fba6:	6820      	ldr	r0, [r4, #0]
 802fba8:	1ac0      	subs	r0, r0, r3
 802fbaa:	6963      	ldr	r3, [r4, #20]
 802fbac:	b2f6      	uxtb	r6, r6
 802fbae:	4283      	cmp	r3, r0
 802fbb0:	4637      	mov	r7, r6
 802fbb2:	dc04      	bgt.n	802fbbe <__swbuf_r+0x42>
 802fbb4:	4621      	mov	r1, r4
 802fbb6:	4628      	mov	r0, r5
 802fbb8:	f7ff fa1e 	bl	802eff8 <_fflush_r>
 802fbbc:	bb28      	cbnz	r0, 802fc0a <__swbuf_r+0x8e>
 802fbbe:	68a3      	ldr	r3, [r4, #8]
 802fbc0:	3b01      	subs	r3, #1
 802fbc2:	60a3      	str	r3, [r4, #8]
 802fbc4:	6823      	ldr	r3, [r4, #0]
 802fbc6:	1c5a      	adds	r2, r3, #1
 802fbc8:	6022      	str	r2, [r4, #0]
 802fbca:	701e      	strb	r6, [r3, #0]
 802fbcc:	6963      	ldr	r3, [r4, #20]
 802fbce:	3001      	adds	r0, #1
 802fbd0:	4283      	cmp	r3, r0
 802fbd2:	d004      	beq.n	802fbde <__swbuf_r+0x62>
 802fbd4:	89a3      	ldrh	r3, [r4, #12]
 802fbd6:	07db      	lsls	r3, r3, #31
 802fbd8:	d519      	bpl.n	802fc0e <__swbuf_r+0x92>
 802fbda:	2e0a      	cmp	r6, #10
 802fbdc:	d117      	bne.n	802fc0e <__swbuf_r+0x92>
 802fbde:	4621      	mov	r1, r4
 802fbe0:	4628      	mov	r0, r5
 802fbe2:	f7ff fa09 	bl	802eff8 <_fflush_r>
 802fbe6:	b190      	cbz	r0, 802fc0e <__swbuf_r+0x92>
 802fbe8:	e00f      	b.n	802fc0a <__swbuf_r+0x8e>
 802fbea:	4b0b      	ldr	r3, [pc, #44]	; (802fc18 <__swbuf_r+0x9c>)
 802fbec:	429c      	cmp	r4, r3
 802fbee:	d101      	bne.n	802fbf4 <__swbuf_r+0x78>
 802fbf0:	68ac      	ldr	r4, [r5, #8]
 802fbf2:	e7d0      	b.n	802fb96 <__swbuf_r+0x1a>
 802fbf4:	4b09      	ldr	r3, [pc, #36]	; (802fc1c <__swbuf_r+0xa0>)
 802fbf6:	429c      	cmp	r4, r3
 802fbf8:	bf08      	it	eq
 802fbfa:	68ec      	ldreq	r4, [r5, #12]
 802fbfc:	e7cb      	b.n	802fb96 <__swbuf_r+0x1a>
 802fbfe:	4621      	mov	r1, r4
 802fc00:	4628      	mov	r0, r5
 802fc02:	f000 f81f 	bl	802fc44 <__swsetup_r>
 802fc06:	2800      	cmp	r0, #0
 802fc08:	d0cc      	beq.n	802fba4 <__swbuf_r+0x28>
 802fc0a:	f04f 37ff 	mov.w	r7, #4294967295
 802fc0e:	4638      	mov	r0, r7
 802fc10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802fc12:	bf00      	nop
 802fc14:	08030810 	.word	0x08030810
 802fc18:	08030830 	.word	0x08030830
 802fc1c:	080307f0 	.word	0x080307f0

0802fc20 <_write_r>:
 802fc20:	b538      	push	{r3, r4, r5, lr}
 802fc22:	4c07      	ldr	r4, [pc, #28]	; (802fc40 <_write_r+0x20>)
 802fc24:	4605      	mov	r5, r0
 802fc26:	4608      	mov	r0, r1
 802fc28:	4611      	mov	r1, r2
 802fc2a:	2200      	movs	r2, #0
 802fc2c:	6022      	str	r2, [r4, #0]
 802fc2e:	461a      	mov	r2, r3
 802fc30:	f7fb f8e1 	bl	802adf6 <_write>
 802fc34:	1c43      	adds	r3, r0, #1
 802fc36:	d102      	bne.n	802fc3e <_write_r+0x1e>
 802fc38:	6823      	ldr	r3, [r4, #0]
 802fc3a:	b103      	cbz	r3, 802fc3e <_write_r+0x1e>
 802fc3c:	602b      	str	r3, [r5, #0]
 802fc3e:	bd38      	pop	{r3, r4, r5, pc}
 802fc40:	20004308 	.word	0x20004308

0802fc44 <__swsetup_r>:
 802fc44:	4b32      	ldr	r3, [pc, #200]	; (802fd10 <__swsetup_r+0xcc>)
 802fc46:	b570      	push	{r4, r5, r6, lr}
 802fc48:	681d      	ldr	r5, [r3, #0]
 802fc4a:	4606      	mov	r6, r0
 802fc4c:	460c      	mov	r4, r1
 802fc4e:	b125      	cbz	r5, 802fc5a <__swsetup_r+0x16>
 802fc50:	69ab      	ldr	r3, [r5, #24]
 802fc52:	b913      	cbnz	r3, 802fc5a <__swsetup_r+0x16>
 802fc54:	4628      	mov	r0, r5
 802fc56:	f7ff fa4b 	bl	802f0f0 <__sinit>
 802fc5a:	4b2e      	ldr	r3, [pc, #184]	; (802fd14 <__swsetup_r+0xd0>)
 802fc5c:	429c      	cmp	r4, r3
 802fc5e:	d10f      	bne.n	802fc80 <__swsetup_r+0x3c>
 802fc60:	686c      	ldr	r4, [r5, #4]
 802fc62:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802fc66:	b29a      	uxth	r2, r3
 802fc68:	0715      	lsls	r5, r2, #28
 802fc6a:	d42c      	bmi.n	802fcc6 <__swsetup_r+0x82>
 802fc6c:	06d0      	lsls	r0, r2, #27
 802fc6e:	d411      	bmi.n	802fc94 <__swsetup_r+0x50>
 802fc70:	2209      	movs	r2, #9
 802fc72:	6032      	str	r2, [r6, #0]
 802fc74:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802fc78:	81a3      	strh	r3, [r4, #12]
 802fc7a:	f04f 30ff 	mov.w	r0, #4294967295
 802fc7e:	e03e      	b.n	802fcfe <__swsetup_r+0xba>
 802fc80:	4b25      	ldr	r3, [pc, #148]	; (802fd18 <__swsetup_r+0xd4>)
 802fc82:	429c      	cmp	r4, r3
 802fc84:	d101      	bne.n	802fc8a <__swsetup_r+0x46>
 802fc86:	68ac      	ldr	r4, [r5, #8]
 802fc88:	e7eb      	b.n	802fc62 <__swsetup_r+0x1e>
 802fc8a:	4b24      	ldr	r3, [pc, #144]	; (802fd1c <__swsetup_r+0xd8>)
 802fc8c:	429c      	cmp	r4, r3
 802fc8e:	bf08      	it	eq
 802fc90:	68ec      	ldreq	r4, [r5, #12]
 802fc92:	e7e6      	b.n	802fc62 <__swsetup_r+0x1e>
 802fc94:	0751      	lsls	r1, r2, #29
 802fc96:	d512      	bpl.n	802fcbe <__swsetup_r+0x7a>
 802fc98:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802fc9a:	b141      	cbz	r1, 802fcae <__swsetup_r+0x6a>
 802fc9c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 802fca0:	4299      	cmp	r1, r3
 802fca2:	d002      	beq.n	802fcaa <__swsetup_r+0x66>
 802fca4:	4630      	mov	r0, r6
 802fca6:	f7ff fb57 	bl	802f358 <_free_r>
 802fcaa:	2300      	movs	r3, #0
 802fcac:	6363      	str	r3, [r4, #52]	; 0x34
 802fcae:	89a3      	ldrh	r3, [r4, #12]
 802fcb0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 802fcb4:	81a3      	strh	r3, [r4, #12]
 802fcb6:	2300      	movs	r3, #0
 802fcb8:	6063      	str	r3, [r4, #4]
 802fcba:	6923      	ldr	r3, [r4, #16]
 802fcbc:	6023      	str	r3, [r4, #0]
 802fcbe:	89a3      	ldrh	r3, [r4, #12]
 802fcc0:	f043 0308 	orr.w	r3, r3, #8
 802fcc4:	81a3      	strh	r3, [r4, #12]
 802fcc6:	6923      	ldr	r3, [r4, #16]
 802fcc8:	b94b      	cbnz	r3, 802fcde <__swsetup_r+0x9a>
 802fcca:	89a3      	ldrh	r3, [r4, #12]
 802fccc:	f403 7320 	and.w	r3, r3, #640	; 0x280
 802fcd0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802fcd4:	d003      	beq.n	802fcde <__swsetup_r+0x9a>
 802fcd6:	4621      	mov	r1, r4
 802fcd8:	4630      	mov	r0, r6
 802fcda:	f000 f867 	bl	802fdac <__smakebuf_r>
 802fcde:	89a2      	ldrh	r2, [r4, #12]
 802fce0:	f012 0301 	ands.w	r3, r2, #1
 802fce4:	d00c      	beq.n	802fd00 <__swsetup_r+0xbc>
 802fce6:	2300      	movs	r3, #0
 802fce8:	60a3      	str	r3, [r4, #8]
 802fcea:	6963      	ldr	r3, [r4, #20]
 802fcec:	425b      	negs	r3, r3
 802fcee:	61a3      	str	r3, [r4, #24]
 802fcf0:	6923      	ldr	r3, [r4, #16]
 802fcf2:	b953      	cbnz	r3, 802fd0a <__swsetup_r+0xc6>
 802fcf4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802fcf8:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 802fcfc:	d1ba      	bne.n	802fc74 <__swsetup_r+0x30>
 802fcfe:	bd70      	pop	{r4, r5, r6, pc}
 802fd00:	0792      	lsls	r2, r2, #30
 802fd02:	bf58      	it	pl
 802fd04:	6963      	ldrpl	r3, [r4, #20]
 802fd06:	60a3      	str	r3, [r4, #8]
 802fd08:	e7f2      	b.n	802fcf0 <__swsetup_r+0xac>
 802fd0a:	2000      	movs	r0, #0
 802fd0c:	e7f7      	b.n	802fcfe <__swsetup_r+0xba>
 802fd0e:	bf00      	nop
 802fd10:	200000a4 	.word	0x200000a4
 802fd14:	08030810 	.word	0x08030810
 802fd18:	08030830 	.word	0x08030830
 802fd1c:	080307f0 	.word	0x080307f0

0802fd20 <_close_r>:
 802fd20:	b538      	push	{r3, r4, r5, lr}
 802fd22:	4c06      	ldr	r4, [pc, #24]	; (802fd3c <_close_r+0x1c>)
 802fd24:	2300      	movs	r3, #0
 802fd26:	4605      	mov	r5, r0
 802fd28:	4608      	mov	r0, r1
 802fd2a:	6023      	str	r3, [r4, #0]
 802fd2c:	f7fb f87f 	bl	802ae2e <_close>
 802fd30:	1c43      	adds	r3, r0, #1
 802fd32:	d102      	bne.n	802fd3a <_close_r+0x1a>
 802fd34:	6823      	ldr	r3, [r4, #0]
 802fd36:	b103      	cbz	r3, 802fd3a <_close_r+0x1a>
 802fd38:	602b      	str	r3, [r5, #0]
 802fd3a:	bd38      	pop	{r3, r4, r5, pc}
 802fd3c:	20004308 	.word	0x20004308

0802fd40 <_lseek_r>:
 802fd40:	b538      	push	{r3, r4, r5, lr}
 802fd42:	4c07      	ldr	r4, [pc, #28]	; (802fd60 <_lseek_r+0x20>)
 802fd44:	4605      	mov	r5, r0
 802fd46:	4608      	mov	r0, r1
 802fd48:	4611      	mov	r1, r2
 802fd4a:	2200      	movs	r2, #0
 802fd4c:	6022      	str	r2, [r4, #0]
 802fd4e:	461a      	mov	r2, r3
 802fd50:	f7fb f894 	bl	802ae7c <_lseek>
 802fd54:	1c43      	adds	r3, r0, #1
 802fd56:	d102      	bne.n	802fd5e <_lseek_r+0x1e>
 802fd58:	6823      	ldr	r3, [r4, #0]
 802fd5a:	b103      	cbz	r3, 802fd5e <_lseek_r+0x1e>
 802fd5c:	602b      	str	r3, [r5, #0]
 802fd5e:	bd38      	pop	{r3, r4, r5, pc}
 802fd60:	20004308 	.word	0x20004308

0802fd64 <__swhatbuf_r>:
 802fd64:	b570      	push	{r4, r5, r6, lr}
 802fd66:	460e      	mov	r6, r1
 802fd68:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802fd6c:	2900      	cmp	r1, #0
 802fd6e:	b096      	sub	sp, #88	; 0x58
 802fd70:	4614      	mov	r4, r2
 802fd72:	461d      	mov	r5, r3
 802fd74:	da07      	bge.n	802fd86 <__swhatbuf_r+0x22>
 802fd76:	2300      	movs	r3, #0
 802fd78:	602b      	str	r3, [r5, #0]
 802fd7a:	89b3      	ldrh	r3, [r6, #12]
 802fd7c:	061a      	lsls	r2, r3, #24
 802fd7e:	d410      	bmi.n	802fda2 <__swhatbuf_r+0x3e>
 802fd80:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802fd84:	e00e      	b.n	802fda4 <__swhatbuf_r+0x40>
 802fd86:	466a      	mov	r2, sp
 802fd88:	f000 f864 	bl	802fe54 <_fstat_r>
 802fd8c:	2800      	cmp	r0, #0
 802fd8e:	dbf2      	blt.n	802fd76 <__swhatbuf_r+0x12>
 802fd90:	9a01      	ldr	r2, [sp, #4]
 802fd92:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 802fd96:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 802fd9a:	425a      	negs	r2, r3
 802fd9c:	415a      	adcs	r2, r3
 802fd9e:	602a      	str	r2, [r5, #0]
 802fda0:	e7ee      	b.n	802fd80 <__swhatbuf_r+0x1c>
 802fda2:	2340      	movs	r3, #64	; 0x40
 802fda4:	2000      	movs	r0, #0
 802fda6:	6023      	str	r3, [r4, #0]
 802fda8:	b016      	add	sp, #88	; 0x58
 802fdaa:	bd70      	pop	{r4, r5, r6, pc}

0802fdac <__smakebuf_r>:
 802fdac:	898b      	ldrh	r3, [r1, #12]
 802fdae:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802fdb0:	079d      	lsls	r5, r3, #30
 802fdb2:	4606      	mov	r6, r0
 802fdb4:	460c      	mov	r4, r1
 802fdb6:	d507      	bpl.n	802fdc8 <__smakebuf_r+0x1c>
 802fdb8:	f104 0347 	add.w	r3, r4, #71	; 0x47
 802fdbc:	6023      	str	r3, [r4, #0]
 802fdbe:	6123      	str	r3, [r4, #16]
 802fdc0:	2301      	movs	r3, #1
 802fdc2:	6163      	str	r3, [r4, #20]
 802fdc4:	b002      	add	sp, #8
 802fdc6:	bd70      	pop	{r4, r5, r6, pc}
 802fdc8:	ab01      	add	r3, sp, #4
 802fdca:	466a      	mov	r2, sp
 802fdcc:	f7ff ffca 	bl	802fd64 <__swhatbuf_r>
 802fdd0:	9900      	ldr	r1, [sp, #0]
 802fdd2:	4605      	mov	r5, r0
 802fdd4:	4630      	mov	r0, r6
 802fdd6:	f7ff fb0d 	bl	802f3f4 <_malloc_r>
 802fdda:	b948      	cbnz	r0, 802fdf0 <__smakebuf_r+0x44>
 802fddc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802fde0:	059a      	lsls	r2, r3, #22
 802fde2:	d4ef      	bmi.n	802fdc4 <__smakebuf_r+0x18>
 802fde4:	f023 0303 	bic.w	r3, r3, #3
 802fde8:	f043 0302 	orr.w	r3, r3, #2
 802fdec:	81a3      	strh	r3, [r4, #12]
 802fdee:	e7e3      	b.n	802fdb8 <__smakebuf_r+0xc>
 802fdf0:	4b0d      	ldr	r3, [pc, #52]	; (802fe28 <__smakebuf_r+0x7c>)
 802fdf2:	62b3      	str	r3, [r6, #40]	; 0x28
 802fdf4:	89a3      	ldrh	r3, [r4, #12]
 802fdf6:	6020      	str	r0, [r4, #0]
 802fdf8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802fdfc:	81a3      	strh	r3, [r4, #12]
 802fdfe:	9b00      	ldr	r3, [sp, #0]
 802fe00:	6163      	str	r3, [r4, #20]
 802fe02:	9b01      	ldr	r3, [sp, #4]
 802fe04:	6120      	str	r0, [r4, #16]
 802fe06:	b15b      	cbz	r3, 802fe20 <__smakebuf_r+0x74>
 802fe08:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802fe0c:	4630      	mov	r0, r6
 802fe0e:	f000 f833 	bl	802fe78 <_isatty_r>
 802fe12:	b128      	cbz	r0, 802fe20 <__smakebuf_r+0x74>
 802fe14:	89a3      	ldrh	r3, [r4, #12]
 802fe16:	f023 0303 	bic.w	r3, r3, #3
 802fe1a:	f043 0301 	orr.w	r3, r3, #1
 802fe1e:	81a3      	strh	r3, [r4, #12]
 802fe20:	89a3      	ldrh	r3, [r4, #12]
 802fe22:	431d      	orrs	r5, r3
 802fe24:	81a5      	strh	r5, [r4, #12]
 802fe26:	e7cd      	b.n	802fdc4 <__smakebuf_r+0x18>
 802fe28:	0802f0b9 	.word	0x0802f0b9

0802fe2c <__malloc_lock>:
 802fe2c:	4770      	bx	lr

0802fe2e <__malloc_unlock>:
 802fe2e:	4770      	bx	lr

0802fe30 <_read_r>:
 802fe30:	b538      	push	{r3, r4, r5, lr}
 802fe32:	4c07      	ldr	r4, [pc, #28]	; (802fe50 <_read_r+0x20>)
 802fe34:	4605      	mov	r5, r0
 802fe36:	4608      	mov	r0, r1
 802fe38:	4611      	mov	r1, r2
 802fe3a:	2200      	movs	r2, #0
 802fe3c:	6022      	str	r2, [r4, #0]
 802fe3e:	461a      	mov	r2, r3
 802fe40:	f7fa ffbc 	bl	802adbc <_read>
 802fe44:	1c43      	adds	r3, r0, #1
 802fe46:	d102      	bne.n	802fe4e <_read_r+0x1e>
 802fe48:	6823      	ldr	r3, [r4, #0]
 802fe4a:	b103      	cbz	r3, 802fe4e <_read_r+0x1e>
 802fe4c:	602b      	str	r3, [r5, #0]
 802fe4e:	bd38      	pop	{r3, r4, r5, pc}
 802fe50:	20004308 	.word	0x20004308

0802fe54 <_fstat_r>:
 802fe54:	b538      	push	{r3, r4, r5, lr}
 802fe56:	4c07      	ldr	r4, [pc, #28]	; (802fe74 <_fstat_r+0x20>)
 802fe58:	2300      	movs	r3, #0
 802fe5a:	4605      	mov	r5, r0
 802fe5c:	4608      	mov	r0, r1
 802fe5e:	4611      	mov	r1, r2
 802fe60:	6023      	str	r3, [r4, #0]
 802fe62:	f7fa fff0 	bl	802ae46 <_fstat>
 802fe66:	1c43      	adds	r3, r0, #1
 802fe68:	d102      	bne.n	802fe70 <_fstat_r+0x1c>
 802fe6a:	6823      	ldr	r3, [r4, #0]
 802fe6c:	b103      	cbz	r3, 802fe70 <_fstat_r+0x1c>
 802fe6e:	602b      	str	r3, [r5, #0]
 802fe70:	bd38      	pop	{r3, r4, r5, pc}
 802fe72:	bf00      	nop
 802fe74:	20004308 	.word	0x20004308

0802fe78 <_isatty_r>:
 802fe78:	b538      	push	{r3, r4, r5, lr}
 802fe7a:	4c06      	ldr	r4, [pc, #24]	; (802fe94 <_isatty_r+0x1c>)
 802fe7c:	2300      	movs	r3, #0
 802fe7e:	4605      	mov	r5, r0
 802fe80:	4608      	mov	r0, r1
 802fe82:	6023      	str	r3, [r4, #0]
 802fe84:	f7fa ffef 	bl	802ae66 <_isatty>
 802fe88:	1c43      	adds	r3, r0, #1
 802fe8a:	d102      	bne.n	802fe92 <_isatty_r+0x1a>
 802fe8c:	6823      	ldr	r3, [r4, #0]
 802fe8e:	b103      	cbz	r3, 802fe92 <_isatty_r+0x1a>
 802fe90:	602b      	str	r3, [r5, #0]
 802fe92:	bd38      	pop	{r3, r4, r5, pc}
 802fe94:	20004308 	.word	0x20004308

0802fe98 <sqrt>:
 802fe98:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802fe9c:	ed2d 8b02 	vpush	{d8}
 802fea0:	b08b      	sub	sp, #44	; 0x2c
 802fea2:	ec55 4b10 	vmov	r4, r5, d0
 802fea6:	f000 f851 	bl	802ff4c <__ieee754_sqrt>
 802feaa:	4b26      	ldr	r3, [pc, #152]	; (802ff44 <sqrt+0xac>)
 802feac:	eeb0 8a40 	vmov.f32	s16, s0
 802feb0:	eef0 8a60 	vmov.f32	s17, s1
 802feb4:	f993 6000 	ldrsb.w	r6, [r3]
 802feb8:	1c73      	adds	r3, r6, #1
 802feba:	d02a      	beq.n	802ff12 <sqrt+0x7a>
 802febc:	4622      	mov	r2, r4
 802febe:	462b      	mov	r3, r5
 802fec0:	4620      	mov	r0, r4
 802fec2:	4629      	mov	r1, r5
 802fec4:	f7f8 fa8a 	bl	80283dc <__aeabi_dcmpun>
 802fec8:	4607      	mov	r7, r0
 802feca:	bb10      	cbnz	r0, 802ff12 <sqrt+0x7a>
 802fecc:	f04f 0800 	mov.w	r8, #0
 802fed0:	f04f 0900 	mov.w	r9, #0
 802fed4:	4642      	mov	r2, r8
 802fed6:	464b      	mov	r3, r9
 802fed8:	4620      	mov	r0, r4
 802feda:	4629      	mov	r1, r5
 802fedc:	f7f8 fa56 	bl	802838c <__aeabi_dcmplt>
 802fee0:	b1b8      	cbz	r0, 802ff12 <sqrt+0x7a>
 802fee2:	2301      	movs	r3, #1
 802fee4:	9300      	str	r3, [sp, #0]
 802fee6:	4b18      	ldr	r3, [pc, #96]	; (802ff48 <sqrt+0xb0>)
 802fee8:	9301      	str	r3, [sp, #4]
 802feea:	9708      	str	r7, [sp, #32]
 802feec:	e9cd 4504 	strd	r4, r5, [sp, #16]
 802fef0:	e9cd 4502 	strd	r4, r5, [sp, #8]
 802fef4:	b9b6      	cbnz	r6, 802ff24 <sqrt+0x8c>
 802fef6:	e9cd 8906 	strd	r8, r9, [sp, #24]
 802fefa:	4668      	mov	r0, sp
 802fefc:	f000 f8d6 	bl	80300ac <matherr>
 802ff00:	b1d0      	cbz	r0, 802ff38 <sqrt+0xa0>
 802ff02:	9b08      	ldr	r3, [sp, #32]
 802ff04:	b11b      	cbz	r3, 802ff0e <sqrt+0x76>
 802ff06:	f7fe ffeb 	bl	802eee0 <__errno>
 802ff0a:	9b08      	ldr	r3, [sp, #32]
 802ff0c:	6003      	str	r3, [r0, #0]
 802ff0e:	ed9d 8b06 	vldr	d8, [sp, #24]
 802ff12:	eeb0 0a48 	vmov.f32	s0, s16
 802ff16:	eef0 0a68 	vmov.f32	s1, s17
 802ff1a:	b00b      	add	sp, #44	; 0x2c
 802ff1c:	ecbd 8b02 	vpop	{d8}
 802ff20:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802ff24:	4642      	mov	r2, r8
 802ff26:	464b      	mov	r3, r9
 802ff28:	4640      	mov	r0, r8
 802ff2a:	4649      	mov	r1, r9
 802ff2c:	f7f8 f8e6 	bl	80280fc <__aeabi_ddiv>
 802ff30:	2e02      	cmp	r6, #2
 802ff32:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ff36:	d1e0      	bne.n	802fefa <sqrt+0x62>
 802ff38:	f7fe ffd2 	bl	802eee0 <__errno>
 802ff3c:	2321      	movs	r3, #33	; 0x21
 802ff3e:	6003      	str	r3, [r0, #0]
 802ff40:	e7df      	b.n	802ff02 <sqrt+0x6a>
 802ff42:	bf00      	nop
 802ff44:	20000108 	.word	0x20000108
 802ff48:	08030887 	.word	0x08030887

0802ff4c <__ieee754_sqrt>:
 802ff4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802ff50:	4955      	ldr	r1, [pc, #340]	; (80300a8 <__ieee754_sqrt+0x15c>)
 802ff52:	ec55 4b10 	vmov	r4, r5, d0
 802ff56:	43a9      	bics	r1, r5
 802ff58:	462b      	mov	r3, r5
 802ff5a:	462a      	mov	r2, r5
 802ff5c:	d112      	bne.n	802ff84 <__ieee754_sqrt+0x38>
 802ff5e:	ee10 2a10 	vmov	r2, s0
 802ff62:	ee10 0a10 	vmov	r0, s0
 802ff66:	4629      	mov	r1, r5
 802ff68:	f7f7 ff9e 	bl	8027ea8 <__aeabi_dmul>
 802ff6c:	4602      	mov	r2, r0
 802ff6e:	460b      	mov	r3, r1
 802ff70:	4620      	mov	r0, r4
 802ff72:	4629      	mov	r1, r5
 802ff74:	f7f7 fde2 	bl	8027b3c <__adddf3>
 802ff78:	4604      	mov	r4, r0
 802ff7a:	460d      	mov	r5, r1
 802ff7c:	ec45 4b10 	vmov	d0, r4, r5
 802ff80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802ff84:	2d00      	cmp	r5, #0
 802ff86:	ee10 0a10 	vmov	r0, s0
 802ff8a:	4621      	mov	r1, r4
 802ff8c:	dc0f      	bgt.n	802ffae <__ieee754_sqrt+0x62>
 802ff8e:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
 802ff92:	4330      	orrs	r0, r6
 802ff94:	d0f2      	beq.n	802ff7c <__ieee754_sqrt+0x30>
 802ff96:	b155      	cbz	r5, 802ffae <__ieee754_sqrt+0x62>
 802ff98:	ee10 2a10 	vmov	r2, s0
 802ff9c:	4620      	mov	r0, r4
 802ff9e:	4629      	mov	r1, r5
 802ffa0:	f7f7 fdca 	bl	8027b38 <__aeabi_dsub>
 802ffa4:	4602      	mov	r2, r0
 802ffa6:	460b      	mov	r3, r1
 802ffa8:	f7f8 f8a8 	bl	80280fc <__aeabi_ddiv>
 802ffac:	e7e4      	b.n	802ff78 <__ieee754_sqrt+0x2c>
 802ffae:	151b      	asrs	r3, r3, #20
 802ffb0:	d073      	beq.n	803009a <__ieee754_sqrt+0x14e>
 802ffb2:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 802ffb6:	07dd      	lsls	r5, r3, #31
 802ffb8:	f3c2 0213 	ubfx	r2, r2, #0, #20
 802ffbc:	bf48      	it	mi
 802ffbe:	0fc8      	lsrmi	r0, r1, #31
 802ffc0:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 802ffc4:	bf44      	itt	mi
 802ffc6:	0049      	lslmi	r1, r1, #1
 802ffc8:	eb00 0242 	addmi.w	r2, r0, r2, lsl #1
 802ffcc:	2500      	movs	r5, #0
 802ffce:	1058      	asrs	r0, r3, #1
 802ffd0:	0fcb      	lsrs	r3, r1, #31
 802ffd2:	eb03 0242 	add.w	r2, r3, r2, lsl #1
 802ffd6:	0049      	lsls	r1, r1, #1
 802ffd8:	2316      	movs	r3, #22
 802ffda:	462c      	mov	r4, r5
 802ffdc:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 802ffe0:	19a7      	adds	r7, r4, r6
 802ffe2:	4297      	cmp	r7, r2
 802ffe4:	bfde      	ittt	le
 802ffe6:	19bc      	addle	r4, r7, r6
 802ffe8:	1bd2      	suble	r2, r2, r7
 802ffea:	19ad      	addle	r5, r5, r6
 802ffec:	0fcf      	lsrs	r7, r1, #31
 802ffee:	3b01      	subs	r3, #1
 802fff0:	eb07 0242 	add.w	r2, r7, r2, lsl #1
 802fff4:	ea4f 0141 	mov.w	r1, r1, lsl #1
 802fff8:	ea4f 0656 	mov.w	r6, r6, lsr #1
 802fffc:	d1f0      	bne.n	802ffe0 <__ieee754_sqrt+0x94>
 802fffe:	f04f 0c20 	mov.w	ip, #32
 8030002:	469e      	mov	lr, r3
 8030004:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
 8030008:	42a2      	cmp	r2, r4
 803000a:	eb06 070e 	add.w	r7, r6, lr
 803000e:	dc02      	bgt.n	8030016 <__ieee754_sqrt+0xca>
 8030010:	d112      	bne.n	8030038 <__ieee754_sqrt+0xec>
 8030012:	428f      	cmp	r7, r1
 8030014:	d810      	bhi.n	8030038 <__ieee754_sqrt+0xec>
 8030016:	2f00      	cmp	r7, #0
 8030018:	eb07 0e06 	add.w	lr, r7, r6
 803001c:	da42      	bge.n	80300a4 <__ieee754_sqrt+0x158>
 803001e:	f1be 0f00 	cmp.w	lr, #0
 8030022:	db3f      	blt.n	80300a4 <__ieee754_sqrt+0x158>
 8030024:	f104 0801 	add.w	r8, r4, #1
 8030028:	1b12      	subs	r2, r2, r4
 803002a:	428f      	cmp	r7, r1
 803002c:	bf88      	it	hi
 803002e:	f102 32ff 	addhi.w	r2, r2, #4294967295
 8030032:	1bc9      	subs	r1, r1, r7
 8030034:	4433      	add	r3, r6
 8030036:	4644      	mov	r4, r8
 8030038:	0052      	lsls	r2, r2, #1
 803003a:	f1bc 0c01 	subs.w	ip, ip, #1
 803003e:	eb02 72d1 	add.w	r2, r2, r1, lsr #31
 8030042:	ea4f 0656 	mov.w	r6, r6, lsr #1
 8030046:	ea4f 0141 	mov.w	r1, r1, lsl #1
 803004a:	d1dd      	bne.n	8030008 <__ieee754_sqrt+0xbc>
 803004c:	430a      	orrs	r2, r1
 803004e:	d006      	beq.n	803005e <__ieee754_sqrt+0x112>
 8030050:	1c5c      	adds	r4, r3, #1
 8030052:	bf13      	iteet	ne
 8030054:	3301      	addne	r3, #1
 8030056:	3501      	addeq	r5, #1
 8030058:	4663      	moveq	r3, ip
 803005a:	f023 0301 	bicne.w	r3, r3, #1
 803005e:	106a      	asrs	r2, r5, #1
 8030060:	085b      	lsrs	r3, r3, #1
 8030062:	07e9      	lsls	r1, r5, #31
 8030064:	f102 527f 	add.w	r2, r2, #1069547520	; 0x3fc00000
 8030068:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
 803006c:	bf48      	it	mi
 803006e:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
 8030072:	eb02 5500 	add.w	r5, r2, r0, lsl #20
 8030076:	461c      	mov	r4, r3
 8030078:	e780      	b.n	802ff7c <__ieee754_sqrt+0x30>
 803007a:	0aca      	lsrs	r2, r1, #11
 803007c:	3815      	subs	r0, #21
 803007e:	0549      	lsls	r1, r1, #21
 8030080:	2a00      	cmp	r2, #0
 8030082:	d0fa      	beq.n	803007a <__ieee754_sqrt+0x12e>
 8030084:	02d6      	lsls	r6, r2, #11
 8030086:	d50a      	bpl.n	803009e <__ieee754_sqrt+0x152>
 8030088:	f1c3 0420 	rsb	r4, r3, #32
 803008c:	fa21 f404 	lsr.w	r4, r1, r4
 8030090:	1e5d      	subs	r5, r3, #1
 8030092:	4099      	lsls	r1, r3
 8030094:	4322      	orrs	r2, r4
 8030096:	1b43      	subs	r3, r0, r5
 8030098:	e78b      	b.n	802ffb2 <__ieee754_sqrt+0x66>
 803009a:	4618      	mov	r0, r3
 803009c:	e7f0      	b.n	8030080 <__ieee754_sqrt+0x134>
 803009e:	0052      	lsls	r2, r2, #1
 80300a0:	3301      	adds	r3, #1
 80300a2:	e7ef      	b.n	8030084 <__ieee754_sqrt+0x138>
 80300a4:	46a0      	mov	r8, r4
 80300a6:	e7bf      	b.n	8030028 <__ieee754_sqrt+0xdc>
 80300a8:	7ff00000 	.word	0x7ff00000

080300ac <matherr>:
 80300ac:	2000      	movs	r0, #0
 80300ae:	4770      	bx	lr

080300b0 <_init>:
 80300b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80300b2:	bf00      	nop
 80300b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80300b6:	bc08      	pop	{r3}
 80300b8:	469e      	mov	lr, r3
 80300ba:	4770      	bx	lr

080300bc <_fini>:
 80300bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80300be:	bf00      	nop
 80300c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80300c2:	bc08      	pop	{r3}
 80300c4:	469e      	mov	lr, r3
 80300c6:	4770      	bx	lr
